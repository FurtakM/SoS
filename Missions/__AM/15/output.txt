// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33689 0 0
// InitNature ;
  19: CALL 33513 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10792 0 0
// PrepareRussian ;
  40: CALL 6785 0 0
// PrepareLegion ;
  44: CALL 4025 0 0
// PreparePowell ;
  48: CALL 2779 0 0
// PrepareAmerican ;
  52: CALL 1602 0 0
// Action ;
  56: CALL 14699 0 0
// MC_Start ( ) ;
  60: CALL 35801 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 57599 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 57692 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57105 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 56920 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 57599 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 57692 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 24
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 47
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 24
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 47
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 56920 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 802: LD_INT 2
 804: PPUSH
 805: LD_INT 5
 807: PPUSH
 808: CALL 57105 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 812: LD_INT 2
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL 57472 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 822: LD_INT 3
 824: PPUSH
 825: LD_INT 10
 827: PUSH
 828: LD_INT 12
 830: PUSH
 831: LD_INT 15
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: LIST
 838: PUSH
 839: LD_OWVAR 67
 843: ARRAY
 844: PPUSH
 845: LD_INT 27
 847: PPUSH
 848: CALL 56602 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 852: LD_INT 3
 854: PPUSH
 855: LD_INT 10
 857: PUSH
 858: LD_INT 11
 860: PUSH
 861: LD_INT 13
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL 57599 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 15
 882: PUSH
 883: EMPTY
 884: LIST
 885: PPUSH
 886: CALL 57692 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 890: LD_ADDR_EXP 128
 894: PUSH
 895: LD_EXP 128
 899: PPUSH
 900: LD_INT 3
 902: PPUSH
 903: LD_INT 22
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 25
 915: PUSH
 916: LD_INT 15
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL_OW 69
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 13
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 31
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 13
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 31
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 13
 978: PUSH
 979: LD_INT 3
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: LD_INT 32
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: LIST
 992: LIST
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: PPUSH
 999: CALL 56920 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1003: LD_INT 4
1005: PPUSH
1006: LD_INT 10
1008: PUSH
1009: LD_INT 12
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL 57599 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1020: LD_INT 4
1022: PPUSH
1023: LD_INT 9
1025: PUSH
1026: EMPTY
1027: LIST
1028: PPUSH
1029: CALL 57692 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1033: LD_INT 4
1035: PPUSH
1036: LD_INT 26
1038: PUSH
1039: LD_INT 74
1041: PUSH
1042: LD_INT 107
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: LD_INT 77
1059: PUSH
1060: LD_INT 101
1062: PUSH
1063: LD_INT 4
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_INT 32
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 86
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_INT 27
1092: PUSH
1093: LD_INT 77
1095: PUSH
1096: LD_INT 110
1098: PUSH
1099: LD_INT 3
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 27
1110: PUSH
1111: LD_INT 42
1113: PUSH
1114: LD_INT 79
1116: PUSH
1117: LD_INT 5
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 29
1128: PUSH
1129: LD_INT 86
1131: PUSH
1132: LD_INT 105
1134: PUSH
1135: LD_INT 2
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 30
1146: PUSH
1147: LD_INT 40
1149: PUSH
1150: LD_INT 75
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 80
1167: PUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: LD_INT 75
1185: PUSH
1186: LD_INT 114
1188: PUSH
1189: LD_INT 5
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 32
1200: PUSH
1201: LD_INT 82
1203: PUSH
1204: LD_INT 110
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 62
1221: PUSH
1222: LD_INT 78
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 4
1236: PUSH
1237: LD_INT 39
1239: PUSH
1240: LD_INT 61
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 56812 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 5
1275: PUSH
1276: LD_INT 6
1278: PUSH
1279: LD_INT 7
1281: PUSH
1282: LD_INT 9
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PPUSH
1291: CALL 58010 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 40
1300: PUSH
1301: LD_INT 75
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_INT 86
1314: PUSH
1315: LD_INT 105
1317: PUSH
1318: LD_INT 0
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL 57244 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 2
1339: PPUSH
1340: CALL 57472 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1344: LD_INT 4
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 57472 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 54
1359: PPUSH
1360: LD_INT 85
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: LD_INT 19
1368: PUSH
1369: LD_INT 16
1371: PUSH
1372: LD_INT 17
1374: PUSH
1375: LD_INT 18
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 57804 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 4
1411: PUSH
1412: LD_INT 1
1414: PUSH
1415: LD_INT 1
1417: PUSH
1418: LD_INT 6
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_INT 4
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 7
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 4
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PPUSH
1469: CALL 56920 0 2
// MC_SetTame ( 4 , powellApe ) ;
1473: LD_INT 4
1475: PPUSH
1476: LD_INT 13
1478: PPUSH
1479: CALL 57423 0 2
// end ;
1483: LD_VAR 0 1
1487: RET
// every 0 0$1 trigger debug do var i , tmp ;
1488: LD_EXP 1
1492: IFFALSE 1599
1494: GO 1496
1496: DISABLE
1497: LD_INT 0
1499: PPUSH
1500: PPUSH
// begin enable ;
1501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1502: LD_ADDR_VAR 0 2
1506: PUSH
1507: LD_INT 22
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 21
1522: PUSH
1523: LD_INT 3
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 3
1536: PUSH
1537: LD_INT 24
1539: PUSH
1540: LD_INT 999
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PPUSH
1556: CALL_OW 69
1560: ST_TO_ADDR
// if not tmp then
1561: LD_VAR 0 2
1565: NOT
1566: IFFALSE 1570
// exit ;
1568: GO 1599
// for i in tmp do
1570: LD_ADDR_VAR 0 1
1574: PUSH
1575: LD_VAR 0 2
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1597
// SetLives ( i , 1000 ) ;
1583: LD_VAR 0 1
1587: PPUSH
1588: LD_INT 1000
1590: PPUSH
1591: CALL_OW 234
1595: GO 1580
1597: POP
1598: POP
// end ; end_of_file
1599: PPOPN 2
1601: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1602: LD_INT 0
1604: PPUSH
// uc_side := 1 ;
1605: LD_ADDR_OWVAR 20
1609: PUSH
1610: LD_INT 1
1612: ST_TO_ADDR
// uc_nation := 1 ;
1613: LD_ADDR_OWVAR 21
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1621: LD_ADDR_EXP 36
1625: PUSH
1626: LD_STRING JMM
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 14_
1637: PPUSH
1638: CALL 62900 0 3
1642: ST_TO_ADDR
// if not JMMVeh then
1643: LD_EXP 4
1647: NOT
1648: IFFALSE 1671
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1650: LD_INT 3
1652: PPUSH
1653: LD_INT 3
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: LD_INT 100
1664: PPUSH
1665: CALL 69533 0 5
1669: GO 1730
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1671: LD_EXP 4
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_EXP 4
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PUSH
1693: LD_INT 1
1695: ARRAY
1696: PPUSH
1697: LD_EXP 4
1701: PUSH
1702: LD_INT 3
1704: ARRAY
1705: PUSH
1706: LD_INT 1
1708: ARRAY
1709: PPUSH
1710: LD_EXP 4
1714: PUSH
1715: LD_INT 4
1717: ARRAY
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: PPUSH
1723: LD_INT 30
1725: PPUSH
1726: CALL 69533 0 5
// JMMNewVeh := CreateVehicle ;
1730: LD_ADDR_EXP 53
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1740: LD_EXP 53
1744: PPUSH
1745: LD_INT 4
1747: PPUSH
1748: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1752: LD_EXP 53
1756: PPUSH
1757: LD_INT 75
1759: PPUSH
1760: LD_INT 92
1762: PPUSH
1763: LD_INT 0
1765: PPUSH
1766: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1770: LD_EXP 36
1774: PPUSH
1775: LD_EXP 53
1779: PPUSH
1780: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1784: LD_EXP 6
1788: PUSH
1789: LD_EXP 2
1793: NOT
1794: AND
1795: IFFALSE 2053
// begin if not JMMGirlVeh then
1797: LD_EXP 5
1801: NOT
1802: IFFALSE 1825
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1804: LD_INT 3
1806: PPUSH
1807: LD_INT 3
1809: PPUSH
1810: LD_INT 1
1812: PPUSH
1813: LD_INT 9
1815: PPUSH
1816: LD_INT 100
1818: PPUSH
1819: CALL 69533 0 5
1823: GO 1884
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1825: LD_EXP 5
1829: PUSH
1830: LD_INT 1
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 5
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_EXP 5
1855: PUSH
1856: LD_INT 3
1858: ARRAY
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PPUSH
1864: LD_EXP 5
1868: PUSH
1869: LD_INT 4
1871: ARRAY
1872: PUSH
1873: LD_INT 1
1875: ARRAY
1876: PPUSH
1877: LD_INT 30
1879: PPUSH
1880: CALL 69533 0 5
// GirlNewVeh := CreateVehicle ;
1884: LD_ADDR_EXP 54
1888: PUSH
1889: CALL_OW 45
1893: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1894: LD_EXP 54
1898: PPUSH
1899: LD_INT 4
1901: PPUSH
1902: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1906: LD_EXP 54
1910: PPUSH
1911: LD_INT 82
1913: PPUSH
1914: LD_INT 96
1916: PPUSH
1917: LD_INT 0
1919: PPUSH
1920: CALL_OW 48
// if JMMGirl = 1 then
1924: LD_EXP 7
1928: PUSH
1929: LD_INT 1
1931: EQUAL
1932: IFFALSE 1967
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1934: LD_ADDR_EXP 37
1938: PUSH
1939: LD_STRING Joan
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_STRING 14_
1947: PPUSH
1948: CALL 62900 0 3
1952: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1953: LD_EXP 37
1957: PPUSH
1958: LD_EXP 54
1962: PPUSH
1963: CALL_OW 52
// end ; if JMMGirl = 2 then
1967: LD_EXP 7
1971: PUSH
1972: LD_INT 2
1974: EQUAL
1975: IFFALSE 2010
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1977: LD_ADDR_EXP 39
1981: PUSH
1982: LD_STRING Lisa
1984: PPUSH
1985: LD_INT 1
1987: PPUSH
1988: LD_STRING 14_
1990: PPUSH
1991: CALL 62900 0 3
1995: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1996: LD_EXP 39
2000: PPUSH
2001: LD_EXP 54
2005: PPUSH
2006: CALL_OW 52
// end ; if JMMGirl = 3 then
2010: LD_EXP 7
2014: PUSH
2015: LD_INT 3
2017: EQUAL
2018: IFFALSE 2053
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2020: LD_ADDR_EXP 51
2024: PUSH
2025: LD_STRING Connie
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_STRING 14_
2033: PPUSH
2034: CALL 62900 0 3
2038: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2039: LD_EXP 51
2043: PPUSH
2044: LD_EXP 54
2048: PPUSH
2049: CALL_OW 52
// end ; end ; end ;
2053: LD_VAR 0 1
2057: RET
// export function PrepareStevensSquad ; var tmp ; begin
2058: LD_INT 0
2060: PPUSH
2061: PPUSH
// uc_side := 1 ;
2062: LD_ADDR_OWVAR 20
2066: PUSH
2067: LD_INT 1
2069: ST_TO_ADDR
// uc_nation := 1 ;
2070: LD_ADDR_OWVAR 21
2074: PUSH
2075: LD_INT 1
2077: ST_TO_ADDR
// tmp := [ ] ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: EMPTY
2084: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2085: LD_ADDR_EXP 38
2089: PUSH
2090: LD_STRING Stevens
2092: PPUSH
2093: LD_EXP 1
2097: NOT
2098: PPUSH
2099: LD_STRING 13f_
2101: PPUSH
2102: CALL 62900 0 3
2106: ST_TO_ADDR
// if not Stevens then
2107: LD_EXP 38
2111: NOT
2112: IFFALSE 2168
// begin hc_name = Baker Smith ;
2114: LD_ADDR_OWVAR 26
2118: PUSH
2119: LD_STRING Baker Smith
2121: ST_TO_ADDR
// hc_gallery =  ;
2122: LD_ADDR_OWVAR 33
2126: PUSH
2127: LD_STRING 
2129: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 10
2135: PPUSH
2136: CALL_OW 384
// Baker = CreateHuman ;
2140: LD_ADDR_EXP 52
2144: PUSH
2145: CALL_OW 44
2149: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2150: LD_ADDR_VAR 0 2
2154: PUSH
2155: LD_VAR 0 2
2159: PUSH
2160: LD_EXP 52
2164: ADD
2165: ST_TO_ADDR
// end else
2166: GO 2184
// tmp := tmp ^ Stevens ;
2168: LD_ADDR_VAR 0 2
2172: PUSH
2173: LD_VAR 0 2
2177: PUSH
2178: LD_EXP 38
2182: ADD
2183: ST_TO_ADDR
// if not Lisa then
2184: LD_EXP 39
2188: NOT
2189: IFFALSE 2235
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2191: LD_ADDR_EXP 39
2195: PUSH
2196: LD_STRING Lisa
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13f_
2207: PPUSH
2208: CALL 62900 0 3
2212: ST_TO_ADDR
// if Lisa then
2213: LD_EXP 39
2217: IFFALSE 2235
// tmp := tmp ^ Lisa ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_VAR 0 2
2228: PUSH
2229: LD_EXP 39
2233: ADD
2234: ST_TO_ADDR
// end ; if not Donaldson then
2235: LD_EXP 40
2239: NOT
2240: IFFALSE 2286
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2242: LD_ADDR_EXP 40
2246: PUSH
2247: LD_STRING Donaldson
2249: PPUSH
2250: LD_EXP 1
2254: NOT
2255: PPUSH
2256: LD_STRING 13f_
2258: PPUSH
2259: CALL 62900 0 3
2263: ST_TO_ADDR
// if Donaldson then
2264: LD_EXP 40
2268: IFFALSE 2286
// tmp := tmp ^ Donaldson ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 40
2284: ADD
2285: ST_TO_ADDR
// end ; if not Bobby then
2286: LD_EXP 41
2290: NOT
2291: IFFALSE 2337
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2293: LD_ADDR_EXP 41
2297: PUSH
2298: LD_STRING Bobby
2300: PPUSH
2301: LD_EXP 1
2305: NOT
2306: PPUSH
2307: LD_STRING 13f_
2309: PPUSH
2310: CALL 62900 0 3
2314: ST_TO_ADDR
// if Bobby then
2315: LD_EXP 41
2319: IFFALSE 2337
// tmp := tmp ^ Bobby ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_VAR 0 2
2330: PUSH
2331: LD_EXP 41
2335: ADD
2336: ST_TO_ADDR
// end ; if not Cyrus then
2337: LD_EXP 42
2341: NOT
2342: IFFALSE 2388
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2344: LD_ADDR_EXP 42
2348: PUSH
2349: LD_STRING Cyrus
2351: PPUSH
2352: LD_EXP 1
2356: NOT
2357: PPUSH
2358: LD_STRING 13f_
2360: PPUSH
2361: CALL 62900 0 3
2365: ST_TO_ADDR
// if Cyrus then
2366: LD_EXP 42
2370: IFFALSE 2388
// tmp := tmp ^ Cyrus ;
2372: LD_ADDR_VAR 0 2
2376: PUSH
2377: LD_VAR 0 2
2381: PUSH
2382: LD_EXP 42
2386: ADD
2387: ST_TO_ADDR
// end ; if not Brown then
2388: LD_EXP 44
2392: NOT
2393: IFFALSE 2439
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2395: LD_ADDR_EXP 44
2399: PUSH
2400: LD_STRING Brown
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13f_
2411: PPUSH
2412: CALL 62900 0 3
2416: ST_TO_ADDR
// if Brown then
2417: LD_EXP 44
2421: IFFALSE 2439
// tmp := tmp ^ Brown ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 44
2437: ADD
2438: ST_TO_ADDR
// end ; if not Gladstone then
2439: LD_EXP 45
2443: NOT
2444: IFFALSE 2490
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2446: LD_ADDR_EXP 45
2450: PUSH
2451: LD_STRING Gladstone
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13f_
2462: PPUSH
2463: CALL 62900 0 3
2467: ST_TO_ADDR
// if Gladstone then
2468: LD_EXP 45
2472: IFFALSE 2490
// tmp := tmp ^ Gladstone ;
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 2
2483: PUSH
2484: LD_EXP 45
2488: ADD
2489: ST_TO_ADDR
// end ; if not Houten then
2490: LD_EXP 46
2494: NOT
2495: IFFALSE 2541
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2497: LD_ADDR_EXP 46
2501: PUSH
2502: LD_STRING Houten
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13f_
2513: PPUSH
2514: CALL 62900 0 3
2518: ST_TO_ADDR
// if Houten then
2519: LD_EXP 46
2523: IFFALSE 2541
// tmp := tmp ^ Houten ;
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: LD_VAR 0 2
2534: PUSH
2535: LD_EXP 46
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cornel then
2541: LD_EXP 47
2545: NOT
2546: IFFALSE 2592
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2548: LD_ADDR_EXP 47
2552: PUSH
2553: LD_STRING Cornel
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13f_
2564: PPUSH
2565: CALL 62900 0 3
2569: ST_TO_ADDR
// if Cornel then
2570: LD_EXP 47
2574: IFFALSE 2592
// tmp := tmp ^ Cornel ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_VAR 0 2
2585: PUSH
2586: LD_EXP 47
2590: ADD
2591: ST_TO_ADDR
// end ; if not Gary then
2592: LD_EXP 48
2596: NOT
2597: IFFALSE 2643
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2599: LD_ADDR_EXP 48
2603: PUSH
2604: LD_STRING Gary
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13f_
2615: PPUSH
2616: CALL 62900 0 3
2620: ST_TO_ADDR
// if Gary then
2621: LD_EXP 48
2625: IFFALSE 2643
// tmp := tmp ^ Gary ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: LD_EXP 48
2641: ADD
2642: ST_TO_ADDR
// end ; if not Frank then
2643: LD_EXP 49
2647: NOT
2648: IFFALSE 2694
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2650: LD_ADDR_EXP 49
2654: PUSH
2655: LD_STRING Frank
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13f_
2666: PPUSH
2667: CALL 62900 0 3
2671: ST_TO_ADDR
// if Frank then
2672: LD_EXP 49
2676: IFFALSE 2694
// tmp := tmp ^ Frank ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 49
2692: ADD
2693: ST_TO_ADDR
// end ; if not Kikuchi then
2694: LD_EXP 50
2698: NOT
2699: IFFALSE 2745
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2701: LD_ADDR_EXP 50
2705: PUSH
2706: LD_STRING Kikuchi
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13f_
2717: PPUSH
2718: CALL 62900 0 3
2722: ST_TO_ADDR
// if Kikuchi then
2723: LD_EXP 50
2727: IFFALSE 2745
// tmp := tmp ^ Kikuchi ;
2729: LD_ADDR_VAR 0 2
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: LD_EXP 50
2743: ADD
2744: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2745: LD_ADDR_VAR 0 2
2749: PUSH
2750: LD_VAR 0 2
2754: PUSH
2755: LD_STRING 13_other_survivors
2757: PPUSH
2758: CALL_OW 31
2762: UNION
2763: ST_TO_ADDR
// result := tmp ;
2764: LD_ADDR_VAR 0 1
2768: PUSH
2769: LD_VAR 0 2
2773: ST_TO_ADDR
// end ; end_of_file
2774: LD_VAR 0 1
2778: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
2783: PPUSH
2784: PPUSH
2785: PPUSH
2786: PPUSH
2787: PPUSH
2788: PPUSH
2789: PPUSH
2790: PPUSH
// uc_side := 4 ;
2791: LD_ADDR_OWVAR 20
2795: PUSH
2796: LD_INT 4
2798: ST_TO_ADDR
// uc_nation := 1 ;
2799: LD_ADDR_OWVAR 21
2803: PUSH
2804: LD_INT 1
2806: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2807: LD_INT 387
2809: PPUSH
2810: CALL_OW 274
2814: PPUSH
2815: LD_INT 1
2817: PPUSH
2818: LD_INT 2500
2820: PPUSH
2821: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2825: LD_INT 387
2827: PPUSH
2828: CALL_OW 274
2832: PPUSH
2833: LD_INT 2
2835: PPUSH
2836: LD_INT 400
2838: PPUSH
2839: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2843: LD_INT 387
2845: PPUSH
2846: CALL_OW 274
2850: PPUSH
2851: LD_INT 3
2853: PPUSH
2854: LD_INT 10
2856: PPUSH
2857: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2861: LD_ADDR_EXP 55
2865: PUSH
2866: LD_STRING Powell
2868: PPUSH
2869: CALL_OW 25
2873: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2874: LD_EXP 55
2878: PPUSH
2879: LD_INT 57
2881: PPUSH
2882: LD_INT 94
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2892: LD_EXP 55
2896: PPUSH
2897: LD_INT 58
2899: PPUSH
2900: LD_INT 94
2902: PPUSH
2903: CALL_OW 118
// vip := [ ] ;
2907: LD_ADDR_EXP 56
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// tmp := [ ] ;
2914: LD_ADDR_VAR 0 6
2918: PUSH
2919: EMPTY
2920: ST_TO_ADDR
// if JMMGirl <> 2 then
2921: LD_EXP 7
2925: PUSH
2926: LD_INT 2
2928: NONEQUAL
2929: IFFALSE 2953
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2931: LD_ADDR_EXP 39
2935: PUSH
2936: LD_STRING Lisa
2938: PPUSH
2939: LD_EXP 1
2943: NOT
2944: PPUSH
2945: LD_STRING 13s_
2947: PPUSH
2948: CALL 62900 0 3
2952: ST_TO_ADDR
// if Lisa then
2953: LD_EXP 39
2957: IFFALSE 2975
// tmp := tmp ^ Lisa ;
2959: LD_ADDR_VAR 0 6
2963: PUSH
2964: LD_VAR 0 6
2968: PUSH
2969: LD_EXP 39
2973: ADD
2974: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2975: LD_ADDR_EXP 40
2979: PUSH
2980: LD_STRING Donaldson
2982: PPUSH
2983: LD_EXP 1
2987: NOT
2988: PPUSH
2989: LD_STRING 13s_
2991: PPUSH
2992: CALL 62900 0 3
2996: ST_TO_ADDR
// if Donaldson then
2997: LD_EXP 40
3001: IFFALSE 3019
// tmp := tmp ^ Donaldson ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: LD_VAR 0 6
3012: PUSH
3013: LD_EXP 40
3017: ADD
3018: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3019: LD_ADDR_EXP 41
3023: PUSH
3024: LD_STRING Bobby
3026: PPUSH
3027: LD_EXP 1
3031: NOT
3032: PPUSH
3033: LD_STRING 13s_
3035: PPUSH
3036: CALL 62900 0 3
3040: ST_TO_ADDR
// if Bobby then
3041: LD_EXP 41
3045: IFFALSE 3063
// tmp := tmp ^ Bobby ;
3047: LD_ADDR_VAR 0 6
3051: PUSH
3052: LD_VAR 0 6
3056: PUSH
3057: LD_EXP 41
3061: ADD
3062: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 42
3067: PUSH
3068: LD_STRING Cyrus
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 62900 0 3
3084: ST_TO_ADDR
// if Cyrus then
3085: LD_EXP 42
3089: IFFALSE 3107
// tmp := tmp ^ Cyrus ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 42
3105: ADD
3106: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 43
3111: PUSH
3112: LD_STRING Denis
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 62900 0 3
3128: ST_TO_ADDR
// if not Denis then
3129: LD_EXP 43
3133: NOT
3134: IFFALSE 3158
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 43
3140: PUSH
3141: LD_STRING Denis
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 62900 0 3
3157: ST_TO_ADDR
// if Denis then
3158: LD_EXP 43
3162: IFFALSE 3180
// tmp := tmp ^ Denis ;
3164: LD_ADDR_VAR 0 6
3168: PUSH
3169: LD_VAR 0 6
3173: PUSH
3174: LD_EXP 43
3178: ADD
3179: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3180: LD_ADDR_EXP 44
3184: PUSH
3185: LD_STRING Brown
3187: PPUSH
3188: LD_EXP 1
3192: NOT
3193: PPUSH
3194: LD_STRING 13s_
3196: PPUSH
3197: CALL 62900 0 3
3201: ST_TO_ADDR
// if Brown then
3202: LD_EXP 44
3206: IFFALSE 3224
// tmp := tmp ^ Brown ;
3208: LD_ADDR_VAR 0 6
3212: PUSH
3213: LD_VAR 0 6
3217: PUSH
3218: LD_EXP 44
3222: ADD
3223: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3224: LD_ADDR_EXP 45
3228: PUSH
3229: LD_STRING Gladstone
3231: PPUSH
3232: LD_EXP 1
3236: NOT
3237: PPUSH
3238: LD_STRING 13s_
3240: PPUSH
3241: CALL 62900 0 3
3245: ST_TO_ADDR
// if Gladstone then
3246: LD_EXP 45
3250: IFFALSE 3268
// tmp := tmp ^ Gladstone ;
3252: LD_ADDR_VAR 0 6
3256: PUSH
3257: LD_VAR 0 6
3261: PUSH
3262: LD_EXP 45
3266: ADD
3267: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3268: LD_ADDR_EXP 46
3272: PUSH
3273: LD_STRING Houten
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13s_
3284: PPUSH
3285: CALL 62900 0 3
3289: ST_TO_ADDR
// if Houten then
3290: LD_EXP 46
3294: IFFALSE 3312
// tmp := tmp ^ Houten ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 46
3310: ADD
3311: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 47
3316: PUSH
3317: LD_STRING Cornel
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 62900 0 3
3333: ST_TO_ADDR
// if Cornel then
3334: LD_EXP 47
3338: IFFALSE 3356
// tmp := tmp ^ Cornel ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 47
3354: ADD
3355: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 48
3360: PUSH
3361: LD_STRING Gary
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 62900 0 3
3377: ST_TO_ADDR
// if Gary then
3378: LD_EXP 48
3382: IFFALSE 3400
// tmp := tmp ^ Gary ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 48
3398: ADD
3399: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 49
3404: PUSH
3405: LD_STRING Frank
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 62900 0 3
3421: ST_TO_ADDR
// if Frank then
3422: LD_EXP 49
3426: IFFALSE 3444
// tmp := tmp ^ Frank ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 49
3442: ADD
3443: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 50
3448: PUSH
3449: LD_STRING Kikuchi
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 62900 0 3
3465: ST_TO_ADDR
// if Kikuchi then
3466: LD_EXP 50
3470: IFFALSE 3488
// tmp := tmp ^ Kikuchi ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 50
3486: ADD
3487: ST_TO_ADDR
// vip := tmp ;
3488: LD_ADDR_EXP 56
3492: PUSH
3493: LD_VAR 0 6
3497: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3498: LD_ADDR_VAR 0 6
3502: PUSH
3503: LD_VAR 0 6
3507: PUSH
3508: LD_STRING 13s_others
3510: PPUSH
3511: CALL_OW 31
3515: UNION
3516: ST_TO_ADDR
// if tmp < 20 then
3517: LD_VAR 0 6
3521: PUSH
3522: LD_INT 20
3524: LESS
3525: IFFALSE 3592
// for i = 1 to 20 - tmp do
3527: LD_ADDR_VAR 0 2
3531: PUSH
3532: DOUBLE
3533: LD_INT 1
3535: DEC
3536: ST_TO_ADDR
3537: LD_INT 20
3539: PUSH
3540: LD_VAR 0 6
3544: MINUS
3545: PUSH
3546: FOR_TO
3547: IFFALSE 3590
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3549: LD_INT 1
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 4
3559: MOD
3560: PUSH
3561: LD_INT 1
3563: PLUS
3564: PPUSH
3565: LD_INT 5
3567: PPUSH
3568: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3572: LD_ADDR_VAR 0 6
3576: PUSH
3577: LD_VAR 0 6
3581: PUSH
3582: CALL_OW 44
3586: ADD
3587: ST_TO_ADDR
// end ;
3588: GO 3546
3590: POP
3591: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3592: LD_ADDR_VAR 0 7
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 4
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 0
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3630: LD_ADDR_VAR 0 8
3634: PUSH
3635: LD_INT 22
3637: PUSH
3638: LD_INT 4
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 30
3647: PUSH
3648: LD_INT 6
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PPUSH
3659: CALL_OW 69
3663: PUSH
3664: LD_INT 1
3666: ARRAY
3667: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3668: LD_ADDR_VAR 0 9
3672: PUSH
3673: LD_INT 22
3675: PUSH
3676: LD_INT 4
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 30
3685: PUSH
3686: LD_INT 4
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 69
3701: PUSH
3702: LD_INT 1
3704: ARRAY
3705: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3706: LD_ADDR_VAR 0 10
3710: PUSH
3711: LD_INT 22
3713: PUSH
3714: LD_INT 4
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 30
3723: PUSH
3724: LD_INT 2
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PPUSH
3735: CALL_OW 69
3739: PUSH
3740: LD_INT 1
3742: ARRAY
3743: ST_TO_ADDR
// for i in tmp do
3744: LD_ADDR_VAR 0 2
3748: PUSH
3749: LD_VAR 0 6
3753: PUSH
3754: FOR_IN
3755: IFFALSE 3881
// begin cl := GetClass ( i ) ;
3757: LD_ADDR_VAR 0 5
3761: PUSH
3762: LD_VAR 0 2
3766: PPUSH
3767: CALL_OW 257
3771: ST_TO_ADDR
// if cl > 4 then
3772: LD_VAR 0 5
3776: PUSH
3777: LD_INT 4
3779: GREATER
3780: IFFALSE 3790
// cl := 1 ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_INT 1
3789: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3790: LD_ADDR_VAR 0 3
3794: PUSH
3795: LD_VAR 0 9
3799: PUSH
3800: LD_VAR 0 7
3804: PUSH
3805: LD_VAR 0 10
3809: PUSH
3810: LD_VAR 0 8
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: PUSH
3821: LD_VAR 0 5
3825: ARRAY
3826: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3827: LD_VAR 0 3
3831: PPUSH
3832: CALL_OW 313
3836: PUSH
3837: LD_INT 5
3839: LESS
3840: IFFALSE 3858
// PlaceHumanInUnit ( i , b ) else
3842: LD_VAR 0 2
3846: PPUSH
3847: LD_VAR 0 3
3851: PPUSH
3852: CALL_OW 52
3856: GO 3879
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3858: LD_VAR 0 2
3862: PPUSH
3863: LD_INT 58
3865: PPUSH
3866: LD_INT 91
3868: PPUSH
3869: LD_INT 6
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 50
// end ;
3879: GO 3754
3881: POP
3882: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3883: LD_INT 2
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 12
3894: PPUSH
3895: LD_INT 100
3897: PPUSH
3898: CALL 69533 0 5
// veh := CreateVehicle ;
3902: LD_ADDR_VAR 0 4
3906: PUSH
3907: CALL_OW 45
3911: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3912: LD_VAR 0 4
3916: PPUSH
3917: LD_INT 4
3919: PPUSH
3920: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3924: LD_VAR 0 4
3928: PPUSH
3929: LD_INT 49
3931: PPUSH
3932: LD_INT 88
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 1
3949: PPUSH
3950: LD_INT 100
3952: PPUSH
3953: CALL_OW 290
// uc_side := 0 ;
3957: LD_ADDR_OWVAR 20
3961: PUSH
3962: LD_INT 0
3964: ST_TO_ADDR
// uc_nation := 0 ;
3965: LD_ADDR_OWVAR 21
3969: PUSH
3970: LD_INT 0
3972: ST_TO_ADDR
// for i = 1 to 4 do
3973: LD_ADDR_VAR 0 2
3977: PUSH
3978: DOUBLE
3979: LD_INT 1
3981: DEC
3982: ST_TO_ADDR
3983: LD_INT 4
3985: PUSH
3986: FOR_TO
3987: IFFALSE 4018
// begin InitHc ;
3989: CALL_OW 19
// hc_class := class_apeman ;
3993: LD_ADDR_OWVAR 28
3997: PUSH
3998: LD_INT 12
4000: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4001: CALL_OW 44
4005: PPUSH
4006: LD_INT 13
4008: PPUSH
4009: LD_INT 0
4011: PPUSH
4012: CALL_OW 49
// end ;
4016: GO 3986
4018: POP
4019: POP
// end ; end_of_file
4020: LD_VAR 0 1
4024: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4025: LD_INT 0
4027: PPUSH
4028: PPUSH
4029: PPUSH
4030: PPUSH
4031: PPUSH
// side := 8 ;
4032: LD_ADDR_VAR 0 3
4036: PUSH
4037: LD_INT 8
4039: ST_TO_ADDR
// uc_side := side ;
4040: LD_ADDR_OWVAR 20
4044: PUSH
4045: LD_VAR 0 3
4049: ST_TO_ADDR
// uc_nation := 2 ;
4050: LD_ADDR_OWVAR 21
4054: PUSH
4055: LD_INT 2
4057: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4058: LD_ADDR_VAR 0 2
4062: PUSH
4063: LD_INT 22
4065: PUSH
4066: LD_VAR 0 3
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: LD_INT 21
4077: PUSH
4078: LD_INT 3
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: PPUSH
4089: CALL_OW 69
4093: PUSH
4094: FOR_IN
4095: IFFALSE 4111
// SetBLevel ( i , 10 ) ;
4097: LD_VAR 0 2
4101: PPUSH
4102: LD_INT 10
4104: PPUSH
4105: CALL_OW 241
4109: GO 4094
4111: POP
4112: POP
// if KurtStatus then
4113: LD_EXP 3
4117: IFFALSE 4140
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4119: LD_ADDR_EXP 57
4123: PUSH
4124: LD_STRING Kurt
4126: PPUSH
4127: LD_INT 0
4129: PPUSH
4130: LD_STRING 
4132: PPUSH
4133: CALL 62900 0 3
4137: ST_TO_ADDR
4138: GO 4162
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4140: LD_ADDR_EXP 57
4144: PUSH
4145: LD_STRING AltKurt
4147: PPUSH
4148: LD_EXP 1
4152: NOT
4153: PPUSH
4154: LD_STRING 
4156: PPUSH
4157: CALL 62900 0 3
4161: ST_TO_ADDR
// if not Kurt then
4162: LD_EXP 57
4166: NOT
4167: IFFALSE 4193
// begin InitHc ;
4169: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 10
4178: PPUSH
4179: CALL_OW 381
// Kurt := CreateHuman ;
4183: LD_ADDR_EXP 57
4187: PUSH
4188: CALL_OW 44
4192: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4193: LD_EXP 57
4197: PPUSH
4198: LD_INT 324
4200: PPUSH
4201: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4205: LD_ADDR_EXP 58
4209: PUSH
4210: LD_STRING Kozlov
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: LD_STRING 
4218: PPUSH
4219: CALL 62900 0 3
4223: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4224: LD_EXP 58
4228: PPUSH
4229: LD_INT 22
4231: PUSH
4232: LD_INT 8
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 23
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 8
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 69
4268: PUSH
4269: LD_INT 1
4271: ARRAY
4272: PPUSH
4273: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4277: LD_EXP 58
4281: PPUSH
4282: LD_INT 3
4284: PPUSH
4285: LD_INT 10
4287: PPUSH
4288: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4292: LD_ADDR_VAR 0 5
4296: PUSH
4297: LD_INT 22
4299: PUSH
4300: LD_VAR 0 3
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 30
4311: PUSH
4312: LD_INT 32
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 58
4321: PUSH
4322: EMPTY
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// for i = 1 to 10 do
4335: LD_ADDR_VAR 0 2
4339: PUSH
4340: DOUBLE
4341: LD_INT 1
4343: DEC
4344: ST_TO_ADDR
4345: LD_INT 10
4347: PUSH
4348: FOR_TO
4349: IFFALSE 4421
// begin uc_nation := nation_nature ;
4351: LD_ADDR_OWVAR 21
4355: PUSH
4356: LD_INT 0
4358: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4359: LD_ADDR_OWVAR 28
4363: PUSH
4364: LD_INT 15
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_name :=  ;
4375: LD_ADDR_OWVAR 26
4379: PUSH
4380: LD_STRING 
4382: ST_TO_ADDR
// un := CreateHuman ;
4383: LD_ADDR_VAR 0 4
4387: PUSH
4388: CALL_OW 44
4392: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4393: LD_VAR 0 4
4397: PPUSH
4398: LD_VAR 0 5
4402: PUSH
4403: LD_VAR 0 5
4407: PUSH
4408: LD_VAR 0 2
4412: MINUS
4413: ARRAY
4414: PPUSH
4415: CALL_OW 52
// end ;
4419: GO 4348
4421: POP
4422: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4423: LD_ADDR_VAR 0 5
4427: PUSH
4428: LD_STRING 12_kurt_squad
4430: PPUSH
4431: CALL_OW 31
4435: ST_TO_ADDR
// if tmp then
4436: LD_VAR 0 5
4440: IFFALSE 4474
// for i in tmp do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: LD_VAR 0 5
4451: PUSH
4452: FOR_IN
4453: IFFALSE 4472
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4455: LD_VAR 0 2
4459: PPUSH
4460: LD_INT 5
4462: PPUSH
4463: LD_INT 0
4465: PPUSH
4466: CALL_OW 49
4470: GO 4452
4472: POP
4473: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4474: LD_INT 324
4476: PPUSH
4477: LD_INT 5
4479: PPUSH
4480: LD_STRING 
4482: PPUSH
4483: LD_INT 8
4485: PUSH
4486: LD_INT 9
4488: PUSH
4489: LD_INT 10
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: LD_OWVAR 67
4501: ARRAY
4502: PPUSH
4503: LD_INT 3000
4505: PUSH
4506: LD_INT 500
4508: PUSH
4509: LD_INT 150
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: PPUSH
4517: LD_INT 16
4519: PUSH
4520: LD_INT 6
4522: PUSH
4523: LD_INT 6
4525: PUSH
4526: LD_INT 8
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL 72942 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4539: LD_ADDR_EXP 99
4543: PUSH
4544: LD_EXP 99
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 22
4554: PUSH
4555: LD_VAR 0 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 23
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: LD_INT 3
4576: PUSH
4577: LD_INT 21
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: PPUSH
4596: CALL_OW 69
4600: PUSH
4601: LD_EXP 57
4605: DIFF
4606: PPUSH
4607: CALL_OW 1
4611: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4612: LD_INT 1
4614: PPUSH
4615: LD_INT 7
4617: PPUSH
4618: CALL_OW 383
// Friend := CreateHuman ;
4622: LD_ADDR_EXP 59
4626: PUSH
4627: CALL_OW 44
4631: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4632: LD_INT 14
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_INT 29
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 69533 0 5
// powellBomb := CreateVehicle ;
4651: LD_ADDR_EXP 60
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4661: LD_EXP 60
4665: PPUSH
4666: LD_INT 90
4668: PPUSH
4669: LD_INT 51
4671: PPUSH
4672: LD_INT 0
4674: PPUSH
4675: CALL_OW 48
// end ;
4679: LD_VAR 0 1
4683: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
// if IsLive ( kozlov_fac ) then
4689: LD_INT 332
4691: PPUSH
4692: CALL_OW 300
4696: IFFALSE 4700
// exit ;
4698: GO 5267
// ComExitBuilding ( Kozlov ) ;
4700: LD_EXP 58
4704: PPUSH
4705: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4709: LD_EXP 58
4713: PPUSH
4714: CALL_OW 257
4718: PUSH
4719: LD_INT 2
4721: NONEQUAL
4722: IFFALSE 4757
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4724: LD_EXP 58
4728: PPUSH
4729: LD_INT 324
4731: PPUSH
4732: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4736: LD_EXP 58
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4748: LD_EXP 58
4752: PPUSH
4753: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4757: LD_EXP 58
4761: PPUSH
4762: LD_INT 2
4764: PPUSH
4765: LD_INT 93
4767: PPUSH
4768: LD_INT 32
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4778: LD_INT 35
4780: PPUSH
4781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4785: LD_INT 22
4787: PUSH
4788: LD_INT 8
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 30
4797: PUSH
4798: LD_INT 3
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 23
4807: PUSH
4808: LD_INT 3
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 57
4817: PUSH
4818: EMPTY
4819: LIST
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: PPUSH
4827: CALL_OW 69
4831: IFFALSE 4778
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4833: LD_ADDR_VAR 0 2
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 8
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 30
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 23
4860: PUSH
4861: LD_INT 3
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 57
4870: PUSH
4871: EMPTY
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: PPUSH
4880: CALL_OW 69
4884: PUSH
4885: LD_INT 1
4887: ARRAY
4888: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4889: LD_INT 22
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: LD_INT 23
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PUSH
4909: LD_INT 30
4911: PUSH
4912: LD_INT 21
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 69
4928: NOT
4929: IFFALSE 5007
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4931: LD_EXP 58
4935: PPUSH
4936: LD_INT 21
4938: PPUSH
4939: LD_INT 97
4941: PPUSH
4942: LD_INT 36
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4952: LD_INT 35
4954: PPUSH
4955: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4959: LD_INT 22
4961: PUSH
4962: LD_INT 8
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 23
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 30
4981: PUSH
4982: LD_INT 21
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 57
4991: PUSH
4992: EMPTY
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 69
5005: IFFALSE 4952
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5007: LD_INT 22
5009: PUSH
5010: LD_INT 8
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 23
5019: PUSH
5020: LD_INT 3
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 18
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 69
5046: NOT
5047: IFFALSE 5125
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5049: LD_EXP 58
5053: PPUSH
5054: LD_INT 18
5056: PPUSH
5057: LD_INT 89
5059: PPUSH
5060: LD_INT 32
5062: PPUSH
5063: LD_INT 1
5065: PPUSH
5066: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5070: LD_INT 35
5072: PPUSH
5073: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5077: LD_INT 22
5079: PUSH
5080: LD_INT 8
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 23
5089: PUSH
5090: LD_INT 3
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 30
5099: PUSH
5100: LD_INT 18
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 57
5109: PUSH
5110: EMPTY
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 69
5123: IFFALSE 5070
// end ; lab := kozlov_lab ;
5125: LD_ADDR_VAR 0 3
5129: PUSH
5130: LD_INT 336
5132: ST_TO_ADDR
// if not lab then
5133: LD_VAR 0 3
5137: NOT
5138: IFFALSE 5142
// exit ;
5140: GO 5267
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5142: LD_EXP 58
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5160: LD_EXP 58
5164: PPUSH
5165: LD_INT 4
5167: PPUSH
5168: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5172: LD_VAR 0 3
5176: PUSH
5177: LD_INT 1
5179: ARRAY
5180: PPUSH
5181: LD_INT 25
5183: PPUSH
5184: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5195: LD_INT 25
5197: PPUSH
5198: LD_INT 8
5200: PPUSH
5201: CALL_OW 321
5205: PUSH
5206: LD_INT 2
5208: EQUAL
5209: IFFALSE 5188
// ComExitBuilding ( Kozlov ) ;
5211: LD_EXP 58
5215: PPUSH
5216: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5220: LD_EXP 58
5224: PPUSH
5225: LD_VAR 0 2
5229: PPUSH
5230: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5234: LD_EXP 58
5238: PPUSH
5239: LD_INT 3
5241: PPUSH
5242: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5246: LD_VAR 0 2
5250: PPUSH
5251: LD_INT 23
5253: PPUSH
5254: LD_INT 3
5256: PPUSH
5257: LD_INT 1
5259: PPUSH
5260: LD_INT 48
5262: PPUSH
5263: CALL_OW 125
// end ;
5267: LD_VAR 0 1
5271: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5272: LD_EXP 22
5276: NOT
5277: PUSH
5278: LD_EXP 15
5282: PUSH
5283: LD_INT 6
5285: GREATEREQUAL
5286: AND
5287: IFFALSE 5368
5289: GO 5291
5291: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: CALL 57105 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5302: LD_INT 3
5304: PPUSH
5305: LD_INT 14
5307: PUSH
5308: LD_INT 1
5310: PUSH
5311: LD_INT 1
5313: PUSH
5314: LD_INT 28
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 14
5325: PUSH
5326: LD_INT 1
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: LD_INT 28
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 14
5343: PUSH
5344: LD_INT 1
5346: PUSH
5347: LD_INT 1
5349: PUSH
5350: LD_INT 28
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL 56968 0 2
// end ;
5368: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5369: LD_EXP 22
5373: NOT
5374: PUSH
5375: LD_EXP 15
5379: PUSH
5380: LD_INT 6
5382: GREATEREQUAL
5383: AND
5384: PUSH
5385: LD_INT 3
5387: PPUSH
5388: LD_INT 1
5390: PPUSH
5391: CALL 58323 0 2
5395: NOT
5396: AND
5397: IFFALSE 6237
5399: GO 5401
5401: DISABLE
5402: LD_INT 0
5404: PPUSH
5405: PPUSH
5406: PPUSH
// begin enable ;
5407: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5408: LD_INT 22
5410: PUSH
5411: LD_INT 8
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PUSH
5418: LD_INT 23
5420: PUSH
5421: LD_INT 2
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PUSH
5428: LD_INT 30
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: NOT
5448: IFFALSE 5452
// exit ;
5450: GO 6237
// if Prob ( 40 ) then
5452: LD_INT 40
5454: PPUSH
5455: CALL_OW 13
5459: IFFALSE 5586
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5461: LD_INT 3
5463: PPUSH
5464: LD_INT 14
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 2
5472: PUSH
5473: LD_INT 28
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PUSH
5482: LD_INT 14
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 2
5490: PUSH
5491: LD_INT 28
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_INT 14
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 2
5508: PUSH
5509: LD_INT 28
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PUSH
5518: LD_INT 14
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: LD_INT 2
5526: PUSH
5527: LD_INT 28
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_INT 14
5538: PUSH
5539: LD_INT 1
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 28
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 14
5556: PUSH
5557: LD_INT 1
5559: PUSH
5560: LD_INT 2
5562: PUSH
5563: LD_INT 26
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL 56968 0 2
// end else
5584: GO 5777
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5586: LD_INT 3
5588: PPUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 27
5600: PUSH
5601: LD_INT 26
5603: PUSH
5604: LD_INT 26
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_OWVAR 67
5616: ARRAY
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 14
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 27
5635: PUSH
5636: LD_INT 26
5638: PUSH
5639: LD_INT 26
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: PUSH
5647: LD_OWVAR 67
5651: ARRAY
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 14
5661: PUSH
5662: LD_INT 1
5664: PUSH
5665: LD_INT 2
5667: PUSH
5668: LD_INT 26
5670: PUSH
5671: LD_INT 26
5673: PUSH
5674: LD_INT 29
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_OWVAR 67
5686: ARRAY
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: PUSH
5694: LD_INT 13
5696: PUSH
5697: LD_INT 1
5699: PUSH
5700: LD_INT 2
5702: PUSH
5703: LD_INT 26
5705: PUSH
5706: LD_INT 29
5708: PUSH
5709: LD_INT 29
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: PUSH
5717: LD_OWVAR 67
5721: ARRAY
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 13
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 29
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 14
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 26
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PPUSH
5773: CALL 56968 0 2
// end ; repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 1
5789: PPUSH
5790: CALL 58323 0 2
5794: PUSH
5795: LD_INT 6
5797: GREATEREQUAL
5798: IFFALSE 5777
// wait ( 0 0$30 ) ;
5800: LD_INT 1050
5802: PPUSH
5803: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: LD_INT 3
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL 58323 0 2
5822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5823: LD_ADDR_EXP 118
5827: PUSH
5828: LD_EXP 118
5832: PPUSH
5833: LD_INT 3
5835: PPUSH
5836: LD_EXP 118
5840: PUSH
5841: LD_INT 3
5843: ARRAY
5844: PUSH
5845: LD_VAR 0 2
5849: DIFF
5850: PPUSH
5851: CALL_OW 1
5855: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5856: LD_ADDR_VAR 0 3
5860: PUSH
5861: LD_INT 0
5863: PPUSH
5864: LD_INT 2
5866: PPUSH
5867: CALL_OW 12
5871: ST_TO_ADDR
// if target then
5872: LD_VAR 0 3
5876: IFFALSE 6004
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5878: LD_ADDR_VAR 0 2
5882: PUSH
5883: LD_VAR 0 2
5887: PPUSH
5888: LD_INT 24
5890: PUSH
5891: LD_INT 250
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PPUSH
5898: CALL_OW 72
5902: ST_TO_ADDR
// for i in tmp do
5903: LD_ADDR_VAR 0 1
5907: PUSH
5908: LD_VAR 0 2
5912: PUSH
5913: FOR_IN
5914: IFFALSE 5954
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5916: LD_VAR 0 1
5920: PPUSH
5921: LD_INT 89
5923: PPUSH
5924: LD_INT 71
5926: PPUSH
5927: CALL_OW 297
5931: PUSH
5932: LD_INT 9
5934: GREATER
5935: IFFALSE 5952
// ComMoveXY ( i , 89 , 71 ) ;
5937: LD_VAR 0 1
5941: PPUSH
5942: LD_INT 89
5944: PPUSH
5945: LD_INT 71
5947: PPUSH
5948: CALL_OW 111
5952: GO 5913
5954: POP
5955: POP
// wait ( 0 0$1 ) ;
5956: LD_INT 35
5958: PPUSH
5959: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5963: LD_VAR 0 2
5967: PPUSH
5968: LD_INT 92
5970: PUSH
5971: LD_INT 89
5973: PUSH
5974: LD_INT 71
5976: PUSH
5977: LD_INT 9
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PPUSH
5986: CALL_OW 72
5990: PUSH
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: MINUS
5999: GREATEREQUAL
6000: IFFALSE 5878
// end else
6002: GO 6128
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 24
6016: PUSH
6017: LD_INT 250
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 72
6028: ST_TO_ADDR
// for i in tmp do
6029: LD_ADDR_VAR 0 1
6033: PUSH
6034: LD_VAR 0 2
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6080
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6042: LD_VAR 0 1
6046: PPUSH
6047: LD_INT 125
6049: PPUSH
6050: LD_INT 129
6052: PPUSH
6053: CALL_OW 297
6057: PUSH
6058: LD_INT 9
6060: GREATER
6061: IFFALSE 6078
// ComMoveXY ( i , 125 , 129 ) ;
6063: LD_VAR 0 1
6067: PPUSH
6068: LD_INT 125
6070: PPUSH
6071: LD_INT 129
6073: PPUSH
6074: CALL_OW 111
6078: GO 6039
6080: POP
6081: POP
// wait ( 0 0$1 ) ;
6082: LD_INT 35
6084: PPUSH
6085: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6089: LD_VAR 0 2
6093: PPUSH
6094: LD_INT 92
6096: PUSH
6097: LD_INT 125
6099: PUSH
6100: LD_INT 129
6102: PUSH
6103: LD_INT 9
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PPUSH
6112: CALL_OW 72
6116: PUSH
6117: LD_VAR 0 2
6121: PUSH
6122: LD_INT 1
6124: MINUS
6125: GREATEREQUAL
6126: IFFALSE 6004
// end ; repeat wait ( 0 0$1 ) ;
6128: LD_INT 35
6130: PPUSH
6131: CALL_OW 67
// for i in tmp do
6135: LD_ADDR_VAR 0 1
6139: PUSH
6140: LD_VAR 0 2
6144: PUSH
6145: FOR_IN
6146: IFFALSE 6228
// begin if GetLives ( i ) > 251 then
6148: LD_VAR 0 1
6152: PPUSH
6153: CALL_OW 256
6157: PUSH
6158: LD_INT 251
6160: GREATER
6161: IFFALSE 6199
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6163: LD_VAR 0 1
6167: PPUSH
6168: LD_INT 81
6170: PUSH
6171: LD_INT 8
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PPUSH
6178: CALL_OW 69
6182: PPUSH
6183: LD_VAR 0 1
6187: PPUSH
6188: CALL_OW 74
6192: PPUSH
6193: CALL_OW 115
6197: GO 6226
// if IsDead ( i ) then
6199: LD_VAR 0 1
6203: PPUSH
6204: CALL_OW 301
6208: IFFALSE 6226
// tmp := tmp diff i ;
6210: LD_ADDR_VAR 0 2
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_VAR 0 1
6224: DIFF
6225: ST_TO_ADDR
// end ;
6226: GO 6145
6228: POP
6229: POP
// until not tmp ;
6230: LD_VAR 0 2
6234: NOT
6235: IFFALSE 6128
// end ;
6237: PPOPN 3
6239: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6240: LD_EXP 22
6244: NOT
6245: PUSH
6246: LD_EXP 15
6250: PUSH
6251: LD_INT 6
6253: GREATEREQUAL
6254: AND
6255: PUSH
6256: LD_OWVAR 67
6260: PUSH
6261: LD_INT 1
6263: GREATER
6264: AND
6265: IFFALSE 6782
6267: GO 6269
6269: DISABLE
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
6274: PPUSH
// begin enable ;
6275: ENABLE
// tmp := [ ] ;
6276: LD_ADDR_VAR 0 3
6280: PUSH
6281: EMPTY
6282: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: DOUBLE
6289: LD_INT 1
6291: DEC
6292: ST_TO_ADDR
6293: LD_INT 4
6295: PUSH
6296: LD_INT 6
6298: PUSH
6299: LD_INT 7
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: PUSH
6307: LD_OWVAR 67
6311: ARRAY
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6474
// begin uc_side := 8 ;
6316: LD_ADDR_OWVAR 20
6320: PUSH
6321: LD_INT 8
6323: ST_TO_ADDR
// uc_nation := 2 ;
6324: LD_ADDR_OWVAR 21
6328: PUSH
6329: LD_INT 2
6331: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6332: LD_INT 13
6334: PUSH
6335: LD_INT 14
6337: PUSH
6338: EMPTY
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 1
6344: PPUSH
6345: LD_INT 2
6347: PPUSH
6348: CALL_OW 12
6352: ARRAY
6353: PPUSH
6354: LD_INT 1
6356: PPUSH
6357: LD_INT 5
6359: PPUSH
6360: LD_INT 27
6362: PUSH
6363: LD_INT 28
6365: PUSH
6366: LD_INT 26
6368: PUSH
6369: LD_INT 25
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 4
6383: PPUSH
6384: CALL_OW 12
6388: ARRAY
6389: PPUSH
6390: LD_INT 88
6392: PPUSH
6393: CALL 69533 0 5
// un := CreateVehicle ;
6397: LD_ADDR_VAR 0 2
6401: PUSH
6402: CALL_OW 45
6406: ST_TO_ADDR
// tmp := tmp ^ un ;
6407: LD_ADDR_VAR 0 3
6411: PUSH
6412: LD_VAR 0 3
6416: PUSH
6417: LD_VAR 0 2
6421: ADD
6422: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6423: LD_VAR 0 2
6427: PPUSH
6428: LD_INT 3
6430: PPUSH
6431: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6435: LD_VAR 0 2
6439: PPUSH
6440: LD_INT 30
6442: PPUSH
6443: LD_INT 0
6445: PPUSH
6446: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6450: LD_VAR 0 2
6454: PPUSH
6455: LD_INT 16
6457: PPUSH
6458: LD_INT 11
6460: PPUSH
6461: CALL_OW 111
// wait ( 0 0$2 ) ;
6465: LD_INT 70
6467: PPUSH
6468: CALL_OW 67
// end ;
6472: GO 6313
6474: POP
6475: POP
// for i = 1 to Difficulty do
6476: LD_ADDR_VAR 0 1
6480: PUSH
6481: DOUBLE
6482: LD_INT 1
6484: DEC
6485: ST_TO_ADDR
6486: LD_OWVAR 67
6490: PUSH
6491: FOR_TO
6492: IFFALSE 6617
// begin uc_side := 8 ;
6494: LD_ADDR_OWVAR 20
6498: PUSH
6499: LD_INT 8
6501: ST_TO_ADDR
// uc_nation := 2 ;
6502: LD_ADDR_OWVAR 21
6506: PUSH
6507: LD_INT 2
6509: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6510: LD_INT 0
6512: PPUSH
6513: LD_INT 8
6515: PPUSH
6516: LD_INT 8
6518: PUSH
6519: LD_INT 8
6521: PUSH
6522: LD_INT 9
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: PUSH
6530: LD_OWVAR 67
6534: ARRAY
6535: PPUSH
6536: CALL_OW 380
// un := CreateHuman ;
6540: LD_ADDR_VAR 0 2
6544: PUSH
6545: CALL_OW 44
6549: ST_TO_ADDR
// tmp := tmp ^ un ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 2
6564: ADD
6565: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6566: LD_VAR 0 2
6570: PPUSH
6571: LD_INT 3
6573: PPUSH
6574: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6578: LD_VAR 0 2
6582: PPUSH
6583: LD_INT 30
6585: PPUSH
6586: LD_INT 0
6588: PPUSH
6589: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6593: LD_VAR 0 2
6597: PPUSH
6598: LD_INT 16
6600: PPUSH
6601: LD_INT 11
6603: PPUSH
6604: CALL_OW 111
// wait ( 0 0$2 ) ;
6608: LD_INT 70
6610: PPUSH
6611: CALL_OW 67
// end ;
6615: GO 6491
6617: POP
6618: POP
// repeat wait ( 0 0$1 ) ;
6619: LD_INT 35
6621: PPUSH
6622: CALL_OW 67
// for i in tmp do
6626: LD_ADDR_VAR 0 1
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: FOR_IN
6637: IFFALSE 6773
// begin if GetLives ( i ) > 250 then
6639: LD_VAR 0 1
6643: PPUSH
6644: CALL_OW 256
6648: PUSH
6649: LD_INT 250
6651: GREATER
6652: IFFALSE 6744
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6654: LD_INT 81
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 91
6666: PUSH
6667: LD_VAR 0 1
6671: PUSH
6672: LD_INT 10
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PPUSH
6684: CALL_OW 69
6688: NOT
6689: IFFALSE 6708
// ComAgressiveMove ( i , 67 , 110 ) else
6691: LD_VAR 0 1
6695: PPUSH
6696: LD_INT 67
6698: PPUSH
6699: LD_INT 110
6701: PPUSH
6702: CALL_OW 114
6706: GO 6742
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6708: LD_VAR 0 1
6712: PPUSH
6713: LD_INT 81
6715: PUSH
6716: LD_INT 8
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: PPUSH
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 74
6737: PPUSH
6738: CALL_OW 115
// end else
6742: GO 6771
// if IsDead ( i ) then
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 301
6753: IFFALSE 6771
// tmp := tmp diff i ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_VAR 0 3
6764: PUSH
6765: LD_VAR 0 1
6769: DIFF
6770: ST_TO_ADDR
// end ;
6771: GO 6636
6773: POP
6774: POP
// until not tmp ;
6775: LD_VAR 0 3
6779: NOT
6780: IFFALSE 6619
// end ; end_of_file
6782: PPOPN 3
6784: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6785: LD_INT 0
6787: PPUSH
6788: PPUSH
6789: PPUSH
6790: PPUSH
6791: PPUSH
6792: PPUSH
6793: PPUSH
6794: PPUSH
6795: PPUSH
// side := 3 ;
6796: LD_ADDR_VAR 0 6
6800: PUSH
6801: LD_INT 3
6803: ST_TO_ADDR
// uc_side := side ;
6804: LD_ADDR_OWVAR 20
6808: PUSH
6809: LD_VAR 0 6
6813: ST_TO_ADDR
// uc_nation := 3 ;
6814: LD_ADDR_OWVAR 21
6818: PUSH
6819: LD_INT 3
6821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6822: LD_ADDR_VAR 0 2
6826: PUSH
6827: LD_INT 22
6829: PUSH
6830: LD_VAR 0 6
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PPUSH
6853: CALL_OW 69
6857: PUSH
6858: FOR_IN
6859: IFFALSE 6875
// SetBLevel ( i , 10 ) ;
6861: LD_VAR 0 2
6865: PPUSH
6866: LD_INT 10
6868: PPUSH
6869: CALL_OW 241
6873: GO 6858
6875: POP
6876: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6877: LD_ADDR_VAR 0 9
6881: PUSH
6882: LD_INT 22
6884: PUSH
6885: LD_VAR 0 6
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 30
6896: PUSH
6897: LD_INT 34
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL_OW 69
6912: ST_TO_ADDR
// if teleport then
6913: LD_VAR 0 9
6917: IFFALSE 6938
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6919: LD_VAR 0 9
6923: PUSH
6924: LD_INT 1
6926: ARRAY
6927: PPUSH
6928: LD_INT 123
6930: PPUSH
6931: LD_INT 122
6933: PPUSH
6934: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6938: LD_ADDR_EXP 61
6942: PUSH
6943: LD_STRING Platonov
6945: PPUSH
6946: CALL_OW 25
6950: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6951: LD_ADDR_EXP 62
6955: PUSH
6956: LD_STRING Kovalyuk
6958: PPUSH
6959: CALL_OW 25
6963: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6964: LD_ADDR_EXP 64
6968: PUSH
6969: LD_STRING Yakotich
6971: PPUSH
6972: CALL_OW 25
6976: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6977: LD_ADDR_EXP 63
6981: PUSH
6982: LD_STRING Bystrov
6984: PPUSH
6985: CALL_OW 25
6989: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6990: LD_ADDR_EXP 65
6994: PUSH
6995: LD_STRING Gleb
6997: PPUSH
6998: CALL_OW 25
7002: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7003: LD_STRING 03_Cornel
7005: PPUSH
7006: CALL_OW 28
7010: IFFALSE 7058
// begin Bierezov := NewCharacter ( Mikhail ) ;
7012: LD_ADDR_EXP 66
7016: PUSH
7017: LD_STRING Mikhail
7019: PPUSH
7020: CALL_OW 25
7024: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7025: LD_EXP 66
7029: PPUSH
7030: LD_INT 197
7032: PPUSH
7033: LD_INT 111
7035: PPUSH
7036: LD_INT 9
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7046: LD_EXP 66
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7058: LD_EXP 61
7062: PPUSH
7063: LD_INT 126
7065: PPUSH
7066: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7070: LD_EXP 62
7074: PPUSH
7075: LD_INT 134
7077: PPUSH
7078: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7082: LD_EXP 64
7086: PPUSH
7087: LD_INT 197
7089: PPUSH
7090: LD_INT 111
7092: PPUSH
7093: LD_INT 9
7095: PPUSH
7096: LD_INT 0
7098: PPUSH
7099: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7103: LD_EXP 63
7107: PPUSH
7108: LD_INT 197
7110: PPUSH
7111: LD_INT 111
7113: PPUSH
7114: LD_INT 9
7116: PPUSH
7117: LD_INT 0
7119: PPUSH
7120: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7124: LD_EXP 65
7128: PPUSH
7129: LD_INT 197
7131: PPUSH
7132: LD_INT 111
7134: PPUSH
7135: LD_INT 9
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7145: LD_ADDR_VAR 0 5
7149: PUSH
7150: LD_INT 126
7152: PPUSH
7153: LD_INT 4
7155: PPUSH
7156: LD_STRING zhukov
7158: PPUSH
7159: LD_INT 9
7161: PUSH
7162: LD_INT 10
7164: PUSH
7165: LD_INT 10
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_OWVAR 67
7177: ARRAY
7178: PPUSH
7179: LD_INT 99999
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: LD_INT 300
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: PPUSH
7193: LD_INT 12
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: LD_INT 13
7201: PUSH
7202: LD_INT 8
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PPUSH
7211: CALL 72942 0 6
7215: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7216: LD_ADDR_VAR 0 4
7220: PUSH
7221: LD_INT 267
7223: PPUSH
7224: CALL_OW 274
7228: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7229: LD_VAR 0 4
7233: PPUSH
7234: LD_INT 1
7236: PPUSH
7237: LD_INT 5000
7239: PPUSH
7240: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7244: LD_VAR 0 4
7248: PPUSH
7249: LD_INT 2
7251: PPUSH
7252: LD_INT 200
7254: PPUSH
7255: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7259: LD_VAR 0 4
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 200
7269: PPUSH
7270: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7274: LD_ADDR_EXP 99
7278: PUSH
7279: LD_EXP 99
7283: PPUSH
7284: LD_INT 2
7286: PPUSH
7287: LD_VAR 0 5
7291: PUSH
7292: LD_INT 22
7294: PUSH
7295: LD_VAR 0 6
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PUSH
7304: LD_INT 3
7306: PUSH
7307: LD_INT 21
7309: PUSH
7310: LD_INT 2
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PPUSH
7325: CALL_OW 69
7329: UNION
7330: PUSH
7331: LD_EXP 61
7335: DIFF
7336: PPUSH
7337: CALL_OW 1
7341: ST_TO_ADDR
// behemoths := [ ] ;
7342: LD_ADDR_EXP 69
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// behemothBuilders := [ ] ;
7349: LD_ADDR_EXP 70
7353: PUSH
7354: EMPTY
7355: ST_TO_ADDR
// if Kovalyuk then
7356: LD_EXP 62
7360: IFFALSE 7382
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7362: LD_ADDR_EXP 70
7366: PUSH
7367: LD_EXP 70
7371: PPUSH
7372: LD_EXP 62
7376: PPUSH
7377: CALL 105254 0 2
7381: ST_TO_ADDR
// j := 3 ;
7382: LD_ADDR_VAR 0 3
7386: PUSH
7387: LD_INT 3
7389: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7390: LD_ADDR_VAR 0 2
7394: PUSH
7395: LD_INT 22
7397: PUSH
7398: LD_INT 3
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 25
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: PPUSH
7419: CALL_OW 69
7423: PUSH
7424: LD_EXP 62
7428: DIFF
7429: PUSH
7430: FOR_IN
7431: IFFALSE 7481
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7433: LD_ADDR_EXP 70
7437: PUSH
7438: LD_EXP 70
7442: PPUSH
7443: LD_VAR 0 2
7447: PPUSH
7448: CALL 105254 0 2
7452: ST_TO_ADDR
// j := j - 1 ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_VAR 0 3
7462: PUSH
7463: LD_INT 1
7465: MINUS
7466: ST_TO_ADDR
// if j = 0 then
7467: LD_VAR 0 3
7471: PUSH
7472: LD_INT 0
7474: EQUAL
7475: IFFALSE 7479
// break ;
7477: GO 7481
// end ;
7479: GO 7430
7481: POP
7482: POP
// end ;
7483: LD_VAR 0 1
7487: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7488: LD_INT 0
7490: PPUSH
7491: PPUSH
7492: PPUSH
7493: PPUSH
7494: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7495: LD_ADDR_VAR 0 4
7499: PUSH
7500: LD_INT 209
7502: PUSH
7503: LD_INT 149
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 219
7512: PUSH
7513: LD_INT 154
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 223
7522: PUSH
7523: LD_INT 149
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 232
7532: PUSH
7533: LD_INT 155
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: ST_TO_ADDR
// if not behemothBuilders then
7546: LD_EXP 70
7550: NOT
7551: IFFALSE 7555
// exit ;
7553: GO 7659
// j := 1 ;
7555: LD_ADDR_VAR 0 3
7559: PUSH
7560: LD_INT 1
7562: ST_TO_ADDR
// for i in behemothBuilders do
7563: LD_ADDR_VAR 0 2
7567: PUSH
7568: LD_EXP 70
7572: PUSH
7573: FOR_IN
7574: IFFALSE 7657
// begin if IsInUnit ( i ) then
7576: LD_VAR 0 2
7580: PPUSH
7581: CALL_OW 310
7585: IFFALSE 7596
// ComExitBuilding ( i ) ;
7587: LD_VAR 0 2
7591: PPUSH
7592: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7596: LD_VAR 0 2
7600: PPUSH
7601: LD_INT 37
7603: PPUSH
7604: LD_VAR 0 4
7608: PUSH
7609: LD_VAR 0 3
7613: ARRAY
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_VAR 0 4
7623: PUSH
7624: LD_VAR 0 3
7628: ARRAY
7629: PUSH
7630: LD_INT 2
7632: ARRAY
7633: PPUSH
7634: LD_INT 0
7636: PPUSH
7637: CALL_OW 230
// j := j + 1 ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: LD_VAR 0 3
7650: PUSH
7651: LD_INT 1
7653: PLUS
7654: ST_TO_ADDR
// end ;
7655: GO 7573
7657: POP
7658: POP
// end ;
7659: LD_VAR 0 1
7663: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7664: LD_INT 24
7666: PPUSH
7667: LD_INT 30
7669: PUSH
7670: LD_INT 37
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL_OW 70
7681: IFFALSE 7694
7683: GO 7685
7685: DISABLE
// behemothUnderConstruct := true ;
7686: LD_ADDR_EXP 26
7690: PUSH
7691: LD_INT 1
7693: ST_TO_ADDR
7694: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7695: LD_INT 3
7697: PPUSH
7698: CALL 105302 0 1
7702: PUSH
7703: LD_INT 22
7705: PUSH
7706: LD_INT 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 30
7715: PUSH
7716: LD_INT 37
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PPUSH
7727: CALL_OW 69
7731: NOT
7732: AND
7733: IFFALSE 7919
7735: GO 7737
7737: DISABLE
7738: LD_INT 0
7740: PPUSH
7741: PPUSH
// begin enable ;
7742: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_INT 3
7750: PPUSH
7751: CALL 105302 0 1
7755: ST_TO_ADDR
// for i in tmp do
7756: LD_ADDR_VAR 0 1
7760: PUSH
7761: LD_VAR 0 2
7765: PUSH
7766: FOR_IN
7767: IFFALSE 7917
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7769: LD_VAR 0 1
7773: PPUSH
7774: LD_INT 9
7776: PPUSH
7777: CALL_OW 308
7781: PUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 110
7791: PUSH
7792: LD_INT 2
7794: EQUAL
7795: NOT
7796: AND
7797: IFFALSE 7811
// SetTag ( i , 2 ) ;
7799: LD_VAR 0 1
7803: PPUSH
7804: LD_INT 2
7806: PPUSH
7807: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7811: LD_INT 81
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 91
7823: PUSH
7824: LD_VAR 0 1
7828: PUSH
7829: LD_INT 12
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: NOT
7846: PUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: CALL_OW 110
7856: PUSH
7857: LD_INT 2
7859: EQUAL
7860: NOT
7861: AND
7862: IFFALSE 7881
// ComAgressiveMove ( i , 64 , 93 ) else
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 64
7871: PPUSH
7872: LD_INT 93
7874: PPUSH
7875: CALL_OW 114
7879: GO 7915
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7881: LD_VAR 0 1
7885: PPUSH
7886: LD_INT 81
7888: PUSH
7889: LD_INT 3
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PPUSH
7896: CALL_OW 69
7900: PPUSH
7901: LD_VAR 0 1
7905: PPUSH
7906: CALL_OW 74
7910: PPUSH
7911: CALL_OW 115
// end ;
7915: GO 7766
7917: POP
7918: POP
// end ;
7919: PPOPN 2
7921: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7922: LD_INT 0
7924: PPUSH
7925: PPUSH
7926: PPUSH
// result := [ ] ;
7927: LD_ADDR_VAR 0 2
7931: PUSH
7932: EMPTY
7933: ST_TO_ADDR
// uc_side := 6 ;
7934: LD_ADDR_OWVAR 20
7938: PUSH
7939: LD_INT 6
7941: ST_TO_ADDR
// uc_nation := 3 ;
7942: LD_ADDR_OWVAR 21
7946: PUSH
7947: LD_INT 3
7949: ST_TO_ADDR
// case strength of 1 :
7950: LD_VAR 0 1
7954: PUSH
7955: LD_INT 1
7957: DOUBLE
7958: EQUAL
7959: IFTRUE 7963
7961: GO 8101
7963: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7964: LD_ADDR_VAR 0 3
7968: PUSH
7969: DOUBLE
7970: LD_INT 1
7972: DEC
7973: ST_TO_ADDR
7974: LD_INT 4
7976: PUSH
7977: LD_INT 5
7979: PUSH
7980: LD_INT 6
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: PUSH
7988: LD_OWVAR 67
7992: ARRAY
7993: PUSH
7994: FOR_TO
7995: IFFALSE 8097
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7997: LD_INT 22
7999: PUSH
8000: LD_INT 24
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_VAR 0 3
8011: PUSH
8012: LD_INT 2
8014: MOD
8015: PUSH
8016: LD_INT 1
8018: PLUS
8019: ARRAY
8020: PPUSH
8021: LD_INT 1
8023: PUSH
8024: LD_INT 3
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 1
8033: PPUSH
8034: LD_INT 2
8036: PPUSH
8037: CALL_OW 12
8041: ARRAY
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: LD_INT 43
8048: PUSH
8049: LD_INT 44
8051: PUSH
8052: LD_INT 45
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 1
8062: PPUSH
8063: LD_INT 3
8065: PPUSH
8066: CALL_OW 12
8070: ARRAY
8071: PPUSH
8072: LD_INT 80
8074: PPUSH
8075: CALL 69533 0 5
// result := result union CreateVehicle ;
8079: LD_ADDR_VAR 0 2
8083: PUSH
8084: LD_VAR 0 2
8088: PUSH
8089: CALL_OW 45
8093: UNION
8094: ST_TO_ADDR
// end ;
8095: GO 7994
8097: POP
8098: POP
// end ; 2 :
8099: GO 9045
8101: LD_INT 2
8103: DOUBLE
8104: EQUAL
8105: IFTRUE 8109
8107: GO 8265
8109: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8110: LD_ADDR_VAR 0 3
8114: PUSH
8115: DOUBLE
8116: LD_INT 1
8118: DEC
8119: ST_TO_ADDR
8120: LD_INT 6
8122: PUSH
8123: LD_INT 6
8125: PUSH
8126: LD_INT 7
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: PUSH
8134: LD_OWVAR 67
8138: ARRAY
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8261
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8143: LD_INT 22
8145: PUSH
8146: LD_INT 24
8148: PUSH
8149: LD_INT 24
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: LIST
8156: PUSH
8157: LD_VAR 0 3
8161: PUSH
8162: LD_INT 3
8164: MOD
8165: PUSH
8166: LD_INT 1
8168: PLUS
8169: ARRAY
8170: PPUSH
8171: LD_INT 1
8173: PUSH
8174: LD_INT 3
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PPUSH
8193: LD_INT 3
8195: PPUSH
8196: LD_INT 43
8198: PUSH
8199: LD_INT 44
8201: PUSH
8202: LD_INT 45
8204: PUSH
8205: LD_INT 44
8207: PUSH
8208: LD_INT 46
8210: PUSH
8211: LD_INT 46
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_VAR 0 3
8226: PUSH
8227: LD_INT 6
8229: MOD
8230: PUSH
8231: LD_INT 1
8233: PLUS
8234: ARRAY
8235: PPUSH
8236: LD_INT 80
8238: PPUSH
8239: CALL 69533 0 5
// result := result union CreateVehicle ;
8243: LD_ADDR_VAR 0 2
8247: PUSH
8248: LD_VAR 0 2
8252: PUSH
8253: CALL_OW 45
8257: UNION
8258: ST_TO_ADDR
// end ;
8259: GO 8140
8261: POP
8262: POP
// end ; 3 :
8263: GO 9045
8265: LD_INT 3
8267: DOUBLE
8268: EQUAL
8269: IFTRUE 8273
8271: GO 8429
8273: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8274: LD_ADDR_VAR 0 3
8278: PUSH
8279: DOUBLE
8280: LD_INT 1
8282: DEC
8283: ST_TO_ADDR
8284: LD_INT 6
8286: PUSH
8287: LD_INT 7
8289: PUSH
8290: LD_INT 8
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: LIST
8297: PUSH
8298: LD_OWVAR 67
8302: ARRAY
8303: PUSH
8304: FOR_TO
8305: IFFALSE 8425
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8307: LD_INT 22
8309: PUSH
8310: LD_INT 24
8312: PUSH
8313: LD_INT 24
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: PUSH
8321: LD_VAR 0 3
8325: PUSH
8326: LD_INT 3
8328: MOD
8329: PUSH
8330: LD_INT 1
8332: PLUS
8333: ARRAY
8334: PPUSH
8335: LD_INT 1
8337: PUSH
8338: LD_INT 3
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 1
8347: PPUSH
8348: LD_INT 2
8350: PPUSH
8351: CALL_OW 12
8355: ARRAY
8356: PPUSH
8357: LD_INT 3
8359: PPUSH
8360: LD_INT 43
8362: PUSH
8363: LD_INT 47
8365: PUSH
8366: LD_INT 45
8368: PUSH
8369: LD_INT 45
8371: PUSH
8372: LD_INT 46
8374: PUSH
8375: LD_INT 46
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: PUSH
8386: LD_VAR 0 3
8390: PUSH
8391: LD_INT 6
8393: MOD
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: ARRAY
8399: PPUSH
8400: LD_INT 80
8402: PPUSH
8403: CALL 69533 0 5
// result := result union CreateVehicle ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_VAR 0 2
8416: PUSH
8417: CALL_OW 45
8421: UNION
8422: ST_TO_ADDR
// end ;
8423: GO 8304
8425: POP
8426: POP
// end ; 4 :
8427: GO 9045
8429: LD_INT 4
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 9044
8437: POP
// begin uc_nation := 3 ;
8438: LD_ADDR_OWVAR 21
8442: PUSH
8443: LD_INT 3
8445: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8446: LD_ADDR_VAR 0 3
8450: PUSH
8451: DOUBLE
8452: LD_INT 1
8454: DEC
8455: ST_TO_ADDR
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: LD_INT 9
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_OWVAR 67
8474: ARRAY
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8597
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8479: LD_INT 22
8481: PUSH
8482: LD_INT 24
8484: PUSH
8485: LD_INT 24
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: LIST
8492: PUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_INT 3
8500: MOD
8501: PUSH
8502: LD_INT 1
8504: PLUS
8505: ARRAY
8506: PPUSH
8507: LD_INT 1
8509: PUSH
8510: LD_INT 3
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: LD_INT 1
8519: PPUSH
8520: LD_INT 2
8522: PPUSH
8523: CALL_OW 12
8527: ARRAY
8528: PPUSH
8529: LD_INT 3
8531: PPUSH
8532: LD_INT 45
8534: PUSH
8535: LD_INT 47
8537: PUSH
8538: LD_INT 47
8540: PUSH
8541: LD_INT 45
8543: PUSH
8544: LD_INT 46
8546: PUSH
8547: LD_INT 46
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 6
8565: MOD
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: ARRAY
8571: PPUSH
8572: LD_INT 80
8574: PPUSH
8575: CALL 69533 0 5
// result := result union CreateVehicle ;
8579: LD_ADDR_VAR 0 2
8583: PUSH
8584: LD_VAR 0 2
8588: PUSH
8589: CALL_OW 45
8593: UNION
8594: ST_TO_ADDR
// end ;
8595: GO 8476
8597: POP
8598: POP
// if not KappaStatus then
8599: LD_EXP 2
8603: NOT
8604: IFFALSE 8839
// begin uc_nation := 1 ;
8606: LD_ADDR_OWVAR 21
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// for i = 1 to 3 do
8614: LD_ADDR_VAR 0 3
8618: PUSH
8619: DOUBLE
8620: LD_INT 1
8622: DEC
8623: ST_TO_ADDR
8624: LD_INT 3
8626: PUSH
8627: FOR_TO
8628: IFFALSE 8764
// begin j := rand ( 0 , 1 ) ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 0
8637: PPUSH
8638: LD_INT 1
8640: PPUSH
8641: CALL_OW 12
8645: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8646: LD_INT 3
8648: PUSH
8649: LD_INT 5
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: LD_INT 4
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_VAR 0 4
8668: PUSH
8669: LD_INT 1
8671: PPUSH
8672: LD_INT 3
8674: PPUSH
8675: CALL_OW 12
8679: PLUS
8680: ARRAY
8681: PPUSH
8682: LD_INT 1
8684: PUSH
8685: LD_INT 3
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: PUSH
8692: LD_INT 1
8694: PPUSH
8695: LD_INT 2
8697: PPUSH
8698: CALL_OW 12
8702: ARRAY
8703: PPUSH
8704: LD_INT 3
8706: PPUSH
8707: LD_INT 9
8709: PUSH
8710: LD_INT 7
8712: PUSH
8713: LD_INT 6
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: PUSH
8721: LD_VAR 0 4
8725: PUSH
8726: LD_INT 1
8728: PPUSH
8729: LD_INT 2
8731: PPUSH
8732: CALL_OW 12
8736: PLUS
8737: ARRAY
8738: PPUSH
8739: LD_INT 85
8741: PPUSH
8742: CALL 69533 0 5
// result := result union CreateVehicle ;
8746: LD_ADDR_VAR 0 2
8750: PUSH
8751: LD_VAR 0 2
8755: PUSH
8756: CALL_OW 45
8760: UNION
8761: ST_TO_ADDR
// end ;
8762: GO 8627
8764: POP
8765: POP
// if vsevolodFirstAttack then
8766: LD_EXP 24
8770: IFFALSE 8837
// begin vsevolodFirstAttack := false ;
8772: LD_ADDR_EXP 24
8776: PUSH
8777: LD_INT 0
8779: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8780: LD_INT 5
8782: PPUSH
8783: LD_INT 3
8785: PPUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 6
8791: PPUSH
8792: LD_INT 100
8794: PPUSH
8795: CALL 69533 0 5
// sewiVeh := CreateVehicle ;
8799: LD_ADDR_EXP 68
8803: PUSH
8804: CALL_OW 45
8808: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8809: LD_EXP 68
8813: PPUSH
8814: LD_INT 1
8816: PPUSH
8817: CALL_OW 242
// result := result union sewiVeh ;
8821: LD_ADDR_VAR 0 2
8825: PUSH
8826: LD_VAR 0 2
8830: PUSH
8831: LD_EXP 68
8835: UNION
8836: ST_TO_ADDR
// end ; end else
8837: GO 9042
// if vsevolodFirstAttack then
8839: LD_EXP 24
8843: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8845: LD_ADDR_EXP 24
8849: PUSH
8850: LD_INT 0
8852: ST_TO_ADDR
// uc_nation := 3 ;
8853: LD_ADDR_OWVAR 21
8857: PUSH
8858: LD_INT 3
8860: ST_TO_ADDR
// for i = 1 to 3 do
8861: LD_ADDR_VAR 0 3
8865: PUSH
8866: DOUBLE
8867: LD_INT 1
8869: DEC
8870: ST_TO_ADDR
8871: LD_INT 3
8873: PUSH
8874: FOR_TO
8875: IFFALSE 8983
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8877: LD_INT 22
8879: PUSH
8880: LD_INT 24
8882: PUSH
8883: LD_INT 24
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: LIST
8890: PUSH
8891: LD_VAR 0 3
8895: PUSH
8896: LD_INT 3
8898: MOD
8899: PUSH
8900: LD_INT 1
8902: PLUS
8903: ARRAY
8904: PPUSH
8905: LD_INT 1
8907: PUSH
8908: LD_INT 3
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 2
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: PPUSH
8927: LD_INT 3
8929: PPUSH
8930: LD_INT 45
8932: PUSH
8933: LD_INT 47
8935: PUSH
8936: LD_INT 47
8938: PUSH
8939: EMPTY
8940: LIST
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 3
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 80
8960: PPUSH
8961: CALL 69533 0 5
// result := result union CreateVehicle ;
8965: LD_ADDR_VAR 0 2
8969: PUSH
8970: LD_VAR 0 2
8974: PUSH
8975: CALL_OW 45
8979: UNION
8980: ST_TO_ADDR
// end ;
8981: GO 8874
8983: POP
8984: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8985: LD_INT 24
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 47
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 69533 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 68
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 68
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 68
9040: UNION
9041: ST_TO_ADDR
// end ; end ; end ;
9042: GO 9045
9044: POP
// end ;
9045: LD_VAR 0 2
9049: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9050: LD_EXP 16
9054: IFFALSE 9802
9056: GO 9058
9058: DISABLE
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9067: LD_ADDR_VAR 0 4
9071: PUSH
9072: LD_INT 11
9074: PUSH
9075: LD_INT 12
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9082: LD_ADDR_VAR 0 3
9086: PUSH
9087: LD_INT 8400
9089: PUSH
9090: LD_INT 7350
9092: PUSH
9093: LD_INT 6650
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9107: LD_ADDR_VAR 0 6
9111: PUSH
9112: LD_INT 70
9114: PUSH
9115: LD_INT 118
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 78
9124: PUSH
9125: LD_INT 31
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: ST_TO_ADDR
// repeat if missionStage = 2 then
9136: LD_EXP 15
9140: PUSH
9141: LD_INT 2
9143: EQUAL
9144: IFFALSE 9155
// wait ( 1 1$30 ) else
9146: LD_INT 3150
9148: PPUSH
9149: CALL_OW 67
9153: GO 9164
// wait ( time ) ;
9155: LD_VAR 0 3
9159: PPUSH
9160: CALL_OW 67
// if missionStage = 6 then
9164: LD_EXP 15
9168: PUSH
9169: LD_INT 6
9171: EQUAL
9172: IFFALSE 9200
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9174: LD_INT 51
9176: PPUSH
9177: LD_INT 6
9179: PPUSH
9180: LD_INT 2
9182: PPUSH
9183: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9187: LD_INT 57
9189: PPUSH
9190: LD_INT 6
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 322
// end ; if missionStage = 8 then
9200: LD_EXP 15
9204: PUSH
9205: LD_INT 8
9207: EQUAL
9208: IFFALSE 9236
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9210: LD_INT 52
9212: PPUSH
9213: LD_INT 6
9215: PPUSH
9216: LD_INT 2
9218: PPUSH
9219: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9223: LD_INT 58
9225: PPUSH
9226: LD_INT 6
9228: PPUSH
9229: LD_INT 2
9231: PPUSH
9232: CALL_OW 322
// end ; if missionStage = 10 then
9236: LD_EXP 15
9240: PUSH
9241: LD_INT 10
9243: EQUAL
9244: IFFALSE 9272
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9246: LD_INT 53
9248: PPUSH
9249: LD_INT 6
9251: PPUSH
9252: LD_INT 2
9254: PPUSH
9255: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9259: LD_INT 59
9261: PPUSH
9262: LD_INT 6
9264: PPUSH
9265: LD_INT 2
9267: PPUSH
9268: CALL_OW 322
// end ; if activeAttacks then
9272: LD_EXP 16
9276: IFFALSE 9796
// begin if missionStage = 2 then
9278: LD_EXP 15
9282: PUSH
9283: LD_INT 2
9285: EQUAL
9286: IFFALSE 9296
// strength := 1 ;
9288: LD_ADDR_VAR 0 5
9292: PUSH
9293: LD_INT 1
9295: ST_TO_ADDR
// if missionStage > 2 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 2
9303: GREATER
9304: IFFALSE 9314
// strength := 2 ;
9306: LD_ADDR_VAR 0 5
9310: PUSH
9311: LD_INT 2
9313: ST_TO_ADDR
// if missionStage > 6 then
9314: LD_EXP 15
9318: PUSH
9319: LD_INT 6
9321: GREATER
9322: IFFALSE 9332
// strength := 3 ;
9324: LD_ADDR_VAR 0 5
9328: PUSH
9329: LD_INT 3
9331: ST_TO_ADDR
// if missionStage > 10 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 10
9339: GREATER
9340: IFFALSE 9350
// strength := 4 ;
9342: LD_ADDR_VAR 0 5
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9350: LD_ADDR_VAR 0 2
9354: PUSH
9355: LD_VAR 0 5
9359: PPUSH
9360: CALL 7922 0 1
9364: ST_TO_ADDR
// for i in tmp do
9365: LD_ADDR_VAR 0 1
9369: PUSH
9370: LD_VAR 0 2
9374: PUSH
9375: FOR_IN
9376: IFFALSE 9476
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9378: LD_VAR 0 1
9382: PPUSH
9383: LD_VAR 0 4
9387: PUSH
9388: LD_INT 1
9390: PPUSH
9391: LD_INT 2
9393: PPUSH
9394: CALL_OW 12
9398: ARRAY
9399: PPUSH
9400: LD_INT 0
9402: PPUSH
9403: CALL_OW 49
// if i = sewiVeh then
9407: LD_VAR 0 1
9411: PUSH
9412: LD_EXP 68
9416: EQUAL
9417: IFFALSE 9452
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9419: LD_ADDR_EXP 67
9423: PUSH
9424: LD_STRING Vsevolod
9426: PPUSH
9427: LD_INT 0
9429: PPUSH
9430: LD_STRING 
9432: PPUSH
9433: CALL 62900 0 3
9437: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9438: LD_EXP 67
9442: PPUSH
9443: LD_VAR 0 1
9447: PPUSH
9448: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9452: LD_VAR 0 1
9456: PPUSH
9457: LD_INT 111
9459: PPUSH
9460: LD_INT 197
9462: PPUSH
9463: CALL_OW 111
// wait ( 0 0$2 ) ;
9467: LD_INT 70
9469: PPUSH
9470: CALL_OW 67
// end ;
9474: GO 9375
9476: POP
9477: POP
// repeat wait ( 0 0$1 ) ;
9478: LD_INT 35
9480: PPUSH
9481: CALL_OW 67
// for i in tmp do
9485: LD_ADDR_VAR 0 1
9489: PUSH
9490: LD_VAR 0 2
9494: PUSH
9495: FOR_IN
9496: IFFALSE 9777
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9498: LD_INT 81
9500: PUSH
9501: LD_INT 6
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 91
9510: PUSH
9511: LD_VAR 0 1
9515: PUSH
9516: LD_INT 12
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: LIST
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PPUSH
9528: CALL_OW 69
9532: IFFALSE 9590
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_INT 81
9541: PUSH
9542: LD_INT 6
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 92
9551: PUSH
9552: LD_VAR 0 1
9556: PUSH
9557: LD_INT 12
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: PPUSH
9574: LD_VAR 0 1
9578: PPUSH
9579: CALL_OW 74
9583: PPUSH
9584: CALL_OW 115
9588: GO 9775
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9590: LD_INT 9
9592: PPUSH
9593: LD_INT 81
9595: PUSH
9596: LD_INT 6
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 70
9607: IFFALSE 9741
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9609: LD_VAR 0 1
9613: PPUSH
9614: LD_VAR 0 6
9618: PUSH
9619: LD_INT 1
9621: ARRAY
9622: PUSH
9623: LD_INT 1
9625: ARRAY
9626: PPUSH
9627: LD_VAR 0 6
9631: PUSH
9632: LD_INT 1
9634: ARRAY
9635: PUSH
9636: LD_INT 2
9638: ARRAY
9639: PPUSH
9640: CALL_OW 297
9644: PUSH
9645: LD_INT 10
9647: GREATER
9648: PUSH
9649: LD_VAR 0 1
9653: PPUSH
9654: LD_INT 9
9656: PPUSH
9657: CALL_OW 308
9661: NOT
9662: AND
9663: IFFALSE 9702
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9665: LD_VAR 0 1
9669: PPUSH
9670: LD_VAR 0 6
9674: PUSH
9675: LD_INT 1
9677: ARRAY
9678: PUSH
9679: LD_INT 1
9681: ARRAY
9682: PPUSH
9683: LD_VAR 0 6
9687: PUSH
9688: LD_INT 1
9690: ARRAY
9691: PUSH
9692: LD_INT 2
9694: ARRAY
9695: PPUSH
9696: CALL_OW 114
9700: GO 9739
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9702: LD_VAR 0 1
9706: PPUSH
9707: LD_INT 9
9709: PPUSH
9710: LD_INT 81
9712: PUSH
9713: LD_INT 6
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PPUSH
9720: CALL_OW 70
9724: PPUSH
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 74
9734: PPUSH
9735: CALL_OW 115
// end else
9739: GO 9775
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 81
9748: PUSH
9749: LD_INT 6
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PPUSH
9756: CALL_OW 69
9760: PPUSH
9761: LD_VAR 0 1
9765: PPUSH
9766: CALL_OW 74
9770: PPUSH
9771: CALL_OW 115
// end ;
9775: GO 9495
9777: POP
9778: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9779: LD_INT 22
9781: PUSH
9782: LD_INT 6
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: CALL_OW 69
9793: NOT
9794: IFFALSE 9478
// end ; until russianDestroyed ;
9796: LD_EXP 21
9800: IFFALSE 9136
// end ;
9802: PPOPN 6
9804: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9805: LD_EXP 21
9809: NOT
9810: PUSH
9811: LD_EXP 15
9815: PUSH
9816: LD_INT 6
9818: GREATEREQUAL
9819: AND
9820: PUSH
9821: LD_INT 2
9823: PPUSH
9824: LD_INT 1
9826: PPUSH
9827: CALL 58323 0 2
9831: NOT
9832: AND
9833: IFFALSE 10789
9835: GO 9837
9837: DISABLE
9838: LD_INT 0
9840: PPUSH
9841: PPUSH
9842: PPUSH
9843: PPUSH
// begin enable ;
9844: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9845: LD_INT 22
9847: PUSH
9848: LD_INT 3
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PUSH
9855: LD_INT 30
9857: PUSH
9858: LD_INT 3
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: NOT
9874: IFFALSE 9878
// exit ;
9876: GO 10789
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9878: LD_ADDR_VAR 0 4
9882: PUSH
9883: LD_INT 22
9885: PUSH
9886: LD_INT 3
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: LD_INT 30
9895: PUSH
9896: LD_INT 34
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PUSH
9903: EMPTY
9904: LIST
9905: LIST
9906: PPUSH
9907: CALL_OW 69
9911: ST_TO_ADDR
// if Prob ( 40 ) then
9912: LD_INT 40
9914: PPUSH
9915: CALL_OW 13
9919: IFFALSE 10046
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9921: LD_INT 2
9923: PPUSH
9924: LD_INT 22
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: LD_INT 3
9932: PUSH
9933: LD_INT 49
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: PUSH
9942: LD_INT 22
9944: PUSH
9945: LD_INT 3
9947: PUSH
9948: LD_INT 3
9950: PUSH
9951: LD_INT 49
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_INT 3
9965: PUSH
9966: LD_INT 3
9968: PUSH
9969: LD_INT 49
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 24
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: LD_INT 46
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 24
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: LD_INT 46
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 3
10022: PUSH
10023: LD_INT 46
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: LIST
10039: PPUSH
10040: CALL 56968 0 2
// end else
10044: GO 10169
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10046: LD_INT 2
10048: PPUSH
10049: LD_INT 24
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 47
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 47
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 47
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 3
10129: PUSH
10130: LD_INT 46
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 24
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: LD_INT 46
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: PPUSH
10165: CALL 56968 0 2
// end ; if Difficulty > 1 then
10169: LD_OWVAR 67
10173: PUSH
10174: LD_INT 1
10176: GREATER
10177: IFFALSE 10207
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10179: LD_INT 2
10181: PPUSH
10182: LD_INT 24
10184: PUSH
10185: LD_INT 3
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 47
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: PPUSH
10203: CALL 56968 0 2
// repeat wait ( 0 0$1 ) ;
10207: LD_INT 35
10209: PPUSH
10210: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10214: LD_INT 2
10216: PPUSH
10217: LD_INT 1
10219: PPUSH
10220: CALL 58323 0 2
10224: PUSH
10225: LD_INT 6
10227: PUSH
10228: LD_INT 7
10230: PUSH
10231: LD_INT 7
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: PUSH
10239: LD_OWVAR 67
10243: ARRAY
10244: GREATEREQUAL
10245: IFFALSE 10207
// wait ( 0 0$30 ) ;
10247: LD_INT 1050
10249: PPUSH
10250: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10254: LD_ADDR_VAR 0 2
10258: PUSH
10259: LD_INT 2
10261: PPUSH
10262: LD_INT 1
10264: PPUSH
10265: CALL 58323 0 2
10269: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10270: LD_ADDR_EXP 118
10274: PUSH
10275: LD_EXP 118
10279: PPUSH
10280: LD_INT 2
10282: PPUSH
10283: LD_EXP 118
10287: PUSH
10288: LD_INT 2
10290: ARRAY
10291: PUSH
10292: LD_VAR 0 2
10296: DIFF
10297: PPUSH
10298: CALL_OW 1
10302: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10303: LD_ADDR_VAR 0 3
10307: PUSH
10308: LD_INT 0
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 12
10318: ST_TO_ADDR
// if target then
10319: LD_VAR 0 3
10323: IFFALSE 10451
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10325: LD_ADDR_VAR 0 2
10329: PUSH
10330: LD_VAR 0 2
10334: PPUSH
10335: LD_INT 24
10337: PUSH
10338: LD_INT 250
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL_OW 72
10349: ST_TO_ADDR
// for i in tmp do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_VAR 0 2
10359: PUSH
10360: FOR_IN
10361: IFFALSE 10401
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10363: LD_VAR 0 1
10367: PPUSH
10368: LD_INT 139
10370: PPUSH
10371: LD_INT 89
10373: PPUSH
10374: CALL_OW 297
10378: PUSH
10379: LD_INT 9
10381: GREATER
10382: IFFALSE 10399
// ComMoveXY ( i , 139 , 89 ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 139
10391: PPUSH
10392: LD_INT 89
10394: PPUSH
10395: CALL_OW 111
10399: GO 10360
10401: POP
10402: POP
// wait ( 0 0$1 ) ;
10403: LD_INT 35
10405: PPUSH
10406: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10410: LD_VAR 0 2
10414: PPUSH
10415: LD_INT 92
10417: PUSH
10418: LD_INT 139
10420: PUSH
10421: LD_INT 89
10423: PUSH
10424: LD_INT 9
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: PPUSH
10433: CALL_OW 72
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: LD_INT 1
10445: MINUS
10446: GREATEREQUAL
10447: IFFALSE 10325
// end else
10449: GO 10593
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10451: LD_VAR 0 2
10455: PPUSH
10456: LD_VAR 0 4
10460: PUSH
10461: LD_INT 1
10463: ARRAY
10464: PPUSH
10465: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10469: LD_ADDR_VAR 0 2
10473: PUSH
10474: LD_VAR 0 2
10478: PPUSH
10479: LD_INT 24
10481: PUSH
10482: LD_INT 250
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PPUSH
10489: CALL_OW 72
10493: ST_TO_ADDR
// for i in tmp do
10494: LD_ADDR_VAR 0 1
10498: PUSH
10499: LD_VAR 0 2
10503: PUSH
10504: FOR_IN
10505: IFFALSE 10545
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10507: LD_VAR 0 1
10511: PPUSH
10512: LD_INT 124
10514: PPUSH
10515: LD_INT 139
10517: PPUSH
10518: CALL_OW 297
10522: PUSH
10523: LD_INT 9
10525: GREATER
10526: IFFALSE 10543
// ComMoveXY ( i , 124 , 139 ) ;
10528: LD_VAR 0 1
10532: PPUSH
10533: LD_INT 124
10535: PPUSH
10536: LD_INT 139
10538: PPUSH
10539: CALL_OW 111
10543: GO 10504
10545: POP
10546: POP
// wait ( 0 0$1 ) ;
10547: LD_INT 35
10549: PPUSH
10550: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10554: LD_VAR 0 2
10558: PPUSH
10559: LD_INT 92
10561: PUSH
10562: LD_INT 124
10564: PUSH
10565: LD_INT 139
10567: PUSH
10568: LD_INT 9
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 72
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: LD_INT 1
10589: MINUS
10590: GREATEREQUAL
10591: IFFALSE 10469
// end ; repeat wait ( 0 0$1 ) ;
10593: LD_INT 35
10595: PPUSH
10596: CALL_OW 67
// for i in tmp do
10600: LD_ADDR_VAR 0 1
10604: PUSH
10605: LD_VAR 0 2
10609: PUSH
10610: FOR_IN
10611: IFFALSE 10780
// begin if GetLives ( i ) > 251 then
10613: LD_VAR 0 1
10617: PPUSH
10618: CALL_OW 256
10622: PUSH
10623: LD_INT 251
10625: GREATER
10626: IFFALSE 10751
// begin if GetWeapon ( i ) = ru_time_lapser then
10628: LD_VAR 0 1
10632: PPUSH
10633: CALL_OW 264
10637: PUSH
10638: LD_INT 49
10640: EQUAL
10641: IFFALSE 10697
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 2
10650: PUSH
10651: LD_INT 22
10653: PUSH
10654: LD_INT 1
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 22
10663: PUSH
10664: LD_INT 8
10666: PUSH
10667: EMPTY
10668: LIST
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 69
10680: PPUSH
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 74
10690: PPUSH
10691: CALL_OW 112
10695: GO 10749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_INT 2
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 1
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 22
10717: PUSH
10718: LD_INT 8
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: PPUSH
10730: CALL_OW 69
10734: PPUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 74
10744: PPUSH
10745: CALL_OW 115
// end else
10749: GO 10778
// if IsDead ( i ) then
10751: LD_VAR 0 1
10755: PPUSH
10756: CALL_OW 301
10760: IFFALSE 10778
// tmp := tmp diff i ;
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_VAR 0 2
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// end ;
10778: GO 10610
10780: POP
10781: POP
// until not tmp ;
10782: LD_VAR 0 2
10786: NOT
10787: IFFALSE 10593
// end ; end_of_file
10789: PPOPN 4
10791: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10792: LD_INT 0
10794: PPUSH
10795: PPUSH
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
// side := 7 ;
10800: LD_ADDR_VAR 0 5
10804: PUSH
10805: LD_INT 7
10807: ST_TO_ADDR
// uc_side := side ;
10808: LD_ADDR_OWVAR 20
10812: PUSH
10813: LD_VAR 0 5
10817: ST_TO_ADDR
// uc_nation := 1 ;
10818: LD_ADDR_OWVAR 21
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10826: LD_ADDR_VAR 0 2
10830: PUSH
10831: LD_INT 22
10833: PUSH
10834: LD_VAR 0 5
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PUSH
10843: LD_INT 21
10845: PUSH
10846: LD_INT 3
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 69
10861: PUSH
10862: FOR_IN
10863: IFFALSE 10879
// SetBLevel ( i , 10 ) ;
10865: LD_VAR 0 2
10869: PPUSH
10870: LD_INT 10
10872: PPUSH
10873: CALL_OW 241
10877: GO 10862
10879: POP
10880: POP
// base := GetBase ( al_depot ) ;
10881: LD_ADDR_VAR 0 4
10885: PUSH
10886: LD_INT 2
10888: PPUSH
10889: CALL_OW 274
10893: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10894: LD_ADDR_VAR 0 6
10898: PUSH
10899: LD_INT 22
10901: PUSH
10902: LD_VAR 0 5
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: LD_INT 30
10913: PUSH
10914: LD_INT 34
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PPUSH
10925: CALL_OW 69
10929: ST_TO_ADDR
// if teleport then
10930: LD_VAR 0 6
10934: IFFALSE 10955
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10936: LD_VAR 0 6
10940: PUSH
10941: LD_INT 1
10943: ARRAY
10944: PPUSH
10945: LD_INT 262
10947: PPUSH
10948: LD_INT 119
10950: PPUSH
10951: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10955: LD_VAR 0 4
10959: PPUSH
10960: LD_INT 1
10962: PPUSH
10963: LD_INT 19500
10965: PPUSH
10966: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10970: LD_VAR 0 4
10974: PPUSH
10975: LD_INT 2
10977: PPUSH
10978: LD_INT 200
10980: PPUSH
10981: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10985: LD_VAR 0 4
10989: PPUSH
10990: LD_INT 3
10992: PPUSH
10993: LD_INT 650
10995: PPUSH
10996: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11000: LD_ADDR_EXP 71
11004: PUSH
11005: LD_STRING Roth
11007: PPUSH
11008: CALL_OW 25
11012: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11013: LD_ADDR_EXP 72
11017: PUSH
11018: LD_STRING Simms
11020: PPUSH
11021: LD_EXP 1
11025: NOT
11026: PPUSH
11027: LD_STRING 10c_
11029: PPUSH
11030: CALL 62900 0 3
11034: ST_TO_ADDR
// if not Simms then
11035: LD_EXP 72
11039: NOT
11040: IFFALSE 11070
// begin uc_nation := 1 ;
11042: LD_ADDR_OWVAR 21
11046: PUSH
11047: LD_INT 1
11049: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11050: LD_INT 2
11052: PPUSH
11053: LD_INT 10
11055: PPUSH
11056: CALL_OW 384
// Simms := CreateHuman ;
11060: LD_ADDR_EXP 72
11064: PUSH
11065: CALL_OW 44
11069: ST_TO_ADDR
// end ; uc_nation := 3 ;
11070: LD_ADDR_OWVAR 21
11074: PUSH
11075: LD_INT 3
11077: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11078: LD_ADDR_EXP 73
11082: PUSH
11083: LD_STRING Kirilenkova
11085: PPUSH
11086: CALL_OW 25
11090: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11091: LD_ADDR_EXP 87
11095: PUSH
11096: LD_STRING Oblukov
11098: PPUSH
11099: CALL_OW 25
11103: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11104: LD_ADDR_EXP 74
11108: PUSH
11109: LD_STRING Dolgov
11111: PPUSH
11112: CALL_OW 25
11116: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11117: LD_ADDR_EXP 75
11121: PUSH
11122: LD_STRING Petrosyan
11124: PPUSH
11125: CALL_OW 25
11129: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11130: LD_ADDR_EXP 86
11134: PUSH
11135: LD_STRING Scholtze
11137: PPUSH
11138: CALL_OW 25
11142: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11143: LD_ADDR_EXP 85
11147: PUSH
11148: LD_STRING Kapitsova
11150: PPUSH
11151: CALL_OW 25
11155: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11156: LD_ADDR_EXP 76
11160: PUSH
11161: LD_STRING Petrovova
11163: PPUSH
11164: CALL_OW 25
11168: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11169: LD_ADDR_EXP 77
11173: PUSH
11174: LD_STRING Kuzmov
11176: PPUSH
11177: CALL_OW 25
11181: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11182: LD_ADDR_EXP 84
11186: PUSH
11187: LD_STRING Karamazov
11189: PPUSH
11190: CALL_OW 25
11194: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11195: LD_STRING 13_Lipshchin_1
11197: PPUSH
11198: LD_INT 0
11200: PPUSH
11201: CALL_OW 30
11205: IFFALSE 11220
// Lipshchin := NewCharacter ( Lipshchin ) ;
11207: LD_ADDR_EXP 78
11211: PUSH
11212: LD_STRING Lipshchin
11214: PPUSH
11215: CALL_OW 25
11219: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11220: LD_STRING 13_Titov_1
11222: PPUSH
11223: LD_INT 0
11225: PPUSH
11226: CALL_OW 30
11230: IFFALSE 11245
// Titov := NewCharacter ( Titov ) ;
11232: LD_ADDR_EXP 80
11236: PUSH
11237: LD_STRING Titov
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11245: LD_STRING 13_Gnyevko_1
11247: PPUSH
11248: LD_INT 0
11250: PPUSH
11251: CALL_OW 30
11255: IFFALSE 11270
// Gnyevko := NewCharacter ( Gnyevko ) ;
11257: LD_ADDR_EXP 79
11261: PUSH
11262: LD_STRING Gnyevko
11264: PPUSH
11265: CALL_OW 25
11269: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11270: LD_STRING 13_Xavier_1
11272: PPUSH
11273: LD_INT 0
11275: PPUSH
11276: CALL_OW 30
11280: IFFALSE 11295
// Xavier := NewCharacter ( Xavier2 ) ;
11282: LD_ADDR_EXP 81
11286: PUSH
11287: LD_STRING Xavier2
11289: PPUSH
11290: CALL_OW 25
11294: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11295: LD_STRING 13_Belkov_1
11297: PPUSH
11298: LD_INT 0
11300: PPUSH
11301: CALL_OW 30
11305: IFFALSE 11320
// Belkov := NewCharacter ( Belkov ) ;
11307: LD_ADDR_EXP 82
11311: PUSH
11312: LD_STRING Belkov
11314: PPUSH
11315: CALL_OW 25
11319: ST_TO_ADDR
// if not BurlakStatus then
11320: LD_EXP 9
11324: NOT
11325: IFFALSE 11340
// Burlak = NewCharacter ( Burlak ) ;
11327: LD_ADDR_EXP 83
11331: PUSH
11332: LD_STRING Burlak
11334: PPUSH
11335: CALL_OW 25
11339: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11340: LD_ADDR_VAR 0 3
11344: PUSH
11345: LD_EXP 71
11349: PUSH
11350: LD_EXP 73
11354: PUSH
11355: LD_EXP 87
11359: PUSH
11360: LD_EXP 74
11364: PUSH
11365: LD_EXP 75
11369: PUSH
11370: LD_EXP 86
11374: PUSH
11375: LD_EXP 85
11379: PUSH
11380: LD_EXP 76
11384: PUSH
11385: LD_EXP 77
11389: PUSH
11390: LD_EXP 84
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: ST_TO_ADDR
// if Simms then
11407: LD_EXP 72
11411: IFFALSE 11429
// tmp := tmp ^ Simms ;
11413: LD_ADDR_VAR 0 3
11417: PUSH
11418: LD_VAR 0 3
11422: PUSH
11423: LD_EXP 72
11427: ADD
11428: ST_TO_ADDR
// if Titov then
11429: LD_EXP 80
11433: IFFALSE 11451
// tmp := tmp ^ Titov ;
11435: LD_ADDR_VAR 0 3
11439: PUSH
11440: LD_VAR 0 3
11444: PUSH
11445: LD_EXP 80
11449: ADD
11450: ST_TO_ADDR
// if Lipshchin then
11451: LD_EXP 78
11455: IFFALSE 11473
// tmp := tmp ^ Lipshchin ;
11457: LD_ADDR_VAR 0 3
11461: PUSH
11462: LD_VAR 0 3
11466: PUSH
11467: LD_EXP 78
11471: ADD
11472: ST_TO_ADDR
// if Gnyevko then
11473: LD_EXP 79
11477: IFFALSE 11495
// tmp := tmp ^ Gnyevko ;
11479: LD_ADDR_VAR 0 3
11483: PUSH
11484: LD_VAR 0 3
11488: PUSH
11489: LD_EXP 79
11493: ADD
11494: ST_TO_ADDR
// if Xavier then
11495: LD_EXP 81
11499: IFFALSE 11517
// tmp := tmp ^ Xavier ;
11501: LD_ADDR_VAR 0 3
11505: PUSH
11506: LD_VAR 0 3
11510: PUSH
11511: LD_EXP 81
11515: ADD
11516: ST_TO_ADDR
// if Belkov then
11517: LD_EXP 82
11521: IFFALSE 11539
// tmp := tmp ^ Belkov ;
11523: LD_ADDR_VAR 0 3
11527: PUSH
11528: LD_VAR 0 3
11532: PUSH
11533: LD_EXP 82
11537: ADD
11538: ST_TO_ADDR
// if Burlak then
11539: LD_EXP 83
11543: IFFALSE 11561
// tmp := tmp ^ Burlak ;
11545: LD_ADDR_VAR 0 3
11549: PUSH
11550: LD_VAR 0 3
11554: PUSH
11555: LD_EXP 83
11559: ADD
11560: ST_TO_ADDR
// for i = 1 to 8 do
11561: LD_ADDR_VAR 0 2
11565: PUSH
11566: DOUBLE
11567: LD_INT 1
11569: DEC
11570: ST_TO_ADDR
11571: LD_INT 8
11573: PUSH
11574: FOR_TO
11575: IFFALSE 11641
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11577: LD_ADDR_OWVAR 21
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: LD_INT 3
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 1
11594: PPUSH
11595: LD_INT 2
11597: PPUSH
11598: CALL_OW 12
11602: ARRAY
11603: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11604: LD_INT 0
11606: PPUSH
11607: LD_VAR 0 2
11611: PUSH
11612: LD_INT 2
11614: DIV
11615: PPUSH
11616: LD_INT 10
11618: PPUSH
11619: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: CALL_OW 44
11637: ADD
11638: ST_TO_ADDR
// end ;
11639: GO 11574
11641: POP
11642: POP
// for i in tmp do
11643: LD_ADDR_VAR 0 2
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: FOR_IN
11654: IFFALSE 11679
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11656: LD_VAR 0 2
11660: PPUSH
11661: LD_INT 260
11663: PPUSH
11664: LD_INT 235
11666: PPUSH
11667: LD_INT 8
11669: PPUSH
11670: LD_INT 0
11672: PPUSH
11673: CALL_OW 50
11677: GO 11653
11679: POP
11680: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11681: LD_ADDR_EXP 99
11685: PUSH
11686: LD_EXP 99
11690: PPUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 22
11696: PUSH
11697: LD_VAR 0 5
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: LD_INT 3
11708: PUSH
11709: LD_INT 21
11711: PUSH
11712: LD_INT 2
11714: PUSH
11715: EMPTY
11716: LIST
11717: LIST
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 69
11731: PUSH
11732: LD_EXP 71
11736: PUSH
11737: LD_EXP 72
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: DIFF
11746: PPUSH
11747: CALL_OW 1
11751: ST_TO_ADDR
// uc_side := 0 ;
11752: LD_ADDR_OWVAR 20
11756: PUSH
11757: LD_INT 0
11759: ST_TO_ADDR
// uc_nation := 0 ;
11760: LD_ADDR_OWVAR 21
11764: PUSH
11765: LD_INT 0
11767: ST_TO_ADDR
// for i = 1 to 5 do
11768: LD_ADDR_VAR 0 2
11772: PUSH
11773: DOUBLE
11774: LD_INT 1
11776: DEC
11777: ST_TO_ADDR
11778: LD_INT 5
11780: PUSH
11781: FOR_TO
11782: IFFALSE 11819
// begin InitHc ;
11784: CALL_OW 19
// hc_class := class_apeman ;
11788: LD_ADDR_OWVAR 28
11792: PUSH
11793: LD_INT 12
11795: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11796: CALL_OW 44
11800: PPUSH
11801: LD_INT 299
11803: PPUSH
11804: LD_INT 229
11806: PPUSH
11807: LD_INT 10
11809: PPUSH
11810: LD_INT 0
11812: PPUSH
11813: CALL_OW 50
// end ;
11817: GO 11781
11819: POP
11820: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11821: LD_EXP 71
11825: PPUSH
11826: LD_INT 259
11828: PPUSH
11829: LD_INT 235
11831: PPUSH
11832: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11836: LD_EXP 71
11840: PPUSH
11841: LD_INT 262
11843: PPUSH
11844: LD_INT 235
11846: PPUSH
11847: CALL_OW 178
// if Simms then
11851: LD_EXP 72
11855: IFFALSE 11886
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11857: LD_EXP 72
11861: PPUSH
11862: LD_INT 262
11864: PPUSH
11865: LD_INT 235
11867: PPUSH
11868: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11872: LD_EXP 72
11876: PPUSH
11877: LD_EXP 71
11881: PPUSH
11882: CALL_OW 179
// end ; end ;
11886: LD_VAR 0 1
11890: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11891: LD_EXP 31
11895: PUSH
11896: LD_EXP 23
11900: NOT
11901: AND
11902: IFFALSE 12078
11904: GO 11906
11906: DISABLE
11907: LD_INT 0
11909: PPUSH
11910: PPUSH
11911: PPUSH
// begin enable ;
11912: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11913: LD_ADDR_VAR 0 2
11917: PUSH
11918: LD_INT 81
11920: PUSH
11921: LD_INT 7
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: LD_INT 2
11930: PUSH
11931: LD_INT 32
11933: PUSH
11934: LD_INT 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PUSH
11941: LD_INT 30
11943: PUSH
11944: LD_INT 30
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 30
11953: PUSH
11954: LD_INT 28
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 34
11963: PUSH
11964: LD_INT 49
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 34
11973: PUSH
11974: LD_INT 10
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PUSH
11981: LD_INT 34
11983: PUSH
11984: LD_INT 8
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: ST_TO_ADDR
// if not tmp then
12009: LD_VAR 0 2
12013: NOT
12014: IFFALSE 12018
// exit ;
12016: GO 12078
// target := tmp [ rand ( 1 , tmp ) ] ;
12018: LD_ADDR_VAR 0 3
12022: PUSH
12023: LD_VAR 0 2
12027: PUSH
12028: LD_INT 1
12030: PPUSH
12031: LD_VAR 0 2
12035: PPUSH
12036: CALL_OW 12
12040: ARRAY
12041: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12042: LD_VAR 0 3
12046: PPUSH
12047: CALL_OW 255
12051: PUSH
12052: LD_INT 1
12054: EQUAL
12055: IFFALSE 12066
// CenterNowOnUnits ( target ) ;
12057: LD_VAR 0 3
12061: PPUSH
12062: CALL_OW 87
// SetLives ( target , 0 ) ;
12066: LD_VAR 0 3
12070: PPUSH
12071: LD_INT 0
12073: PPUSH
12074: CALL_OW 234
// end ;
12078: PPOPN 3
12080: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12081: LD_EXP 23
12085: NOT
12086: PUSH
12087: LD_EXP 31
12091: AND
12092: IFFALSE 12614
12094: GO 12096
12096: DISABLE
12097: LD_INT 0
12099: PPUSH
12100: PPUSH
12101: PPUSH
// begin uc_side := 7 ;
12102: LD_ADDR_OWVAR 20
12106: PUSH
12107: LD_INT 7
12109: ST_TO_ADDR
// uc_nation := 1 ;
12110: LD_ADDR_OWVAR 21
12114: PUSH
12115: LD_INT 1
12117: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12118: LD_ADDR_VAR 0 3
12122: PUSH
12123: LD_INT 125
12125: PUSH
12126: LD_INT 163
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 185
12135: PUSH
12136: LD_INT 168
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: LD_INT 111
12145: PUSH
12146: LD_INT 97
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL 105346 0 1
12162: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12163: LD_ADDR_EXP 88
12167: PUSH
12168: EMPTY
12169: ST_TO_ADDR
// for i = 1 to Difficulty do
12170: LD_ADDR_VAR 0 1
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_OWVAR 67
12184: PUSH
12185: FOR_TO
12186: IFFALSE 12344
// begin InitHc ;
12188: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12192: LD_INT 0
12194: PPUSH
12195: LD_INT 8
12197: PPUSH
12198: CALL_OW 381
// un := CreateHuman ;
12202: LD_ADDR_VAR 0 2
12206: PUSH
12207: CALL_OW 44
12211: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12212: LD_VAR 0 2
12216: PPUSH
12217: LD_INT 258
12219: PPUSH
12220: LD_INT 267
12222: PPUSH
12223: LD_INT 4
12225: PPUSH
12226: LD_INT 0
12228: PPUSH
12229: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12233: LD_ADDR_EXP 88
12237: PUSH
12238: LD_EXP 88
12242: PUSH
12243: LD_VAR 0 2
12247: UNION
12248: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12249: LD_VAR 0 2
12253: PPUSH
12254: LD_VAR 0 3
12258: PUSH
12259: LD_VAR 0 1
12263: ARRAY
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_VAR 0 3
12273: PUSH
12274: LD_VAR 0 1
12278: ARRAY
12279: PUSH
12280: LD_INT 2
12282: ARRAY
12283: PPUSH
12284: LD_INT 4
12286: PPUSH
12287: LD_INT 1
12289: PPUSH
12290: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12294: LD_VAR 0 2
12298: PPUSH
12299: LD_VAR 0 3
12303: PUSH
12304: LD_VAR 0 1
12308: ARRAY
12309: PUSH
12310: LD_INT 1
12312: ARRAY
12313: PPUSH
12314: LD_VAR 0 3
12318: PUSH
12319: LD_VAR 0 1
12323: ARRAY
12324: PUSH
12325: LD_INT 2
12327: ARRAY
12328: PPUSH
12329: CALL_OW 171
// AddComInvisible ( un ) ;
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 212
// end ;
12342: GO 12185
12344: POP
12345: POP
// repeat wait ( 0 0$20 ) ;
12346: LD_INT 700
12348: PPUSH
12349: CALL_OW 67
// for i in allianceSpecialForce do
12353: LD_ADDR_VAR 0 1
12357: PUSH
12358: LD_EXP 88
12362: PUSH
12363: FOR_IN
12364: IFFALSE 12599
// begin if IsInvisible ( i ) then
12366: LD_VAR 0 1
12370: PPUSH
12371: CALL_OW 571
12375: IFFALSE 12568
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12377: LD_ADDR_VAR 0 3
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_INT 1
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 50
12394: PUSH
12395: EMPTY
12396: LIST
12397: PUSH
12398: LD_INT 56
12400: PUSH
12401: EMPTY
12402: LIST
12403: PUSH
12404: LD_INT 91
12406: PUSH
12407: LD_VAR 0 1
12411: PUSH
12412: LD_INT 25
12414: PUSH
12415: LD_INT 30
12417: PUSH
12418: LD_INT 35
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: LIST
12425: PUSH
12426: LD_OWVAR 67
12430: ARRAY
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 2
12439: PUSH
12440: LD_INT 25
12442: PUSH
12443: LD_INT 1
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 25
12452: PUSH
12453: LD_INT 2
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 25
12462: PUSH
12463: LD_INT 3
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 25
12482: PUSH
12483: LD_INT 5
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 25
12492: PUSH
12493: LD_INT 8
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: PPUSH
12516: CALL_OW 69
12520: ST_TO_ADDR
// if not tmp then
12521: LD_VAR 0 3
12525: NOT
12526: IFFALSE 12530
// continue ;
12528: GO 12363
// if Prob ( 30 * Difficulty ) then
12530: LD_INT 30
12532: PUSH
12533: LD_OWVAR 67
12537: MUL
12538: PPUSH
12539: CALL_OW 13
12543: IFFALSE 12568
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12545: LD_VAR 0 3
12549: PUSH
12550: LD_INT 1
12552: PPUSH
12553: LD_VAR 0 3
12557: PPUSH
12558: CALL_OW 12
12562: ARRAY
12563: PPUSH
12564: CALL 30032 0 1
// end ; if IsDead ( i ) then
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 301
12577: IFFALSE 12597
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12579: LD_ADDR_EXP 88
12583: PUSH
12584: LD_EXP 88
12588: PUSH
12589: LD_VAR 0 1
12593: DIFF
12594: ST_TO_ADDR
// continue ;
12595: GO 12363
// end ; end ;
12597: GO 12363
12599: POP
12600: POP
// until allianceDestroyed or not allianceSpecialForce ;
12601: LD_EXP 23
12605: PUSH
12606: LD_EXP 88
12610: NOT
12611: OR
12612: IFFALSE 12346
// end ;
12614: PPOPN 3
12616: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12617: LD_EXP 23
12621: NOT
12622: PUSH
12623: LD_EXP 31
12627: AND
12628: PUSH
12629: LD_INT 1
12631: PPUSH
12632: LD_INT 1
12634: PPUSH
12635: CALL 58323 0 2
12639: NOT
12640: AND
12641: IFFALSE 13608
12643: GO 12645
12645: DISABLE
12646: LD_INT 0
12648: PPUSH
12649: PPUSH
12650: PPUSH
12651: PPUSH
// begin enable ;
12652: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12653: LD_INT 22
12655: PUSH
12656: LD_INT 7
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: PUSH
12663: LD_INT 30
12665: PUSH
12666: LD_INT 3
12668: PUSH
12669: EMPTY
12670: LIST
12671: LIST
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PPUSH
12677: CALL_OW 69
12681: NOT
12682: IFFALSE 12686
// exit ;
12684: GO 13608
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12686: LD_ADDR_VAR 0 4
12690: PUSH
12691: LD_INT 22
12693: PUSH
12694: LD_INT 7
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 30
12703: PUSH
12704: LD_INT 34
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PPUSH
12715: CALL_OW 69
12719: ST_TO_ADDR
// if Prob ( 40 ) then
12720: LD_INT 40
12722: PPUSH
12723: CALL_OW 13
12727: IFFALSE 12854
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12729: LD_INT 1
12731: PPUSH
12732: LD_INT 5
12734: PUSH
12735: LD_INT 3
12737: PUSH
12738: LD_INT 2
12740: PUSH
12741: LD_INT 6
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 5
12752: PUSH
12753: LD_INT 3
12755: PUSH
12756: LD_INT 2
12758: PUSH
12759: LD_INT 6
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 5
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: LD_INT 6
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 24
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: LD_INT 3
12794: PUSH
12795: LD_INT 45
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 24
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: LD_INT 47
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 24
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: LD_INT 3
12830: PUSH
12831: LD_INT 45
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL 56968 0 2
// end else
12852: GO 12977
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12854: LD_INT 1
12856: PPUSH
12857: LD_INT 24
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 3
12865: PUSH
12866: LD_INT 47
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 47
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 5
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 2
12901: PUSH
12902: LD_INT 9
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 5
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: LD_INT 9
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 24
12931: PUSH
12932: LD_INT 1
12934: PUSH
12935: LD_INT 3
12937: PUSH
12938: LD_INT 45
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 24
12949: PUSH
12950: LD_INT 1
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: LD_INT 45
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL 56968 0 2
// end ; if Difficulty > 1 then
12977: LD_OWVAR 67
12981: PUSH
12982: LD_INT 1
12984: GREATER
12985: IFFALSE 13015
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12987: LD_INT 1
12989: PPUSH
12990: LD_INT 24
12992: PUSH
12993: LD_INT 3
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: LD_INT 47
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PUSH
13008: EMPTY
13009: LIST
13010: PPUSH
13011: CALL 56968 0 2
// repeat wait ( 0 0$1 ) ;
13015: LD_INT 35
13017: PPUSH
13018: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13022: LD_INT 1
13024: PPUSH
13025: LD_INT 1
13027: PPUSH
13028: CALL 58323 0 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: LD_INT 7
13038: PUSH
13039: LD_INT 7
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: LIST
13046: PUSH
13047: LD_OWVAR 67
13051: ARRAY
13052: GREATEREQUAL
13053: IFFALSE 13015
// wait ( 0 0$40 ) ;
13055: LD_INT 1400
13057: PPUSH
13058: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13062: LD_ADDR_VAR 0 2
13066: PUSH
13067: LD_INT 1
13069: PPUSH
13070: LD_INT 1
13072: PPUSH
13073: CALL 58323 0 2
13077: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13078: LD_ADDR_EXP 118
13082: PUSH
13083: LD_EXP 118
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: LD_EXP 118
13095: PUSH
13096: LD_INT 1
13098: ARRAY
13099: PUSH
13100: LD_VAR 0 2
13104: DIFF
13105: PPUSH
13106: CALL_OW 1
13110: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13111: LD_ADDR_VAR 0 3
13115: PUSH
13116: LD_INT 0
13118: PPUSH
13119: LD_INT 1
13121: PPUSH
13122: CALL_OW 12
13126: ST_TO_ADDR
// if target then
13127: LD_VAR 0 3
13131: IFFALSE 13297
// begin for i in tmp do
13133: LD_ADDR_VAR 0 1
13137: PUSH
13138: LD_VAR 0 2
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13169
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13146: LD_VAR 0 1
13150: PPUSH
13151: LD_INT 179
13153: PPUSH
13154: LD_INT 209
13156: PPUSH
13157: LD_INT 8
13159: PPUSH
13160: LD_INT 1
13162: PPUSH
13163: CALL_OW 483
13167: GO 13143
13169: POP
13170: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13171: LD_ADDR_VAR 0 2
13175: PUSH
13176: LD_VAR 0 2
13180: PPUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 250
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: PPUSH
13191: CALL_OW 72
13195: ST_TO_ADDR
// for i in tmp do
13196: LD_ADDR_VAR 0 1
13200: PUSH
13201: LD_VAR 0 2
13205: PUSH
13206: FOR_IN
13207: IFFALSE 13247
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13209: LD_VAR 0 1
13213: PPUSH
13214: LD_INT 179
13216: PPUSH
13217: LD_INT 209
13219: PPUSH
13220: CALL_OW 297
13224: PUSH
13225: LD_INT 9
13227: GREATER
13228: IFFALSE 13245
// ComMoveXY ( i , 179 , 209 ) ;
13230: LD_VAR 0 1
13234: PPUSH
13235: LD_INT 179
13237: PPUSH
13238: LD_INT 209
13240: PPUSH
13241: CALL_OW 111
13245: GO 13206
13247: POP
13248: POP
// wait ( 0 0$1 ) ;
13249: LD_INT 35
13251: PPUSH
13252: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13256: LD_VAR 0 2
13260: PPUSH
13261: LD_INT 92
13263: PUSH
13264: LD_INT 179
13266: PUSH
13267: LD_INT 209
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PPUSH
13279: CALL_OW 72
13283: PUSH
13284: LD_VAR 0 2
13288: PUSH
13289: LD_INT 1
13291: MINUS
13292: GREATEREQUAL
13293: IFFALSE 13171
// end else
13295: GO 13459
// begin for i in tmp do
13297: LD_ADDR_VAR 0 1
13301: PUSH
13302: LD_VAR 0 2
13306: PUSH
13307: FOR_IN
13308: IFFALSE 13333
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13310: LD_VAR 0 1
13314: PPUSH
13315: LD_INT 285
13317: PPUSH
13318: LD_INT 163
13320: PPUSH
13321: LD_INT 8
13323: PPUSH
13324: LD_INT 1
13326: PPUSH
13327: CALL_OW 483
13331: GO 13307
13333: POP
13334: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13335: LD_ADDR_VAR 0 2
13339: PUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: LD_INT 24
13347: PUSH
13348: LD_INT 250
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 72
13359: ST_TO_ADDR
// for i in tmp do
13360: LD_ADDR_VAR 0 1
13364: PUSH
13365: LD_VAR 0 2
13369: PUSH
13370: FOR_IN
13371: IFFALSE 13411
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13373: LD_VAR 0 1
13377: PPUSH
13378: LD_INT 285
13380: PPUSH
13381: LD_INT 163
13383: PPUSH
13384: CALL_OW 297
13388: PUSH
13389: LD_INT 9
13391: GREATER
13392: IFFALSE 13409
// ComMoveXY ( i , 285 , 163 ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: LD_INT 285
13401: PPUSH
13402: LD_INT 163
13404: PPUSH
13405: CALL_OW 111
13409: GO 13370
13411: POP
13412: POP
// wait ( 0 0$1 ) ;
13413: LD_INT 35
13415: PPUSH
13416: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13420: LD_VAR 0 2
13424: PPUSH
13425: LD_INT 92
13427: PUSH
13428: LD_INT 285
13430: PUSH
13431: LD_INT 163
13433: PUSH
13434: LD_INT 9
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: PUSH
13448: LD_VAR 0 2
13452: PUSH
13453: LD_INT 1
13455: MINUS
13456: GREATEREQUAL
13457: IFFALSE 13335
// end ; repeat wait ( 0 0$1 ) ;
13459: LD_INT 35
13461: PPUSH
13462: CALL_OW 67
// for i in tmp do
13466: LD_ADDR_VAR 0 1
13470: PUSH
13471: LD_VAR 0 2
13475: PUSH
13476: FOR_IN
13477: IFFALSE 13599
// if GetLives ( i ) > 251 then
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 256
13488: PUSH
13489: LD_INT 251
13491: GREATER
13492: IFFALSE 13581
// begin if GetWeapon ( i ) = ru_time_lapser then
13494: LD_VAR 0 1
13498: PPUSH
13499: CALL_OW 264
13503: PUSH
13504: LD_INT 49
13506: EQUAL
13507: IFFALSE 13545
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13509: LD_VAR 0 1
13513: PPUSH
13514: LD_INT 81
13516: PUSH
13517: LD_INT 7
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 69
13528: PPUSH
13529: LD_VAR 0 1
13533: PPUSH
13534: CALL_OW 74
13538: PPUSH
13539: CALL_OW 112
13543: GO 13579
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13545: LD_VAR 0 1
13549: PPUSH
13550: LD_INT 81
13552: PUSH
13553: LD_INT 7
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PPUSH
13565: LD_VAR 0 1
13569: PPUSH
13570: CALL_OW 74
13574: PPUSH
13575: CALL_OW 115
// end else
13579: GO 13597
// tmp := tmp diff i ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_VAR 0 2
13590: PUSH
13591: LD_VAR 0 1
13595: DIFF
13596: ST_TO_ADDR
13597: GO 13476
13599: POP
13600: POP
// until not tmp ;
13601: LD_VAR 0 2
13605: NOT
13606: IFFALSE 13459
// end ; end_of_file
13608: PPOPN 4
13610: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
13615: PPUSH
13616: PPUSH
// missionStage := 13 ;
13617: LD_ADDR_EXP 15
13621: PUSH
13622: LD_INT 13
13624: ST_TO_ADDR
// uc_side := 2 ;
13625: LD_ADDR_OWVAR 20
13629: PUSH
13630: LD_INT 2
13632: ST_TO_ADDR
// uc_nation := 2 ;
13633: LD_ADDR_OWVAR 21
13637: PUSH
13638: LD_INT 2
13640: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13641: LD_ADDR_EXP 89
13645: PUSH
13646: LD_STRING Omar
13648: PPUSH
13649: CALL_OW 25
13653: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13654: LD_EXP 89
13658: PPUSH
13659: LD_INT 4
13661: PPUSH
13662: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13666: LD_EXP 89
13670: PPUSH
13671: LD_INT 242
13673: PPUSH
13674: LD_INT 75
13676: PPUSH
13677: LD_INT 0
13679: PPUSH
13680: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13684: LD_ADDR_EXP 90
13688: PUSH
13689: LD_STRING Heike
13691: PPUSH
13692: CALL_OW 25
13696: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13697: LD_INT 14
13699: PPUSH
13700: LD_INT 3
13702: PPUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_INT 27
13708: PPUSH
13709: LD_INT 100
13711: PPUSH
13712: CALL 69533 0 5
// veh := CreateVehicle ;
13716: LD_ADDR_VAR 0 3
13720: PUSH
13721: CALL_OW 45
13725: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13726: LD_VAR 0 3
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 242
// SetDir ( veh , 4 ) ;
13738: LD_VAR 0 3
13742: PPUSH
13743: LD_INT 4
13745: PPUSH
13746: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13750: LD_VAR 0 3
13754: PPUSH
13755: LD_INT 241
13757: PPUSH
13758: LD_INT 72
13760: PPUSH
13761: LD_INT 0
13763: PPUSH
13764: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13768: LD_EXP 90
13772: PPUSH
13773: LD_VAR 0 3
13777: PPUSH
13778: CALL_OW 52
// if KhatamStatus then
13782: LD_EXP 8
13786: IFFALSE 13837
// begin Khatam := NewCharacter ( Khatam ) ;
13788: LD_ADDR_EXP 91
13792: PUSH
13793: LD_STRING Khatam
13795: PPUSH
13796: CALL_OW 25
13800: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13801: LD_EXP 91
13805: PPUSH
13806: LD_INT 245
13808: PPUSH
13809: LD_INT 78
13811: PPUSH
13812: LD_INT 3
13814: PPUSH
13815: LD_INT 0
13817: PPUSH
13818: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13822: LD_EXP 91
13826: PPUSH
13827: LD_INT 4
13829: PPUSH
13830: LD_INT 10
13832: PPUSH
13833: CALL_OW 237
// end ; for i = 1 to Difficulty do
13837: LD_ADDR_VAR 0 2
13841: PUSH
13842: DOUBLE
13843: LD_INT 1
13845: DEC
13846: ST_TO_ADDR
13847: LD_OWVAR 67
13851: PUSH
13852: FOR_TO
13853: IFFALSE 13919
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13855: LD_INT 0
13857: PPUSH
13858: LD_INT 7
13860: PUSH
13861: LD_OWVAR 67
13865: PLUS
13866: PPUSH
13867: CALL_OW 384
// un := CreateHuman ;
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: CALL_OW 44
13880: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13881: LD_VAR 0 4
13885: PPUSH
13886: LD_INT 28
13888: PUSH
13889: LD_INT 29
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_VAR 0 2
13900: PUSH
13901: LD_INT 2
13903: MOD
13904: PUSH
13905: LD_INT 1
13907: PLUS
13908: ARRAY
13909: PPUSH
13910: LD_INT 0
13912: PPUSH
13913: CALL_OW 49
// end ;
13917: GO 13852
13919: POP
13920: POP
// for i = 1 to 6 do
13921: LD_ADDR_VAR 0 2
13925: PUSH
13926: DOUBLE
13927: LD_INT 1
13929: DEC
13930: ST_TO_ADDR
13931: LD_INT 6
13933: PUSH
13934: FOR_TO
13935: IFFALSE 13980
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13937: LD_INT 0
13939: PPUSH
13940: LD_INT 7
13942: PUSH
13943: LD_OWVAR 67
13947: PLUS
13948: PPUSH
13949: CALL_OW 381
// un := CreateHuman ;
13953: LD_ADDR_VAR 0 4
13957: PUSH
13958: CALL_OW 44
13962: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13963: LD_VAR 0 4
13967: PPUSH
13968: LD_INT 28
13970: PPUSH
13971: LD_INT 0
13973: PPUSH
13974: CALL_OW 49
// end ;
13978: GO 13934
13980: POP
13981: POP
// for i = 1 to 3 do
13982: LD_ADDR_VAR 0 2
13986: PUSH
13987: DOUBLE
13988: LD_INT 1
13990: DEC
13991: ST_TO_ADDR
13992: LD_INT 3
13994: PUSH
13995: FOR_TO
13996: IFFALSE 14044
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13998: LD_INT 0
14000: PPUSH
14001: LD_INT 8
14003: PPUSH
14004: LD_INT 7
14006: PUSH
14007: LD_OWVAR 67
14011: PLUS
14012: PPUSH
14013: CALL_OW 380
// un := CreateHuman ;
14017: LD_ADDR_VAR 0 4
14021: PUSH
14022: CALL_OW 44
14026: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14027: LD_VAR 0 4
14031: PPUSH
14032: LD_INT 28
14034: PPUSH
14035: LD_INT 0
14037: PPUSH
14038: CALL_OW 49
// end ;
14042: GO 13995
14044: POP
14045: POP
// for i = 1 to 3 do
14046: LD_ADDR_VAR 0 2
14050: PUSH
14051: DOUBLE
14052: LD_INT 1
14054: DEC
14055: ST_TO_ADDR
14056: LD_INT 3
14058: PUSH
14059: FOR_TO
14060: IFFALSE 14150
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14062: LD_INT 14
14064: PPUSH
14065: LD_INT 2
14067: PPUSH
14068: LD_INT 1
14070: PPUSH
14071: LD_INT 28
14073: PPUSH
14074: LD_INT 80
14076: PPUSH
14077: CALL 69533 0 5
// veh := CreateVehicle ;
14081: LD_ADDR_VAR 0 3
14085: PUSH
14086: CALL_OW 45
14090: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14091: LD_VAR 0 3
14095: PPUSH
14096: LD_INT 3
14098: PPUSH
14099: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 29
14110: PPUSH
14111: LD_INT 0
14113: PPUSH
14114: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14118: LD_INT 0
14120: PPUSH
14121: LD_INT 7
14123: PUSH
14124: LD_OWVAR 67
14128: PLUS
14129: PPUSH
14130: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14134: CALL_OW 44
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: CALL_OW 52
// end ;
14148: GO 14059
14150: POP
14151: POP
// for i = 1 to 5 + Difficulty do
14152: LD_ADDR_VAR 0 2
14156: PUSH
14157: DOUBLE
14158: LD_INT 1
14160: DEC
14161: ST_TO_ADDR
14162: LD_INT 5
14164: PUSH
14165: LD_OWVAR 67
14169: PLUS
14170: PUSH
14171: FOR_TO
14172: IFFALSE 14299
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14174: LD_INT 14
14176: PPUSH
14177: LD_INT 1
14179: PPUSH
14180: LD_INT 3
14182: PPUSH
14183: CALL_OW 12
14187: PPUSH
14188: LD_INT 1
14190: PPUSH
14191: LD_INT 28
14193: PUSH
14194: LD_INT 26
14196: PUSH
14197: LD_INT 27
14199: PUSH
14200: LD_INT 25
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: PUSH
14209: LD_VAR 0 2
14213: PUSH
14214: LD_INT 4
14216: MOD
14217: PUSH
14218: LD_INT 1
14220: PLUS
14221: ARRAY
14222: PPUSH
14223: LD_INT 80
14225: PPUSH
14226: CALL 69533 0 5
// veh := CreateVehicle ;
14230: LD_ADDR_VAR 0 3
14234: PUSH
14235: CALL_OW 45
14239: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14240: LD_VAR 0 3
14244: PPUSH
14245: LD_INT 4
14247: PPUSH
14248: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14252: LD_VAR 0 3
14256: PPUSH
14257: LD_INT 28
14259: PPUSH
14260: LD_INT 0
14262: PPUSH
14263: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14267: LD_INT 0
14269: PPUSH
14270: LD_INT 7
14272: PUSH
14273: LD_OWVAR 67
14277: PLUS
14278: PPUSH
14279: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14283: CALL_OW 44
14287: PPUSH
14288: LD_VAR 0 3
14292: PPUSH
14293: CALL_OW 52
// end ;
14297: GO 14171
14299: POP
14300: POP
// for i = 1 to 3 do
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: DOUBLE
14307: LD_INT 1
14309: DEC
14310: ST_TO_ADDR
14311: LD_INT 3
14313: PUSH
14314: FOR_TO
14315: IFFALSE 14375
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14317: LD_INT 14
14319: PPUSH
14320: LD_INT 3
14322: PPUSH
14323: LD_INT 5
14325: PPUSH
14326: LD_INT 29
14328: PPUSH
14329: LD_INT 80
14331: PPUSH
14332: CALL 69533 0 5
// veh := CreateVehicle ;
14336: LD_ADDR_VAR 0 3
14340: PUSH
14341: CALL_OW 45
14345: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14346: LD_VAR 0 3
14350: PPUSH
14351: LD_INT 4
14353: PPUSH
14354: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 0
14368: PPUSH
14369: CALL_OW 49
// end ;
14373: GO 14314
14375: POP
14376: POP
// end ;
14377: LD_VAR 0 1
14381: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14382: LD_INT 22
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PPUSH
14392: CALL_OW 69
14396: IFFALSE 14696
14398: GO 14400
14400: DISABLE
14401: LD_INT 0
14403: PPUSH
14404: PPUSH
14405: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14406: LD_ADDR_VAR 0 3
14410: PUSH
14411: LD_INT 22
14413: PUSH
14414: LD_INT 2
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 25
14423: PUSH
14424: LD_INT 4
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PPUSH
14435: CALL_OW 69
14439: PUSH
14440: LD_EXP 91
14444: DIFF
14445: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: LD_INT 22
14453: PUSH
14454: LD_INT 2
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PPUSH
14461: CALL_OW 69
14465: PUSH
14466: LD_EXP 91
14470: PUSH
14471: LD_VAR 0 3
14475: UNION
14476: DIFF
14477: ST_TO_ADDR
// if Khatam then
14478: LD_EXP 91
14482: IFFALSE 14499
// ComMoveXY ( Khatam , 211 , 92 ) ;
14484: LD_EXP 91
14488: PPUSH
14489: LD_INT 211
14491: PPUSH
14492: LD_INT 92
14494: PPUSH
14495: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14499: LD_INT 197
14501: PPUSH
14502: LD_INT 80
14504: PPUSH
14505: LD_INT 2
14507: PPUSH
14508: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14512: LD_INT 213
14514: PPUSH
14515: LD_INT 90
14517: PPUSH
14518: LD_INT 2
14520: PPUSH
14521: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14525: LD_INT 215
14527: PPUSH
14528: LD_INT 129
14530: PPUSH
14531: LD_INT 2
14533: PPUSH
14534: CALL_OW 441
// if sci then
14538: LD_VAR 0 3
14542: IFFALSE 14563
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14544: LD_VAR 0 3
14548: PUSH
14549: LD_INT 1
14551: ARRAY
14552: PPUSH
14553: LD_INT 197
14555: PPUSH
14556: LD_INT 80
14558: PPUSH
14559: CALL_OW 158
// if sci > 1 then
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 1
14570: GREATER
14571: IFFALSE 14592
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14573: LD_VAR 0 3
14577: PUSH
14578: LD_INT 2
14580: ARRAY
14581: PPUSH
14582: LD_INT 213
14584: PPUSH
14585: LD_INT 90
14587: PPUSH
14588: CALL_OW 158
// if sci > 2 then
14592: LD_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: GREATER
14600: IFFALSE 14621
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14602: LD_VAR 0 3
14606: PUSH
14607: LD_INT 3
14609: ARRAY
14610: PPUSH
14611: LD_INT 215
14613: PPUSH
14614: LD_INT 129
14616: PPUSH
14617: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14621: LD_INT 35
14623: PPUSH
14624: CALL_OW 67
// for i in tmp do
14628: LD_ADDR_VAR 0 1
14632: PUSH
14633: LD_VAR 0 2
14637: PUSH
14638: FOR_IN
14639: IFFALSE 14677
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14641: LD_VAR 0 1
14645: PPUSH
14646: LD_INT 81
14648: PUSH
14649: LD_INT 2
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PPUSH
14656: CALL_OW 69
14660: PPUSH
14661: LD_VAR 0 1
14665: PPUSH
14666: CALL_OW 74
14670: PPUSH
14671: CALL_OW 115
14675: GO 14638
14677: POP
14678: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14679: LD_INT 22
14681: PUSH
14682: LD_INT 2
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: NOT
14694: IFFALSE 14621
// end ; end_of_file
14696: PPOPN 3
14698: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14699: LD_INT 0
14701: PPUSH
14702: PPUSH
14703: PPUSH
14704: PPUSH
14705: PPUSH
14706: PPUSH
14707: PPUSH
14708: PPUSH
14709: PPUSH
// Video ( true ) ;
14710: LD_INT 1
14712: PPUSH
14713: CALL 105226 0 1
// if debug then
14717: LD_EXP 1
14721: IFFALSE 14731
// dialogue_skipped := true ;
14723: LD_ADDR_OWVAR 59
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14731: LD_ADDR_VAR 0 5
14735: PUSH
14736: LD_INT 7
14738: PPUSH
14739: LD_INT 0
14741: PPUSH
14742: CALL_OW 517
14746: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14747: LD_ADDR_VAR 0 2
14751: PUSH
14752: DOUBLE
14753: LD_INT 1
14755: DEC
14756: ST_TO_ADDR
14757: LD_VAR 0 5
14761: PUSH
14762: LD_INT 1
14764: ARRAY
14765: PUSH
14766: FOR_TO
14767: IFFALSE 14812
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14769: LD_VAR 0 5
14773: PUSH
14774: LD_INT 1
14776: ARRAY
14777: PUSH
14778: LD_VAR 0 2
14782: ARRAY
14783: PPUSH
14784: LD_VAR 0 5
14788: PUSH
14789: LD_INT 2
14791: ARRAY
14792: PUSH
14793: LD_VAR 0 2
14797: ARRAY
14798: PPUSH
14799: LD_INT 1
14801: PPUSH
14802: LD_INT 15
14804: NEG
14805: PPUSH
14806: CALL 105140 0 4
14810: GO 14766
14812: POP
14813: POP
// CenterNowOnUnits ( Powell ) ;
14814: LD_EXP 55
14818: PPUSH
14819: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14823: LD_ADDR_VAR 0 5
14827: PUSH
14828: LD_EXP 53
14832: PUSH
14833: EMPTY
14834: LIST
14835: ST_TO_ADDR
// if GirlNewVeh then
14836: LD_EXP 54
14840: IFFALSE 14858
// tmp := tmp ^ GirlNewVeh ;
14842: LD_ADDR_VAR 0 5
14846: PUSH
14847: LD_VAR 0 5
14851: PUSH
14852: LD_EXP 54
14856: ADD
14857: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14858: LD_VAR 0 5
14862: PPUSH
14863: LD_INT 60
14865: PPUSH
14866: LD_INT 109
14868: PPUSH
14869: CALL_OW 111
// if KappaStatus then
14873: LD_EXP 2
14877: IFFALSE 14929
// begin Say ( JMM , D1nT-JMM-1 ) ;
14879: LD_EXP 36
14883: PPUSH
14884: LD_STRING D1nT-JMM-1
14886: PPUSH
14887: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14891: LD_EXP 55
14895: PPUSH
14896: LD_STRING D1T-Pow-1
14898: PPUSH
14899: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14903: LD_EXP 36
14907: PPUSH
14908: LD_STRING D1T-JMM-2
14910: PPUSH
14911: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14915: LD_EXP 55
14919: PPUSH
14920: LD_STRING D1T-Pow-2
14922: PPUSH
14923: CALL_OW 88
// end else
14927: GO 15135
// if JMMGirlStatus then
14929: LD_EXP 6
14933: IFFALSE 15078
// begin Say ( JMM , D1T-JMM-1 ) ;
14935: LD_EXP 36
14939: PPUSH
14940: LD_STRING D1T-JMM-1
14942: PPUSH
14943: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14947: LD_EXP 55
14951: PPUSH
14952: LD_STRING D1T-Pow-1
14954: PPUSH
14955: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14959: LD_EXP 36
14963: PPUSH
14964: LD_STRING D1T-JMM-3
14966: PPUSH
14967: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14971: LD_EXP 55
14975: PPUSH
14976: LD_STRING D1T-Pow-3
14978: PPUSH
14979: CALL_OW 88
// if JMMGirl then
14983: LD_EXP 7
14987: IFFALSE 15076
// begin case JMMGirl of 1 :
14989: LD_EXP 7
14993: PUSH
14994: LD_INT 1
14996: DOUBLE
14997: EQUAL
14998: IFTRUE 15002
15000: GO 15017
15002: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15003: LD_EXP 37
15007: PPUSH
15008: LD_STRING D1T-Joan-3
15010: PPUSH
15011: CALL_OW 88
15015: GO 15064
15017: LD_INT 2
15019: DOUBLE
15020: EQUAL
15021: IFTRUE 15025
15023: GO 15040
15025: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15026: LD_EXP 39
15030: PPUSH
15031: LD_STRING D1T-Lisa-3
15033: PPUSH
15034: CALL_OW 88
15038: GO 15064
15040: LD_INT 3
15042: DOUBLE
15043: EQUAL
15044: IFTRUE 15048
15046: GO 15063
15048: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15049: LD_EXP 51
15053: PPUSH
15054: LD_STRING D1T-Con-3
15056: PPUSH
15057: CALL_OW 88
15061: GO 15064
15063: POP
// Say ( Powell , D1T-Pow-4 ) ;
15064: LD_EXP 55
15068: PPUSH
15069: LD_STRING D1T-Pow-4
15071: PPUSH
15072: CALL_OW 88
// end ; end else
15076: GO 15135
// if not FastEnd then
15078: LD_EXP 11
15082: NOT
15083: IFFALSE 15111
// begin Say ( JMM , D1T-JMM-4 ) ;
15085: LD_EXP 36
15089: PPUSH
15090: LD_STRING D1T-JMM-4
15092: PPUSH
15093: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15097: LD_EXP 55
15101: PPUSH
15102: LD_STRING D1T-Pow-5
15104: PPUSH
15105: CALL_OW 88
// end else
15109: GO 15135
// begin Say ( JMM , D1nT-JMM-1 ) ;
15111: LD_EXP 36
15115: PPUSH
15116: LD_STRING D1nT-JMM-1
15118: PPUSH
15119: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15123: LD_EXP 55
15127: PPUSH
15128: LD_STRING D1nT-Pow-1
15130: PPUSH
15131: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15135: LD_INT 35
15137: PPUSH
15138: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15142: LD_EXP 53
15146: PPUSH
15147: CALL_OW 314
15151: NOT
15152: IFFALSE 15135
// ComExitVehicle ( JMM ) ;
15154: LD_EXP 36
15158: PPUSH
15159: CALL_OW 121
// wait ( 3 ) ;
15163: LD_INT 3
15165: PPUSH
15166: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_INT 60
15177: PPUSH
15178: LD_INT 94
15180: PPUSH
15181: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15185: LD_EXP 36
15189: PPUSH
15190: LD_EXP 55
15194: PPUSH
15195: CALL_OW 179
// if Joan then
15199: LD_EXP 37
15203: IFFALSE 15257
// begin ComExitVehicle ( Joan ) ;
15205: LD_EXP 37
15209: PPUSH
15210: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15214: LD_EXP 37
15218: PPUSH
15219: LD_INT 35
15221: PPUSH
15222: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15226: LD_EXP 37
15230: PPUSH
15231: LD_INT 65
15233: PPUSH
15234: LD_INT 104
15236: PPUSH
15237: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15241: LD_EXP 37
15245: PPUSH
15246: LD_EXP 36
15250: PPUSH
15251: CALL_OW 179
// end else
15255: GO 15391
// if Lisa and JMMGirl = 2 then
15257: LD_EXP 39
15261: PUSH
15262: LD_EXP 7
15266: PUSH
15267: LD_INT 2
15269: EQUAL
15270: AND
15271: IFFALSE 15325
// begin ComExitVehicle ( Lisa ) ;
15273: LD_EXP 39
15277: PPUSH
15278: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15282: LD_EXP 39
15286: PPUSH
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15294: LD_EXP 39
15298: PPUSH
15299: LD_INT 65
15301: PPUSH
15302: LD_INT 104
15304: PPUSH
15305: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15309: LD_EXP 39
15313: PPUSH
15314: LD_EXP 36
15318: PPUSH
15319: CALL_OW 179
// end else
15323: GO 15391
// if Connie and JMMGirl = 3 then
15325: LD_EXP 51
15329: PUSH
15330: LD_EXP 7
15334: PUSH
15335: LD_INT 3
15337: EQUAL
15338: AND
15339: IFFALSE 15391
// begin ComExitVehicle ( Connie ) ;
15341: LD_EXP 51
15345: PPUSH
15346: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15350: LD_EXP 51
15354: PPUSH
15355: LD_INT 35
15357: PPUSH
15358: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15362: LD_EXP 51
15366: PPUSH
15367: LD_INT 65
15369: PPUSH
15370: LD_INT 104
15372: PPUSH
15373: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15377: LD_EXP 51
15381: PPUSH
15382: LD_EXP 36
15386: PPUSH
15387: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15391: LD_INT 35
15393: PPUSH
15394: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15398: LD_EXP 36
15402: PPUSH
15403: LD_EXP 55
15407: PPUSH
15408: CALL_OW 296
15412: PUSH
15413: LD_INT 6
15415: LESS
15416: IFFALSE 15391
// wait ( 0 0$0.5 ) ;
15418: LD_INT 18
15420: PPUSH
15421: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15425: LD_EXP 36
15429: PPUSH
15430: LD_STRING D1-JMM-1
15432: PPUSH
15433: CALL_OW 88
// async ;
15437: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15438: LD_EXP 55
15442: PPUSH
15443: LD_STRING D1-Pow-1
15445: PPUSH
15446: CALL_OW 88
// if not dialogue_skipped then
15450: LD_OWVAR 59
15454: NOT
15455: IFFALSE 15464
// wait ( 0 0$2 ) ;
15457: LD_INT 70
15459: PPUSH
15460: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15464: LD_INT 170
15466: PPUSH
15467: LD_INT 99
15469: PPUSH
15470: LD_INT 1
15472: PPUSH
15473: LD_INT 6
15475: NEG
15476: PPUSH
15477: CALL 105140 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15481: LD_INT 174
15483: PPUSH
15484: LD_INT 115
15486: PPUSH
15487: LD_INT 1
15489: PPUSH
15490: LD_INT 6
15492: NEG
15493: PPUSH
15494: CALL 105140 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15498: LD_INT 169
15500: PPUSH
15501: LD_INT 71
15503: PPUSH
15504: LD_INT 1
15506: PPUSH
15507: LD_INT 6
15509: NEG
15510: PPUSH
15511: CALL 105140 0 4
// if not dialogue_skipped then
15515: LD_OWVAR 59
15519: NOT
15520: IFFALSE 15539
// begin CenterOnXY ( 170 , 99 ) ;
15522: LD_INT 170
15524: PPUSH
15525: LD_INT 99
15527: PPUSH
15528: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15532: LD_INT 80
15534: PPUSH
15535: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15539: LD_INT 75
15541: PPUSH
15542: LD_INT 53
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 9
15550: NEG
15551: PPUSH
15552: CALL 105140 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15556: LD_INT 54
15558: PPUSH
15559: LD_INT 42
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 9
15567: NEG
15568: PPUSH
15569: CALL 105140 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15573: LD_INT 62
15575: PPUSH
15576: LD_INT 51
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 9
15584: NEG
15585: PPUSH
15586: CALL 105140 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 75 , 53 ) ;
15597: LD_INT 75
15599: PPUSH
15600: LD_INT 53
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$4 ) ;
15607: LD_INT 140
15609: PPUSH
15610: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15614: LD_EXP 55
15618: PPUSH
15619: CALL_OW 87
// if not dialogue_skipped then
15623: LD_OWVAR 59
15627: NOT
15628: IFFALSE 15637
// wait ( 0 0$2 ) ;
15630: LD_INT 70
15632: PPUSH
15633: CALL_OW 67
// sync ;
15637: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15638: LD_EXP 36
15642: PPUSH
15643: LD_STRING D1-JMM-2
15645: PPUSH
15646: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15650: LD_EXP 55
15654: PPUSH
15655: LD_STRING D1-Pow-2
15657: PPUSH
15658: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15662: LD_EXP 36
15666: PPUSH
15667: LD_STRING D1-JMM-3
15669: PPUSH
15670: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15674: LD_EXP 55
15678: PPUSH
15679: LD_STRING D1-Pow-3
15681: PPUSH
15682: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15686: LD_EXP 36
15690: PPUSH
15691: LD_STRING D1-JMM-4
15693: PPUSH
15694: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15698: LD_EXP 55
15702: PPUSH
15703: LD_STRING D1-Pow-4
15705: PPUSH
15706: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15710: LD_EXP 36
15714: PPUSH
15715: LD_STRING D1-JMM-5
15717: PPUSH
15718: CALL_OW 88
// async ;
15722: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15723: LD_EXP 55
15727: PPUSH
15728: LD_STRING D1-Pow-5
15730: PPUSH
15731: CALL_OW 88
// if not dialogue_skipped then
15735: LD_OWVAR 59
15739: NOT
15740: IFFALSE 15749
// wait ( 0 0$3.6 ) ;
15742: LD_INT 126
15744: PPUSH
15745: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15749: LD_INT 134
15751: PPUSH
15752: LD_INT 210
15754: PPUSH
15755: LD_INT 1
15757: PPUSH
15758: LD_INT 11
15760: NEG
15761: PPUSH
15762: CALL 105140 0 4
// if not dialogue_skipped then
15766: LD_OWVAR 59
15770: NOT
15771: IFFALSE 15790
// begin CenterOnXY ( 134 , 210 ) ;
15773: LD_INT 134
15775: PPUSH
15776: LD_INT 210
15778: PPUSH
15779: CALL_OW 84
// wait ( 0 0$2 ) ;
15783: LD_INT 70
15785: PPUSH
15786: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15790: LD_INT 101
15792: PPUSH
15793: LD_INT 159
15795: PPUSH
15796: LD_INT 1
15798: PPUSH
15799: LD_INT 10
15801: NEG
15802: PPUSH
15803: CALL 105140 0 4
// if not dialogue_skipped then
15807: LD_OWVAR 59
15811: NOT
15812: IFFALSE 15831
// begin CenterOnXY ( 101 , 159 ) ;
15814: LD_INT 101
15816: PPUSH
15817: LD_INT 159
15819: PPUSH
15820: CALL_OW 84
// wait ( 0 0$2 ) ;
15824: LD_INT 70
15826: PPUSH
15827: CALL_OW 67
// end ; sync ;
15831: SYNC
// CenterNowOnUnits ( Powell ) ;
15832: LD_EXP 55
15836: PPUSH
15837: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15841: LD_ADDR_VAR 0 6
15845: PUSH
15846: LD_INT 1
15848: PUSH
15849: LD_INT 2
15851: PUSH
15852: LD_INT 3
15854: PUSH
15855: LD_INT 4
15857: PUSH
15858: LD_INT 5
15860: PUSH
15861: LD_INT 6
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: LIST
15868: LIST
15869: LIST
15870: LIST
15871: ST_TO_ADDR
// if not dialogue_skipped then
15872: LD_OWVAR 59
15876: NOT
15877: IFFALSE 16046
// begin game_speed := 4 ;
15879: LD_ADDR_OWVAR 65
15883: PUSH
15884: LD_INT 4
15886: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15887: LD_INT 210
15889: PPUSH
15890: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15894: LD_ADDR_VAR 0 7
15898: PUSH
15899: LD_STRING Q1
15901: PPUSH
15902: LD_VAR 0 6
15906: PPUSH
15907: CALL_OW 98
15911: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15912: LD_ADDR_VAR 0 7
15916: PUSH
15917: LD_STRING Q1
15919: PPUSH
15920: LD_VAR 0 6
15924: PPUSH
15925: CALL_OW 98
15929: ST_TO_ADDR
// options = options diff dec ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 6
15939: PUSH
15940: LD_VAR 0 7
15944: DIFF
15945: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15946: LD_VAR 0 7
15950: PPUSH
15951: LD_VAR 0 6
15955: PPUSH
15956: CALL 17349 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15960: LD_VAR 0 7
15964: PUSH
15965: LD_INT 5
15967: PUSH
15968: LD_INT 6
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: IN
15975: PUSH
15976: LD_VAR 0 6
15980: PUSH
15981: LD_INT 2
15983: EQUAL
15984: OR
15985: IFFALSE 15912
// if not ( dec in [ 5 , 6 ] ) then
15987: LD_VAR 0 7
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 6
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: IN
16002: NOT
16003: IFFALSE 16046
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16005: LD_ADDR_VAR 0 7
16009: PUSH
16010: LD_STRING Q1a
16012: PPUSH
16013: LD_INT 1
16015: PUSH
16016: LD_INT 2
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PPUSH
16023: CALL_OW 98
16027: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16028: LD_VAR 0 7
16032: PUSH
16033: LD_INT 4
16035: PLUS
16036: PPUSH
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL 17349 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16046: LD_INT 81
16048: PPUSH
16049: LD_INT 127
16051: PPUSH
16052: CALL_OW 84
// amount := 5 ;
16056: LD_ADDR_VAR 0 8
16060: PUSH
16061: LD_INT 5
16063: ST_TO_ADDR
// macmilan_squad := [ ] ;
16064: LD_ADDR_VAR 0 9
16068: PUSH
16069: EMPTY
16070: ST_TO_ADDR
// if vip < amount then
16071: LD_EXP 56
16075: PUSH
16076: LD_VAR 0 8
16080: LESS
16081: IFFALSE 16125
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16083: LD_ADDR_VAR 0 5
16087: PUSH
16088: LD_EXP 56
16092: PUSH
16093: LD_INT 22
16095: PUSH
16096: LD_INT 4
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 21
16105: PUSH
16106: LD_INT 1
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 69
16121: UNION
16122: ST_TO_ADDR
16123: GO 16135
// tmp := vip ;
16125: LD_ADDR_VAR 0 5
16129: PUSH
16130: LD_EXP 56
16134: ST_TO_ADDR
// tmp := tmp diff Powell ;
16135: LD_ADDR_VAR 0 5
16139: PUSH
16140: LD_VAR 0 5
16144: PUSH
16145: LD_EXP 55
16149: DIFF
16150: ST_TO_ADDR
// if tmp < amount then
16151: LD_VAR 0 5
16155: PUSH
16156: LD_VAR 0 8
16160: LESS
16161: IFFALSE 16173
// amount := tmp ;
16163: LD_ADDR_VAR 0 8
16167: PUSH
16168: LD_VAR 0 5
16172: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16173: LD_VAR 0 5
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PPUSH
16182: CALL_OW 257
16186: PUSH
16187: LD_INT 2
16189: NONEQUAL
16190: IFFALSE 16252
// begin if IsInUnit ( tmp [ 1 ] ) then
16192: LD_VAR 0 5
16196: PUSH
16197: LD_INT 1
16199: ARRAY
16200: PPUSH
16201: CALL_OW 310
16205: IFFALSE 16220
// ComExitBuilding ( tmp [ 1 ] ) ;
16207: LD_VAR 0 5
16211: PUSH
16212: LD_INT 1
16214: ARRAY
16215: PPUSH
16216: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16220: LD_VAR 0 5
16224: PUSH
16225: LD_INT 1
16227: ARRAY
16228: PPUSH
16229: LD_INT 387
16231: PPUSH
16232: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16236: LD_VAR 0 5
16240: PUSH
16241: LD_INT 1
16243: ARRAY
16244: PPUSH
16245: LD_INT 2
16247: PPUSH
16248: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16252: LD_EXP 36
16256: PPUSH
16257: LD_INT 82
16259: PPUSH
16260: LD_INT 129
16262: PPUSH
16263: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16267: LD_EXP 36
16271: PPUSH
16272: LD_EXP 55
16276: PPUSH
16277: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16281: LD_INT 22
16283: PUSH
16284: LD_INT 1
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PPUSH
16291: CALL_OW 69
16295: PUSH
16296: LD_EXP 36
16300: DIFF
16301: PPUSH
16302: LD_INT 84
16304: PPUSH
16305: LD_INT 128
16307: PPUSH
16308: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16312: LD_INT 22
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PPUSH
16322: CALL_OW 69
16326: PUSH
16327: LD_EXP 36
16331: DIFF
16332: PPUSH
16333: LD_EXP 36
16337: PPUSH
16338: CALL_OW 179
// for i = 1 to amount do
16342: LD_ADDR_VAR 0 2
16346: PUSH
16347: DOUBLE
16348: LD_INT 1
16350: DEC
16351: ST_TO_ADDR
16352: LD_VAR 0 8
16356: PUSH
16357: FOR_TO
16358: IFFALSE 16526
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16360: LD_ADDR_VAR 0 9
16364: PUSH
16365: LD_VAR 0 9
16369: PUSH
16370: LD_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: ARRAY
16380: ADD
16381: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16382: LD_VAR 0 5
16386: PUSH
16387: LD_VAR 0 2
16391: ARRAY
16392: PPUSH
16393: CALL_OW 310
16397: IFFALSE 16414
// AddComExitBuilding ( tmp [ i ] ) ;
16399: LD_VAR 0 5
16403: PUSH
16404: LD_VAR 0 2
16408: ARRAY
16409: PPUSH
16410: CALL_OW 182
// if i = 2 and JMMNewVeh then
16414: LD_VAR 0 2
16418: PUSH
16419: LD_INT 2
16421: EQUAL
16422: PUSH
16423: LD_EXP 53
16427: AND
16428: IFFALSE 16486
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16430: LD_VAR 0 5
16434: PUSH
16435: LD_VAR 0 2
16439: ARRAY
16440: PPUSH
16441: LD_EXP 53
16445: PPUSH
16446: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16450: LD_VAR 0 5
16454: PUSH
16455: LD_VAR 0 2
16459: ARRAY
16460: PPUSH
16461: LD_INT 86
16463: PPUSH
16464: LD_INT 133
16466: PPUSH
16467: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16471: LD_VAR 0 5
16475: PUSH
16476: LD_VAR 0 2
16480: ARRAY
16481: PPUSH
16482: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16486: LD_VAR 0 5
16490: PUSH
16491: LD_VAR 0 2
16495: ARRAY
16496: PPUSH
16497: LD_INT 8
16499: PPUSH
16500: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16504: LD_VAR 0 5
16508: PUSH
16509: LD_VAR 0 2
16513: ARRAY
16514: PPUSH
16515: LD_EXP 36
16519: PPUSH
16520: CALL_OW 179
// end ;
16524: GO 16357
16526: POP
16527: POP
// if GirlNewVeh then
16528: LD_EXP 54
16532: IFFALSE 16546
// SetSide ( GirlNewVeh , 4 ) ;
16534: LD_EXP 54
16538: PPUSH
16539: LD_INT 4
16541: PPUSH
16542: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16546: LD_INT 35
16548: PPUSH
16549: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16553: LD_VAR 0 9
16557: PPUSH
16558: LD_INT 95
16560: PUSH
16561: LD_INT 9
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PPUSH
16568: CALL_OW 72
16572: PUSH
16573: LD_INT 0
16575: EQUAL
16576: PUSH
16577: LD_EXP 36
16581: PPUSH
16582: LD_INT 9
16584: PPUSH
16585: CALL_OW 308
16589: NOT
16590: AND
16591: IFFALSE 16546
// wait ( 0 0$2 ) ;
16593: LD_INT 70
16595: PPUSH
16596: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16600: LD_VAR 0 9
16604: PPUSH
16605: LD_INT 1
16607: PPUSH
16608: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16612: LD_INT 21
16614: PUSH
16615: LD_INT 2
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: LD_INT 92
16624: PUSH
16625: LD_INT 83
16627: PUSH
16628: LD_INT 130
16630: PUSH
16631: LD_INT 10
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: PPUSH
16644: CALL_OW 69
16648: PPUSH
16649: LD_INT 1
16651: PPUSH
16652: CALL_OW 235
// Video ( false ) ;
16656: LD_INT 0
16658: PPUSH
16659: CALL 105226 0 1
// ChangeMissionObjectives ( M1 ) ;
16663: LD_STRING M1
16665: PPUSH
16666: CALL_OW 337
// SaveForQuickRestart ;
16670: CALL_OW 22
// missionStart := true ;
16674: LD_ADDR_EXP 13
16678: PUSH
16679: LD_INT 1
16681: ST_TO_ADDR
// missionStage := 2 ;
16682: LD_ADDR_EXP 15
16686: PUSH
16687: LD_INT 2
16689: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16690: LD_INT 105
16692: PPUSH
16693: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16697: LD_ADDR_VAR 0 5
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_INT 4
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 21
16714: PUSH
16715: LD_INT 1
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PPUSH
16726: CALL_OW 69
16730: PUSH
16731: LD_EXP 55
16735: DIFF
16736: ST_TO_ADDR
// if not tmp then
16737: LD_VAR 0 5
16741: NOT
16742: IFFALSE 16757
// tmp := [ Powell ] ;
16744: LD_ADDR_VAR 0 5
16748: PUSH
16749: LD_EXP 55
16753: PUSH
16754: EMPTY
16755: LIST
16756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16757: LD_ADDR_EXP 99
16761: PUSH
16762: LD_EXP 99
16766: PPUSH
16767: LD_INT 4
16769: PPUSH
16770: LD_INT 22
16772: PUSH
16773: LD_INT 4
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: LD_INT 23
16782: PUSH
16783: LD_INT 1
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: PUSH
16790: LD_INT 3
16792: PUSH
16793: LD_INT 21
16795: PUSH
16796: LD_INT 2
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PPUSH
16812: CALL_OW 69
16816: PUSH
16817: LD_EXP 55
16821: DIFF
16822: PPUSH
16823: CALL_OW 1
16827: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16828: LD_ADDR_VAR 0 4
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 4
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 34
16845: PUSH
16846: LD_INT 12
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: PUSH
16862: LD_INT 1
16864: ARRAY
16865: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16866: LD_VAR 0 5
16870: PUSH
16871: LD_INT 1
16873: ARRAY
16874: PPUSH
16875: CALL_OW 310
16879: IFFALSE 16894
// ComExitBuilding ( tmp [ 1 ] ) ;
16881: LD_VAR 0 5
16885: PUSH
16886: LD_INT 1
16888: ARRAY
16889: PPUSH
16890: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16894: LD_VAR 0 5
16898: PUSH
16899: LD_INT 1
16901: ARRAY
16902: PPUSH
16903: LD_VAR 0 4
16907: PPUSH
16908: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16912: LD_VAR 0 5
16916: PUSH
16917: LD_INT 1
16919: ARRAY
16920: PPUSH
16921: LD_INT 80
16923: PPUSH
16924: LD_INT 136
16926: PPUSH
16927: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16931: LD_VAR 0 5
16935: PUSH
16936: LD_INT 1
16938: ARRAY
16939: PPUSH
16940: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16944: LD_VAR 0 5
16948: PUSH
16949: LD_INT 1
16951: ARRAY
16952: PPUSH
16953: LD_INT 59
16955: PPUSH
16956: LD_INT 112
16958: PPUSH
16959: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16963: LD_VAR 0 5
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PPUSH
16972: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16976: LD_EXP 39
16980: PUSH
16981: LD_EXP 56
16985: IN
16986: PUSH
16987: LD_EXP 39
16991: PPUSH
16992: CALL_OW 255
16996: PUSH
16997: LD_INT 1
16999: EQUAL
17000: AND
17001: IFFALSE 17017
// Say ( Lisa , D3nW-Lisa-1 ) else
17003: LD_EXP 39
17007: PPUSH
17008: LD_STRING D3nW-Lisa-1
17010: PPUSH
17011: CALL_OW 88
17015: GO 17261
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17017: LD_EXP 42
17021: PUSH
17022: LD_EXP 56
17026: IN
17027: PUSH
17028: LD_EXP 42
17032: PPUSH
17033: CALL_OW 255
17037: PUSH
17038: LD_INT 1
17040: EQUAL
17041: AND
17042: IFFALSE 17058
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17044: LD_EXP 42
17048: PPUSH
17049: LD_STRING D3nW-Cyrus-1
17051: PPUSH
17052: CALL_OW 88
17056: GO 17261
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17058: LD_EXP 41
17062: PUSH
17063: LD_EXP 56
17067: IN
17068: PUSH
17069: LD_EXP 41
17073: PPUSH
17074: CALL_OW 255
17078: PUSH
17079: LD_INT 1
17081: EQUAL
17082: AND
17083: IFFALSE 17099
// Say ( Bobby , D3nW-Bobby-1 ) else
17085: LD_EXP 41
17089: PPUSH
17090: LD_STRING D3nW-Bobby-1
17092: PPUSH
17093: CALL_OW 88
17097: GO 17261
// if Gary in vip and GetSide ( Gary ) = 1 then
17099: LD_EXP 48
17103: PUSH
17104: LD_EXP 56
17108: IN
17109: PUSH
17110: LD_EXP 48
17114: PPUSH
17115: CALL_OW 255
17119: PUSH
17120: LD_INT 1
17122: EQUAL
17123: AND
17124: IFFALSE 17140
// Say ( Gary , D3nW-Gary-1 ) else
17126: LD_EXP 48
17130: PPUSH
17131: LD_STRING D3nW-Gary-1
17133: PPUSH
17134: CALL_OW 88
17138: GO 17261
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17140: LD_EXP 40
17144: PUSH
17145: LD_EXP 56
17149: IN
17150: PUSH
17151: LD_EXP 40
17155: PPUSH
17156: CALL_OW 255
17160: PUSH
17161: LD_INT 1
17163: EQUAL
17164: AND
17165: IFFALSE 17181
// Say ( Donaldson , D3nW-Don-1 ) else
17167: LD_EXP 40
17171: PPUSH
17172: LD_STRING D3nW-Don-1
17174: PPUSH
17175: CALL_OW 88
17179: GO 17261
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17181: LD_EXP 47
17185: PUSH
17186: LD_EXP 56
17190: IN
17191: PUSH
17192: LD_EXP 47
17196: PPUSH
17197: CALL_OW 255
17201: PUSH
17202: LD_INT 1
17204: EQUAL
17205: AND
17206: IFFALSE 17222
// Say ( Cornel , D3nW-Corn-1 ) else
17208: LD_EXP 47
17212: PPUSH
17213: LD_STRING D3nW-Corn-1
17215: PPUSH
17216: CALL_OW 88
17220: GO 17261
// if Frank in vip and GetSide ( Frank ) = 1 then
17222: LD_EXP 49
17226: PUSH
17227: LD_EXP 56
17231: IN
17232: PUSH
17233: LD_EXP 49
17237: PPUSH
17238: CALL_OW 255
17242: PUSH
17243: LD_INT 1
17245: EQUAL
17246: AND
17247: IFFALSE 17261
// Say ( Frank , D3nW-Frank-1 ) ;
17249: LD_EXP 49
17253: PPUSH
17254: LD_STRING D3nW-Frank-1
17256: PPUSH
17257: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17261: LD_EXP 36
17265: PPUSH
17266: LD_STRING D3nW-JMM-1
17268: PPUSH
17269: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17273: LD_EXP 36
17277: PPUSH
17278: LD_STRING D3nW-JMM-1a
17280: PPUSH
17281: CALL_OW 88
// t := 0 0$00 ;
17285: LD_ADDR_VAR 0 3
17289: PUSH
17290: LD_INT 0
17292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17293: LD_INT 35
17295: PPUSH
17296: CALL_OW 67
// t := t + 0 0$1 ;
17300: LD_ADDR_VAR 0 3
17304: PUSH
17305: LD_VAR 0 3
17309: PUSH
17310: LD_INT 35
17312: PLUS
17313: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17314: LD_INT 59
17316: PPUSH
17317: LD_INT 112
17319: PPUSH
17320: CALL_OW 428
17324: PUSH
17325: LD_VAR 0 3
17329: PUSH
17330: LD_INT 2100
17332: GREATER
17333: OR
17334: IFFALSE 17293
// activeAttacks := true ;
17336: LD_ADDR_EXP 16
17340: PUSH
17341: LD_INT 1
17343: ST_TO_ADDR
// end ;
17344: LD_VAR 0 1
17348: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17349: LD_INT 0
17351: PPUSH
// case question of 1 :
17352: LD_VAR 0 1
17356: PUSH
17357: LD_INT 1
17359: DOUBLE
17360: EQUAL
17361: IFTRUE 17365
17363: GO 17416
17365: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17366: LD_EXP 36
17370: PPUSH
17371: LD_STRING D2Mot-JMM-1
17373: PPUSH
17374: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17378: LD_EXP 55
17382: PPUSH
17383: LD_STRING D2Mot-Pow-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17390: LD_EXP 36
17394: PPUSH
17395: LD_STRING D2Mot-JMM-2
17397: PPUSH
17398: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17402: LD_EXP 55
17406: PPUSH
17407: LD_STRING D2Mot-Pow-2
17409: PPUSH
17410: CALL_OW 88
// end ; 2 :
17414: GO 17759
17416: LD_INT 2
17418: DOUBLE
17419: EQUAL
17420: IFTRUE 17424
17422: GO 17500
17424: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17425: LD_EXP 36
17429: PPUSH
17430: LD_STRING D2Rus-JMM-1
17432: PPUSH
17433: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17437: LD_EXP 55
17441: PPUSH
17442: LD_STRING D2Rus-Pow-1
17444: PPUSH
17445: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17449: LD_EXP 36
17453: PPUSH
17454: LD_STRING D2Rus-JMM-2
17456: PPUSH
17457: CALL_OW 88
// if not ( 3 in list_of_q ) then
17461: LD_INT 3
17463: PUSH
17464: LD_VAR 0 2
17468: IN
17469: NOT
17470: IFFALSE 17486
// Say ( Powell , D2Rus-Pow-2 ) else
17472: LD_EXP 55
17476: PPUSH
17477: LD_STRING D2Rus-Pow-2
17479: PPUSH
17480: CALL_OW 88
17484: GO 17498
// Say ( Powell , D2Rus-Pow-2a ) ;
17486: LD_EXP 55
17490: PPUSH
17491: LD_STRING D2Rus-Pow-2a
17493: PPUSH
17494: CALL_OW 88
// end ; 3 :
17498: GO 17759
17500: LD_INT 3
17502: DOUBLE
17503: EQUAL
17504: IFTRUE 17508
17506: GO 17593
17508: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17509: LD_EXP 36
17513: PPUSH
17514: LD_STRING D2Leg-JMM-1
17516: PPUSH
17517: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17521: LD_EXP 55
17525: PPUSH
17526: LD_STRING D2Leg-Pow-1
17528: PPUSH
17529: CALL_OW 88
// if 2 in list_of_q then
17533: LD_INT 2
17535: PUSH
17536: LD_VAR 0 2
17540: IN
17541: IFFALSE 17567
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17543: LD_EXP 36
17547: PPUSH
17548: LD_STRING D2Leg-JMM-2
17550: PPUSH
17551: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17555: LD_EXP 55
17559: PPUSH
17560: LD_STRING D2Leg-Pow-2
17562: PPUSH
17563: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17567: LD_EXP 36
17571: PPUSH
17572: LD_STRING D2Leg-JMM-3
17574: PPUSH
17575: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17579: LD_EXP 55
17583: PPUSH
17584: LD_STRING D2Leg-Pow-3
17586: PPUSH
17587: CALL_OW 88
// end ; 4 :
17591: GO 17759
17593: LD_INT 4
17595: DOUBLE
17596: EQUAL
17597: IFTRUE 17601
17599: GO 17676
17601: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17602: LD_EXP 36
17606: PPUSH
17607: LD_STRING D2Ar-JMM-1
17609: PPUSH
17610: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17614: LD_EXP 55
17618: PPUSH
17619: LD_STRING D2Ar-Pow-1
17621: PPUSH
17622: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17626: LD_EXP 36
17630: PPUSH
17631: LD_STRING D2Ar-JMM-2
17633: PPUSH
17634: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17638: LD_EXP 55
17642: PPUSH
17643: LD_STRING D2Ar-Pow-2
17645: PPUSH
17646: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17650: LD_EXP 36
17654: PPUSH
17655: LD_STRING D2Ar-JMM-3
17657: PPUSH
17658: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17662: LD_EXP 55
17666: PPUSH
17667: LD_STRING D2Ar-Pow-3
17669: PPUSH
17670: CALL_OW 88
// end ; 5 :
17674: GO 17759
17676: LD_INT 5
17678: DOUBLE
17679: EQUAL
17680: IFTRUE 17684
17682: GO 17699
17684: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17685: LD_EXP 36
17689: PPUSH
17690: LD_STRING D2Conf-JMM-1
17692: PPUSH
17693: CALL_OW 88
17697: GO 17759
17699: LD_INT 6
17701: DOUBLE
17702: EQUAL
17703: IFTRUE 17707
17705: GO 17758
17707: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17708: LD_EXP 36
17712: PPUSH
17713: LD_STRING D2Com-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17720: LD_EXP 55
17724: PPUSH
17725: LD_STRING D2Com-Pow-1
17727: PPUSH
17728: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17732: LD_EXP 36
17736: PPUSH
17737: LD_STRING D2Com-JMM-2
17739: PPUSH
17740: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17744: LD_EXP 55
17748: PPUSH
17749: LD_STRING D2Com-Pow-2
17751: PPUSH
17752: CALL_OW 88
// end ; end ;
17756: GO 17759
17758: POP
// end ;
17759: LD_VAR 0 3
17763: RET
// every 0 0$5 trigger missionStart do var tmp ;
17764: LD_EXP 13
17768: IFFALSE 18051
17770: GO 17772
17772: DISABLE
17773: LD_INT 0
17775: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17776: LD_INT 35
17778: PPUSH
17779: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17783: LD_INT 14
17785: PPUSH
17786: LD_INT 22
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PPUSH
17796: CALL_OW 70
17800: PUSH
17801: LD_EXP 15
17805: PUSH
17806: LD_INT 2
17808: PUSH
17809: LD_INT 3
17811: PUSH
17812: LD_INT 4
17814: PUSH
17815: LD_INT 5
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: AND
17825: IFFALSE 18041
// begin powellAnger := powellAnger + 1 ;
17827: LD_ADDR_EXP 17
17831: PUSH
17832: LD_EXP 17
17836: PUSH
17837: LD_INT 1
17839: PLUS
17840: ST_TO_ADDR
// Video ( true ) ;
17841: LD_INT 1
17843: PPUSH
17844: CALL 105226 0 1
// CenterNowOnUnits ( tmp ) ;
17848: LD_VAR 0 1
17852: PPUSH
17853: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17857: LD_INT 14
17859: PPUSH
17860: LD_INT 22
17862: PUSH
17863: LD_INT 1
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PPUSH
17870: CALL_OW 70
17874: PPUSH
17875: LD_INT 86
17877: PPUSH
17878: LD_INT 133
17880: PPUSH
17881: CALL_OW 111
// async ;
17885: ASYNC
// case powellAnger of 1 :
17886: LD_EXP 17
17890: PUSH
17891: LD_INT 1
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17914
17899: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17900: LD_EXP 55
17904: PPUSH
17905: LD_STRING DBack1-Pow-1
17907: PPUSH
17908: CALL_OW 88
17912: GO 17961
17914: LD_INT 2
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17937
17922: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17923: LD_EXP 55
17927: PPUSH
17928: LD_STRING DBack2-Pow-1
17930: PPUSH
17931: CALL_OW 88
17935: GO 17961
17937: LD_INT 3
17939: DOUBLE
17940: EQUAL
17941: IFTRUE 17945
17943: GO 17960
17945: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17946: LD_EXP 55
17950: PPUSH
17951: LD_STRING DBack3-Pow-1
17953: PPUSH
17954: CALL_OW 88
17958: GO 17961
17960: POP
// sync ;
17961: SYNC
// repeat wait ( 0 0$1 ) ;
17962: LD_INT 35
17964: PPUSH
17965: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17969: LD_INT 14
17971: PPUSH
17972: LD_INT 22
17974: PUSH
17975: LD_INT 1
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: PPUSH
17982: CALL_OW 70
17986: PPUSH
17987: LD_INT 86
17989: PPUSH
17990: LD_INT 133
17992: PPUSH
17993: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17997: LD_INT 14
17999: PPUSH
18000: LD_INT 22
18002: PUSH
18003: LD_INT 1
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PPUSH
18010: CALL_OW 70
18014: NOT
18015: IFFALSE 17962
// if powellAnger >= 3 then
18017: LD_EXP 17
18021: PUSH
18022: LD_INT 3
18024: GREATEREQUAL
18025: IFFALSE 18034
// YouLost ( Dismissed ) ;
18027: LD_STRING Dismissed
18029: PPUSH
18030: CALL_OW 104
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 105226 0 1
// end ; until missionStage > 5 ;
18041: LD_EXP 15
18045: PUSH
18046: LD_INT 5
18048: GREATER
18049: IFFALSE 17776
// end ;
18051: PPOPN 1
18053: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18054: LD_EXP 13
18058: PUSH
18059: LD_INT 22
18061: PUSH
18062: LD_INT 4
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 21
18071: PUSH
18072: LD_INT 2
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PPUSH
18083: CALL_OW 69
18087: PUSH
18088: LD_INT 4
18090: GREATEREQUAL
18091: AND
18092: PUSH
18093: LD_EXP 15
18097: PUSH
18098: LD_INT 2
18100: EQUAL
18101: AND
18102: IFFALSE 19925
18104: GO 18106
18106: DISABLE
18107: LD_INT 0
18109: PPUSH
18110: PPUSH
18111: PPUSH
18112: PPUSH
18113: PPUSH
18114: PPUSH
18115: PPUSH
18116: PPUSH
// begin missionStage := 3 ;
18117: LD_ADDR_EXP 15
18121: PUSH
18122: LD_INT 3
18124: ST_TO_ADDR
// retreat := false ;
18125: LD_ADDR_VAR 0 4
18129: PUSH
18130: LD_INT 0
18132: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18133: LD_ADDR_VAR 0 5
18137: PUSH
18138: LD_INT 22
18140: PUSH
18141: LD_INT 4
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: PUSH
18148: LD_INT 30
18150: PUSH
18151: LD_INT 4
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PPUSH
18162: CALL_OW 69
18166: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18167: LD_ADDR_VAR 0 6
18171: PUSH
18172: LD_INT 22
18174: PUSH
18175: LD_INT 4
18177: PUSH
18178: EMPTY
18179: LIST
18180: LIST
18181: PUSH
18182: LD_INT 30
18184: PUSH
18185: LD_INT 5
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PPUSH
18196: CALL_OW 69
18200: ST_TO_ADDR
// if not bar then
18201: LD_VAR 0 6
18205: NOT
18206: IFFALSE 18259
// begin repeat wait ( 0 0$1 ) ;
18208: LD_INT 35
18210: PPUSH
18211: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18215: LD_INT 22
18217: PUSH
18218: LD_INT 4
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 3
18227: PUSH
18228: LD_INT 57
18230: PUSH
18231: EMPTY
18232: LIST
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: PUSH
18238: LD_INT 30
18240: PUSH
18241: LD_INT 5
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: PPUSH
18253: CALL_OW 69
18257: IFFALSE 18208
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18259: LD_ADDR_VAR 0 6
18263: PUSH
18264: LD_INT 22
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: EMPTY
18271: LIST
18272: LIST
18273: PUSH
18274: LD_INT 30
18276: PUSH
18277: LD_INT 5
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: EMPTY
18285: LIST
18286: LIST
18287: PPUSH
18288: CALL_OW 69
18292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18300: LD_EXP 118
18304: PUSH
18305: LD_INT 4
18307: ARRAY
18308: PUSH
18309: LD_INT 4
18311: GREATEREQUAL
18312: IFFALSE 18293
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18314: LD_ADDR_VAR 0 2
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_INT 4
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 2
18331: PUSH
18332: LD_INT 25
18334: PUSH
18335: LD_INT 1
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PUSH
18342: LD_INT 25
18344: PUSH
18345: LD_INT 2
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 25
18354: PUSH
18355: LD_INT 3
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: LD_INT 25
18364: PUSH
18365: LD_INT 4
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PUSH
18372: LD_INT 25
18374: PUSH
18375: LD_INT 5
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: PPUSH
18394: CALL_OW 69
18398: PUSH
18399: LD_EXP 55
18403: PUSH
18404: LD_EXP 56
18408: ADD
18409: DIFF
18410: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18411: LD_ADDR_VAR 0 3
18415: PUSH
18416: LD_VAR 0 2
18420: PPUSH
18421: LD_INT 26
18423: PUSH
18424: LD_INT 1
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PPUSH
18431: CALL_OW 72
18435: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18436: LD_ADDR_VAR 0 2
18440: PUSH
18441: LD_VAR 0 2
18445: PUSH
18446: LD_VAR 0 3
18450: DIFF
18451: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18452: LD_ADDR_VAR 0 2
18456: PUSH
18457: LD_VAR 0 2
18461: PPUSH
18462: LD_INT 1
18464: PPUSH
18465: CALL 103879 0 2
18469: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18470: LD_ADDR_VAR 0 3
18474: PUSH
18475: LD_VAR 0 3
18479: PPUSH
18480: LD_INT 1
18482: PPUSH
18483: CALL 103879 0 2
18487: ST_TO_ADDR
// for i = 1 to 4 do
18488: LD_ADDR_VAR 0 1
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 4
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18668
// begin if tmp2 then
18504: LD_VAR 0 3
18508: IFFALSE 18589
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18510: LD_ADDR_EXP 18
18514: PUSH
18515: LD_EXP 18
18519: PPUSH
18520: LD_INT 1
18522: PPUSH
18523: LD_EXP 18
18527: PUSH
18528: LD_INT 1
18530: ARRAY
18531: PUSH
18532: LD_VAR 0 3
18536: PUSH
18537: LD_VAR 0 3
18541: ARRAY
18542: ADD
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18549: LD_VAR 0 3
18553: PUSH
18554: LD_VAR 0 3
18558: ARRAY
18559: PPUSH
18560: LD_INT 1
18562: PPUSH
18563: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_VAR 0 3
18576: PPUSH
18577: LD_VAR 0 3
18581: PPUSH
18582: CALL_OW 3
18586: ST_TO_ADDR
// end else
18587: GO 18666
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18589: LD_ADDR_EXP 18
18593: PUSH
18594: LD_EXP 18
18598: PPUSH
18599: LD_INT 1
18601: PPUSH
18602: LD_EXP 18
18606: PUSH
18607: LD_INT 1
18609: ARRAY
18610: PUSH
18611: LD_VAR 0 2
18615: PUSH
18616: LD_VAR 0 2
18620: ARRAY
18621: ADD
18622: PPUSH
18623: CALL_OW 1
18627: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18628: LD_VAR 0 2
18632: PUSH
18633: LD_VAR 0 2
18637: ARRAY
18638: PPUSH
18639: LD_INT 1
18641: PPUSH
18642: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18646: LD_ADDR_VAR 0 2
18650: PUSH
18651: LD_VAR 0 2
18655: PPUSH
18656: LD_VAR 0 2
18660: PPUSH
18661: CALL_OW 3
18665: ST_TO_ADDR
// end ; end ;
18666: GO 18501
18668: POP
18669: POP
// if tmp2 then
18670: LD_VAR 0 3
18674: IFFALSE 18692
// tmp := tmp union tmp2 ;
18676: LD_ADDR_VAR 0 2
18680: PUSH
18681: LD_VAR 0 2
18685: PUSH
18686: LD_VAR 0 3
18690: UNION
18691: ST_TO_ADDR
// for i = 1 to 4 do
18692: LD_ADDR_VAR 0 1
18696: PUSH
18697: DOUBLE
18698: LD_INT 1
18700: DEC
18701: ST_TO_ADDR
18702: LD_INT 4
18704: PUSH
18705: FOR_TO
18706: IFFALSE 18755
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18708: LD_ADDR_EXP 18
18712: PUSH
18713: LD_EXP 18
18717: PPUSH
18718: LD_INT 2
18720: PPUSH
18721: LD_EXP 18
18725: PUSH
18726: LD_INT 2
18728: ARRAY
18729: PUSH
18730: LD_VAR 0 2
18734: PUSH
18735: LD_VAR 0 2
18739: PUSH
18740: LD_VAR 0 1
18744: MINUS
18745: ARRAY
18746: ADD
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
18753: GO 18705
18755: POP
18756: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18757: LD_ADDR_EXP 99
18761: PUSH
18762: LD_EXP 99
18766: PPUSH
18767: LD_INT 4
18769: PPUSH
18770: LD_EXP 99
18774: PUSH
18775: LD_INT 4
18777: ARRAY
18778: PUSH
18779: LD_EXP 18
18783: PUSH
18784: LD_INT 1
18786: ARRAY
18787: DIFF
18788: PPUSH
18789: CALL_OW 1
18793: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18794: LD_VAR 0 5
18798: PUSH
18799: LD_INT 1
18801: ARRAY
18802: PPUSH
18803: CALL_OW 313
18807: IFFALSE 18862
// begin for i in UnitsInside ( arm [ 1 ] ) do
18809: LD_ADDR_VAR 0 1
18813: PUSH
18814: LD_VAR 0 5
18818: PUSH
18819: LD_INT 1
18821: ARRAY
18822: PPUSH
18823: CALL_OW 313
18827: PUSH
18828: FOR_IN
18829: IFFALSE 18860
// begin ComExitBuilding ( i ) ;
18831: LD_VAR 0 1
18835: PPUSH
18836: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18840: LD_VAR 0 1
18844: PPUSH
18845: LD_VAR 0 6
18849: PUSH
18850: LD_INT 1
18852: ARRAY
18853: PPUSH
18854: CALL_OW 180
// end ;
18858: GO 18828
18860: POP
18861: POP
// end ; wait ( 0 0$3 ) ;
18862: LD_INT 105
18864: PPUSH
18865: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18869: LD_ADDR_VAR 0 1
18873: PUSH
18874: LD_EXP 18
18878: PUSH
18879: LD_INT 1
18881: ARRAY
18882: PUSH
18883: FOR_IN
18884: IFFALSE 18991
// begin if IsInUnit ( i ) then
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 310
18895: IFFALSE 18906
// ComExitBuilding ( i ) ;
18897: LD_VAR 0 1
18901: PPUSH
18902: CALL_OW 122
// if GetClass ( i ) <> 1 then
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 257
18915: PUSH
18916: LD_INT 1
18918: NONEQUAL
18919: IFFALSE 18960
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18921: LD_VAR 0 1
18925: PPUSH
18926: LD_VAR 0 5
18930: PUSH
18931: LD_INT 1
18933: ARRAY
18934: PPUSH
18935: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18939: LD_VAR 0 1
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 183
// AddComExitBuilding ( i ) ;
18951: LD_VAR 0 1
18955: PPUSH
18956: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18960: LD_VAR 0 1
18964: PPUSH
18965: LD_INT 60
18967: PPUSH
18968: LD_INT 94
18970: PPUSH
18971: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_EXP 55
18984: PPUSH
18985: CALL_OW 179
// end ;
18989: GO 18883
18991: POP
18992: POP
// wait ( 0 0$15 ) ;
18993: LD_INT 525
18995: PPUSH
18996: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19000: LD_EXP 55
19004: PPUSH
19005: LD_STRING D4-Pow-1
19007: PPUSH
19008: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19012: LD_ADDR_VAR 0 2
19016: PUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PPUSH
19026: LD_INT 26
19028: PUSH
19029: LD_INT 1
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PPUSH
19036: CALL_OW 72
19040: ST_TO_ADDR
// if tmp then
19041: LD_VAR 0 2
19045: IFFALSE 19063
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19047: LD_VAR 0 2
19051: PUSH
19052: LD_INT 1
19054: ARRAY
19055: PPUSH
19056: LD_STRING D4-Sol1-1
19058: PPUSH
19059: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19063: LD_EXP 55
19067: PPUSH
19068: LD_STRING D4-Pow-2
19070: PPUSH
19071: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19075: LD_ADDR_VAR 0 1
19079: PUSH
19080: DOUBLE
19081: LD_INT 1
19083: DEC
19084: ST_TO_ADDR
19085: LD_EXP 18
19089: PUSH
19090: LD_INT 1
19092: ARRAY
19093: PUSH
19094: FOR_TO
19095: IFFALSE 19188
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19097: LD_EXP 18
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: PUSH
19106: LD_VAR 0 1
19110: ARRAY
19111: PPUSH
19112: LD_EXP 118
19116: PUSH
19117: LD_INT 4
19119: ARRAY
19120: PUSH
19121: LD_INT 1
19123: ARRAY
19124: PPUSH
19125: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19129: LD_ADDR_EXP 118
19133: PUSH
19134: LD_EXP 118
19138: PPUSH
19139: LD_INT 4
19141: PPUSH
19142: LD_EXP 118
19146: PUSH
19147: LD_INT 4
19149: ARRAY
19150: PPUSH
19151: LD_INT 1
19153: PPUSH
19154: CALL_OW 3
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19164: LD_INT 8
19166: PPUSH
19167: LD_EXP 18
19171: PUSH
19172: LD_INT 1
19174: ARRAY
19175: PUSH
19176: LD_VAR 0 1
19180: ARRAY
19181: PPUSH
19182: CALL_OW 471
// end ;
19186: GO 19094
19188: POP
19189: POP
// repeat wait ( 0 0$1 ) ;
19190: LD_INT 35
19192: PPUSH
19193: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19197: LD_EXP 18
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: LD_INT 55
19208: PUSH
19209: EMPTY
19210: LIST
19211: PPUSH
19212: CALL_OW 72
19216: PUSH
19217: LD_INT 4
19219: GREATEREQUAL
19220: IFFALSE 19190
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19222: LD_EXP 18
19226: PUSH
19227: LD_INT 1
19229: ARRAY
19230: PPUSH
19231: LD_INT 69
19233: PPUSH
19234: LD_INT 94
19236: PPUSH
19237: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19241: LD_EXP 18
19245: PUSH
19246: LD_INT 1
19248: ARRAY
19249: PPUSH
19250: LD_INT 82
19252: PPUSH
19253: LD_INT 83
19255: PPUSH
19256: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19260: LD_EXP 18
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: LD_INT 77
19271: PPUSH
19272: LD_INT 69
19274: PPUSH
19275: CALL_OW 174
// repeat wait ( 3 ) ;
19279: LD_INT 3
19281: PPUSH
19282: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19286: LD_ADDR_VAR 0 1
19290: PUSH
19291: LD_EXP 18
19295: PUSH
19296: LD_INT 1
19298: ARRAY
19299: PUSH
19300: FOR_IN
19301: IFFALSE 19437
// begin if GetLives ( i ) < 990 then
19303: LD_VAR 0 1
19307: PPUSH
19308: CALL_OW 256
19312: PUSH
19313: LD_INT 990
19315: LESS
19316: IFFALSE 19330
// SetLives ( i , 1000 ) ;
19318: LD_VAR 0 1
19322: PPUSH
19323: LD_INT 1000
19325: PPUSH
19326: CALL_OW 234
// if not IsInUnit ( i ) then
19330: LD_VAR 0 1
19334: PPUSH
19335: CALL_OW 310
19339: NOT
19340: IFFALSE 19435
// begin if not HasTask ( i ) then
19342: LD_VAR 0 1
19346: PPUSH
19347: CALL_OW 314
19351: NOT
19352: IFFALSE 19369
// ComMoveXY ( i , 64 , 93 ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 64
19361: PPUSH
19362: LD_INT 93
19364: PPUSH
19365: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19369: LD_VAR 0 4
19373: NOT
19374: PUSH
19375: LD_VAR 0 1
19379: PPUSH
19380: CALL_OW 258
19384: PUSH
19385: LD_INT 1
19387: EQUAL
19388: AND
19389: IFFALSE 19435
// begin retreat := true ;
19391: LD_ADDR_VAR 0 4
19395: PUSH
19396: LD_INT 1
19398: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19399: LD_VAR 0 1
19403: PPUSH
19404: LD_INT 2
19406: PPUSH
19407: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19411: LD_VAR 0 1
19415: PPUSH
19416: LD_STRING D4a-Sol1-1
19418: PPUSH
19419: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19423: LD_EXP 55
19427: PPUSH
19428: LD_STRING D4a-Pow-1
19430: PPUSH
19431: CALL_OW 88
// end ; end ; end ;
19435: GO 19300
19437: POP
19438: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19439: LD_EXP 18
19443: PUSH
19444: LD_INT 1
19446: ARRAY
19447: PPUSH
19448: LD_INT 95
19450: PUSH
19451: LD_INT 9
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 3
19460: PUSH
19461: LD_INT 55
19463: PUSH
19464: EMPTY
19465: LIST
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: PPUSH
19475: CALL_OW 72
19479: PUSH
19480: LD_INT 4
19482: GREATEREQUAL
19483: IFFALSE 19279
// for i in powellSquadAttack [ 1 ] do
19485: LD_ADDR_VAR 0 1
19489: PUSH
19490: LD_EXP 18
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PUSH
19499: FOR_IN
19500: IFFALSE 19636
// begin if GetTag ( i ) = 2 then
19502: LD_VAR 0 1
19506: PPUSH
19507: CALL_OW 110
19511: PUSH
19512: LD_INT 2
19514: EQUAL
19515: IFFALSE 19577
// begin ComMoveXY ( i , 60 , 94 ) ;
19517: LD_VAR 0 1
19521: PPUSH
19522: LD_INT 60
19524: PPUSH
19525: LD_INT 94
19527: PPUSH
19528: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19532: LD_VAR 0 1
19536: PPUSH
19537: LD_EXP 55
19541: PPUSH
19542: CALL_OW 179
// wait ( 0 0$3 ) ;
19546: LD_INT 105
19548: PPUSH
19549: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19553: LD_VAR 0 1
19557: PPUSH
19558: LD_STRING D4a-Sol1-2
19560: PPUSH
19561: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19565: LD_EXP 55
19569: PPUSH
19570: LD_STRING D4a-Pow-2
19572: PPUSH
19573: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19577: LD_VAR 0 1
19581: PPUSH
19582: LD_INT 0
19584: PPUSH
19585: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19589: LD_ADDR_EXP 99
19593: PUSH
19594: LD_EXP 99
19598: PPUSH
19599: LD_INT 4
19601: PPUSH
19602: LD_EXP 99
19606: PUSH
19607: LD_INT 4
19609: ARRAY
19610: PUSH
19611: LD_VAR 0 1
19615: UNION
19616: PPUSH
19617: CALL_OW 1
19621: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19622: LD_INT 8
19624: PPUSH
19625: LD_VAR 0 1
19629: PPUSH
19630: CALL_OW 472
// end ;
19634: GO 19499
19636: POP
19637: POP
// wait ( 4 4$00 ) ;
19638: LD_INT 8400
19640: PPUSH
19641: CALL_OW 67
// uc_side := 6 ;
19645: LD_ADDR_OWVAR 20
19649: PUSH
19650: LD_INT 6
19652: ST_TO_ADDR
// uc_nation := 3 ;
19653: LD_ADDR_OWVAR 21
19657: PUSH
19658: LD_INT 3
19660: ST_TO_ADDR
// ru := [ ] ;
19661: LD_ADDR_VAR 0 7
19665: PUSH
19666: EMPTY
19667: ST_TO_ADDR
// for i = 1 to 4 do
19668: LD_ADDR_VAR 0 1
19672: PUSH
19673: DOUBLE
19674: LD_INT 1
19676: DEC
19677: ST_TO_ADDR
19678: LD_INT 4
19680: PUSH
19681: FOR_TO
19682: IFFALSE 19783
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19684: LD_INT 22
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 3
19692: PPUSH
19693: LD_INT 43
19695: PUSH
19696: LD_INT 44
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_INT 1
19705: PPUSH
19706: LD_INT 2
19708: PPUSH
19709: CALL_OW 12
19713: ARRAY
19714: PPUSH
19715: LD_INT 89
19717: PPUSH
19718: CALL 69533 0 5
// un := CreateVehicle ;
19722: LD_ADDR_VAR 0 8
19726: PUSH
19727: CALL_OW 45
19731: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19732: LD_VAR 0 8
19736: PPUSH
19737: LD_INT 4
19739: PPUSH
19740: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19744: LD_VAR 0 8
19748: PPUSH
19749: LD_INT 136
19751: PPUSH
19752: LD_INT 90
19754: PPUSH
19755: LD_INT 8
19757: PPUSH
19758: LD_INT 0
19760: PPUSH
19761: CALL_OW 50
// ru := ru ^ un ;
19765: LD_ADDR_VAR 0 7
19769: PUSH
19770: LD_VAR 0 7
19774: PUSH
19775: LD_VAR 0 8
19779: ADD
19780: ST_TO_ADDR
// end ;
19781: GO 19681
19783: POP
19784: POP
// if ru then
19785: LD_VAR 0 7
19789: IFFALSE 19806
// ComAgressiveMove ( ru , 80 , 92 ) ;
19791: LD_VAR 0 7
19795: PPUSH
19796: LD_INT 80
19798: PPUSH
19799: LD_INT 92
19801: PPUSH
19802: CALL_OW 114
// wait ( 8 8$00 ) ;
19806: LD_INT 16800
19808: PPUSH
19809: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19813: LD_INT 4
19815: PPUSH
19816: LD_INT 3
19818: PUSH
19819: LD_INT 1
19821: PUSH
19822: LD_INT 1
19824: PUSH
19825: LD_INT 5
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: PUSH
19834: LD_INT 4
19836: PUSH
19837: LD_INT 1
19839: PUSH
19840: LD_INT 1
19842: PUSH
19843: LD_INT 6
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: PUSH
19852: LD_INT 4
19854: PUSH
19855: LD_INT 1
19857: PUSH
19858: LD_INT 1
19860: PUSH
19861: LD_INT 7
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: PUSH
19870: LD_INT 3
19872: PUSH
19873: LD_INT 1
19875: PUSH
19876: LD_INT 1
19878: PUSH
19879: LD_INT 7
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 1
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 5
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL 56920 0 2
// missionStage := 4 ;
19917: LD_ADDR_EXP 15
19921: PUSH
19922: LD_INT 4
19924: ST_TO_ADDR
// end ;
19925: PPOPN 8
19927: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19928: LD_EXP 15
19932: PUSH
19933: LD_INT 4
19935: EQUAL
19936: PUSH
19937: LD_INT 22
19939: PUSH
19940: LD_INT 4
19942: PUSH
19943: EMPTY
19944: LIST
19945: LIST
19946: PUSH
19947: LD_INT 21
19949: PUSH
19950: LD_INT 2
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: PPUSH
19961: CALL_OW 69
19965: PUSH
19966: LD_INT 5
19968: GREATEREQUAL
19969: AND
19970: IFFALSE 24056
19972: GO 19974
19974: DISABLE
19975: LD_INT 0
19977: PPUSH
19978: PPUSH
19979: PPUSH
19980: PPUSH
19981: PPUSH
19982: PPUSH
19983: PPUSH
19984: PPUSH
19985: PPUSH
19986: PPUSH
19987: PPUSH
19988: PPUSH
19989: PPUSH
// begin missionStage := 5 ;
19990: LD_ADDR_EXP 15
19994: PUSH
19995: LD_INT 5
19997: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19998: LD_ADDR_VAR 0 10
20002: PUSH
20003: LD_INT 22
20005: PUSH
20006: LD_INT 4
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 2
20015: PUSH
20016: LD_INT 30
20018: PUSH
20019: LD_INT 4
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 30
20028: PUSH
20029: LD_INT 5
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: EMPTY
20042: LIST
20043: LIST
20044: PPUSH
20045: CALL_OW 69
20049: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20050: LD_ADDR_VAR 0 6
20054: PUSH
20055: LD_INT 22
20057: PUSH
20058: LD_INT 4
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PUSH
20065: LD_INT 21
20067: PUSH
20068: LD_INT 1
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: PUSH
20075: LD_INT 3
20077: PUSH
20078: LD_INT 25
20080: PUSH
20081: LD_INT 16
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PUSH
20092: LD_INT 3
20094: PUSH
20095: LD_INT 25
20097: PUSH
20098: LD_INT 12
20100: PUSH
20101: EMPTY
20102: LIST
20103: LIST
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: PPUSH
20115: CALL_OW 69
20119: PUSH
20120: LD_EXP 55
20124: DIFF
20125: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20126: LD_ADDR_VAR 0 9
20130: PUSH
20131: LD_INT 22
20133: PUSH
20134: LD_INT 4
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: PUSH
20141: LD_INT 30
20143: PUSH
20144: LD_INT 3
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PPUSH
20155: CALL_OW 69
20159: PUSH
20160: LD_INT 1
20162: ARRAY
20163: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20171: LD_EXP 118
20175: PUSH
20176: LD_INT 4
20178: ARRAY
20179: PUSH
20180: LD_INT 5
20182: GREATEREQUAL
20183: PUSH
20184: LD_EXP 118
20188: PUSH
20189: LD_INT 4
20191: ARRAY
20192: PPUSH
20193: LD_INT 58
20195: PUSH
20196: EMPTY
20197: LIST
20198: PPUSH
20199: CALL_OW 72
20203: PUSH
20204: LD_INT 5
20206: GREATEREQUAL
20207: AND
20208: IFFALSE 20164
// powellAllowRetreat := false ;
20210: LD_ADDR_EXP 19
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20218: LD_INT 700
20220: PPUSH
20221: CALL_OW 67
// activeAttacks := false ;
20225: LD_ADDR_EXP 16
20229: PUSH
20230: LD_INT 0
20232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20233: LD_INT 35
20235: PPUSH
20236: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20240: LD_INT 22
20242: PUSH
20243: LD_INT 6
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: PPUSH
20250: CALL_OW 69
20254: PUSH
20255: LD_INT 0
20257: EQUAL
20258: IFFALSE 20233
// tmp := mc_vehicles [ 4 ] ;
20260: LD_ADDR_VAR 0 3
20264: PUSH
20265: LD_EXP 118
20269: PUSH
20270: LD_INT 4
20272: ARRAY
20273: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20274: LD_ADDR_VAR 0 1
20278: PUSH
20279: DOUBLE
20280: LD_INT 1
20282: DEC
20283: ST_TO_ADDR
20284: LD_EXP 18
20288: PUSH
20289: FOR_TO
20290: IFFALSE 20551
// begin for j in powellSquadAttack [ i ] do
20292: LD_ADDR_VAR 0 2
20296: PUSH
20297: LD_EXP 18
20301: PUSH
20302: LD_VAR 0 1
20306: ARRAY
20307: PUSH
20308: FOR_IN
20309: IFFALSE 20547
// begin forces := forces diff j ;
20311: LD_ADDR_VAR 0 6
20315: PUSH
20316: LD_VAR 0 6
20320: PUSH
20321: LD_VAR 0 2
20325: DIFF
20326: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_INT 1
20334: PPUSH
20335: CALL_OW 109
// wait ( 0 0$2 ) ;
20339: LD_INT 70
20341: PPUSH
20342: CALL_OW 67
// if IsInUnit ( j ) then
20346: LD_VAR 0 2
20350: PPUSH
20351: CALL_OW 310
20355: IFFALSE 20366
// ComExitBuilding ( j ) ;
20357: LD_VAR 0 2
20361: PPUSH
20362: CALL_OW 122
// if GetClass ( j ) <> 1 then
20366: LD_VAR 0 2
20370: PPUSH
20371: CALL_OW 257
20375: PUSH
20376: LD_INT 1
20378: NONEQUAL
20379: IFFALSE 20459
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20381: LD_VAR 0 10
20385: PUSH
20386: LD_INT 1
20388: ARRAY
20389: PPUSH
20390: CALL_OW 313
20394: PUSH
20395: LD_INT 5
20397: GREATEREQUAL
20398: IFFALSE 20420
// AddComEnterUnit ( j , arm [ 2 ] ) else
20400: LD_VAR 0 2
20404: PPUSH
20405: LD_VAR 0 10
20409: PUSH
20410: LD_INT 2
20412: ARRAY
20413: PPUSH
20414: CALL_OW 180
20418: GO 20438
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20420: LD_VAR 0 2
20424: PPUSH
20425: LD_VAR 0 10
20429: PUSH
20430: LD_INT 1
20432: ARRAY
20433: PPUSH
20434: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20438: LD_VAR 0 2
20442: PPUSH
20443: LD_INT 1
20445: PPUSH
20446: CALL_OW 183
// AddComExitBuilding ( j ) ;
20450: LD_VAR 0 2
20454: PPUSH
20455: CALL_OW 182
// end ; if i = 2 then
20459: LD_VAR 0 1
20463: PUSH
20464: LD_INT 2
20466: EQUAL
20467: IFFALSE 20484
// AddComMoveXY ( j , 61 , 93 ) ;
20469: LD_VAR 0 2
20473: PPUSH
20474: LD_INT 61
20476: PPUSH
20477: LD_INT 93
20479: PPUSH
20480: CALL_OW 171
// if i = 1 then
20484: LD_VAR 0 1
20488: PUSH
20489: LD_INT 1
20491: EQUAL
20492: IFFALSE 20545
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20494: LD_VAR 0 2
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PPUSH
20508: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20512: LD_ADDR_VAR 0 3
20516: PUSH
20517: LD_VAR 0 3
20521: PPUSH
20522: LD_INT 1
20524: PPUSH
20525: CALL_OW 3
20529: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20530: LD_VAR 0 2
20534: PPUSH
20535: LD_INT 69
20537: PPUSH
20538: LD_INT 94
20540: PPUSH
20541: CALL_OW 171
// end ; end ;
20545: GO 20308
20547: POP
20548: POP
// end ;
20549: GO 20289
20551: POP
20552: POP
// wait ( 0 0$55 ) ;
20553: LD_INT 1925
20555: PPUSH
20556: CALL_OW 67
// MC_Kill ( 4 ) ;
20560: LD_INT 4
20562: PPUSH
20563: CALL 33924 0 1
// tmp := UnitsInside ( fac ) ;
20567: LD_ADDR_VAR 0 3
20571: PUSH
20572: LD_VAR 0 9
20576: PPUSH
20577: CALL_OW 313
20581: ST_TO_ADDR
// if tmp then
20582: LD_VAR 0 3
20586: IFFALSE 20707
// for i in tmp do
20588: LD_ADDR_VAR 0 1
20592: PUSH
20593: LD_VAR 0 3
20597: PUSH
20598: FOR_IN
20599: IFFALSE 20705
// begin ComExitBuilding ( i ) ;
20601: LD_VAR 0 1
20605: PPUSH
20606: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20610: LD_VAR 0 10
20614: PUSH
20615: LD_INT 2
20617: ARRAY
20618: PPUSH
20619: CALL_OW 313
20623: PUSH
20624: LD_INT 6
20626: LESS
20627: IFFALSE 20649
// AddComEnterUnit ( i , arm [ 2 ] ) else
20629: LD_VAR 0 1
20633: PPUSH
20634: LD_VAR 0 10
20638: PUSH
20639: LD_INT 2
20641: ARRAY
20642: PPUSH
20643: CALL_OW 180
20647: GO 20703
// if UnitsInside ( arm [ 1 ] ) < 6 then
20649: LD_VAR 0 10
20653: PUSH
20654: LD_INT 1
20656: ARRAY
20657: PPUSH
20658: CALL_OW 313
20662: PUSH
20663: LD_INT 6
20665: LESS
20666: IFFALSE 20688
// AddComEnterUnit ( i , arm [ 1 ] ) else
20668: LD_VAR 0 1
20672: PPUSH
20673: LD_VAR 0 10
20677: PUSH
20678: LD_INT 1
20680: ARRAY
20681: PPUSH
20682: CALL_OW 180
20686: GO 20703
// AddComMoveXY ( i , 37 , 68 ) ;
20688: LD_VAR 0 1
20692: PPUSH
20693: LD_INT 37
20695: PPUSH
20696: LD_INT 68
20698: PPUSH
20699: CALL_OW 171
// end ;
20703: GO 20598
20705: POP
20706: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20707: LD_ADDR_VAR 0 11
20711: PUSH
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_INT 26
20719: PUSH
20720: LD_INT 1
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: PPUSH
20727: CALL_OW 72
20731: PUSH
20732: LD_EXP 56
20736: DIFF
20737: ST_TO_ADDR
// if not speaker then
20738: LD_VAR 0 11
20742: NOT
20743: IFFALSE 20770
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20745: LD_ADDR_VAR 0 11
20749: PUSH
20750: LD_VAR 0 6
20754: PPUSH
20755: LD_INT 26
20757: PUSH
20758: LD_INT 1
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: PPUSH
20765: CALL_OW 72
20769: ST_TO_ADDR
// if speaker then
20770: LD_VAR 0 11
20774: IFFALSE 20790
// speaker := speaker [ 1 ] ;
20776: LD_ADDR_VAR 0 11
20780: PUSH
20781: LD_VAR 0 11
20785: PUSH
20786: LD_INT 1
20788: ARRAY
20789: ST_TO_ADDR
// Video ( true ) ;
20790: LD_INT 1
20792: PPUSH
20793: CALL 105226 0 1
// CenterNowOnUnits ( Powell ) ;
20797: LD_EXP 55
20801: PPUSH
20802: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20806: LD_ADDR_VAR 0 3
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: LD_INT 3
20818: PUSH
20819: LD_INT 25
20821: PUSH
20822: LD_INT 1
20824: PUSH
20825: EMPTY
20826: LIST
20827: LIST
20828: PUSH
20829: EMPTY
20830: LIST
20831: LIST
20832: PPUSH
20833: CALL_OW 72
20837: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20838: LD_ADDR_VAR 0 12
20842: PUSH
20843: LD_INT 22
20845: PUSH
20846: LD_INT 4
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: PUSH
20853: LD_INT 30
20855: PUSH
20856: LD_INT 32
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PUSH
20863: LD_INT 58
20865: PUSH
20866: EMPTY
20867: LIST
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: LIST
20873: PPUSH
20874: CALL_OW 69
20878: ST_TO_ADDR
// for i = 1 to 6 do
20879: LD_ADDR_VAR 0 1
20883: PUSH
20884: DOUBLE
20885: LD_INT 1
20887: DEC
20888: ST_TO_ADDR
20889: LD_INT 6
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if IsInUnit ( tmp [ i ] ) then
20895: LD_VAR 0 3
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PPUSH
20906: CALL_OW 310
20910: IFFALSE 20927
// ComExitBuilding ( tmp [ i ] ) ;
20912: LD_VAR 0 3
20916: PUSH
20917: LD_VAR 0 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20927: LD_VAR 0 3
20931: PUSH
20932: LD_VAR 0 1
20936: ARRAY
20937: PPUSH
20938: LD_VAR 0 10
20942: PUSH
20943: LD_INT 1
20945: ARRAY
20946: PPUSH
20947: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20951: LD_VAR 0 3
20955: PUSH
20956: LD_VAR 0 1
20960: ARRAY
20961: PPUSH
20962: LD_INT 1
20964: PPUSH
20965: CALL_OW 183
// if emp_towers then
20969: LD_VAR 0 12
20973: IFFALSE 21032
// begin AddComExitBuilding ( tmp [ i ] ) ;
20975: LD_VAR 0 3
20979: PUSH
20980: LD_VAR 0 1
20984: ARRAY
20985: PPUSH
20986: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20990: LD_VAR 0 3
20994: PUSH
20995: LD_VAR 0 1
20999: ARRAY
21000: PPUSH
21001: LD_VAR 0 12
21005: PUSH
21006: LD_INT 1
21008: ARRAY
21009: PPUSH
21010: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21014: LD_ADDR_VAR 0 12
21018: PUSH
21019: LD_VAR 0 12
21023: PPUSH
21024: LD_INT 1
21026: PPUSH
21027: CALL_OW 3
21031: ST_TO_ADDR
// end ; end ;
21032: GO 20892
21034: POP
21035: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21036: LD_ADDR_VAR 0 3
21040: PUSH
21041: LD_EXP 18
21045: PUSH
21046: LD_INT 1
21048: ARRAY
21049: PUSH
21050: LD_EXP 18
21054: PUSH
21055: LD_INT 2
21057: ARRAY
21058: ADD
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21075: LD_ADDR_VAR 0 1
21079: PUSH
21080: LD_EXP 18
21084: PUSH
21085: LD_INT 2
21087: ARRAY
21088: PUSH
21089: FOR_IN
21090: IFFALSE 21108
// ComTurnUnit ( i , Powell ) ;
21092: LD_VAR 0 1
21096: PPUSH
21097: LD_EXP 55
21101: PPUSH
21102: CALL_OW 119
21106: GO 21089
21108: POP
21109: POP
// Say ( Powell , D5-Pow-1 ) ;
21110: LD_EXP 55
21114: PPUSH
21115: LD_STRING D5-Pow-1
21117: PPUSH
21118: CALL_OW 88
// if tmp then
21122: LD_VAR 0 3
21126: IFFALSE 21144
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21128: LD_VAR 0 3
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: LD_STRING D5-Sol2-1
21139: PPUSH
21140: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21144: LD_EXP 55
21148: PPUSH
21149: LD_STRING D5-Pow-2
21151: PPUSH
21152: CALL_OW 88
// if tmp > 1 then
21156: LD_VAR 0 3
21160: PUSH
21161: LD_INT 1
21163: GREATER
21164: IFFALSE 21182
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21166: LD_VAR 0 3
21170: PUSH
21171: LD_INT 2
21173: ARRAY
21174: PPUSH
21175: LD_STRING D5-Sol2-2
21177: PPUSH
21178: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21182: LD_EXP 55
21186: PPUSH
21187: LD_STRING D5-Pow-3
21189: PPUSH
21190: CALL_OW 88
// wait ( 0 0$1 ) ;
21194: LD_INT 35
21196: PPUSH
21197: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21201: LD_ADDR_VAR 0 3
21205: PUSH
21206: LD_EXP 18
21210: PUSH
21211: LD_INT 1
21213: ARRAY
21214: PUSH
21215: LD_EXP 18
21219: PUSH
21220: LD_INT 2
21222: ARRAY
21223: UNION
21224: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21225: LD_VAR 0 3
21229: PPUSH
21230: LD_INT 80
21232: PPUSH
21233: LD_INT 67
21235: PPUSH
21236: CALL_OW 114
// wait ( 0 0$2 ) ;
21240: LD_INT 70
21242: PPUSH
21243: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21247: LD_INT 79
21249: PPUSH
21250: LD_INT 72
21252: PPUSH
21253: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21257: LD_INT 35
21259: PPUSH
21260: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21264: LD_VAR 0 3
21268: PPUSH
21269: LD_INT 3
21271: PUSH
21272: LD_INT 24
21274: PUSH
21275: LD_INT 1000
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PPUSH
21286: CALL_OW 72
21290: IFFALSE 21257
// Say ( Powell , D5a-Pow-1 ) ;
21292: LD_EXP 55
21296: PPUSH
21297: LD_STRING D5a-Pow-1
21299: PPUSH
21300: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21304: LD_EXP 55
21308: PPUSH
21309: LD_STRING D5a-Pow-1a
21311: PPUSH
21312: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21316: LD_INT 10
21318: PPUSH
21319: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21323: LD_EXP 55
21327: PPUSH
21328: LD_STRING D5a-Pow-1b
21330: PPUSH
21331: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21335: LD_EXP 55
21339: PPUSH
21340: LD_STRING D5a-Pow-1c
21342: PPUSH
21343: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21347: LD_EXP 55
21351: PPUSH
21352: LD_STRING D5a-Pow-1d
21354: PPUSH
21355: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21359: LD_INT 35
21361: PPUSH
21362: CALL_OW 67
// if not HasTask ( tmp ) then
21366: LD_VAR 0 3
21370: PPUSH
21371: CALL_OW 314
21375: NOT
21376: IFFALSE 21393
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21378: LD_VAR 0 3
21382: PPUSH
21383: LD_INT 80
21385: PPUSH
21386: LD_INT 67
21388: PPUSH
21389: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21393: LD_VAR 0 3
21397: PPUSH
21398: LD_INT 24
21400: PUSH
21401: LD_INT 1
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: PPUSH
21408: CALL_OW 72
21412: NOT
21413: IFFALSE 21359
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_INT 22
21422: PUSH
21423: LD_INT 4
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PUSH
21430: LD_INT 92
21432: PUSH
21433: LD_INT 60
21435: PUSH
21436: LD_INT 93
21438: PUSH
21439: LD_INT 10
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 3
21450: PUSH
21451: LD_INT 54
21453: PUSH
21454: EMPTY
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: LIST
21465: PPUSH
21466: CALL_OW 69
21470: PUSH
21471: LD_EXP 55
21475: DIFF
21476: ST_TO_ADDR
// if tmp then
21477: LD_VAR 0 3
21481: IFFALSE 21515
// for i in tmp do
21483: LD_ADDR_VAR 0 1
21487: PUSH
21488: LD_VAR 0 3
21492: PUSH
21493: FOR_IN
21494: IFFALSE 21513
// ComMoveXY ( i , 36 , 67 ) ;
21496: LD_VAR 0 1
21500: PPUSH
21501: LD_INT 36
21503: PPUSH
21504: LD_INT 67
21506: PPUSH
21507: CALL_OW 111
21511: GO 21493
21513: POP
21514: POP
// wait ( 0 0$3 ) ;
21515: LD_INT 105
21517: PPUSH
21518: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21522: LD_VAR 0 11
21526: PPUSH
21527: LD_STRING D6-Sol3-1
21529: PPUSH
21530: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21534: LD_EXP 55
21538: PPUSH
21539: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21543: LD_EXP 55
21547: PPUSH
21548: LD_STRING D6-Pow-1
21550: PPUSH
21551: CALL_OW 88
// tmp := [ ] ;
21555: LD_ADDR_VAR 0 3
21559: PUSH
21560: EMPTY
21561: ST_TO_ADDR
// for i = 1 to 2 do
21562: LD_ADDR_VAR 0 1
21566: PUSH
21567: DOUBLE
21568: LD_INT 1
21570: DEC
21571: ST_TO_ADDR
21572: LD_INT 2
21574: PUSH
21575: FOR_TO
21576: IFFALSE 21683
// begin uc_side := 8 ;
21578: LD_ADDR_OWVAR 20
21582: PUSH
21583: LD_INT 8
21585: ST_TO_ADDR
// uc_nation := 2 ;
21586: LD_ADDR_OWVAR 21
21590: PUSH
21591: LD_INT 2
21593: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21594: LD_INT 14
21596: PPUSH
21597: LD_INT 3
21599: PPUSH
21600: LD_INT 2
21602: PPUSH
21603: LD_INT 29
21605: PPUSH
21606: LD_INT 100
21608: PPUSH
21609: CALL 69533 0 5
// veh := CreateVehicle ;
21613: LD_ADDR_VAR 0 13
21617: PUSH
21618: CALL_OW 45
21622: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21623: LD_VAR 0 13
21627: PPUSH
21628: LD_INT 4
21630: PPUSH
21631: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21635: LD_VAR 0 13
21639: PPUSH
21640: LD_INT 99
21642: PPUSH
21643: LD_INT 83
21645: PPUSH
21646: LD_INT 5
21648: PPUSH
21649: LD_INT 0
21651: PPUSH
21652: CALL_OW 50
// Connect ( veh ) ;
21656: LD_VAR 0 13
21660: PPUSH
21661: CALL 72588 0 1
// tmp := tmp ^ veh ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_VAR 0 13
21679: ADD
21680: ST_TO_ADDR
// end ;
21681: GO 21575
21683: POP
21684: POP
// wait ( 0 0$1 ) ;
21685: LD_INT 35
21687: PPUSH
21688: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21692: LD_INT 99
21694: PPUSH
21695: LD_INT 83
21697: PPUSH
21698: LD_INT 1
21700: PPUSH
21701: LD_INT 10
21703: PPUSH
21704: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21708: LD_INT 99
21710: PPUSH
21711: LD_INT 83
21713: PPUSH
21714: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21718: LD_VAR 0 11
21722: PPUSH
21723: LD_STRING D6-Sol3-2
21725: PPUSH
21726: CALL_OW 88
// async ;
21730: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21731: LD_EXP 55
21735: PPUSH
21736: LD_STRING D6-Pow-2
21738: PPUSH
21739: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21743: LD_VAR 0 3
21747: PUSH
21748: LD_INT 1
21750: ARRAY
21751: PPUSH
21752: LD_VAR 0 9
21756: PPUSH
21757: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21761: LD_VAR 0 3
21765: PUSH
21766: LD_INT 2
21768: ARRAY
21769: PPUSH
21770: LD_INT 22
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: LD_INT 21
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PPUSH
21794: CALL_OW 69
21798: PPUSH
21799: LD_VAR 0 3
21803: PUSH
21804: LD_INT 2
21806: ARRAY
21807: PPUSH
21808: CALL_OW 74
21812: PPUSH
21813: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21817: LD_EXP 55
21821: PPUSH
21822: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21826: LD_INT 99
21828: PPUSH
21829: LD_INT 83
21831: PPUSH
21832: LD_INT 1
21834: PPUSH
21835: CALL_OW 331
// repeat wait ( 4 ) ;
21839: LD_INT 4
21841: PPUSH
21842: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21846: LD_VAR 0 3
21850: PUSH
21851: LD_INT 1
21853: ARRAY
21854: PPUSH
21855: CALL_OW 256
21859: PUSH
21860: LD_INT 1000
21862: LESS
21863: IFFALSE 21881
// SetLives ( tmp [ 1 ] , 1000 ) ;
21865: LD_VAR 0 3
21869: PUSH
21870: LD_INT 1
21872: ARRAY
21873: PPUSH
21874: LD_INT 1000
21876: PPUSH
21877: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21881: LD_INT 22
21883: PUSH
21884: LD_INT 4
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: LD_INT 30
21893: PUSH
21894: LD_INT 3
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: PUSH
21910: LD_INT 0
21912: EQUAL
21913: IFFALSE 21839
// sync ;
21915: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21916: LD_EXP 55
21920: PPUSH
21921: LD_STRING D6a-Pow-1
21923: PPUSH
21924: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21928: LD_VAR 0 11
21932: PPUSH
21933: LD_STRING D6a-Sol3-1
21935: PPUSH
21936: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21940: LD_EXP 55
21944: PPUSH
21945: LD_STRING D6a-Pow-2
21947: PPUSH
21948: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6a-Sol3-2
21959: PPUSH
21960: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21964: LD_EXP 55
21968: PPUSH
21969: LD_STRING D6a-Pow-3
21971: PPUSH
21972: CALL_OW 88
// powellCenterCameraMode := true ;
21976: LD_ADDR_EXP 20
21980: PUSH
21981: LD_INT 1
21983: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21984: LD_ADDR_VAR 0 1
21988: PUSH
21989: LD_INT 22
21991: PUSH
21992: LD_INT 8
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: LD_INT 25
22001: PUSH
22002: LD_INT 2
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: PPUSH
22013: CALL_OW 69
22017: PUSH
22018: FOR_IN
22019: IFFALSE 22074
// begin SetTag ( i , 1 ) ;
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 1
22028: PPUSH
22029: CALL_OW 109
// ComExitBuilding ( i ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22042: LD_VAR 0 1
22046: PPUSH
22047: LD_INT 35
22049: PPUSH
22050: LD_INT 6
22052: PPUSH
22053: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22057: LD_VAR 0 1
22061: PPUSH
22062: LD_INT 53
22064: PPUSH
22065: LD_INT 4
22067: PPUSH
22068: CALL_OW 171
// end ;
22072: GO 22018
22074: POP
22075: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22076: LD_ADDR_VAR 0 3
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 4
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 21
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 3
22103: PUSH
22104: LD_INT 34
22106: PUSH
22107: LD_INT 12
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: LIST
22122: PPUSH
22123: CALL_OW 69
22127: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22128: LD_EXP 55
22132: PPUSH
22133: LD_VAR 0 3
22137: PPUSH
22138: LD_EXP 55
22142: PPUSH
22143: CALL_OW 74
22147: PPUSH
22148: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22152: LD_EXP 55
22156: PPUSH
22157: LD_INT 100
22159: PPUSH
22160: LD_INT 88
22162: PPUSH
22163: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22167: LD_EXP 55
22171: PPUSH
22172: LD_INT 100
22174: PPUSH
22175: LD_INT 75
22177: PPUSH
22178: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22182: LD_EXP 55
22186: PPUSH
22187: LD_INT 88
22189: PPUSH
22190: LD_INT 53
22192: PPUSH
22193: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22197: LD_INT 8
22199: PPUSH
22200: LD_EXP 55
22204: PPUSH
22205: CALL_OW 471
// repeat wait ( 3 ) ;
22209: LD_INT 3
22211: PPUSH
22212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22216: LD_INT 22
22218: PUSH
22219: LD_INT 4
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 92
22228: PUSH
22229: LD_INT 100
22231: PUSH
22232: LD_INT 75
22234: PUSH
22235: LD_INT 6
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PPUSH
22248: CALL_OW 69
22252: IFFALSE 22209
// async ;
22254: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22255: LD_EXP 55
22259: PPUSH
22260: LD_STRING D6b-Pow-1
22262: PPUSH
22263: CALL_OW 88
// repeat wait ( 3 ) ;
22267: LD_INT 3
22269: PPUSH
22270: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22274: LD_EXP 55
22278: PPUSH
22279: CALL_OW 310
22283: PPUSH
22284: CALL_OW 256
22288: PUSH
22289: LD_INT 1000
22291: LESS
22292: IFFALSE 22311
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22294: LD_EXP 55
22298: PPUSH
22299: CALL_OW 310
22303: PPUSH
22304: LD_INT 1000
22306: PPUSH
22307: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22311: LD_EXP 55
22315: PPUSH
22316: CALL_OW 256
22320: PUSH
22321: LD_INT 1000
22323: LESS
22324: IFFALSE 22338
// SetLives ( Powell , 1000 ) ;
22326: LD_EXP 55
22330: PPUSH
22331: LD_INT 1000
22333: PPUSH
22334: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22338: LD_EXP 55
22342: PPUSH
22343: LD_EXP 60
22347: PPUSH
22348: CALL_OW 296
22352: PUSH
22353: LD_INT 5
22355: LESS
22356: PUSH
22357: LD_EXP 55
22361: PPUSH
22362: CALL_OW 310
22366: PPUSH
22367: LD_EXP 60
22371: PPUSH
22372: CALL_OW 296
22376: PUSH
22377: LD_INT 5
22379: LESS
22380: OR
22381: IFFALSE 22400
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22383: LD_EXP 55
22387: PPUSH
22388: CALL_OW 310
22392: PPUSH
22393: LD_INT 100
22395: PPUSH
22396: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22400: LD_EXP 55
22404: PPUSH
22405: CALL_OW 310
22409: NOT
22410: IFFALSE 22267
// game_speed := 4 ;
22412: LD_ADDR_OWVAR 65
22416: PUSH
22417: LD_INT 4
22419: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22420: LD_EXP 55
22424: PPUSH
22425: LD_STRING D6b-Pow-1a
22427: PPUSH
22428: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22432: LD_EXP 55
22436: PPUSH
22437: LD_EXP 60
22441: PPUSH
22442: CALL_OW 180
// sync ;
22446: SYNC
// repeat wait ( 0 0$1 ) ;
22447: LD_INT 35
22449: PPUSH
22450: CALL_OW 67
// until IsInUnit ( Powell ) ;
22454: LD_EXP 55
22458: PPUSH
22459: CALL_OW 310
22463: IFFALSE 22447
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22465: LD_INT 8
22467: PPUSH
22468: LD_EXP 55
22472: PPUSH
22473: CALL_OW 310
22477: PPUSH
22478: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22482: LD_EXP 55
22486: PPUSH
22487: LD_INT 91
22489: PPUSH
22490: LD_INT 44
22492: PPUSH
22493: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22497: LD_EXP 55
22501: PPUSH
22502: LD_INT 96
22504: PPUSH
22505: LD_INT 44
22507: PPUSH
22508: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22512: LD_EXP 55
22516: PPUSH
22517: LD_INT 96
22519: PPUSH
22520: LD_INT 41
22522: PPUSH
22523: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22527: LD_EXP 55
22531: PPUSH
22532: LD_INT 92
22534: PPUSH
22535: LD_INT 39
22537: PPUSH
22538: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22542: LD_EXP 55
22546: PPUSH
22547: LD_INT 88
22549: PPUSH
22550: LD_INT 41
22552: PPUSH
22553: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22557: LD_EXP 55
22561: PPUSH
22562: LD_INT 91
22564: PPUSH
22565: LD_INT 44
22567: PPUSH
22568: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22572: LD_EXP 55
22576: PPUSH
22577: LD_INT 96
22579: PPUSH
22580: LD_INT 44
22582: PPUSH
22583: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22587: LD_EXP 55
22591: PPUSH
22592: LD_INT 96
22594: PPUSH
22595: LD_INT 41
22597: PPUSH
22598: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22602: LD_EXP 55
22606: PPUSH
22607: LD_INT 92
22609: PPUSH
22610: LD_INT 39
22612: PPUSH
22613: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22617: LD_EXP 55
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: LD_INT 41
22627: PPUSH
22628: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22632: LD_EXP 55
22636: PPUSH
22637: LD_INT 91
22639: PPUSH
22640: LD_INT 44
22642: PPUSH
22643: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22647: LD_EXP 55
22651: PPUSH
22652: LD_INT 93
22654: PPUSH
22655: LD_INT 39
22657: PPUSH
22658: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22662: LD_EXP 55
22666: PPUSH
22667: LD_INT 93
22669: PPUSH
22670: LD_INT 36
22672: PPUSH
22673: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22677: LD_INT 122
22679: PPUSH
22680: CALL_OW 67
// game_speed := 4 ;
22684: LD_ADDR_OWVAR 65
22688: PUSH
22689: LD_INT 4
22691: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22692: LD_EXP 55
22696: PPUSH
22697: LD_STRING D6b-Pow-1b
22699: PPUSH
22700: CALL_OW 88
// tmp := [ ] ;
22704: LD_ADDR_VAR 0 3
22708: PUSH
22709: EMPTY
22710: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22711: LD_ADDR_VAR 0 5
22715: PUSH
22716: LD_INT 78
22718: PUSH
22719: LD_INT 47
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: PUSH
22726: LD_INT 106
22728: PUSH
22729: LD_INT 53
22731: PUSH
22732: EMPTY
22733: LIST
22734: LIST
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22740: LD_ADDR_VAR 0 1
22744: PUSH
22745: LD_INT 22
22747: PUSH
22748: LD_INT 8
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: PUSH
22755: LD_INT 21
22757: PUSH
22758: LD_INT 3
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 92
22767: PUSH
22768: LD_INT 90
22770: PUSH
22771: LD_INT 52
22773: PUSH
22774: LD_INT 12
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: LIST
22787: PPUSH
22788: CALL_OW 69
22792: PUSH
22793: FOR_IN
22794: IFFALSE 22819
// tmp := tmp ^ UnitsInside ( i ) ;
22796: LD_ADDR_VAR 0 3
22800: PUSH
22801: LD_VAR 0 3
22805: PUSH
22806: LD_VAR 0 1
22810: PPUSH
22811: CALL_OW 313
22815: ADD
22816: ST_TO_ADDR
22817: GO 22793
22819: POP
22820: POP
// for i in tmp do
22821: LD_ADDR_VAR 0 1
22825: PUSH
22826: LD_VAR 0 3
22830: PUSH
22831: FOR_IN
22832: IFFALSE 22994
// begin dist := 9999 ;
22834: LD_ADDR_VAR 0 8
22838: PUSH
22839: LD_INT 9999
22841: ST_TO_ADDR
// _xy := [ ] ;
22842: LD_ADDR_VAR 0 7
22846: PUSH
22847: EMPTY
22848: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22849: LD_VAR 0 1
22853: PPUSH
22854: LD_INT 1
22856: PPUSH
22857: CALL_OW 109
// ComExitBuilding ( i ) ;
22861: LD_VAR 0 1
22865: PPUSH
22866: CALL_OW 122
// for j in xy do
22870: LD_ADDR_VAR 0 2
22874: PUSH
22875: LD_VAR 0 5
22879: PUSH
22880: FOR_IN
22881: IFFALSE 22963
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_VAR 0 2
22892: PUSH
22893: LD_INT 1
22895: ARRAY
22896: PPUSH
22897: LD_VAR 0 2
22901: PUSH
22902: LD_INT 2
22904: ARRAY
22905: PPUSH
22906: CALL_OW 297
22910: PUSH
22911: LD_VAR 0 8
22915: LESS
22916: IFFALSE 22961
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22918: LD_ADDR_VAR 0 8
22922: PUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: LD_VAR 0 2
22932: PUSH
22933: LD_INT 1
22935: ARRAY
22936: PPUSH
22937: LD_VAR 0 2
22941: PUSH
22942: LD_INT 2
22944: ARRAY
22945: PPUSH
22946: CALL_OW 297
22950: ST_TO_ADDR
// _xy := j ;
22951: LD_ADDR_VAR 0 7
22955: PUSH
22956: LD_VAR 0 2
22960: ST_TO_ADDR
// end ;
22961: GO 22880
22963: POP
22964: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 7
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 7
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 171
// end ;
22992: GO 22831
22994: POP
22995: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22996: LD_ADDR_VAR 0 4
23000: PUSH
23001: LD_VAR 0 3
23005: PPUSH
23006: LD_INT 26
23008: PUSH
23009: LD_INT 1
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: LD_INT 25
23018: PUSH
23019: LD_INT 1
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL_OW 72
23034: ST_TO_ADDR
// if tmp2 < 2 then
23035: LD_VAR 0 4
23039: PUSH
23040: LD_INT 2
23042: LESS
23043: IFFALSE 23112
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23045: LD_ADDR_VAR 0 4
23049: PUSH
23050: LD_INT 22
23052: PUSH
23053: LD_INT 8
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: LD_INT 26
23062: PUSH
23063: LD_INT 1
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 3
23072: PUSH
23073: LD_INT 25
23075: PUSH
23076: LD_INT 15
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: PPUSH
23092: CALL_OW 69
23096: PUSH
23097: LD_EXP 57
23101: PUSH
23102: LD_EXP 58
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: DIFF
23111: ST_TO_ADDR
// if tmp2 then
23112: LD_VAR 0 4
23116: IFFALSE 23134
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23118: LD_VAR 0 4
23122: PUSH
23123: LD_INT 1
23125: ARRAY
23126: PPUSH
23127: LD_STRING D6b-ArSol1-1
23129: PPUSH
23130: CALL_OW 88
// async ;
23134: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23135: LD_EXP 55
23139: PPUSH
23140: LD_STRING D6b-Pow-2
23142: PPUSH
23143: CALL_OW 88
// wait ( 0 0$1 ) ;
23147: LD_INT 35
23149: PPUSH
23150: CALL_OW 67
// if tmp2 > 1 then
23154: LD_VAR 0 4
23158: PUSH
23159: LD_INT 1
23161: GREATER
23162: IFFALSE 23180
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23164: LD_VAR 0 4
23168: PUSH
23169: LD_INT 2
23171: ARRAY
23172: PPUSH
23173: LD_STRING D6b-ArSol2-1
23175: PPUSH
23176: CALL_OW 88
// sync ;
23180: SYNC
// repeat wait ( 5 ) ;
23181: LD_INT 5
23183: PPUSH
23184: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23188: LD_INT 93
23190: PPUSH
23191: LD_INT 36
23193: PPUSH
23194: CALL_OW 428
23198: PPUSH
23199: CALL_OW 255
23203: PUSH
23204: LD_INT 4
23206: EQUAL
23207: IFFALSE 23181
// DialogueOn ;
23209: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23213: LD_INT 10
23215: PPUSH
23216: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23220: LD_EXP 55
23224: PPUSH
23225: LD_STRING D6b-Pow-2a
23227: PPUSH
23228: CALL_OW 88
// DialogueOff ;
23232: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23236: LD_EXP 55
23240: PPUSH
23241: CALL_OW 310
23245: PPUSH
23246: LD_INT 332
23248: PPUSH
23249: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23253: LD_INT 93
23255: PPUSH
23256: LD_INT 35
23258: PPUSH
23259: LD_INT 1
23261: PPUSH
23262: LD_INT 6
23264: NEG
23265: PPUSH
23266: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23270: LD_INT 35
23272: PPUSH
23273: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23277: LD_INT 332
23279: PPUSH
23280: CALL_OW 256
23284: PUSH
23285: LD_INT 1000
23287: LESS
23288: PUSH
23289: LD_INT 332
23291: PPUSH
23292: CALL_OW 300
23296: AND
23297: IFFALSE 23309
// SetLives ( kozlov_fac , 0 ) ;
23299: LD_INT 332
23301: PPUSH
23302: LD_INT 0
23304: PPUSH
23305: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23309: LD_INT 332
23311: PPUSH
23312: CALL_OW 301
23316: PUSH
23317: LD_EXP 55
23321: PPUSH
23322: CALL_OW 301
23326: OR
23327: IFFALSE 23270
// game_speed := 4 ;
23329: LD_ADDR_OWVAR 65
23333: PUSH
23334: LD_INT 4
23336: ST_TO_ADDR
// powellCenterCameraMode := false ;
23337: LD_ADDR_EXP 20
23341: PUSH
23342: LD_INT 0
23344: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23345: LD_ADDR_VAR 0 1
23349: PUSH
23350: LD_VAR 0 3
23354: PUSH
23355: LD_INT 22
23357: PUSH
23358: LD_INT 8
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 25
23367: PUSH
23368: LD_INT 2
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PPUSH
23379: CALL_OW 69
23383: UNION
23384: PUSH
23385: FOR_IN
23386: IFFALSE 23402
// SetTag ( i , 0 ) ;
23388: LD_VAR 0 1
23392: PPUSH
23393: LD_INT 0
23395: PPUSH
23396: CALL_OW 109
23400: GO 23385
23402: POP
23403: POP
// wait ( 0 0$3 ) ;
23404: LD_INT 105
23406: PPUSH
23407: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23411: LD_INT 93
23413: PPUSH
23414: LD_INT 35
23416: PPUSH
23417: LD_INT 1
23419: PPUSH
23420: CALL_OW 331
// DialogueOn ;
23424: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23428: LD_VAR 0 11
23432: PPUSH
23433: LD_STRING D6c-Sol3-1
23435: PPUSH
23436: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23440: LD_INT 10
23442: PPUSH
23443: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23447: LD_EXP 36
23451: PPUSH
23452: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23456: LD_EXP 36
23460: PPUSH
23461: LD_STRING D6c-JMM-1
23463: PPUSH
23464: CALL_OW 88
// if Cyrus then
23468: LD_EXP 42
23472: IFFALSE 23486
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23474: LD_EXP 42
23478: PPUSH
23479: LD_STRING D6c-Cyrus-1
23481: PPUSH
23482: CALL_OW 88
// if Bobby then
23486: LD_EXP 41
23490: IFFALSE 23504
// Say ( Bobby , D6c-Bobby-1 ) ;
23492: LD_EXP 41
23496: PPUSH
23497: LD_STRING D6c-Bobby-1
23499: PPUSH
23500: CALL_OW 88
// if Cornel then
23504: LD_EXP 47
23508: IFFALSE 23522
// Say ( Cornel , D6c-Corn-1 ) ;
23510: LD_EXP 47
23514: PPUSH
23515: LD_STRING D6c-Corn-1
23517: PPUSH
23518: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23522: LD_ADDR_VAR 0 4
23526: PUSH
23527: LD_INT 2
23529: PUSH
23530: LD_INT 22
23532: PUSH
23533: LD_INT 1
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: PUSH
23540: LD_INT 22
23542: PUSH
23543: LD_INT 4
23545: PUSH
23546: EMPTY
23547: LIST
23548: LIST
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: LIST
23554: PUSH
23555: LD_INT 26
23557: PUSH
23558: LD_INT 1
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: PUSH
23565: LD_INT 3
23567: PUSH
23568: LD_INT 25
23570: PUSH
23571: LD_INT 16
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 12
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: LIST
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: PPUSH
23598: CALL_OW 69
23602: PUSH
23603: LD_VAR 0 11
23607: PUSH
23608: LD_EXP 36
23612: UNION
23613: PUSH
23614: LD_EXP 56
23618: UNION
23619: PUSH
23620: EMPTY
23621: LIST
23622: DIFF
23623: ST_TO_ADDR
// if tmp2 then
23624: LD_VAR 0 4
23628: IFFALSE 23646
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23630: LD_VAR 0 4
23634: PUSH
23635: LD_INT 1
23637: ARRAY
23638: PPUSH
23639: LD_STRING D6c-Sol1-1
23641: PPUSH
23642: CALL_OW 88
// if Lisa then
23646: LD_EXP 39
23650: IFFALSE 23664
// Say ( Lisa , D6c-Lisa-1 ) ;
23652: LD_EXP 39
23656: PPUSH
23657: LD_STRING D6c-Lisa-1
23659: PPUSH
23660: CALL_OW 88
// if Gary then
23664: LD_EXP 48
23668: IFFALSE 23682
// Say ( Gary , D6c-Gary-1 ) ;
23670: LD_EXP 48
23674: PPUSH
23675: LD_STRING D6c-Gary-1
23677: PPUSH
23678: CALL_OW 88
// if Donaldson then
23682: LD_EXP 40
23686: IFFALSE 23700
// Say ( Donaldson , D6c-Don-1 ) ;
23688: LD_EXP 40
23692: PPUSH
23693: LD_STRING D6c-Don-1
23695: PPUSH
23696: CALL_OW 88
// if tmp2 > 1 then
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 1
23707: GREATER
23708: IFFALSE 23726
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23710: LD_VAR 0 4
23714: PUSH
23715: LD_INT 2
23717: ARRAY
23718: PPUSH
23719: LD_STRING D6c-Sol2-1
23721: PPUSH
23722: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23726: LD_VAR 0 11
23730: PPUSH
23731: LD_STRING D6c-Sol3-2
23733: PPUSH
23734: CALL_OW 88
// dwait ( 0 0$1 ) ;
23738: LD_INT 35
23740: PPUSH
23741: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23745: LD_EXP 36
23749: PPUSH
23750: LD_STRING D6c-JMM-2
23752: PPUSH
23753: CALL_OW 88
// DialogueOff ;
23757: CALL_OW 7
// Video ( false ) ;
23761: LD_INT 0
23763: PPUSH
23764: CALL 105226 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23768: LD_INT 22
23770: PUSH
23771: LD_INT 4
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PPUSH
23778: CALL_OW 69
23782: PPUSH
23783: LD_INT 1
23785: PPUSH
23786: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23790: LD_INT 4
23792: PPUSH
23793: LD_INT 4
23795: PPUSH
23796: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23800: LD_ADDR_VAR 0 1
23804: PUSH
23805: LD_INT 4
23807: PPUSH
23808: LD_INT 1
23810: PPUSH
23811: LD_INT 2
23813: PPUSH
23814: CALL 62963 0 3
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23857
// if GetTech ( i , 1 ) <> state_researched then
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 1
23829: PPUSH
23830: CALL_OW 321
23834: PUSH
23835: LD_INT 2
23837: NONEQUAL
23838: IFFALSE 23855
// SetTech ( i , 1 , state_researched ) ;
23840: LD_VAR 0 1
23844: PPUSH
23845: LD_INT 1
23847: PPUSH
23848: LD_INT 2
23850: PPUSH
23851: CALL_OW 322
23855: GO 23819
23857: POP
23858: POP
// missionStage := 6 ;
23859: LD_ADDR_EXP 15
23863: PUSH
23864: LD_INT 6
23866: ST_TO_ADDR
// activeAttacks := true ;
23867: LD_ADDR_EXP 16
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23875: LD_STRING M2
23877: PPUSH
23878: CALL_OW 337
// SaveForQuickRestart ;
23882: CALL_OW 22
// wait ( 0 0$40 ) ;
23886: LD_INT 1400
23888: PPUSH
23889: CALL_OW 67
// DialogueOn ;
23893: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23897: LD_EXP 59
23901: PPUSH
23902: LD_STRING D7-Friend-1
23904: PPUSH
23905: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23909: LD_EXP 36
23913: PPUSH
23914: LD_STRING D7-JMM-1
23916: PPUSH
23917: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23921: LD_EXP 59
23925: PPUSH
23926: LD_STRING D7-Friend-2
23928: PPUSH
23929: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23933: LD_EXP 36
23937: PPUSH
23938: LD_STRING D7-JMM-2
23940: PPUSH
23941: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23945: LD_EXP 59
23949: PPUSH
23950: LD_STRING D7-Friend-3
23952: PPUSH
23953: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23957: LD_EXP 36
23961: PPUSH
23962: LD_STRING D7-JMM-3
23964: PPUSH
23965: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23969: LD_EXP 59
23973: PPUSH
23974: LD_STRING D7-Friend-4
23976: PPUSH
23977: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23981: LD_EXP 36
23985: PPUSH
23986: LD_STRING D7-JMM-4
23988: PPUSH
23989: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23993: LD_EXP 59
23997: PPUSH
23998: LD_STRING D7-Friend-5
24000: PPUSH
24001: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24005: LD_EXP 36
24009: PPUSH
24010: LD_STRING D7-JMM-5
24012: PPUSH
24013: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24017: LD_EXP 59
24021: PPUSH
24022: LD_STRING D7-Friend-6
24024: PPUSH
24025: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24029: LD_EXP 36
24033: PPUSH
24034: LD_STRING D7-JMM-6
24036: PPUSH
24037: CALL_OW 88
// DialogueOff ;
24041: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24045: LD_STRING Mlegion
24047: PPUSH
24048: CALL_OW 337
// RebuildKozlovFactory ;
24052: CALL 4684 0 0
// end ;
24056: PPOPN 13
24058: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24059: LD_EXP 20
24063: PUSH
24064: LD_EXP 55
24068: PPUSH
24069: CALL_OW 300
24073: AND
24074: IFFALSE 24116
24076: GO 24078
24078: DISABLE
// begin enable ;
24079: ENABLE
// if IsInUnit ( Powell ) then
24080: LD_EXP 55
24084: PPUSH
24085: CALL_OW 310
24089: IFFALSE 24107
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24091: LD_EXP 55
24095: PPUSH
24096: CALL_OW 310
24100: PPUSH
24101: CALL_OW 85
24105: GO 24116
// CenterOnUnits ( Powell ) ;
24107: LD_EXP 55
24111: PPUSH
24112: CALL_OW 85
// end ;
24116: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24117: LD_INT 22
24119: PUSH
24120: LD_INT 8
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 34
24129: PUSH
24130: LD_INT 48
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PPUSH
24141: CALL_OW 69
24145: IFFALSE 24408
24147: GO 24149
24149: DISABLE
24150: LD_INT 0
24152: PPUSH
24153: PPUSH
// begin if missionStage < 9 then
24154: LD_EXP 15
24158: PUSH
24159: LD_INT 9
24161: LESS
24162: IFFALSE 24172
// missionStage := 9 ;
24164: LD_ADDR_EXP 15
24168: PUSH
24169: LD_INT 9
24171: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24172: LD_ADDR_VAR 0 1
24176: PUSH
24177: LD_INT 22
24179: PUSH
24180: LD_INT 8
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: LD_INT 34
24189: PUSH
24190: LD_INT 48
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: EMPTY
24198: LIST
24199: LIST
24200: PPUSH
24201: CALL_OW 69
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24210: LD_INT 175
24212: PPUSH
24213: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24217: LD_EXP 12
24221: PUSH
24222: LD_EXP 3
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 2
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: IN
24237: OR
24238: IFFALSE 24261
// target := [ 68 , 108 , 1 ] else
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: LD_INT 68
24247: PUSH
24248: LD_INT 108
24250: PUSH
24251: LD_INT 1
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: LIST
24258: ST_TO_ADDR
24259: GO 24280
// target := [ 181 , 88 , 2 ] ;
24261: LD_ADDR_VAR 0 2
24265: PUSH
24266: LD_INT 181
24268: PUSH
24269: LD_INT 88
24271: PUSH
24272: LD_INT 2
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: LIST
24279: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24280: LD_VAR 0 1
24284: PPUSH
24285: LD_VAR 0 2
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 2
24298: PUSH
24299: LD_INT 2
24301: ARRAY
24302: PPUSH
24303: CALL_OW 176
// if target [ 3 ] = 1 then
24307: LD_VAR 0 2
24311: PUSH
24312: LD_INT 3
24314: ARRAY
24315: PUSH
24316: LD_INT 1
24318: EQUAL
24319: IFFALSE 24335
// SayRadio ( Kurt , D12-Kurt-1 ) else
24321: LD_EXP 57
24325: PPUSH
24326: LD_STRING D12-Kurt-1
24328: PPUSH
24329: CALL_OW 94
24333: GO 24359
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24335: LD_EXP 57
24339: PPUSH
24340: LD_STRING D12a-Kurt-1
24342: PPUSH
24343: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24347: LD_EXP 71
24351: PPUSH
24352: LD_STRING D12a-Roth-1
24354: PPUSH
24355: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24359: LD_INT 350
24361: PPUSH
24362: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24366: LD_VAR 0 1
24370: PPUSH
24371: LD_INT 22
24373: PUSH
24374: LD_INT 8
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 30
24383: PUSH
24384: LD_INT 3
24386: PUSH
24387: EMPTY
24388: LIST
24389: LIST
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PPUSH
24395: CALL_OW 69
24399: PUSH
24400: LD_INT 1
24402: ARRAY
24403: PPUSH
24404: CALL_OW 228
// end ;
24408: PPOPN 2
24410: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24411: LD_INT 22
24413: PUSH
24414: LD_INT 8
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: PUSH
24421: LD_INT 21
24423: PUSH
24424: LD_INT 1
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_INT 23
24433: PUSH
24434: LD_INT 2
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: PPUSH
24446: CALL_OW 69
24450: PUSH
24451: LD_INT 8
24453: PUSH
24454: LD_INT 7
24456: PUSH
24457: LD_INT 6
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: LIST
24464: PUSH
24465: LD_OWVAR 67
24469: ARRAY
24470: LESSEQUAL
24471: PUSH
24472: LD_INT 22
24474: PUSH
24475: LD_INT 8
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 34
24484: PUSH
24485: LD_INT 48
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PPUSH
24496: CALL_OW 69
24500: NOT
24501: AND
24502: PUSH
24503: LD_EXP 57
24507: PPUSH
24508: CALL_OW 302
24512: AND
24513: IFFALSE 24830
24515: GO 24517
24517: DISABLE
// begin DialogueOn ;
24518: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24522: LD_EXP 36
24526: PPUSH
24527: LD_STRING D13-JMM-1
24529: PPUSH
24530: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24534: LD_EXP 57
24538: PPUSH
24539: LD_STRING D13-Kurt-1
24541: PPUSH
24542: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24546: LD_EXP 36
24550: PPUSH
24551: LD_STRING D13-JMM-2
24553: PPUSH
24554: CALL_OW 88
// if FakeInfo then
24558: LD_EXP 12
24562: IFFALSE 24582
// begin Say ( Kurt , D13-Kurt-2 ) ;
24564: LD_EXP 57
24568: PPUSH
24569: LD_STRING D13-Kurt-2
24571: PPUSH
24572: CALL_OW 88
// DialogueOff ;
24576: CALL_OW 7
// exit ;
24580: GO 24830
// end ; if not KurtStatus then
24582: LD_EXP 3
24586: NOT
24587: IFFALSE 24603
// Say ( Kurt , D13-Kurt-2b ) else
24589: LD_EXP 57
24593: PPUSH
24594: LD_STRING D13-Kurt-2b
24596: PPUSH
24597: CALL_OW 88
24601: GO 24615
// Say ( Kurt , D13-Kurt-2a ) ;
24603: LD_EXP 57
24607: PPUSH
24608: LD_STRING D13-Kurt-2a
24610: PPUSH
24611: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24615: LD_EXP 57
24619: PPUSH
24620: LD_STRING D13-Kurt-2a
24622: PPUSH
24623: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24627: LD_EXP 36
24631: PPUSH
24632: LD_STRING D13-JMM-3
24634: PPUSH
24635: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24639: LD_EXP 57
24643: PPUSH
24644: LD_STRING D13-Kurt-3
24646: PPUSH
24647: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24651: LD_EXP 36
24655: PPUSH
24656: LD_STRING D13-JMM-4
24658: PPUSH
24659: CALL_OW 88
// DialogueOff ;
24663: CALL_OW 7
// MC_Kill ( 3 ) ;
24667: LD_INT 3
24669: PPUSH
24670: CALL 33924 0 1
// KillUnit ( Kozlov ) ;
24674: LD_EXP 58
24678: PPUSH
24679: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24683: LD_INT 22
24685: PUSH
24686: LD_INT 8
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: LD_INT 21
24695: PUSH
24696: LD_INT 3
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PUSH
24703: LD_INT 23
24705: PUSH
24706: LD_INT 3
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: PUSH
24713: LD_INT 30
24715: PUSH
24716: LD_INT 3
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: LIST
24727: LIST
24728: PPUSH
24729: CALL_OW 69
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24742: LD_INT 8
24744: PPUSH
24745: LD_INT 1
24747: PPUSH
24748: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24752: LD_INT 22
24754: PUSH
24755: LD_INT 8
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PPUSH
24762: CALL_OW 69
24766: PPUSH
24767: LD_INT 1
24769: PPUSH
24770: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24774: LD_INT 8
24776: PPUSH
24777: LD_INT 1
24779: PPUSH
24780: LD_INT 1
24782: PPUSH
24783: LD_INT 1
24785: PPUSH
24786: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24790: LD_EXP 59
24794: PPUSH
24795: LD_INT 37
24797: PPUSH
24798: LD_INT 1
24800: PPUSH
24801: LD_INT 0
24803: PPUSH
24804: CALL_OW 48
// wait ( 0 0$1 ) ;
24808: LD_INT 35
24810: PPUSH
24811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24815: LD_EXP 59
24819: PPUSH
24820: LD_INT 60
24822: PPUSH
24823: LD_INT 95
24825: PPUSH
24826: CALL_OW 111
// end ;
24830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24831: LD_INT 22
24833: PUSH
24834: LD_INT 8
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 21
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 0
24862: EQUAL
24863: IFFALSE 24883
24865: GO 24867
24867: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24868: LD_STRING MlegionOut
24870: PPUSH
24871: CALL_OW 337
// legionDestroyed := true ;
24875: LD_ADDR_EXP 22
24879: PUSH
24880: LD_INT 1
24882: ST_TO_ADDR
// end ;
24883: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24884: LD_INT 1
24886: PPUSH
24887: LD_EXP 59
24891: PPUSH
24892: CALL_OW 292
24896: IFFALSE 25196
24898: GO 24900
24900: DISABLE
24901: LD_INT 0
24903: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24904: LD_EXP 59
24908: PPUSH
24909: CALL_OW 87
// DialogueOn ;
24913: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24917: LD_EXP 36
24921: PPUSH
24922: LD_STRING D14-JMM-1
24924: PPUSH
24925: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24929: LD_EXP 59
24933: PPUSH
24934: LD_STRING D14-Friend-1
24936: PPUSH
24937: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24941: LD_EXP 36
24945: PPUSH
24946: LD_STRING D14-JMM-2
24948: PPUSH
24949: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24953: LD_EXP 59
24957: PPUSH
24958: LD_STRING D14-Friend-2
24960: PPUSH
24961: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24965: LD_EXP 36
24969: PPUSH
24970: LD_STRING D14-JMM-3
24972: PPUSH
24973: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24977: LD_EXP 59
24981: PPUSH
24982: LD_STRING D14-Friend-3
24984: PPUSH
24985: CALL_OW 88
// DialogueOff ;
24989: CALL_OW 7
// dec = Query ( Q14 ) ;
24993: LD_ADDR_VAR 0 1
24997: PUSH
24998: LD_STRING Q14
25000: PPUSH
25001: CALL_OW 97
25005: ST_TO_ADDR
// if dec = 1 then
25006: LD_VAR 0 1
25010: PUSH
25011: LD_INT 1
25013: EQUAL
25014: IFFALSE 25048
// begin DialogueOn ;
25016: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25020: LD_EXP 36
25024: PPUSH
25025: LD_STRING D14a-JMM-1
25027: PPUSH
25028: CALL_OW 88
// DialogueOff ;
25032: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25036: LD_EXP 59
25040: PPUSH
25041: LD_INT 1
25043: PPUSH
25044: CALL_OW 235
// end ; if dec = 2 then
25048: LD_VAR 0 1
25052: PUSH
25053: LD_INT 2
25055: EQUAL
25056: IFFALSE 25102
// begin DialogueOn ;
25058: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25062: LD_EXP 36
25066: PPUSH
25067: LD_STRING D14b-JMM-1
25069: PPUSH
25070: CALL_OW 88
// DialogueOff ;
25074: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25078: LD_EXP 59
25082: PPUSH
25083: LD_INT 9
25085: PPUSH
25086: LD_INT 2
25088: PPUSH
25089: CALL_OW 111
// AddComHold ( Friend ) ;
25093: LD_EXP 59
25097: PPUSH
25098: CALL_OW 200
// end ; if dec = 3 then
25102: LD_VAR 0 1
25106: PUSH
25107: LD_INT 3
25109: EQUAL
25110: IFFALSE 25196
// begin DialogueOn ;
25112: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25116: LD_EXP 36
25120: PPUSH
25121: LD_STRING D14c-JMM-1
25123: PPUSH
25124: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25128: LD_EXP 59
25132: PPUSH
25133: LD_STRING D14c-Friend-1
25135: PPUSH
25136: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25140: LD_EXP 36
25144: PPUSH
25145: LD_STRING D14c-JMM-2
25147: PPUSH
25148: CALL_OW 88
// DialogueOff ;
25152: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25156: LD_INT 8
25158: PPUSH
25159: LD_INT 1
25161: PPUSH
25162: LD_INT 2
25164: PPUSH
25165: LD_INT 1
25167: PPUSH
25168: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25172: LD_EXP 59
25176: PPUSH
25177: LD_INT 9
25179: PPUSH
25180: LD_INT 2
25182: PPUSH
25183: CALL_OW 111
// AddComHold ( Friend ) ;
25187: LD_EXP 59
25191: PPUSH
25192: CALL_OW 200
// end ; end ;
25196: PPOPN 1
25198: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25199: LD_INT 9
25201: PPUSH
25202: LD_INT 2
25204: PPUSH
25205: CALL_OW 428
25209: PUSH
25210: LD_EXP 59
25214: EQUAL
25215: PUSH
25216: LD_EXP 59
25220: PPUSH
25221: CALL_OW 255
25225: PUSH
25226: LD_INT 8
25228: EQUAL
25229: AND
25230: IFFALSE 25244
25232: GO 25234
25234: DISABLE
// RemoveUnit ( Friend ) ;
25235: LD_EXP 59
25239: PPUSH
25240: CALL_OW 64
25244: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25245: LD_EXP 14
25249: PUSH
25250: LD_INT 31500
25252: GREATEREQUAL
25253: PUSH
25254: LD_EXP 7
25258: AND
25259: PUSH
25260: LD_EXP 2
25264: AND
25265: IFFALSE 25695
25267: GO 25269
25269: DISABLE
25270: LD_INT 0
25272: PPUSH
25273: PPUSH
25274: PPUSH
// begin missionStage := 7 ;
25275: LD_ADDR_EXP 15
25279: PUSH
25280: LD_INT 7
25282: ST_TO_ADDR
// uc_side = 1 ;
25283: LD_ADDR_OWVAR 20
25287: PUSH
25288: LD_INT 1
25290: ST_TO_ADDR
// uc_nation = 1 ;
25291: LD_ADDR_OWVAR 21
25295: PUSH
25296: LD_INT 1
25298: ST_TO_ADDR
// for i = 1 to 5 do
25299: LD_ADDR_VAR 0 1
25303: PUSH
25304: DOUBLE
25305: LD_INT 1
25307: DEC
25308: ST_TO_ADDR
25309: LD_INT 5
25311: PUSH
25312: FOR_TO
25313: IFFALSE 25409
// begin vc_engine = 3 ;
25315: LD_ADDR_OWVAR 39
25319: PUSH
25320: LD_INT 3
25322: ST_TO_ADDR
// vc_control = 3 ;
25323: LD_ADDR_OWVAR 38
25327: PUSH
25328: LD_INT 3
25330: ST_TO_ADDR
// vc_chassis = 3 ;
25331: LD_ADDR_OWVAR 37
25335: PUSH
25336: LD_INT 3
25338: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25339: LD_ADDR_OWVAR 40
25343: PUSH
25344: LD_INT 5
25346: PUSH
25347: LD_INT 9
25349: PUSH
25350: LD_INT 7
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 1
25360: PPUSH
25361: LD_INT 3
25363: PPUSH
25364: CALL_OW 12
25368: ARRAY
25369: ST_TO_ADDR
// veh = CreateVehicle ;
25370: LD_ADDR_VAR 0 2
25374: PUSH
25375: CALL_OW 45
25379: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25380: LD_VAR 0 2
25384: PPUSH
25385: LD_INT 1
25387: PPUSH
25388: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25392: LD_VAR 0 2
25396: PPUSH
25397: LD_INT 19
25399: PPUSH
25400: LD_INT 0
25402: PPUSH
25403: CALL_OW 49
// end ;
25407: GO 25312
25409: POP
25410: POP
// vc_engine = 3 ;
25411: LD_ADDR_OWVAR 39
25415: PUSH
25416: LD_INT 3
25418: ST_TO_ADDR
// vc_control = 1 ;
25419: LD_ADDR_OWVAR 38
25423: PUSH
25424: LD_INT 1
25426: ST_TO_ADDR
// vc_chassis = 3 ;
25427: LD_ADDR_OWVAR 37
25431: PUSH
25432: LD_INT 3
25434: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25435: LD_ADDR_OWVAR 40
25439: PUSH
25440: LD_INT 5
25442: PUSH
25443: LD_INT 9
25445: PUSH
25446: LD_INT 7
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 1
25456: PPUSH
25457: LD_INT 3
25459: PPUSH
25460: CALL_OW 12
25464: ARRAY
25465: ST_TO_ADDR
// vehG = CreateVehicle ;
25466: LD_ADDR_VAR 0 3
25470: PUSH
25471: CALL_OW 45
25475: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25476: LD_VAR 0 3
25480: PPUSH
25481: LD_INT 1
25483: PPUSH
25484: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25488: LD_VAR 0 3
25492: PPUSH
25493: LD_INT 19
25495: PPUSH
25496: LD_INT 0
25498: PPUSH
25499: CALL_OW 49
// if JMMGirl = 1 then
25503: LD_EXP 7
25507: PUSH
25508: LD_INT 1
25510: EQUAL
25511: IFFALSE 25567
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25513: LD_ADDR_EXP 37
25517: PUSH
25518: LD_STRING Joan
25520: PPUSH
25521: LD_INT 1
25523: PPUSH
25524: LD_STRING 14_
25526: PPUSH
25527: CALL 62900 0 3
25531: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25532: LD_EXP 37
25536: PPUSH
25537: LD_VAR 0 3
25541: PPUSH
25542: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25546: LD_VAR 0 3
25550: PPUSH
25551: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25555: LD_EXP 37
25559: PPUSH
25560: LD_STRING D10BW-Joan-1
25562: PPUSH
25563: CALL_OW 94
// end ; if JMMGirl = 2 then
25567: LD_EXP 7
25571: PUSH
25572: LD_INT 2
25574: EQUAL
25575: IFFALSE 25631
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25577: LD_ADDR_EXP 39
25581: PUSH
25582: LD_STRING Lisa
25584: PPUSH
25585: LD_INT 1
25587: PPUSH
25588: LD_STRING 14_
25590: PPUSH
25591: CALL 62900 0 3
25595: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25596: LD_EXP 39
25600: PPUSH
25601: LD_VAR 0 3
25605: PPUSH
25606: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25610: LD_VAR 0 3
25614: PPUSH
25615: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25619: LD_EXP 39
25623: PPUSH
25624: LD_STRING D10BW-Lisa-1
25626: PPUSH
25627: CALL_OW 94
// end ; if JMMGirl = 3 then
25631: LD_EXP 7
25635: PUSH
25636: LD_INT 3
25638: EQUAL
25639: IFFALSE 25695
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25641: LD_ADDR_EXP 51
25645: PUSH
25646: LD_STRING Connie
25648: PPUSH
25649: LD_INT 1
25651: PPUSH
25652: LD_STRING 14_
25654: PPUSH
25655: CALL 62900 0 3
25659: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25660: LD_EXP 51
25664: PPUSH
25665: LD_VAR 0 3
25669: PPUSH
25670: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25674: LD_VAR 0 3
25678: PPUSH
25679: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25683: LD_EXP 39
25687: PPUSH
25688: LD_STRING D10BW-Con-1
25690: PPUSH
25691: CALL_OW 94
// end ; end ;
25695: PPOPN 3
25697: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25698: LD_EXP 14
25702: PUSH
25703: LD_INT 94500
25705: GREATEREQUAL
25706: IFFALSE 26118
25708: GO 25710
25710: DISABLE
25711: LD_INT 0
25713: PPUSH
25714: PPUSH
25715: PPUSH
// begin tmp := PrepareStevensSquad ;
25716: LD_ADDR_VAR 0 3
25720: PUSH
25721: CALL 2058 0 0
25725: ST_TO_ADDR
// if not tmp then
25726: LD_VAR 0 3
25730: NOT
25731: IFFALSE 25735
// exit ;
25733: GO 26118
// uc_side := 1 ;
25735: LD_ADDR_OWVAR 20
25739: PUSH
25740: LD_INT 1
25742: ST_TO_ADDR
// uc_nation := 1 ;
25743: LD_ADDR_OWVAR 21
25747: PUSH
25748: LD_INT 1
25750: ST_TO_ADDR
// for i in tmp do
25751: LD_ADDR_VAR 0 1
25755: PUSH
25756: LD_VAR 0 3
25760: PUSH
25761: FOR_IN
25762: IFFALSE 25859
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25764: LD_INT 3
25766: PPUSH
25767: LD_INT 3
25769: PPUSH
25770: LD_INT 1
25772: PPUSH
25773: LD_INT 5
25775: PUSH
25776: LD_INT 9
25778: PUSH
25779: LD_INT 7
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: PPUSH
25790: LD_INT 3
25792: PPUSH
25793: CALL_OW 12
25797: ARRAY
25798: PPUSH
25799: LD_INT 40
25801: PPUSH
25802: CALL 69533 0 5
// veh := CreateVehicle ;
25806: LD_ADDR_VAR 0 2
25810: PUSH
25811: CALL_OW 45
25815: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25816: LD_VAR 0 2
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25828: LD_VAR 0 2
25832: PPUSH
25833: LD_INT 19
25835: PPUSH
25836: LD_INT 0
25838: PPUSH
25839: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25843: LD_VAR 0 1
25847: PPUSH
25848: LD_VAR 0 2
25852: PPUSH
25853: CALL_OW 52
// end ;
25857: GO 25761
25859: POP
25860: POP
// missionStage := 8 ;
25861: LD_ADDR_EXP 15
25865: PUSH
25866: LD_INT 8
25868: ST_TO_ADDR
// DialogueOn ;
25869: CALL_OW 6
// if Stevens then
25873: LD_EXP 38
25877: IFFALSE 25991
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25879: LD_EXP 38
25883: PPUSH
25884: CALL_OW 310
25888: PPUSH
25889: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25893: LD_EXP 38
25897: PPUSH
25898: LD_STRING D8-Huck-1
25900: PPUSH
25901: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25905: LD_EXP 36
25909: PPUSH
25910: LD_STRING D8-JMM-1
25912: PPUSH
25913: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25917: LD_EXP 38
25921: PPUSH
25922: LD_STRING D8-Huck-2
25924: PPUSH
25925: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25929: LD_EXP 36
25933: PPUSH
25934: LD_STRING D8-JMM-2
25936: PPUSH
25937: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25941: LD_EXP 38
25945: PPUSH
25946: LD_STRING D8-Huck-3
25948: PPUSH
25949: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25953: LD_EXP 36
25957: PPUSH
25958: LD_STRING D8-JMM-3
25960: PPUSH
25961: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25965: LD_EXP 38
25969: PPUSH
25970: LD_STRING D8-Huck-4
25972: PPUSH
25973: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25977: LD_EXP 36
25981: PPUSH
25982: LD_STRING D8-JMM-4
25984: PPUSH
25985: CALL_OW 88
// end else
25989: GO 26101
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25991: LD_EXP 52
25995: PPUSH
25996: CALL_OW 310
26000: PPUSH
26001: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26005: LD_EXP 52
26009: PPUSH
26010: LD_STRING D8-Huck-1
26012: PPUSH
26013: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26017: LD_EXP 36
26021: PPUSH
26022: LD_STRING D8-JMM-1a
26024: PPUSH
26025: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26029: LD_EXP 52
26033: PPUSH
26034: LD_STRING D8-Huck-2
26036: PPUSH
26037: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26041: LD_EXP 36
26045: PPUSH
26046: LD_STRING D8-JMM-2
26048: PPUSH
26049: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26053: LD_EXP 52
26057: PPUSH
26058: LD_STRING D8-Huck-3
26060: PPUSH
26061: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26065: LD_EXP 36
26069: PPUSH
26070: LD_STRING D8-JMM-3
26072: PPUSH
26073: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26077: LD_EXP 52
26081: PPUSH
26082: LD_STRING D8-Huck-4
26084: PPUSH
26085: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26089: LD_EXP 36
26093: PPUSH
26094: LD_STRING D8-JMM-4
26096: PPUSH
26097: CALL_OW 88
// end ; DialogueOff ;
26101: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26105: LD_INT 25
26107: PPUSH
26108: LD_INT 1
26110: PPUSH
26111: LD_INT 1
26113: PPUSH
26114: CALL_OW 322
// end ;
26118: PPOPN 3
26120: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26121: LD_INT 1
26123: PPUSH
26124: LD_EXP 68
26128: PPUSH
26129: CALL_OW 292
26133: IFFALSE 26384
26135: GO 26137
26137: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26138: LD_EXP 68
26142: PPUSH
26143: CALL_OW 87
// DialogueOn ;
26147: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26151: LD_EXP 36
26155: PPUSH
26156: LD_STRING D10nB-JMM-1
26158: PPUSH
26159: CALL_OW 88
// if BurlakStatus = 1 then
26163: LD_EXP 9
26167: PUSH
26168: LD_INT 1
26170: EQUAL
26171: IFFALSE 26185
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26173: LD_EXP 67
26177: PPUSH
26178: LD_STRING D10nB-Vse-1a
26180: PPUSH
26181: CALL_OW 94
// end ; if BurlakStatus = 0 then
26185: LD_EXP 9
26189: PUSH
26190: LD_INT 0
26192: EQUAL
26193: IFFALSE 26207
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26195: LD_EXP 67
26199: PPUSH
26200: LD_STRING D10nB-Vse-1
26202: PPUSH
26203: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26207: LD_EXP 36
26211: PPUSH
26212: LD_STRING D10nB-JMM-2
26214: PPUSH
26215: CALL_OW 88
// if KappaStatus then
26219: LD_EXP 2
26223: IFFALSE 26237
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26225: LD_EXP 67
26229: PPUSH
26230: LD_STRING D10nB-Vse-5a
26232: PPUSH
26233: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26237: LD_EXP 2
26241: NOT
26242: PUSH
26243: LD_EXP 6
26247: PUSH
26248: LD_INT 0
26250: EQUAL
26251: AND
26252: IFFALSE 26380
// begin if JMMGirl = 1 then
26254: LD_EXP 7
26258: PUSH
26259: LD_INT 1
26261: EQUAL
26262: IFFALSE 26312
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26264: LD_EXP 67
26268: PPUSH
26269: LD_STRING D10nB-Vse-2
26271: PPUSH
26272: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26276: LD_EXP 36
26280: PPUSH
26281: LD_STRING D10nB-JMM-3
26283: PPUSH
26284: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26288: LD_EXP 67
26292: PPUSH
26293: LD_STRING D10nB-Vse-3
26295: PPUSH
26296: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26300: LD_EXP 36
26304: PPUSH
26305: LD_STRING D10nB-JMM-4
26307: PPUSH
26308: CALL_OW 88
// end ; if JMMGirl = 2 then
26312: LD_EXP 7
26316: PUSH
26317: LD_INT 2
26319: EQUAL
26320: IFFALSE 26346
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26322: LD_EXP 67
26326: PPUSH
26327: LD_STRING D10nB-Vse-4
26329: PPUSH
26330: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26334: LD_EXP 36
26338: PPUSH
26339: LD_STRING D10nB-JMM-5
26341: PPUSH
26342: CALL_OW 88
// end ; if JMMGirl = 3 then
26346: LD_EXP 7
26350: PUSH
26351: LD_INT 3
26353: EQUAL
26354: IFFALSE 26380
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26356: LD_EXP 67
26360: PPUSH
26361: LD_STRING D10nB-Vse-5
26363: PPUSH
26364: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26368: LD_EXP 36
26372: PPUSH
26373: LD_STRING D10nB-JMM-6
26375: PPUSH
26376: CALL_OW 88
// end ; end ; DialogueOff ;
26380: CALL_OW 7
// end ;
26384: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26385: LD_EXP 14
26389: PUSH
26390: LD_INT 115500
26392: GREATEREQUAL
26393: IFFALSE 26752
26395: GO 26397
26397: DISABLE
26398: LD_INT 0
26400: PPUSH
// begin missionStage := 10 ;
26401: LD_ADDR_EXP 15
26405: PUSH
26406: LD_INT 10
26408: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26409: LD_ADDR_VAR 0 1
26413: PUSH
26414: LD_INT 22
26416: PUSH
26417: LD_INT 1
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 26
26426: PUSH
26427: LD_INT 1
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: LD_INT 25
26439: PUSH
26440: LD_INT 12
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 25
26456: PUSH
26457: LD_INT 16
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: PPUSH
26474: CALL_OW 69
26478: PUSH
26479: LD_EXP 36
26483: PUSH
26484: LD_EXP 38
26488: PUSH
26489: LD_EXP 52
26493: PUSH
26494: LD_EXP 39
26498: PUSH
26499: LD_EXP 40
26503: PUSH
26504: LD_EXP 41
26508: PUSH
26509: LD_EXP 42
26513: PUSH
26514: LD_EXP 43
26518: PUSH
26519: LD_EXP 44
26523: PUSH
26524: LD_EXP 45
26528: PUSH
26529: LD_EXP 46
26533: PUSH
26534: LD_EXP 47
26538: PUSH
26539: LD_EXP 48
26543: PUSH
26544: LD_EXP 49
26548: PUSH
26549: LD_EXP 50
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: LIST
26569: LIST
26570: DIFF
26571: ST_TO_ADDR
// if not tmp and Brown then
26572: LD_VAR 0 1
26576: NOT
26577: PUSH
26578: LD_EXP 44
26582: AND
26583: IFFALSE 26598
// tmp := [ Brown ] ;
26585: LD_ADDR_VAR 0 1
26589: PUSH
26590: LD_EXP 44
26594: PUSH
26595: EMPTY
26596: LIST
26597: ST_TO_ADDR
// DialogueOn ;
26598: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26602: LD_VAR 0 1
26606: PUSH
26607: LD_INT 1
26609: ARRAY
26610: PPUSH
26611: LD_STRING D11-Sol1-1
26613: PPUSH
26614: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26618: LD_EXP 61
26622: PPUSH
26623: LD_STRING D11-Pla-1
26625: PPUSH
26626: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26630: LD_EXP 62
26634: PPUSH
26635: LD_STRING D11-Kov-1
26637: PPUSH
26638: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26642: LD_EXP 61
26646: PPUSH
26647: LD_STRING D11-Pla-2
26649: PPUSH
26650: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26654: LD_VAR 0 1
26658: PUSH
26659: LD_INT 1
26661: ARRAY
26662: PPUSH
26663: LD_STRING D11-Sol1-2
26665: PPUSH
26666: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26670: LD_EXP 36
26674: PPUSH
26675: LD_STRING D11-JMM-2
26677: PPUSH
26678: CALL_OW 88
// DialogueOff ;
26682: CALL_OW 7
// allowBehemothConstruct := true ;
26686: LD_ADDR_EXP 25
26690: PUSH
26691: LD_INT 1
26693: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26694: LD_STRING M4
26696: PPUSH
26697: CALL_OW 337
// BuildBehemoths ;
26701: CALL 7488 0 0
// repeat wait ( 15 15$00 ) ;
26705: LD_INT 31500
26707: PPUSH
26708: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26712: LD_EXP 27
26716: IFFALSE 26720
// break ;
26718: GO 26752
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26720: LD_INT 267
26722: PPUSH
26723: CALL_OW 274
26727: PPUSH
26728: LD_INT 1
26730: PPUSH
26731: CALL_OW 275
26735: PUSH
26736: LD_INT 1000
26738: GREATEREQUAL
26739: IFFALSE 26745
// BuildBehemoths ;
26741: CALL 7488 0 0
// until not behemothBuilders ;
26745: LD_EXP 70
26749: NOT
26750: IFFALSE 26705
// end ;
26752: PPOPN 1
26754: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26755: LD_EXP 70
26759: NOT
26760: PUSH
26761: LD_EXP 28
26765: NOT
26766: AND
26767: PUSH
26768: LD_EXP 25
26772: AND
26773: IFFALSE 26793
26775: GO 26777
26777: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26778: LD_STRING M4a
26780: PPUSH
26781: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26785: LD_ADDR_EXP 27
26789: PUSH
26790: LD_INT 1
26792: ST_TO_ADDR
// end ;
26793: END
// every 0 0$1 trigger behemothDone do
26794: LD_EXP 28
26798: IFFALSE 26810
26800: GO 26802
26802: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26803: LD_STRING M4b
26805: PPUSH
26806: CALL_OW 337
26810: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26811: LD_EXP 29
26815: NOT
26816: IFFALSE 27012
26818: GO 26820
26820: DISABLE
26821: LD_INT 0
26823: PPUSH
26824: PPUSH
// begin enable ;
26825: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26826: LD_ADDR_VAR 0 1
26830: PUSH
26831: LD_INT 3
26833: PPUSH
26834: CALL 105302 0 1
26838: ST_TO_ADDR
// if not tmp and not behemothDone then
26839: LD_VAR 0 1
26843: NOT
26844: PUSH
26845: LD_EXP 28
26849: NOT
26850: AND
26851: IFFALSE 26887
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26853: LD_ADDR_VAR 0 1
26857: PUSH
26858: LD_INT 22
26860: PUSH
26861: LD_INT 3
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 30
26870: PUSH
26871: LD_INT 37
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: PPUSH
26882: CALL_OW 69
26886: ST_TO_ADDR
// if not tmp then
26887: LD_VAR 0 1
26891: NOT
26892: IFFALSE 26896
// exit ;
26894: GO 27012
// for i in tmp do
26896: LD_ADDR_VAR 0 2
26900: PUSH
26901: LD_VAR 0 1
26905: PUSH
26906: FOR_IN
26907: IFFALSE 27010
// if See ( 1 , i ) then
26909: LD_INT 1
26911: PPUSH
26912: LD_VAR 0 2
26916: PPUSH
26917: CALL_OW 292
26921: IFFALSE 27008
// begin if GetType ( i ) = unit_building then
26923: LD_VAR 0 2
26927: PPUSH
26928: CALL_OW 247
26932: PUSH
26933: LD_INT 3
26935: EQUAL
26936: IFFALSE 26974
// begin CenterNowOnUnits ( i ) ;
26938: LD_VAR 0 2
26942: PPUSH
26943: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26947: LD_EXP 36
26951: PPUSH
26952: LD_STRING D17a-JMM-1
26954: PPUSH
26955: CALL_OW 88
// seeBehemoth := true ;
26959: LD_ADDR_EXP 29
26963: PUSH
26964: LD_INT 1
26966: ST_TO_ADDR
// disable ;
26967: DISABLE
// exit ;
26968: POP
26969: POP
26970: GO 27012
// end else
26972: GO 27008
// begin CenterNowOnUnits ( i ) ;
26974: LD_VAR 0 2
26978: PPUSH
26979: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26983: LD_EXP 36
26987: PPUSH
26988: LD_STRING D17b-JMM-1
26990: PPUSH
26991: CALL_OW 88
// seeBehemoth := true ;
26995: LD_ADDR_EXP 29
26999: PUSH
27000: LD_INT 1
27002: ST_TO_ADDR
// disable ;
27003: DISABLE
// exit ;
27004: POP
27005: POP
27006: GO 27012
// end ; end ;
27008: GO 26906
27010: POP
27011: POP
// end ;
27012: PPOPN 2
27014: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27015: LD_EXP 14
27019: PUSH
27020: LD_INT 116550
27022: GREATEREQUAL
27023: IFFALSE 28199
27025: GO 27027
27027: DISABLE
27028: LD_INT 0
27030: PPUSH
27031: PPUSH
27032: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27033: LD_INT 2
27035: PPUSH
27036: LD_INT 23
27038: PUSH
27039: LD_INT 3
27041: PUSH
27042: LD_INT 3
27044: PUSH
27045: LD_INT 48
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: PPUSH
27057: CALL 56968 0 2
// repeat wait ( 0 0$1 ) ;
27061: LD_INT 35
27063: PPUSH
27064: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27068: LD_INT 22
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 34
27080: PUSH
27081: LD_INT 48
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PPUSH
27092: CALL_OW 69
27096: IFFALSE 27061
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27098: LD_ADDR_VAR 0 1
27102: PUSH
27103: LD_INT 22
27105: PUSH
27106: LD_INT 3
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 34
27115: PUSH
27116: LD_INT 48
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PPUSH
27127: CALL_OW 69
27131: PUSH
27132: LD_INT 1
27134: ARRAY
27135: ST_TO_ADDR
// missionStage := 12 ;
27136: LD_ADDR_EXP 15
27140: PUSH
27141: LD_INT 12
27143: ST_TO_ADDR
// platonovHasBomb := true ;
27144: LD_ADDR_EXP 30
27148: PUSH
27149: LD_INT 1
27151: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 181
27159: PPUSH
27160: LD_INT 86
27162: PPUSH
27163: CALL_OW 171
// AddComHold ( bomb ) ;
27167: LD_VAR 0 1
27171: PPUSH
27172: CALL_OW 200
// wait ( 0 0$10 ) ;
27176: LD_INT 350
27178: PPUSH
27179: CALL_OW 67
// DialogueOn ;
27183: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27187: LD_EXP 61
27191: PPUSH
27192: LD_STRING D15-Pla-1
27194: PPUSH
27195: CALL_OW 94
// dec = Query ( Q15a ) ;
27199: LD_ADDR_VAR 0 2
27203: PUSH
27204: LD_STRING Q15a
27206: PPUSH
27207: CALL_OW 97
27211: ST_TO_ADDR
// if dec = 1 then
27212: LD_VAR 0 2
27216: PUSH
27217: LD_INT 1
27219: EQUAL
27220: IFFALSE 27243
// begin Say ( JMM , D15a-JMM-1 ) ;
27222: LD_EXP 36
27226: PPUSH
27227: LD_STRING D15a-JMM-1
27229: PPUSH
27230: CALL_OW 88
// YouLost ( Surrender ) ;
27234: LD_STRING Surrender
27236: PPUSH
27237: CALL_OW 104
// exit ;
27241: GO 28199
// end ; if dec = 2 then
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: EQUAL
27251: IFFALSE 27320
// begin Say ( JMM , D15b-JMM-1 ) ;
27253: LD_EXP 36
27257: PPUSH
27258: LD_STRING D15b-JMM-1
27260: PPUSH
27261: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27265: LD_EXP 61
27269: PPUSH
27270: LD_STRING D15b-Pla-1
27272: PPUSH
27273: CALL_OW 94
// DialogueOff ;
27277: CALL_OW 7
// wait ( 3 3$00 ) ;
27281: LD_INT 6300
27283: PPUSH
27284: CALL_OW 67
// DialogueOn ;
27288: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27292: LD_EXP 36
27296: PPUSH
27297: LD_STRING D15d-JMM-1a
27299: PPUSH
27300: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27304: LD_EXP 61
27308: PPUSH
27309: LD_STRING D15d-Pla-1
27311: PPUSH
27312: CALL_OW 94
// DialogueOff ;
27316: CALL_OW 7
// end ; if dec = 3 then
27320: LD_VAR 0 2
27324: PUSH
27325: LD_INT 3
27327: EQUAL
27328: IFFALSE 27382
// begin Say ( JMM , D15c-JMM-1 ) ;
27330: LD_EXP 36
27334: PPUSH
27335: LD_STRING D15c-JMM-1
27337: PPUSH
27338: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27342: LD_EXP 61
27346: PPUSH
27347: LD_STRING D15c-Pla-1
27349: PPUSH
27350: CALL_OW 94
// DialogueOff ;
27354: CALL_OW 7
// wait ( 0 0$15 ) ;
27358: LD_INT 525
27360: PPUSH
27361: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27365: LD_VAR 0 1
27369: PPUSH
27370: LD_INT 60
27372: PPUSH
27373: LD_INT 95
27375: PPUSH
27376: CALL_OW 116
// exit ;
27380: GO 28199
// end ; if dec = 4 then
27382: LD_VAR 0 2
27386: PUSH
27387: LD_INT 4
27389: EQUAL
27390: IFFALSE 27420
// begin Say ( JMM , D15d-JMM-1 ) ;
27392: LD_EXP 36
27396: PPUSH
27397: LD_STRING D15d-JMM-1
27399: PPUSH
27400: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27404: LD_EXP 61
27408: PPUSH
27409: LD_STRING D15d-Pla-1
27411: PPUSH
27412: CALL_OW 94
// DialogueOff ;
27416: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27420: LD_EXP 59
27424: PPUSH
27425: CALL_OW 302
27429: PUSH
27430: LD_EXP 59
27434: PPUSH
27435: CALL_OW 255
27439: PUSH
27440: LD_INT 1
27442: EQUAL
27443: AND
27444: PUSH
27445: LD_INT 22
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 34
27457: PUSH
27458: LD_INT 8
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PPUSH
27469: CALL_OW 69
27473: NOT
27474: AND
27475: IFFALSE 28100
// begin SetSide ( Friend , 8 ) ;
27477: LD_EXP 59
27481: PPUSH
27482: LD_INT 8
27484: PPUSH
27485: CALL_OW 235
// if IsInUnit ( Friend ) then
27489: LD_EXP 59
27493: PPUSH
27494: CALL_OW 310
27498: IFFALSE 27509
// ComExitBuilding ( Friend ) ;
27500: LD_EXP 59
27504: PPUSH
27505: CALL_OW 122
// if IsDriver ( Friend ) then
27509: LD_EXP 59
27513: PPUSH
27514: CALL 102979 0 1
27518: IFFALSE 27529
// ComExitVehicle ( Friend ) ;
27520: LD_EXP 59
27524: PPUSH
27525: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27529: LD_EXP 59
27533: PPUSH
27534: LD_INT 9
27536: PPUSH
27537: LD_INT 2
27539: PPUSH
27540: CALL_OW 171
// wait ( 0 0$05 ) ;
27544: LD_INT 175
27546: PPUSH
27547: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27551: LD_EXP 59
27555: PPUSH
27556: CALL_OW 87
// DialogueOn ;
27560: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27564: LD_EXP 36
27568: PPUSH
27569: LD_STRING D16-JMM-1
27571: PPUSH
27572: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27576: LD_EXP 59
27580: PPUSH
27581: LD_STRING D16-Friend-1
27583: PPUSH
27584: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27588: LD_EXP 36
27592: PPUSH
27593: LD_STRING D16-JMM-2
27595: PPUSH
27596: CALL_OW 88
// DialogueOff ;
27600: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27604: LD_EXP 59
27608: PPUSH
27609: LD_INT 1
27611: PPUSH
27612: CALL_OW 235
// ComHold ( Friend ) ;
27616: LD_EXP 59
27620: PPUSH
27621: CALL_OW 140
// wait ( 0 0$20 ) ;
27625: LD_INT 700
27627: PPUSH
27628: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27632: LD_EXP 59
27636: PPUSH
27637: LD_INT 9
27639: PPUSH
27640: LD_INT 2
27642: PPUSH
27643: CALL_OW 297
27647: PUSH
27648: LD_INT 30
27650: LESS
27651: IFFALSE 27720
// begin SetSide ( Friend , 8 ) ;
27653: LD_EXP 59
27657: PPUSH
27658: LD_INT 8
27660: PPUSH
27661: CALL_OW 235
// if IsInUnit ( Friend ) then
27665: LD_EXP 59
27669: PPUSH
27670: CALL_OW 310
27674: IFFALSE 27685
// ComExitBuilding ( Friend ) ;
27676: LD_EXP 59
27680: PPUSH
27681: CALL_OW 122
// if IsDriver ( Friend ) then
27685: LD_EXP 59
27689: PPUSH
27690: CALL 102979 0 1
27694: IFFALSE 27705
// ComExitVehicle ( Friend ) ;
27696: LD_EXP 59
27700: PPUSH
27701: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27705: LD_EXP 59
27709: PPUSH
27710: LD_INT 9
27712: PPUSH
27713: LD_INT 2
27715: PPUSH
27716: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27720: LD_INT 1050
27722: PPUSH
27723: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27727: LD_INT 22
27729: PUSH
27730: LD_INT 1
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: LD_INT 34
27739: PUSH
27740: LD_INT 8
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PPUSH
27751: CALL_OW 69
27755: NOT
27756: IFFALSE 28078
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27758: LD_ADDR_VAR 0 3
27762: PUSH
27763: LD_INT 22
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 26
27775: PUSH
27776: LD_INT 1
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 3
27785: PUSH
27786: LD_INT 25
27788: PUSH
27789: LD_INT 12
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 25
27798: PUSH
27799: LD_INT 16
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PPUSH
27816: CALL_OW 69
27820: PUSH
27821: LD_EXP 36
27825: PUSH
27826: LD_EXP 38
27830: PUSH
27831: LD_EXP 52
27835: PUSH
27836: LD_EXP 39
27840: PUSH
27841: LD_EXP 40
27845: PUSH
27846: LD_EXP 41
27850: PUSH
27851: LD_EXP 42
27855: PUSH
27856: LD_EXP 43
27860: PUSH
27861: LD_EXP 44
27865: PUSH
27866: LD_EXP 45
27870: PUSH
27871: LD_EXP 46
27875: PUSH
27876: LD_EXP 47
27880: PUSH
27881: LD_EXP 48
27885: PUSH
27886: LD_EXP 49
27890: PUSH
27891: LD_EXP 50
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: DIFF
27913: ST_TO_ADDR
// DialogueOn ;
27914: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27918: LD_EXP 61
27922: PPUSH
27923: LD_STRING D16a-Pla-1
27925: PPUSH
27926: CALL_OW 94
// if Stevens then
27930: LD_EXP 38
27934: IFFALSE 27950
// Say ( Stevens , D16a-Huck-1 ) else
27936: LD_EXP 38
27940: PPUSH
27941: LD_STRING D16a-Huck-1
27943: PPUSH
27944: CALL_OW 88
27948: GO 27992
// if Baker then
27950: LD_EXP 52
27954: IFFALSE 27970
// Say ( Baker , D16a-Huck-1 ) else
27956: LD_EXP 52
27960: PPUSH
27961: LD_STRING D16a-Huck-1
27963: PPUSH
27964: CALL_OW 88
27968: GO 27992
// if tmp then
27970: LD_VAR 0 3
27974: IFFALSE 27992
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27976: LD_VAR 0 3
27980: PUSH
27981: LD_INT 1
27983: ARRAY
27984: PPUSH
27985: LD_STRING D16a-Sol1-1
27987: PPUSH
27988: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27992: LD_EXP 59
27996: PPUSH
27997: CALL_OW 255
28001: PUSH
28002: LD_INT 8
28004: EQUAL
28005: IFFALSE 28021
// Say ( JMM , D16a-JMM-1 ) else
28007: LD_EXP 36
28011: PPUSH
28012: LD_STRING D16a-JMM-1
28014: PPUSH
28015: CALL_OW 88
28019: GO 28057
// begin Say ( JMM , D16a-JMM-1a ) ;
28021: LD_EXP 36
28025: PPUSH
28026: LD_STRING D16a-JMM-1a
28028: PPUSH
28029: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28033: LD_EXP 59
28037: PPUSH
28038: LD_STRING D16a-Friend-1
28040: PPUSH
28041: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28045: LD_EXP 59
28049: PPUSH
28050: LD_INT 3
28052: PPUSH
28053: CALL_OW 235
// end ; DialogueOff ;
28057: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28061: LD_VAR 0 1
28065: PPUSH
28066: LD_INT 60
28068: PPUSH
28069: LD_INT 95
28071: PPUSH
28072: CALL_OW 116
// end else
28076: GO 28098
// begin DialogueOn ;
28078: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28082: LD_EXP 61
28086: PPUSH
28087: LD_STRING D16c-Pla-
28089: PPUSH
28090: CALL_OW 94
// DialogueOff ;
28094: CALL_OW 7
// end ; end else
28098: GO 28199
// begin wait ( 3 3$00 ) ;
28100: LD_INT 6300
28102: PPUSH
28103: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28107: LD_INT 22
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 34
28119: PUSH
28120: LD_INT 8
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PPUSH
28131: CALL_OW 69
28135: NOT
28136: IFFALSE 28179
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28138: LD_EXP 61
28142: PPUSH
28143: LD_STRING D16b-Pla-1
28145: PPUSH
28146: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28150: LD_EXP 36
28154: PPUSH
28155: LD_STRING D16b-JMM-
28157: PPUSH
28158: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28162: LD_VAR 0 1
28166: PPUSH
28167: LD_INT 60
28169: PPUSH
28170: LD_INT 95
28172: PPUSH
28173: CALL_OW 116
// end else
28177: GO 28199
// begin DialogueOn ;
28179: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28183: LD_EXP 61
28187: PPUSH
28188: LD_STRING D16c-Pla-
28190: PPUSH
28191: CALL_OW 94
// DialogueOff ;
28195: CALL_OW 7
// end ; end ; end ;
28199: PPOPN 3
28201: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28202: LD_EXP 14
28206: PUSH
28207: LD_INT 126000
28209: GREATEREQUAL
28210: PUSH
28211: LD_EXP 23
28215: NOT
28216: AND
28217: PUSH
28218: LD_EXP 71
28222: PPUSH
28223: CALL_OW 302
28227: AND
28228: IFFALSE 28586
28230: GO 28232
28232: DISABLE
28233: LD_INT 0
28235: PPUSH
// begin missionStage = 11 ;
28236: LD_ADDR_EXP 15
28240: PUSH
28241: LD_INT 11
28243: ST_TO_ADDR
// DialogueOn ;
28244: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28248: LD_EXP 71
28252: PPUSH
28253: LD_STRING D9-Roth-1
28255: PPUSH
28256: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28260: LD_EXP 36
28264: PPUSH
28265: LD_STRING D9-JMM-1
28267: PPUSH
28268: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28272: LD_EXP 71
28276: PPUSH
28277: LD_STRING D9-Roth-2
28279: PPUSH
28280: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28284: LD_EXP 71
28288: PPUSH
28289: LD_STRING D9-Roth-2a
28291: PPUSH
28292: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28296: LD_EXP 61
28300: PPUSH
28301: LD_STRING D9-Pla-2
28303: PPUSH
28304: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28308: LD_EXP 71
28312: PPUSH
28313: LD_STRING D9-Roth-3
28315: PPUSH
28316: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28320: LD_EXP 61
28324: PPUSH
28325: LD_STRING D9-Pla-3
28327: PPUSH
28328: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28332: LD_EXP 71
28336: PPUSH
28337: LD_STRING D9-Roth-4
28339: PPUSH
28340: CALL_OW 94
// dec = Query ( Q9 ) ;
28344: LD_ADDR_VAR 0 1
28348: PUSH
28349: LD_STRING Q9
28351: PPUSH
28352: CALL_OW 97
28356: ST_TO_ADDR
// if dec = 1 then
28357: LD_VAR 0 1
28361: PUSH
28362: LD_INT 1
28364: EQUAL
28365: IFFALSE 28379
// SayRadio ( Roth , D9a-Roth-1 ) ;
28367: LD_EXP 71
28371: PPUSH
28372: LD_STRING D9a-Roth-1
28374: PPUSH
28375: CALL_OW 94
// if dec = 2 then
28379: LD_VAR 0 1
28383: PUSH
28384: LD_INT 2
28386: EQUAL
28387: IFFALSE 28413
// begin Say ( JMM , D9b-JMM-1 ) ;
28389: LD_EXP 36
28393: PPUSH
28394: LD_STRING D9b-JMM-1
28396: PPUSH
28397: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28401: LD_EXP 71
28405: PPUSH
28406: LD_STRING D9b-Roth-1
28408: PPUSH
28409: CALL_OW 94
// end ; if dec = 3 then
28413: LD_VAR 0 1
28417: PUSH
28418: LD_INT 3
28420: EQUAL
28421: IFFALSE 28483
// begin Say ( JMM , D9c-JMM-1 ) ;
28423: LD_EXP 36
28427: PPUSH
28428: LD_STRING D9c-JMM-1
28430: PPUSH
28431: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28435: LD_EXP 71
28439: PPUSH
28440: LD_STRING D9c-Roth-1
28442: PPUSH
28443: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28447: LD_EXP 36
28451: PPUSH
28452: LD_STRING D9c-JMM-2
28454: PPUSH
28455: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28459: LD_EXP 71
28463: PPUSH
28464: LD_STRING D9c-Roth-2
28466: PPUSH
28467: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9c-JMM-3
28478: PPUSH
28479: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9c-Roth-3
28490: PPUSH
28491: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28495: LD_EXP 71
28499: PPUSH
28500: LD_STRING D9cont-Roth-1
28502: PPUSH
28503: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28507: LD_EXP 36
28511: PPUSH
28512: LD_STRING D9cont-JMM-1
28514: PPUSH
28515: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28519: LD_EXP 71
28523: PPUSH
28524: LD_STRING D9cont-Roth-2
28526: PPUSH
28527: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28531: LD_EXP 36
28535: PPUSH
28536: LD_STRING D9cont-JMM-2
28538: PPUSH
28539: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28543: LD_EXP 71
28547: PPUSH
28548: LD_STRING D9cont-Roth-3
28550: PPUSH
28551: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28555: LD_EXP 36
28559: PPUSH
28560: LD_STRING D9cont-JMM-3
28562: PPUSH
28563: CALL_OW 88
// DialogueOff ;
28567: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28571: LD_STRING M3
28573: PPUSH
28574: CALL_OW 337
// allianceActive := true ;
28578: LD_ADDR_EXP 31
28582: PUSH
28583: LD_INT 1
28585: ST_TO_ADDR
// end ;
28586: PPOPN 1
28588: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28589: LD_EXP 61
28593: PPUSH
28594: CALL_OW 301
28598: PUSH
28599: LD_EXP 64
28603: PPUSH
28604: CALL_OW 301
28608: AND
28609: PUSH
28610: LD_INT 22
28612: PUSH
28613: LD_INT 3
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: LD_INT 21
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: EMPTY
28627: LIST
28628: LIST
28629: PUSH
28630: LD_INT 50
28632: PUSH
28633: EMPTY
28634: LIST
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: PPUSH
28641: CALL_OW 69
28645: PUSH
28646: LD_INT 7
28648: PUSH
28649: LD_INT 8
28651: PUSH
28652: LD_INT 9
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: LIST
28659: PUSH
28660: LD_OWVAR 67
28664: ARRAY
28665: LESS
28666: AND
28667: IFFALSE 29438
28669: GO 28671
28671: DISABLE
28672: LD_INT 0
28674: PPUSH
28675: PPUSH
28676: PPUSH
28677: PPUSH
// begin MC_Kill ( 1 ) ;
28678: LD_INT 1
28680: PPUSH
28681: CALL 33924 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28685: LD_INT 1
28687: PPUSH
28688: LD_INT 3
28690: PPUSH
28691: LD_INT 1
28693: PPUSH
28694: LD_INT 1
28696: PPUSH
28697: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28701: LD_ADDR_VAR 0 1
28705: PUSH
28706: LD_INT 22
28708: PUSH
28709: LD_INT 3
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: LD_INT 1
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 24
28728: PUSH
28729: LD_INT 900
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: LIST
28740: PPUSH
28741: CALL_OW 69
28745: PUSH
28746: FOR_IN
28747: IFFALSE 28778
// if GetSex ( i ) = sex_male then
28749: LD_VAR 0 1
28753: PPUSH
28754: CALL_OW 258
28758: PUSH
28759: LD_INT 1
28761: EQUAL
28762: IFFALSE 28776
// begin tmp = i ;
28764: LD_ADDR_VAR 0 2
28768: PUSH
28769: LD_VAR 0 1
28773: ST_TO_ADDR
// break ;
28774: GO 28778
// end ;
28776: GO 28746
28778: POP
28779: POP
// if tmp = 0 then
28780: LD_VAR 0 2
28784: PUSH
28785: LD_INT 0
28787: EQUAL
28788: IFFALSE 28842
// begin uc_side = 3 ;
28790: LD_ADDR_OWVAR 20
28794: PUSH
28795: LD_INT 3
28797: ST_TO_ADDR
// uc_nation = 3 ;
28798: LD_ADDR_OWVAR 21
28802: PUSH
28803: LD_INT 3
28805: ST_TO_ADDR
// hc_name =  ;
28806: LD_ADDR_OWVAR 26
28810: PUSH
28811: LD_STRING 
28813: ST_TO_ADDR
// hc_gallery =  ;
28814: LD_ADDR_OWVAR 33
28818: PUSH
28819: LD_STRING 
28821: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28822: LD_INT 1
28824: PPUSH
28825: LD_INT 10
28827: PPUSH
28828: CALL_OW 381
// tmp = CreateHuman ;
28832: LD_ADDR_VAR 0 2
28836: PUSH
28837: CALL_OW 44
28841: ST_TO_ADDR
// end ; DialogueOn ;
28842: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28846: LD_VAR 0 2
28850: PPUSH
28851: LD_STRING DSurrenderRussians-RSol1-1a
28853: PPUSH
28854: CALL_OW 88
// DialogueOff ;
28858: CALL_OW 7
// russianDestroyed := true ;
28862: LD_ADDR_EXP 21
28866: PUSH
28867: LD_INT 1
28869: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28870: LD_INT 22
28872: PUSH
28873: LD_INT 3
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 21
28882: PUSH
28883: LD_INT 1
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PPUSH
28894: CALL_OW 69
28898: PPUSH
28899: CALL_OW 122
// wait ( 0 0$1 ) ;
28903: LD_INT 35
28905: PPUSH
28906: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28910: LD_INT 22
28912: PUSH
28913: LD_INT 3
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 21
28922: PUSH
28923: LD_INT 1
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PPUSH
28934: CALL_OW 69
28938: PPUSH
28939: LD_INT 25
28941: PPUSH
28942: CALL_OW 173
// wait ( 0 0$10 ) ;
28946: LD_INT 350
28948: PPUSH
28949: CALL_OW 67
// PrepareOmarInvasion ;
28953: CALL 13611 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28957: LD_ADDR_VAR 0 2
28961: PUSH
28962: LD_EXP 89
28966: PPUSH
28967: CALL_OW 250
28971: PUSH
28972: LD_EXP 89
28976: PPUSH
28977: CALL_OW 251
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28986: LD_VAR 0 2
28990: PUSH
28991: LD_INT 1
28993: ARRAY
28994: PPUSH
28995: LD_VAR 0 2
28999: PUSH
29000: LD_INT 2
29002: ARRAY
29003: PPUSH
29004: LD_INT 1
29006: PPUSH
29007: LD_INT 8
29009: NEG
29010: PPUSH
29011: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29015: LD_EXP 89
29019: PPUSH
29020: CALL_OW 87
// DialogueOn ;
29024: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29028: LD_EXP 36
29032: PPUSH
29033: LD_STRING D19-JMM-1
29035: PPUSH
29036: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29040: LD_ADDR_VAR 0 3
29044: PUSH
29045: LD_INT 22
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 26
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 2
29067: PUSH
29068: LD_INT 25
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 25
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 25
29090: PUSH
29091: LD_INT 3
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 25
29100: PUSH
29101: LD_INT 4
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 25
29110: PUSH
29111: LD_INT 5
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 25
29120: PUSH
29121: LD_INT 8
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: LIST
29141: PPUSH
29142: CALL_OW 69
29146: PUSH
29147: LD_EXP 36
29151: PUSH
29152: LD_EXP 37
29156: PUSH
29157: LD_EXP 38
29161: PUSH
29162: LD_EXP 39
29166: PUSH
29167: LD_EXP 40
29171: PUSH
29172: LD_EXP 41
29176: PUSH
29177: LD_EXP 42
29181: PUSH
29182: LD_EXP 43
29186: PUSH
29187: LD_EXP 44
29191: PUSH
29192: LD_EXP 45
29196: PUSH
29197: LD_EXP 46
29201: PUSH
29202: LD_EXP 47
29206: PUSH
29207: LD_EXP 48
29211: PUSH
29212: LD_EXP 49
29216: PUSH
29217: LD_EXP 50
29221: PUSH
29222: LD_EXP 51
29226: PUSH
29227: LD_EXP 52
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: DIFF
29251: ST_TO_ADDR
// if tmp2 then
29252: LD_VAR 0 3
29256: IFFALSE 29274
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29258: LD_VAR 0 3
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PPUSH
29267: LD_STRING D19-Sol1-1
29269: PPUSH
29270: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29274: LD_EXP 36
29278: PPUSH
29279: LD_STRING D19-JMM-2
29281: PPUSH
29282: CALL_OW 88
// DialogueOff ;
29286: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29290: LD_VAR 0 2
29294: PUSH
29295: LD_INT 1
29297: ARRAY
29298: PPUSH
29299: LD_VAR 0 2
29303: PUSH
29304: LD_INT 2
29306: ARRAY
29307: PPUSH
29308: LD_INT 1
29310: PPUSH
29311: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29315: LD_STRING M5
29317: PPUSH
29318: CALL_OW 337
// omarOnMotherLode := false ;
29322: LD_ADDR_VAR 0 4
29326: PUSH
29327: LD_INT 0
29329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29330: LD_INT 35
29332: PPUSH
29333: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29337: LD_EXP 89
29341: PPUSH
29342: LD_INT 215
29344: PPUSH
29345: LD_INT 100
29347: PPUSH
29348: CALL_OW 297
29352: PUSH
29353: LD_INT 10
29355: LESS
29356: PUSH
29357: LD_VAR 0 4
29361: NOT
29362: AND
29363: IFFALSE 29397
// begin omarOnMotherLode := true ;
29365: LD_ADDR_VAR 0 4
29369: PUSH
29370: LD_INT 1
29372: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29373: LD_EXP 36
29377: PPUSH
29378: LD_STRING D19b-JMM-1
29380: PPUSH
29381: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29385: LD_EXP 89
29389: PPUSH
29390: LD_STRING DOmarContam-Omar-1
29392: PPUSH
29393: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29397: LD_EXP 89
29401: PPUSH
29402: CALL_OW 301
29406: IFFALSE 29330
// Say ( JMM , D19a-JMM-1 ) ;
29408: LD_EXP 36
29412: PPUSH
29413: LD_STRING D19a-JMM-1
29415: PPUSH
29416: CALL_OW 88
// if Heike then
29420: LD_EXP 90
29424: IFFALSE 29438
// Say ( Heike , D19a-Hke-1 ) ;
29426: LD_EXP 90
29430: PPUSH
29431: LD_STRING D19a-Hke-1
29433: PPUSH
29434: CALL_OW 88
// end ;
29438: PPOPN 4
29440: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29441: LD_INT 22
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 21
29453: PUSH
29454: LD_INT 1
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PPUSH
29465: CALL_OW 69
29469: PUSH
29470: LD_EXP 21
29474: AND
29475: IFFALSE 29543
29477: GO 29479
29479: DISABLE
29480: LD_INT 0
29482: PPUSH
29483: PPUSH
// begin enable ;
29484: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29485: LD_ADDR_VAR 0 2
29489: PUSH
29490: LD_INT 25
29492: PPUSH
29493: LD_INT 22
29495: PUSH
29496: LD_INT 3
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PPUSH
29503: CALL_OW 70
29507: ST_TO_ADDR
// if not tmp then
29508: LD_VAR 0 2
29512: NOT
29513: IFFALSE 29517
// exit ;
29515: GO 29543
// for i in tmp do
29517: LD_ADDR_VAR 0 1
29521: PUSH
29522: LD_VAR 0 2
29526: PUSH
29527: FOR_IN
29528: IFFALSE 29541
// RemoveUnit ( i ) ;
29530: LD_VAR 0 1
29534: PPUSH
29535: CALL_OW 64
29539: GO 29527
29541: POP
29542: POP
// end ;
29543: PPOPN 2
29545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29546: LD_INT 22
29548: PUSH
29549: LD_INT 7
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 21
29558: PUSH
29559: LD_INT 1
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PPUSH
29570: CALL_OW 69
29574: PUSH
29575: LD_INT 6
29577: LESS
29578: IFFALSE 30029
29580: GO 29582
29582: DISABLE
29583: LD_INT 0
29585: PPUSH
29586: PPUSH
// begin MC_Kill ( 1 ) ;
29587: LD_INT 1
29589: PPUSH
29590: CALL 33924 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29594: LD_INT 7
29596: PPUSH
29597: LD_INT 1
29599: PPUSH
29600: LD_INT 1
29602: PPUSH
29603: LD_INT 1
29605: PPUSH
29606: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29610: LD_ADDR_VAR 0 1
29614: PUSH
29615: LD_INT 22
29617: PUSH
29618: LD_INT 7
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 26
29627: PUSH
29628: LD_INT 1
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PPUSH
29639: CALL_OW 69
29643: PUSH
29644: LD_EXP 71
29648: DIFF
29649: ST_TO_ADDR
// if tmp then
29650: LD_VAR 0 1
29654: IFFALSE 29672
// tmp := tmp [ 1 ] else
29656: LD_ADDR_VAR 0 1
29660: PUSH
29661: LD_VAR 0 1
29665: PUSH
29666: LD_INT 1
29668: ARRAY
29669: ST_TO_ADDR
29670: GO 29708
// begin uc_side := 7 ;
29672: LD_ADDR_OWVAR 20
29676: PUSH
29677: LD_INT 7
29679: ST_TO_ADDR
// uc_nation := 1 ;
29680: LD_ADDR_OWVAR 21
29684: PUSH
29685: LD_INT 1
29687: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29688: LD_INT 1
29690: PPUSH
29691: LD_INT 8
29693: PPUSH
29694: CALL_OW 384
// tmp := CreateHuman ;
29698: LD_ADDR_VAR 0 1
29702: PUSH
29703: CALL_OW 44
29707: ST_TO_ADDR
// end ; DialogueOn ;
29708: CALL_OW 6
// if IsOK ( Roth ) then
29712: LD_EXP 71
29716: PPUSH
29717: CALL_OW 302
29721: IFFALSE 29735
// Say ( JMM , DAb-JMM-1 ) ;
29723: LD_EXP 36
29727: PPUSH
29728: LD_STRING DAb-JMM-1
29730: PPUSH
29731: CALL_OW 88
// if IsOK ( Roth ) then
29735: LD_EXP 71
29739: PPUSH
29740: CALL_OW 302
29744: IFFALSE 29768
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29746: LD_EXP 71
29750: PPUSH
29751: LD_STRING DSurrenderAlliance-Roth-1
29753: PPUSH
29754: CALL_OW 88
// RothCaptured := true ;
29758: LD_ADDR_EXP 33
29762: PUSH
29763: LD_INT 1
29765: ST_TO_ADDR
// end else
29766: GO 29780
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29768: LD_VAR 0 1
29772: PPUSH
29773: LD_STRING DSurrenderAlliance-Sci1-1
29775: PPUSH
29776: CALL_OW 88
// DialogueOff ;
29780: CALL_OW 7
// allianceDestroyed := true ;
29784: LD_ADDR_EXP 23
29788: PUSH
29789: LD_INT 1
29791: ST_TO_ADDR
// if trueAmericans then
29792: LD_EXP 35
29796: IFFALSE 29872
// begin if trueAmericans = 1 then
29798: LD_EXP 35
29802: PUSH
29803: LD_INT 1
29805: EQUAL
29806: IFFALSE 29822
// Say ( JMM , DAb-JMM-1a ) else
29808: LD_EXP 36
29812: PPUSH
29813: LD_STRING DAb-JMM-1a
29815: PPUSH
29816: CALL_OW 88
29820: GO 29834
// Say ( JMM , DAb-JMM-1b ) ;
29822: LD_EXP 36
29826: PPUSH
29827: LD_STRING DAb-JMM-1b
29829: PPUSH
29830: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29834: LD_EXP 35
29838: PPUSH
29839: CALL_OW 87
// for i in trueAmericans do
29843: LD_ADDR_VAR 0 2
29847: PUSH
29848: LD_EXP 35
29852: PUSH
29853: FOR_IN
29854: IFFALSE 29870
// SetSide ( i , 1 ) ;
29856: LD_VAR 0 2
29860: PPUSH
29861: LD_INT 1
29863: PPUSH
29864: CALL_OW 235
29868: GO 29853
29870: POP
29871: POP
// end ; repeat wait ( 0 0$1 ) ;
29872: LD_INT 35
29874: PPUSH
29875: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29879: LD_ADDR_VAR 0 2
29883: PUSH
29884: LD_INT 22
29886: PUSH
29887: LD_INT 7
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 21
29896: PUSH
29897: LD_INT 1
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PPUSH
29908: CALL_OW 69
29912: PUSH
29913: FOR_IN
29914: IFFALSE 29996
// begin if IsInUnit ( i ) then
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL_OW 310
29925: IFFALSE 29936
// ComExitBuilding ( i ) ;
29927: LD_VAR 0 2
29931: PPUSH
29932: CALL_OW 122
// if IsDriver ( i ) then
29936: LD_VAR 0 2
29940: PPUSH
29941: CALL 102979 0 1
29945: IFFALSE 29956
// ComExitVehicle ( i ) ;
29947: LD_VAR 0 2
29951: PPUSH
29952: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29956: LD_VAR 0 2
29960: PPUSH
29961: LD_INT 26
29963: PPUSH
29964: CALL_OW 308
29968: NOT
29969: IFFALSE 29985
// AddComMoveToArea ( i , allianceEscapeArea ) else
29971: LD_VAR 0 2
29975: PPUSH
29976: LD_INT 26
29978: PPUSH
29979: CALL_OW 173
29983: GO 29994
// RemoveUnit ( i ) ;
29985: LD_VAR 0 2
29989: PPUSH
29990: CALL_OW 64
// end ;
29994: GO 29913
29996: POP
29997: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29998: LD_INT 22
30000: PUSH
30001: LD_INT 7
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 21
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PPUSH
30022: CALL_OW 69
30026: NOT
30027: IFFALSE 29872
// end ;
30029: PPOPN 2
30031: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30032: LD_INT 0
30034: PPUSH
30035: PPUSH
// if not unit then
30036: LD_VAR 0 1
30040: NOT
30041: IFFALSE 30045
// exit ;
30043: GO 31543
// DoNotAttack ( 7 , unit ) ;
30045: LD_INT 7
30047: PPUSH
30048: LD_VAR 0 1
30052: PPUSH
30053: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30057: LD_VAR 0 1
30061: PPUSH
30062: LD_INT 260
30064: PPUSH
30065: LD_INT 235
30067: PPUSH
30068: LD_INT 3
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: CALL_OW 483
// SetSide ( unit , 4 ) ;
30078: LD_VAR 0 1
30082: PPUSH
30083: LD_INT 4
30085: PPUSH
30086: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30090: LD_ADDR_EXP 34
30094: PUSH
30095: LD_EXP 34
30099: PUSH
30100: LD_INT 1
30102: PLUS
30103: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30104: LD_INT 70
30106: PPUSH
30107: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30111: LD_INT 260
30113: PPUSH
30114: LD_INT 235
30116: PPUSH
30117: LD_INT 1
30119: PPUSH
30120: LD_INT 8
30122: NEG
30123: PPUSH
30124: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30128: LD_VAR 0 1
30132: PPUSH
30133: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30137: LD_VAR 0 1
30141: PPUSH
30142: LD_EXP 71
30146: PPUSH
30147: CALL_OW 119
// DialogueOn ;
30151: CALL_OW 6
// case unit of JMM :
30155: LD_VAR 0 1
30159: PUSH
30160: LD_EXP 36
30164: DOUBLE
30165: EQUAL
30166: IFTRUE 30170
30168: GO 30185
30170: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30171: LD_EXP 36
30175: PPUSH
30176: LD_STRING DA1-JMM-1
30178: PPUSH
30179: CALL_OW 91
30183: GO 30627
30185: LD_EXP 37
30189: DOUBLE
30190: EQUAL
30191: IFTRUE 30195
30193: GO 30210
30195: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30196: LD_EXP 37
30200: PPUSH
30201: LD_STRING DA1-Joan-1
30203: PPUSH
30204: CALL_OW 91
30208: GO 30627
30210: LD_EXP 39
30214: DOUBLE
30215: EQUAL
30216: IFTRUE 30220
30218: GO 30235
30220: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30221: LD_EXP 39
30225: PPUSH
30226: LD_STRING DA1-Lisa-1
30228: PPUSH
30229: CALL_OW 91
30233: GO 30627
30235: LD_EXP 40
30239: DOUBLE
30240: EQUAL
30241: IFTRUE 30245
30243: GO 30260
30245: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30246: LD_EXP 40
30250: PPUSH
30251: LD_STRING DA1-Don-1
30253: PPUSH
30254: CALL_OW 91
30258: GO 30627
30260: LD_EXP 47
30264: DOUBLE
30265: EQUAL
30266: IFTRUE 30270
30268: GO 30285
30270: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30271: LD_EXP 47
30275: PPUSH
30276: LD_STRING DA1-Corn-1
30278: PPUSH
30279: CALL_OW 91
30283: GO 30627
30285: LD_EXP 43
30289: DOUBLE
30290: EQUAL
30291: IFTRUE 30295
30293: GO 30310
30295: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30296: LD_EXP 43
30300: PPUSH
30301: LD_STRING DA1-Den-1
30303: PPUSH
30304: CALL_OW 91
30308: GO 30627
30310: LD_EXP 41
30314: DOUBLE
30315: EQUAL
30316: IFTRUE 30320
30318: GO 30335
30320: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30321: LD_EXP 41
30325: PPUSH
30326: LD_STRING DA1-Bobby-1
30328: PPUSH
30329: CALL_OW 91
30333: GO 30627
30335: LD_EXP 45
30339: DOUBLE
30340: EQUAL
30341: IFTRUE 30345
30343: GO 30360
30345: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30346: LD_EXP 45
30350: PPUSH
30351: LD_STRING DA1-Glad-1
30353: PPUSH
30354: CALL_OW 91
30358: GO 30627
30360: LD_EXP 42
30364: DOUBLE
30365: EQUAL
30366: IFTRUE 30370
30368: GO 30385
30370: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30371: LD_EXP 42
30375: PPUSH
30376: LD_STRING DA1-Cyrus-1
30378: PPUSH
30379: CALL_OW 91
30383: GO 30627
30385: LD_EXP 38
30389: DOUBLE
30390: EQUAL
30391: IFTRUE 30395
30393: GO 30410
30395: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30396: LD_EXP 38
30400: PPUSH
30401: LD_STRING DA1-Huck-1
30403: PPUSH
30404: CALL_OW 91
30408: GO 30627
30410: LD_EXP 52
30414: DOUBLE
30415: EQUAL
30416: IFTRUE 30420
30418: GO 30435
30420: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30421: LD_EXP 52
30425: PPUSH
30426: LD_STRING DA1-Huck-1
30428: PPUSH
30429: CALL_OW 91
30433: GO 30627
30435: LD_EXP 44
30439: DOUBLE
30440: EQUAL
30441: IFTRUE 30445
30443: GO 30460
30445: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30446: LD_EXP 44
30450: PPUSH
30451: LD_STRING DA1-Brown-1
30453: PPUSH
30454: CALL_OW 91
30458: GO 30627
30460: LD_EXP 48
30464: DOUBLE
30465: EQUAL
30466: IFTRUE 30470
30468: GO 30485
30470: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30471: LD_EXP 48
30475: PPUSH
30476: LD_STRING DA1-Gary-1
30478: PPUSH
30479: CALL_OW 91
30483: GO 30627
30485: LD_EXP 51
30489: DOUBLE
30490: EQUAL
30491: IFTRUE 30495
30493: GO 30510
30495: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30496: LD_EXP 51
30500: PPUSH
30501: LD_STRING DA1-Con-1
30503: PPUSH
30504: CALL_OW 91
30508: GO 30627
30510: LD_EXP 57
30514: DOUBLE
30515: EQUAL
30516: IFTRUE 30520
30518: GO 30535
30520: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30521: LD_EXP 57
30525: PPUSH
30526: LD_STRING DA1-Kurt-1
30528: PPUSH
30529: CALL_OW 91
30533: GO 30627
30535: LD_EXP 50
30539: DOUBLE
30540: EQUAL
30541: IFTRUE 30545
30543: GO 30560
30545: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30546: LD_EXP 50
30550: PPUSH
30551: LD_STRING DA1-Yam-1
30553: PPUSH
30554: CALL_OW 91
30558: GO 30627
30560: LD_EXP 49
30564: DOUBLE
30565: EQUAL
30566: IFTRUE 30570
30568: GO 30585
30570: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30571: LD_EXP 49
30575: PPUSH
30576: LD_STRING DA1-Frank-1
30578: PPUSH
30579: CALL_OW 91
30583: GO 30627
30585: POP
// begin if GetSex ( unit ) = sex_male then
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 258
30595: PUSH
30596: LD_INT 1
30598: EQUAL
30599: IFFALSE 30615
// ForceSay ( unit , DA1-Sol1-1 ) else
30601: LD_VAR 0 1
30605: PPUSH
30606: LD_STRING DA1-Sol1-1
30608: PPUSH
30609: CALL_OW 91
30613: GO 30627
// ForceSay ( unit , DA1-FSol1-1 ) ;
30615: LD_VAR 0 1
30619: PPUSH
30620: LD_STRING DA1-FSol1-1
30622: PPUSH
30623: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30627: LD_EXP 71
30631: PPUSH
30632: LD_STRING DA-Roth-1
30634: PPUSH
30635: CALL_OW 88
// if capturedUnit = 1 then
30639: LD_EXP 34
30643: PUSH
30644: LD_INT 1
30646: EQUAL
30647: IFFALSE 30675
// begin Say ( Simms , DA-Sim-1 ) ;
30649: LD_EXP 72
30653: PPUSH
30654: LD_STRING DA-Sim-1
30656: PPUSH
30657: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30661: LD_EXP 71
30665: PPUSH
30666: LD_STRING DA-Roth-2
30668: PPUSH
30669: CALL_OW 88
// end else
30673: GO 30687
// Say ( Simms , DA-Sim-2 ) ;
30675: LD_EXP 72
30679: PPUSH
30680: LD_STRING DA-Sim-2
30682: PPUSH
30683: CALL_OW 88
// case unit of JMM :
30687: LD_VAR 0 1
30691: PUSH
30692: LD_EXP 36
30696: DOUBLE
30697: EQUAL
30698: IFTRUE 30702
30700: GO 30717
30702: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30703: LD_EXP 36
30707: PPUSH
30708: LD_STRING DA1-JMM-1a
30710: PPUSH
30711: CALL_OW 91
30715: GO 31224
30717: LD_EXP 37
30721: DOUBLE
30722: EQUAL
30723: IFTRUE 30727
30725: GO 30742
30727: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30728: LD_EXP 37
30732: PPUSH
30733: LD_STRING DA1-Joan-1a
30735: PPUSH
30736: CALL_OW 91
30740: GO 31224
30742: LD_EXP 39
30746: DOUBLE
30747: EQUAL
30748: IFTRUE 30752
30750: GO 30767
30752: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30753: LD_EXP 39
30757: PPUSH
30758: LD_STRING DA1-Lisa-1a
30760: PPUSH
30761: CALL_OW 91
30765: GO 31224
30767: LD_EXP 40
30771: DOUBLE
30772: EQUAL
30773: IFTRUE 30777
30775: GO 30792
30777: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30778: LD_EXP 40
30782: PPUSH
30783: LD_STRING DA1-Don-1a
30785: PPUSH
30786: CALL_OW 91
30790: GO 31224
30792: LD_EXP 47
30796: DOUBLE
30797: EQUAL
30798: IFTRUE 30802
30800: GO 30817
30802: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30803: LD_EXP 47
30807: PPUSH
30808: LD_STRING DA1-Corn-1a
30810: PPUSH
30811: CALL_OW 91
30815: GO 31224
30817: LD_EXP 43
30821: DOUBLE
30822: EQUAL
30823: IFTRUE 30827
30825: GO 30842
30827: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30828: LD_EXP 43
30832: PPUSH
30833: LD_STRING DA1-Den-1a
30835: PPUSH
30836: CALL_OW 91
30840: GO 31224
30842: LD_EXP 41
30846: DOUBLE
30847: EQUAL
30848: IFTRUE 30852
30850: GO 30867
30852: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30853: LD_EXP 41
30857: PPUSH
30858: LD_STRING DA1-Bobby-1a
30860: PPUSH
30861: CALL_OW 91
30865: GO 31224
30867: LD_EXP 45
30871: DOUBLE
30872: EQUAL
30873: IFTRUE 30877
30875: GO 30892
30877: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30878: LD_EXP 45
30882: PPUSH
30883: LD_STRING DA1-Glad-1a
30885: PPUSH
30886: CALL_OW 91
30890: GO 31224
30892: LD_EXP 42
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30902
30900: GO 30917
30902: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30903: LD_EXP 42
30907: PPUSH
30908: LD_STRING DA1-Cyrus-1a
30910: PPUSH
30911: CALL_OW 91
30915: GO 31224
30917: LD_EXP 38
30921: DOUBLE
30922: EQUAL
30923: IFTRUE 30927
30925: GO 30942
30927: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30928: LD_EXP 38
30932: PPUSH
30933: LD_STRING DA1-Huck-1a
30935: PPUSH
30936: CALL_OW 91
30940: GO 31224
30942: LD_EXP 52
30946: DOUBLE
30947: EQUAL
30948: IFTRUE 30952
30950: GO 30967
30952: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30953: LD_EXP 52
30957: PPUSH
30958: LD_STRING DA1-Huck-1a
30960: PPUSH
30961: CALL_OW 91
30965: GO 31224
30967: LD_EXP 44
30971: DOUBLE
30972: EQUAL
30973: IFTRUE 30977
30975: GO 30992
30977: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30978: LD_EXP 44
30982: PPUSH
30983: LD_STRING DA1-Brown-1a
30985: PPUSH
30986: CALL_OW 91
30990: GO 31224
30992: LD_EXP 48
30996: DOUBLE
30997: EQUAL
30998: IFTRUE 31002
31000: GO 31017
31002: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31003: LD_EXP 48
31007: PPUSH
31008: LD_STRING DA1-Gary-1a
31010: PPUSH
31011: CALL_OW 91
31015: GO 31224
31017: LD_EXP 51
31021: DOUBLE
31022: EQUAL
31023: IFTRUE 31027
31025: GO 31042
31027: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31028: LD_EXP 51
31032: PPUSH
31033: LD_STRING DA1-Con-1a
31035: PPUSH
31036: CALL_OW 91
31040: GO 31224
31042: LD_EXP 57
31046: DOUBLE
31047: EQUAL
31048: IFTRUE 31052
31050: GO 31067
31052: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31053: LD_EXP 57
31057: PPUSH
31058: LD_STRING DA1-Kurt-1a
31060: PPUSH
31061: CALL_OW 91
31065: GO 31224
31067: LD_EXP 50
31071: DOUBLE
31072: EQUAL
31073: IFTRUE 31077
31075: GO 31092
31077: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31078: LD_EXP 50
31082: PPUSH
31083: LD_STRING DA1-Yam-1a
31085: PPUSH
31086: CALL_OW 91
31090: GO 31224
31092: LD_EXP 49
31096: DOUBLE
31097: EQUAL
31098: IFTRUE 31102
31100: GO 31117
31102: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31103: LD_EXP 49
31107: PPUSH
31108: LD_STRING DA1-Frank-1a
31110: PPUSH
31111: CALL_OW 91
31115: GO 31224
31117: POP
// begin join := rand ( 0 , 1 ) ;
31118: LD_ADDR_VAR 0 3
31122: PUSH
31123: LD_INT 0
31125: PPUSH
31126: LD_INT 1
31128: PPUSH
31129: CALL_OW 12
31133: ST_TO_ADDR
// if join then
31134: LD_VAR 0 3
31138: IFFALSE 31183
// begin if GetSex ( unit ) = sex_male then
31140: LD_VAR 0 1
31144: PPUSH
31145: CALL_OW 258
31149: PUSH
31150: LD_INT 1
31152: EQUAL
31153: IFFALSE 31169
// ForceSay ( unit , DA1-Sol1-1b ) else
31155: LD_VAR 0 1
31159: PPUSH
31160: LD_STRING DA1-Sol1-1b
31162: PPUSH
31163: CALL_OW 91
31167: GO 31181
// ForceSay ( unit , DA1-FSol1-1b ) ;
31169: LD_VAR 0 1
31173: PPUSH
31174: LD_STRING DA1-FSol1-1b
31176: PPUSH
31177: CALL_OW 91
// end else
31181: GO 31224
// begin if GetSex ( unit ) = sex_male then
31183: LD_VAR 0 1
31187: PPUSH
31188: CALL_OW 258
31192: PUSH
31193: LD_INT 1
31195: EQUAL
31196: IFFALSE 31212
// ForceSay ( unit , DA1-Sol1-1a ) else
31198: LD_VAR 0 1
31202: PPUSH
31203: LD_STRING DA1-Sol1-1a
31205: PPUSH
31206: CALL_OW 91
31210: GO 31224
// ForceSay ( unit , DA1-FSol1-1a ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_STRING DA1-FSol1-1a
31219: PPUSH
31220: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31224: LD_VAR 0 1
31228: PUSH
31229: LD_EXP 36
31233: EQUAL
31234: IFFALSE 31245
// begin YouLost ( JMMCaptured ) ;
31236: LD_STRING JMMCaptured
31238: PPUSH
31239: CALL_OW 104
// exit ;
31243: GO 31543
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31245: LD_VAR 0 1
31249: PUSH
31250: LD_EXP 40
31254: PUSH
31255: LD_EXP 43
31259: PUSH
31260: LD_EXP 41
31264: PUSH
31265: LD_EXP 38
31269: PUSH
31270: LD_EXP 52
31274: PUSH
31275: LD_EXP 44
31279: PUSH
31280: LD_EXP 50
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: IN
31294: PUSH
31295: LD_VAR 0 3
31299: OR
31300: IFFALSE 31399
// begin Say ( Roth , DA-Roth-3 ) ;
31302: LD_EXP 71
31306: PPUSH
31307: LD_STRING DA-Roth-3
31309: PPUSH
31310: CALL_OW 88
// SetSide ( unit , 7 ) ;
31314: LD_VAR 0 1
31318: PPUSH
31319: LD_INT 7
31321: PPUSH
31322: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31326: LD_ADDR_EXP 99
31330: PUSH
31331: LD_EXP 99
31335: PPUSH
31336: LD_INT 1
31338: PPUSH
31339: LD_EXP 99
31343: PUSH
31344: LD_INT 1
31346: ARRAY
31347: PUSH
31348: LD_VAR 0 1
31352: ADD
31353: PPUSH
31354: CALL_OW 1
31358: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31359: LD_INT 260
31361: PPUSH
31362: LD_INT 235
31364: PPUSH
31365: LD_INT 1
31367: PPUSH
31368: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31372: LD_VAR 0 1
31376: PPUSH
31377: LD_INT 1000
31379: PPUSH
31380: CALL_OW 234
// DialogueOff ;
31384: CALL_OW 7
// ComFree ( unit ) ;
31388: LD_VAR 0 1
31392: PPUSH
31393: CALL_OW 139
// end else
31397: GO 31480
// begin Say ( Roth , DA-Roth-3a ) ;
31399: LD_EXP 71
31403: PPUSH
31404: LD_STRING DA-Roth-3a
31406: PPUSH
31407: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31411: LD_ADDR_EXP 35
31415: PUSH
31416: LD_EXP 35
31420: PUSH
31421: LD_VAR 0 1
31425: ADD
31426: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31427: LD_INT 260
31429: PPUSH
31430: LD_INT 235
31432: PPUSH
31433: LD_INT 1
31435: PPUSH
31436: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31440: LD_VAR 0 1
31444: PPUSH
31445: LD_INT 1000
31447: PPUSH
31448: CALL_OW 234
// DialogueOff ;
31452: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31456: LD_VAR 0 1
31460: PPUSH
31461: LD_INT 272
31463: PPUSH
31464: LD_INT 254
31466: PPUSH
31467: CALL_OW 111
// AddComHold ( unit ) ;
31471: LD_VAR 0 1
31475: PPUSH
31476: CALL_OW 200
// end ; if capturedUnit = 1 then
31480: LD_EXP 34
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31543
// begin DialogueOn ;
31490: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31494: LD_EXP 36
31498: PPUSH
31499: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31503: LD_EXP 36
31507: PPUSH
31508: LD_STRING DAa-JMM-1
31510: PPUSH
31511: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31515: LD_EXP 36
31519: PPUSH
31520: LD_STRING DAa-JMM-1a
31522: PPUSH
31523: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31527: LD_EXP 36
31531: PPUSH
31532: LD_STRING DAa-JMM-1b
31534: PPUSH
31535: CALL_OW 88
// DialogueOff ;
31539: CALL_OW 7
// end ; end ;
31543: LD_VAR 0 2
31547: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31548: LD_EXP 15
31552: PUSH
31553: LD_INT 13
31555: GREATEREQUAL
31556: PUSH
31557: LD_INT 22
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 21
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PPUSH
31581: CALL_OW 69
31585: PUSH
31586: LD_INT 0
31588: EQUAL
31589: AND
31590: PUSH
31591: LD_INT 22
31593: PUSH
31594: LD_INT 2
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 21
31603: PUSH
31604: LD_INT 2
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 50
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: PPUSH
31622: CALL_OW 69
31626: PUSH
31627: LD_INT 0
31629: EQUAL
31630: AND
31631: PUSH
31632: LD_EXP 21
31636: AND
31637: PUSH
31638: LD_EXP 22
31642: AND
31643: PUSH
31644: LD_EXP 23
31648: AND
31649: IFFALSE 32130
31651: GO 31653
31653: DISABLE
// begin DialogueOn ;
31654: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31658: LD_EXP 36
31662: PPUSH
31663: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31667: LD_EXP 36
31671: PPUSH
31672: LD_STRING D20-JMM-1
31674: PPUSH
31675: CALL_OW 88
// if IsOK ( Joan ) then
31679: LD_EXP 37
31683: PPUSH
31684: CALL_OW 302
31688: IFFALSE 31702
// Say ( Joan , D20-Joan-1 ) ;
31690: LD_EXP 37
31694: PPUSH
31695: LD_STRING D20-Joan-1
31697: PPUSH
31698: CALL_OW 88
// if IsOk ( Lisa ) then
31702: LD_EXP 39
31706: PPUSH
31707: CALL_OW 302
31711: IFFALSE 31725
// Say ( Lisa , D20-Lisa-1 ) ;
31713: LD_EXP 39
31717: PPUSH
31718: LD_STRING D20-Lisa-1
31720: PPUSH
31721: CALL_OW 88
// if IsOk ( Donaldson ) then
31725: LD_EXP 40
31729: PPUSH
31730: CALL_OW 302
31734: IFFALSE 31748
// Say ( Donaldson , D20-Don-1 ) ;
31736: LD_EXP 40
31740: PPUSH
31741: LD_STRING D20-Don-1
31743: PPUSH
31744: CALL_OW 88
// if IsOK ( Cornel ) then
31748: LD_EXP 47
31752: PPUSH
31753: CALL_OW 302
31757: IFFALSE 31771
// Say ( Cornel , D20-Corn-1 ) ;
31759: LD_EXP 47
31763: PPUSH
31764: LD_STRING D20-Corn-1
31766: PPUSH
31767: CALL_OW 88
// if IsOk ( Denis ) then
31771: LD_EXP 43
31775: PPUSH
31776: CALL_OW 302
31780: IFFALSE 31794
// Say ( Denis , D20-Den-1 ) ;
31782: LD_EXP 43
31786: PPUSH
31787: LD_STRING D20-Den-1
31789: PPUSH
31790: CALL_OW 88
// if IsOk ( Bobby ) then
31794: LD_EXP 41
31798: PPUSH
31799: CALL_OW 302
31803: IFFALSE 31817
// Say ( Bobby , D20-Bobby-1 ) ;
31805: LD_EXP 41
31809: PPUSH
31810: LD_STRING D20-Bobby-1
31812: PPUSH
31813: CALL_OW 88
// if IsOk ( Gladstone ) then
31817: LD_EXP 45
31821: PPUSH
31822: CALL_OW 302
31826: IFFALSE 31840
// Say ( Gladstone , D20-Glad-1 ) ;
31828: LD_EXP 45
31832: PPUSH
31833: LD_STRING D20-Glad-1
31835: PPUSH
31836: CALL_OW 88
// if IsOk ( Cyrus ) then
31840: LD_EXP 42
31844: PPUSH
31845: CALL_OW 302
31849: IFFALSE 31863
// Say ( Cyrus , D20-Cyrus-1 ) ;
31851: LD_EXP 42
31855: PPUSH
31856: LD_STRING D20-Cyrus-1
31858: PPUSH
31859: CALL_OW 88
// if IsOk ( Stevens ) then
31863: LD_EXP 38
31867: PPUSH
31868: CALL_OW 302
31872: IFFALSE 31886
// Say ( Stevens , D20-Huck-1 ) ;
31874: LD_EXP 38
31878: PPUSH
31879: LD_STRING D20-Huck-1
31881: PPUSH
31882: CALL_OW 88
// if IsOk ( Brown ) then
31886: LD_EXP 44
31890: PPUSH
31891: CALL_OW 302
31895: IFFALSE 31909
// Say ( Brown , D20-Brown-1 ) ;
31897: LD_EXP 44
31901: PPUSH
31902: LD_STRING D20-Brown-1
31904: PPUSH
31905: CALL_OW 88
// if IsOk ( Gary ) then
31909: LD_EXP 48
31913: PPUSH
31914: CALL_OW 302
31918: IFFALSE 31932
// Say ( Gary , D20-Gary-1 ) ;
31920: LD_EXP 48
31924: PPUSH
31925: LD_STRING D20-Gary-1
31927: PPUSH
31928: CALL_OW 88
// if IsOk ( Connie ) then
31932: LD_EXP 51
31936: PPUSH
31937: CALL_OW 302
31941: IFFALSE 31955
// Say ( Connie , D20-Con-1 ) ;
31943: LD_EXP 51
31947: PPUSH
31948: LD_STRING D20-Con-1
31950: PPUSH
31951: CALL_OW 88
// if IsOk ( Kurt ) then
31955: LD_EXP 57
31959: PPUSH
31960: CALL_OW 302
31964: IFFALSE 31978
// Say ( Kurt , D20-Kurt-1 ) ;
31966: LD_EXP 57
31970: PPUSH
31971: LD_STRING D20-Kurt-1
31973: PPUSH
31974: CALL_OW 88
// if IsOk ( Kikuchi ) then
31978: LD_EXP 50
31982: PPUSH
31983: CALL_OW 302
31987: IFFALSE 32001
// Say ( Kikuchi , D20-Yam-1 ) ;
31989: LD_EXP 50
31993: PPUSH
31994: LD_STRING D20-Yam-1
31996: PPUSH
31997: CALL_OW 88
// if IsOk ( Frank ) then
32001: LD_EXP 49
32005: PPUSH
32006: CALL_OW 302
32010: IFFALSE 32024
// Say ( Frank , D20-Frank-1 ) ;
32012: LD_EXP 49
32016: PPUSH
32017: LD_STRING D20-Frank-1
32019: PPUSH
32020: CALL_OW 88
// DialogueOff ;
32024: CALL_OW 7
// if RothCaptured then
32028: LD_EXP 33
32032: IFFALSE 32046
// AddMedal ( Roth , 1 ) else
32034: LD_STRING Roth
32036: PPUSH
32037: LD_INT 1
32039: PPUSH
32040: CALL_OW 101
32044: GO 32057
// AddMedal ( Roth , - 1 ) ;
32046: LD_STRING Roth
32048: PPUSH
32049: LD_INT 1
32051: NEG
32052: PPUSH
32053: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32057: LD_EXP 27
32061: IFFALSE 32075
// AddMedal ( Project , 1 ) else
32063: LD_STRING Project
32065: PPUSH
32066: LD_INT 1
32068: PPUSH
32069: CALL_OW 101
32073: GO 32086
// AddMedal ( Project , - 1 ) ;
32075: LD_STRING Project
32077: PPUSH
32078: LD_INT 1
32080: NEG
32081: PPUSH
32082: CALL_OW 101
// if lostCounter = 0 then
32086: LD_EXP 32
32090: PUSH
32091: LD_INT 0
32093: EQUAL
32094: IFFALSE 32108
// AddMedal ( NoLosses , 1 ) else
32096: LD_STRING NoLosses
32098: PPUSH
32099: LD_INT 1
32101: PPUSH
32102: CALL_OW 101
32106: GO 32119
// AddMedal ( NoLosses , - 1 ) ;
32108: LD_STRING NoLosses
32110: PPUSH
32111: LD_INT 1
32113: NEG
32114: PPUSH
32115: CALL_OW 101
// GiveMedals ( MAIN ) ;
32119: LD_STRING MAIN
32121: PPUSH
32122: CALL_OW 102
// YouWin ;
32126: CALL_OW 103
// end ; end_of_file
32130: END
// export function CustomEvent ( event ) ; begin
32131: LD_INT 0
32133: PPUSH
// end ;
32134: LD_VAR 0 2
32138: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32139: LD_VAR 0 1
32143: PUSH
32144: LD_INT 1
32146: EQUAL
32147: PUSH
32148: LD_VAR 0 2
32152: PUSH
32153: LD_INT 4
32155: EQUAL
32156: AND
32157: PUSH
32158: LD_EXP 55
32162: PPUSH
32163: CALL_OW 300
32167: AND
32168: IFFALSE 32184
// begin wait ( 0 0$2 ) ;
32170: LD_INT 70
32172: PPUSH
32173: CALL_OW 67
// YouLost ( Dismissed ) ;
32177: LD_STRING Dismissed
32179: PPUSH
32180: CALL_OW 104
// end ; end ;
32184: PPOPN 2
32186: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32187: LD_VAR 0 2
32191: PPUSH
32192: LD_VAR 0 3
32196: PPUSH
32197: LD_INT 18
32199: PPUSH
32200: CALL_OW 309
32204: IFFALSE 32213
// YouLost ( Motherlode3 ) ;
32206: LD_STRING Motherlode3
32208: PPUSH
32209: CALL_OW 104
// end ;
32213: PPOPN 3
32215: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32216: LD_EXP 27
32220: NOT
32221: IFFALSE 32231
// behemothDone := true ;
32223: LD_ADDR_EXP 28
32227: PUSH
32228: LD_INT 1
32230: ST_TO_ADDR
// end ;
32231: PPOPN 1
32233: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32234: LD_VAR 0 1
32238: PPUSH
32239: CALL_OW 255
32243: PUSH
32244: LD_INT 1
32246: EQUAL
32247: PUSH
32248: LD_EXP 30
32252: AND
32253: PUSH
32254: LD_INT 22
32256: PUSH
32257: LD_INT 3
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 34
32266: PUSH
32267: LD_INT 48
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PPUSH
32278: CALL_OW 69
32282: AND
32283: PUSH
32284: LD_INT 22
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 34
32296: PUSH
32297: LD_INT 8
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PPUSH
32308: CALL_OW 69
32312: NOT
32313: AND
32314: IFFALSE 32366
// begin wait ( 0 0$5 ) ;
32316: LD_INT 175
32318: PPUSH
32319: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32323: LD_INT 22
32325: PUSH
32326: LD_INT 3
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 34
32335: PUSH
32336: LD_INT 48
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PPUSH
32347: CALL_OW 69
32351: PUSH
32352: LD_INT 1
32354: ARRAY
32355: PPUSH
32356: LD_INT 60
32358: PPUSH
32359: LD_INT 95
32361: PPUSH
32362: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32366: LD_VAR 0 2
32370: PPUSH
32371: LD_VAR 0 3
32375: PPUSH
32376: LD_INT 18
32378: PPUSH
32379: CALL_OW 309
32383: IFFALSE 32443
// begin if GetSide ( unit ) = 1 then
32385: LD_VAR 0 1
32389: PPUSH
32390: CALL_OW 255
32394: PUSH
32395: LD_INT 1
32397: EQUAL
32398: IFFALSE 32414
// begin wait ( 0 0$6 ) ;
32400: LD_INT 210
32402: PPUSH
32403: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32407: LD_STRING Motherlode2
32409: PPUSH
32410: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32414: LD_VAR 0 1
32418: PPUSH
32419: CALL_OW 255
32423: PUSH
32424: LD_INT 8
32426: EQUAL
32427: IFFALSE 32443
// begin wait ( 0 0$6 ) ;
32429: LD_INT 210
32431: PPUSH
32432: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32436: LD_STRING Motherlode1
32438: PPUSH
32439: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 255
32452: PUSH
32453: LD_INT 3
32455: EQUAL
32456: IFFALSE 32477
// begin wait ( 0 0$5 ) ;
32458: LD_INT 175
32460: PPUSH
32461: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32465: LD_EXP 61
32469: PPUSH
32470: LD_STRING D18-Pla-1
32472: PPUSH
32473: CALL_OW 94
// end ; end ;
32477: PPOPN 3
32479: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32480: LD_VAR 0 1
32484: PUSH
32485: LD_EXP 70
32489: IN
32490: IFFALSE 32510
// begin behemothBuilders := behemothBuilders diff un ;
32492: LD_ADDR_EXP 70
32496: PUSH
32497: LD_EXP 70
32501: PUSH
32502: LD_VAR 0 1
32506: DIFF
32507: ST_TO_ADDR
// exit ;
32508: GO 32608
// end ; if un = JMM then
32510: LD_VAR 0 1
32514: PUSH
32515: LD_EXP 36
32519: EQUAL
32520: IFFALSE 32531
// begin YouLost ( JMM ) ;
32522: LD_STRING JMM
32524: PPUSH
32525: CALL_OW 104
// exit ;
32529: GO 32608
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32531: LD_VAR 0 1
32535: PUSH
32536: LD_INT 22
32538: PUSH
32539: LD_INT 1
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 3
32548: PUSH
32549: LD_INT 25
32551: PUSH
32552: LD_INT 16
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 25
32561: PUSH
32562: LD_INT 12
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: LIST
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PPUSH
32578: CALL_OW 69
32582: IN
32583: IFFALSE 32599
// lostCounter := lostCounter + 1 ;
32585: LD_ADDR_EXP 32
32589: PUSH
32590: LD_EXP 32
32594: PUSH
32595: LD_INT 1
32597: PLUS
32598: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32599: LD_VAR 0 1
32603: PPUSH
32604: CALL 60303 0 1
// end ;
32608: PPOPN 1
32610: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32611: LD_VAR 0 1
32615: PPUSH
32616: LD_VAR 0 2
32620: PPUSH
32621: CALL 62282 0 2
// end ;
32625: PPOPN 2
32627: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32628: LD_VAR 0 1
32632: PPUSH
32633: CALL 61350 0 1
// end ;
32637: PPOPN 1
32639: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32640: LD_VAR 0 1
32644: PUSH
32645: LD_INT 22
32647: PUSH
32648: LD_INT 8
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 30
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 23
32667: PUSH
32668: LD_INT 3
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: LIST
32679: PPUSH
32680: CALL_OW 69
32684: IN
32685: IFFALSE 32712
// begin ComUpgrade ( building ) ;
32687: LD_VAR 0 1
32691: PPUSH
32692: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32696: LD_EXP 58
32700: PPUSH
32701: LD_VAR 0 1
32705: PPUSH
32706: CALL 72506 0 2
// exit ;
32710: GO 32721
// end ; MCE_BuildingComplete ( building ) ;
32712: LD_VAR 0 1
32716: PPUSH
32717: CALL 61591 0 1
// end ;
32721: PPOPN 1
32723: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32724: LD_VAR 0 1
32728: PPUSH
32729: LD_VAR 0 2
32733: PPUSH
32734: CALL 59999 0 2
// end ;
32738: PPOPN 2
32740: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32741: LD_VAR 0 1
32745: PPUSH
32746: LD_VAR 0 2
32750: PPUSH
32751: LD_VAR 0 3
32755: PPUSH
32756: LD_VAR 0 4
32760: PPUSH
32761: LD_VAR 0 5
32765: PPUSH
32766: CALL 59619 0 5
// end ;
32770: PPOPN 5
32772: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32773: LD_VAR 0 1
32777: PPUSH
32778: LD_VAR 0 2
32782: PPUSH
32783: CALL 59209 0 2
// end ;
32787: PPOPN 2
32789: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32790: LD_VAR 0 1
32794: PPUSH
32795: LD_VAR 0 2
32799: PPUSH
32800: LD_VAR 0 3
32804: PPUSH
32805: LD_VAR 0 4
32809: PPUSH
32810: CALL 59047 0 4
// end ;
32814: PPOPN 4
32816: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32817: LD_VAR 0 1
32821: PPUSH
32822: LD_VAR 0 2
32826: PPUSH
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL 58822 0 3
// end ;
32836: PPOPN 3
32838: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32839: LD_VAR 0 1
32843: PPUSH
32844: LD_VAR 0 2
32848: PPUSH
32849: CALL 58707 0 2
// end ;
32853: PPOPN 2
32855: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32856: LD_VAR 0 1
32860: PPUSH
32861: LD_VAR 0 2
32865: PPUSH
32866: CALL 62543 0 2
// end ;
32870: PPOPN 2
32872: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32873: LD_VAR 0 1
32877: PPUSH
32878: CALL_OW 255
32882: PUSH
32883: LD_INT 4
32885: EQUAL
32886: PUSH
32887: LD_VAR 0 1
32891: PUSH
32892: LD_EXP 18
32896: PUSH
32897: LD_INT 1
32899: ARRAY
32900: IN
32901: AND
32902: PUSH
32903: LD_EXP 19
32907: AND
32908: IFFALSE 32927
// begin ComMoveXY ( driver , 61 , 93 ) ;
32910: LD_VAR 0 1
32914: PPUSH
32915: LD_INT 61
32917: PPUSH
32918: LD_INT 93
32920: PPUSH
32921: CALL_OW 111
// exit ;
32925: GO 32951
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32927: LD_VAR 0 1
32931: PPUSH
32932: LD_VAR 0 2
32936: PPUSH
32937: LD_VAR 0 3
32941: PPUSH
32942: LD_VAR 0 4
32946: PPUSH
32947: CALL 62759 0 4
// end ;
32951: PPOPN 4
32953: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: LD_VAR 0 2
32963: PPUSH
32964: CALL 58516 0 2
// end ; end_of_file
32968: PPOPN 2
32970: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32971: LD_EXP 15
32975: PUSH
32976: LD_INT 2
32978: EQUAL
32979: IFFALSE 33458
32981: GO 32983
32983: DISABLE
32984: LD_INT 0
32986: PPUSH
// begin time := 0 0$40 ;
32987: LD_ADDR_VAR 0 1
32991: PUSH
32992: LD_INT 1400
32994: ST_TO_ADDR
// repeat wait ( time ) ;
32995: LD_VAR 0 1
32999: PPUSH
33000: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33004: LD_INT 1
33006: PPUSH
33007: LD_INT 5
33009: PPUSH
33010: CALL_OW 12
33014: PPUSH
33015: LD_INT 106
33017: PPUSH
33018: LD_INT 150
33020: PPUSH
33021: LD_INT 19
33023: PPUSH
33024: LD_INT 1
33026: PPUSH
33027: CALL_OW 56
// time := time + 0 0$9 ;
33031: LD_ADDR_VAR 0 1
33035: PUSH
33036: LD_VAR 0 1
33040: PUSH
33041: LD_INT 315
33043: PLUS
33044: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33045: LD_INT 455
33047: PPUSH
33048: LD_INT 840
33050: PPUSH
33051: CALL_OW 12
33055: PPUSH
33056: CALL_OW 67
// if Prob ( 50 ) then
33060: LD_INT 50
33062: PPUSH
33063: CALL_OW 13
33067: IFFALSE 33096
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33069: LD_INT 1
33071: PPUSH
33072: LD_INT 5
33074: PPUSH
33075: CALL_OW 12
33079: PPUSH
33080: LD_INT 62
33082: PPUSH
33083: LD_INT 108
33085: PPUSH
33086: LD_INT 10
33088: PPUSH
33089: LD_INT 1
33091: PPUSH
33092: CALL_OW 56
// until missionStage > 4 ;
33096: LD_EXP 15
33100: PUSH
33101: LD_INT 4
33103: GREATER
33104: IFFALSE 32995
// repeat wait ( 0 0$1 ) ;
33106: LD_INT 35
33108: PPUSH
33109: CALL_OW 67
// until missionStage = 6 ;
33113: LD_EXP 15
33117: PUSH
33118: LD_INT 6
33120: EQUAL
33121: IFFALSE 33106
// time := 0 0$50 ;
33123: LD_ADDR_VAR 0 1
33127: PUSH
33128: LD_INT 1750
33130: ST_TO_ADDR
// repeat wait ( time ) ;
33131: LD_VAR 0 1
33135: PPUSH
33136: CALL_OW 67
// if Prob ( 50 ) then
33140: LD_INT 50
33142: PPUSH
33143: CALL_OW 13
33147: IFFALSE 33176
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33149: LD_INT 1
33151: PPUSH
33152: LD_INT 5
33154: PPUSH
33155: CALL_OW 12
33159: PPUSH
33160: LD_INT 106
33162: PPUSH
33163: LD_INT 89
33165: PPUSH
33166: LD_INT 45
33168: PPUSH
33169: LD_INT 1
33171: PPUSH
33172: CALL_OW 56
// time := time + 0 0$3 ;
33176: LD_ADDR_VAR 0 1
33180: PUSH
33181: LD_VAR 0 1
33185: PUSH
33186: LD_INT 105
33188: PLUS
33189: ST_TO_ADDR
// if Prob ( 30 ) then
33190: LD_INT 30
33192: PPUSH
33193: CALL_OW 13
33197: IFFALSE 33243
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33199: LD_INT 525
33201: PPUSH
33202: LD_INT 735
33204: PPUSH
33205: CALL_OW 12
33209: PPUSH
33210: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33214: LD_INT 1
33216: PPUSH
33217: LD_INT 5
33219: PPUSH
33220: CALL_OW 12
33224: PPUSH
33225: LD_INT 21
33227: PPUSH
33228: LD_INT 26
33230: PPUSH
33231: LD_INT 12
33233: PPUSH
33234: LD_INT 1
33236: PPUSH
33237: CALL_OW 56
// end else
33241: GO 33279
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33243: LD_INT 700
33245: PPUSH
33246: LD_INT 1225
33248: PPUSH
33249: CALL_OW 12
33253: PPUSH
33254: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33258: LD_INT 1
33260: PPUSH
33261: LD_INT 5
33263: PPUSH
33264: CALL_OW 12
33268: PPUSH
33269: LD_INT 16
33271: PPUSH
33272: LD_INT 1
33274: PPUSH
33275: CALL_OW 55
// end ; if Prob ( 50 ) then
33279: LD_INT 50
33281: PPUSH
33282: CALL_OW 13
33286: IFFALSE 33332
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33288: LD_INT 700
33290: PPUSH
33291: LD_INT 1050
33293: PPUSH
33294: CALL_OW 12
33298: PPUSH
33299: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33303: LD_INT 1
33305: PPUSH
33306: LD_INT 5
33308: PPUSH
33309: CALL_OW 12
33313: PPUSH
33314: LD_INT 181
33316: PPUSH
33317: LD_INT 218
33319: PPUSH
33320: LD_INT 16
33322: PPUSH
33323: LD_INT 1
33325: PPUSH
33326: CALL_OW 56
// end else
33330: GO 33368
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33332: LD_INT 350
33334: PPUSH
33335: LD_INT 525
33337: PPUSH
33338: CALL_OW 12
33342: PPUSH
33343: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33347: LD_INT 1
33349: PPUSH
33350: LD_INT 5
33352: PPUSH
33353: CALL_OW 12
33357: PPUSH
33358: LD_INT 15
33360: PPUSH
33361: LD_INT 1
33363: PPUSH
33364: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33368: LD_INT 45
33370: PUSH
33371: LD_INT 32
33373: PUSH
33374: LD_INT 25
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: LIST
33381: PUSH
33382: LD_OWVAR 67
33386: ARRAY
33387: PPUSH
33388: CALL_OW 13
33392: IFFALSE 33436
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33394: LD_INT 525
33396: PPUSH
33397: LD_INT 875
33399: PPUSH
33400: CALL_OW 12
33404: PPUSH
33405: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33409: LD_INT 1
33411: PPUSH
33412: LD_INT 5
33414: PPUSH
33415: CALL_OW 12
33419: PPUSH
33420: LD_INT 103
33422: PPUSH
33423: LD_INT 140
33425: PPUSH
33426: LD_INT 20
33428: PPUSH
33429: LD_INT 1
33431: PPUSH
33432: CALL_OW 56
// end ; if time > 2 2$20 then
33436: LD_VAR 0 1
33440: PUSH
33441: LD_INT 4900
33443: GREATER
33444: IFFALSE 33454
// time := 0 0$50 ;
33446: LD_ADDR_VAR 0 1
33450: PUSH
33451: LD_INT 1750
33453: ST_TO_ADDR
// until false ;
33454: LD_INT 0
33456: IFFALSE 33131
// end ; end_of_file
33458: PPOPN 1
33460: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33461: LD_EXP 13
33465: PUSH
33466: LD_EXP 15
33470: PUSH
33471: LD_INT 6
33473: GREATEREQUAL
33474: AND
33475: IFFALSE 33512
33477: GO 33479
33479: DISABLE
// begin enable ;
33480: ENABLE
// missionTime := missionTime + 0 0$1 ;
33481: LD_ADDR_EXP 14
33485: PUSH
33486: LD_EXP 14
33490: PUSH
33491: LD_INT 35
33493: PLUS
33494: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33495: LD_ADDR_OWVAR 47
33499: PUSH
33500: LD_STRING #Am15-1
33502: PUSH
33503: LD_EXP 14
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: ST_TO_ADDR
// end ; end_of_file
33512: END
// export function InitNature ; begin
33513: LD_INT 0
33515: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33516: LD_INT 3
33518: PPUSH
33519: LD_INT 3
33521: PPUSH
33522: LD_INT 2
33524: PPUSH
33525: LD_INT 1
33527: PPUSH
33528: LD_INT 1
33530: PPUSH
33531: LD_INT 0
33533: PPUSH
33534: LD_INT 0
33536: PPUSH
33537: LD_INT 20
33539: PPUSH
33540: LD_INT 0
33542: PPUSH
33543: CALL 97323 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33547: LD_INT 2
33549: PPUSH
33550: LD_INT 1
33552: PPUSH
33553: LD_INT 1
33555: PPUSH
33556: LD_INT 1
33558: PPUSH
33559: LD_INT 1
33561: PPUSH
33562: LD_INT 0
33564: PPUSH
33565: LD_INT 0
33567: PPUSH
33568: LD_INT 21
33570: PPUSH
33571: LD_INT 0
33573: PPUSH
33574: CALL 97323 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33578: LD_INT 4
33580: PPUSH
33581: LD_INT 1
33583: PPUSH
33584: LD_INT 2
33586: PPUSH
33587: LD_INT 4
33589: PPUSH
33590: LD_INT 2
33592: PPUSH
33593: LD_INT 1
33595: PPUSH
33596: LD_INT 0
33598: PPUSH
33599: LD_INT 22
33601: PPUSH
33602: LD_INT 0
33604: PPUSH
33605: CALL 97323 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33609: LD_INT 0
33611: PPUSH
33612: LD_INT 0
33614: PPUSH
33615: LD_INT 0
33617: PPUSH
33618: LD_INT 0
33620: PPUSH
33621: LD_INT 0
33623: PPUSH
33624: LD_INT 0
33626: PPUSH
33627: LD_INT 9
33629: PPUSH
33630: LD_INT 0
33632: PPUSH
33633: LD_INT 23
33635: PPUSH
33636: CALL 97323 0 9
// end ; end_of_file
33640: LD_VAR 0 1
33644: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33645: GO 33647
33647: DISABLE
// begin ru_radar := 98 ;
33648: LD_ADDR_EXP 92
33652: PUSH
33653: LD_INT 98
33655: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33656: LD_ADDR_EXP 93
33660: PUSH
33661: LD_INT 89
33663: ST_TO_ADDR
// us_hack := 99 ;
33664: LD_ADDR_EXP 94
33668: PUSH
33669: LD_INT 99
33671: ST_TO_ADDR
// us_artillery := 97 ;
33672: LD_ADDR_EXP 95
33676: PUSH
33677: LD_INT 97
33679: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33680: LD_ADDR_EXP 96
33684: PUSH
33685: LD_INT 91
33687: ST_TO_ADDR
// end ; end_of_file
33688: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33689: LD_INT 0
33691: PPUSH
33692: PPUSH
// skirmish := false ;
33693: LD_ADDR_EXP 97
33697: PUSH
33698: LD_INT 0
33700: ST_TO_ADDR
// debug_mc := false ;
33701: LD_ADDR_EXP 98
33705: PUSH
33706: LD_INT 0
33708: ST_TO_ADDR
// mc_bases := [ ] ;
33709: LD_ADDR_EXP 99
33713: PUSH
33714: EMPTY
33715: ST_TO_ADDR
// mc_sides := [ ] ;
33716: LD_ADDR_EXP 125
33720: PUSH
33721: EMPTY
33722: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33723: LD_ADDR_EXP 100
33727: PUSH
33728: EMPTY
33729: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33730: LD_ADDR_EXP 101
33734: PUSH
33735: EMPTY
33736: ST_TO_ADDR
// mc_need_heal := [ ] ;
33737: LD_ADDR_EXP 102
33741: PUSH
33742: EMPTY
33743: ST_TO_ADDR
// mc_healers := [ ] ;
33744: LD_ADDR_EXP 103
33748: PUSH
33749: EMPTY
33750: ST_TO_ADDR
// mc_build_list := [ ] ;
33751: LD_ADDR_EXP 104
33755: PUSH
33756: EMPTY
33757: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33758: LD_ADDR_EXP 131
33762: PUSH
33763: EMPTY
33764: ST_TO_ADDR
// mc_builders := [ ] ;
33765: LD_ADDR_EXP 105
33769: PUSH
33770: EMPTY
33771: ST_TO_ADDR
// mc_construct_list := [ ] ;
33772: LD_ADDR_EXP 106
33776: PUSH
33777: EMPTY
33778: ST_TO_ADDR
// mc_turret_list := [ ] ;
33779: LD_ADDR_EXP 107
33783: PUSH
33784: EMPTY
33785: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33786: LD_ADDR_EXP 108
33790: PUSH
33791: EMPTY
33792: ST_TO_ADDR
// mc_miners := [ ] ;
33793: LD_ADDR_EXP 113
33797: PUSH
33798: EMPTY
33799: ST_TO_ADDR
// mc_mines := [ ] ;
33800: LD_ADDR_EXP 112
33804: PUSH
33805: EMPTY
33806: ST_TO_ADDR
// mc_minefields := [ ] ;
33807: LD_ADDR_EXP 114
33811: PUSH
33812: EMPTY
33813: ST_TO_ADDR
// mc_crates := [ ] ;
33814: LD_ADDR_EXP 115
33818: PUSH
33819: EMPTY
33820: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33821: LD_ADDR_EXP 116
33825: PUSH
33826: EMPTY
33827: ST_TO_ADDR
// mc_crates_area := [ ] ;
33828: LD_ADDR_EXP 117
33832: PUSH
33833: EMPTY
33834: ST_TO_ADDR
// mc_vehicles := [ ] ;
33835: LD_ADDR_EXP 118
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_attack := [ ] ;
33842: LD_ADDR_EXP 119
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_produce := [ ] ;
33849: LD_ADDR_EXP 120
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_defender := [ ] ;
33856: LD_ADDR_EXP 121
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_parking := [ ] ;
33863: LD_ADDR_EXP 123
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33870: LD_ADDR_EXP 109
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33877: LD_ADDR_EXP 111
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_scan := [ ] ;
33884: LD_ADDR_EXP 122
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_scan_area := [ ] ;
33891: LD_ADDR_EXP 124
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_tech := [ ] ;
33898: LD_ADDR_EXP 126
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_class := [ ] ;
33905: LD_ADDR_EXP 140
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33912: LD_ADDR_EXP 141
33916: PUSH
33917: EMPTY
33918: ST_TO_ADDR
// end ;
33919: LD_VAR 0 1
33923: RET
// export function MC_Kill ( base ) ; begin
33924: LD_INT 0
33926: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33927: LD_ADDR_EXP 99
33931: PUSH
33932: LD_EXP 99
33936: PPUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: EMPTY
33943: PPUSH
33944: CALL_OW 1
33948: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33949: LD_ADDR_EXP 100
33953: PUSH
33954: LD_EXP 100
33958: PPUSH
33959: LD_VAR 0 1
33963: PPUSH
33964: EMPTY
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33971: LD_ADDR_EXP 101
33975: PUSH
33976: LD_EXP 101
33980: PPUSH
33981: LD_VAR 0 1
33985: PPUSH
33986: EMPTY
33987: PPUSH
33988: CALL_OW 1
33992: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33993: LD_ADDR_EXP 102
33997: PUSH
33998: LD_EXP 102
34002: PPUSH
34003: LD_VAR 0 1
34007: PPUSH
34008: EMPTY
34009: PPUSH
34010: CALL_OW 1
34014: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34015: LD_ADDR_EXP 103
34019: PUSH
34020: LD_EXP 103
34024: PPUSH
34025: LD_VAR 0 1
34029: PPUSH
34030: EMPTY
34031: PPUSH
34032: CALL_OW 1
34036: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34037: LD_ADDR_EXP 104
34041: PUSH
34042: LD_EXP 104
34046: PPUSH
34047: LD_VAR 0 1
34051: PPUSH
34052: EMPTY
34053: PPUSH
34054: CALL_OW 1
34058: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34059: LD_ADDR_EXP 105
34063: PUSH
34064: LD_EXP 105
34068: PPUSH
34069: LD_VAR 0 1
34073: PPUSH
34074: EMPTY
34075: PPUSH
34076: CALL_OW 1
34080: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34081: LD_ADDR_EXP 106
34085: PUSH
34086: LD_EXP 106
34090: PPUSH
34091: LD_VAR 0 1
34095: PPUSH
34096: EMPTY
34097: PPUSH
34098: CALL_OW 1
34102: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34103: LD_ADDR_EXP 107
34107: PUSH
34108: LD_EXP 107
34112: PPUSH
34113: LD_VAR 0 1
34117: PPUSH
34118: EMPTY
34119: PPUSH
34120: CALL_OW 1
34124: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34125: LD_ADDR_EXP 108
34129: PUSH
34130: LD_EXP 108
34134: PPUSH
34135: LD_VAR 0 1
34139: PPUSH
34140: EMPTY
34141: PPUSH
34142: CALL_OW 1
34146: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34147: LD_ADDR_EXP 109
34151: PUSH
34152: LD_EXP 109
34156: PPUSH
34157: LD_VAR 0 1
34161: PPUSH
34162: EMPTY
34163: PPUSH
34164: CALL_OW 1
34168: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34169: LD_ADDR_EXP 110
34173: PUSH
34174: LD_EXP 110
34178: PPUSH
34179: LD_VAR 0 1
34183: PPUSH
34184: LD_INT 0
34186: PPUSH
34187: CALL_OW 1
34191: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34192: LD_ADDR_EXP 111
34196: PUSH
34197: LD_EXP 111
34201: PPUSH
34202: LD_VAR 0 1
34206: PPUSH
34207: EMPTY
34208: PPUSH
34209: CALL_OW 1
34213: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34214: LD_ADDR_EXP 112
34218: PUSH
34219: LD_EXP 112
34223: PPUSH
34224: LD_VAR 0 1
34228: PPUSH
34229: EMPTY
34230: PPUSH
34231: CALL_OW 1
34235: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34236: LD_ADDR_EXP 113
34240: PUSH
34241: LD_EXP 113
34245: PPUSH
34246: LD_VAR 0 1
34250: PPUSH
34251: EMPTY
34252: PPUSH
34253: CALL_OW 1
34257: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34258: LD_ADDR_EXP 114
34262: PUSH
34263: LD_EXP 114
34267: PPUSH
34268: LD_VAR 0 1
34272: PPUSH
34273: EMPTY
34274: PPUSH
34275: CALL_OW 1
34279: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34280: LD_ADDR_EXP 115
34284: PUSH
34285: LD_EXP 115
34289: PPUSH
34290: LD_VAR 0 1
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL_OW 1
34301: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34302: LD_ADDR_EXP 116
34306: PUSH
34307: LD_EXP 116
34311: PPUSH
34312: LD_VAR 0 1
34316: PPUSH
34317: EMPTY
34318: PPUSH
34319: CALL_OW 1
34323: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34324: LD_ADDR_EXP 117
34328: PUSH
34329: LD_EXP 117
34333: PPUSH
34334: LD_VAR 0 1
34338: PPUSH
34339: EMPTY
34340: PPUSH
34341: CALL_OW 1
34345: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34346: LD_ADDR_EXP 118
34350: PUSH
34351: LD_EXP 118
34355: PPUSH
34356: LD_VAR 0 1
34360: PPUSH
34361: EMPTY
34362: PPUSH
34363: CALL_OW 1
34367: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34368: LD_ADDR_EXP 119
34372: PUSH
34373: LD_EXP 119
34377: PPUSH
34378: LD_VAR 0 1
34382: PPUSH
34383: EMPTY
34384: PPUSH
34385: CALL_OW 1
34389: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34390: LD_ADDR_EXP 120
34394: PUSH
34395: LD_EXP 120
34399: PPUSH
34400: LD_VAR 0 1
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL_OW 1
34411: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34412: LD_ADDR_EXP 121
34416: PUSH
34417: LD_EXP 121
34421: PPUSH
34422: LD_VAR 0 1
34426: PPUSH
34427: EMPTY
34428: PPUSH
34429: CALL_OW 1
34433: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34434: LD_ADDR_EXP 122
34438: PUSH
34439: LD_EXP 122
34443: PPUSH
34444: LD_VAR 0 1
34448: PPUSH
34449: EMPTY
34450: PPUSH
34451: CALL_OW 1
34455: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34456: LD_ADDR_EXP 123
34460: PUSH
34461: LD_EXP 123
34465: PPUSH
34466: LD_VAR 0 1
34470: PPUSH
34471: EMPTY
34472: PPUSH
34473: CALL_OW 1
34477: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34478: LD_ADDR_EXP 124
34482: PUSH
34483: LD_EXP 124
34487: PPUSH
34488: LD_VAR 0 1
34492: PPUSH
34493: EMPTY
34494: PPUSH
34495: CALL_OW 1
34499: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34500: LD_ADDR_EXP 126
34504: PUSH
34505: LD_EXP 126
34509: PPUSH
34510: LD_VAR 0 1
34514: PPUSH
34515: EMPTY
34516: PPUSH
34517: CALL_OW 1
34521: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34522: LD_ADDR_EXP 128
34526: PUSH
34527: LD_EXP 128
34531: PPUSH
34532: LD_VAR 0 1
34536: PPUSH
34537: EMPTY
34538: PPUSH
34539: CALL_OW 1
34543: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34544: LD_ADDR_EXP 129
34548: PUSH
34549: LD_EXP 129
34553: PPUSH
34554: LD_VAR 0 1
34558: PPUSH
34559: EMPTY
34560: PPUSH
34561: CALL_OW 1
34565: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34566: LD_ADDR_EXP 130
34570: PUSH
34571: LD_EXP 130
34575: PPUSH
34576: LD_VAR 0 1
34580: PPUSH
34581: EMPTY
34582: PPUSH
34583: CALL_OW 1
34587: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34588: LD_ADDR_EXP 131
34592: PUSH
34593: LD_EXP 131
34597: PPUSH
34598: LD_VAR 0 1
34602: PPUSH
34603: EMPTY
34604: PPUSH
34605: CALL_OW 1
34609: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34610: LD_ADDR_EXP 132
34614: PUSH
34615: LD_EXP 132
34619: PPUSH
34620: LD_VAR 0 1
34624: PPUSH
34625: EMPTY
34626: PPUSH
34627: CALL_OW 1
34631: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34632: LD_ADDR_EXP 133
34636: PUSH
34637: LD_EXP 133
34641: PPUSH
34642: LD_VAR 0 1
34646: PPUSH
34647: EMPTY
34648: PPUSH
34649: CALL_OW 1
34653: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34654: LD_ADDR_EXP 134
34658: PUSH
34659: LD_EXP 134
34663: PPUSH
34664: LD_VAR 0 1
34668: PPUSH
34669: EMPTY
34670: PPUSH
34671: CALL_OW 1
34675: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34676: LD_ADDR_EXP 135
34680: PUSH
34681: LD_EXP 135
34685: PPUSH
34686: LD_VAR 0 1
34690: PPUSH
34691: EMPTY
34692: PPUSH
34693: CALL_OW 1
34697: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34698: LD_ADDR_EXP 136
34702: PUSH
34703: LD_EXP 136
34707: PPUSH
34708: LD_VAR 0 1
34712: PPUSH
34713: EMPTY
34714: PPUSH
34715: CALL_OW 1
34719: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34720: LD_ADDR_EXP 137
34724: PUSH
34725: LD_EXP 137
34729: PPUSH
34730: LD_VAR 0 1
34734: PPUSH
34735: EMPTY
34736: PPUSH
34737: CALL_OW 1
34741: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34742: LD_ADDR_EXP 138
34746: PUSH
34747: LD_EXP 138
34751: PPUSH
34752: LD_VAR 0 1
34756: PPUSH
34757: EMPTY
34758: PPUSH
34759: CALL_OW 1
34763: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34764: LD_ADDR_EXP 139
34768: PUSH
34769: LD_EXP 139
34773: PPUSH
34774: LD_VAR 0 1
34778: PPUSH
34779: EMPTY
34780: PPUSH
34781: CALL_OW 1
34785: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34786: LD_ADDR_EXP 140
34790: PUSH
34791: LD_EXP 140
34795: PPUSH
34796: LD_VAR 0 1
34800: PPUSH
34801: EMPTY
34802: PPUSH
34803: CALL_OW 1
34807: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34808: LD_ADDR_EXP 141
34812: PUSH
34813: LD_EXP 141
34817: PPUSH
34818: LD_VAR 0 1
34822: PPUSH
34823: LD_INT 0
34825: PPUSH
34826: CALL_OW 1
34830: ST_TO_ADDR
// end ;
34831: LD_VAR 0 2
34835: RET
// export function MC_Add ( side , units ) ; var base ; begin
34836: LD_INT 0
34838: PPUSH
34839: PPUSH
// base := mc_bases + 1 ;
34840: LD_ADDR_VAR 0 4
34844: PUSH
34845: LD_EXP 99
34849: PUSH
34850: LD_INT 1
34852: PLUS
34853: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34854: LD_ADDR_EXP 125
34858: PUSH
34859: LD_EXP 125
34863: PPUSH
34864: LD_VAR 0 4
34868: PPUSH
34869: LD_VAR 0 1
34873: PPUSH
34874: CALL_OW 1
34878: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34879: LD_ADDR_EXP 99
34883: PUSH
34884: LD_EXP 99
34888: PPUSH
34889: LD_VAR 0 4
34893: PPUSH
34894: LD_VAR 0 2
34898: PPUSH
34899: CALL_OW 1
34903: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34904: LD_ADDR_EXP 100
34908: PUSH
34909: LD_EXP 100
34913: PPUSH
34914: LD_VAR 0 4
34918: PPUSH
34919: EMPTY
34920: PPUSH
34921: CALL_OW 1
34925: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34926: LD_ADDR_EXP 101
34930: PUSH
34931: LD_EXP 101
34935: PPUSH
34936: LD_VAR 0 4
34940: PPUSH
34941: EMPTY
34942: PPUSH
34943: CALL_OW 1
34947: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34948: LD_ADDR_EXP 102
34952: PUSH
34953: LD_EXP 102
34957: PPUSH
34958: LD_VAR 0 4
34962: PPUSH
34963: EMPTY
34964: PPUSH
34965: CALL_OW 1
34969: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34970: LD_ADDR_EXP 103
34974: PUSH
34975: LD_EXP 103
34979: PPUSH
34980: LD_VAR 0 4
34984: PPUSH
34985: EMPTY
34986: PPUSH
34987: CALL_OW 1
34991: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34992: LD_ADDR_EXP 104
34996: PUSH
34997: LD_EXP 104
35001: PPUSH
35002: LD_VAR 0 4
35006: PPUSH
35007: EMPTY
35008: PPUSH
35009: CALL_OW 1
35013: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35014: LD_ADDR_EXP 105
35018: PUSH
35019: LD_EXP 105
35023: PPUSH
35024: LD_VAR 0 4
35028: PPUSH
35029: EMPTY
35030: PPUSH
35031: CALL_OW 1
35035: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_EXP 106
35045: PPUSH
35046: LD_VAR 0 4
35050: PPUSH
35051: EMPTY
35052: PPUSH
35053: CALL_OW 1
35057: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35058: LD_ADDR_EXP 107
35062: PUSH
35063: LD_EXP 107
35067: PPUSH
35068: LD_VAR 0 4
35072: PPUSH
35073: EMPTY
35074: PPUSH
35075: CALL_OW 1
35079: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35080: LD_ADDR_EXP 108
35084: PUSH
35085: LD_EXP 108
35089: PPUSH
35090: LD_VAR 0 4
35094: PPUSH
35095: EMPTY
35096: PPUSH
35097: CALL_OW 1
35101: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35102: LD_ADDR_EXP 109
35106: PUSH
35107: LD_EXP 109
35111: PPUSH
35112: LD_VAR 0 4
35116: PPUSH
35117: EMPTY
35118: PPUSH
35119: CALL_OW 1
35123: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35124: LD_ADDR_EXP 110
35128: PUSH
35129: LD_EXP 110
35133: PPUSH
35134: LD_VAR 0 4
35138: PPUSH
35139: LD_INT 0
35141: PPUSH
35142: CALL_OW 1
35146: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35147: LD_ADDR_EXP 111
35151: PUSH
35152: LD_EXP 111
35156: PPUSH
35157: LD_VAR 0 4
35161: PPUSH
35162: EMPTY
35163: PPUSH
35164: CALL_OW 1
35168: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35169: LD_ADDR_EXP 112
35173: PUSH
35174: LD_EXP 112
35178: PPUSH
35179: LD_VAR 0 4
35183: PPUSH
35184: EMPTY
35185: PPUSH
35186: CALL_OW 1
35190: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35191: LD_ADDR_EXP 113
35195: PUSH
35196: LD_EXP 113
35200: PPUSH
35201: LD_VAR 0 4
35205: PPUSH
35206: EMPTY
35207: PPUSH
35208: CALL_OW 1
35212: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35213: LD_ADDR_EXP 114
35217: PUSH
35218: LD_EXP 114
35222: PPUSH
35223: LD_VAR 0 4
35227: PPUSH
35228: EMPTY
35229: PPUSH
35230: CALL_OW 1
35234: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35235: LD_ADDR_EXP 115
35239: PUSH
35240: LD_EXP 115
35244: PPUSH
35245: LD_VAR 0 4
35249: PPUSH
35250: EMPTY
35251: PPUSH
35252: CALL_OW 1
35256: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35257: LD_ADDR_EXP 116
35261: PUSH
35262: LD_EXP 116
35266: PPUSH
35267: LD_VAR 0 4
35271: PPUSH
35272: EMPTY
35273: PPUSH
35274: CALL_OW 1
35278: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35279: LD_ADDR_EXP 117
35283: PUSH
35284: LD_EXP 117
35288: PPUSH
35289: LD_VAR 0 4
35293: PPUSH
35294: EMPTY
35295: PPUSH
35296: CALL_OW 1
35300: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35301: LD_ADDR_EXP 118
35305: PUSH
35306: LD_EXP 118
35310: PPUSH
35311: LD_VAR 0 4
35315: PPUSH
35316: EMPTY
35317: PPUSH
35318: CALL_OW 1
35322: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35323: LD_ADDR_EXP 119
35327: PUSH
35328: LD_EXP 119
35332: PPUSH
35333: LD_VAR 0 4
35337: PPUSH
35338: EMPTY
35339: PPUSH
35340: CALL_OW 1
35344: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35345: LD_ADDR_EXP 120
35349: PUSH
35350: LD_EXP 120
35354: PPUSH
35355: LD_VAR 0 4
35359: PPUSH
35360: EMPTY
35361: PPUSH
35362: CALL_OW 1
35366: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35367: LD_ADDR_EXP 121
35371: PUSH
35372: LD_EXP 121
35376: PPUSH
35377: LD_VAR 0 4
35381: PPUSH
35382: EMPTY
35383: PPUSH
35384: CALL_OW 1
35388: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35389: LD_ADDR_EXP 122
35393: PUSH
35394: LD_EXP 122
35398: PPUSH
35399: LD_VAR 0 4
35403: PPUSH
35404: EMPTY
35405: PPUSH
35406: CALL_OW 1
35410: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35411: LD_ADDR_EXP 123
35415: PUSH
35416: LD_EXP 123
35420: PPUSH
35421: LD_VAR 0 4
35425: PPUSH
35426: EMPTY
35427: PPUSH
35428: CALL_OW 1
35432: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35433: LD_ADDR_EXP 124
35437: PUSH
35438: LD_EXP 124
35442: PPUSH
35443: LD_VAR 0 4
35447: PPUSH
35448: EMPTY
35449: PPUSH
35450: CALL_OW 1
35454: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35455: LD_ADDR_EXP 126
35459: PUSH
35460: LD_EXP 126
35464: PPUSH
35465: LD_VAR 0 4
35469: PPUSH
35470: EMPTY
35471: PPUSH
35472: CALL_OW 1
35476: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35477: LD_ADDR_EXP 128
35481: PUSH
35482: LD_EXP 128
35486: PPUSH
35487: LD_VAR 0 4
35491: PPUSH
35492: EMPTY
35493: PPUSH
35494: CALL_OW 1
35498: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35499: LD_ADDR_EXP 129
35503: PUSH
35504: LD_EXP 129
35508: PPUSH
35509: LD_VAR 0 4
35513: PPUSH
35514: EMPTY
35515: PPUSH
35516: CALL_OW 1
35520: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35521: LD_ADDR_EXP 130
35525: PUSH
35526: LD_EXP 130
35530: PPUSH
35531: LD_VAR 0 4
35535: PPUSH
35536: EMPTY
35537: PPUSH
35538: CALL_OW 1
35542: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35543: LD_ADDR_EXP 131
35547: PUSH
35548: LD_EXP 131
35552: PPUSH
35553: LD_VAR 0 4
35557: PPUSH
35558: EMPTY
35559: PPUSH
35560: CALL_OW 1
35564: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35565: LD_ADDR_EXP 132
35569: PUSH
35570: LD_EXP 132
35574: PPUSH
35575: LD_VAR 0 4
35579: PPUSH
35580: EMPTY
35581: PPUSH
35582: CALL_OW 1
35586: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35587: LD_ADDR_EXP 133
35591: PUSH
35592: LD_EXP 133
35596: PPUSH
35597: LD_VAR 0 4
35601: PPUSH
35602: EMPTY
35603: PPUSH
35604: CALL_OW 1
35608: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35609: LD_ADDR_EXP 134
35613: PUSH
35614: LD_EXP 134
35618: PPUSH
35619: LD_VAR 0 4
35623: PPUSH
35624: EMPTY
35625: PPUSH
35626: CALL_OW 1
35630: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35631: LD_ADDR_EXP 135
35635: PUSH
35636: LD_EXP 135
35640: PPUSH
35641: LD_VAR 0 4
35645: PPUSH
35646: EMPTY
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35653: LD_ADDR_EXP 136
35657: PUSH
35658: LD_EXP 136
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: EMPTY
35669: PPUSH
35670: CALL_OW 1
35674: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35675: LD_ADDR_EXP 137
35679: PUSH
35680: LD_EXP 137
35684: PPUSH
35685: LD_VAR 0 4
35689: PPUSH
35690: EMPTY
35691: PPUSH
35692: CALL_OW 1
35696: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35697: LD_ADDR_EXP 138
35701: PUSH
35702: LD_EXP 138
35706: PPUSH
35707: LD_VAR 0 4
35711: PPUSH
35712: EMPTY
35713: PPUSH
35714: CALL_OW 1
35718: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35719: LD_ADDR_EXP 139
35723: PUSH
35724: LD_EXP 139
35728: PPUSH
35729: LD_VAR 0 4
35733: PPUSH
35734: EMPTY
35735: PPUSH
35736: CALL_OW 1
35740: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35741: LD_ADDR_EXP 140
35745: PUSH
35746: LD_EXP 140
35750: PPUSH
35751: LD_VAR 0 4
35755: PPUSH
35756: EMPTY
35757: PPUSH
35758: CALL_OW 1
35762: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35763: LD_ADDR_EXP 141
35767: PUSH
35768: LD_EXP 141
35772: PPUSH
35773: LD_VAR 0 4
35777: PPUSH
35778: LD_INT 0
35780: PPUSH
35781: CALL_OW 1
35785: ST_TO_ADDR
// result := base ;
35786: LD_ADDR_VAR 0 3
35790: PUSH
35791: LD_VAR 0 4
35795: ST_TO_ADDR
// end ;
35796: LD_VAR 0 3
35800: RET
// export function MC_Start ( ) ; var i ; begin
35801: LD_INT 0
35803: PPUSH
35804: PPUSH
// for i = 1 to mc_bases do
35805: LD_ADDR_VAR 0 2
35809: PUSH
35810: DOUBLE
35811: LD_INT 1
35813: DEC
35814: ST_TO_ADDR
35815: LD_EXP 99
35819: PUSH
35820: FOR_TO
35821: IFFALSE 36898
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35823: LD_ADDR_EXP 99
35827: PUSH
35828: LD_EXP 99
35832: PPUSH
35833: LD_VAR 0 2
35837: PPUSH
35838: LD_EXP 99
35842: PUSH
35843: LD_VAR 0 2
35847: ARRAY
35848: PUSH
35849: LD_INT 0
35851: DIFF
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35858: LD_ADDR_EXP 100
35862: PUSH
35863: LD_EXP 100
35867: PPUSH
35868: LD_VAR 0 2
35872: PPUSH
35873: EMPTY
35874: PPUSH
35875: CALL_OW 1
35879: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35880: LD_ADDR_EXP 101
35884: PUSH
35885: LD_EXP 101
35889: PPUSH
35890: LD_VAR 0 2
35894: PPUSH
35895: EMPTY
35896: PPUSH
35897: CALL_OW 1
35901: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35902: LD_ADDR_EXP 102
35906: PUSH
35907: LD_EXP 102
35911: PPUSH
35912: LD_VAR 0 2
35916: PPUSH
35917: EMPTY
35918: PPUSH
35919: CALL_OW 1
35923: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
35924: LD_ADDR_EXP 103
35928: PUSH
35929: LD_EXP 103
35933: PPUSH
35934: LD_VAR 0 2
35938: PPUSH
35939: EMPTY
35940: PUSH
35941: EMPTY
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
35952: LD_ADDR_EXP 104
35956: PUSH
35957: LD_EXP 104
35961: PPUSH
35962: LD_VAR 0 2
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
35974: LD_ADDR_EXP 131
35978: PUSH
35979: LD_EXP 131
35983: PPUSH
35984: LD_VAR 0 2
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
35996: LD_ADDR_EXP 105
36000: PUSH
36001: LD_EXP 105
36005: PPUSH
36006: LD_VAR 0 2
36010: PPUSH
36011: EMPTY
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36018: LD_ADDR_EXP 106
36022: PUSH
36023: LD_EXP 106
36027: PPUSH
36028: LD_VAR 0 2
36032: PPUSH
36033: EMPTY
36034: PPUSH
36035: CALL_OW 1
36039: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36040: LD_ADDR_EXP 107
36044: PUSH
36045: LD_EXP 107
36049: PPUSH
36050: LD_VAR 0 2
36054: PPUSH
36055: LD_EXP 99
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: PPUSH
36066: LD_INT 2
36068: PUSH
36069: LD_INT 30
36071: PUSH
36072: LD_INT 32
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 30
36081: PUSH
36082: LD_INT 33
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: LIST
36093: PPUSH
36094: CALL_OW 72
36098: PPUSH
36099: CALL_OW 1
36103: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36104: LD_ADDR_EXP 108
36108: PUSH
36109: LD_EXP 108
36113: PPUSH
36114: LD_VAR 0 2
36118: PPUSH
36119: LD_EXP 99
36123: PUSH
36124: LD_VAR 0 2
36128: ARRAY
36129: PPUSH
36130: LD_INT 2
36132: PUSH
36133: LD_INT 30
36135: PUSH
36136: LD_INT 32
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 30
36145: PUSH
36146: LD_INT 31
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 58
36160: PUSH
36161: EMPTY
36162: LIST
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PPUSH
36168: CALL_OW 72
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36178: LD_ADDR_EXP 109
36182: PUSH
36183: LD_EXP 109
36187: PPUSH
36188: LD_VAR 0 2
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36200: LD_ADDR_EXP 113
36204: PUSH
36205: LD_EXP 113
36209: PPUSH
36210: LD_VAR 0 2
36214: PPUSH
36215: EMPTY
36216: PPUSH
36217: CALL_OW 1
36221: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36222: LD_ADDR_EXP 112
36226: PUSH
36227: LD_EXP 112
36231: PPUSH
36232: LD_VAR 0 2
36236: PPUSH
36237: EMPTY
36238: PPUSH
36239: CALL_OW 1
36243: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36244: LD_ADDR_EXP 114
36248: PUSH
36249: LD_EXP 114
36253: PPUSH
36254: LD_VAR 0 2
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36266: LD_ADDR_EXP 115
36270: PUSH
36271: LD_EXP 115
36275: PPUSH
36276: LD_VAR 0 2
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL_OW 1
36287: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36288: LD_ADDR_EXP 116
36292: PUSH
36293: LD_EXP 116
36297: PPUSH
36298: LD_VAR 0 2
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36310: LD_ADDR_EXP 117
36314: PUSH
36315: LD_EXP 117
36319: PPUSH
36320: LD_VAR 0 2
36324: PPUSH
36325: EMPTY
36326: PPUSH
36327: CALL_OW 1
36331: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36332: LD_ADDR_EXP 118
36336: PUSH
36337: LD_EXP 118
36341: PPUSH
36342: LD_VAR 0 2
36346: PPUSH
36347: EMPTY
36348: PPUSH
36349: CALL_OW 1
36353: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36354: LD_ADDR_EXP 119
36358: PUSH
36359: LD_EXP 119
36363: PPUSH
36364: LD_VAR 0 2
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36376: LD_ADDR_EXP 120
36380: PUSH
36381: LD_EXP 120
36385: PPUSH
36386: LD_VAR 0 2
36390: PPUSH
36391: EMPTY
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36398: LD_ADDR_EXP 121
36402: PUSH
36403: LD_EXP 121
36407: PPUSH
36408: LD_VAR 0 2
36412: PPUSH
36413: EMPTY
36414: PPUSH
36415: CALL_OW 1
36419: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36420: LD_ADDR_EXP 110
36424: PUSH
36425: LD_EXP 110
36429: PPUSH
36430: LD_VAR 0 2
36434: PPUSH
36435: LD_INT 0
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36443: LD_ADDR_EXP 123
36447: PUSH
36448: LD_EXP 123
36452: PPUSH
36453: LD_VAR 0 2
36457: PPUSH
36458: LD_INT 0
36460: PPUSH
36461: CALL_OW 1
36465: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36466: LD_ADDR_EXP 111
36470: PUSH
36471: LD_EXP 111
36475: PPUSH
36476: LD_VAR 0 2
36480: PPUSH
36481: EMPTY
36482: PPUSH
36483: CALL_OW 1
36487: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36488: LD_ADDR_EXP 122
36492: PUSH
36493: LD_EXP 122
36497: PPUSH
36498: LD_VAR 0 2
36502: PPUSH
36503: LD_INT 0
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36511: LD_ADDR_EXP 124
36515: PUSH
36516: LD_EXP 124
36520: PPUSH
36521: LD_VAR 0 2
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36533: LD_ADDR_EXP 127
36537: PUSH
36538: LD_EXP 127
36542: PPUSH
36543: LD_VAR 0 2
36547: PPUSH
36548: LD_INT 0
36550: PPUSH
36551: CALL_OW 1
36555: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36556: LD_ADDR_EXP 128
36560: PUSH
36561: LD_EXP 128
36565: PPUSH
36566: LD_VAR 0 2
36570: PPUSH
36571: EMPTY
36572: PPUSH
36573: CALL_OW 1
36577: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36578: LD_ADDR_EXP 129
36582: PUSH
36583: LD_EXP 129
36587: PPUSH
36588: LD_VAR 0 2
36592: PPUSH
36593: EMPTY
36594: PPUSH
36595: CALL_OW 1
36599: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36600: LD_ADDR_EXP 130
36604: PUSH
36605: LD_EXP 130
36609: PPUSH
36610: LD_VAR 0 2
36614: PPUSH
36615: EMPTY
36616: PPUSH
36617: CALL_OW 1
36621: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36622: LD_ADDR_EXP 132
36626: PUSH
36627: LD_EXP 132
36631: PPUSH
36632: LD_VAR 0 2
36636: PPUSH
36637: LD_EXP 99
36641: PUSH
36642: LD_VAR 0 2
36646: ARRAY
36647: PPUSH
36648: LD_INT 2
36650: PUSH
36651: LD_INT 30
36653: PUSH
36654: LD_INT 6
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 30
36663: PUSH
36664: LD_INT 7
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 30
36673: PUSH
36674: LD_INT 8
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: PPUSH
36687: CALL_OW 72
36691: PPUSH
36692: CALL_OW 1
36696: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36697: LD_ADDR_EXP 133
36701: PUSH
36702: LD_EXP 133
36706: PPUSH
36707: LD_VAR 0 2
36711: PPUSH
36712: EMPTY
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36719: LD_ADDR_EXP 134
36723: PUSH
36724: LD_EXP 134
36728: PPUSH
36729: LD_VAR 0 2
36733: PPUSH
36734: EMPTY
36735: PPUSH
36736: CALL_OW 1
36740: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36741: LD_ADDR_EXP 135
36745: PUSH
36746: LD_EXP 135
36750: PPUSH
36751: LD_VAR 0 2
36755: PPUSH
36756: EMPTY
36757: PPUSH
36758: CALL_OW 1
36762: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36763: LD_ADDR_EXP 136
36767: PUSH
36768: LD_EXP 136
36772: PPUSH
36773: LD_VAR 0 2
36777: PPUSH
36778: EMPTY
36779: PPUSH
36780: CALL_OW 1
36784: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36785: LD_ADDR_EXP 137
36789: PUSH
36790: LD_EXP 137
36794: PPUSH
36795: LD_VAR 0 2
36799: PPUSH
36800: EMPTY
36801: PPUSH
36802: CALL_OW 1
36806: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36807: LD_ADDR_EXP 138
36811: PUSH
36812: LD_EXP 138
36816: PPUSH
36817: LD_VAR 0 2
36821: PPUSH
36822: EMPTY
36823: PPUSH
36824: CALL_OW 1
36828: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36829: LD_ADDR_EXP 139
36833: PUSH
36834: LD_EXP 139
36838: PPUSH
36839: LD_VAR 0 2
36843: PPUSH
36844: EMPTY
36845: PPUSH
36846: CALL_OW 1
36850: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36851: LD_ADDR_EXP 140
36855: PUSH
36856: LD_EXP 140
36860: PPUSH
36861: LD_VAR 0 2
36865: PPUSH
36866: EMPTY
36867: PPUSH
36868: CALL_OW 1
36872: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36873: LD_ADDR_EXP 141
36877: PUSH
36878: LD_EXP 141
36882: PPUSH
36883: LD_VAR 0 2
36887: PPUSH
36888: LD_INT 0
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// end ;
36896: GO 35820
36898: POP
36899: POP
// MC_InitSides ( ) ;
36900: CALL 37186 0 0
// MC_InitResearch ( ) ;
36904: CALL 36925 0 0
// CustomInitMacro ( ) ;
36908: CALL 444 0 0
// skirmish := true ;
36912: LD_ADDR_EXP 97
36916: PUSH
36917: LD_INT 1
36919: ST_TO_ADDR
// end ;
36920: LD_VAR 0 1
36924: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
36925: LD_INT 0
36927: PPUSH
36928: PPUSH
36929: PPUSH
36930: PPUSH
36931: PPUSH
36932: PPUSH
// if not mc_bases then
36933: LD_EXP 99
36937: NOT
36938: IFFALSE 36942
// exit ;
36940: GO 37181
// for i = 1 to 8 do
36942: LD_ADDR_VAR 0 2
36946: PUSH
36947: DOUBLE
36948: LD_INT 1
36950: DEC
36951: ST_TO_ADDR
36952: LD_INT 8
36954: PUSH
36955: FOR_TO
36956: IFFALSE 36982
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
36958: LD_ADDR_EXP 126
36962: PUSH
36963: LD_EXP 126
36967: PPUSH
36968: LD_VAR 0 2
36972: PPUSH
36973: EMPTY
36974: PPUSH
36975: CALL_OW 1
36979: ST_TO_ADDR
36980: GO 36955
36982: POP
36983: POP
// tmp := [ ] ;
36984: LD_ADDR_VAR 0 5
36988: PUSH
36989: EMPTY
36990: ST_TO_ADDR
// for i = 1 to mc_sides do
36991: LD_ADDR_VAR 0 2
36995: PUSH
36996: DOUBLE
36997: LD_INT 1
36999: DEC
37000: ST_TO_ADDR
37001: LD_EXP 125
37005: PUSH
37006: FOR_TO
37007: IFFALSE 37065
// if not mc_sides [ i ] in tmp then
37009: LD_EXP 125
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_VAR 0 5
37024: IN
37025: NOT
37026: IFFALSE 37063
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37028: LD_ADDR_VAR 0 5
37032: PUSH
37033: LD_VAR 0 5
37037: PPUSH
37038: LD_VAR 0 5
37042: PUSH
37043: LD_INT 1
37045: PLUS
37046: PPUSH
37047: LD_EXP 125
37051: PUSH
37052: LD_VAR 0 2
37056: ARRAY
37057: PPUSH
37058: CALL_OW 2
37062: ST_TO_ADDR
37063: GO 37006
37065: POP
37066: POP
// if not tmp then
37067: LD_VAR 0 5
37071: NOT
37072: IFFALSE 37076
// exit ;
37074: GO 37181
// for j in tmp do
37076: LD_ADDR_VAR 0 3
37080: PUSH
37081: LD_VAR 0 5
37085: PUSH
37086: FOR_IN
37087: IFFALSE 37179
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37089: LD_ADDR_VAR 0 6
37093: PUSH
37094: LD_INT 22
37096: PUSH
37097: LD_VAR 0 3
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PPUSH
37106: CALL_OW 69
37110: ST_TO_ADDR
// if not un then
37111: LD_VAR 0 6
37115: NOT
37116: IFFALSE 37120
// continue ;
37118: GO 37086
// nation := GetNation ( un [ 1 ] ) ;
37120: LD_ADDR_VAR 0 4
37124: PUSH
37125: LD_VAR 0 6
37129: PUSH
37130: LD_INT 1
37132: ARRAY
37133: PPUSH
37134: CALL_OW 248
37138: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37139: LD_ADDR_EXP 126
37143: PUSH
37144: LD_EXP 126
37148: PPUSH
37149: LD_VAR 0 3
37153: PPUSH
37154: LD_VAR 0 3
37158: PPUSH
37159: LD_VAR 0 4
37163: PPUSH
37164: LD_INT 1
37166: PPUSH
37167: CALL 62963 0 3
37171: PPUSH
37172: CALL_OW 1
37176: ST_TO_ADDR
// end ;
37177: GO 37086
37179: POP
37180: POP
// end ;
37181: LD_VAR 0 1
37185: RET
// export function MC_InitSides ( ) ; var i ; begin
37186: LD_INT 0
37188: PPUSH
37189: PPUSH
// if not mc_bases then
37190: LD_EXP 99
37194: NOT
37195: IFFALSE 37199
// exit ;
37197: GO 37273
// for i = 1 to mc_bases do
37199: LD_ADDR_VAR 0 2
37203: PUSH
37204: DOUBLE
37205: LD_INT 1
37207: DEC
37208: ST_TO_ADDR
37209: LD_EXP 99
37213: PUSH
37214: FOR_TO
37215: IFFALSE 37271
// if mc_bases [ i ] then
37217: LD_EXP 99
37221: PUSH
37222: LD_VAR 0 2
37226: ARRAY
37227: IFFALSE 37269
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37229: LD_ADDR_EXP 125
37233: PUSH
37234: LD_EXP 125
37238: PPUSH
37239: LD_VAR 0 2
37243: PPUSH
37244: LD_EXP 99
37248: PUSH
37249: LD_VAR 0 2
37253: ARRAY
37254: PUSH
37255: LD_INT 1
37257: ARRAY
37258: PPUSH
37259: CALL_OW 255
37263: PPUSH
37264: CALL_OW 1
37268: ST_TO_ADDR
37269: GO 37214
37271: POP
37272: POP
// end ;
37273: LD_VAR 0 1
37277: RET
// every 0 0$01 trigger skirmish do
37278: LD_EXP 97
37282: IFFALSE 37436
37284: GO 37286
37286: DISABLE
// begin enable ;
37287: ENABLE
// MC_CheckBuildings ( ) ;
37288: CALL 41925 0 0
// MC_CheckPeopleLife ( ) ;
37292: CALL 42050 0 0
// RaiseSailEvent ( 100 ) ;
37296: LD_INT 100
37298: PPUSH
37299: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37303: LD_INT 103
37305: PPUSH
37306: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37310: LD_INT 104
37312: PPUSH
37313: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37317: LD_INT 105
37319: PPUSH
37320: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37324: LD_INT 106
37326: PPUSH
37327: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37331: LD_INT 107
37333: PPUSH
37334: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37338: LD_INT 108
37340: PPUSH
37341: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37345: LD_INT 109
37347: PPUSH
37348: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37352: LD_INT 110
37354: PPUSH
37355: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37359: LD_INT 111
37361: PPUSH
37362: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37366: LD_INT 112
37368: PPUSH
37369: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37373: LD_INT 113
37375: PPUSH
37376: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37380: LD_INT 120
37382: PPUSH
37383: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37387: LD_INT 121
37389: PPUSH
37390: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37394: LD_INT 122
37396: PPUSH
37397: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37401: LD_INT 123
37403: PPUSH
37404: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37408: LD_INT 124
37410: PPUSH
37411: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37415: LD_INT 125
37417: PPUSH
37418: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37422: LD_INT 126
37424: PPUSH
37425: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37429: LD_INT 200
37431: PPUSH
37432: CALL_OW 427
// end ;
37436: END
// on SailEvent ( event ) do begin if event < 100 then
37437: LD_VAR 0 1
37441: PUSH
37442: LD_INT 100
37444: LESS
37445: IFFALSE 37456
// CustomEvent ( event ) ;
37447: LD_VAR 0 1
37451: PPUSH
37452: CALL 32131 0 1
// if event = 100 then
37456: LD_VAR 0 1
37460: PUSH
37461: LD_INT 100
37463: EQUAL
37464: IFFALSE 37470
// MC_ClassManager ( ) ;
37466: CALL 37862 0 0
// if event = 101 then
37470: LD_VAR 0 1
37474: PUSH
37475: LD_INT 101
37477: EQUAL
37478: IFFALSE 37484
// MC_RepairBuildings ( ) ;
37480: CALL 42646 0 0
// if event = 102 then
37484: LD_VAR 0 1
37488: PUSH
37489: LD_INT 102
37491: EQUAL
37492: IFFALSE 37498
// MC_Heal ( ) ;
37494: CALL 43052 0 0
// if event = 103 then
37498: LD_VAR 0 1
37502: PUSH
37503: LD_INT 103
37505: EQUAL
37506: IFFALSE 37512
// MC_Build ( ) ;
37508: CALL 43474 0 0
// if event = 104 then
37512: LD_VAR 0 1
37516: PUSH
37517: LD_INT 104
37519: EQUAL
37520: IFFALSE 37526
// MC_TurretWeapon ( ) ;
37522: CALL 45087 0 0
// if event = 105 then
37526: LD_VAR 0 1
37530: PUSH
37531: LD_INT 105
37533: EQUAL
37534: IFFALSE 37540
// MC_BuildUpgrade ( ) ;
37536: CALL 44638 0 0
// if event = 106 then
37540: LD_VAR 0 1
37544: PUSH
37545: LD_INT 106
37547: EQUAL
37548: IFFALSE 37554
// MC_PlantMines ( ) ;
37550: CALL 45517 0 0
// if event = 107 then
37554: LD_VAR 0 1
37558: PUSH
37559: LD_INT 107
37561: EQUAL
37562: IFFALSE 37568
// MC_CollectCrates ( ) ;
37564: CALL 46551 0 0
// if event = 108 then
37568: LD_VAR 0 1
37572: PUSH
37573: LD_INT 108
37575: EQUAL
37576: IFFALSE 37582
// MC_LinkRemoteControl ( ) ;
37578: CALL 48308 0 0
// if event = 109 then
37582: LD_VAR 0 1
37586: PUSH
37587: LD_INT 109
37589: EQUAL
37590: IFFALSE 37596
// MC_ProduceVehicle ( ) ;
37592: CALL 48489 0 0
// if event = 110 then
37596: LD_VAR 0 1
37600: PUSH
37601: LD_INT 110
37603: EQUAL
37604: IFFALSE 37610
// MC_SendAttack ( ) ;
37606: CALL 48970 0 0
// if event = 111 then
37610: LD_VAR 0 1
37614: PUSH
37615: LD_INT 111
37617: EQUAL
37618: IFFALSE 37624
// MC_Defend ( ) ;
37620: CALL 49078 0 0
// if event = 112 then
37624: LD_VAR 0 1
37628: PUSH
37629: LD_INT 112
37631: EQUAL
37632: IFFALSE 37638
// MC_Research ( ) ;
37634: CALL 49705 0 0
// if event = 113 then
37638: LD_VAR 0 1
37642: PUSH
37643: LD_INT 113
37645: EQUAL
37646: IFFALSE 37652
// MC_MinesTrigger ( ) ;
37648: CALL 50819 0 0
// if event = 120 then
37652: LD_VAR 0 1
37656: PUSH
37657: LD_INT 120
37659: EQUAL
37660: IFFALSE 37666
// MC_RepairVehicle ( ) ;
37662: CALL 50918 0 0
// if event = 121 then
37666: LD_VAR 0 1
37670: PUSH
37671: LD_INT 121
37673: EQUAL
37674: IFFALSE 37680
// MC_TameApe ( ) ;
37676: CALL 51661 0 0
// if event = 122 then
37680: LD_VAR 0 1
37684: PUSH
37685: LD_INT 122
37687: EQUAL
37688: IFFALSE 37694
// MC_ChangeApeClass ( ) ;
37690: CALL 52490 0 0
// if event = 123 then
37694: LD_VAR 0 1
37698: PUSH
37699: LD_INT 123
37701: EQUAL
37702: IFFALSE 37708
// MC_Bazooka ( ) ;
37704: CALL 53140 0 0
// if event = 124 then
37708: LD_VAR 0 1
37712: PUSH
37713: LD_INT 124
37715: EQUAL
37716: IFFALSE 37722
// MC_TeleportExit ( ) ;
37718: CALL 53338 0 0
// if event = 125 then
37722: LD_VAR 0 1
37726: PUSH
37727: LD_INT 125
37729: EQUAL
37730: IFFALSE 37736
// MC_Deposits ( ) ;
37732: CALL 53985 0 0
// if event = 126 then
37736: LD_VAR 0 1
37740: PUSH
37741: LD_INT 126
37743: EQUAL
37744: IFFALSE 37750
// MC_RemoteDriver ( ) ;
37746: CALL 54610 0 0
// if event = 200 then
37750: LD_VAR 0 1
37754: PUSH
37755: LD_INT 200
37757: EQUAL
37758: IFFALSE 37764
// MC_Idle ( ) ;
37760: CALL 56343 0 0
// end ;
37764: PPOPN 1
37766: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37767: LD_INT 0
37769: PPUSH
37770: PPUSH
// if not mc_bases [ base ] or not tag then
37771: LD_EXP 99
37775: PUSH
37776: LD_VAR 0 1
37780: ARRAY
37781: NOT
37782: PUSH
37783: LD_VAR 0 2
37787: NOT
37788: OR
37789: IFFALSE 37793
// exit ;
37791: GO 37857
// for i in mc_bases [ base ] union mc_ape [ base ] do
37793: LD_ADDR_VAR 0 4
37797: PUSH
37798: LD_EXP 99
37802: PUSH
37803: LD_VAR 0 1
37807: ARRAY
37808: PUSH
37809: LD_EXP 128
37813: PUSH
37814: LD_VAR 0 1
37818: ARRAY
37819: UNION
37820: PUSH
37821: FOR_IN
37822: IFFALSE 37855
// if GetTag ( i ) = tag then
37824: LD_VAR 0 4
37828: PPUSH
37829: CALL_OW 110
37833: PUSH
37834: LD_VAR 0 2
37838: EQUAL
37839: IFFALSE 37853
// SetTag ( i , 0 ) ;
37841: LD_VAR 0 4
37845: PPUSH
37846: LD_INT 0
37848: PPUSH
37849: CALL_OW 109
37853: GO 37821
37855: POP
37856: POP
// end ;
37857: LD_VAR 0 3
37861: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37862: LD_INT 0
37864: PPUSH
37865: PPUSH
37866: PPUSH
37867: PPUSH
37868: PPUSH
37869: PPUSH
37870: PPUSH
37871: PPUSH
// if not mc_bases then
37872: LD_EXP 99
37876: NOT
37877: IFFALSE 37881
// exit ;
37879: GO 38339
// for i = 1 to mc_bases do
37881: LD_ADDR_VAR 0 2
37885: PUSH
37886: DOUBLE
37887: LD_INT 1
37889: DEC
37890: ST_TO_ADDR
37891: LD_EXP 99
37895: PUSH
37896: FOR_TO
37897: IFFALSE 38337
// begin tmp := MC_ClassCheckReq ( i ) ;
37899: LD_ADDR_VAR 0 4
37903: PUSH
37904: LD_VAR 0 2
37908: PPUSH
37909: CALL 38344 0 1
37913: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
37914: LD_ADDR_EXP 140
37918: PUSH
37919: LD_EXP 140
37923: PPUSH
37924: LD_VAR 0 2
37928: PPUSH
37929: LD_VAR 0 4
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
// if not tmp then
37939: LD_VAR 0 4
37943: NOT
37944: IFFALSE 37948
// continue ;
37946: GO 37896
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
37948: LD_ADDR_VAR 0 6
37952: PUSH
37953: LD_EXP 99
37957: PUSH
37958: LD_VAR 0 2
37962: ARRAY
37963: PPUSH
37964: LD_INT 2
37966: PUSH
37967: LD_INT 30
37969: PUSH
37970: LD_INT 4
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 30
37979: PUSH
37980: LD_INT 5
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: LIST
37991: PPUSH
37992: CALL_OW 72
37996: PUSH
37997: LD_EXP 99
38001: PUSH
38002: LD_VAR 0 2
38006: ARRAY
38007: PPUSH
38008: LD_INT 2
38010: PUSH
38011: LD_INT 30
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 30
38023: PUSH
38024: LD_INT 1
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: LIST
38035: PPUSH
38036: CALL_OW 72
38040: PUSH
38041: LD_EXP 99
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: PPUSH
38052: LD_INT 30
38054: PUSH
38055: LD_INT 3
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PPUSH
38062: CALL_OW 72
38066: PUSH
38067: LD_EXP 99
38071: PUSH
38072: LD_VAR 0 2
38076: ARRAY
38077: PPUSH
38078: LD_INT 2
38080: PUSH
38081: LD_INT 30
38083: PUSH
38084: LD_INT 6
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 30
38093: PUSH
38094: LD_INT 7
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 30
38103: PUSH
38104: LD_INT 8
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: PPUSH
38117: CALL_OW 72
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: ST_TO_ADDR
// for j = 1 to 4 do
38128: LD_ADDR_VAR 0 3
38132: PUSH
38133: DOUBLE
38134: LD_INT 1
38136: DEC
38137: ST_TO_ADDR
38138: LD_INT 4
38140: PUSH
38141: FOR_TO
38142: IFFALSE 38333
// begin if not tmp [ j ] then
38144: LD_VAR 0 4
38148: PUSH
38149: LD_VAR 0 3
38153: ARRAY
38154: NOT
38155: IFFALSE 38159
// continue ;
38157: GO 38141
// for p in tmp [ j ] do
38159: LD_ADDR_VAR 0 5
38163: PUSH
38164: LD_VAR 0 4
38168: PUSH
38169: LD_VAR 0 3
38173: ARRAY
38174: PUSH
38175: FOR_IN
38176: IFFALSE 38329
// begin if not b [ j ] then
38178: LD_VAR 0 6
38182: PUSH
38183: LD_VAR 0 3
38187: ARRAY
38188: NOT
38189: IFFALSE 38193
// break ;
38191: GO 38329
// e := 0 ;
38193: LD_ADDR_VAR 0 7
38197: PUSH
38198: LD_INT 0
38200: ST_TO_ADDR
// for k in b [ j ] do
38201: LD_ADDR_VAR 0 8
38205: PUSH
38206: LD_VAR 0 6
38210: PUSH
38211: LD_VAR 0 3
38215: ARRAY
38216: PUSH
38217: FOR_IN
38218: IFFALSE 38245
// if IsNotFull ( k ) then
38220: LD_VAR 0 8
38224: PPUSH
38225: CALL 66989 0 1
38229: IFFALSE 38243
// begin e := k ;
38231: LD_ADDR_VAR 0 7
38235: PUSH
38236: LD_VAR 0 8
38240: ST_TO_ADDR
// break ;
38241: GO 38245
// end ;
38243: GO 38217
38245: POP
38246: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38247: LD_VAR 0 7
38251: PUSH
38252: LD_VAR 0 5
38256: PPUSH
38257: LD_VAR 0 7
38261: PPUSH
38262: CALL 104016 0 2
38266: NOT
38267: AND
38268: IFFALSE 38327
// begin if IsInUnit ( p ) then
38270: LD_VAR 0 5
38274: PPUSH
38275: CALL_OW 310
38279: IFFALSE 38290
// ComExitBuilding ( p ) ;
38281: LD_VAR 0 5
38285: PPUSH
38286: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38290: LD_VAR 0 5
38294: PPUSH
38295: LD_VAR 0 7
38299: PPUSH
38300: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38304: LD_VAR 0 5
38308: PPUSH
38309: LD_VAR 0 3
38313: PPUSH
38314: CALL_OW 183
// AddComExitBuilding ( p ) ;
38318: LD_VAR 0 5
38322: PPUSH
38323: CALL_OW 182
// end ; end ;
38327: GO 38175
38329: POP
38330: POP
// end ;
38331: GO 38141
38333: POP
38334: POP
// end ;
38335: GO 37896
38337: POP
38338: POP
// end ;
38339: LD_VAR 0 1
38343: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38344: LD_INT 0
38346: PPUSH
38347: PPUSH
38348: PPUSH
38349: PPUSH
38350: PPUSH
38351: PPUSH
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38358: LD_VAR 0 1
38362: NOT
38363: PUSH
38364: LD_EXP 99
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: NOT
38375: OR
38376: PUSH
38377: LD_EXP 99
38381: PUSH
38382: LD_VAR 0 1
38386: ARRAY
38387: PPUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 30
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 30
38403: PUSH
38404: LD_INT 1
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: LIST
38415: PPUSH
38416: CALL_OW 72
38420: NOT
38421: OR
38422: IFFALSE 38426
// exit ;
38424: GO 41920
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38426: LD_ADDR_VAR 0 4
38430: PUSH
38431: LD_EXP 99
38435: PUSH
38436: LD_VAR 0 1
38440: ARRAY
38441: PPUSH
38442: LD_INT 2
38444: PUSH
38445: LD_INT 25
38447: PUSH
38448: LD_INT 1
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 25
38457: PUSH
38458: LD_INT 2
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 25
38467: PUSH
38468: LD_INT 3
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 25
38477: PUSH
38478: LD_INT 4
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 25
38487: PUSH
38488: LD_INT 5
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 25
38497: PUSH
38498: LD_INT 8
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 25
38507: PUSH
38508: LD_INT 9
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL_OW 72
38529: ST_TO_ADDR
// for i in tmp do
38530: LD_ADDR_VAR 0 3
38534: PUSH
38535: LD_VAR 0 4
38539: PUSH
38540: FOR_IN
38541: IFFALSE 38572
// if GetTag ( i ) then
38543: LD_VAR 0 3
38547: PPUSH
38548: CALL_OW 110
38552: IFFALSE 38570
// tmp := tmp diff i ;
38554: LD_ADDR_VAR 0 4
38558: PUSH
38559: LD_VAR 0 4
38563: PUSH
38564: LD_VAR 0 3
38568: DIFF
38569: ST_TO_ADDR
38570: GO 38540
38572: POP
38573: POP
// if not tmp then
38574: LD_VAR 0 4
38578: NOT
38579: IFFALSE 38583
// exit ;
38581: GO 41920
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38583: LD_ADDR_VAR 0 5
38587: PUSH
38588: LD_EXP 99
38592: PUSH
38593: LD_VAR 0 1
38597: ARRAY
38598: PPUSH
38599: LD_INT 2
38601: PUSH
38602: LD_INT 25
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 25
38614: PUSH
38615: LD_INT 5
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 25
38624: PUSH
38625: LD_INT 8
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 25
38634: PUSH
38635: LD_INT 9
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: PPUSH
38649: CALL_OW 72
38653: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38654: LD_ADDR_VAR 0 6
38658: PUSH
38659: LD_EXP 99
38663: PUSH
38664: LD_VAR 0 1
38668: ARRAY
38669: PPUSH
38670: LD_INT 25
38672: PUSH
38673: LD_INT 2
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PPUSH
38680: CALL_OW 72
38684: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38685: LD_ADDR_VAR 0 7
38689: PUSH
38690: LD_EXP 99
38694: PUSH
38695: LD_VAR 0 1
38699: ARRAY
38700: PPUSH
38701: LD_INT 25
38703: PUSH
38704: LD_INT 3
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PPUSH
38711: CALL_OW 72
38715: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38716: LD_ADDR_VAR 0 8
38720: PUSH
38721: LD_EXP 99
38725: PUSH
38726: LD_VAR 0 1
38730: ARRAY
38731: PPUSH
38732: LD_INT 25
38734: PUSH
38735: LD_INT 4
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 24
38744: PUSH
38745: LD_INT 251
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PPUSH
38756: CALL_OW 72
38760: ST_TO_ADDR
// if mc_scan [ base ] then
38761: LD_EXP 122
38765: PUSH
38766: LD_VAR 0 1
38770: ARRAY
38771: IFFALSE 39232
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38773: LD_ADDR_EXP 141
38777: PUSH
38778: LD_EXP 141
38782: PPUSH
38783: LD_VAR 0 1
38787: PPUSH
38788: LD_INT 4
38790: PPUSH
38791: CALL_OW 1
38795: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38796: LD_ADDR_VAR 0 12
38800: PUSH
38801: LD_EXP 99
38805: PUSH
38806: LD_VAR 0 1
38810: ARRAY
38811: PPUSH
38812: LD_INT 2
38814: PUSH
38815: LD_INT 30
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 30
38827: PUSH
38828: LD_INT 5
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: LIST
38839: PPUSH
38840: CALL_OW 72
38844: ST_TO_ADDR
// if not b then
38845: LD_VAR 0 12
38849: NOT
38850: IFFALSE 38854
// exit ;
38852: GO 41920
// p := [ ] ;
38854: LD_ADDR_VAR 0 11
38858: PUSH
38859: EMPTY
38860: ST_TO_ADDR
// if sci >= 2 then
38861: LD_VAR 0 8
38865: PUSH
38866: LD_INT 2
38868: GREATEREQUAL
38869: IFFALSE 38900
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38871: LD_ADDR_VAR 0 8
38875: PUSH
38876: LD_VAR 0 8
38880: PUSH
38881: LD_INT 1
38883: ARRAY
38884: PUSH
38885: LD_VAR 0 8
38889: PUSH
38890: LD_INT 2
38892: ARRAY
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: ST_TO_ADDR
38898: GO 38961
// if sci = 1 then
38900: LD_VAR 0 8
38904: PUSH
38905: LD_INT 1
38907: EQUAL
38908: IFFALSE 38929
// sci := [ sci [ 1 ] ] else
38910: LD_ADDR_VAR 0 8
38914: PUSH
38915: LD_VAR 0 8
38919: PUSH
38920: LD_INT 1
38922: ARRAY
38923: PUSH
38924: EMPTY
38925: LIST
38926: ST_TO_ADDR
38927: GO 38961
// if sci = 0 then
38929: LD_VAR 0 8
38933: PUSH
38934: LD_INT 0
38936: EQUAL
38937: IFFALSE 38961
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
38939: LD_ADDR_VAR 0 11
38943: PUSH
38944: LD_VAR 0 4
38948: PPUSH
38949: LD_INT 4
38951: PPUSH
38952: CALL 103879 0 2
38956: PUSH
38957: LD_INT 1
38959: ARRAY
38960: ST_TO_ADDR
// if eng > 4 then
38961: LD_VAR 0 6
38965: PUSH
38966: LD_INT 4
38968: GREATER
38969: IFFALSE 39015
// for i = eng downto 4 do
38971: LD_ADDR_VAR 0 3
38975: PUSH
38976: DOUBLE
38977: LD_VAR 0 6
38981: INC
38982: ST_TO_ADDR
38983: LD_INT 4
38985: PUSH
38986: FOR_DOWNTO
38987: IFFALSE 39013
// eng := eng diff eng [ i ] ;
38989: LD_ADDR_VAR 0 6
38993: PUSH
38994: LD_VAR 0 6
38998: PUSH
38999: LD_VAR 0 6
39003: PUSH
39004: LD_VAR 0 3
39008: ARRAY
39009: DIFF
39010: ST_TO_ADDR
39011: GO 38986
39013: POP
39014: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39015: LD_ADDR_VAR 0 4
39019: PUSH
39020: LD_VAR 0 4
39024: PUSH
39025: LD_VAR 0 5
39029: PUSH
39030: LD_VAR 0 6
39034: UNION
39035: PUSH
39036: LD_VAR 0 7
39040: UNION
39041: PUSH
39042: LD_VAR 0 8
39046: UNION
39047: DIFF
39048: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39049: LD_ADDR_VAR 0 13
39053: PUSH
39054: LD_EXP 99
39058: PUSH
39059: LD_VAR 0 1
39063: ARRAY
39064: PPUSH
39065: LD_INT 2
39067: PUSH
39068: LD_INT 30
39070: PUSH
39071: LD_INT 32
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 30
39080: PUSH
39081: LD_INT 31
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: PPUSH
39093: CALL_OW 72
39097: PUSH
39098: LD_EXP 99
39102: PUSH
39103: LD_VAR 0 1
39107: ARRAY
39108: PPUSH
39109: LD_INT 2
39111: PUSH
39112: LD_INT 30
39114: PUSH
39115: LD_INT 4
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 30
39124: PUSH
39125: LD_INT 5
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: PPUSH
39137: CALL_OW 72
39141: PUSH
39142: LD_INT 6
39144: MUL
39145: PLUS
39146: ST_TO_ADDR
// if bcount < tmp then
39147: LD_VAR 0 13
39151: PUSH
39152: LD_VAR 0 4
39156: LESS
39157: IFFALSE 39203
// for i = tmp downto bcount do
39159: LD_ADDR_VAR 0 3
39163: PUSH
39164: DOUBLE
39165: LD_VAR 0 4
39169: INC
39170: ST_TO_ADDR
39171: LD_VAR 0 13
39175: PUSH
39176: FOR_DOWNTO
39177: IFFALSE 39201
// tmp := Delete ( tmp , tmp ) ;
39179: LD_ADDR_VAR 0 4
39183: PUSH
39184: LD_VAR 0 4
39188: PPUSH
39189: LD_VAR 0 4
39193: PPUSH
39194: CALL_OW 3
39198: ST_TO_ADDR
39199: GO 39176
39201: POP
39202: POP
// result := [ tmp , 0 , 0 , p ] ;
39203: LD_ADDR_VAR 0 2
39207: PUSH
39208: LD_VAR 0 4
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: LD_VAR 0 11
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: ST_TO_ADDR
// exit ;
39230: GO 41920
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39232: LD_EXP 99
39236: PUSH
39237: LD_VAR 0 1
39241: ARRAY
39242: PPUSH
39243: LD_INT 2
39245: PUSH
39246: LD_INT 30
39248: PUSH
39249: LD_INT 6
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 30
39258: PUSH
39259: LD_INT 7
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 30
39268: PUSH
39269: LD_INT 8
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: PPUSH
39282: CALL_OW 72
39286: NOT
39287: PUSH
39288: LD_EXP 99
39292: PUSH
39293: LD_VAR 0 1
39297: ARRAY
39298: PPUSH
39299: LD_INT 30
39301: PUSH
39302: LD_INT 3
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PPUSH
39309: CALL_OW 72
39313: NOT
39314: AND
39315: IFFALSE 39387
// begin if eng = tmp then
39317: LD_VAR 0 6
39321: PUSH
39322: LD_VAR 0 4
39326: EQUAL
39327: IFFALSE 39331
// exit ;
39329: GO 41920
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39331: LD_ADDR_EXP 141
39335: PUSH
39336: LD_EXP 141
39340: PPUSH
39341: LD_VAR 0 1
39345: PPUSH
39346: LD_INT 1
39348: PPUSH
39349: CALL_OW 1
39353: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39354: LD_ADDR_VAR 0 2
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_VAR 0 4
39366: PUSH
39367: LD_VAR 0 6
39371: DIFF
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: ST_TO_ADDR
// exit ;
39385: GO 41920
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39387: LD_EXP 126
39391: PUSH
39392: LD_EXP 125
39396: PUSH
39397: LD_VAR 0 1
39401: ARRAY
39402: ARRAY
39403: PUSH
39404: LD_EXP 99
39408: PUSH
39409: LD_VAR 0 1
39413: ARRAY
39414: PPUSH
39415: LD_INT 2
39417: PUSH
39418: LD_INT 30
39420: PUSH
39421: LD_INT 6
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 30
39430: PUSH
39431: LD_INT 7
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 30
39440: PUSH
39441: LD_INT 8
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: PPUSH
39454: CALL_OW 72
39458: AND
39459: PUSH
39460: LD_EXP 99
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 30
39473: PUSH
39474: LD_INT 3
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PPUSH
39481: CALL_OW 72
39485: NOT
39486: AND
39487: IFFALSE 39701
// begin if sci >= 6 then
39489: LD_VAR 0 8
39493: PUSH
39494: LD_INT 6
39496: GREATEREQUAL
39497: IFFALSE 39501
// exit ;
39499: GO 41920
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39501: LD_ADDR_EXP 141
39505: PUSH
39506: LD_EXP 141
39510: PPUSH
39511: LD_VAR 0 1
39515: PPUSH
39516: LD_INT 2
39518: PPUSH
39519: CALL_OW 1
39523: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39524: LD_ADDR_VAR 0 9
39528: PUSH
39529: LD_VAR 0 4
39533: PUSH
39534: LD_VAR 0 8
39538: DIFF
39539: PPUSH
39540: LD_INT 4
39542: PPUSH
39543: CALL 103879 0 2
39547: ST_TO_ADDR
// p := [ ] ;
39548: LD_ADDR_VAR 0 11
39552: PUSH
39553: EMPTY
39554: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39555: LD_VAR 0 8
39559: PUSH
39560: LD_INT 6
39562: LESS
39563: PUSH
39564: LD_VAR 0 9
39568: PUSH
39569: LD_INT 6
39571: GREATER
39572: AND
39573: IFFALSE 39654
// begin for i = 1 to 6 - sci do
39575: LD_ADDR_VAR 0 3
39579: PUSH
39580: DOUBLE
39581: LD_INT 1
39583: DEC
39584: ST_TO_ADDR
39585: LD_INT 6
39587: PUSH
39588: LD_VAR 0 8
39592: MINUS
39593: PUSH
39594: FOR_TO
39595: IFFALSE 39650
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39597: LD_ADDR_VAR 0 11
39601: PUSH
39602: LD_VAR 0 11
39606: PPUSH
39607: LD_VAR 0 11
39611: PUSH
39612: LD_INT 1
39614: PLUS
39615: PPUSH
39616: LD_VAR 0 9
39620: PUSH
39621: LD_INT 1
39623: ARRAY
39624: PPUSH
39625: CALL_OW 2
39629: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39630: LD_ADDR_VAR 0 9
39634: PUSH
39635: LD_VAR 0 9
39639: PPUSH
39640: LD_INT 1
39642: PPUSH
39643: CALL_OW 3
39647: ST_TO_ADDR
// end ;
39648: GO 39594
39650: POP
39651: POP
// end else
39652: GO 39674
// if sort then
39654: LD_VAR 0 9
39658: IFFALSE 39674
// p := sort [ 1 ] ;
39660: LD_ADDR_VAR 0 11
39664: PUSH
39665: LD_VAR 0 9
39669: PUSH
39670: LD_INT 1
39672: ARRAY
39673: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39674: LD_ADDR_VAR 0 2
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_VAR 0 11
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: ST_TO_ADDR
// exit ;
39699: GO 41920
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39701: LD_EXP 126
39705: PUSH
39706: LD_EXP 125
39710: PUSH
39711: LD_VAR 0 1
39715: ARRAY
39716: ARRAY
39717: PUSH
39718: LD_EXP 99
39722: PUSH
39723: LD_VAR 0 1
39727: ARRAY
39728: PPUSH
39729: LD_INT 2
39731: PUSH
39732: LD_INT 30
39734: PUSH
39735: LD_INT 6
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 30
39744: PUSH
39745: LD_INT 7
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 30
39754: PUSH
39755: LD_INT 8
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: PPUSH
39768: CALL_OW 72
39772: AND
39773: PUSH
39774: LD_EXP 99
39778: PUSH
39779: LD_VAR 0 1
39783: ARRAY
39784: PPUSH
39785: LD_INT 30
39787: PUSH
39788: LD_INT 3
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PPUSH
39795: CALL_OW 72
39799: AND
39800: IFFALSE 40534
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39802: LD_ADDR_EXP 141
39806: PUSH
39807: LD_EXP 141
39811: PPUSH
39812: LD_VAR 0 1
39816: PPUSH
39817: LD_INT 3
39819: PPUSH
39820: CALL_OW 1
39824: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39825: LD_ADDR_VAR 0 2
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: LD_INT 0
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: ST_TO_ADDR
// if not eng then
39848: LD_VAR 0 6
39852: NOT
39853: IFFALSE 39916
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39855: LD_ADDR_VAR 0 11
39859: PUSH
39860: LD_VAR 0 4
39864: PPUSH
39865: LD_INT 2
39867: PPUSH
39868: CALL 103879 0 2
39872: PUSH
39873: LD_INT 1
39875: ARRAY
39876: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39877: LD_ADDR_VAR 0 2
39881: PUSH
39882: LD_VAR 0 2
39886: PPUSH
39887: LD_INT 2
39889: PPUSH
39890: LD_VAR 0 11
39894: PPUSH
39895: CALL_OW 1
39899: ST_TO_ADDR
// tmp := tmp diff p ;
39900: LD_ADDR_VAR 0 4
39904: PUSH
39905: LD_VAR 0 4
39909: PUSH
39910: LD_VAR 0 11
39914: DIFF
39915: ST_TO_ADDR
// end ; if tmp and sci < 6 then
39916: LD_VAR 0 4
39920: PUSH
39921: LD_VAR 0 8
39925: PUSH
39926: LD_INT 6
39928: LESS
39929: AND
39930: IFFALSE 40118
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
39932: LD_ADDR_VAR 0 9
39936: PUSH
39937: LD_VAR 0 4
39941: PUSH
39942: LD_VAR 0 8
39946: PUSH
39947: LD_VAR 0 7
39951: UNION
39952: DIFF
39953: PPUSH
39954: LD_INT 4
39956: PPUSH
39957: CALL 103879 0 2
39961: ST_TO_ADDR
// p := [ ] ;
39962: LD_ADDR_VAR 0 11
39966: PUSH
39967: EMPTY
39968: ST_TO_ADDR
// if sort then
39969: LD_VAR 0 9
39973: IFFALSE 40089
// for i = 1 to 6 - sci do
39975: LD_ADDR_VAR 0 3
39979: PUSH
39980: DOUBLE
39981: LD_INT 1
39983: DEC
39984: ST_TO_ADDR
39985: LD_INT 6
39987: PUSH
39988: LD_VAR 0 8
39992: MINUS
39993: PUSH
39994: FOR_TO
39995: IFFALSE 40087
// begin if i = sort then
39997: LD_VAR 0 3
40001: PUSH
40002: LD_VAR 0 9
40006: EQUAL
40007: IFFALSE 40011
// break ;
40009: GO 40087
// if GetClass ( i ) = 4 then
40011: LD_VAR 0 3
40015: PPUSH
40016: CALL_OW 257
40020: PUSH
40021: LD_INT 4
40023: EQUAL
40024: IFFALSE 40028
// continue ;
40026: GO 39994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40028: LD_ADDR_VAR 0 11
40032: PUSH
40033: LD_VAR 0 11
40037: PPUSH
40038: LD_VAR 0 11
40042: PUSH
40043: LD_INT 1
40045: PLUS
40046: PPUSH
40047: LD_VAR 0 9
40051: PUSH
40052: LD_VAR 0 3
40056: ARRAY
40057: PPUSH
40058: CALL_OW 2
40062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40063: LD_ADDR_VAR 0 4
40067: PUSH
40068: LD_VAR 0 4
40072: PUSH
40073: LD_VAR 0 9
40077: PUSH
40078: LD_VAR 0 3
40082: ARRAY
40083: DIFF
40084: ST_TO_ADDR
// end ;
40085: GO 39994
40087: POP
40088: POP
// if p then
40089: LD_VAR 0 11
40093: IFFALSE 40118
// result := Replace ( result , 4 , p ) ;
40095: LD_ADDR_VAR 0 2
40099: PUSH
40100: LD_VAR 0 2
40104: PPUSH
40105: LD_INT 4
40107: PPUSH
40108: LD_VAR 0 11
40112: PPUSH
40113: CALL_OW 1
40117: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40118: LD_VAR 0 4
40122: PUSH
40123: LD_VAR 0 7
40127: PUSH
40128: LD_INT 6
40130: LESS
40131: AND
40132: IFFALSE 40320
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40134: LD_ADDR_VAR 0 9
40138: PUSH
40139: LD_VAR 0 4
40143: PUSH
40144: LD_VAR 0 8
40148: PUSH
40149: LD_VAR 0 7
40153: UNION
40154: DIFF
40155: PPUSH
40156: LD_INT 3
40158: PPUSH
40159: CALL 103879 0 2
40163: ST_TO_ADDR
// p := [ ] ;
40164: LD_ADDR_VAR 0 11
40168: PUSH
40169: EMPTY
40170: ST_TO_ADDR
// if sort then
40171: LD_VAR 0 9
40175: IFFALSE 40291
// for i = 1 to 6 - mech do
40177: LD_ADDR_VAR 0 3
40181: PUSH
40182: DOUBLE
40183: LD_INT 1
40185: DEC
40186: ST_TO_ADDR
40187: LD_INT 6
40189: PUSH
40190: LD_VAR 0 7
40194: MINUS
40195: PUSH
40196: FOR_TO
40197: IFFALSE 40289
// begin if i = sort then
40199: LD_VAR 0 3
40203: PUSH
40204: LD_VAR 0 9
40208: EQUAL
40209: IFFALSE 40213
// break ;
40211: GO 40289
// if GetClass ( i ) = 3 then
40213: LD_VAR 0 3
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 3
40225: EQUAL
40226: IFFALSE 40230
// continue ;
40228: GO 40196
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40230: LD_ADDR_VAR 0 11
40234: PUSH
40235: LD_VAR 0 11
40239: PPUSH
40240: LD_VAR 0 11
40244: PUSH
40245: LD_INT 1
40247: PLUS
40248: PPUSH
40249: LD_VAR 0 9
40253: PUSH
40254: LD_VAR 0 3
40258: ARRAY
40259: PPUSH
40260: CALL_OW 2
40264: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40265: LD_ADDR_VAR 0 4
40269: PUSH
40270: LD_VAR 0 4
40274: PUSH
40275: LD_VAR 0 9
40279: PUSH
40280: LD_VAR 0 3
40284: ARRAY
40285: DIFF
40286: ST_TO_ADDR
// end ;
40287: GO 40196
40289: POP
40290: POP
// if p then
40291: LD_VAR 0 11
40295: IFFALSE 40320
// result := Replace ( result , 3 , p ) ;
40297: LD_ADDR_VAR 0 2
40301: PUSH
40302: LD_VAR 0 2
40306: PPUSH
40307: LD_INT 3
40309: PPUSH
40310: LD_VAR 0 11
40314: PPUSH
40315: CALL_OW 1
40319: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40320: LD_VAR 0 4
40324: PUSH
40325: LD_INT 6
40327: GREATER
40328: PUSH
40329: LD_VAR 0 6
40333: PUSH
40334: LD_INT 6
40336: LESS
40337: AND
40338: IFFALSE 40532
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40340: LD_ADDR_VAR 0 9
40344: PUSH
40345: LD_VAR 0 4
40349: PUSH
40350: LD_VAR 0 8
40354: PUSH
40355: LD_VAR 0 7
40359: UNION
40360: PUSH
40361: LD_VAR 0 6
40365: UNION
40366: DIFF
40367: PPUSH
40368: LD_INT 2
40370: PPUSH
40371: CALL 103879 0 2
40375: ST_TO_ADDR
// p := [ ] ;
40376: LD_ADDR_VAR 0 11
40380: PUSH
40381: EMPTY
40382: ST_TO_ADDR
// if sort then
40383: LD_VAR 0 9
40387: IFFALSE 40503
// for i = 1 to 6 - eng do
40389: LD_ADDR_VAR 0 3
40393: PUSH
40394: DOUBLE
40395: LD_INT 1
40397: DEC
40398: ST_TO_ADDR
40399: LD_INT 6
40401: PUSH
40402: LD_VAR 0 6
40406: MINUS
40407: PUSH
40408: FOR_TO
40409: IFFALSE 40501
// begin if i = sort then
40411: LD_VAR 0 3
40415: PUSH
40416: LD_VAR 0 9
40420: EQUAL
40421: IFFALSE 40425
// break ;
40423: GO 40501
// if GetClass ( i ) = 2 then
40425: LD_VAR 0 3
40429: PPUSH
40430: CALL_OW 257
40434: PUSH
40435: LD_INT 2
40437: EQUAL
40438: IFFALSE 40442
// continue ;
40440: GO 40408
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40442: LD_ADDR_VAR 0 11
40446: PUSH
40447: LD_VAR 0 11
40451: PPUSH
40452: LD_VAR 0 11
40456: PUSH
40457: LD_INT 1
40459: PLUS
40460: PPUSH
40461: LD_VAR 0 9
40465: PUSH
40466: LD_VAR 0 3
40470: ARRAY
40471: PPUSH
40472: CALL_OW 2
40476: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40477: LD_ADDR_VAR 0 4
40481: PUSH
40482: LD_VAR 0 4
40486: PUSH
40487: LD_VAR 0 9
40491: PUSH
40492: LD_VAR 0 3
40496: ARRAY
40497: DIFF
40498: ST_TO_ADDR
// end ;
40499: GO 40408
40501: POP
40502: POP
// if p then
40503: LD_VAR 0 11
40507: IFFALSE 40532
// result := Replace ( result , 2 , p ) ;
40509: LD_ADDR_VAR 0 2
40513: PUSH
40514: LD_VAR 0 2
40518: PPUSH
40519: LD_INT 2
40521: PPUSH
40522: LD_VAR 0 11
40526: PPUSH
40527: CALL_OW 1
40531: ST_TO_ADDR
// end ; exit ;
40532: GO 41920
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40534: LD_EXP 126
40538: PUSH
40539: LD_EXP 125
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: ARRAY
40550: NOT
40551: PUSH
40552: LD_EXP 99
40556: PUSH
40557: LD_VAR 0 1
40561: ARRAY
40562: PPUSH
40563: LD_INT 30
40565: PUSH
40566: LD_INT 3
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PPUSH
40573: CALL_OW 72
40577: AND
40578: PUSH
40579: LD_EXP 104
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: AND
40590: IFFALSE 41198
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40592: LD_ADDR_EXP 141
40596: PUSH
40597: LD_EXP 141
40601: PPUSH
40602: LD_VAR 0 1
40606: PPUSH
40607: LD_INT 5
40609: PPUSH
40610: CALL_OW 1
40614: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40615: LD_ADDR_VAR 0 2
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: LD_INT 0
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: ST_TO_ADDR
// if sci > 1 then
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: GREATER
40646: IFFALSE 40674
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40648: LD_ADDR_VAR 0 4
40652: PUSH
40653: LD_VAR 0 4
40657: PUSH
40658: LD_VAR 0 8
40662: PUSH
40663: LD_VAR 0 8
40667: PUSH
40668: LD_INT 1
40670: ARRAY
40671: DIFF
40672: DIFF
40673: ST_TO_ADDR
// if tmp and not sci then
40674: LD_VAR 0 4
40678: PUSH
40679: LD_VAR 0 8
40683: NOT
40684: AND
40685: IFFALSE 40754
// begin sort := SortBySkill ( tmp , 4 ) ;
40687: LD_ADDR_VAR 0 9
40691: PUSH
40692: LD_VAR 0 4
40696: PPUSH
40697: LD_INT 4
40699: PPUSH
40700: CALL 103879 0 2
40704: ST_TO_ADDR
// if sort then
40705: LD_VAR 0 9
40709: IFFALSE 40725
// p := sort [ 1 ] ;
40711: LD_ADDR_VAR 0 11
40715: PUSH
40716: LD_VAR 0 9
40720: PUSH
40721: LD_INT 1
40723: ARRAY
40724: ST_TO_ADDR
// if p then
40725: LD_VAR 0 11
40729: IFFALSE 40754
// result := Replace ( result , 4 , p ) ;
40731: LD_ADDR_VAR 0 2
40735: PUSH
40736: LD_VAR 0 2
40740: PPUSH
40741: LD_INT 4
40743: PPUSH
40744: LD_VAR 0 11
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40754: LD_ADDR_VAR 0 4
40758: PUSH
40759: LD_VAR 0 4
40763: PUSH
40764: LD_VAR 0 7
40768: DIFF
40769: ST_TO_ADDR
// if tmp and mech < 6 then
40770: LD_VAR 0 4
40774: PUSH
40775: LD_VAR 0 7
40779: PUSH
40780: LD_INT 6
40782: LESS
40783: AND
40784: IFFALSE 40972
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40786: LD_ADDR_VAR 0 9
40790: PUSH
40791: LD_VAR 0 4
40795: PUSH
40796: LD_VAR 0 8
40800: PUSH
40801: LD_VAR 0 7
40805: UNION
40806: DIFF
40807: PPUSH
40808: LD_INT 3
40810: PPUSH
40811: CALL 103879 0 2
40815: ST_TO_ADDR
// p := [ ] ;
40816: LD_ADDR_VAR 0 11
40820: PUSH
40821: EMPTY
40822: ST_TO_ADDR
// if sort then
40823: LD_VAR 0 9
40827: IFFALSE 40943
// for i = 1 to 6 - mech do
40829: LD_ADDR_VAR 0 3
40833: PUSH
40834: DOUBLE
40835: LD_INT 1
40837: DEC
40838: ST_TO_ADDR
40839: LD_INT 6
40841: PUSH
40842: LD_VAR 0 7
40846: MINUS
40847: PUSH
40848: FOR_TO
40849: IFFALSE 40941
// begin if i = sort then
40851: LD_VAR 0 3
40855: PUSH
40856: LD_VAR 0 9
40860: EQUAL
40861: IFFALSE 40865
// break ;
40863: GO 40941
// if GetClass ( i ) = 3 then
40865: LD_VAR 0 3
40869: PPUSH
40870: CALL_OW 257
40874: PUSH
40875: LD_INT 3
40877: EQUAL
40878: IFFALSE 40882
// continue ;
40880: GO 40848
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40882: LD_ADDR_VAR 0 11
40886: PUSH
40887: LD_VAR 0 11
40891: PPUSH
40892: LD_VAR 0 11
40896: PUSH
40897: LD_INT 1
40899: PLUS
40900: PPUSH
40901: LD_VAR 0 9
40905: PUSH
40906: LD_VAR 0 3
40910: ARRAY
40911: PPUSH
40912: CALL_OW 2
40916: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40917: LD_ADDR_VAR 0 4
40921: PUSH
40922: LD_VAR 0 4
40926: PUSH
40927: LD_VAR 0 9
40931: PUSH
40932: LD_VAR 0 3
40936: ARRAY
40937: DIFF
40938: ST_TO_ADDR
// end ;
40939: GO 40848
40941: POP
40942: POP
// if p then
40943: LD_VAR 0 11
40947: IFFALSE 40972
// result := Replace ( result , 3 , p ) ;
40949: LD_ADDR_VAR 0 2
40953: PUSH
40954: LD_VAR 0 2
40958: PPUSH
40959: LD_INT 3
40961: PPUSH
40962: LD_VAR 0 11
40966: PPUSH
40967: CALL_OW 1
40971: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40972: LD_ADDR_VAR 0 4
40976: PUSH
40977: LD_VAR 0 4
40981: PUSH
40982: LD_VAR 0 6
40986: DIFF
40987: ST_TO_ADDR
// if tmp and eng < 6 then
40988: LD_VAR 0 4
40992: PUSH
40993: LD_VAR 0 6
40997: PUSH
40998: LD_INT 6
41000: LESS
41001: AND
41002: IFFALSE 41196
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41004: LD_ADDR_VAR 0 9
41008: PUSH
41009: LD_VAR 0 4
41013: PUSH
41014: LD_VAR 0 8
41018: PUSH
41019: LD_VAR 0 7
41023: UNION
41024: PUSH
41025: LD_VAR 0 6
41029: UNION
41030: DIFF
41031: PPUSH
41032: LD_INT 2
41034: PPUSH
41035: CALL 103879 0 2
41039: ST_TO_ADDR
// p := [ ] ;
41040: LD_ADDR_VAR 0 11
41044: PUSH
41045: EMPTY
41046: ST_TO_ADDR
// if sort then
41047: LD_VAR 0 9
41051: IFFALSE 41167
// for i = 1 to 6 - eng do
41053: LD_ADDR_VAR 0 3
41057: PUSH
41058: DOUBLE
41059: LD_INT 1
41061: DEC
41062: ST_TO_ADDR
41063: LD_INT 6
41065: PUSH
41066: LD_VAR 0 6
41070: MINUS
41071: PUSH
41072: FOR_TO
41073: IFFALSE 41165
// begin if i = sort then
41075: LD_VAR 0 3
41079: PUSH
41080: LD_VAR 0 9
41084: EQUAL
41085: IFFALSE 41089
// break ;
41087: GO 41165
// if GetClass ( i ) = 2 then
41089: LD_VAR 0 3
41093: PPUSH
41094: CALL_OW 257
41098: PUSH
41099: LD_INT 2
41101: EQUAL
41102: IFFALSE 41106
// continue ;
41104: GO 41072
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41106: LD_ADDR_VAR 0 11
41110: PUSH
41111: LD_VAR 0 11
41115: PPUSH
41116: LD_VAR 0 11
41120: PUSH
41121: LD_INT 1
41123: PLUS
41124: PPUSH
41125: LD_VAR 0 9
41129: PUSH
41130: LD_VAR 0 3
41134: ARRAY
41135: PPUSH
41136: CALL_OW 2
41140: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41141: LD_ADDR_VAR 0 4
41145: PUSH
41146: LD_VAR 0 4
41150: PUSH
41151: LD_VAR 0 9
41155: PUSH
41156: LD_VAR 0 3
41160: ARRAY
41161: DIFF
41162: ST_TO_ADDR
// end ;
41163: GO 41072
41165: POP
41166: POP
// if p then
41167: LD_VAR 0 11
41171: IFFALSE 41196
// result := Replace ( result , 2 , p ) ;
41173: LD_ADDR_VAR 0 2
41177: PUSH
41178: LD_VAR 0 2
41182: PPUSH
41183: LD_INT 2
41185: PPUSH
41186: LD_VAR 0 11
41190: PPUSH
41191: CALL_OW 1
41195: ST_TO_ADDR
// end ; exit ;
41196: GO 41920
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41198: LD_EXP 126
41202: PUSH
41203: LD_EXP 125
41207: PUSH
41208: LD_VAR 0 1
41212: ARRAY
41213: ARRAY
41214: NOT
41215: PUSH
41216: LD_EXP 99
41220: PUSH
41221: LD_VAR 0 1
41225: ARRAY
41226: PPUSH
41227: LD_INT 30
41229: PUSH
41230: LD_INT 3
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PPUSH
41237: CALL_OW 72
41241: AND
41242: PUSH
41243: LD_EXP 104
41247: PUSH
41248: LD_VAR 0 1
41252: ARRAY
41253: NOT
41254: AND
41255: IFFALSE 41920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41257: LD_ADDR_EXP 141
41261: PUSH
41262: LD_EXP 141
41266: PPUSH
41267: LD_VAR 0 1
41271: PPUSH
41272: LD_INT 6
41274: PPUSH
41275: CALL_OW 1
41279: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41280: LD_ADDR_VAR 0 2
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: LD_INT 0
41290: PUSH
41291: LD_INT 0
41293: PUSH
41294: LD_INT 0
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: ST_TO_ADDR
// if sci >= 1 then
41303: LD_VAR 0 8
41307: PUSH
41308: LD_INT 1
41310: GREATEREQUAL
41311: IFFALSE 41333
// tmp := tmp diff sci [ 1 ] ;
41313: LD_ADDR_VAR 0 4
41317: PUSH
41318: LD_VAR 0 4
41322: PUSH
41323: LD_VAR 0 8
41327: PUSH
41328: LD_INT 1
41330: ARRAY
41331: DIFF
41332: ST_TO_ADDR
// if tmp and not sci then
41333: LD_VAR 0 4
41337: PUSH
41338: LD_VAR 0 8
41342: NOT
41343: AND
41344: IFFALSE 41413
// begin sort := SortBySkill ( tmp , 4 ) ;
41346: LD_ADDR_VAR 0 9
41350: PUSH
41351: LD_VAR 0 4
41355: PPUSH
41356: LD_INT 4
41358: PPUSH
41359: CALL 103879 0 2
41363: ST_TO_ADDR
// if sort then
41364: LD_VAR 0 9
41368: IFFALSE 41384
// p := sort [ 1 ] ;
41370: LD_ADDR_VAR 0 11
41374: PUSH
41375: LD_VAR 0 9
41379: PUSH
41380: LD_INT 1
41382: ARRAY
41383: ST_TO_ADDR
// if p then
41384: LD_VAR 0 11
41388: IFFALSE 41413
// result := Replace ( result , 4 , p ) ;
41390: LD_ADDR_VAR 0 2
41394: PUSH
41395: LD_VAR 0 2
41399: PPUSH
41400: LD_INT 4
41402: PPUSH
41403: LD_VAR 0 11
41407: PPUSH
41408: CALL_OW 1
41412: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41413: LD_ADDR_VAR 0 4
41417: PUSH
41418: LD_VAR 0 4
41422: PUSH
41423: LD_VAR 0 7
41427: DIFF
41428: ST_TO_ADDR
// if tmp and mech < 6 then
41429: LD_VAR 0 4
41433: PUSH
41434: LD_VAR 0 7
41438: PUSH
41439: LD_INT 6
41441: LESS
41442: AND
41443: IFFALSE 41625
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41445: LD_ADDR_VAR 0 9
41449: PUSH
41450: LD_VAR 0 4
41454: PUSH
41455: LD_VAR 0 7
41459: DIFF
41460: PPUSH
41461: LD_INT 3
41463: PPUSH
41464: CALL 103879 0 2
41468: ST_TO_ADDR
// p := [ ] ;
41469: LD_ADDR_VAR 0 11
41473: PUSH
41474: EMPTY
41475: ST_TO_ADDR
// if sort then
41476: LD_VAR 0 9
41480: IFFALSE 41596
// for i = 1 to 6 - mech do
41482: LD_ADDR_VAR 0 3
41486: PUSH
41487: DOUBLE
41488: LD_INT 1
41490: DEC
41491: ST_TO_ADDR
41492: LD_INT 6
41494: PUSH
41495: LD_VAR 0 7
41499: MINUS
41500: PUSH
41501: FOR_TO
41502: IFFALSE 41594
// begin if i = sort then
41504: LD_VAR 0 3
41508: PUSH
41509: LD_VAR 0 9
41513: EQUAL
41514: IFFALSE 41518
// break ;
41516: GO 41594
// if GetClass ( i ) = 3 then
41518: LD_VAR 0 3
41522: PPUSH
41523: CALL_OW 257
41527: PUSH
41528: LD_INT 3
41530: EQUAL
41531: IFFALSE 41535
// continue ;
41533: GO 41501
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41535: LD_ADDR_VAR 0 11
41539: PUSH
41540: LD_VAR 0 11
41544: PPUSH
41545: LD_VAR 0 11
41549: PUSH
41550: LD_INT 1
41552: PLUS
41553: PPUSH
41554: LD_VAR 0 9
41558: PUSH
41559: LD_VAR 0 3
41563: ARRAY
41564: PPUSH
41565: CALL_OW 2
41569: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41570: LD_ADDR_VAR 0 4
41574: PUSH
41575: LD_VAR 0 4
41579: PUSH
41580: LD_VAR 0 9
41584: PUSH
41585: LD_VAR 0 3
41589: ARRAY
41590: DIFF
41591: ST_TO_ADDR
// end ;
41592: GO 41501
41594: POP
41595: POP
// if p then
41596: LD_VAR 0 11
41600: IFFALSE 41625
// result := Replace ( result , 3 , p ) ;
41602: LD_ADDR_VAR 0 2
41606: PUSH
41607: LD_VAR 0 2
41611: PPUSH
41612: LD_INT 3
41614: PPUSH
41615: LD_VAR 0 11
41619: PPUSH
41620: CALL_OW 1
41624: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41625: LD_ADDR_VAR 0 4
41629: PUSH
41630: LD_VAR 0 4
41634: PUSH
41635: LD_VAR 0 6
41639: DIFF
41640: ST_TO_ADDR
// if tmp and eng < 4 then
41641: LD_VAR 0 4
41645: PUSH
41646: LD_VAR 0 6
41650: PUSH
41651: LD_INT 4
41653: LESS
41654: AND
41655: IFFALSE 41845
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41657: LD_ADDR_VAR 0 9
41661: PUSH
41662: LD_VAR 0 4
41666: PUSH
41667: LD_VAR 0 7
41671: PUSH
41672: LD_VAR 0 6
41676: UNION
41677: DIFF
41678: PPUSH
41679: LD_INT 2
41681: PPUSH
41682: CALL 103879 0 2
41686: ST_TO_ADDR
// p := [ ] ;
41687: LD_ADDR_VAR 0 11
41691: PUSH
41692: EMPTY
41693: ST_TO_ADDR
// if sort then
41694: LD_VAR 0 9
41698: IFFALSE 41814
// for i = 1 to 4 - eng do
41700: LD_ADDR_VAR 0 3
41704: PUSH
41705: DOUBLE
41706: LD_INT 1
41708: DEC
41709: ST_TO_ADDR
41710: LD_INT 4
41712: PUSH
41713: LD_VAR 0 6
41717: MINUS
41718: PUSH
41719: FOR_TO
41720: IFFALSE 41812
// begin if i = sort then
41722: LD_VAR 0 3
41726: PUSH
41727: LD_VAR 0 9
41731: EQUAL
41732: IFFALSE 41736
// break ;
41734: GO 41812
// if GetClass ( i ) = 2 then
41736: LD_VAR 0 3
41740: PPUSH
41741: CALL_OW 257
41745: PUSH
41746: LD_INT 2
41748: EQUAL
41749: IFFALSE 41753
// continue ;
41751: GO 41719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41753: LD_ADDR_VAR 0 11
41757: PUSH
41758: LD_VAR 0 11
41762: PPUSH
41763: LD_VAR 0 11
41767: PUSH
41768: LD_INT 1
41770: PLUS
41771: PPUSH
41772: LD_VAR 0 9
41776: PUSH
41777: LD_VAR 0 3
41781: ARRAY
41782: PPUSH
41783: CALL_OW 2
41787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41788: LD_ADDR_VAR 0 4
41792: PUSH
41793: LD_VAR 0 4
41797: PUSH
41798: LD_VAR 0 9
41802: PUSH
41803: LD_VAR 0 3
41807: ARRAY
41808: DIFF
41809: ST_TO_ADDR
// end ;
41810: GO 41719
41812: POP
41813: POP
// if p then
41814: LD_VAR 0 11
41818: IFFALSE 41843
// result := Replace ( result , 2 , p ) ;
41820: LD_ADDR_VAR 0 2
41824: PUSH
41825: LD_VAR 0 2
41829: PPUSH
41830: LD_INT 2
41832: PPUSH
41833: LD_VAR 0 11
41837: PPUSH
41838: CALL_OW 1
41842: ST_TO_ADDR
// end else
41843: GO 41889
// for i = eng downto 5 do
41845: LD_ADDR_VAR 0 3
41849: PUSH
41850: DOUBLE
41851: LD_VAR 0 6
41855: INC
41856: ST_TO_ADDR
41857: LD_INT 5
41859: PUSH
41860: FOR_DOWNTO
41861: IFFALSE 41887
// tmp := tmp union eng [ i ] ;
41863: LD_ADDR_VAR 0 4
41867: PUSH
41868: LD_VAR 0 4
41872: PUSH
41873: LD_VAR 0 6
41877: PUSH
41878: LD_VAR 0 3
41882: ARRAY
41883: UNION
41884: ST_TO_ADDR
41885: GO 41860
41887: POP
41888: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41889: LD_ADDR_VAR 0 2
41893: PUSH
41894: LD_VAR 0 2
41898: PPUSH
41899: LD_INT 1
41901: PPUSH
41902: LD_VAR 0 4
41906: PUSH
41907: LD_VAR 0 5
41911: DIFF
41912: PPUSH
41913: CALL_OW 1
41917: ST_TO_ADDR
// exit ;
41918: GO 41920
// end ; end ;
41920: LD_VAR 0 2
41924: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
41925: LD_INT 0
41927: PPUSH
41928: PPUSH
41929: PPUSH
// if not mc_bases then
41930: LD_EXP 99
41934: NOT
41935: IFFALSE 41939
// exit ;
41937: GO 42045
// for i = 1 to mc_bases do
41939: LD_ADDR_VAR 0 2
41943: PUSH
41944: DOUBLE
41945: LD_INT 1
41947: DEC
41948: ST_TO_ADDR
41949: LD_EXP 99
41953: PUSH
41954: FOR_TO
41955: IFFALSE 42036
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41957: LD_ADDR_VAR 0 3
41961: PUSH
41962: LD_EXP 99
41966: PUSH
41967: LD_VAR 0 2
41971: ARRAY
41972: PPUSH
41973: LD_INT 21
41975: PUSH
41976: LD_INT 3
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 3
41985: PUSH
41986: LD_INT 24
41988: PUSH
41989: LD_INT 1000
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PPUSH
42004: CALL_OW 72
42008: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42009: LD_ADDR_EXP 100
42013: PUSH
42014: LD_EXP 100
42018: PPUSH
42019: LD_VAR 0 2
42023: PPUSH
42024: LD_VAR 0 3
42028: PPUSH
42029: CALL_OW 1
42033: ST_TO_ADDR
// end ;
42034: GO 41954
42036: POP
42037: POP
// RaiseSailEvent ( 101 ) ;
42038: LD_INT 101
42040: PPUSH
42041: CALL_OW 427
// end ;
42045: LD_VAR 0 1
42049: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42050: LD_INT 0
42052: PPUSH
42053: PPUSH
42054: PPUSH
42055: PPUSH
42056: PPUSH
42057: PPUSH
42058: PPUSH
// if not mc_bases then
42059: LD_EXP 99
42063: NOT
42064: IFFALSE 42068
// exit ;
42066: GO 42641
// for i = 1 to mc_bases do
42068: LD_ADDR_VAR 0 2
42072: PUSH
42073: DOUBLE
42074: LD_INT 1
42076: DEC
42077: ST_TO_ADDR
42078: LD_EXP 99
42082: PUSH
42083: FOR_TO
42084: IFFALSE 42632
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
42086: LD_ADDR_VAR 0 5
42090: PUSH
42091: LD_EXP 99
42095: PUSH
42096: LD_VAR 0 2
42100: ARRAY
42101: PUSH
42102: LD_EXP 128
42106: PUSH
42107: LD_VAR 0 2
42111: ARRAY
42112: UNION
42113: PPUSH
42114: LD_INT 21
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 1
42126: PUSH
42127: LD_INT 3
42129: PUSH
42130: LD_INT 54
42132: PUSH
42133: EMPTY
42134: LIST
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 3
42142: PUSH
42143: LD_INT 24
42145: PUSH
42146: LD_INT 750
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: LIST
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PPUSH
42166: CALL_OW 72
42170: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42171: LD_ADDR_VAR 0 6
42175: PUSH
42176: LD_EXP 99
42180: PUSH
42181: LD_VAR 0 2
42185: ARRAY
42186: PPUSH
42187: LD_INT 21
42189: PUSH
42190: LD_INT 1
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 3
42202: PUSH
42203: LD_INT 54
42205: PUSH
42206: EMPTY
42207: LIST
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: LD_INT 24
42218: PUSH
42219: LD_INT 250
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: LIST
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PPUSH
42239: CALL_OW 72
42243: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42244: LD_ADDR_VAR 0 7
42248: PUSH
42249: LD_VAR 0 5
42253: PUSH
42254: LD_VAR 0 6
42258: DIFF
42259: ST_TO_ADDR
// if not need_heal_1 then
42260: LD_VAR 0 6
42264: NOT
42265: IFFALSE 42298
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42267: LD_ADDR_EXP 102
42271: PUSH
42272: LD_EXP 102
42276: PPUSH
42277: LD_VAR 0 2
42281: PUSH
42282: LD_INT 1
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PPUSH
42289: EMPTY
42290: PPUSH
42291: CALL 69655 0 3
42295: ST_TO_ADDR
42296: GO 42368
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42298: LD_ADDR_EXP 102
42302: PUSH
42303: LD_EXP 102
42307: PPUSH
42308: LD_VAR 0 2
42312: PUSH
42313: LD_INT 1
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: LD_EXP 102
42324: PUSH
42325: LD_VAR 0 2
42329: ARRAY
42330: PUSH
42331: LD_INT 1
42333: ARRAY
42334: PPUSH
42335: LD_INT 3
42337: PUSH
42338: LD_INT 24
42340: PUSH
42341: LD_INT 1000
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PPUSH
42352: CALL_OW 72
42356: PUSH
42357: LD_VAR 0 6
42361: UNION
42362: PPUSH
42363: CALL 69655 0 3
42367: ST_TO_ADDR
// if not need_heal_2 then
42368: LD_VAR 0 7
42372: NOT
42373: IFFALSE 42406
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42375: LD_ADDR_EXP 102
42379: PUSH
42380: LD_EXP 102
42384: PPUSH
42385: LD_VAR 0 2
42389: PUSH
42390: LD_INT 2
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PPUSH
42397: EMPTY
42398: PPUSH
42399: CALL 69655 0 3
42403: ST_TO_ADDR
42404: GO 42438
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42406: LD_ADDR_EXP 102
42410: PUSH
42411: LD_EXP 102
42415: PPUSH
42416: LD_VAR 0 2
42420: PUSH
42421: LD_INT 2
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PPUSH
42428: LD_VAR 0 7
42432: PPUSH
42433: CALL 69655 0 3
42437: ST_TO_ADDR
// if need_heal_2 then
42438: LD_VAR 0 7
42442: IFFALSE 42614
// for j in need_heal_2 do
42444: LD_ADDR_VAR 0 3
42448: PUSH
42449: LD_VAR 0 7
42453: PUSH
42454: FOR_IN
42455: IFFALSE 42612
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42457: LD_ADDR_VAR 0 5
42461: PUSH
42462: LD_EXP 99
42466: PUSH
42467: LD_VAR 0 2
42471: ARRAY
42472: PPUSH
42473: LD_INT 2
42475: PUSH
42476: LD_INT 30
42478: PUSH
42479: LD_INT 6
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: LD_INT 30
42488: PUSH
42489: LD_INT 7
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 30
42498: PUSH
42499: LD_INT 8
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 30
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 30
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 25
42528: PUSH
42529: LD_INT 4
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: PPUSH
42545: CALL_OW 72
42549: ST_TO_ADDR
// if tmp then
42550: LD_VAR 0 5
42554: IFFALSE 42610
// begin k := NearestUnitToUnit ( tmp , j ) ;
42556: LD_ADDR_VAR 0 4
42560: PUSH
42561: LD_VAR 0 5
42565: PPUSH
42566: LD_VAR 0 3
42570: PPUSH
42571: CALL_OW 74
42575: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42576: LD_VAR 0 3
42580: PPUSH
42581: LD_VAR 0 4
42585: PPUSH
42586: CALL_OW 296
42590: PUSH
42591: LD_INT 7
42593: GREATER
42594: IFFALSE 42610
// ComMoveUnit ( j , k ) ;
42596: LD_VAR 0 3
42600: PPUSH
42601: LD_VAR 0 4
42605: PPUSH
42606: CALL_OW 112
// end ; end ;
42610: GO 42454
42612: POP
42613: POP
// if not need_heal_1 and not need_heal_2 then
42614: LD_VAR 0 6
42618: NOT
42619: PUSH
42620: LD_VAR 0 7
42624: NOT
42625: AND
42626: IFFALSE 42630
// continue ;
42628: GO 42083
// end ;
42630: GO 42083
42632: POP
42633: POP
// RaiseSailEvent ( 102 ) ;
42634: LD_INT 102
42636: PPUSH
42637: CALL_OW 427
// end ;
42641: LD_VAR 0 1
42645: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
42646: LD_INT 0
42648: PPUSH
42649: PPUSH
42650: PPUSH
42651: PPUSH
42652: PPUSH
// if not mc_bases then
42653: LD_EXP 99
42657: NOT
42658: IFFALSE 42662
// exit ;
42660: GO 43047
// for i = 1 to mc_bases do
42662: LD_ADDR_VAR 0 2
42666: PUSH
42667: DOUBLE
42668: LD_INT 1
42670: DEC
42671: ST_TO_ADDR
42672: LD_EXP 99
42676: PUSH
42677: FOR_TO
42678: IFFALSE 43045
// begin if not mc_building_need_repair [ i ] then
42680: LD_EXP 100
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: NOT
42691: IFFALSE 42729
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42693: LD_ADDR_EXP 101
42697: PUSH
42698: LD_EXP 101
42702: PPUSH
42703: LD_VAR 0 2
42707: PPUSH
42708: EMPTY
42709: PPUSH
42710: CALL_OW 1
42714: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42715: LD_VAR 0 2
42719: PPUSH
42720: LD_INT 101
42722: PPUSH
42723: CALL 37767 0 2
// continue ;
42727: GO 42677
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42729: LD_ADDR_EXP 105
42733: PUSH
42734: LD_EXP 105
42738: PPUSH
42739: LD_VAR 0 2
42743: PPUSH
42744: EMPTY
42745: PPUSH
42746: CALL_OW 1
42750: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42751: LD_VAR 0 2
42755: PPUSH
42756: LD_INT 103
42758: PPUSH
42759: CALL 37767 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
42763: LD_ADDR_VAR 0 5
42767: PUSH
42768: LD_EXP 99
42772: PUSH
42773: LD_VAR 0 2
42777: ARRAY
42778: PUSH
42779: LD_EXP 128
42783: PUSH
42784: LD_VAR 0 2
42788: ARRAY
42789: UNION
42790: PPUSH
42791: LD_INT 2
42793: PUSH
42794: LD_INT 25
42796: PUSH
42797: LD_INT 2
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 25
42806: PUSH
42807: LD_INT 16
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: LIST
42818: PUSH
42819: EMPTY
42820: LIST
42821: PPUSH
42822: CALL_OW 72
42826: ST_TO_ADDR
// if not tmp then
42827: LD_VAR 0 5
42831: NOT
42832: IFFALSE 42836
// continue ;
42834: GO 42677
// for j in tmp do
42836: LD_ADDR_VAR 0 3
42840: PUSH
42841: LD_VAR 0 5
42845: PUSH
42846: FOR_IN
42847: IFFALSE 43041
// begin if mc_need_heal [ i ] then
42849: LD_EXP 102
42853: PUSH
42854: LD_VAR 0 2
42858: ARRAY
42859: IFFALSE 42907
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
42861: LD_VAR 0 3
42865: PUSH
42866: LD_EXP 102
42870: PUSH
42871: LD_VAR 0 2
42875: ARRAY
42876: PUSH
42877: LD_INT 1
42879: ARRAY
42880: IN
42881: PUSH
42882: LD_VAR 0 3
42886: PUSH
42887: LD_EXP 102
42891: PUSH
42892: LD_VAR 0 2
42896: ARRAY
42897: PUSH
42898: LD_INT 2
42900: ARRAY
42901: IN
42902: OR
42903: IFFALSE 42907
// continue ;
42905: GO 42846
// if IsInUnit ( j ) then
42907: LD_VAR 0 3
42911: PPUSH
42912: CALL_OW 310
42916: IFFALSE 42927
// ComExitBuilding ( j ) ;
42918: LD_VAR 0 3
42922: PPUSH
42923: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
42927: LD_VAR 0 3
42931: PUSH
42932: LD_EXP 101
42936: PUSH
42937: LD_VAR 0 2
42941: ARRAY
42942: IN
42943: NOT
42944: IFFALSE 43002
// begin SetTag ( j , 101 ) ;
42946: LD_VAR 0 3
42950: PPUSH
42951: LD_INT 101
42953: PPUSH
42954: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
42958: LD_ADDR_EXP 101
42962: PUSH
42963: LD_EXP 101
42967: PPUSH
42968: LD_VAR 0 2
42972: PUSH
42973: LD_EXP 101
42977: PUSH
42978: LD_VAR 0 2
42982: ARRAY
42983: PUSH
42984: LD_INT 1
42986: PLUS
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PPUSH
42992: LD_VAR 0 3
42996: PPUSH
42997: CALL 69655 0 3
43001: ST_TO_ADDR
// end ; wait ( 1 ) ;
43002: LD_INT 1
43004: PPUSH
43005: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43009: LD_VAR 0 3
43013: PPUSH
43014: LD_EXP 100
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PPUSH
43025: LD_VAR 0 3
43029: PPUSH
43030: CALL_OW 74
43034: PPUSH
43035: CALL_OW 130
// end ;
43039: GO 42846
43041: POP
43042: POP
// end ;
43043: GO 42677
43045: POP
43046: POP
// end ;
43047: LD_VAR 0 1
43051: RET
// export function MC_Heal ; var i , j , tmp ; begin
43052: LD_INT 0
43054: PPUSH
43055: PPUSH
43056: PPUSH
43057: PPUSH
// if not mc_bases then
43058: LD_EXP 99
43062: NOT
43063: IFFALSE 43067
// exit ;
43065: GO 43469
// for i = 1 to mc_bases do
43067: LD_ADDR_VAR 0 2
43071: PUSH
43072: DOUBLE
43073: LD_INT 1
43075: DEC
43076: ST_TO_ADDR
43077: LD_EXP 99
43081: PUSH
43082: FOR_TO
43083: IFFALSE 43467
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43085: LD_EXP 102
43089: PUSH
43090: LD_VAR 0 2
43094: ARRAY
43095: PUSH
43096: LD_INT 1
43098: ARRAY
43099: NOT
43100: PUSH
43101: LD_EXP 102
43105: PUSH
43106: LD_VAR 0 2
43110: ARRAY
43111: PUSH
43112: LD_INT 2
43114: ARRAY
43115: NOT
43116: AND
43117: IFFALSE 43155
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43119: LD_ADDR_EXP 103
43123: PUSH
43124: LD_EXP 103
43128: PPUSH
43129: LD_VAR 0 2
43133: PPUSH
43134: EMPTY
43135: PPUSH
43136: CALL_OW 1
43140: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43141: LD_VAR 0 2
43145: PPUSH
43146: LD_INT 102
43148: PPUSH
43149: CALL 37767 0 2
// continue ;
43153: GO 43082
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43155: LD_ADDR_VAR 0 4
43159: PUSH
43160: LD_EXP 99
43164: PUSH
43165: LD_VAR 0 2
43169: ARRAY
43170: PPUSH
43171: LD_INT 25
43173: PUSH
43174: LD_INT 4
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PPUSH
43181: CALL_OW 72
43185: ST_TO_ADDR
// if not tmp then
43186: LD_VAR 0 4
43190: NOT
43191: IFFALSE 43195
// continue ;
43193: GO 43082
// if mc_taming [ i ] then
43195: LD_EXP 130
43199: PUSH
43200: LD_VAR 0 2
43204: ARRAY
43205: IFFALSE 43229
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43207: LD_ADDR_EXP 130
43211: PUSH
43212: LD_EXP 130
43216: PPUSH
43217: LD_VAR 0 2
43221: PPUSH
43222: EMPTY
43223: PPUSH
43224: CALL_OW 1
43228: ST_TO_ADDR
// for j in tmp do
43229: LD_ADDR_VAR 0 3
43233: PUSH
43234: LD_VAR 0 4
43238: PUSH
43239: FOR_IN
43240: IFFALSE 43463
// begin if IsInUnit ( j ) then
43242: LD_VAR 0 3
43246: PPUSH
43247: CALL_OW 310
43251: IFFALSE 43262
// ComExitBuilding ( j ) ;
43253: LD_VAR 0 3
43257: PPUSH
43258: CALL_OW 122
// if not j in mc_healers [ i ] then
43262: LD_VAR 0 3
43266: PUSH
43267: LD_EXP 103
43271: PUSH
43272: LD_VAR 0 2
43276: ARRAY
43277: IN
43278: NOT
43279: IFFALSE 43325
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43281: LD_ADDR_EXP 103
43285: PUSH
43286: LD_EXP 103
43290: PPUSH
43291: LD_VAR 0 2
43295: PUSH
43296: LD_EXP 103
43300: PUSH
43301: LD_VAR 0 2
43305: ARRAY
43306: PUSH
43307: LD_INT 1
43309: PLUS
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PPUSH
43315: LD_VAR 0 3
43319: PPUSH
43320: CALL 69655 0 3
43324: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43325: LD_VAR 0 3
43329: PPUSH
43330: CALL_OW 110
43334: PUSH
43335: LD_INT 102
43337: NONEQUAL
43338: IFFALSE 43352
// SetTag ( j , 102 ) ;
43340: LD_VAR 0 3
43344: PPUSH
43345: LD_INT 102
43347: PPUSH
43348: CALL_OW 109
// Wait ( 3 ) ;
43352: LD_INT 3
43354: PPUSH
43355: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43359: LD_EXP 102
43363: PUSH
43364: LD_VAR 0 2
43368: ARRAY
43369: PUSH
43370: LD_INT 1
43372: ARRAY
43373: IFFALSE 43405
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43375: LD_VAR 0 3
43379: PPUSH
43380: LD_EXP 102
43384: PUSH
43385: LD_VAR 0 2
43389: ARRAY
43390: PUSH
43391: LD_INT 1
43393: ARRAY
43394: PUSH
43395: LD_INT 1
43397: ARRAY
43398: PPUSH
43399: CALL_OW 128
43403: GO 43461
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43405: LD_VAR 0 3
43409: PPUSH
43410: CALL_OW 314
43414: NOT
43415: PUSH
43416: LD_EXP 102
43420: PUSH
43421: LD_VAR 0 2
43425: ARRAY
43426: PUSH
43427: LD_INT 2
43429: ARRAY
43430: AND
43431: IFFALSE 43461
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43433: LD_VAR 0 3
43437: PPUSH
43438: LD_EXP 102
43442: PUSH
43443: LD_VAR 0 2
43447: ARRAY
43448: PUSH
43449: LD_INT 2
43451: ARRAY
43452: PUSH
43453: LD_INT 1
43455: ARRAY
43456: PPUSH
43457: CALL_OW 128
// end ;
43461: GO 43239
43463: POP
43464: POP
// end ;
43465: GO 43082
43467: POP
43468: POP
// end ;
43469: LD_VAR 0 1
43473: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43474: LD_INT 0
43476: PPUSH
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
// if not mc_bases then
43481: LD_EXP 99
43485: NOT
43486: IFFALSE 43490
// exit ;
43488: GO 44633
// for i = 1 to mc_bases do
43490: LD_ADDR_VAR 0 2
43494: PUSH
43495: DOUBLE
43496: LD_INT 1
43498: DEC
43499: ST_TO_ADDR
43500: LD_EXP 99
43504: PUSH
43505: FOR_TO
43506: IFFALSE 44631
// begin if mc_scan [ i ] then
43508: LD_EXP 122
43512: PUSH
43513: LD_VAR 0 2
43517: ARRAY
43518: IFFALSE 43522
// continue ;
43520: GO 43505
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43522: LD_EXP 104
43526: PUSH
43527: LD_VAR 0 2
43531: ARRAY
43532: NOT
43533: PUSH
43534: LD_EXP 106
43538: PUSH
43539: LD_VAR 0 2
43543: ARRAY
43544: NOT
43545: AND
43546: PUSH
43547: LD_EXP 105
43551: PUSH
43552: LD_VAR 0 2
43556: ARRAY
43557: AND
43558: IFFALSE 43596
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43560: LD_ADDR_EXP 105
43564: PUSH
43565: LD_EXP 105
43569: PPUSH
43570: LD_VAR 0 2
43574: PPUSH
43575: EMPTY
43576: PPUSH
43577: CALL_OW 1
43581: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43582: LD_VAR 0 2
43586: PPUSH
43587: LD_INT 103
43589: PPUSH
43590: CALL 37767 0 2
// continue ;
43594: GO 43505
// end ; if mc_construct_list [ i ] then
43596: LD_EXP 106
43600: PUSH
43601: LD_VAR 0 2
43605: ARRAY
43606: IFFALSE 43826
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43608: LD_ADDR_VAR 0 4
43612: PUSH
43613: LD_EXP 99
43617: PUSH
43618: LD_VAR 0 2
43622: ARRAY
43623: PPUSH
43624: LD_INT 25
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PPUSH
43634: CALL_OW 72
43638: PUSH
43639: LD_EXP 101
43643: PUSH
43644: LD_VAR 0 2
43648: ARRAY
43649: DIFF
43650: ST_TO_ADDR
// if not tmp then
43651: LD_VAR 0 4
43655: NOT
43656: IFFALSE 43660
// continue ;
43658: GO 43505
// for j in tmp do
43660: LD_ADDR_VAR 0 3
43664: PUSH
43665: LD_VAR 0 4
43669: PUSH
43670: FOR_IN
43671: IFFALSE 43822
// begin if not mc_builders [ i ] then
43673: LD_EXP 105
43677: PUSH
43678: LD_VAR 0 2
43682: ARRAY
43683: NOT
43684: IFFALSE 43742
// begin SetTag ( j , 103 ) ;
43686: LD_VAR 0 3
43690: PPUSH
43691: LD_INT 103
43693: PPUSH
43694: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43698: LD_ADDR_EXP 105
43702: PUSH
43703: LD_EXP 105
43707: PPUSH
43708: LD_VAR 0 2
43712: PUSH
43713: LD_EXP 105
43717: PUSH
43718: LD_VAR 0 2
43722: ARRAY
43723: PUSH
43724: LD_INT 1
43726: PLUS
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PPUSH
43732: LD_VAR 0 3
43736: PPUSH
43737: CALL 69655 0 3
43741: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43742: LD_VAR 0 3
43746: PPUSH
43747: CALL_OW 310
43751: IFFALSE 43762
// ComExitBuilding ( j ) ;
43753: LD_VAR 0 3
43757: PPUSH
43758: CALL_OW 122
// wait ( 3 ) ;
43762: LD_INT 3
43764: PPUSH
43765: CALL_OW 67
// if not mc_construct_list [ i ] then
43769: LD_EXP 106
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: NOT
43780: IFFALSE 43784
// break ;
43782: GO 43822
// if not HasTask ( j ) then
43784: LD_VAR 0 3
43788: PPUSH
43789: CALL_OW 314
43793: NOT
43794: IFFALSE 43820
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
43796: LD_VAR 0 3
43800: PPUSH
43801: LD_EXP 106
43805: PUSH
43806: LD_VAR 0 2
43810: ARRAY
43811: PUSH
43812: LD_INT 1
43814: ARRAY
43815: PPUSH
43816: CALL 72506 0 2
// end ;
43820: GO 43670
43822: POP
43823: POP
// end else
43824: GO 44629
// if mc_build_list [ i ] then
43826: LD_EXP 104
43830: PUSH
43831: LD_VAR 0 2
43835: ARRAY
43836: IFFALSE 44629
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43838: LD_ADDR_VAR 0 5
43842: PUSH
43843: LD_EXP 99
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PPUSH
43854: LD_INT 2
43856: PUSH
43857: LD_INT 30
43859: PUSH
43860: LD_INT 0
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 30
43869: PUSH
43870: LD_INT 1
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: LIST
43881: PPUSH
43882: CALL_OW 72
43886: ST_TO_ADDR
// if depot then
43887: LD_VAR 0 5
43891: IFFALSE 43909
// depot := depot [ 1 ] else
43893: LD_ADDR_VAR 0 5
43897: PUSH
43898: LD_VAR 0 5
43902: PUSH
43903: LD_INT 1
43905: ARRAY
43906: ST_TO_ADDR
43907: GO 43917
// depot := 0 ;
43909: LD_ADDR_VAR 0 5
43913: PUSH
43914: LD_INT 0
43916: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
43917: LD_EXP 104
43921: PUSH
43922: LD_VAR 0 2
43926: ARRAY
43927: PUSH
43928: LD_INT 1
43930: ARRAY
43931: PUSH
43932: LD_INT 1
43934: ARRAY
43935: PPUSH
43936: CALL 72336 0 1
43940: PUSH
43941: LD_EXP 99
43945: PUSH
43946: LD_VAR 0 2
43950: ARRAY
43951: PPUSH
43952: LD_INT 2
43954: PUSH
43955: LD_INT 30
43957: PUSH
43958: LD_INT 2
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 30
43967: PUSH
43968: LD_INT 3
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: LIST
43979: PPUSH
43980: CALL_OW 72
43984: NOT
43985: AND
43986: IFFALSE 44091
// begin for j = 1 to mc_build_list [ i ] do
43988: LD_ADDR_VAR 0 3
43992: PUSH
43993: DOUBLE
43994: LD_INT 1
43996: DEC
43997: ST_TO_ADDR
43998: LD_EXP 104
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PUSH
44009: FOR_TO
44010: IFFALSE 44089
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44012: LD_EXP 104
44016: PUSH
44017: LD_VAR 0 2
44021: ARRAY
44022: PUSH
44023: LD_VAR 0 3
44027: ARRAY
44028: PUSH
44029: LD_INT 1
44031: ARRAY
44032: PUSH
44033: LD_INT 2
44035: EQUAL
44036: IFFALSE 44087
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44038: LD_ADDR_EXP 104
44042: PUSH
44043: LD_EXP 104
44047: PPUSH
44048: LD_VAR 0 2
44052: PPUSH
44053: LD_EXP 104
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: PPUSH
44064: LD_VAR 0 3
44068: PPUSH
44069: LD_INT 1
44071: PPUSH
44072: LD_INT 0
44074: PPUSH
44075: CALL 69073 0 4
44079: PPUSH
44080: CALL_OW 1
44084: ST_TO_ADDR
// break ;
44085: GO 44089
// end ;
44087: GO 44009
44089: POP
44090: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44091: LD_EXP 104
44095: PUSH
44096: LD_VAR 0 2
44100: ARRAY
44101: PUSH
44102: LD_INT 1
44104: ARRAY
44105: PUSH
44106: LD_INT 1
44108: ARRAY
44109: PUSH
44110: LD_INT 0
44112: EQUAL
44113: PUSH
44114: LD_VAR 0 5
44118: PUSH
44119: LD_VAR 0 5
44123: PPUSH
44124: LD_EXP 104
44128: PUSH
44129: LD_VAR 0 2
44133: ARRAY
44134: PUSH
44135: LD_INT 1
44137: ARRAY
44138: PUSH
44139: LD_INT 1
44141: ARRAY
44142: PPUSH
44143: LD_EXP 104
44147: PUSH
44148: LD_VAR 0 2
44152: ARRAY
44153: PUSH
44154: LD_INT 1
44156: ARRAY
44157: PUSH
44158: LD_INT 2
44160: ARRAY
44161: PPUSH
44162: LD_EXP 104
44166: PUSH
44167: LD_VAR 0 2
44171: ARRAY
44172: PUSH
44173: LD_INT 1
44175: ARRAY
44176: PUSH
44177: LD_INT 3
44179: ARRAY
44180: PPUSH
44181: LD_EXP 104
44185: PUSH
44186: LD_VAR 0 2
44190: ARRAY
44191: PUSH
44192: LD_INT 1
44194: ARRAY
44195: PUSH
44196: LD_INT 4
44198: ARRAY
44199: PPUSH
44200: CALL 77052 0 5
44204: AND
44205: OR
44206: IFFALSE 44487
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44208: LD_ADDR_VAR 0 4
44212: PUSH
44213: LD_EXP 99
44217: PUSH
44218: LD_VAR 0 2
44222: ARRAY
44223: PPUSH
44224: LD_INT 25
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PPUSH
44234: CALL_OW 72
44238: PUSH
44239: LD_EXP 101
44243: PUSH
44244: LD_VAR 0 2
44248: ARRAY
44249: DIFF
44250: ST_TO_ADDR
// if not tmp then
44251: LD_VAR 0 4
44255: NOT
44256: IFFALSE 44260
// continue ;
44258: GO 43505
// for j in tmp do
44260: LD_ADDR_VAR 0 3
44264: PUSH
44265: LD_VAR 0 4
44269: PUSH
44270: FOR_IN
44271: IFFALSE 44483
// begin if not mc_builders [ i ] then
44273: LD_EXP 105
44277: PUSH
44278: LD_VAR 0 2
44282: ARRAY
44283: NOT
44284: IFFALSE 44342
// begin SetTag ( j , 103 ) ;
44286: LD_VAR 0 3
44290: PPUSH
44291: LD_INT 103
44293: PPUSH
44294: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44298: LD_ADDR_EXP 105
44302: PUSH
44303: LD_EXP 105
44307: PPUSH
44308: LD_VAR 0 2
44312: PUSH
44313: LD_EXP 105
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PUSH
44324: LD_INT 1
44326: PLUS
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PPUSH
44332: LD_VAR 0 3
44336: PPUSH
44337: CALL 69655 0 3
44341: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44342: LD_VAR 0 3
44346: PPUSH
44347: CALL_OW 310
44351: IFFALSE 44362
// ComExitBuilding ( j ) ;
44353: LD_VAR 0 3
44357: PPUSH
44358: CALL_OW 122
// wait ( 3 ) ;
44362: LD_INT 3
44364: PPUSH
44365: CALL_OW 67
// if not mc_build_list [ i ] then
44369: LD_EXP 104
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: NOT
44380: IFFALSE 44384
// break ;
44382: GO 44483
// if not HasTask ( j ) then
44384: LD_VAR 0 3
44388: PPUSH
44389: CALL_OW 314
44393: NOT
44394: IFFALSE 44481
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44396: LD_VAR 0 3
44400: PPUSH
44401: LD_EXP 104
44405: PUSH
44406: LD_VAR 0 2
44410: ARRAY
44411: PUSH
44412: LD_INT 1
44414: ARRAY
44415: PUSH
44416: LD_INT 1
44418: ARRAY
44419: PPUSH
44420: LD_EXP 104
44424: PUSH
44425: LD_VAR 0 2
44429: ARRAY
44430: PUSH
44431: LD_INT 1
44433: ARRAY
44434: PUSH
44435: LD_INT 2
44437: ARRAY
44438: PPUSH
44439: LD_EXP 104
44443: PUSH
44444: LD_VAR 0 2
44448: ARRAY
44449: PUSH
44450: LD_INT 1
44452: ARRAY
44453: PUSH
44454: LD_INT 3
44456: ARRAY
44457: PPUSH
44458: LD_EXP 104
44462: PUSH
44463: LD_VAR 0 2
44467: ARRAY
44468: PUSH
44469: LD_INT 1
44471: ARRAY
44472: PUSH
44473: LD_INT 4
44475: ARRAY
44476: PPUSH
44477: CALL_OW 145
// end ;
44481: GO 44270
44483: POP
44484: POP
// end else
44485: GO 44629
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44487: LD_EXP 99
44491: PUSH
44492: LD_VAR 0 2
44496: ARRAY
44497: PPUSH
44498: LD_EXP 104
44502: PUSH
44503: LD_VAR 0 2
44507: ARRAY
44508: PUSH
44509: LD_INT 1
44511: ARRAY
44512: PUSH
44513: LD_INT 1
44515: ARRAY
44516: PPUSH
44517: LD_EXP 104
44521: PUSH
44522: LD_VAR 0 2
44526: ARRAY
44527: PUSH
44528: LD_INT 1
44530: ARRAY
44531: PUSH
44532: LD_INT 2
44534: ARRAY
44535: PPUSH
44536: LD_EXP 104
44540: PUSH
44541: LD_VAR 0 2
44545: ARRAY
44546: PUSH
44547: LD_INT 1
44549: ARRAY
44550: PUSH
44551: LD_INT 3
44553: ARRAY
44554: PPUSH
44555: LD_EXP 104
44559: PUSH
44560: LD_VAR 0 2
44564: ARRAY
44565: PUSH
44566: LD_INT 1
44568: ARRAY
44569: PUSH
44570: LD_INT 4
44572: ARRAY
44573: PPUSH
44574: CALL 76406 0 5
44578: NOT
44579: IFFALSE 44629
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
44581: LD_ADDR_EXP 104
44585: PUSH
44586: LD_EXP 104
44590: PPUSH
44591: LD_VAR 0 2
44595: PPUSH
44596: LD_EXP 104
44600: PUSH
44601: LD_VAR 0 2
44605: ARRAY
44606: PPUSH
44607: LD_INT 1
44609: PPUSH
44610: LD_INT 1
44612: NEG
44613: PPUSH
44614: LD_INT 0
44616: PPUSH
44617: CALL 69073 0 4
44621: PPUSH
44622: CALL_OW 1
44626: ST_TO_ADDR
// continue ;
44627: GO 43505
// end ; end ; end ;
44629: GO 43505
44631: POP
44632: POP
// end ;
44633: LD_VAR 0 1
44637: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
44638: LD_INT 0
44640: PPUSH
44641: PPUSH
44642: PPUSH
44643: PPUSH
44644: PPUSH
44645: PPUSH
// if not mc_bases then
44646: LD_EXP 99
44650: NOT
44651: IFFALSE 44655
// exit ;
44653: GO 45082
// for i = 1 to mc_bases do
44655: LD_ADDR_VAR 0 2
44659: PUSH
44660: DOUBLE
44661: LD_INT 1
44663: DEC
44664: ST_TO_ADDR
44665: LD_EXP 99
44669: PUSH
44670: FOR_TO
44671: IFFALSE 45080
// begin tmp := mc_build_upgrade [ i ] ;
44673: LD_ADDR_VAR 0 4
44677: PUSH
44678: LD_EXP 131
44682: PUSH
44683: LD_VAR 0 2
44687: ARRAY
44688: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
44689: LD_ADDR_VAR 0 6
44693: PUSH
44694: LD_EXP 132
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: PPUSH
44705: LD_INT 2
44707: PUSH
44708: LD_INT 30
44710: PUSH
44711: LD_INT 6
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 30
44720: PUSH
44721: LD_INT 7
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: LIST
44732: PPUSH
44733: CALL_OW 72
44737: ST_TO_ADDR
// if not tmp and not lab then
44738: LD_VAR 0 4
44742: NOT
44743: PUSH
44744: LD_VAR 0 6
44748: NOT
44749: AND
44750: IFFALSE 44754
// continue ;
44752: GO 44670
// if tmp then
44754: LD_VAR 0 4
44758: IFFALSE 44878
// for j in tmp do
44760: LD_ADDR_VAR 0 3
44764: PUSH
44765: LD_VAR 0 4
44769: PUSH
44770: FOR_IN
44771: IFFALSE 44876
// begin if UpgradeCost ( j ) then
44773: LD_VAR 0 3
44777: PPUSH
44778: CALL 76066 0 1
44782: IFFALSE 44874
// begin ComUpgrade ( j ) ;
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
44793: LD_ADDR_EXP 131
44797: PUSH
44798: LD_EXP 131
44802: PPUSH
44803: LD_VAR 0 2
44807: PPUSH
44808: LD_EXP 131
44812: PUSH
44813: LD_VAR 0 2
44817: ARRAY
44818: PUSH
44819: LD_VAR 0 3
44823: DIFF
44824: PPUSH
44825: CALL_OW 1
44829: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44830: LD_ADDR_EXP 106
44834: PUSH
44835: LD_EXP 106
44839: PPUSH
44840: LD_VAR 0 2
44844: PUSH
44845: LD_EXP 106
44849: PUSH
44850: LD_VAR 0 2
44854: ARRAY
44855: PUSH
44856: LD_INT 1
44858: PLUS
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PPUSH
44864: LD_VAR 0 3
44868: PPUSH
44869: CALL 69655 0 3
44873: ST_TO_ADDR
// end ; end ;
44874: GO 44770
44876: POP
44877: POP
// if not lab or not mc_lab_upgrade [ i ] then
44878: LD_VAR 0 6
44882: NOT
44883: PUSH
44884: LD_EXP 133
44888: PUSH
44889: LD_VAR 0 2
44893: ARRAY
44894: NOT
44895: OR
44896: IFFALSE 44900
// continue ;
44898: GO 44670
// for j in lab do
44900: LD_ADDR_VAR 0 3
44904: PUSH
44905: LD_VAR 0 6
44909: PUSH
44910: FOR_IN
44911: IFFALSE 45076
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
44913: LD_VAR 0 3
44917: PPUSH
44918: CALL_OW 266
44922: PUSH
44923: LD_INT 6
44925: PUSH
44926: LD_INT 7
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: IN
44933: PUSH
44934: LD_VAR 0 3
44938: PPUSH
44939: CALL_OW 461
44943: PUSH
44944: LD_INT 1
44946: NONEQUAL
44947: AND
44948: IFFALSE 45074
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
44950: LD_VAR 0 3
44954: PPUSH
44955: LD_EXP 133
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PUSH
44966: LD_INT 1
44968: ARRAY
44969: PPUSH
44970: CALL 76271 0 2
44974: IFFALSE 45074
// begin ComCancel ( j ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
44985: LD_VAR 0 3
44989: PPUSH
44990: LD_EXP 133
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: PUSH
45001: LD_INT 1
45003: ARRAY
45004: PPUSH
45005: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45009: LD_VAR 0 3
45013: PUSH
45014: LD_EXP 106
45018: PUSH
45019: LD_VAR 0 2
45023: ARRAY
45024: IN
45025: NOT
45026: IFFALSE 45072
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45028: LD_ADDR_EXP 106
45032: PUSH
45033: LD_EXP 106
45037: PPUSH
45038: LD_VAR 0 2
45042: PUSH
45043: LD_EXP 106
45047: PUSH
45048: LD_VAR 0 2
45052: ARRAY
45053: PUSH
45054: LD_INT 1
45056: PLUS
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PPUSH
45062: LD_VAR 0 3
45066: PPUSH
45067: CALL 69655 0 3
45071: ST_TO_ADDR
// break ;
45072: GO 45076
// end ; end ; end ;
45074: GO 44910
45076: POP
45077: POP
// end ;
45078: GO 44670
45080: POP
45081: POP
// end ;
45082: LD_VAR 0 1
45086: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45087: LD_INT 0
45089: PPUSH
45090: PPUSH
45091: PPUSH
45092: PPUSH
45093: PPUSH
45094: PPUSH
45095: PPUSH
45096: PPUSH
45097: PPUSH
// if not mc_bases then
45098: LD_EXP 99
45102: NOT
45103: IFFALSE 45107
// exit ;
45105: GO 45512
// for i = 1 to mc_bases do
45107: LD_ADDR_VAR 0 2
45111: PUSH
45112: DOUBLE
45113: LD_INT 1
45115: DEC
45116: ST_TO_ADDR
45117: LD_EXP 99
45121: PUSH
45122: FOR_TO
45123: IFFALSE 45510
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45125: LD_EXP 107
45129: PUSH
45130: LD_VAR 0 2
45134: ARRAY
45135: NOT
45136: PUSH
45137: LD_EXP 99
45141: PUSH
45142: LD_VAR 0 2
45146: ARRAY
45147: PPUSH
45148: LD_INT 30
45150: PUSH
45151: LD_INT 3
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PPUSH
45158: CALL_OW 72
45162: NOT
45163: OR
45164: IFFALSE 45168
// continue ;
45166: GO 45122
// busy := false ;
45168: LD_ADDR_VAR 0 8
45172: PUSH
45173: LD_INT 0
45175: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45176: LD_ADDR_VAR 0 4
45180: PUSH
45181: LD_EXP 99
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: PPUSH
45192: LD_INT 30
45194: PUSH
45195: LD_INT 3
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PPUSH
45202: CALL_OW 72
45206: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45207: LD_ADDR_VAR 0 6
45211: PUSH
45212: LD_EXP 107
45216: PUSH
45217: LD_VAR 0 2
45221: ARRAY
45222: PPUSH
45223: LD_INT 2
45225: PUSH
45226: LD_INT 30
45228: PUSH
45229: LD_INT 32
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 30
45238: PUSH
45239: LD_INT 33
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: LIST
45250: PPUSH
45251: CALL_OW 72
45255: ST_TO_ADDR
// if not t then
45256: LD_VAR 0 6
45260: NOT
45261: IFFALSE 45265
// continue ;
45263: GO 45122
// for j in tmp do
45265: LD_ADDR_VAR 0 3
45269: PUSH
45270: LD_VAR 0 4
45274: PUSH
45275: FOR_IN
45276: IFFALSE 45306
// if not BuildingStatus ( j ) = bs_idle then
45278: LD_VAR 0 3
45282: PPUSH
45283: CALL_OW 461
45287: PUSH
45288: LD_INT 2
45290: EQUAL
45291: NOT
45292: IFFALSE 45304
// begin busy := true ;
45294: LD_ADDR_VAR 0 8
45298: PUSH
45299: LD_INT 1
45301: ST_TO_ADDR
// break ;
45302: GO 45306
// end ;
45304: GO 45275
45306: POP
45307: POP
// if busy then
45308: LD_VAR 0 8
45312: IFFALSE 45316
// continue ;
45314: GO 45122
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45316: LD_ADDR_VAR 0 7
45320: PUSH
45321: LD_VAR 0 6
45325: PPUSH
45326: LD_INT 35
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PPUSH
45336: CALL_OW 72
45340: ST_TO_ADDR
// if tw then
45341: LD_VAR 0 7
45345: IFFALSE 45422
// begin tw := tw [ 1 ] ;
45347: LD_ADDR_VAR 0 7
45351: PUSH
45352: LD_VAR 0 7
45356: PUSH
45357: LD_INT 1
45359: ARRAY
45360: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45361: LD_ADDR_VAR 0 9
45365: PUSH
45366: LD_VAR 0 7
45370: PPUSH
45371: LD_EXP 124
45375: PUSH
45376: LD_VAR 0 2
45380: ARRAY
45381: PPUSH
45382: CALL 74625 0 2
45386: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45387: LD_EXP 138
45391: PUSH
45392: LD_VAR 0 2
45396: ARRAY
45397: IFFALSE 45420
// if not weapon in mc_allowed_tower_weapons [ i ] then
45399: LD_VAR 0 9
45403: PUSH
45404: LD_EXP 138
45408: PUSH
45409: LD_VAR 0 2
45413: ARRAY
45414: IN
45415: NOT
45416: IFFALSE 45420
// continue ;
45418: GO 45122
// end else
45420: GO 45485
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45422: LD_ADDR_VAR 0 5
45426: PUSH
45427: LD_EXP 107
45431: PUSH
45432: LD_VAR 0 2
45436: ARRAY
45437: PPUSH
45438: LD_VAR 0 4
45442: PPUSH
45443: CALL 104802 0 2
45447: ST_TO_ADDR
// if not tmp2 then
45448: LD_VAR 0 5
45452: NOT
45453: IFFALSE 45457
// continue ;
45455: GO 45122
// tw := tmp2 [ 1 ] ;
45457: LD_ADDR_VAR 0 7
45461: PUSH
45462: LD_VAR 0 5
45466: PUSH
45467: LD_INT 1
45469: ARRAY
45470: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45471: LD_ADDR_VAR 0 9
45475: PUSH
45476: LD_VAR 0 5
45480: PUSH
45481: LD_INT 2
45483: ARRAY
45484: ST_TO_ADDR
// end ; if not weapon then
45485: LD_VAR 0 9
45489: NOT
45490: IFFALSE 45494
// continue ;
45492: GO 45122
// ComPlaceWeapon ( tw , weapon ) ;
45494: LD_VAR 0 7
45498: PPUSH
45499: LD_VAR 0 9
45503: PPUSH
45504: CALL_OW 148
// end ;
45508: GO 45122
45510: POP
45511: POP
// end ;
45512: LD_VAR 0 1
45516: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
45522: PPUSH
45523: PPUSH
45524: PPUSH
// if not mc_bases then
45525: LD_EXP 99
45529: NOT
45530: IFFALSE 45534
// exit ;
45532: GO 46546
// for i = 1 to mc_bases do
45534: LD_ADDR_VAR 0 2
45538: PUSH
45539: DOUBLE
45540: LD_INT 1
45542: DEC
45543: ST_TO_ADDR
45544: LD_EXP 99
45548: PUSH
45549: FOR_TO
45550: IFFALSE 46544
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45552: LD_EXP 112
45556: PUSH
45557: LD_VAR 0 2
45561: ARRAY
45562: NOT
45563: PUSH
45564: LD_EXP 112
45568: PUSH
45569: LD_VAR 0 2
45573: ARRAY
45574: PUSH
45575: LD_EXP 113
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: EQUAL
45586: OR
45587: IFFALSE 45591
// continue ;
45589: GO 45549
// if mc_miners [ i ] then
45591: LD_EXP 113
45595: PUSH
45596: LD_VAR 0 2
45600: ARRAY
45601: IFFALSE 46231
// begin k := 1 ;
45603: LD_ADDR_VAR 0 4
45607: PUSH
45608: LD_INT 1
45610: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
45611: LD_ADDR_VAR 0 3
45615: PUSH
45616: DOUBLE
45617: LD_EXP 113
45621: PUSH
45622: LD_VAR 0 2
45626: ARRAY
45627: INC
45628: ST_TO_ADDR
45629: LD_INT 1
45631: PUSH
45632: FOR_DOWNTO
45633: IFFALSE 46229
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
45635: LD_EXP 113
45639: PUSH
45640: LD_VAR 0 2
45644: ARRAY
45645: PUSH
45646: LD_VAR 0 3
45650: ARRAY
45651: PPUSH
45652: CALL_OW 301
45656: PUSH
45657: LD_EXP 113
45661: PUSH
45662: LD_VAR 0 2
45666: ARRAY
45667: PUSH
45668: LD_VAR 0 3
45672: ARRAY
45673: PPUSH
45674: CALL_OW 257
45678: PUSH
45679: LD_INT 1
45681: NONEQUAL
45682: OR
45683: IFFALSE 45746
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
45685: LD_ADDR_VAR 0 5
45689: PUSH
45690: LD_EXP 113
45694: PUSH
45695: LD_VAR 0 2
45699: ARRAY
45700: PUSH
45701: LD_EXP 113
45705: PUSH
45706: LD_VAR 0 2
45710: ARRAY
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: DIFF
45718: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
45719: LD_ADDR_EXP 113
45723: PUSH
45724: LD_EXP 113
45728: PPUSH
45729: LD_VAR 0 2
45733: PPUSH
45734: LD_VAR 0 5
45738: PPUSH
45739: CALL_OW 1
45743: ST_TO_ADDR
// continue ;
45744: GO 45632
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
45746: LD_EXP 113
45750: PUSH
45751: LD_VAR 0 2
45755: ARRAY
45756: PUSH
45757: LD_VAR 0 3
45761: ARRAY
45762: PPUSH
45763: CALL 69591 0 1
45767: PUSH
45768: LD_EXP 113
45772: PUSH
45773: LD_VAR 0 2
45777: ARRAY
45778: PUSH
45779: LD_VAR 0 3
45783: ARRAY
45784: PPUSH
45785: CALL_OW 255
45789: PPUSH
45790: LD_EXP 112
45794: PUSH
45795: LD_VAR 0 2
45799: ARRAY
45800: PUSH
45801: LD_VAR 0 4
45805: ARRAY
45806: PUSH
45807: LD_INT 1
45809: ARRAY
45810: PPUSH
45811: LD_EXP 112
45815: PUSH
45816: LD_VAR 0 2
45820: ARRAY
45821: PUSH
45822: LD_VAR 0 4
45826: ARRAY
45827: PUSH
45828: LD_INT 2
45830: ARRAY
45831: PPUSH
45832: LD_INT 15
45834: PPUSH
45835: CALL 70551 0 4
45839: PUSH
45840: LD_INT 4
45842: ARRAY
45843: PUSH
45844: LD_EXP 113
45848: PUSH
45849: LD_VAR 0 2
45853: ARRAY
45854: PUSH
45855: LD_VAR 0 3
45859: ARRAY
45860: PPUSH
45861: LD_INT 10
45863: PPUSH
45864: CALL 72248 0 2
45868: PUSH
45869: LD_INT 4
45871: ARRAY
45872: OR
45873: AND
45874: IFFALSE 45897
// ComStop ( mc_miners [ i ] [ j ] ) ;
45876: LD_EXP 113
45880: PUSH
45881: LD_VAR 0 2
45885: ARRAY
45886: PUSH
45887: LD_VAR 0 3
45891: ARRAY
45892: PPUSH
45893: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
45897: LD_EXP 113
45901: PUSH
45902: LD_VAR 0 2
45906: ARRAY
45907: PUSH
45908: LD_VAR 0 3
45912: ARRAY
45913: PPUSH
45914: CALL_OW 257
45918: PUSH
45919: LD_INT 1
45921: EQUAL
45922: PUSH
45923: LD_EXP 113
45927: PUSH
45928: LD_VAR 0 2
45932: ARRAY
45933: PUSH
45934: LD_VAR 0 3
45938: ARRAY
45939: PPUSH
45940: CALL_OW 459
45944: NOT
45945: AND
45946: PUSH
45947: LD_EXP 113
45951: PUSH
45952: LD_VAR 0 2
45956: ARRAY
45957: PUSH
45958: LD_VAR 0 3
45962: ARRAY
45963: PPUSH
45964: CALL_OW 255
45968: PPUSH
45969: LD_EXP 112
45973: PUSH
45974: LD_VAR 0 2
45978: ARRAY
45979: PUSH
45980: LD_VAR 0 4
45984: ARRAY
45985: PUSH
45986: LD_INT 1
45988: ARRAY
45989: PPUSH
45990: LD_EXP 112
45994: PUSH
45995: LD_VAR 0 2
45999: ARRAY
46000: PUSH
46001: LD_VAR 0 4
46005: ARRAY
46006: PUSH
46007: LD_INT 2
46009: ARRAY
46010: PPUSH
46011: LD_INT 15
46013: PPUSH
46014: CALL 70551 0 4
46018: PUSH
46019: LD_INT 4
46021: ARRAY
46022: PUSH
46023: LD_INT 0
46025: EQUAL
46026: AND
46027: PUSH
46028: LD_EXP 113
46032: PUSH
46033: LD_VAR 0 2
46037: ARRAY
46038: PUSH
46039: LD_VAR 0 3
46043: ARRAY
46044: PPUSH
46045: CALL_OW 314
46049: NOT
46050: AND
46051: IFFALSE 46227
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46053: LD_EXP 113
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_VAR 0 3
46068: ARRAY
46069: PPUSH
46070: CALL_OW 310
46074: IFFALSE 46097
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46076: LD_EXP 113
46080: PUSH
46081: LD_VAR 0 2
46085: ARRAY
46086: PUSH
46087: LD_VAR 0 3
46091: ARRAY
46092: PPUSH
46093: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46097: LD_EXP 113
46101: PUSH
46102: LD_VAR 0 2
46106: ARRAY
46107: PUSH
46108: LD_VAR 0 3
46112: ARRAY
46113: PPUSH
46114: CALL_OW 314
46118: NOT
46119: IFFALSE 46187
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46121: LD_EXP 113
46125: PUSH
46126: LD_VAR 0 2
46130: ARRAY
46131: PUSH
46132: LD_VAR 0 3
46136: ARRAY
46137: PPUSH
46138: LD_EXP 112
46142: PUSH
46143: LD_VAR 0 2
46147: ARRAY
46148: PUSH
46149: LD_VAR 0 4
46153: ARRAY
46154: PUSH
46155: LD_INT 1
46157: ARRAY
46158: PPUSH
46159: LD_EXP 112
46163: PUSH
46164: LD_VAR 0 2
46168: ARRAY
46169: PUSH
46170: LD_VAR 0 4
46174: ARRAY
46175: PUSH
46176: LD_INT 2
46178: ARRAY
46179: PPUSH
46180: LD_INT 0
46182: PPUSH
46183: CALL_OW 193
// k := k + 1 ;
46187: LD_ADDR_VAR 0 4
46191: PUSH
46192: LD_VAR 0 4
46196: PUSH
46197: LD_INT 1
46199: PLUS
46200: ST_TO_ADDR
// if k > mc_mines [ i ] then
46201: LD_VAR 0 4
46205: PUSH
46206: LD_EXP 112
46210: PUSH
46211: LD_VAR 0 2
46215: ARRAY
46216: GREATER
46217: IFFALSE 46227
// k := 1 ;
46219: LD_ADDR_VAR 0 4
46223: PUSH
46224: LD_INT 1
46226: ST_TO_ADDR
// end ; end ;
46227: GO 45632
46229: POP
46230: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46231: LD_ADDR_VAR 0 5
46235: PUSH
46236: LD_EXP 99
46240: PUSH
46241: LD_VAR 0 2
46245: ARRAY
46246: PPUSH
46247: LD_INT 2
46249: PUSH
46250: LD_INT 30
46252: PUSH
46253: LD_INT 4
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 30
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 30
46272: PUSH
46273: LD_INT 32
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: PPUSH
46286: CALL_OW 72
46290: ST_TO_ADDR
// if not tmp then
46291: LD_VAR 0 5
46295: NOT
46296: IFFALSE 46300
// continue ;
46298: GO 45549
// list := [ ] ;
46300: LD_ADDR_VAR 0 6
46304: PUSH
46305: EMPTY
46306: ST_TO_ADDR
// for j in tmp do
46307: LD_ADDR_VAR 0 3
46311: PUSH
46312: LD_VAR 0 5
46316: PUSH
46317: FOR_IN
46318: IFFALSE 46387
// begin for k in UnitsInside ( j ) do
46320: LD_ADDR_VAR 0 4
46324: PUSH
46325: LD_VAR 0 3
46329: PPUSH
46330: CALL_OW 313
46334: PUSH
46335: FOR_IN
46336: IFFALSE 46383
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46338: LD_VAR 0 4
46342: PPUSH
46343: CALL_OW 257
46347: PUSH
46348: LD_INT 1
46350: EQUAL
46351: PUSH
46352: LD_VAR 0 4
46356: PPUSH
46357: CALL_OW 459
46361: NOT
46362: AND
46363: IFFALSE 46381
// list := list ^ k ;
46365: LD_ADDR_VAR 0 6
46369: PUSH
46370: LD_VAR 0 6
46374: PUSH
46375: LD_VAR 0 4
46379: ADD
46380: ST_TO_ADDR
46381: GO 46335
46383: POP
46384: POP
// end ;
46385: GO 46317
46387: POP
46388: POP
// list := list diff mc_miners [ i ] ;
46389: LD_ADDR_VAR 0 6
46393: PUSH
46394: LD_VAR 0 6
46398: PUSH
46399: LD_EXP 113
46403: PUSH
46404: LD_VAR 0 2
46408: ARRAY
46409: DIFF
46410: ST_TO_ADDR
// if not list then
46411: LD_VAR 0 6
46415: NOT
46416: IFFALSE 46420
// continue ;
46418: GO 45549
// k := mc_mines [ i ] - mc_miners [ i ] ;
46420: LD_ADDR_VAR 0 4
46424: PUSH
46425: LD_EXP 112
46429: PUSH
46430: LD_VAR 0 2
46434: ARRAY
46435: PUSH
46436: LD_EXP 113
46440: PUSH
46441: LD_VAR 0 2
46445: ARRAY
46446: MINUS
46447: ST_TO_ADDR
// if k > list then
46448: LD_VAR 0 4
46452: PUSH
46453: LD_VAR 0 6
46457: GREATER
46458: IFFALSE 46470
// k := list ;
46460: LD_ADDR_VAR 0 4
46464: PUSH
46465: LD_VAR 0 6
46469: ST_TO_ADDR
// for j = 1 to k do
46470: LD_ADDR_VAR 0 3
46474: PUSH
46475: DOUBLE
46476: LD_INT 1
46478: DEC
46479: ST_TO_ADDR
46480: LD_VAR 0 4
46484: PUSH
46485: FOR_TO
46486: IFFALSE 46540
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46488: LD_ADDR_EXP 113
46492: PUSH
46493: LD_EXP 113
46497: PPUSH
46498: LD_VAR 0 2
46502: PUSH
46503: LD_EXP 113
46507: PUSH
46508: LD_VAR 0 2
46512: ARRAY
46513: PUSH
46514: LD_INT 1
46516: PLUS
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PPUSH
46522: LD_VAR 0 6
46526: PUSH
46527: LD_VAR 0 3
46531: ARRAY
46532: PPUSH
46533: CALL 69655 0 3
46537: ST_TO_ADDR
46538: GO 46485
46540: POP
46541: POP
// end ;
46542: GO 45549
46544: POP
46545: POP
// end ;
46546: LD_VAR 0 1
46550: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46551: LD_INT 0
46553: PPUSH
46554: PPUSH
46555: PPUSH
46556: PPUSH
46557: PPUSH
46558: PPUSH
46559: PPUSH
46560: PPUSH
46561: PPUSH
46562: PPUSH
// if not mc_bases then
46563: LD_EXP 99
46567: NOT
46568: IFFALSE 46572
// exit ;
46570: GO 48303
// for i = 1 to mc_bases do
46572: LD_ADDR_VAR 0 2
46576: PUSH
46577: DOUBLE
46578: LD_INT 1
46580: DEC
46581: ST_TO_ADDR
46582: LD_EXP 99
46586: PUSH
46587: FOR_TO
46588: IFFALSE 48301
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
46590: LD_EXP 99
46594: PUSH
46595: LD_VAR 0 2
46599: ARRAY
46600: NOT
46601: PUSH
46602: LD_EXP 106
46606: PUSH
46607: LD_VAR 0 2
46611: ARRAY
46612: OR
46613: IFFALSE 46617
// continue ;
46615: GO 46587
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
46617: LD_EXP 115
46621: PUSH
46622: LD_VAR 0 2
46626: ARRAY
46627: NOT
46628: PUSH
46629: LD_EXP 116
46633: PUSH
46634: LD_VAR 0 2
46638: ARRAY
46639: AND
46640: IFFALSE 46678
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
46642: LD_ADDR_EXP 116
46646: PUSH
46647: LD_EXP 116
46651: PPUSH
46652: LD_VAR 0 2
46656: PPUSH
46657: EMPTY
46658: PPUSH
46659: CALL_OW 1
46663: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
46664: LD_VAR 0 2
46668: PPUSH
46669: LD_INT 107
46671: PPUSH
46672: CALL 37767 0 2
// continue ;
46676: GO 46587
// end ; target := [ ] ;
46678: LD_ADDR_VAR 0 6
46682: PUSH
46683: EMPTY
46684: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
46685: LD_ADDR_VAR 0 3
46689: PUSH
46690: DOUBLE
46691: LD_EXP 115
46695: PUSH
46696: LD_VAR 0 2
46700: ARRAY
46701: INC
46702: ST_TO_ADDR
46703: LD_INT 1
46705: PUSH
46706: FOR_DOWNTO
46707: IFFALSE 46967
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
46709: LD_EXP 115
46713: PUSH
46714: LD_VAR 0 2
46718: ARRAY
46719: PUSH
46720: LD_VAR 0 3
46724: ARRAY
46725: PUSH
46726: LD_INT 2
46728: ARRAY
46729: PPUSH
46730: LD_EXP 115
46734: PUSH
46735: LD_VAR 0 2
46739: ARRAY
46740: PUSH
46741: LD_VAR 0 3
46745: ARRAY
46746: PUSH
46747: LD_INT 3
46749: ARRAY
46750: PPUSH
46751: CALL_OW 488
46755: PUSH
46756: LD_EXP 115
46760: PUSH
46761: LD_VAR 0 2
46765: ARRAY
46766: PUSH
46767: LD_VAR 0 3
46771: ARRAY
46772: PUSH
46773: LD_INT 2
46775: ARRAY
46776: PPUSH
46777: LD_EXP 115
46781: PUSH
46782: LD_VAR 0 2
46786: ARRAY
46787: PUSH
46788: LD_VAR 0 3
46792: ARRAY
46793: PUSH
46794: LD_INT 3
46796: ARRAY
46797: PPUSH
46798: CALL_OW 284
46802: PUSH
46803: LD_INT 0
46805: EQUAL
46806: AND
46807: IFFALSE 46862
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
46809: LD_ADDR_VAR 0 5
46813: PUSH
46814: LD_EXP 115
46818: PUSH
46819: LD_VAR 0 2
46823: ARRAY
46824: PPUSH
46825: LD_VAR 0 3
46829: PPUSH
46830: CALL_OW 3
46834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
46835: LD_ADDR_EXP 115
46839: PUSH
46840: LD_EXP 115
46844: PPUSH
46845: LD_VAR 0 2
46849: PPUSH
46850: LD_VAR 0 5
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// continue ;
46860: GO 46706
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
46862: LD_EXP 99
46866: PUSH
46867: LD_VAR 0 2
46871: ARRAY
46872: PUSH
46873: LD_INT 1
46875: ARRAY
46876: PPUSH
46877: CALL_OW 255
46881: PPUSH
46882: LD_EXP 115
46886: PUSH
46887: LD_VAR 0 2
46891: ARRAY
46892: PUSH
46893: LD_VAR 0 3
46897: ARRAY
46898: PUSH
46899: LD_INT 2
46901: ARRAY
46902: PPUSH
46903: LD_EXP 115
46907: PUSH
46908: LD_VAR 0 2
46912: ARRAY
46913: PUSH
46914: LD_VAR 0 3
46918: ARRAY
46919: PUSH
46920: LD_INT 3
46922: ARRAY
46923: PPUSH
46924: LD_INT 30
46926: PPUSH
46927: CALL 70551 0 4
46931: PUSH
46932: LD_INT 4
46934: ARRAY
46935: PUSH
46936: LD_INT 0
46938: EQUAL
46939: IFFALSE 46965
// begin target := mc_crates [ i ] [ j ] ;
46941: LD_ADDR_VAR 0 6
46945: PUSH
46946: LD_EXP 115
46950: PUSH
46951: LD_VAR 0 2
46955: ARRAY
46956: PUSH
46957: LD_VAR 0 3
46961: ARRAY
46962: ST_TO_ADDR
// break ;
46963: GO 46967
// end ; end ;
46965: GO 46706
46967: POP
46968: POP
// if not target then
46969: LD_VAR 0 6
46973: NOT
46974: IFFALSE 46978
// continue ;
46976: GO 46587
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
46978: LD_ADDR_VAR 0 7
46982: PUSH
46983: LD_EXP 118
46987: PUSH
46988: LD_VAR 0 2
46992: ARRAY
46993: PPUSH
46994: LD_INT 2
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: LD_INT 58
47002: PUSH
47003: EMPTY
47004: LIST
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 61
47012: PUSH
47013: EMPTY
47014: LIST
47015: PUSH
47016: LD_INT 33
47018: PUSH
47019: LD_INT 5
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 33
47028: PUSH
47029: LD_INT 3
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 2
47045: PUSH
47046: LD_INT 34
47048: PUSH
47049: LD_INT 32
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 34
47058: PUSH
47059: LD_INT 51
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 34
47068: PUSH
47069: LD_INT 12
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PPUSH
47086: CALL_OW 72
47090: ST_TO_ADDR
// if not cargo then
47091: LD_VAR 0 7
47095: NOT
47096: IFFALSE 47739
// begin if mc_crates_collector [ i ] < 5 then
47098: LD_EXP 116
47102: PUSH
47103: LD_VAR 0 2
47107: ARRAY
47108: PUSH
47109: LD_INT 5
47111: LESS
47112: IFFALSE 47478
// begin if mc_ape [ i ] then
47114: LD_EXP 128
47118: PUSH
47119: LD_VAR 0 2
47123: ARRAY
47124: IFFALSE 47171
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47126: LD_ADDR_VAR 0 5
47130: PUSH
47131: LD_EXP 128
47135: PUSH
47136: LD_VAR 0 2
47140: ARRAY
47141: PPUSH
47142: LD_INT 25
47144: PUSH
47145: LD_INT 16
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 24
47154: PUSH
47155: LD_INT 750
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PPUSH
47166: CALL_OW 72
47170: ST_TO_ADDR
// if not tmp then
47171: LD_VAR 0 5
47175: NOT
47176: IFFALSE 47223
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47178: LD_ADDR_VAR 0 5
47182: PUSH
47183: LD_EXP 99
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: PPUSH
47194: LD_INT 25
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 24
47206: PUSH
47207: LD_INT 750
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PPUSH
47218: CALL_OW 72
47222: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47223: LD_EXP 128
47227: PUSH
47228: LD_VAR 0 2
47232: ARRAY
47233: PUSH
47234: LD_EXP 99
47238: PUSH
47239: LD_VAR 0 2
47243: ARRAY
47244: PPUSH
47245: LD_INT 25
47247: PUSH
47248: LD_INT 2
47250: PUSH
47251: EMPTY
47252: LIST
47253: LIST
47254: PUSH
47255: LD_INT 24
47257: PUSH
47258: LD_INT 750
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PPUSH
47269: CALL_OW 72
47273: AND
47274: PUSH
47275: LD_VAR 0 5
47279: PUSH
47280: LD_INT 5
47282: LESS
47283: AND
47284: IFFALSE 47366
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47286: LD_ADDR_VAR 0 3
47290: PUSH
47291: LD_EXP 99
47295: PUSH
47296: LD_VAR 0 2
47300: ARRAY
47301: PPUSH
47302: LD_INT 25
47304: PUSH
47305: LD_INT 2
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PUSH
47312: LD_INT 24
47314: PUSH
47315: LD_INT 750
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PPUSH
47326: CALL_OW 72
47330: PUSH
47331: FOR_IN
47332: IFFALSE 47364
// begin tmp := tmp union j ;
47334: LD_ADDR_VAR 0 5
47338: PUSH
47339: LD_VAR 0 5
47343: PUSH
47344: LD_VAR 0 3
47348: UNION
47349: ST_TO_ADDR
// if tmp >= 5 then
47350: LD_VAR 0 5
47354: PUSH
47355: LD_INT 5
47357: GREATEREQUAL
47358: IFFALSE 47362
// break ;
47360: GO 47364
// end ;
47362: GO 47331
47364: POP
47365: POP
// end ; if not tmp then
47366: LD_VAR 0 5
47370: NOT
47371: IFFALSE 47375
// continue ;
47373: GO 46587
// for j in tmp do
47375: LD_ADDR_VAR 0 3
47379: PUSH
47380: LD_VAR 0 5
47384: PUSH
47385: FOR_IN
47386: IFFALSE 47476
// if not GetTag ( j ) then
47388: LD_VAR 0 3
47392: PPUSH
47393: CALL_OW 110
47397: NOT
47398: IFFALSE 47474
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47400: LD_ADDR_EXP 116
47404: PUSH
47405: LD_EXP 116
47409: PPUSH
47410: LD_VAR 0 2
47414: PUSH
47415: LD_EXP 116
47419: PUSH
47420: LD_VAR 0 2
47424: ARRAY
47425: PUSH
47426: LD_INT 1
47428: PLUS
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PPUSH
47434: LD_VAR 0 3
47438: PPUSH
47439: CALL 69655 0 3
47443: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47444: LD_VAR 0 3
47448: PPUSH
47449: LD_INT 107
47451: PPUSH
47452: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47456: LD_EXP 116
47460: PUSH
47461: LD_VAR 0 2
47465: ARRAY
47466: PUSH
47467: LD_INT 5
47469: GREATEREQUAL
47470: IFFALSE 47474
// break ;
47472: GO 47476
// end ;
47474: GO 47385
47476: POP
47477: POP
// end ; if mc_crates_collector [ i ] and target then
47478: LD_EXP 116
47482: PUSH
47483: LD_VAR 0 2
47487: ARRAY
47488: PUSH
47489: LD_VAR 0 6
47493: AND
47494: IFFALSE 47737
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47496: LD_EXP 116
47500: PUSH
47501: LD_VAR 0 2
47505: ARRAY
47506: PUSH
47507: LD_VAR 0 6
47511: PUSH
47512: LD_INT 1
47514: ARRAY
47515: LESS
47516: IFFALSE 47536
// tmp := mc_crates_collector [ i ] else
47518: LD_ADDR_VAR 0 5
47522: PUSH
47523: LD_EXP 116
47527: PUSH
47528: LD_VAR 0 2
47532: ARRAY
47533: ST_TO_ADDR
47534: GO 47550
// tmp := target [ 1 ] ;
47536: LD_ADDR_VAR 0 5
47540: PUSH
47541: LD_VAR 0 6
47545: PUSH
47546: LD_INT 1
47548: ARRAY
47549: ST_TO_ADDR
// k := 0 ;
47550: LD_ADDR_VAR 0 4
47554: PUSH
47555: LD_INT 0
47557: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47558: LD_ADDR_VAR 0 3
47562: PUSH
47563: LD_EXP 116
47567: PUSH
47568: LD_VAR 0 2
47572: ARRAY
47573: PUSH
47574: FOR_IN
47575: IFFALSE 47735
// begin k := k + 1 ;
47577: LD_ADDR_VAR 0 4
47581: PUSH
47582: LD_VAR 0 4
47586: PUSH
47587: LD_INT 1
47589: PLUS
47590: ST_TO_ADDR
// if k > tmp then
47591: LD_VAR 0 4
47595: PUSH
47596: LD_VAR 0 5
47600: GREATER
47601: IFFALSE 47605
// break ;
47603: GO 47735
// if not GetClass ( j ) in [ 2 , 16 ] then
47605: LD_VAR 0 3
47609: PPUSH
47610: CALL_OW 257
47614: PUSH
47615: LD_INT 2
47617: PUSH
47618: LD_INT 16
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: IN
47625: NOT
47626: IFFALSE 47679
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
47628: LD_ADDR_EXP 116
47632: PUSH
47633: LD_EXP 116
47637: PPUSH
47638: LD_VAR 0 2
47642: PPUSH
47643: LD_EXP 116
47647: PUSH
47648: LD_VAR 0 2
47652: ARRAY
47653: PUSH
47654: LD_VAR 0 3
47658: DIFF
47659: PPUSH
47660: CALL_OW 1
47664: ST_TO_ADDR
// SetTag ( j , 0 ) ;
47665: LD_VAR 0 3
47669: PPUSH
47670: LD_INT 0
47672: PPUSH
47673: CALL_OW 109
// continue ;
47677: GO 47574
// end ; if IsInUnit ( j ) then
47679: LD_VAR 0 3
47683: PPUSH
47684: CALL_OW 310
47688: IFFALSE 47699
// ComExitBuilding ( j ) ;
47690: LD_VAR 0 3
47694: PPUSH
47695: CALL_OW 122
// wait ( 3 ) ;
47699: LD_INT 3
47701: PPUSH
47702: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47706: LD_VAR 0 3
47710: PPUSH
47711: LD_VAR 0 6
47715: PUSH
47716: LD_INT 2
47718: ARRAY
47719: PPUSH
47720: LD_VAR 0 6
47724: PUSH
47725: LD_INT 3
47727: ARRAY
47728: PPUSH
47729: CALL_OW 117
// end ;
47733: GO 47574
47735: POP
47736: POP
// end ; end else
47737: GO 48299
// begin for j in cargo do
47739: LD_ADDR_VAR 0 3
47743: PUSH
47744: LD_VAR 0 7
47748: PUSH
47749: FOR_IN
47750: IFFALSE 48297
// begin if GetTag ( j ) <> 0 then
47752: LD_VAR 0 3
47756: PPUSH
47757: CALL_OW 110
47761: PUSH
47762: LD_INT 0
47764: NONEQUAL
47765: IFFALSE 47769
// continue ;
47767: GO 47749
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
47769: LD_VAR 0 3
47773: PPUSH
47774: CALL_OW 256
47778: PUSH
47779: LD_INT 1000
47781: LESS
47782: PUSH
47783: LD_VAR 0 3
47787: PPUSH
47788: LD_EXP 123
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PPUSH
47799: CALL_OW 308
47803: NOT
47804: AND
47805: IFFALSE 47827
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47807: LD_VAR 0 3
47811: PPUSH
47812: LD_EXP 123
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PPUSH
47823: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
47827: LD_VAR 0 3
47831: PPUSH
47832: CALL_OW 256
47836: PUSH
47837: LD_INT 1000
47839: LESS
47840: PUSH
47841: LD_VAR 0 3
47845: PPUSH
47846: LD_EXP 123
47850: PUSH
47851: LD_VAR 0 2
47855: ARRAY
47856: PPUSH
47857: CALL_OW 308
47861: AND
47862: IFFALSE 47866
// continue ;
47864: GO 47749
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
47866: LD_VAR 0 3
47870: PPUSH
47871: CALL_OW 262
47875: PUSH
47876: LD_INT 2
47878: EQUAL
47879: PUSH
47880: LD_VAR 0 3
47884: PPUSH
47885: CALL_OW 261
47889: PUSH
47890: LD_INT 15
47892: LESS
47893: AND
47894: IFFALSE 47898
// continue ;
47896: GO 47749
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
47898: LD_VAR 0 3
47902: PPUSH
47903: CALL_OW 262
47907: PUSH
47908: LD_INT 1
47910: EQUAL
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: CALL_OW 261
47921: PUSH
47922: LD_INT 10
47924: LESS
47925: AND
47926: IFFALSE 48236
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47928: LD_ADDR_VAR 0 8
47932: PUSH
47933: LD_EXP 99
47937: PUSH
47938: LD_VAR 0 2
47942: ARRAY
47943: PPUSH
47944: LD_INT 2
47946: PUSH
47947: LD_INT 30
47949: PUSH
47950: LD_INT 0
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 30
47959: PUSH
47960: LD_INT 1
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: LIST
47971: PPUSH
47972: CALL_OW 72
47976: ST_TO_ADDR
// if not depot then
47977: LD_VAR 0 8
47981: NOT
47982: IFFALSE 47986
// continue ;
47984: GO 47749
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
47986: LD_VAR 0 3
47990: PPUSH
47991: LD_VAR 0 8
47995: PPUSH
47996: LD_VAR 0 3
48000: PPUSH
48001: CALL_OW 74
48005: PPUSH
48006: CALL_OW 296
48010: PUSH
48011: LD_INT 6
48013: LESS
48014: IFFALSE 48030
// SetFuel ( j , 100 ) else
48016: LD_VAR 0 3
48020: PPUSH
48021: LD_INT 100
48023: PPUSH
48024: CALL_OW 240
48028: GO 48236
// if GetFuel ( j ) = 0 then
48030: LD_VAR 0 3
48034: PPUSH
48035: CALL_OW 261
48039: PUSH
48040: LD_INT 0
48042: EQUAL
48043: IFFALSE 48236
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48045: LD_ADDR_EXP 118
48049: PUSH
48050: LD_EXP 118
48054: PPUSH
48055: LD_VAR 0 2
48059: PPUSH
48060: LD_EXP 118
48064: PUSH
48065: LD_VAR 0 2
48069: ARRAY
48070: PUSH
48071: LD_VAR 0 3
48075: DIFF
48076: PPUSH
48077: CALL_OW 1
48081: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48082: LD_VAR 0 3
48086: PPUSH
48087: CALL_OW 263
48091: PUSH
48092: LD_INT 1
48094: EQUAL
48095: IFFALSE 48111
// ComExitVehicle ( IsInUnit ( j ) ) ;
48097: LD_VAR 0 3
48101: PPUSH
48102: CALL_OW 310
48106: PPUSH
48107: CALL_OW 121
// if GetControl ( j ) = control_remote then
48111: LD_VAR 0 3
48115: PPUSH
48116: CALL_OW 263
48120: PUSH
48121: LD_INT 2
48123: EQUAL
48124: IFFALSE 48135
// ComUnlink ( j ) ;
48126: LD_VAR 0 3
48130: PPUSH
48131: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
48135: LD_ADDR_VAR 0 9
48139: PUSH
48140: LD_VAR 0 2
48144: PPUSH
48145: LD_INT 3
48147: PPUSH
48148: CALL 57340 0 2
48152: ST_TO_ADDR
// if fac then
48153: LD_VAR 0 9
48157: IFFALSE 48234
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48159: LD_ADDR_VAR 0 10
48163: PUSH
48164: LD_VAR 0 9
48168: PPUSH
48169: LD_VAR 0 3
48173: PPUSH
48174: CALL_OW 265
48178: PPUSH
48179: LD_VAR 0 3
48183: PPUSH
48184: CALL_OW 262
48188: PPUSH
48189: LD_VAR 0 3
48193: PPUSH
48194: CALL_OW 263
48198: PPUSH
48199: LD_VAR 0 3
48203: PPUSH
48204: CALL_OW 264
48208: PPUSH
48209: CALL 67255 0 5
48213: ST_TO_ADDR
// if components then
48214: LD_VAR 0 10
48218: IFFALSE 48234
// MC_InsertProduceList ( i , components ) ;
48220: LD_VAR 0 2
48224: PPUSH
48225: LD_VAR 0 10
48229: PPUSH
48230: CALL 56968 0 2
// end ; continue ;
48234: GO 47749
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48236: LD_VAR 0 3
48240: PPUSH
48241: LD_INT 1
48243: PPUSH
48244: CALL_OW 289
48248: PUSH
48249: LD_INT 100
48251: LESS
48252: PUSH
48253: LD_VAR 0 3
48257: PPUSH
48258: CALL_OW 314
48262: NOT
48263: AND
48264: IFFALSE 48293
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48266: LD_VAR 0 3
48270: PPUSH
48271: LD_VAR 0 6
48275: PUSH
48276: LD_INT 2
48278: ARRAY
48279: PPUSH
48280: LD_VAR 0 6
48284: PUSH
48285: LD_INT 3
48287: ARRAY
48288: PPUSH
48289: CALL_OW 117
// break ;
48293: GO 48297
// end ;
48295: GO 47749
48297: POP
48298: POP
// end ; end ;
48299: GO 46587
48301: POP
48302: POP
// end ;
48303: LD_VAR 0 1
48307: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48308: LD_INT 0
48310: PPUSH
48311: PPUSH
48312: PPUSH
48313: PPUSH
// if not mc_bases then
48314: LD_EXP 99
48318: NOT
48319: IFFALSE 48323
// exit ;
48321: GO 48484
// for i = 1 to mc_bases do
48323: LD_ADDR_VAR 0 2
48327: PUSH
48328: DOUBLE
48329: LD_INT 1
48331: DEC
48332: ST_TO_ADDR
48333: LD_EXP 99
48337: PUSH
48338: FOR_TO
48339: IFFALSE 48482
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48341: LD_ADDR_VAR 0 4
48345: PUSH
48346: LD_EXP 118
48350: PUSH
48351: LD_VAR 0 2
48355: ARRAY
48356: PUSH
48357: LD_EXP 121
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: UNION
48368: PPUSH
48369: LD_INT 33
48371: PUSH
48372: LD_INT 2
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PPUSH
48379: CALL_OW 72
48383: ST_TO_ADDR
// if tmp then
48384: LD_VAR 0 4
48388: IFFALSE 48480
// for j in tmp do
48390: LD_ADDR_VAR 0 3
48394: PUSH
48395: LD_VAR 0 4
48399: PUSH
48400: FOR_IN
48401: IFFALSE 48478
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48403: LD_VAR 0 3
48407: PPUSH
48408: CALL_OW 312
48412: NOT
48413: PUSH
48414: LD_VAR 0 3
48418: PPUSH
48419: CALL_OW 256
48423: PUSH
48424: LD_INT 250
48426: GREATEREQUAL
48427: AND
48428: IFFALSE 48441
// Connect ( j ) else
48430: LD_VAR 0 3
48434: PPUSH
48435: CALL 72588 0 1
48439: GO 48476
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48441: LD_VAR 0 3
48445: PPUSH
48446: CALL_OW 256
48450: PUSH
48451: LD_INT 250
48453: LESS
48454: PUSH
48455: LD_VAR 0 3
48459: PPUSH
48460: CALL_OW 312
48464: AND
48465: IFFALSE 48476
// ComUnlink ( j ) ;
48467: LD_VAR 0 3
48471: PPUSH
48472: CALL_OW 136
48476: GO 48400
48478: POP
48479: POP
// end ;
48480: GO 48338
48482: POP
48483: POP
// end ;
48484: LD_VAR 0 1
48488: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48489: LD_INT 0
48491: PPUSH
48492: PPUSH
48493: PPUSH
48494: PPUSH
48495: PPUSH
// if not mc_bases then
48496: LD_EXP 99
48500: NOT
48501: IFFALSE 48505
// exit ;
48503: GO 48965
// for i = 1 to mc_bases do
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: DOUBLE
48511: LD_INT 1
48513: DEC
48514: ST_TO_ADDR
48515: LD_EXP 99
48519: PUSH
48520: FOR_TO
48521: IFFALSE 48963
// begin if not mc_produce [ i ] then
48523: LD_EXP 120
48527: PUSH
48528: LD_VAR 0 2
48532: ARRAY
48533: NOT
48534: IFFALSE 48538
// continue ;
48536: GO 48520
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48538: LD_ADDR_VAR 0 5
48542: PUSH
48543: LD_EXP 99
48547: PUSH
48548: LD_VAR 0 2
48552: ARRAY
48553: PPUSH
48554: LD_INT 30
48556: PUSH
48557: LD_INT 3
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PPUSH
48564: CALL_OW 72
48568: ST_TO_ADDR
// if not fac then
48569: LD_VAR 0 5
48573: NOT
48574: IFFALSE 48578
// continue ;
48576: GO 48520
// for j in fac do
48578: LD_ADDR_VAR 0 3
48582: PUSH
48583: LD_VAR 0 5
48587: PUSH
48588: FOR_IN
48589: IFFALSE 48959
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
48591: LD_VAR 0 3
48595: PPUSH
48596: CALL_OW 461
48600: PUSH
48601: LD_INT 2
48603: NONEQUAL
48604: PUSH
48605: LD_VAR 0 3
48609: PPUSH
48610: LD_INT 15
48612: PPUSH
48613: CALL 72248 0 2
48617: PUSH
48618: LD_INT 4
48620: ARRAY
48621: OR
48622: PUSH
48623: LD_VAR 0 3
48627: PPUSH
48628: CALL_OW 313
48632: PUSH
48633: LD_INT 0
48635: EQUAL
48636: OR
48637: IFFALSE 48641
// continue ;
48639: GO 48588
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
48641: LD_VAR 0 3
48645: PPUSH
48646: LD_EXP 120
48650: PUSH
48651: LD_VAR 0 2
48655: ARRAY
48656: PUSH
48657: LD_INT 1
48659: ARRAY
48660: PUSH
48661: LD_INT 1
48663: ARRAY
48664: PPUSH
48665: LD_EXP 120
48669: PUSH
48670: LD_VAR 0 2
48674: ARRAY
48675: PUSH
48676: LD_INT 1
48678: ARRAY
48679: PUSH
48680: LD_INT 2
48682: ARRAY
48683: PPUSH
48684: LD_EXP 120
48688: PUSH
48689: LD_VAR 0 2
48693: ARRAY
48694: PUSH
48695: LD_INT 1
48697: ARRAY
48698: PUSH
48699: LD_INT 3
48701: ARRAY
48702: PPUSH
48703: LD_EXP 120
48707: PUSH
48708: LD_VAR 0 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: ARRAY
48717: PUSH
48718: LD_INT 4
48720: ARRAY
48721: PPUSH
48722: CALL_OW 448
48726: PUSH
48727: LD_VAR 0 3
48731: PPUSH
48732: LD_EXP 120
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: PUSH
48743: LD_INT 1
48745: ARRAY
48746: PUSH
48747: LD_INT 1
48749: ARRAY
48750: PUSH
48751: LD_EXP 120
48755: PUSH
48756: LD_VAR 0 2
48760: ARRAY
48761: PUSH
48762: LD_INT 1
48764: ARRAY
48765: PUSH
48766: LD_INT 2
48768: ARRAY
48769: PUSH
48770: LD_EXP 120
48774: PUSH
48775: LD_VAR 0 2
48779: ARRAY
48780: PUSH
48781: LD_INT 1
48783: ARRAY
48784: PUSH
48785: LD_INT 3
48787: ARRAY
48788: PUSH
48789: LD_EXP 120
48793: PUSH
48794: LD_VAR 0 2
48798: ARRAY
48799: PUSH
48800: LD_INT 1
48802: ARRAY
48803: PUSH
48804: LD_INT 4
48806: ARRAY
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: PPUSH
48814: CALL 75919 0 2
48818: AND
48819: IFFALSE 48957
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
48821: LD_VAR 0 3
48825: PPUSH
48826: LD_EXP 120
48830: PUSH
48831: LD_VAR 0 2
48835: ARRAY
48836: PUSH
48837: LD_INT 1
48839: ARRAY
48840: PUSH
48841: LD_INT 1
48843: ARRAY
48844: PPUSH
48845: LD_EXP 120
48849: PUSH
48850: LD_VAR 0 2
48854: ARRAY
48855: PUSH
48856: LD_INT 1
48858: ARRAY
48859: PUSH
48860: LD_INT 2
48862: ARRAY
48863: PPUSH
48864: LD_EXP 120
48868: PUSH
48869: LD_VAR 0 2
48873: ARRAY
48874: PUSH
48875: LD_INT 1
48877: ARRAY
48878: PUSH
48879: LD_INT 3
48881: ARRAY
48882: PPUSH
48883: LD_EXP 120
48887: PUSH
48888: LD_VAR 0 2
48892: ARRAY
48893: PUSH
48894: LD_INT 1
48896: ARRAY
48897: PUSH
48898: LD_INT 4
48900: ARRAY
48901: PPUSH
48902: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
48906: LD_ADDR_VAR 0 4
48910: PUSH
48911: LD_EXP 120
48915: PUSH
48916: LD_VAR 0 2
48920: ARRAY
48921: PPUSH
48922: LD_INT 1
48924: PPUSH
48925: CALL_OW 3
48929: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48930: LD_ADDR_EXP 120
48934: PUSH
48935: LD_EXP 120
48939: PPUSH
48940: LD_VAR 0 2
48944: PPUSH
48945: LD_VAR 0 4
48949: PPUSH
48950: CALL_OW 1
48954: ST_TO_ADDR
// break ;
48955: GO 48959
// end ; end ;
48957: GO 48588
48959: POP
48960: POP
// end ;
48961: GO 48520
48963: POP
48964: POP
// end ;
48965: LD_VAR 0 1
48969: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
48970: LD_INT 0
48972: PPUSH
48973: PPUSH
48974: PPUSH
// if not mc_bases then
48975: LD_EXP 99
48979: NOT
48980: IFFALSE 48984
// exit ;
48982: GO 49073
// for i = 1 to mc_bases do
48984: LD_ADDR_VAR 0 2
48988: PUSH
48989: DOUBLE
48990: LD_INT 1
48992: DEC
48993: ST_TO_ADDR
48994: LD_EXP 99
48998: PUSH
48999: FOR_TO
49000: IFFALSE 49071
// begin if mc_attack [ i ] then
49002: LD_EXP 119
49006: PUSH
49007: LD_VAR 0 2
49011: ARRAY
49012: IFFALSE 49069
// begin tmp := mc_attack [ i ] [ 1 ] ;
49014: LD_ADDR_VAR 0 3
49018: PUSH
49019: LD_EXP 119
49023: PUSH
49024: LD_VAR 0 2
49028: ARRAY
49029: PUSH
49030: LD_INT 1
49032: ARRAY
49033: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49034: LD_ADDR_EXP 119
49038: PUSH
49039: LD_EXP 119
49043: PPUSH
49044: LD_VAR 0 2
49048: PPUSH
49049: EMPTY
49050: PPUSH
49051: CALL_OW 1
49055: ST_TO_ADDR
// Attack ( tmp ) ;
49056: LD_VAR 0 3
49060: PPUSH
49061: CALL 98108 0 1
// exit ;
49065: POP
49066: POP
49067: GO 49073
// end ; end ;
49069: GO 48999
49071: POP
49072: POP
// end ;
49073: LD_VAR 0 1
49077: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49078: LD_INT 0
49080: PPUSH
49081: PPUSH
49082: PPUSH
49083: PPUSH
49084: PPUSH
49085: PPUSH
49086: PPUSH
// if not mc_bases then
49087: LD_EXP 99
49091: NOT
49092: IFFALSE 49096
// exit ;
49094: GO 49700
// for i = 1 to mc_bases do
49096: LD_ADDR_VAR 0 2
49100: PUSH
49101: DOUBLE
49102: LD_INT 1
49104: DEC
49105: ST_TO_ADDR
49106: LD_EXP 99
49110: PUSH
49111: FOR_TO
49112: IFFALSE 49698
// begin if not mc_bases [ i ] then
49114: LD_EXP 99
49118: PUSH
49119: LD_VAR 0 2
49123: ARRAY
49124: NOT
49125: IFFALSE 49129
// continue ;
49127: GO 49111
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49129: LD_ADDR_VAR 0 7
49133: PUSH
49134: LD_EXP 99
49138: PUSH
49139: LD_VAR 0 2
49143: ARRAY
49144: PUSH
49145: LD_INT 1
49147: ARRAY
49148: PPUSH
49149: CALL 66559 0 1
49153: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49154: LD_ADDR_EXP 122
49158: PUSH
49159: LD_EXP 122
49163: PPUSH
49164: LD_VAR 0 2
49168: PPUSH
49169: LD_EXP 99
49173: PUSH
49174: LD_VAR 0 2
49178: ARRAY
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PPUSH
49184: CALL_OW 255
49188: PPUSH
49189: LD_EXP 124
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: PPUSH
49200: CALL 64519 0 2
49204: PPUSH
49205: CALL_OW 1
49209: ST_TO_ADDR
// if not mc_scan [ i ] then
49210: LD_EXP 122
49214: PUSH
49215: LD_VAR 0 2
49219: ARRAY
49220: NOT
49221: IFFALSE 49376
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49223: LD_ADDR_VAR 0 4
49227: PUSH
49228: LD_EXP 99
49232: PUSH
49233: LD_VAR 0 2
49237: ARRAY
49238: PPUSH
49239: LD_INT 2
49241: PUSH
49242: LD_INT 25
49244: PUSH
49245: LD_INT 5
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 25
49254: PUSH
49255: LD_INT 8
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: PUSH
49262: LD_INT 25
49264: PUSH
49265: LD_INT 9
49267: PUSH
49268: EMPTY
49269: LIST
49270: LIST
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: PPUSH
49278: CALL_OW 72
49282: ST_TO_ADDR
// if not tmp then
49283: LD_VAR 0 4
49287: NOT
49288: IFFALSE 49292
// continue ;
49290: GO 49111
// for j in tmp do
49292: LD_ADDR_VAR 0 3
49296: PUSH
49297: LD_VAR 0 4
49301: PUSH
49302: FOR_IN
49303: IFFALSE 49374
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49305: LD_VAR 0 3
49309: PPUSH
49310: CALL_OW 310
49314: PPUSH
49315: CALL_OW 266
49319: PUSH
49320: LD_INT 5
49322: EQUAL
49323: PUSH
49324: LD_VAR 0 3
49328: PPUSH
49329: CALL_OW 257
49333: PUSH
49334: LD_INT 1
49336: EQUAL
49337: AND
49338: PUSH
49339: LD_VAR 0 3
49343: PPUSH
49344: CALL_OW 459
49348: NOT
49349: AND
49350: PUSH
49351: LD_VAR 0 7
49355: AND
49356: IFFALSE 49372
// ComChangeProfession ( j , class ) ;
49358: LD_VAR 0 3
49362: PPUSH
49363: LD_VAR 0 7
49367: PPUSH
49368: CALL_OW 123
49372: GO 49302
49374: POP
49375: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49376: LD_EXP 122
49380: PUSH
49381: LD_VAR 0 2
49385: ARRAY
49386: PUSH
49387: LD_EXP 121
49391: PUSH
49392: LD_VAR 0 2
49396: ARRAY
49397: NOT
49398: AND
49399: PUSH
49400: LD_EXP 99
49404: PUSH
49405: LD_VAR 0 2
49409: ARRAY
49410: PPUSH
49411: LD_INT 30
49413: PUSH
49414: LD_INT 32
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PPUSH
49421: CALL_OW 72
49425: NOT
49426: AND
49427: PUSH
49428: LD_EXP 99
49432: PUSH
49433: LD_VAR 0 2
49437: ARRAY
49438: PPUSH
49439: LD_INT 2
49441: PUSH
49442: LD_INT 30
49444: PUSH
49445: LD_INT 4
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 30
49454: PUSH
49455: LD_INT 5
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: LIST
49466: PPUSH
49467: CALL_OW 72
49471: NOT
49472: AND
49473: IFFALSE 49605
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49475: LD_ADDR_VAR 0 4
49479: PUSH
49480: LD_EXP 99
49484: PUSH
49485: LD_VAR 0 2
49489: ARRAY
49490: PPUSH
49491: LD_INT 2
49493: PUSH
49494: LD_INT 25
49496: PUSH
49497: LD_INT 1
49499: PUSH
49500: EMPTY
49501: LIST
49502: LIST
49503: PUSH
49504: LD_INT 25
49506: PUSH
49507: LD_INT 5
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 25
49516: PUSH
49517: LD_INT 8
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 25
49526: PUSH
49527: LD_INT 9
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: LIST
49538: LIST
49539: LIST
49540: PPUSH
49541: CALL_OW 72
49545: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49546: LD_ADDR_VAR 0 4
49550: PUSH
49551: LD_VAR 0 4
49555: PUSH
49556: LD_VAR 0 4
49560: PPUSH
49561: LD_INT 18
49563: PPUSH
49564: CALL 102891 0 2
49568: DIFF
49569: ST_TO_ADDR
// if tmp then
49570: LD_VAR 0 4
49574: IFFALSE 49605
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
49576: LD_VAR 0 2
49580: PPUSH
49581: LD_VAR 0 4
49585: PPUSH
49586: LD_EXP 124
49590: PUSH
49591: LD_VAR 0 2
49595: ARRAY
49596: PPUSH
49597: CALL 64554 0 3
// exit ;
49601: POP
49602: POP
49603: GO 49700
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
49605: LD_EXP 122
49609: PUSH
49610: LD_VAR 0 2
49614: ARRAY
49615: PUSH
49616: LD_EXP 121
49620: PUSH
49621: LD_VAR 0 2
49625: ARRAY
49626: AND
49627: IFFALSE 49696
// begin tmp := mc_defender [ i ] ;
49629: LD_ADDR_VAR 0 4
49633: PUSH
49634: LD_EXP 121
49638: PUSH
49639: LD_VAR 0 2
49643: ARRAY
49644: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49645: LD_ADDR_EXP 121
49649: PUSH
49650: LD_EXP 121
49654: PPUSH
49655: LD_VAR 0 2
49659: PPUSH
49660: EMPTY
49661: PPUSH
49662: CALL_OW 1
49666: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
49667: LD_VAR 0 2
49671: PPUSH
49672: LD_VAR 0 4
49676: PPUSH
49677: LD_EXP 122
49681: PUSH
49682: LD_VAR 0 2
49686: ARRAY
49687: PPUSH
49688: CALL 65052 0 3
// exit ;
49692: POP
49693: POP
49694: GO 49700
// end ; end ;
49696: GO 49111
49698: POP
49699: POP
// end ;
49700: LD_VAR 0 1
49704: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
49705: LD_INT 0
49707: PPUSH
49708: PPUSH
49709: PPUSH
49710: PPUSH
49711: PPUSH
49712: PPUSH
49713: PPUSH
49714: PPUSH
49715: PPUSH
49716: PPUSH
49717: PPUSH
// if not mc_bases then
49718: LD_EXP 99
49722: NOT
49723: IFFALSE 49727
// exit ;
49725: GO 50814
// for i = 1 to mc_bases do
49727: LD_ADDR_VAR 0 2
49731: PUSH
49732: DOUBLE
49733: LD_INT 1
49735: DEC
49736: ST_TO_ADDR
49737: LD_EXP 99
49741: PUSH
49742: FOR_TO
49743: IFFALSE 50812
// begin tmp := mc_lab [ i ] ;
49745: LD_ADDR_VAR 0 6
49749: PUSH
49750: LD_EXP 132
49754: PUSH
49755: LD_VAR 0 2
49759: ARRAY
49760: ST_TO_ADDR
// if not tmp then
49761: LD_VAR 0 6
49765: NOT
49766: IFFALSE 49770
// continue ;
49768: GO 49742
// idle_lab := 0 ;
49770: LD_ADDR_VAR 0 11
49774: PUSH
49775: LD_INT 0
49777: ST_TO_ADDR
// for j in tmp do
49778: LD_ADDR_VAR 0 3
49782: PUSH
49783: LD_VAR 0 6
49787: PUSH
49788: FOR_IN
49789: IFFALSE 50808
// begin researching := false ;
49791: LD_ADDR_VAR 0 10
49795: PUSH
49796: LD_INT 0
49798: ST_TO_ADDR
// side := GetSide ( j ) ;
49799: LD_ADDR_VAR 0 4
49803: PUSH
49804: LD_VAR 0 3
49808: PPUSH
49809: CALL_OW 255
49813: ST_TO_ADDR
// if not mc_tech [ side ] then
49814: LD_EXP 126
49818: PUSH
49819: LD_VAR 0 4
49823: ARRAY
49824: NOT
49825: IFFALSE 49829
// continue ;
49827: GO 49788
// if BuildingStatus ( j ) = bs_idle then
49829: LD_VAR 0 3
49833: PPUSH
49834: CALL_OW 461
49838: PUSH
49839: LD_INT 2
49841: EQUAL
49842: IFFALSE 50030
// begin if idle_lab and UnitsInside ( j ) < 6 then
49844: LD_VAR 0 11
49848: PUSH
49849: LD_VAR 0 3
49853: PPUSH
49854: CALL_OW 313
49858: PUSH
49859: LD_INT 6
49861: LESS
49862: AND
49863: IFFALSE 49934
// begin tmp2 := UnitsInside ( idle_lab ) ;
49865: LD_ADDR_VAR 0 9
49869: PUSH
49870: LD_VAR 0 11
49874: PPUSH
49875: CALL_OW 313
49879: ST_TO_ADDR
// if tmp2 then
49880: LD_VAR 0 9
49884: IFFALSE 49926
// for x in tmp2 do
49886: LD_ADDR_VAR 0 7
49890: PUSH
49891: LD_VAR 0 9
49895: PUSH
49896: FOR_IN
49897: IFFALSE 49924
// begin ComExitBuilding ( x ) ;
49899: LD_VAR 0 7
49903: PPUSH
49904: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49908: LD_VAR 0 7
49912: PPUSH
49913: LD_VAR 0 3
49917: PPUSH
49918: CALL_OW 180
// end ;
49922: GO 49896
49924: POP
49925: POP
// idle_lab := 0 ;
49926: LD_ADDR_VAR 0 11
49930: PUSH
49931: LD_INT 0
49933: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
49934: LD_ADDR_VAR 0 5
49938: PUSH
49939: LD_EXP 126
49943: PUSH
49944: LD_VAR 0 4
49948: ARRAY
49949: PUSH
49950: FOR_IN
49951: IFFALSE 50011
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
49953: LD_VAR 0 3
49957: PPUSH
49958: LD_VAR 0 5
49962: PPUSH
49963: CALL_OW 430
49967: PUSH
49968: LD_VAR 0 4
49972: PPUSH
49973: LD_VAR 0 5
49977: PPUSH
49978: CALL 63624 0 2
49982: AND
49983: IFFALSE 50009
// begin researching := true ;
49985: LD_ADDR_VAR 0 10
49989: PUSH
49990: LD_INT 1
49992: ST_TO_ADDR
// ComResearch ( j , t ) ;
49993: LD_VAR 0 3
49997: PPUSH
49998: LD_VAR 0 5
50002: PPUSH
50003: CALL_OW 124
// break ;
50007: GO 50011
// end ;
50009: GO 49950
50011: POP
50012: POP
// if not researching then
50013: LD_VAR 0 10
50017: NOT
50018: IFFALSE 50030
// idle_lab := j ;
50020: LD_ADDR_VAR 0 11
50024: PUSH
50025: LD_VAR 0 3
50029: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50030: LD_VAR 0 3
50034: PPUSH
50035: CALL_OW 461
50039: PUSH
50040: LD_INT 10
50042: EQUAL
50043: IFFALSE 50631
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50045: LD_EXP 128
50049: PUSH
50050: LD_VAR 0 2
50054: ARRAY
50055: NOT
50056: PUSH
50057: LD_EXP 129
50061: PUSH
50062: LD_VAR 0 2
50066: ARRAY
50067: NOT
50068: AND
50069: PUSH
50070: LD_EXP 126
50074: PUSH
50075: LD_VAR 0 4
50079: ARRAY
50080: PUSH
50081: LD_INT 1
50083: GREATER
50084: AND
50085: IFFALSE 50216
// begin ComCancel ( j ) ;
50087: LD_VAR 0 3
50091: PPUSH
50092: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50096: LD_ADDR_EXP 126
50100: PUSH
50101: LD_EXP 126
50105: PPUSH
50106: LD_VAR 0 4
50110: PPUSH
50111: LD_EXP 126
50115: PUSH
50116: LD_VAR 0 4
50120: ARRAY
50121: PPUSH
50122: LD_EXP 126
50126: PUSH
50127: LD_VAR 0 4
50131: ARRAY
50132: PUSH
50133: LD_INT 1
50135: MINUS
50136: PPUSH
50137: LD_EXP 126
50141: PUSH
50142: LD_VAR 0 4
50146: ARRAY
50147: PPUSH
50148: LD_INT 0
50150: PPUSH
50151: CALL 69073 0 4
50155: PPUSH
50156: CALL_OW 1
50160: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50161: LD_ADDR_EXP 126
50165: PUSH
50166: LD_EXP 126
50170: PPUSH
50171: LD_VAR 0 4
50175: PPUSH
50176: LD_EXP 126
50180: PUSH
50181: LD_VAR 0 4
50185: ARRAY
50186: PPUSH
50187: LD_EXP 126
50191: PUSH
50192: LD_VAR 0 4
50196: ARRAY
50197: PPUSH
50198: LD_INT 1
50200: PPUSH
50201: LD_INT 0
50203: PPUSH
50204: CALL 69073 0 4
50208: PPUSH
50209: CALL_OW 1
50213: ST_TO_ADDR
// continue ;
50214: GO 49788
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50216: LD_EXP 128
50220: PUSH
50221: LD_VAR 0 2
50225: ARRAY
50226: PUSH
50227: LD_EXP 129
50231: PUSH
50232: LD_VAR 0 2
50236: ARRAY
50237: NOT
50238: AND
50239: IFFALSE 50366
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50241: LD_ADDR_EXP 129
50245: PUSH
50246: LD_EXP 129
50250: PPUSH
50251: LD_VAR 0 2
50255: PUSH
50256: LD_EXP 129
50260: PUSH
50261: LD_VAR 0 2
50265: ARRAY
50266: PUSH
50267: LD_INT 1
50269: PLUS
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: LD_EXP 128
50279: PUSH
50280: LD_VAR 0 2
50284: ARRAY
50285: PUSH
50286: LD_INT 1
50288: ARRAY
50289: PPUSH
50290: CALL 69655 0 3
50294: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50295: LD_EXP 128
50299: PUSH
50300: LD_VAR 0 2
50304: ARRAY
50305: PUSH
50306: LD_INT 1
50308: ARRAY
50309: PPUSH
50310: LD_INT 112
50312: PPUSH
50313: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50317: LD_ADDR_VAR 0 9
50321: PUSH
50322: LD_EXP 128
50326: PUSH
50327: LD_VAR 0 2
50331: ARRAY
50332: PPUSH
50333: LD_INT 1
50335: PPUSH
50336: CALL_OW 3
50340: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50341: LD_ADDR_EXP 128
50345: PUSH
50346: LD_EXP 128
50350: PPUSH
50351: LD_VAR 0 2
50355: PPUSH
50356: LD_VAR 0 9
50360: PPUSH
50361: CALL_OW 1
50365: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50366: LD_EXP 128
50370: PUSH
50371: LD_VAR 0 2
50375: ARRAY
50376: PUSH
50377: LD_EXP 129
50381: PUSH
50382: LD_VAR 0 2
50386: ARRAY
50387: AND
50388: PUSH
50389: LD_EXP 129
50393: PUSH
50394: LD_VAR 0 2
50398: ARRAY
50399: PUSH
50400: LD_INT 1
50402: ARRAY
50403: PPUSH
50404: CALL_OW 310
50408: NOT
50409: AND
50410: PUSH
50411: LD_VAR 0 3
50415: PPUSH
50416: CALL_OW 313
50420: PUSH
50421: LD_INT 6
50423: EQUAL
50424: AND
50425: IFFALSE 50481
// begin tmp2 := UnitsInside ( j ) ;
50427: LD_ADDR_VAR 0 9
50431: PUSH
50432: LD_VAR 0 3
50436: PPUSH
50437: CALL_OW 313
50441: ST_TO_ADDR
// if tmp2 = 6 then
50442: LD_VAR 0 9
50446: PUSH
50447: LD_INT 6
50449: EQUAL
50450: IFFALSE 50481
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50452: LD_VAR 0 9
50456: PUSH
50457: LD_INT 1
50459: ARRAY
50460: PPUSH
50461: LD_INT 112
50463: PPUSH
50464: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50468: LD_VAR 0 9
50472: PUSH
50473: LD_INT 1
50475: ARRAY
50476: PPUSH
50477: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50481: LD_EXP 129
50485: PUSH
50486: LD_VAR 0 2
50490: ARRAY
50491: PUSH
50492: LD_EXP 129
50496: PUSH
50497: LD_VAR 0 2
50501: ARRAY
50502: PUSH
50503: LD_INT 1
50505: ARRAY
50506: PPUSH
50507: CALL_OW 314
50511: NOT
50512: AND
50513: PUSH
50514: LD_EXP 129
50518: PUSH
50519: LD_VAR 0 2
50523: ARRAY
50524: PUSH
50525: LD_INT 1
50527: ARRAY
50528: PPUSH
50529: CALL_OW 310
50533: NOT
50534: AND
50535: IFFALSE 50561
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50537: LD_EXP 129
50541: PUSH
50542: LD_VAR 0 2
50546: ARRAY
50547: PUSH
50548: LD_INT 1
50550: ARRAY
50551: PPUSH
50552: LD_VAR 0 3
50556: PPUSH
50557: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50561: LD_EXP 129
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: PUSH
50572: LD_INT 1
50574: ARRAY
50575: PPUSH
50576: CALL_OW 310
50580: PUSH
50581: LD_EXP 129
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PUSH
50592: LD_INT 1
50594: ARRAY
50595: PPUSH
50596: CALL_OW 310
50600: PPUSH
50601: CALL_OW 461
50605: PUSH
50606: LD_INT 3
50608: NONEQUAL
50609: AND
50610: IFFALSE 50631
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
50612: LD_EXP 129
50616: PUSH
50617: LD_VAR 0 2
50621: ARRAY
50622: PUSH
50623: LD_INT 1
50625: ARRAY
50626: PPUSH
50627: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
50631: LD_VAR 0 3
50635: PPUSH
50636: CALL_OW 461
50640: PUSH
50641: LD_INT 6
50643: EQUAL
50644: PUSH
50645: LD_VAR 0 6
50649: PUSH
50650: LD_INT 1
50652: GREATER
50653: AND
50654: IFFALSE 50806
// begin sci := [ ] ;
50656: LD_ADDR_VAR 0 8
50660: PUSH
50661: EMPTY
50662: ST_TO_ADDR
// for x in ( tmp diff j ) do
50663: LD_ADDR_VAR 0 7
50667: PUSH
50668: LD_VAR 0 6
50672: PUSH
50673: LD_VAR 0 3
50677: DIFF
50678: PUSH
50679: FOR_IN
50680: IFFALSE 50732
// begin if sci = 6 then
50682: LD_VAR 0 8
50686: PUSH
50687: LD_INT 6
50689: EQUAL
50690: IFFALSE 50694
// break ;
50692: GO 50732
// if BuildingStatus ( x ) = bs_idle then
50694: LD_VAR 0 7
50698: PPUSH
50699: CALL_OW 461
50703: PUSH
50704: LD_INT 2
50706: EQUAL
50707: IFFALSE 50730
// sci := sci ^ UnitsInside ( x ) ;
50709: LD_ADDR_VAR 0 8
50713: PUSH
50714: LD_VAR 0 8
50718: PUSH
50719: LD_VAR 0 7
50723: PPUSH
50724: CALL_OW 313
50728: ADD
50729: ST_TO_ADDR
// end ;
50730: GO 50679
50732: POP
50733: POP
// if not sci then
50734: LD_VAR 0 8
50738: NOT
50739: IFFALSE 50743
// continue ;
50741: GO 49788
// for x in sci do
50743: LD_ADDR_VAR 0 7
50747: PUSH
50748: LD_VAR 0 8
50752: PUSH
50753: FOR_IN
50754: IFFALSE 50804
// if IsInUnit ( x ) and not HasTask ( x ) then
50756: LD_VAR 0 7
50760: PPUSH
50761: CALL_OW 310
50765: PUSH
50766: LD_VAR 0 7
50770: PPUSH
50771: CALL_OW 314
50775: NOT
50776: AND
50777: IFFALSE 50802
// begin ComExitBuilding ( x ) ;
50779: LD_VAR 0 7
50783: PPUSH
50784: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50788: LD_VAR 0 7
50792: PPUSH
50793: LD_VAR 0 3
50797: PPUSH
50798: CALL_OW 180
// end ;
50802: GO 50753
50804: POP
50805: POP
// end ; end ;
50806: GO 49788
50808: POP
50809: POP
// end ;
50810: GO 49742
50812: POP
50813: POP
// end ;
50814: LD_VAR 0 1
50818: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
50819: LD_INT 0
50821: PPUSH
50822: PPUSH
// if not mc_bases then
50823: LD_EXP 99
50827: NOT
50828: IFFALSE 50832
// exit ;
50830: GO 50913
// for i = 1 to mc_bases do
50832: LD_ADDR_VAR 0 2
50836: PUSH
50837: DOUBLE
50838: LD_INT 1
50840: DEC
50841: ST_TO_ADDR
50842: LD_EXP 99
50846: PUSH
50847: FOR_TO
50848: IFFALSE 50911
// if mc_mines [ i ] and mc_miners [ i ] then
50850: LD_EXP 112
50854: PUSH
50855: LD_VAR 0 2
50859: ARRAY
50860: PUSH
50861: LD_EXP 113
50865: PUSH
50866: LD_VAR 0 2
50870: ARRAY
50871: AND
50872: IFFALSE 50909
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
50874: LD_EXP 113
50878: PUSH
50879: LD_VAR 0 2
50883: ARRAY
50884: PUSH
50885: LD_INT 1
50887: ARRAY
50888: PPUSH
50889: CALL_OW 255
50893: PPUSH
50894: LD_EXP 112
50898: PUSH
50899: LD_VAR 0 2
50903: ARRAY
50904: PPUSH
50905: CALL 66712 0 2
50909: GO 50847
50911: POP
50912: POP
// end ;
50913: LD_VAR 0 1
50917: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
50918: LD_INT 0
50920: PPUSH
50921: PPUSH
50922: PPUSH
50923: PPUSH
50924: PPUSH
50925: PPUSH
50926: PPUSH
50927: PPUSH
// if not mc_bases or not mc_parking then
50928: LD_EXP 99
50932: NOT
50933: PUSH
50934: LD_EXP 123
50938: NOT
50939: OR
50940: IFFALSE 50944
// exit ;
50942: GO 51656
// for i = 1 to mc_bases do
50944: LD_ADDR_VAR 0 2
50948: PUSH
50949: DOUBLE
50950: LD_INT 1
50952: DEC
50953: ST_TO_ADDR
50954: LD_EXP 99
50958: PUSH
50959: FOR_TO
50960: IFFALSE 51654
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
50962: LD_EXP 99
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: NOT
50973: PUSH
50974: LD_EXP 123
50978: PUSH
50979: LD_VAR 0 2
50983: ARRAY
50984: NOT
50985: OR
50986: IFFALSE 50990
// continue ;
50988: GO 50959
// if mc_scan [ i ] then
50990: LD_EXP 122
50994: PUSH
50995: LD_VAR 0 2
50999: ARRAY
51000: IFFALSE 51026
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51002: LD_ADDR_EXP 111
51006: PUSH
51007: LD_EXP 111
51011: PPUSH
51012: LD_VAR 0 2
51016: PPUSH
51017: EMPTY
51018: PPUSH
51019: CALL_OW 1
51023: ST_TO_ADDR
// continue ;
51024: GO 50959
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51026: LD_ADDR_VAR 0 5
51030: PUSH
51031: LD_EXP 99
51035: PUSH
51036: LD_VAR 0 2
51040: ARRAY
51041: PUSH
51042: LD_INT 1
51044: ARRAY
51045: PPUSH
51046: CALL_OW 255
51050: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51051: LD_ADDR_VAR 0 6
51055: PUSH
51056: LD_EXP 99
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PPUSH
51067: LD_INT 30
51069: PUSH
51070: LD_INT 3
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: PPUSH
51077: CALL_OW 72
51081: ST_TO_ADDR
// if not fac then
51082: LD_VAR 0 6
51086: NOT
51087: IFFALSE 51138
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51089: LD_ADDR_VAR 0 6
51093: PUSH
51094: LD_EXP 99
51098: PUSH
51099: LD_VAR 0 2
51103: ARRAY
51104: PPUSH
51105: LD_INT 2
51107: PUSH
51108: LD_INT 30
51110: PUSH
51111: LD_INT 0
51113: PUSH
51114: EMPTY
51115: LIST
51116: LIST
51117: PUSH
51118: LD_INT 30
51120: PUSH
51121: LD_INT 1
51123: PUSH
51124: EMPTY
51125: LIST
51126: LIST
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: LIST
51132: PPUSH
51133: CALL_OW 72
51137: ST_TO_ADDR
// if not fac then
51138: LD_VAR 0 6
51142: NOT
51143: IFFALSE 51147
// continue ;
51145: GO 50959
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51147: LD_ADDR_VAR 0 7
51151: PUSH
51152: LD_EXP 123
51156: PUSH
51157: LD_VAR 0 2
51161: ARRAY
51162: PPUSH
51163: LD_INT 22
51165: PUSH
51166: LD_VAR 0 5
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: PUSH
51175: LD_INT 21
51177: PUSH
51178: LD_INT 2
51180: PUSH
51181: EMPTY
51182: LIST
51183: LIST
51184: PUSH
51185: LD_INT 3
51187: PUSH
51188: LD_INT 24
51190: PUSH
51191: LD_INT 1000
51193: PUSH
51194: EMPTY
51195: LIST
51196: LIST
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: EMPTY
51203: LIST
51204: LIST
51205: LIST
51206: PPUSH
51207: CALL_OW 70
51211: PUSH
51212: LD_INT 22
51214: PUSH
51215: LD_VAR 0 5
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: LD_INT 91
51226: PUSH
51227: LD_VAR 0 6
51231: PUSH
51232: LD_INT 1
51234: ARRAY
51235: PUSH
51236: LD_INT 25
51238: PUSH
51239: EMPTY
51240: LIST
51241: LIST
51242: LIST
51243: PUSH
51244: LD_INT 21
51246: PUSH
51247: LD_INT 2
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: LD_INT 3
51256: PUSH
51257: LD_INT 24
51259: PUSH
51260: LD_INT 1000
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: PUSH
51267: EMPTY
51268: LIST
51269: LIST
51270: PUSH
51271: EMPTY
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: PPUSH
51277: CALL_OW 69
51281: UNION
51282: ST_TO_ADDR
// if not vehs then
51283: LD_VAR 0 7
51287: NOT
51288: IFFALSE 51314
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51290: LD_ADDR_EXP 111
51294: PUSH
51295: LD_EXP 111
51299: PPUSH
51300: LD_VAR 0 2
51304: PPUSH
51305: EMPTY
51306: PPUSH
51307: CALL_OW 1
51311: ST_TO_ADDR
// continue ;
51312: GO 50959
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51314: LD_ADDR_VAR 0 8
51318: PUSH
51319: LD_EXP 99
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: PPUSH
51330: LD_INT 30
51332: PUSH
51333: LD_INT 3
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PPUSH
51340: CALL_OW 72
51344: ST_TO_ADDR
// if tmp then
51345: LD_VAR 0 8
51349: IFFALSE 51452
// begin for j in tmp do
51351: LD_ADDR_VAR 0 3
51355: PUSH
51356: LD_VAR 0 8
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51450
// for k in UnitsInside ( j ) do
51364: LD_ADDR_VAR 0 4
51368: PUSH
51369: LD_VAR 0 3
51373: PPUSH
51374: CALL_OW 313
51378: PUSH
51379: FOR_IN
51380: IFFALSE 51446
// if k then
51382: LD_VAR 0 4
51386: IFFALSE 51444
// if not k in mc_repair_vehicle [ i ] then
51388: LD_VAR 0 4
51392: PUSH
51393: LD_EXP 111
51397: PUSH
51398: LD_VAR 0 2
51402: ARRAY
51403: IN
51404: NOT
51405: IFFALSE 51444
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51407: LD_ADDR_EXP 111
51411: PUSH
51412: LD_EXP 111
51416: PPUSH
51417: LD_VAR 0 2
51421: PPUSH
51422: LD_EXP 111
51426: PUSH
51427: LD_VAR 0 2
51431: ARRAY
51432: PUSH
51433: LD_VAR 0 4
51437: UNION
51438: PPUSH
51439: CALL_OW 1
51443: ST_TO_ADDR
51444: GO 51379
51446: POP
51447: POP
51448: GO 51361
51450: POP
51451: POP
// end ; if not mc_repair_vehicle [ i ] then
51452: LD_EXP 111
51456: PUSH
51457: LD_VAR 0 2
51461: ARRAY
51462: NOT
51463: IFFALSE 51467
// continue ;
51465: GO 50959
// for j in mc_repair_vehicle [ i ] do
51467: LD_ADDR_VAR 0 3
51471: PUSH
51472: LD_EXP 111
51476: PUSH
51477: LD_VAR 0 2
51481: ARRAY
51482: PUSH
51483: FOR_IN
51484: IFFALSE 51650
// begin if GetClass ( j ) <> 3 then
51486: LD_VAR 0 3
51490: PPUSH
51491: CALL_OW 257
51495: PUSH
51496: LD_INT 3
51498: NONEQUAL
51499: IFFALSE 51540
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51501: LD_ADDR_EXP 111
51505: PUSH
51506: LD_EXP 111
51510: PPUSH
51511: LD_VAR 0 2
51515: PPUSH
51516: LD_EXP 111
51520: PUSH
51521: LD_VAR 0 2
51525: ARRAY
51526: PUSH
51527: LD_VAR 0 3
51531: DIFF
51532: PPUSH
51533: CALL_OW 1
51537: ST_TO_ADDR
// continue ;
51538: GO 51483
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51540: LD_VAR 0 3
51544: PPUSH
51545: CALL_OW 311
51549: NOT
51550: PUSH
51551: LD_VAR 0 3
51555: PUSH
51556: LD_EXP 102
51560: PUSH
51561: LD_VAR 0 2
51565: ARRAY
51566: PUSH
51567: LD_INT 1
51569: ARRAY
51570: IN
51571: NOT
51572: AND
51573: PUSH
51574: LD_VAR 0 3
51578: PUSH
51579: LD_EXP 102
51583: PUSH
51584: LD_VAR 0 2
51588: ARRAY
51589: PUSH
51590: LD_INT 2
51592: ARRAY
51593: IN
51594: NOT
51595: AND
51596: IFFALSE 51648
// begin if IsInUnit ( j ) then
51598: LD_VAR 0 3
51602: PPUSH
51603: CALL_OW 310
51607: IFFALSE 51618
// ComExitBuilding ( j ) ;
51609: LD_VAR 0 3
51613: PPUSH
51614: CALL_OW 122
// if not HasTask ( j ) then
51618: LD_VAR 0 3
51622: PPUSH
51623: CALL_OW 314
51627: NOT
51628: IFFALSE 51648
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
51630: LD_VAR 0 3
51634: PPUSH
51635: LD_VAR 0 7
51639: PUSH
51640: LD_INT 1
51642: ARRAY
51643: PPUSH
51644: CALL_OW 189
// end ; end ;
51648: GO 51483
51650: POP
51651: POP
// end ;
51652: GO 50959
51654: POP
51655: POP
// end ;
51656: LD_VAR 0 1
51660: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
51661: LD_INT 0
51663: PPUSH
51664: PPUSH
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
// if not mc_bases then
51674: LD_EXP 99
51678: NOT
51679: IFFALSE 51683
// exit ;
51681: GO 52485
// for i = 1 to mc_bases do
51683: LD_ADDR_VAR 0 2
51687: PUSH
51688: DOUBLE
51689: LD_INT 1
51691: DEC
51692: ST_TO_ADDR
51693: LD_EXP 99
51697: PUSH
51698: FOR_TO
51699: IFFALSE 52483
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
51701: LD_EXP 127
51705: PUSH
51706: LD_VAR 0 2
51710: ARRAY
51711: NOT
51712: PUSH
51713: LD_EXP 102
51717: PUSH
51718: LD_VAR 0 2
51722: ARRAY
51723: PUSH
51724: LD_INT 1
51726: ARRAY
51727: OR
51728: PUSH
51729: LD_EXP 102
51733: PUSH
51734: LD_VAR 0 2
51738: ARRAY
51739: PUSH
51740: LD_INT 2
51742: ARRAY
51743: OR
51744: PUSH
51745: LD_EXP 125
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PPUSH
51756: LD_INT 1
51758: PPUSH
51759: CALL_OW 325
51763: NOT
51764: OR
51765: PUSH
51766: LD_EXP 122
51770: PUSH
51771: LD_VAR 0 2
51775: ARRAY
51776: OR
51777: IFFALSE 51781
// continue ;
51779: GO 51698
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
51781: LD_ADDR_VAR 0 8
51785: PUSH
51786: LD_EXP 99
51790: PUSH
51791: LD_VAR 0 2
51795: ARRAY
51796: PPUSH
51797: LD_INT 25
51799: PUSH
51800: LD_INT 4
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PUSH
51807: LD_INT 50
51809: PUSH
51810: EMPTY
51811: LIST
51812: PUSH
51813: LD_INT 3
51815: PUSH
51816: LD_INT 60
51818: PUSH
51819: EMPTY
51820: LIST
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: PUSH
51826: EMPTY
51827: LIST
51828: LIST
51829: LIST
51830: PPUSH
51831: CALL_OW 72
51835: PUSH
51836: LD_EXP 103
51840: PUSH
51841: LD_VAR 0 2
51845: ARRAY
51846: DIFF
51847: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51848: LD_ADDR_VAR 0 9
51852: PUSH
51853: LD_EXP 99
51857: PUSH
51858: LD_VAR 0 2
51862: ARRAY
51863: PPUSH
51864: LD_INT 2
51866: PUSH
51867: LD_INT 30
51869: PUSH
51870: LD_INT 0
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: PUSH
51877: LD_INT 30
51879: PUSH
51880: LD_INT 1
51882: PUSH
51883: EMPTY
51884: LIST
51885: LIST
51886: PUSH
51887: EMPTY
51888: LIST
51889: LIST
51890: LIST
51891: PPUSH
51892: CALL_OW 72
51896: ST_TO_ADDR
// if not tmp or not dep then
51897: LD_VAR 0 8
51901: NOT
51902: PUSH
51903: LD_VAR 0 9
51907: NOT
51908: OR
51909: IFFALSE 51913
// continue ;
51911: GO 51698
// side := GetSide ( tmp [ 1 ] ) ;
51913: LD_ADDR_VAR 0 11
51917: PUSH
51918: LD_VAR 0 8
51922: PUSH
51923: LD_INT 1
51925: ARRAY
51926: PPUSH
51927: CALL_OW 255
51931: ST_TO_ADDR
// dep := dep [ 1 ] ;
51932: LD_ADDR_VAR 0 9
51936: PUSH
51937: LD_VAR 0 9
51941: PUSH
51942: LD_INT 1
51944: ARRAY
51945: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
51946: LD_ADDR_VAR 0 7
51950: PUSH
51951: LD_EXP 127
51955: PUSH
51956: LD_VAR 0 2
51960: ARRAY
51961: PPUSH
51962: LD_INT 22
51964: PUSH
51965: LD_INT 0
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: PUSH
51972: LD_INT 25
51974: PUSH
51975: LD_INT 12
51977: PUSH
51978: EMPTY
51979: LIST
51980: LIST
51981: PUSH
51982: EMPTY
51983: LIST
51984: LIST
51985: PPUSH
51986: CALL_OW 70
51990: PUSH
51991: LD_INT 22
51993: PUSH
51994: LD_INT 0
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: PUSH
52001: LD_INT 25
52003: PUSH
52004: LD_INT 12
52006: PUSH
52007: EMPTY
52008: LIST
52009: LIST
52010: PUSH
52011: LD_INT 91
52013: PUSH
52014: LD_VAR 0 9
52018: PUSH
52019: LD_INT 20
52021: PUSH
52022: EMPTY
52023: LIST
52024: LIST
52025: LIST
52026: PUSH
52027: EMPTY
52028: LIST
52029: LIST
52030: LIST
52031: PPUSH
52032: CALL_OW 69
52036: UNION
52037: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52038: LD_ADDR_VAR 0 10
52042: PUSH
52043: LD_EXP 127
52047: PUSH
52048: LD_VAR 0 2
52052: ARRAY
52053: PPUSH
52054: LD_INT 81
52056: PUSH
52057: LD_VAR 0 11
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: PPUSH
52066: CALL_OW 70
52070: ST_TO_ADDR
// if not apes or danger_at_area then
52071: LD_VAR 0 7
52075: NOT
52076: PUSH
52077: LD_VAR 0 10
52081: OR
52082: IFFALSE 52132
// begin if mc_taming [ i ] then
52084: LD_EXP 130
52088: PUSH
52089: LD_VAR 0 2
52093: ARRAY
52094: IFFALSE 52130
// begin MC_Reset ( i , 121 ) ;
52096: LD_VAR 0 2
52100: PPUSH
52101: LD_INT 121
52103: PPUSH
52104: CALL 37767 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52108: LD_ADDR_EXP 130
52112: PUSH
52113: LD_EXP 130
52117: PPUSH
52118: LD_VAR 0 2
52122: PPUSH
52123: EMPTY
52124: PPUSH
52125: CALL_OW 1
52129: ST_TO_ADDR
// end ; continue ;
52130: GO 51698
// end ; for j in tmp do
52132: LD_ADDR_VAR 0 3
52136: PUSH
52137: LD_VAR 0 8
52141: PUSH
52142: FOR_IN
52143: IFFALSE 52479
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52145: LD_VAR 0 3
52149: PUSH
52150: LD_EXP 130
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: IN
52161: NOT
52162: PUSH
52163: LD_EXP 130
52167: PUSH
52168: LD_VAR 0 2
52172: ARRAY
52173: PUSH
52174: LD_INT 3
52176: LESS
52177: AND
52178: IFFALSE 52236
// begin SetTag ( j , 121 ) ;
52180: LD_VAR 0 3
52184: PPUSH
52185: LD_INT 121
52187: PPUSH
52188: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52192: LD_ADDR_EXP 130
52196: PUSH
52197: LD_EXP 130
52201: PPUSH
52202: LD_VAR 0 2
52206: PUSH
52207: LD_EXP 130
52211: PUSH
52212: LD_VAR 0 2
52216: ARRAY
52217: PUSH
52218: LD_INT 1
52220: PLUS
52221: PUSH
52222: EMPTY
52223: LIST
52224: LIST
52225: PPUSH
52226: LD_VAR 0 3
52230: PPUSH
52231: CALL 69655 0 3
52235: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52236: LD_VAR 0 3
52240: PUSH
52241: LD_EXP 130
52245: PUSH
52246: LD_VAR 0 2
52250: ARRAY
52251: IN
52252: IFFALSE 52477
// begin if GetClass ( j ) <> 4 then
52254: LD_VAR 0 3
52258: PPUSH
52259: CALL_OW 257
52263: PUSH
52264: LD_INT 4
52266: NONEQUAL
52267: IFFALSE 52320
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52269: LD_ADDR_EXP 130
52273: PUSH
52274: LD_EXP 130
52278: PPUSH
52279: LD_VAR 0 2
52283: PPUSH
52284: LD_EXP 130
52288: PUSH
52289: LD_VAR 0 2
52293: ARRAY
52294: PUSH
52295: LD_VAR 0 3
52299: DIFF
52300: PPUSH
52301: CALL_OW 1
52305: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52306: LD_VAR 0 3
52310: PPUSH
52311: LD_INT 0
52313: PPUSH
52314: CALL_OW 109
// continue ;
52318: GO 52142
// end ; if IsInUnit ( j ) then
52320: LD_VAR 0 3
52324: PPUSH
52325: CALL_OW 310
52329: IFFALSE 52340
// ComExitBuilding ( j ) ;
52331: LD_VAR 0 3
52335: PPUSH
52336: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52340: LD_ADDR_VAR 0 6
52344: PUSH
52345: LD_VAR 0 7
52349: PPUSH
52350: LD_VAR 0 3
52354: PPUSH
52355: CALL_OW 74
52359: ST_TO_ADDR
// if not ape then
52360: LD_VAR 0 6
52364: NOT
52365: IFFALSE 52369
// break ;
52367: GO 52479
// x := GetX ( ape ) ;
52369: LD_ADDR_VAR 0 4
52373: PUSH
52374: LD_VAR 0 6
52378: PPUSH
52379: CALL_OW 250
52383: ST_TO_ADDR
// y := GetY ( ape ) ;
52384: LD_ADDR_VAR 0 5
52388: PUSH
52389: LD_VAR 0 6
52393: PPUSH
52394: CALL_OW 251
52398: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52399: LD_VAR 0 4
52403: PPUSH
52404: LD_VAR 0 5
52408: PPUSH
52409: CALL_OW 488
52413: NOT
52414: PUSH
52415: LD_VAR 0 11
52419: PPUSH
52420: LD_VAR 0 4
52424: PPUSH
52425: LD_VAR 0 5
52429: PPUSH
52430: LD_INT 20
52432: PPUSH
52433: CALL 70551 0 4
52437: PUSH
52438: LD_INT 4
52440: ARRAY
52441: OR
52442: IFFALSE 52446
// break ;
52444: GO 52479
// if not HasTask ( j ) then
52446: LD_VAR 0 3
52450: PPUSH
52451: CALL_OW 314
52455: NOT
52456: IFFALSE 52477
// ComTameXY ( j , x , y ) ;
52458: LD_VAR 0 3
52462: PPUSH
52463: LD_VAR 0 4
52467: PPUSH
52468: LD_VAR 0 5
52472: PPUSH
52473: CALL_OW 131
// end ; end ;
52477: GO 52142
52479: POP
52480: POP
// end ;
52481: GO 51698
52483: POP
52484: POP
// end ;
52485: LD_VAR 0 1
52489: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52490: LD_INT 0
52492: PPUSH
52493: PPUSH
52494: PPUSH
52495: PPUSH
52496: PPUSH
52497: PPUSH
52498: PPUSH
52499: PPUSH
// if not mc_bases then
52500: LD_EXP 99
52504: NOT
52505: IFFALSE 52509
// exit ;
52507: GO 53135
// for i = 1 to mc_bases do
52509: LD_ADDR_VAR 0 2
52513: PUSH
52514: DOUBLE
52515: LD_INT 1
52517: DEC
52518: ST_TO_ADDR
52519: LD_EXP 99
52523: PUSH
52524: FOR_TO
52525: IFFALSE 53133
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52527: LD_EXP 128
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: NOT
52538: PUSH
52539: LD_EXP 128
52543: PUSH
52544: LD_VAR 0 2
52548: ARRAY
52549: PPUSH
52550: LD_INT 25
52552: PUSH
52553: LD_INT 12
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: PPUSH
52560: CALL_OW 72
52564: NOT
52565: OR
52566: IFFALSE 52570
// continue ;
52568: GO 52524
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52570: LD_ADDR_VAR 0 5
52574: PUSH
52575: LD_EXP 128
52579: PUSH
52580: LD_VAR 0 2
52584: ARRAY
52585: PUSH
52586: LD_INT 1
52588: ARRAY
52589: PPUSH
52590: CALL_OW 255
52594: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52595: LD_VAR 0 5
52599: PPUSH
52600: LD_INT 2
52602: PPUSH
52603: CALL_OW 325
52607: IFFALSE 52860
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52609: LD_ADDR_VAR 0 4
52613: PUSH
52614: LD_EXP 128
52618: PUSH
52619: LD_VAR 0 2
52623: ARRAY
52624: PPUSH
52625: LD_INT 25
52627: PUSH
52628: LD_INT 16
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PPUSH
52635: CALL_OW 72
52639: ST_TO_ADDR
// if tmp < 6 then
52640: LD_VAR 0 4
52644: PUSH
52645: LD_INT 6
52647: LESS
52648: IFFALSE 52860
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52650: LD_ADDR_VAR 0 6
52654: PUSH
52655: LD_EXP 99
52659: PUSH
52660: LD_VAR 0 2
52664: ARRAY
52665: PPUSH
52666: LD_INT 2
52668: PUSH
52669: LD_INT 30
52671: PUSH
52672: LD_INT 0
52674: PUSH
52675: EMPTY
52676: LIST
52677: LIST
52678: PUSH
52679: LD_INT 30
52681: PUSH
52682: LD_INT 1
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: PUSH
52689: EMPTY
52690: LIST
52691: LIST
52692: LIST
52693: PPUSH
52694: CALL_OW 72
52698: ST_TO_ADDR
// if depot then
52699: LD_VAR 0 6
52703: IFFALSE 52860
// begin selected := 0 ;
52705: LD_ADDR_VAR 0 7
52709: PUSH
52710: LD_INT 0
52712: ST_TO_ADDR
// for j in depot do
52713: LD_ADDR_VAR 0 3
52717: PUSH
52718: LD_VAR 0 6
52722: PUSH
52723: FOR_IN
52724: IFFALSE 52755
// begin if UnitsInside ( j ) < 6 then
52726: LD_VAR 0 3
52730: PPUSH
52731: CALL_OW 313
52735: PUSH
52736: LD_INT 6
52738: LESS
52739: IFFALSE 52753
// begin selected := j ;
52741: LD_ADDR_VAR 0 7
52745: PUSH
52746: LD_VAR 0 3
52750: ST_TO_ADDR
// break ;
52751: GO 52755
// end ; end ;
52753: GO 52723
52755: POP
52756: POP
// if selected then
52757: LD_VAR 0 7
52761: IFFALSE 52860
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52763: LD_ADDR_VAR 0 3
52767: PUSH
52768: LD_EXP 128
52772: PUSH
52773: LD_VAR 0 2
52777: ARRAY
52778: PPUSH
52779: LD_INT 25
52781: PUSH
52782: LD_INT 12
52784: PUSH
52785: EMPTY
52786: LIST
52787: LIST
52788: PPUSH
52789: CALL_OW 72
52793: PUSH
52794: FOR_IN
52795: IFFALSE 52858
// if not HasTask ( j ) then
52797: LD_VAR 0 3
52801: PPUSH
52802: CALL_OW 314
52806: NOT
52807: IFFALSE 52856
// begin if not IsInUnit ( j ) then
52809: LD_VAR 0 3
52813: PPUSH
52814: CALL_OW 310
52818: NOT
52819: IFFALSE 52835
// ComEnterUnit ( j , selected ) ;
52821: LD_VAR 0 3
52825: PPUSH
52826: LD_VAR 0 7
52830: PPUSH
52831: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
52835: LD_VAR 0 3
52839: PPUSH
52840: LD_INT 16
52842: PPUSH
52843: CALL_OW 183
// AddComExitBuilding ( j ) ;
52847: LD_VAR 0 3
52851: PPUSH
52852: CALL_OW 182
// end ;
52856: GO 52794
52858: POP
52859: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
52860: LD_VAR 0 5
52864: PPUSH
52865: LD_INT 11
52867: PPUSH
52868: CALL_OW 325
52872: IFFALSE 53131
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52874: LD_ADDR_VAR 0 4
52878: PUSH
52879: LD_EXP 128
52883: PUSH
52884: LD_VAR 0 2
52888: ARRAY
52889: PPUSH
52890: LD_INT 25
52892: PUSH
52893: LD_INT 16
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PPUSH
52900: CALL_OW 72
52904: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
52905: LD_VAR 0 4
52909: PUSH
52910: LD_INT 6
52912: GREATEREQUAL
52913: PUSH
52914: LD_VAR 0 5
52918: PPUSH
52919: LD_INT 2
52921: PPUSH
52922: CALL_OW 325
52926: NOT
52927: OR
52928: IFFALSE 53131
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52930: LD_ADDR_VAR 0 8
52934: PUSH
52935: LD_EXP 99
52939: PUSH
52940: LD_VAR 0 2
52944: ARRAY
52945: PPUSH
52946: LD_INT 2
52948: PUSH
52949: LD_INT 30
52951: PUSH
52952: LD_INT 4
52954: PUSH
52955: EMPTY
52956: LIST
52957: LIST
52958: PUSH
52959: LD_INT 30
52961: PUSH
52962: LD_INT 5
52964: PUSH
52965: EMPTY
52966: LIST
52967: LIST
52968: PUSH
52969: EMPTY
52970: LIST
52971: LIST
52972: LIST
52973: PPUSH
52974: CALL_OW 72
52978: ST_TO_ADDR
// if barracks then
52979: LD_VAR 0 8
52983: IFFALSE 53131
// begin selected := 0 ;
52985: LD_ADDR_VAR 0 7
52989: PUSH
52990: LD_INT 0
52992: ST_TO_ADDR
// for j in barracks do
52993: LD_ADDR_VAR 0 3
52997: PUSH
52998: LD_VAR 0 8
53002: PUSH
53003: FOR_IN
53004: IFFALSE 53035
// begin if UnitsInside ( j ) < 6 then
53006: LD_VAR 0 3
53010: PPUSH
53011: CALL_OW 313
53015: PUSH
53016: LD_INT 6
53018: LESS
53019: IFFALSE 53033
// begin selected := j ;
53021: LD_ADDR_VAR 0 7
53025: PUSH
53026: LD_VAR 0 3
53030: ST_TO_ADDR
// break ;
53031: GO 53035
// end ; end ;
53033: GO 53003
53035: POP
53036: POP
// if selected then
53037: LD_VAR 0 7
53041: IFFALSE 53131
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53043: LD_ADDR_VAR 0 3
53047: PUSH
53048: LD_EXP 128
53052: PUSH
53053: LD_VAR 0 2
53057: ARRAY
53058: PPUSH
53059: LD_INT 25
53061: PUSH
53062: LD_INT 12
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: PPUSH
53069: CALL_OW 72
53073: PUSH
53074: FOR_IN
53075: IFFALSE 53129
// if not IsInUnit ( j ) and not HasTask ( j ) then
53077: LD_VAR 0 3
53081: PPUSH
53082: CALL_OW 310
53086: NOT
53087: PUSH
53088: LD_VAR 0 3
53092: PPUSH
53093: CALL_OW 314
53097: NOT
53098: AND
53099: IFFALSE 53127
// begin ComEnterUnit ( j , selected ) ;
53101: LD_VAR 0 3
53105: PPUSH
53106: LD_VAR 0 7
53110: PPUSH
53111: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53115: LD_VAR 0 3
53119: PPUSH
53120: LD_INT 15
53122: PPUSH
53123: CALL_OW 183
// end ;
53127: GO 53074
53129: POP
53130: POP
// end ; end ; end ; end ; end ;
53131: GO 52524
53133: POP
53134: POP
// end ;
53135: LD_VAR 0 1
53139: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53140: LD_INT 0
53142: PPUSH
53143: PPUSH
53144: PPUSH
53145: PPUSH
// if not mc_bases then
53146: LD_EXP 99
53150: NOT
53151: IFFALSE 53155
// exit ;
53153: GO 53333
// for i = 1 to mc_bases do
53155: LD_ADDR_VAR 0 2
53159: PUSH
53160: DOUBLE
53161: LD_INT 1
53163: DEC
53164: ST_TO_ADDR
53165: LD_EXP 99
53169: PUSH
53170: FOR_TO
53171: IFFALSE 53331
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53173: LD_ADDR_VAR 0 4
53177: PUSH
53178: LD_EXP 99
53182: PUSH
53183: LD_VAR 0 2
53187: ARRAY
53188: PPUSH
53189: LD_INT 25
53191: PUSH
53192: LD_INT 9
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PPUSH
53199: CALL_OW 72
53203: ST_TO_ADDR
// if not tmp then
53204: LD_VAR 0 4
53208: NOT
53209: IFFALSE 53213
// continue ;
53211: GO 53170
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53213: LD_EXP 125
53217: PUSH
53218: LD_VAR 0 2
53222: ARRAY
53223: PPUSH
53224: LD_INT 29
53226: PPUSH
53227: CALL_OW 325
53231: NOT
53232: PUSH
53233: LD_EXP 125
53237: PUSH
53238: LD_VAR 0 2
53242: ARRAY
53243: PPUSH
53244: LD_INT 28
53246: PPUSH
53247: CALL_OW 325
53251: NOT
53252: AND
53253: IFFALSE 53257
// continue ;
53255: GO 53170
// for j in tmp do
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_VAR 0 4
53266: PUSH
53267: FOR_IN
53268: IFFALSE 53327
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53270: LD_VAR 0 3
53274: PUSH
53275: LD_EXP 102
53279: PUSH
53280: LD_VAR 0 2
53284: ARRAY
53285: PUSH
53286: LD_INT 1
53288: ARRAY
53289: IN
53290: NOT
53291: PUSH
53292: LD_VAR 0 3
53296: PUSH
53297: LD_EXP 102
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PUSH
53308: LD_INT 2
53310: ARRAY
53311: IN
53312: NOT
53313: AND
53314: IFFALSE 53325
// ComSpaceTimeShoot ( j ) ;
53316: LD_VAR 0 3
53320: PPUSH
53321: CALL 63715 0 1
53325: GO 53267
53327: POP
53328: POP
// end ;
53329: GO 53170
53331: POP
53332: POP
// end ;
53333: LD_VAR 0 1
53337: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53338: LD_INT 0
53340: PPUSH
53341: PPUSH
53342: PPUSH
53343: PPUSH
53344: PPUSH
53345: PPUSH
53346: PPUSH
53347: PPUSH
53348: PPUSH
// if not mc_bases then
53349: LD_EXP 99
53353: NOT
53354: IFFALSE 53358
// exit ;
53356: GO 53980
// for i = 1 to mc_bases do
53358: LD_ADDR_VAR 0 2
53362: PUSH
53363: DOUBLE
53364: LD_INT 1
53366: DEC
53367: ST_TO_ADDR
53368: LD_EXP 99
53372: PUSH
53373: FOR_TO
53374: IFFALSE 53978
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53376: LD_EXP 134
53380: PUSH
53381: LD_VAR 0 2
53385: ARRAY
53386: NOT
53387: PUSH
53388: LD_INT 38
53390: PPUSH
53391: LD_EXP 125
53395: PUSH
53396: LD_VAR 0 2
53400: ARRAY
53401: PPUSH
53402: CALL_OW 321
53406: PUSH
53407: LD_INT 2
53409: NONEQUAL
53410: OR
53411: IFFALSE 53415
// continue ;
53413: GO 53373
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53415: LD_ADDR_VAR 0 8
53419: PUSH
53420: LD_EXP 99
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: PPUSH
53431: LD_INT 30
53433: PUSH
53434: LD_INT 34
53436: PUSH
53437: EMPTY
53438: LIST
53439: LIST
53440: PPUSH
53441: CALL_OW 72
53445: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53446: LD_ADDR_VAR 0 9
53450: PUSH
53451: LD_EXP 99
53455: PUSH
53456: LD_VAR 0 2
53460: ARRAY
53461: PPUSH
53462: LD_INT 25
53464: PUSH
53465: LD_INT 4
53467: PUSH
53468: EMPTY
53469: LIST
53470: LIST
53471: PPUSH
53472: CALL_OW 72
53476: PPUSH
53477: LD_INT 0
53479: PPUSH
53480: CALL 102891 0 2
53484: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53485: LD_VAR 0 9
53489: NOT
53490: PUSH
53491: LD_VAR 0 8
53495: NOT
53496: OR
53497: PUSH
53498: LD_EXP 99
53502: PUSH
53503: LD_VAR 0 2
53507: ARRAY
53508: PPUSH
53509: LD_INT 124
53511: PPUSH
53512: CALL 102891 0 2
53516: OR
53517: IFFALSE 53521
// continue ;
53519: GO 53373
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53521: LD_EXP 135
53525: PUSH
53526: LD_VAR 0 2
53530: ARRAY
53531: PUSH
53532: LD_EXP 134
53536: PUSH
53537: LD_VAR 0 2
53541: ARRAY
53542: LESS
53543: PUSH
53544: LD_EXP 135
53548: PUSH
53549: LD_VAR 0 2
53553: ARRAY
53554: PUSH
53555: LD_VAR 0 8
53559: LESS
53560: AND
53561: IFFALSE 53976
// begin tmp := sci [ 1 ] ;
53563: LD_ADDR_VAR 0 7
53567: PUSH
53568: LD_VAR 0 9
53572: PUSH
53573: LD_INT 1
53575: ARRAY
53576: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53577: LD_VAR 0 7
53581: PPUSH
53582: LD_INT 124
53584: PPUSH
53585: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53589: LD_ADDR_VAR 0 3
53593: PUSH
53594: DOUBLE
53595: LD_EXP 134
53599: PUSH
53600: LD_VAR 0 2
53604: ARRAY
53605: INC
53606: ST_TO_ADDR
53607: LD_EXP 134
53611: PUSH
53612: LD_VAR 0 2
53616: ARRAY
53617: PUSH
53618: FOR_DOWNTO
53619: IFFALSE 53962
// begin if IsInUnit ( tmp ) then
53621: LD_VAR 0 7
53625: PPUSH
53626: CALL_OW 310
53630: IFFALSE 53641
// ComExitBuilding ( tmp ) ;
53632: LD_VAR 0 7
53636: PPUSH
53637: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
53641: LD_INT 35
53643: PPUSH
53644: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
53648: LD_VAR 0 7
53652: PPUSH
53653: CALL_OW 310
53657: NOT
53658: PUSH
53659: LD_VAR 0 7
53663: PPUSH
53664: CALL_OW 314
53668: NOT
53669: AND
53670: IFFALSE 53641
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
53672: LD_ADDR_VAR 0 6
53676: PUSH
53677: LD_VAR 0 7
53681: PPUSH
53682: CALL_OW 250
53686: PUSH
53687: LD_VAR 0 7
53691: PPUSH
53692: CALL_OW 251
53696: PUSH
53697: EMPTY
53698: LIST
53699: LIST
53700: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53701: LD_INT 35
53703: PPUSH
53704: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
53708: LD_ADDR_VAR 0 4
53712: PUSH
53713: LD_EXP 134
53717: PUSH
53718: LD_VAR 0 2
53722: ARRAY
53723: PUSH
53724: LD_VAR 0 3
53728: ARRAY
53729: PUSH
53730: LD_INT 1
53732: ARRAY
53733: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
53734: LD_ADDR_VAR 0 5
53738: PUSH
53739: LD_EXP 134
53743: PUSH
53744: LD_VAR 0 2
53748: ARRAY
53749: PUSH
53750: LD_VAR 0 3
53754: ARRAY
53755: PUSH
53756: LD_INT 2
53758: ARRAY
53759: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
53760: LD_VAR 0 7
53764: PPUSH
53765: LD_INT 10
53767: PPUSH
53768: CALL 72248 0 2
53772: PUSH
53773: LD_INT 4
53775: ARRAY
53776: IFFALSE 53814
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
53778: LD_VAR 0 7
53782: PPUSH
53783: LD_VAR 0 6
53787: PUSH
53788: LD_INT 1
53790: ARRAY
53791: PPUSH
53792: LD_VAR 0 6
53796: PUSH
53797: LD_INT 2
53799: ARRAY
53800: PPUSH
53801: CALL_OW 111
// wait ( 0 0$10 ) ;
53805: LD_INT 350
53807: PPUSH
53808: CALL_OW 67
// end else
53812: GO 53840
// begin ComMoveXY ( tmp , x , y ) ;
53814: LD_VAR 0 7
53818: PPUSH
53819: LD_VAR 0 4
53823: PPUSH
53824: LD_VAR 0 5
53828: PPUSH
53829: CALL_OW 111
// wait ( 0 0$3 ) ;
53833: LD_INT 105
53835: PPUSH
53836: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
53840: LD_VAR 0 7
53844: PPUSH
53845: LD_VAR 0 4
53849: PPUSH
53850: LD_VAR 0 5
53854: PPUSH
53855: CALL_OW 307
53859: IFFALSE 53701
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
53861: LD_VAR 0 7
53865: PPUSH
53866: LD_VAR 0 4
53870: PPUSH
53871: LD_VAR 0 5
53875: PPUSH
53876: LD_VAR 0 8
53880: PUSH
53881: LD_VAR 0 3
53885: ARRAY
53886: PPUSH
53887: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
53891: LD_INT 35
53893: PPUSH
53894: CALL_OW 67
// until not HasTask ( tmp ) ;
53898: LD_VAR 0 7
53902: PPUSH
53903: CALL_OW 314
53907: NOT
53908: IFFALSE 53891
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
53910: LD_ADDR_EXP 135
53914: PUSH
53915: LD_EXP 135
53919: PPUSH
53920: LD_VAR 0 2
53924: PUSH
53925: LD_EXP 135
53929: PUSH
53930: LD_VAR 0 2
53934: ARRAY
53935: PUSH
53936: LD_INT 1
53938: PLUS
53939: PUSH
53940: EMPTY
53941: LIST
53942: LIST
53943: PPUSH
53944: LD_VAR 0 8
53948: PUSH
53949: LD_VAR 0 3
53953: ARRAY
53954: PPUSH
53955: CALL 69655 0 3
53959: ST_TO_ADDR
// end ;
53960: GO 53618
53962: POP
53963: POP
// MC_Reset ( i , 124 ) ;
53964: LD_VAR 0 2
53968: PPUSH
53969: LD_INT 124
53971: PPUSH
53972: CALL 37767 0 2
// end ; end ;
53976: GO 53373
53978: POP
53979: POP
// end ;
53980: LD_VAR 0 1
53984: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53985: LD_INT 0
53987: PPUSH
53988: PPUSH
53989: PPUSH
// if not mc_bases then
53990: LD_EXP 99
53994: NOT
53995: IFFALSE 53999
// exit ;
53997: GO 54605
// for i = 1 to mc_bases do
53999: LD_ADDR_VAR 0 2
54003: PUSH
54004: DOUBLE
54005: LD_INT 1
54007: DEC
54008: ST_TO_ADDR
54009: LD_EXP 99
54013: PUSH
54014: FOR_TO
54015: IFFALSE 54603
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54017: LD_ADDR_VAR 0 3
54021: PUSH
54022: LD_EXP 99
54026: PUSH
54027: LD_VAR 0 2
54031: ARRAY
54032: PPUSH
54033: LD_INT 25
54035: PUSH
54036: LD_INT 4
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PPUSH
54043: CALL_OW 72
54047: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54048: LD_VAR 0 3
54052: NOT
54053: PUSH
54054: LD_EXP 136
54058: PUSH
54059: LD_VAR 0 2
54063: ARRAY
54064: NOT
54065: OR
54066: PUSH
54067: LD_EXP 99
54071: PUSH
54072: LD_VAR 0 2
54076: ARRAY
54077: PPUSH
54078: LD_INT 2
54080: PUSH
54081: LD_INT 30
54083: PUSH
54084: LD_INT 0
54086: PUSH
54087: EMPTY
54088: LIST
54089: LIST
54090: PUSH
54091: LD_INT 30
54093: PUSH
54094: LD_INT 1
54096: PUSH
54097: EMPTY
54098: LIST
54099: LIST
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: LIST
54105: PPUSH
54106: CALL_OW 72
54110: NOT
54111: OR
54112: IFFALSE 54162
// begin if mc_deposits_finder [ i ] then
54114: LD_EXP 137
54118: PUSH
54119: LD_VAR 0 2
54123: ARRAY
54124: IFFALSE 54160
// begin MC_Reset ( i , 125 ) ;
54126: LD_VAR 0 2
54130: PPUSH
54131: LD_INT 125
54133: PPUSH
54134: CALL 37767 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54138: LD_ADDR_EXP 137
54142: PUSH
54143: LD_EXP 137
54147: PPUSH
54148: LD_VAR 0 2
54152: PPUSH
54153: EMPTY
54154: PPUSH
54155: CALL_OW 1
54159: ST_TO_ADDR
// end ; continue ;
54160: GO 54014
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54162: LD_EXP 136
54166: PUSH
54167: LD_VAR 0 2
54171: ARRAY
54172: PUSH
54173: LD_INT 1
54175: ARRAY
54176: PUSH
54177: LD_INT 3
54179: ARRAY
54180: PUSH
54181: LD_INT 1
54183: EQUAL
54184: PUSH
54185: LD_INT 20
54187: PPUSH
54188: LD_EXP 125
54192: PUSH
54193: LD_VAR 0 2
54197: ARRAY
54198: PPUSH
54199: CALL_OW 321
54203: PUSH
54204: LD_INT 2
54206: NONEQUAL
54207: AND
54208: IFFALSE 54258
// begin if mc_deposits_finder [ i ] then
54210: LD_EXP 137
54214: PUSH
54215: LD_VAR 0 2
54219: ARRAY
54220: IFFALSE 54256
// begin MC_Reset ( i , 125 ) ;
54222: LD_VAR 0 2
54226: PPUSH
54227: LD_INT 125
54229: PPUSH
54230: CALL 37767 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54234: LD_ADDR_EXP 137
54238: PUSH
54239: LD_EXP 137
54243: PPUSH
54244: LD_VAR 0 2
54248: PPUSH
54249: EMPTY
54250: PPUSH
54251: CALL_OW 1
54255: ST_TO_ADDR
// end ; continue ;
54256: GO 54014
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54258: LD_EXP 136
54262: PUSH
54263: LD_VAR 0 2
54267: ARRAY
54268: PUSH
54269: LD_INT 1
54271: ARRAY
54272: PUSH
54273: LD_INT 1
54275: ARRAY
54276: PPUSH
54277: LD_EXP 136
54281: PUSH
54282: LD_VAR 0 2
54286: ARRAY
54287: PUSH
54288: LD_INT 1
54290: ARRAY
54291: PUSH
54292: LD_INT 2
54294: ARRAY
54295: PPUSH
54296: LD_EXP 125
54300: PUSH
54301: LD_VAR 0 2
54305: ARRAY
54306: PPUSH
54307: CALL_OW 440
54311: IFFALSE 54354
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54313: LD_ADDR_EXP 136
54317: PUSH
54318: LD_EXP 136
54322: PPUSH
54323: LD_VAR 0 2
54327: PPUSH
54328: LD_EXP 136
54332: PUSH
54333: LD_VAR 0 2
54337: ARRAY
54338: PPUSH
54339: LD_INT 1
54341: PPUSH
54342: CALL_OW 3
54346: PPUSH
54347: CALL_OW 1
54351: ST_TO_ADDR
54352: GO 54601
// begin if not mc_deposits_finder [ i ] then
54354: LD_EXP 137
54358: PUSH
54359: LD_VAR 0 2
54363: ARRAY
54364: NOT
54365: IFFALSE 54417
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54367: LD_ADDR_EXP 137
54371: PUSH
54372: LD_EXP 137
54376: PPUSH
54377: LD_VAR 0 2
54381: PPUSH
54382: LD_VAR 0 3
54386: PUSH
54387: LD_INT 1
54389: ARRAY
54390: PUSH
54391: EMPTY
54392: LIST
54393: PPUSH
54394: CALL_OW 1
54398: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54399: LD_VAR 0 3
54403: PUSH
54404: LD_INT 1
54406: ARRAY
54407: PPUSH
54408: LD_INT 125
54410: PPUSH
54411: CALL_OW 109
// end else
54415: GO 54601
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54417: LD_EXP 137
54421: PUSH
54422: LD_VAR 0 2
54426: ARRAY
54427: PUSH
54428: LD_INT 1
54430: ARRAY
54431: PPUSH
54432: CALL_OW 310
54436: IFFALSE 54459
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54438: LD_EXP 137
54442: PUSH
54443: LD_VAR 0 2
54447: ARRAY
54448: PUSH
54449: LD_INT 1
54451: ARRAY
54452: PPUSH
54453: CALL_OW 122
54457: GO 54601
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54459: LD_EXP 137
54463: PUSH
54464: LD_VAR 0 2
54468: ARRAY
54469: PUSH
54470: LD_INT 1
54472: ARRAY
54473: PPUSH
54474: CALL_OW 314
54478: NOT
54479: PUSH
54480: LD_EXP 137
54484: PUSH
54485: LD_VAR 0 2
54489: ARRAY
54490: PUSH
54491: LD_INT 1
54493: ARRAY
54494: PPUSH
54495: LD_EXP 136
54499: PUSH
54500: LD_VAR 0 2
54504: ARRAY
54505: PUSH
54506: LD_INT 1
54508: ARRAY
54509: PUSH
54510: LD_INT 1
54512: ARRAY
54513: PPUSH
54514: LD_EXP 136
54518: PUSH
54519: LD_VAR 0 2
54523: ARRAY
54524: PUSH
54525: LD_INT 1
54527: ARRAY
54528: PUSH
54529: LD_INT 2
54531: ARRAY
54532: PPUSH
54533: CALL_OW 297
54537: PUSH
54538: LD_INT 6
54540: GREATER
54541: AND
54542: IFFALSE 54601
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54544: LD_EXP 137
54548: PUSH
54549: LD_VAR 0 2
54553: ARRAY
54554: PUSH
54555: LD_INT 1
54557: ARRAY
54558: PPUSH
54559: LD_EXP 136
54563: PUSH
54564: LD_VAR 0 2
54568: ARRAY
54569: PUSH
54570: LD_INT 1
54572: ARRAY
54573: PUSH
54574: LD_INT 1
54576: ARRAY
54577: PPUSH
54578: LD_EXP 136
54582: PUSH
54583: LD_VAR 0 2
54587: ARRAY
54588: PUSH
54589: LD_INT 1
54591: ARRAY
54592: PUSH
54593: LD_INT 2
54595: ARRAY
54596: PPUSH
54597: CALL_OW 111
// end ; end ; end ;
54601: GO 54014
54603: POP
54604: POP
// end ;
54605: LD_VAR 0 1
54609: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
54610: LD_INT 0
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
// if not mc_bases then
54623: LD_EXP 99
54627: NOT
54628: IFFALSE 54632
// exit ;
54630: GO 55356
// for i = 1 to mc_bases do
54632: LD_ADDR_VAR 0 2
54636: PUSH
54637: DOUBLE
54638: LD_INT 1
54640: DEC
54641: ST_TO_ADDR
54642: LD_EXP 99
54646: PUSH
54647: FOR_TO
54648: IFFALSE 55354
// begin if not mc_bases [ i ] then
54650: LD_EXP 99
54654: PUSH
54655: LD_VAR 0 2
54659: ARRAY
54660: NOT
54661: IFFALSE 54665
// continue ;
54663: GO 54647
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
54665: LD_ADDR_VAR 0 7
54669: PUSH
54670: LD_EXP 99
54674: PUSH
54675: LD_VAR 0 2
54679: ARRAY
54680: PUSH
54681: LD_INT 1
54683: ARRAY
54684: PPUSH
54685: CALL_OW 248
54689: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
54690: LD_VAR 0 7
54694: PUSH
54695: LD_INT 3
54697: EQUAL
54698: PUSH
54699: LD_EXP 118
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: PUSH
54710: LD_EXP 121
54714: PUSH
54715: LD_VAR 0 2
54719: ARRAY
54720: UNION
54721: PPUSH
54722: LD_INT 33
54724: PUSH
54725: LD_INT 2
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: PPUSH
54732: CALL_OW 72
54736: NOT
54737: OR
54738: IFFALSE 54742
// continue ;
54740: GO 54647
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
54742: LD_ADDR_VAR 0 9
54746: PUSH
54747: LD_EXP 99
54751: PUSH
54752: LD_VAR 0 2
54756: ARRAY
54757: PPUSH
54758: LD_INT 30
54760: PUSH
54761: LD_INT 36
54763: PUSH
54764: EMPTY
54765: LIST
54766: LIST
54767: PPUSH
54768: CALL_OW 72
54772: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
54773: LD_ADDR_VAR 0 10
54777: PUSH
54778: LD_EXP 118
54782: PUSH
54783: LD_VAR 0 2
54787: ARRAY
54788: PPUSH
54789: LD_INT 34
54791: PUSH
54792: LD_INT 31
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: PPUSH
54799: CALL_OW 72
54803: ST_TO_ADDR
// if not cts and not mcts then
54804: LD_VAR 0 9
54808: NOT
54809: PUSH
54810: LD_VAR 0 10
54814: NOT
54815: AND
54816: IFFALSE 54820
// continue ;
54818: GO 54647
// x := cts ;
54820: LD_ADDR_VAR 0 11
54824: PUSH
54825: LD_VAR 0 9
54829: ST_TO_ADDR
// if not x then
54830: LD_VAR 0 11
54834: NOT
54835: IFFALSE 54847
// x := mcts ;
54837: LD_ADDR_VAR 0 11
54841: PUSH
54842: LD_VAR 0 10
54846: ST_TO_ADDR
// if mc_remote_driver [ i ] then
54847: LD_EXP 139
54851: PUSH
54852: LD_VAR 0 2
54856: ARRAY
54857: IFFALSE 55126
// for j in mc_remote_driver [ i ] do
54859: LD_ADDR_VAR 0 3
54863: PUSH
54864: LD_EXP 139
54868: PUSH
54869: LD_VAR 0 2
54873: ARRAY
54874: PUSH
54875: FOR_IN
54876: IFFALSE 55124
// begin if GetClass ( j ) <> 3 then
54878: LD_VAR 0 3
54882: PPUSH
54883: CALL_OW 257
54887: PUSH
54888: LD_INT 3
54890: NONEQUAL
54891: IFFALSE 54944
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
54893: LD_ADDR_EXP 139
54897: PUSH
54898: LD_EXP 139
54902: PPUSH
54903: LD_VAR 0 2
54907: PPUSH
54908: LD_EXP 139
54912: PUSH
54913: LD_VAR 0 2
54917: ARRAY
54918: PUSH
54919: LD_VAR 0 3
54923: DIFF
54924: PPUSH
54925: CALL_OW 1
54929: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54930: LD_VAR 0 3
54934: PPUSH
54935: LD_INT 0
54937: PPUSH
54938: CALL_OW 109
// continue ;
54942: GO 54875
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
54944: LD_VAR 0 3
54948: PPUSH
54949: CALL_OW 310
54953: NOT
54954: PUSH
54955: LD_VAR 0 3
54959: PPUSH
54960: CALL_OW 310
54964: PPUSH
54965: CALL_OW 266
54969: PUSH
54970: LD_INT 36
54972: NONEQUAL
54973: PUSH
54974: LD_VAR 0 3
54978: PPUSH
54979: CALL 102979 0 1
54983: NOT
54984: AND
54985: OR
54986: IFFALSE 55122
// begin if IsInUnit ( j ) then
54988: LD_VAR 0 3
54992: PPUSH
54993: CALL_OW 310
54997: IFFALSE 55008
// ComExitBuilding ( j ) ;
54999: LD_VAR 0 3
55003: PPUSH
55004: CALL_OW 122
// ct := 0 ;
55008: LD_ADDR_VAR 0 8
55012: PUSH
55013: LD_INT 0
55015: ST_TO_ADDR
// for k in x do
55016: LD_ADDR_VAR 0 4
55020: PUSH
55021: LD_VAR 0 11
55025: PUSH
55026: FOR_IN
55027: IFFALSE 55100
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55029: LD_VAR 0 4
55033: PPUSH
55034: CALL_OW 264
55038: PUSH
55039: LD_INT 31
55041: EQUAL
55042: PUSH
55043: LD_VAR 0 4
55047: PPUSH
55048: CALL_OW 311
55052: NOT
55053: AND
55054: PUSH
55055: LD_VAR 0 4
55059: PPUSH
55060: CALL_OW 266
55064: PUSH
55065: LD_INT 36
55067: EQUAL
55068: PUSH
55069: LD_VAR 0 4
55073: PPUSH
55074: CALL_OW 313
55078: PUSH
55079: LD_INT 3
55081: LESS
55082: AND
55083: OR
55084: IFFALSE 55098
// begin ct := k ;
55086: LD_ADDR_VAR 0 8
55090: PUSH
55091: LD_VAR 0 4
55095: ST_TO_ADDR
// break ;
55096: GO 55100
// end ;
55098: GO 55026
55100: POP
55101: POP
// if ct then
55102: LD_VAR 0 8
55106: IFFALSE 55122
// ComEnterUnit ( j , ct ) ;
55108: LD_VAR 0 3
55112: PPUSH
55113: LD_VAR 0 8
55117: PPUSH
55118: CALL_OW 120
// end ; end ;
55122: GO 54875
55124: POP
55125: POP
// places := 0 ;
55126: LD_ADDR_VAR 0 5
55130: PUSH
55131: LD_INT 0
55133: ST_TO_ADDR
// for j = 1 to x do
55134: LD_ADDR_VAR 0 3
55138: PUSH
55139: DOUBLE
55140: LD_INT 1
55142: DEC
55143: ST_TO_ADDR
55144: LD_VAR 0 11
55148: PUSH
55149: FOR_TO
55150: IFFALSE 55205
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55152: LD_VAR 0 11
55156: PUSH
55157: LD_VAR 0 3
55161: ARRAY
55162: PPUSH
55163: CALL_OW 264
55167: PUSH
55168: LD_INT 31
55170: EQUAL
55171: IFFALSE 55189
// places := places + 1 else
55173: LD_ADDR_VAR 0 5
55177: PUSH
55178: LD_VAR 0 5
55182: PUSH
55183: LD_INT 1
55185: PLUS
55186: ST_TO_ADDR
55187: GO 55203
// places := places + 3 ;
55189: LD_ADDR_VAR 0 5
55193: PUSH
55194: LD_VAR 0 5
55198: PUSH
55199: LD_INT 3
55201: PLUS
55202: ST_TO_ADDR
55203: GO 55149
55205: POP
55206: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55207: LD_ADDR_VAR 0 6
55211: PUSH
55212: LD_EXP 99
55216: PUSH
55217: LD_VAR 0 2
55221: ARRAY
55222: PPUSH
55223: LD_INT 25
55225: PUSH
55226: LD_INT 3
55228: PUSH
55229: EMPTY
55230: LIST
55231: LIST
55232: PPUSH
55233: CALL_OW 72
55237: PUSH
55238: LD_EXP 139
55242: PUSH
55243: LD_VAR 0 2
55247: ARRAY
55248: DIFF
55249: PPUSH
55250: LD_INT 3
55252: PPUSH
55253: CALL 103879 0 2
55257: ST_TO_ADDR
// if not tmp then
55258: LD_VAR 0 6
55262: NOT
55263: IFFALSE 55267
// continue ;
55265: GO 54647
// places := places - mc_remote_driver [ i ] ;
55267: LD_ADDR_VAR 0 5
55271: PUSH
55272: LD_VAR 0 5
55276: PUSH
55277: LD_EXP 139
55281: PUSH
55282: LD_VAR 0 2
55286: ARRAY
55287: MINUS
55288: ST_TO_ADDR
// if places then
55289: LD_VAR 0 5
55293: IFFALSE 55352
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55295: LD_ADDR_EXP 139
55299: PUSH
55300: LD_EXP 139
55304: PPUSH
55305: LD_VAR 0 2
55309: PPUSH
55310: LD_EXP 139
55314: PUSH
55315: LD_VAR 0 2
55319: ARRAY
55320: PUSH
55321: LD_VAR 0 6
55325: PUSH
55326: LD_INT 1
55328: ARRAY
55329: UNION
55330: PPUSH
55331: CALL_OW 1
55335: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55336: LD_VAR 0 6
55340: PUSH
55341: LD_INT 1
55343: ARRAY
55344: PPUSH
55345: LD_INT 126
55347: PPUSH
55348: CALL_OW 109
// end ; end ;
55352: GO 54647
55354: POP
55355: POP
// end ;
55356: LD_VAR 0 1
55360: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55361: LD_INT 0
55363: PPUSH
55364: PPUSH
55365: PPUSH
55366: PPUSH
55367: PPUSH
55368: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55369: LD_VAR 0 1
55373: NOT
55374: PUSH
55375: LD_VAR 0 2
55379: NOT
55380: OR
55381: PUSH
55382: LD_VAR 0 3
55386: NOT
55387: OR
55388: PUSH
55389: LD_VAR 0 4
55393: PUSH
55394: LD_INT 1
55396: PUSH
55397: LD_INT 2
55399: PUSH
55400: LD_INT 3
55402: PUSH
55403: LD_INT 4
55405: PUSH
55406: LD_INT 5
55408: PUSH
55409: LD_INT 8
55411: PUSH
55412: LD_INT 9
55414: PUSH
55415: LD_INT 15
55417: PUSH
55418: LD_INT 16
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: LIST
55425: LIST
55426: LIST
55427: LIST
55428: LIST
55429: LIST
55430: LIST
55431: IN
55432: NOT
55433: OR
55434: IFFALSE 55438
// exit ;
55436: GO 56338
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55438: LD_ADDR_VAR 0 2
55442: PUSH
55443: LD_VAR 0 2
55447: PPUSH
55448: LD_INT 21
55450: PUSH
55451: LD_INT 3
55453: PUSH
55454: EMPTY
55455: LIST
55456: LIST
55457: PUSH
55458: LD_INT 24
55460: PUSH
55461: LD_INT 250
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: PUSH
55468: EMPTY
55469: LIST
55470: LIST
55471: PPUSH
55472: CALL_OW 72
55476: ST_TO_ADDR
// case class of 1 , 15 :
55477: LD_VAR 0 4
55481: PUSH
55482: LD_INT 1
55484: DOUBLE
55485: EQUAL
55486: IFTRUE 55496
55488: LD_INT 15
55490: DOUBLE
55491: EQUAL
55492: IFTRUE 55496
55494: GO 55581
55496: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55497: LD_ADDR_VAR 0 8
55501: PUSH
55502: LD_VAR 0 2
55506: PPUSH
55507: LD_INT 2
55509: PUSH
55510: LD_INT 30
55512: PUSH
55513: LD_INT 32
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: PUSH
55520: LD_INT 30
55522: PUSH
55523: LD_INT 31
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: PUSH
55530: EMPTY
55531: LIST
55532: LIST
55533: LIST
55534: PPUSH
55535: CALL_OW 72
55539: PUSH
55540: LD_VAR 0 2
55544: PPUSH
55545: LD_INT 2
55547: PUSH
55548: LD_INT 30
55550: PUSH
55551: LD_INT 4
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: PUSH
55558: LD_INT 30
55560: PUSH
55561: LD_INT 5
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PUSH
55568: EMPTY
55569: LIST
55570: LIST
55571: LIST
55572: PPUSH
55573: CALL_OW 72
55577: ADD
55578: ST_TO_ADDR
55579: GO 55827
55581: LD_INT 2
55583: DOUBLE
55584: EQUAL
55585: IFTRUE 55595
55587: LD_INT 16
55589: DOUBLE
55590: EQUAL
55591: IFTRUE 55595
55593: GO 55641
55595: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55596: LD_ADDR_VAR 0 8
55600: PUSH
55601: LD_VAR 0 2
55605: PPUSH
55606: LD_INT 2
55608: PUSH
55609: LD_INT 30
55611: PUSH
55612: LD_INT 0
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 30
55621: PUSH
55622: LD_INT 1
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PPUSH
55634: CALL_OW 72
55638: ST_TO_ADDR
55639: GO 55827
55641: LD_INT 3
55643: DOUBLE
55644: EQUAL
55645: IFTRUE 55649
55647: GO 55695
55649: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
55650: LD_ADDR_VAR 0 8
55654: PUSH
55655: LD_VAR 0 2
55659: PPUSH
55660: LD_INT 2
55662: PUSH
55663: LD_INT 30
55665: PUSH
55666: LD_INT 2
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: PUSH
55673: LD_INT 30
55675: PUSH
55676: LD_INT 3
55678: PUSH
55679: EMPTY
55680: LIST
55681: LIST
55682: PUSH
55683: EMPTY
55684: LIST
55685: LIST
55686: LIST
55687: PPUSH
55688: CALL_OW 72
55692: ST_TO_ADDR
55693: GO 55827
55695: LD_INT 4
55697: DOUBLE
55698: EQUAL
55699: IFTRUE 55703
55701: GO 55760
55703: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
55704: LD_ADDR_VAR 0 8
55708: PUSH
55709: LD_VAR 0 2
55713: PPUSH
55714: LD_INT 2
55716: PUSH
55717: LD_INT 30
55719: PUSH
55720: LD_INT 6
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: PUSH
55727: LD_INT 30
55729: PUSH
55730: LD_INT 7
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: PUSH
55737: LD_INT 30
55739: PUSH
55740: LD_INT 8
55742: PUSH
55743: EMPTY
55744: LIST
55745: LIST
55746: PUSH
55747: EMPTY
55748: LIST
55749: LIST
55750: LIST
55751: LIST
55752: PPUSH
55753: CALL_OW 72
55757: ST_TO_ADDR
55758: GO 55827
55760: LD_INT 5
55762: DOUBLE
55763: EQUAL
55764: IFTRUE 55780
55766: LD_INT 8
55768: DOUBLE
55769: EQUAL
55770: IFTRUE 55780
55772: LD_INT 9
55774: DOUBLE
55775: EQUAL
55776: IFTRUE 55780
55778: GO 55826
55780: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
55781: LD_ADDR_VAR 0 8
55785: PUSH
55786: LD_VAR 0 2
55790: PPUSH
55791: LD_INT 2
55793: PUSH
55794: LD_INT 30
55796: PUSH
55797: LD_INT 4
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PUSH
55804: LD_INT 30
55806: PUSH
55807: LD_INT 5
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: LIST
55818: PPUSH
55819: CALL_OW 72
55823: ST_TO_ADDR
55824: GO 55827
55826: POP
// if not tmp then
55827: LD_VAR 0 8
55831: NOT
55832: IFFALSE 55836
// exit ;
55834: GO 56338
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
55836: LD_VAR 0 4
55840: PUSH
55841: LD_INT 1
55843: PUSH
55844: LD_INT 15
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: IN
55851: PUSH
55852: LD_EXP 108
55856: PUSH
55857: LD_VAR 0 1
55861: ARRAY
55862: AND
55863: IFFALSE 56019
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
55865: LD_ADDR_VAR 0 9
55869: PUSH
55870: LD_EXP 108
55874: PUSH
55875: LD_VAR 0 1
55879: ARRAY
55880: PUSH
55881: LD_INT 1
55883: ARRAY
55884: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
55885: LD_VAR 0 9
55889: PUSH
55890: LD_EXP 109
55894: PUSH
55895: LD_VAR 0 1
55899: ARRAY
55900: IN
55901: NOT
55902: IFFALSE 56017
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
55904: LD_ADDR_EXP 109
55908: PUSH
55909: LD_EXP 109
55913: PPUSH
55914: LD_VAR 0 1
55918: PUSH
55919: LD_EXP 109
55923: PUSH
55924: LD_VAR 0 1
55928: ARRAY
55929: PUSH
55930: LD_INT 1
55932: PLUS
55933: PUSH
55934: EMPTY
55935: LIST
55936: LIST
55937: PPUSH
55938: LD_VAR 0 9
55942: PPUSH
55943: CALL 69655 0 3
55947: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
55948: LD_ADDR_EXP 108
55952: PUSH
55953: LD_EXP 108
55957: PPUSH
55958: LD_VAR 0 1
55962: PPUSH
55963: LD_EXP 108
55967: PUSH
55968: LD_VAR 0 1
55972: ARRAY
55973: PUSH
55974: LD_VAR 0 9
55978: DIFF
55979: PPUSH
55980: CALL_OW 1
55984: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55985: LD_VAR 0 3
55989: PPUSH
55990: LD_EXP 109
55994: PUSH
55995: LD_VAR 0 1
55999: ARRAY
56000: PUSH
56001: LD_EXP 109
56005: PUSH
56006: LD_VAR 0 1
56010: ARRAY
56011: ARRAY
56012: PPUSH
56013: CALL_OW 120
// end ; exit ;
56017: GO 56338
// end ; if tmp > 1 then
56019: LD_VAR 0 8
56023: PUSH
56024: LD_INT 1
56026: GREATER
56027: IFFALSE 56131
// for i = 2 to tmp do
56029: LD_ADDR_VAR 0 6
56033: PUSH
56034: DOUBLE
56035: LD_INT 2
56037: DEC
56038: ST_TO_ADDR
56039: LD_VAR 0 8
56043: PUSH
56044: FOR_TO
56045: IFFALSE 56129
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56047: LD_VAR 0 8
56051: PUSH
56052: LD_VAR 0 6
56056: ARRAY
56057: PPUSH
56058: CALL_OW 461
56062: PUSH
56063: LD_INT 6
56065: EQUAL
56066: IFFALSE 56127
// begin x := tmp [ i ] ;
56068: LD_ADDR_VAR 0 9
56072: PUSH
56073: LD_VAR 0 8
56077: PUSH
56078: LD_VAR 0 6
56082: ARRAY
56083: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56084: LD_ADDR_VAR 0 8
56088: PUSH
56089: LD_VAR 0 8
56093: PPUSH
56094: LD_VAR 0 6
56098: PPUSH
56099: CALL_OW 3
56103: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56104: LD_ADDR_VAR 0 8
56108: PUSH
56109: LD_VAR 0 8
56113: PPUSH
56114: LD_INT 1
56116: PPUSH
56117: LD_VAR 0 9
56121: PPUSH
56122: CALL_OW 2
56126: ST_TO_ADDR
// end ;
56127: GO 56044
56129: POP
56130: POP
// for i in tmp do
56131: LD_ADDR_VAR 0 6
56135: PUSH
56136: LD_VAR 0 8
56140: PUSH
56141: FOR_IN
56142: IFFALSE 56211
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56144: LD_VAR 0 6
56148: PPUSH
56149: CALL_OW 313
56153: PUSH
56154: LD_INT 6
56156: LESS
56157: PUSH
56158: LD_VAR 0 6
56162: PPUSH
56163: CALL_OW 266
56167: PUSH
56168: LD_INT 31
56170: PUSH
56171: LD_INT 32
56173: PUSH
56174: EMPTY
56175: LIST
56176: LIST
56177: IN
56178: NOT
56179: AND
56180: PUSH
56181: LD_VAR 0 6
56185: PPUSH
56186: CALL_OW 313
56190: PUSH
56191: LD_INT 0
56193: EQUAL
56194: OR
56195: IFFALSE 56209
// begin j := i ;
56197: LD_ADDR_VAR 0 7
56201: PUSH
56202: LD_VAR 0 6
56206: ST_TO_ADDR
// break ;
56207: GO 56211
// end ; end ;
56209: GO 56141
56211: POP
56212: POP
// if j then
56213: LD_VAR 0 7
56217: IFFALSE 56235
// ComEnterUnit ( unit , j ) else
56219: LD_VAR 0 3
56223: PPUSH
56224: LD_VAR 0 7
56228: PPUSH
56229: CALL_OW 120
56233: GO 56338
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56235: LD_ADDR_VAR 0 10
56239: PUSH
56240: LD_VAR 0 2
56244: PPUSH
56245: LD_INT 2
56247: PUSH
56248: LD_INT 30
56250: PUSH
56251: LD_INT 0
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: PUSH
56258: LD_INT 30
56260: PUSH
56261: LD_INT 1
56263: PUSH
56264: EMPTY
56265: LIST
56266: LIST
56267: PUSH
56268: EMPTY
56269: LIST
56270: LIST
56271: LIST
56272: PPUSH
56273: CALL_OW 72
56277: ST_TO_ADDR
// if depot then
56278: LD_VAR 0 10
56282: IFFALSE 56338
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56284: LD_ADDR_VAR 0 10
56288: PUSH
56289: LD_VAR 0 10
56293: PPUSH
56294: LD_VAR 0 3
56298: PPUSH
56299: CALL_OW 74
56303: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56304: LD_VAR 0 3
56308: PPUSH
56309: LD_VAR 0 10
56313: PPUSH
56314: CALL_OW 296
56318: PUSH
56319: LD_INT 10
56321: GREATER
56322: IFFALSE 56338
// ComStandNearbyBuilding ( unit , depot ) ;
56324: LD_VAR 0 3
56328: PPUSH
56329: LD_VAR 0 10
56333: PPUSH
56334: CALL 64332 0 2
// end ; end ; end ;
56338: LD_VAR 0 5
56342: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56343: LD_INT 0
56345: PPUSH
56346: PPUSH
56347: PPUSH
56348: PPUSH
// if not mc_bases then
56349: LD_EXP 99
56353: NOT
56354: IFFALSE 56358
// exit ;
56356: GO 56597
// for i = 1 to mc_bases do
56358: LD_ADDR_VAR 0 2
56362: PUSH
56363: DOUBLE
56364: LD_INT 1
56366: DEC
56367: ST_TO_ADDR
56368: LD_EXP 99
56372: PUSH
56373: FOR_TO
56374: IFFALSE 56595
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56376: LD_ADDR_VAR 0 4
56380: PUSH
56381: LD_EXP 99
56385: PUSH
56386: LD_VAR 0 2
56390: ARRAY
56391: PPUSH
56392: LD_INT 21
56394: PUSH
56395: LD_INT 1
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PPUSH
56402: CALL_OW 72
56406: PUSH
56407: LD_EXP 128
56411: PUSH
56412: LD_VAR 0 2
56416: ARRAY
56417: UNION
56418: ST_TO_ADDR
// if not tmp then
56419: LD_VAR 0 4
56423: NOT
56424: IFFALSE 56428
// continue ;
56426: GO 56373
// for j in tmp do
56428: LD_ADDR_VAR 0 3
56432: PUSH
56433: LD_VAR 0 4
56437: PUSH
56438: FOR_IN
56439: IFFALSE 56591
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56441: LD_VAR 0 3
56445: PPUSH
56446: CALL_OW 110
56450: NOT
56451: PUSH
56452: LD_VAR 0 3
56456: PPUSH
56457: CALL_OW 314
56461: NOT
56462: AND
56463: PUSH
56464: LD_VAR 0 3
56468: PPUSH
56469: CALL_OW 311
56473: NOT
56474: AND
56475: PUSH
56476: LD_VAR 0 3
56480: PPUSH
56481: CALL_OW 310
56485: NOT
56486: AND
56487: PUSH
56488: LD_VAR 0 3
56492: PUSH
56493: LD_EXP 102
56497: PUSH
56498: LD_VAR 0 2
56502: ARRAY
56503: PUSH
56504: LD_INT 1
56506: ARRAY
56507: IN
56508: NOT
56509: AND
56510: PUSH
56511: LD_VAR 0 3
56515: PUSH
56516: LD_EXP 102
56520: PUSH
56521: LD_VAR 0 2
56525: ARRAY
56526: PUSH
56527: LD_INT 2
56529: ARRAY
56530: IN
56531: NOT
56532: AND
56533: PUSH
56534: LD_VAR 0 3
56538: PUSH
56539: LD_EXP 111
56543: PUSH
56544: LD_VAR 0 2
56548: ARRAY
56549: IN
56550: NOT
56551: AND
56552: IFFALSE 56589
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56554: LD_VAR 0 2
56558: PPUSH
56559: LD_EXP 99
56563: PUSH
56564: LD_VAR 0 2
56568: ARRAY
56569: PPUSH
56570: LD_VAR 0 3
56574: PPUSH
56575: LD_VAR 0 3
56579: PPUSH
56580: CALL_OW 257
56584: PPUSH
56585: CALL 55361 0 4
// end ;
56589: GO 56438
56591: POP
56592: POP
// end ;
56593: GO 56373
56595: POP
56596: POP
// end ;
56597: LD_VAR 0 1
56601: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
56602: LD_INT 0
56604: PPUSH
56605: PPUSH
56606: PPUSH
56607: PPUSH
56608: PPUSH
56609: PPUSH
// if not mc_bases [ base ] then
56610: LD_EXP 99
56614: PUSH
56615: LD_VAR 0 1
56619: ARRAY
56620: NOT
56621: IFFALSE 56625
// exit ;
56623: GO 56807
// tmp := [ ] ;
56625: LD_ADDR_VAR 0 6
56629: PUSH
56630: EMPTY
56631: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
56632: LD_ADDR_VAR 0 7
56636: PUSH
56637: LD_VAR 0 3
56641: PPUSH
56642: LD_INT 0
56644: PPUSH
56645: CALL_OW 517
56649: ST_TO_ADDR
// if not list then
56650: LD_VAR 0 7
56654: NOT
56655: IFFALSE 56659
// exit ;
56657: GO 56807
// for i = 1 to amount do
56659: LD_ADDR_VAR 0 5
56663: PUSH
56664: DOUBLE
56665: LD_INT 1
56667: DEC
56668: ST_TO_ADDR
56669: LD_VAR 0 2
56673: PUSH
56674: FOR_TO
56675: IFFALSE 56755
// begin x := rand ( 1 , list [ 1 ] ) ;
56677: LD_ADDR_VAR 0 8
56681: PUSH
56682: LD_INT 1
56684: PPUSH
56685: LD_VAR 0 7
56689: PUSH
56690: LD_INT 1
56692: ARRAY
56693: PPUSH
56694: CALL_OW 12
56698: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
56699: LD_ADDR_VAR 0 6
56703: PUSH
56704: LD_VAR 0 6
56708: PPUSH
56709: LD_VAR 0 5
56713: PPUSH
56714: LD_VAR 0 7
56718: PUSH
56719: LD_INT 1
56721: ARRAY
56722: PUSH
56723: LD_VAR 0 8
56727: ARRAY
56728: PUSH
56729: LD_VAR 0 7
56733: PUSH
56734: LD_INT 2
56736: ARRAY
56737: PUSH
56738: LD_VAR 0 8
56742: ARRAY
56743: PUSH
56744: EMPTY
56745: LIST
56746: LIST
56747: PPUSH
56748: CALL_OW 1
56752: ST_TO_ADDR
// end ;
56753: GO 56674
56755: POP
56756: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
56757: LD_ADDR_EXP 112
56761: PUSH
56762: LD_EXP 112
56766: PPUSH
56767: LD_VAR 0 1
56771: PPUSH
56772: LD_VAR 0 6
56776: PPUSH
56777: CALL_OW 1
56781: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
56782: LD_ADDR_EXP 114
56786: PUSH
56787: LD_EXP 114
56791: PPUSH
56792: LD_VAR 0 1
56796: PPUSH
56797: LD_VAR 0 3
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// end ;
56807: LD_VAR 0 4
56811: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
56812: LD_INT 0
56814: PPUSH
// if not mc_bases [ base ] then
56815: LD_EXP 99
56819: PUSH
56820: LD_VAR 0 1
56824: ARRAY
56825: NOT
56826: IFFALSE 56830
// exit ;
56828: GO 56855
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
56830: LD_ADDR_EXP 104
56834: PUSH
56835: LD_EXP 104
56839: PPUSH
56840: LD_VAR 0 1
56844: PPUSH
56845: LD_VAR 0 2
56849: PPUSH
56850: CALL_OW 1
56854: ST_TO_ADDR
// end ;
56855: LD_VAR 0 3
56859: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
56860: LD_INT 0
56862: PPUSH
// if not mc_bases [ base ] then
56863: LD_EXP 99
56867: PUSH
56868: LD_VAR 0 1
56872: ARRAY
56873: NOT
56874: IFFALSE 56878
// exit ;
56876: GO 56915
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
56878: LD_ADDR_EXP 104
56882: PUSH
56883: LD_EXP 104
56887: PPUSH
56888: LD_VAR 0 1
56892: PPUSH
56893: LD_EXP 104
56897: PUSH
56898: LD_VAR 0 1
56902: ARRAY
56903: PUSH
56904: LD_VAR 0 2
56908: UNION
56909: PPUSH
56910: CALL_OW 1
56914: ST_TO_ADDR
// end ;
56915: LD_VAR 0 3
56919: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
56920: LD_INT 0
56922: PPUSH
// if not mc_bases [ base ] then
56923: LD_EXP 99
56927: PUSH
56928: LD_VAR 0 1
56932: ARRAY
56933: NOT
56934: IFFALSE 56938
// exit ;
56936: GO 56963
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
56938: LD_ADDR_EXP 120
56942: PUSH
56943: LD_EXP 120
56947: PPUSH
56948: LD_VAR 0 1
56952: PPUSH
56953: LD_VAR 0 2
56957: PPUSH
56958: CALL_OW 1
56962: ST_TO_ADDR
// end ;
56963: LD_VAR 0 3
56967: RET
// export function MC_InsertProduceList ( base , components ) ; begin
56968: LD_INT 0
56970: PPUSH
// if not mc_bases [ base ] then
56971: LD_EXP 99
56975: PUSH
56976: LD_VAR 0 1
56980: ARRAY
56981: NOT
56982: IFFALSE 56986
// exit ;
56984: GO 57023
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56986: LD_ADDR_EXP 120
56990: PUSH
56991: LD_EXP 120
56995: PPUSH
56996: LD_VAR 0 1
57000: PPUSH
57001: LD_EXP 120
57005: PUSH
57006: LD_VAR 0 1
57010: ARRAY
57011: PUSH
57012: LD_VAR 0 2
57016: ADD
57017: PPUSH
57018: CALL_OW 1
57022: ST_TO_ADDR
// end ;
57023: LD_VAR 0 3
57027: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57028: LD_INT 0
57030: PPUSH
// if not mc_bases [ base ] then
57031: LD_EXP 99
57035: PUSH
57036: LD_VAR 0 1
57040: ARRAY
57041: NOT
57042: IFFALSE 57046
// exit ;
57044: GO 57100
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57046: LD_ADDR_EXP 121
57050: PUSH
57051: LD_EXP 121
57055: PPUSH
57056: LD_VAR 0 1
57060: PPUSH
57061: LD_VAR 0 2
57065: PPUSH
57066: CALL_OW 1
57070: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57071: LD_ADDR_EXP 110
57075: PUSH
57076: LD_EXP 110
57080: PPUSH
57081: LD_VAR 0 1
57085: PPUSH
57086: LD_VAR 0 2
57090: PUSH
57091: LD_INT 0
57093: PLUS
57094: PPUSH
57095: CALL_OW 1
57099: ST_TO_ADDR
// end ;
57100: LD_VAR 0 3
57104: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57105: LD_INT 0
57107: PPUSH
// if not mc_bases [ base ] then
57108: LD_EXP 99
57112: PUSH
57113: LD_VAR 0 1
57117: ARRAY
57118: NOT
57119: IFFALSE 57123
// exit ;
57121: GO 57148
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57123: LD_ADDR_EXP 110
57127: PUSH
57128: LD_EXP 110
57132: PPUSH
57133: LD_VAR 0 1
57137: PPUSH
57138: LD_VAR 0 2
57142: PPUSH
57143: CALL_OW 1
57147: ST_TO_ADDR
// end ;
57148: LD_VAR 0 3
57152: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57153: LD_INT 0
57155: PPUSH
57156: PPUSH
57157: PPUSH
57158: PPUSH
// if not mc_bases [ base ] then
57159: LD_EXP 99
57163: PUSH
57164: LD_VAR 0 1
57168: ARRAY
57169: NOT
57170: IFFALSE 57174
// exit ;
57172: GO 57239
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57174: LD_ADDR_EXP 119
57178: PUSH
57179: LD_EXP 119
57183: PPUSH
57184: LD_VAR 0 1
57188: PUSH
57189: LD_EXP 119
57193: PUSH
57194: LD_VAR 0 1
57198: ARRAY
57199: PUSH
57200: LD_INT 1
57202: PLUS
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PPUSH
57208: LD_VAR 0 1
57212: PUSH
57213: LD_VAR 0 2
57217: PUSH
57218: LD_VAR 0 3
57222: PUSH
57223: LD_VAR 0 4
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: PPUSH
57234: CALL 69655 0 3
57238: ST_TO_ADDR
// end ;
57239: LD_VAR 0 5
57243: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57244: LD_INT 0
57246: PPUSH
// if not mc_bases [ base ] then
57247: LD_EXP 99
57251: PUSH
57252: LD_VAR 0 1
57256: ARRAY
57257: NOT
57258: IFFALSE 57262
// exit ;
57260: GO 57287
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57262: LD_ADDR_EXP 136
57266: PUSH
57267: LD_EXP 136
57271: PPUSH
57272: LD_VAR 0 1
57276: PPUSH
57277: LD_VAR 0 2
57281: PPUSH
57282: CALL_OW 1
57286: ST_TO_ADDR
// end ;
57287: LD_VAR 0 3
57291: RET
// export function MC_GetMinesField ( base ) ; begin
57292: LD_INT 0
57294: PPUSH
// result := mc_mines [ base ] ;
57295: LD_ADDR_VAR 0 2
57299: PUSH
57300: LD_EXP 112
57304: PUSH
57305: LD_VAR 0 1
57309: ARRAY
57310: ST_TO_ADDR
// end ;
57311: LD_VAR 0 2
57315: RET
// export function MC_GetProduceList ( base ) ; begin
57316: LD_INT 0
57318: PPUSH
// result := mc_produce [ base ] ;
57319: LD_ADDR_VAR 0 2
57323: PUSH
57324: LD_EXP 120
57328: PUSH
57329: LD_VAR 0 1
57333: ARRAY
57334: ST_TO_ADDR
// end ;
57335: LD_VAR 0 2
57339: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57340: LD_INT 0
57342: PPUSH
57343: PPUSH
// if not mc_bases then
57344: LD_EXP 99
57348: NOT
57349: IFFALSE 57353
// exit ;
57351: GO 57418
// if mc_bases [ base ] then
57353: LD_EXP 99
57357: PUSH
57358: LD_VAR 0 1
57362: ARRAY
57363: IFFALSE 57418
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57365: LD_ADDR_VAR 0 3
57369: PUSH
57370: LD_EXP 99
57374: PUSH
57375: LD_VAR 0 1
57379: ARRAY
57380: PPUSH
57381: LD_INT 30
57383: PUSH
57384: LD_VAR 0 2
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PPUSH
57393: CALL_OW 72
57397: ST_TO_ADDR
// if result then
57398: LD_VAR 0 3
57402: IFFALSE 57418
// result := result [ 1 ] ;
57404: LD_ADDR_VAR 0 3
57408: PUSH
57409: LD_VAR 0 3
57413: PUSH
57414: LD_INT 1
57416: ARRAY
57417: ST_TO_ADDR
// end ; end ;
57418: LD_VAR 0 3
57422: RET
// export function MC_SetTame ( base , area ) ; begin
57423: LD_INT 0
57425: PPUSH
// if not mc_bases or not base then
57426: LD_EXP 99
57430: NOT
57431: PUSH
57432: LD_VAR 0 1
57436: NOT
57437: OR
57438: IFFALSE 57442
// exit ;
57440: GO 57467
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57442: LD_ADDR_EXP 127
57446: PUSH
57447: LD_EXP 127
57451: PPUSH
57452: LD_VAR 0 1
57456: PPUSH
57457: LD_VAR 0 2
57461: PPUSH
57462: CALL_OW 1
57466: ST_TO_ADDR
// end ;
57467: LD_VAR 0 3
57471: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57472: LD_INT 0
57474: PPUSH
57475: PPUSH
// if not mc_bases or not base then
57476: LD_EXP 99
57480: NOT
57481: PUSH
57482: LD_VAR 0 1
57486: NOT
57487: OR
57488: IFFALSE 57492
// exit ;
57490: GO 57594
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57492: LD_ADDR_VAR 0 4
57496: PUSH
57497: LD_EXP 99
57501: PUSH
57502: LD_VAR 0 1
57506: ARRAY
57507: PPUSH
57508: LD_INT 30
57510: PUSH
57511: LD_VAR 0 2
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: PPUSH
57520: CALL_OW 72
57524: ST_TO_ADDR
// if not tmp then
57525: LD_VAR 0 4
57529: NOT
57530: IFFALSE 57534
// exit ;
57532: GO 57594
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57534: LD_ADDR_EXP 131
57538: PUSH
57539: LD_EXP 131
57543: PPUSH
57544: LD_VAR 0 1
57548: PPUSH
57549: LD_EXP 131
57553: PUSH
57554: LD_VAR 0 1
57558: ARRAY
57559: PPUSH
57560: LD_EXP 131
57564: PUSH
57565: LD_VAR 0 1
57569: ARRAY
57570: PUSH
57571: LD_INT 1
57573: PLUS
57574: PPUSH
57575: LD_VAR 0 4
57579: PUSH
57580: LD_INT 1
57582: ARRAY
57583: PPUSH
57584: CALL_OW 2
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// end ;
57594: LD_VAR 0 3
57598: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
57599: LD_INT 0
57601: PPUSH
57602: PPUSH
// if not mc_bases or not base or not kinds then
57603: LD_EXP 99
57607: NOT
57608: PUSH
57609: LD_VAR 0 1
57613: NOT
57614: OR
57615: PUSH
57616: LD_VAR 0 2
57620: NOT
57621: OR
57622: IFFALSE 57626
// exit ;
57624: GO 57687
// for i in kinds do
57626: LD_ADDR_VAR 0 4
57630: PUSH
57631: LD_VAR 0 2
57635: PUSH
57636: FOR_IN
57637: IFFALSE 57685
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
57639: LD_ADDR_EXP 133
57643: PUSH
57644: LD_EXP 133
57648: PPUSH
57649: LD_VAR 0 1
57653: PUSH
57654: LD_EXP 133
57658: PUSH
57659: LD_VAR 0 1
57663: ARRAY
57664: PUSH
57665: LD_INT 1
57667: PLUS
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: PPUSH
57673: LD_VAR 0 4
57677: PPUSH
57678: CALL 69655 0 3
57682: ST_TO_ADDR
57683: GO 57636
57685: POP
57686: POP
// end ;
57687: LD_VAR 0 3
57691: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
57692: LD_INT 0
57694: PPUSH
// if not mc_bases or not base or not areas then
57695: LD_EXP 99
57699: NOT
57700: PUSH
57701: LD_VAR 0 1
57705: NOT
57706: OR
57707: PUSH
57708: LD_VAR 0 2
57712: NOT
57713: OR
57714: IFFALSE 57718
// exit ;
57716: GO 57743
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
57718: LD_ADDR_EXP 117
57722: PUSH
57723: LD_EXP 117
57727: PPUSH
57728: LD_VAR 0 1
57732: PPUSH
57733: LD_VAR 0 2
57737: PPUSH
57738: CALL_OW 1
57742: ST_TO_ADDR
// end ;
57743: LD_VAR 0 3
57747: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
57748: LD_INT 0
57750: PPUSH
// if not mc_bases or not base or not teleports_exit then
57751: LD_EXP 99
57755: NOT
57756: PUSH
57757: LD_VAR 0 1
57761: NOT
57762: OR
57763: PUSH
57764: LD_VAR 0 2
57768: NOT
57769: OR
57770: IFFALSE 57774
// exit ;
57772: GO 57799
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
57774: LD_ADDR_EXP 134
57778: PUSH
57779: LD_EXP 134
57783: PPUSH
57784: LD_VAR 0 1
57788: PPUSH
57789: LD_VAR 0 2
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// end ;
57799: LD_VAR 0 3
57803: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
57804: LD_INT 0
57806: PPUSH
57807: PPUSH
57808: PPUSH
// if not mc_bases or not base or not ext_list then
57809: LD_EXP 99
57813: NOT
57814: PUSH
57815: LD_VAR 0 1
57819: NOT
57820: OR
57821: PUSH
57822: LD_VAR 0 5
57826: NOT
57827: OR
57828: IFFALSE 57832
// exit ;
57830: GO 58005
// tmp := GetFacExtXYD ( x , y , d ) ;
57832: LD_ADDR_VAR 0 8
57836: PUSH
57837: LD_VAR 0 2
57841: PPUSH
57842: LD_VAR 0 3
57846: PPUSH
57847: LD_VAR 0 4
57851: PPUSH
57852: CALL 103009 0 3
57856: ST_TO_ADDR
// if not tmp then
57857: LD_VAR 0 8
57861: NOT
57862: IFFALSE 57866
// exit ;
57864: GO 58005
// for i in tmp do
57866: LD_ADDR_VAR 0 7
57870: PUSH
57871: LD_VAR 0 8
57875: PUSH
57876: FOR_IN
57877: IFFALSE 58003
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
57879: LD_ADDR_EXP 104
57883: PUSH
57884: LD_EXP 104
57888: PPUSH
57889: LD_VAR 0 1
57893: PPUSH
57894: LD_EXP 104
57898: PUSH
57899: LD_VAR 0 1
57903: ARRAY
57904: PPUSH
57905: LD_EXP 104
57909: PUSH
57910: LD_VAR 0 1
57914: ARRAY
57915: PUSH
57916: LD_INT 1
57918: PLUS
57919: PPUSH
57920: LD_VAR 0 5
57924: PUSH
57925: LD_INT 1
57927: ARRAY
57928: PUSH
57929: LD_VAR 0 7
57933: PUSH
57934: LD_INT 1
57936: ARRAY
57937: PUSH
57938: LD_VAR 0 7
57942: PUSH
57943: LD_INT 2
57945: ARRAY
57946: PUSH
57947: LD_VAR 0 7
57951: PUSH
57952: LD_INT 3
57954: ARRAY
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: LIST
57960: LIST
57961: PPUSH
57962: CALL_OW 2
57966: PPUSH
57967: CALL_OW 1
57971: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57972: LD_ADDR_VAR 0 5
57976: PUSH
57977: LD_VAR 0 5
57981: PPUSH
57982: LD_INT 1
57984: PPUSH
57985: CALL_OW 3
57989: ST_TO_ADDR
// if not ext_list then
57990: LD_VAR 0 5
57994: NOT
57995: IFFALSE 58001
// exit ;
57997: POP
57998: POP
57999: GO 58005
// end ;
58001: GO 57876
58003: POP
58004: POP
// end ;
58005: LD_VAR 0 6
58009: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58010: LD_INT 0
58012: PPUSH
// if not mc_bases or not base or not weapon_list then
58013: LD_EXP 99
58017: NOT
58018: PUSH
58019: LD_VAR 0 1
58023: NOT
58024: OR
58025: PUSH
58026: LD_VAR 0 2
58030: NOT
58031: OR
58032: IFFALSE 58036
// exit ;
58034: GO 58061
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58036: LD_ADDR_EXP 138
58040: PUSH
58041: LD_EXP 138
58045: PPUSH
58046: LD_VAR 0 1
58050: PPUSH
58051: LD_VAR 0 2
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
// end ;
58061: LD_VAR 0 3
58065: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58066: LD_INT 0
58068: PPUSH
// if not mc_bases or not base or not tech_list then
58069: LD_EXP 99
58073: NOT
58074: PUSH
58075: LD_VAR 0 1
58079: NOT
58080: OR
58081: PUSH
58082: LD_VAR 0 2
58086: NOT
58087: OR
58088: IFFALSE 58092
// exit ;
58090: GO 58117
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58092: LD_ADDR_EXP 126
58096: PUSH
58097: LD_EXP 126
58101: PPUSH
58102: LD_VAR 0 1
58106: PPUSH
58107: LD_VAR 0 2
58111: PPUSH
58112: CALL_OW 1
58116: ST_TO_ADDR
// end ;
58117: LD_VAR 0 3
58121: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58122: LD_INT 0
58124: PPUSH
// if not mc_bases or not parking_area or not base then
58125: LD_EXP 99
58129: NOT
58130: PUSH
58131: LD_VAR 0 2
58135: NOT
58136: OR
58137: PUSH
58138: LD_VAR 0 1
58142: NOT
58143: OR
58144: IFFALSE 58148
// exit ;
58146: GO 58173
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58148: LD_ADDR_EXP 123
58152: PUSH
58153: LD_EXP 123
58157: PPUSH
58158: LD_VAR 0 1
58162: PPUSH
58163: LD_VAR 0 2
58167: PPUSH
58168: CALL_OW 1
58172: ST_TO_ADDR
// end ;
58173: LD_VAR 0 3
58177: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58178: LD_INT 0
58180: PPUSH
// if not mc_bases or not base or not scan_area then
58181: LD_EXP 99
58185: NOT
58186: PUSH
58187: LD_VAR 0 1
58191: NOT
58192: OR
58193: PUSH
58194: LD_VAR 0 2
58198: NOT
58199: OR
58200: IFFALSE 58204
// exit ;
58202: GO 58229
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58204: LD_ADDR_EXP 124
58208: PUSH
58209: LD_EXP 124
58213: PPUSH
58214: LD_VAR 0 1
58218: PPUSH
58219: LD_VAR 0 2
58223: PPUSH
58224: CALL_OW 1
58228: ST_TO_ADDR
// end ;
58229: LD_VAR 0 3
58233: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58234: LD_INT 0
58236: PPUSH
58237: PPUSH
// if not mc_bases or not base then
58238: LD_EXP 99
58242: NOT
58243: PUSH
58244: LD_VAR 0 1
58248: NOT
58249: OR
58250: IFFALSE 58254
// exit ;
58252: GO 58318
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58254: LD_ADDR_VAR 0 3
58258: PUSH
58259: LD_INT 1
58261: PUSH
58262: LD_INT 2
58264: PUSH
58265: LD_INT 3
58267: PUSH
58268: LD_INT 4
58270: PUSH
58271: LD_INT 11
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: LIST
58278: LIST
58279: LIST
58280: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58281: LD_ADDR_EXP 126
58285: PUSH
58286: LD_EXP 126
58290: PPUSH
58291: LD_VAR 0 1
58295: PPUSH
58296: LD_EXP 126
58300: PUSH
58301: LD_VAR 0 1
58305: ARRAY
58306: PUSH
58307: LD_VAR 0 3
58311: DIFF
58312: PPUSH
58313: CALL_OW 1
58317: ST_TO_ADDR
// end ;
58318: LD_VAR 0 2
58322: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58323: LD_INT 0
58325: PPUSH
// result := mc_vehicles [ base ] ;
58326: LD_ADDR_VAR 0 3
58330: PUSH
58331: LD_EXP 118
58335: PUSH
58336: LD_VAR 0 1
58340: ARRAY
58341: ST_TO_ADDR
// if onlyCombat then
58342: LD_VAR 0 2
58346: IFFALSE 58511
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58348: LD_ADDR_VAR 0 3
58352: PUSH
58353: LD_VAR 0 3
58357: PUSH
58358: LD_VAR 0 3
58362: PPUSH
58363: LD_INT 2
58365: PUSH
58366: LD_INT 34
58368: PUSH
58369: LD_INT 12
58371: PUSH
58372: EMPTY
58373: LIST
58374: LIST
58375: PUSH
58376: LD_INT 34
58378: PUSH
58379: LD_INT 51
58381: PUSH
58382: EMPTY
58383: LIST
58384: LIST
58385: PUSH
58386: LD_INT 34
58388: PUSH
58389: LD_EXP 93
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: PUSH
58398: LD_INT 34
58400: PUSH
58401: LD_INT 32
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: PUSH
58408: LD_INT 34
58410: PUSH
58411: LD_INT 13
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: LD_INT 34
58420: PUSH
58421: LD_INT 52
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: PUSH
58428: LD_INT 34
58430: PUSH
58431: LD_INT 14
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: LD_INT 34
58440: PUSH
58441: LD_INT 53
58443: PUSH
58444: EMPTY
58445: LIST
58446: LIST
58447: PUSH
58448: LD_INT 34
58450: PUSH
58451: LD_EXP 92
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: PUSH
58460: LD_INT 34
58462: PUSH
58463: LD_INT 31
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PUSH
58470: LD_INT 34
58472: PUSH
58473: LD_INT 48
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: PUSH
58480: LD_INT 34
58482: PUSH
58483: LD_INT 8
58485: PUSH
58486: EMPTY
58487: LIST
58488: LIST
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: LIST
58497: LIST
58498: LIST
58499: LIST
58500: LIST
58501: LIST
58502: LIST
58503: LIST
58504: PPUSH
58505: CALL_OW 72
58509: DIFF
58510: ST_TO_ADDR
// end ; end_of_file
58511: LD_VAR 0 3
58515: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58516: LD_INT 0
58518: PPUSH
58519: PPUSH
58520: PPUSH
// if not mc_bases or not skirmish then
58521: LD_EXP 99
58525: NOT
58526: PUSH
58527: LD_EXP 97
58531: NOT
58532: OR
58533: IFFALSE 58537
// exit ;
58535: GO 58702
// for i = 1 to mc_bases do
58537: LD_ADDR_VAR 0 4
58541: PUSH
58542: DOUBLE
58543: LD_INT 1
58545: DEC
58546: ST_TO_ADDR
58547: LD_EXP 99
58551: PUSH
58552: FOR_TO
58553: IFFALSE 58700
// begin if sci in mc_bases [ i ] then
58555: LD_VAR 0 2
58559: PUSH
58560: LD_EXP 99
58564: PUSH
58565: LD_VAR 0 4
58569: ARRAY
58570: IN
58571: IFFALSE 58698
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
58573: LD_ADDR_EXP 128
58577: PUSH
58578: LD_EXP 128
58582: PPUSH
58583: LD_VAR 0 4
58587: PUSH
58588: LD_EXP 128
58592: PUSH
58593: LD_VAR 0 4
58597: ARRAY
58598: PUSH
58599: LD_INT 1
58601: PLUS
58602: PUSH
58603: EMPTY
58604: LIST
58605: LIST
58606: PPUSH
58607: LD_VAR 0 1
58611: PPUSH
58612: CALL 69655 0 3
58616: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
58617: LD_ADDR_VAR 0 5
58621: PUSH
58622: LD_EXP 99
58626: PUSH
58627: LD_VAR 0 4
58631: ARRAY
58632: PPUSH
58633: LD_INT 2
58635: PUSH
58636: LD_INT 30
58638: PUSH
58639: LD_INT 0
58641: PUSH
58642: EMPTY
58643: LIST
58644: LIST
58645: PUSH
58646: LD_INT 30
58648: PUSH
58649: LD_INT 1
58651: PUSH
58652: EMPTY
58653: LIST
58654: LIST
58655: PUSH
58656: EMPTY
58657: LIST
58658: LIST
58659: LIST
58660: PPUSH
58661: CALL_OW 72
58665: PPUSH
58666: LD_VAR 0 1
58670: PPUSH
58671: CALL_OW 74
58675: ST_TO_ADDR
// if tmp then
58676: LD_VAR 0 5
58680: IFFALSE 58696
// ComStandNearbyBuilding ( ape , tmp ) ;
58682: LD_VAR 0 1
58686: PPUSH
58687: LD_VAR 0 5
58691: PPUSH
58692: CALL 64332 0 2
// break ;
58696: GO 58700
// end ; end ;
58698: GO 58552
58700: POP
58701: POP
// end ;
58702: LD_VAR 0 3
58706: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
58707: LD_INT 0
58709: PPUSH
58710: PPUSH
58711: PPUSH
// if not mc_bases or not skirmish then
58712: LD_EXP 99
58716: NOT
58717: PUSH
58718: LD_EXP 97
58722: NOT
58723: OR
58724: IFFALSE 58728
// exit ;
58726: GO 58817
// for i = 1 to mc_bases do
58728: LD_ADDR_VAR 0 4
58732: PUSH
58733: DOUBLE
58734: LD_INT 1
58736: DEC
58737: ST_TO_ADDR
58738: LD_EXP 99
58742: PUSH
58743: FOR_TO
58744: IFFALSE 58815
// begin if building in mc_busy_turret_list [ i ] then
58746: LD_VAR 0 1
58750: PUSH
58751: LD_EXP 109
58755: PUSH
58756: LD_VAR 0 4
58760: ARRAY
58761: IN
58762: IFFALSE 58813
// begin tmp := mc_busy_turret_list [ i ] diff building ;
58764: LD_ADDR_VAR 0 5
58768: PUSH
58769: LD_EXP 109
58773: PUSH
58774: LD_VAR 0 4
58778: ARRAY
58779: PUSH
58780: LD_VAR 0 1
58784: DIFF
58785: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
58786: LD_ADDR_EXP 109
58790: PUSH
58791: LD_EXP 109
58795: PPUSH
58796: LD_VAR 0 4
58800: PPUSH
58801: LD_VAR 0 5
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// break ;
58811: GO 58815
// end ; end ;
58813: GO 58743
58815: POP
58816: POP
// end ;
58817: LD_VAR 0 3
58821: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
58822: LD_INT 0
58824: PPUSH
58825: PPUSH
58826: PPUSH
// if not mc_bases or not skirmish then
58827: LD_EXP 99
58831: NOT
58832: PUSH
58833: LD_EXP 97
58837: NOT
58838: OR
58839: IFFALSE 58843
// exit ;
58841: GO 59042
// for i = 1 to mc_bases do
58843: LD_ADDR_VAR 0 5
58847: PUSH
58848: DOUBLE
58849: LD_INT 1
58851: DEC
58852: ST_TO_ADDR
58853: LD_EXP 99
58857: PUSH
58858: FOR_TO
58859: IFFALSE 59040
// if building in mc_bases [ i ] then
58861: LD_VAR 0 1
58865: PUSH
58866: LD_EXP 99
58870: PUSH
58871: LD_VAR 0 5
58875: ARRAY
58876: IN
58877: IFFALSE 59038
// begin tmp := mc_bases [ i ] diff building ;
58879: LD_ADDR_VAR 0 6
58883: PUSH
58884: LD_EXP 99
58888: PUSH
58889: LD_VAR 0 5
58893: ARRAY
58894: PUSH
58895: LD_VAR 0 1
58899: DIFF
58900: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
58901: LD_ADDR_EXP 99
58905: PUSH
58906: LD_EXP 99
58910: PPUSH
58911: LD_VAR 0 5
58915: PPUSH
58916: LD_VAR 0 6
58920: PPUSH
58921: CALL_OW 1
58925: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
58926: LD_VAR 0 1
58930: PUSH
58931: LD_EXP 107
58935: PUSH
58936: LD_VAR 0 5
58940: ARRAY
58941: IN
58942: IFFALSE 58981
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
58944: LD_ADDR_EXP 107
58948: PUSH
58949: LD_EXP 107
58953: PPUSH
58954: LD_VAR 0 5
58958: PPUSH
58959: LD_EXP 107
58963: PUSH
58964: LD_VAR 0 5
58968: ARRAY
58969: PUSH
58970: LD_VAR 0 1
58974: DIFF
58975: PPUSH
58976: CALL_OW 1
58980: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58981: LD_VAR 0 1
58985: PUSH
58986: LD_EXP 108
58990: PUSH
58991: LD_VAR 0 5
58995: ARRAY
58996: IN
58997: IFFALSE 59036
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
58999: LD_ADDR_EXP 108
59003: PUSH
59004: LD_EXP 108
59008: PPUSH
59009: LD_VAR 0 5
59013: PPUSH
59014: LD_EXP 108
59018: PUSH
59019: LD_VAR 0 5
59023: ARRAY
59024: PUSH
59025: LD_VAR 0 1
59029: DIFF
59030: PPUSH
59031: CALL_OW 1
59035: ST_TO_ADDR
// break ;
59036: GO 59040
// end ;
59038: GO 58858
59040: POP
59041: POP
// end ;
59042: LD_VAR 0 4
59046: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59047: LD_INT 0
59049: PPUSH
59050: PPUSH
59051: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59052: LD_EXP 99
59056: NOT
59057: PUSH
59058: LD_EXP 97
59062: NOT
59063: OR
59064: PUSH
59065: LD_VAR 0 3
59069: PUSH
59070: LD_EXP 125
59074: IN
59075: NOT
59076: OR
59077: IFFALSE 59081
// exit ;
59079: GO 59204
// for i = 1 to mc_vehicles do
59081: LD_ADDR_VAR 0 6
59085: PUSH
59086: DOUBLE
59087: LD_INT 1
59089: DEC
59090: ST_TO_ADDR
59091: LD_EXP 118
59095: PUSH
59096: FOR_TO
59097: IFFALSE 59202
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59099: LD_VAR 0 2
59103: PUSH
59104: LD_EXP 118
59108: PUSH
59109: LD_VAR 0 6
59113: ARRAY
59114: IN
59115: PUSH
59116: LD_VAR 0 1
59120: PUSH
59121: LD_EXP 118
59125: PUSH
59126: LD_VAR 0 6
59130: ARRAY
59131: IN
59132: OR
59133: IFFALSE 59200
// begin tmp := mc_vehicles [ i ] diff old ;
59135: LD_ADDR_VAR 0 7
59139: PUSH
59140: LD_EXP 118
59144: PUSH
59145: LD_VAR 0 6
59149: ARRAY
59150: PUSH
59151: LD_VAR 0 2
59155: DIFF
59156: ST_TO_ADDR
// tmp := tmp diff new ;
59157: LD_ADDR_VAR 0 7
59161: PUSH
59162: LD_VAR 0 7
59166: PUSH
59167: LD_VAR 0 1
59171: DIFF
59172: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59173: LD_ADDR_EXP 118
59177: PUSH
59178: LD_EXP 118
59182: PPUSH
59183: LD_VAR 0 6
59187: PPUSH
59188: LD_VAR 0 7
59192: PPUSH
59193: CALL_OW 1
59197: ST_TO_ADDR
// break ;
59198: GO 59202
// end ;
59200: GO 59096
59202: POP
59203: POP
// end ;
59204: LD_VAR 0 5
59208: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59209: LD_INT 0
59211: PPUSH
59212: PPUSH
59213: PPUSH
59214: PPUSH
// if not mc_bases or not skirmish then
59215: LD_EXP 99
59219: NOT
59220: PUSH
59221: LD_EXP 97
59225: NOT
59226: OR
59227: IFFALSE 59231
// exit ;
59229: GO 59614
// side := GetSide ( vehicle ) ;
59231: LD_ADDR_VAR 0 5
59235: PUSH
59236: LD_VAR 0 1
59240: PPUSH
59241: CALL_OW 255
59245: ST_TO_ADDR
// for i = 1 to mc_bases do
59246: LD_ADDR_VAR 0 4
59250: PUSH
59251: DOUBLE
59252: LD_INT 1
59254: DEC
59255: ST_TO_ADDR
59256: LD_EXP 99
59260: PUSH
59261: FOR_TO
59262: IFFALSE 59612
// begin if factory in mc_bases [ i ] then
59264: LD_VAR 0 2
59268: PUSH
59269: LD_EXP 99
59273: PUSH
59274: LD_VAR 0 4
59278: ARRAY
59279: IN
59280: IFFALSE 59610
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59282: LD_EXP 121
59286: PUSH
59287: LD_VAR 0 4
59291: ARRAY
59292: PUSH
59293: LD_EXP 110
59297: PUSH
59298: LD_VAR 0 4
59302: ARRAY
59303: LESS
59304: PUSH
59305: LD_VAR 0 1
59309: PPUSH
59310: CALL_OW 264
59314: PUSH
59315: LD_INT 31
59317: PUSH
59318: LD_INT 32
59320: PUSH
59321: LD_INT 51
59323: PUSH
59324: LD_EXP 93
59328: PUSH
59329: LD_INT 12
59331: PUSH
59332: LD_INT 30
59334: PUSH
59335: LD_EXP 92
59339: PUSH
59340: LD_INT 11
59342: PUSH
59343: LD_INT 53
59345: PUSH
59346: LD_INT 14
59348: PUSH
59349: LD_EXP 96
59353: PUSH
59354: LD_INT 29
59356: PUSH
59357: LD_EXP 94
59361: PUSH
59362: LD_INT 13
59364: PUSH
59365: LD_INT 52
59367: PUSH
59368: LD_INT 48
59370: PUSH
59371: LD_INT 8
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: LIST
59378: LIST
59379: LIST
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: IN
59393: NOT
59394: AND
59395: IFFALSE 59436
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
59397: LD_ADDR_EXP 121
59401: PUSH
59402: LD_EXP 121
59406: PPUSH
59407: LD_VAR 0 4
59411: PPUSH
59412: LD_EXP 121
59416: PUSH
59417: LD_VAR 0 4
59421: ARRAY
59422: PUSH
59423: LD_VAR 0 1
59427: ADD
59428: PPUSH
59429: CALL_OW 1
59433: ST_TO_ADDR
59434: GO 59480
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59436: LD_ADDR_EXP 118
59440: PUSH
59441: LD_EXP 118
59445: PPUSH
59446: LD_VAR 0 4
59450: PUSH
59451: LD_EXP 118
59455: PUSH
59456: LD_VAR 0 4
59460: ARRAY
59461: PUSH
59462: LD_INT 1
59464: PLUS
59465: PUSH
59466: EMPTY
59467: LIST
59468: LIST
59469: PPUSH
59470: LD_VAR 0 1
59474: PPUSH
59475: CALL 69655 0 3
59479: ST_TO_ADDR
// if not mc_scan [ i ] then
59480: LD_EXP 122
59484: PUSH
59485: LD_VAR 0 4
59489: ARRAY
59490: NOT
59491: IFFALSE 59610
// begin if GetControl ( vehicle ) = control_remote then
59493: LD_VAR 0 1
59497: PPUSH
59498: CALL_OW 263
59502: PUSH
59503: LD_INT 2
59505: EQUAL
59506: IFFALSE 59526
// repeat wait ( 0 0$1 ) ;
59508: LD_INT 35
59510: PPUSH
59511: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59515: LD_VAR 0 1
59519: PPUSH
59520: CALL_OW 312
59524: IFFALSE 59508
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59526: LD_VAR 0 1
59530: PPUSH
59531: LD_EXP 123
59535: PUSH
59536: LD_VAR 0 4
59540: ARRAY
59541: PPUSH
59542: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
59546: LD_VAR 0 1
59550: PPUSH
59551: CALL_OW 263
59555: PUSH
59556: LD_INT 1
59558: NONEQUAL
59559: IFFALSE 59563
// break ;
59561: GO 59612
// repeat wait ( 0 0$1 ) ;
59563: LD_INT 35
59565: PPUSH
59566: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
59570: LD_VAR 0 1
59574: PPUSH
59575: LD_EXP 123
59579: PUSH
59580: LD_VAR 0 4
59584: ARRAY
59585: PPUSH
59586: CALL_OW 308
59590: IFFALSE 59563
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
59592: LD_VAR 0 1
59596: PPUSH
59597: CALL_OW 311
59601: PPUSH
59602: CALL_OW 121
// exit ;
59606: POP
59607: POP
59608: GO 59614
// end ; end ; end ;
59610: GO 59261
59612: POP
59613: POP
// end ;
59614: LD_VAR 0 3
59618: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
59619: LD_INT 0
59621: PPUSH
59622: PPUSH
59623: PPUSH
59624: PPUSH
// if not mc_bases or not skirmish then
59625: LD_EXP 99
59629: NOT
59630: PUSH
59631: LD_EXP 97
59635: NOT
59636: OR
59637: IFFALSE 59641
// exit ;
59639: GO 59994
// repeat wait ( 0 0$1 ) ;
59641: LD_INT 35
59643: PPUSH
59644: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
59648: LD_VAR 0 2
59652: PPUSH
59653: LD_VAR 0 3
59657: PPUSH
59658: CALL_OW 284
59662: IFFALSE 59641
// if GetResourceTypeXY ( x , y ) = mat_artefact then
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_VAR 0 3
59673: PPUSH
59674: CALL_OW 283
59678: PUSH
59679: LD_INT 4
59681: EQUAL
59682: IFFALSE 59686
// exit ;
59684: GO 59994
// for i = 1 to mc_bases do
59686: LD_ADDR_VAR 0 7
59690: PUSH
59691: DOUBLE
59692: LD_INT 1
59694: DEC
59695: ST_TO_ADDR
59696: LD_EXP 99
59700: PUSH
59701: FOR_TO
59702: IFFALSE 59992
// begin if mc_crates_area [ i ] then
59704: LD_EXP 117
59708: PUSH
59709: LD_VAR 0 7
59713: ARRAY
59714: IFFALSE 59825
// for j in mc_crates_area [ i ] do
59716: LD_ADDR_VAR 0 8
59720: PUSH
59721: LD_EXP 117
59725: PUSH
59726: LD_VAR 0 7
59730: ARRAY
59731: PUSH
59732: FOR_IN
59733: IFFALSE 59823
// if InArea ( x , y , j ) then
59735: LD_VAR 0 2
59739: PPUSH
59740: LD_VAR 0 3
59744: PPUSH
59745: LD_VAR 0 8
59749: PPUSH
59750: CALL_OW 309
59754: IFFALSE 59821
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59756: LD_ADDR_EXP 115
59760: PUSH
59761: LD_EXP 115
59765: PPUSH
59766: LD_VAR 0 7
59770: PUSH
59771: LD_EXP 115
59775: PUSH
59776: LD_VAR 0 7
59780: ARRAY
59781: PUSH
59782: LD_INT 1
59784: PLUS
59785: PUSH
59786: EMPTY
59787: LIST
59788: LIST
59789: PPUSH
59790: LD_VAR 0 4
59794: PUSH
59795: LD_VAR 0 2
59799: PUSH
59800: LD_VAR 0 3
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: LIST
59809: PPUSH
59810: CALL 69655 0 3
59814: ST_TO_ADDR
// exit ;
59815: POP
59816: POP
59817: POP
59818: POP
59819: GO 59994
// end ;
59821: GO 59732
59823: POP
59824: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59825: LD_ADDR_VAR 0 9
59829: PUSH
59830: LD_EXP 99
59834: PUSH
59835: LD_VAR 0 7
59839: ARRAY
59840: PPUSH
59841: LD_INT 2
59843: PUSH
59844: LD_INT 30
59846: PUSH
59847: LD_INT 0
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PUSH
59854: LD_INT 30
59856: PUSH
59857: LD_INT 1
59859: PUSH
59860: EMPTY
59861: LIST
59862: LIST
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: LIST
59868: PPUSH
59869: CALL_OW 72
59873: ST_TO_ADDR
// if not depot then
59874: LD_VAR 0 9
59878: NOT
59879: IFFALSE 59883
// continue ;
59881: GO 59701
// for j in depot do
59883: LD_ADDR_VAR 0 8
59887: PUSH
59888: LD_VAR 0 9
59892: PUSH
59893: FOR_IN
59894: IFFALSE 59988
// if GetDistUnitXY ( j , x , y ) < 30 then
59896: LD_VAR 0 8
59900: PPUSH
59901: LD_VAR 0 2
59905: PPUSH
59906: LD_VAR 0 3
59910: PPUSH
59911: CALL_OW 297
59915: PUSH
59916: LD_INT 30
59918: LESS
59919: IFFALSE 59986
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59921: LD_ADDR_EXP 115
59925: PUSH
59926: LD_EXP 115
59930: PPUSH
59931: LD_VAR 0 7
59935: PUSH
59936: LD_EXP 115
59940: PUSH
59941: LD_VAR 0 7
59945: ARRAY
59946: PUSH
59947: LD_INT 1
59949: PLUS
59950: PUSH
59951: EMPTY
59952: LIST
59953: LIST
59954: PPUSH
59955: LD_VAR 0 4
59959: PUSH
59960: LD_VAR 0 2
59964: PUSH
59965: LD_VAR 0 3
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: LIST
59974: PPUSH
59975: CALL 69655 0 3
59979: ST_TO_ADDR
// exit ;
59980: POP
59981: POP
59982: POP
59983: POP
59984: GO 59994
// end ;
59986: GO 59893
59988: POP
59989: POP
// end ;
59990: GO 59701
59992: POP
59993: POP
// end ;
59994: LD_VAR 0 6
59998: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59999: LD_INT 0
60001: PPUSH
60002: PPUSH
60003: PPUSH
60004: PPUSH
// if not mc_bases or not skirmish then
60005: LD_EXP 99
60009: NOT
60010: PUSH
60011: LD_EXP 97
60015: NOT
60016: OR
60017: IFFALSE 60021
// exit ;
60019: GO 60298
// side := GetSide ( lab ) ;
60021: LD_ADDR_VAR 0 4
60025: PUSH
60026: LD_VAR 0 2
60030: PPUSH
60031: CALL_OW 255
60035: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60036: LD_VAR 0 4
60040: PUSH
60041: LD_EXP 125
60045: IN
60046: NOT
60047: PUSH
60048: LD_EXP 126
60052: NOT
60053: OR
60054: PUSH
60055: LD_EXP 99
60059: NOT
60060: OR
60061: IFFALSE 60065
// exit ;
60063: GO 60298
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60065: LD_ADDR_EXP 126
60069: PUSH
60070: LD_EXP 126
60074: PPUSH
60075: LD_VAR 0 4
60079: PPUSH
60080: LD_EXP 126
60084: PUSH
60085: LD_VAR 0 4
60089: ARRAY
60090: PUSH
60091: LD_VAR 0 1
60095: DIFF
60096: PPUSH
60097: CALL_OW 1
60101: ST_TO_ADDR
// for i = 1 to mc_bases do
60102: LD_ADDR_VAR 0 5
60106: PUSH
60107: DOUBLE
60108: LD_INT 1
60110: DEC
60111: ST_TO_ADDR
60112: LD_EXP 99
60116: PUSH
60117: FOR_TO
60118: IFFALSE 60296
// begin if lab in mc_bases [ i ] then
60120: LD_VAR 0 2
60124: PUSH
60125: LD_EXP 99
60129: PUSH
60130: LD_VAR 0 5
60134: ARRAY
60135: IN
60136: IFFALSE 60294
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60138: LD_VAR 0 1
60142: PUSH
60143: LD_INT 11
60145: PUSH
60146: LD_INT 4
60148: PUSH
60149: LD_INT 3
60151: PUSH
60152: LD_INT 2
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: LIST
60159: LIST
60160: IN
60161: PUSH
60162: LD_EXP 129
60166: PUSH
60167: LD_VAR 0 5
60171: ARRAY
60172: AND
60173: IFFALSE 60294
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60175: LD_ADDR_VAR 0 6
60179: PUSH
60180: LD_EXP 129
60184: PUSH
60185: LD_VAR 0 5
60189: ARRAY
60190: PUSH
60191: LD_INT 1
60193: ARRAY
60194: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60195: LD_ADDR_EXP 129
60199: PUSH
60200: LD_EXP 129
60204: PPUSH
60205: LD_VAR 0 5
60209: PPUSH
60210: EMPTY
60211: PPUSH
60212: CALL_OW 1
60216: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60217: LD_VAR 0 6
60221: PPUSH
60222: LD_INT 0
60224: PPUSH
60225: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60229: LD_VAR 0 6
60233: PPUSH
60234: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60238: LD_ADDR_EXP 128
60242: PUSH
60243: LD_EXP 128
60247: PPUSH
60248: LD_VAR 0 5
60252: PPUSH
60253: LD_EXP 128
60257: PUSH
60258: LD_VAR 0 5
60262: ARRAY
60263: PPUSH
60264: LD_INT 1
60266: PPUSH
60267: LD_VAR 0 6
60271: PPUSH
60272: CALL_OW 2
60276: PPUSH
60277: CALL_OW 1
60281: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60282: LD_VAR 0 5
60286: PPUSH
60287: LD_INT 112
60289: PPUSH
60290: CALL 37767 0 2
// end ; end ; end ;
60294: GO 60117
60296: POP
60297: POP
// end ;
60298: LD_VAR 0 3
60302: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60303: LD_INT 0
60305: PPUSH
60306: PPUSH
60307: PPUSH
60308: PPUSH
60309: PPUSH
60310: PPUSH
60311: PPUSH
60312: PPUSH
// if not mc_bases or not skirmish then
60313: LD_EXP 99
60317: NOT
60318: PUSH
60319: LD_EXP 97
60323: NOT
60324: OR
60325: IFFALSE 60329
// exit ;
60327: GO 61345
// for i = 1 to mc_bases do
60329: LD_ADDR_VAR 0 3
60333: PUSH
60334: DOUBLE
60335: LD_INT 1
60337: DEC
60338: ST_TO_ADDR
60339: LD_EXP 99
60343: PUSH
60344: FOR_TO
60345: IFFALSE 61343
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60347: LD_VAR 0 1
60351: PUSH
60352: LD_EXP 99
60356: PUSH
60357: LD_VAR 0 3
60361: ARRAY
60362: IN
60363: PUSH
60364: LD_VAR 0 1
60368: PUSH
60369: LD_EXP 106
60373: PUSH
60374: LD_VAR 0 3
60378: ARRAY
60379: IN
60380: OR
60381: PUSH
60382: LD_VAR 0 1
60386: PUSH
60387: LD_EXP 118
60391: PUSH
60392: LD_VAR 0 3
60396: ARRAY
60397: IN
60398: OR
60399: PUSH
60400: LD_VAR 0 1
60404: PUSH
60405: LD_EXP 128
60409: PUSH
60410: LD_VAR 0 3
60414: ARRAY
60415: IN
60416: OR
60417: PUSH
60418: LD_VAR 0 1
60422: PUSH
60423: LD_EXP 129
60427: PUSH
60428: LD_VAR 0 3
60432: ARRAY
60433: IN
60434: OR
60435: IFFALSE 61341
// begin if un in mc_ape [ i ] then
60437: LD_VAR 0 1
60441: PUSH
60442: LD_EXP 128
60446: PUSH
60447: LD_VAR 0 3
60451: ARRAY
60452: IN
60453: IFFALSE 60492
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60455: LD_ADDR_EXP 128
60459: PUSH
60460: LD_EXP 128
60464: PPUSH
60465: LD_VAR 0 3
60469: PPUSH
60470: LD_EXP 128
60474: PUSH
60475: LD_VAR 0 3
60479: ARRAY
60480: PUSH
60481: LD_VAR 0 1
60485: DIFF
60486: PPUSH
60487: CALL_OW 1
60491: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60492: LD_VAR 0 1
60496: PUSH
60497: LD_EXP 129
60501: PUSH
60502: LD_VAR 0 3
60506: ARRAY
60507: IN
60508: IFFALSE 60532
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60510: LD_ADDR_EXP 129
60514: PUSH
60515: LD_EXP 129
60519: PPUSH
60520: LD_VAR 0 3
60524: PPUSH
60525: EMPTY
60526: PPUSH
60527: CALL_OW 1
60531: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
60532: LD_VAR 0 1
60536: PPUSH
60537: CALL_OW 247
60541: PUSH
60542: LD_INT 2
60544: EQUAL
60545: PUSH
60546: LD_VAR 0 1
60550: PPUSH
60551: CALL_OW 110
60555: PUSH
60556: LD_INT 20
60558: EQUAL
60559: PUSH
60560: LD_VAR 0 1
60564: PUSH
60565: LD_EXP 121
60569: PUSH
60570: LD_VAR 0 3
60574: ARRAY
60575: IN
60576: OR
60577: AND
60578: IFFALSE 60681
// begin fac := MC_GetBuilding ( i , b_factory ) ;
60580: LD_ADDR_VAR 0 8
60584: PUSH
60585: LD_VAR 0 3
60589: PPUSH
60590: LD_INT 3
60592: PPUSH
60593: CALL 57340 0 2
60597: ST_TO_ADDR
// if fac then
60598: LD_VAR 0 8
60602: IFFALSE 60681
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
60604: LD_ADDR_VAR 0 9
60608: PUSH
60609: LD_VAR 0 8
60613: PPUSH
60614: LD_VAR 0 1
60618: PPUSH
60619: CALL_OW 265
60623: PPUSH
60624: LD_VAR 0 1
60628: PPUSH
60629: CALL_OW 262
60633: PPUSH
60634: LD_VAR 0 1
60638: PPUSH
60639: CALL_OW 263
60643: PPUSH
60644: LD_VAR 0 1
60648: PPUSH
60649: CALL_OW 264
60653: PPUSH
60654: CALL 67255 0 5
60658: ST_TO_ADDR
// if components then
60659: LD_VAR 0 9
60663: IFFALSE 60679
// MC_InsertProduceList ( i , components ) ;
60665: LD_VAR 0 3
60669: PPUSH
60670: LD_VAR 0 9
60674: PPUSH
60675: CALL 56968 0 2
// break ;
60679: GO 61343
// end ; end ; if GetType ( un ) = unit_building then
60681: LD_VAR 0 1
60685: PPUSH
60686: CALL_OW 247
60690: PUSH
60691: LD_INT 3
60693: EQUAL
60694: IFFALSE 61009
// begin btype := GetBType ( un ) ;
60696: LD_ADDR_VAR 0 5
60700: PUSH
60701: LD_VAR 0 1
60705: PPUSH
60706: CALL_OW 266
60710: ST_TO_ADDR
// if btype = b_warehouse then
60711: LD_VAR 0 5
60715: PUSH
60716: LD_INT 1
60718: EQUAL
60719: IFFALSE 60737
// begin btype := b_depot ;
60721: LD_ADDR_VAR 0 5
60725: PUSH
60726: LD_INT 0
60728: ST_TO_ADDR
// pos := 1 ;
60729: LD_ADDR_VAR 0 6
60733: PUSH
60734: LD_INT 1
60736: ST_TO_ADDR
// end ; if btype = b_factory then
60737: LD_VAR 0 5
60741: PUSH
60742: LD_INT 3
60744: EQUAL
60745: IFFALSE 60763
// begin btype := b_workshop ;
60747: LD_ADDR_VAR 0 5
60751: PUSH
60752: LD_INT 2
60754: ST_TO_ADDR
// pos := 1 ;
60755: LD_ADDR_VAR 0 6
60759: PUSH
60760: LD_INT 1
60762: ST_TO_ADDR
// end ; if btype = b_barracks then
60763: LD_VAR 0 5
60767: PUSH
60768: LD_INT 5
60770: EQUAL
60771: IFFALSE 60781
// btype := b_armoury ;
60773: LD_ADDR_VAR 0 5
60777: PUSH
60778: LD_INT 4
60780: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
60781: LD_VAR 0 5
60785: PUSH
60786: LD_INT 7
60788: PUSH
60789: LD_INT 8
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: IN
60796: IFFALSE 60806
// btype := b_lab ;
60798: LD_ADDR_VAR 0 5
60802: PUSH
60803: LD_INT 6
60805: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
60806: LD_ADDR_EXP 104
60810: PUSH
60811: LD_EXP 104
60815: PPUSH
60816: LD_VAR 0 3
60820: PUSH
60821: LD_EXP 104
60825: PUSH
60826: LD_VAR 0 3
60830: ARRAY
60831: PUSH
60832: LD_INT 1
60834: PLUS
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: PPUSH
60840: LD_VAR 0 5
60844: PUSH
60845: LD_VAR 0 1
60849: PPUSH
60850: CALL_OW 250
60854: PUSH
60855: LD_VAR 0 1
60859: PPUSH
60860: CALL_OW 251
60864: PUSH
60865: LD_VAR 0 1
60869: PPUSH
60870: CALL_OW 254
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: PPUSH
60881: CALL 69655 0 3
60885: ST_TO_ADDR
// if pos = 1 then
60886: LD_VAR 0 6
60890: PUSH
60891: LD_INT 1
60893: EQUAL
60894: IFFALSE 61009
// begin tmp := mc_build_list [ i ] ;
60896: LD_ADDR_VAR 0 7
60900: PUSH
60901: LD_EXP 104
60905: PUSH
60906: LD_VAR 0 3
60910: ARRAY
60911: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60912: LD_VAR 0 7
60916: PPUSH
60917: LD_INT 2
60919: PUSH
60920: LD_INT 30
60922: PUSH
60923: LD_INT 0
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 30
60932: PUSH
60933: LD_INT 1
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: LIST
60944: PPUSH
60945: CALL_OW 72
60949: IFFALSE 60959
// pos := 2 ;
60951: LD_ADDR_VAR 0 6
60955: PUSH
60956: LD_INT 2
60958: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
60959: LD_ADDR_VAR 0 7
60963: PUSH
60964: LD_VAR 0 7
60968: PPUSH
60969: LD_VAR 0 6
60973: PPUSH
60974: LD_VAR 0 7
60978: PPUSH
60979: CALL 69981 0 3
60983: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
60984: LD_ADDR_EXP 104
60988: PUSH
60989: LD_EXP 104
60993: PPUSH
60994: LD_VAR 0 3
60998: PPUSH
60999: LD_VAR 0 7
61003: PPUSH
61004: CALL_OW 1
61008: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61009: LD_VAR 0 1
61013: PUSH
61014: LD_EXP 99
61018: PUSH
61019: LD_VAR 0 3
61023: ARRAY
61024: IN
61025: IFFALSE 61064
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61027: LD_ADDR_EXP 99
61031: PUSH
61032: LD_EXP 99
61036: PPUSH
61037: LD_VAR 0 3
61041: PPUSH
61042: LD_EXP 99
61046: PUSH
61047: LD_VAR 0 3
61051: ARRAY
61052: PUSH
61053: LD_VAR 0 1
61057: DIFF
61058: PPUSH
61059: CALL_OW 1
61063: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61064: LD_VAR 0 1
61068: PUSH
61069: LD_EXP 106
61073: PUSH
61074: LD_VAR 0 3
61078: ARRAY
61079: IN
61080: IFFALSE 61119
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61082: LD_ADDR_EXP 106
61086: PUSH
61087: LD_EXP 106
61091: PPUSH
61092: LD_VAR 0 3
61096: PPUSH
61097: LD_EXP 106
61101: PUSH
61102: LD_VAR 0 3
61106: ARRAY
61107: PUSH
61108: LD_VAR 0 1
61112: DIFF
61113: PPUSH
61114: CALL_OW 1
61118: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61119: LD_VAR 0 1
61123: PUSH
61124: LD_EXP 118
61128: PUSH
61129: LD_VAR 0 3
61133: ARRAY
61134: IN
61135: IFFALSE 61174
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61137: LD_ADDR_EXP 118
61141: PUSH
61142: LD_EXP 118
61146: PPUSH
61147: LD_VAR 0 3
61151: PPUSH
61152: LD_EXP 118
61156: PUSH
61157: LD_VAR 0 3
61161: ARRAY
61162: PUSH
61163: LD_VAR 0 1
61167: DIFF
61168: PPUSH
61169: CALL_OW 1
61173: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61174: LD_VAR 0 1
61178: PUSH
61179: LD_EXP 121
61183: PUSH
61184: LD_VAR 0 3
61188: ARRAY
61189: IN
61190: IFFALSE 61229
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61192: LD_ADDR_EXP 121
61196: PUSH
61197: LD_EXP 121
61201: PPUSH
61202: LD_VAR 0 3
61206: PPUSH
61207: LD_EXP 121
61211: PUSH
61212: LD_VAR 0 3
61216: ARRAY
61217: PUSH
61218: LD_VAR 0 1
61222: DIFF
61223: PPUSH
61224: CALL_OW 1
61228: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61229: LD_VAR 0 1
61233: PUSH
61234: LD_EXP 108
61238: PUSH
61239: LD_VAR 0 3
61243: ARRAY
61244: IN
61245: IFFALSE 61284
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61247: LD_ADDR_EXP 108
61251: PUSH
61252: LD_EXP 108
61256: PPUSH
61257: LD_VAR 0 3
61261: PPUSH
61262: LD_EXP 108
61266: PUSH
61267: LD_VAR 0 3
61271: ARRAY
61272: PUSH
61273: LD_VAR 0 1
61277: DIFF
61278: PPUSH
61279: CALL_OW 1
61283: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61284: LD_VAR 0 1
61288: PUSH
61289: LD_EXP 107
61293: PUSH
61294: LD_VAR 0 3
61298: ARRAY
61299: IN
61300: IFFALSE 61339
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61302: LD_ADDR_EXP 107
61306: PUSH
61307: LD_EXP 107
61311: PPUSH
61312: LD_VAR 0 3
61316: PPUSH
61317: LD_EXP 107
61321: PUSH
61322: LD_VAR 0 3
61326: ARRAY
61327: PUSH
61328: LD_VAR 0 1
61332: DIFF
61333: PPUSH
61334: CALL_OW 1
61338: ST_TO_ADDR
// end ; break ;
61339: GO 61343
// end ;
61341: GO 60344
61343: POP
61344: POP
// end ;
61345: LD_VAR 0 2
61349: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61350: LD_INT 0
61352: PPUSH
61353: PPUSH
61354: PPUSH
// if not mc_bases or not skirmish then
61355: LD_EXP 99
61359: NOT
61360: PUSH
61361: LD_EXP 97
61365: NOT
61366: OR
61367: IFFALSE 61371
// exit ;
61369: GO 61586
// for i = 1 to mc_bases do
61371: LD_ADDR_VAR 0 3
61375: PUSH
61376: DOUBLE
61377: LD_INT 1
61379: DEC
61380: ST_TO_ADDR
61381: LD_EXP 99
61385: PUSH
61386: FOR_TO
61387: IFFALSE 61584
// begin if building in mc_construct_list [ i ] then
61389: LD_VAR 0 1
61393: PUSH
61394: LD_EXP 106
61398: PUSH
61399: LD_VAR 0 3
61403: ARRAY
61404: IN
61405: IFFALSE 61582
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61407: LD_ADDR_EXP 106
61411: PUSH
61412: LD_EXP 106
61416: PPUSH
61417: LD_VAR 0 3
61421: PPUSH
61422: LD_EXP 106
61426: PUSH
61427: LD_VAR 0 3
61431: ARRAY
61432: PUSH
61433: LD_VAR 0 1
61437: DIFF
61438: PPUSH
61439: CALL_OW 1
61443: ST_TO_ADDR
// if building in mc_lab [ i ] then
61444: LD_VAR 0 1
61448: PUSH
61449: LD_EXP 132
61453: PUSH
61454: LD_VAR 0 3
61458: ARRAY
61459: IN
61460: IFFALSE 61515
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
61462: LD_ADDR_EXP 133
61466: PUSH
61467: LD_EXP 133
61471: PPUSH
61472: LD_VAR 0 3
61476: PPUSH
61477: LD_EXP 133
61481: PUSH
61482: LD_VAR 0 3
61486: ARRAY
61487: PPUSH
61488: LD_INT 1
61490: PPUSH
61491: LD_EXP 133
61495: PUSH
61496: LD_VAR 0 3
61500: ARRAY
61501: PPUSH
61502: LD_INT 0
61504: PPUSH
61505: CALL 69073 0 4
61509: PPUSH
61510: CALL_OW 1
61514: ST_TO_ADDR
// if not building in mc_bases [ i ] then
61515: LD_VAR 0 1
61519: PUSH
61520: LD_EXP 99
61524: PUSH
61525: LD_VAR 0 3
61529: ARRAY
61530: IN
61531: NOT
61532: IFFALSE 61578
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61534: LD_ADDR_EXP 99
61538: PUSH
61539: LD_EXP 99
61543: PPUSH
61544: LD_VAR 0 3
61548: PUSH
61549: LD_EXP 99
61553: PUSH
61554: LD_VAR 0 3
61558: ARRAY
61559: PUSH
61560: LD_INT 1
61562: PLUS
61563: PUSH
61564: EMPTY
61565: LIST
61566: LIST
61567: PPUSH
61568: LD_VAR 0 1
61572: PPUSH
61573: CALL 69655 0 3
61577: ST_TO_ADDR
// exit ;
61578: POP
61579: POP
61580: GO 61586
// end ; end ;
61582: GO 61386
61584: POP
61585: POP
// end ;
61586: LD_VAR 0 2
61590: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
61591: LD_INT 0
61593: PPUSH
61594: PPUSH
61595: PPUSH
61596: PPUSH
61597: PPUSH
61598: PPUSH
61599: PPUSH
// if not mc_bases or not skirmish then
61600: LD_EXP 99
61604: NOT
61605: PUSH
61606: LD_EXP 97
61610: NOT
61611: OR
61612: IFFALSE 61616
// exit ;
61614: GO 62277
// for i = 1 to mc_bases do
61616: LD_ADDR_VAR 0 3
61620: PUSH
61621: DOUBLE
61622: LD_INT 1
61624: DEC
61625: ST_TO_ADDR
61626: LD_EXP 99
61630: PUSH
61631: FOR_TO
61632: IFFALSE 62275
// begin if building in mc_construct_list [ i ] then
61634: LD_VAR 0 1
61638: PUSH
61639: LD_EXP 106
61643: PUSH
61644: LD_VAR 0 3
61648: ARRAY
61649: IN
61650: IFFALSE 62273
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61652: LD_ADDR_EXP 106
61656: PUSH
61657: LD_EXP 106
61661: PPUSH
61662: LD_VAR 0 3
61666: PPUSH
61667: LD_EXP 106
61671: PUSH
61672: LD_VAR 0 3
61676: ARRAY
61677: PUSH
61678: LD_VAR 0 1
61682: DIFF
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61689: LD_ADDR_EXP 99
61693: PUSH
61694: LD_EXP 99
61698: PPUSH
61699: LD_VAR 0 3
61703: PUSH
61704: LD_EXP 99
61708: PUSH
61709: LD_VAR 0 3
61713: ARRAY
61714: PUSH
61715: LD_INT 1
61717: PLUS
61718: PUSH
61719: EMPTY
61720: LIST
61721: LIST
61722: PPUSH
61723: LD_VAR 0 1
61727: PPUSH
61728: CALL 69655 0 3
61732: ST_TO_ADDR
// btype := GetBType ( building ) ;
61733: LD_ADDR_VAR 0 5
61737: PUSH
61738: LD_VAR 0 1
61742: PPUSH
61743: CALL_OW 266
61747: ST_TO_ADDR
// side := GetSide ( building ) ;
61748: LD_ADDR_VAR 0 8
61752: PUSH
61753: LD_VAR 0 1
61757: PPUSH
61758: CALL_OW 255
61762: ST_TO_ADDR
// if btype = b_lab then
61763: LD_VAR 0 5
61767: PUSH
61768: LD_INT 6
61770: EQUAL
61771: IFFALSE 61821
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
61773: LD_ADDR_EXP 132
61777: PUSH
61778: LD_EXP 132
61782: PPUSH
61783: LD_VAR 0 3
61787: PUSH
61788: LD_EXP 132
61792: PUSH
61793: LD_VAR 0 3
61797: ARRAY
61798: PUSH
61799: LD_INT 1
61801: PLUS
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: PPUSH
61807: LD_VAR 0 1
61811: PPUSH
61812: CALL 69655 0 3
61816: ST_TO_ADDR
// exit ;
61817: POP
61818: POP
61819: GO 62277
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
61821: LD_VAR 0 5
61825: PUSH
61826: LD_INT 0
61828: PUSH
61829: LD_INT 2
61831: PUSH
61832: LD_INT 4
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: LIST
61839: IN
61840: IFFALSE 61964
// begin if btype = b_armoury then
61842: LD_VAR 0 5
61846: PUSH
61847: LD_INT 4
61849: EQUAL
61850: IFFALSE 61860
// btype := b_barracks ;
61852: LD_ADDR_VAR 0 5
61856: PUSH
61857: LD_INT 5
61859: ST_TO_ADDR
// if btype = b_depot then
61860: LD_VAR 0 5
61864: PUSH
61865: LD_INT 0
61867: EQUAL
61868: IFFALSE 61878
// btype := b_warehouse ;
61870: LD_ADDR_VAR 0 5
61874: PUSH
61875: LD_INT 1
61877: ST_TO_ADDR
// if btype = b_workshop then
61878: LD_VAR 0 5
61882: PUSH
61883: LD_INT 2
61885: EQUAL
61886: IFFALSE 61896
// btype := b_factory ;
61888: LD_ADDR_VAR 0 5
61892: PUSH
61893: LD_INT 3
61895: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
61896: LD_VAR 0 5
61900: PPUSH
61901: LD_VAR 0 8
61905: PPUSH
61906: CALL_OW 323
61910: PUSH
61911: LD_INT 1
61913: EQUAL
61914: IFFALSE 61960
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
61916: LD_ADDR_EXP 131
61920: PUSH
61921: LD_EXP 131
61925: PPUSH
61926: LD_VAR 0 3
61930: PUSH
61931: LD_EXP 131
61935: PUSH
61936: LD_VAR 0 3
61940: ARRAY
61941: PUSH
61942: LD_INT 1
61944: PLUS
61945: PUSH
61946: EMPTY
61947: LIST
61948: LIST
61949: PPUSH
61950: LD_VAR 0 1
61954: PPUSH
61955: CALL 69655 0 3
61959: ST_TO_ADDR
// exit ;
61960: POP
61961: POP
61962: GO 62277
// end ; if btype in [ b_bunker , b_turret ] then
61964: LD_VAR 0 5
61968: PUSH
61969: LD_INT 32
61971: PUSH
61972: LD_INT 33
61974: PUSH
61975: EMPTY
61976: LIST
61977: LIST
61978: IN
61979: IFFALSE 62269
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
61981: LD_ADDR_EXP 107
61985: PUSH
61986: LD_EXP 107
61990: PPUSH
61991: LD_VAR 0 3
61995: PUSH
61996: LD_EXP 107
62000: PUSH
62001: LD_VAR 0 3
62005: ARRAY
62006: PUSH
62007: LD_INT 1
62009: PLUS
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: PPUSH
62015: LD_VAR 0 1
62019: PPUSH
62020: CALL 69655 0 3
62024: ST_TO_ADDR
// if btype = b_bunker then
62025: LD_VAR 0 5
62029: PUSH
62030: LD_INT 32
62032: EQUAL
62033: IFFALSE 62269
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62035: LD_ADDR_EXP 108
62039: PUSH
62040: LD_EXP 108
62044: PPUSH
62045: LD_VAR 0 3
62049: PUSH
62050: LD_EXP 108
62054: PUSH
62055: LD_VAR 0 3
62059: ARRAY
62060: PUSH
62061: LD_INT 1
62063: PLUS
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PPUSH
62069: LD_VAR 0 1
62073: PPUSH
62074: CALL 69655 0 3
62078: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62079: LD_ADDR_VAR 0 6
62083: PUSH
62084: LD_EXP 99
62088: PUSH
62089: LD_VAR 0 3
62093: ARRAY
62094: PPUSH
62095: LD_INT 25
62097: PUSH
62098: LD_INT 1
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: PUSH
62105: LD_INT 3
62107: PUSH
62108: LD_INT 54
62110: PUSH
62111: EMPTY
62112: LIST
62113: PUSH
62114: EMPTY
62115: LIST
62116: LIST
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PPUSH
62122: CALL_OW 72
62126: ST_TO_ADDR
// if tmp then
62127: LD_VAR 0 6
62131: IFFALSE 62137
// exit ;
62133: POP
62134: POP
62135: GO 62277
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62137: LD_ADDR_VAR 0 6
62141: PUSH
62142: LD_EXP 99
62146: PUSH
62147: LD_VAR 0 3
62151: ARRAY
62152: PPUSH
62153: LD_INT 2
62155: PUSH
62156: LD_INT 30
62158: PUSH
62159: LD_INT 4
62161: PUSH
62162: EMPTY
62163: LIST
62164: LIST
62165: PUSH
62166: LD_INT 30
62168: PUSH
62169: LD_INT 5
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: PPUSH
62181: CALL_OW 72
62185: ST_TO_ADDR
// if not tmp then
62186: LD_VAR 0 6
62190: NOT
62191: IFFALSE 62197
// exit ;
62193: POP
62194: POP
62195: GO 62277
// for j in tmp do
62197: LD_ADDR_VAR 0 4
62201: PUSH
62202: LD_VAR 0 6
62206: PUSH
62207: FOR_IN
62208: IFFALSE 62267
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62210: LD_ADDR_VAR 0 7
62214: PUSH
62215: LD_VAR 0 4
62219: PPUSH
62220: CALL_OW 313
62224: PPUSH
62225: LD_INT 25
62227: PUSH
62228: LD_INT 1
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PPUSH
62235: CALL_OW 72
62239: ST_TO_ADDR
// if units then
62240: LD_VAR 0 7
62244: IFFALSE 62265
// begin ComExitBuilding ( units [ 1 ] ) ;
62246: LD_VAR 0 7
62250: PUSH
62251: LD_INT 1
62253: ARRAY
62254: PPUSH
62255: CALL_OW 122
// exit ;
62259: POP
62260: POP
62261: POP
62262: POP
62263: GO 62277
// end ; end ;
62265: GO 62207
62267: POP
62268: POP
// end ; end ; exit ;
62269: POP
62270: POP
62271: GO 62277
// end ; end ;
62273: GO 61631
62275: POP
62276: POP
// end ;
62277: LD_VAR 0 2
62281: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62282: LD_INT 0
62284: PPUSH
62285: PPUSH
62286: PPUSH
62287: PPUSH
62288: PPUSH
62289: PPUSH
62290: PPUSH
// if not mc_bases or not skirmish then
62291: LD_EXP 99
62295: NOT
62296: PUSH
62297: LD_EXP 97
62301: NOT
62302: OR
62303: IFFALSE 62307
// exit ;
62305: GO 62538
// btype := GetBType ( building ) ;
62307: LD_ADDR_VAR 0 6
62311: PUSH
62312: LD_VAR 0 1
62316: PPUSH
62317: CALL_OW 266
62321: ST_TO_ADDR
// x := GetX ( building ) ;
62322: LD_ADDR_VAR 0 7
62326: PUSH
62327: LD_VAR 0 1
62331: PPUSH
62332: CALL_OW 250
62336: ST_TO_ADDR
// y := GetY ( building ) ;
62337: LD_ADDR_VAR 0 8
62341: PUSH
62342: LD_VAR 0 1
62346: PPUSH
62347: CALL_OW 251
62351: ST_TO_ADDR
// d := GetDir ( building ) ;
62352: LD_ADDR_VAR 0 9
62356: PUSH
62357: LD_VAR 0 1
62361: PPUSH
62362: CALL_OW 254
62366: ST_TO_ADDR
// for i = 1 to mc_bases do
62367: LD_ADDR_VAR 0 4
62371: PUSH
62372: DOUBLE
62373: LD_INT 1
62375: DEC
62376: ST_TO_ADDR
62377: LD_EXP 99
62381: PUSH
62382: FOR_TO
62383: IFFALSE 62536
// begin if not mc_build_list [ i ] then
62385: LD_EXP 104
62389: PUSH
62390: LD_VAR 0 4
62394: ARRAY
62395: NOT
62396: IFFALSE 62400
// continue ;
62398: GO 62382
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62400: LD_VAR 0 6
62404: PUSH
62405: LD_VAR 0 7
62409: PUSH
62410: LD_VAR 0 8
62414: PUSH
62415: LD_VAR 0 9
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: LIST
62424: LIST
62425: PPUSH
62426: LD_EXP 104
62430: PUSH
62431: LD_VAR 0 4
62435: ARRAY
62436: PUSH
62437: LD_INT 1
62439: ARRAY
62440: PPUSH
62441: CALL 75824 0 2
62445: IFFALSE 62534
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
62447: LD_ADDR_EXP 104
62451: PUSH
62452: LD_EXP 104
62456: PPUSH
62457: LD_VAR 0 4
62461: PPUSH
62462: LD_EXP 104
62466: PUSH
62467: LD_VAR 0 4
62471: ARRAY
62472: PPUSH
62473: LD_INT 1
62475: PPUSH
62476: CALL_OW 3
62480: PPUSH
62481: CALL_OW 1
62485: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
62486: LD_ADDR_EXP 106
62490: PUSH
62491: LD_EXP 106
62495: PPUSH
62496: LD_VAR 0 4
62500: PUSH
62501: LD_EXP 106
62505: PUSH
62506: LD_VAR 0 4
62510: ARRAY
62511: PUSH
62512: LD_INT 1
62514: PLUS
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PPUSH
62520: LD_VAR 0 1
62524: PPUSH
62525: CALL 69655 0 3
62529: ST_TO_ADDR
// exit ;
62530: POP
62531: POP
62532: GO 62538
// end ; end ;
62534: GO 62382
62536: POP
62537: POP
// end ;
62538: LD_VAR 0 3
62542: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
62543: LD_INT 0
62545: PPUSH
62546: PPUSH
62547: PPUSH
// if not mc_bases or not skirmish then
62548: LD_EXP 99
62552: NOT
62553: PUSH
62554: LD_EXP 97
62558: NOT
62559: OR
62560: IFFALSE 62564
// exit ;
62562: GO 62754
// for i = 1 to mc_bases do
62564: LD_ADDR_VAR 0 4
62568: PUSH
62569: DOUBLE
62570: LD_INT 1
62572: DEC
62573: ST_TO_ADDR
62574: LD_EXP 99
62578: PUSH
62579: FOR_TO
62580: IFFALSE 62667
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
62582: LD_VAR 0 1
62586: PUSH
62587: LD_EXP 107
62591: PUSH
62592: LD_VAR 0 4
62596: ARRAY
62597: IN
62598: PUSH
62599: LD_VAR 0 1
62603: PUSH
62604: LD_EXP 108
62608: PUSH
62609: LD_VAR 0 4
62613: ARRAY
62614: IN
62615: NOT
62616: AND
62617: IFFALSE 62665
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62619: LD_ADDR_EXP 108
62623: PUSH
62624: LD_EXP 108
62628: PPUSH
62629: LD_VAR 0 4
62633: PUSH
62634: LD_EXP 108
62638: PUSH
62639: LD_VAR 0 4
62643: ARRAY
62644: PUSH
62645: LD_INT 1
62647: PLUS
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PPUSH
62653: LD_VAR 0 1
62657: PPUSH
62658: CALL 69655 0 3
62662: ST_TO_ADDR
// break ;
62663: GO 62667
// end ; end ;
62665: GO 62579
62667: POP
62668: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
62669: LD_VAR 0 1
62673: PPUSH
62674: CALL_OW 257
62678: PUSH
62679: LD_EXP 125
62683: IN
62684: PUSH
62685: LD_VAR 0 1
62689: PPUSH
62690: CALL_OW 266
62694: PUSH
62695: LD_INT 5
62697: EQUAL
62698: AND
62699: PUSH
62700: LD_VAR 0 2
62704: PPUSH
62705: CALL_OW 110
62709: PUSH
62710: LD_INT 18
62712: NONEQUAL
62713: AND
62714: IFFALSE 62754
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
62716: LD_VAR 0 2
62720: PPUSH
62721: CALL_OW 257
62725: PUSH
62726: LD_INT 5
62728: PUSH
62729: LD_INT 8
62731: PUSH
62732: LD_INT 9
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: LIST
62739: IN
62740: IFFALSE 62754
// SetClass ( unit , 1 ) ;
62742: LD_VAR 0 2
62746: PPUSH
62747: LD_INT 1
62749: PPUSH
62750: CALL_OW 336
// end ;
62754: LD_VAR 0 3
62758: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
62759: LD_INT 0
62761: PPUSH
62762: PPUSH
// if not mc_bases or not skirmish then
62763: LD_EXP 99
62767: NOT
62768: PUSH
62769: LD_EXP 97
62773: NOT
62774: OR
62775: IFFALSE 62779
// exit ;
62777: GO 62895
// if GetLives ( abandoned_vehicle ) > 250 then
62779: LD_VAR 0 2
62783: PPUSH
62784: CALL_OW 256
62788: PUSH
62789: LD_INT 250
62791: GREATER
62792: IFFALSE 62796
// exit ;
62794: GO 62895
// for i = 1 to mc_bases do
62796: LD_ADDR_VAR 0 6
62800: PUSH
62801: DOUBLE
62802: LD_INT 1
62804: DEC
62805: ST_TO_ADDR
62806: LD_EXP 99
62810: PUSH
62811: FOR_TO
62812: IFFALSE 62893
// begin if driver in mc_bases [ i ] then
62814: LD_VAR 0 1
62818: PUSH
62819: LD_EXP 99
62823: PUSH
62824: LD_VAR 0 6
62828: ARRAY
62829: IN
62830: IFFALSE 62891
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
62832: LD_VAR 0 1
62836: PPUSH
62837: LD_EXP 99
62841: PUSH
62842: LD_VAR 0 6
62846: ARRAY
62847: PPUSH
62848: LD_INT 2
62850: PUSH
62851: LD_INT 30
62853: PUSH
62854: LD_INT 0
62856: PUSH
62857: EMPTY
62858: LIST
62859: LIST
62860: PUSH
62861: LD_INT 30
62863: PUSH
62864: LD_INT 1
62866: PUSH
62867: EMPTY
62868: LIST
62869: LIST
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: LIST
62875: PPUSH
62876: CALL_OW 72
62880: PUSH
62881: LD_INT 1
62883: ARRAY
62884: PPUSH
62885: CALL_OW 112
// break ;
62889: GO 62893
// end ; end ;
62891: GO 62811
62893: POP
62894: POP
// end ; end_of_file
62895: LD_VAR 0 5
62899: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62900: LD_INT 0
62902: PPUSH
62903: PPUSH
// if exist_mode then
62904: LD_VAR 0 2
62908: IFFALSE 62933
// unit := CreateCharacter ( prefix & ident ) else
62910: LD_ADDR_VAR 0 5
62914: PUSH
62915: LD_VAR 0 3
62919: PUSH
62920: LD_VAR 0 1
62924: STR
62925: PPUSH
62926: CALL_OW 34
62930: ST_TO_ADDR
62931: GO 62948
// unit := NewCharacter ( ident ) ;
62933: LD_ADDR_VAR 0 5
62937: PUSH
62938: LD_VAR 0 1
62942: PPUSH
62943: CALL_OW 25
62947: ST_TO_ADDR
// result := unit ;
62948: LD_ADDR_VAR 0 4
62952: PUSH
62953: LD_VAR 0 5
62957: ST_TO_ADDR
// end ;
62958: LD_VAR 0 4
62962: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
62963: LD_INT 0
62965: PPUSH
62966: PPUSH
// if not side or not nation then
62967: LD_VAR 0 1
62971: NOT
62972: PUSH
62973: LD_VAR 0 2
62977: NOT
62978: OR
62979: IFFALSE 62983
// exit ;
62981: GO 63619
// case nation of nation_american :
62983: LD_VAR 0 2
62987: PUSH
62988: LD_INT 1
62990: DOUBLE
62991: EQUAL
62992: IFTRUE 62996
62994: GO 63166
62996: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
62997: LD_ADDR_VAR 0 4
63001: PUSH
63002: LD_INT 35
63004: PUSH
63005: LD_INT 45
63007: PUSH
63008: LD_INT 46
63010: PUSH
63011: LD_INT 47
63013: PUSH
63014: LD_INT 1
63016: PUSH
63017: LD_INT 2
63019: PUSH
63020: LD_INT 6
63022: PUSH
63023: LD_INT 15
63025: PUSH
63026: LD_INT 16
63028: PUSH
63029: LD_INT 7
63031: PUSH
63032: LD_INT 12
63034: PUSH
63035: LD_INT 13
63037: PUSH
63038: LD_INT 10
63040: PUSH
63041: LD_INT 14
63043: PUSH
63044: LD_INT 20
63046: PUSH
63047: LD_INT 21
63049: PUSH
63050: LD_INT 22
63052: PUSH
63053: LD_INT 25
63055: PUSH
63056: LD_INT 32
63058: PUSH
63059: LD_INT 27
63061: PUSH
63062: LD_INT 36
63064: PUSH
63065: LD_INT 69
63067: PUSH
63068: LD_INT 39
63070: PUSH
63071: LD_INT 34
63073: PUSH
63074: LD_INT 40
63076: PUSH
63077: LD_INT 48
63079: PUSH
63080: LD_INT 49
63082: PUSH
63083: LD_INT 50
63085: PUSH
63086: LD_INT 51
63088: PUSH
63089: LD_INT 52
63091: PUSH
63092: LD_INT 53
63094: PUSH
63095: LD_INT 54
63097: PUSH
63098: LD_INT 55
63100: PUSH
63101: LD_INT 56
63103: PUSH
63104: LD_INT 57
63106: PUSH
63107: LD_INT 58
63109: PUSH
63110: LD_INT 59
63112: PUSH
63113: LD_INT 60
63115: PUSH
63116: LD_INT 61
63118: PUSH
63119: LD_INT 62
63121: PUSH
63122: EMPTY
63123: LIST
63124: LIST
63125: LIST
63126: LIST
63127: LIST
63128: LIST
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: LIST
63134: LIST
63135: LIST
63136: LIST
63137: LIST
63138: LIST
63139: LIST
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: ST_TO_ADDR
63164: GO 63543
63166: LD_INT 2
63168: DOUBLE
63169: EQUAL
63170: IFTRUE 63174
63172: GO 63352
63174: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
63175: LD_ADDR_VAR 0 4
63179: PUSH
63180: LD_INT 35
63182: PUSH
63183: LD_INT 45
63185: PUSH
63186: LD_INT 46
63188: PUSH
63189: LD_INT 47
63191: PUSH
63192: LD_INT 70
63194: PUSH
63195: LD_INT 1
63197: PUSH
63198: LD_INT 11
63200: PUSH
63201: LD_INT 3
63203: PUSH
63204: LD_INT 4
63206: PUSH
63207: LD_INT 5
63209: PUSH
63210: LD_INT 6
63212: PUSH
63213: LD_INT 15
63215: PUSH
63216: LD_INT 18
63218: PUSH
63219: LD_INT 7
63221: PUSH
63222: LD_INT 17
63224: PUSH
63225: LD_INT 8
63227: PUSH
63228: LD_INT 20
63230: PUSH
63231: LD_INT 21
63233: PUSH
63234: LD_INT 22
63236: PUSH
63237: LD_INT 72
63239: PUSH
63240: LD_INT 26
63242: PUSH
63243: LD_INT 69
63245: PUSH
63246: LD_INT 39
63248: PUSH
63249: LD_INT 40
63251: PUSH
63252: LD_INT 41
63254: PUSH
63255: LD_INT 42
63257: PUSH
63258: LD_INT 43
63260: PUSH
63261: LD_INT 48
63263: PUSH
63264: LD_INT 49
63266: PUSH
63267: LD_INT 50
63269: PUSH
63270: LD_INT 51
63272: PUSH
63273: LD_INT 52
63275: PUSH
63276: LD_INT 53
63278: PUSH
63279: LD_INT 54
63281: PUSH
63282: LD_INT 55
63284: PUSH
63285: LD_INT 56
63287: PUSH
63288: LD_INT 60
63290: PUSH
63291: LD_INT 61
63293: PUSH
63294: LD_INT 62
63296: PUSH
63297: LD_INT 66
63299: PUSH
63300: LD_INT 67
63302: PUSH
63303: LD_INT 68
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: LIST
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: LIST
63317: LIST
63318: LIST
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: ST_TO_ADDR
63350: GO 63543
63352: LD_INT 3
63354: DOUBLE
63355: EQUAL
63356: IFTRUE 63360
63358: GO 63542
63360: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63361: LD_ADDR_VAR 0 4
63365: PUSH
63366: LD_INT 46
63368: PUSH
63369: LD_INT 47
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: LD_INT 2
63377: PUSH
63378: LD_INT 11
63380: PUSH
63381: LD_INT 9
63383: PUSH
63384: LD_INT 20
63386: PUSH
63387: LD_INT 19
63389: PUSH
63390: LD_INT 21
63392: PUSH
63393: LD_INT 24
63395: PUSH
63396: LD_INT 22
63398: PUSH
63399: LD_INT 25
63401: PUSH
63402: LD_INT 28
63404: PUSH
63405: LD_INT 29
63407: PUSH
63408: LD_INT 30
63410: PUSH
63411: LD_INT 31
63413: PUSH
63414: LD_INT 37
63416: PUSH
63417: LD_INT 38
63419: PUSH
63420: LD_INT 32
63422: PUSH
63423: LD_INT 27
63425: PUSH
63426: LD_INT 33
63428: PUSH
63429: LD_INT 69
63431: PUSH
63432: LD_INT 39
63434: PUSH
63435: LD_INT 34
63437: PUSH
63438: LD_INT 40
63440: PUSH
63441: LD_INT 71
63443: PUSH
63444: LD_INT 23
63446: PUSH
63447: LD_INT 44
63449: PUSH
63450: LD_INT 48
63452: PUSH
63453: LD_INT 49
63455: PUSH
63456: LD_INT 50
63458: PUSH
63459: LD_INT 51
63461: PUSH
63462: LD_INT 52
63464: PUSH
63465: LD_INT 53
63467: PUSH
63468: LD_INT 54
63470: PUSH
63471: LD_INT 55
63473: PUSH
63474: LD_INT 56
63476: PUSH
63477: LD_INT 57
63479: PUSH
63480: LD_INT 58
63482: PUSH
63483: LD_INT 59
63485: PUSH
63486: LD_INT 63
63488: PUSH
63489: LD_INT 64
63491: PUSH
63492: LD_INT 65
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: LIST
63510: LIST
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: LIST
63519: LIST
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: LIST
63529: LIST
63530: LIST
63531: LIST
63532: LIST
63533: LIST
63534: LIST
63535: LIST
63536: LIST
63537: LIST
63538: LIST
63539: ST_TO_ADDR
63540: GO 63543
63542: POP
// if state > - 1 and state < 3 then
63543: LD_VAR 0 3
63547: PUSH
63548: LD_INT 1
63550: NEG
63551: GREATER
63552: PUSH
63553: LD_VAR 0 3
63557: PUSH
63558: LD_INT 3
63560: LESS
63561: AND
63562: IFFALSE 63619
// for i in result do
63564: LD_ADDR_VAR 0 5
63568: PUSH
63569: LD_VAR 0 4
63573: PUSH
63574: FOR_IN
63575: IFFALSE 63617
// if GetTech ( i , side ) <> state then
63577: LD_VAR 0 5
63581: PPUSH
63582: LD_VAR 0 1
63586: PPUSH
63587: CALL_OW 321
63591: PUSH
63592: LD_VAR 0 3
63596: NONEQUAL
63597: IFFALSE 63615
// result := result diff i ;
63599: LD_ADDR_VAR 0 4
63603: PUSH
63604: LD_VAR 0 4
63608: PUSH
63609: LD_VAR 0 5
63613: DIFF
63614: ST_TO_ADDR
63615: GO 63574
63617: POP
63618: POP
// end ;
63619: LD_VAR 0 4
63623: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63624: LD_INT 0
63626: PPUSH
63627: PPUSH
63628: PPUSH
// result := true ;
63629: LD_ADDR_VAR 0 3
63633: PUSH
63634: LD_INT 1
63636: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63637: LD_ADDR_VAR 0 5
63641: PUSH
63642: LD_VAR 0 2
63646: PPUSH
63647: CALL_OW 480
63651: ST_TO_ADDR
// if not tmp then
63652: LD_VAR 0 5
63656: NOT
63657: IFFALSE 63661
// exit ;
63659: GO 63710
// for i in tmp do
63661: LD_ADDR_VAR 0 4
63665: PUSH
63666: LD_VAR 0 5
63670: PUSH
63671: FOR_IN
63672: IFFALSE 63708
// if GetTech ( i , side ) <> state_researched then
63674: LD_VAR 0 4
63678: PPUSH
63679: LD_VAR 0 1
63683: PPUSH
63684: CALL_OW 321
63688: PUSH
63689: LD_INT 2
63691: NONEQUAL
63692: IFFALSE 63706
// begin result := false ;
63694: LD_ADDR_VAR 0 3
63698: PUSH
63699: LD_INT 0
63701: ST_TO_ADDR
// exit ;
63702: POP
63703: POP
63704: GO 63710
// end ;
63706: GO 63671
63708: POP
63709: POP
// end ;
63710: LD_VAR 0 3
63714: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63715: LD_INT 0
63717: PPUSH
63718: PPUSH
63719: PPUSH
63720: PPUSH
63721: PPUSH
63722: PPUSH
63723: PPUSH
63724: PPUSH
63725: PPUSH
63726: PPUSH
63727: PPUSH
63728: PPUSH
63729: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63730: LD_VAR 0 1
63734: NOT
63735: PUSH
63736: LD_VAR 0 1
63740: PPUSH
63741: CALL_OW 257
63745: PUSH
63746: LD_INT 9
63748: NONEQUAL
63749: OR
63750: IFFALSE 63754
// exit ;
63752: GO 64327
// side := GetSide ( unit ) ;
63754: LD_ADDR_VAR 0 9
63758: PUSH
63759: LD_VAR 0 1
63763: PPUSH
63764: CALL_OW 255
63768: ST_TO_ADDR
// tech_space := tech_spacanom ;
63769: LD_ADDR_VAR 0 12
63773: PUSH
63774: LD_INT 29
63776: ST_TO_ADDR
// tech_time := tech_taurad ;
63777: LD_ADDR_VAR 0 13
63781: PUSH
63782: LD_INT 28
63784: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63785: LD_ADDR_VAR 0 11
63789: PUSH
63790: LD_VAR 0 1
63794: PPUSH
63795: CALL_OW 310
63799: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63800: LD_VAR 0 11
63804: PPUSH
63805: CALL_OW 247
63809: PUSH
63810: LD_INT 2
63812: EQUAL
63813: IFFALSE 63817
// exit ;
63815: GO 64327
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63817: LD_ADDR_VAR 0 8
63821: PUSH
63822: LD_INT 81
63824: PUSH
63825: LD_VAR 0 9
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 3
63836: PUSH
63837: LD_INT 21
63839: PUSH
63840: LD_INT 3
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: PPUSH
63855: CALL_OW 69
63859: ST_TO_ADDR
// if not tmp then
63860: LD_VAR 0 8
63864: NOT
63865: IFFALSE 63869
// exit ;
63867: GO 64327
// if in_unit then
63869: LD_VAR 0 11
63873: IFFALSE 63897
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63875: LD_ADDR_VAR 0 10
63879: PUSH
63880: LD_VAR 0 8
63884: PPUSH
63885: LD_VAR 0 11
63889: PPUSH
63890: CALL_OW 74
63894: ST_TO_ADDR
63895: GO 63917
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63897: LD_ADDR_VAR 0 10
63901: PUSH
63902: LD_VAR 0 8
63906: PPUSH
63907: LD_VAR 0 1
63911: PPUSH
63912: CALL_OW 74
63916: ST_TO_ADDR
// if not enemy then
63917: LD_VAR 0 10
63921: NOT
63922: IFFALSE 63926
// exit ;
63924: GO 64327
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
63926: LD_VAR 0 11
63930: PUSH
63931: LD_VAR 0 11
63935: PPUSH
63936: LD_VAR 0 10
63940: PPUSH
63941: CALL_OW 296
63945: PUSH
63946: LD_INT 13
63948: GREATER
63949: AND
63950: PUSH
63951: LD_VAR 0 1
63955: PPUSH
63956: LD_VAR 0 10
63960: PPUSH
63961: CALL_OW 296
63965: PUSH
63966: LD_INT 12
63968: GREATER
63969: OR
63970: IFFALSE 63974
// exit ;
63972: GO 64327
// missile := [ 1 ] ;
63974: LD_ADDR_VAR 0 14
63978: PUSH
63979: LD_INT 1
63981: PUSH
63982: EMPTY
63983: LIST
63984: ST_TO_ADDR
// if Researched ( side , tech_space ) then
63985: LD_VAR 0 9
63989: PPUSH
63990: LD_VAR 0 12
63994: PPUSH
63995: CALL_OW 325
63999: IFFALSE 64028
// missile := Insert ( missile , missile + 1 , 2 ) ;
64001: LD_ADDR_VAR 0 14
64005: PUSH
64006: LD_VAR 0 14
64010: PPUSH
64011: LD_VAR 0 14
64015: PUSH
64016: LD_INT 1
64018: PLUS
64019: PPUSH
64020: LD_INT 2
64022: PPUSH
64023: CALL_OW 2
64027: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64028: LD_VAR 0 9
64032: PPUSH
64033: LD_VAR 0 13
64037: PPUSH
64038: CALL_OW 325
64042: PUSH
64043: LD_VAR 0 10
64047: PPUSH
64048: CALL_OW 255
64052: PPUSH
64053: LD_VAR 0 13
64057: PPUSH
64058: CALL_OW 325
64062: NOT
64063: AND
64064: IFFALSE 64093
// missile := Insert ( missile , missile + 1 , 3 ) ;
64066: LD_ADDR_VAR 0 14
64070: PUSH
64071: LD_VAR 0 14
64075: PPUSH
64076: LD_VAR 0 14
64080: PUSH
64081: LD_INT 1
64083: PLUS
64084: PPUSH
64085: LD_INT 3
64087: PPUSH
64088: CALL_OW 2
64092: ST_TO_ADDR
// if missile < 2 then
64093: LD_VAR 0 14
64097: PUSH
64098: LD_INT 2
64100: LESS
64101: IFFALSE 64105
// exit ;
64103: GO 64327
// x := GetX ( enemy ) ;
64105: LD_ADDR_VAR 0 4
64109: PUSH
64110: LD_VAR 0 10
64114: PPUSH
64115: CALL_OW 250
64119: ST_TO_ADDR
// y := GetY ( enemy ) ;
64120: LD_ADDR_VAR 0 5
64124: PUSH
64125: LD_VAR 0 10
64129: PPUSH
64130: CALL_OW 251
64134: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64135: LD_ADDR_VAR 0 6
64139: PUSH
64140: LD_VAR 0 4
64144: PUSH
64145: LD_INT 1
64147: NEG
64148: PPUSH
64149: LD_INT 1
64151: PPUSH
64152: CALL_OW 12
64156: PLUS
64157: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64158: LD_ADDR_VAR 0 7
64162: PUSH
64163: LD_VAR 0 5
64167: PUSH
64168: LD_INT 1
64170: NEG
64171: PPUSH
64172: LD_INT 1
64174: PPUSH
64175: CALL_OW 12
64179: PLUS
64180: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64181: LD_VAR 0 6
64185: PPUSH
64186: LD_VAR 0 7
64190: PPUSH
64191: CALL_OW 488
64195: NOT
64196: IFFALSE 64218
// begin _x := x ;
64198: LD_ADDR_VAR 0 6
64202: PUSH
64203: LD_VAR 0 4
64207: ST_TO_ADDR
// _y := y ;
64208: LD_ADDR_VAR 0 7
64212: PUSH
64213: LD_VAR 0 5
64217: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64218: LD_ADDR_VAR 0 3
64222: PUSH
64223: LD_INT 1
64225: PPUSH
64226: LD_VAR 0 14
64230: PPUSH
64231: CALL_OW 12
64235: ST_TO_ADDR
// case i of 1 :
64236: LD_VAR 0 3
64240: PUSH
64241: LD_INT 1
64243: DOUBLE
64244: EQUAL
64245: IFTRUE 64249
64247: GO 64266
64249: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64250: LD_VAR 0 1
64254: PPUSH
64255: LD_VAR 0 10
64259: PPUSH
64260: CALL_OW 115
64264: GO 64327
64266: LD_INT 2
64268: DOUBLE
64269: EQUAL
64270: IFTRUE 64274
64272: GO 64296
64274: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64275: LD_VAR 0 1
64279: PPUSH
64280: LD_VAR 0 6
64284: PPUSH
64285: LD_VAR 0 7
64289: PPUSH
64290: CALL_OW 153
64294: GO 64327
64296: LD_INT 3
64298: DOUBLE
64299: EQUAL
64300: IFTRUE 64304
64302: GO 64326
64304: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64305: LD_VAR 0 1
64309: PPUSH
64310: LD_VAR 0 6
64314: PPUSH
64315: LD_VAR 0 7
64319: PPUSH
64320: CALL_OW 154
64324: GO 64327
64326: POP
// end ;
64327: LD_VAR 0 2
64331: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64332: LD_INT 0
64334: PPUSH
64335: PPUSH
64336: PPUSH
64337: PPUSH
64338: PPUSH
64339: PPUSH
// if not unit or not building then
64340: LD_VAR 0 1
64344: NOT
64345: PUSH
64346: LD_VAR 0 2
64350: NOT
64351: OR
64352: IFFALSE 64356
// exit ;
64354: GO 64514
// x := GetX ( building ) ;
64356: LD_ADDR_VAR 0 5
64360: PUSH
64361: LD_VAR 0 2
64365: PPUSH
64366: CALL_OW 250
64370: ST_TO_ADDR
// y := GetY ( building ) ;
64371: LD_ADDR_VAR 0 6
64375: PUSH
64376: LD_VAR 0 2
64380: PPUSH
64381: CALL_OW 251
64385: ST_TO_ADDR
// for i = 0 to 5 do
64386: LD_ADDR_VAR 0 4
64390: PUSH
64391: DOUBLE
64392: LD_INT 0
64394: DEC
64395: ST_TO_ADDR
64396: LD_INT 5
64398: PUSH
64399: FOR_TO
64400: IFFALSE 64512
// begin _x := ShiftX ( x , i , 3 ) ;
64402: LD_ADDR_VAR 0 7
64406: PUSH
64407: LD_VAR 0 5
64411: PPUSH
64412: LD_VAR 0 4
64416: PPUSH
64417: LD_INT 3
64419: PPUSH
64420: CALL_OW 272
64424: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64425: LD_ADDR_VAR 0 8
64429: PUSH
64430: LD_VAR 0 6
64434: PPUSH
64435: LD_VAR 0 4
64439: PPUSH
64440: LD_INT 3
64442: PPUSH
64443: CALL_OW 273
64447: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64448: LD_VAR 0 7
64452: PPUSH
64453: LD_VAR 0 8
64457: PPUSH
64458: CALL_OW 488
64462: NOT
64463: IFFALSE 64467
// continue ;
64465: GO 64399
// if HexInfo ( _x , _y ) = 0 then
64467: LD_VAR 0 7
64471: PPUSH
64472: LD_VAR 0 8
64476: PPUSH
64477: CALL_OW 428
64481: PUSH
64482: LD_INT 0
64484: EQUAL
64485: IFFALSE 64510
// begin ComMoveXY ( unit , _x , _y ) ;
64487: LD_VAR 0 1
64491: PPUSH
64492: LD_VAR 0 7
64496: PPUSH
64497: LD_VAR 0 8
64501: PPUSH
64502: CALL_OW 111
// exit ;
64506: POP
64507: POP
64508: GO 64514
// end ; end ;
64510: GO 64399
64512: POP
64513: POP
// end ;
64514: LD_VAR 0 3
64518: RET
// export function ScanBase ( side , base_area ) ; begin
64519: LD_INT 0
64521: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64522: LD_ADDR_VAR 0 3
64526: PUSH
64527: LD_VAR 0 2
64531: PPUSH
64532: LD_INT 81
64534: PUSH
64535: LD_VAR 0 1
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PPUSH
64544: CALL_OW 70
64548: ST_TO_ADDR
// end ;
64549: LD_VAR 0 3
64553: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
64554: LD_INT 0
64556: PPUSH
64557: PPUSH
64558: PPUSH
64559: PPUSH
64560: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
64561: LD_VAR 0 1
64565: NOT
64566: PUSH
64567: LD_EXP 99
64571: PUSH
64572: LD_VAR 0 1
64576: ARRAY
64577: NOT
64578: OR
64579: PUSH
64580: LD_VAR 0 2
64584: NOT
64585: OR
64586: PUSH
64587: LD_VAR 0 3
64591: NOT
64592: OR
64593: IFFALSE 64597
// exit ;
64595: GO 65047
// side := mc_sides [ base ] ;
64597: LD_ADDR_VAR 0 6
64601: PUSH
64602: LD_EXP 125
64606: PUSH
64607: LD_VAR 0 1
64611: ARRAY
64612: ST_TO_ADDR
// if not side then
64613: LD_VAR 0 6
64617: NOT
64618: IFFALSE 64622
// exit ;
64620: GO 65047
// for i in solds do
64622: LD_ADDR_VAR 0 7
64626: PUSH
64627: LD_VAR 0 2
64631: PUSH
64632: FOR_IN
64633: IFFALSE 64694
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
64635: LD_VAR 0 7
64639: PPUSH
64640: CALL_OW 310
64644: PPUSH
64645: CALL_OW 266
64649: PUSH
64650: LD_INT 32
64652: PUSH
64653: LD_INT 31
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: IN
64660: IFFALSE 64680
// solds := solds diff i else
64662: LD_ADDR_VAR 0 2
64666: PUSH
64667: LD_VAR 0 2
64671: PUSH
64672: LD_VAR 0 7
64676: DIFF
64677: ST_TO_ADDR
64678: GO 64692
// SetTag ( i , 18 ) ;
64680: LD_VAR 0 7
64684: PPUSH
64685: LD_INT 18
64687: PPUSH
64688: CALL_OW 109
64692: GO 64632
64694: POP
64695: POP
// if not solds then
64696: LD_VAR 0 2
64700: NOT
64701: IFFALSE 64705
// exit ;
64703: GO 65047
// repeat wait ( 0 0$1 ) ;
64705: LD_INT 35
64707: PPUSH
64708: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
64712: LD_ADDR_VAR 0 5
64716: PUSH
64717: LD_VAR 0 6
64721: PPUSH
64722: LD_VAR 0 3
64726: PPUSH
64727: CALL 64519 0 2
64731: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
64732: LD_VAR 0 5
64736: NOT
64737: PUSH
64738: LD_VAR 0 5
64742: PUSH
64743: LD_INT 3
64745: GREATER
64746: OR
64747: PUSH
64748: LD_EXP 121
64752: PUSH
64753: LD_VAR 0 1
64757: ARRAY
64758: OR
64759: IFFALSE 64800
// begin for i in solds do
64761: LD_ADDR_VAR 0 7
64765: PUSH
64766: LD_VAR 0 2
64770: PUSH
64771: FOR_IN
64772: IFFALSE 64796
// if HasTask ( i ) then
64774: LD_VAR 0 7
64778: PPUSH
64779: CALL_OW 314
64783: IFFALSE 64794
// ComStop ( i ) ;
64785: LD_VAR 0 7
64789: PPUSH
64790: CALL_OW 141
64794: GO 64771
64796: POP
64797: POP
// break ;
64798: GO 65035
// end ; for i in solds do
64800: LD_ADDR_VAR 0 7
64804: PUSH
64805: LD_VAR 0 2
64809: PUSH
64810: FOR_IN
64811: IFFALSE 65027
// begin if IsInUnit ( i ) then
64813: LD_VAR 0 7
64817: PPUSH
64818: CALL_OW 310
64822: IFFALSE 64833
// ComExitBuilding ( i ) ;
64824: LD_VAR 0 7
64828: PPUSH
64829: CALL_OW 122
// if GetLives ( i ) > 333 then
64833: LD_VAR 0 7
64837: PPUSH
64838: CALL_OW 256
64842: PUSH
64843: LD_INT 333
64845: GREATER
64846: IFFALSE 64874
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
64848: LD_VAR 0 7
64852: PPUSH
64853: LD_VAR 0 5
64857: PPUSH
64858: LD_VAR 0 7
64862: PPUSH
64863: CALL_OW 74
64867: PPUSH
64868: CALL_OW 115
64872: GO 65025
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
64874: LD_ADDR_VAR 0 8
64878: PUSH
64879: LD_EXP 99
64883: PUSH
64884: LD_VAR 0 1
64888: ARRAY
64889: PPUSH
64890: LD_INT 2
64892: PUSH
64893: LD_INT 30
64895: PUSH
64896: LD_INT 0
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 30
64905: PUSH
64906: LD_INT 1
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 30
64915: PUSH
64916: LD_INT 6
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: PPUSH
64929: CALL_OW 72
64933: PPUSH
64934: LD_VAR 0 7
64938: PPUSH
64939: CALL_OW 74
64943: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
64944: LD_VAR 0 7
64948: PPUSH
64949: LD_VAR 0 8
64953: PPUSH
64954: CALL_OW 250
64958: PPUSH
64959: LD_INT 3
64961: PPUSH
64962: LD_INT 5
64964: PPUSH
64965: CALL_OW 272
64969: PPUSH
64970: LD_VAR 0 8
64974: PPUSH
64975: CALL_OW 251
64979: PPUSH
64980: LD_INT 3
64982: PPUSH
64983: LD_INT 5
64985: PPUSH
64986: CALL_OW 273
64990: PPUSH
64991: CALL_OW 111
// SetTag ( i , 0 ) ;
64995: LD_VAR 0 7
64999: PPUSH
65000: LD_INT 0
65002: PPUSH
65003: CALL_OW 109
// solds := solds diff i ;
65007: LD_ADDR_VAR 0 2
65011: PUSH
65012: LD_VAR 0 2
65016: PUSH
65017: LD_VAR 0 7
65021: DIFF
65022: ST_TO_ADDR
// continue ;
65023: GO 64810
// end ; end ;
65025: GO 64810
65027: POP
65028: POP
// until solds ;
65029: LD_VAR 0 2
65033: IFFALSE 64705
// MC_Reset ( base , 18 ) ;
65035: LD_VAR 0 1
65039: PPUSH
65040: LD_INT 18
65042: PPUSH
65043: CALL 37767 0 2
// end ;
65047: LD_VAR 0 4
65051: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65052: LD_INT 0
65054: PPUSH
65055: PPUSH
65056: PPUSH
65057: PPUSH
65058: PPUSH
65059: PPUSH
65060: PPUSH
65061: PPUSH
65062: PPUSH
65063: PPUSH
65064: PPUSH
65065: PPUSH
65066: PPUSH
65067: PPUSH
65068: PPUSH
65069: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65070: LD_ADDR_VAR 0 12
65074: PUSH
65075: LD_EXP 99
65079: PUSH
65080: LD_VAR 0 1
65084: ARRAY
65085: PPUSH
65086: LD_INT 25
65088: PUSH
65089: LD_INT 3
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: PPUSH
65096: CALL_OW 72
65100: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65101: LD_ADDR_VAR 0 8
65105: PUSH
65106: LD_EXP 99
65110: PUSH
65111: LD_VAR 0 1
65115: ARRAY
65116: PPUSH
65117: LD_INT 2
65119: PUSH
65120: LD_INT 25
65122: PUSH
65123: LD_INT 1
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PUSH
65130: LD_INT 25
65132: PUSH
65133: LD_INT 5
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PUSH
65140: LD_INT 25
65142: PUSH
65143: LD_INT 8
65145: PUSH
65146: EMPTY
65147: LIST
65148: LIST
65149: PUSH
65150: LD_INT 25
65152: PUSH
65153: LD_INT 9
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: PPUSH
65167: CALL_OW 72
65171: ST_TO_ADDR
// if not defenders and not solds then
65172: LD_VAR 0 2
65176: NOT
65177: PUSH
65178: LD_VAR 0 8
65182: NOT
65183: AND
65184: IFFALSE 65188
// exit ;
65186: GO 66554
// depot_under_attack := false ;
65188: LD_ADDR_VAR 0 16
65192: PUSH
65193: LD_INT 0
65195: ST_TO_ADDR
// sold_defenders := [ ] ;
65196: LD_ADDR_VAR 0 17
65200: PUSH
65201: EMPTY
65202: ST_TO_ADDR
// if mechs then
65203: LD_VAR 0 12
65207: IFFALSE 65336
// for i in defenders do
65209: LD_ADDR_VAR 0 5
65213: PUSH
65214: LD_VAR 0 2
65218: PUSH
65219: FOR_IN
65220: IFFALSE 65334
// begin SetTag ( i , 20 ) ;
65222: LD_VAR 0 5
65226: PPUSH
65227: LD_INT 20
65229: PPUSH
65230: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65234: LD_VAR 0 5
65238: PPUSH
65239: CALL_OW 263
65243: PUSH
65244: LD_INT 1
65246: EQUAL
65247: PUSH
65248: LD_VAR 0 5
65252: PPUSH
65253: CALL_OW 311
65257: NOT
65258: AND
65259: PUSH
65260: LD_VAR 0 12
65264: AND
65265: IFFALSE 65332
// begin un := mechs [ 1 ] ;
65267: LD_ADDR_VAR 0 10
65271: PUSH
65272: LD_VAR 0 12
65276: PUSH
65277: LD_INT 1
65279: ARRAY
65280: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65281: LD_VAR 0 10
65285: PPUSH
65286: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65290: LD_VAR 0 10
65294: PPUSH
65295: LD_VAR 0 5
65299: PPUSH
65300: CALL_OW 180
// SetTag ( un , 19 ) ;
65304: LD_VAR 0 10
65308: PPUSH
65309: LD_INT 19
65311: PPUSH
65312: CALL_OW 109
// mechs := mechs diff un ;
65316: LD_ADDR_VAR 0 12
65320: PUSH
65321: LD_VAR 0 12
65325: PUSH
65326: LD_VAR 0 10
65330: DIFF
65331: ST_TO_ADDR
// end ; end ;
65332: GO 65219
65334: POP
65335: POP
// if solds then
65336: LD_VAR 0 8
65340: IFFALSE 65399
// for i in solds do
65342: LD_ADDR_VAR 0 5
65346: PUSH
65347: LD_VAR 0 8
65351: PUSH
65352: FOR_IN
65353: IFFALSE 65397
// if not GetTag ( i ) then
65355: LD_VAR 0 5
65359: PPUSH
65360: CALL_OW 110
65364: NOT
65365: IFFALSE 65395
// begin defenders := defenders union i ;
65367: LD_ADDR_VAR 0 2
65371: PUSH
65372: LD_VAR 0 2
65376: PUSH
65377: LD_VAR 0 5
65381: UNION
65382: ST_TO_ADDR
// SetTag ( i , 18 ) ;
65383: LD_VAR 0 5
65387: PPUSH
65388: LD_INT 18
65390: PPUSH
65391: CALL_OW 109
// end ;
65395: GO 65352
65397: POP
65398: POP
// repeat wait ( 0 0$1 ) ;
65399: LD_INT 35
65401: PPUSH
65402: CALL_OW 67
// enemy := mc_scan [ base ] ;
65406: LD_ADDR_VAR 0 3
65410: PUSH
65411: LD_EXP 122
65415: PUSH
65416: LD_VAR 0 1
65420: ARRAY
65421: ST_TO_ADDR
// for i in defenders do
65422: LD_ADDR_VAR 0 5
65426: PUSH
65427: LD_VAR 0 2
65431: PUSH
65432: FOR_IN
65433: IFFALSE 66118
// begin e := NearestUnitToUnit ( enemy , i ) ;
65435: LD_ADDR_VAR 0 13
65439: PUSH
65440: LD_VAR 0 3
65444: PPUSH
65445: LD_VAR 0 5
65449: PPUSH
65450: CALL_OW 74
65454: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
65455: LD_ADDR_VAR 0 16
65459: PUSH
65460: LD_EXP 99
65464: PUSH
65465: LD_VAR 0 1
65469: ARRAY
65470: PPUSH
65471: LD_INT 2
65473: PUSH
65474: LD_INT 30
65476: PUSH
65477: LD_INT 0
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 30
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: LIST
65498: PPUSH
65499: CALL_OW 72
65503: NOT
65504: PUSH
65505: LD_EXP 99
65509: PUSH
65510: LD_VAR 0 1
65514: ARRAY
65515: PPUSH
65516: LD_INT 2
65518: PUSH
65519: LD_INT 30
65521: PUSH
65522: LD_INT 0
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 30
65531: PUSH
65532: LD_INT 1
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: LIST
65543: PPUSH
65544: CALL_OW 72
65548: PPUSH
65549: CALL_OW 256
65553: PUSH
65554: LD_INT 600
65556: LESS
65557: OR
65558: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
65559: LD_VAR 0 5
65563: PPUSH
65564: CALL_OW 247
65568: PUSH
65569: LD_INT 2
65571: DOUBLE
65572: EQUAL
65573: IFTRUE 65577
65575: GO 65824
65577: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
65578: LD_VAR 0 5
65582: PPUSH
65583: CALL_OW 256
65587: PUSH
65588: LD_INT 650
65590: GREATER
65591: PUSH
65592: LD_VAR 0 5
65596: PPUSH
65597: LD_VAR 0 13
65601: PPUSH
65602: CALL_OW 296
65606: PUSH
65607: LD_INT 40
65609: LESS
65610: AND
65611: IFFALSE 65629
// ComAttackUnit ( i , e ) else
65613: LD_VAR 0 5
65617: PPUSH
65618: LD_VAR 0 13
65622: PPUSH
65623: CALL_OW 115
65627: GO 65707
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
65629: LD_VAR 0 5
65633: PPUSH
65634: LD_VAR 0 13
65638: PPUSH
65639: CALL_OW 296
65643: PUSH
65644: LD_INT 30
65646: GREATEREQUAL
65647: PUSH
65648: LD_VAR 0 5
65652: PPUSH
65653: CALL_OW 256
65657: PUSH
65658: LD_INT 650
65660: LESSEQUAL
65661: OR
65662: PUSH
65663: LD_VAR 0 5
65667: PPUSH
65668: LD_EXP 123
65672: PUSH
65673: LD_VAR 0 1
65677: ARRAY
65678: PPUSH
65679: CALL_OW 308
65683: NOT
65684: AND
65685: IFFALSE 65707
// ComMoveToArea ( i , mc_parking [ base ] ) ;
65687: LD_VAR 0 5
65691: PPUSH
65692: LD_EXP 123
65696: PUSH
65697: LD_VAR 0 1
65701: ARRAY
65702: PPUSH
65703: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
65707: LD_VAR 0 5
65711: PPUSH
65712: CALL_OW 256
65716: PUSH
65717: LD_INT 998
65719: LESS
65720: PUSH
65721: LD_VAR 0 5
65725: PPUSH
65726: CALL_OW 263
65730: PUSH
65731: LD_INT 1
65733: EQUAL
65734: AND
65735: PUSH
65736: LD_VAR 0 5
65740: PPUSH
65741: CALL_OW 311
65745: AND
65746: PUSH
65747: LD_VAR 0 5
65751: PPUSH
65752: LD_EXP 123
65756: PUSH
65757: LD_VAR 0 1
65761: ARRAY
65762: PPUSH
65763: CALL_OW 308
65767: AND
65768: IFFALSE 65822
// begin mech := IsDrivenBy ( i ) ;
65770: LD_ADDR_VAR 0 9
65774: PUSH
65775: LD_VAR 0 5
65779: PPUSH
65780: CALL_OW 311
65784: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
65785: LD_VAR 0 9
65789: PPUSH
65790: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
65794: LD_VAR 0 9
65798: PPUSH
65799: LD_VAR 0 5
65803: PPUSH
65804: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
65808: LD_VAR 0 9
65812: PPUSH
65813: LD_VAR 0 5
65817: PPUSH
65818: CALL_OW 180
// end ; end ; unit_human :
65822: GO 66089
65824: LD_INT 1
65826: DOUBLE
65827: EQUAL
65828: IFTRUE 65832
65830: GO 66088
65832: POP
// begin b := IsInUnit ( i ) ;
65833: LD_ADDR_VAR 0 18
65837: PUSH
65838: LD_VAR 0 5
65842: PPUSH
65843: CALL_OW 310
65847: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
65848: LD_ADDR_VAR 0 19
65852: PUSH
65853: LD_VAR 0 18
65857: NOT
65858: PUSH
65859: LD_VAR 0 18
65863: PPUSH
65864: CALL_OW 266
65868: PUSH
65869: LD_INT 32
65871: PUSH
65872: LD_INT 31
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: IN
65879: OR
65880: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
65881: LD_VAR 0 16
65885: PUSH
65886: LD_VAR 0 2
65890: PPUSH
65891: LD_INT 21
65893: PUSH
65894: LD_INT 2
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PPUSH
65901: CALL_OW 72
65905: PUSH
65906: LD_INT 1
65908: LESSEQUAL
65909: OR
65910: PUSH
65911: LD_VAR 0 19
65915: AND
65916: PUSH
65917: LD_VAR 0 5
65921: PUSH
65922: LD_VAR 0 17
65926: IN
65927: NOT
65928: AND
65929: IFFALSE 66022
// begin if b then
65931: LD_VAR 0 18
65935: IFFALSE 65984
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
65937: LD_VAR 0 18
65941: PPUSH
65942: LD_VAR 0 3
65946: PPUSH
65947: LD_VAR 0 18
65951: PPUSH
65952: CALL_OW 74
65956: PPUSH
65957: CALL_OW 296
65961: PUSH
65962: LD_INT 10
65964: LESS
65965: PUSH
65966: LD_VAR 0 18
65970: PPUSH
65971: CALL_OW 461
65975: PUSH
65976: LD_INT 7
65978: NONEQUAL
65979: AND
65980: IFFALSE 65984
// continue ;
65982: GO 65432
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
65984: LD_ADDR_VAR 0 17
65988: PUSH
65989: LD_VAR 0 17
65993: PPUSH
65994: LD_VAR 0 17
65998: PUSH
65999: LD_INT 1
66001: PLUS
66002: PPUSH
66003: LD_VAR 0 5
66007: PPUSH
66008: CALL_OW 1
66012: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66013: LD_VAR 0 5
66017: PPUSH
66018: CALL_OW 122
// end ; if sold_defenders then
66022: LD_VAR 0 17
66026: IFFALSE 66086
// if i in sold_defenders then
66028: LD_VAR 0 5
66032: PUSH
66033: LD_VAR 0 17
66037: IN
66038: IFFALSE 66086
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66040: LD_VAR 0 5
66044: PPUSH
66045: CALL_OW 314
66049: NOT
66050: PUSH
66051: LD_VAR 0 5
66055: PPUSH
66056: LD_VAR 0 13
66060: PPUSH
66061: CALL_OW 296
66065: PUSH
66066: LD_INT 30
66068: LESS
66069: AND
66070: IFFALSE 66086
// ComAttackUnit ( i , e ) ;
66072: LD_VAR 0 5
66076: PPUSH
66077: LD_VAR 0 13
66081: PPUSH
66082: CALL_OW 115
// end ; end ; end ;
66086: GO 66089
66088: POP
// if IsDead ( i ) then
66089: LD_VAR 0 5
66093: PPUSH
66094: CALL_OW 301
66098: IFFALSE 66116
// defenders := defenders diff i ;
66100: LD_ADDR_VAR 0 2
66104: PUSH
66105: LD_VAR 0 2
66109: PUSH
66110: LD_VAR 0 5
66114: DIFF
66115: ST_TO_ADDR
// end ;
66116: GO 65432
66118: POP
66119: POP
// until not enemy or not defenders ;
66120: LD_VAR 0 3
66124: NOT
66125: PUSH
66126: LD_VAR 0 2
66130: NOT
66131: OR
66132: IFFALSE 65399
// MC_Reset ( base , 18 ) ;
66134: LD_VAR 0 1
66138: PPUSH
66139: LD_INT 18
66141: PPUSH
66142: CALL 37767 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66146: LD_ADDR_VAR 0 2
66150: PUSH
66151: LD_VAR 0 2
66155: PUSH
66156: LD_VAR 0 2
66160: PPUSH
66161: LD_INT 2
66163: PUSH
66164: LD_INT 25
66166: PUSH
66167: LD_INT 1
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 25
66176: PUSH
66177: LD_INT 5
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 25
66186: PUSH
66187: LD_INT 8
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 25
66196: PUSH
66197: LD_INT 9
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: PPUSH
66211: CALL_OW 72
66215: DIFF
66216: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66217: LD_VAR 0 3
66221: NOT
66222: PUSH
66223: LD_VAR 0 2
66227: PPUSH
66228: LD_INT 21
66230: PUSH
66231: LD_INT 2
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PPUSH
66238: CALL_OW 72
66242: AND
66243: IFFALSE 66505
// begin tmp := FilterByTag ( defenders , 19 ) ;
66245: LD_ADDR_VAR 0 11
66249: PUSH
66250: LD_VAR 0 2
66254: PPUSH
66255: LD_INT 19
66257: PPUSH
66258: CALL 102891 0 2
66262: ST_TO_ADDR
// if tmp then
66263: LD_VAR 0 11
66267: IFFALSE 66337
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66269: LD_ADDR_VAR 0 11
66273: PUSH
66274: LD_VAR 0 11
66278: PPUSH
66279: LD_INT 25
66281: PUSH
66282: LD_INT 3
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PPUSH
66289: CALL_OW 72
66293: ST_TO_ADDR
// if tmp then
66294: LD_VAR 0 11
66298: IFFALSE 66337
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66300: LD_ADDR_EXP 111
66304: PUSH
66305: LD_EXP 111
66309: PPUSH
66310: LD_VAR 0 1
66314: PPUSH
66315: LD_EXP 111
66319: PUSH
66320: LD_VAR 0 1
66324: ARRAY
66325: PUSH
66326: LD_VAR 0 11
66330: UNION
66331: PPUSH
66332: CALL_OW 1
66336: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
66337: LD_VAR 0 1
66341: PPUSH
66342: LD_INT 19
66344: PPUSH
66345: CALL 37767 0 2
// repeat wait ( 0 0$1 ) ;
66349: LD_INT 35
66351: PPUSH
66352: CALL_OW 67
// for i in defenders do
66356: LD_ADDR_VAR 0 5
66360: PUSH
66361: LD_VAR 0 2
66365: PUSH
66366: FOR_IN
66367: IFFALSE 66456
// begin if not IsInArea ( i , mc_parking [ base ] ) then
66369: LD_VAR 0 5
66373: PPUSH
66374: LD_EXP 123
66378: PUSH
66379: LD_VAR 0 1
66383: ARRAY
66384: PPUSH
66385: CALL_OW 308
66389: NOT
66390: IFFALSE 66414
// ComMoveToArea ( i , mc_parking [ base ] ) else
66392: LD_VAR 0 5
66396: PPUSH
66397: LD_EXP 123
66401: PUSH
66402: LD_VAR 0 1
66406: ARRAY
66407: PPUSH
66408: CALL_OW 113
66412: GO 66454
// if GetControl ( i ) = control_manual then
66414: LD_VAR 0 5
66418: PPUSH
66419: CALL_OW 263
66423: PUSH
66424: LD_INT 1
66426: EQUAL
66427: IFFALSE 66454
// if IsDrivenBy ( i ) then
66429: LD_VAR 0 5
66433: PPUSH
66434: CALL_OW 311
66438: IFFALSE 66454
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
66440: LD_VAR 0 5
66444: PPUSH
66445: CALL_OW 311
66449: PPUSH
66450: CALL_OW 121
// end ;
66454: GO 66366
66456: POP
66457: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
66458: LD_VAR 0 2
66462: PPUSH
66463: LD_INT 95
66465: PUSH
66466: LD_EXP 123
66470: PUSH
66471: LD_VAR 0 1
66475: ARRAY
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PPUSH
66481: CALL_OW 72
66485: PUSH
66486: LD_VAR 0 2
66490: EQUAL
66491: PUSH
66492: LD_EXP 122
66496: PUSH
66497: LD_VAR 0 1
66501: ARRAY
66502: OR
66503: IFFALSE 66349
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
66505: LD_ADDR_EXP 121
66509: PUSH
66510: LD_EXP 121
66514: PPUSH
66515: LD_VAR 0 1
66519: PPUSH
66520: LD_EXP 121
66524: PUSH
66525: LD_VAR 0 1
66529: ARRAY
66530: PUSH
66531: LD_VAR 0 2
66535: UNION
66536: PPUSH
66537: CALL_OW 1
66541: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
66542: LD_VAR 0 1
66546: PPUSH
66547: LD_INT 20
66549: PPUSH
66550: CALL 37767 0 2
// end ;
66554: LD_VAR 0 4
66558: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66559: LD_INT 0
66561: PPUSH
66562: PPUSH
66563: PPUSH
66564: PPUSH
// result := false ;
66565: LD_ADDR_VAR 0 2
66569: PUSH
66570: LD_INT 0
66572: ST_TO_ADDR
// side := GetSide ( unit ) ;
66573: LD_ADDR_VAR 0 3
66577: PUSH
66578: LD_VAR 0 1
66582: PPUSH
66583: CALL_OW 255
66587: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66588: LD_ADDR_VAR 0 4
66592: PUSH
66593: LD_VAR 0 1
66597: PPUSH
66598: CALL_OW 248
66602: ST_TO_ADDR
// case nat of 1 :
66603: LD_VAR 0 4
66607: PUSH
66608: LD_INT 1
66610: DOUBLE
66611: EQUAL
66612: IFTRUE 66616
66614: GO 66627
66616: POP
// tech := tech_lassight ; 2 :
66617: LD_ADDR_VAR 0 5
66621: PUSH
66622: LD_INT 12
66624: ST_TO_ADDR
66625: GO 66666
66627: LD_INT 2
66629: DOUBLE
66630: EQUAL
66631: IFTRUE 66635
66633: GO 66646
66635: POP
// tech := tech_mortar ; 3 :
66636: LD_ADDR_VAR 0 5
66640: PUSH
66641: LD_INT 41
66643: ST_TO_ADDR
66644: GO 66666
66646: LD_INT 3
66648: DOUBLE
66649: EQUAL
66650: IFTRUE 66654
66652: GO 66665
66654: POP
// tech := tech_bazooka ; end ;
66655: LD_ADDR_VAR 0 5
66659: PUSH
66660: LD_INT 44
66662: ST_TO_ADDR
66663: GO 66666
66665: POP
// if Researched ( side , tech ) then
66666: LD_VAR 0 3
66670: PPUSH
66671: LD_VAR 0 5
66675: PPUSH
66676: CALL_OW 325
66680: IFFALSE 66707
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66682: LD_ADDR_VAR 0 2
66686: PUSH
66687: LD_INT 5
66689: PUSH
66690: LD_INT 8
66692: PUSH
66693: LD_INT 9
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: LIST
66700: PUSH
66701: LD_VAR 0 4
66705: ARRAY
66706: ST_TO_ADDR
// end ;
66707: LD_VAR 0 2
66711: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66712: LD_INT 0
66714: PPUSH
66715: PPUSH
66716: PPUSH
// if not mines then
66717: LD_VAR 0 2
66721: NOT
66722: IFFALSE 66726
// exit ;
66724: GO 66870
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66726: LD_ADDR_VAR 0 5
66730: PUSH
66731: LD_INT 81
66733: PUSH
66734: LD_VAR 0 1
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 3
66745: PUSH
66746: LD_INT 21
66748: PUSH
66749: LD_INT 3
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PPUSH
66764: CALL_OW 69
66768: ST_TO_ADDR
// for i in mines do
66769: LD_ADDR_VAR 0 4
66773: PUSH
66774: LD_VAR 0 2
66778: PUSH
66779: FOR_IN
66780: IFFALSE 66868
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66782: LD_VAR 0 4
66786: PUSH
66787: LD_INT 1
66789: ARRAY
66790: PPUSH
66791: LD_VAR 0 4
66795: PUSH
66796: LD_INT 2
66798: ARRAY
66799: PPUSH
66800: CALL_OW 458
66804: NOT
66805: IFFALSE 66809
// continue ;
66807: GO 66779
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66809: LD_VAR 0 4
66813: PUSH
66814: LD_INT 1
66816: ARRAY
66817: PPUSH
66818: LD_VAR 0 4
66822: PUSH
66823: LD_INT 2
66825: ARRAY
66826: PPUSH
66827: CALL_OW 428
66831: PUSH
66832: LD_VAR 0 5
66836: IN
66837: IFFALSE 66866
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66839: LD_VAR 0 4
66843: PUSH
66844: LD_INT 1
66846: ARRAY
66847: PPUSH
66848: LD_VAR 0 4
66852: PUSH
66853: LD_INT 2
66855: ARRAY
66856: PPUSH
66857: LD_VAR 0 1
66861: PPUSH
66862: CALL_OW 456
// end ;
66866: GO 66779
66868: POP
66869: POP
// end ;
66870: LD_VAR 0 3
66874: RET
// export function Count ( array ) ; var i ; begin
66875: LD_INT 0
66877: PPUSH
66878: PPUSH
// result := 0 ;
66879: LD_ADDR_VAR 0 2
66883: PUSH
66884: LD_INT 0
66886: ST_TO_ADDR
// for i in array do
66887: LD_ADDR_VAR 0 3
66891: PUSH
66892: LD_VAR 0 1
66896: PUSH
66897: FOR_IN
66898: IFFALSE 66922
// if i then
66900: LD_VAR 0 3
66904: IFFALSE 66920
// result := result + 1 ;
66906: LD_ADDR_VAR 0 2
66910: PUSH
66911: LD_VAR 0 2
66915: PUSH
66916: LD_INT 1
66918: PLUS
66919: ST_TO_ADDR
66920: GO 66897
66922: POP
66923: POP
// end ;
66924: LD_VAR 0 2
66928: RET
// export function IsEmpty ( building ) ; begin
66929: LD_INT 0
66931: PPUSH
// if not building then
66932: LD_VAR 0 1
66936: NOT
66937: IFFALSE 66941
// exit ;
66939: GO 66984
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66941: LD_ADDR_VAR 0 2
66945: PUSH
66946: LD_VAR 0 1
66950: PUSH
66951: LD_INT 22
66953: PUSH
66954: LD_VAR 0 1
66958: PPUSH
66959: CALL_OW 255
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 58
66970: PUSH
66971: EMPTY
66972: LIST
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PPUSH
66978: CALL_OW 69
66982: IN
66983: ST_TO_ADDR
// end ;
66984: LD_VAR 0 2
66988: RET
// export function IsNotFull ( building ) ; begin
66989: LD_INT 0
66991: PPUSH
// if not building then
66992: LD_VAR 0 1
66996: NOT
66997: IFFALSE 67001
// exit ;
66999: GO 67020
// result := UnitsInside ( building ) < 6 ;
67001: LD_ADDR_VAR 0 2
67005: PUSH
67006: LD_VAR 0 1
67010: PPUSH
67011: CALL_OW 313
67015: PUSH
67016: LD_INT 6
67018: LESS
67019: ST_TO_ADDR
// end ;
67020: LD_VAR 0 2
67024: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67025: LD_INT 0
67027: PPUSH
67028: PPUSH
67029: PPUSH
67030: PPUSH
// tmp := [ ] ;
67031: LD_ADDR_VAR 0 3
67035: PUSH
67036: EMPTY
67037: ST_TO_ADDR
// list := [ ] ;
67038: LD_ADDR_VAR 0 5
67042: PUSH
67043: EMPTY
67044: ST_TO_ADDR
// for i = 16 to 25 do
67045: LD_ADDR_VAR 0 4
67049: PUSH
67050: DOUBLE
67051: LD_INT 16
67053: DEC
67054: ST_TO_ADDR
67055: LD_INT 25
67057: PUSH
67058: FOR_TO
67059: IFFALSE 67132
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67061: LD_ADDR_VAR 0 3
67065: PUSH
67066: LD_VAR 0 3
67070: PUSH
67071: LD_INT 22
67073: PUSH
67074: LD_VAR 0 1
67078: PPUSH
67079: CALL_OW 255
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 91
67090: PUSH
67091: LD_VAR 0 1
67095: PUSH
67096: LD_INT 6
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 30
67106: PUSH
67107: LD_VAR 0 4
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: LIST
67120: PUSH
67121: EMPTY
67122: LIST
67123: PPUSH
67124: CALL_OW 69
67128: ADD
67129: ST_TO_ADDR
67130: GO 67058
67132: POP
67133: POP
// for i = 1 to tmp do
67134: LD_ADDR_VAR 0 4
67138: PUSH
67139: DOUBLE
67140: LD_INT 1
67142: DEC
67143: ST_TO_ADDR
67144: LD_VAR 0 3
67148: PUSH
67149: FOR_TO
67150: IFFALSE 67238
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67152: LD_ADDR_VAR 0 5
67156: PUSH
67157: LD_VAR 0 5
67161: PUSH
67162: LD_VAR 0 3
67166: PUSH
67167: LD_VAR 0 4
67171: ARRAY
67172: PPUSH
67173: CALL_OW 266
67177: PUSH
67178: LD_VAR 0 3
67182: PUSH
67183: LD_VAR 0 4
67187: ARRAY
67188: PPUSH
67189: CALL_OW 250
67193: PUSH
67194: LD_VAR 0 3
67198: PUSH
67199: LD_VAR 0 4
67203: ARRAY
67204: PPUSH
67205: CALL_OW 251
67209: PUSH
67210: LD_VAR 0 3
67214: PUSH
67215: LD_VAR 0 4
67219: ARRAY
67220: PPUSH
67221: CALL_OW 254
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: PUSH
67232: EMPTY
67233: LIST
67234: ADD
67235: ST_TO_ADDR
67236: GO 67149
67238: POP
67239: POP
// result := list ;
67240: LD_ADDR_VAR 0 2
67244: PUSH
67245: LD_VAR 0 5
67249: ST_TO_ADDR
// end ;
67250: LD_VAR 0 2
67254: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67255: LD_INT 0
67257: PPUSH
67258: PPUSH
67259: PPUSH
67260: PPUSH
67261: PPUSH
67262: PPUSH
67263: PPUSH
// if not factory then
67264: LD_VAR 0 1
67268: NOT
67269: IFFALSE 67273
// exit ;
67271: GO 67798
// if control = control_apeman then
67273: LD_VAR 0 4
67277: PUSH
67278: LD_INT 5
67280: EQUAL
67281: IFFALSE 67390
// begin tmp := UnitsInside ( factory ) ;
67283: LD_ADDR_VAR 0 8
67287: PUSH
67288: LD_VAR 0 1
67292: PPUSH
67293: CALL_OW 313
67297: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67298: LD_VAR 0 8
67302: PPUSH
67303: LD_INT 25
67305: PUSH
67306: LD_INT 12
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PPUSH
67313: CALL_OW 72
67317: NOT
67318: IFFALSE 67328
// control := control_manual ;
67320: LD_ADDR_VAR 0 4
67324: PUSH
67325: LD_INT 1
67327: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67328: LD_ADDR_VAR 0 8
67332: PUSH
67333: LD_VAR 0 1
67337: PPUSH
67338: CALL 67025 0 1
67342: ST_TO_ADDR
// if tmp then
67343: LD_VAR 0 8
67347: IFFALSE 67390
// begin for i in tmp do
67349: LD_ADDR_VAR 0 7
67353: PUSH
67354: LD_VAR 0 8
67358: PUSH
67359: FOR_IN
67360: IFFALSE 67388
// if i [ 1 ] = b_ext_radar then
67362: LD_VAR 0 7
67366: PUSH
67367: LD_INT 1
67369: ARRAY
67370: PUSH
67371: LD_INT 20
67373: EQUAL
67374: IFFALSE 67386
// begin control := control_remote ;
67376: LD_ADDR_VAR 0 4
67380: PUSH
67381: LD_INT 2
67383: ST_TO_ADDR
// break ;
67384: GO 67388
// end ;
67386: GO 67359
67388: POP
67389: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67390: LD_VAR 0 1
67394: PPUSH
67395: LD_VAR 0 2
67399: PPUSH
67400: LD_VAR 0 3
67404: PPUSH
67405: LD_VAR 0 4
67409: PPUSH
67410: LD_VAR 0 5
67414: PPUSH
67415: CALL_OW 448
67419: IFFALSE 67454
// begin result := [ chassis , engine , control , weapon ] ;
67421: LD_ADDR_VAR 0 6
67425: PUSH
67426: LD_VAR 0 2
67430: PUSH
67431: LD_VAR 0 3
67435: PUSH
67436: LD_VAR 0 4
67440: PUSH
67441: LD_VAR 0 5
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: ST_TO_ADDR
// exit ;
67452: GO 67798
// end ; _chassis := AvailableChassisList ( factory ) ;
67454: LD_ADDR_VAR 0 9
67458: PUSH
67459: LD_VAR 0 1
67463: PPUSH
67464: CALL_OW 475
67468: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67469: LD_ADDR_VAR 0 11
67473: PUSH
67474: LD_VAR 0 1
67478: PPUSH
67479: CALL_OW 476
67483: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67484: LD_ADDR_VAR 0 12
67488: PUSH
67489: LD_VAR 0 1
67493: PPUSH
67494: CALL_OW 477
67498: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67499: LD_ADDR_VAR 0 10
67503: PUSH
67504: LD_VAR 0 1
67508: PPUSH
67509: CALL_OW 478
67513: ST_TO_ADDR
// if not chassis in _chassis then
67514: LD_VAR 0 2
67518: PUSH
67519: LD_VAR 0 9
67523: IN
67524: NOT
67525: IFFALSE 67551
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67527: LD_ADDR_VAR 0 2
67531: PUSH
67532: LD_VAR 0 9
67536: PUSH
67537: LD_INT 1
67539: PPUSH
67540: LD_VAR 0 9
67544: PPUSH
67545: CALL_OW 12
67549: ARRAY
67550: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67551: LD_VAR 0 2
67555: PPUSH
67556: LD_VAR 0 3
67560: PPUSH
67561: CALL 67803 0 2
67565: NOT
67566: IFFALSE 67625
// repeat engine := _engine [ 1 ] ;
67568: LD_ADDR_VAR 0 3
67572: PUSH
67573: LD_VAR 0 11
67577: PUSH
67578: LD_INT 1
67580: ARRAY
67581: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67582: LD_ADDR_VAR 0 11
67586: PUSH
67587: LD_VAR 0 11
67591: PPUSH
67592: LD_INT 1
67594: PPUSH
67595: CALL_OW 3
67599: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67600: LD_VAR 0 2
67604: PPUSH
67605: LD_VAR 0 3
67609: PPUSH
67610: CALL 67803 0 2
67614: PUSH
67615: LD_VAR 0 11
67619: PUSH
67620: EMPTY
67621: EQUAL
67622: OR
67623: IFFALSE 67568
// if not control in _control then
67625: LD_VAR 0 4
67629: PUSH
67630: LD_VAR 0 12
67634: IN
67635: NOT
67636: IFFALSE 67662
// control := _control [ rand ( 1 , _control ) ] ;
67638: LD_ADDR_VAR 0 4
67642: PUSH
67643: LD_VAR 0 12
67647: PUSH
67648: LD_INT 1
67650: PPUSH
67651: LD_VAR 0 12
67655: PPUSH
67656: CALL_OW 12
67660: ARRAY
67661: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67662: LD_VAR 0 2
67666: PPUSH
67667: LD_VAR 0 5
67671: PPUSH
67672: CALL 68023 0 2
67676: NOT
67677: IFFALSE 67736
// repeat weapon := _weapon [ 1 ] ;
67679: LD_ADDR_VAR 0 5
67683: PUSH
67684: LD_VAR 0 10
67688: PUSH
67689: LD_INT 1
67691: ARRAY
67692: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67693: LD_ADDR_VAR 0 10
67697: PUSH
67698: LD_VAR 0 10
67702: PPUSH
67703: LD_INT 1
67705: PPUSH
67706: CALL_OW 3
67710: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67711: LD_VAR 0 2
67715: PPUSH
67716: LD_VAR 0 5
67720: PPUSH
67721: CALL 68023 0 2
67725: PUSH
67726: LD_VAR 0 10
67730: PUSH
67731: EMPTY
67732: EQUAL
67733: OR
67734: IFFALSE 67679
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67736: LD_VAR 0 1
67740: PPUSH
67741: LD_VAR 0 2
67745: PPUSH
67746: LD_VAR 0 3
67750: PPUSH
67751: LD_VAR 0 4
67755: PPUSH
67756: LD_VAR 0 5
67760: PPUSH
67761: CALL_OW 448
67765: IFFALSE 67798
// result := [ chassis , engine , control , weapon ] ;
67767: LD_ADDR_VAR 0 6
67771: PUSH
67772: LD_VAR 0 2
67776: PUSH
67777: LD_VAR 0 3
67781: PUSH
67782: LD_VAR 0 4
67786: PUSH
67787: LD_VAR 0 5
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: ST_TO_ADDR
// end ;
67798: LD_VAR 0 6
67802: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67803: LD_INT 0
67805: PPUSH
// if not chassis or not engine then
67806: LD_VAR 0 1
67810: NOT
67811: PUSH
67812: LD_VAR 0 2
67816: NOT
67817: OR
67818: IFFALSE 67822
// exit ;
67820: GO 68018
// case engine of engine_solar :
67822: LD_VAR 0 2
67826: PUSH
67827: LD_INT 2
67829: DOUBLE
67830: EQUAL
67831: IFTRUE 67835
67833: GO 67873
67835: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67836: LD_ADDR_VAR 0 3
67840: PUSH
67841: LD_INT 11
67843: PUSH
67844: LD_INT 12
67846: PUSH
67847: LD_INT 13
67849: PUSH
67850: LD_INT 14
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: LD_INT 2
67858: PUSH
67859: LD_INT 3
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: ST_TO_ADDR
67871: GO 68002
67873: LD_INT 1
67875: DOUBLE
67876: EQUAL
67877: IFTRUE 67881
67879: GO 67943
67881: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67882: LD_ADDR_VAR 0 3
67886: PUSH
67887: LD_INT 11
67889: PUSH
67890: LD_INT 12
67892: PUSH
67893: LD_INT 13
67895: PUSH
67896: LD_INT 14
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 3
67907: PUSH
67908: LD_INT 4
67910: PUSH
67911: LD_INT 5
67913: PUSH
67914: LD_INT 21
67916: PUSH
67917: LD_INT 23
67919: PUSH
67920: LD_INT 22
67922: PUSH
67923: LD_INT 24
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: ST_TO_ADDR
67941: GO 68002
67943: LD_INT 3
67945: DOUBLE
67946: EQUAL
67947: IFTRUE 67951
67949: GO 68001
67951: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67952: LD_ADDR_VAR 0 3
67956: PUSH
67957: LD_INT 13
67959: PUSH
67960: LD_INT 14
67962: PUSH
67963: LD_INT 2
67965: PUSH
67966: LD_INT 3
67968: PUSH
67969: LD_INT 4
67971: PUSH
67972: LD_INT 5
67974: PUSH
67975: LD_INT 21
67977: PUSH
67978: LD_INT 22
67980: PUSH
67981: LD_INT 23
67983: PUSH
67984: LD_INT 24
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: ST_TO_ADDR
67999: GO 68002
68001: POP
// result := ( chassis in result ) ;
68002: LD_ADDR_VAR 0 3
68006: PUSH
68007: LD_VAR 0 1
68011: PUSH
68012: LD_VAR 0 3
68016: IN
68017: ST_TO_ADDR
// end ;
68018: LD_VAR 0 3
68022: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68023: LD_INT 0
68025: PPUSH
// if not chassis or not weapon then
68026: LD_VAR 0 1
68030: NOT
68031: PUSH
68032: LD_VAR 0 2
68036: NOT
68037: OR
68038: IFFALSE 68042
// exit ;
68040: GO 69068
// case weapon of us_machine_gun :
68042: LD_VAR 0 2
68046: PUSH
68047: LD_INT 2
68049: DOUBLE
68050: EQUAL
68051: IFTRUE 68055
68053: GO 68085
68055: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68056: LD_ADDR_VAR 0 3
68060: PUSH
68061: LD_INT 1
68063: PUSH
68064: LD_INT 2
68066: PUSH
68067: LD_INT 3
68069: PUSH
68070: LD_INT 4
68072: PUSH
68073: LD_INT 5
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: ST_TO_ADDR
68083: GO 69052
68085: LD_INT 3
68087: DOUBLE
68088: EQUAL
68089: IFTRUE 68093
68091: GO 68123
68093: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68094: LD_ADDR_VAR 0 3
68098: PUSH
68099: LD_INT 1
68101: PUSH
68102: LD_INT 2
68104: PUSH
68105: LD_INT 3
68107: PUSH
68108: LD_INT 4
68110: PUSH
68111: LD_INT 5
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: ST_TO_ADDR
68121: GO 69052
68123: LD_INT 11
68125: DOUBLE
68126: EQUAL
68127: IFTRUE 68131
68129: GO 68161
68131: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68132: LD_ADDR_VAR 0 3
68136: PUSH
68137: LD_INT 1
68139: PUSH
68140: LD_INT 2
68142: PUSH
68143: LD_INT 3
68145: PUSH
68146: LD_INT 4
68148: PUSH
68149: LD_INT 5
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: ST_TO_ADDR
68159: GO 69052
68161: LD_INT 4
68163: DOUBLE
68164: EQUAL
68165: IFTRUE 68169
68167: GO 68195
68169: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68170: LD_ADDR_VAR 0 3
68174: PUSH
68175: LD_INT 2
68177: PUSH
68178: LD_INT 3
68180: PUSH
68181: LD_INT 4
68183: PUSH
68184: LD_INT 5
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: ST_TO_ADDR
68193: GO 69052
68195: LD_INT 5
68197: DOUBLE
68198: EQUAL
68199: IFTRUE 68203
68201: GO 68229
68203: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68204: LD_ADDR_VAR 0 3
68208: PUSH
68209: LD_INT 2
68211: PUSH
68212: LD_INT 3
68214: PUSH
68215: LD_INT 4
68217: PUSH
68218: LD_INT 5
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: ST_TO_ADDR
68227: GO 69052
68229: LD_INT 9
68231: DOUBLE
68232: EQUAL
68233: IFTRUE 68237
68235: GO 68263
68237: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68238: LD_ADDR_VAR 0 3
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: LD_INT 3
68248: PUSH
68249: LD_INT 4
68251: PUSH
68252: LD_INT 5
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: ST_TO_ADDR
68261: GO 69052
68263: LD_INT 7
68265: DOUBLE
68266: EQUAL
68267: IFTRUE 68271
68269: GO 68297
68271: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68272: LD_ADDR_VAR 0 3
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 3
68282: PUSH
68283: LD_INT 4
68285: PUSH
68286: LD_INT 5
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: ST_TO_ADDR
68295: GO 69052
68297: LD_INT 12
68299: DOUBLE
68300: EQUAL
68301: IFTRUE 68305
68303: GO 68331
68305: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68306: LD_ADDR_VAR 0 3
68310: PUSH
68311: LD_INT 2
68313: PUSH
68314: LD_INT 3
68316: PUSH
68317: LD_INT 4
68319: PUSH
68320: LD_INT 5
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: ST_TO_ADDR
68329: GO 69052
68331: LD_INT 13
68333: DOUBLE
68334: EQUAL
68335: IFTRUE 68339
68337: GO 68365
68339: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68340: LD_ADDR_VAR 0 3
68344: PUSH
68345: LD_INT 2
68347: PUSH
68348: LD_INT 3
68350: PUSH
68351: LD_INT 4
68353: PUSH
68354: LD_INT 5
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: ST_TO_ADDR
68363: GO 69052
68365: LD_INT 14
68367: DOUBLE
68368: EQUAL
68369: IFTRUE 68373
68371: GO 68391
68373: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68374: LD_ADDR_VAR 0 3
68378: PUSH
68379: LD_INT 4
68381: PUSH
68382: LD_INT 5
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: ST_TO_ADDR
68389: GO 69052
68391: LD_INT 6
68393: DOUBLE
68394: EQUAL
68395: IFTRUE 68399
68397: GO 68417
68399: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68400: LD_ADDR_VAR 0 3
68404: PUSH
68405: LD_INT 4
68407: PUSH
68408: LD_INT 5
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: ST_TO_ADDR
68415: GO 69052
68417: LD_INT 10
68419: DOUBLE
68420: EQUAL
68421: IFTRUE 68425
68423: GO 68443
68425: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68426: LD_ADDR_VAR 0 3
68430: PUSH
68431: LD_INT 4
68433: PUSH
68434: LD_INT 5
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: ST_TO_ADDR
68441: GO 69052
68443: LD_INT 22
68445: DOUBLE
68446: EQUAL
68447: IFTRUE 68451
68449: GO 68477
68451: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68452: LD_ADDR_VAR 0 3
68456: PUSH
68457: LD_INT 11
68459: PUSH
68460: LD_INT 12
68462: PUSH
68463: LD_INT 13
68465: PUSH
68466: LD_INT 14
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: LIST
68473: LIST
68474: ST_TO_ADDR
68475: GO 69052
68477: LD_INT 23
68479: DOUBLE
68480: EQUAL
68481: IFTRUE 68485
68483: GO 68511
68485: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68486: LD_ADDR_VAR 0 3
68490: PUSH
68491: LD_INT 11
68493: PUSH
68494: LD_INT 12
68496: PUSH
68497: LD_INT 13
68499: PUSH
68500: LD_INT 14
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: ST_TO_ADDR
68509: GO 69052
68511: LD_INT 24
68513: DOUBLE
68514: EQUAL
68515: IFTRUE 68519
68517: GO 68545
68519: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68520: LD_ADDR_VAR 0 3
68524: PUSH
68525: LD_INT 11
68527: PUSH
68528: LD_INT 12
68530: PUSH
68531: LD_INT 13
68533: PUSH
68534: LD_INT 14
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: ST_TO_ADDR
68543: GO 69052
68545: LD_INT 30
68547: DOUBLE
68548: EQUAL
68549: IFTRUE 68553
68551: GO 68579
68553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68554: LD_ADDR_VAR 0 3
68558: PUSH
68559: LD_INT 11
68561: PUSH
68562: LD_INT 12
68564: PUSH
68565: LD_INT 13
68567: PUSH
68568: LD_INT 14
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: ST_TO_ADDR
68577: GO 69052
68579: LD_INT 25
68581: DOUBLE
68582: EQUAL
68583: IFTRUE 68587
68585: GO 68605
68587: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68588: LD_ADDR_VAR 0 3
68592: PUSH
68593: LD_INT 13
68595: PUSH
68596: LD_INT 14
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: ST_TO_ADDR
68603: GO 69052
68605: LD_INT 27
68607: DOUBLE
68608: EQUAL
68609: IFTRUE 68613
68611: GO 68631
68613: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68614: LD_ADDR_VAR 0 3
68618: PUSH
68619: LD_INT 13
68621: PUSH
68622: LD_INT 14
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: ST_TO_ADDR
68629: GO 69052
68631: LD_INT 28
68633: DOUBLE
68634: EQUAL
68635: IFTRUE 68639
68637: GO 68657
68639: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68640: LD_ADDR_VAR 0 3
68644: PUSH
68645: LD_INT 13
68647: PUSH
68648: LD_INT 14
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: ST_TO_ADDR
68655: GO 69052
68657: LD_INT 29
68659: DOUBLE
68660: EQUAL
68661: IFTRUE 68665
68663: GO 68683
68665: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68666: LD_ADDR_VAR 0 3
68670: PUSH
68671: LD_INT 13
68673: PUSH
68674: LD_INT 14
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: ST_TO_ADDR
68681: GO 69052
68683: LD_INT 31
68685: DOUBLE
68686: EQUAL
68687: IFTRUE 68691
68689: GO 68709
68691: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68692: LD_ADDR_VAR 0 3
68696: PUSH
68697: LD_INT 13
68699: PUSH
68700: LD_INT 14
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: ST_TO_ADDR
68707: GO 69052
68709: LD_INT 26
68711: DOUBLE
68712: EQUAL
68713: IFTRUE 68717
68715: GO 68735
68717: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68718: LD_ADDR_VAR 0 3
68722: PUSH
68723: LD_INT 13
68725: PUSH
68726: LD_INT 14
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: ST_TO_ADDR
68733: GO 69052
68735: LD_INT 42
68737: DOUBLE
68738: EQUAL
68739: IFTRUE 68743
68741: GO 68769
68743: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68744: LD_ADDR_VAR 0 3
68748: PUSH
68749: LD_INT 21
68751: PUSH
68752: LD_INT 22
68754: PUSH
68755: LD_INT 23
68757: PUSH
68758: LD_INT 24
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: ST_TO_ADDR
68767: GO 69052
68769: LD_INT 43
68771: DOUBLE
68772: EQUAL
68773: IFTRUE 68777
68775: GO 68803
68777: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68778: LD_ADDR_VAR 0 3
68782: PUSH
68783: LD_INT 21
68785: PUSH
68786: LD_INT 22
68788: PUSH
68789: LD_INT 23
68791: PUSH
68792: LD_INT 24
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: ST_TO_ADDR
68801: GO 69052
68803: LD_INT 44
68805: DOUBLE
68806: EQUAL
68807: IFTRUE 68811
68809: GO 68837
68811: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68812: LD_ADDR_VAR 0 3
68816: PUSH
68817: LD_INT 21
68819: PUSH
68820: LD_INT 22
68822: PUSH
68823: LD_INT 23
68825: PUSH
68826: LD_INT 24
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: ST_TO_ADDR
68835: GO 69052
68837: LD_INT 45
68839: DOUBLE
68840: EQUAL
68841: IFTRUE 68845
68843: GO 68871
68845: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68846: LD_ADDR_VAR 0 3
68850: PUSH
68851: LD_INT 21
68853: PUSH
68854: LD_INT 22
68856: PUSH
68857: LD_INT 23
68859: PUSH
68860: LD_INT 24
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: ST_TO_ADDR
68869: GO 69052
68871: LD_INT 49
68873: DOUBLE
68874: EQUAL
68875: IFTRUE 68879
68877: GO 68905
68879: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68880: LD_ADDR_VAR 0 3
68884: PUSH
68885: LD_INT 21
68887: PUSH
68888: LD_INT 22
68890: PUSH
68891: LD_INT 23
68893: PUSH
68894: LD_INT 24
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: ST_TO_ADDR
68903: GO 69052
68905: LD_INT 51
68907: DOUBLE
68908: EQUAL
68909: IFTRUE 68913
68911: GO 68939
68913: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68914: LD_ADDR_VAR 0 3
68918: PUSH
68919: LD_INT 21
68921: PUSH
68922: LD_INT 22
68924: PUSH
68925: LD_INT 23
68927: PUSH
68928: LD_INT 24
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: ST_TO_ADDR
68937: GO 69052
68939: LD_INT 52
68941: DOUBLE
68942: EQUAL
68943: IFTRUE 68947
68945: GO 68973
68947: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68948: LD_ADDR_VAR 0 3
68952: PUSH
68953: LD_INT 21
68955: PUSH
68956: LD_INT 22
68958: PUSH
68959: LD_INT 23
68961: PUSH
68962: LD_INT 24
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: ST_TO_ADDR
68971: GO 69052
68973: LD_INT 53
68975: DOUBLE
68976: EQUAL
68977: IFTRUE 68981
68979: GO 68999
68981: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68982: LD_ADDR_VAR 0 3
68986: PUSH
68987: LD_INT 23
68989: PUSH
68990: LD_INT 24
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: ST_TO_ADDR
68997: GO 69052
68999: LD_INT 46
69001: DOUBLE
69002: EQUAL
69003: IFTRUE 69007
69005: GO 69025
69007: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69008: LD_ADDR_VAR 0 3
69012: PUSH
69013: LD_INT 23
69015: PUSH
69016: LD_INT 24
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: ST_TO_ADDR
69023: GO 69052
69025: LD_INT 47
69027: DOUBLE
69028: EQUAL
69029: IFTRUE 69033
69031: GO 69051
69033: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69034: LD_ADDR_VAR 0 3
69038: PUSH
69039: LD_INT 23
69041: PUSH
69042: LD_INT 24
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: ST_TO_ADDR
69049: GO 69052
69051: POP
// result := ( chassis in result ) ;
69052: LD_ADDR_VAR 0 3
69056: PUSH
69057: LD_VAR 0 1
69061: PUSH
69062: LD_VAR 0 3
69066: IN
69067: ST_TO_ADDR
// end ;
69068: LD_VAR 0 3
69072: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69073: LD_INT 0
69075: PPUSH
69076: PPUSH
69077: PPUSH
69078: PPUSH
69079: PPUSH
69080: PPUSH
69081: PPUSH
// result := array ;
69082: LD_ADDR_VAR 0 5
69086: PUSH
69087: LD_VAR 0 1
69091: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69092: LD_VAR 0 1
69096: NOT
69097: PUSH
69098: LD_VAR 0 2
69102: NOT
69103: OR
69104: PUSH
69105: LD_VAR 0 3
69109: NOT
69110: OR
69111: PUSH
69112: LD_VAR 0 2
69116: PUSH
69117: LD_VAR 0 1
69121: GREATER
69122: OR
69123: PUSH
69124: LD_VAR 0 3
69128: PUSH
69129: LD_VAR 0 1
69133: GREATER
69134: OR
69135: IFFALSE 69139
// exit ;
69137: GO 69435
// if direction then
69139: LD_VAR 0 4
69143: IFFALSE 69207
// begin d := 1 ;
69145: LD_ADDR_VAR 0 9
69149: PUSH
69150: LD_INT 1
69152: ST_TO_ADDR
// if i_from > i_to then
69153: LD_VAR 0 2
69157: PUSH
69158: LD_VAR 0 3
69162: GREATER
69163: IFFALSE 69189
// length := ( array - i_from ) + i_to else
69165: LD_ADDR_VAR 0 11
69169: PUSH
69170: LD_VAR 0 1
69174: PUSH
69175: LD_VAR 0 2
69179: MINUS
69180: PUSH
69181: LD_VAR 0 3
69185: PLUS
69186: ST_TO_ADDR
69187: GO 69205
// length := i_to - i_from ;
69189: LD_ADDR_VAR 0 11
69193: PUSH
69194: LD_VAR 0 3
69198: PUSH
69199: LD_VAR 0 2
69203: MINUS
69204: ST_TO_ADDR
// end else
69205: GO 69268
// begin d := - 1 ;
69207: LD_ADDR_VAR 0 9
69211: PUSH
69212: LD_INT 1
69214: NEG
69215: ST_TO_ADDR
// if i_from > i_to then
69216: LD_VAR 0 2
69220: PUSH
69221: LD_VAR 0 3
69225: GREATER
69226: IFFALSE 69246
// length := i_from - i_to else
69228: LD_ADDR_VAR 0 11
69232: PUSH
69233: LD_VAR 0 2
69237: PUSH
69238: LD_VAR 0 3
69242: MINUS
69243: ST_TO_ADDR
69244: GO 69268
// length := ( array - i_to ) + i_from ;
69246: LD_ADDR_VAR 0 11
69250: PUSH
69251: LD_VAR 0 1
69255: PUSH
69256: LD_VAR 0 3
69260: MINUS
69261: PUSH
69262: LD_VAR 0 2
69266: PLUS
69267: ST_TO_ADDR
// end ; if not length then
69268: LD_VAR 0 11
69272: NOT
69273: IFFALSE 69277
// exit ;
69275: GO 69435
// tmp := array ;
69277: LD_ADDR_VAR 0 10
69281: PUSH
69282: LD_VAR 0 1
69286: ST_TO_ADDR
// for i = 1 to length do
69287: LD_ADDR_VAR 0 6
69291: PUSH
69292: DOUBLE
69293: LD_INT 1
69295: DEC
69296: ST_TO_ADDR
69297: LD_VAR 0 11
69301: PUSH
69302: FOR_TO
69303: IFFALSE 69423
// begin for j = 1 to array do
69305: LD_ADDR_VAR 0 7
69309: PUSH
69310: DOUBLE
69311: LD_INT 1
69313: DEC
69314: ST_TO_ADDR
69315: LD_VAR 0 1
69319: PUSH
69320: FOR_TO
69321: IFFALSE 69409
// begin k := j + d ;
69323: LD_ADDR_VAR 0 8
69327: PUSH
69328: LD_VAR 0 7
69332: PUSH
69333: LD_VAR 0 9
69337: PLUS
69338: ST_TO_ADDR
// if k > array then
69339: LD_VAR 0 8
69343: PUSH
69344: LD_VAR 0 1
69348: GREATER
69349: IFFALSE 69359
// k := 1 ;
69351: LD_ADDR_VAR 0 8
69355: PUSH
69356: LD_INT 1
69358: ST_TO_ADDR
// if not k then
69359: LD_VAR 0 8
69363: NOT
69364: IFFALSE 69376
// k := array ;
69366: LD_ADDR_VAR 0 8
69370: PUSH
69371: LD_VAR 0 1
69375: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69376: LD_ADDR_VAR 0 10
69380: PUSH
69381: LD_VAR 0 10
69385: PPUSH
69386: LD_VAR 0 8
69390: PPUSH
69391: LD_VAR 0 1
69395: PUSH
69396: LD_VAR 0 7
69400: ARRAY
69401: PPUSH
69402: CALL_OW 1
69406: ST_TO_ADDR
// end ;
69407: GO 69320
69409: POP
69410: POP
// array := tmp ;
69411: LD_ADDR_VAR 0 1
69415: PUSH
69416: LD_VAR 0 10
69420: ST_TO_ADDR
// end ;
69421: GO 69302
69423: POP
69424: POP
// result := array ;
69425: LD_ADDR_VAR 0 5
69429: PUSH
69430: LD_VAR 0 1
69434: ST_TO_ADDR
// end ;
69435: LD_VAR 0 5
69439: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69440: LD_INT 0
69442: PPUSH
69443: PPUSH
// result := 0 ;
69444: LD_ADDR_VAR 0 3
69448: PUSH
69449: LD_INT 0
69451: ST_TO_ADDR
// if not array or not value in array then
69452: LD_VAR 0 1
69456: NOT
69457: PUSH
69458: LD_VAR 0 2
69462: PUSH
69463: LD_VAR 0 1
69467: IN
69468: NOT
69469: OR
69470: IFFALSE 69474
// exit ;
69472: GO 69528
// for i = 1 to array do
69474: LD_ADDR_VAR 0 4
69478: PUSH
69479: DOUBLE
69480: LD_INT 1
69482: DEC
69483: ST_TO_ADDR
69484: LD_VAR 0 1
69488: PUSH
69489: FOR_TO
69490: IFFALSE 69526
// if value = array [ i ] then
69492: LD_VAR 0 2
69496: PUSH
69497: LD_VAR 0 1
69501: PUSH
69502: LD_VAR 0 4
69506: ARRAY
69507: EQUAL
69508: IFFALSE 69524
// begin result := i ;
69510: LD_ADDR_VAR 0 3
69514: PUSH
69515: LD_VAR 0 4
69519: ST_TO_ADDR
// exit ;
69520: POP
69521: POP
69522: GO 69528
// end ;
69524: GO 69489
69526: POP
69527: POP
// end ;
69528: LD_VAR 0 3
69532: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69533: LD_INT 0
69535: PPUSH
// vc_chassis := chassis ;
69536: LD_ADDR_OWVAR 37
69540: PUSH
69541: LD_VAR 0 1
69545: ST_TO_ADDR
// vc_engine := engine ;
69546: LD_ADDR_OWVAR 39
69550: PUSH
69551: LD_VAR 0 2
69555: ST_TO_ADDR
// vc_control := control ;
69556: LD_ADDR_OWVAR 38
69560: PUSH
69561: LD_VAR 0 3
69565: ST_TO_ADDR
// vc_weapon := weapon ;
69566: LD_ADDR_OWVAR 40
69570: PUSH
69571: LD_VAR 0 4
69575: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69576: LD_ADDR_OWVAR 41
69580: PUSH
69581: LD_VAR 0 5
69585: ST_TO_ADDR
// end ;
69586: LD_VAR 0 6
69590: RET
// export function WantPlant ( unit ) ; var task ; begin
69591: LD_INT 0
69593: PPUSH
69594: PPUSH
// result := false ;
69595: LD_ADDR_VAR 0 2
69599: PUSH
69600: LD_INT 0
69602: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69603: LD_ADDR_VAR 0 3
69607: PUSH
69608: LD_VAR 0 1
69612: PPUSH
69613: CALL_OW 437
69617: ST_TO_ADDR
// if task then
69618: LD_VAR 0 3
69622: IFFALSE 69650
// if task [ 1 ] [ 1 ] = p then
69624: LD_VAR 0 3
69628: PUSH
69629: LD_INT 1
69631: ARRAY
69632: PUSH
69633: LD_INT 1
69635: ARRAY
69636: PUSH
69637: LD_STRING p
69639: EQUAL
69640: IFFALSE 69650
// result := true ;
69642: LD_ADDR_VAR 0 2
69646: PUSH
69647: LD_INT 1
69649: ST_TO_ADDR
// end ;
69650: LD_VAR 0 2
69654: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69655: LD_INT 0
69657: PPUSH
69658: PPUSH
69659: PPUSH
69660: PPUSH
// if pos < 1 then
69661: LD_VAR 0 2
69665: PUSH
69666: LD_INT 1
69668: LESS
69669: IFFALSE 69673
// exit ;
69671: GO 69976
// if pos = 1 then
69673: LD_VAR 0 2
69677: PUSH
69678: LD_INT 1
69680: EQUAL
69681: IFFALSE 69714
// result := Replace ( arr , pos [ 1 ] , value ) else
69683: LD_ADDR_VAR 0 4
69687: PUSH
69688: LD_VAR 0 1
69692: PPUSH
69693: LD_VAR 0 2
69697: PUSH
69698: LD_INT 1
69700: ARRAY
69701: PPUSH
69702: LD_VAR 0 3
69706: PPUSH
69707: CALL_OW 1
69711: ST_TO_ADDR
69712: GO 69976
// begin tmp := arr ;
69714: LD_ADDR_VAR 0 6
69718: PUSH
69719: LD_VAR 0 1
69723: ST_TO_ADDR
// s_arr := [ tmp ] ;
69724: LD_ADDR_VAR 0 7
69728: PUSH
69729: LD_VAR 0 6
69733: PUSH
69734: EMPTY
69735: LIST
69736: ST_TO_ADDR
// for i = 1 to pos - 1 do
69737: LD_ADDR_VAR 0 5
69741: PUSH
69742: DOUBLE
69743: LD_INT 1
69745: DEC
69746: ST_TO_ADDR
69747: LD_VAR 0 2
69751: PUSH
69752: LD_INT 1
69754: MINUS
69755: PUSH
69756: FOR_TO
69757: IFFALSE 69802
// begin tmp := tmp [ pos [ i ] ] ;
69759: LD_ADDR_VAR 0 6
69763: PUSH
69764: LD_VAR 0 6
69768: PUSH
69769: LD_VAR 0 2
69773: PUSH
69774: LD_VAR 0 5
69778: ARRAY
69779: ARRAY
69780: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69781: LD_ADDR_VAR 0 7
69785: PUSH
69786: LD_VAR 0 7
69790: PUSH
69791: LD_VAR 0 6
69795: PUSH
69796: EMPTY
69797: LIST
69798: ADD
69799: ST_TO_ADDR
// end ;
69800: GO 69756
69802: POP
69803: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69804: LD_ADDR_VAR 0 6
69808: PUSH
69809: LD_VAR 0 6
69813: PPUSH
69814: LD_VAR 0 2
69818: PUSH
69819: LD_VAR 0 2
69823: ARRAY
69824: PPUSH
69825: LD_VAR 0 3
69829: PPUSH
69830: CALL_OW 1
69834: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69835: LD_ADDR_VAR 0 7
69839: PUSH
69840: LD_VAR 0 7
69844: PPUSH
69845: LD_VAR 0 7
69849: PPUSH
69850: LD_VAR 0 6
69854: PPUSH
69855: CALL_OW 1
69859: ST_TO_ADDR
// for i = s_arr downto 2 do
69860: LD_ADDR_VAR 0 5
69864: PUSH
69865: DOUBLE
69866: LD_VAR 0 7
69870: INC
69871: ST_TO_ADDR
69872: LD_INT 2
69874: PUSH
69875: FOR_DOWNTO
69876: IFFALSE 69960
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69878: LD_ADDR_VAR 0 6
69882: PUSH
69883: LD_VAR 0 7
69887: PUSH
69888: LD_VAR 0 5
69892: PUSH
69893: LD_INT 1
69895: MINUS
69896: ARRAY
69897: PPUSH
69898: LD_VAR 0 2
69902: PUSH
69903: LD_VAR 0 5
69907: PUSH
69908: LD_INT 1
69910: MINUS
69911: ARRAY
69912: PPUSH
69913: LD_VAR 0 7
69917: PUSH
69918: LD_VAR 0 5
69922: ARRAY
69923: PPUSH
69924: CALL_OW 1
69928: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69929: LD_ADDR_VAR 0 7
69933: PUSH
69934: LD_VAR 0 7
69938: PPUSH
69939: LD_VAR 0 5
69943: PUSH
69944: LD_INT 1
69946: MINUS
69947: PPUSH
69948: LD_VAR 0 6
69952: PPUSH
69953: CALL_OW 1
69957: ST_TO_ADDR
// end ;
69958: GO 69875
69960: POP
69961: POP
// result := s_arr [ 1 ] ;
69962: LD_ADDR_VAR 0 4
69966: PUSH
69967: LD_VAR 0 7
69971: PUSH
69972: LD_INT 1
69974: ARRAY
69975: ST_TO_ADDR
// end ; end ;
69976: LD_VAR 0 4
69980: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69981: LD_INT 0
69983: PPUSH
69984: PPUSH
// if not list then
69985: LD_VAR 0 1
69989: NOT
69990: IFFALSE 69994
// exit ;
69992: GO 70085
// i := list [ pos1 ] ;
69994: LD_ADDR_VAR 0 5
69998: PUSH
69999: LD_VAR 0 1
70003: PUSH
70004: LD_VAR 0 2
70008: ARRAY
70009: ST_TO_ADDR
// if not i then
70010: LD_VAR 0 5
70014: NOT
70015: IFFALSE 70019
// exit ;
70017: GO 70085
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70019: LD_ADDR_VAR 0 1
70023: PUSH
70024: LD_VAR 0 1
70028: PPUSH
70029: LD_VAR 0 2
70033: PPUSH
70034: LD_VAR 0 1
70038: PUSH
70039: LD_VAR 0 3
70043: ARRAY
70044: PPUSH
70045: CALL_OW 1
70049: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70050: LD_ADDR_VAR 0 1
70054: PUSH
70055: LD_VAR 0 1
70059: PPUSH
70060: LD_VAR 0 3
70064: PPUSH
70065: LD_VAR 0 5
70069: PPUSH
70070: CALL_OW 1
70074: ST_TO_ADDR
// result := list ;
70075: LD_ADDR_VAR 0 4
70079: PUSH
70080: LD_VAR 0 1
70084: ST_TO_ADDR
// end ;
70085: LD_VAR 0 4
70089: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70090: LD_INT 0
70092: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70093: LD_ADDR_VAR 0 5
70097: PUSH
70098: LD_VAR 0 1
70102: PPUSH
70103: CALL_OW 250
70107: PPUSH
70108: LD_VAR 0 1
70112: PPUSH
70113: CALL_OW 251
70117: PPUSH
70118: LD_VAR 0 2
70122: PPUSH
70123: LD_VAR 0 3
70127: PPUSH
70128: LD_VAR 0 4
70132: PPUSH
70133: CALL 70143 0 5
70137: ST_TO_ADDR
// end ;
70138: LD_VAR 0 5
70142: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70143: LD_INT 0
70145: PPUSH
70146: PPUSH
70147: PPUSH
70148: PPUSH
// if not list then
70149: LD_VAR 0 3
70153: NOT
70154: IFFALSE 70158
// exit ;
70156: GO 70546
// result := [ ] ;
70158: LD_ADDR_VAR 0 6
70162: PUSH
70163: EMPTY
70164: ST_TO_ADDR
// for i in list do
70165: LD_ADDR_VAR 0 7
70169: PUSH
70170: LD_VAR 0 3
70174: PUSH
70175: FOR_IN
70176: IFFALSE 70378
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70178: LD_ADDR_VAR 0 9
70182: PUSH
70183: LD_VAR 0 7
70187: PPUSH
70188: LD_VAR 0 1
70192: PPUSH
70193: LD_VAR 0 2
70197: PPUSH
70198: CALL_OW 297
70202: ST_TO_ADDR
// if not result then
70203: LD_VAR 0 6
70207: NOT
70208: IFFALSE 70234
// result := [ [ i , tmp ] ] else
70210: LD_ADDR_VAR 0 6
70214: PUSH
70215: LD_VAR 0 7
70219: PUSH
70220: LD_VAR 0 9
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: EMPTY
70230: LIST
70231: ST_TO_ADDR
70232: GO 70376
// begin if result [ result ] [ 2 ] < tmp then
70234: LD_VAR 0 6
70238: PUSH
70239: LD_VAR 0 6
70243: ARRAY
70244: PUSH
70245: LD_INT 2
70247: ARRAY
70248: PUSH
70249: LD_VAR 0 9
70253: LESS
70254: IFFALSE 70296
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70256: LD_ADDR_VAR 0 6
70260: PUSH
70261: LD_VAR 0 6
70265: PPUSH
70266: LD_VAR 0 6
70270: PUSH
70271: LD_INT 1
70273: PLUS
70274: PPUSH
70275: LD_VAR 0 7
70279: PUSH
70280: LD_VAR 0 9
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PPUSH
70289: CALL_OW 2
70293: ST_TO_ADDR
70294: GO 70376
// for j = 1 to result do
70296: LD_ADDR_VAR 0 8
70300: PUSH
70301: DOUBLE
70302: LD_INT 1
70304: DEC
70305: ST_TO_ADDR
70306: LD_VAR 0 6
70310: PUSH
70311: FOR_TO
70312: IFFALSE 70374
// begin if tmp < result [ j ] [ 2 ] then
70314: LD_VAR 0 9
70318: PUSH
70319: LD_VAR 0 6
70323: PUSH
70324: LD_VAR 0 8
70328: ARRAY
70329: PUSH
70330: LD_INT 2
70332: ARRAY
70333: LESS
70334: IFFALSE 70372
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70336: LD_ADDR_VAR 0 6
70340: PUSH
70341: LD_VAR 0 6
70345: PPUSH
70346: LD_VAR 0 8
70350: PPUSH
70351: LD_VAR 0 7
70355: PUSH
70356: LD_VAR 0 9
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PPUSH
70365: CALL_OW 2
70369: ST_TO_ADDR
// break ;
70370: GO 70374
// end ; end ;
70372: GO 70311
70374: POP
70375: POP
// end ; end ;
70376: GO 70175
70378: POP
70379: POP
// if result and not asc then
70380: LD_VAR 0 6
70384: PUSH
70385: LD_VAR 0 4
70389: NOT
70390: AND
70391: IFFALSE 70466
// begin tmp := result ;
70393: LD_ADDR_VAR 0 9
70397: PUSH
70398: LD_VAR 0 6
70402: ST_TO_ADDR
// for i = tmp downto 1 do
70403: LD_ADDR_VAR 0 7
70407: PUSH
70408: DOUBLE
70409: LD_VAR 0 9
70413: INC
70414: ST_TO_ADDR
70415: LD_INT 1
70417: PUSH
70418: FOR_DOWNTO
70419: IFFALSE 70464
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70421: LD_ADDR_VAR 0 6
70425: PUSH
70426: LD_VAR 0 6
70430: PPUSH
70431: LD_VAR 0 9
70435: PUSH
70436: LD_VAR 0 7
70440: MINUS
70441: PUSH
70442: LD_INT 1
70444: PLUS
70445: PPUSH
70446: LD_VAR 0 9
70450: PUSH
70451: LD_VAR 0 7
70455: ARRAY
70456: PPUSH
70457: CALL_OW 1
70461: ST_TO_ADDR
70462: GO 70418
70464: POP
70465: POP
// end ; tmp := [ ] ;
70466: LD_ADDR_VAR 0 9
70470: PUSH
70471: EMPTY
70472: ST_TO_ADDR
// if mode then
70473: LD_VAR 0 5
70477: IFFALSE 70546
// begin for i = 1 to result do
70479: LD_ADDR_VAR 0 7
70483: PUSH
70484: DOUBLE
70485: LD_INT 1
70487: DEC
70488: ST_TO_ADDR
70489: LD_VAR 0 6
70493: PUSH
70494: FOR_TO
70495: IFFALSE 70534
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70497: LD_ADDR_VAR 0 9
70501: PUSH
70502: LD_VAR 0 9
70506: PPUSH
70507: LD_VAR 0 7
70511: PPUSH
70512: LD_VAR 0 6
70516: PUSH
70517: LD_VAR 0 7
70521: ARRAY
70522: PUSH
70523: LD_INT 1
70525: ARRAY
70526: PPUSH
70527: CALL_OW 1
70531: ST_TO_ADDR
70532: GO 70494
70534: POP
70535: POP
// result := tmp ;
70536: LD_ADDR_VAR 0 6
70540: PUSH
70541: LD_VAR 0 9
70545: ST_TO_ADDR
// end ; end ;
70546: LD_VAR 0 6
70550: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70551: LD_INT 0
70553: PPUSH
70554: PPUSH
70555: PPUSH
70556: PPUSH
70557: PPUSH
70558: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70559: LD_ADDR_VAR 0 5
70563: PUSH
70564: LD_INT 0
70566: PUSH
70567: LD_INT 0
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: EMPTY
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: ST_TO_ADDR
// if not x or not y then
70581: LD_VAR 0 2
70585: NOT
70586: PUSH
70587: LD_VAR 0 3
70591: NOT
70592: OR
70593: IFFALSE 70597
// exit ;
70595: GO 72243
// if not range then
70597: LD_VAR 0 4
70601: NOT
70602: IFFALSE 70612
// range := 10 ;
70604: LD_ADDR_VAR 0 4
70608: PUSH
70609: LD_INT 10
70611: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70612: LD_ADDR_VAR 0 8
70616: PUSH
70617: LD_INT 81
70619: PUSH
70620: LD_VAR 0 1
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 92
70631: PUSH
70632: LD_VAR 0 2
70636: PUSH
70637: LD_VAR 0 3
70641: PUSH
70642: LD_VAR 0 4
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 3
70655: PUSH
70656: LD_INT 21
70658: PUSH
70659: LD_INT 3
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: LIST
70674: PPUSH
70675: CALL_OW 69
70679: ST_TO_ADDR
// if not tmp then
70680: LD_VAR 0 8
70684: NOT
70685: IFFALSE 70689
// exit ;
70687: GO 72243
// for i in tmp do
70689: LD_ADDR_VAR 0 6
70693: PUSH
70694: LD_VAR 0 8
70698: PUSH
70699: FOR_IN
70700: IFFALSE 72218
// begin points := [ 0 , 0 , 0 ] ;
70702: LD_ADDR_VAR 0 9
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: LD_INT 0
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: LIST
70720: ST_TO_ADDR
// bpoints := 1 ;
70721: LD_ADDR_VAR 0 10
70725: PUSH
70726: LD_INT 1
70728: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70729: LD_VAR 0 6
70733: PPUSH
70734: CALL_OW 247
70738: PUSH
70739: LD_INT 1
70741: DOUBLE
70742: EQUAL
70743: IFTRUE 70747
70745: GO 71325
70747: POP
// begin if GetClass ( i ) = 1 then
70748: LD_VAR 0 6
70752: PPUSH
70753: CALL_OW 257
70757: PUSH
70758: LD_INT 1
70760: EQUAL
70761: IFFALSE 70782
// points := [ 10 , 5 , 3 ] ;
70763: LD_ADDR_VAR 0 9
70767: PUSH
70768: LD_INT 10
70770: PUSH
70771: LD_INT 5
70773: PUSH
70774: LD_INT 3
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: LIST
70781: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70782: LD_VAR 0 6
70786: PPUSH
70787: CALL_OW 257
70791: PUSH
70792: LD_INT 2
70794: PUSH
70795: LD_INT 3
70797: PUSH
70798: LD_INT 4
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: LIST
70805: IN
70806: IFFALSE 70827
// points := [ 3 , 2 , 1 ] ;
70808: LD_ADDR_VAR 0 9
70812: PUSH
70813: LD_INT 3
70815: PUSH
70816: LD_INT 2
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: LIST
70826: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70827: LD_VAR 0 6
70831: PPUSH
70832: CALL_OW 257
70836: PUSH
70837: LD_INT 5
70839: EQUAL
70840: IFFALSE 70861
// points := [ 130 , 5 , 2 ] ;
70842: LD_ADDR_VAR 0 9
70846: PUSH
70847: LD_INT 130
70849: PUSH
70850: LD_INT 5
70852: PUSH
70853: LD_INT 2
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: LIST
70860: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70861: LD_VAR 0 6
70865: PPUSH
70866: CALL_OW 257
70870: PUSH
70871: LD_INT 8
70873: EQUAL
70874: IFFALSE 70895
// points := [ 35 , 35 , 30 ] ;
70876: LD_ADDR_VAR 0 9
70880: PUSH
70881: LD_INT 35
70883: PUSH
70884: LD_INT 35
70886: PUSH
70887: LD_INT 30
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: LIST
70894: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70895: LD_VAR 0 6
70899: PPUSH
70900: CALL_OW 257
70904: PUSH
70905: LD_INT 9
70907: EQUAL
70908: IFFALSE 70929
// points := [ 20 , 55 , 40 ] ;
70910: LD_ADDR_VAR 0 9
70914: PUSH
70915: LD_INT 20
70917: PUSH
70918: LD_INT 55
70920: PUSH
70921: LD_INT 40
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: LIST
70928: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70929: LD_VAR 0 6
70933: PPUSH
70934: CALL_OW 257
70938: PUSH
70939: LD_INT 12
70941: PUSH
70942: LD_INT 16
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: IN
70949: IFFALSE 70970
// points := [ 5 , 3 , 2 ] ;
70951: LD_ADDR_VAR 0 9
70955: PUSH
70956: LD_INT 5
70958: PUSH
70959: LD_INT 3
70961: PUSH
70962: LD_INT 2
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: LIST
70969: ST_TO_ADDR
// if GetClass ( i ) = 17 then
70970: LD_VAR 0 6
70974: PPUSH
70975: CALL_OW 257
70979: PUSH
70980: LD_INT 17
70982: EQUAL
70983: IFFALSE 71004
// points := [ 100 , 50 , 75 ] ;
70985: LD_ADDR_VAR 0 9
70989: PUSH
70990: LD_INT 100
70992: PUSH
70993: LD_INT 50
70995: PUSH
70996: LD_INT 75
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: LIST
71003: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71004: LD_VAR 0 6
71008: PPUSH
71009: CALL_OW 257
71013: PUSH
71014: LD_INT 15
71016: EQUAL
71017: IFFALSE 71038
// points := [ 10 , 5 , 3 ] ;
71019: LD_ADDR_VAR 0 9
71023: PUSH
71024: LD_INT 10
71026: PUSH
71027: LD_INT 5
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: LIST
71037: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71038: LD_VAR 0 6
71042: PPUSH
71043: CALL_OW 257
71047: PUSH
71048: LD_INT 14
71050: EQUAL
71051: IFFALSE 71072
// points := [ 10 , 0 , 0 ] ;
71053: LD_ADDR_VAR 0 9
71057: PUSH
71058: LD_INT 10
71060: PUSH
71061: LD_INT 0
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71072: LD_VAR 0 6
71076: PPUSH
71077: CALL_OW 257
71081: PUSH
71082: LD_INT 11
71084: EQUAL
71085: IFFALSE 71106
// points := [ 30 , 10 , 5 ] ;
71087: LD_ADDR_VAR 0 9
71091: PUSH
71092: LD_INT 30
71094: PUSH
71095: LD_INT 10
71097: PUSH
71098: LD_INT 5
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: LIST
71105: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71106: LD_VAR 0 1
71110: PPUSH
71111: LD_INT 5
71113: PPUSH
71114: CALL_OW 321
71118: PUSH
71119: LD_INT 2
71121: EQUAL
71122: IFFALSE 71139
// bpoints := bpoints * 1.8 ;
71124: LD_ADDR_VAR 0 10
71128: PUSH
71129: LD_VAR 0 10
71133: PUSH
71134: LD_REAL  1.80000000000000E+0000
71137: MUL
71138: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71139: LD_VAR 0 6
71143: PPUSH
71144: CALL_OW 257
71148: PUSH
71149: LD_INT 1
71151: PUSH
71152: LD_INT 2
71154: PUSH
71155: LD_INT 3
71157: PUSH
71158: LD_INT 4
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: IN
71167: PUSH
71168: LD_VAR 0 1
71172: PPUSH
71173: LD_INT 51
71175: PPUSH
71176: CALL_OW 321
71180: PUSH
71181: LD_INT 2
71183: EQUAL
71184: AND
71185: IFFALSE 71202
// bpoints := bpoints * 1.2 ;
71187: LD_ADDR_VAR 0 10
71191: PUSH
71192: LD_VAR 0 10
71196: PUSH
71197: LD_REAL  1.20000000000000E+0000
71200: MUL
71201: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71202: LD_VAR 0 6
71206: PPUSH
71207: CALL_OW 257
71211: PUSH
71212: LD_INT 5
71214: PUSH
71215: LD_INT 7
71217: PUSH
71218: LD_INT 9
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: LIST
71225: IN
71226: PUSH
71227: LD_VAR 0 1
71231: PPUSH
71232: LD_INT 52
71234: PPUSH
71235: CALL_OW 321
71239: PUSH
71240: LD_INT 2
71242: EQUAL
71243: AND
71244: IFFALSE 71261
// bpoints := bpoints * 1.5 ;
71246: LD_ADDR_VAR 0 10
71250: PUSH
71251: LD_VAR 0 10
71255: PUSH
71256: LD_REAL  1.50000000000000E+0000
71259: MUL
71260: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71261: LD_VAR 0 1
71265: PPUSH
71266: LD_INT 66
71268: PPUSH
71269: CALL_OW 321
71273: PUSH
71274: LD_INT 2
71276: EQUAL
71277: IFFALSE 71294
// bpoints := bpoints * 1.1 ;
71279: LD_ADDR_VAR 0 10
71283: PUSH
71284: LD_VAR 0 10
71288: PUSH
71289: LD_REAL  1.10000000000000E+0000
71292: MUL
71293: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71294: LD_ADDR_VAR 0 10
71298: PUSH
71299: LD_VAR 0 10
71303: PUSH
71304: LD_VAR 0 6
71308: PPUSH
71309: LD_INT 1
71311: PPUSH
71312: CALL_OW 259
71316: PUSH
71317: LD_REAL  1.15000000000000E+0000
71320: MUL
71321: MUL
71322: ST_TO_ADDR
// end ; unit_vehicle :
71323: GO 72147
71325: LD_INT 2
71327: DOUBLE
71328: EQUAL
71329: IFTRUE 71333
71331: GO 72135
71333: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71334: LD_VAR 0 6
71338: PPUSH
71339: CALL_OW 264
71343: PUSH
71344: LD_INT 2
71346: PUSH
71347: LD_INT 42
71349: PUSH
71350: LD_INT 24
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: LIST
71357: IN
71358: IFFALSE 71379
// points := [ 25 , 5 , 3 ] ;
71360: LD_ADDR_VAR 0 9
71364: PUSH
71365: LD_INT 25
71367: PUSH
71368: LD_INT 5
71370: PUSH
71371: LD_INT 3
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: LIST
71378: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71379: LD_VAR 0 6
71383: PPUSH
71384: CALL_OW 264
71388: PUSH
71389: LD_INT 4
71391: PUSH
71392: LD_INT 43
71394: PUSH
71395: LD_INT 25
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: LIST
71402: IN
71403: IFFALSE 71424
// points := [ 40 , 15 , 5 ] ;
71405: LD_ADDR_VAR 0 9
71409: PUSH
71410: LD_INT 40
71412: PUSH
71413: LD_INT 15
71415: PUSH
71416: LD_INT 5
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71424: LD_VAR 0 6
71428: PPUSH
71429: CALL_OW 264
71433: PUSH
71434: LD_INT 3
71436: PUSH
71437: LD_INT 23
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: IN
71444: IFFALSE 71465
// points := [ 7 , 25 , 8 ] ;
71446: LD_ADDR_VAR 0 9
71450: PUSH
71451: LD_INT 7
71453: PUSH
71454: LD_INT 25
71456: PUSH
71457: LD_INT 8
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71465: LD_VAR 0 6
71469: PPUSH
71470: CALL_OW 264
71474: PUSH
71475: LD_INT 5
71477: PUSH
71478: LD_INT 27
71480: PUSH
71481: LD_INT 44
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: LIST
71488: IN
71489: IFFALSE 71510
// points := [ 14 , 50 , 16 ] ;
71491: LD_ADDR_VAR 0 9
71495: PUSH
71496: LD_INT 14
71498: PUSH
71499: LD_INT 50
71501: PUSH
71502: LD_INT 16
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: LIST
71509: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71510: LD_VAR 0 6
71514: PPUSH
71515: CALL_OW 264
71519: PUSH
71520: LD_INT 6
71522: PUSH
71523: LD_INT 46
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: IN
71530: IFFALSE 71551
// points := [ 32 , 120 , 70 ] ;
71532: LD_ADDR_VAR 0 9
71536: PUSH
71537: LD_INT 32
71539: PUSH
71540: LD_INT 120
71542: PUSH
71543: LD_INT 70
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: LIST
71550: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71551: LD_VAR 0 6
71555: PPUSH
71556: CALL_OW 264
71560: PUSH
71561: LD_INT 7
71563: PUSH
71564: LD_INT 28
71566: PUSH
71567: LD_INT 45
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: LIST
71574: IN
71575: IFFALSE 71596
// points := [ 35 , 20 , 45 ] ;
71577: LD_ADDR_VAR 0 9
71581: PUSH
71582: LD_INT 35
71584: PUSH
71585: LD_INT 20
71587: PUSH
71588: LD_INT 45
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: LIST
71595: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71596: LD_VAR 0 6
71600: PPUSH
71601: CALL_OW 264
71605: PUSH
71606: LD_INT 47
71608: PUSH
71609: EMPTY
71610: LIST
71611: IN
71612: IFFALSE 71633
// points := [ 67 , 45 , 75 ] ;
71614: LD_ADDR_VAR 0 9
71618: PUSH
71619: LD_INT 67
71621: PUSH
71622: LD_INT 45
71624: PUSH
71625: LD_INT 75
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: LIST
71632: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71633: LD_VAR 0 6
71637: PPUSH
71638: CALL_OW 264
71642: PUSH
71643: LD_INT 26
71645: PUSH
71646: EMPTY
71647: LIST
71648: IN
71649: IFFALSE 71670
// points := [ 120 , 30 , 80 ] ;
71651: LD_ADDR_VAR 0 9
71655: PUSH
71656: LD_INT 120
71658: PUSH
71659: LD_INT 30
71661: PUSH
71662: LD_INT 80
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: LIST
71669: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71670: LD_VAR 0 6
71674: PPUSH
71675: CALL_OW 264
71679: PUSH
71680: LD_INT 22
71682: PUSH
71683: EMPTY
71684: LIST
71685: IN
71686: IFFALSE 71707
// points := [ 40 , 1 , 1 ] ;
71688: LD_ADDR_VAR 0 9
71692: PUSH
71693: LD_INT 40
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: LD_INT 1
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: LIST
71706: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71707: LD_VAR 0 6
71711: PPUSH
71712: CALL_OW 264
71716: PUSH
71717: LD_INT 29
71719: PUSH
71720: EMPTY
71721: LIST
71722: IN
71723: IFFALSE 71744
// points := [ 70 , 200 , 400 ] ;
71725: LD_ADDR_VAR 0 9
71729: PUSH
71730: LD_INT 70
71732: PUSH
71733: LD_INT 200
71735: PUSH
71736: LD_INT 400
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: LIST
71743: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71744: LD_VAR 0 6
71748: PPUSH
71749: CALL_OW 264
71753: PUSH
71754: LD_INT 14
71756: PUSH
71757: LD_INT 53
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: IN
71764: IFFALSE 71785
// points := [ 40 , 10 , 20 ] ;
71766: LD_ADDR_VAR 0 9
71770: PUSH
71771: LD_INT 40
71773: PUSH
71774: LD_INT 10
71776: PUSH
71777: LD_INT 20
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: LIST
71784: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71785: LD_VAR 0 6
71789: PPUSH
71790: CALL_OW 264
71794: PUSH
71795: LD_INT 9
71797: PUSH
71798: EMPTY
71799: LIST
71800: IN
71801: IFFALSE 71822
// points := [ 5 , 70 , 20 ] ;
71803: LD_ADDR_VAR 0 9
71807: PUSH
71808: LD_INT 5
71810: PUSH
71811: LD_INT 70
71813: PUSH
71814: LD_INT 20
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: LIST
71821: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71822: LD_VAR 0 6
71826: PPUSH
71827: CALL_OW 264
71831: PUSH
71832: LD_INT 10
71834: PUSH
71835: EMPTY
71836: LIST
71837: IN
71838: IFFALSE 71859
// points := [ 35 , 110 , 70 ] ;
71840: LD_ADDR_VAR 0 9
71844: PUSH
71845: LD_INT 35
71847: PUSH
71848: LD_INT 110
71850: PUSH
71851: LD_INT 70
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: LIST
71858: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71859: LD_VAR 0 6
71863: PPUSH
71864: CALL_OW 265
71868: PUSH
71869: LD_INT 25
71871: EQUAL
71872: IFFALSE 71893
// points := [ 80 , 65 , 100 ] ;
71874: LD_ADDR_VAR 0 9
71878: PUSH
71879: LD_INT 80
71881: PUSH
71882: LD_INT 65
71884: PUSH
71885: LD_INT 100
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: LIST
71892: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71893: LD_VAR 0 6
71897: PPUSH
71898: CALL_OW 263
71902: PUSH
71903: LD_INT 1
71905: EQUAL
71906: IFFALSE 71941
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71908: LD_ADDR_VAR 0 10
71912: PUSH
71913: LD_VAR 0 10
71917: PUSH
71918: LD_VAR 0 6
71922: PPUSH
71923: CALL_OW 311
71927: PPUSH
71928: LD_INT 3
71930: PPUSH
71931: CALL_OW 259
71935: PUSH
71936: LD_INT 4
71938: MUL
71939: MUL
71940: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71941: LD_VAR 0 6
71945: PPUSH
71946: CALL_OW 263
71950: PUSH
71951: LD_INT 2
71953: EQUAL
71954: IFFALSE 72005
// begin j := IsControledBy ( i ) ;
71956: LD_ADDR_VAR 0 7
71960: PUSH
71961: LD_VAR 0 6
71965: PPUSH
71966: CALL_OW 312
71970: ST_TO_ADDR
// if j then
71971: LD_VAR 0 7
71975: IFFALSE 72005
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71977: LD_ADDR_VAR 0 10
71981: PUSH
71982: LD_VAR 0 10
71986: PUSH
71987: LD_VAR 0 7
71991: PPUSH
71992: LD_INT 3
71994: PPUSH
71995: CALL_OW 259
71999: PUSH
72000: LD_INT 3
72002: MUL
72003: MUL
72004: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72005: LD_VAR 0 6
72009: PPUSH
72010: CALL_OW 264
72014: PUSH
72015: LD_INT 5
72017: PUSH
72018: LD_INT 6
72020: PUSH
72021: LD_INT 46
72023: PUSH
72024: LD_INT 44
72026: PUSH
72027: LD_INT 47
72029: PUSH
72030: LD_INT 45
72032: PUSH
72033: LD_INT 28
72035: PUSH
72036: LD_INT 7
72038: PUSH
72039: LD_INT 27
72041: PUSH
72042: LD_INT 29
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: IN
72057: PUSH
72058: LD_VAR 0 1
72062: PPUSH
72063: LD_INT 52
72065: PPUSH
72066: CALL_OW 321
72070: PUSH
72071: LD_INT 2
72073: EQUAL
72074: AND
72075: IFFALSE 72092
// bpoints := bpoints * 1.2 ;
72077: LD_ADDR_VAR 0 10
72081: PUSH
72082: LD_VAR 0 10
72086: PUSH
72087: LD_REAL  1.20000000000000E+0000
72090: MUL
72091: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72092: LD_VAR 0 6
72096: PPUSH
72097: CALL_OW 264
72101: PUSH
72102: LD_INT 6
72104: PUSH
72105: LD_INT 46
72107: PUSH
72108: LD_INT 47
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: LIST
72115: IN
72116: IFFALSE 72133
// bpoints := bpoints * 1.2 ;
72118: LD_ADDR_VAR 0 10
72122: PUSH
72123: LD_VAR 0 10
72127: PUSH
72128: LD_REAL  1.20000000000000E+0000
72131: MUL
72132: ST_TO_ADDR
// end ; unit_building :
72133: GO 72147
72135: LD_INT 3
72137: DOUBLE
72138: EQUAL
72139: IFTRUE 72143
72141: GO 72146
72143: POP
// ; end ;
72144: GO 72147
72146: POP
// for j = 1 to 3 do
72147: LD_ADDR_VAR 0 7
72151: PUSH
72152: DOUBLE
72153: LD_INT 1
72155: DEC
72156: ST_TO_ADDR
72157: LD_INT 3
72159: PUSH
72160: FOR_TO
72161: IFFALSE 72214
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72163: LD_ADDR_VAR 0 5
72167: PUSH
72168: LD_VAR 0 5
72172: PPUSH
72173: LD_VAR 0 7
72177: PPUSH
72178: LD_VAR 0 5
72182: PUSH
72183: LD_VAR 0 7
72187: ARRAY
72188: PUSH
72189: LD_VAR 0 9
72193: PUSH
72194: LD_VAR 0 7
72198: ARRAY
72199: PUSH
72200: LD_VAR 0 10
72204: MUL
72205: PLUS
72206: PPUSH
72207: CALL_OW 1
72211: ST_TO_ADDR
72212: GO 72160
72214: POP
72215: POP
// end ;
72216: GO 70699
72218: POP
72219: POP
// result := Replace ( result , 4 , tmp ) ;
72220: LD_ADDR_VAR 0 5
72224: PUSH
72225: LD_VAR 0 5
72229: PPUSH
72230: LD_INT 4
72232: PPUSH
72233: LD_VAR 0 8
72237: PPUSH
72238: CALL_OW 1
72242: ST_TO_ADDR
// end ;
72243: LD_VAR 0 5
72247: RET
// export function DangerAtRange ( unit , range ) ; begin
72248: LD_INT 0
72250: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72251: LD_ADDR_VAR 0 3
72255: PUSH
72256: LD_VAR 0 1
72260: PPUSH
72261: CALL_OW 255
72265: PPUSH
72266: LD_VAR 0 1
72270: PPUSH
72271: CALL_OW 250
72275: PPUSH
72276: LD_VAR 0 1
72280: PPUSH
72281: CALL_OW 251
72285: PPUSH
72286: LD_VAR 0 2
72290: PPUSH
72291: CALL 70551 0 4
72295: ST_TO_ADDR
// end ;
72296: LD_VAR 0 3
72300: RET
// export function DangerInArea ( side , area ) ; begin
72301: LD_INT 0
72303: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72304: LD_ADDR_VAR 0 3
72308: PUSH
72309: LD_VAR 0 2
72313: PPUSH
72314: LD_INT 81
72316: PUSH
72317: LD_VAR 0 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PPUSH
72326: CALL_OW 70
72330: ST_TO_ADDR
// end ;
72331: LD_VAR 0 3
72335: RET
// export function IsExtension ( b ) ; begin
72336: LD_INT 0
72338: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72339: LD_ADDR_VAR 0 2
72343: PUSH
72344: LD_VAR 0 1
72348: PUSH
72349: LD_INT 23
72351: PUSH
72352: LD_INT 20
72354: PUSH
72355: LD_INT 22
72357: PUSH
72358: LD_INT 17
72360: PUSH
72361: LD_INT 24
72363: PUSH
72364: LD_INT 21
72366: PUSH
72367: LD_INT 19
72369: PUSH
72370: LD_INT 16
72372: PUSH
72373: LD_INT 25
72375: PUSH
72376: LD_INT 18
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: IN
72391: ST_TO_ADDR
// end ;
72392: LD_VAR 0 2
72396: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72397: LD_INT 0
72399: PPUSH
72400: PPUSH
72401: PPUSH
// result := [ ] ;
72402: LD_ADDR_VAR 0 3
72406: PUSH
72407: EMPTY
72408: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72409: LD_ADDR_VAR 0 4
72413: PUSH
72414: LD_VAR 0 2
72418: PPUSH
72419: LD_INT 21
72421: PUSH
72422: LD_INT 3
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PPUSH
72429: CALL_OW 70
72433: ST_TO_ADDR
// if not tmp then
72434: LD_VAR 0 4
72438: NOT
72439: IFFALSE 72443
// exit ;
72441: GO 72501
// for i in tmp do
72443: LD_ADDR_VAR 0 5
72447: PUSH
72448: LD_VAR 0 4
72452: PUSH
72453: FOR_IN
72454: IFFALSE 72489
// if GetBase ( i ) <> base then
72456: LD_VAR 0 5
72460: PPUSH
72461: CALL_OW 274
72465: PUSH
72466: LD_VAR 0 1
72470: NONEQUAL
72471: IFFALSE 72487
// ComLinkToBase ( base , i ) ;
72473: LD_VAR 0 1
72477: PPUSH
72478: LD_VAR 0 5
72482: PPUSH
72483: CALL_OW 169
72487: GO 72453
72489: POP
72490: POP
// result := tmp ;
72491: LD_ADDR_VAR 0 3
72495: PUSH
72496: LD_VAR 0 4
72500: ST_TO_ADDR
// end ;
72501: LD_VAR 0 3
72505: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72506: LD_INT 0
72508: PPUSH
72509: PPUSH
// if BuildingStatus ( b ) = bs_build then
72510: LD_VAR 0 2
72514: PPUSH
72515: CALL_OW 461
72519: PUSH
72520: LD_INT 1
72522: EQUAL
72523: IFFALSE 72583
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72525: LD_VAR 0 1
72529: PPUSH
72530: LD_STRING h
72532: PUSH
72533: LD_VAR 0 2
72537: PPUSH
72538: CALL_OW 250
72542: PUSH
72543: LD_VAR 0 2
72547: PPUSH
72548: CALL_OW 251
72552: PUSH
72553: LD_VAR 0 2
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: LD_INT 0
72563: PUSH
72564: LD_INT 0
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: LIST
72575: PUSH
72576: EMPTY
72577: LIST
72578: PPUSH
72579: CALL_OW 446
// end ;
72583: LD_VAR 0 3
72587: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72588: LD_INT 0
72590: PPUSH
72591: PPUSH
72592: PPUSH
72593: PPUSH
72594: PPUSH
72595: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72596: LD_VAR 0 1
72600: NOT
72601: PUSH
72602: LD_VAR 0 1
72606: PPUSH
72607: CALL_OW 263
72611: PUSH
72612: LD_INT 2
72614: EQUAL
72615: NOT
72616: OR
72617: IFFALSE 72621
// exit ;
72619: GO 72937
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72621: LD_ADDR_VAR 0 6
72625: PUSH
72626: LD_INT 22
72628: PUSH
72629: LD_VAR 0 1
72633: PPUSH
72634: CALL_OW 255
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 2
72645: PUSH
72646: LD_INT 30
72648: PUSH
72649: LD_INT 36
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 34
72658: PUSH
72659: LD_INT 31
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: LIST
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PPUSH
72675: CALL_OW 69
72679: ST_TO_ADDR
// if not tmp then
72680: LD_VAR 0 6
72684: NOT
72685: IFFALSE 72689
// exit ;
72687: GO 72937
// result := [ ] ;
72689: LD_ADDR_VAR 0 2
72693: PUSH
72694: EMPTY
72695: ST_TO_ADDR
// for i in tmp do
72696: LD_ADDR_VAR 0 3
72700: PUSH
72701: LD_VAR 0 6
72705: PUSH
72706: FOR_IN
72707: IFFALSE 72778
// begin t := UnitsInside ( i ) ;
72709: LD_ADDR_VAR 0 4
72713: PUSH
72714: LD_VAR 0 3
72718: PPUSH
72719: CALL_OW 313
72723: ST_TO_ADDR
// if t then
72724: LD_VAR 0 4
72728: IFFALSE 72776
// for j in t do
72730: LD_ADDR_VAR 0 7
72734: PUSH
72735: LD_VAR 0 4
72739: PUSH
72740: FOR_IN
72741: IFFALSE 72774
// result := Insert ( result , result + 1 , j ) ;
72743: LD_ADDR_VAR 0 2
72747: PUSH
72748: LD_VAR 0 2
72752: PPUSH
72753: LD_VAR 0 2
72757: PUSH
72758: LD_INT 1
72760: PLUS
72761: PPUSH
72762: LD_VAR 0 7
72766: PPUSH
72767: CALL_OW 2
72771: ST_TO_ADDR
72772: GO 72740
72774: POP
72775: POP
// end ;
72776: GO 72706
72778: POP
72779: POP
// if not result then
72780: LD_VAR 0 2
72784: NOT
72785: IFFALSE 72789
// exit ;
72787: GO 72937
// mech := result [ 1 ] ;
72789: LD_ADDR_VAR 0 5
72793: PUSH
72794: LD_VAR 0 2
72798: PUSH
72799: LD_INT 1
72801: ARRAY
72802: ST_TO_ADDR
// if result > 1 then
72803: LD_VAR 0 2
72807: PUSH
72808: LD_INT 1
72810: GREATER
72811: IFFALSE 72923
// for i = 2 to result do
72813: LD_ADDR_VAR 0 3
72817: PUSH
72818: DOUBLE
72819: LD_INT 2
72821: DEC
72822: ST_TO_ADDR
72823: LD_VAR 0 2
72827: PUSH
72828: FOR_TO
72829: IFFALSE 72921
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72831: LD_ADDR_VAR 0 4
72835: PUSH
72836: LD_VAR 0 2
72840: PUSH
72841: LD_VAR 0 3
72845: ARRAY
72846: PPUSH
72847: LD_INT 3
72849: PPUSH
72850: CALL_OW 259
72854: PUSH
72855: LD_VAR 0 2
72859: PUSH
72860: LD_VAR 0 3
72864: ARRAY
72865: PPUSH
72866: CALL_OW 432
72870: MINUS
72871: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72872: LD_VAR 0 4
72876: PUSH
72877: LD_VAR 0 5
72881: PPUSH
72882: LD_INT 3
72884: PPUSH
72885: CALL_OW 259
72889: PUSH
72890: LD_VAR 0 5
72894: PPUSH
72895: CALL_OW 432
72899: MINUS
72900: GREATEREQUAL
72901: IFFALSE 72919
// mech := result [ i ] ;
72903: LD_ADDR_VAR 0 5
72907: PUSH
72908: LD_VAR 0 2
72912: PUSH
72913: LD_VAR 0 3
72917: ARRAY
72918: ST_TO_ADDR
// end ;
72919: GO 72828
72921: POP
72922: POP
// ComLinkTo ( vehicle , mech ) ;
72923: LD_VAR 0 1
72927: PPUSH
72928: LD_VAR 0 5
72932: PPUSH
72933: CALL_OW 135
// end ;
72937: LD_VAR 0 2
72941: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72942: LD_INT 0
72944: PPUSH
72945: PPUSH
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
72950: PPUSH
72951: PPUSH
72952: PPUSH
72953: PPUSH
72954: PPUSH
72955: PPUSH
72956: PPUSH
// result := [ ] ;
72957: LD_ADDR_VAR 0 7
72961: PUSH
72962: EMPTY
72963: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
72964: LD_VAR 0 1
72968: PPUSH
72969: CALL_OW 266
72973: PUSH
72974: LD_INT 0
72976: PUSH
72977: LD_INT 1
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: IN
72984: NOT
72985: IFFALSE 72989
// exit ;
72987: GO 74620
// if name then
72989: LD_VAR 0 3
72993: IFFALSE 73009
// SetBName ( base_dep , name ) ;
72995: LD_VAR 0 1
72999: PPUSH
73000: LD_VAR 0 3
73004: PPUSH
73005: CALL_OW 500
// base := GetBase ( base_dep ) ;
73009: LD_ADDR_VAR 0 15
73013: PUSH
73014: LD_VAR 0 1
73018: PPUSH
73019: CALL_OW 274
73023: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73024: LD_ADDR_VAR 0 16
73028: PUSH
73029: LD_VAR 0 1
73033: PPUSH
73034: CALL_OW 255
73038: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73039: LD_ADDR_VAR 0 17
73043: PUSH
73044: LD_VAR 0 1
73048: PPUSH
73049: CALL_OW 248
73053: ST_TO_ADDR
// if sources then
73054: LD_VAR 0 5
73058: IFFALSE 73105
// for i = 1 to 3 do
73060: LD_ADDR_VAR 0 8
73064: PUSH
73065: DOUBLE
73066: LD_INT 1
73068: DEC
73069: ST_TO_ADDR
73070: LD_INT 3
73072: PUSH
73073: FOR_TO
73074: IFFALSE 73103
// AddResourceType ( base , i , sources [ i ] ) ;
73076: LD_VAR 0 15
73080: PPUSH
73081: LD_VAR 0 8
73085: PPUSH
73086: LD_VAR 0 5
73090: PUSH
73091: LD_VAR 0 8
73095: ARRAY
73096: PPUSH
73097: CALL_OW 276
73101: GO 73073
73103: POP
73104: POP
// buildings := GetBaseBuildings ( base , area ) ;
73105: LD_ADDR_VAR 0 18
73109: PUSH
73110: LD_VAR 0 15
73114: PPUSH
73115: LD_VAR 0 2
73119: PPUSH
73120: CALL 72397 0 2
73124: ST_TO_ADDR
// InitHc ;
73125: CALL_OW 19
// InitUc ;
73129: CALL_OW 18
// uc_side := side ;
73133: LD_ADDR_OWVAR 20
73137: PUSH
73138: LD_VAR 0 16
73142: ST_TO_ADDR
// uc_nation := nation ;
73143: LD_ADDR_OWVAR 21
73147: PUSH
73148: LD_VAR 0 17
73152: ST_TO_ADDR
// if buildings then
73153: LD_VAR 0 18
73157: IFFALSE 74479
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73159: LD_ADDR_VAR 0 19
73163: PUSH
73164: LD_VAR 0 18
73168: PPUSH
73169: LD_INT 2
73171: PUSH
73172: LD_INT 30
73174: PUSH
73175: LD_INT 29
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 30
73184: PUSH
73185: LD_INT 30
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: LIST
73196: PPUSH
73197: CALL_OW 72
73201: ST_TO_ADDR
// if tmp then
73202: LD_VAR 0 19
73206: IFFALSE 73254
// for i in tmp do
73208: LD_ADDR_VAR 0 8
73212: PUSH
73213: LD_VAR 0 19
73217: PUSH
73218: FOR_IN
73219: IFFALSE 73252
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73221: LD_VAR 0 8
73225: PPUSH
73226: CALL_OW 250
73230: PPUSH
73231: LD_VAR 0 8
73235: PPUSH
73236: CALL_OW 251
73240: PPUSH
73241: LD_VAR 0 16
73245: PPUSH
73246: CALL_OW 441
73250: GO 73218
73252: POP
73253: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73254: LD_VAR 0 18
73258: PPUSH
73259: LD_INT 2
73261: PUSH
73262: LD_INT 30
73264: PUSH
73265: LD_INT 32
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 30
73274: PUSH
73275: LD_INT 33
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: LIST
73286: PPUSH
73287: CALL_OW 72
73291: IFFALSE 73379
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73293: LD_ADDR_VAR 0 8
73297: PUSH
73298: LD_VAR 0 18
73302: PPUSH
73303: LD_INT 2
73305: PUSH
73306: LD_INT 30
73308: PUSH
73309: LD_INT 32
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 30
73318: PUSH
73319: LD_INT 33
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: LIST
73330: PPUSH
73331: CALL_OW 72
73335: PUSH
73336: FOR_IN
73337: IFFALSE 73377
// begin if not GetBWeapon ( i ) then
73339: LD_VAR 0 8
73343: PPUSH
73344: CALL_OW 269
73348: NOT
73349: IFFALSE 73375
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73351: LD_VAR 0 8
73355: PPUSH
73356: LD_VAR 0 8
73360: PPUSH
73361: LD_VAR 0 2
73365: PPUSH
73366: CALL 74625 0 2
73370: PPUSH
73371: CALL_OW 431
// end ;
73375: GO 73336
73377: POP
73378: POP
// end ; for i = 1 to personel do
73379: LD_ADDR_VAR 0 8
73383: PUSH
73384: DOUBLE
73385: LD_INT 1
73387: DEC
73388: ST_TO_ADDR
73389: LD_VAR 0 6
73393: PUSH
73394: FOR_TO
73395: IFFALSE 74459
// begin if i > 4 then
73397: LD_VAR 0 8
73401: PUSH
73402: LD_INT 4
73404: GREATER
73405: IFFALSE 73409
// break ;
73407: GO 74459
// case i of 1 :
73409: LD_VAR 0 8
73413: PUSH
73414: LD_INT 1
73416: DOUBLE
73417: EQUAL
73418: IFTRUE 73422
73420: GO 73502
73422: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73423: LD_ADDR_VAR 0 12
73427: PUSH
73428: LD_VAR 0 18
73432: PPUSH
73433: LD_INT 22
73435: PUSH
73436: LD_VAR 0 16
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 58
73447: PUSH
73448: EMPTY
73449: LIST
73450: PUSH
73451: LD_INT 2
73453: PUSH
73454: LD_INT 30
73456: PUSH
73457: LD_INT 32
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 30
73466: PUSH
73467: LD_INT 4
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 30
73476: PUSH
73477: LD_INT 5
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: LIST
73494: PPUSH
73495: CALL_OW 72
73499: ST_TO_ADDR
73500: GO 73724
73502: LD_INT 2
73504: DOUBLE
73505: EQUAL
73506: IFTRUE 73510
73508: GO 73572
73510: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73511: LD_ADDR_VAR 0 12
73515: PUSH
73516: LD_VAR 0 18
73520: PPUSH
73521: LD_INT 22
73523: PUSH
73524: LD_VAR 0 16
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 2
73535: PUSH
73536: LD_INT 30
73538: PUSH
73539: LD_INT 0
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 30
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: LIST
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PPUSH
73565: CALL_OW 72
73569: ST_TO_ADDR
73570: GO 73724
73572: LD_INT 3
73574: DOUBLE
73575: EQUAL
73576: IFTRUE 73580
73578: GO 73642
73580: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73581: LD_ADDR_VAR 0 12
73585: PUSH
73586: LD_VAR 0 18
73590: PPUSH
73591: LD_INT 22
73593: PUSH
73594: LD_VAR 0 16
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 2
73605: PUSH
73606: LD_INT 30
73608: PUSH
73609: LD_INT 2
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 30
73618: PUSH
73619: LD_INT 3
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: LIST
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: PPUSH
73635: CALL_OW 72
73639: ST_TO_ADDR
73640: GO 73724
73642: LD_INT 4
73644: DOUBLE
73645: EQUAL
73646: IFTRUE 73650
73648: GO 73723
73650: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73651: LD_ADDR_VAR 0 12
73655: PUSH
73656: LD_VAR 0 18
73660: PPUSH
73661: LD_INT 22
73663: PUSH
73664: LD_VAR 0 16
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 2
73675: PUSH
73676: LD_INT 30
73678: PUSH
73679: LD_INT 6
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 30
73688: PUSH
73689: LD_INT 7
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 30
73698: PUSH
73699: LD_INT 8
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PPUSH
73716: CALL_OW 72
73720: ST_TO_ADDR
73721: GO 73724
73723: POP
// if i = 1 then
73724: LD_VAR 0 8
73728: PUSH
73729: LD_INT 1
73731: EQUAL
73732: IFFALSE 73843
// begin tmp := [ ] ;
73734: LD_ADDR_VAR 0 19
73738: PUSH
73739: EMPTY
73740: ST_TO_ADDR
// for j in f do
73741: LD_ADDR_VAR 0 9
73745: PUSH
73746: LD_VAR 0 12
73750: PUSH
73751: FOR_IN
73752: IFFALSE 73825
// if GetBType ( j ) = b_bunker then
73754: LD_VAR 0 9
73758: PPUSH
73759: CALL_OW 266
73763: PUSH
73764: LD_INT 32
73766: EQUAL
73767: IFFALSE 73794
// tmp := Insert ( tmp , 1 , j ) else
73769: LD_ADDR_VAR 0 19
73773: PUSH
73774: LD_VAR 0 19
73778: PPUSH
73779: LD_INT 1
73781: PPUSH
73782: LD_VAR 0 9
73786: PPUSH
73787: CALL_OW 2
73791: ST_TO_ADDR
73792: GO 73823
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73794: LD_ADDR_VAR 0 19
73798: PUSH
73799: LD_VAR 0 19
73803: PPUSH
73804: LD_VAR 0 19
73808: PUSH
73809: LD_INT 1
73811: PLUS
73812: PPUSH
73813: LD_VAR 0 9
73817: PPUSH
73818: CALL_OW 2
73822: ST_TO_ADDR
73823: GO 73751
73825: POP
73826: POP
// if tmp then
73827: LD_VAR 0 19
73831: IFFALSE 73843
// f := tmp ;
73833: LD_ADDR_VAR 0 12
73837: PUSH
73838: LD_VAR 0 19
73842: ST_TO_ADDR
// end ; x := personel [ i ] ;
73843: LD_ADDR_VAR 0 13
73847: PUSH
73848: LD_VAR 0 6
73852: PUSH
73853: LD_VAR 0 8
73857: ARRAY
73858: ST_TO_ADDR
// if x = - 1 then
73859: LD_VAR 0 13
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: EQUAL
73868: IFFALSE 74077
// begin for j in f do
73870: LD_ADDR_VAR 0 9
73874: PUSH
73875: LD_VAR 0 12
73879: PUSH
73880: FOR_IN
73881: IFFALSE 74073
// repeat InitHc ;
73883: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73887: LD_VAR 0 9
73891: PPUSH
73892: CALL_OW 266
73896: PUSH
73897: LD_INT 5
73899: EQUAL
73900: IFFALSE 73970
// begin if UnitsInside ( j ) < 3 then
73902: LD_VAR 0 9
73906: PPUSH
73907: CALL_OW 313
73911: PUSH
73912: LD_INT 3
73914: LESS
73915: IFFALSE 73951
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73917: LD_INT 0
73919: PPUSH
73920: LD_INT 5
73922: PUSH
73923: LD_INT 8
73925: PUSH
73926: LD_INT 9
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: LIST
73933: PUSH
73934: LD_VAR 0 17
73938: ARRAY
73939: PPUSH
73940: LD_VAR 0 4
73944: PPUSH
73945: CALL_OW 380
73949: GO 73968
// PrepareHuman ( false , i , skill ) ;
73951: LD_INT 0
73953: PPUSH
73954: LD_VAR 0 8
73958: PPUSH
73959: LD_VAR 0 4
73963: PPUSH
73964: CALL_OW 380
// end else
73968: GO 73987
// PrepareHuman ( false , i , skill ) ;
73970: LD_INT 0
73972: PPUSH
73973: LD_VAR 0 8
73977: PPUSH
73978: LD_VAR 0 4
73982: PPUSH
73983: CALL_OW 380
// un := CreateHuman ;
73987: LD_ADDR_VAR 0 14
73991: PUSH
73992: CALL_OW 44
73996: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73997: LD_ADDR_VAR 0 7
74001: PUSH
74002: LD_VAR 0 7
74006: PPUSH
74007: LD_INT 1
74009: PPUSH
74010: LD_VAR 0 14
74014: PPUSH
74015: CALL_OW 2
74019: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74020: LD_VAR 0 14
74024: PPUSH
74025: LD_VAR 0 9
74029: PPUSH
74030: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74034: LD_VAR 0 9
74038: PPUSH
74039: CALL_OW 313
74043: PUSH
74044: LD_INT 6
74046: EQUAL
74047: PUSH
74048: LD_VAR 0 9
74052: PPUSH
74053: CALL_OW 266
74057: PUSH
74058: LD_INT 32
74060: PUSH
74061: LD_INT 31
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: IN
74068: OR
74069: IFFALSE 73883
74071: GO 73880
74073: POP
74074: POP
// end else
74075: GO 74457
// for j = 1 to x do
74077: LD_ADDR_VAR 0 9
74081: PUSH
74082: DOUBLE
74083: LD_INT 1
74085: DEC
74086: ST_TO_ADDR
74087: LD_VAR 0 13
74091: PUSH
74092: FOR_TO
74093: IFFALSE 74455
// begin InitHc ;
74095: CALL_OW 19
// if not f then
74099: LD_VAR 0 12
74103: NOT
74104: IFFALSE 74193
// begin PrepareHuman ( false , i , skill ) ;
74106: LD_INT 0
74108: PPUSH
74109: LD_VAR 0 8
74113: PPUSH
74114: LD_VAR 0 4
74118: PPUSH
74119: CALL_OW 380
// un := CreateHuman ;
74123: LD_ADDR_VAR 0 14
74127: PUSH
74128: CALL_OW 44
74132: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74133: LD_ADDR_VAR 0 7
74137: PUSH
74138: LD_VAR 0 7
74142: PPUSH
74143: LD_INT 1
74145: PPUSH
74146: LD_VAR 0 14
74150: PPUSH
74151: CALL_OW 2
74155: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74156: LD_VAR 0 14
74160: PPUSH
74161: LD_VAR 0 1
74165: PPUSH
74166: CALL_OW 250
74170: PPUSH
74171: LD_VAR 0 1
74175: PPUSH
74176: CALL_OW 251
74180: PPUSH
74181: LD_INT 10
74183: PPUSH
74184: LD_INT 0
74186: PPUSH
74187: CALL_OW 50
// continue ;
74191: GO 74092
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74193: LD_VAR 0 12
74197: PUSH
74198: LD_INT 1
74200: ARRAY
74201: PPUSH
74202: CALL_OW 313
74206: PUSH
74207: LD_VAR 0 12
74211: PUSH
74212: LD_INT 1
74214: ARRAY
74215: PPUSH
74216: CALL_OW 266
74220: PUSH
74221: LD_INT 32
74223: PUSH
74224: LD_INT 31
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: IN
74231: AND
74232: PUSH
74233: LD_VAR 0 12
74237: PUSH
74238: LD_INT 1
74240: ARRAY
74241: PPUSH
74242: CALL_OW 313
74246: PUSH
74247: LD_INT 6
74249: EQUAL
74250: OR
74251: IFFALSE 74271
// f := Delete ( f , 1 ) ;
74253: LD_ADDR_VAR 0 12
74257: PUSH
74258: LD_VAR 0 12
74262: PPUSH
74263: LD_INT 1
74265: PPUSH
74266: CALL_OW 3
74270: ST_TO_ADDR
// if not f then
74271: LD_VAR 0 12
74275: NOT
74276: IFFALSE 74294
// begin x := x + 2 ;
74278: LD_ADDR_VAR 0 13
74282: PUSH
74283: LD_VAR 0 13
74287: PUSH
74288: LD_INT 2
74290: PLUS
74291: ST_TO_ADDR
// continue ;
74292: GO 74092
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74294: LD_VAR 0 12
74298: PUSH
74299: LD_INT 1
74301: ARRAY
74302: PPUSH
74303: CALL_OW 266
74307: PUSH
74308: LD_INT 5
74310: EQUAL
74311: IFFALSE 74385
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74313: LD_VAR 0 12
74317: PUSH
74318: LD_INT 1
74320: ARRAY
74321: PPUSH
74322: CALL_OW 313
74326: PUSH
74327: LD_INT 3
74329: LESS
74330: IFFALSE 74366
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74332: LD_INT 0
74334: PPUSH
74335: LD_INT 5
74337: PUSH
74338: LD_INT 8
74340: PUSH
74341: LD_INT 9
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: LIST
74348: PUSH
74349: LD_VAR 0 17
74353: ARRAY
74354: PPUSH
74355: LD_VAR 0 4
74359: PPUSH
74360: CALL_OW 380
74364: GO 74383
// PrepareHuman ( false , i , skill ) ;
74366: LD_INT 0
74368: PPUSH
74369: LD_VAR 0 8
74373: PPUSH
74374: LD_VAR 0 4
74378: PPUSH
74379: CALL_OW 380
// end else
74383: GO 74402
// PrepareHuman ( false , i , skill ) ;
74385: LD_INT 0
74387: PPUSH
74388: LD_VAR 0 8
74392: PPUSH
74393: LD_VAR 0 4
74397: PPUSH
74398: CALL_OW 380
// un := CreateHuman ;
74402: LD_ADDR_VAR 0 14
74406: PUSH
74407: CALL_OW 44
74411: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74412: LD_ADDR_VAR 0 7
74416: PUSH
74417: LD_VAR 0 7
74421: PPUSH
74422: LD_INT 1
74424: PPUSH
74425: LD_VAR 0 14
74429: PPUSH
74430: CALL_OW 2
74434: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74435: LD_VAR 0 14
74439: PPUSH
74440: LD_VAR 0 12
74444: PUSH
74445: LD_INT 1
74447: ARRAY
74448: PPUSH
74449: CALL_OW 52
// end ;
74453: GO 74092
74455: POP
74456: POP
// end ;
74457: GO 73394
74459: POP
74460: POP
// result := result ^ buildings ;
74461: LD_ADDR_VAR 0 7
74465: PUSH
74466: LD_VAR 0 7
74470: PUSH
74471: LD_VAR 0 18
74475: ADD
74476: ST_TO_ADDR
// end else
74477: GO 74620
// begin for i = 1 to personel do
74479: LD_ADDR_VAR 0 8
74483: PUSH
74484: DOUBLE
74485: LD_INT 1
74487: DEC
74488: ST_TO_ADDR
74489: LD_VAR 0 6
74493: PUSH
74494: FOR_TO
74495: IFFALSE 74618
// begin if i > 4 then
74497: LD_VAR 0 8
74501: PUSH
74502: LD_INT 4
74504: GREATER
74505: IFFALSE 74509
// break ;
74507: GO 74618
// x := personel [ i ] ;
74509: LD_ADDR_VAR 0 13
74513: PUSH
74514: LD_VAR 0 6
74518: PUSH
74519: LD_VAR 0 8
74523: ARRAY
74524: ST_TO_ADDR
// if x = - 1 then
74525: LD_VAR 0 13
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: EQUAL
74534: IFFALSE 74538
// continue ;
74536: GO 74494
// PrepareHuman ( false , i , skill ) ;
74538: LD_INT 0
74540: PPUSH
74541: LD_VAR 0 8
74545: PPUSH
74546: LD_VAR 0 4
74550: PPUSH
74551: CALL_OW 380
// un := CreateHuman ;
74555: LD_ADDR_VAR 0 14
74559: PUSH
74560: CALL_OW 44
74564: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74565: LD_VAR 0 14
74569: PPUSH
74570: LD_VAR 0 1
74574: PPUSH
74575: CALL_OW 250
74579: PPUSH
74580: LD_VAR 0 1
74584: PPUSH
74585: CALL_OW 251
74589: PPUSH
74590: LD_INT 10
74592: PPUSH
74593: LD_INT 0
74595: PPUSH
74596: CALL_OW 50
// result := result ^ un ;
74600: LD_ADDR_VAR 0 7
74604: PUSH
74605: LD_VAR 0 7
74609: PUSH
74610: LD_VAR 0 14
74614: ADD
74615: ST_TO_ADDR
// end ;
74616: GO 74494
74618: POP
74619: POP
// end ; end ;
74620: LD_VAR 0 7
74624: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74625: LD_INT 0
74627: PPUSH
74628: PPUSH
74629: PPUSH
74630: PPUSH
74631: PPUSH
74632: PPUSH
74633: PPUSH
74634: PPUSH
74635: PPUSH
74636: PPUSH
74637: PPUSH
74638: PPUSH
74639: PPUSH
74640: PPUSH
74641: PPUSH
74642: PPUSH
// result := false ;
74643: LD_ADDR_VAR 0 3
74647: PUSH
74648: LD_INT 0
74650: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74651: LD_VAR 0 1
74655: NOT
74656: PUSH
74657: LD_VAR 0 1
74661: PPUSH
74662: CALL_OW 266
74666: PUSH
74667: LD_INT 32
74669: PUSH
74670: LD_INT 33
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: IN
74677: NOT
74678: OR
74679: IFFALSE 74683
// exit ;
74681: GO 75819
// nat := GetNation ( tower ) ;
74683: LD_ADDR_VAR 0 12
74687: PUSH
74688: LD_VAR 0 1
74692: PPUSH
74693: CALL_OW 248
74697: ST_TO_ADDR
// side := GetSide ( tower ) ;
74698: LD_ADDR_VAR 0 16
74702: PUSH
74703: LD_VAR 0 1
74707: PPUSH
74708: CALL_OW 255
74712: ST_TO_ADDR
// x := GetX ( tower ) ;
74713: LD_ADDR_VAR 0 10
74717: PUSH
74718: LD_VAR 0 1
74722: PPUSH
74723: CALL_OW 250
74727: ST_TO_ADDR
// y := GetY ( tower ) ;
74728: LD_ADDR_VAR 0 11
74732: PUSH
74733: LD_VAR 0 1
74737: PPUSH
74738: CALL_OW 251
74742: ST_TO_ADDR
// if not x or not y then
74743: LD_VAR 0 10
74747: NOT
74748: PUSH
74749: LD_VAR 0 11
74753: NOT
74754: OR
74755: IFFALSE 74759
// exit ;
74757: GO 75819
// weapon := 0 ;
74759: LD_ADDR_VAR 0 18
74763: PUSH
74764: LD_INT 0
74766: ST_TO_ADDR
// fac_list := [ ] ;
74767: LD_ADDR_VAR 0 17
74771: PUSH
74772: EMPTY
74773: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
74774: LD_ADDR_VAR 0 6
74778: PUSH
74779: LD_VAR 0 1
74783: PPUSH
74784: CALL_OW 274
74788: PPUSH
74789: LD_VAR 0 2
74793: PPUSH
74794: CALL 72397 0 2
74798: PPUSH
74799: LD_INT 30
74801: PUSH
74802: LD_INT 3
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PPUSH
74809: CALL_OW 72
74813: ST_TO_ADDR
// if not factories then
74814: LD_VAR 0 6
74818: NOT
74819: IFFALSE 74823
// exit ;
74821: GO 75819
// for i in factories do
74823: LD_ADDR_VAR 0 8
74827: PUSH
74828: LD_VAR 0 6
74832: PUSH
74833: FOR_IN
74834: IFFALSE 74859
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74836: LD_ADDR_VAR 0 17
74840: PUSH
74841: LD_VAR 0 17
74845: PUSH
74846: LD_VAR 0 8
74850: PPUSH
74851: CALL_OW 478
74855: UNION
74856: ST_TO_ADDR
74857: GO 74833
74859: POP
74860: POP
// if not fac_list then
74861: LD_VAR 0 17
74865: NOT
74866: IFFALSE 74870
// exit ;
74868: GO 75819
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74870: LD_ADDR_VAR 0 5
74874: PUSH
74875: LD_INT 4
74877: PUSH
74878: LD_INT 5
74880: PUSH
74881: LD_INT 9
74883: PUSH
74884: LD_INT 10
74886: PUSH
74887: LD_INT 6
74889: PUSH
74890: LD_INT 7
74892: PUSH
74893: LD_INT 11
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 27
74907: PUSH
74908: LD_INT 28
74910: PUSH
74911: LD_INT 26
74913: PUSH
74914: LD_INT 30
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 43
74925: PUSH
74926: LD_INT 44
74928: PUSH
74929: LD_INT 46
74931: PUSH
74932: LD_INT 45
74934: PUSH
74935: LD_INT 47
74937: PUSH
74938: LD_INT 49
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: LIST
74953: PUSH
74954: LD_VAR 0 12
74958: ARRAY
74959: ST_TO_ADDR
// for i in list do
74960: LD_ADDR_VAR 0 8
74964: PUSH
74965: LD_VAR 0 5
74969: PUSH
74970: FOR_IN
74971: IFFALSE 75004
// if not i in fac_list then
74973: LD_VAR 0 8
74977: PUSH
74978: LD_VAR 0 17
74982: IN
74983: NOT
74984: IFFALSE 75002
// list := list diff i ;
74986: LD_ADDR_VAR 0 5
74990: PUSH
74991: LD_VAR 0 5
74995: PUSH
74996: LD_VAR 0 8
75000: DIFF
75001: ST_TO_ADDR
75002: GO 74970
75004: POP
75005: POP
// if not list then
75006: LD_VAR 0 5
75010: NOT
75011: IFFALSE 75015
// exit ;
75013: GO 75819
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75015: LD_VAR 0 12
75019: PUSH
75020: LD_INT 3
75022: EQUAL
75023: PUSH
75024: LD_INT 49
75026: PUSH
75027: LD_VAR 0 5
75031: IN
75032: AND
75033: PUSH
75034: LD_INT 31
75036: PPUSH
75037: LD_VAR 0 16
75041: PPUSH
75042: CALL_OW 321
75046: PUSH
75047: LD_INT 2
75049: EQUAL
75050: AND
75051: IFFALSE 75111
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75053: LD_INT 22
75055: PUSH
75056: LD_VAR 0 16
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 35
75067: PUSH
75068: LD_INT 49
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: PUSH
75075: LD_INT 91
75077: PUSH
75078: LD_VAR 0 1
75082: PUSH
75083: LD_INT 10
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: LIST
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: LIST
75095: PPUSH
75096: CALL_OW 69
75100: NOT
75101: IFFALSE 75111
// weapon := ru_time_lapser ;
75103: LD_ADDR_VAR 0 18
75107: PUSH
75108: LD_INT 49
75110: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75111: LD_VAR 0 12
75115: PUSH
75116: LD_INT 1
75118: PUSH
75119: LD_INT 2
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: IN
75126: PUSH
75127: LD_INT 11
75129: PUSH
75130: LD_VAR 0 5
75134: IN
75135: PUSH
75136: LD_INT 30
75138: PUSH
75139: LD_VAR 0 5
75143: IN
75144: OR
75145: AND
75146: PUSH
75147: LD_INT 6
75149: PPUSH
75150: LD_VAR 0 16
75154: PPUSH
75155: CALL_OW 321
75159: PUSH
75160: LD_INT 2
75162: EQUAL
75163: AND
75164: IFFALSE 75329
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75166: LD_INT 22
75168: PUSH
75169: LD_VAR 0 16
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 2
75180: PUSH
75181: LD_INT 35
75183: PUSH
75184: LD_INT 11
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 35
75193: PUSH
75194: LD_INT 30
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 91
75208: PUSH
75209: LD_VAR 0 1
75213: PUSH
75214: LD_INT 18
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: LIST
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: LIST
75226: PPUSH
75227: CALL_OW 69
75231: NOT
75232: PUSH
75233: LD_INT 22
75235: PUSH
75236: LD_VAR 0 16
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 2
75247: PUSH
75248: LD_INT 30
75250: PUSH
75251: LD_INT 32
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 30
75260: PUSH
75261: LD_INT 33
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 91
75275: PUSH
75276: LD_VAR 0 1
75280: PUSH
75281: LD_INT 12
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: LIST
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: LIST
75293: PUSH
75294: EMPTY
75295: LIST
75296: PPUSH
75297: CALL_OW 69
75301: PUSH
75302: LD_INT 2
75304: GREATER
75305: AND
75306: IFFALSE 75329
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75308: LD_ADDR_VAR 0 18
75312: PUSH
75313: LD_INT 11
75315: PUSH
75316: LD_INT 30
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_VAR 0 12
75327: ARRAY
75328: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75329: LD_VAR 0 18
75333: NOT
75334: PUSH
75335: LD_INT 40
75337: PPUSH
75338: LD_VAR 0 16
75342: PPUSH
75343: CALL_OW 321
75347: PUSH
75348: LD_INT 2
75350: EQUAL
75351: AND
75352: PUSH
75353: LD_INT 7
75355: PUSH
75356: LD_VAR 0 5
75360: IN
75361: PUSH
75362: LD_INT 28
75364: PUSH
75365: LD_VAR 0 5
75369: IN
75370: OR
75371: PUSH
75372: LD_INT 45
75374: PUSH
75375: LD_VAR 0 5
75379: IN
75380: OR
75381: AND
75382: IFFALSE 75636
// begin hex := GetHexInfo ( x , y ) ;
75384: LD_ADDR_VAR 0 4
75388: PUSH
75389: LD_VAR 0 10
75393: PPUSH
75394: LD_VAR 0 11
75398: PPUSH
75399: CALL_OW 546
75403: ST_TO_ADDR
// if hex [ 1 ] then
75404: LD_VAR 0 4
75408: PUSH
75409: LD_INT 1
75411: ARRAY
75412: IFFALSE 75416
// exit ;
75414: GO 75819
// height := hex [ 2 ] ;
75416: LD_ADDR_VAR 0 15
75420: PUSH
75421: LD_VAR 0 4
75425: PUSH
75426: LD_INT 2
75428: ARRAY
75429: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75430: LD_ADDR_VAR 0 14
75434: PUSH
75435: LD_INT 0
75437: PUSH
75438: LD_INT 2
75440: PUSH
75441: LD_INT 3
75443: PUSH
75444: LD_INT 5
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: ST_TO_ADDR
// for i in tmp do
75453: LD_ADDR_VAR 0 8
75457: PUSH
75458: LD_VAR 0 14
75462: PUSH
75463: FOR_IN
75464: IFFALSE 75634
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75466: LD_ADDR_VAR 0 9
75470: PUSH
75471: LD_VAR 0 10
75475: PPUSH
75476: LD_VAR 0 8
75480: PPUSH
75481: LD_INT 5
75483: PPUSH
75484: CALL_OW 272
75488: PUSH
75489: LD_VAR 0 11
75493: PPUSH
75494: LD_VAR 0 8
75498: PPUSH
75499: LD_INT 5
75501: PPUSH
75502: CALL_OW 273
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75511: LD_VAR 0 9
75515: PUSH
75516: LD_INT 1
75518: ARRAY
75519: PPUSH
75520: LD_VAR 0 9
75524: PUSH
75525: LD_INT 2
75527: ARRAY
75528: PPUSH
75529: CALL_OW 488
75533: IFFALSE 75632
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75535: LD_ADDR_VAR 0 4
75539: PUSH
75540: LD_VAR 0 9
75544: PUSH
75545: LD_INT 1
75547: ARRAY
75548: PPUSH
75549: LD_VAR 0 9
75553: PUSH
75554: LD_INT 2
75556: ARRAY
75557: PPUSH
75558: CALL_OW 546
75562: ST_TO_ADDR
// if hex [ 1 ] then
75563: LD_VAR 0 4
75567: PUSH
75568: LD_INT 1
75570: ARRAY
75571: IFFALSE 75575
// continue ;
75573: GO 75463
// h := hex [ 2 ] ;
75575: LD_ADDR_VAR 0 13
75579: PUSH
75580: LD_VAR 0 4
75584: PUSH
75585: LD_INT 2
75587: ARRAY
75588: ST_TO_ADDR
// if h + 7 < height then
75589: LD_VAR 0 13
75593: PUSH
75594: LD_INT 7
75596: PLUS
75597: PUSH
75598: LD_VAR 0 15
75602: LESS
75603: IFFALSE 75632
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75605: LD_ADDR_VAR 0 18
75609: PUSH
75610: LD_INT 7
75612: PUSH
75613: LD_INT 28
75615: PUSH
75616: LD_INT 45
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: LIST
75623: PUSH
75624: LD_VAR 0 12
75628: ARRAY
75629: ST_TO_ADDR
// break ;
75630: GO 75634
// end ; end ; end ;
75632: GO 75463
75634: POP
75635: POP
// end ; if not weapon then
75636: LD_VAR 0 18
75640: NOT
75641: IFFALSE 75701
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75643: LD_ADDR_VAR 0 5
75647: PUSH
75648: LD_VAR 0 5
75652: PUSH
75653: LD_INT 11
75655: PUSH
75656: LD_INT 30
75658: PUSH
75659: LD_INT 49
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: LIST
75666: DIFF
75667: ST_TO_ADDR
// if not list then
75668: LD_VAR 0 5
75672: NOT
75673: IFFALSE 75677
// exit ;
75675: GO 75819
// weapon := list [ rand ( 1 , list ) ] ;
75677: LD_ADDR_VAR 0 18
75681: PUSH
75682: LD_VAR 0 5
75686: PUSH
75687: LD_INT 1
75689: PPUSH
75690: LD_VAR 0 5
75694: PPUSH
75695: CALL_OW 12
75699: ARRAY
75700: ST_TO_ADDR
// end ; if weapon then
75701: LD_VAR 0 18
75705: IFFALSE 75819
// begin tmp := CostOfWeapon ( weapon ) ;
75707: LD_ADDR_VAR 0 14
75711: PUSH
75712: LD_VAR 0 18
75716: PPUSH
75717: CALL_OW 451
75721: ST_TO_ADDR
// j := GetBase ( tower ) ;
75722: LD_ADDR_VAR 0 9
75726: PUSH
75727: LD_VAR 0 1
75731: PPUSH
75732: CALL_OW 274
75736: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75737: LD_VAR 0 9
75741: PPUSH
75742: LD_INT 1
75744: PPUSH
75745: CALL_OW 275
75749: PUSH
75750: LD_VAR 0 14
75754: PUSH
75755: LD_INT 1
75757: ARRAY
75758: GREATEREQUAL
75759: PUSH
75760: LD_VAR 0 9
75764: PPUSH
75765: LD_INT 2
75767: PPUSH
75768: CALL_OW 275
75772: PUSH
75773: LD_VAR 0 14
75777: PUSH
75778: LD_INT 2
75780: ARRAY
75781: GREATEREQUAL
75782: AND
75783: PUSH
75784: LD_VAR 0 9
75788: PPUSH
75789: LD_INT 3
75791: PPUSH
75792: CALL_OW 275
75796: PUSH
75797: LD_VAR 0 14
75801: PUSH
75802: LD_INT 3
75804: ARRAY
75805: GREATEREQUAL
75806: AND
75807: IFFALSE 75819
// result := weapon ;
75809: LD_ADDR_VAR 0 3
75813: PUSH
75814: LD_VAR 0 18
75818: ST_TO_ADDR
// end ; end ;
75819: LD_VAR 0 3
75823: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75824: LD_INT 0
75826: PPUSH
75827: PPUSH
// result := true ;
75828: LD_ADDR_VAR 0 3
75832: PUSH
75833: LD_INT 1
75835: ST_TO_ADDR
// if array1 = array2 then
75836: LD_VAR 0 1
75840: PUSH
75841: LD_VAR 0 2
75845: EQUAL
75846: IFFALSE 75906
// begin for i = 1 to array1 do
75848: LD_ADDR_VAR 0 4
75852: PUSH
75853: DOUBLE
75854: LD_INT 1
75856: DEC
75857: ST_TO_ADDR
75858: LD_VAR 0 1
75862: PUSH
75863: FOR_TO
75864: IFFALSE 75902
// if array1 [ i ] <> array2 [ i ] then
75866: LD_VAR 0 1
75870: PUSH
75871: LD_VAR 0 4
75875: ARRAY
75876: PUSH
75877: LD_VAR 0 2
75881: PUSH
75882: LD_VAR 0 4
75886: ARRAY
75887: NONEQUAL
75888: IFFALSE 75900
// begin result := false ;
75890: LD_ADDR_VAR 0 3
75894: PUSH
75895: LD_INT 0
75897: ST_TO_ADDR
// break ;
75898: GO 75902
// end ;
75900: GO 75863
75902: POP
75903: POP
// end else
75904: GO 75914
// result := false ;
75906: LD_ADDR_VAR 0 3
75910: PUSH
75911: LD_INT 0
75913: ST_TO_ADDR
// end ;
75914: LD_VAR 0 3
75918: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75919: LD_INT 0
75921: PPUSH
75922: PPUSH
75923: PPUSH
// pom := GetBase ( fac ) ;
75924: LD_ADDR_VAR 0 5
75928: PUSH
75929: LD_VAR 0 1
75933: PPUSH
75934: CALL_OW 274
75938: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75939: LD_ADDR_VAR 0 4
75943: PUSH
75944: LD_VAR 0 2
75948: PUSH
75949: LD_INT 1
75951: ARRAY
75952: PPUSH
75953: LD_VAR 0 2
75957: PUSH
75958: LD_INT 2
75960: ARRAY
75961: PPUSH
75962: LD_VAR 0 2
75966: PUSH
75967: LD_INT 3
75969: ARRAY
75970: PPUSH
75971: LD_VAR 0 2
75975: PUSH
75976: LD_INT 4
75978: ARRAY
75979: PPUSH
75980: CALL_OW 449
75984: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75985: LD_ADDR_VAR 0 3
75989: PUSH
75990: LD_VAR 0 5
75994: PPUSH
75995: LD_INT 1
75997: PPUSH
75998: CALL_OW 275
76002: PUSH
76003: LD_VAR 0 4
76007: PUSH
76008: LD_INT 1
76010: ARRAY
76011: GREATEREQUAL
76012: PUSH
76013: LD_VAR 0 5
76017: PPUSH
76018: LD_INT 2
76020: PPUSH
76021: CALL_OW 275
76025: PUSH
76026: LD_VAR 0 4
76030: PUSH
76031: LD_INT 2
76033: ARRAY
76034: GREATEREQUAL
76035: AND
76036: PUSH
76037: LD_VAR 0 5
76041: PPUSH
76042: LD_INT 3
76044: PPUSH
76045: CALL_OW 275
76049: PUSH
76050: LD_VAR 0 4
76054: PUSH
76055: LD_INT 3
76057: ARRAY
76058: GREATEREQUAL
76059: AND
76060: ST_TO_ADDR
// end ;
76061: LD_VAR 0 3
76065: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76066: LD_INT 0
76068: PPUSH
76069: PPUSH
76070: PPUSH
76071: PPUSH
// pom := GetBase ( building ) ;
76072: LD_ADDR_VAR 0 3
76076: PUSH
76077: LD_VAR 0 1
76081: PPUSH
76082: CALL_OW 274
76086: ST_TO_ADDR
// if not pom then
76087: LD_VAR 0 3
76091: NOT
76092: IFFALSE 76096
// exit ;
76094: GO 76266
// btype := GetBType ( building ) ;
76096: LD_ADDR_VAR 0 5
76100: PUSH
76101: LD_VAR 0 1
76105: PPUSH
76106: CALL_OW 266
76110: ST_TO_ADDR
// if btype = b_armoury then
76111: LD_VAR 0 5
76115: PUSH
76116: LD_INT 4
76118: EQUAL
76119: IFFALSE 76129
// btype := b_barracks ;
76121: LD_ADDR_VAR 0 5
76125: PUSH
76126: LD_INT 5
76128: ST_TO_ADDR
// if btype = b_depot then
76129: LD_VAR 0 5
76133: PUSH
76134: LD_INT 0
76136: EQUAL
76137: IFFALSE 76147
// btype := b_warehouse ;
76139: LD_ADDR_VAR 0 5
76143: PUSH
76144: LD_INT 1
76146: ST_TO_ADDR
// if btype = b_workshop then
76147: LD_VAR 0 5
76151: PUSH
76152: LD_INT 2
76154: EQUAL
76155: IFFALSE 76165
// btype := b_factory ;
76157: LD_ADDR_VAR 0 5
76161: PUSH
76162: LD_INT 3
76164: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76165: LD_ADDR_VAR 0 4
76169: PUSH
76170: LD_VAR 0 5
76174: PPUSH
76175: LD_VAR 0 1
76179: PPUSH
76180: CALL_OW 248
76184: PPUSH
76185: CALL_OW 450
76189: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76190: LD_ADDR_VAR 0 2
76194: PUSH
76195: LD_VAR 0 3
76199: PPUSH
76200: LD_INT 1
76202: PPUSH
76203: CALL_OW 275
76207: PUSH
76208: LD_VAR 0 4
76212: PUSH
76213: LD_INT 1
76215: ARRAY
76216: GREATEREQUAL
76217: PUSH
76218: LD_VAR 0 3
76222: PPUSH
76223: LD_INT 2
76225: PPUSH
76226: CALL_OW 275
76230: PUSH
76231: LD_VAR 0 4
76235: PUSH
76236: LD_INT 2
76238: ARRAY
76239: GREATEREQUAL
76240: AND
76241: PUSH
76242: LD_VAR 0 3
76246: PPUSH
76247: LD_INT 3
76249: PPUSH
76250: CALL_OW 275
76254: PUSH
76255: LD_VAR 0 4
76259: PUSH
76260: LD_INT 3
76262: ARRAY
76263: GREATEREQUAL
76264: AND
76265: ST_TO_ADDR
// end ;
76266: LD_VAR 0 2
76270: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76271: LD_INT 0
76273: PPUSH
76274: PPUSH
76275: PPUSH
// pom := GetBase ( building ) ;
76276: LD_ADDR_VAR 0 4
76280: PUSH
76281: LD_VAR 0 1
76285: PPUSH
76286: CALL_OW 274
76290: ST_TO_ADDR
// if not pom then
76291: LD_VAR 0 4
76295: NOT
76296: IFFALSE 76300
// exit ;
76298: GO 76401
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76300: LD_ADDR_VAR 0 5
76304: PUSH
76305: LD_VAR 0 2
76309: PPUSH
76310: LD_VAR 0 1
76314: PPUSH
76315: CALL_OW 248
76319: PPUSH
76320: CALL_OW 450
76324: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76325: LD_ADDR_VAR 0 3
76329: PUSH
76330: LD_VAR 0 4
76334: PPUSH
76335: LD_INT 1
76337: PPUSH
76338: CALL_OW 275
76342: PUSH
76343: LD_VAR 0 5
76347: PUSH
76348: LD_INT 1
76350: ARRAY
76351: GREATEREQUAL
76352: PUSH
76353: LD_VAR 0 4
76357: PPUSH
76358: LD_INT 2
76360: PPUSH
76361: CALL_OW 275
76365: PUSH
76366: LD_VAR 0 5
76370: PUSH
76371: LD_INT 2
76373: ARRAY
76374: GREATEREQUAL
76375: AND
76376: PUSH
76377: LD_VAR 0 4
76381: PPUSH
76382: LD_INT 3
76384: PPUSH
76385: CALL_OW 275
76389: PUSH
76390: LD_VAR 0 5
76394: PUSH
76395: LD_INT 3
76397: ARRAY
76398: GREATEREQUAL
76399: AND
76400: ST_TO_ADDR
// end ;
76401: LD_VAR 0 3
76405: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76406: LD_INT 0
76408: PPUSH
76409: PPUSH
76410: PPUSH
76411: PPUSH
76412: PPUSH
76413: PPUSH
76414: PPUSH
76415: PPUSH
76416: PPUSH
76417: PPUSH
// result := false ;
76418: LD_ADDR_VAR 0 6
76422: PUSH
76423: LD_INT 0
76425: ST_TO_ADDR
// if not base or not btype or not x or not y then
76426: LD_VAR 0 1
76430: NOT
76431: PUSH
76432: LD_VAR 0 2
76436: NOT
76437: OR
76438: PUSH
76439: LD_VAR 0 3
76443: NOT
76444: OR
76445: PUSH
76446: LD_VAR 0 4
76450: NOT
76451: OR
76452: IFFALSE 76456
// exit ;
76454: GO 77047
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76456: LD_ADDR_VAR 0 12
76460: PUSH
76461: LD_VAR 0 2
76465: PPUSH
76466: LD_VAR 0 3
76470: PPUSH
76471: LD_VAR 0 4
76475: PPUSH
76476: LD_VAR 0 5
76480: PPUSH
76481: LD_VAR 0 1
76485: PUSH
76486: LD_INT 1
76488: ARRAY
76489: PPUSH
76490: CALL_OW 248
76494: PPUSH
76495: LD_INT 0
76497: PPUSH
76498: CALL 77884 0 6
76502: ST_TO_ADDR
// if not hexes then
76503: LD_VAR 0 12
76507: NOT
76508: IFFALSE 76512
// exit ;
76510: GO 77047
// for i = 1 to hexes do
76512: LD_ADDR_VAR 0 7
76516: PUSH
76517: DOUBLE
76518: LD_INT 1
76520: DEC
76521: ST_TO_ADDR
76522: LD_VAR 0 12
76526: PUSH
76527: FOR_TO
76528: IFFALSE 77045
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76530: LD_ADDR_VAR 0 11
76534: PUSH
76535: LD_VAR 0 12
76539: PUSH
76540: LD_VAR 0 7
76544: ARRAY
76545: PUSH
76546: LD_INT 1
76548: ARRAY
76549: PPUSH
76550: LD_VAR 0 12
76554: PUSH
76555: LD_VAR 0 7
76559: ARRAY
76560: PUSH
76561: LD_INT 2
76563: ARRAY
76564: PPUSH
76565: CALL_OW 428
76569: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76570: LD_VAR 0 12
76574: PUSH
76575: LD_VAR 0 7
76579: ARRAY
76580: PUSH
76581: LD_INT 1
76583: ARRAY
76584: PPUSH
76585: LD_VAR 0 12
76589: PUSH
76590: LD_VAR 0 7
76594: ARRAY
76595: PUSH
76596: LD_INT 2
76598: ARRAY
76599: PPUSH
76600: CALL_OW 351
76604: PUSH
76605: LD_VAR 0 12
76609: PUSH
76610: LD_VAR 0 7
76614: ARRAY
76615: PUSH
76616: LD_INT 1
76618: ARRAY
76619: PPUSH
76620: LD_VAR 0 12
76624: PUSH
76625: LD_VAR 0 7
76629: ARRAY
76630: PUSH
76631: LD_INT 2
76633: ARRAY
76634: PPUSH
76635: CALL_OW 488
76639: NOT
76640: OR
76641: PUSH
76642: LD_VAR 0 11
76646: PPUSH
76647: CALL_OW 247
76651: PUSH
76652: LD_INT 3
76654: EQUAL
76655: OR
76656: IFFALSE 76662
// exit ;
76658: POP
76659: POP
76660: GO 77047
// if not tmp then
76662: LD_VAR 0 11
76666: NOT
76667: IFFALSE 76671
// continue ;
76669: GO 76527
// result := true ;
76671: LD_ADDR_VAR 0 6
76675: PUSH
76676: LD_INT 1
76678: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76679: LD_ADDR_VAR 0 15
76683: PUSH
76684: LD_INT 22
76686: PUSH
76687: LD_VAR 0 11
76691: PPUSH
76692: CALL_OW 255
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 2
76703: PUSH
76704: LD_INT 30
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 30
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: LIST
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PPUSH
76733: CALL_OW 69
76737: ST_TO_ADDR
// if dep then
76738: LD_VAR 0 15
76742: IFFALSE 76878
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76744: LD_ADDR_VAR 0 14
76748: PUSH
76749: LD_VAR 0 15
76753: PUSH
76754: LD_INT 1
76756: ARRAY
76757: PPUSH
76758: CALL_OW 250
76762: PPUSH
76763: LD_VAR 0 15
76767: PUSH
76768: LD_INT 1
76770: ARRAY
76771: PPUSH
76772: CALL_OW 254
76776: PPUSH
76777: LD_INT 5
76779: PPUSH
76780: CALL_OW 272
76784: PUSH
76785: LD_VAR 0 15
76789: PUSH
76790: LD_INT 1
76792: ARRAY
76793: PPUSH
76794: CALL_OW 251
76798: PPUSH
76799: LD_VAR 0 15
76803: PUSH
76804: LD_INT 1
76806: ARRAY
76807: PPUSH
76808: CALL_OW 254
76812: PPUSH
76813: LD_INT 5
76815: PPUSH
76816: CALL_OW 273
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76825: LD_VAR 0 14
76829: PUSH
76830: LD_INT 1
76832: ARRAY
76833: PPUSH
76834: LD_VAR 0 14
76838: PUSH
76839: LD_INT 2
76841: ARRAY
76842: PPUSH
76843: CALL_OW 488
76847: IFFALSE 76878
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76849: LD_VAR 0 11
76853: PPUSH
76854: LD_VAR 0 14
76858: PUSH
76859: LD_INT 1
76861: ARRAY
76862: PPUSH
76863: LD_VAR 0 14
76867: PUSH
76868: LD_INT 2
76870: ARRAY
76871: PPUSH
76872: CALL_OW 111
// continue ;
76876: GO 76527
// end ; end ; r := GetDir ( tmp ) ;
76878: LD_ADDR_VAR 0 13
76882: PUSH
76883: LD_VAR 0 11
76887: PPUSH
76888: CALL_OW 254
76892: ST_TO_ADDR
// if r = 5 then
76893: LD_VAR 0 13
76897: PUSH
76898: LD_INT 5
76900: EQUAL
76901: IFFALSE 76911
// r := 0 ;
76903: LD_ADDR_VAR 0 13
76907: PUSH
76908: LD_INT 0
76910: ST_TO_ADDR
// for j = r to 5 do
76911: LD_ADDR_VAR 0 8
76915: PUSH
76916: DOUBLE
76917: LD_VAR 0 13
76921: DEC
76922: ST_TO_ADDR
76923: LD_INT 5
76925: PUSH
76926: FOR_TO
76927: IFFALSE 77041
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76929: LD_ADDR_VAR 0 9
76933: PUSH
76934: LD_VAR 0 11
76938: PPUSH
76939: CALL_OW 250
76943: PPUSH
76944: LD_VAR 0 8
76948: PPUSH
76949: LD_INT 2
76951: PPUSH
76952: CALL_OW 272
76956: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76957: LD_ADDR_VAR 0 10
76961: PUSH
76962: LD_VAR 0 11
76966: PPUSH
76967: CALL_OW 251
76971: PPUSH
76972: LD_VAR 0 8
76976: PPUSH
76977: LD_INT 2
76979: PPUSH
76980: CALL_OW 273
76984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76985: LD_VAR 0 9
76989: PPUSH
76990: LD_VAR 0 10
76994: PPUSH
76995: CALL_OW 488
76999: PUSH
77000: LD_VAR 0 9
77004: PPUSH
77005: LD_VAR 0 10
77009: PPUSH
77010: CALL_OW 428
77014: NOT
77015: AND
77016: IFFALSE 77039
// begin ComMoveXY ( tmp , _x , _y ) ;
77018: LD_VAR 0 11
77022: PPUSH
77023: LD_VAR 0 9
77027: PPUSH
77028: LD_VAR 0 10
77032: PPUSH
77033: CALL_OW 111
// break ;
77037: GO 77041
// end ; end ;
77039: GO 76926
77041: POP
77042: POP
// end ;
77043: GO 76527
77045: POP
77046: POP
// end ;
77047: LD_VAR 0 6
77051: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77052: LD_INT 0
77054: PPUSH
77055: PPUSH
77056: PPUSH
77057: PPUSH
77058: PPUSH
77059: PPUSH
77060: PPUSH
77061: PPUSH
77062: PPUSH
77063: PPUSH
// result := false ;
77064: LD_ADDR_VAR 0 6
77068: PUSH
77069: LD_INT 0
77071: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77072: LD_VAR 0 1
77076: NOT
77077: PUSH
77078: LD_VAR 0 1
77082: PPUSH
77083: CALL_OW 266
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: IN
77098: NOT
77099: OR
77100: PUSH
77101: LD_VAR 0 2
77105: NOT
77106: OR
77107: PUSH
77108: LD_VAR 0 5
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 2
77121: PUSH
77122: LD_INT 3
77124: PUSH
77125: LD_INT 4
77127: PUSH
77128: LD_INT 5
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: IN
77139: NOT
77140: OR
77141: PUSH
77142: LD_VAR 0 3
77146: PPUSH
77147: LD_VAR 0 4
77151: PPUSH
77152: CALL_OW 488
77156: NOT
77157: OR
77158: IFFALSE 77162
// exit ;
77160: GO 77879
// pom := GetBase ( depot ) ;
77162: LD_ADDR_VAR 0 10
77166: PUSH
77167: LD_VAR 0 1
77171: PPUSH
77172: CALL_OW 274
77176: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77177: LD_ADDR_VAR 0 11
77181: PUSH
77182: LD_VAR 0 2
77186: PPUSH
77187: LD_VAR 0 1
77191: PPUSH
77192: CALL_OW 248
77196: PPUSH
77197: CALL_OW 450
77201: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77202: LD_VAR 0 10
77206: PPUSH
77207: LD_INT 1
77209: PPUSH
77210: CALL_OW 275
77214: PUSH
77215: LD_VAR 0 11
77219: PUSH
77220: LD_INT 1
77222: ARRAY
77223: GREATEREQUAL
77224: PUSH
77225: LD_VAR 0 10
77229: PPUSH
77230: LD_INT 2
77232: PPUSH
77233: CALL_OW 275
77237: PUSH
77238: LD_VAR 0 11
77242: PUSH
77243: LD_INT 2
77245: ARRAY
77246: GREATEREQUAL
77247: AND
77248: PUSH
77249: LD_VAR 0 10
77253: PPUSH
77254: LD_INT 3
77256: PPUSH
77257: CALL_OW 275
77261: PUSH
77262: LD_VAR 0 11
77266: PUSH
77267: LD_INT 3
77269: ARRAY
77270: GREATEREQUAL
77271: AND
77272: NOT
77273: IFFALSE 77277
// exit ;
77275: GO 77879
// if GetBType ( depot ) = b_depot then
77277: LD_VAR 0 1
77281: PPUSH
77282: CALL_OW 266
77286: PUSH
77287: LD_INT 0
77289: EQUAL
77290: IFFALSE 77302
// dist := 28 else
77292: LD_ADDR_VAR 0 14
77296: PUSH
77297: LD_INT 28
77299: ST_TO_ADDR
77300: GO 77310
// dist := 36 ;
77302: LD_ADDR_VAR 0 14
77306: PUSH
77307: LD_INT 36
77309: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77310: LD_VAR 0 1
77314: PPUSH
77315: LD_VAR 0 3
77319: PPUSH
77320: LD_VAR 0 4
77324: PPUSH
77325: CALL_OW 297
77329: PUSH
77330: LD_VAR 0 14
77334: GREATER
77335: IFFALSE 77339
// exit ;
77337: GO 77879
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77339: LD_ADDR_VAR 0 12
77343: PUSH
77344: LD_VAR 0 2
77348: PPUSH
77349: LD_VAR 0 3
77353: PPUSH
77354: LD_VAR 0 4
77358: PPUSH
77359: LD_VAR 0 5
77363: PPUSH
77364: LD_VAR 0 1
77368: PPUSH
77369: CALL_OW 248
77373: PPUSH
77374: LD_INT 0
77376: PPUSH
77377: CALL 77884 0 6
77381: ST_TO_ADDR
// if not hexes then
77382: LD_VAR 0 12
77386: NOT
77387: IFFALSE 77391
// exit ;
77389: GO 77879
// hex := GetHexInfo ( x , y ) ;
77391: LD_ADDR_VAR 0 15
77395: PUSH
77396: LD_VAR 0 3
77400: PPUSH
77401: LD_VAR 0 4
77405: PPUSH
77406: CALL_OW 546
77410: ST_TO_ADDR
// if hex [ 1 ] then
77411: LD_VAR 0 15
77415: PUSH
77416: LD_INT 1
77418: ARRAY
77419: IFFALSE 77423
// exit ;
77421: GO 77879
// height := hex [ 2 ] ;
77423: LD_ADDR_VAR 0 13
77427: PUSH
77428: LD_VAR 0 15
77432: PUSH
77433: LD_INT 2
77435: ARRAY
77436: ST_TO_ADDR
// for i = 1 to hexes do
77437: LD_ADDR_VAR 0 7
77441: PUSH
77442: DOUBLE
77443: LD_INT 1
77445: DEC
77446: ST_TO_ADDR
77447: LD_VAR 0 12
77451: PUSH
77452: FOR_TO
77453: IFFALSE 77783
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77455: LD_VAR 0 12
77459: PUSH
77460: LD_VAR 0 7
77464: ARRAY
77465: PUSH
77466: LD_INT 1
77468: ARRAY
77469: PPUSH
77470: LD_VAR 0 12
77474: PUSH
77475: LD_VAR 0 7
77479: ARRAY
77480: PUSH
77481: LD_INT 2
77483: ARRAY
77484: PPUSH
77485: CALL_OW 488
77489: NOT
77490: PUSH
77491: LD_VAR 0 12
77495: PUSH
77496: LD_VAR 0 7
77500: ARRAY
77501: PUSH
77502: LD_INT 1
77504: ARRAY
77505: PPUSH
77506: LD_VAR 0 12
77510: PUSH
77511: LD_VAR 0 7
77515: ARRAY
77516: PUSH
77517: LD_INT 2
77519: ARRAY
77520: PPUSH
77521: CALL_OW 428
77525: PUSH
77526: LD_INT 0
77528: GREATER
77529: OR
77530: PUSH
77531: LD_VAR 0 12
77535: PUSH
77536: LD_VAR 0 7
77540: ARRAY
77541: PUSH
77542: LD_INT 1
77544: ARRAY
77545: PPUSH
77546: LD_VAR 0 12
77550: PUSH
77551: LD_VAR 0 7
77555: ARRAY
77556: PUSH
77557: LD_INT 2
77559: ARRAY
77560: PPUSH
77561: CALL_OW 351
77565: OR
77566: IFFALSE 77572
// exit ;
77568: POP
77569: POP
77570: GO 77879
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77572: LD_ADDR_VAR 0 8
77576: PUSH
77577: LD_VAR 0 12
77581: PUSH
77582: LD_VAR 0 7
77586: ARRAY
77587: PUSH
77588: LD_INT 1
77590: ARRAY
77591: PPUSH
77592: LD_VAR 0 12
77596: PUSH
77597: LD_VAR 0 7
77601: ARRAY
77602: PUSH
77603: LD_INT 2
77605: ARRAY
77606: PPUSH
77607: CALL_OW 546
77611: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77612: LD_VAR 0 8
77616: PUSH
77617: LD_INT 1
77619: ARRAY
77620: PUSH
77621: LD_VAR 0 8
77625: PUSH
77626: LD_INT 2
77628: ARRAY
77629: PUSH
77630: LD_VAR 0 13
77634: PUSH
77635: LD_INT 2
77637: PLUS
77638: GREATER
77639: OR
77640: PUSH
77641: LD_VAR 0 8
77645: PUSH
77646: LD_INT 2
77648: ARRAY
77649: PUSH
77650: LD_VAR 0 13
77654: PUSH
77655: LD_INT 2
77657: MINUS
77658: LESS
77659: OR
77660: PUSH
77661: LD_VAR 0 8
77665: PUSH
77666: LD_INT 3
77668: ARRAY
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: LD_INT 8
77675: PUSH
77676: LD_INT 9
77678: PUSH
77679: LD_INT 10
77681: PUSH
77682: LD_INT 11
77684: PUSH
77685: LD_INT 12
77687: PUSH
77688: LD_INT 13
77690: PUSH
77691: LD_INT 16
77693: PUSH
77694: LD_INT 17
77696: PUSH
77697: LD_INT 18
77699: PUSH
77700: LD_INT 19
77702: PUSH
77703: LD_INT 20
77705: PUSH
77706: LD_INT 21
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: IN
77724: NOT
77725: OR
77726: PUSH
77727: LD_VAR 0 8
77731: PUSH
77732: LD_INT 5
77734: ARRAY
77735: NOT
77736: OR
77737: PUSH
77738: LD_VAR 0 8
77742: PUSH
77743: LD_INT 6
77745: ARRAY
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: LD_INT 2
77752: PUSH
77753: LD_INT 7
77755: PUSH
77756: LD_INT 9
77758: PUSH
77759: LD_INT 10
77761: PUSH
77762: LD_INT 11
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: IN
77773: NOT
77774: OR
77775: IFFALSE 77781
// exit ;
77777: POP
77778: POP
77779: GO 77879
// end ;
77781: GO 77452
77783: POP
77784: POP
// side := GetSide ( depot ) ;
77785: LD_ADDR_VAR 0 9
77789: PUSH
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 255
77799: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77800: LD_VAR 0 9
77804: PPUSH
77805: LD_VAR 0 3
77809: PPUSH
77810: LD_VAR 0 4
77814: PPUSH
77815: LD_INT 20
77817: PPUSH
77818: CALL 70551 0 4
77822: PUSH
77823: LD_INT 4
77825: ARRAY
77826: IFFALSE 77830
// exit ;
77828: GO 77879
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77830: LD_VAR 0 2
77834: PUSH
77835: LD_INT 29
77837: PUSH
77838: LD_INT 30
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: IN
77845: PUSH
77846: LD_VAR 0 3
77850: PPUSH
77851: LD_VAR 0 4
77855: PPUSH
77856: LD_VAR 0 9
77860: PPUSH
77861: CALL_OW 440
77865: NOT
77866: AND
77867: IFFALSE 77871
// exit ;
77869: GO 77879
// result := true ;
77871: LD_ADDR_VAR 0 6
77875: PUSH
77876: LD_INT 1
77878: ST_TO_ADDR
// end ;
77879: LD_VAR 0 6
77883: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
77884: LD_INT 0
77886: PPUSH
77887: PPUSH
77888: PPUSH
77889: PPUSH
77890: PPUSH
77891: PPUSH
77892: PPUSH
77893: PPUSH
77894: PPUSH
77895: PPUSH
77896: PPUSH
77897: PPUSH
77898: PPUSH
77899: PPUSH
77900: PPUSH
77901: PPUSH
77902: PPUSH
77903: PPUSH
77904: PPUSH
77905: PPUSH
77906: PPUSH
77907: PPUSH
77908: PPUSH
77909: PPUSH
77910: PPUSH
77911: PPUSH
77912: PPUSH
77913: PPUSH
77914: PPUSH
77915: PPUSH
77916: PPUSH
77917: PPUSH
77918: PPUSH
77919: PPUSH
77920: PPUSH
77921: PPUSH
77922: PPUSH
77923: PPUSH
77924: PPUSH
77925: PPUSH
77926: PPUSH
77927: PPUSH
77928: PPUSH
77929: PPUSH
77930: PPUSH
77931: PPUSH
77932: PPUSH
77933: PPUSH
77934: PPUSH
77935: PPUSH
77936: PPUSH
77937: PPUSH
77938: PPUSH
77939: PPUSH
77940: PPUSH
77941: PPUSH
77942: PPUSH
77943: PPUSH
// result = [ ] ;
77944: LD_ADDR_VAR 0 7
77948: PUSH
77949: EMPTY
77950: ST_TO_ADDR
// temp_list = [ ] ;
77951: LD_ADDR_VAR 0 9
77955: PUSH
77956: EMPTY
77957: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77958: LD_VAR 0 4
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 2
77971: PUSH
77972: LD_INT 3
77974: PUSH
77975: LD_INT 4
77977: PUSH
77978: LD_INT 5
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: IN
77989: NOT
77990: PUSH
77991: LD_VAR 0 1
77995: PUSH
77996: LD_INT 0
77998: PUSH
77999: LD_INT 1
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: IN
78006: PUSH
78007: LD_VAR 0 5
78011: PUSH
78012: LD_INT 1
78014: PUSH
78015: LD_INT 2
78017: PUSH
78018: LD_INT 3
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: LIST
78025: IN
78026: NOT
78027: AND
78028: OR
78029: IFFALSE 78033
// exit ;
78031: GO 96418
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78033: LD_VAR 0 1
78037: PUSH
78038: LD_INT 6
78040: PUSH
78041: LD_INT 7
78043: PUSH
78044: LD_INT 8
78046: PUSH
78047: LD_INT 13
78049: PUSH
78050: LD_INT 12
78052: PUSH
78053: LD_INT 15
78055: PUSH
78056: LD_INT 11
78058: PUSH
78059: LD_INT 14
78061: PUSH
78062: LD_INT 10
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: IN
78076: IFFALSE 78086
// btype = b_lab ;
78078: LD_ADDR_VAR 0 1
78082: PUSH
78083: LD_INT 6
78085: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78086: LD_VAR 0 6
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: LD_INT 1
78096: PUSH
78097: LD_INT 2
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: LIST
78104: IN
78105: NOT
78106: PUSH
78107: LD_VAR 0 1
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: LD_INT 1
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 3
78123: PUSH
78124: LD_INT 6
78126: PUSH
78127: LD_INT 36
78129: PUSH
78130: LD_INT 4
78132: PUSH
78133: LD_INT 5
78135: PUSH
78136: LD_INT 31
78138: PUSH
78139: LD_INT 32
78141: PUSH
78142: LD_INT 33
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: IN
78158: NOT
78159: PUSH
78160: LD_VAR 0 6
78164: PUSH
78165: LD_INT 1
78167: EQUAL
78168: AND
78169: OR
78170: PUSH
78171: LD_VAR 0 1
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: LD_INT 3
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: IN
78186: NOT
78187: PUSH
78188: LD_VAR 0 6
78192: PUSH
78193: LD_INT 2
78195: EQUAL
78196: AND
78197: OR
78198: IFFALSE 78208
// mode = 0 ;
78200: LD_ADDR_VAR 0 6
78204: PUSH
78205: LD_INT 0
78207: ST_TO_ADDR
// case mode of 0 :
78208: LD_VAR 0 6
78212: PUSH
78213: LD_INT 0
78215: DOUBLE
78216: EQUAL
78217: IFTRUE 78221
78219: GO 89674
78221: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78222: LD_ADDR_VAR 0 11
78226: PUSH
78227: LD_INT 0
78229: PUSH
78230: LD_INT 0
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: PUSH
78237: LD_INT 0
78239: PUSH
78240: LD_INT 1
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 1
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 1
78260: PUSH
78261: LD_INT 1
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 1
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 1
78280: NEG
78281: PUSH
78282: LD_INT 0
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 1
78291: NEG
78292: PUSH
78293: LD_INT 1
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: LD_INT 2
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 0
78315: PUSH
78316: LD_INT 2
78318: NEG
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: LD_INT 1
78329: NEG
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: LD_INT 2
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: LD_INT 0
78347: PUSH
78348: LD_INT 2
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: LD_INT 1
78357: NEG
78358: PUSH
78359: LD_INT 1
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: LD_INT 1
78368: PUSH
78369: LD_INT 3
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 0
78378: PUSH
78379: LD_INT 3
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: LD_INT 2
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78415: LD_ADDR_VAR 0 12
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 0
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 1
78443: PUSH
78444: LD_INT 0
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 1
78453: PUSH
78454: LD_INT 1
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 0
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 1
78473: NEG
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 1
78484: NEG
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 1
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 2
78507: PUSH
78508: LD_INT 0
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 2
78517: PUSH
78518: LD_INT 1
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 1
78527: NEG
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 2
78538: NEG
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 2
78549: NEG
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 2
78561: NEG
78562: PUSH
78563: LD_INT 1
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 3
78572: NEG
78573: PUSH
78574: LD_INT 0
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 3
78583: NEG
78584: PUSH
78585: LD_INT 1
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78611: LD_ADDR_VAR 0 13
78615: PUSH
78616: LD_INT 0
78618: PUSH
78619: LD_INT 0
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: LD_INT 1
78631: NEG
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 1
78639: PUSH
78640: LD_INT 0
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: PUSH
78650: LD_INT 1
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 0
78659: PUSH
78660: LD_INT 1
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: LD_INT 0
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 1
78680: NEG
78681: PUSH
78682: LD_INT 1
78684: NEG
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: LD_INT 2
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 2
78704: PUSH
78705: LD_INT 1
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: LD_INT 2
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 1
78724: PUSH
78725: LD_INT 2
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 2
78734: NEG
78735: PUSH
78736: LD_INT 1
78738: NEG
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: LD_INT 2
78750: NEG
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 2
78758: NEG
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 3
78770: NEG
78771: PUSH
78772: LD_INT 2
78774: NEG
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 3
78782: NEG
78783: PUSH
78784: LD_INT 3
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78810: LD_ADDR_VAR 0 14
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 0
78827: PUSH
78828: LD_INT 1
78830: NEG
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 0
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 0
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 1
78868: NEG
78869: PUSH
78870: LD_INT 0
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 1
78879: NEG
78880: PUSH
78881: LD_INT 1
78883: NEG
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 1
78891: NEG
78892: PUSH
78893: LD_INT 2
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 0
78903: PUSH
78904: LD_INT 2
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 1
78914: PUSH
78915: LD_INT 1
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: LD_INT 2
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: LD_INT 3
78960: NEG
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: LD_INT 3
78971: NEG
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: LD_INT 2
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79006: LD_ADDR_VAR 0 15
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 0
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: LD_INT 1
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 1
79034: PUSH
79035: LD_INT 0
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 1
79044: PUSH
79045: LD_INT 1
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 0
79054: PUSH
79055: LD_INT 1
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 1
79064: NEG
79065: PUSH
79066: LD_INT 0
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: LD_INT 1
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 2
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 2
79108: PUSH
79109: LD_INT 1
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 1
79118: NEG
79119: PUSH
79120: LD_INT 1
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 2
79129: NEG
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: PUSH
79153: LD_INT 1
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 3
79173: PUSH
79174: LD_INT 1
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79199: LD_ADDR_VAR 0 16
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 0
79216: PUSH
79217: LD_INT 1
79219: NEG
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: LD_INT 0
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 1
79237: PUSH
79238: LD_INT 1
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 0
79247: PUSH
79248: LD_INT 1
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 1
79257: NEG
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: NEG
79281: PUSH
79282: LD_INT 2
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: LD_INT 2
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 1
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 2
79322: NEG
79323: PUSH
79324: LD_INT 1
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: LD_INT 2
79334: NEG
79335: PUSH
79336: LD_INT 2
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 3
79346: PUSH
79347: LD_INT 2
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 3
79356: PUSH
79357: LD_INT 3
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 3
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79392: LD_ADDR_VAR 0 17
79396: PUSH
79397: LD_INT 0
79399: PUSH
79400: LD_INT 0
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: LD_INT 1
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 1
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 1
79430: PUSH
79431: LD_INT 1
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 1
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 1
79450: NEG
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: NEG
79462: PUSH
79463: LD_INT 1
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 1
79473: NEG
79474: PUSH
79475: LD_INT 2
79477: NEG
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: LD_INT 2
79488: NEG
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: LD_INT 1
79499: NEG
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 2
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 2
79517: PUSH
79518: LD_INT 1
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: LD_INT 2
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 1
79537: PUSH
79538: LD_INT 2
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 0
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 2
79568: NEG
79569: PUSH
79570: LD_INT 0
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 2
79579: NEG
79580: PUSH
79581: LD_INT 1
79583: NEG
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: NEG
79592: PUSH
79593: LD_INT 2
79595: NEG
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79622: LD_ADDR_VAR 0 18
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: LD_INT 1
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 1
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 1
79660: PUSH
79661: LD_INT 1
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 0
79670: PUSH
79671: LD_INT 1
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 1
79680: NEG
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 1
79691: NEG
79692: PUSH
79693: LD_INT 1
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 1
79703: NEG
79704: PUSH
79705: LD_INT 2
79707: NEG
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 0
79715: PUSH
79716: LD_INT 2
79718: NEG
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 1
79726: PUSH
79727: LD_INT 1
79729: NEG
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: LD_INT 0
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 2
79747: PUSH
79748: LD_INT 1
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 2
79757: PUSH
79758: LD_INT 2
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: LD_INT 2
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 0
79777: PUSH
79778: LD_INT 2
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: LD_INT 1
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 2
79798: NEG
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 2
79809: NEG
79810: PUSH
79811: LD_INT 1
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: NEG
79822: PUSH
79823: LD_INT 2
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79852: LD_ADDR_VAR 0 19
79856: PUSH
79857: LD_INT 0
79859: PUSH
79860: LD_INT 0
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: LD_INT 1
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 1
79880: PUSH
79881: LD_INT 0
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 1
79890: PUSH
79891: LD_INT 1
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 1
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 1
79910: NEG
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: NEG
79922: PUSH
79923: LD_INT 1
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: LD_INT 2
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 0
79945: PUSH
79946: LD_INT 2
79948: NEG
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: LD_INT 1
79959: NEG
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 2
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: LD_INT 1
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 2
79987: PUSH
79988: LD_INT 2
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 1
79997: PUSH
79998: LD_INT 2
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: LD_INT 2
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 1
80017: NEG
80018: PUSH
80019: LD_INT 1
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 2
80028: NEG
80029: PUSH
80030: LD_INT 0
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: NEG
80040: PUSH
80041: LD_INT 1
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 2
80051: NEG
80052: PUSH
80053: LD_INT 2
80055: NEG
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80082: LD_ADDR_VAR 0 20
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 0
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 1
80110: PUSH
80111: LD_INT 0
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 1
80120: PUSH
80121: LD_INT 1
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 1
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 1
80140: NEG
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: LD_INT 2
80167: NEG
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 0
80175: PUSH
80176: LD_INT 2
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: LD_INT 0
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 2
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 2
80217: PUSH
80218: LD_INT 2
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: LD_INT 2
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 0
80237: PUSH
80238: LD_INT 2
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 1
80247: NEG
80248: PUSH
80249: LD_INT 1
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 2
80258: NEG
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: NEG
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: LD_INT 2
80285: NEG
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: LIST
80301: LIST
80302: LIST
80303: LIST
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80312: LD_ADDR_VAR 0 21
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: LD_INT 0
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 0
80329: PUSH
80330: LD_INT 1
80332: NEG
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 1
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: LD_INT 1
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: LD_INT 1
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 1
80370: NEG
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: NEG
80382: PUSH
80383: LD_INT 1
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: NEG
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 2
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 2
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 2
80437: PUSH
80438: LD_INT 1
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 2
80447: PUSH
80448: LD_INT 2
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 1
80457: PUSH
80458: LD_INT 2
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 0
80467: PUSH
80468: LD_INT 2
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 1
80477: NEG
80478: PUSH
80479: LD_INT 1
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 2
80488: NEG
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 2
80499: NEG
80500: PUSH
80501: LD_INT 1
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: NEG
80512: PUSH
80513: LD_INT 2
80515: NEG
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80542: LD_ADDR_VAR 0 22
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 1
80600: NEG
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 2
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 2
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 2
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: PUSH
80688: LD_INT 2
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 2
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 1
80707: NEG
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 2
80718: NEG
80719: PUSH
80720: LD_INT 0
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: LD_INT 2
80745: NEG
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80772: LD_ADDR_VAR 0 23
80776: PUSH
80777: LD_INT 0
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 1
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 1
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: LD_INT 1
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 0
80820: PUSH
80821: LD_INT 1
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 1
80853: NEG
80854: PUSH
80855: LD_INT 2
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 2
80887: PUSH
80888: LD_INT 0
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 2
80897: PUSH
80898: LD_INT 1
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 2
80907: PUSH
80908: LD_INT 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 0
80927: PUSH
80928: LD_INT 2
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 2
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: NEG
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 2
80983: NEG
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 1
80995: NEG
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: LD_INT 2
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 2
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81052: LD_ADDR_VAR 0 24
81056: PUSH
81057: LD_INT 0
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 1
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 1
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 0
81100: PUSH
81101: LD_INT 1
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 1
81110: NEG
81111: PUSH
81112: LD_INT 0
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 1
81121: NEG
81122: PUSH
81123: LD_INT 1
81125: NEG
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: LD_INT 2
81148: NEG
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: LD_INT 1
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 2
81167: PUSH
81168: LD_INT 0
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: PUSH
81178: LD_INT 1
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: LD_INT 2
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: LD_INT 2
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 2
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: NEG
81218: PUSH
81219: LD_INT 1
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 2
81228: NEG
81229: PUSH
81230: LD_INT 0
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 2
81239: NEG
81240: PUSH
81241: LD_INT 1
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: LD_INT 2
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: PUSH
81264: LD_INT 2
81266: NEG
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: LD_INT 1
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 3
81285: PUSH
81286: LD_INT 1
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 3
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: LIST
81307: LIST
81308: LIST
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81328: LD_ADDR_VAR 0 25
81332: PUSH
81333: LD_INT 0
81335: PUSH
81336: LD_INT 0
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 0
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 1
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 1
81366: PUSH
81367: LD_INT 1
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 0
81376: PUSH
81377: LD_INT 1
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 1
81386: NEG
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: NEG
81398: PUSH
81399: LD_INT 1
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 2
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: LD_INT 2
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 1
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 2
81453: PUSH
81454: LD_INT 1
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 2
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 1
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 2
81504: NEG
81505: PUSH
81506: LD_INT 0
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 2
81515: NEG
81516: PUSH
81517: LD_INT 1
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: NEG
81528: PUSH
81529: LD_INT 2
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 3
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 3
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 2
81559: PUSH
81560: LD_INT 3
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 3
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81602: LD_ADDR_VAR 0 26
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 0
81619: PUSH
81620: LD_INT 1
81622: NEG
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: LD_INT 1
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 0
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 1
81683: NEG
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 0
81695: PUSH
81696: LD_INT 2
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: LD_INT 1
81709: NEG
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 2
81737: PUSH
81738: LD_INT 2
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 1
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 0
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 1
81767: NEG
81768: PUSH
81769: LD_INT 1
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 2
81778: NEG
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 2
81789: NEG
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: LD_INT 2
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 2
81813: PUSH
81814: LD_INT 3
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 1
81823: PUSH
81824: LD_INT 3
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: LD_INT 1
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81878: LD_ADDR_VAR 0 27
81882: PUSH
81883: LD_INT 0
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 0
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 1
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 0
81926: PUSH
81927: LD_INT 1
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: LD_INT 0
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 1
81947: NEG
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 2
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 2
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 2
82013: PUSH
82014: LD_INT 2
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 1
82023: PUSH
82024: LD_INT 2
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: LD_INT 2
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 1
82043: NEG
82044: PUSH
82045: LD_INT 1
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 2
82054: NEG
82055: PUSH
82056: LD_INT 0
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 2
82065: NEG
82066: PUSH
82067: LD_INT 1
82069: NEG
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 2
82077: NEG
82078: PUSH
82079: LD_INT 2
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 2
82100: NEG
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 3
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 3
82123: NEG
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82158: LD_ADDR_VAR 0 28
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: LD_INT 0
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: LD_INT 1
82178: NEG
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 1
82186: PUSH
82187: LD_INT 0
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 0
82206: PUSH
82207: LD_INT 1
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 1
82216: NEG
82217: PUSH
82218: LD_INT 0
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: LD_INT 1
82231: NEG
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 1
82239: NEG
82240: PUSH
82241: LD_INT 2
82243: NEG
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 0
82251: PUSH
82252: LD_INT 2
82254: NEG
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 2
82273: PUSH
82274: LD_INT 0
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 2
82283: PUSH
82284: LD_INT 1
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 2
82293: PUSH
82294: LD_INT 2
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: LD_INT 2
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 0
82313: PUSH
82314: LD_INT 2
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: NEG
82324: PUSH
82325: LD_INT 1
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: NEG
82335: PUSH
82336: LD_INT 0
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: NEG
82346: PUSH
82347: LD_INT 1
82349: NEG
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: NEG
82358: PUSH
82359: LD_INT 2
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: LD_INT 3
82373: NEG
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 1
82381: NEG
82382: PUSH
82383: LD_INT 3
82385: NEG
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 3
82393: NEG
82394: PUSH
82395: LD_INT 1
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 3
82405: NEG
82406: PUSH
82407: LD_INT 2
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82440: LD_ADDR_VAR 0 29
82444: PUSH
82445: LD_INT 0
82447: PUSH
82448: LD_INT 0
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 1
82478: PUSH
82479: LD_INT 1
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 0
82488: PUSH
82489: LD_INT 1
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 1
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 1
82521: NEG
82522: PUSH
82523: LD_INT 2
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 0
82533: PUSH
82534: LD_INT 2
82536: NEG
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 1
82544: PUSH
82545: LD_INT 1
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 2
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 2
82565: PUSH
82566: LD_INT 1
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: LD_INT 2
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: LD_INT 2
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: LD_INT 1
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 2
82606: NEG
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: LD_INT 2
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 2
82630: NEG
82631: PUSH
82632: LD_INT 3
82634: NEG
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: LD_INT 1
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 3
82653: PUSH
82654: LD_INT 1
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 3
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 1
82673: NEG
82674: PUSH
82675: LD_INT 2
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 3
82684: NEG
82685: PUSH
82686: LD_INT 2
82688: NEG
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82719: LD_ADDR_VAR 0 30
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 0
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 0
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: LD_INT 1
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: LD_INT 1
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 1
82777: NEG
82778: PUSH
82779: LD_INT 0
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 1
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: LD_INT 2
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: LD_INT 2
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: LD_INT 2
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: LD_INT 2
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: LD_INT 1
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 2
82885: NEG
82886: PUSH
82887: LD_INT 0
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 2
82896: NEG
82897: PUSH
82898: LD_INT 1
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 1
82908: NEG
82909: PUSH
82910: LD_INT 3
82912: NEG
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 1
82920: PUSH
82921: LD_INT 2
82923: NEG
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 3
82931: PUSH
82932: LD_INT 2
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 3
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: LD_INT 1
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 3
82962: NEG
82963: PUSH
82964: LD_INT 1
82966: NEG
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82997: LD_ADDR_VAR 0 31
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: LD_INT 0
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: LD_INT 1
83017: NEG
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: LD_INT 0
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 1
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: LD_INT 1
83070: NEG
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 2
83162: NEG
83163: PUSH
83164: LD_INT 1
83166: NEG
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 2
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: LD_INT 3
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 3
83209: PUSH
83210: LD_INT 1
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: LD_INT 3
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 1
83229: NEG
83230: PUSH
83231: LD_INT 2
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 3
83240: NEG
83241: PUSH
83242: LD_INT 2
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83275: LD_ADDR_VAR 0 32
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: LD_INT 0
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: LD_INT 1
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 0
83323: PUSH
83324: LD_INT 1
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 1
83333: NEG
83334: PUSH
83335: LD_INT 0
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: LD_INT 1
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: LD_INT 2
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 0
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: PUSH
83380: LD_INT 1
83382: NEG
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: LD_INT 1
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: LD_INT 2
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 1
83410: PUSH
83411: LD_INT 2
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 0
83420: PUSH
83421: LD_INT 2
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: NEG
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: NEG
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 2
83452: NEG
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: LD_INT 3
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: LD_INT 2
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 3
83487: PUSH
83488: LD_INT 2
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 2
83497: PUSH
83498: LD_INT 3
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 2
83507: NEG
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 3
83518: NEG
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83553: LD_ADDR_VAR 0 33
83557: PUSH
83558: LD_INT 0
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 0
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: PUSH
83592: LD_INT 1
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 0
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 1
83611: NEG
83612: PUSH
83613: LD_INT 0
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: NEG
83635: PUSH
83636: LD_INT 2
83638: NEG
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: LD_INT 1
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 2
83657: PUSH
83658: LD_INT 0
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 2
83667: PUSH
83668: LD_INT 1
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 1
83677: PUSH
83678: LD_INT 2
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: LD_INT 2
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: LD_INT 1
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_INT 2
83708: NEG
83709: PUSH
83710: LD_INT 0
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 2
83719: NEG
83720: PUSH
83721: LD_INT 1
83723: NEG
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 3
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: PUSH
83756: LD_INT 1
83758: NEG
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 3
83766: PUSH
83767: LD_INT 1
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: LD_INT 1
83776: PUSH
83777: LD_INT 3
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 1
83786: NEG
83787: PUSH
83788: LD_INT 2
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: LD_INT 3
83797: NEG
83798: PUSH
83799: LD_INT 2
83801: NEG
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83832: LD_ADDR_VAR 0 34
83836: PUSH
83837: LD_INT 0
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 0
83849: PUSH
83850: LD_INT 1
83852: NEG
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: PUSH
83861: LD_INT 0
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: LD_INT 1
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 0
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 1
83890: NEG
83891: PUSH
83892: LD_INT 0
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 1
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: NEG
83914: PUSH
83915: LD_INT 2
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 0
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: LD_INT 1
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: LD_INT 1
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 2
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: LD_INT 1
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: NEG
84012: PUSH
84013: LD_INT 2
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: LD_INT 3
84027: NEG
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: LD_INT 2
84038: NEG
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 3
84046: PUSH
84047: LD_INT 2
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 2
84056: PUSH
84057: LD_INT 3
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 2
84066: NEG
84067: PUSH
84068: LD_INT 1
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 3
84077: NEG
84078: PUSH
84079: LD_INT 1
84081: NEG
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84112: LD_ADDR_VAR 0 35
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: LD_INT 0
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 0
84129: PUSH
84130: LD_INT 1
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 1
84140: PUSH
84141: LD_INT 0
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: PUSH
84151: LD_INT 1
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 0
84160: PUSH
84161: LD_INT 1
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 1
84170: NEG
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: LD_INT 1
84185: NEG
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 2
84203: NEG
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84224: LD_ADDR_VAR 0 36
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: NEG
84283: PUSH
84284: LD_INT 0
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 1
84293: NEG
84294: PUSH
84295: LD_INT 1
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 2
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 1
84317: PUSH
84318: LD_INT 2
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84336: LD_ADDR_VAR 0 37
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 0
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 0
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: LD_INT 1
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 1
84405: NEG
84406: PUSH
84407: LD_INT 1
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 1
84417: PUSH
84418: LD_INT 1
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: NEG
84429: PUSH
84430: LD_INT 1
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84448: LD_ADDR_VAR 0 38
84452: PUSH
84453: LD_INT 0
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 0
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 1
84476: PUSH
84477: LD_INT 0
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: LD_INT 1
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: LD_INT 0
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: LD_INT 1
84521: NEG
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 2
84529: PUSH
84530: LD_INT 1
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 2
84539: NEG
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84560: LD_ADDR_VAR 0 39
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: LD_INT 0
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 0
84577: PUSH
84578: LD_INT 1
84580: NEG
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 1
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: LD_INT 1
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 0
84608: PUSH
84609: LD_INT 1
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 1
84618: NEG
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: LD_INT 1
84633: NEG
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: NEG
84642: PUSH
84643: LD_INT 2
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 2
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84672: LD_ADDR_VAR 0 40
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 0
84689: PUSH
84690: LD_INT 1
84692: NEG
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: PUSH
84701: LD_INT 0
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 1
84710: PUSH
84711: LD_INT 1
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: LD_INT 0
84720: PUSH
84721: LD_INT 1
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: LD_INT 0
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: LD_INT 1
84741: NEG
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: LD_INT 1
84756: NEG
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 1
84764: NEG
84765: PUSH
84766: LD_INT 1
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84784: LD_ADDR_VAR 0 41
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: LD_INT 0
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 0
84801: PUSH
84802: LD_INT 1
84804: NEG
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 1
84812: PUSH
84813: LD_INT 0
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: LD_INT 1
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: LD_INT 1
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: LD_INT 1
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 1
84865: NEG
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 2
84898: PUSH
84899: LD_INT 1
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 2
84908: PUSH
84909: LD_INT 2
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: LD_INT 2
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 2
84939: NEG
84940: PUSH
84941: LD_INT 0
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 2
84950: NEG
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: NEG
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: NEG
84975: PUSH
84976: LD_INT 3
84978: NEG
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 2
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 3
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 3
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 3
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 3
85027: PUSH
85028: LD_INT 3
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: PUSH
85038: LD_INT 3
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: LD_INT 1
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 3
85058: NEG
85059: PUSH
85060: LD_INT 0
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 3
85069: NEG
85070: PUSH
85071: LD_INT 1
85073: NEG
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 3
85081: NEG
85082: PUSH
85083: LD_INT 2
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 3
85093: NEG
85094: PUSH
85095: LD_INT 3
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85134: LD_ADDR_VAR 0 42
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 1
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: LD_INT 0
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: LD_INT 1
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 2
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: LD_INT 2
85230: NEG
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 2
85249: PUSH
85250: LD_INT 1
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 2
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 1
85269: PUSH
85270: LD_INT 2
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: LD_INT 2
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: PUSH
85291: LD_INT 1
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 2
85300: NEG
85301: PUSH
85302: LD_INT 1
85304: NEG
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 2
85312: NEG
85313: PUSH
85314: LD_INT 2
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: NEG
85325: PUSH
85326: LD_INT 3
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 1
85336: NEG
85337: PUSH
85338: LD_INT 3
85340: NEG
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: LD_INT 3
85351: NEG
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: PUSH
85357: LD_INT 1
85359: PUSH
85360: LD_INT 2
85362: NEG
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 3
85370: PUSH
85371: LD_INT 2
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 3
85380: PUSH
85381: LD_INT 3
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 2
85390: PUSH
85391: LD_INT 3
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 1
85400: PUSH
85401: LD_INT 3
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: LD_INT 3
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 3
85431: NEG
85432: PUSH
85433: LD_INT 2
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 3
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85484: LD_ADDR_VAR 0 43
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: LD_INT 1
85504: NEG
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 1
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 1
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 0
85532: PUSH
85533: LD_INT 1
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 1
85542: NEG
85543: PUSH
85544: LD_INT 0
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: NEG
85566: PUSH
85567: LD_INT 2
85569: NEG
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 0
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 2
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 0
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 1
85639: NEG
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: NEG
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 2
85661: NEG
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 1
85673: NEG
85674: PUSH
85675: LD_INT 3
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: LD_INT 3
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 2
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 3
85718: PUSH
85719: LD_INT 0
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 3
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: LD_INT 3
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: LD_INT 3
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 2
85769: NEG
85770: PUSH
85771: LD_INT 1
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 3
85780: NEG
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 3
85791: NEG
85792: PUSH
85793: LD_INT 1
85795: NEG
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85832: LD_ADDR_VAR 0 44
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 0
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 1
85860: PUSH
85861: LD_INT 0
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 0
85880: PUSH
85881: LD_INT 1
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 1
85890: NEG
85891: PUSH
85892: LD_INT 0
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: LD_INT 1
85905: NEG
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: NEG
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 2
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 2
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: PUSH
85957: LD_INT 2
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: PUSH
85967: LD_INT 2
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: LD_INT 0
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: NEG
85999: PUSH
86000: LD_INT 1
86002: NEG
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 2
86010: NEG
86011: PUSH
86012: LD_INT 2
86014: NEG
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 2
86022: NEG
86023: PUSH
86024: LD_INT 3
86026: NEG
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 2
86034: PUSH
86035: LD_INT 1
86037: NEG
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 3
86045: PUSH
86046: LD_INT 0
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 3
86055: PUSH
86056: LD_INT 1
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 3
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 3
86075: PUSH
86076: LD_INT 3
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: LD_INT 3
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 2
86095: NEG
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: LD_INT 3
86106: NEG
86107: PUSH
86108: LD_INT 0
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 3
86117: NEG
86118: PUSH
86119: LD_INT 1
86121: NEG
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 3
86129: NEG
86130: PUSH
86131: LD_INT 2
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 3
86141: NEG
86142: PUSH
86143: LD_INT 3
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86182: LD_ADDR_VAR 0 45
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 0
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 1
86220: PUSH
86221: LD_INT 1
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 0
86230: PUSH
86231: LD_INT 1
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: NEG
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: LD_INT 2
86267: NEG
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 0
86275: PUSH
86276: LD_INT 2
86278: NEG
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 1
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 2
86297: PUSH
86298: LD_INT 1
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 2
86307: PUSH
86308: LD_INT 2
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 1
86317: PUSH
86318: LD_INT 2
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: PUSH
86325: LD_INT 0
86327: PUSH
86328: LD_INT 2
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: NEG
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 2
86348: NEG
86349: PUSH
86350: LD_INT 1
86352: NEG
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 2
86360: NEG
86361: PUSH
86362: LD_INT 2
86364: NEG
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 3
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 1
86384: NEG
86385: PUSH
86386: LD_INT 3
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 0
86396: PUSH
86397: LD_INT 3
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: LD_INT 2
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 3
86418: PUSH
86419: LD_INT 2
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 3
86428: PUSH
86429: LD_INT 3
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 2
86438: PUSH
86439: LD_INT 3
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: LD_INT 3
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 3
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 1
86468: NEG
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 3
86479: NEG
86480: PUSH
86481: LD_INT 2
86483: NEG
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 3
86491: NEG
86492: PUSH
86493: LD_INT 3
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86532: LD_ADDR_VAR 0 46
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 0
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: LD_INT 1
86605: NEG
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 0
86625: PUSH
86626: LD_INT 2
86628: NEG
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: LD_INT 1
86639: NEG
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 2
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: LD_INT 2
86657: PUSH
86658: LD_INT 1
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 1
86667: PUSH
86668: LD_INT 2
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: LD_INT 0
86677: PUSH
86678: LD_INT 2
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: LD_INT 1
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 2
86698: NEG
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 2
86709: NEG
86710: PUSH
86711: LD_INT 1
86713: NEG
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 1
86721: NEG
86722: PUSH
86723: LD_INT 3
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 3
86736: NEG
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 1
86744: PUSH
86745: LD_INT 2
86747: NEG
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: PUSH
86753: LD_INT 2
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 3
86766: PUSH
86767: LD_INT 0
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 3
86776: PUSH
86777: LD_INT 1
86779: PUSH
86780: EMPTY
86781: LIST
86782: LIST
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: LD_INT 3
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: PUSH
86794: LD_INT 0
86796: PUSH
86797: LD_INT 3
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: NEG
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 2
86817: NEG
86818: PUSH
86819: LD_INT 1
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 3
86828: NEG
86829: PUSH
86830: LD_INT 0
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 3
86839: NEG
86840: PUSH
86841: LD_INT 1
86843: NEG
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86880: LD_ADDR_VAR 0 47
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: LD_INT 0
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: LD_INT 1
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 1
86908: PUSH
86909: LD_INT 0
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 1
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 1
86938: NEG
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 1
86949: NEG
86950: PUSH
86951: LD_INT 1
86953: NEG
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: LD_INT 2
86976: NEG
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 2
86995: NEG
86996: PUSH
86997: LD_INT 1
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 2
87007: NEG
87008: PUSH
87009: LD_INT 2
87011: NEG
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87031: LD_ADDR_VAR 0 48
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 0
87048: PUSH
87049: LD_INT 1
87051: NEG
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 1
87069: PUSH
87070: LD_INT 1
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 0
87079: PUSH
87080: LD_INT 1
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 1
87100: NEG
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: NEG
87113: PUSH
87114: LD_INT 2
87116: NEG
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 2
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 2
87146: PUSH
87147: LD_INT 0
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: LD_INT 1
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: LIST
87168: LIST
87169: LIST
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87178: LD_ADDR_VAR 0 49
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: LD_INT 0
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 0
87195: PUSH
87196: LD_INT 1
87198: NEG
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 1
87216: PUSH
87217: LD_INT 1
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 0
87226: PUSH
87227: LD_INT 1
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: LD_INT 0
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: NEG
87248: PUSH
87249: LD_INT 1
87251: NEG
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: LD_INT 1
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 2
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 2
87280: PUSH
87281: LD_INT 1
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 2
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 2
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87322: LD_ADDR_VAR 0 50
87326: PUSH
87327: LD_INT 0
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 0
87339: PUSH
87340: LD_INT 1
87342: NEG
87343: PUSH
87344: EMPTY
87345: LIST
87346: LIST
87347: PUSH
87348: LD_INT 1
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 1
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: LD_INT 1
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 1
87380: NEG
87381: PUSH
87382: LD_INT 0
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: NEG
87392: PUSH
87393: LD_INT 1
87395: NEG
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 2
87403: PUSH
87404: LD_INT 1
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 2
87413: PUSH
87414: LD_INT 2
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 1
87423: PUSH
87424: LD_INT 2
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 2
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: LD_INT 1
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87466: LD_ADDR_VAR 0 51
87470: PUSH
87471: LD_INT 0
87473: PUSH
87474: LD_INT 0
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 0
87483: PUSH
87484: LD_INT 1
87486: NEG
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 0
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 0
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 1
87535: NEG
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: PUSH
87548: LD_INT 2
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 0
87557: PUSH
87558: LD_INT 2
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: LD_INT 1
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 2
87578: NEG
87579: PUSH
87580: LD_INT 0
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 2
87589: NEG
87590: PUSH
87591: LD_INT 1
87593: NEG
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87613: LD_ADDR_VAR 0 52
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: LD_INT 1
87633: NEG
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 1
87641: PUSH
87642: LD_INT 0
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: PUSH
87652: LD_INT 1
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: LD_INT 1
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 1
87671: NEG
87672: PUSH
87673: LD_INT 0
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 1
87694: NEG
87695: PUSH
87696: LD_INT 2
87698: NEG
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 1
87706: NEG
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 2
87717: NEG
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 2
87728: NEG
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: LD_INT 2
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87764: LD_ADDR_VAR 0 53
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 1
87784: NEG
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: PUSH
87803: LD_INT 1
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 0
87812: PUSH
87813: LD_INT 1
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 1
87822: NEG
87823: PUSH
87824: LD_INT 0
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 1
87833: NEG
87834: PUSH
87835: LD_INT 1
87837: NEG
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: LD_INT 2
87849: NEG
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 2
87860: NEG
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: LD_INT 1
87871: NEG
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 2
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 2
87889: PUSH
87890: LD_INT 1
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 2
87899: PUSH
87900: LD_INT 2
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: PUSH
87910: LD_INT 2
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 0
87919: PUSH
87920: LD_INT 2
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 1
87929: NEG
87930: PUSH
87931: LD_INT 1
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: LD_INT 0
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 2
87951: NEG
87952: PUSH
87953: LD_INT 1
87955: NEG
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 2
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87994: LD_ADDR_VAR 0 54
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 1
88022: PUSH
88023: LD_INT 0
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 1
88032: PUSH
88033: LD_INT 1
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 0
88042: PUSH
88043: LD_INT 1
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: LD_INT 1
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: LD_INT 2
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 0
88087: PUSH
88088: LD_INT 2
88090: NEG
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: LD_INT 1
88101: NEG
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: LD_INT 2
88109: PUSH
88110: LD_INT 0
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 2
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 2
88129: PUSH
88130: LD_INT 2
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 1
88139: PUSH
88140: LD_INT 2
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 0
88149: PUSH
88150: LD_INT 2
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 1
88159: NEG
88160: PUSH
88161: LD_INT 1
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 2
88170: NEG
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 2
88181: NEG
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 2
88193: NEG
88194: PUSH
88195: LD_INT 2
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88224: LD_ADDR_VAR 0 55
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 0
88241: PUSH
88242: LD_INT 1
88244: NEG
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 1
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 0
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 1
88282: NEG
88283: PUSH
88284: LD_INT 0
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: LD_INT 2
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: LD_INT 2
88320: NEG
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: LD_INT 1
88331: NEG
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: LD_INT 0
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 2
88349: PUSH
88350: LD_INT 1
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: LD_INT 2
88359: PUSH
88360: LD_INT 2
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 1
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 0
88379: PUSH
88380: LD_INT 2
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 1
88389: NEG
88390: PUSH
88391: LD_INT 1
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 2
88400: NEG
88401: PUSH
88402: LD_INT 0
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 2
88411: NEG
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: NEG
88424: PUSH
88425: LD_INT 2
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88454: LD_ADDR_VAR 0 56
88458: PUSH
88459: LD_INT 0
88461: PUSH
88462: LD_INT 0
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 1
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 1
88492: PUSH
88493: LD_INT 1
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 0
88502: PUSH
88503: LD_INT 1
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 1
88512: NEG
88513: PUSH
88514: LD_INT 0
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: LD_INT 1
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: LD_INT 2
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 0
88547: PUSH
88548: LD_INT 2
88550: NEG
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 2
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 2
88589: PUSH
88590: LD_INT 2
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: LD_INT 2
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 1
88619: NEG
88620: PUSH
88621: LD_INT 1
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 2
88630: NEG
88631: PUSH
88632: LD_INT 0
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: NEG
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 2
88653: NEG
88654: PUSH
88655: LD_INT 2
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88684: LD_ADDR_VAR 0 57
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: LD_INT 0
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 0
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 1
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 1
88722: PUSH
88723: LD_INT 1
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 0
88732: PUSH
88733: LD_INT 1
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 1
88742: NEG
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: NEG
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: LD_INT 2
88769: NEG
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 0
88777: PUSH
88778: LD_INT 2
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: LD_INT 1
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: LD_INT 1
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 2
88819: PUSH
88820: LD_INT 2
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 1
88829: PUSH
88830: LD_INT 2
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: PUSH
88847: LD_INT 1
88849: NEG
88850: PUSH
88851: LD_INT 1
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 2
88860: NEG
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 2
88871: NEG
88872: PUSH
88873: LD_INT 1
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 2
88883: NEG
88884: PUSH
88885: LD_INT 2
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88914: LD_ADDR_VAR 0 58
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 1
88952: PUSH
88953: LD_INT 1
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: LD_INT 1
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 1
88972: NEG
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: NEG
88996: PUSH
88997: LD_INT 2
88999: NEG
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 2
89010: NEG
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 2
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 2
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 2
89049: PUSH
89050: LD_INT 2
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: LD_INT 2
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 0
89069: PUSH
89070: LD_INT 2
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 1
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: NEG
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 2
89101: NEG
89102: PUSH
89103: LD_INT 1
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: NEG
89114: PUSH
89115: LD_INT 2
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89144: LD_ADDR_VAR 0 59
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: LD_INT 0
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 0
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 1
89172: PUSH
89173: LD_INT 0
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: PUSH
89180: LD_INT 1
89182: PUSH
89183: LD_INT 1
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 1
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: NEG
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89232: LD_ADDR_VAR 0 60
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 0
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: LD_INT 1
89252: NEG
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 1
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: LD_INT 1
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: NEG
89302: PUSH
89303: LD_INT 1
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89320: LD_ADDR_VAR 0 61
89324: PUSH
89325: LD_INT 0
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 0
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 1
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 0
89368: PUSH
89369: LD_INT 1
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 1
89378: NEG
89379: PUSH
89380: LD_INT 0
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 1
89389: NEG
89390: PUSH
89391: LD_INT 1
89393: NEG
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89408: LD_ADDR_VAR 0 62
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89496: LD_ADDR_VAR 0 63
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 0
89513: PUSH
89514: LD_INT 1
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 1
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 1
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: LD_INT 0
89544: PUSH
89545: LD_INT 1
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 0
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 1
89565: NEG
89566: PUSH
89567: LD_INT 1
89569: NEG
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89584: LD_ADDR_VAR 0 64
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: LD_INT 0
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: LD_INT 1
89604: NEG
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 1
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 1
89622: PUSH
89623: LD_INT 1
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 1
89642: NEG
89643: PUSH
89644: LD_INT 0
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 1
89653: NEG
89654: PUSH
89655: LD_INT 1
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: ST_TO_ADDR
// end ; 1 :
89672: GO 95569
89674: LD_INT 1
89676: DOUBLE
89677: EQUAL
89678: IFTRUE 89682
89680: GO 92305
89682: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89683: LD_ADDR_VAR 0 11
89687: PUSH
89688: LD_INT 1
89690: NEG
89691: PUSH
89692: LD_INT 3
89694: NEG
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 0
89702: PUSH
89703: LD_INT 3
89705: NEG
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 1
89713: PUSH
89714: LD_INT 2
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89727: LD_ADDR_VAR 0 12
89731: PUSH
89732: LD_INT 2
89734: PUSH
89735: LD_INT 1
89737: NEG
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 3
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 3
89755: PUSH
89756: LD_INT 1
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: LIST
89767: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89768: LD_ADDR_VAR 0 13
89772: PUSH
89773: LD_INT 3
89775: PUSH
89776: LD_INT 2
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 3
89785: PUSH
89786: LD_INT 3
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 2
89795: PUSH
89796: LD_INT 3
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: LIST
89807: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89808: LD_ADDR_VAR 0 14
89812: PUSH
89813: LD_INT 1
89815: PUSH
89816: LD_INT 3
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 0
89825: PUSH
89826: LD_INT 3
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: NEG
89836: PUSH
89837: LD_INT 2
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: LIST
89848: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89849: LD_ADDR_VAR 0 15
89853: PUSH
89854: LD_INT 2
89856: NEG
89857: PUSH
89858: LD_INT 1
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 3
89867: NEG
89868: PUSH
89869: LD_INT 0
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 3
89878: NEG
89879: PUSH
89880: LD_INT 1
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: LIST
89892: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89893: LD_ADDR_VAR 0 16
89897: PUSH
89898: LD_INT 2
89900: NEG
89901: PUSH
89902: LD_INT 3
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 3
89912: NEG
89913: PUSH
89914: LD_INT 2
89916: NEG
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 3
89924: NEG
89925: PUSH
89926: LD_INT 3
89928: NEG
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: LIST
89938: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89939: LD_ADDR_VAR 0 17
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: LD_INT 3
89950: NEG
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_INT 3
89961: NEG
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: LD_INT 2
89972: NEG
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: LIST
89982: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89983: LD_ADDR_VAR 0 18
89987: PUSH
89988: LD_INT 2
89990: PUSH
89991: LD_INT 1
89993: NEG
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 3
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 3
90011: PUSH
90012: LD_INT 1
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: LIST
90023: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90024: LD_ADDR_VAR 0 19
90028: PUSH
90029: LD_INT 3
90031: PUSH
90032: LD_INT 2
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: PUSH
90039: LD_INT 3
90041: PUSH
90042: LD_INT 3
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 3
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: LIST
90063: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90064: LD_ADDR_VAR 0 20
90068: PUSH
90069: LD_INT 1
90071: PUSH
90072: LD_INT 3
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 0
90081: PUSH
90082: LD_INT 3
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: LD_INT 2
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: LIST
90104: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90105: LD_ADDR_VAR 0 21
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 3
90123: NEG
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 3
90134: NEG
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: LIST
90148: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90149: LD_ADDR_VAR 0 22
90153: PUSH
90154: LD_INT 2
90156: NEG
90157: PUSH
90158: LD_INT 3
90160: NEG
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 3
90168: NEG
90169: PUSH
90170: LD_INT 2
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 3
90180: NEG
90181: PUSH
90182: LD_INT 3
90184: NEG
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: LIST
90194: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90195: LD_ADDR_VAR 0 23
90199: PUSH
90200: LD_INT 0
90202: PUSH
90203: LD_INT 3
90205: NEG
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 1
90213: NEG
90214: PUSH
90215: LD_INT 4
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: PUSH
90226: LD_INT 3
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: LIST
90238: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90239: LD_ADDR_VAR 0 24
90243: PUSH
90244: LD_INT 3
90246: PUSH
90247: LD_INT 0
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 3
90256: PUSH
90257: LD_INT 1
90259: NEG
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 4
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: LIST
90279: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90280: LD_ADDR_VAR 0 25
90284: PUSH
90285: LD_INT 3
90287: PUSH
90288: LD_INT 3
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 4
90297: PUSH
90298: LD_INT 3
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 3
90307: PUSH
90308: LD_INT 4
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: LIST
90319: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90320: LD_ADDR_VAR 0 26
90324: PUSH
90325: LD_INT 0
90327: PUSH
90328: LD_INT 3
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: PUSH
90338: LD_INT 4
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: LD_INT 3
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: LIST
90360: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90361: LD_ADDR_VAR 0 27
90365: PUSH
90366: LD_INT 3
90368: NEG
90369: PUSH
90370: LD_INT 0
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 3
90379: NEG
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 4
90390: NEG
90391: PUSH
90392: LD_INT 1
90394: NEG
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: LIST
90404: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90405: LD_ADDR_VAR 0 28
90409: PUSH
90410: LD_INT 3
90412: NEG
90413: PUSH
90414: LD_INT 3
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 3
90424: NEG
90425: PUSH
90426: LD_INT 4
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 4
90436: NEG
90437: PUSH
90438: LD_INT 3
90440: NEG
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: LIST
90450: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90451: LD_ADDR_VAR 0 29
90455: PUSH
90456: LD_INT 1
90458: NEG
90459: PUSH
90460: LD_INT 3
90462: NEG
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: PUSH
90468: LD_INT 0
90470: PUSH
90471: LD_INT 3
90473: NEG
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 1
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 4
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 4
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: PUSH
90516: LD_INT 3
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: LD_INT 5
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: LD_INT 5
90541: NEG
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: PUSH
90547: LD_INT 1
90549: PUSH
90550: LD_INT 4
90552: NEG
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: LD_INT 6
90564: NEG
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: LD_INT 6
90575: NEG
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: LD_INT 5
90586: NEG
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90606: LD_ADDR_VAR 0 30
90610: PUSH
90611: LD_INT 2
90613: PUSH
90614: LD_INT 1
90616: NEG
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: PUSH
90622: LD_INT 3
90624: PUSH
90625: LD_INT 0
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 3
90634: PUSH
90635: LD_INT 1
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 3
90644: PUSH
90645: LD_INT 1
90647: NEG
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 4
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 4
90665: PUSH
90666: LD_INT 1
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 4
90675: PUSH
90676: LD_INT 1
90678: NEG
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 5
90686: PUSH
90687: LD_INT 0
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 5
90696: PUSH
90697: LD_INT 1
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 5
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 6
90717: PUSH
90718: LD_INT 0
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: LD_INT 6
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90749: LD_ADDR_VAR 0 31
90753: PUSH
90754: LD_INT 3
90756: PUSH
90757: LD_INT 2
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 3
90766: PUSH
90767: LD_INT 3
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: LD_INT 3
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 4
90786: PUSH
90787: LD_INT 3
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 4
90796: PUSH
90797: LD_INT 4
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 3
90806: PUSH
90807: LD_INT 4
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 5
90816: PUSH
90817: LD_INT 4
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 5
90826: PUSH
90827: LD_INT 5
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 4
90836: PUSH
90837: LD_INT 5
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 6
90846: PUSH
90847: LD_INT 5
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 6
90856: PUSH
90857: LD_INT 6
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 5
90866: PUSH
90867: LD_INT 6
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90888: LD_ADDR_VAR 0 32
90892: PUSH
90893: LD_INT 1
90895: PUSH
90896: LD_INT 3
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: LD_INT 3
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 1
90915: NEG
90916: PUSH
90917: LD_INT 2
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 1
90926: PUSH
90927: LD_INT 4
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 0
90936: PUSH
90937: LD_INT 4
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 1
90946: NEG
90947: PUSH
90948: LD_INT 3
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: LD_INT 5
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 0
90967: PUSH
90968: LD_INT 5
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 1
90977: NEG
90978: PUSH
90979: LD_INT 4
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 1
90988: PUSH
90989: LD_INT 6
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 0
90998: PUSH
90999: LD_INT 6
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 1
91008: NEG
91009: PUSH
91010: LD_INT 5
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91031: LD_ADDR_VAR 0 33
91035: PUSH
91036: LD_INT 2
91038: NEG
91039: PUSH
91040: LD_INT 1
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 3
91049: NEG
91050: PUSH
91051: LD_INT 0
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 3
91060: NEG
91061: PUSH
91062: LD_INT 1
91064: NEG
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 3
91072: NEG
91073: PUSH
91074: LD_INT 1
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 4
91083: NEG
91084: PUSH
91085: LD_INT 0
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 4
91094: NEG
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 4
91106: NEG
91107: PUSH
91108: LD_INT 1
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 5
91117: NEG
91118: PUSH
91119: LD_INT 0
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 5
91128: NEG
91129: PUSH
91130: LD_INT 1
91132: NEG
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 5
91140: NEG
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 6
91151: NEG
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: PUSH
91160: LD_INT 6
91162: NEG
91163: PUSH
91164: LD_INT 1
91166: NEG
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91186: LD_ADDR_VAR 0 34
91190: PUSH
91191: LD_INT 2
91193: NEG
91194: PUSH
91195: LD_INT 3
91197: NEG
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 3
91205: NEG
91206: PUSH
91207: LD_INT 2
91209: NEG
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: LD_INT 3
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 3
91229: NEG
91230: PUSH
91231: LD_INT 4
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 4
91241: NEG
91242: PUSH
91243: LD_INT 3
91245: NEG
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 4
91253: NEG
91254: PUSH
91255: LD_INT 4
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 4
91265: NEG
91266: PUSH
91267: LD_INT 5
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 5
91277: NEG
91278: PUSH
91279: LD_INT 4
91281: NEG
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 5
91289: NEG
91290: PUSH
91291: LD_INT 5
91293: NEG
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 5
91301: NEG
91302: PUSH
91303: LD_INT 6
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 6
91313: NEG
91314: PUSH
91315: LD_INT 5
91317: NEG
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 6
91325: NEG
91326: PUSH
91327: LD_INT 6
91329: NEG
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91349: LD_ADDR_VAR 0 41
91353: PUSH
91354: LD_INT 0
91356: PUSH
91357: LD_INT 2
91359: NEG
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: LD_INT 3
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 1
91379: PUSH
91380: LD_INT 2
91382: NEG
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: LIST
91392: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91393: LD_ADDR_VAR 0 42
91397: PUSH
91398: LD_INT 2
91400: PUSH
91401: LD_INT 0
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 2
91410: PUSH
91411: LD_INT 1
91413: NEG
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91434: LD_ADDR_VAR 0 43
91438: PUSH
91439: LD_INT 2
91441: PUSH
91442: LD_INT 2
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 3
91451: PUSH
91452: LD_INT 2
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 2
91461: PUSH
91462: LD_INT 3
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91474: LD_ADDR_VAR 0 44
91478: PUSH
91479: LD_INT 0
91481: PUSH
91482: LD_INT 2
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: LD_INT 3
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: NEG
91502: PUSH
91503: LD_INT 2
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: LIST
91514: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91515: LD_ADDR_VAR 0 45
91519: PUSH
91520: LD_INT 2
91522: NEG
91523: PUSH
91524: LD_INT 0
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 2
91533: NEG
91534: PUSH
91535: LD_INT 1
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: PUSH
91542: LD_INT 3
91544: NEG
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: LIST
91558: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91559: LD_ADDR_VAR 0 46
91563: PUSH
91564: LD_INT 2
91566: NEG
91567: PUSH
91568: LD_INT 2
91570: NEG
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: LD_INT 3
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 3
91590: NEG
91591: PUSH
91592: LD_INT 2
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: LIST
91604: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91605: LD_ADDR_VAR 0 47
91609: PUSH
91610: LD_INT 2
91612: NEG
91613: PUSH
91614: LD_INT 3
91616: NEG
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91638: LD_ADDR_VAR 0 48
91642: PUSH
91643: LD_INT 1
91645: PUSH
91646: LD_INT 2
91648: NEG
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: PUSH
91657: LD_INT 1
91659: NEG
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91669: LD_ADDR_VAR 0 49
91673: PUSH
91674: LD_INT 3
91676: PUSH
91677: LD_INT 1
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 3
91686: PUSH
91687: LD_INT 2
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91698: LD_ADDR_VAR 0 50
91702: PUSH
91703: LD_INT 2
91705: PUSH
91706: LD_INT 3
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 1
91715: PUSH
91716: LD_INT 3
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91727: LD_ADDR_VAR 0 51
91731: PUSH
91732: LD_INT 1
91734: NEG
91735: PUSH
91736: LD_INT 2
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 2
91745: NEG
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91758: LD_ADDR_VAR 0 52
91762: PUSH
91763: LD_INT 3
91765: NEG
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: LD_INT 2
91781: NEG
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91791: LD_ADDR_VAR 0 53
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: LD_INT 3
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 0
91810: PUSH
91811: LD_INT 3
91813: NEG
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 1
91821: PUSH
91822: LD_INT 2
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91835: LD_ADDR_VAR 0 54
91839: PUSH
91840: LD_INT 2
91842: PUSH
91843: LD_INT 1
91845: NEG
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 3
91853: PUSH
91854: LD_INT 0
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 3
91863: PUSH
91864: LD_INT 1
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91876: LD_ADDR_VAR 0 55
91880: PUSH
91881: LD_INT 3
91883: PUSH
91884: LD_INT 2
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: LD_INT 3
91893: PUSH
91894: LD_INT 3
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: LD_INT 3
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: LIST
91915: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91916: LD_ADDR_VAR 0 56
91920: PUSH
91921: LD_INT 1
91923: PUSH
91924: LD_INT 3
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 3
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: LD_INT 2
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: LIST
91956: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91957: LD_ADDR_VAR 0 57
91961: PUSH
91962: LD_INT 2
91964: NEG
91965: PUSH
91966: LD_INT 1
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: NEG
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 3
91986: NEG
91987: PUSH
91988: LD_INT 1
91990: NEG
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: LIST
92000: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92001: LD_ADDR_VAR 0 58
92005: PUSH
92006: LD_INT 2
92008: NEG
92009: PUSH
92010: LD_INT 3
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 3
92020: NEG
92021: PUSH
92022: LD_INT 2
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 3
92032: NEG
92033: PUSH
92034: LD_INT 3
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92047: LD_ADDR_VAR 0 59
92051: PUSH
92052: LD_INT 1
92054: NEG
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 0
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 1
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92091: LD_ADDR_VAR 0 60
92095: PUSH
92096: LD_INT 1
92098: PUSH
92099: LD_INT 1
92101: NEG
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 2
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 2
92119: PUSH
92120: LD_INT 1
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: LIST
92131: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92132: LD_ADDR_VAR 0 61
92136: PUSH
92137: LD_INT 2
92139: PUSH
92140: LD_INT 1
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 2
92149: PUSH
92150: LD_INT 2
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: LD_INT 2
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: LIST
92171: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92172: LD_ADDR_VAR 0 62
92176: PUSH
92177: LD_INT 1
92179: PUSH
92180: LD_INT 2
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 0
92189: PUSH
92190: LD_INT 2
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 1
92199: NEG
92200: PUSH
92201: LD_INT 1
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: LIST
92212: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92213: LD_ADDR_VAR 0 63
92217: PUSH
92218: LD_INT 1
92220: NEG
92221: PUSH
92222: LD_INT 1
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 2
92231: NEG
92232: PUSH
92233: LD_INT 0
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: LD_INT 1
92246: NEG
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: LIST
92256: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92257: LD_ADDR_VAR 0 64
92261: PUSH
92262: LD_INT 1
92264: NEG
92265: PUSH
92266: LD_INT 2
92268: NEG
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: LD_INT 1
92280: NEG
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 2
92288: NEG
92289: PUSH
92290: LD_INT 2
92292: NEG
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// end ; 2 :
92303: GO 95569
92305: LD_INT 2
92307: DOUBLE
92308: EQUAL
92309: IFTRUE 92313
92311: GO 95568
92313: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92314: LD_ADDR_VAR 0 29
92318: PUSH
92319: LD_INT 4
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 4
92331: PUSH
92332: LD_INT 1
92334: NEG
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 5
92342: PUSH
92343: LD_INT 0
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 5
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 4
92362: PUSH
92363: LD_INT 1
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: LD_INT 3
92372: PUSH
92373: LD_INT 0
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 3
92382: PUSH
92383: LD_INT 1
92385: NEG
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 3
92393: PUSH
92394: LD_INT 2
92396: NEG
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 5
92404: PUSH
92405: LD_INT 2
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 3
92414: PUSH
92415: LD_INT 3
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 3
92424: PUSH
92425: LD_INT 2
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 4
92434: PUSH
92435: LD_INT 3
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 4
92444: PUSH
92445: LD_INT 4
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 3
92454: PUSH
92455: LD_INT 4
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 2
92464: PUSH
92465: LD_INT 3
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: LD_INT 2
92474: PUSH
92475: LD_INT 2
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 4
92484: PUSH
92485: LD_INT 2
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 2
92494: PUSH
92495: LD_INT 4
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: LD_INT 0
92504: PUSH
92505: LD_INT 4
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 0
92514: PUSH
92515: LD_INT 3
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 1
92524: PUSH
92525: LD_INT 4
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 1
92534: PUSH
92535: LD_INT 5
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: LD_INT 5
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 1
92554: NEG
92555: PUSH
92556: LD_INT 4
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 1
92565: NEG
92566: PUSH
92567: LD_INT 3
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 2
92576: PUSH
92577: LD_INT 5
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 2
92586: NEG
92587: PUSH
92588: LD_INT 3
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: NEG
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 3
92608: NEG
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 2
92620: NEG
92621: PUSH
92622: LD_INT 0
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 2
92631: NEG
92632: PUSH
92633: LD_INT 1
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 3
92642: NEG
92643: PUSH
92644: LD_INT 1
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 4
92653: NEG
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 4
92664: NEG
92665: PUSH
92666: LD_INT 1
92668: NEG
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 4
92676: NEG
92677: PUSH
92678: LD_INT 2
92680: NEG
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 2
92688: NEG
92689: PUSH
92690: LD_INT 2
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 4
92699: NEG
92700: PUSH
92701: LD_INT 4
92703: NEG
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 4
92711: NEG
92712: PUSH
92713: LD_INT 5
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 3
92723: NEG
92724: PUSH
92725: LD_INT 4
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: NEG
92736: PUSH
92737: LD_INT 3
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 4
92747: NEG
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 5
92759: NEG
92760: PUSH
92761: LD_INT 4
92763: NEG
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 5
92771: NEG
92772: PUSH
92773: LD_INT 5
92775: NEG
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 3
92783: NEG
92784: PUSH
92785: LD_INT 5
92787: NEG
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 5
92795: NEG
92796: PUSH
92797: LD_INT 3
92799: NEG
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92852: LD_ADDR_VAR 0 30
92856: PUSH
92857: LD_INT 4
92859: PUSH
92860: LD_INT 4
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 4
92869: PUSH
92870: LD_INT 3
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 5
92879: PUSH
92880: LD_INT 4
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 5
92889: PUSH
92890: LD_INT 5
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 4
92899: PUSH
92900: LD_INT 5
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 3
92909: PUSH
92910: LD_INT 4
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 3
92919: PUSH
92920: LD_INT 3
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 5
92929: PUSH
92930: LD_INT 3
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 3
92939: PUSH
92940: LD_INT 5
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: LD_INT 3
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 0
92959: PUSH
92960: LD_INT 2
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PUSH
92967: LD_INT 1
92969: PUSH
92970: LD_INT 3
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 1
92979: PUSH
92980: LD_INT 4
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 0
92989: PUSH
92990: LD_INT 4
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: LD_INT 1
92999: NEG
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 1
93010: NEG
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: PUSH
93022: LD_INT 4
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 2
93031: NEG
93032: PUSH
93033: LD_INT 2
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 4
93042: NEG
93043: PUSH
93044: LD_INT 0
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 4
93053: NEG
93054: PUSH
93055: LD_INT 1
93057: NEG
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 3
93065: NEG
93066: PUSH
93067: LD_INT 0
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 3
93076: NEG
93077: PUSH
93078: LD_INT 1
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: LD_INT 4
93087: NEG
93088: PUSH
93089: LD_INT 1
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 5
93098: NEG
93099: PUSH
93100: LD_INT 0
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 5
93109: NEG
93110: PUSH
93111: LD_INT 1
93113: NEG
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 5
93121: NEG
93122: PUSH
93123: LD_INT 2
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 3
93133: NEG
93134: PUSH
93135: LD_INT 2
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 3
93144: NEG
93145: PUSH
93146: LD_INT 3
93148: NEG
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 3
93156: NEG
93157: PUSH
93158: LD_INT 4
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 2
93168: NEG
93169: PUSH
93170: LD_INT 3
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 2
93180: NEG
93181: PUSH
93182: LD_INT 2
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 3
93192: NEG
93193: PUSH
93194: LD_INT 2
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 4
93204: NEG
93205: PUSH
93206: LD_INT 3
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 4
93216: NEG
93217: PUSH
93218: LD_INT 4
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 2
93228: NEG
93229: PUSH
93230: LD_INT 4
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 4
93240: NEG
93241: PUSH
93242: LD_INT 2
93244: NEG
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 0
93252: PUSH
93253: LD_INT 4
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 0
93263: PUSH
93264: LD_INT 5
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: LD_INT 4
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: LD_INT 3
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 0
93296: PUSH
93297: LD_INT 3
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: LD_INT 4
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: LD_INT 5
93323: NEG
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 2
93331: PUSH
93332: LD_INT 3
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 2
93342: NEG
93343: PUSH
93344: LD_INT 5
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: EMPTY
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93399: LD_ADDR_VAR 0 31
93403: PUSH
93404: LD_INT 0
93406: PUSH
93407: LD_INT 4
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 0
93416: PUSH
93417: LD_INT 3
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 1
93426: PUSH
93427: LD_INT 4
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: LD_INT 1
93436: PUSH
93437: LD_INT 5
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 0
93446: PUSH
93447: LD_INT 5
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 1
93456: NEG
93457: PUSH
93458: LD_INT 4
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 1
93467: NEG
93468: PUSH
93469: LD_INT 3
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 2
93478: PUSH
93479: LD_INT 5
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 2
93488: NEG
93489: PUSH
93490: LD_INT 3
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 3
93499: NEG
93500: PUSH
93501: LD_INT 0
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 3
93510: NEG
93511: PUSH
93512: LD_INT 1
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 2
93522: NEG
93523: PUSH
93524: LD_INT 0
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 2
93533: NEG
93534: PUSH
93535: LD_INT 1
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 3
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 4
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 4
93578: NEG
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 2
93590: NEG
93591: PUSH
93592: LD_INT 2
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 4
93601: NEG
93602: PUSH
93603: LD_INT 4
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 4
93613: NEG
93614: PUSH
93615: LD_INT 5
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 3
93625: NEG
93626: PUSH
93627: LD_INT 4
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 3
93637: NEG
93638: PUSH
93639: LD_INT 3
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 4
93649: NEG
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 5
93661: NEG
93662: PUSH
93663: LD_INT 4
93665: NEG
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 5
93673: NEG
93674: PUSH
93675: LD_INT 5
93677: NEG
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: LD_INT 3
93685: NEG
93686: PUSH
93687: LD_INT 5
93689: NEG
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 5
93697: NEG
93698: PUSH
93699: LD_INT 3
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 0
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 0
93720: PUSH
93721: LD_INT 4
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 1
93731: PUSH
93732: LD_INT 3
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 1
93742: PUSH
93743: LD_INT 2
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 0
93753: PUSH
93754: LD_INT 2
93756: NEG
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 1
93764: NEG
93765: PUSH
93766: LD_INT 3
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: NEG
93777: PUSH
93778: LD_INT 4
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: LD_INT 2
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 2
93799: NEG
93800: PUSH
93801: LD_INT 4
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 4
93811: PUSH
93812: LD_INT 0
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 4
93821: PUSH
93822: LD_INT 1
93824: NEG
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 5
93832: PUSH
93833: LD_INT 0
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 5
93842: PUSH
93843: LD_INT 1
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 4
93852: PUSH
93853: LD_INT 1
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 3
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 3
93872: PUSH
93873: LD_INT 1
93875: NEG
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 3
93883: PUSH
93884: LD_INT 2
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 5
93894: PUSH
93895: LD_INT 2
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93949: LD_ADDR_VAR 0 32
93953: PUSH
93954: LD_INT 4
93956: NEG
93957: PUSH
93958: LD_INT 0
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 4
93967: NEG
93968: PUSH
93969: LD_INT 1
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 3
93979: NEG
93980: PUSH
93981: LD_INT 0
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 3
93990: NEG
93991: PUSH
93992: LD_INT 1
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 4
94001: NEG
94002: PUSH
94003: LD_INT 1
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 5
94012: NEG
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 5
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 5
94035: NEG
94036: PUSH
94037: LD_INT 2
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 3
94047: NEG
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PUSH
94056: LD_INT 3
94058: NEG
94059: PUSH
94060: LD_INT 3
94062: NEG
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 3
94070: NEG
94071: PUSH
94072: LD_INT 4
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 2
94082: NEG
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 2
94094: NEG
94095: PUSH
94096: LD_INT 2
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 2
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 4
94118: NEG
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 4
94130: NEG
94131: PUSH
94132: LD_INT 4
94134: NEG
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: LD_INT 2
94142: NEG
94143: PUSH
94144: LD_INT 4
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 4
94154: NEG
94155: PUSH
94156: LD_INT 2
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 0
94166: PUSH
94167: LD_INT 4
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 0
94177: PUSH
94178: LD_INT 5
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 1
94188: PUSH
94189: LD_INT 4
94191: NEG
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 1
94199: PUSH
94200: LD_INT 3
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: LD_INT 3
94213: NEG
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: NEG
94222: PUSH
94223: LD_INT 4
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: NEG
94234: PUSH
94235: LD_INT 5
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 2
94245: PUSH
94246: LD_INT 3
94248: NEG
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 2
94256: NEG
94257: PUSH
94258: LD_INT 5
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: PUSH
94269: LD_INT 0
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 3
94278: PUSH
94279: LD_INT 1
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 4
94289: PUSH
94290: LD_INT 0
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 4
94299: PUSH
94300: LD_INT 1
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: LD_INT 3
94309: PUSH
94310: LD_INT 1
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 2
94319: PUSH
94320: LD_INT 0
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 2
94329: PUSH
94330: LD_INT 1
94332: NEG
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 2
94340: PUSH
94341: LD_INT 2
94343: NEG
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 4
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 4
94361: PUSH
94362: LD_INT 4
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: PUSH
94369: LD_INT 4
94371: PUSH
94372: LD_INT 3
94374: PUSH
94375: EMPTY
94376: LIST
94377: LIST
94378: PUSH
94379: LD_INT 5
94381: PUSH
94382: LD_INT 4
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 5
94391: PUSH
94392: LD_INT 5
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: PUSH
94399: LD_INT 4
94401: PUSH
94402: LD_INT 5
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 3
94411: PUSH
94412: LD_INT 4
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: PUSH
94419: LD_INT 3
94421: PUSH
94422: LD_INT 3
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 5
94431: PUSH
94432: LD_INT 3
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 3
94441: PUSH
94442: LD_INT 5
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94496: LD_ADDR_VAR 0 33
94500: PUSH
94501: LD_INT 4
94503: NEG
94504: PUSH
94505: LD_INT 4
94507: NEG
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 4
94515: NEG
94516: PUSH
94517: LD_INT 5
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 3
94527: NEG
94528: PUSH
94529: LD_INT 4
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 3
94539: NEG
94540: PUSH
94541: LD_INT 3
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 4
94551: NEG
94552: PUSH
94553: LD_INT 3
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 5
94563: NEG
94564: PUSH
94565: LD_INT 4
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 5
94575: NEG
94576: PUSH
94577: LD_INT 5
94579: NEG
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 3
94587: NEG
94588: PUSH
94589: LD_INT 5
94591: NEG
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PUSH
94597: LD_INT 5
94599: NEG
94600: PUSH
94601: LD_INT 3
94603: NEG
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: PUSH
94609: LD_INT 0
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 0
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 1
94633: PUSH
94634: LD_INT 3
94636: NEG
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 1
94644: PUSH
94645: LD_INT 2
94647: NEG
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: PUSH
94653: LD_INT 0
94655: PUSH
94656: LD_INT 2
94658: NEG
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 1
94666: NEG
94667: PUSH
94668: LD_INT 3
94670: NEG
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: PUSH
94676: LD_INT 1
94678: NEG
94679: PUSH
94680: LD_INT 4
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 2
94690: PUSH
94691: LD_INT 2
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 2
94701: NEG
94702: PUSH
94703: LD_INT 4
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 4
94713: PUSH
94714: LD_INT 0
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: LD_INT 1
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 5
94734: PUSH
94735: LD_INT 0
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 5
94744: PUSH
94745: LD_INT 1
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 4
94754: PUSH
94755: LD_INT 1
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 3
94764: PUSH
94765: LD_INT 0
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 3
94774: PUSH
94775: LD_INT 1
94777: NEG
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 3
94785: PUSH
94786: LD_INT 2
94788: NEG
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 5
94796: PUSH
94797: LD_INT 2
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: LD_INT 3
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 3
94816: PUSH
94817: LD_INT 2
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 4
94826: PUSH
94827: LD_INT 3
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 4
94836: PUSH
94837: LD_INT 4
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 3
94846: PUSH
94847: LD_INT 4
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: LD_INT 3
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 2
94866: PUSH
94867: LD_INT 2
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 4
94876: PUSH
94877: LD_INT 2
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 2
94886: PUSH
94887: LD_INT 4
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 0
94896: PUSH
94897: LD_INT 4
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 0
94906: PUSH
94907: LD_INT 3
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: PUSH
94917: LD_INT 4
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 1
94926: PUSH
94927: LD_INT 5
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 0
94936: PUSH
94937: LD_INT 5
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 1
94946: NEG
94947: PUSH
94948: LD_INT 4
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 1
94957: NEG
94958: PUSH
94959: LD_INT 3
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: LD_INT 5
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 2
94978: NEG
94979: PUSH
94980: LD_INT 3
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95034: LD_ADDR_VAR 0 34
95038: PUSH
95039: LD_INT 0
95041: PUSH
95042: LD_INT 4
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 0
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 1
95063: PUSH
95064: LD_INT 4
95066: NEG
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: LD_INT 3
95077: NEG
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 0
95085: PUSH
95086: LD_INT 3
95088: NEG
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 1
95096: NEG
95097: PUSH
95098: LD_INT 4
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 1
95108: NEG
95109: PUSH
95110: LD_INT 5
95112: NEG
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: PUSH
95118: LD_INT 2
95120: PUSH
95121: LD_INT 3
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 2
95131: NEG
95132: PUSH
95133: LD_INT 5
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 3
95143: PUSH
95144: LD_INT 0
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 3
95153: PUSH
95154: LD_INT 1
95156: NEG
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 4
95164: PUSH
95165: LD_INT 0
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 4
95174: PUSH
95175: LD_INT 1
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 3
95184: PUSH
95185: LD_INT 1
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 2
95194: PUSH
95195: LD_INT 0
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: LD_INT 1
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 2
95215: PUSH
95216: LD_INT 2
95218: NEG
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 4
95226: PUSH
95227: LD_INT 2
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 4
95236: PUSH
95237: LD_INT 4
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 4
95246: PUSH
95247: LD_INT 3
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: LD_INT 5
95256: PUSH
95257: LD_INT 4
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: LD_INT 5
95266: PUSH
95267: LD_INT 5
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 4
95276: PUSH
95277: LD_INT 5
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 3
95286: PUSH
95287: LD_INT 4
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 3
95296: PUSH
95297: LD_INT 3
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 5
95306: PUSH
95307: LD_INT 3
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 3
95316: PUSH
95317: LD_INT 5
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 0
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 0
95336: PUSH
95337: LD_INT 2
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 1
95346: PUSH
95347: LD_INT 3
95349: PUSH
95350: EMPTY
95351: LIST
95352: LIST
95353: PUSH
95354: LD_INT 1
95356: PUSH
95357: LD_INT 4
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: PUSH
95364: LD_INT 0
95366: PUSH
95367: LD_INT 4
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 1
95376: NEG
95377: PUSH
95378: LD_INT 3
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 1
95387: NEG
95388: PUSH
95389: LD_INT 2
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 2
95398: PUSH
95399: LD_INT 4
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 2
95408: NEG
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 4
95419: NEG
95420: PUSH
95421: LD_INT 0
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 4
95430: NEG
95431: PUSH
95432: LD_INT 1
95434: NEG
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 3
95442: NEG
95443: PUSH
95444: LD_INT 0
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 3
95453: NEG
95454: PUSH
95455: LD_INT 1
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 4
95464: NEG
95465: PUSH
95466: LD_INT 1
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 5
95475: NEG
95476: PUSH
95477: LD_INT 0
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 5
95486: NEG
95487: PUSH
95488: LD_INT 1
95490: NEG
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 5
95498: NEG
95499: PUSH
95500: LD_INT 2
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 3
95510: NEG
95511: PUSH
95512: LD_INT 2
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: ST_TO_ADDR
// end ; end ;
95566: GO 95569
95568: POP
// case btype of b_depot , b_warehouse :
95569: LD_VAR 0 1
95573: PUSH
95574: LD_INT 0
95576: DOUBLE
95577: EQUAL
95578: IFTRUE 95588
95580: LD_INT 1
95582: DOUBLE
95583: EQUAL
95584: IFTRUE 95588
95586: GO 95789
95588: POP
// case nation of nation_american :
95589: LD_VAR 0 5
95593: PUSH
95594: LD_INT 1
95596: DOUBLE
95597: EQUAL
95598: IFTRUE 95602
95600: GO 95658
95602: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95603: LD_ADDR_VAR 0 9
95607: PUSH
95608: LD_VAR 0 11
95612: PUSH
95613: LD_VAR 0 12
95617: PUSH
95618: LD_VAR 0 13
95622: PUSH
95623: LD_VAR 0 14
95627: PUSH
95628: LD_VAR 0 15
95632: PUSH
95633: LD_VAR 0 16
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: PUSH
95646: LD_VAR 0 4
95650: PUSH
95651: LD_INT 1
95653: PLUS
95654: ARRAY
95655: ST_TO_ADDR
95656: GO 95787
95658: LD_INT 2
95660: DOUBLE
95661: EQUAL
95662: IFTRUE 95666
95664: GO 95722
95666: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95667: LD_ADDR_VAR 0 9
95671: PUSH
95672: LD_VAR 0 17
95676: PUSH
95677: LD_VAR 0 18
95681: PUSH
95682: LD_VAR 0 19
95686: PUSH
95687: LD_VAR 0 20
95691: PUSH
95692: LD_VAR 0 21
95696: PUSH
95697: LD_VAR 0 22
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: PUSH
95710: LD_VAR 0 4
95714: PUSH
95715: LD_INT 1
95717: PLUS
95718: ARRAY
95719: ST_TO_ADDR
95720: GO 95787
95722: LD_INT 3
95724: DOUBLE
95725: EQUAL
95726: IFTRUE 95730
95728: GO 95786
95730: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95731: LD_ADDR_VAR 0 9
95735: PUSH
95736: LD_VAR 0 23
95740: PUSH
95741: LD_VAR 0 24
95745: PUSH
95746: LD_VAR 0 25
95750: PUSH
95751: LD_VAR 0 26
95755: PUSH
95756: LD_VAR 0 27
95760: PUSH
95761: LD_VAR 0 28
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: PUSH
95774: LD_VAR 0 4
95778: PUSH
95779: LD_INT 1
95781: PLUS
95782: ARRAY
95783: ST_TO_ADDR
95784: GO 95787
95786: POP
95787: GO 96336
95789: LD_INT 2
95791: DOUBLE
95792: EQUAL
95793: IFTRUE 95803
95795: LD_INT 3
95797: DOUBLE
95798: EQUAL
95799: IFTRUE 95803
95801: GO 95859
95803: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95804: LD_ADDR_VAR 0 9
95808: PUSH
95809: LD_VAR 0 29
95813: PUSH
95814: LD_VAR 0 30
95818: PUSH
95819: LD_VAR 0 31
95823: PUSH
95824: LD_VAR 0 32
95828: PUSH
95829: LD_VAR 0 33
95833: PUSH
95834: LD_VAR 0 34
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: PUSH
95847: LD_VAR 0 4
95851: PUSH
95852: LD_INT 1
95854: PLUS
95855: ARRAY
95856: ST_TO_ADDR
95857: GO 96336
95859: LD_INT 16
95861: DOUBLE
95862: EQUAL
95863: IFTRUE 95915
95865: LD_INT 17
95867: DOUBLE
95868: EQUAL
95869: IFTRUE 95915
95871: LD_INT 18
95873: DOUBLE
95874: EQUAL
95875: IFTRUE 95915
95877: LD_INT 19
95879: DOUBLE
95880: EQUAL
95881: IFTRUE 95915
95883: LD_INT 20
95885: DOUBLE
95886: EQUAL
95887: IFTRUE 95915
95889: LD_INT 21
95891: DOUBLE
95892: EQUAL
95893: IFTRUE 95915
95895: LD_INT 23
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95915
95901: LD_INT 24
95903: DOUBLE
95904: EQUAL
95905: IFTRUE 95915
95907: LD_INT 25
95909: DOUBLE
95910: EQUAL
95911: IFTRUE 95915
95913: GO 95971
95915: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95916: LD_ADDR_VAR 0 9
95920: PUSH
95921: LD_VAR 0 35
95925: PUSH
95926: LD_VAR 0 36
95930: PUSH
95931: LD_VAR 0 37
95935: PUSH
95936: LD_VAR 0 38
95940: PUSH
95941: LD_VAR 0 39
95945: PUSH
95946: LD_VAR 0 40
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: PUSH
95959: LD_VAR 0 4
95963: PUSH
95964: LD_INT 1
95966: PLUS
95967: ARRAY
95968: ST_TO_ADDR
95969: GO 96336
95971: LD_INT 6
95973: DOUBLE
95974: EQUAL
95975: IFTRUE 96027
95977: LD_INT 7
95979: DOUBLE
95980: EQUAL
95981: IFTRUE 96027
95983: LD_INT 8
95985: DOUBLE
95986: EQUAL
95987: IFTRUE 96027
95989: LD_INT 13
95991: DOUBLE
95992: EQUAL
95993: IFTRUE 96027
95995: LD_INT 12
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96027
96001: LD_INT 15
96003: DOUBLE
96004: EQUAL
96005: IFTRUE 96027
96007: LD_INT 11
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96027
96013: LD_INT 14
96015: DOUBLE
96016: EQUAL
96017: IFTRUE 96027
96019: LD_INT 10
96021: DOUBLE
96022: EQUAL
96023: IFTRUE 96027
96025: GO 96083
96027: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96028: LD_ADDR_VAR 0 9
96032: PUSH
96033: LD_VAR 0 41
96037: PUSH
96038: LD_VAR 0 42
96042: PUSH
96043: LD_VAR 0 43
96047: PUSH
96048: LD_VAR 0 44
96052: PUSH
96053: LD_VAR 0 45
96057: PUSH
96058: LD_VAR 0 46
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: PUSH
96071: LD_VAR 0 4
96075: PUSH
96076: LD_INT 1
96078: PLUS
96079: ARRAY
96080: ST_TO_ADDR
96081: GO 96336
96083: LD_INT 36
96085: DOUBLE
96086: EQUAL
96087: IFTRUE 96091
96089: GO 96147
96091: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96092: LD_ADDR_VAR 0 9
96096: PUSH
96097: LD_VAR 0 47
96101: PUSH
96102: LD_VAR 0 48
96106: PUSH
96107: LD_VAR 0 49
96111: PUSH
96112: LD_VAR 0 50
96116: PUSH
96117: LD_VAR 0 51
96121: PUSH
96122: LD_VAR 0 52
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: PUSH
96135: LD_VAR 0 4
96139: PUSH
96140: LD_INT 1
96142: PLUS
96143: ARRAY
96144: ST_TO_ADDR
96145: GO 96336
96147: LD_INT 4
96149: DOUBLE
96150: EQUAL
96151: IFTRUE 96173
96153: LD_INT 5
96155: DOUBLE
96156: EQUAL
96157: IFTRUE 96173
96159: LD_INT 34
96161: DOUBLE
96162: EQUAL
96163: IFTRUE 96173
96165: LD_INT 37
96167: DOUBLE
96168: EQUAL
96169: IFTRUE 96173
96171: GO 96229
96173: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96174: LD_ADDR_VAR 0 9
96178: PUSH
96179: LD_VAR 0 53
96183: PUSH
96184: LD_VAR 0 54
96188: PUSH
96189: LD_VAR 0 55
96193: PUSH
96194: LD_VAR 0 56
96198: PUSH
96199: LD_VAR 0 57
96203: PUSH
96204: LD_VAR 0 58
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: PUSH
96217: LD_VAR 0 4
96221: PUSH
96222: LD_INT 1
96224: PLUS
96225: ARRAY
96226: ST_TO_ADDR
96227: GO 96336
96229: LD_INT 31
96231: DOUBLE
96232: EQUAL
96233: IFTRUE 96279
96235: LD_INT 32
96237: DOUBLE
96238: EQUAL
96239: IFTRUE 96279
96241: LD_INT 33
96243: DOUBLE
96244: EQUAL
96245: IFTRUE 96279
96247: LD_INT 27
96249: DOUBLE
96250: EQUAL
96251: IFTRUE 96279
96253: LD_INT 26
96255: DOUBLE
96256: EQUAL
96257: IFTRUE 96279
96259: LD_INT 28
96261: DOUBLE
96262: EQUAL
96263: IFTRUE 96279
96265: LD_INT 29
96267: DOUBLE
96268: EQUAL
96269: IFTRUE 96279
96271: LD_INT 30
96273: DOUBLE
96274: EQUAL
96275: IFTRUE 96279
96277: GO 96335
96279: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96280: LD_ADDR_VAR 0 9
96284: PUSH
96285: LD_VAR 0 59
96289: PUSH
96290: LD_VAR 0 60
96294: PUSH
96295: LD_VAR 0 61
96299: PUSH
96300: LD_VAR 0 62
96304: PUSH
96305: LD_VAR 0 63
96309: PUSH
96310: LD_VAR 0 64
96314: PUSH
96315: EMPTY
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: PUSH
96323: LD_VAR 0 4
96327: PUSH
96328: LD_INT 1
96330: PLUS
96331: ARRAY
96332: ST_TO_ADDR
96333: GO 96336
96335: POP
// temp_list2 = [ ] ;
96336: LD_ADDR_VAR 0 10
96340: PUSH
96341: EMPTY
96342: ST_TO_ADDR
// for i in temp_list do
96343: LD_ADDR_VAR 0 8
96347: PUSH
96348: LD_VAR 0 9
96352: PUSH
96353: FOR_IN
96354: IFFALSE 96406
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96356: LD_ADDR_VAR 0 10
96360: PUSH
96361: LD_VAR 0 10
96365: PUSH
96366: LD_VAR 0 8
96370: PUSH
96371: LD_INT 1
96373: ARRAY
96374: PUSH
96375: LD_VAR 0 2
96379: PLUS
96380: PUSH
96381: LD_VAR 0 8
96385: PUSH
96386: LD_INT 2
96388: ARRAY
96389: PUSH
96390: LD_VAR 0 3
96394: PLUS
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: EMPTY
96401: LIST
96402: ADD
96403: ST_TO_ADDR
96404: GO 96353
96406: POP
96407: POP
// result = temp_list2 ;
96408: LD_ADDR_VAR 0 7
96412: PUSH
96413: LD_VAR 0 10
96417: ST_TO_ADDR
// end ;
96418: LD_VAR 0 7
96422: RET
// export function EnemyInRange ( unit , dist ) ; begin
96423: LD_INT 0
96425: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96426: LD_ADDR_VAR 0 3
96430: PUSH
96431: LD_VAR 0 1
96435: PPUSH
96436: CALL_OW 255
96440: PPUSH
96441: LD_VAR 0 1
96445: PPUSH
96446: CALL_OW 250
96450: PPUSH
96451: LD_VAR 0 1
96455: PPUSH
96456: CALL_OW 251
96460: PPUSH
96461: LD_VAR 0 2
96465: PPUSH
96466: CALL 70551 0 4
96470: PUSH
96471: LD_INT 4
96473: ARRAY
96474: ST_TO_ADDR
// end ;
96475: LD_VAR 0 3
96479: RET
// export function PlayerSeeMe ( unit ) ; begin
96480: LD_INT 0
96482: PPUSH
// result := See ( your_side , unit ) ;
96483: LD_ADDR_VAR 0 2
96487: PUSH
96488: LD_OWVAR 2
96492: PPUSH
96493: LD_VAR 0 1
96497: PPUSH
96498: CALL_OW 292
96502: ST_TO_ADDR
// end ;
96503: LD_VAR 0 2
96507: RET
// export function ReverseDir ( unit ) ; begin
96508: LD_INT 0
96510: PPUSH
// if not unit then
96511: LD_VAR 0 1
96515: NOT
96516: IFFALSE 96520
// exit ;
96518: GO 96566
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
96520: LD_ADDR_VAR 0 2
96524: PUSH
96525: LD_INT 3
96527: PUSH
96528: LD_INT 4
96530: PUSH
96531: LD_INT 5
96533: PUSH
96534: LD_INT 0
96536: PUSH
96537: LD_INT 1
96539: PUSH
96540: LD_INT 2
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: PUSH
96551: LD_VAR 0 1
96555: PPUSH
96556: CALL_OW 254
96560: PUSH
96561: LD_INT 1
96563: PLUS
96564: ARRAY
96565: ST_TO_ADDR
// end ;
96566: LD_VAR 0 2
96570: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96571: LD_INT 0
96573: PPUSH
96574: PPUSH
96575: PPUSH
96576: PPUSH
96577: PPUSH
// if not hexes then
96578: LD_VAR 0 2
96582: NOT
96583: IFFALSE 96587
// exit ;
96585: GO 96735
// dist := 9999 ;
96587: LD_ADDR_VAR 0 5
96591: PUSH
96592: LD_INT 9999
96594: ST_TO_ADDR
// for i = 1 to hexes do
96595: LD_ADDR_VAR 0 4
96599: PUSH
96600: DOUBLE
96601: LD_INT 1
96603: DEC
96604: ST_TO_ADDR
96605: LD_VAR 0 2
96609: PUSH
96610: FOR_TO
96611: IFFALSE 96723
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96613: LD_VAR 0 1
96617: PPUSH
96618: LD_VAR 0 2
96622: PUSH
96623: LD_VAR 0 4
96627: ARRAY
96628: PUSH
96629: LD_INT 1
96631: ARRAY
96632: PPUSH
96633: LD_VAR 0 2
96637: PUSH
96638: LD_VAR 0 4
96642: ARRAY
96643: PUSH
96644: LD_INT 2
96646: ARRAY
96647: PPUSH
96648: CALL_OW 297
96652: PUSH
96653: LD_VAR 0 5
96657: LESS
96658: IFFALSE 96721
// begin hex := hexes [ i ] ;
96660: LD_ADDR_VAR 0 7
96664: PUSH
96665: LD_VAR 0 2
96669: PUSH
96670: LD_VAR 0 4
96674: ARRAY
96675: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96676: LD_ADDR_VAR 0 5
96680: PUSH
96681: LD_VAR 0 1
96685: PPUSH
96686: LD_VAR 0 2
96690: PUSH
96691: LD_VAR 0 4
96695: ARRAY
96696: PUSH
96697: LD_INT 1
96699: ARRAY
96700: PPUSH
96701: LD_VAR 0 2
96705: PUSH
96706: LD_VAR 0 4
96710: ARRAY
96711: PUSH
96712: LD_INT 2
96714: ARRAY
96715: PPUSH
96716: CALL_OW 297
96720: ST_TO_ADDR
// end ; end ;
96721: GO 96610
96723: POP
96724: POP
// result := hex ;
96725: LD_ADDR_VAR 0 3
96729: PUSH
96730: LD_VAR 0 7
96734: ST_TO_ADDR
// end ;
96735: LD_VAR 0 3
96739: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96740: LD_INT 0
96742: PPUSH
96743: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96744: LD_VAR 0 1
96748: NOT
96749: PUSH
96750: LD_VAR 0 1
96754: PUSH
96755: LD_INT 21
96757: PUSH
96758: LD_INT 2
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: LD_INT 23
96767: PUSH
96768: LD_INT 2
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PPUSH
96779: CALL_OW 69
96783: IN
96784: NOT
96785: OR
96786: IFFALSE 96790
// exit ;
96788: GO 96837
// for i = 1 to 3 do
96790: LD_ADDR_VAR 0 3
96794: PUSH
96795: DOUBLE
96796: LD_INT 1
96798: DEC
96799: ST_TO_ADDR
96800: LD_INT 3
96802: PUSH
96803: FOR_TO
96804: IFFALSE 96835
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96806: LD_VAR 0 1
96810: PPUSH
96811: CALL_OW 250
96815: PPUSH
96816: LD_VAR 0 1
96820: PPUSH
96821: CALL_OW 251
96825: PPUSH
96826: LD_INT 1
96828: PPUSH
96829: CALL_OW 453
96833: GO 96803
96835: POP
96836: POP
// end ;
96837: LD_VAR 0 2
96841: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96842: LD_INT 0
96844: PPUSH
96845: PPUSH
96846: PPUSH
96847: PPUSH
96848: PPUSH
96849: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96850: LD_VAR 0 1
96854: NOT
96855: PUSH
96856: LD_VAR 0 2
96860: NOT
96861: OR
96862: PUSH
96863: LD_VAR 0 1
96867: PPUSH
96868: CALL_OW 314
96872: OR
96873: IFFALSE 96877
// exit ;
96875: GO 97318
// x := GetX ( enemy_unit ) ;
96877: LD_ADDR_VAR 0 7
96881: PUSH
96882: LD_VAR 0 2
96886: PPUSH
96887: CALL_OW 250
96891: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96892: LD_ADDR_VAR 0 8
96896: PUSH
96897: LD_VAR 0 2
96901: PPUSH
96902: CALL_OW 251
96906: ST_TO_ADDR
// if not x or not y then
96907: LD_VAR 0 7
96911: NOT
96912: PUSH
96913: LD_VAR 0 8
96917: NOT
96918: OR
96919: IFFALSE 96923
// exit ;
96921: GO 97318
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96923: LD_ADDR_VAR 0 6
96927: PUSH
96928: LD_VAR 0 7
96932: PPUSH
96933: LD_INT 0
96935: PPUSH
96936: LD_INT 4
96938: PPUSH
96939: CALL_OW 272
96943: PUSH
96944: LD_VAR 0 8
96948: PPUSH
96949: LD_INT 0
96951: PPUSH
96952: LD_INT 4
96954: PPUSH
96955: CALL_OW 273
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_VAR 0 7
96968: PPUSH
96969: LD_INT 1
96971: PPUSH
96972: LD_INT 4
96974: PPUSH
96975: CALL_OW 272
96979: PUSH
96980: LD_VAR 0 8
96984: PPUSH
96985: LD_INT 1
96987: PPUSH
96988: LD_INT 4
96990: PPUSH
96991: CALL_OW 273
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PUSH
97000: LD_VAR 0 7
97004: PPUSH
97005: LD_INT 2
97007: PPUSH
97008: LD_INT 4
97010: PPUSH
97011: CALL_OW 272
97015: PUSH
97016: LD_VAR 0 8
97020: PPUSH
97021: LD_INT 2
97023: PPUSH
97024: LD_INT 4
97026: PPUSH
97027: CALL_OW 273
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: LD_VAR 0 7
97040: PPUSH
97041: LD_INT 3
97043: PPUSH
97044: LD_INT 4
97046: PPUSH
97047: CALL_OW 272
97051: PUSH
97052: LD_VAR 0 8
97056: PPUSH
97057: LD_INT 3
97059: PPUSH
97060: LD_INT 4
97062: PPUSH
97063: CALL_OW 273
97067: PUSH
97068: EMPTY
97069: LIST
97070: LIST
97071: PUSH
97072: LD_VAR 0 7
97076: PPUSH
97077: LD_INT 4
97079: PPUSH
97080: LD_INT 4
97082: PPUSH
97083: CALL_OW 272
97087: PUSH
97088: LD_VAR 0 8
97092: PPUSH
97093: LD_INT 4
97095: PPUSH
97096: LD_INT 4
97098: PPUSH
97099: CALL_OW 273
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: PUSH
97108: LD_VAR 0 7
97112: PPUSH
97113: LD_INT 5
97115: PPUSH
97116: LD_INT 4
97118: PPUSH
97119: CALL_OW 272
97123: PUSH
97124: LD_VAR 0 8
97128: PPUSH
97129: LD_INT 5
97131: PPUSH
97132: LD_INT 4
97134: PPUSH
97135: CALL_OW 273
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: ST_TO_ADDR
// for i = tmp downto 1 do
97152: LD_ADDR_VAR 0 4
97156: PUSH
97157: DOUBLE
97158: LD_VAR 0 6
97162: INC
97163: ST_TO_ADDR
97164: LD_INT 1
97166: PUSH
97167: FOR_DOWNTO
97168: IFFALSE 97269
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97170: LD_VAR 0 6
97174: PUSH
97175: LD_VAR 0 4
97179: ARRAY
97180: PUSH
97181: LD_INT 1
97183: ARRAY
97184: PPUSH
97185: LD_VAR 0 6
97189: PUSH
97190: LD_VAR 0 4
97194: ARRAY
97195: PUSH
97196: LD_INT 2
97198: ARRAY
97199: PPUSH
97200: CALL_OW 488
97204: NOT
97205: PUSH
97206: LD_VAR 0 6
97210: PUSH
97211: LD_VAR 0 4
97215: ARRAY
97216: PUSH
97217: LD_INT 1
97219: ARRAY
97220: PPUSH
97221: LD_VAR 0 6
97225: PUSH
97226: LD_VAR 0 4
97230: ARRAY
97231: PUSH
97232: LD_INT 2
97234: ARRAY
97235: PPUSH
97236: CALL_OW 428
97240: PUSH
97241: LD_INT 0
97243: NONEQUAL
97244: OR
97245: IFFALSE 97267
// tmp := Delete ( tmp , i ) ;
97247: LD_ADDR_VAR 0 6
97251: PUSH
97252: LD_VAR 0 6
97256: PPUSH
97257: LD_VAR 0 4
97261: PPUSH
97262: CALL_OW 3
97266: ST_TO_ADDR
97267: GO 97167
97269: POP
97270: POP
// j := GetClosestHex ( unit , tmp ) ;
97271: LD_ADDR_VAR 0 5
97275: PUSH
97276: LD_VAR 0 1
97280: PPUSH
97281: LD_VAR 0 6
97285: PPUSH
97286: CALL 96571 0 2
97290: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97291: LD_VAR 0 1
97295: PPUSH
97296: LD_VAR 0 5
97300: PUSH
97301: LD_INT 1
97303: ARRAY
97304: PPUSH
97305: LD_VAR 0 5
97309: PUSH
97310: LD_INT 2
97312: ARRAY
97313: PPUSH
97314: CALL_OW 111
// end ;
97318: LD_VAR 0 3
97322: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97323: LD_INT 0
97325: PPUSH
97326: PPUSH
97327: PPUSH
// uc_side = 0 ;
97328: LD_ADDR_OWVAR 20
97332: PUSH
97333: LD_INT 0
97335: ST_TO_ADDR
// uc_nation = 0 ;
97336: LD_ADDR_OWVAR 21
97340: PUSH
97341: LD_INT 0
97343: ST_TO_ADDR
// InitHc ;
97344: CALL_OW 19
// InitVc ;
97348: CALL_OW 20
// if mastodonts then
97352: LD_VAR 0 6
97356: IFFALSE 97423
// for i = 1 to mastodonts do
97358: LD_ADDR_VAR 0 11
97362: PUSH
97363: DOUBLE
97364: LD_INT 1
97366: DEC
97367: ST_TO_ADDR
97368: LD_VAR 0 6
97372: PUSH
97373: FOR_TO
97374: IFFALSE 97421
// begin vc_chassis := 31 ;
97376: LD_ADDR_OWVAR 37
97380: PUSH
97381: LD_INT 31
97383: ST_TO_ADDR
// vc_control := control_rider ;
97384: LD_ADDR_OWVAR 38
97388: PUSH
97389: LD_INT 4
97391: ST_TO_ADDR
// animal := CreateVehicle ;
97392: LD_ADDR_VAR 0 12
97396: PUSH
97397: CALL_OW 45
97401: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97402: LD_VAR 0 12
97406: PPUSH
97407: LD_VAR 0 8
97411: PPUSH
97412: LD_INT 0
97414: PPUSH
97415: CALL 104168 0 3
// end ;
97419: GO 97373
97421: POP
97422: POP
// if horses then
97423: LD_VAR 0 5
97427: IFFALSE 97494
// for i = 1 to horses do
97429: LD_ADDR_VAR 0 11
97433: PUSH
97434: DOUBLE
97435: LD_INT 1
97437: DEC
97438: ST_TO_ADDR
97439: LD_VAR 0 5
97443: PUSH
97444: FOR_TO
97445: IFFALSE 97492
// begin hc_class := 21 ;
97447: LD_ADDR_OWVAR 28
97451: PUSH
97452: LD_INT 21
97454: ST_TO_ADDR
// hc_gallery :=  ;
97455: LD_ADDR_OWVAR 33
97459: PUSH
97460: LD_STRING 
97462: ST_TO_ADDR
// animal := CreateHuman ;
97463: LD_ADDR_VAR 0 12
97467: PUSH
97468: CALL_OW 44
97472: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97473: LD_VAR 0 12
97477: PPUSH
97478: LD_VAR 0 8
97482: PPUSH
97483: LD_INT 0
97485: PPUSH
97486: CALL 104168 0 3
// end ;
97490: GO 97444
97492: POP
97493: POP
// if birds then
97494: LD_VAR 0 1
97498: IFFALSE 97565
// for i = 1 to birds do
97500: LD_ADDR_VAR 0 11
97504: PUSH
97505: DOUBLE
97506: LD_INT 1
97508: DEC
97509: ST_TO_ADDR
97510: LD_VAR 0 1
97514: PUSH
97515: FOR_TO
97516: IFFALSE 97563
// begin hc_class = 18 ;
97518: LD_ADDR_OWVAR 28
97522: PUSH
97523: LD_INT 18
97525: ST_TO_ADDR
// hc_gallery =  ;
97526: LD_ADDR_OWVAR 33
97530: PUSH
97531: LD_STRING 
97533: ST_TO_ADDR
// animal := CreateHuman ;
97534: LD_ADDR_VAR 0 12
97538: PUSH
97539: CALL_OW 44
97543: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97544: LD_VAR 0 12
97548: PPUSH
97549: LD_VAR 0 8
97553: PPUSH
97554: LD_INT 0
97556: PPUSH
97557: CALL 104168 0 3
// end ;
97561: GO 97515
97563: POP
97564: POP
// if tigers then
97565: LD_VAR 0 2
97569: IFFALSE 97653
// for i = 1 to tigers do
97571: LD_ADDR_VAR 0 11
97575: PUSH
97576: DOUBLE
97577: LD_INT 1
97579: DEC
97580: ST_TO_ADDR
97581: LD_VAR 0 2
97585: PUSH
97586: FOR_TO
97587: IFFALSE 97651
// begin hc_class = class_tiger ;
97589: LD_ADDR_OWVAR 28
97593: PUSH
97594: LD_INT 14
97596: ST_TO_ADDR
// hc_gallery =  ;
97597: LD_ADDR_OWVAR 33
97601: PUSH
97602: LD_STRING 
97604: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97605: LD_ADDR_OWVAR 35
97609: PUSH
97610: LD_INT 7
97612: NEG
97613: PPUSH
97614: LD_INT 7
97616: PPUSH
97617: CALL_OW 12
97621: ST_TO_ADDR
// animal := CreateHuman ;
97622: LD_ADDR_VAR 0 12
97626: PUSH
97627: CALL_OW 44
97631: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97632: LD_VAR 0 12
97636: PPUSH
97637: LD_VAR 0 8
97641: PPUSH
97642: LD_INT 0
97644: PPUSH
97645: CALL 104168 0 3
// end ;
97649: GO 97586
97651: POP
97652: POP
// if apemans then
97653: LD_VAR 0 3
97657: IFFALSE 97780
// for i = 1 to apemans do
97659: LD_ADDR_VAR 0 11
97663: PUSH
97664: DOUBLE
97665: LD_INT 1
97667: DEC
97668: ST_TO_ADDR
97669: LD_VAR 0 3
97673: PUSH
97674: FOR_TO
97675: IFFALSE 97778
// begin hc_class = class_apeman ;
97677: LD_ADDR_OWVAR 28
97681: PUSH
97682: LD_INT 12
97684: ST_TO_ADDR
// hc_gallery =  ;
97685: LD_ADDR_OWVAR 33
97689: PUSH
97690: LD_STRING 
97692: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97693: LD_ADDR_OWVAR 35
97697: PUSH
97698: LD_INT 5
97700: NEG
97701: PPUSH
97702: LD_INT 5
97704: PPUSH
97705: CALL_OW 12
97709: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97710: LD_ADDR_OWVAR 31
97714: PUSH
97715: LD_INT 1
97717: PPUSH
97718: LD_INT 3
97720: PPUSH
97721: CALL_OW 12
97725: PUSH
97726: LD_INT 1
97728: PPUSH
97729: LD_INT 3
97731: PPUSH
97732: CALL_OW 12
97736: PUSH
97737: LD_INT 0
97739: PUSH
97740: LD_INT 0
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: ST_TO_ADDR
// animal := CreateHuman ;
97749: LD_ADDR_VAR 0 12
97753: PUSH
97754: CALL_OW 44
97758: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97759: LD_VAR 0 12
97763: PPUSH
97764: LD_VAR 0 8
97768: PPUSH
97769: LD_INT 0
97771: PPUSH
97772: CALL 104168 0 3
// end ;
97776: GO 97674
97778: POP
97779: POP
// if enchidnas then
97780: LD_VAR 0 4
97784: IFFALSE 97851
// for i = 1 to enchidnas do
97786: LD_ADDR_VAR 0 11
97790: PUSH
97791: DOUBLE
97792: LD_INT 1
97794: DEC
97795: ST_TO_ADDR
97796: LD_VAR 0 4
97800: PUSH
97801: FOR_TO
97802: IFFALSE 97849
// begin hc_class = 13 ;
97804: LD_ADDR_OWVAR 28
97808: PUSH
97809: LD_INT 13
97811: ST_TO_ADDR
// hc_gallery =  ;
97812: LD_ADDR_OWVAR 33
97816: PUSH
97817: LD_STRING 
97819: ST_TO_ADDR
// animal := CreateHuman ;
97820: LD_ADDR_VAR 0 12
97824: PUSH
97825: CALL_OW 44
97829: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97830: LD_VAR 0 12
97834: PPUSH
97835: LD_VAR 0 8
97839: PPUSH
97840: LD_INT 0
97842: PPUSH
97843: CALL 104168 0 3
// end ;
97847: GO 97801
97849: POP
97850: POP
// if fishes then
97851: LD_VAR 0 7
97855: IFFALSE 97922
// for i = 1 to fishes do
97857: LD_ADDR_VAR 0 11
97861: PUSH
97862: DOUBLE
97863: LD_INT 1
97865: DEC
97866: ST_TO_ADDR
97867: LD_VAR 0 7
97871: PUSH
97872: FOR_TO
97873: IFFALSE 97920
// begin hc_class = 20 ;
97875: LD_ADDR_OWVAR 28
97879: PUSH
97880: LD_INT 20
97882: ST_TO_ADDR
// hc_gallery =  ;
97883: LD_ADDR_OWVAR 33
97887: PUSH
97888: LD_STRING 
97890: ST_TO_ADDR
// animal := CreateHuman ;
97891: LD_ADDR_VAR 0 12
97895: PUSH
97896: CALL_OW 44
97900: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97901: LD_VAR 0 12
97905: PPUSH
97906: LD_VAR 0 9
97910: PPUSH
97911: LD_INT 0
97913: PPUSH
97914: CALL 104168 0 3
// end ;
97918: GO 97872
97920: POP
97921: POP
// end ;
97922: LD_VAR 0 10
97926: RET
// export function WantHeal ( sci , unit ) ; begin
97927: LD_INT 0
97929: PPUSH
// if GetTaskList ( sci ) > 0 then
97930: LD_VAR 0 1
97934: PPUSH
97935: CALL_OW 437
97939: PUSH
97940: LD_INT 0
97942: GREATER
97943: IFFALSE 98013
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97945: LD_VAR 0 1
97949: PPUSH
97950: CALL_OW 437
97954: PUSH
97955: LD_INT 1
97957: ARRAY
97958: PUSH
97959: LD_INT 1
97961: ARRAY
97962: PUSH
97963: LD_STRING l
97965: EQUAL
97966: PUSH
97967: LD_VAR 0 1
97971: PPUSH
97972: CALL_OW 437
97976: PUSH
97977: LD_INT 1
97979: ARRAY
97980: PUSH
97981: LD_INT 4
97983: ARRAY
97984: PUSH
97985: LD_VAR 0 2
97989: EQUAL
97990: AND
97991: IFFALSE 98003
// result := true else
97993: LD_ADDR_VAR 0 3
97997: PUSH
97998: LD_INT 1
98000: ST_TO_ADDR
98001: GO 98011
// result := false ;
98003: LD_ADDR_VAR 0 3
98007: PUSH
98008: LD_INT 0
98010: ST_TO_ADDR
// end else
98011: GO 98021
// result := false ;
98013: LD_ADDR_VAR 0 3
98017: PUSH
98018: LD_INT 0
98020: ST_TO_ADDR
// end ;
98021: LD_VAR 0 3
98025: RET
// export function HealTarget ( sci ) ; begin
98026: LD_INT 0
98028: PPUSH
// if not sci then
98029: LD_VAR 0 1
98033: NOT
98034: IFFALSE 98038
// exit ;
98036: GO 98103
// result := 0 ;
98038: LD_ADDR_VAR 0 2
98042: PUSH
98043: LD_INT 0
98045: ST_TO_ADDR
// if GetTaskList ( sci ) then
98046: LD_VAR 0 1
98050: PPUSH
98051: CALL_OW 437
98055: IFFALSE 98103
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98057: LD_VAR 0 1
98061: PPUSH
98062: CALL_OW 437
98066: PUSH
98067: LD_INT 1
98069: ARRAY
98070: PUSH
98071: LD_INT 1
98073: ARRAY
98074: PUSH
98075: LD_STRING l
98077: EQUAL
98078: IFFALSE 98103
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98080: LD_ADDR_VAR 0 2
98084: PUSH
98085: LD_VAR 0 1
98089: PPUSH
98090: CALL_OW 437
98094: PUSH
98095: LD_INT 1
98097: ARRAY
98098: PUSH
98099: LD_INT 4
98101: ARRAY
98102: ST_TO_ADDR
// end ;
98103: LD_VAR 0 2
98107: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98108: LD_INT 0
98110: PPUSH
98111: PPUSH
98112: PPUSH
98113: PPUSH
98114: PPUSH
98115: PPUSH
98116: PPUSH
98117: PPUSH
98118: PPUSH
98119: PPUSH
98120: PPUSH
98121: PPUSH
98122: PPUSH
98123: PPUSH
98124: PPUSH
98125: PPUSH
98126: PPUSH
98127: PPUSH
98128: PPUSH
98129: PPUSH
98130: PPUSH
98131: PPUSH
98132: PPUSH
98133: PPUSH
98134: PPUSH
98135: PPUSH
98136: PPUSH
98137: PPUSH
98138: PPUSH
98139: PPUSH
98140: PPUSH
98141: PPUSH
98142: PPUSH
98143: PPUSH
// if not list then
98144: LD_VAR 0 1
98148: NOT
98149: IFFALSE 98153
// exit ;
98151: GO 102779
// base := list [ 1 ] ;
98153: LD_ADDR_VAR 0 3
98157: PUSH
98158: LD_VAR 0 1
98162: PUSH
98163: LD_INT 1
98165: ARRAY
98166: ST_TO_ADDR
// group := list [ 2 ] ;
98167: LD_ADDR_VAR 0 4
98171: PUSH
98172: LD_VAR 0 1
98176: PUSH
98177: LD_INT 2
98179: ARRAY
98180: ST_TO_ADDR
// path := list [ 3 ] ;
98181: LD_ADDR_VAR 0 5
98185: PUSH
98186: LD_VAR 0 1
98190: PUSH
98191: LD_INT 3
98193: ARRAY
98194: ST_TO_ADDR
// flags := list [ 4 ] ;
98195: LD_ADDR_VAR 0 6
98199: PUSH
98200: LD_VAR 0 1
98204: PUSH
98205: LD_INT 4
98207: ARRAY
98208: ST_TO_ADDR
// mined := [ ] ;
98209: LD_ADDR_VAR 0 27
98213: PUSH
98214: EMPTY
98215: ST_TO_ADDR
// bombed := [ ] ;
98216: LD_ADDR_VAR 0 28
98220: PUSH
98221: EMPTY
98222: ST_TO_ADDR
// healers := [ ] ;
98223: LD_ADDR_VAR 0 31
98227: PUSH
98228: EMPTY
98229: ST_TO_ADDR
// to_heal := [ ] ;
98230: LD_ADDR_VAR 0 30
98234: PUSH
98235: EMPTY
98236: ST_TO_ADDR
// repairs := [ ] ;
98237: LD_ADDR_VAR 0 33
98241: PUSH
98242: EMPTY
98243: ST_TO_ADDR
// to_repair := [ ] ;
98244: LD_ADDR_VAR 0 32
98248: PUSH
98249: EMPTY
98250: ST_TO_ADDR
// if not group or not path then
98251: LD_VAR 0 4
98255: NOT
98256: PUSH
98257: LD_VAR 0 5
98261: NOT
98262: OR
98263: IFFALSE 98267
// exit ;
98265: GO 102779
// side := GetSide ( group [ 1 ] ) ;
98267: LD_ADDR_VAR 0 35
98271: PUSH
98272: LD_VAR 0 4
98276: PUSH
98277: LD_INT 1
98279: ARRAY
98280: PPUSH
98281: CALL_OW 255
98285: ST_TO_ADDR
// if flags then
98286: LD_VAR 0 6
98290: IFFALSE 98434
// begin f_ignore_area := flags [ 1 ] ;
98292: LD_ADDR_VAR 0 17
98296: PUSH
98297: LD_VAR 0 6
98301: PUSH
98302: LD_INT 1
98304: ARRAY
98305: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98306: LD_ADDR_VAR 0 18
98310: PUSH
98311: LD_VAR 0 6
98315: PUSH
98316: LD_INT 2
98318: ARRAY
98319: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98320: LD_ADDR_VAR 0 19
98324: PUSH
98325: LD_VAR 0 6
98329: PUSH
98330: LD_INT 3
98332: ARRAY
98333: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98334: LD_ADDR_VAR 0 20
98338: PUSH
98339: LD_VAR 0 6
98343: PUSH
98344: LD_INT 4
98346: ARRAY
98347: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98348: LD_ADDR_VAR 0 21
98352: PUSH
98353: LD_VAR 0 6
98357: PUSH
98358: LD_INT 5
98360: ARRAY
98361: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98362: LD_ADDR_VAR 0 22
98366: PUSH
98367: LD_VAR 0 6
98371: PUSH
98372: LD_INT 6
98374: ARRAY
98375: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98376: LD_ADDR_VAR 0 23
98380: PUSH
98381: LD_VAR 0 6
98385: PUSH
98386: LD_INT 7
98388: ARRAY
98389: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98390: LD_ADDR_VAR 0 24
98394: PUSH
98395: LD_VAR 0 6
98399: PUSH
98400: LD_INT 8
98402: ARRAY
98403: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98404: LD_ADDR_VAR 0 25
98408: PUSH
98409: LD_VAR 0 6
98413: PUSH
98414: LD_INT 9
98416: ARRAY
98417: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98418: LD_ADDR_VAR 0 26
98422: PUSH
98423: LD_VAR 0 6
98427: PUSH
98428: LD_INT 10
98430: ARRAY
98431: ST_TO_ADDR
// end else
98432: GO 98514
// begin f_ignore_area := false ;
98434: LD_ADDR_VAR 0 17
98438: PUSH
98439: LD_INT 0
98441: ST_TO_ADDR
// f_capture := false ;
98442: LD_ADDR_VAR 0 18
98446: PUSH
98447: LD_INT 0
98449: ST_TO_ADDR
// f_ignore_civ := false ;
98450: LD_ADDR_VAR 0 19
98454: PUSH
98455: LD_INT 0
98457: ST_TO_ADDR
// f_murder := false ;
98458: LD_ADDR_VAR 0 20
98462: PUSH
98463: LD_INT 0
98465: ST_TO_ADDR
// f_mines := false ;
98466: LD_ADDR_VAR 0 21
98470: PUSH
98471: LD_INT 0
98473: ST_TO_ADDR
// f_repair := false ;
98474: LD_ADDR_VAR 0 22
98478: PUSH
98479: LD_INT 0
98481: ST_TO_ADDR
// f_heal := false ;
98482: LD_ADDR_VAR 0 23
98486: PUSH
98487: LD_INT 0
98489: ST_TO_ADDR
// f_spacetime := false ;
98490: LD_ADDR_VAR 0 24
98494: PUSH
98495: LD_INT 0
98497: ST_TO_ADDR
// f_attack_depot := false ;
98498: LD_ADDR_VAR 0 25
98502: PUSH
98503: LD_INT 0
98505: ST_TO_ADDR
// f_crawl := false ;
98506: LD_ADDR_VAR 0 26
98510: PUSH
98511: LD_INT 0
98513: ST_TO_ADDR
// end ; if f_heal then
98514: LD_VAR 0 23
98518: IFFALSE 98545
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98520: LD_ADDR_VAR 0 31
98524: PUSH
98525: LD_VAR 0 4
98529: PPUSH
98530: LD_INT 25
98532: PUSH
98533: LD_INT 4
98535: PUSH
98536: EMPTY
98537: LIST
98538: LIST
98539: PPUSH
98540: CALL_OW 72
98544: ST_TO_ADDR
// if f_repair then
98545: LD_VAR 0 22
98549: IFFALSE 98576
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98551: LD_ADDR_VAR 0 33
98555: PUSH
98556: LD_VAR 0 4
98560: PPUSH
98561: LD_INT 25
98563: PUSH
98564: LD_INT 3
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: PPUSH
98571: CALL_OW 72
98575: ST_TO_ADDR
// units_path := [ ] ;
98576: LD_ADDR_VAR 0 16
98580: PUSH
98581: EMPTY
98582: ST_TO_ADDR
// for i = 1 to group do
98583: LD_ADDR_VAR 0 7
98587: PUSH
98588: DOUBLE
98589: LD_INT 1
98591: DEC
98592: ST_TO_ADDR
98593: LD_VAR 0 4
98597: PUSH
98598: FOR_TO
98599: IFFALSE 98628
// units_path := Replace ( units_path , i , path ) ;
98601: LD_ADDR_VAR 0 16
98605: PUSH
98606: LD_VAR 0 16
98610: PPUSH
98611: LD_VAR 0 7
98615: PPUSH
98616: LD_VAR 0 5
98620: PPUSH
98621: CALL_OW 1
98625: ST_TO_ADDR
98626: GO 98598
98628: POP
98629: POP
// repeat for i = group downto 1 do
98630: LD_ADDR_VAR 0 7
98634: PUSH
98635: DOUBLE
98636: LD_VAR 0 4
98640: INC
98641: ST_TO_ADDR
98642: LD_INT 1
98644: PUSH
98645: FOR_DOWNTO
98646: IFFALSE 102742
// begin wait ( 5 ) ;
98648: LD_INT 5
98650: PPUSH
98651: CALL_OW 67
// tmp := [ ] ;
98655: LD_ADDR_VAR 0 14
98659: PUSH
98660: EMPTY
98661: ST_TO_ADDR
// attacking := false ;
98662: LD_ADDR_VAR 0 29
98666: PUSH
98667: LD_INT 0
98669: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98670: LD_VAR 0 4
98674: PUSH
98675: LD_VAR 0 7
98679: ARRAY
98680: PPUSH
98681: CALL_OW 301
98685: PUSH
98686: LD_VAR 0 4
98690: PUSH
98691: LD_VAR 0 7
98695: ARRAY
98696: NOT
98697: OR
98698: IFFALSE 98807
// begin if GetType ( group [ i ] ) = unit_human then
98700: LD_VAR 0 4
98704: PUSH
98705: LD_VAR 0 7
98709: ARRAY
98710: PPUSH
98711: CALL_OW 247
98715: PUSH
98716: LD_INT 1
98718: EQUAL
98719: IFFALSE 98765
// begin to_heal := to_heal diff group [ i ] ;
98721: LD_ADDR_VAR 0 30
98725: PUSH
98726: LD_VAR 0 30
98730: PUSH
98731: LD_VAR 0 4
98735: PUSH
98736: LD_VAR 0 7
98740: ARRAY
98741: DIFF
98742: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98743: LD_ADDR_VAR 0 31
98747: PUSH
98748: LD_VAR 0 31
98752: PUSH
98753: LD_VAR 0 4
98757: PUSH
98758: LD_VAR 0 7
98762: ARRAY
98763: DIFF
98764: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98765: LD_ADDR_VAR 0 4
98769: PUSH
98770: LD_VAR 0 4
98774: PPUSH
98775: LD_VAR 0 7
98779: PPUSH
98780: CALL_OW 3
98784: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98785: LD_ADDR_VAR 0 16
98789: PUSH
98790: LD_VAR 0 16
98794: PPUSH
98795: LD_VAR 0 7
98799: PPUSH
98800: CALL_OW 3
98804: ST_TO_ADDR
// continue ;
98805: GO 98645
// end ; if f_repair then
98807: LD_VAR 0 22
98811: IFFALSE 99300
// begin if GetType ( group [ i ] ) = unit_vehicle then
98813: LD_VAR 0 4
98817: PUSH
98818: LD_VAR 0 7
98822: ARRAY
98823: PPUSH
98824: CALL_OW 247
98828: PUSH
98829: LD_INT 2
98831: EQUAL
98832: IFFALSE 99022
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98834: LD_VAR 0 4
98838: PUSH
98839: LD_VAR 0 7
98843: ARRAY
98844: PPUSH
98845: CALL_OW 256
98849: PUSH
98850: LD_INT 700
98852: LESS
98853: PUSH
98854: LD_VAR 0 4
98858: PUSH
98859: LD_VAR 0 7
98863: ARRAY
98864: PUSH
98865: LD_VAR 0 32
98869: IN
98870: NOT
98871: AND
98872: IFFALSE 98896
// to_repair := to_repair union group [ i ] ;
98874: LD_ADDR_VAR 0 32
98878: PUSH
98879: LD_VAR 0 32
98883: PUSH
98884: LD_VAR 0 4
98888: PUSH
98889: LD_VAR 0 7
98893: ARRAY
98894: UNION
98895: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98896: LD_VAR 0 4
98900: PUSH
98901: LD_VAR 0 7
98905: ARRAY
98906: PPUSH
98907: CALL_OW 256
98911: PUSH
98912: LD_INT 1000
98914: EQUAL
98915: PUSH
98916: LD_VAR 0 4
98920: PUSH
98921: LD_VAR 0 7
98925: ARRAY
98926: PUSH
98927: LD_VAR 0 32
98931: IN
98932: AND
98933: IFFALSE 98957
// to_repair := to_repair diff group [ i ] ;
98935: LD_ADDR_VAR 0 32
98939: PUSH
98940: LD_VAR 0 32
98944: PUSH
98945: LD_VAR 0 4
98949: PUSH
98950: LD_VAR 0 7
98954: ARRAY
98955: DIFF
98956: ST_TO_ADDR
// if group [ i ] in to_repair then
98957: LD_VAR 0 4
98961: PUSH
98962: LD_VAR 0 7
98966: ARRAY
98967: PUSH
98968: LD_VAR 0 32
98972: IN
98973: IFFALSE 99020
// begin if not IsInArea ( group [ i ] , f_repair ) then
98975: LD_VAR 0 4
98979: PUSH
98980: LD_VAR 0 7
98984: ARRAY
98985: PPUSH
98986: LD_VAR 0 22
98990: PPUSH
98991: CALL_OW 308
98995: NOT
98996: IFFALSE 99018
// ComMoveToArea ( group [ i ] , f_repair ) ;
98998: LD_VAR 0 4
99002: PUSH
99003: LD_VAR 0 7
99007: ARRAY
99008: PPUSH
99009: LD_VAR 0 22
99013: PPUSH
99014: CALL_OW 113
// continue ;
99018: GO 98645
// end ; end else
99020: GO 99300
// if group [ i ] in repairs then
99022: LD_VAR 0 4
99026: PUSH
99027: LD_VAR 0 7
99031: ARRAY
99032: PUSH
99033: LD_VAR 0 33
99037: IN
99038: IFFALSE 99300
// begin if IsInUnit ( group [ i ] ) then
99040: LD_VAR 0 4
99044: PUSH
99045: LD_VAR 0 7
99049: ARRAY
99050: PPUSH
99051: CALL_OW 310
99055: IFFALSE 99123
// begin z := IsInUnit ( group [ i ] ) ;
99057: LD_ADDR_VAR 0 13
99061: PUSH
99062: LD_VAR 0 4
99066: PUSH
99067: LD_VAR 0 7
99071: ARRAY
99072: PPUSH
99073: CALL_OW 310
99077: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99078: LD_VAR 0 13
99082: PUSH
99083: LD_VAR 0 32
99087: IN
99088: PUSH
99089: LD_VAR 0 13
99093: PPUSH
99094: LD_VAR 0 22
99098: PPUSH
99099: CALL_OW 308
99103: AND
99104: IFFALSE 99121
// ComExitVehicle ( group [ i ] ) ;
99106: LD_VAR 0 4
99110: PUSH
99111: LD_VAR 0 7
99115: ARRAY
99116: PPUSH
99117: CALL_OW 121
// end else
99121: GO 99300
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99123: LD_ADDR_VAR 0 13
99127: PUSH
99128: LD_VAR 0 4
99132: PPUSH
99133: LD_INT 95
99135: PUSH
99136: LD_VAR 0 22
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: PUSH
99145: LD_INT 58
99147: PUSH
99148: EMPTY
99149: LIST
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: PPUSH
99155: CALL_OW 72
99159: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99160: LD_VAR 0 4
99164: PUSH
99165: LD_VAR 0 7
99169: ARRAY
99170: PPUSH
99171: CALL_OW 314
99175: NOT
99176: IFFALSE 99298
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99178: LD_ADDR_VAR 0 10
99182: PUSH
99183: LD_VAR 0 13
99187: PPUSH
99188: LD_VAR 0 4
99192: PUSH
99193: LD_VAR 0 7
99197: ARRAY
99198: PPUSH
99199: CALL_OW 74
99203: ST_TO_ADDR
// if not x then
99204: LD_VAR 0 10
99208: NOT
99209: IFFALSE 99213
// continue ;
99211: GO 98645
// if GetLives ( x ) < 1000 then
99213: LD_VAR 0 10
99217: PPUSH
99218: CALL_OW 256
99222: PUSH
99223: LD_INT 1000
99225: LESS
99226: IFFALSE 99250
// ComRepairVehicle ( group [ i ] , x ) else
99228: LD_VAR 0 4
99232: PUSH
99233: LD_VAR 0 7
99237: ARRAY
99238: PPUSH
99239: LD_VAR 0 10
99243: PPUSH
99244: CALL_OW 129
99248: GO 99298
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99250: LD_VAR 0 23
99254: PUSH
99255: LD_VAR 0 4
99259: PUSH
99260: LD_VAR 0 7
99264: ARRAY
99265: PPUSH
99266: CALL_OW 256
99270: PUSH
99271: LD_INT 1000
99273: LESS
99274: AND
99275: NOT
99276: IFFALSE 99298
// ComEnterUnit ( group [ i ] , x ) ;
99278: LD_VAR 0 4
99282: PUSH
99283: LD_VAR 0 7
99287: ARRAY
99288: PPUSH
99289: LD_VAR 0 10
99293: PPUSH
99294: CALL_OW 120
// end ; continue ;
99298: GO 98645
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99300: LD_VAR 0 23
99304: PUSH
99305: LD_VAR 0 4
99309: PUSH
99310: LD_VAR 0 7
99314: ARRAY
99315: PPUSH
99316: CALL_OW 247
99320: PUSH
99321: LD_INT 1
99323: EQUAL
99324: AND
99325: IFFALSE 99803
// begin if group [ i ] in healers then
99327: LD_VAR 0 4
99331: PUSH
99332: LD_VAR 0 7
99336: ARRAY
99337: PUSH
99338: LD_VAR 0 31
99342: IN
99343: IFFALSE 99616
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99345: LD_VAR 0 4
99349: PUSH
99350: LD_VAR 0 7
99354: ARRAY
99355: PPUSH
99356: LD_VAR 0 23
99360: PPUSH
99361: CALL_OW 308
99365: NOT
99366: PUSH
99367: LD_VAR 0 4
99371: PUSH
99372: LD_VAR 0 7
99376: ARRAY
99377: PPUSH
99378: CALL_OW 314
99382: NOT
99383: AND
99384: IFFALSE 99408
// ComMoveToArea ( group [ i ] , f_heal ) else
99386: LD_VAR 0 4
99390: PUSH
99391: LD_VAR 0 7
99395: ARRAY
99396: PPUSH
99397: LD_VAR 0 23
99401: PPUSH
99402: CALL_OW 113
99406: GO 99614
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99408: LD_VAR 0 4
99412: PUSH
99413: LD_VAR 0 7
99417: ARRAY
99418: PPUSH
99419: CALL 98026 0 1
99423: PPUSH
99424: CALL_OW 256
99428: PUSH
99429: LD_INT 1000
99431: EQUAL
99432: IFFALSE 99451
// ComStop ( group [ i ] ) else
99434: LD_VAR 0 4
99438: PUSH
99439: LD_VAR 0 7
99443: ARRAY
99444: PPUSH
99445: CALL_OW 141
99449: GO 99614
// if not HasTask ( group [ i ] ) and to_heal then
99451: LD_VAR 0 4
99455: PUSH
99456: LD_VAR 0 7
99460: ARRAY
99461: PPUSH
99462: CALL_OW 314
99466: NOT
99467: PUSH
99468: LD_VAR 0 30
99472: AND
99473: IFFALSE 99614
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99475: LD_ADDR_VAR 0 13
99479: PUSH
99480: LD_VAR 0 30
99484: PPUSH
99485: LD_INT 3
99487: PUSH
99488: LD_INT 54
99490: PUSH
99491: EMPTY
99492: LIST
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PPUSH
99498: CALL_OW 72
99502: PPUSH
99503: LD_VAR 0 4
99507: PUSH
99508: LD_VAR 0 7
99512: ARRAY
99513: PPUSH
99514: CALL_OW 74
99518: ST_TO_ADDR
// if z then
99519: LD_VAR 0 13
99523: IFFALSE 99614
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99525: LD_INT 91
99527: PUSH
99528: LD_VAR 0 13
99532: PUSH
99533: LD_INT 10
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: LIST
99540: PUSH
99541: LD_INT 81
99543: PUSH
99544: LD_VAR 0 13
99548: PPUSH
99549: CALL_OW 255
99553: PUSH
99554: EMPTY
99555: LIST
99556: LIST
99557: PUSH
99558: EMPTY
99559: LIST
99560: LIST
99561: PPUSH
99562: CALL_OW 69
99566: PUSH
99567: LD_INT 0
99569: EQUAL
99570: IFFALSE 99594
// ComHeal ( group [ i ] , z ) else
99572: LD_VAR 0 4
99576: PUSH
99577: LD_VAR 0 7
99581: ARRAY
99582: PPUSH
99583: LD_VAR 0 13
99587: PPUSH
99588: CALL_OW 128
99592: GO 99614
// ComMoveToArea ( group [ i ] , f_heal ) ;
99594: LD_VAR 0 4
99598: PUSH
99599: LD_VAR 0 7
99603: ARRAY
99604: PPUSH
99605: LD_VAR 0 23
99609: PPUSH
99610: CALL_OW 113
// end ; continue ;
99614: GO 98645
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99616: LD_VAR 0 4
99620: PUSH
99621: LD_VAR 0 7
99625: ARRAY
99626: PPUSH
99627: CALL_OW 256
99631: PUSH
99632: LD_INT 700
99634: LESS
99635: PUSH
99636: LD_VAR 0 4
99640: PUSH
99641: LD_VAR 0 7
99645: ARRAY
99646: PUSH
99647: LD_VAR 0 30
99651: IN
99652: NOT
99653: AND
99654: IFFALSE 99678
// to_heal := to_heal union group [ i ] ;
99656: LD_ADDR_VAR 0 30
99660: PUSH
99661: LD_VAR 0 30
99665: PUSH
99666: LD_VAR 0 4
99670: PUSH
99671: LD_VAR 0 7
99675: ARRAY
99676: UNION
99677: ST_TO_ADDR
// if group [ i ] in to_heal then
99678: LD_VAR 0 4
99682: PUSH
99683: LD_VAR 0 7
99687: ARRAY
99688: PUSH
99689: LD_VAR 0 30
99693: IN
99694: IFFALSE 99803
// begin if GetLives ( group [ i ] ) = 1000 then
99696: LD_VAR 0 4
99700: PUSH
99701: LD_VAR 0 7
99705: ARRAY
99706: PPUSH
99707: CALL_OW 256
99711: PUSH
99712: LD_INT 1000
99714: EQUAL
99715: IFFALSE 99741
// to_heal := to_heal diff group [ i ] else
99717: LD_ADDR_VAR 0 30
99721: PUSH
99722: LD_VAR 0 30
99726: PUSH
99727: LD_VAR 0 4
99731: PUSH
99732: LD_VAR 0 7
99736: ARRAY
99737: DIFF
99738: ST_TO_ADDR
99739: GO 99803
// begin if not IsInArea ( group [ i ] , to_heal ) then
99741: LD_VAR 0 4
99745: PUSH
99746: LD_VAR 0 7
99750: ARRAY
99751: PPUSH
99752: LD_VAR 0 30
99756: PPUSH
99757: CALL_OW 308
99761: NOT
99762: IFFALSE 99786
// ComMoveToArea ( group [ i ] , f_heal ) else
99764: LD_VAR 0 4
99768: PUSH
99769: LD_VAR 0 7
99773: ARRAY
99774: PPUSH
99775: LD_VAR 0 23
99779: PPUSH
99780: CALL_OW 113
99784: GO 99801
// ComHold ( group [ i ] ) ;
99786: LD_VAR 0 4
99790: PUSH
99791: LD_VAR 0 7
99795: ARRAY
99796: PPUSH
99797: CALL_OW 140
// continue ;
99801: GO 98645
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99803: LD_VAR 0 4
99807: PUSH
99808: LD_VAR 0 7
99812: ARRAY
99813: PPUSH
99814: LD_INT 10
99816: PPUSH
99817: CALL 96423 0 2
99821: NOT
99822: PUSH
99823: LD_VAR 0 16
99827: PUSH
99828: LD_VAR 0 7
99832: ARRAY
99833: PUSH
99834: EMPTY
99835: EQUAL
99836: NOT
99837: AND
99838: IFFALSE 100104
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99840: LD_VAR 0 4
99844: PUSH
99845: LD_VAR 0 7
99849: ARRAY
99850: PPUSH
99851: CALL_OW 262
99855: PUSH
99856: LD_INT 1
99858: PUSH
99859: LD_INT 2
99861: PUSH
99862: EMPTY
99863: LIST
99864: LIST
99865: IN
99866: IFFALSE 99907
// if GetFuel ( group [ i ] ) < 10 then
99868: LD_VAR 0 4
99872: PUSH
99873: LD_VAR 0 7
99877: ARRAY
99878: PPUSH
99879: CALL_OW 261
99883: PUSH
99884: LD_INT 10
99886: LESS
99887: IFFALSE 99907
// SetFuel ( group [ i ] , 12 ) ;
99889: LD_VAR 0 4
99893: PUSH
99894: LD_VAR 0 7
99898: ARRAY
99899: PPUSH
99900: LD_INT 12
99902: PPUSH
99903: CALL_OW 240
// if units_path [ i ] then
99907: LD_VAR 0 16
99911: PUSH
99912: LD_VAR 0 7
99916: ARRAY
99917: IFFALSE 100102
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99919: LD_VAR 0 4
99923: PUSH
99924: LD_VAR 0 7
99928: ARRAY
99929: PPUSH
99930: LD_VAR 0 16
99934: PUSH
99935: LD_VAR 0 7
99939: ARRAY
99940: PUSH
99941: LD_INT 1
99943: ARRAY
99944: PUSH
99945: LD_INT 1
99947: ARRAY
99948: PPUSH
99949: LD_VAR 0 16
99953: PUSH
99954: LD_VAR 0 7
99958: ARRAY
99959: PUSH
99960: LD_INT 1
99962: ARRAY
99963: PUSH
99964: LD_INT 2
99966: ARRAY
99967: PPUSH
99968: CALL_OW 297
99972: PUSH
99973: LD_INT 6
99975: GREATER
99976: IFFALSE 100051
// begin if not HasTask ( group [ i ] ) then
99978: LD_VAR 0 4
99982: PUSH
99983: LD_VAR 0 7
99987: ARRAY
99988: PPUSH
99989: CALL_OW 314
99993: NOT
99994: IFFALSE 100049
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
99996: LD_VAR 0 4
100000: PUSH
100001: LD_VAR 0 7
100005: ARRAY
100006: PPUSH
100007: LD_VAR 0 16
100011: PUSH
100012: LD_VAR 0 7
100016: ARRAY
100017: PUSH
100018: LD_INT 1
100020: ARRAY
100021: PUSH
100022: LD_INT 1
100024: ARRAY
100025: PPUSH
100026: LD_VAR 0 16
100030: PUSH
100031: LD_VAR 0 7
100035: ARRAY
100036: PUSH
100037: LD_INT 1
100039: ARRAY
100040: PUSH
100041: LD_INT 2
100043: ARRAY
100044: PPUSH
100045: CALL_OW 114
// end else
100049: GO 100102
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100051: LD_ADDR_VAR 0 15
100055: PUSH
100056: LD_VAR 0 16
100060: PUSH
100061: LD_VAR 0 7
100065: ARRAY
100066: PPUSH
100067: LD_INT 1
100069: PPUSH
100070: CALL_OW 3
100074: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100075: LD_ADDR_VAR 0 16
100079: PUSH
100080: LD_VAR 0 16
100084: PPUSH
100085: LD_VAR 0 7
100089: PPUSH
100090: LD_VAR 0 15
100094: PPUSH
100095: CALL_OW 1
100099: ST_TO_ADDR
// continue ;
100100: GO 98645
// end ; end ; end else
100102: GO 102740
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100104: LD_ADDR_VAR 0 14
100108: PUSH
100109: LD_INT 81
100111: PUSH
100112: LD_VAR 0 4
100116: PUSH
100117: LD_VAR 0 7
100121: ARRAY
100122: PPUSH
100123: CALL_OW 255
100127: PUSH
100128: EMPTY
100129: LIST
100130: LIST
100131: PPUSH
100132: CALL_OW 69
100136: ST_TO_ADDR
// if not tmp then
100137: LD_VAR 0 14
100141: NOT
100142: IFFALSE 100146
// continue ;
100144: GO 98645
// if f_ignore_area then
100146: LD_VAR 0 17
100150: IFFALSE 100238
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100152: LD_ADDR_VAR 0 15
100156: PUSH
100157: LD_VAR 0 14
100161: PPUSH
100162: LD_INT 3
100164: PUSH
100165: LD_INT 92
100167: PUSH
100168: LD_VAR 0 17
100172: PUSH
100173: LD_INT 1
100175: ARRAY
100176: PUSH
100177: LD_VAR 0 17
100181: PUSH
100182: LD_INT 2
100184: ARRAY
100185: PUSH
100186: LD_VAR 0 17
100190: PUSH
100191: LD_INT 3
100193: ARRAY
100194: PUSH
100195: EMPTY
100196: LIST
100197: LIST
100198: LIST
100199: LIST
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: PPUSH
100205: CALL_OW 72
100209: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100210: LD_VAR 0 14
100214: PUSH
100215: LD_VAR 0 15
100219: DIFF
100220: IFFALSE 100238
// tmp := tmp diff tmp2 ;
100222: LD_ADDR_VAR 0 14
100226: PUSH
100227: LD_VAR 0 14
100231: PUSH
100232: LD_VAR 0 15
100236: DIFF
100237: ST_TO_ADDR
// end ; if not f_murder then
100238: LD_VAR 0 20
100242: NOT
100243: IFFALSE 100301
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100245: LD_ADDR_VAR 0 15
100249: PUSH
100250: LD_VAR 0 14
100254: PPUSH
100255: LD_INT 3
100257: PUSH
100258: LD_INT 50
100260: PUSH
100261: EMPTY
100262: LIST
100263: PUSH
100264: EMPTY
100265: LIST
100266: LIST
100267: PPUSH
100268: CALL_OW 72
100272: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100273: LD_VAR 0 14
100277: PUSH
100278: LD_VAR 0 15
100282: DIFF
100283: IFFALSE 100301
// tmp := tmp diff tmp2 ;
100285: LD_ADDR_VAR 0 14
100289: PUSH
100290: LD_VAR 0 14
100294: PUSH
100295: LD_VAR 0 15
100299: DIFF
100300: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100301: LD_ADDR_VAR 0 14
100305: PUSH
100306: LD_VAR 0 4
100310: PUSH
100311: LD_VAR 0 7
100315: ARRAY
100316: PPUSH
100317: LD_VAR 0 14
100321: PPUSH
100322: LD_INT 1
100324: PPUSH
100325: LD_INT 1
100327: PPUSH
100328: CALL 70090 0 4
100332: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100333: LD_VAR 0 4
100337: PUSH
100338: LD_VAR 0 7
100342: ARRAY
100343: PPUSH
100344: CALL_OW 257
100348: PUSH
100349: LD_INT 1
100351: EQUAL
100352: IFFALSE 100800
// begin if WantPlant ( group [ i ] ) then
100354: LD_VAR 0 4
100358: PUSH
100359: LD_VAR 0 7
100363: ARRAY
100364: PPUSH
100365: CALL 69591 0 1
100369: IFFALSE 100373
// continue ;
100371: GO 98645
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100373: LD_VAR 0 18
100377: PUSH
100378: LD_VAR 0 4
100382: PUSH
100383: LD_VAR 0 7
100387: ARRAY
100388: PPUSH
100389: CALL_OW 310
100393: NOT
100394: AND
100395: PUSH
100396: LD_VAR 0 14
100400: PUSH
100401: LD_INT 1
100403: ARRAY
100404: PUSH
100405: LD_VAR 0 14
100409: PPUSH
100410: LD_INT 21
100412: PUSH
100413: LD_INT 2
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: PUSH
100420: LD_INT 58
100422: PUSH
100423: EMPTY
100424: LIST
100425: PUSH
100426: EMPTY
100427: LIST
100428: LIST
100429: PPUSH
100430: CALL_OW 72
100434: IN
100435: AND
100436: IFFALSE 100472
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100438: LD_VAR 0 4
100442: PUSH
100443: LD_VAR 0 7
100447: ARRAY
100448: PPUSH
100449: LD_VAR 0 14
100453: PUSH
100454: LD_INT 1
100456: ARRAY
100457: PPUSH
100458: CALL_OW 120
// attacking := true ;
100462: LD_ADDR_VAR 0 29
100466: PUSH
100467: LD_INT 1
100469: ST_TO_ADDR
// continue ;
100470: GO 98645
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100472: LD_VAR 0 26
100476: PUSH
100477: LD_VAR 0 4
100481: PUSH
100482: LD_VAR 0 7
100486: ARRAY
100487: PPUSH
100488: CALL_OW 257
100492: PUSH
100493: LD_INT 1
100495: EQUAL
100496: AND
100497: PUSH
100498: LD_VAR 0 4
100502: PUSH
100503: LD_VAR 0 7
100507: ARRAY
100508: PPUSH
100509: CALL_OW 256
100513: PUSH
100514: LD_INT 800
100516: LESS
100517: AND
100518: PUSH
100519: LD_VAR 0 4
100523: PUSH
100524: LD_VAR 0 7
100528: ARRAY
100529: PPUSH
100530: CALL_OW 318
100534: NOT
100535: AND
100536: IFFALSE 100553
// ComCrawl ( group [ i ] ) ;
100538: LD_VAR 0 4
100542: PUSH
100543: LD_VAR 0 7
100547: ARRAY
100548: PPUSH
100549: CALL_OW 137
// if f_mines then
100553: LD_VAR 0 21
100557: IFFALSE 100800
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100559: LD_VAR 0 14
100563: PUSH
100564: LD_INT 1
100566: ARRAY
100567: PPUSH
100568: CALL_OW 247
100572: PUSH
100573: LD_INT 3
100575: EQUAL
100576: PUSH
100577: LD_VAR 0 14
100581: PUSH
100582: LD_INT 1
100584: ARRAY
100585: PUSH
100586: LD_VAR 0 27
100590: IN
100591: NOT
100592: AND
100593: IFFALSE 100800
// begin x := GetX ( tmp [ 1 ] ) ;
100595: LD_ADDR_VAR 0 10
100599: PUSH
100600: LD_VAR 0 14
100604: PUSH
100605: LD_INT 1
100607: ARRAY
100608: PPUSH
100609: CALL_OW 250
100613: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100614: LD_ADDR_VAR 0 11
100618: PUSH
100619: LD_VAR 0 14
100623: PUSH
100624: LD_INT 1
100626: ARRAY
100627: PPUSH
100628: CALL_OW 251
100632: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100633: LD_ADDR_VAR 0 12
100637: PUSH
100638: LD_VAR 0 4
100642: PUSH
100643: LD_VAR 0 7
100647: ARRAY
100648: PPUSH
100649: CALL 96508 0 1
100653: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100654: LD_VAR 0 4
100658: PUSH
100659: LD_VAR 0 7
100663: ARRAY
100664: PPUSH
100665: LD_VAR 0 10
100669: PPUSH
100670: LD_VAR 0 11
100674: PPUSH
100675: LD_VAR 0 14
100679: PUSH
100680: LD_INT 1
100682: ARRAY
100683: PPUSH
100684: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100688: LD_VAR 0 4
100692: PUSH
100693: LD_VAR 0 7
100697: ARRAY
100698: PPUSH
100699: LD_VAR 0 10
100703: PPUSH
100704: LD_VAR 0 12
100708: PPUSH
100709: LD_INT 7
100711: PPUSH
100712: CALL_OW 272
100716: PPUSH
100717: LD_VAR 0 11
100721: PPUSH
100722: LD_VAR 0 12
100726: PPUSH
100727: LD_INT 7
100729: PPUSH
100730: CALL_OW 273
100734: PPUSH
100735: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100739: LD_VAR 0 4
100743: PUSH
100744: LD_VAR 0 7
100748: ARRAY
100749: PPUSH
100750: LD_INT 71
100752: PPUSH
100753: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100757: LD_ADDR_VAR 0 27
100761: PUSH
100762: LD_VAR 0 27
100766: PPUSH
100767: LD_VAR 0 27
100771: PUSH
100772: LD_INT 1
100774: PLUS
100775: PPUSH
100776: LD_VAR 0 14
100780: PUSH
100781: LD_INT 1
100783: ARRAY
100784: PPUSH
100785: CALL_OW 1
100789: ST_TO_ADDR
// attacking := true ;
100790: LD_ADDR_VAR 0 29
100794: PUSH
100795: LD_INT 1
100797: ST_TO_ADDR
// continue ;
100798: GO 98645
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100800: LD_VAR 0 4
100804: PUSH
100805: LD_VAR 0 7
100809: ARRAY
100810: PPUSH
100811: CALL_OW 257
100815: PUSH
100816: LD_INT 17
100818: EQUAL
100819: PUSH
100820: LD_VAR 0 4
100824: PUSH
100825: LD_VAR 0 7
100829: ARRAY
100830: PPUSH
100831: CALL_OW 110
100835: PUSH
100836: LD_INT 71
100838: EQUAL
100839: NOT
100840: AND
100841: IFFALSE 100987
// begin attacking := false ;
100843: LD_ADDR_VAR 0 29
100847: PUSH
100848: LD_INT 0
100850: ST_TO_ADDR
// k := 5 ;
100851: LD_ADDR_VAR 0 9
100855: PUSH
100856: LD_INT 5
100858: ST_TO_ADDR
// if tmp < k then
100859: LD_VAR 0 14
100863: PUSH
100864: LD_VAR 0 9
100868: LESS
100869: IFFALSE 100881
// k := tmp ;
100871: LD_ADDR_VAR 0 9
100875: PUSH
100876: LD_VAR 0 14
100880: ST_TO_ADDR
// for j = 1 to k do
100881: LD_ADDR_VAR 0 8
100885: PUSH
100886: DOUBLE
100887: LD_INT 1
100889: DEC
100890: ST_TO_ADDR
100891: LD_VAR 0 9
100895: PUSH
100896: FOR_TO
100897: IFFALSE 100985
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100899: LD_VAR 0 14
100903: PUSH
100904: LD_VAR 0 8
100908: ARRAY
100909: PUSH
100910: LD_VAR 0 14
100914: PPUSH
100915: LD_INT 58
100917: PUSH
100918: EMPTY
100919: LIST
100920: PPUSH
100921: CALL_OW 72
100925: IN
100926: NOT
100927: IFFALSE 100983
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100929: LD_VAR 0 4
100933: PUSH
100934: LD_VAR 0 7
100938: ARRAY
100939: PPUSH
100940: LD_VAR 0 14
100944: PUSH
100945: LD_VAR 0 8
100949: ARRAY
100950: PPUSH
100951: CALL_OW 115
// attacking := true ;
100955: LD_ADDR_VAR 0 29
100959: PUSH
100960: LD_INT 1
100962: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
100963: LD_VAR 0 4
100967: PUSH
100968: LD_VAR 0 7
100972: ARRAY
100973: PPUSH
100974: LD_INT 71
100976: PPUSH
100977: CALL_OW 109
// continue ;
100981: GO 100896
// end ; end ;
100983: GO 100896
100985: POP
100986: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
100987: LD_VAR 0 4
100991: PUSH
100992: LD_VAR 0 7
100996: ARRAY
100997: PPUSH
100998: CALL_OW 257
101002: PUSH
101003: LD_INT 8
101005: EQUAL
101006: PUSH
101007: LD_VAR 0 4
101011: PUSH
101012: LD_VAR 0 7
101016: ARRAY
101017: PPUSH
101018: CALL_OW 264
101022: PUSH
101023: LD_INT 28
101025: PUSH
101026: LD_INT 45
101028: PUSH
101029: LD_INT 7
101031: PUSH
101032: LD_INT 47
101034: PUSH
101035: EMPTY
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: IN
101041: OR
101042: IFFALSE 101272
// begin attacking := false ;
101044: LD_ADDR_VAR 0 29
101048: PUSH
101049: LD_INT 0
101051: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101052: LD_VAR 0 14
101056: PUSH
101057: LD_INT 1
101059: ARRAY
101060: PPUSH
101061: CALL_OW 266
101065: PUSH
101066: LD_INT 32
101068: PUSH
101069: LD_INT 31
101071: PUSH
101072: LD_INT 33
101074: PUSH
101075: LD_INT 4
101077: PUSH
101078: LD_INT 5
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: IN
101088: IFFALSE 101272
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101090: LD_ADDR_VAR 0 9
101094: PUSH
101095: LD_VAR 0 14
101099: PUSH
101100: LD_INT 1
101102: ARRAY
101103: PPUSH
101104: CALL_OW 266
101108: PPUSH
101109: LD_VAR 0 14
101113: PUSH
101114: LD_INT 1
101116: ARRAY
101117: PPUSH
101118: CALL_OW 250
101122: PPUSH
101123: LD_VAR 0 14
101127: PUSH
101128: LD_INT 1
101130: ARRAY
101131: PPUSH
101132: CALL_OW 251
101136: PPUSH
101137: LD_VAR 0 14
101141: PUSH
101142: LD_INT 1
101144: ARRAY
101145: PPUSH
101146: CALL_OW 254
101150: PPUSH
101151: LD_VAR 0 14
101155: PUSH
101156: LD_INT 1
101158: ARRAY
101159: PPUSH
101160: CALL_OW 248
101164: PPUSH
101165: LD_INT 0
101167: PPUSH
101168: CALL 77884 0 6
101172: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101173: LD_ADDR_VAR 0 8
101177: PUSH
101178: LD_VAR 0 4
101182: PUSH
101183: LD_VAR 0 7
101187: ARRAY
101188: PPUSH
101189: LD_VAR 0 9
101193: PPUSH
101194: CALL 96571 0 2
101198: ST_TO_ADDR
// if j then
101199: LD_VAR 0 8
101203: IFFALSE 101272
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101205: LD_VAR 0 8
101209: PUSH
101210: LD_INT 1
101212: ARRAY
101213: PPUSH
101214: LD_VAR 0 8
101218: PUSH
101219: LD_INT 2
101221: ARRAY
101222: PPUSH
101223: CALL_OW 488
101227: IFFALSE 101272
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101229: LD_VAR 0 4
101233: PUSH
101234: LD_VAR 0 7
101238: ARRAY
101239: PPUSH
101240: LD_VAR 0 8
101244: PUSH
101245: LD_INT 1
101247: ARRAY
101248: PPUSH
101249: LD_VAR 0 8
101253: PUSH
101254: LD_INT 2
101256: ARRAY
101257: PPUSH
101258: CALL_OW 116
// attacking := true ;
101262: LD_ADDR_VAR 0 29
101266: PUSH
101267: LD_INT 1
101269: ST_TO_ADDR
// continue ;
101270: GO 98645
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101272: LD_VAR 0 4
101276: PUSH
101277: LD_VAR 0 7
101281: ARRAY
101282: PPUSH
101283: CALL_OW 265
101287: PUSH
101288: LD_INT 11
101290: EQUAL
101291: IFFALSE 101569
// begin k := 10 ;
101293: LD_ADDR_VAR 0 9
101297: PUSH
101298: LD_INT 10
101300: ST_TO_ADDR
// x := 0 ;
101301: LD_ADDR_VAR 0 10
101305: PUSH
101306: LD_INT 0
101308: ST_TO_ADDR
// if tmp < k then
101309: LD_VAR 0 14
101313: PUSH
101314: LD_VAR 0 9
101318: LESS
101319: IFFALSE 101331
// k := tmp ;
101321: LD_ADDR_VAR 0 9
101325: PUSH
101326: LD_VAR 0 14
101330: ST_TO_ADDR
// for j = k downto 1 do
101331: LD_ADDR_VAR 0 8
101335: PUSH
101336: DOUBLE
101337: LD_VAR 0 9
101341: INC
101342: ST_TO_ADDR
101343: LD_INT 1
101345: PUSH
101346: FOR_DOWNTO
101347: IFFALSE 101422
// begin if GetType ( tmp [ j ] ) = unit_human then
101349: LD_VAR 0 14
101353: PUSH
101354: LD_VAR 0 8
101358: ARRAY
101359: PPUSH
101360: CALL_OW 247
101364: PUSH
101365: LD_INT 1
101367: EQUAL
101368: IFFALSE 101420
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101370: LD_VAR 0 4
101374: PUSH
101375: LD_VAR 0 7
101379: ARRAY
101380: PPUSH
101381: LD_VAR 0 14
101385: PUSH
101386: LD_VAR 0 8
101390: ARRAY
101391: PPUSH
101392: CALL 96842 0 2
// x := tmp [ j ] ;
101396: LD_ADDR_VAR 0 10
101400: PUSH
101401: LD_VAR 0 14
101405: PUSH
101406: LD_VAR 0 8
101410: ARRAY
101411: ST_TO_ADDR
// attacking := true ;
101412: LD_ADDR_VAR 0 29
101416: PUSH
101417: LD_INT 1
101419: ST_TO_ADDR
// end ; end ;
101420: GO 101346
101422: POP
101423: POP
// if not x then
101424: LD_VAR 0 10
101428: NOT
101429: IFFALSE 101569
// begin attacking := true ;
101431: LD_ADDR_VAR 0 29
101435: PUSH
101436: LD_INT 1
101438: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101439: LD_VAR 0 4
101443: PUSH
101444: LD_VAR 0 7
101448: ARRAY
101449: PPUSH
101450: CALL_OW 250
101454: PPUSH
101455: LD_VAR 0 4
101459: PUSH
101460: LD_VAR 0 7
101464: ARRAY
101465: PPUSH
101466: CALL_OW 251
101470: PPUSH
101471: CALL_OW 546
101475: PUSH
101476: LD_INT 2
101478: ARRAY
101479: PUSH
101480: LD_VAR 0 14
101484: PUSH
101485: LD_INT 1
101487: ARRAY
101488: PPUSH
101489: CALL_OW 250
101493: PPUSH
101494: LD_VAR 0 14
101498: PUSH
101499: LD_INT 1
101501: ARRAY
101502: PPUSH
101503: CALL_OW 251
101507: PPUSH
101508: CALL_OW 546
101512: PUSH
101513: LD_INT 2
101515: ARRAY
101516: EQUAL
101517: IFFALSE 101545
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101519: LD_VAR 0 4
101523: PUSH
101524: LD_VAR 0 7
101528: ARRAY
101529: PPUSH
101530: LD_VAR 0 14
101534: PUSH
101535: LD_INT 1
101537: ARRAY
101538: PPUSH
101539: CALL 96842 0 2
101543: GO 101569
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101545: LD_VAR 0 4
101549: PUSH
101550: LD_VAR 0 7
101554: ARRAY
101555: PPUSH
101556: LD_VAR 0 14
101560: PUSH
101561: LD_INT 1
101563: ARRAY
101564: PPUSH
101565: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101569: LD_VAR 0 4
101573: PUSH
101574: LD_VAR 0 7
101578: ARRAY
101579: PPUSH
101580: CALL_OW 264
101584: PUSH
101585: LD_INT 29
101587: EQUAL
101588: IFFALSE 101954
// begin if WantsToAttack ( group [ i ] ) in bombed then
101590: LD_VAR 0 4
101594: PUSH
101595: LD_VAR 0 7
101599: ARRAY
101600: PPUSH
101601: CALL_OW 319
101605: PUSH
101606: LD_VAR 0 28
101610: IN
101611: IFFALSE 101615
// continue ;
101613: GO 98645
// k := 8 ;
101615: LD_ADDR_VAR 0 9
101619: PUSH
101620: LD_INT 8
101622: ST_TO_ADDR
// x := 0 ;
101623: LD_ADDR_VAR 0 10
101627: PUSH
101628: LD_INT 0
101630: ST_TO_ADDR
// if tmp < k then
101631: LD_VAR 0 14
101635: PUSH
101636: LD_VAR 0 9
101640: LESS
101641: IFFALSE 101653
// k := tmp ;
101643: LD_ADDR_VAR 0 9
101647: PUSH
101648: LD_VAR 0 14
101652: ST_TO_ADDR
// for j = 1 to k do
101653: LD_ADDR_VAR 0 8
101657: PUSH
101658: DOUBLE
101659: LD_INT 1
101661: DEC
101662: ST_TO_ADDR
101663: LD_VAR 0 9
101667: PUSH
101668: FOR_TO
101669: IFFALSE 101801
// begin if GetType ( tmp [ j ] ) = unit_building then
101671: LD_VAR 0 14
101675: PUSH
101676: LD_VAR 0 8
101680: ARRAY
101681: PPUSH
101682: CALL_OW 247
101686: PUSH
101687: LD_INT 3
101689: EQUAL
101690: IFFALSE 101799
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101692: LD_VAR 0 14
101696: PUSH
101697: LD_VAR 0 8
101701: ARRAY
101702: PUSH
101703: LD_VAR 0 28
101707: IN
101708: NOT
101709: PUSH
101710: LD_VAR 0 14
101714: PUSH
101715: LD_VAR 0 8
101719: ARRAY
101720: PPUSH
101721: CALL_OW 313
101725: AND
101726: IFFALSE 101799
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101728: LD_VAR 0 4
101732: PUSH
101733: LD_VAR 0 7
101737: ARRAY
101738: PPUSH
101739: LD_VAR 0 14
101743: PUSH
101744: LD_VAR 0 8
101748: ARRAY
101749: PPUSH
101750: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101754: LD_ADDR_VAR 0 28
101758: PUSH
101759: LD_VAR 0 28
101763: PPUSH
101764: LD_VAR 0 28
101768: PUSH
101769: LD_INT 1
101771: PLUS
101772: PPUSH
101773: LD_VAR 0 14
101777: PUSH
101778: LD_VAR 0 8
101782: ARRAY
101783: PPUSH
101784: CALL_OW 1
101788: ST_TO_ADDR
// attacking := true ;
101789: LD_ADDR_VAR 0 29
101793: PUSH
101794: LD_INT 1
101796: ST_TO_ADDR
// break ;
101797: GO 101801
// end ; end ;
101799: GO 101668
101801: POP
101802: POP
// if not attacking and f_attack_depot then
101803: LD_VAR 0 29
101807: NOT
101808: PUSH
101809: LD_VAR 0 25
101813: AND
101814: IFFALSE 101909
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101816: LD_ADDR_VAR 0 13
101820: PUSH
101821: LD_VAR 0 14
101825: PPUSH
101826: LD_INT 2
101828: PUSH
101829: LD_INT 30
101831: PUSH
101832: LD_INT 0
101834: PUSH
101835: EMPTY
101836: LIST
101837: LIST
101838: PUSH
101839: LD_INT 30
101841: PUSH
101842: LD_INT 1
101844: PUSH
101845: EMPTY
101846: LIST
101847: LIST
101848: PUSH
101849: EMPTY
101850: LIST
101851: LIST
101852: LIST
101853: PPUSH
101854: CALL_OW 72
101858: ST_TO_ADDR
// if z then
101859: LD_VAR 0 13
101863: IFFALSE 101909
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101865: LD_VAR 0 4
101869: PUSH
101870: LD_VAR 0 7
101874: ARRAY
101875: PPUSH
101876: LD_VAR 0 13
101880: PPUSH
101881: LD_VAR 0 4
101885: PUSH
101886: LD_VAR 0 7
101890: ARRAY
101891: PPUSH
101892: CALL_OW 74
101896: PPUSH
101897: CALL_OW 115
// attacking := true ;
101901: LD_ADDR_VAR 0 29
101905: PUSH
101906: LD_INT 1
101908: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101909: LD_VAR 0 4
101913: PUSH
101914: LD_VAR 0 7
101918: ARRAY
101919: PPUSH
101920: CALL_OW 256
101924: PUSH
101925: LD_INT 500
101927: LESS
101928: IFFALSE 101954
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101930: LD_VAR 0 4
101934: PUSH
101935: LD_VAR 0 7
101939: ARRAY
101940: PPUSH
101941: LD_VAR 0 14
101945: PUSH
101946: LD_INT 1
101948: ARRAY
101949: PPUSH
101950: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
101954: LD_VAR 0 4
101958: PUSH
101959: LD_VAR 0 7
101963: ARRAY
101964: PPUSH
101965: CALL_OW 264
101969: PUSH
101970: LD_INT 49
101972: EQUAL
101973: IFFALSE 102094
// begin if not HasTask ( group [ i ] ) then
101975: LD_VAR 0 4
101979: PUSH
101980: LD_VAR 0 7
101984: ARRAY
101985: PPUSH
101986: CALL_OW 314
101990: NOT
101991: IFFALSE 102094
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
101993: LD_ADDR_VAR 0 9
101997: PUSH
101998: LD_INT 81
102000: PUSH
102001: LD_VAR 0 4
102005: PUSH
102006: LD_VAR 0 7
102010: ARRAY
102011: PPUSH
102012: CALL_OW 255
102016: PUSH
102017: EMPTY
102018: LIST
102019: LIST
102020: PPUSH
102021: CALL_OW 69
102025: PPUSH
102026: LD_VAR 0 4
102030: PUSH
102031: LD_VAR 0 7
102035: ARRAY
102036: PPUSH
102037: CALL_OW 74
102041: ST_TO_ADDR
// if k then
102042: LD_VAR 0 9
102046: IFFALSE 102094
// if GetDistUnits ( group [ i ] , k ) > 10 then
102048: LD_VAR 0 4
102052: PUSH
102053: LD_VAR 0 7
102057: ARRAY
102058: PPUSH
102059: LD_VAR 0 9
102063: PPUSH
102064: CALL_OW 296
102068: PUSH
102069: LD_INT 10
102071: GREATER
102072: IFFALSE 102094
// ComMoveUnit ( group [ i ] , k ) ;
102074: LD_VAR 0 4
102078: PUSH
102079: LD_VAR 0 7
102083: ARRAY
102084: PPUSH
102085: LD_VAR 0 9
102089: PPUSH
102090: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102094: LD_VAR 0 4
102098: PUSH
102099: LD_VAR 0 7
102103: ARRAY
102104: PPUSH
102105: CALL_OW 256
102109: PUSH
102110: LD_INT 250
102112: LESS
102113: PUSH
102114: LD_VAR 0 4
102118: PUSH
102119: LD_VAR 0 7
102123: ARRAY
102124: PUSH
102125: LD_INT 21
102127: PUSH
102128: LD_INT 2
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PUSH
102135: LD_INT 23
102137: PUSH
102138: LD_INT 2
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: PPUSH
102149: CALL_OW 69
102153: IN
102154: AND
102155: IFFALSE 102280
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102157: LD_ADDR_VAR 0 9
102161: PUSH
102162: LD_OWVAR 3
102166: PUSH
102167: LD_VAR 0 4
102171: PUSH
102172: LD_VAR 0 7
102176: ARRAY
102177: DIFF
102178: PPUSH
102179: LD_VAR 0 4
102183: PUSH
102184: LD_VAR 0 7
102188: ARRAY
102189: PPUSH
102190: CALL_OW 74
102194: ST_TO_ADDR
// if not k then
102195: LD_VAR 0 9
102199: NOT
102200: IFFALSE 102204
// continue ;
102202: GO 98645
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102204: LD_VAR 0 9
102208: PUSH
102209: LD_INT 81
102211: PUSH
102212: LD_VAR 0 4
102216: PUSH
102217: LD_VAR 0 7
102221: ARRAY
102222: PPUSH
102223: CALL_OW 255
102227: PUSH
102228: EMPTY
102229: LIST
102230: LIST
102231: PPUSH
102232: CALL_OW 69
102236: IN
102237: PUSH
102238: LD_VAR 0 9
102242: PPUSH
102243: LD_VAR 0 4
102247: PUSH
102248: LD_VAR 0 7
102252: ARRAY
102253: PPUSH
102254: CALL_OW 296
102258: PUSH
102259: LD_INT 5
102261: LESS
102262: AND
102263: IFFALSE 102280
// ComAutodestruct ( group [ i ] ) ;
102265: LD_VAR 0 4
102269: PUSH
102270: LD_VAR 0 7
102274: ARRAY
102275: PPUSH
102276: CALL 96740 0 1
// end ; if f_attack_depot then
102280: LD_VAR 0 25
102284: IFFALSE 102396
// begin k := 6 ;
102286: LD_ADDR_VAR 0 9
102290: PUSH
102291: LD_INT 6
102293: ST_TO_ADDR
// if tmp < k then
102294: LD_VAR 0 14
102298: PUSH
102299: LD_VAR 0 9
102303: LESS
102304: IFFALSE 102316
// k := tmp ;
102306: LD_ADDR_VAR 0 9
102310: PUSH
102311: LD_VAR 0 14
102315: ST_TO_ADDR
// for j = 1 to k do
102316: LD_ADDR_VAR 0 8
102320: PUSH
102321: DOUBLE
102322: LD_INT 1
102324: DEC
102325: ST_TO_ADDR
102326: LD_VAR 0 9
102330: PUSH
102331: FOR_TO
102332: IFFALSE 102394
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102334: LD_VAR 0 8
102338: PPUSH
102339: CALL_OW 266
102343: PUSH
102344: LD_INT 0
102346: PUSH
102347: LD_INT 1
102349: PUSH
102350: EMPTY
102351: LIST
102352: LIST
102353: IN
102354: IFFALSE 102392
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102356: LD_VAR 0 4
102360: PUSH
102361: LD_VAR 0 7
102365: ARRAY
102366: PPUSH
102367: LD_VAR 0 14
102371: PUSH
102372: LD_VAR 0 8
102376: ARRAY
102377: PPUSH
102378: CALL_OW 115
// attacking := true ;
102382: LD_ADDR_VAR 0 29
102386: PUSH
102387: LD_INT 1
102389: ST_TO_ADDR
// break ;
102390: GO 102394
// end ;
102392: GO 102331
102394: POP
102395: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102396: LD_VAR 0 4
102400: PUSH
102401: LD_VAR 0 7
102405: ARRAY
102406: PPUSH
102407: CALL_OW 302
102411: PUSH
102412: LD_VAR 0 29
102416: NOT
102417: AND
102418: IFFALSE 102740
// begin if GetTag ( group [ i ] ) = 71 then
102420: LD_VAR 0 4
102424: PUSH
102425: LD_VAR 0 7
102429: ARRAY
102430: PPUSH
102431: CALL_OW 110
102435: PUSH
102436: LD_INT 71
102438: EQUAL
102439: IFFALSE 102480
// begin if HasTask ( group [ i ] ) then
102441: LD_VAR 0 4
102445: PUSH
102446: LD_VAR 0 7
102450: ARRAY
102451: PPUSH
102452: CALL_OW 314
102456: IFFALSE 102462
// continue else
102458: GO 98645
102460: GO 102480
// SetTag ( group [ i ] , 0 ) ;
102462: LD_VAR 0 4
102466: PUSH
102467: LD_VAR 0 7
102471: ARRAY
102472: PPUSH
102473: LD_INT 0
102475: PPUSH
102476: CALL_OW 109
// end ; k := 8 ;
102480: LD_ADDR_VAR 0 9
102484: PUSH
102485: LD_INT 8
102487: ST_TO_ADDR
// x := 0 ;
102488: LD_ADDR_VAR 0 10
102492: PUSH
102493: LD_INT 0
102495: ST_TO_ADDR
// if tmp < k then
102496: LD_VAR 0 14
102500: PUSH
102501: LD_VAR 0 9
102505: LESS
102506: IFFALSE 102518
// k := tmp ;
102508: LD_ADDR_VAR 0 9
102512: PUSH
102513: LD_VAR 0 14
102517: ST_TO_ADDR
// for j = 1 to k do
102518: LD_ADDR_VAR 0 8
102522: PUSH
102523: DOUBLE
102524: LD_INT 1
102526: DEC
102527: ST_TO_ADDR
102528: LD_VAR 0 9
102532: PUSH
102533: FOR_TO
102534: IFFALSE 102632
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102536: LD_VAR 0 14
102540: PUSH
102541: LD_VAR 0 8
102545: ARRAY
102546: PPUSH
102547: CALL_OW 247
102551: PUSH
102552: LD_INT 1
102554: EQUAL
102555: PUSH
102556: LD_VAR 0 14
102560: PUSH
102561: LD_VAR 0 8
102565: ARRAY
102566: PPUSH
102567: CALL_OW 256
102571: PUSH
102572: LD_INT 250
102574: LESS
102575: PUSH
102576: LD_VAR 0 20
102580: AND
102581: PUSH
102582: LD_VAR 0 20
102586: NOT
102587: PUSH
102588: LD_VAR 0 14
102592: PUSH
102593: LD_VAR 0 8
102597: ARRAY
102598: PPUSH
102599: CALL_OW 256
102603: PUSH
102604: LD_INT 250
102606: GREATEREQUAL
102607: AND
102608: OR
102609: AND
102610: IFFALSE 102630
// begin x := tmp [ j ] ;
102612: LD_ADDR_VAR 0 10
102616: PUSH
102617: LD_VAR 0 14
102621: PUSH
102622: LD_VAR 0 8
102626: ARRAY
102627: ST_TO_ADDR
// break ;
102628: GO 102632
// end ;
102630: GO 102533
102632: POP
102633: POP
// if x then
102634: LD_VAR 0 10
102638: IFFALSE 102662
// ComAttackUnit ( group [ i ] , x ) else
102640: LD_VAR 0 4
102644: PUSH
102645: LD_VAR 0 7
102649: ARRAY
102650: PPUSH
102651: LD_VAR 0 10
102655: PPUSH
102656: CALL_OW 115
102660: GO 102686
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102662: LD_VAR 0 4
102666: PUSH
102667: LD_VAR 0 7
102671: ARRAY
102672: PPUSH
102673: LD_VAR 0 14
102677: PUSH
102678: LD_INT 1
102680: ARRAY
102681: PPUSH
102682: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102686: LD_VAR 0 4
102690: PUSH
102691: LD_VAR 0 7
102695: ARRAY
102696: PPUSH
102697: CALL_OW 314
102701: NOT
102702: IFFALSE 102740
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102704: LD_VAR 0 4
102708: PUSH
102709: LD_VAR 0 7
102713: ARRAY
102714: PPUSH
102715: LD_VAR 0 14
102719: PPUSH
102720: LD_VAR 0 4
102724: PUSH
102725: LD_VAR 0 7
102729: ARRAY
102730: PPUSH
102731: CALL_OW 74
102735: PPUSH
102736: CALL_OW 115
// end ; end ; end ;
102740: GO 98645
102742: POP
102743: POP
// wait ( 0 0$1 ) ;
102744: LD_INT 35
102746: PPUSH
102747: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102751: LD_VAR 0 4
102755: PUSH
102756: EMPTY
102757: EQUAL
102758: PUSH
102759: LD_INT 81
102761: PUSH
102762: LD_VAR 0 35
102766: PUSH
102767: EMPTY
102768: LIST
102769: LIST
102770: PPUSH
102771: CALL_OW 69
102775: NOT
102776: OR
102777: IFFALSE 98630
// end ;
102779: LD_VAR 0 2
102783: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102784: LD_INT 0
102786: PPUSH
102787: PPUSH
102788: PPUSH
102789: PPUSH
// if not base_units then
102790: LD_VAR 0 1
102794: NOT
102795: IFFALSE 102799
// exit ;
102797: GO 102886
// result := false ;
102799: LD_ADDR_VAR 0 2
102803: PUSH
102804: LD_INT 0
102806: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102807: LD_ADDR_VAR 0 5
102811: PUSH
102812: LD_VAR 0 1
102816: PPUSH
102817: LD_INT 21
102819: PUSH
102820: LD_INT 3
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: PPUSH
102827: CALL_OW 72
102831: ST_TO_ADDR
// if not tmp then
102832: LD_VAR 0 5
102836: NOT
102837: IFFALSE 102841
// exit ;
102839: GO 102886
// for i in tmp do
102841: LD_ADDR_VAR 0 3
102845: PUSH
102846: LD_VAR 0 5
102850: PUSH
102851: FOR_IN
102852: IFFALSE 102884
// begin result := EnemyInRange ( i , 22 ) ;
102854: LD_ADDR_VAR 0 2
102858: PUSH
102859: LD_VAR 0 3
102863: PPUSH
102864: LD_INT 22
102866: PPUSH
102867: CALL 96423 0 2
102871: ST_TO_ADDR
// if result then
102872: LD_VAR 0 2
102876: IFFALSE 102882
// exit ;
102878: POP
102879: POP
102880: GO 102886
// end ;
102882: GO 102851
102884: POP
102885: POP
// end ;
102886: LD_VAR 0 2
102890: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
102891: LD_INT 0
102893: PPUSH
102894: PPUSH
// if not units then
102895: LD_VAR 0 1
102899: NOT
102900: IFFALSE 102904
// exit ;
102902: GO 102974
// result := [ ] ;
102904: LD_ADDR_VAR 0 3
102908: PUSH
102909: EMPTY
102910: ST_TO_ADDR
// for i in units do
102911: LD_ADDR_VAR 0 4
102915: PUSH
102916: LD_VAR 0 1
102920: PUSH
102921: FOR_IN
102922: IFFALSE 102972
// if GetTag ( i ) = tag then
102924: LD_VAR 0 4
102928: PPUSH
102929: CALL_OW 110
102933: PUSH
102934: LD_VAR 0 2
102938: EQUAL
102939: IFFALSE 102970
// result := Insert ( result , result + 1 , i ) ;
102941: LD_ADDR_VAR 0 3
102945: PUSH
102946: LD_VAR 0 3
102950: PPUSH
102951: LD_VAR 0 3
102955: PUSH
102956: LD_INT 1
102958: PLUS
102959: PPUSH
102960: LD_VAR 0 4
102964: PPUSH
102965: CALL_OW 2
102969: ST_TO_ADDR
102970: GO 102921
102972: POP
102973: POP
// end ;
102974: LD_VAR 0 3
102978: RET
// export function IsDriver ( un ) ; begin
102979: LD_INT 0
102981: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102982: LD_ADDR_VAR 0 2
102986: PUSH
102987: LD_VAR 0 1
102991: PUSH
102992: LD_INT 55
102994: PUSH
102995: EMPTY
102996: LIST
102997: PPUSH
102998: CALL_OW 69
103002: IN
103003: ST_TO_ADDR
// end ;
103004: LD_VAR 0 2
103008: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103009: LD_INT 0
103011: PPUSH
103012: PPUSH
// list := [ ] ;
103013: LD_ADDR_VAR 0 5
103017: PUSH
103018: EMPTY
103019: ST_TO_ADDR
// case d of 0 :
103020: LD_VAR 0 3
103024: PUSH
103025: LD_INT 0
103027: DOUBLE
103028: EQUAL
103029: IFTRUE 103033
103031: GO 103166
103033: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103034: LD_ADDR_VAR 0 5
103038: PUSH
103039: LD_VAR 0 1
103043: PUSH
103044: LD_INT 4
103046: MINUS
103047: PUSH
103048: LD_VAR 0 2
103052: PUSH
103053: LD_INT 4
103055: MINUS
103056: PUSH
103057: LD_INT 2
103059: PUSH
103060: EMPTY
103061: LIST
103062: LIST
103063: LIST
103064: PUSH
103065: LD_VAR 0 1
103069: PUSH
103070: LD_INT 3
103072: MINUS
103073: PUSH
103074: LD_VAR 0 2
103078: PUSH
103079: LD_INT 1
103081: PUSH
103082: EMPTY
103083: LIST
103084: LIST
103085: LIST
103086: PUSH
103087: LD_VAR 0 1
103091: PUSH
103092: LD_INT 4
103094: PLUS
103095: PUSH
103096: LD_VAR 0 2
103100: PUSH
103101: LD_INT 4
103103: PUSH
103104: EMPTY
103105: LIST
103106: LIST
103107: LIST
103108: PUSH
103109: LD_VAR 0 1
103113: PUSH
103114: LD_INT 3
103116: PLUS
103117: PUSH
103118: LD_VAR 0 2
103122: PUSH
103123: LD_INT 3
103125: PLUS
103126: PUSH
103127: LD_INT 5
103129: PUSH
103130: EMPTY
103131: LIST
103132: LIST
103133: LIST
103134: PUSH
103135: LD_VAR 0 1
103139: PUSH
103140: LD_VAR 0 2
103144: PUSH
103145: LD_INT 4
103147: PLUS
103148: PUSH
103149: LD_INT 0
103151: PUSH
103152: EMPTY
103153: LIST
103154: LIST
103155: LIST
103156: PUSH
103157: EMPTY
103158: LIST
103159: LIST
103160: LIST
103161: LIST
103162: LIST
103163: ST_TO_ADDR
// end ; 1 :
103164: GO 103864
103166: LD_INT 1
103168: DOUBLE
103169: EQUAL
103170: IFTRUE 103174
103172: GO 103307
103174: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103175: LD_ADDR_VAR 0 5
103179: PUSH
103180: LD_VAR 0 1
103184: PUSH
103185: LD_VAR 0 2
103189: PUSH
103190: LD_INT 4
103192: MINUS
103193: PUSH
103194: LD_INT 3
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: LIST
103201: PUSH
103202: LD_VAR 0 1
103206: PUSH
103207: LD_INT 3
103209: MINUS
103210: PUSH
103211: LD_VAR 0 2
103215: PUSH
103216: LD_INT 3
103218: MINUS
103219: PUSH
103220: LD_INT 2
103222: PUSH
103223: EMPTY
103224: LIST
103225: LIST
103226: LIST
103227: PUSH
103228: LD_VAR 0 1
103232: PUSH
103233: LD_INT 4
103235: MINUS
103236: PUSH
103237: LD_VAR 0 2
103241: PUSH
103242: LD_INT 1
103244: PUSH
103245: EMPTY
103246: LIST
103247: LIST
103248: LIST
103249: PUSH
103250: LD_VAR 0 1
103254: PUSH
103255: LD_VAR 0 2
103259: PUSH
103260: LD_INT 3
103262: PLUS
103263: PUSH
103264: LD_INT 0
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: LIST
103271: PUSH
103272: LD_VAR 0 1
103276: PUSH
103277: LD_INT 4
103279: PLUS
103280: PUSH
103281: LD_VAR 0 2
103285: PUSH
103286: LD_INT 4
103288: PLUS
103289: PUSH
103290: LD_INT 5
103292: PUSH
103293: EMPTY
103294: LIST
103295: LIST
103296: LIST
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: LIST
103302: LIST
103303: LIST
103304: ST_TO_ADDR
// end ; 2 :
103305: GO 103864
103307: LD_INT 2
103309: DOUBLE
103310: EQUAL
103311: IFTRUE 103315
103313: GO 103444
103315: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103316: LD_ADDR_VAR 0 5
103320: PUSH
103321: LD_VAR 0 1
103325: PUSH
103326: LD_VAR 0 2
103330: PUSH
103331: LD_INT 3
103333: MINUS
103334: PUSH
103335: LD_INT 3
103337: PUSH
103338: EMPTY
103339: LIST
103340: LIST
103341: LIST
103342: PUSH
103343: LD_VAR 0 1
103347: PUSH
103348: LD_INT 4
103350: PLUS
103351: PUSH
103352: LD_VAR 0 2
103356: PUSH
103357: LD_INT 4
103359: PUSH
103360: EMPTY
103361: LIST
103362: LIST
103363: LIST
103364: PUSH
103365: LD_VAR 0 1
103369: PUSH
103370: LD_VAR 0 2
103374: PUSH
103375: LD_INT 4
103377: PLUS
103378: PUSH
103379: LD_INT 0
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: LIST
103386: PUSH
103387: LD_VAR 0 1
103391: PUSH
103392: LD_INT 3
103394: MINUS
103395: PUSH
103396: LD_VAR 0 2
103400: PUSH
103401: LD_INT 1
103403: PUSH
103404: EMPTY
103405: LIST
103406: LIST
103407: LIST
103408: PUSH
103409: LD_VAR 0 1
103413: PUSH
103414: LD_INT 4
103416: MINUS
103417: PUSH
103418: LD_VAR 0 2
103422: PUSH
103423: LD_INT 4
103425: MINUS
103426: PUSH
103427: LD_INT 2
103429: PUSH
103430: EMPTY
103431: LIST
103432: LIST
103433: LIST
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: LIST
103439: LIST
103440: LIST
103441: ST_TO_ADDR
// end ; 3 :
103442: GO 103864
103444: LD_INT 3
103446: DOUBLE
103447: EQUAL
103448: IFTRUE 103452
103450: GO 103585
103452: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103453: LD_ADDR_VAR 0 5
103457: PUSH
103458: LD_VAR 0 1
103462: PUSH
103463: LD_INT 3
103465: PLUS
103466: PUSH
103467: LD_VAR 0 2
103471: PUSH
103472: LD_INT 4
103474: PUSH
103475: EMPTY
103476: LIST
103477: LIST
103478: LIST
103479: PUSH
103480: LD_VAR 0 1
103484: PUSH
103485: LD_INT 4
103487: PLUS
103488: PUSH
103489: LD_VAR 0 2
103493: PUSH
103494: LD_INT 4
103496: PLUS
103497: PUSH
103498: LD_INT 5
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: LIST
103505: PUSH
103506: LD_VAR 0 1
103510: PUSH
103511: LD_INT 4
103513: MINUS
103514: PUSH
103515: LD_VAR 0 2
103519: PUSH
103520: LD_INT 1
103522: PUSH
103523: EMPTY
103524: LIST
103525: LIST
103526: LIST
103527: PUSH
103528: LD_VAR 0 1
103532: PUSH
103533: LD_VAR 0 2
103537: PUSH
103538: LD_INT 4
103540: MINUS
103541: PUSH
103542: LD_INT 3
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: LIST
103549: PUSH
103550: LD_VAR 0 1
103554: PUSH
103555: LD_INT 3
103557: MINUS
103558: PUSH
103559: LD_VAR 0 2
103563: PUSH
103564: LD_INT 3
103566: MINUS
103567: PUSH
103568: LD_INT 2
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: LIST
103575: PUSH
103576: EMPTY
103577: LIST
103578: LIST
103579: LIST
103580: LIST
103581: LIST
103582: ST_TO_ADDR
// end ; 4 :
103583: GO 103864
103585: LD_INT 4
103587: DOUBLE
103588: EQUAL
103589: IFTRUE 103593
103591: GO 103726
103593: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103594: LD_ADDR_VAR 0 5
103598: PUSH
103599: LD_VAR 0 1
103603: PUSH
103604: LD_VAR 0 2
103608: PUSH
103609: LD_INT 4
103611: PLUS
103612: PUSH
103613: LD_INT 0
103615: PUSH
103616: EMPTY
103617: LIST
103618: LIST
103619: LIST
103620: PUSH
103621: LD_VAR 0 1
103625: PUSH
103626: LD_INT 3
103628: PLUS
103629: PUSH
103630: LD_VAR 0 2
103634: PUSH
103635: LD_INT 3
103637: PLUS
103638: PUSH
103639: LD_INT 5
103641: PUSH
103642: EMPTY
103643: LIST
103644: LIST
103645: LIST
103646: PUSH
103647: LD_VAR 0 1
103651: PUSH
103652: LD_INT 4
103654: PLUS
103655: PUSH
103656: LD_VAR 0 2
103660: PUSH
103661: LD_INT 4
103663: PUSH
103664: EMPTY
103665: LIST
103666: LIST
103667: LIST
103668: PUSH
103669: LD_VAR 0 1
103673: PUSH
103674: LD_VAR 0 2
103678: PUSH
103679: LD_INT 3
103681: MINUS
103682: PUSH
103683: LD_INT 3
103685: PUSH
103686: EMPTY
103687: LIST
103688: LIST
103689: LIST
103690: PUSH
103691: LD_VAR 0 1
103695: PUSH
103696: LD_INT 4
103698: MINUS
103699: PUSH
103700: LD_VAR 0 2
103704: PUSH
103705: LD_INT 4
103707: MINUS
103708: PUSH
103709: LD_INT 2
103711: PUSH
103712: EMPTY
103713: LIST
103714: LIST
103715: LIST
103716: PUSH
103717: EMPTY
103718: LIST
103719: LIST
103720: LIST
103721: LIST
103722: LIST
103723: ST_TO_ADDR
// end ; 5 :
103724: GO 103864
103726: LD_INT 5
103728: DOUBLE
103729: EQUAL
103730: IFTRUE 103734
103732: GO 103863
103734: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103735: LD_ADDR_VAR 0 5
103739: PUSH
103740: LD_VAR 0 1
103744: PUSH
103745: LD_INT 4
103747: MINUS
103748: PUSH
103749: LD_VAR 0 2
103753: PUSH
103754: LD_INT 1
103756: PUSH
103757: EMPTY
103758: LIST
103759: LIST
103760: LIST
103761: PUSH
103762: LD_VAR 0 1
103766: PUSH
103767: LD_VAR 0 2
103771: PUSH
103772: LD_INT 4
103774: MINUS
103775: PUSH
103776: LD_INT 3
103778: PUSH
103779: EMPTY
103780: LIST
103781: LIST
103782: LIST
103783: PUSH
103784: LD_VAR 0 1
103788: PUSH
103789: LD_INT 4
103791: PLUS
103792: PUSH
103793: LD_VAR 0 2
103797: PUSH
103798: LD_INT 4
103800: PLUS
103801: PUSH
103802: LD_INT 5
103804: PUSH
103805: EMPTY
103806: LIST
103807: LIST
103808: LIST
103809: PUSH
103810: LD_VAR 0 1
103814: PUSH
103815: LD_INT 3
103817: PLUS
103818: PUSH
103819: LD_VAR 0 2
103823: PUSH
103824: LD_INT 4
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: LIST
103831: PUSH
103832: LD_VAR 0 1
103836: PUSH
103837: LD_VAR 0 2
103841: PUSH
103842: LD_INT 3
103844: PLUS
103845: PUSH
103846: LD_INT 0
103848: PUSH
103849: EMPTY
103850: LIST
103851: LIST
103852: LIST
103853: PUSH
103854: EMPTY
103855: LIST
103856: LIST
103857: LIST
103858: LIST
103859: LIST
103860: ST_TO_ADDR
// end ; end ;
103861: GO 103864
103863: POP
// result := list ;
103864: LD_ADDR_VAR 0 4
103868: PUSH
103869: LD_VAR 0 5
103873: ST_TO_ADDR
// end ;
103874: LD_VAR 0 4
103878: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103879: LD_INT 0
103881: PPUSH
103882: PPUSH
103883: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103884: LD_VAR 0 1
103888: NOT
103889: PUSH
103890: LD_VAR 0 2
103894: PUSH
103895: LD_INT 1
103897: PUSH
103898: LD_INT 2
103900: PUSH
103901: LD_INT 3
103903: PUSH
103904: LD_INT 4
103906: PUSH
103907: EMPTY
103908: LIST
103909: LIST
103910: LIST
103911: LIST
103912: IN
103913: NOT
103914: OR
103915: IFFALSE 103919
// exit ;
103917: GO 104011
// tmp := [ ] ;
103919: LD_ADDR_VAR 0 5
103923: PUSH
103924: EMPTY
103925: ST_TO_ADDR
// for i in units do
103926: LD_ADDR_VAR 0 4
103930: PUSH
103931: LD_VAR 0 1
103935: PUSH
103936: FOR_IN
103937: IFFALSE 103980
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103939: LD_ADDR_VAR 0 5
103943: PUSH
103944: LD_VAR 0 5
103948: PPUSH
103949: LD_VAR 0 5
103953: PUSH
103954: LD_INT 1
103956: PLUS
103957: PPUSH
103958: LD_VAR 0 4
103962: PPUSH
103963: LD_VAR 0 2
103967: PPUSH
103968: CALL_OW 259
103972: PPUSH
103973: CALL_OW 2
103977: ST_TO_ADDR
103978: GO 103936
103980: POP
103981: POP
// if not tmp then
103982: LD_VAR 0 5
103986: NOT
103987: IFFALSE 103991
// exit ;
103989: GO 104011
// result := SortListByListDesc ( units , tmp ) ;
103991: LD_ADDR_VAR 0 3
103995: PUSH
103996: LD_VAR 0 1
104000: PPUSH
104001: LD_VAR 0 5
104005: PPUSH
104006: CALL_OW 77
104010: ST_TO_ADDR
// end ;
104011: LD_VAR 0 3
104015: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104016: LD_INT 0
104018: PPUSH
104019: PPUSH
104020: PPUSH
// x := GetX ( building ) ;
104021: LD_ADDR_VAR 0 4
104025: PUSH
104026: LD_VAR 0 2
104030: PPUSH
104031: CALL_OW 250
104035: ST_TO_ADDR
// y := GetY ( building ) ;
104036: LD_ADDR_VAR 0 5
104040: PUSH
104041: LD_VAR 0 2
104045: PPUSH
104046: CALL_OW 251
104050: ST_TO_ADDR
// if GetTaskList ( unit ) then
104051: LD_VAR 0 1
104055: PPUSH
104056: CALL_OW 437
104060: IFFALSE 104155
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104062: LD_STRING e
104064: PUSH
104065: LD_VAR 0 1
104069: PPUSH
104070: CALL_OW 437
104074: PUSH
104075: LD_INT 1
104077: ARRAY
104078: PUSH
104079: LD_INT 1
104081: ARRAY
104082: EQUAL
104083: PUSH
104084: LD_VAR 0 4
104088: PUSH
104089: LD_VAR 0 1
104093: PPUSH
104094: CALL_OW 437
104098: PUSH
104099: LD_INT 1
104101: ARRAY
104102: PUSH
104103: LD_INT 2
104105: ARRAY
104106: EQUAL
104107: AND
104108: PUSH
104109: LD_VAR 0 5
104113: PUSH
104114: LD_VAR 0 1
104118: PPUSH
104119: CALL_OW 437
104123: PUSH
104124: LD_INT 1
104126: ARRAY
104127: PUSH
104128: LD_INT 3
104130: ARRAY
104131: EQUAL
104132: AND
104133: IFFALSE 104145
// result := true else
104135: LD_ADDR_VAR 0 3
104139: PUSH
104140: LD_INT 1
104142: ST_TO_ADDR
104143: GO 104153
// result := false ;
104145: LD_ADDR_VAR 0 3
104149: PUSH
104150: LD_INT 0
104152: ST_TO_ADDR
// end else
104153: GO 104163
// result := false ;
104155: LD_ADDR_VAR 0 3
104159: PUSH
104160: LD_INT 0
104162: ST_TO_ADDR
// end ;
104163: LD_VAR 0 3
104167: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104168: LD_INT 0
104170: PPUSH
104171: PPUSH
104172: PPUSH
104173: PPUSH
// if not unit or not area then
104174: LD_VAR 0 1
104178: NOT
104179: PUSH
104180: LD_VAR 0 2
104184: NOT
104185: OR
104186: IFFALSE 104190
// exit ;
104188: GO 104354
// tmp := AreaToList ( area , i ) ;
104190: LD_ADDR_VAR 0 6
104194: PUSH
104195: LD_VAR 0 2
104199: PPUSH
104200: LD_VAR 0 5
104204: PPUSH
104205: CALL_OW 517
104209: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104210: LD_ADDR_VAR 0 5
104214: PUSH
104215: DOUBLE
104216: LD_INT 1
104218: DEC
104219: ST_TO_ADDR
104220: LD_VAR 0 6
104224: PUSH
104225: LD_INT 1
104227: ARRAY
104228: PUSH
104229: FOR_TO
104230: IFFALSE 104352
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104232: LD_ADDR_VAR 0 7
104236: PUSH
104237: LD_VAR 0 6
104241: PUSH
104242: LD_INT 1
104244: ARRAY
104245: PUSH
104246: LD_VAR 0 5
104250: ARRAY
104251: PUSH
104252: LD_VAR 0 6
104256: PUSH
104257: LD_INT 2
104259: ARRAY
104260: PUSH
104261: LD_VAR 0 5
104265: ARRAY
104266: PUSH
104267: EMPTY
104268: LIST
104269: LIST
104270: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104271: LD_VAR 0 7
104275: PUSH
104276: LD_INT 1
104278: ARRAY
104279: PPUSH
104280: LD_VAR 0 7
104284: PUSH
104285: LD_INT 2
104287: ARRAY
104288: PPUSH
104289: CALL_OW 428
104293: PUSH
104294: LD_INT 0
104296: EQUAL
104297: IFFALSE 104350
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104299: LD_VAR 0 1
104303: PPUSH
104304: LD_VAR 0 7
104308: PUSH
104309: LD_INT 1
104311: ARRAY
104312: PPUSH
104313: LD_VAR 0 7
104317: PUSH
104318: LD_INT 2
104320: ARRAY
104321: PPUSH
104322: LD_VAR 0 3
104326: PPUSH
104327: CALL_OW 48
// result := IsPlaced ( unit ) ;
104331: LD_ADDR_VAR 0 4
104335: PUSH
104336: LD_VAR 0 1
104340: PPUSH
104341: CALL_OW 305
104345: ST_TO_ADDR
// exit ;
104346: POP
104347: POP
104348: GO 104354
// end ; end ;
104350: GO 104229
104352: POP
104353: POP
// end ;
104354: LD_VAR 0 4
104358: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104359: LD_INT 0
104361: PPUSH
104362: PPUSH
104363: PPUSH
// if not side or side > 8 then
104364: LD_VAR 0 1
104368: NOT
104369: PUSH
104370: LD_VAR 0 1
104374: PUSH
104375: LD_INT 8
104377: GREATER
104378: OR
104379: IFFALSE 104383
// exit ;
104381: GO 104570
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104383: LD_ADDR_VAR 0 4
104387: PUSH
104388: LD_INT 22
104390: PUSH
104391: LD_VAR 0 1
104395: PUSH
104396: EMPTY
104397: LIST
104398: LIST
104399: PUSH
104400: LD_INT 21
104402: PUSH
104403: LD_INT 3
104405: PUSH
104406: EMPTY
104407: LIST
104408: LIST
104409: PUSH
104410: EMPTY
104411: LIST
104412: LIST
104413: PPUSH
104414: CALL_OW 69
104418: ST_TO_ADDR
// if not tmp then
104419: LD_VAR 0 4
104423: NOT
104424: IFFALSE 104428
// exit ;
104426: GO 104570
// enable_addtolog := true ;
104428: LD_ADDR_OWVAR 81
104432: PUSH
104433: LD_INT 1
104435: ST_TO_ADDR
// AddToLog ( [ ) ;
104436: LD_STRING [
104438: PPUSH
104439: CALL_OW 561
// for i in tmp do
104443: LD_ADDR_VAR 0 3
104447: PUSH
104448: LD_VAR 0 4
104452: PUSH
104453: FOR_IN
104454: IFFALSE 104561
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104456: LD_STRING [
104458: PUSH
104459: LD_VAR 0 3
104463: PPUSH
104464: CALL_OW 266
104468: STR
104469: PUSH
104470: LD_STRING , 
104472: STR
104473: PUSH
104474: LD_VAR 0 3
104478: PPUSH
104479: CALL_OW 250
104483: STR
104484: PUSH
104485: LD_STRING , 
104487: STR
104488: PUSH
104489: LD_VAR 0 3
104493: PPUSH
104494: CALL_OW 251
104498: STR
104499: PUSH
104500: LD_STRING , 
104502: STR
104503: PUSH
104504: LD_VAR 0 3
104508: PPUSH
104509: CALL_OW 254
104513: STR
104514: PUSH
104515: LD_STRING , 
104517: STR
104518: PUSH
104519: LD_VAR 0 3
104523: PPUSH
104524: LD_INT 1
104526: PPUSH
104527: CALL_OW 268
104531: STR
104532: PUSH
104533: LD_STRING , 
104535: STR
104536: PUSH
104537: LD_VAR 0 3
104541: PPUSH
104542: LD_INT 2
104544: PPUSH
104545: CALL_OW 268
104549: STR
104550: PUSH
104551: LD_STRING ],
104553: STR
104554: PPUSH
104555: CALL_OW 561
// end ;
104559: GO 104453
104561: POP
104562: POP
// AddToLog ( ]; ) ;
104563: LD_STRING ];
104565: PPUSH
104566: CALL_OW 561
// end ;
104570: LD_VAR 0 2
104574: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104575: LD_INT 0
104577: PPUSH
104578: PPUSH
104579: PPUSH
104580: PPUSH
104581: PPUSH
// if not area or not rate or not max then
104582: LD_VAR 0 1
104586: NOT
104587: PUSH
104588: LD_VAR 0 2
104592: NOT
104593: OR
104594: PUSH
104595: LD_VAR 0 4
104599: NOT
104600: OR
104601: IFFALSE 104605
// exit ;
104603: GO 104797
// while 1 do
104605: LD_INT 1
104607: IFFALSE 104797
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104609: LD_ADDR_VAR 0 9
104613: PUSH
104614: LD_VAR 0 1
104618: PPUSH
104619: LD_INT 1
104621: PPUSH
104622: CALL_OW 287
104626: PUSH
104627: LD_INT 10
104629: MUL
104630: ST_TO_ADDR
// r := rate / 10 ;
104631: LD_ADDR_VAR 0 7
104635: PUSH
104636: LD_VAR 0 2
104640: PUSH
104641: LD_INT 10
104643: DIVREAL
104644: ST_TO_ADDR
// time := 1 1$00 ;
104645: LD_ADDR_VAR 0 8
104649: PUSH
104650: LD_INT 2100
104652: ST_TO_ADDR
// if amount < min then
104653: LD_VAR 0 9
104657: PUSH
104658: LD_VAR 0 3
104662: LESS
104663: IFFALSE 104681
// r := r * 2 else
104665: LD_ADDR_VAR 0 7
104669: PUSH
104670: LD_VAR 0 7
104674: PUSH
104675: LD_INT 2
104677: MUL
104678: ST_TO_ADDR
104679: GO 104707
// if amount > max then
104681: LD_VAR 0 9
104685: PUSH
104686: LD_VAR 0 4
104690: GREATER
104691: IFFALSE 104707
// r := r / 2 ;
104693: LD_ADDR_VAR 0 7
104697: PUSH
104698: LD_VAR 0 7
104702: PUSH
104703: LD_INT 2
104705: DIVREAL
104706: ST_TO_ADDR
// time := time / r ;
104707: LD_ADDR_VAR 0 8
104711: PUSH
104712: LD_VAR 0 8
104716: PUSH
104717: LD_VAR 0 7
104721: DIVREAL
104722: ST_TO_ADDR
// if time < 0 then
104723: LD_VAR 0 8
104727: PUSH
104728: LD_INT 0
104730: LESS
104731: IFFALSE 104748
// time := time * - 1 ;
104733: LD_ADDR_VAR 0 8
104737: PUSH
104738: LD_VAR 0 8
104742: PUSH
104743: LD_INT 1
104745: NEG
104746: MUL
104747: ST_TO_ADDR
// wait ( time ) ;
104748: LD_VAR 0 8
104752: PPUSH
104753: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
104757: LD_INT 35
104759: PPUSH
104760: LD_INT 875
104762: PPUSH
104763: CALL_OW 12
104767: PPUSH
104768: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104772: LD_INT 1
104774: PPUSH
104775: LD_INT 5
104777: PPUSH
104778: CALL_OW 12
104782: PPUSH
104783: LD_VAR 0 1
104787: PPUSH
104788: LD_INT 1
104790: PPUSH
104791: CALL_OW 55
// end ;
104795: GO 104605
// end ;
104797: LD_VAR 0 5
104801: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104802: LD_INT 0
104804: PPUSH
104805: PPUSH
104806: PPUSH
104807: PPUSH
104808: PPUSH
104809: PPUSH
104810: PPUSH
104811: PPUSH
// if not turrets or not factories then
104812: LD_VAR 0 1
104816: NOT
104817: PUSH
104818: LD_VAR 0 2
104822: NOT
104823: OR
104824: IFFALSE 104828
// exit ;
104826: GO 105135
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104828: LD_ADDR_VAR 0 10
104832: PUSH
104833: LD_INT 5
104835: PUSH
104836: LD_INT 6
104838: PUSH
104839: EMPTY
104840: LIST
104841: LIST
104842: PUSH
104843: LD_INT 2
104845: PUSH
104846: LD_INT 4
104848: PUSH
104849: EMPTY
104850: LIST
104851: LIST
104852: PUSH
104853: LD_INT 3
104855: PUSH
104856: LD_INT 5
104858: PUSH
104859: EMPTY
104860: LIST
104861: LIST
104862: PUSH
104863: EMPTY
104864: LIST
104865: LIST
104866: LIST
104867: PUSH
104868: LD_INT 24
104870: PUSH
104871: LD_INT 25
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PUSH
104878: LD_INT 23
104880: PUSH
104881: LD_INT 27
104883: PUSH
104884: EMPTY
104885: LIST
104886: LIST
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: PUSH
104892: LD_INT 42
104894: PUSH
104895: LD_INT 43
104897: PUSH
104898: EMPTY
104899: LIST
104900: LIST
104901: PUSH
104902: LD_INT 44
104904: PUSH
104905: LD_INT 46
104907: PUSH
104908: EMPTY
104909: LIST
104910: LIST
104911: PUSH
104912: LD_INT 45
104914: PUSH
104915: LD_INT 47
104917: PUSH
104918: EMPTY
104919: LIST
104920: LIST
104921: PUSH
104922: EMPTY
104923: LIST
104924: LIST
104925: LIST
104926: PUSH
104927: EMPTY
104928: LIST
104929: LIST
104930: LIST
104931: ST_TO_ADDR
// result := [ ] ;
104932: LD_ADDR_VAR 0 3
104936: PUSH
104937: EMPTY
104938: ST_TO_ADDR
// for i in turrets do
104939: LD_ADDR_VAR 0 4
104943: PUSH
104944: LD_VAR 0 1
104948: PUSH
104949: FOR_IN
104950: IFFALSE 105133
// begin nat := GetNation ( i ) ;
104952: LD_ADDR_VAR 0 7
104956: PUSH
104957: LD_VAR 0 4
104961: PPUSH
104962: CALL_OW 248
104966: ST_TO_ADDR
// weapon := 0 ;
104967: LD_ADDR_VAR 0 8
104971: PUSH
104972: LD_INT 0
104974: ST_TO_ADDR
// if not nat then
104975: LD_VAR 0 7
104979: NOT
104980: IFFALSE 104984
// continue ;
104982: GO 104949
// for j in list [ nat ] do
104984: LD_ADDR_VAR 0 5
104988: PUSH
104989: LD_VAR 0 10
104993: PUSH
104994: LD_VAR 0 7
104998: ARRAY
104999: PUSH
105000: FOR_IN
105001: IFFALSE 105042
// if GetBWeapon ( i ) = j [ 1 ] then
105003: LD_VAR 0 4
105007: PPUSH
105008: CALL_OW 269
105012: PUSH
105013: LD_VAR 0 5
105017: PUSH
105018: LD_INT 1
105020: ARRAY
105021: EQUAL
105022: IFFALSE 105040
// begin weapon := j [ 2 ] ;
105024: LD_ADDR_VAR 0 8
105028: PUSH
105029: LD_VAR 0 5
105033: PUSH
105034: LD_INT 2
105036: ARRAY
105037: ST_TO_ADDR
// break ;
105038: GO 105042
// end ;
105040: GO 105000
105042: POP
105043: POP
// if not weapon then
105044: LD_VAR 0 8
105048: NOT
105049: IFFALSE 105053
// continue ;
105051: GO 104949
// for k in factories do
105053: LD_ADDR_VAR 0 6
105057: PUSH
105058: LD_VAR 0 2
105062: PUSH
105063: FOR_IN
105064: IFFALSE 105129
// begin weapons := AvailableWeaponList ( k ) ;
105066: LD_ADDR_VAR 0 9
105070: PUSH
105071: LD_VAR 0 6
105075: PPUSH
105076: CALL_OW 478
105080: ST_TO_ADDR
// if not weapons then
105081: LD_VAR 0 9
105085: NOT
105086: IFFALSE 105090
// continue ;
105088: GO 105063
// if weapon in weapons then
105090: LD_VAR 0 8
105094: PUSH
105095: LD_VAR 0 9
105099: IN
105100: IFFALSE 105127
// begin result := [ i , weapon ] ;
105102: LD_ADDR_VAR 0 3
105106: PUSH
105107: LD_VAR 0 4
105111: PUSH
105112: LD_VAR 0 8
105116: PUSH
105117: EMPTY
105118: LIST
105119: LIST
105120: ST_TO_ADDR
// exit ;
105121: POP
105122: POP
105123: POP
105124: POP
105125: GO 105135
// end ; end ;
105127: GO 105063
105129: POP
105130: POP
// end ;
105131: GO 104949
105133: POP
105134: POP
// end ;
105135: LD_VAR 0 3
105139: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105140: LD_INT 0
105142: PPUSH
// if not side or side > 8 then
105143: LD_VAR 0 3
105147: NOT
105148: PUSH
105149: LD_VAR 0 3
105153: PUSH
105154: LD_INT 8
105156: GREATER
105157: OR
105158: IFFALSE 105162
// exit ;
105160: GO 105221
// if not range then
105162: LD_VAR 0 4
105166: NOT
105167: IFFALSE 105178
// range := - 12 ;
105169: LD_ADDR_VAR 0 4
105173: PUSH
105174: LD_INT 12
105176: NEG
105177: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105178: LD_VAR 0 1
105182: PPUSH
105183: LD_VAR 0 2
105187: PPUSH
105188: LD_VAR 0 3
105192: PPUSH
105193: LD_VAR 0 4
105197: PPUSH
105198: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105202: LD_VAR 0 1
105206: PPUSH
105207: LD_VAR 0 2
105211: PPUSH
105212: LD_VAR 0 3
105216: PPUSH
105217: CALL_OW 331
// end ;
105221: LD_VAR 0 5
105225: RET
// export function Video ( mode ) ; begin
105226: LD_INT 0
105228: PPUSH
// ingame_video = mode ;
105229: LD_ADDR_OWVAR 52
105233: PUSH
105234: LD_VAR 0 1
105238: ST_TO_ADDR
// interface_hidden = mode ;
105239: LD_ADDR_OWVAR 54
105243: PUSH
105244: LD_VAR 0 1
105248: ST_TO_ADDR
// end ;
105249: LD_VAR 0 2
105253: RET
// export function Join ( array , element ) ; begin
105254: LD_INT 0
105256: PPUSH
// result := array ^ element ;
105257: LD_ADDR_VAR 0 3
105261: PUSH
105262: LD_VAR 0 1
105266: PUSH
105267: LD_VAR 0 2
105271: ADD
105272: ST_TO_ADDR
// end ;
105273: LD_VAR 0 3
105277: RET
// export function JoinUnion ( array , element ) ; begin
105278: LD_INT 0
105280: PPUSH
// result := array union element ;
105281: LD_ADDR_VAR 0 3
105285: PUSH
105286: LD_VAR 0 1
105290: PUSH
105291: LD_VAR 0 2
105295: UNION
105296: ST_TO_ADDR
// end ;
105297: LD_VAR 0 3
105301: RET
// export function GetBehemoths ( side ) ; begin
105302: LD_INT 0
105304: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
105305: LD_ADDR_VAR 0 2
105309: PUSH
105310: LD_INT 22
105312: PUSH
105313: LD_VAR 0 1
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: PUSH
105322: LD_INT 31
105324: PUSH
105325: LD_INT 25
105327: PUSH
105328: EMPTY
105329: LIST
105330: LIST
105331: PUSH
105332: EMPTY
105333: LIST
105334: LIST
105335: PPUSH
105336: CALL_OW 69
105340: ST_TO_ADDR
// end ;
105341: LD_VAR 0 2
105345: RET
// export function Shuffle ( array ) ; var i , index ; begin
105346: LD_INT 0
105348: PPUSH
105349: PPUSH
105350: PPUSH
// result := [ ] ;
105351: LD_ADDR_VAR 0 2
105355: PUSH
105356: EMPTY
105357: ST_TO_ADDR
// if not array then
105358: LD_VAR 0 1
105362: NOT
105363: IFFALSE 105367
// exit ;
105365: GO 105466
// Randomize ;
105367: CALL_OW 10
// for i = array downto 1 do
105371: LD_ADDR_VAR 0 3
105375: PUSH
105376: DOUBLE
105377: LD_VAR 0 1
105381: INC
105382: ST_TO_ADDR
105383: LD_INT 1
105385: PUSH
105386: FOR_DOWNTO
105387: IFFALSE 105464
// begin index := rand ( 1 , array ) ;
105389: LD_ADDR_VAR 0 4
105393: PUSH
105394: LD_INT 1
105396: PPUSH
105397: LD_VAR 0 1
105401: PPUSH
105402: CALL_OW 12
105406: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105407: LD_ADDR_VAR 0 2
105411: PUSH
105412: LD_VAR 0 2
105416: PPUSH
105417: LD_VAR 0 2
105421: PUSH
105422: LD_INT 1
105424: PLUS
105425: PPUSH
105426: LD_VAR 0 1
105430: PUSH
105431: LD_VAR 0 4
105435: ARRAY
105436: PPUSH
105437: CALL_OW 2
105441: ST_TO_ADDR
// array := Delete ( array , index ) ;
105442: LD_ADDR_VAR 0 1
105446: PUSH
105447: LD_VAR 0 1
105451: PPUSH
105452: LD_VAR 0 4
105456: PPUSH
105457: CALL_OW 3
105461: ST_TO_ADDR
// end ;
105462: GO 105386
105464: POP
105465: POP
// end ;
105466: LD_VAR 0 2
105470: RET
