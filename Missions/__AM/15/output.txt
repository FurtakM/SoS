// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34988 0 0
// InitMacro ;
  19: CALL 35148 0 0
// InitNature ;
  23: CALL 34856 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37313 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 139
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 140
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59738 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59831 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59181 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 58996 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59738 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59831 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 58996 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59181 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59611 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58678 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59738 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59831 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 144
 959: PUSH
 960: LD_EXP 144
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 58996 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59738 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59831 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58888 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 60149 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59320 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59611 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59611 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59943 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 58996 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59562 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65407 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70231 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70231 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70231 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70231 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70231 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65407 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65407 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65407 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65407 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65407 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65407 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65407 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65407 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65407 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65407 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65407 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65407 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65407 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65407 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65407 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65407 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65407 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65407 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65407 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65407 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65407 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65407 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65407 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65407 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65407 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65407 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65407 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65407 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70231 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65407 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65407 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65407 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73672 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 115
4739: PUSH
4740: LD_EXP 115
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70231 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 59181 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 59044 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60462 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 59044 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 59044 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60462 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60462 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 134
6023: PUSH
6024: LD_EXP 134
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 134
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70231 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65407 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73672 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 115
7483: PUSH
7484: LD_EXP 115
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 101729 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 101729 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 101790 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 101790 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70231 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70231 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70231 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70231 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70231 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70231 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70231 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70231 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65407 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60462 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 59044 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 59044 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 59044 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60462 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60462 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 134
10579: PUSH
10580: LD_EXP 134
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 134
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65407 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 115
11990: PUSH
11991: LD_EXP 115
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 101834 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 59044 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 59044 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 59044 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60462 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60462 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 134
13374: PUSH
13375: LD_EXP 134
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 134
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70231 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70231 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70231 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70231 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 101701 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 101615 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 101615 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 101615 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 101615 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 101615 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 101615 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 101615 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 101615 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 101615 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 101701 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 115
17039: PUSH
17040: LD_EXP 115
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 101701 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 101701 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 134
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 100235 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 100235 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 115
19216: PUSH
19217: LD_EXP 115
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 115
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 134
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 134
19588: PUSH
19589: LD_EXP 134
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 134
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 115
20048: PUSH
20049: LD_EXP 115
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 115
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70231 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 58996 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 134
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 134
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 134
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35390 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 101701 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70231 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73318 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 101701 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65470 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35390 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65407 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65407 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65407 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70231 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 101790 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 59044 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 99335 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 99335 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 2 ) ;
29795: LD_INT 2
29797: PPUSH
29798: CALL 35390 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35390 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 99335 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 115
32464: PUSH
32465: LD_EXP 115
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 115
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 33
32737: PUSH
32738: LD_INT 5
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 21
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 50
32757: PUSH
32758: EMPTY
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: PPUSH
32767: CALL_OW 69
32771: PUSH
32772: LD_INT 0
32774: EQUAL
32775: AND
32776: PUSH
32777: LD_EXP 21
32781: AND
32782: PUSH
32783: LD_EXP 22
32787: AND
32788: PUSH
32789: LD_EXP 23
32793: AND
32794: IFFALSE 33443
32796: GO 32798
32798: DISABLE
32799: LD_INT 0
32801: PPUSH
32802: PPUSH
32803: PPUSH
// begin m1 := false ;
32804: LD_ADDR_VAR 0 1
32808: PUSH
32809: LD_INT 0
32811: ST_TO_ADDR
// m2 := false ;
32812: LD_ADDR_VAR 0 2
32816: PUSH
32817: LD_INT 0
32819: ST_TO_ADDR
// m3 := false ;
32820: LD_ADDR_VAR 0 3
32824: PUSH
32825: LD_INT 0
32827: ST_TO_ADDR
// if not bombExploded then
32828: LD_EXP 37
32832: NOT
32833: IFFALSE 32842
// SetAchievement ( ACH_SIBROCKET ) ;
32835: LD_STRING ACH_SIBROCKET
32837: PPUSH
32838: CALL_OW 543
// if tick <= 120 120$00 then
32842: LD_OWVAR 1
32846: PUSH
32847: LD_INT 252000
32849: LESSEQUAL
32850: IFFALSE 32866
// begin wait ( 3 ) ;
32852: LD_INT 3
32854: PPUSH
32855: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32859: LD_STRING ACH_ASPEED_15
32861: PPUSH
32862: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32866: LD_EXP 39
32870: PPUSH
32871: CALL_OW 87
// music_class := 5 ;
32875: LD_ADDR_OWVAR 72
32879: PUSH
32880: LD_INT 5
32882: ST_TO_ADDR
// music_nat := 5 ;
32883: LD_ADDR_OWVAR 71
32887: PUSH
32888: LD_INT 5
32890: ST_TO_ADDR
// DialogueOn ;
32891: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32895: LD_EXP 39
32899: PPUSH
32900: LD_STRING D20-JMM-1
32902: PPUSH
32903: CALL_OW 88
// if IsOK ( Joan ) then
32907: LD_EXP 40
32911: PPUSH
32912: CALL_OW 302
32916: IFFALSE 32930
// Say ( Joan , D20-Joan-1 ) ;
32918: LD_EXP 40
32922: PPUSH
32923: LD_STRING D20-Joan-1
32925: PPUSH
32926: CALL_OW 88
// if IsOk ( Lisa ) then
32930: LD_EXP 42
32934: PPUSH
32935: CALL_OW 302
32939: IFFALSE 32953
// Say ( Lisa , D20-Lisa-1 ) ;
32941: LD_EXP 42
32945: PPUSH
32946: LD_STRING D20-Lisa-1
32948: PPUSH
32949: CALL_OW 88
// if IsOk ( Donaldson ) then
32953: LD_EXP 43
32957: PPUSH
32958: CALL_OW 302
32962: IFFALSE 32976
// Say ( Donaldson , D20-Don-1 ) ;
32964: LD_EXP 43
32968: PPUSH
32969: LD_STRING D20-Don-1
32971: PPUSH
32972: CALL_OW 88
// if IsOK ( Cornel ) then
32976: LD_EXP 50
32980: PPUSH
32981: CALL_OW 302
32985: IFFALSE 32999
// Say ( Cornel , D20-Corn-1 ) ;
32987: LD_EXP 50
32991: PPUSH
32992: LD_STRING D20-Corn-1
32994: PPUSH
32995: CALL_OW 88
// if IsOk ( Denis ) then
32999: LD_EXP 46
33003: PPUSH
33004: CALL_OW 302
33008: IFFALSE 33022
// Say ( Denis , D20-Den-1 ) ;
33010: LD_EXP 46
33014: PPUSH
33015: LD_STRING D20-Den-1
33017: PPUSH
33018: CALL_OW 88
// if IsOk ( Bobby ) then
33022: LD_EXP 44
33026: PPUSH
33027: CALL_OW 302
33031: IFFALSE 33045
// Say ( Bobby , D20-Bobby-1 ) ;
33033: LD_EXP 44
33037: PPUSH
33038: LD_STRING D20-Bobby-1
33040: PPUSH
33041: CALL_OW 88
// if IsOk ( Gladstone ) then
33045: LD_EXP 48
33049: PPUSH
33050: CALL_OW 302
33054: IFFALSE 33068
// Say ( Gladstone , D20-Glad-1 ) ;
33056: LD_EXP 48
33060: PPUSH
33061: LD_STRING D20-Glad-1
33063: PPUSH
33064: CALL_OW 88
// if IsOk ( Cyrus ) then
33068: LD_EXP 45
33072: PPUSH
33073: CALL_OW 302
33077: IFFALSE 33091
// Say ( Cyrus , D20-Cyrus-1 ) ;
33079: LD_EXP 45
33083: PPUSH
33084: LD_STRING D20-Cyrus-1
33086: PPUSH
33087: CALL_OW 88
// if IsOk ( Stevens ) then
33091: LD_EXP 41
33095: PPUSH
33096: CALL_OW 302
33100: IFFALSE 33114
// Say ( Stevens , D20-Huck-1 ) ;
33102: LD_EXP 41
33106: PPUSH
33107: LD_STRING D20-Huck-1
33109: PPUSH
33110: CALL_OW 88
// if IsOk ( Brown ) then
33114: LD_EXP 47
33118: PPUSH
33119: CALL_OW 302
33123: IFFALSE 33137
// Say ( Brown , D20-Brown-1 ) ;
33125: LD_EXP 47
33129: PPUSH
33130: LD_STRING D20-Brown-1
33132: PPUSH
33133: CALL_OW 88
// if IsOk ( Gary ) then
33137: LD_EXP 51
33141: PPUSH
33142: CALL_OW 302
33146: IFFALSE 33160
// Say ( Gary , D20-Gary-1 ) ;
33148: LD_EXP 51
33152: PPUSH
33153: LD_STRING D20-Gary-1
33155: PPUSH
33156: CALL_OW 88
// if IsOk ( Connie ) then
33160: LD_EXP 54
33164: PPUSH
33165: CALL_OW 302
33169: IFFALSE 33183
// Say ( Connie , D20-Con-1 ) ;
33171: LD_EXP 54
33175: PPUSH
33176: LD_STRING D20-Con-1
33178: PPUSH
33179: CALL_OW 88
// if IsOk ( Kurt ) then
33183: LD_EXP 60
33187: PPUSH
33188: CALL_OW 302
33192: IFFALSE 33206
// Say ( Kurt , D20-Kurt-1 ) ;
33194: LD_EXP 60
33198: PPUSH
33199: LD_STRING D20-Kurt-1
33201: PPUSH
33202: CALL_OW 88
// if IsOk ( Kikuchi ) then
33206: LD_EXP 53
33210: PPUSH
33211: CALL_OW 302
33215: IFFALSE 33229
// Say ( Kikuchi , D20-Yam-1 ) ;
33217: LD_EXP 53
33221: PPUSH
33222: LD_STRING D20-Yam-1
33224: PPUSH
33225: CALL_OW 88
// if IsOk ( Frank ) then
33229: LD_EXP 52
33233: PPUSH
33234: CALL_OW 302
33238: IFFALSE 33252
// Say ( Frank , D20-Frank-1 ) ;
33240: LD_EXP 52
33244: PPUSH
33245: LD_STRING D20-Frank-1
33247: PPUSH
33248: CALL_OW 88
// DialogueOff ;
33252: CALL_OW 7
// if RothCaptured then
33256: LD_EXP 33
33260: IFFALSE 33282
// begin m1 := true ;
33262: LD_ADDR_VAR 0 1
33266: PUSH
33267: LD_INT 1
33269: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33270: LD_STRING Roth
33272: PPUSH
33273: LD_INT 1
33275: PPUSH
33276: CALL_OW 101
// end else
33280: GO 33293
// AddMedal ( Roth , - 1 ) ;
33282: LD_STRING Roth
33284: PPUSH
33285: LD_INT 1
33287: NEG
33288: PPUSH
33289: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33293: LD_EXP 25
33297: NOT
33298: PUSH
33299: LD_EXP 27
33303: OR
33304: IFFALSE 33326
// begin m2 := true ;
33306: LD_ADDR_VAR 0 2
33310: PUSH
33311: LD_INT 1
33313: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33314: LD_STRING Project
33316: PPUSH
33317: LD_INT 1
33319: PPUSH
33320: CALL_OW 101
// end else
33324: GO 33337
// AddMedal ( Project , - 1 ) ;
33326: LD_STRING Project
33328: PPUSH
33329: LD_INT 1
33331: NEG
33332: PPUSH
33333: CALL_OW 101
// if lostCounter = 0 then
33337: LD_EXP 32
33341: PUSH
33342: LD_INT 0
33344: EQUAL
33345: IFFALSE 33367
// begin m3 := true ;
33347: LD_ADDR_VAR 0 3
33351: PUSH
33352: LD_INT 1
33354: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33355: LD_STRING NoLosses
33357: PPUSH
33358: LD_INT 1
33360: PPUSH
33361: CALL_OW 101
// end else
33365: GO 33378
// AddMedal ( NoLosses , - 1 ) ;
33367: LD_STRING NoLosses
33369: PPUSH
33370: LD_INT 1
33372: NEG
33373: PPUSH
33374: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33378: LD_VAR 0 1
33382: PUSH
33383: LD_VAR 0 2
33387: AND
33388: PUSH
33389: LD_VAR 0 3
33393: AND
33394: PUSH
33395: LD_OWVAR 67
33399: PUSH
33400: LD_INT 3
33402: EQUAL
33403: AND
33404: IFFALSE 33416
// SetAchievementEX ( ACH_AMER , 15 ) ;
33406: LD_STRING ACH_AMER
33408: PPUSH
33409: LD_INT 15
33411: PPUSH
33412: CALL_OW 564
// GiveMedals ( MAIN ) ;
33416: LD_STRING MAIN
33418: PPUSH
33419: CALL_OW 102
// music_class := 4 ;
33423: LD_ADDR_OWVAR 72
33427: PUSH
33428: LD_INT 4
33430: ST_TO_ADDR
// music_nat := 1 ;
33431: LD_ADDR_OWVAR 71
33435: PUSH
33436: LD_INT 1
33438: ST_TO_ADDR
// YouWin ;
33439: CALL_OW 103
// end ; end_of_file
33443: PPOPN 3
33445: END
// export function CustomEvent ( event ) ; begin
33446: LD_INT 0
33448: PPUSH
// end ;
33449: LD_VAR 0 2
33453: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33454: LD_VAR 0 1
33458: PUSH
33459: LD_INT 1
33461: EQUAL
33462: PUSH
33463: LD_VAR 0 2
33467: PUSH
33468: LD_INT 4
33470: EQUAL
33471: AND
33472: PUSH
33473: LD_EXP 58
33477: PPUSH
33478: CALL_OW 300
33482: AND
33483: IFFALSE 33499
// begin wait ( 0 0$2 ) ;
33485: LD_INT 70
33487: PPUSH
33488: CALL_OW 67
// YouLost ( Dismissed ) ;
33492: LD_STRING Dismissed
33494: PPUSH
33495: CALL_OW 104
// end ; end ;
33499: PPOPN 2
33501: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33502: LD_VAR 0 2
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: LD_INT 18
33514: PPUSH
33515: CALL_OW 309
33519: IFFALSE 33528
// YouLost ( Motherlode3 ) ;
33521: LD_STRING Motherlode3
33523: PPUSH
33524: CALL_OW 104
// end ;
33528: PPOPN 3
33530: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33531: LD_EXP 27
33535: NOT
33536: IFFALSE 33546
// behemothDone := true ;
33538: LD_ADDR_EXP 28
33542: PUSH
33543: LD_INT 1
33545: ST_TO_ADDR
// end ;
33546: PPOPN 1
33548: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33549: LD_VAR 0 1
33553: PPUSH
33554: CALL_OW 255
33558: PUSH
33559: LD_INT 1
33561: EQUAL
33562: IFFALSE 33572
// bombExploded := true ;
33564: LD_ADDR_EXP 37
33568: PUSH
33569: LD_INT 1
33571: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33572: LD_VAR 0 1
33576: PPUSH
33577: CALL_OW 255
33581: PUSH
33582: LD_INT 1
33584: EQUAL
33585: PUSH
33586: LD_EXP 30
33590: AND
33591: PUSH
33592: LD_INT 22
33594: PUSH
33595: LD_INT 3
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 34
33604: PUSH
33605: LD_INT 48
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 69
33620: AND
33621: PUSH
33622: LD_INT 22
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 34
33634: PUSH
33635: LD_INT 8
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PPUSH
33646: CALL_OW 69
33650: NOT
33651: AND
33652: IFFALSE 33704
// begin wait ( 0 0$5 ) ;
33654: LD_INT 175
33656: PPUSH
33657: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33661: LD_INT 22
33663: PUSH
33664: LD_INT 3
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 34
33673: PUSH
33674: LD_INT 48
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PPUSH
33685: CALL_OW 69
33689: PUSH
33690: LD_INT 1
33692: ARRAY
33693: PPUSH
33694: LD_INT 60
33696: PPUSH
33697: LD_INT 95
33699: PPUSH
33700: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33704: LD_VAR 0 2
33708: PPUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: LD_INT 18
33716: PPUSH
33717: CALL_OW 309
33721: IFFALSE 33781
// begin if GetSide ( unit ) = 1 then
33723: LD_VAR 0 1
33727: PPUSH
33728: CALL_OW 255
33732: PUSH
33733: LD_INT 1
33735: EQUAL
33736: IFFALSE 33752
// begin wait ( 0 0$6 ) ;
33738: LD_INT 210
33740: PPUSH
33741: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33745: LD_STRING Motherlode2
33747: PPUSH
33748: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33752: LD_VAR 0 1
33756: PPUSH
33757: CALL_OW 255
33761: PUSH
33762: LD_INT 8
33764: EQUAL
33765: IFFALSE 33781
// begin wait ( 0 0$6 ) ;
33767: LD_INT 210
33769: PPUSH
33770: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33774: LD_STRING Motherlode1
33776: PPUSH
33777: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33781: LD_VAR 0 1
33785: PPUSH
33786: CALL_OW 255
33790: PUSH
33791: LD_INT 3
33793: EQUAL
33794: IFFALSE 33815
// begin wait ( 0 0$5 ) ;
33796: LD_INT 175
33798: PPUSH
33799: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33803: LD_EXP 64
33807: PPUSH
33808: LD_STRING D18-Pla-1
33810: PPUSH
33811: CALL_OW 94
// end ; end ;
33815: PPOPN 3
33817: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33818: LD_VAR 0 1
33822: PUSH
33823: LD_INT 22
33825: PUSH
33826: LD_INT 1
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 21
33835: PUSH
33836: LD_INT 1
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 23
33845: PUSH
33846: LD_INT 1
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: LIST
33857: PPUSH
33858: CALL_OW 69
33862: IN
33863: IFFALSE 33879
// lostCounter := lostCounter + 1 ;
33865: LD_ADDR_EXP 32
33869: PUSH
33870: LD_EXP 32
33874: PUSH
33875: LD_INT 1
33877: PLUS
33878: ST_TO_ADDR
// if un in behemothBuilders then
33879: LD_VAR 0 1
33883: PUSH
33884: LD_EXP 73
33888: IN
33889: IFFALSE 33909
// begin behemothBuilders := behemothBuilders diff un ;
33891: LD_ADDR_EXP 73
33895: PUSH
33896: LD_EXP 73
33900: PUSH
33901: LD_VAR 0 1
33905: DIFF
33906: ST_TO_ADDR
// exit ;
33907: GO 33939
// end ; if un = JMM then
33909: LD_VAR 0 1
33913: PUSH
33914: LD_EXP 39
33918: EQUAL
33919: IFFALSE 33930
// begin YouLost ( JMM ) ;
33921: LD_STRING JMM
33923: PPUSH
33924: CALL_OW 104
// exit ;
33928: GO 33939
// end ; MCE_UnitDestroyed ( un ) ;
33930: LD_VAR 0 1
33934: PPUSH
33935: CALL 62455 0 1
// end ;
33939: PPOPN 1
33941: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33942: LD_VAR 0 1
33946: PPUSH
33947: LD_VAR 0 2
33951: PPUSH
33952: CALL 64789 0 2
// end ;
33956: PPOPN 2
33958: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33959: LD_VAR 0 1
33963: PPUSH
33964: CALL 63857 0 1
// end ;
33968: PPOPN 1
33970: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33971: LD_VAR 0 1
33975: PUSH
33976: LD_INT 22
33978: PUSH
33979: LD_INT 8
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 30
33988: PUSH
33989: LD_INT 2
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 23
33998: PUSH
33999: LD_INT 3
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: LIST
34010: PPUSH
34011: CALL_OW 69
34015: IN
34016: IFFALSE 34043
// begin ComUpgrade ( building ) ;
34018: LD_VAR 0 1
34022: PPUSH
34023: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34027: LD_EXP 61
34031: PPUSH
34032: LD_VAR 0 1
34036: PPUSH
34037: CALL 73210 0 2
// exit ;
34041: GO 34052
// end ; MCE_BuildingComplete ( building ) ;
34043: LD_VAR 0 1
34047: PPUSH
34048: CALL 64098 0 1
// end ;
34052: PPOPN 1
34054: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34055: LD_VAR 0 1
34059: PPUSH
34060: LD_VAR 0 2
34064: PPUSH
34065: CALL 62151 0 2
// end ;
34069: PPOPN 2
34071: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34072: LD_VAR 0 1
34076: PPUSH
34077: LD_VAR 0 2
34081: PPUSH
34082: LD_VAR 0 3
34086: PPUSH
34087: LD_VAR 0 4
34091: PPUSH
34092: LD_VAR 0 5
34096: PPUSH
34097: CALL 61771 0 5
// end ;
34101: PPOPN 5
34103: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34104: LD_VAR 0 1
34108: PPUSH
34109: LD_VAR 0 2
34113: PPUSH
34114: CALL 61361 0 2
// end ;
34118: PPOPN 2
34120: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34121: LD_VAR 0 1
34125: PPUSH
34126: LD_VAR 0 2
34130: PPUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: LD_VAR 0 4
34140: PPUSH
34141: CALL 61199 0 4
// end ;
34145: PPOPN 4
34147: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34148: LD_VAR 0 1
34152: PPUSH
34153: LD_VAR 0 2
34157: PPUSH
34158: LD_VAR 0 3
34162: PPUSH
34163: CALL 60974 0 3
// end ;
34167: PPOPN 3
34169: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34170: LD_VAR 0 1
34174: PPUSH
34175: LD_VAR 0 2
34179: PPUSH
34180: CALL 60859 0 2
// end ;
34184: PPOPN 2
34186: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34187: LD_VAR 0 1
34191: PPUSH
34192: LD_VAR 0 2
34196: PPUSH
34197: CALL 65050 0 2
// end ;
34201: PPOPN 2
34203: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34204: LD_VAR 0 1
34208: PPUSH
34209: CALL_OW 255
34213: PUSH
34214: LD_INT 4
34216: EQUAL
34217: PUSH
34218: LD_VAR 0 1
34222: PUSH
34223: LD_EXP 18
34227: PUSH
34228: LD_INT 1
34230: ARRAY
34231: IN
34232: AND
34233: PUSH
34234: LD_EXP 19
34238: AND
34239: IFFALSE 34258
// begin ComMoveXY ( driver , 61 , 93 ) ;
34241: LD_VAR 0 1
34245: PPUSH
34246: LD_INT 61
34248: PPUSH
34249: LD_INT 93
34251: PPUSH
34252: CALL_OW 111
// exit ;
34256: GO 34282
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34258: LD_VAR 0 1
34262: PPUSH
34263: LD_VAR 0 2
34267: PPUSH
34268: LD_VAR 0 3
34272: PPUSH
34273: LD_VAR 0 4
34277: PPUSH
34278: CALL 65266 0 4
// end ;
34282: PPOPN 4
34284: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34285: LD_VAR 0 1
34289: PPUSH
34290: LD_VAR 0 2
34294: PPUSH
34295: CALL 60668 0 2
// end ;
34299: PPOPN 2
34301: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34302: LD_VAR 0 1
34306: PPUSH
34307: CALL 116341 0 1
// end ; end_of_file
34311: PPOPN 1
34313: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34314: LD_EXP 15
34318: PUSH
34319: LD_INT 2
34321: EQUAL
34322: IFFALSE 34801
34324: GO 34326
34326: DISABLE
34327: LD_INT 0
34329: PPUSH
// begin time := 0 0$40 ;
34330: LD_ADDR_VAR 0 1
34334: PUSH
34335: LD_INT 1400
34337: ST_TO_ADDR
// repeat wait ( time ) ;
34338: LD_VAR 0 1
34342: PPUSH
34343: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34347: LD_INT 1
34349: PPUSH
34350: LD_INT 5
34352: PPUSH
34353: CALL_OW 12
34357: PPUSH
34358: LD_INT 106
34360: PPUSH
34361: LD_INT 150
34363: PPUSH
34364: LD_INT 19
34366: PPUSH
34367: LD_INT 1
34369: PPUSH
34370: CALL_OW 56
// time := time + 0 0$9 ;
34374: LD_ADDR_VAR 0 1
34378: PUSH
34379: LD_VAR 0 1
34383: PUSH
34384: LD_INT 315
34386: PLUS
34387: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34388: LD_INT 455
34390: PPUSH
34391: LD_INT 840
34393: PPUSH
34394: CALL_OW 12
34398: PPUSH
34399: CALL_OW 67
// if Prob ( 50 ) then
34403: LD_INT 50
34405: PPUSH
34406: CALL_OW 13
34410: IFFALSE 34439
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34412: LD_INT 1
34414: PPUSH
34415: LD_INT 5
34417: PPUSH
34418: CALL_OW 12
34422: PPUSH
34423: LD_INT 62
34425: PPUSH
34426: LD_INT 108
34428: PPUSH
34429: LD_INT 10
34431: PPUSH
34432: LD_INT 1
34434: PPUSH
34435: CALL_OW 56
// until missionStage > 4 ;
34439: LD_EXP 15
34443: PUSH
34444: LD_INT 4
34446: GREATER
34447: IFFALSE 34338
// repeat wait ( 0 0$1 ) ;
34449: LD_INT 35
34451: PPUSH
34452: CALL_OW 67
// until missionStage = 6 ;
34456: LD_EXP 15
34460: PUSH
34461: LD_INT 6
34463: EQUAL
34464: IFFALSE 34449
// time := 0 0$50 ;
34466: LD_ADDR_VAR 0 1
34470: PUSH
34471: LD_INT 1750
34473: ST_TO_ADDR
// repeat wait ( time ) ;
34474: LD_VAR 0 1
34478: PPUSH
34479: CALL_OW 67
// if Prob ( 50 ) then
34483: LD_INT 50
34485: PPUSH
34486: CALL_OW 13
34490: IFFALSE 34519
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34492: LD_INT 1
34494: PPUSH
34495: LD_INT 5
34497: PPUSH
34498: CALL_OW 12
34502: PPUSH
34503: LD_INT 106
34505: PPUSH
34506: LD_INT 89
34508: PPUSH
34509: LD_INT 45
34511: PPUSH
34512: LD_INT 1
34514: PPUSH
34515: CALL_OW 56
// time := time + 0 0$2 ;
34519: LD_ADDR_VAR 0 1
34523: PUSH
34524: LD_VAR 0 1
34528: PUSH
34529: LD_INT 70
34531: PLUS
34532: ST_TO_ADDR
// if Prob ( 30 ) then
34533: LD_INT 30
34535: PPUSH
34536: CALL_OW 13
34540: IFFALSE 34586
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34542: LD_INT 385
34544: PPUSH
34545: LD_INT 945
34547: PPUSH
34548: CALL_OW 12
34552: PPUSH
34553: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34557: LD_INT 1
34559: PPUSH
34560: LD_INT 5
34562: PPUSH
34563: CALL_OW 12
34567: PPUSH
34568: LD_INT 21
34570: PPUSH
34571: LD_INT 26
34573: PPUSH
34574: LD_INT 12
34576: PPUSH
34577: LD_INT 1
34579: PPUSH
34580: CALL_OW 56
// end else
34584: GO 34622
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34586: LD_INT 700
34588: PPUSH
34589: LD_INT 1225
34591: PPUSH
34592: CALL_OW 12
34596: PPUSH
34597: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34601: LD_INT 1
34603: PPUSH
34604: LD_INT 5
34606: PPUSH
34607: CALL_OW 12
34611: PPUSH
34612: LD_INT 16
34614: PPUSH
34615: LD_INT 1
34617: PPUSH
34618: CALL_OW 55
// end ; if Prob ( 50 ) then
34622: LD_INT 50
34624: PPUSH
34625: CALL_OW 13
34629: IFFALSE 34675
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34631: LD_INT 700
34633: PPUSH
34634: LD_INT 1050
34636: PPUSH
34637: CALL_OW 12
34641: PPUSH
34642: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34646: LD_INT 1
34648: PPUSH
34649: LD_INT 5
34651: PPUSH
34652: CALL_OW 12
34656: PPUSH
34657: LD_INT 181
34659: PPUSH
34660: LD_INT 218
34662: PPUSH
34663: LD_INT 16
34665: PPUSH
34666: LD_INT 1
34668: PPUSH
34669: CALL_OW 56
// end else
34673: GO 34711
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34675: LD_INT 350
34677: PPUSH
34678: LD_INT 525
34680: PPUSH
34681: CALL_OW 12
34685: PPUSH
34686: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34690: LD_INT 1
34692: PPUSH
34693: LD_INT 5
34695: PPUSH
34696: CALL_OW 12
34700: PPUSH
34701: LD_INT 15
34703: PPUSH
34704: LD_INT 1
34706: PPUSH
34707: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34711: LD_INT 45
34713: PUSH
34714: LD_INT 32
34716: PUSH
34717: LD_INT 25
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: LIST
34724: PUSH
34725: LD_OWVAR 67
34729: ARRAY
34730: PPUSH
34731: CALL_OW 13
34735: IFFALSE 34779
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34737: LD_INT 175
34739: PPUSH
34740: LD_INT 315
34742: PPUSH
34743: CALL_OW 12
34747: PPUSH
34748: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34752: LD_INT 1
34754: PPUSH
34755: LD_INT 5
34757: PPUSH
34758: CALL_OW 12
34762: PPUSH
34763: LD_INT 103
34765: PPUSH
34766: LD_INT 140
34768: PPUSH
34769: LD_INT 20
34771: PPUSH
34772: LD_INT 1
34774: PPUSH
34775: CALL_OW 56
// end ; if time > 1 1$20 then
34779: LD_VAR 0 1
34783: PUSH
34784: LD_INT 2800
34786: GREATER
34787: IFFALSE 34797
// time := 0 0$30 ;
34789: LD_ADDR_VAR 0 1
34793: PUSH
34794: LD_INT 1050
34796: ST_TO_ADDR
// until false ;
34797: LD_INT 0
34799: IFFALSE 34474
// end ; end_of_file
34801: PPOPN 1
34803: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34804: LD_EXP 13
34808: PUSH
34809: LD_EXP 15
34813: PUSH
34814: LD_INT 6
34816: GREATEREQUAL
34817: AND
34818: IFFALSE 34855
34820: GO 34822
34822: DISABLE
// begin enable ;
34823: ENABLE
// missionTime := missionTime + 0 0$1 ;
34824: LD_ADDR_EXP 14
34828: PUSH
34829: LD_EXP 14
34833: PUSH
34834: LD_INT 35
34836: PLUS
34837: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34838: LD_ADDR_OWVAR 47
34842: PUSH
34843: LD_STRING #Am15-1
34845: PUSH
34846: LD_EXP 14
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: ST_TO_ADDR
// end ; end_of_file
34855: END
// export function InitNature ; begin
34856: LD_INT 0
34858: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34859: LD_INT 3
34861: PPUSH
34862: LD_INT 3
34864: PPUSH
34865: LD_INT 2
34867: PPUSH
34868: LD_INT 1
34870: PPUSH
34871: LD_INT 1
34873: PPUSH
34874: LD_INT 0
34876: PPUSH
34877: LD_INT 0
34879: PPUSH
34880: LD_INT 20
34882: PPUSH
34883: LD_INT 0
34885: PPUSH
34886: CALL 98355 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 1
34898: PPUSH
34899: LD_INT 1
34901: PPUSH
34902: LD_INT 1
34904: PPUSH
34905: LD_INT 0
34907: PPUSH
34908: LD_INT 0
34910: PPUSH
34911: LD_INT 21
34913: PPUSH
34914: LD_INT 0
34916: PPUSH
34917: CALL 98355 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34921: LD_INT 4
34923: PPUSH
34924: LD_INT 1
34926: PPUSH
34927: LD_INT 2
34929: PPUSH
34930: LD_INT 4
34932: PPUSH
34933: LD_INT 2
34935: PPUSH
34936: LD_INT 1
34938: PPUSH
34939: LD_INT 0
34941: PPUSH
34942: LD_INT 22
34944: PPUSH
34945: LD_INT 0
34947: PPUSH
34948: CALL 98355 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34952: LD_INT 0
34954: PPUSH
34955: LD_INT 0
34957: PPUSH
34958: LD_INT 0
34960: PPUSH
34961: LD_INT 0
34963: PPUSH
34964: LD_INT 0
34966: PPUSH
34967: LD_INT 0
34969: PPUSH
34970: LD_INT 9
34972: PPUSH
34973: LD_INT 0
34975: PPUSH
34976: LD_INT 23
34978: PPUSH
34979: CALL 98355 0 9
// end ; end_of_file
34983: LD_VAR 0 1
34987: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
34988: LD_INT 0
34990: PPUSH
// ar_miner := 81 ;
34991: LD_ADDR_EXP 102
34995: PUSH
34996: LD_INT 81
34998: ST_TO_ADDR
// ar_crane := 88 ;
34999: LD_ADDR_EXP 101
35003: PUSH
35004: LD_INT 88
35006: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35007: LD_ADDR_EXP 96
35011: PUSH
35012: LD_INT 89
35014: ST_TO_ADDR
// us_hack := 99 ;
35015: LD_ADDR_EXP 97
35019: PUSH
35020: LD_INT 99
35022: ST_TO_ADDR
// us_artillery := 97 ;
35023: LD_ADDR_EXP 98
35027: PUSH
35028: LD_INT 97
35030: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35031: LD_ADDR_EXP 99
35035: PUSH
35036: LD_INT 91
35038: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
35039: LD_ADDR_EXP 100
35043: PUSH
35044: LD_INT 92
35046: ST_TO_ADDR
// ru_radar := 98 ;
35047: LD_ADDR_EXP 95
35051: PUSH
35052: LD_INT 98
35054: ST_TO_ADDR
// tech_Artillery := 80 ;
35055: LD_ADDR_EXP 103
35059: PUSH
35060: LD_INT 80
35062: ST_TO_ADDR
// tech_RadMat := 81 ;
35063: LD_ADDR_EXP 104
35067: PUSH
35068: LD_INT 81
35070: ST_TO_ADDR
// tech_BasicTools := 82 ;
35071: LD_ADDR_EXP 105
35075: PUSH
35076: LD_INT 82
35078: ST_TO_ADDR
// tech_Cargo := 83 ;
35079: LD_ADDR_EXP 106
35083: PUSH
35084: LD_INT 83
35086: ST_TO_ADDR
// tech_Track := 84 ;
35087: LD_ADDR_EXP 107
35091: PUSH
35092: LD_INT 84
35094: ST_TO_ADDR
// tech_Crane := 85 ;
35095: LD_ADDR_EXP 108
35099: PUSH
35100: LD_INT 85
35102: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35103: LD_ADDR_EXP 109
35107: PUSH
35108: LD_INT 86
35110: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35111: LD_ADDR_EXP 110
35115: PUSH
35116: LD_INT 87
35118: ST_TO_ADDR
// class_mastodont := 31 ;
35119: LD_ADDR_EXP 111
35123: PUSH
35124: LD_INT 31
35126: ST_TO_ADDR
// class_horse := 21 ;
35127: LD_ADDR_EXP 112
35131: PUSH
35132: LD_INT 21
35134: ST_TO_ADDR
// end ;
35135: LD_VAR 0 1
35139: RET
// every 1 do
35140: GO 35142
35142: DISABLE
// InitGlobalVariables ; end_of_file
35143: CALL 34988 0 0
35147: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35148: LD_INT 0
35150: PPUSH
35151: PPUSH
// skirmish := false ;
35152: LD_ADDR_EXP 113
35156: PUSH
35157: LD_INT 0
35159: ST_TO_ADDR
// debug_mc := false ;
35160: LD_ADDR_EXP 114
35164: PUSH
35165: LD_INT 0
35167: ST_TO_ADDR
// mc_bases := [ ] ;
35168: LD_ADDR_EXP 115
35172: PUSH
35173: EMPTY
35174: ST_TO_ADDR
// mc_sides := [ ] ;
35175: LD_ADDR_EXP 141
35179: PUSH
35180: EMPTY
35181: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35182: LD_ADDR_EXP 116
35186: PUSH
35187: EMPTY
35188: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35189: LD_ADDR_EXP 117
35193: PUSH
35194: EMPTY
35195: ST_TO_ADDR
// mc_need_heal := [ ] ;
35196: LD_ADDR_EXP 118
35200: PUSH
35201: EMPTY
35202: ST_TO_ADDR
// mc_healers := [ ] ;
35203: LD_ADDR_EXP 119
35207: PUSH
35208: EMPTY
35209: ST_TO_ADDR
// mc_build_list := [ ] ;
35210: LD_ADDR_EXP 120
35214: PUSH
35215: EMPTY
35216: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35217: LD_ADDR_EXP 147
35221: PUSH
35222: EMPTY
35223: ST_TO_ADDR
// mc_builders := [ ] ;
35224: LD_ADDR_EXP 121
35228: PUSH
35229: EMPTY
35230: ST_TO_ADDR
// mc_construct_list := [ ] ;
35231: LD_ADDR_EXP 122
35235: PUSH
35236: EMPTY
35237: ST_TO_ADDR
// mc_turret_list := [ ] ;
35238: LD_ADDR_EXP 123
35242: PUSH
35243: EMPTY
35244: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35245: LD_ADDR_EXP 124
35249: PUSH
35250: EMPTY
35251: ST_TO_ADDR
// mc_miners := [ ] ;
35252: LD_ADDR_EXP 129
35256: PUSH
35257: EMPTY
35258: ST_TO_ADDR
// mc_mines := [ ] ;
35259: LD_ADDR_EXP 128
35263: PUSH
35264: EMPTY
35265: ST_TO_ADDR
// mc_minefields := [ ] ;
35266: LD_ADDR_EXP 130
35270: PUSH
35271: EMPTY
35272: ST_TO_ADDR
// mc_crates := [ ] ;
35273: LD_ADDR_EXP 131
35277: PUSH
35278: EMPTY
35279: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35280: LD_ADDR_EXP 132
35284: PUSH
35285: EMPTY
35286: ST_TO_ADDR
// mc_crates_area := [ ] ;
35287: LD_ADDR_EXP 133
35291: PUSH
35292: EMPTY
35293: ST_TO_ADDR
// mc_vehicles := [ ] ;
35294: LD_ADDR_EXP 134
35298: PUSH
35299: EMPTY
35300: ST_TO_ADDR
// mc_attack := [ ] ;
35301: LD_ADDR_EXP 135
35305: PUSH
35306: EMPTY
35307: ST_TO_ADDR
// mc_produce := [ ] ;
35308: LD_ADDR_EXP 136
35312: PUSH
35313: EMPTY
35314: ST_TO_ADDR
// mc_defender := [ ] ;
35315: LD_ADDR_EXP 137
35319: PUSH
35320: EMPTY
35321: ST_TO_ADDR
// mc_parking := [ ] ;
35322: LD_ADDR_EXP 139
35326: PUSH
35327: EMPTY
35328: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35329: LD_ADDR_EXP 125
35333: PUSH
35334: EMPTY
35335: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35336: LD_ADDR_EXP 127
35340: PUSH
35341: EMPTY
35342: ST_TO_ADDR
// mc_scan := [ ] ;
35343: LD_ADDR_EXP 138
35347: PUSH
35348: EMPTY
35349: ST_TO_ADDR
// mc_scan_area := [ ] ;
35350: LD_ADDR_EXP 140
35354: PUSH
35355: EMPTY
35356: ST_TO_ADDR
// mc_tech := [ ] ;
35357: LD_ADDR_EXP 142
35361: PUSH
35362: EMPTY
35363: ST_TO_ADDR
// mc_class := [ ] ;
35364: LD_ADDR_EXP 156
35368: PUSH
35369: EMPTY
35370: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35371: LD_ADDR_EXP 157
35375: PUSH
35376: EMPTY
35377: ST_TO_ADDR
// mc_is_defending := [ ] ;
35378: LD_ADDR_EXP 158
35382: PUSH
35383: EMPTY
35384: ST_TO_ADDR
// end ;
35385: LD_VAR 0 1
35389: RET
// export function MC_Kill ( base ) ; begin
35390: LD_INT 0
35392: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35393: LD_ADDR_EXP 115
35397: PUSH
35398: LD_EXP 115
35402: PPUSH
35403: LD_VAR 0 1
35407: PPUSH
35408: EMPTY
35409: PPUSH
35410: CALL_OW 1
35414: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35415: LD_ADDR_EXP 116
35419: PUSH
35420: LD_EXP 116
35424: PPUSH
35425: LD_VAR 0 1
35429: PPUSH
35430: EMPTY
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35437: LD_ADDR_EXP 117
35441: PUSH
35442: LD_EXP 117
35446: PPUSH
35447: LD_VAR 0 1
35451: PPUSH
35452: EMPTY
35453: PPUSH
35454: CALL_OW 1
35458: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35459: LD_ADDR_EXP 118
35463: PUSH
35464: LD_EXP 118
35468: PPUSH
35469: LD_VAR 0 1
35473: PPUSH
35474: EMPTY
35475: PPUSH
35476: CALL_OW 1
35480: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35481: LD_ADDR_EXP 119
35485: PUSH
35486: LD_EXP 119
35490: PPUSH
35491: LD_VAR 0 1
35495: PPUSH
35496: EMPTY
35497: PPUSH
35498: CALL_OW 1
35502: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35503: LD_ADDR_EXP 120
35507: PUSH
35508: LD_EXP 120
35512: PPUSH
35513: LD_VAR 0 1
35517: PPUSH
35518: EMPTY
35519: PPUSH
35520: CALL_OW 1
35524: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35525: LD_ADDR_EXP 121
35529: PUSH
35530: LD_EXP 121
35534: PPUSH
35535: LD_VAR 0 1
35539: PPUSH
35540: EMPTY
35541: PPUSH
35542: CALL_OW 1
35546: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35547: LD_ADDR_EXP 122
35551: PUSH
35552: LD_EXP 122
35556: PPUSH
35557: LD_VAR 0 1
35561: PPUSH
35562: EMPTY
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35569: LD_ADDR_EXP 123
35573: PUSH
35574: LD_EXP 123
35578: PPUSH
35579: LD_VAR 0 1
35583: PPUSH
35584: EMPTY
35585: PPUSH
35586: CALL_OW 1
35590: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35591: LD_ADDR_EXP 124
35595: PUSH
35596: LD_EXP 124
35600: PPUSH
35601: LD_VAR 0 1
35605: PPUSH
35606: EMPTY
35607: PPUSH
35608: CALL_OW 1
35612: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35613: LD_ADDR_EXP 125
35617: PUSH
35618: LD_EXP 125
35622: PPUSH
35623: LD_VAR 0 1
35627: PPUSH
35628: EMPTY
35629: PPUSH
35630: CALL_OW 1
35634: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35635: LD_ADDR_EXP 126
35639: PUSH
35640: LD_EXP 126
35644: PPUSH
35645: LD_VAR 0 1
35649: PPUSH
35650: LD_INT 0
35652: PPUSH
35653: CALL_OW 1
35657: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35658: LD_ADDR_EXP 127
35662: PUSH
35663: LD_EXP 127
35667: PPUSH
35668: LD_VAR 0 1
35672: PPUSH
35673: EMPTY
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35680: LD_ADDR_EXP 128
35684: PUSH
35685: LD_EXP 128
35689: PPUSH
35690: LD_VAR 0 1
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35702: LD_ADDR_EXP 129
35706: PUSH
35707: LD_EXP 129
35711: PPUSH
35712: LD_VAR 0 1
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35724: LD_ADDR_EXP 130
35728: PUSH
35729: LD_EXP 130
35733: PPUSH
35734: LD_VAR 0 1
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35746: LD_ADDR_EXP 131
35750: PUSH
35751: LD_EXP 131
35755: PPUSH
35756: LD_VAR 0 1
35760: PPUSH
35761: EMPTY
35762: PPUSH
35763: CALL_OW 1
35767: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35768: LD_ADDR_EXP 132
35772: PUSH
35773: LD_EXP 132
35777: PPUSH
35778: LD_VAR 0 1
35782: PPUSH
35783: EMPTY
35784: PPUSH
35785: CALL_OW 1
35789: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35790: LD_ADDR_EXP 133
35794: PUSH
35795: LD_EXP 133
35799: PPUSH
35800: LD_VAR 0 1
35804: PPUSH
35805: EMPTY
35806: PPUSH
35807: CALL_OW 1
35811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35812: LD_ADDR_EXP 134
35816: PUSH
35817: LD_EXP 134
35821: PPUSH
35822: LD_VAR 0 1
35826: PPUSH
35827: EMPTY
35828: PPUSH
35829: CALL_OW 1
35833: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35834: LD_ADDR_EXP 135
35838: PUSH
35839: LD_EXP 135
35843: PPUSH
35844: LD_VAR 0 1
35848: PPUSH
35849: EMPTY
35850: PPUSH
35851: CALL_OW 1
35855: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35856: LD_ADDR_EXP 136
35860: PUSH
35861: LD_EXP 136
35865: PPUSH
35866: LD_VAR 0 1
35870: PPUSH
35871: EMPTY
35872: PPUSH
35873: CALL_OW 1
35877: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35878: LD_ADDR_EXP 137
35882: PUSH
35883: LD_EXP 137
35887: PPUSH
35888: LD_VAR 0 1
35892: PPUSH
35893: EMPTY
35894: PPUSH
35895: CALL_OW 1
35899: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35900: LD_ADDR_EXP 138
35904: PUSH
35905: LD_EXP 138
35909: PPUSH
35910: LD_VAR 0 1
35914: PPUSH
35915: EMPTY
35916: PPUSH
35917: CALL_OW 1
35921: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35922: LD_ADDR_EXP 139
35926: PUSH
35927: LD_EXP 139
35931: PPUSH
35932: LD_VAR 0 1
35936: PPUSH
35937: EMPTY
35938: PPUSH
35939: CALL_OW 1
35943: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35944: LD_ADDR_EXP 140
35948: PUSH
35949: LD_EXP 140
35953: PPUSH
35954: LD_VAR 0 1
35958: PPUSH
35959: EMPTY
35960: PPUSH
35961: CALL_OW 1
35965: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35966: LD_ADDR_EXP 142
35970: PUSH
35971: LD_EXP 142
35975: PPUSH
35976: LD_VAR 0 1
35980: PPUSH
35981: EMPTY
35982: PPUSH
35983: CALL_OW 1
35987: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35988: LD_ADDR_EXP 144
35992: PUSH
35993: LD_EXP 144
35997: PPUSH
35998: LD_VAR 0 1
36002: PPUSH
36003: EMPTY
36004: PPUSH
36005: CALL_OW 1
36009: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36010: LD_ADDR_EXP 145
36014: PUSH
36015: LD_EXP 145
36019: PPUSH
36020: LD_VAR 0 1
36024: PPUSH
36025: EMPTY
36026: PPUSH
36027: CALL_OW 1
36031: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36032: LD_ADDR_EXP 146
36036: PUSH
36037: LD_EXP 146
36041: PPUSH
36042: LD_VAR 0 1
36046: PPUSH
36047: EMPTY
36048: PPUSH
36049: CALL_OW 1
36053: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36054: LD_ADDR_EXP 147
36058: PUSH
36059: LD_EXP 147
36063: PPUSH
36064: LD_VAR 0 1
36068: PPUSH
36069: EMPTY
36070: PPUSH
36071: CALL_OW 1
36075: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36076: LD_ADDR_EXP 148
36080: PUSH
36081: LD_EXP 148
36085: PPUSH
36086: LD_VAR 0 1
36090: PPUSH
36091: EMPTY
36092: PPUSH
36093: CALL_OW 1
36097: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36098: LD_ADDR_EXP 149
36102: PUSH
36103: LD_EXP 149
36107: PPUSH
36108: LD_VAR 0 1
36112: PPUSH
36113: EMPTY
36114: PPUSH
36115: CALL_OW 1
36119: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36120: LD_ADDR_EXP 150
36124: PUSH
36125: LD_EXP 150
36129: PPUSH
36130: LD_VAR 0 1
36134: PPUSH
36135: EMPTY
36136: PPUSH
36137: CALL_OW 1
36141: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36142: LD_ADDR_EXP 151
36146: PUSH
36147: LD_EXP 151
36151: PPUSH
36152: LD_VAR 0 1
36156: PPUSH
36157: EMPTY
36158: PPUSH
36159: CALL_OW 1
36163: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36164: LD_ADDR_EXP 152
36168: PUSH
36169: LD_EXP 152
36173: PPUSH
36174: LD_VAR 0 1
36178: PPUSH
36179: EMPTY
36180: PPUSH
36181: CALL_OW 1
36185: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36186: LD_ADDR_EXP 153
36190: PUSH
36191: LD_EXP 153
36195: PPUSH
36196: LD_VAR 0 1
36200: PPUSH
36201: EMPTY
36202: PPUSH
36203: CALL_OW 1
36207: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36208: LD_ADDR_EXP 154
36212: PUSH
36213: LD_EXP 154
36217: PPUSH
36218: LD_VAR 0 1
36222: PPUSH
36223: EMPTY
36224: PPUSH
36225: CALL_OW 1
36229: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36230: LD_ADDR_EXP 155
36234: PUSH
36235: LD_EXP 155
36239: PPUSH
36240: LD_VAR 0 1
36244: PPUSH
36245: EMPTY
36246: PPUSH
36247: CALL_OW 1
36251: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36252: LD_ADDR_EXP 156
36256: PUSH
36257: LD_EXP 156
36261: PPUSH
36262: LD_VAR 0 1
36266: PPUSH
36267: EMPTY
36268: PPUSH
36269: CALL_OW 1
36273: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36274: LD_ADDR_EXP 157
36278: PUSH
36279: LD_EXP 157
36283: PPUSH
36284: LD_VAR 0 1
36288: PPUSH
36289: LD_INT 0
36291: PPUSH
36292: CALL_OW 1
36296: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36297: LD_ADDR_EXP 158
36301: PUSH
36302: LD_EXP 158
36306: PPUSH
36307: LD_VAR 0 1
36311: PPUSH
36312: LD_INT 0
36314: PPUSH
36315: CALL_OW 1
36319: ST_TO_ADDR
// end ;
36320: LD_VAR 0 2
36324: RET
// export function MC_Add ( side , units ) ; var base ; begin
36325: LD_INT 0
36327: PPUSH
36328: PPUSH
// base := mc_bases + 1 ;
36329: LD_ADDR_VAR 0 4
36333: PUSH
36334: LD_EXP 115
36338: PUSH
36339: LD_INT 1
36341: PLUS
36342: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36343: LD_ADDR_EXP 141
36347: PUSH
36348: LD_EXP 141
36352: PPUSH
36353: LD_VAR 0 4
36357: PPUSH
36358: LD_VAR 0 1
36362: PPUSH
36363: CALL_OW 1
36367: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36368: LD_ADDR_EXP 115
36372: PUSH
36373: LD_EXP 115
36377: PPUSH
36378: LD_VAR 0 4
36382: PPUSH
36383: LD_VAR 0 2
36387: PPUSH
36388: CALL_OW 1
36392: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36393: LD_ADDR_EXP 116
36397: PUSH
36398: LD_EXP 116
36402: PPUSH
36403: LD_VAR 0 4
36407: PPUSH
36408: EMPTY
36409: PPUSH
36410: CALL_OW 1
36414: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36415: LD_ADDR_EXP 117
36419: PUSH
36420: LD_EXP 117
36424: PPUSH
36425: LD_VAR 0 4
36429: PPUSH
36430: EMPTY
36431: PPUSH
36432: CALL_OW 1
36436: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36437: LD_ADDR_EXP 118
36441: PUSH
36442: LD_EXP 118
36446: PPUSH
36447: LD_VAR 0 4
36451: PPUSH
36452: EMPTY
36453: PPUSH
36454: CALL_OW 1
36458: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36459: LD_ADDR_EXP 119
36463: PUSH
36464: LD_EXP 119
36468: PPUSH
36469: LD_VAR 0 4
36473: PPUSH
36474: EMPTY
36475: PPUSH
36476: CALL_OW 1
36480: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36481: LD_ADDR_EXP 120
36485: PUSH
36486: LD_EXP 120
36490: PPUSH
36491: LD_VAR 0 4
36495: PPUSH
36496: EMPTY
36497: PPUSH
36498: CALL_OW 1
36502: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36503: LD_ADDR_EXP 121
36507: PUSH
36508: LD_EXP 121
36512: PPUSH
36513: LD_VAR 0 4
36517: PPUSH
36518: EMPTY
36519: PPUSH
36520: CALL_OW 1
36524: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36525: LD_ADDR_EXP 122
36529: PUSH
36530: LD_EXP 122
36534: PPUSH
36535: LD_VAR 0 4
36539: PPUSH
36540: EMPTY
36541: PPUSH
36542: CALL_OW 1
36546: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36547: LD_ADDR_EXP 123
36551: PUSH
36552: LD_EXP 123
36556: PPUSH
36557: LD_VAR 0 4
36561: PPUSH
36562: EMPTY
36563: PPUSH
36564: CALL_OW 1
36568: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36569: LD_ADDR_EXP 124
36573: PUSH
36574: LD_EXP 124
36578: PPUSH
36579: LD_VAR 0 4
36583: PPUSH
36584: EMPTY
36585: PPUSH
36586: CALL_OW 1
36590: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36591: LD_ADDR_EXP 125
36595: PUSH
36596: LD_EXP 125
36600: PPUSH
36601: LD_VAR 0 4
36605: PPUSH
36606: EMPTY
36607: PPUSH
36608: CALL_OW 1
36612: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36613: LD_ADDR_EXP 126
36617: PUSH
36618: LD_EXP 126
36622: PPUSH
36623: LD_VAR 0 4
36627: PPUSH
36628: LD_INT 0
36630: PPUSH
36631: CALL_OW 1
36635: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36636: LD_ADDR_EXP 127
36640: PUSH
36641: LD_EXP 127
36645: PPUSH
36646: LD_VAR 0 4
36650: PPUSH
36651: EMPTY
36652: PPUSH
36653: CALL_OW 1
36657: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36658: LD_ADDR_EXP 128
36662: PUSH
36663: LD_EXP 128
36667: PPUSH
36668: LD_VAR 0 4
36672: PPUSH
36673: EMPTY
36674: PPUSH
36675: CALL_OW 1
36679: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36680: LD_ADDR_EXP 129
36684: PUSH
36685: LD_EXP 129
36689: PPUSH
36690: LD_VAR 0 4
36694: PPUSH
36695: EMPTY
36696: PPUSH
36697: CALL_OW 1
36701: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36702: LD_ADDR_EXP 130
36706: PUSH
36707: LD_EXP 130
36711: PPUSH
36712: LD_VAR 0 4
36716: PPUSH
36717: EMPTY
36718: PPUSH
36719: CALL_OW 1
36723: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36724: LD_ADDR_EXP 131
36728: PUSH
36729: LD_EXP 131
36733: PPUSH
36734: LD_VAR 0 4
36738: PPUSH
36739: EMPTY
36740: PPUSH
36741: CALL_OW 1
36745: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36746: LD_ADDR_EXP 132
36750: PUSH
36751: LD_EXP 132
36755: PPUSH
36756: LD_VAR 0 4
36760: PPUSH
36761: EMPTY
36762: PPUSH
36763: CALL_OW 1
36767: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36768: LD_ADDR_EXP 133
36772: PUSH
36773: LD_EXP 133
36777: PPUSH
36778: LD_VAR 0 4
36782: PPUSH
36783: EMPTY
36784: PPUSH
36785: CALL_OW 1
36789: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36790: LD_ADDR_EXP 134
36794: PUSH
36795: LD_EXP 134
36799: PPUSH
36800: LD_VAR 0 4
36804: PPUSH
36805: EMPTY
36806: PPUSH
36807: CALL_OW 1
36811: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36812: LD_ADDR_EXP 135
36816: PUSH
36817: LD_EXP 135
36821: PPUSH
36822: LD_VAR 0 4
36826: PPUSH
36827: EMPTY
36828: PPUSH
36829: CALL_OW 1
36833: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36834: LD_ADDR_EXP 136
36838: PUSH
36839: LD_EXP 136
36843: PPUSH
36844: LD_VAR 0 4
36848: PPUSH
36849: EMPTY
36850: PPUSH
36851: CALL_OW 1
36855: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36856: LD_ADDR_EXP 137
36860: PUSH
36861: LD_EXP 137
36865: PPUSH
36866: LD_VAR 0 4
36870: PPUSH
36871: EMPTY
36872: PPUSH
36873: CALL_OW 1
36877: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36878: LD_ADDR_EXP 138
36882: PUSH
36883: LD_EXP 138
36887: PPUSH
36888: LD_VAR 0 4
36892: PPUSH
36893: EMPTY
36894: PPUSH
36895: CALL_OW 1
36899: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36900: LD_ADDR_EXP 139
36904: PUSH
36905: LD_EXP 139
36909: PPUSH
36910: LD_VAR 0 4
36914: PPUSH
36915: EMPTY
36916: PPUSH
36917: CALL_OW 1
36921: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36922: LD_ADDR_EXP 140
36926: PUSH
36927: LD_EXP 140
36931: PPUSH
36932: LD_VAR 0 4
36936: PPUSH
36937: EMPTY
36938: PPUSH
36939: CALL_OW 1
36943: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36944: LD_ADDR_EXP 142
36948: PUSH
36949: LD_EXP 142
36953: PPUSH
36954: LD_VAR 0 4
36958: PPUSH
36959: EMPTY
36960: PPUSH
36961: CALL_OW 1
36965: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36966: LD_ADDR_EXP 144
36970: PUSH
36971: LD_EXP 144
36975: PPUSH
36976: LD_VAR 0 4
36980: PPUSH
36981: EMPTY
36982: PPUSH
36983: CALL_OW 1
36987: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36988: LD_ADDR_EXP 145
36992: PUSH
36993: LD_EXP 145
36997: PPUSH
36998: LD_VAR 0 4
37002: PPUSH
37003: EMPTY
37004: PPUSH
37005: CALL_OW 1
37009: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37010: LD_ADDR_EXP 146
37014: PUSH
37015: LD_EXP 146
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: EMPTY
37026: PPUSH
37027: CALL_OW 1
37031: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37032: LD_ADDR_EXP 147
37036: PUSH
37037: LD_EXP 147
37041: PPUSH
37042: LD_VAR 0 4
37046: PPUSH
37047: EMPTY
37048: PPUSH
37049: CALL_OW 1
37053: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37054: LD_ADDR_EXP 148
37058: PUSH
37059: LD_EXP 148
37063: PPUSH
37064: LD_VAR 0 4
37068: PPUSH
37069: EMPTY
37070: PPUSH
37071: CALL_OW 1
37075: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37076: LD_ADDR_EXP 149
37080: PUSH
37081: LD_EXP 149
37085: PPUSH
37086: LD_VAR 0 4
37090: PPUSH
37091: EMPTY
37092: PPUSH
37093: CALL_OW 1
37097: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37098: LD_ADDR_EXP 150
37102: PUSH
37103: LD_EXP 150
37107: PPUSH
37108: LD_VAR 0 4
37112: PPUSH
37113: EMPTY
37114: PPUSH
37115: CALL_OW 1
37119: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37120: LD_ADDR_EXP 151
37124: PUSH
37125: LD_EXP 151
37129: PPUSH
37130: LD_VAR 0 4
37134: PPUSH
37135: EMPTY
37136: PPUSH
37137: CALL_OW 1
37141: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37142: LD_ADDR_EXP 152
37146: PUSH
37147: LD_EXP 152
37151: PPUSH
37152: LD_VAR 0 4
37156: PPUSH
37157: EMPTY
37158: PPUSH
37159: CALL_OW 1
37163: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37164: LD_ADDR_EXP 153
37168: PUSH
37169: LD_EXP 153
37173: PPUSH
37174: LD_VAR 0 4
37178: PPUSH
37179: EMPTY
37180: PPUSH
37181: CALL_OW 1
37185: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37186: LD_ADDR_EXP 154
37190: PUSH
37191: LD_EXP 154
37195: PPUSH
37196: LD_VAR 0 4
37200: PPUSH
37201: EMPTY
37202: PPUSH
37203: CALL_OW 1
37207: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37208: LD_ADDR_EXP 155
37212: PUSH
37213: LD_EXP 155
37217: PPUSH
37218: LD_VAR 0 4
37222: PPUSH
37223: EMPTY
37224: PPUSH
37225: CALL_OW 1
37229: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37230: LD_ADDR_EXP 156
37234: PUSH
37235: LD_EXP 156
37239: PPUSH
37240: LD_VAR 0 4
37244: PPUSH
37245: EMPTY
37246: PPUSH
37247: CALL_OW 1
37251: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37252: LD_ADDR_EXP 157
37256: PUSH
37257: LD_EXP 157
37261: PPUSH
37262: LD_VAR 0 4
37266: PPUSH
37267: LD_INT 0
37269: PPUSH
37270: CALL_OW 1
37274: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37275: LD_ADDR_EXP 158
37279: PUSH
37280: LD_EXP 158
37284: PPUSH
37285: LD_VAR 0 4
37289: PPUSH
37290: LD_INT 0
37292: PPUSH
37293: CALL_OW 1
37297: ST_TO_ADDR
// result := base ;
37298: LD_ADDR_VAR 0 3
37302: PUSH
37303: LD_VAR 0 4
37307: ST_TO_ADDR
// end ;
37308: LD_VAR 0 3
37312: RET
// export function MC_Start ( ) ; var i ; begin
37313: LD_INT 0
37315: PPUSH
37316: PPUSH
// for i = 1 to mc_bases do
37317: LD_ADDR_VAR 0 2
37321: PUSH
37322: DOUBLE
37323: LD_INT 1
37325: DEC
37326: ST_TO_ADDR
37327: LD_EXP 115
37331: PUSH
37332: FOR_TO
37333: IFFALSE 38410
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37335: LD_ADDR_EXP 115
37339: PUSH
37340: LD_EXP 115
37344: PPUSH
37345: LD_VAR 0 2
37349: PPUSH
37350: LD_EXP 115
37354: PUSH
37355: LD_VAR 0 2
37359: ARRAY
37360: PUSH
37361: LD_INT 0
37363: DIFF
37364: PPUSH
37365: CALL_OW 1
37369: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37370: LD_ADDR_EXP 116
37374: PUSH
37375: LD_EXP 116
37379: PPUSH
37380: LD_VAR 0 2
37384: PPUSH
37385: EMPTY
37386: PPUSH
37387: CALL_OW 1
37391: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37392: LD_ADDR_EXP 117
37396: PUSH
37397: LD_EXP 117
37401: PPUSH
37402: LD_VAR 0 2
37406: PPUSH
37407: EMPTY
37408: PPUSH
37409: CALL_OW 1
37413: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37414: LD_ADDR_EXP 118
37418: PUSH
37419: LD_EXP 118
37423: PPUSH
37424: LD_VAR 0 2
37428: PPUSH
37429: EMPTY
37430: PPUSH
37431: CALL_OW 1
37435: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37436: LD_ADDR_EXP 119
37440: PUSH
37441: LD_EXP 119
37445: PPUSH
37446: LD_VAR 0 2
37450: PPUSH
37451: EMPTY
37452: PUSH
37453: EMPTY
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PPUSH
37459: CALL_OW 1
37463: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37464: LD_ADDR_EXP 120
37468: PUSH
37469: LD_EXP 120
37473: PPUSH
37474: LD_VAR 0 2
37478: PPUSH
37479: EMPTY
37480: PPUSH
37481: CALL_OW 1
37485: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37486: LD_ADDR_EXP 147
37490: PUSH
37491: LD_EXP 147
37495: PPUSH
37496: LD_VAR 0 2
37500: PPUSH
37501: EMPTY
37502: PPUSH
37503: CALL_OW 1
37507: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37508: LD_ADDR_EXP 121
37512: PUSH
37513: LD_EXP 121
37517: PPUSH
37518: LD_VAR 0 2
37522: PPUSH
37523: EMPTY
37524: PPUSH
37525: CALL_OW 1
37529: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37530: LD_ADDR_EXP 122
37534: PUSH
37535: LD_EXP 122
37539: PPUSH
37540: LD_VAR 0 2
37544: PPUSH
37545: EMPTY
37546: PPUSH
37547: CALL_OW 1
37551: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37552: LD_ADDR_EXP 123
37556: PUSH
37557: LD_EXP 123
37561: PPUSH
37562: LD_VAR 0 2
37566: PPUSH
37567: LD_EXP 115
37571: PUSH
37572: LD_VAR 0 2
37576: ARRAY
37577: PPUSH
37578: LD_INT 2
37580: PUSH
37581: LD_INT 30
37583: PUSH
37584: LD_INT 32
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 30
37593: PUSH
37594: LD_INT 33
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: LIST
37605: PPUSH
37606: CALL_OW 72
37610: PPUSH
37611: CALL_OW 1
37615: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37616: LD_ADDR_EXP 124
37620: PUSH
37621: LD_EXP 124
37625: PPUSH
37626: LD_VAR 0 2
37630: PPUSH
37631: LD_EXP 115
37635: PUSH
37636: LD_VAR 0 2
37640: ARRAY
37641: PPUSH
37642: LD_INT 2
37644: PUSH
37645: LD_INT 30
37647: PUSH
37648: LD_INT 32
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 30
37657: PUSH
37658: LD_INT 31
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 58
37672: PUSH
37673: EMPTY
37674: LIST
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PPUSH
37680: CALL_OW 72
37684: PPUSH
37685: CALL_OW 1
37689: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37690: LD_ADDR_EXP 125
37694: PUSH
37695: LD_EXP 125
37699: PPUSH
37700: LD_VAR 0 2
37704: PPUSH
37705: EMPTY
37706: PPUSH
37707: CALL_OW 1
37711: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37712: LD_ADDR_EXP 129
37716: PUSH
37717: LD_EXP 129
37721: PPUSH
37722: LD_VAR 0 2
37726: PPUSH
37727: EMPTY
37728: PPUSH
37729: CALL_OW 1
37733: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37734: LD_ADDR_EXP 128
37738: PUSH
37739: LD_EXP 128
37743: PPUSH
37744: LD_VAR 0 2
37748: PPUSH
37749: EMPTY
37750: PPUSH
37751: CALL_OW 1
37755: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37756: LD_ADDR_EXP 130
37760: PUSH
37761: LD_EXP 130
37765: PPUSH
37766: LD_VAR 0 2
37770: PPUSH
37771: EMPTY
37772: PPUSH
37773: CALL_OW 1
37777: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37778: LD_ADDR_EXP 131
37782: PUSH
37783: LD_EXP 131
37787: PPUSH
37788: LD_VAR 0 2
37792: PPUSH
37793: EMPTY
37794: PPUSH
37795: CALL_OW 1
37799: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37800: LD_ADDR_EXP 132
37804: PUSH
37805: LD_EXP 132
37809: PPUSH
37810: LD_VAR 0 2
37814: PPUSH
37815: EMPTY
37816: PPUSH
37817: CALL_OW 1
37821: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37822: LD_ADDR_EXP 133
37826: PUSH
37827: LD_EXP 133
37831: PPUSH
37832: LD_VAR 0 2
37836: PPUSH
37837: EMPTY
37838: PPUSH
37839: CALL_OW 1
37843: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37844: LD_ADDR_EXP 134
37848: PUSH
37849: LD_EXP 134
37853: PPUSH
37854: LD_VAR 0 2
37858: PPUSH
37859: EMPTY
37860: PPUSH
37861: CALL_OW 1
37865: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37866: LD_ADDR_EXP 135
37870: PUSH
37871: LD_EXP 135
37875: PPUSH
37876: LD_VAR 0 2
37880: PPUSH
37881: EMPTY
37882: PPUSH
37883: CALL_OW 1
37887: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37888: LD_ADDR_EXP 136
37892: PUSH
37893: LD_EXP 136
37897: PPUSH
37898: LD_VAR 0 2
37902: PPUSH
37903: EMPTY
37904: PPUSH
37905: CALL_OW 1
37909: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37910: LD_ADDR_EXP 137
37914: PUSH
37915: LD_EXP 137
37919: PPUSH
37920: LD_VAR 0 2
37924: PPUSH
37925: EMPTY
37926: PPUSH
37927: CALL_OW 1
37931: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37932: LD_ADDR_EXP 126
37936: PUSH
37937: LD_EXP 126
37941: PPUSH
37942: LD_VAR 0 2
37946: PPUSH
37947: LD_INT 0
37949: PPUSH
37950: CALL_OW 1
37954: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37955: LD_ADDR_EXP 139
37959: PUSH
37960: LD_EXP 139
37964: PPUSH
37965: LD_VAR 0 2
37969: PPUSH
37970: LD_INT 0
37972: PPUSH
37973: CALL_OW 1
37977: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37978: LD_ADDR_EXP 127
37982: PUSH
37983: LD_EXP 127
37987: PPUSH
37988: LD_VAR 0 2
37992: PPUSH
37993: EMPTY
37994: PPUSH
37995: CALL_OW 1
37999: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38000: LD_ADDR_EXP 138
38004: PUSH
38005: LD_EXP 138
38009: PPUSH
38010: LD_VAR 0 2
38014: PPUSH
38015: LD_INT 0
38017: PPUSH
38018: CALL_OW 1
38022: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38023: LD_ADDR_EXP 140
38027: PUSH
38028: LD_EXP 140
38032: PPUSH
38033: LD_VAR 0 2
38037: PPUSH
38038: EMPTY
38039: PPUSH
38040: CALL_OW 1
38044: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38045: LD_ADDR_EXP 143
38049: PUSH
38050: LD_EXP 143
38054: PPUSH
38055: LD_VAR 0 2
38059: PPUSH
38060: LD_INT 0
38062: PPUSH
38063: CALL_OW 1
38067: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38068: LD_ADDR_EXP 144
38072: PUSH
38073: LD_EXP 144
38077: PPUSH
38078: LD_VAR 0 2
38082: PPUSH
38083: EMPTY
38084: PPUSH
38085: CALL_OW 1
38089: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38090: LD_ADDR_EXP 145
38094: PUSH
38095: LD_EXP 145
38099: PPUSH
38100: LD_VAR 0 2
38104: PPUSH
38105: EMPTY
38106: PPUSH
38107: CALL_OW 1
38111: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38112: LD_ADDR_EXP 146
38116: PUSH
38117: LD_EXP 146
38121: PPUSH
38122: LD_VAR 0 2
38126: PPUSH
38127: EMPTY
38128: PPUSH
38129: CALL_OW 1
38133: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38134: LD_ADDR_EXP 148
38138: PUSH
38139: LD_EXP 148
38143: PPUSH
38144: LD_VAR 0 2
38148: PPUSH
38149: LD_EXP 115
38153: PUSH
38154: LD_VAR 0 2
38158: ARRAY
38159: PPUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 30
38165: PUSH
38166: LD_INT 6
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 30
38175: PUSH
38176: LD_INT 7
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 30
38185: PUSH
38186: LD_INT 8
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: PPUSH
38199: CALL_OW 72
38203: PPUSH
38204: CALL_OW 1
38208: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38209: LD_ADDR_EXP 149
38213: PUSH
38214: LD_EXP 149
38218: PPUSH
38219: LD_VAR 0 2
38223: PPUSH
38224: EMPTY
38225: PPUSH
38226: CALL_OW 1
38230: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38231: LD_ADDR_EXP 150
38235: PUSH
38236: LD_EXP 150
38240: PPUSH
38241: LD_VAR 0 2
38245: PPUSH
38246: EMPTY
38247: PPUSH
38248: CALL_OW 1
38252: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38253: LD_ADDR_EXP 151
38257: PUSH
38258: LD_EXP 151
38262: PPUSH
38263: LD_VAR 0 2
38267: PPUSH
38268: EMPTY
38269: PPUSH
38270: CALL_OW 1
38274: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38275: LD_ADDR_EXP 152
38279: PUSH
38280: LD_EXP 152
38284: PPUSH
38285: LD_VAR 0 2
38289: PPUSH
38290: EMPTY
38291: PPUSH
38292: CALL_OW 1
38296: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38297: LD_ADDR_EXP 153
38301: PUSH
38302: LD_EXP 153
38306: PPUSH
38307: LD_VAR 0 2
38311: PPUSH
38312: EMPTY
38313: PPUSH
38314: CALL_OW 1
38318: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38319: LD_ADDR_EXP 154
38323: PUSH
38324: LD_EXP 154
38328: PPUSH
38329: LD_VAR 0 2
38333: PPUSH
38334: EMPTY
38335: PPUSH
38336: CALL_OW 1
38340: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38341: LD_ADDR_EXP 155
38345: PUSH
38346: LD_EXP 155
38350: PPUSH
38351: LD_VAR 0 2
38355: PPUSH
38356: EMPTY
38357: PPUSH
38358: CALL_OW 1
38362: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38363: LD_ADDR_EXP 156
38367: PUSH
38368: LD_EXP 156
38372: PPUSH
38373: LD_VAR 0 2
38377: PPUSH
38378: EMPTY
38379: PPUSH
38380: CALL_OW 1
38384: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38385: LD_ADDR_EXP 157
38389: PUSH
38390: LD_EXP 157
38394: PPUSH
38395: LD_VAR 0 2
38399: PPUSH
38400: LD_INT 0
38402: PPUSH
38403: CALL_OW 1
38407: ST_TO_ADDR
// end ;
38408: GO 37332
38410: POP
38411: POP
// MC_InitSides ( ) ;
38412: CALL 38698 0 0
// MC_InitResearch ( ) ;
38416: CALL 38437 0 0
// CustomInitMacro ( ) ;
38420: CALL 471 0 0
// skirmish := true ;
38424: LD_ADDR_EXP 113
38428: PUSH
38429: LD_INT 1
38431: ST_TO_ADDR
// end ;
38432: LD_VAR 0 1
38436: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38437: LD_INT 0
38439: PPUSH
38440: PPUSH
38441: PPUSH
38442: PPUSH
38443: PPUSH
38444: PPUSH
// if not mc_bases then
38445: LD_EXP 115
38449: NOT
38450: IFFALSE 38454
// exit ;
38452: GO 38693
// for i = 1 to 8 do
38454: LD_ADDR_VAR 0 2
38458: PUSH
38459: DOUBLE
38460: LD_INT 1
38462: DEC
38463: ST_TO_ADDR
38464: LD_INT 8
38466: PUSH
38467: FOR_TO
38468: IFFALSE 38494
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38470: LD_ADDR_EXP 142
38474: PUSH
38475: LD_EXP 142
38479: PPUSH
38480: LD_VAR 0 2
38484: PPUSH
38485: EMPTY
38486: PPUSH
38487: CALL_OW 1
38491: ST_TO_ADDR
38492: GO 38467
38494: POP
38495: POP
// tmp := [ ] ;
38496: LD_ADDR_VAR 0 5
38500: PUSH
38501: EMPTY
38502: ST_TO_ADDR
// for i = 1 to mc_sides do
38503: LD_ADDR_VAR 0 2
38507: PUSH
38508: DOUBLE
38509: LD_INT 1
38511: DEC
38512: ST_TO_ADDR
38513: LD_EXP 141
38517: PUSH
38518: FOR_TO
38519: IFFALSE 38577
// if not mc_sides [ i ] in tmp then
38521: LD_EXP 141
38525: PUSH
38526: LD_VAR 0 2
38530: ARRAY
38531: PUSH
38532: LD_VAR 0 5
38536: IN
38537: NOT
38538: IFFALSE 38575
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38540: LD_ADDR_VAR 0 5
38544: PUSH
38545: LD_VAR 0 5
38549: PPUSH
38550: LD_VAR 0 5
38554: PUSH
38555: LD_INT 1
38557: PLUS
38558: PPUSH
38559: LD_EXP 141
38563: PUSH
38564: LD_VAR 0 2
38568: ARRAY
38569: PPUSH
38570: CALL_OW 2
38574: ST_TO_ADDR
38575: GO 38518
38577: POP
38578: POP
// if not tmp then
38579: LD_VAR 0 5
38583: NOT
38584: IFFALSE 38588
// exit ;
38586: GO 38693
// for j in tmp do
38588: LD_ADDR_VAR 0 3
38592: PUSH
38593: LD_VAR 0 5
38597: PUSH
38598: FOR_IN
38599: IFFALSE 38691
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38601: LD_ADDR_VAR 0 6
38605: PUSH
38606: LD_INT 22
38608: PUSH
38609: LD_VAR 0 3
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PPUSH
38618: CALL_OW 69
38622: ST_TO_ADDR
// if not un then
38623: LD_VAR 0 6
38627: NOT
38628: IFFALSE 38632
// continue ;
38630: GO 38598
// nation := GetNation ( un [ 1 ] ) ;
38632: LD_ADDR_VAR 0 4
38636: PUSH
38637: LD_VAR 0 6
38641: PUSH
38642: LD_INT 1
38644: ARRAY
38645: PPUSH
38646: CALL_OW 248
38650: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38651: LD_ADDR_EXP 142
38655: PUSH
38656: LD_EXP 142
38660: PPUSH
38661: LD_VAR 0 3
38665: PPUSH
38666: LD_VAR 0 3
38670: PPUSH
38671: LD_VAR 0 4
38675: PPUSH
38676: LD_INT 1
38678: PPUSH
38679: CALL 65470 0 3
38683: PPUSH
38684: CALL_OW 1
38688: ST_TO_ADDR
// end ;
38689: GO 38598
38691: POP
38692: POP
// end ;
38693: LD_VAR 0 1
38697: RET
// export function MC_InitSides ( ) ; var i ; begin
38698: LD_INT 0
38700: PPUSH
38701: PPUSH
// if not mc_bases then
38702: LD_EXP 115
38706: NOT
38707: IFFALSE 38711
// exit ;
38709: GO 38785
// for i = 1 to mc_bases do
38711: LD_ADDR_VAR 0 2
38715: PUSH
38716: DOUBLE
38717: LD_INT 1
38719: DEC
38720: ST_TO_ADDR
38721: LD_EXP 115
38725: PUSH
38726: FOR_TO
38727: IFFALSE 38783
// if mc_bases [ i ] then
38729: LD_EXP 115
38733: PUSH
38734: LD_VAR 0 2
38738: ARRAY
38739: IFFALSE 38781
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38741: LD_ADDR_EXP 141
38745: PUSH
38746: LD_EXP 141
38750: PPUSH
38751: LD_VAR 0 2
38755: PPUSH
38756: LD_EXP 115
38760: PUSH
38761: LD_VAR 0 2
38765: ARRAY
38766: PUSH
38767: LD_INT 1
38769: ARRAY
38770: PPUSH
38771: CALL_OW 255
38775: PPUSH
38776: CALL_OW 1
38780: ST_TO_ADDR
38781: GO 38726
38783: POP
38784: POP
// end ;
38785: LD_VAR 0 1
38789: RET
// every 0 0$03 trigger skirmish do
38790: LD_EXP 113
38794: IFFALSE 38948
38796: GO 38798
38798: DISABLE
// begin enable ;
38799: ENABLE
// MC_CheckBuildings ( ) ;
38800: CALL 43446 0 0
// MC_CheckPeopleLife ( ) ;
38804: CALL 43571 0 0
// RaiseSailEvent ( 100 ) ;
38808: LD_INT 100
38810: PPUSH
38811: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38815: LD_INT 103
38817: PPUSH
38818: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38822: LD_INT 104
38824: PPUSH
38825: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38829: LD_INT 105
38831: PPUSH
38832: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38836: LD_INT 106
38838: PPUSH
38839: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38843: LD_INT 107
38845: PPUSH
38846: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38850: LD_INT 108
38852: PPUSH
38853: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38857: LD_INT 109
38859: PPUSH
38860: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38864: LD_INT 110
38866: PPUSH
38867: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38871: LD_INT 111
38873: PPUSH
38874: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38878: LD_INT 112
38880: PPUSH
38881: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38885: LD_INT 113
38887: PPUSH
38888: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38892: LD_INT 120
38894: PPUSH
38895: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38899: LD_INT 121
38901: PPUSH
38902: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38906: LD_INT 122
38908: PPUSH
38909: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38913: LD_INT 123
38915: PPUSH
38916: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38920: LD_INT 124
38922: PPUSH
38923: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38927: LD_INT 125
38929: PPUSH
38930: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38934: LD_INT 126
38936: PPUSH
38937: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38941: LD_INT 200
38943: PPUSH
38944: CALL_OW 427
// end ;
38948: END
// on SailEvent ( event ) do begin if event < 100 then
38949: LD_VAR 0 1
38953: PUSH
38954: LD_INT 100
38956: LESS
38957: IFFALSE 38968
// CustomEvent ( event ) ;
38959: LD_VAR 0 1
38963: PPUSH
38964: CALL 33446 0 1
// if event = 100 then
38968: LD_VAR 0 1
38972: PUSH
38973: LD_INT 100
38975: EQUAL
38976: IFFALSE 38982
// MC_ClassManager ( ) ;
38978: CALL 39374 0 0
// if event = 101 then
38982: LD_VAR 0 1
38986: PUSH
38987: LD_INT 101
38989: EQUAL
38990: IFFALSE 38996
// MC_RepairBuildings ( ) ;
38992: CALL 44156 0 0
// if event = 102 then
38996: LD_VAR 0 1
39000: PUSH
39001: LD_INT 102
39003: EQUAL
39004: IFFALSE 39010
// MC_Heal ( ) ;
39006: CALL 45041 0 0
// if event = 103 then
39010: LD_VAR 0 1
39014: PUSH
39015: LD_INT 103
39017: EQUAL
39018: IFFALSE 39024
// MC_Build ( ) ;
39020: CALL 45463 0 0
// if event = 104 then
39024: LD_VAR 0 1
39028: PUSH
39029: LD_INT 104
39031: EQUAL
39032: IFFALSE 39038
// MC_TurretWeapon ( ) ;
39034: CALL 47104 0 0
// if event = 105 then
39038: LD_VAR 0 1
39042: PUSH
39043: LD_INT 105
39045: EQUAL
39046: IFFALSE 39052
// MC_BuildUpgrade ( ) ;
39048: CALL 46655 0 0
// if event = 106 then
39052: LD_VAR 0 1
39056: PUSH
39057: LD_INT 106
39059: EQUAL
39060: IFFALSE 39066
// MC_PlantMines ( ) ;
39062: CALL 47534 0 0
// if event = 107 then
39066: LD_VAR 0 1
39070: PUSH
39071: LD_INT 107
39073: EQUAL
39074: IFFALSE 39080
// MC_CollectCrates ( ) ;
39076: CALL 48325 0 0
// if event = 108 then
39080: LD_VAR 0 1
39084: PUSH
39085: LD_INT 108
39087: EQUAL
39088: IFFALSE 39094
// MC_LinkRemoteControl ( ) ;
39090: CALL 50101 0 0
// if event = 109 then
39094: LD_VAR 0 1
39098: PUSH
39099: LD_INT 109
39101: EQUAL
39102: IFFALSE 39108
// MC_ProduceVehicle ( ) ;
39104: CALL 50282 0 0
// if event = 110 then
39108: LD_VAR 0 1
39112: PUSH
39113: LD_INT 110
39115: EQUAL
39116: IFFALSE 39122
// MC_SendAttack ( ) ;
39118: CALL 50748 0 0
// if event = 111 then
39122: LD_VAR 0 1
39126: PUSH
39127: LD_INT 111
39129: EQUAL
39130: IFFALSE 39136
// MC_Defend ( ) ;
39132: CALL 50856 0 0
// if event = 112 then
39136: LD_VAR 0 1
39140: PUSH
39141: LD_INT 112
39143: EQUAL
39144: IFFALSE 39150
// MC_Research ( ) ;
39146: CALL 51578 0 0
// if event = 113 then
39150: LD_VAR 0 1
39154: PUSH
39155: LD_INT 113
39157: EQUAL
39158: IFFALSE 39164
// MC_MinesTrigger ( ) ;
39160: CALL 52692 0 0
// if event = 120 then
39164: LD_VAR 0 1
39168: PUSH
39169: LD_INT 120
39171: EQUAL
39172: IFFALSE 39178
// MC_RepairVehicle ( ) ;
39174: CALL 52791 0 0
// if event = 121 then
39178: LD_VAR 0 1
39182: PUSH
39183: LD_INT 121
39185: EQUAL
39186: IFFALSE 39192
// MC_TameApe ( ) ;
39188: CALL 53521 0 0
// if event = 122 then
39192: LD_VAR 0 1
39196: PUSH
39197: LD_INT 122
39199: EQUAL
39200: IFFALSE 39206
// MC_ChangeApeClass ( ) ;
39202: CALL 54350 0 0
// if event = 123 then
39206: LD_VAR 0 1
39210: PUSH
39211: LD_INT 123
39213: EQUAL
39214: IFFALSE 39220
// MC_Bazooka ( ) ;
39216: CALL 55000 0 0
// if event = 124 then
39220: LD_VAR 0 1
39224: PUSH
39225: LD_INT 124
39227: EQUAL
39228: IFFALSE 39234
// MC_TeleportExit ( ) ;
39230: CALL 55198 0 0
// if event = 125 then
39234: LD_VAR 0 1
39238: PUSH
39239: LD_INT 125
39241: EQUAL
39242: IFFALSE 39248
// MC_Deposits ( ) ;
39244: CALL 55845 0 0
// if event = 126 then
39248: LD_VAR 0 1
39252: PUSH
39253: LD_INT 126
39255: EQUAL
39256: IFFALSE 39262
// MC_RemoteDriver ( ) ;
39258: CALL 56470 0 0
// if event = 200 then
39262: LD_VAR 0 1
39266: PUSH
39267: LD_INT 200
39269: EQUAL
39270: IFFALSE 39276
// MC_Idle ( ) ;
39272: CALL 58419 0 0
// end ;
39276: PPOPN 1
39278: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39279: LD_INT 0
39281: PPUSH
39282: PPUSH
// if not mc_bases [ base ] or not tag then
39283: LD_EXP 115
39287: PUSH
39288: LD_VAR 0 1
39292: ARRAY
39293: NOT
39294: PUSH
39295: LD_VAR 0 2
39299: NOT
39300: OR
39301: IFFALSE 39305
// exit ;
39303: GO 39369
// for i in mc_bases [ base ] union mc_ape [ base ] do
39305: LD_ADDR_VAR 0 4
39309: PUSH
39310: LD_EXP 115
39314: PUSH
39315: LD_VAR 0 1
39319: ARRAY
39320: PUSH
39321: LD_EXP 144
39325: PUSH
39326: LD_VAR 0 1
39330: ARRAY
39331: UNION
39332: PUSH
39333: FOR_IN
39334: IFFALSE 39367
// if GetTag ( i ) = tag then
39336: LD_VAR 0 4
39340: PPUSH
39341: CALL_OW 110
39345: PUSH
39346: LD_VAR 0 2
39350: EQUAL
39351: IFFALSE 39365
// SetTag ( i , 0 ) ;
39353: LD_VAR 0 4
39357: PPUSH
39358: LD_INT 0
39360: PPUSH
39361: CALL_OW 109
39365: GO 39333
39367: POP
39368: POP
// end ;
39369: LD_VAR 0 3
39373: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39374: LD_INT 0
39376: PPUSH
39377: PPUSH
39378: PPUSH
39379: PPUSH
39380: PPUSH
39381: PPUSH
39382: PPUSH
39383: PPUSH
// if not mc_bases then
39384: LD_EXP 115
39388: NOT
39389: IFFALSE 39393
// exit ;
39391: GO 39851
// for i = 1 to mc_bases do
39393: LD_ADDR_VAR 0 2
39397: PUSH
39398: DOUBLE
39399: LD_INT 1
39401: DEC
39402: ST_TO_ADDR
39403: LD_EXP 115
39407: PUSH
39408: FOR_TO
39409: IFFALSE 39849
// begin tmp := MC_ClassCheckReq ( i ) ;
39411: LD_ADDR_VAR 0 4
39415: PUSH
39416: LD_VAR 0 2
39420: PPUSH
39421: CALL 39856 0 1
39425: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39426: LD_ADDR_EXP 156
39430: PUSH
39431: LD_EXP 156
39435: PPUSH
39436: LD_VAR 0 2
39440: PPUSH
39441: LD_VAR 0 4
39445: PPUSH
39446: CALL_OW 1
39450: ST_TO_ADDR
// if not tmp then
39451: LD_VAR 0 4
39455: NOT
39456: IFFALSE 39460
// continue ;
39458: GO 39408
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39460: LD_ADDR_VAR 0 6
39464: PUSH
39465: LD_EXP 115
39469: PUSH
39470: LD_VAR 0 2
39474: ARRAY
39475: PPUSH
39476: LD_INT 2
39478: PUSH
39479: LD_INT 30
39481: PUSH
39482: LD_INT 4
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 30
39491: PUSH
39492: LD_INT 5
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: LIST
39503: PPUSH
39504: CALL_OW 72
39508: PUSH
39509: LD_EXP 115
39513: PUSH
39514: LD_VAR 0 2
39518: ARRAY
39519: PPUSH
39520: LD_INT 2
39522: PUSH
39523: LD_INT 30
39525: PUSH
39526: LD_INT 0
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 30
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: PPUSH
39548: CALL_OW 72
39552: PUSH
39553: LD_EXP 115
39557: PUSH
39558: LD_VAR 0 2
39562: ARRAY
39563: PPUSH
39564: LD_INT 30
39566: PUSH
39567: LD_INT 3
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PPUSH
39574: CALL_OW 72
39578: PUSH
39579: LD_EXP 115
39583: PUSH
39584: LD_VAR 0 2
39588: ARRAY
39589: PPUSH
39590: LD_INT 2
39592: PUSH
39593: LD_INT 30
39595: PUSH
39596: LD_INT 6
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 30
39605: PUSH
39606: LD_INT 7
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 8
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: PPUSH
39629: CALL_OW 72
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: ST_TO_ADDR
// for j = 1 to 4 do
39640: LD_ADDR_VAR 0 3
39644: PUSH
39645: DOUBLE
39646: LD_INT 1
39648: DEC
39649: ST_TO_ADDR
39650: LD_INT 4
39652: PUSH
39653: FOR_TO
39654: IFFALSE 39845
// begin if not tmp [ j ] then
39656: LD_VAR 0 4
39660: PUSH
39661: LD_VAR 0 3
39665: ARRAY
39666: NOT
39667: IFFALSE 39671
// continue ;
39669: GO 39653
// for p in tmp [ j ] do
39671: LD_ADDR_VAR 0 5
39675: PUSH
39676: LD_VAR 0 4
39680: PUSH
39681: LD_VAR 0 3
39685: ARRAY
39686: PUSH
39687: FOR_IN
39688: IFFALSE 39841
// begin if not b [ j ] then
39690: LD_VAR 0 6
39694: PUSH
39695: LD_VAR 0 3
39699: ARRAY
39700: NOT
39701: IFFALSE 39705
// break ;
39703: GO 39841
// e := 0 ;
39705: LD_ADDR_VAR 0 7
39709: PUSH
39710: LD_INT 0
39712: ST_TO_ADDR
// for k in b [ j ] do
39713: LD_ADDR_VAR 0 8
39717: PUSH
39718: LD_VAR 0 6
39722: PUSH
39723: LD_VAR 0 3
39727: ARRAY
39728: PUSH
39729: FOR_IN
39730: IFFALSE 39757
// if IsNotFull ( k ) then
39732: LD_VAR 0 8
39736: PPUSH
39737: CALL 67619 0 1
39741: IFFALSE 39755
// begin e := k ;
39743: LD_ADDR_VAR 0 7
39747: PUSH
39748: LD_VAR 0 8
39752: ST_TO_ADDR
// break ;
39753: GO 39757
// end ;
39755: GO 39729
39757: POP
39758: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39759: LD_VAR 0 7
39763: PUSH
39764: LD_VAR 0 5
39768: PPUSH
39769: LD_VAR 0 7
39773: PPUSH
39774: CALL 100372 0 2
39778: NOT
39779: AND
39780: IFFALSE 39839
// begin if IsInUnit ( p ) then
39782: LD_VAR 0 5
39786: PPUSH
39787: CALL_OW 310
39791: IFFALSE 39802
// ComExitBuilding ( p ) ;
39793: LD_VAR 0 5
39797: PPUSH
39798: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39802: LD_VAR 0 5
39806: PPUSH
39807: LD_VAR 0 7
39811: PPUSH
39812: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39816: LD_VAR 0 5
39820: PPUSH
39821: LD_VAR 0 3
39825: PPUSH
39826: CALL_OW 183
// AddComExitBuilding ( p ) ;
39830: LD_VAR 0 5
39834: PPUSH
39835: CALL_OW 182
// end ; end ;
39839: GO 39687
39841: POP
39842: POP
// end ;
39843: GO 39653
39845: POP
39846: POP
// end ;
39847: GO 39408
39849: POP
39850: POP
// end ;
39851: LD_VAR 0 1
39855: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39856: LD_INT 0
39858: PPUSH
39859: PPUSH
39860: PPUSH
39861: PPUSH
39862: PPUSH
39863: PPUSH
39864: PPUSH
39865: PPUSH
39866: PPUSH
39867: PPUSH
39868: PPUSH
39869: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39870: LD_VAR 0 1
39874: NOT
39875: PUSH
39876: LD_EXP 115
39880: PUSH
39881: LD_VAR 0 1
39885: ARRAY
39886: NOT
39887: OR
39888: PUSH
39889: LD_EXP 115
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: PPUSH
39900: LD_INT 2
39902: PUSH
39903: LD_INT 30
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 30
39915: PUSH
39916: LD_INT 1
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: LIST
39927: PPUSH
39928: CALL_OW 72
39932: NOT
39933: OR
39934: IFFALSE 39938
// exit ;
39936: GO 43441
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39938: LD_ADDR_VAR 0 4
39942: PUSH
39943: LD_EXP 115
39947: PUSH
39948: LD_VAR 0 1
39952: ARRAY
39953: PPUSH
39954: LD_INT 2
39956: PUSH
39957: LD_INT 25
39959: PUSH
39960: LD_INT 1
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 25
39969: PUSH
39970: LD_INT 2
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 25
39979: PUSH
39980: LD_INT 3
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 25
39989: PUSH
39990: LD_INT 4
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 25
39999: PUSH
40000: LD_INT 5
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PUSH
40007: LD_INT 25
40009: PUSH
40010: LD_INT 8
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 25
40019: PUSH
40020: LD_INT 9
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: PPUSH
40037: CALL_OW 72
40041: ST_TO_ADDR
// if not tmp then
40042: LD_VAR 0 4
40046: NOT
40047: IFFALSE 40051
// exit ;
40049: GO 43441
// for i in tmp do
40051: LD_ADDR_VAR 0 3
40055: PUSH
40056: LD_VAR 0 4
40060: PUSH
40061: FOR_IN
40062: IFFALSE 40093
// if GetTag ( i ) then
40064: LD_VAR 0 3
40068: PPUSH
40069: CALL_OW 110
40073: IFFALSE 40091
// tmp := tmp diff i ;
40075: LD_ADDR_VAR 0 4
40079: PUSH
40080: LD_VAR 0 4
40084: PUSH
40085: LD_VAR 0 3
40089: DIFF
40090: ST_TO_ADDR
40091: GO 40061
40093: POP
40094: POP
// if not tmp then
40095: LD_VAR 0 4
40099: NOT
40100: IFFALSE 40104
// exit ;
40102: GO 43441
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40104: LD_ADDR_VAR 0 5
40108: PUSH
40109: LD_EXP 115
40113: PUSH
40114: LD_VAR 0 1
40118: ARRAY
40119: PPUSH
40120: LD_INT 2
40122: PUSH
40123: LD_INT 25
40125: PUSH
40126: LD_INT 1
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 25
40135: PUSH
40136: LD_INT 5
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 25
40145: PUSH
40146: LD_INT 8
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 25
40155: PUSH
40156: LD_INT 9
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: PPUSH
40170: CALL_OW 72
40174: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40175: LD_ADDR_VAR 0 6
40179: PUSH
40180: LD_EXP 115
40184: PUSH
40185: LD_VAR 0 1
40189: ARRAY
40190: PPUSH
40191: LD_INT 25
40193: PUSH
40194: LD_INT 2
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PPUSH
40201: CALL_OW 72
40205: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40206: LD_ADDR_VAR 0 7
40210: PUSH
40211: LD_EXP 115
40215: PUSH
40216: LD_VAR 0 1
40220: ARRAY
40221: PPUSH
40222: LD_INT 25
40224: PUSH
40225: LD_INT 3
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PPUSH
40232: CALL_OW 72
40236: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40237: LD_ADDR_VAR 0 8
40241: PUSH
40242: LD_EXP 115
40246: PUSH
40247: LD_VAR 0 1
40251: ARRAY
40252: PPUSH
40253: LD_INT 25
40255: PUSH
40256: LD_INT 4
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 24
40265: PUSH
40266: LD_INT 251
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PPUSH
40277: CALL_OW 72
40281: ST_TO_ADDR
// if mc_scan [ base ] then
40282: LD_EXP 138
40286: PUSH
40287: LD_VAR 0 1
40291: ARRAY
40292: IFFALSE 40753
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40294: LD_ADDR_EXP 157
40298: PUSH
40299: LD_EXP 157
40303: PPUSH
40304: LD_VAR 0 1
40308: PPUSH
40309: LD_INT 4
40311: PPUSH
40312: CALL_OW 1
40316: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40317: LD_ADDR_VAR 0 12
40321: PUSH
40322: LD_EXP 115
40326: PUSH
40327: LD_VAR 0 1
40331: ARRAY
40332: PPUSH
40333: LD_INT 2
40335: PUSH
40336: LD_INT 30
40338: PUSH
40339: LD_INT 4
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 30
40348: PUSH
40349: LD_INT 5
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: LIST
40360: PPUSH
40361: CALL_OW 72
40365: ST_TO_ADDR
// if not b then
40366: LD_VAR 0 12
40370: NOT
40371: IFFALSE 40375
// exit ;
40373: GO 43441
// p := [ ] ;
40375: LD_ADDR_VAR 0 11
40379: PUSH
40380: EMPTY
40381: ST_TO_ADDR
// if sci >= 2 then
40382: LD_VAR 0 8
40386: PUSH
40387: LD_INT 2
40389: GREATEREQUAL
40390: IFFALSE 40421
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40392: LD_ADDR_VAR 0 8
40396: PUSH
40397: LD_VAR 0 8
40401: PUSH
40402: LD_INT 1
40404: ARRAY
40405: PUSH
40406: LD_VAR 0 8
40410: PUSH
40411: LD_INT 2
40413: ARRAY
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: ST_TO_ADDR
40419: GO 40482
// if sci = 1 then
40421: LD_VAR 0 8
40425: PUSH
40426: LD_INT 1
40428: EQUAL
40429: IFFALSE 40450
// sci := [ sci [ 1 ] ] else
40431: LD_ADDR_VAR 0 8
40435: PUSH
40436: LD_VAR 0 8
40440: PUSH
40441: LD_INT 1
40443: ARRAY
40444: PUSH
40445: EMPTY
40446: LIST
40447: ST_TO_ADDR
40448: GO 40482
// if sci = 0 then
40450: LD_VAR 0 8
40454: PUSH
40455: LD_INT 0
40457: EQUAL
40458: IFFALSE 40482
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40460: LD_ADDR_VAR 0 11
40464: PUSH
40465: LD_VAR 0 4
40469: PPUSH
40470: LD_INT 4
40472: PPUSH
40473: CALL 100235 0 2
40477: PUSH
40478: LD_INT 1
40480: ARRAY
40481: ST_TO_ADDR
// if eng > 4 then
40482: LD_VAR 0 6
40486: PUSH
40487: LD_INT 4
40489: GREATER
40490: IFFALSE 40536
// for i = eng downto 4 do
40492: LD_ADDR_VAR 0 3
40496: PUSH
40497: DOUBLE
40498: LD_VAR 0 6
40502: INC
40503: ST_TO_ADDR
40504: LD_INT 4
40506: PUSH
40507: FOR_DOWNTO
40508: IFFALSE 40534
// eng := eng diff eng [ i ] ;
40510: LD_ADDR_VAR 0 6
40514: PUSH
40515: LD_VAR 0 6
40519: PUSH
40520: LD_VAR 0 6
40524: PUSH
40525: LD_VAR 0 3
40529: ARRAY
40530: DIFF
40531: ST_TO_ADDR
40532: GO 40507
40534: POP
40535: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40536: LD_ADDR_VAR 0 4
40540: PUSH
40541: LD_VAR 0 4
40545: PUSH
40546: LD_VAR 0 5
40550: PUSH
40551: LD_VAR 0 6
40555: UNION
40556: PUSH
40557: LD_VAR 0 7
40561: UNION
40562: PUSH
40563: LD_VAR 0 8
40567: UNION
40568: DIFF
40569: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40570: LD_ADDR_VAR 0 13
40574: PUSH
40575: LD_EXP 115
40579: PUSH
40580: LD_VAR 0 1
40584: ARRAY
40585: PPUSH
40586: LD_INT 2
40588: PUSH
40589: LD_INT 30
40591: PUSH
40592: LD_INT 32
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 30
40601: PUSH
40602: LD_INT 31
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: LIST
40613: PPUSH
40614: CALL_OW 72
40618: PUSH
40619: LD_EXP 115
40623: PUSH
40624: LD_VAR 0 1
40628: ARRAY
40629: PPUSH
40630: LD_INT 2
40632: PUSH
40633: LD_INT 30
40635: PUSH
40636: LD_INT 4
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 30
40645: PUSH
40646: LD_INT 5
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: LIST
40657: PPUSH
40658: CALL_OW 72
40662: PUSH
40663: LD_INT 6
40665: MUL
40666: PLUS
40667: ST_TO_ADDR
// if bcount < tmp then
40668: LD_VAR 0 13
40672: PUSH
40673: LD_VAR 0 4
40677: LESS
40678: IFFALSE 40724
// for i = tmp downto bcount do
40680: LD_ADDR_VAR 0 3
40684: PUSH
40685: DOUBLE
40686: LD_VAR 0 4
40690: INC
40691: ST_TO_ADDR
40692: LD_VAR 0 13
40696: PUSH
40697: FOR_DOWNTO
40698: IFFALSE 40722
// tmp := Delete ( tmp , tmp ) ;
40700: LD_ADDR_VAR 0 4
40704: PUSH
40705: LD_VAR 0 4
40709: PPUSH
40710: LD_VAR 0 4
40714: PPUSH
40715: CALL_OW 3
40719: ST_TO_ADDR
40720: GO 40697
40722: POP
40723: POP
// result := [ tmp , 0 , 0 , p ] ;
40724: LD_ADDR_VAR 0 2
40728: PUSH
40729: LD_VAR 0 4
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: LD_INT 0
40739: PUSH
40740: LD_VAR 0 11
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: ST_TO_ADDR
// exit ;
40751: GO 43441
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40753: LD_EXP 115
40757: PUSH
40758: LD_VAR 0 1
40762: ARRAY
40763: PPUSH
40764: LD_INT 2
40766: PUSH
40767: LD_INT 30
40769: PUSH
40770: LD_INT 6
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 30
40779: PUSH
40780: LD_INT 7
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 30
40789: PUSH
40790: LD_INT 8
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: PPUSH
40803: CALL_OW 72
40807: NOT
40808: PUSH
40809: LD_EXP 115
40813: PUSH
40814: LD_VAR 0 1
40818: ARRAY
40819: PPUSH
40820: LD_INT 30
40822: PUSH
40823: LD_INT 3
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PPUSH
40830: CALL_OW 72
40834: NOT
40835: AND
40836: IFFALSE 40908
// begin if eng = tmp then
40838: LD_VAR 0 6
40842: PUSH
40843: LD_VAR 0 4
40847: EQUAL
40848: IFFALSE 40852
// exit ;
40850: GO 43441
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40852: LD_ADDR_EXP 157
40856: PUSH
40857: LD_EXP 157
40861: PPUSH
40862: LD_VAR 0 1
40866: PPUSH
40867: LD_INT 1
40869: PPUSH
40870: CALL_OW 1
40874: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40875: LD_ADDR_VAR 0 2
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: LD_VAR 0 4
40887: PUSH
40888: LD_VAR 0 6
40892: DIFF
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: ST_TO_ADDR
// exit ;
40906: GO 43441
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40908: LD_EXP 142
40912: PUSH
40913: LD_EXP 141
40917: PUSH
40918: LD_VAR 0 1
40922: ARRAY
40923: ARRAY
40924: PUSH
40925: LD_EXP 115
40929: PUSH
40930: LD_VAR 0 1
40934: ARRAY
40935: PPUSH
40936: LD_INT 2
40938: PUSH
40939: LD_INT 30
40941: PUSH
40942: LD_INT 6
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 30
40951: PUSH
40952: LD_INT 7
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 30
40961: PUSH
40962: LD_INT 8
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: PPUSH
40975: CALL_OW 72
40979: AND
40980: PUSH
40981: LD_EXP 115
40985: PUSH
40986: LD_VAR 0 1
40990: ARRAY
40991: PPUSH
40992: LD_INT 30
40994: PUSH
40995: LD_INT 3
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PPUSH
41002: CALL_OW 72
41006: NOT
41007: AND
41008: IFFALSE 41222
// begin if sci >= 6 then
41010: LD_VAR 0 8
41014: PUSH
41015: LD_INT 6
41017: GREATEREQUAL
41018: IFFALSE 41022
// exit ;
41020: GO 43441
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41022: LD_ADDR_EXP 157
41026: PUSH
41027: LD_EXP 157
41031: PPUSH
41032: LD_VAR 0 1
41036: PPUSH
41037: LD_INT 2
41039: PPUSH
41040: CALL_OW 1
41044: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41045: LD_ADDR_VAR 0 9
41049: PUSH
41050: LD_VAR 0 4
41054: PUSH
41055: LD_VAR 0 8
41059: DIFF
41060: PPUSH
41061: LD_INT 4
41063: PPUSH
41064: CALL 100235 0 2
41068: ST_TO_ADDR
// p := [ ] ;
41069: LD_ADDR_VAR 0 11
41073: PUSH
41074: EMPTY
41075: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41076: LD_VAR 0 8
41080: PUSH
41081: LD_INT 6
41083: LESS
41084: PUSH
41085: LD_VAR 0 9
41089: PUSH
41090: LD_INT 6
41092: GREATER
41093: AND
41094: IFFALSE 41175
// begin for i = 1 to 6 - sci do
41096: LD_ADDR_VAR 0 3
41100: PUSH
41101: DOUBLE
41102: LD_INT 1
41104: DEC
41105: ST_TO_ADDR
41106: LD_INT 6
41108: PUSH
41109: LD_VAR 0 8
41113: MINUS
41114: PUSH
41115: FOR_TO
41116: IFFALSE 41171
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41118: LD_ADDR_VAR 0 11
41122: PUSH
41123: LD_VAR 0 11
41127: PPUSH
41128: LD_VAR 0 11
41132: PUSH
41133: LD_INT 1
41135: PLUS
41136: PPUSH
41137: LD_VAR 0 9
41141: PUSH
41142: LD_INT 1
41144: ARRAY
41145: PPUSH
41146: CALL_OW 2
41150: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41151: LD_ADDR_VAR 0 9
41155: PUSH
41156: LD_VAR 0 9
41160: PPUSH
41161: LD_INT 1
41163: PPUSH
41164: CALL_OW 3
41168: ST_TO_ADDR
// end ;
41169: GO 41115
41171: POP
41172: POP
// end else
41173: GO 41195
// if sort then
41175: LD_VAR 0 9
41179: IFFALSE 41195
// p := sort [ 1 ] ;
41181: LD_ADDR_VAR 0 11
41185: PUSH
41186: LD_VAR 0 9
41190: PUSH
41191: LD_INT 1
41193: ARRAY
41194: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41195: LD_ADDR_VAR 0 2
41199: PUSH
41200: LD_INT 0
41202: PUSH
41203: LD_INT 0
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: LD_VAR 0 11
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: ST_TO_ADDR
// exit ;
41220: GO 43441
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41222: LD_EXP 142
41226: PUSH
41227: LD_EXP 141
41231: PUSH
41232: LD_VAR 0 1
41236: ARRAY
41237: ARRAY
41238: PUSH
41239: LD_EXP 115
41243: PUSH
41244: LD_VAR 0 1
41248: ARRAY
41249: PPUSH
41250: LD_INT 2
41252: PUSH
41253: LD_INT 30
41255: PUSH
41256: LD_INT 6
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 30
41265: PUSH
41266: LD_INT 7
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 30
41275: PUSH
41276: LD_INT 8
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: PPUSH
41289: CALL_OW 72
41293: AND
41294: PUSH
41295: LD_EXP 115
41299: PUSH
41300: LD_VAR 0 1
41304: ARRAY
41305: PPUSH
41306: LD_INT 30
41308: PUSH
41309: LD_INT 3
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PPUSH
41316: CALL_OW 72
41320: AND
41321: IFFALSE 42055
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41323: LD_ADDR_EXP 157
41327: PUSH
41328: LD_EXP 157
41332: PPUSH
41333: LD_VAR 0 1
41337: PPUSH
41338: LD_INT 3
41340: PPUSH
41341: CALL_OW 1
41345: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41346: LD_ADDR_VAR 0 2
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: LD_INT 0
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: LIST
41367: LIST
41368: ST_TO_ADDR
// if not eng then
41369: LD_VAR 0 6
41373: NOT
41374: IFFALSE 41437
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41376: LD_ADDR_VAR 0 11
41380: PUSH
41381: LD_VAR 0 4
41385: PPUSH
41386: LD_INT 2
41388: PPUSH
41389: CALL 100235 0 2
41393: PUSH
41394: LD_INT 1
41396: ARRAY
41397: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41398: LD_ADDR_VAR 0 2
41402: PUSH
41403: LD_VAR 0 2
41407: PPUSH
41408: LD_INT 2
41410: PPUSH
41411: LD_VAR 0 11
41415: PPUSH
41416: CALL_OW 1
41420: ST_TO_ADDR
// tmp := tmp diff p ;
41421: LD_ADDR_VAR 0 4
41425: PUSH
41426: LD_VAR 0 4
41430: PUSH
41431: LD_VAR 0 11
41435: DIFF
41436: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41437: LD_VAR 0 4
41441: PUSH
41442: LD_VAR 0 8
41446: PUSH
41447: LD_INT 6
41449: LESS
41450: AND
41451: IFFALSE 41639
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41453: LD_ADDR_VAR 0 9
41457: PUSH
41458: LD_VAR 0 4
41462: PUSH
41463: LD_VAR 0 8
41467: PUSH
41468: LD_VAR 0 7
41472: UNION
41473: DIFF
41474: PPUSH
41475: LD_INT 4
41477: PPUSH
41478: CALL 100235 0 2
41482: ST_TO_ADDR
// p := [ ] ;
41483: LD_ADDR_VAR 0 11
41487: PUSH
41488: EMPTY
41489: ST_TO_ADDR
// if sort then
41490: LD_VAR 0 9
41494: IFFALSE 41610
// for i = 1 to 6 - sci do
41496: LD_ADDR_VAR 0 3
41500: PUSH
41501: DOUBLE
41502: LD_INT 1
41504: DEC
41505: ST_TO_ADDR
41506: LD_INT 6
41508: PUSH
41509: LD_VAR 0 8
41513: MINUS
41514: PUSH
41515: FOR_TO
41516: IFFALSE 41608
// begin if i = sort then
41518: LD_VAR 0 3
41522: PUSH
41523: LD_VAR 0 9
41527: EQUAL
41528: IFFALSE 41532
// break ;
41530: GO 41608
// if GetClass ( i ) = 4 then
41532: LD_VAR 0 3
41536: PPUSH
41537: CALL_OW 257
41541: PUSH
41542: LD_INT 4
41544: EQUAL
41545: IFFALSE 41549
// continue ;
41547: GO 41515
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41549: LD_ADDR_VAR 0 11
41553: PUSH
41554: LD_VAR 0 11
41558: PPUSH
41559: LD_VAR 0 11
41563: PUSH
41564: LD_INT 1
41566: PLUS
41567: PPUSH
41568: LD_VAR 0 9
41572: PUSH
41573: LD_VAR 0 3
41577: ARRAY
41578: PPUSH
41579: CALL_OW 2
41583: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41584: LD_ADDR_VAR 0 4
41588: PUSH
41589: LD_VAR 0 4
41593: PUSH
41594: LD_VAR 0 9
41598: PUSH
41599: LD_VAR 0 3
41603: ARRAY
41604: DIFF
41605: ST_TO_ADDR
// end ;
41606: GO 41515
41608: POP
41609: POP
// if p then
41610: LD_VAR 0 11
41614: IFFALSE 41639
// result := Replace ( result , 4 , p ) ;
41616: LD_ADDR_VAR 0 2
41620: PUSH
41621: LD_VAR 0 2
41625: PPUSH
41626: LD_INT 4
41628: PPUSH
41629: LD_VAR 0 11
41633: PPUSH
41634: CALL_OW 1
41638: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41639: LD_VAR 0 4
41643: PUSH
41644: LD_VAR 0 7
41648: PUSH
41649: LD_INT 6
41651: LESS
41652: AND
41653: IFFALSE 41841
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41655: LD_ADDR_VAR 0 9
41659: PUSH
41660: LD_VAR 0 4
41664: PUSH
41665: LD_VAR 0 8
41669: PUSH
41670: LD_VAR 0 7
41674: UNION
41675: DIFF
41676: PPUSH
41677: LD_INT 3
41679: PPUSH
41680: CALL 100235 0 2
41684: ST_TO_ADDR
// p := [ ] ;
41685: LD_ADDR_VAR 0 11
41689: PUSH
41690: EMPTY
41691: ST_TO_ADDR
// if sort then
41692: LD_VAR 0 9
41696: IFFALSE 41812
// for i = 1 to 6 - mech do
41698: LD_ADDR_VAR 0 3
41702: PUSH
41703: DOUBLE
41704: LD_INT 1
41706: DEC
41707: ST_TO_ADDR
41708: LD_INT 6
41710: PUSH
41711: LD_VAR 0 7
41715: MINUS
41716: PUSH
41717: FOR_TO
41718: IFFALSE 41810
// begin if i = sort then
41720: LD_VAR 0 3
41724: PUSH
41725: LD_VAR 0 9
41729: EQUAL
41730: IFFALSE 41734
// break ;
41732: GO 41810
// if GetClass ( i ) = 3 then
41734: LD_VAR 0 3
41738: PPUSH
41739: CALL_OW 257
41743: PUSH
41744: LD_INT 3
41746: EQUAL
41747: IFFALSE 41751
// continue ;
41749: GO 41717
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41751: LD_ADDR_VAR 0 11
41755: PUSH
41756: LD_VAR 0 11
41760: PPUSH
41761: LD_VAR 0 11
41765: PUSH
41766: LD_INT 1
41768: PLUS
41769: PPUSH
41770: LD_VAR 0 9
41774: PUSH
41775: LD_VAR 0 3
41779: ARRAY
41780: PPUSH
41781: CALL_OW 2
41785: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41786: LD_ADDR_VAR 0 4
41790: PUSH
41791: LD_VAR 0 4
41795: PUSH
41796: LD_VAR 0 9
41800: PUSH
41801: LD_VAR 0 3
41805: ARRAY
41806: DIFF
41807: ST_TO_ADDR
// end ;
41808: GO 41717
41810: POP
41811: POP
// if p then
41812: LD_VAR 0 11
41816: IFFALSE 41841
// result := Replace ( result , 3 , p ) ;
41818: LD_ADDR_VAR 0 2
41822: PUSH
41823: LD_VAR 0 2
41827: PPUSH
41828: LD_INT 3
41830: PPUSH
41831: LD_VAR 0 11
41835: PPUSH
41836: CALL_OW 1
41840: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41841: LD_VAR 0 4
41845: PUSH
41846: LD_INT 6
41848: GREATER
41849: PUSH
41850: LD_VAR 0 6
41854: PUSH
41855: LD_INT 6
41857: LESS
41858: AND
41859: IFFALSE 42053
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41861: LD_ADDR_VAR 0 9
41865: PUSH
41866: LD_VAR 0 4
41870: PUSH
41871: LD_VAR 0 8
41875: PUSH
41876: LD_VAR 0 7
41880: UNION
41881: PUSH
41882: LD_VAR 0 6
41886: UNION
41887: DIFF
41888: PPUSH
41889: LD_INT 2
41891: PPUSH
41892: CALL 100235 0 2
41896: ST_TO_ADDR
// p := [ ] ;
41897: LD_ADDR_VAR 0 11
41901: PUSH
41902: EMPTY
41903: ST_TO_ADDR
// if sort then
41904: LD_VAR 0 9
41908: IFFALSE 42024
// for i = 1 to 6 - eng do
41910: LD_ADDR_VAR 0 3
41914: PUSH
41915: DOUBLE
41916: LD_INT 1
41918: DEC
41919: ST_TO_ADDR
41920: LD_INT 6
41922: PUSH
41923: LD_VAR 0 6
41927: MINUS
41928: PUSH
41929: FOR_TO
41930: IFFALSE 42022
// begin if i = sort then
41932: LD_VAR 0 3
41936: PUSH
41937: LD_VAR 0 9
41941: EQUAL
41942: IFFALSE 41946
// break ;
41944: GO 42022
// if GetClass ( i ) = 2 then
41946: LD_VAR 0 3
41950: PPUSH
41951: CALL_OW 257
41955: PUSH
41956: LD_INT 2
41958: EQUAL
41959: IFFALSE 41963
// continue ;
41961: GO 41929
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41963: LD_ADDR_VAR 0 11
41967: PUSH
41968: LD_VAR 0 11
41972: PPUSH
41973: LD_VAR 0 11
41977: PUSH
41978: LD_INT 1
41980: PLUS
41981: PPUSH
41982: LD_VAR 0 9
41986: PUSH
41987: LD_VAR 0 3
41991: ARRAY
41992: PPUSH
41993: CALL_OW 2
41997: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41998: LD_ADDR_VAR 0 4
42002: PUSH
42003: LD_VAR 0 4
42007: PUSH
42008: LD_VAR 0 9
42012: PUSH
42013: LD_VAR 0 3
42017: ARRAY
42018: DIFF
42019: ST_TO_ADDR
// end ;
42020: GO 41929
42022: POP
42023: POP
// if p then
42024: LD_VAR 0 11
42028: IFFALSE 42053
// result := Replace ( result , 2 , p ) ;
42030: LD_ADDR_VAR 0 2
42034: PUSH
42035: LD_VAR 0 2
42039: PPUSH
42040: LD_INT 2
42042: PPUSH
42043: LD_VAR 0 11
42047: PPUSH
42048: CALL_OW 1
42052: ST_TO_ADDR
// end ; exit ;
42053: GO 43441
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42055: LD_EXP 142
42059: PUSH
42060: LD_EXP 141
42064: PUSH
42065: LD_VAR 0 1
42069: ARRAY
42070: ARRAY
42071: NOT
42072: PUSH
42073: LD_EXP 115
42077: PUSH
42078: LD_VAR 0 1
42082: ARRAY
42083: PPUSH
42084: LD_INT 30
42086: PUSH
42087: LD_INT 3
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PPUSH
42094: CALL_OW 72
42098: AND
42099: PUSH
42100: LD_EXP 120
42104: PUSH
42105: LD_VAR 0 1
42109: ARRAY
42110: AND
42111: IFFALSE 42719
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42113: LD_ADDR_EXP 157
42117: PUSH
42118: LD_EXP 157
42122: PPUSH
42123: LD_VAR 0 1
42127: PPUSH
42128: LD_INT 5
42130: PPUSH
42131: CALL_OW 1
42135: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42136: LD_ADDR_VAR 0 2
42140: PUSH
42141: LD_INT 0
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 0
42149: PUSH
42150: LD_INT 0
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: ST_TO_ADDR
// if sci > 1 then
42159: LD_VAR 0 8
42163: PUSH
42164: LD_INT 1
42166: GREATER
42167: IFFALSE 42195
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42169: LD_ADDR_VAR 0 4
42173: PUSH
42174: LD_VAR 0 4
42178: PUSH
42179: LD_VAR 0 8
42183: PUSH
42184: LD_VAR 0 8
42188: PUSH
42189: LD_INT 1
42191: ARRAY
42192: DIFF
42193: DIFF
42194: ST_TO_ADDR
// if tmp and not sci then
42195: LD_VAR 0 4
42199: PUSH
42200: LD_VAR 0 8
42204: NOT
42205: AND
42206: IFFALSE 42275
// begin sort := SortBySkill ( tmp , 4 ) ;
42208: LD_ADDR_VAR 0 9
42212: PUSH
42213: LD_VAR 0 4
42217: PPUSH
42218: LD_INT 4
42220: PPUSH
42221: CALL 100235 0 2
42225: ST_TO_ADDR
// if sort then
42226: LD_VAR 0 9
42230: IFFALSE 42246
// p := sort [ 1 ] ;
42232: LD_ADDR_VAR 0 11
42236: PUSH
42237: LD_VAR 0 9
42241: PUSH
42242: LD_INT 1
42244: ARRAY
42245: ST_TO_ADDR
// if p then
42246: LD_VAR 0 11
42250: IFFALSE 42275
// result := Replace ( result , 4 , p ) ;
42252: LD_ADDR_VAR 0 2
42256: PUSH
42257: LD_VAR 0 2
42261: PPUSH
42262: LD_INT 4
42264: PPUSH
42265: LD_VAR 0 11
42269: PPUSH
42270: CALL_OW 1
42274: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42275: LD_ADDR_VAR 0 4
42279: PUSH
42280: LD_VAR 0 4
42284: PUSH
42285: LD_VAR 0 7
42289: DIFF
42290: ST_TO_ADDR
// if tmp and mech < 6 then
42291: LD_VAR 0 4
42295: PUSH
42296: LD_VAR 0 7
42300: PUSH
42301: LD_INT 6
42303: LESS
42304: AND
42305: IFFALSE 42493
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42307: LD_ADDR_VAR 0 9
42311: PUSH
42312: LD_VAR 0 4
42316: PUSH
42317: LD_VAR 0 8
42321: PUSH
42322: LD_VAR 0 7
42326: UNION
42327: DIFF
42328: PPUSH
42329: LD_INT 3
42331: PPUSH
42332: CALL 100235 0 2
42336: ST_TO_ADDR
// p := [ ] ;
42337: LD_ADDR_VAR 0 11
42341: PUSH
42342: EMPTY
42343: ST_TO_ADDR
// if sort then
42344: LD_VAR 0 9
42348: IFFALSE 42464
// for i = 1 to 6 - mech do
42350: LD_ADDR_VAR 0 3
42354: PUSH
42355: DOUBLE
42356: LD_INT 1
42358: DEC
42359: ST_TO_ADDR
42360: LD_INT 6
42362: PUSH
42363: LD_VAR 0 7
42367: MINUS
42368: PUSH
42369: FOR_TO
42370: IFFALSE 42462
// begin if i = sort then
42372: LD_VAR 0 3
42376: PUSH
42377: LD_VAR 0 9
42381: EQUAL
42382: IFFALSE 42386
// break ;
42384: GO 42462
// if GetClass ( i ) = 3 then
42386: LD_VAR 0 3
42390: PPUSH
42391: CALL_OW 257
42395: PUSH
42396: LD_INT 3
42398: EQUAL
42399: IFFALSE 42403
// continue ;
42401: GO 42369
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42403: LD_ADDR_VAR 0 11
42407: PUSH
42408: LD_VAR 0 11
42412: PPUSH
42413: LD_VAR 0 11
42417: PUSH
42418: LD_INT 1
42420: PLUS
42421: PPUSH
42422: LD_VAR 0 9
42426: PUSH
42427: LD_VAR 0 3
42431: ARRAY
42432: PPUSH
42433: CALL_OW 2
42437: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42438: LD_ADDR_VAR 0 4
42442: PUSH
42443: LD_VAR 0 4
42447: PUSH
42448: LD_VAR 0 9
42452: PUSH
42453: LD_VAR 0 3
42457: ARRAY
42458: DIFF
42459: ST_TO_ADDR
// end ;
42460: GO 42369
42462: POP
42463: POP
// if p then
42464: LD_VAR 0 11
42468: IFFALSE 42493
// result := Replace ( result , 3 , p ) ;
42470: LD_ADDR_VAR 0 2
42474: PUSH
42475: LD_VAR 0 2
42479: PPUSH
42480: LD_INT 3
42482: PPUSH
42483: LD_VAR 0 11
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42493: LD_ADDR_VAR 0 4
42497: PUSH
42498: LD_VAR 0 4
42502: PUSH
42503: LD_VAR 0 6
42507: DIFF
42508: ST_TO_ADDR
// if tmp and eng < 6 then
42509: LD_VAR 0 4
42513: PUSH
42514: LD_VAR 0 6
42518: PUSH
42519: LD_INT 6
42521: LESS
42522: AND
42523: IFFALSE 42717
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42525: LD_ADDR_VAR 0 9
42529: PUSH
42530: LD_VAR 0 4
42534: PUSH
42535: LD_VAR 0 8
42539: PUSH
42540: LD_VAR 0 7
42544: UNION
42545: PUSH
42546: LD_VAR 0 6
42550: UNION
42551: DIFF
42552: PPUSH
42553: LD_INT 2
42555: PPUSH
42556: CALL 100235 0 2
42560: ST_TO_ADDR
// p := [ ] ;
42561: LD_ADDR_VAR 0 11
42565: PUSH
42566: EMPTY
42567: ST_TO_ADDR
// if sort then
42568: LD_VAR 0 9
42572: IFFALSE 42688
// for i = 1 to 6 - eng do
42574: LD_ADDR_VAR 0 3
42578: PUSH
42579: DOUBLE
42580: LD_INT 1
42582: DEC
42583: ST_TO_ADDR
42584: LD_INT 6
42586: PUSH
42587: LD_VAR 0 6
42591: MINUS
42592: PUSH
42593: FOR_TO
42594: IFFALSE 42686
// begin if i = sort then
42596: LD_VAR 0 3
42600: PUSH
42601: LD_VAR 0 9
42605: EQUAL
42606: IFFALSE 42610
// break ;
42608: GO 42686
// if GetClass ( i ) = 2 then
42610: LD_VAR 0 3
42614: PPUSH
42615: CALL_OW 257
42619: PUSH
42620: LD_INT 2
42622: EQUAL
42623: IFFALSE 42627
// continue ;
42625: GO 42593
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42627: LD_ADDR_VAR 0 11
42631: PUSH
42632: LD_VAR 0 11
42636: PPUSH
42637: LD_VAR 0 11
42641: PUSH
42642: LD_INT 1
42644: PLUS
42645: PPUSH
42646: LD_VAR 0 9
42650: PUSH
42651: LD_VAR 0 3
42655: ARRAY
42656: PPUSH
42657: CALL_OW 2
42661: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42662: LD_ADDR_VAR 0 4
42666: PUSH
42667: LD_VAR 0 4
42671: PUSH
42672: LD_VAR 0 9
42676: PUSH
42677: LD_VAR 0 3
42681: ARRAY
42682: DIFF
42683: ST_TO_ADDR
// end ;
42684: GO 42593
42686: POP
42687: POP
// if p then
42688: LD_VAR 0 11
42692: IFFALSE 42717
// result := Replace ( result , 2 , p ) ;
42694: LD_ADDR_VAR 0 2
42698: PUSH
42699: LD_VAR 0 2
42703: PPUSH
42704: LD_INT 2
42706: PPUSH
42707: LD_VAR 0 11
42711: PPUSH
42712: CALL_OW 1
42716: ST_TO_ADDR
// end ; exit ;
42717: GO 43441
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42719: LD_EXP 142
42723: PUSH
42724: LD_EXP 141
42728: PUSH
42729: LD_VAR 0 1
42733: ARRAY
42734: ARRAY
42735: NOT
42736: PUSH
42737: LD_EXP 115
42741: PUSH
42742: LD_VAR 0 1
42746: ARRAY
42747: PPUSH
42748: LD_INT 30
42750: PUSH
42751: LD_INT 3
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PPUSH
42758: CALL_OW 72
42762: AND
42763: PUSH
42764: LD_EXP 120
42768: PUSH
42769: LD_VAR 0 1
42773: ARRAY
42774: NOT
42775: AND
42776: IFFALSE 43441
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42778: LD_ADDR_EXP 157
42782: PUSH
42783: LD_EXP 157
42787: PPUSH
42788: LD_VAR 0 1
42792: PPUSH
42793: LD_INT 6
42795: PPUSH
42796: CALL_OW 1
42800: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42801: LD_ADDR_VAR 0 2
42805: PUSH
42806: LD_INT 0
42808: PUSH
42809: LD_INT 0
42811: PUSH
42812: LD_INT 0
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: ST_TO_ADDR
// if sci >= 1 then
42824: LD_VAR 0 8
42828: PUSH
42829: LD_INT 1
42831: GREATEREQUAL
42832: IFFALSE 42854
// tmp := tmp diff sci [ 1 ] ;
42834: LD_ADDR_VAR 0 4
42838: PUSH
42839: LD_VAR 0 4
42843: PUSH
42844: LD_VAR 0 8
42848: PUSH
42849: LD_INT 1
42851: ARRAY
42852: DIFF
42853: ST_TO_ADDR
// if tmp and not sci then
42854: LD_VAR 0 4
42858: PUSH
42859: LD_VAR 0 8
42863: NOT
42864: AND
42865: IFFALSE 42934
// begin sort := SortBySkill ( tmp , 4 ) ;
42867: LD_ADDR_VAR 0 9
42871: PUSH
42872: LD_VAR 0 4
42876: PPUSH
42877: LD_INT 4
42879: PPUSH
42880: CALL 100235 0 2
42884: ST_TO_ADDR
// if sort then
42885: LD_VAR 0 9
42889: IFFALSE 42905
// p := sort [ 1 ] ;
42891: LD_ADDR_VAR 0 11
42895: PUSH
42896: LD_VAR 0 9
42900: PUSH
42901: LD_INT 1
42903: ARRAY
42904: ST_TO_ADDR
// if p then
42905: LD_VAR 0 11
42909: IFFALSE 42934
// result := Replace ( result , 4 , p ) ;
42911: LD_ADDR_VAR 0 2
42915: PUSH
42916: LD_VAR 0 2
42920: PPUSH
42921: LD_INT 4
42923: PPUSH
42924: LD_VAR 0 11
42928: PPUSH
42929: CALL_OW 1
42933: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42934: LD_ADDR_VAR 0 4
42938: PUSH
42939: LD_VAR 0 4
42943: PUSH
42944: LD_VAR 0 7
42948: DIFF
42949: ST_TO_ADDR
// if tmp and mech < 6 then
42950: LD_VAR 0 4
42954: PUSH
42955: LD_VAR 0 7
42959: PUSH
42960: LD_INT 6
42962: LESS
42963: AND
42964: IFFALSE 43146
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42966: LD_ADDR_VAR 0 9
42970: PUSH
42971: LD_VAR 0 4
42975: PUSH
42976: LD_VAR 0 7
42980: DIFF
42981: PPUSH
42982: LD_INT 3
42984: PPUSH
42985: CALL 100235 0 2
42989: ST_TO_ADDR
// p := [ ] ;
42990: LD_ADDR_VAR 0 11
42994: PUSH
42995: EMPTY
42996: ST_TO_ADDR
// if sort then
42997: LD_VAR 0 9
43001: IFFALSE 43117
// for i = 1 to 6 - mech do
43003: LD_ADDR_VAR 0 3
43007: PUSH
43008: DOUBLE
43009: LD_INT 1
43011: DEC
43012: ST_TO_ADDR
43013: LD_INT 6
43015: PUSH
43016: LD_VAR 0 7
43020: MINUS
43021: PUSH
43022: FOR_TO
43023: IFFALSE 43115
// begin if i = sort then
43025: LD_VAR 0 3
43029: PUSH
43030: LD_VAR 0 9
43034: EQUAL
43035: IFFALSE 43039
// break ;
43037: GO 43115
// if GetClass ( i ) = 3 then
43039: LD_VAR 0 3
43043: PPUSH
43044: CALL_OW 257
43048: PUSH
43049: LD_INT 3
43051: EQUAL
43052: IFFALSE 43056
// continue ;
43054: GO 43022
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43056: LD_ADDR_VAR 0 11
43060: PUSH
43061: LD_VAR 0 11
43065: PPUSH
43066: LD_VAR 0 11
43070: PUSH
43071: LD_INT 1
43073: PLUS
43074: PPUSH
43075: LD_VAR 0 9
43079: PUSH
43080: LD_VAR 0 3
43084: ARRAY
43085: PPUSH
43086: CALL_OW 2
43090: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43091: LD_ADDR_VAR 0 4
43095: PUSH
43096: LD_VAR 0 4
43100: PUSH
43101: LD_VAR 0 9
43105: PUSH
43106: LD_VAR 0 3
43110: ARRAY
43111: DIFF
43112: ST_TO_ADDR
// end ;
43113: GO 43022
43115: POP
43116: POP
// if p then
43117: LD_VAR 0 11
43121: IFFALSE 43146
// result := Replace ( result , 3 , p ) ;
43123: LD_ADDR_VAR 0 2
43127: PUSH
43128: LD_VAR 0 2
43132: PPUSH
43133: LD_INT 3
43135: PPUSH
43136: LD_VAR 0 11
43140: PPUSH
43141: CALL_OW 1
43145: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43146: LD_ADDR_VAR 0 4
43150: PUSH
43151: LD_VAR 0 4
43155: PUSH
43156: LD_VAR 0 6
43160: DIFF
43161: ST_TO_ADDR
// if tmp and eng < 4 then
43162: LD_VAR 0 4
43166: PUSH
43167: LD_VAR 0 6
43171: PUSH
43172: LD_INT 4
43174: LESS
43175: AND
43176: IFFALSE 43366
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43178: LD_ADDR_VAR 0 9
43182: PUSH
43183: LD_VAR 0 4
43187: PUSH
43188: LD_VAR 0 7
43192: PUSH
43193: LD_VAR 0 6
43197: UNION
43198: DIFF
43199: PPUSH
43200: LD_INT 2
43202: PPUSH
43203: CALL 100235 0 2
43207: ST_TO_ADDR
// p := [ ] ;
43208: LD_ADDR_VAR 0 11
43212: PUSH
43213: EMPTY
43214: ST_TO_ADDR
// if sort then
43215: LD_VAR 0 9
43219: IFFALSE 43335
// for i = 1 to 4 - eng do
43221: LD_ADDR_VAR 0 3
43225: PUSH
43226: DOUBLE
43227: LD_INT 1
43229: DEC
43230: ST_TO_ADDR
43231: LD_INT 4
43233: PUSH
43234: LD_VAR 0 6
43238: MINUS
43239: PUSH
43240: FOR_TO
43241: IFFALSE 43333
// begin if i = sort then
43243: LD_VAR 0 3
43247: PUSH
43248: LD_VAR 0 9
43252: EQUAL
43253: IFFALSE 43257
// break ;
43255: GO 43333
// if GetClass ( i ) = 2 then
43257: LD_VAR 0 3
43261: PPUSH
43262: CALL_OW 257
43266: PUSH
43267: LD_INT 2
43269: EQUAL
43270: IFFALSE 43274
// continue ;
43272: GO 43240
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43274: LD_ADDR_VAR 0 11
43278: PUSH
43279: LD_VAR 0 11
43283: PPUSH
43284: LD_VAR 0 11
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: PPUSH
43293: LD_VAR 0 9
43297: PUSH
43298: LD_VAR 0 3
43302: ARRAY
43303: PPUSH
43304: CALL_OW 2
43308: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43309: LD_ADDR_VAR 0 4
43313: PUSH
43314: LD_VAR 0 4
43318: PUSH
43319: LD_VAR 0 9
43323: PUSH
43324: LD_VAR 0 3
43328: ARRAY
43329: DIFF
43330: ST_TO_ADDR
// end ;
43331: GO 43240
43333: POP
43334: POP
// if p then
43335: LD_VAR 0 11
43339: IFFALSE 43364
// result := Replace ( result , 2 , p ) ;
43341: LD_ADDR_VAR 0 2
43345: PUSH
43346: LD_VAR 0 2
43350: PPUSH
43351: LD_INT 2
43353: PPUSH
43354: LD_VAR 0 11
43358: PPUSH
43359: CALL_OW 1
43363: ST_TO_ADDR
// end else
43364: GO 43410
// for i = eng downto 5 do
43366: LD_ADDR_VAR 0 3
43370: PUSH
43371: DOUBLE
43372: LD_VAR 0 6
43376: INC
43377: ST_TO_ADDR
43378: LD_INT 5
43380: PUSH
43381: FOR_DOWNTO
43382: IFFALSE 43408
// tmp := tmp union eng [ i ] ;
43384: LD_ADDR_VAR 0 4
43388: PUSH
43389: LD_VAR 0 4
43393: PUSH
43394: LD_VAR 0 6
43398: PUSH
43399: LD_VAR 0 3
43403: ARRAY
43404: UNION
43405: ST_TO_ADDR
43406: GO 43381
43408: POP
43409: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43410: LD_ADDR_VAR 0 2
43414: PUSH
43415: LD_VAR 0 2
43419: PPUSH
43420: LD_INT 1
43422: PPUSH
43423: LD_VAR 0 4
43427: PUSH
43428: LD_VAR 0 5
43432: DIFF
43433: PPUSH
43434: CALL_OW 1
43438: ST_TO_ADDR
// exit ;
43439: GO 43441
// end ; end ;
43441: LD_VAR 0 2
43445: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43446: LD_INT 0
43448: PPUSH
43449: PPUSH
43450: PPUSH
// if not mc_bases then
43451: LD_EXP 115
43455: NOT
43456: IFFALSE 43460
// exit ;
43458: GO 43566
// for i = 1 to mc_bases do
43460: LD_ADDR_VAR 0 2
43464: PUSH
43465: DOUBLE
43466: LD_INT 1
43468: DEC
43469: ST_TO_ADDR
43470: LD_EXP 115
43474: PUSH
43475: FOR_TO
43476: IFFALSE 43557
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43478: LD_ADDR_VAR 0 3
43482: PUSH
43483: LD_EXP 115
43487: PUSH
43488: LD_VAR 0 2
43492: ARRAY
43493: PPUSH
43494: LD_INT 21
43496: PUSH
43497: LD_INT 3
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: PUSH
43507: LD_INT 24
43509: PUSH
43510: LD_INT 1000
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PPUSH
43525: CALL_OW 72
43529: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43530: LD_ADDR_EXP 116
43534: PUSH
43535: LD_EXP 116
43539: PPUSH
43540: LD_VAR 0 2
43544: PPUSH
43545: LD_VAR 0 3
43549: PPUSH
43550: CALL_OW 1
43554: ST_TO_ADDR
// end ;
43555: GO 43475
43557: POP
43558: POP
// RaiseSailEvent ( 101 ) ;
43559: LD_INT 101
43561: PPUSH
43562: CALL_OW 427
// end ;
43566: LD_VAR 0 1
43570: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43571: LD_INT 0
43573: PPUSH
43574: PPUSH
43575: PPUSH
43576: PPUSH
43577: PPUSH
43578: PPUSH
43579: PPUSH
// if not mc_bases then
43580: LD_EXP 115
43584: NOT
43585: IFFALSE 43589
// exit ;
43587: GO 44151
// for i = 1 to mc_bases do
43589: LD_ADDR_VAR 0 2
43593: PUSH
43594: DOUBLE
43595: LD_INT 1
43597: DEC
43598: ST_TO_ADDR
43599: LD_EXP 115
43603: PUSH
43604: FOR_TO
43605: IFFALSE 44142
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43607: LD_ADDR_VAR 0 5
43611: PUSH
43612: LD_EXP 115
43616: PUSH
43617: LD_VAR 0 2
43621: ARRAY
43622: PUSH
43623: LD_EXP 144
43627: PUSH
43628: LD_VAR 0 2
43632: ARRAY
43633: UNION
43634: PPUSH
43635: LD_INT 21
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: LD_INT 1
43647: PUSH
43648: LD_INT 3
43650: PUSH
43651: LD_INT 54
43653: PUSH
43654: EMPTY
43655: LIST
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 3
43663: PUSH
43664: LD_INT 24
43666: PUSH
43667: LD_INT 1000
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: LIST
43682: PUSH
43683: EMPTY
43684: LIST
43685: LIST
43686: PPUSH
43687: CALL_OW 72
43691: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43692: LD_ADDR_VAR 0 6
43696: PUSH
43697: LD_EXP 115
43701: PUSH
43702: LD_VAR 0 2
43706: ARRAY
43707: PPUSH
43708: LD_INT 21
43710: PUSH
43711: LD_INT 1
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 1
43720: PUSH
43721: LD_INT 3
43723: PUSH
43724: LD_INT 54
43726: PUSH
43727: EMPTY
43728: LIST
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 3
43736: PUSH
43737: LD_INT 24
43739: PUSH
43740: LD_INT 250
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: LIST
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PPUSH
43760: CALL_OW 72
43764: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43765: LD_ADDR_VAR 0 7
43769: PUSH
43770: LD_VAR 0 5
43774: PUSH
43775: LD_VAR 0 6
43779: DIFF
43780: ST_TO_ADDR
// if not need_heal_1 then
43781: LD_VAR 0 6
43785: NOT
43786: IFFALSE 43819
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43788: LD_ADDR_EXP 118
43792: PUSH
43793: LD_EXP 118
43797: PPUSH
43798: LD_VAR 0 2
43802: PUSH
43803: LD_INT 1
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PPUSH
43810: EMPTY
43811: PPUSH
43812: CALL 70353 0 3
43816: ST_TO_ADDR
43817: GO 43889
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43819: LD_ADDR_EXP 118
43823: PUSH
43824: LD_EXP 118
43828: PPUSH
43829: LD_VAR 0 2
43833: PUSH
43834: LD_INT 1
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PPUSH
43841: LD_EXP 118
43845: PUSH
43846: LD_VAR 0 2
43850: ARRAY
43851: PUSH
43852: LD_INT 1
43854: ARRAY
43855: PPUSH
43856: LD_INT 3
43858: PUSH
43859: LD_INT 24
43861: PUSH
43862: LD_INT 1000
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PPUSH
43873: CALL_OW 72
43877: PUSH
43878: LD_VAR 0 6
43882: UNION
43883: PPUSH
43884: CALL 70353 0 3
43888: ST_TO_ADDR
// if not need_heal_2 then
43889: LD_VAR 0 7
43893: NOT
43894: IFFALSE 43927
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43896: LD_ADDR_EXP 118
43900: PUSH
43901: LD_EXP 118
43905: PPUSH
43906: LD_VAR 0 2
43910: PUSH
43911: LD_INT 2
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PPUSH
43918: EMPTY
43919: PPUSH
43920: CALL 70353 0 3
43924: ST_TO_ADDR
43925: GO 43959
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43927: LD_ADDR_EXP 118
43931: PUSH
43932: LD_EXP 118
43936: PPUSH
43937: LD_VAR 0 2
43941: PUSH
43942: LD_INT 2
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PPUSH
43949: LD_VAR 0 7
43953: PPUSH
43954: CALL 70353 0 3
43958: ST_TO_ADDR
// if need_heal_2 then
43959: LD_VAR 0 7
43963: IFFALSE 44124
// for j in need_heal_2 do
43965: LD_ADDR_VAR 0 3
43969: PUSH
43970: LD_VAR 0 7
43974: PUSH
43975: FOR_IN
43976: IFFALSE 44122
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43978: LD_ADDR_VAR 0 5
43982: PUSH
43983: LD_EXP 115
43987: PUSH
43988: LD_VAR 0 2
43992: ARRAY
43993: PPUSH
43994: LD_INT 2
43996: PUSH
43997: LD_INT 30
43999: PUSH
44000: LD_INT 6
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 30
44009: PUSH
44010: LD_INT 7
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 30
44019: PUSH
44020: LD_INT 8
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 30
44029: PUSH
44030: LD_INT 0
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: PUSH
44037: LD_INT 30
44039: PUSH
44040: LD_INT 1
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: PPUSH
44055: CALL_OW 72
44059: ST_TO_ADDR
// if tmp then
44060: LD_VAR 0 5
44064: IFFALSE 44120
// begin k := NearestUnitToUnit ( tmp , j ) ;
44066: LD_ADDR_VAR 0 4
44070: PUSH
44071: LD_VAR 0 5
44075: PPUSH
44076: LD_VAR 0 3
44080: PPUSH
44081: CALL_OW 74
44085: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44086: LD_VAR 0 3
44090: PPUSH
44091: LD_VAR 0 4
44095: PPUSH
44096: CALL_OW 296
44100: PUSH
44101: LD_INT 5
44103: GREATER
44104: IFFALSE 44120
// ComMoveToNearbyEntrance ( j , k ) ;
44106: LD_VAR 0 3
44110: PPUSH
44111: LD_VAR 0 4
44115: PPUSH
44116: CALL 102596 0 2
// end ; end ;
44120: GO 43975
44122: POP
44123: POP
// if not need_heal_1 and not need_heal_2 then
44124: LD_VAR 0 6
44128: NOT
44129: PUSH
44130: LD_VAR 0 7
44134: NOT
44135: AND
44136: IFFALSE 44140
// continue ;
44138: GO 43604
// end ;
44140: GO 43604
44142: POP
44143: POP
// RaiseSailEvent ( 102 ) ;
44144: LD_INT 102
44146: PPUSH
44147: CALL_OW 427
// end ;
44151: LD_VAR 0 1
44155: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44156: LD_INT 0
44158: PPUSH
44159: PPUSH
44160: PPUSH
44161: PPUSH
44162: PPUSH
44163: PPUSH
44164: PPUSH
44165: PPUSH
// if not mc_bases then
44166: LD_EXP 115
44170: NOT
44171: IFFALSE 44175
// exit ;
44173: GO 45036
// for i = 1 to mc_bases do
44175: LD_ADDR_VAR 0 2
44179: PUSH
44180: DOUBLE
44181: LD_INT 1
44183: DEC
44184: ST_TO_ADDR
44185: LD_EXP 115
44189: PUSH
44190: FOR_TO
44191: IFFALSE 45034
// begin if not mc_building_need_repair [ i ] then
44193: LD_EXP 116
44197: PUSH
44198: LD_VAR 0 2
44202: ARRAY
44203: NOT
44204: IFFALSE 44391
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44206: LD_ADDR_VAR 0 6
44210: PUSH
44211: LD_EXP 134
44215: PUSH
44216: LD_VAR 0 2
44220: ARRAY
44221: PPUSH
44222: LD_INT 3
44224: PUSH
44225: LD_INT 24
44227: PUSH
44228: LD_INT 1000
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 2
44241: PUSH
44242: LD_INT 34
44244: PUSH
44245: LD_INT 13
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 34
44254: PUSH
44255: LD_INT 52
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 34
44264: PUSH
44265: LD_EXP 101
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PPUSH
44284: CALL_OW 72
44288: ST_TO_ADDR
// if cranes then
44289: LD_VAR 0 6
44293: IFFALSE 44355
// for j in cranes do
44295: LD_ADDR_VAR 0 3
44299: PUSH
44300: LD_VAR 0 6
44304: PUSH
44305: FOR_IN
44306: IFFALSE 44353
// if not IsInArea ( j , mc_parking [ i ] ) then
44308: LD_VAR 0 3
44312: PPUSH
44313: LD_EXP 139
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PPUSH
44324: CALL_OW 308
44328: NOT
44329: IFFALSE 44351
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44331: LD_VAR 0 3
44335: PPUSH
44336: LD_EXP 139
44340: PUSH
44341: LD_VAR 0 2
44345: ARRAY
44346: PPUSH
44347: CALL_OW 113
44351: GO 44305
44353: POP
44354: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44355: LD_ADDR_EXP 117
44359: PUSH
44360: LD_EXP 117
44364: PPUSH
44365: LD_VAR 0 2
44369: PPUSH
44370: EMPTY
44371: PPUSH
44372: CALL_OW 1
44376: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44377: LD_VAR 0 2
44381: PPUSH
44382: LD_INT 101
44384: PPUSH
44385: CALL 39279 0 2
// continue ;
44389: GO 44190
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44391: LD_ADDR_EXP 121
44395: PUSH
44396: LD_EXP 121
44400: PPUSH
44401: LD_VAR 0 2
44405: PPUSH
44406: EMPTY
44407: PPUSH
44408: CALL_OW 1
44412: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44413: LD_VAR 0 2
44417: PPUSH
44418: LD_INT 103
44420: PPUSH
44421: CALL 39279 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44425: LD_ADDR_VAR 0 5
44429: PUSH
44430: LD_EXP 115
44434: PUSH
44435: LD_VAR 0 2
44439: ARRAY
44440: PUSH
44441: LD_EXP 144
44445: PUSH
44446: LD_VAR 0 2
44450: ARRAY
44451: UNION
44452: PPUSH
44453: LD_INT 2
44455: PUSH
44456: LD_INT 25
44458: PUSH
44459: LD_INT 2
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 25
44468: PUSH
44469: LD_INT 16
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: LIST
44480: PUSH
44481: EMPTY
44482: LIST
44483: PPUSH
44484: CALL_OW 72
44488: PUSH
44489: LD_EXP 118
44493: PUSH
44494: LD_VAR 0 2
44498: ARRAY
44499: PUSH
44500: LD_INT 1
44502: ARRAY
44503: PUSH
44504: LD_EXP 118
44508: PUSH
44509: LD_VAR 0 2
44513: ARRAY
44514: PUSH
44515: LD_INT 2
44517: ARRAY
44518: UNION
44519: DIFF
44520: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44521: LD_ADDR_VAR 0 6
44525: PUSH
44526: LD_EXP 134
44530: PUSH
44531: LD_VAR 0 2
44535: ARRAY
44536: PPUSH
44537: LD_INT 2
44539: PUSH
44540: LD_INT 34
44542: PUSH
44543: LD_INT 13
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 34
44552: PUSH
44553: LD_INT 52
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 34
44562: PUSH
44563: LD_EXP 101
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: PPUSH
44578: CALL_OW 72
44582: ST_TO_ADDR
// if cranes then
44583: LD_VAR 0 6
44587: IFFALSE 44723
// begin for j in cranes do
44589: LD_ADDR_VAR 0 3
44593: PUSH
44594: LD_VAR 0 6
44598: PUSH
44599: FOR_IN
44600: IFFALSE 44721
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44602: LD_VAR 0 3
44606: PPUSH
44607: CALL_OW 256
44611: PUSH
44612: LD_INT 1000
44614: EQUAL
44615: PUSH
44616: LD_VAR 0 3
44620: PPUSH
44621: CALL_OW 314
44625: NOT
44626: AND
44627: IFFALSE 44661
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44629: LD_VAR 0 3
44633: PPUSH
44634: LD_EXP 116
44638: PUSH
44639: LD_VAR 0 2
44643: ARRAY
44644: PPUSH
44645: LD_VAR 0 3
44649: PPUSH
44650: CALL_OW 74
44654: PPUSH
44655: CALL_OW 130
44659: GO 44719
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44661: LD_VAR 0 3
44665: PPUSH
44666: CALL_OW 256
44670: PUSH
44671: LD_INT 500
44673: LESS
44674: PUSH
44675: LD_VAR 0 3
44679: PPUSH
44680: LD_EXP 139
44684: PUSH
44685: LD_VAR 0 2
44689: ARRAY
44690: PPUSH
44691: CALL_OW 308
44695: NOT
44696: AND
44697: IFFALSE 44719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44699: LD_VAR 0 3
44703: PPUSH
44704: LD_EXP 139
44708: PUSH
44709: LD_VAR 0 2
44713: ARRAY
44714: PPUSH
44715: CALL_OW 113
// end ;
44719: GO 44599
44721: POP
44722: POP
// end ; if tmp > 3 then
44723: LD_VAR 0 5
44727: PUSH
44728: LD_INT 3
44730: GREATER
44731: IFFALSE 44751
// tmp := ShrinkArray ( tmp , 4 ) ;
44733: LD_ADDR_VAR 0 5
44737: PUSH
44738: LD_VAR 0 5
44742: PPUSH
44743: LD_INT 4
44745: PPUSH
44746: CALL 102044 0 2
44750: ST_TO_ADDR
// if not tmp then
44751: LD_VAR 0 5
44755: NOT
44756: IFFALSE 44760
// continue ;
44758: GO 44190
// for j in tmp do
44760: LD_ADDR_VAR 0 3
44764: PUSH
44765: LD_VAR 0 5
44769: PUSH
44770: FOR_IN
44771: IFFALSE 45030
// begin if IsInUnit ( j ) then
44773: LD_VAR 0 3
44777: PPUSH
44778: CALL_OW 310
44782: IFFALSE 44793
// ComExitBuilding ( j ) ;
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44793: LD_VAR 0 3
44797: PUSH
44798: LD_EXP 117
44802: PUSH
44803: LD_VAR 0 2
44807: ARRAY
44808: IN
44809: NOT
44810: IFFALSE 44868
// begin SetTag ( j , 101 ) ;
44812: LD_VAR 0 3
44816: PPUSH
44817: LD_INT 101
44819: PPUSH
44820: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44824: LD_ADDR_EXP 117
44828: PUSH
44829: LD_EXP 117
44833: PPUSH
44834: LD_VAR 0 2
44838: PUSH
44839: LD_EXP 117
44843: PUSH
44844: LD_VAR 0 2
44848: ARRAY
44849: PUSH
44850: LD_INT 1
44852: PLUS
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PPUSH
44858: LD_VAR 0 3
44862: PPUSH
44863: CALL 70353 0 3
44867: ST_TO_ADDR
// end ; wait ( 1 ) ;
44868: LD_INT 1
44870: PPUSH
44871: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44875: LD_ADDR_VAR 0 7
44879: PUSH
44880: LD_EXP 116
44884: PUSH
44885: LD_VAR 0 2
44889: ARRAY
44890: ST_TO_ADDR
// if mc_scan [ i ] then
44891: LD_EXP 138
44895: PUSH
44896: LD_VAR 0 2
44900: ARRAY
44901: IFFALSE 44963
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44903: LD_ADDR_VAR 0 7
44907: PUSH
44908: LD_EXP 116
44912: PUSH
44913: LD_VAR 0 2
44917: ARRAY
44918: PPUSH
44919: LD_INT 3
44921: PUSH
44922: LD_INT 30
44924: PUSH
44925: LD_INT 32
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 30
44934: PUSH
44935: LD_INT 33
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 30
44944: PUSH
44945: LD_INT 31
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: PPUSH
44958: CALL_OW 72
44962: ST_TO_ADDR
// if not to_repair_tmp then
44963: LD_VAR 0 7
44967: NOT
44968: IFFALSE 44972
// continue ;
44970: GO 44770
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44972: LD_ADDR_VAR 0 8
44976: PUSH
44977: LD_VAR 0 7
44981: PPUSH
44982: LD_VAR 0 3
44986: PPUSH
44987: CALL_OW 74
44991: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
44992: LD_VAR 0 8
44996: PPUSH
44997: LD_INT 16
44999: PPUSH
45000: CALL 72946 0 2
45004: PUSH
45005: LD_INT 4
45007: ARRAY
45008: PUSH
45009: LD_INT 10
45011: LESS
45012: IFFALSE 45028
// ComRepairBuilding ( j , to_repair ) ;
45014: LD_VAR 0 3
45018: PPUSH
45019: LD_VAR 0 8
45023: PPUSH
45024: CALL_OW 130
// end ;
45028: GO 44770
45030: POP
45031: POP
// end ;
45032: GO 44190
45034: POP
45035: POP
// end ;
45036: LD_VAR 0 1
45040: RET
// export function MC_Heal ; var i , j , tmp ; begin
45041: LD_INT 0
45043: PPUSH
45044: PPUSH
45045: PPUSH
45046: PPUSH
// if not mc_bases then
45047: LD_EXP 115
45051: NOT
45052: IFFALSE 45056
// exit ;
45054: GO 45458
// for i = 1 to mc_bases do
45056: LD_ADDR_VAR 0 2
45060: PUSH
45061: DOUBLE
45062: LD_INT 1
45064: DEC
45065: ST_TO_ADDR
45066: LD_EXP 115
45070: PUSH
45071: FOR_TO
45072: IFFALSE 45456
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45074: LD_EXP 118
45078: PUSH
45079: LD_VAR 0 2
45083: ARRAY
45084: PUSH
45085: LD_INT 1
45087: ARRAY
45088: NOT
45089: PUSH
45090: LD_EXP 118
45094: PUSH
45095: LD_VAR 0 2
45099: ARRAY
45100: PUSH
45101: LD_INT 2
45103: ARRAY
45104: NOT
45105: AND
45106: IFFALSE 45144
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45108: LD_ADDR_EXP 119
45112: PUSH
45113: LD_EXP 119
45117: PPUSH
45118: LD_VAR 0 2
45122: PPUSH
45123: EMPTY
45124: PPUSH
45125: CALL_OW 1
45129: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45130: LD_VAR 0 2
45134: PPUSH
45135: LD_INT 102
45137: PPUSH
45138: CALL 39279 0 2
// continue ;
45142: GO 45071
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45144: LD_ADDR_VAR 0 4
45148: PUSH
45149: LD_EXP 115
45153: PUSH
45154: LD_VAR 0 2
45158: ARRAY
45159: PPUSH
45160: LD_INT 25
45162: PUSH
45163: LD_INT 4
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: PPUSH
45170: CALL_OW 72
45174: ST_TO_ADDR
// if not tmp then
45175: LD_VAR 0 4
45179: NOT
45180: IFFALSE 45184
// continue ;
45182: GO 45071
// if mc_taming [ i ] then
45184: LD_EXP 146
45188: PUSH
45189: LD_VAR 0 2
45193: ARRAY
45194: IFFALSE 45218
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45196: LD_ADDR_EXP 146
45200: PUSH
45201: LD_EXP 146
45205: PPUSH
45206: LD_VAR 0 2
45210: PPUSH
45211: EMPTY
45212: PPUSH
45213: CALL_OW 1
45217: ST_TO_ADDR
// for j in tmp do
45218: LD_ADDR_VAR 0 3
45222: PUSH
45223: LD_VAR 0 4
45227: PUSH
45228: FOR_IN
45229: IFFALSE 45452
// begin if IsInUnit ( j ) then
45231: LD_VAR 0 3
45235: PPUSH
45236: CALL_OW 310
45240: IFFALSE 45251
// ComExitBuilding ( j ) ;
45242: LD_VAR 0 3
45246: PPUSH
45247: CALL_OW 122
// if not j in mc_healers [ i ] then
45251: LD_VAR 0 3
45255: PUSH
45256: LD_EXP 119
45260: PUSH
45261: LD_VAR 0 2
45265: ARRAY
45266: IN
45267: NOT
45268: IFFALSE 45314
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45270: LD_ADDR_EXP 119
45274: PUSH
45275: LD_EXP 119
45279: PPUSH
45280: LD_VAR 0 2
45284: PUSH
45285: LD_EXP 119
45289: PUSH
45290: LD_VAR 0 2
45294: ARRAY
45295: PUSH
45296: LD_INT 1
45298: PLUS
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PPUSH
45304: LD_VAR 0 3
45308: PPUSH
45309: CALL 70353 0 3
45313: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45314: LD_VAR 0 3
45318: PPUSH
45319: CALL_OW 110
45323: PUSH
45324: LD_INT 102
45326: NONEQUAL
45327: IFFALSE 45341
// SetTag ( j , 102 ) ;
45329: LD_VAR 0 3
45333: PPUSH
45334: LD_INT 102
45336: PPUSH
45337: CALL_OW 109
// Wait ( 3 ) ;
45341: LD_INT 3
45343: PPUSH
45344: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45348: LD_EXP 118
45352: PUSH
45353: LD_VAR 0 2
45357: ARRAY
45358: PUSH
45359: LD_INT 1
45361: ARRAY
45362: IFFALSE 45394
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45364: LD_VAR 0 3
45368: PPUSH
45369: LD_EXP 118
45373: PUSH
45374: LD_VAR 0 2
45378: ARRAY
45379: PUSH
45380: LD_INT 1
45382: ARRAY
45383: PUSH
45384: LD_INT 1
45386: ARRAY
45387: PPUSH
45388: CALL_OW 128
45392: GO 45450
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45394: LD_VAR 0 3
45398: PPUSH
45399: CALL_OW 314
45403: NOT
45404: PUSH
45405: LD_EXP 118
45409: PUSH
45410: LD_VAR 0 2
45414: ARRAY
45415: PUSH
45416: LD_INT 2
45418: ARRAY
45419: AND
45420: IFFALSE 45450
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45422: LD_VAR 0 3
45426: PPUSH
45427: LD_EXP 118
45431: PUSH
45432: LD_VAR 0 2
45436: ARRAY
45437: PUSH
45438: LD_INT 2
45440: ARRAY
45441: PUSH
45442: LD_INT 1
45444: ARRAY
45445: PPUSH
45446: CALL_OW 128
// end ;
45450: GO 45228
45452: POP
45453: POP
// end ;
45454: GO 45071
45456: POP
45457: POP
// end ;
45458: LD_VAR 0 1
45462: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45463: LD_INT 0
45465: PPUSH
45466: PPUSH
45467: PPUSH
45468: PPUSH
45469: PPUSH
// if not mc_bases then
45470: LD_EXP 115
45474: NOT
45475: IFFALSE 45479
// exit ;
45477: GO 46650
// for i = 1 to mc_bases do
45479: LD_ADDR_VAR 0 2
45483: PUSH
45484: DOUBLE
45485: LD_INT 1
45487: DEC
45488: ST_TO_ADDR
45489: LD_EXP 115
45493: PUSH
45494: FOR_TO
45495: IFFALSE 46648
// begin if mc_scan [ i ] then
45497: LD_EXP 138
45501: PUSH
45502: LD_VAR 0 2
45506: ARRAY
45507: IFFALSE 45511
// continue ;
45509: GO 45494
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45511: LD_EXP 120
45515: PUSH
45516: LD_VAR 0 2
45520: ARRAY
45521: NOT
45522: PUSH
45523: LD_EXP 122
45527: PUSH
45528: LD_VAR 0 2
45532: ARRAY
45533: NOT
45534: AND
45535: PUSH
45536: LD_EXP 121
45540: PUSH
45541: LD_VAR 0 2
45545: ARRAY
45546: AND
45547: IFFALSE 45585
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45549: LD_ADDR_EXP 121
45553: PUSH
45554: LD_EXP 121
45558: PPUSH
45559: LD_VAR 0 2
45563: PPUSH
45564: EMPTY
45565: PPUSH
45566: CALL_OW 1
45570: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45571: LD_VAR 0 2
45575: PPUSH
45576: LD_INT 103
45578: PPUSH
45579: CALL 39279 0 2
// continue ;
45583: GO 45494
// end ; if mc_construct_list [ i ] then
45585: LD_EXP 122
45589: PUSH
45590: LD_VAR 0 2
45594: ARRAY
45595: IFFALSE 45815
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45597: LD_ADDR_VAR 0 4
45601: PUSH
45602: LD_EXP 115
45606: PUSH
45607: LD_VAR 0 2
45611: ARRAY
45612: PPUSH
45613: LD_INT 25
45615: PUSH
45616: LD_INT 2
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PPUSH
45623: CALL_OW 72
45627: PUSH
45628: LD_EXP 117
45632: PUSH
45633: LD_VAR 0 2
45637: ARRAY
45638: DIFF
45639: ST_TO_ADDR
// if not tmp then
45640: LD_VAR 0 4
45644: NOT
45645: IFFALSE 45649
// continue ;
45647: GO 45494
// for j in tmp do
45649: LD_ADDR_VAR 0 3
45653: PUSH
45654: LD_VAR 0 4
45658: PUSH
45659: FOR_IN
45660: IFFALSE 45811
// begin if not mc_builders [ i ] then
45662: LD_EXP 121
45666: PUSH
45667: LD_VAR 0 2
45671: ARRAY
45672: NOT
45673: IFFALSE 45731
// begin SetTag ( j , 103 ) ;
45675: LD_VAR 0 3
45679: PPUSH
45680: LD_INT 103
45682: PPUSH
45683: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45687: LD_ADDR_EXP 121
45691: PUSH
45692: LD_EXP 121
45696: PPUSH
45697: LD_VAR 0 2
45701: PUSH
45702: LD_EXP 121
45706: PUSH
45707: LD_VAR 0 2
45711: ARRAY
45712: PUSH
45713: LD_INT 1
45715: PLUS
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PPUSH
45721: LD_VAR 0 3
45725: PPUSH
45726: CALL 70353 0 3
45730: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45731: LD_VAR 0 3
45735: PPUSH
45736: CALL_OW 310
45740: IFFALSE 45751
// ComExitBuilding ( j ) ;
45742: LD_VAR 0 3
45746: PPUSH
45747: CALL_OW 122
// wait ( 3 ) ;
45751: LD_INT 3
45753: PPUSH
45754: CALL_OW 67
// if not mc_construct_list [ i ] then
45758: LD_EXP 122
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: NOT
45769: IFFALSE 45773
// break ;
45771: GO 45811
// if not HasTask ( j ) then
45773: LD_VAR 0 3
45777: PPUSH
45778: CALL_OW 314
45782: NOT
45783: IFFALSE 45809
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45785: LD_VAR 0 3
45789: PPUSH
45790: LD_EXP 122
45794: PUSH
45795: LD_VAR 0 2
45799: ARRAY
45800: PUSH
45801: LD_INT 1
45803: ARRAY
45804: PPUSH
45805: CALL 73210 0 2
// end ;
45809: GO 45659
45811: POP
45812: POP
// end else
45813: GO 46646
// if mc_build_list [ i ] then
45815: LD_EXP 120
45819: PUSH
45820: LD_VAR 0 2
45824: ARRAY
45825: IFFALSE 46646
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45827: LD_ADDR_VAR 0 5
45831: PUSH
45832: LD_EXP 115
45836: PUSH
45837: LD_VAR 0 2
45841: ARRAY
45842: PPUSH
45843: LD_INT 2
45845: PUSH
45846: LD_INT 30
45848: PUSH
45849: LD_INT 0
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 30
45858: PUSH
45859: LD_INT 1
45861: PUSH
45862: EMPTY
45863: LIST
45864: LIST
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: LIST
45870: PPUSH
45871: CALL_OW 72
45875: ST_TO_ADDR
// if depot then
45876: LD_VAR 0 5
45880: IFFALSE 45898
// depot := depot [ 1 ] else
45882: LD_ADDR_VAR 0 5
45886: PUSH
45887: LD_VAR 0 5
45891: PUSH
45892: LD_INT 1
45894: ARRAY
45895: ST_TO_ADDR
45896: GO 45906
// depot := 0 ;
45898: LD_ADDR_VAR 0 5
45902: PUSH
45903: LD_INT 0
45905: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45906: LD_EXP 120
45910: PUSH
45911: LD_VAR 0 2
45915: ARRAY
45916: PUSH
45917: LD_INT 1
45919: ARRAY
45920: PUSH
45921: LD_INT 1
45923: ARRAY
45924: PPUSH
45925: CALL 73034 0 1
45929: PUSH
45930: LD_EXP 115
45934: PUSH
45935: LD_VAR 0 2
45939: ARRAY
45940: PPUSH
45941: LD_INT 2
45943: PUSH
45944: LD_INT 30
45946: PUSH
45947: LD_INT 2
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 30
45956: PUSH
45957: LD_INT 3
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: LIST
45968: PPUSH
45969: CALL_OW 72
45973: NOT
45974: AND
45975: IFFALSE 46080
// begin for j = 1 to mc_build_list [ i ] do
45977: LD_ADDR_VAR 0 3
45981: PUSH
45982: DOUBLE
45983: LD_INT 1
45985: DEC
45986: ST_TO_ADDR
45987: LD_EXP 120
45991: PUSH
45992: LD_VAR 0 2
45996: ARRAY
45997: PUSH
45998: FOR_TO
45999: IFFALSE 46078
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46001: LD_EXP 120
46005: PUSH
46006: LD_VAR 0 2
46010: ARRAY
46011: PUSH
46012: LD_VAR 0 3
46016: ARRAY
46017: PUSH
46018: LD_INT 1
46020: ARRAY
46021: PUSH
46022: LD_INT 2
46024: EQUAL
46025: IFFALSE 46076
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46027: LD_ADDR_EXP 120
46031: PUSH
46032: LD_EXP 120
46036: PPUSH
46037: LD_VAR 0 2
46041: PPUSH
46042: LD_EXP 120
46046: PUSH
46047: LD_VAR 0 2
46051: ARRAY
46052: PPUSH
46053: LD_VAR 0 3
46057: PPUSH
46058: LD_INT 1
46060: PPUSH
46061: LD_INT 0
46063: PPUSH
46064: CALL 69771 0 4
46068: PPUSH
46069: CALL_OW 1
46073: ST_TO_ADDR
// break ;
46074: GO 46078
// end ;
46076: GO 45998
46078: POP
46079: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46080: LD_EXP 120
46084: PUSH
46085: LD_VAR 0 2
46089: ARRAY
46090: PUSH
46091: LD_INT 1
46093: ARRAY
46094: PUSH
46095: LD_INT 1
46097: ARRAY
46098: PUSH
46099: LD_INT 0
46101: EQUAL
46102: PUSH
46103: LD_VAR 0 5
46107: PUSH
46108: LD_VAR 0 5
46112: PPUSH
46113: LD_EXP 120
46117: PUSH
46118: LD_VAR 0 2
46122: ARRAY
46123: PUSH
46124: LD_INT 1
46126: ARRAY
46127: PUSH
46128: LD_INT 1
46130: ARRAY
46131: PPUSH
46132: LD_EXP 120
46136: PUSH
46137: LD_VAR 0 2
46141: ARRAY
46142: PUSH
46143: LD_INT 1
46145: ARRAY
46146: PUSH
46147: LD_INT 2
46149: ARRAY
46150: PPUSH
46151: LD_EXP 120
46155: PUSH
46156: LD_VAR 0 2
46160: ARRAY
46161: PUSH
46162: LD_INT 1
46164: ARRAY
46165: PUSH
46166: LD_INT 3
46168: ARRAY
46169: PPUSH
46170: LD_EXP 120
46174: PUSH
46175: LD_VAR 0 2
46179: ARRAY
46180: PUSH
46181: LD_INT 1
46183: ARRAY
46184: PUSH
46185: LD_INT 4
46187: ARRAY
46188: PPUSH
46189: CALL 78101 0 5
46193: AND
46194: OR
46195: IFFALSE 46476
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46197: LD_ADDR_VAR 0 4
46201: PUSH
46202: LD_EXP 115
46206: PUSH
46207: LD_VAR 0 2
46211: ARRAY
46212: PPUSH
46213: LD_INT 25
46215: PUSH
46216: LD_INT 2
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PPUSH
46223: CALL_OW 72
46227: PUSH
46228: LD_EXP 117
46232: PUSH
46233: LD_VAR 0 2
46237: ARRAY
46238: DIFF
46239: ST_TO_ADDR
// if not tmp then
46240: LD_VAR 0 4
46244: NOT
46245: IFFALSE 46249
// continue ;
46247: GO 45494
// for j in tmp do
46249: LD_ADDR_VAR 0 3
46253: PUSH
46254: LD_VAR 0 4
46258: PUSH
46259: FOR_IN
46260: IFFALSE 46472
// begin if not mc_builders [ i ] then
46262: LD_EXP 121
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: NOT
46273: IFFALSE 46331
// begin SetTag ( j , 103 ) ;
46275: LD_VAR 0 3
46279: PPUSH
46280: LD_INT 103
46282: PPUSH
46283: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46287: LD_ADDR_EXP 121
46291: PUSH
46292: LD_EXP 121
46296: PPUSH
46297: LD_VAR 0 2
46301: PUSH
46302: LD_EXP 121
46306: PUSH
46307: LD_VAR 0 2
46311: ARRAY
46312: PUSH
46313: LD_INT 1
46315: PLUS
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PPUSH
46321: LD_VAR 0 3
46325: PPUSH
46326: CALL 70353 0 3
46330: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46331: LD_VAR 0 3
46335: PPUSH
46336: CALL_OW 310
46340: IFFALSE 46351
// ComExitBuilding ( j ) ;
46342: LD_VAR 0 3
46346: PPUSH
46347: CALL_OW 122
// wait ( 3 ) ;
46351: LD_INT 3
46353: PPUSH
46354: CALL_OW 67
// if not mc_build_list [ i ] then
46358: LD_EXP 120
46362: PUSH
46363: LD_VAR 0 2
46367: ARRAY
46368: NOT
46369: IFFALSE 46373
// break ;
46371: GO 46472
// if not HasTask ( j ) then
46373: LD_VAR 0 3
46377: PPUSH
46378: CALL_OW 314
46382: NOT
46383: IFFALSE 46470
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46385: LD_VAR 0 3
46389: PPUSH
46390: LD_EXP 120
46394: PUSH
46395: LD_VAR 0 2
46399: ARRAY
46400: PUSH
46401: LD_INT 1
46403: ARRAY
46404: PUSH
46405: LD_INT 1
46407: ARRAY
46408: PPUSH
46409: LD_EXP 120
46413: PUSH
46414: LD_VAR 0 2
46418: ARRAY
46419: PUSH
46420: LD_INT 1
46422: ARRAY
46423: PUSH
46424: LD_INT 2
46426: ARRAY
46427: PPUSH
46428: LD_EXP 120
46432: PUSH
46433: LD_VAR 0 2
46437: ARRAY
46438: PUSH
46439: LD_INT 1
46441: ARRAY
46442: PUSH
46443: LD_INT 3
46445: ARRAY
46446: PPUSH
46447: LD_EXP 120
46451: PUSH
46452: LD_VAR 0 2
46456: ARRAY
46457: PUSH
46458: LD_INT 1
46460: ARRAY
46461: PUSH
46462: LD_INT 4
46464: ARRAY
46465: PPUSH
46466: CALL_OW 145
// end ;
46470: GO 46259
46472: POP
46473: POP
// end else
46474: GO 46646
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46476: LD_EXP 115
46480: PUSH
46481: LD_VAR 0 2
46485: ARRAY
46486: PPUSH
46487: LD_EXP 120
46491: PUSH
46492: LD_VAR 0 2
46496: ARRAY
46497: PUSH
46498: LD_INT 1
46500: ARRAY
46501: PUSH
46502: LD_INT 1
46504: ARRAY
46505: PPUSH
46506: LD_EXP 120
46510: PUSH
46511: LD_VAR 0 2
46515: ARRAY
46516: PUSH
46517: LD_INT 1
46519: ARRAY
46520: PUSH
46521: LD_INT 2
46523: ARRAY
46524: PPUSH
46525: LD_EXP 120
46529: PUSH
46530: LD_VAR 0 2
46534: ARRAY
46535: PUSH
46536: LD_INT 1
46538: ARRAY
46539: PUSH
46540: LD_INT 3
46542: ARRAY
46543: PPUSH
46544: LD_EXP 120
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PUSH
46555: LD_INT 1
46557: ARRAY
46558: PUSH
46559: LD_INT 4
46561: ARRAY
46562: PPUSH
46563: LD_EXP 115
46567: PUSH
46568: LD_VAR 0 2
46572: ARRAY
46573: PPUSH
46574: LD_INT 21
46576: PUSH
46577: LD_INT 3
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PPUSH
46584: CALL_OW 72
46588: PPUSH
46589: EMPTY
46590: PPUSH
46591: CALL 77231 0 7
46595: NOT
46596: IFFALSE 46646
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46598: LD_ADDR_EXP 120
46602: PUSH
46603: LD_EXP 120
46607: PPUSH
46608: LD_VAR 0 2
46612: PPUSH
46613: LD_EXP 120
46617: PUSH
46618: LD_VAR 0 2
46622: ARRAY
46623: PPUSH
46624: LD_INT 1
46626: PPUSH
46627: LD_INT 1
46629: NEG
46630: PPUSH
46631: LD_INT 0
46633: PPUSH
46634: CALL 69771 0 4
46638: PPUSH
46639: CALL_OW 1
46643: ST_TO_ADDR
// continue ;
46644: GO 45494
// end ; end ; end ;
46646: GO 45494
46648: POP
46649: POP
// end ;
46650: LD_VAR 0 1
46654: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46655: LD_INT 0
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
46661: PPUSH
46662: PPUSH
// if not mc_bases then
46663: LD_EXP 115
46667: NOT
46668: IFFALSE 46672
// exit ;
46670: GO 47099
// for i = 1 to mc_bases do
46672: LD_ADDR_VAR 0 2
46676: PUSH
46677: DOUBLE
46678: LD_INT 1
46680: DEC
46681: ST_TO_ADDR
46682: LD_EXP 115
46686: PUSH
46687: FOR_TO
46688: IFFALSE 47097
// begin tmp := mc_build_upgrade [ i ] ;
46690: LD_ADDR_VAR 0 4
46694: PUSH
46695: LD_EXP 147
46699: PUSH
46700: LD_VAR 0 2
46704: ARRAY
46705: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46706: LD_ADDR_VAR 0 6
46710: PUSH
46711: LD_EXP 148
46715: PUSH
46716: LD_VAR 0 2
46720: ARRAY
46721: PPUSH
46722: LD_INT 2
46724: PUSH
46725: LD_INT 30
46727: PUSH
46728: LD_INT 6
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: PUSH
46735: LD_INT 30
46737: PUSH
46738: LD_INT 7
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: LIST
46749: PPUSH
46750: CALL_OW 72
46754: ST_TO_ADDR
// if not tmp and not lab then
46755: LD_VAR 0 4
46759: NOT
46760: PUSH
46761: LD_VAR 0 6
46765: NOT
46766: AND
46767: IFFALSE 46771
// continue ;
46769: GO 46687
// if tmp then
46771: LD_VAR 0 4
46775: IFFALSE 46895
// for j in tmp do
46777: LD_ADDR_VAR 0 3
46781: PUSH
46782: LD_VAR 0 4
46786: PUSH
46787: FOR_IN
46788: IFFALSE 46893
// begin if UpgradeCost ( j ) then
46790: LD_VAR 0 3
46794: PPUSH
46795: CALL 76891 0 1
46799: IFFALSE 46891
// begin ComUpgrade ( j ) ;
46801: LD_VAR 0 3
46805: PPUSH
46806: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46810: LD_ADDR_EXP 147
46814: PUSH
46815: LD_EXP 147
46819: PPUSH
46820: LD_VAR 0 2
46824: PPUSH
46825: LD_EXP 147
46829: PUSH
46830: LD_VAR 0 2
46834: ARRAY
46835: PUSH
46836: LD_VAR 0 3
46840: DIFF
46841: PPUSH
46842: CALL_OW 1
46846: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46847: LD_ADDR_EXP 122
46851: PUSH
46852: LD_EXP 122
46856: PPUSH
46857: LD_VAR 0 2
46861: PUSH
46862: LD_EXP 122
46866: PUSH
46867: LD_VAR 0 2
46871: ARRAY
46872: PUSH
46873: LD_INT 1
46875: PLUS
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PPUSH
46881: LD_VAR 0 3
46885: PPUSH
46886: CALL 70353 0 3
46890: ST_TO_ADDR
// end ; end ;
46891: GO 46787
46893: POP
46894: POP
// if not lab or not mc_lab_upgrade [ i ] then
46895: LD_VAR 0 6
46899: NOT
46900: PUSH
46901: LD_EXP 149
46905: PUSH
46906: LD_VAR 0 2
46910: ARRAY
46911: NOT
46912: OR
46913: IFFALSE 46917
// continue ;
46915: GO 46687
// for j in lab do
46917: LD_ADDR_VAR 0 3
46921: PUSH
46922: LD_VAR 0 6
46926: PUSH
46927: FOR_IN
46928: IFFALSE 47093
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46930: LD_VAR 0 3
46934: PPUSH
46935: CALL_OW 266
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 7
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: IN
46950: PUSH
46951: LD_VAR 0 3
46955: PPUSH
46956: CALL_OW 461
46960: PUSH
46961: LD_INT 1
46963: NONEQUAL
46964: AND
46965: IFFALSE 47091
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46967: LD_VAR 0 3
46971: PPUSH
46972: LD_EXP 149
46976: PUSH
46977: LD_VAR 0 2
46981: ARRAY
46982: PUSH
46983: LD_INT 1
46985: ARRAY
46986: PPUSH
46987: CALL 77096 0 2
46991: IFFALSE 47091
// begin ComCancel ( j ) ;
46993: LD_VAR 0 3
46997: PPUSH
46998: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47002: LD_VAR 0 3
47006: PPUSH
47007: LD_EXP 149
47011: PUSH
47012: LD_VAR 0 2
47016: ARRAY
47017: PUSH
47018: LD_INT 1
47020: ARRAY
47021: PPUSH
47022: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47026: LD_VAR 0 3
47030: PUSH
47031: LD_EXP 122
47035: PUSH
47036: LD_VAR 0 2
47040: ARRAY
47041: IN
47042: NOT
47043: IFFALSE 47089
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47045: LD_ADDR_EXP 122
47049: PUSH
47050: LD_EXP 122
47054: PPUSH
47055: LD_VAR 0 2
47059: PUSH
47060: LD_EXP 122
47064: PUSH
47065: LD_VAR 0 2
47069: ARRAY
47070: PUSH
47071: LD_INT 1
47073: PLUS
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PPUSH
47079: LD_VAR 0 3
47083: PPUSH
47084: CALL 70353 0 3
47088: ST_TO_ADDR
// break ;
47089: GO 47093
// end ; end ; end ;
47091: GO 46927
47093: POP
47094: POP
// end ;
47095: GO 46687
47097: POP
47098: POP
// end ;
47099: LD_VAR 0 1
47103: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47104: LD_INT 0
47106: PPUSH
47107: PPUSH
47108: PPUSH
47109: PPUSH
47110: PPUSH
47111: PPUSH
47112: PPUSH
47113: PPUSH
47114: PPUSH
// if not mc_bases then
47115: LD_EXP 115
47119: NOT
47120: IFFALSE 47124
// exit ;
47122: GO 47529
// for i = 1 to mc_bases do
47124: LD_ADDR_VAR 0 2
47128: PUSH
47129: DOUBLE
47130: LD_INT 1
47132: DEC
47133: ST_TO_ADDR
47134: LD_EXP 115
47138: PUSH
47139: FOR_TO
47140: IFFALSE 47527
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47142: LD_EXP 123
47146: PUSH
47147: LD_VAR 0 2
47151: ARRAY
47152: NOT
47153: PUSH
47154: LD_EXP 115
47158: PUSH
47159: LD_VAR 0 2
47163: ARRAY
47164: PPUSH
47165: LD_INT 30
47167: PUSH
47168: LD_INT 3
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PPUSH
47175: CALL_OW 72
47179: NOT
47180: OR
47181: IFFALSE 47185
// continue ;
47183: GO 47139
// busy := false ;
47185: LD_ADDR_VAR 0 8
47189: PUSH
47190: LD_INT 0
47192: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47193: LD_ADDR_VAR 0 4
47197: PUSH
47198: LD_EXP 115
47202: PUSH
47203: LD_VAR 0 2
47207: ARRAY
47208: PPUSH
47209: LD_INT 30
47211: PUSH
47212: LD_INT 3
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PPUSH
47219: CALL_OW 72
47223: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47224: LD_ADDR_VAR 0 6
47228: PUSH
47229: LD_EXP 123
47233: PUSH
47234: LD_VAR 0 2
47238: ARRAY
47239: PPUSH
47240: LD_INT 2
47242: PUSH
47243: LD_INT 30
47245: PUSH
47246: LD_INT 32
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 30
47255: PUSH
47256: LD_INT 33
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: LIST
47267: PPUSH
47268: CALL_OW 72
47272: ST_TO_ADDR
// if not t then
47273: LD_VAR 0 6
47277: NOT
47278: IFFALSE 47282
// continue ;
47280: GO 47139
// for j in tmp do
47282: LD_ADDR_VAR 0 3
47286: PUSH
47287: LD_VAR 0 4
47291: PUSH
47292: FOR_IN
47293: IFFALSE 47323
// if not BuildingStatus ( j ) = bs_idle then
47295: LD_VAR 0 3
47299: PPUSH
47300: CALL_OW 461
47304: PUSH
47305: LD_INT 2
47307: EQUAL
47308: NOT
47309: IFFALSE 47321
// begin busy := true ;
47311: LD_ADDR_VAR 0 8
47315: PUSH
47316: LD_INT 1
47318: ST_TO_ADDR
// break ;
47319: GO 47323
// end ;
47321: GO 47292
47323: POP
47324: POP
// if busy then
47325: LD_VAR 0 8
47329: IFFALSE 47333
// continue ;
47331: GO 47139
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47333: LD_ADDR_VAR 0 7
47337: PUSH
47338: LD_VAR 0 6
47342: PPUSH
47343: LD_INT 35
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: PPUSH
47353: CALL_OW 72
47357: ST_TO_ADDR
// if tw then
47358: LD_VAR 0 7
47362: IFFALSE 47439
// begin tw := tw [ 1 ] ;
47364: LD_ADDR_VAR 0 7
47368: PUSH
47369: LD_VAR 0 7
47373: PUSH
47374: LD_INT 1
47376: ARRAY
47377: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47378: LD_ADDR_VAR 0 9
47382: PUSH
47383: LD_VAR 0 7
47387: PPUSH
47388: LD_EXP 140
47392: PUSH
47393: LD_VAR 0 2
47397: ARRAY
47398: PPUSH
47399: CALL 75358 0 2
47403: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47404: LD_EXP 154
47408: PUSH
47409: LD_VAR 0 2
47413: ARRAY
47414: IFFALSE 47437
// if not weapon in mc_allowed_tower_weapons [ i ] then
47416: LD_VAR 0 9
47420: PUSH
47421: LD_EXP 154
47425: PUSH
47426: LD_VAR 0 2
47430: ARRAY
47431: IN
47432: NOT
47433: IFFALSE 47437
// continue ;
47435: GO 47139
// end else
47437: GO 47502
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47439: LD_ADDR_VAR 0 5
47443: PUSH
47444: LD_EXP 123
47448: PUSH
47449: LD_VAR 0 2
47453: ARRAY
47454: PPUSH
47455: LD_VAR 0 4
47459: PPUSH
47460: CALL 101277 0 2
47464: ST_TO_ADDR
// if not tmp2 then
47465: LD_VAR 0 5
47469: NOT
47470: IFFALSE 47474
// continue ;
47472: GO 47139
// tw := tmp2 [ 1 ] ;
47474: LD_ADDR_VAR 0 7
47478: PUSH
47479: LD_VAR 0 5
47483: PUSH
47484: LD_INT 1
47486: ARRAY
47487: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47488: LD_ADDR_VAR 0 9
47492: PUSH
47493: LD_VAR 0 5
47497: PUSH
47498: LD_INT 2
47500: ARRAY
47501: ST_TO_ADDR
// end ; if not weapon then
47502: LD_VAR 0 9
47506: NOT
47507: IFFALSE 47511
// continue ;
47509: GO 47139
// ComPlaceWeapon ( tw , weapon ) ;
47511: LD_VAR 0 7
47515: PPUSH
47516: LD_VAR 0 9
47520: PPUSH
47521: CALL_OW 148
// end ;
47525: GO 47139
47527: POP
47528: POP
// end ;
47529: LD_VAR 0 1
47533: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47534: LD_INT 0
47536: PPUSH
47537: PPUSH
47538: PPUSH
47539: PPUSH
47540: PPUSH
47541: PPUSH
47542: PPUSH
// if not mc_bases then
47543: LD_EXP 115
47547: NOT
47548: IFFALSE 47552
// exit ;
47550: GO 48320
// for i = 1 to mc_bases do
47552: LD_ADDR_VAR 0 2
47556: PUSH
47557: DOUBLE
47558: LD_INT 1
47560: DEC
47561: ST_TO_ADDR
47562: LD_EXP 115
47566: PUSH
47567: FOR_TO
47568: IFFALSE 48318
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47570: LD_EXP 128
47574: PUSH
47575: LD_VAR 0 2
47579: ARRAY
47580: NOT
47581: PUSH
47582: LD_EXP 128
47586: PUSH
47587: LD_VAR 0 2
47591: ARRAY
47592: PUSH
47593: LD_EXP 129
47597: PUSH
47598: LD_VAR 0 2
47602: ARRAY
47603: EQUAL
47604: OR
47605: PUSH
47606: LD_EXP 138
47610: PUSH
47611: LD_VAR 0 2
47615: ARRAY
47616: OR
47617: IFFALSE 47621
// continue ;
47619: GO 47567
// if mc_miners [ i ] then
47621: LD_EXP 129
47625: PUSH
47626: LD_VAR 0 2
47630: ARRAY
47631: IFFALSE 48005
// begin for j = mc_miners [ i ] downto 1 do
47633: LD_ADDR_VAR 0 3
47637: PUSH
47638: DOUBLE
47639: LD_EXP 129
47643: PUSH
47644: LD_VAR 0 2
47648: ARRAY
47649: INC
47650: ST_TO_ADDR
47651: LD_INT 1
47653: PUSH
47654: FOR_DOWNTO
47655: IFFALSE 48003
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47657: LD_EXP 129
47661: PUSH
47662: LD_VAR 0 2
47666: ARRAY
47667: PUSH
47668: LD_VAR 0 3
47672: ARRAY
47673: PPUSH
47674: CALL_OW 301
47678: PUSH
47679: LD_EXP 129
47683: PUSH
47684: LD_VAR 0 2
47688: ARRAY
47689: PUSH
47690: LD_VAR 0 3
47694: ARRAY
47695: PPUSH
47696: CALL_OW 257
47700: PUSH
47701: LD_INT 1
47703: NONEQUAL
47704: OR
47705: IFFALSE 47768
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47707: LD_ADDR_VAR 0 5
47711: PUSH
47712: LD_EXP 129
47716: PUSH
47717: LD_VAR 0 2
47721: ARRAY
47722: PUSH
47723: LD_EXP 129
47727: PUSH
47728: LD_VAR 0 2
47732: ARRAY
47733: PUSH
47734: LD_VAR 0 3
47738: ARRAY
47739: DIFF
47740: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47741: LD_ADDR_EXP 129
47745: PUSH
47746: LD_EXP 129
47750: PPUSH
47751: LD_VAR 0 2
47755: PPUSH
47756: LD_VAR 0 5
47760: PPUSH
47761: CALL_OW 1
47765: ST_TO_ADDR
// continue ;
47766: GO 47654
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47768: LD_EXP 129
47772: PUSH
47773: LD_VAR 0 2
47777: ARRAY
47778: PUSH
47779: LD_VAR 0 3
47783: ARRAY
47784: PPUSH
47785: CALL_OW 257
47789: PUSH
47790: LD_INT 1
47792: EQUAL
47793: PUSH
47794: LD_EXP 129
47798: PUSH
47799: LD_VAR 0 2
47803: ARRAY
47804: PUSH
47805: LD_VAR 0 3
47809: ARRAY
47810: PPUSH
47811: CALL_OW 459
47815: NOT
47816: AND
47817: PUSH
47818: LD_EXP 129
47822: PUSH
47823: LD_VAR 0 2
47827: ARRAY
47828: PUSH
47829: LD_VAR 0 3
47833: ARRAY
47834: PPUSH
47835: CALL_OW 314
47839: NOT
47840: AND
47841: IFFALSE 48001
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47843: LD_EXP 129
47847: PUSH
47848: LD_VAR 0 2
47852: ARRAY
47853: PUSH
47854: LD_VAR 0 3
47858: ARRAY
47859: PPUSH
47860: CALL_OW 310
47864: IFFALSE 47887
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47866: LD_EXP 129
47870: PUSH
47871: LD_VAR 0 2
47875: ARRAY
47876: PUSH
47877: LD_VAR 0 3
47881: ARRAY
47882: PPUSH
47883: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47887: LD_EXP 129
47891: PUSH
47892: LD_VAR 0 2
47896: ARRAY
47897: PUSH
47898: LD_VAR 0 3
47902: ARRAY
47903: PPUSH
47904: CALL_OW 314
47908: NOT
47909: IFFALSE 48001
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47911: LD_ADDR_VAR 0 7
47915: PUSH
47916: LD_INT 1
47918: PPUSH
47919: LD_EXP 128
47923: PUSH
47924: LD_VAR 0 2
47928: ARRAY
47929: PPUSH
47930: CALL_OW 12
47934: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
47935: LD_EXP 129
47939: PUSH
47940: LD_VAR 0 2
47944: ARRAY
47945: PUSH
47946: LD_VAR 0 3
47950: ARRAY
47951: PPUSH
47952: LD_EXP 128
47956: PUSH
47957: LD_VAR 0 2
47961: ARRAY
47962: PUSH
47963: LD_VAR 0 7
47967: ARRAY
47968: PUSH
47969: LD_INT 1
47971: ARRAY
47972: PPUSH
47973: LD_EXP 128
47977: PUSH
47978: LD_VAR 0 2
47982: ARRAY
47983: PUSH
47984: LD_VAR 0 7
47988: ARRAY
47989: PUSH
47990: LD_INT 2
47992: ARRAY
47993: PPUSH
47994: LD_INT 0
47996: PPUSH
47997: CALL_OW 193
// end ; end ; end ;
48001: GO 47654
48003: POP
48004: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48005: LD_ADDR_VAR 0 5
48009: PUSH
48010: LD_EXP 115
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PPUSH
48021: LD_INT 2
48023: PUSH
48024: LD_INT 30
48026: PUSH
48027: LD_INT 4
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: PUSH
48034: LD_INT 30
48036: PUSH
48037: LD_INT 5
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 30
48046: PUSH
48047: LD_INT 32
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: LIST
48058: LIST
48059: PPUSH
48060: CALL_OW 72
48064: ST_TO_ADDR
// if not tmp then
48065: LD_VAR 0 5
48069: NOT
48070: IFFALSE 48074
// continue ;
48072: GO 47567
// list := [ ] ;
48074: LD_ADDR_VAR 0 6
48078: PUSH
48079: EMPTY
48080: ST_TO_ADDR
// for j in tmp do
48081: LD_ADDR_VAR 0 3
48085: PUSH
48086: LD_VAR 0 5
48090: PUSH
48091: FOR_IN
48092: IFFALSE 48161
// begin for k in UnitsInside ( j ) do
48094: LD_ADDR_VAR 0 4
48098: PUSH
48099: LD_VAR 0 3
48103: PPUSH
48104: CALL_OW 313
48108: PUSH
48109: FOR_IN
48110: IFFALSE 48157
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48112: LD_VAR 0 4
48116: PPUSH
48117: CALL_OW 257
48121: PUSH
48122: LD_INT 1
48124: EQUAL
48125: PUSH
48126: LD_VAR 0 4
48130: PPUSH
48131: CALL_OW 459
48135: NOT
48136: AND
48137: IFFALSE 48155
// list := list ^ k ;
48139: LD_ADDR_VAR 0 6
48143: PUSH
48144: LD_VAR 0 6
48148: PUSH
48149: LD_VAR 0 4
48153: ADD
48154: ST_TO_ADDR
48155: GO 48109
48157: POP
48158: POP
// end ;
48159: GO 48091
48161: POP
48162: POP
// list := list diff mc_miners [ i ] ;
48163: LD_ADDR_VAR 0 6
48167: PUSH
48168: LD_VAR 0 6
48172: PUSH
48173: LD_EXP 129
48177: PUSH
48178: LD_VAR 0 2
48182: ARRAY
48183: DIFF
48184: ST_TO_ADDR
// if not list then
48185: LD_VAR 0 6
48189: NOT
48190: IFFALSE 48194
// continue ;
48192: GO 47567
// k := mc_mines [ i ] - mc_miners [ i ] ;
48194: LD_ADDR_VAR 0 4
48198: PUSH
48199: LD_EXP 128
48203: PUSH
48204: LD_VAR 0 2
48208: ARRAY
48209: PUSH
48210: LD_EXP 129
48214: PUSH
48215: LD_VAR 0 2
48219: ARRAY
48220: MINUS
48221: ST_TO_ADDR
// if k > list then
48222: LD_VAR 0 4
48226: PUSH
48227: LD_VAR 0 6
48231: GREATER
48232: IFFALSE 48244
// k := list ;
48234: LD_ADDR_VAR 0 4
48238: PUSH
48239: LD_VAR 0 6
48243: ST_TO_ADDR
// for j = 1 to k do
48244: LD_ADDR_VAR 0 3
48248: PUSH
48249: DOUBLE
48250: LD_INT 1
48252: DEC
48253: ST_TO_ADDR
48254: LD_VAR 0 4
48258: PUSH
48259: FOR_TO
48260: IFFALSE 48314
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48262: LD_ADDR_EXP 129
48266: PUSH
48267: LD_EXP 129
48271: PPUSH
48272: LD_VAR 0 2
48276: PUSH
48277: LD_EXP 129
48281: PUSH
48282: LD_VAR 0 2
48286: ARRAY
48287: PUSH
48288: LD_INT 1
48290: PLUS
48291: PUSH
48292: EMPTY
48293: LIST
48294: LIST
48295: PPUSH
48296: LD_VAR 0 6
48300: PUSH
48301: LD_VAR 0 3
48305: ARRAY
48306: PPUSH
48307: CALL 70353 0 3
48311: ST_TO_ADDR
48312: GO 48259
48314: POP
48315: POP
// end ;
48316: GO 47567
48318: POP
48319: POP
// end ;
48320: LD_VAR 0 1
48324: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48325: LD_INT 0
48327: PPUSH
48328: PPUSH
48329: PPUSH
48330: PPUSH
48331: PPUSH
48332: PPUSH
48333: PPUSH
48334: PPUSH
48335: PPUSH
48336: PPUSH
// if not mc_bases then
48337: LD_EXP 115
48341: NOT
48342: IFFALSE 48346
// exit ;
48344: GO 50096
// for i = 1 to mc_bases do
48346: LD_ADDR_VAR 0 2
48350: PUSH
48351: DOUBLE
48352: LD_INT 1
48354: DEC
48355: ST_TO_ADDR
48356: LD_EXP 115
48360: PUSH
48361: FOR_TO
48362: IFFALSE 50094
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48364: LD_EXP 115
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: NOT
48375: PUSH
48376: LD_EXP 122
48380: PUSH
48381: LD_VAR 0 2
48385: ARRAY
48386: OR
48387: IFFALSE 48391
// continue ;
48389: GO 48361
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48391: LD_EXP 131
48395: PUSH
48396: LD_VAR 0 2
48400: ARRAY
48401: NOT
48402: PUSH
48403: LD_EXP 132
48407: PUSH
48408: LD_VAR 0 2
48412: ARRAY
48413: AND
48414: IFFALSE 48452
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48416: LD_ADDR_EXP 132
48420: PUSH
48421: LD_EXP 132
48425: PPUSH
48426: LD_VAR 0 2
48430: PPUSH
48431: EMPTY
48432: PPUSH
48433: CALL_OW 1
48437: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48438: LD_VAR 0 2
48442: PPUSH
48443: LD_INT 107
48445: PPUSH
48446: CALL 39279 0 2
// continue ;
48450: GO 48361
// end ; target := [ ] ;
48452: LD_ADDR_VAR 0 6
48456: PUSH
48457: EMPTY
48458: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48459: LD_ADDR_VAR 0 3
48463: PUSH
48464: DOUBLE
48465: LD_EXP 131
48469: PUSH
48470: LD_VAR 0 2
48474: ARRAY
48475: INC
48476: ST_TO_ADDR
48477: LD_INT 1
48479: PUSH
48480: FOR_DOWNTO
48481: IFFALSE 48741
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48483: LD_EXP 131
48487: PUSH
48488: LD_VAR 0 2
48492: ARRAY
48493: PUSH
48494: LD_VAR 0 3
48498: ARRAY
48499: PUSH
48500: LD_INT 2
48502: ARRAY
48503: PPUSH
48504: LD_EXP 131
48508: PUSH
48509: LD_VAR 0 2
48513: ARRAY
48514: PUSH
48515: LD_VAR 0 3
48519: ARRAY
48520: PUSH
48521: LD_INT 3
48523: ARRAY
48524: PPUSH
48525: CALL_OW 488
48529: PUSH
48530: LD_EXP 131
48534: PUSH
48535: LD_VAR 0 2
48539: ARRAY
48540: PUSH
48541: LD_VAR 0 3
48545: ARRAY
48546: PUSH
48547: LD_INT 2
48549: ARRAY
48550: PPUSH
48551: LD_EXP 131
48555: PUSH
48556: LD_VAR 0 2
48560: ARRAY
48561: PUSH
48562: LD_VAR 0 3
48566: ARRAY
48567: PUSH
48568: LD_INT 3
48570: ARRAY
48571: PPUSH
48572: CALL_OW 284
48576: PUSH
48577: LD_INT 0
48579: EQUAL
48580: AND
48581: IFFALSE 48636
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48583: LD_ADDR_VAR 0 5
48587: PUSH
48588: LD_EXP 131
48592: PUSH
48593: LD_VAR 0 2
48597: ARRAY
48598: PPUSH
48599: LD_VAR 0 3
48603: PPUSH
48604: CALL_OW 3
48608: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48609: LD_ADDR_EXP 131
48613: PUSH
48614: LD_EXP 131
48618: PPUSH
48619: LD_VAR 0 2
48623: PPUSH
48624: LD_VAR 0 5
48628: PPUSH
48629: CALL_OW 1
48633: ST_TO_ADDR
// continue ;
48634: GO 48480
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48636: LD_EXP 115
48640: PUSH
48641: LD_VAR 0 2
48645: ARRAY
48646: PUSH
48647: LD_INT 1
48649: ARRAY
48650: PPUSH
48651: CALL_OW 255
48655: PPUSH
48656: LD_EXP 131
48660: PUSH
48661: LD_VAR 0 2
48665: ARRAY
48666: PUSH
48667: LD_VAR 0 3
48671: ARRAY
48672: PUSH
48673: LD_INT 2
48675: ARRAY
48676: PPUSH
48677: LD_EXP 131
48681: PUSH
48682: LD_VAR 0 2
48686: ARRAY
48687: PUSH
48688: LD_VAR 0 3
48692: ARRAY
48693: PUSH
48694: LD_INT 3
48696: ARRAY
48697: PPUSH
48698: LD_INT 30
48700: PPUSH
48701: CALL 71249 0 4
48705: PUSH
48706: LD_INT 4
48708: ARRAY
48709: PUSH
48710: LD_INT 0
48712: EQUAL
48713: IFFALSE 48739
// begin target := mc_crates [ i ] [ j ] ;
48715: LD_ADDR_VAR 0 6
48719: PUSH
48720: LD_EXP 131
48724: PUSH
48725: LD_VAR 0 2
48729: ARRAY
48730: PUSH
48731: LD_VAR 0 3
48735: ARRAY
48736: ST_TO_ADDR
// break ;
48737: GO 48741
// end ; end ;
48739: GO 48480
48741: POP
48742: POP
// if not target then
48743: LD_VAR 0 6
48747: NOT
48748: IFFALSE 48752
// continue ;
48750: GO 48361
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48752: LD_ADDR_VAR 0 7
48756: PUSH
48757: LD_EXP 134
48761: PUSH
48762: LD_VAR 0 2
48766: ARRAY
48767: PPUSH
48768: LD_INT 2
48770: PUSH
48771: LD_INT 3
48773: PUSH
48774: LD_INT 58
48776: PUSH
48777: EMPTY
48778: LIST
48779: PUSH
48780: EMPTY
48781: LIST
48782: LIST
48783: PUSH
48784: LD_INT 61
48786: PUSH
48787: EMPTY
48788: LIST
48789: PUSH
48790: LD_INT 33
48792: PUSH
48793: LD_INT 5
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 33
48802: PUSH
48803: LD_INT 3
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: PUSH
48817: LD_INT 2
48819: PUSH
48820: LD_INT 34
48822: PUSH
48823: LD_INT 32
48825: PUSH
48826: EMPTY
48827: LIST
48828: LIST
48829: PUSH
48830: LD_INT 34
48832: PUSH
48833: LD_INT 51
48835: PUSH
48836: EMPTY
48837: LIST
48838: LIST
48839: PUSH
48840: LD_INT 34
48842: PUSH
48843: LD_INT 12
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: EMPTY
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PPUSH
48860: CALL_OW 72
48864: ST_TO_ADDR
// if not cargo then
48865: LD_VAR 0 7
48869: NOT
48870: IFFALSE 49513
// begin if mc_crates_collector [ i ] < 5 then
48872: LD_EXP 132
48876: PUSH
48877: LD_VAR 0 2
48881: ARRAY
48882: PUSH
48883: LD_INT 5
48885: LESS
48886: IFFALSE 49252
// begin if mc_ape [ i ] then
48888: LD_EXP 144
48892: PUSH
48893: LD_VAR 0 2
48897: ARRAY
48898: IFFALSE 48945
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48900: LD_ADDR_VAR 0 5
48904: PUSH
48905: LD_EXP 144
48909: PUSH
48910: LD_VAR 0 2
48914: ARRAY
48915: PPUSH
48916: LD_INT 25
48918: PUSH
48919: LD_INT 16
48921: PUSH
48922: EMPTY
48923: LIST
48924: LIST
48925: PUSH
48926: LD_INT 24
48928: PUSH
48929: LD_INT 750
48931: PUSH
48932: EMPTY
48933: LIST
48934: LIST
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PPUSH
48940: CALL_OW 72
48944: ST_TO_ADDR
// if not tmp then
48945: LD_VAR 0 5
48949: NOT
48950: IFFALSE 48997
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48952: LD_ADDR_VAR 0 5
48956: PUSH
48957: LD_EXP 115
48961: PUSH
48962: LD_VAR 0 2
48966: ARRAY
48967: PPUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 2
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 24
48980: PUSH
48981: LD_INT 750
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PPUSH
48992: CALL_OW 72
48996: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48997: LD_EXP 144
49001: PUSH
49002: LD_VAR 0 2
49006: ARRAY
49007: PUSH
49008: LD_EXP 115
49012: PUSH
49013: LD_VAR 0 2
49017: ARRAY
49018: PPUSH
49019: LD_INT 25
49021: PUSH
49022: LD_INT 2
49024: PUSH
49025: EMPTY
49026: LIST
49027: LIST
49028: PUSH
49029: LD_INT 24
49031: PUSH
49032: LD_INT 750
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PPUSH
49043: CALL_OW 72
49047: AND
49048: PUSH
49049: LD_VAR 0 5
49053: PUSH
49054: LD_INT 5
49056: LESS
49057: AND
49058: IFFALSE 49140
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49060: LD_ADDR_VAR 0 3
49064: PUSH
49065: LD_EXP 115
49069: PUSH
49070: LD_VAR 0 2
49074: ARRAY
49075: PPUSH
49076: LD_INT 25
49078: PUSH
49079: LD_INT 2
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PUSH
49086: LD_INT 24
49088: PUSH
49089: LD_INT 750
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PPUSH
49100: CALL_OW 72
49104: PUSH
49105: FOR_IN
49106: IFFALSE 49138
// begin tmp := tmp union j ;
49108: LD_ADDR_VAR 0 5
49112: PUSH
49113: LD_VAR 0 5
49117: PUSH
49118: LD_VAR 0 3
49122: UNION
49123: ST_TO_ADDR
// if tmp >= 5 then
49124: LD_VAR 0 5
49128: PUSH
49129: LD_INT 5
49131: GREATEREQUAL
49132: IFFALSE 49136
// break ;
49134: GO 49138
// end ;
49136: GO 49105
49138: POP
49139: POP
// end ; if not tmp then
49140: LD_VAR 0 5
49144: NOT
49145: IFFALSE 49149
// continue ;
49147: GO 48361
// for j in tmp do
49149: LD_ADDR_VAR 0 3
49153: PUSH
49154: LD_VAR 0 5
49158: PUSH
49159: FOR_IN
49160: IFFALSE 49250
// if not GetTag ( j ) then
49162: LD_VAR 0 3
49166: PPUSH
49167: CALL_OW 110
49171: NOT
49172: IFFALSE 49248
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49174: LD_ADDR_EXP 132
49178: PUSH
49179: LD_EXP 132
49183: PPUSH
49184: LD_VAR 0 2
49188: PUSH
49189: LD_EXP 132
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: PUSH
49200: LD_INT 1
49202: PLUS
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PPUSH
49208: LD_VAR 0 3
49212: PPUSH
49213: CALL 70353 0 3
49217: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49218: LD_VAR 0 3
49222: PPUSH
49223: LD_INT 107
49225: PPUSH
49226: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49230: LD_EXP 132
49234: PUSH
49235: LD_VAR 0 2
49239: ARRAY
49240: PUSH
49241: LD_INT 5
49243: GREATEREQUAL
49244: IFFALSE 49248
// break ;
49246: GO 49250
// end ;
49248: GO 49159
49250: POP
49251: POP
// end ; if mc_crates_collector [ i ] and target then
49252: LD_EXP 132
49256: PUSH
49257: LD_VAR 0 2
49261: ARRAY
49262: PUSH
49263: LD_VAR 0 6
49267: AND
49268: IFFALSE 49511
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49270: LD_EXP 132
49274: PUSH
49275: LD_VAR 0 2
49279: ARRAY
49280: PUSH
49281: LD_VAR 0 6
49285: PUSH
49286: LD_INT 1
49288: ARRAY
49289: LESS
49290: IFFALSE 49310
// tmp := mc_crates_collector [ i ] else
49292: LD_ADDR_VAR 0 5
49296: PUSH
49297: LD_EXP 132
49301: PUSH
49302: LD_VAR 0 2
49306: ARRAY
49307: ST_TO_ADDR
49308: GO 49324
// tmp := target [ 1 ] ;
49310: LD_ADDR_VAR 0 5
49314: PUSH
49315: LD_VAR 0 6
49319: PUSH
49320: LD_INT 1
49322: ARRAY
49323: ST_TO_ADDR
// k := 0 ;
49324: LD_ADDR_VAR 0 4
49328: PUSH
49329: LD_INT 0
49331: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49332: LD_ADDR_VAR 0 3
49336: PUSH
49337: LD_EXP 132
49341: PUSH
49342: LD_VAR 0 2
49346: ARRAY
49347: PUSH
49348: FOR_IN
49349: IFFALSE 49509
// begin k := k + 1 ;
49351: LD_ADDR_VAR 0 4
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: LD_INT 1
49363: PLUS
49364: ST_TO_ADDR
// if k > tmp then
49365: LD_VAR 0 4
49369: PUSH
49370: LD_VAR 0 5
49374: GREATER
49375: IFFALSE 49379
// break ;
49377: GO 49509
// if not GetClass ( j ) in [ 2 , 16 ] then
49379: LD_VAR 0 3
49383: PPUSH
49384: CALL_OW 257
49388: PUSH
49389: LD_INT 2
49391: PUSH
49392: LD_INT 16
49394: PUSH
49395: EMPTY
49396: LIST
49397: LIST
49398: IN
49399: NOT
49400: IFFALSE 49453
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49402: LD_ADDR_EXP 132
49406: PUSH
49407: LD_EXP 132
49411: PPUSH
49412: LD_VAR 0 2
49416: PPUSH
49417: LD_EXP 132
49421: PUSH
49422: LD_VAR 0 2
49426: ARRAY
49427: PUSH
49428: LD_VAR 0 3
49432: DIFF
49433: PPUSH
49434: CALL_OW 1
49438: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49439: LD_VAR 0 3
49443: PPUSH
49444: LD_INT 0
49446: PPUSH
49447: CALL_OW 109
// continue ;
49451: GO 49348
// end ; if IsInUnit ( j ) then
49453: LD_VAR 0 3
49457: PPUSH
49458: CALL_OW 310
49462: IFFALSE 49473
// ComExitBuilding ( j ) ;
49464: LD_VAR 0 3
49468: PPUSH
49469: CALL_OW 122
// wait ( 3 ) ;
49473: LD_INT 3
49475: PPUSH
49476: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49480: LD_VAR 0 3
49484: PPUSH
49485: LD_VAR 0 6
49489: PUSH
49490: LD_INT 2
49492: ARRAY
49493: PPUSH
49494: LD_VAR 0 6
49498: PUSH
49499: LD_INT 3
49501: ARRAY
49502: PPUSH
49503: CALL_OW 117
// end ;
49507: GO 49348
49509: POP
49510: POP
// end ; end else
49511: GO 50092
// begin for j in cargo do
49513: LD_ADDR_VAR 0 3
49517: PUSH
49518: LD_VAR 0 7
49522: PUSH
49523: FOR_IN
49524: IFFALSE 50090
// begin if GetTag ( j ) <> 0 then
49526: LD_VAR 0 3
49530: PPUSH
49531: CALL_OW 110
49535: PUSH
49536: LD_INT 0
49538: NONEQUAL
49539: IFFALSE 49543
// continue ;
49541: GO 49523
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49543: LD_VAR 0 3
49547: PPUSH
49548: CALL_OW 256
49552: PUSH
49553: LD_INT 1000
49555: LESS
49556: PUSH
49557: LD_VAR 0 3
49561: PPUSH
49562: LD_EXP 139
49566: PUSH
49567: LD_VAR 0 2
49571: ARRAY
49572: PPUSH
49573: CALL_OW 308
49577: NOT
49578: AND
49579: IFFALSE 49601
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49581: LD_VAR 0 3
49585: PPUSH
49586: LD_EXP 139
49590: PUSH
49591: LD_VAR 0 2
49595: ARRAY
49596: PPUSH
49597: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49601: LD_VAR 0 3
49605: PPUSH
49606: CALL_OW 256
49610: PUSH
49611: LD_INT 1000
49613: LESS
49614: PUSH
49615: LD_VAR 0 3
49619: PPUSH
49620: LD_EXP 139
49624: PUSH
49625: LD_VAR 0 2
49629: ARRAY
49630: PPUSH
49631: CALL_OW 308
49635: AND
49636: IFFALSE 49640
// continue ;
49638: GO 49523
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49640: LD_VAR 0 3
49644: PPUSH
49645: CALL_OW 262
49649: PUSH
49650: LD_INT 2
49652: EQUAL
49653: PUSH
49654: LD_VAR 0 3
49658: PPUSH
49659: CALL_OW 261
49663: PUSH
49664: LD_INT 15
49666: LESS
49667: AND
49668: IFFALSE 49672
// continue ;
49670: GO 49523
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49672: LD_VAR 0 3
49676: PPUSH
49677: CALL_OW 262
49681: PUSH
49682: LD_INT 1
49684: EQUAL
49685: PUSH
49686: LD_VAR 0 3
49690: PPUSH
49691: CALL_OW 261
49695: PUSH
49696: LD_INT 10
49698: LESS
49699: AND
49700: IFFALSE 50029
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49702: LD_ADDR_VAR 0 8
49706: PUSH
49707: LD_EXP 115
49711: PUSH
49712: LD_VAR 0 2
49716: ARRAY
49717: PPUSH
49718: LD_INT 2
49720: PUSH
49721: LD_INT 30
49723: PUSH
49724: LD_INT 0
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: LD_INT 30
49733: PUSH
49734: LD_INT 1
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: LIST
49745: PPUSH
49746: CALL_OW 72
49750: ST_TO_ADDR
// if not depot then
49751: LD_VAR 0 8
49755: NOT
49756: IFFALSE 49760
// continue ;
49758: GO 49523
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49760: LD_VAR 0 3
49764: PPUSH
49765: LD_VAR 0 8
49769: PPUSH
49770: LD_VAR 0 3
49774: PPUSH
49775: CALL_OW 74
49779: PPUSH
49780: CALL_OW 296
49784: PUSH
49785: LD_INT 6
49787: LESS
49788: IFFALSE 49804
// SetFuel ( j , 100 ) else
49790: LD_VAR 0 3
49794: PPUSH
49795: LD_INT 100
49797: PPUSH
49798: CALL_OW 240
49802: GO 50029
// if GetFuel ( j ) = 0 then
49804: LD_VAR 0 3
49808: PPUSH
49809: CALL_OW 261
49813: PUSH
49814: LD_INT 0
49816: EQUAL
49817: IFFALSE 50029
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49819: LD_ADDR_EXP 134
49823: PUSH
49824: LD_EXP 134
49828: PPUSH
49829: LD_VAR 0 2
49833: PPUSH
49834: LD_EXP 134
49838: PUSH
49839: LD_VAR 0 2
49843: ARRAY
49844: PUSH
49845: LD_VAR 0 3
49849: DIFF
49850: PPUSH
49851: CALL_OW 1
49855: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49856: LD_VAR 0 3
49860: PPUSH
49861: CALL_OW 263
49865: PUSH
49866: LD_INT 1
49868: EQUAL
49869: IFFALSE 49885
// ComExitVehicle ( IsInUnit ( j ) ) ;
49871: LD_VAR 0 3
49875: PPUSH
49876: CALL_OW 310
49880: PPUSH
49881: CALL_OW 121
// if GetControl ( j ) = control_remote then
49885: LD_VAR 0 3
49889: PPUSH
49890: CALL_OW 263
49894: PUSH
49895: LD_INT 2
49897: EQUAL
49898: IFFALSE 49909
// ComUnlink ( j ) ;
49900: LD_VAR 0 3
49904: PPUSH
49905: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49909: LD_ADDR_VAR 0 9
49913: PUSH
49914: LD_VAR 0 2
49918: PPUSH
49919: LD_INT 3
49921: PPUSH
49922: CALL 59499 0 2
49926: ST_TO_ADDR
// if fac then
49927: LD_VAR 0 9
49931: IFFALSE 50027
// begin for k in fac do
49933: LD_ADDR_VAR 0 4
49937: PUSH
49938: LD_VAR 0 9
49942: PUSH
49943: FOR_IN
49944: IFFALSE 50025
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49946: LD_ADDR_VAR 0 10
49950: PUSH
49951: LD_VAR 0 9
49955: PPUSH
49956: LD_VAR 0 3
49960: PPUSH
49961: CALL_OW 265
49965: PPUSH
49966: LD_VAR 0 3
49970: PPUSH
49971: CALL_OW 262
49975: PPUSH
49976: LD_VAR 0 3
49980: PPUSH
49981: CALL_OW 263
49985: PPUSH
49986: LD_VAR 0 3
49990: PPUSH
49991: CALL_OW 264
49995: PPUSH
49996: CALL 67885 0 5
50000: ST_TO_ADDR
// if components then
50001: LD_VAR 0 10
50005: IFFALSE 50023
// begin MC_InsertProduceList ( i , components ) ;
50007: LD_VAR 0 2
50011: PPUSH
50012: LD_VAR 0 10
50016: PPUSH
50017: CALL 59044 0 2
// break ;
50021: GO 50025
// end ; end ;
50023: GO 49943
50025: POP
50026: POP
// end ; continue ;
50027: GO 49523
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50029: LD_VAR 0 3
50033: PPUSH
50034: LD_INT 1
50036: PPUSH
50037: CALL_OW 289
50041: PUSH
50042: LD_INT 100
50044: LESS
50045: PUSH
50046: LD_VAR 0 3
50050: PPUSH
50051: CALL_OW 314
50055: NOT
50056: AND
50057: IFFALSE 50086
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50059: LD_VAR 0 3
50063: PPUSH
50064: LD_VAR 0 6
50068: PUSH
50069: LD_INT 2
50071: ARRAY
50072: PPUSH
50073: LD_VAR 0 6
50077: PUSH
50078: LD_INT 3
50080: ARRAY
50081: PPUSH
50082: CALL_OW 117
// break ;
50086: GO 50090
// end ;
50088: GO 49523
50090: POP
50091: POP
// end ; end ;
50092: GO 48361
50094: POP
50095: POP
// end ;
50096: LD_VAR 0 1
50100: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50101: LD_INT 0
50103: PPUSH
50104: PPUSH
50105: PPUSH
50106: PPUSH
// if not mc_bases then
50107: LD_EXP 115
50111: NOT
50112: IFFALSE 50116
// exit ;
50114: GO 50277
// for i = 1 to mc_bases do
50116: LD_ADDR_VAR 0 2
50120: PUSH
50121: DOUBLE
50122: LD_INT 1
50124: DEC
50125: ST_TO_ADDR
50126: LD_EXP 115
50130: PUSH
50131: FOR_TO
50132: IFFALSE 50275
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50134: LD_ADDR_VAR 0 4
50138: PUSH
50139: LD_EXP 134
50143: PUSH
50144: LD_VAR 0 2
50148: ARRAY
50149: PUSH
50150: LD_EXP 137
50154: PUSH
50155: LD_VAR 0 2
50159: ARRAY
50160: UNION
50161: PPUSH
50162: LD_INT 33
50164: PUSH
50165: LD_INT 2
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PPUSH
50172: CALL_OW 72
50176: ST_TO_ADDR
// if tmp then
50177: LD_VAR 0 4
50181: IFFALSE 50273
// for j in tmp do
50183: LD_ADDR_VAR 0 3
50187: PUSH
50188: LD_VAR 0 4
50192: PUSH
50193: FOR_IN
50194: IFFALSE 50271
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50196: LD_VAR 0 3
50200: PPUSH
50201: CALL_OW 312
50205: NOT
50206: PUSH
50207: LD_VAR 0 3
50211: PPUSH
50212: CALL_OW 256
50216: PUSH
50217: LD_INT 250
50219: GREATEREQUAL
50220: AND
50221: IFFALSE 50234
// Connect ( j ) else
50223: LD_VAR 0 3
50227: PPUSH
50228: CALL 73318 0 1
50232: GO 50269
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50234: LD_VAR 0 3
50238: PPUSH
50239: CALL_OW 256
50243: PUSH
50244: LD_INT 250
50246: LESS
50247: PUSH
50248: LD_VAR 0 3
50252: PPUSH
50253: CALL_OW 312
50257: AND
50258: IFFALSE 50269
// ComUnlink ( j ) ;
50260: LD_VAR 0 3
50264: PPUSH
50265: CALL_OW 136
50269: GO 50193
50271: POP
50272: POP
// end ;
50273: GO 50131
50275: POP
50276: POP
// end ;
50277: LD_VAR 0 1
50281: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50282: LD_INT 0
50284: PPUSH
50285: PPUSH
50286: PPUSH
50287: PPUSH
50288: PPUSH
// if not mc_bases then
50289: LD_EXP 115
50293: NOT
50294: IFFALSE 50298
// exit ;
50296: GO 50743
// for i = 1 to mc_bases do
50298: LD_ADDR_VAR 0 2
50302: PUSH
50303: DOUBLE
50304: LD_INT 1
50306: DEC
50307: ST_TO_ADDR
50308: LD_EXP 115
50312: PUSH
50313: FOR_TO
50314: IFFALSE 50741
// begin if not mc_produce [ i ] then
50316: LD_EXP 136
50320: PUSH
50321: LD_VAR 0 2
50325: ARRAY
50326: NOT
50327: IFFALSE 50331
// continue ;
50329: GO 50313
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50331: LD_ADDR_VAR 0 5
50335: PUSH
50336: LD_EXP 115
50340: PUSH
50341: LD_VAR 0 2
50345: ARRAY
50346: PPUSH
50347: LD_INT 30
50349: PUSH
50350: LD_INT 3
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: PPUSH
50357: CALL_OW 72
50361: ST_TO_ADDR
// if not fac then
50362: LD_VAR 0 5
50366: NOT
50367: IFFALSE 50371
// continue ;
50369: GO 50313
// for j in fac do
50371: LD_ADDR_VAR 0 3
50375: PUSH
50376: LD_VAR 0 5
50380: PUSH
50381: FOR_IN
50382: IFFALSE 50737
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50384: LD_VAR 0 3
50388: PPUSH
50389: CALL_OW 461
50393: PUSH
50394: LD_INT 2
50396: NONEQUAL
50397: PUSH
50398: LD_VAR 0 3
50402: PPUSH
50403: LD_INT 15
50405: PPUSH
50406: CALL 72946 0 2
50410: PUSH
50411: LD_INT 4
50413: ARRAY
50414: OR
50415: IFFALSE 50419
// continue ;
50417: GO 50381
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50419: LD_VAR 0 3
50423: PPUSH
50424: LD_EXP 136
50428: PUSH
50429: LD_VAR 0 2
50433: ARRAY
50434: PUSH
50435: LD_INT 1
50437: ARRAY
50438: PUSH
50439: LD_INT 1
50441: ARRAY
50442: PPUSH
50443: LD_EXP 136
50447: PUSH
50448: LD_VAR 0 2
50452: ARRAY
50453: PUSH
50454: LD_INT 1
50456: ARRAY
50457: PUSH
50458: LD_INT 2
50460: ARRAY
50461: PPUSH
50462: LD_EXP 136
50466: PUSH
50467: LD_VAR 0 2
50471: ARRAY
50472: PUSH
50473: LD_INT 1
50475: ARRAY
50476: PUSH
50477: LD_INT 3
50479: ARRAY
50480: PPUSH
50481: LD_EXP 136
50485: PUSH
50486: LD_VAR 0 2
50490: ARRAY
50491: PUSH
50492: LD_INT 1
50494: ARRAY
50495: PUSH
50496: LD_INT 4
50498: ARRAY
50499: PPUSH
50500: CALL_OW 448
50504: PUSH
50505: LD_VAR 0 3
50509: PPUSH
50510: LD_EXP 136
50514: PUSH
50515: LD_VAR 0 2
50519: ARRAY
50520: PUSH
50521: LD_INT 1
50523: ARRAY
50524: PUSH
50525: LD_INT 1
50527: ARRAY
50528: PUSH
50529: LD_EXP 136
50533: PUSH
50534: LD_VAR 0 2
50538: ARRAY
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PUSH
50544: LD_INT 2
50546: ARRAY
50547: PUSH
50548: LD_EXP 136
50552: PUSH
50553: LD_VAR 0 2
50557: ARRAY
50558: PUSH
50559: LD_INT 1
50561: ARRAY
50562: PUSH
50563: LD_INT 3
50565: ARRAY
50566: PUSH
50567: LD_EXP 136
50571: PUSH
50572: LD_VAR 0 2
50576: ARRAY
50577: PUSH
50578: LD_INT 1
50580: ARRAY
50581: PUSH
50582: LD_INT 4
50584: ARRAY
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: PPUSH
50592: CALL 76744 0 2
50596: AND
50597: IFFALSE 50735
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50599: LD_VAR 0 3
50603: PPUSH
50604: LD_EXP 136
50608: PUSH
50609: LD_VAR 0 2
50613: ARRAY
50614: PUSH
50615: LD_INT 1
50617: ARRAY
50618: PUSH
50619: LD_INT 1
50621: ARRAY
50622: PPUSH
50623: LD_EXP 136
50627: PUSH
50628: LD_VAR 0 2
50632: ARRAY
50633: PUSH
50634: LD_INT 1
50636: ARRAY
50637: PUSH
50638: LD_INT 2
50640: ARRAY
50641: PPUSH
50642: LD_EXP 136
50646: PUSH
50647: LD_VAR 0 2
50651: ARRAY
50652: PUSH
50653: LD_INT 1
50655: ARRAY
50656: PUSH
50657: LD_INT 3
50659: ARRAY
50660: PPUSH
50661: LD_EXP 136
50665: PUSH
50666: LD_VAR 0 2
50670: ARRAY
50671: PUSH
50672: LD_INT 1
50674: ARRAY
50675: PUSH
50676: LD_INT 4
50678: ARRAY
50679: PPUSH
50680: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50684: LD_ADDR_VAR 0 4
50688: PUSH
50689: LD_EXP 136
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PPUSH
50700: LD_INT 1
50702: PPUSH
50703: CALL_OW 3
50707: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50708: LD_ADDR_EXP 136
50712: PUSH
50713: LD_EXP 136
50717: PPUSH
50718: LD_VAR 0 2
50722: PPUSH
50723: LD_VAR 0 4
50727: PPUSH
50728: CALL_OW 1
50732: ST_TO_ADDR
// break ;
50733: GO 50737
// end ; end ;
50735: GO 50381
50737: POP
50738: POP
// end ;
50739: GO 50313
50741: POP
50742: POP
// end ;
50743: LD_VAR 0 1
50747: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
50752: PPUSH
// if not mc_bases then
50753: LD_EXP 115
50757: NOT
50758: IFFALSE 50762
// exit ;
50760: GO 50851
// for i = 1 to mc_bases do
50762: LD_ADDR_VAR 0 2
50766: PUSH
50767: DOUBLE
50768: LD_INT 1
50770: DEC
50771: ST_TO_ADDR
50772: LD_EXP 115
50776: PUSH
50777: FOR_TO
50778: IFFALSE 50849
// begin if mc_attack [ i ] then
50780: LD_EXP 135
50784: PUSH
50785: LD_VAR 0 2
50789: ARRAY
50790: IFFALSE 50847
// begin tmp := mc_attack [ i ] [ 1 ] ;
50792: LD_ADDR_VAR 0 3
50796: PUSH
50797: LD_EXP 135
50801: PUSH
50802: LD_VAR 0 2
50806: ARRAY
50807: PUSH
50808: LD_INT 1
50810: ARRAY
50811: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50812: LD_ADDR_EXP 135
50816: PUSH
50817: LD_EXP 135
50821: PPUSH
50822: LD_VAR 0 2
50826: PPUSH
50827: EMPTY
50828: PPUSH
50829: CALL_OW 1
50833: ST_TO_ADDR
// Attack ( tmp ) ;
50834: LD_VAR 0 3
50838: PPUSH
50839: CALL 120250 0 1
// exit ;
50843: POP
50844: POP
50845: GO 50851
// end ; end ;
50847: GO 50777
50849: POP
50850: POP
// end ;
50851: LD_VAR 0 1
50855: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50856: LD_INT 0
50858: PPUSH
50859: PPUSH
50860: PPUSH
50861: PPUSH
50862: PPUSH
50863: PPUSH
50864: PPUSH
// if not mc_bases then
50865: LD_EXP 115
50869: NOT
50870: IFFALSE 50874
// exit ;
50872: GO 51573
// for i = 1 to mc_bases do
50874: LD_ADDR_VAR 0 2
50878: PUSH
50879: DOUBLE
50880: LD_INT 1
50882: DEC
50883: ST_TO_ADDR
50884: LD_EXP 115
50888: PUSH
50889: FOR_TO
50890: IFFALSE 51571
// begin if not mc_bases [ i ] then
50892: LD_EXP 115
50896: PUSH
50897: LD_VAR 0 2
50901: ARRAY
50902: NOT
50903: IFFALSE 50907
// continue ;
50905: GO 50889
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50907: LD_ADDR_VAR 0 7
50911: PUSH
50912: LD_EXP 115
50916: PUSH
50917: LD_VAR 0 2
50921: ARRAY
50922: PUSH
50923: LD_INT 1
50925: ARRAY
50926: PPUSH
50927: CALL 67189 0 1
50931: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50932: LD_ADDR_EXP 138
50936: PUSH
50937: LD_EXP 138
50941: PPUSH
50942: LD_VAR 0 2
50946: PPUSH
50947: LD_EXP 115
50951: PUSH
50952: LD_VAR 0 2
50956: ARRAY
50957: PUSH
50958: LD_INT 1
50960: ARRAY
50961: PPUSH
50962: CALL_OW 255
50966: PPUSH
50967: LD_EXP 140
50971: PUSH
50972: LD_VAR 0 2
50976: ARRAY
50977: PPUSH
50978: CALL 67154 0 2
50982: PPUSH
50983: CALL_OW 1
50987: ST_TO_ADDR
// if not mc_scan [ i ] then
50988: LD_EXP 138
50992: PUSH
50993: LD_VAR 0 2
50997: ARRAY
50998: NOT
50999: IFFALSE 51177
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51001: LD_ADDR_VAR 0 4
51005: PUSH
51006: LD_EXP 115
51010: PUSH
51011: LD_VAR 0 2
51015: ARRAY
51016: PPUSH
51017: LD_INT 2
51019: PUSH
51020: LD_INT 25
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 25
51032: PUSH
51033: LD_INT 8
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: LD_INT 25
51042: PUSH
51043: LD_INT 9
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PUSH
51050: EMPTY
51051: LIST
51052: LIST
51053: LIST
51054: LIST
51055: PPUSH
51056: CALL_OW 72
51060: ST_TO_ADDR
// if not tmp then
51061: LD_VAR 0 4
51065: NOT
51066: IFFALSE 51070
// continue ;
51068: GO 50889
// for j in tmp do
51070: LD_ADDR_VAR 0 3
51074: PUSH
51075: LD_VAR 0 4
51079: PUSH
51080: FOR_IN
51081: IFFALSE 51152
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51083: LD_VAR 0 3
51087: PPUSH
51088: CALL_OW 310
51092: PPUSH
51093: CALL_OW 266
51097: PUSH
51098: LD_INT 5
51100: EQUAL
51101: PUSH
51102: LD_VAR 0 3
51106: PPUSH
51107: CALL_OW 257
51111: PUSH
51112: LD_INT 1
51114: EQUAL
51115: AND
51116: PUSH
51117: LD_VAR 0 3
51121: PPUSH
51122: CALL_OW 459
51126: NOT
51127: AND
51128: PUSH
51129: LD_VAR 0 7
51133: AND
51134: IFFALSE 51150
// ComChangeProfession ( j , class ) ;
51136: LD_VAR 0 3
51140: PPUSH
51141: LD_VAR 0 7
51145: PPUSH
51146: CALL_OW 123
51150: GO 51080
51152: POP
51153: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51154: LD_ADDR_EXP 158
51158: PUSH
51159: LD_EXP 158
51163: PPUSH
51164: LD_VAR 0 2
51168: PPUSH
51169: LD_INT 0
51171: PPUSH
51172: CALL_OW 1
51176: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51177: LD_EXP 138
51181: PUSH
51182: LD_VAR 0 2
51186: ARRAY
51187: PUSH
51188: LD_EXP 158
51192: PUSH
51193: LD_VAR 0 2
51197: ARRAY
51198: NOT
51199: AND
51200: PUSH
51201: LD_EXP 137
51205: PUSH
51206: LD_VAR 0 2
51210: ARRAY
51211: NOT
51212: AND
51213: PUSH
51214: LD_EXP 115
51218: PUSH
51219: LD_VAR 0 2
51223: ARRAY
51224: PPUSH
51225: LD_INT 30
51227: PUSH
51228: LD_INT 32
51230: PUSH
51231: EMPTY
51232: LIST
51233: LIST
51234: PPUSH
51235: CALL_OW 72
51239: NOT
51240: AND
51241: PUSH
51242: LD_EXP 115
51246: PUSH
51247: LD_VAR 0 2
51251: ARRAY
51252: PPUSH
51253: LD_INT 2
51255: PUSH
51256: LD_INT 30
51258: PUSH
51259: LD_INT 4
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: PUSH
51266: LD_INT 30
51268: PUSH
51269: LD_INT 5
51271: PUSH
51272: EMPTY
51273: LIST
51274: LIST
51275: PUSH
51276: EMPTY
51277: LIST
51278: LIST
51279: LIST
51280: PPUSH
51281: CALL_OW 72
51285: NOT
51286: AND
51287: IFFALSE 51442
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51289: LD_ADDR_VAR 0 4
51293: PUSH
51294: LD_EXP 115
51298: PUSH
51299: LD_VAR 0 2
51303: ARRAY
51304: PPUSH
51305: LD_INT 2
51307: PUSH
51308: LD_INT 25
51310: PUSH
51311: LD_INT 1
51313: PUSH
51314: EMPTY
51315: LIST
51316: LIST
51317: PUSH
51318: LD_INT 25
51320: PUSH
51321: LD_INT 5
51323: PUSH
51324: EMPTY
51325: LIST
51326: LIST
51327: PUSH
51328: LD_INT 25
51330: PUSH
51331: LD_INT 8
51333: PUSH
51334: EMPTY
51335: LIST
51336: LIST
51337: PUSH
51338: LD_INT 25
51340: PUSH
51341: LD_INT 9
51343: PUSH
51344: EMPTY
51345: LIST
51346: LIST
51347: PUSH
51348: EMPTY
51349: LIST
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: PPUSH
51355: CALL_OW 72
51359: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51360: LD_ADDR_VAR 0 4
51364: PUSH
51365: LD_VAR 0 4
51369: PUSH
51370: LD_VAR 0 4
51374: PPUSH
51375: LD_INT 18
51377: PPUSH
51378: CALL 99247 0 2
51382: DIFF
51383: ST_TO_ADDR
// if tmp then
51384: LD_VAR 0 4
51388: IFFALSE 51442
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51390: LD_ADDR_EXP 158
51394: PUSH
51395: LD_EXP 158
51399: PPUSH
51400: LD_VAR 0 2
51404: PPUSH
51405: LD_INT 1
51407: PPUSH
51408: CALL_OW 1
51412: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51413: LD_VAR 0 2
51417: PPUSH
51418: LD_VAR 0 4
51422: PPUSH
51423: LD_EXP 140
51427: PUSH
51428: LD_VAR 0 2
51432: ARRAY
51433: PPUSH
51434: CALL 124959 0 3
// exit ;
51438: POP
51439: POP
51440: GO 51573
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51442: LD_EXP 138
51446: PUSH
51447: LD_VAR 0 2
51451: ARRAY
51452: PUSH
51453: LD_EXP 158
51457: PUSH
51458: LD_VAR 0 2
51462: ARRAY
51463: NOT
51464: AND
51465: PUSH
51466: LD_EXP 137
51470: PUSH
51471: LD_VAR 0 2
51475: ARRAY
51476: AND
51477: IFFALSE 51569
// begin tmp := mc_defender [ i ] ;
51479: LD_ADDR_VAR 0 4
51483: PUSH
51484: LD_EXP 137
51488: PUSH
51489: LD_VAR 0 2
51493: ARRAY
51494: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51495: LD_ADDR_EXP 137
51499: PUSH
51500: LD_EXP 137
51504: PPUSH
51505: LD_VAR 0 2
51509: PPUSH
51510: EMPTY
51511: PPUSH
51512: CALL_OW 1
51516: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51517: LD_ADDR_EXP 158
51521: PUSH
51522: LD_EXP 158
51526: PPUSH
51527: LD_VAR 0 2
51531: PPUSH
51532: LD_INT 1
51534: PPUSH
51535: CALL_OW 1
51539: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51540: LD_VAR 0 2
51544: PPUSH
51545: LD_VAR 0 4
51549: PPUSH
51550: LD_EXP 138
51554: PUSH
51555: LD_VAR 0 2
51559: ARRAY
51560: PPUSH
51561: CALL 125520 0 3
// exit ;
51565: POP
51566: POP
51567: GO 51573
// end ; end ;
51569: GO 50889
51571: POP
51572: POP
// end ;
51573: LD_VAR 0 1
51577: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51578: LD_INT 0
51580: PPUSH
51581: PPUSH
51582: PPUSH
51583: PPUSH
51584: PPUSH
51585: PPUSH
51586: PPUSH
51587: PPUSH
51588: PPUSH
51589: PPUSH
51590: PPUSH
// if not mc_bases then
51591: LD_EXP 115
51595: NOT
51596: IFFALSE 51600
// exit ;
51598: GO 52687
// for i = 1 to mc_bases do
51600: LD_ADDR_VAR 0 2
51604: PUSH
51605: DOUBLE
51606: LD_INT 1
51608: DEC
51609: ST_TO_ADDR
51610: LD_EXP 115
51614: PUSH
51615: FOR_TO
51616: IFFALSE 52685
// begin tmp := mc_lab [ i ] ;
51618: LD_ADDR_VAR 0 6
51622: PUSH
51623: LD_EXP 148
51627: PUSH
51628: LD_VAR 0 2
51632: ARRAY
51633: ST_TO_ADDR
// if not tmp then
51634: LD_VAR 0 6
51638: NOT
51639: IFFALSE 51643
// continue ;
51641: GO 51615
// idle_lab := 0 ;
51643: LD_ADDR_VAR 0 11
51647: PUSH
51648: LD_INT 0
51650: ST_TO_ADDR
// for j in tmp do
51651: LD_ADDR_VAR 0 3
51655: PUSH
51656: LD_VAR 0 6
51660: PUSH
51661: FOR_IN
51662: IFFALSE 52681
// begin researching := false ;
51664: LD_ADDR_VAR 0 10
51668: PUSH
51669: LD_INT 0
51671: ST_TO_ADDR
// side := GetSide ( j ) ;
51672: LD_ADDR_VAR 0 4
51676: PUSH
51677: LD_VAR 0 3
51681: PPUSH
51682: CALL_OW 255
51686: ST_TO_ADDR
// if not mc_tech [ side ] then
51687: LD_EXP 142
51691: PUSH
51692: LD_VAR 0 4
51696: ARRAY
51697: NOT
51698: IFFALSE 51702
// continue ;
51700: GO 51661
// if BuildingStatus ( j ) = bs_idle then
51702: LD_VAR 0 3
51706: PPUSH
51707: CALL_OW 461
51711: PUSH
51712: LD_INT 2
51714: EQUAL
51715: IFFALSE 51903
// begin if idle_lab and UnitsInside ( j ) < 6 then
51717: LD_VAR 0 11
51721: PUSH
51722: LD_VAR 0 3
51726: PPUSH
51727: CALL_OW 313
51731: PUSH
51732: LD_INT 6
51734: LESS
51735: AND
51736: IFFALSE 51807
// begin tmp2 := UnitsInside ( idle_lab ) ;
51738: LD_ADDR_VAR 0 9
51742: PUSH
51743: LD_VAR 0 11
51747: PPUSH
51748: CALL_OW 313
51752: ST_TO_ADDR
// if tmp2 then
51753: LD_VAR 0 9
51757: IFFALSE 51799
// for x in tmp2 do
51759: LD_ADDR_VAR 0 7
51763: PUSH
51764: LD_VAR 0 9
51768: PUSH
51769: FOR_IN
51770: IFFALSE 51797
// begin ComExitBuilding ( x ) ;
51772: LD_VAR 0 7
51776: PPUSH
51777: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51781: LD_VAR 0 7
51785: PPUSH
51786: LD_VAR 0 3
51790: PPUSH
51791: CALL_OW 180
// end ;
51795: GO 51769
51797: POP
51798: POP
// idle_lab := 0 ;
51799: LD_ADDR_VAR 0 11
51803: PUSH
51804: LD_INT 0
51806: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51807: LD_ADDR_VAR 0 5
51811: PUSH
51812: LD_EXP 142
51816: PUSH
51817: LD_VAR 0 4
51821: ARRAY
51822: PUSH
51823: FOR_IN
51824: IFFALSE 51884
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51826: LD_VAR 0 3
51830: PPUSH
51831: LD_VAR 0 5
51835: PPUSH
51836: CALL_OW 430
51840: PUSH
51841: LD_VAR 0 4
51845: PPUSH
51846: LD_VAR 0 5
51850: PPUSH
51851: CALL 66259 0 2
51855: AND
51856: IFFALSE 51882
// begin researching := true ;
51858: LD_ADDR_VAR 0 10
51862: PUSH
51863: LD_INT 1
51865: ST_TO_ADDR
// ComResearch ( j , t ) ;
51866: LD_VAR 0 3
51870: PPUSH
51871: LD_VAR 0 5
51875: PPUSH
51876: CALL_OW 124
// break ;
51880: GO 51884
// end ;
51882: GO 51823
51884: POP
51885: POP
// if not researching then
51886: LD_VAR 0 10
51890: NOT
51891: IFFALSE 51903
// idle_lab := j ;
51893: LD_ADDR_VAR 0 11
51897: PUSH
51898: LD_VAR 0 3
51902: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51903: LD_VAR 0 3
51907: PPUSH
51908: CALL_OW 461
51912: PUSH
51913: LD_INT 10
51915: EQUAL
51916: IFFALSE 52504
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51918: LD_EXP 144
51922: PUSH
51923: LD_VAR 0 2
51927: ARRAY
51928: NOT
51929: PUSH
51930: LD_EXP 145
51934: PUSH
51935: LD_VAR 0 2
51939: ARRAY
51940: NOT
51941: AND
51942: PUSH
51943: LD_EXP 142
51947: PUSH
51948: LD_VAR 0 4
51952: ARRAY
51953: PUSH
51954: LD_INT 1
51956: GREATER
51957: AND
51958: IFFALSE 52089
// begin ComCancel ( j ) ;
51960: LD_VAR 0 3
51964: PPUSH
51965: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51969: LD_ADDR_EXP 142
51973: PUSH
51974: LD_EXP 142
51978: PPUSH
51979: LD_VAR 0 4
51983: PPUSH
51984: LD_EXP 142
51988: PUSH
51989: LD_VAR 0 4
51993: ARRAY
51994: PPUSH
51995: LD_EXP 142
51999: PUSH
52000: LD_VAR 0 4
52004: ARRAY
52005: PUSH
52006: LD_INT 1
52008: MINUS
52009: PPUSH
52010: LD_EXP 142
52014: PUSH
52015: LD_VAR 0 4
52019: ARRAY
52020: PPUSH
52021: LD_INT 0
52023: PPUSH
52024: CALL 69771 0 4
52028: PPUSH
52029: CALL_OW 1
52033: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52034: LD_ADDR_EXP 142
52038: PUSH
52039: LD_EXP 142
52043: PPUSH
52044: LD_VAR 0 4
52048: PPUSH
52049: LD_EXP 142
52053: PUSH
52054: LD_VAR 0 4
52058: ARRAY
52059: PPUSH
52060: LD_EXP 142
52064: PUSH
52065: LD_VAR 0 4
52069: ARRAY
52070: PPUSH
52071: LD_INT 1
52073: PPUSH
52074: LD_INT 0
52076: PPUSH
52077: CALL 69771 0 4
52081: PPUSH
52082: CALL_OW 1
52086: ST_TO_ADDR
// continue ;
52087: GO 51661
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52089: LD_EXP 144
52093: PUSH
52094: LD_VAR 0 2
52098: ARRAY
52099: PUSH
52100: LD_EXP 145
52104: PUSH
52105: LD_VAR 0 2
52109: ARRAY
52110: NOT
52111: AND
52112: IFFALSE 52239
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52114: LD_ADDR_EXP 145
52118: PUSH
52119: LD_EXP 145
52123: PPUSH
52124: LD_VAR 0 2
52128: PUSH
52129: LD_EXP 145
52133: PUSH
52134: LD_VAR 0 2
52138: ARRAY
52139: PUSH
52140: LD_INT 1
52142: PLUS
52143: PUSH
52144: EMPTY
52145: LIST
52146: LIST
52147: PPUSH
52148: LD_EXP 144
52152: PUSH
52153: LD_VAR 0 2
52157: ARRAY
52158: PUSH
52159: LD_INT 1
52161: ARRAY
52162: PPUSH
52163: CALL 70353 0 3
52167: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52168: LD_EXP 144
52172: PUSH
52173: LD_VAR 0 2
52177: ARRAY
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PPUSH
52183: LD_INT 112
52185: PPUSH
52186: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52190: LD_ADDR_VAR 0 9
52194: PUSH
52195: LD_EXP 144
52199: PUSH
52200: LD_VAR 0 2
52204: ARRAY
52205: PPUSH
52206: LD_INT 1
52208: PPUSH
52209: CALL_OW 3
52213: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52214: LD_ADDR_EXP 144
52218: PUSH
52219: LD_EXP 144
52223: PPUSH
52224: LD_VAR 0 2
52228: PPUSH
52229: LD_VAR 0 9
52233: PPUSH
52234: CALL_OW 1
52238: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52239: LD_EXP 144
52243: PUSH
52244: LD_VAR 0 2
52248: ARRAY
52249: PUSH
52250: LD_EXP 145
52254: PUSH
52255: LD_VAR 0 2
52259: ARRAY
52260: AND
52261: PUSH
52262: LD_EXP 145
52266: PUSH
52267: LD_VAR 0 2
52271: ARRAY
52272: PUSH
52273: LD_INT 1
52275: ARRAY
52276: PPUSH
52277: CALL_OW 310
52281: NOT
52282: AND
52283: PUSH
52284: LD_VAR 0 3
52288: PPUSH
52289: CALL_OW 313
52293: PUSH
52294: LD_INT 6
52296: EQUAL
52297: AND
52298: IFFALSE 52354
// begin tmp2 := UnitsInside ( j ) ;
52300: LD_ADDR_VAR 0 9
52304: PUSH
52305: LD_VAR 0 3
52309: PPUSH
52310: CALL_OW 313
52314: ST_TO_ADDR
// if tmp2 = 6 then
52315: LD_VAR 0 9
52319: PUSH
52320: LD_INT 6
52322: EQUAL
52323: IFFALSE 52354
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52325: LD_VAR 0 9
52329: PUSH
52330: LD_INT 1
52332: ARRAY
52333: PPUSH
52334: LD_INT 112
52336: PPUSH
52337: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52341: LD_VAR 0 9
52345: PUSH
52346: LD_INT 1
52348: ARRAY
52349: PPUSH
52350: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52354: LD_EXP 145
52358: PUSH
52359: LD_VAR 0 2
52363: ARRAY
52364: PUSH
52365: LD_EXP 145
52369: PUSH
52370: LD_VAR 0 2
52374: ARRAY
52375: PUSH
52376: LD_INT 1
52378: ARRAY
52379: PPUSH
52380: CALL_OW 314
52384: NOT
52385: AND
52386: PUSH
52387: LD_EXP 145
52391: PUSH
52392: LD_VAR 0 2
52396: ARRAY
52397: PUSH
52398: LD_INT 1
52400: ARRAY
52401: PPUSH
52402: CALL_OW 310
52406: NOT
52407: AND
52408: IFFALSE 52434
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52410: LD_EXP 145
52414: PUSH
52415: LD_VAR 0 2
52419: ARRAY
52420: PUSH
52421: LD_INT 1
52423: ARRAY
52424: PPUSH
52425: LD_VAR 0 3
52429: PPUSH
52430: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52434: LD_EXP 145
52438: PUSH
52439: LD_VAR 0 2
52443: ARRAY
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PPUSH
52449: CALL_OW 310
52453: PUSH
52454: LD_EXP 145
52458: PUSH
52459: LD_VAR 0 2
52463: ARRAY
52464: PUSH
52465: LD_INT 1
52467: ARRAY
52468: PPUSH
52469: CALL_OW 310
52473: PPUSH
52474: CALL_OW 461
52478: PUSH
52479: LD_INT 3
52481: NONEQUAL
52482: AND
52483: IFFALSE 52504
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52485: LD_EXP 145
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PUSH
52496: LD_INT 1
52498: ARRAY
52499: PPUSH
52500: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52504: LD_VAR 0 3
52508: PPUSH
52509: CALL_OW 461
52513: PUSH
52514: LD_INT 6
52516: EQUAL
52517: PUSH
52518: LD_VAR 0 6
52522: PUSH
52523: LD_INT 1
52525: GREATER
52526: AND
52527: IFFALSE 52679
// begin sci := [ ] ;
52529: LD_ADDR_VAR 0 8
52533: PUSH
52534: EMPTY
52535: ST_TO_ADDR
// for x in ( tmp diff j ) do
52536: LD_ADDR_VAR 0 7
52540: PUSH
52541: LD_VAR 0 6
52545: PUSH
52546: LD_VAR 0 3
52550: DIFF
52551: PUSH
52552: FOR_IN
52553: IFFALSE 52605
// begin if sci = 6 then
52555: LD_VAR 0 8
52559: PUSH
52560: LD_INT 6
52562: EQUAL
52563: IFFALSE 52567
// break ;
52565: GO 52605
// if BuildingStatus ( x ) = bs_idle then
52567: LD_VAR 0 7
52571: PPUSH
52572: CALL_OW 461
52576: PUSH
52577: LD_INT 2
52579: EQUAL
52580: IFFALSE 52603
// sci := sci ^ UnitsInside ( x ) ;
52582: LD_ADDR_VAR 0 8
52586: PUSH
52587: LD_VAR 0 8
52591: PUSH
52592: LD_VAR 0 7
52596: PPUSH
52597: CALL_OW 313
52601: ADD
52602: ST_TO_ADDR
// end ;
52603: GO 52552
52605: POP
52606: POP
// if not sci then
52607: LD_VAR 0 8
52611: NOT
52612: IFFALSE 52616
// continue ;
52614: GO 51661
// for x in sci do
52616: LD_ADDR_VAR 0 7
52620: PUSH
52621: LD_VAR 0 8
52625: PUSH
52626: FOR_IN
52627: IFFALSE 52677
// if IsInUnit ( x ) and not HasTask ( x ) then
52629: LD_VAR 0 7
52633: PPUSH
52634: CALL_OW 310
52638: PUSH
52639: LD_VAR 0 7
52643: PPUSH
52644: CALL_OW 314
52648: NOT
52649: AND
52650: IFFALSE 52675
// begin ComExitBuilding ( x ) ;
52652: LD_VAR 0 7
52656: PPUSH
52657: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52661: LD_VAR 0 7
52665: PPUSH
52666: LD_VAR 0 3
52670: PPUSH
52671: CALL_OW 180
// end ;
52675: GO 52626
52677: POP
52678: POP
// end ; end ;
52679: GO 51661
52681: POP
52682: POP
// end ;
52683: GO 51615
52685: POP
52686: POP
// end ;
52687: LD_VAR 0 1
52691: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52692: LD_INT 0
52694: PPUSH
52695: PPUSH
// if not mc_bases then
52696: LD_EXP 115
52700: NOT
52701: IFFALSE 52705
// exit ;
52703: GO 52786
// for i = 1 to mc_bases do
52705: LD_ADDR_VAR 0 2
52709: PUSH
52710: DOUBLE
52711: LD_INT 1
52713: DEC
52714: ST_TO_ADDR
52715: LD_EXP 115
52719: PUSH
52720: FOR_TO
52721: IFFALSE 52784
// if mc_mines [ i ] and mc_miners [ i ] then
52723: LD_EXP 128
52727: PUSH
52728: LD_VAR 0 2
52732: ARRAY
52733: PUSH
52734: LD_EXP 129
52738: PUSH
52739: LD_VAR 0 2
52743: ARRAY
52744: AND
52745: IFFALSE 52782
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52747: LD_EXP 129
52751: PUSH
52752: LD_VAR 0 2
52756: ARRAY
52757: PUSH
52758: LD_INT 1
52760: ARRAY
52761: PPUSH
52762: CALL_OW 255
52766: PPUSH
52767: LD_EXP 128
52771: PUSH
52772: LD_VAR 0 2
52776: ARRAY
52777: PPUSH
52778: CALL 67342 0 2
52782: GO 52720
52784: POP
52785: POP
// end ;
52786: LD_VAR 0 1
52790: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52791: LD_INT 0
52793: PPUSH
52794: PPUSH
52795: PPUSH
52796: PPUSH
52797: PPUSH
52798: PPUSH
52799: PPUSH
52800: PPUSH
// if not mc_bases or not mc_parking then
52801: LD_EXP 115
52805: NOT
52806: PUSH
52807: LD_EXP 139
52811: NOT
52812: OR
52813: IFFALSE 52817
// exit ;
52815: GO 53516
// for i = 1 to mc_bases do
52817: LD_ADDR_VAR 0 2
52821: PUSH
52822: DOUBLE
52823: LD_INT 1
52825: DEC
52826: ST_TO_ADDR
52827: LD_EXP 115
52831: PUSH
52832: FOR_TO
52833: IFFALSE 53514
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52835: LD_EXP 115
52839: PUSH
52840: LD_VAR 0 2
52844: ARRAY
52845: NOT
52846: PUSH
52847: LD_EXP 139
52851: PUSH
52852: LD_VAR 0 2
52856: ARRAY
52857: NOT
52858: OR
52859: IFFALSE 52863
// continue ;
52861: GO 52832
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52863: LD_ADDR_VAR 0 5
52867: PUSH
52868: LD_EXP 115
52872: PUSH
52873: LD_VAR 0 2
52877: ARRAY
52878: PUSH
52879: LD_INT 1
52881: ARRAY
52882: PPUSH
52883: CALL_OW 255
52887: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52888: LD_ADDR_VAR 0 6
52892: PUSH
52893: LD_EXP 115
52897: PUSH
52898: LD_VAR 0 2
52902: ARRAY
52903: PPUSH
52904: LD_INT 30
52906: PUSH
52907: LD_INT 3
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: PPUSH
52914: CALL_OW 72
52918: ST_TO_ADDR
// if not fac then
52919: LD_VAR 0 6
52923: NOT
52924: IFFALSE 52975
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52926: LD_ADDR_VAR 0 6
52930: PUSH
52931: LD_EXP 115
52935: PUSH
52936: LD_VAR 0 2
52940: ARRAY
52941: PPUSH
52942: LD_INT 2
52944: PUSH
52945: LD_INT 30
52947: PUSH
52948: LD_INT 0
52950: PUSH
52951: EMPTY
52952: LIST
52953: LIST
52954: PUSH
52955: LD_INT 30
52957: PUSH
52958: LD_INT 1
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: PUSH
52965: EMPTY
52966: LIST
52967: LIST
52968: LIST
52969: PPUSH
52970: CALL_OW 72
52974: ST_TO_ADDR
// if not fac then
52975: LD_VAR 0 6
52979: NOT
52980: IFFALSE 52984
// continue ;
52982: GO 52832
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52984: LD_ADDR_VAR 0 7
52988: PUSH
52989: LD_EXP 139
52993: PUSH
52994: LD_VAR 0 2
52998: ARRAY
52999: PPUSH
53000: LD_INT 22
53002: PUSH
53003: LD_VAR 0 5
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: LD_INT 21
53014: PUSH
53015: LD_INT 2
53017: PUSH
53018: EMPTY
53019: LIST
53020: LIST
53021: PUSH
53022: LD_INT 3
53024: PUSH
53025: LD_INT 24
53027: PUSH
53028: LD_INT 1000
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: LIST
53043: PPUSH
53044: CALL_OW 70
53048: ST_TO_ADDR
// for j in fac do
53049: LD_ADDR_VAR 0 3
53053: PUSH
53054: LD_VAR 0 6
53058: PUSH
53059: FOR_IN
53060: IFFALSE 53141
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53062: LD_ADDR_VAR 0 7
53066: PUSH
53067: LD_VAR 0 7
53071: PUSH
53072: LD_INT 22
53074: PUSH
53075: LD_VAR 0 5
53079: PUSH
53080: EMPTY
53081: LIST
53082: LIST
53083: PUSH
53084: LD_INT 91
53086: PUSH
53087: LD_VAR 0 3
53091: PUSH
53092: LD_INT 15
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: LIST
53099: PUSH
53100: LD_INT 21
53102: PUSH
53103: LD_INT 2
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: PUSH
53110: LD_INT 3
53112: PUSH
53113: LD_INT 24
53115: PUSH
53116: LD_INT 1000
53118: PUSH
53119: EMPTY
53120: LIST
53121: LIST
53122: PUSH
53123: EMPTY
53124: LIST
53125: LIST
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: LIST
53131: LIST
53132: PPUSH
53133: CALL_OW 69
53137: UNION
53138: ST_TO_ADDR
53139: GO 53059
53141: POP
53142: POP
// if not vehs then
53143: LD_VAR 0 7
53147: NOT
53148: IFFALSE 53174
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53150: LD_ADDR_EXP 127
53154: PUSH
53155: LD_EXP 127
53159: PPUSH
53160: LD_VAR 0 2
53164: PPUSH
53165: EMPTY
53166: PPUSH
53167: CALL_OW 1
53171: ST_TO_ADDR
// continue ;
53172: GO 52832
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53174: LD_ADDR_VAR 0 8
53178: PUSH
53179: LD_EXP 115
53183: PUSH
53184: LD_VAR 0 2
53188: ARRAY
53189: PPUSH
53190: LD_INT 30
53192: PUSH
53193: LD_INT 3
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PPUSH
53200: CALL_OW 72
53204: ST_TO_ADDR
// if tmp then
53205: LD_VAR 0 8
53209: IFFALSE 53312
// begin for j in tmp do
53211: LD_ADDR_VAR 0 3
53215: PUSH
53216: LD_VAR 0 8
53220: PUSH
53221: FOR_IN
53222: IFFALSE 53310
// for k in UnitsInside ( j ) do
53224: LD_ADDR_VAR 0 4
53228: PUSH
53229: LD_VAR 0 3
53233: PPUSH
53234: CALL_OW 313
53238: PUSH
53239: FOR_IN
53240: IFFALSE 53306
// if k then
53242: LD_VAR 0 4
53246: IFFALSE 53304
// if not k in mc_repair_vehicle [ i ] then
53248: LD_VAR 0 4
53252: PUSH
53253: LD_EXP 127
53257: PUSH
53258: LD_VAR 0 2
53262: ARRAY
53263: IN
53264: NOT
53265: IFFALSE 53304
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53267: LD_ADDR_EXP 127
53271: PUSH
53272: LD_EXP 127
53276: PPUSH
53277: LD_VAR 0 2
53281: PPUSH
53282: LD_EXP 127
53286: PUSH
53287: LD_VAR 0 2
53291: ARRAY
53292: PUSH
53293: LD_VAR 0 4
53297: UNION
53298: PPUSH
53299: CALL_OW 1
53303: ST_TO_ADDR
53304: GO 53239
53306: POP
53307: POP
53308: GO 53221
53310: POP
53311: POP
// end ; if not mc_repair_vehicle [ i ] then
53312: LD_EXP 127
53316: PUSH
53317: LD_VAR 0 2
53321: ARRAY
53322: NOT
53323: IFFALSE 53327
// continue ;
53325: GO 52832
// for j in mc_repair_vehicle [ i ] do
53327: LD_ADDR_VAR 0 3
53331: PUSH
53332: LD_EXP 127
53336: PUSH
53337: LD_VAR 0 2
53341: ARRAY
53342: PUSH
53343: FOR_IN
53344: IFFALSE 53510
// begin if GetClass ( j ) <> 3 then
53346: LD_VAR 0 3
53350: PPUSH
53351: CALL_OW 257
53355: PUSH
53356: LD_INT 3
53358: NONEQUAL
53359: IFFALSE 53400
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53361: LD_ADDR_EXP 127
53365: PUSH
53366: LD_EXP 127
53370: PPUSH
53371: LD_VAR 0 2
53375: PPUSH
53376: LD_EXP 127
53380: PUSH
53381: LD_VAR 0 2
53385: ARRAY
53386: PUSH
53387: LD_VAR 0 3
53391: DIFF
53392: PPUSH
53393: CALL_OW 1
53397: ST_TO_ADDR
// continue ;
53398: GO 53343
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53400: LD_VAR 0 3
53404: PPUSH
53405: CALL_OW 311
53409: NOT
53410: PUSH
53411: LD_VAR 0 3
53415: PUSH
53416: LD_EXP 118
53420: PUSH
53421: LD_VAR 0 2
53425: ARRAY
53426: PUSH
53427: LD_INT 1
53429: ARRAY
53430: IN
53431: NOT
53432: AND
53433: PUSH
53434: LD_VAR 0 3
53438: PUSH
53439: LD_EXP 118
53443: PUSH
53444: LD_VAR 0 2
53448: ARRAY
53449: PUSH
53450: LD_INT 2
53452: ARRAY
53453: IN
53454: NOT
53455: AND
53456: IFFALSE 53508
// begin if IsInUnit ( j ) then
53458: LD_VAR 0 3
53462: PPUSH
53463: CALL_OW 310
53467: IFFALSE 53478
// ComExitBuilding ( j ) ;
53469: LD_VAR 0 3
53473: PPUSH
53474: CALL_OW 122
// if not HasTask ( j ) then
53478: LD_VAR 0 3
53482: PPUSH
53483: CALL_OW 314
53487: NOT
53488: IFFALSE 53508
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53490: LD_VAR 0 3
53494: PPUSH
53495: LD_VAR 0 7
53499: PUSH
53500: LD_INT 1
53502: ARRAY
53503: PPUSH
53504: CALL_OW 189
// end ; end ;
53508: GO 53343
53510: POP
53511: POP
// end ;
53512: GO 52832
53514: POP
53515: POP
// end ;
53516: LD_VAR 0 1
53520: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53521: LD_INT 0
53523: PPUSH
53524: PPUSH
53525: PPUSH
53526: PPUSH
53527: PPUSH
53528: PPUSH
53529: PPUSH
53530: PPUSH
53531: PPUSH
53532: PPUSH
53533: PPUSH
// if not mc_bases then
53534: LD_EXP 115
53538: NOT
53539: IFFALSE 53543
// exit ;
53541: GO 54345
// for i = 1 to mc_bases do
53543: LD_ADDR_VAR 0 2
53547: PUSH
53548: DOUBLE
53549: LD_INT 1
53551: DEC
53552: ST_TO_ADDR
53553: LD_EXP 115
53557: PUSH
53558: FOR_TO
53559: IFFALSE 54343
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53561: LD_EXP 143
53565: PUSH
53566: LD_VAR 0 2
53570: ARRAY
53571: NOT
53572: PUSH
53573: LD_EXP 118
53577: PUSH
53578: LD_VAR 0 2
53582: ARRAY
53583: PUSH
53584: LD_INT 1
53586: ARRAY
53587: OR
53588: PUSH
53589: LD_EXP 118
53593: PUSH
53594: LD_VAR 0 2
53598: ARRAY
53599: PUSH
53600: LD_INT 2
53602: ARRAY
53603: OR
53604: PUSH
53605: LD_EXP 141
53609: PUSH
53610: LD_VAR 0 2
53614: ARRAY
53615: PPUSH
53616: LD_INT 1
53618: PPUSH
53619: CALL_OW 325
53623: NOT
53624: OR
53625: PUSH
53626: LD_EXP 138
53630: PUSH
53631: LD_VAR 0 2
53635: ARRAY
53636: OR
53637: IFFALSE 53641
// continue ;
53639: GO 53558
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53641: LD_ADDR_VAR 0 8
53645: PUSH
53646: LD_EXP 115
53650: PUSH
53651: LD_VAR 0 2
53655: ARRAY
53656: PPUSH
53657: LD_INT 25
53659: PUSH
53660: LD_INT 4
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PUSH
53667: LD_INT 50
53669: PUSH
53670: EMPTY
53671: LIST
53672: PUSH
53673: LD_INT 3
53675: PUSH
53676: LD_INT 60
53678: PUSH
53679: EMPTY
53680: LIST
53681: PUSH
53682: EMPTY
53683: LIST
53684: LIST
53685: PUSH
53686: EMPTY
53687: LIST
53688: LIST
53689: LIST
53690: PPUSH
53691: CALL_OW 72
53695: PUSH
53696: LD_EXP 119
53700: PUSH
53701: LD_VAR 0 2
53705: ARRAY
53706: DIFF
53707: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53708: LD_ADDR_VAR 0 9
53712: PUSH
53713: LD_EXP 115
53717: PUSH
53718: LD_VAR 0 2
53722: ARRAY
53723: PPUSH
53724: LD_INT 2
53726: PUSH
53727: LD_INT 30
53729: PUSH
53730: LD_INT 0
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: PUSH
53737: LD_INT 30
53739: PUSH
53740: LD_INT 1
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: PUSH
53747: EMPTY
53748: LIST
53749: LIST
53750: LIST
53751: PPUSH
53752: CALL_OW 72
53756: ST_TO_ADDR
// if not tmp or not dep then
53757: LD_VAR 0 8
53761: NOT
53762: PUSH
53763: LD_VAR 0 9
53767: NOT
53768: OR
53769: IFFALSE 53773
// continue ;
53771: GO 53558
// side := GetSide ( tmp [ 1 ] ) ;
53773: LD_ADDR_VAR 0 11
53777: PUSH
53778: LD_VAR 0 8
53782: PUSH
53783: LD_INT 1
53785: ARRAY
53786: PPUSH
53787: CALL_OW 255
53791: ST_TO_ADDR
// dep := dep [ 1 ] ;
53792: LD_ADDR_VAR 0 9
53796: PUSH
53797: LD_VAR 0 9
53801: PUSH
53802: LD_INT 1
53804: ARRAY
53805: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53806: LD_ADDR_VAR 0 7
53810: PUSH
53811: LD_EXP 143
53815: PUSH
53816: LD_VAR 0 2
53820: ARRAY
53821: PPUSH
53822: LD_INT 22
53824: PUSH
53825: LD_INT 0
53827: PUSH
53828: EMPTY
53829: LIST
53830: LIST
53831: PUSH
53832: LD_INT 25
53834: PUSH
53835: LD_INT 12
53837: PUSH
53838: EMPTY
53839: LIST
53840: LIST
53841: PUSH
53842: EMPTY
53843: LIST
53844: LIST
53845: PPUSH
53846: CALL_OW 70
53850: PUSH
53851: LD_INT 22
53853: PUSH
53854: LD_INT 0
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: PUSH
53861: LD_INT 25
53863: PUSH
53864: LD_INT 12
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: PUSH
53871: LD_INT 91
53873: PUSH
53874: LD_VAR 0 9
53878: PUSH
53879: LD_INT 20
53881: PUSH
53882: EMPTY
53883: LIST
53884: LIST
53885: LIST
53886: PUSH
53887: EMPTY
53888: LIST
53889: LIST
53890: LIST
53891: PPUSH
53892: CALL_OW 69
53896: UNION
53897: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53898: LD_ADDR_VAR 0 10
53902: PUSH
53903: LD_EXP 143
53907: PUSH
53908: LD_VAR 0 2
53912: ARRAY
53913: PPUSH
53914: LD_INT 81
53916: PUSH
53917: LD_VAR 0 11
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: PPUSH
53926: CALL_OW 70
53930: ST_TO_ADDR
// if not apes or danger_at_area then
53931: LD_VAR 0 7
53935: NOT
53936: PUSH
53937: LD_VAR 0 10
53941: OR
53942: IFFALSE 53992
// begin if mc_taming [ i ] then
53944: LD_EXP 146
53948: PUSH
53949: LD_VAR 0 2
53953: ARRAY
53954: IFFALSE 53990
// begin MC_Reset ( i , 121 ) ;
53956: LD_VAR 0 2
53960: PPUSH
53961: LD_INT 121
53963: PPUSH
53964: CALL 39279 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53968: LD_ADDR_EXP 146
53972: PUSH
53973: LD_EXP 146
53977: PPUSH
53978: LD_VAR 0 2
53982: PPUSH
53983: EMPTY
53984: PPUSH
53985: CALL_OW 1
53989: ST_TO_ADDR
// end ; continue ;
53990: GO 53558
// end ; for j in tmp do
53992: LD_ADDR_VAR 0 3
53996: PUSH
53997: LD_VAR 0 8
54001: PUSH
54002: FOR_IN
54003: IFFALSE 54339
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54005: LD_VAR 0 3
54009: PUSH
54010: LD_EXP 146
54014: PUSH
54015: LD_VAR 0 2
54019: ARRAY
54020: IN
54021: NOT
54022: PUSH
54023: LD_EXP 146
54027: PUSH
54028: LD_VAR 0 2
54032: ARRAY
54033: PUSH
54034: LD_INT 3
54036: LESS
54037: AND
54038: IFFALSE 54096
// begin SetTag ( j , 121 ) ;
54040: LD_VAR 0 3
54044: PPUSH
54045: LD_INT 121
54047: PPUSH
54048: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54052: LD_ADDR_EXP 146
54056: PUSH
54057: LD_EXP 146
54061: PPUSH
54062: LD_VAR 0 2
54066: PUSH
54067: LD_EXP 146
54071: PUSH
54072: LD_VAR 0 2
54076: ARRAY
54077: PUSH
54078: LD_INT 1
54080: PLUS
54081: PUSH
54082: EMPTY
54083: LIST
54084: LIST
54085: PPUSH
54086: LD_VAR 0 3
54090: PPUSH
54091: CALL 70353 0 3
54095: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54096: LD_VAR 0 3
54100: PUSH
54101: LD_EXP 146
54105: PUSH
54106: LD_VAR 0 2
54110: ARRAY
54111: IN
54112: IFFALSE 54337
// begin if GetClass ( j ) <> 4 then
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 257
54123: PUSH
54124: LD_INT 4
54126: NONEQUAL
54127: IFFALSE 54180
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54129: LD_ADDR_EXP 146
54133: PUSH
54134: LD_EXP 146
54138: PPUSH
54139: LD_VAR 0 2
54143: PPUSH
54144: LD_EXP 146
54148: PUSH
54149: LD_VAR 0 2
54153: ARRAY
54154: PUSH
54155: LD_VAR 0 3
54159: DIFF
54160: PPUSH
54161: CALL_OW 1
54165: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54166: LD_VAR 0 3
54170: PPUSH
54171: LD_INT 0
54173: PPUSH
54174: CALL_OW 109
// continue ;
54178: GO 54002
// end ; if IsInUnit ( j ) then
54180: LD_VAR 0 3
54184: PPUSH
54185: CALL_OW 310
54189: IFFALSE 54200
// ComExitBuilding ( j ) ;
54191: LD_VAR 0 3
54195: PPUSH
54196: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54200: LD_ADDR_VAR 0 6
54204: PUSH
54205: LD_VAR 0 7
54209: PPUSH
54210: LD_VAR 0 3
54214: PPUSH
54215: CALL_OW 74
54219: ST_TO_ADDR
// if not ape then
54220: LD_VAR 0 6
54224: NOT
54225: IFFALSE 54229
// break ;
54227: GO 54339
// x := GetX ( ape ) ;
54229: LD_ADDR_VAR 0 4
54233: PUSH
54234: LD_VAR 0 6
54238: PPUSH
54239: CALL_OW 250
54243: ST_TO_ADDR
// y := GetY ( ape ) ;
54244: LD_ADDR_VAR 0 5
54248: PUSH
54249: LD_VAR 0 6
54253: PPUSH
54254: CALL_OW 251
54258: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54259: LD_VAR 0 4
54263: PPUSH
54264: LD_VAR 0 5
54268: PPUSH
54269: CALL_OW 488
54273: NOT
54274: PUSH
54275: LD_VAR 0 11
54279: PPUSH
54280: LD_VAR 0 4
54284: PPUSH
54285: LD_VAR 0 5
54289: PPUSH
54290: LD_INT 20
54292: PPUSH
54293: CALL 71249 0 4
54297: PUSH
54298: LD_INT 4
54300: ARRAY
54301: OR
54302: IFFALSE 54306
// break ;
54304: GO 54339
// if not HasTask ( j ) then
54306: LD_VAR 0 3
54310: PPUSH
54311: CALL_OW 314
54315: NOT
54316: IFFALSE 54337
// ComTameXY ( j , x , y ) ;
54318: LD_VAR 0 3
54322: PPUSH
54323: LD_VAR 0 4
54327: PPUSH
54328: LD_VAR 0 5
54332: PPUSH
54333: CALL_OW 131
// end ; end ;
54337: GO 54002
54339: POP
54340: POP
// end ;
54341: GO 53558
54343: POP
54344: POP
// end ;
54345: LD_VAR 0 1
54349: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54350: LD_INT 0
54352: PPUSH
54353: PPUSH
54354: PPUSH
54355: PPUSH
54356: PPUSH
54357: PPUSH
54358: PPUSH
54359: PPUSH
// if not mc_bases then
54360: LD_EXP 115
54364: NOT
54365: IFFALSE 54369
// exit ;
54367: GO 54995
// for i = 1 to mc_bases do
54369: LD_ADDR_VAR 0 2
54373: PUSH
54374: DOUBLE
54375: LD_INT 1
54377: DEC
54378: ST_TO_ADDR
54379: LD_EXP 115
54383: PUSH
54384: FOR_TO
54385: IFFALSE 54993
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54387: LD_EXP 144
54391: PUSH
54392: LD_VAR 0 2
54396: ARRAY
54397: NOT
54398: PUSH
54399: LD_EXP 144
54403: PUSH
54404: LD_VAR 0 2
54408: ARRAY
54409: PPUSH
54410: LD_INT 25
54412: PUSH
54413: LD_INT 12
54415: PUSH
54416: EMPTY
54417: LIST
54418: LIST
54419: PPUSH
54420: CALL_OW 72
54424: NOT
54425: OR
54426: IFFALSE 54430
// continue ;
54428: GO 54384
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54430: LD_ADDR_VAR 0 5
54434: PUSH
54435: LD_EXP 144
54439: PUSH
54440: LD_VAR 0 2
54444: ARRAY
54445: PUSH
54446: LD_INT 1
54448: ARRAY
54449: PPUSH
54450: CALL_OW 255
54454: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54455: LD_VAR 0 5
54459: PPUSH
54460: LD_INT 2
54462: PPUSH
54463: CALL_OW 325
54467: IFFALSE 54720
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54469: LD_ADDR_VAR 0 4
54473: PUSH
54474: LD_EXP 144
54478: PUSH
54479: LD_VAR 0 2
54483: ARRAY
54484: PPUSH
54485: LD_INT 25
54487: PUSH
54488: LD_INT 16
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: PPUSH
54495: CALL_OW 72
54499: ST_TO_ADDR
// if tmp < 6 then
54500: LD_VAR 0 4
54504: PUSH
54505: LD_INT 6
54507: LESS
54508: IFFALSE 54720
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54510: LD_ADDR_VAR 0 6
54514: PUSH
54515: LD_EXP 115
54519: PUSH
54520: LD_VAR 0 2
54524: ARRAY
54525: PPUSH
54526: LD_INT 2
54528: PUSH
54529: LD_INT 30
54531: PUSH
54532: LD_INT 0
54534: PUSH
54535: EMPTY
54536: LIST
54537: LIST
54538: PUSH
54539: LD_INT 30
54541: PUSH
54542: LD_INT 1
54544: PUSH
54545: EMPTY
54546: LIST
54547: LIST
54548: PUSH
54549: EMPTY
54550: LIST
54551: LIST
54552: LIST
54553: PPUSH
54554: CALL_OW 72
54558: ST_TO_ADDR
// if depot then
54559: LD_VAR 0 6
54563: IFFALSE 54720
// begin selected := 0 ;
54565: LD_ADDR_VAR 0 7
54569: PUSH
54570: LD_INT 0
54572: ST_TO_ADDR
// for j in depot do
54573: LD_ADDR_VAR 0 3
54577: PUSH
54578: LD_VAR 0 6
54582: PUSH
54583: FOR_IN
54584: IFFALSE 54615
// begin if UnitsInside ( j ) < 6 then
54586: LD_VAR 0 3
54590: PPUSH
54591: CALL_OW 313
54595: PUSH
54596: LD_INT 6
54598: LESS
54599: IFFALSE 54613
// begin selected := j ;
54601: LD_ADDR_VAR 0 7
54605: PUSH
54606: LD_VAR 0 3
54610: ST_TO_ADDR
// break ;
54611: GO 54615
// end ; end ;
54613: GO 54583
54615: POP
54616: POP
// if selected then
54617: LD_VAR 0 7
54621: IFFALSE 54720
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54623: LD_ADDR_VAR 0 3
54627: PUSH
54628: LD_EXP 144
54632: PUSH
54633: LD_VAR 0 2
54637: ARRAY
54638: PPUSH
54639: LD_INT 25
54641: PUSH
54642: LD_INT 12
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: PPUSH
54649: CALL_OW 72
54653: PUSH
54654: FOR_IN
54655: IFFALSE 54718
// if not HasTask ( j ) then
54657: LD_VAR 0 3
54661: PPUSH
54662: CALL_OW 314
54666: NOT
54667: IFFALSE 54716
// begin if not IsInUnit ( j ) then
54669: LD_VAR 0 3
54673: PPUSH
54674: CALL_OW 310
54678: NOT
54679: IFFALSE 54695
// ComEnterUnit ( j , selected ) ;
54681: LD_VAR 0 3
54685: PPUSH
54686: LD_VAR 0 7
54690: PPUSH
54691: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54695: LD_VAR 0 3
54699: PPUSH
54700: LD_INT 16
54702: PPUSH
54703: CALL_OW 183
// AddComExitBuilding ( j ) ;
54707: LD_VAR 0 3
54711: PPUSH
54712: CALL_OW 182
// end ;
54716: GO 54654
54718: POP
54719: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54720: LD_VAR 0 5
54724: PPUSH
54725: LD_INT 11
54727: PPUSH
54728: CALL_OW 325
54732: IFFALSE 54991
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54734: LD_ADDR_VAR 0 4
54738: PUSH
54739: LD_EXP 144
54743: PUSH
54744: LD_VAR 0 2
54748: ARRAY
54749: PPUSH
54750: LD_INT 25
54752: PUSH
54753: LD_INT 16
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: PPUSH
54760: CALL_OW 72
54764: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54765: LD_VAR 0 4
54769: PUSH
54770: LD_INT 6
54772: GREATEREQUAL
54773: PUSH
54774: LD_VAR 0 5
54778: PPUSH
54779: LD_INT 2
54781: PPUSH
54782: CALL_OW 325
54786: NOT
54787: OR
54788: IFFALSE 54991
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54790: LD_ADDR_VAR 0 8
54794: PUSH
54795: LD_EXP 115
54799: PUSH
54800: LD_VAR 0 2
54804: ARRAY
54805: PPUSH
54806: LD_INT 2
54808: PUSH
54809: LD_INT 30
54811: PUSH
54812: LD_INT 4
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: PUSH
54819: LD_INT 30
54821: PUSH
54822: LD_INT 5
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PUSH
54829: EMPTY
54830: LIST
54831: LIST
54832: LIST
54833: PPUSH
54834: CALL_OW 72
54838: ST_TO_ADDR
// if barracks then
54839: LD_VAR 0 8
54843: IFFALSE 54991
// begin selected := 0 ;
54845: LD_ADDR_VAR 0 7
54849: PUSH
54850: LD_INT 0
54852: ST_TO_ADDR
// for j in barracks do
54853: LD_ADDR_VAR 0 3
54857: PUSH
54858: LD_VAR 0 8
54862: PUSH
54863: FOR_IN
54864: IFFALSE 54895
// begin if UnitsInside ( j ) < 6 then
54866: LD_VAR 0 3
54870: PPUSH
54871: CALL_OW 313
54875: PUSH
54876: LD_INT 6
54878: LESS
54879: IFFALSE 54893
// begin selected := j ;
54881: LD_ADDR_VAR 0 7
54885: PUSH
54886: LD_VAR 0 3
54890: ST_TO_ADDR
// break ;
54891: GO 54895
// end ; end ;
54893: GO 54863
54895: POP
54896: POP
// if selected then
54897: LD_VAR 0 7
54901: IFFALSE 54991
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54903: LD_ADDR_VAR 0 3
54907: PUSH
54908: LD_EXP 144
54912: PUSH
54913: LD_VAR 0 2
54917: ARRAY
54918: PPUSH
54919: LD_INT 25
54921: PUSH
54922: LD_INT 12
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: PPUSH
54929: CALL_OW 72
54933: PUSH
54934: FOR_IN
54935: IFFALSE 54989
// if not IsInUnit ( j ) and not HasTask ( j ) then
54937: LD_VAR 0 3
54941: PPUSH
54942: CALL_OW 310
54946: NOT
54947: PUSH
54948: LD_VAR 0 3
54952: PPUSH
54953: CALL_OW 314
54957: NOT
54958: AND
54959: IFFALSE 54987
// begin ComEnterUnit ( j , selected ) ;
54961: LD_VAR 0 3
54965: PPUSH
54966: LD_VAR 0 7
54970: PPUSH
54971: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54975: LD_VAR 0 3
54979: PPUSH
54980: LD_INT 15
54982: PPUSH
54983: CALL_OW 183
// end ;
54987: GO 54934
54989: POP
54990: POP
// end ; end ; end ; end ; end ;
54991: GO 54384
54993: POP
54994: POP
// end ;
54995: LD_VAR 0 1
54999: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55000: LD_INT 0
55002: PPUSH
55003: PPUSH
55004: PPUSH
55005: PPUSH
// if not mc_bases then
55006: LD_EXP 115
55010: NOT
55011: IFFALSE 55015
// exit ;
55013: GO 55193
// for i = 1 to mc_bases do
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: DOUBLE
55021: LD_INT 1
55023: DEC
55024: ST_TO_ADDR
55025: LD_EXP 115
55029: PUSH
55030: FOR_TO
55031: IFFALSE 55191
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55033: LD_ADDR_VAR 0 4
55037: PUSH
55038: LD_EXP 115
55042: PUSH
55043: LD_VAR 0 2
55047: ARRAY
55048: PPUSH
55049: LD_INT 25
55051: PUSH
55052: LD_INT 9
55054: PUSH
55055: EMPTY
55056: LIST
55057: LIST
55058: PPUSH
55059: CALL_OW 72
55063: ST_TO_ADDR
// if not tmp then
55064: LD_VAR 0 4
55068: NOT
55069: IFFALSE 55073
// continue ;
55071: GO 55030
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55073: LD_EXP 141
55077: PUSH
55078: LD_VAR 0 2
55082: ARRAY
55083: PPUSH
55084: LD_INT 29
55086: PPUSH
55087: CALL_OW 325
55091: NOT
55092: PUSH
55093: LD_EXP 141
55097: PUSH
55098: LD_VAR 0 2
55102: ARRAY
55103: PPUSH
55104: LD_INT 28
55106: PPUSH
55107: CALL_OW 325
55111: NOT
55112: AND
55113: IFFALSE 55117
// continue ;
55115: GO 55030
// for j in tmp do
55117: LD_ADDR_VAR 0 3
55121: PUSH
55122: LD_VAR 0 4
55126: PUSH
55127: FOR_IN
55128: IFFALSE 55187
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55130: LD_VAR 0 3
55134: PUSH
55135: LD_EXP 118
55139: PUSH
55140: LD_VAR 0 2
55144: ARRAY
55145: PUSH
55146: LD_INT 1
55148: ARRAY
55149: IN
55150: NOT
55151: PUSH
55152: LD_VAR 0 3
55156: PUSH
55157: LD_EXP 118
55161: PUSH
55162: LD_VAR 0 2
55166: ARRAY
55167: PUSH
55168: LD_INT 2
55170: ARRAY
55171: IN
55172: NOT
55173: AND
55174: IFFALSE 55185
// ComSpaceTimeShoot ( j ) ;
55176: LD_VAR 0 3
55180: PPUSH
55181: CALL 66350 0 1
55185: GO 55127
55187: POP
55188: POP
// end ;
55189: GO 55030
55191: POP
55192: POP
// end ;
55193: LD_VAR 0 1
55197: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55198: LD_INT 0
55200: PPUSH
55201: PPUSH
55202: PPUSH
55203: PPUSH
55204: PPUSH
55205: PPUSH
55206: PPUSH
55207: PPUSH
55208: PPUSH
// if not mc_bases then
55209: LD_EXP 115
55213: NOT
55214: IFFALSE 55218
// exit ;
55216: GO 55840
// for i = 1 to mc_bases do
55218: LD_ADDR_VAR 0 2
55222: PUSH
55223: DOUBLE
55224: LD_INT 1
55226: DEC
55227: ST_TO_ADDR
55228: LD_EXP 115
55232: PUSH
55233: FOR_TO
55234: IFFALSE 55838
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55236: LD_EXP 150
55240: PUSH
55241: LD_VAR 0 2
55245: ARRAY
55246: NOT
55247: PUSH
55248: LD_INT 38
55250: PPUSH
55251: LD_EXP 141
55255: PUSH
55256: LD_VAR 0 2
55260: ARRAY
55261: PPUSH
55262: CALL_OW 321
55266: PUSH
55267: LD_INT 2
55269: NONEQUAL
55270: OR
55271: IFFALSE 55275
// continue ;
55273: GO 55233
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55275: LD_ADDR_VAR 0 8
55279: PUSH
55280: LD_EXP 115
55284: PUSH
55285: LD_VAR 0 2
55289: ARRAY
55290: PPUSH
55291: LD_INT 30
55293: PUSH
55294: LD_INT 34
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: PPUSH
55301: CALL_OW 72
55305: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55306: LD_ADDR_VAR 0 9
55310: PUSH
55311: LD_EXP 115
55315: PUSH
55316: LD_VAR 0 2
55320: ARRAY
55321: PPUSH
55322: LD_INT 25
55324: PUSH
55325: LD_INT 4
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: CALL_OW 72
55336: PPUSH
55337: LD_INT 0
55339: PPUSH
55340: CALL 99247 0 2
55344: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55345: LD_VAR 0 9
55349: NOT
55350: PUSH
55351: LD_VAR 0 8
55355: NOT
55356: OR
55357: PUSH
55358: LD_EXP 115
55362: PUSH
55363: LD_VAR 0 2
55367: ARRAY
55368: PPUSH
55369: LD_INT 124
55371: PPUSH
55372: CALL 99247 0 2
55376: OR
55377: IFFALSE 55381
// continue ;
55379: GO 55233
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55381: LD_EXP 151
55385: PUSH
55386: LD_VAR 0 2
55390: ARRAY
55391: PUSH
55392: LD_EXP 150
55396: PUSH
55397: LD_VAR 0 2
55401: ARRAY
55402: LESS
55403: PUSH
55404: LD_EXP 151
55408: PUSH
55409: LD_VAR 0 2
55413: ARRAY
55414: PUSH
55415: LD_VAR 0 8
55419: LESS
55420: AND
55421: IFFALSE 55836
// begin tmp := sci [ 1 ] ;
55423: LD_ADDR_VAR 0 7
55427: PUSH
55428: LD_VAR 0 9
55432: PUSH
55433: LD_INT 1
55435: ARRAY
55436: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55437: LD_VAR 0 7
55441: PPUSH
55442: LD_INT 124
55444: PPUSH
55445: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55449: LD_ADDR_VAR 0 3
55453: PUSH
55454: DOUBLE
55455: LD_EXP 150
55459: PUSH
55460: LD_VAR 0 2
55464: ARRAY
55465: INC
55466: ST_TO_ADDR
55467: LD_EXP 150
55471: PUSH
55472: LD_VAR 0 2
55476: ARRAY
55477: PUSH
55478: FOR_DOWNTO
55479: IFFALSE 55822
// begin if IsInUnit ( tmp ) then
55481: LD_VAR 0 7
55485: PPUSH
55486: CALL_OW 310
55490: IFFALSE 55501
// ComExitBuilding ( tmp ) ;
55492: LD_VAR 0 7
55496: PPUSH
55497: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55501: LD_INT 35
55503: PPUSH
55504: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55508: LD_VAR 0 7
55512: PPUSH
55513: CALL_OW 310
55517: NOT
55518: PUSH
55519: LD_VAR 0 7
55523: PPUSH
55524: CALL_OW 314
55528: NOT
55529: AND
55530: IFFALSE 55501
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55532: LD_ADDR_VAR 0 6
55536: PUSH
55537: LD_VAR 0 7
55541: PPUSH
55542: CALL_OW 250
55546: PUSH
55547: LD_VAR 0 7
55551: PPUSH
55552: CALL_OW 251
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55561: LD_INT 35
55563: PPUSH
55564: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55568: LD_ADDR_VAR 0 4
55572: PUSH
55573: LD_EXP 150
55577: PUSH
55578: LD_VAR 0 2
55582: ARRAY
55583: PUSH
55584: LD_VAR 0 3
55588: ARRAY
55589: PUSH
55590: LD_INT 1
55592: ARRAY
55593: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55594: LD_ADDR_VAR 0 5
55598: PUSH
55599: LD_EXP 150
55603: PUSH
55604: LD_VAR 0 2
55608: ARRAY
55609: PUSH
55610: LD_VAR 0 3
55614: ARRAY
55615: PUSH
55616: LD_INT 2
55618: ARRAY
55619: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55620: LD_VAR 0 7
55624: PPUSH
55625: LD_INT 10
55627: PPUSH
55628: CALL 72946 0 2
55632: PUSH
55633: LD_INT 4
55635: ARRAY
55636: IFFALSE 55674
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55638: LD_VAR 0 7
55642: PPUSH
55643: LD_VAR 0 6
55647: PUSH
55648: LD_INT 1
55650: ARRAY
55651: PPUSH
55652: LD_VAR 0 6
55656: PUSH
55657: LD_INT 2
55659: ARRAY
55660: PPUSH
55661: CALL_OW 111
// wait ( 0 0$10 ) ;
55665: LD_INT 350
55667: PPUSH
55668: CALL_OW 67
// end else
55672: GO 55700
// begin ComMoveXY ( tmp , x , y ) ;
55674: LD_VAR 0 7
55678: PPUSH
55679: LD_VAR 0 4
55683: PPUSH
55684: LD_VAR 0 5
55688: PPUSH
55689: CALL_OW 111
// wait ( 0 0$3 ) ;
55693: LD_INT 105
55695: PPUSH
55696: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55700: LD_VAR 0 7
55704: PPUSH
55705: LD_VAR 0 4
55709: PPUSH
55710: LD_VAR 0 5
55714: PPUSH
55715: CALL_OW 307
55719: IFFALSE 55561
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55721: LD_VAR 0 7
55725: PPUSH
55726: LD_VAR 0 4
55730: PPUSH
55731: LD_VAR 0 5
55735: PPUSH
55736: LD_VAR 0 8
55740: PUSH
55741: LD_VAR 0 3
55745: ARRAY
55746: PPUSH
55747: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55751: LD_INT 35
55753: PPUSH
55754: CALL_OW 67
// until not HasTask ( tmp ) ;
55758: LD_VAR 0 7
55762: PPUSH
55763: CALL_OW 314
55767: NOT
55768: IFFALSE 55751
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55770: LD_ADDR_EXP 151
55774: PUSH
55775: LD_EXP 151
55779: PPUSH
55780: LD_VAR 0 2
55784: PUSH
55785: LD_EXP 151
55789: PUSH
55790: LD_VAR 0 2
55794: ARRAY
55795: PUSH
55796: LD_INT 1
55798: PLUS
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PPUSH
55804: LD_VAR 0 8
55808: PUSH
55809: LD_VAR 0 3
55813: ARRAY
55814: PPUSH
55815: CALL 70353 0 3
55819: ST_TO_ADDR
// end ;
55820: GO 55478
55822: POP
55823: POP
// MC_Reset ( i , 124 ) ;
55824: LD_VAR 0 2
55828: PPUSH
55829: LD_INT 124
55831: PPUSH
55832: CALL 39279 0 2
// end ; end ;
55836: GO 55233
55838: POP
55839: POP
// end ;
55840: LD_VAR 0 1
55844: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55845: LD_INT 0
55847: PPUSH
55848: PPUSH
55849: PPUSH
// if not mc_bases then
55850: LD_EXP 115
55854: NOT
55855: IFFALSE 55859
// exit ;
55857: GO 56465
// for i = 1 to mc_bases do
55859: LD_ADDR_VAR 0 2
55863: PUSH
55864: DOUBLE
55865: LD_INT 1
55867: DEC
55868: ST_TO_ADDR
55869: LD_EXP 115
55873: PUSH
55874: FOR_TO
55875: IFFALSE 56463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55877: LD_ADDR_VAR 0 3
55881: PUSH
55882: LD_EXP 115
55886: PUSH
55887: LD_VAR 0 2
55891: ARRAY
55892: PPUSH
55893: LD_INT 25
55895: PUSH
55896: LD_INT 4
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: PPUSH
55903: CALL_OW 72
55907: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55908: LD_VAR 0 3
55912: NOT
55913: PUSH
55914: LD_EXP 152
55918: PUSH
55919: LD_VAR 0 2
55923: ARRAY
55924: NOT
55925: OR
55926: PUSH
55927: LD_EXP 115
55931: PUSH
55932: LD_VAR 0 2
55936: ARRAY
55937: PPUSH
55938: LD_INT 2
55940: PUSH
55941: LD_INT 30
55943: PUSH
55944: LD_INT 0
55946: PUSH
55947: EMPTY
55948: LIST
55949: LIST
55950: PUSH
55951: LD_INT 30
55953: PUSH
55954: LD_INT 1
55956: PUSH
55957: EMPTY
55958: LIST
55959: LIST
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: LIST
55965: PPUSH
55966: CALL_OW 72
55970: NOT
55971: OR
55972: IFFALSE 56022
// begin if mc_deposits_finder [ i ] then
55974: LD_EXP 153
55978: PUSH
55979: LD_VAR 0 2
55983: ARRAY
55984: IFFALSE 56020
// begin MC_Reset ( i , 125 ) ;
55986: LD_VAR 0 2
55990: PPUSH
55991: LD_INT 125
55993: PPUSH
55994: CALL 39279 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55998: LD_ADDR_EXP 153
56002: PUSH
56003: LD_EXP 153
56007: PPUSH
56008: LD_VAR 0 2
56012: PPUSH
56013: EMPTY
56014: PPUSH
56015: CALL_OW 1
56019: ST_TO_ADDR
// end ; continue ;
56020: GO 55874
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56022: LD_EXP 152
56026: PUSH
56027: LD_VAR 0 2
56031: ARRAY
56032: PUSH
56033: LD_INT 1
56035: ARRAY
56036: PUSH
56037: LD_INT 3
56039: ARRAY
56040: PUSH
56041: LD_INT 1
56043: EQUAL
56044: PUSH
56045: LD_INT 20
56047: PPUSH
56048: LD_EXP 141
56052: PUSH
56053: LD_VAR 0 2
56057: ARRAY
56058: PPUSH
56059: CALL_OW 321
56063: PUSH
56064: LD_INT 2
56066: NONEQUAL
56067: AND
56068: IFFALSE 56118
// begin if mc_deposits_finder [ i ] then
56070: LD_EXP 153
56074: PUSH
56075: LD_VAR 0 2
56079: ARRAY
56080: IFFALSE 56116
// begin MC_Reset ( i , 125 ) ;
56082: LD_VAR 0 2
56086: PPUSH
56087: LD_INT 125
56089: PPUSH
56090: CALL 39279 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56094: LD_ADDR_EXP 153
56098: PUSH
56099: LD_EXP 153
56103: PPUSH
56104: LD_VAR 0 2
56108: PPUSH
56109: EMPTY
56110: PPUSH
56111: CALL_OW 1
56115: ST_TO_ADDR
// end ; continue ;
56116: GO 55874
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56118: LD_EXP 152
56122: PUSH
56123: LD_VAR 0 2
56127: ARRAY
56128: PUSH
56129: LD_INT 1
56131: ARRAY
56132: PUSH
56133: LD_INT 1
56135: ARRAY
56136: PPUSH
56137: LD_EXP 152
56141: PUSH
56142: LD_VAR 0 2
56146: ARRAY
56147: PUSH
56148: LD_INT 1
56150: ARRAY
56151: PUSH
56152: LD_INT 2
56154: ARRAY
56155: PPUSH
56156: LD_EXP 141
56160: PUSH
56161: LD_VAR 0 2
56165: ARRAY
56166: PPUSH
56167: CALL_OW 440
56171: IFFALSE 56214
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56173: LD_ADDR_EXP 152
56177: PUSH
56178: LD_EXP 152
56182: PPUSH
56183: LD_VAR 0 2
56187: PPUSH
56188: LD_EXP 152
56192: PUSH
56193: LD_VAR 0 2
56197: ARRAY
56198: PPUSH
56199: LD_INT 1
56201: PPUSH
56202: CALL_OW 3
56206: PPUSH
56207: CALL_OW 1
56211: ST_TO_ADDR
56212: GO 56461
// begin if not mc_deposits_finder [ i ] then
56214: LD_EXP 153
56218: PUSH
56219: LD_VAR 0 2
56223: ARRAY
56224: NOT
56225: IFFALSE 56277
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56227: LD_ADDR_EXP 153
56231: PUSH
56232: LD_EXP 153
56236: PPUSH
56237: LD_VAR 0 2
56241: PPUSH
56242: LD_VAR 0 3
56246: PUSH
56247: LD_INT 1
56249: ARRAY
56250: PUSH
56251: EMPTY
56252: LIST
56253: PPUSH
56254: CALL_OW 1
56258: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56259: LD_VAR 0 3
56263: PUSH
56264: LD_INT 1
56266: ARRAY
56267: PPUSH
56268: LD_INT 125
56270: PPUSH
56271: CALL_OW 109
// end else
56275: GO 56461
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56277: LD_EXP 153
56281: PUSH
56282: LD_VAR 0 2
56286: ARRAY
56287: PUSH
56288: LD_INT 1
56290: ARRAY
56291: PPUSH
56292: CALL_OW 310
56296: IFFALSE 56319
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56298: LD_EXP 153
56302: PUSH
56303: LD_VAR 0 2
56307: ARRAY
56308: PUSH
56309: LD_INT 1
56311: ARRAY
56312: PPUSH
56313: CALL_OW 122
56317: GO 56461
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56319: LD_EXP 153
56323: PUSH
56324: LD_VAR 0 2
56328: ARRAY
56329: PUSH
56330: LD_INT 1
56332: ARRAY
56333: PPUSH
56334: CALL_OW 314
56338: NOT
56339: PUSH
56340: LD_EXP 153
56344: PUSH
56345: LD_VAR 0 2
56349: ARRAY
56350: PUSH
56351: LD_INT 1
56353: ARRAY
56354: PPUSH
56355: LD_EXP 152
56359: PUSH
56360: LD_VAR 0 2
56364: ARRAY
56365: PUSH
56366: LD_INT 1
56368: ARRAY
56369: PUSH
56370: LD_INT 1
56372: ARRAY
56373: PPUSH
56374: LD_EXP 152
56378: PUSH
56379: LD_VAR 0 2
56383: ARRAY
56384: PUSH
56385: LD_INT 1
56387: ARRAY
56388: PUSH
56389: LD_INT 2
56391: ARRAY
56392: PPUSH
56393: CALL_OW 297
56397: PUSH
56398: LD_INT 6
56400: GREATER
56401: AND
56402: IFFALSE 56461
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56404: LD_EXP 153
56408: PUSH
56409: LD_VAR 0 2
56413: ARRAY
56414: PUSH
56415: LD_INT 1
56417: ARRAY
56418: PPUSH
56419: LD_EXP 152
56423: PUSH
56424: LD_VAR 0 2
56428: ARRAY
56429: PUSH
56430: LD_INT 1
56432: ARRAY
56433: PUSH
56434: LD_INT 1
56436: ARRAY
56437: PPUSH
56438: LD_EXP 152
56442: PUSH
56443: LD_VAR 0 2
56447: ARRAY
56448: PUSH
56449: LD_INT 1
56451: ARRAY
56452: PUSH
56453: LD_INT 2
56455: ARRAY
56456: PPUSH
56457: CALL_OW 111
// end ; end ; end ;
56461: GO 55874
56463: POP
56464: POP
// end ;
56465: LD_VAR 0 1
56469: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56470: LD_INT 0
56472: PPUSH
56473: PPUSH
56474: PPUSH
56475: PPUSH
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
56480: PPUSH
56481: PPUSH
56482: PPUSH
// if not mc_bases then
56483: LD_EXP 115
56487: NOT
56488: IFFALSE 56492
// exit ;
56490: GO 57432
// for i = 1 to mc_bases do
56492: LD_ADDR_VAR 0 2
56496: PUSH
56497: DOUBLE
56498: LD_INT 1
56500: DEC
56501: ST_TO_ADDR
56502: LD_EXP 115
56506: PUSH
56507: FOR_TO
56508: IFFALSE 57430
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56510: LD_EXP 115
56514: PUSH
56515: LD_VAR 0 2
56519: ARRAY
56520: NOT
56521: PUSH
56522: LD_EXP 138
56526: PUSH
56527: LD_VAR 0 2
56531: ARRAY
56532: OR
56533: IFFALSE 56537
// continue ;
56535: GO 56507
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56537: LD_ADDR_VAR 0 7
56541: PUSH
56542: LD_EXP 115
56546: PUSH
56547: LD_VAR 0 2
56551: ARRAY
56552: PUSH
56553: LD_INT 1
56555: ARRAY
56556: PPUSH
56557: CALL_OW 248
56561: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56562: LD_VAR 0 7
56566: PUSH
56567: LD_INT 3
56569: EQUAL
56570: PUSH
56571: LD_EXP 134
56575: PUSH
56576: LD_VAR 0 2
56580: ARRAY
56581: PUSH
56582: LD_EXP 137
56586: PUSH
56587: LD_VAR 0 2
56591: ARRAY
56592: UNION
56593: PPUSH
56594: LD_INT 33
56596: PUSH
56597: LD_INT 2
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: PPUSH
56604: CALL_OW 72
56608: NOT
56609: OR
56610: IFFALSE 56614
// continue ;
56612: GO 56507
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56614: LD_ADDR_VAR 0 9
56618: PUSH
56619: LD_EXP 115
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PPUSH
56630: LD_INT 30
56632: PUSH
56633: LD_INT 36
56635: PUSH
56636: EMPTY
56637: LIST
56638: LIST
56639: PPUSH
56640: CALL_OW 72
56644: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56645: LD_ADDR_VAR 0 10
56649: PUSH
56650: LD_EXP 134
56654: PUSH
56655: LD_VAR 0 2
56659: ARRAY
56660: PPUSH
56661: LD_INT 34
56663: PUSH
56664: LD_INT 31
56666: PUSH
56667: EMPTY
56668: LIST
56669: LIST
56670: PPUSH
56671: CALL_OW 72
56675: ST_TO_ADDR
// if not cts and not mcts then
56676: LD_VAR 0 9
56680: NOT
56681: PUSH
56682: LD_VAR 0 10
56686: NOT
56687: AND
56688: IFFALSE 56692
// continue ;
56690: GO 56507
// x := cts ;
56692: LD_ADDR_VAR 0 11
56696: PUSH
56697: LD_VAR 0 9
56701: ST_TO_ADDR
// if not x then
56702: LD_VAR 0 11
56706: NOT
56707: IFFALSE 56719
// x := mcts ;
56709: LD_ADDR_VAR 0 11
56713: PUSH
56714: LD_VAR 0 10
56718: ST_TO_ADDR
// if not x then
56719: LD_VAR 0 11
56723: NOT
56724: IFFALSE 56728
// continue ;
56726: GO 56507
// if mc_remote_driver [ i ] then
56728: LD_EXP 155
56732: PUSH
56733: LD_VAR 0 2
56737: ARRAY
56738: IFFALSE 57125
// for j in mc_remote_driver [ i ] do
56740: LD_ADDR_VAR 0 3
56744: PUSH
56745: LD_EXP 155
56749: PUSH
56750: LD_VAR 0 2
56754: ARRAY
56755: PUSH
56756: FOR_IN
56757: IFFALSE 57123
// begin if GetClass ( j ) <> 3 then
56759: LD_VAR 0 3
56763: PPUSH
56764: CALL_OW 257
56768: PUSH
56769: LD_INT 3
56771: NONEQUAL
56772: IFFALSE 56825
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56774: LD_ADDR_EXP 155
56778: PUSH
56779: LD_EXP 155
56783: PPUSH
56784: LD_VAR 0 2
56788: PPUSH
56789: LD_EXP 155
56793: PUSH
56794: LD_VAR 0 2
56798: ARRAY
56799: PUSH
56800: LD_VAR 0 3
56804: DIFF
56805: PPUSH
56806: CALL_OW 1
56810: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56811: LD_VAR 0 3
56815: PPUSH
56816: LD_INT 0
56818: PPUSH
56819: CALL_OW 109
// continue ;
56823: GO 56756
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56825: LD_EXP 134
56829: PUSH
56830: LD_VAR 0 2
56834: ARRAY
56835: PPUSH
56836: LD_INT 34
56838: PUSH
56839: LD_INT 31
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: PUSH
56846: LD_INT 58
56848: PUSH
56849: EMPTY
56850: LIST
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PPUSH
56856: CALL_OW 72
56860: PUSH
56861: LD_VAR 0 3
56865: PPUSH
56866: CALL 99335 0 1
56870: NOT
56871: AND
56872: IFFALSE 56943
// begin if IsInUnit ( j ) then
56874: LD_VAR 0 3
56878: PPUSH
56879: CALL_OW 310
56883: IFFALSE 56894
// ComExitBuilding ( j ) ;
56885: LD_VAR 0 3
56889: PPUSH
56890: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56894: LD_VAR 0 3
56898: PPUSH
56899: LD_EXP 134
56903: PUSH
56904: LD_VAR 0 2
56908: ARRAY
56909: PPUSH
56910: LD_INT 34
56912: PUSH
56913: LD_INT 31
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: PUSH
56920: LD_INT 58
56922: PUSH
56923: EMPTY
56924: LIST
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: PPUSH
56930: CALL_OW 72
56934: PUSH
56935: LD_INT 1
56937: ARRAY
56938: PPUSH
56939: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56943: LD_VAR 0 3
56947: PPUSH
56948: CALL_OW 310
56952: NOT
56953: PUSH
56954: LD_VAR 0 3
56958: PPUSH
56959: CALL_OW 310
56963: PPUSH
56964: CALL_OW 266
56968: PUSH
56969: LD_INT 36
56971: NONEQUAL
56972: PUSH
56973: LD_VAR 0 3
56977: PPUSH
56978: CALL 99335 0 1
56982: NOT
56983: AND
56984: OR
56985: IFFALSE 57121
// begin if IsInUnit ( j ) then
56987: LD_VAR 0 3
56991: PPUSH
56992: CALL_OW 310
56996: IFFALSE 57007
// ComExitBuilding ( j ) ;
56998: LD_VAR 0 3
57002: PPUSH
57003: CALL_OW 122
// ct := 0 ;
57007: LD_ADDR_VAR 0 8
57011: PUSH
57012: LD_INT 0
57014: ST_TO_ADDR
// for k in x do
57015: LD_ADDR_VAR 0 4
57019: PUSH
57020: LD_VAR 0 11
57024: PUSH
57025: FOR_IN
57026: IFFALSE 57099
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57028: LD_VAR 0 4
57032: PPUSH
57033: CALL_OW 264
57037: PUSH
57038: LD_INT 31
57040: EQUAL
57041: PUSH
57042: LD_VAR 0 4
57046: PPUSH
57047: CALL_OW 311
57051: NOT
57052: AND
57053: PUSH
57054: LD_VAR 0 4
57058: PPUSH
57059: CALL_OW 266
57063: PUSH
57064: LD_INT 36
57066: EQUAL
57067: PUSH
57068: LD_VAR 0 4
57072: PPUSH
57073: CALL_OW 313
57077: PUSH
57078: LD_INT 3
57080: LESS
57081: AND
57082: OR
57083: IFFALSE 57097
// begin ct := k ;
57085: LD_ADDR_VAR 0 8
57089: PUSH
57090: LD_VAR 0 4
57094: ST_TO_ADDR
// break ;
57095: GO 57099
// end ;
57097: GO 57025
57099: POP
57100: POP
// if ct then
57101: LD_VAR 0 8
57105: IFFALSE 57121
// ComEnterUnit ( j , ct ) ;
57107: LD_VAR 0 3
57111: PPUSH
57112: LD_VAR 0 8
57116: PPUSH
57117: CALL_OW 120
// end ; end ;
57121: GO 56756
57123: POP
57124: POP
// places := 0 ;
57125: LD_ADDR_VAR 0 5
57129: PUSH
57130: LD_INT 0
57132: ST_TO_ADDR
// for j = 1 to x do
57133: LD_ADDR_VAR 0 3
57137: PUSH
57138: DOUBLE
57139: LD_INT 1
57141: DEC
57142: ST_TO_ADDR
57143: LD_VAR 0 11
57147: PUSH
57148: FOR_TO
57149: IFFALSE 57225
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57151: LD_VAR 0 11
57155: PUSH
57156: LD_VAR 0 3
57160: ARRAY
57161: PPUSH
57162: CALL_OW 264
57166: PUSH
57167: LD_INT 31
57169: EQUAL
57170: IFFALSE 57188
// places := places + 1 else
57172: LD_ADDR_VAR 0 5
57176: PUSH
57177: LD_VAR 0 5
57181: PUSH
57182: LD_INT 1
57184: PLUS
57185: ST_TO_ADDR
57186: GO 57223
// if GetBType ( x [ j ] ) = b_control_tower then
57188: LD_VAR 0 11
57192: PUSH
57193: LD_VAR 0 3
57197: ARRAY
57198: PPUSH
57199: CALL_OW 266
57203: PUSH
57204: LD_INT 36
57206: EQUAL
57207: IFFALSE 57223
// places := places + 3 ;
57209: LD_ADDR_VAR 0 5
57213: PUSH
57214: LD_VAR 0 5
57218: PUSH
57219: LD_INT 3
57221: PLUS
57222: ST_TO_ADDR
57223: GO 57148
57225: POP
57226: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57227: LD_VAR 0 5
57231: PUSH
57232: LD_INT 0
57234: EQUAL
57235: PUSH
57236: LD_VAR 0 5
57240: PUSH
57241: LD_EXP 155
57245: PUSH
57246: LD_VAR 0 2
57250: ARRAY
57251: LESSEQUAL
57252: OR
57253: IFFALSE 57257
// continue ;
57255: GO 56507
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57257: LD_ADDR_VAR 0 6
57261: PUSH
57262: LD_EXP 115
57266: PUSH
57267: LD_VAR 0 2
57271: ARRAY
57272: PPUSH
57273: LD_INT 25
57275: PUSH
57276: LD_INT 3
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PPUSH
57283: CALL_OW 72
57287: PUSH
57288: LD_EXP 155
57292: PUSH
57293: LD_VAR 0 2
57297: ARRAY
57298: DIFF
57299: PPUSH
57300: LD_INT 3
57302: PPUSH
57303: CALL 100235 0 2
57307: ST_TO_ADDR
// for j in tmp do
57308: LD_ADDR_VAR 0 3
57312: PUSH
57313: LD_VAR 0 6
57317: PUSH
57318: FOR_IN
57319: IFFALSE 57354
// if GetTag ( j ) > 0 then
57321: LD_VAR 0 3
57325: PPUSH
57326: CALL_OW 110
57330: PUSH
57331: LD_INT 0
57333: GREATER
57334: IFFALSE 57352
// tmp := tmp diff j ;
57336: LD_ADDR_VAR 0 6
57340: PUSH
57341: LD_VAR 0 6
57345: PUSH
57346: LD_VAR 0 3
57350: DIFF
57351: ST_TO_ADDR
57352: GO 57318
57354: POP
57355: POP
// if not tmp then
57356: LD_VAR 0 6
57360: NOT
57361: IFFALSE 57365
// continue ;
57363: GO 56507
// if places then
57365: LD_VAR 0 5
57369: IFFALSE 57428
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57371: LD_ADDR_EXP 155
57375: PUSH
57376: LD_EXP 155
57380: PPUSH
57381: LD_VAR 0 2
57385: PPUSH
57386: LD_EXP 155
57390: PUSH
57391: LD_VAR 0 2
57395: ARRAY
57396: PUSH
57397: LD_VAR 0 6
57401: PUSH
57402: LD_INT 1
57404: ARRAY
57405: UNION
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57412: LD_VAR 0 6
57416: PUSH
57417: LD_INT 1
57419: ARRAY
57420: PPUSH
57421: LD_INT 126
57423: PPUSH
57424: CALL_OW 109
// end ; end ;
57428: GO 56507
57430: POP
57431: POP
// end ;
57432: LD_VAR 0 1
57436: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57437: LD_INT 0
57439: PPUSH
57440: PPUSH
57441: PPUSH
57442: PPUSH
57443: PPUSH
57444: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57445: LD_VAR 0 1
57449: NOT
57450: PUSH
57451: LD_VAR 0 2
57455: NOT
57456: OR
57457: PUSH
57458: LD_VAR 0 3
57462: NOT
57463: OR
57464: PUSH
57465: LD_VAR 0 4
57469: PUSH
57470: LD_INT 1
57472: PUSH
57473: LD_INT 2
57475: PUSH
57476: LD_INT 3
57478: PUSH
57479: LD_INT 4
57481: PUSH
57482: LD_INT 5
57484: PUSH
57485: LD_INT 8
57487: PUSH
57488: LD_INT 9
57490: PUSH
57491: LD_INT 15
57493: PUSH
57494: LD_INT 16
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: LIST
57501: LIST
57502: LIST
57503: LIST
57504: LIST
57505: LIST
57506: LIST
57507: IN
57508: NOT
57509: OR
57510: IFFALSE 57514
// exit ;
57512: GO 58414
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57514: LD_ADDR_VAR 0 2
57518: PUSH
57519: LD_VAR 0 2
57523: PPUSH
57524: LD_INT 21
57526: PUSH
57527: LD_INT 3
57529: PUSH
57530: EMPTY
57531: LIST
57532: LIST
57533: PUSH
57534: LD_INT 24
57536: PUSH
57537: LD_INT 250
57539: PUSH
57540: EMPTY
57541: LIST
57542: LIST
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: PPUSH
57548: CALL_OW 72
57552: ST_TO_ADDR
// case class of 1 , 15 :
57553: LD_VAR 0 4
57557: PUSH
57558: LD_INT 1
57560: DOUBLE
57561: EQUAL
57562: IFTRUE 57572
57564: LD_INT 15
57566: DOUBLE
57567: EQUAL
57568: IFTRUE 57572
57570: GO 57657
57572: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57573: LD_ADDR_VAR 0 8
57577: PUSH
57578: LD_VAR 0 2
57582: PPUSH
57583: LD_INT 2
57585: PUSH
57586: LD_INT 30
57588: PUSH
57589: LD_INT 32
57591: PUSH
57592: EMPTY
57593: LIST
57594: LIST
57595: PUSH
57596: LD_INT 30
57598: PUSH
57599: LD_INT 31
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: LIST
57610: PPUSH
57611: CALL_OW 72
57615: PUSH
57616: LD_VAR 0 2
57620: PPUSH
57621: LD_INT 2
57623: PUSH
57624: LD_INT 30
57626: PUSH
57627: LD_INT 4
57629: PUSH
57630: EMPTY
57631: LIST
57632: LIST
57633: PUSH
57634: LD_INT 30
57636: PUSH
57637: LD_INT 5
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: PUSH
57644: EMPTY
57645: LIST
57646: LIST
57647: LIST
57648: PPUSH
57649: CALL_OW 72
57653: ADD
57654: ST_TO_ADDR
57655: GO 57903
57657: LD_INT 2
57659: DOUBLE
57660: EQUAL
57661: IFTRUE 57671
57663: LD_INT 16
57665: DOUBLE
57666: EQUAL
57667: IFTRUE 57671
57669: GO 57717
57671: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57672: LD_ADDR_VAR 0 8
57676: PUSH
57677: LD_VAR 0 2
57681: PPUSH
57682: LD_INT 2
57684: PUSH
57685: LD_INT 30
57687: PUSH
57688: LD_INT 0
57690: PUSH
57691: EMPTY
57692: LIST
57693: LIST
57694: PUSH
57695: LD_INT 30
57697: PUSH
57698: LD_INT 1
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: LIST
57709: PPUSH
57710: CALL_OW 72
57714: ST_TO_ADDR
57715: GO 57903
57717: LD_INT 3
57719: DOUBLE
57720: EQUAL
57721: IFTRUE 57725
57723: GO 57771
57725: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57726: LD_ADDR_VAR 0 8
57730: PUSH
57731: LD_VAR 0 2
57735: PPUSH
57736: LD_INT 2
57738: PUSH
57739: LD_INT 30
57741: PUSH
57742: LD_INT 2
57744: PUSH
57745: EMPTY
57746: LIST
57747: LIST
57748: PUSH
57749: LD_INT 30
57751: PUSH
57752: LD_INT 3
57754: PUSH
57755: EMPTY
57756: LIST
57757: LIST
57758: PUSH
57759: EMPTY
57760: LIST
57761: LIST
57762: LIST
57763: PPUSH
57764: CALL_OW 72
57768: ST_TO_ADDR
57769: GO 57903
57771: LD_INT 4
57773: DOUBLE
57774: EQUAL
57775: IFTRUE 57779
57777: GO 57836
57779: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57780: LD_ADDR_VAR 0 8
57784: PUSH
57785: LD_VAR 0 2
57789: PPUSH
57790: LD_INT 2
57792: PUSH
57793: LD_INT 30
57795: PUSH
57796: LD_INT 6
57798: PUSH
57799: EMPTY
57800: LIST
57801: LIST
57802: PUSH
57803: LD_INT 30
57805: PUSH
57806: LD_INT 7
57808: PUSH
57809: EMPTY
57810: LIST
57811: LIST
57812: PUSH
57813: LD_INT 30
57815: PUSH
57816: LD_INT 8
57818: PUSH
57819: EMPTY
57820: LIST
57821: LIST
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: LIST
57827: LIST
57828: PPUSH
57829: CALL_OW 72
57833: ST_TO_ADDR
57834: GO 57903
57836: LD_INT 5
57838: DOUBLE
57839: EQUAL
57840: IFTRUE 57856
57842: LD_INT 8
57844: DOUBLE
57845: EQUAL
57846: IFTRUE 57856
57848: LD_INT 9
57850: DOUBLE
57851: EQUAL
57852: IFTRUE 57856
57854: GO 57902
57856: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57857: LD_ADDR_VAR 0 8
57861: PUSH
57862: LD_VAR 0 2
57866: PPUSH
57867: LD_INT 2
57869: PUSH
57870: LD_INT 30
57872: PUSH
57873: LD_INT 4
57875: PUSH
57876: EMPTY
57877: LIST
57878: LIST
57879: PUSH
57880: LD_INT 30
57882: PUSH
57883: LD_INT 5
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: LIST
57894: PPUSH
57895: CALL_OW 72
57899: ST_TO_ADDR
57900: GO 57903
57902: POP
// if not tmp then
57903: LD_VAR 0 8
57907: NOT
57908: IFFALSE 57912
// exit ;
57910: GO 58414
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57912: LD_VAR 0 4
57916: PUSH
57917: LD_INT 1
57919: PUSH
57920: LD_INT 15
57922: PUSH
57923: EMPTY
57924: LIST
57925: LIST
57926: IN
57927: PUSH
57928: LD_EXP 124
57932: PUSH
57933: LD_VAR 0 1
57937: ARRAY
57938: AND
57939: IFFALSE 58095
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57941: LD_ADDR_VAR 0 9
57945: PUSH
57946: LD_EXP 124
57950: PUSH
57951: LD_VAR 0 1
57955: ARRAY
57956: PUSH
57957: LD_INT 1
57959: ARRAY
57960: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57961: LD_VAR 0 9
57965: PUSH
57966: LD_EXP 125
57970: PUSH
57971: LD_VAR 0 1
57975: ARRAY
57976: IN
57977: NOT
57978: IFFALSE 58093
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57980: LD_ADDR_EXP 125
57984: PUSH
57985: LD_EXP 125
57989: PPUSH
57990: LD_VAR 0 1
57994: PUSH
57995: LD_EXP 125
57999: PUSH
58000: LD_VAR 0 1
58004: ARRAY
58005: PUSH
58006: LD_INT 1
58008: PLUS
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PPUSH
58014: LD_VAR 0 9
58018: PPUSH
58019: CALL 70353 0 3
58023: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58024: LD_ADDR_EXP 124
58028: PUSH
58029: LD_EXP 124
58033: PPUSH
58034: LD_VAR 0 1
58038: PPUSH
58039: LD_EXP 124
58043: PUSH
58044: LD_VAR 0 1
58048: ARRAY
58049: PUSH
58050: LD_VAR 0 9
58054: DIFF
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58061: LD_VAR 0 3
58065: PPUSH
58066: LD_EXP 125
58070: PUSH
58071: LD_VAR 0 1
58075: ARRAY
58076: PUSH
58077: LD_EXP 125
58081: PUSH
58082: LD_VAR 0 1
58086: ARRAY
58087: ARRAY
58088: PPUSH
58089: CALL_OW 120
// end ; exit ;
58093: GO 58414
// end ; if tmp > 1 then
58095: LD_VAR 0 8
58099: PUSH
58100: LD_INT 1
58102: GREATER
58103: IFFALSE 58207
// for i = 2 to tmp do
58105: LD_ADDR_VAR 0 6
58109: PUSH
58110: DOUBLE
58111: LD_INT 2
58113: DEC
58114: ST_TO_ADDR
58115: LD_VAR 0 8
58119: PUSH
58120: FOR_TO
58121: IFFALSE 58205
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58123: LD_VAR 0 8
58127: PUSH
58128: LD_VAR 0 6
58132: ARRAY
58133: PPUSH
58134: CALL_OW 461
58138: PUSH
58139: LD_INT 6
58141: EQUAL
58142: IFFALSE 58203
// begin x := tmp [ i ] ;
58144: LD_ADDR_VAR 0 9
58148: PUSH
58149: LD_VAR 0 8
58153: PUSH
58154: LD_VAR 0 6
58158: ARRAY
58159: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58160: LD_ADDR_VAR 0 8
58164: PUSH
58165: LD_VAR 0 8
58169: PPUSH
58170: LD_VAR 0 6
58174: PPUSH
58175: CALL_OW 3
58179: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58180: LD_ADDR_VAR 0 8
58184: PUSH
58185: LD_VAR 0 8
58189: PPUSH
58190: LD_INT 1
58192: PPUSH
58193: LD_VAR 0 9
58197: PPUSH
58198: CALL_OW 2
58202: ST_TO_ADDR
// end ;
58203: GO 58120
58205: POP
58206: POP
// for i in tmp do
58207: LD_ADDR_VAR 0 6
58211: PUSH
58212: LD_VAR 0 8
58216: PUSH
58217: FOR_IN
58218: IFFALSE 58287
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58220: LD_VAR 0 6
58224: PPUSH
58225: CALL_OW 313
58229: PUSH
58230: LD_INT 6
58232: LESS
58233: PUSH
58234: LD_VAR 0 6
58238: PPUSH
58239: CALL_OW 266
58243: PUSH
58244: LD_INT 31
58246: PUSH
58247: LD_INT 32
58249: PUSH
58250: EMPTY
58251: LIST
58252: LIST
58253: IN
58254: NOT
58255: AND
58256: PUSH
58257: LD_VAR 0 6
58261: PPUSH
58262: CALL_OW 313
58266: PUSH
58267: LD_INT 0
58269: EQUAL
58270: OR
58271: IFFALSE 58285
// begin j := i ;
58273: LD_ADDR_VAR 0 7
58277: PUSH
58278: LD_VAR 0 6
58282: ST_TO_ADDR
// break ;
58283: GO 58287
// end ; end ;
58285: GO 58217
58287: POP
58288: POP
// if j then
58289: LD_VAR 0 7
58293: IFFALSE 58311
// ComEnterUnit ( unit , j ) else
58295: LD_VAR 0 3
58299: PPUSH
58300: LD_VAR 0 7
58304: PPUSH
58305: CALL_OW 120
58309: GO 58414
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58311: LD_ADDR_VAR 0 10
58315: PUSH
58316: LD_VAR 0 2
58320: PPUSH
58321: LD_INT 2
58323: PUSH
58324: LD_INT 30
58326: PUSH
58327: LD_INT 0
58329: PUSH
58330: EMPTY
58331: LIST
58332: LIST
58333: PUSH
58334: LD_INT 30
58336: PUSH
58337: LD_INT 1
58339: PUSH
58340: EMPTY
58341: LIST
58342: LIST
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: LIST
58348: PPUSH
58349: CALL_OW 72
58353: ST_TO_ADDR
// if depot then
58354: LD_VAR 0 10
58358: IFFALSE 58414
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58360: LD_ADDR_VAR 0 10
58364: PUSH
58365: LD_VAR 0 10
58369: PPUSH
58370: LD_VAR 0 3
58374: PPUSH
58375: CALL_OW 74
58379: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58380: LD_VAR 0 3
58384: PPUSH
58385: LD_VAR 0 10
58389: PPUSH
58390: CALL_OW 296
58394: PUSH
58395: LD_INT 10
58397: GREATER
58398: IFFALSE 58414
// ComStandNearbyBuilding ( unit , depot ) ;
58400: LD_VAR 0 3
58404: PPUSH
58405: LD_VAR 0 10
58409: PPUSH
58410: CALL 66967 0 2
// end ; end ; end ;
58414: LD_VAR 0 5
58418: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58419: LD_INT 0
58421: PPUSH
58422: PPUSH
58423: PPUSH
58424: PPUSH
// if not mc_bases then
58425: LD_EXP 115
58429: NOT
58430: IFFALSE 58434
// exit ;
58432: GO 58673
// for i = 1 to mc_bases do
58434: LD_ADDR_VAR 0 2
58438: PUSH
58439: DOUBLE
58440: LD_INT 1
58442: DEC
58443: ST_TO_ADDR
58444: LD_EXP 115
58448: PUSH
58449: FOR_TO
58450: IFFALSE 58671
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58452: LD_ADDR_VAR 0 4
58456: PUSH
58457: LD_EXP 115
58461: PUSH
58462: LD_VAR 0 2
58466: ARRAY
58467: PPUSH
58468: LD_INT 21
58470: PUSH
58471: LD_INT 1
58473: PUSH
58474: EMPTY
58475: LIST
58476: LIST
58477: PPUSH
58478: CALL_OW 72
58482: PUSH
58483: LD_EXP 144
58487: PUSH
58488: LD_VAR 0 2
58492: ARRAY
58493: UNION
58494: ST_TO_ADDR
// if not tmp then
58495: LD_VAR 0 4
58499: NOT
58500: IFFALSE 58504
// continue ;
58502: GO 58449
// for j in tmp do
58504: LD_ADDR_VAR 0 3
58508: PUSH
58509: LD_VAR 0 4
58513: PUSH
58514: FOR_IN
58515: IFFALSE 58667
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58517: LD_VAR 0 3
58521: PPUSH
58522: CALL_OW 110
58526: NOT
58527: PUSH
58528: LD_VAR 0 3
58532: PPUSH
58533: CALL_OW 314
58537: NOT
58538: AND
58539: PUSH
58540: LD_VAR 0 3
58544: PPUSH
58545: CALL_OW 311
58549: NOT
58550: AND
58551: PUSH
58552: LD_VAR 0 3
58556: PPUSH
58557: CALL_OW 310
58561: NOT
58562: AND
58563: PUSH
58564: LD_VAR 0 3
58568: PUSH
58569: LD_EXP 118
58573: PUSH
58574: LD_VAR 0 2
58578: ARRAY
58579: PUSH
58580: LD_INT 1
58582: ARRAY
58583: IN
58584: NOT
58585: AND
58586: PUSH
58587: LD_VAR 0 3
58591: PUSH
58592: LD_EXP 118
58596: PUSH
58597: LD_VAR 0 2
58601: ARRAY
58602: PUSH
58603: LD_INT 2
58605: ARRAY
58606: IN
58607: NOT
58608: AND
58609: PUSH
58610: LD_VAR 0 3
58614: PUSH
58615: LD_EXP 127
58619: PUSH
58620: LD_VAR 0 2
58624: ARRAY
58625: IN
58626: NOT
58627: AND
58628: IFFALSE 58665
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58630: LD_VAR 0 2
58634: PPUSH
58635: LD_EXP 115
58639: PUSH
58640: LD_VAR 0 2
58644: ARRAY
58645: PPUSH
58646: LD_VAR 0 3
58650: PPUSH
58651: LD_VAR 0 3
58655: PPUSH
58656: CALL_OW 257
58660: PPUSH
58661: CALL 57437 0 4
// end ;
58665: GO 58514
58667: POP
58668: POP
// end ;
58669: GO 58449
58671: POP
58672: POP
// end ;
58673: LD_VAR 0 1
58677: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58678: LD_INT 0
58680: PPUSH
58681: PPUSH
58682: PPUSH
58683: PPUSH
58684: PPUSH
58685: PPUSH
// if not mc_bases [ base ] then
58686: LD_EXP 115
58690: PUSH
58691: LD_VAR 0 1
58695: ARRAY
58696: NOT
58697: IFFALSE 58701
// exit ;
58699: GO 58883
// tmp := [ ] ;
58701: LD_ADDR_VAR 0 6
58705: PUSH
58706: EMPTY
58707: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58708: LD_ADDR_VAR 0 7
58712: PUSH
58713: LD_VAR 0 3
58717: PPUSH
58718: LD_INT 0
58720: PPUSH
58721: CALL_OW 517
58725: ST_TO_ADDR
// if not list then
58726: LD_VAR 0 7
58730: NOT
58731: IFFALSE 58735
// exit ;
58733: GO 58883
// for i = 1 to amount do
58735: LD_ADDR_VAR 0 5
58739: PUSH
58740: DOUBLE
58741: LD_INT 1
58743: DEC
58744: ST_TO_ADDR
58745: LD_VAR 0 2
58749: PUSH
58750: FOR_TO
58751: IFFALSE 58831
// begin x := rand ( 1 , list [ 1 ] ) ;
58753: LD_ADDR_VAR 0 8
58757: PUSH
58758: LD_INT 1
58760: PPUSH
58761: LD_VAR 0 7
58765: PUSH
58766: LD_INT 1
58768: ARRAY
58769: PPUSH
58770: CALL_OW 12
58774: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58775: LD_ADDR_VAR 0 6
58779: PUSH
58780: LD_VAR 0 6
58784: PPUSH
58785: LD_VAR 0 5
58789: PPUSH
58790: LD_VAR 0 7
58794: PUSH
58795: LD_INT 1
58797: ARRAY
58798: PUSH
58799: LD_VAR 0 8
58803: ARRAY
58804: PUSH
58805: LD_VAR 0 7
58809: PUSH
58810: LD_INT 2
58812: ARRAY
58813: PUSH
58814: LD_VAR 0 8
58818: ARRAY
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: PPUSH
58824: CALL_OW 1
58828: ST_TO_ADDR
// end ;
58829: GO 58750
58831: POP
58832: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58833: LD_ADDR_EXP 128
58837: PUSH
58838: LD_EXP 128
58842: PPUSH
58843: LD_VAR 0 1
58847: PPUSH
58848: LD_VAR 0 6
58852: PPUSH
58853: CALL_OW 1
58857: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58858: LD_ADDR_EXP 130
58862: PUSH
58863: LD_EXP 130
58867: PPUSH
58868: LD_VAR 0 1
58872: PPUSH
58873: LD_VAR 0 3
58877: PPUSH
58878: CALL_OW 1
58882: ST_TO_ADDR
// end ;
58883: LD_VAR 0 4
58887: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58888: LD_INT 0
58890: PPUSH
// if not mc_bases [ base ] then
58891: LD_EXP 115
58895: PUSH
58896: LD_VAR 0 1
58900: ARRAY
58901: NOT
58902: IFFALSE 58906
// exit ;
58904: GO 58931
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58906: LD_ADDR_EXP 120
58910: PUSH
58911: LD_EXP 120
58915: PPUSH
58916: LD_VAR 0 1
58920: PPUSH
58921: LD_VAR 0 2
58925: PPUSH
58926: CALL_OW 1
58930: ST_TO_ADDR
// end ;
58931: LD_VAR 0 3
58935: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58936: LD_INT 0
58938: PPUSH
// if not mc_bases [ base ] then
58939: LD_EXP 115
58943: PUSH
58944: LD_VAR 0 1
58948: ARRAY
58949: NOT
58950: IFFALSE 58954
// exit ;
58952: GO 58991
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58954: LD_ADDR_EXP 120
58958: PUSH
58959: LD_EXP 120
58963: PPUSH
58964: LD_VAR 0 1
58968: PPUSH
58969: LD_EXP 120
58973: PUSH
58974: LD_VAR 0 1
58978: ARRAY
58979: PUSH
58980: LD_VAR 0 2
58984: UNION
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// end ;
58991: LD_VAR 0 3
58995: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58996: LD_INT 0
58998: PPUSH
// if not mc_bases [ base ] then
58999: LD_EXP 115
59003: PUSH
59004: LD_VAR 0 1
59008: ARRAY
59009: NOT
59010: IFFALSE 59014
// exit ;
59012: GO 59039
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59014: LD_ADDR_EXP 136
59018: PUSH
59019: LD_EXP 136
59023: PPUSH
59024: LD_VAR 0 1
59028: PPUSH
59029: LD_VAR 0 2
59033: PPUSH
59034: CALL_OW 1
59038: ST_TO_ADDR
// end ;
59039: LD_VAR 0 3
59043: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59044: LD_INT 0
59046: PPUSH
// if not mc_bases [ base ] then
59047: LD_EXP 115
59051: PUSH
59052: LD_VAR 0 1
59056: ARRAY
59057: NOT
59058: IFFALSE 59062
// exit ;
59060: GO 59099
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59062: LD_ADDR_EXP 136
59066: PUSH
59067: LD_EXP 136
59071: PPUSH
59072: LD_VAR 0 1
59076: PPUSH
59077: LD_EXP 136
59081: PUSH
59082: LD_VAR 0 1
59086: ARRAY
59087: PUSH
59088: LD_VAR 0 2
59092: ADD
59093: PPUSH
59094: CALL_OW 1
59098: ST_TO_ADDR
// end ;
59099: LD_VAR 0 3
59103: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59104: LD_INT 0
59106: PPUSH
// if not mc_bases [ base ] then
59107: LD_EXP 115
59111: PUSH
59112: LD_VAR 0 1
59116: ARRAY
59117: NOT
59118: IFFALSE 59122
// exit ;
59120: GO 59176
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59122: LD_ADDR_EXP 137
59126: PUSH
59127: LD_EXP 137
59131: PPUSH
59132: LD_VAR 0 1
59136: PPUSH
59137: LD_VAR 0 2
59141: PPUSH
59142: CALL_OW 1
59146: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59147: LD_ADDR_EXP 126
59151: PUSH
59152: LD_EXP 126
59156: PPUSH
59157: LD_VAR 0 1
59161: PPUSH
59162: LD_VAR 0 2
59166: PUSH
59167: LD_INT 0
59169: PLUS
59170: PPUSH
59171: CALL_OW 1
59175: ST_TO_ADDR
// end ;
59176: LD_VAR 0 3
59180: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59181: LD_INT 0
59183: PPUSH
// if not mc_bases [ base ] then
59184: LD_EXP 115
59188: PUSH
59189: LD_VAR 0 1
59193: ARRAY
59194: NOT
59195: IFFALSE 59199
// exit ;
59197: GO 59224
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59199: LD_ADDR_EXP 126
59203: PUSH
59204: LD_EXP 126
59208: PPUSH
59209: LD_VAR 0 1
59213: PPUSH
59214: LD_VAR 0 2
59218: PPUSH
59219: CALL_OW 1
59223: ST_TO_ADDR
// end ;
59224: LD_VAR 0 3
59228: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59229: LD_INT 0
59231: PPUSH
59232: PPUSH
59233: PPUSH
59234: PPUSH
// if not mc_bases [ base ] then
59235: LD_EXP 115
59239: PUSH
59240: LD_VAR 0 1
59244: ARRAY
59245: NOT
59246: IFFALSE 59250
// exit ;
59248: GO 59315
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59250: LD_ADDR_EXP 135
59254: PUSH
59255: LD_EXP 135
59259: PPUSH
59260: LD_VAR 0 1
59264: PUSH
59265: LD_EXP 135
59269: PUSH
59270: LD_VAR 0 1
59274: ARRAY
59275: PUSH
59276: LD_INT 1
59278: PLUS
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: PPUSH
59284: LD_VAR 0 1
59288: PUSH
59289: LD_VAR 0 2
59293: PUSH
59294: LD_VAR 0 3
59298: PUSH
59299: LD_VAR 0 4
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: LIST
59308: LIST
59309: PPUSH
59310: CALL 70353 0 3
59314: ST_TO_ADDR
// end ;
59315: LD_VAR 0 5
59319: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59320: LD_INT 0
59322: PPUSH
// if not mc_bases [ base ] then
59323: LD_EXP 115
59327: PUSH
59328: LD_VAR 0 1
59332: ARRAY
59333: NOT
59334: IFFALSE 59338
// exit ;
59336: GO 59363
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59338: LD_ADDR_EXP 152
59342: PUSH
59343: LD_EXP 152
59347: PPUSH
59348: LD_VAR 0 1
59352: PPUSH
59353: LD_VAR 0 2
59357: PPUSH
59358: CALL_OW 1
59362: ST_TO_ADDR
// end ;
59363: LD_VAR 0 3
59367: RET
// export function MC_GetMinesField ( base ) ; begin
59368: LD_INT 0
59370: PPUSH
// result := mc_mines [ base ] ;
59371: LD_ADDR_VAR 0 2
59375: PUSH
59376: LD_EXP 128
59380: PUSH
59381: LD_VAR 0 1
59385: ARRAY
59386: ST_TO_ADDR
// end ;
59387: LD_VAR 0 2
59391: RET
// export function MC_GetProduceList ( base ) ; begin
59392: LD_INT 0
59394: PPUSH
// result := mc_produce [ base ] ;
59395: LD_ADDR_VAR 0 2
59399: PUSH
59400: LD_EXP 136
59404: PUSH
59405: LD_VAR 0 1
59409: ARRAY
59410: ST_TO_ADDR
// end ;
59411: LD_VAR 0 2
59415: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59416: LD_INT 0
59418: PPUSH
59419: PPUSH
// if not mc_bases then
59420: LD_EXP 115
59424: NOT
59425: IFFALSE 59429
// exit ;
59427: GO 59494
// if mc_bases [ base ] then
59429: LD_EXP 115
59433: PUSH
59434: LD_VAR 0 1
59438: ARRAY
59439: IFFALSE 59494
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59441: LD_ADDR_VAR 0 3
59445: PUSH
59446: LD_EXP 115
59450: PUSH
59451: LD_VAR 0 1
59455: ARRAY
59456: PPUSH
59457: LD_INT 30
59459: PUSH
59460: LD_VAR 0 2
59464: PUSH
59465: EMPTY
59466: LIST
59467: LIST
59468: PPUSH
59469: CALL_OW 72
59473: ST_TO_ADDR
// if result then
59474: LD_VAR 0 3
59478: IFFALSE 59494
// result := result [ 1 ] ;
59480: LD_ADDR_VAR 0 3
59484: PUSH
59485: LD_VAR 0 3
59489: PUSH
59490: LD_INT 1
59492: ARRAY
59493: ST_TO_ADDR
// end ; end ;
59494: LD_VAR 0 3
59498: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59499: LD_INT 0
59501: PPUSH
59502: PPUSH
// if not mc_bases then
59503: LD_EXP 115
59507: NOT
59508: IFFALSE 59512
// exit ;
59510: GO 59557
// if mc_bases [ base ] then
59512: LD_EXP 115
59516: PUSH
59517: LD_VAR 0 1
59521: ARRAY
59522: IFFALSE 59557
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59524: LD_ADDR_VAR 0 3
59528: PUSH
59529: LD_EXP 115
59533: PUSH
59534: LD_VAR 0 1
59538: ARRAY
59539: PPUSH
59540: LD_INT 30
59542: PUSH
59543: LD_VAR 0 2
59547: PUSH
59548: EMPTY
59549: LIST
59550: LIST
59551: PPUSH
59552: CALL_OW 72
59556: ST_TO_ADDR
// end ;
59557: LD_VAR 0 3
59561: RET
// export function MC_SetTame ( base , area ) ; begin
59562: LD_INT 0
59564: PPUSH
// if not mc_bases or not base then
59565: LD_EXP 115
59569: NOT
59570: PUSH
59571: LD_VAR 0 1
59575: NOT
59576: OR
59577: IFFALSE 59581
// exit ;
59579: GO 59606
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59581: LD_ADDR_EXP 143
59585: PUSH
59586: LD_EXP 143
59590: PPUSH
59591: LD_VAR 0 1
59595: PPUSH
59596: LD_VAR 0 2
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
// end ;
59606: LD_VAR 0 3
59610: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59611: LD_INT 0
59613: PPUSH
59614: PPUSH
// if not mc_bases or not base then
59615: LD_EXP 115
59619: NOT
59620: PUSH
59621: LD_VAR 0 1
59625: NOT
59626: OR
59627: IFFALSE 59631
// exit ;
59629: GO 59733
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59631: LD_ADDR_VAR 0 4
59635: PUSH
59636: LD_EXP 115
59640: PUSH
59641: LD_VAR 0 1
59645: ARRAY
59646: PPUSH
59647: LD_INT 30
59649: PUSH
59650: LD_VAR 0 2
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 72
59663: ST_TO_ADDR
// if not tmp then
59664: LD_VAR 0 4
59668: NOT
59669: IFFALSE 59673
// exit ;
59671: GO 59733
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59673: LD_ADDR_EXP 147
59677: PUSH
59678: LD_EXP 147
59682: PPUSH
59683: LD_VAR 0 1
59687: PPUSH
59688: LD_EXP 147
59692: PUSH
59693: LD_VAR 0 1
59697: ARRAY
59698: PPUSH
59699: LD_EXP 147
59703: PUSH
59704: LD_VAR 0 1
59708: ARRAY
59709: PUSH
59710: LD_INT 1
59712: PLUS
59713: PPUSH
59714: LD_VAR 0 4
59718: PUSH
59719: LD_INT 1
59721: ARRAY
59722: PPUSH
59723: CALL_OW 2
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// end ;
59733: LD_VAR 0 3
59737: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59738: LD_INT 0
59740: PPUSH
59741: PPUSH
// if not mc_bases or not base or not kinds then
59742: LD_EXP 115
59746: NOT
59747: PUSH
59748: LD_VAR 0 1
59752: NOT
59753: OR
59754: PUSH
59755: LD_VAR 0 2
59759: NOT
59760: OR
59761: IFFALSE 59765
// exit ;
59763: GO 59826
// for i in kinds do
59765: LD_ADDR_VAR 0 4
59769: PUSH
59770: LD_VAR 0 2
59774: PUSH
59775: FOR_IN
59776: IFFALSE 59824
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59778: LD_ADDR_EXP 149
59782: PUSH
59783: LD_EXP 149
59787: PPUSH
59788: LD_VAR 0 1
59792: PUSH
59793: LD_EXP 149
59797: PUSH
59798: LD_VAR 0 1
59802: ARRAY
59803: PUSH
59804: LD_INT 1
59806: PLUS
59807: PUSH
59808: EMPTY
59809: LIST
59810: LIST
59811: PPUSH
59812: LD_VAR 0 4
59816: PPUSH
59817: CALL 70353 0 3
59821: ST_TO_ADDR
59822: GO 59775
59824: POP
59825: POP
// end ;
59826: LD_VAR 0 3
59830: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59831: LD_INT 0
59833: PPUSH
// if not mc_bases or not base or not areas then
59834: LD_EXP 115
59838: NOT
59839: PUSH
59840: LD_VAR 0 1
59844: NOT
59845: OR
59846: PUSH
59847: LD_VAR 0 2
59851: NOT
59852: OR
59853: IFFALSE 59857
// exit ;
59855: GO 59882
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59857: LD_ADDR_EXP 133
59861: PUSH
59862: LD_EXP 133
59866: PPUSH
59867: LD_VAR 0 1
59871: PPUSH
59872: LD_VAR 0 2
59876: PPUSH
59877: CALL_OW 1
59881: ST_TO_ADDR
// end ;
59882: LD_VAR 0 3
59886: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59887: LD_INT 0
59889: PPUSH
// if not mc_bases or not base or not teleports_exit then
59890: LD_EXP 115
59894: NOT
59895: PUSH
59896: LD_VAR 0 1
59900: NOT
59901: OR
59902: PUSH
59903: LD_VAR 0 2
59907: NOT
59908: OR
59909: IFFALSE 59913
// exit ;
59911: GO 59938
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59913: LD_ADDR_EXP 150
59917: PUSH
59918: LD_EXP 150
59922: PPUSH
59923: LD_VAR 0 1
59927: PPUSH
59928: LD_VAR 0 2
59932: PPUSH
59933: CALL_OW 1
59937: ST_TO_ADDR
// end ;
59938: LD_VAR 0 3
59942: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59943: LD_INT 0
59945: PPUSH
59946: PPUSH
59947: PPUSH
// if not mc_bases or not base or not ext_list then
59948: LD_EXP 115
59952: NOT
59953: PUSH
59954: LD_VAR 0 1
59958: NOT
59959: OR
59960: PUSH
59961: LD_VAR 0 5
59965: NOT
59966: OR
59967: IFFALSE 59971
// exit ;
59969: GO 60144
// tmp := GetFacExtXYD ( x , y , d ) ;
59971: LD_ADDR_VAR 0 8
59975: PUSH
59976: LD_VAR 0 2
59980: PPUSH
59981: LD_VAR 0 3
59985: PPUSH
59986: LD_VAR 0 4
59990: PPUSH
59991: CALL 99365 0 3
59995: ST_TO_ADDR
// if not tmp then
59996: LD_VAR 0 8
60000: NOT
60001: IFFALSE 60005
// exit ;
60003: GO 60144
// for i in tmp do
60005: LD_ADDR_VAR 0 7
60009: PUSH
60010: LD_VAR 0 8
60014: PUSH
60015: FOR_IN
60016: IFFALSE 60142
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60018: LD_ADDR_EXP 120
60022: PUSH
60023: LD_EXP 120
60027: PPUSH
60028: LD_VAR 0 1
60032: PPUSH
60033: LD_EXP 120
60037: PUSH
60038: LD_VAR 0 1
60042: ARRAY
60043: PPUSH
60044: LD_EXP 120
60048: PUSH
60049: LD_VAR 0 1
60053: ARRAY
60054: PUSH
60055: LD_INT 1
60057: PLUS
60058: PPUSH
60059: LD_VAR 0 5
60063: PUSH
60064: LD_INT 1
60066: ARRAY
60067: PUSH
60068: LD_VAR 0 7
60072: PUSH
60073: LD_INT 1
60075: ARRAY
60076: PUSH
60077: LD_VAR 0 7
60081: PUSH
60082: LD_INT 2
60084: ARRAY
60085: PUSH
60086: LD_VAR 0 7
60090: PUSH
60091: LD_INT 3
60093: ARRAY
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: LIST
60099: LIST
60100: PPUSH
60101: CALL_OW 2
60105: PPUSH
60106: CALL_OW 1
60110: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60111: LD_ADDR_VAR 0 5
60115: PUSH
60116: LD_VAR 0 5
60120: PPUSH
60121: LD_INT 1
60123: PPUSH
60124: CALL_OW 3
60128: ST_TO_ADDR
// if not ext_list then
60129: LD_VAR 0 5
60133: NOT
60134: IFFALSE 60140
// exit ;
60136: POP
60137: POP
60138: GO 60144
// end ;
60140: GO 60015
60142: POP
60143: POP
// end ;
60144: LD_VAR 0 6
60148: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60149: LD_INT 0
60151: PPUSH
// if not mc_bases or not base or not weapon_list then
60152: LD_EXP 115
60156: NOT
60157: PUSH
60158: LD_VAR 0 1
60162: NOT
60163: OR
60164: PUSH
60165: LD_VAR 0 2
60169: NOT
60170: OR
60171: IFFALSE 60175
// exit ;
60173: GO 60200
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60175: LD_ADDR_EXP 154
60179: PUSH
60180: LD_EXP 154
60184: PPUSH
60185: LD_VAR 0 1
60189: PPUSH
60190: LD_VAR 0 2
60194: PPUSH
60195: CALL_OW 1
60199: ST_TO_ADDR
// end ;
60200: LD_VAR 0 3
60204: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60205: LD_INT 0
60207: PPUSH
// if not mc_bases or not base or not tech_list then
60208: LD_EXP 115
60212: NOT
60213: PUSH
60214: LD_VAR 0 1
60218: NOT
60219: OR
60220: PUSH
60221: LD_VAR 0 2
60225: NOT
60226: OR
60227: IFFALSE 60231
// exit ;
60229: GO 60256
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60231: LD_ADDR_EXP 142
60235: PUSH
60236: LD_EXP 142
60240: PPUSH
60241: LD_VAR 0 1
60245: PPUSH
60246: LD_VAR 0 2
60250: PPUSH
60251: CALL_OW 1
60255: ST_TO_ADDR
// end ;
60256: LD_VAR 0 3
60260: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60261: LD_INT 0
60263: PPUSH
// if not mc_bases or not parking_area or not base then
60264: LD_EXP 115
60268: NOT
60269: PUSH
60270: LD_VAR 0 2
60274: NOT
60275: OR
60276: PUSH
60277: LD_VAR 0 1
60281: NOT
60282: OR
60283: IFFALSE 60287
// exit ;
60285: GO 60312
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60287: LD_ADDR_EXP 139
60291: PUSH
60292: LD_EXP 139
60296: PPUSH
60297: LD_VAR 0 1
60301: PPUSH
60302: LD_VAR 0 2
60306: PPUSH
60307: CALL_OW 1
60311: ST_TO_ADDR
// end ;
60312: LD_VAR 0 3
60316: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60317: LD_INT 0
60319: PPUSH
// if not mc_bases or not base or not scan_area then
60320: LD_EXP 115
60324: NOT
60325: PUSH
60326: LD_VAR 0 1
60330: NOT
60331: OR
60332: PUSH
60333: LD_VAR 0 2
60337: NOT
60338: OR
60339: IFFALSE 60343
// exit ;
60341: GO 60368
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60343: LD_ADDR_EXP 140
60347: PUSH
60348: LD_EXP 140
60352: PPUSH
60353: LD_VAR 0 1
60357: PPUSH
60358: LD_VAR 0 2
60362: PPUSH
60363: CALL_OW 1
60367: ST_TO_ADDR
// end ;
60368: LD_VAR 0 3
60372: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60373: LD_INT 0
60375: PPUSH
60376: PPUSH
// if not mc_bases or not base then
60377: LD_EXP 115
60381: NOT
60382: PUSH
60383: LD_VAR 0 1
60387: NOT
60388: OR
60389: IFFALSE 60393
// exit ;
60391: GO 60457
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60393: LD_ADDR_VAR 0 3
60397: PUSH
60398: LD_INT 1
60400: PUSH
60401: LD_INT 2
60403: PUSH
60404: LD_INT 3
60406: PUSH
60407: LD_INT 4
60409: PUSH
60410: LD_INT 11
60412: PUSH
60413: EMPTY
60414: LIST
60415: LIST
60416: LIST
60417: LIST
60418: LIST
60419: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60420: LD_ADDR_EXP 142
60424: PUSH
60425: LD_EXP 142
60429: PPUSH
60430: LD_VAR 0 1
60434: PPUSH
60435: LD_EXP 142
60439: PUSH
60440: LD_VAR 0 1
60444: ARRAY
60445: PUSH
60446: LD_VAR 0 3
60450: DIFF
60451: PPUSH
60452: CALL_OW 1
60456: ST_TO_ADDR
// end ;
60457: LD_VAR 0 2
60461: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60462: LD_INT 0
60464: PPUSH
// result := mc_vehicles [ base ] ;
60465: LD_ADDR_VAR 0 3
60469: PUSH
60470: LD_EXP 134
60474: PUSH
60475: LD_VAR 0 1
60479: ARRAY
60480: ST_TO_ADDR
// if onlyCombat then
60481: LD_VAR 0 2
60485: IFFALSE 60663
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60487: LD_ADDR_VAR 0 3
60491: PUSH
60492: LD_VAR 0 3
60496: PUSH
60497: LD_VAR 0 3
60501: PPUSH
60502: LD_INT 2
60504: PUSH
60505: LD_INT 34
60507: PUSH
60508: LD_INT 12
60510: PUSH
60511: EMPTY
60512: LIST
60513: LIST
60514: PUSH
60515: LD_INT 34
60517: PUSH
60518: LD_INT 51
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PUSH
60525: LD_INT 34
60527: PUSH
60528: LD_EXP 96
60532: PUSH
60533: EMPTY
60534: LIST
60535: LIST
60536: PUSH
60537: LD_INT 34
60539: PUSH
60540: LD_INT 32
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PUSH
60547: LD_INT 34
60549: PUSH
60550: LD_INT 13
60552: PUSH
60553: EMPTY
60554: LIST
60555: LIST
60556: PUSH
60557: LD_INT 34
60559: PUSH
60560: LD_INT 52
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PUSH
60567: LD_INT 34
60569: PUSH
60570: LD_EXP 101
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: PUSH
60579: LD_INT 34
60581: PUSH
60582: LD_INT 14
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: LD_INT 34
60591: PUSH
60592: LD_INT 53
60594: PUSH
60595: EMPTY
60596: LIST
60597: LIST
60598: PUSH
60599: LD_INT 34
60601: PUSH
60602: LD_EXP 95
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: PUSH
60611: LD_INT 34
60613: PUSH
60614: LD_INT 31
60616: PUSH
60617: EMPTY
60618: LIST
60619: LIST
60620: PUSH
60621: LD_INT 34
60623: PUSH
60624: LD_INT 48
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PUSH
60631: LD_INT 34
60633: PUSH
60634: LD_INT 8
60636: PUSH
60637: EMPTY
60638: LIST
60639: LIST
60640: PUSH
60641: EMPTY
60642: LIST
60643: LIST
60644: LIST
60645: LIST
60646: LIST
60647: LIST
60648: LIST
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: LIST
60654: LIST
60655: LIST
60656: PPUSH
60657: CALL_OW 72
60661: DIFF
60662: ST_TO_ADDR
// end ; end_of_file
60663: LD_VAR 0 3
60667: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60668: LD_INT 0
60670: PPUSH
60671: PPUSH
60672: PPUSH
// if not mc_bases or not skirmish then
60673: LD_EXP 115
60677: NOT
60678: PUSH
60679: LD_EXP 113
60683: NOT
60684: OR
60685: IFFALSE 60689
// exit ;
60687: GO 60854
// for i = 1 to mc_bases do
60689: LD_ADDR_VAR 0 4
60693: PUSH
60694: DOUBLE
60695: LD_INT 1
60697: DEC
60698: ST_TO_ADDR
60699: LD_EXP 115
60703: PUSH
60704: FOR_TO
60705: IFFALSE 60852
// begin if sci in mc_bases [ i ] then
60707: LD_VAR 0 2
60711: PUSH
60712: LD_EXP 115
60716: PUSH
60717: LD_VAR 0 4
60721: ARRAY
60722: IN
60723: IFFALSE 60850
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60725: LD_ADDR_EXP 144
60729: PUSH
60730: LD_EXP 144
60734: PPUSH
60735: LD_VAR 0 4
60739: PUSH
60740: LD_EXP 144
60744: PUSH
60745: LD_VAR 0 4
60749: ARRAY
60750: PUSH
60751: LD_INT 1
60753: PLUS
60754: PUSH
60755: EMPTY
60756: LIST
60757: LIST
60758: PPUSH
60759: LD_VAR 0 1
60763: PPUSH
60764: CALL 70353 0 3
60768: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60769: LD_ADDR_VAR 0 5
60773: PUSH
60774: LD_EXP 115
60778: PUSH
60779: LD_VAR 0 4
60783: ARRAY
60784: PPUSH
60785: LD_INT 2
60787: PUSH
60788: LD_INT 30
60790: PUSH
60791: LD_INT 0
60793: PUSH
60794: EMPTY
60795: LIST
60796: LIST
60797: PUSH
60798: LD_INT 30
60800: PUSH
60801: LD_INT 1
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: LIST
60812: PPUSH
60813: CALL_OW 72
60817: PPUSH
60818: LD_VAR 0 1
60822: PPUSH
60823: CALL_OW 74
60827: ST_TO_ADDR
// if tmp then
60828: LD_VAR 0 5
60832: IFFALSE 60848
// ComStandNearbyBuilding ( ape , tmp ) ;
60834: LD_VAR 0 1
60838: PPUSH
60839: LD_VAR 0 5
60843: PPUSH
60844: CALL 66967 0 2
// break ;
60848: GO 60852
// end ; end ;
60850: GO 60704
60852: POP
60853: POP
// end ;
60854: LD_VAR 0 3
60858: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60859: LD_INT 0
60861: PPUSH
60862: PPUSH
60863: PPUSH
// if not mc_bases or not skirmish then
60864: LD_EXP 115
60868: NOT
60869: PUSH
60870: LD_EXP 113
60874: NOT
60875: OR
60876: IFFALSE 60880
// exit ;
60878: GO 60969
// for i = 1 to mc_bases do
60880: LD_ADDR_VAR 0 4
60884: PUSH
60885: DOUBLE
60886: LD_INT 1
60888: DEC
60889: ST_TO_ADDR
60890: LD_EXP 115
60894: PUSH
60895: FOR_TO
60896: IFFALSE 60967
// begin if building in mc_busy_turret_list [ i ] then
60898: LD_VAR 0 1
60902: PUSH
60903: LD_EXP 125
60907: PUSH
60908: LD_VAR 0 4
60912: ARRAY
60913: IN
60914: IFFALSE 60965
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60916: LD_ADDR_VAR 0 5
60920: PUSH
60921: LD_EXP 125
60925: PUSH
60926: LD_VAR 0 4
60930: ARRAY
60931: PUSH
60932: LD_VAR 0 1
60936: DIFF
60937: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60938: LD_ADDR_EXP 125
60942: PUSH
60943: LD_EXP 125
60947: PPUSH
60948: LD_VAR 0 4
60952: PPUSH
60953: LD_VAR 0 5
60957: PPUSH
60958: CALL_OW 1
60962: ST_TO_ADDR
// break ;
60963: GO 60967
// end ; end ;
60965: GO 60895
60967: POP
60968: POP
// end ;
60969: LD_VAR 0 3
60973: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60974: LD_INT 0
60976: PPUSH
60977: PPUSH
60978: PPUSH
// if not mc_bases or not skirmish then
60979: LD_EXP 115
60983: NOT
60984: PUSH
60985: LD_EXP 113
60989: NOT
60990: OR
60991: IFFALSE 60995
// exit ;
60993: GO 61194
// for i = 1 to mc_bases do
60995: LD_ADDR_VAR 0 5
60999: PUSH
61000: DOUBLE
61001: LD_INT 1
61003: DEC
61004: ST_TO_ADDR
61005: LD_EXP 115
61009: PUSH
61010: FOR_TO
61011: IFFALSE 61192
// if building in mc_bases [ i ] then
61013: LD_VAR 0 1
61017: PUSH
61018: LD_EXP 115
61022: PUSH
61023: LD_VAR 0 5
61027: ARRAY
61028: IN
61029: IFFALSE 61190
// begin tmp := mc_bases [ i ] diff building ;
61031: LD_ADDR_VAR 0 6
61035: PUSH
61036: LD_EXP 115
61040: PUSH
61041: LD_VAR 0 5
61045: ARRAY
61046: PUSH
61047: LD_VAR 0 1
61051: DIFF
61052: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61053: LD_ADDR_EXP 115
61057: PUSH
61058: LD_EXP 115
61062: PPUSH
61063: LD_VAR 0 5
61067: PPUSH
61068: LD_VAR 0 6
61072: PPUSH
61073: CALL_OW 1
61077: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61078: LD_VAR 0 1
61082: PUSH
61083: LD_EXP 123
61087: PUSH
61088: LD_VAR 0 5
61092: ARRAY
61093: IN
61094: IFFALSE 61133
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61096: LD_ADDR_EXP 123
61100: PUSH
61101: LD_EXP 123
61105: PPUSH
61106: LD_VAR 0 5
61110: PPUSH
61111: LD_EXP 123
61115: PUSH
61116: LD_VAR 0 5
61120: ARRAY
61121: PUSH
61122: LD_VAR 0 1
61126: DIFF
61127: PPUSH
61128: CALL_OW 1
61132: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61133: LD_VAR 0 1
61137: PUSH
61138: LD_EXP 124
61142: PUSH
61143: LD_VAR 0 5
61147: ARRAY
61148: IN
61149: IFFALSE 61188
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61151: LD_ADDR_EXP 124
61155: PUSH
61156: LD_EXP 124
61160: PPUSH
61161: LD_VAR 0 5
61165: PPUSH
61166: LD_EXP 124
61170: PUSH
61171: LD_VAR 0 5
61175: ARRAY
61176: PUSH
61177: LD_VAR 0 1
61181: DIFF
61182: PPUSH
61183: CALL_OW 1
61187: ST_TO_ADDR
// break ;
61188: GO 61192
// end ;
61190: GO 61010
61192: POP
61193: POP
// end ;
61194: LD_VAR 0 4
61198: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61199: LD_INT 0
61201: PPUSH
61202: PPUSH
61203: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61204: LD_EXP 115
61208: NOT
61209: PUSH
61210: LD_EXP 113
61214: NOT
61215: OR
61216: PUSH
61217: LD_VAR 0 3
61221: PUSH
61222: LD_EXP 141
61226: IN
61227: NOT
61228: OR
61229: IFFALSE 61233
// exit ;
61231: GO 61356
// for i = 1 to mc_vehicles do
61233: LD_ADDR_VAR 0 6
61237: PUSH
61238: DOUBLE
61239: LD_INT 1
61241: DEC
61242: ST_TO_ADDR
61243: LD_EXP 134
61247: PUSH
61248: FOR_TO
61249: IFFALSE 61354
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61251: LD_VAR 0 2
61255: PUSH
61256: LD_EXP 134
61260: PUSH
61261: LD_VAR 0 6
61265: ARRAY
61266: IN
61267: PUSH
61268: LD_VAR 0 1
61272: PUSH
61273: LD_EXP 134
61277: PUSH
61278: LD_VAR 0 6
61282: ARRAY
61283: IN
61284: OR
61285: IFFALSE 61352
// begin tmp := mc_vehicles [ i ] diff old ;
61287: LD_ADDR_VAR 0 7
61291: PUSH
61292: LD_EXP 134
61296: PUSH
61297: LD_VAR 0 6
61301: ARRAY
61302: PUSH
61303: LD_VAR 0 2
61307: DIFF
61308: ST_TO_ADDR
// tmp := tmp diff new ;
61309: LD_ADDR_VAR 0 7
61313: PUSH
61314: LD_VAR 0 7
61318: PUSH
61319: LD_VAR 0 1
61323: DIFF
61324: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61325: LD_ADDR_EXP 134
61329: PUSH
61330: LD_EXP 134
61334: PPUSH
61335: LD_VAR 0 6
61339: PPUSH
61340: LD_VAR 0 7
61344: PPUSH
61345: CALL_OW 1
61349: ST_TO_ADDR
// break ;
61350: GO 61354
// end ;
61352: GO 61248
61354: POP
61355: POP
// end ;
61356: LD_VAR 0 5
61360: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61361: LD_INT 0
61363: PPUSH
61364: PPUSH
61365: PPUSH
61366: PPUSH
// if not mc_bases or not skirmish then
61367: LD_EXP 115
61371: NOT
61372: PUSH
61373: LD_EXP 113
61377: NOT
61378: OR
61379: IFFALSE 61383
// exit ;
61381: GO 61766
// side := GetSide ( vehicle ) ;
61383: LD_ADDR_VAR 0 5
61387: PUSH
61388: LD_VAR 0 1
61392: PPUSH
61393: CALL_OW 255
61397: ST_TO_ADDR
// for i = 1 to mc_bases do
61398: LD_ADDR_VAR 0 4
61402: PUSH
61403: DOUBLE
61404: LD_INT 1
61406: DEC
61407: ST_TO_ADDR
61408: LD_EXP 115
61412: PUSH
61413: FOR_TO
61414: IFFALSE 61764
// begin if factory in mc_bases [ i ] then
61416: LD_VAR 0 2
61420: PUSH
61421: LD_EXP 115
61425: PUSH
61426: LD_VAR 0 4
61430: ARRAY
61431: IN
61432: IFFALSE 61762
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61434: LD_EXP 137
61438: PUSH
61439: LD_VAR 0 4
61443: ARRAY
61444: PUSH
61445: LD_EXP 126
61449: PUSH
61450: LD_VAR 0 4
61454: ARRAY
61455: LESS
61456: PUSH
61457: LD_VAR 0 1
61461: PPUSH
61462: CALL_OW 264
61466: PUSH
61467: LD_INT 31
61469: PUSH
61470: LD_INT 32
61472: PUSH
61473: LD_INT 51
61475: PUSH
61476: LD_EXP 96
61480: PUSH
61481: LD_INT 12
61483: PUSH
61484: LD_INT 30
61486: PUSH
61487: LD_EXP 95
61491: PUSH
61492: LD_INT 11
61494: PUSH
61495: LD_INT 53
61497: PUSH
61498: LD_INT 14
61500: PUSH
61501: LD_EXP 99
61505: PUSH
61506: LD_INT 29
61508: PUSH
61509: LD_EXP 97
61513: PUSH
61514: LD_INT 13
61516: PUSH
61517: LD_INT 52
61519: PUSH
61520: LD_EXP 101
61524: PUSH
61525: LD_INT 48
61527: PUSH
61528: LD_INT 8
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: LIST
61535: LIST
61536: LIST
61537: LIST
61538: LIST
61539: LIST
61540: LIST
61541: LIST
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: LIST
61547: LIST
61548: LIST
61549: LIST
61550: IN
61551: NOT
61552: AND
61553: IFFALSE 61601
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61555: LD_ADDR_EXP 137
61559: PUSH
61560: LD_EXP 137
61564: PPUSH
61565: LD_VAR 0 4
61569: PUSH
61570: LD_EXP 137
61574: PUSH
61575: LD_VAR 0 4
61579: ARRAY
61580: PUSH
61581: LD_INT 1
61583: PLUS
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: CALL 70353 0 3
61598: ST_TO_ADDR
61599: GO 61645
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61601: LD_ADDR_EXP 134
61605: PUSH
61606: LD_EXP 134
61610: PPUSH
61611: LD_VAR 0 4
61615: PUSH
61616: LD_EXP 134
61620: PUSH
61621: LD_VAR 0 4
61625: ARRAY
61626: PUSH
61627: LD_INT 1
61629: PLUS
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: PPUSH
61635: LD_VAR 0 1
61639: PPUSH
61640: CALL 70353 0 3
61644: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61645: LD_VAR 0 1
61649: PPUSH
61650: CALL_OW 263
61654: PUSH
61655: LD_INT 2
61657: EQUAL
61658: IFFALSE 61678
// begin repeat wait ( 0 0$1 ) ;
61660: LD_INT 35
61662: PPUSH
61663: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61667: LD_VAR 0 1
61671: PPUSH
61672: CALL_OW 312
61676: IFFALSE 61660
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61678: LD_VAR 0 1
61682: PPUSH
61683: LD_EXP 139
61687: PUSH
61688: LD_VAR 0 4
61692: ARRAY
61693: PPUSH
61694: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61698: LD_VAR 0 1
61702: PPUSH
61703: CALL_OW 263
61707: PUSH
61708: LD_INT 1
61710: NONEQUAL
61711: IFFALSE 61715
// break ;
61713: GO 61764
// repeat wait ( 0 0$1 ) ;
61715: LD_INT 35
61717: PPUSH
61718: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61722: LD_VAR 0 1
61726: PPUSH
61727: LD_EXP 139
61731: PUSH
61732: LD_VAR 0 4
61736: ARRAY
61737: PPUSH
61738: CALL_OW 308
61742: IFFALSE 61715
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61744: LD_VAR 0 1
61748: PPUSH
61749: CALL_OW 311
61753: PPUSH
61754: CALL_OW 121
// exit ;
61758: POP
61759: POP
61760: GO 61766
// end ; end ;
61762: GO 61413
61764: POP
61765: POP
// end ;
61766: LD_VAR 0 3
61770: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61771: LD_INT 0
61773: PPUSH
61774: PPUSH
61775: PPUSH
61776: PPUSH
// if not mc_bases or not skirmish then
61777: LD_EXP 115
61781: NOT
61782: PUSH
61783: LD_EXP 113
61787: NOT
61788: OR
61789: IFFALSE 61793
// exit ;
61791: GO 62146
// repeat wait ( 0 0$1 ) ;
61793: LD_INT 35
61795: PPUSH
61796: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61800: LD_VAR 0 2
61804: PPUSH
61805: LD_VAR 0 3
61809: PPUSH
61810: CALL_OW 284
61814: IFFALSE 61793
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61816: LD_VAR 0 2
61820: PPUSH
61821: LD_VAR 0 3
61825: PPUSH
61826: CALL_OW 283
61830: PUSH
61831: LD_INT 4
61833: EQUAL
61834: IFFALSE 61838
// exit ;
61836: GO 62146
// for i = 1 to mc_bases do
61838: LD_ADDR_VAR 0 7
61842: PUSH
61843: DOUBLE
61844: LD_INT 1
61846: DEC
61847: ST_TO_ADDR
61848: LD_EXP 115
61852: PUSH
61853: FOR_TO
61854: IFFALSE 62144
// begin if mc_crates_area [ i ] then
61856: LD_EXP 133
61860: PUSH
61861: LD_VAR 0 7
61865: ARRAY
61866: IFFALSE 61977
// for j in mc_crates_area [ i ] do
61868: LD_ADDR_VAR 0 8
61872: PUSH
61873: LD_EXP 133
61877: PUSH
61878: LD_VAR 0 7
61882: ARRAY
61883: PUSH
61884: FOR_IN
61885: IFFALSE 61975
// if InArea ( x , y , j ) then
61887: LD_VAR 0 2
61891: PPUSH
61892: LD_VAR 0 3
61896: PPUSH
61897: LD_VAR 0 8
61901: PPUSH
61902: CALL_OW 309
61906: IFFALSE 61973
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61908: LD_ADDR_EXP 131
61912: PUSH
61913: LD_EXP 131
61917: PPUSH
61918: LD_VAR 0 7
61922: PUSH
61923: LD_EXP 131
61927: PUSH
61928: LD_VAR 0 7
61932: ARRAY
61933: PUSH
61934: LD_INT 1
61936: PLUS
61937: PUSH
61938: EMPTY
61939: LIST
61940: LIST
61941: PPUSH
61942: LD_VAR 0 4
61946: PUSH
61947: LD_VAR 0 2
61951: PUSH
61952: LD_VAR 0 3
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL 70353 0 3
61966: ST_TO_ADDR
// exit ;
61967: POP
61968: POP
61969: POP
61970: POP
61971: GO 62146
// end ;
61973: GO 61884
61975: POP
61976: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61977: LD_ADDR_VAR 0 9
61981: PUSH
61982: LD_EXP 115
61986: PUSH
61987: LD_VAR 0 7
61991: ARRAY
61992: PPUSH
61993: LD_INT 2
61995: PUSH
61996: LD_INT 30
61998: PUSH
61999: LD_INT 0
62001: PUSH
62002: EMPTY
62003: LIST
62004: LIST
62005: PUSH
62006: LD_INT 30
62008: PUSH
62009: LD_INT 1
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: LIST
62020: PPUSH
62021: CALL_OW 72
62025: ST_TO_ADDR
// if not depot then
62026: LD_VAR 0 9
62030: NOT
62031: IFFALSE 62035
// continue ;
62033: GO 61853
// for j in depot do
62035: LD_ADDR_VAR 0 8
62039: PUSH
62040: LD_VAR 0 9
62044: PUSH
62045: FOR_IN
62046: IFFALSE 62140
// if GetDistUnitXY ( j , x , y ) < 30 then
62048: LD_VAR 0 8
62052: PPUSH
62053: LD_VAR 0 2
62057: PPUSH
62058: LD_VAR 0 3
62062: PPUSH
62063: CALL_OW 297
62067: PUSH
62068: LD_INT 30
62070: LESS
62071: IFFALSE 62138
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62073: LD_ADDR_EXP 131
62077: PUSH
62078: LD_EXP 131
62082: PPUSH
62083: LD_VAR 0 7
62087: PUSH
62088: LD_EXP 131
62092: PUSH
62093: LD_VAR 0 7
62097: ARRAY
62098: PUSH
62099: LD_INT 1
62101: PLUS
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PPUSH
62107: LD_VAR 0 4
62111: PUSH
62112: LD_VAR 0 2
62116: PUSH
62117: LD_VAR 0 3
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: LIST
62126: PPUSH
62127: CALL 70353 0 3
62131: ST_TO_ADDR
// exit ;
62132: POP
62133: POP
62134: POP
62135: POP
62136: GO 62146
// end ;
62138: GO 62045
62140: POP
62141: POP
// end ;
62142: GO 61853
62144: POP
62145: POP
// end ;
62146: LD_VAR 0 6
62150: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62151: LD_INT 0
62153: PPUSH
62154: PPUSH
62155: PPUSH
62156: PPUSH
// if not mc_bases or not skirmish then
62157: LD_EXP 115
62161: NOT
62162: PUSH
62163: LD_EXP 113
62167: NOT
62168: OR
62169: IFFALSE 62173
// exit ;
62171: GO 62450
// side := GetSide ( lab ) ;
62173: LD_ADDR_VAR 0 4
62177: PUSH
62178: LD_VAR 0 2
62182: PPUSH
62183: CALL_OW 255
62187: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62188: LD_VAR 0 4
62192: PUSH
62193: LD_EXP 141
62197: IN
62198: NOT
62199: PUSH
62200: LD_EXP 142
62204: NOT
62205: OR
62206: PUSH
62207: LD_EXP 115
62211: NOT
62212: OR
62213: IFFALSE 62217
// exit ;
62215: GO 62450
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62217: LD_ADDR_EXP 142
62221: PUSH
62222: LD_EXP 142
62226: PPUSH
62227: LD_VAR 0 4
62231: PPUSH
62232: LD_EXP 142
62236: PUSH
62237: LD_VAR 0 4
62241: ARRAY
62242: PUSH
62243: LD_VAR 0 1
62247: DIFF
62248: PPUSH
62249: CALL_OW 1
62253: ST_TO_ADDR
// for i = 1 to mc_bases do
62254: LD_ADDR_VAR 0 5
62258: PUSH
62259: DOUBLE
62260: LD_INT 1
62262: DEC
62263: ST_TO_ADDR
62264: LD_EXP 115
62268: PUSH
62269: FOR_TO
62270: IFFALSE 62448
// begin if lab in mc_bases [ i ] then
62272: LD_VAR 0 2
62276: PUSH
62277: LD_EXP 115
62281: PUSH
62282: LD_VAR 0 5
62286: ARRAY
62287: IN
62288: IFFALSE 62446
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62290: LD_VAR 0 1
62294: PUSH
62295: LD_INT 11
62297: PUSH
62298: LD_INT 4
62300: PUSH
62301: LD_INT 3
62303: PUSH
62304: LD_INT 2
62306: PUSH
62307: EMPTY
62308: LIST
62309: LIST
62310: LIST
62311: LIST
62312: IN
62313: PUSH
62314: LD_EXP 145
62318: PUSH
62319: LD_VAR 0 5
62323: ARRAY
62324: AND
62325: IFFALSE 62446
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62327: LD_ADDR_VAR 0 6
62331: PUSH
62332: LD_EXP 145
62336: PUSH
62337: LD_VAR 0 5
62341: ARRAY
62342: PUSH
62343: LD_INT 1
62345: ARRAY
62346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62347: LD_ADDR_EXP 145
62351: PUSH
62352: LD_EXP 145
62356: PPUSH
62357: LD_VAR 0 5
62361: PPUSH
62362: EMPTY
62363: PPUSH
62364: CALL_OW 1
62368: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62369: LD_VAR 0 6
62373: PPUSH
62374: LD_INT 0
62376: PPUSH
62377: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62381: LD_VAR 0 6
62385: PPUSH
62386: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62390: LD_ADDR_EXP 144
62394: PUSH
62395: LD_EXP 144
62399: PPUSH
62400: LD_VAR 0 5
62404: PPUSH
62405: LD_EXP 144
62409: PUSH
62410: LD_VAR 0 5
62414: ARRAY
62415: PPUSH
62416: LD_INT 1
62418: PPUSH
62419: LD_VAR 0 6
62423: PPUSH
62424: CALL_OW 2
62428: PPUSH
62429: CALL_OW 1
62433: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62434: LD_VAR 0 5
62438: PPUSH
62439: LD_INT 112
62441: PPUSH
62442: CALL 39279 0 2
// end ; end ; end ;
62446: GO 62269
62448: POP
62449: POP
// end ;
62450: LD_VAR 0 3
62454: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62455: LD_INT 0
62457: PPUSH
62458: PPUSH
62459: PPUSH
62460: PPUSH
62461: PPUSH
62462: PPUSH
62463: PPUSH
62464: PPUSH
// if not mc_bases or not skirmish then
62465: LD_EXP 115
62469: NOT
62470: PUSH
62471: LD_EXP 113
62475: NOT
62476: OR
62477: IFFALSE 62481
// exit ;
62479: GO 63852
// for i = 1 to mc_bases do
62481: LD_ADDR_VAR 0 3
62485: PUSH
62486: DOUBLE
62487: LD_INT 1
62489: DEC
62490: ST_TO_ADDR
62491: LD_EXP 115
62495: PUSH
62496: FOR_TO
62497: IFFALSE 63850
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62499: LD_VAR 0 1
62503: PUSH
62504: LD_EXP 115
62508: PUSH
62509: LD_VAR 0 3
62513: ARRAY
62514: IN
62515: PUSH
62516: LD_VAR 0 1
62520: PUSH
62521: LD_EXP 122
62525: PUSH
62526: LD_VAR 0 3
62530: ARRAY
62531: IN
62532: OR
62533: PUSH
62534: LD_VAR 0 1
62538: PUSH
62539: LD_EXP 137
62543: PUSH
62544: LD_VAR 0 3
62548: ARRAY
62549: IN
62550: OR
62551: PUSH
62552: LD_VAR 0 1
62556: PUSH
62557: LD_EXP 134
62561: PUSH
62562: LD_VAR 0 3
62566: ARRAY
62567: IN
62568: OR
62569: PUSH
62570: LD_VAR 0 1
62574: PUSH
62575: LD_EXP 144
62579: PUSH
62580: LD_VAR 0 3
62584: ARRAY
62585: IN
62586: OR
62587: PUSH
62588: LD_VAR 0 1
62592: PUSH
62593: LD_EXP 145
62597: PUSH
62598: LD_VAR 0 3
62602: ARRAY
62603: IN
62604: OR
62605: IFFALSE 63848
// begin if un in mc_ape [ i ] then
62607: LD_VAR 0 1
62611: PUSH
62612: LD_EXP 144
62616: PUSH
62617: LD_VAR 0 3
62621: ARRAY
62622: IN
62623: IFFALSE 62662
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62625: LD_ADDR_EXP 144
62629: PUSH
62630: LD_EXP 144
62634: PPUSH
62635: LD_VAR 0 3
62639: PPUSH
62640: LD_EXP 144
62644: PUSH
62645: LD_VAR 0 3
62649: ARRAY
62650: PUSH
62651: LD_VAR 0 1
62655: DIFF
62656: PPUSH
62657: CALL_OW 1
62661: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62662: LD_VAR 0 1
62666: PUSH
62667: LD_EXP 145
62671: PUSH
62672: LD_VAR 0 3
62676: ARRAY
62677: IN
62678: IFFALSE 62702
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62680: LD_ADDR_EXP 145
62684: PUSH
62685: LD_EXP 145
62689: PPUSH
62690: LD_VAR 0 3
62694: PPUSH
62695: EMPTY
62696: PPUSH
62697: CALL_OW 1
62701: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62702: LD_VAR 0 1
62706: PPUSH
62707: CALL_OW 247
62711: PUSH
62712: LD_INT 2
62714: EQUAL
62715: PUSH
62716: LD_VAR 0 1
62720: PPUSH
62721: CALL_OW 110
62725: PUSH
62726: LD_INT 20
62728: EQUAL
62729: PUSH
62730: LD_VAR 0 1
62734: PUSH
62735: LD_EXP 137
62739: PUSH
62740: LD_VAR 0 3
62744: ARRAY
62745: IN
62746: OR
62747: PUSH
62748: LD_VAR 0 1
62752: PPUSH
62753: CALL_OW 264
62757: PUSH
62758: LD_INT 12
62760: PUSH
62761: LD_INT 51
62763: PUSH
62764: LD_EXP 96
62768: PUSH
62769: LD_INT 32
62771: PUSH
62772: LD_INT 13
62774: PUSH
62775: LD_INT 52
62777: PUSH
62778: LD_INT 31
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: IN
62790: OR
62791: AND
62792: IFFALSE 63100
// begin if un in mc_defender [ i ] then
62794: LD_VAR 0 1
62798: PUSH
62799: LD_EXP 137
62803: PUSH
62804: LD_VAR 0 3
62808: ARRAY
62809: IN
62810: IFFALSE 62849
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62812: LD_ADDR_EXP 137
62816: PUSH
62817: LD_EXP 137
62821: PPUSH
62822: LD_VAR 0 3
62826: PPUSH
62827: LD_EXP 137
62831: PUSH
62832: LD_VAR 0 3
62836: ARRAY
62837: PUSH
62838: LD_VAR 0 1
62842: DIFF
62843: PPUSH
62844: CALL_OW 1
62848: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62849: LD_ADDR_VAR 0 8
62853: PUSH
62854: LD_VAR 0 3
62858: PPUSH
62859: LD_INT 3
62861: PPUSH
62862: CALL 59499 0 2
62866: ST_TO_ADDR
// if fac then
62867: LD_VAR 0 8
62871: IFFALSE 63100
// begin for j in fac do
62873: LD_ADDR_VAR 0 4
62877: PUSH
62878: LD_VAR 0 8
62882: PUSH
62883: FOR_IN
62884: IFFALSE 63098
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62886: LD_ADDR_VAR 0 9
62890: PUSH
62891: LD_VAR 0 8
62895: PPUSH
62896: LD_VAR 0 1
62900: PPUSH
62901: CALL_OW 265
62905: PPUSH
62906: LD_VAR 0 1
62910: PPUSH
62911: CALL_OW 262
62915: PPUSH
62916: LD_VAR 0 1
62920: PPUSH
62921: CALL_OW 263
62925: PPUSH
62926: LD_VAR 0 1
62930: PPUSH
62931: CALL_OW 264
62935: PPUSH
62936: CALL 67885 0 5
62940: ST_TO_ADDR
// if components then
62941: LD_VAR 0 9
62945: IFFALSE 63096
// begin if GetWeapon ( un ) = ar_control_tower then
62947: LD_VAR 0 1
62951: PPUSH
62952: CALL_OW 264
62956: PUSH
62957: LD_INT 31
62959: EQUAL
62960: IFFALSE 63077
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62962: LD_VAR 0 1
62966: PPUSH
62967: CALL_OW 311
62971: PPUSH
62972: LD_INT 0
62974: PPUSH
62975: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62979: LD_ADDR_EXP 155
62983: PUSH
62984: LD_EXP 155
62988: PPUSH
62989: LD_VAR 0 3
62993: PPUSH
62994: LD_EXP 155
62998: PUSH
62999: LD_VAR 0 3
63003: ARRAY
63004: PUSH
63005: LD_VAR 0 1
63009: PPUSH
63010: CALL_OW 311
63014: DIFF
63015: PPUSH
63016: CALL_OW 1
63020: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63021: LD_ADDR_VAR 0 7
63025: PUSH
63026: LD_EXP 136
63030: PUSH
63031: LD_VAR 0 3
63035: ARRAY
63036: PPUSH
63037: LD_INT 1
63039: PPUSH
63040: LD_VAR 0 9
63044: PPUSH
63045: CALL_OW 2
63049: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63050: LD_ADDR_EXP 136
63054: PUSH
63055: LD_EXP 136
63059: PPUSH
63060: LD_VAR 0 3
63064: PPUSH
63065: LD_VAR 0 7
63069: PPUSH
63070: CALL_OW 1
63074: ST_TO_ADDR
// end else
63075: GO 63094
// MC_InsertProduceList ( i , [ components ] ) ;
63077: LD_VAR 0 3
63081: PPUSH
63082: LD_VAR 0 9
63086: PUSH
63087: EMPTY
63088: LIST
63089: PPUSH
63090: CALL 59044 0 2
// break ;
63094: GO 63098
// end ; end ;
63096: GO 62883
63098: POP
63099: POP
// end ; end ; if GetType ( un ) = unit_building then
63100: LD_VAR 0 1
63104: PPUSH
63105: CALL_OW 247
63109: PUSH
63110: LD_INT 3
63112: EQUAL
63113: IFFALSE 63516
// begin btype := GetBType ( un ) ;
63115: LD_ADDR_VAR 0 5
63119: PUSH
63120: LD_VAR 0 1
63124: PPUSH
63125: CALL_OW 266
63129: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63130: LD_VAR 0 5
63134: PUSH
63135: LD_INT 29
63137: PUSH
63138: LD_INT 30
63140: PUSH
63141: EMPTY
63142: LIST
63143: LIST
63144: IN
63145: IFFALSE 63218
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63147: LD_VAR 0 1
63151: PPUSH
63152: CALL_OW 250
63156: PPUSH
63157: LD_VAR 0 1
63161: PPUSH
63162: CALL_OW 251
63166: PPUSH
63167: LD_VAR 0 1
63171: PPUSH
63172: CALL_OW 255
63176: PPUSH
63177: CALL_OW 440
63181: NOT
63182: IFFALSE 63218
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63184: LD_VAR 0 1
63188: PPUSH
63189: CALL_OW 250
63193: PPUSH
63194: LD_VAR 0 1
63198: PPUSH
63199: CALL_OW 251
63203: PPUSH
63204: LD_VAR 0 1
63208: PPUSH
63209: CALL_OW 255
63213: PPUSH
63214: CALL_OW 441
// end ; if btype = b_warehouse then
63218: LD_VAR 0 5
63222: PUSH
63223: LD_INT 1
63225: EQUAL
63226: IFFALSE 63244
// begin btype := b_depot ;
63228: LD_ADDR_VAR 0 5
63232: PUSH
63233: LD_INT 0
63235: ST_TO_ADDR
// pos := 1 ;
63236: LD_ADDR_VAR 0 6
63240: PUSH
63241: LD_INT 1
63243: ST_TO_ADDR
// end ; if btype = b_factory then
63244: LD_VAR 0 5
63248: PUSH
63249: LD_INT 3
63251: EQUAL
63252: IFFALSE 63270
// begin btype := b_workshop ;
63254: LD_ADDR_VAR 0 5
63258: PUSH
63259: LD_INT 2
63261: ST_TO_ADDR
// pos := 1 ;
63262: LD_ADDR_VAR 0 6
63266: PUSH
63267: LD_INT 1
63269: ST_TO_ADDR
// end ; if btype = b_barracks then
63270: LD_VAR 0 5
63274: PUSH
63275: LD_INT 5
63277: EQUAL
63278: IFFALSE 63288
// btype := b_armoury ;
63280: LD_ADDR_VAR 0 5
63284: PUSH
63285: LD_INT 4
63287: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63288: LD_VAR 0 5
63292: PUSH
63293: LD_INT 7
63295: PUSH
63296: LD_INT 8
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: IN
63303: IFFALSE 63313
// btype := b_lab ;
63305: LD_ADDR_VAR 0 5
63309: PUSH
63310: LD_INT 6
63312: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63313: LD_ADDR_EXP 120
63317: PUSH
63318: LD_EXP 120
63322: PPUSH
63323: LD_VAR 0 3
63327: PUSH
63328: LD_EXP 120
63332: PUSH
63333: LD_VAR 0 3
63337: ARRAY
63338: PUSH
63339: LD_INT 1
63341: PLUS
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PPUSH
63347: LD_VAR 0 5
63351: PUSH
63352: LD_VAR 0 1
63356: PPUSH
63357: CALL_OW 250
63361: PUSH
63362: LD_VAR 0 1
63366: PPUSH
63367: CALL_OW 251
63371: PUSH
63372: LD_VAR 0 1
63376: PPUSH
63377: CALL_OW 254
63381: PUSH
63382: EMPTY
63383: LIST
63384: LIST
63385: LIST
63386: LIST
63387: PPUSH
63388: CALL 70353 0 3
63392: ST_TO_ADDR
// if pos = 1 then
63393: LD_VAR 0 6
63397: PUSH
63398: LD_INT 1
63400: EQUAL
63401: IFFALSE 63516
// begin tmp := mc_build_list [ i ] ;
63403: LD_ADDR_VAR 0 7
63407: PUSH
63408: LD_EXP 120
63412: PUSH
63413: LD_VAR 0 3
63417: ARRAY
63418: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63419: LD_VAR 0 7
63423: PPUSH
63424: LD_INT 2
63426: PUSH
63427: LD_INT 30
63429: PUSH
63430: LD_INT 0
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 30
63439: PUSH
63440: LD_INT 1
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: LIST
63451: PPUSH
63452: CALL_OW 72
63456: IFFALSE 63466
// pos := 2 ;
63458: LD_ADDR_VAR 0 6
63462: PUSH
63463: LD_INT 2
63465: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63466: LD_ADDR_VAR 0 7
63470: PUSH
63471: LD_VAR 0 7
63475: PPUSH
63476: LD_VAR 0 6
63480: PPUSH
63481: LD_VAR 0 7
63485: PPUSH
63486: CALL 70679 0 3
63490: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63491: LD_ADDR_EXP 120
63495: PUSH
63496: LD_EXP 120
63500: PPUSH
63501: LD_VAR 0 3
63505: PPUSH
63506: LD_VAR 0 7
63510: PPUSH
63511: CALL_OW 1
63515: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63516: LD_VAR 0 1
63520: PUSH
63521: LD_EXP 115
63525: PUSH
63526: LD_VAR 0 3
63530: ARRAY
63531: IN
63532: IFFALSE 63571
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63534: LD_ADDR_EXP 115
63538: PUSH
63539: LD_EXP 115
63543: PPUSH
63544: LD_VAR 0 3
63548: PPUSH
63549: LD_EXP 115
63553: PUSH
63554: LD_VAR 0 3
63558: ARRAY
63559: PUSH
63560: LD_VAR 0 1
63564: DIFF
63565: PPUSH
63566: CALL_OW 1
63570: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63571: LD_VAR 0 1
63575: PUSH
63576: LD_EXP 122
63580: PUSH
63581: LD_VAR 0 3
63585: ARRAY
63586: IN
63587: IFFALSE 63626
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63589: LD_ADDR_EXP 122
63593: PUSH
63594: LD_EXP 122
63598: PPUSH
63599: LD_VAR 0 3
63603: PPUSH
63604: LD_EXP 122
63608: PUSH
63609: LD_VAR 0 3
63613: ARRAY
63614: PUSH
63615: LD_VAR 0 1
63619: DIFF
63620: PPUSH
63621: CALL_OW 1
63625: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63626: LD_VAR 0 1
63630: PUSH
63631: LD_EXP 134
63635: PUSH
63636: LD_VAR 0 3
63640: ARRAY
63641: IN
63642: IFFALSE 63681
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63644: LD_ADDR_EXP 134
63648: PUSH
63649: LD_EXP 134
63653: PPUSH
63654: LD_VAR 0 3
63658: PPUSH
63659: LD_EXP 134
63663: PUSH
63664: LD_VAR 0 3
63668: ARRAY
63669: PUSH
63670: LD_VAR 0 1
63674: DIFF
63675: PPUSH
63676: CALL_OW 1
63680: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63681: LD_VAR 0 1
63685: PUSH
63686: LD_EXP 137
63690: PUSH
63691: LD_VAR 0 3
63695: ARRAY
63696: IN
63697: IFFALSE 63736
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63699: LD_ADDR_EXP 137
63703: PUSH
63704: LD_EXP 137
63708: PPUSH
63709: LD_VAR 0 3
63713: PPUSH
63714: LD_EXP 137
63718: PUSH
63719: LD_VAR 0 3
63723: ARRAY
63724: PUSH
63725: LD_VAR 0 1
63729: DIFF
63730: PPUSH
63731: CALL_OW 1
63735: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63736: LD_VAR 0 1
63740: PUSH
63741: LD_EXP 124
63745: PUSH
63746: LD_VAR 0 3
63750: ARRAY
63751: IN
63752: IFFALSE 63791
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63754: LD_ADDR_EXP 124
63758: PUSH
63759: LD_EXP 124
63763: PPUSH
63764: LD_VAR 0 3
63768: PPUSH
63769: LD_EXP 124
63773: PUSH
63774: LD_VAR 0 3
63778: ARRAY
63779: PUSH
63780: LD_VAR 0 1
63784: DIFF
63785: PPUSH
63786: CALL_OW 1
63790: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63791: LD_VAR 0 1
63795: PUSH
63796: LD_EXP 123
63800: PUSH
63801: LD_VAR 0 3
63805: ARRAY
63806: IN
63807: IFFALSE 63846
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63809: LD_ADDR_EXP 123
63813: PUSH
63814: LD_EXP 123
63818: PPUSH
63819: LD_VAR 0 3
63823: PPUSH
63824: LD_EXP 123
63828: PUSH
63829: LD_VAR 0 3
63833: ARRAY
63834: PUSH
63835: LD_VAR 0 1
63839: DIFF
63840: PPUSH
63841: CALL_OW 1
63845: ST_TO_ADDR
// end ; break ;
63846: GO 63850
// end ;
63848: GO 62496
63850: POP
63851: POP
// end ;
63852: LD_VAR 0 2
63856: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63857: LD_INT 0
63859: PPUSH
63860: PPUSH
63861: PPUSH
// if not mc_bases or not skirmish then
63862: LD_EXP 115
63866: NOT
63867: PUSH
63868: LD_EXP 113
63872: NOT
63873: OR
63874: IFFALSE 63878
// exit ;
63876: GO 64093
// for i = 1 to mc_bases do
63878: LD_ADDR_VAR 0 3
63882: PUSH
63883: DOUBLE
63884: LD_INT 1
63886: DEC
63887: ST_TO_ADDR
63888: LD_EXP 115
63892: PUSH
63893: FOR_TO
63894: IFFALSE 64091
// begin if building in mc_construct_list [ i ] then
63896: LD_VAR 0 1
63900: PUSH
63901: LD_EXP 122
63905: PUSH
63906: LD_VAR 0 3
63910: ARRAY
63911: IN
63912: IFFALSE 64089
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63914: LD_ADDR_EXP 122
63918: PUSH
63919: LD_EXP 122
63923: PPUSH
63924: LD_VAR 0 3
63928: PPUSH
63929: LD_EXP 122
63933: PUSH
63934: LD_VAR 0 3
63938: ARRAY
63939: PUSH
63940: LD_VAR 0 1
63944: DIFF
63945: PPUSH
63946: CALL_OW 1
63950: ST_TO_ADDR
// if building in mc_lab [ i ] then
63951: LD_VAR 0 1
63955: PUSH
63956: LD_EXP 148
63960: PUSH
63961: LD_VAR 0 3
63965: ARRAY
63966: IN
63967: IFFALSE 64022
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63969: LD_ADDR_EXP 149
63973: PUSH
63974: LD_EXP 149
63978: PPUSH
63979: LD_VAR 0 3
63983: PPUSH
63984: LD_EXP 149
63988: PUSH
63989: LD_VAR 0 3
63993: ARRAY
63994: PPUSH
63995: LD_INT 1
63997: PPUSH
63998: LD_EXP 149
64002: PUSH
64003: LD_VAR 0 3
64007: ARRAY
64008: PPUSH
64009: LD_INT 0
64011: PPUSH
64012: CALL 69771 0 4
64016: PPUSH
64017: CALL_OW 1
64021: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64022: LD_VAR 0 1
64026: PUSH
64027: LD_EXP 115
64031: PUSH
64032: LD_VAR 0 3
64036: ARRAY
64037: IN
64038: NOT
64039: IFFALSE 64085
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64041: LD_ADDR_EXP 115
64045: PUSH
64046: LD_EXP 115
64050: PPUSH
64051: LD_VAR 0 3
64055: PUSH
64056: LD_EXP 115
64060: PUSH
64061: LD_VAR 0 3
64065: ARRAY
64066: PUSH
64067: LD_INT 1
64069: PLUS
64070: PUSH
64071: EMPTY
64072: LIST
64073: LIST
64074: PPUSH
64075: LD_VAR 0 1
64079: PPUSH
64080: CALL 70353 0 3
64084: ST_TO_ADDR
// exit ;
64085: POP
64086: POP
64087: GO 64093
// end ; end ;
64089: GO 63893
64091: POP
64092: POP
// end ;
64093: LD_VAR 0 2
64097: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64098: LD_INT 0
64100: PPUSH
64101: PPUSH
64102: PPUSH
64103: PPUSH
64104: PPUSH
64105: PPUSH
64106: PPUSH
// if not mc_bases or not skirmish then
64107: LD_EXP 115
64111: NOT
64112: PUSH
64113: LD_EXP 113
64117: NOT
64118: OR
64119: IFFALSE 64123
// exit ;
64121: GO 64784
// for i = 1 to mc_bases do
64123: LD_ADDR_VAR 0 3
64127: PUSH
64128: DOUBLE
64129: LD_INT 1
64131: DEC
64132: ST_TO_ADDR
64133: LD_EXP 115
64137: PUSH
64138: FOR_TO
64139: IFFALSE 64782
// begin if building in mc_construct_list [ i ] then
64141: LD_VAR 0 1
64145: PUSH
64146: LD_EXP 122
64150: PUSH
64151: LD_VAR 0 3
64155: ARRAY
64156: IN
64157: IFFALSE 64780
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64159: LD_ADDR_EXP 122
64163: PUSH
64164: LD_EXP 122
64168: PPUSH
64169: LD_VAR 0 3
64173: PPUSH
64174: LD_EXP 122
64178: PUSH
64179: LD_VAR 0 3
64183: ARRAY
64184: PUSH
64185: LD_VAR 0 1
64189: DIFF
64190: PPUSH
64191: CALL_OW 1
64195: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64196: LD_ADDR_EXP 115
64200: PUSH
64201: LD_EXP 115
64205: PPUSH
64206: LD_VAR 0 3
64210: PUSH
64211: LD_EXP 115
64215: PUSH
64216: LD_VAR 0 3
64220: ARRAY
64221: PUSH
64222: LD_INT 1
64224: PLUS
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PPUSH
64230: LD_VAR 0 1
64234: PPUSH
64235: CALL 70353 0 3
64239: ST_TO_ADDR
// btype := GetBType ( building ) ;
64240: LD_ADDR_VAR 0 5
64244: PUSH
64245: LD_VAR 0 1
64249: PPUSH
64250: CALL_OW 266
64254: ST_TO_ADDR
// side := GetSide ( building ) ;
64255: LD_ADDR_VAR 0 8
64259: PUSH
64260: LD_VAR 0 1
64264: PPUSH
64265: CALL_OW 255
64269: ST_TO_ADDR
// if btype = b_lab then
64270: LD_VAR 0 5
64274: PUSH
64275: LD_INT 6
64277: EQUAL
64278: IFFALSE 64328
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64280: LD_ADDR_EXP 148
64284: PUSH
64285: LD_EXP 148
64289: PPUSH
64290: LD_VAR 0 3
64294: PUSH
64295: LD_EXP 148
64299: PUSH
64300: LD_VAR 0 3
64304: ARRAY
64305: PUSH
64306: LD_INT 1
64308: PLUS
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PPUSH
64314: LD_VAR 0 1
64318: PPUSH
64319: CALL 70353 0 3
64323: ST_TO_ADDR
// exit ;
64324: POP
64325: POP
64326: GO 64784
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64328: LD_VAR 0 5
64332: PUSH
64333: LD_INT 0
64335: PUSH
64336: LD_INT 2
64338: PUSH
64339: LD_INT 4
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: LIST
64346: IN
64347: IFFALSE 64471
// begin if btype = b_armoury then
64349: LD_VAR 0 5
64353: PUSH
64354: LD_INT 4
64356: EQUAL
64357: IFFALSE 64367
// btype := b_barracks ;
64359: LD_ADDR_VAR 0 5
64363: PUSH
64364: LD_INT 5
64366: ST_TO_ADDR
// if btype = b_depot then
64367: LD_VAR 0 5
64371: PUSH
64372: LD_INT 0
64374: EQUAL
64375: IFFALSE 64385
// btype := b_warehouse ;
64377: LD_ADDR_VAR 0 5
64381: PUSH
64382: LD_INT 1
64384: ST_TO_ADDR
// if btype = b_workshop then
64385: LD_VAR 0 5
64389: PUSH
64390: LD_INT 2
64392: EQUAL
64393: IFFALSE 64403
// btype := b_factory ;
64395: LD_ADDR_VAR 0 5
64399: PUSH
64400: LD_INT 3
64402: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64403: LD_VAR 0 5
64407: PPUSH
64408: LD_VAR 0 8
64412: PPUSH
64413: CALL_OW 323
64417: PUSH
64418: LD_INT 1
64420: EQUAL
64421: IFFALSE 64467
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64423: LD_ADDR_EXP 147
64427: PUSH
64428: LD_EXP 147
64432: PPUSH
64433: LD_VAR 0 3
64437: PUSH
64438: LD_EXP 147
64442: PUSH
64443: LD_VAR 0 3
64447: ARRAY
64448: PUSH
64449: LD_INT 1
64451: PLUS
64452: PUSH
64453: EMPTY
64454: LIST
64455: LIST
64456: PPUSH
64457: LD_VAR 0 1
64461: PPUSH
64462: CALL 70353 0 3
64466: ST_TO_ADDR
// exit ;
64467: POP
64468: POP
64469: GO 64784
// end ; if btype in [ b_bunker , b_turret ] then
64471: LD_VAR 0 5
64475: PUSH
64476: LD_INT 32
64478: PUSH
64479: LD_INT 33
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: IN
64486: IFFALSE 64776
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64488: LD_ADDR_EXP 123
64492: PUSH
64493: LD_EXP 123
64497: PPUSH
64498: LD_VAR 0 3
64502: PUSH
64503: LD_EXP 123
64507: PUSH
64508: LD_VAR 0 3
64512: ARRAY
64513: PUSH
64514: LD_INT 1
64516: PLUS
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PPUSH
64522: LD_VAR 0 1
64526: PPUSH
64527: CALL 70353 0 3
64531: ST_TO_ADDR
// if btype = b_bunker then
64532: LD_VAR 0 5
64536: PUSH
64537: LD_INT 32
64539: EQUAL
64540: IFFALSE 64776
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64542: LD_ADDR_EXP 124
64546: PUSH
64547: LD_EXP 124
64551: PPUSH
64552: LD_VAR 0 3
64556: PUSH
64557: LD_EXP 124
64561: PUSH
64562: LD_VAR 0 3
64566: ARRAY
64567: PUSH
64568: LD_INT 1
64570: PLUS
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: PPUSH
64576: LD_VAR 0 1
64580: PPUSH
64581: CALL 70353 0 3
64585: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64586: LD_ADDR_VAR 0 6
64590: PUSH
64591: LD_EXP 115
64595: PUSH
64596: LD_VAR 0 3
64600: ARRAY
64601: PPUSH
64602: LD_INT 25
64604: PUSH
64605: LD_INT 1
64607: PUSH
64608: EMPTY
64609: LIST
64610: LIST
64611: PUSH
64612: LD_INT 3
64614: PUSH
64615: LD_INT 54
64617: PUSH
64618: EMPTY
64619: LIST
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PPUSH
64629: CALL_OW 72
64633: ST_TO_ADDR
// if tmp then
64634: LD_VAR 0 6
64638: IFFALSE 64644
// exit ;
64640: POP
64641: POP
64642: GO 64784
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64644: LD_ADDR_VAR 0 6
64648: PUSH
64649: LD_EXP 115
64653: PUSH
64654: LD_VAR 0 3
64658: ARRAY
64659: PPUSH
64660: LD_INT 2
64662: PUSH
64663: LD_INT 30
64665: PUSH
64666: LD_INT 4
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 30
64675: PUSH
64676: LD_INT 5
64678: PUSH
64679: EMPTY
64680: LIST
64681: LIST
64682: PUSH
64683: EMPTY
64684: LIST
64685: LIST
64686: LIST
64687: PPUSH
64688: CALL_OW 72
64692: ST_TO_ADDR
// if not tmp then
64693: LD_VAR 0 6
64697: NOT
64698: IFFALSE 64704
// exit ;
64700: POP
64701: POP
64702: GO 64784
// for j in tmp do
64704: LD_ADDR_VAR 0 4
64708: PUSH
64709: LD_VAR 0 6
64713: PUSH
64714: FOR_IN
64715: IFFALSE 64774
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64717: LD_ADDR_VAR 0 7
64721: PUSH
64722: LD_VAR 0 4
64726: PPUSH
64727: CALL_OW 313
64731: PPUSH
64732: LD_INT 25
64734: PUSH
64735: LD_INT 1
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PPUSH
64742: CALL_OW 72
64746: ST_TO_ADDR
// if units then
64747: LD_VAR 0 7
64751: IFFALSE 64772
// begin ComExitBuilding ( units [ 1 ] ) ;
64753: LD_VAR 0 7
64757: PUSH
64758: LD_INT 1
64760: ARRAY
64761: PPUSH
64762: CALL_OW 122
// exit ;
64766: POP
64767: POP
64768: POP
64769: POP
64770: GO 64784
// end ; end ;
64772: GO 64714
64774: POP
64775: POP
// end ; end ; exit ;
64776: POP
64777: POP
64778: GO 64784
// end ; end ;
64780: GO 64138
64782: POP
64783: POP
// end ;
64784: LD_VAR 0 2
64788: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64789: LD_INT 0
64791: PPUSH
64792: PPUSH
64793: PPUSH
64794: PPUSH
64795: PPUSH
64796: PPUSH
64797: PPUSH
// if not mc_bases or not skirmish then
64798: LD_EXP 115
64802: NOT
64803: PUSH
64804: LD_EXP 113
64808: NOT
64809: OR
64810: IFFALSE 64814
// exit ;
64812: GO 65045
// btype := GetBType ( building ) ;
64814: LD_ADDR_VAR 0 6
64818: PUSH
64819: LD_VAR 0 1
64823: PPUSH
64824: CALL_OW 266
64828: ST_TO_ADDR
// x := GetX ( building ) ;
64829: LD_ADDR_VAR 0 7
64833: PUSH
64834: LD_VAR 0 1
64838: PPUSH
64839: CALL_OW 250
64843: ST_TO_ADDR
// y := GetY ( building ) ;
64844: LD_ADDR_VAR 0 8
64848: PUSH
64849: LD_VAR 0 1
64853: PPUSH
64854: CALL_OW 251
64858: ST_TO_ADDR
// d := GetDir ( building ) ;
64859: LD_ADDR_VAR 0 9
64863: PUSH
64864: LD_VAR 0 1
64868: PPUSH
64869: CALL_OW 254
64873: ST_TO_ADDR
// for i = 1 to mc_bases do
64874: LD_ADDR_VAR 0 4
64878: PUSH
64879: DOUBLE
64880: LD_INT 1
64882: DEC
64883: ST_TO_ADDR
64884: LD_EXP 115
64888: PUSH
64889: FOR_TO
64890: IFFALSE 65043
// begin if not mc_build_list [ i ] then
64892: LD_EXP 120
64896: PUSH
64897: LD_VAR 0 4
64901: ARRAY
64902: NOT
64903: IFFALSE 64907
// continue ;
64905: GO 64889
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64907: LD_VAR 0 6
64911: PUSH
64912: LD_VAR 0 7
64916: PUSH
64917: LD_VAR 0 8
64921: PUSH
64922: LD_VAR 0 9
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: PPUSH
64933: LD_EXP 120
64937: PUSH
64938: LD_VAR 0 4
64942: ARRAY
64943: PUSH
64944: LD_INT 1
64946: ARRAY
64947: PPUSH
64948: CALL 76560 0 2
64952: IFFALSE 65041
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64954: LD_ADDR_EXP 120
64958: PUSH
64959: LD_EXP 120
64963: PPUSH
64964: LD_VAR 0 4
64968: PPUSH
64969: LD_EXP 120
64973: PUSH
64974: LD_VAR 0 4
64978: ARRAY
64979: PPUSH
64980: LD_INT 1
64982: PPUSH
64983: CALL_OW 3
64987: PPUSH
64988: CALL_OW 1
64992: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64993: LD_ADDR_EXP 122
64997: PUSH
64998: LD_EXP 122
65002: PPUSH
65003: LD_VAR 0 4
65007: PUSH
65008: LD_EXP 122
65012: PUSH
65013: LD_VAR 0 4
65017: ARRAY
65018: PUSH
65019: LD_INT 1
65021: PLUS
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PPUSH
65027: LD_VAR 0 1
65031: PPUSH
65032: CALL 70353 0 3
65036: ST_TO_ADDR
// exit ;
65037: POP
65038: POP
65039: GO 65045
// end ; end ;
65041: GO 64889
65043: POP
65044: POP
// end ;
65045: LD_VAR 0 3
65049: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65050: LD_INT 0
65052: PPUSH
65053: PPUSH
65054: PPUSH
// if not mc_bases or not skirmish then
65055: LD_EXP 115
65059: NOT
65060: PUSH
65061: LD_EXP 113
65065: NOT
65066: OR
65067: IFFALSE 65071
// exit ;
65069: GO 65261
// for i = 1 to mc_bases do
65071: LD_ADDR_VAR 0 4
65075: PUSH
65076: DOUBLE
65077: LD_INT 1
65079: DEC
65080: ST_TO_ADDR
65081: LD_EXP 115
65085: PUSH
65086: FOR_TO
65087: IFFALSE 65174
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65089: LD_VAR 0 1
65093: PUSH
65094: LD_EXP 123
65098: PUSH
65099: LD_VAR 0 4
65103: ARRAY
65104: IN
65105: PUSH
65106: LD_VAR 0 1
65110: PUSH
65111: LD_EXP 124
65115: PUSH
65116: LD_VAR 0 4
65120: ARRAY
65121: IN
65122: NOT
65123: AND
65124: IFFALSE 65172
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65126: LD_ADDR_EXP 124
65130: PUSH
65131: LD_EXP 124
65135: PPUSH
65136: LD_VAR 0 4
65140: PUSH
65141: LD_EXP 124
65145: PUSH
65146: LD_VAR 0 4
65150: ARRAY
65151: PUSH
65152: LD_INT 1
65154: PLUS
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PPUSH
65160: LD_VAR 0 1
65164: PPUSH
65165: CALL 70353 0 3
65169: ST_TO_ADDR
// break ;
65170: GO 65174
// end ; end ;
65172: GO 65086
65174: POP
65175: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65176: LD_VAR 0 1
65180: PPUSH
65181: CALL_OW 257
65185: PUSH
65186: LD_EXP 141
65190: IN
65191: PUSH
65192: LD_VAR 0 1
65196: PPUSH
65197: CALL_OW 266
65201: PUSH
65202: LD_INT 5
65204: EQUAL
65205: AND
65206: PUSH
65207: LD_VAR 0 2
65211: PPUSH
65212: CALL_OW 110
65216: PUSH
65217: LD_INT 18
65219: NONEQUAL
65220: AND
65221: IFFALSE 65261
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65223: LD_VAR 0 2
65227: PPUSH
65228: CALL_OW 257
65232: PUSH
65233: LD_INT 5
65235: PUSH
65236: LD_INT 8
65238: PUSH
65239: LD_INT 9
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: LIST
65246: IN
65247: IFFALSE 65261
// SetClass ( unit , 1 ) ;
65249: LD_VAR 0 2
65253: PPUSH
65254: LD_INT 1
65256: PPUSH
65257: CALL_OW 336
// end ;
65261: LD_VAR 0 3
65265: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65266: LD_INT 0
65268: PPUSH
65269: PPUSH
// if not mc_bases or not skirmish then
65270: LD_EXP 115
65274: NOT
65275: PUSH
65276: LD_EXP 113
65280: NOT
65281: OR
65282: IFFALSE 65286
// exit ;
65284: GO 65402
// if GetLives ( abandoned_vehicle ) > 250 then
65286: LD_VAR 0 2
65290: PPUSH
65291: CALL_OW 256
65295: PUSH
65296: LD_INT 250
65298: GREATER
65299: IFFALSE 65303
// exit ;
65301: GO 65402
// for i = 1 to mc_bases do
65303: LD_ADDR_VAR 0 6
65307: PUSH
65308: DOUBLE
65309: LD_INT 1
65311: DEC
65312: ST_TO_ADDR
65313: LD_EXP 115
65317: PUSH
65318: FOR_TO
65319: IFFALSE 65400
// begin if driver in mc_bases [ i ] then
65321: LD_VAR 0 1
65325: PUSH
65326: LD_EXP 115
65330: PUSH
65331: LD_VAR 0 6
65335: ARRAY
65336: IN
65337: IFFALSE 65398
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65339: LD_VAR 0 1
65343: PPUSH
65344: LD_EXP 115
65348: PUSH
65349: LD_VAR 0 6
65353: ARRAY
65354: PPUSH
65355: LD_INT 2
65357: PUSH
65358: LD_INT 30
65360: PUSH
65361: LD_INT 0
65363: PUSH
65364: EMPTY
65365: LIST
65366: LIST
65367: PUSH
65368: LD_INT 30
65370: PUSH
65371: LD_INT 1
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: LIST
65382: PPUSH
65383: CALL_OW 72
65387: PUSH
65388: LD_INT 1
65390: ARRAY
65391: PPUSH
65392: CALL 102596 0 2
// break ;
65396: GO 65400
// end ; end ;
65398: GO 65318
65400: POP
65401: POP
// end ; end_of_file
65402: LD_VAR 0 5
65406: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65407: LD_INT 0
65409: PPUSH
65410: PPUSH
// if exist_mode then
65411: LD_VAR 0 2
65415: IFFALSE 65440
// unit := CreateCharacter ( prefix & ident ) else
65417: LD_ADDR_VAR 0 5
65421: PUSH
65422: LD_VAR 0 3
65426: PUSH
65427: LD_VAR 0 1
65431: STR
65432: PPUSH
65433: CALL_OW 34
65437: ST_TO_ADDR
65438: GO 65455
// unit := NewCharacter ( ident ) ;
65440: LD_ADDR_VAR 0 5
65444: PUSH
65445: LD_VAR 0 1
65449: PPUSH
65450: CALL_OW 25
65454: ST_TO_ADDR
// result := unit ;
65455: LD_ADDR_VAR 0 4
65459: PUSH
65460: LD_VAR 0 5
65464: ST_TO_ADDR
// end ;
65465: LD_VAR 0 4
65469: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65470: LD_INT 0
65472: PPUSH
65473: PPUSH
// if not side or not nation then
65474: LD_VAR 0 1
65478: NOT
65479: PUSH
65480: LD_VAR 0 2
65484: NOT
65485: OR
65486: IFFALSE 65490
// exit ;
65488: GO 66254
// case nation of nation_american :
65490: LD_VAR 0 2
65494: PUSH
65495: LD_INT 1
65497: DOUBLE
65498: EQUAL
65499: IFTRUE 65503
65501: GO 65717
65503: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65504: LD_ADDR_VAR 0 4
65508: PUSH
65509: LD_INT 35
65511: PUSH
65512: LD_INT 45
65514: PUSH
65515: LD_INT 46
65517: PUSH
65518: LD_INT 47
65520: PUSH
65521: LD_INT 82
65523: PUSH
65524: LD_INT 83
65526: PUSH
65527: LD_INT 84
65529: PUSH
65530: LD_INT 85
65532: PUSH
65533: LD_INT 86
65535: PUSH
65536: LD_INT 1
65538: PUSH
65539: LD_INT 2
65541: PUSH
65542: LD_INT 6
65544: PUSH
65545: LD_INT 15
65547: PUSH
65548: LD_INT 16
65550: PUSH
65551: LD_INT 7
65553: PUSH
65554: LD_INT 12
65556: PUSH
65557: LD_INT 13
65559: PUSH
65560: LD_INT 10
65562: PUSH
65563: LD_INT 14
65565: PUSH
65566: LD_INT 20
65568: PUSH
65569: LD_INT 21
65571: PUSH
65572: LD_INT 22
65574: PUSH
65575: LD_INT 25
65577: PUSH
65578: LD_INT 32
65580: PUSH
65581: LD_INT 27
65583: PUSH
65584: LD_INT 36
65586: PUSH
65587: LD_INT 69
65589: PUSH
65590: LD_INT 39
65592: PUSH
65593: LD_INT 34
65595: PUSH
65596: LD_INT 40
65598: PUSH
65599: LD_INT 48
65601: PUSH
65602: LD_INT 49
65604: PUSH
65605: LD_INT 50
65607: PUSH
65608: LD_INT 51
65610: PUSH
65611: LD_INT 52
65613: PUSH
65614: LD_INT 53
65616: PUSH
65617: LD_INT 54
65619: PUSH
65620: LD_INT 55
65622: PUSH
65623: LD_INT 56
65625: PUSH
65626: LD_INT 57
65628: PUSH
65629: LD_INT 58
65631: PUSH
65632: LD_INT 59
65634: PUSH
65635: LD_INT 60
65637: PUSH
65638: LD_INT 61
65640: PUSH
65641: LD_INT 62
65643: PUSH
65644: LD_INT 80
65646: PUSH
65647: LD_INT 82
65649: PUSH
65650: LD_INT 83
65652: PUSH
65653: LD_INT 84
65655: PUSH
65656: LD_INT 85
65658: PUSH
65659: LD_INT 86
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: ST_TO_ADDR
65715: GO 66178
65717: LD_INT 2
65719: DOUBLE
65720: EQUAL
65721: IFTRUE 65725
65723: GO 65947
65725: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65726: LD_ADDR_VAR 0 4
65730: PUSH
65731: LD_INT 35
65733: PUSH
65734: LD_INT 45
65736: PUSH
65737: LD_INT 46
65739: PUSH
65740: LD_INT 47
65742: PUSH
65743: LD_INT 82
65745: PUSH
65746: LD_INT 83
65748: PUSH
65749: LD_INT 84
65751: PUSH
65752: LD_INT 85
65754: PUSH
65755: LD_INT 87
65757: PUSH
65758: LD_INT 70
65760: PUSH
65761: LD_INT 1
65763: PUSH
65764: LD_INT 11
65766: PUSH
65767: LD_INT 3
65769: PUSH
65770: LD_INT 4
65772: PUSH
65773: LD_INT 5
65775: PUSH
65776: LD_INT 6
65778: PUSH
65779: LD_INT 15
65781: PUSH
65782: LD_INT 18
65784: PUSH
65785: LD_INT 7
65787: PUSH
65788: LD_INT 17
65790: PUSH
65791: LD_INT 8
65793: PUSH
65794: LD_INT 20
65796: PUSH
65797: LD_INT 21
65799: PUSH
65800: LD_INT 22
65802: PUSH
65803: LD_INT 72
65805: PUSH
65806: LD_INT 26
65808: PUSH
65809: LD_INT 69
65811: PUSH
65812: LD_INT 39
65814: PUSH
65815: LD_INT 40
65817: PUSH
65818: LD_INT 41
65820: PUSH
65821: LD_INT 42
65823: PUSH
65824: LD_INT 43
65826: PUSH
65827: LD_INT 48
65829: PUSH
65830: LD_INT 49
65832: PUSH
65833: LD_INT 50
65835: PUSH
65836: LD_INT 51
65838: PUSH
65839: LD_INT 52
65841: PUSH
65842: LD_INT 53
65844: PUSH
65845: LD_INT 54
65847: PUSH
65848: LD_INT 55
65850: PUSH
65851: LD_INT 56
65853: PUSH
65854: LD_INT 60
65856: PUSH
65857: LD_INT 61
65859: PUSH
65860: LD_INT 62
65862: PUSH
65863: LD_INT 66
65865: PUSH
65866: LD_INT 67
65868: PUSH
65869: LD_INT 68
65871: PUSH
65872: LD_INT 81
65874: PUSH
65875: LD_INT 82
65877: PUSH
65878: LD_INT 83
65880: PUSH
65881: LD_INT 84
65883: PUSH
65884: LD_INT 85
65886: PUSH
65887: LD_INT 87
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: ST_TO_ADDR
65945: GO 66178
65947: LD_INT 3
65949: DOUBLE
65950: EQUAL
65951: IFTRUE 65955
65953: GO 66177
65955: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65956: LD_ADDR_VAR 0 4
65960: PUSH
65961: LD_INT 46
65963: PUSH
65964: LD_INT 47
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: LD_INT 2
65972: PUSH
65973: LD_INT 82
65975: PUSH
65976: LD_INT 83
65978: PUSH
65979: LD_INT 84
65981: PUSH
65982: LD_INT 85
65984: PUSH
65985: LD_INT 86
65987: PUSH
65988: LD_INT 11
65990: PUSH
65991: LD_INT 9
65993: PUSH
65994: LD_INT 20
65996: PUSH
65997: LD_INT 19
65999: PUSH
66000: LD_INT 21
66002: PUSH
66003: LD_INT 24
66005: PUSH
66006: LD_INT 22
66008: PUSH
66009: LD_INT 25
66011: PUSH
66012: LD_INT 28
66014: PUSH
66015: LD_INT 29
66017: PUSH
66018: LD_INT 30
66020: PUSH
66021: LD_INT 31
66023: PUSH
66024: LD_INT 37
66026: PUSH
66027: LD_INT 38
66029: PUSH
66030: LD_INT 32
66032: PUSH
66033: LD_INT 27
66035: PUSH
66036: LD_INT 33
66038: PUSH
66039: LD_INT 69
66041: PUSH
66042: LD_INT 39
66044: PUSH
66045: LD_INT 34
66047: PUSH
66048: LD_INT 40
66050: PUSH
66051: LD_INT 71
66053: PUSH
66054: LD_INT 23
66056: PUSH
66057: LD_INT 44
66059: PUSH
66060: LD_INT 48
66062: PUSH
66063: LD_INT 49
66065: PUSH
66066: LD_INT 50
66068: PUSH
66069: LD_INT 51
66071: PUSH
66072: LD_INT 52
66074: PUSH
66075: LD_INT 53
66077: PUSH
66078: LD_INT 54
66080: PUSH
66081: LD_INT 55
66083: PUSH
66084: LD_INT 56
66086: PUSH
66087: LD_INT 57
66089: PUSH
66090: LD_INT 58
66092: PUSH
66093: LD_INT 59
66095: PUSH
66096: LD_INT 63
66098: PUSH
66099: LD_INT 64
66101: PUSH
66102: LD_INT 65
66104: PUSH
66105: LD_INT 82
66107: PUSH
66108: LD_INT 83
66110: PUSH
66111: LD_INT 84
66113: PUSH
66114: LD_INT 85
66116: PUSH
66117: LD_INT 86
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: LIST
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: ST_TO_ADDR
66175: GO 66178
66177: POP
// if state > - 1 and state < 3 then
66178: LD_VAR 0 3
66182: PUSH
66183: LD_INT 1
66185: NEG
66186: GREATER
66187: PUSH
66188: LD_VAR 0 3
66192: PUSH
66193: LD_INT 3
66195: LESS
66196: AND
66197: IFFALSE 66254
// for i in result do
66199: LD_ADDR_VAR 0 5
66203: PUSH
66204: LD_VAR 0 4
66208: PUSH
66209: FOR_IN
66210: IFFALSE 66252
// if GetTech ( i , side ) <> state then
66212: LD_VAR 0 5
66216: PPUSH
66217: LD_VAR 0 1
66221: PPUSH
66222: CALL_OW 321
66226: PUSH
66227: LD_VAR 0 3
66231: NONEQUAL
66232: IFFALSE 66250
// result := result diff i ;
66234: LD_ADDR_VAR 0 4
66238: PUSH
66239: LD_VAR 0 4
66243: PUSH
66244: LD_VAR 0 5
66248: DIFF
66249: ST_TO_ADDR
66250: GO 66209
66252: POP
66253: POP
// end ;
66254: LD_VAR 0 4
66258: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66259: LD_INT 0
66261: PPUSH
66262: PPUSH
66263: PPUSH
// result := true ;
66264: LD_ADDR_VAR 0 3
66268: PUSH
66269: LD_INT 1
66271: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66272: LD_ADDR_VAR 0 5
66276: PUSH
66277: LD_VAR 0 2
66281: PPUSH
66282: CALL_OW 480
66286: ST_TO_ADDR
// if not tmp then
66287: LD_VAR 0 5
66291: NOT
66292: IFFALSE 66296
// exit ;
66294: GO 66345
// for i in tmp do
66296: LD_ADDR_VAR 0 4
66300: PUSH
66301: LD_VAR 0 5
66305: PUSH
66306: FOR_IN
66307: IFFALSE 66343
// if GetTech ( i , side ) <> state_researched then
66309: LD_VAR 0 4
66313: PPUSH
66314: LD_VAR 0 1
66318: PPUSH
66319: CALL_OW 321
66323: PUSH
66324: LD_INT 2
66326: NONEQUAL
66327: IFFALSE 66341
// begin result := false ;
66329: LD_ADDR_VAR 0 3
66333: PUSH
66334: LD_INT 0
66336: ST_TO_ADDR
// exit ;
66337: POP
66338: POP
66339: GO 66345
// end ;
66341: GO 66306
66343: POP
66344: POP
// end ;
66345: LD_VAR 0 3
66349: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66350: LD_INT 0
66352: PPUSH
66353: PPUSH
66354: PPUSH
66355: PPUSH
66356: PPUSH
66357: PPUSH
66358: PPUSH
66359: PPUSH
66360: PPUSH
66361: PPUSH
66362: PPUSH
66363: PPUSH
66364: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66365: LD_VAR 0 1
66369: NOT
66370: PUSH
66371: LD_VAR 0 1
66375: PPUSH
66376: CALL_OW 257
66380: PUSH
66381: LD_INT 9
66383: NONEQUAL
66384: OR
66385: IFFALSE 66389
// exit ;
66387: GO 66962
// side := GetSide ( unit ) ;
66389: LD_ADDR_VAR 0 9
66393: PUSH
66394: LD_VAR 0 1
66398: PPUSH
66399: CALL_OW 255
66403: ST_TO_ADDR
// tech_space := tech_spacanom ;
66404: LD_ADDR_VAR 0 12
66408: PUSH
66409: LD_INT 29
66411: ST_TO_ADDR
// tech_time := tech_taurad ;
66412: LD_ADDR_VAR 0 13
66416: PUSH
66417: LD_INT 28
66419: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66420: LD_ADDR_VAR 0 11
66424: PUSH
66425: LD_VAR 0 1
66429: PPUSH
66430: CALL_OW 310
66434: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66435: LD_VAR 0 11
66439: PPUSH
66440: CALL_OW 247
66444: PUSH
66445: LD_INT 2
66447: EQUAL
66448: IFFALSE 66452
// exit ;
66450: GO 66962
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66452: LD_ADDR_VAR 0 8
66456: PUSH
66457: LD_INT 81
66459: PUSH
66460: LD_VAR 0 9
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 3
66471: PUSH
66472: LD_INT 21
66474: PUSH
66475: LD_INT 3
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PPUSH
66490: CALL_OW 69
66494: ST_TO_ADDR
// if not tmp then
66495: LD_VAR 0 8
66499: NOT
66500: IFFALSE 66504
// exit ;
66502: GO 66962
// if in_unit then
66504: LD_VAR 0 11
66508: IFFALSE 66532
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66510: LD_ADDR_VAR 0 10
66514: PUSH
66515: LD_VAR 0 8
66519: PPUSH
66520: LD_VAR 0 11
66524: PPUSH
66525: CALL_OW 74
66529: ST_TO_ADDR
66530: GO 66552
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66532: LD_ADDR_VAR 0 10
66536: PUSH
66537: LD_VAR 0 8
66541: PPUSH
66542: LD_VAR 0 1
66546: PPUSH
66547: CALL_OW 74
66551: ST_TO_ADDR
// if not enemy then
66552: LD_VAR 0 10
66556: NOT
66557: IFFALSE 66561
// exit ;
66559: GO 66962
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66561: LD_VAR 0 11
66565: PUSH
66566: LD_VAR 0 11
66570: PPUSH
66571: LD_VAR 0 10
66575: PPUSH
66576: CALL_OW 296
66580: PUSH
66581: LD_INT 13
66583: GREATER
66584: AND
66585: PUSH
66586: LD_VAR 0 1
66590: PPUSH
66591: LD_VAR 0 10
66595: PPUSH
66596: CALL_OW 296
66600: PUSH
66601: LD_INT 12
66603: GREATER
66604: OR
66605: IFFALSE 66609
// exit ;
66607: GO 66962
// missile := [ 1 ] ;
66609: LD_ADDR_VAR 0 14
66613: PUSH
66614: LD_INT 1
66616: PUSH
66617: EMPTY
66618: LIST
66619: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66620: LD_VAR 0 9
66624: PPUSH
66625: LD_VAR 0 12
66629: PPUSH
66630: CALL_OW 325
66634: IFFALSE 66663
// missile := Insert ( missile , missile + 1 , 2 ) ;
66636: LD_ADDR_VAR 0 14
66640: PUSH
66641: LD_VAR 0 14
66645: PPUSH
66646: LD_VAR 0 14
66650: PUSH
66651: LD_INT 1
66653: PLUS
66654: PPUSH
66655: LD_INT 2
66657: PPUSH
66658: CALL_OW 2
66662: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66663: LD_VAR 0 9
66667: PPUSH
66668: LD_VAR 0 13
66672: PPUSH
66673: CALL_OW 325
66677: PUSH
66678: LD_VAR 0 10
66682: PPUSH
66683: CALL_OW 255
66687: PPUSH
66688: LD_VAR 0 13
66692: PPUSH
66693: CALL_OW 325
66697: NOT
66698: AND
66699: IFFALSE 66728
// missile := Insert ( missile , missile + 1 , 3 ) ;
66701: LD_ADDR_VAR 0 14
66705: PUSH
66706: LD_VAR 0 14
66710: PPUSH
66711: LD_VAR 0 14
66715: PUSH
66716: LD_INT 1
66718: PLUS
66719: PPUSH
66720: LD_INT 3
66722: PPUSH
66723: CALL_OW 2
66727: ST_TO_ADDR
// if missile < 2 then
66728: LD_VAR 0 14
66732: PUSH
66733: LD_INT 2
66735: LESS
66736: IFFALSE 66740
// exit ;
66738: GO 66962
// x := GetX ( enemy ) ;
66740: LD_ADDR_VAR 0 4
66744: PUSH
66745: LD_VAR 0 10
66749: PPUSH
66750: CALL_OW 250
66754: ST_TO_ADDR
// y := GetY ( enemy ) ;
66755: LD_ADDR_VAR 0 5
66759: PUSH
66760: LD_VAR 0 10
66764: PPUSH
66765: CALL_OW 251
66769: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66770: LD_ADDR_VAR 0 6
66774: PUSH
66775: LD_VAR 0 4
66779: PUSH
66780: LD_INT 1
66782: NEG
66783: PPUSH
66784: LD_INT 1
66786: PPUSH
66787: CALL_OW 12
66791: PLUS
66792: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66793: LD_ADDR_VAR 0 7
66797: PUSH
66798: LD_VAR 0 5
66802: PUSH
66803: LD_INT 1
66805: NEG
66806: PPUSH
66807: LD_INT 1
66809: PPUSH
66810: CALL_OW 12
66814: PLUS
66815: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66816: LD_VAR 0 6
66820: PPUSH
66821: LD_VAR 0 7
66825: PPUSH
66826: CALL_OW 488
66830: NOT
66831: IFFALSE 66853
// begin _x := x ;
66833: LD_ADDR_VAR 0 6
66837: PUSH
66838: LD_VAR 0 4
66842: ST_TO_ADDR
// _y := y ;
66843: LD_ADDR_VAR 0 7
66847: PUSH
66848: LD_VAR 0 5
66852: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66853: LD_ADDR_VAR 0 3
66857: PUSH
66858: LD_INT 1
66860: PPUSH
66861: LD_VAR 0 14
66865: PPUSH
66866: CALL_OW 12
66870: ST_TO_ADDR
// case i of 1 :
66871: LD_VAR 0 3
66875: PUSH
66876: LD_INT 1
66878: DOUBLE
66879: EQUAL
66880: IFTRUE 66884
66882: GO 66901
66884: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66885: LD_VAR 0 1
66889: PPUSH
66890: LD_VAR 0 10
66894: PPUSH
66895: CALL_OW 115
66899: GO 66962
66901: LD_INT 2
66903: DOUBLE
66904: EQUAL
66905: IFTRUE 66909
66907: GO 66931
66909: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66910: LD_VAR 0 1
66914: PPUSH
66915: LD_VAR 0 6
66919: PPUSH
66920: LD_VAR 0 7
66924: PPUSH
66925: CALL_OW 153
66929: GO 66962
66931: LD_INT 3
66933: DOUBLE
66934: EQUAL
66935: IFTRUE 66939
66937: GO 66961
66939: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66940: LD_VAR 0 1
66944: PPUSH
66945: LD_VAR 0 6
66949: PPUSH
66950: LD_VAR 0 7
66954: PPUSH
66955: CALL_OW 154
66959: GO 66962
66961: POP
// end ;
66962: LD_VAR 0 2
66966: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66967: LD_INT 0
66969: PPUSH
66970: PPUSH
66971: PPUSH
66972: PPUSH
66973: PPUSH
66974: PPUSH
// if not unit or not building then
66975: LD_VAR 0 1
66979: NOT
66980: PUSH
66981: LD_VAR 0 2
66985: NOT
66986: OR
66987: IFFALSE 66991
// exit ;
66989: GO 67149
// x := GetX ( building ) ;
66991: LD_ADDR_VAR 0 5
66995: PUSH
66996: LD_VAR 0 2
67000: PPUSH
67001: CALL_OW 250
67005: ST_TO_ADDR
// y := GetY ( building ) ;
67006: LD_ADDR_VAR 0 6
67010: PUSH
67011: LD_VAR 0 2
67015: PPUSH
67016: CALL_OW 251
67020: ST_TO_ADDR
// for i = 0 to 5 do
67021: LD_ADDR_VAR 0 4
67025: PUSH
67026: DOUBLE
67027: LD_INT 0
67029: DEC
67030: ST_TO_ADDR
67031: LD_INT 5
67033: PUSH
67034: FOR_TO
67035: IFFALSE 67147
// begin _x := ShiftX ( x , i , 3 ) ;
67037: LD_ADDR_VAR 0 7
67041: PUSH
67042: LD_VAR 0 5
67046: PPUSH
67047: LD_VAR 0 4
67051: PPUSH
67052: LD_INT 3
67054: PPUSH
67055: CALL_OW 272
67059: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67060: LD_ADDR_VAR 0 8
67064: PUSH
67065: LD_VAR 0 6
67069: PPUSH
67070: LD_VAR 0 4
67074: PPUSH
67075: LD_INT 3
67077: PPUSH
67078: CALL_OW 273
67082: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67083: LD_VAR 0 7
67087: PPUSH
67088: LD_VAR 0 8
67092: PPUSH
67093: CALL_OW 488
67097: NOT
67098: IFFALSE 67102
// continue ;
67100: GO 67034
// if HexInfo ( _x , _y ) = 0 then
67102: LD_VAR 0 7
67106: PPUSH
67107: LD_VAR 0 8
67111: PPUSH
67112: CALL_OW 428
67116: PUSH
67117: LD_INT 0
67119: EQUAL
67120: IFFALSE 67145
// begin ComMoveXY ( unit , _x , _y ) ;
67122: LD_VAR 0 1
67126: PPUSH
67127: LD_VAR 0 7
67131: PPUSH
67132: LD_VAR 0 8
67136: PPUSH
67137: CALL_OW 111
// exit ;
67141: POP
67142: POP
67143: GO 67149
// end ; end ;
67145: GO 67034
67147: POP
67148: POP
// end ;
67149: LD_VAR 0 3
67153: RET
// export function ScanBase ( side , base_area ) ; begin
67154: LD_INT 0
67156: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67157: LD_ADDR_VAR 0 3
67161: PUSH
67162: LD_VAR 0 2
67166: PPUSH
67167: LD_INT 81
67169: PUSH
67170: LD_VAR 0 1
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PPUSH
67179: CALL_OW 70
67183: ST_TO_ADDR
// end ;
67184: LD_VAR 0 3
67188: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67189: LD_INT 0
67191: PPUSH
67192: PPUSH
67193: PPUSH
67194: PPUSH
// result := false ;
67195: LD_ADDR_VAR 0 2
67199: PUSH
67200: LD_INT 0
67202: ST_TO_ADDR
// side := GetSide ( unit ) ;
67203: LD_ADDR_VAR 0 3
67207: PUSH
67208: LD_VAR 0 1
67212: PPUSH
67213: CALL_OW 255
67217: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67218: LD_ADDR_VAR 0 4
67222: PUSH
67223: LD_VAR 0 1
67227: PPUSH
67228: CALL_OW 248
67232: ST_TO_ADDR
// case nat of 1 :
67233: LD_VAR 0 4
67237: PUSH
67238: LD_INT 1
67240: DOUBLE
67241: EQUAL
67242: IFTRUE 67246
67244: GO 67257
67246: POP
// tech := tech_lassight ; 2 :
67247: LD_ADDR_VAR 0 5
67251: PUSH
67252: LD_INT 12
67254: ST_TO_ADDR
67255: GO 67296
67257: LD_INT 2
67259: DOUBLE
67260: EQUAL
67261: IFTRUE 67265
67263: GO 67276
67265: POP
// tech := tech_mortar ; 3 :
67266: LD_ADDR_VAR 0 5
67270: PUSH
67271: LD_INT 41
67273: ST_TO_ADDR
67274: GO 67296
67276: LD_INT 3
67278: DOUBLE
67279: EQUAL
67280: IFTRUE 67284
67282: GO 67295
67284: POP
// tech := tech_bazooka ; end ;
67285: LD_ADDR_VAR 0 5
67289: PUSH
67290: LD_INT 44
67292: ST_TO_ADDR
67293: GO 67296
67295: POP
// if Researched ( side , tech ) then
67296: LD_VAR 0 3
67300: PPUSH
67301: LD_VAR 0 5
67305: PPUSH
67306: CALL_OW 325
67310: IFFALSE 67337
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67312: LD_ADDR_VAR 0 2
67316: PUSH
67317: LD_INT 5
67319: PUSH
67320: LD_INT 8
67322: PUSH
67323: LD_INT 9
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: LIST
67330: PUSH
67331: LD_VAR 0 4
67335: ARRAY
67336: ST_TO_ADDR
// end ;
67337: LD_VAR 0 2
67341: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67342: LD_INT 0
67344: PPUSH
67345: PPUSH
67346: PPUSH
// if not mines then
67347: LD_VAR 0 2
67351: NOT
67352: IFFALSE 67356
// exit ;
67354: GO 67500
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67356: LD_ADDR_VAR 0 5
67360: PUSH
67361: LD_INT 81
67363: PUSH
67364: LD_VAR 0 1
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 3
67375: PUSH
67376: LD_INT 21
67378: PUSH
67379: LD_INT 3
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PPUSH
67394: CALL_OW 69
67398: ST_TO_ADDR
// for i in mines do
67399: LD_ADDR_VAR 0 4
67403: PUSH
67404: LD_VAR 0 2
67408: PUSH
67409: FOR_IN
67410: IFFALSE 67498
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67412: LD_VAR 0 4
67416: PUSH
67417: LD_INT 1
67419: ARRAY
67420: PPUSH
67421: LD_VAR 0 4
67425: PUSH
67426: LD_INT 2
67428: ARRAY
67429: PPUSH
67430: CALL_OW 458
67434: NOT
67435: IFFALSE 67439
// continue ;
67437: GO 67409
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67439: LD_VAR 0 4
67443: PUSH
67444: LD_INT 1
67446: ARRAY
67447: PPUSH
67448: LD_VAR 0 4
67452: PUSH
67453: LD_INT 2
67455: ARRAY
67456: PPUSH
67457: CALL_OW 428
67461: PUSH
67462: LD_VAR 0 5
67466: IN
67467: IFFALSE 67496
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67469: LD_VAR 0 4
67473: PUSH
67474: LD_INT 1
67476: ARRAY
67477: PPUSH
67478: LD_VAR 0 4
67482: PUSH
67483: LD_INT 2
67485: ARRAY
67486: PPUSH
67487: LD_VAR 0 1
67491: PPUSH
67492: CALL_OW 456
// end ;
67496: GO 67409
67498: POP
67499: POP
// end ;
67500: LD_VAR 0 3
67504: RET
// export function Count ( array ) ; var i ; begin
67505: LD_INT 0
67507: PPUSH
67508: PPUSH
// result := 0 ;
67509: LD_ADDR_VAR 0 2
67513: PUSH
67514: LD_INT 0
67516: ST_TO_ADDR
// for i in array do
67517: LD_ADDR_VAR 0 3
67521: PUSH
67522: LD_VAR 0 1
67526: PUSH
67527: FOR_IN
67528: IFFALSE 67552
// if i then
67530: LD_VAR 0 3
67534: IFFALSE 67550
// result := result + 1 ;
67536: LD_ADDR_VAR 0 2
67540: PUSH
67541: LD_VAR 0 2
67545: PUSH
67546: LD_INT 1
67548: PLUS
67549: ST_TO_ADDR
67550: GO 67527
67552: POP
67553: POP
// end ;
67554: LD_VAR 0 2
67558: RET
// export function IsEmpty ( building ) ; begin
67559: LD_INT 0
67561: PPUSH
// if not building then
67562: LD_VAR 0 1
67566: NOT
67567: IFFALSE 67571
// exit ;
67569: GO 67614
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67571: LD_ADDR_VAR 0 2
67575: PUSH
67576: LD_VAR 0 1
67580: PUSH
67581: LD_INT 22
67583: PUSH
67584: LD_VAR 0 1
67588: PPUSH
67589: CALL_OW 255
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 58
67600: PUSH
67601: EMPTY
67602: LIST
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PPUSH
67608: CALL_OW 69
67612: IN
67613: ST_TO_ADDR
// end ;
67614: LD_VAR 0 2
67618: RET
// export function IsNotFull ( building ) ; begin
67619: LD_INT 0
67621: PPUSH
// if not building then
67622: LD_VAR 0 1
67626: NOT
67627: IFFALSE 67631
// exit ;
67629: GO 67650
// result := UnitsInside ( building ) < 6 ;
67631: LD_ADDR_VAR 0 2
67635: PUSH
67636: LD_VAR 0 1
67640: PPUSH
67641: CALL_OW 313
67645: PUSH
67646: LD_INT 6
67648: LESS
67649: ST_TO_ADDR
// end ;
67650: LD_VAR 0 2
67654: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67655: LD_INT 0
67657: PPUSH
67658: PPUSH
67659: PPUSH
67660: PPUSH
// tmp := [ ] ;
67661: LD_ADDR_VAR 0 3
67665: PUSH
67666: EMPTY
67667: ST_TO_ADDR
// list := [ ] ;
67668: LD_ADDR_VAR 0 5
67672: PUSH
67673: EMPTY
67674: ST_TO_ADDR
// for i = 16 to 25 do
67675: LD_ADDR_VAR 0 4
67679: PUSH
67680: DOUBLE
67681: LD_INT 16
67683: DEC
67684: ST_TO_ADDR
67685: LD_INT 25
67687: PUSH
67688: FOR_TO
67689: IFFALSE 67762
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67691: LD_ADDR_VAR 0 3
67695: PUSH
67696: LD_VAR 0 3
67700: PUSH
67701: LD_INT 22
67703: PUSH
67704: LD_VAR 0 1
67708: PPUSH
67709: CALL_OW 255
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 91
67720: PUSH
67721: LD_VAR 0 1
67725: PUSH
67726: LD_INT 6
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 30
67736: PUSH
67737: LD_VAR 0 4
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: LIST
67750: PUSH
67751: EMPTY
67752: LIST
67753: PPUSH
67754: CALL_OW 69
67758: ADD
67759: ST_TO_ADDR
67760: GO 67688
67762: POP
67763: POP
// for i = 1 to tmp do
67764: LD_ADDR_VAR 0 4
67768: PUSH
67769: DOUBLE
67770: LD_INT 1
67772: DEC
67773: ST_TO_ADDR
67774: LD_VAR 0 3
67778: PUSH
67779: FOR_TO
67780: IFFALSE 67868
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67782: LD_ADDR_VAR 0 5
67786: PUSH
67787: LD_VAR 0 5
67791: PUSH
67792: LD_VAR 0 3
67796: PUSH
67797: LD_VAR 0 4
67801: ARRAY
67802: PPUSH
67803: CALL_OW 266
67807: PUSH
67808: LD_VAR 0 3
67812: PUSH
67813: LD_VAR 0 4
67817: ARRAY
67818: PPUSH
67819: CALL_OW 250
67823: PUSH
67824: LD_VAR 0 3
67828: PUSH
67829: LD_VAR 0 4
67833: ARRAY
67834: PPUSH
67835: CALL_OW 251
67839: PUSH
67840: LD_VAR 0 3
67844: PUSH
67845: LD_VAR 0 4
67849: ARRAY
67850: PPUSH
67851: CALL_OW 254
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: PUSH
67862: EMPTY
67863: LIST
67864: ADD
67865: ST_TO_ADDR
67866: GO 67779
67868: POP
67869: POP
// result := list ;
67870: LD_ADDR_VAR 0 2
67874: PUSH
67875: LD_VAR 0 5
67879: ST_TO_ADDR
// end ;
67880: LD_VAR 0 2
67884: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67885: LD_INT 0
67887: PPUSH
67888: PPUSH
67889: PPUSH
67890: PPUSH
67891: PPUSH
67892: PPUSH
67893: PPUSH
// if not factory then
67894: LD_VAR 0 1
67898: NOT
67899: IFFALSE 67903
// exit ;
67901: GO 68496
// if control = control_apeman then
67903: LD_VAR 0 4
67907: PUSH
67908: LD_INT 5
67910: EQUAL
67911: IFFALSE 68020
// begin tmp := UnitsInside ( factory ) ;
67913: LD_ADDR_VAR 0 8
67917: PUSH
67918: LD_VAR 0 1
67922: PPUSH
67923: CALL_OW 313
67927: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67928: LD_VAR 0 8
67932: PPUSH
67933: LD_INT 25
67935: PUSH
67936: LD_INT 12
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PPUSH
67943: CALL_OW 72
67947: NOT
67948: IFFALSE 67958
// control := control_manual ;
67950: LD_ADDR_VAR 0 4
67954: PUSH
67955: LD_INT 1
67957: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67958: LD_ADDR_VAR 0 8
67962: PUSH
67963: LD_VAR 0 1
67967: PPUSH
67968: CALL 67655 0 1
67972: ST_TO_ADDR
// if tmp then
67973: LD_VAR 0 8
67977: IFFALSE 68020
// begin for i in tmp do
67979: LD_ADDR_VAR 0 7
67983: PUSH
67984: LD_VAR 0 8
67988: PUSH
67989: FOR_IN
67990: IFFALSE 68018
// if i [ 1 ] = b_ext_radio then
67992: LD_VAR 0 7
67996: PUSH
67997: LD_INT 1
67999: ARRAY
68000: PUSH
68001: LD_INT 22
68003: EQUAL
68004: IFFALSE 68016
// begin control := control_remote ;
68006: LD_ADDR_VAR 0 4
68010: PUSH
68011: LD_INT 2
68013: ST_TO_ADDR
// break ;
68014: GO 68018
// end ;
68016: GO 67989
68018: POP
68019: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68020: LD_VAR 0 1
68024: PPUSH
68025: LD_VAR 0 2
68029: PPUSH
68030: LD_VAR 0 3
68034: PPUSH
68035: LD_VAR 0 4
68039: PPUSH
68040: LD_VAR 0 5
68044: PPUSH
68045: CALL_OW 448
68049: IFFALSE 68084
// begin result := [ chassis , engine , control , weapon ] ;
68051: LD_ADDR_VAR 0 6
68055: PUSH
68056: LD_VAR 0 2
68060: PUSH
68061: LD_VAR 0 3
68065: PUSH
68066: LD_VAR 0 4
68070: PUSH
68071: LD_VAR 0 5
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: ST_TO_ADDR
// exit ;
68082: GO 68496
// end ; _chassis := AvailableChassisList ( factory ) ;
68084: LD_ADDR_VAR 0 9
68088: PUSH
68089: LD_VAR 0 1
68093: PPUSH
68094: CALL_OW 475
68098: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68099: LD_ADDR_VAR 0 11
68103: PUSH
68104: LD_VAR 0 1
68108: PPUSH
68109: CALL_OW 476
68113: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68114: LD_ADDR_VAR 0 12
68118: PUSH
68119: LD_VAR 0 1
68123: PPUSH
68124: CALL_OW 477
68128: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68129: LD_ADDR_VAR 0 10
68133: PUSH
68134: LD_VAR 0 1
68138: PPUSH
68139: CALL_OW 478
68143: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68144: LD_VAR 0 9
68148: NOT
68149: PUSH
68150: LD_VAR 0 11
68154: NOT
68155: OR
68156: PUSH
68157: LD_VAR 0 12
68161: NOT
68162: OR
68163: PUSH
68164: LD_VAR 0 10
68168: NOT
68169: OR
68170: IFFALSE 68205
// begin result := [ chassis , engine , control , weapon ] ;
68172: LD_ADDR_VAR 0 6
68176: PUSH
68177: LD_VAR 0 2
68181: PUSH
68182: LD_VAR 0 3
68186: PUSH
68187: LD_VAR 0 4
68191: PUSH
68192: LD_VAR 0 5
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: ST_TO_ADDR
// exit ;
68203: GO 68496
// end ; if not chassis in _chassis then
68205: LD_VAR 0 2
68209: PUSH
68210: LD_VAR 0 9
68214: IN
68215: NOT
68216: IFFALSE 68242
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68218: LD_ADDR_VAR 0 2
68222: PUSH
68223: LD_VAR 0 9
68227: PUSH
68228: LD_INT 1
68230: PPUSH
68231: LD_VAR 0 9
68235: PPUSH
68236: CALL_OW 12
68240: ARRAY
68241: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68242: LD_VAR 0 2
68246: PPUSH
68247: LD_VAR 0 3
68251: PPUSH
68252: CALL 68501 0 2
68256: NOT
68257: IFFALSE 68316
// repeat engine := _engine [ 1 ] ;
68259: LD_ADDR_VAR 0 3
68263: PUSH
68264: LD_VAR 0 11
68268: PUSH
68269: LD_INT 1
68271: ARRAY
68272: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68273: LD_ADDR_VAR 0 11
68277: PUSH
68278: LD_VAR 0 11
68282: PPUSH
68283: LD_INT 1
68285: PPUSH
68286: CALL_OW 3
68290: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68291: LD_VAR 0 2
68295: PPUSH
68296: LD_VAR 0 3
68300: PPUSH
68301: CALL 68501 0 2
68305: PUSH
68306: LD_VAR 0 11
68310: PUSH
68311: EMPTY
68312: EQUAL
68313: OR
68314: IFFALSE 68259
// if not control in _control then
68316: LD_VAR 0 4
68320: PUSH
68321: LD_VAR 0 12
68325: IN
68326: NOT
68327: IFFALSE 68353
// control := _control [ rand ( 1 , _control ) ] ;
68329: LD_ADDR_VAR 0 4
68333: PUSH
68334: LD_VAR 0 12
68338: PUSH
68339: LD_INT 1
68341: PPUSH
68342: LD_VAR 0 12
68346: PPUSH
68347: CALL_OW 12
68351: ARRAY
68352: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68353: LD_VAR 0 2
68357: PPUSH
68358: LD_VAR 0 5
68362: PPUSH
68363: CALL 68721 0 2
68367: NOT
68368: IFFALSE 68427
// repeat weapon := _weapon [ 1 ] ;
68370: LD_ADDR_VAR 0 5
68374: PUSH
68375: LD_VAR 0 10
68379: PUSH
68380: LD_INT 1
68382: ARRAY
68383: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68384: LD_ADDR_VAR 0 10
68388: PUSH
68389: LD_VAR 0 10
68393: PPUSH
68394: LD_INT 1
68396: PPUSH
68397: CALL_OW 3
68401: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68402: LD_VAR 0 2
68406: PPUSH
68407: LD_VAR 0 5
68411: PPUSH
68412: CALL 68721 0 2
68416: PUSH
68417: LD_VAR 0 10
68421: PUSH
68422: EMPTY
68423: EQUAL
68424: OR
68425: IFFALSE 68370
// result := [ ] ;
68427: LD_ADDR_VAR 0 6
68431: PUSH
68432: EMPTY
68433: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68434: LD_VAR 0 1
68438: PPUSH
68439: LD_VAR 0 2
68443: PPUSH
68444: LD_VAR 0 3
68448: PPUSH
68449: LD_VAR 0 4
68453: PPUSH
68454: LD_VAR 0 5
68458: PPUSH
68459: CALL_OW 448
68463: IFFALSE 68496
// result := [ chassis , engine , control , weapon ] ;
68465: LD_ADDR_VAR 0 6
68469: PUSH
68470: LD_VAR 0 2
68474: PUSH
68475: LD_VAR 0 3
68479: PUSH
68480: LD_VAR 0 4
68484: PUSH
68485: LD_VAR 0 5
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: ST_TO_ADDR
// end ;
68496: LD_VAR 0 6
68500: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68501: LD_INT 0
68503: PPUSH
// if not chassis or not engine then
68504: LD_VAR 0 1
68508: NOT
68509: PUSH
68510: LD_VAR 0 2
68514: NOT
68515: OR
68516: IFFALSE 68520
// exit ;
68518: GO 68716
// case engine of engine_solar :
68520: LD_VAR 0 2
68524: PUSH
68525: LD_INT 2
68527: DOUBLE
68528: EQUAL
68529: IFTRUE 68533
68531: GO 68571
68533: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68534: LD_ADDR_VAR 0 3
68538: PUSH
68539: LD_INT 11
68541: PUSH
68542: LD_INT 12
68544: PUSH
68545: LD_INT 13
68547: PUSH
68548: LD_INT 14
68550: PUSH
68551: LD_INT 1
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: LD_INT 3
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: ST_TO_ADDR
68569: GO 68700
68571: LD_INT 1
68573: DOUBLE
68574: EQUAL
68575: IFTRUE 68579
68577: GO 68641
68579: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68580: LD_ADDR_VAR 0 3
68584: PUSH
68585: LD_INT 11
68587: PUSH
68588: LD_INT 12
68590: PUSH
68591: LD_INT 13
68593: PUSH
68594: LD_INT 14
68596: PUSH
68597: LD_INT 1
68599: PUSH
68600: LD_INT 2
68602: PUSH
68603: LD_INT 3
68605: PUSH
68606: LD_INT 4
68608: PUSH
68609: LD_INT 5
68611: PUSH
68612: LD_INT 21
68614: PUSH
68615: LD_INT 23
68617: PUSH
68618: LD_INT 22
68620: PUSH
68621: LD_INT 24
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: ST_TO_ADDR
68639: GO 68700
68641: LD_INT 3
68643: DOUBLE
68644: EQUAL
68645: IFTRUE 68649
68647: GO 68699
68649: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68650: LD_ADDR_VAR 0 3
68654: PUSH
68655: LD_INT 13
68657: PUSH
68658: LD_INT 14
68660: PUSH
68661: LD_INT 2
68663: PUSH
68664: LD_INT 3
68666: PUSH
68667: LD_INT 4
68669: PUSH
68670: LD_INT 5
68672: PUSH
68673: LD_INT 21
68675: PUSH
68676: LD_INT 22
68678: PUSH
68679: LD_INT 23
68681: PUSH
68682: LD_INT 24
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: ST_TO_ADDR
68697: GO 68700
68699: POP
// result := ( chassis in result ) ;
68700: LD_ADDR_VAR 0 3
68704: PUSH
68705: LD_VAR 0 1
68709: PUSH
68710: LD_VAR 0 3
68714: IN
68715: ST_TO_ADDR
// end ;
68716: LD_VAR 0 3
68720: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68721: LD_INT 0
68723: PPUSH
// if not chassis or not weapon then
68724: LD_VAR 0 1
68728: NOT
68729: PUSH
68730: LD_VAR 0 2
68734: NOT
68735: OR
68736: IFFALSE 68740
// exit ;
68738: GO 69766
// case weapon of us_machine_gun :
68740: LD_VAR 0 2
68744: PUSH
68745: LD_INT 2
68747: DOUBLE
68748: EQUAL
68749: IFTRUE 68753
68751: GO 68783
68753: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68754: LD_ADDR_VAR 0 3
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: LD_INT 3
68767: PUSH
68768: LD_INT 4
68770: PUSH
68771: LD_INT 5
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: ST_TO_ADDR
68781: GO 69750
68783: LD_INT 3
68785: DOUBLE
68786: EQUAL
68787: IFTRUE 68791
68789: GO 68821
68791: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68792: LD_ADDR_VAR 0 3
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: LD_INT 2
68802: PUSH
68803: LD_INT 3
68805: PUSH
68806: LD_INT 4
68808: PUSH
68809: LD_INT 5
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: LIST
68818: ST_TO_ADDR
68819: GO 69750
68821: LD_INT 11
68823: DOUBLE
68824: EQUAL
68825: IFTRUE 68829
68827: GO 68859
68829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68830: LD_ADDR_VAR 0 3
68834: PUSH
68835: LD_INT 1
68837: PUSH
68838: LD_INT 2
68840: PUSH
68841: LD_INT 3
68843: PUSH
68844: LD_INT 4
68846: PUSH
68847: LD_INT 5
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: ST_TO_ADDR
68857: GO 69750
68859: LD_INT 4
68861: DOUBLE
68862: EQUAL
68863: IFTRUE 68867
68865: GO 68893
68867: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68868: LD_ADDR_VAR 0 3
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: LD_INT 3
68878: PUSH
68879: LD_INT 4
68881: PUSH
68882: LD_INT 5
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: ST_TO_ADDR
68891: GO 69750
68893: LD_INT 5
68895: DOUBLE
68896: EQUAL
68897: IFTRUE 68901
68899: GO 68927
68901: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68902: LD_ADDR_VAR 0 3
68906: PUSH
68907: LD_INT 2
68909: PUSH
68910: LD_INT 3
68912: PUSH
68913: LD_INT 4
68915: PUSH
68916: LD_INT 5
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: ST_TO_ADDR
68925: GO 69750
68927: LD_INT 9
68929: DOUBLE
68930: EQUAL
68931: IFTRUE 68935
68933: GO 68961
68935: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68936: LD_ADDR_VAR 0 3
68940: PUSH
68941: LD_INT 2
68943: PUSH
68944: LD_INT 3
68946: PUSH
68947: LD_INT 4
68949: PUSH
68950: LD_INT 5
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: ST_TO_ADDR
68959: GO 69750
68961: LD_INT 7
68963: DOUBLE
68964: EQUAL
68965: IFTRUE 68969
68967: GO 68995
68969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68970: LD_ADDR_VAR 0 3
68974: PUSH
68975: LD_INT 2
68977: PUSH
68978: LD_INT 3
68980: PUSH
68981: LD_INT 4
68983: PUSH
68984: LD_INT 5
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: ST_TO_ADDR
68993: GO 69750
68995: LD_INT 12
68997: DOUBLE
68998: EQUAL
68999: IFTRUE 69003
69001: GO 69029
69003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69004: LD_ADDR_VAR 0 3
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: LD_INT 3
69014: PUSH
69015: LD_INT 4
69017: PUSH
69018: LD_INT 5
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: ST_TO_ADDR
69027: GO 69750
69029: LD_INT 13
69031: DOUBLE
69032: EQUAL
69033: IFTRUE 69037
69035: GO 69063
69037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69038: LD_ADDR_VAR 0 3
69042: PUSH
69043: LD_INT 2
69045: PUSH
69046: LD_INT 3
69048: PUSH
69049: LD_INT 4
69051: PUSH
69052: LD_INT 5
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: ST_TO_ADDR
69061: GO 69750
69063: LD_INT 14
69065: DOUBLE
69066: EQUAL
69067: IFTRUE 69071
69069: GO 69089
69071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69072: LD_ADDR_VAR 0 3
69076: PUSH
69077: LD_INT 4
69079: PUSH
69080: LD_INT 5
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: ST_TO_ADDR
69087: GO 69750
69089: LD_INT 6
69091: DOUBLE
69092: EQUAL
69093: IFTRUE 69097
69095: GO 69115
69097: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69098: LD_ADDR_VAR 0 3
69102: PUSH
69103: LD_INT 4
69105: PUSH
69106: LD_INT 5
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: ST_TO_ADDR
69113: GO 69750
69115: LD_INT 10
69117: DOUBLE
69118: EQUAL
69119: IFTRUE 69123
69121: GO 69141
69123: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69124: LD_ADDR_VAR 0 3
69128: PUSH
69129: LD_INT 4
69131: PUSH
69132: LD_INT 5
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: ST_TO_ADDR
69139: GO 69750
69141: LD_INT 22
69143: DOUBLE
69144: EQUAL
69145: IFTRUE 69149
69147: GO 69175
69149: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69150: LD_ADDR_VAR 0 3
69154: PUSH
69155: LD_INT 11
69157: PUSH
69158: LD_INT 12
69160: PUSH
69161: LD_INT 13
69163: PUSH
69164: LD_INT 14
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: ST_TO_ADDR
69173: GO 69750
69175: LD_INT 23
69177: DOUBLE
69178: EQUAL
69179: IFTRUE 69183
69181: GO 69209
69183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69184: LD_ADDR_VAR 0 3
69188: PUSH
69189: LD_INT 11
69191: PUSH
69192: LD_INT 12
69194: PUSH
69195: LD_INT 13
69197: PUSH
69198: LD_INT 14
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: ST_TO_ADDR
69207: GO 69750
69209: LD_INT 24
69211: DOUBLE
69212: EQUAL
69213: IFTRUE 69217
69215: GO 69243
69217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69218: LD_ADDR_VAR 0 3
69222: PUSH
69223: LD_INT 11
69225: PUSH
69226: LD_INT 12
69228: PUSH
69229: LD_INT 13
69231: PUSH
69232: LD_INT 14
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: ST_TO_ADDR
69241: GO 69750
69243: LD_INT 30
69245: DOUBLE
69246: EQUAL
69247: IFTRUE 69251
69249: GO 69277
69251: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69252: LD_ADDR_VAR 0 3
69256: PUSH
69257: LD_INT 11
69259: PUSH
69260: LD_INT 12
69262: PUSH
69263: LD_INT 13
69265: PUSH
69266: LD_INT 14
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: ST_TO_ADDR
69275: GO 69750
69277: LD_INT 25
69279: DOUBLE
69280: EQUAL
69281: IFTRUE 69285
69283: GO 69303
69285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69286: LD_ADDR_VAR 0 3
69290: PUSH
69291: LD_INT 13
69293: PUSH
69294: LD_INT 14
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: ST_TO_ADDR
69301: GO 69750
69303: LD_INT 27
69305: DOUBLE
69306: EQUAL
69307: IFTRUE 69311
69309: GO 69329
69311: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_INT 13
69319: PUSH
69320: LD_INT 14
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: ST_TO_ADDR
69327: GO 69750
69329: LD_INT 28
69331: DOUBLE
69332: EQUAL
69333: IFTRUE 69337
69335: GO 69355
69337: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69338: LD_ADDR_VAR 0 3
69342: PUSH
69343: LD_INT 13
69345: PUSH
69346: LD_INT 14
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: ST_TO_ADDR
69353: GO 69750
69355: LD_INT 29
69357: DOUBLE
69358: EQUAL
69359: IFTRUE 69363
69361: GO 69381
69363: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69364: LD_ADDR_VAR 0 3
69368: PUSH
69369: LD_INT 13
69371: PUSH
69372: LD_INT 14
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: ST_TO_ADDR
69379: GO 69750
69381: LD_INT 31
69383: DOUBLE
69384: EQUAL
69385: IFTRUE 69389
69387: GO 69407
69389: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69390: LD_ADDR_VAR 0 3
69394: PUSH
69395: LD_INT 13
69397: PUSH
69398: LD_INT 14
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: ST_TO_ADDR
69405: GO 69750
69407: LD_INT 26
69409: DOUBLE
69410: EQUAL
69411: IFTRUE 69415
69413: GO 69433
69415: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69416: LD_ADDR_VAR 0 3
69420: PUSH
69421: LD_INT 13
69423: PUSH
69424: LD_INT 14
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: ST_TO_ADDR
69431: GO 69750
69433: LD_INT 42
69435: DOUBLE
69436: EQUAL
69437: IFTRUE 69441
69439: GO 69467
69441: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69442: LD_ADDR_VAR 0 3
69446: PUSH
69447: LD_INT 21
69449: PUSH
69450: LD_INT 22
69452: PUSH
69453: LD_INT 23
69455: PUSH
69456: LD_INT 24
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: ST_TO_ADDR
69465: GO 69750
69467: LD_INT 43
69469: DOUBLE
69470: EQUAL
69471: IFTRUE 69475
69473: GO 69501
69475: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69476: LD_ADDR_VAR 0 3
69480: PUSH
69481: LD_INT 21
69483: PUSH
69484: LD_INT 22
69486: PUSH
69487: LD_INT 23
69489: PUSH
69490: LD_INT 24
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: LIST
69497: LIST
69498: ST_TO_ADDR
69499: GO 69750
69501: LD_INT 44
69503: DOUBLE
69504: EQUAL
69505: IFTRUE 69509
69507: GO 69535
69509: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69510: LD_ADDR_VAR 0 3
69514: PUSH
69515: LD_INT 21
69517: PUSH
69518: LD_INT 22
69520: PUSH
69521: LD_INT 23
69523: PUSH
69524: LD_INT 24
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: ST_TO_ADDR
69533: GO 69750
69535: LD_INT 45
69537: DOUBLE
69538: EQUAL
69539: IFTRUE 69543
69541: GO 69569
69543: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69544: LD_ADDR_VAR 0 3
69548: PUSH
69549: LD_INT 21
69551: PUSH
69552: LD_INT 22
69554: PUSH
69555: LD_INT 23
69557: PUSH
69558: LD_INT 24
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: ST_TO_ADDR
69567: GO 69750
69569: LD_INT 49
69571: DOUBLE
69572: EQUAL
69573: IFTRUE 69577
69575: GO 69603
69577: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69578: LD_ADDR_VAR 0 3
69582: PUSH
69583: LD_INT 21
69585: PUSH
69586: LD_INT 22
69588: PUSH
69589: LD_INT 23
69591: PUSH
69592: LD_INT 24
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: ST_TO_ADDR
69601: GO 69750
69603: LD_INT 51
69605: DOUBLE
69606: EQUAL
69607: IFTRUE 69611
69609: GO 69637
69611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69612: LD_ADDR_VAR 0 3
69616: PUSH
69617: LD_INT 21
69619: PUSH
69620: LD_INT 22
69622: PUSH
69623: LD_INT 23
69625: PUSH
69626: LD_INT 24
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: ST_TO_ADDR
69635: GO 69750
69637: LD_INT 52
69639: DOUBLE
69640: EQUAL
69641: IFTRUE 69645
69643: GO 69671
69645: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69646: LD_ADDR_VAR 0 3
69650: PUSH
69651: LD_INT 21
69653: PUSH
69654: LD_INT 22
69656: PUSH
69657: LD_INT 23
69659: PUSH
69660: LD_INT 24
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: LIST
69667: LIST
69668: ST_TO_ADDR
69669: GO 69750
69671: LD_INT 53
69673: DOUBLE
69674: EQUAL
69675: IFTRUE 69679
69677: GO 69697
69679: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69680: LD_ADDR_VAR 0 3
69684: PUSH
69685: LD_INT 23
69687: PUSH
69688: LD_INT 24
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: ST_TO_ADDR
69695: GO 69750
69697: LD_INT 46
69699: DOUBLE
69700: EQUAL
69701: IFTRUE 69705
69703: GO 69723
69705: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69706: LD_ADDR_VAR 0 3
69710: PUSH
69711: LD_INT 23
69713: PUSH
69714: LD_INT 24
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: ST_TO_ADDR
69721: GO 69750
69723: LD_INT 47
69725: DOUBLE
69726: EQUAL
69727: IFTRUE 69731
69729: GO 69749
69731: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69732: LD_ADDR_VAR 0 3
69736: PUSH
69737: LD_INT 23
69739: PUSH
69740: LD_INT 24
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: ST_TO_ADDR
69747: GO 69750
69749: POP
// result := ( chassis in result ) ;
69750: LD_ADDR_VAR 0 3
69754: PUSH
69755: LD_VAR 0 1
69759: PUSH
69760: LD_VAR 0 3
69764: IN
69765: ST_TO_ADDR
// end ;
69766: LD_VAR 0 3
69770: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69771: LD_INT 0
69773: PPUSH
69774: PPUSH
69775: PPUSH
69776: PPUSH
69777: PPUSH
69778: PPUSH
69779: PPUSH
// result := array ;
69780: LD_ADDR_VAR 0 5
69784: PUSH
69785: LD_VAR 0 1
69789: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69790: LD_VAR 0 1
69794: NOT
69795: PUSH
69796: LD_VAR 0 2
69800: NOT
69801: OR
69802: PUSH
69803: LD_VAR 0 3
69807: NOT
69808: OR
69809: PUSH
69810: LD_VAR 0 2
69814: PUSH
69815: LD_VAR 0 1
69819: GREATER
69820: OR
69821: PUSH
69822: LD_VAR 0 3
69826: PUSH
69827: LD_VAR 0 1
69831: GREATER
69832: OR
69833: IFFALSE 69837
// exit ;
69835: GO 70133
// if direction then
69837: LD_VAR 0 4
69841: IFFALSE 69905
// begin d := 1 ;
69843: LD_ADDR_VAR 0 9
69847: PUSH
69848: LD_INT 1
69850: ST_TO_ADDR
// if i_from > i_to then
69851: LD_VAR 0 2
69855: PUSH
69856: LD_VAR 0 3
69860: GREATER
69861: IFFALSE 69887
// length := ( array - i_from ) + i_to else
69863: LD_ADDR_VAR 0 11
69867: PUSH
69868: LD_VAR 0 1
69872: PUSH
69873: LD_VAR 0 2
69877: MINUS
69878: PUSH
69879: LD_VAR 0 3
69883: PLUS
69884: ST_TO_ADDR
69885: GO 69903
// length := i_to - i_from ;
69887: LD_ADDR_VAR 0 11
69891: PUSH
69892: LD_VAR 0 3
69896: PUSH
69897: LD_VAR 0 2
69901: MINUS
69902: ST_TO_ADDR
// end else
69903: GO 69966
// begin d := - 1 ;
69905: LD_ADDR_VAR 0 9
69909: PUSH
69910: LD_INT 1
69912: NEG
69913: ST_TO_ADDR
// if i_from > i_to then
69914: LD_VAR 0 2
69918: PUSH
69919: LD_VAR 0 3
69923: GREATER
69924: IFFALSE 69944
// length := i_from - i_to else
69926: LD_ADDR_VAR 0 11
69930: PUSH
69931: LD_VAR 0 2
69935: PUSH
69936: LD_VAR 0 3
69940: MINUS
69941: ST_TO_ADDR
69942: GO 69966
// length := ( array - i_to ) + i_from ;
69944: LD_ADDR_VAR 0 11
69948: PUSH
69949: LD_VAR 0 1
69953: PUSH
69954: LD_VAR 0 3
69958: MINUS
69959: PUSH
69960: LD_VAR 0 2
69964: PLUS
69965: ST_TO_ADDR
// end ; if not length then
69966: LD_VAR 0 11
69970: NOT
69971: IFFALSE 69975
// exit ;
69973: GO 70133
// tmp := array ;
69975: LD_ADDR_VAR 0 10
69979: PUSH
69980: LD_VAR 0 1
69984: ST_TO_ADDR
// for i = 1 to length do
69985: LD_ADDR_VAR 0 6
69989: PUSH
69990: DOUBLE
69991: LD_INT 1
69993: DEC
69994: ST_TO_ADDR
69995: LD_VAR 0 11
69999: PUSH
70000: FOR_TO
70001: IFFALSE 70121
// begin for j = 1 to array do
70003: LD_ADDR_VAR 0 7
70007: PUSH
70008: DOUBLE
70009: LD_INT 1
70011: DEC
70012: ST_TO_ADDR
70013: LD_VAR 0 1
70017: PUSH
70018: FOR_TO
70019: IFFALSE 70107
// begin k := j + d ;
70021: LD_ADDR_VAR 0 8
70025: PUSH
70026: LD_VAR 0 7
70030: PUSH
70031: LD_VAR 0 9
70035: PLUS
70036: ST_TO_ADDR
// if k > array then
70037: LD_VAR 0 8
70041: PUSH
70042: LD_VAR 0 1
70046: GREATER
70047: IFFALSE 70057
// k := 1 ;
70049: LD_ADDR_VAR 0 8
70053: PUSH
70054: LD_INT 1
70056: ST_TO_ADDR
// if not k then
70057: LD_VAR 0 8
70061: NOT
70062: IFFALSE 70074
// k := array ;
70064: LD_ADDR_VAR 0 8
70068: PUSH
70069: LD_VAR 0 1
70073: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70074: LD_ADDR_VAR 0 10
70078: PUSH
70079: LD_VAR 0 10
70083: PPUSH
70084: LD_VAR 0 8
70088: PPUSH
70089: LD_VAR 0 1
70093: PUSH
70094: LD_VAR 0 7
70098: ARRAY
70099: PPUSH
70100: CALL_OW 1
70104: ST_TO_ADDR
// end ;
70105: GO 70018
70107: POP
70108: POP
// array := tmp ;
70109: LD_ADDR_VAR 0 1
70113: PUSH
70114: LD_VAR 0 10
70118: ST_TO_ADDR
// end ;
70119: GO 70000
70121: POP
70122: POP
// result := array ;
70123: LD_ADDR_VAR 0 5
70127: PUSH
70128: LD_VAR 0 1
70132: ST_TO_ADDR
// end ;
70133: LD_VAR 0 5
70137: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70138: LD_INT 0
70140: PPUSH
70141: PPUSH
// result := 0 ;
70142: LD_ADDR_VAR 0 3
70146: PUSH
70147: LD_INT 0
70149: ST_TO_ADDR
// if not array or not value in array then
70150: LD_VAR 0 1
70154: NOT
70155: PUSH
70156: LD_VAR 0 2
70160: PUSH
70161: LD_VAR 0 1
70165: IN
70166: NOT
70167: OR
70168: IFFALSE 70172
// exit ;
70170: GO 70226
// for i = 1 to array do
70172: LD_ADDR_VAR 0 4
70176: PUSH
70177: DOUBLE
70178: LD_INT 1
70180: DEC
70181: ST_TO_ADDR
70182: LD_VAR 0 1
70186: PUSH
70187: FOR_TO
70188: IFFALSE 70224
// if value = array [ i ] then
70190: LD_VAR 0 2
70194: PUSH
70195: LD_VAR 0 1
70199: PUSH
70200: LD_VAR 0 4
70204: ARRAY
70205: EQUAL
70206: IFFALSE 70222
// begin result := i ;
70208: LD_ADDR_VAR 0 3
70212: PUSH
70213: LD_VAR 0 4
70217: ST_TO_ADDR
// exit ;
70218: POP
70219: POP
70220: GO 70226
// end ;
70222: GO 70187
70224: POP
70225: POP
// end ;
70226: LD_VAR 0 3
70230: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70231: LD_INT 0
70233: PPUSH
// vc_chassis := chassis ;
70234: LD_ADDR_OWVAR 37
70238: PUSH
70239: LD_VAR 0 1
70243: ST_TO_ADDR
// vc_engine := engine ;
70244: LD_ADDR_OWVAR 39
70248: PUSH
70249: LD_VAR 0 2
70253: ST_TO_ADDR
// vc_control := control ;
70254: LD_ADDR_OWVAR 38
70258: PUSH
70259: LD_VAR 0 3
70263: ST_TO_ADDR
// vc_weapon := weapon ;
70264: LD_ADDR_OWVAR 40
70268: PUSH
70269: LD_VAR 0 4
70273: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70274: LD_ADDR_OWVAR 41
70278: PUSH
70279: LD_VAR 0 5
70283: ST_TO_ADDR
// end ;
70284: LD_VAR 0 6
70288: RET
// export function WantPlant ( unit ) ; var task ; begin
70289: LD_INT 0
70291: PPUSH
70292: PPUSH
// result := false ;
70293: LD_ADDR_VAR 0 2
70297: PUSH
70298: LD_INT 0
70300: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70301: LD_ADDR_VAR 0 3
70305: PUSH
70306: LD_VAR 0 1
70310: PPUSH
70311: CALL_OW 437
70315: ST_TO_ADDR
// if task then
70316: LD_VAR 0 3
70320: IFFALSE 70348
// if task [ 1 ] [ 1 ] = p then
70322: LD_VAR 0 3
70326: PUSH
70327: LD_INT 1
70329: ARRAY
70330: PUSH
70331: LD_INT 1
70333: ARRAY
70334: PUSH
70335: LD_STRING p
70337: EQUAL
70338: IFFALSE 70348
// result := true ;
70340: LD_ADDR_VAR 0 2
70344: PUSH
70345: LD_INT 1
70347: ST_TO_ADDR
// end ;
70348: LD_VAR 0 2
70352: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70353: LD_INT 0
70355: PPUSH
70356: PPUSH
70357: PPUSH
70358: PPUSH
// if pos < 1 then
70359: LD_VAR 0 2
70363: PUSH
70364: LD_INT 1
70366: LESS
70367: IFFALSE 70371
// exit ;
70369: GO 70674
// if pos = 1 then
70371: LD_VAR 0 2
70375: PUSH
70376: LD_INT 1
70378: EQUAL
70379: IFFALSE 70412
// result := Replace ( arr , pos [ 1 ] , value ) else
70381: LD_ADDR_VAR 0 4
70385: PUSH
70386: LD_VAR 0 1
70390: PPUSH
70391: LD_VAR 0 2
70395: PUSH
70396: LD_INT 1
70398: ARRAY
70399: PPUSH
70400: LD_VAR 0 3
70404: PPUSH
70405: CALL_OW 1
70409: ST_TO_ADDR
70410: GO 70674
// begin tmp := arr ;
70412: LD_ADDR_VAR 0 6
70416: PUSH
70417: LD_VAR 0 1
70421: ST_TO_ADDR
// s_arr := [ tmp ] ;
70422: LD_ADDR_VAR 0 7
70426: PUSH
70427: LD_VAR 0 6
70431: PUSH
70432: EMPTY
70433: LIST
70434: ST_TO_ADDR
// for i = 1 to pos - 1 do
70435: LD_ADDR_VAR 0 5
70439: PUSH
70440: DOUBLE
70441: LD_INT 1
70443: DEC
70444: ST_TO_ADDR
70445: LD_VAR 0 2
70449: PUSH
70450: LD_INT 1
70452: MINUS
70453: PUSH
70454: FOR_TO
70455: IFFALSE 70500
// begin tmp := tmp [ pos [ i ] ] ;
70457: LD_ADDR_VAR 0 6
70461: PUSH
70462: LD_VAR 0 6
70466: PUSH
70467: LD_VAR 0 2
70471: PUSH
70472: LD_VAR 0 5
70476: ARRAY
70477: ARRAY
70478: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70479: LD_ADDR_VAR 0 7
70483: PUSH
70484: LD_VAR 0 7
70488: PUSH
70489: LD_VAR 0 6
70493: PUSH
70494: EMPTY
70495: LIST
70496: ADD
70497: ST_TO_ADDR
// end ;
70498: GO 70454
70500: POP
70501: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70502: LD_ADDR_VAR 0 6
70506: PUSH
70507: LD_VAR 0 6
70511: PPUSH
70512: LD_VAR 0 2
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: PPUSH
70523: LD_VAR 0 3
70527: PPUSH
70528: CALL_OW 1
70532: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70533: LD_ADDR_VAR 0 7
70537: PUSH
70538: LD_VAR 0 7
70542: PPUSH
70543: LD_VAR 0 7
70547: PPUSH
70548: LD_VAR 0 6
70552: PPUSH
70553: CALL_OW 1
70557: ST_TO_ADDR
// for i = s_arr downto 2 do
70558: LD_ADDR_VAR 0 5
70562: PUSH
70563: DOUBLE
70564: LD_VAR 0 7
70568: INC
70569: ST_TO_ADDR
70570: LD_INT 2
70572: PUSH
70573: FOR_DOWNTO
70574: IFFALSE 70658
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70576: LD_ADDR_VAR 0 6
70580: PUSH
70581: LD_VAR 0 7
70585: PUSH
70586: LD_VAR 0 5
70590: PUSH
70591: LD_INT 1
70593: MINUS
70594: ARRAY
70595: PPUSH
70596: LD_VAR 0 2
70600: PUSH
70601: LD_VAR 0 5
70605: PUSH
70606: LD_INT 1
70608: MINUS
70609: ARRAY
70610: PPUSH
70611: LD_VAR 0 7
70615: PUSH
70616: LD_VAR 0 5
70620: ARRAY
70621: PPUSH
70622: CALL_OW 1
70626: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70627: LD_ADDR_VAR 0 7
70631: PUSH
70632: LD_VAR 0 7
70636: PPUSH
70637: LD_VAR 0 5
70641: PUSH
70642: LD_INT 1
70644: MINUS
70645: PPUSH
70646: LD_VAR 0 6
70650: PPUSH
70651: CALL_OW 1
70655: ST_TO_ADDR
// end ;
70656: GO 70573
70658: POP
70659: POP
// result := s_arr [ 1 ] ;
70660: LD_ADDR_VAR 0 4
70664: PUSH
70665: LD_VAR 0 7
70669: PUSH
70670: LD_INT 1
70672: ARRAY
70673: ST_TO_ADDR
// end ; end ;
70674: LD_VAR 0 4
70678: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70679: LD_INT 0
70681: PPUSH
70682: PPUSH
// if not list then
70683: LD_VAR 0 1
70687: NOT
70688: IFFALSE 70692
// exit ;
70690: GO 70783
// i := list [ pos1 ] ;
70692: LD_ADDR_VAR 0 5
70696: PUSH
70697: LD_VAR 0 1
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: ST_TO_ADDR
// if not i then
70708: LD_VAR 0 5
70712: NOT
70713: IFFALSE 70717
// exit ;
70715: GO 70783
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70717: LD_ADDR_VAR 0 1
70721: PUSH
70722: LD_VAR 0 1
70726: PPUSH
70727: LD_VAR 0 2
70731: PPUSH
70732: LD_VAR 0 1
70736: PUSH
70737: LD_VAR 0 3
70741: ARRAY
70742: PPUSH
70743: CALL_OW 1
70747: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70748: LD_ADDR_VAR 0 1
70752: PUSH
70753: LD_VAR 0 1
70757: PPUSH
70758: LD_VAR 0 3
70762: PPUSH
70763: LD_VAR 0 5
70767: PPUSH
70768: CALL_OW 1
70772: ST_TO_ADDR
// result := list ;
70773: LD_ADDR_VAR 0 4
70777: PUSH
70778: LD_VAR 0 1
70782: ST_TO_ADDR
// end ;
70783: LD_VAR 0 4
70787: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70788: LD_INT 0
70790: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70791: LD_ADDR_VAR 0 5
70795: PUSH
70796: LD_VAR 0 1
70800: PPUSH
70801: CALL_OW 250
70805: PPUSH
70806: LD_VAR 0 1
70810: PPUSH
70811: CALL_OW 251
70815: PPUSH
70816: LD_VAR 0 2
70820: PPUSH
70821: LD_VAR 0 3
70825: PPUSH
70826: LD_VAR 0 4
70830: PPUSH
70831: CALL 70841 0 5
70835: ST_TO_ADDR
// end ;
70836: LD_VAR 0 5
70840: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70841: LD_INT 0
70843: PPUSH
70844: PPUSH
70845: PPUSH
70846: PPUSH
// if not list then
70847: LD_VAR 0 3
70851: NOT
70852: IFFALSE 70856
// exit ;
70854: GO 71244
// result := [ ] ;
70856: LD_ADDR_VAR 0 6
70860: PUSH
70861: EMPTY
70862: ST_TO_ADDR
// for i in list do
70863: LD_ADDR_VAR 0 7
70867: PUSH
70868: LD_VAR 0 3
70872: PUSH
70873: FOR_IN
70874: IFFALSE 71076
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70876: LD_ADDR_VAR 0 9
70880: PUSH
70881: LD_VAR 0 7
70885: PPUSH
70886: LD_VAR 0 1
70890: PPUSH
70891: LD_VAR 0 2
70895: PPUSH
70896: CALL_OW 297
70900: ST_TO_ADDR
// if not result then
70901: LD_VAR 0 6
70905: NOT
70906: IFFALSE 70932
// result := [ [ i , tmp ] ] else
70908: LD_ADDR_VAR 0 6
70912: PUSH
70913: LD_VAR 0 7
70917: PUSH
70918: LD_VAR 0 9
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: EMPTY
70928: LIST
70929: ST_TO_ADDR
70930: GO 71074
// begin if result [ result ] [ 2 ] < tmp then
70932: LD_VAR 0 6
70936: PUSH
70937: LD_VAR 0 6
70941: ARRAY
70942: PUSH
70943: LD_INT 2
70945: ARRAY
70946: PUSH
70947: LD_VAR 0 9
70951: LESS
70952: IFFALSE 70994
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70954: LD_ADDR_VAR 0 6
70958: PUSH
70959: LD_VAR 0 6
70963: PPUSH
70964: LD_VAR 0 6
70968: PUSH
70969: LD_INT 1
70971: PLUS
70972: PPUSH
70973: LD_VAR 0 7
70977: PUSH
70978: LD_VAR 0 9
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PPUSH
70987: CALL_OW 2
70991: ST_TO_ADDR
70992: GO 71074
// for j = 1 to result do
70994: LD_ADDR_VAR 0 8
70998: PUSH
70999: DOUBLE
71000: LD_INT 1
71002: DEC
71003: ST_TO_ADDR
71004: LD_VAR 0 6
71008: PUSH
71009: FOR_TO
71010: IFFALSE 71072
// begin if tmp < result [ j ] [ 2 ] then
71012: LD_VAR 0 9
71016: PUSH
71017: LD_VAR 0 6
71021: PUSH
71022: LD_VAR 0 8
71026: ARRAY
71027: PUSH
71028: LD_INT 2
71030: ARRAY
71031: LESS
71032: IFFALSE 71070
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71034: LD_ADDR_VAR 0 6
71038: PUSH
71039: LD_VAR 0 6
71043: PPUSH
71044: LD_VAR 0 8
71048: PPUSH
71049: LD_VAR 0 7
71053: PUSH
71054: LD_VAR 0 9
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PPUSH
71063: CALL_OW 2
71067: ST_TO_ADDR
// break ;
71068: GO 71072
// end ; end ;
71070: GO 71009
71072: POP
71073: POP
// end ; end ;
71074: GO 70873
71076: POP
71077: POP
// if result and not asc then
71078: LD_VAR 0 6
71082: PUSH
71083: LD_VAR 0 4
71087: NOT
71088: AND
71089: IFFALSE 71164
// begin tmp := result ;
71091: LD_ADDR_VAR 0 9
71095: PUSH
71096: LD_VAR 0 6
71100: ST_TO_ADDR
// for i = tmp downto 1 do
71101: LD_ADDR_VAR 0 7
71105: PUSH
71106: DOUBLE
71107: LD_VAR 0 9
71111: INC
71112: ST_TO_ADDR
71113: LD_INT 1
71115: PUSH
71116: FOR_DOWNTO
71117: IFFALSE 71162
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71119: LD_ADDR_VAR 0 6
71123: PUSH
71124: LD_VAR 0 6
71128: PPUSH
71129: LD_VAR 0 9
71133: PUSH
71134: LD_VAR 0 7
71138: MINUS
71139: PUSH
71140: LD_INT 1
71142: PLUS
71143: PPUSH
71144: LD_VAR 0 9
71148: PUSH
71149: LD_VAR 0 7
71153: ARRAY
71154: PPUSH
71155: CALL_OW 1
71159: ST_TO_ADDR
71160: GO 71116
71162: POP
71163: POP
// end ; tmp := [ ] ;
71164: LD_ADDR_VAR 0 9
71168: PUSH
71169: EMPTY
71170: ST_TO_ADDR
// if mode then
71171: LD_VAR 0 5
71175: IFFALSE 71244
// begin for i = 1 to result do
71177: LD_ADDR_VAR 0 7
71181: PUSH
71182: DOUBLE
71183: LD_INT 1
71185: DEC
71186: ST_TO_ADDR
71187: LD_VAR 0 6
71191: PUSH
71192: FOR_TO
71193: IFFALSE 71232
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71195: LD_ADDR_VAR 0 9
71199: PUSH
71200: LD_VAR 0 9
71204: PPUSH
71205: LD_VAR 0 7
71209: PPUSH
71210: LD_VAR 0 6
71214: PUSH
71215: LD_VAR 0 7
71219: ARRAY
71220: PUSH
71221: LD_INT 1
71223: ARRAY
71224: PPUSH
71225: CALL_OW 1
71229: ST_TO_ADDR
71230: GO 71192
71232: POP
71233: POP
// result := tmp ;
71234: LD_ADDR_VAR 0 6
71238: PUSH
71239: LD_VAR 0 9
71243: ST_TO_ADDR
// end ; end ;
71244: LD_VAR 0 6
71248: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71249: LD_INT 0
71251: PPUSH
71252: PPUSH
71253: PPUSH
71254: PPUSH
71255: PPUSH
71256: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71257: LD_ADDR_VAR 0 5
71261: PUSH
71262: LD_INT 0
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: LD_INT 0
71270: PUSH
71271: EMPTY
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: ST_TO_ADDR
// if not x or not y then
71279: LD_VAR 0 2
71283: NOT
71284: PUSH
71285: LD_VAR 0 3
71289: NOT
71290: OR
71291: IFFALSE 71295
// exit ;
71293: GO 72941
// if not range then
71295: LD_VAR 0 4
71299: NOT
71300: IFFALSE 71310
// range := 10 ;
71302: LD_ADDR_VAR 0 4
71306: PUSH
71307: LD_INT 10
71309: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71310: LD_ADDR_VAR 0 8
71314: PUSH
71315: LD_INT 81
71317: PUSH
71318: LD_VAR 0 1
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 92
71329: PUSH
71330: LD_VAR 0 2
71334: PUSH
71335: LD_VAR 0 3
71339: PUSH
71340: LD_VAR 0 4
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 3
71353: PUSH
71354: LD_INT 21
71356: PUSH
71357: LD_INT 3
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: LIST
71372: PPUSH
71373: CALL_OW 69
71377: ST_TO_ADDR
// if not tmp then
71378: LD_VAR 0 8
71382: NOT
71383: IFFALSE 71387
// exit ;
71385: GO 72941
// for i in tmp do
71387: LD_ADDR_VAR 0 6
71391: PUSH
71392: LD_VAR 0 8
71396: PUSH
71397: FOR_IN
71398: IFFALSE 72916
// begin points := [ 0 , 0 , 0 ] ;
71400: LD_ADDR_VAR 0 9
71404: PUSH
71405: LD_INT 0
71407: PUSH
71408: LD_INT 0
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: LIST
71418: ST_TO_ADDR
// bpoints := 1 ;
71419: LD_ADDR_VAR 0 10
71423: PUSH
71424: LD_INT 1
71426: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71427: LD_VAR 0 6
71431: PPUSH
71432: CALL_OW 247
71436: PUSH
71437: LD_INT 1
71439: DOUBLE
71440: EQUAL
71441: IFTRUE 71445
71443: GO 72023
71445: POP
// begin if GetClass ( i ) = 1 then
71446: LD_VAR 0 6
71450: PPUSH
71451: CALL_OW 257
71455: PUSH
71456: LD_INT 1
71458: EQUAL
71459: IFFALSE 71480
// points := [ 10 , 5 , 3 ] ;
71461: LD_ADDR_VAR 0 9
71465: PUSH
71466: LD_INT 10
71468: PUSH
71469: LD_INT 5
71471: PUSH
71472: LD_INT 3
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: LIST
71479: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71480: LD_VAR 0 6
71484: PPUSH
71485: CALL_OW 257
71489: PUSH
71490: LD_INT 2
71492: PUSH
71493: LD_INT 3
71495: PUSH
71496: LD_INT 4
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: LIST
71503: IN
71504: IFFALSE 71525
// points := [ 3 , 2 , 1 ] ;
71506: LD_ADDR_VAR 0 9
71510: PUSH
71511: LD_INT 3
71513: PUSH
71514: LD_INT 2
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: LIST
71524: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71525: LD_VAR 0 6
71529: PPUSH
71530: CALL_OW 257
71534: PUSH
71535: LD_INT 5
71537: EQUAL
71538: IFFALSE 71559
// points := [ 130 , 5 , 2 ] ;
71540: LD_ADDR_VAR 0 9
71544: PUSH
71545: LD_INT 130
71547: PUSH
71548: LD_INT 5
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: LIST
71558: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71559: LD_VAR 0 6
71563: PPUSH
71564: CALL_OW 257
71568: PUSH
71569: LD_INT 8
71571: EQUAL
71572: IFFALSE 71593
// points := [ 35 , 35 , 30 ] ;
71574: LD_ADDR_VAR 0 9
71578: PUSH
71579: LD_INT 35
71581: PUSH
71582: LD_INT 35
71584: PUSH
71585: LD_INT 30
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: LIST
71592: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71593: LD_VAR 0 6
71597: PPUSH
71598: CALL_OW 257
71602: PUSH
71603: LD_INT 9
71605: EQUAL
71606: IFFALSE 71627
// points := [ 20 , 55 , 40 ] ;
71608: LD_ADDR_VAR 0 9
71612: PUSH
71613: LD_INT 20
71615: PUSH
71616: LD_INT 55
71618: PUSH
71619: LD_INT 40
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: LIST
71626: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71627: LD_VAR 0 6
71631: PPUSH
71632: CALL_OW 257
71636: PUSH
71637: LD_INT 12
71639: PUSH
71640: LD_INT 16
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: IN
71647: IFFALSE 71668
// points := [ 5 , 3 , 2 ] ;
71649: LD_ADDR_VAR 0 9
71653: PUSH
71654: LD_INT 5
71656: PUSH
71657: LD_INT 3
71659: PUSH
71660: LD_INT 2
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71668: LD_VAR 0 6
71672: PPUSH
71673: CALL_OW 257
71677: PUSH
71678: LD_INT 17
71680: EQUAL
71681: IFFALSE 71702
// points := [ 100 , 50 , 75 ] ;
71683: LD_ADDR_VAR 0 9
71687: PUSH
71688: LD_INT 100
71690: PUSH
71691: LD_INT 50
71693: PUSH
71694: LD_INT 75
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: LIST
71701: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71702: LD_VAR 0 6
71706: PPUSH
71707: CALL_OW 257
71711: PUSH
71712: LD_INT 15
71714: EQUAL
71715: IFFALSE 71736
// points := [ 10 , 5 , 3 ] ;
71717: LD_ADDR_VAR 0 9
71721: PUSH
71722: LD_INT 10
71724: PUSH
71725: LD_INT 5
71727: PUSH
71728: LD_INT 3
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: LIST
71735: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71736: LD_VAR 0 6
71740: PPUSH
71741: CALL_OW 257
71745: PUSH
71746: LD_INT 14
71748: EQUAL
71749: IFFALSE 71770
// points := [ 10 , 0 , 0 ] ;
71751: LD_ADDR_VAR 0 9
71755: PUSH
71756: LD_INT 10
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: LD_INT 0
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: LIST
71769: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71770: LD_VAR 0 6
71774: PPUSH
71775: CALL_OW 257
71779: PUSH
71780: LD_INT 11
71782: EQUAL
71783: IFFALSE 71804
// points := [ 30 , 10 , 5 ] ;
71785: LD_ADDR_VAR 0 9
71789: PUSH
71790: LD_INT 30
71792: PUSH
71793: LD_INT 10
71795: PUSH
71796: LD_INT 5
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: LIST
71803: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71804: LD_VAR 0 1
71808: PPUSH
71809: LD_INT 5
71811: PPUSH
71812: CALL_OW 321
71816: PUSH
71817: LD_INT 2
71819: EQUAL
71820: IFFALSE 71837
// bpoints := bpoints * 1.8 ;
71822: LD_ADDR_VAR 0 10
71826: PUSH
71827: LD_VAR 0 10
71831: PUSH
71832: LD_REAL  1.80000000000000E+0000
71835: MUL
71836: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71837: LD_VAR 0 6
71841: PPUSH
71842: CALL_OW 257
71846: PUSH
71847: LD_INT 1
71849: PUSH
71850: LD_INT 2
71852: PUSH
71853: LD_INT 3
71855: PUSH
71856: LD_INT 4
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: IN
71865: PUSH
71866: LD_VAR 0 1
71870: PPUSH
71871: LD_INT 51
71873: PPUSH
71874: CALL_OW 321
71878: PUSH
71879: LD_INT 2
71881: EQUAL
71882: AND
71883: IFFALSE 71900
// bpoints := bpoints * 1.2 ;
71885: LD_ADDR_VAR 0 10
71889: PUSH
71890: LD_VAR 0 10
71894: PUSH
71895: LD_REAL  1.20000000000000E+0000
71898: MUL
71899: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71900: LD_VAR 0 6
71904: PPUSH
71905: CALL_OW 257
71909: PUSH
71910: LD_INT 5
71912: PUSH
71913: LD_INT 7
71915: PUSH
71916: LD_INT 9
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: LIST
71923: IN
71924: PUSH
71925: LD_VAR 0 1
71929: PPUSH
71930: LD_INT 52
71932: PPUSH
71933: CALL_OW 321
71937: PUSH
71938: LD_INT 2
71940: EQUAL
71941: AND
71942: IFFALSE 71959
// bpoints := bpoints * 1.5 ;
71944: LD_ADDR_VAR 0 10
71948: PUSH
71949: LD_VAR 0 10
71953: PUSH
71954: LD_REAL  1.50000000000000E+0000
71957: MUL
71958: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71959: LD_VAR 0 1
71963: PPUSH
71964: LD_INT 66
71966: PPUSH
71967: CALL_OW 321
71971: PUSH
71972: LD_INT 2
71974: EQUAL
71975: IFFALSE 71992
// bpoints := bpoints * 1.1 ;
71977: LD_ADDR_VAR 0 10
71981: PUSH
71982: LD_VAR 0 10
71986: PUSH
71987: LD_REAL  1.10000000000000E+0000
71990: MUL
71991: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71992: LD_ADDR_VAR 0 10
71996: PUSH
71997: LD_VAR 0 10
72001: PUSH
72002: LD_VAR 0 6
72006: PPUSH
72007: LD_INT 1
72009: PPUSH
72010: CALL_OW 259
72014: PUSH
72015: LD_REAL  1.15000000000000E+0000
72018: MUL
72019: MUL
72020: ST_TO_ADDR
// end ; unit_vehicle :
72021: GO 72845
72023: LD_INT 2
72025: DOUBLE
72026: EQUAL
72027: IFTRUE 72031
72029: GO 72833
72031: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72032: LD_VAR 0 6
72036: PPUSH
72037: CALL_OW 264
72041: PUSH
72042: LD_INT 2
72044: PUSH
72045: LD_INT 42
72047: PUSH
72048: LD_INT 24
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: IN
72056: IFFALSE 72077
// points := [ 25 , 5 , 3 ] ;
72058: LD_ADDR_VAR 0 9
72062: PUSH
72063: LD_INT 25
72065: PUSH
72066: LD_INT 5
72068: PUSH
72069: LD_INT 3
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: LIST
72076: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72077: LD_VAR 0 6
72081: PPUSH
72082: CALL_OW 264
72086: PUSH
72087: LD_INT 4
72089: PUSH
72090: LD_INT 43
72092: PUSH
72093: LD_INT 25
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: LIST
72100: IN
72101: IFFALSE 72122
// points := [ 40 , 15 , 5 ] ;
72103: LD_ADDR_VAR 0 9
72107: PUSH
72108: LD_INT 40
72110: PUSH
72111: LD_INT 15
72113: PUSH
72114: LD_INT 5
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: LIST
72121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72122: LD_VAR 0 6
72126: PPUSH
72127: CALL_OW 264
72131: PUSH
72132: LD_INT 3
72134: PUSH
72135: LD_INT 23
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: IN
72142: IFFALSE 72163
// points := [ 7 , 25 , 8 ] ;
72144: LD_ADDR_VAR 0 9
72148: PUSH
72149: LD_INT 7
72151: PUSH
72152: LD_INT 25
72154: PUSH
72155: LD_INT 8
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: LIST
72162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72163: LD_VAR 0 6
72167: PPUSH
72168: CALL_OW 264
72172: PUSH
72173: LD_INT 5
72175: PUSH
72176: LD_INT 27
72178: PUSH
72179: LD_INT 44
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: LIST
72186: IN
72187: IFFALSE 72208
// points := [ 14 , 50 , 16 ] ;
72189: LD_ADDR_VAR 0 9
72193: PUSH
72194: LD_INT 14
72196: PUSH
72197: LD_INT 50
72199: PUSH
72200: LD_INT 16
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: LIST
72207: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72208: LD_VAR 0 6
72212: PPUSH
72213: CALL_OW 264
72217: PUSH
72218: LD_INT 6
72220: PUSH
72221: LD_INT 46
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: IN
72228: IFFALSE 72249
// points := [ 32 , 120 , 70 ] ;
72230: LD_ADDR_VAR 0 9
72234: PUSH
72235: LD_INT 32
72237: PUSH
72238: LD_INT 120
72240: PUSH
72241: LD_INT 70
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: LIST
72248: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72249: LD_VAR 0 6
72253: PPUSH
72254: CALL_OW 264
72258: PUSH
72259: LD_INT 7
72261: PUSH
72262: LD_INT 28
72264: PUSH
72265: LD_INT 45
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: LIST
72272: IN
72273: IFFALSE 72294
// points := [ 35 , 20 , 45 ] ;
72275: LD_ADDR_VAR 0 9
72279: PUSH
72280: LD_INT 35
72282: PUSH
72283: LD_INT 20
72285: PUSH
72286: LD_INT 45
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: LIST
72293: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72294: LD_VAR 0 6
72298: PPUSH
72299: CALL_OW 264
72303: PUSH
72304: LD_INT 47
72306: PUSH
72307: EMPTY
72308: LIST
72309: IN
72310: IFFALSE 72331
// points := [ 67 , 45 , 75 ] ;
72312: LD_ADDR_VAR 0 9
72316: PUSH
72317: LD_INT 67
72319: PUSH
72320: LD_INT 45
72322: PUSH
72323: LD_INT 75
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: LIST
72330: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72331: LD_VAR 0 6
72335: PPUSH
72336: CALL_OW 264
72340: PUSH
72341: LD_INT 26
72343: PUSH
72344: EMPTY
72345: LIST
72346: IN
72347: IFFALSE 72368
// points := [ 120 , 30 , 80 ] ;
72349: LD_ADDR_VAR 0 9
72353: PUSH
72354: LD_INT 120
72356: PUSH
72357: LD_INT 30
72359: PUSH
72360: LD_INT 80
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: LIST
72367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72368: LD_VAR 0 6
72372: PPUSH
72373: CALL_OW 264
72377: PUSH
72378: LD_INT 22
72380: PUSH
72381: EMPTY
72382: LIST
72383: IN
72384: IFFALSE 72405
// points := [ 40 , 1 , 1 ] ;
72386: LD_ADDR_VAR 0 9
72390: PUSH
72391: LD_INT 40
72393: PUSH
72394: LD_INT 1
72396: PUSH
72397: LD_INT 1
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: LIST
72404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72405: LD_VAR 0 6
72409: PPUSH
72410: CALL_OW 264
72414: PUSH
72415: LD_INT 29
72417: PUSH
72418: EMPTY
72419: LIST
72420: IN
72421: IFFALSE 72442
// points := [ 70 , 200 , 400 ] ;
72423: LD_ADDR_VAR 0 9
72427: PUSH
72428: LD_INT 70
72430: PUSH
72431: LD_INT 200
72433: PUSH
72434: LD_INT 400
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72442: LD_VAR 0 6
72446: PPUSH
72447: CALL_OW 264
72451: PUSH
72452: LD_INT 14
72454: PUSH
72455: LD_INT 53
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: IN
72462: IFFALSE 72483
// points := [ 40 , 10 , 20 ] ;
72464: LD_ADDR_VAR 0 9
72468: PUSH
72469: LD_INT 40
72471: PUSH
72472: LD_INT 10
72474: PUSH
72475: LD_INT 20
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: LIST
72482: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72483: LD_VAR 0 6
72487: PPUSH
72488: CALL_OW 264
72492: PUSH
72493: LD_INT 9
72495: PUSH
72496: EMPTY
72497: LIST
72498: IN
72499: IFFALSE 72520
// points := [ 5 , 70 , 20 ] ;
72501: LD_ADDR_VAR 0 9
72505: PUSH
72506: LD_INT 5
72508: PUSH
72509: LD_INT 70
72511: PUSH
72512: LD_INT 20
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: LIST
72519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72520: LD_VAR 0 6
72524: PPUSH
72525: CALL_OW 264
72529: PUSH
72530: LD_INT 10
72532: PUSH
72533: EMPTY
72534: LIST
72535: IN
72536: IFFALSE 72557
// points := [ 35 , 110 , 70 ] ;
72538: LD_ADDR_VAR 0 9
72542: PUSH
72543: LD_INT 35
72545: PUSH
72546: LD_INT 110
72548: PUSH
72549: LD_INT 70
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: LIST
72556: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72557: LD_VAR 0 6
72561: PPUSH
72562: CALL_OW 265
72566: PUSH
72567: LD_INT 25
72569: EQUAL
72570: IFFALSE 72591
// points := [ 80 , 65 , 100 ] ;
72572: LD_ADDR_VAR 0 9
72576: PUSH
72577: LD_INT 80
72579: PUSH
72580: LD_INT 65
72582: PUSH
72583: LD_INT 100
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: LIST
72590: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72591: LD_VAR 0 6
72595: PPUSH
72596: CALL_OW 263
72600: PUSH
72601: LD_INT 1
72603: EQUAL
72604: IFFALSE 72639
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72606: LD_ADDR_VAR 0 10
72610: PUSH
72611: LD_VAR 0 10
72615: PUSH
72616: LD_VAR 0 6
72620: PPUSH
72621: CALL_OW 311
72625: PPUSH
72626: LD_INT 3
72628: PPUSH
72629: CALL_OW 259
72633: PUSH
72634: LD_INT 4
72636: MUL
72637: MUL
72638: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72639: LD_VAR 0 6
72643: PPUSH
72644: CALL_OW 263
72648: PUSH
72649: LD_INT 2
72651: EQUAL
72652: IFFALSE 72703
// begin j := IsControledBy ( i ) ;
72654: LD_ADDR_VAR 0 7
72658: PUSH
72659: LD_VAR 0 6
72663: PPUSH
72664: CALL_OW 312
72668: ST_TO_ADDR
// if j then
72669: LD_VAR 0 7
72673: IFFALSE 72703
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72675: LD_ADDR_VAR 0 10
72679: PUSH
72680: LD_VAR 0 10
72684: PUSH
72685: LD_VAR 0 7
72689: PPUSH
72690: LD_INT 3
72692: PPUSH
72693: CALL_OW 259
72697: PUSH
72698: LD_INT 3
72700: MUL
72701: MUL
72702: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72703: LD_VAR 0 6
72707: PPUSH
72708: CALL_OW 264
72712: PUSH
72713: LD_INT 5
72715: PUSH
72716: LD_INT 6
72718: PUSH
72719: LD_INT 46
72721: PUSH
72722: LD_INT 44
72724: PUSH
72725: LD_INT 47
72727: PUSH
72728: LD_INT 45
72730: PUSH
72731: LD_INT 28
72733: PUSH
72734: LD_INT 7
72736: PUSH
72737: LD_INT 27
72739: PUSH
72740: LD_INT 29
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: IN
72755: PUSH
72756: LD_VAR 0 1
72760: PPUSH
72761: LD_INT 52
72763: PPUSH
72764: CALL_OW 321
72768: PUSH
72769: LD_INT 2
72771: EQUAL
72772: AND
72773: IFFALSE 72790
// bpoints := bpoints * 1.2 ;
72775: LD_ADDR_VAR 0 10
72779: PUSH
72780: LD_VAR 0 10
72784: PUSH
72785: LD_REAL  1.20000000000000E+0000
72788: MUL
72789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72790: LD_VAR 0 6
72794: PPUSH
72795: CALL_OW 264
72799: PUSH
72800: LD_INT 6
72802: PUSH
72803: LD_INT 46
72805: PUSH
72806: LD_INT 47
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: LIST
72813: IN
72814: IFFALSE 72831
// bpoints := bpoints * 1.2 ;
72816: LD_ADDR_VAR 0 10
72820: PUSH
72821: LD_VAR 0 10
72825: PUSH
72826: LD_REAL  1.20000000000000E+0000
72829: MUL
72830: ST_TO_ADDR
// end ; unit_building :
72831: GO 72845
72833: LD_INT 3
72835: DOUBLE
72836: EQUAL
72837: IFTRUE 72841
72839: GO 72844
72841: POP
// ; end ;
72842: GO 72845
72844: POP
// for j = 1 to 3 do
72845: LD_ADDR_VAR 0 7
72849: PUSH
72850: DOUBLE
72851: LD_INT 1
72853: DEC
72854: ST_TO_ADDR
72855: LD_INT 3
72857: PUSH
72858: FOR_TO
72859: IFFALSE 72912
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72861: LD_ADDR_VAR 0 5
72865: PUSH
72866: LD_VAR 0 5
72870: PPUSH
72871: LD_VAR 0 7
72875: PPUSH
72876: LD_VAR 0 5
72880: PUSH
72881: LD_VAR 0 7
72885: ARRAY
72886: PUSH
72887: LD_VAR 0 9
72891: PUSH
72892: LD_VAR 0 7
72896: ARRAY
72897: PUSH
72898: LD_VAR 0 10
72902: MUL
72903: PLUS
72904: PPUSH
72905: CALL_OW 1
72909: ST_TO_ADDR
72910: GO 72858
72912: POP
72913: POP
// end ;
72914: GO 71397
72916: POP
72917: POP
// result := Replace ( result , 4 , tmp ) ;
72918: LD_ADDR_VAR 0 5
72922: PUSH
72923: LD_VAR 0 5
72927: PPUSH
72928: LD_INT 4
72930: PPUSH
72931: LD_VAR 0 8
72935: PPUSH
72936: CALL_OW 1
72940: ST_TO_ADDR
// end ;
72941: LD_VAR 0 5
72945: RET
// export function DangerAtRange ( unit , range ) ; begin
72946: LD_INT 0
72948: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72949: LD_ADDR_VAR 0 3
72953: PUSH
72954: LD_VAR 0 1
72958: PPUSH
72959: CALL_OW 255
72963: PPUSH
72964: LD_VAR 0 1
72968: PPUSH
72969: CALL_OW 250
72973: PPUSH
72974: LD_VAR 0 1
72978: PPUSH
72979: CALL_OW 251
72983: PPUSH
72984: LD_VAR 0 2
72988: PPUSH
72989: CALL 71249 0 4
72993: ST_TO_ADDR
// end ;
72994: LD_VAR 0 3
72998: RET
// export function DangerInArea ( side , area ) ; begin
72999: LD_INT 0
73001: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73002: LD_ADDR_VAR 0 3
73006: PUSH
73007: LD_VAR 0 2
73011: PPUSH
73012: LD_INT 81
73014: PUSH
73015: LD_VAR 0 1
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PPUSH
73024: CALL_OW 70
73028: ST_TO_ADDR
// end ;
73029: LD_VAR 0 3
73033: RET
// export function IsExtension ( b ) ; begin
73034: LD_INT 0
73036: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73037: LD_ADDR_VAR 0 2
73041: PUSH
73042: LD_VAR 0 1
73046: PUSH
73047: LD_INT 23
73049: PUSH
73050: LD_INT 20
73052: PUSH
73053: LD_INT 22
73055: PUSH
73056: LD_INT 17
73058: PUSH
73059: LD_INT 24
73061: PUSH
73062: LD_INT 21
73064: PUSH
73065: LD_INT 19
73067: PUSH
73068: LD_INT 16
73070: PUSH
73071: LD_INT 25
73073: PUSH
73074: LD_INT 18
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: IN
73089: ST_TO_ADDR
// end ;
73090: LD_VAR 0 2
73094: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73095: LD_INT 0
73097: PPUSH
73098: PPUSH
73099: PPUSH
// result := [ ] ;
73100: LD_ADDR_VAR 0 4
73104: PUSH
73105: EMPTY
73106: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73107: LD_ADDR_VAR 0 5
73111: PUSH
73112: LD_VAR 0 2
73116: PPUSH
73117: LD_INT 21
73119: PUSH
73120: LD_INT 3
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PPUSH
73127: CALL_OW 70
73131: ST_TO_ADDR
// if not tmp then
73132: LD_VAR 0 5
73136: NOT
73137: IFFALSE 73141
// exit ;
73139: GO 73205
// if checkLink then
73141: LD_VAR 0 3
73145: IFFALSE 73195
// begin for i in tmp do
73147: LD_ADDR_VAR 0 6
73151: PUSH
73152: LD_VAR 0 5
73156: PUSH
73157: FOR_IN
73158: IFFALSE 73193
// if GetBase ( i ) <> base then
73160: LD_VAR 0 6
73164: PPUSH
73165: CALL_OW 274
73169: PUSH
73170: LD_VAR 0 1
73174: NONEQUAL
73175: IFFALSE 73191
// ComLinkToBase ( base , i ) ;
73177: LD_VAR 0 1
73181: PPUSH
73182: LD_VAR 0 6
73186: PPUSH
73187: CALL_OW 169
73191: GO 73157
73193: POP
73194: POP
// end ; result := tmp ;
73195: LD_ADDR_VAR 0 4
73199: PUSH
73200: LD_VAR 0 5
73204: ST_TO_ADDR
// end ;
73205: LD_VAR 0 4
73209: RET
// export function ComComplete ( units , b ) ; var i ; begin
73210: LD_INT 0
73212: PPUSH
73213: PPUSH
// if not units then
73214: LD_VAR 0 1
73218: NOT
73219: IFFALSE 73223
// exit ;
73221: GO 73313
// for i in units do
73223: LD_ADDR_VAR 0 4
73227: PUSH
73228: LD_VAR 0 1
73232: PUSH
73233: FOR_IN
73234: IFFALSE 73311
// if BuildingStatus ( b ) = bs_build then
73236: LD_VAR 0 2
73240: PPUSH
73241: CALL_OW 461
73245: PUSH
73246: LD_INT 1
73248: EQUAL
73249: IFFALSE 73309
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73251: LD_VAR 0 4
73255: PPUSH
73256: LD_STRING h
73258: PUSH
73259: LD_VAR 0 2
73263: PPUSH
73264: CALL_OW 250
73268: PUSH
73269: LD_VAR 0 2
73273: PPUSH
73274: CALL_OW 251
73278: PUSH
73279: LD_VAR 0 2
73283: PUSH
73284: LD_INT 0
73286: PUSH
73287: LD_INT 0
73289: PUSH
73290: LD_INT 0
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: PUSH
73302: EMPTY
73303: LIST
73304: PPUSH
73305: CALL_OW 446
73309: GO 73233
73311: POP
73312: POP
// end ;
73313: LD_VAR 0 3
73317: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73318: LD_INT 0
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
73324: PPUSH
73325: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73326: LD_VAR 0 1
73330: NOT
73331: PUSH
73332: LD_VAR 0 1
73336: PPUSH
73337: CALL_OW 263
73341: PUSH
73342: LD_INT 2
73344: EQUAL
73345: NOT
73346: OR
73347: IFFALSE 73351
// exit ;
73349: GO 73667
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73351: LD_ADDR_VAR 0 6
73355: PUSH
73356: LD_INT 22
73358: PUSH
73359: LD_VAR 0 1
73363: PPUSH
73364: CALL_OW 255
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 2
73375: PUSH
73376: LD_INT 30
73378: PUSH
73379: LD_INT 36
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 34
73388: PUSH
73389: LD_INT 31
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: LIST
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PPUSH
73405: CALL_OW 69
73409: ST_TO_ADDR
// if not tmp then
73410: LD_VAR 0 6
73414: NOT
73415: IFFALSE 73419
// exit ;
73417: GO 73667
// result := [ ] ;
73419: LD_ADDR_VAR 0 2
73423: PUSH
73424: EMPTY
73425: ST_TO_ADDR
// for i in tmp do
73426: LD_ADDR_VAR 0 3
73430: PUSH
73431: LD_VAR 0 6
73435: PUSH
73436: FOR_IN
73437: IFFALSE 73508
// begin t := UnitsInside ( i ) ;
73439: LD_ADDR_VAR 0 4
73443: PUSH
73444: LD_VAR 0 3
73448: PPUSH
73449: CALL_OW 313
73453: ST_TO_ADDR
// if t then
73454: LD_VAR 0 4
73458: IFFALSE 73506
// for j in t do
73460: LD_ADDR_VAR 0 7
73464: PUSH
73465: LD_VAR 0 4
73469: PUSH
73470: FOR_IN
73471: IFFALSE 73504
// result := Insert ( result , result + 1 , j ) ;
73473: LD_ADDR_VAR 0 2
73477: PUSH
73478: LD_VAR 0 2
73482: PPUSH
73483: LD_VAR 0 2
73487: PUSH
73488: LD_INT 1
73490: PLUS
73491: PPUSH
73492: LD_VAR 0 7
73496: PPUSH
73497: CALL_OW 2
73501: ST_TO_ADDR
73502: GO 73470
73504: POP
73505: POP
// end ;
73506: GO 73436
73508: POP
73509: POP
// if not result then
73510: LD_VAR 0 2
73514: NOT
73515: IFFALSE 73519
// exit ;
73517: GO 73667
// mech := result [ 1 ] ;
73519: LD_ADDR_VAR 0 5
73523: PUSH
73524: LD_VAR 0 2
73528: PUSH
73529: LD_INT 1
73531: ARRAY
73532: ST_TO_ADDR
// if result > 1 then
73533: LD_VAR 0 2
73537: PUSH
73538: LD_INT 1
73540: GREATER
73541: IFFALSE 73653
// for i = 2 to result do
73543: LD_ADDR_VAR 0 3
73547: PUSH
73548: DOUBLE
73549: LD_INT 2
73551: DEC
73552: ST_TO_ADDR
73553: LD_VAR 0 2
73557: PUSH
73558: FOR_TO
73559: IFFALSE 73651
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73561: LD_ADDR_VAR 0 4
73565: PUSH
73566: LD_VAR 0 2
73570: PUSH
73571: LD_VAR 0 3
73575: ARRAY
73576: PPUSH
73577: LD_INT 3
73579: PPUSH
73580: CALL_OW 259
73584: PUSH
73585: LD_VAR 0 2
73589: PUSH
73590: LD_VAR 0 3
73594: ARRAY
73595: PPUSH
73596: CALL_OW 432
73600: MINUS
73601: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73602: LD_VAR 0 4
73606: PUSH
73607: LD_VAR 0 5
73611: PPUSH
73612: LD_INT 3
73614: PPUSH
73615: CALL_OW 259
73619: PUSH
73620: LD_VAR 0 5
73624: PPUSH
73625: CALL_OW 432
73629: MINUS
73630: GREATEREQUAL
73631: IFFALSE 73649
// mech := result [ i ] ;
73633: LD_ADDR_VAR 0 5
73637: PUSH
73638: LD_VAR 0 2
73642: PUSH
73643: LD_VAR 0 3
73647: ARRAY
73648: ST_TO_ADDR
// end ;
73649: GO 73558
73651: POP
73652: POP
// ComLinkTo ( vehicle , mech ) ;
73653: LD_VAR 0 1
73657: PPUSH
73658: LD_VAR 0 5
73662: PPUSH
73663: CALL_OW 135
// end ;
73667: LD_VAR 0 2
73671: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73672: LD_INT 0
73674: PPUSH
73675: PPUSH
73676: PPUSH
73677: PPUSH
73678: PPUSH
73679: PPUSH
73680: PPUSH
73681: PPUSH
73682: PPUSH
73683: PPUSH
73684: PPUSH
73685: PPUSH
73686: PPUSH
// result := [ ] ;
73687: LD_ADDR_VAR 0 7
73691: PUSH
73692: EMPTY
73693: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73694: LD_VAR 0 1
73698: PPUSH
73699: CALL_OW 266
73703: PUSH
73704: LD_INT 0
73706: PUSH
73707: LD_INT 1
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: IN
73714: NOT
73715: IFFALSE 73719
// exit ;
73717: GO 75353
// if name then
73719: LD_VAR 0 3
73723: IFFALSE 73739
// SetBName ( base_dep , name ) ;
73725: LD_VAR 0 1
73729: PPUSH
73730: LD_VAR 0 3
73734: PPUSH
73735: CALL_OW 500
// base := GetBase ( base_dep ) ;
73739: LD_ADDR_VAR 0 15
73743: PUSH
73744: LD_VAR 0 1
73748: PPUSH
73749: CALL_OW 274
73753: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73754: LD_ADDR_VAR 0 16
73758: PUSH
73759: LD_VAR 0 1
73763: PPUSH
73764: CALL_OW 255
73768: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73769: LD_ADDR_VAR 0 17
73773: PUSH
73774: LD_VAR 0 1
73778: PPUSH
73779: CALL_OW 248
73783: ST_TO_ADDR
// if sources then
73784: LD_VAR 0 5
73788: IFFALSE 73835
// for i = 1 to 3 do
73790: LD_ADDR_VAR 0 8
73794: PUSH
73795: DOUBLE
73796: LD_INT 1
73798: DEC
73799: ST_TO_ADDR
73800: LD_INT 3
73802: PUSH
73803: FOR_TO
73804: IFFALSE 73833
// AddResourceType ( base , i , sources [ i ] ) ;
73806: LD_VAR 0 15
73810: PPUSH
73811: LD_VAR 0 8
73815: PPUSH
73816: LD_VAR 0 5
73820: PUSH
73821: LD_VAR 0 8
73825: ARRAY
73826: PPUSH
73827: CALL_OW 276
73831: GO 73803
73833: POP
73834: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
73835: LD_ADDR_VAR 0 18
73839: PUSH
73840: LD_VAR 0 15
73844: PPUSH
73845: LD_VAR 0 2
73849: PPUSH
73850: LD_INT 1
73852: PPUSH
73853: CALL 73095 0 3
73857: ST_TO_ADDR
// InitHc ;
73858: CALL_OW 19
// InitUc ;
73862: CALL_OW 18
// uc_side := side ;
73866: LD_ADDR_OWVAR 20
73870: PUSH
73871: LD_VAR 0 16
73875: ST_TO_ADDR
// uc_nation := nation ;
73876: LD_ADDR_OWVAR 21
73880: PUSH
73881: LD_VAR 0 17
73885: ST_TO_ADDR
// if buildings then
73886: LD_VAR 0 18
73890: IFFALSE 75212
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73892: LD_ADDR_VAR 0 19
73896: PUSH
73897: LD_VAR 0 18
73901: PPUSH
73902: LD_INT 2
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: LD_INT 29
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 30
73917: PUSH
73918: LD_INT 30
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: LIST
73929: PPUSH
73930: CALL_OW 72
73934: ST_TO_ADDR
// if tmp then
73935: LD_VAR 0 19
73939: IFFALSE 73987
// for i in tmp do
73941: LD_ADDR_VAR 0 8
73945: PUSH
73946: LD_VAR 0 19
73950: PUSH
73951: FOR_IN
73952: IFFALSE 73985
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73954: LD_VAR 0 8
73958: PPUSH
73959: CALL_OW 250
73963: PPUSH
73964: LD_VAR 0 8
73968: PPUSH
73969: CALL_OW 251
73973: PPUSH
73974: LD_VAR 0 16
73978: PPUSH
73979: CALL_OW 441
73983: GO 73951
73985: POP
73986: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73987: LD_VAR 0 18
73991: PPUSH
73992: LD_INT 2
73994: PUSH
73995: LD_INT 30
73997: PUSH
73998: LD_INT 32
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 30
74007: PUSH
74008: LD_INT 33
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: LIST
74019: PPUSH
74020: CALL_OW 72
74024: IFFALSE 74112
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74026: LD_ADDR_VAR 0 8
74030: PUSH
74031: LD_VAR 0 18
74035: PPUSH
74036: LD_INT 2
74038: PUSH
74039: LD_INT 30
74041: PUSH
74042: LD_INT 32
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: LD_INT 30
74051: PUSH
74052: LD_INT 33
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: LIST
74063: PPUSH
74064: CALL_OW 72
74068: PUSH
74069: FOR_IN
74070: IFFALSE 74110
// begin if not GetBWeapon ( i ) then
74072: LD_VAR 0 8
74076: PPUSH
74077: CALL_OW 269
74081: NOT
74082: IFFALSE 74108
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74084: LD_VAR 0 8
74088: PPUSH
74089: LD_VAR 0 8
74093: PPUSH
74094: LD_VAR 0 2
74098: PPUSH
74099: CALL 75358 0 2
74103: PPUSH
74104: CALL_OW 431
// end ;
74108: GO 74069
74110: POP
74111: POP
// end ; for i = 1 to personel do
74112: LD_ADDR_VAR 0 8
74116: PUSH
74117: DOUBLE
74118: LD_INT 1
74120: DEC
74121: ST_TO_ADDR
74122: LD_VAR 0 6
74126: PUSH
74127: FOR_TO
74128: IFFALSE 75192
// begin if i > 4 then
74130: LD_VAR 0 8
74134: PUSH
74135: LD_INT 4
74137: GREATER
74138: IFFALSE 74142
// break ;
74140: GO 75192
// case i of 1 :
74142: LD_VAR 0 8
74146: PUSH
74147: LD_INT 1
74149: DOUBLE
74150: EQUAL
74151: IFTRUE 74155
74153: GO 74235
74155: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74156: LD_ADDR_VAR 0 12
74160: PUSH
74161: LD_VAR 0 18
74165: PPUSH
74166: LD_INT 22
74168: PUSH
74169: LD_VAR 0 16
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: LD_INT 58
74180: PUSH
74181: EMPTY
74182: LIST
74183: PUSH
74184: LD_INT 2
74186: PUSH
74187: LD_INT 30
74189: PUSH
74190: LD_INT 32
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 30
74199: PUSH
74200: LD_INT 4
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 30
74209: PUSH
74210: LD_INT 5
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: LIST
74227: PPUSH
74228: CALL_OW 72
74232: ST_TO_ADDR
74233: GO 74457
74235: LD_INT 2
74237: DOUBLE
74238: EQUAL
74239: IFTRUE 74243
74241: GO 74305
74243: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74244: LD_ADDR_VAR 0 12
74248: PUSH
74249: LD_VAR 0 18
74253: PPUSH
74254: LD_INT 22
74256: PUSH
74257: LD_VAR 0 16
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 2
74268: PUSH
74269: LD_INT 30
74271: PUSH
74272: LD_INT 0
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: PUSH
74279: LD_INT 30
74281: PUSH
74282: LD_INT 1
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: LIST
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PPUSH
74298: CALL_OW 72
74302: ST_TO_ADDR
74303: GO 74457
74305: LD_INT 3
74307: DOUBLE
74308: EQUAL
74309: IFTRUE 74313
74311: GO 74375
74313: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74314: LD_ADDR_VAR 0 12
74318: PUSH
74319: LD_VAR 0 18
74323: PPUSH
74324: LD_INT 22
74326: PUSH
74327: LD_VAR 0 16
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 2
74338: PUSH
74339: LD_INT 30
74341: PUSH
74342: LD_INT 2
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 30
74351: PUSH
74352: LD_INT 3
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: LIST
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PPUSH
74368: CALL_OW 72
74372: ST_TO_ADDR
74373: GO 74457
74375: LD_INT 4
74377: DOUBLE
74378: EQUAL
74379: IFTRUE 74383
74381: GO 74456
74383: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74384: LD_ADDR_VAR 0 12
74388: PUSH
74389: LD_VAR 0 18
74393: PPUSH
74394: LD_INT 22
74396: PUSH
74397: LD_VAR 0 16
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 2
74408: PUSH
74409: LD_INT 30
74411: PUSH
74412: LD_INT 6
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 30
74421: PUSH
74422: LD_INT 7
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 30
74431: PUSH
74432: LD_INT 8
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PPUSH
74449: CALL_OW 72
74453: ST_TO_ADDR
74454: GO 74457
74456: POP
// if i = 1 then
74457: LD_VAR 0 8
74461: PUSH
74462: LD_INT 1
74464: EQUAL
74465: IFFALSE 74576
// begin tmp := [ ] ;
74467: LD_ADDR_VAR 0 19
74471: PUSH
74472: EMPTY
74473: ST_TO_ADDR
// for j in f do
74474: LD_ADDR_VAR 0 9
74478: PUSH
74479: LD_VAR 0 12
74483: PUSH
74484: FOR_IN
74485: IFFALSE 74558
// if GetBType ( j ) = b_bunker then
74487: LD_VAR 0 9
74491: PPUSH
74492: CALL_OW 266
74496: PUSH
74497: LD_INT 32
74499: EQUAL
74500: IFFALSE 74527
// tmp := Insert ( tmp , 1 , j ) else
74502: LD_ADDR_VAR 0 19
74506: PUSH
74507: LD_VAR 0 19
74511: PPUSH
74512: LD_INT 1
74514: PPUSH
74515: LD_VAR 0 9
74519: PPUSH
74520: CALL_OW 2
74524: ST_TO_ADDR
74525: GO 74556
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74527: LD_ADDR_VAR 0 19
74531: PUSH
74532: LD_VAR 0 19
74536: PPUSH
74537: LD_VAR 0 19
74541: PUSH
74542: LD_INT 1
74544: PLUS
74545: PPUSH
74546: LD_VAR 0 9
74550: PPUSH
74551: CALL_OW 2
74555: ST_TO_ADDR
74556: GO 74484
74558: POP
74559: POP
// if tmp then
74560: LD_VAR 0 19
74564: IFFALSE 74576
// f := tmp ;
74566: LD_ADDR_VAR 0 12
74570: PUSH
74571: LD_VAR 0 19
74575: ST_TO_ADDR
// end ; x := personel [ i ] ;
74576: LD_ADDR_VAR 0 13
74580: PUSH
74581: LD_VAR 0 6
74585: PUSH
74586: LD_VAR 0 8
74590: ARRAY
74591: ST_TO_ADDR
// if x = - 1 then
74592: LD_VAR 0 13
74596: PUSH
74597: LD_INT 1
74599: NEG
74600: EQUAL
74601: IFFALSE 74810
// begin for j in f do
74603: LD_ADDR_VAR 0 9
74607: PUSH
74608: LD_VAR 0 12
74612: PUSH
74613: FOR_IN
74614: IFFALSE 74806
// repeat InitHc ;
74616: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74620: LD_VAR 0 9
74624: PPUSH
74625: CALL_OW 266
74629: PUSH
74630: LD_INT 5
74632: EQUAL
74633: IFFALSE 74703
// begin if UnitsInside ( j ) < 3 then
74635: LD_VAR 0 9
74639: PPUSH
74640: CALL_OW 313
74644: PUSH
74645: LD_INT 3
74647: LESS
74648: IFFALSE 74684
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74650: LD_INT 0
74652: PPUSH
74653: LD_INT 5
74655: PUSH
74656: LD_INT 8
74658: PUSH
74659: LD_INT 9
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: LIST
74666: PUSH
74667: LD_VAR 0 17
74671: ARRAY
74672: PPUSH
74673: LD_VAR 0 4
74677: PPUSH
74678: CALL_OW 380
74682: GO 74701
// PrepareHuman ( false , i , skill ) ;
74684: LD_INT 0
74686: PPUSH
74687: LD_VAR 0 8
74691: PPUSH
74692: LD_VAR 0 4
74696: PPUSH
74697: CALL_OW 380
// end else
74701: GO 74720
// PrepareHuman ( false , i , skill ) ;
74703: LD_INT 0
74705: PPUSH
74706: LD_VAR 0 8
74710: PPUSH
74711: LD_VAR 0 4
74715: PPUSH
74716: CALL_OW 380
// un := CreateHuman ;
74720: LD_ADDR_VAR 0 14
74724: PUSH
74725: CALL_OW 44
74729: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74730: LD_ADDR_VAR 0 7
74734: PUSH
74735: LD_VAR 0 7
74739: PPUSH
74740: LD_INT 1
74742: PPUSH
74743: LD_VAR 0 14
74747: PPUSH
74748: CALL_OW 2
74752: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74753: LD_VAR 0 14
74757: PPUSH
74758: LD_VAR 0 9
74762: PPUSH
74763: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74767: LD_VAR 0 9
74771: PPUSH
74772: CALL_OW 313
74776: PUSH
74777: LD_INT 6
74779: EQUAL
74780: PUSH
74781: LD_VAR 0 9
74785: PPUSH
74786: CALL_OW 266
74790: PUSH
74791: LD_INT 32
74793: PUSH
74794: LD_INT 31
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: IN
74801: OR
74802: IFFALSE 74616
74804: GO 74613
74806: POP
74807: POP
// end else
74808: GO 75190
// for j = 1 to x do
74810: LD_ADDR_VAR 0 9
74814: PUSH
74815: DOUBLE
74816: LD_INT 1
74818: DEC
74819: ST_TO_ADDR
74820: LD_VAR 0 13
74824: PUSH
74825: FOR_TO
74826: IFFALSE 75188
// begin InitHc ;
74828: CALL_OW 19
// if not f then
74832: LD_VAR 0 12
74836: NOT
74837: IFFALSE 74926
// begin PrepareHuman ( false , i , skill ) ;
74839: LD_INT 0
74841: PPUSH
74842: LD_VAR 0 8
74846: PPUSH
74847: LD_VAR 0 4
74851: PPUSH
74852: CALL_OW 380
// un := CreateHuman ;
74856: LD_ADDR_VAR 0 14
74860: PUSH
74861: CALL_OW 44
74865: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74866: LD_ADDR_VAR 0 7
74870: PUSH
74871: LD_VAR 0 7
74875: PPUSH
74876: LD_INT 1
74878: PPUSH
74879: LD_VAR 0 14
74883: PPUSH
74884: CALL_OW 2
74888: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74889: LD_VAR 0 14
74893: PPUSH
74894: LD_VAR 0 1
74898: PPUSH
74899: CALL_OW 250
74903: PPUSH
74904: LD_VAR 0 1
74908: PPUSH
74909: CALL_OW 251
74913: PPUSH
74914: LD_INT 10
74916: PPUSH
74917: LD_INT 0
74919: PPUSH
74920: CALL_OW 50
// continue ;
74924: GO 74825
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74926: LD_VAR 0 12
74930: PUSH
74931: LD_INT 1
74933: ARRAY
74934: PPUSH
74935: CALL_OW 313
74939: PUSH
74940: LD_VAR 0 12
74944: PUSH
74945: LD_INT 1
74947: ARRAY
74948: PPUSH
74949: CALL_OW 266
74953: PUSH
74954: LD_INT 32
74956: PUSH
74957: LD_INT 31
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: IN
74964: AND
74965: PUSH
74966: LD_VAR 0 12
74970: PUSH
74971: LD_INT 1
74973: ARRAY
74974: PPUSH
74975: CALL_OW 313
74979: PUSH
74980: LD_INT 6
74982: EQUAL
74983: OR
74984: IFFALSE 75004
// f := Delete ( f , 1 ) ;
74986: LD_ADDR_VAR 0 12
74990: PUSH
74991: LD_VAR 0 12
74995: PPUSH
74996: LD_INT 1
74998: PPUSH
74999: CALL_OW 3
75003: ST_TO_ADDR
// if not f then
75004: LD_VAR 0 12
75008: NOT
75009: IFFALSE 75027
// begin x := x + 2 ;
75011: LD_ADDR_VAR 0 13
75015: PUSH
75016: LD_VAR 0 13
75020: PUSH
75021: LD_INT 2
75023: PLUS
75024: ST_TO_ADDR
// continue ;
75025: GO 74825
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75027: LD_VAR 0 12
75031: PUSH
75032: LD_INT 1
75034: ARRAY
75035: PPUSH
75036: CALL_OW 266
75040: PUSH
75041: LD_INT 5
75043: EQUAL
75044: IFFALSE 75118
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75046: LD_VAR 0 12
75050: PUSH
75051: LD_INT 1
75053: ARRAY
75054: PPUSH
75055: CALL_OW 313
75059: PUSH
75060: LD_INT 3
75062: LESS
75063: IFFALSE 75099
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75065: LD_INT 0
75067: PPUSH
75068: LD_INT 5
75070: PUSH
75071: LD_INT 8
75073: PUSH
75074: LD_INT 9
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: LIST
75081: PUSH
75082: LD_VAR 0 17
75086: ARRAY
75087: PPUSH
75088: LD_VAR 0 4
75092: PPUSH
75093: CALL_OW 380
75097: GO 75116
// PrepareHuman ( false , i , skill ) ;
75099: LD_INT 0
75101: PPUSH
75102: LD_VAR 0 8
75106: PPUSH
75107: LD_VAR 0 4
75111: PPUSH
75112: CALL_OW 380
// end else
75116: GO 75135
// PrepareHuman ( false , i , skill ) ;
75118: LD_INT 0
75120: PPUSH
75121: LD_VAR 0 8
75125: PPUSH
75126: LD_VAR 0 4
75130: PPUSH
75131: CALL_OW 380
// un := CreateHuman ;
75135: LD_ADDR_VAR 0 14
75139: PUSH
75140: CALL_OW 44
75144: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75145: LD_ADDR_VAR 0 7
75149: PUSH
75150: LD_VAR 0 7
75154: PPUSH
75155: LD_INT 1
75157: PPUSH
75158: LD_VAR 0 14
75162: PPUSH
75163: CALL_OW 2
75167: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75168: LD_VAR 0 14
75172: PPUSH
75173: LD_VAR 0 12
75177: PUSH
75178: LD_INT 1
75180: ARRAY
75181: PPUSH
75182: CALL_OW 52
// end ;
75186: GO 74825
75188: POP
75189: POP
// end ;
75190: GO 74127
75192: POP
75193: POP
// result := result ^ buildings ;
75194: LD_ADDR_VAR 0 7
75198: PUSH
75199: LD_VAR 0 7
75203: PUSH
75204: LD_VAR 0 18
75208: ADD
75209: ST_TO_ADDR
// end else
75210: GO 75353
// begin for i = 1 to personel do
75212: LD_ADDR_VAR 0 8
75216: PUSH
75217: DOUBLE
75218: LD_INT 1
75220: DEC
75221: ST_TO_ADDR
75222: LD_VAR 0 6
75226: PUSH
75227: FOR_TO
75228: IFFALSE 75351
// begin if i > 4 then
75230: LD_VAR 0 8
75234: PUSH
75235: LD_INT 4
75237: GREATER
75238: IFFALSE 75242
// break ;
75240: GO 75351
// x := personel [ i ] ;
75242: LD_ADDR_VAR 0 13
75246: PUSH
75247: LD_VAR 0 6
75251: PUSH
75252: LD_VAR 0 8
75256: ARRAY
75257: ST_TO_ADDR
// if x = - 1 then
75258: LD_VAR 0 13
75262: PUSH
75263: LD_INT 1
75265: NEG
75266: EQUAL
75267: IFFALSE 75271
// continue ;
75269: GO 75227
// PrepareHuman ( false , i , skill ) ;
75271: LD_INT 0
75273: PPUSH
75274: LD_VAR 0 8
75278: PPUSH
75279: LD_VAR 0 4
75283: PPUSH
75284: CALL_OW 380
// un := CreateHuman ;
75288: LD_ADDR_VAR 0 14
75292: PUSH
75293: CALL_OW 44
75297: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75298: LD_VAR 0 14
75302: PPUSH
75303: LD_VAR 0 1
75307: PPUSH
75308: CALL_OW 250
75312: PPUSH
75313: LD_VAR 0 1
75317: PPUSH
75318: CALL_OW 251
75322: PPUSH
75323: LD_INT 10
75325: PPUSH
75326: LD_INT 0
75328: PPUSH
75329: CALL_OW 50
// result := result ^ un ;
75333: LD_ADDR_VAR 0 7
75337: PUSH
75338: LD_VAR 0 7
75342: PUSH
75343: LD_VAR 0 14
75347: ADD
75348: ST_TO_ADDR
// end ;
75349: GO 75227
75351: POP
75352: POP
// end ; end ;
75353: LD_VAR 0 7
75357: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75358: LD_INT 0
75360: PPUSH
75361: PPUSH
75362: PPUSH
75363: PPUSH
75364: PPUSH
75365: PPUSH
75366: PPUSH
75367: PPUSH
75368: PPUSH
75369: PPUSH
75370: PPUSH
75371: PPUSH
75372: PPUSH
75373: PPUSH
75374: PPUSH
75375: PPUSH
// result := false ;
75376: LD_ADDR_VAR 0 3
75380: PUSH
75381: LD_INT 0
75383: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75384: LD_VAR 0 1
75388: NOT
75389: PUSH
75390: LD_VAR 0 1
75394: PPUSH
75395: CALL_OW 266
75399: PUSH
75400: LD_INT 32
75402: PUSH
75403: LD_INT 33
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: IN
75410: NOT
75411: OR
75412: IFFALSE 75416
// exit ;
75414: GO 76555
// nat := GetNation ( tower ) ;
75416: LD_ADDR_VAR 0 12
75420: PUSH
75421: LD_VAR 0 1
75425: PPUSH
75426: CALL_OW 248
75430: ST_TO_ADDR
// side := GetSide ( tower ) ;
75431: LD_ADDR_VAR 0 16
75435: PUSH
75436: LD_VAR 0 1
75440: PPUSH
75441: CALL_OW 255
75445: ST_TO_ADDR
// x := GetX ( tower ) ;
75446: LD_ADDR_VAR 0 10
75450: PUSH
75451: LD_VAR 0 1
75455: PPUSH
75456: CALL_OW 250
75460: ST_TO_ADDR
// y := GetY ( tower ) ;
75461: LD_ADDR_VAR 0 11
75465: PUSH
75466: LD_VAR 0 1
75470: PPUSH
75471: CALL_OW 251
75475: ST_TO_ADDR
// if not x or not y then
75476: LD_VAR 0 10
75480: NOT
75481: PUSH
75482: LD_VAR 0 11
75486: NOT
75487: OR
75488: IFFALSE 75492
// exit ;
75490: GO 76555
// weapon := 0 ;
75492: LD_ADDR_VAR 0 18
75496: PUSH
75497: LD_INT 0
75499: ST_TO_ADDR
// fac_list := [ ] ;
75500: LD_ADDR_VAR 0 17
75504: PUSH
75505: EMPTY
75506: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
75507: LD_ADDR_VAR 0 6
75511: PUSH
75512: LD_VAR 0 1
75516: PPUSH
75517: CALL_OW 274
75521: PPUSH
75522: LD_VAR 0 2
75526: PPUSH
75527: LD_INT 0
75529: PPUSH
75530: CALL 73095 0 3
75534: PPUSH
75535: LD_INT 30
75537: PUSH
75538: LD_INT 3
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PPUSH
75545: CALL_OW 72
75549: ST_TO_ADDR
// if not factories then
75550: LD_VAR 0 6
75554: NOT
75555: IFFALSE 75559
// exit ;
75557: GO 76555
// for i in factories do
75559: LD_ADDR_VAR 0 8
75563: PUSH
75564: LD_VAR 0 6
75568: PUSH
75569: FOR_IN
75570: IFFALSE 75595
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75572: LD_ADDR_VAR 0 17
75576: PUSH
75577: LD_VAR 0 17
75581: PUSH
75582: LD_VAR 0 8
75586: PPUSH
75587: CALL_OW 478
75591: UNION
75592: ST_TO_ADDR
75593: GO 75569
75595: POP
75596: POP
// if not fac_list then
75597: LD_VAR 0 17
75601: NOT
75602: IFFALSE 75606
// exit ;
75604: GO 76555
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75606: LD_ADDR_VAR 0 5
75610: PUSH
75611: LD_INT 4
75613: PUSH
75614: LD_INT 5
75616: PUSH
75617: LD_INT 9
75619: PUSH
75620: LD_INT 10
75622: PUSH
75623: LD_INT 6
75625: PUSH
75626: LD_INT 7
75628: PUSH
75629: LD_INT 11
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 27
75643: PUSH
75644: LD_INT 28
75646: PUSH
75647: LD_INT 26
75649: PUSH
75650: LD_INT 30
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 43
75661: PUSH
75662: LD_INT 44
75664: PUSH
75665: LD_INT 46
75667: PUSH
75668: LD_INT 45
75670: PUSH
75671: LD_INT 47
75673: PUSH
75674: LD_INT 49
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: LIST
75681: LIST
75682: LIST
75683: LIST
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: LIST
75689: PUSH
75690: LD_VAR 0 12
75694: ARRAY
75695: ST_TO_ADDR
// for i in list do
75696: LD_ADDR_VAR 0 8
75700: PUSH
75701: LD_VAR 0 5
75705: PUSH
75706: FOR_IN
75707: IFFALSE 75740
// if not i in fac_list then
75709: LD_VAR 0 8
75713: PUSH
75714: LD_VAR 0 17
75718: IN
75719: NOT
75720: IFFALSE 75738
// list := list diff i ;
75722: LD_ADDR_VAR 0 5
75726: PUSH
75727: LD_VAR 0 5
75731: PUSH
75732: LD_VAR 0 8
75736: DIFF
75737: ST_TO_ADDR
75738: GO 75706
75740: POP
75741: POP
// if not list then
75742: LD_VAR 0 5
75746: NOT
75747: IFFALSE 75751
// exit ;
75749: GO 76555
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75751: LD_VAR 0 12
75755: PUSH
75756: LD_INT 3
75758: EQUAL
75759: PUSH
75760: LD_INT 49
75762: PUSH
75763: LD_VAR 0 5
75767: IN
75768: AND
75769: PUSH
75770: LD_INT 31
75772: PPUSH
75773: LD_VAR 0 16
75777: PPUSH
75778: CALL_OW 321
75782: PUSH
75783: LD_INT 2
75785: EQUAL
75786: AND
75787: IFFALSE 75847
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75789: LD_INT 22
75791: PUSH
75792: LD_VAR 0 16
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 35
75803: PUSH
75804: LD_INT 49
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 91
75813: PUSH
75814: LD_VAR 0 1
75818: PUSH
75819: LD_INT 10
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: LIST
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: LIST
75831: PPUSH
75832: CALL_OW 69
75836: NOT
75837: IFFALSE 75847
// weapon := ru_time_lapser ;
75839: LD_ADDR_VAR 0 18
75843: PUSH
75844: LD_INT 49
75846: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75847: LD_VAR 0 12
75851: PUSH
75852: LD_INT 1
75854: PUSH
75855: LD_INT 2
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: IN
75862: PUSH
75863: LD_INT 11
75865: PUSH
75866: LD_VAR 0 5
75870: IN
75871: PUSH
75872: LD_INT 30
75874: PUSH
75875: LD_VAR 0 5
75879: IN
75880: OR
75881: AND
75882: PUSH
75883: LD_INT 6
75885: PPUSH
75886: LD_VAR 0 16
75890: PPUSH
75891: CALL_OW 321
75895: PUSH
75896: LD_INT 2
75898: EQUAL
75899: AND
75900: IFFALSE 76065
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75902: LD_INT 22
75904: PUSH
75905: LD_VAR 0 16
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 2
75916: PUSH
75917: LD_INT 35
75919: PUSH
75920: LD_INT 11
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 35
75929: PUSH
75930: LD_INT 30
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 91
75944: PUSH
75945: LD_VAR 0 1
75949: PUSH
75950: LD_INT 18
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: LIST
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: LIST
75962: PPUSH
75963: CALL_OW 69
75967: NOT
75968: PUSH
75969: LD_INT 22
75971: PUSH
75972: LD_VAR 0 16
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 2
75983: PUSH
75984: LD_INT 30
75986: PUSH
75987: LD_INT 32
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 30
75996: PUSH
75997: LD_INT 33
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 91
76011: PUSH
76012: LD_VAR 0 1
76016: PUSH
76017: LD_INT 12
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: LIST
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: LIST
76029: PUSH
76030: EMPTY
76031: LIST
76032: PPUSH
76033: CALL_OW 69
76037: PUSH
76038: LD_INT 2
76040: GREATER
76041: AND
76042: IFFALSE 76065
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76044: LD_ADDR_VAR 0 18
76048: PUSH
76049: LD_INT 11
76051: PUSH
76052: LD_INT 30
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_VAR 0 12
76063: ARRAY
76064: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76065: LD_VAR 0 18
76069: NOT
76070: PUSH
76071: LD_INT 40
76073: PPUSH
76074: LD_VAR 0 16
76078: PPUSH
76079: CALL_OW 321
76083: PUSH
76084: LD_INT 2
76086: EQUAL
76087: AND
76088: PUSH
76089: LD_INT 7
76091: PUSH
76092: LD_VAR 0 5
76096: IN
76097: PUSH
76098: LD_INT 28
76100: PUSH
76101: LD_VAR 0 5
76105: IN
76106: OR
76107: PUSH
76108: LD_INT 45
76110: PUSH
76111: LD_VAR 0 5
76115: IN
76116: OR
76117: AND
76118: IFFALSE 76372
// begin hex := GetHexInfo ( x , y ) ;
76120: LD_ADDR_VAR 0 4
76124: PUSH
76125: LD_VAR 0 10
76129: PPUSH
76130: LD_VAR 0 11
76134: PPUSH
76135: CALL_OW 546
76139: ST_TO_ADDR
// if hex [ 1 ] then
76140: LD_VAR 0 4
76144: PUSH
76145: LD_INT 1
76147: ARRAY
76148: IFFALSE 76152
// exit ;
76150: GO 76555
// height := hex [ 2 ] ;
76152: LD_ADDR_VAR 0 15
76156: PUSH
76157: LD_VAR 0 4
76161: PUSH
76162: LD_INT 2
76164: ARRAY
76165: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76166: LD_ADDR_VAR 0 14
76170: PUSH
76171: LD_INT 0
76173: PUSH
76174: LD_INT 2
76176: PUSH
76177: LD_INT 3
76179: PUSH
76180: LD_INT 5
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: ST_TO_ADDR
// for i in tmp do
76189: LD_ADDR_VAR 0 8
76193: PUSH
76194: LD_VAR 0 14
76198: PUSH
76199: FOR_IN
76200: IFFALSE 76370
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76202: LD_ADDR_VAR 0 9
76206: PUSH
76207: LD_VAR 0 10
76211: PPUSH
76212: LD_VAR 0 8
76216: PPUSH
76217: LD_INT 5
76219: PPUSH
76220: CALL_OW 272
76224: PUSH
76225: LD_VAR 0 11
76229: PPUSH
76230: LD_VAR 0 8
76234: PPUSH
76235: LD_INT 5
76237: PPUSH
76238: CALL_OW 273
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76247: LD_VAR 0 9
76251: PUSH
76252: LD_INT 1
76254: ARRAY
76255: PPUSH
76256: LD_VAR 0 9
76260: PUSH
76261: LD_INT 2
76263: ARRAY
76264: PPUSH
76265: CALL_OW 488
76269: IFFALSE 76368
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76271: LD_ADDR_VAR 0 4
76275: PUSH
76276: LD_VAR 0 9
76280: PUSH
76281: LD_INT 1
76283: ARRAY
76284: PPUSH
76285: LD_VAR 0 9
76289: PUSH
76290: LD_INT 2
76292: ARRAY
76293: PPUSH
76294: CALL_OW 546
76298: ST_TO_ADDR
// if hex [ 1 ] then
76299: LD_VAR 0 4
76303: PUSH
76304: LD_INT 1
76306: ARRAY
76307: IFFALSE 76311
// continue ;
76309: GO 76199
// h := hex [ 2 ] ;
76311: LD_ADDR_VAR 0 13
76315: PUSH
76316: LD_VAR 0 4
76320: PUSH
76321: LD_INT 2
76323: ARRAY
76324: ST_TO_ADDR
// if h + 7 < height then
76325: LD_VAR 0 13
76329: PUSH
76330: LD_INT 7
76332: PLUS
76333: PUSH
76334: LD_VAR 0 15
76338: LESS
76339: IFFALSE 76368
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76341: LD_ADDR_VAR 0 18
76345: PUSH
76346: LD_INT 7
76348: PUSH
76349: LD_INT 28
76351: PUSH
76352: LD_INT 45
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: LIST
76359: PUSH
76360: LD_VAR 0 12
76364: ARRAY
76365: ST_TO_ADDR
// break ;
76366: GO 76370
// end ; end ; end ;
76368: GO 76199
76370: POP
76371: POP
// end ; if not weapon then
76372: LD_VAR 0 18
76376: NOT
76377: IFFALSE 76437
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76379: LD_ADDR_VAR 0 5
76383: PUSH
76384: LD_VAR 0 5
76388: PUSH
76389: LD_INT 11
76391: PUSH
76392: LD_INT 30
76394: PUSH
76395: LD_INT 49
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: LIST
76402: DIFF
76403: ST_TO_ADDR
// if not list then
76404: LD_VAR 0 5
76408: NOT
76409: IFFALSE 76413
// exit ;
76411: GO 76555
// weapon := list [ rand ( 1 , list ) ] ;
76413: LD_ADDR_VAR 0 18
76417: PUSH
76418: LD_VAR 0 5
76422: PUSH
76423: LD_INT 1
76425: PPUSH
76426: LD_VAR 0 5
76430: PPUSH
76431: CALL_OW 12
76435: ARRAY
76436: ST_TO_ADDR
// end ; if weapon then
76437: LD_VAR 0 18
76441: IFFALSE 76555
// begin tmp := CostOfWeapon ( weapon ) ;
76443: LD_ADDR_VAR 0 14
76447: PUSH
76448: LD_VAR 0 18
76452: PPUSH
76453: CALL_OW 451
76457: ST_TO_ADDR
// j := GetBase ( tower ) ;
76458: LD_ADDR_VAR 0 9
76462: PUSH
76463: LD_VAR 0 1
76467: PPUSH
76468: CALL_OW 274
76472: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76473: LD_VAR 0 9
76477: PPUSH
76478: LD_INT 1
76480: PPUSH
76481: CALL_OW 275
76485: PUSH
76486: LD_VAR 0 14
76490: PUSH
76491: LD_INT 1
76493: ARRAY
76494: GREATEREQUAL
76495: PUSH
76496: LD_VAR 0 9
76500: PPUSH
76501: LD_INT 2
76503: PPUSH
76504: CALL_OW 275
76508: PUSH
76509: LD_VAR 0 14
76513: PUSH
76514: LD_INT 2
76516: ARRAY
76517: GREATEREQUAL
76518: AND
76519: PUSH
76520: LD_VAR 0 9
76524: PPUSH
76525: LD_INT 3
76527: PPUSH
76528: CALL_OW 275
76532: PUSH
76533: LD_VAR 0 14
76537: PUSH
76538: LD_INT 3
76540: ARRAY
76541: GREATEREQUAL
76542: AND
76543: IFFALSE 76555
// result := weapon ;
76545: LD_ADDR_VAR 0 3
76549: PUSH
76550: LD_VAR 0 18
76554: ST_TO_ADDR
// end ; end ;
76555: LD_VAR 0 3
76559: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76560: LD_INT 0
76562: PPUSH
76563: PPUSH
// result := true ;
76564: LD_ADDR_VAR 0 3
76568: PUSH
76569: LD_INT 1
76571: ST_TO_ADDR
// if array1 = array2 then
76572: LD_VAR 0 1
76576: PUSH
76577: LD_VAR 0 2
76581: EQUAL
76582: IFFALSE 76642
// begin for i = 1 to array1 do
76584: LD_ADDR_VAR 0 4
76588: PUSH
76589: DOUBLE
76590: LD_INT 1
76592: DEC
76593: ST_TO_ADDR
76594: LD_VAR 0 1
76598: PUSH
76599: FOR_TO
76600: IFFALSE 76638
// if array1 [ i ] <> array2 [ i ] then
76602: LD_VAR 0 1
76606: PUSH
76607: LD_VAR 0 4
76611: ARRAY
76612: PUSH
76613: LD_VAR 0 2
76617: PUSH
76618: LD_VAR 0 4
76622: ARRAY
76623: NONEQUAL
76624: IFFALSE 76636
// begin result := false ;
76626: LD_ADDR_VAR 0 3
76630: PUSH
76631: LD_INT 0
76633: ST_TO_ADDR
// break ;
76634: GO 76638
// end ;
76636: GO 76599
76638: POP
76639: POP
// end else
76640: GO 76650
// result := false ;
76642: LD_ADDR_VAR 0 3
76646: PUSH
76647: LD_INT 0
76649: ST_TO_ADDR
// end ;
76650: LD_VAR 0 3
76654: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
76655: LD_INT 0
76657: PPUSH
76658: PPUSH
// if not array1 or not array2 then
76659: LD_VAR 0 1
76663: NOT
76664: PUSH
76665: LD_VAR 0 2
76669: NOT
76670: OR
76671: IFFALSE 76675
// exit ;
76673: GO 76739
// result := true ;
76675: LD_ADDR_VAR 0 3
76679: PUSH
76680: LD_INT 1
76682: ST_TO_ADDR
// for i = 1 to array1 do
76683: LD_ADDR_VAR 0 4
76687: PUSH
76688: DOUBLE
76689: LD_INT 1
76691: DEC
76692: ST_TO_ADDR
76693: LD_VAR 0 1
76697: PUSH
76698: FOR_TO
76699: IFFALSE 76737
// if array1 [ i ] <> array2 [ i ] then
76701: LD_VAR 0 1
76705: PUSH
76706: LD_VAR 0 4
76710: ARRAY
76711: PUSH
76712: LD_VAR 0 2
76716: PUSH
76717: LD_VAR 0 4
76721: ARRAY
76722: NONEQUAL
76723: IFFALSE 76735
// begin result := false ;
76725: LD_ADDR_VAR 0 3
76729: PUSH
76730: LD_INT 0
76732: ST_TO_ADDR
// break ;
76733: GO 76737
// end ;
76735: GO 76698
76737: POP
76738: POP
// end ;
76739: LD_VAR 0 3
76743: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76744: LD_INT 0
76746: PPUSH
76747: PPUSH
76748: PPUSH
// pom := GetBase ( fac ) ;
76749: LD_ADDR_VAR 0 5
76753: PUSH
76754: LD_VAR 0 1
76758: PPUSH
76759: CALL_OW 274
76763: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76764: LD_ADDR_VAR 0 4
76768: PUSH
76769: LD_VAR 0 2
76773: PUSH
76774: LD_INT 1
76776: ARRAY
76777: PPUSH
76778: LD_VAR 0 2
76782: PUSH
76783: LD_INT 2
76785: ARRAY
76786: PPUSH
76787: LD_VAR 0 2
76791: PUSH
76792: LD_INT 3
76794: ARRAY
76795: PPUSH
76796: LD_VAR 0 2
76800: PUSH
76801: LD_INT 4
76803: ARRAY
76804: PPUSH
76805: CALL_OW 449
76809: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76810: LD_ADDR_VAR 0 3
76814: PUSH
76815: LD_VAR 0 5
76819: PPUSH
76820: LD_INT 1
76822: PPUSH
76823: CALL_OW 275
76827: PUSH
76828: LD_VAR 0 4
76832: PUSH
76833: LD_INT 1
76835: ARRAY
76836: GREATEREQUAL
76837: PUSH
76838: LD_VAR 0 5
76842: PPUSH
76843: LD_INT 2
76845: PPUSH
76846: CALL_OW 275
76850: PUSH
76851: LD_VAR 0 4
76855: PUSH
76856: LD_INT 2
76858: ARRAY
76859: GREATEREQUAL
76860: AND
76861: PUSH
76862: LD_VAR 0 5
76866: PPUSH
76867: LD_INT 3
76869: PPUSH
76870: CALL_OW 275
76874: PUSH
76875: LD_VAR 0 4
76879: PUSH
76880: LD_INT 3
76882: ARRAY
76883: GREATEREQUAL
76884: AND
76885: ST_TO_ADDR
// end ;
76886: LD_VAR 0 3
76890: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76891: LD_INT 0
76893: PPUSH
76894: PPUSH
76895: PPUSH
76896: PPUSH
// pom := GetBase ( building ) ;
76897: LD_ADDR_VAR 0 3
76901: PUSH
76902: LD_VAR 0 1
76906: PPUSH
76907: CALL_OW 274
76911: ST_TO_ADDR
// if not pom then
76912: LD_VAR 0 3
76916: NOT
76917: IFFALSE 76921
// exit ;
76919: GO 77091
// btype := GetBType ( building ) ;
76921: LD_ADDR_VAR 0 5
76925: PUSH
76926: LD_VAR 0 1
76930: PPUSH
76931: CALL_OW 266
76935: ST_TO_ADDR
// if btype = b_armoury then
76936: LD_VAR 0 5
76940: PUSH
76941: LD_INT 4
76943: EQUAL
76944: IFFALSE 76954
// btype := b_barracks ;
76946: LD_ADDR_VAR 0 5
76950: PUSH
76951: LD_INT 5
76953: ST_TO_ADDR
// if btype = b_depot then
76954: LD_VAR 0 5
76958: PUSH
76959: LD_INT 0
76961: EQUAL
76962: IFFALSE 76972
// btype := b_warehouse ;
76964: LD_ADDR_VAR 0 5
76968: PUSH
76969: LD_INT 1
76971: ST_TO_ADDR
// if btype = b_workshop then
76972: LD_VAR 0 5
76976: PUSH
76977: LD_INT 2
76979: EQUAL
76980: IFFALSE 76990
// btype := b_factory ;
76982: LD_ADDR_VAR 0 5
76986: PUSH
76987: LD_INT 3
76989: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76990: LD_ADDR_VAR 0 4
76994: PUSH
76995: LD_VAR 0 5
76999: PPUSH
77000: LD_VAR 0 1
77004: PPUSH
77005: CALL_OW 248
77009: PPUSH
77010: CALL_OW 450
77014: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77015: LD_ADDR_VAR 0 2
77019: PUSH
77020: LD_VAR 0 3
77024: PPUSH
77025: LD_INT 1
77027: PPUSH
77028: CALL_OW 275
77032: PUSH
77033: LD_VAR 0 4
77037: PUSH
77038: LD_INT 1
77040: ARRAY
77041: GREATEREQUAL
77042: PUSH
77043: LD_VAR 0 3
77047: PPUSH
77048: LD_INT 2
77050: PPUSH
77051: CALL_OW 275
77055: PUSH
77056: LD_VAR 0 4
77060: PUSH
77061: LD_INT 2
77063: ARRAY
77064: GREATEREQUAL
77065: AND
77066: PUSH
77067: LD_VAR 0 3
77071: PPUSH
77072: LD_INT 3
77074: PPUSH
77075: CALL_OW 275
77079: PUSH
77080: LD_VAR 0 4
77084: PUSH
77085: LD_INT 3
77087: ARRAY
77088: GREATEREQUAL
77089: AND
77090: ST_TO_ADDR
// end ;
77091: LD_VAR 0 2
77095: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77096: LD_INT 0
77098: PPUSH
77099: PPUSH
77100: PPUSH
// pom := GetBase ( building ) ;
77101: LD_ADDR_VAR 0 4
77105: PUSH
77106: LD_VAR 0 1
77110: PPUSH
77111: CALL_OW 274
77115: ST_TO_ADDR
// if not pom then
77116: LD_VAR 0 4
77120: NOT
77121: IFFALSE 77125
// exit ;
77123: GO 77226
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77125: LD_ADDR_VAR 0 5
77129: PUSH
77130: LD_VAR 0 2
77134: PPUSH
77135: LD_VAR 0 1
77139: PPUSH
77140: CALL_OW 248
77144: PPUSH
77145: CALL_OW 450
77149: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77150: LD_ADDR_VAR 0 3
77154: PUSH
77155: LD_VAR 0 4
77159: PPUSH
77160: LD_INT 1
77162: PPUSH
77163: CALL_OW 275
77167: PUSH
77168: LD_VAR 0 5
77172: PUSH
77173: LD_INT 1
77175: ARRAY
77176: GREATEREQUAL
77177: PUSH
77178: LD_VAR 0 4
77182: PPUSH
77183: LD_INT 2
77185: PPUSH
77186: CALL_OW 275
77190: PUSH
77191: LD_VAR 0 5
77195: PUSH
77196: LD_INT 2
77198: ARRAY
77199: GREATEREQUAL
77200: AND
77201: PUSH
77202: LD_VAR 0 4
77206: PPUSH
77207: LD_INT 3
77209: PPUSH
77210: CALL_OW 275
77214: PUSH
77215: LD_VAR 0 5
77219: PUSH
77220: LD_INT 3
77222: ARRAY
77223: GREATEREQUAL
77224: AND
77225: ST_TO_ADDR
// end ;
77226: LD_VAR 0 3
77230: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77231: LD_INT 0
77233: PPUSH
77234: PPUSH
77235: PPUSH
77236: PPUSH
77237: PPUSH
77238: PPUSH
77239: PPUSH
77240: PPUSH
77241: PPUSH
77242: PPUSH
77243: PPUSH
// result := false ;
77244: LD_ADDR_VAR 0 8
77248: PUSH
77249: LD_INT 0
77251: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77252: LD_VAR 0 5
77256: NOT
77257: PUSH
77258: LD_VAR 0 1
77262: NOT
77263: OR
77264: PUSH
77265: LD_VAR 0 2
77269: NOT
77270: OR
77271: PUSH
77272: LD_VAR 0 3
77276: NOT
77277: OR
77278: IFFALSE 77282
// exit ;
77280: GO 78096
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77282: LD_ADDR_VAR 0 14
77286: PUSH
77287: LD_VAR 0 1
77291: PPUSH
77292: LD_VAR 0 2
77296: PPUSH
77297: LD_VAR 0 3
77301: PPUSH
77302: LD_VAR 0 4
77306: PPUSH
77307: LD_VAR 0 5
77311: PUSH
77312: LD_INT 1
77314: ARRAY
77315: PPUSH
77316: CALL_OW 248
77320: PPUSH
77321: LD_INT 0
77323: PPUSH
77324: CALL 78933 0 6
77328: ST_TO_ADDR
// if not hexes then
77329: LD_VAR 0 14
77333: NOT
77334: IFFALSE 77338
// exit ;
77336: GO 78096
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77338: LD_ADDR_VAR 0 17
77342: PUSH
77343: LD_VAR 0 5
77347: PPUSH
77348: LD_INT 22
77350: PUSH
77351: LD_VAR 0 13
77355: PPUSH
77356: CALL_OW 255
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 2
77367: PUSH
77368: LD_INT 30
77370: PUSH
77371: LD_INT 0
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 30
77380: PUSH
77381: LD_INT 1
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: LIST
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PPUSH
77397: CALL_OW 72
77401: ST_TO_ADDR
// for i = 1 to hexes do
77402: LD_ADDR_VAR 0 9
77406: PUSH
77407: DOUBLE
77408: LD_INT 1
77410: DEC
77411: ST_TO_ADDR
77412: LD_VAR 0 14
77416: PUSH
77417: FOR_TO
77418: IFFALSE 78094
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77420: LD_ADDR_VAR 0 13
77424: PUSH
77425: LD_VAR 0 14
77429: PUSH
77430: LD_VAR 0 9
77434: ARRAY
77435: PUSH
77436: LD_INT 1
77438: ARRAY
77439: PPUSH
77440: LD_VAR 0 14
77444: PUSH
77445: LD_VAR 0 9
77449: ARRAY
77450: PUSH
77451: LD_INT 2
77453: ARRAY
77454: PPUSH
77455: CALL_OW 428
77459: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77460: LD_VAR 0 14
77464: PUSH
77465: LD_VAR 0 9
77469: ARRAY
77470: PUSH
77471: LD_INT 1
77473: ARRAY
77474: PPUSH
77475: LD_VAR 0 14
77479: PUSH
77480: LD_VAR 0 9
77484: ARRAY
77485: PUSH
77486: LD_INT 2
77488: ARRAY
77489: PPUSH
77490: CALL_OW 351
77494: PUSH
77495: LD_VAR 0 14
77499: PUSH
77500: LD_VAR 0 9
77504: ARRAY
77505: PUSH
77506: LD_INT 1
77508: ARRAY
77509: PPUSH
77510: LD_VAR 0 14
77514: PUSH
77515: LD_VAR 0 9
77519: ARRAY
77520: PUSH
77521: LD_INT 2
77523: ARRAY
77524: PPUSH
77525: CALL_OW 488
77529: NOT
77530: OR
77531: PUSH
77532: LD_VAR 0 13
77536: PPUSH
77537: CALL_OW 247
77541: PUSH
77542: LD_INT 3
77544: EQUAL
77545: OR
77546: IFFALSE 77552
// exit ;
77548: POP
77549: POP
77550: GO 78096
// if not tmp then
77552: LD_VAR 0 13
77556: NOT
77557: IFFALSE 77561
// continue ;
77559: GO 77417
// result := true ;
77561: LD_ADDR_VAR 0 8
77565: PUSH
77566: LD_INT 1
77568: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
77569: LD_VAR 0 6
77573: PUSH
77574: LD_VAR 0 13
77578: PPUSH
77579: CALL_OW 247
77583: PUSH
77584: LD_INT 2
77586: EQUAL
77587: AND
77588: PUSH
77589: LD_VAR 0 13
77593: PPUSH
77594: CALL_OW 263
77598: PUSH
77599: LD_INT 1
77601: EQUAL
77602: AND
77603: IFFALSE 77767
// begin if IsDrivenBy ( tmp ) then
77605: LD_VAR 0 13
77609: PPUSH
77610: CALL_OW 311
77614: IFFALSE 77618
// continue ;
77616: GO 77417
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
77618: LD_VAR 0 6
77622: PPUSH
77623: LD_INT 3
77625: PUSH
77626: LD_INT 60
77628: PUSH
77629: EMPTY
77630: LIST
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 3
77638: PUSH
77639: LD_INT 55
77641: PUSH
77642: EMPTY
77643: LIST
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PPUSH
77653: CALL_OW 72
77657: IFFALSE 77765
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
77659: LD_ADDR_VAR 0 18
77663: PUSH
77664: LD_VAR 0 6
77668: PPUSH
77669: LD_INT 3
77671: PUSH
77672: LD_INT 60
77674: PUSH
77675: EMPTY
77676: LIST
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 3
77684: PUSH
77685: LD_INT 55
77687: PUSH
77688: EMPTY
77689: LIST
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PPUSH
77699: CALL_OW 72
77703: PUSH
77704: LD_INT 1
77706: ARRAY
77707: ST_TO_ADDR
// if IsInUnit ( driver ) then
77708: LD_VAR 0 18
77712: PPUSH
77713: CALL_OW 310
77717: IFFALSE 77728
// ComExit ( driver ) ;
77719: LD_VAR 0 18
77723: PPUSH
77724: CALL 102117 0 1
// AddComEnterUnit ( driver , tmp ) ;
77728: LD_VAR 0 18
77732: PPUSH
77733: LD_VAR 0 13
77737: PPUSH
77738: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
77742: LD_VAR 0 18
77746: PPUSH
77747: LD_VAR 0 7
77751: PPUSH
77752: CALL_OW 173
// AddComExitVehicle ( driver ) ;
77756: LD_VAR 0 18
77760: PPUSH
77761: CALL_OW 181
// end ; continue ;
77765: GO 77417
// end ; if not cleaners or not tmp in cleaners then
77767: LD_VAR 0 6
77771: NOT
77772: PUSH
77773: LD_VAR 0 13
77777: PUSH
77778: LD_VAR 0 6
77782: IN
77783: NOT
77784: OR
77785: IFFALSE 78092
// begin if dep then
77787: LD_VAR 0 17
77791: IFFALSE 77927
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77793: LD_ADDR_VAR 0 16
77797: PUSH
77798: LD_VAR 0 17
77802: PUSH
77803: LD_INT 1
77805: ARRAY
77806: PPUSH
77807: CALL_OW 250
77811: PPUSH
77812: LD_VAR 0 17
77816: PUSH
77817: LD_INT 1
77819: ARRAY
77820: PPUSH
77821: CALL_OW 254
77825: PPUSH
77826: LD_INT 5
77828: PPUSH
77829: CALL_OW 272
77833: PUSH
77834: LD_VAR 0 17
77838: PUSH
77839: LD_INT 1
77841: ARRAY
77842: PPUSH
77843: CALL_OW 251
77847: PPUSH
77848: LD_VAR 0 17
77852: PUSH
77853: LD_INT 1
77855: ARRAY
77856: PPUSH
77857: CALL_OW 254
77861: PPUSH
77862: LD_INT 5
77864: PPUSH
77865: CALL_OW 273
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77874: LD_VAR 0 16
77878: PUSH
77879: LD_INT 1
77881: ARRAY
77882: PPUSH
77883: LD_VAR 0 16
77887: PUSH
77888: LD_INT 2
77890: ARRAY
77891: PPUSH
77892: CALL_OW 488
77896: IFFALSE 77927
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77898: LD_VAR 0 13
77902: PPUSH
77903: LD_VAR 0 16
77907: PUSH
77908: LD_INT 1
77910: ARRAY
77911: PPUSH
77912: LD_VAR 0 16
77916: PUSH
77917: LD_INT 2
77919: ARRAY
77920: PPUSH
77921: CALL_OW 111
// continue ;
77925: GO 77417
// end ; end ; r := GetDir ( tmp ) ;
77927: LD_ADDR_VAR 0 15
77931: PUSH
77932: LD_VAR 0 13
77936: PPUSH
77937: CALL_OW 254
77941: ST_TO_ADDR
// if r = 5 then
77942: LD_VAR 0 15
77946: PUSH
77947: LD_INT 5
77949: EQUAL
77950: IFFALSE 77960
// r := 0 ;
77952: LD_ADDR_VAR 0 15
77956: PUSH
77957: LD_INT 0
77959: ST_TO_ADDR
// for j = r to 5 do
77960: LD_ADDR_VAR 0 10
77964: PUSH
77965: DOUBLE
77966: LD_VAR 0 15
77970: DEC
77971: ST_TO_ADDR
77972: LD_INT 5
77974: PUSH
77975: FOR_TO
77976: IFFALSE 78090
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77978: LD_ADDR_VAR 0 11
77982: PUSH
77983: LD_VAR 0 13
77987: PPUSH
77988: CALL_OW 250
77992: PPUSH
77993: LD_VAR 0 10
77997: PPUSH
77998: LD_INT 2
78000: PPUSH
78001: CALL_OW 272
78005: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78006: LD_ADDR_VAR 0 12
78010: PUSH
78011: LD_VAR 0 13
78015: PPUSH
78016: CALL_OW 251
78020: PPUSH
78021: LD_VAR 0 10
78025: PPUSH
78026: LD_INT 2
78028: PPUSH
78029: CALL_OW 273
78033: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78034: LD_VAR 0 11
78038: PPUSH
78039: LD_VAR 0 12
78043: PPUSH
78044: CALL_OW 488
78048: PUSH
78049: LD_VAR 0 11
78053: PPUSH
78054: LD_VAR 0 12
78058: PPUSH
78059: CALL_OW 428
78063: NOT
78064: AND
78065: IFFALSE 78088
// begin ComMoveXY ( tmp , _x , _y ) ;
78067: LD_VAR 0 13
78071: PPUSH
78072: LD_VAR 0 11
78076: PPUSH
78077: LD_VAR 0 12
78081: PPUSH
78082: CALL_OW 111
// break ;
78086: GO 78090
// end ; end ;
78088: GO 77975
78090: POP
78091: POP
// end ; end ;
78092: GO 77417
78094: POP
78095: POP
// end ;
78096: LD_VAR 0 8
78100: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78101: LD_INT 0
78103: PPUSH
78104: PPUSH
78105: PPUSH
78106: PPUSH
78107: PPUSH
78108: PPUSH
78109: PPUSH
78110: PPUSH
78111: PPUSH
78112: PPUSH
// result := false ;
78113: LD_ADDR_VAR 0 6
78117: PUSH
78118: LD_INT 0
78120: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78121: LD_VAR 0 1
78125: NOT
78126: PUSH
78127: LD_VAR 0 1
78131: PPUSH
78132: CALL_OW 266
78136: PUSH
78137: LD_INT 0
78139: PUSH
78140: LD_INT 1
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: IN
78147: NOT
78148: OR
78149: PUSH
78150: LD_VAR 0 2
78154: NOT
78155: OR
78156: PUSH
78157: LD_VAR 0 5
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 1
78167: PUSH
78168: LD_INT 2
78170: PUSH
78171: LD_INT 3
78173: PUSH
78174: LD_INT 4
78176: PUSH
78177: LD_INT 5
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: IN
78188: NOT
78189: OR
78190: PUSH
78191: LD_VAR 0 3
78195: PPUSH
78196: LD_VAR 0 4
78200: PPUSH
78201: CALL_OW 488
78205: NOT
78206: OR
78207: IFFALSE 78211
// exit ;
78209: GO 78928
// pom := GetBase ( depot ) ;
78211: LD_ADDR_VAR 0 10
78215: PUSH
78216: LD_VAR 0 1
78220: PPUSH
78221: CALL_OW 274
78225: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78226: LD_ADDR_VAR 0 11
78230: PUSH
78231: LD_VAR 0 2
78235: PPUSH
78236: LD_VAR 0 1
78240: PPUSH
78241: CALL_OW 248
78245: PPUSH
78246: CALL_OW 450
78250: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78251: LD_VAR 0 10
78255: PPUSH
78256: LD_INT 1
78258: PPUSH
78259: CALL_OW 275
78263: PUSH
78264: LD_VAR 0 11
78268: PUSH
78269: LD_INT 1
78271: ARRAY
78272: GREATEREQUAL
78273: PUSH
78274: LD_VAR 0 10
78278: PPUSH
78279: LD_INT 2
78281: PPUSH
78282: CALL_OW 275
78286: PUSH
78287: LD_VAR 0 11
78291: PUSH
78292: LD_INT 2
78294: ARRAY
78295: GREATEREQUAL
78296: AND
78297: PUSH
78298: LD_VAR 0 10
78302: PPUSH
78303: LD_INT 3
78305: PPUSH
78306: CALL_OW 275
78310: PUSH
78311: LD_VAR 0 11
78315: PUSH
78316: LD_INT 3
78318: ARRAY
78319: GREATEREQUAL
78320: AND
78321: NOT
78322: IFFALSE 78326
// exit ;
78324: GO 78928
// if GetBType ( depot ) = b_depot then
78326: LD_VAR 0 1
78330: PPUSH
78331: CALL_OW 266
78335: PUSH
78336: LD_INT 0
78338: EQUAL
78339: IFFALSE 78351
// dist := 28 else
78341: LD_ADDR_VAR 0 14
78345: PUSH
78346: LD_INT 28
78348: ST_TO_ADDR
78349: GO 78359
// dist := 36 ;
78351: LD_ADDR_VAR 0 14
78355: PUSH
78356: LD_INT 36
78358: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78359: LD_VAR 0 1
78363: PPUSH
78364: LD_VAR 0 3
78368: PPUSH
78369: LD_VAR 0 4
78373: PPUSH
78374: CALL_OW 297
78378: PUSH
78379: LD_VAR 0 14
78383: GREATER
78384: IFFALSE 78388
// exit ;
78386: GO 78928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78388: LD_ADDR_VAR 0 12
78392: PUSH
78393: LD_VAR 0 2
78397: PPUSH
78398: LD_VAR 0 3
78402: PPUSH
78403: LD_VAR 0 4
78407: PPUSH
78408: LD_VAR 0 5
78412: PPUSH
78413: LD_VAR 0 1
78417: PPUSH
78418: CALL_OW 248
78422: PPUSH
78423: LD_INT 0
78425: PPUSH
78426: CALL 78933 0 6
78430: ST_TO_ADDR
// if not hexes then
78431: LD_VAR 0 12
78435: NOT
78436: IFFALSE 78440
// exit ;
78438: GO 78928
// hex := GetHexInfo ( x , y ) ;
78440: LD_ADDR_VAR 0 15
78444: PUSH
78445: LD_VAR 0 3
78449: PPUSH
78450: LD_VAR 0 4
78454: PPUSH
78455: CALL_OW 546
78459: ST_TO_ADDR
// if hex [ 1 ] then
78460: LD_VAR 0 15
78464: PUSH
78465: LD_INT 1
78467: ARRAY
78468: IFFALSE 78472
// exit ;
78470: GO 78928
// height := hex [ 2 ] ;
78472: LD_ADDR_VAR 0 13
78476: PUSH
78477: LD_VAR 0 15
78481: PUSH
78482: LD_INT 2
78484: ARRAY
78485: ST_TO_ADDR
// for i = 1 to hexes do
78486: LD_ADDR_VAR 0 7
78490: PUSH
78491: DOUBLE
78492: LD_INT 1
78494: DEC
78495: ST_TO_ADDR
78496: LD_VAR 0 12
78500: PUSH
78501: FOR_TO
78502: IFFALSE 78832
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
78504: LD_VAR 0 12
78508: PUSH
78509: LD_VAR 0 7
78513: ARRAY
78514: PUSH
78515: LD_INT 1
78517: ARRAY
78518: PPUSH
78519: LD_VAR 0 12
78523: PUSH
78524: LD_VAR 0 7
78528: ARRAY
78529: PUSH
78530: LD_INT 2
78532: ARRAY
78533: PPUSH
78534: CALL_OW 488
78538: NOT
78539: PUSH
78540: LD_VAR 0 12
78544: PUSH
78545: LD_VAR 0 7
78549: ARRAY
78550: PUSH
78551: LD_INT 1
78553: ARRAY
78554: PPUSH
78555: LD_VAR 0 12
78559: PUSH
78560: LD_VAR 0 7
78564: ARRAY
78565: PUSH
78566: LD_INT 2
78568: ARRAY
78569: PPUSH
78570: CALL_OW 428
78574: PUSH
78575: LD_INT 0
78577: GREATER
78578: OR
78579: PUSH
78580: LD_VAR 0 12
78584: PUSH
78585: LD_VAR 0 7
78589: ARRAY
78590: PUSH
78591: LD_INT 1
78593: ARRAY
78594: PPUSH
78595: LD_VAR 0 12
78599: PUSH
78600: LD_VAR 0 7
78604: ARRAY
78605: PUSH
78606: LD_INT 2
78608: ARRAY
78609: PPUSH
78610: CALL_OW 351
78614: OR
78615: IFFALSE 78621
// exit ;
78617: POP
78618: POP
78619: GO 78928
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78621: LD_ADDR_VAR 0 8
78625: PUSH
78626: LD_VAR 0 12
78630: PUSH
78631: LD_VAR 0 7
78635: ARRAY
78636: PUSH
78637: LD_INT 1
78639: ARRAY
78640: PPUSH
78641: LD_VAR 0 12
78645: PUSH
78646: LD_VAR 0 7
78650: ARRAY
78651: PUSH
78652: LD_INT 2
78654: ARRAY
78655: PPUSH
78656: CALL_OW 546
78660: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78661: LD_VAR 0 8
78665: PUSH
78666: LD_INT 1
78668: ARRAY
78669: PUSH
78670: LD_VAR 0 8
78674: PUSH
78675: LD_INT 2
78677: ARRAY
78678: PUSH
78679: LD_VAR 0 13
78683: PUSH
78684: LD_INT 2
78686: PLUS
78687: GREATER
78688: OR
78689: PUSH
78690: LD_VAR 0 8
78694: PUSH
78695: LD_INT 2
78697: ARRAY
78698: PUSH
78699: LD_VAR 0 13
78703: PUSH
78704: LD_INT 2
78706: MINUS
78707: LESS
78708: OR
78709: PUSH
78710: LD_VAR 0 8
78714: PUSH
78715: LD_INT 3
78717: ARRAY
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: LD_INT 8
78724: PUSH
78725: LD_INT 9
78727: PUSH
78728: LD_INT 10
78730: PUSH
78731: LD_INT 11
78733: PUSH
78734: LD_INT 12
78736: PUSH
78737: LD_INT 13
78739: PUSH
78740: LD_INT 16
78742: PUSH
78743: LD_INT 17
78745: PUSH
78746: LD_INT 18
78748: PUSH
78749: LD_INT 19
78751: PUSH
78752: LD_INT 20
78754: PUSH
78755: LD_INT 21
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: IN
78773: NOT
78774: OR
78775: PUSH
78776: LD_VAR 0 8
78780: PUSH
78781: LD_INT 5
78783: ARRAY
78784: NOT
78785: OR
78786: PUSH
78787: LD_VAR 0 8
78791: PUSH
78792: LD_INT 6
78794: ARRAY
78795: PUSH
78796: LD_INT 1
78798: PUSH
78799: LD_INT 2
78801: PUSH
78802: LD_INT 7
78804: PUSH
78805: LD_INT 9
78807: PUSH
78808: LD_INT 10
78810: PUSH
78811: LD_INT 11
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: IN
78822: NOT
78823: OR
78824: IFFALSE 78830
// exit ;
78826: POP
78827: POP
78828: GO 78928
// end ;
78830: GO 78501
78832: POP
78833: POP
// side := GetSide ( depot ) ;
78834: LD_ADDR_VAR 0 9
78838: PUSH
78839: LD_VAR 0 1
78843: PPUSH
78844: CALL_OW 255
78848: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78849: LD_VAR 0 9
78853: PPUSH
78854: LD_VAR 0 3
78858: PPUSH
78859: LD_VAR 0 4
78863: PPUSH
78864: LD_INT 20
78866: PPUSH
78867: CALL 71249 0 4
78871: PUSH
78872: LD_INT 4
78874: ARRAY
78875: IFFALSE 78879
// exit ;
78877: GO 78928
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78879: LD_VAR 0 2
78883: PUSH
78884: LD_INT 29
78886: PUSH
78887: LD_INT 30
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: IN
78894: PUSH
78895: LD_VAR 0 3
78899: PPUSH
78900: LD_VAR 0 4
78904: PPUSH
78905: LD_VAR 0 9
78909: PPUSH
78910: CALL_OW 440
78914: NOT
78915: AND
78916: IFFALSE 78920
// exit ;
78918: GO 78928
// result := true ;
78920: LD_ADDR_VAR 0 6
78924: PUSH
78925: LD_INT 1
78927: ST_TO_ADDR
// end ;
78928: LD_VAR 0 6
78932: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78933: LD_INT 0
78935: PPUSH
78936: PPUSH
78937: PPUSH
78938: PPUSH
78939: PPUSH
78940: PPUSH
78941: PPUSH
78942: PPUSH
78943: PPUSH
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
78950: PPUSH
78951: PPUSH
78952: PPUSH
78953: PPUSH
78954: PPUSH
78955: PPUSH
78956: PPUSH
78957: PPUSH
78958: PPUSH
78959: PPUSH
78960: PPUSH
78961: PPUSH
78962: PPUSH
78963: PPUSH
78964: PPUSH
78965: PPUSH
78966: PPUSH
78967: PPUSH
78968: PPUSH
78969: PPUSH
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
78974: PPUSH
78975: PPUSH
78976: PPUSH
78977: PPUSH
78978: PPUSH
78979: PPUSH
78980: PPUSH
78981: PPUSH
78982: PPUSH
78983: PPUSH
78984: PPUSH
78985: PPUSH
78986: PPUSH
78987: PPUSH
78988: PPUSH
78989: PPUSH
78990: PPUSH
78991: PPUSH
78992: PPUSH
// result = [ ] ;
78993: LD_ADDR_VAR 0 7
78997: PUSH
78998: EMPTY
78999: ST_TO_ADDR
// temp_list = [ ] ;
79000: LD_ADDR_VAR 0 9
79004: PUSH
79005: EMPTY
79006: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79007: LD_VAR 0 4
79011: PUSH
79012: LD_INT 0
79014: PUSH
79015: LD_INT 1
79017: PUSH
79018: LD_INT 2
79020: PUSH
79021: LD_INT 3
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: LD_INT 5
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: IN
79038: NOT
79039: PUSH
79040: LD_VAR 0 1
79044: PUSH
79045: LD_INT 0
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: IN
79055: PUSH
79056: LD_VAR 0 5
79060: PUSH
79061: LD_INT 1
79063: PUSH
79064: LD_INT 2
79066: PUSH
79067: LD_INT 3
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: LIST
79074: IN
79075: NOT
79076: AND
79077: OR
79078: IFFALSE 79082
// exit ;
79080: GO 97473
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79082: LD_VAR 0 1
79086: PUSH
79087: LD_INT 6
79089: PUSH
79090: LD_INT 7
79092: PUSH
79093: LD_INT 8
79095: PUSH
79096: LD_INT 13
79098: PUSH
79099: LD_INT 12
79101: PUSH
79102: LD_INT 15
79104: PUSH
79105: LD_INT 11
79107: PUSH
79108: LD_INT 14
79110: PUSH
79111: LD_INT 10
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: IN
79125: IFFALSE 79135
// btype = b_lab ;
79127: LD_ADDR_VAR 0 1
79131: PUSH
79132: LD_INT 6
79134: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79135: LD_VAR 0 6
79139: PUSH
79140: LD_INT 0
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: LD_INT 2
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: LIST
79153: IN
79154: NOT
79155: PUSH
79156: LD_VAR 0 1
79160: PUSH
79161: LD_INT 0
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: LD_INT 3
79172: PUSH
79173: LD_INT 6
79175: PUSH
79176: LD_INT 36
79178: PUSH
79179: LD_INT 4
79181: PUSH
79182: LD_INT 5
79184: PUSH
79185: LD_INT 31
79187: PUSH
79188: LD_INT 32
79190: PUSH
79191: LD_INT 33
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: IN
79207: NOT
79208: PUSH
79209: LD_VAR 0 6
79213: PUSH
79214: LD_INT 1
79216: EQUAL
79217: AND
79218: OR
79219: PUSH
79220: LD_VAR 0 1
79224: PUSH
79225: LD_INT 2
79227: PUSH
79228: LD_INT 3
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: IN
79235: NOT
79236: PUSH
79237: LD_VAR 0 6
79241: PUSH
79242: LD_INT 2
79244: EQUAL
79245: AND
79246: OR
79247: IFFALSE 79257
// mode = 0 ;
79249: LD_ADDR_VAR 0 6
79253: PUSH
79254: LD_INT 0
79256: ST_TO_ADDR
// case mode of 0 :
79257: LD_VAR 0 6
79261: PUSH
79262: LD_INT 0
79264: DOUBLE
79265: EQUAL
79266: IFTRUE 79270
79268: GO 90723
79270: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79271: LD_ADDR_VAR 0 11
79275: PUSH
79276: LD_INT 0
79278: PUSH
79279: LD_INT 0
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 0
79288: PUSH
79289: LD_INT 1
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 1
79299: PUSH
79300: LD_INT 0
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 1
79309: PUSH
79310: LD_INT 1
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 0
79319: PUSH
79320: LD_INT 1
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 1
79329: NEG
79330: PUSH
79331: LD_INT 0
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 1
79340: NEG
79341: PUSH
79342: LD_INT 1
79344: NEG
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 1
79352: NEG
79353: PUSH
79354: LD_INT 2
79356: NEG
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: LD_INT 0
79364: PUSH
79365: LD_INT 2
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 1
79375: PUSH
79376: LD_INT 1
79378: NEG
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 1
79386: PUSH
79387: LD_INT 2
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 0
79396: PUSH
79397: LD_INT 2
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 1
79406: NEG
79407: PUSH
79408: LD_INT 1
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 0
79427: PUSH
79428: LD_INT 3
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: NEG
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79464: LD_ADDR_VAR 0 12
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: LD_INT 0
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: LD_INT 1
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 1
79502: PUSH
79503: LD_INT 1
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: LD_INT 1
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 1
79522: NEG
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 1
79533: NEG
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 1
79545: PUSH
79546: LD_INT 1
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 2
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 2
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 2
79587: NEG
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: LD_INT 1
79602: NEG
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 2
79610: NEG
79611: PUSH
79612: LD_INT 1
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 3
79621: NEG
79622: PUSH
79623: LD_INT 0
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 3
79632: NEG
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79660: LD_ADDR_VAR 0 13
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: LD_INT 0
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 0
79677: PUSH
79678: LD_INT 1
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 1
79688: PUSH
79689: LD_INT 0
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 1
79698: PUSH
79699: LD_INT 1
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 0
79708: PUSH
79709: LD_INT 1
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 1
79718: NEG
79719: PUSH
79720: LD_INT 0
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 1
79729: NEG
79730: PUSH
79731: LD_INT 1
79733: NEG
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: LD_INT 2
79745: NEG
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 2
79753: PUSH
79754: LD_INT 1
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 2
79763: PUSH
79764: LD_INT 2
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 1
79773: PUSH
79774: LD_INT 2
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 2
79783: NEG
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 2
79795: NEG
79796: PUSH
79797: LD_INT 2
79799: NEG
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 2
79807: NEG
79808: PUSH
79809: LD_INT 3
79811: NEG
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 3
79819: NEG
79820: PUSH
79821: LD_INT 2
79823: NEG
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 3
79831: NEG
79832: PUSH
79833: LD_INT 3
79835: NEG
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79859: LD_ADDR_VAR 0 14
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 0
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 1
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 1
79897: PUSH
79898: LD_INT 1
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 0
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: NEG
79918: PUSH
79919: LD_INT 0
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: LD_INT 1
79932: NEG
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 1
79940: NEG
79941: PUSH
79942: LD_INT 2
79944: NEG
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 0
79952: PUSH
79953: LD_INT 2
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 1
79963: PUSH
79964: LD_INT 1
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: LD_INT 2
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 1
79994: NEG
79995: PUSH
79996: LD_INT 1
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 1
80005: NEG
80006: PUSH
80007: LD_INT 3
80009: NEG
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: LD_INT 3
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 2
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: LIST
80049: LIST
80050: LIST
80051: LIST
80052: LIST
80053: LIST
80054: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80055: LD_ADDR_VAR 0 15
80059: PUSH
80060: LD_INT 0
80062: PUSH
80063: LD_INT 0
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: LD_INT 0
80072: PUSH
80073: LD_INT 1
80075: NEG
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 1
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 1
80093: PUSH
80094: LD_INT 1
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 0
80103: PUSH
80104: LD_INT 1
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 1
80113: NEG
80114: PUSH
80115: LD_INT 0
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: LD_INT 1
80124: NEG
80125: PUSH
80126: LD_INT 1
80128: NEG
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 1
80136: PUSH
80137: LD_INT 1
80139: NEG
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 2
80147: PUSH
80148: LD_INT 0
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 2
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 1
80167: NEG
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 2
80178: NEG
80179: PUSH
80180: LD_INT 0
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 2
80189: NEG
80190: PUSH
80191: LD_INT 1
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 2
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 3
80212: PUSH
80213: LD_INT 0
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 3
80222: PUSH
80223: LD_INT 1
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80248: LD_ADDR_VAR 0 16
80252: PUSH
80253: LD_INT 0
80255: PUSH
80256: LD_INT 0
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: LD_INT 1
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 1
80276: PUSH
80277: LD_INT 0
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: LD_INT 1
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: LD_INT 1
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 1
80317: NEG
80318: PUSH
80319: LD_INT 1
80321: NEG
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 1
80329: NEG
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: PUSH
80342: LD_INT 1
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 2
80351: PUSH
80352: LD_INT 2
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 1
80361: PUSH
80362: LD_INT 2
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 2
80371: NEG
80372: PUSH
80373: LD_INT 1
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: NEG
80384: PUSH
80385: LD_INT 2
80387: NEG
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 3
80395: PUSH
80396: LD_INT 2
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 3
80405: PUSH
80406: LD_INT 3
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 2
80415: PUSH
80416: LD_INT 3
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80441: LD_ADDR_VAR 0 17
80445: PUSH
80446: LD_INT 0
80448: PUSH
80449: LD_INT 0
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: LD_INT 1
80461: NEG
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 0
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 1
80479: PUSH
80480: LD_INT 1
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 0
80489: PUSH
80490: LD_INT 1
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 1
80499: NEG
80500: PUSH
80501: LD_INT 0
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: NEG
80511: PUSH
80512: LD_INT 1
80514: NEG
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 1
80522: NEG
80523: PUSH
80524: LD_INT 2
80526: NEG
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: LD_INT 2
80537: NEG
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 1
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 2
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: PUSH
80567: LD_INT 1
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 2
80576: PUSH
80577: LD_INT 2
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: LD_INT 2
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 0
80596: PUSH
80597: LD_INT 2
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: NEG
80607: PUSH
80608: LD_INT 1
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 2
80617: NEG
80618: PUSH
80619: LD_INT 0
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 2
80628: NEG
80629: PUSH
80630: LD_INT 1
80632: NEG
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 2
80640: NEG
80641: PUSH
80642: LD_INT 2
80644: NEG
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80671: LD_ADDR_VAR 0 18
80675: PUSH
80676: LD_INT 0
80678: PUSH
80679: LD_INT 0
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 1
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 1
80709: PUSH
80710: LD_INT 1
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: LD_INT 1
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 1
80729: NEG
80730: PUSH
80731: LD_INT 0
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 1
80740: NEG
80741: PUSH
80742: LD_INT 1
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: LD_INT 2
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 0
80764: PUSH
80765: LD_INT 2
80767: NEG
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 1
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 2
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 2
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 2
80806: PUSH
80807: LD_INT 2
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 1
80816: PUSH
80817: LD_INT 2
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 0
80826: PUSH
80827: LD_INT 2
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 1
80836: NEG
80837: PUSH
80838: LD_INT 1
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 2
80847: NEG
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 2
80858: NEG
80859: PUSH
80860: LD_INT 1
80862: NEG
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 2
80870: NEG
80871: PUSH
80872: LD_INT 2
80874: NEG
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80901: LD_ADDR_VAR 0 19
80905: PUSH
80906: LD_INT 0
80908: PUSH
80909: LD_INT 0
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 0
80918: PUSH
80919: LD_INT 1
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: LD_INT 0
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 1
80939: PUSH
80940: LD_INT 1
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 0
80949: PUSH
80950: LD_INT 1
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 1
80959: NEG
80960: PUSH
80961: LD_INT 0
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 1
80970: NEG
80971: PUSH
80972: LD_INT 1
80974: NEG
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 1
80982: NEG
80983: PUSH
80984: LD_INT 2
80986: NEG
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 0
80994: PUSH
80995: LD_INT 2
80997: NEG
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 1
81005: PUSH
81006: LD_INT 1
81008: NEG
81009: PUSH
81010: EMPTY
81011: LIST
81012: LIST
81013: PUSH
81014: LD_INT 2
81016: PUSH
81017: LD_INT 0
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 2
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 2
81036: PUSH
81037: LD_INT 2
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 1
81046: PUSH
81047: LD_INT 2
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 0
81056: PUSH
81057: LD_INT 2
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 1
81066: NEG
81067: PUSH
81068: LD_INT 1
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 2
81077: NEG
81078: PUSH
81079: LD_INT 0
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 2
81088: NEG
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 2
81100: NEG
81101: PUSH
81102: LD_INT 2
81104: NEG
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81131: LD_ADDR_VAR 0 20
81135: PUSH
81136: LD_INT 0
81138: PUSH
81139: LD_INT 0
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 1
81151: NEG
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: LD_INT 0
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: PUSH
81170: LD_INT 1
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 0
81179: PUSH
81180: LD_INT 1
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 1
81189: NEG
81190: PUSH
81191: LD_INT 0
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 1
81200: NEG
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 1
81212: NEG
81213: PUSH
81214: LD_INT 2
81216: NEG
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 0
81224: PUSH
81225: LD_INT 2
81227: NEG
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 1
81235: PUSH
81236: LD_INT 1
81238: NEG
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 2
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 2
81256: PUSH
81257: LD_INT 1
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 2
81266: PUSH
81267: LD_INT 2
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 1
81276: PUSH
81277: LD_INT 2
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 0
81286: PUSH
81287: LD_INT 2
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 1
81296: NEG
81297: PUSH
81298: LD_INT 1
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 2
81307: NEG
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: LD_INT 1
81322: NEG
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 2
81330: NEG
81331: PUSH
81332: LD_INT 2
81334: NEG
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81361: LD_ADDR_VAR 0 21
81365: PUSH
81366: LD_INT 0
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: LD_INT 1
81381: NEG
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 1
81389: PUSH
81390: LD_INT 0
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 1
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: LD_INT 1
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 1
81419: NEG
81420: PUSH
81421: LD_INT 0
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: NEG
81431: PUSH
81432: LD_INT 1
81434: NEG
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 1
81442: NEG
81443: PUSH
81444: LD_INT 2
81446: NEG
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 0
81454: PUSH
81455: LD_INT 2
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: LD_INT 1
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: LD_INT 0
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: LD_INT 1
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 2
81496: PUSH
81497: LD_INT 2
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: PUSH
81507: LD_INT 2
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 2
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 1
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 2
81537: NEG
81538: PUSH
81539: LD_INT 0
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 2
81548: NEG
81549: PUSH
81550: LD_INT 1
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: NEG
81561: PUSH
81562: LD_INT 2
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: EMPTY
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81591: LD_ADDR_VAR 0 22
81595: PUSH
81596: LD_INT 0
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: LD_INT 1
81611: NEG
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 1
81619: PUSH
81620: LD_INT 0
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 1
81629: PUSH
81630: LD_INT 1
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 0
81639: PUSH
81640: LD_INT 1
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 1
81649: NEG
81650: PUSH
81651: LD_INT 0
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: LD_INT 1
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: LD_INT 2
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 0
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 1
81695: PUSH
81696: LD_INT 1
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 2
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 2
81716: PUSH
81717: LD_INT 1
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: LD_INT 2
81726: PUSH
81727: LD_INT 2
81729: PUSH
81730: EMPTY
81731: LIST
81732: LIST
81733: PUSH
81734: LD_INT 1
81736: PUSH
81737: LD_INT 2
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 0
81746: PUSH
81747: LD_INT 2
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 1
81756: NEG
81757: PUSH
81758: LD_INT 1
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 2
81767: NEG
81768: PUSH
81769: LD_INT 0
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 2
81778: NEG
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: LD_INT 2
81794: NEG
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81821: LD_ADDR_VAR 0 23
81825: PUSH
81826: LD_INT 0
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 0
81838: PUSH
81839: LD_INT 1
81841: NEG
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 1
81849: PUSH
81850: LD_INT 0
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 1
81859: PUSH
81860: LD_INT 1
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 0
81869: PUSH
81870: LD_INT 1
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: NEG
81880: PUSH
81881: LD_INT 0
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 1
81890: NEG
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: LD_INT 2
81906: NEG
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 0
81914: PUSH
81915: LD_INT 2
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 1
81925: PUSH
81926: LD_INT 1
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 2
81936: PUSH
81937: LD_INT 0
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 2
81946: PUSH
81947: LD_INT 1
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 2
81956: PUSH
81957: LD_INT 2
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 1
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 0
81976: PUSH
81977: LD_INT 2
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 1
81986: NEG
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 2
81997: NEG
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 2
82008: NEG
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 2
82020: NEG
82021: PUSH
82022: LD_INT 2
82024: NEG
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 2
82032: NEG
82033: PUSH
82034: LD_INT 3
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: LD_INT 3
82048: NEG
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 1
82056: PUSH
82057: LD_INT 2
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 2
82067: PUSH
82068: LD_INT 1
82070: NEG
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82101: LD_ADDR_VAR 0 24
82105: PUSH
82106: LD_INT 0
82108: PUSH
82109: LD_INT 0
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 0
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 1
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 1
82139: PUSH
82140: LD_INT 1
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 0
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 1
82170: NEG
82171: PUSH
82172: LD_INT 1
82174: NEG
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 1
82182: NEG
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 0
82194: PUSH
82195: LD_INT 2
82197: NEG
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PUSH
82203: LD_INT 1
82205: PUSH
82206: LD_INT 1
82208: NEG
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 2
82216: PUSH
82217: LD_INT 0
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 2
82226: PUSH
82227: LD_INT 1
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 2
82236: PUSH
82237: LD_INT 2
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 1
82246: PUSH
82247: LD_INT 2
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 0
82256: PUSH
82257: LD_INT 2
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: LD_INT 1
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 2
82277: NEG
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 2
82288: NEG
82289: PUSH
82290: LD_INT 1
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 2
82300: NEG
82301: PUSH
82302: LD_INT 2
82304: NEG
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: LD_INT 2
82315: NEG
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: LD_INT 1
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 3
82334: PUSH
82335: LD_INT 1
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 3
82344: PUSH
82345: LD_INT 2
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82377: LD_ADDR_VAR 0 25
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: LD_INT 0
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 0
82394: PUSH
82395: LD_INT 1
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 1
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: LD_INT 1
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: LD_INT 1
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 1
82435: NEG
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 1
82446: NEG
82447: PUSH
82448: LD_INT 1
82450: NEG
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 1
82458: NEG
82459: PUSH
82460: LD_INT 2
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: LD_INT 2
82473: NEG
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 1
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 2
82492: PUSH
82493: LD_INT 0
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 2
82502: PUSH
82503: LD_INT 1
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 2
82512: PUSH
82513: LD_INT 2
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 1
82522: PUSH
82523: LD_INT 2
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: LD_INT 2
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: NEG
82543: PUSH
82544: LD_INT 1
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: NEG
82554: PUSH
82555: LD_INT 0
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: PUSH
82562: LD_INT 2
82564: NEG
82565: PUSH
82566: LD_INT 1
82568: NEG
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 2
82576: NEG
82577: PUSH
82578: LD_INT 2
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 3
82588: PUSH
82589: LD_INT 1
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 3
82598: PUSH
82599: LD_INT 2
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 2
82608: PUSH
82609: LD_INT 3
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: PUSH
82619: LD_INT 3
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82651: LD_ADDR_VAR 0 26
82655: PUSH
82656: LD_INT 0
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: LD_INT 1
82671: NEG
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 1
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 1
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 0
82699: PUSH
82700: LD_INT 1
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 1
82720: NEG
82721: PUSH
82722: LD_INT 1
82724: NEG
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: NEG
82733: PUSH
82734: LD_INT 2
82736: NEG
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 0
82744: PUSH
82745: LD_INT 2
82747: NEG
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 1
82755: PUSH
82756: LD_INT 1
82758: NEG
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 2
82766: PUSH
82767: LD_INT 0
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 2
82776: PUSH
82777: LD_INT 1
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: PUSH
82787: LD_INT 2
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 1
82796: PUSH
82797: LD_INT 2
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: LD_INT 1
82816: NEG
82817: PUSH
82818: LD_INT 1
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 2
82827: NEG
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 2
82838: NEG
82839: PUSH
82840: LD_INT 1
82842: NEG
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: LD_INT 2
82854: NEG
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 2
82862: PUSH
82863: LD_INT 3
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 1
82872: PUSH
82873: LD_INT 3
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: LD_INT 2
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 2
82893: NEG
82894: PUSH
82895: LD_INT 1
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82927: LD_ADDR_VAR 0 27
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 1
82947: NEG
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 1
82955: PUSH
82956: LD_INT 0
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 1
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 0
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 1
82985: NEG
82986: PUSH
82987: LD_INT 0
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 1
83000: NEG
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 1
83008: NEG
83009: PUSH
83010: LD_INT 2
83012: NEG
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 0
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 1
83031: PUSH
83032: LD_INT 1
83034: NEG
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 2
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 2
83052: PUSH
83053: LD_INT 1
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 2
83062: PUSH
83063: LD_INT 2
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: LD_INT 2
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 0
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 2
83103: NEG
83104: PUSH
83105: LD_INT 0
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: LD_INT 2
83114: NEG
83115: PUSH
83116: LD_INT 1
83118: NEG
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 1
83138: NEG
83139: PUSH
83140: LD_INT 2
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 2
83149: NEG
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 3
83160: NEG
83161: PUSH
83162: LD_INT 1
83164: NEG
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: PUSH
83170: LD_INT 3
83172: NEG
83173: PUSH
83174: LD_INT 2
83176: NEG
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83207: LD_ADDR_VAR 0 28
83211: PUSH
83212: LD_INT 0
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: LD_INT 1
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 1
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 1
83245: PUSH
83246: LD_INT 1
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 0
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 1
83265: NEG
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: NEG
83277: PUSH
83278: LD_INT 1
83280: NEG
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: PUSH
83286: LD_INT 1
83288: NEG
83289: PUSH
83290: LD_INT 2
83292: NEG
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: LD_INT 2
83303: NEG
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 1
83311: PUSH
83312: LD_INT 1
83314: NEG
83315: PUSH
83316: EMPTY
83317: LIST
83318: LIST
83319: PUSH
83320: LD_INT 2
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 2
83332: PUSH
83333: LD_INT 1
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: LD_INT 2
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 1
83352: PUSH
83353: LD_INT 2
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 0
83362: PUSH
83363: LD_INT 2
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 1
83372: NEG
83373: PUSH
83374: LD_INT 1
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 2
83383: NEG
83384: PUSH
83385: LD_INT 0
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 2
83394: NEG
83395: PUSH
83396: LD_INT 1
83398: NEG
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 2
83406: NEG
83407: PUSH
83408: LD_INT 2
83410: NEG
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 2
83418: NEG
83419: PUSH
83420: LD_INT 3
83422: NEG
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: NEG
83431: PUSH
83432: LD_INT 3
83434: NEG
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 3
83442: NEG
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 3
83454: NEG
83455: PUSH
83456: LD_INT 2
83458: NEG
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83489: LD_ADDR_VAR 0 29
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: LD_INT 0
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: LD_INT 1
83509: NEG
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: LD_INT 1
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 0
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 1
83547: NEG
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 1
83558: NEG
83559: PUSH
83560: LD_INT 1
83562: NEG
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: LD_INT 2
83574: NEG
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 0
83582: PUSH
83583: LD_INT 2
83585: NEG
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 2
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: LD_INT 1
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 1
83624: PUSH
83625: LD_INT 2
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 0
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: LD_INT 1
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 2
83655: NEG
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 2
83667: NEG
83668: PUSH
83669: LD_INT 2
83671: NEG
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: NEG
83680: PUSH
83681: LD_INT 3
83683: NEG
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 2
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 3
83702: PUSH
83703: LD_INT 1
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 1
83712: PUSH
83713: LD_INT 3
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 1
83722: NEG
83723: PUSH
83724: LD_INT 2
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 3
83733: NEG
83734: PUSH
83735: LD_INT 2
83737: NEG
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83768: LD_ADDR_VAR 0 30
83772: PUSH
83773: LD_INT 0
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 0
83785: PUSH
83786: LD_INT 1
83788: NEG
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 1
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 1
83806: PUSH
83807: LD_INT 1
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 0
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: NEG
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 1
83837: NEG
83838: PUSH
83839: LD_INT 1
83841: NEG
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 1
83849: NEG
83850: PUSH
83851: LD_INT 2
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: LD_INT 2
83864: NEG
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: PUSH
83870: LD_INT 1
83872: PUSH
83873: LD_INT 1
83875: NEG
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 2
83883: PUSH
83884: LD_INT 0
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 2
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 2
83903: PUSH
83904: LD_INT 2
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: PUSH
83914: LD_INT 2
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: LD_INT 1
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 2
83934: NEG
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: NEG
83946: PUSH
83947: LD_INT 1
83949: NEG
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: NEG
83958: PUSH
83959: LD_INT 3
83961: NEG
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 1
83969: PUSH
83970: LD_INT 2
83972: NEG
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 3
83980: PUSH
83981: LD_INT 2
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: PUSH
83988: LD_INT 2
83990: PUSH
83991: LD_INT 3
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 2
84000: NEG
84001: PUSH
84002: LD_INT 1
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 3
84011: NEG
84012: PUSH
84013: LD_INT 1
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84046: LD_ADDR_VAR 0 31
84050: PUSH
84051: LD_INT 0
84053: PUSH
84054: LD_INT 0
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 0
84063: PUSH
84064: LD_INT 1
84066: NEG
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 1
84074: PUSH
84075: LD_INT 0
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 1
84084: PUSH
84085: LD_INT 1
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 0
84094: PUSH
84095: LD_INT 1
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: NEG
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 1
84115: NEG
84116: PUSH
84117: LD_INT 1
84119: NEG
84120: PUSH
84121: EMPTY
84122: LIST
84123: LIST
84124: PUSH
84125: LD_INT 1
84127: NEG
84128: PUSH
84129: LD_INT 2
84131: NEG
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 1
84139: PUSH
84140: LD_INT 1
84142: NEG
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 2
84150: PUSH
84151: LD_INT 0
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 2
84160: PUSH
84161: LD_INT 1
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 2
84170: PUSH
84171: LD_INT 2
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PUSH
84178: LD_INT 1
84180: PUSH
84181: LD_INT 2
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 0
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: NEG
84201: PUSH
84202: LD_INT 1
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 2
84211: NEG
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 2
84223: NEG
84224: PUSH
84225: LD_INT 2
84227: NEG
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 2
84235: NEG
84236: PUSH
84237: LD_INT 3
84239: NEG
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 2
84247: PUSH
84248: LD_INT 1
84250: NEG
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 3
84258: PUSH
84259: LD_INT 1
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 1
84268: PUSH
84269: LD_INT 3
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 1
84278: NEG
84279: PUSH
84280: LD_INT 2
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: LD_INT 3
84289: NEG
84290: PUSH
84291: LD_INT 2
84293: NEG
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84324: LD_ADDR_VAR 0 32
84328: PUSH
84329: LD_INT 0
84331: PUSH
84332: LD_INT 0
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 0
84341: PUSH
84342: LD_INT 1
84344: NEG
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: LD_INT 0
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 1
84362: PUSH
84363: LD_INT 1
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 0
84372: PUSH
84373: LD_INT 1
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: LD_INT 0
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 1
84393: NEG
84394: PUSH
84395: LD_INT 1
84397: NEG
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 1
84405: NEG
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: LD_INT 2
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: LD_INT 1
84431: NEG
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 2
84439: PUSH
84440: LD_INT 1
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 2
84449: PUSH
84450: LD_INT 2
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 1
84459: PUSH
84460: LD_INT 2
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 0
84469: PUSH
84470: LD_INT 2
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 1
84479: NEG
84480: PUSH
84481: LD_INT 1
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 2
84490: NEG
84491: PUSH
84492: LD_INT 0
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: LD_INT 1
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 1
84513: NEG
84514: PUSH
84515: LD_INT 3
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 1
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 3
84536: PUSH
84537: LD_INT 2
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 2
84546: PUSH
84547: LD_INT 3
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: PUSH
84554: LD_INT 2
84556: NEG
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 3
84567: NEG
84568: PUSH
84569: LD_INT 1
84571: NEG
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84602: LD_ADDR_VAR 0 33
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 0
84619: PUSH
84620: LD_INT 1
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: LD_INT 0
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 1
84640: PUSH
84641: LD_INT 1
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 0
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 1
84660: NEG
84661: PUSH
84662: LD_INT 0
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 1
84671: NEG
84672: PUSH
84673: LD_INT 1
84675: NEG
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 2
84687: NEG
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 1
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: LD_INT 1
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 1
84726: PUSH
84727: LD_INT 2
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: LD_INT 2
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 1
84746: NEG
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: LD_INT 0
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 2
84768: NEG
84769: PUSH
84770: LD_INT 1
84772: NEG
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 2
84780: NEG
84781: PUSH
84782: LD_INT 2
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 2
84792: NEG
84793: PUSH
84794: LD_INT 3
84796: NEG
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 2
84804: PUSH
84805: LD_INT 1
84807: NEG
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 3
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 1
84825: PUSH
84826: LD_INT 3
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 1
84835: NEG
84836: PUSH
84837: LD_INT 2
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 3
84846: NEG
84847: PUSH
84848: LD_INT 2
84850: NEG
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84881: LD_ADDR_VAR 0 34
84885: PUSH
84886: LD_INT 0
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: LD_INT 1
84901: NEG
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: LD_INT 0
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 1
84919: PUSH
84920: LD_INT 1
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 0
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 1
84939: NEG
84940: PUSH
84941: LD_INT 0
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 1
84950: NEG
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 0
84974: PUSH
84975: LD_INT 2
84977: NEG
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: LD_INT 1
84988: NEG
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 2
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 2
85006: PUSH
85007: LD_INT 2
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: LD_INT 1
85016: PUSH
85017: LD_INT 2
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 1
85026: NEG
85027: PUSH
85028: LD_INT 1
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: LD_INT 0
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 2
85048: NEG
85049: PUSH
85050: LD_INT 1
85052: NEG
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 2
85060: NEG
85061: PUSH
85062: LD_INT 2
85064: NEG
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 1
85072: NEG
85073: PUSH
85074: LD_INT 3
85076: NEG
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: PUSH
85085: LD_INT 2
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 3
85095: PUSH
85096: LD_INT 2
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 2
85105: PUSH
85106: LD_INT 3
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 2
85115: NEG
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 3
85126: NEG
85127: PUSH
85128: LD_INT 1
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85161: LD_ADDR_VAR 0 35
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 0
85178: PUSH
85179: LD_INT 1
85181: NEG
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 1
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: LD_INT 1
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 0
85209: PUSH
85210: LD_INT 1
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: NEG
85231: PUSH
85232: LD_INT 1
85234: NEG
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 2
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 2
85252: NEG
85253: PUSH
85254: LD_INT 1
85256: NEG
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85273: LD_ADDR_VAR 0 36
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: LD_INT 0
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 0
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 1
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 1
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: NEG
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: NEG
85343: PUSH
85344: LD_INT 1
85346: NEG
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 1
85354: NEG
85355: PUSH
85356: LD_INT 2
85358: NEG
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: LD_INT 2
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85385: LD_ADDR_VAR 0 37
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: LD_INT 0
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 0
85402: PUSH
85403: LD_INT 1
85405: NEG
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 1
85413: PUSH
85414: LD_INT 0
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: LD_INT 1
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 1
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: NEG
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: NEG
85455: PUSH
85456: LD_INT 1
85458: NEG
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: LD_INT 1
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 1
85477: NEG
85478: PUSH
85479: LD_INT 1
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85497: LD_ADDR_VAR 0 38
85501: PUSH
85502: LD_INT 0
85504: PUSH
85505: LD_INT 0
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 0
85514: PUSH
85515: LD_INT 1
85517: NEG
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: LD_INT 0
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 1
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: LD_INT 0
85545: PUSH
85546: LD_INT 1
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 1
85555: NEG
85556: PUSH
85557: LD_INT 0
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 1
85566: NEG
85567: PUSH
85568: LD_INT 1
85570: NEG
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 2
85578: PUSH
85579: LD_INT 1
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 2
85588: NEG
85589: PUSH
85590: LD_INT 1
85592: NEG
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85609: LD_ADDR_VAR 0 39
85613: PUSH
85614: LD_INT 0
85616: PUSH
85617: LD_INT 0
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: LD_INT 1
85629: NEG
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: LD_INT 0
85640: PUSH
85641: EMPTY
85642: LIST
85643: LIST
85644: PUSH
85645: LD_INT 1
85647: PUSH
85648: LD_INT 1
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: LD_INT 1
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: LD_INT 0
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 1
85678: NEG
85679: PUSH
85680: LD_INT 1
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: NEG
85691: PUSH
85692: LD_INT 2
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: PUSH
85703: LD_INT 2
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85721: LD_ADDR_VAR 0 40
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: LD_INT 0
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 0
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: PUSH
85750: LD_INT 0
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: LD_INT 1
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 0
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 1
85779: NEG
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 1
85790: NEG
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 1
85805: NEG
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 1
85813: NEG
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85833: LD_ADDR_VAR 0 41
85837: PUSH
85838: LD_INT 0
85840: PUSH
85841: LD_INT 0
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 0
85850: PUSH
85851: LD_INT 1
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: LD_INT 0
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 1
85871: PUSH
85872: LD_INT 1
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 0
85881: PUSH
85882: LD_INT 1
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: NEG
85892: PUSH
85893: LD_INT 0
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: NEG
85903: PUSH
85904: LD_INT 1
85906: NEG
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 1
85914: NEG
85915: PUSH
85916: LD_INT 2
85918: NEG
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: LD_INT 1
85929: NEG
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 2
85937: PUSH
85938: LD_INT 0
85940: PUSH
85941: EMPTY
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 2
85947: PUSH
85948: LD_INT 1
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 2
85957: PUSH
85958: LD_INT 2
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 1
85967: PUSH
85968: LD_INT 2
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 1
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: LD_INT 0
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: LD_INT 2
85999: NEG
86000: PUSH
86001: LD_INT 1
86003: NEG
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 2
86011: NEG
86012: PUSH
86013: LD_INT 2
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 2
86023: NEG
86024: PUSH
86025: LD_INT 3
86027: NEG
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: PUSH
86036: LD_INT 1
86038: NEG
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 3
86046: PUSH
86047: LD_INT 0
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 3
86056: PUSH
86057: LD_INT 1
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 3
86066: PUSH
86067: LD_INT 2
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 3
86076: PUSH
86077: LD_INT 3
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 2
86086: PUSH
86087: LD_INT 3
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 2
86096: NEG
86097: PUSH
86098: LD_INT 1
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 3
86107: NEG
86108: PUSH
86109: LD_INT 0
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 3
86118: NEG
86119: PUSH
86120: LD_INT 1
86122: NEG
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 3
86130: NEG
86131: PUSH
86132: LD_INT 2
86134: NEG
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 3
86142: NEG
86143: PUSH
86144: LD_INT 3
86146: NEG
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86183: LD_ADDR_VAR 0 42
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: LD_INT 0
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 0
86200: PUSH
86201: LD_INT 1
86203: NEG
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 1
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 1
86241: NEG
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: LD_INT 1
86256: NEG
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 1
86264: NEG
86265: PUSH
86266: LD_INT 2
86268: NEG
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 0
86276: PUSH
86277: LD_INT 2
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 2
86298: PUSH
86299: LD_INT 1
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 2
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 1
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 0
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 1
86338: NEG
86339: PUSH
86340: LD_INT 1
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: NEG
86350: PUSH
86351: LD_INT 1
86353: NEG
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 2
86361: NEG
86362: PUSH
86363: LD_INT 2
86365: NEG
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 2
86373: NEG
86374: PUSH
86375: LD_INT 3
86377: NEG
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 1
86385: NEG
86386: PUSH
86387: LD_INT 3
86389: NEG
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 0
86397: PUSH
86398: LD_INT 3
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 3
86419: PUSH
86420: LD_INT 2
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 3
86429: PUSH
86430: LD_INT 3
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: LD_INT 2
86439: PUSH
86440: LD_INT 3
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: LD_INT 3
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: LD_INT 3
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 1
86469: NEG
86470: PUSH
86471: LD_INT 2
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 3
86480: NEG
86481: PUSH
86482: LD_INT 2
86484: NEG
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 3
86492: NEG
86493: PUSH
86494: LD_INT 3
86496: NEG
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86533: LD_ADDR_VAR 0 43
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: LD_INT 0
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: LD_INT 1
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 0
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 1
86591: NEG
86592: PUSH
86593: LD_INT 0
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: NEG
86615: PUSH
86616: LD_INT 2
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 0
86626: PUSH
86627: LD_INT 2
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 1
86637: PUSH
86638: LD_INT 1
86640: NEG
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 2
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 2
86658: PUSH
86659: LD_INT 1
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: LD_INT 1
86668: PUSH
86669: LD_INT 2
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: LD_INT 0
86678: PUSH
86679: LD_INT 2
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 1
86688: NEG
86689: PUSH
86690: LD_INT 1
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: NEG
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: LD_INT 3
86726: NEG
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: LD_INT 3
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 1
86745: PUSH
86746: LD_INT 2
86748: NEG
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: PUSH
86757: LD_INT 1
86759: NEG
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: PUSH
86765: LD_INT 3
86767: PUSH
86768: LD_INT 0
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 3
86777: PUSH
86778: LD_INT 1
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: PUSH
86788: LD_INT 3
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: LD_INT 3
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: LD_INT 2
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 2
86818: NEG
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 3
86829: NEG
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 3
86840: NEG
86841: PUSH
86842: LD_INT 1
86844: NEG
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86881: LD_ADDR_VAR 0 44
86885: PUSH
86886: LD_INT 0
86888: PUSH
86889: LD_INT 0
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 0
86898: PUSH
86899: LD_INT 1
86901: NEG
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 1
86909: PUSH
86910: LD_INT 0
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 1
86919: PUSH
86920: LD_INT 1
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 0
86929: PUSH
86930: LD_INT 1
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: LD_INT 0
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: LD_INT 1
86954: NEG
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 1
86962: NEG
86963: PUSH
86964: LD_INT 2
86966: NEG
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: LD_INT 1
86974: PUSH
86975: LD_INT 1
86977: NEG
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: LD_INT 0
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 2
86995: PUSH
86996: LD_INT 1
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 2
87005: PUSH
87006: LD_INT 2
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 1
87015: PUSH
87016: LD_INT 2
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 1
87025: NEG
87026: PUSH
87027: LD_INT 1
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 2
87036: NEG
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 2
87047: NEG
87048: PUSH
87049: LD_INT 1
87051: NEG
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 2
87059: NEG
87060: PUSH
87061: LD_INT 2
87063: NEG
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 2
87071: NEG
87072: PUSH
87073: LD_INT 3
87075: NEG
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 2
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 3
87094: PUSH
87095: LD_INT 0
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 3
87104: PUSH
87105: LD_INT 1
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 3
87114: PUSH
87115: LD_INT 2
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 3
87124: PUSH
87125: LD_INT 3
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 2
87134: PUSH
87135: LD_INT 3
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 2
87144: NEG
87145: PUSH
87146: LD_INT 1
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: LD_INT 3
87155: NEG
87156: PUSH
87157: LD_INT 0
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 3
87166: NEG
87167: PUSH
87168: LD_INT 1
87170: NEG
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: PUSH
87176: LD_INT 3
87178: NEG
87179: PUSH
87180: LD_INT 2
87182: NEG
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 3
87190: NEG
87191: PUSH
87192: LD_INT 3
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87231: LD_ADDR_VAR 0 45
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: LD_INT 0
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 0
87248: PUSH
87249: LD_INT 1
87251: NEG
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 1
87269: PUSH
87270: LD_INT 1
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 0
87279: PUSH
87280: LD_INT 1
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 1
87289: NEG
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: NEG
87301: PUSH
87302: LD_INT 1
87304: NEG
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 1
87312: NEG
87313: PUSH
87314: LD_INT 2
87316: NEG
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: LD_INT 2
87327: NEG
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 1
87335: PUSH
87336: LD_INT 1
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 2
87346: PUSH
87347: LD_INT 1
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 2
87356: PUSH
87357: LD_INT 2
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 1
87366: PUSH
87367: LD_INT 2
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: LD_INT 2
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 1
87386: NEG
87387: PUSH
87388: LD_INT 1
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 2
87397: NEG
87398: PUSH
87399: LD_INT 1
87401: NEG
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 2
87409: NEG
87410: PUSH
87411: LD_INT 2
87413: NEG
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 2
87421: NEG
87422: PUSH
87423: LD_INT 3
87425: NEG
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 1
87433: NEG
87434: PUSH
87435: LD_INT 3
87437: NEG
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 0
87445: PUSH
87446: LD_INT 3
87448: NEG
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: LD_INT 2
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 3
87467: PUSH
87468: LD_INT 2
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 3
87477: PUSH
87478: LD_INT 3
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 2
87487: PUSH
87488: LD_INT 3
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 3
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 0
87507: PUSH
87508: LD_INT 3
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 1
87517: NEG
87518: PUSH
87519: LD_INT 2
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 3
87528: NEG
87529: PUSH
87530: LD_INT 2
87532: NEG
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 3
87540: NEG
87541: PUSH
87542: LD_INT 3
87544: NEG
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87581: LD_ADDR_VAR 0 46
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: LD_INT 0
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 0
87598: PUSH
87599: LD_INT 1
87601: NEG
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: PUSH
87610: LD_INT 0
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 1
87619: PUSH
87620: LD_INT 1
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 0
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 1
87639: NEG
87640: PUSH
87641: LD_INT 0
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: LD_INT 1
87654: NEG
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 1
87662: NEG
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 0
87674: PUSH
87675: LD_INT 2
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 1
87685: PUSH
87686: LD_INT 1
87688: NEG
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: LD_INT 0
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 2
87706: PUSH
87707: LD_INT 1
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 1
87716: PUSH
87717: LD_INT 2
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: LD_INT 2
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 1
87736: NEG
87737: PUSH
87738: LD_INT 1
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 2
87747: NEG
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 2
87758: NEG
87759: PUSH
87760: LD_INT 1
87762: NEG
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: LD_INT 3
87774: NEG
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 0
87782: PUSH
87783: LD_INT 3
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: PUSH
87794: LD_INT 2
87796: NEG
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: PUSH
87805: LD_INT 1
87807: NEG
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 3
87815: PUSH
87816: LD_INT 0
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 3
87825: PUSH
87826: LD_INT 1
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: PUSH
87836: LD_INT 3
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: LD_INT 3
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: NEG
87867: PUSH
87868: LD_INT 1
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 3
87877: NEG
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 3
87888: NEG
87889: PUSH
87890: LD_INT 1
87892: NEG
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87929: LD_ADDR_VAR 0 47
87933: PUSH
87934: LD_INT 0
87936: PUSH
87937: LD_INT 0
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: LD_INT 1
87949: NEG
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: LD_INT 1
87957: PUSH
87958: LD_INT 0
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 1
87967: PUSH
87968: LD_INT 1
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 0
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 1
87987: NEG
87988: PUSH
87989: LD_INT 0
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: PUSH
87996: LD_INT 1
87998: NEG
87999: PUSH
88000: LD_INT 1
88002: NEG
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 1
88010: NEG
88011: PUSH
88012: LD_INT 2
88014: NEG
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 0
88022: PUSH
88023: LD_INT 2
88025: NEG
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 1
88033: PUSH
88034: LD_INT 1
88036: NEG
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 2
88044: NEG
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 2
88056: NEG
88057: PUSH
88058: LD_INT 2
88060: NEG
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88080: LD_ADDR_VAR 0 48
88084: PUSH
88085: LD_INT 0
88087: PUSH
88088: LD_INT 0
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 0
88097: PUSH
88098: LD_INT 1
88100: NEG
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 1
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 1
88118: PUSH
88119: LD_INT 1
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 0
88128: PUSH
88129: LD_INT 1
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 1
88138: NEG
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 1
88149: NEG
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 1
88161: NEG
88162: PUSH
88163: LD_INT 2
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 0
88173: PUSH
88174: LD_INT 2
88176: NEG
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: LD_INT 1
88184: PUSH
88185: LD_INT 1
88187: NEG
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 2
88195: PUSH
88196: LD_INT 0
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 2
88205: PUSH
88206: LD_INT 1
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88227: LD_ADDR_VAR 0 49
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: LD_INT 0
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 0
88244: PUSH
88245: LD_INT 1
88247: NEG
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 1
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: LD_INT 1
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: PUSH
88273: LD_INT 0
88275: PUSH
88276: LD_INT 1
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: LD_INT 1
88285: NEG
88286: PUSH
88287: LD_INT 0
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: LD_INT 1
88296: NEG
88297: PUSH
88298: LD_INT 1
88300: NEG
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 1
88308: PUSH
88309: LD_INT 1
88311: NEG
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 2
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 2
88329: PUSH
88330: LD_INT 1
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: LD_INT 2
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: LD_INT 2
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88371: LD_ADDR_VAR 0 50
88375: PUSH
88376: LD_INT 0
88378: PUSH
88379: LD_INT 0
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 0
88388: PUSH
88389: LD_INT 1
88391: NEG
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: LD_INT 0
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 1
88409: PUSH
88410: LD_INT 1
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 0
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 1
88429: NEG
88430: PUSH
88431: LD_INT 0
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 1
88440: NEG
88441: PUSH
88442: LD_INT 1
88444: NEG
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: PUSH
88450: LD_INT 2
88452: PUSH
88453: LD_INT 1
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PUSH
88460: LD_INT 2
88462: PUSH
88463: LD_INT 2
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 1
88472: PUSH
88473: LD_INT 2
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 0
88482: PUSH
88483: LD_INT 2
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 1
88492: NEG
88493: PUSH
88494: LD_INT 1
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88515: LD_ADDR_VAR 0 51
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 0
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 0
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: PUSH
88544: LD_INT 0
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PUSH
88551: LD_INT 1
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: LD_INT 1
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: LD_INT 0
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 1
88584: NEG
88585: PUSH
88586: LD_INT 1
88588: NEG
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: PUSH
88594: LD_INT 1
88596: PUSH
88597: LD_INT 2
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: LD_INT 2
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 1
88616: NEG
88617: PUSH
88618: LD_INT 1
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 2
88627: NEG
88628: PUSH
88629: LD_INT 0
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 2
88638: NEG
88639: PUSH
88640: LD_INT 1
88642: NEG
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88662: LD_ADDR_VAR 0 52
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: LD_INT 0
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 1
88682: NEG
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 1
88700: PUSH
88701: LD_INT 1
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: NEG
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 1
88731: NEG
88732: PUSH
88733: LD_INT 1
88735: NEG
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: PUSH
88741: LD_INT 1
88743: NEG
88744: PUSH
88745: LD_INT 2
88747: NEG
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 1
88755: NEG
88756: PUSH
88757: LD_INT 1
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 2
88766: NEG
88767: PUSH
88768: LD_INT 0
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 2
88777: NEG
88778: PUSH
88779: LD_INT 1
88781: NEG
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 2
88789: NEG
88790: PUSH
88791: LD_INT 2
88793: NEG
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88813: LD_ADDR_VAR 0 53
88817: PUSH
88818: LD_INT 0
88820: PUSH
88821: LD_INT 0
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 0
88830: PUSH
88831: LD_INT 1
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: LD_INT 0
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 1
88851: PUSH
88852: LD_INT 1
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: LD_INT 1
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 1
88871: NEG
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: NEG
88883: PUSH
88884: LD_INT 1
88886: NEG
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 1
88894: NEG
88895: PUSH
88896: LD_INT 2
88898: NEG
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: LD_INT 2
88909: NEG
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 1
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 2
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 2
88938: PUSH
88939: LD_INT 1
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 2
88948: PUSH
88949: LD_INT 2
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 2
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 2
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 1
88978: NEG
88979: PUSH
88980: LD_INT 1
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: NEG
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 2
89000: NEG
89001: PUSH
89002: LD_INT 1
89004: NEG
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 2
89012: NEG
89013: PUSH
89014: LD_INT 2
89016: NEG
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89043: LD_ADDR_VAR 0 54
89047: PUSH
89048: LD_INT 0
89050: PUSH
89051: LD_INT 0
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: LD_INT 1
89063: NEG
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 0
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 1
89081: PUSH
89082: LD_INT 1
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: LD_INT 1
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: LD_INT 0
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: NEG
89113: PUSH
89114: LD_INT 1
89116: NEG
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 1
89124: NEG
89125: PUSH
89126: LD_INT 2
89128: NEG
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 0
89136: PUSH
89137: LD_INT 2
89139: NEG
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: PUSH
89145: LD_INT 1
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 2
89158: PUSH
89159: LD_INT 0
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 2
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 2
89178: PUSH
89179: LD_INT 2
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 1
89188: PUSH
89189: LD_INT 2
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: LD_INT 2
89201: PUSH
89202: EMPTY
89203: LIST
89204: LIST
89205: PUSH
89206: LD_INT 1
89208: NEG
89209: PUSH
89210: LD_INT 1
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: LD_INT 2
89219: NEG
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 2
89230: NEG
89231: PUSH
89232: LD_INT 1
89234: NEG
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 2
89242: NEG
89243: PUSH
89244: LD_INT 2
89246: NEG
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89273: LD_ADDR_VAR 0 55
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: LD_INT 0
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 0
89290: PUSH
89291: LD_INT 1
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 1
89311: PUSH
89312: LD_INT 1
89314: PUSH
89315: EMPTY
89316: LIST
89317: LIST
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: LD_INT 1
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 1
89331: NEG
89332: PUSH
89333: LD_INT 0
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: NEG
89343: PUSH
89344: LD_INT 1
89346: NEG
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: LD_INT 1
89354: NEG
89355: PUSH
89356: LD_INT 2
89358: NEG
89359: PUSH
89360: EMPTY
89361: LIST
89362: LIST
89363: PUSH
89364: LD_INT 0
89366: PUSH
89367: LD_INT 2
89369: NEG
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: LD_INT 1
89380: NEG
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 2
89388: PUSH
89389: LD_INT 0
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 2
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 2
89408: PUSH
89409: LD_INT 2
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: LD_INT 1
89418: PUSH
89419: LD_INT 2
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 0
89428: PUSH
89429: LD_INT 2
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: NEG
89439: PUSH
89440: LD_INT 1
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 2
89449: NEG
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 2
89460: NEG
89461: PUSH
89462: LD_INT 1
89464: NEG
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 2
89472: NEG
89473: PUSH
89474: LD_INT 2
89476: NEG
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89503: LD_ADDR_VAR 0 56
89507: PUSH
89508: LD_INT 0
89510: PUSH
89511: LD_INT 0
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 0
89520: PUSH
89521: LD_INT 1
89523: NEG
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 1
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 1
89541: PUSH
89542: LD_INT 1
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 0
89551: PUSH
89552: LD_INT 1
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 1
89561: NEG
89562: PUSH
89563: LD_INT 0
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: NEG
89573: PUSH
89574: LD_INT 1
89576: NEG
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 1
89584: NEG
89585: PUSH
89586: LD_INT 2
89588: NEG
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 0
89596: PUSH
89597: LD_INT 2
89599: NEG
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 1
89607: PUSH
89608: LD_INT 1
89610: NEG
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 2
89618: PUSH
89619: LD_INT 0
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 2
89628: PUSH
89629: LD_INT 1
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 2
89638: PUSH
89639: LD_INT 2
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: PUSH
89649: LD_INT 2
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 0
89658: PUSH
89659: LD_INT 2
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 1
89668: NEG
89669: PUSH
89670: LD_INT 1
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 2
89679: NEG
89680: PUSH
89681: LD_INT 0
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: LD_INT 2
89690: NEG
89691: PUSH
89692: LD_INT 1
89694: NEG
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 2
89702: NEG
89703: PUSH
89704: LD_INT 2
89706: NEG
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89733: LD_ADDR_VAR 0 57
89737: PUSH
89738: LD_INT 0
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: LD_INT 1
89753: NEG
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 1
89761: PUSH
89762: LD_INT 0
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 1
89791: NEG
89792: PUSH
89793: LD_INT 0
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: NEG
89803: PUSH
89804: LD_INT 1
89806: NEG
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 1
89814: NEG
89815: PUSH
89816: LD_INT 2
89818: NEG
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 0
89826: PUSH
89827: LD_INT 2
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: LD_INT 1
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 2
89848: PUSH
89849: LD_INT 0
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 2
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 2
89868: PUSH
89869: LD_INT 2
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 1
89878: PUSH
89879: LD_INT 2
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PUSH
89886: LD_INT 0
89888: PUSH
89889: LD_INT 2
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 1
89898: NEG
89899: PUSH
89900: LD_INT 1
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 2
89909: NEG
89910: PUSH
89911: LD_INT 0
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 2
89920: NEG
89921: PUSH
89922: LD_INT 1
89924: NEG
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 2
89932: NEG
89933: PUSH
89934: LD_INT 2
89936: NEG
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89963: LD_ADDR_VAR 0 58
89967: PUSH
89968: LD_INT 0
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 0
89980: PUSH
89981: LD_INT 1
89983: NEG
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 1
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 1
90001: PUSH
90002: LD_INT 1
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 0
90011: PUSH
90012: LD_INT 1
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: LD_INT 1
90021: NEG
90022: PUSH
90023: LD_INT 0
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 1
90032: NEG
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 1
90044: NEG
90045: PUSH
90046: LD_INT 2
90048: NEG
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 0
90056: PUSH
90057: LD_INT 2
90059: NEG
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 1
90067: PUSH
90068: LD_INT 1
90070: NEG
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 2
90078: PUSH
90079: LD_INT 0
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 2
90088: PUSH
90089: LD_INT 1
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 2
90098: PUSH
90099: LD_INT 2
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: PUSH
90106: LD_INT 1
90108: PUSH
90109: LD_INT 2
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 0
90118: PUSH
90119: LD_INT 2
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 1
90128: NEG
90129: PUSH
90130: LD_INT 1
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: LD_INT 2
90139: NEG
90140: PUSH
90141: LD_INT 0
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 2
90150: NEG
90151: PUSH
90152: LD_INT 1
90154: NEG
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 2
90162: NEG
90163: PUSH
90164: LD_INT 2
90166: NEG
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90193: LD_ADDR_VAR 0 59
90197: PUSH
90198: LD_INT 0
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 0
90210: PUSH
90211: LD_INT 1
90213: NEG
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 1
90221: PUSH
90222: LD_INT 0
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 1
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 0
90241: PUSH
90242: LD_INT 1
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PUSH
90249: LD_INT 1
90251: NEG
90252: PUSH
90253: LD_INT 0
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: LD_INT 1
90266: NEG
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90281: LD_ADDR_VAR 0 60
90285: PUSH
90286: LD_INT 0
90288: PUSH
90289: LD_INT 0
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 0
90298: PUSH
90299: LD_INT 1
90301: NEG
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 1
90309: PUSH
90310: LD_INT 0
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: PUSH
90317: LD_INT 1
90319: PUSH
90320: LD_INT 1
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 0
90329: PUSH
90330: LD_INT 1
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 1
90350: NEG
90351: PUSH
90352: LD_INT 1
90354: NEG
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90369: LD_ADDR_VAR 0 61
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: LD_INT 0
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: PUSH
90384: LD_INT 0
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 1
90397: PUSH
90398: LD_INT 0
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: PUSH
90415: LD_INT 0
90417: PUSH
90418: LD_INT 1
90420: PUSH
90421: EMPTY
90422: LIST
90423: LIST
90424: PUSH
90425: LD_INT 1
90427: NEG
90428: PUSH
90429: LD_INT 0
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: LD_INT 1
90438: NEG
90439: PUSH
90440: LD_INT 1
90442: NEG
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90457: LD_ADDR_VAR 0 62
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: LD_INT 0
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 1
90477: NEG
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 0
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: LD_INT 1
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 0
90505: PUSH
90506: LD_INT 1
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: NEG
90516: PUSH
90517: LD_INT 0
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: LD_INT 1
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90545: LD_ADDR_VAR 0 63
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 0
90562: PUSH
90563: LD_INT 1
90565: NEG
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 1
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 0
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: NEG
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 1
90614: NEG
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90633: LD_ADDR_VAR 0 64
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 0
90650: PUSH
90651: LD_INT 1
90653: NEG
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 1
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 1
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 0
90681: PUSH
90682: LD_INT 1
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 1
90702: NEG
90703: PUSH
90704: LD_INT 1
90706: NEG
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: LIST
90720: ST_TO_ADDR
// end ; 1 :
90721: GO 96618
90723: LD_INT 1
90725: DOUBLE
90726: EQUAL
90727: IFTRUE 90731
90729: GO 93354
90731: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90732: LD_ADDR_VAR 0 11
90736: PUSH
90737: LD_INT 1
90739: NEG
90740: PUSH
90741: LD_INT 3
90743: NEG
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 0
90751: PUSH
90752: LD_INT 3
90754: NEG
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 1
90762: PUSH
90763: LD_INT 2
90765: NEG
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: LIST
90775: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90776: LD_ADDR_VAR 0 12
90780: PUSH
90781: LD_INT 2
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 3
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 3
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: LIST
90816: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90817: LD_ADDR_VAR 0 13
90821: PUSH
90822: LD_INT 3
90824: PUSH
90825: LD_INT 2
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: PUSH
90832: LD_INT 3
90834: PUSH
90835: LD_INT 3
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 2
90844: PUSH
90845: LD_INT 3
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: LIST
90856: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90857: LD_ADDR_VAR 0 14
90861: PUSH
90862: LD_INT 1
90864: PUSH
90865: LD_INT 3
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 0
90874: PUSH
90875: LD_INT 3
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 1
90884: NEG
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: LIST
90897: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90898: LD_ADDR_VAR 0 15
90902: PUSH
90903: LD_INT 2
90905: NEG
90906: PUSH
90907: LD_INT 1
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 3
90916: NEG
90917: PUSH
90918: LD_INT 0
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 3
90927: NEG
90928: PUSH
90929: LD_INT 1
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: LIST
90941: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90942: LD_ADDR_VAR 0 16
90946: PUSH
90947: LD_INT 2
90949: NEG
90950: PUSH
90951: LD_INT 3
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 3
90961: NEG
90962: PUSH
90963: LD_INT 2
90965: NEG
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 3
90973: NEG
90974: PUSH
90975: LD_INT 3
90977: NEG
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: LIST
90987: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90988: LD_ADDR_VAR 0 17
90992: PUSH
90993: LD_INT 1
90995: NEG
90996: PUSH
90997: LD_INT 3
90999: NEG
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: LD_INT 3
91010: NEG
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 1
91018: PUSH
91019: LD_INT 2
91021: NEG
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: LIST
91031: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91032: LD_ADDR_VAR 0 18
91036: PUSH
91037: LD_INT 2
91039: PUSH
91040: LD_INT 1
91042: NEG
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 3
91050: PUSH
91051: LD_INT 0
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 3
91060: PUSH
91061: LD_INT 1
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: LIST
91072: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91073: LD_ADDR_VAR 0 19
91077: PUSH
91078: LD_INT 3
91080: PUSH
91081: LD_INT 2
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 3
91090: PUSH
91091: LD_INT 3
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 2
91100: PUSH
91101: LD_INT 3
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: LIST
91112: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91113: LD_ADDR_VAR 0 20
91117: PUSH
91118: LD_INT 1
91120: PUSH
91121: LD_INT 3
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PUSH
91128: LD_INT 0
91130: PUSH
91131: LD_INT 3
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 1
91140: NEG
91141: PUSH
91142: LD_INT 2
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: LIST
91153: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91154: LD_ADDR_VAR 0 21
91158: PUSH
91159: LD_INT 2
91161: NEG
91162: PUSH
91163: LD_INT 1
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 3
91172: NEG
91173: PUSH
91174: LD_INT 0
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 3
91183: NEG
91184: PUSH
91185: LD_INT 1
91187: NEG
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: LIST
91197: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91198: LD_ADDR_VAR 0 22
91202: PUSH
91203: LD_INT 2
91205: NEG
91206: PUSH
91207: LD_INT 3
91209: NEG
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: LD_INT 2
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 3
91229: NEG
91230: PUSH
91231: LD_INT 3
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: LIST
91243: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91244: LD_ADDR_VAR 0 23
91248: PUSH
91249: LD_INT 0
91251: PUSH
91252: LD_INT 3
91254: NEG
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 4
91266: NEG
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 1
91274: PUSH
91275: LD_INT 3
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: LIST
91287: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91288: LD_ADDR_VAR 0 24
91292: PUSH
91293: LD_INT 3
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 3
91305: PUSH
91306: LD_INT 1
91308: NEG
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 4
91316: PUSH
91317: LD_INT 1
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91329: LD_ADDR_VAR 0 25
91333: PUSH
91334: LD_INT 3
91336: PUSH
91337: LD_INT 3
91339: PUSH
91340: EMPTY
91341: LIST
91342: LIST
91343: PUSH
91344: LD_INT 4
91346: PUSH
91347: LD_INT 3
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 3
91356: PUSH
91357: LD_INT 4
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: LIST
91368: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91369: LD_ADDR_VAR 0 26
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: LD_INT 3
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 1
91386: PUSH
91387: LD_INT 4
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 1
91396: NEG
91397: PUSH
91398: LD_INT 3
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: LIST
91409: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91410: LD_ADDR_VAR 0 27
91414: PUSH
91415: LD_INT 3
91417: NEG
91418: PUSH
91419: LD_INT 0
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 3
91428: NEG
91429: PUSH
91430: LD_INT 1
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 4
91439: NEG
91440: PUSH
91441: LD_INT 1
91443: NEG
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: LIST
91453: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91454: LD_ADDR_VAR 0 28
91458: PUSH
91459: LD_INT 3
91461: NEG
91462: PUSH
91463: LD_INT 3
91465: NEG
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 3
91473: NEG
91474: PUSH
91475: LD_INT 4
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 4
91485: NEG
91486: PUSH
91487: LD_INT 3
91489: NEG
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: LIST
91499: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
91500: LD_ADDR_VAR 0 29
91504: PUSH
91505: LD_INT 1
91507: NEG
91508: PUSH
91509: LD_INT 3
91511: NEG
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: LD_INT 3
91522: NEG
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 1
91530: PUSH
91531: LD_INT 2
91533: NEG
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 1
91541: NEG
91542: PUSH
91543: LD_INT 4
91545: NEG
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 0
91553: PUSH
91554: LD_INT 4
91556: NEG
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: LD_INT 3
91567: NEG
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 1
91575: NEG
91576: PUSH
91577: LD_INT 5
91579: NEG
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 0
91587: PUSH
91588: LD_INT 5
91590: NEG
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 1
91598: PUSH
91599: LD_INT 4
91601: NEG
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: PUSH
91607: LD_INT 1
91609: NEG
91610: PUSH
91611: LD_INT 6
91613: NEG
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: LD_INT 6
91624: NEG
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 1
91632: PUSH
91633: LD_INT 5
91635: NEG
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91655: LD_ADDR_VAR 0 30
91659: PUSH
91660: LD_INT 2
91662: PUSH
91663: LD_INT 1
91665: NEG
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 3
91673: PUSH
91674: LD_INT 0
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 3
91683: PUSH
91684: LD_INT 1
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 3
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 4
91704: PUSH
91705: LD_INT 0
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 4
91714: PUSH
91715: LD_INT 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 4
91724: PUSH
91725: LD_INT 1
91727: NEG
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 5
91735: PUSH
91736: LD_INT 0
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 5
91745: PUSH
91746: LD_INT 1
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: PUSH
91753: LD_INT 5
91755: PUSH
91756: LD_INT 1
91758: NEG
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 6
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: LD_INT 6
91776: PUSH
91777: LD_INT 1
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91798: LD_ADDR_VAR 0 31
91802: PUSH
91803: LD_INT 3
91805: PUSH
91806: LD_INT 2
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 3
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 2
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 4
91835: PUSH
91836: LD_INT 3
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: LD_INT 4
91845: PUSH
91846: LD_INT 4
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 3
91855: PUSH
91856: LD_INT 4
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 5
91865: PUSH
91866: LD_INT 4
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 5
91875: PUSH
91876: LD_INT 5
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 4
91885: PUSH
91886: LD_INT 5
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 6
91895: PUSH
91896: LD_INT 5
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 6
91905: PUSH
91906: LD_INT 6
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 5
91915: PUSH
91916: LD_INT 6
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91937: LD_ADDR_VAR 0 32
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 3
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: LD_INT 3
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: NEG
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 1
91975: PUSH
91976: LD_INT 4
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 0
91985: PUSH
91986: LD_INT 4
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 1
91995: NEG
91996: PUSH
91997: LD_INT 3
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 1
92006: PUSH
92007: LD_INT 5
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 0
92016: PUSH
92017: LD_INT 5
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 1
92026: NEG
92027: PUSH
92028: LD_INT 4
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 1
92037: PUSH
92038: LD_INT 6
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: PUSH
92045: LD_INT 0
92047: PUSH
92048: LD_INT 6
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 1
92057: NEG
92058: PUSH
92059: LD_INT 5
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92080: LD_ADDR_VAR 0 33
92084: PUSH
92085: LD_INT 2
92087: NEG
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 3
92098: NEG
92099: PUSH
92100: LD_INT 0
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 3
92109: NEG
92110: PUSH
92111: LD_INT 1
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 3
92121: NEG
92122: PUSH
92123: LD_INT 1
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PUSH
92130: LD_INT 4
92132: NEG
92133: PUSH
92134: LD_INT 0
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 4
92143: NEG
92144: PUSH
92145: LD_INT 1
92147: NEG
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 4
92155: NEG
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 5
92166: NEG
92167: PUSH
92168: LD_INT 0
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 5
92177: NEG
92178: PUSH
92179: LD_INT 1
92181: NEG
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 5
92189: NEG
92190: PUSH
92191: LD_INT 1
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: LD_INT 6
92200: NEG
92201: PUSH
92202: LD_INT 0
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 6
92211: NEG
92212: PUSH
92213: LD_INT 1
92215: NEG
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92235: LD_ADDR_VAR 0 34
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: LD_INT 3
92246: NEG
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 3
92254: NEG
92255: PUSH
92256: LD_INT 2
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 3
92266: NEG
92267: PUSH
92268: LD_INT 3
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 3
92278: NEG
92279: PUSH
92280: LD_INT 4
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 4
92290: NEG
92291: PUSH
92292: LD_INT 3
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 4
92302: NEG
92303: PUSH
92304: LD_INT 4
92306: NEG
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 4
92314: NEG
92315: PUSH
92316: LD_INT 5
92318: NEG
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 5
92326: NEG
92327: PUSH
92328: LD_INT 4
92330: NEG
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 5
92338: NEG
92339: PUSH
92340: LD_INT 5
92342: NEG
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PUSH
92348: LD_INT 5
92350: NEG
92351: PUSH
92352: LD_INT 6
92354: NEG
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 6
92362: NEG
92363: PUSH
92364: LD_INT 5
92366: NEG
92367: PUSH
92368: EMPTY
92369: LIST
92370: LIST
92371: PUSH
92372: LD_INT 6
92374: NEG
92375: PUSH
92376: LD_INT 6
92378: NEG
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92398: LD_ADDR_VAR 0 41
92402: PUSH
92403: LD_INT 0
92405: PUSH
92406: LD_INT 2
92408: NEG
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 1
92416: NEG
92417: PUSH
92418: LD_INT 3
92420: NEG
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 1
92428: PUSH
92429: LD_INT 2
92431: NEG
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: LIST
92441: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92442: LD_ADDR_VAR 0 42
92446: PUSH
92447: LD_INT 2
92449: PUSH
92450: LD_INT 0
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 2
92459: PUSH
92460: LD_INT 1
92462: NEG
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 3
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: LIST
92482: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92483: LD_ADDR_VAR 0 43
92487: PUSH
92488: LD_INT 2
92490: PUSH
92491: LD_INT 2
92493: PUSH
92494: EMPTY
92495: LIST
92496: LIST
92497: PUSH
92498: LD_INT 3
92500: PUSH
92501: LD_INT 2
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 2
92510: PUSH
92511: LD_INT 3
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: LIST
92522: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
92523: LD_ADDR_VAR 0 44
92527: PUSH
92528: LD_INT 0
92530: PUSH
92531: LD_INT 2
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PUSH
92538: LD_INT 1
92540: PUSH
92541: LD_INT 3
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 1
92550: NEG
92551: PUSH
92552: LD_INT 2
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: LIST
92563: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92564: LD_ADDR_VAR 0 45
92568: PUSH
92569: LD_INT 2
92571: NEG
92572: PUSH
92573: LD_INT 0
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 2
92582: NEG
92583: PUSH
92584: LD_INT 1
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 3
92593: NEG
92594: PUSH
92595: LD_INT 1
92597: NEG
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: LIST
92607: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92608: LD_ADDR_VAR 0 46
92612: PUSH
92613: LD_INT 2
92615: NEG
92616: PUSH
92617: LD_INT 2
92619: NEG
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: NEG
92628: PUSH
92629: LD_INT 3
92631: NEG
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 3
92639: NEG
92640: PUSH
92641: LD_INT 2
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: LIST
92653: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92654: LD_ADDR_VAR 0 47
92658: PUSH
92659: LD_INT 2
92661: NEG
92662: PUSH
92663: LD_INT 3
92665: NEG
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PUSH
92671: LD_INT 1
92673: NEG
92674: PUSH
92675: LD_INT 3
92677: NEG
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92687: LD_ADDR_VAR 0 48
92691: PUSH
92692: LD_INT 1
92694: PUSH
92695: LD_INT 2
92697: NEG
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: LD_INT 1
92708: NEG
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92718: LD_ADDR_VAR 0 49
92722: PUSH
92723: LD_INT 3
92725: PUSH
92726: LD_INT 1
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: PUSH
92736: LD_INT 2
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92747: LD_ADDR_VAR 0 50
92751: PUSH
92752: LD_INT 2
92754: PUSH
92755: LD_INT 3
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 1
92764: PUSH
92765: LD_INT 3
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92776: LD_ADDR_VAR 0 51
92780: PUSH
92781: LD_INT 1
92783: NEG
92784: PUSH
92785: LD_INT 2
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 2
92794: NEG
92795: PUSH
92796: LD_INT 1
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92807: LD_ADDR_VAR 0 52
92811: PUSH
92812: LD_INT 3
92814: NEG
92815: PUSH
92816: LD_INT 1
92818: NEG
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: LD_INT 3
92826: NEG
92827: PUSH
92828: LD_INT 2
92830: NEG
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: EMPTY
92837: LIST
92838: LIST
92839: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92840: LD_ADDR_VAR 0 53
92844: PUSH
92845: LD_INT 1
92847: NEG
92848: PUSH
92849: LD_INT 3
92851: NEG
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 0
92859: PUSH
92860: LD_INT 3
92862: NEG
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 1
92870: PUSH
92871: LD_INT 2
92873: NEG
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: LIST
92883: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92884: LD_ADDR_VAR 0 54
92888: PUSH
92889: LD_INT 2
92891: PUSH
92892: LD_INT 1
92894: NEG
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: LD_INT 3
92902: PUSH
92903: LD_INT 0
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: LD_INT 3
92912: PUSH
92913: LD_INT 1
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: LIST
92924: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92925: LD_ADDR_VAR 0 55
92929: PUSH
92930: LD_INT 3
92932: PUSH
92933: LD_INT 2
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 3
92942: PUSH
92943: LD_INT 3
92945: PUSH
92946: EMPTY
92947: LIST
92948: LIST
92949: PUSH
92950: LD_INT 2
92952: PUSH
92953: LD_INT 3
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: LIST
92964: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92965: LD_ADDR_VAR 0 56
92969: PUSH
92970: LD_INT 1
92972: PUSH
92973: LD_INT 3
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 0
92982: PUSH
92983: LD_INT 3
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 1
92992: NEG
92993: PUSH
92994: LD_INT 2
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: LIST
93005: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93006: LD_ADDR_VAR 0 57
93010: PUSH
93011: LD_INT 2
93013: NEG
93014: PUSH
93015: LD_INT 1
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 3
93024: NEG
93025: PUSH
93026: LD_INT 0
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 3
93035: NEG
93036: PUSH
93037: LD_INT 1
93039: NEG
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: LIST
93049: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93050: LD_ADDR_VAR 0 58
93054: PUSH
93055: LD_INT 2
93057: NEG
93058: PUSH
93059: LD_INT 3
93061: NEG
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 3
93069: NEG
93070: PUSH
93071: LD_INT 2
93073: NEG
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 3
93081: NEG
93082: PUSH
93083: LD_INT 3
93085: NEG
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: LIST
93095: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93096: LD_ADDR_VAR 0 59
93100: PUSH
93101: LD_INT 1
93103: NEG
93104: PUSH
93105: LD_INT 2
93107: NEG
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 0
93115: PUSH
93116: LD_INT 2
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 1
93126: PUSH
93127: LD_INT 1
93129: NEG
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: EMPTY
93136: LIST
93137: LIST
93138: LIST
93139: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93140: LD_ADDR_VAR 0 60
93144: PUSH
93145: LD_INT 1
93147: PUSH
93148: LD_INT 1
93150: NEG
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 2
93158: PUSH
93159: LD_INT 0
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 2
93168: PUSH
93169: LD_INT 1
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: LIST
93180: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93181: LD_ADDR_VAR 0 61
93185: PUSH
93186: LD_INT 2
93188: PUSH
93189: LD_INT 1
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 2
93198: PUSH
93199: LD_INT 2
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 1
93208: PUSH
93209: LD_INT 2
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: LIST
93220: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93221: LD_ADDR_VAR 0 62
93225: PUSH
93226: LD_INT 1
93228: PUSH
93229: LD_INT 2
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 2
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 1
93248: NEG
93249: PUSH
93250: LD_INT 1
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: LIST
93261: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93262: LD_ADDR_VAR 0 63
93266: PUSH
93267: LD_INT 1
93269: NEG
93270: PUSH
93271: LD_INT 1
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 2
93280: NEG
93281: PUSH
93282: LD_INT 0
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 2
93291: NEG
93292: PUSH
93293: LD_INT 1
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: LIST
93305: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93306: LD_ADDR_VAR 0 64
93310: PUSH
93311: LD_INT 1
93313: NEG
93314: PUSH
93315: LD_INT 2
93317: NEG
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 2
93325: NEG
93326: PUSH
93327: LD_INT 1
93329: NEG
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 2
93337: NEG
93338: PUSH
93339: LD_INT 2
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: LIST
93351: ST_TO_ADDR
// end ; 2 :
93352: GO 96618
93354: LD_INT 2
93356: DOUBLE
93357: EQUAL
93358: IFTRUE 93362
93360: GO 96617
93362: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93363: LD_ADDR_VAR 0 29
93367: PUSH
93368: LD_INT 4
93370: PUSH
93371: LD_INT 0
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 4
93380: PUSH
93381: LD_INT 1
93383: NEG
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 5
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 5
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 4
93411: PUSH
93412: LD_INT 1
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 3
93421: PUSH
93422: LD_INT 0
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 3
93431: PUSH
93432: LD_INT 1
93434: NEG
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 3
93442: PUSH
93443: LD_INT 2
93445: NEG
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: PUSH
93451: LD_INT 5
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 3
93463: PUSH
93464: LD_INT 3
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: LD_INT 3
93473: PUSH
93474: LD_INT 2
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 4
93483: PUSH
93484: LD_INT 3
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 4
93493: PUSH
93494: LD_INT 4
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 3
93503: PUSH
93504: LD_INT 4
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: LD_INT 2
93513: PUSH
93514: LD_INT 3
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 2
93523: PUSH
93524: LD_INT 2
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 4
93533: PUSH
93534: LD_INT 2
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 2
93543: PUSH
93544: LD_INT 4
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 0
93553: PUSH
93554: LD_INT 4
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: LD_INT 3
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 1
93573: PUSH
93574: LD_INT 4
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 1
93583: PUSH
93584: LD_INT 5
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 0
93593: PUSH
93594: LD_INT 5
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 1
93603: NEG
93604: PUSH
93605: LD_INT 4
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 1
93614: NEG
93615: PUSH
93616: LD_INT 3
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 2
93625: PUSH
93626: LD_INT 5
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 2
93635: NEG
93636: PUSH
93637: LD_INT 3
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 3
93646: NEG
93647: PUSH
93648: LD_INT 0
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 3
93657: NEG
93658: PUSH
93659: LD_INT 1
93661: NEG
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 2
93669: NEG
93670: PUSH
93671: LD_INT 0
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 2
93680: NEG
93681: PUSH
93682: LD_INT 1
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 3
93691: NEG
93692: PUSH
93693: LD_INT 1
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: PUSH
93700: LD_INT 4
93702: NEG
93703: PUSH
93704: LD_INT 0
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 4
93713: NEG
93714: PUSH
93715: LD_INT 1
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 4
93725: NEG
93726: PUSH
93727: LD_INT 2
93729: NEG
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PUSH
93735: LD_INT 2
93737: NEG
93738: PUSH
93739: LD_INT 2
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PUSH
93746: LD_INT 4
93748: NEG
93749: PUSH
93750: LD_INT 4
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 4
93760: NEG
93761: PUSH
93762: LD_INT 5
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 3
93772: NEG
93773: PUSH
93774: LD_INT 4
93776: NEG
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: LD_INT 3
93784: NEG
93785: PUSH
93786: LD_INT 3
93788: NEG
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 4
93796: NEG
93797: PUSH
93798: LD_INT 3
93800: NEG
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 5
93808: NEG
93809: PUSH
93810: LD_INT 4
93812: NEG
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: LD_INT 5
93820: NEG
93821: PUSH
93822: LD_INT 5
93824: NEG
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 3
93832: NEG
93833: PUSH
93834: LD_INT 5
93836: NEG
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 5
93844: NEG
93845: PUSH
93846: LD_INT 3
93848: NEG
93849: PUSH
93850: EMPTY
93851: LIST
93852: LIST
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93901: LD_ADDR_VAR 0 30
93905: PUSH
93906: LD_INT 4
93908: PUSH
93909: LD_INT 4
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 4
93918: PUSH
93919: LD_INT 3
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 5
93928: PUSH
93929: LD_INT 4
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 5
93938: PUSH
93939: LD_INT 5
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 4
93948: PUSH
93949: LD_INT 5
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 3
93958: PUSH
93959: LD_INT 4
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 3
93968: PUSH
93969: LD_INT 3
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: LD_INT 5
93978: PUSH
93979: LD_INT 3
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: PUSH
93986: LD_INT 3
93988: PUSH
93989: LD_INT 5
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 0
93998: PUSH
93999: LD_INT 3
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 0
94008: PUSH
94009: LD_INT 2
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: PUSH
94016: LD_INT 1
94018: PUSH
94019: LD_INT 3
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: PUSH
94026: LD_INT 1
94028: PUSH
94029: LD_INT 4
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 0
94038: PUSH
94039: LD_INT 4
94041: PUSH
94042: EMPTY
94043: LIST
94044: LIST
94045: PUSH
94046: LD_INT 1
94048: NEG
94049: PUSH
94050: LD_INT 3
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 1
94059: NEG
94060: PUSH
94061: LD_INT 2
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 2
94070: PUSH
94071: LD_INT 4
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: PUSH
94078: LD_INT 2
94080: NEG
94081: PUSH
94082: LD_INT 2
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 4
94091: NEG
94092: PUSH
94093: LD_INT 0
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 4
94102: NEG
94103: PUSH
94104: LD_INT 1
94106: NEG
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 3
94114: NEG
94115: PUSH
94116: LD_INT 0
94118: PUSH
94119: EMPTY
94120: LIST
94121: LIST
94122: PUSH
94123: LD_INT 3
94125: NEG
94126: PUSH
94127: LD_INT 1
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: LD_INT 4
94136: NEG
94137: PUSH
94138: LD_INT 1
94140: PUSH
94141: EMPTY
94142: LIST
94143: LIST
94144: PUSH
94145: LD_INT 5
94147: NEG
94148: PUSH
94149: LD_INT 0
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 5
94158: NEG
94159: PUSH
94160: LD_INT 1
94162: NEG
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 5
94170: NEG
94171: PUSH
94172: LD_INT 2
94174: NEG
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: LD_INT 3
94182: NEG
94183: PUSH
94184: LD_INT 2
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 3
94193: NEG
94194: PUSH
94195: LD_INT 3
94197: NEG
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 3
94205: NEG
94206: PUSH
94207: LD_INT 4
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 2
94217: NEG
94218: PUSH
94219: LD_INT 3
94221: NEG
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 2
94229: NEG
94230: PUSH
94231: LD_INT 2
94233: NEG
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 3
94241: NEG
94242: PUSH
94243: LD_INT 2
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 4
94253: NEG
94254: PUSH
94255: LD_INT 3
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 4
94265: NEG
94266: PUSH
94267: LD_INT 4
94269: NEG
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 2
94277: NEG
94278: PUSH
94279: LD_INT 4
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 4
94289: NEG
94290: PUSH
94291: LD_INT 2
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 0
94301: PUSH
94302: LD_INT 4
94304: NEG
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 0
94312: PUSH
94313: LD_INT 5
94315: NEG
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 1
94323: PUSH
94324: LD_INT 4
94326: NEG
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 1
94334: PUSH
94335: LD_INT 3
94337: NEG
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 0
94345: PUSH
94346: LD_INT 3
94348: NEG
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 1
94356: NEG
94357: PUSH
94358: LD_INT 4
94360: NEG
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 1
94368: NEG
94369: PUSH
94370: LD_INT 5
94372: NEG
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 2
94380: PUSH
94381: LD_INT 3
94383: NEG
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 2
94391: NEG
94392: PUSH
94393: LD_INT 5
94395: NEG
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94448: LD_ADDR_VAR 0 31
94452: PUSH
94453: LD_INT 0
94455: PUSH
94456: LD_INT 4
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 0
94465: PUSH
94466: LD_INT 3
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 1
94475: PUSH
94476: LD_INT 4
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: LD_INT 5
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 0
94495: PUSH
94496: LD_INT 5
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 1
94505: NEG
94506: PUSH
94507: LD_INT 4
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 1
94516: NEG
94517: PUSH
94518: LD_INT 3
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 2
94527: PUSH
94528: LD_INT 5
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 2
94537: NEG
94538: PUSH
94539: LD_INT 3
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 3
94548: NEG
94549: PUSH
94550: LD_INT 0
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 3
94559: NEG
94560: PUSH
94561: LD_INT 1
94563: NEG
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 2
94571: NEG
94572: PUSH
94573: LD_INT 0
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: PUSH
94580: LD_INT 2
94582: NEG
94583: PUSH
94584: LD_INT 1
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 3
94593: NEG
94594: PUSH
94595: LD_INT 1
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 4
94604: NEG
94605: PUSH
94606: LD_INT 0
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 4
94615: NEG
94616: PUSH
94617: LD_INT 1
94619: NEG
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 4
94627: NEG
94628: PUSH
94629: LD_INT 2
94631: NEG
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 2
94639: NEG
94640: PUSH
94641: LD_INT 2
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 4
94650: NEG
94651: PUSH
94652: LD_INT 4
94654: NEG
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 4
94662: NEG
94663: PUSH
94664: LD_INT 5
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 3
94674: NEG
94675: PUSH
94676: LD_INT 4
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 3
94686: NEG
94687: PUSH
94688: LD_INT 3
94690: NEG
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 4
94698: NEG
94699: PUSH
94700: LD_INT 3
94702: NEG
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 5
94710: NEG
94711: PUSH
94712: LD_INT 4
94714: NEG
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 5
94722: NEG
94723: PUSH
94724: LD_INT 5
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 3
94734: NEG
94735: PUSH
94736: LD_INT 5
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 5
94746: NEG
94747: PUSH
94748: LD_INT 3
94750: NEG
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 0
94758: PUSH
94759: LD_INT 3
94761: NEG
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 0
94769: PUSH
94770: LD_INT 4
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 1
94780: PUSH
94781: LD_INT 3
94783: NEG
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 1
94791: PUSH
94792: LD_INT 2
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 0
94802: PUSH
94803: LD_INT 2
94805: NEG
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 1
94813: NEG
94814: PUSH
94815: LD_INT 3
94817: NEG
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 1
94825: NEG
94826: PUSH
94827: LD_INT 4
94829: NEG
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 2
94837: PUSH
94838: LD_INT 2
94840: NEG
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 2
94848: NEG
94849: PUSH
94850: LD_INT 4
94852: NEG
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 4
94860: PUSH
94861: LD_INT 0
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: PUSH
94868: LD_INT 4
94870: PUSH
94871: LD_INT 1
94873: NEG
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 5
94881: PUSH
94882: LD_INT 0
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 5
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 4
94901: PUSH
94902: LD_INT 1
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 3
94911: PUSH
94912: LD_INT 0
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 3
94921: PUSH
94922: LD_INT 1
94924: NEG
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 3
94932: PUSH
94933: LD_INT 2
94935: NEG
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 5
94943: PUSH
94944: LD_INT 2
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94998: LD_ADDR_VAR 0 32
95002: PUSH
95003: LD_INT 4
95005: NEG
95006: PUSH
95007: LD_INT 0
95009: PUSH
95010: EMPTY
95011: LIST
95012: LIST
95013: PUSH
95014: LD_INT 4
95016: NEG
95017: PUSH
95018: LD_INT 1
95020: NEG
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 3
95028: NEG
95029: PUSH
95030: LD_INT 0
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 3
95039: NEG
95040: PUSH
95041: LD_INT 1
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 4
95050: NEG
95051: PUSH
95052: LD_INT 1
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 5
95061: NEG
95062: PUSH
95063: LD_INT 0
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: LD_INT 5
95072: NEG
95073: PUSH
95074: LD_INT 1
95076: NEG
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 5
95084: NEG
95085: PUSH
95086: LD_INT 2
95088: NEG
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 3
95096: NEG
95097: PUSH
95098: LD_INT 2
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PUSH
95105: LD_INT 3
95107: NEG
95108: PUSH
95109: LD_INT 3
95111: NEG
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 3
95119: NEG
95120: PUSH
95121: LD_INT 4
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 2
95131: NEG
95132: PUSH
95133: LD_INT 3
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 2
95143: NEG
95144: PUSH
95145: LD_INT 2
95147: NEG
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 3
95155: NEG
95156: PUSH
95157: LD_INT 2
95159: NEG
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 4
95167: NEG
95168: PUSH
95169: LD_INT 3
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 4
95179: NEG
95180: PUSH
95181: LD_INT 4
95183: NEG
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 2
95191: NEG
95192: PUSH
95193: LD_INT 4
95195: NEG
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 4
95203: NEG
95204: PUSH
95205: LD_INT 2
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 0
95215: PUSH
95216: LD_INT 4
95218: NEG
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 0
95226: PUSH
95227: LD_INT 5
95229: NEG
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 1
95237: PUSH
95238: LD_INT 4
95240: NEG
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 1
95248: PUSH
95249: LD_INT 3
95251: NEG
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 0
95259: PUSH
95260: LD_INT 3
95262: NEG
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 1
95270: NEG
95271: PUSH
95272: LD_INT 4
95274: NEG
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 1
95282: NEG
95283: PUSH
95284: LD_INT 5
95286: NEG
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: LD_INT 2
95294: PUSH
95295: LD_INT 3
95297: NEG
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 2
95305: NEG
95306: PUSH
95307: LD_INT 5
95309: NEG
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 3
95317: PUSH
95318: LD_INT 0
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 3
95327: PUSH
95328: LD_INT 1
95330: NEG
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: LD_INT 4
95338: PUSH
95339: LD_INT 0
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 4
95348: PUSH
95349: LD_INT 1
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 3
95358: PUSH
95359: LD_INT 1
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 2
95368: PUSH
95369: LD_INT 0
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 2
95378: PUSH
95379: LD_INT 1
95381: NEG
95382: PUSH
95383: EMPTY
95384: LIST
95385: LIST
95386: PUSH
95387: LD_INT 2
95389: PUSH
95390: LD_INT 2
95392: NEG
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: LD_INT 4
95400: PUSH
95401: LD_INT 2
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 4
95410: PUSH
95411: LD_INT 4
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 4
95420: PUSH
95421: LD_INT 3
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 5
95430: PUSH
95431: LD_INT 4
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 5
95440: PUSH
95441: LD_INT 5
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: LD_INT 4
95450: PUSH
95451: LD_INT 5
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: PUSH
95458: LD_INT 3
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 3
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: LD_INT 5
95480: PUSH
95481: LD_INT 3
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 3
95490: PUSH
95491: LD_INT 5
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95545: LD_ADDR_VAR 0 33
95549: PUSH
95550: LD_INT 4
95552: NEG
95553: PUSH
95554: LD_INT 4
95556: NEG
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 4
95564: NEG
95565: PUSH
95566: LD_INT 5
95568: NEG
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PUSH
95574: LD_INT 3
95576: NEG
95577: PUSH
95578: LD_INT 4
95580: NEG
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: PUSH
95586: LD_INT 3
95588: NEG
95589: PUSH
95590: LD_INT 3
95592: NEG
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 4
95600: NEG
95601: PUSH
95602: LD_INT 3
95604: NEG
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: PUSH
95610: LD_INT 5
95612: NEG
95613: PUSH
95614: LD_INT 4
95616: NEG
95617: PUSH
95618: EMPTY
95619: LIST
95620: LIST
95621: PUSH
95622: LD_INT 5
95624: NEG
95625: PUSH
95626: LD_INT 5
95628: NEG
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 3
95636: NEG
95637: PUSH
95638: LD_INT 5
95640: NEG
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 5
95648: NEG
95649: PUSH
95650: LD_INT 3
95652: NEG
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 0
95660: PUSH
95661: LD_INT 3
95663: NEG
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: LD_INT 4
95674: NEG
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 1
95682: PUSH
95683: LD_INT 3
95685: NEG
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 1
95693: PUSH
95694: LD_INT 2
95696: NEG
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 0
95704: PUSH
95705: LD_INT 2
95707: NEG
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 1
95715: NEG
95716: PUSH
95717: LD_INT 3
95719: NEG
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 1
95727: NEG
95728: PUSH
95729: LD_INT 4
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 2
95739: PUSH
95740: LD_INT 2
95742: NEG
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 2
95750: NEG
95751: PUSH
95752: LD_INT 4
95754: NEG
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: PUSH
95760: LD_INT 4
95762: PUSH
95763: LD_INT 0
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 4
95772: PUSH
95773: LD_INT 1
95775: NEG
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 5
95783: PUSH
95784: LD_INT 0
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 5
95793: PUSH
95794: LD_INT 1
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: LD_INT 4
95803: PUSH
95804: LD_INT 1
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 3
95813: PUSH
95814: LD_INT 0
95816: PUSH
95817: EMPTY
95818: LIST
95819: LIST
95820: PUSH
95821: LD_INT 3
95823: PUSH
95824: LD_INT 1
95826: NEG
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PUSH
95832: LD_INT 3
95834: PUSH
95835: LD_INT 2
95837: NEG
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 5
95845: PUSH
95846: LD_INT 2
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 3
95855: PUSH
95856: LD_INT 3
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 3
95865: PUSH
95866: LD_INT 2
95868: PUSH
95869: EMPTY
95870: LIST
95871: LIST
95872: PUSH
95873: LD_INT 4
95875: PUSH
95876: LD_INT 3
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 4
95885: PUSH
95886: LD_INT 4
95888: PUSH
95889: EMPTY
95890: LIST
95891: LIST
95892: PUSH
95893: LD_INT 3
95895: PUSH
95896: LD_INT 4
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: LD_INT 2
95905: PUSH
95906: LD_INT 3
95908: PUSH
95909: EMPTY
95910: LIST
95911: LIST
95912: PUSH
95913: LD_INT 2
95915: PUSH
95916: LD_INT 2
95918: PUSH
95919: EMPTY
95920: LIST
95921: LIST
95922: PUSH
95923: LD_INT 4
95925: PUSH
95926: LD_INT 2
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 2
95935: PUSH
95936: LD_INT 4
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 0
95945: PUSH
95946: LD_INT 4
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 0
95955: PUSH
95956: LD_INT 3
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 1
95965: PUSH
95966: LD_INT 4
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 1
95975: PUSH
95976: LD_INT 5
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 0
95985: PUSH
95986: LD_INT 5
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 1
95995: NEG
95996: PUSH
95997: LD_INT 4
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 1
96006: NEG
96007: PUSH
96008: LD_INT 3
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PUSH
96015: LD_INT 2
96017: PUSH
96018: LD_INT 5
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 2
96027: NEG
96028: PUSH
96029: LD_INT 3
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96083: LD_ADDR_VAR 0 34
96087: PUSH
96088: LD_INT 0
96090: PUSH
96091: LD_INT 4
96093: NEG
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PUSH
96099: LD_INT 0
96101: PUSH
96102: LD_INT 5
96104: NEG
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 1
96112: PUSH
96113: LD_INT 4
96115: NEG
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 1
96123: PUSH
96124: LD_INT 3
96126: NEG
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: PUSH
96132: LD_INT 0
96134: PUSH
96135: LD_INT 3
96137: NEG
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: LD_INT 1
96145: NEG
96146: PUSH
96147: LD_INT 4
96149: NEG
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 1
96157: NEG
96158: PUSH
96159: LD_INT 5
96161: NEG
96162: PUSH
96163: EMPTY
96164: LIST
96165: LIST
96166: PUSH
96167: LD_INT 2
96169: PUSH
96170: LD_INT 3
96172: NEG
96173: PUSH
96174: EMPTY
96175: LIST
96176: LIST
96177: PUSH
96178: LD_INT 2
96180: NEG
96181: PUSH
96182: LD_INT 5
96184: NEG
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 3
96192: PUSH
96193: LD_INT 0
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 3
96202: PUSH
96203: LD_INT 1
96205: NEG
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 4
96213: PUSH
96214: LD_INT 0
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 4
96223: PUSH
96224: LD_INT 1
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 3
96233: PUSH
96234: LD_INT 1
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 2
96243: PUSH
96244: LD_INT 0
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: LD_INT 2
96253: PUSH
96254: LD_INT 1
96256: NEG
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PUSH
96262: LD_INT 2
96264: PUSH
96265: LD_INT 2
96267: NEG
96268: PUSH
96269: EMPTY
96270: LIST
96271: LIST
96272: PUSH
96273: LD_INT 4
96275: PUSH
96276: LD_INT 2
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: LD_INT 4
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 4
96295: PUSH
96296: LD_INT 3
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 5
96305: PUSH
96306: LD_INT 4
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 5
96315: PUSH
96316: LD_INT 5
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 4
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 3
96335: PUSH
96336: LD_INT 4
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 3
96345: PUSH
96346: LD_INT 3
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 5
96355: PUSH
96356: LD_INT 3
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 3
96365: PUSH
96366: LD_INT 5
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 0
96375: PUSH
96376: LD_INT 3
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: LD_INT 0
96385: PUSH
96386: LD_INT 2
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: PUSH
96393: LD_INT 1
96395: PUSH
96396: LD_INT 3
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 1
96405: PUSH
96406: LD_INT 4
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 0
96415: PUSH
96416: LD_INT 4
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 1
96425: NEG
96426: PUSH
96427: LD_INT 3
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 1
96436: NEG
96437: PUSH
96438: LD_INT 2
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 2
96447: PUSH
96448: LD_INT 4
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 2
96457: NEG
96458: PUSH
96459: LD_INT 2
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 4
96468: NEG
96469: PUSH
96470: LD_INT 0
96472: PUSH
96473: EMPTY
96474: LIST
96475: LIST
96476: PUSH
96477: LD_INT 4
96479: NEG
96480: PUSH
96481: LD_INT 1
96483: NEG
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: LD_INT 3
96491: NEG
96492: PUSH
96493: LD_INT 0
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: LD_INT 3
96502: NEG
96503: PUSH
96504: LD_INT 1
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: PUSH
96511: LD_INT 4
96513: NEG
96514: PUSH
96515: LD_INT 1
96517: PUSH
96518: EMPTY
96519: LIST
96520: LIST
96521: PUSH
96522: LD_INT 5
96524: NEG
96525: PUSH
96526: LD_INT 0
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: LD_INT 5
96535: NEG
96536: PUSH
96537: LD_INT 1
96539: NEG
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: LD_INT 5
96547: NEG
96548: PUSH
96549: LD_INT 2
96551: NEG
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 3
96559: NEG
96560: PUSH
96561: LD_INT 2
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: ST_TO_ADDR
// end ; end ;
96615: GO 96618
96617: POP
// case btype of b_depot , b_warehouse :
96618: LD_VAR 0 1
96622: PUSH
96623: LD_INT 0
96625: DOUBLE
96626: EQUAL
96627: IFTRUE 96637
96629: LD_INT 1
96631: DOUBLE
96632: EQUAL
96633: IFTRUE 96637
96635: GO 96838
96637: POP
// case nation of nation_american :
96638: LD_VAR 0 5
96642: PUSH
96643: LD_INT 1
96645: DOUBLE
96646: EQUAL
96647: IFTRUE 96651
96649: GO 96707
96651: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96652: LD_ADDR_VAR 0 9
96656: PUSH
96657: LD_VAR 0 11
96661: PUSH
96662: LD_VAR 0 12
96666: PUSH
96667: LD_VAR 0 13
96671: PUSH
96672: LD_VAR 0 14
96676: PUSH
96677: LD_VAR 0 15
96681: PUSH
96682: LD_VAR 0 16
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: PUSH
96695: LD_VAR 0 4
96699: PUSH
96700: LD_INT 1
96702: PLUS
96703: ARRAY
96704: ST_TO_ADDR
96705: GO 96836
96707: LD_INT 2
96709: DOUBLE
96710: EQUAL
96711: IFTRUE 96715
96713: GO 96771
96715: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96716: LD_ADDR_VAR 0 9
96720: PUSH
96721: LD_VAR 0 17
96725: PUSH
96726: LD_VAR 0 18
96730: PUSH
96731: LD_VAR 0 19
96735: PUSH
96736: LD_VAR 0 20
96740: PUSH
96741: LD_VAR 0 21
96745: PUSH
96746: LD_VAR 0 22
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: PUSH
96759: LD_VAR 0 4
96763: PUSH
96764: LD_INT 1
96766: PLUS
96767: ARRAY
96768: ST_TO_ADDR
96769: GO 96836
96771: LD_INT 3
96773: DOUBLE
96774: EQUAL
96775: IFTRUE 96779
96777: GO 96835
96779: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96780: LD_ADDR_VAR 0 9
96784: PUSH
96785: LD_VAR 0 23
96789: PUSH
96790: LD_VAR 0 24
96794: PUSH
96795: LD_VAR 0 25
96799: PUSH
96800: LD_VAR 0 26
96804: PUSH
96805: LD_VAR 0 27
96809: PUSH
96810: LD_VAR 0 28
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: PUSH
96823: LD_VAR 0 4
96827: PUSH
96828: LD_INT 1
96830: PLUS
96831: ARRAY
96832: ST_TO_ADDR
96833: GO 96836
96835: POP
96836: GO 97391
96838: LD_INT 2
96840: DOUBLE
96841: EQUAL
96842: IFTRUE 96852
96844: LD_INT 3
96846: DOUBLE
96847: EQUAL
96848: IFTRUE 96852
96850: GO 96908
96852: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96853: LD_ADDR_VAR 0 9
96857: PUSH
96858: LD_VAR 0 29
96862: PUSH
96863: LD_VAR 0 30
96867: PUSH
96868: LD_VAR 0 31
96872: PUSH
96873: LD_VAR 0 32
96877: PUSH
96878: LD_VAR 0 33
96882: PUSH
96883: LD_VAR 0 34
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: PUSH
96896: LD_VAR 0 4
96900: PUSH
96901: LD_INT 1
96903: PLUS
96904: ARRAY
96905: ST_TO_ADDR
96906: GO 97391
96908: LD_INT 16
96910: DOUBLE
96911: EQUAL
96912: IFTRUE 96970
96914: LD_INT 17
96916: DOUBLE
96917: EQUAL
96918: IFTRUE 96970
96920: LD_INT 18
96922: DOUBLE
96923: EQUAL
96924: IFTRUE 96970
96926: LD_INT 19
96928: DOUBLE
96929: EQUAL
96930: IFTRUE 96970
96932: LD_INT 22
96934: DOUBLE
96935: EQUAL
96936: IFTRUE 96970
96938: LD_INT 20
96940: DOUBLE
96941: EQUAL
96942: IFTRUE 96970
96944: LD_INT 21
96946: DOUBLE
96947: EQUAL
96948: IFTRUE 96970
96950: LD_INT 23
96952: DOUBLE
96953: EQUAL
96954: IFTRUE 96970
96956: LD_INT 24
96958: DOUBLE
96959: EQUAL
96960: IFTRUE 96970
96962: LD_INT 25
96964: DOUBLE
96965: EQUAL
96966: IFTRUE 96970
96968: GO 97026
96970: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96971: LD_ADDR_VAR 0 9
96975: PUSH
96976: LD_VAR 0 35
96980: PUSH
96981: LD_VAR 0 36
96985: PUSH
96986: LD_VAR 0 37
96990: PUSH
96991: LD_VAR 0 38
96995: PUSH
96996: LD_VAR 0 39
97000: PUSH
97001: LD_VAR 0 40
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: PUSH
97014: LD_VAR 0 4
97018: PUSH
97019: LD_INT 1
97021: PLUS
97022: ARRAY
97023: ST_TO_ADDR
97024: GO 97391
97026: LD_INT 6
97028: DOUBLE
97029: EQUAL
97030: IFTRUE 97082
97032: LD_INT 7
97034: DOUBLE
97035: EQUAL
97036: IFTRUE 97082
97038: LD_INT 8
97040: DOUBLE
97041: EQUAL
97042: IFTRUE 97082
97044: LD_INT 13
97046: DOUBLE
97047: EQUAL
97048: IFTRUE 97082
97050: LD_INT 12
97052: DOUBLE
97053: EQUAL
97054: IFTRUE 97082
97056: LD_INT 15
97058: DOUBLE
97059: EQUAL
97060: IFTRUE 97082
97062: LD_INT 11
97064: DOUBLE
97065: EQUAL
97066: IFTRUE 97082
97068: LD_INT 14
97070: DOUBLE
97071: EQUAL
97072: IFTRUE 97082
97074: LD_INT 10
97076: DOUBLE
97077: EQUAL
97078: IFTRUE 97082
97080: GO 97138
97082: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97083: LD_ADDR_VAR 0 9
97087: PUSH
97088: LD_VAR 0 41
97092: PUSH
97093: LD_VAR 0 42
97097: PUSH
97098: LD_VAR 0 43
97102: PUSH
97103: LD_VAR 0 44
97107: PUSH
97108: LD_VAR 0 45
97112: PUSH
97113: LD_VAR 0 46
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: PUSH
97126: LD_VAR 0 4
97130: PUSH
97131: LD_INT 1
97133: PLUS
97134: ARRAY
97135: ST_TO_ADDR
97136: GO 97391
97138: LD_INT 36
97140: DOUBLE
97141: EQUAL
97142: IFTRUE 97146
97144: GO 97202
97146: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97147: LD_ADDR_VAR 0 9
97151: PUSH
97152: LD_VAR 0 47
97156: PUSH
97157: LD_VAR 0 48
97161: PUSH
97162: LD_VAR 0 49
97166: PUSH
97167: LD_VAR 0 50
97171: PUSH
97172: LD_VAR 0 51
97176: PUSH
97177: LD_VAR 0 52
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: PUSH
97190: LD_VAR 0 4
97194: PUSH
97195: LD_INT 1
97197: PLUS
97198: ARRAY
97199: ST_TO_ADDR
97200: GO 97391
97202: LD_INT 4
97204: DOUBLE
97205: EQUAL
97206: IFTRUE 97228
97208: LD_INT 5
97210: DOUBLE
97211: EQUAL
97212: IFTRUE 97228
97214: LD_INT 34
97216: DOUBLE
97217: EQUAL
97218: IFTRUE 97228
97220: LD_INT 37
97222: DOUBLE
97223: EQUAL
97224: IFTRUE 97228
97226: GO 97284
97228: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97229: LD_ADDR_VAR 0 9
97233: PUSH
97234: LD_VAR 0 53
97238: PUSH
97239: LD_VAR 0 54
97243: PUSH
97244: LD_VAR 0 55
97248: PUSH
97249: LD_VAR 0 56
97253: PUSH
97254: LD_VAR 0 57
97258: PUSH
97259: LD_VAR 0 58
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_VAR 0 4
97276: PUSH
97277: LD_INT 1
97279: PLUS
97280: ARRAY
97281: ST_TO_ADDR
97282: GO 97391
97284: LD_INT 31
97286: DOUBLE
97287: EQUAL
97288: IFTRUE 97334
97290: LD_INT 32
97292: DOUBLE
97293: EQUAL
97294: IFTRUE 97334
97296: LD_INT 33
97298: DOUBLE
97299: EQUAL
97300: IFTRUE 97334
97302: LD_INT 27
97304: DOUBLE
97305: EQUAL
97306: IFTRUE 97334
97308: LD_INT 26
97310: DOUBLE
97311: EQUAL
97312: IFTRUE 97334
97314: LD_INT 28
97316: DOUBLE
97317: EQUAL
97318: IFTRUE 97334
97320: LD_INT 29
97322: DOUBLE
97323: EQUAL
97324: IFTRUE 97334
97326: LD_INT 30
97328: DOUBLE
97329: EQUAL
97330: IFTRUE 97334
97332: GO 97390
97334: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
97335: LD_ADDR_VAR 0 9
97339: PUSH
97340: LD_VAR 0 59
97344: PUSH
97345: LD_VAR 0 60
97349: PUSH
97350: LD_VAR 0 61
97354: PUSH
97355: LD_VAR 0 62
97359: PUSH
97360: LD_VAR 0 63
97364: PUSH
97365: LD_VAR 0 64
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: PUSH
97378: LD_VAR 0 4
97382: PUSH
97383: LD_INT 1
97385: PLUS
97386: ARRAY
97387: ST_TO_ADDR
97388: GO 97391
97390: POP
// temp_list2 = [ ] ;
97391: LD_ADDR_VAR 0 10
97395: PUSH
97396: EMPTY
97397: ST_TO_ADDR
// for i in temp_list do
97398: LD_ADDR_VAR 0 8
97402: PUSH
97403: LD_VAR 0 9
97407: PUSH
97408: FOR_IN
97409: IFFALSE 97461
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97411: LD_ADDR_VAR 0 10
97415: PUSH
97416: LD_VAR 0 10
97420: PUSH
97421: LD_VAR 0 8
97425: PUSH
97426: LD_INT 1
97428: ARRAY
97429: PUSH
97430: LD_VAR 0 2
97434: PLUS
97435: PUSH
97436: LD_VAR 0 8
97440: PUSH
97441: LD_INT 2
97443: ARRAY
97444: PUSH
97445: LD_VAR 0 3
97449: PLUS
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PUSH
97455: EMPTY
97456: LIST
97457: ADD
97458: ST_TO_ADDR
97459: GO 97408
97461: POP
97462: POP
// result = temp_list2 ;
97463: LD_ADDR_VAR 0 7
97467: PUSH
97468: LD_VAR 0 10
97472: ST_TO_ADDR
// end ;
97473: LD_VAR 0 7
97477: RET
// export function EnemyInRange ( unit , dist ) ; begin
97478: LD_INT 0
97480: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97481: LD_ADDR_VAR 0 3
97485: PUSH
97486: LD_VAR 0 1
97490: PPUSH
97491: CALL_OW 255
97495: PPUSH
97496: LD_VAR 0 1
97500: PPUSH
97501: CALL_OW 250
97505: PPUSH
97506: LD_VAR 0 1
97510: PPUSH
97511: CALL_OW 251
97515: PPUSH
97516: LD_VAR 0 2
97520: PPUSH
97521: CALL 71249 0 4
97525: PUSH
97526: LD_INT 4
97528: ARRAY
97529: ST_TO_ADDR
// end ;
97530: LD_VAR 0 3
97534: RET
// export function PlayerSeeMe ( unit ) ; begin
97535: LD_INT 0
97537: PPUSH
// result := See ( your_side , unit ) ;
97538: LD_ADDR_VAR 0 2
97542: PUSH
97543: LD_OWVAR 2
97547: PPUSH
97548: LD_VAR 0 1
97552: PPUSH
97553: CALL_OW 292
97557: ST_TO_ADDR
// end ;
97558: LD_VAR 0 2
97562: RET
// export function ReverseDir ( unit ) ; begin
97563: LD_INT 0
97565: PPUSH
// if not unit then
97566: LD_VAR 0 1
97570: NOT
97571: IFFALSE 97575
// exit ;
97573: GO 97598
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
97575: LD_ADDR_VAR 0 2
97579: PUSH
97580: LD_VAR 0 1
97584: PPUSH
97585: CALL_OW 254
97589: PUSH
97590: LD_INT 3
97592: PLUS
97593: PUSH
97594: LD_INT 6
97596: MOD
97597: ST_TO_ADDR
// end ;
97598: LD_VAR 0 2
97602: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97603: LD_INT 0
97605: PPUSH
97606: PPUSH
97607: PPUSH
97608: PPUSH
97609: PPUSH
// if not hexes then
97610: LD_VAR 0 2
97614: NOT
97615: IFFALSE 97619
// exit ;
97617: GO 97767
// dist := 9999 ;
97619: LD_ADDR_VAR 0 5
97623: PUSH
97624: LD_INT 9999
97626: ST_TO_ADDR
// for i = 1 to hexes do
97627: LD_ADDR_VAR 0 4
97631: PUSH
97632: DOUBLE
97633: LD_INT 1
97635: DEC
97636: ST_TO_ADDR
97637: LD_VAR 0 2
97641: PUSH
97642: FOR_TO
97643: IFFALSE 97755
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97645: LD_VAR 0 1
97649: PPUSH
97650: LD_VAR 0 2
97654: PUSH
97655: LD_VAR 0 4
97659: ARRAY
97660: PUSH
97661: LD_INT 1
97663: ARRAY
97664: PPUSH
97665: LD_VAR 0 2
97669: PUSH
97670: LD_VAR 0 4
97674: ARRAY
97675: PUSH
97676: LD_INT 2
97678: ARRAY
97679: PPUSH
97680: CALL_OW 297
97684: PUSH
97685: LD_VAR 0 5
97689: LESS
97690: IFFALSE 97753
// begin hex := hexes [ i ] ;
97692: LD_ADDR_VAR 0 7
97696: PUSH
97697: LD_VAR 0 2
97701: PUSH
97702: LD_VAR 0 4
97706: ARRAY
97707: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97708: LD_ADDR_VAR 0 5
97712: PUSH
97713: LD_VAR 0 1
97717: PPUSH
97718: LD_VAR 0 2
97722: PUSH
97723: LD_VAR 0 4
97727: ARRAY
97728: PUSH
97729: LD_INT 1
97731: ARRAY
97732: PPUSH
97733: LD_VAR 0 2
97737: PUSH
97738: LD_VAR 0 4
97742: ARRAY
97743: PUSH
97744: LD_INT 2
97746: ARRAY
97747: PPUSH
97748: CALL_OW 297
97752: ST_TO_ADDR
// end ; end ;
97753: GO 97642
97755: POP
97756: POP
// result := hex ;
97757: LD_ADDR_VAR 0 3
97761: PUSH
97762: LD_VAR 0 7
97766: ST_TO_ADDR
// end ;
97767: LD_VAR 0 3
97771: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97772: LD_INT 0
97774: PPUSH
97775: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97776: LD_VAR 0 1
97780: NOT
97781: PUSH
97782: LD_VAR 0 1
97786: PUSH
97787: LD_INT 21
97789: PUSH
97790: LD_INT 2
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 23
97799: PUSH
97800: LD_INT 2
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PPUSH
97811: CALL_OW 69
97815: IN
97816: NOT
97817: OR
97818: IFFALSE 97822
// exit ;
97820: GO 97869
// for i = 1 to 3 do
97822: LD_ADDR_VAR 0 3
97826: PUSH
97827: DOUBLE
97828: LD_INT 1
97830: DEC
97831: ST_TO_ADDR
97832: LD_INT 3
97834: PUSH
97835: FOR_TO
97836: IFFALSE 97867
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97838: LD_VAR 0 1
97842: PPUSH
97843: CALL_OW 250
97847: PPUSH
97848: LD_VAR 0 1
97852: PPUSH
97853: CALL_OW 251
97857: PPUSH
97858: LD_INT 1
97860: PPUSH
97861: CALL_OW 453
97865: GO 97835
97867: POP
97868: POP
// end ;
97869: LD_VAR 0 2
97873: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97874: LD_INT 0
97876: PPUSH
97877: PPUSH
97878: PPUSH
97879: PPUSH
97880: PPUSH
97881: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97882: LD_VAR 0 1
97886: NOT
97887: PUSH
97888: LD_VAR 0 2
97892: NOT
97893: OR
97894: PUSH
97895: LD_VAR 0 1
97899: PPUSH
97900: CALL_OW 314
97904: OR
97905: IFFALSE 97909
// exit ;
97907: GO 98350
// x := GetX ( enemy_unit ) ;
97909: LD_ADDR_VAR 0 7
97913: PUSH
97914: LD_VAR 0 2
97918: PPUSH
97919: CALL_OW 250
97923: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97924: LD_ADDR_VAR 0 8
97928: PUSH
97929: LD_VAR 0 2
97933: PPUSH
97934: CALL_OW 251
97938: ST_TO_ADDR
// if not x or not y then
97939: LD_VAR 0 7
97943: NOT
97944: PUSH
97945: LD_VAR 0 8
97949: NOT
97950: OR
97951: IFFALSE 97955
// exit ;
97953: GO 98350
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97955: LD_ADDR_VAR 0 6
97959: PUSH
97960: LD_VAR 0 7
97964: PPUSH
97965: LD_INT 0
97967: PPUSH
97968: LD_INT 4
97970: PPUSH
97971: CALL_OW 272
97975: PUSH
97976: LD_VAR 0 8
97980: PPUSH
97981: LD_INT 0
97983: PPUSH
97984: LD_INT 4
97986: PPUSH
97987: CALL_OW 273
97991: PUSH
97992: EMPTY
97993: LIST
97994: LIST
97995: PUSH
97996: LD_VAR 0 7
98000: PPUSH
98001: LD_INT 1
98003: PPUSH
98004: LD_INT 4
98006: PPUSH
98007: CALL_OW 272
98011: PUSH
98012: LD_VAR 0 8
98016: PPUSH
98017: LD_INT 1
98019: PPUSH
98020: LD_INT 4
98022: PPUSH
98023: CALL_OW 273
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: PUSH
98032: LD_VAR 0 7
98036: PPUSH
98037: LD_INT 2
98039: PPUSH
98040: LD_INT 4
98042: PPUSH
98043: CALL_OW 272
98047: PUSH
98048: LD_VAR 0 8
98052: PPUSH
98053: LD_INT 2
98055: PPUSH
98056: LD_INT 4
98058: PPUSH
98059: CALL_OW 273
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: PUSH
98068: LD_VAR 0 7
98072: PPUSH
98073: LD_INT 3
98075: PPUSH
98076: LD_INT 4
98078: PPUSH
98079: CALL_OW 272
98083: PUSH
98084: LD_VAR 0 8
98088: PPUSH
98089: LD_INT 3
98091: PPUSH
98092: LD_INT 4
98094: PPUSH
98095: CALL_OW 273
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_VAR 0 7
98108: PPUSH
98109: LD_INT 4
98111: PPUSH
98112: LD_INT 4
98114: PPUSH
98115: CALL_OW 272
98119: PUSH
98120: LD_VAR 0 8
98124: PPUSH
98125: LD_INT 4
98127: PPUSH
98128: LD_INT 4
98130: PPUSH
98131: CALL_OW 273
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_VAR 0 7
98144: PPUSH
98145: LD_INT 5
98147: PPUSH
98148: LD_INT 4
98150: PPUSH
98151: CALL_OW 272
98155: PUSH
98156: LD_VAR 0 8
98160: PPUSH
98161: LD_INT 5
98163: PPUSH
98164: LD_INT 4
98166: PPUSH
98167: CALL_OW 273
98171: PUSH
98172: EMPTY
98173: LIST
98174: LIST
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: ST_TO_ADDR
// for i = tmp downto 1 do
98184: LD_ADDR_VAR 0 4
98188: PUSH
98189: DOUBLE
98190: LD_VAR 0 6
98194: INC
98195: ST_TO_ADDR
98196: LD_INT 1
98198: PUSH
98199: FOR_DOWNTO
98200: IFFALSE 98301
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98202: LD_VAR 0 6
98206: PUSH
98207: LD_VAR 0 4
98211: ARRAY
98212: PUSH
98213: LD_INT 1
98215: ARRAY
98216: PPUSH
98217: LD_VAR 0 6
98221: PUSH
98222: LD_VAR 0 4
98226: ARRAY
98227: PUSH
98228: LD_INT 2
98230: ARRAY
98231: PPUSH
98232: CALL_OW 488
98236: NOT
98237: PUSH
98238: LD_VAR 0 6
98242: PUSH
98243: LD_VAR 0 4
98247: ARRAY
98248: PUSH
98249: LD_INT 1
98251: ARRAY
98252: PPUSH
98253: LD_VAR 0 6
98257: PUSH
98258: LD_VAR 0 4
98262: ARRAY
98263: PUSH
98264: LD_INT 2
98266: ARRAY
98267: PPUSH
98268: CALL_OW 428
98272: PUSH
98273: LD_INT 0
98275: NONEQUAL
98276: OR
98277: IFFALSE 98299
// tmp := Delete ( tmp , i ) ;
98279: LD_ADDR_VAR 0 6
98283: PUSH
98284: LD_VAR 0 6
98288: PPUSH
98289: LD_VAR 0 4
98293: PPUSH
98294: CALL_OW 3
98298: ST_TO_ADDR
98299: GO 98199
98301: POP
98302: POP
// j := GetClosestHex ( unit , tmp ) ;
98303: LD_ADDR_VAR 0 5
98307: PUSH
98308: LD_VAR 0 1
98312: PPUSH
98313: LD_VAR 0 6
98317: PPUSH
98318: CALL 97603 0 2
98322: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98323: LD_VAR 0 1
98327: PPUSH
98328: LD_VAR 0 5
98332: PUSH
98333: LD_INT 1
98335: ARRAY
98336: PPUSH
98337: LD_VAR 0 5
98341: PUSH
98342: LD_INT 2
98344: ARRAY
98345: PPUSH
98346: CALL_OW 111
// end ;
98350: LD_VAR 0 3
98354: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98355: LD_INT 0
98357: PPUSH
98358: PPUSH
98359: PPUSH
// uc_side = 0 ;
98360: LD_ADDR_OWVAR 20
98364: PUSH
98365: LD_INT 0
98367: ST_TO_ADDR
// uc_nation = 0 ;
98368: LD_ADDR_OWVAR 21
98372: PUSH
98373: LD_INT 0
98375: ST_TO_ADDR
// InitHc_All ( ) ;
98376: CALL_OW 584
// InitVc ;
98380: CALL_OW 20
// if mastodonts then
98384: LD_VAR 0 6
98388: IFFALSE 98455
// for i = 1 to mastodonts do
98390: LD_ADDR_VAR 0 11
98394: PUSH
98395: DOUBLE
98396: LD_INT 1
98398: DEC
98399: ST_TO_ADDR
98400: LD_VAR 0 6
98404: PUSH
98405: FOR_TO
98406: IFFALSE 98453
// begin vc_chassis := 31 ;
98408: LD_ADDR_OWVAR 37
98412: PUSH
98413: LD_INT 31
98415: ST_TO_ADDR
// vc_control := control_rider ;
98416: LD_ADDR_OWVAR 38
98420: PUSH
98421: LD_INT 4
98423: ST_TO_ADDR
// animal := CreateVehicle ;
98424: LD_ADDR_VAR 0 12
98428: PUSH
98429: CALL_OW 45
98433: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98434: LD_VAR 0 12
98438: PPUSH
98439: LD_VAR 0 8
98443: PPUSH
98444: LD_INT 0
98446: PPUSH
98447: CALL 100643 0 3
// end ;
98451: GO 98405
98453: POP
98454: POP
// if horses then
98455: LD_VAR 0 5
98459: IFFALSE 98526
// for i = 1 to horses do
98461: LD_ADDR_VAR 0 11
98465: PUSH
98466: DOUBLE
98467: LD_INT 1
98469: DEC
98470: ST_TO_ADDR
98471: LD_VAR 0 5
98475: PUSH
98476: FOR_TO
98477: IFFALSE 98524
// begin hc_class := 21 ;
98479: LD_ADDR_OWVAR 28
98483: PUSH
98484: LD_INT 21
98486: ST_TO_ADDR
// hc_gallery :=  ;
98487: LD_ADDR_OWVAR 33
98491: PUSH
98492: LD_STRING 
98494: ST_TO_ADDR
// animal := CreateHuman ;
98495: LD_ADDR_VAR 0 12
98499: PUSH
98500: CALL_OW 44
98504: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98505: LD_VAR 0 12
98509: PPUSH
98510: LD_VAR 0 8
98514: PPUSH
98515: LD_INT 0
98517: PPUSH
98518: CALL 100643 0 3
// end ;
98522: GO 98476
98524: POP
98525: POP
// if birds then
98526: LD_VAR 0 1
98530: IFFALSE 98597
// for i = 1 to birds do
98532: LD_ADDR_VAR 0 11
98536: PUSH
98537: DOUBLE
98538: LD_INT 1
98540: DEC
98541: ST_TO_ADDR
98542: LD_VAR 0 1
98546: PUSH
98547: FOR_TO
98548: IFFALSE 98595
// begin hc_class = 18 ;
98550: LD_ADDR_OWVAR 28
98554: PUSH
98555: LD_INT 18
98557: ST_TO_ADDR
// hc_gallery =  ;
98558: LD_ADDR_OWVAR 33
98562: PUSH
98563: LD_STRING 
98565: ST_TO_ADDR
// animal := CreateHuman ;
98566: LD_ADDR_VAR 0 12
98570: PUSH
98571: CALL_OW 44
98575: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98576: LD_VAR 0 12
98580: PPUSH
98581: LD_VAR 0 8
98585: PPUSH
98586: LD_INT 0
98588: PPUSH
98589: CALL 100643 0 3
// end ;
98593: GO 98547
98595: POP
98596: POP
// if tigers then
98597: LD_VAR 0 2
98601: IFFALSE 98685
// for i = 1 to tigers do
98603: LD_ADDR_VAR 0 11
98607: PUSH
98608: DOUBLE
98609: LD_INT 1
98611: DEC
98612: ST_TO_ADDR
98613: LD_VAR 0 2
98617: PUSH
98618: FOR_TO
98619: IFFALSE 98683
// begin hc_class = class_tiger ;
98621: LD_ADDR_OWVAR 28
98625: PUSH
98626: LD_INT 14
98628: ST_TO_ADDR
// hc_gallery =  ;
98629: LD_ADDR_OWVAR 33
98633: PUSH
98634: LD_STRING 
98636: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98637: LD_ADDR_OWVAR 35
98641: PUSH
98642: LD_INT 7
98644: NEG
98645: PPUSH
98646: LD_INT 7
98648: PPUSH
98649: CALL_OW 12
98653: ST_TO_ADDR
// animal := CreateHuman ;
98654: LD_ADDR_VAR 0 12
98658: PUSH
98659: CALL_OW 44
98663: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98664: LD_VAR 0 12
98668: PPUSH
98669: LD_VAR 0 8
98673: PPUSH
98674: LD_INT 0
98676: PPUSH
98677: CALL 100643 0 3
// end ;
98681: GO 98618
98683: POP
98684: POP
// if apemans then
98685: LD_VAR 0 3
98689: IFFALSE 98812
// for i = 1 to apemans do
98691: LD_ADDR_VAR 0 11
98695: PUSH
98696: DOUBLE
98697: LD_INT 1
98699: DEC
98700: ST_TO_ADDR
98701: LD_VAR 0 3
98705: PUSH
98706: FOR_TO
98707: IFFALSE 98810
// begin hc_class = class_apeman ;
98709: LD_ADDR_OWVAR 28
98713: PUSH
98714: LD_INT 12
98716: ST_TO_ADDR
// hc_gallery =  ;
98717: LD_ADDR_OWVAR 33
98721: PUSH
98722: LD_STRING 
98724: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98725: LD_ADDR_OWVAR 35
98729: PUSH
98730: LD_INT 5
98732: NEG
98733: PPUSH
98734: LD_INT 5
98736: PPUSH
98737: CALL_OW 12
98741: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98742: LD_ADDR_OWVAR 31
98746: PUSH
98747: LD_INT 1
98749: PPUSH
98750: LD_INT 3
98752: PPUSH
98753: CALL_OW 12
98757: PUSH
98758: LD_INT 1
98760: PPUSH
98761: LD_INT 3
98763: PPUSH
98764: CALL_OW 12
98768: PUSH
98769: LD_INT 0
98771: PUSH
98772: LD_INT 0
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: ST_TO_ADDR
// animal := CreateHuman ;
98781: LD_ADDR_VAR 0 12
98785: PUSH
98786: CALL_OW 44
98790: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98791: LD_VAR 0 12
98795: PPUSH
98796: LD_VAR 0 8
98800: PPUSH
98801: LD_INT 0
98803: PPUSH
98804: CALL 100643 0 3
// end ;
98808: GO 98706
98810: POP
98811: POP
// if enchidnas then
98812: LD_VAR 0 4
98816: IFFALSE 98883
// for i = 1 to enchidnas do
98818: LD_ADDR_VAR 0 11
98822: PUSH
98823: DOUBLE
98824: LD_INT 1
98826: DEC
98827: ST_TO_ADDR
98828: LD_VAR 0 4
98832: PUSH
98833: FOR_TO
98834: IFFALSE 98881
// begin hc_class = 13 ;
98836: LD_ADDR_OWVAR 28
98840: PUSH
98841: LD_INT 13
98843: ST_TO_ADDR
// hc_gallery =  ;
98844: LD_ADDR_OWVAR 33
98848: PUSH
98849: LD_STRING 
98851: ST_TO_ADDR
// animal := CreateHuman ;
98852: LD_ADDR_VAR 0 12
98856: PUSH
98857: CALL_OW 44
98861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98862: LD_VAR 0 12
98866: PPUSH
98867: LD_VAR 0 8
98871: PPUSH
98872: LD_INT 0
98874: PPUSH
98875: CALL 100643 0 3
// end ;
98879: GO 98833
98881: POP
98882: POP
// if fishes then
98883: LD_VAR 0 7
98887: IFFALSE 98954
// for i = 1 to fishes do
98889: LD_ADDR_VAR 0 11
98893: PUSH
98894: DOUBLE
98895: LD_INT 1
98897: DEC
98898: ST_TO_ADDR
98899: LD_VAR 0 7
98903: PUSH
98904: FOR_TO
98905: IFFALSE 98952
// begin hc_class = 20 ;
98907: LD_ADDR_OWVAR 28
98911: PUSH
98912: LD_INT 20
98914: ST_TO_ADDR
// hc_gallery =  ;
98915: LD_ADDR_OWVAR 33
98919: PUSH
98920: LD_STRING 
98922: ST_TO_ADDR
// animal := CreateHuman ;
98923: LD_ADDR_VAR 0 12
98927: PUSH
98928: CALL_OW 44
98932: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98933: LD_VAR 0 12
98937: PPUSH
98938: LD_VAR 0 9
98942: PPUSH
98943: LD_INT 0
98945: PPUSH
98946: CALL 100643 0 3
// end ;
98950: GO 98904
98952: POP
98953: POP
// end ;
98954: LD_VAR 0 10
98958: RET
// export function WantHeal ( sci , unit ) ; begin
98959: LD_INT 0
98961: PPUSH
// if GetTaskList ( sci ) > 0 then
98962: LD_VAR 0 1
98966: PPUSH
98967: CALL_OW 437
98971: PUSH
98972: LD_INT 0
98974: GREATER
98975: IFFALSE 99045
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98977: LD_VAR 0 1
98981: PPUSH
98982: CALL_OW 437
98986: PUSH
98987: LD_INT 1
98989: ARRAY
98990: PUSH
98991: LD_INT 1
98993: ARRAY
98994: PUSH
98995: LD_STRING l
98997: EQUAL
98998: PUSH
98999: LD_VAR 0 1
99003: PPUSH
99004: CALL_OW 437
99008: PUSH
99009: LD_INT 1
99011: ARRAY
99012: PUSH
99013: LD_INT 4
99015: ARRAY
99016: PUSH
99017: LD_VAR 0 2
99021: EQUAL
99022: AND
99023: IFFALSE 99035
// result := true else
99025: LD_ADDR_VAR 0 3
99029: PUSH
99030: LD_INT 1
99032: ST_TO_ADDR
99033: GO 99043
// result := false ;
99035: LD_ADDR_VAR 0 3
99039: PUSH
99040: LD_INT 0
99042: ST_TO_ADDR
// end else
99043: GO 99053
// result := false ;
99045: LD_ADDR_VAR 0 3
99049: PUSH
99050: LD_INT 0
99052: ST_TO_ADDR
// end ;
99053: LD_VAR 0 3
99057: RET
// export function HealTarget ( sci ) ; begin
99058: LD_INT 0
99060: PPUSH
// if not sci then
99061: LD_VAR 0 1
99065: NOT
99066: IFFALSE 99070
// exit ;
99068: GO 99135
// result := 0 ;
99070: LD_ADDR_VAR 0 2
99074: PUSH
99075: LD_INT 0
99077: ST_TO_ADDR
// if GetTaskList ( sci ) then
99078: LD_VAR 0 1
99082: PPUSH
99083: CALL_OW 437
99087: IFFALSE 99135
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99089: LD_VAR 0 1
99093: PPUSH
99094: CALL_OW 437
99098: PUSH
99099: LD_INT 1
99101: ARRAY
99102: PUSH
99103: LD_INT 1
99105: ARRAY
99106: PUSH
99107: LD_STRING l
99109: EQUAL
99110: IFFALSE 99135
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99112: LD_ADDR_VAR 0 2
99116: PUSH
99117: LD_VAR 0 1
99121: PPUSH
99122: CALL_OW 437
99126: PUSH
99127: LD_INT 1
99129: ARRAY
99130: PUSH
99131: LD_INT 4
99133: ARRAY
99134: ST_TO_ADDR
// end ;
99135: LD_VAR 0 2
99139: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99140: LD_INT 0
99142: PPUSH
99143: PPUSH
99144: PPUSH
99145: PPUSH
// if not base_units then
99146: LD_VAR 0 1
99150: NOT
99151: IFFALSE 99155
// exit ;
99153: GO 99242
// result := false ;
99155: LD_ADDR_VAR 0 2
99159: PUSH
99160: LD_INT 0
99162: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99163: LD_ADDR_VAR 0 5
99167: PUSH
99168: LD_VAR 0 1
99172: PPUSH
99173: LD_INT 21
99175: PUSH
99176: LD_INT 3
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PPUSH
99183: CALL_OW 72
99187: ST_TO_ADDR
// if not tmp then
99188: LD_VAR 0 5
99192: NOT
99193: IFFALSE 99197
// exit ;
99195: GO 99242
// for i in tmp do
99197: LD_ADDR_VAR 0 3
99201: PUSH
99202: LD_VAR 0 5
99206: PUSH
99207: FOR_IN
99208: IFFALSE 99240
// begin result := EnemyInRange ( i , 22 ) ;
99210: LD_ADDR_VAR 0 2
99214: PUSH
99215: LD_VAR 0 3
99219: PPUSH
99220: LD_INT 22
99222: PPUSH
99223: CALL 97478 0 2
99227: ST_TO_ADDR
// if result then
99228: LD_VAR 0 2
99232: IFFALSE 99238
// exit ;
99234: POP
99235: POP
99236: GO 99242
// end ;
99238: GO 99207
99240: POP
99241: POP
// end ;
99242: LD_VAR 0 2
99246: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99247: LD_INT 0
99249: PPUSH
99250: PPUSH
// if not units then
99251: LD_VAR 0 1
99255: NOT
99256: IFFALSE 99260
// exit ;
99258: GO 99330
// result := [ ] ;
99260: LD_ADDR_VAR 0 3
99264: PUSH
99265: EMPTY
99266: ST_TO_ADDR
// for i in units do
99267: LD_ADDR_VAR 0 4
99271: PUSH
99272: LD_VAR 0 1
99276: PUSH
99277: FOR_IN
99278: IFFALSE 99328
// if GetTag ( i ) = tag then
99280: LD_VAR 0 4
99284: PPUSH
99285: CALL_OW 110
99289: PUSH
99290: LD_VAR 0 2
99294: EQUAL
99295: IFFALSE 99326
// result := Insert ( result , result + 1 , i ) ;
99297: LD_ADDR_VAR 0 3
99301: PUSH
99302: LD_VAR 0 3
99306: PPUSH
99307: LD_VAR 0 3
99311: PUSH
99312: LD_INT 1
99314: PLUS
99315: PPUSH
99316: LD_VAR 0 4
99320: PPUSH
99321: CALL_OW 2
99325: ST_TO_ADDR
99326: GO 99277
99328: POP
99329: POP
// end ;
99330: LD_VAR 0 3
99334: RET
// export function IsDriver ( un ) ; begin
99335: LD_INT 0
99337: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99338: LD_ADDR_VAR 0 2
99342: PUSH
99343: LD_VAR 0 1
99347: PUSH
99348: LD_INT 55
99350: PUSH
99351: EMPTY
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: IN
99359: ST_TO_ADDR
// end ;
99360: LD_VAR 0 2
99364: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99365: LD_INT 0
99367: PPUSH
99368: PPUSH
// list := [ ] ;
99369: LD_ADDR_VAR 0 5
99373: PUSH
99374: EMPTY
99375: ST_TO_ADDR
// case d of 0 :
99376: LD_VAR 0 3
99380: PUSH
99381: LD_INT 0
99383: DOUBLE
99384: EQUAL
99385: IFTRUE 99389
99387: GO 99522
99389: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99390: LD_ADDR_VAR 0 5
99394: PUSH
99395: LD_VAR 0 1
99399: PUSH
99400: LD_INT 4
99402: MINUS
99403: PUSH
99404: LD_VAR 0 2
99408: PUSH
99409: LD_INT 4
99411: MINUS
99412: PUSH
99413: LD_INT 2
99415: PUSH
99416: EMPTY
99417: LIST
99418: LIST
99419: LIST
99420: PUSH
99421: LD_VAR 0 1
99425: PUSH
99426: LD_INT 3
99428: MINUS
99429: PUSH
99430: LD_VAR 0 2
99434: PUSH
99435: LD_INT 1
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: LIST
99442: PUSH
99443: LD_VAR 0 1
99447: PUSH
99448: LD_INT 4
99450: PLUS
99451: PUSH
99452: LD_VAR 0 2
99456: PUSH
99457: LD_INT 4
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: LIST
99464: PUSH
99465: LD_VAR 0 1
99469: PUSH
99470: LD_INT 3
99472: PLUS
99473: PUSH
99474: LD_VAR 0 2
99478: PUSH
99479: LD_INT 3
99481: PLUS
99482: PUSH
99483: LD_INT 5
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: LIST
99490: PUSH
99491: LD_VAR 0 1
99495: PUSH
99496: LD_VAR 0 2
99500: PUSH
99501: LD_INT 4
99503: PLUS
99504: PUSH
99505: LD_INT 0
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: LIST
99512: PUSH
99513: EMPTY
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: ST_TO_ADDR
// end ; 1 :
99520: GO 100220
99522: LD_INT 1
99524: DOUBLE
99525: EQUAL
99526: IFTRUE 99530
99528: GO 99663
99530: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
99531: LD_ADDR_VAR 0 5
99535: PUSH
99536: LD_VAR 0 1
99540: PUSH
99541: LD_VAR 0 2
99545: PUSH
99546: LD_INT 4
99548: MINUS
99549: PUSH
99550: LD_INT 3
99552: PUSH
99553: EMPTY
99554: LIST
99555: LIST
99556: LIST
99557: PUSH
99558: LD_VAR 0 1
99562: PUSH
99563: LD_INT 3
99565: MINUS
99566: PUSH
99567: LD_VAR 0 2
99571: PUSH
99572: LD_INT 3
99574: MINUS
99575: PUSH
99576: LD_INT 2
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: LIST
99583: PUSH
99584: LD_VAR 0 1
99588: PUSH
99589: LD_INT 4
99591: MINUS
99592: PUSH
99593: LD_VAR 0 2
99597: PUSH
99598: LD_INT 1
99600: PUSH
99601: EMPTY
99602: LIST
99603: LIST
99604: LIST
99605: PUSH
99606: LD_VAR 0 1
99610: PUSH
99611: LD_VAR 0 2
99615: PUSH
99616: LD_INT 3
99618: PLUS
99619: PUSH
99620: LD_INT 0
99622: PUSH
99623: EMPTY
99624: LIST
99625: LIST
99626: LIST
99627: PUSH
99628: LD_VAR 0 1
99632: PUSH
99633: LD_INT 4
99635: PLUS
99636: PUSH
99637: LD_VAR 0 2
99641: PUSH
99642: LD_INT 4
99644: PLUS
99645: PUSH
99646: LD_INT 5
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: LIST
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: ST_TO_ADDR
// end ; 2 :
99661: GO 100220
99663: LD_INT 2
99665: DOUBLE
99666: EQUAL
99667: IFTRUE 99671
99669: GO 99800
99671: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99672: LD_ADDR_VAR 0 5
99676: PUSH
99677: LD_VAR 0 1
99681: PUSH
99682: LD_VAR 0 2
99686: PUSH
99687: LD_INT 3
99689: MINUS
99690: PUSH
99691: LD_INT 3
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: LIST
99698: PUSH
99699: LD_VAR 0 1
99703: PUSH
99704: LD_INT 4
99706: PLUS
99707: PUSH
99708: LD_VAR 0 2
99712: PUSH
99713: LD_INT 4
99715: PUSH
99716: EMPTY
99717: LIST
99718: LIST
99719: LIST
99720: PUSH
99721: LD_VAR 0 1
99725: PUSH
99726: LD_VAR 0 2
99730: PUSH
99731: LD_INT 4
99733: PLUS
99734: PUSH
99735: LD_INT 0
99737: PUSH
99738: EMPTY
99739: LIST
99740: LIST
99741: LIST
99742: PUSH
99743: LD_VAR 0 1
99747: PUSH
99748: LD_INT 3
99750: MINUS
99751: PUSH
99752: LD_VAR 0 2
99756: PUSH
99757: LD_INT 1
99759: PUSH
99760: EMPTY
99761: LIST
99762: LIST
99763: LIST
99764: PUSH
99765: LD_VAR 0 1
99769: PUSH
99770: LD_INT 4
99772: MINUS
99773: PUSH
99774: LD_VAR 0 2
99778: PUSH
99779: LD_INT 4
99781: MINUS
99782: PUSH
99783: LD_INT 2
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: LIST
99790: PUSH
99791: EMPTY
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: ST_TO_ADDR
// end ; 3 :
99798: GO 100220
99800: LD_INT 3
99802: DOUBLE
99803: EQUAL
99804: IFTRUE 99808
99806: GO 99941
99808: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99809: LD_ADDR_VAR 0 5
99813: PUSH
99814: LD_VAR 0 1
99818: PUSH
99819: LD_INT 3
99821: PLUS
99822: PUSH
99823: LD_VAR 0 2
99827: PUSH
99828: LD_INT 4
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: LIST
99835: PUSH
99836: LD_VAR 0 1
99840: PUSH
99841: LD_INT 4
99843: PLUS
99844: PUSH
99845: LD_VAR 0 2
99849: PUSH
99850: LD_INT 4
99852: PLUS
99853: PUSH
99854: LD_INT 5
99856: PUSH
99857: EMPTY
99858: LIST
99859: LIST
99860: LIST
99861: PUSH
99862: LD_VAR 0 1
99866: PUSH
99867: LD_INT 4
99869: MINUS
99870: PUSH
99871: LD_VAR 0 2
99875: PUSH
99876: LD_INT 1
99878: PUSH
99879: EMPTY
99880: LIST
99881: LIST
99882: LIST
99883: PUSH
99884: LD_VAR 0 1
99888: PUSH
99889: LD_VAR 0 2
99893: PUSH
99894: LD_INT 4
99896: MINUS
99897: PUSH
99898: LD_INT 3
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: LIST
99905: PUSH
99906: LD_VAR 0 1
99910: PUSH
99911: LD_INT 3
99913: MINUS
99914: PUSH
99915: LD_VAR 0 2
99919: PUSH
99920: LD_INT 3
99922: MINUS
99923: PUSH
99924: LD_INT 2
99926: PUSH
99927: EMPTY
99928: LIST
99929: LIST
99930: LIST
99931: PUSH
99932: EMPTY
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: ST_TO_ADDR
// end ; 4 :
99939: GO 100220
99941: LD_INT 4
99943: DOUBLE
99944: EQUAL
99945: IFTRUE 99949
99947: GO 100082
99949: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99950: LD_ADDR_VAR 0 5
99954: PUSH
99955: LD_VAR 0 1
99959: PUSH
99960: LD_VAR 0 2
99964: PUSH
99965: LD_INT 4
99967: PLUS
99968: PUSH
99969: LD_INT 0
99971: PUSH
99972: EMPTY
99973: LIST
99974: LIST
99975: LIST
99976: PUSH
99977: LD_VAR 0 1
99981: PUSH
99982: LD_INT 3
99984: PLUS
99985: PUSH
99986: LD_VAR 0 2
99990: PUSH
99991: LD_INT 3
99993: PLUS
99994: PUSH
99995: LD_INT 5
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: LIST
100002: PUSH
100003: LD_VAR 0 1
100007: PUSH
100008: LD_INT 4
100010: PLUS
100011: PUSH
100012: LD_VAR 0 2
100016: PUSH
100017: LD_INT 4
100019: PUSH
100020: EMPTY
100021: LIST
100022: LIST
100023: LIST
100024: PUSH
100025: LD_VAR 0 1
100029: PUSH
100030: LD_VAR 0 2
100034: PUSH
100035: LD_INT 3
100037: MINUS
100038: PUSH
100039: LD_INT 3
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: LIST
100046: PUSH
100047: LD_VAR 0 1
100051: PUSH
100052: LD_INT 4
100054: MINUS
100055: PUSH
100056: LD_VAR 0 2
100060: PUSH
100061: LD_INT 4
100063: MINUS
100064: PUSH
100065: LD_INT 2
100067: PUSH
100068: EMPTY
100069: LIST
100070: LIST
100071: LIST
100072: PUSH
100073: EMPTY
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: ST_TO_ADDR
// end ; 5 :
100080: GO 100220
100082: LD_INT 5
100084: DOUBLE
100085: EQUAL
100086: IFTRUE 100090
100088: GO 100219
100090: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100091: LD_ADDR_VAR 0 5
100095: PUSH
100096: LD_VAR 0 1
100100: PUSH
100101: LD_INT 4
100103: MINUS
100104: PUSH
100105: LD_VAR 0 2
100109: PUSH
100110: LD_INT 1
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: LIST
100117: PUSH
100118: LD_VAR 0 1
100122: PUSH
100123: LD_VAR 0 2
100127: PUSH
100128: LD_INT 4
100130: MINUS
100131: PUSH
100132: LD_INT 3
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: LIST
100139: PUSH
100140: LD_VAR 0 1
100144: PUSH
100145: LD_INT 4
100147: PLUS
100148: PUSH
100149: LD_VAR 0 2
100153: PUSH
100154: LD_INT 4
100156: PLUS
100157: PUSH
100158: LD_INT 5
100160: PUSH
100161: EMPTY
100162: LIST
100163: LIST
100164: LIST
100165: PUSH
100166: LD_VAR 0 1
100170: PUSH
100171: LD_INT 3
100173: PLUS
100174: PUSH
100175: LD_VAR 0 2
100179: PUSH
100180: LD_INT 4
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: LIST
100187: PUSH
100188: LD_VAR 0 1
100192: PUSH
100193: LD_VAR 0 2
100197: PUSH
100198: LD_INT 3
100200: PLUS
100201: PUSH
100202: LD_INT 0
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: LIST
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: LIST
100216: ST_TO_ADDR
// end ; end ;
100217: GO 100220
100219: POP
// result := list ;
100220: LD_ADDR_VAR 0 4
100224: PUSH
100225: LD_VAR 0 5
100229: ST_TO_ADDR
// end ;
100230: LD_VAR 0 4
100234: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100235: LD_INT 0
100237: PPUSH
100238: PPUSH
100239: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100240: LD_VAR 0 1
100244: NOT
100245: PUSH
100246: LD_VAR 0 2
100250: PUSH
100251: LD_INT 1
100253: PUSH
100254: LD_INT 2
100256: PUSH
100257: LD_INT 3
100259: PUSH
100260: LD_INT 4
100262: PUSH
100263: EMPTY
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: IN
100269: NOT
100270: OR
100271: IFFALSE 100275
// exit ;
100273: GO 100367
// tmp := [ ] ;
100275: LD_ADDR_VAR 0 5
100279: PUSH
100280: EMPTY
100281: ST_TO_ADDR
// for i in units do
100282: LD_ADDR_VAR 0 4
100286: PUSH
100287: LD_VAR 0 1
100291: PUSH
100292: FOR_IN
100293: IFFALSE 100336
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
100295: LD_ADDR_VAR 0 5
100299: PUSH
100300: LD_VAR 0 5
100304: PPUSH
100305: LD_VAR 0 5
100309: PUSH
100310: LD_INT 1
100312: PLUS
100313: PPUSH
100314: LD_VAR 0 4
100318: PPUSH
100319: LD_VAR 0 2
100323: PPUSH
100324: CALL_OW 259
100328: PPUSH
100329: CALL_OW 2
100333: ST_TO_ADDR
100334: GO 100292
100336: POP
100337: POP
// if not tmp then
100338: LD_VAR 0 5
100342: NOT
100343: IFFALSE 100347
// exit ;
100345: GO 100367
// result := SortListByListDesc ( units , tmp ) ;
100347: LD_ADDR_VAR 0 3
100351: PUSH
100352: LD_VAR 0 1
100356: PPUSH
100357: LD_VAR 0 5
100361: PPUSH
100362: CALL_OW 77
100366: ST_TO_ADDR
// end ;
100367: LD_VAR 0 3
100371: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100372: LD_INT 0
100374: PPUSH
100375: PPUSH
100376: PPUSH
// result := false ;
100377: LD_ADDR_VAR 0 3
100381: PUSH
100382: LD_INT 0
100384: ST_TO_ADDR
// x := GetX ( building ) ;
100385: LD_ADDR_VAR 0 4
100389: PUSH
100390: LD_VAR 0 2
100394: PPUSH
100395: CALL_OW 250
100399: ST_TO_ADDR
// y := GetY ( building ) ;
100400: LD_ADDR_VAR 0 5
100404: PUSH
100405: LD_VAR 0 2
100409: PPUSH
100410: CALL_OW 251
100414: ST_TO_ADDR
// if not building or not x or not y then
100415: LD_VAR 0 2
100419: NOT
100420: PUSH
100421: LD_VAR 0 4
100425: NOT
100426: OR
100427: PUSH
100428: LD_VAR 0 5
100432: NOT
100433: OR
100434: IFFALSE 100438
// exit ;
100436: GO 100530
// if GetTaskList ( unit ) then
100438: LD_VAR 0 1
100442: PPUSH
100443: CALL_OW 437
100447: IFFALSE 100530
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100449: LD_STRING e
100451: PUSH
100452: LD_VAR 0 1
100456: PPUSH
100457: CALL_OW 437
100461: PUSH
100462: LD_INT 1
100464: ARRAY
100465: PUSH
100466: LD_INT 1
100468: ARRAY
100469: EQUAL
100470: PUSH
100471: LD_VAR 0 4
100475: PUSH
100476: LD_VAR 0 1
100480: PPUSH
100481: CALL_OW 437
100485: PUSH
100486: LD_INT 1
100488: ARRAY
100489: PUSH
100490: LD_INT 2
100492: ARRAY
100493: EQUAL
100494: AND
100495: PUSH
100496: LD_VAR 0 5
100500: PUSH
100501: LD_VAR 0 1
100505: PPUSH
100506: CALL_OW 437
100510: PUSH
100511: LD_INT 1
100513: ARRAY
100514: PUSH
100515: LD_INT 3
100517: ARRAY
100518: EQUAL
100519: AND
100520: IFFALSE 100530
// result := true end ;
100522: LD_ADDR_VAR 0 3
100526: PUSH
100527: LD_INT 1
100529: ST_TO_ADDR
// end ;
100530: LD_VAR 0 3
100534: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
100535: LD_INT 0
100537: PPUSH
// result := false ;
100538: LD_ADDR_VAR 0 4
100542: PUSH
100543: LD_INT 0
100545: ST_TO_ADDR
// if GetTaskList ( unit ) then
100546: LD_VAR 0 1
100550: PPUSH
100551: CALL_OW 437
100555: IFFALSE 100638
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100557: LD_STRING M
100559: PUSH
100560: LD_VAR 0 1
100564: PPUSH
100565: CALL_OW 437
100569: PUSH
100570: LD_INT 1
100572: ARRAY
100573: PUSH
100574: LD_INT 1
100576: ARRAY
100577: EQUAL
100578: PUSH
100579: LD_VAR 0 2
100583: PUSH
100584: LD_VAR 0 1
100588: PPUSH
100589: CALL_OW 437
100593: PUSH
100594: LD_INT 1
100596: ARRAY
100597: PUSH
100598: LD_INT 2
100600: ARRAY
100601: EQUAL
100602: AND
100603: PUSH
100604: LD_VAR 0 3
100608: PUSH
100609: LD_VAR 0 1
100613: PPUSH
100614: CALL_OW 437
100618: PUSH
100619: LD_INT 1
100621: ARRAY
100622: PUSH
100623: LD_INT 3
100625: ARRAY
100626: EQUAL
100627: AND
100628: IFFALSE 100638
// result := true ;
100630: LD_ADDR_VAR 0 4
100634: PUSH
100635: LD_INT 1
100637: ST_TO_ADDR
// end ; end ;
100638: LD_VAR 0 4
100642: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100643: LD_INT 0
100645: PPUSH
100646: PPUSH
100647: PPUSH
100648: PPUSH
// if not unit or not area then
100649: LD_VAR 0 1
100653: NOT
100654: PUSH
100655: LD_VAR 0 2
100659: NOT
100660: OR
100661: IFFALSE 100665
// exit ;
100663: GO 100829
// tmp := AreaToList ( area , i ) ;
100665: LD_ADDR_VAR 0 6
100669: PUSH
100670: LD_VAR 0 2
100674: PPUSH
100675: LD_VAR 0 5
100679: PPUSH
100680: CALL_OW 517
100684: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100685: LD_ADDR_VAR 0 5
100689: PUSH
100690: DOUBLE
100691: LD_INT 1
100693: DEC
100694: ST_TO_ADDR
100695: LD_VAR 0 6
100699: PUSH
100700: LD_INT 1
100702: ARRAY
100703: PUSH
100704: FOR_TO
100705: IFFALSE 100827
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100707: LD_ADDR_VAR 0 7
100711: PUSH
100712: LD_VAR 0 6
100716: PUSH
100717: LD_INT 1
100719: ARRAY
100720: PUSH
100721: LD_VAR 0 5
100725: ARRAY
100726: PUSH
100727: LD_VAR 0 6
100731: PUSH
100732: LD_INT 2
100734: ARRAY
100735: PUSH
100736: LD_VAR 0 5
100740: ARRAY
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100746: LD_VAR 0 7
100750: PUSH
100751: LD_INT 1
100753: ARRAY
100754: PPUSH
100755: LD_VAR 0 7
100759: PUSH
100760: LD_INT 2
100762: ARRAY
100763: PPUSH
100764: CALL_OW 428
100768: PUSH
100769: LD_INT 0
100771: EQUAL
100772: IFFALSE 100825
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100774: LD_VAR 0 1
100778: PPUSH
100779: LD_VAR 0 7
100783: PUSH
100784: LD_INT 1
100786: ARRAY
100787: PPUSH
100788: LD_VAR 0 7
100792: PUSH
100793: LD_INT 2
100795: ARRAY
100796: PPUSH
100797: LD_VAR 0 3
100801: PPUSH
100802: CALL_OW 48
// result := IsPlaced ( unit ) ;
100806: LD_ADDR_VAR 0 4
100810: PUSH
100811: LD_VAR 0 1
100815: PPUSH
100816: CALL_OW 305
100820: ST_TO_ADDR
// exit ;
100821: POP
100822: POP
100823: GO 100829
// end ; end ;
100825: GO 100704
100827: POP
100828: POP
// end ;
100829: LD_VAR 0 4
100833: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100834: LD_INT 0
100836: PPUSH
100837: PPUSH
100838: PPUSH
// if not side or side > 8 then
100839: LD_VAR 0 1
100843: NOT
100844: PUSH
100845: LD_VAR 0 1
100849: PUSH
100850: LD_INT 8
100852: GREATER
100853: OR
100854: IFFALSE 100858
// exit ;
100856: GO 101045
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100858: LD_ADDR_VAR 0 4
100862: PUSH
100863: LD_INT 22
100865: PUSH
100866: LD_VAR 0 1
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: PUSH
100875: LD_INT 21
100877: PUSH
100878: LD_INT 3
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: EMPTY
100886: LIST
100887: LIST
100888: PPUSH
100889: CALL_OW 69
100893: ST_TO_ADDR
// if not tmp then
100894: LD_VAR 0 4
100898: NOT
100899: IFFALSE 100903
// exit ;
100901: GO 101045
// enable_addtolog := true ;
100903: LD_ADDR_OWVAR 81
100907: PUSH
100908: LD_INT 1
100910: ST_TO_ADDR
// AddToLog ( [ ) ;
100911: LD_STRING [
100913: PPUSH
100914: CALL_OW 561
// for i in tmp do
100918: LD_ADDR_VAR 0 3
100922: PUSH
100923: LD_VAR 0 4
100927: PUSH
100928: FOR_IN
100929: IFFALSE 101036
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100931: LD_STRING [
100933: PUSH
100934: LD_VAR 0 3
100938: PPUSH
100939: CALL_OW 266
100943: STR
100944: PUSH
100945: LD_STRING , 
100947: STR
100948: PUSH
100949: LD_VAR 0 3
100953: PPUSH
100954: CALL_OW 250
100958: STR
100959: PUSH
100960: LD_STRING , 
100962: STR
100963: PUSH
100964: LD_VAR 0 3
100968: PPUSH
100969: CALL_OW 251
100973: STR
100974: PUSH
100975: LD_STRING , 
100977: STR
100978: PUSH
100979: LD_VAR 0 3
100983: PPUSH
100984: CALL_OW 254
100988: STR
100989: PUSH
100990: LD_STRING , 
100992: STR
100993: PUSH
100994: LD_VAR 0 3
100998: PPUSH
100999: LD_INT 1
101001: PPUSH
101002: CALL_OW 268
101006: STR
101007: PUSH
101008: LD_STRING , 
101010: STR
101011: PUSH
101012: LD_VAR 0 3
101016: PPUSH
101017: LD_INT 2
101019: PPUSH
101020: CALL_OW 268
101024: STR
101025: PUSH
101026: LD_STRING ],
101028: STR
101029: PPUSH
101030: CALL_OW 561
// end ;
101034: GO 100928
101036: POP
101037: POP
// AddToLog ( ]; ) ;
101038: LD_STRING ];
101040: PPUSH
101041: CALL_OW 561
// end ;
101045: LD_VAR 0 2
101049: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101050: LD_INT 0
101052: PPUSH
101053: PPUSH
101054: PPUSH
101055: PPUSH
101056: PPUSH
// if not area or not rate or not max then
101057: LD_VAR 0 1
101061: NOT
101062: PUSH
101063: LD_VAR 0 2
101067: NOT
101068: OR
101069: PUSH
101070: LD_VAR 0 4
101074: NOT
101075: OR
101076: IFFALSE 101080
// exit ;
101078: GO 101272
// while 1 do
101080: LD_INT 1
101082: IFFALSE 101272
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101084: LD_ADDR_VAR 0 9
101088: PUSH
101089: LD_VAR 0 1
101093: PPUSH
101094: LD_INT 1
101096: PPUSH
101097: CALL_OW 287
101101: PUSH
101102: LD_INT 10
101104: MUL
101105: ST_TO_ADDR
// r := rate / 10 ;
101106: LD_ADDR_VAR 0 7
101110: PUSH
101111: LD_VAR 0 2
101115: PUSH
101116: LD_INT 10
101118: DIVREAL
101119: ST_TO_ADDR
// time := 1 1$00 ;
101120: LD_ADDR_VAR 0 8
101124: PUSH
101125: LD_INT 2100
101127: ST_TO_ADDR
// if amount < min then
101128: LD_VAR 0 9
101132: PUSH
101133: LD_VAR 0 3
101137: LESS
101138: IFFALSE 101156
// r := r * 2 else
101140: LD_ADDR_VAR 0 7
101144: PUSH
101145: LD_VAR 0 7
101149: PUSH
101150: LD_INT 2
101152: MUL
101153: ST_TO_ADDR
101154: GO 101182
// if amount > max then
101156: LD_VAR 0 9
101160: PUSH
101161: LD_VAR 0 4
101165: GREATER
101166: IFFALSE 101182
// r := r / 2 ;
101168: LD_ADDR_VAR 0 7
101172: PUSH
101173: LD_VAR 0 7
101177: PUSH
101178: LD_INT 2
101180: DIVREAL
101181: ST_TO_ADDR
// time := time / r ;
101182: LD_ADDR_VAR 0 8
101186: PUSH
101187: LD_VAR 0 8
101191: PUSH
101192: LD_VAR 0 7
101196: DIVREAL
101197: ST_TO_ADDR
// if time < 0 then
101198: LD_VAR 0 8
101202: PUSH
101203: LD_INT 0
101205: LESS
101206: IFFALSE 101223
// time := time * - 1 ;
101208: LD_ADDR_VAR 0 8
101212: PUSH
101213: LD_VAR 0 8
101217: PUSH
101218: LD_INT 1
101220: NEG
101221: MUL
101222: ST_TO_ADDR
// wait ( time ) ;
101223: LD_VAR 0 8
101227: PPUSH
101228: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101232: LD_INT 35
101234: PPUSH
101235: LD_INT 875
101237: PPUSH
101238: CALL_OW 12
101242: PPUSH
101243: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101247: LD_INT 1
101249: PPUSH
101250: LD_INT 5
101252: PPUSH
101253: CALL_OW 12
101257: PPUSH
101258: LD_VAR 0 1
101262: PPUSH
101263: LD_INT 1
101265: PPUSH
101266: CALL_OW 55
// end ;
101270: GO 101080
// end ;
101272: LD_VAR 0 5
101276: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101277: LD_INT 0
101279: PPUSH
101280: PPUSH
101281: PPUSH
101282: PPUSH
101283: PPUSH
101284: PPUSH
101285: PPUSH
101286: PPUSH
// if not turrets or not factories then
101287: LD_VAR 0 1
101291: NOT
101292: PUSH
101293: LD_VAR 0 2
101297: NOT
101298: OR
101299: IFFALSE 101303
// exit ;
101301: GO 101610
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101303: LD_ADDR_VAR 0 10
101307: PUSH
101308: LD_INT 5
101310: PUSH
101311: LD_INT 6
101313: PUSH
101314: EMPTY
101315: LIST
101316: LIST
101317: PUSH
101318: LD_INT 2
101320: PUSH
101321: LD_INT 4
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PUSH
101328: LD_INT 3
101330: PUSH
101331: LD_INT 5
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: EMPTY
101339: LIST
101340: LIST
101341: LIST
101342: PUSH
101343: LD_INT 24
101345: PUSH
101346: LD_INT 25
101348: PUSH
101349: EMPTY
101350: LIST
101351: LIST
101352: PUSH
101353: LD_INT 23
101355: PUSH
101356: LD_INT 27
101358: PUSH
101359: EMPTY
101360: LIST
101361: LIST
101362: PUSH
101363: EMPTY
101364: LIST
101365: LIST
101366: PUSH
101367: LD_INT 42
101369: PUSH
101370: LD_INT 43
101372: PUSH
101373: EMPTY
101374: LIST
101375: LIST
101376: PUSH
101377: LD_INT 44
101379: PUSH
101380: LD_INT 46
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: LD_INT 45
101389: PUSH
101390: LD_INT 47
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: LIST
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: LIST
101406: ST_TO_ADDR
// result := [ ] ;
101407: LD_ADDR_VAR 0 3
101411: PUSH
101412: EMPTY
101413: ST_TO_ADDR
// for i in turrets do
101414: LD_ADDR_VAR 0 4
101418: PUSH
101419: LD_VAR 0 1
101423: PUSH
101424: FOR_IN
101425: IFFALSE 101608
// begin nat := GetNation ( i ) ;
101427: LD_ADDR_VAR 0 7
101431: PUSH
101432: LD_VAR 0 4
101436: PPUSH
101437: CALL_OW 248
101441: ST_TO_ADDR
// weapon := 0 ;
101442: LD_ADDR_VAR 0 8
101446: PUSH
101447: LD_INT 0
101449: ST_TO_ADDR
// if not nat then
101450: LD_VAR 0 7
101454: NOT
101455: IFFALSE 101459
// continue ;
101457: GO 101424
// for j in list [ nat ] do
101459: LD_ADDR_VAR 0 5
101463: PUSH
101464: LD_VAR 0 10
101468: PUSH
101469: LD_VAR 0 7
101473: ARRAY
101474: PUSH
101475: FOR_IN
101476: IFFALSE 101517
// if GetBWeapon ( i ) = j [ 1 ] then
101478: LD_VAR 0 4
101482: PPUSH
101483: CALL_OW 269
101487: PUSH
101488: LD_VAR 0 5
101492: PUSH
101493: LD_INT 1
101495: ARRAY
101496: EQUAL
101497: IFFALSE 101515
// begin weapon := j [ 2 ] ;
101499: LD_ADDR_VAR 0 8
101503: PUSH
101504: LD_VAR 0 5
101508: PUSH
101509: LD_INT 2
101511: ARRAY
101512: ST_TO_ADDR
// break ;
101513: GO 101517
// end ;
101515: GO 101475
101517: POP
101518: POP
// if not weapon then
101519: LD_VAR 0 8
101523: NOT
101524: IFFALSE 101528
// continue ;
101526: GO 101424
// for k in factories do
101528: LD_ADDR_VAR 0 6
101532: PUSH
101533: LD_VAR 0 2
101537: PUSH
101538: FOR_IN
101539: IFFALSE 101604
// begin weapons := AvailableWeaponList ( k ) ;
101541: LD_ADDR_VAR 0 9
101545: PUSH
101546: LD_VAR 0 6
101550: PPUSH
101551: CALL_OW 478
101555: ST_TO_ADDR
// if not weapons then
101556: LD_VAR 0 9
101560: NOT
101561: IFFALSE 101565
// continue ;
101563: GO 101538
// if weapon in weapons then
101565: LD_VAR 0 8
101569: PUSH
101570: LD_VAR 0 9
101574: IN
101575: IFFALSE 101602
// begin result := [ i , weapon ] ;
101577: LD_ADDR_VAR 0 3
101581: PUSH
101582: LD_VAR 0 4
101586: PUSH
101587: LD_VAR 0 8
101591: PUSH
101592: EMPTY
101593: LIST
101594: LIST
101595: ST_TO_ADDR
// exit ;
101596: POP
101597: POP
101598: POP
101599: POP
101600: GO 101610
// end ; end ;
101602: GO 101538
101604: POP
101605: POP
// end ;
101606: GO 101424
101608: POP
101609: POP
// end ;
101610: LD_VAR 0 3
101614: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101615: LD_INT 0
101617: PPUSH
// if not side or side > 8 then
101618: LD_VAR 0 3
101622: NOT
101623: PUSH
101624: LD_VAR 0 3
101628: PUSH
101629: LD_INT 8
101631: GREATER
101632: OR
101633: IFFALSE 101637
// exit ;
101635: GO 101696
// if not range then
101637: LD_VAR 0 4
101641: NOT
101642: IFFALSE 101653
// range := - 12 ;
101644: LD_ADDR_VAR 0 4
101648: PUSH
101649: LD_INT 12
101651: NEG
101652: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101653: LD_VAR 0 1
101657: PPUSH
101658: LD_VAR 0 2
101662: PPUSH
101663: LD_VAR 0 3
101667: PPUSH
101668: LD_VAR 0 4
101672: PPUSH
101673: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101677: LD_VAR 0 1
101681: PPUSH
101682: LD_VAR 0 2
101686: PPUSH
101687: LD_VAR 0 3
101691: PPUSH
101692: CALL_OW 331
// end ;
101696: LD_VAR 0 5
101700: RET
// export function Video ( mode ) ; begin
101701: LD_INT 0
101703: PPUSH
// ingame_video = mode ;
101704: LD_ADDR_OWVAR 52
101708: PUSH
101709: LD_VAR 0 1
101713: ST_TO_ADDR
// interface_hidden = mode ;
101714: LD_ADDR_OWVAR 54
101718: PUSH
101719: LD_VAR 0 1
101723: ST_TO_ADDR
// end ;
101724: LD_VAR 0 2
101728: RET
// export function Join ( array , element ) ; begin
101729: LD_INT 0
101731: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101732: LD_ADDR_VAR 0 3
101736: PUSH
101737: LD_VAR 0 1
101741: PPUSH
101742: LD_VAR 0 1
101746: PUSH
101747: LD_INT 1
101749: PLUS
101750: PPUSH
101751: LD_VAR 0 2
101755: PPUSH
101756: CALL_OW 1
101760: ST_TO_ADDR
// end ;
101761: LD_VAR 0 3
101765: RET
// export function JoinUnion ( array , element ) ; begin
101766: LD_INT 0
101768: PPUSH
// result := array union element ;
101769: LD_ADDR_VAR 0 3
101773: PUSH
101774: LD_VAR 0 1
101778: PUSH
101779: LD_VAR 0 2
101783: UNION
101784: ST_TO_ADDR
// end ;
101785: LD_VAR 0 3
101789: RET
// export function GetBehemoths ( side ) ; begin
101790: LD_INT 0
101792: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101793: LD_ADDR_VAR 0 2
101797: PUSH
101798: LD_INT 22
101800: PUSH
101801: LD_VAR 0 1
101805: PUSH
101806: EMPTY
101807: LIST
101808: LIST
101809: PUSH
101810: LD_INT 31
101812: PUSH
101813: LD_INT 25
101815: PUSH
101816: EMPTY
101817: LIST
101818: LIST
101819: PUSH
101820: EMPTY
101821: LIST
101822: LIST
101823: PPUSH
101824: CALL_OW 69
101828: ST_TO_ADDR
// end ;
101829: LD_VAR 0 2
101833: RET
// export function Shuffle ( array ) ; var i , index ; begin
101834: LD_INT 0
101836: PPUSH
101837: PPUSH
101838: PPUSH
// result := [ ] ;
101839: LD_ADDR_VAR 0 2
101843: PUSH
101844: EMPTY
101845: ST_TO_ADDR
// if not array then
101846: LD_VAR 0 1
101850: NOT
101851: IFFALSE 101855
// exit ;
101853: GO 101954
// Randomize ;
101855: CALL_OW 10
// for i = array downto 1 do
101859: LD_ADDR_VAR 0 3
101863: PUSH
101864: DOUBLE
101865: LD_VAR 0 1
101869: INC
101870: ST_TO_ADDR
101871: LD_INT 1
101873: PUSH
101874: FOR_DOWNTO
101875: IFFALSE 101952
// begin index := rand ( 1 , array ) ;
101877: LD_ADDR_VAR 0 4
101881: PUSH
101882: LD_INT 1
101884: PPUSH
101885: LD_VAR 0 1
101889: PPUSH
101890: CALL_OW 12
101894: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101895: LD_ADDR_VAR 0 2
101899: PUSH
101900: LD_VAR 0 2
101904: PPUSH
101905: LD_VAR 0 2
101909: PUSH
101910: LD_INT 1
101912: PLUS
101913: PPUSH
101914: LD_VAR 0 1
101918: PUSH
101919: LD_VAR 0 4
101923: ARRAY
101924: PPUSH
101925: CALL_OW 2
101929: ST_TO_ADDR
// array := Delete ( array , index ) ;
101930: LD_ADDR_VAR 0 1
101934: PUSH
101935: LD_VAR 0 1
101939: PPUSH
101940: LD_VAR 0 4
101944: PPUSH
101945: CALL_OW 3
101949: ST_TO_ADDR
// end ;
101950: GO 101874
101952: POP
101953: POP
// end ;
101954: LD_VAR 0 2
101958: RET
// export function GetBaseMaterials ( base ) ; begin
101959: LD_INT 0
101961: PPUSH
// result := [ 0 , 0 , 0 ] ;
101962: LD_ADDR_VAR 0 2
101966: PUSH
101967: LD_INT 0
101969: PUSH
101970: LD_INT 0
101972: PUSH
101973: LD_INT 0
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: LIST
101980: ST_TO_ADDR
// if not base then
101981: LD_VAR 0 1
101985: NOT
101986: IFFALSE 101990
// exit ;
101988: GO 102039
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101990: LD_ADDR_VAR 0 2
101994: PUSH
101995: LD_VAR 0 1
101999: PPUSH
102000: LD_INT 1
102002: PPUSH
102003: CALL_OW 275
102007: PUSH
102008: LD_VAR 0 1
102012: PPUSH
102013: LD_INT 2
102015: PPUSH
102016: CALL_OW 275
102020: PUSH
102021: LD_VAR 0 1
102025: PPUSH
102026: LD_INT 3
102028: PPUSH
102029: CALL_OW 275
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: LIST
102038: ST_TO_ADDR
// end ;
102039: LD_VAR 0 2
102043: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102044: LD_INT 0
102046: PPUSH
102047: PPUSH
// result := array ;
102048: LD_ADDR_VAR 0 3
102052: PUSH
102053: LD_VAR 0 1
102057: ST_TO_ADDR
// if size > 0 then
102058: LD_VAR 0 2
102062: PUSH
102063: LD_INT 0
102065: GREATER
102066: IFFALSE 102112
// for i := array downto size do
102068: LD_ADDR_VAR 0 4
102072: PUSH
102073: DOUBLE
102074: LD_VAR 0 1
102078: INC
102079: ST_TO_ADDR
102080: LD_VAR 0 2
102084: PUSH
102085: FOR_DOWNTO
102086: IFFALSE 102110
// result := Delete ( result , result ) ;
102088: LD_ADDR_VAR 0 3
102092: PUSH
102093: LD_VAR 0 3
102097: PPUSH
102098: LD_VAR 0 3
102102: PPUSH
102103: CALL_OW 3
102107: ST_TO_ADDR
102108: GO 102085
102110: POP
102111: POP
// end ;
102112: LD_VAR 0 3
102116: RET
// export function ComExit ( unit ) ; var tmp ; begin
102117: LD_INT 0
102119: PPUSH
102120: PPUSH
// if not IsInUnit ( unit ) then
102121: LD_VAR 0 1
102125: PPUSH
102126: CALL_OW 310
102130: NOT
102131: IFFALSE 102135
// exit ;
102133: GO 102195
// tmp := IsInUnit ( unit ) ;
102135: LD_ADDR_VAR 0 3
102139: PUSH
102140: LD_VAR 0 1
102144: PPUSH
102145: CALL_OW 310
102149: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102150: LD_VAR 0 3
102154: PPUSH
102155: CALL_OW 247
102159: PUSH
102160: LD_INT 2
102162: EQUAL
102163: IFFALSE 102176
// ComExitVehicle ( unit ) else
102165: LD_VAR 0 1
102169: PPUSH
102170: CALL_OW 121
102174: GO 102185
// ComExitBuilding ( unit ) ;
102176: LD_VAR 0 1
102180: PPUSH
102181: CALL_OW 122
// result := tmp ;
102185: LD_ADDR_VAR 0 2
102189: PUSH
102190: LD_VAR 0 3
102194: ST_TO_ADDR
// end ;
102195: LD_VAR 0 2
102199: RET
// export function ComExitAll ( units ) ; var i ; begin
102200: LD_INT 0
102202: PPUSH
102203: PPUSH
// if not units then
102204: LD_VAR 0 1
102208: NOT
102209: IFFALSE 102213
// exit ;
102211: GO 102239
// for i in units do
102213: LD_ADDR_VAR 0 3
102217: PUSH
102218: LD_VAR 0 1
102222: PUSH
102223: FOR_IN
102224: IFFALSE 102237
// ComExit ( i ) ;
102226: LD_VAR 0 3
102230: PPUSH
102231: CALL 102117 0 1
102235: GO 102223
102237: POP
102238: POP
// end ;
102239: LD_VAR 0 2
102243: RET
// export function ResetHc ; begin
102244: LD_INT 0
102246: PPUSH
// InitHc ;
102247: CALL_OW 19
// hc_importance := 0 ;
102251: LD_ADDR_OWVAR 32
102255: PUSH
102256: LD_INT 0
102258: ST_TO_ADDR
// end ;
102259: LD_VAR 0 1
102263: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102264: LD_INT 0
102266: PPUSH
102267: PPUSH
102268: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102269: LD_ADDR_VAR 0 6
102273: PUSH
102274: LD_VAR 0 1
102278: PUSH
102279: LD_VAR 0 3
102283: PLUS
102284: PUSH
102285: LD_INT 2
102287: DIV
102288: ST_TO_ADDR
// if _x < 0 then
102289: LD_VAR 0 6
102293: PUSH
102294: LD_INT 0
102296: LESS
102297: IFFALSE 102314
// _x := _x * - 1 ;
102299: LD_ADDR_VAR 0 6
102303: PUSH
102304: LD_VAR 0 6
102308: PUSH
102309: LD_INT 1
102311: NEG
102312: MUL
102313: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102314: LD_ADDR_VAR 0 7
102318: PUSH
102319: LD_VAR 0 2
102323: PUSH
102324: LD_VAR 0 4
102328: PLUS
102329: PUSH
102330: LD_INT 2
102332: DIV
102333: ST_TO_ADDR
// if _y < 0 then
102334: LD_VAR 0 7
102338: PUSH
102339: LD_INT 0
102341: LESS
102342: IFFALSE 102359
// _y := _y * - 1 ;
102344: LD_ADDR_VAR 0 7
102348: PUSH
102349: LD_VAR 0 7
102353: PUSH
102354: LD_INT 1
102356: NEG
102357: MUL
102358: ST_TO_ADDR
// result := [ _x , _y ] ;
102359: LD_ADDR_VAR 0 5
102363: PUSH
102364: LD_VAR 0 6
102368: PUSH
102369: LD_VAR 0 7
102373: PUSH
102374: EMPTY
102375: LIST
102376: LIST
102377: ST_TO_ADDR
// end ;
102378: LD_VAR 0 5
102382: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
102383: LD_INT 0
102385: PPUSH
102386: PPUSH
102387: PPUSH
102388: PPUSH
// task := GetTaskList ( unit ) ;
102389: LD_ADDR_VAR 0 7
102393: PUSH
102394: LD_VAR 0 1
102398: PPUSH
102399: CALL_OW 437
102403: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
102404: LD_VAR 0 7
102408: NOT
102409: PUSH
102410: LD_VAR 0 1
102414: PPUSH
102415: LD_VAR 0 2
102419: PPUSH
102420: CALL_OW 308
102424: NOT
102425: AND
102426: IFFALSE 102430
// exit ;
102428: GO 102548
// if IsInArea ( unit , area ) then
102430: LD_VAR 0 1
102434: PPUSH
102435: LD_VAR 0 2
102439: PPUSH
102440: CALL_OW 308
102444: IFFALSE 102462
// begin ComMoveToArea ( unit , goAway ) ;
102446: LD_VAR 0 1
102450: PPUSH
102451: LD_VAR 0 3
102455: PPUSH
102456: CALL_OW 113
// exit ;
102460: GO 102548
// end ; if task [ 1 ] [ 1 ] <> M then
102462: LD_VAR 0 7
102466: PUSH
102467: LD_INT 1
102469: ARRAY
102470: PUSH
102471: LD_INT 1
102473: ARRAY
102474: PUSH
102475: LD_STRING M
102477: NONEQUAL
102478: IFFALSE 102482
// exit ;
102480: GO 102548
// x := task [ 1 ] [ 2 ] ;
102482: LD_ADDR_VAR 0 5
102486: PUSH
102487: LD_VAR 0 7
102491: PUSH
102492: LD_INT 1
102494: ARRAY
102495: PUSH
102496: LD_INT 2
102498: ARRAY
102499: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
102500: LD_ADDR_VAR 0 6
102504: PUSH
102505: LD_VAR 0 7
102509: PUSH
102510: LD_INT 1
102512: ARRAY
102513: PUSH
102514: LD_INT 3
102516: ARRAY
102517: ST_TO_ADDR
// if InArea ( x , y , area ) then
102518: LD_VAR 0 5
102522: PPUSH
102523: LD_VAR 0 6
102527: PPUSH
102528: LD_VAR 0 2
102532: PPUSH
102533: CALL_OW 309
102537: IFFALSE 102548
// ComStop ( unit ) ;
102539: LD_VAR 0 1
102543: PPUSH
102544: CALL_OW 141
// end ;
102548: LD_VAR 0 4
102552: RET
// export function Abs ( value ) ; begin
102553: LD_INT 0
102555: PPUSH
// result := value ;
102556: LD_ADDR_VAR 0 2
102560: PUSH
102561: LD_VAR 0 1
102565: ST_TO_ADDR
// if value < 0 then
102566: LD_VAR 0 1
102570: PUSH
102571: LD_INT 0
102573: LESS
102574: IFFALSE 102591
// result := value * - 1 ;
102576: LD_ADDR_VAR 0 2
102580: PUSH
102581: LD_VAR 0 1
102585: PUSH
102586: LD_INT 1
102588: NEG
102589: MUL
102590: ST_TO_ADDR
// end ;
102591: LD_VAR 0 2
102595: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102596: LD_INT 0
102598: PPUSH
102599: PPUSH
102600: PPUSH
102601: PPUSH
102602: PPUSH
102603: PPUSH
102604: PPUSH
102605: PPUSH
// if not unit or not building then
102606: LD_VAR 0 1
102610: NOT
102611: PUSH
102612: LD_VAR 0 2
102616: NOT
102617: OR
102618: IFFALSE 102622
// exit ;
102620: GO 102848
// x := GetX ( building ) ;
102622: LD_ADDR_VAR 0 4
102626: PUSH
102627: LD_VAR 0 2
102631: PPUSH
102632: CALL_OW 250
102636: ST_TO_ADDR
// y := GetY ( building ) ;
102637: LD_ADDR_VAR 0 6
102641: PUSH
102642: LD_VAR 0 2
102646: PPUSH
102647: CALL_OW 251
102651: ST_TO_ADDR
// d := GetDir ( building ) ;
102652: LD_ADDR_VAR 0 8
102656: PUSH
102657: LD_VAR 0 2
102661: PPUSH
102662: CALL_OW 254
102666: ST_TO_ADDR
// r := 4 ;
102667: LD_ADDR_VAR 0 9
102671: PUSH
102672: LD_INT 4
102674: ST_TO_ADDR
// for i := 1 to 5 do
102675: LD_ADDR_VAR 0 10
102679: PUSH
102680: DOUBLE
102681: LD_INT 1
102683: DEC
102684: ST_TO_ADDR
102685: LD_INT 5
102687: PUSH
102688: FOR_TO
102689: IFFALSE 102846
// begin _x := ShiftX ( x , d , r + i ) ;
102691: LD_ADDR_VAR 0 5
102695: PUSH
102696: LD_VAR 0 4
102700: PPUSH
102701: LD_VAR 0 8
102705: PPUSH
102706: LD_VAR 0 9
102710: PUSH
102711: LD_VAR 0 10
102715: PLUS
102716: PPUSH
102717: CALL_OW 272
102721: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102722: LD_ADDR_VAR 0 7
102726: PUSH
102727: LD_VAR 0 6
102731: PPUSH
102732: LD_VAR 0 8
102736: PPUSH
102737: LD_VAR 0 9
102741: PUSH
102742: LD_VAR 0 10
102746: PLUS
102747: PPUSH
102748: CALL_OW 273
102752: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102753: LD_VAR 0 5
102757: PPUSH
102758: LD_VAR 0 7
102762: PPUSH
102763: CALL_OW 488
102767: PUSH
102768: LD_VAR 0 5
102772: PPUSH
102773: LD_VAR 0 7
102777: PPUSH
102778: CALL_OW 428
102782: PPUSH
102783: CALL_OW 247
102787: PUSH
102788: LD_INT 3
102790: PUSH
102791: LD_INT 2
102793: PUSH
102794: EMPTY
102795: LIST
102796: LIST
102797: IN
102798: NOT
102799: AND
102800: IFFALSE 102844
// begin ComMoveXY ( unit , _x , _y ) ;
102802: LD_VAR 0 1
102806: PPUSH
102807: LD_VAR 0 5
102811: PPUSH
102812: LD_VAR 0 7
102816: PPUSH
102817: CALL_OW 111
// result := [ _x , _y ] ;
102821: LD_ADDR_VAR 0 3
102825: PUSH
102826: LD_VAR 0 5
102830: PUSH
102831: LD_VAR 0 7
102835: PUSH
102836: EMPTY
102837: LIST
102838: LIST
102839: ST_TO_ADDR
// exit ;
102840: POP
102841: POP
102842: GO 102848
// end ; end ;
102844: GO 102688
102846: POP
102847: POP
// end ;
102848: LD_VAR 0 3
102852: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
102853: LD_INT 0
102855: PPUSH
102856: PPUSH
102857: PPUSH
// result := 0 ;
102858: LD_ADDR_VAR 0 3
102862: PUSH
102863: LD_INT 0
102865: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
102866: LD_VAR 0 1
102870: PUSH
102871: LD_INT 0
102873: LESS
102874: PUSH
102875: LD_VAR 0 1
102879: PUSH
102880: LD_INT 8
102882: GREATER
102883: OR
102884: PUSH
102885: LD_VAR 0 2
102889: PUSH
102890: LD_INT 0
102892: LESS
102893: OR
102894: PUSH
102895: LD_VAR 0 2
102899: PUSH
102900: LD_INT 8
102902: GREATER
102903: OR
102904: IFFALSE 102908
// exit ;
102906: GO 102983
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102908: LD_ADDR_VAR 0 4
102912: PUSH
102913: LD_INT 22
102915: PUSH
102916: LD_VAR 0 2
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: PPUSH
102925: CALL_OW 69
102929: PUSH
102930: FOR_IN
102931: IFFALSE 102981
// begin un := UnitShoot ( i ) ;
102933: LD_ADDR_VAR 0 5
102937: PUSH
102938: LD_VAR 0 4
102942: PPUSH
102943: CALL_OW 504
102947: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102948: LD_VAR 0 5
102952: PPUSH
102953: CALL_OW 255
102957: PUSH
102958: LD_VAR 0 1
102962: EQUAL
102963: IFFALSE 102979
// begin result := un ;
102965: LD_ADDR_VAR 0 3
102969: PUSH
102970: LD_VAR 0 5
102974: ST_TO_ADDR
// exit ;
102975: POP
102976: POP
102977: GO 102983
// end ; end ;
102979: GO 102930
102981: POP
102982: POP
// end ;
102983: LD_VAR 0 3
102987: RET
// export function GetCargoBay ( units ) ; begin
102988: LD_INT 0
102990: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102991: LD_ADDR_VAR 0 2
102995: PUSH
102996: LD_VAR 0 1
103000: PPUSH
103001: LD_INT 2
103003: PUSH
103004: LD_INT 34
103006: PUSH
103007: LD_INT 12
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: PUSH
103014: LD_INT 34
103016: PUSH
103017: LD_INT 51
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 34
103026: PUSH
103027: LD_INT 32
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: PUSH
103034: LD_INT 34
103036: PUSH
103037: LD_EXP 96
103041: PUSH
103042: EMPTY
103043: LIST
103044: LIST
103045: PUSH
103046: EMPTY
103047: LIST
103048: LIST
103049: LIST
103050: LIST
103051: LIST
103052: PPUSH
103053: CALL_OW 72
103057: ST_TO_ADDR
// end ; end_of_file end_of_file
103058: LD_VAR 0 2
103062: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103063: LD_INT 0
103065: PPUSH
// if p2 = 100 then
103066: LD_VAR 0 2
103070: PUSH
103071: LD_INT 100
103073: EQUAL
103074: IFFALSE 104023
// begin if not StreamModeActive then
103076: LD_EXP 159
103080: NOT
103081: IFFALSE 103091
// StreamModeActive := true ;
103083: LD_ADDR_EXP 159
103087: PUSH
103088: LD_INT 1
103090: ST_TO_ADDR
// if p3 = 0 then
103091: LD_VAR 0 3
103095: PUSH
103096: LD_INT 0
103098: EQUAL
103099: IFFALSE 103105
// InitStreamMode ;
103101: CALL 104183 0 0
// if p3 = 1 then
103105: LD_VAR 0 3
103109: PUSH
103110: LD_INT 1
103112: EQUAL
103113: IFFALSE 103123
// sRocket := true ;
103115: LD_ADDR_EXP 164
103119: PUSH
103120: LD_INT 1
103122: ST_TO_ADDR
// if p3 = 2 then
103123: LD_VAR 0 3
103127: PUSH
103128: LD_INT 2
103130: EQUAL
103131: IFFALSE 103141
// sSpeed := true ;
103133: LD_ADDR_EXP 163
103137: PUSH
103138: LD_INT 1
103140: ST_TO_ADDR
// if p3 = 3 then
103141: LD_VAR 0 3
103145: PUSH
103146: LD_INT 3
103148: EQUAL
103149: IFFALSE 103159
// sEngine := true ;
103151: LD_ADDR_EXP 165
103155: PUSH
103156: LD_INT 1
103158: ST_TO_ADDR
// if p3 = 4 then
103159: LD_VAR 0 3
103163: PUSH
103164: LD_INT 4
103166: EQUAL
103167: IFFALSE 103177
// sSpec := true ;
103169: LD_ADDR_EXP 162
103173: PUSH
103174: LD_INT 1
103176: ST_TO_ADDR
// if p3 = 5 then
103177: LD_VAR 0 3
103181: PUSH
103182: LD_INT 5
103184: EQUAL
103185: IFFALSE 103195
// sLevel := true ;
103187: LD_ADDR_EXP 166
103191: PUSH
103192: LD_INT 1
103194: ST_TO_ADDR
// if p3 = 6 then
103195: LD_VAR 0 3
103199: PUSH
103200: LD_INT 6
103202: EQUAL
103203: IFFALSE 103213
// sArmoury := true ;
103205: LD_ADDR_EXP 167
103209: PUSH
103210: LD_INT 1
103212: ST_TO_ADDR
// if p3 = 7 then
103213: LD_VAR 0 3
103217: PUSH
103218: LD_INT 7
103220: EQUAL
103221: IFFALSE 103231
// sRadar := true ;
103223: LD_ADDR_EXP 168
103227: PUSH
103228: LD_INT 1
103230: ST_TO_ADDR
// if p3 = 8 then
103231: LD_VAR 0 3
103235: PUSH
103236: LD_INT 8
103238: EQUAL
103239: IFFALSE 103249
// sBunker := true ;
103241: LD_ADDR_EXP 169
103245: PUSH
103246: LD_INT 1
103248: ST_TO_ADDR
// if p3 = 9 then
103249: LD_VAR 0 3
103253: PUSH
103254: LD_INT 9
103256: EQUAL
103257: IFFALSE 103267
// sHack := true ;
103259: LD_ADDR_EXP 170
103263: PUSH
103264: LD_INT 1
103266: ST_TO_ADDR
// if p3 = 10 then
103267: LD_VAR 0 3
103271: PUSH
103272: LD_INT 10
103274: EQUAL
103275: IFFALSE 103285
// sFire := true ;
103277: LD_ADDR_EXP 171
103281: PUSH
103282: LD_INT 1
103284: ST_TO_ADDR
// if p3 = 11 then
103285: LD_VAR 0 3
103289: PUSH
103290: LD_INT 11
103292: EQUAL
103293: IFFALSE 103303
// sRefresh := true ;
103295: LD_ADDR_EXP 172
103299: PUSH
103300: LD_INT 1
103302: ST_TO_ADDR
// if p3 = 12 then
103303: LD_VAR 0 3
103307: PUSH
103308: LD_INT 12
103310: EQUAL
103311: IFFALSE 103321
// sExp := true ;
103313: LD_ADDR_EXP 173
103317: PUSH
103318: LD_INT 1
103320: ST_TO_ADDR
// if p3 = 13 then
103321: LD_VAR 0 3
103325: PUSH
103326: LD_INT 13
103328: EQUAL
103329: IFFALSE 103339
// sDepot := true ;
103331: LD_ADDR_EXP 174
103335: PUSH
103336: LD_INT 1
103338: ST_TO_ADDR
// if p3 = 14 then
103339: LD_VAR 0 3
103343: PUSH
103344: LD_INT 14
103346: EQUAL
103347: IFFALSE 103357
// sFlag := true ;
103349: LD_ADDR_EXP 175
103353: PUSH
103354: LD_INT 1
103356: ST_TO_ADDR
// if p3 = 15 then
103357: LD_VAR 0 3
103361: PUSH
103362: LD_INT 15
103364: EQUAL
103365: IFFALSE 103375
// sKamikadze := true ;
103367: LD_ADDR_EXP 183
103371: PUSH
103372: LD_INT 1
103374: ST_TO_ADDR
// if p3 = 16 then
103375: LD_VAR 0 3
103379: PUSH
103380: LD_INT 16
103382: EQUAL
103383: IFFALSE 103393
// sTroll := true ;
103385: LD_ADDR_EXP 184
103389: PUSH
103390: LD_INT 1
103392: ST_TO_ADDR
// if p3 = 17 then
103393: LD_VAR 0 3
103397: PUSH
103398: LD_INT 17
103400: EQUAL
103401: IFFALSE 103411
// sSlow := true ;
103403: LD_ADDR_EXP 185
103407: PUSH
103408: LD_INT 1
103410: ST_TO_ADDR
// if p3 = 18 then
103411: LD_VAR 0 3
103415: PUSH
103416: LD_INT 18
103418: EQUAL
103419: IFFALSE 103429
// sLack := true ;
103421: LD_ADDR_EXP 186
103425: PUSH
103426: LD_INT 1
103428: ST_TO_ADDR
// if p3 = 19 then
103429: LD_VAR 0 3
103433: PUSH
103434: LD_INT 19
103436: EQUAL
103437: IFFALSE 103447
// sTank := true ;
103439: LD_ADDR_EXP 188
103443: PUSH
103444: LD_INT 1
103446: ST_TO_ADDR
// if p3 = 20 then
103447: LD_VAR 0 3
103451: PUSH
103452: LD_INT 20
103454: EQUAL
103455: IFFALSE 103465
// sRemote := true ;
103457: LD_ADDR_EXP 189
103461: PUSH
103462: LD_INT 1
103464: ST_TO_ADDR
// if p3 = 21 then
103465: LD_VAR 0 3
103469: PUSH
103470: LD_INT 21
103472: EQUAL
103473: IFFALSE 103483
// sPowell := true ;
103475: LD_ADDR_EXP 190
103479: PUSH
103480: LD_INT 1
103482: ST_TO_ADDR
// if p3 = 22 then
103483: LD_VAR 0 3
103487: PUSH
103488: LD_INT 22
103490: EQUAL
103491: IFFALSE 103501
// sTeleport := true ;
103493: LD_ADDR_EXP 193
103497: PUSH
103498: LD_INT 1
103500: ST_TO_ADDR
// if p3 = 23 then
103501: LD_VAR 0 3
103505: PUSH
103506: LD_INT 23
103508: EQUAL
103509: IFFALSE 103519
// sOilTower := true ;
103511: LD_ADDR_EXP 195
103515: PUSH
103516: LD_INT 1
103518: ST_TO_ADDR
// if p3 = 24 then
103519: LD_VAR 0 3
103523: PUSH
103524: LD_INT 24
103526: EQUAL
103527: IFFALSE 103537
// sShovel := true ;
103529: LD_ADDR_EXP 196
103533: PUSH
103534: LD_INT 1
103536: ST_TO_ADDR
// if p3 = 25 then
103537: LD_VAR 0 3
103541: PUSH
103542: LD_INT 25
103544: EQUAL
103545: IFFALSE 103555
// sSheik := true ;
103547: LD_ADDR_EXP 197
103551: PUSH
103552: LD_INT 1
103554: ST_TO_ADDR
// if p3 = 26 then
103555: LD_VAR 0 3
103559: PUSH
103560: LD_INT 26
103562: EQUAL
103563: IFFALSE 103573
// sEarthquake := true ;
103565: LD_ADDR_EXP 199
103569: PUSH
103570: LD_INT 1
103572: ST_TO_ADDR
// if p3 = 27 then
103573: LD_VAR 0 3
103577: PUSH
103578: LD_INT 27
103580: EQUAL
103581: IFFALSE 103591
// sAI := true ;
103583: LD_ADDR_EXP 200
103587: PUSH
103588: LD_INT 1
103590: ST_TO_ADDR
// if p3 = 28 then
103591: LD_VAR 0 3
103595: PUSH
103596: LD_INT 28
103598: EQUAL
103599: IFFALSE 103609
// sCargo := true ;
103601: LD_ADDR_EXP 203
103605: PUSH
103606: LD_INT 1
103608: ST_TO_ADDR
// if p3 = 29 then
103609: LD_VAR 0 3
103613: PUSH
103614: LD_INT 29
103616: EQUAL
103617: IFFALSE 103627
// sDLaser := true ;
103619: LD_ADDR_EXP 204
103623: PUSH
103624: LD_INT 1
103626: ST_TO_ADDR
// if p3 = 30 then
103627: LD_VAR 0 3
103631: PUSH
103632: LD_INT 30
103634: EQUAL
103635: IFFALSE 103645
// sExchange := true ;
103637: LD_ADDR_EXP 205
103641: PUSH
103642: LD_INT 1
103644: ST_TO_ADDR
// if p3 = 31 then
103645: LD_VAR 0 3
103649: PUSH
103650: LD_INT 31
103652: EQUAL
103653: IFFALSE 103663
// sFac := true ;
103655: LD_ADDR_EXP 206
103659: PUSH
103660: LD_INT 1
103662: ST_TO_ADDR
// if p3 = 32 then
103663: LD_VAR 0 3
103667: PUSH
103668: LD_INT 32
103670: EQUAL
103671: IFFALSE 103681
// sPower := true ;
103673: LD_ADDR_EXP 207
103677: PUSH
103678: LD_INT 1
103680: ST_TO_ADDR
// if p3 = 33 then
103681: LD_VAR 0 3
103685: PUSH
103686: LD_INT 33
103688: EQUAL
103689: IFFALSE 103699
// sRandom := true ;
103691: LD_ADDR_EXP 208
103695: PUSH
103696: LD_INT 1
103698: ST_TO_ADDR
// if p3 = 34 then
103699: LD_VAR 0 3
103703: PUSH
103704: LD_INT 34
103706: EQUAL
103707: IFFALSE 103717
// sShield := true ;
103709: LD_ADDR_EXP 209
103713: PUSH
103714: LD_INT 1
103716: ST_TO_ADDR
// if p3 = 35 then
103717: LD_VAR 0 3
103721: PUSH
103722: LD_INT 35
103724: EQUAL
103725: IFFALSE 103735
// sTime := true ;
103727: LD_ADDR_EXP 210
103731: PUSH
103732: LD_INT 1
103734: ST_TO_ADDR
// if p3 = 36 then
103735: LD_VAR 0 3
103739: PUSH
103740: LD_INT 36
103742: EQUAL
103743: IFFALSE 103753
// sTools := true ;
103745: LD_ADDR_EXP 211
103749: PUSH
103750: LD_INT 1
103752: ST_TO_ADDR
// if p3 = 101 then
103753: LD_VAR 0 3
103757: PUSH
103758: LD_INT 101
103760: EQUAL
103761: IFFALSE 103771
// sSold := true ;
103763: LD_ADDR_EXP 176
103767: PUSH
103768: LD_INT 1
103770: ST_TO_ADDR
// if p3 = 102 then
103771: LD_VAR 0 3
103775: PUSH
103776: LD_INT 102
103778: EQUAL
103779: IFFALSE 103789
// sDiff := true ;
103781: LD_ADDR_EXP 177
103785: PUSH
103786: LD_INT 1
103788: ST_TO_ADDR
// if p3 = 103 then
103789: LD_VAR 0 3
103793: PUSH
103794: LD_INT 103
103796: EQUAL
103797: IFFALSE 103807
// sFog := true ;
103799: LD_ADDR_EXP 180
103803: PUSH
103804: LD_INT 1
103806: ST_TO_ADDR
// if p3 = 104 then
103807: LD_VAR 0 3
103811: PUSH
103812: LD_INT 104
103814: EQUAL
103815: IFFALSE 103825
// sReset := true ;
103817: LD_ADDR_EXP 181
103821: PUSH
103822: LD_INT 1
103824: ST_TO_ADDR
// if p3 = 105 then
103825: LD_VAR 0 3
103829: PUSH
103830: LD_INT 105
103832: EQUAL
103833: IFFALSE 103843
// sSun := true ;
103835: LD_ADDR_EXP 182
103839: PUSH
103840: LD_INT 1
103842: ST_TO_ADDR
// if p3 = 106 then
103843: LD_VAR 0 3
103847: PUSH
103848: LD_INT 106
103850: EQUAL
103851: IFFALSE 103861
// sTiger := true ;
103853: LD_ADDR_EXP 178
103857: PUSH
103858: LD_INT 1
103860: ST_TO_ADDR
// if p3 = 107 then
103861: LD_VAR 0 3
103865: PUSH
103866: LD_INT 107
103868: EQUAL
103869: IFFALSE 103879
// sBomb := true ;
103871: LD_ADDR_EXP 179
103875: PUSH
103876: LD_INT 1
103878: ST_TO_ADDR
// if p3 = 108 then
103879: LD_VAR 0 3
103883: PUSH
103884: LD_INT 108
103886: EQUAL
103887: IFFALSE 103897
// sWound := true ;
103889: LD_ADDR_EXP 187
103893: PUSH
103894: LD_INT 1
103896: ST_TO_ADDR
// if p3 = 109 then
103897: LD_VAR 0 3
103901: PUSH
103902: LD_INT 109
103904: EQUAL
103905: IFFALSE 103915
// sBetray := true ;
103907: LD_ADDR_EXP 191
103911: PUSH
103912: LD_INT 1
103914: ST_TO_ADDR
// if p3 = 110 then
103915: LD_VAR 0 3
103919: PUSH
103920: LD_INT 110
103922: EQUAL
103923: IFFALSE 103933
// sContamin := true ;
103925: LD_ADDR_EXP 192
103929: PUSH
103930: LD_INT 1
103932: ST_TO_ADDR
// if p3 = 111 then
103933: LD_VAR 0 3
103937: PUSH
103938: LD_INT 111
103940: EQUAL
103941: IFFALSE 103951
// sOil := true ;
103943: LD_ADDR_EXP 194
103947: PUSH
103948: LD_INT 1
103950: ST_TO_ADDR
// if p3 = 112 then
103951: LD_VAR 0 3
103955: PUSH
103956: LD_INT 112
103958: EQUAL
103959: IFFALSE 103969
// sStu := true ;
103961: LD_ADDR_EXP 198
103965: PUSH
103966: LD_INT 1
103968: ST_TO_ADDR
// if p3 = 113 then
103969: LD_VAR 0 3
103973: PUSH
103974: LD_INT 113
103976: EQUAL
103977: IFFALSE 103987
// sBazooka := true ;
103979: LD_ADDR_EXP 201
103983: PUSH
103984: LD_INT 1
103986: ST_TO_ADDR
// if p3 = 114 then
103987: LD_VAR 0 3
103991: PUSH
103992: LD_INT 114
103994: EQUAL
103995: IFFALSE 104005
// sMortar := true ;
103997: LD_ADDR_EXP 202
104001: PUSH
104002: LD_INT 1
104004: ST_TO_ADDR
// if p3 = 115 then
104005: LD_VAR 0 3
104009: PUSH
104010: LD_INT 115
104012: EQUAL
104013: IFFALSE 104023
// sRanger := true ;
104015: LD_ADDR_EXP 212
104019: PUSH
104020: LD_INT 1
104022: ST_TO_ADDR
// end ; if p2 = 101 then
104023: LD_VAR 0 2
104027: PUSH
104028: LD_INT 101
104030: EQUAL
104031: IFFALSE 104159
// begin case p3 of 1 :
104033: LD_VAR 0 3
104037: PUSH
104038: LD_INT 1
104040: DOUBLE
104041: EQUAL
104042: IFTRUE 104046
104044: GO 104053
104046: POP
// hHackUnlimitedResources ; 2 :
104047: CALL 115196 0 0
104051: GO 104159
104053: LD_INT 2
104055: DOUBLE
104056: EQUAL
104057: IFTRUE 104061
104059: GO 104068
104061: POP
// hHackSetLevel10 ; 3 :
104062: CALL 115329 0 0
104066: GO 104159
104068: LD_INT 3
104070: DOUBLE
104071: EQUAL
104072: IFTRUE 104076
104074: GO 104083
104076: POP
// hHackSetLevel10YourUnits ; 4 :
104077: CALL 115414 0 0
104081: GO 104159
104083: LD_INT 4
104085: DOUBLE
104086: EQUAL
104087: IFTRUE 104091
104089: GO 104098
104091: POP
// hHackInvincible ; 5 :
104092: CALL 115862 0 0
104096: GO 104159
104098: LD_INT 5
104100: DOUBLE
104101: EQUAL
104102: IFTRUE 104106
104104: GO 104113
104106: POP
// hHackInvisible ; 6 :
104107: CALL 115973 0 0
104111: GO 104159
104113: LD_INT 6
104115: DOUBLE
104116: EQUAL
104117: IFTRUE 104121
104119: GO 104128
104121: POP
// hHackChangeYourSide ; 7 :
104122: CALL 116030 0 0
104126: GO 104159
104128: LD_INT 7
104130: DOUBLE
104131: EQUAL
104132: IFTRUE 104136
104134: GO 104143
104136: POP
// hHackChangeUnitSide ; 8 :
104137: CALL 116072 0 0
104141: GO 104159
104143: LD_INT 8
104145: DOUBLE
104146: EQUAL
104147: IFTRUE 104151
104149: GO 104158
104151: POP
// hHackFog ; end ;
104152: CALL 116173 0 0
104156: GO 104159
104158: POP
// end ; end ;
104159: LD_VAR 0 7
104163: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
104164: GO 104166
104166: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
104167: LD_STRING initStreamRollete();
104169: PPUSH
104170: CALL_OW 559
// InitStreamMode ;
104174: CALL 104183 0 0
// DefineStreamItems ( ) ;
104178: CALL 104623 0 0
// end ;
104182: END
// function InitStreamMode ; begin
104183: LD_INT 0
104185: PPUSH
// streamModeActive := false ;
104186: LD_ADDR_EXP 159
104190: PUSH
104191: LD_INT 0
104193: ST_TO_ADDR
// normalCounter := 36 ;
104194: LD_ADDR_EXP 160
104198: PUSH
104199: LD_INT 36
104201: ST_TO_ADDR
// hardcoreCounter := 16 ;
104202: LD_ADDR_EXP 161
104206: PUSH
104207: LD_INT 16
104209: ST_TO_ADDR
// sRocket := false ;
104210: LD_ADDR_EXP 164
104214: PUSH
104215: LD_INT 0
104217: ST_TO_ADDR
// sSpeed := false ;
104218: LD_ADDR_EXP 163
104222: PUSH
104223: LD_INT 0
104225: ST_TO_ADDR
// sEngine := false ;
104226: LD_ADDR_EXP 165
104230: PUSH
104231: LD_INT 0
104233: ST_TO_ADDR
// sSpec := false ;
104234: LD_ADDR_EXP 162
104238: PUSH
104239: LD_INT 0
104241: ST_TO_ADDR
// sLevel := false ;
104242: LD_ADDR_EXP 166
104246: PUSH
104247: LD_INT 0
104249: ST_TO_ADDR
// sArmoury := false ;
104250: LD_ADDR_EXP 167
104254: PUSH
104255: LD_INT 0
104257: ST_TO_ADDR
// sRadar := false ;
104258: LD_ADDR_EXP 168
104262: PUSH
104263: LD_INT 0
104265: ST_TO_ADDR
// sBunker := false ;
104266: LD_ADDR_EXP 169
104270: PUSH
104271: LD_INT 0
104273: ST_TO_ADDR
// sHack := false ;
104274: LD_ADDR_EXP 170
104278: PUSH
104279: LD_INT 0
104281: ST_TO_ADDR
// sFire := false ;
104282: LD_ADDR_EXP 171
104286: PUSH
104287: LD_INT 0
104289: ST_TO_ADDR
// sRefresh := false ;
104290: LD_ADDR_EXP 172
104294: PUSH
104295: LD_INT 0
104297: ST_TO_ADDR
// sExp := false ;
104298: LD_ADDR_EXP 173
104302: PUSH
104303: LD_INT 0
104305: ST_TO_ADDR
// sDepot := false ;
104306: LD_ADDR_EXP 174
104310: PUSH
104311: LD_INT 0
104313: ST_TO_ADDR
// sFlag := false ;
104314: LD_ADDR_EXP 175
104318: PUSH
104319: LD_INT 0
104321: ST_TO_ADDR
// sKamikadze := false ;
104322: LD_ADDR_EXP 183
104326: PUSH
104327: LD_INT 0
104329: ST_TO_ADDR
// sTroll := false ;
104330: LD_ADDR_EXP 184
104334: PUSH
104335: LD_INT 0
104337: ST_TO_ADDR
// sSlow := false ;
104338: LD_ADDR_EXP 185
104342: PUSH
104343: LD_INT 0
104345: ST_TO_ADDR
// sLack := false ;
104346: LD_ADDR_EXP 186
104350: PUSH
104351: LD_INT 0
104353: ST_TO_ADDR
// sTank := false ;
104354: LD_ADDR_EXP 188
104358: PUSH
104359: LD_INT 0
104361: ST_TO_ADDR
// sRemote := false ;
104362: LD_ADDR_EXP 189
104366: PUSH
104367: LD_INT 0
104369: ST_TO_ADDR
// sPowell := false ;
104370: LD_ADDR_EXP 190
104374: PUSH
104375: LD_INT 0
104377: ST_TO_ADDR
// sTeleport := false ;
104378: LD_ADDR_EXP 193
104382: PUSH
104383: LD_INT 0
104385: ST_TO_ADDR
// sOilTower := false ;
104386: LD_ADDR_EXP 195
104390: PUSH
104391: LD_INT 0
104393: ST_TO_ADDR
// sShovel := false ;
104394: LD_ADDR_EXP 196
104398: PUSH
104399: LD_INT 0
104401: ST_TO_ADDR
// sSheik := false ;
104402: LD_ADDR_EXP 197
104406: PUSH
104407: LD_INT 0
104409: ST_TO_ADDR
// sEarthquake := false ;
104410: LD_ADDR_EXP 199
104414: PUSH
104415: LD_INT 0
104417: ST_TO_ADDR
// sAI := false ;
104418: LD_ADDR_EXP 200
104422: PUSH
104423: LD_INT 0
104425: ST_TO_ADDR
// sCargo := false ;
104426: LD_ADDR_EXP 203
104430: PUSH
104431: LD_INT 0
104433: ST_TO_ADDR
// sDLaser := false ;
104434: LD_ADDR_EXP 204
104438: PUSH
104439: LD_INT 0
104441: ST_TO_ADDR
// sExchange := false ;
104442: LD_ADDR_EXP 205
104446: PUSH
104447: LD_INT 0
104449: ST_TO_ADDR
// sFac := false ;
104450: LD_ADDR_EXP 206
104454: PUSH
104455: LD_INT 0
104457: ST_TO_ADDR
// sPower := false ;
104458: LD_ADDR_EXP 207
104462: PUSH
104463: LD_INT 0
104465: ST_TO_ADDR
// sRandom := false ;
104466: LD_ADDR_EXP 208
104470: PUSH
104471: LD_INT 0
104473: ST_TO_ADDR
// sShield := false ;
104474: LD_ADDR_EXP 209
104478: PUSH
104479: LD_INT 0
104481: ST_TO_ADDR
// sTime := false ;
104482: LD_ADDR_EXP 210
104486: PUSH
104487: LD_INT 0
104489: ST_TO_ADDR
// sTools := false ;
104490: LD_ADDR_EXP 211
104494: PUSH
104495: LD_INT 0
104497: ST_TO_ADDR
// sSold := false ;
104498: LD_ADDR_EXP 176
104502: PUSH
104503: LD_INT 0
104505: ST_TO_ADDR
// sDiff := false ;
104506: LD_ADDR_EXP 177
104510: PUSH
104511: LD_INT 0
104513: ST_TO_ADDR
// sFog := false ;
104514: LD_ADDR_EXP 180
104518: PUSH
104519: LD_INT 0
104521: ST_TO_ADDR
// sReset := false ;
104522: LD_ADDR_EXP 181
104526: PUSH
104527: LD_INT 0
104529: ST_TO_ADDR
// sSun := false ;
104530: LD_ADDR_EXP 182
104534: PUSH
104535: LD_INT 0
104537: ST_TO_ADDR
// sTiger := false ;
104538: LD_ADDR_EXP 178
104542: PUSH
104543: LD_INT 0
104545: ST_TO_ADDR
// sBomb := false ;
104546: LD_ADDR_EXP 179
104550: PUSH
104551: LD_INT 0
104553: ST_TO_ADDR
// sWound := false ;
104554: LD_ADDR_EXP 187
104558: PUSH
104559: LD_INT 0
104561: ST_TO_ADDR
// sBetray := false ;
104562: LD_ADDR_EXP 191
104566: PUSH
104567: LD_INT 0
104569: ST_TO_ADDR
// sContamin := false ;
104570: LD_ADDR_EXP 192
104574: PUSH
104575: LD_INT 0
104577: ST_TO_ADDR
// sOil := false ;
104578: LD_ADDR_EXP 194
104582: PUSH
104583: LD_INT 0
104585: ST_TO_ADDR
// sStu := false ;
104586: LD_ADDR_EXP 198
104590: PUSH
104591: LD_INT 0
104593: ST_TO_ADDR
// sBazooka := false ;
104594: LD_ADDR_EXP 201
104598: PUSH
104599: LD_INT 0
104601: ST_TO_ADDR
// sMortar := false ;
104602: LD_ADDR_EXP 202
104606: PUSH
104607: LD_INT 0
104609: ST_TO_ADDR
// sRanger := false ;
104610: LD_ADDR_EXP 212
104614: PUSH
104615: LD_INT 0
104617: ST_TO_ADDR
// end ;
104618: LD_VAR 0 1
104622: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
104623: LD_INT 0
104625: PPUSH
104626: PPUSH
104627: PPUSH
104628: PPUSH
104629: PPUSH
// result := [ ] ;
104630: LD_ADDR_VAR 0 1
104634: PUSH
104635: EMPTY
104636: ST_TO_ADDR
// if campaign_id = 1 then
104637: LD_OWVAR 69
104641: PUSH
104642: LD_INT 1
104644: EQUAL
104645: IFFALSE 107583
// begin case mission_number of 1 :
104647: LD_OWVAR 70
104651: PUSH
104652: LD_INT 1
104654: DOUBLE
104655: EQUAL
104656: IFTRUE 104660
104658: GO 104724
104660: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
104661: LD_ADDR_VAR 0 1
104665: PUSH
104666: LD_INT 2
104668: PUSH
104669: LD_INT 4
104671: PUSH
104672: LD_INT 11
104674: PUSH
104675: LD_INT 12
104677: PUSH
104678: LD_INT 15
104680: PUSH
104681: LD_INT 16
104683: PUSH
104684: LD_INT 22
104686: PUSH
104687: LD_INT 23
104689: PUSH
104690: LD_INT 26
104692: PUSH
104693: EMPTY
104694: LIST
104695: LIST
104696: LIST
104697: LIST
104698: LIST
104699: LIST
104700: LIST
104701: LIST
104702: LIST
104703: PUSH
104704: LD_INT 101
104706: PUSH
104707: LD_INT 102
104709: PUSH
104710: LD_INT 106
104712: PUSH
104713: EMPTY
104714: LIST
104715: LIST
104716: LIST
104717: PUSH
104718: EMPTY
104719: LIST
104720: LIST
104721: ST_TO_ADDR
104722: GO 107581
104724: LD_INT 2
104726: DOUBLE
104727: EQUAL
104728: IFTRUE 104732
104730: GO 104804
104732: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
104733: LD_ADDR_VAR 0 1
104737: PUSH
104738: LD_INT 2
104740: PUSH
104741: LD_INT 4
104743: PUSH
104744: LD_INT 11
104746: PUSH
104747: LD_INT 12
104749: PUSH
104750: LD_INT 15
104752: PUSH
104753: LD_INT 16
104755: PUSH
104756: LD_INT 22
104758: PUSH
104759: LD_INT 23
104761: PUSH
104762: LD_INT 26
104764: PUSH
104765: EMPTY
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: PUSH
104776: LD_INT 101
104778: PUSH
104779: LD_INT 102
104781: PUSH
104782: LD_INT 105
104784: PUSH
104785: LD_INT 106
104787: PUSH
104788: LD_INT 108
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: LIST
104795: LIST
104796: LIST
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: ST_TO_ADDR
104802: GO 107581
104804: LD_INT 3
104806: DOUBLE
104807: EQUAL
104808: IFTRUE 104812
104810: GO 104888
104812: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
104813: LD_ADDR_VAR 0 1
104817: PUSH
104818: LD_INT 2
104820: PUSH
104821: LD_INT 4
104823: PUSH
104824: LD_INT 5
104826: PUSH
104827: LD_INT 11
104829: PUSH
104830: LD_INT 12
104832: PUSH
104833: LD_INT 15
104835: PUSH
104836: LD_INT 16
104838: PUSH
104839: LD_INT 22
104841: PUSH
104842: LD_INT 26
104844: PUSH
104845: LD_INT 36
104847: PUSH
104848: EMPTY
104849: LIST
104850: LIST
104851: LIST
104852: LIST
104853: LIST
104854: LIST
104855: LIST
104856: LIST
104857: LIST
104858: LIST
104859: PUSH
104860: LD_INT 101
104862: PUSH
104863: LD_INT 102
104865: PUSH
104866: LD_INT 105
104868: PUSH
104869: LD_INT 106
104871: PUSH
104872: LD_INT 108
104874: PUSH
104875: EMPTY
104876: LIST
104877: LIST
104878: LIST
104879: LIST
104880: LIST
104881: PUSH
104882: EMPTY
104883: LIST
104884: LIST
104885: ST_TO_ADDR
104886: GO 107581
104888: LD_INT 4
104890: DOUBLE
104891: EQUAL
104892: IFTRUE 104896
104894: GO 104980
104896: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
104897: LD_ADDR_VAR 0 1
104901: PUSH
104902: LD_INT 2
104904: PUSH
104905: LD_INT 4
104907: PUSH
104908: LD_INT 5
104910: PUSH
104911: LD_INT 8
104913: PUSH
104914: LD_INT 11
104916: PUSH
104917: LD_INT 12
104919: PUSH
104920: LD_INT 15
104922: PUSH
104923: LD_INT 16
104925: PUSH
104926: LD_INT 22
104928: PUSH
104929: LD_INT 23
104931: PUSH
104932: LD_INT 26
104934: PUSH
104935: LD_INT 36
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: LIST
104942: LIST
104943: LIST
104944: LIST
104945: LIST
104946: LIST
104947: LIST
104948: LIST
104949: LIST
104950: LIST
104951: PUSH
104952: LD_INT 101
104954: PUSH
104955: LD_INT 102
104957: PUSH
104958: LD_INT 105
104960: PUSH
104961: LD_INT 106
104963: PUSH
104964: LD_INT 108
104966: PUSH
104967: EMPTY
104968: LIST
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: ST_TO_ADDR
104978: GO 107581
104980: LD_INT 5
104982: DOUBLE
104983: EQUAL
104984: IFTRUE 104988
104986: GO 105088
104988: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
104989: LD_ADDR_VAR 0 1
104993: PUSH
104994: LD_INT 2
104996: PUSH
104997: LD_INT 4
104999: PUSH
105000: LD_INT 5
105002: PUSH
105003: LD_INT 6
105005: PUSH
105006: LD_INT 8
105008: PUSH
105009: LD_INT 11
105011: PUSH
105012: LD_INT 12
105014: PUSH
105015: LD_INT 15
105017: PUSH
105018: LD_INT 16
105020: PUSH
105021: LD_INT 22
105023: PUSH
105024: LD_INT 23
105026: PUSH
105027: LD_INT 25
105029: PUSH
105030: LD_INT 26
105032: PUSH
105033: LD_INT 36
105035: PUSH
105036: EMPTY
105037: LIST
105038: LIST
105039: LIST
105040: LIST
105041: LIST
105042: LIST
105043: LIST
105044: LIST
105045: LIST
105046: LIST
105047: LIST
105048: LIST
105049: LIST
105050: LIST
105051: PUSH
105052: LD_INT 101
105054: PUSH
105055: LD_INT 102
105057: PUSH
105058: LD_INT 105
105060: PUSH
105061: LD_INT 106
105063: PUSH
105064: LD_INT 108
105066: PUSH
105067: LD_INT 109
105069: PUSH
105070: LD_INT 112
105072: PUSH
105073: EMPTY
105074: LIST
105075: LIST
105076: LIST
105077: LIST
105078: LIST
105079: LIST
105080: LIST
105081: PUSH
105082: EMPTY
105083: LIST
105084: LIST
105085: ST_TO_ADDR
105086: GO 107581
105088: LD_INT 6
105090: DOUBLE
105091: EQUAL
105092: IFTRUE 105096
105094: GO 105216
105096: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
105097: LD_ADDR_VAR 0 1
105101: PUSH
105102: LD_INT 2
105104: PUSH
105105: LD_INT 4
105107: PUSH
105108: LD_INT 5
105110: PUSH
105111: LD_INT 6
105113: PUSH
105114: LD_INT 8
105116: PUSH
105117: LD_INT 11
105119: PUSH
105120: LD_INT 12
105122: PUSH
105123: LD_INT 15
105125: PUSH
105126: LD_INT 16
105128: PUSH
105129: LD_INT 20
105131: PUSH
105132: LD_INT 21
105134: PUSH
105135: LD_INT 22
105137: PUSH
105138: LD_INT 23
105140: PUSH
105141: LD_INT 25
105143: PUSH
105144: LD_INT 26
105146: PUSH
105147: LD_INT 30
105149: PUSH
105150: LD_INT 31
105152: PUSH
105153: LD_INT 32
105155: PUSH
105156: LD_INT 36
105158: PUSH
105159: EMPTY
105160: LIST
105161: LIST
105162: LIST
105163: LIST
105164: LIST
105165: LIST
105166: LIST
105167: LIST
105168: LIST
105169: LIST
105170: LIST
105171: LIST
105172: LIST
105173: LIST
105174: LIST
105175: LIST
105176: LIST
105177: LIST
105178: LIST
105179: PUSH
105180: LD_INT 101
105182: PUSH
105183: LD_INT 102
105185: PUSH
105186: LD_INT 105
105188: PUSH
105189: LD_INT 106
105191: PUSH
105192: LD_INT 108
105194: PUSH
105195: LD_INT 109
105197: PUSH
105198: LD_INT 112
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: LIST
105205: LIST
105206: LIST
105207: LIST
105208: LIST
105209: PUSH
105210: EMPTY
105211: LIST
105212: LIST
105213: ST_TO_ADDR
105214: GO 107581
105216: LD_INT 7
105218: DOUBLE
105219: EQUAL
105220: IFTRUE 105224
105222: GO 105324
105224: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
105225: LD_ADDR_VAR 0 1
105229: PUSH
105230: LD_INT 2
105232: PUSH
105233: LD_INT 4
105235: PUSH
105236: LD_INT 5
105238: PUSH
105239: LD_INT 7
105241: PUSH
105242: LD_INT 11
105244: PUSH
105245: LD_INT 12
105247: PUSH
105248: LD_INT 15
105250: PUSH
105251: LD_INT 16
105253: PUSH
105254: LD_INT 20
105256: PUSH
105257: LD_INT 21
105259: PUSH
105260: LD_INT 22
105262: PUSH
105263: LD_INT 23
105265: PUSH
105266: LD_INT 25
105268: PUSH
105269: LD_INT 26
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: LIST
105276: LIST
105277: LIST
105278: LIST
105279: LIST
105280: LIST
105281: LIST
105282: LIST
105283: LIST
105284: LIST
105285: LIST
105286: LIST
105287: PUSH
105288: LD_INT 101
105290: PUSH
105291: LD_INT 102
105293: PUSH
105294: LD_INT 103
105296: PUSH
105297: LD_INT 105
105299: PUSH
105300: LD_INT 106
105302: PUSH
105303: LD_INT 108
105305: PUSH
105306: LD_INT 112
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: LIST
105313: LIST
105314: LIST
105315: LIST
105316: LIST
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: ST_TO_ADDR
105322: GO 107581
105324: LD_INT 8
105326: DOUBLE
105327: EQUAL
105328: IFTRUE 105332
105330: GO 105460
105332: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
105333: LD_ADDR_VAR 0 1
105337: PUSH
105338: LD_INT 2
105340: PUSH
105341: LD_INT 4
105343: PUSH
105344: LD_INT 5
105346: PUSH
105347: LD_INT 6
105349: PUSH
105350: LD_INT 7
105352: PUSH
105353: LD_INT 8
105355: PUSH
105356: LD_INT 11
105358: PUSH
105359: LD_INT 12
105361: PUSH
105362: LD_INT 15
105364: PUSH
105365: LD_INT 16
105367: PUSH
105368: LD_INT 20
105370: PUSH
105371: LD_INT 21
105373: PUSH
105374: LD_INT 22
105376: PUSH
105377: LD_INT 23
105379: PUSH
105380: LD_INT 25
105382: PUSH
105383: LD_INT 26
105385: PUSH
105386: LD_INT 30
105388: PUSH
105389: LD_INT 31
105391: PUSH
105392: LD_INT 32
105394: PUSH
105395: LD_INT 36
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: LIST
105402: LIST
105403: LIST
105404: LIST
105405: LIST
105406: LIST
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: LIST
105412: LIST
105413: LIST
105414: LIST
105415: LIST
105416: LIST
105417: LIST
105418: LIST
105419: PUSH
105420: LD_INT 101
105422: PUSH
105423: LD_INT 102
105425: PUSH
105426: LD_INT 103
105428: PUSH
105429: LD_INT 105
105431: PUSH
105432: LD_INT 106
105434: PUSH
105435: LD_INT 108
105437: PUSH
105438: LD_INT 109
105440: PUSH
105441: LD_INT 112
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: LIST
105448: LIST
105449: LIST
105450: LIST
105451: LIST
105452: LIST
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: ST_TO_ADDR
105458: GO 107581
105460: LD_INT 9
105462: DOUBLE
105463: EQUAL
105464: IFTRUE 105468
105466: GO 105604
105468: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
105469: LD_ADDR_VAR 0 1
105473: PUSH
105474: LD_INT 2
105476: PUSH
105477: LD_INT 4
105479: PUSH
105480: LD_INT 5
105482: PUSH
105483: LD_INT 6
105485: PUSH
105486: LD_INT 7
105488: PUSH
105489: LD_INT 8
105491: PUSH
105492: LD_INT 11
105494: PUSH
105495: LD_INT 12
105497: PUSH
105498: LD_INT 15
105500: PUSH
105501: LD_INT 16
105503: PUSH
105504: LD_INT 20
105506: PUSH
105507: LD_INT 21
105509: PUSH
105510: LD_INT 22
105512: PUSH
105513: LD_INT 23
105515: PUSH
105516: LD_INT 25
105518: PUSH
105519: LD_INT 26
105521: PUSH
105522: LD_INT 28
105524: PUSH
105525: LD_INT 30
105527: PUSH
105528: LD_INT 31
105530: PUSH
105531: LD_INT 32
105533: PUSH
105534: LD_INT 36
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: LIST
105541: LIST
105542: LIST
105543: LIST
105544: LIST
105545: LIST
105546: LIST
105547: LIST
105548: LIST
105549: LIST
105550: LIST
105551: LIST
105552: LIST
105553: LIST
105554: LIST
105555: LIST
105556: LIST
105557: LIST
105558: LIST
105559: PUSH
105560: LD_INT 101
105562: PUSH
105563: LD_INT 102
105565: PUSH
105566: LD_INT 103
105568: PUSH
105569: LD_INT 105
105571: PUSH
105572: LD_INT 106
105574: PUSH
105575: LD_INT 108
105577: PUSH
105578: LD_INT 109
105580: PUSH
105581: LD_INT 112
105583: PUSH
105584: LD_INT 114
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: LIST
105591: LIST
105592: LIST
105593: LIST
105594: LIST
105595: LIST
105596: LIST
105597: PUSH
105598: EMPTY
105599: LIST
105600: LIST
105601: ST_TO_ADDR
105602: GO 107581
105604: LD_INT 10
105606: DOUBLE
105607: EQUAL
105608: IFTRUE 105612
105610: GO 105796
105612: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
105613: LD_ADDR_VAR 0 1
105617: PUSH
105618: LD_INT 2
105620: PUSH
105621: LD_INT 4
105623: PUSH
105624: LD_INT 5
105626: PUSH
105627: LD_INT 6
105629: PUSH
105630: LD_INT 7
105632: PUSH
105633: LD_INT 8
105635: PUSH
105636: LD_INT 9
105638: PUSH
105639: LD_INT 10
105641: PUSH
105642: LD_INT 11
105644: PUSH
105645: LD_INT 12
105647: PUSH
105648: LD_INT 13
105650: PUSH
105651: LD_INT 14
105653: PUSH
105654: LD_INT 15
105656: PUSH
105657: LD_INT 16
105659: PUSH
105660: LD_INT 17
105662: PUSH
105663: LD_INT 18
105665: PUSH
105666: LD_INT 19
105668: PUSH
105669: LD_INT 20
105671: PUSH
105672: LD_INT 21
105674: PUSH
105675: LD_INT 22
105677: PUSH
105678: LD_INT 23
105680: PUSH
105681: LD_INT 24
105683: PUSH
105684: LD_INT 25
105686: PUSH
105687: LD_INT 26
105689: PUSH
105690: LD_INT 28
105692: PUSH
105693: LD_INT 30
105695: PUSH
105696: LD_INT 31
105698: PUSH
105699: LD_INT 32
105701: PUSH
105702: LD_INT 36
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: LIST
105709: LIST
105710: LIST
105711: LIST
105712: LIST
105713: LIST
105714: LIST
105715: LIST
105716: LIST
105717: LIST
105718: LIST
105719: LIST
105720: LIST
105721: LIST
105722: LIST
105723: LIST
105724: LIST
105725: LIST
105726: LIST
105727: LIST
105728: LIST
105729: LIST
105730: LIST
105731: LIST
105732: LIST
105733: LIST
105734: LIST
105735: PUSH
105736: LD_INT 101
105738: PUSH
105739: LD_INT 102
105741: PUSH
105742: LD_INT 103
105744: PUSH
105745: LD_INT 104
105747: PUSH
105748: LD_INT 105
105750: PUSH
105751: LD_INT 106
105753: PUSH
105754: LD_INT 107
105756: PUSH
105757: LD_INT 108
105759: PUSH
105760: LD_INT 109
105762: PUSH
105763: LD_INT 110
105765: PUSH
105766: LD_INT 111
105768: PUSH
105769: LD_INT 112
105771: PUSH
105772: LD_INT 114
105774: PUSH
105775: EMPTY
105776: LIST
105777: LIST
105778: LIST
105779: LIST
105780: LIST
105781: LIST
105782: LIST
105783: LIST
105784: LIST
105785: LIST
105786: LIST
105787: LIST
105788: LIST
105789: PUSH
105790: EMPTY
105791: LIST
105792: LIST
105793: ST_TO_ADDR
105794: GO 107581
105796: LD_INT 11
105798: DOUBLE
105799: EQUAL
105800: IFTRUE 105804
105802: GO 105996
105804: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
105805: LD_ADDR_VAR 0 1
105809: PUSH
105810: LD_INT 2
105812: PUSH
105813: LD_INT 3
105815: PUSH
105816: LD_INT 4
105818: PUSH
105819: LD_INT 5
105821: PUSH
105822: LD_INT 6
105824: PUSH
105825: LD_INT 7
105827: PUSH
105828: LD_INT 8
105830: PUSH
105831: LD_INT 9
105833: PUSH
105834: LD_INT 10
105836: PUSH
105837: LD_INT 11
105839: PUSH
105840: LD_INT 12
105842: PUSH
105843: LD_INT 13
105845: PUSH
105846: LD_INT 14
105848: PUSH
105849: LD_INT 15
105851: PUSH
105852: LD_INT 16
105854: PUSH
105855: LD_INT 17
105857: PUSH
105858: LD_INT 18
105860: PUSH
105861: LD_INT 19
105863: PUSH
105864: LD_INT 20
105866: PUSH
105867: LD_INT 21
105869: PUSH
105870: LD_INT 22
105872: PUSH
105873: LD_INT 23
105875: PUSH
105876: LD_INT 24
105878: PUSH
105879: LD_INT 25
105881: PUSH
105882: LD_INT 26
105884: PUSH
105885: LD_INT 28
105887: PUSH
105888: LD_INT 30
105890: PUSH
105891: LD_INT 31
105893: PUSH
105894: LD_INT 32
105896: PUSH
105897: LD_INT 34
105899: PUSH
105900: LD_INT 36
105902: PUSH
105903: EMPTY
105904: LIST
105905: LIST
105906: LIST
105907: LIST
105908: LIST
105909: LIST
105910: LIST
105911: LIST
105912: LIST
105913: LIST
105914: LIST
105915: LIST
105916: LIST
105917: LIST
105918: LIST
105919: LIST
105920: LIST
105921: LIST
105922: LIST
105923: LIST
105924: LIST
105925: LIST
105926: LIST
105927: LIST
105928: LIST
105929: LIST
105930: LIST
105931: LIST
105932: LIST
105933: LIST
105934: LIST
105935: PUSH
105936: LD_INT 101
105938: PUSH
105939: LD_INT 102
105941: PUSH
105942: LD_INT 103
105944: PUSH
105945: LD_INT 104
105947: PUSH
105948: LD_INT 105
105950: PUSH
105951: LD_INT 106
105953: PUSH
105954: LD_INT 107
105956: PUSH
105957: LD_INT 108
105959: PUSH
105960: LD_INT 109
105962: PUSH
105963: LD_INT 110
105965: PUSH
105966: LD_INT 111
105968: PUSH
105969: LD_INT 112
105971: PUSH
105972: LD_INT 114
105974: PUSH
105975: EMPTY
105976: LIST
105977: LIST
105978: LIST
105979: LIST
105980: LIST
105981: LIST
105982: LIST
105983: LIST
105984: LIST
105985: LIST
105986: LIST
105987: LIST
105988: LIST
105989: PUSH
105990: EMPTY
105991: LIST
105992: LIST
105993: ST_TO_ADDR
105994: GO 107581
105996: LD_INT 12
105998: DOUBLE
105999: EQUAL
106000: IFTRUE 106004
106002: GO 106212
106004: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
106005: LD_ADDR_VAR 0 1
106009: PUSH
106010: LD_INT 1
106012: PUSH
106013: LD_INT 2
106015: PUSH
106016: LD_INT 3
106018: PUSH
106019: LD_INT 4
106021: PUSH
106022: LD_INT 5
106024: PUSH
106025: LD_INT 6
106027: PUSH
106028: LD_INT 7
106030: PUSH
106031: LD_INT 8
106033: PUSH
106034: LD_INT 9
106036: PUSH
106037: LD_INT 10
106039: PUSH
106040: LD_INT 11
106042: PUSH
106043: LD_INT 12
106045: PUSH
106046: LD_INT 13
106048: PUSH
106049: LD_INT 14
106051: PUSH
106052: LD_INT 15
106054: PUSH
106055: LD_INT 16
106057: PUSH
106058: LD_INT 17
106060: PUSH
106061: LD_INT 18
106063: PUSH
106064: LD_INT 19
106066: PUSH
106067: LD_INT 20
106069: PUSH
106070: LD_INT 21
106072: PUSH
106073: LD_INT 22
106075: PUSH
106076: LD_INT 23
106078: PUSH
106079: LD_INT 24
106081: PUSH
106082: LD_INT 25
106084: PUSH
106085: LD_INT 26
106087: PUSH
106088: LD_INT 27
106090: PUSH
106091: LD_INT 28
106093: PUSH
106094: LD_INT 30
106096: PUSH
106097: LD_INT 31
106099: PUSH
106100: LD_INT 32
106102: PUSH
106103: LD_INT 33
106105: PUSH
106106: LD_INT 34
106108: PUSH
106109: LD_INT 36
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: LIST
106116: LIST
106117: LIST
106118: LIST
106119: LIST
106120: LIST
106121: LIST
106122: LIST
106123: LIST
106124: LIST
106125: LIST
106126: LIST
106127: LIST
106128: LIST
106129: LIST
106130: LIST
106131: LIST
106132: LIST
106133: LIST
106134: LIST
106135: LIST
106136: LIST
106137: LIST
106138: LIST
106139: LIST
106140: LIST
106141: LIST
106142: LIST
106143: LIST
106144: LIST
106145: LIST
106146: LIST
106147: PUSH
106148: LD_INT 101
106150: PUSH
106151: LD_INT 102
106153: PUSH
106154: LD_INT 103
106156: PUSH
106157: LD_INT 104
106159: PUSH
106160: LD_INT 105
106162: PUSH
106163: LD_INT 106
106165: PUSH
106166: LD_INT 107
106168: PUSH
106169: LD_INT 108
106171: PUSH
106172: LD_INT 109
106174: PUSH
106175: LD_INT 110
106177: PUSH
106178: LD_INT 111
106180: PUSH
106181: LD_INT 112
106183: PUSH
106184: LD_INT 113
106186: PUSH
106187: LD_INT 114
106189: PUSH
106190: EMPTY
106191: LIST
106192: LIST
106193: LIST
106194: LIST
106195: LIST
106196: LIST
106197: LIST
106198: LIST
106199: LIST
106200: LIST
106201: LIST
106202: LIST
106203: LIST
106204: LIST
106205: PUSH
106206: EMPTY
106207: LIST
106208: LIST
106209: ST_TO_ADDR
106210: GO 107581
106212: LD_INT 13
106214: DOUBLE
106215: EQUAL
106216: IFTRUE 106220
106218: GO 106416
106220: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
106221: LD_ADDR_VAR 0 1
106225: PUSH
106226: LD_INT 1
106228: PUSH
106229: LD_INT 2
106231: PUSH
106232: LD_INT 3
106234: PUSH
106235: LD_INT 4
106237: PUSH
106238: LD_INT 5
106240: PUSH
106241: LD_INT 8
106243: PUSH
106244: LD_INT 9
106246: PUSH
106247: LD_INT 10
106249: PUSH
106250: LD_INT 11
106252: PUSH
106253: LD_INT 12
106255: PUSH
106256: LD_INT 14
106258: PUSH
106259: LD_INT 15
106261: PUSH
106262: LD_INT 16
106264: PUSH
106265: LD_INT 17
106267: PUSH
106268: LD_INT 18
106270: PUSH
106271: LD_INT 19
106273: PUSH
106274: LD_INT 20
106276: PUSH
106277: LD_INT 21
106279: PUSH
106280: LD_INT 22
106282: PUSH
106283: LD_INT 23
106285: PUSH
106286: LD_INT 24
106288: PUSH
106289: LD_INT 25
106291: PUSH
106292: LD_INT 26
106294: PUSH
106295: LD_INT 27
106297: PUSH
106298: LD_INT 28
106300: PUSH
106301: LD_INT 30
106303: PUSH
106304: LD_INT 31
106306: PUSH
106307: LD_INT 32
106309: PUSH
106310: LD_INT 33
106312: PUSH
106313: LD_INT 34
106315: PUSH
106316: LD_INT 36
106318: PUSH
106319: EMPTY
106320: LIST
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: LIST
106327: LIST
106328: LIST
106329: LIST
106330: LIST
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: LIST
106336: LIST
106337: LIST
106338: LIST
106339: LIST
106340: LIST
106341: LIST
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: LIST
106347: LIST
106348: LIST
106349: LIST
106350: LIST
106351: PUSH
106352: LD_INT 101
106354: PUSH
106355: LD_INT 102
106357: PUSH
106358: LD_INT 103
106360: PUSH
106361: LD_INT 104
106363: PUSH
106364: LD_INT 105
106366: PUSH
106367: LD_INT 106
106369: PUSH
106370: LD_INT 107
106372: PUSH
106373: LD_INT 108
106375: PUSH
106376: LD_INT 109
106378: PUSH
106379: LD_INT 110
106381: PUSH
106382: LD_INT 111
106384: PUSH
106385: LD_INT 112
106387: PUSH
106388: LD_INT 113
106390: PUSH
106391: LD_INT 114
106393: PUSH
106394: EMPTY
106395: LIST
106396: LIST
106397: LIST
106398: LIST
106399: LIST
106400: LIST
106401: LIST
106402: LIST
106403: LIST
106404: LIST
106405: LIST
106406: LIST
106407: LIST
106408: LIST
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: ST_TO_ADDR
106414: GO 107581
106416: LD_INT 14
106418: DOUBLE
106419: EQUAL
106420: IFTRUE 106424
106422: GO 106636
106424: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
106425: LD_ADDR_VAR 0 1
106429: PUSH
106430: LD_INT 1
106432: PUSH
106433: LD_INT 2
106435: PUSH
106436: LD_INT 3
106438: PUSH
106439: LD_INT 4
106441: PUSH
106442: LD_INT 5
106444: PUSH
106445: LD_INT 6
106447: PUSH
106448: LD_INT 7
106450: PUSH
106451: LD_INT 8
106453: PUSH
106454: LD_INT 9
106456: PUSH
106457: LD_INT 10
106459: PUSH
106460: LD_INT 11
106462: PUSH
106463: LD_INT 12
106465: PUSH
106466: LD_INT 13
106468: PUSH
106469: LD_INT 14
106471: PUSH
106472: LD_INT 15
106474: PUSH
106475: LD_INT 16
106477: PUSH
106478: LD_INT 17
106480: PUSH
106481: LD_INT 18
106483: PUSH
106484: LD_INT 19
106486: PUSH
106487: LD_INT 20
106489: PUSH
106490: LD_INT 21
106492: PUSH
106493: LD_INT 22
106495: PUSH
106496: LD_INT 23
106498: PUSH
106499: LD_INT 24
106501: PUSH
106502: LD_INT 25
106504: PUSH
106505: LD_INT 26
106507: PUSH
106508: LD_INT 27
106510: PUSH
106511: LD_INT 28
106513: PUSH
106514: LD_INT 29
106516: PUSH
106517: LD_INT 30
106519: PUSH
106520: LD_INT 31
106522: PUSH
106523: LD_INT 32
106525: PUSH
106526: LD_INT 33
106528: PUSH
106529: LD_INT 34
106531: PUSH
106532: LD_INT 36
106534: PUSH
106535: EMPTY
106536: LIST
106537: LIST
106538: LIST
106539: LIST
106540: LIST
106541: LIST
106542: LIST
106543: LIST
106544: LIST
106545: LIST
106546: LIST
106547: LIST
106548: LIST
106549: LIST
106550: LIST
106551: LIST
106552: LIST
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: LIST
106558: LIST
106559: LIST
106560: LIST
106561: LIST
106562: LIST
106563: LIST
106564: LIST
106565: LIST
106566: LIST
106567: LIST
106568: LIST
106569: LIST
106570: LIST
106571: PUSH
106572: LD_INT 101
106574: PUSH
106575: LD_INT 102
106577: PUSH
106578: LD_INT 103
106580: PUSH
106581: LD_INT 104
106583: PUSH
106584: LD_INT 105
106586: PUSH
106587: LD_INT 106
106589: PUSH
106590: LD_INT 107
106592: PUSH
106593: LD_INT 108
106595: PUSH
106596: LD_INT 109
106598: PUSH
106599: LD_INT 110
106601: PUSH
106602: LD_INT 111
106604: PUSH
106605: LD_INT 112
106607: PUSH
106608: LD_INT 113
106610: PUSH
106611: LD_INT 114
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: LIST
106618: LIST
106619: LIST
106620: LIST
106621: LIST
106622: LIST
106623: LIST
106624: LIST
106625: LIST
106626: LIST
106627: LIST
106628: LIST
106629: PUSH
106630: EMPTY
106631: LIST
106632: LIST
106633: ST_TO_ADDR
106634: GO 107581
106636: LD_INT 15
106638: DOUBLE
106639: EQUAL
106640: IFTRUE 106644
106642: GO 106856
106644: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
106645: LD_ADDR_VAR 0 1
106649: PUSH
106650: LD_INT 1
106652: PUSH
106653: LD_INT 2
106655: PUSH
106656: LD_INT 3
106658: PUSH
106659: LD_INT 4
106661: PUSH
106662: LD_INT 5
106664: PUSH
106665: LD_INT 6
106667: PUSH
106668: LD_INT 7
106670: PUSH
106671: LD_INT 8
106673: PUSH
106674: LD_INT 9
106676: PUSH
106677: LD_INT 10
106679: PUSH
106680: LD_INT 11
106682: PUSH
106683: LD_INT 12
106685: PUSH
106686: LD_INT 13
106688: PUSH
106689: LD_INT 14
106691: PUSH
106692: LD_INT 15
106694: PUSH
106695: LD_INT 16
106697: PUSH
106698: LD_INT 17
106700: PUSH
106701: LD_INT 18
106703: PUSH
106704: LD_INT 19
106706: PUSH
106707: LD_INT 20
106709: PUSH
106710: LD_INT 21
106712: PUSH
106713: LD_INT 22
106715: PUSH
106716: LD_INT 23
106718: PUSH
106719: LD_INT 24
106721: PUSH
106722: LD_INT 25
106724: PUSH
106725: LD_INT 26
106727: PUSH
106728: LD_INT 27
106730: PUSH
106731: LD_INT 28
106733: PUSH
106734: LD_INT 29
106736: PUSH
106737: LD_INT 30
106739: PUSH
106740: LD_INT 31
106742: PUSH
106743: LD_INT 32
106745: PUSH
106746: LD_INT 33
106748: PUSH
106749: LD_INT 34
106751: PUSH
106752: LD_INT 36
106754: PUSH
106755: EMPTY
106756: LIST
106757: LIST
106758: LIST
106759: LIST
106760: LIST
106761: LIST
106762: LIST
106763: LIST
106764: LIST
106765: LIST
106766: LIST
106767: LIST
106768: LIST
106769: LIST
106770: LIST
106771: LIST
106772: LIST
106773: LIST
106774: LIST
106775: LIST
106776: LIST
106777: LIST
106778: LIST
106779: LIST
106780: LIST
106781: LIST
106782: LIST
106783: LIST
106784: LIST
106785: LIST
106786: LIST
106787: LIST
106788: LIST
106789: LIST
106790: LIST
106791: PUSH
106792: LD_INT 101
106794: PUSH
106795: LD_INT 102
106797: PUSH
106798: LD_INT 103
106800: PUSH
106801: LD_INT 104
106803: PUSH
106804: LD_INT 105
106806: PUSH
106807: LD_INT 106
106809: PUSH
106810: LD_INT 107
106812: PUSH
106813: LD_INT 108
106815: PUSH
106816: LD_INT 109
106818: PUSH
106819: LD_INT 110
106821: PUSH
106822: LD_INT 111
106824: PUSH
106825: LD_INT 112
106827: PUSH
106828: LD_INT 113
106830: PUSH
106831: LD_INT 114
106833: PUSH
106834: EMPTY
106835: LIST
106836: LIST
106837: LIST
106838: LIST
106839: LIST
106840: LIST
106841: LIST
106842: LIST
106843: LIST
106844: LIST
106845: LIST
106846: LIST
106847: LIST
106848: LIST
106849: PUSH
106850: EMPTY
106851: LIST
106852: LIST
106853: ST_TO_ADDR
106854: GO 107581
106856: LD_INT 16
106858: DOUBLE
106859: EQUAL
106860: IFTRUE 106864
106862: GO 106988
106864: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
106865: LD_ADDR_VAR 0 1
106869: PUSH
106870: LD_INT 2
106872: PUSH
106873: LD_INT 4
106875: PUSH
106876: LD_INT 5
106878: PUSH
106879: LD_INT 7
106881: PUSH
106882: LD_INT 11
106884: PUSH
106885: LD_INT 12
106887: PUSH
106888: LD_INT 15
106890: PUSH
106891: LD_INT 16
106893: PUSH
106894: LD_INT 20
106896: PUSH
106897: LD_INT 21
106899: PUSH
106900: LD_INT 22
106902: PUSH
106903: LD_INT 23
106905: PUSH
106906: LD_INT 25
106908: PUSH
106909: LD_INT 26
106911: PUSH
106912: LD_INT 30
106914: PUSH
106915: LD_INT 31
106917: PUSH
106918: LD_INT 32
106920: PUSH
106921: LD_INT 33
106923: PUSH
106924: LD_INT 34
106926: PUSH
106927: EMPTY
106928: LIST
106929: LIST
106930: LIST
106931: LIST
106932: LIST
106933: LIST
106934: LIST
106935: LIST
106936: LIST
106937: LIST
106938: LIST
106939: LIST
106940: LIST
106941: LIST
106942: LIST
106943: LIST
106944: LIST
106945: LIST
106946: LIST
106947: PUSH
106948: LD_INT 101
106950: PUSH
106951: LD_INT 102
106953: PUSH
106954: LD_INT 103
106956: PUSH
106957: LD_INT 106
106959: PUSH
106960: LD_INT 108
106962: PUSH
106963: LD_INT 112
106965: PUSH
106966: LD_INT 113
106968: PUSH
106969: LD_INT 114
106971: PUSH
106972: EMPTY
106973: LIST
106974: LIST
106975: LIST
106976: LIST
106977: LIST
106978: LIST
106979: LIST
106980: LIST
106981: PUSH
106982: EMPTY
106983: LIST
106984: LIST
106985: ST_TO_ADDR
106986: GO 107581
106988: LD_INT 17
106990: DOUBLE
106991: EQUAL
106992: IFTRUE 106996
106994: GO 107208
106996: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
106997: LD_ADDR_VAR 0 1
107001: PUSH
107002: LD_INT 1
107004: PUSH
107005: LD_INT 2
107007: PUSH
107008: LD_INT 3
107010: PUSH
107011: LD_INT 4
107013: PUSH
107014: LD_INT 5
107016: PUSH
107017: LD_INT 6
107019: PUSH
107020: LD_INT 7
107022: PUSH
107023: LD_INT 8
107025: PUSH
107026: LD_INT 9
107028: PUSH
107029: LD_INT 10
107031: PUSH
107032: LD_INT 11
107034: PUSH
107035: LD_INT 12
107037: PUSH
107038: LD_INT 13
107040: PUSH
107041: LD_INT 14
107043: PUSH
107044: LD_INT 15
107046: PUSH
107047: LD_INT 16
107049: PUSH
107050: LD_INT 17
107052: PUSH
107053: LD_INT 18
107055: PUSH
107056: LD_INT 19
107058: PUSH
107059: LD_INT 20
107061: PUSH
107062: LD_INT 21
107064: PUSH
107065: LD_INT 22
107067: PUSH
107068: LD_INT 23
107070: PUSH
107071: LD_INT 24
107073: PUSH
107074: LD_INT 25
107076: PUSH
107077: LD_INT 26
107079: PUSH
107080: LD_INT 27
107082: PUSH
107083: LD_INT 28
107085: PUSH
107086: LD_INT 29
107088: PUSH
107089: LD_INT 30
107091: PUSH
107092: LD_INT 31
107094: PUSH
107095: LD_INT 32
107097: PUSH
107098: LD_INT 33
107100: PUSH
107101: LD_INT 34
107103: PUSH
107104: LD_INT 36
107106: PUSH
107107: EMPTY
107108: LIST
107109: LIST
107110: LIST
107111: LIST
107112: LIST
107113: LIST
107114: LIST
107115: LIST
107116: LIST
107117: LIST
107118: LIST
107119: LIST
107120: LIST
107121: LIST
107122: LIST
107123: LIST
107124: LIST
107125: LIST
107126: LIST
107127: LIST
107128: LIST
107129: LIST
107130: LIST
107131: LIST
107132: LIST
107133: LIST
107134: LIST
107135: LIST
107136: LIST
107137: LIST
107138: LIST
107139: LIST
107140: LIST
107141: LIST
107142: LIST
107143: PUSH
107144: LD_INT 101
107146: PUSH
107147: LD_INT 102
107149: PUSH
107150: LD_INT 103
107152: PUSH
107153: LD_INT 104
107155: PUSH
107156: LD_INT 105
107158: PUSH
107159: LD_INT 106
107161: PUSH
107162: LD_INT 107
107164: PUSH
107165: LD_INT 108
107167: PUSH
107168: LD_INT 109
107170: PUSH
107171: LD_INT 110
107173: PUSH
107174: LD_INT 111
107176: PUSH
107177: LD_INT 112
107179: PUSH
107180: LD_INT 113
107182: PUSH
107183: LD_INT 114
107185: PUSH
107186: EMPTY
107187: LIST
107188: LIST
107189: LIST
107190: LIST
107191: LIST
107192: LIST
107193: LIST
107194: LIST
107195: LIST
107196: LIST
107197: LIST
107198: LIST
107199: LIST
107200: LIST
107201: PUSH
107202: EMPTY
107203: LIST
107204: LIST
107205: ST_TO_ADDR
107206: GO 107581
107208: LD_INT 18
107210: DOUBLE
107211: EQUAL
107212: IFTRUE 107216
107214: GO 107352
107216: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
107217: LD_ADDR_VAR 0 1
107221: PUSH
107222: LD_INT 2
107224: PUSH
107225: LD_INT 4
107227: PUSH
107228: LD_INT 5
107230: PUSH
107231: LD_INT 7
107233: PUSH
107234: LD_INT 11
107236: PUSH
107237: LD_INT 12
107239: PUSH
107240: LD_INT 15
107242: PUSH
107243: LD_INT 16
107245: PUSH
107246: LD_INT 20
107248: PUSH
107249: LD_INT 21
107251: PUSH
107252: LD_INT 22
107254: PUSH
107255: LD_INT 23
107257: PUSH
107258: LD_INT 25
107260: PUSH
107261: LD_INT 26
107263: PUSH
107264: LD_INT 30
107266: PUSH
107267: LD_INT 31
107269: PUSH
107270: LD_INT 32
107272: PUSH
107273: LD_INT 33
107275: PUSH
107276: LD_INT 34
107278: PUSH
107279: LD_INT 35
107281: PUSH
107282: LD_INT 36
107284: PUSH
107285: EMPTY
107286: LIST
107287: LIST
107288: LIST
107289: LIST
107290: LIST
107291: LIST
107292: LIST
107293: LIST
107294: LIST
107295: LIST
107296: LIST
107297: LIST
107298: LIST
107299: LIST
107300: LIST
107301: LIST
107302: LIST
107303: LIST
107304: LIST
107305: LIST
107306: LIST
107307: PUSH
107308: LD_INT 101
107310: PUSH
107311: LD_INT 102
107313: PUSH
107314: LD_INT 103
107316: PUSH
107317: LD_INT 106
107319: PUSH
107320: LD_INT 108
107322: PUSH
107323: LD_INT 112
107325: PUSH
107326: LD_INT 113
107328: PUSH
107329: LD_INT 114
107331: PUSH
107332: LD_INT 115
107334: PUSH
107335: EMPTY
107336: LIST
107337: LIST
107338: LIST
107339: LIST
107340: LIST
107341: LIST
107342: LIST
107343: LIST
107344: LIST
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: ST_TO_ADDR
107350: GO 107581
107352: LD_INT 19
107354: DOUBLE
107355: EQUAL
107356: IFTRUE 107360
107358: GO 107580
107360: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
107361: LD_ADDR_VAR 0 1
107365: PUSH
107366: LD_INT 1
107368: PUSH
107369: LD_INT 2
107371: PUSH
107372: LD_INT 3
107374: PUSH
107375: LD_INT 4
107377: PUSH
107378: LD_INT 5
107380: PUSH
107381: LD_INT 6
107383: PUSH
107384: LD_INT 7
107386: PUSH
107387: LD_INT 8
107389: PUSH
107390: LD_INT 9
107392: PUSH
107393: LD_INT 10
107395: PUSH
107396: LD_INT 11
107398: PUSH
107399: LD_INT 12
107401: PUSH
107402: LD_INT 13
107404: PUSH
107405: LD_INT 14
107407: PUSH
107408: LD_INT 15
107410: PUSH
107411: LD_INT 16
107413: PUSH
107414: LD_INT 17
107416: PUSH
107417: LD_INT 18
107419: PUSH
107420: LD_INT 19
107422: PUSH
107423: LD_INT 20
107425: PUSH
107426: LD_INT 21
107428: PUSH
107429: LD_INT 22
107431: PUSH
107432: LD_INT 23
107434: PUSH
107435: LD_INT 24
107437: PUSH
107438: LD_INT 25
107440: PUSH
107441: LD_INT 26
107443: PUSH
107444: LD_INT 27
107446: PUSH
107447: LD_INT 28
107449: PUSH
107450: LD_INT 29
107452: PUSH
107453: LD_INT 30
107455: PUSH
107456: LD_INT 31
107458: PUSH
107459: LD_INT 32
107461: PUSH
107462: LD_INT 33
107464: PUSH
107465: LD_INT 34
107467: PUSH
107468: LD_INT 35
107470: PUSH
107471: LD_INT 36
107473: PUSH
107474: EMPTY
107475: LIST
107476: LIST
107477: LIST
107478: LIST
107479: LIST
107480: LIST
107481: LIST
107482: LIST
107483: LIST
107484: LIST
107485: LIST
107486: LIST
107487: LIST
107488: LIST
107489: LIST
107490: LIST
107491: LIST
107492: LIST
107493: LIST
107494: LIST
107495: LIST
107496: LIST
107497: LIST
107498: LIST
107499: LIST
107500: LIST
107501: LIST
107502: LIST
107503: LIST
107504: LIST
107505: LIST
107506: LIST
107507: LIST
107508: LIST
107509: LIST
107510: LIST
107511: PUSH
107512: LD_INT 101
107514: PUSH
107515: LD_INT 102
107517: PUSH
107518: LD_INT 103
107520: PUSH
107521: LD_INT 104
107523: PUSH
107524: LD_INT 105
107526: PUSH
107527: LD_INT 106
107529: PUSH
107530: LD_INT 107
107532: PUSH
107533: LD_INT 108
107535: PUSH
107536: LD_INT 109
107538: PUSH
107539: LD_INT 110
107541: PUSH
107542: LD_INT 111
107544: PUSH
107545: LD_INT 112
107547: PUSH
107548: LD_INT 113
107550: PUSH
107551: LD_INT 114
107553: PUSH
107554: LD_INT 115
107556: PUSH
107557: EMPTY
107558: LIST
107559: LIST
107560: LIST
107561: LIST
107562: LIST
107563: LIST
107564: LIST
107565: LIST
107566: LIST
107567: LIST
107568: LIST
107569: LIST
107570: LIST
107571: LIST
107572: LIST
107573: PUSH
107574: EMPTY
107575: LIST
107576: LIST
107577: ST_TO_ADDR
107578: GO 107581
107580: POP
// end else
107581: GO 107800
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
107583: LD_ADDR_VAR 0 1
107587: PUSH
107588: LD_INT 1
107590: PUSH
107591: LD_INT 2
107593: PUSH
107594: LD_INT 3
107596: PUSH
107597: LD_INT 4
107599: PUSH
107600: LD_INT 5
107602: PUSH
107603: LD_INT 6
107605: PUSH
107606: LD_INT 7
107608: PUSH
107609: LD_INT 8
107611: PUSH
107612: LD_INT 9
107614: PUSH
107615: LD_INT 10
107617: PUSH
107618: LD_INT 11
107620: PUSH
107621: LD_INT 12
107623: PUSH
107624: LD_INT 13
107626: PUSH
107627: LD_INT 14
107629: PUSH
107630: LD_INT 15
107632: PUSH
107633: LD_INT 16
107635: PUSH
107636: LD_INT 17
107638: PUSH
107639: LD_INT 18
107641: PUSH
107642: LD_INT 19
107644: PUSH
107645: LD_INT 20
107647: PUSH
107648: LD_INT 21
107650: PUSH
107651: LD_INT 22
107653: PUSH
107654: LD_INT 23
107656: PUSH
107657: LD_INT 24
107659: PUSH
107660: LD_INT 25
107662: PUSH
107663: LD_INT 26
107665: PUSH
107666: LD_INT 27
107668: PUSH
107669: LD_INT 28
107671: PUSH
107672: LD_INT 29
107674: PUSH
107675: LD_INT 30
107677: PUSH
107678: LD_INT 31
107680: PUSH
107681: LD_INT 32
107683: PUSH
107684: LD_INT 33
107686: PUSH
107687: LD_INT 34
107689: PUSH
107690: LD_INT 35
107692: PUSH
107693: LD_INT 36
107695: PUSH
107696: EMPTY
107697: LIST
107698: LIST
107699: LIST
107700: LIST
107701: LIST
107702: LIST
107703: LIST
107704: LIST
107705: LIST
107706: LIST
107707: LIST
107708: LIST
107709: LIST
107710: LIST
107711: LIST
107712: LIST
107713: LIST
107714: LIST
107715: LIST
107716: LIST
107717: LIST
107718: LIST
107719: LIST
107720: LIST
107721: LIST
107722: LIST
107723: LIST
107724: LIST
107725: LIST
107726: LIST
107727: LIST
107728: LIST
107729: LIST
107730: LIST
107731: LIST
107732: LIST
107733: PUSH
107734: LD_INT 101
107736: PUSH
107737: LD_INT 102
107739: PUSH
107740: LD_INT 103
107742: PUSH
107743: LD_INT 104
107745: PUSH
107746: LD_INT 105
107748: PUSH
107749: LD_INT 106
107751: PUSH
107752: LD_INT 107
107754: PUSH
107755: LD_INT 108
107757: PUSH
107758: LD_INT 109
107760: PUSH
107761: LD_INT 110
107763: PUSH
107764: LD_INT 111
107766: PUSH
107767: LD_INT 112
107769: PUSH
107770: LD_INT 113
107772: PUSH
107773: LD_INT 114
107775: PUSH
107776: LD_INT 115
107778: PUSH
107779: EMPTY
107780: LIST
107781: LIST
107782: LIST
107783: LIST
107784: LIST
107785: LIST
107786: LIST
107787: LIST
107788: LIST
107789: LIST
107790: LIST
107791: LIST
107792: LIST
107793: LIST
107794: LIST
107795: PUSH
107796: EMPTY
107797: LIST
107798: LIST
107799: ST_TO_ADDR
// if result then
107800: LD_VAR 0 1
107804: IFFALSE 108093
// begin normal :=  ;
107806: LD_ADDR_VAR 0 3
107810: PUSH
107811: LD_STRING 
107813: ST_TO_ADDR
// hardcore :=  ;
107814: LD_ADDR_VAR 0 4
107818: PUSH
107819: LD_STRING 
107821: ST_TO_ADDR
// for i = 1 to normalCounter do
107822: LD_ADDR_VAR 0 5
107826: PUSH
107827: DOUBLE
107828: LD_INT 1
107830: DEC
107831: ST_TO_ADDR
107832: LD_EXP 160
107836: PUSH
107837: FOR_TO
107838: IFFALSE 107939
// begin tmp := 0 ;
107840: LD_ADDR_VAR 0 2
107844: PUSH
107845: LD_STRING 0
107847: ST_TO_ADDR
// if result [ 1 ] then
107848: LD_VAR 0 1
107852: PUSH
107853: LD_INT 1
107855: ARRAY
107856: IFFALSE 107921
// if result [ 1 ] [ 1 ] = i then
107858: LD_VAR 0 1
107862: PUSH
107863: LD_INT 1
107865: ARRAY
107866: PUSH
107867: LD_INT 1
107869: ARRAY
107870: PUSH
107871: LD_VAR 0 5
107875: EQUAL
107876: IFFALSE 107921
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
107878: LD_ADDR_VAR 0 1
107882: PUSH
107883: LD_VAR 0 1
107887: PPUSH
107888: LD_INT 1
107890: PPUSH
107891: LD_VAR 0 1
107895: PUSH
107896: LD_INT 1
107898: ARRAY
107899: PPUSH
107900: LD_INT 1
107902: PPUSH
107903: CALL_OW 3
107907: PPUSH
107908: CALL_OW 1
107912: ST_TO_ADDR
// tmp := 1 ;
107913: LD_ADDR_VAR 0 2
107917: PUSH
107918: LD_STRING 1
107920: ST_TO_ADDR
// end ; normal := normal & tmp ;
107921: LD_ADDR_VAR 0 3
107925: PUSH
107926: LD_VAR 0 3
107930: PUSH
107931: LD_VAR 0 2
107935: STR
107936: ST_TO_ADDR
// end ;
107937: GO 107837
107939: POP
107940: POP
// for i = 1 to hardcoreCounter do
107941: LD_ADDR_VAR 0 5
107945: PUSH
107946: DOUBLE
107947: LD_INT 1
107949: DEC
107950: ST_TO_ADDR
107951: LD_EXP 161
107955: PUSH
107956: FOR_TO
107957: IFFALSE 108062
// begin tmp := 0 ;
107959: LD_ADDR_VAR 0 2
107963: PUSH
107964: LD_STRING 0
107966: ST_TO_ADDR
// if result [ 2 ] then
107967: LD_VAR 0 1
107971: PUSH
107972: LD_INT 2
107974: ARRAY
107975: IFFALSE 108044
// if result [ 2 ] [ 1 ] = 100 + i then
107977: LD_VAR 0 1
107981: PUSH
107982: LD_INT 2
107984: ARRAY
107985: PUSH
107986: LD_INT 1
107988: ARRAY
107989: PUSH
107990: LD_INT 100
107992: PUSH
107993: LD_VAR 0 5
107997: PLUS
107998: EQUAL
107999: IFFALSE 108044
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
108001: LD_ADDR_VAR 0 1
108005: PUSH
108006: LD_VAR 0 1
108010: PPUSH
108011: LD_INT 2
108013: PPUSH
108014: LD_VAR 0 1
108018: PUSH
108019: LD_INT 2
108021: ARRAY
108022: PPUSH
108023: LD_INT 1
108025: PPUSH
108026: CALL_OW 3
108030: PPUSH
108031: CALL_OW 1
108035: ST_TO_ADDR
// tmp := 1 ;
108036: LD_ADDR_VAR 0 2
108040: PUSH
108041: LD_STRING 1
108043: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
108044: LD_ADDR_VAR 0 4
108048: PUSH
108049: LD_VAR 0 4
108053: PUSH
108054: LD_VAR 0 2
108058: STR
108059: ST_TO_ADDR
// end ;
108060: GO 107956
108062: POP
108063: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
108064: LD_STRING getStreamItemsFromMission("
108066: PUSH
108067: LD_VAR 0 3
108071: STR
108072: PUSH
108073: LD_STRING ","
108075: STR
108076: PUSH
108077: LD_VAR 0 4
108081: STR
108082: PUSH
108083: LD_STRING ")
108085: STR
108086: PPUSH
108087: CALL_OW 559
// end else
108091: GO 108100
// ToLua ( getStreamItemsFromMission("","") ) ;
108093: LD_STRING getStreamItemsFromMission("","")
108095: PPUSH
108096: CALL_OW 559
// end ;
108100: LD_VAR 0 1
108104: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
108105: LD_EXP 159
108109: PUSH
108110: LD_EXP 164
108114: AND
108115: IFFALSE 108239
108117: GO 108119
108119: DISABLE
108120: LD_INT 0
108122: PPUSH
108123: PPUSH
// begin enable ;
108124: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
108125: LD_ADDR_VAR 0 2
108129: PUSH
108130: LD_INT 22
108132: PUSH
108133: LD_OWVAR 2
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: PUSH
108142: LD_INT 2
108144: PUSH
108145: LD_INT 34
108147: PUSH
108148: LD_INT 7
108150: PUSH
108151: EMPTY
108152: LIST
108153: LIST
108154: PUSH
108155: LD_INT 34
108157: PUSH
108158: LD_INT 45
108160: PUSH
108161: EMPTY
108162: LIST
108163: LIST
108164: PUSH
108165: LD_INT 34
108167: PUSH
108168: LD_INT 28
108170: PUSH
108171: EMPTY
108172: LIST
108173: LIST
108174: PUSH
108175: LD_INT 34
108177: PUSH
108178: LD_INT 47
108180: PUSH
108181: EMPTY
108182: LIST
108183: LIST
108184: PUSH
108185: EMPTY
108186: LIST
108187: LIST
108188: LIST
108189: LIST
108190: LIST
108191: PUSH
108192: EMPTY
108193: LIST
108194: LIST
108195: PPUSH
108196: CALL_OW 69
108200: ST_TO_ADDR
// if not tmp then
108201: LD_VAR 0 2
108205: NOT
108206: IFFALSE 108210
// exit ;
108208: GO 108239
// for i in tmp do
108210: LD_ADDR_VAR 0 1
108214: PUSH
108215: LD_VAR 0 2
108219: PUSH
108220: FOR_IN
108221: IFFALSE 108237
// begin SetLives ( i , 0 ) ;
108223: LD_VAR 0 1
108227: PPUSH
108228: LD_INT 0
108230: PPUSH
108231: CALL_OW 234
// end ;
108235: GO 108220
108237: POP
108238: POP
// end ;
108239: PPOPN 2
108241: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
108242: LD_EXP 159
108246: PUSH
108247: LD_EXP 165
108251: AND
108252: IFFALSE 108336
108254: GO 108256
108256: DISABLE
108257: LD_INT 0
108259: PPUSH
108260: PPUSH
// begin enable ;
108261: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
108262: LD_ADDR_VAR 0 2
108266: PUSH
108267: LD_INT 22
108269: PUSH
108270: LD_OWVAR 2
108274: PUSH
108275: EMPTY
108276: LIST
108277: LIST
108278: PUSH
108279: LD_INT 32
108281: PUSH
108282: LD_INT 3
108284: PUSH
108285: EMPTY
108286: LIST
108287: LIST
108288: PUSH
108289: EMPTY
108290: LIST
108291: LIST
108292: PPUSH
108293: CALL_OW 69
108297: ST_TO_ADDR
// if not tmp then
108298: LD_VAR 0 2
108302: NOT
108303: IFFALSE 108307
// exit ;
108305: GO 108336
// for i in tmp do
108307: LD_ADDR_VAR 0 1
108311: PUSH
108312: LD_VAR 0 2
108316: PUSH
108317: FOR_IN
108318: IFFALSE 108334
// begin SetLives ( i , 0 ) ;
108320: LD_VAR 0 1
108324: PPUSH
108325: LD_INT 0
108327: PPUSH
108328: CALL_OW 234
// end ;
108332: GO 108317
108334: POP
108335: POP
// end ;
108336: PPOPN 2
108338: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
108339: LD_EXP 159
108343: PUSH
108344: LD_EXP 162
108348: AND
108349: IFFALSE 108442
108351: GO 108353
108353: DISABLE
108354: LD_INT 0
108356: PPUSH
// begin enable ;
108357: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
108358: LD_ADDR_VAR 0 1
108362: PUSH
108363: LD_INT 22
108365: PUSH
108366: LD_OWVAR 2
108370: PUSH
108371: EMPTY
108372: LIST
108373: LIST
108374: PUSH
108375: LD_INT 2
108377: PUSH
108378: LD_INT 25
108380: PUSH
108381: LD_INT 5
108383: PUSH
108384: EMPTY
108385: LIST
108386: LIST
108387: PUSH
108388: LD_INT 25
108390: PUSH
108391: LD_INT 9
108393: PUSH
108394: EMPTY
108395: LIST
108396: LIST
108397: PUSH
108398: LD_INT 25
108400: PUSH
108401: LD_INT 8
108403: PUSH
108404: EMPTY
108405: LIST
108406: LIST
108407: PUSH
108408: EMPTY
108409: LIST
108410: LIST
108411: LIST
108412: LIST
108413: PUSH
108414: EMPTY
108415: LIST
108416: LIST
108417: PPUSH
108418: CALL_OW 69
108422: PUSH
108423: FOR_IN
108424: IFFALSE 108440
// begin SetClass ( i , 1 ) ;
108426: LD_VAR 0 1
108430: PPUSH
108431: LD_INT 1
108433: PPUSH
108434: CALL_OW 336
// end ;
108438: GO 108423
108440: POP
108441: POP
// end ;
108442: PPOPN 1
108444: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
108445: LD_EXP 159
108449: PUSH
108450: LD_EXP 163
108454: AND
108455: PUSH
108456: LD_OWVAR 65
108460: PUSH
108461: LD_INT 7
108463: LESS
108464: AND
108465: IFFALSE 108479
108467: GO 108469
108469: DISABLE
// begin enable ;
108470: ENABLE
// game_speed := 7 ;
108471: LD_ADDR_OWVAR 65
108475: PUSH
108476: LD_INT 7
108478: ST_TO_ADDR
// end ;
108479: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
108480: LD_EXP 159
108484: PUSH
108485: LD_EXP 166
108489: AND
108490: IFFALSE 108692
108492: GO 108494
108494: DISABLE
108495: LD_INT 0
108497: PPUSH
108498: PPUSH
108499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108500: LD_ADDR_VAR 0 3
108504: PUSH
108505: LD_INT 81
108507: PUSH
108508: LD_OWVAR 2
108512: PUSH
108513: EMPTY
108514: LIST
108515: LIST
108516: PUSH
108517: LD_INT 21
108519: PUSH
108520: LD_INT 1
108522: PUSH
108523: EMPTY
108524: LIST
108525: LIST
108526: PUSH
108527: EMPTY
108528: LIST
108529: LIST
108530: PPUSH
108531: CALL_OW 69
108535: ST_TO_ADDR
// if not tmp then
108536: LD_VAR 0 3
108540: NOT
108541: IFFALSE 108545
// exit ;
108543: GO 108692
// if tmp > 5 then
108545: LD_VAR 0 3
108549: PUSH
108550: LD_INT 5
108552: GREATER
108553: IFFALSE 108565
// k := 5 else
108555: LD_ADDR_VAR 0 2
108559: PUSH
108560: LD_INT 5
108562: ST_TO_ADDR
108563: GO 108575
// k := tmp ;
108565: LD_ADDR_VAR 0 2
108569: PUSH
108570: LD_VAR 0 3
108574: ST_TO_ADDR
// for i := 1 to k do
108575: LD_ADDR_VAR 0 1
108579: PUSH
108580: DOUBLE
108581: LD_INT 1
108583: DEC
108584: ST_TO_ADDR
108585: LD_VAR 0 2
108589: PUSH
108590: FOR_TO
108591: IFFALSE 108690
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
108593: LD_VAR 0 3
108597: PUSH
108598: LD_VAR 0 1
108602: ARRAY
108603: PPUSH
108604: LD_VAR 0 1
108608: PUSH
108609: LD_INT 4
108611: MOD
108612: PUSH
108613: LD_INT 1
108615: PLUS
108616: PPUSH
108617: CALL_OW 259
108621: PUSH
108622: LD_INT 10
108624: LESS
108625: IFFALSE 108688
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
108627: LD_VAR 0 3
108631: PUSH
108632: LD_VAR 0 1
108636: ARRAY
108637: PPUSH
108638: LD_VAR 0 1
108642: PUSH
108643: LD_INT 4
108645: MOD
108646: PUSH
108647: LD_INT 1
108649: PLUS
108650: PPUSH
108651: LD_VAR 0 3
108655: PUSH
108656: LD_VAR 0 1
108660: ARRAY
108661: PPUSH
108662: LD_VAR 0 1
108666: PUSH
108667: LD_INT 4
108669: MOD
108670: PUSH
108671: LD_INT 1
108673: PLUS
108674: PPUSH
108675: CALL_OW 259
108679: PUSH
108680: LD_INT 1
108682: PLUS
108683: PPUSH
108684: CALL_OW 237
108688: GO 108590
108690: POP
108691: POP
// end ;
108692: PPOPN 3
108694: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
108695: LD_EXP 159
108699: PUSH
108700: LD_EXP 167
108704: AND
108705: IFFALSE 108725
108707: GO 108709
108709: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
108710: LD_INT 4
108712: PPUSH
108713: LD_OWVAR 2
108717: PPUSH
108718: LD_INT 0
108720: PPUSH
108721: CALL_OW 324
108725: END
// every 0 0$1 trigger StreamModeActive and sShovel do
108726: LD_EXP 159
108730: PUSH
108731: LD_EXP 196
108735: AND
108736: IFFALSE 108756
108738: GO 108740
108740: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
108741: LD_INT 19
108743: PPUSH
108744: LD_OWVAR 2
108748: PPUSH
108749: LD_INT 0
108751: PPUSH
108752: CALL_OW 324
108756: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
108757: LD_EXP 159
108761: PUSH
108762: LD_EXP 168
108766: AND
108767: IFFALSE 108869
108769: GO 108771
108771: DISABLE
108772: LD_INT 0
108774: PPUSH
108775: PPUSH
// begin enable ;
108776: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
108777: LD_ADDR_VAR 0 2
108781: PUSH
108782: LD_INT 22
108784: PUSH
108785: LD_OWVAR 2
108789: PUSH
108790: EMPTY
108791: LIST
108792: LIST
108793: PUSH
108794: LD_INT 2
108796: PUSH
108797: LD_INT 34
108799: PUSH
108800: LD_INT 11
108802: PUSH
108803: EMPTY
108804: LIST
108805: LIST
108806: PUSH
108807: LD_INT 34
108809: PUSH
108810: LD_INT 30
108812: PUSH
108813: EMPTY
108814: LIST
108815: LIST
108816: PUSH
108817: EMPTY
108818: LIST
108819: LIST
108820: LIST
108821: PUSH
108822: EMPTY
108823: LIST
108824: LIST
108825: PPUSH
108826: CALL_OW 69
108830: ST_TO_ADDR
// if not tmp then
108831: LD_VAR 0 2
108835: NOT
108836: IFFALSE 108840
// exit ;
108838: GO 108869
// for i in tmp do
108840: LD_ADDR_VAR 0 1
108844: PUSH
108845: LD_VAR 0 2
108849: PUSH
108850: FOR_IN
108851: IFFALSE 108867
// begin SetLives ( i , 0 ) ;
108853: LD_VAR 0 1
108857: PPUSH
108858: LD_INT 0
108860: PPUSH
108861: CALL_OW 234
// end ;
108865: GO 108850
108867: POP
108868: POP
// end ;
108869: PPOPN 2
108871: END
// every 0 0$1 trigger StreamModeActive and sBunker do
108872: LD_EXP 159
108876: PUSH
108877: LD_EXP 169
108881: AND
108882: IFFALSE 108902
108884: GO 108886
108886: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
108887: LD_INT 32
108889: PPUSH
108890: LD_OWVAR 2
108894: PPUSH
108895: LD_INT 0
108897: PPUSH
108898: CALL_OW 324
108902: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
108903: LD_EXP 159
108907: PUSH
108908: LD_EXP 170
108912: AND
108913: IFFALSE 109094
108915: GO 108917
108917: DISABLE
108918: LD_INT 0
108920: PPUSH
108921: PPUSH
108922: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
108923: LD_ADDR_VAR 0 2
108927: PUSH
108928: LD_INT 22
108930: PUSH
108931: LD_OWVAR 2
108935: PUSH
108936: EMPTY
108937: LIST
108938: LIST
108939: PUSH
108940: LD_INT 33
108942: PUSH
108943: LD_INT 3
108945: PUSH
108946: EMPTY
108947: LIST
108948: LIST
108949: PUSH
108950: EMPTY
108951: LIST
108952: LIST
108953: PPUSH
108954: CALL_OW 69
108958: ST_TO_ADDR
// if not tmp then
108959: LD_VAR 0 2
108963: NOT
108964: IFFALSE 108968
// exit ;
108966: GO 109094
// side := 0 ;
108968: LD_ADDR_VAR 0 3
108972: PUSH
108973: LD_INT 0
108975: ST_TO_ADDR
// for i := 1 to 8 do
108976: LD_ADDR_VAR 0 1
108980: PUSH
108981: DOUBLE
108982: LD_INT 1
108984: DEC
108985: ST_TO_ADDR
108986: LD_INT 8
108988: PUSH
108989: FOR_TO
108990: IFFALSE 109038
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
108992: LD_OWVAR 2
108996: PUSH
108997: LD_VAR 0 1
109001: NONEQUAL
109002: PUSH
109003: LD_OWVAR 2
109007: PPUSH
109008: LD_VAR 0 1
109012: PPUSH
109013: CALL_OW 81
109017: PUSH
109018: LD_INT 2
109020: EQUAL
109021: AND
109022: IFFALSE 109036
// begin side := i ;
109024: LD_ADDR_VAR 0 3
109028: PUSH
109029: LD_VAR 0 1
109033: ST_TO_ADDR
// break ;
109034: GO 109038
// end ;
109036: GO 108989
109038: POP
109039: POP
// if not side then
109040: LD_VAR 0 3
109044: NOT
109045: IFFALSE 109049
// exit ;
109047: GO 109094
// for i := 1 to tmp do
109049: LD_ADDR_VAR 0 1
109053: PUSH
109054: DOUBLE
109055: LD_INT 1
109057: DEC
109058: ST_TO_ADDR
109059: LD_VAR 0 2
109063: PUSH
109064: FOR_TO
109065: IFFALSE 109092
// if Prob ( 60 ) then
109067: LD_INT 60
109069: PPUSH
109070: CALL_OW 13
109074: IFFALSE 109090
// SetSide ( i , side ) ;
109076: LD_VAR 0 1
109080: PPUSH
109081: LD_VAR 0 3
109085: PPUSH
109086: CALL_OW 235
109090: GO 109064
109092: POP
109093: POP
// end ;
109094: PPOPN 3
109096: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
109097: LD_EXP 159
109101: PUSH
109102: LD_EXP 172
109106: AND
109107: IFFALSE 109226
109109: GO 109111
109111: DISABLE
109112: LD_INT 0
109114: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
109115: LD_ADDR_VAR 0 1
109119: PUSH
109120: LD_INT 22
109122: PUSH
109123: LD_OWVAR 2
109127: PUSH
109128: EMPTY
109129: LIST
109130: LIST
109131: PUSH
109132: LD_INT 21
109134: PUSH
109135: LD_INT 1
109137: PUSH
109138: EMPTY
109139: LIST
109140: LIST
109141: PUSH
109142: LD_INT 3
109144: PUSH
109145: LD_INT 23
109147: PUSH
109148: LD_INT 0
109150: PUSH
109151: EMPTY
109152: LIST
109153: LIST
109154: PUSH
109155: EMPTY
109156: LIST
109157: LIST
109158: PUSH
109159: EMPTY
109160: LIST
109161: LIST
109162: LIST
109163: PPUSH
109164: CALL_OW 69
109168: PUSH
109169: FOR_IN
109170: IFFALSE 109224
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
109172: LD_VAR 0 1
109176: PPUSH
109177: CALL_OW 257
109181: PUSH
109182: LD_INT 1
109184: PUSH
109185: LD_INT 2
109187: PUSH
109188: LD_INT 3
109190: PUSH
109191: LD_INT 4
109193: PUSH
109194: EMPTY
109195: LIST
109196: LIST
109197: LIST
109198: LIST
109199: IN
109200: IFFALSE 109222
// SetClass ( un , rand ( 1 , 4 ) ) ;
109202: LD_VAR 0 1
109206: PPUSH
109207: LD_INT 1
109209: PPUSH
109210: LD_INT 4
109212: PPUSH
109213: CALL_OW 12
109217: PPUSH
109218: CALL_OW 336
109222: GO 109169
109224: POP
109225: POP
// end ;
109226: PPOPN 1
109228: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
109229: LD_EXP 159
109233: PUSH
109234: LD_EXP 171
109238: AND
109239: IFFALSE 109318
109241: GO 109243
109243: DISABLE
109244: LD_INT 0
109246: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
109247: LD_ADDR_VAR 0 1
109251: PUSH
109252: LD_INT 22
109254: PUSH
109255: LD_OWVAR 2
109259: PUSH
109260: EMPTY
109261: LIST
109262: LIST
109263: PUSH
109264: LD_INT 21
109266: PUSH
109267: LD_INT 3
109269: PUSH
109270: EMPTY
109271: LIST
109272: LIST
109273: PUSH
109274: EMPTY
109275: LIST
109276: LIST
109277: PPUSH
109278: CALL_OW 69
109282: ST_TO_ADDR
// if not tmp then
109283: LD_VAR 0 1
109287: NOT
109288: IFFALSE 109292
// exit ;
109290: GO 109318
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
109292: LD_VAR 0 1
109296: PUSH
109297: LD_INT 1
109299: PPUSH
109300: LD_VAR 0 1
109304: PPUSH
109305: CALL_OW 12
109309: ARRAY
109310: PPUSH
109311: LD_INT 100
109313: PPUSH
109314: CALL_OW 234
// end ;
109318: PPOPN 1
109320: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
109321: LD_EXP 159
109325: PUSH
109326: LD_EXP 173
109330: AND
109331: IFFALSE 109429
109333: GO 109335
109335: DISABLE
109336: LD_INT 0
109338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109339: LD_ADDR_VAR 0 1
109343: PUSH
109344: LD_INT 22
109346: PUSH
109347: LD_OWVAR 2
109351: PUSH
109352: EMPTY
109353: LIST
109354: LIST
109355: PUSH
109356: LD_INT 21
109358: PUSH
109359: LD_INT 1
109361: PUSH
109362: EMPTY
109363: LIST
109364: LIST
109365: PUSH
109366: EMPTY
109367: LIST
109368: LIST
109369: PPUSH
109370: CALL_OW 69
109374: ST_TO_ADDR
// if not tmp then
109375: LD_VAR 0 1
109379: NOT
109380: IFFALSE 109384
// exit ;
109382: GO 109429
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
109384: LD_VAR 0 1
109388: PUSH
109389: LD_INT 1
109391: PPUSH
109392: LD_VAR 0 1
109396: PPUSH
109397: CALL_OW 12
109401: ARRAY
109402: PPUSH
109403: LD_INT 1
109405: PPUSH
109406: LD_INT 4
109408: PPUSH
109409: CALL_OW 12
109413: PPUSH
109414: LD_INT 3000
109416: PPUSH
109417: LD_INT 9000
109419: PPUSH
109420: CALL_OW 12
109424: PPUSH
109425: CALL_OW 492
// end ;
109429: PPOPN 1
109431: END
// every 0 0$1 trigger StreamModeActive and sDepot do
109432: LD_EXP 159
109436: PUSH
109437: LD_EXP 174
109441: AND
109442: IFFALSE 109462
109444: GO 109446
109446: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
109447: LD_INT 1
109449: PPUSH
109450: LD_OWVAR 2
109454: PPUSH
109455: LD_INT 0
109457: PPUSH
109458: CALL_OW 324
109462: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
109463: LD_EXP 159
109467: PUSH
109468: LD_EXP 175
109472: AND
109473: IFFALSE 109556
109475: GO 109477
109477: DISABLE
109478: LD_INT 0
109480: PPUSH
109481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
109482: LD_ADDR_VAR 0 2
109486: PUSH
109487: LD_INT 22
109489: PUSH
109490: LD_OWVAR 2
109494: PUSH
109495: EMPTY
109496: LIST
109497: LIST
109498: PUSH
109499: LD_INT 21
109501: PUSH
109502: LD_INT 3
109504: PUSH
109505: EMPTY
109506: LIST
109507: LIST
109508: PUSH
109509: EMPTY
109510: LIST
109511: LIST
109512: PPUSH
109513: CALL_OW 69
109517: ST_TO_ADDR
// if not tmp then
109518: LD_VAR 0 2
109522: NOT
109523: IFFALSE 109527
// exit ;
109525: GO 109556
// for i in tmp do
109527: LD_ADDR_VAR 0 1
109531: PUSH
109532: LD_VAR 0 2
109536: PUSH
109537: FOR_IN
109538: IFFALSE 109554
// SetBLevel ( i , 10 ) ;
109540: LD_VAR 0 1
109544: PPUSH
109545: LD_INT 10
109547: PPUSH
109548: CALL_OW 241
109552: GO 109537
109554: POP
109555: POP
// end ;
109556: PPOPN 2
109558: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
109559: LD_EXP 159
109563: PUSH
109564: LD_EXP 176
109568: AND
109569: IFFALSE 109680
109571: GO 109573
109573: DISABLE
109574: LD_INT 0
109576: PPUSH
109577: PPUSH
109578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
109579: LD_ADDR_VAR 0 3
109583: PUSH
109584: LD_INT 22
109586: PUSH
109587: LD_OWVAR 2
109591: PUSH
109592: EMPTY
109593: LIST
109594: LIST
109595: PUSH
109596: LD_INT 25
109598: PUSH
109599: LD_INT 1
109601: PUSH
109602: EMPTY
109603: LIST
109604: LIST
109605: PUSH
109606: EMPTY
109607: LIST
109608: LIST
109609: PPUSH
109610: CALL_OW 69
109614: ST_TO_ADDR
// if not tmp then
109615: LD_VAR 0 3
109619: NOT
109620: IFFALSE 109624
// exit ;
109622: GO 109680
// un := tmp [ rand ( 1 , tmp ) ] ;
109624: LD_ADDR_VAR 0 2
109628: PUSH
109629: LD_VAR 0 3
109633: PUSH
109634: LD_INT 1
109636: PPUSH
109637: LD_VAR 0 3
109641: PPUSH
109642: CALL_OW 12
109646: ARRAY
109647: ST_TO_ADDR
// if Crawls ( un ) then
109648: LD_VAR 0 2
109652: PPUSH
109653: CALL_OW 318
109657: IFFALSE 109668
// ComWalk ( un ) ;
109659: LD_VAR 0 2
109663: PPUSH
109664: CALL_OW 138
// SetClass ( un , class_sniper ) ;
109668: LD_VAR 0 2
109672: PPUSH
109673: LD_INT 5
109675: PPUSH
109676: CALL_OW 336
// end ;
109680: PPOPN 3
109682: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
109683: LD_EXP 159
109687: PUSH
109688: LD_EXP 177
109692: AND
109693: PUSH
109694: LD_OWVAR 67
109698: PUSH
109699: LD_INT 3
109701: LESS
109702: AND
109703: IFFALSE 109722
109705: GO 109707
109707: DISABLE
// Difficulty := Difficulty + 1 ;
109708: LD_ADDR_OWVAR 67
109712: PUSH
109713: LD_OWVAR 67
109717: PUSH
109718: LD_INT 1
109720: PLUS
109721: ST_TO_ADDR
109722: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
109723: LD_EXP 159
109727: PUSH
109728: LD_EXP 178
109732: AND
109733: IFFALSE 109836
109735: GO 109737
109737: DISABLE
109738: LD_INT 0
109740: PPUSH
// begin for i := 1 to 5 do
109741: LD_ADDR_VAR 0 1
109745: PUSH
109746: DOUBLE
109747: LD_INT 1
109749: DEC
109750: ST_TO_ADDR
109751: LD_INT 5
109753: PUSH
109754: FOR_TO
109755: IFFALSE 109834
// begin uc_nation := nation_nature ;
109757: LD_ADDR_OWVAR 21
109761: PUSH
109762: LD_INT 0
109764: ST_TO_ADDR
// uc_side := 0 ;
109765: LD_ADDR_OWVAR 20
109769: PUSH
109770: LD_INT 0
109772: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109773: LD_ADDR_OWVAR 29
109777: PUSH
109778: LD_INT 12
109780: PUSH
109781: LD_INT 12
109783: PUSH
109784: EMPTY
109785: LIST
109786: LIST
109787: ST_TO_ADDR
// hc_agressivity := 20 ;
109788: LD_ADDR_OWVAR 35
109792: PUSH
109793: LD_INT 20
109795: ST_TO_ADDR
// hc_class := class_tiger ;
109796: LD_ADDR_OWVAR 28
109800: PUSH
109801: LD_INT 14
109803: ST_TO_ADDR
// hc_gallery :=  ;
109804: LD_ADDR_OWVAR 33
109808: PUSH
109809: LD_STRING 
109811: ST_TO_ADDR
// hc_name :=  ;
109812: LD_ADDR_OWVAR 26
109816: PUSH
109817: LD_STRING 
109819: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
109820: CALL_OW 44
109824: PPUSH
109825: LD_INT 0
109827: PPUSH
109828: CALL_OW 51
// end ;
109832: GO 109754
109834: POP
109835: POP
// end ;
109836: PPOPN 1
109838: END
// every 0 0$1 trigger StreamModeActive and sBomb do
109839: LD_EXP 159
109843: PUSH
109844: LD_EXP 179
109848: AND
109849: IFFALSE 109858
109851: GO 109853
109853: DISABLE
// StreamSibBomb ;
109854: CALL 109859 0 0
109858: END
// export function StreamSibBomb ; var i , x , y ; begin
109859: LD_INT 0
109861: PPUSH
109862: PPUSH
109863: PPUSH
109864: PPUSH
// result := false ;
109865: LD_ADDR_VAR 0 1
109869: PUSH
109870: LD_INT 0
109872: ST_TO_ADDR
// for i := 1 to 16 do
109873: LD_ADDR_VAR 0 2
109877: PUSH
109878: DOUBLE
109879: LD_INT 1
109881: DEC
109882: ST_TO_ADDR
109883: LD_INT 16
109885: PUSH
109886: FOR_TO
109887: IFFALSE 110086
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109889: LD_ADDR_VAR 0 3
109893: PUSH
109894: LD_INT 10
109896: PUSH
109897: LD_INT 20
109899: PUSH
109900: LD_INT 30
109902: PUSH
109903: LD_INT 40
109905: PUSH
109906: LD_INT 50
109908: PUSH
109909: LD_INT 60
109911: PUSH
109912: LD_INT 70
109914: PUSH
109915: LD_INT 80
109917: PUSH
109918: LD_INT 90
109920: PUSH
109921: LD_INT 100
109923: PUSH
109924: LD_INT 110
109926: PUSH
109927: LD_INT 120
109929: PUSH
109930: LD_INT 130
109932: PUSH
109933: LD_INT 140
109935: PUSH
109936: LD_INT 150
109938: PUSH
109939: EMPTY
109940: LIST
109941: LIST
109942: LIST
109943: LIST
109944: LIST
109945: LIST
109946: LIST
109947: LIST
109948: LIST
109949: LIST
109950: LIST
109951: LIST
109952: LIST
109953: LIST
109954: LIST
109955: PUSH
109956: LD_INT 1
109958: PPUSH
109959: LD_INT 15
109961: PPUSH
109962: CALL_OW 12
109966: ARRAY
109967: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109968: LD_ADDR_VAR 0 4
109972: PUSH
109973: LD_INT 10
109975: PUSH
109976: LD_INT 20
109978: PUSH
109979: LD_INT 30
109981: PUSH
109982: LD_INT 40
109984: PUSH
109985: LD_INT 50
109987: PUSH
109988: LD_INT 60
109990: PUSH
109991: LD_INT 70
109993: PUSH
109994: LD_INT 80
109996: PUSH
109997: LD_INT 90
109999: PUSH
110000: LD_INT 100
110002: PUSH
110003: LD_INT 110
110005: PUSH
110006: LD_INT 120
110008: PUSH
110009: LD_INT 130
110011: PUSH
110012: LD_INT 140
110014: PUSH
110015: LD_INT 150
110017: PUSH
110018: EMPTY
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: PUSH
110035: LD_INT 1
110037: PPUSH
110038: LD_INT 15
110040: PPUSH
110041: CALL_OW 12
110045: ARRAY
110046: ST_TO_ADDR
// if ValidHex ( x , y ) then
110047: LD_VAR 0 3
110051: PPUSH
110052: LD_VAR 0 4
110056: PPUSH
110057: CALL_OW 488
110061: IFFALSE 110084
// begin result := [ x , y ] ;
110063: LD_ADDR_VAR 0 1
110067: PUSH
110068: LD_VAR 0 3
110072: PUSH
110073: LD_VAR 0 4
110077: PUSH
110078: EMPTY
110079: LIST
110080: LIST
110081: ST_TO_ADDR
// break ;
110082: GO 110086
// end ; end ;
110084: GO 109886
110086: POP
110087: POP
// if result then
110088: LD_VAR 0 1
110092: IFFALSE 110152
// begin ToLua ( playSibBomb() ) ;
110094: LD_STRING playSibBomb()
110096: PPUSH
110097: CALL_OW 559
// wait ( 0 0$14 ) ;
110101: LD_INT 490
110103: PPUSH
110104: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
110108: LD_VAR 0 1
110112: PUSH
110113: LD_INT 1
110115: ARRAY
110116: PPUSH
110117: LD_VAR 0 1
110121: PUSH
110122: LD_INT 2
110124: ARRAY
110125: PPUSH
110126: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
110130: LD_VAR 0 1
110134: PUSH
110135: LD_INT 1
110137: ARRAY
110138: PPUSH
110139: LD_VAR 0 1
110143: PUSH
110144: LD_INT 2
110146: ARRAY
110147: PPUSH
110148: CALL_OW 429
// end ; end ;
110152: LD_VAR 0 1
110156: RET
// every 0 0$1 trigger StreamModeActive and sReset do
110157: LD_EXP 159
110161: PUSH
110162: LD_EXP 181
110166: AND
110167: IFFALSE 110179
110169: GO 110171
110171: DISABLE
// YouLost (  ) ;
110172: LD_STRING 
110174: PPUSH
110175: CALL_OW 104
110179: END
// every 0 0$1 trigger StreamModeActive and sFog do
110180: LD_EXP 159
110184: PUSH
110185: LD_EXP 180
110189: AND
110190: IFFALSE 110204
110192: GO 110194
110194: DISABLE
// FogOff ( your_side ) ;
110195: LD_OWVAR 2
110199: PPUSH
110200: CALL_OW 344
110204: END
// every 0 0$1 trigger StreamModeActive and sSun do
110205: LD_EXP 159
110209: PUSH
110210: LD_EXP 182
110214: AND
110215: IFFALSE 110243
110217: GO 110219
110219: DISABLE
// begin solar_recharge_percent := 0 ;
110220: LD_ADDR_OWVAR 79
110224: PUSH
110225: LD_INT 0
110227: ST_TO_ADDR
// wait ( 5 5$00 ) ;
110228: LD_INT 10500
110230: PPUSH
110231: CALL_OW 67
// solar_recharge_percent := 100 ;
110235: LD_ADDR_OWVAR 79
110239: PUSH
110240: LD_INT 100
110242: ST_TO_ADDR
// end ;
110243: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
110244: LD_EXP 159
110248: PUSH
110249: LD_EXP 183
110253: AND
110254: IFFALSE 110493
110256: GO 110258
110258: DISABLE
110259: LD_INT 0
110261: PPUSH
110262: PPUSH
110263: PPUSH
// begin tmp := [ ] ;
110264: LD_ADDR_VAR 0 3
110268: PUSH
110269: EMPTY
110270: ST_TO_ADDR
// for i := 1 to 6 do
110271: LD_ADDR_VAR 0 1
110275: PUSH
110276: DOUBLE
110277: LD_INT 1
110279: DEC
110280: ST_TO_ADDR
110281: LD_INT 6
110283: PUSH
110284: FOR_TO
110285: IFFALSE 110390
// begin uc_nation := nation_nature ;
110287: LD_ADDR_OWVAR 21
110291: PUSH
110292: LD_INT 0
110294: ST_TO_ADDR
// uc_side := 0 ;
110295: LD_ADDR_OWVAR 20
110299: PUSH
110300: LD_INT 0
110302: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
110303: LD_ADDR_OWVAR 29
110307: PUSH
110308: LD_INT 12
110310: PUSH
110311: LD_INT 12
110313: PUSH
110314: EMPTY
110315: LIST
110316: LIST
110317: ST_TO_ADDR
// hc_agressivity := 20 ;
110318: LD_ADDR_OWVAR 35
110322: PUSH
110323: LD_INT 20
110325: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
110326: LD_ADDR_OWVAR 28
110330: PUSH
110331: LD_INT 17
110333: ST_TO_ADDR
// hc_gallery :=  ;
110334: LD_ADDR_OWVAR 33
110338: PUSH
110339: LD_STRING 
110341: ST_TO_ADDR
// hc_name :=  ;
110342: LD_ADDR_OWVAR 26
110346: PUSH
110347: LD_STRING 
110349: ST_TO_ADDR
// un := CreateHuman ;
110350: LD_ADDR_VAR 0 2
110354: PUSH
110355: CALL_OW 44
110359: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
110360: LD_VAR 0 2
110364: PPUSH
110365: LD_INT 1
110367: PPUSH
110368: CALL_OW 51
// tmp := tmp ^ un ;
110372: LD_ADDR_VAR 0 3
110376: PUSH
110377: LD_VAR 0 3
110381: PUSH
110382: LD_VAR 0 2
110386: ADD
110387: ST_TO_ADDR
// end ;
110388: GO 110284
110390: POP
110391: POP
// repeat wait ( 0 0$1 ) ;
110392: LD_INT 35
110394: PPUSH
110395: CALL_OW 67
// for un in tmp do
110399: LD_ADDR_VAR 0 2
110403: PUSH
110404: LD_VAR 0 3
110408: PUSH
110409: FOR_IN
110410: IFFALSE 110484
// begin if IsDead ( un ) then
110412: LD_VAR 0 2
110416: PPUSH
110417: CALL_OW 301
110421: IFFALSE 110441
// begin tmp := tmp diff un ;
110423: LD_ADDR_VAR 0 3
110427: PUSH
110428: LD_VAR 0 3
110432: PUSH
110433: LD_VAR 0 2
110437: DIFF
110438: ST_TO_ADDR
// continue ;
110439: GO 110409
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
110441: LD_VAR 0 2
110445: PPUSH
110446: LD_INT 3
110448: PUSH
110449: LD_INT 22
110451: PUSH
110452: LD_INT 0
110454: PUSH
110455: EMPTY
110456: LIST
110457: LIST
110458: PUSH
110459: EMPTY
110460: LIST
110461: LIST
110462: PPUSH
110463: CALL_OW 69
110467: PPUSH
110468: LD_VAR 0 2
110472: PPUSH
110473: CALL_OW 74
110477: PPUSH
110478: CALL_OW 115
// end ;
110482: GO 110409
110484: POP
110485: POP
// until not tmp ;
110486: LD_VAR 0 3
110490: NOT
110491: IFFALSE 110392
// end ;
110493: PPOPN 3
110495: END
// every 0 0$1 trigger StreamModeActive and sTroll do
110496: LD_EXP 159
110500: PUSH
110501: LD_EXP 184
110505: AND
110506: IFFALSE 110560
110508: GO 110510
110510: DISABLE
// begin ToLua ( displayTroll(); ) ;
110511: LD_STRING displayTroll();
110513: PPUSH
110514: CALL_OW 559
// wait ( 3 3$00 ) ;
110518: LD_INT 6300
110520: PPUSH
110521: CALL_OW 67
// ToLua ( hideTroll(); ) ;
110525: LD_STRING hideTroll();
110527: PPUSH
110528: CALL_OW 559
// wait ( 1 1$00 ) ;
110532: LD_INT 2100
110534: PPUSH
110535: CALL_OW 67
// ToLua ( displayTroll(); ) ;
110539: LD_STRING displayTroll();
110541: PPUSH
110542: CALL_OW 559
// wait ( 1 1$00 ) ;
110546: LD_INT 2100
110548: PPUSH
110549: CALL_OW 67
// ToLua ( hideTroll(); ) ;
110553: LD_STRING hideTroll();
110555: PPUSH
110556: CALL_OW 559
// end ;
110560: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
110561: LD_EXP 159
110565: PUSH
110566: LD_EXP 185
110570: AND
110571: IFFALSE 110634
110573: GO 110575
110575: DISABLE
110576: LD_INT 0
110578: PPUSH
// begin p := 0 ;
110579: LD_ADDR_VAR 0 1
110583: PUSH
110584: LD_INT 0
110586: ST_TO_ADDR
// repeat game_speed := 1 ;
110587: LD_ADDR_OWVAR 65
110591: PUSH
110592: LD_INT 1
110594: ST_TO_ADDR
// wait ( 0 0$1 ) ;
110595: LD_INT 35
110597: PPUSH
110598: CALL_OW 67
// p := p + 1 ;
110602: LD_ADDR_VAR 0 1
110606: PUSH
110607: LD_VAR 0 1
110611: PUSH
110612: LD_INT 1
110614: PLUS
110615: ST_TO_ADDR
// until p >= 60 ;
110616: LD_VAR 0 1
110620: PUSH
110621: LD_INT 60
110623: GREATEREQUAL
110624: IFFALSE 110587
// game_speed := 4 ;
110626: LD_ADDR_OWVAR 65
110630: PUSH
110631: LD_INT 4
110633: ST_TO_ADDR
// end ;
110634: PPOPN 1
110636: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
110637: LD_EXP 159
110641: PUSH
110642: LD_EXP 186
110646: AND
110647: IFFALSE 110793
110649: GO 110651
110651: DISABLE
110652: LD_INT 0
110654: PPUSH
110655: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110656: LD_ADDR_VAR 0 1
110660: PUSH
110661: LD_INT 22
110663: PUSH
110664: LD_OWVAR 2
110668: PUSH
110669: EMPTY
110670: LIST
110671: LIST
110672: PUSH
110673: LD_INT 2
110675: PUSH
110676: LD_INT 30
110678: PUSH
110679: LD_INT 0
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: PUSH
110686: LD_INT 30
110688: PUSH
110689: LD_INT 1
110691: PUSH
110692: EMPTY
110693: LIST
110694: LIST
110695: PUSH
110696: EMPTY
110697: LIST
110698: LIST
110699: LIST
110700: PUSH
110701: EMPTY
110702: LIST
110703: LIST
110704: PPUSH
110705: CALL_OW 69
110709: ST_TO_ADDR
// if not depot then
110710: LD_VAR 0 1
110714: NOT
110715: IFFALSE 110719
// exit ;
110717: GO 110793
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
110719: LD_ADDR_VAR 0 2
110723: PUSH
110724: LD_VAR 0 1
110728: PUSH
110729: LD_INT 1
110731: PPUSH
110732: LD_VAR 0 1
110736: PPUSH
110737: CALL_OW 12
110741: ARRAY
110742: PPUSH
110743: CALL_OW 274
110747: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
110748: LD_VAR 0 2
110752: PPUSH
110753: LD_INT 1
110755: PPUSH
110756: LD_INT 0
110758: PPUSH
110759: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
110763: LD_VAR 0 2
110767: PPUSH
110768: LD_INT 2
110770: PPUSH
110771: LD_INT 0
110773: PPUSH
110774: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
110778: LD_VAR 0 2
110782: PPUSH
110783: LD_INT 3
110785: PPUSH
110786: LD_INT 0
110788: PPUSH
110789: CALL_OW 277
// end ;
110793: PPOPN 2
110795: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
110796: LD_EXP 159
110800: PUSH
110801: LD_EXP 187
110805: AND
110806: IFFALSE 110903
110808: GO 110810
110810: DISABLE
110811: LD_INT 0
110813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110814: LD_ADDR_VAR 0 1
110818: PUSH
110819: LD_INT 22
110821: PUSH
110822: LD_OWVAR 2
110826: PUSH
110827: EMPTY
110828: LIST
110829: LIST
110830: PUSH
110831: LD_INT 21
110833: PUSH
110834: LD_INT 1
110836: PUSH
110837: EMPTY
110838: LIST
110839: LIST
110840: PUSH
110841: LD_INT 3
110843: PUSH
110844: LD_INT 23
110846: PUSH
110847: LD_INT 0
110849: PUSH
110850: EMPTY
110851: LIST
110852: LIST
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: PUSH
110858: EMPTY
110859: LIST
110860: LIST
110861: LIST
110862: PPUSH
110863: CALL_OW 69
110867: ST_TO_ADDR
// if not tmp then
110868: LD_VAR 0 1
110872: NOT
110873: IFFALSE 110877
// exit ;
110875: GO 110903
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
110877: LD_VAR 0 1
110881: PUSH
110882: LD_INT 1
110884: PPUSH
110885: LD_VAR 0 1
110889: PPUSH
110890: CALL_OW 12
110894: ARRAY
110895: PPUSH
110896: LD_INT 200
110898: PPUSH
110899: CALL_OW 234
// end ;
110903: PPOPN 1
110905: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
110906: LD_EXP 159
110910: PUSH
110911: LD_EXP 188
110915: AND
110916: IFFALSE 110995
110918: GO 110920
110920: DISABLE
110921: LD_INT 0
110923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
110924: LD_ADDR_VAR 0 1
110928: PUSH
110929: LD_INT 22
110931: PUSH
110932: LD_OWVAR 2
110936: PUSH
110937: EMPTY
110938: LIST
110939: LIST
110940: PUSH
110941: LD_INT 21
110943: PUSH
110944: LD_INT 2
110946: PUSH
110947: EMPTY
110948: LIST
110949: LIST
110950: PUSH
110951: EMPTY
110952: LIST
110953: LIST
110954: PPUSH
110955: CALL_OW 69
110959: ST_TO_ADDR
// if not tmp then
110960: LD_VAR 0 1
110964: NOT
110965: IFFALSE 110969
// exit ;
110967: GO 110995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
110969: LD_VAR 0 1
110973: PUSH
110974: LD_INT 1
110976: PPUSH
110977: LD_VAR 0 1
110981: PPUSH
110982: CALL_OW 12
110986: ARRAY
110987: PPUSH
110988: LD_INT 60
110990: PPUSH
110991: CALL_OW 234
// end ;
110995: PPOPN 1
110997: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
110998: LD_EXP 159
111002: PUSH
111003: LD_EXP 189
111007: AND
111008: IFFALSE 111107
111010: GO 111012
111012: DISABLE
111013: LD_INT 0
111015: PPUSH
111016: PPUSH
// begin enable ;
111017: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
111018: LD_ADDR_VAR 0 1
111022: PUSH
111023: LD_INT 22
111025: PUSH
111026: LD_OWVAR 2
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: PUSH
111035: LD_INT 61
111037: PUSH
111038: EMPTY
111039: LIST
111040: PUSH
111041: LD_INT 33
111043: PUSH
111044: LD_INT 2
111046: PUSH
111047: EMPTY
111048: LIST
111049: LIST
111050: PUSH
111051: EMPTY
111052: LIST
111053: LIST
111054: LIST
111055: PPUSH
111056: CALL_OW 69
111060: ST_TO_ADDR
// if not tmp then
111061: LD_VAR 0 1
111065: NOT
111066: IFFALSE 111070
// exit ;
111068: GO 111107
// for i in tmp do
111070: LD_ADDR_VAR 0 2
111074: PUSH
111075: LD_VAR 0 1
111079: PUSH
111080: FOR_IN
111081: IFFALSE 111105
// if IsControledBy ( i ) then
111083: LD_VAR 0 2
111087: PPUSH
111088: CALL_OW 312
111092: IFFALSE 111103
// ComUnlink ( i ) ;
111094: LD_VAR 0 2
111098: PPUSH
111099: CALL_OW 136
111103: GO 111080
111105: POP
111106: POP
// end ;
111107: PPOPN 2
111109: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
111110: LD_EXP 159
111114: PUSH
111115: LD_EXP 190
111119: AND
111120: IFFALSE 111260
111122: GO 111124
111124: DISABLE
111125: LD_INT 0
111127: PPUSH
111128: PPUSH
// begin ToLua ( displayPowell(); ) ;
111129: LD_STRING displayPowell();
111131: PPUSH
111132: CALL_OW 559
// uc_side := 0 ;
111136: LD_ADDR_OWVAR 20
111140: PUSH
111141: LD_INT 0
111143: ST_TO_ADDR
// uc_nation := 2 ;
111144: LD_ADDR_OWVAR 21
111148: PUSH
111149: LD_INT 2
111151: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
111152: LD_ADDR_OWVAR 37
111156: PUSH
111157: LD_INT 14
111159: ST_TO_ADDR
// vc_engine := engine_siberite ;
111160: LD_ADDR_OWVAR 39
111164: PUSH
111165: LD_INT 3
111167: ST_TO_ADDR
// vc_control := control_apeman ;
111168: LD_ADDR_OWVAR 38
111172: PUSH
111173: LD_INT 5
111175: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
111176: LD_ADDR_OWVAR 40
111180: PUSH
111181: LD_INT 29
111183: ST_TO_ADDR
// un := CreateVehicle ;
111184: LD_ADDR_VAR 0 2
111188: PUSH
111189: CALL_OW 45
111193: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111194: LD_VAR 0 2
111198: PPUSH
111199: LD_INT 1
111201: PPUSH
111202: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
111206: LD_INT 35
111208: PPUSH
111209: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
111213: LD_VAR 0 2
111217: PPUSH
111218: LD_INT 22
111220: PUSH
111221: LD_OWVAR 2
111225: PUSH
111226: EMPTY
111227: LIST
111228: LIST
111229: PPUSH
111230: CALL_OW 69
111234: PPUSH
111235: LD_VAR 0 2
111239: PPUSH
111240: CALL_OW 74
111244: PPUSH
111245: CALL_OW 115
// until IsDead ( un ) ;
111249: LD_VAR 0 2
111253: PPUSH
111254: CALL_OW 301
111258: IFFALSE 111206
// end ;
111260: PPOPN 2
111262: END
// every 0 0$1 trigger StreamModeActive and sStu do
111263: LD_EXP 159
111267: PUSH
111268: LD_EXP 198
111272: AND
111273: IFFALSE 111289
111275: GO 111277
111277: DISABLE
// begin ToLua ( displayStucuk(); ) ;
111278: LD_STRING displayStucuk();
111280: PPUSH
111281: CALL_OW 559
// ResetFog ;
111285: CALL_OW 335
// end ;
111289: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
111290: LD_EXP 159
111294: PUSH
111295: LD_EXP 191
111299: AND
111300: IFFALSE 111441
111302: GO 111304
111304: DISABLE
111305: LD_INT 0
111307: PPUSH
111308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
111309: LD_ADDR_VAR 0 2
111313: PUSH
111314: LD_INT 22
111316: PUSH
111317: LD_OWVAR 2
111321: PUSH
111322: EMPTY
111323: LIST
111324: LIST
111325: PUSH
111326: LD_INT 21
111328: PUSH
111329: LD_INT 1
111331: PUSH
111332: EMPTY
111333: LIST
111334: LIST
111335: PUSH
111336: EMPTY
111337: LIST
111338: LIST
111339: PPUSH
111340: CALL_OW 69
111344: ST_TO_ADDR
// if not tmp then
111345: LD_VAR 0 2
111349: NOT
111350: IFFALSE 111354
// exit ;
111352: GO 111441
// un := tmp [ rand ( 1 , tmp ) ] ;
111354: LD_ADDR_VAR 0 1
111358: PUSH
111359: LD_VAR 0 2
111363: PUSH
111364: LD_INT 1
111366: PPUSH
111367: LD_VAR 0 2
111371: PPUSH
111372: CALL_OW 12
111376: ARRAY
111377: ST_TO_ADDR
// SetSide ( un , 0 ) ;
111378: LD_VAR 0 1
111382: PPUSH
111383: LD_INT 0
111385: PPUSH
111386: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
111390: LD_VAR 0 1
111394: PPUSH
111395: LD_OWVAR 3
111399: PUSH
111400: LD_VAR 0 1
111404: DIFF
111405: PPUSH
111406: LD_VAR 0 1
111410: PPUSH
111411: CALL_OW 74
111415: PPUSH
111416: CALL_OW 115
// wait ( 0 0$20 ) ;
111420: LD_INT 700
111422: PPUSH
111423: CALL_OW 67
// SetSide ( un , your_side ) ;
111427: LD_VAR 0 1
111431: PPUSH
111432: LD_OWVAR 2
111436: PPUSH
111437: CALL_OW 235
// end ;
111441: PPOPN 2
111443: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
111444: LD_EXP 159
111448: PUSH
111449: LD_EXP 192
111453: AND
111454: IFFALSE 111560
111456: GO 111458
111458: DISABLE
111459: LD_INT 0
111461: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
111462: LD_ADDR_VAR 0 1
111466: PUSH
111467: LD_INT 22
111469: PUSH
111470: LD_OWVAR 2
111474: PUSH
111475: EMPTY
111476: LIST
111477: LIST
111478: PUSH
111479: LD_INT 2
111481: PUSH
111482: LD_INT 30
111484: PUSH
111485: LD_INT 0
111487: PUSH
111488: EMPTY
111489: LIST
111490: LIST
111491: PUSH
111492: LD_INT 30
111494: PUSH
111495: LD_INT 1
111497: PUSH
111498: EMPTY
111499: LIST
111500: LIST
111501: PUSH
111502: EMPTY
111503: LIST
111504: LIST
111505: LIST
111506: PUSH
111507: EMPTY
111508: LIST
111509: LIST
111510: PPUSH
111511: CALL_OW 69
111515: ST_TO_ADDR
// if not depot then
111516: LD_VAR 0 1
111520: NOT
111521: IFFALSE 111525
// exit ;
111523: GO 111560
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
111525: LD_VAR 0 1
111529: PUSH
111530: LD_INT 1
111532: ARRAY
111533: PPUSH
111534: CALL_OW 250
111538: PPUSH
111539: LD_VAR 0 1
111543: PUSH
111544: LD_INT 1
111546: ARRAY
111547: PPUSH
111548: CALL_OW 251
111552: PPUSH
111553: LD_INT 70
111555: PPUSH
111556: CALL_OW 495
// end ;
111560: PPOPN 1
111562: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
111563: LD_EXP 159
111567: PUSH
111568: LD_EXP 193
111572: AND
111573: IFFALSE 111784
111575: GO 111577
111577: DISABLE
111578: LD_INT 0
111580: PPUSH
111581: PPUSH
111582: PPUSH
111583: PPUSH
111584: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
111585: LD_ADDR_VAR 0 5
111589: PUSH
111590: LD_INT 22
111592: PUSH
111593: LD_OWVAR 2
111597: PUSH
111598: EMPTY
111599: LIST
111600: LIST
111601: PUSH
111602: LD_INT 21
111604: PUSH
111605: LD_INT 1
111607: PUSH
111608: EMPTY
111609: LIST
111610: LIST
111611: PUSH
111612: EMPTY
111613: LIST
111614: LIST
111615: PPUSH
111616: CALL_OW 69
111620: ST_TO_ADDR
// if not tmp then
111621: LD_VAR 0 5
111625: NOT
111626: IFFALSE 111630
// exit ;
111628: GO 111784
// for i in tmp do
111630: LD_ADDR_VAR 0 1
111634: PUSH
111635: LD_VAR 0 5
111639: PUSH
111640: FOR_IN
111641: IFFALSE 111782
// begin d := rand ( 0 , 5 ) ;
111643: LD_ADDR_VAR 0 4
111647: PUSH
111648: LD_INT 0
111650: PPUSH
111651: LD_INT 5
111653: PPUSH
111654: CALL_OW 12
111658: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
111659: LD_ADDR_VAR 0 2
111663: PUSH
111664: LD_VAR 0 1
111668: PPUSH
111669: CALL_OW 250
111673: PPUSH
111674: LD_VAR 0 4
111678: PPUSH
111679: LD_INT 3
111681: PPUSH
111682: LD_INT 12
111684: PPUSH
111685: CALL_OW 12
111689: PPUSH
111690: CALL_OW 272
111694: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
111695: LD_ADDR_VAR 0 3
111699: PUSH
111700: LD_VAR 0 1
111704: PPUSH
111705: CALL_OW 251
111709: PPUSH
111710: LD_VAR 0 4
111714: PPUSH
111715: LD_INT 3
111717: PPUSH
111718: LD_INT 12
111720: PPUSH
111721: CALL_OW 12
111725: PPUSH
111726: CALL_OW 273
111730: ST_TO_ADDR
// if ValidHex ( x , y ) then
111731: LD_VAR 0 2
111735: PPUSH
111736: LD_VAR 0 3
111740: PPUSH
111741: CALL_OW 488
111745: IFFALSE 111780
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
111747: LD_VAR 0 1
111751: PPUSH
111752: LD_VAR 0 2
111756: PPUSH
111757: LD_VAR 0 3
111761: PPUSH
111762: LD_INT 3
111764: PPUSH
111765: LD_INT 6
111767: PPUSH
111768: CALL_OW 12
111772: PPUSH
111773: LD_INT 1
111775: PPUSH
111776: CALL_OW 483
// end ;
111780: GO 111640
111782: POP
111783: POP
// end ;
111784: PPOPN 5
111786: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
111787: LD_EXP 159
111791: PUSH
111792: LD_EXP 194
111796: AND
111797: IFFALSE 111891
111799: GO 111801
111801: DISABLE
111802: LD_INT 0
111804: PPUSH
111805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
111806: LD_ADDR_VAR 0 2
111810: PUSH
111811: LD_INT 22
111813: PUSH
111814: LD_OWVAR 2
111818: PUSH
111819: EMPTY
111820: LIST
111821: LIST
111822: PUSH
111823: LD_INT 32
111825: PUSH
111826: LD_INT 1
111828: PUSH
111829: EMPTY
111830: LIST
111831: LIST
111832: PUSH
111833: LD_INT 21
111835: PUSH
111836: LD_INT 2
111838: PUSH
111839: EMPTY
111840: LIST
111841: LIST
111842: PUSH
111843: EMPTY
111844: LIST
111845: LIST
111846: LIST
111847: PPUSH
111848: CALL_OW 69
111852: ST_TO_ADDR
// if not tmp then
111853: LD_VAR 0 2
111857: NOT
111858: IFFALSE 111862
// exit ;
111860: GO 111891
// for i in tmp do
111862: LD_ADDR_VAR 0 1
111866: PUSH
111867: LD_VAR 0 2
111871: PUSH
111872: FOR_IN
111873: IFFALSE 111889
// SetFuel ( i , 0 ) ;
111875: LD_VAR 0 1
111879: PPUSH
111880: LD_INT 0
111882: PPUSH
111883: CALL_OW 240
111887: GO 111872
111889: POP
111890: POP
// end ;
111891: PPOPN 2
111893: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
111894: LD_EXP 159
111898: PUSH
111899: LD_EXP 195
111903: AND
111904: IFFALSE 111970
111906: GO 111908
111908: DISABLE
111909: LD_INT 0
111911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111912: LD_ADDR_VAR 0 1
111916: PUSH
111917: LD_INT 22
111919: PUSH
111920: LD_OWVAR 2
111924: PUSH
111925: EMPTY
111926: LIST
111927: LIST
111928: PUSH
111929: LD_INT 30
111931: PUSH
111932: LD_INT 29
111934: PUSH
111935: EMPTY
111936: LIST
111937: LIST
111938: PUSH
111939: EMPTY
111940: LIST
111941: LIST
111942: PPUSH
111943: CALL_OW 69
111947: ST_TO_ADDR
// if not tmp then
111948: LD_VAR 0 1
111952: NOT
111953: IFFALSE 111957
// exit ;
111955: GO 111970
// DestroyUnit ( tmp [ 1 ] ) ;
111957: LD_VAR 0 1
111961: PUSH
111962: LD_INT 1
111964: ARRAY
111965: PPUSH
111966: CALL_OW 65
// end ;
111970: PPOPN 1
111972: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
111973: LD_EXP 159
111977: PUSH
111978: LD_EXP 197
111982: AND
111983: IFFALSE 112112
111985: GO 111987
111987: DISABLE
111988: LD_INT 0
111990: PPUSH
// begin uc_side := 0 ;
111991: LD_ADDR_OWVAR 20
111995: PUSH
111996: LD_INT 0
111998: ST_TO_ADDR
// uc_nation := nation_arabian ;
111999: LD_ADDR_OWVAR 21
112003: PUSH
112004: LD_INT 2
112006: ST_TO_ADDR
// hc_gallery :=  ;
112007: LD_ADDR_OWVAR 33
112011: PUSH
112012: LD_STRING 
112014: ST_TO_ADDR
// hc_name :=  ;
112015: LD_ADDR_OWVAR 26
112019: PUSH
112020: LD_STRING 
112022: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
112023: LD_INT 1
112025: PPUSH
112026: LD_INT 11
112028: PPUSH
112029: LD_INT 10
112031: PPUSH
112032: CALL_OW 380
// un := CreateHuman ;
112036: LD_ADDR_VAR 0 1
112040: PUSH
112041: CALL_OW 44
112045: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112046: LD_VAR 0 1
112050: PPUSH
112051: LD_INT 1
112053: PPUSH
112054: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
112058: LD_INT 35
112060: PPUSH
112061: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
112065: LD_VAR 0 1
112069: PPUSH
112070: LD_INT 22
112072: PUSH
112073: LD_OWVAR 2
112077: PUSH
112078: EMPTY
112079: LIST
112080: LIST
112081: PPUSH
112082: CALL_OW 69
112086: PPUSH
112087: LD_VAR 0 1
112091: PPUSH
112092: CALL_OW 74
112096: PPUSH
112097: CALL_OW 115
// until IsDead ( un ) ;
112101: LD_VAR 0 1
112105: PPUSH
112106: CALL_OW 301
112110: IFFALSE 112058
// end ;
112112: PPOPN 1
112114: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
112115: LD_EXP 159
112119: PUSH
112120: LD_EXP 199
112124: AND
112125: IFFALSE 112137
112127: GO 112129
112129: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
112130: LD_STRING earthquake(getX(game), 0, 32)
112132: PPUSH
112133: CALL_OW 559
112137: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
112138: LD_EXP 159
112142: PUSH
112143: LD_EXP 200
112147: AND
112148: IFFALSE 112239
112150: GO 112152
112152: DISABLE
112153: LD_INT 0
112155: PPUSH
// begin enable ;
112156: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
112157: LD_ADDR_VAR 0 1
112161: PUSH
112162: LD_INT 22
112164: PUSH
112165: LD_OWVAR 2
112169: PUSH
112170: EMPTY
112171: LIST
112172: LIST
112173: PUSH
112174: LD_INT 21
112176: PUSH
112177: LD_INT 2
112179: PUSH
112180: EMPTY
112181: LIST
112182: LIST
112183: PUSH
112184: LD_INT 33
112186: PUSH
112187: LD_INT 3
112189: PUSH
112190: EMPTY
112191: LIST
112192: LIST
112193: PUSH
112194: EMPTY
112195: LIST
112196: LIST
112197: LIST
112198: PPUSH
112199: CALL_OW 69
112203: ST_TO_ADDR
// if not tmp then
112204: LD_VAR 0 1
112208: NOT
112209: IFFALSE 112213
// exit ;
112211: GO 112239
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112213: LD_VAR 0 1
112217: PUSH
112218: LD_INT 1
112220: PPUSH
112221: LD_VAR 0 1
112225: PPUSH
112226: CALL_OW 12
112230: ARRAY
112231: PPUSH
112232: LD_INT 1
112234: PPUSH
112235: CALL_OW 234
// end ;
112239: PPOPN 1
112241: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
112242: LD_EXP 159
112246: PUSH
112247: LD_EXP 201
112251: AND
112252: IFFALSE 112393
112254: GO 112256
112256: DISABLE
112257: LD_INT 0
112259: PPUSH
112260: PPUSH
112261: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112262: LD_ADDR_VAR 0 3
112266: PUSH
112267: LD_INT 22
112269: PUSH
112270: LD_OWVAR 2
112274: PUSH
112275: EMPTY
112276: LIST
112277: LIST
112278: PUSH
112279: LD_INT 25
112281: PUSH
112282: LD_INT 1
112284: PUSH
112285: EMPTY
112286: LIST
112287: LIST
112288: PUSH
112289: EMPTY
112290: LIST
112291: LIST
112292: PPUSH
112293: CALL_OW 69
112297: ST_TO_ADDR
// if not tmp then
112298: LD_VAR 0 3
112302: NOT
112303: IFFALSE 112307
// exit ;
112305: GO 112393
// un := tmp [ rand ( 1 , tmp ) ] ;
112307: LD_ADDR_VAR 0 2
112311: PUSH
112312: LD_VAR 0 3
112316: PUSH
112317: LD_INT 1
112319: PPUSH
112320: LD_VAR 0 3
112324: PPUSH
112325: CALL_OW 12
112329: ARRAY
112330: ST_TO_ADDR
// if Crawls ( un ) then
112331: LD_VAR 0 2
112335: PPUSH
112336: CALL_OW 318
112340: IFFALSE 112351
// ComWalk ( un ) ;
112342: LD_VAR 0 2
112346: PPUSH
112347: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
112351: LD_VAR 0 2
112355: PPUSH
112356: LD_INT 9
112358: PPUSH
112359: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
112363: LD_INT 28
112365: PPUSH
112366: LD_OWVAR 2
112370: PPUSH
112371: LD_INT 2
112373: PPUSH
112374: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
112378: LD_INT 29
112380: PPUSH
112381: LD_OWVAR 2
112385: PPUSH
112386: LD_INT 2
112388: PPUSH
112389: CALL_OW 322
// end ;
112393: PPOPN 3
112395: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
112396: LD_EXP 159
112400: PUSH
112401: LD_EXP 202
112405: AND
112406: IFFALSE 112517
112408: GO 112410
112410: DISABLE
112411: LD_INT 0
112413: PPUSH
112414: PPUSH
112415: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112416: LD_ADDR_VAR 0 3
112420: PUSH
112421: LD_INT 22
112423: PUSH
112424: LD_OWVAR 2
112428: PUSH
112429: EMPTY
112430: LIST
112431: LIST
112432: PUSH
112433: LD_INT 25
112435: PUSH
112436: LD_INT 1
112438: PUSH
112439: EMPTY
112440: LIST
112441: LIST
112442: PUSH
112443: EMPTY
112444: LIST
112445: LIST
112446: PPUSH
112447: CALL_OW 69
112451: ST_TO_ADDR
// if not tmp then
112452: LD_VAR 0 3
112456: NOT
112457: IFFALSE 112461
// exit ;
112459: GO 112517
// un := tmp [ rand ( 1 , tmp ) ] ;
112461: LD_ADDR_VAR 0 2
112465: PUSH
112466: LD_VAR 0 3
112470: PUSH
112471: LD_INT 1
112473: PPUSH
112474: LD_VAR 0 3
112478: PPUSH
112479: CALL_OW 12
112483: ARRAY
112484: ST_TO_ADDR
// if Crawls ( un ) then
112485: LD_VAR 0 2
112489: PPUSH
112490: CALL_OW 318
112494: IFFALSE 112505
// ComWalk ( un ) ;
112496: LD_VAR 0 2
112500: PPUSH
112501: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112505: LD_VAR 0 2
112509: PPUSH
112510: LD_INT 8
112512: PPUSH
112513: CALL_OW 336
// end ;
112517: PPOPN 3
112519: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
112520: LD_EXP 159
112524: PUSH
112525: LD_EXP 203
112529: AND
112530: IFFALSE 112674
112532: GO 112534
112534: DISABLE
112535: LD_INT 0
112537: PPUSH
112538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
112539: LD_ADDR_VAR 0 2
112543: PUSH
112544: LD_INT 22
112546: PUSH
112547: LD_OWVAR 2
112551: PUSH
112552: EMPTY
112553: LIST
112554: LIST
112555: PUSH
112556: LD_INT 21
112558: PUSH
112559: LD_INT 2
112561: PUSH
112562: EMPTY
112563: LIST
112564: LIST
112565: PUSH
112566: LD_INT 2
112568: PUSH
112569: LD_INT 34
112571: PUSH
112572: LD_INT 12
112574: PUSH
112575: EMPTY
112576: LIST
112577: LIST
112578: PUSH
112579: LD_INT 34
112581: PUSH
112582: LD_INT 51
112584: PUSH
112585: EMPTY
112586: LIST
112587: LIST
112588: PUSH
112589: LD_INT 34
112591: PUSH
112592: LD_INT 32
112594: PUSH
112595: EMPTY
112596: LIST
112597: LIST
112598: PUSH
112599: EMPTY
112600: LIST
112601: LIST
112602: LIST
112603: LIST
112604: PUSH
112605: EMPTY
112606: LIST
112607: LIST
112608: LIST
112609: PPUSH
112610: CALL_OW 69
112614: ST_TO_ADDR
// if not tmp then
112615: LD_VAR 0 2
112619: NOT
112620: IFFALSE 112624
// exit ;
112622: GO 112674
// for i in tmp do
112624: LD_ADDR_VAR 0 1
112628: PUSH
112629: LD_VAR 0 2
112633: PUSH
112634: FOR_IN
112635: IFFALSE 112672
// if GetCargo ( i , mat_artifact ) = 0 then
112637: LD_VAR 0 1
112641: PPUSH
112642: LD_INT 4
112644: PPUSH
112645: CALL_OW 289
112649: PUSH
112650: LD_INT 0
112652: EQUAL
112653: IFFALSE 112670
// SetCargo ( i , mat_siberit , 100 ) ;
112655: LD_VAR 0 1
112659: PPUSH
112660: LD_INT 3
112662: PPUSH
112663: LD_INT 100
112665: PPUSH
112666: CALL_OW 290
112670: GO 112634
112672: POP
112673: POP
// end ;
112674: PPOPN 2
112676: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
112677: LD_EXP 159
112681: PUSH
112682: LD_EXP 204
112686: AND
112687: IFFALSE 112870
112689: GO 112691
112691: DISABLE
112692: LD_INT 0
112694: PPUSH
112695: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112696: LD_ADDR_VAR 0 2
112700: PUSH
112701: LD_INT 22
112703: PUSH
112704: LD_OWVAR 2
112708: PUSH
112709: EMPTY
112710: LIST
112711: LIST
112712: PPUSH
112713: CALL_OW 69
112717: ST_TO_ADDR
// if not tmp then
112718: LD_VAR 0 2
112722: NOT
112723: IFFALSE 112727
// exit ;
112725: GO 112870
// for i := 1 to 2 do
112727: LD_ADDR_VAR 0 1
112731: PUSH
112732: DOUBLE
112733: LD_INT 1
112735: DEC
112736: ST_TO_ADDR
112737: LD_INT 2
112739: PUSH
112740: FOR_TO
112741: IFFALSE 112868
// begin uc_side := your_side ;
112743: LD_ADDR_OWVAR 20
112747: PUSH
112748: LD_OWVAR 2
112752: ST_TO_ADDR
// uc_nation := nation_american ;
112753: LD_ADDR_OWVAR 21
112757: PUSH
112758: LD_INT 1
112760: ST_TO_ADDR
// vc_chassis := us_morphling ;
112761: LD_ADDR_OWVAR 37
112765: PUSH
112766: LD_INT 5
112768: ST_TO_ADDR
// vc_engine := engine_siberite ;
112769: LD_ADDR_OWVAR 39
112773: PUSH
112774: LD_INT 3
112776: ST_TO_ADDR
// vc_control := control_computer ;
112777: LD_ADDR_OWVAR 38
112781: PUSH
112782: LD_INT 3
112784: ST_TO_ADDR
// vc_weapon := us_double_laser ;
112785: LD_ADDR_OWVAR 40
112789: PUSH
112790: LD_INT 10
112792: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
112793: LD_VAR 0 2
112797: PUSH
112798: LD_INT 1
112800: ARRAY
112801: PPUSH
112802: CALL_OW 310
112806: NOT
112807: IFFALSE 112854
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
112809: CALL_OW 45
112813: PPUSH
112814: LD_VAR 0 2
112818: PUSH
112819: LD_INT 1
112821: ARRAY
112822: PPUSH
112823: CALL_OW 250
112827: PPUSH
112828: LD_VAR 0 2
112832: PUSH
112833: LD_INT 1
112835: ARRAY
112836: PPUSH
112837: CALL_OW 251
112841: PPUSH
112842: LD_INT 12
112844: PPUSH
112845: LD_INT 1
112847: PPUSH
112848: CALL_OW 50
112852: GO 112866
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
112854: CALL_OW 45
112858: PPUSH
112859: LD_INT 1
112861: PPUSH
112862: CALL_OW 51
// end ;
112866: GO 112740
112868: POP
112869: POP
// end ;
112870: PPOPN 2
112872: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
112873: LD_EXP 159
112877: PUSH
112878: LD_EXP 205
112882: AND
112883: IFFALSE 113105
112885: GO 112887
112887: DISABLE
112888: LD_INT 0
112890: PPUSH
112891: PPUSH
112892: PPUSH
112893: PPUSH
112894: PPUSH
112895: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112896: LD_ADDR_VAR 0 6
112900: PUSH
112901: LD_INT 22
112903: PUSH
112904: LD_OWVAR 2
112908: PUSH
112909: EMPTY
112910: LIST
112911: LIST
112912: PUSH
112913: LD_INT 21
112915: PUSH
112916: LD_INT 1
112918: PUSH
112919: EMPTY
112920: LIST
112921: LIST
112922: PUSH
112923: LD_INT 3
112925: PUSH
112926: LD_INT 23
112928: PUSH
112929: LD_INT 0
112931: PUSH
112932: EMPTY
112933: LIST
112934: LIST
112935: PUSH
112936: EMPTY
112937: LIST
112938: LIST
112939: PUSH
112940: EMPTY
112941: LIST
112942: LIST
112943: LIST
112944: PPUSH
112945: CALL_OW 69
112949: ST_TO_ADDR
// if not tmp then
112950: LD_VAR 0 6
112954: NOT
112955: IFFALSE 112959
// exit ;
112957: GO 113105
// s1 := rand ( 1 , 4 ) ;
112959: LD_ADDR_VAR 0 2
112963: PUSH
112964: LD_INT 1
112966: PPUSH
112967: LD_INT 4
112969: PPUSH
112970: CALL_OW 12
112974: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
112975: LD_ADDR_VAR 0 4
112979: PUSH
112980: LD_VAR 0 6
112984: PUSH
112985: LD_INT 1
112987: ARRAY
112988: PPUSH
112989: LD_VAR 0 2
112993: PPUSH
112994: CALL_OW 259
112998: ST_TO_ADDR
// if s1 = 1 then
112999: LD_VAR 0 2
113003: PUSH
113004: LD_INT 1
113006: EQUAL
113007: IFFALSE 113027
// s2 := rand ( 2 , 4 ) else
113009: LD_ADDR_VAR 0 3
113013: PUSH
113014: LD_INT 2
113016: PPUSH
113017: LD_INT 4
113019: PPUSH
113020: CALL_OW 12
113024: ST_TO_ADDR
113025: GO 113035
// s2 := 1 ;
113027: LD_ADDR_VAR 0 3
113031: PUSH
113032: LD_INT 1
113034: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
113035: LD_ADDR_VAR 0 5
113039: PUSH
113040: LD_VAR 0 6
113044: PUSH
113045: LD_INT 1
113047: ARRAY
113048: PPUSH
113049: LD_VAR 0 3
113053: PPUSH
113054: CALL_OW 259
113058: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
113059: LD_VAR 0 6
113063: PUSH
113064: LD_INT 1
113066: ARRAY
113067: PPUSH
113068: LD_VAR 0 2
113072: PPUSH
113073: LD_VAR 0 5
113077: PPUSH
113078: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
113082: LD_VAR 0 6
113086: PUSH
113087: LD_INT 1
113089: ARRAY
113090: PPUSH
113091: LD_VAR 0 3
113095: PPUSH
113096: LD_VAR 0 4
113100: PPUSH
113101: CALL_OW 237
// end ;
113105: PPOPN 6
113107: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
113108: LD_EXP 159
113112: PUSH
113113: LD_EXP 206
113117: AND
113118: IFFALSE 113197
113120: GO 113122
113122: DISABLE
113123: LD_INT 0
113125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
113126: LD_ADDR_VAR 0 1
113130: PUSH
113131: LD_INT 22
113133: PUSH
113134: LD_OWVAR 2
113138: PUSH
113139: EMPTY
113140: LIST
113141: LIST
113142: PUSH
113143: LD_INT 30
113145: PUSH
113146: LD_INT 3
113148: PUSH
113149: EMPTY
113150: LIST
113151: LIST
113152: PUSH
113153: EMPTY
113154: LIST
113155: LIST
113156: PPUSH
113157: CALL_OW 69
113161: ST_TO_ADDR
// if not tmp then
113162: LD_VAR 0 1
113166: NOT
113167: IFFALSE 113171
// exit ;
113169: GO 113197
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
113171: LD_VAR 0 1
113175: PUSH
113176: LD_INT 1
113178: PPUSH
113179: LD_VAR 0 1
113183: PPUSH
113184: CALL_OW 12
113188: ARRAY
113189: PPUSH
113190: LD_INT 1
113192: PPUSH
113193: CALL_OW 234
// end ;
113197: PPOPN 1
113199: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
113200: LD_EXP 159
113204: PUSH
113205: LD_EXP 207
113209: AND
113210: IFFALSE 113322
113212: GO 113214
113214: DISABLE
113215: LD_INT 0
113217: PPUSH
113218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
113219: LD_ADDR_VAR 0 2
113223: PUSH
113224: LD_INT 22
113226: PUSH
113227: LD_OWVAR 2
113231: PUSH
113232: EMPTY
113233: LIST
113234: LIST
113235: PUSH
113236: LD_INT 2
113238: PUSH
113239: LD_INT 30
113241: PUSH
113242: LD_INT 27
113244: PUSH
113245: EMPTY
113246: LIST
113247: LIST
113248: PUSH
113249: LD_INT 30
113251: PUSH
113252: LD_INT 26
113254: PUSH
113255: EMPTY
113256: LIST
113257: LIST
113258: PUSH
113259: LD_INT 30
113261: PUSH
113262: LD_INT 28
113264: PUSH
113265: EMPTY
113266: LIST
113267: LIST
113268: PUSH
113269: EMPTY
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: PUSH
113275: EMPTY
113276: LIST
113277: LIST
113278: PPUSH
113279: CALL_OW 69
113283: ST_TO_ADDR
// if not tmp then
113284: LD_VAR 0 2
113288: NOT
113289: IFFALSE 113293
// exit ;
113291: GO 113322
// for i in tmp do
113293: LD_ADDR_VAR 0 1
113297: PUSH
113298: LD_VAR 0 2
113302: PUSH
113303: FOR_IN
113304: IFFALSE 113320
// SetLives ( i , 1 ) ;
113306: LD_VAR 0 1
113310: PPUSH
113311: LD_INT 1
113313: PPUSH
113314: CALL_OW 234
113318: GO 113303
113320: POP
113321: POP
// end ;
113322: PPOPN 2
113324: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
113325: LD_EXP 159
113329: PUSH
113330: LD_EXP 208
113334: AND
113335: IFFALSE 113609
113337: GO 113339
113339: DISABLE
113340: LD_INT 0
113342: PPUSH
113343: PPUSH
113344: PPUSH
// begin i := rand ( 1 , 7 ) ;
113345: LD_ADDR_VAR 0 1
113349: PUSH
113350: LD_INT 1
113352: PPUSH
113353: LD_INT 7
113355: PPUSH
113356: CALL_OW 12
113360: ST_TO_ADDR
// case i of 1 :
113361: LD_VAR 0 1
113365: PUSH
113366: LD_INT 1
113368: DOUBLE
113369: EQUAL
113370: IFTRUE 113374
113372: GO 113384
113374: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
113375: LD_STRING earthquake(getX(game), 0, 32)
113377: PPUSH
113378: CALL_OW 559
113382: GO 113609
113384: LD_INT 2
113386: DOUBLE
113387: EQUAL
113388: IFTRUE 113392
113390: GO 113406
113392: POP
// begin ToLua ( displayStucuk(); ) ;
113393: LD_STRING displayStucuk();
113395: PPUSH
113396: CALL_OW 559
// ResetFog ;
113400: CALL_OW 335
// end ; 3 :
113404: GO 113609
113406: LD_INT 3
113408: DOUBLE
113409: EQUAL
113410: IFTRUE 113414
113412: GO 113518
113414: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113415: LD_ADDR_VAR 0 2
113419: PUSH
113420: LD_INT 22
113422: PUSH
113423: LD_OWVAR 2
113427: PUSH
113428: EMPTY
113429: LIST
113430: LIST
113431: PUSH
113432: LD_INT 25
113434: PUSH
113435: LD_INT 1
113437: PUSH
113438: EMPTY
113439: LIST
113440: LIST
113441: PUSH
113442: EMPTY
113443: LIST
113444: LIST
113445: PPUSH
113446: CALL_OW 69
113450: ST_TO_ADDR
// if not tmp then
113451: LD_VAR 0 2
113455: NOT
113456: IFFALSE 113460
// exit ;
113458: GO 113609
// un := tmp [ rand ( 1 , tmp ) ] ;
113460: LD_ADDR_VAR 0 3
113464: PUSH
113465: LD_VAR 0 2
113469: PUSH
113470: LD_INT 1
113472: PPUSH
113473: LD_VAR 0 2
113477: PPUSH
113478: CALL_OW 12
113482: ARRAY
113483: ST_TO_ADDR
// if Crawls ( un ) then
113484: LD_VAR 0 3
113488: PPUSH
113489: CALL_OW 318
113493: IFFALSE 113504
// ComWalk ( un ) ;
113495: LD_VAR 0 3
113499: PPUSH
113500: CALL_OW 138
// SetClass ( un , class_mortar ) ;
113504: LD_VAR 0 3
113508: PPUSH
113509: LD_INT 8
113511: PPUSH
113512: CALL_OW 336
// end ; 4 :
113516: GO 113609
113518: LD_INT 4
113520: DOUBLE
113521: EQUAL
113522: IFTRUE 113526
113524: GO 113587
113526: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
113527: LD_ADDR_VAR 0 2
113531: PUSH
113532: LD_INT 22
113534: PUSH
113535: LD_OWVAR 2
113539: PUSH
113540: EMPTY
113541: LIST
113542: LIST
113543: PUSH
113544: LD_INT 30
113546: PUSH
113547: LD_INT 29
113549: PUSH
113550: EMPTY
113551: LIST
113552: LIST
113553: PUSH
113554: EMPTY
113555: LIST
113556: LIST
113557: PPUSH
113558: CALL_OW 69
113562: ST_TO_ADDR
// if not tmp then
113563: LD_VAR 0 2
113567: NOT
113568: IFFALSE 113572
// exit ;
113570: GO 113609
// DestroyUnit ( tmp [ 1 ] ) ;
113572: LD_VAR 0 2
113576: PUSH
113577: LD_INT 1
113579: ARRAY
113580: PPUSH
113581: CALL_OW 65
// end ; 5 .. 7 :
113585: GO 113609
113587: LD_INT 5
113589: DOUBLE
113590: GREATEREQUAL
113591: IFFALSE 113599
113593: LD_INT 7
113595: DOUBLE
113596: LESSEQUAL
113597: IFTRUE 113601
113599: GO 113608
113601: POP
// StreamSibBomb ; end ;
113602: CALL 109859 0 0
113606: GO 113609
113608: POP
// end ;
113609: PPOPN 3
113611: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
113612: LD_EXP 159
113616: PUSH
113617: LD_EXP 209
113621: AND
113622: IFFALSE 113778
113624: GO 113626
113626: DISABLE
113627: LD_INT 0
113629: PPUSH
113630: PPUSH
113631: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
113632: LD_ADDR_VAR 0 2
113636: PUSH
113637: LD_INT 81
113639: PUSH
113640: LD_OWVAR 2
113644: PUSH
113645: EMPTY
113646: LIST
113647: LIST
113648: PUSH
113649: LD_INT 2
113651: PUSH
113652: LD_INT 21
113654: PUSH
113655: LD_INT 1
113657: PUSH
113658: EMPTY
113659: LIST
113660: LIST
113661: PUSH
113662: LD_INT 21
113664: PUSH
113665: LD_INT 2
113667: PUSH
113668: EMPTY
113669: LIST
113670: LIST
113671: PUSH
113672: EMPTY
113673: LIST
113674: LIST
113675: LIST
113676: PUSH
113677: EMPTY
113678: LIST
113679: LIST
113680: PPUSH
113681: CALL_OW 69
113685: ST_TO_ADDR
// if not tmp then
113686: LD_VAR 0 2
113690: NOT
113691: IFFALSE 113695
// exit ;
113693: GO 113778
// p := 0 ;
113695: LD_ADDR_VAR 0 3
113699: PUSH
113700: LD_INT 0
113702: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113703: LD_INT 35
113705: PPUSH
113706: CALL_OW 67
// p := p + 1 ;
113710: LD_ADDR_VAR 0 3
113714: PUSH
113715: LD_VAR 0 3
113719: PUSH
113720: LD_INT 1
113722: PLUS
113723: ST_TO_ADDR
// for i in tmp do
113724: LD_ADDR_VAR 0 1
113728: PUSH
113729: LD_VAR 0 2
113733: PUSH
113734: FOR_IN
113735: IFFALSE 113766
// if GetLives ( i ) < 1000 then
113737: LD_VAR 0 1
113741: PPUSH
113742: CALL_OW 256
113746: PUSH
113747: LD_INT 1000
113749: LESS
113750: IFFALSE 113764
// SetLives ( i , 1000 ) ;
113752: LD_VAR 0 1
113756: PPUSH
113757: LD_INT 1000
113759: PPUSH
113760: CALL_OW 234
113764: GO 113734
113766: POP
113767: POP
// until p > 20 ;
113768: LD_VAR 0 3
113772: PUSH
113773: LD_INT 20
113775: GREATER
113776: IFFALSE 113703
// end ;
113778: PPOPN 3
113780: END
// every 0 0$1 trigger StreamModeActive and sTime do
113781: LD_EXP 159
113785: PUSH
113786: LD_EXP 210
113790: AND
113791: IFFALSE 113826
113793: GO 113795
113795: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
113796: LD_INT 28
113798: PPUSH
113799: LD_OWVAR 2
113803: PPUSH
113804: LD_INT 2
113806: PPUSH
113807: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
113811: LD_INT 30
113813: PPUSH
113814: LD_OWVAR 2
113818: PPUSH
113819: LD_INT 2
113821: PPUSH
113822: CALL_OW 322
// end ;
113826: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
113827: LD_EXP 159
113831: PUSH
113832: LD_EXP 211
113836: AND
113837: IFFALSE 113958
113839: GO 113841
113841: DISABLE
113842: LD_INT 0
113844: PPUSH
113845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113846: LD_ADDR_VAR 0 2
113850: PUSH
113851: LD_INT 22
113853: PUSH
113854: LD_OWVAR 2
113858: PUSH
113859: EMPTY
113860: LIST
113861: LIST
113862: PUSH
113863: LD_INT 21
113865: PUSH
113866: LD_INT 1
113868: PUSH
113869: EMPTY
113870: LIST
113871: LIST
113872: PUSH
113873: LD_INT 3
113875: PUSH
113876: LD_INT 23
113878: PUSH
113879: LD_INT 0
113881: PUSH
113882: EMPTY
113883: LIST
113884: LIST
113885: PUSH
113886: EMPTY
113887: LIST
113888: LIST
113889: PUSH
113890: EMPTY
113891: LIST
113892: LIST
113893: LIST
113894: PPUSH
113895: CALL_OW 69
113899: ST_TO_ADDR
// if not tmp then
113900: LD_VAR 0 2
113904: NOT
113905: IFFALSE 113909
// exit ;
113907: GO 113958
// for i in tmp do
113909: LD_ADDR_VAR 0 1
113913: PUSH
113914: LD_VAR 0 2
113918: PUSH
113919: FOR_IN
113920: IFFALSE 113956
// begin if Crawls ( i ) then
113922: LD_VAR 0 1
113926: PPUSH
113927: CALL_OW 318
113931: IFFALSE 113942
// ComWalk ( i ) ;
113933: LD_VAR 0 1
113937: PPUSH
113938: CALL_OW 138
// SetClass ( i , 2 ) ;
113942: LD_VAR 0 1
113946: PPUSH
113947: LD_INT 2
113949: PPUSH
113950: CALL_OW 336
// end ;
113954: GO 113919
113956: POP
113957: POP
// end ;
113958: PPOPN 2
113960: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
113961: LD_EXP 159
113965: PUSH
113966: LD_EXP 212
113970: AND
113971: IFFALSE 114252
113973: GO 113975
113975: DISABLE
113976: LD_INT 0
113978: PPUSH
113979: PPUSH
113980: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
113981: LD_OWVAR 2
113985: PPUSH
113986: LD_INT 9
113988: PPUSH
113989: LD_INT 1
113991: PPUSH
113992: LD_INT 1
113994: PPUSH
113995: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
113999: LD_INT 9
114001: PPUSH
114002: LD_OWVAR 2
114006: PPUSH
114007: CALL_OW 343
// uc_side := 9 ;
114011: LD_ADDR_OWVAR 20
114015: PUSH
114016: LD_INT 9
114018: ST_TO_ADDR
// uc_nation := 2 ;
114019: LD_ADDR_OWVAR 21
114023: PUSH
114024: LD_INT 2
114026: ST_TO_ADDR
// hc_name := Dark Warrior ;
114027: LD_ADDR_OWVAR 26
114031: PUSH
114032: LD_STRING Dark Warrior
114034: ST_TO_ADDR
// hc_gallery :=  ;
114035: LD_ADDR_OWVAR 33
114039: PUSH
114040: LD_STRING 
114042: ST_TO_ADDR
// hc_noskilllimit := true ;
114043: LD_ADDR_OWVAR 76
114047: PUSH
114048: LD_INT 1
114050: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
114051: LD_ADDR_OWVAR 31
114055: PUSH
114056: LD_INT 30
114058: PUSH
114059: LD_INT 30
114061: PUSH
114062: LD_INT 30
114064: PUSH
114065: LD_INT 30
114067: PUSH
114068: EMPTY
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: ST_TO_ADDR
// un := CreateHuman ;
114074: LD_ADDR_VAR 0 3
114078: PUSH
114079: CALL_OW 44
114083: ST_TO_ADDR
// hc_noskilllimit := false ;
114084: LD_ADDR_OWVAR 76
114088: PUSH
114089: LD_INT 0
114091: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114092: LD_VAR 0 3
114096: PPUSH
114097: LD_INT 1
114099: PPUSH
114100: CALL_OW 51
// p := 0 ;
114104: LD_ADDR_VAR 0 2
114108: PUSH
114109: LD_INT 0
114111: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
114112: LD_INT 35
114114: PPUSH
114115: CALL_OW 67
// p := p + 1 ;
114119: LD_ADDR_VAR 0 2
114123: PUSH
114124: LD_VAR 0 2
114128: PUSH
114129: LD_INT 1
114131: PLUS
114132: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
114133: LD_VAR 0 3
114137: PPUSH
114138: CALL_OW 256
114142: PUSH
114143: LD_INT 1000
114145: LESS
114146: IFFALSE 114160
// SetLives ( un , 1000 ) ;
114148: LD_VAR 0 3
114152: PPUSH
114153: LD_INT 1000
114155: PPUSH
114156: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
114160: LD_VAR 0 3
114164: PPUSH
114165: LD_INT 81
114167: PUSH
114168: LD_OWVAR 2
114172: PUSH
114173: EMPTY
114174: LIST
114175: LIST
114176: PUSH
114177: LD_INT 91
114179: PUSH
114180: LD_VAR 0 3
114184: PUSH
114185: LD_INT 30
114187: PUSH
114188: EMPTY
114189: LIST
114190: LIST
114191: LIST
114192: PUSH
114193: EMPTY
114194: LIST
114195: LIST
114196: PPUSH
114197: CALL_OW 69
114201: PPUSH
114202: LD_VAR 0 3
114206: PPUSH
114207: CALL_OW 74
114211: PPUSH
114212: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
114216: LD_VAR 0 2
114220: PUSH
114221: LD_INT 60
114223: GREATER
114224: PUSH
114225: LD_VAR 0 3
114229: PPUSH
114230: CALL_OW 301
114234: OR
114235: IFFALSE 114112
// if un then
114237: LD_VAR 0 3
114241: IFFALSE 114252
// RemoveUnit ( un ) ;
114243: LD_VAR 0 3
114247: PPUSH
114248: CALL_OW 64
// end ;
114252: PPOPN 3
114254: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
114255: LD_INT 0
114257: PPUSH
// case cmd of 301 :
114258: LD_VAR 0 1
114262: PUSH
114263: LD_INT 301
114265: DOUBLE
114266: EQUAL
114267: IFTRUE 114271
114269: GO 114303
114271: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
114272: LD_VAR 0 6
114276: PPUSH
114277: LD_VAR 0 7
114281: PPUSH
114282: LD_VAR 0 8
114286: PPUSH
114287: LD_VAR 0 4
114291: PPUSH
114292: LD_VAR 0 5
114296: PPUSH
114297: CALL 115504 0 5
114301: GO 114424
114303: LD_INT 302
114305: DOUBLE
114306: EQUAL
114307: IFTRUE 114311
114309: GO 114348
114311: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
114312: LD_VAR 0 6
114316: PPUSH
114317: LD_VAR 0 7
114321: PPUSH
114322: LD_VAR 0 8
114326: PPUSH
114327: LD_VAR 0 9
114331: PPUSH
114332: LD_VAR 0 4
114336: PPUSH
114337: LD_VAR 0 5
114341: PPUSH
114342: CALL 115595 0 6
114346: GO 114424
114348: LD_INT 303
114350: DOUBLE
114351: EQUAL
114352: IFTRUE 114356
114354: GO 114393
114356: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
114357: LD_VAR 0 6
114361: PPUSH
114362: LD_VAR 0 7
114366: PPUSH
114367: LD_VAR 0 8
114371: PPUSH
114372: LD_VAR 0 9
114376: PPUSH
114377: LD_VAR 0 4
114381: PPUSH
114382: LD_VAR 0 5
114386: PPUSH
114387: CALL 114429 0 6
114391: GO 114424
114393: LD_INT 304
114395: DOUBLE
114396: EQUAL
114397: IFTRUE 114401
114399: GO 114423
114401: POP
// hHackTeleport ( unit , x , y ) ; end ;
114402: LD_VAR 0 2
114406: PPUSH
114407: LD_VAR 0 4
114411: PPUSH
114412: LD_VAR 0 5
114416: PPUSH
114417: CALL 116188 0 3
114421: GO 114424
114423: POP
// end ;
114424: LD_VAR 0 12
114428: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
114429: LD_INT 0
114431: PPUSH
114432: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
114433: LD_VAR 0 1
114437: PUSH
114438: LD_INT 1
114440: LESS
114441: PUSH
114442: LD_VAR 0 1
114446: PUSH
114447: LD_INT 3
114449: GREATER
114450: OR
114451: PUSH
114452: LD_VAR 0 5
114456: PPUSH
114457: LD_VAR 0 6
114461: PPUSH
114462: CALL_OW 428
114466: OR
114467: IFFALSE 114471
// exit ;
114469: GO 115191
// uc_side := your_side ;
114471: LD_ADDR_OWVAR 20
114475: PUSH
114476: LD_OWVAR 2
114480: ST_TO_ADDR
// uc_nation := nation ;
114481: LD_ADDR_OWVAR 21
114485: PUSH
114486: LD_VAR 0 1
114490: ST_TO_ADDR
// bc_level = 1 ;
114491: LD_ADDR_OWVAR 43
114495: PUSH
114496: LD_INT 1
114498: ST_TO_ADDR
// case btype of 1 :
114499: LD_VAR 0 2
114503: PUSH
114504: LD_INT 1
114506: DOUBLE
114507: EQUAL
114508: IFTRUE 114512
114510: GO 114523
114512: POP
// bc_type := b_depot ; 2 :
114513: LD_ADDR_OWVAR 42
114517: PUSH
114518: LD_INT 0
114520: ST_TO_ADDR
114521: GO 115135
114523: LD_INT 2
114525: DOUBLE
114526: EQUAL
114527: IFTRUE 114531
114529: GO 114542
114531: POP
// bc_type := b_warehouse ; 3 :
114532: LD_ADDR_OWVAR 42
114536: PUSH
114537: LD_INT 1
114539: ST_TO_ADDR
114540: GO 115135
114542: LD_INT 3
114544: DOUBLE
114545: EQUAL
114546: IFTRUE 114550
114548: GO 114561
114550: POP
// bc_type := b_lab ; 4 .. 9 :
114551: LD_ADDR_OWVAR 42
114555: PUSH
114556: LD_INT 6
114558: ST_TO_ADDR
114559: GO 115135
114561: LD_INT 4
114563: DOUBLE
114564: GREATEREQUAL
114565: IFFALSE 114573
114567: LD_INT 9
114569: DOUBLE
114570: LESSEQUAL
114571: IFTRUE 114575
114573: GO 114627
114575: POP
// begin bc_type := b_lab_half ;
114576: LD_ADDR_OWVAR 42
114580: PUSH
114581: LD_INT 7
114583: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
114584: LD_ADDR_OWVAR 44
114588: PUSH
114589: LD_INT 10
114591: PUSH
114592: LD_INT 11
114594: PUSH
114595: LD_INT 12
114597: PUSH
114598: LD_INT 15
114600: PUSH
114601: LD_INT 14
114603: PUSH
114604: LD_INT 13
114606: PUSH
114607: EMPTY
114608: LIST
114609: LIST
114610: LIST
114611: LIST
114612: LIST
114613: LIST
114614: PUSH
114615: LD_VAR 0 2
114619: PUSH
114620: LD_INT 3
114622: MINUS
114623: ARRAY
114624: ST_TO_ADDR
// end ; 10 .. 13 :
114625: GO 115135
114627: LD_INT 10
114629: DOUBLE
114630: GREATEREQUAL
114631: IFFALSE 114639
114633: LD_INT 13
114635: DOUBLE
114636: LESSEQUAL
114637: IFTRUE 114641
114639: GO 114718
114641: POP
// begin bc_type := b_lab_full ;
114642: LD_ADDR_OWVAR 42
114646: PUSH
114647: LD_INT 8
114649: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
114650: LD_ADDR_OWVAR 44
114654: PUSH
114655: LD_INT 10
114657: PUSH
114658: LD_INT 12
114660: PUSH
114661: LD_INT 14
114663: PUSH
114664: LD_INT 13
114666: PUSH
114667: EMPTY
114668: LIST
114669: LIST
114670: LIST
114671: LIST
114672: PUSH
114673: LD_VAR 0 2
114677: PUSH
114678: LD_INT 9
114680: MINUS
114681: ARRAY
114682: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
114683: LD_ADDR_OWVAR 45
114687: PUSH
114688: LD_INT 11
114690: PUSH
114691: LD_INT 15
114693: PUSH
114694: LD_INT 12
114696: PUSH
114697: LD_INT 15
114699: PUSH
114700: EMPTY
114701: LIST
114702: LIST
114703: LIST
114704: LIST
114705: PUSH
114706: LD_VAR 0 2
114710: PUSH
114711: LD_INT 9
114713: MINUS
114714: ARRAY
114715: ST_TO_ADDR
// end ; 14 :
114716: GO 115135
114718: LD_INT 14
114720: DOUBLE
114721: EQUAL
114722: IFTRUE 114726
114724: GO 114737
114726: POP
// bc_type := b_workshop ; 15 :
114727: LD_ADDR_OWVAR 42
114731: PUSH
114732: LD_INT 2
114734: ST_TO_ADDR
114735: GO 115135
114737: LD_INT 15
114739: DOUBLE
114740: EQUAL
114741: IFTRUE 114745
114743: GO 114756
114745: POP
// bc_type := b_factory ; 16 :
114746: LD_ADDR_OWVAR 42
114750: PUSH
114751: LD_INT 3
114753: ST_TO_ADDR
114754: GO 115135
114756: LD_INT 16
114758: DOUBLE
114759: EQUAL
114760: IFTRUE 114764
114762: GO 114775
114764: POP
// bc_type := b_ext_gun ; 17 :
114765: LD_ADDR_OWVAR 42
114769: PUSH
114770: LD_INT 17
114772: ST_TO_ADDR
114773: GO 115135
114775: LD_INT 17
114777: DOUBLE
114778: EQUAL
114779: IFTRUE 114783
114781: GO 114811
114783: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
114784: LD_ADDR_OWVAR 42
114788: PUSH
114789: LD_INT 19
114791: PUSH
114792: LD_INT 23
114794: PUSH
114795: LD_INT 19
114797: PUSH
114798: EMPTY
114799: LIST
114800: LIST
114801: LIST
114802: PUSH
114803: LD_VAR 0 1
114807: ARRAY
114808: ST_TO_ADDR
114809: GO 115135
114811: LD_INT 18
114813: DOUBLE
114814: EQUAL
114815: IFTRUE 114819
114817: GO 114830
114819: POP
// bc_type := b_ext_radar ; 19 :
114820: LD_ADDR_OWVAR 42
114824: PUSH
114825: LD_INT 20
114827: ST_TO_ADDR
114828: GO 115135
114830: LD_INT 19
114832: DOUBLE
114833: EQUAL
114834: IFTRUE 114838
114836: GO 114849
114838: POP
// bc_type := b_ext_radio ; 20 :
114839: LD_ADDR_OWVAR 42
114843: PUSH
114844: LD_INT 22
114846: ST_TO_ADDR
114847: GO 115135
114849: LD_INT 20
114851: DOUBLE
114852: EQUAL
114853: IFTRUE 114857
114855: GO 114868
114857: POP
// bc_type := b_ext_siberium ; 21 :
114858: LD_ADDR_OWVAR 42
114862: PUSH
114863: LD_INT 21
114865: ST_TO_ADDR
114866: GO 115135
114868: LD_INT 21
114870: DOUBLE
114871: EQUAL
114872: IFTRUE 114876
114874: GO 114887
114876: POP
// bc_type := b_ext_computer ; 22 :
114877: LD_ADDR_OWVAR 42
114881: PUSH
114882: LD_INT 24
114884: ST_TO_ADDR
114885: GO 115135
114887: LD_INT 22
114889: DOUBLE
114890: EQUAL
114891: IFTRUE 114895
114893: GO 114906
114895: POP
// bc_type := b_ext_track ; 23 :
114896: LD_ADDR_OWVAR 42
114900: PUSH
114901: LD_INT 16
114903: ST_TO_ADDR
114904: GO 115135
114906: LD_INT 23
114908: DOUBLE
114909: EQUAL
114910: IFTRUE 114914
114912: GO 114925
114914: POP
// bc_type := b_ext_laser ; 24 :
114915: LD_ADDR_OWVAR 42
114919: PUSH
114920: LD_INT 25
114922: ST_TO_ADDR
114923: GO 115135
114925: LD_INT 24
114927: DOUBLE
114928: EQUAL
114929: IFTRUE 114933
114931: GO 114944
114933: POP
// bc_type := b_control_tower ; 25 :
114934: LD_ADDR_OWVAR 42
114938: PUSH
114939: LD_INT 36
114941: ST_TO_ADDR
114942: GO 115135
114944: LD_INT 25
114946: DOUBLE
114947: EQUAL
114948: IFTRUE 114952
114950: GO 114963
114952: POP
// bc_type := b_breastwork ; 26 :
114953: LD_ADDR_OWVAR 42
114957: PUSH
114958: LD_INT 31
114960: ST_TO_ADDR
114961: GO 115135
114963: LD_INT 26
114965: DOUBLE
114966: EQUAL
114967: IFTRUE 114971
114969: GO 114982
114971: POP
// bc_type := b_bunker ; 27 :
114972: LD_ADDR_OWVAR 42
114976: PUSH
114977: LD_INT 32
114979: ST_TO_ADDR
114980: GO 115135
114982: LD_INT 27
114984: DOUBLE
114985: EQUAL
114986: IFTRUE 114990
114988: GO 115001
114990: POP
// bc_type := b_turret ; 28 :
114991: LD_ADDR_OWVAR 42
114995: PUSH
114996: LD_INT 33
114998: ST_TO_ADDR
114999: GO 115135
115001: LD_INT 28
115003: DOUBLE
115004: EQUAL
115005: IFTRUE 115009
115007: GO 115020
115009: POP
// bc_type := b_armoury ; 29 :
115010: LD_ADDR_OWVAR 42
115014: PUSH
115015: LD_INT 4
115017: ST_TO_ADDR
115018: GO 115135
115020: LD_INT 29
115022: DOUBLE
115023: EQUAL
115024: IFTRUE 115028
115026: GO 115039
115028: POP
// bc_type := b_barracks ; 30 :
115029: LD_ADDR_OWVAR 42
115033: PUSH
115034: LD_INT 5
115036: ST_TO_ADDR
115037: GO 115135
115039: LD_INT 30
115041: DOUBLE
115042: EQUAL
115043: IFTRUE 115047
115045: GO 115058
115047: POP
// bc_type := b_solar_power ; 31 :
115048: LD_ADDR_OWVAR 42
115052: PUSH
115053: LD_INT 27
115055: ST_TO_ADDR
115056: GO 115135
115058: LD_INT 31
115060: DOUBLE
115061: EQUAL
115062: IFTRUE 115066
115064: GO 115077
115066: POP
// bc_type := b_oil_power ; 32 :
115067: LD_ADDR_OWVAR 42
115071: PUSH
115072: LD_INT 26
115074: ST_TO_ADDR
115075: GO 115135
115077: LD_INT 32
115079: DOUBLE
115080: EQUAL
115081: IFTRUE 115085
115083: GO 115096
115085: POP
// bc_type := b_siberite_power ; 33 :
115086: LD_ADDR_OWVAR 42
115090: PUSH
115091: LD_INT 28
115093: ST_TO_ADDR
115094: GO 115135
115096: LD_INT 33
115098: DOUBLE
115099: EQUAL
115100: IFTRUE 115104
115102: GO 115115
115104: POP
// bc_type := b_oil_mine ; 34 :
115105: LD_ADDR_OWVAR 42
115109: PUSH
115110: LD_INT 29
115112: ST_TO_ADDR
115113: GO 115135
115115: LD_INT 34
115117: DOUBLE
115118: EQUAL
115119: IFTRUE 115123
115121: GO 115134
115123: POP
// bc_type := b_siberite_mine ; end ;
115124: LD_ADDR_OWVAR 42
115128: PUSH
115129: LD_INT 30
115131: ST_TO_ADDR
115132: GO 115135
115134: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
115135: LD_ADDR_VAR 0 8
115139: PUSH
115140: LD_VAR 0 5
115144: PPUSH
115145: LD_VAR 0 6
115149: PPUSH
115150: LD_VAR 0 3
115154: PPUSH
115155: CALL_OW 47
115159: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
115160: LD_OWVAR 42
115164: PUSH
115165: LD_INT 32
115167: PUSH
115168: LD_INT 33
115170: PUSH
115171: EMPTY
115172: LIST
115173: LIST
115174: IN
115175: IFFALSE 115191
// PlaceWeaponTurret ( b , weapon ) ;
115177: LD_VAR 0 8
115181: PPUSH
115182: LD_VAR 0 4
115186: PPUSH
115187: CALL_OW 431
// end ;
115191: LD_VAR 0 7
115195: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
115196: LD_INT 0
115198: PPUSH
115199: PPUSH
115200: PPUSH
115201: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115202: LD_ADDR_VAR 0 4
115206: PUSH
115207: LD_INT 22
115209: PUSH
115210: LD_OWVAR 2
115214: PUSH
115215: EMPTY
115216: LIST
115217: LIST
115218: PUSH
115219: LD_INT 2
115221: PUSH
115222: LD_INT 30
115224: PUSH
115225: LD_INT 0
115227: PUSH
115228: EMPTY
115229: LIST
115230: LIST
115231: PUSH
115232: LD_INT 30
115234: PUSH
115235: LD_INT 1
115237: PUSH
115238: EMPTY
115239: LIST
115240: LIST
115241: PUSH
115242: EMPTY
115243: LIST
115244: LIST
115245: LIST
115246: PUSH
115247: EMPTY
115248: LIST
115249: LIST
115250: PPUSH
115251: CALL_OW 69
115255: ST_TO_ADDR
// if not tmp then
115256: LD_VAR 0 4
115260: NOT
115261: IFFALSE 115265
// exit ;
115263: GO 115324
// for i in tmp do
115265: LD_ADDR_VAR 0 2
115269: PUSH
115270: LD_VAR 0 4
115274: PUSH
115275: FOR_IN
115276: IFFALSE 115322
// for j = 1 to 3 do
115278: LD_ADDR_VAR 0 3
115282: PUSH
115283: DOUBLE
115284: LD_INT 1
115286: DEC
115287: ST_TO_ADDR
115288: LD_INT 3
115290: PUSH
115291: FOR_TO
115292: IFFALSE 115318
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
115294: LD_VAR 0 2
115298: PPUSH
115299: CALL_OW 274
115303: PPUSH
115304: LD_VAR 0 3
115308: PPUSH
115309: LD_INT 99999
115311: PPUSH
115312: CALL_OW 277
115316: GO 115291
115318: POP
115319: POP
115320: GO 115275
115322: POP
115323: POP
// end ;
115324: LD_VAR 0 1
115328: RET
// export function hHackSetLevel10 ; var i , j ; begin
115329: LD_INT 0
115331: PPUSH
115332: PPUSH
115333: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115334: LD_ADDR_VAR 0 2
115338: PUSH
115339: LD_INT 21
115341: PUSH
115342: LD_INT 1
115344: PUSH
115345: EMPTY
115346: LIST
115347: LIST
115348: PPUSH
115349: CALL_OW 69
115353: PUSH
115354: FOR_IN
115355: IFFALSE 115407
// if IsSelected ( i ) then
115357: LD_VAR 0 2
115361: PPUSH
115362: CALL_OW 306
115366: IFFALSE 115405
// begin for j := 1 to 4 do
115368: LD_ADDR_VAR 0 3
115372: PUSH
115373: DOUBLE
115374: LD_INT 1
115376: DEC
115377: ST_TO_ADDR
115378: LD_INT 4
115380: PUSH
115381: FOR_TO
115382: IFFALSE 115403
// SetSkill ( i , j , 10 ) ;
115384: LD_VAR 0 2
115388: PPUSH
115389: LD_VAR 0 3
115393: PPUSH
115394: LD_INT 10
115396: PPUSH
115397: CALL_OW 237
115401: GO 115381
115403: POP
115404: POP
// end ;
115405: GO 115354
115407: POP
115408: POP
// end ;
115409: LD_VAR 0 1
115413: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
115414: LD_INT 0
115416: PPUSH
115417: PPUSH
115418: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
115419: LD_ADDR_VAR 0 2
115423: PUSH
115424: LD_INT 22
115426: PUSH
115427: LD_OWVAR 2
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: PUSH
115436: LD_INT 21
115438: PUSH
115439: LD_INT 1
115441: PUSH
115442: EMPTY
115443: LIST
115444: LIST
115445: PUSH
115446: EMPTY
115447: LIST
115448: LIST
115449: PPUSH
115450: CALL_OW 69
115454: PUSH
115455: FOR_IN
115456: IFFALSE 115497
// begin for j := 1 to 4 do
115458: LD_ADDR_VAR 0 3
115462: PUSH
115463: DOUBLE
115464: LD_INT 1
115466: DEC
115467: ST_TO_ADDR
115468: LD_INT 4
115470: PUSH
115471: FOR_TO
115472: IFFALSE 115493
// SetSkill ( i , j , 10 ) ;
115474: LD_VAR 0 2
115478: PPUSH
115479: LD_VAR 0 3
115483: PPUSH
115484: LD_INT 10
115486: PPUSH
115487: CALL_OW 237
115491: GO 115471
115493: POP
115494: POP
// end ;
115495: GO 115455
115497: POP
115498: POP
// end ;
115499: LD_VAR 0 1
115503: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
115504: LD_INT 0
115506: PPUSH
// uc_side := your_side ;
115507: LD_ADDR_OWVAR 20
115511: PUSH
115512: LD_OWVAR 2
115516: ST_TO_ADDR
// uc_nation := nation ;
115517: LD_ADDR_OWVAR 21
115521: PUSH
115522: LD_VAR 0 1
115526: ST_TO_ADDR
// InitHc ;
115527: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
115531: LD_INT 0
115533: PPUSH
115534: LD_VAR 0 2
115538: PPUSH
115539: LD_VAR 0 3
115543: PPUSH
115544: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
115548: LD_VAR 0 4
115552: PPUSH
115553: LD_VAR 0 5
115557: PPUSH
115558: CALL_OW 428
115562: PUSH
115563: LD_INT 0
115565: EQUAL
115566: IFFALSE 115590
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
115568: CALL_OW 44
115572: PPUSH
115573: LD_VAR 0 4
115577: PPUSH
115578: LD_VAR 0 5
115582: PPUSH
115583: LD_INT 1
115585: PPUSH
115586: CALL_OW 48
// end ;
115590: LD_VAR 0 6
115594: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
115595: LD_INT 0
115597: PPUSH
115598: PPUSH
// uc_side := your_side ;
115599: LD_ADDR_OWVAR 20
115603: PUSH
115604: LD_OWVAR 2
115608: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
115609: LD_VAR 0 1
115613: PUSH
115614: LD_INT 1
115616: PUSH
115617: LD_INT 2
115619: PUSH
115620: LD_INT 3
115622: PUSH
115623: LD_INT 4
115625: PUSH
115626: LD_INT 5
115628: PUSH
115629: EMPTY
115630: LIST
115631: LIST
115632: LIST
115633: LIST
115634: LIST
115635: IN
115636: IFFALSE 115648
// uc_nation := nation_american else
115638: LD_ADDR_OWVAR 21
115642: PUSH
115643: LD_INT 1
115645: ST_TO_ADDR
115646: GO 115691
// if chassis in [ 11 , 12 , 13 , 14 ] then
115648: LD_VAR 0 1
115652: PUSH
115653: LD_INT 11
115655: PUSH
115656: LD_INT 12
115658: PUSH
115659: LD_INT 13
115661: PUSH
115662: LD_INT 14
115664: PUSH
115665: EMPTY
115666: LIST
115667: LIST
115668: LIST
115669: LIST
115670: IN
115671: IFFALSE 115683
// uc_nation := nation_arabian else
115673: LD_ADDR_OWVAR 21
115677: PUSH
115678: LD_INT 2
115680: ST_TO_ADDR
115681: GO 115691
// uc_nation := nation_russian ;
115683: LD_ADDR_OWVAR 21
115687: PUSH
115688: LD_INT 3
115690: ST_TO_ADDR
// vc_chassis := chassis ;
115691: LD_ADDR_OWVAR 37
115695: PUSH
115696: LD_VAR 0 1
115700: ST_TO_ADDR
// vc_engine := engine ;
115701: LD_ADDR_OWVAR 39
115705: PUSH
115706: LD_VAR 0 2
115710: ST_TO_ADDR
// vc_control := control ;
115711: LD_ADDR_OWVAR 38
115715: PUSH
115716: LD_VAR 0 3
115720: ST_TO_ADDR
// vc_weapon := weapon ;
115721: LD_ADDR_OWVAR 40
115725: PUSH
115726: LD_VAR 0 4
115730: ST_TO_ADDR
// un := CreateVehicle ;
115731: LD_ADDR_VAR 0 8
115735: PUSH
115736: CALL_OW 45
115740: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
115741: LD_VAR 0 8
115745: PPUSH
115746: LD_INT 0
115748: PPUSH
115749: LD_INT 5
115751: PPUSH
115752: CALL_OW 12
115756: PPUSH
115757: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
115761: LD_VAR 0 8
115765: PPUSH
115766: LD_VAR 0 5
115770: PPUSH
115771: LD_VAR 0 6
115775: PPUSH
115776: LD_INT 1
115778: PPUSH
115779: CALL_OW 48
// end ;
115783: LD_VAR 0 7
115787: RET
// export hInvincible ; every 1 do
115788: GO 115790
115790: DISABLE
// hInvincible := [ ] ;
115791: LD_ADDR_EXP 213
115795: PUSH
115796: EMPTY
115797: ST_TO_ADDR
115798: END
// every 10 do var i ;
115799: GO 115801
115801: DISABLE
115802: LD_INT 0
115804: PPUSH
// begin enable ;
115805: ENABLE
// if not hInvincible then
115806: LD_EXP 213
115810: NOT
115811: IFFALSE 115815
// exit ;
115813: GO 115859
// for i in hInvincible do
115815: LD_ADDR_VAR 0 1
115819: PUSH
115820: LD_EXP 213
115824: PUSH
115825: FOR_IN
115826: IFFALSE 115857
// if GetLives ( i ) < 1000 then
115828: LD_VAR 0 1
115832: PPUSH
115833: CALL_OW 256
115837: PUSH
115838: LD_INT 1000
115840: LESS
115841: IFFALSE 115855
// SetLives ( i , 1000 ) ;
115843: LD_VAR 0 1
115847: PPUSH
115848: LD_INT 1000
115850: PPUSH
115851: CALL_OW 234
115855: GO 115825
115857: POP
115858: POP
// end ;
115859: PPOPN 1
115861: END
// export function hHackInvincible ; var i ; begin
115862: LD_INT 0
115864: PPUSH
115865: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
115866: LD_ADDR_VAR 0 2
115870: PUSH
115871: LD_INT 2
115873: PUSH
115874: LD_INT 21
115876: PUSH
115877: LD_INT 1
115879: PUSH
115880: EMPTY
115881: LIST
115882: LIST
115883: PUSH
115884: LD_INT 21
115886: PUSH
115887: LD_INT 2
115889: PUSH
115890: EMPTY
115891: LIST
115892: LIST
115893: PUSH
115894: EMPTY
115895: LIST
115896: LIST
115897: LIST
115898: PPUSH
115899: CALL_OW 69
115903: PUSH
115904: FOR_IN
115905: IFFALSE 115966
// if IsSelected ( i ) then
115907: LD_VAR 0 2
115911: PPUSH
115912: CALL_OW 306
115916: IFFALSE 115964
// begin if i in hInvincible then
115918: LD_VAR 0 2
115922: PUSH
115923: LD_EXP 213
115927: IN
115928: IFFALSE 115948
// hInvincible := hInvincible diff i else
115930: LD_ADDR_EXP 213
115934: PUSH
115935: LD_EXP 213
115939: PUSH
115940: LD_VAR 0 2
115944: DIFF
115945: ST_TO_ADDR
115946: GO 115964
// hInvincible := hInvincible union i ;
115948: LD_ADDR_EXP 213
115952: PUSH
115953: LD_EXP 213
115957: PUSH
115958: LD_VAR 0 2
115962: UNION
115963: ST_TO_ADDR
// end ;
115964: GO 115904
115966: POP
115967: POP
// end ;
115968: LD_VAR 0 1
115972: RET
// export function hHackInvisible ; var i , j ; begin
115973: LD_INT 0
115975: PPUSH
115976: PPUSH
115977: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115978: LD_ADDR_VAR 0 2
115982: PUSH
115983: LD_INT 21
115985: PUSH
115986: LD_INT 1
115988: PUSH
115989: EMPTY
115990: LIST
115991: LIST
115992: PPUSH
115993: CALL_OW 69
115997: PUSH
115998: FOR_IN
115999: IFFALSE 116023
// if IsSelected ( i ) then
116001: LD_VAR 0 2
116005: PPUSH
116006: CALL_OW 306
116010: IFFALSE 116021
// ComForceInvisible ( i ) ;
116012: LD_VAR 0 2
116016: PPUSH
116017: CALL_OW 496
116021: GO 115998
116023: POP
116024: POP
// end ;
116025: LD_VAR 0 1
116029: RET
// export function hHackChangeYourSide ; begin
116030: LD_INT 0
116032: PPUSH
// if your_side = 8 then
116033: LD_OWVAR 2
116037: PUSH
116038: LD_INT 8
116040: EQUAL
116041: IFFALSE 116053
// your_side := 0 else
116043: LD_ADDR_OWVAR 2
116047: PUSH
116048: LD_INT 0
116050: ST_TO_ADDR
116051: GO 116067
// your_side := your_side + 1 ;
116053: LD_ADDR_OWVAR 2
116057: PUSH
116058: LD_OWVAR 2
116062: PUSH
116063: LD_INT 1
116065: PLUS
116066: ST_TO_ADDR
// end ;
116067: LD_VAR 0 1
116071: RET
// export function hHackChangeUnitSide ; var i , j ; begin
116072: LD_INT 0
116074: PPUSH
116075: PPUSH
116076: PPUSH
// for i in all_units do
116077: LD_ADDR_VAR 0 2
116081: PUSH
116082: LD_OWVAR 3
116086: PUSH
116087: FOR_IN
116088: IFFALSE 116166
// if IsSelected ( i ) then
116090: LD_VAR 0 2
116094: PPUSH
116095: CALL_OW 306
116099: IFFALSE 116164
// begin j := GetSide ( i ) ;
116101: LD_ADDR_VAR 0 3
116105: PUSH
116106: LD_VAR 0 2
116110: PPUSH
116111: CALL_OW 255
116115: ST_TO_ADDR
// if j = 8 then
116116: LD_VAR 0 3
116120: PUSH
116121: LD_INT 8
116123: EQUAL
116124: IFFALSE 116136
// j := 0 else
116126: LD_ADDR_VAR 0 3
116130: PUSH
116131: LD_INT 0
116133: ST_TO_ADDR
116134: GO 116150
// j := j + 1 ;
116136: LD_ADDR_VAR 0 3
116140: PUSH
116141: LD_VAR 0 3
116145: PUSH
116146: LD_INT 1
116148: PLUS
116149: ST_TO_ADDR
// SetSide ( i , j ) ;
116150: LD_VAR 0 2
116154: PPUSH
116155: LD_VAR 0 3
116159: PPUSH
116160: CALL_OW 235
// end ;
116164: GO 116087
116166: POP
116167: POP
// end ;
116168: LD_VAR 0 1
116172: RET
// export function hHackFog ; begin
116173: LD_INT 0
116175: PPUSH
// FogOff ( true ) ;
116176: LD_INT 1
116178: PPUSH
116179: CALL_OW 344
// end ;
116183: LD_VAR 0 1
116187: RET
// export function hHackTeleport ( unit , x , y ) ; begin
116188: LD_INT 0
116190: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
116191: LD_VAR 0 1
116195: PPUSH
116196: LD_VAR 0 2
116200: PPUSH
116201: LD_VAR 0 3
116205: PPUSH
116206: LD_INT 1
116208: PPUSH
116209: LD_INT 1
116211: PPUSH
116212: CALL_OW 483
// CenterOnXY ( x , y ) ;
116216: LD_VAR 0 2
116220: PPUSH
116221: LD_VAR 0 3
116225: PPUSH
116226: CALL_OW 84
// end ; end_of_file
116230: LD_VAR 0 4
116234: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
116235: LD_INT 0
116237: PPUSH
116238: PPUSH
116239: PPUSH
116240: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
116241: LD_VAR 0 1
116245: PPUSH
116246: CALL_OW 264
116250: PUSH
116251: LD_EXP 99
116255: EQUAL
116256: IFFALSE 116328
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
116258: LD_INT 68
116260: PPUSH
116261: LD_VAR 0 1
116265: PPUSH
116266: CALL_OW 255
116270: PPUSH
116271: CALL_OW 321
116275: PUSH
116276: LD_INT 2
116278: EQUAL
116279: IFFALSE 116291
// eff := 70 else
116281: LD_ADDR_VAR 0 4
116285: PUSH
116286: LD_INT 70
116288: ST_TO_ADDR
116289: GO 116299
// eff := 30 ;
116291: LD_ADDR_VAR 0 4
116295: PUSH
116296: LD_INT 30
116298: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
116299: LD_VAR 0 1
116303: PPUSH
116304: CALL_OW 250
116308: PPUSH
116309: LD_VAR 0 1
116313: PPUSH
116314: CALL_OW 251
116318: PPUSH
116319: LD_VAR 0 4
116323: PPUSH
116324: CALL_OW 495
// end ; end ;
116328: LD_VAR 0 2
116332: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
116333: LD_INT 0
116335: PPUSH
// end ;
116336: LD_VAR 0 4
116340: RET
// export function SOS_Command ( cmd ) ; begin
116341: LD_INT 0
116343: PPUSH
// end ;
116344: LD_VAR 0 2
116348: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
116349: LD_INT 0
116351: PPUSH
// if cmd = 121 then
116352: LD_VAR 0 1
116356: PUSH
116357: LD_INT 121
116359: EQUAL
116360: IFFALSE 116362
// end ;
116362: LD_VAR 0 6
116366: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
116367: LD_INT 0
116369: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
116370: LD_VAR 0 1
116374: PUSH
116375: LD_INT 250
116377: EQUAL
116378: PUSH
116379: LD_VAR 0 2
116383: PPUSH
116384: CALL_OW 264
116388: PUSH
116389: LD_EXP 102
116393: EQUAL
116394: AND
116395: IFFALSE 116416
// MinerPlaceMine ( unit , x , y ) ;
116397: LD_VAR 0 2
116401: PPUSH
116402: LD_VAR 0 4
116406: PPUSH
116407: LD_VAR 0 5
116411: PPUSH
116412: CALL 118765 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
116416: LD_VAR 0 1
116420: PUSH
116421: LD_INT 251
116423: EQUAL
116424: PUSH
116425: LD_VAR 0 2
116429: PPUSH
116430: CALL_OW 264
116434: PUSH
116435: LD_EXP 102
116439: EQUAL
116440: AND
116441: IFFALSE 116462
// MinerDetonateMine ( unit , x , y ) ;
116443: LD_VAR 0 2
116447: PPUSH
116448: LD_VAR 0 4
116452: PPUSH
116453: LD_VAR 0 5
116457: PPUSH
116458: CALL 119042 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
116462: LD_VAR 0 1
116466: PUSH
116467: LD_INT 252
116469: EQUAL
116470: PUSH
116471: LD_VAR 0 2
116475: PPUSH
116476: CALL_OW 264
116480: PUSH
116481: LD_EXP 102
116485: EQUAL
116486: AND
116487: IFFALSE 116508
// MinerCreateMinefield ( unit , x , y ) ;
116489: LD_VAR 0 2
116493: PPUSH
116494: LD_VAR 0 4
116498: PPUSH
116499: LD_VAR 0 5
116503: PPUSH
116504: CALL 119459 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
116508: LD_VAR 0 1
116512: PUSH
116513: LD_INT 253
116515: EQUAL
116516: PUSH
116517: LD_VAR 0 2
116521: PPUSH
116522: CALL_OW 257
116526: PUSH
116527: LD_INT 5
116529: EQUAL
116530: AND
116531: IFFALSE 116552
// ComBinocular ( unit , x , y ) ;
116533: LD_VAR 0 2
116537: PPUSH
116538: LD_VAR 0 4
116542: PPUSH
116543: LD_VAR 0 5
116547: PPUSH
116548: CALL 119830 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
116552: LD_VAR 0 1
116556: PUSH
116557: LD_INT 254
116559: EQUAL
116560: PUSH
116561: LD_VAR 0 2
116565: PPUSH
116566: CALL_OW 264
116570: PUSH
116571: LD_EXP 97
116575: EQUAL
116576: AND
116577: PUSH
116578: LD_VAR 0 3
116582: PPUSH
116583: CALL_OW 263
116587: PUSH
116588: LD_INT 3
116590: EQUAL
116591: AND
116592: IFFALSE 116608
// HackDestroyVehicle ( unit , selectedUnit ) ;
116594: LD_VAR 0 2
116598: PPUSH
116599: LD_VAR 0 3
116603: PPUSH
116604: CALL 118125 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
116608: LD_VAR 0 1
116612: PUSH
116613: LD_INT 255
116615: EQUAL
116616: PUSH
116617: LD_VAR 0 2
116621: PPUSH
116622: CALL_OW 264
116626: PUSH
116627: LD_INT 14
116629: PUSH
116630: LD_INT 53
116632: PUSH
116633: EMPTY
116634: LIST
116635: LIST
116636: IN
116637: AND
116638: PUSH
116639: LD_VAR 0 4
116643: PPUSH
116644: LD_VAR 0 5
116648: PPUSH
116649: CALL_OW 488
116653: AND
116654: IFFALSE 116678
// CutTreeXYR ( unit , x , y , 12 ) ;
116656: LD_VAR 0 2
116660: PPUSH
116661: LD_VAR 0 4
116665: PPUSH
116666: LD_VAR 0 5
116670: PPUSH
116671: LD_INT 12
116673: PPUSH
116674: CALL 116691 0 4
// end ;
116678: LD_VAR 0 6
116682: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
116683: LD_INT 0
116685: PPUSH
// end ;
116686: LD_VAR 0 4
116690: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
116691: LD_INT 0
116693: PPUSH
116694: PPUSH
116695: PPUSH
116696: PPUSH
116697: PPUSH
116698: PPUSH
116699: PPUSH
116700: PPUSH
116701: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
116702: LD_VAR 0 1
116706: NOT
116707: PUSH
116708: LD_VAR 0 2
116712: PPUSH
116713: LD_VAR 0 3
116717: PPUSH
116718: CALL_OW 488
116722: NOT
116723: OR
116724: PUSH
116725: LD_VAR 0 4
116729: NOT
116730: OR
116731: IFFALSE 116735
// exit ;
116733: GO 117075
// list := [ ] ;
116735: LD_ADDR_VAR 0 13
116739: PUSH
116740: EMPTY
116741: ST_TO_ADDR
// if x - r < 0 then
116742: LD_VAR 0 2
116746: PUSH
116747: LD_VAR 0 4
116751: MINUS
116752: PUSH
116753: LD_INT 0
116755: LESS
116756: IFFALSE 116768
// min_x := 0 else
116758: LD_ADDR_VAR 0 7
116762: PUSH
116763: LD_INT 0
116765: ST_TO_ADDR
116766: GO 116784
// min_x := x - r ;
116768: LD_ADDR_VAR 0 7
116772: PUSH
116773: LD_VAR 0 2
116777: PUSH
116778: LD_VAR 0 4
116782: MINUS
116783: ST_TO_ADDR
// if y - r < 0 then
116784: LD_VAR 0 3
116788: PUSH
116789: LD_VAR 0 4
116793: MINUS
116794: PUSH
116795: LD_INT 0
116797: LESS
116798: IFFALSE 116810
// min_y := 0 else
116800: LD_ADDR_VAR 0 8
116804: PUSH
116805: LD_INT 0
116807: ST_TO_ADDR
116808: GO 116826
// min_y := y - r ;
116810: LD_ADDR_VAR 0 8
116814: PUSH
116815: LD_VAR 0 3
116819: PUSH
116820: LD_VAR 0 4
116824: MINUS
116825: ST_TO_ADDR
// max_x := x + r ;
116826: LD_ADDR_VAR 0 9
116830: PUSH
116831: LD_VAR 0 2
116835: PUSH
116836: LD_VAR 0 4
116840: PLUS
116841: ST_TO_ADDR
// max_y := y + r ;
116842: LD_ADDR_VAR 0 10
116846: PUSH
116847: LD_VAR 0 3
116851: PUSH
116852: LD_VAR 0 4
116856: PLUS
116857: ST_TO_ADDR
// for _x = min_x to max_x do
116858: LD_ADDR_VAR 0 11
116862: PUSH
116863: DOUBLE
116864: LD_VAR 0 7
116868: DEC
116869: ST_TO_ADDR
116870: LD_VAR 0 9
116874: PUSH
116875: FOR_TO
116876: IFFALSE 116993
// for _y = min_y to max_y do
116878: LD_ADDR_VAR 0 12
116882: PUSH
116883: DOUBLE
116884: LD_VAR 0 8
116888: DEC
116889: ST_TO_ADDR
116890: LD_VAR 0 10
116894: PUSH
116895: FOR_TO
116896: IFFALSE 116989
// begin if not ValidHex ( _x , _y ) then
116898: LD_VAR 0 11
116902: PPUSH
116903: LD_VAR 0 12
116907: PPUSH
116908: CALL_OW 488
116912: NOT
116913: IFFALSE 116917
// continue ;
116915: GO 116895
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116917: LD_VAR 0 11
116921: PPUSH
116922: LD_VAR 0 12
116926: PPUSH
116927: CALL_OW 351
116931: PUSH
116932: LD_VAR 0 11
116936: PPUSH
116937: LD_VAR 0 12
116941: PPUSH
116942: CALL_OW 554
116946: AND
116947: IFFALSE 116987
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116949: LD_ADDR_VAR 0 13
116953: PUSH
116954: LD_VAR 0 13
116958: PPUSH
116959: LD_VAR 0 13
116963: PUSH
116964: LD_INT 1
116966: PLUS
116967: PPUSH
116968: LD_VAR 0 11
116972: PUSH
116973: LD_VAR 0 12
116977: PUSH
116978: EMPTY
116979: LIST
116980: LIST
116981: PPUSH
116982: CALL_OW 2
116986: ST_TO_ADDR
// end ;
116987: GO 116895
116989: POP
116990: POP
116991: GO 116875
116993: POP
116994: POP
// if not list then
116995: LD_VAR 0 13
116999: NOT
117000: IFFALSE 117004
// exit ;
117002: GO 117075
// for i in list do
117004: LD_ADDR_VAR 0 6
117008: PUSH
117009: LD_VAR 0 13
117013: PUSH
117014: FOR_IN
117015: IFFALSE 117073
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
117017: LD_VAR 0 1
117021: PPUSH
117022: LD_STRING M
117024: PUSH
117025: LD_VAR 0 6
117029: PUSH
117030: LD_INT 1
117032: ARRAY
117033: PUSH
117034: LD_VAR 0 6
117038: PUSH
117039: LD_INT 2
117041: ARRAY
117042: PUSH
117043: LD_INT 0
117045: PUSH
117046: LD_INT 0
117048: PUSH
117049: LD_INT 0
117051: PUSH
117052: LD_INT 0
117054: PUSH
117055: EMPTY
117056: LIST
117057: LIST
117058: LIST
117059: LIST
117060: LIST
117061: LIST
117062: LIST
117063: PUSH
117064: EMPTY
117065: LIST
117066: PPUSH
117067: CALL_OW 447
117071: GO 117014
117073: POP
117074: POP
// end ;
117075: LD_VAR 0 5
117079: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
117080: LD_EXP 216
117084: NOT
117085: IFFALSE 117135
117087: GO 117089
117089: DISABLE
// begin initHack := true ;
117090: LD_ADDR_EXP 216
117094: PUSH
117095: LD_INT 1
117097: ST_TO_ADDR
// hackTanks := [ ] ;
117098: LD_ADDR_EXP 217
117102: PUSH
117103: EMPTY
117104: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
117105: LD_ADDR_EXP 218
117109: PUSH
117110: EMPTY
117111: ST_TO_ADDR
// hackLimit := 3 ;
117112: LD_ADDR_EXP 219
117116: PUSH
117117: LD_INT 3
117119: ST_TO_ADDR
// hackDist := 12 ;
117120: LD_ADDR_EXP 220
117124: PUSH
117125: LD_INT 12
117127: ST_TO_ADDR
// hackCounter := [ ] ;
117128: LD_ADDR_EXP 221
117132: PUSH
117133: EMPTY
117134: ST_TO_ADDR
// end ;
117135: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
117136: LD_EXP 216
117140: PUSH
117141: LD_INT 34
117143: PUSH
117144: LD_EXP 97
117148: PUSH
117149: EMPTY
117150: LIST
117151: LIST
117152: PPUSH
117153: CALL_OW 69
117157: AND
117158: IFFALSE 117413
117160: GO 117162
117162: DISABLE
117163: LD_INT 0
117165: PPUSH
117166: PPUSH
// begin enable ;
117167: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
117168: LD_ADDR_VAR 0 1
117172: PUSH
117173: LD_INT 34
117175: PUSH
117176: LD_EXP 97
117180: PUSH
117181: EMPTY
117182: LIST
117183: LIST
117184: PPUSH
117185: CALL_OW 69
117189: PUSH
117190: FOR_IN
117191: IFFALSE 117411
// begin if not i in hackTanks then
117193: LD_VAR 0 1
117197: PUSH
117198: LD_EXP 217
117202: IN
117203: NOT
117204: IFFALSE 117287
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
117206: LD_ADDR_EXP 217
117210: PUSH
117211: LD_EXP 217
117215: PPUSH
117216: LD_EXP 217
117220: PUSH
117221: LD_INT 1
117223: PLUS
117224: PPUSH
117225: LD_VAR 0 1
117229: PPUSH
117230: CALL_OW 1
117234: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
117235: LD_ADDR_EXP 218
117239: PUSH
117240: LD_EXP 218
117244: PPUSH
117245: LD_EXP 218
117249: PUSH
117250: LD_INT 1
117252: PLUS
117253: PPUSH
117254: EMPTY
117255: PPUSH
117256: CALL_OW 1
117260: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
117261: LD_ADDR_EXP 221
117265: PUSH
117266: LD_EXP 221
117270: PPUSH
117271: LD_EXP 221
117275: PUSH
117276: LD_INT 1
117278: PLUS
117279: PPUSH
117280: EMPTY
117281: PPUSH
117282: CALL_OW 1
117286: ST_TO_ADDR
// end ; if not IsOk ( i ) then
117287: LD_VAR 0 1
117291: PPUSH
117292: CALL_OW 302
117296: NOT
117297: IFFALSE 117310
// begin HackUnlinkAll ( i ) ;
117299: LD_VAR 0 1
117303: PPUSH
117304: CALL 117416 0 1
// continue ;
117308: GO 117190
// end ; HackCheckCapturedStatus ( i ) ;
117310: LD_VAR 0 1
117314: PPUSH
117315: CALL 117859 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
117319: LD_ADDR_VAR 0 2
117323: PUSH
117324: LD_INT 81
117326: PUSH
117327: LD_VAR 0 1
117331: PPUSH
117332: CALL_OW 255
117336: PUSH
117337: EMPTY
117338: LIST
117339: LIST
117340: PUSH
117341: LD_INT 33
117343: PUSH
117344: LD_INT 3
117346: PUSH
117347: EMPTY
117348: LIST
117349: LIST
117350: PUSH
117351: LD_INT 91
117353: PUSH
117354: LD_VAR 0 1
117358: PUSH
117359: LD_EXP 220
117363: PUSH
117364: EMPTY
117365: LIST
117366: LIST
117367: LIST
117368: PUSH
117369: LD_INT 50
117371: PUSH
117372: EMPTY
117373: LIST
117374: PUSH
117375: EMPTY
117376: LIST
117377: LIST
117378: LIST
117379: LIST
117380: PPUSH
117381: CALL_OW 69
117385: ST_TO_ADDR
// if not tmp then
117386: LD_VAR 0 2
117390: NOT
117391: IFFALSE 117395
// continue ;
117393: GO 117190
// HackLink ( i , tmp ) ;
117395: LD_VAR 0 1
117399: PPUSH
117400: LD_VAR 0 2
117404: PPUSH
117405: CALL 117552 0 2
// end ;
117409: GO 117190
117411: POP
117412: POP
// end ;
117413: PPOPN 2
117415: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
117416: LD_INT 0
117418: PPUSH
117419: PPUSH
117420: PPUSH
// if not hack in hackTanks then
117421: LD_VAR 0 1
117425: PUSH
117426: LD_EXP 217
117430: IN
117431: NOT
117432: IFFALSE 117436
// exit ;
117434: GO 117547
// index := GetElementIndex ( hackTanks , hack ) ;
117436: LD_ADDR_VAR 0 4
117440: PUSH
117441: LD_EXP 217
117445: PPUSH
117446: LD_VAR 0 1
117450: PPUSH
117451: CALL 70138 0 2
117455: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
117456: LD_EXP 218
117460: PUSH
117461: LD_VAR 0 4
117465: ARRAY
117466: IFFALSE 117547
// begin for i in hackTanksCaptured [ index ] do
117468: LD_ADDR_VAR 0 3
117472: PUSH
117473: LD_EXP 218
117477: PUSH
117478: LD_VAR 0 4
117482: ARRAY
117483: PUSH
117484: FOR_IN
117485: IFFALSE 117511
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
117487: LD_VAR 0 3
117491: PUSH
117492: LD_INT 1
117494: ARRAY
117495: PPUSH
117496: LD_VAR 0 3
117500: PUSH
117501: LD_INT 2
117503: ARRAY
117504: PPUSH
117505: CALL_OW 235
117509: GO 117484
117511: POP
117512: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
117513: LD_ADDR_EXP 218
117517: PUSH
117518: LD_EXP 218
117522: PPUSH
117523: LD_VAR 0 4
117527: PPUSH
117528: EMPTY
117529: PPUSH
117530: CALL_OW 1
117534: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
117535: LD_VAR 0 1
117539: PPUSH
117540: LD_INT 0
117542: PPUSH
117543: CALL_OW 505
// end ; end ;
117547: LD_VAR 0 2
117551: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
117552: LD_INT 0
117554: PPUSH
117555: PPUSH
117556: PPUSH
// if not hack in hackTanks or not vehicles then
117557: LD_VAR 0 1
117561: PUSH
117562: LD_EXP 217
117566: IN
117567: NOT
117568: PUSH
117569: LD_VAR 0 2
117573: NOT
117574: OR
117575: IFFALSE 117579
// exit ;
117577: GO 117854
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
117579: LD_ADDR_VAR 0 2
117583: PUSH
117584: LD_VAR 0 1
117588: PPUSH
117589: LD_VAR 0 2
117593: PPUSH
117594: LD_INT 1
117596: PPUSH
117597: LD_INT 1
117599: PPUSH
117600: CALL 70788 0 4
117604: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
117605: LD_ADDR_VAR 0 5
117609: PUSH
117610: LD_EXP 217
117614: PPUSH
117615: LD_VAR 0 1
117619: PPUSH
117620: CALL 70138 0 2
117624: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
117625: LD_EXP 218
117629: PUSH
117630: LD_VAR 0 5
117634: ARRAY
117635: PUSH
117636: LD_EXP 219
117640: LESS
117641: IFFALSE 117830
// begin for i := 1 to vehicles do
117643: LD_ADDR_VAR 0 4
117647: PUSH
117648: DOUBLE
117649: LD_INT 1
117651: DEC
117652: ST_TO_ADDR
117653: LD_VAR 0 2
117657: PUSH
117658: FOR_TO
117659: IFFALSE 117828
// begin if hackTanksCaptured [ index ] = hackLimit then
117661: LD_EXP 218
117665: PUSH
117666: LD_VAR 0 5
117670: ARRAY
117671: PUSH
117672: LD_EXP 219
117676: EQUAL
117677: IFFALSE 117681
// break ;
117679: GO 117828
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
117681: LD_ADDR_EXP 221
117685: PUSH
117686: LD_EXP 221
117690: PPUSH
117691: LD_VAR 0 5
117695: PPUSH
117696: LD_EXP 221
117700: PUSH
117701: LD_VAR 0 5
117705: ARRAY
117706: PUSH
117707: LD_INT 1
117709: PLUS
117710: PPUSH
117711: CALL_OW 1
117715: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
117716: LD_ADDR_EXP 218
117720: PUSH
117721: LD_EXP 218
117725: PPUSH
117726: LD_VAR 0 5
117730: PUSH
117731: LD_EXP 218
117735: PUSH
117736: LD_VAR 0 5
117740: ARRAY
117741: PUSH
117742: LD_INT 1
117744: PLUS
117745: PUSH
117746: EMPTY
117747: LIST
117748: LIST
117749: PPUSH
117750: LD_VAR 0 2
117754: PUSH
117755: LD_VAR 0 4
117759: ARRAY
117760: PUSH
117761: LD_VAR 0 2
117765: PUSH
117766: LD_VAR 0 4
117770: ARRAY
117771: PPUSH
117772: CALL_OW 255
117776: PUSH
117777: EMPTY
117778: LIST
117779: LIST
117780: PPUSH
117781: CALL 70353 0 3
117785: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
117786: LD_VAR 0 2
117790: PUSH
117791: LD_VAR 0 4
117795: ARRAY
117796: PPUSH
117797: LD_VAR 0 1
117801: PPUSH
117802: CALL_OW 255
117806: PPUSH
117807: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
117811: LD_VAR 0 2
117815: PUSH
117816: LD_VAR 0 4
117820: ARRAY
117821: PPUSH
117822: CALL_OW 141
// end ;
117826: GO 117658
117828: POP
117829: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117830: LD_VAR 0 1
117834: PPUSH
117835: LD_EXP 218
117839: PUSH
117840: LD_VAR 0 5
117844: ARRAY
117845: PUSH
117846: LD_INT 0
117848: PLUS
117849: PPUSH
117850: CALL_OW 505
// end ;
117854: LD_VAR 0 3
117858: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117859: LD_INT 0
117861: PPUSH
117862: PPUSH
117863: PPUSH
117864: PPUSH
// if not hack in hackTanks then
117865: LD_VAR 0 1
117869: PUSH
117870: LD_EXP 217
117874: IN
117875: NOT
117876: IFFALSE 117880
// exit ;
117878: GO 118120
// index := GetElementIndex ( hackTanks , hack ) ;
117880: LD_ADDR_VAR 0 4
117884: PUSH
117885: LD_EXP 217
117889: PPUSH
117890: LD_VAR 0 1
117894: PPUSH
117895: CALL 70138 0 2
117899: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117900: LD_ADDR_VAR 0 3
117904: PUSH
117905: DOUBLE
117906: LD_EXP 218
117910: PUSH
117911: LD_VAR 0 4
117915: ARRAY
117916: INC
117917: ST_TO_ADDR
117918: LD_INT 1
117920: PUSH
117921: FOR_DOWNTO
117922: IFFALSE 118094
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117924: LD_ADDR_VAR 0 5
117928: PUSH
117929: LD_EXP 218
117933: PUSH
117934: LD_VAR 0 4
117938: ARRAY
117939: PUSH
117940: LD_VAR 0 3
117944: ARRAY
117945: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117946: LD_VAR 0 5
117950: PUSH
117951: LD_INT 1
117953: ARRAY
117954: PPUSH
117955: CALL_OW 302
117959: NOT
117960: PUSH
117961: LD_VAR 0 5
117965: PUSH
117966: LD_INT 1
117968: ARRAY
117969: PPUSH
117970: CALL_OW 255
117974: PUSH
117975: LD_VAR 0 1
117979: PPUSH
117980: CALL_OW 255
117984: NONEQUAL
117985: OR
117986: IFFALSE 118092
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117988: LD_VAR 0 5
117992: PUSH
117993: LD_INT 1
117995: ARRAY
117996: PPUSH
117997: CALL_OW 305
118001: PUSH
118002: LD_VAR 0 5
118006: PUSH
118007: LD_INT 1
118009: ARRAY
118010: PPUSH
118011: CALL_OW 255
118015: PUSH
118016: LD_VAR 0 1
118020: PPUSH
118021: CALL_OW 255
118025: EQUAL
118026: AND
118027: IFFALSE 118051
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
118029: LD_VAR 0 5
118033: PUSH
118034: LD_INT 1
118036: ARRAY
118037: PPUSH
118038: LD_VAR 0 5
118042: PUSH
118043: LD_INT 2
118045: ARRAY
118046: PPUSH
118047: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
118051: LD_ADDR_EXP 218
118055: PUSH
118056: LD_EXP 218
118060: PPUSH
118061: LD_VAR 0 4
118065: PPUSH
118066: LD_EXP 218
118070: PUSH
118071: LD_VAR 0 4
118075: ARRAY
118076: PPUSH
118077: LD_VAR 0 3
118081: PPUSH
118082: CALL_OW 3
118086: PPUSH
118087: CALL_OW 1
118091: ST_TO_ADDR
// end ; end ;
118092: GO 117921
118094: POP
118095: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
118096: LD_VAR 0 1
118100: PPUSH
118101: LD_EXP 218
118105: PUSH
118106: LD_VAR 0 4
118110: ARRAY
118111: PUSH
118112: LD_INT 0
118114: PLUS
118115: PPUSH
118116: CALL_OW 505
// end ;
118120: LD_VAR 0 2
118124: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
118125: LD_INT 0
118127: PPUSH
118128: PPUSH
118129: PPUSH
118130: PPUSH
// if not hack in hackTanks then
118131: LD_VAR 0 1
118135: PUSH
118136: LD_EXP 217
118140: IN
118141: NOT
118142: IFFALSE 118146
// exit ;
118144: GO 118231
// index := GetElementIndex ( hackTanks , hack ) ;
118146: LD_ADDR_VAR 0 5
118150: PUSH
118151: LD_EXP 217
118155: PPUSH
118156: LD_VAR 0 1
118160: PPUSH
118161: CALL 70138 0 2
118165: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
118166: LD_ADDR_VAR 0 4
118170: PUSH
118171: DOUBLE
118172: LD_INT 1
118174: DEC
118175: ST_TO_ADDR
118176: LD_EXP 218
118180: PUSH
118181: LD_VAR 0 5
118185: ARRAY
118186: PUSH
118187: FOR_TO
118188: IFFALSE 118229
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
118190: LD_EXP 218
118194: PUSH
118195: LD_VAR 0 5
118199: ARRAY
118200: PUSH
118201: LD_VAR 0 4
118205: ARRAY
118206: PUSH
118207: LD_INT 1
118209: ARRAY
118210: PUSH
118211: LD_VAR 0 2
118215: EQUAL
118216: IFFALSE 118227
// KillUnit ( vehicle ) ;
118218: LD_VAR 0 2
118222: PPUSH
118223: CALL_OW 66
118227: GO 118187
118229: POP
118230: POP
// end ;
118231: LD_VAR 0 3
118235: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
118236: LD_EXP 222
118240: NOT
118241: IFFALSE 118276
118243: GO 118245
118245: DISABLE
// begin initMiner := true ;
118246: LD_ADDR_EXP 222
118250: PUSH
118251: LD_INT 1
118253: ST_TO_ADDR
// minersList := [ ] ;
118254: LD_ADDR_EXP 223
118258: PUSH
118259: EMPTY
118260: ST_TO_ADDR
// minerMinesList := [ ] ;
118261: LD_ADDR_EXP 224
118265: PUSH
118266: EMPTY
118267: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
118268: LD_ADDR_EXP 225
118272: PUSH
118273: LD_INT 5
118275: ST_TO_ADDR
// end ;
118276: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
118277: LD_EXP 222
118281: PUSH
118282: LD_INT 34
118284: PUSH
118285: LD_EXP 102
118289: PUSH
118290: EMPTY
118291: LIST
118292: LIST
118293: PPUSH
118294: CALL_OW 69
118298: AND
118299: IFFALSE 118762
118301: GO 118303
118303: DISABLE
118304: LD_INT 0
118306: PPUSH
118307: PPUSH
118308: PPUSH
118309: PPUSH
// begin enable ;
118310: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
118311: LD_ADDR_VAR 0 1
118315: PUSH
118316: LD_INT 34
118318: PUSH
118319: LD_EXP 102
118323: PUSH
118324: EMPTY
118325: LIST
118326: LIST
118327: PPUSH
118328: CALL_OW 69
118332: PUSH
118333: FOR_IN
118334: IFFALSE 118406
// begin if not i in minersList then
118336: LD_VAR 0 1
118340: PUSH
118341: LD_EXP 223
118345: IN
118346: NOT
118347: IFFALSE 118404
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
118349: LD_ADDR_EXP 223
118353: PUSH
118354: LD_EXP 223
118358: PPUSH
118359: LD_EXP 223
118363: PUSH
118364: LD_INT 1
118366: PLUS
118367: PPUSH
118368: LD_VAR 0 1
118372: PPUSH
118373: CALL_OW 1
118377: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
118378: LD_ADDR_EXP 224
118382: PUSH
118383: LD_EXP 224
118387: PPUSH
118388: LD_EXP 224
118392: PUSH
118393: LD_INT 1
118395: PLUS
118396: PPUSH
118397: EMPTY
118398: PPUSH
118399: CALL_OW 1
118403: ST_TO_ADDR
// end end ;
118404: GO 118333
118406: POP
118407: POP
// for i := minerMinesList downto 1 do
118408: LD_ADDR_VAR 0 1
118412: PUSH
118413: DOUBLE
118414: LD_EXP 224
118418: INC
118419: ST_TO_ADDR
118420: LD_INT 1
118422: PUSH
118423: FOR_DOWNTO
118424: IFFALSE 118760
// begin if IsLive ( minersList [ i ] ) then
118426: LD_EXP 223
118430: PUSH
118431: LD_VAR 0 1
118435: ARRAY
118436: PPUSH
118437: CALL_OW 300
118441: IFFALSE 118469
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
118443: LD_EXP 223
118447: PUSH
118448: LD_VAR 0 1
118452: ARRAY
118453: PPUSH
118454: LD_EXP 224
118458: PUSH
118459: LD_VAR 0 1
118463: ARRAY
118464: PPUSH
118465: CALL_OW 505
// if not minerMinesList [ i ] then
118469: LD_EXP 224
118473: PUSH
118474: LD_VAR 0 1
118478: ARRAY
118479: NOT
118480: IFFALSE 118484
// continue ;
118482: GO 118423
// for j := minerMinesList [ i ] downto 1 do
118484: LD_ADDR_VAR 0 2
118488: PUSH
118489: DOUBLE
118490: LD_EXP 224
118494: PUSH
118495: LD_VAR 0 1
118499: ARRAY
118500: INC
118501: ST_TO_ADDR
118502: LD_INT 1
118504: PUSH
118505: FOR_DOWNTO
118506: IFFALSE 118756
// begin side := GetSide ( minersList [ i ] ) ;
118508: LD_ADDR_VAR 0 3
118512: PUSH
118513: LD_EXP 223
118517: PUSH
118518: LD_VAR 0 1
118522: ARRAY
118523: PPUSH
118524: CALL_OW 255
118528: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
118529: LD_ADDR_VAR 0 4
118533: PUSH
118534: LD_EXP 224
118538: PUSH
118539: LD_VAR 0 1
118543: ARRAY
118544: PUSH
118545: LD_VAR 0 2
118549: ARRAY
118550: PUSH
118551: LD_INT 1
118553: ARRAY
118554: PPUSH
118555: LD_EXP 224
118559: PUSH
118560: LD_VAR 0 1
118564: ARRAY
118565: PUSH
118566: LD_VAR 0 2
118570: ARRAY
118571: PUSH
118572: LD_INT 2
118574: ARRAY
118575: PPUSH
118576: CALL_OW 428
118580: ST_TO_ADDR
// if not tmp then
118581: LD_VAR 0 4
118585: NOT
118586: IFFALSE 118590
// continue ;
118588: GO 118505
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
118590: LD_VAR 0 4
118594: PUSH
118595: LD_INT 81
118597: PUSH
118598: LD_VAR 0 3
118602: PUSH
118603: EMPTY
118604: LIST
118605: LIST
118606: PPUSH
118607: CALL_OW 69
118611: IN
118612: PUSH
118613: LD_EXP 224
118617: PUSH
118618: LD_VAR 0 1
118622: ARRAY
118623: PUSH
118624: LD_VAR 0 2
118628: ARRAY
118629: PUSH
118630: LD_INT 1
118632: ARRAY
118633: PPUSH
118634: LD_EXP 224
118638: PUSH
118639: LD_VAR 0 1
118643: ARRAY
118644: PUSH
118645: LD_VAR 0 2
118649: ARRAY
118650: PUSH
118651: LD_INT 2
118653: ARRAY
118654: PPUSH
118655: CALL_OW 458
118659: AND
118660: IFFALSE 118754
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
118662: LD_EXP 224
118666: PUSH
118667: LD_VAR 0 1
118671: ARRAY
118672: PUSH
118673: LD_VAR 0 2
118677: ARRAY
118678: PUSH
118679: LD_INT 1
118681: ARRAY
118682: PPUSH
118683: LD_EXP 224
118687: PUSH
118688: LD_VAR 0 1
118692: ARRAY
118693: PUSH
118694: LD_VAR 0 2
118698: ARRAY
118699: PUSH
118700: LD_INT 2
118702: ARRAY
118703: PPUSH
118704: LD_VAR 0 3
118708: PPUSH
118709: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
118713: LD_ADDR_EXP 224
118717: PUSH
118718: LD_EXP 224
118722: PPUSH
118723: LD_VAR 0 1
118727: PPUSH
118728: LD_EXP 224
118732: PUSH
118733: LD_VAR 0 1
118737: ARRAY
118738: PPUSH
118739: LD_VAR 0 2
118743: PPUSH
118744: CALL_OW 3
118748: PPUSH
118749: CALL_OW 1
118753: ST_TO_ADDR
// end ; end ;
118754: GO 118505
118756: POP
118757: POP
// end ;
118758: GO 118423
118760: POP
118761: POP
// end ;
118762: PPOPN 4
118764: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
118765: LD_INT 0
118767: PPUSH
118768: PPUSH
// result := false ;
118769: LD_ADDR_VAR 0 4
118773: PUSH
118774: LD_INT 0
118776: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
118777: LD_VAR 0 1
118781: PPUSH
118782: CALL_OW 264
118786: PUSH
118787: LD_EXP 102
118791: EQUAL
118792: NOT
118793: IFFALSE 118797
// exit ;
118795: GO 119037
// index := GetElementIndex ( minersList , unit ) ;
118797: LD_ADDR_VAR 0 5
118801: PUSH
118802: LD_EXP 223
118806: PPUSH
118807: LD_VAR 0 1
118811: PPUSH
118812: CALL 70138 0 2
118816: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
118817: LD_EXP 224
118821: PUSH
118822: LD_VAR 0 5
118826: ARRAY
118827: PUSH
118828: LD_EXP 225
118832: GREATEREQUAL
118833: IFFALSE 118837
// exit ;
118835: GO 119037
// ComMoveXY ( unit , x , y ) ;
118837: LD_VAR 0 1
118841: PPUSH
118842: LD_VAR 0 2
118846: PPUSH
118847: LD_VAR 0 3
118851: PPUSH
118852: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118856: LD_INT 35
118858: PPUSH
118859: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118863: LD_VAR 0 1
118867: PPUSH
118868: LD_VAR 0 2
118872: PPUSH
118873: LD_VAR 0 3
118877: PPUSH
118878: CALL 100535 0 3
118882: NOT
118883: PUSH
118884: LD_VAR 0 1
118888: PPUSH
118889: CALL_OW 314
118893: AND
118894: IFFALSE 118898
// exit ;
118896: GO 119037
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118898: LD_VAR 0 2
118902: PPUSH
118903: LD_VAR 0 3
118907: PPUSH
118908: CALL_OW 428
118912: PUSH
118913: LD_VAR 0 1
118917: EQUAL
118918: PUSH
118919: LD_VAR 0 1
118923: PPUSH
118924: CALL_OW 314
118928: NOT
118929: AND
118930: IFFALSE 118856
// PlaySoundXY ( x , y , PlantMine ) ;
118932: LD_VAR 0 2
118936: PPUSH
118937: LD_VAR 0 3
118941: PPUSH
118942: LD_STRING PlantMine
118944: PPUSH
118945: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
118949: LD_VAR 0 2
118953: PPUSH
118954: LD_VAR 0 3
118958: PPUSH
118959: LD_VAR 0 1
118963: PPUSH
118964: CALL_OW 255
118968: PPUSH
118969: LD_INT 0
118971: PPUSH
118972: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118976: LD_ADDR_EXP 224
118980: PUSH
118981: LD_EXP 224
118985: PPUSH
118986: LD_VAR 0 5
118990: PUSH
118991: LD_EXP 224
118995: PUSH
118996: LD_VAR 0 5
119000: ARRAY
119001: PUSH
119002: LD_INT 1
119004: PLUS
119005: PUSH
119006: EMPTY
119007: LIST
119008: LIST
119009: PPUSH
119010: LD_VAR 0 2
119014: PUSH
119015: LD_VAR 0 3
119019: PUSH
119020: EMPTY
119021: LIST
119022: LIST
119023: PPUSH
119024: CALL 70353 0 3
119028: ST_TO_ADDR
// result := true ;
119029: LD_ADDR_VAR 0 4
119033: PUSH
119034: LD_INT 1
119036: ST_TO_ADDR
// end ;
119037: LD_VAR 0 4
119041: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
119042: LD_INT 0
119044: PPUSH
119045: PPUSH
119046: PPUSH
// if not unit in minersList then
119047: LD_VAR 0 1
119051: PUSH
119052: LD_EXP 223
119056: IN
119057: NOT
119058: IFFALSE 119062
// exit ;
119060: GO 119454
// index := GetElementIndex ( minersList , unit ) ;
119062: LD_ADDR_VAR 0 6
119066: PUSH
119067: LD_EXP 223
119071: PPUSH
119072: LD_VAR 0 1
119076: PPUSH
119077: CALL 70138 0 2
119081: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
119082: LD_ADDR_VAR 0 5
119086: PUSH
119087: DOUBLE
119088: LD_EXP 224
119092: PUSH
119093: LD_VAR 0 6
119097: ARRAY
119098: INC
119099: ST_TO_ADDR
119100: LD_INT 1
119102: PUSH
119103: FOR_DOWNTO
119104: IFFALSE 119265
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
119106: LD_EXP 224
119110: PUSH
119111: LD_VAR 0 6
119115: ARRAY
119116: PUSH
119117: LD_VAR 0 5
119121: ARRAY
119122: PUSH
119123: LD_INT 1
119125: ARRAY
119126: PUSH
119127: LD_VAR 0 2
119131: EQUAL
119132: PUSH
119133: LD_EXP 224
119137: PUSH
119138: LD_VAR 0 6
119142: ARRAY
119143: PUSH
119144: LD_VAR 0 5
119148: ARRAY
119149: PUSH
119150: LD_INT 2
119152: ARRAY
119153: PUSH
119154: LD_VAR 0 3
119158: EQUAL
119159: AND
119160: IFFALSE 119263
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
119162: LD_EXP 224
119166: PUSH
119167: LD_VAR 0 6
119171: ARRAY
119172: PUSH
119173: LD_VAR 0 5
119177: ARRAY
119178: PUSH
119179: LD_INT 1
119181: ARRAY
119182: PPUSH
119183: LD_EXP 224
119187: PUSH
119188: LD_VAR 0 6
119192: ARRAY
119193: PUSH
119194: LD_VAR 0 5
119198: ARRAY
119199: PUSH
119200: LD_INT 2
119202: ARRAY
119203: PPUSH
119204: LD_VAR 0 1
119208: PPUSH
119209: CALL_OW 255
119213: PPUSH
119214: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
119218: LD_ADDR_EXP 224
119222: PUSH
119223: LD_EXP 224
119227: PPUSH
119228: LD_VAR 0 6
119232: PPUSH
119233: LD_EXP 224
119237: PUSH
119238: LD_VAR 0 6
119242: ARRAY
119243: PPUSH
119244: LD_VAR 0 5
119248: PPUSH
119249: CALL_OW 3
119253: PPUSH
119254: CALL_OW 1
119258: ST_TO_ADDR
// exit ;
119259: POP
119260: POP
119261: GO 119454
// end ; end ;
119263: GO 119103
119265: POP
119266: POP
// for i := minerMinesList [ index ] downto 1 do
119267: LD_ADDR_VAR 0 5
119271: PUSH
119272: DOUBLE
119273: LD_EXP 224
119277: PUSH
119278: LD_VAR 0 6
119282: ARRAY
119283: INC
119284: ST_TO_ADDR
119285: LD_INT 1
119287: PUSH
119288: FOR_DOWNTO
119289: IFFALSE 119452
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
119291: LD_EXP 224
119295: PUSH
119296: LD_VAR 0 6
119300: ARRAY
119301: PUSH
119302: LD_VAR 0 5
119306: ARRAY
119307: PUSH
119308: LD_INT 1
119310: ARRAY
119311: PPUSH
119312: LD_EXP 224
119316: PUSH
119317: LD_VAR 0 6
119321: ARRAY
119322: PUSH
119323: LD_VAR 0 5
119327: ARRAY
119328: PUSH
119329: LD_INT 2
119331: ARRAY
119332: PPUSH
119333: LD_VAR 0 2
119337: PPUSH
119338: LD_VAR 0 3
119342: PPUSH
119343: CALL_OW 298
119347: PUSH
119348: LD_INT 6
119350: LESS
119351: IFFALSE 119450
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
119353: LD_EXP 224
119357: PUSH
119358: LD_VAR 0 6
119362: ARRAY
119363: PUSH
119364: LD_VAR 0 5
119368: ARRAY
119369: PUSH
119370: LD_INT 1
119372: ARRAY
119373: PPUSH
119374: LD_EXP 224
119378: PUSH
119379: LD_VAR 0 6
119383: ARRAY
119384: PUSH
119385: LD_VAR 0 5
119389: ARRAY
119390: PUSH
119391: LD_INT 2
119393: ARRAY
119394: PPUSH
119395: LD_VAR 0 1
119399: PPUSH
119400: CALL_OW 255
119404: PPUSH
119405: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
119409: LD_ADDR_EXP 224
119413: PUSH
119414: LD_EXP 224
119418: PPUSH
119419: LD_VAR 0 6
119423: PPUSH
119424: LD_EXP 224
119428: PUSH
119429: LD_VAR 0 6
119433: ARRAY
119434: PPUSH
119435: LD_VAR 0 5
119439: PPUSH
119440: CALL_OW 3
119444: PPUSH
119445: CALL_OW 1
119449: ST_TO_ADDR
// end ; end ;
119450: GO 119288
119452: POP
119453: POP
// end ;
119454: LD_VAR 0 4
119458: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
119459: LD_INT 0
119461: PPUSH
119462: PPUSH
119463: PPUSH
119464: PPUSH
119465: PPUSH
119466: PPUSH
119467: PPUSH
119468: PPUSH
119469: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
119470: LD_VAR 0 1
119474: PPUSH
119475: CALL_OW 264
119479: PUSH
119480: LD_EXP 102
119484: EQUAL
119485: NOT
119486: PUSH
119487: LD_VAR 0 1
119491: PUSH
119492: LD_EXP 223
119496: IN
119497: NOT
119498: OR
119499: IFFALSE 119503
// exit ;
119501: GO 119825
// index := GetElementIndex ( minersList , unit ) ;
119503: LD_ADDR_VAR 0 6
119507: PUSH
119508: LD_EXP 223
119512: PPUSH
119513: LD_VAR 0 1
119517: PPUSH
119518: CALL 70138 0 2
119522: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
119523: LD_ADDR_VAR 0 8
119527: PUSH
119528: LD_EXP 225
119532: PUSH
119533: LD_EXP 224
119537: PUSH
119538: LD_VAR 0 6
119542: ARRAY
119543: MINUS
119544: ST_TO_ADDR
// if not minesFreeAmount then
119545: LD_VAR 0 8
119549: NOT
119550: IFFALSE 119554
// exit ;
119552: GO 119825
// tmp := [ ] ;
119554: LD_ADDR_VAR 0 7
119558: PUSH
119559: EMPTY
119560: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
119561: LD_ADDR_VAR 0 5
119565: PUSH
119566: DOUBLE
119567: LD_INT 1
119569: DEC
119570: ST_TO_ADDR
119571: LD_VAR 0 8
119575: PUSH
119576: FOR_TO
119577: IFFALSE 119772
// begin _d := rand ( 0 , 5 ) ;
119579: LD_ADDR_VAR 0 11
119583: PUSH
119584: LD_INT 0
119586: PPUSH
119587: LD_INT 5
119589: PPUSH
119590: CALL_OW 12
119594: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
119595: LD_ADDR_VAR 0 12
119599: PUSH
119600: LD_INT 2
119602: PPUSH
119603: LD_INT 6
119605: PPUSH
119606: CALL_OW 12
119610: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
119611: LD_ADDR_VAR 0 9
119615: PUSH
119616: LD_VAR 0 2
119620: PPUSH
119621: LD_VAR 0 11
119625: PPUSH
119626: LD_VAR 0 12
119630: PPUSH
119631: CALL_OW 272
119635: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
119636: LD_ADDR_VAR 0 10
119640: PUSH
119641: LD_VAR 0 3
119645: PPUSH
119646: LD_VAR 0 11
119650: PPUSH
119651: LD_VAR 0 12
119655: PPUSH
119656: CALL_OW 273
119660: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
119661: LD_VAR 0 9
119665: PPUSH
119666: LD_VAR 0 10
119670: PPUSH
119671: CALL_OW 488
119675: PUSH
119676: LD_VAR 0 9
119680: PUSH
119681: LD_VAR 0 10
119685: PUSH
119686: EMPTY
119687: LIST
119688: LIST
119689: PUSH
119690: LD_VAR 0 7
119694: IN
119695: NOT
119696: AND
119697: PUSH
119698: LD_VAR 0 9
119702: PPUSH
119703: LD_VAR 0 10
119707: PPUSH
119708: CALL_OW 458
119712: NOT
119713: AND
119714: IFFALSE 119756
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
119716: LD_ADDR_VAR 0 7
119720: PUSH
119721: LD_VAR 0 7
119725: PPUSH
119726: LD_VAR 0 7
119730: PUSH
119731: LD_INT 1
119733: PLUS
119734: PPUSH
119735: LD_VAR 0 9
119739: PUSH
119740: LD_VAR 0 10
119744: PUSH
119745: EMPTY
119746: LIST
119747: LIST
119748: PPUSH
119749: CALL_OW 1
119753: ST_TO_ADDR
119754: GO 119770
// i := i - 1 ;
119756: LD_ADDR_VAR 0 5
119760: PUSH
119761: LD_VAR 0 5
119765: PUSH
119766: LD_INT 1
119768: MINUS
119769: ST_TO_ADDR
// end ;
119770: GO 119576
119772: POP
119773: POP
// for i in tmp do
119774: LD_ADDR_VAR 0 5
119778: PUSH
119779: LD_VAR 0 7
119783: PUSH
119784: FOR_IN
119785: IFFALSE 119823
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
119787: LD_VAR 0 1
119791: PPUSH
119792: LD_VAR 0 5
119796: PUSH
119797: LD_INT 1
119799: ARRAY
119800: PPUSH
119801: LD_VAR 0 5
119805: PUSH
119806: LD_INT 2
119808: ARRAY
119809: PPUSH
119810: CALL 118765 0 3
119814: NOT
119815: IFFALSE 119821
// exit ;
119817: POP
119818: POP
119819: GO 119825
119821: GO 119784
119823: POP
119824: POP
// end ;
119825: LD_VAR 0 4
119829: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
119830: LD_INT 0
119832: PPUSH
119833: PPUSH
119834: PPUSH
119835: PPUSH
119836: PPUSH
119837: PPUSH
119838: PPUSH
// if not GetClass ( unit ) = class_sniper then
119839: LD_VAR 0 1
119843: PPUSH
119844: CALL_OW 257
119848: PUSH
119849: LD_INT 5
119851: EQUAL
119852: NOT
119853: IFFALSE 119857
// exit ;
119855: GO 120245
// dist := 8 ;
119857: LD_ADDR_VAR 0 5
119861: PUSH
119862: LD_INT 8
119864: ST_TO_ADDR
// viewRange := 12 ;
119865: LD_ADDR_VAR 0 7
119869: PUSH
119870: LD_INT 12
119872: ST_TO_ADDR
// side := GetSide ( unit ) ;
119873: LD_ADDR_VAR 0 6
119877: PUSH
119878: LD_VAR 0 1
119882: PPUSH
119883: CALL_OW 255
119887: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119888: LD_INT 61
119890: PPUSH
119891: LD_VAR 0 6
119895: PPUSH
119896: CALL_OW 321
119900: PUSH
119901: LD_INT 2
119903: EQUAL
119904: IFFALSE 119914
// viewRange := 16 ;
119906: LD_ADDR_VAR 0 7
119910: PUSH
119911: LD_INT 16
119913: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119914: LD_VAR 0 1
119918: PPUSH
119919: LD_VAR 0 2
119923: PPUSH
119924: LD_VAR 0 3
119928: PPUSH
119929: CALL_OW 297
119933: PUSH
119934: LD_VAR 0 5
119938: GREATER
119939: IFFALSE 120018
// begin ComMoveXY ( unit , x , y ) ;
119941: LD_VAR 0 1
119945: PPUSH
119946: LD_VAR 0 2
119950: PPUSH
119951: LD_VAR 0 3
119955: PPUSH
119956: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119960: LD_INT 35
119962: PPUSH
119963: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119967: LD_VAR 0 1
119971: PPUSH
119972: LD_VAR 0 2
119976: PPUSH
119977: LD_VAR 0 3
119981: PPUSH
119982: CALL 100535 0 3
119986: NOT
119987: IFFALSE 119991
// exit ;
119989: GO 120245
// until GetDistUnitXY ( unit , x , y ) < dist ;
119991: LD_VAR 0 1
119995: PPUSH
119996: LD_VAR 0 2
120000: PPUSH
120001: LD_VAR 0 3
120005: PPUSH
120006: CALL_OW 297
120010: PUSH
120011: LD_VAR 0 5
120015: LESS
120016: IFFALSE 119960
// end ; ComTurnXY ( unit , x , y ) ;
120018: LD_VAR 0 1
120022: PPUSH
120023: LD_VAR 0 2
120027: PPUSH
120028: LD_VAR 0 3
120032: PPUSH
120033: CALL_OW 118
// wait ( 5 ) ;
120037: LD_INT 5
120039: PPUSH
120040: CALL_OW 67
// _d := GetDir ( unit ) ;
120044: LD_ADDR_VAR 0 10
120048: PUSH
120049: LD_VAR 0 1
120053: PPUSH
120054: CALL_OW 254
120058: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
120059: LD_ADDR_VAR 0 8
120063: PUSH
120064: LD_VAR 0 1
120068: PPUSH
120069: CALL_OW 250
120073: PPUSH
120074: LD_VAR 0 10
120078: PPUSH
120079: LD_VAR 0 5
120083: PPUSH
120084: CALL_OW 272
120088: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
120089: LD_ADDR_VAR 0 9
120093: PUSH
120094: LD_VAR 0 1
120098: PPUSH
120099: CALL_OW 251
120103: PPUSH
120104: LD_VAR 0 10
120108: PPUSH
120109: LD_VAR 0 5
120113: PPUSH
120114: CALL_OW 273
120118: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
120119: LD_VAR 0 8
120123: PPUSH
120124: LD_VAR 0 9
120128: PPUSH
120129: CALL_OW 488
120133: NOT
120134: IFFALSE 120138
// exit ;
120136: GO 120245
// ComAnimCustom ( unit , 1 ) ;
120138: LD_VAR 0 1
120142: PPUSH
120143: LD_INT 1
120145: PPUSH
120146: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
120150: LD_VAR 0 8
120154: PPUSH
120155: LD_VAR 0 9
120159: PPUSH
120160: LD_VAR 0 6
120164: PPUSH
120165: LD_VAR 0 7
120169: PPUSH
120170: CALL_OW 330
// repeat wait ( 1 ) ;
120174: LD_INT 1
120176: PPUSH
120177: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
120181: LD_VAR 0 1
120185: PPUSH
120186: CALL_OW 316
120190: PUSH
120191: LD_VAR 0 1
120195: PPUSH
120196: CALL_OW 314
120200: OR
120201: PUSH
120202: LD_VAR 0 1
120206: PPUSH
120207: CALL_OW 302
120211: NOT
120212: OR
120213: PUSH
120214: LD_VAR 0 1
120218: PPUSH
120219: CALL_OW 301
120223: OR
120224: IFFALSE 120174
// RemoveSeeing ( _x , _y , side ) ;
120226: LD_VAR 0 8
120230: PPUSH
120231: LD_VAR 0 9
120235: PPUSH
120236: LD_VAR 0 6
120240: PPUSH
120241: CALL_OW 331
// end ; end_of_file
120245: LD_VAR 0 4
120249: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
120250: LD_INT 0
120252: PPUSH
120253: PPUSH
120254: PPUSH
120255: PPUSH
120256: PPUSH
120257: PPUSH
120258: PPUSH
120259: PPUSH
120260: PPUSH
120261: PPUSH
120262: PPUSH
120263: PPUSH
120264: PPUSH
120265: PPUSH
120266: PPUSH
120267: PPUSH
120268: PPUSH
120269: PPUSH
120270: PPUSH
120271: PPUSH
120272: PPUSH
120273: PPUSH
120274: PPUSH
120275: PPUSH
120276: PPUSH
120277: PPUSH
120278: PPUSH
120279: PPUSH
120280: PPUSH
120281: PPUSH
120282: PPUSH
120283: PPUSH
120284: PPUSH
120285: PPUSH
// if not list then
120286: LD_VAR 0 1
120290: NOT
120291: IFFALSE 120295
// exit ;
120293: GO 124954
// base := list [ 1 ] ;
120295: LD_ADDR_VAR 0 3
120299: PUSH
120300: LD_VAR 0 1
120304: PUSH
120305: LD_INT 1
120307: ARRAY
120308: ST_TO_ADDR
// group := list [ 2 ] ;
120309: LD_ADDR_VAR 0 4
120313: PUSH
120314: LD_VAR 0 1
120318: PUSH
120319: LD_INT 2
120321: ARRAY
120322: ST_TO_ADDR
// path := list [ 3 ] ;
120323: LD_ADDR_VAR 0 5
120327: PUSH
120328: LD_VAR 0 1
120332: PUSH
120333: LD_INT 3
120335: ARRAY
120336: ST_TO_ADDR
// flags := list [ 4 ] ;
120337: LD_ADDR_VAR 0 6
120341: PUSH
120342: LD_VAR 0 1
120346: PUSH
120347: LD_INT 4
120349: ARRAY
120350: ST_TO_ADDR
// mined := [ ] ;
120351: LD_ADDR_VAR 0 27
120355: PUSH
120356: EMPTY
120357: ST_TO_ADDR
// bombed := [ ] ;
120358: LD_ADDR_VAR 0 28
120362: PUSH
120363: EMPTY
120364: ST_TO_ADDR
// healers := [ ] ;
120365: LD_ADDR_VAR 0 31
120369: PUSH
120370: EMPTY
120371: ST_TO_ADDR
// to_heal := [ ] ;
120372: LD_ADDR_VAR 0 30
120376: PUSH
120377: EMPTY
120378: ST_TO_ADDR
// repairs := [ ] ;
120379: LD_ADDR_VAR 0 33
120383: PUSH
120384: EMPTY
120385: ST_TO_ADDR
// to_repair := [ ] ;
120386: LD_ADDR_VAR 0 32
120390: PUSH
120391: EMPTY
120392: ST_TO_ADDR
// if not group or not path then
120393: LD_VAR 0 4
120397: NOT
120398: PUSH
120399: LD_VAR 0 5
120403: NOT
120404: OR
120405: IFFALSE 120409
// exit ;
120407: GO 124954
// side := GetSide ( group [ 1 ] ) ;
120409: LD_ADDR_VAR 0 35
120413: PUSH
120414: LD_VAR 0 4
120418: PUSH
120419: LD_INT 1
120421: ARRAY
120422: PPUSH
120423: CALL_OW 255
120427: ST_TO_ADDR
// if flags then
120428: LD_VAR 0 6
120432: IFFALSE 120576
// begin f_ignore_area := flags [ 1 ] ;
120434: LD_ADDR_VAR 0 17
120438: PUSH
120439: LD_VAR 0 6
120443: PUSH
120444: LD_INT 1
120446: ARRAY
120447: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
120448: LD_ADDR_VAR 0 18
120452: PUSH
120453: LD_VAR 0 6
120457: PUSH
120458: LD_INT 2
120460: ARRAY
120461: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
120462: LD_ADDR_VAR 0 19
120466: PUSH
120467: LD_VAR 0 6
120471: PUSH
120472: LD_INT 3
120474: ARRAY
120475: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
120476: LD_ADDR_VAR 0 20
120480: PUSH
120481: LD_VAR 0 6
120485: PUSH
120486: LD_INT 4
120488: ARRAY
120489: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
120490: LD_ADDR_VAR 0 21
120494: PUSH
120495: LD_VAR 0 6
120499: PUSH
120500: LD_INT 5
120502: ARRAY
120503: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
120504: LD_ADDR_VAR 0 22
120508: PUSH
120509: LD_VAR 0 6
120513: PUSH
120514: LD_INT 6
120516: ARRAY
120517: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
120518: LD_ADDR_VAR 0 23
120522: PUSH
120523: LD_VAR 0 6
120527: PUSH
120528: LD_INT 7
120530: ARRAY
120531: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
120532: LD_ADDR_VAR 0 24
120536: PUSH
120537: LD_VAR 0 6
120541: PUSH
120542: LD_INT 8
120544: ARRAY
120545: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
120546: LD_ADDR_VAR 0 25
120550: PUSH
120551: LD_VAR 0 6
120555: PUSH
120556: LD_INT 9
120558: ARRAY
120559: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
120560: LD_ADDR_VAR 0 26
120564: PUSH
120565: LD_VAR 0 6
120569: PUSH
120570: LD_INT 10
120572: ARRAY
120573: ST_TO_ADDR
// end else
120574: GO 120656
// begin f_ignore_area := false ;
120576: LD_ADDR_VAR 0 17
120580: PUSH
120581: LD_INT 0
120583: ST_TO_ADDR
// f_capture := false ;
120584: LD_ADDR_VAR 0 18
120588: PUSH
120589: LD_INT 0
120591: ST_TO_ADDR
// f_ignore_civ := false ;
120592: LD_ADDR_VAR 0 19
120596: PUSH
120597: LD_INT 0
120599: ST_TO_ADDR
// f_murder := false ;
120600: LD_ADDR_VAR 0 20
120604: PUSH
120605: LD_INT 0
120607: ST_TO_ADDR
// f_mines := false ;
120608: LD_ADDR_VAR 0 21
120612: PUSH
120613: LD_INT 0
120615: ST_TO_ADDR
// f_repair := false ;
120616: LD_ADDR_VAR 0 22
120620: PUSH
120621: LD_INT 0
120623: ST_TO_ADDR
// f_heal := false ;
120624: LD_ADDR_VAR 0 23
120628: PUSH
120629: LD_INT 0
120631: ST_TO_ADDR
// f_spacetime := false ;
120632: LD_ADDR_VAR 0 24
120636: PUSH
120637: LD_INT 0
120639: ST_TO_ADDR
// f_attack_depot := false ;
120640: LD_ADDR_VAR 0 25
120644: PUSH
120645: LD_INT 0
120647: ST_TO_ADDR
// f_crawl := false ;
120648: LD_ADDR_VAR 0 26
120652: PUSH
120653: LD_INT 0
120655: ST_TO_ADDR
// end ; if f_heal then
120656: LD_VAR 0 23
120660: IFFALSE 120687
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
120662: LD_ADDR_VAR 0 31
120666: PUSH
120667: LD_VAR 0 4
120671: PPUSH
120672: LD_INT 25
120674: PUSH
120675: LD_INT 4
120677: PUSH
120678: EMPTY
120679: LIST
120680: LIST
120681: PPUSH
120682: CALL_OW 72
120686: ST_TO_ADDR
// if f_repair then
120687: LD_VAR 0 22
120691: IFFALSE 120718
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
120693: LD_ADDR_VAR 0 33
120697: PUSH
120698: LD_VAR 0 4
120702: PPUSH
120703: LD_INT 25
120705: PUSH
120706: LD_INT 3
120708: PUSH
120709: EMPTY
120710: LIST
120711: LIST
120712: PPUSH
120713: CALL_OW 72
120717: ST_TO_ADDR
// units_path := [ ] ;
120718: LD_ADDR_VAR 0 16
120722: PUSH
120723: EMPTY
120724: ST_TO_ADDR
// for i = 1 to group do
120725: LD_ADDR_VAR 0 7
120729: PUSH
120730: DOUBLE
120731: LD_INT 1
120733: DEC
120734: ST_TO_ADDR
120735: LD_VAR 0 4
120739: PUSH
120740: FOR_TO
120741: IFFALSE 120770
// units_path := Replace ( units_path , i , path ) ;
120743: LD_ADDR_VAR 0 16
120747: PUSH
120748: LD_VAR 0 16
120752: PPUSH
120753: LD_VAR 0 7
120757: PPUSH
120758: LD_VAR 0 5
120762: PPUSH
120763: CALL_OW 1
120767: ST_TO_ADDR
120768: GO 120740
120770: POP
120771: POP
// repeat for i = group downto 1 do
120772: LD_ADDR_VAR 0 7
120776: PUSH
120777: DOUBLE
120778: LD_VAR 0 4
120782: INC
120783: ST_TO_ADDR
120784: LD_INT 1
120786: PUSH
120787: FOR_DOWNTO
120788: IFFALSE 124910
// begin wait ( 5 ) ;
120790: LD_INT 5
120792: PPUSH
120793: CALL_OW 67
// tmp := [ ] ;
120797: LD_ADDR_VAR 0 14
120801: PUSH
120802: EMPTY
120803: ST_TO_ADDR
// attacking := false ;
120804: LD_ADDR_VAR 0 29
120808: PUSH
120809: LD_INT 0
120811: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
120812: LD_VAR 0 4
120816: PUSH
120817: LD_VAR 0 7
120821: ARRAY
120822: PPUSH
120823: CALL_OW 301
120827: PUSH
120828: LD_VAR 0 4
120832: PUSH
120833: LD_VAR 0 7
120837: ARRAY
120838: NOT
120839: OR
120840: IFFALSE 120949
// begin if GetType ( group [ i ] ) = unit_human then
120842: LD_VAR 0 4
120846: PUSH
120847: LD_VAR 0 7
120851: ARRAY
120852: PPUSH
120853: CALL_OW 247
120857: PUSH
120858: LD_INT 1
120860: EQUAL
120861: IFFALSE 120907
// begin to_heal := to_heal diff group [ i ] ;
120863: LD_ADDR_VAR 0 30
120867: PUSH
120868: LD_VAR 0 30
120872: PUSH
120873: LD_VAR 0 4
120877: PUSH
120878: LD_VAR 0 7
120882: ARRAY
120883: DIFF
120884: ST_TO_ADDR
// healers := healers diff group [ i ] ;
120885: LD_ADDR_VAR 0 31
120889: PUSH
120890: LD_VAR 0 31
120894: PUSH
120895: LD_VAR 0 4
120899: PUSH
120900: LD_VAR 0 7
120904: ARRAY
120905: DIFF
120906: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
120907: LD_ADDR_VAR 0 4
120911: PUSH
120912: LD_VAR 0 4
120916: PPUSH
120917: LD_VAR 0 7
120921: PPUSH
120922: CALL_OW 3
120926: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
120927: LD_ADDR_VAR 0 16
120931: PUSH
120932: LD_VAR 0 16
120936: PPUSH
120937: LD_VAR 0 7
120941: PPUSH
120942: CALL_OW 3
120946: ST_TO_ADDR
// continue ;
120947: GO 120787
// end ; if f_repair then
120949: LD_VAR 0 22
120953: IFFALSE 121442
// begin if GetType ( group [ i ] ) = unit_vehicle then
120955: LD_VAR 0 4
120959: PUSH
120960: LD_VAR 0 7
120964: ARRAY
120965: PPUSH
120966: CALL_OW 247
120970: PUSH
120971: LD_INT 2
120973: EQUAL
120974: IFFALSE 121164
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
120976: LD_VAR 0 4
120980: PUSH
120981: LD_VAR 0 7
120985: ARRAY
120986: PPUSH
120987: CALL_OW 256
120991: PUSH
120992: LD_INT 700
120994: LESS
120995: PUSH
120996: LD_VAR 0 4
121000: PUSH
121001: LD_VAR 0 7
121005: ARRAY
121006: PUSH
121007: LD_VAR 0 32
121011: IN
121012: NOT
121013: AND
121014: IFFALSE 121038
// to_repair := to_repair union group [ i ] ;
121016: LD_ADDR_VAR 0 32
121020: PUSH
121021: LD_VAR 0 32
121025: PUSH
121026: LD_VAR 0 4
121030: PUSH
121031: LD_VAR 0 7
121035: ARRAY
121036: UNION
121037: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
121038: LD_VAR 0 4
121042: PUSH
121043: LD_VAR 0 7
121047: ARRAY
121048: PPUSH
121049: CALL_OW 256
121053: PUSH
121054: LD_INT 1000
121056: EQUAL
121057: PUSH
121058: LD_VAR 0 4
121062: PUSH
121063: LD_VAR 0 7
121067: ARRAY
121068: PUSH
121069: LD_VAR 0 32
121073: IN
121074: AND
121075: IFFALSE 121099
// to_repair := to_repair diff group [ i ] ;
121077: LD_ADDR_VAR 0 32
121081: PUSH
121082: LD_VAR 0 32
121086: PUSH
121087: LD_VAR 0 4
121091: PUSH
121092: LD_VAR 0 7
121096: ARRAY
121097: DIFF
121098: ST_TO_ADDR
// if group [ i ] in to_repair then
121099: LD_VAR 0 4
121103: PUSH
121104: LD_VAR 0 7
121108: ARRAY
121109: PUSH
121110: LD_VAR 0 32
121114: IN
121115: IFFALSE 121162
// begin if not IsInArea ( group [ i ] , f_repair ) then
121117: LD_VAR 0 4
121121: PUSH
121122: LD_VAR 0 7
121126: ARRAY
121127: PPUSH
121128: LD_VAR 0 22
121132: PPUSH
121133: CALL_OW 308
121137: NOT
121138: IFFALSE 121160
// ComMoveToArea ( group [ i ] , f_repair ) ;
121140: LD_VAR 0 4
121144: PUSH
121145: LD_VAR 0 7
121149: ARRAY
121150: PPUSH
121151: LD_VAR 0 22
121155: PPUSH
121156: CALL_OW 113
// continue ;
121160: GO 120787
// end ; end else
121162: GO 121442
// if group [ i ] in repairs then
121164: LD_VAR 0 4
121168: PUSH
121169: LD_VAR 0 7
121173: ARRAY
121174: PUSH
121175: LD_VAR 0 33
121179: IN
121180: IFFALSE 121442
// begin if IsInUnit ( group [ i ] ) then
121182: LD_VAR 0 4
121186: PUSH
121187: LD_VAR 0 7
121191: ARRAY
121192: PPUSH
121193: CALL_OW 310
121197: IFFALSE 121265
// begin z := IsInUnit ( group [ i ] ) ;
121199: LD_ADDR_VAR 0 13
121203: PUSH
121204: LD_VAR 0 4
121208: PUSH
121209: LD_VAR 0 7
121213: ARRAY
121214: PPUSH
121215: CALL_OW 310
121219: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
121220: LD_VAR 0 13
121224: PUSH
121225: LD_VAR 0 32
121229: IN
121230: PUSH
121231: LD_VAR 0 13
121235: PPUSH
121236: LD_VAR 0 22
121240: PPUSH
121241: CALL_OW 308
121245: AND
121246: IFFALSE 121263
// ComExitVehicle ( group [ i ] ) ;
121248: LD_VAR 0 4
121252: PUSH
121253: LD_VAR 0 7
121257: ARRAY
121258: PPUSH
121259: CALL_OW 121
// end else
121263: GO 121442
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
121265: LD_ADDR_VAR 0 13
121269: PUSH
121270: LD_VAR 0 4
121274: PPUSH
121275: LD_INT 95
121277: PUSH
121278: LD_VAR 0 22
121282: PUSH
121283: EMPTY
121284: LIST
121285: LIST
121286: PUSH
121287: LD_INT 58
121289: PUSH
121290: EMPTY
121291: LIST
121292: PUSH
121293: EMPTY
121294: LIST
121295: LIST
121296: PPUSH
121297: CALL_OW 72
121301: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
121302: LD_VAR 0 4
121306: PUSH
121307: LD_VAR 0 7
121311: ARRAY
121312: PPUSH
121313: CALL_OW 314
121317: NOT
121318: IFFALSE 121440
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
121320: LD_ADDR_VAR 0 10
121324: PUSH
121325: LD_VAR 0 13
121329: PPUSH
121330: LD_VAR 0 4
121334: PUSH
121335: LD_VAR 0 7
121339: ARRAY
121340: PPUSH
121341: CALL_OW 74
121345: ST_TO_ADDR
// if not x then
121346: LD_VAR 0 10
121350: NOT
121351: IFFALSE 121355
// continue ;
121353: GO 120787
// if GetLives ( x ) < 1000 then
121355: LD_VAR 0 10
121359: PPUSH
121360: CALL_OW 256
121364: PUSH
121365: LD_INT 1000
121367: LESS
121368: IFFALSE 121392
// ComRepairVehicle ( group [ i ] , x ) else
121370: LD_VAR 0 4
121374: PUSH
121375: LD_VAR 0 7
121379: ARRAY
121380: PPUSH
121381: LD_VAR 0 10
121385: PPUSH
121386: CALL_OW 129
121390: GO 121440
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
121392: LD_VAR 0 23
121396: PUSH
121397: LD_VAR 0 4
121401: PUSH
121402: LD_VAR 0 7
121406: ARRAY
121407: PPUSH
121408: CALL_OW 256
121412: PUSH
121413: LD_INT 1000
121415: LESS
121416: AND
121417: NOT
121418: IFFALSE 121440
// ComEnterUnit ( group [ i ] , x ) ;
121420: LD_VAR 0 4
121424: PUSH
121425: LD_VAR 0 7
121429: ARRAY
121430: PPUSH
121431: LD_VAR 0 10
121435: PPUSH
121436: CALL_OW 120
// end ; continue ;
121440: GO 120787
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
121442: LD_VAR 0 23
121446: PUSH
121447: LD_VAR 0 4
121451: PUSH
121452: LD_VAR 0 7
121456: ARRAY
121457: PPUSH
121458: CALL_OW 247
121462: PUSH
121463: LD_INT 1
121465: EQUAL
121466: AND
121467: IFFALSE 121945
// begin if group [ i ] in healers then
121469: LD_VAR 0 4
121473: PUSH
121474: LD_VAR 0 7
121478: ARRAY
121479: PUSH
121480: LD_VAR 0 31
121484: IN
121485: IFFALSE 121758
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
121487: LD_VAR 0 4
121491: PUSH
121492: LD_VAR 0 7
121496: ARRAY
121497: PPUSH
121498: LD_VAR 0 23
121502: PPUSH
121503: CALL_OW 308
121507: NOT
121508: PUSH
121509: LD_VAR 0 4
121513: PUSH
121514: LD_VAR 0 7
121518: ARRAY
121519: PPUSH
121520: CALL_OW 314
121524: NOT
121525: AND
121526: IFFALSE 121550
// ComMoveToArea ( group [ i ] , f_heal ) else
121528: LD_VAR 0 4
121532: PUSH
121533: LD_VAR 0 7
121537: ARRAY
121538: PPUSH
121539: LD_VAR 0 23
121543: PPUSH
121544: CALL_OW 113
121548: GO 121756
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
121550: LD_VAR 0 4
121554: PUSH
121555: LD_VAR 0 7
121559: ARRAY
121560: PPUSH
121561: CALL 99058 0 1
121565: PPUSH
121566: CALL_OW 256
121570: PUSH
121571: LD_INT 1000
121573: EQUAL
121574: IFFALSE 121593
// ComStop ( group [ i ] ) else
121576: LD_VAR 0 4
121580: PUSH
121581: LD_VAR 0 7
121585: ARRAY
121586: PPUSH
121587: CALL_OW 141
121591: GO 121756
// if not HasTask ( group [ i ] ) and to_heal then
121593: LD_VAR 0 4
121597: PUSH
121598: LD_VAR 0 7
121602: ARRAY
121603: PPUSH
121604: CALL_OW 314
121608: NOT
121609: PUSH
121610: LD_VAR 0 30
121614: AND
121615: IFFALSE 121756
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
121617: LD_ADDR_VAR 0 13
121621: PUSH
121622: LD_VAR 0 30
121626: PPUSH
121627: LD_INT 3
121629: PUSH
121630: LD_INT 54
121632: PUSH
121633: EMPTY
121634: LIST
121635: PUSH
121636: EMPTY
121637: LIST
121638: LIST
121639: PPUSH
121640: CALL_OW 72
121644: PPUSH
121645: LD_VAR 0 4
121649: PUSH
121650: LD_VAR 0 7
121654: ARRAY
121655: PPUSH
121656: CALL_OW 74
121660: ST_TO_ADDR
// if z then
121661: LD_VAR 0 13
121665: IFFALSE 121756
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
121667: LD_INT 91
121669: PUSH
121670: LD_VAR 0 13
121674: PUSH
121675: LD_INT 10
121677: PUSH
121678: EMPTY
121679: LIST
121680: LIST
121681: LIST
121682: PUSH
121683: LD_INT 81
121685: PUSH
121686: LD_VAR 0 13
121690: PPUSH
121691: CALL_OW 255
121695: PUSH
121696: EMPTY
121697: LIST
121698: LIST
121699: PUSH
121700: EMPTY
121701: LIST
121702: LIST
121703: PPUSH
121704: CALL_OW 69
121708: PUSH
121709: LD_INT 0
121711: EQUAL
121712: IFFALSE 121736
// ComHeal ( group [ i ] , z ) else
121714: LD_VAR 0 4
121718: PUSH
121719: LD_VAR 0 7
121723: ARRAY
121724: PPUSH
121725: LD_VAR 0 13
121729: PPUSH
121730: CALL_OW 128
121734: GO 121756
// ComMoveToArea ( group [ i ] , f_heal ) ;
121736: LD_VAR 0 4
121740: PUSH
121741: LD_VAR 0 7
121745: ARRAY
121746: PPUSH
121747: LD_VAR 0 23
121751: PPUSH
121752: CALL_OW 113
// end ; continue ;
121756: GO 120787
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
121758: LD_VAR 0 4
121762: PUSH
121763: LD_VAR 0 7
121767: ARRAY
121768: PPUSH
121769: CALL_OW 256
121773: PUSH
121774: LD_INT 700
121776: LESS
121777: PUSH
121778: LD_VAR 0 4
121782: PUSH
121783: LD_VAR 0 7
121787: ARRAY
121788: PUSH
121789: LD_VAR 0 30
121793: IN
121794: NOT
121795: AND
121796: IFFALSE 121820
// to_heal := to_heal union group [ i ] ;
121798: LD_ADDR_VAR 0 30
121802: PUSH
121803: LD_VAR 0 30
121807: PUSH
121808: LD_VAR 0 4
121812: PUSH
121813: LD_VAR 0 7
121817: ARRAY
121818: UNION
121819: ST_TO_ADDR
// if group [ i ] in to_heal then
121820: LD_VAR 0 4
121824: PUSH
121825: LD_VAR 0 7
121829: ARRAY
121830: PUSH
121831: LD_VAR 0 30
121835: IN
121836: IFFALSE 121945
// begin if GetLives ( group [ i ] ) = 1000 then
121838: LD_VAR 0 4
121842: PUSH
121843: LD_VAR 0 7
121847: ARRAY
121848: PPUSH
121849: CALL_OW 256
121853: PUSH
121854: LD_INT 1000
121856: EQUAL
121857: IFFALSE 121883
// to_heal := to_heal diff group [ i ] else
121859: LD_ADDR_VAR 0 30
121863: PUSH
121864: LD_VAR 0 30
121868: PUSH
121869: LD_VAR 0 4
121873: PUSH
121874: LD_VAR 0 7
121878: ARRAY
121879: DIFF
121880: ST_TO_ADDR
121881: GO 121945
// begin if not IsInArea ( group [ i ] , to_heal ) then
121883: LD_VAR 0 4
121887: PUSH
121888: LD_VAR 0 7
121892: ARRAY
121893: PPUSH
121894: LD_VAR 0 30
121898: PPUSH
121899: CALL_OW 308
121903: NOT
121904: IFFALSE 121928
// ComMoveToArea ( group [ i ] , f_heal ) else
121906: LD_VAR 0 4
121910: PUSH
121911: LD_VAR 0 7
121915: ARRAY
121916: PPUSH
121917: LD_VAR 0 23
121921: PPUSH
121922: CALL_OW 113
121926: GO 121943
// ComHold ( group [ i ] ) ;
121928: LD_VAR 0 4
121932: PUSH
121933: LD_VAR 0 7
121937: ARRAY
121938: PPUSH
121939: CALL_OW 140
// continue ;
121943: GO 120787
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
121945: LD_VAR 0 4
121949: PUSH
121950: LD_VAR 0 7
121954: ARRAY
121955: PPUSH
121956: LD_INT 10
121958: PPUSH
121959: CALL 97478 0 2
121963: NOT
121964: PUSH
121965: LD_VAR 0 16
121969: PUSH
121970: LD_VAR 0 7
121974: ARRAY
121975: PUSH
121976: EMPTY
121977: EQUAL
121978: NOT
121979: AND
121980: IFFALSE 122246
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
121982: LD_VAR 0 4
121986: PUSH
121987: LD_VAR 0 7
121991: ARRAY
121992: PPUSH
121993: CALL_OW 262
121997: PUSH
121998: LD_INT 1
122000: PUSH
122001: LD_INT 2
122003: PUSH
122004: EMPTY
122005: LIST
122006: LIST
122007: IN
122008: IFFALSE 122049
// if GetFuel ( group [ i ] ) < 10 then
122010: LD_VAR 0 4
122014: PUSH
122015: LD_VAR 0 7
122019: ARRAY
122020: PPUSH
122021: CALL_OW 261
122025: PUSH
122026: LD_INT 10
122028: LESS
122029: IFFALSE 122049
// SetFuel ( group [ i ] , 12 ) ;
122031: LD_VAR 0 4
122035: PUSH
122036: LD_VAR 0 7
122040: ARRAY
122041: PPUSH
122042: LD_INT 12
122044: PPUSH
122045: CALL_OW 240
// if units_path [ i ] then
122049: LD_VAR 0 16
122053: PUSH
122054: LD_VAR 0 7
122058: ARRAY
122059: IFFALSE 122244
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
122061: LD_VAR 0 4
122065: PUSH
122066: LD_VAR 0 7
122070: ARRAY
122071: PPUSH
122072: LD_VAR 0 16
122076: PUSH
122077: LD_VAR 0 7
122081: ARRAY
122082: PUSH
122083: LD_INT 1
122085: ARRAY
122086: PUSH
122087: LD_INT 1
122089: ARRAY
122090: PPUSH
122091: LD_VAR 0 16
122095: PUSH
122096: LD_VAR 0 7
122100: ARRAY
122101: PUSH
122102: LD_INT 1
122104: ARRAY
122105: PUSH
122106: LD_INT 2
122108: ARRAY
122109: PPUSH
122110: CALL_OW 297
122114: PUSH
122115: LD_INT 6
122117: GREATER
122118: IFFALSE 122193
// begin if not HasTask ( group [ i ] ) then
122120: LD_VAR 0 4
122124: PUSH
122125: LD_VAR 0 7
122129: ARRAY
122130: PPUSH
122131: CALL_OW 314
122135: NOT
122136: IFFALSE 122191
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
122138: LD_VAR 0 4
122142: PUSH
122143: LD_VAR 0 7
122147: ARRAY
122148: PPUSH
122149: LD_VAR 0 16
122153: PUSH
122154: LD_VAR 0 7
122158: ARRAY
122159: PUSH
122160: LD_INT 1
122162: ARRAY
122163: PUSH
122164: LD_INT 1
122166: ARRAY
122167: PPUSH
122168: LD_VAR 0 16
122172: PUSH
122173: LD_VAR 0 7
122177: ARRAY
122178: PUSH
122179: LD_INT 1
122181: ARRAY
122182: PUSH
122183: LD_INT 2
122185: ARRAY
122186: PPUSH
122187: CALL_OW 114
// end else
122191: GO 122244
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
122193: LD_ADDR_VAR 0 15
122197: PUSH
122198: LD_VAR 0 16
122202: PUSH
122203: LD_VAR 0 7
122207: ARRAY
122208: PPUSH
122209: LD_INT 1
122211: PPUSH
122212: CALL_OW 3
122216: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
122217: LD_ADDR_VAR 0 16
122221: PUSH
122222: LD_VAR 0 16
122226: PPUSH
122227: LD_VAR 0 7
122231: PPUSH
122232: LD_VAR 0 15
122236: PPUSH
122237: CALL_OW 1
122241: ST_TO_ADDR
// continue ;
122242: GO 120787
// end ; end ; end else
122244: GO 124908
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
122246: LD_ADDR_VAR 0 14
122250: PUSH
122251: LD_INT 81
122253: PUSH
122254: LD_VAR 0 4
122258: PUSH
122259: LD_VAR 0 7
122263: ARRAY
122264: PPUSH
122265: CALL_OW 255
122269: PUSH
122270: EMPTY
122271: LIST
122272: LIST
122273: PPUSH
122274: CALL_OW 69
122278: ST_TO_ADDR
// if not tmp then
122279: LD_VAR 0 14
122283: NOT
122284: IFFALSE 122288
// continue ;
122286: GO 120787
// if f_ignore_area then
122288: LD_VAR 0 17
122292: IFFALSE 122380
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
122294: LD_ADDR_VAR 0 15
122298: PUSH
122299: LD_VAR 0 14
122303: PPUSH
122304: LD_INT 3
122306: PUSH
122307: LD_INT 92
122309: PUSH
122310: LD_VAR 0 17
122314: PUSH
122315: LD_INT 1
122317: ARRAY
122318: PUSH
122319: LD_VAR 0 17
122323: PUSH
122324: LD_INT 2
122326: ARRAY
122327: PUSH
122328: LD_VAR 0 17
122332: PUSH
122333: LD_INT 3
122335: ARRAY
122336: PUSH
122337: EMPTY
122338: LIST
122339: LIST
122340: LIST
122341: LIST
122342: PUSH
122343: EMPTY
122344: LIST
122345: LIST
122346: PPUSH
122347: CALL_OW 72
122351: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122352: LD_VAR 0 14
122356: PUSH
122357: LD_VAR 0 15
122361: DIFF
122362: IFFALSE 122380
// tmp := tmp diff tmp2 ;
122364: LD_ADDR_VAR 0 14
122368: PUSH
122369: LD_VAR 0 14
122373: PUSH
122374: LD_VAR 0 15
122378: DIFF
122379: ST_TO_ADDR
// end ; if not f_murder then
122380: LD_VAR 0 20
122384: NOT
122385: IFFALSE 122443
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
122387: LD_ADDR_VAR 0 15
122391: PUSH
122392: LD_VAR 0 14
122396: PPUSH
122397: LD_INT 3
122399: PUSH
122400: LD_INT 50
122402: PUSH
122403: EMPTY
122404: LIST
122405: PUSH
122406: EMPTY
122407: LIST
122408: LIST
122409: PPUSH
122410: CALL_OW 72
122414: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122415: LD_VAR 0 14
122419: PUSH
122420: LD_VAR 0 15
122424: DIFF
122425: IFFALSE 122443
// tmp := tmp diff tmp2 ;
122427: LD_ADDR_VAR 0 14
122431: PUSH
122432: LD_VAR 0 14
122436: PUSH
122437: LD_VAR 0 15
122441: DIFF
122442: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
122443: LD_ADDR_VAR 0 14
122447: PUSH
122448: LD_VAR 0 4
122452: PUSH
122453: LD_VAR 0 7
122457: ARRAY
122458: PPUSH
122459: LD_VAR 0 14
122463: PPUSH
122464: LD_INT 1
122466: PPUSH
122467: LD_INT 1
122469: PPUSH
122470: CALL 70788 0 4
122474: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
122475: LD_VAR 0 4
122479: PUSH
122480: LD_VAR 0 7
122484: ARRAY
122485: PPUSH
122486: CALL_OW 257
122490: PUSH
122491: LD_INT 1
122493: EQUAL
122494: IFFALSE 122942
// begin if WantPlant ( group [ i ] ) then
122496: LD_VAR 0 4
122500: PUSH
122501: LD_VAR 0 7
122505: ARRAY
122506: PPUSH
122507: CALL 70289 0 1
122511: IFFALSE 122515
// continue ;
122513: GO 120787
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
122515: LD_VAR 0 18
122519: PUSH
122520: LD_VAR 0 4
122524: PUSH
122525: LD_VAR 0 7
122529: ARRAY
122530: PPUSH
122531: CALL_OW 310
122535: NOT
122536: AND
122537: PUSH
122538: LD_VAR 0 14
122542: PUSH
122543: LD_INT 1
122545: ARRAY
122546: PUSH
122547: LD_VAR 0 14
122551: PPUSH
122552: LD_INT 21
122554: PUSH
122555: LD_INT 2
122557: PUSH
122558: EMPTY
122559: LIST
122560: LIST
122561: PUSH
122562: LD_INT 58
122564: PUSH
122565: EMPTY
122566: LIST
122567: PUSH
122568: EMPTY
122569: LIST
122570: LIST
122571: PPUSH
122572: CALL_OW 72
122576: IN
122577: AND
122578: IFFALSE 122614
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
122580: LD_VAR 0 4
122584: PUSH
122585: LD_VAR 0 7
122589: ARRAY
122590: PPUSH
122591: LD_VAR 0 14
122595: PUSH
122596: LD_INT 1
122598: ARRAY
122599: PPUSH
122600: CALL_OW 120
// attacking := true ;
122604: LD_ADDR_VAR 0 29
122608: PUSH
122609: LD_INT 1
122611: ST_TO_ADDR
// continue ;
122612: GO 120787
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
122614: LD_VAR 0 26
122618: PUSH
122619: LD_VAR 0 4
122623: PUSH
122624: LD_VAR 0 7
122628: ARRAY
122629: PPUSH
122630: CALL_OW 257
122634: PUSH
122635: LD_INT 1
122637: EQUAL
122638: AND
122639: PUSH
122640: LD_VAR 0 4
122644: PUSH
122645: LD_VAR 0 7
122649: ARRAY
122650: PPUSH
122651: CALL_OW 256
122655: PUSH
122656: LD_INT 800
122658: LESS
122659: AND
122660: PUSH
122661: LD_VAR 0 4
122665: PUSH
122666: LD_VAR 0 7
122670: ARRAY
122671: PPUSH
122672: CALL_OW 318
122676: NOT
122677: AND
122678: IFFALSE 122695
// ComCrawl ( group [ i ] ) ;
122680: LD_VAR 0 4
122684: PUSH
122685: LD_VAR 0 7
122689: ARRAY
122690: PPUSH
122691: CALL_OW 137
// if f_mines then
122695: LD_VAR 0 21
122699: IFFALSE 122942
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
122701: LD_VAR 0 14
122705: PUSH
122706: LD_INT 1
122708: ARRAY
122709: PPUSH
122710: CALL_OW 247
122714: PUSH
122715: LD_INT 3
122717: EQUAL
122718: PUSH
122719: LD_VAR 0 14
122723: PUSH
122724: LD_INT 1
122726: ARRAY
122727: PUSH
122728: LD_VAR 0 27
122732: IN
122733: NOT
122734: AND
122735: IFFALSE 122942
// begin x := GetX ( tmp [ 1 ] ) ;
122737: LD_ADDR_VAR 0 10
122741: PUSH
122742: LD_VAR 0 14
122746: PUSH
122747: LD_INT 1
122749: ARRAY
122750: PPUSH
122751: CALL_OW 250
122755: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
122756: LD_ADDR_VAR 0 11
122760: PUSH
122761: LD_VAR 0 14
122765: PUSH
122766: LD_INT 1
122768: ARRAY
122769: PPUSH
122770: CALL_OW 251
122774: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
122775: LD_ADDR_VAR 0 12
122779: PUSH
122780: LD_VAR 0 4
122784: PUSH
122785: LD_VAR 0 7
122789: ARRAY
122790: PPUSH
122791: CALL 97563 0 1
122795: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
122796: LD_VAR 0 4
122800: PUSH
122801: LD_VAR 0 7
122805: ARRAY
122806: PPUSH
122807: LD_VAR 0 10
122811: PPUSH
122812: LD_VAR 0 11
122816: PPUSH
122817: LD_VAR 0 14
122821: PUSH
122822: LD_INT 1
122824: ARRAY
122825: PPUSH
122826: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
122830: LD_VAR 0 4
122834: PUSH
122835: LD_VAR 0 7
122839: ARRAY
122840: PPUSH
122841: LD_VAR 0 10
122845: PPUSH
122846: LD_VAR 0 12
122850: PPUSH
122851: LD_INT 7
122853: PPUSH
122854: CALL_OW 272
122858: PPUSH
122859: LD_VAR 0 11
122863: PPUSH
122864: LD_VAR 0 12
122868: PPUSH
122869: LD_INT 7
122871: PPUSH
122872: CALL_OW 273
122876: PPUSH
122877: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
122881: LD_VAR 0 4
122885: PUSH
122886: LD_VAR 0 7
122890: ARRAY
122891: PPUSH
122892: LD_INT 71
122894: PPUSH
122895: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
122899: LD_ADDR_VAR 0 27
122903: PUSH
122904: LD_VAR 0 27
122908: PPUSH
122909: LD_VAR 0 27
122913: PUSH
122914: LD_INT 1
122916: PLUS
122917: PPUSH
122918: LD_VAR 0 14
122922: PUSH
122923: LD_INT 1
122925: ARRAY
122926: PPUSH
122927: CALL_OW 1
122931: ST_TO_ADDR
// attacking := true ;
122932: LD_ADDR_VAR 0 29
122936: PUSH
122937: LD_INT 1
122939: ST_TO_ADDR
// continue ;
122940: GO 120787
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
122942: LD_VAR 0 4
122946: PUSH
122947: LD_VAR 0 7
122951: ARRAY
122952: PPUSH
122953: CALL_OW 257
122957: PUSH
122958: LD_INT 17
122960: EQUAL
122961: PUSH
122962: LD_VAR 0 4
122966: PUSH
122967: LD_VAR 0 7
122971: ARRAY
122972: PPUSH
122973: CALL_OW 110
122977: PUSH
122978: LD_INT 71
122980: EQUAL
122981: NOT
122982: AND
122983: IFFALSE 123129
// begin attacking := false ;
122985: LD_ADDR_VAR 0 29
122989: PUSH
122990: LD_INT 0
122992: ST_TO_ADDR
// k := 5 ;
122993: LD_ADDR_VAR 0 9
122997: PUSH
122998: LD_INT 5
123000: ST_TO_ADDR
// if tmp < k then
123001: LD_VAR 0 14
123005: PUSH
123006: LD_VAR 0 9
123010: LESS
123011: IFFALSE 123023
// k := tmp ;
123013: LD_ADDR_VAR 0 9
123017: PUSH
123018: LD_VAR 0 14
123022: ST_TO_ADDR
// for j = 1 to k do
123023: LD_ADDR_VAR 0 8
123027: PUSH
123028: DOUBLE
123029: LD_INT 1
123031: DEC
123032: ST_TO_ADDR
123033: LD_VAR 0 9
123037: PUSH
123038: FOR_TO
123039: IFFALSE 123127
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
123041: LD_VAR 0 14
123045: PUSH
123046: LD_VAR 0 8
123050: ARRAY
123051: PUSH
123052: LD_VAR 0 14
123056: PPUSH
123057: LD_INT 58
123059: PUSH
123060: EMPTY
123061: LIST
123062: PPUSH
123063: CALL_OW 72
123067: IN
123068: NOT
123069: IFFALSE 123125
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123071: LD_VAR 0 4
123075: PUSH
123076: LD_VAR 0 7
123080: ARRAY
123081: PPUSH
123082: LD_VAR 0 14
123086: PUSH
123087: LD_VAR 0 8
123091: ARRAY
123092: PPUSH
123093: CALL_OW 115
// attacking := true ;
123097: LD_ADDR_VAR 0 29
123101: PUSH
123102: LD_INT 1
123104: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
123105: LD_VAR 0 4
123109: PUSH
123110: LD_VAR 0 7
123114: ARRAY
123115: PPUSH
123116: LD_INT 71
123118: PPUSH
123119: CALL_OW 109
// continue ;
123123: GO 123038
// end ; end ;
123125: GO 123038
123127: POP
123128: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
123129: LD_VAR 0 4
123133: PUSH
123134: LD_VAR 0 7
123138: ARRAY
123139: PPUSH
123140: CALL_OW 257
123144: PUSH
123145: LD_INT 8
123147: EQUAL
123148: PUSH
123149: LD_VAR 0 4
123153: PUSH
123154: LD_VAR 0 7
123158: ARRAY
123159: PPUSH
123160: CALL_OW 264
123164: PUSH
123165: LD_INT 28
123167: PUSH
123168: LD_INT 45
123170: PUSH
123171: LD_INT 7
123173: PUSH
123174: LD_INT 47
123176: PUSH
123177: EMPTY
123178: LIST
123179: LIST
123180: LIST
123181: LIST
123182: IN
123183: OR
123184: IFFALSE 123440
// begin attacking := false ;
123186: LD_ADDR_VAR 0 29
123190: PUSH
123191: LD_INT 0
123193: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
123194: LD_VAR 0 14
123198: PUSH
123199: LD_INT 1
123201: ARRAY
123202: PPUSH
123203: CALL_OW 266
123207: PUSH
123208: LD_INT 32
123210: PUSH
123211: LD_INT 31
123213: PUSH
123214: LD_INT 33
123216: PUSH
123217: LD_INT 4
123219: PUSH
123220: LD_INT 5
123222: PUSH
123223: EMPTY
123224: LIST
123225: LIST
123226: LIST
123227: LIST
123228: LIST
123229: IN
123230: IFFALSE 123416
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
123232: LD_ADDR_VAR 0 9
123236: PUSH
123237: LD_VAR 0 14
123241: PUSH
123242: LD_INT 1
123244: ARRAY
123245: PPUSH
123246: CALL_OW 266
123250: PPUSH
123251: LD_VAR 0 14
123255: PUSH
123256: LD_INT 1
123258: ARRAY
123259: PPUSH
123260: CALL_OW 250
123264: PPUSH
123265: LD_VAR 0 14
123269: PUSH
123270: LD_INT 1
123272: ARRAY
123273: PPUSH
123274: CALL_OW 251
123278: PPUSH
123279: LD_VAR 0 14
123283: PUSH
123284: LD_INT 1
123286: ARRAY
123287: PPUSH
123288: CALL_OW 254
123292: PPUSH
123293: LD_VAR 0 14
123297: PUSH
123298: LD_INT 1
123300: ARRAY
123301: PPUSH
123302: CALL_OW 248
123306: PPUSH
123307: LD_INT 0
123309: PPUSH
123310: CALL 78933 0 6
123314: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
123315: LD_ADDR_VAR 0 8
123319: PUSH
123320: LD_VAR 0 4
123324: PUSH
123325: LD_VAR 0 7
123329: ARRAY
123330: PPUSH
123331: LD_VAR 0 9
123335: PPUSH
123336: CALL 97603 0 2
123340: ST_TO_ADDR
// if j then
123341: LD_VAR 0 8
123345: IFFALSE 123414
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
123347: LD_VAR 0 8
123351: PUSH
123352: LD_INT 1
123354: ARRAY
123355: PPUSH
123356: LD_VAR 0 8
123360: PUSH
123361: LD_INT 2
123363: ARRAY
123364: PPUSH
123365: CALL_OW 488
123369: IFFALSE 123414
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
123371: LD_VAR 0 4
123375: PUSH
123376: LD_VAR 0 7
123380: ARRAY
123381: PPUSH
123382: LD_VAR 0 8
123386: PUSH
123387: LD_INT 1
123389: ARRAY
123390: PPUSH
123391: LD_VAR 0 8
123395: PUSH
123396: LD_INT 2
123398: ARRAY
123399: PPUSH
123400: CALL_OW 116
// attacking := true ;
123404: LD_ADDR_VAR 0 29
123408: PUSH
123409: LD_INT 1
123411: ST_TO_ADDR
// continue ;
123412: GO 120787
// end ; end else
123414: GO 123440
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123416: LD_VAR 0 4
123420: PUSH
123421: LD_VAR 0 7
123425: ARRAY
123426: PPUSH
123427: LD_VAR 0 14
123431: PUSH
123432: LD_INT 1
123434: ARRAY
123435: PPUSH
123436: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
123440: LD_VAR 0 4
123444: PUSH
123445: LD_VAR 0 7
123449: ARRAY
123450: PPUSH
123451: CALL_OW 265
123455: PUSH
123456: LD_INT 11
123458: EQUAL
123459: IFFALSE 123737
// begin k := 10 ;
123461: LD_ADDR_VAR 0 9
123465: PUSH
123466: LD_INT 10
123468: ST_TO_ADDR
// x := 0 ;
123469: LD_ADDR_VAR 0 10
123473: PUSH
123474: LD_INT 0
123476: ST_TO_ADDR
// if tmp < k then
123477: LD_VAR 0 14
123481: PUSH
123482: LD_VAR 0 9
123486: LESS
123487: IFFALSE 123499
// k := tmp ;
123489: LD_ADDR_VAR 0 9
123493: PUSH
123494: LD_VAR 0 14
123498: ST_TO_ADDR
// for j = k downto 1 do
123499: LD_ADDR_VAR 0 8
123503: PUSH
123504: DOUBLE
123505: LD_VAR 0 9
123509: INC
123510: ST_TO_ADDR
123511: LD_INT 1
123513: PUSH
123514: FOR_DOWNTO
123515: IFFALSE 123590
// begin if GetType ( tmp [ j ] ) = unit_human then
123517: LD_VAR 0 14
123521: PUSH
123522: LD_VAR 0 8
123526: ARRAY
123527: PPUSH
123528: CALL_OW 247
123532: PUSH
123533: LD_INT 1
123535: EQUAL
123536: IFFALSE 123588
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
123538: LD_VAR 0 4
123542: PUSH
123543: LD_VAR 0 7
123547: ARRAY
123548: PPUSH
123549: LD_VAR 0 14
123553: PUSH
123554: LD_VAR 0 8
123558: ARRAY
123559: PPUSH
123560: CALL 97874 0 2
// x := tmp [ j ] ;
123564: LD_ADDR_VAR 0 10
123568: PUSH
123569: LD_VAR 0 14
123573: PUSH
123574: LD_VAR 0 8
123578: ARRAY
123579: ST_TO_ADDR
// attacking := true ;
123580: LD_ADDR_VAR 0 29
123584: PUSH
123585: LD_INT 1
123587: ST_TO_ADDR
// end ; end ;
123588: GO 123514
123590: POP
123591: POP
// if not x then
123592: LD_VAR 0 10
123596: NOT
123597: IFFALSE 123737
// begin attacking := true ;
123599: LD_ADDR_VAR 0 29
123603: PUSH
123604: LD_INT 1
123606: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
123607: LD_VAR 0 4
123611: PUSH
123612: LD_VAR 0 7
123616: ARRAY
123617: PPUSH
123618: CALL_OW 250
123622: PPUSH
123623: LD_VAR 0 4
123627: PUSH
123628: LD_VAR 0 7
123632: ARRAY
123633: PPUSH
123634: CALL_OW 251
123638: PPUSH
123639: CALL_OW 546
123643: PUSH
123644: LD_INT 2
123646: ARRAY
123647: PUSH
123648: LD_VAR 0 14
123652: PUSH
123653: LD_INT 1
123655: ARRAY
123656: PPUSH
123657: CALL_OW 250
123661: PPUSH
123662: LD_VAR 0 14
123666: PUSH
123667: LD_INT 1
123669: ARRAY
123670: PPUSH
123671: CALL_OW 251
123675: PPUSH
123676: CALL_OW 546
123680: PUSH
123681: LD_INT 2
123683: ARRAY
123684: EQUAL
123685: IFFALSE 123713
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
123687: LD_VAR 0 4
123691: PUSH
123692: LD_VAR 0 7
123696: ARRAY
123697: PPUSH
123698: LD_VAR 0 14
123702: PUSH
123703: LD_INT 1
123705: ARRAY
123706: PPUSH
123707: CALL 97874 0 2
123711: GO 123737
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123713: LD_VAR 0 4
123717: PUSH
123718: LD_VAR 0 7
123722: ARRAY
123723: PPUSH
123724: LD_VAR 0 14
123728: PUSH
123729: LD_INT 1
123731: ARRAY
123732: PPUSH
123733: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
123737: LD_VAR 0 4
123741: PUSH
123742: LD_VAR 0 7
123746: ARRAY
123747: PPUSH
123748: CALL_OW 264
123752: PUSH
123753: LD_INT 29
123755: EQUAL
123756: IFFALSE 124122
// begin if WantsToAttack ( group [ i ] ) in bombed then
123758: LD_VAR 0 4
123762: PUSH
123763: LD_VAR 0 7
123767: ARRAY
123768: PPUSH
123769: CALL_OW 319
123773: PUSH
123774: LD_VAR 0 28
123778: IN
123779: IFFALSE 123783
// continue ;
123781: GO 120787
// k := 8 ;
123783: LD_ADDR_VAR 0 9
123787: PUSH
123788: LD_INT 8
123790: ST_TO_ADDR
// x := 0 ;
123791: LD_ADDR_VAR 0 10
123795: PUSH
123796: LD_INT 0
123798: ST_TO_ADDR
// if tmp < k then
123799: LD_VAR 0 14
123803: PUSH
123804: LD_VAR 0 9
123808: LESS
123809: IFFALSE 123821
// k := tmp ;
123811: LD_ADDR_VAR 0 9
123815: PUSH
123816: LD_VAR 0 14
123820: ST_TO_ADDR
// for j = 1 to k do
123821: LD_ADDR_VAR 0 8
123825: PUSH
123826: DOUBLE
123827: LD_INT 1
123829: DEC
123830: ST_TO_ADDR
123831: LD_VAR 0 9
123835: PUSH
123836: FOR_TO
123837: IFFALSE 123969
// begin if GetType ( tmp [ j ] ) = unit_building then
123839: LD_VAR 0 14
123843: PUSH
123844: LD_VAR 0 8
123848: ARRAY
123849: PPUSH
123850: CALL_OW 247
123854: PUSH
123855: LD_INT 3
123857: EQUAL
123858: IFFALSE 123967
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
123860: LD_VAR 0 14
123864: PUSH
123865: LD_VAR 0 8
123869: ARRAY
123870: PUSH
123871: LD_VAR 0 28
123875: IN
123876: NOT
123877: PUSH
123878: LD_VAR 0 14
123882: PUSH
123883: LD_VAR 0 8
123887: ARRAY
123888: PPUSH
123889: CALL_OW 313
123893: AND
123894: IFFALSE 123967
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123896: LD_VAR 0 4
123900: PUSH
123901: LD_VAR 0 7
123905: ARRAY
123906: PPUSH
123907: LD_VAR 0 14
123911: PUSH
123912: LD_VAR 0 8
123916: ARRAY
123917: PPUSH
123918: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
123922: LD_ADDR_VAR 0 28
123926: PUSH
123927: LD_VAR 0 28
123931: PPUSH
123932: LD_VAR 0 28
123936: PUSH
123937: LD_INT 1
123939: PLUS
123940: PPUSH
123941: LD_VAR 0 14
123945: PUSH
123946: LD_VAR 0 8
123950: ARRAY
123951: PPUSH
123952: CALL_OW 1
123956: ST_TO_ADDR
// attacking := true ;
123957: LD_ADDR_VAR 0 29
123961: PUSH
123962: LD_INT 1
123964: ST_TO_ADDR
// break ;
123965: GO 123969
// end ; end ;
123967: GO 123836
123969: POP
123970: POP
// if not attacking and f_attack_depot then
123971: LD_VAR 0 29
123975: NOT
123976: PUSH
123977: LD_VAR 0 25
123981: AND
123982: IFFALSE 124077
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123984: LD_ADDR_VAR 0 13
123988: PUSH
123989: LD_VAR 0 14
123993: PPUSH
123994: LD_INT 2
123996: PUSH
123997: LD_INT 30
123999: PUSH
124000: LD_INT 0
124002: PUSH
124003: EMPTY
124004: LIST
124005: LIST
124006: PUSH
124007: LD_INT 30
124009: PUSH
124010: LD_INT 1
124012: PUSH
124013: EMPTY
124014: LIST
124015: LIST
124016: PUSH
124017: EMPTY
124018: LIST
124019: LIST
124020: LIST
124021: PPUSH
124022: CALL_OW 72
124026: ST_TO_ADDR
// if z then
124027: LD_VAR 0 13
124031: IFFALSE 124077
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
124033: LD_VAR 0 4
124037: PUSH
124038: LD_VAR 0 7
124042: ARRAY
124043: PPUSH
124044: LD_VAR 0 13
124048: PPUSH
124049: LD_VAR 0 4
124053: PUSH
124054: LD_VAR 0 7
124058: ARRAY
124059: PPUSH
124060: CALL_OW 74
124064: PPUSH
124065: CALL_OW 115
// attacking := true ;
124069: LD_ADDR_VAR 0 29
124073: PUSH
124074: LD_INT 1
124076: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
124077: LD_VAR 0 4
124081: PUSH
124082: LD_VAR 0 7
124086: ARRAY
124087: PPUSH
124088: CALL_OW 256
124092: PUSH
124093: LD_INT 500
124095: LESS
124096: IFFALSE 124122
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124098: LD_VAR 0 4
124102: PUSH
124103: LD_VAR 0 7
124107: ARRAY
124108: PPUSH
124109: LD_VAR 0 14
124113: PUSH
124114: LD_INT 1
124116: ARRAY
124117: PPUSH
124118: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
124122: LD_VAR 0 4
124126: PUSH
124127: LD_VAR 0 7
124131: ARRAY
124132: PPUSH
124133: CALL_OW 264
124137: PUSH
124138: LD_INT 49
124140: EQUAL
124141: IFFALSE 124262
// begin if not HasTask ( group [ i ] ) then
124143: LD_VAR 0 4
124147: PUSH
124148: LD_VAR 0 7
124152: ARRAY
124153: PPUSH
124154: CALL_OW 314
124158: NOT
124159: IFFALSE 124262
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
124161: LD_ADDR_VAR 0 9
124165: PUSH
124166: LD_INT 81
124168: PUSH
124169: LD_VAR 0 4
124173: PUSH
124174: LD_VAR 0 7
124178: ARRAY
124179: PPUSH
124180: CALL_OW 255
124184: PUSH
124185: EMPTY
124186: LIST
124187: LIST
124188: PPUSH
124189: CALL_OW 69
124193: PPUSH
124194: LD_VAR 0 4
124198: PUSH
124199: LD_VAR 0 7
124203: ARRAY
124204: PPUSH
124205: CALL_OW 74
124209: ST_TO_ADDR
// if k then
124210: LD_VAR 0 9
124214: IFFALSE 124262
// if GetDistUnits ( group [ i ] , k ) > 10 then
124216: LD_VAR 0 4
124220: PUSH
124221: LD_VAR 0 7
124225: ARRAY
124226: PPUSH
124227: LD_VAR 0 9
124231: PPUSH
124232: CALL_OW 296
124236: PUSH
124237: LD_INT 10
124239: GREATER
124240: IFFALSE 124262
// ComMoveUnit ( group [ i ] , k ) ;
124242: LD_VAR 0 4
124246: PUSH
124247: LD_VAR 0 7
124251: ARRAY
124252: PPUSH
124253: LD_VAR 0 9
124257: PPUSH
124258: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
124262: LD_VAR 0 4
124266: PUSH
124267: LD_VAR 0 7
124271: ARRAY
124272: PPUSH
124273: CALL_OW 256
124277: PUSH
124278: LD_INT 250
124280: LESS
124281: PUSH
124282: LD_VAR 0 4
124286: PUSH
124287: LD_VAR 0 7
124291: ARRAY
124292: PUSH
124293: LD_INT 21
124295: PUSH
124296: LD_INT 2
124298: PUSH
124299: EMPTY
124300: LIST
124301: LIST
124302: PUSH
124303: LD_INT 23
124305: PUSH
124306: LD_INT 2
124308: PUSH
124309: EMPTY
124310: LIST
124311: LIST
124312: PUSH
124313: EMPTY
124314: LIST
124315: LIST
124316: PPUSH
124317: CALL_OW 69
124321: IN
124322: AND
124323: IFFALSE 124448
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
124325: LD_ADDR_VAR 0 9
124329: PUSH
124330: LD_OWVAR 3
124334: PUSH
124335: LD_VAR 0 4
124339: PUSH
124340: LD_VAR 0 7
124344: ARRAY
124345: DIFF
124346: PPUSH
124347: LD_VAR 0 4
124351: PUSH
124352: LD_VAR 0 7
124356: ARRAY
124357: PPUSH
124358: CALL_OW 74
124362: ST_TO_ADDR
// if not k then
124363: LD_VAR 0 9
124367: NOT
124368: IFFALSE 124372
// continue ;
124370: GO 120787
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
124372: LD_VAR 0 9
124376: PUSH
124377: LD_INT 81
124379: PUSH
124380: LD_VAR 0 4
124384: PUSH
124385: LD_VAR 0 7
124389: ARRAY
124390: PPUSH
124391: CALL_OW 255
124395: PUSH
124396: EMPTY
124397: LIST
124398: LIST
124399: PPUSH
124400: CALL_OW 69
124404: IN
124405: PUSH
124406: LD_VAR 0 9
124410: PPUSH
124411: LD_VAR 0 4
124415: PUSH
124416: LD_VAR 0 7
124420: ARRAY
124421: PPUSH
124422: CALL_OW 296
124426: PUSH
124427: LD_INT 5
124429: LESS
124430: AND
124431: IFFALSE 124448
// ComAutodestruct ( group [ i ] ) ;
124433: LD_VAR 0 4
124437: PUSH
124438: LD_VAR 0 7
124442: ARRAY
124443: PPUSH
124444: CALL 97772 0 1
// end ; if f_attack_depot then
124448: LD_VAR 0 25
124452: IFFALSE 124564
// begin k := 6 ;
124454: LD_ADDR_VAR 0 9
124458: PUSH
124459: LD_INT 6
124461: ST_TO_ADDR
// if tmp < k then
124462: LD_VAR 0 14
124466: PUSH
124467: LD_VAR 0 9
124471: LESS
124472: IFFALSE 124484
// k := tmp ;
124474: LD_ADDR_VAR 0 9
124478: PUSH
124479: LD_VAR 0 14
124483: ST_TO_ADDR
// for j = 1 to k do
124484: LD_ADDR_VAR 0 8
124488: PUSH
124489: DOUBLE
124490: LD_INT 1
124492: DEC
124493: ST_TO_ADDR
124494: LD_VAR 0 9
124498: PUSH
124499: FOR_TO
124500: IFFALSE 124562
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
124502: LD_VAR 0 8
124506: PPUSH
124507: CALL_OW 266
124511: PUSH
124512: LD_INT 0
124514: PUSH
124515: LD_INT 1
124517: PUSH
124518: EMPTY
124519: LIST
124520: LIST
124521: IN
124522: IFFALSE 124560
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124524: LD_VAR 0 4
124528: PUSH
124529: LD_VAR 0 7
124533: ARRAY
124534: PPUSH
124535: LD_VAR 0 14
124539: PUSH
124540: LD_VAR 0 8
124544: ARRAY
124545: PPUSH
124546: CALL_OW 115
// attacking := true ;
124550: LD_ADDR_VAR 0 29
124554: PUSH
124555: LD_INT 1
124557: ST_TO_ADDR
// break ;
124558: GO 124562
// end ;
124560: GO 124499
124562: POP
124563: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
124564: LD_VAR 0 4
124568: PUSH
124569: LD_VAR 0 7
124573: ARRAY
124574: PPUSH
124575: CALL_OW 302
124579: PUSH
124580: LD_VAR 0 29
124584: NOT
124585: AND
124586: IFFALSE 124908
// begin if GetTag ( group [ i ] ) = 71 then
124588: LD_VAR 0 4
124592: PUSH
124593: LD_VAR 0 7
124597: ARRAY
124598: PPUSH
124599: CALL_OW 110
124603: PUSH
124604: LD_INT 71
124606: EQUAL
124607: IFFALSE 124648
// begin if HasTask ( group [ i ] ) then
124609: LD_VAR 0 4
124613: PUSH
124614: LD_VAR 0 7
124618: ARRAY
124619: PPUSH
124620: CALL_OW 314
124624: IFFALSE 124630
// continue else
124626: GO 120787
124628: GO 124648
// SetTag ( group [ i ] , 0 ) ;
124630: LD_VAR 0 4
124634: PUSH
124635: LD_VAR 0 7
124639: ARRAY
124640: PPUSH
124641: LD_INT 0
124643: PPUSH
124644: CALL_OW 109
// end ; k := 8 ;
124648: LD_ADDR_VAR 0 9
124652: PUSH
124653: LD_INT 8
124655: ST_TO_ADDR
// x := 0 ;
124656: LD_ADDR_VAR 0 10
124660: PUSH
124661: LD_INT 0
124663: ST_TO_ADDR
// if tmp < k then
124664: LD_VAR 0 14
124668: PUSH
124669: LD_VAR 0 9
124673: LESS
124674: IFFALSE 124686
// k := tmp ;
124676: LD_ADDR_VAR 0 9
124680: PUSH
124681: LD_VAR 0 14
124685: ST_TO_ADDR
// for j = 1 to k do
124686: LD_ADDR_VAR 0 8
124690: PUSH
124691: DOUBLE
124692: LD_INT 1
124694: DEC
124695: ST_TO_ADDR
124696: LD_VAR 0 9
124700: PUSH
124701: FOR_TO
124702: IFFALSE 124800
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
124704: LD_VAR 0 14
124708: PUSH
124709: LD_VAR 0 8
124713: ARRAY
124714: PPUSH
124715: CALL_OW 247
124719: PUSH
124720: LD_INT 1
124722: EQUAL
124723: PUSH
124724: LD_VAR 0 14
124728: PUSH
124729: LD_VAR 0 8
124733: ARRAY
124734: PPUSH
124735: CALL_OW 256
124739: PUSH
124740: LD_INT 250
124742: LESS
124743: PUSH
124744: LD_VAR 0 20
124748: AND
124749: PUSH
124750: LD_VAR 0 20
124754: NOT
124755: PUSH
124756: LD_VAR 0 14
124760: PUSH
124761: LD_VAR 0 8
124765: ARRAY
124766: PPUSH
124767: CALL_OW 256
124771: PUSH
124772: LD_INT 250
124774: GREATEREQUAL
124775: AND
124776: OR
124777: AND
124778: IFFALSE 124798
// begin x := tmp [ j ] ;
124780: LD_ADDR_VAR 0 10
124784: PUSH
124785: LD_VAR 0 14
124789: PUSH
124790: LD_VAR 0 8
124794: ARRAY
124795: ST_TO_ADDR
// break ;
124796: GO 124800
// end ;
124798: GO 124701
124800: POP
124801: POP
// if x then
124802: LD_VAR 0 10
124806: IFFALSE 124830
// ComAttackUnit ( group [ i ] , x ) else
124808: LD_VAR 0 4
124812: PUSH
124813: LD_VAR 0 7
124817: ARRAY
124818: PPUSH
124819: LD_VAR 0 10
124823: PPUSH
124824: CALL_OW 115
124828: GO 124854
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124830: LD_VAR 0 4
124834: PUSH
124835: LD_VAR 0 7
124839: ARRAY
124840: PPUSH
124841: LD_VAR 0 14
124845: PUSH
124846: LD_INT 1
124848: ARRAY
124849: PPUSH
124850: CALL_OW 115
// if not HasTask ( group [ i ] ) then
124854: LD_VAR 0 4
124858: PUSH
124859: LD_VAR 0 7
124863: ARRAY
124864: PPUSH
124865: CALL_OW 314
124869: NOT
124870: IFFALSE 124908
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
124872: LD_VAR 0 4
124876: PUSH
124877: LD_VAR 0 7
124881: ARRAY
124882: PPUSH
124883: LD_VAR 0 14
124887: PPUSH
124888: LD_VAR 0 4
124892: PUSH
124893: LD_VAR 0 7
124897: ARRAY
124898: PPUSH
124899: CALL_OW 74
124903: PPUSH
124904: CALL_OW 115
// end ; end ; end ;
124908: GO 120787
124910: POP
124911: POP
// wait ( 0 0$2 ) ;
124912: LD_INT 70
124914: PPUSH
124915: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
124919: LD_VAR 0 4
124923: NOT
124924: PUSH
124925: LD_VAR 0 4
124929: PUSH
124930: EMPTY
124931: EQUAL
124932: OR
124933: PUSH
124934: LD_INT 81
124936: PUSH
124937: LD_VAR 0 35
124941: PUSH
124942: EMPTY
124943: LIST
124944: LIST
124945: PPUSH
124946: CALL_OW 69
124950: NOT
124951: OR
124952: IFFALSE 120772
// end ;
124954: LD_VAR 0 2
124958: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
124959: LD_INT 0
124961: PPUSH
124962: PPUSH
124963: PPUSH
124964: PPUSH
124965: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
124966: LD_VAR 0 1
124970: NOT
124971: PUSH
124972: LD_EXP 115
124976: PUSH
124977: LD_VAR 0 1
124981: ARRAY
124982: NOT
124983: OR
124984: PUSH
124985: LD_VAR 0 2
124989: NOT
124990: OR
124991: PUSH
124992: LD_VAR 0 3
124996: NOT
124997: OR
124998: IFFALSE 125002
// exit ;
125000: GO 125515
// side := mc_sides [ base ] ;
125002: LD_ADDR_VAR 0 6
125006: PUSH
125007: LD_EXP 141
125011: PUSH
125012: LD_VAR 0 1
125016: ARRAY
125017: ST_TO_ADDR
// if not side then
125018: LD_VAR 0 6
125022: NOT
125023: IFFALSE 125027
// exit ;
125025: GO 125515
// for i in solds do
125027: LD_ADDR_VAR 0 7
125031: PUSH
125032: LD_VAR 0 2
125036: PUSH
125037: FOR_IN
125038: IFFALSE 125099
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
125040: LD_VAR 0 7
125044: PPUSH
125045: CALL_OW 310
125049: PPUSH
125050: CALL_OW 266
125054: PUSH
125055: LD_INT 32
125057: PUSH
125058: LD_INT 31
125060: PUSH
125061: EMPTY
125062: LIST
125063: LIST
125064: IN
125065: IFFALSE 125085
// solds := solds diff i else
125067: LD_ADDR_VAR 0 2
125071: PUSH
125072: LD_VAR 0 2
125076: PUSH
125077: LD_VAR 0 7
125081: DIFF
125082: ST_TO_ADDR
125083: GO 125097
// SetTag ( i , 18 ) ;
125085: LD_VAR 0 7
125089: PPUSH
125090: LD_INT 18
125092: PPUSH
125093: CALL_OW 109
125097: GO 125037
125099: POP
125100: POP
// if not solds then
125101: LD_VAR 0 2
125105: NOT
125106: IFFALSE 125110
// exit ;
125108: GO 125515
// repeat wait ( 0 0$2 ) ;
125110: LD_INT 70
125112: PPUSH
125113: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
125117: LD_ADDR_VAR 0 5
125121: PUSH
125122: LD_VAR 0 6
125126: PPUSH
125127: LD_VAR 0 3
125131: PPUSH
125132: CALL 67154 0 2
125136: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125137: LD_EXP 115
125141: PUSH
125142: LD_VAR 0 1
125146: ARRAY
125147: NOT
125148: PUSH
125149: LD_EXP 115
125153: PUSH
125154: LD_VAR 0 1
125158: ARRAY
125159: PUSH
125160: EMPTY
125161: EQUAL
125162: OR
125163: IFFALSE 125200
// begin for i in solds do
125165: LD_ADDR_VAR 0 7
125169: PUSH
125170: LD_VAR 0 2
125174: PUSH
125175: FOR_IN
125176: IFFALSE 125189
// ComStop ( i ) ;
125178: LD_VAR 0 7
125182: PPUSH
125183: CALL_OW 141
125187: GO 125175
125189: POP
125190: POP
// solds := [ ] ;
125191: LD_ADDR_VAR 0 2
125195: PUSH
125196: EMPTY
125197: ST_TO_ADDR
// exit ;
125198: GO 125515
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
125200: LD_VAR 0 5
125204: NOT
125205: PUSH
125206: LD_VAR 0 5
125210: PUSH
125211: LD_INT 3
125213: GREATER
125214: OR
125215: PUSH
125216: LD_EXP 137
125220: PUSH
125221: LD_VAR 0 1
125225: ARRAY
125226: OR
125227: IFFALSE 125268
// begin for i in solds do
125229: LD_ADDR_VAR 0 7
125233: PUSH
125234: LD_VAR 0 2
125238: PUSH
125239: FOR_IN
125240: IFFALSE 125264
// if HasTask ( i ) then
125242: LD_VAR 0 7
125246: PPUSH
125247: CALL_OW 314
125251: IFFALSE 125262
// ComStop ( i ) ;
125253: LD_VAR 0 7
125257: PPUSH
125258: CALL_OW 141
125262: GO 125239
125264: POP
125265: POP
// break ;
125266: GO 125503
// end ; for i in solds do
125268: LD_ADDR_VAR 0 7
125272: PUSH
125273: LD_VAR 0 2
125277: PUSH
125278: FOR_IN
125279: IFFALSE 125495
// begin if IsInUnit ( i ) then
125281: LD_VAR 0 7
125285: PPUSH
125286: CALL_OW 310
125290: IFFALSE 125301
// ComExitBuilding ( i ) ;
125292: LD_VAR 0 7
125296: PPUSH
125297: CALL_OW 122
// if GetLives ( i ) > 333 then
125301: LD_VAR 0 7
125305: PPUSH
125306: CALL_OW 256
125310: PUSH
125311: LD_INT 333
125313: GREATER
125314: IFFALSE 125342
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
125316: LD_VAR 0 7
125320: PPUSH
125321: LD_VAR 0 5
125325: PPUSH
125326: LD_VAR 0 7
125330: PPUSH
125331: CALL_OW 74
125335: PPUSH
125336: CALL_OW 115
125340: GO 125493
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
125342: LD_ADDR_VAR 0 8
125346: PUSH
125347: LD_EXP 115
125351: PUSH
125352: LD_VAR 0 1
125356: ARRAY
125357: PPUSH
125358: LD_INT 2
125360: PUSH
125361: LD_INT 30
125363: PUSH
125364: LD_INT 0
125366: PUSH
125367: EMPTY
125368: LIST
125369: LIST
125370: PUSH
125371: LD_INT 30
125373: PUSH
125374: LD_INT 1
125376: PUSH
125377: EMPTY
125378: LIST
125379: LIST
125380: PUSH
125381: LD_INT 30
125383: PUSH
125384: LD_INT 6
125386: PUSH
125387: EMPTY
125388: LIST
125389: LIST
125390: PUSH
125391: EMPTY
125392: LIST
125393: LIST
125394: LIST
125395: LIST
125396: PPUSH
125397: CALL_OW 72
125401: PPUSH
125402: LD_VAR 0 7
125406: PPUSH
125407: CALL_OW 74
125411: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
125412: LD_VAR 0 7
125416: PPUSH
125417: LD_VAR 0 8
125421: PPUSH
125422: CALL_OW 250
125426: PPUSH
125427: LD_INT 3
125429: PPUSH
125430: LD_INT 5
125432: PPUSH
125433: CALL_OW 272
125437: PPUSH
125438: LD_VAR 0 8
125442: PPUSH
125443: CALL_OW 251
125447: PPUSH
125448: LD_INT 3
125450: PPUSH
125451: LD_INT 5
125453: PPUSH
125454: CALL_OW 273
125458: PPUSH
125459: CALL_OW 111
// SetTag ( i , 0 ) ;
125463: LD_VAR 0 7
125467: PPUSH
125468: LD_INT 0
125470: PPUSH
125471: CALL_OW 109
// solds := solds diff i ;
125475: LD_ADDR_VAR 0 2
125479: PUSH
125480: LD_VAR 0 2
125484: PUSH
125485: LD_VAR 0 7
125489: DIFF
125490: ST_TO_ADDR
// continue ;
125491: GO 125278
// end ; end ;
125493: GO 125278
125495: POP
125496: POP
// until solds ;
125497: LD_VAR 0 2
125501: IFFALSE 125110
// MC_Reset ( base , 18 ) ;
125503: LD_VAR 0 1
125507: PPUSH
125508: LD_INT 18
125510: PPUSH
125511: CALL 39279 0 2
// end ;
125515: LD_VAR 0 4
125519: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
125520: LD_INT 0
125522: PPUSH
125523: PPUSH
125524: PPUSH
125525: PPUSH
125526: PPUSH
125527: PPUSH
125528: PPUSH
125529: PPUSH
125530: PPUSH
125531: PPUSH
125532: PPUSH
125533: PPUSH
125534: PPUSH
125535: PPUSH
125536: PPUSH
125537: PPUSH
125538: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
125539: LD_ADDR_VAR 0 13
125543: PUSH
125544: LD_EXP 115
125548: PUSH
125549: LD_VAR 0 1
125553: ARRAY
125554: PPUSH
125555: LD_INT 25
125557: PUSH
125558: LD_INT 3
125560: PUSH
125561: EMPTY
125562: LIST
125563: LIST
125564: PPUSH
125565: CALL_OW 72
125569: ST_TO_ADDR
// if mc_remote_driver [ base ] then
125570: LD_EXP 155
125574: PUSH
125575: LD_VAR 0 1
125579: ARRAY
125580: IFFALSE 125604
// mechs := mechs diff mc_remote_driver [ base ] ;
125582: LD_ADDR_VAR 0 13
125586: PUSH
125587: LD_VAR 0 13
125591: PUSH
125592: LD_EXP 155
125596: PUSH
125597: LD_VAR 0 1
125601: ARRAY
125602: DIFF
125603: ST_TO_ADDR
// for i in mechs do
125604: LD_ADDR_VAR 0 5
125608: PUSH
125609: LD_VAR 0 13
125613: PUSH
125614: FOR_IN
125615: IFFALSE 125650
// if GetTag ( i ) > 0 then
125617: LD_VAR 0 5
125621: PPUSH
125622: CALL_OW 110
125626: PUSH
125627: LD_INT 0
125629: GREATER
125630: IFFALSE 125648
// mechs := mechs diff i ;
125632: LD_ADDR_VAR 0 13
125636: PUSH
125637: LD_VAR 0 13
125641: PUSH
125642: LD_VAR 0 5
125646: DIFF
125647: ST_TO_ADDR
125648: GO 125614
125650: POP
125651: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
125652: LD_ADDR_VAR 0 9
125656: PUSH
125657: LD_EXP 115
125661: PUSH
125662: LD_VAR 0 1
125666: ARRAY
125667: PPUSH
125668: LD_INT 2
125670: PUSH
125671: LD_INT 25
125673: PUSH
125674: LD_INT 1
125676: PUSH
125677: EMPTY
125678: LIST
125679: LIST
125680: PUSH
125681: LD_INT 25
125683: PUSH
125684: LD_INT 5
125686: PUSH
125687: EMPTY
125688: LIST
125689: LIST
125690: PUSH
125691: LD_INT 25
125693: PUSH
125694: LD_INT 8
125696: PUSH
125697: EMPTY
125698: LIST
125699: LIST
125700: PUSH
125701: LD_INT 25
125703: PUSH
125704: LD_INT 9
125706: PUSH
125707: EMPTY
125708: LIST
125709: LIST
125710: PUSH
125711: EMPTY
125712: LIST
125713: LIST
125714: LIST
125715: LIST
125716: LIST
125717: PPUSH
125718: CALL_OW 72
125722: ST_TO_ADDR
// if not defenders and not solds then
125723: LD_VAR 0 2
125727: NOT
125728: PUSH
125729: LD_VAR 0 9
125733: NOT
125734: AND
125735: IFFALSE 125739
// exit ;
125737: GO 127429
// depot_under_attack := false ;
125739: LD_ADDR_VAR 0 17
125743: PUSH
125744: LD_INT 0
125746: ST_TO_ADDR
// sold_defenders := [ ] ;
125747: LD_ADDR_VAR 0 18
125751: PUSH
125752: EMPTY
125753: ST_TO_ADDR
// if mechs then
125754: LD_VAR 0 13
125758: IFFALSE 125911
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
125760: LD_ADDR_VAR 0 5
125764: PUSH
125765: LD_VAR 0 2
125769: PPUSH
125770: LD_INT 21
125772: PUSH
125773: LD_INT 2
125775: PUSH
125776: EMPTY
125777: LIST
125778: LIST
125779: PPUSH
125780: CALL_OW 72
125784: PUSH
125785: FOR_IN
125786: IFFALSE 125909
// begin if GetTag ( i ) <> 20 then
125788: LD_VAR 0 5
125792: PPUSH
125793: CALL_OW 110
125797: PUSH
125798: LD_INT 20
125800: NONEQUAL
125801: IFFALSE 125815
// SetTag ( i , 20 ) ;
125803: LD_VAR 0 5
125807: PPUSH
125808: LD_INT 20
125810: PPUSH
125811: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
125815: LD_VAR 0 5
125819: PPUSH
125820: CALL_OW 263
125824: PUSH
125825: LD_INT 1
125827: EQUAL
125828: PUSH
125829: LD_VAR 0 5
125833: PPUSH
125834: CALL_OW 311
125838: NOT
125839: AND
125840: IFFALSE 125907
// begin un := mechs [ 1 ] ;
125842: LD_ADDR_VAR 0 11
125846: PUSH
125847: LD_VAR 0 13
125851: PUSH
125852: LD_INT 1
125854: ARRAY
125855: ST_TO_ADDR
// ComExit ( un ) ;
125856: LD_VAR 0 11
125860: PPUSH
125861: CALL 102117 0 1
// AddComEnterUnit ( un , i ) ;
125865: LD_VAR 0 11
125869: PPUSH
125870: LD_VAR 0 5
125874: PPUSH
125875: CALL_OW 180
// SetTag ( un , 19 ) ;
125879: LD_VAR 0 11
125883: PPUSH
125884: LD_INT 19
125886: PPUSH
125887: CALL_OW 109
// mechs := mechs diff un ;
125891: LD_ADDR_VAR 0 13
125895: PUSH
125896: LD_VAR 0 13
125900: PUSH
125901: LD_VAR 0 11
125905: DIFF
125906: ST_TO_ADDR
// end ; end ;
125907: GO 125785
125909: POP
125910: POP
// if solds then
125911: LD_VAR 0 9
125915: IFFALSE 125974
// for i in solds do
125917: LD_ADDR_VAR 0 5
125921: PUSH
125922: LD_VAR 0 9
125926: PUSH
125927: FOR_IN
125928: IFFALSE 125972
// if not GetTag ( i ) then
125930: LD_VAR 0 5
125934: PPUSH
125935: CALL_OW 110
125939: NOT
125940: IFFALSE 125970
// begin defenders := defenders union i ;
125942: LD_ADDR_VAR 0 2
125946: PUSH
125947: LD_VAR 0 2
125951: PUSH
125952: LD_VAR 0 5
125956: UNION
125957: ST_TO_ADDR
// SetTag ( i , 18 ) ;
125958: LD_VAR 0 5
125962: PPUSH
125963: LD_INT 18
125965: PPUSH
125966: CALL_OW 109
// end ;
125970: GO 125927
125972: POP
125973: POP
// repeat wait ( 0 0$2 ) ;
125974: LD_INT 70
125976: PPUSH
125977: CALL_OW 67
// enemy := mc_scan [ base ] ;
125981: LD_ADDR_VAR 0 3
125985: PUSH
125986: LD_EXP 138
125990: PUSH
125991: LD_VAR 0 1
125995: ARRAY
125996: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125997: LD_EXP 115
126001: PUSH
126002: LD_VAR 0 1
126006: ARRAY
126007: NOT
126008: PUSH
126009: LD_EXP 115
126013: PUSH
126014: LD_VAR 0 1
126018: ARRAY
126019: PUSH
126020: EMPTY
126021: EQUAL
126022: OR
126023: IFFALSE 126060
// begin for i in defenders do
126025: LD_ADDR_VAR 0 5
126029: PUSH
126030: LD_VAR 0 2
126034: PUSH
126035: FOR_IN
126036: IFFALSE 126049
// ComStop ( i ) ;
126038: LD_VAR 0 5
126042: PPUSH
126043: CALL_OW 141
126047: GO 126035
126049: POP
126050: POP
// defenders := [ ] ;
126051: LD_ADDR_VAR 0 2
126055: PUSH
126056: EMPTY
126057: ST_TO_ADDR
// exit ;
126058: GO 127429
// end ; for i in defenders do
126060: LD_ADDR_VAR 0 5
126064: PUSH
126065: LD_VAR 0 2
126069: PUSH
126070: FOR_IN
126071: IFFALSE 126889
// begin e := NearestUnitToUnit ( enemy , i ) ;
126073: LD_ADDR_VAR 0 14
126077: PUSH
126078: LD_VAR 0 3
126082: PPUSH
126083: LD_VAR 0 5
126087: PPUSH
126088: CALL_OW 74
126092: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126093: LD_ADDR_VAR 0 8
126097: PUSH
126098: LD_EXP 115
126102: PUSH
126103: LD_VAR 0 1
126107: ARRAY
126108: PPUSH
126109: LD_INT 2
126111: PUSH
126112: LD_INT 30
126114: PUSH
126115: LD_INT 0
126117: PUSH
126118: EMPTY
126119: LIST
126120: LIST
126121: PUSH
126122: LD_INT 30
126124: PUSH
126125: LD_INT 1
126127: PUSH
126128: EMPTY
126129: LIST
126130: LIST
126131: PUSH
126132: EMPTY
126133: LIST
126134: LIST
126135: LIST
126136: PPUSH
126137: CALL_OW 72
126141: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
126142: LD_ADDR_VAR 0 17
126146: PUSH
126147: LD_VAR 0 8
126151: NOT
126152: PUSH
126153: LD_VAR 0 8
126157: PPUSH
126158: LD_INT 3
126160: PUSH
126161: LD_INT 24
126163: PUSH
126164: LD_INT 600
126166: PUSH
126167: EMPTY
126168: LIST
126169: LIST
126170: PUSH
126171: EMPTY
126172: LIST
126173: LIST
126174: PPUSH
126175: CALL_OW 72
126179: OR
126180: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
126181: LD_VAR 0 5
126185: PPUSH
126186: CALL_OW 247
126190: PUSH
126191: LD_INT 2
126193: DOUBLE
126194: EQUAL
126195: IFTRUE 126199
126197: GO 126595
126199: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
126200: LD_VAR 0 5
126204: PPUSH
126205: CALL_OW 256
126209: PUSH
126210: LD_INT 1000
126212: EQUAL
126213: PUSH
126214: LD_VAR 0 5
126218: PPUSH
126219: LD_VAR 0 14
126223: PPUSH
126224: CALL_OW 296
126228: PUSH
126229: LD_INT 40
126231: LESS
126232: PUSH
126233: LD_VAR 0 14
126237: PPUSH
126238: LD_EXP 140
126242: PUSH
126243: LD_VAR 0 1
126247: ARRAY
126248: PPUSH
126249: CALL_OW 308
126253: OR
126254: AND
126255: IFFALSE 126377
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
126257: LD_VAR 0 5
126261: PPUSH
126262: CALL_OW 262
126266: PUSH
126267: LD_INT 1
126269: EQUAL
126270: PUSH
126271: LD_VAR 0 5
126275: PPUSH
126276: CALL_OW 261
126280: PUSH
126281: LD_INT 30
126283: LESS
126284: AND
126285: PUSH
126286: LD_VAR 0 8
126290: AND
126291: IFFALSE 126361
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
126293: LD_VAR 0 5
126297: PPUSH
126298: LD_VAR 0 8
126302: PPUSH
126303: LD_VAR 0 5
126307: PPUSH
126308: CALL_OW 74
126312: PPUSH
126313: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
126317: LD_VAR 0 5
126321: PPUSH
126322: LD_VAR 0 8
126326: PPUSH
126327: LD_VAR 0 5
126331: PPUSH
126332: CALL_OW 74
126336: PPUSH
126337: CALL_OW 296
126341: PUSH
126342: LD_INT 6
126344: LESS
126345: IFFALSE 126359
// SetFuel ( i , 100 ) ;
126347: LD_VAR 0 5
126351: PPUSH
126352: LD_INT 100
126354: PPUSH
126355: CALL_OW 240
// end else
126359: GO 126375
// ComAttackUnit ( i , e ) ;
126361: LD_VAR 0 5
126365: PPUSH
126366: LD_VAR 0 14
126370: PPUSH
126371: CALL_OW 115
// end else
126375: GO 126478
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
126377: LD_VAR 0 14
126381: PPUSH
126382: LD_EXP 140
126386: PUSH
126387: LD_VAR 0 1
126391: ARRAY
126392: PPUSH
126393: CALL_OW 308
126397: NOT
126398: PUSH
126399: LD_VAR 0 5
126403: PPUSH
126404: LD_VAR 0 14
126408: PPUSH
126409: CALL_OW 296
126413: PUSH
126414: LD_INT 40
126416: GREATEREQUAL
126417: AND
126418: PUSH
126419: LD_VAR 0 5
126423: PPUSH
126424: CALL_OW 256
126428: PUSH
126429: LD_INT 650
126431: LESSEQUAL
126432: OR
126433: PUSH
126434: LD_VAR 0 5
126438: PPUSH
126439: LD_EXP 139
126443: PUSH
126444: LD_VAR 0 1
126448: ARRAY
126449: PPUSH
126450: CALL_OW 308
126454: NOT
126455: AND
126456: IFFALSE 126478
// ComMoveToArea ( i , mc_parking [ base ] ) ;
126458: LD_VAR 0 5
126462: PPUSH
126463: LD_EXP 139
126467: PUSH
126468: LD_VAR 0 1
126472: ARRAY
126473: PPUSH
126474: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
126478: LD_VAR 0 5
126482: PPUSH
126483: CALL_OW 256
126487: PUSH
126488: LD_INT 1000
126490: LESS
126491: PUSH
126492: LD_VAR 0 5
126496: PPUSH
126497: CALL_OW 263
126501: PUSH
126502: LD_INT 1
126504: EQUAL
126505: AND
126506: PUSH
126507: LD_VAR 0 5
126511: PPUSH
126512: CALL_OW 311
126516: AND
126517: PUSH
126518: LD_VAR 0 5
126522: PPUSH
126523: LD_EXP 139
126527: PUSH
126528: LD_VAR 0 1
126532: ARRAY
126533: PPUSH
126534: CALL_OW 308
126538: AND
126539: IFFALSE 126593
// begin mech := IsDrivenBy ( i ) ;
126541: LD_ADDR_VAR 0 10
126545: PUSH
126546: LD_VAR 0 5
126550: PPUSH
126551: CALL_OW 311
126555: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
126556: LD_VAR 0 10
126560: PPUSH
126561: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
126565: LD_VAR 0 10
126569: PPUSH
126570: LD_VAR 0 5
126574: PPUSH
126575: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
126579: LD_VAR 0 10
126583: PPUSH
126584: LD_VAR 0 5
126588: PPUSH
126589: CALL_OW 180
// end ; end ; unit_human :
126593: GO 126860
126595: LD_INT 1
126597: DOUBLE
126598: EQUAL
126599: IFTRUE 126603
126601: GO 126859
126603: POP
// begin b := IsInUnit ( i ) ;
126604: LD_ADDR_VAR 0 19
126608: PUSH
126609: LD_VAR 0 5
126613: PPUSH
126614: CALL_OW 310
126618: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
126619: LD_ADDR_VAR 0 20
126623: PUSH
126624: LD_VAR 0 19
126628: NOT
126629: PUSH
126630: LD_VAR 0 19
126634: PPUSH
126635: CALL_OW 266
126639: PUSH
126640: LD_INT 32
126642: PUSH
126643: LD_INT 31
126645: PUSH
126646: EMPTY
126647: LIST
126648: LIST
126649: IN
126650: OR
126651: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
126652: LD_VAR 0 17
126656: PUSH
126657: LD_VAR 0 2
126661: PPUSH
126662: LD_INT 21
126664: PUSH
126665: LD_INT 2
126667: PUSH
126668: EMPTY
126669: LIST
126670: LIST
126671: PPUSH
126672: CALL_OW 72
126676: PUSH
126677: LD_INT 1
126679: LESSEQUAL
126680: OR
126681: PUSH
126682: LD_VAR 0 20
126686: AND
126687: PUSH
126688: LD_VAR 0 5
126692: PUSH
126693: LD_VAR 0 18
126697: IN
126698: NOT
126699: AND
126700: IFFALSE 126793
// begin if b then
126702: LD_VAR 0 19
126706: IFFALSE 126755
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
126708: LD_VAR 0 19
126712: PPUSH
126713: LD_VAR 0 3
126717: PPUSH
126718: LD_VAR 0 19
126722: PPUSH
126723: CALL_OW 74
126727: PPUSH
126728: CALL_OW 296
126732: PUSH
126733: LD_INT 10
126735: LESS
126736: PUSH
126737: LD_VAR 0 19
126741: PPUSH
126742: CALL_OW 461
126746: PUSH
126747: LD_INT 7
126749: NONEQUAL
126750: AND
126751: IFFALSE 126755
// continue ;
126753: GO 126070
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
126755: LD_ADDR_VAR 0 18
126759: PUSH
126760: LD_VAR 0 18
126764: PPUSH
126765: LD_VAR 0 18
126769: PUSH
126770: LD_INT 1
126772: PLUS
126773: PPUSH
126774: LD_VAR 0 5
126778: PPUSH
126779: CALL_OW 1
126783: ST_TO_ADDR
// ComExitBuilding ( i ) ;
126784: LD_VAR 0 5
126788: PPUSH
126789: CALL_OW 122
// end ; if sold_defenders then
126793: LD_VAR 0 18
126797: IFFALSE 126857
// if i in sold_defenders then
126799: LD_VAR 0 5
126803: PUSH
126804: LD_VAR 0 18
126808: IN
126809: IFFALSE 126857
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
126811: LD_VAR 0 5
126815: PPUSH
126816: CALL_OW 314
126820: NOT
126821: PUSH
126822: LD_VAR 0 5
126826: PPUSH
126827: LD_VAR 0 14
126831: PPUSH
126832: CALL_OW 296
126836: PUSH
126837: LD_INT 30
126839: LESS
126840: AND
126841: IFFALSE 126857
// ComAttackUnit ( i , e ) ;
126843: LD_VAR 0 5
126847: PPUSH
126848: LD_VAR 0 14
126852: PPUSH
126853: CALL_OW 115
// end ; end ; end ;
126857: GO 126860
126859: POP
// if IsDead ( i ) then
126860: LD_VAR 0 5
126864: PPUSH
126865: CALL_OW 301
126869: IFFALSE 126887
// defenders := defenders diff i ;
126871: LD_ADDR_VAR 0 2
126875: PUSH
126876: LD_VAR 0 2
126880: PUSH
126881: LD_VAR 0 5
126885: DIFF
126886: ST_TO_ADDR
// end ;
126887: GO 126070
126889: POP
126890: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
126891: LD_VAR 0 3
126895: NOT
126896: PUSH
126897: LD_VAR 0 2
126901: NOT
126902: OR
126903: PUSH
126904: LD_EXP 115
126908: PUSH
126909: LD_VAR 0 1
126913: ARRAY
126914: NOT
126915: OR
126916: IFFALSE 125974
// MC_Reset ( base , 18 ) ;
126918: LD_VAR 0 1
126922: PPUSH
126923: LD_INT 18
126925: PPUSH
126926: CALL 39279 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126930: LD_ADDR_VAR 0 2
126934: PUSH
126935: LD_VAR 0 2
126939: PUSH
126940: LD_VAR 0 2
126944: PPUSH
126945: LD_INT 2
126947: PUSH
126948: LD_INT 25
126950: PUSH
126951: LD_INT 1
126953: PUSH
126954: EMPTY
126955: LIST
126956: LIST
126957: PUSH
126958: LD_INT 25
126960: PUSH
126961: LD_INT 5
126963: PUSH
126964: EMPTY
126965: LIST
126966: LIST
126967: PUSH
126968: LD_INT 25
126970: PUSH
126971: LD_INT 8
126973: PUSH
126974: EMPTY
126975: LIST
126976: LIST
126977: PUSH
126978: LD_INT 25
126980: PUSH
126981: LD_INT 9
126983: PUSH
126984: EMPTY
126985: LIST
126986: LIST
126987: PUSH
126988: EMPTY
126989: LIST
126990: LIST
126991: LIST
126992: LIST
126993: LIST
126994: PPUSH
126995: CALL_OW 72
126999: DIFF
127000: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
127001: LD_VAR 0 3
127005: NOT
127006: PUSH
127007: LD_VAR 0 2
127011: PPUSH
127012: LD_INT 21
127014: PUSH
127015: LD_INT 2
127017: PUSH
127018: EMPTY
127019: LIST
127020: LIST
127021: PPUSH
127022: CALL_OW 72
127026: AND
127027: IFFALSE 127365
// begin tmp := FilterByTag ( defenders , 19 ) ;
127029: LD_ADDR_VAR 0 12
127033: PUSH
127034: LD_VAR 0 2
127038: PPUSH
127039: LD_INT 19
127041: PPUSH
127042: CALL 99247 0 2
127046: ST_TO_ADDR
// if tmp then
127047: LD_VAR 0 12
127051: IFFALSE 127121
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
127053: LD_ADDR_VAR 0 12
127057: PUSH
127058: LD_VAR 0 12
127062: PPUSH
127063: LD_INT 25
127065: PUSH
127066: LD_INT 3
127068: PUSH
127069: EMPTY
127070: LIST
127071: LIST
127072: PPUSH
127073: CALL_OW 72
127077: ST_TO_ADDR
// if tmp then
127078: LD_VAR 0 12
127082: IFFALSE 127121
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
127084: LD_ADDR_EXP 127
127088: PUSH
127089: LD_EXP 127
127093: PPUSH
127094: LD_VAR 0 1
127098: PPUSH
127099: LD_EXP 127
127103: PUSH
127104: LD_VAR 0 1
127108: ARRAY
127109: PUSH
127110: LD_VAR 0 12
127114: UNION
127115: PPUSH
127116: CALL_OW 1
127120: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
127121: LD_VAR 0 1
127125: PPUSH
127126: LD_INT 19
127128: PPUSH
127129: CALL 39279 0 2
// repeat wait ( 0 0$1 ) ;
127133: LD_INT 35
127135: PPUSH
127136: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127140: LD_EXP 115
127144: PUSH
127145: LD_VAR 0 1
127149: ARRAY
127150: NOT
127151: PUSH
127152: LD_EXP 115
127156: PUSH
127157: LD_VAR 0 1
127161: ARRAY
127162: PUSH
127163: EMPTY
127164: EQUAL
127165: OR
127166: IFFALSE 127203
// begin for i in defenders do
127168: LD_ADDR_VAR 0 5
127172: PUSH
127173: LD_VAR 0 2
127177: PUSH
127178: FOR_IN
127179: IFFALSE 127192
// ComStop ( i ) ;
127181: LD_VAR 0 5
127185: PPUSH
127186: CALL_OW 141
127190: GO 127178
127192: POP
127193: POP
// defenders := [ ] ;
127194: LD_ADDR_VAR 0 2
127198: PUSH
127199: EMPTY
127200: ST_TO_ADDR
// exit ;
127201: GO 127429
// end ; for i in defenders do
127203: LD_ADDR_VAR 0 5
127207: PUSH
127208: LD_VAR 0 2
127212: PUSH
127213: FOR_IN
127214: IFFALSE 127303
// begin if not IsInArea ( i , mc_parking [ base ] ) then
127216: LD_VAR 0 5
127220: PPUSH
127221: LD_EXP 139
127225: PUSH
127226: LD_VAR 0 1
127230: ARRAY
127231: PPUSH
127232: CALL_OW 308
127236: NOT
127237: IFFALSE 127261
// ComMoveToArea ( i , mc_parking [ base ] ) else
127239: LD_VAR 0 5
127243: PPUSH
127244: LD_EXP 139
127248: PUSH
127249: LD_VAR 0 1
127253: ARRAY
127254: PPUSH
127255: CALL_OW 113
127259: GO 127301
// if GetControl ( i ) = control_manual then
127261: LD_VAR 0 5
127265: PPUSH
127266: CALL_OW 263
127270: PUSH
127271: LD_INT 1
127273: EQUAL
127274: IFFALSE 127301
// if IsDrivenBy ( i ) then
127276: LD_VAR 0 5
127280: PPUSH
127281: CALL_OW 311
127285: IFFALSE 127301
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
127287: LD_VAR 0 5
127291: PPUSH
127292: CALL_OW 311
127296: PPUSH
127297: CALL_OW 121
// end ;
127301: GO 127213
127303: POP
127304: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
127305: LD_VAR 0 2
127309: PPUSH
127310: LD_INT 95
127312: PUSH
127313: LD_EXP 139
127317: PUSH
127318: LD_VAR 0 1
127322: ARRAY
127323: PUSH
127324: EMPTY
127325: LIST
127326: LIST
127327: PPUSH
127328: CALL_OW 72
127332: PUSH
127333: LD_VAR 0 2
127337: EQUAL
127338: PUSH
127339: LD_EXP 138
127343: PUSH
127344: LD_VAR 0 1
127348: ARRAY
127349: OR
127350: PUSH
127351: LD_EXP 115
127355: PUSH
127356: LD_VAR 0 1
127360: ARRAY
127361: NOT
127362: OR
127363: IFFALSE 127133
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
127365: LD_ADDR_EXP 137
127369: PUSH
127370: LD_EXP 137
127374: PPUSH
127375: LD_VAR 0 1
127379: PPUSH
127380: LD_VAR 0 2
127384: PPUSH
127385: LD_INT 21
127387: PUSH
127388: LD_INT 2
127390: PUSH
127391: EMPTY
127392: LIST
127393: LIST
127394: PPUSH
127395: CALL_OW 72
127399: PPUSH
127400: CALL_OW 1
127404: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
127405: LD_VAR 0 1
127409: PPUSH
127410: LD_INT 19
127412: PPUSH
127413: CALL 39279 0 2
// MC_Reset ( base , 20 ) ;
127417: LD_VAR 0 1
127421: PPUSH
127422: LD_INT 20
127424: PPUSH
127425: CALL 39279 0 2
// end ; end_of_file
127429: LD_VAR 0 4
127433: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
127434: LD_VAR 0 1
127438: PUSH
127439: LD_INT 200
127441: DOUBLE
127442: GREATEREQUAL
127443: IFFALSE 127451
127445: LD_INT 299
127447: DOUBLE
127448: LESSEQUAL
127449: IFTRUE 127453
127451: GO 127485
127453: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
127454: LD_VAR 0 1
127458: PPUSH
127459: LD_VAR 0 2
127463: PPUSH
127464: LD_VAR 0 3
127468: PPUSH
127469: LD_VAR 0 4
127473: PPUSH
127474: LD_VAR 0 5
127478: PPUSH
127479: CALL 116367 0 5
127483: GO 127562
127485: LD_INT 300
127487: DOUBLE
127488: GREATEREQUAL
127489: IFFALSE 127497
127491: LD_INT 399
127493: DOUBLE
127494: LESSEQUAL
127495: IFTRUE 127499
127497: GO 127561
127499: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
127500: LD_VAR 0 1
127504: PPUSH
127505: LD_VAR 0 2
127509: PPUSH
127510: LD_VAR 0 3
127514: PPUSH
127515: LD_VAR 0 4
127519: PPUSH
127520: LD_VAR 0 5
127524: PPUSH
127525: LD_VAR 0 6
127529: PPUSH
127530: LD_VAR 0 7
127534: PPUSH
127535: LD_VAR 0 8
127539: PPUSH
127540: LD_VAR 0 9
127544: PPUSH
127545: LD_VAR 0 10
127549: PPUSH
127550: LD_VAR 0 11
127554: PPUSH
127555: CALL 114255 0 11
127559: GO 127562
127561: POP
// end ;
127562: PPOPN 11
127564: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
127565: LD_VAR 0 1
127569: PPUSH
127570: LD_VAR 0 2
127574: PPUSH
127575: LD_VAR 0 3
127579: PPUSH
127580: LD_VAR 0 4
127584: PPUSH
127585: LD_VAR 0 5
127589: PPUSH
127590: CALL 116349 0 5
// end ; end_of_file
127594: PPOPN 5
127596: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
127597: LD_VAR 0 1
127601: PPUSH
127602: LD_VAR 0 2
127606: PPUSH
127607: LD_VAR 0 3
127611: PPUSH
127612: LD_VAR 0 4
127616: PPUSH
127617: LD_VAR 0 5
127621: PPUSH
127622: LD_VAR 0 6
127626: PPUSH
127627: CALL 103063 0 6
// end ;
127631: PPOPN 6
127633: END
