// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36846 0 0
// InitNature ;
  19: CALL 36714 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11915 0 0
// PrepareRussian ;
  40: CALL 7187 0 0
// PrepareLegion ;
  44: CALL 4342 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15994 0 0
// MC_Start ( ) ;
  60: CALL 39018 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61816 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61909 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61259 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 61074 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61816 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61909 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 61074 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61259 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61689 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60756 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61816 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61909 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 61074 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61816 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61909 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60966 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62227 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61398 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61689 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61689 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 62021 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 61074 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61640 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67510 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72525 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72525 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72525 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72525 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72525 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67510 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67510 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67510 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67510 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 67510 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 67510 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 67510 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 67510 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 67510 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 67510 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 67510 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 67510 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 67510 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 67510 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 67510 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3159: LD_ADDR_EXP 60
3163: PUSH
3164: LD_STRING Powell
3166: PPUSH
3167: CALL_OW 25
3171: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3172: LD_EXP 60
3176: PPUSH
3177: LD_INT 57
3179: PPUSH
3180: LD_INT 94
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3190: LD_EXP 60
3194: PPUSH
3195: LD_INT 58
3197: PPUSH
3198: LD_INT 94
3200: PPUSH
3201: CALL_OW 118
// vip := [ ] ;
3205: LD_ADDR_EXP 61
3209: PUSH
3210: EMPTY
3211: ST_TO_ADDR
// tmp := [ ] ;
3212: LD_ADDR_VAR 0 5
3216: PUSH
3217: EMPTY
3218: ST_TO_ADDR
// if JMMGirl <> 2 then
3219: LD_EXP 7
3223: PUSH
3224: LD_INT 2
3226: NONEQUAL
3227: IFFALSE 3251
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3229: LD_ADDR_EXP 43
3233: PUSH
3234: LD_STRING Lisa
3236: PPUSH
3237: LD_EXP 1
3241: NOT
3242: PPUSH
3243: LD_STRING 13s_
3245: PPUSH
3246: CALL 67510 0 3
3250: ST_TO_ADDR
// if Lisa then
3251: LD_EXP 43
3255: IFFALSE 3273
// tmp := tmp ^ Lisa ;
3257: LD_ADDR_VAR 0 5
3261: PUSH
3262: LD_VAR 0 5
3266: PUSH
3267: LD_EXP 43
3271: ADD
3272: ST_TO_ADDR
// if JMMGirl < 3 then
3273: LD_EXP 7
3277: PUSH
3278: LD_INT 3
3280: LESS
3281: IFFALSE 3312
// begin Connie := NewCharacter ( Coonie ) ;
3283: LD_ADDR_EXP 55
3287: PUSH
3288: LD_STRING Coonie
3290: PPUSH
3291: CALL_OW 25
3295: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3296: LD_ADDR_VAR 0 5
3300: PUSH
3301: LD_VAR 0 5
3305: PUSH
3306: LD_EXP 55
3310: ADD
3311: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 44
3316: PUSH
3317: LD_STRING Donaldson
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 67510 0 3
3333: ST_TO_ADDR
// if Donaldson then
3334: LD_EXP 44
3338: IFFALSE 3356
// tmp := tmp ^ Donaldson ;
3340: LD_ADDR_VAR 0 5
3344: PUSH
3345: LD_VAR 0 5
3349: PUSH
3350: LD_EXP 44
3354: ADD
3355: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 45
3360: PUSH
3361: LD_STRING Bobby
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 67510 0 3
3377: ST_TO_ADDR
// if Bobby then
3378: LD_EXP 45
3382: IFFALSE 3400
// tmp := tmp ^ Bobby ;
3384: LD_ADDR_VAR 0 5
3388: PUSH
3389: LD_VAR 0 5
3393: PUSH
3394: LD_EXP 45
3398: ADD
3399: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 46
3404: PUSH
3405: LD_STRING Cyrus
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 67510 0 3
3421: ST_TO_ADDR
// if Cyrus then
3422: LD_EXP 46
3426: IFFALSE 3444
// tmp := tmp ^ Cyrus ;
3428: LD_ADDR_VAR 0 5
3432: PUSH
3433: LD_VAR 0 5
3437: PUSH
3438: LD_EXP 46
3442: ADD
3443: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 47
3448: PUSH
3449: LD_STRING Denis
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 67510 0 3
3465: ST_TO_ADDR
// if not Denis then
3466: LD_EXP 47
3470: NOT
3471: IFFALSE 3495
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3473: LD_ADDR_EXP 47
3477: PUSH
3478: LD_STRING Denis
3480: PPUSH
3481: LD_EXP 1
3485: NOT
3486: PPUSH
3487: LD_STRING 13f_
3489: PPUSH
3490: CALL 67510 0 3
3494: ST_TO_ADDR
// if Denis then
3495: LD_EXP 47
3499: IFFALSE 3517
// tmp := tmp ^ Denis ;
3501: LD_ADDR_VAR 0 5
3505: PUSH
3506: LD_VAR 0 5
3510: PUSH
3511: LD_EXP 47
3515: ADD
3516: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3517: LD_ADDR_EXP 48
3521: PUSH
3522: LD_STRING Brown
3524: PPUSH
3525: LD_EXP 1
3529: NOT
3530: PPUSH
3531: LD_STRING 13s_
3533: PPUSH
3534: CALL 67510 0 3
3538: ST_TO_ADDR
// if Brown then
3539: LD_EXP 48
3543: IFFALSE 3561
// tmp := tmp ^ Brown ;
3545: LD_ADDR_VAR 0 5
3549: PUSH
3550: LD_VAR 0 5
3554: PUSH
3555: LD_EXP 48
3559: ADD
3560: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3561: LD_ADDR_EXP 49
3565: PUSH
3566: LD_STRING Gladstone
3568: PPUSH
3569: LD_EXP 1
3573: NOT
3574: PPUSH
3575: LD_STRING 13s_
3577: PPUSH
3578: CALL 67510 0 3
3582: ST_TO_ADDR
// if Gladstone then
3583: LD_EXP 49
3587: IFFALSE 3605
// tmp := tmp ^ Gladstone ;
3589: LD_ADDR_VAR 0 5
3593: PUSH
3594: LD_VAR 0 5
3598: PUSH
3599: LD_EXP 49
3603: ADD
3604: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3605: LD_ADDR_EXP 50
3609: PUSH
3610: LD_STRING Houten
3612: PPUSH
3613: LD_EXP 1
3617: NOT
3618: PPUSH
3619: LD_STRING 13s_
3621: PPUSH
3622: CALL 67510 0 3
3626: ST_TO_ADDR
// if Houten then
3627: LD_EXP 50
3631: IFFALSE 3649
// tmp := tmp ^ Houten ;
3633: LD_ADDR_VAR 0 5
3637: PUSH
3638: LD_VAR 0 5
3642: PUSH
3643: LD_EXP 50
3647: ADD
3648: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3649: LD_ADDR_EXP 51
3653: PUSH
3654: LD_STRING Cornel
3656: PPUSH
3657: LD_EXP 1
3661: NOT
3662: PPUSH
3663: LD_STRING 13s_
3665: PPUSH
3666: CALL 67510 0 3
3670: ST_TO_ADDR
// if Cornel then
3671: LD_EXP 51
3675: IFFALSE 3693
// tmp := tmp ^ Cornel ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_VAR 0 5
3686: PUSH
3687: LD_EXP 51
3691: ADD
3692: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3693: LD_ADDR_EXP 52
3697: PUSH
3698: LD_STRING Gary
3700: PPUSH
3701: LD_EXP 1
3705: NOT
3706: PPUSH
3707: LD_STRING 13s_
3709: PPUSH
3710: CALL 67510 0 3
3714: ST_TO_ADDR
// if Gary then
3715: LD_EXP 52
3719: IFFALSE 3737
// tmp := tmp ^ Gary ;
3721: LD_ADDR_VAR 0 5
3725: PUSH
3726: LD_VAR 0 5
3730: PUSH
3731: LD_EXP 52
3735: ADD
3736: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3737: LD_ADDR_EXP 53
3741: PUSH
3742: LD_STRING Frank
3744: PPUSH
3745: LD_EXP 1
3749: NOT
3750: PPUSH
3751: LD_STRING 13s_
3753: PPUSH
3754: CALL 67510 0 3
3758: ST_TO_ADDR
// if Frank then
3759: LD_EXP 53
3763: IFFALSE 3781
// tmp := tmp ^ Frank ;
3765: LD_ADDR_VAR 0 5
3769: PUSH
3770: LD_VAR 0 5
3774: PUSH
3775: LD_EXP 53
3779: ADD
3780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3781: LD_ADDR_EXP 54
3785: PUSH
3786: LD_STRING Kikuchi
3788: PPUSH
3789: LD_EXP 1
3793: NOT
3794: PPUSH
3795: LD_STRING 13s_
3797: PPUSH
3798: CALL 67510 0 3
3802: ST_TO_ADDR
// if Kikuchi then
3803: LD_EXP 54
3807: IFFALSE 3825
// tmp := tmp ^ Kikuchi ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: LD_VAR 0 5
3818: PUSH
3819: LD_EXP 54
3823: ADD
3824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3825: LD_ADDR_EXP 57
3829: PUSH
3830: LD_STRING Mike
3832: PPUSH
3833: LD_EXP 1
3837: NOT
3838: PPUSH
3839: LD_STRING 10c_
3841: PPUSH
3842: CALL 67510 0 3
3846: ST_TO_ADDR
// if Mike then
3847: LD_EXP 57
3851: IFFALSE 3874
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3853: LD_EXP 57
3857: PPUSH
3858: LD_INT 61
3860: PPUSH
3861: LD_INT 89
3863: PPUSH
3864: LD_INT 8
3866: PPUSH
3867: LD_INT 0
3869: PPUSH
3870: CALL_OW 50
// vip := tmp ;
3874: LD_ADDR_EXP 61
3878: PUSH
3879: LD_VAR 0 5
3883: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3884: LD_ADDR_VAR 0 5
3888: PUSH
3889: LD_VAR 0 5
3893: PUSH
3894: LD_STRING 13s_others
3896: PPUSH
3897: CALL_OW 31
3901: UNION
3902: ST_TO_ADDR
// if tmp < 18 then
3903: LD_VAR 0 5
3907: PUSH
3908: LD_INT 18
3910: LESS
3911: IFFALSE 4004
// for i = 1 to 18 - tmp do
3913: LD_ADDR_VAR 0 2
3917: PUSH
3918: DOUBLE
3919: LD_INT 1
3921: DEC
3922: ST_TO_ADDR
3923: LD_INT 18
3925: PUSH
3926: LD_VAR 0 5
3930: MINUS
3931: PUSH
3932: FOR_TO
3933: IFFALSE 4002
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3935: LD_INT 1
3937: PPUSH
3938: LD_VAR 0 2
3942: PUSH
3943: LD_INT 4
3945: MOD
3946: PUSH
3947: LD_INT 1
3949: PLUS
3950: PPUSH
3951: LD_INT 4
3953: PPUSH
3954: CALL_OW 380
// un := CreateHuman ;
3958: LD_ADDR_VAR 0 10
3962: PUSH
3963: CALL_OW 44
3967: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_VAR 0 5
3977: PPUSH
3978: LD_VAR 0 10
3982: PPUSH
3983: CALL 104959 0 2
3987: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3988: LD_VAR 0 10
3992: PPUSH
3993: LD_INT 1
3995: PPUSH
3996: CALL_OW 109
// end ;
4000: GO 3932
4002: POP
4003: POP
// depot := HexInfo ( 53 , 94 ) ;
4004: LD_ADDR_VAR 0 6
4008: PUSH
4009: LD_INT 53
4011: PPUSH
4012: LD_INT 94
4014: PPUSH
4015: CALL_OW 428
4019: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4020: LD_ADDR_VAR 0 7
4024: PUSH
4025: LD_INT 56
4027: PPUSH
4028: LD_INT 101
4030: PPUSH
4031: CALL_OW 428
4035: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4036: LD_ADDR_VAR 0 8
4040: PUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 101
4046: PPUSH
4047: CALL_OW 428
4051: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4052: LD_ADDR_VAR 0 9
4056: PUSH
4057: LD_INT 54
4059: PPUSH
4060: LD_INT 85
4062: PPUSH
4063: CALL_OW 428
4067: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4068: LD_ADDR_VAR 0 3
4072: PUSH
4073: LD_VAR 0 8
4077: PUSH
4078: LD_VAR 0 6
4082: PUSH
4083: LD_VAR 0 9
4087: PUSH
4088: LD_VAR 0 7
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// for i in tmp do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: LD_VAR 0 5
4108: PUSH
4109: FOR_IN
4110: IFFALSE 4198
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4112: LD_VAR 0 3
4116: PUSH
4117: LD_INT 1
4119: ARRAY
4120: PPUSH
4121: CALL_OW 313
4125: PUSH
4126: LD_INT 6
4128: EQUAL
4129: IFFALSE 4149
// b := Delete ( b , 1 ) ;
4131: LD_ADDR_VAR 0 3
4135: PUSH
4136: LD_VAR 0 3
4140: PPUSH
4141: LD_INT 1
4143: PPUSH
4144: CALL_OW 3
4148: ST_TO_ADDR
// if b then
4149: LD_VAR 0 3
4153: IFFALSE 4175
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4155: LD_VAR 0 2
4159: PPUSH
4160: LD_VAR 0 3
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PPUSH
4169: CALL_OW 52
4173: GO 4196
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4175: LD_VAR 0 2
4179: PPUSH
4180: LD_INT 61
4182: PPUSH
4183: LD_INT 89
4185: PPUSH
4186: LD_INT 8
4188: PPUSH
4189: LD_INT 0
4191: PPUSH
4192: CALL_OW 50
// end ;
4196: GO 4109
4198: POP
4199: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4200: LD_INT 2
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: LD_INT 12
4211: PPUSH
4212: LD_INT 100
4214: PPUSH
4215: CALL 72525 0 5
// veh := CreateVehicle ;
4219: LD_ADDR_VAR 0 4
4223: PUSH
4224: CALL_OW 45
4228: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4229: LD_VAR 0 4
4233: PPUSH
4234: LD_INT 4
4236: PPUSH
4237: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4241: LD_VAR 0 4
4245: PPUSH
4246: LD_INT 49
4248: PPUSH
4249: LD_INT 88
4251: PPUSH
4252: LD_INT 0
4254: PPUSH
4255: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 290
// uc_side := 0 ;
4274: LD_ADDR_OWVAR 20
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// uc_nation := 0 ;
4282: LD_ADDR_OWVAR 21
4286: PUSH
4287: LD_INT 0
4289: ST_TO_ADDR
// for i := 1 to 3 do
4290: LD_ADDR_VAR 0 2
4294: PUSH
4295: DOUBLE
4296: LD_INT 1
4298: DEC
4299: ST_TO_ADDR
4300: LD_INT 3
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4335
// begin InitHc ;
4306: CALL_OW 19
// hc_class := class_apeman ;
4310: LD_ADDR_OWVAR 28
4314: PUSH
4315: LD_INT 12
4317: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4318: CALL_OW 44
4322: PPUSH
4323: LD_INT 13
4325: PPUSH
4326: LD_INT 0
4328: PPUSH
4329: CALL_OW 49
// end ;
4333: GO 4303
4335: POP
4336: POP
// end ; end_of_file
4337: LD_VAR 0 1
4341: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4342: LD_INT 0
4344: PPUSH
4345: PPUSH
4346: PPUSH
4347: PPUSH
4348: PPUSH
// side := 8 ;
4349: LD_ADDR_VAR 0 3
4353: PUSH
4354: LD_INT 8
4356: ST_TO_ADDR
// uc_side := side ;
4357: LD_ADDR_OWVAR 20
4361: PUSH
4362: LD_VAR 0 3
4366: ST_TO_ADDR
// uc_nation := 2 ;
4367: LD_ADDR_OWVAR 21
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4375: LD_ADDR_VAR 0 2
4379: PUSH
4380: LD_INT 22
4382: PUSH
4383: LD_VAR 0 3
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 21
4394: PUSH
4395: LD_INT 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PPUSH
4406: CALL_OW 69
4410: PUSH
4411: FOR_IN
4412: IFFALSE 4428
// SetBLevel ( i , 10 ) ;
4414: LD_VAR 0 2
4418: PPUSH
4419: LD_INT 10
4421: PPUSH
4422: CALL_OW 241
4426: GO 4411
4428: POP
4429: POP
// if KurtStatus then
4430: LD_EXP 3
4434: IFFALSE 4457
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4436: LD_ADDR_EXP 62
4440: PUSH
4441: LD_STRING Kurt
4443: PPUSH
4444: LD_INT 0
4446: PPUSH
4447: LD_STRING 
4449: PPUSH
4450: CALL 67510 0 3
4454: ST_TO_ADDR
4455: GO 4479
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4457: LD_ADDR_EXP 62
4461: PUSH
4462: LD_STRING AltKurt
4464: PPUSH
4465: LD_EXP 1
4469: NOT
4470: PPUSH
4471: LD_STRING 
4473: PPUSH
4474: CALL 67510 0 3
4478: ST_TO_ADDR
// if not Kurt then
4479: LD_EXP 62
4483: NOT
4484: IFFALSE 4510
// begin InitHc ;
4486: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4490: LD_INT 1
4492: PPUSH
4493: LD_INT 10
4495: PPUSH
4496: CALL_OW 381
// Kurt := CreateHuman ;
4500: LD_ADDR_EXP 62
4504: PUSH
4505: CALL_OW 44
4509: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4510: LD_EXP 62
4514: PPUSH
4515: LD_INT 324
4517: PPUSH
4518: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4522: LD_ADDR_EXP 63
4526: PUSH
4527: LD_STRING Kozlov
4529: PPUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_STRING 
4535: PPUSH
4536: CALL 67510 0 3
4540: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4541: LD_EXP 63
4545: PPUSH
4546: LD_INT 22
4548: PUSH
4549: LD_INT 8
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 23
4558: PUSH
4559: LD_INT 3
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 30
4568: PUSH
4569: LD_INT 8
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: PPUSH
4581: CALL_OW 69
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4594: LD_EXP 63
4598: PPUSH
4599: LD_INT 3
4601: PPUSH
4602: LD_INT 10
4604: PPUSH
4605: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4609: LD_EXP 63
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 10
4619: PPUSH
4620: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_INT 22
4631: PUSH
4632: LD_VAR 0 3
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: PUSH
4641: LD_INT 30
4643: PUSH
4644: LD_INT 32
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 58
4653: PUSH
4654: EMPTY
4655: LIST
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: LIST
4661: PPUSH
4662: CALL_OW 69
4666: ST_TO_ADDR
// for i = 1 to 10 do
4667: LD_ADDR_VAR 0 2
4671: PUSH
4672: DOUBLE
4673: LD_INT 1
4675: DEC
4676: ST_TO_ADDR
4677: LD_INT 10
4679: PUSH
4680: FOR_TO
4681: IFFALSE 4753
// begin uc_nation := nation_nature ;
4683: LD_ADDR_OWVAR 21
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4691: LD_ADDR_OWVAR 28
4695: PUSH
4696: LD_INT 15
4698: ST_TO_ADDR
// hc_gallery :=  ;
4699: LD_ADDR_OWVAR 33
4703: PUSH
4704: LD_STRING 
4706: ST_TO_ADDR
// hc_name :=  ;
4707: LD_ADDR_OWVAR 26
4711: PUSH
4712: LD_STRING 
4714: ST_TO_ADDR
// un := CreateHuman ;
4715: LD_ADDR_VAR 0 4
4719: PUSH
4720: CALL_OW 44
4724: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4725: LD_VAR 0 4
4729: PPUSH
4730: LD_VAR 0 5
4734: PUSH
4735: LD_VAR 0 5
4739: PUSH
4740: LD_VAR 0 2
4744: MINUS
4745: ARRAY
4746: PPUSH
4747: CALL_OW 52
// end ;
4751: GO 4680
4753: POP
4754: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4755: LD_ADDR_VAR 0 5
4759: PUSH
4760: LD_STRING 12_kurt_squad
4762: PPUSH
4763: CALL_OW 31
4767: ST_TO_ADDR
// if tmp then
4768: LD_VAR 0 5
4772: IFFALSE 4806
// for i in tmp do
4774: LD_ADDR_VAR 0 2
4778: PUSH
4779: LD_VAR 0 5
4783: PUSH
4784: FOR_IN
4785: IFFALSE 4804
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4787: LD_VAR 0 2
4791: PPUSH
4792: LD_INT 5
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 49
4802: GO 4784
4804: POP
4805: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4806: LD_INT 324
4808: PPUSH
4809: LD_INT 5
4811: PPUSH
4812: LD_STRING 
4814: PPUSH
4815: LD_INT 8
4817: PUSH
4818: LD_INT 9
4820: PUSH
4821: LD_INT 10
4823: PUSH
4824: LD_INT 10
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: PUSH
4833: LD_OWVAR 67
4837: ARRAY
4838: PPUSH
4839: LD_INT 3000
4841: PUSH
4842: LD_INT 500
4844: PUSH
4845: LD_INT 150
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PPUSH
4853: LD_INT 16
4855: PUSH
4856: LD_INT 6
4858: PUSH
4859: LD_INT 6
4861: PUSH
4862: LD_INT 8
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL 75969 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4875: LD_ADDR_EXP 100
4879: PUSH
4880: LD_EXP 100
4884: PPUSH
4885: LD_INT 3
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_VAR 0 3
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 23
4902: PUSH
4903: LD_INT 2
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 3
4912: PUSH
4913: LD_INT 21
4915: PUSH
4916: LD_INT 2
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: LIST
4931: PPUSH
4932: CALL_OW 69
4936: PUSH
4937: LD_EXP 62
4941: DIFF
4942: PPUSH
4943: CALL_OW 1
4947: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4948: LD_INT 1
4950: PPUSH
4951: LD_INT 7
4953: PPUSH
4954: CALL_OW 383
// hc_name := Ali Hadrach ;
4958: LD_ADDR_OWVAR 26
4962: PUSH
4963: LD_STRING Ali Hadrach
4965: ST_TO_ADDR
// hc_face_number := 31 ;
4966: LD_ADDR_OWVAR 34
4970: PUSH
4971: LD_INT 31
4973: ST_TO_ADDR
// Friend := CreateHuman ;
4974: LD_ADDR_EXP 64
4978: PUSH
4979: CALL_OW 44
4983: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4984: LD_INT 14
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 1
4992: PPUSH
4993: LD_INT 29
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 72525 0 5
// powellBomb := CreateVehicle ;
5003: LD_ADDR_EXP 65
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5013: LD_EXP 65
5017: PPUSH
5018: LD_INT 90
5020: PPUSH
5021: LD_INT 51
5023: PPUSH
5024: LD_INT 0
5026: PPUSH
5027: CALL_OW 48
// end ;
5031: LD_VAR 0 1
5035: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5036: LD_INT 0
5038: PPUSH
5039: PPUSH
5040: PPUSH
// if IsLive ( kozlov_fac ) then
5041: LD_INT 332
5043: PPUSH
5044: CALL_OW 300
5048: IFFALSE 5052
// exit ;
5050: GO 5619
// ComExitBuilding ( Kozlov ) ;
5052: LD_EXP 63
5056: PPUSH
5057: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5061: LD_EXP 63
5065: PPUSH
5066: CALL_OW 257
5070: PUSH
5071: LD_INT 2
5073: NONEQUAL
5074: IFFALSE 5109
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5076: LD_EXP 63
5080: PPUSH
5081: LD_INT 324
5083: PPUSH
5084: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5088: LD_EXP 63
5092: PPUSH
5093: LD_INT 2
5095: PPUSH
5096: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5100: LD_EXP 63
5104: PPUSH
5105: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5109: LD_EXP 63
5113: PPUSH
5114: LD_INT 2
5116: PPUSH
5117: LD_INT 93
5119: PPUSH
5120: LD_INT 32
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5130: LD_INT 35
5132: PPUSH
5133: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5137: LD_INT 22
5139: PUSH
5140: LD_INT 8
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 30
5149: PUSH
5150: LD_INT 3
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 23
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 57
5169: PUSH
5170: EMPTY
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: PPUSH
5179: CALL_OW 69
5183: IFFALSE 5130
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_INT 8
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 3
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 23
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 57
5222: PUSH
5223: EMPTY
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 1
5239: ARRAY
5240: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5241: LD_INT 22
5243: PUSH
5244: LD_INT 8
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 23
5253: PUSH
5254: LD_INT 3
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 30
5263: PUSH
5264: LD_INT 21
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PPUSH
5276: CALL_OW 69
5280: NOT
5281: IFFALSE 5359
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5283: LD_EXP 63
5287: PPUSH
5288: LD_INT 21
5290: PPUSH
5291: LD_INT 97
5293: PPUSH
5294: LD_INT 36
5296: PPUSH
5297: LD_INT 5
5299: PPUSH
5300: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5304: LD_INT 35
5306: PPUSH
5307: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5311: LD_INT 22
5313: PUSH
5314: LD_INT 8
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 23
5323: PUSH
5324: LD_INT 3
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 30
5333: PUSH
5334: LD_INT 21
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 57
5343: PUSH
5344: EMPTY
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: PPUSH
5353: CALL_OW 69
5357: IFFALSE 5304
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5359: LD_INT 22
5361: PUSH
5362: LD_INT 8
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: LD_INT 23
5371: PUSH
5372: LD_INT 3
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 18
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: LIST
5393: PPUSH
5394: CALL_OW 69
5398: NOT
5399: IFFALSE 5477
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5401: LD_EXP 63
5405: PPUSH
5406: LD_INT 18
5408: PPUSH
5409: LD_INT 89
5411: PPUSH
5412: LD_INT 32
5414: PPUSH
5415: LD_INT 1
5417: PPUSH
5418: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5422: LD_INT 35
5424: PPUSH
5425: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5429: LD_INT 22
5431: PUSH
5432: LD_INT 8
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: LD_INT 23
5441: PUSH
5442: LD_INT 3
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 30
5451: PUSH
5452: LD_INT 18
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 57
5461: PUSH
5462: EMPTY
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 69
5475: IFFALSE 5422
// end ; lab := kozlov_lab ;
5477: LD_ADDR_VAR 0 3
5481: PUSH
5482: LD_INT 336
5484: ST_TO_ADDR
// if not lab then
5485: LD_VAR 0 3
5489: NOT
5490: IFFALSE 5494
// exit ;
5492: GO 5619
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5494: LD_EXP 63
5498: PPUSH
5499: LD_VAR 0 3
5503: PUSH
5504: LD_INT 1
5506: ARRAY
5507: PPUSH
5508: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5512: LD_EXP 63
5516: PPUSH
5517: LD_INT 4
5519: PPUSH
5520: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5524: LD_VAR 0 3
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: LD_INT 25
5535: PPUSH
5536: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5540: LD_INT 35
5542: PPUSH
5543: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5547: LD_INT 25
5549: PPUSH
5550: LD_INT 8
5552: PPUSH
5553: CALL_OW 321
5557: PUSH
5558: LD_INT 2
5560: EQUAL
5561: IFFALSE 5540
// ComExitBuilding ( Kozlov ) ;
5563: LD_EXP 63
5567: PPUSH
5568: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5572: LD_EXP 63
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5586: LD_EXP 63
5590: PPUSH
5591: LD_INT 3
5593: PPUSH
5594: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5598: LD_VAR 0 2
5602: PPUSH
5603: LD_INT 23
5605: PPUSH
5606: LD_INT 3
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: LD_INT 48
5614: PPUSH
5615: CALL_OW 125
// end ;
5619: LD_VAR 0 1
5623: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5624: LD_EXP 22
5628: NOT
5629: PUSH
5630: LD_EXP 15
5634: PUSH
5635: LD_INT 6
5637: GREATEREQUAL
5638: AND
5639: IFFALSE 5720
5641: GO 5643
5643: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5644: LD_INT 3
5646: PPUSH
5647: LD_INT 3
5649: PPUSH
5650: CALL 61259 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 28
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: PPUSH
5716: CALL 61122 0 2
// end ;
5720: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5721: LD_EXP 22
5725: NOT
5726: PUSH
5727: LD_EXP 15
5731: PUSH
5732: LD_INT 6
5734: GREATEREQUAL
5735: AND
5736: PUSH
5737: LD_INT 3
5739: PPUSH
5740: LD_INT 1
5742: PPUSH
5743: CALL 62540 0 2
5747: NOT
5748: AND
5749: IFFALSE 6623
5751: GO 5753
5753: DISABLE
5754: LD_INT 0
5756: PPUSH
5757: PPUSH
5758: PPUSH
// begin enable ;
5759: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5760: LD_INT 22
5762: PUSH
5763: LD_INT 8
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 23
5772: PUSH
5773: LD_INT 2
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 30
5782: PUSH
5783: LD_INT 3
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: LIST
5794: PPUSH
5795: CALL_OW 69
5799: NOT
5800: IFFALSE 5804
// exit ;
5802: GO 6623
// if Prob ( 40 ) then
5804: LD_INT 40
5806: PPUSH
5807: CALL_OW 13
5811: IFFALSE 5938
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5813: LD_INT 3
5815: PPUSH
5816: LD_INT 14
5818: PUSH
5819: LD_INT 1
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 28
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: PUSH
5834: LD_INT 14
5836: PUSH
5837: LD_INT 1
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_INT 14
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 28
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 14
5872: PUSH
5873: LD_INT 1
5875: PUSH
5876: LD_INT 2
5878: PUSH
5879: LD_INT 28
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 14
5890: PUSH
5891: LD_INT 1
5893: PUSH
5894: LD_INT 2
5896: PUSH
5897: LD_INT 28
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 14
5908: PUSH
5909: LD_INT 1
5911: PUSH
5912: LD_INT 2
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL 61122 0 2
// end else
5936: GO 6145
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_INT 14
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 27
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: LD_INT 26
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_OWVAR 67
5972: ARRAY
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 14
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 27
5991: PUSH
5992: LD_INT 26
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 26
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_OWVAR 67
6011: ARRAY
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 26
6030: PUSH
6031: LD_INT 26
6033: PUSH
6034: LD_INT 29
6036: PUSH
6037: LD_INT 29
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: PUSH
6046: LD_OWVAR 67
6050: ARRAY
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 13
6060: PUSH
6061: LD_INT 1
6063: PUSH
6064: LD_INT 2
6066: PUSH
6067: LD_INT 26
6069: PUSH
6070: LD_INT 29
6072: PUSH
6073: LD_INT 29
6075: PUSH
6076: LD_INT 29
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: LD_OWVAR 67
6089: ARRAY
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 13
6099: PUSH
6100: LD_INT 1
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: LD_INT 29
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 14
6117: PUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: LD_INT 26
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: PPUSH
6141: CALL 61122 0 2
// end ; repeat wait ( 0 0$1 ) ;
6145: LD_INT 35
6147: PPUSH
6148: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6152: LD_INT 3
6154: PPUSH
6155: LD_INT 1
6157: PPUSH
6158: CALL 62540 0 2
6162: PUSH
6163: LD_INT 6
6165: GREATEREQUAL
6166: IFFALSE 6145
// wait ( 0 0$30 ) ;
6168: LD_INT 1050
6170: PPUSH
6171: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_INT 3
6182: PPUSH
6183: LD_INT 1
6185: PPUSH
6186: CALL 62540 0 2
6190: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6191: LD_ADDR_EXP 119
6195: PUSH
6196: LD_EXP 119
6200: PPUSH
6201: LD_INT 3
6203: PPUSH
6204: LD_EXP 119
6208: PUSH
6209: LD_INT 3
6211: ARRAY
6212: PUSH
6213: LD_VAR 0 2
6217: DIFF
6218: PPUSH
6219: CALL_OW 1
6223: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6224: LD_ADDR_VAR 0 3
6228: PUSH
6229: LD_INT 0
6231: PPUSH
6232: LD_INT 2
6234: PPUSH
6235: CALL_OW 12
6239: ST_TO_ADDR
// if target then
6240: LD_VAR 0 3
6244: IFFALSE 6381
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: LD_INT 24
6258: PUSH
6259: LD_INT 250
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: PPUSH
6266: CALL_OW 72
6270: ST_TO_ADDR
// if not tmp then
6271: LD_VAR 0 2
6275: NOT
6276: IFFALSE 6280
// break ;
6278: GO 6379
// for i in tmp do
6280: LD_ADDR_VAR 0 1
6284: PUSH
6285: LD_VAR 0 2
6289: PUSH
6290: FOR_IN
6291: IFFALSE 6331
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6293: LD_VAR 0 1
6297: PPUSH
6298: LD_INT 89
6300: PPUSH
6301: LD_INT 71
6303: PPUSH
6304: CALL_OW 297
6308: PUSH
6309: LD_INT 9
6311: GREATER
6312: IFFALSE 6329
// ComMoveXY ( i , 89 , 71 ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_INT 89
6321: PPUSH
6322: LD_INT 71
6324: PPUSH
6325: CALL_OW 111
6329: GO 6290
6331: POP
6332: POP
// wait ( 0 0$1 ) ;
6333: LD_INT 35
6335: PPUSH
6336: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_INT 92
6347: PUSH
6348: LD_INT 89
6350: PUSH
6351: LD_INT 71
6353: PUSH
6354: LD_INT 9
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: LD_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: MINUS
6376: GREATEREQUAL
6377: IFFALSE 6246
// end else
6379: GO 6514
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PPUSH
6391: LD_INT 24
6393: PUSH
6394: LD_INT 250
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: ST_TO_ADDR
// if not tmp then
6406: LD_VAR 0 2
6410: NOT
6411: IFFALSE 6415
// break ;
6413: GO 6514
// for i in tmp do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_VAR 0 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6466
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_INT 125
6435: PPUSH
6436: LD_INT 129
6438: PPUSH
6439: CALL_OW 297
6443: PUSH
6444: LD_INT 9
6446: GREATER
6447: IFFALSE 6464
// ComMoveXY ( i , 125 , 129 ) ;
6449: LD_VAR 0 1
6453: PPUSH
6454: LD_INT 125
6456: PPUSH
6457: LD_INT 129
6459: PPUSH
6460: CALL_OW 111
6464: GO 6425
6466: POP
6467: POP
// wait ( 0 0$1 ) ;
6468: LD_INT 35
6470: PPUSH
6471: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6475: LD_VAR 0 2
6479: PPUSH
6480: LD_INT 92
6482: PUSH
6483: LD_INT 125
6485: PUSH
6486: LD_INT 129
6488: PUSH
6489: LD_INT 9
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL_OW 72
6502: PUSH
6503: LD_VAR 0 2
6507: PUSH
6508: LD_INT 1
6510: MINUS
6511: GREATEREQUAL
6512: IFFALSE 6381
// end ; repeat wait ( 0 0$1 ) ;
6514: LD_INT 35
6516: PPUSH
6517: CALL_OW 67
// for i in tmp do
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_VAR 0 2
6530: PUSH
6531: FOR_IN
6532: IFFALSE 6614
// begin if GetLives ( i ) > 251 then
6534: LD_VAR 0 1
6538: PPUSH
6539: CALL_OW 256
6543: PUSH
6544: LD_INT 251
6546: GREATER
6547: IFFALSE 6585
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6549: LD_VAR 0 1
6553: PPUSH
6554: LD_INT 81
6556: PUSH
6557: LD_INT 8
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 69
6568: PPUSH
6569: LD_VAR 0 1
6573: PPUSH
6574: CALL_OW 74
6578: PPUSH
6579: CALL_OW 115
6583: GO 6612
// if IsDead ( i ) then
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 301
6594: IFFALSE 6612
// tmp := tmp diff i ;
6596: LD_ADDR_VAR 0 2
6600: PUSH
6601: LD_VAR 0 2
6605: PUSH
6606: LD_VAR 0 1
6610: DIFF
6611: ST_TO_ADDR
// end ;
6612: GO 6531
6614: POP
6615: POP
// until not tmp ;
6616: LD_VAR 0 2
6620: NOT
6621: IFFALSE 6514
// end ;
6623: PPOPN 3
6625: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6626: LD_EXP 22
6630: NOT
6631: PUSH
6632: LD_EXP 15
6636: PUSH
6637: LD_INT 6
6639: GREATEREQUAL
6640: AND
6641: PUSH
6642: LD_OWVAR 67
6646: PUSH
6647: LD_INT 1
6649: GREATER
6650: AND
6651: IFFALSE 7184
6653: GO 6655
6655: DISABLE
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// begin enable ;
6661: ENABLE
// tmp := [ ] ;
6662: LD_ADDR_VAR 0 3
6666: PUSH
6667: EMPTY
6668: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6669: LD_ADDR_VAR 0 1
6673: PUSH
6674: DOUBLE
6675: LD_INT 1
6677: DEC
6678: ST_TO_ADDR
6679: LD_INT 4
6681: PUSH
6682: LD_INT 6
6684: PUSH
6685: LD_INT 7
6687: PUSH
6688: LD_INT 8
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: PUSH
6697: LD_OWVAR 67
6701: ARRAY
6702: PUSH
6703: FOR_TO
6704: IFFALSE 6864
// begin uc_side := 8 ;
6706: LD_ADDR_OWVAR 20
6710: PUSH
6711: LD_INT 8
6713: ST_TO_ADDR
// uc_nation := 2 ;
6714: LD_ADDR_OWVAR 21
6718: PUSH
6719: LD_INT 2
6721: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6722: LD_INT 13
6724: PUSH
6725: LD_INT 14
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 1
6734: PPUSH
6735: LD_INT 2
6737: PPUSH
6738: CALL_OW 12
6742: ARRAY
6743: PPUSH
6744: LD_INT 1
6746: PPUSH
6747: LD_INT 5
6749: PPUSH
6750: LD_INT 27
6752: PUSH
6753: LD_INT 28
6755: PUSH
6756: LD_INT 26
6758: PUSH
6759: LD_INT 25
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 4
6773: PPUSH
6774: CALL_OW 12
6778: ARRAY
6779: PPUSH
6780: LD_INT 88
6782: PPUSH
6783: CALL 72525 0 5
// un := CreateVehicle ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: CALL_OW 45
6796: ST_TO_ADDR
// tmp := tmp ^ un ;
6797: LD_ADDR_VAR 0 3
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: LD_VAR 0 2
6811: ADD
6812: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6813: LD_VAR 0 2
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 30
6832: PPUSH
6833: LD_INT 0
6835: PPUSH
6836: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6840: LD_VAR 0 2
6844: PPUSH
6845: LD_INT 16
6847: PPUSH
6848: LD_INT 11
6850: PPUSH
6851: CALL_OW 111
// wait ( 0 0$2 ) ;
6855: LD_INT 70
6857: PPUSH
6858: CALL_OW 67
// end ;
6862: GO 6703
6864: POP
6865: POP
// for i = 1 to Difficulty do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_OWVAR 67
6880: PUSH
6881: FOR_TO
6882: IFFALSE 7011
// begin uc_side := 8 ;
6884: LD_ADDR_OWVAR 20
6888: PUSH
6889: LD_INT 8
6891: ST_TO_ADDR
// uc_nation := 2 ;
6892: LD_ADDR_OWVAR 21
6896: PUSH
6897: LD_INT 2
6899: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6900: LD_INT 0
6902: PPUSH
6903: LD_INT 8
6905: PPUSH
6906: LD_INT 8
6908: PUSH
6909: LD_INT 8
6911: PUSH
6912: LD_INT 9
6914: PUSH
6915: LD_INT 10
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_OWVAR 67
6928: ARRAY
6929: PPUSH
6930: CALL_OW 380
// un := CreateHuman ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: CALL_OW 44
6943: ST_TO_ADDR
// tmp := tmp ^ un ;
6944: LD_ADDR_VAR 0 3
6948: PUSH
6949: LD_VAR 0 3
6953: PUSH
6954: LD_VAR 0 2
6958: ADD
6959: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6960: LD_VAR 0 2
6964: PPUSH
6965: LD_INT 3
6967: PPUSH
6968: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 30
6979: PPUSH
6980: LD_INT 0
6982: PPUSH
6983: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6987: LD_VAR 0 2
6991: PPUSH
6992: LD_INT 16
6994: PPUSH
6995: LD_INT 11
6997: PPUSH
6998: CALL_OW 111
// wait ( 0 0$2 ) ;
7002: LD_INT 70
7004: PPUSH
7005: CALL_OW 67
// end ;
7009: GO 6881
7011: POP
7012: POP
// repeat wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// if legionDestroyed then
7020: LD_EXP 22
7024: IFFALSE 7028
// exit ;
7026: GO 7184
// for i in tmp do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: LD_VAR 0 3
7037: PUSH
7038: FOR_IN
7039: IFFALSE 7175
// begin if GetLives ( i ) > 250 then
7041: LD_VAR 0 1
7045: PPUSH
7046: CALL_OW 256
7050: PUSH
7051: LD_INT 250
7053: GREATER
7054: IFFALSE 7146
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7056: LD_INT 81
7058: PUSH
7059: LD_INT 8
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 91
7068: PUSH
7069: LD_VAR 0 1
7073: PUSH
7074: LD_INT 10
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PPUSH
7086: CALL_OW 69
7090: NOT
7091: IFFALSE 7110
// ComAgressiveMove ( i , 67 , 110 ) else
7093: LD_VAR 0 1
7097: PPUSH
7098: LD_INT 67
7100: PPUSH
7101: LD_INT 110
7103: PPUSH
7104: CALL_OW 114
7108: GO 7144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7110: LD_VAR 0 1
7114: PPUSH
7115: LD_INT 81
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: PPUSH
7130: LD_VAR 0 1
7134: PPUSH
7135: CALL_OW 74
7139: PPUSH
7140: CALL_OW 115
// end else
7144: GO 7173
// if IsDead ( i ) then
7146: LD_VAR 0 1
7150: PPUSH
7151: CALL_OW 301
7155: IFFALSE 7173
// tmp := tmp diff i ;
7157: LD_ADDR_VAR 0 3
7161: PUSH
7162: LD_VAR 0 3
7166: PUSH
7167: LD_VAR 0 1
7171: DIFF
7172: ST_TO_ADDR
// end ;
7173: GO 7038
7175: POP
7176: POP
// until not tmp ;
7177: LD_VAR 0 3
7181: NOT
7182: IFFALSE 7013
// end ; end_of_file
7184: PPOPN 3
7186: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7187: LD_INT 0
7189: PPUSH
7190: PPUSH
7191: PPUSH
7192: PPUSH
7193: PPUSH
7194: PPUSH
7195: PPUSH
7196: PPUSH
7197: PPUSH
// side := 3 ;
7198: LD_ADDR_VAR 0 6
7202: PUSH
7203: LD_INT 3
7205: ST_TO_ADDR
// uc_side := side ;
7206: LD_ADDR_OWVAR 20
7210: PUSH
7211: LD_VAR 0 6
7215: ST_TO_ADDR
// uc_nation := 3 ;
7216: LD_ADDR_OWVAR 21
7220: PUSH
7221: LD_INT 3
7223: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7224: LD_ADDR_VAR 0 2
7228: PUSH
7229: LD_INT 22
7231: PUSH
7232: LD_VAR 0 6
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 21
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 69
7259: PUSH
7260: FOR_IN
7261: IFFALSE 7277
// SetBLevel ( i , 10 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 10
7270: PPUSH
7271: CALL_OW 241
7275: GO 7260
7277: POP
7278: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7279: LD_ADDR_VAR 0 9
7283: PUSH
7284: LD_INT 22
7286: PUSH
7287: LD_VAR 0 6
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 30
7298: PUSH
7299: LD_INT 34
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PPUSH
7310: CALL_OW 69
7314: ST_TO_ADDR
// if teleport then
7315: LD_VAR 0 9
7319: IFFALSE 7340
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7321: LD_VAR 0 9
7325: PUSH
7326: LD_INT 1
7328: ARRAY
7329: PPUSH
7330: LD_INT 123
7332: PPUSH
7333: LD_INT 122
7335: PPUSH
7336: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7340: LD_ADDR_EXP 66
7344: PUSH
7345: LD_STRING Platonov
7347: PPUSH
7348: CALL_OW 25
7352: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7353: LD_ADDR_EXP 67
7357: PUSH
7358: LD_STRING Kovalyuk
7360: PPUSH
7361: CALL_OW 25
7365: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7366: LD_ADDR_EXP 69
7370: PUSH
7371: LD_STRING Yakotich
7373: PPUSH
7374: LD_EXP 1
7378: NOT
7379: PPUSH
7380: LD_STRING 09_
7382: PPUSH
7383: CALL 67510 0 3
7387: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7388: LD_ADDR_EXP 68
7392: PUSH
7393: LD_STRING Bystrov
7395: PPUSH
7396: CALL_OW 25
7400: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7401: LD_ADDR_EXP 70
7405: PUSH
7406: LD_STRING Gleb
7408: PPUSH
7409: CALL_OW 25
7413: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7414: LD_STRING 03_Cornel
7416: PPUSH
7417: CALL_OW 28
7421: IFFALSE 7469
// begin Bierezov := NewCharacter ( Mikhail ) ;
7423: LD_ADDR_EXP 71
7427: PUSH
7428: LD_STRING Mikhail
7430: PPUSH
7431: CALL_OW 25
7435: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7436: LD_EXP 71
7440: PPUSH
7441: LD_INT 197
7443: PPUSH
7444: LD_INT 111
7446: PPUSH
7447: LD_INT 9
7449: PPUSH
7450: LD_INT 0
7452: PPUSH
7453: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7457: LD_EXP 71
7461: PPUSH
7462: LD_INT 3
7464: PPUSH
7465: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7469: LD_EXP 66
7473: PPUSH
7474: LD_INT 126
7476: PPUSH
7477: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7481: LD_EXP 67
7485: PPUSH
7486: LD_INT 134
7488: PPUSH
7489: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7493: LD_EXP 69
7497: PPUSH
7498: LD_INT 197
7500: PPUSH
7501: LD_INT 111
7503: PPUSH
7504: LD_INT 9
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7514: LD_EXP 68
7518: PPUSH
7519: LD_INT 197
7521: PPUSH
7522: LD_INT 111
7524: PPUSH
7525: LD_INT 9
7527: PPUSH
7528: LD_INT 0
7530: PPUSH
7531: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7535: LD_EXP 70
7539: PPUSH
7540: LD_INT 197
7542: PPUSH
7543: LD_INT 111
7545: PPUSH
7546: LD_INT 9
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7556: LD_ADDR_VAR 0 5
7560: PUSH
7561: LD_INT 126
7563: PPUSH
7564: LD_INT 4
7566: PPUSH
7567: LD_STRING zhukov
7569: PPUSH
7570: LD_INT 9
7572: PUSH
7573: LD_INT 10
7575: PUSH
7576: LD_INT 10
7578: PUSH
7579: LD_INT 10
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: PUSH
7588: LD_OWVAR 67
7592: ARRAY
7593: PPUSH
7594: LD_INT 90000
7596: PUSH
7597: LD_INT 1000
7599: PUSH
7600: LD_INT 300
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: LIST
7607: PPUSH
7608: LD_INT 18
7610: PUSH
7611: LD_INT 8
7613: PUSH
7614: LD_INT 13
7616: PUSH
7617: LD_INT 8
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL 75969 0 6
7630: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7631: LD_ADDR_VAR 0 4
7635: PUSH
7636: LD_INT 267
7638: PPUSH
7639: CALL_OW 274
7643: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7644: LD_VAR 0 4
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 5000
7654: PPUSH
7655: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7659: LD_VAR 0 4
7663: PPUSH
7664: LD_INT 2
7666: PPUSH
7667: LD_INT 200
7669: PPUSH
7670: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7674: LD_VAR 0 4
7678: PPUSH
7679: LD_INT 3
7681: PPUSH
7682: LD_INT 200
7684: PPUSH
7685: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7689: LD_ADDR_EXP 100
7693: PUSH
7694: LD_EXP 100
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: LD_VAR 0 5
7706: PUSH
7707: LD_INT 22
7709: PUSH
7710: LD_VAR 0 6
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 3
7721: PUSH
7722: LD_INT 21
7724: PUSH
7725: LD_INT 2
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PPUSH
7740: CALL_OW 69
7744: UNION
7745: PUSH
7746: LD_EXP 66
7750: DIFF
7751: PPUSH
7752: CALL_OW 1
7756: ST_TO_ADDR
// behemoths := [ ] ;
7757: LD_ADDR_EXP 74
7761: PUSH
7762: EMPTY
7763: ST_TO_ADDR
// behemothBuilders := [ ] ;
7764: LD_ADDR_EXP 75
7768: PUSH
7769: EMPTY
7770: ST_TO_ADDR
// if Kovalyuk then
7771: LD_EXP 67
7775: IFFALSE 7797
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7777: LD_ADDR_EXP 75
7781: PUSH
7782: LD_EXP 75
7786: PPUSH
7787: LD_EXP 67
7791: PPUSH
7792: CALL 104959 0 2
7796: ST_TO_ADDR
// j := 3 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_INT 3
7804: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7805: LD_ADDR_VAR 0 2
7809: PUSH
7810: LD_INT 22
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 25
7822: PUSH
7823: LD_INT 3
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: PUSH
7839: LD_EXP 67
7843: DIFF
7844: PUSH
7845: FOR_IN
7846: IFFALSE 7896
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7848: LD_ADDR_EXP 75
7852: PUSH
7853: LD_EXP 75
7857: PPUSH
7858: LD_VAR 0 2
7862: PPUSH
7863: CALL 104959 0 2
7867: ST_TO_ADDR
// j := j - 1 ;
7868: LD_ADDR_VAR 0 3
7872: PUSH
7873: LD_VAR 0 3
7877: PUSH
7878: LD_INT 1
7880: MINUS
7881: ST_TO_ADDR
// if j = 0 then
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 0
7889: EQUAL
7890: IFFALSE 7894
// break ;
7892: GO 7896
// end ;
7894: GO 7845
7896: POP
7897: POP
// end ;
7898: LD_VAR 0 1
7902: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
7909: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7910: LD_ADDR_VAR 0 4
7914: PUSH
7915: LD_INT 209
7917: PUSH
7918: LD_INT 149
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 219
7927: PUSH
7928: LD_INT 154
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 223
7937: PUSH
7938: LD_INT 149
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 232
7947: PUSH
7948: LD_INT 155
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: ST_TO_ADDR
// if not behemothBuilders then
7961: LD_EXP 75
7965: NOT
7966: IFFALSE 7970
// exit ;
7968: GO 8101
// j := 1 ;
7970: LD_ADDR_VAR 0 3
7974: PUSH
7975: LD_INT 1
7977: ST_TO_ADDR
// for i in behemothBuilders do
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: LD_EXP 75
7987: PUSH
7988: FOR_IN
7989: IFFALSE 8099
// begin if GetClass ( i ) <> class_mechanic then
7991: LD_VAR 0 2
7995: PPUSH
7996: CALL_OW 257
8000: PUSH
8001: LD_INT 3
8003: NONEQUAL
8004: IFFALSE 8018
// SetClass ( i , class_mechanic ) ;
8006: LD_VAR 0 2
8010: PPUSH
8011: LD_INT 3
8013: PPUSH
8014: CALL_OW 336
// if IsInUnit ( i ) then
8018: LD_VAR 0 2
8022: PPUSH
8023: CALL_OW 310
8027: IFFALSE 8038
// ComExitBuilding ( i ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_INT 37
8045: PPUSH
8046: LD_VAR 0 4
8050: PUSH
8051: LD_VAR 0 3
8055: ARRAY
8056: PUSH
8057: LD_INT 1
8059: ARRAY
8060: PPUSH
8061: LD_VAR 0 4
8065: PUSH
8066: LD_VAR 0 3
8070: ARRAY
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: LD_INT 0
8078: PPUSH
8079: CALL_OW 230
// j := j + 1 ;
8083: LD_ADDR_VAR 0 3
8087: PUSH
8088: LD_VAR 0 3
8092: PUSH
8093: LD_INT 1
8095: PLUS
8096: ST_TO_ADDR
// end ;
8097: GO 7988
8099: POP
8100: POP
// end ;
8101: LD_VAR 0 1
8105: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8106: LD_INT 24
8108: PPUSH
8109: LD_INT 30
8111: PUSH
8112: LD_INT 37
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 70
8123: IFFALSE 8136
8125: GO 8127
8127: DISABLE
// behemothUnderConstruct := true ;
8128: LD_ADDR_EXP 26
8132: PUSH
8133: LD_INT 1
8135: ST_TO_ADDR
8136: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8137: LD_INT 3
8139: PPUSH
8140: CALL 105020 0 1
8144: PUSH
8145: LD_INT 22
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 30
8157: PUSH
8158: LD_INT 37
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: NOT
8174: AND
8175: IFFALSE 8361
8177: GO 8179
8179: DISABLE
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
// begin enable ;
8184: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8185: LD_ADDR_VAR 0 2
8189: PUSH
8190: LD_INT 3
8192: PPUSH
8193: CALL 105020 0 1
8197: ST_TO_ADDR
// for i in tmp do
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_VAR 0 2
8207: PUSH
8208: FOR_IN
8209: IFFALSE 8359
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 9
8218: PPUSH
8219: CALL_OW 308
8223: PUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 110
8233: PUSH
8234: LD_INT 2
8236: EQUAL
8237: NOT
8238: AND
8239: IFFALSE 8253
// SetTag ( i , 2 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 2
8248: PPUSH
8249: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8253: LD_INT 81
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PUSH
8263: LD_INT 91
8265: PUSH
8266: LD_VAR 0 1
8270: PUSH
8271: LD_INT 12
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: NOT
8288: PUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL_OW 110
8298: PUSH
8299: LD_INT 2
8301: EQUAL
8302: NOT
8303: AND
8304: IFFALSE 8323
// ComAgressiveMove ( i , 64 , 93 ) else
8306: LD_VAR 0 1
8310: PPUSH
8311: LD_INT 64
8313: PPUSH
8314: LD_INT 93
8316: PPUSH
8317: CALL_OW 114
8321: GO 8357
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8323: LD_VAR 0 1
8327: PPUSH
8328: LD_INT 81
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PPUSH
8338: CALL_OW 69
8342: PPUSH
8343: LD_VAR 0 1
8347: PPUSH
8348: CALL_OW 74
8352: PPUSH
8353: CALL_OW 115
// end ;
8357: GO 8208
8359: POP
8360: POP
// end ;
8361: PPOPN 2
8363: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8364: LD_INT 0
8366: PPUSH
8367: PPUSH
8368: PPUSH
// result := [ ] ;
8369: LD_ADDR_VAR 0 2
8373: PUSH
8374: EMPTY
8375: ST_TO_ADDR
// uc_side := 6 ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_INT 6
8383: ST_TO_ADDR
// uc_nation := 3 ;
8384: LD_ADDR_OWVAR 21
8388: PUSH
8389: LD_INT 3
8391: ST_TO_ADDR
// case strength of 1 :
8392: LD_VAR 0 1
8396: PUSH
8397: LD_INT 1
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8547
8405: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 4
8418: PUSH
8419: LD_INT 5
8421: PUSH
8422: LD_INT 6
8424: PUSH
8425: LD_INT 7
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_OWVAR 67
8438: ARRAY
8439: PUSH
8440: FOR_TO
8441: IFFALSE 8543
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8443: LD_INT 22
8445: PUSH
8446: LD_INT 24
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 2
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 44
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 1
8508: PPUSH
8509: LD_INT 3
8511: PPUSH
8512: CALL_OW 12
8516: ARRAY
8517: PPUSH
8518: LD_INT 80
8520: PPUSH
8521: CALL 72525 0 5
// result := result union CreateVehicle ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_VAR 0 2
8534: PUSH
8535: CALL_OW 45
8539: UNION
8540: ST_TO_ADDR
// end ;
8541: GO 8440
8543: POP
8544: POP
// end ; 2 :
8545: GO 9542
8547: LD_INT 2
8549: DOUBLE
8550: EQUAL
8551: IFTRUE 8555
8553: GO 8723
8555: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: DOUBLE
8562: LD_INT 1
8564: DEC
8565: ST_TO_ADDR
8566: LD_INT 5
8568: PUSH
8569: LD_INT 6
8571: PUSH
8572: LD_INT 7
8574: PUSH
8575: LD_INT 8
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_OWVAR 67
8588: ARRAY
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8719
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8593: LD_INT 22
8595: PUSH
8596: LD_INT 24
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: PUSH
8607: LD_VAR 0 3
8611: PUSH
8612: LD_INT 3
8614: MOD
8615: PUSH
8616: LD_INT 1
8618: PLUS
8619: ARRAY
8620: PPUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: LD_INT 1
8633: PPUSH
8634: LD_INT 2
8636: PPUSH
8637: CALL_OW 12
8641: ARRAY
8642: PPUSH
8643: LD_INT 3
8645: PPUSH
8646: LD_INT 43
8648: PUSH
8649: LD_INT 44
8651: PUSH
8652: LD_INT 45
8654: PUSH
8655: LD_INT 44
8657: PUSH
8658: LD_INT 46
8660: PUSH
8661: LD_INT 46
8663: PUSH
8664: LD_INT 49
8666: PUSH
8667: LD_INT 49
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_VAR 0 3
8684: PUSH
8685: LD_INT 8
8687: MOD
8688: PUSH
8689: LD_INT 1
8691: PLUS
8692: ARRAY
8693: PPUSH
8694: LD_INT 80
8696: PPUSH
8697: CALL 72525 0 5
// result := result union CreateVehicle ;
8701: LD_ADDR_VAR 0 2
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: CALL_OW 45
8715: UNION
8716: ST_TO_ADDR
// end ;
8717: GO 8590
8719: POP
8720: POP
// end ; 3 :
8721: GO 9542
8723: LD_INT 3
8725: DOUBLE
8726: EQUAL
8727: IFTRUE 8731
8729: GO 8903
8731: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: DOUBLE
8738: LD_INT 1
8740: DEC
8741: ST_TO_ADDR
8742: LD_INT 6
8744: PUSH
8745: LD_INT 7
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: LD_INT 9
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_OWVAR 67
8764: ARRAY
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8899
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8769: LD_INT 22
8771: PUSH
8772: LD_INT 24
8774: PUSH
8775: LD_INT 24
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: LIST
8782: PUSH
8783: LD_VAR 0 3
8787: PUSH
8788: LD_INT 3
8790: MOD
8791: PUSH
8792: LD_INT 1
8794: PLUS
8795: ARRAY
8796: PPUSH
8797: LD_INT 1
8799: PUSH
8800: LD_INT 3
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 1
8809: PPUSH
8810: LD_INT 2
8812: PPUSH
8813: CALL_OW 12
8817: ARRAY
8818: PPUSH
8819: LD_INT 3
8821: PPUSH
8822: LD_INT 43
8824: PUSH
8825: LD_INT 47
8827: PUSH
8828: LD_INT 45
8830: PUSH
8831: LD_INT 45
8833: PUSH
8834: LD_INT 46
8836: PUSH
8837: LD_INT 46
8839: PUSH
8840: LD_INT 49
8842: PUSH
8843: LD_INT 49
8845: PUSH
8846: LD_INT 49
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_VAR 0 3
8864: PUSH
8865: LD_INT 9
8867: MOD
8868: PUSH
8869: LD_INT 1
8871: PLUS
8872: ARRAY
8873: PPUSH
8874: LD_INT 80
8876: PPUSH
8877: CALL 72525 0 5
// result := result union CreateVehicle ;
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_VAR 0 2
8890: PUSH
8891: CALL_OW 45
8895: UNION
8896: ST_TO_ADDR
// end ;
8897: GO 8766
8899: POP
8900: POP
// end ; 4 :
8901: GO 9542
8903: LD_INT 4
8905: DOUBLE
8906: EQUAL
8907: IFTRUE 8911
8909: GO 9541
8911: POP
// begin uc_nation := 3 ;
8912: LD_ADDR_OWVAR 21
8916: PUSH
8917: LD_INT 3
8919: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8920: LD_ADDR_VAR 0 3
8924: PUSH
8925: DOUBLE
8926: LD_INT 1
8928: DEC
8929: ST_TO_ADDR
8930: LD_INT 6
8932: PUSH
8933: LD_INT 8
8935: PUSH
8936: LD_INT 9
8938: PUSH
8939: LD_INT 10
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: PUSH
8948: LD_OWVAR 67
8952: ARRAY
8953: PUSH
8954: FOR_TO
8955: IFFALSE 9087
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 24
8962: PUSH
8963: LD_INT 24
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_VAR 0 3
8975: PUSH
8976: LD_INT 3
8978: MOD
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ARRAY
8984: PPUSH
8985: LD_INT 1
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: ARRAY
9006: PPUSH
9007: LD_INT 3
9009: PPUSH
9010: LD_INT 45
9012: PUSH
9013: LD_INT 47
9015: PUSH
9016: LD_INT 47
9018: PUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 46
9024: PUSH
9025: LD_INT 46
9027: PUSH
9028: LD_INT 49
9030: PUSH
9031: LD_INT 49
9033: PUSH
9034: LD_INT 49
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: PUSH
9048: LD_VAR 0 3
9052: PUSH
9053: LD_INT 9
9055: MOD
9056: PUSH
9057: LD_INT 1
9059: PLUS
9060: ARRAY
9061: PPUSH
9062: LD_INT 80
9064: PPUSH
9065: CALL 72525 0 5
// result := result union CreateVehicle ;
9069: LD_ADDR_VAR 0 2
9073: PUSH
9074: LD_VAR 0 2
9078: PUSH
9079: CALL_OW 45
9083: UNION
9084: ST_TO_ADDR
// end ;
9085: GO 8954
9087: POP
9088: POP
// if not KappaStatus then
9089: LD_EXP 2
9093: NOT
9094: IFFALSE 9329
// begin uc_nation := 1 ;
9096: LD_ADDR_OWVAR 21
9100: PUSH
9101: LD_INT 1
9103: ST_TO_ADDR
// for i = 1 to 3 do
9104: LD_ADDR_VAR 0 3
9108: PUSH
9109: DOUBLE
9110: LD_INT 1
9112: DEC
9113: ST_TO_ADDR
9114: LD_INT 3
9116: PUSH
9117: FOR_TO
9118: IFFALSE 9254
// begin j := rand ( 0 , 1 ) ;
9120: LD_ADDR_VAR 0 4
9124: PUSH
9125: LD_INT 0
9127: PPUSH
9128: LD_INT 1
9130: PPUSH
9131: CALL_OW 12
9135: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9136: LD_INT 3
9138: PUSH
9139: LD_INT 5
9141: PUSH
9142: LD_INT 5
9144: PUSH
9145: LD_INT 4
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: PUSH
9154: LD_VAR 0 4
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 3
9164: PPUSH
9165: CALL_OW 12
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 3
9196: PPUSH
9197: LD_INT 9
9199: PUSH
9200: LD_INT 7
9202: PUSH
9203: LD_INT 6
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 4
9215: PUSH
9216: LD_INT 1
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: CALL_OW 12
9226: PLUS
9227: ARRAY
9228: PPUSH
9229: LD_INT 85
9231: PPUSH
9232: CALL 72525 0 5
// result := result union CreateVehicle ;
9236: LD_ADDR_VAR 0 2
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: CALL_OW 45
9250: UNION
9251: ST_TO_ADDR
// end ;
9252: GO 9117
9254: POP
9255: POP
// if vsevolodFirstAttack then
9256: LD_EXP 24
9260: IFFALSE 9327
// begin vsevolodFirstAttack := false ;
9262: LD_ADDR_EXP 24
9266: PUSH
9267: LD_INT 0
9269: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9270: LD_INT 5
9272: PPUSH
9273: LD_INT 3
9275: PPUSH
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 100
9284: PPUSH
9285: CALL 72525 0 5
// sewiVeh := CreateVehicle ;
9289: LD_ADDR_EXP 73
9293: PUSH
9294: CALL_OW 45
9298: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9299: LD_EXP 73
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 242
// result := result union sewiVeh ;
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: LD_VAR 0 2
9320: PUSH
9321: LD_EXP 73
9325: UNION
9326: ST_TO_ADDR
// end ; end else
9327: GO 9539
// if vsevolodFirstAttack then
9329: LD_EXP 24
9333: IFFALSE 9539
// begin vsevolodFirstAttack := false ;
9335: LD_ADDR_EXP 24
9339: PUSH
9340: LD_INT 0
9342: ST_TO_ADDR
// uc_nation := 3 ;
9343: LD_ADDR_OWVAR 21
9347: PUSH
9348: LD_INT 3
9350: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9351: LD_ADDR_VAR 0 3
9355: PUSH
9356: DOUBLE
9357: LD_INT 1
9359: DEC
9360: ST_TO_ADDR
9361: LD_INT 2
9363: PUSH
9364: LD_OWVAR 67
9368: PLUS
9369: PUSH
9370: FOR_TO
9371: IFFALSE 9479
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9373: LD_INT 22
9375: PUSH
9376: LD_INT 24
9378: PUSH
9379: LD_INT 24
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: LIST
9386: PUSH
9387: LD_VAR 0 3
9391: PUSH
9392: LD_INT 3
9394: MOD
9395: PUSH
9396: LD_INT 1
9398: PLUS
9399: ARRAY
9400: PPUSH
9401: LD_INT 1
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 1
9413: PPUSH
9414: LD_INT 2
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: PPUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 45
9428: PUSH
9429: LD_INT 47
9431: PUSH
9432: LD_INT 47
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: PUSH
9440: LD_VAR 0 3
9444: PUSH
9445: LD_INT 3
9447: MOD
9448: PUSH
9449: LD_INT 1
9451: PLUS
9452: ARRAY
9453: PPUSH
9454: LD_INT 80
9456: PPUSH
9457: CALL 72525 0 5
// result := result union CreateVehicle ;
9461: LD_ADDR_VAR 0 2
9465: PUSH
9466: LD_VAR 0 2
9470: PUSH
9471: CALL_OW 45
9475: UNION
9476: ST_TO_ADDR
// end ;
9477: GO 9370
9479: POP
9480: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9481: LD_INT 24
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 47
9492: PPUSH
9493: LD_INT 100
9495: PPUSH
9496: CALL 72525 0 5
// sewiVeh := CreateVehicle ;
9500: LD_ADDR_EXP 73
9504: PUSH
9505: CALL_OW 45
9509: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9510: LD_EXP 73
9514: PPUSH
9515: LD_INT 6
9517: NEG
9518: PPUSH
9519: CALL_OW 242
// result := result union sewiVeh ;
9523: LD_ADDR_VAR 0 2
9527: PUSH
9528: LD_VAR 0 2
9532: PUSH
9533: LD_EXP 73
9537: UNION
9538: ST_TO_ADDR
// end ; end ; end ;
9539: GO 9542
9541: POP
// end ;
9542: LD_VAR 0 2
9546: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9547: LD_EXP 16
9551: IFFALSE 10222
9553: GO 9555
9555: DISABLE
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
9562: PPUSH
9563: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9564: LD_ADDR_VAR 0 4
9568: PUSH
9569: LD_INT 11
9571: PUSH
9572: LD_INT 12
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9579: LD_ADDR_VAR 0 3
9583: PUSH
9584: LD_INT 11550
9586: PUSH
9587: LD_INT 10150
9589: PUSH
9590: LD_INT 9800
9592: PUSH
9593: LD_INT 9450
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_OWVAR 67
9606: ARRAY
9607: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9608: LD_ADDR_VAR 0 6
9612: PUSH
9613: LD_INT 70
9615: PUSH
9616: LD_INT 118
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 78
9625: PUSH
9626: LD_INT 31
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: ST_TO_ADDR
// repeat if missionStage = 2 then
9637: LD_EXP 15
9641: PUSH
9642: LD_INT 2
9644: EQUAL
9645: IFFALSE 9656
// wait ( 1 1$30 ) else
9647: LD_INT 3150
9649: PPUSH
9650: CALL_OW 67
9654: GO 9665
// wait ( time ) ;
9656: LD_VAR 0 3
9660: PPUSH
9661: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9665: LD_EXP 15
9669: PUSH
9670: LD_INT 6
9672: EQUAL
9673: PUSH
9674: LD_OWVAR 67
9678: PUSH
9679: LD_INT 2
9681: GREATER
9682: OR
9683: IFFALSE 9711
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9685: LD_INT 51
9687: PPUSH
9688: LD_INT 6
9690: PPUSH
9691: LD_INT 2
9693: PPUSH
9694: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9698: LD_INT 57
9700: PPUSH
9701: LD_INT 6
9703: PPUSH
9704: LD_INT 2
9706: PPUSH
9707: CALL_OW 322
// end ; if missionStage = 8 then
9711: LD_EXP 15
9715: PUSH
9716: LD_INT 8
9718: EQUAL
9719: IFFALSE 9747
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9721: LD_INT 52
9723: PPUSH
9724: LD_INT 6
9726: PPUSH
9727: LD_INT 2
9729: PPUSH
9730: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9734: LD_INT 58
9736: PPUSH
9737: LD_INT 6
9739: PPUSH
9740: LD_INT 2
9742: PPUSH
9743: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9747: LD_EXP 15
9751: PUSH
9752: LD_INT 10
9754: EQUAL
9755: PUSH
9756: LD_OWVAR 67
9760: PUSH
9761: LD_INT 1
9763: GREATER
9764: AND
9765: IFFALSE 9793
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9767: LD_INT 53
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 2
9775: PPUSH
9776: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9780: LD_INT 59
9782: PPUSH
9783: LD_INT 6
9785: PPUSH
9786: LD_INT 2
9788: PPUSH
9789: CALL_OW 322
// end ; if activeAttacks then
9793: LD_EXP 16
9797: IFFALSE 10216
// begin if missionStage = 2 then
9799: LD_EXP 15
9803: PUSH
9804: LD_INT 2
9806: EQUAL
9807: IFFALSE 9817
// strength := 1 ;
9809: LD_ADDR_VAR 0 5
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
// if missionStage > 2 then
9817: LD_EXP 15
9821: PUSH
9822: LD_INT 2
9824: GREATER
9825: IFFALSE 9835
// strength := 2 ;
9827: LD_ADDR_VAR 0 5
9831: PUSH
9832: LD_INT 2
9834: ST_TO_ADDR
// if missionStage > 6 then
9835: LD_EXP 15
9839: PUSH
9840: LD_INT 6
9842: GREATER
9843: IFFALSE 9853
// strength := 3 ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_INT 3
9852: ST_TO_ADDR
// if missionStage > 10 then
9853: LD_EXP 15
9857: PUSH
9858: LD_INT 10
9860: GREATER
9861: IFFALSE 9871
// strength := 4 ;
9863: LD_ADDR_VAR 0 5
9867: PUSH
9868: LD_INT 4
9870: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9871: LD_ADDR_VAR 0 2
9875: PUSH
9876: LD_VAR 0 5
9880: PPUSH
9881: CALL 8364 0 1
9885: ST_TO_ADDR
// for i in tmp do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 2
9895: PUSH
9896: FOR_IN
9897: IFFALSE 10106
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_VAR 0 4
9908: PUSH
9909: LD_INT 1
9911: PPUSH
9912: LD_INT 2
9914: PPUSH
9915: CALL_OW 12
9919: ARRAY
9920: PPUSH
9921: LD_INT 0
9923: PPUSH
9924: CALL_OW 49
// if i = sewiVeh then
9928: LD_VAR 0 1
9932: PUSH
9933: LD_EXP 73
9937: EQUAL
9938: IFFALSE 9975
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9940: LD_ADDR_EXP 72
9944: PUSH
9945: LD_STRING Vsevolod
9947: PPUSH
9948: LD_INT 0
9950: PPUSH
9951: LD_STRING 
9953: PPUSH
9954: CALL 67510 0 3
9958: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9959: LD_EXP 72
9963: PPUSH
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 52
// end else
9973: GO 10056
// if GetControl ( i ) = control_manual then
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 263
9984: PUSH
9985: LD_INT 1
9987: EQUAL
9988: IFFALSE 10056
// begin uc_side := 6 ;
9990: LD_ADDR_OWVAR 20
9994: PUSH
9995: LD_INT 6
9997: ST_TO_ADDR
// uc_nation := 3 ;
9998: LD_ADDR_OWVAR 21
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// hc_gallery :=  ;
10006: LD_ADDR_OWVAR 33
10010: PUSH
10011: LD_STRING 
10013: ST_TO_ADDR
// hc_name :=  ;
10014: LD_ADDR_OWVAR 26
10018: PUSH
10019: LD_STRING 
10021: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10022: LD_INT 0
10024: PPUSH
10025: LD_INT 3
10027: PPUSH
10028: LD_INT 10
10030: PPUSH
10031: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10035: CALL_OW 44
10039: PPUSH
10040: LD_VAR 0 1
10044: PPUSH
10045: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10049: LD_INT 10
10051: PPUSH
10052: CALL_OW 67
// end ; if Prob ( 50 ) then
10056: LD_INT 50
10058: PPUSH
10059: CALL_OW 13
10063: IFFALSE 10082
// ComMoveXY ( i , 111 , 197 ) else
10065: LD_VAR 0 1
10069: PPUSH
10070: LD_INT 111
10072: PPUSH
10073: LD_INT 197
10075: PPUSH
10076: CALL_OW 111
10080: GO 10097
// ComMoveXY ( i , 91 , 165 ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_INT 91
10089: PPUSH
10090: LD_INT 165
10092: PPUSH
10093: CALL_OW 111
// wait ( 0 0$2 ) ;
10097: LD_INT 70
10099: PPUSH
10100: CALL_OW 67
// end ;
10104: GO 9896
10106: POP
10107: POP
// repeat wait ( 0 0$1 ) ;
10108: LD_INT 35
10110: PPUSH
10111: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 50
10127: PUSH
10128: EMPTY
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: PUSH
10136: FOR_IN
10137: IFFALSE 10196
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_INT 108
10146: PUSH
10147: LD_INT 153
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 105
10156: PUSH
10157: LD_INT 149
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 85
10166: PUSH
10167: LD_INT 131
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 64
10176: PUSH
10177: LD_INT 105
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PPUSH
10190: CALL 107563 0 2
10194: GO 10136
10196: POP
10197: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10198: LD_VAR 0 2
10202: PPUSH
10203: LD_INT 50
10205: PUSH
10206: EMPTY
10207: LIST
10208: PPUSH
10209: CALL_OW 72
10213: NOT
10214: IFFALSE 10108
// end ; until russianDestroyed ;
10216: LD_EXP 21
10220: IFFALSE 9637
// end ;
10222: PPOPN 6
10224: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10225: LD_EXP 21
10229: NOT
10230: PUSH
10231: LD_EXP 15
10235: PUSH
10236: LD_INT 6
10238: GREATEREQUAL
10239: AND
10240: PUSH
10241: LD_INT 2
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 62540 0 2
10251: NOT
10252: AND
10253: IFFALSE 11192
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
10261: PPUSH
10262: PPUSH
10263: PPUSH
// begin enable ;
10264: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 30
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: NOT
10294: IFFALSE 10298
// exit ;
10296: GO 11192
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10298: LD_ADDR_VAR 0 4
10302: PUSH
10303: LD_INT 22
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: ST_TO_ADDR
// if Prob ( 40 ) then
10332: LD_INT 40
10334: PPUSH
10335: CALL_OW 13
10339: IFFALSE 10485
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10341: LD_INT 2
10343: PPUSH
10344: LD_INT 22
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 49
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 22
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 49
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 49
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 24
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 46
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 24
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 46
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 3
10442: PUSH
10443: LD_INT 46
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 24
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 3
10460: PUSH
10461: LD_INT 46
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: PPUSH
10479: CALL 61122 0 2
// end else
10483: GO 10627
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10485: LD_INT 2
10487: PPUSH
10488: LD_INT 24
10490: PUSH
10491: LD_INT 3
10493: PUSH
10494: LD_INT 3
10496: PUSH
10497: LD_INT 47
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 24
10508: PUSH
10509: LD_INT 3
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: LD_INT 47
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 24
10526: PUSH
10527: LD_INT 3
10529: PUSH
10530: LD_INT 3
10532: PUSH
10533: LD_INT 47
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: PUSH
10542: LD_INT 24
10544: PUSH
10545: LD_INT 3
10547: PUSH
10548: LD_INT 3
10550: PUSH
10551: LD_INT 46
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 24
10562: PUSH
10563: LD_INT 3
10565: PUSH
10566: LD_INT 3
10568: PUSH
10569: LD_INT 46
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: LD_INT 3
10586: PUSH
10587: LD_INT 46
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 24
10598: PUSH
10599: LD_INT 3
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 46
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL 61122 0 2
// end ; repeat wait ( 0 0$1 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10634: LD_INT 2
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL 62540 0 2
10644: PUSH
10645: LD_INT 7
10647: GREATEREQUAL
10648: IFFALSE 10627
// wait ( 0 0$10 ) ;
10650: LD_INT 350
10652: PPUSH
10653: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10657: LD_ADDR_VAR 0 2
10661: PUSH
10662: LD_INT 2
10664: PPUSH
10665: LD_INT 1
10667: PPUSH
10668: CALL 62540 0 2
10672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10673: LD_ADDR_EXP 119
10677: PUSH
10678: LD_EXP 119
10682: PPUSH
10683: LD_INT 2
10685: PPUSH
10686: LD_EXP 119
10690: PUSH
10691: LD_INT 2
10693: ARRAY
10694: PUSH
10695: LD_VAR 0 2
10699: DIFF
10700: PPUSH
10701: CALL_OW 1
10705: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10706: LD_ADDR_VAR 0 3
10710: PUSH
10711: LD_INT 0
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: CALL_OW 12
10721: ST_TO_ADDR
// if target then
10722: LD_VAR 0 3
10726: IFFALSE 10854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10728: LD_ADDR_VAR 0 2
10732: PUSH
10733: LD_VAR 0 2
10737: PPUSH
10738: LD_INT 24
10740: PUSH
10741: LD_INT 250
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 72
10752: ST_TO_ADDR
// for i in tmp do
10753: LD_ADDR_VAR 0 1
10757: PUSH
10758: LD_VAR 0 2
10762: PUSH
10763: FOR_IN
10764: IFFALSE 10804
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10766: LD_VAR 0 1
10770: PPUSH
10771: LD_INT 139
10773: PPUSH
10774: LD_INT 89
10776: PPUSH
10777: CALL_OW 297
10781: PUSH
10782: LD_INT 9
10784: GREATER
10785: IFFALSE 10802
// ComMoveXY ( i , 139 , 89 ) ;
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 139
10794: PPUSH
10795: LD_INT 89
10797: PPUSH
10798: CALL_OW 111
10802: GO 10763
10804: POP
10805: POP
// wait ( 0 0$1 ) ;
10806: LD_INT 35
10808: PPUSH
10809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10813: LD_VAR 0 2
10817: PPUSH
10818: LD_INT 92
10820: PUSH
10821: LD_INT 139
10823: PUSH
10824: LD_INT 89
10826: PUSH
10827: LD_INT 9
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PPUSH
10836: CALL_OW 72
10840: PUSH
10841: LD_VAR 0 2
10845: PUSH
10846: LD_INT 1
10848: MINUS
10849: GREATEREQUAL
10850: IFFALSE 10728
// end else
10852: GO 10996
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10854: LD_VAR 0 2
10858: PPUSH
10859: LD_VAR 0 4
10863: PUSH
10864: LD_INT 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10872: LD_ADDR_VAR 0 2
10876: PUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: LD_INT 24
10884: PUSH
10885: LD_INT 250
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PPUSH
10892: CALL_OW 72
10896: ST_TO_ADDR
// for i in tmp do
10897: LD_ADDR_VAR 0 1
10901: PUSH
10902: LD_VAR 0 2
10906: PUSH
10907: FOR_IN
10908: IFFALSE 10948
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10910: LD_VAR 0 1
10914: PPUSH
10915: LD_INT 124
10917: PPUSH
10918: LD_INT 139
10920: PPUSH
10921: CALL_OW 297
10925: PUSH
10926: LD_INT 9
10928: GREATER
10929: IFFALSE 10946
// ComMoveXY ( i , 124 , 139 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 124
10938: PPUSH
10939: LD_INT 139
10941: PPUSH
10942: CALL_OW 111
10946: GO 10907
10948: POP
10949: POP
// wait ( 0 0$1 ) ;
10950: LD_INT 35
10952: PPUSH
10953: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_INT 92
10964: PUSH
10965: LD_INT 124
10967: PUSH
10968: LD_INT 139
10970: PUSH
10971: LD_INT 9
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 72
10984: PUSH
10985: LD_VAR 0 2
10989: PUSH
10990: LD_INT 1
10992: MINUS
10993: GREATEREQUAL
10994: IFFALSE 10872
// end ; repeat wait ( 0 0$1 ) ;
10996: LD_INT 35
10998: PPUSH
10999: CALL_OW 67
// for i in tmp do
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_VAR 0 2
11012: PUSH
11013: FOR_IN
11014: IFFALSE 11183
// begin if GetLives ( i ) > 251 then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 256
11025: PUSH
11026: LD_INT 251
11028: GREATER
11029: IFFALSE 11154
// begin if GetWeapon ( i ) = ru_time_lapser then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 264
11040: PUSH
11041: LD_INT 49
11043: EQUAL
11044: IFFALSE 11100
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11046: LD_VAR 0 1
11050: PPUSH
11051: LD_INT 2
11053: PUSH
11054: LD_INT 22
11056: PUSH
11057: LD_INT 1
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 8
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: PPUSH
11084: LD_VAR 0 1
11088: PPUSH
11089: CALL_OW 74
11093: PPUSH
11094: CALL_OW 112
11098: GO 11152
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11100: LD_VAR 0 1
11104: PPUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 22
11110: PUSH
11111: LD_INT 1
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 22
11120: PUSH
11121: LD_INT 8
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: LIST
11132: PPUSH
11133: CALL_OW 69
11137: PPUSH
11138: LD_VAR 0 1
11142: PPUSH
11143: CALL_OW 74
11147: PPUSH
11148: CALL_OW 115
// end else
11152: GO 11181
// if IsDead ( i ) then
11154: LD_VAR 0 1
11158: PPUSH
11159: CALL_OW 301
11163: IFFALSE 11181
// tmp := tmp diff i ;
11165: LD_ADDR_VAR 0 2
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_VAR 0 1
11179: DIFF
11180: ST_TO_ADDR
// end ;
11181: GO 11013
11183: POP
11184: POP
// until not tmp ;
11185: LD_VAR 0 2
11189: NOT
11190: IFFALSE 10996
// end ;
11192: PPOPN 4
11194: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11195: LD_EXP 15
11199: PUSH
11200: LD_INT 8
11202: GREATEREQUAL
11203: PUSH
11204: LD_OWVAR 67
11208: PUSH
11209: LD_INT 1
11211: GREATER
11212: AND
11213: IFFALSE 11397
11215: GO 11217
11217: DISABLE
11218: LD_INT 0
11220: PPUSH
11221: PPUSH
11222: PPUSH
// begin ruMobile := [ ] ;
11223: LD_ADDR_EXP 76
11227: PUSH
11228: EMPTY
11229: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11230: LD_ADDR_VAR 0 1
11234: PUSH
11235: DOUBLE
11236: LD_INT 1
11238: DEC
11239: ST_TO_ADDR
11240: LD_INT 3
11242: PUSH
11243: LD_INT 4
11245: PUSH
11246: LD_INT 5
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: LIST
11253: PUSH
11254: LD_OWVAR 67
11258: PUSH
11259: LD_INT 1
11261: MINUS
11262: ARRAY
11263: PUSH
11264: FOR_TO
11265: IFFALSE 11395
// begin uc_side := 3 ;
11267: LD_ADDR_OWVAR 20
11271: PUSH
11272: LD_INT 3
11274: ST_TO_ADDR
// uc_nation := 3 ;
11275: LD_ADDR_OWVAR 21
11279: PUSH
11280: LD_INT 3
11282: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11283: LD_INT 21
11285: PPUSH
11286: LD_INT 3
11288: PPUSH
11289: LD_INT 1
11291: PPUSH
11292: LD_INT 45
11294: PPUSH
11295: LD_INT 100
11297: PPUSH
11298: CALL 72525 0 5
// veh := CreateVehicle ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: CALL_OW 45
11311: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11312: LD_VAR 0 2
11316: PPUSH
11317: LD_INT 3
11319: PPUSH
11320: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: LD_INT 29
11331: PPUSH
11332: LD_INT 0
11334: PPUSH
11335: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11339: LD_INT 0
11341: PPUSH
11342: LD_INT 10
11344: PPUSH
11345: CALL_OW 383
// un := CreateHuman ;
11349: LD_ADDR_VAR 0 3
11353: PUSH
11354: CALL_OW 44
11358: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11359: LD_VAR 0 3
11363: PPUSH
11364: LD_VAR 0 2
11368: PPUSH
11369: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11373: LD_ADDR_EXP 76
11377: PUSH
11378: LD_EXP 76
11382: PPUSH
11383: LD_VAR 0 2
11387: PPUSH
11388: CALL 104959 0 2
11392: ST_TO_ADDR
// end ;
11393: GO 11264
11395: POP
11396: POP
// end ;
11397: PPOPN 3
11399: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11400: LD_EXP 76
11404: IFFALSE 11912
11406: GO 11408
11408: DISABLE
11409: LD_INT 0
11411: PPUSH
11412: PPUSH
11413: PPUSH
// begin enable ;
11414: ENABLE
// if not ruMobile then
11415: LD_EXP 76
11419: NOT
11420: IFFALSE 11424
// exit ;
11422: GO 11912
// for i in ruMobile do
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_EXP 76
11433: PUSH
11434: FOR_IN
11435: IFFALSE 11910
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11437: LD_VAR 0 1
11441: PPUSH
11442: CALL_OW 302
11446: NOT
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 255
11457: PUSH
11458: LD_INT 3
11460: NONEQUAL
11461: OR
11462: IFFALSE 11482
// begin ruMobile := ruMobile diff i ;
11464: LD_ADDR_EXP 76
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_VAR 0 1
11478: DIFF
11479: ST_TO_ADDR
// continue ;
11480: GO 11434
// end ; if GetTag ( i ) = 300 then
11482: LD_VAR 0 1
11486: PPUSH
11487: CALL_OW 110
11491: PUSH
11492: LD_INT 300
11494: EQUAL
11495: IFFALSE 11545
// begin ComMoveXY ( i , 160 , 81 ) ;
11497: LD_VAR 0 1
11501: PPUSH
11502: LD_INT 160
11504: PPUSH
11505: LD_INT 81
11507: PPUSH
11508: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 160
11519: PPUSH
11520: LD_INT 81
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 8
11530: LESS
11531: IFFALSE 11545
// SetTag ( i , 301 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 301
11540: PPUSH
11541: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 110
11554: PUSH
11555: LD_INT 301
11557: EQUAL
11558: IFFALSE 11601
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11560: LD_VAR 0 1
11564: PPUSH
11565: LD_INT 33
11567: PPUSH
11568: CALL_OW 308
11572: NOT
11573: IFFALSE 11589
// ComMoveToArea ( i , ruMobileParkingArea ) else
11575: LD_VAR 0 1
11579: PPUSH
11580: LD_INT 33
11582: PPUSH
11583: CALL_OW 113
11587: GO 11601
// SetTag ( i , 302 ) ;
11589: LD_VAR 0 1
11593: PPUSH
11594: LD_INT 302
11596: PPUSH
11597: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11601: LD_VAR 0 1
11605: PPUSH
11606: CALL_OW 110
11610: PUSH
11611: LD_INT 302
11613: EQUAL
11614: IFFALSE 11744
// begin if GetLives ( i ) < 1000 then
11616: LD_VAR 0 1
11620: PPUSH
11621: CALL_OW 256
11625: PUSH
11626: LD_INT 1000
11628: LESS
11629: IFFALSE 11721
// begin if not IsDrivenBy ( i ) then
11631: LD_VAR 0 1
11635: PPUSH
11636: CALL_OW 311
11640: NOT
11641: IFFALSE 11645
// continue ;
11643: GO 11434
// mech := IsDrivenBy ( i ) ;
11645: LD_ADDR_VAR 0 2
11649: PUSH
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 311
11659: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11660: LD_VAR 0 2
11664: PPUSH
11665: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_VAR 0 1
11678: PPUSH
11679: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11683: LD_INT 35
11685: PPUSH
11686: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11690: LD_VAR 0 1
11694: PPUSH
11695: CALL_OW 256
11699: PUSH
11700: LD_INT 1000
11702: EQUAL
11703: IFFALSE 11683
// ComEnterUnit ( mech , i ) ;
11705: LD_VAR 0 2
11709: PPUSH
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 120
// end else
11719: GO 11744
// if IsDrivenBy ( i ) then
11721: LD_VAR 0 1
11725: PPUSH
11726: CALL_OW 311
11730: IFFALSE 11744
// SetTag ( i , 0 ) ;
11732: LD_VAR 0 1
11736: PPUSH
11737: LD_INT 0
11739: PPUSH
11740: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 110
11753: PUSH
11754: LD_INT 300
11756: LESS
11757: IFFALSE 11908
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_INT 4
11766: PPUSH
11767: LD_INT 81
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PPUSH
11777: CALL_OW 70
11781: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11782: LD_VAR 0 1
11786: PPUSH
11787: CALL_OW 256
11791: PUSH
11792: LD_INT 650
11794: LESS
11795: IFFALSE 11820
// begin ComStop ( i ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: CALL_OW 141
// SetTag ( i , 300 ) ;
11806: LD_VAR 0 1
11810: PPUSH
11811: LD_INT 300
11813: PPUSH
11814: CALL_OW 109
// continue ;
11818: GO 11434
// end ; if enemy then
11820: LD_VAR 0 3
11824: IFFALSE 11864
// begin if not HasTask ( i ) then
11826: LD_VAR 0 1
11830: PPUSH
11831: CALL_OW 314
11835: NOT
11836: IFFALSE 11862
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11838: LD_VAR 0 1
11842: PPUSH
11843: LD_VAR 0 3
11847: PPUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 74
11857: PPUSH
11858: CALL_OW 115
// end else
11862: GO 11908
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11864: LD_VAR 0 1
11868: PPUSH
11869: LD_INT 158
11871: PUSH
11872: LD_INT 61
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 98
11881: PUSH
11882: LD_INT 100
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 78
11891: PUSH
11892: LD_INT 93
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL 107563 0 2
// end ; end ;
11908: GO 11434
11910: POP
11911: POP
// end ; end_of_file
11912: PPOPN 3
11914: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11915: LD_INT 0
11917: PPUSH
11918: PPUSH
11919: PPUSH
11920: PPUSH
11921: PPUSH
11922: PPUSH
// side := 7 ;
11923: LD_ADDR_VAR 0 5
11927: PUSH
11928: LD_INT 7
11930: ST_TO_ADDR
// uc_side := side ;
11931: LD_ADDR_OWVAR 20
11935: PUSH
11936: LD_VAR 0 5
11940: ST_TO_ADDR
// uc_nation := 1 ;
11941: LD_ADDR_OWVAR 21
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11949: LD_ADDR_VAR 0 2
11953: PUSH
11954: LD_INT 22
11956: PUSH
11957: LD_VAR 0 5
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 21
11968: PUSH
11969: LD_INT 3
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PPUSH
11980: CALL_OW 69
11984: PUSH
11985: FOR_IN
11986: IFFALSE 12002
// SetBLevel ( i , 10 ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 241
12000: GO 11985
12002: POP
12003: POP
// base := GetBase ( al_depot ) ;
12004: LD_ADDR_VAR 0 4
12008: PUSH
12009: LD_INT 2
12011: PPUSH
12012: CALL_OW 274
12016: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12017: LD_ADDR_VAR 0 6
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_VAR 0 5
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 30
12036: PUSH
12037: LD_INT 34
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PPUSH
12048: CALL_OW 69
12052: ST_TO_ADDR
// if teleport then
12053: LD_VAR 0 6
12057: IFFALSE 12078
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12059: LD_VAR 0 6
12063: PUSH
12064: LD_INT 1
12066: ARRAY
12067: PPUSH
12068: LD_INT 262
12070: PPUSH
12071: LD_INT 119
12073: PPUSH
12074: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12078: LD_VAR 0 4
12082: PPUSH
12083: LD_INT 1
12085: PPUSH
12086: LD_INT 19500
12088: PPUSH
12089: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12093: LD_VAR 0 4
12097: PPUSH
12098: LD_INT 2
12100: PPUSH
12101: LD_INT 200
12103: PPUSH
12104: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12108: LD_VAR 0 4
12112: PPUSH
12113: LD_INT 3
12115: PPUSH
12116: LD_INT 650
12118: PPUSH
12119: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12123: LD_ADDR_EXP 77
12127: PUSH
12128: LD_STRING Roth
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12136: LD_ADDR_EXP 78
12140: PUSH
12141: LD_STRING Simms
12143: PPUSH
12144: LD_EXP 1
12148: NOT
12149: PPUSH
12150: LD_STRING 10c_
12152: PPUSH
12153: CALL 67510 0 3
12157: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12158: LD_EXP 78
12162: PPUSH
12163: LD_INT 4
12165: PPUSH
12166: CALL_OW 336
// if not Simms then
12170: LD_EXP 78
12174: NOT
12175: IFFALSE 12205
// begin uc_nation := 1 ;
12177: LD_ADDR_OWVAR 21
12181: PUSH
12182: LD_INT 1
12184: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_INT 10
12190: PPUSH
12191: CALL_OW 384
// Simms := CreateHuman ;
12195: LD_ADDR_EXP 78
12199: PUSH
12200: CALL_OW 44
12204: ST_TO_ADDR
// end ; uc_nation := 3 ;
12205: LD_ADDR_OWVAR 21
12209: PUSH
12210: LD_INT 3
12212: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12213: LD_ADDR_EXP 79
12217: PUSH
12218: LD_STRING Kirilenkova
12220: PPUSH
12221: CALL_OW 25
12225: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12226: LD_ADDR_EXP 93
12230: PUSH
12231: LD_STRING Oblukov
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12239: LD_ADDR_EXP 80
12243: PUSH
12244: LD_STRING Dolgov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12252: LD_ADDR_EXP 81
12256: PUSH
12257: LD_STRING Petrosyan
12259: PPUSH
12260: CALL_OW 25
12264: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12265: LD_ADDR_EXP 92
12269: PUSH
12270: LD_STRING Scholtze
12272: PPUSH
12273: CALL_OW 25
12277: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12278: LD_ADDR_EXP 91
12282: PUSH
12283: LD_STRING Kapitsova
12285: PPUSH
12286: CALL_OW 25
12290: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12291: LD_ADDR_EXP 82
12295: PUSH
12296: LD_STRING Petrovova
12298: PPUSH
12299: CALL_OW 25
12303: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12304: LD_ADDR_EXP 83
12308: PUSH
12309: LD_STRING Kuzmov
12311: PPUSH
12312: CALL_OW 25
12316: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12317: LD_ADDR_EXP 90
12321: PUSH
12322: LD_STRING Karamazov
12324: PPUSH
12325: CALL_OW 25
12329: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12330: LD_STRING 13_Lipshchin_1
12332: PPUSH
12333: LD_INT 0
12335: PPUSH
12336: CALL_OW 30
12340: IFFALSE 12355
// Lipshchin := NewCharacter ( Lipshchin ) ;
12342: LD_ADDR_EXP 84
12346: PUSH
12347: LD_STRING Lipshchin
12349: PPUSH
12350: CALL_OW 25
12354: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12355: LD_STRING 13_Titov_1
12357: PPUSH
12358: LD_INT 0
12360: PPUSH
12361: CALL_OW 30
12365: IFFALSE 12380
// Titov := NewCharacter ( Titov ) ;
12367: LD_ADDR_EXP 86
12371: PUSH
12372: LD_STRING Titov
12374: PPUSH
12375: CALL_OW 25
12379: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12380: LD_STRING 13_Gnyevko_1
12382: PPUSH
12383: LD_INT 0
12385: PPUSH
12386: CALL_OW 30
12390: IFFALSE 12405
// Gnyevko := NewCharacter ( Gnyevko ) ;
12392: LD_ADDR_EXP 85
12396: PUSH
12397: LD_STRING Gnyevko
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12405: LD_STRING 13_Xavier_1
12407: PPUSH
12408: LD_INT 0
12410: PPUSH
12411: CALL_OW 30
12415: IFFALSE 12430
// Xavier := NewCharacter ( Xavier2 ) ;
12417: LD_ADDR_EXP 87
12421: PUSH
12422: LD_STRING Xavier2
12424: PPUSH
12425: CALL_OW 25
12429: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12430: LD_STRING 13_Belkov_1
12432: PPUSH
12433: LD_INT 0
12435: PPUSH
12436: CALL_OW 30
12440: IFFALSE 12455
// Belkov := NewCharacter ( Belkov ) ;
12442: LD_ADDR_EXP 88
12446: PUSH
12447: LD_STRING Belkov
12449: PPUSH
12450: CALL_OW 25
12454: ST_TO_ADDR
// if not BurlakStatus then
12455: LD_EXP 9
12459: NOT
12460: IFFALSE 12475
// Burlak = NewCharacter ( Burlak ) ;
12462: LD_ADDR_EXP 89
12466: PUSH
12467: LD_STRING Burlak
12469: PPUSH
12470: CALL_OW 25
12474: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: LD_EXP 77
12484: PUSH
12485: LD_EXP 79
12489: PUSH
12490: LD_EXP 93
12494: PUSH
12495: LD_EXP 80
12499: PUSH
12500: LD_EXP 81
12504: PUSH
12505: LD_EXP 92
12509: PUSH
12510: LD_EXP 91
12514: PUSH
12515: LD_EXP 82
12519: PUSH
12520: LD_EXP 83
12524: PUSH
12525: LD_EXP 90
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: ST_TO_ADDR
// if Simms then
12542: LD_EXP 78
12546: IFFALSE 12564
// tmp := tmp ^ Simms ;
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_VAR 0 3
12557: PUSH
12558: LD_EXP 78
12562: ADD
12563: ST_TO_ADDR
// if Titov then
12564: LD_EXP 86
12568: IFFALSE 12586
// tmp := tmp ^ Titov ;
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_VAR 0 3
12579: PUSH
12580: LD_EXP 86
12584: ADD
12585: ST_TO_ADDR
// if Lipshchin then
12586: LD_EXP 84
12590: IFFALSE 12608
// tmp := tmp ^ Lipshchin ;
12592: LD_ADDR_VAR 0 3
12596: PUSH
12597: LD_VAR 0 3
12601: PUSH
12602: LD_EXP 84
12606: ADD
12607: ST_TO_ADDR
// if Gnyevko then
12608: LD_EXP 85
12612: IFFALSE 12630
// tmp := tmp ^ Gnyevko ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_EXP 85
12628: ADD
12629: ST_TO_ADDR
// if Xavier then
12630: LD_EXP 87
12634: IFFALSE 12652
// tmp := tmp ^ Xavier ;
12636: LD_ADDR_VAR 0 3
12640: PUSH
12641: LD_VAR 0 3
12645: PUSH
12646: LD_EXP 87
12650: ADD
12651: ST_TO_ADDR
// if Belkov then
12652: LD_EXP 88
12656: IFFALSE 12674
// tmp := tmp ^ Belkov ;
12658: LD_ADDR_VAR 0 3
12662: PUSH
12663: LD_VAR 0 3
12667: PUSH
12668: LD_EXP 88
12672: ADD
12673: ST_TO_ADDR
// if Burlak then
12674: LD_EXP 89
12678: IFFALSE 12696
// tmp := tmp ^ Burlak ;
12680: LD_ADDR_VAR 0 3
12684: PUSH
12685: LD_VAR 0 3
12689: PUSH
12690: LD_EXP 89
12694: ADD
12695: ST_TO_ADDR
// for i = 1 to 11 do
12696: LD_ADDR_VAR 0 2
12700: PUSH
12701: DOUBLE
12702: LD_INT 1
12704: DEC
12705: ST_TO_ADDR
12706: LD_INT 11
12708: PUSH
12709: FOR_TO
12710: IFFALSE 12776
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12712: LD_ADDR_OWVAR 21
12716: PUSH
12717: LD_INT 1
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 1
12729: PPUSH
12730: LD_INT 2
12732: PPUSH
12733: CALL_OW 12
12737: ARRAY
12738: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12739: LD_INT 0
12741: PPUSH
12742: LD_VAR 0 2
12746: PUSH
12747: LD_INT 2
12749: DIV
12750: PPUSH
12751: LD_INT 10
12753: PPUSH
12754: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 3
12767: PUSH
12768: CALL_OW 44
12772: ADD
12773: ST_TO_ADDR
// end ;
12774: GO 12709
12776: POP
12777: POP
// for i in tmp do
12778: LD_ADDR_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: FOR_IN
12789: IFFALSE 12814
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12791: LD_VAR 0 2
12795: PPUSH
12796: LD_INT 260
12798: PPUSH
12799: LD_INT 235
12801: PPUSH
12802: LD_INT 8
12804: PPUSH
12805: LD_INT 0
12807: PPUSH
12808: CALL_OW 50
12812: GO 12788
12814: POP
12815: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12816: LD_ADDR_EXP 100
12820: PUSH
12821: LD_EXP 100
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: LD_INT 22
12831: PUSH
12832: LD_VAR 0 5
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 3
12843: PUSH
12844: LD_INT 21
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: PUSH
12867: LD_EXP 77
12871: PUSH
12872: LD_EXP 78
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: DIFF
12881: PPUSH
12882: CALL_OW 1
12886: ST_TO_ADDR
// uc_side := 0 ;
12887: LD_ADDR_OWVAR 20
12891: PUSH
12892: LD_INT 0
12894: ST_TO_ADDR
// uc_nation := 0 ;
12895: LD_ADDR_OWVAR 21
12899: PUSH
12900: LD_INT 0
12902: ST_TO_ADDR
// for i = 1 to 5 do
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_INT 5
12915: PUSH
12916: FOR_TO
12917: IFFALSE 12954
// begin InitHc ;
12919: CALL_OW 19
// hc_class := class_apeman ;
12923: LD_ADDR_OWVAR 28
12927: PUSH
12928: LD_INT 12
12930: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12931: CALL_OW 44
12935: PPUSH
12936: LD_INT 299
12938: PPUSH
12939: LD_INT 229
12941: PPUSH
12942: LD_INT 10
12944: PPUSH
12945: LD_INT 0
12947: PPUSH
12948: CALL_OW 50
// end ;
12952: GO 12916
12954: POP
12955: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12956: LD_EXP 77
12960: PPUSH
12961: LD_INT 259
12963: PPUSH
12964: LD_INT 235
12966: PPUSH
12967: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12971: LD_EXP 77
12975: PPUSH
12976: LD_INT 262
12978: PPUSH
12979: LD_INT 235
12981: PPUSH
12982: CALL_OW 178
// if Simms then
12986: LD_EXP 78
12990: IFFALSE 13021
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12992: LD_EXP 78
12996: PPUSH
12997: LD_INT 262
12999: PPUSH
13000: LD_INT 235
13002: PPUSH
13003: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13007: LD_EXP 78
13011: PPUSH
13012: LD_EXP 77
13016: PPUSH
13017: CALL_OW 179
// end ; end ;
13021: LD_VAR 0 1
13025: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13026: LD_EXP 31
13030: PUSH
13031: LD_EXP 23
13035: NOT
13036: AND
13037: IFFALSE 13265
13039: GO 13041
13041: DISABLE
13042: LD_INT 0
13044: PPUSH
13045: PPUSH
13046: PPUSH
// begin enable ;
13047: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13048: LD_ADDR_VAR 0 2
13052: PUSH
13053: LD_INT 81
13055: PUSH
13056: LD_INT 7
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 2
13065: PUSH
13066: LD_INT 32
13068: PUSH
13069: LD_INT 3
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 30
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PUSH
13086: LD_INT 30
13088: PUSH
13089: LD_INT 28
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 34
13098: PUSH
13099: LD_INT 49
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PUSH
13106: LD_INT 34
13108: PUSH
13109: LD_INT 10
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PUSH
13116: LD_INT 34
13118: PUSH
13119: LD_INT 8
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if not tmp then
13144: LD_VAR 0 2
13148: NOT
13149: IFFALSE 13153
// exit ;
13151: GO 13265
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 34
13160: PUSH
13161: LD_INT 8
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: IFFALSE 13205
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 2
13183: PPUSH
13184: LD_INT 34
13186: PUSH
13187: LD_INT 8
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 72
13198: PUSH
13199: LD_INT 1
13201: ARRAY
13202: ST_TO_ADDR
13203: GO 13229
// target := tmp [ rand ( 1 , tmp ) ] ;
13205: LD_ADDR_VAR 0 3
13209: PUSH
13210: LD_VAR 0 2
13214: PUSH
13215: LD_INT 1
13217: PPUSH
13218: LD_VAR 0 2
13222: PPUSH
13223: CALL_OW 12
13227: ARRAY
13228: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13229: LD_VAR 0 3
13233: PPUSH
13234: CALL_OW 255
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13253
// CenterNowOnUnits ( target ) ;
13244: LD_VAR 0 3
13248: PPUSH
13249: CALL_OW 87
// SetLives ( target , 0 ) ;
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_INT 0
13260: PPUSH
13261: CALL_OW 234
// end ;
13265: PPOPN 3
13267: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13268: LD_EXP 23
13272: NOT
13273: PUSH
13274: LD_EXP 31
13278: AND
13279: IFFALSE 13805
13281: GO 13283
13283: DISABLE
13284: LD_INT 0
13286: PPUSH
13287: PPUSH
13288: PPUSH
// begin uc_side := 7 ;
13289: LD_ADDR_OWVAR 20
13293: PUSH
13294: LD_INT 7
13296: ST_TO_ADDR
// uc_nation := 1 ;
13297: LD_ADDR_OWVAR 21
13301: PUSH
13302: LD_INT 1
13304: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13305: LD_ADDR_VAR 0 3
13309: PUSH
13310: LD_INT 125
13312: PUSH
13313: LD_INT 163
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PUSH
13320: LD_INT 185
13322: PUSH
13323: LD_INT 168
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PUSH
13330: LD_INT 111
13332: PUSH
13333: LD_INT 97
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: PPUSH
13345: CALL 105064 0 1
13349: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13350: LD_ADDR_EXP 94
13354: PUSH
13355: EMPTY
13356: ST_TO_ADDR
// for i = 1 to Difficulty do
13357: LD_ADDR_VAR 0 1
13361: PUSH
13362: DOUBLE
13363: LD_INT 1
13365: DEC
13366: ST_TO_ADDR
13367: LD_OWVAR 67
13371: PUSH
13372: FOR_TO
13373: IFFALSE 13531
// begin InitHc ;
13375: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13379: LD_INT 0
13381: PPUSH
13382: LD_INT 8
13384: PPUSH
13385: CALL_OW 381
// un := CreateHuman ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: CALL_OW 44
13398: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13399: LD_VAR 0 2
13403: PPUSH
13404: LD_INT 258
13406: PPUSH
13407: LD_INT 267
13409: PPUSH
13410: LD_INT 4
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13420: LD_ADDR_EXP 94
13424: PUSH
13425: LD_EXP 94
13429: PUSH
13430: LD_VAR 0 2
13434: UNION
13435: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13436: LD_VAR 0 2
13440: PPUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 1
13450: ARRAY
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: PPUSH
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: ARRAY
13466: PUSH
13467: LD_INT 2
13469: ARRAY
13470: PPUSH
13471: LD_INT 4
13473: PPUSH
13474: LD_INT 1
13476: PPUSH
13477: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_VAR 0 3
13490: PUSH
13491: LD_VAR 0 1
13495: ARRAY
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_VAR 0 3
13505: PUSH
13506: LD_VAR 0 1
13510: ARRAY
13511: PUSH
13512: LD_INT 2
13514: ARRAY
13515: PPUSH
13516: CALL_OW 171
// AddComInvisible ( un ) ;
13520: LD_VAR 0 2
13524: PPUSH
13525: CALL_OW 212
// end ;
13529: GO 13372
13531: POP
13532: POP
// repeat wait ( 0 0$20 ) ;
13533: LD_INT 700
13535: PPUSH
13536: CALL_OW 67
// for i in allianceSpecialForce do
13540: LD_ADDR_VAR 0 1
13544: PUSH
13545: LD_EXP 94
13549: PUSH
13550: FOR_IN
13551: IFFALSE 13790
// begin if IsInvisible ( i ) then
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 571
13562: IFFALSE 13759
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 22
13571: PUSH
13572: LD_INT 1
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 50
13581: PUSH
13582: EMPTY
13583: LIST
13584: PUSH
13585: LD_INT 56
13587: PUSH
13588: EMPTY
13589: LIST
13590: PUSH
13591: LD_INT 91
13593: PUSH
13594: LD_VAR 0 1
13598: PUSH
13599: LD_INT 25
13601: PUSH
13602: LD_INT 30
13604: PUSH
13605: LD_INT 35
13607: PUSH
13608: LD_INT 40
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: PUSH
13617: LD_OWVAR 67
13621: ARRAY
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 2
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 3
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 25
13663: PUSH
13664: LD_INT 4
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: LD_INT 25
13673: PUSH
13674: LD_INT 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 25
13683: PUSH
13684: LD_INT 8
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: ST_TO_ADDR
// if not tmp then
13712: LD_VAR 0 3
13716: NOT
13717: IFFALSE 13721
// continue ;
13719: GO 13550
// if Prob ( 30 * Difficulty ) then
13721: LD_INT 30
13723: PUSH
13724: LD_OWVAR 67
13728: MUL
13729: PPUSH
13730: CALL_OW 13
13734: IFFALSE 13759
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13736: LD_VAR 0 3
13740: PUSH
13741: LD_INT 1
13743: PPUSH
13744: LD_VAR 0 3
13748: PPUSH
13749: CALL_OW 12
13753: ARRAY
13754: PPUSH
13755: CALL 32858 0 1
// end ; if IsDead ( i ) then
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 301
13768: IFFALSE 13788
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13770: LD_ADDR_EXP 94
13774: PUSH
13775: LD_EXP 94
13779: PUSH
13780: LD_VAR 0 1
13784: DIFF
13785: ST_TO_ADDR
// continue ;
13786: GO 13550
// end ; end ;
13788: GO 13550
13790: POP
13791: POP
// until allianceDestroyed or not allianceSpecialForce ;
13792: LD_EXP 23
13796: PUSH
13797: LD_EXP 94
13801: NOT
13802: OR
13803: IFFALSE 13533
// end ;
13805: PPOPN 3
13807: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13808: LD_EXP 23
13812: NOT
13813: PUSH
13814: LD_EXP 31
13818: AND
13819: IFFALSE 14769
13821: GO 13823
13823: DISABLE
13824: LD_INT 0
13826: PPUSH
13827: PPUSH
13828: PPUSH
13829: PPUSH
// begin enable ;
13830: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13831: LD_INT 22
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 3
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PPUSH
13855: CALL_OW 69
13859: NOT
13860: IFFALSE 13864
// exit ;
13862: GO 14769
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13864: LD_ADDR_VAR 0 4
13868: PUSH
13869: LD_INT 22
13871: PUSH
13872: LD_INT 7
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: PUSH
13879: LD_INT 30
13881: PUSH
13882: LD_INT 34
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PPUSH
13893: CALL_OW 69
13897: ST_TO_ADDR
// if Prob ( 40 ) then
13898: LD_INT 40
13900: PPUSH
13901: CALL_OW 13
13905: IFFALSE 14051
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13907: LD_INT 1
13909: PPUSH
13910: LD_INT 5
13912: PUSH
13913: LD_INT 3
13915: PUSH
13916: LD_INT 2
13918: PUSH
13919: LD_INT 6
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 5
13930: PUSH
13931: LD_INT 3
13933: PUSH
13934: LD_INT 2
13936: PUSH
13937: LD_INT 6
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 5
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 6
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 5
13966: PUSH
13967: LD_INT 3
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 9
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: PUSH
13982: LD_INT 24
13984: PUSH
13985: LD_INT 3
13987: PUSH
13988: LD_INT 3
13990: PUSH
13991: LD_INT 45
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 24
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: LD_INT 3
14008: PUSH
14009: LD_INT 47
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 24
14020: PUSH
14021: LD_INT 3
14023: PUSH
14024: LD_INT 3
14026: PUSH
14027: LD_INT 45
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: PPUSH
14045: CALL 61122 0 2
// end else
14049: GO 14193
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14051: LD_INT 1
14053: PPUSH
14054: LD_INT 24
14056: PUSH
14057: LD_INT 3
14059: PUSH
14060: LD_INT 3
14062: PUSH
14063: LD_INT 47
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: PUSH
14072: LD_INT 24
14074: PUSH
14075: LD_INT 3
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: LD_INT 47
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 5
14092: PUSH
14093: LD_INT 3
14095: PUSH
14096: LD_INT 2
14098: PUSH
14099: LD_INT 9
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 5
14110: PUSH
14111: LD_INT 3
14113: PUSH
14114: LD_INT 2
14116: PUSH
14117: LD_INT 9
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PUSH
14126: LD_INT 5
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 2
14134: PUSH
14135: LD_INT 9
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: LD_INT 1
14149: PUSH
14150: LD_INT 3
14152: PUSH
14153: LD_INT 45
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 24
14164: PUSH
14165: LD_INT 1
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: LD_INT 45
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL 61122 0 2
// end ; repeat wait ( 0 0$1 ) ;
14193: LD_INT 35
14195: PPUSH
14196: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14200: LD_INT 1
14202: PPUSH
14203: LD_INT 1
14205: PPUSH
14206: CALL 62540 0 2
14210: PUSH
14211: LD_INT 7
14213: GREATEREQUAL
14214: IFFALSE 14193
// wait ( 0 0$10 ) ;
14216: LD_INT 350
14218: PPUSH
14219: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 1
14233: PPUSH
14234: CALL 62540 0 2
14238: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14239: LD_ADDR_EXP 119
14243: PUSH
14244: LD_EXP 119
14248: PPUSH
14249: LD_INT 1
14251: PPUSH
14252: LD_EXP 119
14256: PUSH
14257: LD_INT 1
14259: ARRAY
14260: PUSH
14261: LD_VAR 0 2
14265: DIFF
14266: PPUSH
14267: CALL_OW 1
14271: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_INT 0
14279: PPUSH
14280: LD_INT 1
14282: PPUSH
14283: CALL_OW 12
14287: ST_TO_ADDR
// if target then
14288: LD_VAR 0 3
14292: IFFALSE 14458
// begin for i in tmp do
14294: LD_ADDR_VAR 0 1
14298: PUSH
14299: LD_VAR 0 2
14303: PUSH
14304: FOR_IN
14305: IFFALSE 14330
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14307: LD_VAR 0 1
14311: PPUSH
14312: LD_INT 179
14314: PPUSH
14315: LD_INT 209
14317: PPUSH
14318: LD_INT 8
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: CALL_OW 483
14328: GO 14304
14330: POP
14331: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14332: LD_ADDR_VAR 0 2
14336: PUSH
14337: LD_VAR 0 2
14341: PPUSH
14342: LD_INT 24
14344: PUSH
14345: LD_INT 250
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 72
14356: ST_TO_ADDR
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14408
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14370: LD_VAR 0 1
14374: PPUSH
14375: LD_INT 179
14377: PPUSH
14378: LD_INT 209
14380: PPUSH
14381: CALL_OW 297
14385: PUSH
14386: LD_INT 9
14388: GREATER
14389: IFFALSE 14406
// ComMoveXY ( i , 179 , 209 ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_INT 179
14398: PPUSH
14399: LD_INT 209
14401: PPUSH
14402: CALL_OW 111
14406: GO 14367
14408: POP
14409: POP
// wait ( 0 0$1 ) ;
14410: LD_INT 35
14412: PPUSH
14413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14417: LD_VAR 0 2
14421: PPUSH
14422: LD_INT 92
14424: PUSH
14425: LD_INT 179
14427: PUSH
14428: LD_INT 209
14430: PUSH
14431: LD_INT 9
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 72
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_INT 1
14452: MINUS
14453: GREATEREQUAL
14454: IFFALSE 14332
// end else
14456: GO 14620
// begin for i in tmp do
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: LD_VAR 0 2
14467: PUSH
14468: FOR_IN
14469: IFFALSE 14494
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 285
14478: PPUSH
14479: LD_INT 163
14481: PPUSH
14482: LD_INT 8
14484: PPUSH
14485: LD_INT 1
14487: PPUSH
14488: CALL_OW 483
14492: GO 14468
14494: POP
14495: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_VAR 0 2
14505: PPUSH
14506: LD_INT 24
14508: PUSH
14509: LD_INT 250
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: ST_TO_ADDR
// for i in tmp do
14521: LD_ADDR_VAR 0 1
14525: PUSH
14526: LD_VAR 0 2
14530: PUSH
14531: FOR_IN
14532: IFFALSE 14572
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14534: LD_VAR 0 1
14538: PPUSH
14539: LD_INT 285
14541: PPUSH
14542: LD_INT 163
14544: PPUSH
14545: CALL_OW 297
14549: PUSH
14550: LD_INT 9
14552: GREATER
14553: IFFALSE 14570
// ComMoveXY ( i , 285 , 163 ) ;
14555: LD_VAR 0 1
14559: PPUSH
14560: LD_INT 285
14562: PPUSH
14563: LD_INT 163
14565: PPUSH
14566: CALL_OW 111
14570: GO 14531
14572: POP
14573: POP
// wait ( 0 0$1 ) ;
14574: LD_INT 35
14576: PPUSH
14577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14581: LD_VAR 0 2
14585: PPUSH
14586: LD_INT 92
14588: PUSH
14589: LD_INT 285
14591: PUSH
14592: LD_INT 163
14594: PUSH
14595: LD_INT 9
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: PPUSH
14604: CALL_OW 72
14608: PUSH
14609: LD_VAR 0 2
14613: PUSH
14614: LD_INT 1
14616: MINUS
14617: GREATEREQUAL
14618: IFFALSE 14496
// end ; repeat wait ( 0 0$1 ) ;
14620: LD_INT 35
14622: PPUSH
14623: CALL_OW 67
// for i in tmp do
14627: LD_ADDR_VAR 0 1
14631: PUSH
14632: LD_VAR 0 2
14636: PUSH
14637: FOR_IN
14638: IFFALSE 14760
// if GetLives ( i ) > 251 then
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 256
14649: PUSH
14650: LD_INT 251
14652: GREATER
14653: IFFALSE 14742
// begin if GetWeapon ( i ) = ru_time_lapser then
14655: LD_VAR 0 1
14659: PPUSH
14660: CALL_OW 264
14664: PUSH
14665: LD_INT 49
14667: EQUAL
14668: IFFALSE 14706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 81
14677: PUSH
14678: LD_INT 7
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: PPUSH
14690: LD_VAR 0 1
14694: PPUSH
14695: CALL_OW 74
14699: PPUSH
14700: CALL_OW 112
14704: GO 14740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14706: LD_VAR 0 1
14710: PPUSH
14711: LD_INT 81
14713: PUSH
14714: LD_INT 7
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PPUSH
14721: CALL_OW 69
14725: PPUSH
14726: LD_VAR 0 1
14730: PPUSH
14731: CALL_OW 74
14735: PPUSH
14736: CALL_OW 115
// end else
14740: GO 14758
// tmp := tmp diff i ;
14742: LD_ADDR_VAR 0 2
14746: PUSH
14747: LD_VAR 0 2
14751: PUSH
14752: LD_VAR 0 1
14756: DIFF
14757: ST_TO_ADDR
14758: GO 14637
14760: POP
14761: POP
// until not tmp ;
14762: LD_VAR 0 2
14766: NOT
14767: IFFALSE 14620
// end ; end_of_file
14769: PPOPN 4
14771: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
// missionStage := 13 ;
14778: LD_ADDR_EXP 15
14782: PUSH
14783: LD_INT 13
14785: ST_TO_ADDR
// uc_side := 2 ;
14786: LD_ADDR_OWVAR 20
14790: PUSH
14791: LD_INT 2
14793: ST_TO_ADDR
// uc_nation := 2 ;
14794: LD_ADDR_OWVAR 21
14798: PUSH
14799: LD_INT 2
14801: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14802: LD_ADDR_EXP 95
14806: PUSH
14807: LD_STRING Omar
14809: PPUSH
14810: CALL_OW 25
14814: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14815: LD_EXP 95
14819: PPUSH
14820: LD_INT 4
14822: PPUSH
14823: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14827: LD_EXP 95
14831: PPUSH
14832: LD_INT 242
14834: PPUSH
14835: LD_INT 75
14837: PPUSH
14838: LD_INT 0
14840: PPUSH
14841: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14845: LD_ADDR_EXP 96
14849: PUSH
14850: LD_STRING Heike
14852: PPUSH
14853: CALL_OW 25
14857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14858: LD_INT 14
14860: PPUSH
14861: LD_INT 3
14863: PPUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 27
14869: PPUSH
14870: LD_INT 100
14872: PPUSH
14873: CALL 72525 0 5
// veh := CreateVehicle ;
14877: LD_ADDR_VAR 0 3
14881: PUSH
14882: CALL_OW 45
14886: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14887: LD_VAR 0 3
14891: PPUSH
14892: LD_INT 2
14894: NEG
14895: PPUSH
14896: CALL_OW 242
// SetDir ( veh , 4 ) ;
14900: LD_VAR 0 3
14904: PPUSH
14905: LD_INT 4
14907: PPUSH
14908: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14912: LD_VAR 0 3
14916: PPUSH
14917: LD_INT 241
14919: PPUSH
14920: LD_INT 72
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14930: LD_EXP 96
14934: PPUSH
14935: LD_VAR 0 3
14939: PPUSH
14940: CALL_OW 52
// if KhatamStatus then
14944: LD_EXP 8
14948: IFFALSE 15011
// begin Khatam := NewCharacter ( Khatam ) ;
14950: LD_ADDR_EXP 97
14954: PUSH
14955: LD_STRING Khatam
14957: PPUSH
14958: CALL_OW 25
14962: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14963: LD_EXP 97
14967: PPUSH
14968: LD_INT 245
14970: PPUSH
14971: LD_INT 78
14973: PPUSH
14974: LD_INT 3
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14984: LD_EXP 97
14988: PPUSH
14989: LD_INT 4
14991: PPUSH
14992: LD_INT 10
14994: PPUSH
14995: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14999: LD_EXP 97
15003: PPUSH
15004: LD_INT 4
15006: PPUSH
15007: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: DOUBLE
15017: LD_INT 1
15019: DEC
15020: ST_TO_ADDR
15021: LD_INT 2
15023: PUSH
15024: LD_INT 2
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: LD_INT 3
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: PUSH
15039: LD_OWVAR 67
15043: ARRAY
15044: PUSH
15045: FOR_TO
15046: IFFALSE 15112
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15048: LD_INT 0
15050: PPUSH
15051: LD_INT 6
15053: PUSH
15054: LD_OWVAR 67
15058: PLUS
15059: PPUSH
15060: CALL_OW 384
// un := CreateHuman ;
15064: LD_ADDR_VAR 0 4
15068: PUSH
15069: CALL_OW 44
15073: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_INT 28
15081: PUSH
15082: LD_INT 29
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_VAR 0 2
15093: PUSH
15094: LD_INT 2
15096: MOD
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: ARRAY
15102: PPUSH
15103: LD_INT 0
15105: PPUSH
15106: CALL_OW 49
// end ;
15110: GO 15045
15112: POP
15113: POP
// for i = 1 to 6 do
15114: LD_ADDR_VAR 0 2
15118: PUSH
15119: DOUBLE
15120: LD_INT 1
15122: DEC
15123: ST_TO_ADDR
15124: LD_INT 6
15126: PUSH
15127: FOR_TO
15128: IFFALSE 15173
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15130: LD_INT 0
15132: PPUSH
15133: LD_INT 6
15135: PUSH
15136: LD_OWVAR 67
15140: PLUS
15141: PPUSH
15142: CALL_OW 381
// un := CreateHuman ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: CALL_OW 44
15155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15156: LD_VAR 0 4
15160: PPUSH
15161: LD_INT 32
15163: PPUSH
15164: LD_INT 0
15166: PPUSH
15167: CALL_OW 49
// end ;
15171: GO 15127
15173: POP
15174: POP
// for i = 1 to 3 do
15175: LD_ADDR_VAR 0 2
15179: PUSH
15180: DOUBLE
15181: LD_INT 1
15183: DEC
15184: ST_TO_ADDR
15185: LD_INT 3
15187: PUSH
15188: FOR_TO
15189: IFFALSE 15237
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15191: LD_INT 0
15193: PPUSH
15194: LD_INT 8
15196: PPUSH
15197: LD_INT 6
15199: PUSH
15200: LD_OWVAR 67
15204: PLUS
15205: PPUSH
15206: CALL_OW 380
// un := CreateHuman ;
15210: LD_ADDR_VAR 0 4
15214: PUSH
15215: CALL_OW 44
15219: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15220: LD_VAR 0 4
15224: PPUSH
15225: LD_INT 32
15227: PPUSH
15228: LD_INT 0
15230: PPUSH
15231: CALL_OW 49
// end ;
15235: GO 15188
15237: POP
15238: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15239: LD_ADDR_VAR 0 2
15243: PUSH
15244: DOUBLE
15245: LD_INT 1
15247: DEC
15248: ST_TO_ADDR
15249: LD_INT 2
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: LD_INT 4
15257: PUSH
15258: LD_INT 4
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: PUSH
15267: LD_OWVAR 67
15271: ARRAY
15272: PUSH
15273: FOR_TO
15274: IFFALSE 15364
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15276: LD_INT 14
15278: PPUSH
15279: LD_INT 2
15281: PPUSH
15282: LD_INT 1
15284: PPUSH
15285: LD_INT 28
15287: PPUSH
15288: LD_INT 80
15290: PPUSH
15291: CALL 72525 0 5
// veh := CreateVehicle ;
15295: LD_ADDR_VAR 0 3
15299: PUSH
15300: CALL_OW 45
15304: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15305: LD_VAR 0 3
15309: PPUSH
15310: LD_INT 3
15312: PPUSH
15313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15317: LD_VAR 0 3
15321: PPUSH
15322: LD_INT 29
15324: PPUSH
15325: LD_INT 0
15327: PPUSH
15328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15332: LD_INT 0
15334: PPUSH
15335: LD_INT 6
15337: PUSH
15338: LD_OWVAR 67
15342: PLUS
15343: PPUSH
15344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15348: CALL_OW 44
15352: PPUSH
15353: LD_VAR 0 3
15357: PPUSH
15358: CALL_OW 52
// end ;
15362: GO 15273
15364: POP
15365: POP
// for i = 1 to 5 + Difficulty do
15366: LD_ADDR_VAR 0 2
15370: PUSH
15371: DOUBLE
15372: LD_INT 1
15374: DEC
15375: ST_TO_ADDR
15376: LD_INT 5
15378: PUSH
15379: LD_OWVAR 67
15383: PLUS
15384: PUSH
15385: FOR_TO
15386: IFFALSE 15513
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15388: LD_INT 14
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 3
15396: PPUSH
15397: CALL_OW 12
15401: PPUSH
15402: LD_INT 1
15404: PPUSH
15405: LD_INT 28
15407: PUSH
15408: LD_INT 26
15410: PUSH
15411: LD_INT 27
15413: PUSH
15414: LD_INT 25
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: LIST
15421: LIST
15422: PUSH
15423: LD_VAR 0 2
15427: PUSH
15428: LD_INT 4
15430: MOD
15431: PUSH
15432: LD_INT 1
15434: PLUS
15435: ARRAY
15436: PPUSH
15437: LD_INT 80
15439: PPUSH
15440: CALL 72525 0 5
// veh := CreateVehicle ;
15444: LD_ADDR_VAR 0 3
15448: PUSH
15449: CALL_OW 45
15453: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15454: LD_VAR 0 3
15458: PPUSH
15459: LD_INT 4
15461: PPUSH
15462: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15466: LD_VAR 0 3
15470: PPUSH
15471: LD_INT 28
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15481: LD_INT 0
15483: PPUSH
15484: LD_INT 6
15486: PUSH
15487: LD_OWVAR 67
15491: PLUS
15492: PPUSH
15493: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15497: CALL_OW 44
15501: PPUSH
15502: LD_VAR 0 3
15506: PPUSH
15507: CALL_OW 52
// end ;
15511: GO 15385
15513: POP
15514: POP
// for i = 1 to Difficulty do
15515: LD_ADDR_VAR 0 2
15519: PUSH
15520: DOUBLE
15521: LD_INT 1
15523: DEC
15524: ST_TO_ADDR
15525: LD_OWVAR 67
15529: PUSH
15530: FOR_TO
15531: IFFALSE 15591
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15533: LD_INT 14
15535: PPUSH
15536: LD_INT 3
15538: PPUSH
15539: LD_INT 5
15541: PPUSH
15542: LD_INT 29
15544: PPUSH
15545: LD_INT 80
15547: PPUSH
15548: CALL 72525 0 5
// veh := CreateVehicle ;
15552: LD_ADDR_VAR 0 3
15556: PUSH
15557: CALL_OW 45
15561: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15562: LD_VAR 0 3
15566: PPUSH
15567: LD_INT 4
15569: PPUSH
15570: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15574: LD_VAR 0 3
15578: PPUSH
15579: LD_INT 28
15581: PPUSH
15582: LD_INT 0
15584: PPUSH
15585: CALL_OW 49
// end ;
15589: GO 15530
15591: POP
15592: POP
// end ;
15593: LD_VAR 0 1
15597: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15598: LD_INT 22
15600: PUSH
15601: LD_INT 2
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PPUSH
15608: CALL_OW 69
15612: IFFALSE 15991
15614: GO 15616
15616: DISABLE
15617: LD_INT 0
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15623: LD_ADDR_VAR 0 3
15627: PUSH
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 25
15640: PUSH
15641: LD_INT 4
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: PUSH
15657: LD_EXP 97
15661: DIFF
15662: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15663: LD_ADDR_VAR 0 2
15667: PUSH
15668: LD_INT 22
15670: PUSH
15671: LD_INT 2
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PPUSH
15678: CALL_OW 69
15682: PUSH
15683: LD_EXP 97
15687: PUSH
15688: LD_VAR 0 3
15692: UNION
15693: DIFF
15694: ST_TO_ADDR
// if Khatam then
15695: LD_EXP 97
15699: IFFALSE 15716
// ComMoveXY ( Khatam , 211 , 92 ) ;
15701: LD_EXP 97
15705: PPUSH
15706: LD_INT 211
15708: PPUSH
15709: LD_INT 92
15711: PPUSH
15712: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15716: LD_INT 197
15718: PPUSH
15719: LD_INT 80
15721: PPUSH
15722: LD_INT 2
15724: PPUSH
15725: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15729: LD_INT 213
15731: PPUSH
15732: LD_INT 90
15734: PPUSH
15735: LD_INT 2
15737: PPUSH
15738: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15742: LD_INT 215
15744: PPUSH
15745: LD_INT 129
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: CALL_OW 441
// if sci then
15755: LD_VAR 0 3
15759: IFFALSE 15780
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15761: LD_VAR 0 3
15765: PUSH
15766: LD_INT 1
15768: ARRAY
15769: PPUSH
15770: LD_INT 197
15772: PPUSH
15773: LD_INT 80
15775: PPUSH
15776: CALL_OW 158
// if sci > 1 then
15780: LD_VAR 0 3
15784: PUSH
15785: LD_INT 1
15787: GREATER
15788: IFFALSE 15809
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15790: LD_VAR 0 3
15794: PUSH
15795: LD_INT 2
15797: ARRAY
15798: PPUSH
15799: LD_INT 213
15801: PPUSH
15802: LD_INT 90
15804: PPUSH
15805: CALL_OW 158
// if sci > 2 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 2
15816: GREATER
15817: IFFALSE 15838
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15819: LD_VAR 0 3
15823: PUSH
15824: LD_INT 3
15826: ARRAY
15827: PPUSH
15828: LD_INT 215
15830: PPUSH
15831: LD_INT 129
15833: PPUSH
15834: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
// wait ( 0 0$5 ) ;
15853: LD_INT 175
15855: PPUSH
15856: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15860: LD_INT 70
15862: PPUSH
15863: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15867: LD_ADDR_VAR 0 4
15871: PUSH
15872: LD_INT 92
15874: PUSH
15875: LD_INT 195
15877: PUSH
15878: LD_INT 102
15880: PUSH
15881: LD_INT 36
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 22
15892: PUSH
15893: LD_INT 1
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PPUSH
15904: CALL_OW 69
15908: ST_TO_ADDR
// for i in tmp do
15909: LD_ADDR_VAR 0 1
15913: PUSH
15914: LD_VAR 0 2
15918: PUSH
15919: FOR_IN
15920: IFFALSE 15971
// if enemy then
15922: LD_VAR 0 4
15926: IFFALSE 15954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_VAR 0 4
15937: PPUSH
15938: LD_VAR 0 1
15942: PPUSH
15943: CALL_OW 74
15947: PPUSH
15948: CALL_OW 115
15952: GO 15969
// ComAgressiveMove ( i , 195 , 102 ) ;
15954: LD_VAR 0 1
15958: PPUSH
15959: LD_INT 195
15961: PPUSH
15962: LD_INT 102
15964: PPUSH
15965: CALL_OW 114
15969: GO 15919
15971: POP
15972: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_INT 50
15980: PUSH
15981: EMPTY
15982: LIST
15983: PPUSH
15984: CALL_OW 72
15988: NOT
15989: IFFALSE 15860
// end ; end_of_file
15991: PPOPN 4
15993: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15994: LD_INT 0
15996: PPUSH
15997: PPUSH
15998: PPUSH
15999: PPUSH
16000: PPUSH
16001: PPUSH
16002: PPUSH
16003: PPUSH
16004: PPUSH
// Video ( true ) ;
16005: LD_INT 1
16007: PPUSH
16008: CALL 104931 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 7
16019: PPUSH
16020: LD_INT 0
16022: PPUSH
16023: CALL_OW 517
16027: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16028: LD_ADDR_VAR 0 2
16032: PUSH
16033: DOUBLE
16034: LD_INT 1
16036: DEC
16037: ST_TO_ADDR
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ARRAY
16046: PUSH
16047: FOR_TO
16048: IFFALSE 16093
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16050: LD_VAR 0 5
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_VAR 0 2
16063: ARRAY
16064: PPUSH
16065: LD_VAR 0 5
16069: PUSH
16070: LD_INT 2
16072: ARRAY
16073: PUSH
16074: LD_VAR 0 2
16078: ARRAY
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: LD_INT 15
16085: NEG
16086: PPUSH
16087: CALL 104845 0 4
16091: GO 16047
16093: POP
16094: POP
// CenterNowOnUnits ( Powell ) ;
16095: LD_EXP 60
16099: PPUSH
16100: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_EXP 58
16113: PUSH
16114: EMPTY
16115: LIST
16116: ST_TO_ADDR
// if GirlNewVeh then
16117: LD_EXP 59
16121: IFFALSE 16139
// tmp := tmp ^ GirlNewVeh ;
16123: LD_ADDR_VAR 0 5
16127: PUSH
16128: LD_VAR 0 5
16132: PUSH
16133: LD_EXP 59
16137: ADD
16138: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16139: LD_VAR 0 5
16143: PPUSH
16144: LD_INT 60
16146: PPUSH
16147: LD_INT 109
16149: PPUSH
16150: CALL_OW 111
// if KappaStatus then
16154: LD_EXP 2
16158: IFFALSE 16210
// begin Say ( JMM , D1nT-JMM-1 ) ;
16160: LD_EXP 40
16164: PPUSH
16165: LD_STRING D1nT-JMM-1
16167: PPUSH
16168: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16172: LD_EXP 60
16176: PPUSH
16177: LD_STRING D1T-Pow-1
16179: PPUSH
16180: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16184: LD_EXP 40
16188: PPUSH
16189: LD_STRING D1T-JMM-2
16191: PPUSH
16192: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16196: LD_EXP 60
16200: PPUSH
16201: LD_STRING D1T-Pow-2
16203: PPUSH
16204: CALL_OW 88
// end else
16208: GO 16416
// if JMMGirlStatus then
16210: LD_EXP 6
16214: IFFALSE 16359
// begin Say ( JMM , D1T-JMM-1 ) ;
16216: LD_EXP 40
16220: PPUSH
16221: LD_STRING D1T-JMM-1
16223: PPUSH
16224: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16228: LD_EXP 60
16232: PPUSH
16233: LD_STRING D1T-Pow-1
16235: PPUSH
16236: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16240: LD_EXP 40
16244: PPUSH
16245: LD_STRING D1T-JMM-3
16247: PPUSH
16248: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16252: LD_EXP 60
16256: PPUSH
16257: LD_STRING D1T-Pow-3
16259: PPUSH
16260: CALL_OW 88
// if JMMGirl then
16264: LD_EXP 7
16268: IFFALSE 16357
// begin case JMMGirl of 1 :
16270: LD_EXP 7
16274: PUSH
16275: LD_INT 1
16277: DOUBLE
16278: EQUAL
16279: IFTRUE 16283
16281: GO 16298
16283: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16284: LD_EXP 41
16288: PPUSH
16289: LD_STRING D1T-Joan-3
16291: PPUSH
16292: CALL_OW 88
16296: GO 16345
16298: LD_INT 2
16300: DOUBLE
16301: EQUAL
16302: IFTRUE 16306
16304: GO 16321
16306: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16307: LD_EXP 43
16311: PPUSH
16312: LD_STRING D1T-Lisa-3
16314: PPUSH
16315: CALL_OW 88
16319: GO 16345
16321: LD_INT 3
16323: DOUBLE
16324: EQUAL
16325: IFTRUE 16329
16327: GO 16344
16329: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16330: LD_EXP 55
16334: PPUSH
16335: LD_STRING D1T-Con-3
16337: PPUSH
16338: CALL_OW 88
16342: GO 16345
16344: POP
// Say ( Powell , D1T-Pow-4 ) ;
16345: LD_EXP 60
16349: PPUSH
16350: LD_STRING D1T-Pow-4
16352: PPUSH
16353: CALL_OW 88
// end ; end else
16357: GO 16416
// if not FastEnd then
16359: LD_EXP 11
16363: NOT
16364: IFFALSE 16392
// begin Say ( JMM , D1T-JMM-4 ) ;
16366: LD_EXP 40
16370: PPUSH
16371: LD_STRING D1T-JMM-4
16373: PPUSH
16374: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16378: LD_EXP 60
16382: PPUSH
16383: LD_STRING D1T-Pow-5
16385: PPUSH
16386: CALL_OW 88
// end else
16390: GO 16416
// begin Say ( JMM , D1nT-JMM-1 ) ;
16392: LD_EXP 40
16396: PPUSH
16397: LD_STRING D1nT-JMM-1
16399: PPUSH
16400: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16404: LD_EXP 60
16408: PPUSH
16409: LD_STRING D1nT-Pow-1
16411: PPUSH
16412: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16416: LD_INT 3
16418: PPUSH
16419: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16423: LD_EXP 58
16427: PPUSH
16428: CALL_OW 314
16432: NOT
16433: IFFALSE 16416
// ComExitVehicle ( JMM ) ;
16435: LD_EXP 40
16439: PPUSH
16440: CALL_OW 121
// repeat wait ( 3 ) ;
16444: LD_INT 3
16446: PPUSH
16447: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16451: LD_EXP 40
16455: PPUSH
16456: CALL_OW 310
16460: NOT
16461: IFFALSE 16444
// ComMoveXY ( JMM , 60 , 94 ) ;
16463: LD_EXP 40
16467: PPUSH
16468: LD_INT 60
16470: PPUSH
16471: LD_INT 94
16473: PPUSH
16474: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16478: LD_EXP 40
16482: PPUSH
16483: LD_EXP 60
16487: PPUSH
16488: CALL_OW 179
// if Joan then
16492: LD_EXP 41
16496: IFFALSE 16550
// begin ComExitVehicle ( Joan ) ;
16498: LD_EXP 41
16502: PPUSH
16503: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16507: LD_EXP 41
16511: PPUSH
16512: LD_INT 35
16514: PPUSH
16515: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16519: LD_EXP 41
16523: PPUSH
16524: LD_INT 65
16526: PPUSH
16527: LD_INT 104
16529: PPUSH
16530: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16534: LD_EXP 41
16538: PPUSH
16539: LD_EXP 40
16543: PPUSH
16544: CALL_OW 179
// end else
16548: GO 16684
// if Lisa and JMMGirl = 2 then
16550: LD_EXP 43
16554: PUSH
16555: LD_EXP 7
16559: PUSH
16560: LD_INT 2
16562: EQUAL
16563: AND
16564: IFFALSE 16618
// begin ComExitVehicle ( Lisa ) ;
16566: LD_EXP 43
16570: PPUSH
16571: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16575: LD_EXP 43
16579: PPUSH
16580: LD_INT 35
16582: PPUSH
16583: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16587: LD_EXP 43
16591: PPUSH
16592: LD_INT 65
16594: PPUSH
16595: LD_INT 104
16597: PPUSH
16598: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16602: LD_EXP 43
16606: PPUSH
16607: LD_EXP 40
16611: PPUSH
16612: CALL_OW 179
// end else
16616: GO 16684
// if Connie and JMMGirl = 3 then
16618: LD_EXP 55
16622: PUSH
16623: LD_EXP 7
16627: PUSH
16628: LD_INT 3
16630: EQUAL
16631: AND
16632: IFFALSE 16684
// begin ComExitVehicle ( Connie ) ;
16634: LD_EXP 55
16638: PPUSH
16639: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16643: LD_EXP 55
16647: PPUSH
16648: LD_INT 35
16650: PPUSH
16651: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16655: LD_EXP 55
16659: PPUSH
16660: LD_INT 65
16662: PPUSH
16663: LD_INT 104
16665: PPUSH
16666: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16670: LD_EXP 55
16674: PPUSH
16675: LD_EXP 40
16679: PPUSH
16680: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16684: LD_INT 35
16686: PPUSH
16687: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16691: LD_EXP 40
16695: PPUSH
16696: LD_EXP 60
16700: PPUSH
16701: CALL_OW 296
16705: PUSH
16706: LD_INT 8
16708: LESS
16709: IFFALSE 16684
// wait ( 0 0$0.5 ) ;
16711: LD_INT 18
16713: PPUSH
16714: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16718: LD_EXP 40
16722: PPUSH
16723: LD_STRING D1-JMM-1
16725: PPUSH
16726: CALL_OW 88
// async ;
16730: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16731: LD_EXP 60
16735: PPUSH
16736: LD_STRING D1-Pow-1
16738: PPUSH
16739: CALL_OW 88
// if not dialogue_skipped then
16743: LD_OWVAR 59
16747: NOT
16748: IFFALSE 16757
// wait ( 0 0$2 ) ;
16750: LD_INT 70
16752: PPUSH
16753: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16757: LD_INT 170
16759: PPUSH
16760: LD_INT 99
16762: PPUSH
16763: LD_INT 1
16765: PPUSH
16766: LD_INT 6
16768: NEG
16769: PPUSH
16770: CALL 104845 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16774: LD_INT 174
16776: PPUSH
16777: LD_INT 115
16779: PPUSH
16780: LD_INT 1
16782: PPUSH
16783: LD_INT 6
16785: NEG
16786: PPUSH
16787: CALL 104845 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16791: LD_INT 169
16793: PPUSH
16794: LD_INT 71
16796: PPUSH
16797: LD_INT 1
16799: PPUSH
16800: LD_INT 6
16802: NEG
16803: PPUSH
16804: CALL 104845 0 4
// if not dialogue_skipped then
16808: LD_OWVAR 59
16812: NOT
16813: IFFALSE 16832
// begin CenterOnXY ( 170 , 99 ) ;
16815: LD_INT 170
16817: PPUSH
16818: LD_INT 99
16820: PPUSH
16821: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16825: LD_INT 80
16827: PPUSH
16828: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16832: LD_INT 75
16834: PPUSH
16835: LD_INT 53
16837: PPUSH
16838: LD_INT 1
16840: PPUSH
16841: LD_INT 9
16843: NEG
16844: PPUSH
16845: CALL 104845 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16849: LD_INT 54
16851: PPUSH
16852: LD_INT 42
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: LD_INT 9
16860: NEG
16861: PPUSH
16862: CALL 104845 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16866: LD_INT 62
16868: PPUSH
16869: LD_INT 51
16871: PPUSH
16872: LD_INT 1
16874: PPUSH
16875: LD_INT 9
16877: NEG
16878: PPUSH
16879: CALL 104845 0 4
// if not dialogue_skipped then
16883: LD_OWVAR 59
16887: NOT
16888: IFFALSE 16907
// begin CenterOnXY ( 75 , 53 ) ;
16890: LD_INT 75
16892: PPUSH
16893: LD_INT 53
16895: PPUSH
16896: CALL_OW 84
// wait ( 0 0$4 ) ;
16900: LD_INT 140
16902: PPUSH
16903: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16907: LD_EXP 60
16911: PPUSH
16912: CALL_OW 87
// if not dialogue_skipped then
16916: LD_OWVAR 59
16920: NOT
16921: IFFALSE 16930
// wait ( 0 0$2 ) ;
16923: LD_INT 70
16925: PPUSH
16926: CALL_OW 67
// sync ;
16930: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16931: LD_EXP 40
16935: PPUSH
16936: LD_STRING D1-JMM-2
16938: PPUSH
16939: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16943: LD_EXP 60
16947: PPUSH
16948: LD_STRING D1-Pow-2
16950: PPUSH
16951: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16955: LD_EXP 40
16959: PPUSH
16960: LD_STRING D1-JMM-3
16962: PPUSH
16963: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16967: LD_EXP 60
16971: PPUSH
16972: LD_STRING D1-Pow-3
16974: PPUSH
16975: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16979: LD_EXP 40
16983: PPUSH
16984: LD_STRING D1-JMM-4
16986: PPUSH
16987: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16991: LD_EXP 60
16995: PPUSH
16996: LD_STRING D1-Pow-4
16998: PPUSH
16999: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17003: LD_EXP 40
17007: PPUSH
17008: LD_STRING D1-JMM-5
17010: PPUSH
17011: CALL_OW 88
// async ;
17015: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17016: LD_EXP 60
17020: PPUSH
17021: LD_STRING D1-Pow-5
17023: PPUSH
17024: CALL_OW 88
// if not dialogue_skipped then
17028: LD_OWVAR 59
17032: NOT
17033: IFFALSE 17042
// wait ( 0 0$3.6 ) ;
17035: LD_INT 126
17037: PPUSH
17038: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17042: LD_INT 134
17044: PPUSH
17045: LD_INT 210
17047: PPUSH
17048: LD_INT 1
17050: PPUSH
17051: LD_INT 11
17053: NEG
17054: PPUSH
17055: CALL 104845 0 4
// if not dialogue_skipped then
17059: LD_OWVAR 59
17063: NOT
17064: IFFALSE 17083
// begin CenterOnXY ( 134 , 210 ) ;
17066: LD_INT 134
17068: PPUSH
17069: LD_INT 210
17071: PPUSH
17072: CALL_OW 84
// wait ( 0 0$2 ) ;
17076: LD_INT 70
17078: PPUSH
17079: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17083: LD_INT 101
17085: PPUSH
17086: LD_INT 159
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 10
17094: NEG
17095: PPUSH
17096: CALL 104845 0 4
// if not dialogue_skipped then
17100: LD_OWVAR 59
17104: NOT
17105: IFFALSE 17124
// begin CenterOnXY ( 101 , 159 ) ;
17107: LD_INT 101
17109: PPUSH
17110: LD_INT 159
17112: PPUSH
17113: CALL_OW 84
// wait ( 0 0$2 ) ;
17117: LD_INT 70
17119: PPUSH
17120: CALL_OW 67
// end ; sync ;
17124: SYNC
// CenterNowOnUnits ( Powell ) ;
17125: LD_EXP 60
17129: PPUSH
17130: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17134: LD_ADDR_VAR 0 6
17138: PUSH
17139: LD_INT 1
17141: PUSH
17142: LD_INT 2
17144: PUSH
17145: LD_INT 3
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: ST_TO_ADDR
// if not dialogue_skipped then
17165: LD_OWVAR 59
17169: NOT
17170: IFFALSE 17339
// begin game_speed := 4 ;
17172: LD_ADDR_OWVAR 65
17176: PUSH
17177: LD_INT 4
17179: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17180: LD_INT 210
17182: PPUSH
17183: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17187: LD_ADDR_VAR 0 7
17191: PUSH
17192: LD_STRING Q1
17194: PPUSH
17195: LD_VAR 0 6
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17205: LD_ADDR_VAR 0 7
17209: PUSH
17210: LD_STRING Q1
17212: PPUSH
17213: LD_VAR 0 6
17217: PPUSH
17218: CALL_OW 98
17222: ST_TO_ADDR
// options := options diff dec ;
17223: LD_ADDR_VAR 0 6
17227: PUSH
17228: LD_VAR 0 6
17232: PUSH
17233: LD_VAR 0 7
17237: DIFF
17238: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17239: LD_VAR 0 7
17243: PPUSH
17244: LD_VAR 0 6
17248: PPUSH
17249: CALL 18903 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17253: LD_VAR 0 7
17257: PUSH
17258: LD_INT 5
17260: PUSH
17261: LD_INT 6
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: IN
17268: PUSH
17269: LD_VAR 0 6
17273: PUSH
17274: LD_INT 2
17276: EQUAL
17277: OR
17278: IFFALSE 17205
// if not ( dec in [ 5 , 6 ] ) then
17280: LD_VAR 0 7
17284: PUSH
17285: LD_INT 5
17287: PUSH
17288: LD_INT 6
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: IN
17295: NOT
17296: IFFALSE 17339
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17298: LD_ADDR_VAR 0 7
17302: PUSH
17303: LD_STRING Q1a
17305: PPUSH
17306: LD_INT 1
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PPUSH
17316: CALL_OW 98
17320: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 4
17328: PLUS
17329: PPUSH
17330: LD_VAR 0 6
17334: PPUSH
17335: CALL 18903 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17339: LD_INT 81
17341: PPUSH
17342: LD_INT 127
17344: PPUSH
17345: CALL_OW 84
// amount := 8 ;
17349: LD_ADDR_VAR 0 8
17353: PUSH
17354: LD_INT 8
17356: ST_TO_ADDR
// macmilan_squad := [ ] ;
17357: LD_ADDR_VAR 0 9
17361: PUSH
17362: EMPTY
17363: ST_TO_ADDR
// if vip < amount then
17364: LD_EXP 61
17368: PUSH
17369: LD_VAR 0 8
17373: LESS
17374: IFFALSE 17418
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17376: LD_ADDR_VAR 0 5
17380: PUSH
17381: LD_EXP 61
17385: PUSH
17386: LD_INT 22
17388: PUSH
17389: LD_INT 4
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: PUSH
17396: LD_INT 21
17398: PUSH
17399: LD_INT 1
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PPUSH
17410: CALL_OW 69
17414: UNION
17415: ST_TO_ADDR
17416: GO 17428
// tmp := vip ;
17418: LD_ADDR_VAR 0 5
17422: PUSH
17423: LD_EXP 61
17427: ST_TO_ADDR
// tmp := tmp diff Powell ;
17428: LD_ADDR_VAR 0 5
17432: PUSH
17433: LD_VAR 0 5
17437: PUSH
17438: LD_EXP 60
17442: DIFF
17443: ST_TO_ADDR
// if tmp < amount then
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 8
17453: LESS
17454: IFFALSE 17466
// amount := tmp ;
17456: LD_ADDR_VAR 0 8
17460: PUSH
17461: LD_VAR 0 5
17465: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17466: LD_VAR 0 5
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: PPUSH
17475: CALL_OW 257
17479: PUSH
17480: LD_INT 2
17482: NONEQUAL
17483: IFFALSE 17581
// begin if IsInUnit ( tmp [ 1 ] ) then
17485: LD_VAR 0 5
17489: PUSH
17490: LD_INT 1
17492: ARRAY
17493: PPUSH
17494: CALL_OW 310
17498: IFFALSE 17513
// ComExitBuilding ( tmp [ 1 ] ) ;
17500: LD_VAR 0 5
17504: PUSH
17505: LD_INT 1
17507: ARRAY
17508: PPUSH
17509: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17513: LD_INT 387
17515: PPUSH
17516: CALL_OW 313
17520: PUSH
17521: LD_INT 6
17523: EQUAL
17524: IFFALSE 17549
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17526: LD_INT 387
17528: PPUSH
17529: CALL_OW 313
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PPUSH
17538: CALL_OW 122
// wait ( 3 ) ;
17542: LD_INT 3
17544: PPUSH
17545: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17549: LD_VAR 0 5
17553: PUSH
17554: LD_INT 1
17556: ARRAY
17557: PPUSH
17558: LD_INT 387
17560: PPUSH
17561: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17565: LD_VAR 0 5
17569: PUSH
17570: LD_INT 1
17572: ARRAY
17573: PPUSH
17574: LD_INT 2
17576: PPUSH
17577: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17581: LD_EXP 40
17585: PPUSH
17586: LD_INT 82
17588: PPUSH
17589: LD_INT 129
17591: PPUSH
17592: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17596: LD_EXP 40
17600: PPUSH
17601: LD_EXP 60
17605: PPUSH
17606: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17610: LD_INT 22
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PPUSH
17620: CALL_OW 69
17624: PUSH
17625: LD_EXP 40
17629: DIFF
17630: PPUSH
17631: LD_INT 84
17633: PPUSH
17634: LD_INT 128
17636: PPUSH
17637: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17641: LD_INT 22
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: PUSH
17656: LD_EXP 40
17660: DIFF
17661: PPUSH
17662: LD_EXP 40
17666: PPUSH
17667: CALL_OW 179
// for i = 1 to amount do
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: DOUBLE
17677: LD_INT 1
17679: DEC
17680: ST_TO_ADDR
17681: LD_VAR 0 8
17685: PUSH
17686: FOR_TO
17687: IFFALSE 17855
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17689: LD_ADDR_VAR 0 9
17693: PUSH
17694: LD_VAR 0 9
17698: PUSH
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: ADD
17710: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17711: LD_VAR 0 5
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: CALL_OW 310
17726: IFFALSE 17743
// AddComExitBuilding ( tmp [ i ] ) ;
17728: LD_VAR 0 5
17732: PUSH
17733: LD_VAR 0 2
17737: ARRAY
17738: PPUSH
17739: CALL_OW 182
// if i = 2 and JMMNewVeh then
17743: LD_VAR 0 2
17747: PUSH
17748: LD_INT 2
17750: EQUAL
17751: PUSH
17752: LD_EXP 58
17756: AND
17757: IFFALSE 17815
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17759: LD_VAR 0 5
17763: PUSH
17764: LD_VAR 0 2
17768: ARRAY
17769: PPUSH
17770: LD_EXP 58
17774: PPUSH
17775: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17779: LD_VAR 0 5
17783: PUSH
17784: LD_VAR 0 2
17788: ARRAY
17789: PPUSH
17790: LD_INT 86
17792: PPUSH
17793: LD_INT 133
17795: PPUSH
17796: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 2
17809: ARRAY
17810: PPUSH
17811: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17815: LD_VAR 0 5
17819: PUSH
17820: LD_VAR 0 2
17824: ARRAY
17825: PPUSH
17826: LD_INT 8
17828: PPUSH
17829: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17833: LD_VAR 0 5
17837: PUSH
17838: LD_VAR 0 2
17842: ARRAY
17843: PPUSH
17844: LD_EXP 40
17848: PPUSH
17849: CALL_OW 179
// end ;
17853: GO 17686
17855: POP
17856: POP
// if GirlNewVeh then
17857: LD_EXP 59
17861: IFFALSE 17875
// SetSide ( GirlNewVeh , 4 ) ;
17863: LD_EXP 59
17867: PPUSH
17868: LD_INT 4
17870: PPUSH
17871: CALL_OW 235
// if Mike then
17875: LD_EXP 57
17879: IFFALSE 17916
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
17881: LD_ADDR_VAR 0 9
17885: PUSH
17886: LD_VAR 0 9
17890: PPUSH
17891: LD_EXP 57
17895: PPUSH
17896: CALL 104959 0 2
17900: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
17901: LD_EXP 57
17905: PPUSH
17906: LD_INT 86
17908: PPUSH
17909: LD_INT 133
17911: PPUSH
17912: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
17916: LD_INT 35
17918: PPUSH
17919: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_INT 95
17930: PUSH
17931: LD_INT 9
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PPUSH
17938: CALL_OW 72
17942: PUSH
17943: LD_INT 0
17945: EQUAL
17946: PUSH
17947: LD_EXP 40
17951: PPUSH
17952: LD_INT 9
17954: PPUSH
17955: CALL_OW 308
17959: NOT
17960: AND
17961: IFFALSE 17916
// wait ( 0 0$2 ) ;
17963: LD_INT 70
17965: PPUSH
17966: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17970: LD_VAR 0 9
17974: PPUSH
17975: LD_INT 1
17977: PPUSH
17978: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17982: LD_INT 21
17984: PUSH
17985: LD_INT 2
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: LD_INT 83
17997: PUSH
17998: LD_INT 130
18000: PUSH
18001: LD_INT 10
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: PUSH
18010: EMPTY
18011: LIST
18012: LIST
18013: PPUSH
18014: CALL_OW 69
18018: PPUSH
18019: LD_INT 1
18021: PPUSH
18022: CALL_OW 235
// tick := 0 ;
18026: LD_ADDR_OWVAR 1
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 104931 0 1
// ChangeMissionObjectives ( M1 ) ;
18041: LD_STRING M1
18043: PPUSH
18044: CALL_OW 337
// SaveForQuickRestart ;
18048: CALL_OW 22
// missionStart := true ;
18052: LD_ADDR_EXP 13
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// missionStage := 2 ;
18060: LD_ADDR_EXP 15
18064: PUSH
18065: LD_INT 2
18067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18068: LD_INT 35
18070: PPUSH
18071: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18075: LD_ADDR_VAR 0 5
18079: PUSH
18080: LD_INT 22
18082: PUSH
18083: LD_INT 4
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 21
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 69
18108: PUSH
18109: LD_EXP 60
18113: DIFF
18114: ST_TO_ADDR
// if not tmp then
18115: LD_VAR 0 5
18119: NOT
18120: IFFALSE 18135
// tmp := [ Powell ] ;
18122: LD_ADDR_VAR 0 5
18126: PUSH
18127: LD_EXP 60
18131: PUSH
18132: EMPTY
18133: LIST
18134: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18135: LD_ADDR_VAR 0 4
18139: PUSH
18140: LD_INT 22
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: PUSH
18150: LD_INT 34
18152: PUSH
18153: LD_INT 12
18155: PUSH
18156: EMPTY
18157: LIST
18158: LIST
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 69
18168: PUSH
18169: LD_INT 1
18171: ARRAY
18172: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18173: LD_VAR 0 5
18177: PUSH
18178: LD_INT 1
18180: ARRAY
18181: PPUSH
18182: CALL_OW 310
18186: IFFALSE 18201
// ComExitBuilding ( tmp [ 1 ] ) ;
18188: LD_VAR 0 5
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: PPUSH
18197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18201: LD_VAR 0 5
18205: PUSH
18206: LD_INT 1
18208: ARRAY
18209: PPUSH
18210: LD_VAR 0 4
18214: PPUSH
18215: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18219: LD_VAR 0 5
18223: PUSH
18224: LD_INT 1
18226: ARRAY
18227: PPUSH
18228: LD_INT 80
18230: PPUSH
18231: LD_INT 136
18233: PPUSH
18234: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18238: LD_VAR 0 5
18242: PUSH
18243: LD_INT 1
18245: ARRAY
18246: PPUSH
18247: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18251: LD_VAR 0 5
18255: PUSH
18256: LD_INT 1
18258: ARRAY
18259: PPUSH
18260: LD_INT 59
18262: PPUSH
18263: LD_INT 112
18265: PPUSH
18266: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18270: LD_VAR 0 5
18274: PUSH
18275: LD_INT 1
18277: ARRAY
18278: PPUSH
18279: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18283: LD_EXP 41
18287: PUSH
18288: LD_EXP 41
18292: PPUSH
18293: CALL_OW 255
18297: PUSH
18298: LD_INT 1
18300: EQUAL
18301: AND
18302: IFFALSE 18328
// begin Say ( Joan , D3W-Joan-1 ) ;
18304: LD_EXP 41
18308: PPUSH
18309: LD_STRING D3W-Joan-1
18311: PPUSH
18312: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18316: LD_EXP 40
18320: PPUSH
18321: LD_STRING D3W-JMM-1
18323: PPUSH
18324: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18328: LD_EXP 43
18332: PUSH
18333: LD_EXP 43
18337: PPUSH
18338: CALL_OW 255
18342: PUSH
18343: LD_INT 1
18345: EQUAL
18346: AND
18347: PUSH
18348: LD_EXP 43
18352: PUSH
18353: LD_EXP 61
18357: IN
18358: NOT
18359: AND
18360: IFFALSE 18386
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18362: LD_EXP 43
18366: PPUSH
18367: LD_STRING D3W-Lisa-1
18369: PPUSH
18370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18374: LD_EXP 40
18378: PPUSH
18379: LD_STRING D3W-JMM-1
18381: PPUSH
18382: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18386: LD_EXP 55
18390: PUSH
18391: LD_EXP 55
18395: PPUSH
18396: CALL_OW 255
18400: PUSH
18401: LD_INT 1
18403: EQUAL
18404: AND
18405: IFFALSE 18431
// begin Say ( Connie , D3W-Con-1 ) ;
18407: LD_EXP 55
18411: PPUSH
18412: LD_STRING D3W-Con-1
18414: PPUSH
18415: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18419: LD_EXP 40
18423: PPUSH
18424: LD_STRING D3W-JMM-1
18426: PPUSH
18427: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
18431: LD_INT 18
18433: PPUSH
18434: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
18438: LD_EXP 43
18442: PUSH
18443: LD_EXP 61
18447: IN
18448: PUSH
18449: LD_EXP 43
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Lisa , D3nW-Lisa-1 ) else
18465: LD_EXP 43
18469: PPUSH
18470: LD_STRING D3nW-Lisa-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18723
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18479: LD_EXP 46
18483: PUSH
18484: LD_EXP 61
18488: IN
18489: PUSH
18490: LD_EXP 46
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18506: LD_EXP 46
18510: PPUSH
18511: LD_STRING D3nW-Cyrus-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18723
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18520: LD_EXP 45
18524: PUSH
18525: LD_EXP 61
18529: IN
18530: PUSH
18531: LD_EXP 45
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18561
// Say ( Bobby , D3nW-Bobby-1 ) else
18547: LD_EXP 45
18551: PPUSH
18552: LD_STRING D3nW-Bobby-1
18554: PPUSH
18555: CALL_OW 88
18559: GO 18723
// if Gary in vip and GetSide ( Gary ) = 1 then
18561: LD_EXP 52
18565: PUSH
18566: LD_EXP 61
18570: IN
18571: PUSH
18572: LD_EXP 52
18576: PPUSH
18577: CALL_OW 255
18581: PUSH
18582: LD_INT 1
18584: EQUAL
18585: AND
18586: IFFALSE 18602
// Say ( Gary , D3nW-Gary-1 ) else
18588: LD_EXP 52
18592: PPUSH
18593: LD_STRING D3nW-Gary-1
18595: PPUSH
18596: CALL_OW 88
18600: GO 18723
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18602: LD_EXP 44
18606: PUSH
18607: LD_EXP 61
18611: IN
18612: PUSH
18613: LD_EXP 44
18617: PPUSH
18618: CALL_OW 255
18622: PUSH
18623: LD_INT 1
18625: EQUAL
18626: AND
18627: IFFALSE 18643
// Say ( Donaldson , D3nW-Don-1 ) else
18629: LD_EXP 44
18633: PPUSH
18634: LD_STRING D3nW-Don-1
18636: PPUSH
18637: CALL_OW 88
18641: GO 18723
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18643: LD_EXP 51
18647: PUSH
18648: LD_EXP 61
18652: IN
18653: PUSH
18654: LD_EXP 51
18658: PPUSH
18659: CALL_OW 255
18663: PUSH
18664: LD_INT 1
18666: EQUAL
18667: AND
18668: IFFALSE 18684
// Say ( Cornel , D3nW-Corn-1 ) else
18670: LD_EXP 51
18674: PPUSH
18675: LD_STRING D3nW-Corn-1
18677: PPUSH
18678: CALL_OW 88
18682: GO 18723
// if Frank in vip and GetSide ( Frank ) = 1 then
18684: LD_EXP 53
18688: PUSH
18689: LD_EXP 61
18693: IN
18694: PUSH
18695: LD_EXP 53
18699: PPUSH
18700: CALL_OW 255
18704: PUSH
18705: LD_INT 1
18707: EQUAL
18708: AND
18709: IFFALSE 18723
// Say ( Frank , D3nW-Frank-1 ) ;
18711: LD_EXP 53
18715: PPUSH
18716: LD_STRING D3nW-Frank-1
18718: PPUSH
18719: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18723: LD_EXP 61
18727: PPUSH
18728: LD_INT 22
18730: PUSH
18731: LD_INT 1
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 72
18742: IFFALSE 18768
// begin Say ( JMM , D3nW-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D3nW-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D3nW-JMM-1a
18763: PPUSH
18764: CALL_OW 88
// end ; t := 0 0$00 ;
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_INT 0
18775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18776: LD_INT 35
18778: PPUSH
18779: CALL_OW 67
// t := t + 0 0$1 ;
18783: LD_ADDR_VAR 0 3
18787: PUSH
18788: LD_VAR 0 3
18792: PUSH
18793: LD_INT 35
18795: PLUS
18796: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18797: LD_INT 59
18799: PPUSH
18800: LD_INT 112
18802: PPUSH
18803: CALL_OW 428
18807: PUSH
18808: LD_VAR 0 3
18812: PUSH
18813: LD_INT 2100
18815: GREATER
18816: OR
18817: IFFALSE 18776
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18819: LD_ADDR_EXP 100
18823: PUSH
18824: LD_EXP 100
18828: PPUSH
18829: LD_INT 4
18831: PPUSH
18832: LD_INT 22
18834: PUSH
18835: LD_INT 4
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 23
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 3
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 69
18878: PUSH
18879: LD_EXP 60
18883: DIFF
18884: PPUSH
18885: CALL_OW 1
18889: ST_TO_ADDR
// activeAttacks := true ;
18890: LD_ADDR_EXP 16
18894: PUSH
18895: LD_INT 1
18897: ST_TO_ADDR
// end ;
18898: LD_VAR 0 1
18902: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18903: LD_INT 0
18905: PPUSH
// case question of 1 :
18906: LD_VAR 0 1
18910: PUSH
18911: LD_INT 1
18913: DOUBLE
18914: EQUAL
18915: IFTRUE 18919
18917: GO 18970
18919: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18920: LD_EXP 40
18924: PPUSH
18925: LD_STRING D2Mot-JMM-1
18927: PPUSH
18928: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18932: LD_EXP 60
18936: PPUSH
18937: LD_STRING D2Mot-Pow-1
18939: PPUSH
18940: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18944: LD_EXP 40
18948: PPUSH
18949: LD_STRING D2Mot-JMM-2
18951: PPUSH
18952: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18956: LD_EXP 60
18960: PPUSH
18961: LD_STRING D2Mot-Pow-2
18963: PPUSH
18964: CALL_OW 88
// end ; 2 :
18968: GO 19321
18970: LD_INT 2
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19054
18978: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_STRING D2Rus-JMM-1
18986: PPUSH
18987: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18991: LD_EXP 60
18995: PPUSH
18996: LD_STRING D2Rus-Pow-1
18998: PPUSH
18999: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19003: LD_EXP 40
19007: PPUSH
19008: LD_STRING D2Rus-JMM-2
19010: PPUSH
19011: CALL_OW 88
// if not ( 3 in list_of_q ) then
19015: LD_INT 3
19017: PUSH
19018: LD_VAR 0 2
19022: IN
19023: NOT
19024: IFFALSE 19040
// Say ( Powell , D2Rus-Pow-2 ) else
19026: LD_EXP 60
19030: PPUSH
19031: LD_STRING D2Rus-Pow-2
19033: PPUSH
19034: CALL_OW 88
19038: GO 19052
// Say ( Powell , D2Rus-Pow-2a ) ;
19040: LD_EXP 60
19044: PPUSH
19045: LD_STRING D2Rus-Pow-2a
19047: PPUSH
19048: CALL_OW 88
// end ; 3 :
19052: GO 19321
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19147
19062: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Leg-JMM-1
19070: PPUSH
19071: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19075: LD_EXP 60
19079: PPUSH
19080: LD_STRING D2Leg-Pow-1
19082: PPUSH
19083: CALL_OW 88
// if 2 in list_of_q then
19087: LD_INT 2
19089: PUSH
19090: LD_VAR 0 2
19094: IN
19095: IFFALSE 19121
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19097: LD_EXP 40
19101: PPUSH
19102: LD_STRING D2Leg-JMM-2
19104: PPUSH
19105: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19109: LD_EXP 60
19113: PPUSH
19114: LD_STRING D2Leg-Pow-2
19116: PPUSH
19117: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19121: LD_EXP 40
19125: PPUSH
19126: LD_STRING D2Leg-JMM-3
19128: PPUSH
19129: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19133: LD_EXP 60
19137: PPUSH
19138: LD_STRING D2Leg-Pow-3
19140: PPUSH
19141: CALL_OW 88
// end ; 4 :
19145: GO 19321
19147: LD_INT 4
19149: DOUBLE
19150: EQUAL
19151: IFTRUE 19155
19153: GO 19230
19155: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19156: LD_EXP 40
19160: PPUSH
19161: LD_STRING D2Ar-JMM-1
19163: PPUSH
19164: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19168: LD_EXP 60
19172: PPUSH
19173: LD_STRING D2Ar-Pow-1
19175: PPUSH
19176: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19180: LD_EXP 40
19184: PPUSH
19185: LD_STRING D2Ar-JMM-2
19187: PPUSH
19188: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19192: LD_EXP 60
19196: PPUSH
19197: LD_STRING D2Ar-Pow-2
19199: PPUSH
19200: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19204: LD_EXP 40
19208: PPUSH
19209: LD_STRING D2Ar-JMM-3
19211: PPUSH
19212: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19216: LD_EXP 60
19220: PPUSH
19221: LD_STRING D2Ar-Pow-3
19223: PPUSH
19224: CALL_OW 88
// end ; 5 :
19228: GO 19321
19230: LD_INT 5
19232: DOUBLE
19233: EQUAL
19234: IFTRUE 19238
19236: GO 19253
19238: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19239: LD_EXP 40
19243: PPUSH
19244: LD_STRING D2Conf-JMM-1
19246: PPUSH
19247: CALL_OW 88
19251: GO 19321
19253: LD_INT 6
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19320
19261: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19262: LD_EXP 40
19266: PPUSH
19267: LD_STRING D2Com-JMM-1
19269: PPUSH
19270: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19274: LD_EXP 60
19278: PPUSH
19279: LD_STRING D2Com-Pow-1
19281: PPUSH
19282: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19286: LD_EXP 40
19290: PPUSH
19291: LD_STRING D2Com-JMM-2
19293: PPUSH
19294: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19298: LD_EXP 60
19302: PPUSH
19303: LD_STRING D2Com-Pow-2
19305: PPUSH
19306: CALL_OW 88
// powellAngerQuery := true ;
19310: LD_ADDR_EXP 36
19314: PUSH
19315: LD_INT 1
19317: ST_TO_ADDR
// end ; end ;
19318: GO 19321
19320: POP
// end ;
19321: LD_VAR 0 3
19325: RET
// every 0 0$5 trigger missionStart do var tmp ;
19326: LD_EXP 13
19330: IFFALSE 19613
19332: GO 19334
19334: DISABLE
19335: LD_INT 0
19337: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19338: LD_INT 35
19340: PPUSH
19341: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19345: LD_INT 14
19347: PPUSH
19348: LD_INT 22
19350: PUSH
19351: LD_INT 1
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PPUSH
19358: CALL_OW 70
19362: PUSH
19363: LD_EXP 15
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: LD_INT 3
19373: PUSH
19374: LD_INT 4
19376: PUSH
19377: LD_INT 5
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: IN
19386: AND
19387: IFFALSE 19603
// begin powellAnger := powellAnger + 1 ;
19389: LD_ADDR_EXP 17
19393: PUSH
19394: LD_EXP 17
19398: PUSH
19399: LD_INT 1
19401: PLUS
19402: ST_TO_ADDR
// Video ( true ) ;
19403: LD_INT 1
19405: PPUSH
19406: CALL 104931 0 1
// CenterNowOnUnits ( tmp ) ;
19410: LD_VAR 0 1
19414: PPUSH
19415: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19419: LD_INT 14
19421: PPUSH
19422: LD_INT 22
19424: PUSH
19425: LD_INT 1
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: PPUSH
19432: CALL_OW 70
19436: PPUSH
19437: LD_INT 86
19439: PPUSH
19440: LD_INT 133
19442: PPUSH
19443: CALL_OW 111
// async ;
19447: ASYNC
// case powellAnger of 1 :
19448: LD_EXP 17
19452: PUSH
19453: LD_INT 1
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19476
19461: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19462: LD_EXP 60
19466: PPUSH
19467: LD_STRING DBack1-Pow-1
19469: PPUSH
19470: CALL_OW 88
19474: GO 19523
19476: LD_INT 2
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19499
19484: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19485: LD_EXP 60
19489: PPUSH
19490: LD_STRING DBack2-Pow-1
19492: PPUSH
19493: CALL_OW 88
19497: GO 19523
19499: LD_INT 3
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19522
19507: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19508: LD_EXP 60
19512: PPUSH
19513: LD_STRING DBack3-Pow-1
19515: PPUSH
19516: CALL_OW 88
19520: GO 19523
19522: POP
// sync ;
19523: SYNC
// repeat wait ( 0 0$1 ) ;
19524: LD_INT 35
19526: PPUSH
19527: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19531: LD_INT 14
19533: PPUSH
19534: LD_INT 22
19536: PUSH
19537: LD_INT 1
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: PPUSH
19544: CALL_OW 70
19548: PPUSH
19549: LD_INT 86
19551: PPUSH
19552: LD_INT 133
19554: PPUSH
19555: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19559: LD_INT 14
19561: PPUSH
19562: LD_INT 22
19564: PUSH
19565: LD_INT 1
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 70
19576: NOT
19577: IFFALSE 19524
// if powellAnger >= 3 then
19579: LD_EXP 17
19583: PUSH
19584: LD_INT 3
19586: GREATEREQUAL
19587: IFFALSE 19596
// YouLost ( Dismissed ) ;
19589: LD_STRING Dismissed
19591: PPUSH
19592: CALL_OW 104
// Video ( false ) ;
19596: LD_INT 0
19598: PPUSH
19599: CALL 104931 0 1
// end ; until missionStage > 5 ;
19603: LD_EXP 15
19607: PUSH
19608: LD_INT 5
19610: GREATER
19611: IFFALSE 19338
// end ;
19613: PPOPN 1
19615: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19616: LD_EXP 13
19620: PUSH
19621: LD_INT 22
19623: PUSH
19624: LD_INT 4
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 21
19633: PUSH
19634: LD_INT 2
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PPUSH
19645: CALL_OW 69
19649: PUSH
19650: LD_INT 4
19652: GREATEREQUAL
19653: AND
19654: PUSH
19655: LD_EXP 15
19659: PUSH
19660: LD_INT 2
19662: EQUAL
19663: AND
19664: IFFALSE 21854
19666: GO 19668
19668: DISABLE
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
19678: PPUSH
19679: PPUSH
19680: PPUSH
// begin missionStage := 3 ;
19681: LD_ADDR_EXP 15
19685: PUSH
19686: LD_INT 3
19688: ST_TO_ADDR
// retreat := false ;
19689: LD_ADDR_VAR 0 4
19693: PUSH
19694: LD_INT 0
19696: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_INT 22
19704: PUSH
19705: LD_INT 4
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 30
19714: PUSH
19715: LD_INT 4
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: PPUSH
19726: CALL_OW 69
19730: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19731: LD_ADDR_VAR 0 6
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: LD_INT 5
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: ST_TO_ADDR
// if not bar then
19765: LD_VAR 0 6
19769: NOT
19770: IFFALSE 19823
// begin repeat wait ( 0 0$1 ) ;
19772: LD_INT 35
19774: PPUSH
19775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19779: LD_INT 22
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 57
19794: PUSH
19795: EMPTY
19796: LIST
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 30
19804: PUSH
19805: LD_INT 5
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: LIST
19816: PPUSH
19817: CALL_OW 69
19821: IFFALSE 19772
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19823: LD_ADDR_VAR 0 6
19827: PUSH
19828: LD_INT 22
19830: PUSH
19831: LD_INT 4
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: LD_INT 30
19840: PUSH
19841: LD_INT 5
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: PPUSH
19852: CALL_OW 69
19856: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19857: LD_INT 35
19859: PPUSH
19860: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19864: LD_EXP 119
19868: PUSH
19869: LD_INT 4
19871: ARRAY
19872: PUSH
19873: LD_INT 4
19875: GREATEREQUAL
19876: IFFALSE 19857
// tmp := [ ] ;
19878: LD_ADDR_VAR 0 2
19882: PUSH
19883: EMPTY
19884: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19885: LD_ADDR_VAR 0 1
19889: PUSH
19890: LD_INT 22
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 2
19902: PUSH
19903: LD_INT 25
19905: PUSH
19906: LD_INT 1
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 25
19915: PUSH
19916: LD_INT 2
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: LD_INT 25
19925: PUSH
19926: LD_INT 3
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: LD_INT 25
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: PUSH
19943: LD_INT 25
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: PPUSH
19965: CALL_OW 69
19969: PUSH
19970: LD_EXP 60
19974: PUSH
19975: LD_EXP 61
19979: ADD
19980: DIFF
19981: PUSH
19982: FOR_IN
19983: IFFALSE 20047
// if GetTag ( i ) = 1 then
19985: LD_VAR 0 1
19989: PPUSH
19990: CALL_OW 110
19994: PUSH
19995: LD_INT 1
19997: EQUAL
19998: IFFALSE 20022
// tmp := Join ( tmp , i ) else
20000: LD_ADDR_VAR 0 2
20004: PUSH
20005: LD_VAR 0 2
20009: PPUSH
20010: LD_VAR 0 1
20014: PPUSH
20015: CALL 104959 0 2
20019: ST_TO_ADDR
20020: GO 20045
// tmp := Insert ( tmp , 1 , i ) ;
20022: LD_ADDR_VAR 0 2
20026: PUSH
20027: LD_VAR 0 2
20031: PPUSH
20032: LD_INT 1
20034: PPUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 2
20044: ST_TO_ADDR
20045: GO 19982
20047: POP
20048: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20049: LD_ADDR_VAR 0 3
20053: PUSH
20054: LD_VAR 0 2
20058: PPUSH
20059: LD_INT 26
20061: PUSH
20062: LD_INT 1
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PPUSH
20069: CALL_OW 72
20073: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20074: LD_ADDR_VAR 0 2
20078: PUSH
20079: LD_VAR 0 2
20083: PUSH
20084: LD_VAR 0 3
20088: DIFF
20089: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 2
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: CALL 103468 0 2
20107: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_VAR 0 3
20117: PPUSH
20118: LD_INT 3
20120: PPUSH
20121: CALL 103468 0 2
20125: ST_TO_ADDR
// for i := 1 to 4 do
20126: LD_ADDR_VAR 0 1
20130: PUSH
20131: DOUBLE
20132: LD_INT 1
20134: DEC
20135: ST_TO_ADDR
20136: LD_INT 4
20138: PUSH
20139: FOR_TO
20140: IFFALSE 20293
// begin if tmp2 then
20142: LD_VAR 0 3
20146: IFFALSE 20214
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20148: LD_ADDR_EXP 18
20152: PUSH
20153: LD_EXP 18
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_EXP 18
20165: PUSH
20166: LD_INT 1
20168: ARRAY
20169: PUSH
20170: LD_VAR 0 3
20174: PUSH
20175: LD_VAR 0 3
20179: ARRAY
20180: ADD
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20187: LD_VAR 0 3
20191: PUSH
20192: LD_VAR 0 3
20196: ARRAY
20197: PPUSH
20198: LD_INT 1
20200: PPUSH
20201: CALL_OW 109
// tmp2 := [ ] ;
20205: LD_ADDR_VAR 0 3
20209: PUSH
20210: EMPTY
20211: ST_TO_ADDR
// end else
20212: GO 20291
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20214: LD_ADDR_EXP 18
20218: PUSH
20219: LD_EXP 18
20223: PPUSH
20224: LD_INT 1
20226: PPUSH
20227: LD_EXP 18
20231: PUSH
20232: LD_INT 1
20234: ARRAY
20235: PUSH
20236: LD_VAR 0 2
20240: PUSH
20241: LD_VAR 0 2
20245: ARRAY
20246: ADD
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20253: LD_VAR 0 2
20257: PUSH
20258: LD_VAR 0 2
20262: ARRAY
20263: PPUSH
20264: LD_INT 1
20266: PPUSH
20267: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20271: LD_ADDR_VAR 0 2
20275: PUSH
20276: LD_VAR 0 2
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: CALL_OW 3
20290: ST_TO_ADDR
// end ; end ;
20291: GO 20139
20293: POP
20294: POP
// if tmp2 then
20295: LD_VAR 0 3
20299: IFFALSE 20317
// tmp := tmp union tmp2 ;
20301: LD_ADDR_VAR 0 2
20305: PUSH
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 3
20315: UNION
20316: ST_TO_ADDR
// for i := 1 to 4 do
20317: LD_ADDR_VAR 0 1
20321: PUSH
20322: DOUBLE
20323: LD_INT 1
20325: DEC
20326: ST_TO_ADDR
20327: LD_INT 4
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20380
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20333: LD_ADDR_EXP 18
20337: PUSH
20338: LD_EXP 18
20342: PPUSH
20343: LD_INT 2
20345: PPUSH
20346: LD_EXP 18
20350: PUSH
20351: LD_INT 2
20353: ARRAY
20354: PUSH
20355: LD_VAR 0 2
20359: PUSH
20360: LD_VAR 0 2
20364: PUSH
20365: LD_VAR 0 1
20369: MINUS
20370: ARRAY
20371: ADD
20372: PPUSH
20373: CALL_OW 1
20377: ST_TO_ADDR
20378: GO 20330
20380: POP
20381: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20382: LD_ADDR_EXP 100
20386: PUSH
20387: LD_EXP 100
20391: PPUSH
20392: LD_INT 4
20394: PPUSH
20395: LD_EXP 100
20399: PUSH
20400: LD_INT 4
20402: ARRAY
20403: PUSH
20404: LD_EXP 18
20408: PUSH
20409: LD_INT 1
20411: ARRAY
20412: DIFF
20413: PPUSH
20414: CALL_OW 1
20418: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20419: LD_VAR 0 5
20423: PUSH
20424: LD_INT 1
20426: ARRAY
20427: PPUSH
20428: CALL_OW 313
20432: IFFALSE 20487
// begin for i in UnitsInside ( arm [ 1 ] ) do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 5
20443: PUSH
20444: LD_INT 1
20446: ARRAY
20447: PPUSH
20448: CALL_OW 313
20452: PUSH
20453: FOR_IN
20454: IFFALSE 20485
// begin ComExitBuilding ( i ) ;
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20465: LD_VAR 0 1
20469: PPUSH
20470: LD_VAR 0 6
20474: PUSH
20475: LD_INT 1
20477: ARRAY
20478: PPUSH
20479: CALL_OW 180
// end ;
20483: GO 20453
20485: POP
20486: POP
// end ; wait ( 0 0$3 ) ;
20487: LD_INT 105
20489: PPUSH
20490: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20494: LD_ADDR_VAR 0 1
20498: PUSH
20499: LD_EXP 18
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PUSH
20508: FOR_IN
20509: IFFALSE 20616
// begin if IsInUnit ( i ) then
20511: LD_VAR 0 1
20515: PPUSH
20516: CALL_OW 310
20520: IFFALSE 20531
// ComExitBuilding ( i ) ;
20522: LD_VAR 0 1
20526: PPUSH
20527: CALL_OW 122
// if GetClass ( i ) <> 1 then
20531: LD_VAR 0 1
20535: PPUSH
20536: CALL_OW 257
20540: PUSH
20541: LD_INT 1
20543: NONEQUAL
20544: IFFALSE 20585
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20546: LD_VAR 0 1
20550: PPUSH
20551: LD_VAR 0 5
20555: PUSH
20556: LD_INT 1
20558: ARRAY
20559: PPUSH
20560: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20564: LD_VAR 0 1
20568: PPUSH
20569: LD_INT 1
20571: PPUSH
20572: CALL_OW 183
// AddComExitBuilding ( i ) ;
20576: LD_VAR 0 1
20580: PPUSH
20581: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20585: LD_VAR 0 1
20589: PPUSH
20590: LD_INT 60
20592: PPUSH
20593: LD_INT 94
20595: PPUSH
20596: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20600: LD_VAR 0 1
20604: PPUSH
20605: LD_EXP 60
20609: PPUSH
20610: CALL_OW 179
// end ;
20614: GO 20508
20616: POP
20617: POP
// wait ( 0 0$10 ) ;
20618: LD_INT 350
20620: PPUSH
20621: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20625: LD_EXP 60
20629: PPUSH
20630: LD_STRING D4-Pow-1
20632: PPUSH
20633: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20637: LD_ADDR_VAR 0 2
20641: PUSH
20642: LD_EXP 18
20646: PUSH
20647: LD_INT 1
20649: ARRAY
20650: PPUSH
20651: LD_INT 26
20653: PUSH
20654: LD_INT 1
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: ST_TO_ADDR
// if tmp then
20666: LD_VAR 0 2
20670: IFFALSE 20688
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20672: LD_VAR 0 2
20676: PUSH
20677: LD_INT 1
20679: ARRAY
20680: PPUSH
20681: LD_STRING D4-Sol1-1
20683: PPUSH
20684: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20688: LD_EXP 60
20692: PPUSH
20693: LD_STRING D4-Pow-2
20695: PPUSH
20696: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20700: LD_ADDR_VAR 0 1
20704: PUSH
20705: DOUBLE
20706: LD_INT 1
20708: DEC
20709: ST_TO_ADDR
20710: LD_EXP 18
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20813
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20722: LD_EXP 18
20726: PUSH
20727: LD_INT 1
20729: ARRAY
20730: PUSH
20731: LD_VAR 0 1
20735: ARRAY
20736: PPUSH
20737: LD_EXP 119
20741: PUSH
20742: LD_INT 4
20744: ARRAY
20745: PUSH
20746: LD_INT 1
20748: ARRAY
20749: PPUSH
20750: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20754: LD_ADDR_EXP 119
20758: PUSH
20759: LD_EXP 119
20763: PPUSH
20764: LD_INT 4
20766: PPUSH
20767: LD_EXP 119
20771: PUSH
20772: LD_INT 4
20774: ARRAY
20775: PPUSH
20776: LD_INT 1
20778: PPUSH
20779: CALL_OW 3
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20789: LD_INT 8
20791: PPUSH
20792: LD_EXP 18
20796: PUSH
20797: LD_INT 1
20799: ARRAY
20800: PUSH
20801: LD_VAR 0 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 471
// end ;
20811: GO 20719
20813: POP
20814: POP
// repeat wait ( 0 0$1 ) ;
20815: LD_INT 35
20817: PPUSH
20818: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20822: LD_EXP 18
20826: PUSH
20827: LD_INT 1
20829: ARRAY
20830: PPUSH
20831: LD_INT 55
20833: PUSH
20834: EMPTY
20835: LIST
20836: PPUSH
20837: CALL_OW 72
20841: PUSH
20842: LD_INT 4
20844: GREATEREQUAL
20845: IFFALSE 20815
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20847: LD_EXP 18
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: PPUSH
20856: LD_INT 69
20858: PPUSH
20859: LD_INT 94
20861: PPUSH
20862: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20866: LD_EXP 18
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: LD_INT 82
20877: PPUSH
20878: LD_INT 83
20880: PPUSH
20881: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20885: LD_EXP 18
20889: PUSH
20890: LD_INT 1
20892: ARRAY
20893: PPUSH
20894: LD_INT 77
20896: PPUSH
20897: LD_INT 69
20899: PPUSH
20900: CALL_OW 174
// repeat wait ( 3 ) ;
20904: LD_INT 3
20906: PPUSH
20907: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20911: LD_ADDR_VAR 0 1
20915: PUSH
20916: LD_EXP 18
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PUSH
20925: FOR_IN
20926: IFFALSE 21062
// begin if GetLives ( i ) < 990 then
20928: LD_VAR 0 1
20932: PPUSH
20933: CALL_OW 256
20937: PUSH
20938: LD_INT 990
20940: LESS
20941: IFFALSE 20955
// SetLives ( i , 1000 ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_INT 1000
20950: PPUSH
20951: CALL_OW 234
// if not IsInUnit ( i ) then
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 310
20964: NOT
20965: IFFALSE 21060
// begin if not HasTask ( i ) then
20967: LD_VAR 0 1
20971: PPUSH
20972: CALL_OW 314
20976: NOT
20977: IFFALSE 20994
// ComMoveXY ( i , 64 , 93 ) ;
20979: LD_VAR 0 1
20983: PPUSH
20984: LD_INT 64
20986: PPUSH
20987: LD_INT 93
20989: PPUSH
20990: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20994: LD_VAR 0 4
20998: NOT
20999: PUSH
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 258
21009: PUSH
21010: LD_INT 1
21012: EQUAL
21013: AND
21014: IFFALSE 21060
// begin retreat := true ;
21016: LD_ADDR_VAR 0 4
21020: PUSH
21021: LD_INT 1
21023: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21024: LD_VAR 0 1
21028: PPUSH
21029: LD_INT 2
21031: PPUSH
21032: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21036: LD_VAR 0 1
21040: PPUSH
21041: LD_STRING D4a-Sol1-1
21043: PPUSH
21044: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21048: LD_EXP 60
21052: PPUSH
21053: LD_STRING D4a-Pow-1
21055: PPUSH
21056: CALL_OW 88
// end ; end ; end ;
21060: GO 20925
21062: POP
21063: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21064: LD_EXP 18
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: LD_INT 95
21075: PUSH
21076: LD_INT 9
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 55
21088: PUSH
21089: EMPTY
21090: LIST
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PPUSH
21100: CALL_OW 72
21104: PUSH
21105: LD_INT 4
21107: GREATEREQUAL
21108: IFFALSE 20904
// for i in powellSquadAttack [ 1 ] do
21110: LD_ADDR_VAR 0 1
21114: PUSH
21115: LD_EXP 18
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PUSH
21124: FOR_IN
21125: IFFALSE 21261
// begin if GetTag ( i ) = 2 then
21127: LD_VAR 0 1
21131: PPUSH
21132: CALL_OW 110
21136: PUSH
21137: LD_INT 2
21139: EQUAL
21140: IFFALSE 21202
// begin ComMoveXY ( i , 60 , 94 ) ;
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 60
21149: PPUSH
21150: LD_INT 94
21152: PPUSH
21153: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21157: LD_VAR 0 1
21161: PPUSH
21162: LD_EXP 60
21166: PPUSH
21167: CALL_OW 179
// wait ( 0 0$3 ) ;
21171: LD_INT 105
21173: PPUSH
21174: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21178: LD_VAR 0 1
21182: PPUSH
21183: LD_STRING D4a-Sol1-2
21185: PPUSH
21186: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21190: LD_EXP 60
21194: PPUSH
21195: LD_STRING D4a-Pow-2
21197: PPUSH
21198: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_INT 0
21209: PPUSH
21210: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21214: LD_ADDR_EXP 100
21218: PUSH
21219: LD_EXP 100
21223: PPUSH
21224: LD_INT 4
21226: PPUSH
21227: LD_EXP 100
21231: PUSH
21232: LD_INT 4
21234: ARRAY
21235: PUSH
21236: LD_VAR 0 1
21240: UNION
21241: PPUSH
21242: CALL_OW 1
21246: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21247: LD_INT 8
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: CALL_OW 472
// end ;
21259: GO 21124
21261: POP
21262: POP
// wait ( 2 2$00 ) ;
21263: LD_INT 4200
21265: PPUSH
21266: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21270: LD_ADDR_VAR 0 9
21274: PUSH
21275: LD_INT 22
21277: PUSH
21278: LD_INT 4
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 30
21287: PUSH
21288: LD_INT 32
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: PUSH
21295: LD_INT 58
21297: PUSH
21298: EMPTY
21299: LIST
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: LIST
21305: PPUSH
21306: CALL_OW 69
21310: ST_TO_ADDR
// if tmp then
21311: LD_VAR 0 2
21315: IFFALSE 21555
// begin for i := 1 to tmp do
21317: LD_ADDR_VAR 0 1
21321: PUSH
21322: DOUBLE
21323: LD_INT 1
21325: DEC
21326: ST_TO_ADDR
21327: LD_VAR 0 2
21331: PUSH
21332: FOR_TO
21333: IFFALSE 21546
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21335: LD_ADDR_EXP 100
21339: PUSH
21340: LD_EXP 100
21344: PPUSH
21345: LD_INT 4
21347: PPUSH
21348: LD_EXP 100
21352: PUSH
21353: LD_INT 4
21355: ARRAY
21356: PUSH
21357: LD_VAR 0 2
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: DIFF
21368: PPUSH
21369: CALL_OW 1
21373: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21374: LD_ADDR_VAR 0 10
21378: PUSH
21379: LD_VAR 0 2
21383: PUSH
21384: LD_VAR 0 1
21388: ARRAY
21389: PPUSH
21390: CALL_OW 310
21394: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21395: LD_VAR 0 10
21399: PUSH
21400: LD_VAR 0 10
21404: PPUSH
21405: CALL_OW 266
21409: PUSH
21410: LD_INT 32
21412: EQUAL
21413: AND
21414: IFFALSE 21418
// continue ;
21416: GO 21332
// if t then
21418: LD_VAR 0 10
21422: IFFALSE 21439
// ComExitBuilding ( tmp [ i ] ) ;
21424: LD_VAR 0 2
21428: PUSH
21429: LD_VAR 0 1
21433: ARRAY
21434: PPUSH
21435: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21439: LD_VAR 0 2
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: LD_VAR 0 5
21454: PUSH
21455: LD_INT 1
21457: ARRAY
21458: PPUSH
21459: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21463: LD_VAR 0 2
21467: PUSH
21468: LD_VAR 0 1
21472: ARRAY
21473: PPUSH
21474: LD_INT 1
21476: PPUSH
21477: CALL_OW 183
// if emptyTowers then
21481: LD_VAR 0 9
21485: IFFALSE 21544
// begin AddComExitBuilding ( tmp [ i ] ) ;
21487: LD_VAR 0 2
21491: PUSH
21492: LD_VAR 0 1
21496: ARRAY
21497: PPUSH
21498: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21502: LD_VAR 0 2
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: LD_VAR 0 9
21517: PUSH
21518: LD_INT 1
21520: ARRAY
21521: PPUSH
21522: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21526: LD_ADDR_VAR 0 9
21530: PUSH
21531: LD_VAR 0 9
21535: PPUSH
21536: LD_INT 1
21538: PPUSH
21539: CALL_OW 3
21543: ST_TO_ADDR
// end ; end ;
21544: GO 21332
21546: POP
21547: POP
// wait ( 0 0$30 ) ;
21548: LD_INT 1050
21550: PPUSH
21551: CALL_OW 67
// end ; uc_side := 6 ;
21555: LD_ADDR_OWVAR 20
21559: PUSH
21560: LD_INT 6
21562: ST_TO_ADDR
// uc_nation := 3 ;
21563: LD_ADDR_OWVAR 21
21567: PUSH
21568: LD_INT 3
21570: ST_TO_ADDR
// ru := [ ] ;
21571: LD_ADDR_VAR 0 7
21575: PUSH
21576: EMPTY
21577: ST_TO_ADDR
// for i = 1 to 5 do
21578: LD_ADDR_VAR 0 1
21582: PUSH
21583: DOUBLE
21584: LD_INT 1
21586: DEC
21587: ST_TO_ADDR
21588: LD_INT 5
21590: PUSH
21591: FOR_TO
21592: IFFALSE 21712
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21594: LD_INT 22
21596: PUSH
21597: LD_INT 23
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 1
21606: PPUSH
21607: LD_INT 2
21609: PPUSH
21610: CALL_OW 12
21614: ARRAY
21615: PPUSH
21616: LD_INT 1
21618: PPUSH
21619: LD_INT 3
21621: PPUSH
21622: LD_INT 43
21624: PUSH
21625: LD_INT 44
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 1
21634: PPUSH
21635: LD_INT 2
21637: PPUSH
21638: CALL_OW 12
21642: ARRAY
21643: PPUSH
21644: LD_INT 89
21646: PPUSH
21647: CALL 72525 0 5
// un := CreateVehicle ;
21651: LD_ADDR_VAR 0 8
21655: PUSH
21656: CALL_OW 45
21660: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21661: LD_VAR 0 8
21665: PPUSH
21666: LD_INT 4
21668: PPUSH
21669: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21673: LD_VAR 0 8
21677: PPUSH
21678: LD_INT 136
21680: PPUSH
21681: LD_INT 90
21683: PPUSH
21684: LD_INT 8
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 50
// ru := ru ^ un ;
21694: LD_ADDR_VAR 0 7
21698: PUSH
21699: LD_VAR 0 7
21703: PUSH
21704: LD_VAR 0 8
21708: ADD
21709: ST_TO_ADDR
// end ;
21710: GO 21591
21712: POP
21713: POP
// if ru then
21714: LD_VAR 0 7
21718: IFFALSE 21735
// ComAgressiveMove ( ru , 57 , 94 ) ;
21720: LD_VAR 0 7
21724: PPUSH
21725: LD_INT 57
21727: PPUSH
21728: LD_INT 94
21730: PPUSH
21731: CALL_OW 114
// wait ( 3 3$00 ) ;
21735: LD_INT 6300
21737: PPUSH
21738: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21742: LD_INT 4
21744: PPUSH
21745: LD_INT 3
21747: PUSH
21748: LD_INT 1
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 5
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 4
21765: PUSH
21766: LD_INT 1
21768: PUSH
21769: LD_INT 1
21771: PUSH
21772: LD_INT 6
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 4
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: LD_INT 1
21789: PUSH
21790: LD_INT 7
21792: PUSH
21793: EMPTY
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 3
21801: PUSH
21802: LD_INT 1
21804: PUSH
21805: LD_INT 1
21807: PUSH
21808: LD_INT 7
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: PUSH
21817: LD_INT 3
21819: PUSH
21820: LD_INT 1
21822: PUSH
21823: LD_INT 1
21825: PUSH
21826: LD_INT 5
21828: PUSH
21829: EMPTY
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: PPUSH
21842: CALL 61074 0 2
// missionStage := 4 ;
21846: LD_ADDR_EXP 15
21850: PUSH
21851: LD_INT 4
21853: ST_TO_ADDR
// end ;
21854: PPOPN 10
21856: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21857: LD_EXP 15
21861: PUSH
21862: LD_INT 4
21864: EQUAL
21865: PUSH
21866: LD_INT 22
21868: PUSH
21869: LD_INT 4
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: LD_INT 21
21878: PUSH
21879: LD_INT 2
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: EMPTY
21887: LIST
21888: LIST
21889: PPUSH
21890: CALL_OW 69
21894: PUSH
21895: LD_INT 5
21897: GREATEREQUAL
21898: AND
21899: IFFALSE 26112
21901: GO 21903
21903: DISABLE
21904: LD_INT 0
21906: PPUSH
21907: PPUSH
21908: PPUSH
21909: PPUSH
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
// begin wait ( 0 0$10 ) ;
21919: LD_INT 350
21921: PPUSH
21922: CALL_OW 67
// missionStage := 5 ;
21926: LD_ADDR_EXP 15
21930: PUSH
21931: LD_INT 5
21933: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21934: LD_ADDR_VAR 0 10
21938: PUSH
21939: LD_INT 22
21941: PUSH
21942: LD_INT 4
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PPUSH
21981: CALL_OW 69
21985: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21986: LD_ADDR_VAR 0 6
21990: PUSH
21991: LD_INT 22
21993: PUSH
21994: LD_INT 4
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 1
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: LD_INT 3
22013: PUSH
22014: LD_INT 25
22016: PUSH
22017: LD_INT 16
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 3
22030: PUSH
22031: LD_INT 25
22033: PUSH
22034: LD_INT 12
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 69
22055: PUSH
22056: LD_EXP 60
22060: DIFF
22061: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22062: LD_ADDR_VAR 0 9
22066: PUSH
22067: LD_INT 22
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PPUSH
22091: CALL_OW 69
22095: PUSH
22096: LD_INT 1
22098: ARRAY
22099: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22100: LD_INT 350
22102: PPUSH
22103: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22107: LD_EXP 119
22111: PUSH
22112: LD_INT 4
22114: ARRAY
22115: PUSH
22116: LD_INT 5
22118: LESS
22119: PUSH
22120: LD_VAR 0 9
22124: PPUSH
22125: CALL_OW 461
22129: PUSH
22130: LD_INT 2
22132: EQUAL
22133: AND
22134: IFFALSE 22164
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22136: LD_INT 4
22138: PPUSH
22139: LD_INT 3
22141: PUSH
22142: LD_INT 1
22144: PUSH
22145: LD_INT 1
22147: PUSH
22148: LD_INT 5
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: PPUSH
22160: CALL 61122 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22164: LD_EXP 119
22168: PUSH
22169: LD_INT 4
22171: ARRAY
22172: PUSH
22173: LD_INT 5
22175: GREATEREQUAL
22176: PUSH
22177: LD_EXP 119
22181: PUSH
22182: LD_INT 4
22184: ARRAY
22185: PPUSH
22186: LD_INT 58
22188: PUSH
22189: EMPTY
22190: LIST
22191: PPUSH
22192: CALL_OW 72
22196: PUSH
22197: LD_INT 5
22199: GREATEREQUAL
22200: AND
22201: IFFALSE 22100
// powellAllowRetreat := false ;
22203: LD_ADDR_EXP 19
22207: PUSH
22208: LD_INT 0
22210: ST_TO_ADDR
// activeAttacks := false ;
22211: LD_ADDR_EXP 16
22215: PUSH
22216: LD_INT 0
22218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22226: LD_INT 22
22228: PUSH
22229: LD_INT 6
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PPUSH
22236: CALL_OW 69
22240: PUSH
22241: LD_INT 0
22243: EQUAL
22244: IFFALSE 22219
// tmp := mc_vehicles [ 4 ] ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_EXP 119
22255: PUSH
22256: LD_INT 4
22258: ARRAY
22259: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22260: LD_ADDR_VAR 0 1
22264: PUSH
22265: DOUBLE
22266: LD_INT 1
22268: DEC
22269: ST_TO_ADDR
22270: LD_EXP 18
22274: PUSH
22275: FOR_TO
22276: IFFALSE 22537
// begin for j in powellSquadAttack [ i ] do
22278: LD_ADDR_VAR 0 2
22282: PUSH
22283: LD_EXP 18
22287: PUSH
22288: LD_VAR 0 1
22292: ARRAY
22293: PUSH
22294: FOR_IN
22295: IFFALSE 22533
// begin forces := forces diff j ;
22297: LD_ADDR_VAR 0 6
22301: PUSH
22302: LD_VAR 0 6
22306: PUSH
22307: LD_VAR 0 2
22311: DIFF
22312: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_INT 1
22320: PPUSH
22321: CALL_OW 109
// wait ( 0 0$2 ) ;
22325: LD_INT 70
22327: PPUSH
22328: CALL_OW 67
// if IsInUnit ( j ) then
22332: LD_VAR 0 2
22336: PPUSH
22337: CALL_OW 310
22341: IFFALSE 22352
// ComExitBuilding ( j ) ;
22343: LD_VAR 0 2
22347: PPUSH
22348: CALL_OW 122
// if GetClass ( j ) <> 1 then
22352: LD_VAR 0 2
22356: PPUSH
22357: CALL_OW 257
22361: PUSH
22362: LD_INT 1
22364: NONEQUAL
22365: IFFALSE 22445
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22367: LD_VAR 0 10
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 313
22380: PUSH
22381: LD_INT 5
22383: GREATEREQUAL
22384: IFFALSE 22406
// AddComEnterUnit ( j , arm [ 2 ] ) else
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_VAR 0 10
22395: PUSH
22396: LD_INT 2
22398: ARRAY
22399: PPUSH
22400: CALL_OW 180
22404: GO 22424
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22406: LD_VAR 0 2
22410: PPUSH
22411: LD_VAR 0 10
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22424: LD_VAR 0 2
22428: PPUSH
22429: LD_INT 1
22431: PPUSH
22432: CALL_OW 183
// AddComExitBuilding ( j ) ;
22436: LD_VAR 0 2
22440: PPUSH
22441: CALL_OW 182
// end ; if i = 2 then
22445: LD_VAR 0 1
22449: PUSH
22450: LD_INT 2
22452: EQUAL
22453: IFFALSE 22470
// AddComMoveXY ( j , 61 , 93 ) ;
22455: LD_VAR 0 2
22459: PPUSH
22460: LD_INT 61
22462: PPUSH
22463: LD_INT 93
22465: PPUSH
22466: CALL_OW 171
// if i = 1 then
22470: LD_VAR 0 1
22474: PUSH
22475: LD_INT 1
22477: EQUAL
22478: IFFALSE 22531
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22480: LD_VAR 0 2
22484: PPUSH
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 1
22492: ARRAY
22493: PPUSH
22494: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_VAR 0 3
22507: PPUSH
22508: LD_INT 1
22510: PPUSH
22511: CALL_OW 3
22515: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22516: LD_VAR 0 2
22520: PPUSH
22521: LD_INT 69
22523: PPUSH
22524: LD_INT 94
22526: PPUSH
22527: CALL_OW 171
// end ; end ;
22531: GO 22294
22533: POP
22534: POP
// end ;
22535: GO 22275
22537: POP
22538: POP
// wait ( 0 0$30 ) ;
22539: LD_INT 1050
22541: PPUSH
22542: CALL_OW 67
// MC_Kill ( 4 ) ;
22546: LD_INT 4
22548: PPUSH
22549: CALL 37095 0 1
// tmp := UnitsInside ( fac ) ;
22553: LD_ADDR_VAR 0 3
22557: PUSH
22558: LD_VAR 0 9
22562: PPUSH
22563: CALL_OW 313
22567: ST_TO_ADDR
// if tmp then
22568: LD_VAR 0 3
22572: IFFALSE 22693
// for i in tmp do
22574: LD_ADDR_VAR 0 1
22578: PUSH
22579: LD_VAR 0 3
22583: PUSH
22584: FOR_IN
22585: IFFALSE 22691
// begin ComExitBuilding ( i ) ;
22587: LD_VAR 0 1
22591: PPUSH
22592: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22596: LD_VAR 0 10
22600: PUSH
22601: LD_INT 2
22603: ARRAY
22604: PPUSH
22605: CALL_OW 313
22609: PUSH
22610: LD_INT 6
22612: LESS
22613: IFFALSE 22635
// AddComEnterUnit ( i , arm [ 2 ] ) else
22615: LD_VAR 0 1
22619: PPUSH
22620: LD_VAR 0 10
22624: PUSH
22625: LD_INT 2
22627: ARRAY
22628: PPUSH
22629: CALL_OW 180
22633: GO 22689
// if UnitsInside ( arm [ 1 ] ) < 6 then
22635: LD_VAR 0 10
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 313
22648: PUSH
22649: LD_INT 6
22651: LESS
22652: IFFALSE 22674
// AddComEnterUnit ( i , arm [ 1 ] ) else
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 10
22663: PUSH
22664: LD_INT 1
22666: ARRAY
22667: PPUSH
22668: CALL_OW 180
22672: GO 22689
// AddComMoveXY ( i , 37 , 68 ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_INT 37
22681: PPUSH
22682: LD_INT 68
22684: PPUSH
22685: CALL_OW 171
// end ;
22689: GO 22584
22691: POP
22692: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22693: LD_ADDR_VAR 0 11
22697: PUSH
22698: LD_VAR 0 6
22702: PPUSH
22703: LD_INT 26
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_EXP 61
22722: DIFF
22723: ST_TO_ADDR
// if not speaker then
22724: LD_VAR 0 11
22728: NOT
22729: IFFALSE 22756
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22731: LD_ADDR_VAR 0 11
22735: PUSH
22736: LD_VAR 0 6
22740: PPUSH
22741: LD_INT 26
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 72
22755: ST_TO_ADDR
// if speaker then
22756: LD_VAR 0 11
22760: IFFALSE 22776
// speaker := speaker [ 1 ] ;
22762: LD_ADDR_VAR 0 11
22766: PUSH
22767: LD_VAR 0 11
22771: PUSH
22772: LD_INT 1
22774: ARRAY
22775: ST_TO_ADDR
// Video ( true ) ;
22776: LD_INT 1
22778: PPUSH
22779: CALL 104931 0 1
// CenterNowOnUnits ( Powell ) ;
22783: LD_EXP 60
22787: PPUSH
22788: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22792: LD_ADDR_VAR 0 3
22796: PUSH
22797: LD_VAR 0 6
22801: PPUSH
22802: LD_INT 3
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 1
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 72
22823: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_INT 22
22831: PUSH
22832: LD_INT 4
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 30
22841: PUSH
22842: LD_INT 32
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: LD_INT 58
22851: PUSH
22852: EMPTY
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 69
22864: ST_TO_ADDR
// for i := 1 to 4 do
22865: LD_ADDR_VAR 0 1
22869: PUSH
22870: DOUBLE
22871: LD_INT 1
22873: DEC
22874: ST_TO_ADDR
22875: LD_INT 4
22877: PUSH
22878: FOR_TO
22879: IFFALSE 23020
// begin if IsInUnit ( tmp [ i ] ) then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_VAR 0 1
22890: ARRAY
22891: PPUSH
22892: CALL_OW 310
22896: IFFALSE 22913
// ComExitBuilding ( tmp [ i ] ) ;
22898: LD_VAR 0 3
22902: PUSH
22903: LD_VAR 0 1
22907: ARRAY
22908: PPUSH
22909: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22913: LD_VAR 0 3
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_VAR 0 10
22928: PUSH
22929: LD_INT 1
22931: ARRAY
22932: PPUSH
22933: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22937: LD_VAR 0 3
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 1
22950: PPUSH
22951: CALL_OW 183
// if emp_towers then
22955: LD_VAR 0 12
22959: IFFALSE 23018
// begin AddComExitBuilding ( tmp [ i ] ) ;
22961: LD_VAR 0 3
22965: PUSH
22966: LD_VAR 0 1
22970: ARRAY
22971: PPUSH
22972: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_VAR 0 1
22985: ARRAY
22986: PPUSH
22987: LD_VAR 0 12
22991: PUSH
22992: LD_INT 1
22994: ARRAY
22995: PPUSH
22996: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23000: LD_ADDR_VAR 0 12
23004: PUSH
23005: LD_VAR 0 12
23009: PPUSH
23010: LD_INT 1
23012: PPUSH
23013: CALL_OW 3
23017: ST_TO_ADDR
// end ; end ;
23018: GO 22878
23020: POP
23021: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_EXP 18
23031: PUSH
23032: LD_INT 1
23034: ARRAY
23035: PUSH
23036: LD_EXP 18
23040: PUSH
23041: LD_INT 2
23043: ARRAY
23044: ADD
23045: PPUSH
23046: LD_INT 26
23048: PUSH
23049: LD_INT 1
23051: PUSH
23052: EMPTY
23053: LIST
23054: LIST
23055: PPUSH
23056: CALL_OW 72
23060: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23061: LD_ADDR_VAR 0 1
23065: PUSH
23066: LD_EXP 18
23070: PUSH
23071: LD_INT 2
23073: ARRAY
23074: PUSH
23075: FOR_IN
23076: IFFALSE 23094
// ComTurnUnit ( i , Powell ) ;
23078: LD_VAR 0 1
23082: PPUSH
23083: LD_EXP 60
23087: PPUSH
23088: CALL_OW 119
23092: GO 23075
23094: POP
23095: POP
// Say ( Powell , D5-Pow-1 ) ;
23096: LD_EXP 60
23100: PPUSH
23101: LD_STRING D5-Pow-1
23103: PPUSH
23104: CALL_OW 88
// if tmp then
23108: LD_VAR 0 3
23112: IFFALSE 23130
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 1
23121: ARRAY
23122: PPUSH
23123: LD_STRING D5-Sol2-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23130: LD_EXP 60
23134: PPUSH
23135: LD_STRING D5-Pow-2
23137: PPUSH
23138: CALL_OW 88
// if tmp > 1 then
23142: LD_VAR 0 3
23146: PUSH
23147: LD_INT 1
23149: GREATER
23150: IFFALSE 23168
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23152: LD_VAR 0 3
23156: PUSH
23157: LD_INT 2
23159: ARRAY
23160: PPUSH
23161: LD_STRING D5-Sol2-2
23163: PPUSH
23164: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23168: LD_EXP 60
23172: PPUSH
23173: LD_STRING D5-Pow-3
23175: PPUSH
23176: CALL_OW 88
// wait ( 0 0$1 ) ;
23180: LD_INT 35
23182: PPUSH
23183: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23187: LD_ADDR_VAR 0 3
23191: PUSH
23192: LD_EXP 18
23196: PUSH
23197: LD_INT 1
23199: ARRAY
23200: PUSH
23201: LD_EXP 18
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: UNION
23210: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23211: LD_VAR 0 3
23215: PPUSH
23216: LD_INT 80
23218: PPUSH
23219: LD_INT 67
23221: PPUSH
23222: CALL_OW 114
// wait ( 0 0$2 ) ;
23226: LD_INT 70
23228: PPUSH
23229: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23233: LD_INT 79
23235: PPUSH
23236: LD_INT 72
23238: PPUSH
23239: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23243: LD_INT 70
23245: PPUSH
23246: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23250: LD_VAR 0 3
23254: PPUSH
23255: LD_INT 3
23257: PUSH
23258: LD_INT 24
23260: PUSH
23261: LD_INT 1000
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PPUSH
23272: CALL_OW 72
23276: IFFALSE 23243
// Say ( Powell , D5a-Pow-1 ) ;
23278: LD_EXP 60
23282: PPUSH
23283: LD_STRING D5a-Pow-1
23285: PPUSH
23286: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23290: LD_EXP 60
23294: PPUSH
23295: LD_STRING D5a-Pow-1a
23297: PPUSH
23298: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23302: LD_INT 24
23304: PPUSH
23305: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23309: LD_EXP 60
23313: PPUSH
23314: LD_STRING D5a-Pow-1b
23316: PPUSH
23317: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23321: LD_INT 10
23323: PPUSH
23324: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23328: LD_EXP 60
23332: PPUSH
23333: LD_STRING D5a-Pow-1c
23335: PPUSH
23336: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23340: LD_VAR 0 3
23344: PPUSH
23345: LD_INT 68
23347: PPUSH
23348: LD_INT 63
23350: PPUSH
23351: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23355: LD_INT 18
23357: PPUSH
23358: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23362: LD_EXP 60
23366: PPUSH
23367: LD_STRING D5a-Pow-1d
23369: PPUSH
23370: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if not HasTask ( tmp ) then
23381: LD_VAR 0 3
23385: PPUSH
23386: CALL_OW 314
23390: NOT
23391: IFFALSE 23408
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23393: LD_VAR 0 3
23397: PPUSH
23398: LD_INT 68
23400: PPUSH
23401: LD_INT 63
23403: PPUSH
23404: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23408: LD_VAR 0 3
23412: PPUSH
23413: LD_INT 24
23415: PUSH
23416: LD_INT 1
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 72
23427: NOT
23428: IFFALSE 23374
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_INT 22
23437: PUSH
23438: LD_INT 4
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 92
23447: PUSH
23448: LD_INT 60
23450: PUSH
23451: LD_INT 93
23453: PUSH
23454: LD_INT 10
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 3
23465: PUSH
23466: LD_INT 54
23468: PUSH
23469: EMPTY
23470: LIST
23471: PUSH
23472: EMPTY
23473: LIST
23474: LIST
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: LIST
23480: PPUSH
23481: CALL_OW 69
23485: PUSH
23486: LD_EXP 60
23490: DIFF
23491: ST_TO_ADDR
// if tmp then
23492: LD_VAR 0 3
23496: IFFALSE 23530
// for i in tmp do
23498: LD_ADDR_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: PUSH
23508: FOR_IN
23509: IFFALSE 23528
// ComMoveXY ( i , 36 , 67 ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: LD_INT 36
23518: PPUSH
23519: LD_INT 67
23521: PPUSH
23522: CALL_OW 111
23526: GO 23508
23528: POP
23529: POP
// wait ( 0 0$3 ) ;
23530: LD_INT 105
23532: PPUSH
23533: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23537: LD_VAR 0 11
23541: PPUSH
23542: LD_STRING D6-Sol3-1
23544: PPUSH
23545: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23549: LD_EXP 60
23553: PPUSH
23554: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23558: LD_EXP 60
23562: PPUSH
23563: LD_STRING D6-Pow-1
23565: PPUSH
23566: CALL_OW 88
// tmp := [ ] ;
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: EMPTY
23576: ST_TO_ADDR
// for i = 1 to 2 do
23577: LD_ADDR_VAR 0 1
23581: PUSH
23582: DOUBLE
23583: LD_INT 1
23585: DEC
23586: ST_TO_ADDR
23587: LD_INT 2
23589: PUSH
23590: FOR_TO
23591: IFFALSE 23705
// begin uc_side := 8 ;
23593: LD_ADDR_OWVAR 20
23597: PUSH
23598: LD_INT 8
23600: ST_TO_ADDR
// uc_nation := 2 ;
23601: LD_ADDR_OWVAR 21
23605: PUSH
23606: LD_INT 2
23608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23609: LD_INT 14
23611: PPUSH
23612: LD_INT 3
23614: PPUSH
23615: LD_INT 2
23617: PPUSH
23618: LD_INT 29
23620: PPUSH
23621: LD_INT 100
23623: PPUSH
23624: CALL 72525 0 5
// veh := CreateVehicle ;
23628: LD_ADDR_VAR 0 13
23632: PUSH
23633: CALL_OW 45
23637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23638: LD_VAR 0 13
23642: PPUSH
23643: LD_INT 4
23645: PPUSH
23646: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23650: LD_VAR 0 13
23654: PPUSH
23655: LD_INT 99
23657: PPUSH
23658: LD_INT 83
23660: PPUSH
23661: LD_INT 3
23663: PPUSH
23664: LD_INT 0
23666: PPUSH
23667: CALL_OW 50
// wait ( 3 ) ;
23671: LD_INT 3
23673: PPUSH
23674: CALL_OW 67
// Connect ( veh ) ;
23678: LD_VAR 0 13
23682: PPUSH
23683: CALL 75616 0 1
// tmp := tmp ^ veh ;
23687: LD_ADDR_VAR 0 3
23691: PUSH
23692: LD_VAR 0 3
23696: PUSH
23697: LD_VAR 0 13
23701: ADD
23702: ST_TO_ADDR
// end ;
23703: GO 23590
23705: POP
23706: POP
// wait ( 0 0$1 ) ;
23707: LD_INT 35
23709: PPUSH
23710: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23714: LD_INT 99
23716: PPUSH
23717: LD_INT 83
23719: PPUSH
23720: LD_INT 1
23722: PPUSH
23723: LD_INT 10
23725: PPUSH
23726: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23730: LD_INT 99
23732: PPUSH
23733: LD_INT 83
23735: PPUSH
23736: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23740: LD_VAR 0 11
23744: PPUSH
23745: LD_STRING D6-Sol3-2
23747: PPUSH
23748: CALL_OW 88
// async ;
23752: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23753: LD_EXP 60
23757: PPUSH
23758: LD_STRING D6-Pow-2
23760: PPUSH
23761: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23765: LD_VAR 0 3
23769: PUSH
23770: LD_INT 1
23772: ARRAY
23773: PPUSH
23774: LD_VAR 0 9
23778: PPUSH
23779: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23783: LD_VAR 0 3
23787: PUSH
23788: LD_INT 2
23790: ARRAY
23791: PPUSH
23792: LD_INT 22
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 21
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: PPUSH
23816: CALL_OW 69
23820: PPUSH
23821: LD_VAR 0 3
23825: PUSH
23826: LD_INT 2
23828: ARRAY
23829: PPUSH
23830: CALL_OW 74
23834: PPUSH
23835: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23839: LD_EXP 60
23843: PPUSH
23844: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23848: LD_INT 99
23850: PPUSH
23851: LD_INT 83
23853: PPUSH
23854: LD_INT 1
23856: PPUSH
23857: CALL_OW 331
// repeat wait ( 4 ) ;
23861: LD_INT 4
23863: PPUSH
23864: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23868: LD_VAR 0 3
23872: PUSH
23873: LD_INT 1
23875: ARRAY
23876: PPUSH
23877: CALL_OW 256
23881: PUSH
23882: LD_INT 1000
23884: LESS
23885: IFFALSE 23903
// SetLives ( tmp [ 1 ] , 1000 ) ;
23887: LD_VAR 0 3
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: PPUSH
23896: LD_INT 1000
23898: PPUSH
23899: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23903: LD_INT 22
23905: PUSH
23906: LD_INT 4
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: PUSH
23913: LD_INT 30
23915: PUSH
23916: LD_INT 3
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PPUSH
23927: CALL_OW 69
23931: PUSH
23932: LD_INT 0
23934: EQUAL
23935: IFFALSE 23861
// skirmish := false ;
23937: LD_ADDR_EXP 98
23941: PUSH
23942: LD_INT 0
23944: ST_TO_ADDR
// sync ;
23945: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23946: LD_EXP 60
23950: PPUSH
23951: LD_STRING D6a-Pow-1
23953: PPUSH
23954: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23958: LD_VAR 0 11
23962: PPUSH
23963: LD_STRING D6a-Sol3-1
23965: PPUSH
23966: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23970: LD_EXP 60
23974: PPUSH
23975: LD_STRING D6a-Pow-2
23977: PPUSH
23978: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23982: LD_VAR 0 11
23986: PPUSH
23987: LD_STRING D6a-Sol3-2
23989: PPUSH
23990: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23994: LD_EXP 60
23998: PPUSH
23999: LD_STRING D6a-Pow-3
24001: PPUSH
24002: CALL_OW 88
// powellCenterCameraMode := true ;
24006: LD_ADDR_EXP 20
24010: PUSH
24011: LD_INT 1
24013: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24014: LD_ADDR_VAR 0 1
24018: PUSH
24019: LD_INT 22
24021: PUSH
24022: LD_INT 8
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 25
24031: PUSH
24032: LD_INT 2
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: PPUSH
24043: CALL_OW 69
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24104
// begin SetTag ( i , 1 ) ;
24051: LD_VAR 0 1
24055: PPUSH
24056: LD_INT 1
24058: PPUSH
24059: CALL_OW 109
// ComExitBuilding ( i ) ;
24063: LD_VAR 0 1
24067: PPUSH
24068: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: LD_INT 35
24079: PPUSH
24080: LD_INT 6
24082: PPUSH
24083: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24087: LD_VAR 0 1
24091: PPUSH
24092: LD_INT 53
24094: PPUSH
24095: LD_INT 4
24097: PPUSH
24098: CALL_OW 171
// end ;
24102: GO 24048
24104: POP
24105: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24106: LD_ADDR_VAR 0 3
24110: PUSH
24111: LD_INT 22
24113: PUSH
24114: LD_INT 4
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 21
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 34
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PPUSH
24153: CALL_OW 69
24157: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24158: LD_EXP 60
24162: PPUSH
24163: LD_VAR 0 3
24167: PPUSH
24168: LD_EXP 60
24172: PPUSH
24173: CALL_OW 74
24177: PPUSH
24178: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24182: LD_EXP 60
24186: PPUSH
24187: LD_INT 100
24189: PPUSH
24190: LD_INT 88
24192: PPUSH
24193: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24197: LD_EXP 60
24201: PPUSH
24202: LD_INT 100
24204: PPUSH
24205: LD_INT 75
24207: PPUSH
24208: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24212: LD_EXP 60
24216: PPUSH
24217: LD_INT 88
24219: PPUSH
24220: LD_INT 53
24222: PPUSH
24223: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24227: LD_INT 8
24229: PPUSH
24230: LD_EXP 60
24234: PPUSH
24235: CALL_OW 471
// repeat wait ( 3 ) ;
24239: LD_INT 3
24241: PPUSH
24242: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24246: LD_INT 22
24248: PUSH
24249: LD_INT 4
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: LD_INT 92
24258: PUSH
24259: LD_INT 100
24261: PUSH
24262: LD_INT 75
24264: PUSH
24265: LD_INT 6
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PPUSH
24278: CALL_OW 69
24282: IFFALSE 24239
// async ;
24284: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24285: LD_EXP 60
24289: PPUSH
24290: LD_STRING D6b-Pow-1
24292: PPUSH
24293: CALL_OW 88
// repeat wait ( 3 ) ;
24297: LD_INT 3
24299: PPUSH
24300: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24304: LD_EXP 60
24308: PPUSH
24309: CALL_OW 310
24313: PPUSH
24314: CALL_OW 256
24318: PUSH
24319: LD_INT 1000
24321: LESS
24322: IFFALSE 24341
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24324: LD_EXP 60
24328: PPUSH
24329: CALL_OW 310
24333: PPUSH
24334: LD_INT 1000
24336: PPUSH
24337: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24341: LD_EXP 60
24345: PPUSH
24346: CALL_OW 256
24350: PUSH
24351: LD_INT 1000
24353: LESS
24354: IFFALSE 24368
// SetLives ( Powell , 1000 ) ;
24356: LD_EXP 60
24360: PPUSH
24361: LD_INT 1000
24363: PPUSH
24364: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24368: LD_EXP 60
24372: PPUSH
24373: LD_EXP 65
24377: PPUSH
24378: CALL_OW 296
24382: PUSH
24383: LD_INT 5
24385: LESS
24386: PUSH
24387: LD_EXP 60
24391: PPUSH
24392: CALL_OW 310
24396: PPUSH
24397: LD_EXP 65
24401: PPUSH
24402: CALL_OW 296
24406: PUSH
24407: LD_INT 5
24409: LESS
24410: OR
24411: IFFALSE 24430
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24413: LD_EXP 60
24417: PPUSH
24418: CALL_OW 310
24422: PPUSH
24423: LD_INT 100
24425: PPUSH
24426: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24430: LD_EXP 60
24434: PPUSH
24435: CALL_OW 310
24439: NOT
24440: IFFALSE 24297
// DoNotAttack ( 8 , powellBomb ) ;
24442: LD_INT 8
24444: PPUSH
24445: LD_EXP 65
24449: PPUSH
24450: CALL_OW 471
// game_speed := 4 ;
24454: LD_ADDR_OWVAR 65
24458: PUSH
24459: LD_INT 4
24461: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24462: LD_EXP 60
24466: PPUSH
24467: LD_STRING D6b-Pow-1a
24469: PPUSH
24470: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24474: LD_EXP 60
24478: PPUSH
24479: LD_EXP 65
24483: PPUSH
24484: CALL_OW 180
// sync ;
24488: SYNC
// repeat wait ( 0 0$1 ) ;
24489: LD_INT 35
24491: PPUSH
24492: CALL_OW 67
// until IsInUnit ( Powell ) ;
24496: LD_EXP 60
24500: PPUSH
24501: CALL_OW 310
24505: IFFALSE 24489
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24507: LD_INT 8
24509: PPUSH
24510: LD_EXP 60
24514: PPUSH
24515: CALL_OW 310
24519: PPUSH
24520: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24524: LD_EXP 60
24528: PPUSH
24529: LD_INT 91
24531: PPUSH
24532: LD_INT 44
24534: PPUSH
24535: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24539: LD_EXP 60
24543: PPUSH
24544: LD_INT 96
24546: PPUSH
24547: LD_INT 44
24549: PPUSH
24550: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24554: LD_EXP 60
24558: PPUSH
24559: LD_INT 96
24561: PPUSH
24562: LD_INT 41
24564: PPUSH
24565: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24569: LD_EXP 60
24573: PPUSH
24574: LD_INT 92
24576: PPUSH
24577: LD_INT 39
24579: PPUSH
24580: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24584: LD_EXP 60
24588: PPUSH
24589: LD_INT 88
24591: PPUSH
24592: LD_INT 41
24594: PPUSH
24595: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24599: LD_EXP 60
24603: PPUSH
24604: LD_INT 91
24606: PPUSH
24607: LD_INT 44
24609: PPUSH
24610: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24614: LD_EXP 60
24618: PPUSH
24619: LD_INT 96
24621: PPUSH
24622: LD_INT 44
24624: PPUSH
24625: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24629: LD_EXP 60
24633: PPUSH
24634: LD_INT 96
24636: PPUSH
24637: LD_INT 41
24639: PPUSH
24640: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24644: LD_EXP 60
24648: PPUSH
24649: LD_INT 92
24651: PPUSH
24652: LD_INT 39
24654: PPUSH
24655: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24659: LD_EXP 60
24663: PPUSH
24664: LD_INT 88
24666: PPUSH
24667: LD_INT 41
24669: PPUSH
24670: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24674: LD_EXP 60
24678: PPUSH
24679: LD_INT 91
24681: PPUSH
24682: LD_INT 44
24684: PPUSH
24685: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24689: LD_EXP 60
24693: PPUSH
24694: LD_INT 93
24696: PPUSH
24697: LD_INT 39
24699: PPUSH
24700: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24704: LD_EXP 60
24708: PPUSH
24709: LD_INT 93
24711: PPUSH
24712: LD_INT 36
24714: PPUSH
24715: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24719: LD_INT 122
24721: PPUSH
24722: CALL_OW 67
// game_speed := 4 ;
24726: LD_ADDR_OWVAR 65
24730: PUSH
24731: LD_INT 4
24733: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24734: LD_EXP 60
24738: PPUSH
24739: LD_STRING D6b-Pow-1b
24741: PPUSH
24742: CALL_OW 88
// tmp := [ ] ;
24746: LD_ADDR_VAR 0 3
24750: PUSH
24751: EMPTY
24752: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24753: LD_ADDR_VAR 0 5
24757: PUSH
24758: LD_INT 78
24760: PUSH
24761: LD_INT 47
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 106
24770: PUSH
24771: LD_INT 53
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24782: LD_ADDR_VAR 0 1
24786: PUSH
24787: LD_INT 22
24789: PUSH
24790: LD_INT 8
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 21
24799: PUSH
24800: LD_INT 3
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 92
24809: PUSH
24810: LD_INT 90
24812: PUSH
24813: LD_INT 52
24815: PUSH
24816: LD_INT 12
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PPUSH
24830: CALL_OW 69
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24861
// tmp := tmp ^ UnitsInside ( i ) ;
24838: LD_ADDR_VAR 0 3
24842: PUSH
24843: LD_VAR 0 3
24847: PUSH
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 313
24857: ADD
24858: ST_TO_ADDR
24859: GO 24835
24861: POP
24862: POP
// for i in tmp do
24863: LD_ADDR_VAR 0 1
24867: PUSH
24868: LD_VAR 0 3
24872: PUSH
24873: FOR_IN
24874: IFFALSE 25036
// begin dist := 9999 ;
24876: LD_ADDR_VAR 0 8
24880: PUSH
24881: LD_INT 9999
24883: ST_TO_ADDR
// _xy := [ ] ;
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: EMPTY
24890: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24891: LD_VAR 0 1
24895: PPUSH
24896: LD_INT 1
24898: PPUSH
24899: CALL_OW 109
// ComExitBuilding ( i ) ;
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 122
// for j in xy do
24912: LD_ADDR_VAR 0 2
24916: PUSH
24917: LD_VAR 0 5
24921: PUSH
24922: FOR_IN
24923: IFFALSE 25005
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24925: LD_VAR 0 1
24929: PPUSH
24930: LD_VAR 0 2
24934: PUSH
24935: LD_INT 1
24937: ARRAY
24938: PPUSH
24939: LD_VAR 0 2
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 297
24952: PUSH
24953: LD_VAR 0 8
24957: LESS
24958: IFFALSE 25003
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24960: LD_ADDR_VAR 0 8
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: LD_VAR 0 2
24974: PUSH
24975: LD_INT 1
24977: ARRAY
24978: PPUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 2
24986: ARRAY
24987: PPUSH
24988: CALL_OW 297
24992: ST_TO_ADDR
// _xy := j ;
24993: LD_ADDR_VAR 0 7
24997: PUSH
24998: LD_VAR 0 2
25002: ST_TO_ADDR
// end ;
25003: GO 24922
25005: POP
25006: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25007: LD_VAR 0 1
25011: PPUSH
25012: LD_VAR 0 7
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: PPUSH
25021: LD_VAR 0 7
25025: PUSH
25026: LD_INT 2
25028: ARRAY
25029: PPUSH
25030: CALL_OW 171
// end ;
25034: GO 24873
25036: POP
25037: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25038: LD_ADDR_VAR 0 4
25042: PUSH
25043: LD_VAR 0 3
25047: PPUSH
25048: LD_INT 26
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 25
25060: PUSH
25061: LD_INT 1
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: ST_TO_ADDR
// if tmp2 < 2 then
25077: LD_VAR 0 4
25081: PUSH
25082: LD_INT 2
25084: LESS
25085: IFFALSE 25154
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_INT 22
25094: PUSH
25095: LD_INT 8
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 26
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 3
25114: PUSH
25115: LD_INT 25
25117: PUSH
25118: LD_INT 15
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: PPUSH
25134: CALL_OW 69
25138: PUSH
25139: LD_EXP 62
25143: PUSH
25144: LD_EXP 63
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: DIFF
25153: ST_TO_ADDR
// if tmp2 then
25154: LD_VAR 0 4
25158: IFFALSE 25176
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25160: LD_VAR 0 4
25164: PUSH
25165: LD_INT 1
25167: ARRAY
25168: PPUSH
25169: LD_STRING D6b-ArSol1-1
25171: PPUSH
25172: CALL_OW 88
// async ;
25176: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25177: LD_EXP 60
25181: PPUSH
25182: LD_STRING D6b-Pow-2
25184: PPUSH
25185: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25189: LD_INT 18
25191: PPUSH
25192: CALL_OW 67
// if tmp2 > 1 then
25196: LD_VAR 0 4
25200: PUSH
25201: LD_INT 1
25203: GREATER
25204: IFFALSE 25222
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25206: LD_VAR 0 4
25210: PUSH
25211: LD_INT 2
25213: ARRAY
25214: PPUSH
25215: LD_STRING D6b-ArSol2-1
25217: PPUSH
25218: CALL_OW 88
// sync ;
25222: SYNC
// repeat wait ( 5 ) ;
25223: LD_INT 5
25225: PPUSH
25226: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25230: LD_INT 93
25232: PPUSH
25233: LD_INT 36
25235: PPUSH
25236: CALL_OW 428
25240: PPUSH
25241: CALL_OW 255
25245: PUSH
25246: LD_INT 4
25248: EQUAL
25249: IFFALSE 25223
// DialogueOn ;
25251: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25255: LD_INT 10
25257: PPUSH
25258: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25262: LD_EXP 60
25266: PPUSH
25267: LD_STRING D6b-Pow-2a
25269: PPUSH
25270: CALL_OW 88
// DialogueOff ;
25274: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25278: LD_EXP 60
25282: PPUSH
25283: CALL_OW 310
25287: PPUSH
25288: LD_INT 332
25290: PPUSH
25291: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25295: LD_INT 93
25297: PPUSH
25298: LD_INT 35
25300: PPUSH
25301: LD_INT 1
25303: PPUSH
25304: LD_INT 6
25306: NEG
25307: PPUSH
25308: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25312: LD_INT 35
25314: PPUSH
25315: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25319: LD_INT 332
25321: PPUSH
25322: CALL_OW 256
25326: PUSH
25327: LD_INT 1000
25329: LESS
25330: PUSH
25331: LD_INT 332
25333: PPUSH
25334: CALL_OW 300
25338: AND
25339: IFFALSE 25351
// SetLives ( kozlov_fac , 0 ) ;
25341: LD_INT 332
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25351: LD_INT 332
25353: PPUSH
25354: CALL_OW 301
25358: PUSH
25359: LD_EXP 60
25363: PPUSH
25364: CALL_OW 301
25368: OR
25369: IFFALSE 25312
// game_speed := 4 ;
25371: LD_ADDR_OWVAR 65
25375: PUSH
25376: LD_INT 4
25378: ST_TO_ADDR
// powellCenterCameraMode := false ;
25379: LD_ADDR_EXP 20
25383: PUSH
25384: LD_INT 0
25386: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25387: LD_ADDR_VAR 0 1
25391: PUSH
25392: LD_VAR 0 3
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 8
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 25
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PPUSH
25421: CALL_OW 69
25425: UNION
25426: PUSH
25427: FOR_IN
25428: IFFALSE 25444
// SetTag ( i , 0 ) ;
25430: LD_VAR 0 1
25434: PPUSH
25435: LD_INT 0
25437: PPUSH
25438: CALL_OW 109
25442: GO 25427
25444: POP
25445: POP
// wait ( 0 0$3 ) ;
25446: LD_INT 105
25448: PPUSH
25449: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25453: LD_INT 93
25455: PPUSH
25456: LD_INT 35
25458: PPUSH
25459: LD_INT 1
25461: PPUSH
25462: CALL_OW 331
// DialogueOn ;
25466: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25470: LD_VAR 0 11
25474: PPUSH
25475: LD_STRING D6c-Sol3-1
25477: PPUSH
25478: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25482: LD_INT 10
25484: PPUSH
25485: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25489: LD_EXP 40
25493: PPUSH
25494: LD_STRING D6c-JMM-1
25496: PPUSH
25497: CALL_OW 88
// if Cyrus then
25501: LD_EXP 46
25505: IFFALSE 25519
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25507: LD_EXP 46
25511: PPUSH
25512: LD_STRING D6c-Cyrus-1
25514: PPUSH
25515: CALL_OW 88
// if Bobby then
25519: LD_EXP 45
25523: IFFALSE 25537
// Say ( Bobby , D6c-Bobby-1 ) ;
25525: LD_EXP 45
25529: PPUSH
25530: LD_STRING D6c-Bobby-1
25532: PPUSH
25533: CALL_OW 88
// if Cornel then
25537: LD_EXP 51
25541: IFFALSE 25555
// Say ( Cornel , D6c-Corn-1 ) ;
25543: LD_EXP 51
25547: PPUSH
25548: LD_STRING D6c-Corn-1
25550: PPUSH
25551: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25555: LD_ADDR_VAR 0 4
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 22
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 22
25575: PUSH
25576: LD_INT 4
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 26
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 23
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: LIST
25612: PPUSH
25613: CALL_OW 69
25617: PUSH
25618: LD_VAR 0 11
25622: PUSH
25623: LD_EXP 40
25627: UNION
25628: PUSH
25629: LD_EXP 61
25633: UNION
25634: DIFF
25635: ST_TO_ADDR
// if tmp2 then
25636: LD_VAR 0 4
25640: IFFALSE 25658
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25642: LD_VAR 0 4
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PPUSH
25651: LD_STRING D6c-Sol1-1
25653: PPUSH
25654: CALL_OW 88
// if Lisa then
25658: LD_EXP 43
25662: IFFALSE 25676
// Say ( Lisa , D6c-Lisa-1 ) ;
25664: LD_EXP 43
25668: PPUSH
25669: LD_STRING D6c-Lisa-1
25671: PPUSH
25672: CALL_OW 88
// if Gary then
25676: LD_EXP 52
25680: IFFALSE 25694
// Say ( Gary , D6c-Gary-1 ) ;
25682: LD_EXP 52
25686: PPUSH
25687: LD_STRING D6c-Gary-1
25689: PPUSH
25690: CALL_OW 88
// if Donaldson then
25694: LD_EXP 44
25698: IFFALSE 25712
// Say ( Donaldson , D6c-Don-1 ) ;
25700: LD_EXP 44
25704: PPUSH
25705: LD_STRING D6c-Don-1
25707: PPUSH
25708: CALL_OW 88
// if tmp2 > 1 then
25712: LD_VAR 0 4
25716: PUSH
25717: LD_INT 1
25719: GREATER
25720: IFFALSE 25738
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 2
25729: ARRAY
25730: PPUSH
25731: LD_STRING D6c-Sol2-1
25733: PPUSH
25734: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25738: LD_VAR 0 11
25742: PPUSH
25743: LD_STRING D6c-Sol3-2
25745: PPUSH
25746: CALL_OW 88
// if IsInUnit ( JMM ) then
25750: LD_EXP 40
25754: PPUSH
25755: CALL_OW 310
25759: IFFALSE 25777
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25761: LD_EXP 40
25765: PPUSH
25766: CALL_OW 310
25770: PPUSH
25771: CALL_OW 87
25775: GO 25786
// CenterNowOnUnits ( JMM ) ;
25777: LD_EXP 40
25781: PPUSH
25782: CALL_OW 87
// dwait ( 0 0$2 ) ;
25786: LD_INT 70
25788: PPUSH
25789: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D6c-JMM-2
25800: PPUSH
25801: CALL_OW 88
// DialogueOff ;
25805: CALL_OW 7
// Video ( false ) ;
25809: LD_INT 0
25811: PPUSH
25812: CALL 104931 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25816: LD_INT 22
25818: PUSH
25819: LD_INT 4
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 69
25830: PPUSH
25831: LD_INT 1
25833: PPUSH
25834: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25838: LD_INT 4
25840: PPUSH
25841: LD_INT 4
25843: PPUSH
25844: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25848: LD_ADDR_VAR 0 1
25852: PUSH
25853: LD_INT 4
25855: PPUSH
25856: LD_INT 1
25858: PPUSH
25859: LD_INT 2
25861: PPUSH
25862: CALL 67573 0 3
25866: PUSH
25867: FOR_IN
25868: IFFALSE 25905
// if GetTech ( i , 1 ) <> state_researched then
25870: LD_VAR 0 1
25874: PPUSH
25875: LD_INT 1
25877: PPUSH
25878: CALL_OW 321
25882: PUSH
25883: LD_INT 2
25885: NONEQUAL
25886: IFFALSE 25903
// SetTech ( i , 1 , state_researched ) ;
25888: LD_VAR 0 1
25892: PPUSH
25893: LD_INT 1
25895: PPUSH
25896: LD_INT 2
25898: PPUSH
25899: CALL_OW 322
25903: GO 25867
25905: POP
25906: POP
// missionStage := 6 ;
25907: LD_ADDR_EXP 15
25911: PUSH
25912: LD_INT 6
25914: ST_TO_ADDR
// activeAttacks := true ;
25915: LD_ADDR_EXP 16
25919: PUSH
25920: LD_INT 1
25922: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25923: LD_STRING M2
25925: PPUSH
25926: CALL_OW 337
// SaveForQuickRestart ;
25930: CALL_OW 22
// wait ( 0 0$40 ) ;
25934: LD_INT 1400
25936: PPUSH
25937: CALL_OW 67
// DialogueOn ;
25941: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
25945: LD_EXP 64
25949: PPUSH
25950: LD_STRING D7-Friend-1
25952: PPUSH
25953: CALL 108878 0 2
// Say ( JMM , D7-JMM-1 ) ;
25957: LD_EXP 40
25961: PPUSH
25962: LD_STRING D7-JMM-1
25964: PPUSH
25965: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
25969: LD_EXP 64
25973: PPUSH
25974: LD_STRING D7-Friend-2
25976: PPUSH
25977: CALL 108878 0 2
// Say ( JMM , D7-JMM-2 ) ;
25981: LD_EXP 40
25985: PPUSH
25986: LD_STRING D7-JMM-2
25988: PPUSH
25989: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
25993: LD_EXP 64
25997: PPUSH
25998: LD_STRING D7-Friend-3
26000: PPUSH
26001: CALL 108878 0 2
// Say ( JMM , D7-JMM-3 ) ;
26005: LD_EXP 40
26009: PPUSH
26010: LD_STRING D7-JMM-3
26012: PPUSH
26013: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26017: LD_EXP 64
26021: PPUSH
26022: LD_STRING D7-Friend-4
26024: PPUSH
26025: CALL 108878 0 2
// Say ( JMM , D7-JMM-4 ) ;
26029: LD_EXP 40
26033: PPUSH
26034: LD_STRING D7-JMM-4
26036: PPUSH
26037: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26041: LD_EXP 64
26045: PPUSH
26046: LD_STRING D7-Friend-5
26048: PPUSH
26049: CALL 108878 0 2
// Say ( JMM , D7-JMM-5 ) ;
26053: LD_EXP 40
26057: PPUSH
26058: LD_STRING D7-JMM-5
26060: PPUSH
26061: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26065: LD_EXP 64
26069: PPUSH
26070: LD_STRING D7-Friend-6
26072: PPUSH
26073: CALL 108878 0 2
// Say ( JMM , D7-JMM-6 ) ;
26077: LD_EXP 40
26081: PPUSH
26082: LD_STRING D7-JMM-6
26084: PPUSH
26085: CALL_OW 88
// DialogueOff ;
26089: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26093: LD_STRING Mlegion
26095: PPUSH
26096: CALL_OW 337
// skirmish := true ;
26100: LD_ADDR_EXP 98
26104: PUSH
26105: LD_INT 1
26107: ST_TO_ADDR
// RebuildKozlovFactory ;
26108: CALL 5036 0 0
// end ;
26112: PPOPN 13
26114: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26115: LD_EXP 20
26119: PUSH
26120: LD_EXP 60
26124: PPUSH
26125: CALL_OW 300
26129: AND
26130: IFFALSE 26172
26132: GO 26134
26134: DISABLE
// begin enable ;
26135: ENABLE
// if IsInUnit ( Powell ) then
26136: LD_EXP 60
26140: PPUSH
26141: CALL_OW 310
26145: IFFALSE 26163
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26147: LD_EXP 60
26151: PPUSH
26152: CALL_OW 310
26156: PPUSH
26157: CALL_OW 85
26161: GO 26172
// CenterOnUnits ( Powell ) ;
26163: LD_EXP 60
26167: PPUSH
26168: CALL_OW 85
// end ;
26172: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26173: LD_INT 22
26175: PUSH
26176: LD_INT 8
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 34
26185: PUSH
26186: LD_INT 48
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL_OW 69
26201: IFFALSE 26475
26203: GO 26205
26205: DISABLE
26206: LD_INT 0
26208: PPUSH
26209: PPUSH
// begin if missionStage < 9 then
26210: LD_EXP 15
26214: PUSH
26215: LD_INT 9
26217: LESS
26218: IFFALSE 26228
// missionStage := 9 ;
26220: LD_ADDR_EXP 15
26224: PUSH
26225: LD_INT 9
26227: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26228: LD_ADDR_VAR 0 1
26232: PUSH
26233: LD_INT 22
26235: PUSH
26236: LD_INT 8
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 34
26245: PUSH
26246: LD_INT 48
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PPUSH
26257: CALL_OW 69
26261: PUSH
26262: LD_INT 1
26264: ARRAY
26265: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26266: LD_INT 175
26268: PPUSH
26269: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26273: LD_EXP 12
26277: PUSH
26278: LD_EXP 3
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: LD_INT 2
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: IN
26293: OR
26294: IFFALSE 26317
// target := [ 68 , 108 , 1 ] else
26296: LD_ADDR_VAR 0 2
26300: PUSH
26301: LD_INT 68
26303: PUSH
26304: LD_INT 108
26306: PUSH
26307: LD_INT 1
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: LIST
26314: ST_TO_ADDR
26315: GO 26336
// target := [ 181 , 88 , 2 ] ;
26317: LD_ADDR_VAR 0 2
26321: PUSH
26322: LD_INT 181
26324: PUSH
26325: LD_INT 88
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26336: LD_VAR 0 1
26340: PPUSH
26341: LD_VAR 0 2
26345: PUSH
26346: LD_INT 1
26348: ARRAY
26349: PPUSH
26350: LD_VAR 0 2
26354: PUSH
26355: LD_INT 2
26357: ARRAY
26358: PPUSH
26359: CALL_OW 176
// if target [ 3 ] = 1 then
26363: LD_VAR 0 2
26367: PUSH
26368: LD_INT 3
26370: ARRAY
26371: PUSH
26372: LD_INT 1
26374: EQUAL
26375: IFFALSE 26391
// SayRadio ( Kurt , D12-Kurt-1 ) else
26377: LD_EXP 62
26381: PPUSH
26382: LD_STRING D12-Kurt-1
26384: PPUSH
26385: CALL_OW 94
26389: GO 26415
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26391: LD_EXP 62
26395: PPUSH
26396: LD_STRING D12a-Kurt-1
26398: PPUSH
26399: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26403: LD_EXP 77
26407: PPUSH
26408: LD_STRING D12a-Roth-1
26410: PPUSH
26411: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26415: LD_INT 350
26417: PPUSH
26418: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26422: LD_VAR 0 1
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 8
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 23
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 30
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PPUSH
26462: CALL_OW 69
26466: PUSH
26467: LD_INT 1
26469: ARRAY
26470: PPUSH
26471: CALL_OW 228
// end ;
26475: PPOPN 2
26477: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26478: LD_EXP 62
26482: PPUSH
26483: CALL_OW 256
26487: PUSH
26488: LD_INT 999
26490: LESS
26491: PUSH
26492: LD_INT 22
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 21
26504: PUSH
26505: LD_INT 1
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 23
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 69
26531: PUSH
26532: LD_INT 9
26534: PUSH
26535: LD_INT 8
26537: PUSH
26538: LD_INT 7
26540: PUSH
26541: LD_INT 6
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: PUSH
26550: LD_OWVAR 67
26554: ARRAY
26555: LESSEQUAL
26556: OR
26557: PUSH
26558: LD_INT 22
26560: PUSH
26561: LD_INT 8
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 34
26570: PUSH
26571: LD_INT 48
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 69
26586: NOT
26587: AND
26588: PUSH
26589: LD_EXP 62
26593: PPUSH
26594: CALL_OW 302
26598: AND
26599: PUSH
26600: LD_INT 5
26602: PPUSH
26603: LD_INT 22
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 70
26617: AND
26618: IFFALSE 27362
26620: GO 26622
26622: DISABLE
26623: LD_INT 0
26625: PPUSH
26626: PPUSH
26627: PPUSH
// begin legionDestroyed := true ;
26628: LD_ADDR_EXP 22
26632: PUSH
26633: LD_INT 1
26635: ST_TO_ADDR
// DialogueOn ;
26636: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26640: LD_EXP 40
26644: PPUSH
26645: LD_STRING D13-JMM-1
26647: PPUSH
26648: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26652: LD_EXP 62
26656: PPUSH
26657: LD_STRING D13-Kurt-1
26659: PPUSH
26660: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26664: LD_EXP 40
26668: PPUSH
26669: LD_STRING D13-JMM-2
26671: PPUSH
26672: CALL_OW 88
// if FakeInfo then
26676: LD_EXP 12
26680: IFFALSE 26700
// begin Say ( Kurt , D13-Kurt-2 ) ;
26682: LD_EXP 62
26686: PPUSH
26687: LD_STRING D13-Kurt-2
26689: PPUSH
26690: CALL_OW 88
// DialogueOff ;
26694: CALL_OW 7
// exit ;
26698: GO 27362
// end ; if not KurtStatus then
26700: LD_EXP 3
26704: NOT
26705: IFFALSE 26721
// Say ( Kurt , D13-Kurt-2b ) else
26707: LD_EXP 62
26711: PPUSH
26712: LD_STRING D13-Kurt-2b
26714: PPUSH
26715: CALL_OW 88
26719: GO 26733
// Say ( Kurt , D13-Kurt-2a ) ;
26721: LD_EXP 62
26725: PPUSH
26726: LD_STRING D13-Kurt-2a
26728: PPUSH
26729: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26733: LD_EXP 40
26737: PPUSH
26738: LD_STRING D13-JMM-3
26740: PPUSH
26741: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26745: LD_EXP 62
26749: PPUSH
26750: LD_STRING D13-Kurt-3
26752: PPUSH
26753: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26757: LD_EXP 40
26761: PPUSH
26762: LD_STRING D13-JMM-4
26764: PPUSH
26765: CALL_OW 88
// DialogueOff ;
26769: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26773: LD_STRING MlegionOut
26775: PPUSH
26776: CALL_OW 337
// MC_Kill ( 3 ) ;
26780: LD_INT 3
26782: PPUSH
26783: CALL 37095 0 1
// KillUnit ( Kozlov ) ;
26787: LD_EXP 63
26791: PPUSH
26792: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26796: LD_ADDR_VAR 0 1
26800: PUSH
26801: LD_INT 22
26803: PUSH
26804: LD_INT 8
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 23
26813: PUSH
26814: LD_INT 3
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 3
26823: PUSH
26824: LD_INT 21
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 69
26847: PUSH
26848: FOR_IN
26849: IFFALSE 26862
// KillUnit ( i ) ;
26851: LD_VAR 0 1
26855: PPUSH
26856: CALL_OW 66
26860: GO 26848
26862: POP
26863: POP
// ChangeSideFog ( 8 , 1 ) ;
26864: LD_INT 8
26866: PPUSH
26867: LD_INT 1
26869: PPUSH
26870: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26874: LD_ADDR_VAR 0 2
26878: PUSH
26879: LD_INT 22
26881: PUSH
26882: LD_INT 8
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 21
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PPUSH
26903: CALL_OW 69
26907: PUSH
26908: LD_EXP 63
26912: PUSH
26913: LD_EXP 62
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: DIFF
26922: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26923: LD_VAR 0 2
26927: PUSH
26928: LD_INT 6
26930: PUSH
26931: LD_INT 5
26933: PUSH
26934: LD_INT 4
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: PUSH
26946: LD_OWVAR 67
26950: ARRAY
26951: GREATEREQUAL
26952: IFFALSE 27104
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26954: LD_ADDR_VAR 0 3
26958: PUSH
26959: LD_INT 6
26961: PUSH
26962: LD_INT 5
26964: PUSH
26965: LD_INT 4
26967: PUSH
26968: LD_INT 3
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: PUSH
26977: LD_OWVAR 67
26981: ARRAY
26982: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26983: LD_ADDR_VAR 0 1
26987: PUSH
26988: DOUBLE
26989: LD_VAR 0 2
26993: PUSH
26994: LD_VAR 0 3
26998: PUSH
26999: LD_INT 1
27001: PLUS
27002: MINUS
27003: INC
27004: ST_TO_ADDR
27005: LD_INT 1
27007: PUSH
27008: FOR_DOWNTO
27009: IFFALSE 27100
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27011: LD_ADDR_EXP 38
27015: PUSH
27016: LD_EXP 38
27020: PUSH
27021: LD_VAR 0 2
27025: PUSH
27026: LD_VAR 0 1
27030: ARRAY
27031: ADD
27032: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27033: LD_VAR 0 2
27037: PUSH
27038: LD_VAR 0 1
27042: ARRAY
27043: PPUSH
27044: CALL_OW 310
27048: IFFALSE 27065
// ComExit ( tmp [ i ] ) ;
27050: LD_VAR 0 2
27054: PUSH
27055: LD_VAR 0 1
27059: ARRAY
27060: PPUSH
27061: CALL 105357 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27065: LD_VAR 0 2
27069: PUSH
27070: LD_VAR 0 1
27074: ARRAY
27075: PPUSH
27076: LD_INT 34
27078: PUSH
27079: LD_INT 0
27081: PPUSH
27082: LD_INT 6
27084: PPUSH
27085: CALL_OW 12
27089: PLUS
27090: PPUSH
27091: LD_INT 1
27093: PPUSH
27094: CALL_OW 171
// end ;
27098: GO 27008
27100: POP
27101: POP
// end else
27102: GO 27114
// x := tmp ;
27104: LD_ADDR_VAR 0 3
27108: PUSH
27109: LD_VAR 0 2
27113: ST_TO_ADDR
// for i := tmp downto tmp - x do
27114: LD_ADDR_VAR 0 1
27118: PUSH
27119: DOUBLE
27120: LD_VAR 0 2
27124: INC
27125: ST_TO_ADDR
27126: LD_VAR 0 2
27130: PUSH
27131: LD_VAR 0 3
27135: MINUS
27136: PUSH
27137: FOR_DOWNTO
27138: IFFALSE 27192
// begin if IsInUnit ( tmp [ i ] ) then
27140: LD_VAR 0 2
27144: PUSH
27145: LD_VAR 0 1
27149: ARRAY
27150: PPUSH
27151: CALL_OW 310
27155: IFFALSE 27172
// ComExit ( tmp [ i ] ) ;
27157: LD_VAR 0 2
27161: PUSH
27162: LD_VAR 0 1
27166: ARRAY
27167: PPUSH
27168: CALL 105357 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27172: LD_VAR 0 2
27176: PUSH
27177: LD_VAR 0 1
27181: ARRAY
27182: PPUSH
27183: LD_INT 1
27185: PPUSH
27186: CALL_OW 235
// end ;
27190: GO 27137
27192: POP
27193: POP
// wait ( 0 0$0.3 ) ;
27194: LD_INT 10
27196: PPUSH
27197: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27201: LD_ADDR_VAR 0 1
27205: PUSH
27206: LD_INT 22
27208: PUSH
27209: LD_INT 8
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 21
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PPUSH
27230: CALL_OW 69
27234: PUSH
27235: FOR_IN
27236: IFFALSE 27249
// KillUnit ( i ) ;
27238: LD_VAR 0 1
27242: PPUSH
27243: CALL_OW 66
27247: GO 27235
27249: POP
27250: POP
// SetSide ( Kurt , 1 ) ;
27251: LD_EXP 62
27255: PPUSH
27256: LD_INT 1
27258: PPUSH
27259: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27263: LD_INT 22
27265: PUSH
27266: LD_INT 8
27268: PUSH
27269: EMPTY
27270: LIST
27271: LIST
27272: PUSH
27273: LD_INT 21
27275: PUSH
27276: LD_INT 3
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PPUSH
27287: CALL_OW 69
27291: PPUSH
27292: LD_INT 1
27294: PPUSH
27295: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27299: LD_INT 8
27301: PPUSH
27302: LD_INT 1
27304: PPUSH
27305: LD_INT 1
27307: PPUSH
27308: LD_INT 1
27310: PPUSH
27311: CALL_OW 80
// wait ( 1 1$20 ) ;
27315: LD_INT 2800
27317: PPUSH
27318: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27322: LD_EXP 64
27326: PPUSH
27327: LD_INT 37
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: LD_INT 0
27335: PPUSH
27336: CALL_OW 48
// wait ( 0 0$1 ) ;
27340: LD_INT 35
27342: PPUSH
27343: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27347: LD_EXP 64
27351: PPUSH
27352: LD_INT 60
27354: PPUSH
27355: LD_INT 95
27357: PPUSH
27358: CALL_OW 111
// end ;
27362: PPOPN 3
27364: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27365: LD_EXP 22
27369: NOT
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_INT 8
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 21
27383: PUSH
27384: LD_INT 1
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PPUSH
27395: CALL_OW 69
27399: PUSH
27400: LD_INT 0
27402: EQUAL
27403: AND
27404: IFFALSE 27424
27406: GO 27408
27408: DISABLE
// begin legionDestroyed := true ;
27409: LD_ADDR_EXP 22
27413: PUSH
27414: LD_INT 1
27416: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27417: LD_STRING MlegionOut
27419: PPUSH
27420: CALL_OW 337
// end ;
27424: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27425: LD_EXP 38
27429: IFFALSE 27504
27431: GO 27433
27433: DISABLE
27434: LD_INT 0
27436: PPUSH
// begin enable ;
27437: ENABLE
// for i in legionEscapeUnits do
27438: LD_ADDR_VAR 0 1
27442: PUSH
27443: LD_EXP 38
27447: PUSH
27448: FOR_IN
27449: IFFALSE 27502
// begin if IsInArea ( i , legionEscapeArea ) then
27451: LD_VAR 0 1
27455: PPUSH
27456: LD_INT 31
27458: PPUSH
27459: CALL_OW 308
27463: IFFALSE 27476
// RemoveUnit ( i ) else
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 64
27474: GO 27500
// if not HasTask ( i ) then
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 314
27485: NOT
27486: IFFALSE 27500
// ComMoveToArea ( i , legionEscapeArea ) ;
27488: LD_VAR 0 1
27492: PPUSH
27493: LD_INT 31
27495: PPUSH
27496: CALL_OW 113
// end ;
27500: GO 27448
27502: POP
27503: POP
// end ;
27504: PPOPN 1
27506: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27507: LD_INT 1
27509: PPUSH
27510: LD_EXP 64
27514: PPUSH
27515: CALL_OW 292
27519: IFFALSE 27817
27521: GO 27523
27523: DISABLE
27524: LD_INT 0
27526: PPUSH
// begin wait ( 0 0$2 ) ;
27527: LD_INT 70
27529: PPUSH
27530: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27534: LD_EXP 64
27538: PPUSH
27539: CALL_OW 87
// DialogueOn ;
27543: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27547: LD_EXP 40
27551: PPUSH
27552: LD_STRING D14-JMM-1
27554: PPUSH
27555: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27559: LD_EXP 64
27563: PPUSH
27564: LD_STRING D14-Friend-1
27566: PPUSH
27567: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27571: LD_EXP 40
27575: PPUSH
27576: LD_STRING D14-JMM-2
27578: PPUSH
27579: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27583: LD_EXP 64
27587: PPUSH
27588: LD_STRING D14-Friend-2
27590: PPUSH
27591: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27595: LD_EXP 40
27599: PPUSH
27600: LD_STRING D14-JMM-3
27602: PPUSH
27603: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27607: LD_EXP 64
27611: PPUSH
27612: LD_STRING D14-Friend-3
27614: PPUSH
27615: CALL_OW 88
// DialogueOff ;
27619: CALL_OW 7
// dec = Query ( Q14 ) ;
27623: LD_ADDR_VAR 0 1
27627: PUSH
27628: LD_STRING Q14
27630: PPUSH
27631: CALL_OW 97
27635: ST_TO_ADDR
// if dec = 1 then
27636: LD_VAR 0 1
27640: PUSH
27641: LD_INT 1
27643: EQUAL
27644: IFFALSE 27678
// begin DialogueOn ;
27646: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27650: LD_EXP 40
27654: PPUSH
27655: LD_STRING D14a-JMM-1
27657: PPUSH
27658: CALL_OW 88
// DialogueOff ;
27662: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27666: LD_EXP 64
27670: PPUSH
27671: LD_INT 1
27673: PPUSH
27674: CALL_OW 235
// end ; if dec = 2 then
27678: LD_VAR 0 1
27682: PUSH
27683: LD_INT 2
27685: EQUAL
27686: IFFALSE 27739
// begin DialogueOn ;
27688: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27692: LD_EXP 40
27696: PPUSH
27697: LD_STRING D14b-JMM-1
27699: PPUSH
27700: CALL_OW 88
// DialogueOff ;
27704: CALL_OW 7
// wait ( 0 0$1 ) ;
27708: LD_INT 35
27710: PPUSH
27711: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27715: LD_EXP 64
27719: PPUSH
27720: LD_INT 9
27722: PPUSH
27723: LD_INT 2
27725: PPUSH
27726: CALL_OW 111
// AddComHold ( Friend ) ;
27730: LD_EXP 64
27734: PPUSH
27735: CALL_OW 200
// end ; if dec = 3 then
27739: LD_VAR 0 1
27743: PUSH
27744: LD_INT 3
27746: EQUAL
27747: IFFALSE 27817
// begin DialogueOn ;
27749: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27753: LD_EXP 40
27757: PPUSH
27758: LD_STRING D14c-JMM-1
27760: PPUSH
27761: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27765: LD_EXP 64
27769: PPUSH
27770: LD_STRING D14c-Friend-1
27772: PPUSH
27773: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27777: LD_EXP 40
27781: PPUSH
27782: LD_STRING D14c-JMM-2
27784: PPUSH
27785: CALL_OW 88
// DialogueOff ;
27789: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27793: LD_EXP 64
27797: PPUSH
27798: LD_INT 9
27800: PPUSH
27801: LD_INT 2
27803: PPUSH
27804: CALL_OW 111
// AddComHold ( Friend ) ;
27808: LD_EXP 64
27812: PPUSH
27813: CALL_OW 200
// end ; end ;
27817: PPOPN 1
27819: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27820: LD_INT 9
27822: PPUSH
27823: LD_INT 2
27825: PPUSH
27826: CALL_OW 428
27830: PUSH
27831: LD_EXP 64
27835: EQUAL
27836: PUSH
27837: LD_EXP 64
27841: PPUSH
27842: CALL_OW 255
27846: PUSH
27847: LD_INT 8
27849: EQUAL
27850: AND
27851: IFFALSE 27865
27853: GO 27855
27855: DISABLE
// RemoveUnit ( Friend ) ;
27856: LD_EXP 64
27860: PPUSH
27861: CALL_OW 64
27865: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27866: LD_EXP 14
27870: PUSH
27871: LD_INT 31500
27873: GREATEREQUAL
27874: PUSH
27875: LD_EXP 7
27879: AND
27880: PUSH
27881: LD_EXP 2
27885: AND
27886: IFFALSE 28316
27888: GO 27890
27890: DISABLE
27891: LD_INT 0
27893: PPUSH
27894: PPUSH
27895: PPUSH
// begin missionStage := 7 ;
27896: LD_ADDR_EXP 15
27900: PUSH
27901: LD_INT 7
27903: ST_TO_ADDR
// uc_side = 1 ;
27904: LD_ADDR_OWVAR 20
27908: PUSH
27909: LD_INT 1
27911: ST_TO_ADDR
// uc_nation = 1 ;
27912: LD_ADDR_OWVAR 21
27916: PUSH
27917: LD_INT 1
27919: ST_TO_ADDR
// for i = 1 to 5 do
27920: LD_ADDR_VAR 0 1
27924: PUSH
27925: DOUBLE
27926: LD_INT 1
27928: DEC
27929: ST_TO_ADDR
27930: LD_INT 5
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28030
// begin vc_engine = 3 ;
27936: LD_ADDR_OWVAR 39
27940: PUSH
27941: LD_INT 3
27943: ST_TO_ADDR
// vc_control = 3 ;
27944: LD_ADDR_OWVAR 38
27948: PUSH
27949: LD_INT 3
27951: ST_TO_ADDR
// vc_chassis = 3 ;
27952: LD_ADDR_OWVAR 37
27956: PUSH
27957: LD_INT 3
27959: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27960: LD_ADDR_OWVAR 40
27964: PUSH
27965: LD_INT 5
27967: PUSH
27968: LD_INT 9
27970: PUSH
27971: LD_INT 7
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 1
27981: PPUSH
27982: LD_INT 3
27984: PPUSH
27985: CALL_OW 12
27989: ARRAY
27990: ST_TO_ADDR
// veh = CreateVehicle ;
27991: LD_ADDR_VAR 0 2
27995: PUSH
27996: CALL_OW 45
28000: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28001: LD_VAR 0 2
28005: PPUSH
28006: LD_INT 1
28008: PPUSH
28009: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28013: LD_VAR 0 2
28017: PPUSH
28018: LD_INT 19
28020: PPUSH
28021: LD_INT 0
28023: PPUSH
28024: CALL_OW 49
// end ;
28028: GO 27933
28030: POP
28031: POP
// vc_engine = 3 ;
28032: LD_ADDR_OWVAR 39
28036: PUSH
28037: LD_INT 3
28039: ST_TO_ADDR
// vc_control = 1 ;
28040: LD_ADDR_OWVAR 38
28044: PUSH
28045: LD_INT 1
28047: ST_TO_ADDR
// vc_chassis = 3 ;
28048: LD_ADDR_OWVAR 37
28052: PUSH
28053: LD_INT 3
28055: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28056: LD_ADDR_OWVAR 40
28060: PUSH
28061: LD_INT 5
28063: PUSH
28064: LD_INT 9
28066: PUSH
28067: LD_INT 7
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 1
28077: PPUSH
28078: LD_INT 3
28080: PPUSH
28081: CALL_OW 12
28085: ARRAY
28086: ST_TO_ADDR
// vehG = CreateVehicle ;
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: CALL_OW 45
28096: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
28097: LD_VAR 0 3
28101: PPUSH
28102: LD_INT 1
28104: PPUSH
28105: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
28109: LD_VAR 0 3
28113: PPUSH
28114: LD_INT 19
28116: PPUSH
28117: LD_INT 0
28119: PPUSH
28120: CALL_OW 49
// if JMMGirl = 1 then
28124: LD_EXP 7
28128: PUSH
28129: LD_INT 1
28131: EQUAL
28132: IFFALSE 28188
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
28134: LD_ADDR_EXP 41
28138: PUSH
28139: LD_STRING Joan
28141: PPUSH
28142: LD_INT 1
28144: PPUSH
28145: LD_STRING 14_
28147: PPUSH
28148: CALL 67510 0 3
28152: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28153: LD_EXP 41
28157: PPUSH
28158: LD_VAR 0 3
28162: PPUSH
28163: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28167: LD_VAR 0 3
28171: PPUSH
28172: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28176: LD_EXP 41
28180: PPUSH
28181: LD_STRING D10BW-Joan-1
28183: PPUSH
28184: CALL_OW 94
// end ; if JMMGirl = 2 then
28188: LD_EXP 7
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28252
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28198: LD_ADDR_EXP 43
28202: PUSH
28203: LD_STRING Lisa
28205: PPUSH
28206: LD_INT 1
28208: PPUSH
28209: LD_STRING 14_
28211: PPUSH
28212: CALL 67510 0 3
28216: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28217: LD_EXP 43
28221: PPUSH
28222: LD_VAR 0 3
28226: PPUSH
28227: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28231: LD_VAR 0 3
28235: PPUSH
28236: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28240: LD_EXP 43
28244: PPUSH
28245: LD_STRING D10BW-Lisa-1
28247: PPUSH
28248: CALL_OW 94
// end ; if JMMGirl = 3 then
28252: LD_EXP 7
28256: PUSH
28257: LD_INT 3
28259: EQUAL
28260: IFFALSE 28316
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28262: LD_ADDR_EXP 55
28266: PUSH
28267: LD_STRING Connie
28269: PPUSH
28270: LD_INT 1
28272: PPUSH
28273: LD_STRING 14_
28275: PPUSH
28276: CALL 67510 0 3
28280: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28281: LD_EXP 55
28285: PPUSH
28286: LD_VAR 0 3
28290: PPUSH
28291: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28295: LD_VAR 0 3
28299: PPUSH
28300: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28304: LD_EXP 55
28308: PPUSH
28309: LD_STRING D10BW-Con-1
28311: PPUSH
28312: CALL_OW 94
// end ; end ;
28316: PPOPN 3
28318: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28319: LD_EXP 14
28323: PUSH
28324: LD_INT 94500
28326: GREATEREQUAL
28327: IFFALSE 28739
28329: GO 28331
28331: DISABLE
28332: LD_INT 0
28334: PPUSH
28335: PPUSH
28336: PPUSH
// begin tmp := PrepareStevensSquad ;
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: CALL 2323 0 0
28346: ST_TO_ADDR
// if not tmp then
28347: LD_VAR 0 3
28351: NOT
28352: IFFALSE 28356
// exit ;
28354: GO 28739
// uc_side := 1 ;
28356: LD_ADDR_OWVAR 20
28360: PUSH
28361: LD_INT 1
28363: ST_TO_ADDR
// uc_nation := 1 ;
28364: LD_ADDR_OWVAR 21
28368: PUSH
28369: LD_INT 1
28371: ST_TO_ADDR
// for i in tmp do
28372: LD_ADDR_VAR 0 1
28376: PUSH
28377: LD_VAR 0 3
28381: PUSH
28382: FOR_IN
28383: IFFALSE 28480
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28385: LD_INT 3
28387: PPUSH
28388: LD_INT 3
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: LD_INT 5
28396: PUSH
28397: LD_INT 9
28399: PUSH
28400: LD_INT 7
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 1
28410: PPUSH
28411: LD_INT 3
28413: PPUSH
28414: CALL_OW 12
28418: ARRAY
28419: PPUSH
28420: LD_INT 40
28422: PPUSH
28423: CALL 72525 0 5
// veh := CreateVehicle ;
28427: LD_ADDR_VAR 0 2
28431: PUSH
28432: CALL_OW 45
28436: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28437: LD_VAR 0 2
28441: PPUSH
28442: LD_INT 1
28444: PPUSH
28445: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28449: LD_VAR 0 2
28453: PPUSH
28454: LD_INT 19
28456: PPUSH
28457: LD_INT 0
28459: PPUSH
28460: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28464: LD_VAR 0 1
28468: PPUSH
28469: LD_VAR 0 2
28473: PPUSH
28474: CALL_OW 52
// end ;
28478: GO 28382
28480: POP
28481: POP
// missionStage := 8 ;
28482: LD_ADDR_EXP 15
28486: PUSH
28487: LD_INT 8
28489: ST_TO_ADDR
// DialogueOn ;
28490: CALL_OW 6
// if Stevens then
28494: LD_EXP 42
28498: IFFALSE 28612
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28500: LD_EXP 42
28504: PPUSH
28505: CALL_OW 310
28509: PPUSH
28510: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28514: LD_EXP 42
28518: PPUSH
28519: LD_STRING D8-Huck-1
28521: PPUSH
28522: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28526: LD_EXP 40
28530: PPUSH
28531: LD_STRING D8-JMM-1
28533: PPUSH
28534: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28538: LD_EXP 42
28542: PPUSH
28543: LD_STRING D8-Huck-2
28545: PPUSH
28546: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28550: LD_EXP 40
28554: PPUSH
28555: LD_STRING D8-JMM-2
28557: PPUSH
28558: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28562: LD_EXP 42
28566: PPUSH
28567: LD_STRING D8-Huck-3
28569: PPUSH
28570: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28574: LD_EXP 40
28578: PPUSH
28579: LD_STRING D8-JMM-3
28581: PPUSH
28582: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28586: LD_EXP 42
28590: PPUSH
28591: LD_STRING D8-Huck-4
28593: PPUSH
28594: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28598: LD_EXP 40
28602: PPUSH
28603: LD_STRING D8-JMM-4
28605: PPUSH
28606: CALL_OW 88
// end else
28610: GO 28722
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28612: LD_EXP 56
28616: PPUSH
28617: CALL_OW 310
28621: PPUSH
28622: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28626: LD_EXP 56
28630: PPUSH
28631: LD_STRING D8-Huck-1
28633: PPUSH
28634: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28638: LD_EXP 40
28642: PPUSH
28643: LD_STRING D8-JMM-1a
28645: PPUSH
28646: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28650: LD_EXP 56
28654: PPUSH
28655: LD_STRING D8-Huck-2
28657: PPUSH
28658: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28662: LD_EXP 40
28666: PPUSH
28667: LD_STRING D8-JMM-2
28669: PPUSH
28670: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28674: LD_EXP 56
28678: PPUSH
28679: LD_STRING D8-Huck-3
28681: PPUSH
28682: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28686: LD_EXP 40
28690: PPUSH
28691: LD_STRING D8-JMM-3
28693: PPUSH
28694: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28698: LD_EXP 56
28702: PPUSH
28703: LD_STRING D8-Huck-4
28705: PPUSH
28706: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28710: LD_EXP 40
28714: PPUSH
28715: LD_STRING D8-JMM-4
28717: PPUSH
28718: CALL_OW 88
// end ; DialogueOff ;
28722: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28726: LD_INT 25
28728: PPUSH
28729: LD_INT 1
28731: PPUSH
28732: LD_INT 1
28734: PPUSH
28735: CALL_OW 322
// end ;
28739: PPOPN 3
28741: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
28742: LD_EXP 73
28746: PPUSH
28747: CALL_OW 302
28751: PUSH
28752: LD_INT 1
28754: PPUSH
28755: LD_EXP 73
28759: PPUSH
28760: CALL_OW 292
28764: AND
28765: IFFALSE 29016
28767: GO 28769
28769: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28770: LD_EXP 73
28774: PPUSH
28775: CALL_OW 87
// DialogueOn ;
28779: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28783: LD_EXP 40
28787: PPUSH
28788: LD_STRING D10nB-JMM-1
28790: PPUSH
28791: CALL_OW 88
// if BurlakStatus = 1 then
28795: LD_EXP 9
28799: PUSH
28800: LD_INT 1
28802: EQUAL
28803: IFFALSE 28817
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28805: LD_EXP 72
28809: PPUSH
28810: LD_STRING D10nB-Vse-1a
28812: PPUSH
28813: CALL_OW 94
// end ; if BurlakStatus = 0 then
28817: LD_EXP 9
28821: PUSH
28822: LD_INT 0
28824: EQUAL
28825: IFFALSE 28839
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28827: LD_EXP 72
28831: PPUSH
28832: LD_STRING D10nB-Vse-1
28834: PPUSH
28835: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28839: LD_EXP 40
28843: PPUSH
28844: LD_STRING D10nB-JMM-2
28846: PPUSH
28847: CALL_OW 88
// if KappaStatus then
28851: LD_EXP 2
28855: IFFALSE 28869
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28857: LD_EXP 72
28861: PPUSH
28862: LD_STRING D10nB-Vse-5a
28864: PPUSH
28865: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28869: LD_EXP 2
28873: NOT
28874: PUSH
28875: LD_EXP 6
28879: PUSH
28880: LD_INT 0
28882: EQUAL
28883: AND
28884: IFFALSE 29012
// begin if JMMGirl = 1 then
28886: LD_EXP 7
28890: PUSH
28891: LD_INT 1
28893: EQUAL
28894: IFFALSE 28944
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28896: LD_EXP 72
28900: PPUSH
28901: LD_STRING D10nB-Vse-2
28903: PPUSH
28904: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28908: LD_EXP 40
28912: PPUSH
28913: LD_STRING D10nB-JMM-3
28915: PPUSH
28916: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28920: LD_EXP 72
28924: PPUSH
28925: LD_STRING D10nB-Vse-3
28927: PPUSH
28928: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28932: LD_EXP 40
28936: PPUSH
28937: LD_STRING D10nB-JMM-4
28939: PPUSH
28940: CALL_OW 88
// end ; if JMMGirl = 2 then
28944: LD_EXP 7
28948: PUSH
28949: LD_INT 2
28951: EQUAL
28952: IFFALSE 28978
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28954: LD_EXP 72
28958: PPUSH
28959: LD_STRING D10nB-Vse-4
28961: PPUSH
28962: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28966: LD_EXP 40
28970: PPUSH
28971: LD_STRING D10nB-JMM-5
28973: PPUSH
28974: CALL_OW 88
// end ; if JMMGirl = 3 then
28978: LD_EXP 7
28982: PUSH
28983: LD_INT 3
28985: EQUAL
28986: IFFALSE 29012
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28988: LD_EXP 72
28992: PPUSH
28993: LD_STRING D10nB-Vse-5
28995: PPUSH
28996: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29000: LD_EXP 40
29004: PPUSH
29005: LD_STRING D10nB-JMM-6
29007: PPUSH
29008: CALL_OW 88
// end ; end ; DialogueOff ;
29012: CALL_OW 7
// end ;
29016: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
29017: LD_EXP 14
29021: PUSH
29022: LD_INT 115500
29024: GREATEREQUAL
29025: IFFALSE 29401
29027: GO 29029
29029: DISABLE
29030: LD_INT 0
29032: PPUSH
// begin missionStage := 10 ;
29033: LD_ADDR_EXP 15
29037: PUSH
29038: LD_INT 10
29040: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29041: LD_ADDR_VAR 0 1
29045: PUSH
29046: LD_INT 22
29048: PUSH
29049: LD_INT 1
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 23
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 26
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 12
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 3
29095: PUSH
29096: LD_INT 25
29098: PUSH
29099: LD_INT 16
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: LIST
29116: PPUSH
29117: CALL_OW 69
29121: PUSH
29122: LD_EXP 40
29126: PUSH
29127: LD_EXP 62
29131: PUSH
29132: LD_EXP 42
29136: PUSH
29137: LD_EXP 56
29141: PUSH
29142: LD_EXP 43
29146: PUSH
29147: LD_EXP 44
29151: PUSH
29152: LD_EXP 45
29156: PUSH
29157: LD_EXP 46
29161: PUSH
29162: LD_EXP 47
29166: PUSH
29167: LD_EXP 48
29171: PUSH
29172: LD_EXP 49
29176: PUSH
29177: LD_EXP 50
29181: PUSH
29182: LD_EXP 51
29186: PUSH
29187: LD_EXP 52
29191: PUSH
29192: LD_EXP 53
29196: PUSH
29197: LD_EXP 54
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: DIFF
29220: ST_TO_ADDR
// if not tmp and Brown then
29221: LD_VAR 0 1
29225: NOT
29226: PUSH
29227: LD_EXP 48
29231: AND
29232: IFFALSE 29247
// tmp := [ Brown ] ;
29234: LD_ADDR_VAR 0 1
29238: PUSH
29239: LD_EXP 48
29243: PUSH
29244: EMPTY
29245: LIST
29246: ST_TO_ADDR
// DialogueOn ;
29247: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29251: LD_VAR 0 1
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PPUSH
29260: LD_STRING D11-Sol1-1
29262: PPUSH
29263: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29267: LD_EXP 66
29271: PPUSH
29272: LD_STRING D11-Pla-1
29274: PPUSH
29275: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29279: LD_EXP 67
29283: PPUSH
29284: LD_STRING D11-Kov-1
29286: PPUSH
29287: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29291: LD_EXP 66
29295: PPUSH
29296: LD_STRING D11-Pla-2
29298: PPUSH
29299: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29303: LD_VAR 0 1
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: LD_STRING D11-Sol1-2
29314: PPUSH
29315: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29319: LD_EXP 40
29323: PPUSH
29324: LD_STRING D11-JMM-2
29326: PPUSH
29327: CALL_OW 88
// DialogueOff ;
29331: CALL_OW 7
// allowBehemothConstruct := true ;
29335: LD_ADDR_EXP 25
29339: PUSH
29340: LD_INT 1
29342: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29343: LD_STRING M4
29345: PPUSH
29346: CALL_OW 337
// BuildBehemoths ;
29350: CALL 7903 0 0
// repeat wait ( 15 15$00 ) ;
29354: LD_INT 31500
29356: PPUSH
29357: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29361: LD_EXP 27
29365: IFFALSE 29369
// break ;
29367: GO 29401
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29369: LD_INT 267
29371: PPUSH
29372: CALL_OW 274
29376: PPUSH
29377: LD_INT 1
29379: PPUSH
29380: CALL_OW 275
29384: PUSH
29385: LD_INT 1000
29387: GREATEREQUAL
29388: IFFALSE 29394
// BuildBehemoths ;
29390: CALL 7903 0 0
// until not behemothBuilders ;
29394: LD_EXP 75
29398: NOT
29399: IFFALSE 29354
// end ;
29401: PPOPN 1
29403: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29404: LD_EXP 75
29408: NOT
29409: PUSH
29410: LD_EXP 28
29414: NOT
29415: AND
29416: PUSH
29417: LD_EXP 25
29421: AND
29422: IFFALSE 29442
29424: GO 29426
29426: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29427: LD_STRING M4a
29429: PPUSH
29430: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29434: LD_ADDR_EXP 27
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// end ;
29442: END
// every 0 0$1 trigger behemothDone do
29443: LD_EXP 28
29447: IFFALSE 29459
29449: GO 29451
29451: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29452: LD_STRING M4b
29454: PPUSH
29455: CALL_OW 337
29459: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29460: LD_EXP 29
29464: NOT
29465: IFFALSE 29661
29467: GO 29469
29469: DISABLE
29470: LD_INT 0
29472: PPUSH
29473: PPUSH
// begin enable ;
29474: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29475: LD_ADDR_VAR 0 1
29479: PUSH
29480: LD_INT 3
29482: PPUSH
29483: CALL 105020 0 1
29487: ST_TO_ADDR
// if not tmp and not behemothDone then
29488: LD_VAR 0 1
29492: NOT
29493: PUSH
29494: LD_EXP 28
29498: NOT
29499: AND
29500: IFFALSE 29536
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29502: LD_ADDR_VAR 0 1
29506: PUSH
29507: LD_INT 22
29509: PUSH
29510: LD_INT 3
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 30
29519: PUSH
29520: LD_INT 37
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PPUSH
29531: CALL_OW 69
29535: ST_TO_ADDR
// if not tmp then
29536: LD_VAR 0 1
29540: NOT
29541: IFFALSE 29545
// exit ;
29543: GO 29661
// for i in tmp do
29545: LD_ADDR_VAR 0 2
29549: PUSH
29550: LD_VAR 0 1
29554: PUSH
29555: FOR_IN
29556: IFFALSE 29659
// if See ( 1 , i ) then
29558: LD_INT 1
29560: PPUSH
29561: LD_VAR 0 2
29565: PPUSH
29566: CALL_OW 292
29570: IFFALSE 29657
// begin if GetType ( i ) = unit_building then
29572: LD_VAR 0 2
29576: PPUSH
29577: CALL_OW 247
29581: PUSH
29582: LD_INT 3
29584: EQUAL
29585: IFFALSE 29623
// begin disable ;
29587: DISABLE
// CenterNowOnUnits ( i ) ;
29588: LD_VAR 0 2
29592: PPUSH
29593: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29597: LD_EXP 40
29601: PPUSH
29602: LD_STRING D17a-JMM-1
29604: PPUSH
29605: CALL_OW 88
// seeBehemoth := true ;
29609: LD_ADDR_EXP 29
29613: PUSH
29614: LD_INT 1
29616: ST_TO_ADDR
// exit ;
29617: POP
29618: POP
29619: GO 29661
// end else
29621: GO 29657
// begin disable ;
29623: DISABLE
// CenterNowOnUnits ( i ) ;
29624: LD_VAR 0 2
29628: PPUSH
29629: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29633: LD_EXP 40
29637: PPUSH
29638: LD_STRING D17b-JMM-1
29640: PPUSH
29641: CALL_OW 88
// seeBehemoth := true ;
29645: LD_ADDR_EXP 29
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// exit ;
29653: POP
29654: POP
29655: GO 29661
// end ; end ;
29657: GO 29555
29659: POP
29660: POP
// end ;
29661: PPOPN 2
29663: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29664: LD_EXP 14
29668: PUSH
29669: LD_INT 123200
29671: GREATEREQUAL
29672: IFFALSE 30872
29674: GO 29676
29676: DISABLE
29677: LD_INT 0
29679: PPUSH
29680: PPUSH
29681: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29682: LD_INT 2
29684: PPUSH
29685: LD_INT 23
29687: PUSH
29688: LD_INT 3
29690: PUSH
29691: LD_INT 3
29693: PUSH
29694: LD_INT 48
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: PUSH
29703: EMPTY
29704: LIST
29705: PPUSH
29706: CALL 61122 0 2
// repeat wait ( 0 0$1 ) ;
29710: LD_INT 35
29712: PPUSH
29713: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29717: LD_INT 22
29719: PUSH
29720: LD_INT 3
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 34
29729: PUSH
29730: LD_INT 48
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PPUSH
29741: CALL_OW 69
29745: IFFALSE 29710
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29747: LD_ADDR_VAR 0 1
29751: PUSH
29752: LD_INT 22
29754: PUSH
29755: LD_INT 3
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 34
29764: PUSH
29765: LD_INT 48
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PPUSH
29776: CALL_OW 69
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: ST_TO_ADDR
// missionStage := 12 ;
29785: LD_ADDR_EXP 15
29789: PUSH
29790: LD_INT 12
29792: ST_TO_ADDR
// platonovHasBomb := true ;
29793: LD_ADDR_EXP 30
29797: PUSH
29798: LD_INT 1
29800: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29801: LD_VAR 0 1
29805: PPUSH
29806: LD_INT 181
29808: PPUSH
29809: LD_INT 86
29811: PPUSH
29812: CALL_OW 171
// AddComHold ( bomb ) ;
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 200
// wait ( 0 0$10 ) ;
29825: LD_INT 350
29827: PPUSH
29828: CALL_OW 67
// DialogueOn ;
29832: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29836: LD_EXP 66
29840: PPUSH
29841: LD_STRING D15-Pla-1
29843: PPUSH
29844: CALL_OW 94
// dec = Query ( Q15a ) ;
29848: LD_ADDR_VAR 0 2
29852: PUSH
29853: LD_STRING Q15a
29855: PPUSH
29856: CALL_OW 97
29860: ST_TO_ADDR
// if dec = 1 then
29861: LD_VAR 0 2
29865: PUSH
29866: LD_INT 1
29868: EQUAL
29869: IFFALSE 29892
// begin Say ( JMM , D15a-JMM-1 ) ;
29871: LD_EXP 40
29875: PPUSH
29876: LD_STRING D15a-JMM-1
29878: PPUSH
29879: CALL_OW 88
// YouLost ( Surrender ) ;
29883: LD_STRING Surrender
29885: PPUSH
29886: CALL_OW 104
// exit ;
29890: GO 30872
// end ; if dec = 2 then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 2
29899: EQUAL
29900: IFFALSE 29969
// begin Say ( JMM , D15b-JMM-1 ) ;
29902: LD_EXP 40
29906: PPUSH
29907: LD_STRING D15b-JMM-1
29909: PPUSH
29910: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29914: LD_EXP 66
29918: PPUSH
29919: LD_STRING D15b-Pla-1
29921: PPUSH
29922: CALL_OW 94
// DialogueOff ;
29926: CALL_OW 7
// wait ( 3 3$00 ) ;
29930: LD_INT 6300
29932: PPUSH
29933: CALL_OW 67
// DialogueOn ;
29937: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29941: LD_EXP 40
29945: PPUSH
29946: LD_STRING D15d-JMM-1a
29948: PPUSH
29949: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29953: LD_EXP 66
29957: PPUSH
29958: LD_STRING D15d-Pla-1
29960: PPUSH
29961: CALL_OW 94
// DialogueOff ;
29965: CALL_OW 7
// end ; if dec = 3 then
29969: LD_VAR 0 2
29973: PUSH
29974: LD_INT 3
29976: EQUAL
29977: IFFALSE 30031
// begin Say ( JMM , D15c-JMM-1 ) ;
29979: LD_EXP 40
29983: PPUSH
29984: LD_STRING D15c-JMM-1
29986: PPUSH
29987: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29991: LD_EXP 66
29995: PPUSH
29996: LD_STRING D15c-Pla-1
29998: PPUSH
29999: CALL_OW 94
// DialogueOff ;
30003: CALL_OW 7
// wait ( 0 0$15 ) ;
30007: LD_INT 525
30009: PPUSH
30010: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30014: LD_VAR 0 1
30018: PPUSH
30019: LD_INT 60
30021: PPUSH
30022: LD_INT 95
30024: PPUSH
30025: CALL_OW 116
// exit ;
30029: GO 30872
// end ; if dec = 4 then
30031: LD_VAR 0 2
30035: PUSH
30036: LD_INT 4
30038: EQUAL
30039: IFFALSE 30069
// begin Say ( JMM , D15d-JMM-1 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D15d-JMM-1
30048: PPUSH
30049: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D15d-Pla-1
30060: PPUSH
30061: CALL_OW 94
// DialogueOff ;
30065: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30069: LD_EXP 64
30073: PPUSH
30074: CALL_OW 302
30078: PUSH
30079: LD_EXP 64
30083: PPUSH
30084: CALL_OW 255
30088: PUSH
30089: LD_INT 1
30091: EQUAL
30092: AND
30093: PUSH
30094: LD_INT 22
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 34
30106: PUSH
30107: LD_INT 8
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PPUSH
30118: CALL_OW 69
30122: NOT
30123: AND
30124: IFFALSE 30773
// begin SetSide ( Friend , 8 ) ;
30126: LD_EXP 64
30130: PPUSH
30131: LD_INT 8
30133: PPUSH
30134: CALL_OW 235
// if IsInUnit ( Friend ) then
30138: LD_EXP 64
30142: PPUSH
30143: CALL_OW 310
30147: IFFALSE 30158
// ComExitBuilding ( Friend ) ;
30149: LD_EXP 64
30153: PPUSH
30154: CALL_OW 122
// if IsDriver ( Friend ) then
30158: LD_EXP 64
30162: PPUSH
30163: CALL 102568 0 1
30167: IFFALSE 30178
// ComExitVehicle ( Friend ) ;
30169: LD_EXP 64
30173: PPUSH
30174: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30178: LD_EXP 64
30182: PPUSH
30183: LD_INT 9
30185: PPUSH
30186: LD_INT 2
30188: PPUSH
30189: CALL_OW 171
// wait ( 0 0$05 ) ;
30193: LD_INT 175
30195: PPUSH
30196: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30200: LD_EXP 64
30204: PPUSH
30205: CALL_OW 87
// DialogueOn ;
30209: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30213: LD_EXP 40
30217: PPUSH
30218: LD_STRING D16-JMM-1
30220: PPUSH
30221: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30225: LD_EXP 64
30229: PPUSH
30230: LD_STRING D16-Friend-1
30232: PPUSH
30233: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30237: LD_EXP 40
30241: PPUSH
30242: LD_STRING D16-JMM-2
30244: PPUSH
30245: CALL_OW 88
// DialogueOff ;
30249: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30253: LD_EXP 64
30257: PPUSH
30258: LD_INT 1
30260: PPUSH
30261: CALL_OW 235
// ComHold ( Friend ) ;
30265: LD_EXP 64
30269: PPUSH
30270: CALL_OW 140
// wait ( 0 0$20 ) ;
30274: LD_INT 700
30276: PPUSH
30277: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30281: LD_EXP 64
30285: PPUSH
30286: LD_INT 9
30288: PPUSH
30289: LD_INT 2
30291: PPUSH
30292: CALL_OW 297
30296: PUSH
30297: LD_INT 30
30299: LESS
30300: IFFALSE 30369
// begin SetSide ( Friend , 8 ) ;
30302: LD_EXP 64
30306: PPUSH
30307: LD_INT 8
30309: PPUSH
30310: CALL_OW 235
// if IsInUnit ( Friend ) then
30314: LD_EXP 64
30318: PPUSH
30319: CALL_OW 310
30323: IFFALSE 30334
// ComExitBuilding ( Friend ) ;
30325: LD_EXP 64
30329: PPUSH
30330: CALL_OW 122
// if IsDriver ( Friend ) then
30334: LD_EXP 64
30338: PPUSH
30339: CALL 102568 0 1
30343: IFFALSE 30354
// ComExitVehicle ( Friend ) ;
30345: LD_EXP 64
30349: PPUSH
30350: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30354: LD_EXP 64
30358: PPUSH
30359: LD_INT 9
30361: PPUSH
30362: LD_INT 2
30364: PPUSH
30365: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30369: LD_INT 1050
30371: PPUSH
30372: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30376: LD_INT 22
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 34
30388: PUSH
30389: LD_INT 8
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PPUSH
30400: CALL_OW 69
30404: NOT
30405: IFFALSE 30751
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30407: LD_ADDR_VAR 0 3
30411: PUSH
30412: LD_INT 22
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 26
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 25
30437: PUSH
30438: LD_INT 12
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 25
30447: PUSH
30448: LD_INT 16
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: LIST
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: LIST
30464: PPUSH
30465: CALL_OW 69
30469: PUSH
30470: LD_EXP 40
30474: PUSH
30475: LD_EXP 42
30479: PUSH
30480: LD_EXP 56
30484: PUSH
30485: LD_EXP 43
30489: PUSH
30490: LD_EXP 44
30494: PUSH
30495: LD_EXP 45
30499: PUSH
30500: LD_EXP 46
30504: PUSH
30505: LD_EXP 47
30509: PUSH
30510: LD_EXP 48
30514: PUSH
30515: LD_EXP 49
30519: PUSH
30520: LD_EXP 50
30524: PUSH
30525: LD_EXP 51
30529: PUSH
30530: LD_EXP 52
30534: PUSH
30535: LD_EXP 53
30539: PUSH
30540: LD_EXP 54
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: DIFF
30562: ST_TO_ADDR
// DialogueOn ;
30563: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30567: LD_EXP 66
30571: PPUSH
30572: LD_STRING D16a-Pla-1
30574: PPUSH
30575: CALL_OW 94
// if Stevens then
30579: LD_EXP 42
30583: IFFALSE 30599
// Say ( Stevens , D16a-Huck-1 ) else
30585: LD_EXP 42
30589: PPUSH
30590: LD_STRING D16a-Huck-1
30592: PPUSH
30593: CALL_OW 88
30597: GO 30641
// if Baker then
30599: LD_EXP 56
30603: IFFALSE 30619
// Say ( Baker , D16a-Huck-1 ) else
30605: LD_EXP 56
30609: PPUSH
30610: LD_STRING D16a-Huck-1
30612: PPUSH
30613: CALL_OW 88
30617: GO 30641
// if tmp then
30619: LD_VAR 0 3
30623: IFFALSE 30641
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30625: LD_VAR 0 3
30629: PUSH
30630: LD_INT 1
30632: ARRAY
30633: PPUSH
30634: LD_STRING D16a-Sol1-1
30636: PPUSH
30637: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30641: LD_EXP 64
30645: PPUSH
30646: CALL_OW 255
30650: PUSH
30651: LD_INT 8
30653: EQUAL
30654: IFFALSE 30670
// Say ( JMM , D16a-JMM-1 ) else
30656: LD_EXP 40
30660: PPUSH
30661: LD_STRING D16a-JMM-1
30663: PPUSH
30664: CALL_OW 88
30668: GO 30730
// begin Say ( JMM , D16a-JMM-1a ) ;
30670: LD_EXP 40
30674: PPUSH
30675: LD_STRING D16a-JMM-1a
30677: PPUSH
30678: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30682: LD_EXP 64
30686: PPUSH
30687: LD_STRING D16a-Friend-1
30689: PPUSH
30690: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30694: LD_EXP 64
30698: PPUSH
30699: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30703: LD_EXP 64
30707: PPUSH
30708: LD_INT 191
30710: PPUSH
30711: LD_INT 103
30713: PPUSH
30714: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30718: LD_EXP 64
30722: PPUSH
30723: LD_INT 3
30725: PPUSH
30726: CALL_OW 235
// end ; DialogueOff ;
30730: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30734: LD_VAR 0 1
30738: PPUSH
30739: LD_INT 60
30741: PPUSH
30742: LD_INT 95
30744: PPUSH
30745: CALL_OW 116
// end else
30749: GO 30771
// begin DialogueOn ;
30751: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30755: LD_EXP 66
30759: PPUSH
30760: LD_STRING D16c-Pla-1
30762: PPUSH
30763: CALL_OW 94
// DialogueOff ;
30767: CALL_OW 7
// end ; end else
30771: GO 30872
// begin wait ( 3 3$00 ) ;
30773: LD_INT 6300
30775: PPUSH
30776: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30780: LD_INT 22
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 34
30792: PUSH
30793: LD_INT 8
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PPUSH
30804: CALL_OW 69
30808: NOT
30809: IFFALSE 30852
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30811: LD_EXP 66
30815: PPUSH
30816: LD_STRING D16b-Pla-1
30818: PPUSH
30819: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30823: LD_EXP 40
30827: PPUSH
30828: LD_STRING D16b-JMM-1
30830: PPUSH
30831: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30835: LD_VAR 0 1
30839: PPUSH
30840: LD_INT 60
30842: PPUSH
30843: LD_INT 95
30845: PPUSH
30846: CALL_OW 116
// end else
30850: GO 30872
// begin DialogueOn ;
30852: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30856: LD_EXP 66
30860: PPUSH
30861: LD_STRING D16c-Pla-1
30863: PPUSH
30864: CALL_OW 94
// DialogueOff ;
30868: CALL_OW 7
// end ; end ; end ;
30872: PPOPN 3
30874: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30875: LD_EXP 14
30879: PUSH
30880: LD_INT 126000
30882: GREATEREQUAL
30883: PUSH
30884: LD_EXP 23
30888: NOT
30889: AND
30890: PUSH
30891: LD_EXP 77
30895: PPUSH
30896: CALL_OW 302
30900: AND
30901: IFFALSE 31259
30903: GO 30905
30905: DISABLE
30906: LD_INT 0
30908: PPUSH
// begin missionStage = 11 ;
30909: LD_ADDR_EXP 15
30913: PUSH
30914: LD_INT 11
30916: ST_TO_ADDR
// DialogueOn ;
30917: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30921: LD_EXP 77
30925: PPUSH
30926: LD_STRING D9-Roth-1
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9-JMM-1
30940: PPUSH
30941: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30945: LD_EXP 77
30949: PPUSH
30950: LD_STRING D9-Roth-2
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30957: LD_EXP 77
30961: PPUSH
30962: LD_STRING D9-Roth-2a
30964: PPUSH
30965: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30969: LD_EXP 66
30973: PPUSH
30974: LD_STRING D9-Pla-2
30976: PPUSH
30977: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30981: LD_EXP 77
30985: PPUSH
30986: LD_STRING D9-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30993: LD_EXP 66
30997: PPUSH
30998: LD_STRING D9-Pla-3
31000: PPUSH
31001: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31005: LD_EXP 77
31009: PPUSH
31010: LD_STRING D9-Roth-4
31012: PPUSH
31013: CALL_OW 94
// dec = Query ( Q9 ) ;
31017: LD_ADDR_VAR 0 1
31021: PUSH
31022: LD_STRING Q9
31024: PPUSH
31025: CALL_OW 97
31029: ST_TO_ADDR
// if dec = 1 then
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 1
31037: EQUAL
31038: IFFALSE 31052
// SayRadio ( Roth , D9a-Roth-1 ) ;
31040: LD_EXP 77
31044: PPUSH
31045: LD_STRING D9a-Roth-1
31047: PPUSH
31048: CALL_OW 94
// if dec = 2 then
31052: LD_VAR 0 1
31056: PUSH
31057: LD_INT 2
31059: EQUAL
31060: IFFALSE 31086
// begin Say ( JMM , D9b-JMM-1 ) ;
31062: LD_EXP 40
31066: PPUSH
31067: LD_STRING D9b-JMM-1
31069: PPUSH
31070: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
31074: LD_EXP 77
31078: PPUSH
31079: LD_STRING D9b-Roth-1
31081: PPUSH
31082: CALL_OW 94
// end ; if dec = 3 then
31086: LD_VAR 0 1
31090: PUSH
31091: LD_INT 3
31093: EQUAL
31094: IFFALSE 31156
// begin Say ( JMM , D9c-JMM-1 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D9c-JMM-1
31103: PPUSH
31104: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
31108: LD_EXP 77
31112: PPUSH
31113: LD_STRING D9c-Roth-1
31115: PPUSH
31116: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
31120: LD_EXP 40
31124: PPUSH
31125: LD_STRING D9c-JMM-2
31127: PPUSH
31128: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
31132: LD_EXP 77
31136: PPUSH
31137: LD_STRING D9c-Roth-2
31139: PPUSH
31140: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
31144: LD_EXP 40
31148: PPUSH
31149: LD_STRING D9c-JMM-3
31151: PPUSH
31152: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
31156: LD_EXP 77
31160: PPUSH
31161: LD_STRING D9c-Roth-3
31163: PPUSH
31164: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
31168: LD_EXP 77
31172: PPUSH
31173: LD_STRING D9cont-Roth-1
31175: PPUSH
31176: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31180: LD_EXP 40
31184: PPUSH
31185: LD_STRING D9cont-JMM-1
31187: PPUSH
31188: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31192: LD_EXP 77
31196: PPUSH
31197: LD_STRING D9cont-Roth-2
31199: PPUSH
31200: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31204: LD_EXP 40
31208: PPUSH
31209: LD_STRING D9cont-JMM-2
31211: PPUSH
31212: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31216: LD_EXP 77
31220: PPUSH
31221: LD_STRING D9cont-Roth-3
31223: PPUSH
31224: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31228: LD_EXP 40
31232: PPUSH
31233: LD_STRING D9cont-JMM-3
31235: PPUSH
31236: CALL_OW 88
// DialogueOff ;
31240: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31244: LD_STRING M3
31246: PPUSH
31247: CALL_OW 337
// allianceActive := true ;
31251: LD_ADDR_EXP 31
31255: PUSH
31256: LD_INT 1
31258: ST_TO_ADDR
// end ;
31259: PPOPN 1
31261: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31262: LD_INT 1
31264: PPUSH
31265: LD_INT 126
31267: PPUSH
31268: CALL_OW 292
31272: PUSH
31273: LD_EXP 66
31277: PPUSH
31278: CALL_OW 310
31282: AND
31283: IFFALSE 31363
31285: GO 31287
31287: DISABLE
31288: LD_INT 0
31290: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31291: LD_EXP 66
31295: PPUSH
31296: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31300: LD_ADDR_VAR 0 1
31304: PUSH
31305: LD_INT 4
31307: PPUSH
31308: LD_INT 22
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 70
31322: PPUSH
31323: LD_EXP 66
31327: PPUSH
31328: CALL_OW 74
31332: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31333: LD_EXP 66
31337: PPUSH
31338: LD_VAR 0 1
31342: PUSH
31343: LD_INT 1
31345: ARRAY
31346: PPUSH
31347: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31351: LD_EXP 66
31355: PPUSH
31356: LD_STRING D18-Pla-1
31358: PPUSH
31359: CALL_OW 88
// end ;
31363: PPOPN 1
31365: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31366: LD_EXP 66
31370: PPUSH
31371: CALL_OW 301
31375: PUSH
31376: LD_EXP 69
31380: PPUSH
31381: CALL_OW 301
31385: AND
31386: PUSH
31387: LD_INT 22
31389: PUSH
31390: LD_INT 3
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 21
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 50
31409: PUSH
31410: EMPTY
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 69
31422: PUSH
31423: LD_INT 7
31425: PUSH
31426: LD_INT 8
31428: PUSH
31429: LD_INT 9
31431: PUSH
31432: LD_INT 10
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: PUSH
31441: LD_OWVAR 67
31445: ARRAY
31446: LESS
31447: AND
31448: IFFALSE 32247
31450: GO 31452
31452: DISABLE
31453: LD_INT 0
31455: PPUSH
31456: PPUSH
31457: PPUSH
31458: PPUSH
// begin MC_Kill ( 2 ) ;
31459: LD_INT 2
31461: PPUSH
31462: CALL 37095 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31466: LD_INT 1
31468: PPUSH
31469: LD_INT 3
31471: PPUSH
31472: LD_INT 1
31474: PPUSH
31475: LD_INT 1
31477: PPUSH
31478: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31482: LD_ADDR_VAR 0 2
31486: PUSH
31487: LD_INT 22
31489: PUSH
31490: LD_INT 3
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 21
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 50
31509: PUSH
31510: EMPTY
31511: LIST
31512: PUSH
31513: LD_INT 26
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 69
31533: ST_TO_ADDR
// if not tmp then
31534: LD_VAR 0 2
31538: NOT
31539: IFFALSE 31595
// begin uc_side = 3 ;
31541: LD_ADDR_OWVAR 20
31545: PUSH
31546: LD_INT 3
31548: ST_TO_ADDR
// uc_nation = 3 ;
31549: LD_ADDR_OWVAR 21
31553: PUSH
31554: LD_INT 3
31556: ST_TO_ADDR
// hc_name =  ;
31557: LD_ADDR_OWVAR 26
31561: PUSH
31562: LD_STRING 
31564: ST_TO_ADDR
// hc_gallery =  ;
31565: LD_ADDR_OWVAR 33
31569: PUSH
31570: LD_STRING 
31572: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31573: LD_INT 1
31575: PPUSH
31576: LD_INT 10
31578: PPUSH
31579: CALL_OW 381
// tmp = CreateHuman ;
31583: LD_ADDR_VAR 0 2
31587: PUSH
31588: CALL_OW 44
31592: ST_TO_ADDR
// end else
31593: GO 31609
// tmp := tmp [ 1 ] ;
31595: LD_ADDR_VAR 0 2
31599: PUSH
31600: LD_VAR 0 2
31604: PUSH
31605: LD_INT 1
31607: ARRAY
31608: ST_TO_ADDR
// DialogueOn ;
31609: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31613: LD_VAR 0 2
31617: PPUSH
31618: LD_STRING DSurrenderRussians-RSol1-1a
31620: PPUSH
31621: CALL_OW 94
// DialogueOff ;
31625: CALL_OW 7
// russianDestroyed := true ;
31629: LD_ADDR_EXP 21
31633: PUSH
31634: LD_INT 1
31636: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31637: LD_ADDR_VAR 0 1
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 6
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PPUSH
31652: CALL_OW 69
31656: PUSH
31657: FOR_IN
31658: IFFALSE 31671
// KillUnit ( i ) ;
31660: LD_VAR 0 1
31664: PPUSH
31665: CALL_OW 66
31669: GO 31657
31671: POP
31672: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31673: LD_INT 22
31675: PUSH
31676: LD_INT 3
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PPUSH
31697: CALL_OW 69
31701: PPUSH
31702: CALL_OW 122
// wait ( 0 0$1 ) ;
31706: LD_INT 35
31708: PPUSH
31709: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31713: LD_INT 22
31715: PUSH
31716: LD_INT 3
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 21
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: PPUSH
31742: LD_INT 25
31744: PPUSH
31745: CALL_OW 173
// wait ( 0 0$35 ) ;
31749: LD_INT 1225
31751: PPUSH
31752: CALL_OW 67
// PrepareOmarInvasion ;
31756: CALL 14772 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31760: LD_ADDR_VAR 0 2
31764: PUSH
31765: LD_EXP 95
31769: PPUSH
31770: CALL_OW 250
31774: PUSH
31775: LD_EXP 95
31779: PPUSH
31780: CALL_OW 251
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: ARRAY
31797: PPUSH
31798: LD_VAR 0 2
31802: PUSH
31803: LD_INT 2
31805: ARRAY
31806: PPUSH
31807: LD_INT 1
31809: PPUSH
31810: LD_INT 8
31812: NEG
31813: PPUSH
31814: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31818: LD_EXP 95
31822: PPUSH
31823: CALL_OW 87
// DialogueOn ;
31827: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31831: LD_EXP 40
31835: PPUSH
31836: LD_STRING D19-JMM-1
31838: PPUSH
31839: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31843: LD_ADDR_VAR 0 3
31847: PUSH
31848: LD_INT 22
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 26
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 25
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 25
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 25
31893: PUSH
31894: LD_INT 3
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 25
31903: PUSH
31904: LD_INT 4
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 25
31913: PUSH
31914: LD_INT 5
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 25
31923: PUSH
31924: LD_INT 8
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: LIST
31944: PPUSH
31945: CALL_OW 69
31949: PUSH
31950: LD_EXP 40
31954: PUSH
31955: LD_EXP 41
31959: PUSH
31960: LD_EXP 62
31964: PUSH
31965: LD_EXP 42
31969: PUSH
31970: LD_EXP 43
31974: PUSH
31975: LD_EXP 44
31979: PUSH
31980: LD_EXP 45
31984: PUSH
31985: LD_EXP 46
31989: PUSH
31990: LD_EXP 47
31994: PUSH
31995: LD_EXP 48
31999: PUSH
32000: LD_EXP 49
32004: PUSH
32005: LD_EXP 50
32009: PUSH
32010: LD_EXP 51
32014: PUSH
32015: LD_EXP 52
32019: PUSH
32020: LD_EXP 53
32024: PUSH
32025: LD_EXP 54
32029: PUSH
32030: LD_EXP 55
32034: PUSH
32035: LD_EXP 56
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: DIFF
32060: ST_TO_ADDR
// if tmp2 then
32061: LD_VAR 0 3
32065: IFFALSE 32083
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
32067: LD_VAR 0 3
32071: PUSH
32072: LD_INT 1
32074: ARRAY
32075: PPUSH
32076: LD_STRING D19-Sol1-1
32078: PPUSH
32079: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
32083: LD_EXP 40
32087: PPUSH
32088: LD_STRING D19-JMM-2
32090: PPUSH
32091: CALL_OW 88
// DialogueOff ;
32095: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
32099: LD_VAR 0 2
32103: PUSH
32104: LD_INT 1
32106: ARRAY
32107: PPUSH
32108: LD_VAR 0 2
32112: PUSH
32113: LD_INT 2
32115: ARRAY
32116: PPUSH
32117: LD_INT 1
32119: PPUSH
32120: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
32124: LD_STRING M5
32126: PPUSH
32127: CALL_OW 337
// omarOnMotherLode := false ;
32131: LD_ADDR_VAR 0 4
32135: PUSH
32136: LD_INT 0
32138: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32139: LD_INT 35
32141: PPUSH
32142: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
32146: LD_EXP 95
32150: PPUSH
32151: LD_INT 215
32153: PPUSH
32154: LD_INT 100
32156: PPUSH
32157: CALL_OW 297
32161: PUSH
32162: LD_INT 10
32164: LESS
32165: PUSH
32166: LD_VAR 0 4
32170: NOT
32171: AND
32172: IFFALSE 32206
// begin omarOnMotherLode := true ;
32174: LD_ADDR_VAR 0 4
32178: PUSH
32179: LD_INT 1
32181: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32182: LD_EXP 40
32186: PPUSH
32187: LD_STRING D19b-JMM-1
32189: PPUSH
32190: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32194: LD_EXP 95
32198: PPUSH
32199: LD_STRING DOmarContam-Omar-1
32201: PPUSH
32202: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32206: LD_EXP 95
32210: PPUSH
32211: CALL_OW 301
32215: IFFALSE 32139
// Say ( JMM , D19a-JMM-1 ) ;
32217: LD_EXP 40
32221: PPUSH
32222: LD_STRING D19a-JMM-1
32224: PPUSH
32225: CALL_OW 88
// if Heike then
32229: LD_EXP 96
32233: IFFALSE 32247
// Say ( Heike , D19a-Hke-1 ) ;
32235: LD_EXP 96
32239: PPUSH
32240: LD_STRING D19a-Hke-1
32242: PPUSH
32243: CALL_OW 88
// end ;
32247: PPOPN 4
32249: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32250: LD_INT 22
32252: PUSH
32253: LD_INT 3
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 21
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 69
32278: PUSH
32279: LD_EXP 21
32283: AND
32284: IFFALSE 32352
32286: GO 32288
32288: DISABLE
32289: LD_INT 0
32291: PPUSH
32292: PPUSH
// begin enable ;
32293: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32294: LD_ADDR_VAR 0 2
32298: PUSH
32299: LD_INT 25
32301: PPUSH
32302: LD_INT 22
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PPUSH
32312: CALL_OW 70
32316: ST_TO_ADDR
// if not tmp then
32317: LD_VAR 0 2
32321: NOT
32322: IFFALSE 32326
// exit ;
32324: GO 32352
// for i in tmp do
32326: LD_ADDR_VAR 0 1
32330: PUSH
32331: LD_VAR 0 2
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32350
// RemoveUnit ( i ) ;
32339: LD_VAR 0 1
32343: PPUSH
32344: CALL_OW 64
32348: GO 32336
32350: POP
32351: POP
// end ;
32352: PPOPN 2
32354: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32355: LD_INT 22
32357: PUSH
32358: LD_INT 7
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 21
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 69
32383: PUSH
32384: LD_INT 6
32386: LESS
32387: IFFALSE 32855
32389: GO 32391
32391: DISABLE
32392: LD_INT 0
32394: PPUSH
32395: PPUSH
// begin MC_Kill ( 1 ) ;
32396: LD_INT 1
32398: PPUSH
32399: CALL 37095 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32403: LD_INT 7
32405: PPUSH
32406: LD_INT 1
32408: PPUSH
32409: LD_INT 1
32411: PPUSH
32412: LD_INT 1
32414: PPUSH
32415: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32419: LD_ADDR_VAR 0 1
32423: PUSH
32424: LD_INT 22
32426: PUSH
32427: LD_INT 7
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 26
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: CALL_OW 69
32452: PUSH
32453: LD_EXP 77
32457: DIFF
32458: ST_TO_ADDR
// if tmp then
32459: LD_VAR 0 1
32463: IFFALSE 32481
// tmp := tmp [ 1 ] else
32465: LD_ADDR_VAR 0 1
32469: PUSH
32470: LD_VAR 0 1
32474: PUSH
32475: LD_INT 1
32477: ARRAY
32478: ST_TO_ADDR
32479: GO 32517
// begin uc_side := 7 ;
32481: LD_ADDR_OWVAR 20
32485: PUSH
32486: LD_INT 7
32488: ST_TO_ADDR
// uc_nation := 1 ;
32489: LD_ADDR_OWVAR 21
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32497: LD_INT 1
32499: PPUSH
32500: LD_INT 8
32502: PPUSH
32503: CALL_OW 384
// tmp := CreateHuman ;
32507: LD_ADDR_VAR 0 1
32511: PUSH
32512: CALL_OW 44
32516: ST_TO_ADDR
// end ; DialogueOn ;
32517: CALL_OW 6
// if IsOK ( Roth ) then
32521: LD_EXP 77
32525: PPUSH
32526: CALL_OW 302
32530: IFFALSE 32544
// Say ( JMM , DAb-JMM-1 ) ;
32532: LD_EXP 40
32536: PPUSH
32537: LD_STRING DAb-JMM-1
32539: PPUSH
32540: CALL_OW 88
// if IsOK ( Roth ) then
32544: LD_EXP 77
32548: PPUSH
32549: CALL_OW 302
32553: IFFALSE 32577
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32555: LD_EXP 77
32559: PPUSH
32560: LD_STRING DSurrenderAlliance-Roth-1
32562: PPUSH
32563: CALL_OW 88
// RothCaptured := true ;
32567: LD_ADDR_EXP 33
32571: PUSH
32572: LD_INT 1
32574: ST_TO_ADDR
// end else
32575: GO 32589
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32577: LD_VAR 0 1
32581: PPUSH
32582: LD_STRING DSurrenderAlliance-Sci1-1
32584: PPUSH
32585: CALL_OW 88
// DialogueOff ;
32589: CALL_OW 7
// allianceDestroyed := true ;
32593: LD_ADDR_EXP 23
32597: PUSH
32598: LD_INT 1
32600: ST_TO_ADDR
// if capturedUnit = 0 then
32601: LD_EXP 34
32605: PUSH
32606: LD_INT 0
32608: EQUAL
32609: IFFALSE 32618
// SetAchievement ( ACH_ALLIANCE ) ;
32611: LD_STRING ACH_ALLIANCE
32613: PPUSH
32614: CALL_OW 543
// if trueAmericans then
32618: LD_EXP 35
32622: IFFALSE 32698
// begin if trueAmericans = 1 then
32624: LD_EXP 35
32628: PUSH
32629: LD_INT 1
32631: EQUAL
32632: IFFALSE 32648
// Say ( JMM , DAb-JMM-1a ) else
32634: LD_EXP 40
32638: PPUSH
32639: LD_STRING DAb-JMM-1a
32641: PPUSH
32642: CALL_OW 88
32646: GO 32660
// Say ( JMM , DAb-JMM-1b ) ;
32648: LD_EXP 40
32652: PPUSH
32653: LD_STRING DAb-JMM-1b
32655: PPUSH
32656: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32660: LD_EXP 35
32664: PPUSH
32665: CALL_OW 87
// for i in trueAmericans do
32669: LD_ADDR_VAR 0 2
32673: PUSH
32674: LD_EXP 35
32678: PUSH
32679: FOR_IN
32680: IFFALSE 32696
// SetSide ( i , 1 ) ;
32682: LD_VAR 0 2
32686: PPUSH
32687: LD_INT 1
32689: PPUSH
32690: CALL_OW 235
32694: GO 32679
32696: POP
32697: POP
// end ; repeat wait ( 0 0$1 ) ;
32698: LD_INT 35
32700: PPUSH
32701: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32705: LD_ADDR_VAR 0 2
32709: PUSH
32710: LD_INT 22
32712: PUSH
32713: LD_INT 7
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 21
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PPUSH
32734: CALL_OW 69
32738: PUSH
32739: FOR_IN
32740: IFFALSE 32822
// begin if IsInUnit ( i ) then
32742: LD_VAR 0 2
32746: PPUSH
32747: CALL_OW 310
32751: IFFALSE 32762
// ComExitBuilding ( i ) ;
32753: LD_VAR 0 2
32757: PPUSH
32758: CALL_OW 122
// if IsDriver ( i ) then
32762: LD_VAR 0 2
32766: PPUSH
32767: CALL 102568 0 1
32771: IFFALSE 32782
// ComExitVehicle ( i ) ;
32773: LD_VAR 0 2
32777: PPUSH
32778: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32782: LD_VAR 0 2
32786: PPUSH
32787: LD_INT 26
32789: PPUSH
32790: CALL_OW 308
32794: NOT
32795: IFFALSE 32811
// AddComMoveToArea ( i , allianceEscapeArea ) else
32797: LD_VAR 0 2
32801: PPUSH
32802: LD_INT 26
32804: PPUSH
32805: CALL_OW 173
32809: GO 32820
// RemoveUnit ( i ) ;
32811: LD_VAR 0 2
32815: PPUSH
32816: CALL_OW 64
// end ;
32820: GO 32739
32822: POP
32823: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32824: LD_INT 22
32826: PUSH
32827: LD_INT 7
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 21
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PPUSH
32848: CALL_OW 69
32852: NOT
32853: IFFALSE 32698
// end ;
32855: PPOPN 2
32857: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32858: LD_INT 0
32860: PPUSH
32861: PPUSH
// if not unit then
32862: LD_VAR 0 1
32866: NOT
32867: IFFALSE 32871
// exit ;
32869: GO 34369
// DoNotAttack ( 7 , unit ) ;
32871: LD_INT 7
32873: PPUSH
32874: LD_VAR 0 1
32878: PPUSH
32879: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: LD_INT 260
32890: PPUSH
32891: LD_INT 235
32893: PPUSH
32894: LD_INT 3
32896: PPUSH
32897: LD_INT 1
32899: PPUSH
32900: CALL_OW 483
// SetSide ( unit , 4 ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: LD_INT 4
32911: PPUSH
32912: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32916: LD_ADDR_EXP 34
32920: PUSH
32921: LD_EXP 34
32925: PUSH
32926: LD_INT 1
32928: PLUS
32929: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32930: LD_INT 70
32932: PPUSH
32933: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32937: LD_INT 260
32939: PPUSH
32940: LD_INT 235
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: LD_INT 8
32948: NEG
32949: PPUSH
32950: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32963: LD_VAR 0 1
32967: PPUSH
32968: LD_EXP 77
32972: PPUSH
32973: CALL_OW 119
// DialogueOn ;
32977: CALL_OW 6
// case unit of JMM :
32981: LD_VAR 0 1
32985: PUSH
32986: LD_EXP 40
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33011
32996: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32997: LD_EXP 40
33001: PPUSH
33002: LD_STRING DA1-JMM-1
33004: PPUSH
33005: CALL_OW 91
33009: GO 33453
33011: LD_EXP 41
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33036
33021: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33022: LD_EXP 41
33026: PPUSH
33027: LD_STRING DA1-Joan-1
33029: PPUSH
33030: CALL_OW 91
33034: GO 33453
33036: LD_EXP 43
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33061
33046: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33047: LD_EXP 43
33051: PPUSH
33052: LD_STRING DA1-Lisa-1
33054: PPUSH
33055: CALL_OW 91
33059: GO 33453
33061: LD_EXP 44
33065: DOUBLE
33066: EQUAL
33067: IFTRUE 33071
33069: GO 33086
33071: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
33072: LD_EXP 44
33076: PPUSH
33077: LD_STRING DA1-Don-1
33079: PPUSH
33080: CALL_OW 91
33084: GO 33453
33086: LD_EXP 51
33090: DOUBLE
33091: EQUAL
33092: IFTRUE 33096
33094: GO 33111
33096: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
33097: LD_EXP 51
33101: PPUSH
33102: LD_STRING DA1-Corn-1
33104: PPUSH
33105: CALL_OW 91
33109: GO 33453
33111: LD_EXP 47
33115: DOUBLE
33116: EQUAL
33117: IFTRUE 33121
33119: GO 33136
33121: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
33122: LD_EXP 47
33126: PPUSH
33127: LD_STRING DA1-Den-1
33129: PPUSH
33130: CALL_OW 91
33134: GO 33453
33136: LD_EXP 45
33140: DOUBLE
33141: EQUAL
33142: IFTRUE 33146
33144: GO 33161
33146: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
33147: LD_EXP 45
33151: PPUSH
33152: LD_STRING DA1-Bobby-1
33154: PPUSH
33155: CALL_OW 91
33159: GO 33453
33161: LD_EXP 49
33165: DOUBLE
33166: EQUAL
33167: IFTRUE 33171
33169: GO 33186
33171: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
33172: LD_EXP 49
33176: PPUSH
33177: LD_STRING DA1-Glad-1
33179: PPUSH
33180: CALL_OW 91
33184: GO 33453
33186: LD_EXP 46
33190: DOUBLE
33191: EQUAL
33192: IFTRUE 33196
33194: GO 33211
33196: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33197: LD_EXP 46
33201: PPUSH
33202: LD_STRING DA1-Cyrus-1
33204: PPUSH
33205: CALL_OW 91
33209: GO 33453
33211: LD_EXP 42
33215: DOUBLE
33216: EQUAL
33217: IFTRUE 33221
33219: GO 33236
33221: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33222: LD_EXP 42
33226: PPUSH
33227: LD_STRING DA1-Huck-1
33229: PPUSH
33230: CALL_OW 91
33234: GO 33453
33236: LD_EXP 56
33240: DOUBLE
33241: EQUAL
33242: IFTRUE 33246
33244: GO 33261
33246: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33247: LD_EXP 56
33251: PPUSH
33252: LD_STRING DA1-Huck-1
33254: PPUSH
33255: CALL_OW 91
33259: GO 33453
33261: LD_EXP 48
33265: DOUBLE
33266: EQUAL
33267: IFTRUE 33271
33269: GO 33286
33271: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33272: LD_EXP 48
33276: PPUSH
33277: LD_STRING DA1-Brown-1
33279: PPUSH
33280: CALL_OW 91
33284: GO 33453
33286: LD_EXP 52
33290: DOUBLE
33291: EQUAL
33292: IFTRUE 33296
33294: GO 33311
33296: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33297: LD_EXP 52
33301: PPUSH
33302: LD_STRING DA1-Gary-1
33304: PPUSH
33305: CALL_OW 91
33309: GO 33453
33311: LD_EXP 55
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33336
33321: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33322: LD_EXP 55
33326: PPUSH
33327: LD_STRING DA1-Con-1
33329: PPUSH
33330: CALL_OW 91
33334: GO 33453
33336: LD_EXP 62
33340: DOUBLE
33341: EQUAL
33342: IFTRUE 33346
33344: GO 33361
33346: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33347: LD_EXP 62
33351: PPUSH
33352: LD_STRING DA1-Kurt-1
33354: PPUSH
33355: CALL_OW 91
33359: GO 33453
33361: LD_EXP 54
33365: DOUBLE
33366: EQUAL
33367: IFTRUE 33371
33369: GO 33386
33371: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33372: LD_EXP 54
33376: PPUSH
33377: LD_STRING DA1-Yam-1
33379: PPUSH
33380: CALL_OW 91
33384: GO 33453
33386: LD_EXP 53
33390: DOUBLE
33391: EQUAL
33392: IFTRUE 33396
33394: GO 33411
33396: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33397: LD_EXP 53
33401: PPUSH
33402: LD_STRING DA1-Frank-1
33404: PPUSH
33405: CALL_OW 91
33409: GO 33453
33411: POP
// begin if GetSex ( unit ) = sex_male then
33412: LD_VAR 0 1
33416: PPUSH
33417: CALL_OW 258
33421: PUSH
33422: LD_INT 1
33424: EQUAL
33425: IFFALSE 33441
// ForceSay ( unit , DA1-Sol1-1 ) else
33427: LD_VAR 0 1
33431: PPUSH
33432: LD_STRING DA1-Sol1-1
33434: PPUSH
33435: CALL_OW 91
33439: GO 33453
// ForceSay ( unit , DA1-FSol1-1 ) ;
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_STRING DA1-FSol1-1
33448: PPUSH
33449: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33453: LD_EXP 77
33457: PPUSH
33458: LD_STRING DA-Roth-1
33460: PPUSH
33461: CALL_OW 88
// if capturedUnit = 1 then
33465: LD_EXP 34
33469: PUSH
33470: LD_INT 1
33472: EQUAL
33473: IFFALSE 33501
// begin Say ( Simms , DA-Sim-1 ) ;
33475: LD_EXP 78
33479: PPUSH
33480: LD_STRING DA-Sim-1
33482: PPUSH
33483: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33487: LD_EXP 77
33491: PPUSH
33492: LD_STRING DA-Roth-2
33494: PPUSH
33495: CALL_OW 88
// end else
33499: GO 33513
// Say ( Simms , DA-Sim-2 ) ;
33501: LD_EXP 78
33505: PPUSH
33506: LD_STRING DA-Sim-2
33508: PPUSH
33509: CALL_OW 88
// case unit of JMM :
33513: LD_VAR 0 1
33517: PUSH
33518: LD_EXP 40
33522: DOUBLE
33523: EQUAL
33524: IFTRUE 33528
33526: GO 33543
33528: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33529: LD_EXP 40
33533: PPUSH
33534: LD_STRING DA1-JMM-1a
33536: PPUSH
33537: CALL_OW 91
33541: GO 34050
33543: LD_EXP 41
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33568
33553: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33554: LD_EXP 41
33558: PPUSH
33559: LD_STRING DA1-Joan-1a
33561: PPUSH
33562: CALL_OW 91
33566: GO 34050
33568: LD_EXP 43
33572: DOUBLE
33573: EQUAL
33574: IFTRUE 33578
33576: GO 33593
33578: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33579: LD_EXP 43
33583: PPUSH
33584: LD_STRING DA1-Lisa-1a
33586: PPUSH
33587: CALL_OW 91
33591: GO 34050
33593: LD_EXP 44
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33618
33603: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33604: LD_EXP 44
33608: PPUSH
33609: LD_STRING DA1-Don-1a
33611: PPUSH
33612: CALL_OW 91
33616: GO 34050
33618: LD_EXP 51
33622: DOUBLE
33623: EQUAL
33624: IFTRUE 33628
33626: GO 33643
33628: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33629: LD_EXP 51
33633: PPUSH
33634: LD_STRING DA1-Corn-1a
33636: PPUSH
33637: CALL_OW 91
33641: GO 34050
33643: LD_EXP 47
33647: DOUBLE
33648: EQUAL
33649: IFTRUE 33653
33651: GO 33668
33653: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33654: LD_EXP 47
33658: PPUSH
33659: LD_STRING DA1-Den-1a
33661: PPUSH
33662: CALL_OW 91
33666: GO 34050
33668: LD_EXP 45
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33693
33678: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33679: LD_EXP 45
33683: PPUSH
33684: LD_STRING DA1-Bobby-1a
33686: PPUSH
33687: CALL_OW 91
33691: GO 34050
33693: LD_EXP 49
33697: DOUBLE
33698: EQUAL
33699: IFTRUE 33703
33701: GO 33718
33703: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33704: LD_EXP 49
33708: PPUSH
33709: LD_STRING DA1-Glad-1a
33711: PPUSH
33712: CALL_OW 91
33716: GO 34050
33718: LD_EXP 46
33722: DOUBLE
33723: EQUAL
33724: IFTRUE 33728
33726: GO 33743
33728: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33729: LD_EXP 46
33733: PPUSH
33734: LD_STRING DA1-Cyrus-1a
33736: PPUSH
33737: CALL_OW 91
33741: GO 34050
33743: LD_EXP 42
33747: DOUBLE
33748: EQUAL
33749: IFTRUE 33753
33751: GO 33768
33753: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33754: LD_EXP 42
33758: PPUSH
33759: LD_STRING DA1-Huck-1a
33761: PPUSH
33762: CALL_OW 91
33766: GO 34050
33768: LD_EXP 56
33772: DOUBLE
33773: EQUAL
33774: IFTRUE 33778
33776: GO 33793
33778: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33779: LD_EXP 56
33783: PPUSH
33784: LD_STRING DA1-Huck-1a
33786: PPUSH
33787: CALL_OW 91
33791: GO 34050
33793: LD_EXP 48
33797: DOUBLE
33798: EQUAL
33799: IFTRUE 33803
33801: GO 33818
33803: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33804: LD_EXP 48
33808: PPUSH
33809: LD_STRING DA1-Brown-1a
33811: PPUSH
33812: CALL_OW 91
33816: GO 34050
33818: LD_EXP 52
33822: DOUBLE
33823: EQUAL
33824: IFTRUE 33828
33826: GO 33843
33828: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33829: LD_EXP 52
33833: PPUSH
33834: LD_STRING DA1-Gary-1a
33836: PPUSH
33837: CALL_OW 91
33841: GO 34050
33843: LD_EXP 55
33847: DOUBLE
33848: EQUAL
33849: IFTRUE 33853
33851: GO 33868
33853: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33854: LD_EXP 55
33858: PPUSH
33859: LD_STRING DA1-Con-1a
33861: PPUSH
33862: CALL_OW 91
33866: GO 34050
33868: LD_EXP 62
33872: DOUBLE
33873: EQUAL
33874: IFTRUE 33878
33876: GO 33893
33878: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33879: LD_EXP 62
33883: PPUSH
33884: LD_STRING DA1-Kurt-1a
33886: PPUSH
33887: CALL_OW 91
33891: GO 34050
33893: LD_EXP 54
33897: DOUBLE
33898: EQUAL
33899: IFTRUE 33903
33901: GO 33918
33903: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33904: LD_EXP 54
33908: PPUSH
33909: LD_STRING DA1-Yam-1a
33911: PPUSH
33912: CALL_OW 91
33916: GO 34050
33918: LD_EXP 53
33922: DOUBLE
33923: EQUAL
33924: IFTRUE 33928
33926: GO 33943
33928: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33929: LD_EXP 53
33933: PPUSH
33934: LD_STRING DA1-Frank-1a
33936: PPUSH
33937: CALL_OW 91
33941: GO 34050
33943: POP
// begin join := rand ( 0 , 1 ) ;
33944: LD_ADDR_VAR 0 3
33948: PUSH
33949: LD_INT 0
33951: PPUSH
33952: LD_INT 1
33954: PPUSH
33955: CALL_OW 12
33959: ST_TO_ADDR
// if join then
33960: LD_VAR 0 3
33964: IFFALSE 34009
// begin if GetSex ( unit ) = sex_male then
33966: LD_VAR 0 1
33970: PPUSH
33971: CALL_OW 258
33975: PUSH
33976: LD_INT 1
33978: EQUAL
33979: IFFALSE 33995
// ForceSay ( unit , DA1-Sol1-1b ) else
33981: LD_VAR 0 1
33985: PPUSH
33986: LD_STRING DA1-Sol1-1b
33988: PPUSH
33989: CALL_OW 91
33993: GO 34007
// ForceSay ( unit , DA1-FSol1-1b ) ;
33995: LD_VAR 0 1
33999: PPUSH
34000: LD_STRING DA1-FSol1-1b
34002: PPUSH
34003: CALL_OW 91
// end else
34007: GO 34050
// begin if GetSex ( unit ) = sex_male then
34009: LD_VAR 0 1
34013: PPUSH
34014: CALL_OW 258
34018: PUSH
34019: LD_INT 1
34021: EQUAL
34022: IFFALSE 34038
// ForceSay ( unit , DA1-Sol1-1a ) else
34024: LD_VAR 0 1
34028: PPUSH
34029: LD_STRING DA1-Sol1-1a
34031: PPUSH
34032: CALL_OW 91
34036: GO 34050
// ForceSay ( unit , DA1-FSol1-1a ) ;
34038: LD_VAR 0 1
34042: PPUSH
34043: LD_STRING DA1-FSol1-1a
34045: PPUSH
34046: CALL_OW 91
// end ; end ; end ; if unit = JMM then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 40
34059: EQUAL
34060: IFFALSE 34071
// begin YouLost ( JMMCaptured ) ;
34062: LD_STRING JMMCaptured
34064: PPUSH
34065: CALL_OW 104
// exit ;
34069: GO 34369
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
34071: LD_VAR 0 1
34075: PUSH
34076: LD_EXP 44
34080: PUSH
34081: LD_EXP 47
34085: PUSH
34086: LD_EXP 45
34090: PUSH
34091: LD_EXP 42
34095: PUSH
34096: LD_EXP 56
34100: PUSH
34101: LD_EXP 48
34105: PUSH
34106: LD_EXP 54
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: IN
34120: PUSH
34121: LD_VAR 0 3
34125: OR
34126: IFFALSE 34225
// begin Say ( Roth , DA-Roth-3 ) ;
34128: LD_EXP 77
34132: PPUSH
34133: LD_STRING DA-Roth-3
34135: PPUSH
34136: CALL_OW 88
// SetSide ( unit , 7 ) ;
34140: LD_VAR 0 1
34144: PPUSH
34145: LD_INT 7
34147: PPUSH
34148: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
34152: LD_ADDR_EXP 100
34156: PUSH
34157: LD_EXP 100
34161: PPUSH
34162: LD_INT 1
34164: PPUSH
34165: LD_EXP 100
34169: PUSH
34170: LD_INT 1
34172: ARRAY
34173: PUSH
34174: LD_VAR 0 1
34178: ADD
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34185: LD_INT 260
34187: PPUSH
34188: LD_INT 235
34190: PPUSH
34191: LD_INT 1
34193: PPUSH
34194: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 1000
34205: PPUSH
34206: CALL_OW 234
// DialogueOff ;
34210: CALL_OW 7
// ComFree ( unit ) ;
34214: LD_VAR 0 1
34218: PPUSH
34219: CALL_OW 139
// end else
34223: GO 34306
// begin Say ( Roth , DA-Roth-3a ) ;
34225: LD_EXP 77
34229: PPUSH
34230: LD_STRING DA-Roth-3a
34232: PPUSH
34233: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34237: LD_ADDR_EXP 35
34241: PUSH
34242: LD_EXP 35
34246: PUSH
34247: LD_VAR 0 1
34251: ADD
34252: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34253: LD_INT 260
34255: PPUSH
34256: LD_INT 235
34258: PPUSH
34259: LD_INT 1
34261: PPUSH
34262: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34266: LD_VAR 0 1
34270: PPUSH
34271: LD_INT 1000
34273: PPUSH
34274: CALL_OW 234
// DialogueOff ;
34278: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34282: LD_VAR 0 1
34286: PPUSH
34287: LD_INT 272
34289: PPUSH
34290: LD_INT 254
34292: PPUSH
34293: CALL_OW 111
// AddComHold ( unit ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 200
// end ; if capturedUnit = 1 then
34306: LD_EXP 34
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34369
// begin DialogueOn ;
34316: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34320: LD_EXP 40
34324: PPUSH
34325: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34329: LD_EXP 40
34333: PPUSH
34334: LD_STRING DAa-JMM-1
34336: PPUSH
34337: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34341: LD_EXP 40
34345: PPUSH
34346: LD_STRING DAa-JMM-1a
34348: PPUSH
34349: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34353: LD_EXP 40
34357: PPUSH
34358: LD_STRING DAa-JMM-1b
34360: PPUSH
34361: CALL_OW 88
// DialogueOff ;
34365: CALL_OW 7
// end ; end ;
34369: LD_VAR 0 2
34373: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34374: LD_EXP 15
34378: PUSH
34379: LD_INT 13
34381: GREATEREQUAL
34382: PUSH
34383: LD_INT 22
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 21
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PPUSH
34407: CALL_OW 69
34411: PUSH
34412: LD_INT 0
34414: EQUAL
34415: AND
34416: PUSH
34417: LD_INT 22
34419: PUSH
34420: LD_INT 2
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 33
34429: PUSH
34430: LD_INT 5
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 21
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 50
34449: PUSH
34450: EMPTY
34451: LIST
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: PPUSH
34459: CALL_OW 69
34463: PUSH
34464: LD_INT 0
34466: EQUAL
34467: AND
34468: PUSH
34469: LD_EXP 21
34473: AND
34474: PUSH
34475: LD_EXP 22
34479: AND
34480: PUSH
34481: LD_EXP 23
34485: AND
34486: IFFALSE 35175
34488: GO 34490
34490: DISABLE
34491: LD_INT 0
34493: PPUSH
34494: PPUSH
34495: PPUSH
// begin m1 := false ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_INT 0
34503: ST_TO_ADDR
// m2 := false ;
34504: LD_ADDR_VAR 0 2
34508: PUSH
34509: LD_INT 0
34511: ST_TO_ADDR
// m3 := false ;
34512: LD_ADDR_VAR 0 3
34516: PUSH
34517: LD_INT 0
34519: ST_TO_ADDR
// if not bombExploded then
34520: LD_EXP 37
34524: NOT
34525: IFFALSE 34534
// SetAchievement ( ACH_SIBROCKET ) ;
34527: LD_STRING ACH_SIBROCKET
34529: PPUSH
34530: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34534: LD_EXP 64
34538: PPUSH
34539: CALL_OW 255
34543: PUSH
34544: LD_INT 1
34546: EQUAL
34547: PUSH
34548: LD_EXP 64
34552: PPUSH
34553: CALL_OW 302
34557: AND
34558: IFFALSE 34574
// begin wait ( 3 ) ;
34560: LD_INT 3
34562: PPUSH
34563: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34567: LD_STRING ACH_OPO
34569: PPUSH
34570: CALL_OW 543
// end ; if tick <= 120 120$00 then
34574: LD_OWVAR 1
34578: PUSH
34579: LD_INT 252000
34581: LESSEQUAL
34582: IFFALSE 34598
// begin wait ( 3 ) ;
34584: LD_INT 3
34586: PPUSH
34587: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34591: LD_STRING ACH_ASPEED_15
34593: PPUSH
34594: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34598: LD_EXP 40
34602: PPUSH
34603: CALL_OW 87
// music_class := 5 ;
34607: LD_ADDR_OWVAR 72
34611: PUSH
34612: LD_INT 5
34614: ST_TO_ADDR
// music_nat := 5 ;
34615: LD_ADDR_OWVAR 71
34619: PUSH
34620: LD_INT 5
34622: ST_TO_ADDR
// DialogueOn ;
34623: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34627: LD_EXP 40
34631: PPUSH
34632: LD_STRING D20-JMM-1
34634: PPUSH
34635: CALL_OW 88
// if IsOK ( Joan ) then
34639: LD_EXP 41
34643: PPUSH
34644: CALL_OW 302
34648: IFFALSE 34662
// Say ( Joan , D20-Joan-1 ) ;
34650: LD_EXP 41
34654: PPUSH
34655: LD_STRING D20-Joan-1
34657: PPUSH
34658: CALL_OW 88
// if IsOk ( Lisa ) then
34662: LD_EXP 43
34666: PPUSH
34667: CALL_OW 302
34671: IFFALSE 34685
// Say ( Lisa , D20-Lisa-1 ) ;
34673: LD_EXP 43
34677: PPUSH
34678: LD_STRING D20-Lisa-1
34680: PPUSH
34681: CALL_OW 88
// if IsOk ( Donaldson ) then
34685: LD_EXP 44
34689: PPUSH
34690: CALL_OW 302
34694: IFFALSE 34708
// Say ( Donaldson , D20-Don-1 ) ;
34696: LD_EXP 44
34700: PPUSH
34701: LD_STRING D20-Don-1
34703: PPUSH
34704: CALL_OW 88
// if IsOK ( Cornel ) then
34708: LD_EXP 51
34712: PPUSH
34713: CALL_OW 302
34717: IFFALSE 34731
// Say ( Cornel , D20-Corn-1 ) ;
34719: LD_EXP 51
34723: PPUSH
34724: LD_STRING D20-Corn-1
34726: PPUSH
34727: CALL_OW 88
// if IsOk ( Denis ) then
34731: LD_EXP 47
34735: PPUSH
34736: CALL_OW 302
34740: IFFALSE 34754
// Say ( Denis , D20-Den-1 ) ;
34742: LD_EXP 47
34746: PPUSH
34747: LD_STRING D20-Den-1
34749: PPUSH
34750: CALL_OW 88
// if IsOk ( Bobby ) then
34754: LD_EXP 45
34758: PPUSH
34759: CALL_OW 302
34763: IFFALSE 34777
// Say ( Bobby , D20-Bobby-1 ) ;
34765: LD_EXP 45
34769: PPUSH
34770: LD_STRING D20-Bobby-1
34772: PPUSH
34773: CALL_OW 88
// if IsOk ( Gladstone ) then
34777: LD_EXP 49
34781: PPUSH
34782: CALL_OW 302
34786: IFFALSE 34800
// Say ( Gladstone , D20-Glad-1 ) ;
34788: LD_EXP 49
34792: PPUSH
34793: LD_STRING D20-Glad-1
34795: PPUSH
34796: CALL_OW 88
// if IsOk ( Cyrus ) then
34800: LD_EXP 46
34804: PPUSH
34805: CALL_OW 302
34809: IFFALSE 34823
// Say ( Cyrus , D20-Cyrus-1 ) ;
34811: LD_EXP 46
34815: PPUSH
34816: LD_STRING D20-Cyrus-1
34818: PPUSH
34819: CALL_OW 88
// if IsOk ( Stevens ) then
34823: LD_EXP 42
34827: PPUSH
34828: CALL_OW 302
34832: IFFALSE 34846
// Say ( Stevens , D20-Huck-1 ) ;
34834: LD_EXP 42
34838: PPUSH
34839: LD_STRING D20-Huck-1
34841: PPUSH
34842: CALL_OW 88
// if IsOk ( Brown ) then
34846: LD_EXP 48
34850: PPUSH
34851: CALL_OW 302
34855: IFFALSE 34869
// Say ( Brown , D20-Brown-1 ) ;
34857: LD_EXP 48
34861: PPUSH
34862: LD_STRING D20-Brown-1
34864: PPUSH
34865: CALL_OW 88
// if IsOk ( Gary ) then
34869: LD_EXP 52
34873: PPUSH
34874: CALL_OW 302
34878: IFFALSE 34892
// Say ( Gary , D20-Gary-1 ) ;
34880: LD_EXP 52
34884: PPUSH
34885: LD_STRING D20-Gary-1
34887: PPUSH
34888: CALL_OW 88
// if IsOk ( Connie ) then
34892: LD_EXP 55
34896: PPUSH
34897: CALL_OW 302
34901: IFFALSE 34915
// Say ( Connie , D20-Con-1 ) ;
34903: LD_EXP 55
34907: PPUSH
34908: LD_STRING D20-Con-1
34910: PPUSH
34911: CALL_OW 88
// if IsOk ( Kurt ) then
34915: LD_EXP 62
34919: PPUSH
34920: CALL_OW 302
34924: IFFALSE 34938
// Say ( Kurt , D20-Kurt-1 ) ;
34926: LD_EXP 62
34930: PPUSH
34931: LD_STRING D20-Kurt-1
34933: PPUSH
34934: CALL_OW 88
// if IsOk ( Kikuchi ) then
34938: LD_EXP 54
34942: PPUSH
34943: CALL_OW 302
34947: IFFALSE 34961
// Say ( Kikuchi , D20-Yam-1 ) ;
34949: LD_EXP 54
34953: PPUSH
34954: LD_STRING D20-Yam-1
34956: PPUSH
34957: CALL_OW 88
// if IsOk ( Frank ) then
34961: LD_EXP 53
34965: PPUSH
34966: CALL_OW 302
34970: IFFALSE 34984
// Say ( Frank , D20-Frank-1 ) ;
34972: LD_EXP 53
34976: PPUSH
34977: LD_STRING D20-Frank-1
34979: PPUSH
34980: CALL_OW 88
// DialogueOff ;
34984: CALL_OW 7
// if RothCaptured then
34988: LD_EXP 33
34992: IFFALSE 35014
// begin m1 := true ;
34994: LD_ADDR_VAR 0 1
34998: PUSH
34999: LD_INT 1
35001: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35002: LD_STRING Roth
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: CALL_OW 101
// end else
35012: GO 35025
// AddMedal ( Roth , - 1 ) ;
35014: LD_STRING Roth
35016: PPUSH
35017: LD_INT 1
35019: NEG
35020: PPUSH
35021: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
35025: LD_EXP 25
35029: NOT
35030: PUSH
35031: LD_EXP 27
35035: OR
35036: IFFALSE 35058
// begin m2 := true ;
35038: LD_ADDR_VAR 0 2
35042: PUSH
35043: LD_INT 1
35045: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
35046: LD_STRING Project
35048: PPUSH
35049: LD_INT 1
35051: PPUSH
35052: CALL_OW 101
// end else
35056: GO 35069
// AddMedal ( Project , - 1 ) ;
35058: LD_STRING Project
35060: PPUSH
35061: LD_INT 1
35063: NEG
35064: PPUSH
35065: CALL_OW 101
// if lostCounter = 0 then
35069: LD_EXP 32
35073: PUSH
35074: LD_INT 0
35076: EQUAL
35077: IFFALSE 35099
// begin m3 := true ;
35079: LD_ADDR_VAR 0 3
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
35087: LD_STRING NoLosses
35089: PPUSH
35090: LD_INT 1
35092: PPUSH
35093: CALL_OW 101
// end else
35097: GO 35110
// AddMedal ( NoLosses , - 1 ) ;
35099: LD_STRING NoLosses
35101: PPUSH
35102: LD_INT 1
35104: NEG
35105: PPUSH
35106: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
35110: LD_VAR 0 1
35114: PUSH
35115: LD_VAR 0 2
35119: AND
35120: PUSH
35121: LD_VAR 0 3
35125: AND
35126: PUSH
35127: LD_OWVAR 67
35131: PUSH
35132: LD_INT 3
35134: GREATEREQUAL
35135: AND
35136: IFFALSE 35148
// SetAchievementEX ( ACH_AMER , 15 ) ;
35138: LD_STRING ACH_AMER
35140: PPUSH
35141: LD_INT 15
35143: PPUSH
35144: CALL_OW 564
// GiveMedals ( MAIN ) ;
35148: LD_STRING MAIN
35150: PPUSH
35151: CALL_OW 102
// music_class := 4 ;
35155: LD_ADDR_OWVAR 72
35159: PUSH
35160: LD_INT 4
35162: ST_TO_ADDR
// music_nat := 1 ;
35163: LD_ADDR_OWVAR 71
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// YouWin ;
35171: CALL_OW 103
// end ; end_of_file
35175: PPOPN 3
35177: END
// export function CustomEvent ( event ) ; begin
35178: LD_INT 0
35180: PPUSH
// end ;
35181: LD_VAR 0 2
35185: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35186: LD_VAR 0 1
35190: PUSH
35191: LD_INT 1
35193: EQUAL
35194: PUSH
35195: LD_VAR 0 2
35199: PUSH
35200: LD_INT 4
35202: EQUAL
35203: AND
35204: PUSH
35205: LD_EXP 60
35209: PPUSH
35210: CALL_OW 300
35214: AND
35215: IFFALSE 35231
// begin wait ( 0 0$2 ) ;
35217: LD_INT 70
35219: PPUSH
35220: CALL_OW 67
// YouLost ( Dismissed ) ;
35224: LD_STRING Dismissed
35226: PPUSH
35227: CALL_OW 104
// end ; end ;
35231: PPOPN 2
35233: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35234: LD_VAR 0 2
35238: PPUSH
35239: LD_VAR 0 3
35243: PPUSH
35244: LD_INT 18
35246: PPUSH
35247: CALL_OW 309
35251: IFFALSE 35260
// YouLost ( Motherlode3 ) ;
35253: LD_STRING Motherlode3
35255: PPUSH
35256: CALL_OW 104
// end ;
35260: PPOPN 3
35262: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35263: LD_EXP 27
35267: NOT
35268: IFFALSE 35278
// behemothDone := true ;
35270: LD_ADDR_EXP 28
35274: PUSH
35275: LD_INT 1
35277: ST_TO_ADDR
// end ;
35278: PPOPN 1
35280: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35281: LD_VAR 0 1
35285: PPUSH
35286: CALL_OW 255
35290: PUSH
35291: LD_INT 1
35293: EQUAL
35294: IFFALSE 35304
// bombExploded := true ;
35296: LD_ADDR_EXP 37
35300: PUSH
35301: LD_INT 1
35303: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35304: LD_VAR 0 1
35308: PPUSH
35309: CALL_OW 255
35313: PUSH
35314: LD_INT 3
35316: EQUAL
35317: IFFALSE 35347
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35319: LD_INT 2
35321: PPUSH
35322: LD_INT 23
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: LD_INT 3
35330: PUSH
35331: LD_INT 48
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: PUSH
35340: EMPTY
35341: LIST
35342: PPUSH
35343: CALL 61122 0 2
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35347: LD_VAR 0 1
35351: PPUSH
35352: CALL_OW 255
35356: PUSH
35357: LD_INT 1
35359: EQUAL
35360: PUSH
35361: LD_EXP 30
35365: AND
35366: PUSH
35367: LD_INT 22
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 34
35379: PUSH
35380: LD_INT 48
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PPUSH
35391: CALL_OW 69
35395: AND
35396: PUSH
35397: LD_INT 22
35399: PUSH
35400: LD_INT 1
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 34
35409: PUSH
35410: LD_INT 8
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PPUSH
35421: CALL_OW 69
35425: NOT
35426: AND
35427: IFFALSE 35479
// begin wait ( 0 0$5 ) ;
35429: LD_INT 175
35431: PPUSH
35432: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35436: LD_INT 22
35438: PUSH
35439: LD_INT 3
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 34
35448: PUSH
35449: LD_INT 48
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PPUSH
35460: CALL_OW 69
35464: PUSH
35465: LD_INT 1
35467: ARRAY
35468: PPUSH
35469: LD_INT 60
35471: PPUSH
35472: LD_INT 95
35474: PPUSH
35475: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35479: LD_VAR 0 2
35483: PPUSH
35484: LD_VAR 0 3
35488: PPUSH
35489: LD_INT 18
35491: PPUSH
35492: CALL_OW 309
35496: PUSH
35497: LD_VAR 0 2
35501: PPUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_INT 18
35509: PPUSH
35510: CALL 108768 0 3
35514: OR
35515: IFFALSE 35562
// begin if GetSide ( unit ) = 1 then
35517: LD_VAR 0 1
35521: PPUSH
35522: CALL_OW 255
35526: PUSH
35527: LD_INT 1
35529: EQUAL
35530: IFFALSE 35548
// begin wait ( 0 0$6 ) ;
35532: LD_INT 210
35534: PPUSH
35535: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35539: LD_STRING Motherlode2
35541: PPUSH
35542: CALL_OW 104
// end else
35546: GO 35562
// begin wait ( 0 0$6 ) ;
35548: LD_INT 210
35550: PPUSH
35551: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35555: LD_STRING Motherlode1
35557: PPUSH
35558: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35562: LD_VAR 0 1
35566: PPUSH
35567: CALL_OW 255
35571: PUSH
35572: LD_INT 3
35574: EQUAL
35575: IFFALSE 35596
// begin wait ( 0 0$5 ) ;
35577: LD_INT 175
35579: PPUSH
35580: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35584: LD_EXP 66
35588: PPUSH
35589: LD_STRING D18-Pla-1
35591: PPUSH
35592: CALL_OW 94
// end ; end ;
35596: PPOPN 3
35598: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35599: LD_VAR 0 1
35603: PPUSH
35604: CALL 124561 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35608: LD_VAR 0 1
35612: PUSH
35613: LD_INT 22
35615: PUSH
35616: LD_INT 1
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 21
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 23
35635: PUSH
35636: LD_INT 1
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: LIST
35647: PPUSH
35648: CALL_OW 69
35652: IN
35653: IFFALSE 35669
// lostCounter := lostCounter + 1 ;
35655: LD_ADDR_EXP 32
35659: PUSH
35660: LD_EXP 32
35664: PUSH
35665: LD_INT 1
35667: PLUS
35668: ST_TO_ADDR
// if un in behemothBuilders then
35669: LD_VAR 0 1
35673: PUSH
35674: LD_EXP 75
35678: IN
35679: IFFALSE 35699
// begin behemothBuilders := behemothBuilders diff un ;
35681: LD_ADDR_EXP 75
35685: PUSH
35686: LD_EXP 75
35690: PUSH
35691: LD_VAR 0 1
35695: DIFF
35696: ST_TO_ADDR
// exit ;
35697: GO 35729
// end ; if un = JMM then
35699: LD_VAR 0 1
35703: PUSH
35704: LD_EXP 40
35708: EQUAL
35709: IFFALSE 35720
// begin YouLost ( JMM ) ;
35711: LD_STRING JMM
35713: PPUSH
35714: CALL_OW 104
// exit ;
35718: GO 35729
// end ; MCE_UnitDestroyed ( un ) ;
35720: LD_VAR 0 1
35724: PPUSH
35725: CALL 64526 0 1
// end ;
35729: PPOPN 1
35731: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35732: LD_VAR 0 1
35736: PPUSH
35737: LD_VAR 0 2
35741: PPUSH
35742: CALL 66858 0 2
// end ;
35746: PPOPN 2
35748: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35749: LD_VAR 0 1
35753: PPUSH
35754: CALL 65926 0 1
// end ;
35758: PPOPN 1
35760: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35761: LD_VAR 0 1
35765: PUSH
35766: LD_INT 22
35768: PUSH
35769: LD_INT 8
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 30
35778: PUSH
35779: LD_INT 2
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 23
35788: PUSH
35789: LD_INT 3
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: PPUSH
35801: CALL_OW 69
35805: IN
35806: IFFALSE 35833
// begin ComUpgrade ( building ) ;
35808: LD_VAR 0 1
35812: PPUSH
35813: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35817: LD_EXP 63
35821: PPUSH
35822: LD_VAR 0 1
35826: PPUSH
35827: CALL 75508 0 2
// exit ;
35831: GO 35842
// end ; MCE_BuildingComplete ( building ) ;
35833: LD_VAR 0 1
35837: PPUSH
35838: CALL 66167 0 1
// end ;
35842: PPOPN 1
35844: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35845: LD_VAR 0 1
35849: PPUSH
35850: LD_VAR 0 2
35854: PPUSH
35855: CALL 64222 0 2
// end ;
35859: PPOPN 2
35861: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35862: LD_VAR 0 1
35866: PPUSH
35867: LD_VAR 0 2
35871: PPUSH
35872: LD_VAR 0 3
35876: PPUSH
35877: LD_VAR 0 4
35881: PPUSH
35882: LD_VAR 0 5
35886: PPUSH
35887: CALL 63842 0 5
// end ;
35891: PPOPN 5
35893: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35894: LD_VAR 0 1
35898: PPUSH
35899: CALL_OW 255
35903: PUSH
35904: LD_INT 1
35906: EQUAL
35907: IFFALSE 35924
// amConstructCounter := Inc ( amConstructCounter ) ;
35909: LD_ADDR_EXP 39
35913: PUSH
35914: LD_EXP 39
35918: PPUSH
35919: CALL 106320 0 1
35923: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35924: LD_VAR 0 1
35928: PPUSH
35929: LD_VAR 0 2
35933: PPUSH
35934: CALL 124681 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35938: LD_VAR 0 1
35942: PPUSH
35943: LD_VAR 0 2
35947: PPUSH
35948: CALL 63433 0 2
// end ;
35952: PPOPN 2
35954: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35955: LD_VAR 0 1
35959: PPUSH
35960: LD_VAR 0 2
35964: PPUSH
35965: LD_VAR 0 3
35969: PPUSH
35970: LD_VAR 0 4
35974: PPUSH
35975: CALL 63271 0 4
// end ;
35979: PPOPN 4
35981: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35982: LD_VAR 0 1
35986: PPUSH
35987: LD_VAR 0 2
35991: PPUSH
35992: LD_VAR 0 3
35996: PPUSH
35997: CALL 63046 0 3
// end ;
36001: PPOPN 3
36003: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36004: LD_VAR 0 1
36008: PPUSH
36009: LD_VAR 0 2
36013: PPUSH
36014: CALL 62931 0 2
// end ;
36018: PPOPN 2
36020: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
36021: LD_VAR 0 1
36025: PPUSH
36026: LD_VAR 0 2
36030: PPUSH
36031: CALL 67153 0 2
// end ;
36035: PPOPN 2
36037: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
36038: LD_VAR 0 1
36042: PPUSH
36043: CALL_OW 255
36047: PUSH
36048: LD_INT 4
36050: EQUAL
36051: PUSH
36052: LD_VAR 0 1
36056: PUSH
36057: LD_EXP 18
36061: PUSH
36062: LD_INT 1
36064: ARRAY
36065: IN
36066: AND
36067: PUSH
36068: LD_EXP 19
36072: AND
36073: IFFALSE 36092
// begin ComMoveXY ( driver , 61 , 93 ) ;
36075: LD_VAR 0 1
36079: PPUSH
36080: LD_INT 61
36082: PPUSH
36083: LD_INT 93
36085: PPUSH
36086: CALL_OW 111
// exit ;
36090: GO 36116
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
36092: LD_VAR 0 1
36096: PPUSH
36097: LD_VAR 0 2
36101: PPUSH
36102: LD_VAR 0 3
36106: PPUSH
36107: LD_VAR 0 4
36111: PPUSH
36112: CALL 67369 0 4
// end ;
36116: PPOPN 4
36118: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
36119: LD_VAR 0 1
36123: PPUSH
36124: LD_VAR 0 2
36128: PPUSH
36129: CALL 62740 0 2
// end ;
36133: PPOPN 2
36135: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
36136: LD_VAR 0 1
36140: PPUSH
36141: CALL 124665 0 1
// end ; end_of_file
36145: PPOPN 1
36147: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
36148: LD_EXP 15
36152: PUSH
36153: LD_INT 2
36155: EQUAL
36156: IFFALSE 36659
36158: GO 36160
36160: DISABLE
36161: LD_INT 0
36163: PPUSH
36164: PPUSH
// begin time := 0 0$35 ;
36165: LD_ADDR_VAR 0 2
36169: PUSH
36170: LD_INT 1225
36172: ST_TO_ADDR
// repeat wait ( time ) ;
36173: LD_VAR 0 2
36177: PPUSH
36178: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36182: LD_INT 1
36184: PPUSH
36185: LD_INT 5
36187: PPUSH
36188: CALL_OW 12
36192: PPUSH
36193: LD_INT 106
36195: PPUSH
36196: LD_INT 150
36198: PPUSH
36199: LD_INT 19
36201: PPUSH
36202: LD_INT 1
36204: PPUSH
36205: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36209: LD_INT 455
36211: PPUSH
36212: LD_INT 770
36214: PPUSH
36215: CALL_OW 12
36219: PPUSH
36220: CALL_OW 67
// if Prob ( 50 ) then
36224: LD_INT 50
36226: PPUSH
36227: CALL_OW 13
36231: IFFALSE 36260
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36233: LD_INT 1
36235: PPUSH
36236: LD_INT 5
36238: PPUSH
36239: CALL_OW 12
36243: PPUSH
36244: LD_INT 62
36246: PPUSH
36247: LD_INT 108
36249: PPUSH
36250: LD_INT 10
36252: PPUSH
36253: LD_INT 1
36255: PPUSH
36256: CALL_OW 56
// until missionStage > 4 ;
36260: LD_EXP 15
36264: PUSH
36265: LD_INT 4
36267: GREATER
36268: IFFALSE 36173
// repeat wait ( 0 0$1 ) ;
36270: LD_INT 35
36272: PPUSH
36273: CALL_OW 67
// until missionStage = 6 ;
36277: LD_EXP 15
36281: PUSH
36282: LD_INT 6
36284: EQUAL
36285: IFFALSE 36270
// time := 0 0$20 ;
36287: LD_ADDR_VAR 0 2
36291: PUSH
36292: LD_INT 700
36294: ST_TO_ADDR
// repeat wait ( time ) ;
36295: LD_VAR 0 2
36299: PPUSH
36300: CALL_OW 67
// if Prob ( 90 ) then
36304: LD_INT 90
36306: PPUSH
36307: CALL_OW 13
36311: IFFALSE 36354
// begin time := time + 0 0$2 ;
36313: LD_ADDR_VAR 0 2
36317: PUSH
36318: LD_VAR 0 2
36322: PUSH
36323: LD_INT 70
36325: PLUS
36326: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36327: LD_INT 1
36329: PPUSH
36330: LD_INT 5
36332: PPUSH
36333: CALL_OW 12
36337: PPUSH
36338: LD_INT 106
36340: PPUSH
36341: LD_INT 89
36343: PPUSH
36344: LD_INT 45
36346: PPUSH
36347: LD_INT 1
36349: PPUSH
36350: CALL_OW 56
// end ; if Prob ( 45 ) then
36354: LD_INT 45
36356: PPUSH
36357: CALL_OW 13
36361: IFFALSE 36417
// begin for i := 1 to 4 do
36363: LD_ADDR_VAR 0 1
36367: PUSH
36368: DOUBLE
36369: LD_INT 1
36371: DEC
36372: ST_TO_ADDR
36373: LD_INT 4
36375: PUSH
36376: FOR_TO
36377: IFFALSE 36415
// begin wait ( 0 0$5 ) ;
36379: LD_INT 175
36381: PPUSH
36382: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36386: LD_INT 1
36388: PPUSH
36389: LD_INT 5
36391: PPUSH
36392: CALL_OW 12
36396: PPUSH
36397: LD_INT 113
36399: PPUSH
36400: LD_INT 117
36402: PPUSH
36403: LD_INT 25
36405: PPUSH
36406: LD_INT 1
36408: PPUSH
36409: CALL_OW 56
// end ;
36413: GO 36376
36415: POP
36416: POP
// end ; if Prob ( 40 ) then
36417: LD_INT 40
36419: PPUSH
36420: CALL_OW 13
36424: IFFALSE 36470
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36426: LD_INT 385
36428: PPUSH
36429: LD_INT 945
36431: PPUSH
36432: CALL_OW 12
36436: PPUSH
36437: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36441: LD_INT 1
36443: PPUSH
36444: LD_INT 5
36446: PPUSH
36447: CALL_OW 12
36451: PPUSH
36452: LD_INT 21
36454: PPUSH
36455: LD_INT 26
36457: PPUSH
36458: LD_INT 12
36460: PPUSH
36461: LD_INT 1
36463: PPUSH
36464: CALL_OW 56
// end else
36468: GO 36506
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36470: LD_INT 700
36472: PPUSH
36473: LD_INT 1225
36475: PPUSH
36476: CALL_OW 12
36480: PPUSH
36481: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36485: LD_INT 1
36487: PPUSH
36488: LD_INT 5
36490: PPUSH
36491: CALL_OW 12
36495: PPUSH
36496: LD_INT 16
36498: PPUSH
36499: LD_INT 1
36501: PPUSH
36502: CALL_OW 55
// end ; if Prob ( 50 ) then
36506: LD_INT 50
36508: PPUSH
36509: CALL_OW 13
36513: IFFALSE 36559
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36515: LD_INT 700
36517: PPUSH
36518: LD_INT 1050
36520: PPUSH
36521: CALL_OW 12
36525: PPUSH
36526: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36530: LD_INT 1
36532: PPUSH
36533: LD_INT 5
36535: PPUSH
36536: CALL_OW 12
36540: PPUSH
36541: LD_INT 168
36543: PPUSH
36544: LD_INT 168
36546: PPUSH
36547: LD_INT 16
36549: PPUSH
36550: LD_INT 1
36552: PPUSH
36553: CALL_OW 56
// end else
36557: GO 36595
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36559: LD_INT 350
36561: PPUSH
36562: LD_INT 525
36564: PPUSH
36565: CALL_OW 12
36569: PPUSH
36570: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36574: LD_INT 1
36576: PPUSH
36577: LD_INT 5
36579: PPUSH
36580: CALL_OW 12
36584: PPUSH
36585: LD_INT 15
36587: PPUSH
36588: LD_INT 1
36590: PPUSH
36591: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36595: LD_INT 175
36597: PPUSH
36598: LD_INT 315
36600: PPUSH
36601: CALL_OW 12
36605: PPUSH
36606: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36610: LD_INT 1
36612: PPUSH
36613: LD_INT 5
36615: PPUSH
36616: CALL_OW 12
36620: PPUSH
36621: LD_INT 103
36623: PPUSH
36624: LD_INT 140
36626: PPUSH
36627: LD_INT 20
36629: PPUSH
36630: LD_INT 1
36632: PPUSH
36633: CALL_OW 56
// if time > 1 1$10 then
36637: LD_VAR 0 2
36641: PUSH
36642: LD_INT 2450
36644: GREATER
36645: IFFALSE 36655
// time := 0 0$30 ;
36647: LD_ADDR_VAR 0 2
36651: PUSH
36652: LD_INT 1050
36654: ST_TO_ADDR
// until false ;
36655: LD_INT 0
36657: IFFALSE 36295
// end ; end_of_file
36659: PPOPN 2
36661: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36662: LD_EXP 13
36666: PUSH
36667: LD_EXP 15
36671: PUSH
36672: LD_INT 6
36674: GREATEREQUAL
36675: AND
36676: IFFALSE 36713
36678: GO 36680
36680: DISABLE
// begin enable ;
36681: ENABLE
// missionTime := missionTime + 0 0$1 ;
36682: LD_ADDR_EXP 14
36686: PUSH
36687: LD_EXP 14
36691: PUSH
36692: LD_INT 35
36694: PLUS
36695: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36696: LD_ADDR_OWVAR 47
36700: PUSH
36701: LD_STRING #Am15-1
36703: PUSH
36704: LD_EXP 14
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: ST_TO_ADDR
// end ; end_of_file
36713: END
// export function InitNature ; begin
36714: LD_INT 0
36716: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36717: LD_INT 3
36719: PPUSH
36720: LD_INT 3
36722: PPUSH
36723: LD_INT 2
36725: PPUSH
36726: LD_INT 1
36728: PPUSH
36729: LD_INT 1
36731: PPUSH
36732: LD_INT 0
36734: PPUSH
36735: LD_INT 0
36737: PPUSH
36738: LD_INT 20
36740: PPUSH
36741: LD_INT 0
36743: PPUSH
36744: CALL 101641 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36748: LD_INT 2
36750: PPUSH
36751: LD_INT 1
36753: PPUSH
36754: LD_INT 1
36756: PPUSH
36757: LD_INT 1
36759: PPUSH
36760: LD_INT 1
36762: PPUSH
36763: LD_INT 0
36765: PPUSH
36766: LD_INT 0
36768: PPUSH
36769: LD_INT 21
36771: PPUSH
36772: LD_INT 0
36774: PPUSH
36775: CALL 101641 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36779: LD_INT 4
36781: PPUSH
36782: LD_INT 1
36784: PPUSH
36785: LD_INT 2
36787: PPUSH
36788: LD_INT 4
36790: PPUSH
36791: LD_INT 2
36793: PPUSH
36794: LD_INT 1
36796: PPUSH
36797: LD_INT 0
36799: PPUSH
36800: LD_INT 22
36802: PPUSH
36803: LD_INT 0
36805: PPUSH
36806: CALL 101641 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36810: LD_INT 0
36812: PPUSH
36813: LD_INT 0
36815: PPUSH
36816: LD_INT 0
36818: PPUSH
36819: LD_INT 0
36821: PPUSH
36822: LD_INT 0
36824: PPUSH
36825: LD_INT 0
36827: PPUSH
36828: LD_INT 9
36830: PPUSH
36831: LD_INT 0
36833: PPUSH
36834: LD_INT 23
36836: PPUSH
36837: CALL 101641 0 9
// end ; end_of_file
36841: LD_VAR 0 1
36845: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36846: LD_INT 0
36848: PPUSH
36849: PPUSH
// skirmish := false ;
36850: LD_ADDR_EXP 98
36854: PUSH
36855: LD_INT 0
36857: ST_TO_ADDR
// debug_mc := false ;
36858: LD_ADDR_EXP 99
36862: PUSH
36863: LD_INT 0
36865: ST_TO_ADDR
// mc_bases := [ ] ;
36866: LD_ADDR_EXP 100
36870: PUSH
36871: EMPTY
36872: ST_TO_ADDR
// mc_sides := [ ] ;
36873: LD_ADDR_EXP 126
36877: PUSH
36878: EMPTY
36879: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36880: LD_ADDR_EXP 101
36884: PUSH
36885: EMPTY
36886: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36887: LD_ADDR_EXP 102
36891: PUSH
36892: EMPTY
36893: ST_TO_ADDR
// mc_need_heal := [ ] ;
36894: LD_ADDR_EXP 103
36898: PUSH
36899: EMPTY
36900: ST_TO_ADDR
// mc_healers := [ ] ;
36901: LD_ADDR_EXP 104
36905: PUSH
36906: EMPTY
36907: ST_TO_ADDR
// mc_build_list := [ ] ;
36908: LD_ADDR_EXP 105
36912: PUSH
36913: EMPTY
36914: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36915: LD_ADDR_EXP 132
36919: PUSH
36920: EMPTY
36921: ST_TO_ADDR
// mc_builders := [ ] ;
36922: LD_ADDR_EXP 106
36926: PUSH
36927: EMPTY
36928: ST_TO_ADDR
// mc_construct_list := [ ] ;
36929: LD_ADDR_EXP 107
36933: PUSH
36934: EMPTY
36935: ST_TO_ADDR
// mc_turret_list := [ ] ;
36936: LD_ADDR_EXP 108
36940: PUSH
36941: EMPTY
36942: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36943: LD_ADDR_EXP 109
36947: PUSH
36948: EMPTY
36949: ST_TO_ADDR
// mc_miners := [ ] ;
36950: LD_ADDR_EXP 114
36954: PUSH
36955: EMPTY
36956: ST_TO_ADDR
// mc_mines := [ ] ;
36957: LD_ADDR_EXP 113
36961: PUSH
36962: EMPTY
36963: ST_TO_ADDR
// mc_minefields := [ ] ;
36964: LD_ADDR_EXP 115
36968: PUSH
36969: EMPTY
36970: ST_TO_ADDR
// mc_crates := [ ] ;
36971: LD_ADDR_EXP 116
36975: PUSH
36976: EMPTY
36977: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36978: LD_ADDR_EXP 117
36982: PUSH
36983: EMPTY
36984: ST_TO_ADDR
// mc_crates_area := [ ] ;
36985: LD_ADDR_EXP 118
36989: PUSH
36990: EMPTY
36991: ST_TO_ADDR
// mc_vehicles := [ ] ;
36992: LD_ADDR_EXP 119
36996: PUSH
36997: EMPTY
36998: ST_TO_ADDR
// mc_attack := [ ] ;
36999: LD_ADDR_EXP 120
37003: PUSH
37004: EMPTY
37005: ST_TO_ADDR
// mc_produce := [ ] ;
37006: LD_ADDR_EXP 121
37010: PUSH
37011: EMPTY
37012: ST_TO_ADDR
// mc_defender := [ ] ;
37013: LD_ADDR_EXP 122
37017: PUSH
37018: EMPTY
37019: ST_TO_ADDR
// mc_parking := [ ] ;
37020: LD_ADDR_EXP 124
37024: PUSH
37025: EMPTY
37026: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
37027: LD_ADDR_EXP 110
37031: PUSH
37032: EMPTY
37033: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
37034: LD_ADDR_EXP 112
37038: PUSH
37039: EMPTY
37040: ST_TO_ADDR
// mc_scan := [ ] ;
37041: LD_ADDR_EXP 123
37045: PUSH
37046: EMPTY
37047: ST_TO_ADDR
// mc_scan_area := [ ] ;
37048: LD_ADDR_EXP 125
37052: PUSH
37053: EMPTY
37054: ST_TO_ADDR
// mc_tech := [ ] ;
37055: LD_ADDR_EXP 127
37059: PUSH
37060: EMPTY
37061: ST_TO_ADDR
// mc_class := [ ] ;
37062: LD_ADDR_EXP 141
37066: PUSH
37067: EMPTY
37068: ST_TO_ADDR
// mc_class_case_use := [ ] ;
37069: LD_ADDR_EXP 142
37073: PUSH
37074: EMPTY
37075: ST_TO_ADDR
// mc_is_defending := [ ] ;
37076: LD_ADDR_EXP 143
37080: PUSH
37081: EMPTY
37082: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
37083: LD_ADDR_EXP 134
37087: PUSH
37088: EMPTY
37089: ST_TO_ADDR
// end ;
37090: LD_VAR 0 1
37094: RET
// export function MC_Kill ( base ) ; begin
37095: LD_INT 0
37097: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
37098: LD_ADDR_EXP 100
37102: PUSH
37103: LD_EXP 100
37107: PPUSH
37108: LD_VAR 0 1
37112: PPUSH
37113: EMPTY
37114: PPUSH
37115: CALL_OW 1
37119: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37120: LD_ADDR_EXP 101
37124: PUSH
37125: LD_EXP 101
37129: PPUSH
37130: LD_VAR 0 1
37134: PPUSH
37135: EMPTY
37136: PPUSH
37137: CALL_OW 1
37141: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37142: LD_ADDR_EXP 102
37146: PUSH
37147: LD_EXP 102
37151: PPUSH
37152: LD_VAR 0 1
37156: PPUSH
37157: EMPTY
37158: PPUSH
37159: CALL_OW 1
37163: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37164: LD_ADDR_EXP 103
37168: PUSH
37169: LD_EXP 103
37173: PPUSH
37174: LD_VAR 0 1
37178: PPUSH
37179: EMPTY
37180: PPUSH
37181: CALL_OW 1
37185: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37186: LD_ADDR_EXP 104
37190: PUSH
37191: LD_EXP 104
37195: PPUSH
37196: LD_VAR 0 1
37200: PPUSH
37201: EMPTY
37202: PPUSH
37203: CALL_OW 1
37207: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37208: LD_ADDR_EXP 105
37212: PUSH
37213: LD_EXP 105
37217: PPUSH
37218: LD_VAR 0 1
37222: PPUSH
37223: EMPTY
37224: PPUSH
37225: CALL_OW 1
37229: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37230: LD_ADDR_EXP 106
37234: PUSH
37235: LD_EXP 106
37239: PPUSH
37240: LD_VAR 0 1
37244: PPUSH
37245: EMPTY
37246: PPUSH
37247: CALL_OW 1
37251: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37252: LD_ADDR_EXP 107
37256: PUSH
37257: LD_EXP 107
37261: PPUSH
37262: LD_VAR 0 1
37266: PPUSH
37267: EMPTY
37268: PPUSH
37269: CALL_OW 1
37273: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37274: LD_ADDR_EXP 108
37278: PUSH
37279: LD_EXP 108
37283: PPUSH
37284: LD_VAR 0 1
37288: PPUSH
37289: EMPTY
37290: PPUSH
37291: CALL_OW 1
37295: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37296: LD_ADDR_EXP 109
37300: PUSH
37301: LD_EXP 109
37305: PPUSH
37306: LD_VAR 0 1
37310: PPUSH
37311: EMPTY
37312: PPUSH
37313: CALL_OW 1
37317: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37318: LD_ADDR_EXP 110
37322: PUSH
37323: LD_EXP 110
37327: PPUSH
37328: LD_VAR 0 1
37332: PPUSH
37333: EMPTY
37334: PPUSH
37335: CALL_OW 1
37339: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37340: LD_ADDR_EXP 111
37344: PUSH
37345: LD_EXP 111
37349: PPUSH
37350: LD_VAR 0 1
37354: PPUSH
37355: LD_INT 0
37357: PPUSH
37358: CALL_OW 1
37362: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37363: LD_ADDR_EXP 112
37367: PUSH
37368: LD_EXP 112
37372: PPUSH
37373: LD_VAR 0 1
37377: PPUSH
37378: EMPTY
37379: PPUSH
37380: CALL_OW 1
37384: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37385: LD_ADDR_EXP 113
37389: PUSH
37390: LD_EXP 113
37394: PPUSH
37395: LD_VAR 0 1
37399: PPUSH
37400: EMPTY
37401: PPUSH
37402: CALL_OW 1
37406: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37407: LD_ADDR_EXP 114
37411: PUSH
37412: LD_EXP 114
37416: PPUSH
37417: LD_VAR 0 1
37421: PPUSH
37422: EMPTY
37423: PPUSH
37424: CALL_OW 1
37428: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37429: LD_ADDR_EXP 115
37433: PUSH
37434: LD_EXP 115
37438: PPUSH
37439: LD_VAR 0 1
37443: PPUSH
37444: EMPTY
37445: PPUSH
37446: CALL_OW 1
37450: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37451: LD_ADDR_EXP 116
37455: PUSH
37456: LD_EXP 116
37460: PPUSH
37461: LD_VAR 0 1
37465: PPUSH
37466: EMPTY
37467: PPUSH
37468: CALL_OW 1
37472: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37473: LD_ADDR_EXP 117
37477: PUSH
37478: LD_EXP 117
37482: PPUSH
37483: LD_VAR 0 1
37487: PPUSH
37488: EMPTY
37489: PPUSH
37490: CALL_OW 1
37494: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37495: LD_ADDR_EXP 118
37499: PUSH
37500: LD_EXP 118
37504: PPUSH
37505: LD_VAR 0 1
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL_OW 1
37516: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37517: LD_ADDR_EXP 119
37521: PUSH
37522: LD_EXP 119
37526: PPUSH
37527: LD_VAR 0 1
37531: PPUSH
37532: EMPTY
37533: PPUSH
37534: CALL_OW 1
37538: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37539: LD_ADDR_EXP 120
37543: PUSH
37544: LD_EXP 120
37548: PPUSH
37549: LD_VAR 0 1
37553: PPUSH
37554: EMPTY
37555: PPUSH
37556: CALL_OW 1
37560: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37561: LD_ADDR_EXP 121
37565: PUSH
37566: LD_EXP 121
37570: PPUSH
37571: LD_VAR 0 1
37575: PPUSH
37576: EMPTY
37577: PPUSH
37578: CALL_OW 1
37582: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37583: LD_ADDR_EXP 122
37587: PUSH
37588: LD_EXP 122
37592: PPUSH
37593: LD_VAR 0 1
37597: PPUSH
37598: EMPTY
37599: PPUSH
37600: CALL_OW 1
37604: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37605: LD_ADDR_EXP 123
37609: PUSH
37610: LD_EXP 123
37614: PPUSH
37615: LD_VAR 0 1
37619: PPUSH
37620: EMPTY
37621: PPUSH
37622: CALL_OW 1
37626: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37627: LD_ADDR_EXP 124
37631: PUSH
37632: LD_EXP 124
37636: PPUSH
37637: LD_VAR 0 1
37641: PPUSH
37642: EMPTY
37643: PPUSH
37644: CALL_OW 1
37648: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37649: LD_ADDR_EXP 125
37653: PUSH
37654: LD_EXP 125
37658: PPUSH
37659: LD_VAR 0 1
37663: PPUSH
37664: EMPTY
37665: PPUSH
37666: CALL_OW 1
37670: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37671: LD_ADDR_EXP 127
37675: PUSH
37676: LD_EXP 127
37680: PPUSH
37681: LD_VAR 0 1
37685: PPUSH
37686: EMPTY
37687: PPUSH
37688: CALL_OW 1
37692: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37693: LD_ADDR_EXP 129
37697: PUSH
37698: LD_EXP 129
37702: PPUSH
37703: LD_VAR 0 1
37707: PPUSH
37708: EMPTY
37709: PPUSH
37710: CALL_OW 1
37714: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37715: LD_ADDR_EXP 130
37719: PUSH
37720: LD_EXP 130
37724: PPUSH
37725: LD_VAR 0 1
37729: PPUSH
37730: EMPTY
37731: PPUSH
37732: CALL_OW 1
37736: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37737: LD_ADDR_EXP 131
37741: PUSH
37742: LD_EXP 131
37746: PPUSH
37747: LD_VAR 0 1
37751: PPUSH
37752: EMPTY
37753: PPUSH
37754: CALL_OW 1
37758: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37759: LD_ADDR_EXP 132
37763: PUSH
37764: LD_EXP 132
37768: PPUSH
37769: LD_VAR 0 1
37773: PPUSH
37774: EMPTY
37775: PPUSH
37776: CALL_OW 1
37780: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37781: LD_ADDR_EXP 133
37785: PUSH
37786: LD_EXP 133
37790: PPUSH
37791: LD_VAR 0 1
37795: PPUSH
37796: EMPTY
37797: PPUSH
37798: CALL_OW 1
37802: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37803: LD_ADDR_EXP 134
37807: PUSH
37808: LD_EXP 134
37812: PPUSH
37813: LD_VAR 0 1
37817: PPUSH
37818: EMPTY
37819: PPUSH
37820: CALL_OW 1
37824: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37825: LD_ADDR_EXP 135
37829: PUSH
37830: LD_EXP 135
37834: PPUSH
37835: LD_VAR 0 1
37839: PPUSH
37840: EMPTY
37841: PPUSH
37842: CALL_OW 1
37846: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37847: LD_ADDR_EXP 136
37851: PUSH
37852: LD_EXP 136
37856: PPUSH
37857: LD_VAR 0 1
37861: PPUSH
37862: EMPTY
37863: PPUSH
37864: CALL_OW 1
37868: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37869: LD_ADDR_EXP 137
37873: PUSH
37874: LD_EXP 137
37878: PPUSH
37879: LD_VAR 0 1
37883: PPUSH
37884: EMPTY
37885: PPUSH
37886: CALL_OW 1
37890: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37891: LD_ADDR_EXP 138
37895: PUSH
37896: LD_EXP 138
37900: PPUSH
37901: LD_VAR 0 1
37905: PPUSH
37906: EMPTY
37907: PPUSH
37908: CALL_OW 1
37912: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37913: LD_ADDR_EXP 139
37917: PUSH
37918: LD_EXP 139
37922: PPUSH
37923: LD_VAR 0 1
37927: PPUSH
37928: EMPTY
37929: PPUSH
37930: CALL_OW 1
37934: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37935: LD_ADDR_EXP 140
37939: PUSH
37940: LD_EXP 140
37944: PPUSH
37945: LD_VAR 0 1
37949: PPUSH
37950: EMPTY
37951: PPUSH
37952: CALL_OW 1
37956: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37957: LD_ADDR_EXP 141
37961: PUSH
37962: LD_EXP 141
37966: PPUSH
37967: LD_VAR 0 1
37971: PPUSH
37972: EMPTY
37973: PPUSH
37974: CALL_OW 1
37978: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37979: LD_ADDR_EXP 142
37983: PUSH
37984: LD_EXP 142
37988: PPUSH
37989: LD_VAR 0 1
37993: PPUSH
37994: LD_INT 0
37996: PPUSH
37997: CALL_OW 1
38001: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38002: LD_ADDR_EXP 143
38006: PUSH
38007: LD_EXP 143
38011: PPUSH
38012: LD_VAR 0 1
38016: PPUSH
38017: LD_INT 0
38019: PPUSH
38020: CALL_OW 1
38024: ST_TO_ADDR
// end ;
38025: LD_VAR 0 2
38029: RET
// export function MC_Add ( side , units ) ; var base ; begin
38030: LD_INT 0
38032: PPUSH
38033: PPUSH
// base := mc_bases + 1 ;
38034: LD_ADDR_VAR 0 4
38038: PUSH
38039: LD_EXP 100
38043: PUSH
38044: LD_INT 1
38046: PLUS
38047: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
38048: LD_ADDR_EXP 126
38052: PUSH
38053: LD_EXP 126
38057: PPUSH
38058: LD_VAR 0 4
38062: PPUSH
38063: LD_VAR 0 1
38067: PPUSH
38068: CALL_OW 1
38072: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
38073: LD_ADDR_EXP 100
38077: PUSH
38078: LD_EXP 100
38082: PPUSH
38083: LD_VAR 0 4
38087: PPUSH
38088: LD_VAR 0 2
38092: PPUSH
38093: CALL_OW 1
38097: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38098: LD_ADDR_EXP 101
38102: PUSH
38103: LD_EXP 101
38107: PPUSH
38108: LD_VAR 0 4
38112: PPUSH
38113: EMPTY
38114: PPUSH
38115: CALL_OW 1
38119: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38120: LD_ADDR_EXP 102
38124: PUSH
38125: LD_EXP 102
38129: PPUSH
38130: LD_VAR 0 4
38134: PPUSH
38135: EMPTY
38136: PPUSH
38137: CALL_OW 1
38141: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38142: LD_ADDR_EXP 103
38146: PUSH
38147: LD_EXP 103
38151: PPUSH
38152: LD_VAR 0 4
38156: PPUSH
38157: EMPTY
38158: PPUSH
38159: CALL_OW 1
38163: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38164: LD_ADDR_EXP 104
38168: PUSH
38169: LD_EXP 104
38173: PPUSH
38174: LD_VAR 0 4
38178: PPUSH
38179: EMPTY
38180: PPUSH
38181: CALL_OW 1
38185: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38186: LD_ADDR_EXP 105
38190: PUSH
38191: LD_EXP 105
38195: PPUSH
38196: LD_VAR 0 4
38200: PPUSH
38201: EMPTY
38202: PPUSH
38203: CALL_OW 1
38207: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38208: LD_ADDR_EXP 106
38212: PUSH
38213: LD_EXP 106
38217: PPUSH
38218: LD_VAR 0 4
38222: PPUSH
38223: EMPTY
38224: PPUSH
38225: CALL_OW 1
38229: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38230: LD_ADDR_EXP 107
38234: PUSH
38235: LD_EXP 107
38239: PPUSH
38240: LD_VAR 0 4
38244: PPUSH
38245: EMPTY
38246: PPUSH
38247: CALL_OW 1
38251: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38252: LD_ADDR_EXP 108
38256: PUSH
38257: LD_EXP 108
38261: PPUSH
38262: LD_VAR 0 4
38266: PPUSH
38267: EMPTY
38268: PPUSH
38269: CALL_OW 1
38273: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38274: LD_ADDR_EXP 109
38278: PUSH
38279: LD_EXP 109
38283: PPUSH
38284: LD_VAR 0 4
38288: PPUSH
38289: EMPTY
38290: PPUSH
38291: CALL_OW 1
38295: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38296: LD_ADDR_EXP 110
38300: PUSH
38301: LD_EXP 110
38305: PPUSH
38306: LD_VAR 0 4
38310: PPUSH
38311: EMPTY
38312: PPUSH
38313: CALL_OW 1
38317: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38318: LD_ADDR_EXP 111
38322: PUSH
38323: LD_EXP 111
38327: PPUSH
38328: LD_VAR 0 4
38332: PPUSH
38333: LD_INT 0
38335: PPUSH
38336: CALL_OW 1
38340: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38341: LD_ADDR_EXP 112
38345: PUSH
38346: LD_EXP 112
38350: PPUSH
38351: LD_VAR 0 4
38355: PPUSH
38356: EMPTY
38357: PPUSH
38358: CALL_OW 1
38362: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38363: LD_ADDR_EXP 113
38367: PUSH
38368: LD_EXP 113
38372: PPUSH
38373: LD_VAR 0 4
38377: PPUSH
38378: EMPTY
38379: PPUSH
38380: CALL_OW 1
38384: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38385: LD_ADDR_EXP 114
38389: PUSH
38390: LD_EXP 114
38394: PPUSH
38395: LD_VAR 0 4
38399: PPUSH
38400: EMPTY
38401: PPUSH
38402: CALL_OW 1
38406: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38407: LD_ADDR_EXP 115
38411: PUSH
38412: LD_EXP 115
38416: PPUSH
38417: LD_VAR 0 4
38421: PPUSH
38422: EMPTY
38423: PPUSH
38424: CALL_OW 1
38428: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38429: LD_ADDR_EXP 116
38433: PUSH
38434: LD_EXP 116
38438: PPUSH
38439: LD_VAR 0 4
38443: PPUSH
38444: EMPTY
38445: PPUSH
38446: CALL_OW 1
38450: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38451: LD_ADDR_EXP 117
38455: PUSH
38456: LD_EXP 117
38460: PPUSH
38461: LD_VAR 0 4
38465: PPUSH
38466: EMPTY
38467: PPUSH
38468: CALL_OW 1
38472: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38473: LD_ADDR_EXP 118
38477: PUSH
38478: LD_EXP 118
38482: PPUSH
38483: LD_VAR 0 4
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL_OW 1
38494: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38495: LD_ADDR_EXP 119
38499: PUSH
38500: LD_EXP 119
38504: PPUSH
38505: LD_VAR 0 4
38509: PPUSH
38510: EMPTY
38511: PPUSH
38512: CALL_OW 1
38516: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38517: LD_ADDR_EXP 120
38521: PUSH
38522: LD_EXP 120
38526: PPUSH
38527: LD_VAR 0 4
38531: PPUSH
38532: EMPTY
38533: PPUSH
38534: CALL_OW 1
38538: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38539: LD_ADDR_EXP 121
38543: PUSH
38544: LD_EXP 121
38548: PPUSH
38549: LD_VAR 0 4
38553: PPUSH
38554: EMPTY
38555: PPUSH
38556: CALL_OW 1
38560: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38561: LD_ADDR_EXP 122
38565: PUSH
38566: LD_EXP 122
38570: PPUSH
38571: LD_VAR 0 4
38575: PPUSH
38576: EMPTY
38577: PPUSH
38578: CALL_OW 1
38582: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38583: LD_ADDR_EXP 123
38587: PUSH
38588: LD_EXP 123
38592: PPUSH
38593: LD_VAR 0 4
38597: PPUSH
38598: EMPTY
38599: PPUSH
38600: CALL_OW 1
38604: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38605: LD_ADDR_EXP 124
38609: PUSH
38610: LD_EXP 124
38614: PPUSH
38615: LD_VAR 0 4
38619: PPUSH
38620: EMPTY
38621: PPUSH
38622: CALL_OW 1
38626: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38627: LD_ADDR_EXP 125
38631: PUSH
38632: LD_EXP 125
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: EMPTY
38643: PPUSH
38644: CALL_OW 1
38648: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38649: LD_ADDR_EXP 127
38653: PUSH
38654: LD_EXP 127
38658: PPUSH
38659: LD_VAR 0 4
38663: PPUSH
38664: EMPTY
38665: PPUSH
38666: CALL_OW 1
38670: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38671: LD_ADDR_EXP 129
38675: PUSH
38676: LD_EXP 129
38680: PPUSH
38681: LD_VAR 0 4
38685: PPUSH
38686: EMPTY
38687: PPUSH
38688: CALL_OW 1
38692: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38693: LD_ADDR_EXP 130
38697: PUSH
38698: LD_EXP 130
38702: PPUSH
38703: LD_VAR 0 4
38707: PPUSH
38708: EMPTY
38709: PPUSH
38710: CALL_OW 1
38714: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38715: LD_ADDR_EXP 131
38719: PUSH
38720: LD_EXP 131
38724: PPUSH
38725: LD_VAR 0 4
38729: PPUSH
38730: EMPTY
38731: PPUSH
38732: CALL_OW 1
38736: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38737: LD_ADDR_EXP 132
38741: PUSH
38742: LD_EXP 132
38746: PPUSH
38747: LD_VAR 0 4
38751: PPUSH
38752: EMPTY
38753: PPUSH
38754: CALL_OW 1
38758: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38759: LD_ADDR_EXP 133
38763: PUSH
38764: LD_EXP 133
38768: PPUSH
38769: LD_VAR 0 4
38773: PPUSH
38774: EMPTY
38775: PPUSH
38776: CALL_OW 1
38780: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38781: LD_ADDR_EXP 134
38785: PUSH
38786: LD_EXP 134
38790: PPUSH
38791: LD_VAR 0 4
38795: PPUSH
38796: EMPTY
38797: PPUSH
38798: CALL_OW 1
38802: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38803: LD_ADDR_EXP 135
38807: PUSH
38808: LD_EXP 135
38812: PPUSH
38813: LD_VAR 0 4
38817: PPUSH
38818: EMPTY
38819: PPUSH
38820: CALL_OW 1
38824: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38825: LD_ADDR_EXP 136
38829: PUSH
38830: LD_EXP 136
38834: PPUSH
38835: LD_VAR 0 4
38839: PPUSH
38840: EMPTY
38841: PPUSH
38842: CALL_OW 1
38846: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38847: LD_ADDR_EXP 137
38851: PUSH
38852: LD_EXP 137
38856: PPUSH
38857: LD_VAR 0 4
38861: PPUSH
38862: EMPTY
38863: PPUSH
38864: CALL_OW 1
38868: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38869: LD_ADDR_EXP 138
38873: PUSH
38874: LD_EXP 138
38878: PPUSH
38879: LD_VAR 0 4
38883: PPUSH
38884: EMPTY
38885: PPUSH
38886: CALL_OW 1
38890: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38891: LD_ADDR_EXP 139
38895: PUSH
38896: LD_EXP 139
38900: PPUSH
38901: LD_VAR 0 4
38905: PPUSH
38906: EMPTY
38907: PPUSH
38908: CALL_OW 1
38912: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38913: LD_ADDR_EXP 140
38917: PUSH
38918: LD_EXP 140
38922: PPUSH
38923: LD_VAR 0 4
38927: PPUSH
38928: EMPTY
38929: PPUSH
38930: CALL_OW 1
38934: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38935: LD_ADDR_EXP 141
38939: PUSH
38940: LD_EXP 141
38944: PPUSH
38945: LD_VAR 0 4
38949: PPUSH
38950: EMPTY
38951: PPUSH
38952: CALL_OW 1
38956: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38957: LD_ADDR_EXP 142
38961: PUSH
38962: LD_EXP 142
38966: PPUSH
38967: LD_VAR 0 4
38971: PPUSH
38972: LD_INT 0
38974: PPUSH
38975: CALL_OW 1
38979: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38980: LD_ADDR_EXP 143
38984: PUSH
38985: LD_EXP 143
38989: PPUSH
38990: LD_VAR 0 4
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: CALL_OW 1
39002: ST_TO_ADDR
// result := base ;
39003: LD_ADDR_VAR 0 3
39007: PUSH
39008: LD_VAR 0 4
39012: ST_TO_ADDR
// end ;
39013: LD_VAR 0 3
39017: RET
// export function MC_Start ( ) ; var i ; begin
39018: LD_INT 0
39020: PPUSH
39021: PPUSH
// for i = 1 to mc_bases do
39022: LD_ADDR_VAR 0 2
39026: PUSH
39027: DOUBLE
39028: LD_INT 1
39030: DEC
39031: ST_TO_ADDR
39032: LD_EXP 100
39036: PUSH
39037: FOR_TO
39038: IFFALSE 40138
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
39040: LD_ADDR_EXP 100
39044: PUSH
39045: LD_EXP 100
39049: PPUSH
39050: LD_VAR 0 2
39054: PPUSH
39055: LD_EXP 100
39059: PUSH
39060: LD_VAR 0 2
39064: ARRAY
39065: PUSH
39066: LD_INT 0
39068: DIFF
39069: PPUSH
39070: CALL_OW 1
39074: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
39075: LD_ADDR_EXP 101
39079: PUSH
39080: LD_EXP 101
39084: PPUSH
39085: LD_VAR 0 2
39089: PPUSH
39090: EMPTY
39091: PPUSH
39092: CALL_OW 1
39096: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39097: LD_ADDR_EXP 102
39101: PUSH
39102: LD_EXP 102
39106: PPUSH
39107: LD_VAR 0 2
39111: PPUSH
39112: EMPTY
39113: PPUSH
39114: CALL_OW 1
39118: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
39119: LD_ADDR_EXP 103
39123: PUSH
39124: LD_EXP 103
39128: PPUSH
39129: LD_VAR 0 2
39133: PPUSH
39134: EMPTY
39135: PPUSH
39136: CALL_OW 1
39140: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
39141: LD_ADDR_EXP 104
39145: PUSH
39146: LD_EXP 104
39150: PPUSH
39151: LD_VAR 0 2
39155: PPUSH
39156: EMPTY
39157: PUSH
39158: EMPTY
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PPUSH
39164: CALL_OW 1
39168: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
39169: LD_ADDR_EXP 105
39173: PUSH
39174: LD_EXP 105
39178: PPUSH
39179: LD_VAR 0 2
39183: PPUSH
39184: EMPTY
39185: PPUSH
39186: CALL_OW 1
39190: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39191: LD_ADDR_EXP 132
39195: PUSH
39196: LD_EXP 132
39200: PPUSH
39201: LD_VAR 0 2
39205: PPUSH
39206: EMPTY
39207: PPUSH
39208: CALL_OW 1
39212: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39213: LD_ADDR_EXP 106
39217: PUSH
39218: LD_EXP 106
39222: PPUSH
39223: LD_VAR 0 2
39227: PPUSH
39228: EMPTY
39229: PPUSH
39230: CALL_OW 1
39234: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39235: LD_ADDR_EXP 107
39239: PUSH
39240: LD_EXP 107
39244: PPUSH
39245: LD_VAR 0 2
39249: PPUSH
39250: EMPTY
39251: PPUSH
39252: CALL_OW 1
39256: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39257: LD_ADDR_EXP 108
39261: PUSH
39262: LD_EXP 108
39266: PPUSH
39267: LD_VAR 0 2
39271: PPUSH
39272: LD_EXP 100
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: PPUSH
39283: LD_INT 2
39285: PUSH
39286: LD_INT 30
39288: PUSH
39289: LD_INT 32
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 30
39298: PUSH
39299: LD_INT 33
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: LIST
39310: PPUSH
39311: CALL_OW 72
39315: PPUSH
39316: CALL_OW 1
39320: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39321: LD_ADDR_EXP 109
39325: PUSH
39326: LD_EXP 109
39330: PPUSH
39331: LD_VAR 0 2
39335: PPUSH
39336: LD_EXP 100
39340: PUSH
39341: LD_VAR 0 2
39345: ARRAY
39346: PPUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 30
39352: PUSH
39353: LD_INT 32
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 30
39362: PUSH
39363: LD_INT 31
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 58
39377: PUSH
39378: EMPTY
39379: LIST
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PPUSH
39385: CALL_OW 72
39389: PPUSH
39390: CALL_OW 1
39394: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39395: LD_ADDR_EXP 110
39399: PUSH
39400: LD_EXP 110
39404: PPUSH
39405: LD_VAR 0 2
39409: PPUSH
39410: EMPTY
39411: PPUSH
39412: CALL_OW 1
39416: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39417: LD_ADDR_EXP 114
39421: PUSH
39422: LD_EXP 114
39426: PPUSH
39427: LD_VAR 0 2
39431: PPUSH
39432: EMPTY
39433: PPUSH
39434: CALL_OW 1
39438: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39439: LD_ADDR_EXP 113
39443: PUSH
39444: LD_EXP 113
39448: PPUSH
39449: LD_VAR 0 2
39453: PPUSH
39454: EMPTY
39455: PPUSH
39456: CALL_OW 1
39460: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39461: LD_ADDR_EXP 115
39465: PUSH
39466: LD_EXP 115
39470: PPUSH
39471: LD_VAR 0 2
39475: PPUSH
39476: EMPTY
39477: PPUSH
39478: CALL_OW 1
39482: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39483: LD_ADDR_EXP 116
39487: PUSH
39488: LD_EXP 116
39492: PPUSH
39493: LD_VAR 0 2
39497: PPUSH
39498: EMPTY
39499: PPUSH
39500: CALL_OW 1
39504: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39505: LD_ADDR_EXP 117
39509: PUSH
39510: LD_EXP 117
39514: PPUSH
39515: LD_VAR 0 2
39519: PPUSH
39520: EMPTY
39521: PPUSH
39522: CALL_OW 1
39526: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39527: LD_ADDR_EXP 118
39531: PUSH
39532: LD_EXP 118
39536: PPUSH
39537: LD_VAR 0 2
39541: PPUSH
39542: EMPTY
39543: PPUSH
39544: CALL_OW 1
39548: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39549: LD_ADDR_EXP 119
39553: PUSH
39554: LD_EXP 119
39558: PPUSH
39559: LD_VAR 0 2
39563: PPUSH
39564: EMPTY
39565: PPUSH
39566: CALL_OW 1
39570: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39571: LD_ADDR_EXP 120
39575: PUSH
39576: LD_EXP 120
39580: PPUSH
39581: LD_VAR 0 2
39585: PPUSH
39586: EMPTY
39587: PPUSH
39588: CALL_OW 1
39592: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39593: LD_ADDR_EXP 121
39597: PUSH
39598: LD_EXP 121
39602: PPUSH
39603: LD_VAR 0 2
39607: PPUSH
39608: EMPTY
39609: PPUSH
39610: CALL_OW 1
39614: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39615: LD_ADDR_EXP 122
39619: PUSH
39620: LD_EXP 122
39624: PPUSH
39625: LD_VAR 0 2
39629: PPUSH
39630: EMPTY
39631: PPUSH
39632: CALL_OW 1
39636: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39637: LD_ADDR_EXP 111
39641: PUSH
39642: LD_EXP 111
39646: PPUSH
39647: LD_VAR 0 2
39651: PPUSH
39652: LD_INT 0
39654: PPUSH
39655: CALL_OW 1
39659: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39660: LD_ADDR_EXP 124
39664: PUSH
39665: LD_EXP 124
39669: PPUSH
39670: LD_VAR 0 2
39674: PPUSH
39675: LD_INT 0
39677: PPUSH
39678: CALL_OW 1
39682: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39683: LD_ADDR_EXP 112
39687: PUSH
39688: LD_EXP 112
39692: PPUSH
39693: LD_VAR 0 2
39697: PPUSH
39698: EMPTY
39699: PPUSH
39700: CALL_OW 1
39704: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39705: LD_ADDR_EXP 123
39709: PUSH
39710: LD_EXP 123
39714: PPUSH
39715: LD_VAR 0 2
39719: PPUSH
39720: LD_INT 0
39722: PPUSH
39723: CALL_OW 1
39727: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39728: LD_ADDR_EXP 125
39732: PUSH
39733: LD_EXP 125
39737: PPUSH
39738: LD_VAR 0 2
39742: PPUSH
39743: EMPTY
39744: PPUSH
39745: CALL_OW 1
39749: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39750: LD_ADDR_EXP 128
39754: PUSH
39755: LD_EXP 128
39759: PPUSH
39760: LD_VAR 0 2
39764: PPUSH
39765: LD_INT 0
39767: PPUSH
39768: CALL_OW 1
39772: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39773: LD_ADDR_EXP 129
39777: PUSH
39778: LD_EXP 129
39782: PPUSH
39783: LD_VAR 0 2
39787: PPUSH
39788: EMPTY
39789: PPUSH
39790: CALL_OW 1
39794: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39795: LD_ADDR_EXP 130
39799: PUSH
39800: LD_EXP 130
39804: PPUSH
39805: LD_VAR 0 2
39809: PPUSH
39810: EMPTY
39811: PPUSH
39812: CALL_OW 1
39816: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39817: LD_ADDR_EXP 131
39821: PUSH
39822: LD_EXP 131
39826: PPUSH
39827: LD_VAR 0 2
39831: PPUSH
39832: EMPTY
39833: PPUSH
39834: CALL_OW 1
39838: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39839: LD_ADDR_EXP 133
39843: PUSH
39844: LD_EXP 133
39848: PPUSH
39849: LD_VAR 0 2
39853: PPUSH
39854: LD_EXP 100
39858: PUSH
39859: LD_VAR 0 2
39863: ARRAY
39864: PPUSH
39865: LD_INT 2
39867: PUSH
39868: LD_INT 30
39870: PUSH
39871: LD_INT 6
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 30
39880: PUSH
39881: LD_INT 7
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 30
39890: PUSH
39891: LD_INT 8
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: PPUSH
39904: CALL_OW 72
39908: PPUSH
39909: CALL_OW 1
39913: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39914: LD_ADDR_EXP 134
39918: PUSH
39919: LD_EXP 134
39923: PPUSH
39924: LD_VAR 0 2
39928: PPUSH
39929: EMPTY
39930: PPUSH
39931: CALL_OW 1
39935: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39936: LD_ADDR_EXP 135
39940: PUSH
39941: LD_EXP 135
39945: PPUSH
39946: LD_VAR 0 2
39950: PPUSH
39951: EMPTY
39952: PPUSH
39953: CALL_OW 1
39957: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39958: LD_ADDR_EXP 136
39962: PUSH
39963: LD_EXP 136
39967: PPUSH
39968: LD_VAR 0 2
39972: PPUSH
39973: EMPTY
39974: PPUSH
39975: CALL_OW 1
39979: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39980: LD_ADDR_EXP 137
39984: PUSH
39985: LD_EXP 137
39989: PPUSH
39990: LD_VAR 0 2
39994: PPUSH
39995: EMPTY
39996: PPUSH
39997: CALL_OW 1
40001: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40002: LD_ADDR_EXP 138
40006: PUSH
40007: LD_EXP 138
40011: PPUSH
40012: LD_VAR 0 2
40016: PPUSH
40017: EMPTY
40018: PPUSH
40019: CALL_OW 1
40023: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
40024: LD_ADDR_EXP 139
40028: PUSH
40029: LD_EXP 139
40033: PPUSH
40034: LD_VAR 0 2
40038: PPUSH
40039: EMPTY
40040: PPUSH
40041: CALL_OW 1
40045: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
40046: LD_ADDR_EXP 140
40050: PUSH
40051: LD_EXP 140
40055: PPUSH
40056: LD_VAR 0 2
40060: PPUSH
40061: EMPTY
40062: PPUSH
40063: CALL_OW 1
40067: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
40068: LD_ADDR_EXP 141
40072: PUSH
40073: LD_EXP 141
40077: PPUSH
40078: LD_VAR 0 2
40082: PPUSH
40083: EMPTY
40084: PPUSH
40085: CALL_OW 1
40089: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
40090: LD_ADDR_EXP 142
40094: PUSH
40095: LD_EXP 142
40099: PPUSH
40100: LD_VAR 0 2
40104: PPUSH
40105: LD_INT 0
40107: PPUSH
40108: CALL_OW 1
40112: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
40113: LD_ADDR_EXP 143
40117: PUSH
40118: LD_EXP 143
40122: PPUSH
40123: LD_VAR 0 2
40127: PPUSH
40128: LD_INT 0
40130: PPUSH
40131: CALL_OW 1
40135: ST_TO_ADDR
// end ;
40136: GO 39037
40138: POP
40139: POP
// MC_InitSides ( ) ;
40140: CALL 40426 0 0
// MC_InitResearch ( ) ;
40144: CALL 40165 0 0
// CustomInitMacro ( ) ;
40148: CALL 475 0 0
// skirmish := true ;
40152: LD_ADDR_EXP 98
40156: PUSH
40157: LD_INT 1
40159: ST_TO_ADDR
// end ;
40160: LD_VAR 0 1
40164: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
40165: LD_INT 0
40167: PPUSH
40168: PPUSH
40169: PPUSH
40170: PPUSH
40171: PPUSH
40172: PPUSH
// if not mc_bases then
40173: LD_EXP 100
40177: NOT
40178: IFFALSE 40182
// exit ;
40180: GO 40421
// for i = 1 to 8 do
40182: LD_ADDR_VAR 0 2
40186: PUSH
40187: DOUBLE
40188: LD_INT 1
40190: DEC
40191: ST_TO_ADDR
40192: LD_INT 8
40194: PUSH
40195: FOR_TO
40196: IFFALSE 40222
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40198: LD_ADDR_EXP 127
40202: PUSH
40203: LD_EXP 127
40207: PPUSH
40208: LD_VAR 0 2
40212: PPUSH
40213: EMPTY
40214: PPUSH
40215: CALL_OW 1
40219: ST_TO_ADDR
40220: GO 40195
40222: POP
40223: POP
// tmp := [ ] ;
40224: LD_ADDR_VAR 0 5
40228: PUSH
40229: EMPTY
40230: ST_TO_ADDR
// for i = 1 to mc_sides do
40231: LD_ADDR_VAR 0 2
40235: PUSH
40236: DOUBLE
40237: LD_INT 1
40239: DEC
40240: ST_TO_ADDR
40241: LD_EXP 126
40245: PUSH
40246: FOR_TO
40247: IFFALSE 40305
// if not mc_sides [ i ] in tmp then
40249: LD_EXP 126
40253: PUSH
40254: LD_VAR 0 2
40258: ARRAY
40259: PUSH
40260: LD_VAR 0 5
40264: IN
40265: NOT
40266: IFFALSE 40303
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40268: LD_ADDR_VAR 0 5
40272: PUSH
40273: LD_VAR 0 5
40277: PPUSH
40278: LD_VAR 0 5
40282: PUSH
40283: LD_INT 1
40285: PLUS
40286: PPUSH
40287: LD_EXP 126
40291: PUSH
40292: LD_VAR 0 2
40296: ARRAY
40297: PPUSH
40298: CALL_OW 2
40302: ST_TO_ADDR
40303: GO 40246
40305: POP
40306: POP
// if not tmp then
40307: LD_VAR 0 5
40311: NOT
40312: IFFALSE 40316
// exit ;
40314: GO 40421
// for j in tmp do
40316: LD_ADDR_VAR 0 3
40320: PUSH
40321: LD_VAR 0 5
40325: PUSH
40326: FOR_IN
40327: IFFALSE 40419
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40329: LD_ADDR_VAR 0 6
40333: PUSH
40334: LD_INT 22
40336: PUSH
40337: LD_VAR 0 3
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PPUSH
40346: CALL_OW 69
40350: ST_TO_ADDR
// if not un then
40351: LD_VAR 0 6
40355: NOT
40356: IFFALSE 40360
// continue ;
40358: GO 40326
// nation := GetNation ( un [ 1 ] ) ;
40360: LD_ADDR_VAR 0 4
40364: PUSH
40365: LD_VAR 0 6
40369: PUSH
40370: LD_INT 1
40372: ARRAY
40373: PPUSH
40374: CALL_OW 248
40378: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40379: LD_ADDR_EXP 127
40383: PUSH
40384: LD_EXP 127
40388: PPUSH
40389: LD_VAR 0 3
40393: PPUSH
40394: LD_VAR 0 3
40398: PPUSH
40399: LD_VAR 0 4
40403: PPUSH
40404: LD_INT 1
40406: PPUSH
40407: CALL 67573 0 3
40411: PPUSH
40412: CALL_OW 1
40416: ST_TO_ADDR
// end ;
40417: GO 40326
40419: POP
40420: POP
// end ;
40421: LD_VAR 0 1
40425: RET
// export function MC_InitSides ( ) ; var i ; begin
40426: LD_INT 0
40428: PPUSH
40429: PPUSH
// if not mc_bases then
40430: LD_EXP 100
40434: NOT
40435: IFFALSE 40439
// exit ;
40437: GO 40513
// for i = 1 to mc_bases do
40439: LD_ADDR_VAR 0 2
40443: PUSH
40444: DOUBLE
40445: LD_INT 1
40447: DEC
40448: ST_TO_ADDR
40449: LD_EXP 100
40453: PUSH
40454: FOR_TO
40455: IFFALSE 40511
// if mc_bases [ i ] then
40457: LD_EXP 100
40461: PUSH
40462: LD_VAR 0 2
40466: ARRAY
40467: IFFALSE 40509
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40469: LD_ADDR_EXP 126
40473: PUSH
40474: LD_EXP 126
40478: PPUSH
40479: LD_VAR 0 2
40483: PPUSH
40484: LD_EXP 100
40488: PUSH
40489: LD_VAR 0 2
40493: ARRAY
40494: PUSH
40495: LD_INT 1
40497: ARRAY
40498: PPUSH
40499: CALL_OW 255
40503: PPUSH
40504: CALL_OW 1
40508: ST_TO_ADDR
40509: GO 40454
40511: POP
40512: POP
// end ;
40513: LD_VAR 0 1
40517: RET
// every 0 0$03 trigger skirmish do
40518: LD_EXP 98
40522: IFFALSE 40676
40524: GO 40526
40526: DISABLE
// begin enable ;
40527: ENABLE
// MC_CheckBuildings ( ) ;
40528: CALL 45174 0 0
// MC_CheckPeopleLife ( ) ;
40532: CALL 45335 0 0
// RaiseSailEvent ( 100 ) ;
40536: LD_INT 100
40538: PPUSH
40539: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40543: LD_INT 103
40545: PPUSH
40546: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40550: LD_INT 104
40552: PPUSH
40553: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40557: LD_INT 105
40559: PPUSH
40560: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40564: LD_INT 106
40566: PPUSH
40567: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40571: LD_INT 107
40573: PPUSH
40574: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40578: LD_INT 108
40580: PPUSH
40581: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40585: LD_INT 109
40587: PPUSH
40588: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40592: LD_INT 110
40594: PPUSH
40595: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40599: LD_INT 111
40601: PPUSH
40602: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40606: LD_INT 112
40608: PPUSH
40609: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40613: LD_INT 113
40615: PPUSH
40616: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40620: LD_INT 120
40622: PPUSH
40623: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40627: LD_INT 121
40629: PPUSH
40630: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40634: LD_INT 122
40636: PPUSH
40637: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40641: LD_INT 123
40643: PPUSH
40644: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40648: LD_INT 124
40650: PPUSH
40651: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40655: LD_INT 125
40657: PPUSH
40658: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40662: LD_INT 126
40664: PPUSH
40665: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40669: LD_INT 200
40671: PPUSH
40672: CALL_OW 427
// end ;
40676: END
// on SailEvent ( event ) do begin if event < 100 then
40677: LD_VAR 0 1
40681: PUSH
40682: LD_INT 100
40684: LESS
40685: IFFALSE 40696
// CustomEvent ( event ) ;
40687: LD_VAR 0 1
40691: PPUSH
40692: CALL 35178 0 1
// if event = 100 then
40696: LD_VAR 0 1
40700: PUSH
40701: LD_INT 100
40703: EQUAL
40704: IFFALSE 40710
// MC_ClassManager ( ) ;
40706: CALL 41102 0 0
// if event = 101 then
40710: LD_VAR 0 1
40714: PUSH
40715: LD_INT 101
40717: EQUAL
40718: IFFALSE 40724
// MC_RepairBuildings ( ) ;
40720: CALL 45920 0 0
// if event = 102 then
40724: LD_VAR 0 1
40728: PUSH
40729: LD_INT 102
40731: EQUAL
40732: IFFALSE 40738
// MC_Heal ( ) ;
40734: CALL 46855 0 0
// if event = 103 then
40738: LD_VAR 0 1
40742: PUSH
40743: LD_INT 103
40745: EQUAL
40746: IFFALSE 40752
// MC_Build ( ) ;
40748: CALL 47277 0 0
// if event = 104 then
40752: LD_VAR 0 1
40756: PUSH
40757: LD_INT 104
40759: EQUAL
40760: IFFALSE 40766
// MC_TurretWeapon ( ) ;
40762: CALL 48911 0 0
// if event = 105 then
40766: LD_VAR 0 1
40770: PUSH
40771: LD_INT 105
40773: EQUAL
40774: IFFALSE 40780
// MC_BuildUpgrade ( ) ;
40776: CALL 48462 0 0
// if event = 106 then
40780: LD_VAR 0 1
40784: PUSH
40785: LD_INT 106
40787: EQUAL
40788: IFFALSE 40794
// MC_PlantMines ( ) ;
40790: CALL 49341 0 0
// if event = 107 then
40794: LD_VAR 0 1
40798: PUSH
40799: LD_INT 107
40801: EQUAL
40802: IFFALSE 40808
// MC_CollectCrates ( ) ;
40804: CALL 50132 0 0
// if event = 108 then
40808: LD_VAR 0 1
40812: PUSH
40813: LD_INT 108
40815: EQUAL
40816: IFFALSE 40822
// MC_LinkRemoteControl ( ) ;
40818: CALL 51982 0 0
// if event = 109 then
40822: LD_VAR 0 1
40826: PUSH
40827: LD_INT 109
40829: EQUAL
40830: IFFALSE 40836
// MC_ProduceVehicle ( ) ;
40832: CALL 52163 0 0
// if event = 110 then
40836: LD_VAR 0 1
40840: PUSH
40841: LD_INT 110
40843: EQUAL
40844: IFFALSE 40850
// MC_SendAttack ( ) ;
40846: CALL 52629 0 0
// if event = 111 then
40850: LD_VAR 0 1
40854: PUSH
40855: LD_INT 111
40857: EQUAL
40858: IFFALSE 40864
// MC_Defend ( ) ;
40860: CALL 52737 0 0
// if event = 112 then
40864: LD_VAR 0 1
40868: PUSH
40869: LD_INT 112
40871: EQUAL
40872: IFFALSE 40878
// MC_Research ( ) ;
40874: CALL 53617 0 0
// if event = 113 then
40878: LD_VAR 0 1
40882: PUSH
40883: LD_INT 113
40885: EQUAL
40886: IFFALSE 40892
// MC_MinesTrigger ( ) ;
40888: CALL 54731 0 0
// if event = 120 then
40892: LD_VAR 0 1
40896: PUSH
40897: LD_INT 120
40899: EQUAL
40900: IFFALSE 40906
// MC_RepairVehicle ( ) ;
40902: CALL 54830 0 0
// if event = 121 then
40906: LD_VAR 0 1
40910: PUSH
40911: LD_INT 121
40913: EQUAL
40914: IFFALSE 40920
// MC_TameApe ( ) ;
40916: CALL 55599 0 0
// if event = 122 then
40920: LD_VAR 0 1
40924: PUSH
40925: LD_INT 122
40927: EQUAL
40928: IFFALSE 40934
// MC_ChangeApeClass ( ) ;
40930: CALL 56428 0 0
// if event = 123 then
40934: LD_VAR 0 1
40938: PUSH
40939: LD_INT 123
40941: EQUAL
40942: IFFALSE 40948
// MC_Bazooka ( ) ;
40944: CALL 57078 0 0
// if event = 124 then
40948: LD_VAR 0 1
40952: PUSH
40953: LD_INT 124
40955: EQUAL
40956: IFFALSE 40962
// MC_TeleportExit ( ) ;
40958: CALL 57276 0 0
// if event = 125 then
40962: LD_VAR 0 1
40966: PUSH
40967: LD_INT 125
40969: EQUAL
40970: IFFALSE 40976
// MC_Deposits ( ) ;
40972: CALL 57923 0 0
// if event = 126 then
40976: LD_VAR 0 1
40980: PUSH
40981: LD_INT 126
40983: EQUAL
40984: IFFALSE 40990
// MC_RemoteDriver ( ) ;
40986: CALL 58548 0 0
// if event = 200 then
40990: LD_VAR 0 1
40994: PUSH
40995: LD_INT 200
40997: EQUAL
40998: IFFALSE 41004
// MC_Idle ( ) ;
41000: CALL 60497 0 0
// end ;
41004: PPOPN 1
41006: END
// export function MC_Reset ( base , tag ) ; var i ; begin
41007: LD_INT 0
41009: PPUSH
41010: PPUSH
// if not mc_bases [ base ] or not tag then
41011: LD_EXP 100
41015: PUSH
41016: LD_VAR 0 1
41020: ARRAY
41021: NOT
41022: PUSH
41023: LD_VAR 0 2
41027: NOT
41028: OR
41029: IFFALSE 41033
// exit ;
41031: GO 41097
// for i in mc_bases [ base ] union mc_ape [ base ] do
41033: LD_ADDR_VAR 0 4
41037: PUSH
41038: LD_EXP 100
41042: PUSH
41043: LD_VAR 0 1
41047: ARRAY
41048: PUSH
41049: LD_EXP 129
41053: PUSH
41054: LD_VAR 0 1
41058: ARRAY
41059: UNION
41060: PUSH
41061: FOR_IN
41062: IFFALSE 41095
// if GetTag ( i ) = tag then
41064: LD_VAR 0 4
41068: PPUSH
41069: CALL_OW 110
41073: PUSH
41074: LD_VAR 0 2
41078: EQUAL
41079: IFFALSE 41093
// SetTag ( i , 0 ) ;
41081: LD_VAR 0 4
41085: PPUSH
41086: LD_INT 0
41088: PPUSH
41089: CALL_OW 109
41093: GO 41061
41095: POP
41096: POP
// end ;
41097: LD_VAR 0 3
41101: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
41102: LD_INT 0
41104: PPUSH
41105: PPUSH
41106: PPUSH
41107: PPUSH
41108: PPUSH
41109: PPUSH
41110: PPUSH
41111: PPUSH
// if not mc_bases then
41112: LD_EXP 100
41116: NOT
41117: IFFALSE 41121
// exit ;
41119: GO 41579
// for i = 1 to mc_bases do
41121: LD_ADDR_VAR 0 2
41125: PUSH
41126: DOUBLE
41127: LD_INT 1
41129: DEC
41130: ST_TO_ADDR
41131: LD_EXP 100
41135: PUSH
41136: FOR_TO
41137: IFFALSE 41577
// begin tmp := MC_ClassCheckReq ( i ) ;
41139: LD_ADDR_VAR 0 4
41143: PUSH
41144: LD_VAR 0 2
41148: PPUSH
41149: CALL 41584 0 1
41153: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
41154: LD_ADDR_EXP 141
41158: PUSH
41159: LD_EXP 141
41163: PPUSH
41164: LD_VAR 0 2
41168: PPUSH
41169: LD_VAR 0 4
41173: PPUSH
41174: CALL_OW 1
41178: ST_TO_ADDR
// if not tmp then
41179: LD_VAR 0 4
41183: NOT
41184: IFFALSE 41188
// continue ;
41186: GO 41136
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41188: LD_ADDR_VAR 0 6
41192: PUSH
41193: LD_EXP 100
41197: PUSH
41198: LD_VAR 0 2
41202: ARRAY
41203: PPUSH
41204: LD_INT 2
41206: PUSH
41207: LD_INT 30
41209: PUSH
41210: LD_INT 4
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 30
41219: PUSH
41220: LD_INT 5
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: LIST
41231: PPUSH
41232: CALL_OW 72
41236: PUSH
41237: LD_EXP 100
41241: PUSH
41242: LD_VAR 0 2
41246: ARRAY
41247: PPUSH
41248: LD_INT 2
41250: PUSH
41251: LD_INT 30
41253: PUSH
41254: LD_INT 0
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 30
41263: PUSH
41264: LD_INT 1
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: LIST
41275: PPUSH
41276: CALL_OW 72
41280: PUSH
41281: LD_EXP 100
41285: PUSH
41286: LD_VAR 0 2
41290: ARRAY
41291: PPUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 3
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PPUSH
41302: CALL_OW 72
41306: PUSH
41307: LD_EXP 100
41311: PUSH
41312: LD_VAR 0 2
41316: ARRAY
41317: PPUSH
41318: LD_INT 2
41320: PUSH
41321: LD_INT 30
41323: PUSH
41324: LD_INT 6
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: LD_INT 30
41333: PUSH
41334: LD_INT 7
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 30
41343: PUSH
41344: LD_INT 8
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: PPUSH
41357: CALL_OW 72
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: LIST
41366: LIST
41367: ST_TO_ADDR
// for j = 1 to 4 do
41368: LD_ADDR_VAR 0 3
41372: PUSH
41373: DOUBLE
41374: LD_INT 1
41376: DEC
41377: ST_TO_ADDR
41378: LD_INT 4
41380: PUSH
41381: FOR_TO
41382: IFFALSE 41573
// begin if not tmp [ j ] then
41384: LD_VAR 0 4
41388: PUSH
41389: LD_VAR 0 3
41393: ARRAY
41394: NOT
41395: IFFALSE 41399
// continue ;
41397: GO 41381
// for p in tmp [ j ] do
41399: LD_ADDR_VAR 0 5
41403: PUSH
41404: LD_VAR 0 4
41408: PUSH
41409: LD_VAR 0 3
41413: ARRAY
41414: PUSH
41415: FOR_IN
41416: IFFALSE 41569
// begin if not b [ j ] then
41418: LD_VAR 0 6
41422: PUSH
41423: LD_VAR 0 3
41427: ARRAY
41428: NOT
41429: IFFALSE 41433
// break ;
41431: GO 41569
// e := 0 ;
41433: LD_ADDR_VAR 0 7
41437: PUSH
41438: LD_INT 0
41440: ST_TO_ADDR
// for k in b [ j ] do
41441: LD_ADDR_VAR 0 8
41445: PUSH
41446: LD_VAR 0 6
41450: PUSH
41451: LD_VAR 0 3
41455: ARRAY
41456: PUSH
41457: FOR_IN
41458: IFFALSE 41485
// if IsNotFull ( k ) then
41460: LD_VAR 0 8
41464: PPUSH
41465: CALL 69726 0 1
41469: IFFALSE 41483
// begin e := k ;
41471: LD_ADDR_VAR 0 7
41475: PUSH
41476: LD_VAR 0 8
41480: ST_TO_ADDR
// break ;
41481: GO 41485
// end ;
41483: GO 41457
41485: POP
41486: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41487: LD_VAR 0 7
41491: PUSH
41492: LD_VAR 0 5
41496: PPUSH
41497: LD_VAR 0 7
41501: PPUSH
41502: CALL 103605 0 2
41506: NOT
41507: AND
41508: IFFALSE 41567
// begin if IsInUnit ( p ) then
41510: LD_VAR 0 5
41514: PPUSH
41515: CALL_OW 310
41519: IFFALSE 41530
// ComExitBuilding ( p ) ;
41521: LD_VAR 0 5
41525: PPUSH
41526: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41530: LD_VAR 0 5
41534: PPUSH
41535: LD_VAR 0 7
41539: PPUSH
41540: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41544: LD_VAR 0 5
41548: PPUSH
41549: LD_VAR 0 3
41553: PPUSH
41554: CALL_OW 183
// AddComExitBuilding ( p ) ;
41558: LD_VAR 0 5
41562: PPUSH
41563: CALL_OW 182
// end ; end ;
41567: GO 41415
41569: POP
41570: POP
// end ;
41571: GO 41381
41573: POP
41574: POP
// end ;
41575: GO 41136
41577: POP
41578: POP
// end ;
41579: LD_VAR 0 1
41583: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41584: LD_INT 0
41586: PPUSH
41587: PPUSH
41588: PPUSH
41589: PPUSH
41590: PPUSH
41591: PPUSH
41592: PPUSH
41593: PPUSH
41594: PPUSH
41595: PPUSH
41596: PPUSH
41597: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41598: LD_VAR 0 1
41602: NOT
41603: PUSH
41604: LD_EXP 100
41608: PUSH
41609: LD_VAR 0 1
41613: ARRAY
41614: NOT
41615: OR
41616: PUSH
41617: LD_EXP 100
41621: PUSH
41622: LD_VAR 0 1
41626: ARRAY
41627: PPUSH
41628: LD_INT 2
41630: PUSH
41631: LD_INT 30
41633: PUSH
41634: LD_INT 0
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 30
41643: PUSH
41644: LD_INT 1
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: LIST
41655: PPUSH
41656: CALL_OW 72
41660: NOT
41661: OR
41662: IFFALSE 41666
// exit ;
41664: GO 45169
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41666: LD_ADDR_VAR 0 4
41670: PUSH
41671: LD_EXP 100
41675: PUSH
41676: LD_VAR 0 1
41680: ARRAY
41681: PPUSH
41682: LD_INT 2
41684: PUSH
41685: LD_INT 25
41687: PUSH
41688: LD_INT 1
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 25
41697: PUSH
41698: LD_INT 2
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 25
41707: PUSH
41708: LD_INT 3
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 25
41717: PUSH
41718: LD_INT 4
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 25
41727: PUSH
41728: LD_INT 5
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 25
41737: PUSH
41738: LD_INT 8
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 25
41747: PUSH
41748: LD_INT 9
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: PPUSH
41765: CALL_OW 72
41769: ST_TO_ADDR
// if not tmp then
41770: LD_VAR 0 4
41774: NOT
41775: IFFALSE 41779
// exit ;
41777: GO 45169
// for i in tmp do
41779: LD_ADDR_VAR 0 3
41783: PUSH
41784: LD_VAR 0 4
41788: PUSH
41789: FOR_IN
41790: IFFALSE 41821
// if GetTag ( i ) then
41792: LD_VAR 0 3
41796: PPUSH
41797: CALL_OW 110
41801: IFFALSE 41819
// tmp := tmp diff i ;
41803: LD_ADDR_VAR 0 4
41807: PUSH
41808: LD_VAR 0 4
41812: PUSH
41813: LD_VAR 0 3
41817: DIFF
41818: ST_TO_ADDR
41819: GO 41789
41821: POP
41822: POP
// if not tmp then
41823: LD_VAR 0 4
41827: NOT
41828: IFFALSE 41832
// exit ;
41830: GO 45169
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41832: LD_ADDR_VAR 0 5
41836: PUSH
41837: LD_EXP 100
41841: PUSH
41842: LD_VAR 0 1
41846: ARRAY
41847: PPUSH
41848: LD_INT 2
41850: PUSH
41851: LD_INT 25
41853: PUSH
41854: LD_INT 1
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 25
41863: PUSH
41864: LD_INT 5
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 25
41873: PUSH
41874: LD_INT 8
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 25
41883: PUSH
41884: LD_INT 9
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: PPUSH
41898: CALL_OW 72
41902: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41903: LD_ADDR_VAR 0 6
41907: PUSH
41908: LD_EXP 100
41912: PUSH
41913: LD_VAR 0 1
41917: ARRAY
41918: PPUSH
41919: LD_INT 25
41921: PUSH
41922: LD_INT 2
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PPUSH
41929: CALL_OW 72
41933: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41934: LD_ADDR_VAR 0 7
41938: PUSH
41939: LD_EXP 100
41943: PUSH
41944: LD_VAR 0 1
41948: ARRAY
41949: PPUSH
41950: LD_INT 25
41952: PUSH
41953: LD_INT 3
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PPUSH
41960: CALL_OW 72
41964: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41965: LD_ADDR_VAR 0 8
41969: PUSH
41970: LD_EXP 100
41974: PUSH
41975: LD_VAR 0 1
41979: ARRAY
41980: PPUSH
41981: LD_INT 25
41983: PUSH
41984: LD_INT 4
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 24
41993: PUSH
41994: LD_INT 251
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PPUSH
42005: CALL_OW 72
42009: ST_TO_ADDR
// if mc_is_defending [ base ] then
42010: LD_EXP 143
42014: PUSH
42015: LD_VAR 0 1
42019: ARRAY
42020: IFFALSE 42481
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
42022: LD_ADDR_EXP 142
42026: PUSH
42027: LD_EXP 142
42031: PPUSH
42032: LD_VAR 0 1
42036: PPUSH
42037: LD_INT 4
42039: PPUSH
42040: CALL_OW 1
42044: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42045: LD_ADDR_VAR 0 12
42049: PUSH
42050: LD_EXP 100
42054: PUSH
42055: LD_VAR 0 1
42059: ARRAY
42060: PPUSH
42061: LD_INT 2
42063: PUSH
42064: LD_INT 30
42066: PUSH
42067: LD_INT 4
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 30
42076: PUSH
42077: LD_INT 5
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: LIST
42088: PPUSH
42089: CALL_OW 72
42093: ST_TO_ADDR
// if not b then
42094: LD_VAR 0 12
42098: NOT
42099: IFFALSE 42103
// exit ;
42101: GO 45169
// p := [ ] ;
42103: LD_ADDR_VAR 0 11
42107: PUSH
42108: EMPTY
42109: ST_TO_ADDR
// if sci >= 2 then
42110: LD_VAR 0 8
42114: PUSH
42115: LD_INT 2
42117: GREATEREQUAL
42118: IFFALSE 42149
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
42120: LD_ADDR_VAR 0 8
42124: PUSH
42125: LD_VAR 0 8
42129: PUSH
42130: LD_INT 1
42132: ARRAY
42133: PUSH
42134: LD_VAR 0 8
42138: PUSH
42139: LD_INT 2
42141: ARRAY
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: ST_TO_ADDR
42147: GO 42210
// if sci = 1 then
42149: LD_VAR 0 8
42153: PUSH
42154: LD_INT 1
42156: EQUAL
42157: IFFALSE 42178
// sci := [ sci [ 1 ] ] else
42159: LD_ADDR_VAR 0 8
42163: PUSH
42164: LD_VAR 0 8
42168: PUSH
42169: LD_INT 1
42171: ARRAY
42172: PUSH
42173: EMPTY
42174: LIST
42175: ST_TO_ADDR
42176: GO 42210
// if sci = 0 then
42178: LD_VAR 0 8
42182: PUSH
42183: LD_INT 0
42185: EQUAL
42186: IFFALSE 42210
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42188: LD_ADDR_VAR 0 11
42192: PUSH
42193: LD_VAR 0 4
42197: PPUSH
42198: LD_INT 4
42200: PPUSH
42201: CALL 103468 0 2
42205: PUSH
42206: LD_INT 1
42208: ARRAY
42209: ST_TO_ADDR
// if eng > 4 then
42210: LD_VAR 0 6
42214: PUSH
42215: LD_INT 4
42217: GREATER
42218: IFFALSE 42264
// for i = eng downto 4 do
42220: LD_ADDR_VAR 0 3
42224: PUSH
42225: DOUBLE
42226: LD_VAR 0 6
42230: INC
42231: ST_TO_ADDR
42232: LD_INT 4
42234: PUSH
42235: FOR_DOWNTO
42236: IFFALSE 42262
// eng := eng diff eng [ i ] ;
42238: LD_ADDR_VAR 0 6
42242: PUSH
42243: LD_VAR 0 6
42247: PUSH
42248: LD_VAR 0 6
42252: PUSH
42253: LD_VAR 0 3
42257: ARRAY
42258: DIFF
42259: ST_TO_ADDR
42260: GO 42235
42262: POP
42263: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42264: LD_ADDR_VAR 0 4
42268: PUSH
42269: LD_VAR 0 4
42273: PUSH
42274: LD_VAR 0 5
42278: PUSH
42279: LD_VAR 0 6
42283: UNION
42284: PUSH
42285: LD_VAR 0 7
42289: UNION
42290: PUSH
42291: LD_VAR 0 8
42295: UNION
42296: DIFF
42297: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42298: LD_ADDR_VAR 0 13
42302: PUSH
42303: LD_EXP 100
42307: PUSH
42308: LD_VAR 0 1
42312: ARRAY
42313: PPUSH
42314: LD_INT 2
42316: PUSH
42317: LD_INT 30
42319: PUSH
42320: LD_INT 32
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 30
42329: PUSH
42330: LD_INT 31
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: LIST
42341: PPUSH
42342: CALL_OW 72
42346: PUSH
42347: LD_EXP 100
42351: PUSH
42352: LD_VAR 0 1
42356: ARRAY
42357: PPUSH
42358: LD_INT 2
42360: PUSH
42361: LD_INT 30
42363: PUSH
42364: LD_INT 4
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 30
42373: PUSH
42374: LD_INT 5
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: LIST
42385: PPUSH
42386: CALL_OW 72
42390: PUSH
42391: LD_INT 6
42393: MUL
42394: PLUS
42395: ST_TO_ADDR
// if bcount < tmp then
42396: LD_VAR 0 13
42400: PUSH
42401: LD_VAR 0 4
42405: LESS
42406: IFFALSE 42452
// for i = tmp downto bcount do
42408: LD_ADDR_VAR 0 3
42412: PUSH
42413: DOUBLE
42414: LD_VAR 0 4
42418: INC
42419: ST_TO_ADDR
42420: LD_VAR 0 13
42424: PUSH
42425: FOR_DOWNTO
42426: IFFALSE 42450
// tmp := Delete ( tmp , tmp ) ;
42428: LD_ADDR_VAR 0 4
42432: PUSH
42433: LD_VAR 0 4
42437: PPUSH
42438: LD_VAR 0 4
42442: PPUSH
42443: CALL_OW 3
42447: ST_TO_ADDR
42448: GO 42425
42450: POP
42451: POP
// result := [ tmp , 0 , 0 , p ] ;
42452: LD_ADDR_VAR 0 2
42456: PUSH
42457: LD_VAR 0 4
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: LD_INT 0
42467: PUSH
42468: LD_VAR 0 11
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: ST_TO_ADDR
// exit ;
42479: GO 45169
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42481: LD_EXP 100
42485: PUSH
42486: LD_VAR 0 1
42490: ARRAY
42491: PPUSH
42492: LD_INT 2
42494: PUSH
42495: LD_INT 30
42497: PUSH
42498: LD_INT 6
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 30
42507: PUSH
42508: LD_INT 7
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 30
42517: PUSH
42518: LD_INT 8
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: PPUSH
42531: CALL_OW 72
42535: NOT
42536: PUSH
42537: LD_EXP 100
42541: PUSH
42542: LD_VAR 0 1
42546: ARRAY
42547: PPUSH
42548: LD_INT 30
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PPUSH
42558: CALL_OW 72
42562: NOT
42563: AND
42564: IFFALSE 42636
// begin if eng = tmp then
42566: LD_VAR 0 6
42570: PUSH
42571: LD_VAR 0 4
42575: EQUAL
42576: IFFALSE 42580
// exit ;
42578: GO 45169
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42580: LD_ADDR_EXP 142
42584: PUSH
42585: LD_EXP 142
42589: PPUSH
42590: LD_VAR 0 1
42594: PPUSH
42595: LD_INT 1
42597: PPUSH
42598: CALL_OW 1
42602: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42603: LD_ADDR_VAR 0 2
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: LD_VAR 0 4
42615: PUSH
42616: LD_VAR 0 6
42620: DIFF
42621: PUSH
42622: LD_INT 0
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: ST_TO_ADDR
// exit ;
42634: GO 45169
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42636: LD_EXP 127
42640: PUSH
42641: LD_EXP 126
42645: PUSH
42646: LD_VAR 0 1
42650: ARRAY
42651: ARRAY
42652: PUSH
42653: LD_EXP 100
42657: PUSH
42658: LD_VAR 0 1
42662: ARRAY
42663: PPUSH
42664: LD_INT 2
42666: PUSH
42667: LD_INT 30
42669: PUSH
42670: LD_INT 6
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 30
42679: PUSH
42680: LD_INT 7
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 30
42689: PUSH
42690: LD_INT 8
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: PPUSH
42703: CALL_OW 72
42707: AND
42708: PUSH
42709: LD_EXP 100
42713: PUSH
42714: LD_VAR 0 1
42718: ARRAY
42719: PPUSH
42720: LD_INT 30
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PPUSH
42730: CALL_OW 72
42734: NOT
42735: AND
42736: IFFALSE 42950
// begin if sci >= 6 then
42738: LD_VAR 0 8
42742: PUSH
42743: LD_INT 6
42745: GREATEREQUAL
42746: IFFALSE 42750
// exit ;
42748: GO 45169
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42750: LD_ADDR_EXP 142
42754: PUSH
42755: LD_EXP 142
42759: PPUSH
42760: LD_VAR 0 1
42764: PPUSH
42765: LD_INT 2
42767: PPUSH
42768: CALL_OW 1
42772: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42773: LD_ADDR_VAR 0 9
42777: PUSH
42778: LD_VAR 0 4
42782: PUSH
42783: LD_VAR 0 8
42787: DIFF
42788: PPUSH
42789: LD_INT 4
42791: PPUSH
42792: CALL 103468 0 2
42796: ST_TO_ADDR
// p := [ ] ;
42797: LD_ADDR_VAR 0 11
42801: PUSH
42802: EMPTY
42803: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42804: LD_VAR 0 8
42808: PUSH
42809: LD_INT 6
42811: LESS
42812: PUSH
42813: LD_VAR 0 9
42817: PUSH
42818: LD_INT 6
42820: GREATER
42821: AND
42822: IFFALSE 42903
// begin for i = 1 to 6 - sci do
42824: LD_ADDR_VAR 0 3
42828: PUSH
42829: DOUBLE
42830: LD_INT 1
42832: DEC
42833: ST_TO_ADDR
42834: LD_INT 6
42836: PUSH
42837: LD_VAR 0 8
42841: MINUS
42842: PUSH
42843: FOR_TO
42844: IFFALSE 42899
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42846: LD_ADDR_VAR 0 11
42850: PUSH
42851: LD_VAR 0 11
42855: PPUSH
42856: LD_VAR 0 11
42860: PUSH
42861: LD_INT 1
42863: PLUS
42864: PPUSH
42865: LD_VAR 0 9
42869: PUSH
42870: LD_INT 1
42872: ARRAY
42873: PPUSH
42874: CALL_OW 2
42878: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42879: LD_ADDR_VAR 0 9
42883: PUSH
42884: LD_VAR 0 9
42888: PPUSH
42889: LD_INT 1
42891: PPUSH
42892: CALL_OW 3
42896: ST_TO_ADDR
// end ;
42897: GO 42843
42899: POP
42900: POP
// end else
42901: GO 42923
// if sort then
42903: LD_VAR 0 9
42907: IFFALSE 42923
// p := sort [ 1 ] ;
42909: LD_ADDR_VAR 0 11
42913: PUSH
42914: LD_VAR 0 9
42918: PUSH
42919: LD_INT 1
42921: ARRAY
42922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42923: LD_ADDR_VAR 0 2
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: LD_INT 0
42933: PUSH
42934: LD_INT 0
42936: PUSH
42937: LD_VAR 0 11
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: ST_TO_ADDR
// exit ;
42948: GO 45169
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42950: LD_EXP 127
42954: PUSH
42955: LD_EXP 126
42959: PUSH
42960: LD_VAR 0 1
42964: ARRAY
42965: ARRAY
42966: PUSH
42967: LD_EXP 100
42971: PUSH
42972: LD_VAR 0 1
42976: ARRAY
42977: PPUSH
42978: LD_INT 2
42980: PUSH
42981: LD_INT 30
42983: PUSH
42984: LD_INT 6
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 30
42993: PUSH
42994: LD_INT 7
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 30
43003: PUSH
43004: LD_INT 8
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: PPUSH
43017: CALL_OW 72
43021: AND
43022: PUSH
43023: LD_EXP 100
43027: PUSH
43028: LD_VAR 0 1
43032: ARRAY
43033: PPUSH
43034: LD_INT 30
43036: PUSH
43037: LD_INT 3
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PPUSH
43044: CALL_OW 72
43048: AND
43049: IFFALSE 43783
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
43051: LD_ADDR_EXP 142
43055: PUSH
43056: LD_EXP 142
43060: PPUSH
43061: LD_VAR 0 1
43065: PPUSH
43066: LD_INT 3
43068: PPUSH
43069: CALL_OW 1
43073: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43074: LD_ADDR_VAR 0 2
43078: PUSH
43079: LD_INT 0
43081: PUSH
43082: LD_INT 0
43084: PUSH
43085: LD_INT 0
43087: PUSH
43088: LD_INT 0
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: ST_TO_ADDR
// if not eng then
43097: LD_VAR 0 6
43101: NOT
43102: IFFALSE 43165
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
43104: LD_ADDR_VAR 0 11
43108: PUSH
43109: LD_VAR 0 4
43113: PPUSH
43114: LD_INT 2
43116: PPUSH
43117: CALL 103468 0 2
43121: PUSH
43122: LD_INT 1
43124: ARRAY
43125: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
43126: LD_ADDR_VAR 0 2
43130: PUSH
43131: LD_VAR 0 2
43135: PPUSH
43136: LD_INT 2
43138: PPUSH
43139: LD_VAR 0 11
43143: PPUSH
43144: CALL_OW 1
43148: ST_TO_ADDR
// tmp := tmp diff p ;
43149: LD_ADDR_VAR 0 4
43153: PUSH
43154: LD_VAR 0 4
43158: PUSH
43159: LD_VAR 0 11
43163: DIFF
43164: ST_TO_ADDR
// end ; if tmp and sci < 6 then
43165: LD_VAR 0 4
43169: PUSH
43170: LD_VAR 0 8
43174: PUSH
43175: LD_INT 6
43177: LESS
43178: AND
43179: IFFALSE 43367
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43181: LD_ADDR_VAR 0 9
43185: PUSH
43186: LD_VAR 0 4
43190: PUSH
43191: LD_VAR 0 8
43195: PUSH
43196: LD_VAR 0 7
43200: UNION
43201: DIFF
43202: PPUSH
43203: LD_INT 4
43205: PPUSH
43206: CALL 103468 0 2
43210: ST_TO_ADDR
// p := [ ] ;
43211: LD_ADDR_VAR 0 11
43215: PUSH
43216: EMPTY
43217: ST_TO_ADDR
// if sort then
43218: LD_VAR 0 9
43222: IFFALSE 43338
// for i = 1 to 6 - sci do
43224: LD_ADDR_VAR 0 3
43228: PUSH
43229: DOUBLE
43230: LD_INT 1
43232: DEC
43233: ST_TO_ADDR
43234: LD_INT 6
43236: PUSH
43237: LD_VAR 0 8
43241: MINUS
43242: PUSH
43243: FOR_TO
43244: IFFALSE 43336
// begin if i = sort then
43246: LD_VAR 0 3
43250: PUSH
43251: LD_VAR 0 9
43255: EQUAL
43256: IFFALSE 43260
// break ;
43258: GO 43336
// if GetClass ( i ) = 4 then
43260: LD_VAR 0 3
43264: PPUSH
43265: CALL_OW 257
43269: PUSH
43270: LD_INT 4
43272: EQUAL
43273: IFFALSE 43277
// continue ;
43275: GO 43243
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43277: LD_ADDR_VAR 0 11
43281: PUSH
43282: LD_VAR 0 11
43286: PPUSH
43287: LD_VAR 0 11
43291: PUSH
43292: LD_INT 1
43294: PLUS
43295: PPUSH
43296: LD_VAR 0 9
43300: PUSH
43301: LD_VAR 0 3
43305: ARRAY
43306: PPUSH
43307: CALL_OW 2
43311: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43312: LD_ADDR_VAR 0 4
43316: PUSH
43317: LD_VAR 0 4
43321: PUSH
43322: LD_VAR 0 9
43326: PUSH
43327: LD_VAR 0 3
43331: ARRAY
43332: DIFF
43333: ST_TO_ADDR
// end ;
43334: GO 43243
43336: POP
43337: POP
// if p then
43338: LD_VAR 0 11
43342: IFFALSE 43367
// result := Replace ( result , 4 , p ) ;
43344: LD_ADDR_VAR 0 2
43348: PUSH
43349: LD_VAR 0 2
43353: PPUSH
43354: LD_INT 4
43356: PPUSH
43357: LD_VAR 0 11
43361: PPUSH
43362: CALL_OW 1
43366: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43367: LD_VAR 0 4
43371: PUSH
43372: LD_VAR 0 7
43376: PUSH
43377: LD_INT 6
43379: LESS
43380: AND
43381: IFFALSE 43569
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43383: LD_ADDR_VAR 0 9
43387: PUSH
43388: LD_VAR 0 4
43392: PUSH
43393: LD_VAR 0 8
43397: PUSH
43398: LD_VAR 0 7
43402: UNION
43403: DIFF
43404: PPUSH
43405: LD_INT 3
43407: PPUSH
43408: CALL 103468 0 2
43412: ST_TO_ADDR
// p := [ ] ;
43413: LD_ADDR_VAR 0 11
43417: PUSH
43418: EMPTY
43419: ST_TO_ADDR
// if sort then
43420: LD_VAR 0 9
43424: IFFALSE 43540
// for i = 1 to 6 - mech do
43426: LD_ADDR_VAR 0 3
43430: PUSH
43431: DOUBLE
43432: LD_INT 1
43434: DEC
43435: ST_TO_ADDR
43436: LD_INT 6
43438: PUSH
43439: LD_VAR 0 7
43443: MINUS
43444: PUSH
43445: FOR_TO
43446: IFFALSE 43538
// begin if i = sort then
43448: LD_VAR 0 3
43452: PUSH
43453: LD_VAR 0 9
43457: EQUAL
43458: IFFALSE 43462
// break ;
43460: GO 43538
// if GetClass ( i ) = 3 then
43462: LD_VAR 0 3
43466: PPUSH
43467: CALL_OW 257
43471: PUSH
43472: LD_INT 3
43474: EQUAL
43475: IFFALSE 43479
// continue ;
43477: GO 43445
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43479: LD_ADDR_VAR 0 11
43483: PUSH
43484: LD_VAR 0 11
43488: PPUSH
43489: LD_VAR 0 11
43493: PUSH
43494: LD_INT 1
43496: PLUS
43497: PPUSH
43498: LD_VAR 0 9
43502: PUSH
43503: LD_VAR 0 3
43507: ARRAY
43508: PPUSH
43509: CALL_OW 2
43513: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43514: LD_ADDR_VAR 0 4
43518: PUSH
43519: LD_VAR 0 4
43523: PUSH
43524: LD_VAR 0 9
43528: PUSH
43529: LD_VAR 0 3
43533: ARRAY
43534: DIFF
43535: ST_TO_ADDR
// end ;
43536: GO 43445
43538: POP
43539: POP
// if p then
43540: LD_VAR 0 11
43544: IFFALSE 43569
// result := Replace ( result , 3 , p ) ;
43546: LD_ADDR_VAR 0 2
43550: PUSH
43551: LD_VAR 0 2
43555: PPUSH
43556: LD_INT 3
43558: PPUSH
43559: LD_VAR 0 11
43563: PPUSH
43564: CALL_OW 1
43568: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43569: LD_VAR 0 4
43573: PUSH
43574: LD_INT 6
43576: GREATER
43577: PUSH
43578: LD_VAR 0 6
43582: PUSH
43583: LD_INT 6
43585: LESS
43586: AND
43587: IFFALSE 43781
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43589: LD_ADDR_VAR 0 9
43593: PUSH
43594: LD_VAR 0 4
43598: PUSH
43599: LD_VAR 0 8
43603: PUSH
43604: LD_VAR 0 7
43608: UNION
43609: PUSH
43610: LD_VAR 0 6
43614: UNION
43615: DIFF
43616: PPUSH
43617: LD_INT 2
43619: PPUSH
43620: CALL 103468 0 2
43624: ST_TO_ADDR
// p := [ ] ;
43625: LD_ADDR_VAR 0 11
43629: PUSH
43630: EMPTY
43631: ST_TO_ADDR
// if sort then
43632: LD_VAR 0 9
43636: IFFALSE 43752
// for i = 1 to 6 - eng do
43638: LD_ADDR_VAR 0 3
43642: PUSH
43643: DOUBLE
43644: LD_INT 1
43646: DEC
43647: ST_TO_ADDR
43648: LD_INT 6
43650: PUSH
43651: LD_VAR 0 6
43655: MINUS
43656: PUSH
43657: FOR_TO
43658: IFFALSE 43750
// begin if i = sort then
43660: LD_VAR 0 3
43664: PUSH
43665: LD_VAR 0 9
43669: EQUAL
43670: IFFALSE 43674
// break ;
43672: GO 43750
// if GetClass ( i ) = 2 then
43674: LD_VAR 0 3
43678: PPUSH
43679: CALL_OW 257
43683: PUSH
43684: LD_INT 2
43686: EQUAL
43687: IFFALSE 43691
// continue ;
43689: GO 43657
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43691: LD_ADDR_VAR 0 11
43695: PUSH
43696: LD_VAR 0 11
43700: PPUSH
43701: LD_VAR 0 11
43705: PUSH
43706: LD_INT 1
43708: PLUS
43709: PPUSH
43710: LD_VAR 0 9
43714: PUSH
43715: LD_VAR 0 3
43719: ARRAY
43720: PPUSH
43721: CALL_OW 2
43725: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43726: LD_ADDR_VAR 0 4
43730: PUSH
43731: LD_VAR 0 4
43735: PUSH
43736: LD_VAR 0 9
43740: PUSH
43741: LD_VAR 0 3
43745: ARRAY
43746: DIFF
43747: ST_TO_ADDR
// end ;
43748: GO 43657
43750: POP
43751: POP
// if p then
43752: LD_VAR 0 11
43756: IFFALSE 43781
// result := Replace ( result , 2 , p ) ;
43758: LD_ADDR_VAR 0 2
43762: PUSH
43763: LD_VAR 0 2
43767: PPUSH
43768: LD_INT 2
43770: PPUSH
43771: LD_VAR 0 11
43775: PPUSH
43776: CALL_OW 1
43780: ST_TO_ADDR
// end ; exit ;
43781: GO 45169
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43783: LD_EXP 127
43787: PUSH
43788: LD_EXP 126
43792: PUSH
43793: LD_VAR 0 1
43797: ARRAY
43798: ARRAY
43799: NOT
43800: PUSH
43801: LD_EXP 100
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: PPUSH
43812: LD_INT 30
43814: PUSH
43815: LD_INT 3
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PPUSH
43822: CALL_OW 72
43826: AND
43827: PUSH
43828: LD_EXP 105
43832: PUSH
43833: LD_VAR 0 1
43837: ARRAY
43838: AND
43839: IFFALSE 44447
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43841: LD_ADDR_EXP 142
43845: PUSH
43846: LD_EXP 142
43850: PPUSH
43851: LD_VAR 0 1
43855: PPUSH
43856: LD_INT 5
43858: PPUSH
43859: CALL_OW 1
43863: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43864: LD_ADDR_VAR 0 2
43868: PUSH
43869: LD_INT 0
43871: PUSH
43872: LD_INT 0
43874: PUSH
43875: LD_INT 0
43877: PUSH
43878: LD_INT 0
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: ST_TO_ADDR
// if sci > 1 then
43887: LD_VAR 0 8
43891: PUSH
43892: LD_INT 1
43894: GREATER
43895: IFFALSE 43923
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43897: LD_ADDR_VAR 0 4
43901: PUSH
43902: LD_VAR 0 4
43906: PUSH
43907: LD_VAR 0 8
43911: PUSH
43912: LD_VAR 0 8
43916: PUSH
43917: LD_INT 1
43919: ARRAY
43920: DIFF
43921: DIFF
43922: ST_TO_ADDR
// if tmp and not sci then
43923: LD_VAR 0 4
43927: PUSH
43928: LD_VAR 0 8
43932: NOT
43933: AND
43934: IFFALSE 44003
// begin sort := SortBySkill ( tmp , 4 ) ;
43936: LD_ADDR_VAR 0 9
43940: PUSH
43941: LD_VAR 0 4
43945: PPUSH
43946: LD_INT 4
43948: PPUSH
43949: CALL 103468 0 2
43953: ST_TO_ADDR
// if sort then
43954: LD_VAR 0 9
43958: IFFALSE 43974
// p := sort [ 1 ] ;
43960: LD_ADDR_VAR 0 11
43964: PUSH
43965: LD_VAR 0 9
43969: PUSH
43970: LD_INT 1
43972: ARRAY
43973: ST_TO_ADDR
// if p then
43974: LD_VAR 0 11
43978: IFFALSE 44003
// result := Replace ( result , 4 , p ) ;
43980: LD_ADDR_VAR 0 2
43984: PUSH
43985: LD_VAR 0 2
43989: PPUSH
43990: LD_INT 4
43992: PPUSH
43993: LD_VAR 0 11
43997: PPUSH
43998: CALL_OW 1
44002: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44003: LD_ADDR_VAR 0 4
44007: PUSH
44008: LD_VAR 0 4
44012: PUSH
44013: LD_VAR 0 7
44017: DIFF
44018: ST_TO_ADDR
// if tmp and mech < 6 then
44019: LD_VAR 0 4
44023: PUSH
44024: LD_VAR 0 7
44028: PUSH
44029: LD_INT 6
44031: LESS
44032: AND
44033: IFFALSE 44221
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44035: LD_ADDR_VAR 0 9
44039: PUSH
44040: LD_VAR 0 4
44044: PUSH
44045: LD_VAR 0 8
44049: PUSH
44050: LD_VAR 0 7
44054: UNION
44055: DIFF
44056: PPUSH
44057: LD_INT 3
44059: PPUSH
44060: CALL 103468 0 2
44064: ST_TO_ADDR
// p := [ ] ;
44065: LD_ADDR_VAR 0 11
44069: PUSH
44070: EMPTY
44071: ST_TO_ADDR
// if sort then
44072: LD_VAR 0 9
44076: IFFALSE 44192
// for i = 1 to 6 - mech do
44078: LD_ADDR_VAR 0 3
44082: PUSH
44083: DOUBLE
44084: LD_INT 1
44086: DEC
44087: ST_TO_ADDR
44088: LD_INT 6
44090: PUSH
44091: LD_VAR 0 7
44095: MINUS
44096: PUSH
44097: FOR_TO
44098: IFFALSE 44190
// begin if i = sort then
44100: LD_VAR 0 3
44104: PUSH
44105: LD_VAR 0 9
44109: EQUAL
44110: IFFALSE 44114
// break ;
44112: GO 44190
// if GetClass ( i ) = 3 then
44114: LD_VAR 0 3
44118: PPUSH
44119: CALL_OW 257
44123: PUSH
44124: LD_INT 3
44126: EQUAL
44127: IFFALSE 44131
// continue ;
44129: GO 44097
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44131: LD_ADDR_VAR 0 11
44135: PUSH
44136: LD_VAR 0 11
44140: PPUSH
44141: LD_VAR 0 11
44145: PUSH
44146: LD_INT 1
44148: PLUS
44149: PPUSH
44150: LD_VAR 0 9
44154: PUSH
44155: LD_VAR 0 3
44159: ARRAY
44160: PPUSH
44161: CALL_OW 2
44165: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44166: LD_ADDR_VAR 0 4
44170: PUSH
44171: LD_VAR 0 4
44175: PUSH
44176: LD_VAR 0 9
44180: PUSH
44181: LD_VAR 0 3
44185: ARRAY
44186: DIFF
44187: ST_TO_ADDR
// end ;
44188: GO 44097
44190: POP
44191: POP
// if p then
44192: LD_VAR 0 11
44196: IFFALSE 44221
// result := Replace ( result , 3 , p ) ;
44198: LD_ADDR_VAR 0 2
44202: PUSH
44203: LD_VAR 0 2
44207: PPUSH
44208: LD_INT 3
44210: PPUSH
44211: LD_VAR 0 11
44215: PPUSH
44216: CALL_OW 1
44220: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44221: LD_ADDR_VAR 0 4
44225: PUSH
44226: LD_VAR 0 4
44230: PUSH
44231: LD_VAR 0 6
44235: DIFF
44236: ST_TO_ADDR
// if tmp and eng < 6 then
44237: LD_VAR 0 4
44241: PUSH
44242: LD_VAR 0 6
44246: PUSH
44247: LD_INT 6
44249: LESS
44250: AND
44251: IFFALSE 44445
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44253: LD_ADDR_VAR 0 9
44257: PUSH
44258: LD_VAR 0 4
44262: PUSH
44263: LD_VAR 0 8
44267: PUSH
44268: LD_VAR 0 7
44272: UNION
44273: PUSH
44274: LD_VAR 0 6
44278: UNION
44279: DIFF
44280: PPUSH
44281: LD_INT 2
44283: PPUSH
44284: CALL 103468 0 2
44288: ST_TO_ADDR
// p := [ ] ;
44289: LD_ADDR_VAR 0 11
44293: PUSH
44294: EMPTY
44295: ST_TO_ADDR
// if sort then
44296: LD_VAR 0 9
44300: IFFALSE 44416
// for i = 1 to 6 - eng do
44302: LD_ADDR_VAR 0 3
44306: PUSH
44307: DOUBLE
44308: LD_INT 1
44310: DEC
44311: ST_TO_ADDR
44312: LD_INT 6
44314: PUSH
44315: LD_VAR 0 6
44319: MINUS
44320: PUSH
44321: FOR_TO
44322: IFFALSE 44414
// begin if i = sort then
44324: LD_VAR 0 3
44328: PUSH
44329: LD_VAR 0 9
44333: EQUAL
44334: IFFALSE 44338
// break ;
44336: GO 44414
// if GetClass ( i ) = 2 then
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 257
44347: PUSH
44348: LD_INT 2
44350: EQUAL
44351: IFFALSE 44355
// continue ;
44353: GO 44321
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44355: LD_ADDR_VAR 0 11
44359: PUSH
44360: LD_VAR 0 11
44364: PPUSH
44365: LD_VAR 0 11
44369: PUSH
44370: LD_INT 1
44372: PLUS
44373: PPUSH
44374: LD_VAR 0 9
44378: PUSH
44379: LD_VAR 0 3
44383: ARRAY
44384: PPUSH
44385: CALL_OW 2
44389: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44390: LD_ADDR_VAR 0 4
44394: PUSH
44395: LD_VAR 0 4
44399: PUSH
44400: LD_VAR 0 9
44404: PUSH
44405: LD_VAR 0 3
44409: ARRAY
44410: DIFF
44411: ST_TO_ADDR
// end ;
44412: GO 44321
44414: POP
44415: POP
// if p then
44416: LD_VAR 0 11
44420: IFFALSE 44445
// result := Replace ( result , 2 , p ) ;
44422: LD_ADDR_VAR 0 2
44426: PUSH
44427: LD_VAR 0 2
44431: PPUSH
44432: LD_INT 2
44434: PPUSH
44435: LD_VAR 0 11
44439: PPUSH
44440: CALL_OW 1
44444: ST_TO_ADDR
// end ; exit ;
44445: GO 45169
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44447: LD_EXP 127
44451: PUSH
44452: LD_EXP 126
44456: PUSH
44457: LD_VAR 0 1
44461: ARRAY
44462: ARRAY
44463: NOT
44464: PUSH
44465: LD_EXP 100
44469: PUSH
44470: LD_VAR 0 1
44474: ARRAY
44475: PPUSH
44476: LD_INT 30
44478: PUSH
44479: LD_INT 3
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PPUSH
44486: CALL_OW 72
44490: AND
44491: PUSH
44492: LD_EXP 105
44496: PUSH
44497: LD_VAR 0 1
44501: ARRAY
44502: NOT
44503: AND
44504: IFFALSE 45169
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44506: LD_ADDR_EXP 142
44510: PUSH
44511: LD_EXP 142
44515: PPUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: LD_INT 6
44523: PPUSH
44524: CALL_OW 1
44528: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44529: LD_ADDR_VAR 0 2
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: LD_INT 0
44539: PUSH
44540: LD_INT 0
44542: PUSH
44543: LD_INT 0
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: ST_TO_ADDR
// if sci >= 1 then
44552: LD_VAR 0 8
44556: PUSH
44557: LD_INT 1
44559: GREATEREQUAL
44560: IFFALSE 44582
// tmp := tmp diff sci [ 1 ] ;
44562: LD_ADDR_VAR 0 4
44566: PUSH
44567: LD_VAR 0 4
44571: PUSH
44572: LD_VAR 0 8
44576: PUSH
44577: LD_INT 1
44579: ARRAY
44580: DIFF
44581: ST_TO_ADDR
// if tmp and not sci then
44582: LD_VAR 0 4
44586: PUSH
44587: LD_VAR 0 8
44591: NOT
44592: AND
44593: IFFALSE 44662
// begin sort := SortBySkill ( tmp , 4 ) ;
44595: LD_ADDR_VAR 0 9
44599: PUSH
44600: LD_VAR 0 4
44604: PPUSH
44605: LD_INT 4
44607: PPUSH
44608: CALL 103468 0 2
44612: ST_TO_ADDR
// if sort then
44613: LD_VAR 0 9
44617: IFFALSE 44633
// p := sort [ 1 ] ;
44619: LD_ADDR_VAR 0 11
44623: PUSH
44624: LD_VAR 0 9
44628: PUSH
44629: LD_INT 1
44631: ARRAY
44632: ST_TO_ADDR
// if p then
44633: LD_VAR 0 11
44637: IFFALSE 44662
// result := Replace ( result , 4 , p ) ;
44639: LD_ADDR_VAR 0 2
44643: PUSH
44644: LD_VAR 0 2
44648: PPUSH
44649: LD_INT 4
44651: PPUSH
44652: LD_VAR 0 11
44656: PPUSH
44657: CALL_OW 1
44661: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44662: LD_ADDR_VAR 0 4
44666: PUSH
44667: LD_VAR 0 4
44671: PUSH
44672: LD_VAR 0 7
44676: DIFF
44677: ST_TO_ADDR
// if tmp and mech < 6 then
44678: LD_VAR 0 4
44682: PUSH
44683: LD_VAR 0 7
44687: PUSH
44688: LD_INT 6
44690: LESS
44691: AND
44692: IFFALSE 44874
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44694: LD_ADDR_VAR 0 9
44698: PUSH
44699: LD_VAR 0 4
44703: PUSH
44704: LD_VAR 0 7
44708: DIFF
44709: PPUSH
44710: LD_INT 3
44712: PPUSH
44713: CALL 103468 0 2
44717: ST_TO_ADDR
// p := [ ] ;
44718: LD_ADDR_VAR 0 11
44722: PUSH
44723: EMPTY
44724: ST_TO_ADDR
// if sort then
44725: LD_VAR 0 9
44729: IFFALSE 44845
// for i = 1 to 6 - mech do
44731: LD_ADDR_VAR 0 3
44735: PUSH
44736: DOUBLE
44737: LD_INT 1
44739: DEC
44740: ST_TO_ADDR
44741: LD_INT 6
44743: PUSH
44744: LD_VAR 0 7
44748: MINUS
44749: PUSH
44750: FOR_TO
44751: IFFALSE 44843
// begin if i = sort then
44753: LD_VAR 0 3
44757: PUSH
44758: LD_VAR 0 9
44762: EQUAL
44763: IFFALSE 44767
// break ;
44765: GO 44843
// if GetClass ( i ) = 3 then
44767: LD_VAR 0 3
44771: PPUSH
44772: CALL_OW 257
44776: PUSH
44777: LD_INT 3
44779: EQUAL
44780: IFFALSE 44784
// continue ;
44782: GO 44750
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44784: LD_ADDR_VAR 0 11
44788: PUSH
44789: LD_VAR 0 11
44793: PPUSH
44794: LD_VAR 0 11
44798: PUSH
44799: LD_INT 1
44801: PLUS
44802: PPUSH
44803: LD_VAR 0 9
44807: PUSH
44808: LD_VAR 0 3
44812: ARRAY
44813: PPUSH
44814: CALL_OW 2
44818: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44819: LD_ADDR_VAR 0 4
44823: PUSH
44824: LD_VAR 0 4
44828: PUSH
44829: LD_VAR 0 9
44833: PUSH
44834: LD_VAR 0 3
44838: ARRAY
44839: DIFF
44840: ST_TO_ADDR
// end ;
44841: GO 44750
44843: POP
44844: POP
// if p then
44845: LD_VAR 0 11
44849: IFFALSE 44874
// result := Replace ( result , 3 , p ) ;
44851: LD_ADDR_VAR 0 2
44855: PUSH
44856: LD_VAR 0 2
44860: PPUSH
44861: LD_INT 3
44863: PPUSH
44864: LD_VAR 0 11
44868: PPUSH
44869: CALL_OW 1
44873: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44874: LD_ADDR_VAR 0 4
44878: PUSH
44879: LD_VAR 0 4
44883: PUSH
44884: LD_VAR 0 6
44888: DIFF
44889: ST_TO_ADDR
// if tmp and eng < 4 then
44890: LD_VAR 0 4
44894: PUSH
44895: LD_VAR 0 6
44899: PUSH
44900: LD_INT 4
44902: LESS
44903: AND
44904: IFFALSE 45094
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44906: LD_ADDR_VAR 0 9
44910: PUSH
44911: LD_VAR 0 4
44915: PUSH
44916: LD_VAR 0 7
44920: PUSH
44921: LD_VAR 0 6
44925: UNION
44926: DIFF
44927: PPUSH
44928: LD_INT 2
44930: PPUSH
44931: CALL 103468 0 2
44935: ST_TO_ADDR
// p := [ ] ;
44936: LD_ADDR_VAR 0 11
44940: PUSH
44941: EMPTY
44942: ST_TO_ADDR
// if sort then
44943: LD_VAR 0 9
44947: IFFALSE 45063
// for i = 1 to 4 - eng do
44949: LD_ADDR_VAR 0 3
44953: PUSH
44954: DOUBLE
44955: LD_INT 1
44957: DEC
44958: ST_TO_ADDR
44959: LD_INT 4
44961: PUSH
44962: LD_VAR 0 6
44966: MINUS
44967: PUSH
44968: FOR_TO
44969: IFFALSE 45061
// begin if i = sort then
44971: LD_VAR 0 3
44975: PUSH
44976: LD_VAR 0 9
44980: EQUAL
44981: IFFALSE 44985
// break ;
44983: GO 45061
// if GetClass ( i ) = 2 then
44985: LD_VAR 0 3
44989: PPUSH
44990: CALL_OW 257
44994: PUSH
44995: LD_INT 2
44997: EQUAL
44998: IFFALSE 45002
// continue ;
45000: GO 44968
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45002: LD_ADDR_VAR 0 11
45006: PUSH
45007: LD_VAR 0 11
45011: PPUSH
45012: LD_VAR 0 11
45016: PUSH
45017: LD_INT 1
45019: PLUS
45020: PPUSH
45021: LD_VAR 0 9
45025: PUSH
45026: LD_VAR 0 3
45030: ARRAY
45031: PPUSH
45032: CALL_OW 2
45036: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45037: LD_ADDR_VAR 0 4
45041: PUSH
45042: LD_VAR 0 4
45046: PUSH
45047: LD_VAR 0 9
45051: PUSH
45052: LD_VAR 0 3
45056: ARRAY
45057: DIFF
45058: ST_TO_ADDR
// end ;
45059: GO 44968
45061: POP
45062: POP
// if p then
45063: LD_VAR 0 11
45067: IFFALSE 45092
// result := Replace ( result , 2 , p ) ;
45069: LD_ADDR_VAR 0 2
45073: PUSH
45074: LD_VAR 0 2
45078: PPUSH
45079: LD_INT 2
45081: PPUSH
45082: LD_VAR 0 11
45086: PPUSH
45087: CALL_OW 1
45091: ST_TO_ADDR
// end else
45092: GO 45138
// for i = eng downto 5 do
45094: LD_ADDR_VAR 0 3
45098: PUSH
45099: DOUBLE
45100: LD_VAR 0 6
45104: INC
45105: ST_TO_ADDR
45106: LD_INT 5
45108: PUSH
45109: FOR_DOWNTO
45110: IFFALSE 45136
// tmp := tmp union eng [ i ] ;
45112: LD_ADDR_VAR 0 4
45116: PUSH
45117: LD_VAR 0 4
45121: PUSH
45122: LD_VAR 0 6
45126: PUSH
45127: LD_VAR 0 3
45131: ARRAY
45132: UNION
45133: ST_TO_ADDR
45134: GO 45109
45136: POP
45137: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
45138: LD_ADDR_VAR 0 2
45142: PUSH
45143: LD_VAR 0 2
45147: PPUSH
45148: LD_INT 1
45150: PPUSH
45151: LD_VAR 0 4
45155: PUSH
45156: LD_VAR 0 5
45160: DIFF
45161: PPUSH
45162: CALL_OW 1
45166: ST_TO_ADDR
// exit ;
45167: GO 45169
// end ; end ;
45169: LD_VAR 0 2
45173: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
45174: LD_INT 0
45176: PPUSH
45177: PPUSH
45178: PPUSH
// if not mc_bases then
45179: LD_EXP 100
45183: NOT
45184: IFFALSE 45188
// exit ;
45186: GO 45330
// for i = 1 to mc_bases do
45188: LD_ADDR_VAR 0 2
45192: PUSH
45193: DOUBLE
45194: LD_INT 1
45196: DEC
45197: ST_TO_ADDR
45198: LD_EXP 100
45202: PUSH
45203: FOR_TO
45204: IFFALSE 45321
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45206: LD_ADDR_VAR 0 3
45210: PUSH
45211: LD_EXP 100
45215: PUSH
45216: LD_VAR 0 2
45220: ARRAY
45221: PPUSH
45222: LD_INT 21
45224: PUSH
45225: LD_INT 3
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 3
45234: PUSH
45235: LD_INT 2
45237: PUSH
45238: LD_INT 30
45240: PUSH
45241: LD_INT 29
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 30
45250: PUSH
45251: LD_INT 30
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: LIST
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 3
45269: PUSH
45270: LD_INT 24
45272: PUSH
45273: LD_INT 1000
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: LIST
45288: PPUSH
45289: CALL_OW 72
45293: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45294: LD_ADDR_EXP 101
45298: PUSH
45299: LD_EXP 101
45303: PPUSH
45304: LD_VAR 0 2
45308: PPUSH
45309: LD_VAR 0 3
45313: PPUSH
45314: CALL_OW 1
45318: ST_TO_ADDR
// end ;
45319: GO 45203
45321: POP
45322: POP
// RaiseSailEvent ( 101 ) ;
45323: LD_INT 101
45325: PPUSH
45326: CALL_OW 427
// end ;
45330: LD_VAR 0 1
45334: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45335: LD_INT 0
45337: PPUSH
45338: PPUSH
45339: PPUSH
45340: PPUSH
45341: PPUSH
45342: PPUSH
45343: PPUSH
// if not mc_bases then
45344: LD_EXP 100
45348: NOT
45349: IFFALSE 45353
// exit ;
45351: GO 45915
// for i = 1 to mc_bases do
45353: LD_ADDR_VAR 0 2
45357: PUSH
45358: DOUBLE
45359: LD_INT 1
45361: DEC
45362: ST_TO_ADDR
45363: LD_EXP 100
45367: PUSH
45368: FOR_TO
45369: IFFALSE 45906
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45371: LD_ADDR_VAR 0 5
45375: PUSH
45376: LD_EXP 100
45380: PUSH
45381: LD_VAR 0 2
45385: ARRAY
45386: PUSH
45387: LD_EXP 129
45391: PUSH
45392: LD_VAR 0 2
45396: ARRAY
45397: UNION
45398: PPUSH
45399: LD_INT 21
45401: PUSH
45402: LD_INT 1
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 1
45411: PUSH
45412: LD_INT 3
45414: PUSH
45415: LD_INT 54
45417: PUSH
45418: EMPTY
45419: LIST
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 3
45427: PUSH
45428: LD_INT 24
45430: PUSH
45431: LD_INT 1000
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PPUSH
45451: CALL_OW 72
45455: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45456: LD_ADDR_VAR 0 6
45460: PUSH
45461: LD_EXP 100
45465: PUSH
45466: LD_VAR 0 2
45470: ARRAY
45471: PPUSH
45472: LD_INT 21
45474: PUSH
45475: LD_INT 1
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: PUSH
45482: LD_INT 1
45484: PUSH
45485: LD_INT 3
45487: PUSH
45488: LD_INT 54
45490: PUSH
45491: EMPTY
45492: LIST
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 3
45500: PUSH
45501: LD_INT 24
45503: PUSH
45504: LD_INT 250
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PPUSH
45524: CALL_OW 72
45528: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45529: LD_ADDR_VAR 0 7
45533: PUSH
45534: LD_VAR 0 5
45538: PUSH
45539: LD_VAR 0 6
45543: DIFF
45544: ST_TO_ADDR
// if not need_heal_1 then
45545: LD_VAR 0 6
45549: NOT
45550: IFFALSE 45583
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45552: LD_ADDR_EXP 103
45556: PUSH
45557: LD_EXP 103
45561: PPUSH
45562: LD_VAR 0 2
45566: PUSH
45567: LD_INT 1
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PPUSH
45574: EMPTY
45575: PPUSH
45576: CALL 72647 0 3
45580: ST_TO_ADDR
45581: GO 45653
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45583: LD_ADDR_EXP 103
45587: PUSH
45588: LD_EXP 103
45592: PPUSH
45593: LD_VAR 0 2
45597: PUSH
45598: LD_INT 1
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: PPUSH
45605: LD_EXP 103
45609: PUSH
45610: LD_VAR 0 2
45614: ARRAY
45615: PUSH
45616: LD_INT 1
45618: ARRAY
45619: PPUSH
45620: LD_INT 3
45622: PUSH
45623: LD_INT 24
45625: PUSH
45626: LD_INT 1000
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PPUSH
45637: CALL_OW 72
45641: PUSH
45642: LD_VAR 0 6
45646: UNION
45647: PPUSH
45648: CALL 72647 0 3
45652: ST_TO_ADDR
// if not need_heal_2 then
45653: LD_VAR 0 7
45657: NOT
45658: IFFALSE 45691
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45660: LD_ADDR_EXP 103
45664: PUSH
45665: LD_EXP 103
45669: PPUSH
45670: LD_VAR 0 2
45674: PUSH
45675: LD_INT 2
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PPUSH
45682: EMPTY
45683: PPUSH
45684: CALL 72647 0 3
45688: ST_TO_ADDR
45689: GO 45723
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45691: LD_ADDR_EXP 103
45695: PUSH
45696: LD_EXP 103
45700: PPUSH
45701: LD_VAR 0 2
45705: PUSH
45706: LD_INT 2
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: PPUSH
45713: LD_VAR 0 7
45717: PPUSH
45718: CALL 72647 0 3
45722: ST_TO_ADDR
// if need_heal_2 then
45723: LD_VAR 0 7
45727: IFFALSE 45888
// for j in need_heal_2 do
45729: LD_ADDR_VAR 0 3
45733: PUSH
45734: LD_VAR 0 7
45738: PUSH
45739: FOR_IN
45740: IFFALSE 45886
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45742: LD_ADDR_VAR 0 5
45746: PUSH
45747: LD_EXP 100
45751: PUSH
45752: LD_VAR 0 2
45756: ARRAY
45757: PPUSH
45758: LD_INT 2
45760: PUSH
45761: LD_INT 30
45763: PUSH
45764: LD_INT 6
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 30
45773: PUSH
45774: LD_INT 7
45776: PUSH
45777: EMPTY
45778: LIST
45779: LIST
45780: PUSH
45781: LD_INT 30
45783: PUSH
45784: LD_INT 8
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 30
45793: PUSH
45794: LD_INT 0
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: LD_INT 30
45803: PUSH
45804: LD_INT 1
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: PPUSH
45819: CALL_OW 72
45823: ST_TO_ADDR
// if tmp then
45824: LD_VAR 0 5
45828: IFFALSE 45884
// begin k := NearestUnitToUnit ( tmp , j ) ;
45830: LD_ADDR_VAR 0 4
45834: PUSH
45835: LD_VAR 0 5
45839: PPUSH
45840: LD_VAR 0 3
45844: PPUSH
45845: CALL_OW 74
45849: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45850: LD_VAR 0 3
45854: PPUSH
45855: LD_VAR 0 4
45859: PPUSH
45860: CALL_OW 296
45864: PUSH
45865: LD_INT 5
45867: GREATER
45868: IFFALSE 45884
// ComMoveToNearbyEntrance ( j , k ) ;
45870: LD_VAR 0 3
45874: PPUSH
45875: LD_VAR 0 4
45879: PPUSH
45880: CALL 105836 0 2
// end ; end ;
45884: GO 45739
45886: POP
45887: POP
// if not need_heal_1 and not need_heal_2 then
45888: LD_VAR 0 6
45892: NOT
45893: PUSH
45894: LD_VAR 0 7
45898: NOT
45899: AND
45900: IFFALSE 45904
// continue ;
45902: GO 45368
// end ;
45904: GO 45368
45906: POP
45907: POP
// RaiseSailEvent ( 102 ) ;
45908: LD_INT 102
45910: PPUSH
45911: CALL_OW 427
// end ;
45915: LD_VAR 0 1
45919: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45920: LD_INT 0
45922: PPUSH
45923: PPUSH
45924: PPUSH
45925: PPUSH
45926: PPUSH
45927: PPUSH
45928: PPUSH
45929: PPUSH
// if not mc_bases then
45930: LD_EXP 100
45934: NOT
45935: IFFALSE 45939
// exit ;
45937: GO 46850
// for i = 1 to mc_bases do
45939: LD_ADDR_VAR 0 2
45943: PUSH
45944: DOUBLE
45945: LD_INT 1
45947: DEC
45948: ST_TO_ADDR
45949: LD_EXP 100
45953: PUSH
45954: FOR_TO
45955: IFFALSE 46848
// begin if not mc_building_need_repair [ i ] then
45957: LD_EXP 101
45961: PUSH
45962: LD_VAR 0 2
45966: ARRAY
45967: NOT
45968: IFFALSE 46153
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45970: LD_ADDR_VAR 0 6
45974: PUSH
45975: LD_EXP 119
45979: PUSH
45980: LD_VAR 0 2
45984: ARRAY
45985: PPUSH
45986: LD_INT 3
45988: PUSH
45989: LD_INT 24
45991: PUSH
45992: LD_INT 1000
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: EMPTY
46000: LIST
46001: LIST
46002: PUSH
46003: LD_INT 2
46005: PUSH
46006: LD_INT 34
46008: PUSH
46009: LD_INT 13
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 34
46018: PUSH
46019: LD_INT 52
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: LD_INT 34
46028: PUSH
46029: LD_INT 88
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PPUSH
46046: CALL_OW 72
46050: ST_TO_ADDR
// if cranes then
46051: LD_VAR 0 6
46055: IFFALSE 46117
// for j in cranes do
46057: LD_ADDR_VAR 0 3
46061: PUSH
46062: LD_VAR 0 6
46066: PUSH
46067: FOR_IN
46068: IFFALSE 46115
// if not IsInArea ( j , mc_parking [ i ] ) then
46070: LD_VAR 0 3
46074: PPUSH
46075: LD_EXP 124
46079: PUSH
46080: LD_VAR 0 2
46084: ARRAY
46085: PPUSH
46086: CALL_OW 308
46090: NOT
46091: IFFALSE 46113
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46093: LD_VAR 0 3
46097: PPUSH
46098: LD_EXP 124
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PPUSH
46109: CALL_OW 113
46113: GO 46067
46115: POP
46116: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
46117: LD_ADDR_EXP 102
46121: PUSH
46122: LD_EXP 102
46126: PPUSH
46127: LD_VAR 0 2
46131: PPUSH
46132: EMPTY
46133: PPUSH
46134: CALL_OW 1
46138: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
46139: LD_VAR 0 2
46143: PPUSH
46144: LD_INT 101
46146: PPUSH
46147: CALL 41007 0 2
// continue ;
46151: GO 45954
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
46153: LD_ADDR_EXP 106
46157: PUSH
46158: LD_EXP 106
46162: PPUSH
46163: LD_VAR 0 2
46167: PPUSH
46168: EMPTY
46169: PPUSH
46170: CALL_OW 1
46174: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46175: LD_VAR 0 2
46179: PPUSH
46180: LD_INT 103
46182: PPUSH
46183: CALL 41007 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46187: LD_ADDR_VAR 0 5
46191: PUSH
46192: LD_EXP 100
46196: PUSH
46197: LD_VAR 0 2
46201: ARRAY
46202: PUSH
46203: LD_EXP 129
46207: PUSH
46208: LD_VAR 0 2
46212: ARRAY
46213: UNION
46214: PPUSH
46215: LD_INT 2
46217: PUSH
46218: LD_INT 25
46220: PUSH
46221: LD_INT 2
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 25
46230: PUSH
46231: LD_INT 16
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: LIST
46242: PUSH
46243: EMPTY
46244: LIST
46245: PPUSH
46246: CALL_OW 72
46250: ST_TO_ADDR
// if mc_need_heal [ i ] then
46251: LD_EXP 103
46255: PUSH
46256: LD_VAR 0 2
46260: ARRAY
46261: IFFALSE 46305
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46263: LD_ADDR_VAR 0 5
46267: PUSH
46268: LD_VAR 0 5
46272: PUSH
46273: LD_EXP 103
46277: PUSH
46278: LD_VAR 0 2
46282: ARRAY
46283: PUSH
46284: LD_INT 1
46286: ARRAY
46287: PUSH
46288: LD_EXP 103
46292: PUSH
46293: LD_VAR 0 2
46297: ARRAY
46298: PUSH
46299: LD_INT 2
46301: ARRAY
46302: UNION
46303: DIFF
46304: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46305: LD_ADDR_VAR 0 6
46309: PUSH
46310: LD_EXP 119
46314: PUSH
46315: LD_VAR 0 2
46319: ARRAY
46320: PPUSH
46321: LD_INT 2
46323: PUSH
46324: LD_INT 34
46326: PUSH
46327: LD_INT 13
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 34
46336: PUSH
46337: LD_INT 52
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 34
46346: PUSH
46347: LD_INT 88
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: PPUSH
46360: CALL_OW 72
46364: ST_TO_ADDR
// if cranes then
46365: LD_VAR 0 6
46369: IFFALSE 46537
// begin for j in cranes do
46371: LD_ADDR_VAR 0 3
46375: PUSH
46376: LD_VAR 0 6
46380: PUSH
46381: FOR_IN
46382: IFFALSE 46535
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46384: LD_VAR 0 3
46388: PPUSH
46389: CALL_OW 256
46393: PUSH
46394: LD_INT 1000
46396: EQUAL
46397: PUSH
46398: LD_VAR 0 3
46402: PPUSH
46403: CALL_OW 314
46407: NOT
46408: AND
46409: IFFALSE 46475
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46411: LD_ADDR_VAR 0 8
46415: PUSH
46416: LD_EXP 101
46420: PUSH
46421: LD_VAR 0 2
46425: ARRAY
46426: PPUSH
46427: LD_VAR 0 3
46431: PPUSH
46432: CALL_OW 74
46436: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46437: LD_VAR 0 8
46441: PPUSH
46442: LD_INT 16
46444: PPUSH
46445: CALL 75244 0 2
46449: PUSH
46450: LD_INT 4
46452: ARRAY
46453: PUSH
46454: LD_INT 10
46456: LESS
46457: IFFALSE 46473
// ComRepairBuilding ( j , to_repair ) ;
46459: LD_VAR 0 3
46463: PPUSH
46464: LD_VAR 0 8
46468: PPUSH
46469: CALL_OW 130
// end else
46473: GO 46533
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46475: LD_VAR 0 3
46479: PPUSH
46480: CALL_OW 256
46484: PUSH
46485: LD_INT 500
46487: LESS
46488: PUSH
46489: LD_VAR 0 3
46493: PPUSH
46494: LD_EXP 124
46498: PUSH
46499: LD_VAR 0 2
46503: ARRAY
46504: PPUSH
46505: CALL_OW 308
46509: NOT
46510: AND
46511: IFFALSE 46533
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46513: LD_VAR 0 3
46517: PPUSH
46518: LD_EXP 124
46522: PUSH
46523: LD_VAR 0 2
46527: ARRAY
46528: PPUSH
46529: CALL_OW 113
// end ;
46533: GO 46381
46535: POP
46536: POP
// end ; if tmp > 3 then
46537: LD_VAR 0 5
46541: PUSH
46542: LD_INT 3
46544: GREATER
46545: IFFALSE 46565
// tmp := ShrinkArray ( tmp , 4 ) ;
46547: LD_ADDR_VAR 0 5
46551: PUSH
46552: LD_VAR 0 5
46556: PPUSH
46557: LD_INT 4
46559: PPUSH
46560: CALL 105274 0 2
46564: ST_TO_ADDR
// if not tmp then
46565: LD_VAR 0 5
46569: NOT
46570: IFFALSE 46574
// continue ;
46572: GO 45954
// for j in tmp do
46574: LD_ADDR_VAR 0 3
46578: PUSH
46579: LD_VAR 0 5
46583: PUSH
46584: FOR_IN
46585: IFFALSE 46844
// begin if IsInUnit ( j ) then
46587: LD_VAR 0 3
46591: PPUSH
46592: CALL_OW 310
46596: IFFALSE 46607
// ComExitBuilding ( j ) ;
46598: LD_VAR 0 3
46602: PPUSH
46603: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46607: LD_VAR 0 3
46611: PUSH
46612: LD_EXP 102
46616: PUSH
46617: LD_VAR 0 2
46621: ARRAY
46622: IN
46623: NOT
46624: IFFALSE 46682
// begin SetTag ( j , 101 ) ;
46626: LD_VAR 0 3
46630: PPUSH
46631: LD_INT 101
46633: PPUSH
46634: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46638: LD_ADDR_EXP 102
46642: PUSH
46643: LD_EXP 102
46647: PPUSH
46648: LD_VAR 0 2
46652: PUSH
46653: LD_EXP 102
46657: PUSH
46658: LD_VAR 0 2
46662: ARRAY
46663: PUSH
46664: LD_INT 1
46666: PLUS
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: PPUSH
46672: LD_VAR 0 3
46676: PPUSH
46677: CALL 72647 0 3
46681: ST_TO_ADDR
// end ; wait ( 1 ) ;
46682: LD_INT 1
46684: PPUSH
46685: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46689: LD_ADDR_VAR 0 7
46693: PUSH
46694: LD_EXP 101
46698: PUSH
46699: LD_VAR 0 2
46703: ARRAY
46704: ST_TO_ADDR
// if mc_scan [ i ] then
46705: LD_EXP 123
46709: PUSH
46710: LD_VAR 0 2
46714: ARRAY
46715: IFFALSE 46777
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46717: LD_ADDR_VAR 0 7
46721: PUSH
46722: LD_EXP 101
46726: PUSH
46727: LD_VAR 0 2
46731: ARRAY
46732: PPUSH
46733: LD_INT 3
46735: PUSH
46736: LD_INT 30
46738: PUSH
46739: LD_INT 32
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 30
46748: PUSH
46749: LD_INT 33
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 30
46758: PUSH
46759: LD_INT 31
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: PPUSH
46772: CALL_OW 72
46776: ST_TO_ADDR
// if not to_repair_tmp then
46777: LD_VAR 0 7
46781: NOT
46782: IFFALSE 46786
// continue ;
46784: GO 46584
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46786: LD_ADDR_VAR 0 8
46790: PUSH
46791: LD_VAR 0 7
46795: PPUSH
46796: LD_VAR 0 3
46800: PPUSH
46801: CALL_OW 74
46805: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46806: LD_VAR 0 8
46810: PPUSH
46811: LD_INT 16
46813: PPUSH
46814: CALL 75244 0 2
46818: PUSH
46819: LD_INT 4
46821: ARRAY
46822: PUSH
46823: LD_INT 14
46825: LESS
46826: IFFALSE 46842
// ComRepairBuilding ( j , to_repair ) ;
46828: LD_VAR 0 3
46832: PPUSH
46833: LD_VAR 0 8
46837: PPUSH
46838: CALL_OW 130
// end ;
46842: GO 46584
46844: POP
46845: POP
// end ;
46846: GO 45954
46848: POP
46849: POP
// end ;
46850: LD_VAR 0 1
46854: RET
// export function MC_Heal ; var i , j , tmp ; begin
46855: LD_INT 0
46857: PPUSH
46858: PPUSH
46859: PPUSH
46860: PPUSH
// if not mc_bases then
46861: LD_EXP 100
46865: NOT
46866: IFFALSE 46870
// exit ;
46868: GO 47272
// for i = 1 to mc_bases do
46870: LD_ADDR_VAR 0 2
46874: PUSH
46875: DOUBLE
46876: LD_INT 1
46878: DEC
46879: ST_TO_ADDR
46880: LD_EXP 100
46884: PUSH
46885: FOR_TO
46886: IFFALSE 47270
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46888: LD_EXP 103
46892: PUSH
46893: LD_VAR 0 2
46897: ARRAY
46898: PUSH
46899: LD_INT 1
46901: ARRAY
46902: NOT
46903: PUSH
46904: LD_EXP 103
46908: PUSH
46909: LD_VAR 0 2
46913: ARRAY
46914: PUSH
46915: LD_INT 2
46917: ARRAY
46918: NOT
46919: AND
46920: IFFALSE 46958
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46922: LD_ADDR_EXP 104
46926: PUSH
46927: LD_EXP 104
46931: PPUSH
46932: LD_VAR 0 2
46936: PPUSH
46937: EMPTY
46938: PPUSH
46939: CALL_OW 1
46943: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46944: LD_VAR 0 2
46948: PPUSH
46949: LD_INT 102
46951: PPUSH
46952: CALL 41007 0 2
// continue ;
46956: GO 46885
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46958: LD_ADDR_VAR 0 4
46962: PUSH
46963: LD_EXP 100
46967: PUSH
46968: LD_VAR 0 2
46972: ARRAY
46973: PPUSH
46974: LD_INT 25
46976: PUSH
46977: LD_INT 4
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: PPUSH
46984: CALL_OW 72
46988: ST_TO_ADDR
// if not tmp then
46989: LD_VAR 0 4
46993: NOT
46994: IFFALSE 46998
// continue ;
46996: GO 46885
// if mc_taming [ i ] then
46998: LD_EXP 131
47002: PUSH
47003: LD_VAR 0 2
47007: ARRAY
47008: IFFALSE 47032
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
47010: LD_ADDR_EXP 131
47014: PUSH
47015: LD_EXP 131
47019: PPUSH
47020: LD_VAR 0 2
47024: PPUSH
47025: EMPTY
47026: PPUSH
47027: CALL_OW 1
47031: ST_TO_ADDR
// for j in tmp do
47032: LD_ADDR_VAR 0 3
47036: PUSH
47037: LD_VAR 0 4
47041: PUSH
47042: FOR_IN
47043: IFFALSE 47266
// begin if IsInUnit ( j ) then
47045: LD_VAR 0 3
47049: PPUSH
47050: CALL_OW 310
47054: IFFALSE 47065
// ComExitBuilding ( j ) ;
47056: LD_VAR 0 3
47060: PPUSH
47061: CALL_OW 122
// if not j in mc_healers [ i ] then
47065: LD_VAR 0 3
47069: PUSH
47070: LD_EXP 104
47074: PUSH
47075: LD_VAR 0 2
47079: ARRAY
47080: IN
47081: NOT
47082: IFFALSE 47128
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
47084: LD_ADDR_EXP 104
47088: PUSH
47089: LD_EXP 104
47093: PPUSH
47094: LD_VAR 0 2
47098: PUSH
47099: LD_EXP 104
47103: PUSH
47104: LD_VAR 0 2
47108: ARRAY
47109: PUSH
47110: LD_INT 1
47112: PLUS
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PPUSH
47118: LD_VAR 0 3
47122: PPUSH
47123: CALL 72647 0 3
47127: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
47128: LD_VAR 0 3
47132: PPUSH
47133: CALL_OW 110
47137: PUSH
47138: LD_INT 102
47140: NONEQUAL
47141: IFFALSE 47155
// SetTag ( j , 102 ) ;
47143: LD_VAR 0 3
47147: PPUSH
47148: LD_INT 102
47150: PPUSH
47151: CALL_OW 109
// Wait ( 3 ) ;
47155: LD_INT 3
47157: PPUSH
47158: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
47162: LD_EXP 103
47166: PUSH
47167: LD_VAR 0 2
47171: ARRAY
47172: PUSH
47173: LD_INT 1
47175: ARRAY
47176: IFFALSE 47208
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47178: LD_VAR 0 3
47182: PPUSH
47183: LD_EXP 103
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: PUSH
47194: LD_INT 1
47196: ARRAY
47197: PUSH
47198: LD_INT 1
47200: ARRAY
47201: PPUSH
47202: CALL_OW 128
47206: GO 47264
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47208: LD_VAR 0 3
47212: PPUSH
47213: CALL_OW 314
47217: NOT
47218: PUSH
47219: LD_EXP 103
47223: PUSH
47224: LD_VAR 0 2
47228: ARRAY
47229: PUSH
47230: LD_INT 2
47232: ARRAY
47233: AND
47234: IFFALSE 47264
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47236: LD_VAR 0 3
47240: PPUSH
47241: LD_EXP 103
47245: PUSH
47246: LD_VAR 0 2
47250: ARRAY
47251: PUSH
47252: LD_INT 2
47254: ARRAY
47255: PUSH
47256: LD_INT 1
47258: ARRAY
47259: PPUSH
47260: CALL_OW 128
// end ;
47264: GO 47042
47266: POP
47267: POP
// end ;
47268: GO 46885
47270: POP
47271: POP
// end ;
47272: LD_VAR 0 1
47276: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47277: LD_INT 0
47279: PPUSH
47280: PPUSH
47281: PPUSH
47282: PPUSH
47283: PPUSH
47284: PPUSH
// if not mc_bases then
47285: LD_EXP 100
47289: NOT
47290: IFFALSE 47294
// exit ;
47292: GO 48457
// for i = 1 to mc_bases do
47294: LD_ADDR_VAR 0 2
47298: PUSH
47299: DOUBLE
47300: LD_INT 1
47302: DEC
47303: ST_TO_ADDR
47304: LD_EXP 100
47308: PUSH
47309: FOR_TO
47310: IFFALSE 48455
// begin if mc_scan [ i ] then
47312: LD_EXP 123
47316: PUSH
47317: LD_VAR 0 2
47321: ARRAY
47322: IFFALSE 47326
// continue ;
47324: GO 47309
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47326: LD_EXP 105
47330: PUSH
47331: LD_VAR 0 2
47335: ARRAY
47336: NOT
47337: PUSH
47338: LD_EXP 107
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: NOT
47349: AND
47350: PUSH
47351: LD_EXP 106
47355: PUSH
47356: LD_VAR 0 2
47360: ARRAY
47361: AND
47362: IFFALSE 47400
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47364: LD_ADDR_EXP 106
47368: PUSH
47369: LD_EXP 106
47373: PPUSH
47374: LD_VAR 0 2
47378: PPUSH
47379: EMPTY
47380: PPUSH
47381: CALL_OW 1
47385: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47386: LD_VAR 0 2
47390: PPUSH
47391: LD_INT 103
47393: PPUSH
47394: CALL 41007 0 2
// continue ;
47398: GO 47309
// end ; if mc_construct_list [ i ] then
47400: LD_EXP 107
47404: PUSH
47405: LD_VAR 0 2
47409: ARRAY
47410: IFFALSE 47630
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47412: LD_ADDR_VAR 0 5
47416: PUSH
47417: LD_EXP 100
47421: PUSH
47422: LD_VAR 0 2
47426: ARRAY
47427: PPUSH
47428: LD_INT 25
47430: PUSH
47431: LD_INT 2
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PPUSH
47438: CALL_OW 72
47442: PUSH
47443: LD_EXP 102
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: DIFF
47454: ST_TO_ADDR
// if not tmp then
47455: LD_VAR 0 5
47459: NOT
47460: IFFALSE 47464
// continue ;
47462: GO 47309
// for j in tmp do
47464: LD_ADDR_VAR 0 3
47468: PUSH
47469: LD_VAR 0 5
47473: PUSH
47474: FOR_IN
47475: IFFALSE 47626
// begin if not mc_builders [ i ] then
47477: LD_EXP 106
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: NOT
47488: IFFALSE 47546
// begin SetTag ( j , 103 ) ;
47490: LD_VAR 0 3
47494: PPUSH
47495: LD_INT 103
47497: PPUSH
47498: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47502: LD_ADDR_EXP 106
47506: PUSH
47507: LD_EXP 106
47511: PPUSH
47512: LD_VAR 0 2
47516: PUSH
47517: LD_EXP 106
47521: PUSH
47522: LD_VAR 0 2
47526: ARRAY
47527: PUSH
47528: LD_INT 1
47530: PLUS
47531: PUSH
47532: EMPTY
47533: LIST
47534: LIST
47535: PPUSH
47536: LD_VAR 0 3
47540: PPUSH
47541: CALL 72647 0 3
47545: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47546: LD_VAR 0 3
47550: PPUSH
47551: CALL_OW 310
47555: IFFALSE 47566
// ComExitBuilding ( j ) ;
47557: LD_VAR 0 3
47561: PPUSH
47562: CALL_OW 122
// wait ( 3 ) ;
47566: LD_INT 3
47568: PPUSH
47569: CALL_OW 67
// if not mc_construct_list [ i ] then
47573: LD_EXP 107
47577: PUSH
47578: LD_VAR 0 2
47582: ARRAY
47583: NOT
47584: IFFALSE 47588
// break ;
47586: GO 47626
// if not HasTask ( j ) then
47588: LD_VAR 0 3
47592: PPUSH
47593: CALL_OW 314
47597: NOT
47598: IFFALSE 47624
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47600: LD_VAR 0 3
47604: PPUSH
47605: LD_EXP 107
47609: PUSH
47610: LD_VAR 0 2
47614: ARRAY
47615: PUSH
47616: LD_INT 1
47618: ARRAY
47619: PPUSH
47620: CALL 75508 0 2
// end ;
47624: GO 47474
47626: POP
47627: POP
// end else
47628: GO 48453
// if mc_build_list [ i ] then
47630: LD_EXP 105
47634: PUSH
47635: LD_VAR 0 2
47639: ARRAY
47640: IFFALSE 48453
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47642: LD_EXP 105
47646: PUSH
47647: LD_VAR 0 2
47651: ARRAY
47652: PUSH
47653: LD_INT 1
47655: ARRAY
47656: PUSH
47657: LD_INT 1
47659: ARRAY
47660: PPUSH
47661: CALL 75332 0 1
47665: PUSH
47666: LD_EXP 100
47670: PUSH
47671: LD_VAR 0 2
47675: ARRAY
47676: PPUSH
47677: LD_INT 2
47679: PUSH
47680: LD_INT 30
47682: PUSH
47683: LD_INT 2
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: PUSH
47690: LD_INT 30
47692: PUSH
47693: LD_INT 3
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: PUSH
47700: EMPTY
47701: LIST
47702: LIST
47703: LIST
47704: PPUSH
47705: CALL_OW 72
47709: NOT
47710: AND
47711: IFFALSE 47816
// begin for j = 1 to mc_build_list [ i ] do
47713: LD_ADDR_VAR 0 3
47717: PUSH
47718: DOUBLE
47719: LD_INT 1
47721: DEC
47722: ST_TO_ADDR
47723: LD_EXP 105
47727: PUSH
47728: LD_VAR 0 2
47732: ARRAY
47733: PUSH
47734: FOR_TO
47735: IFFALSE 47814
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47737: LD_EXP 105
47741: PUSH
47742: LD_VAR 0 2
47746: ARRAY
47747: PUSH
47748: LD_VAR 0 3
47752: ARRAY
47753: PUSH
47754: LD_INT 1
47756: ARRAY
47757: PUSH
47758: LD_INT 2
47760: EQUAL
47761: IFFALSE 47812
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47763: LD_ADDR_EXP 105
47767: PUSH
47768: LD_EXP 105
47772: PPUSH
47773: LD_VAR 0 2
47777: PPUSH
47778: LD_EXP 105
47782: PUSH
47783: LD_VAR 0 2
47787: ARRAY
47788: PPUSH
47789: LD_VAR 0 3
47793: PPUSH
47794: LD_INT 1
47796: PPUSH
47797: LD_INT 0
47799: PPUSH
47800: CALL 72065 0 4
47804: PPUSH
47805: CALL_OW 1
47809: ST_TO_ADDR
// break ;
47810: GO 47814
// end ;
47812: GO 47734
47814: POP
47815: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47816: LD_ADDR_VAR 0 6
47820: PUSH
47821: LD_EXP 100
47825: PUSH
47826: LD_VAR 0 2
47830: ARRAY
47831: PPUSH
47832: LD_INT 2
47834: PUSH
47835: LD_INT 30
47837: PUSH
47838: LD_INT 0
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PUSH
47845: LD_INT 30
47847: PUSH
47848: LD_INT 1
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: EMPTY
47856: LIST
47857: LIST
47858: LIST
47859: PPUSH
47860: CALL_OW 72
47864: ST_TO_ADDR
// for k := 1 to depot do
47865: LD_ADDR_VAR 0 4
47869: PUSH
47870: DOUBLE
47871: LD_INT 1
47873: DEC
47874: ST_TO_ADDR
47875: LD_VAR 0 6
47879: PUSH
47880: FOR_TO
47881: IFFALSE 48451
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47883: LD_EXP 105
47887: PUSH
47888: LD_VAR 0 2
47892: ARRAY
47893: PUSH
47894: LD_INT 1
47896: ARRAY
47897: PUSH
47898: LD_INT 1
47900: ARRAY
47901: PUSH
47902: LD_INT 0
47904: EQUAL
47905: PUSH
47906: LD_VAR 0 6
47910: PUSH
47911: LD_VAR 0 4
47915: ARRAY
47916: PPUSH
47917: LD_EXP 105
47921: PUSH
47922: LD_VAR 0 2
47926: ARRAY
47927: PUSH
47928: LD_INT 1
47930: ARRAY
47931: PUSH
47932: LD_INT 1
47934: ARRAY
47935: PPUSH
47936: LD_EXP 105
47940: PUSH
47941: LD_VAR 0 2
47945: ARRAY
47946: PUSH
47947: LD_INT 1
47949: ARRAY
47950: PUSH
47951: LD_INT 2
47953: ARRAY
47954: PPUSH
47955: LD_EXP 105
47959: PUSH
47960: LD_VAR 0 2
47964: ARRAY
47965: PUSH
47966: LD_INT 1
47968: ARRAY
47969: PUSH
47970: LD_INT 3
47972: ARRAY
47973: PPUSH
47974: LD_EXP 105
47978: PUSH
47979: LD_VAR 0 2
47983: ARRAY
47984: PUSH
47985: LD_INT 1
47987: ARRAY
47988: PUSH
47989: LD_INT 4
47991: ARRAY
47992: PPUSH
47993: CALL 80744 0 5
47997: OR
47998: IFFALSE 48279
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48000: LD_ADDR_VAR 0 5
48004: PUSH
48005: LD_EXP 100
48009: PUSH
48010: LD_VAR 0 2
48014: ARRAY
48015: PPUSH
48016: LD_INT 25
48018: PUSH
48019: LD_INT 2
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PPUSH
48026: CALL_OW 72
48030: PUSH
48031: LD_EXP 102
48035: PUSH
48036: LD_VAR 0 2
48040: ARRAY
48041: DIFF
48042: ST_TO_ADDR
// if not tmp then
48043: LD_VAR 0 5
48047: NOT
48048: IFFALSE 48052
// continue ;
48050: GO 47880
// for j in tmp do
48052: LD_ADDR_VAR 0 3
48056: PUSH
48057: LD_VAR 0 5
48061: PUSH
48062: FOR_IN
48063: IFFALSE 48275
// begin if not mc_builders [ i ] then
48065: LD_EXP 106
48069: PUSH
48070: LD_VAR 0 2
48074: ARRAY
48075: NOT
48076: IFFALSE 48134
// begin SetTag ( j , 103 ) ;
48078: LD_VAR 0 3
48082: PPUSH
48083: LD_INT 103
48085: PPUSH
48086: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48090: LD_ADDR_EXP 106
48094: PUSH
48095: LD_EXP 106
48099: PPUSH
48100: LD_VAR 0 2
48104: PUSH
48105: LD_EXP 106
48109: PUSH
48110: LD_VAR 0 2
48114: ARRAY
48115: PUSH
48116: LD_INT 1
48118: PLUS
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PPUSH
48124: LD_VAR 0 3
48128: PPUSH
48129: CALL 72647 0 3
48133: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48134: LD_VAR 0 3
48138: PPUSH
48139: CALL_OW 310
48143: IFFALSE 48154
// ComExitBuilding ( j ) ;
48145: LD_VAR 0 3
48149: PPUSH
48150: CALL_OW 122
// wait ( 3 ) ;
48154: LD_INT 3
48156: PPUSH
48157: CALL_OW 67
// if not mc_build_list [ i ] then
48161: LD_EXP 105
48165: PUSH
48166: LD_VAR 0 2
48170: ARRAY
48171: NOT
48172: IFFALSE 48176
// break ;
48174: GO 48275
// if not HasTask ( j ) then
48176: LD_VAR 0 3
48180: PPUSH
48181: CALL_OW 314
48185: NOT
48186: IFFALSE 48273
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48188: LD_VAR 0 3
48192: PPUSH
48193: LD_EXP 105
48197: PUSH
48198: LD_VAR 0 2
48202: ARRAY
48203: PUSH
48204: LD_INT 1
48206: ARRAY
48207: PUSH
48208: LD_INT 1
48210: ARRAY
48211: PPUSH
48212: LD_EXP 105
48216: PUSH
48217: LD_VAR 0 2
48221: ARRAY
48222: PUSH
48223: LD_INT 1
48225: ARRAY
48226: PUSH
48227: LD_INT 2
48229: ARRAY
48230: PPUSH
48231: LD_EXP 105
48235: PUSH
48236: LD_VAR 0 2
48240: ARRAY
48241: PUSH
48242: LD_INT 1
48244: ARRAY
48245: PUSH
48246: LD_INT 3
48248: ARRAY
48249: PPUSH
48250: LD_EXP 105
48254: PUSH
48255: LD_VAR 0 2
48259: ARRAY
48260: PUSH
48261: LD_INT 1
48263: ARRAY
48264: PUSH
48265: LD_INT 4
48267: ARRAY
48268: PPUSH
48269: CALL_OW 145
// end ;
48273: GO 48062
48275: POP
48276: POP
// end else
48277: GO 48449
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48279: LD_EXP 100
48283: PUSH
48284: LD_VAR 0 2
48288: ARRAY
48289: PPUSH
48290: LD_EXP 105
48294: PUSH
48295: LD_VAR 0 2
48299: ARRAY
48300: PUSH
48301: LD_INT 1
48303: ARRAY
48304: PUSH
48305: LD_INT 1
48307: ARRAY
48308: PPUSH
48309: LD_EXP 105
48313: PUSH
48314: LD_VAR 0 2
48318: ARRAY
48319: PUSH
48320: LD_INT 1
48322: ARRAY
48323: PUSH
48324: LD_INT 2
48326: ARRAY
48327: PPUSH
48328: LD_EXP 105
48332: PUSH
48333: LD_VAR 0 2
48337: ARRAY
48338: PUSH
48339: LD_INT 1
48341: ARRAY
48342: PUSH
48343: LD_INT 3
48345: ARRAY
48346: PPUSH
48347: LD_EXP 105
48351: PUSH
48352: LD_VAR 0 2
48356: ARRAY
48357: PUSH
48358: LD_INT 1
48360: ARRAY
48361: PUSH
48362: LD_INT 4
48364: ARRAY
48365: PPUSH
48366: LD_EXP 100
48370: PUSH
48371: LD_VAR 0 2
48375: ARRAY
48376: PPUSH
48377: LD_INT 21
48379: PUSH
48380: LD_INT 3
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: PPUSH
48387: CALL_OW 72
48391: PPUSH
48392: EMPTY
48393: PPUSH
48394: CALL 79498 0 7
48398: NOT
48399: IFFALSE 48449
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48401: LD_ADDR_EXP 105
48405: PUSH
48406: LD_EXP 105
48410: PPUSH
48411: LD_VAR 0 2
48415: PPUSH
48416: LD_EXP 105
48420: PUSH
48421: LD_VAR 0 2
48425: ARRAY
48426: PPUSH
48427: LD_INT 1
48429: PPUSH
48430: LD_INT 1
48432: NEG
48433: PPUSH
48434: LD_INT 0
48436: PPUSH
48437: CALL 72065 0 4
48441: PPUSH
48442: CALL_OW 1
48446: ST_TO_ADDR
// continue ;
48447: GO 47880
// end ; end ;
48449: GO 47880
48451: POP
48452: POP
// end ; end ;
48453: GO 47309
48455: POP
48456: POP
// end ;
48457: LD_VAR 0 1
48461: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48462: LD_INT 0
48464: PPUSH
48465: PPUSH
48466: PPUSH
48467: PPUSH
48468: PPUSH
48469: PPUSH
// if not mc_bases then
48470: LD_EXP 100
48474: NOT
48475: IFFALSE 48479
// exit ;
48477: GO 48906
// for i = 1 to mc_bases do
48479: LD_ADDR_VAR 0 2
48483: PUSH
48484: DOUBLE
48485: LD_INT 1
48487: DEC
48488: ST_TO_ADDR
48489: LD_EXP 100
48493: PUSH
48494: FOR_TO
48495: IFFALSE 48904
// begin tmp := mc_build_upgrade [ i ] ;
48497: LD_ADDR_VAR 0 4
48501: PUSH
48502: LD_EXP 132
48506: PUSH
48507: LD_VAR 0 2
48511: ARRAY
48512: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48513: LD_ADDR_VAR 0 6
48517: PUSH
48518: LD_EXP 133
48522: PUSH
48523: LD_VAR 0 2
48527: ARRAY
48528: PPUSH
48529: LD_INT 2
48531: PUSH
48532: LD_INT 30
48534: PUSH
48535: LD_INT 6
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 30
48544: PUSH
48545: LD_INT 7
48547: PUSH
48548: EMPTY
48549: LIST
48550: LIST
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: LIST
48556: PPUSH
48557: CALL_OW 72
48561: ST_TO_ADDR
// if not tmp and not lab then
48562: LD_VAR 0 4
48566: NOT
48567: PUSH
48568: LD_VAR 0 6
48572: NOT
48573: AND
48574: IFFALSE 48578
// continue ;
48576: GO 48494
// if tmp then
48578: LD_VAR 0 4
48582: IFFALSE 48702
// for j in tmp do
48584: LD_ADDR_VAR 0 3
48588: PUSH
48589: LD_VAR 0 4
48593: PUSH
48594: FOR_IN
48595: IFFALSE 48700
// begin if UpgradeCost ( j ) then
48597: LD_VAR 0 3
48601: PPUSH
48602: CALL 79158 0 1
48606: IFFALSE 48698
// begin ComUpgrade ( j ) ;
48608: LD_VAR 0 3
48612: PPUSH
48613: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48617: LD_ADDR_EXP 132
48621: PUSH
48622: LD_EXP 132
48626: PPUSH
48627: LD_VAR 0 2
48631: PPUSH
48632: LD_EXP 132
48636: PUSH
48637: LD_VAR 0 2
48641: ARRAY
48642: PUSH
48643: LD_VAR 0 3
48647: DIFF
48648: PPUSH
48649: CALL_OW 1
48653: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48654: LD_ADDR_EXP 107
48658: PUSH
48659: LD_EXP 107
48663: PPUSH
48664: LD_VAR 0 2
48668: PUSH
48669: LD_EXP 107
48673: PUSH
48674: LD_VAR 0 2
48678: ARRAY
48679: PUSH
48680: LD_INT 1
48682: PLUS
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PPUSH
48688: LD_VAR 0 3
48692: PPUSH
48693: CALL 72647 0 3
48697: ST_TO_ADDR
// end ; end ;
48698: GO 48594
48700: POP
48701: POP
// if not lab or not mc_lab_upgrade [ i ] then
48702: LD_VAR 0 6
48706: NOT
48707: PUSH
48708: LD_EXP 134
48712: PUSH
48713: LD_VAR 0 2
48717: ARRAY
48718: NOT
48719: OR
48720: IFFALSE 48724
// continue ;
48722: GO 48494
// for j in lab do
48724: LD_ADDR_VAR 0 3
48728: PUSH
48729: LD_VAR 0 6
48733: PUSH
48734: FOR_IN
48735: IFFALSE 48900
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48737: LD_VAR 0 3
48741: PPUSH
48742: CALL_OW 266
48746: PUSH
48747: LD_INT 6
48749: PUSH
48750: LD_INT 7
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: IN
48757: PUSH
48758: LD_VAR 0 3
48762: PPUSH
48763: CALL_OW 461
48767: PUSH
48768: LD_INT 1
48770: NONEQUAL
48771: AND
48772: IFFALSE 48898
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48774: LD_VAR 0 3
48778: PPUSH
48779: LD_EXP 134
48783: PUSH
48784: LD_VAR 0 2
48788: ARRAY
48789: PUSH
48790: LD_INT 1
48792: ARRAY
48793: PPUSH
48794: CALL 79363 0 2
48798: IFFALSE 48898
// begin ComCancel ( j ) ;
48800: LD_VAR 0 3
48804: PPUSH
48805: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48809: LD_VAR 0 3
48813: PPUSH
48814: LD_EXP 134
48818: PUSH
48819: LD_VAR 0 2
48823: ARRAY
48824: PUSH
48825: LD_INT 1
48827: ARRAY
48828: PPUSH
48829: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48833: LD_VAR 0 3
48837: PUSH
48838: LD_EXP 107
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: IN
48849: NOT
48850: IFFALSE 48896
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48852: LD_ADDR_EXP 107
48856: PUSH
48857: LD_EXP 107
48861: PPUSH
48862: LD_VAR 0 2
48866: PUSH
48867: LD_EXP 107
48871: PUSH
48872: LD_VAR 0 2
48876: ARRAY
48877: PUSH
48878: LD_INT 1
48880: PLUS
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: PPUSH
48886: LD_VAR 0 3
48890: PPUSH
48891: CALL 72647 0 3
48895: ST_TO_ADDR
// break ;
48896: GO 48900
// end ; end ; end ;
48898: GO 48734
48900: POP
48901: POP
// end ;
48902: GO 48494
48904: POP
48905: POP
// end ;
48906: LD_VAR 0 1
48910: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48911: LD_INT 0
48913: PPUSH
48914: PPUSH
48915: PPUSH
48916: PPUSH
48917: PPUSH
48918: PPUSH
48919: PPUSH
48920: PPUSH
48921: PPUSH
// if not mc_bases then
48922: LD_EXP 100
48926: NOT
48927: IFFALSE 48931
// exit ;
48929: GO 49336
// for i = 1 to mc_bases do
48931: LD_ADDR_VAR 0 2
48935: PUSH
48936: DOUBLE
48937: LD_INT 1
48939: DEC
48940: ST_TO_ADDR
48941: LD_EXP 100
48945: PUSH
48946: FOR_TO
48947: IFFALSE 49334
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48949: LD_EXP 108
48953: PUSH
48954: LD_VAR 0 2
48958: ARRAY
48959: NOT
48960: PUSH
48961: LD_EXP 100
48965: PUSH
48966: LD_VAR 0 2
48970: ARRAY
48971: PPUSH
48972: LD_INT 30
48974: PUSH
48975: LD_INT 3
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: PPUSH
48982: CALL_OW 72
48986: NOT
48987: OR
48988: IFFALSE 48992
// continue ;
48990: GO 48946
// busy := false ;
48992: LD_ADDR_VAR 0 8
48996: PUSH
48997: LD_INT 0
48999: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49000: LD_ADDR_VAR 0 4
49004: PUSH
49005: LD_EXP 100
49009: PUSH
49010: LD_VAR 0 2
49014: ARRAY
49015: PPUSH
49016: LD_INT 30
49018: PUSH
49019: LD_INT 3
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PPUSH
49026: CALL_OW 72
49030: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
49031: LD_ADDR_VAR 0 6
49035: PUSH
49036: LD_EXP 108
49040: PUSH
49041: LD_VAR 0 2
49045: ARRAY
49046: PPUSH
49047: LD_INT 2
49049: PUSH
49050: LD_INT 30
49052: PUSH
49053: LD_INT 32
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PUSH
49060: LD_INT 30
49062: PUSH
49063: LD_INT 33
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: LIST
49074: PPUSH
49075: CALL_OW 72
49079: ST_TO_ADDR
// if not t then
49080: LD_VAR 0 6
49084: NOT
49085: IFFALSE 49089
// continue ;
49087: GO 48946
// for j in tmp do
49089: LD_ADDR_VAR 0 3
49093: PUSH
49094: LD_VAR 0 4
49098: PUSH
49099: FOR_IN
49100: IFFALSE 49130
// if not BuildingStatus ( j ) = bs_idle then
49102: LD_VAR 0 3
49106: PPUSH
49107: CALL_OW 461
49111: PUSH
49112: LD_INT 2
49114: EQUAL
49115: NOT
49116: IFFALSE 49128
// begin busy := true ;
49118: LD_ADDR_VAR 0 8
49122: PUSH
49123: LD_INT 1
49125: ST_TO_ADDR
// break ;
49126: GO 49130
// end ;
49128: GO 49099
49130: POP
49131: POP
// if busy then
49132: LD_VAR 0 8
49136: IFFALSE 49140
// continue ;
49138: GO 48946
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
49140: LD_ADDR_VAR 0 7
49144: PUSH
49145: LD_VAR 0 6
49149: PPUSH
49150: LD_INT 35
49152: PUSH
49153: LD_INT 0
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PPUSH
49160: CALL_OW 72
49164: ST_TO_ADDR
// if tw then
49165: LD_VAR 0 7
49169: IFFALSE 49246
// begin tw := tw [ 1 ] ;
49171: LD_ADDR_VAR 0 7
49175: PUSH
49176: LD_VAR 0 7
49180: PUSH
49181: LD_INT 1
49183: ARRAY
49184: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49185: LD_ADDR_VAR 0 9
49189: PUSH
49190: LD_VAR 0 7
49194: PPUSH
49195: LD_EXP 125
49199: PUSH
49200: LD_VAR 0 2
49204: ARRAY
49205: PPUSH
49206: CALL 77655 0 2
49210: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49211: LD_EXP 139
49215: PUSH
49216: LD_VAR 0 2
49220: ARRAY
49221: IFFALSE 49244
// if not weapon in mc_allowed_tower_weapons [ i ] then
49223: LD_VAR 0 9
49227: PUSH
49228: LD_EXP 139
49232: PUSH
49233: LD_VAR 0 2
49237: ARRAY
49238: IN
49239: NOT
49240: IFFALSE 49244
// continue ;
49242: GO 48946
// end else
49244: GO 49309
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49246: LD_ADDR_VAR 0 5
49250: PUSH
49251: LD_EXP 108
49255: PUSH
49256: LD_VAR 0 2
49260: ARRAY
49261: PPUSH
49262: LD_VAR 0 4
49266: PPUSH
49267: CALL 104507 0 2
49271: ST_TO_ADDR
// if not tmp2 then
49272: LD_VAR 0 5
49276: NOT
49277: IFFALSE 49281
// continue ;
49279: GO 48946
// tw := tmp2 [ 1 ] ;
49281: LD_ADDR_VAR 0 7
49285: PUSH
49286: LD_VAR 0 5
49290: PUSH
49291: LD_INT 1
49293: ARRAY
49294: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49295: LD_ADDR_VAR 0 9
49299: PUSH
49300: LD_VAR 0 5
49304: PUSH
49305: LD_INT 2
49307: ARRAY
49308: ST_TO_ADDR
// end ; if not weapon then
49309: LD_VAR 0 9
49313: NOT
49314: IFFALSE 49318
// continue ;
49316: GO 48946
// ComPlaceWeapon ( tw , weapon ) ;
49318: LD_VAR 0 7
49322: PPUSH
49323: LD_VAR 0 9
49327: PPUSH
49328: CALL_OW 148
// end ;
49332: GO 48946
49334: POP
49335: POP
// end ;
49336: LD_VAR 0 1
49340: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49341: LD_INT 0
49343: PPUSH
49344: PPUSH
49345: PPUSH
49346: PPUSH
49347: PPUSH
49348: PPUSH
49349: PPUSH
// if not mc_bases then
49350: LD_EXP 100
49354: NOT
49355: IFFALSE 49359
// exit ;
49357: GO 50127
// for i = 1 to mc_bases do
49359: LD_ADDR_VAR 0 2
49363: PUSH
49364: DOUBLE
49365: LD_INT 1
49367: DEC
49368: ST_TO_ADDR
49369: LD_EXP 100
49373: PUSH
49374: FOR_TO
49375: IFFALSE 50125
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49377: LD_EXP 113
49381: PUSH
49382: LD_VAR 0 2
49386: ARRAY
49387: NOT
49388: PUSH
49389: LD_EXP 113
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: PUSH
49400: LD_EXP 114
49404: PUSH
49405: LD_VAR 0 2
49409: ARRAY
49410: EQUAL
49411: OR
49412: PUSH
49413: LD_EXP 123
49417: PUSH
49418: LD_VAR 0 2
49422: ARRAY
49423: OR
49424: IFFALSE 49428
// continue ;
49426: GO 49374
// if mc_miners [ i ] then
49428: LD_EXP 114
49432: PUSH
49433: LD_VAR 0 2
49437: ARRAY
49438: IFFALSE 49812
// begin for j = mc_miners [ i ] downto 1 do
49440: LD_ADDR_VAR 0 3
49444: PUSH
49445: DOUBLE
49446: LD_EXP 114
49450: PUSH
49451: LD_VAR 0 2
49455: ARRAY
49456: INC
49457: ST_TO_ADDR
49458: LD_INT 1
49460: PUSH
49461: FOR_DOWNTO
49462: IFFALSE 49810
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49464: LD_EXP 114
49468: PUSH
49469: LD_VAR 0 2
49473: ARRAY
49474: PUSH
49475: LD_VAR 0 3
49479: ARRAY
49480: PPUSH
49481: CALL_OW 301
49485: PUSH
49486: LD_EXP 114
49490: PUSH
49491: LD_VAR 0 2
49495: ARRAY
49496: PUSH
49497: LD_VAR 0 3
49501: ARRAY
49502: PPUSH
49503: CALL_OW 257
49507: PUSH
49508: LD_INT 1
49510: NONEQUAL
49511: OR
49512: IFFALSE 49575
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49514: LD_ADDR_VAR 0 5
49518: PUSH
49519: LD_EXP 114
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PUSH
49530: LD_EXP 114
49534: PUSH
49535: LD_VAR 0 2
49539: ARRAY
49540: PUSH
49541: LD_VAR 0 3
49545: ARRAY
49546: DIFF
49547: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49548: LD_ADDR_EXP 114
49552: PUSH
49553: LD_EXP 114
49557: PPUSH
49558: LD_VAR 0 2
49562: PPUSH
49563: LD_VAR 0 5
49567: PPUSH
49568: CALL_OW 1
49572: ST_TO_ADDR
// continue ;
49573: GO 49461
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49575: LD_EXP 114
49579: PUSH
49580: LD_VAR 0 2
49584: ARRAY
49585: PUSH
49586: LD_VAR 0 3
49590: ARRAY
49591: PPUSH
49592: CALL_OW 257
49596: PUSH
49597: LD_INT 1
49599: EQUAL
49600: PUSH
49601: LD_EXP 114
49605: PUSH
49606: LD_VAR 0 2
49610: ARRAY
49611: PUSH
49612: LD_VAR 0 3
49616: ARRAY
49617: PPUSH
49618: CALL_OW 459
49622: NOT
49623: AND
49624: PUSH
49625: LD_EXP 114
49629: PUSH
49630: LD_VAR 0 2
49634: ARRAY
49635: PUSH
49636: LD_VAR 0 3
49640: ARRAY
49641: PPUSH
49642: CALL_OW 314
49646: NOT
49647: AND
49648: IFFALSE 49808
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49650: LD_EXP 114
49654: PUSH
49655: LD_VAR 0 2
49659: ARRAY
49660: PUSH
49661: LD_VAR 0 3
49665: ARRAY
49666: PPUSH
49667: CALL_OW 310
49671: IFFALSE 49694
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49673: LD_EXP 114
49677: PUSH
49678: LD_VAR 0 2
49682: ARRAY
49683: PUSH
49684: LD_VAR 0 3
49688: ARRAY
49689: PPUSH
49690: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49694: LD_EXP 114
49698: PUSH
49699: LD_VAR 0 2
49703: ARRAY
49704: PUSH
49705: LD_VAR 0 3
49709: ARRAY
49710: PPUSH
49711: CALL_OW 314
49715: NOT
49716: IFFALSE 49808
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49718: LD_ADDR_VAR 0 7
49722: PUSH
49723: LD_INT 1
49725: PPUSH
49726: LD_EXP 113
49730: PUSH
49731: LD_VAR 0 2
49735: ARRAY
49736: PPUSH
49737: CALL_OW 12
49741: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49742: LD_EXP 114
49746: PUSH
49747: LD_VAR 0 2
49751: ARRAY
49752: PUSH
49753: LD_VAR 0 3
49757: ARRAY
49758: PPUSH
49759: LD_EXP 113
49763: PUSH
49764: LD_VAR 0 2
49768: ARRAY
49769: PUSH
49770: LD_VAR 0 7
49774: ARRAY
49775: PUSH
49776: LD_INT 1
49778: ARRAY
49779: PPUSH
49780: LD_EXP 113
49784: PUSH
49785: LD_VAR 0 2
49789: ARRAY
49790: PUSH
49791: LD_VAR 0 7
49795: ARRAY
49796: PUSH
49797: LD_INT 2
49799: ARRAY
49800: PPUSH
49801: LD_INT 0
49803: PPUSH
49804: CALL_OW 193
// end ; end ; end ;
49808: GO 49461
49810: POP
49811: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49812: LD_ADDR_VAR 0 5
49816: PUSH
49817: LD_EXP 100
49821: PUSH
49822: LD_VAR 0 2
49826: ARRAY
49827: PPUSH
49828: LD_INT 2
49830: PUSH
49831: LD_INT 30
49833: PUSH
49834: LD_INT 4
49836: PUSH
49837: EMPTY
49838: LIST
49839: LIST
49840: PUSH
49841: LD_INT 30
49843: PUSH
49844: LD_INT 5
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: PUSH
49851: LD_INT 30
49853: PUSH
49854: LD_INT 32
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: PPUSH
49867: CALL_OW 72
49871: ST_TO_ADDR
// if not tmp then
49872: LD_VAR 0 5
49876: NOT
49877: IFFALSE 49881
// continue ;
49879: GO 49374
// list := [ ] ;
49881: LD_ADDR_VAR 0 6
49885: PUSH
49886: EMPTY
49887: ST_TO_ADDR
// for j in tmp do
49888: LD_ADDR_VAR 0 3
49892: PUSH
49893: LD_VAR 0 5
49897: PUSH
49898: FOR_IN
49899: IFFALSE 49968
// begin for k in UnitsInside ( j ) do
49901: LD_ADDR_VAR 0 4
49905: PUSH
49906: LD_VAR 0 3
49910: PPUSH
49911: CALL_OW 313
49915: PUSH
49916: FOR_IN
49917: IFFALSE 49964
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49919: LD_VAR 0 4
49923: PPUSH
49924: CALL_OW 257
49928: PUSH
49929: LD_INT 1
49931: EQUAL
49932: PUSH
49933: LD_VAR 0 4
49937: PPUSH
49938: CALL_OW 459
49942: NOT
49943: AND
49944: IFFALSE 49962
// list := list ^ k ;
49946: LD_ADDR_VAR 0 6
49950: PUSH
49951: LD_VAR 0 6
49955: PUSH
49956: LD_VAR 0 4
49960: ADD
49961: ST_TO_ADDR
49962: GO 49916
49964: POP
49965: POP
// end ;
49966: GO 49898
49968: POP
49969: POP
// list := list diff mc_miners [ i ] ;
49970: LD_ADDR_VAR 0 6
49974: PUSH
49975: LD_VAR 0 6
49979: PUSH
49980: LD_EXP 114
49984: PUSH
49985: LD_VAR 0 2
49989: ARRAY
49990: DIFF
49991: ST_TO_ADDR
// if not list then
49992: LD_VAR 0 6
49996: NOT
49997: IFFALSE 50001
// continue ;
49999: GO 49374
// k := mc_mines [ i ] - mc_miners [ i ] ;
50001: LD_ADDR_VAR 0 4
50005: PUSH
50006: LD_EXP 113
50010: PUSH
50011: LD_VAR 0 2
50015: ARRAY
50016: PUSH
50017: LD_EXP 114
50021: PUSH
50022: LD_VAR 0 2
50026: ARRAY
50027: MINUS
50028: ST_TO_ADDR
// if k > list then
50029: LD_VAR 0 4
50033: PUSH
50034: LD_VAR 0 6
50038: GREATER
50039: IFFALSE 50051
// k := list ;
50041: LD_ADDR_VAR 0 4
50045: PUSH
50046: LD_VAR 0 6
50050: ST_TO_ADDR
// for j = 1 to k do
50051: LD_ADDR_VAR 0 3
50055: PUSH
50056: DOUBLE
50057: LD_INT 1
50059: DEC
50060: ST_TO_ADDR
50061: LD_VAR 0 4
50065: PUSH
50066: FOR_TO
50067: IFFALSE 50121
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
50069: LD_ADDR_EXP 114
50073: PUSH
50074: LD_EXP 114
50078: PPUSH
50079: LD_VAR 0 2
50083: PUSH
50084: LD_EXP 114
50088: PUSH
50089: LD_VAR 0 2
50093: ARRAY
50094: PUSH
50095: LD_INT 1
50097: PLUS
50098: PUSH
50099: EMPTY
50100: LIST
50101: LIST
50102: PPUSH
50103: LD_VAR 0 6
50107: PUSH
50108: LD_VAR 0 3
50112: ARRAY
50113: PPUSH
50114: CALL 72647 0 3
50118: ST_TO_ADDR
50119: GO 50066
50121: POP
50122: POP
// end ;
50123: GO 49374
50125: POP
50126: POP
// end ;
50127: LD_VAR 0 1
50131: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
50132: LD_INT 0
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
50138: PPUSH
50139: PPUSH
50140: PPUSH
50141: PPUSH
50142: PPUSH
50143: PPUSH
50144: PPUSH
// if not mc_bases then
50145: LD_EXP 100
50149: NOT
50150: IFFALSE 50154
// exit ;
50152: GO 51977
// for i = 1 to mc_bases do
50154: LD_ADDR_VAR 0 2
50158: PUSH
50159: DOUBLE
50160: LD_INT 1
50162: DEC
50163: ST_TO_ADDR
50164: LD_EXP 100
50168: PUSH
50169: FOR_TO
50170: IFFALSE 51975
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
50172: LD_EXP 100
50176: PUSH
50177: LD_VAR 0 2
50181: ARRAY
50182: NOT
50183: PUSH
50184: LD_EXP 107
50188: PUSH
50189: LD_VAR 0 2
50193: ARRAY
50194: OR
50195: IFFALSE 50199
// continue ;
50197: GO 50169
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50199: LD_EXP 116
50203: PUSH
50204: LD_VAR 0 2
50208: ARRAY
50209: NOT
50210: PUSH
50211: LD_EXP 117
50215: PUSH
50216: LD_VAR 0 2
50220: ARRAY
50221: AND
50222: IFFALSE 50260
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50224: LD_ADDR_EXP 117
50228: PUSH
50229: LD_EXP 117
50233: PPUSH
50234: LD_VAR 0 2
50238: PPUSH
50239: EMPTY
50240: PPUSH
50241: CALL_OW 1
50245: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50246: LD_VAR 0 2
50250: PPUSH
50251: LD_INT 107
50253: PPUSH
50254: CALL 41007 0 2
// continue ;
50258: GO 50169
// end ; target := [ ] ;
50260: LD_ADDR_VAR 0 7
50264: PUSH
50265: EMPTY
50266: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50267: LD_ADDR_VAR 0 6
50271: PUSH
50272: LD_EXP 100
50276: PUSH
50277: LD_VAR 0 2
50281: ARRAY
50282: PUSH
50283: LD_INT 1
50285: ARRAY
50286: PPUSH
50287: CALL_OW 255
50291: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50292: LD_ADDR_VAR 0 9
50296: PUSH
50297: LD_EXP 100
50301: PUSH
50302: LD_VAR 0 2
50306: ARRAY
50307: PPUSH
50308: LD_INT 2
50310: PUSH
50311: LD_INT 30
50313: PUSH
50314: LD_INT 0
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PUSH
50321: LD_INT 30
50323: PUSH
50324: LD_INT 1
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: EMPTY
50332: LIST
50333: LIST
50334: LIST
50335: PPUSH
50336: CALL_OW 72
50340: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50341: LD_ADDR_VAR 0 3
50345: PUSH
50346: DOUBLE
50347: LD_EXP 116
50351: PUSH
50352: LD_VAR 0 2
50356: ARRAY
50357: INC
50358: ST_TO_ADDR
50359: LD_INT 1
50361: PUSH
50362: FOR_DOWNTO
50363: IFFALSE 50608
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50365: LD_EXP 116
50369: PUSH
50370: LD_VAR 0 2
50374: ARRAY
50375: PUSH
50376: LD_VAR 0 3
50380: ARRAY
50381: PUSH
50382: LD_INT 2
50384: ARRAY
50385: PPUSH
50386: LD_EXP 116
50390: PUSH
50391: LD_VAR 0 2
50395: ARRAY
50396: PUSH
50397: LD_VAR 0 3
50401: ARRAY
50402: PUSH
50403: LD_INT 3
50405: ARRAY
50406: PPUSH
50407: CALL_OW 488
50411: PUSH
50412: LD_EXP 116
50416: PUSH
50417: LD_VAR 0 2
50421: ARRAY
50422: PUSH
50423: LD_VAR 0 3
50427: ARRAY
50428: PUSH
50429: LD_INT 2
50431: ARRAY
50432: PPUSH
50433: LD_EXP 116
50437: PUSH
50438: LD_VAR 0 2
50442: ARRAY
50443: PUSH
50444: LD_VAR 0 3
50448: ARRAY
50449: PUSH
50450: LD_INT 3
50452: ARRAY
50453: PPUSH
50454: CALL_OW 284
50458: PUSH
50459: LD_INT 0
50461: EQUAL
50462: AND
50463: IFFALSE 50518
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50465: LD_ADDR_VAR 0 5
50469: PUSH
50470: LD_EXP 116
50474: PUSH
50475: LD_VAR 0 2
50479: ARRAY
50480: PPUSH
50481: LD_VAR 0 3
50485: PPUSH
50486: CALL_OW 3
50490: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50491: LD_ADDR_EXP 116
50495: PUSH
50496: LD_EXP 116
50500: PPUSH
50501: LD_VAR 0 2
50505: PPUSH
50506: LD_VAR 0 5
50510: PPUSH
50511: CALL_OW 1
50515: ST_TO_ADDR
// continue ;
50516: GO 50362
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50518: LD_VAR 0 6
50522: PPUSH
50523: LD_EXP 116
50527: PUSH
50528: LD_VAR 0 2
50532: ARRAY
50533: PUSH
50534: LD_VAR 0 3
50538: ARRAY
50539: PUSH
50540: LD_INT 2
50542: ARRAY
50543: PPUSH
50544: LD_EXP 116
50548: PUSH
50549: LD_VAR 0 2
50553: ARRAY
50554: PUSH
50555: LD_VAR 0 3
50559: ARRAY
50560: PUSH
50561: LD_INT 3
50563: ARRAY
50564: PPUSH
50565: LD_INT 30
50567: PPUSH
50568: CALL 73543 0 4
50572: PUSH
50573: LD_INT 4
50575: ARRAY
50576: PUSH
50577: LD_INT 0
50579: EQUAL
50580: IFFALSE 50606
// begin target := mc_crates [ i ] [ j ] ;
50582: LD_ADDR_VAR 0 7
50586: PUSH
50587: LD_EXP 116
50591: PUSH
50592: LD_VAR 0 2
50596: ARRAY
50597: PUSH
50598: LD_VAR 0 3
50602: ARRAY
50603: ST_TO_ADDR
// break ;
50604: GO 50608
// end ; end ;
50606: GO 50362
50608: POP
50609: POP
// if not target then
50610: LD_VAR 0 7
50614: NOT
50615: IFFALSE 50619
// continue ;
50617: GO 50169
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50619: LD_ADDR_VAR 0 8
50623: PUSH
50624: LD_EXP 119
50628: PUSH
50629: LD_VAR 0 2
50633: ARRAY
50634: PPUSH
50635: LD_INT 2
50637: PUSH
50638: LD_INT 3
50640: PUSH
50641: LD_INT 58
50643: PUSH
50644: EMPTY
50645: LIST
50646: PUSH
50647: EMPTY
50648: LIST
50649: LIST
50650: PUSH
50651: LD_INT 61
50653: PUSH
50654: EMPTY
50655: LIST
50656: PUSH
50657: LD_INT 33
50659: PUSH
50660: LD_INT 5
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: PUSH
50667: LD_INT 33
50669: PUSH
50670: LD_INT 3
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: EMPTY
50678: LIST
50679: LIST
50680: LIST
50681: LIST
50682: LIST
50683: PUSH
50684: LD_INT 2
50686: PUSH
50687: LD_INT 34
50689: PUSH
50690: LD_INT 32
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PUSH
50697: LD_INT 34
50699: PUSH
50700: LD_INT 51
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: PUSH
50707: LD_INT 34
50709: PUSH
50710: LD_INT 12
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: LIST
50721: LIST
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PPUSH
50727: CALL_OW 72
50731: ST_TO_ADDR
// if not cargo then
50732: LD_VAR 0 8
50736: NOT
50737: IFFALSE 51443
// begin if mc_crates_collector [ i ] < 5 then
50739: LD_EXP 117
50743: PUSH
50744: LD_VAR 0 2
50748: ARRAY
50749: PUSH
50750: LD_INT 5
50752: LESS
50753: IFFALSE 51119
// begin if mc_ape [ i ] then
50755: LD_EXP 129
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: IFFALSE 50812
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50767: LD_ADDR_VAR 0 5
50771: PUSH
50772: LD_EXP 129
50776: PUSH
50777: LD_VAR 0 2
50781: ARRAY
50782: PPUSH
50783: LD_INT 25
50785: PUSH
50786: LD_INT 16
50788: PUSH
50789: EMPTY
50790: LIST
50791: LIST
50792: PUSH
50793: LD_INT 24
50795: PUSH
50796: LD_INT 750
50798: PUSH
50799: EMPTY
50800: LIST
50801: LIST
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PPUSH
50807: CALL_OW 72
50811: ST_TO_ADDR
// if not tmp then
50812: LD_VAR 0 5
50816: NOT
50817: IFFALSE 50864
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50819: LD_ADDR_VAR 0 5
50823: PUSH
50824: LD_EXP 100
50828: PUSH
50829: LD_VAR 0 2
50833: ARRAY
50834: PPUSH
50835: LD_INT 25
50837: PUSH
50838: LD_INT 2
50840: PUSH
50841: EMPTY
50842: LIST
50843: LIST
50844: PUSH
50845: LD_INT 24
50847: PUSH
50848: LD_INT 750
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: EMPTY
50856: LIST
50857: LIST
50858: PPUSH
50859: CALL_OW 72
50863: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50864: LD_EXP 129
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: PUSH
50875: LD_EXP 100
50879: PUSH
50880: LD_VAR 0 2
50884: ARRAY
50885: PPUSH
50886: LD_INT 25
50888: PUSH
50889: LD_INT 2
50891: PUSH
50892: EMPTY
50893: LIST
50894: LIST
50895: PUSH
50896: LD_INT 24
50898: PUSH
50899: LD_INT 750
50901: PUSH
50902: EMPTY
50903: LIST
50904: LIST
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PPUSH
50910: CALL_OW 72
50914: AND
50915: PUSH
50916: LD_VAR 0 5
50920: PUSH
50921: LD_INT 5
50923: LESS
50924: AND
50925: IFFALSE 51007
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50927: LD_ADDR_VAR 0 3
50931: PUSH
50932: LD_EXP 100
50936: PUSH
50937: LD_VAR 0 2
50941: ARRAY
50942: PPUSH
50943: LD_INT 25
50945: PUSH
50946: LD_INT 2
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: PUSH
50953: LD_INT 24
50955: PUSH
50956: LD_INT 750
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PPUSH
50967: CALL_OW 72
50971: PUSH
50972: FOR_IN
50973: IFFALSE 51005
// begin tmp := tmp union j ;
50975: LD_ADDR_VAR 0 5
50979: PUSH
50980: LD_VAR 0 5
50984: PUSH
50985: LD_VAR 0 3
50989: UNION
50990: ST_TO_ADDR
// if tmp >= 5 then
50991: LD_VAR 0 5
50995: PUSH
50996: LD_INT 5
50998: GREATEREQUAL
50999: IFFALSE 51003
// break ;
51001: GO 51005
// end ;
51003: GO 50972
51005: POP
51006: POP
// end ; if not tmp then
51007: LD_VAR 0 5
51011: NOT
51012: IFFALSE 51016
// continue ;
51014: GO 50169
// for j in tmp do
51016: LD_ADDR_VAR 0 3
51020: PUSH
51021: LD_VAR 0 5
51025: PUSH
51026: FOR_IN
51027: IFFALSE 51117
// if not GetTag ( j ) then
51029: LD_VAR 0 3
51033: PPUSH
51034: CALL_OW 110
51038: NOT
51039: IFFALSE 51115
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
51041: LD_ADDR_EXP 117
51045: PUSH
51046: LD_EXP 117
51050: PPUSH
51051: LD_VAR 0 2
51055: PUSH
51056: LD_EXP 117
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PUSH
51067: LD_INT 1
51069: PLUS
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PPUSH
51075: LD_VAR 0 3
51079: PPUSH
51080: CALL 72647 0 3
51084: ST_TO_ADDR
// SetTag ( j , 107 ) ;
51085: LD_VAR 0 3
51089: PPUSH
51090: LD_INT 107
51092: PPUSH
51093: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
51097: LD_EXP 117
51101: PUSH
51102: LD_VAR 0 2
51106: ARRAY
51107: PUSH
51108: LD_INT 5
51110: GREATEREQUAL
51111: IFFALSE 51115
// break ;
51113: GO 51117
// end ;
51115: GO 51026
51117: POP
51118: POP
// end ; if mc_crates_collector [ i ] and target then
51119: LD_EXP 117
51123: PUSH
51124: LD_VAR 0 2
51128: ARRAY
51129: PUSH
51130: LD_VAR 0 7
51134: AND
51135: IFFALSE 51441
// begin if mc_crates_collector [ i ] < target [ 1 ] then
51137: LD_EXP 117
51141: PUSH
51142: LD_VAR 0 2
51146: ARRAY
51147: PUSH
51148: LD_VAR 0 7
51152: PUSH
51153: LD_INT 1
51155: ARRAY
51156: LESS
51157: IFFALSE 51177
// tmp := mc_crates_collector [ i ] else
51159: LD_ADDR_VAR 0 5
51163: PUSH
51164: LD_EXP 117
51168: PUSH
51169: LD_VAR 0 2
51173: ARRAY
51174: ST_TO_ADDR
51175: GO 51191
// tmp := target [ 1 ] ;
51177: LD_ADDR_VAR 0 5
51181: PUSH
51182: LD_VAR 0 7
51186: PUSH
51187: LD_INT 1
51189: ARRAY
51190: ST_TO_ADDR
// k := 0 ;
51191: LD_ADDR_VAR 0 4
51195: PUSH
51196: LD_INT 0
51198: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51199: LD_ADDR_VAR 0 3
51203: PUSH
51204: LD_EXP 117
51208: PUSH
51209: LD_VAR 0 2
51213: ARRAY
51214: PUSH
51215: FOR_IN
51216: IFFALSE 51439
// begin k := k + 1 ;
51218: LD_ADDR_VAR 0 4
51222: PUSH
51223: LD_VAR 0 4
51227: PUSH
51228: LD_INT 1
51230: PLUS
51231: ST_TO_ADDR
// if k > tmp then
51232: LD_VAR 0 4
51236: PUSH
51237: LD_VAR 0 5
51241: GREATER
51242: IFFALSE 51246
// break ;
51244: GO 51439
// if not GetClass ( j ) in [ 2 , 16 ] then
51246: LD_VAR 0 3
51250: PPUSH
51251: CALL_OW 257
51255: PUSH
51256: LD_INT 2
51258: PUSH
51259: LD_INT 16
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: IN
51266: NOT
51267: IFFALSE 51320
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51269: LD_ADDR_EXP 117
51273: PUSH
51274: LD_EXP 117
51278: PPUSH
51279: LD_VAR 0 2
51283: PPUSH
51284: LD_EXP 117
51288: PUSH
51289: LD_VAR 0 2
51293: ARRAY
51294: PUSH
51295: LD_VAR 0 3
51299: DIFF
51300: PPUSH
51301: CALL_OW 1
51305: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51306: LD_VAR 0 3
51310: PPUSH
51311: LD_INT 0
51313: PPUSH
51314: CALL_OW 109
// continue ;
51318: GO 51215
// end ; if IsInUnit ( j ) then
51320: LD_VAR 0 3
51324: PPUSH
51325: CALL_OW 310
51329: IFFALSE 51340
// ComExitBuilding ( j ) ;
51331: LD_VAR 0 3
51335: PPUSH
51336: CALL_OW 122
// wait ( 3 ) ;
51340: LD_INT 3
51342: PPUSH
51343: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51347: LD_VAR 0 3
51351: PPUSH
51352: CALL_OW 314
51356: PUSH
51357: LD_VAR 0 6
51361: PPUSH
51362: LD_VAR 0 7
51366: PUSH
51367: LD_INT 2
51369: ARRAY
51370: PPUSH
51371: LD_VAR 0 7
51375: PUSH
51376: LD_INT 3
51378: ARRAY
51379: PPUSH
51380: LD_INT 30
51382: PPUSH
51383: CALL 73543 0 4
51387: PUSH
51388: LD_INT 4
51390: ARRAY
51391: AND
51392: IFFALSE 51410
// ComStandNearbyBuilding ( j , depot ) else
51394: LD_VAR 0 3
51398: PPUSH
51399: LD_VAR 0 9
51403: PPUSH
51404: CALL 69074 0 2
51408: GO 51437
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51410: LD_VAR 0 3
51414: PPUSH
51415: LD_VAR 0 7
51419: PUSH
51420: LD_INT 2
51422: ARRAY
51423: PPUSH
51424: LD_VAR 0 7
51428: PUSH
51429: LD_INT 3
51431: ARRAY
51432: PPUSH
51433: CALL_OW 117
// end ;
51437: GO 51215
51439: POP
51440: POP
// end ; end else
51441: GO 51973
// begin for j in cargo do
51443: LD_ADDR_VAR 0 3
51447: PUSH
51448: LD_VAR 0 8
51452: PUSH
51453: FOR_IN
51454: IFFALSE 51971
// begin if GetTag ( j ) <> 0 then
51456: LD_VAR 0 3
51460: PPUSH
51461: CALL_OW 110
51465: PUSH
51466: LD_INT 0
51468: NONEQUAL
51469: IFFALSE 51473
// continue ;
51471: GO 51453
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51473: LD_VAR 0 3
51477: PPUSH
51478: CALL_OW 256
51482: PUSH
51483: LD_INT 1000
51485: LESS
51486: PUSH
51487: LD_VAR 0 3
51491: PPUSH
51492: LD_EXP 124
51496: PUSH
51497: LD_VAR 0 2
51501: ARRAY
51502: PPUSH
51503: CALL_OW 308
51507: NOT
51508: AND
51509: IFFALSE 51531
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51511: LD_VAR 0 3
51515: PPUSH
51516: LD_EXP 124
51520: PUSH
51521: LD_VAR 0 2
51525: ARRAY
51526: PPUSH
51527: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51531: LD_VAR 0 3
51535: PPUSH
51536: CALL_OW 256
51540: PUSH
51541: LD_INT 1000
51543: LESS
51544: PUSH
51545: LD_VAR 0 3
51549: PPUSH
51550: LD_EXP 124
51554: PUSH
51555: LD_VAR 0 2
51559: ARRAY
51560: PPUSH
51561: CALL_OW 308
51565: AND
51566: IFFALSE 51570
// continue ;
51568: GO 51453
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51570: LD_VAR 0 3
51574: PPUSH
51575: CALL_OW 262
51579: PUSH
51580: LD_INT 2
51582: EQUAL
51583: PUSH
51584: LD_VAR 0 3
51588: PPUSH
51589: CALL_OW 261
51593: PUSH
51594: LD_INT 15
51596: LESS
51597: AND
51598: IFFALSE 51602
// continue ;
51600: GO 51453
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51602: LD_VAR 0 3
51606: PPUSH
51607: CALL_OW 262
51611: PUSH
51612: LD_INT 1
51614: EQUAL
51615: PUSH
51616: LD_VAR 0 3
51620: PPUSH
51621: CALL_OW 261
51625: PUSH
51626: LD_INT 10
51628: LESS
51629: AND
51630: IFFALSE 51910
// begin if not depot then
51632: LD_VAR 0 9
51636: NOT
51637: IFFALSE 51641
// continue ;
51639: GO 51453
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51641: LD_VAR 0 3
51645: PPUSH
51646: LD_VAR 0 9
51650: PPUSH
51651: LD_VAR 0 3
51655: PPUSH
51656: CALL_OW 74
51660: PPUSH
51661: CALL_OW 296
51665: PUSH
51666: LD_INT 6
51668: LESS
51669: IFFALSE 51685
// SetFuel ( j , 100 ) else
51671: LD_VAR 0 3
51675: PPUSH
51676: LD_INT 100
51678: PPUSH
51679: CALL_OW 240
51683: GO 51910
// if GetFuel ( j ) = 0 then
51685: LD_VAR 0 3
51689: PPUSH
51690: CALL_OW 261
51694: PUSH
51695: LD_INT 0
51697: EQUAL
51698: IFFALSE 51910
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51700: LD_ADDR_EXP 119
51704: PUSH
51705: LD_EXP 119
51709: PPUSH
51710: LD_VAR 0 2
51714: PPUSH
51715: LD_EXP 119
51719: PUSH
51720: LD_VAR 0 2
51724: ARRAY
51725: PUSH
51726: LD_VAR 0 3
51730: DIFF
51731: PPUSH
51732: CALL_OW 1
51736: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51737: LD_VAR 0 3
51741: PPUSH
51742: CALL_OW 263
51746: PUSH
51747: LD_INT 1
51749: EQUAL
51750: IFFALSE 51766
// ComExitVehicle ( IsInUnit ( j ) ) ;
51752: LD_VAR 0 3
51756: PPUSH
51757: CALL_OW 310
51761: PPUSH
51762: CALL_OW 121
// if GetControl ( j ) = control_remote then
51766: LD_VAR 0 3
51770: PPUSH
51771: CALL_OW 263
51775: PUSH
51776: LD_INT 2
51778: EQUAL
51779: IFFALSE 51790
// ComUnlink ( j ) ;
51781: LD_VAR 0 3
51785: PPUSH
51786: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51790: LD_ADDR_VAR 0 10
51794: PUSH
51795: LD_VAR 0 2
51799: PPUSH
51800: LD_INT 3
51802: PPUSH
51803: CALL 61577 0 2
51807: ST_TO_ADDR
// if fac then
51808: LD_VAR 0 10
51812: IFFALSE 51908
// begin for k in fac do
51814: LD_ADDR_VAR 0 4
51818: PUSH
51819: LD_VAR 0 10
51823: PUSH
51824: FOR_IN
51825: IFFALSE 51906
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51827: LD_ADDR_VAR 0 11
51831: PUSH
51832: LD_VAR 0 10
51836: PPUSH
51837: LD_VAR 0 3
51841: PPUSH
51842: CALL_OW 265
51846: PPUSH
51847: LD_VAR 0 3
51851: PPUSH
51852: CALL_OW 262
51856: PPUSH
51857: LD_VAR 0 3
51861: PPUSH
51862: CALL_OW 263
51866: PPUSH
51867: LD_VAR 0 3
51871: PPUSH
51872: CALL_OW 264
51876: PPUSH
51877: CALL 70145 0 5
51881: ST_TO_ADDR
// if components then
51882: LD_VAR 0 11
51886: IFFALSE 51904
// begin MC_InsertProduceList ( i , components ) ;
51888: LD_VAR 0 2
51892: PPUSH
51893: LD_VAR 0 11
51897: PPUSH
51898: CALL 61122 0 2
// break ;
51902: GO 51906
// end ; end ;
51904: GO 51824
51906: POP
51907: POP
// end ; continue ;
51908: GO 51453
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51910: LD_VAR 0 3
51914: PPUSH
51915: LD_INT 1
51917: PPUSH
51918: CALL_OW 289
51922: PUSH
51923: LD_INT 100
51925: LESS
51926: PUSH
51927: LD_VAR 0 3
51931: PPUSH
51932: CALL_OW 314
51936: NOT
51937: AND
51938: IFFALSE 51967
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51940: LD_VAR 0 3
51944: PPUSH
51945: LD_VAR 0 7
51949: PUSH
51950: LD_INT 2
51952: ARRAY
51953: PPUSH
51954: LD_VAR 0 7
51958: PUSH
51959: LD_INT 3
51961: ARRAY
51962: PPUSH
51963: CALL_OW 117
// break ;
51967: GO 51971
// end ;
51969: GO 51453
51971: POP
51972: POP
// end ; end ;
51973: GO 50169
51975: POP
51976: POP
// end ;
51977: LD_VAR 0 1
51981: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51982: LD_INT 0
51984: PPUSH
51985: PPUSH
51986: PPUSH
51987: PPUSH
// if not mc_bases then
51988: LD_EXP 100
51992: NOT
51993: IFFALSE 51997
// exit ;
51995: GO 52158
// for i = 1 to mc_bases do
51997: LD_ADDR_VAR 0 2
52001: PUSH
52002: DOUBLE
52003: LD_INT 1
52005: DEC
52006: ST_TO_ADDR
52007: LD_EXP 100
52011: PUSH
52012: FOR_TO
52013: IFFALSE 52156
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
52015: LD_ADDR_VAR 0 4
52019: PUSH
52020: LD_EXP 119
52024: PUSH
52025: LD_VAR 0 2
52029: ARRAY
52030: PUSH
52031: LD_EXP 122
52035: PUSH
52036: LD_VAR 0 2
52040: ARRAY
52041: UNION
52042: PPUSH
52043: LD_INT 33
52045: PUSH
52046: LD_INT 2
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: PPUSH
52053: CALL_OW 72
52057: ST_TO_ADDR
// if tmp then
52058: LD_VAR 0 4
52062: IFFALSE 52154
// for j in tmp do
52064: LD_ADDR_VAR 0 3
52068: PUSH
52069: LD_VAR 0 4
52073: PUSH
52074: FOR_IN
52075: IFFALSE 52152
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
52077: LD_VAR 0 3
52081: PPUSH
52082: CALL_OW 312
52086: NOT
52087: PUSH
52088: LD_VAR 0 3
52092: PPUSH
52093: CALL_OW 256
52097: PUSH
52098: LD_INT 250
52100: GREATEREQUAL
52101: AND
52102: IFFALSE 52115
// Connect ( j ) else
52104: LD_VAR 0 3
52108: PPUSH
52109: CALL 75616 0 1
52113: GO 52150
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
52115: LD_VAR 0 3
52119: PPUSH
52120: CALL_OW 256
52124: PUSH
52125: LD_INT 250
52127: LESS
52128: PUSH
52129: LD_VAR 0 3
52133: PPUSH
52134: CALL_OW 312
52138: AND
52139: IFFALSE 52150
// ComUnlink ( j ) ;
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 136
52150: GO 52074
52152: POP
52153: POP
// end ;
52154: GO 52012
52156: POP
52157: POP
// end ;
52158: LD_VAR 0 1
52162: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
52163: LD_INT 0
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
52169: PPUSH
// if not mc_bases then
52170: LD_EXP 100
52174: NOT
52175: IFFALSE 52179
// exit ;
52177: GO 52624
// for i = 1 to mc_bases do
52179: LD_ADDR_VAR 0 2
52183: PUSH
52184: DOUBLE
52185: LD_INT 1
52187: DEC
52188: ST_TO_ADDR
52189: LD_EXP 100
52193: PUSH
52194: FOR_TO
52195: IFFALSE 52622
// begin if not mc_produce [ i ] then
52197: LD_EXP 121
52201: PUSH
52202: LD_VAR 0 2
52206: ARRAY
52207: NOT
52208: IFFALSE 52212
// continue ;
52210: GO 52194
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52212: LD_ADDR_VAR 0 5
52216: PUSH
52217: LD_EXP 100
52221: PUSH
52222: LD_VAR 0 2
52226: ARRAY
52227: PPUSH
52228: LD_INT 30
52230: PUSH
52231: LD_INT 3
52233: PUSH
52234: EMPTY
52235: LIST
52236: LIST
52237: PPUSH
52238: CALL_OW 72
52242: ST_TO_ADDR
// if not fac then
52243: LD_VAR 0 5
52247: NOT
52248: IFFALSE 52252
// continue ;
52250: GO 52194
// for j in fac do
52252: LD_ADDR_VAR 0 3
52256: PUSH
52257: LD_VAR 0 5
52261: PUSH
52262: FOR_IN
52263: IFFALSE 52618
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52265: LD_VAR 0 3
52269: PPUSH
52270: CALL_OW 461
52274: PUSH
52275: LD_INT 2
52277: NONEQUAL
52278: PUSH
52279: LD_VAR 0 3
52283: PPUSH
52284: LD_INT 15
52286: PPUSH
52287: CALL 75244 0 2
52291: PUSH
52292: LD_INT 4
52294: ARRAY
52295: OR
52296: IFFALSE 52300
// continue ;
52298: GO 52262
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52300: LD_VAR 0 3
52304: PPUSH
52305: LD_EXP 121
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: PUSH
52316: LD_INT 1
52318: ARRAY
52319: PUSH
52320: LD_INT 1
52322: ARRAY
52323: PPUSH
52324: LD_EXP 121
52328: PUSH
52329: LD_VAR 0 2
52333: ARRAY
52334: PUSH
52335: LD_INT 1
52337: ARRAY
52338: PUSH
52339: LD_INT 2
52341: ARRAY
52342: PPUSH
52343: LD_EXP 121
52347: PUSH
52348: LD_VAR 0 2
52352: ARRAY
52353: PUSH
52354: LD_INT 1
52356: ARRAY
52357: PUSH
52358: LD_INT 3
52360: ARRAY
52361: PPUSH
52362: LD_EXP 121
52366: PUSH
52367: LD_VAR 0 2
52371: ARRAY
52372: PUSH
52373: LD_INT 1
52375: ARRAY
52376: PUSH
52377: LD_INT 4
52379: ARRAY
52380: PPUSH
52381: CALL_OW 448
52385: PUSH
52386: LD_VAR 0 3
52390: PPUSH
52391: LD_EXP 121
52395: PUSH
52396: LD_VAR 0 2
52400: ARRAY
52401: PUSH
52402: LD_INT 1
52404: ARRAY
52405: PUSH
52406: LD_INT 1
52408: ARRAY
52409: PUSH
52410: LD_EXP 121
52414: PUSH
52415: LD_VAR 0 2
52419: ARRAY
52420: PUSH
52421: LD_INT 1
52423: ARRAY
52424: PUSH
52425: LD_INT 2
52427: ARRAY
52428: PUSH
52429: LD_EXP 121
52433: PUSH
52434: LD_VAR 0 2
52438: ARRAY
52439: PUSH
52440: LD_INT 1
52442: ARRAY
52443: PUSH
52444: LD_INT 3
52446: ARRAY
52447: PUSH
52448: LD_EXP 121
52452: PUSH
52453: LD_VAR 0 2
52457: ARRAY
52458: PUSH
52459: LD_INT 1
52461: ARRAY
52462: PUSH
52463: LD_INT 4
52465: ARRAY
52466: PUSH
52467: EMPTY
52468: LIST
52469: LIST
52470: LIST
52471: LIST
52472: PPUSH
52473: CALL 79011 0 2
52477: AND
52478: IFFALSE 52616
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52480: LD_VAR 0 3
52484: PPUSH
52485: LD_EXP 121
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PUSH
52496: LD_INT 1
52498: ARRAY
52499: PUSH
52500: LD_INT 1
52502: ARRAY
52503: PPUSH
52504: LD_EXP 121
52508: PUSH
52509: LD_VAR 0 2
52513: ARRAY
52514: PUSH
52515: LD_INT 1
52517: ARRAY
52518: PUSH
52519: LD_INT 2
52521: ARRAY
52522: PPUSH
52523: LD_EXP 121
52527: PUSH
52528: LD_VAR 0 2
52532: ARRAY
52533: PUSH
52534: LD_INT 1
52536: ARRAY
52537: PUSH
52538: LD_INT 3
52540: ARRAY
52541: PPUSH
52542: LD_EXP 121
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: PUSH
52553: LD_INT 1
52555: ARRAY
52556: PUSH
52557: LD_INT 4
52559: ARRAY
52560: PPUSH
52561: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52565: LD_ADDR_VAR 0 4
52569: PUSH
52570: LD_EXP 121
52574: PUSH
52575: LD_VAR 0 2
52579: ARRAY
52580: PPUSH
52581: LD_INT 1
52583: PPUSH
52584: CALL_OW 3
52588: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52589: LD_ADDR_EXP 121
52593: PUSH
52594: LD_EXP 121
52598: PPUSH
52599: LD_VAR 0 2
52603: PPUSH
52604: LD_VAR 0 4
52608: PPUSH
52609: CALL_OW 1
52613: ST_TO_ADDR
// break ;
52614: GO 52618
// end ; end ;
52616: GO 52262
52618: POP
52619: POP
// end ;
52620: GO 52194
52622: POP
52623: POP
// end ;
52624: LD_VAR 0 1
52628: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52629: LD_INT 0
52631: PPUSH
52632: PPUSH
52633: PPUSH
// if not mc_bases then
52634: LD_EXP 100
52638: NOT
52639: IFFALSE 52643
// exit ;
52641: GO 52732
// for i = 1 to mc_bases do
52643: LD_ADDR_VAR 0 2
52647: PUSH
52648: DOUBLE
52649: LD_INT 1
52651: DEC
52652: ST_TO_ADDR
52653: LD_EXP 100
52657: PUSH
52658: FOR_TO
52659: IFFALSE 52730
// begin if mc_attack [ i ] then
52661: LD_EXP 120
52665: PUSH
52666: LD_VAR 0 2
52670: ARRAY
52671: IFFALSE 52728
// begin tmp := mc_attack [ i ] [ 1 ] ;
52673: LD_ADDR_VAR 0 3
52677: PUSH
52678: LD_EXP 120
52682: PUSH
52683: LD_VAR 0 2
52687: ARRAY
52688: PUSH
52689: LD_INT 1
52691: ARRAY
52692: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52693: LD_ADDR_EXP 120
52697: PUSH
52698: LD_EXP 120
52702: PPUSH
52703: LD_VAR 0 2
52707: PPUSH
52708: EMPTY
52709: PPUSH
52710: CALL_OW 1
52714: ST_TO_ADDR
// Attack ( tmp ) ;
52715: LD_VAR 0 3
52719: PPUSH
52720: CALL 128850 0 1
// exit ;
52724: POP
52725: POP
52726: GO 52732
// end ; end ;
52728: GO 52658
52730: POP
52731: POP
// end ;
52732: LD_VAR 0 1
52736: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52737: LD_INT 0
52739: PPUSH
52740: PPUSH
52741: PPUSH
52742: PPUSH
52743: PPUSH
52744: PPUSH
52745: PPUSH
// if not mc_bases then
52746: LD_EXP 100
52750: NOT
52751: IFFALSE 52755
// exit ;
52753: GO 53612
// for i = 1 to mc_bases do
52755: LD_ADDR_VAR 0 2
52759: PUSH
52760: DOUBLE
52761: LD_INT 1
52763: DEC
52764: ST_TO_ADDR
52765: LD_EXP 100
52769: PUSH
52770: FOR_TO
52771: IFFALSE 53610
// begin if not mc_bases [ i ] then
52773: LD_EXP 100
52777: PUSH
52778: LD_VAR 0 2
52782: ARRAY
52783: NOT
52784: IFFALSE 52788
// continue ;
52786: GO 52770
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52788: LD_ADDR_VAR 0 7
52792: PUSH
52793: LD_EXP 100
52797: PUSH
52798: LD_VAR 0 2
52802: ARRAY
52803: PUSH
52804: LD_INT 1
52806: ARRAY
52807: PPUSH
52808: CALL 69296 0 1
52812: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52813: LD_ADDR_EXP 123
52817: PUSH
52818: LD_EXP 123
52822: PPUSH
52823: LD_VAR 0 2
52827: PPUSH
52828: LD_EXP 100
52832: PUSH
52833: LD_VAR 0 2
52837: ARRAY
52838: PUSH
52839: LD_INT 1
52841: ARRAY
52842: PPUSH
52843: CALL_OW 255
52847: PPUSH
52848: LD_EXP 125
52852: PUSH
52853: LD_VAR 0 2
52857: ARRAY
52858: PPUSH
52859: CALL 69261 0 2
52863: PPUSH
52864: CALL_OW 1
52868: ST_TO_ADDR
// if not mc_scan [ i ] then
52869: LD_EXP 123
52873: PUSH
52874: LD_VAR 0 2
52878: ARRAY
52879: NOT
52880: IFFALSE 53058
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52882: LD_ADDR_EXP 143
52886: PUSH
52887: LD_EXP 143
52891: PPUSH
52892: LD_VAR 0 2
52896: PPUSH
52897: LD_INT 0
52899: PPUSH
52900: CALL_OW 1
52904: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52905: LD_ADDR_VAR 0 4
52909: PUSH
52910: LD_EXP 100
52914: PUSH
52915: LD_VAR 0 2
52919: ARRAY
52920: PPUSH
52921: LD_INT 2
52923: PUSH
52924: LD_INT 25
52926: PUSH
52927: LD_INT 5
52929: PUSH
52930: EMPTY
52931: LIST
52932: LIST
52933: PUSH
52934: LD_INT 25
52936: PUSH
52937: LD_INT 8
52939: PUSH
52940: EMPTY
52941: LIST
52942: LIST
52943: PUSH
52944: LD_INT 25
52946: PUSH
52947: LD_INT 9
52949: PUSH
52950: EMPTY
52951: LIST
52952: LIST
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: LIST
52958: LIST
52959: PPUSH
52960: CALL_OW 72
52964: ST_TO_ADDR
// if not tmp then
52965: LD_VAR 0 4
52969: NOT
52970: IFFALSE 52974
// continue ;
52972: GO 52770
// for j in tmp do
52974: LD_ADDR_VAR 0 3
52978: PUSH
52979: LD_VAR 0 4
52983: PUSH
52984: FOR_IN
52985: IFFALSE 53056
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52987: LD_VAR 0 3
52991: PPUSH
52992: CALL_OW 310
52996: PPUSH
52997: CALL_OW 266
53001: PUSH
53002: LD_INT 5
53004: EQUAL
53005: PUSH
53006: LD_VAR 0 3
53010: PPUSH
53011: CALL_OW 257
53015: PUSH
53016: LD_INT 1
53018: EQUAL
53019: AND
53020: PUSH
53021: LD_VAR 0 3
53025: PPUSH
53026: CALL_OW 459
53030: NOT
53031: AND
53032: PUSH
53033: LD_VAR 0 7
53037: AND
53038: IFFALSE 53054
// ComChangeProfession ( j , class ) ;
53040: LD_VAR 0 3
53044: PPUSH
53045: LD_VAR 0 7
53049: PPUSH
53050: CALL_OW 123
53054: GO 52984
53056: POP
53057: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
53058: LD_EXP 123
53062: PUSH
53063: LD_VAR 0 2
53067: ARRAY
53068: PUSH
53069: LD_EXP 143
53073: PUSH
53074: LD_VAR 0 2
53078: ARRAY
53079: NOT
53080: AND
53081: PUSH
53082: LD_EXP 122
53086: PUSH
53087: LD_VAR 0 2
53091: ARRAY
53092: NOT
53093: AND
53094: PUSH
53095: LD_EXP 100
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: PPUSH
53106: LD_INT 50
53108: PUSH
53109: EMPTY
53110: LIST
53111: PUSH
53112: LD_INT 2
53114: PUSH
53115: LD_INT 30
53117: PUSH
53118: LD_INT 32
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PUSH
53125: LD_INT 30
53127: PUSH
53128: LD_INT 33
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: PUSH
53135: LD_INT 30
53137: PUSH
53138: LD_INT 4
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: PUSH
53145: LD_INT 30
53147: PUSH
53148: LD_INT 5
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: LIST
53161: PUSH
53162: EMPTY
53163: LIST
53164: LIST
53165: PPUSH
53166: CALL_OW 72
53170: PUSH
53171: LD_INT 4
53173: LESS
53174: PUSH
53175: LD_EXP 100
53179: PUSH
53180: LD_VAR 0 2
53184: ARRAY
53185: PPUSH
53186: LD_INT 3
53188: PUSH
53189: LD_INT 24
53191: PUSH
53192: LD_INT 1000
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PUSH
53199: EMPTY
53200: LIST
53201: LIST
53202: PUSH
53203: LD_INT 2
53205: PUSH
53206: LD_INT 30
53208: PUSH
53209: LD_INT 0
53211: PUSH
53212: EMPTY
53213: LIST
53214: LIST
53215: PUSH
53216: LD_INT 30
53218: PUSH
53219: LD_INT 1
53221: PUSH
53222: EMPTY
53223: LIST
53224: LIST
53225: PUSH
53226: EMPTY
53227: LIST
53228: LIST
53229: LIST
53230: PUSH
53231: EMPTY
53232: LIST
53233: LIST
53234: PPUSH
53235: CALL_OW 72
53239: OR
53240: AND
53241: IFFALSE 53492
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53243: LD_ADDR_EXP 143
53247: PUSH
53248: LD_EXP 143
53252: PPUSH
53253: LD_VAR 0 2
53257: PPUSH
53258: LD_INT 1
53260: PPUSH
53261: CALL_OW 1
53265: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53266: LD_ADDR_VAR 0 4
53270: PUSH
53271: LD_EXP 100
53275: PUSH
53276: LD_VAR 0 2
53280: ARRAY
53281: PPUSH
53282: LD_INT 2
53284: PUSH
53285: LD_INT 25
53287: PUSH
53288: LD_INT 1
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: LD_INT 25
53297: PUSH
53298: LD_INT 5
53300: PUSH
53301: EMPTY
53302: LIST
53303: LIST
53304: PUSH
53305: LD_INT 25
53307: PUSH
53308: LD_INT 8
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: PUSH
53315: LD_INT 25
53317: PUSH
53318: LD_INT 9
53320: PUSH
53321: EMPTY
53322: LIST
53323: LIST
53324: PUSH
53325: EMPTY
53326: LIST
53327: LIST
53328: LIST
53329: LIST
53330: LIST
53331: PPUSH
53332: CALL_OW 72
53336: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53337: LD_ADDR_VAR 0 4
53341: PUSH
53342: LD_VAR 0 4
53346: PUSH
53347: LD_VAR 0 4
53351: PPUSH
53352: LD_INT 18
53354: PPUSH
53355: CALL 102533 0 2
53359: DIFF
53360: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53361: LD_VAR 0 4
53365: NOT
53366: PUSH
53367: LD_EXP 100
53371: PUSH
53372: LD_VAR 0 2
53376: ARRAY
53377: PPUSH
53378: LD_INT 2
53380: PUSH
53381: LD_INT 30
53383: PUSH
53384: LD_INT 4
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 30
53393: PUSH
53394: LD_INT 5
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: PUSH
53401: EMPTY
53402: LIST
53403: LIST
53404: LIST
53405: PPUSH
53406: CALL_OW 72
53410: NOT
53411: AND
53412: IFFALSE 53474
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53414: LD_ADDR_VAR 0 4
53418: PUSH
53419: LD_EXP 100
53423: PUSH
53424: LD_VAR 0 2
53428: ARRAY
53429: PPUSH
53430: LD_INT 2
53432: PUSH
53433: LD_INT 25
53435: PUSH
53436: LD_INT 2
53438: PUSH
53439: EMPTY
53440: LIST
53441: LIST
53442: PUSH
53443: LD_INT 25
53445: PUSH
53446: LD_INT 3
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: LD_INT 25
53455: PUSH
53456: LD_INT 4
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: LIST
53467: LIST
53468: PPUSH
53469: CALL_OW 72
53473: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53474: LD_VAR 0 2
53478: PPUSH
53479: LD_VAR 0 4
53483: PPUSH
53484: CALL 133559 0 2
// exit ;
53488: POP
53489: POP
53490: GO 53612
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53492: LD_EXP 123
53496: PUSH
53497: LD_VAR 0 2
53501: ARRAY
53502: PUSH
53503: LD_EXP 143
53507: PUSH
53508: LD_VAR 0 2
53512: ARRAY
53513: NOT
53514: AND
53515: PUSH
53516: LD_EXP 122
53520: PUSH
53521: LD_VAR 0 2
53525: ARRAY
53526: AND
53527: IFFALSE 53608
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53529: LD_ADDR_EXP 143
53533: PUSH
53534: LD_EXP 143
53538: PPUSH
53539: LD_VAR 0 2
53543: PPUSH
53544: LD_INT 1
53546: PPUSH
53547: CALL_OW 1
53551: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53552: LD_ADDR_VAR 0 4
53556: PUSH
53557: LD_EXP 122
53561: PUSH
53562: LD_VAR 0 2
53566: ARRAY
53567: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53568: LD_ADDR_EXP 122
53572: PUSH
53573: LD_EXP 122
53577: PPUSH
53578: LD_VAR 0 2
53582: PPUSH
53583: EMPTY
53584: PPUSH
53585: CALL_OW 1
53589: ST_TO_ADDR
// Defend ( i , tmp ) ;
53590: LD_VAR 0 2
53594: PPUSH
53595: LD_VAR 0 4
53599: PPUSH
53600: CALL 134155 0 2
// exit ;
53604: POP
53605: POP
53606: GO 53612
// end ; end ;
53608: GO 52770
53610: POP
53611: POP
// end ;
53612: LD_VAR 0 1
53616: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53617: LD_INT 0
53619: PPUSH
53620: PPUSH
53621: PPUSH
53622: PPUSH
53623: PPUSH
53624: PPUSH
53625: PPUSH
53626: PPUSH
53627: PPUSH
53628: PPUSH
53629: PPUSH
// if not mc_bases then
53630: LD_EXP 100
53634: NOT
53635: IFFALSE 53639
// exit ;
53637: GO 54726
// for i = 1 to mc_bases do
53639: LD_ADDR_VAR 0 2
53643: PUSH
53644: DOUBLE
53645: LD_INT 1
53647: DEC
53648: ST_TO_ADDR
53649: LD_EXP 100
53653: PUSH
53654: FOR_TO
53655: IFFALSE 54724
// begin tmp := mc_lab [ i ] ;
53657: LD_ADDR_VAR 0 6
53661: PUSH
53662: LD_EXP 133
53666: PUSH
53667: LD_VAR 0 2
53671: ARRAY
53672: ST_TO_ADDR
// if not tmp then
53673: LD_VAR 0 6
53677: NOT
53678: IFFALSE 53682
// continue ;
53680: GO 53654
// idle_lab := 0 ;
53682: LD_ADDR_VAR 0 11
53686: PUSH
53687: LD_INT 0
53689: ST_TO_ADDR
// for j in tmp do
53690: LD_ADDR_VAR 0 3
53694: PUSH
53695: LD_VAR 0 6
53699: PUSH
53700: FOR_IN
53701: IFFALSE 54720
// begin researching := false ;
53703: LD_ADDR_VAR 0 10
53707: PUSH
53708: LD_INT 0
53710: ST_TO_ADDR
// side := GetSide ( j ) ;
53711: LD_ADDR_VAR 0 4
53715: PUSH
53716: LD_VAR 0 3
53720: PPUSH
53721: CALL_OW 255
53725: ST_TO_ADDR
// if not mc_tech [ side ] then
53726: LD_EXP 127
53730: PUSH
53731: LD_VAR 0 4
53735: ARRAY
53736: NOT
53737: IFFALSE 53741
// continue ;
53739: GO 53700
// if BuildingStatus ( j ) = bs_idle then
53741: LD_VAR 0 3
53745: PPUSH
53746: CALL_OW 461
53750: PUSH
53751: LD_INT 2
53753: EQUAL
53754: IFFALSE 53942
// begin if idle_lab and UnitsInside ( j ) < 6 then
53756: LD_VAR 0 11
53760: PUSH
53761: LD_VAR 0 3
53765: PPUSH
53766: CALL_OW 313
53770: PUSH
53771: LD_INT 6
53773: LESS
53774: AND
53775: IFFALSE 53846
// begin tmp2 := UnitsInside ( idle_lab ) ;
53777: LD_ADDR_VAR 0 9
53781: PUSH
53782: LD_VAR 0 11
53786: PPUSH
53787: CALL_OW 313
53791: ST_TO_ADDR
// if tmp2 then
53792: LD_VAR 0 9
53796: IFFALSE 53838
// for x in tmp2 do
53798: LD_ADDR_VAR 0 7
53802: PUSH
53803: LD_VAR 0 9
53807: PUSH
53808: FOR_IN
53809: IFFALSE 53836
// begin ComExitBuilding ( x ) ;
53811: LD_VAR 0 7
53815: PPUSH
53816: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53820: LD_VAR 0 7
53824: PPUSH
53825: LD_VAR 0 3
53829: PPUSH
53830: CALL_OW 180
// end ;
53834: GO 53808
53836: POP
53837: POP
// idle_lab := 0 ;
53838: LD_ADDR_VAR 0 11
53842: PUSH
53843: LD_INT 0
53845: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53846: LD_ADDR_VAR 0 5
53850: PUSH
53851: LD_EXP 127
53855: PUSH
53856: LD_VAR 0 4
53860: ARRAY
53861: PUSH
53862: FOR_IN
53863: IFFALSE 53923
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53865: LD_VAR 0 3
53869: PPUSH
53870: LD_VAR 0 5
53874: PPUSH
53875: CALL_OW 430
53879: PUSH
53880: LD_VAR 0 4
53884: PPUSH
53885: LD_VAR 0 5
53889: PPUSH
53890: CALL 68366 0 2
53894: AND
53895: IFFALSE 53921
// begin researching := true ;
53897: LD_ADDR_VAR 0 10
53901: PUSH
53902: LD_INT 1
53904: ST_TO_ADDR
// ComResearch ( j , t ) ;
53905: LD_VAR 0 3
53909: PPUSH
53910: LD_VAR 0 5
53914: PPUSH
53915: CALL_OW 124
// break ;
53919: GO 53923
// end ;
53921: GO 53862
53923: POP
53924: POP
// if not researching then
53925: LD_VAR 0 10
53929: NOT
53930: IFFALSE 53942
// idle_lab := j ;
53932: LD_ADDR_VAR 0 11
53936: PUSH
53937: LD_VAR 0 3
53941: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53942: LD_VAR 0 3
53946: PPUSH
53947: CALL_OW 461
53951: PUSH
53952: LD_INT 10
53954: EQUAL
53955: IFFALSE 54543
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53957: LD_EXP 129
53961: PUSH
53962: LD_VAR 0 2
53966: ARRAY
53967: NOT
53968: PUSH
53969: LD_EXP 130
53973: PUSH
53974: LD_VAR 0 2
53978: ARRAY
53979: NOT
53980: AND
53981: PUSH
53982: LD_EXP 127
53986: PUSH
53987: LD_VAR 0 4
53991: ARRAY
53992: PUSH
53993: LD_INT 1
53995: GREATER
53996: AND
53997: IFFALSE 54128
// begin ComCancel ( j ) ;
53999: LD_VAR 0 3
54003: PPUSH
54004: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
54008: LD_ADDR_EXP 127
54012: PUSH
54013: LD_EXP 127
54017: PPUSH
54018: LD_VAR 0 4
54022: PPUSH
54023: LD_EXP 127
54027: PUSH
54028: LD_VAR 0 4
54032: ARRAY
54033: PPUSH
54034: LD_EXP 127
54038: PUSH
54039: LD_VAR 0 4
54043: ARRAY
54044: PUSH
54045: LD_INT 1
54047: MINUS
54048: PPUSH
54049: LD_EXP 127
54053: PUSH
54054: LD_VAR 0 4
54058: ARRAY
54059: PPUSH
54060: LD_INT 0
54062: PPUSH
54063: CALL 72065 0 4
54067: PPUSH
54068: CALL_OW 1
54072: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
54073: LD_ADDR_EXP 127
54077: PUSH
54078: LD_EXP 127
54082: PPUSH
54083: LD_VAR 0 4
54087: PPUSH
54088: LD_EXP 127
54092: PUSH
54093: LD_VAR 0 4
54097: ARRAY
54098: PPUSH
54099: LD_EXP 127
54103: PUSH
54104: LD_VAR 0 4
54108: ARRAY
54109: PPUSH
54110: LD_INT 1
54112: PPUSH
54113: LD_INT 0
54115: PPUSH
54116: CALL 72065 0 4
54120: PPUSH
54121: CALL_OW 1
54125: ST_TO_ADDR
// continue ;
54126: GO 53700
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
54128: LD_EXP 129
54132: PUSH
54133: LD_VAR 0 2
54137: ARRAY
54138: PUSH
54139: LD_EXP 130
54143: PUSH
54144: LD_VAR 0 2
54148: ARRAY
54149: NOT
54150: AND
54151: IFFALSE 54278
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
54153: LD_ADDR_EXP 130
54157: PUSH
54158: LD_EXP 130
54162: PPUSH
54163: LD_VAR 0 2
54167: PUSH
54168: LD_EXP 130
54172: PUSH
54173: LD_VAR 0 2
54177: ARRAY
54178: PUSH
54179: LD_INT 1
54181: PLUS
54182: PUSH
54183: EMPTY
54184: LIST
54185: LIST
54186: PPUSH
54187: LD_EXP 129
54191: PUSH
54192: LD_VAR 0 2
54196: ARRAY
54197: PUSH
54198: LD_INT 1
54200: ARRAY
54201: PPUSH
54202: CALL 72647 0 3
54206: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54207: LD_EXP 129
54211: PUSH
54212: LD_VAR 0 2
54216: ARRAY
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PPUSH
54222: LD_INT 112
54224: PPUSH
54225: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54229: LD_ADDR_VAR 0 9
54233: PUSH
54234: LD_EXP 129
54238: PUSH
54239: LD_VAR 0 2
54243: ARRAY
54244: PPUSH
54245: LD_INT 1
54247: PPUSH
54248: CALL_OW 3
54252: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54253: LD_ADDR_EXP 129
54257: PUSH
54258: LD_EXP 129
54262: PPUSH
54263: LD_VAR 0 2
54267: PPUSH
54268: LD_VAR 0 9
54272: PPUSH
54273: CALL_OW 1
54277: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54278: LD_EXP 129
54282: PUSH
54283: LD_VAR 0 2
54287: ARRAY
54288: PUSH
54289: LD_EXP 130
54293: PUSH
54294: LD_VAR 0 2
54298: ARRAY
54299: AND
54300: PUSH
54301: LD_EXP 130
54305: PUSH
54306: LD_VAR 0 2
54310: ARRAY
54311: PUSH
54312: LD_INT 1
54314: ARRAY
54315: PPUSH
54316: CALL_OW 310
54320: NOT
54321: AND
54322: PUSH
54323: LD_VAR 0 3
54327: PPUSH
54328: CALL_OW 313
54332: PUSH
54333: LD_INT 6
54335: EQUAL
54336: AND
54337: IFFALSE 54393
// begin tmp2 := UnitsInside ( j ) ;
54339: LD_ADDR_VAR 0 9
54343: PUSH
54344: LD_VAR 0 3
54348: PPUSH
54349: CALL_OW 313
54353: ST_TO_ADDR
// if tmp2 = 6 then
54354: LD_VAR 0 9
54358: PUSH
54359: LD_INT 6
54361: EQUAL
54362: IFFALSE 54393
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54364: LD_VAR 0 9
54368: PUSH
54369: LD_INT 1
54371: ARRAY
54372: PPUSH
54373: LD_INT 112
54375: PPUSH
54376: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54380: LD_VAR 0 9
54384: PUSH
54385: LD_INT 1
54387: ARRAY
54388: PPUSH
54389: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54393: LD_EXP 130
54397: PUSH
54398: LD_VAR 0 2
54402: ARRAY
54403: PUSH
54404: LD_EXP 130
54408: PUSH
54409: LD_VAR 0 2
54413: ARRAY
54414: PUSH
54415: LD_INT 1
54417: ARRAY
54418: PPUSH
54419: CALL_OW 314
54423: NOT
54424: AND
54425: PUSH
54426: LD_EXP 130
54430: PUSH
54431: LD_VAR 0 2
54435: ARRAY
54436: PUSH
54437: LD_INT 1
54439: ARRAY
54440: PPUSH
54441: CALL_OW 310
54445: NOT
54446: AND
54447: IFFALSE 54473
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54449: LD_EXP 130
54453: PUSH
54454: LD_VAR 0 2
54458: ARRAY
54459: PUSH
54460: LD_INT 1
54462: ARRAY
54463: PPUSH
54464: LD_VAR 0 3
54468: PPUSH
54469: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54473: LD_EXP 130
54477: PUSH
54478: LD_VAR 0 2
54482: ARRAY
54483: PUSH
54484: LD_INT 1
54486: ARRAY
54487: PPUSH
54488: CALL_OW 310
54492: PUSH
54493: LD_EXP 130
54497: PUSH
54498: LD_VAR 0 2
54502: ARRAY
54503: PUSH
54504: LD_INT 1
54506: ARRAY
54507: PPUSH
54508: CALL_OW 310
54512: PPUSH
54513: CALL_OW 461
54517: PUSH
54518: LD_INT 3
54520: NONEQUAL
54521: AND
54522: IFFALSE 54543
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54524: LD_EXP 130
54528: PUSH
54529: LD_VAR 0 2
54533: ARRAY
54534: PUSH
54535: LD_INT 1
54537: ARRAY
54538: PPUSH
54539: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54543: LD_VAR 0 3
54547: PPUSH
54548: CALL_OW 461
54552: PUSH
54553: LD_INT 6
54555: EQUAL
54556: PUSH
54557: LD_VAR 0 6
54561: PUSH
54562: LD_INT 1
54564: GREATER
54565: AND
54566: IFFALSE 54718
// begin sci := [ ] ;
54568: LD_ADDR_VAR 0 8
54572: PUSH
54573: EMPTY
54574: ST_TO_ADDR
// for x in ( tmp diff j ) do
54575: LD_ADDR_VAR 0 7
54579: PUSH
54580: LD_VAR 0 6
54584: PUSH
54585: LD_VAR 0 3
54589: DIFF
54590: PUSH
54591: FOR_IN
54592: IFFALSE 54644
// begin if sci = 6 then
54594: LD_VAR 0 8
54598: PUSH
54599: LD_INT 6
54601: EQUAL
54602: IFFALSE 54606
// break ;
54604: GO 54644
// if BuildingStatus ( x ) = bs_idle then
54606: LD_VAR 0 7
54610: PPUSH
54611: CALL_OW 461
54615: PUSH
54616: LD_INT 2
54618: EQUAL
54619: IFFALSE 54642
// sci := sci ^ UnitsInside ( x ) ;
54621: LD_ADDR_VAR 0 8
54625: PUSH
54626: LD_VAR 0 8
54630: PUSH
54631: LD_VAR 0 7
54635: PPUSH
54636: CALL_OW 313
54640: ADD
54641: ST_TO_ADDR
// end ;
54642: GO 54591
54644: POP
54645: POP
// if not sci then
54646: LD_VAR 0 8
54650: NOT
54651: IFFALSE 54655
// continue ;
54653: GO 53700
// for x in sci do
54655: LD_ADDR_VAR 0 7
54659: PUSH
54660: LD_VAR 0 8
54664: PUSH
54665: FOR_IN
54666: IFFALSE 54716
// if IsInUnit ( x ) and not HasTask ( x ) then
54668: LD_VAR 0 7
54672: PPUSH
54673: CALL_OW 310
54677: PUSH
54678: LD_VAR 0 7
54682: PPUSH
54683: CALL_OW 314
54687: NOT
54688: AND
54689: IFFALSE 54714
// begin ComExitBuilding ( x ) ;
54691: LD_VAR 0 7
54695: PPUSH
54696: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54700: LD_VAR 0 7
54704: PPUSH
54705: LD_VAR 0 3
54709: PPUSH
54710: CALL_OW 180
// end ;
54714: GO 54665
54716: POP
54717: POP
// end ; end ;
54718: GO 53700
54720: POP
54721: POP
// end ;
54722: GO 53654
54724: POP
54725: POP
// end ;
54726: LD_VAR 0 1
54730: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54731: LD_INT 0
54733: PPUSH
54734: PPUSH
// if not mc_bases then
54735: LD_EXP 100
54739: NOT
54740: IFFALSE 54744
// exit ;
54742: GO 54825
// for i = 1 to mc_bases do
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: DOUBLE
54750: LD_INT 1
54752: DEC
54753: ST_TO_ADDR
54754: LD_EXP 100
54758: PUSH
54759: FOR_TO
54760: IFFALSE 54823
// if mc_mines [ i ] and mc_miners [ i ] then
54762: LD_EXP 113
54766: PUSH
54767: LD_VAR 0 2
54771: ARRAY
54772: PUSH
54773: LD_EXP 114
54777: PUSH
54778: LD_VAR 0 2
54782: ARRAY
54783: AND
54784: IFFALSE 54821
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54786: LD_EXP 114
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: PUSH
54797: LD_INT 1
54799: ARRAY
54800: PPUSH
54801: CALL_OW 255
54805: PPUSH
54806: LD_EXP 113
54810: PUSH
54811: LD_VAR 0 2
54815: ARRAY
54816: PPUSH
54817: CALL 69449 0 2
54821: GO 54759
54823: POP
54824: POP
// end ;
54825: LD_VAR 0 1
54829: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54830: LD_INT 0
54832: PPUSH
54833: PPUSH
54834: PPUSH
54835: PPUSH
54836: PPUSH
54837: PPUSH
54838: PPUSH
54839: PPUSH
// if not mc_bases or not mc_parking then
54840: LD_EXP 100
54844: NOT
54845: PUSH
54846: LD_EXP 124
54850: NOT
54851: OR
54852: IFFALSE 54856
// exit ;
54854: GO 55594
// for i = 1 to mc_bases do
54856: LD_ADDR_VAR 0 2
54860: PUSH
54861: DOUBLE
54862: LD_INT 1
54864: DEC
54865: ST_TO_ADDR
54866: LD_EXP 100
54870: PUSH
54871: FOR_TO
54872: IFFALSE 55592
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54874: LD_EXP 100
54878: PUSH
54879: LD_VAR 0 2
54883: ARRAY
54884: NOT
54885: PUSH
54886: LD_EXP 124
54890: PUSH
54891: LD_VAR 0 2
54895: ARRAY
54896: NOT
54897: OR
54898: IFFALSE 54902
// continue ;
54900: GO 54871
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54902: LD_ADDR_VAR 0 5
54906: PUSH
54907: LD_EXP 100
54911: PUSH
54912: LD_VAR 0 2
54916: ARRAY
54917: PUSH
54918: LD_INT 1
54920: ARRAY
54921: PPUSH
54922: CALL_OW 255
54926: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54927: LD_ADDR_VAR 0 6
54931: PUSH
54932: LD_EXP 100
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: PPUSH
54943: LD_INT 30
54945: PUSH
54946: LD_INT 3
54948: PUSH
54949: EMPTY
54950: LIST
54951: LIST
54952: PPUSH
54953: CALL_OW 72
54957: ST_TO_ADDR
// if not fac then
54958: LD_VAR 0 6
54962: NOT
54963: IFFALSE 55014
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54965: LD_ADDR_VAR 0 6
54969: PUSH
54970: LD_EXP 100
54974: PUSH
54975: LD_VAR 0 2
54979: ARRAY
54980: PPUSH
54981: LD_INT 2
54983: PUSH
54984: LD_INT 30
54986: PUSH
54987: LD_INT 0
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: PUSH
54994: LD_INT 30
54996: PUSH
54997: LD_INT 1
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: LIST
55008: PPUSH
55009: CALL_OW 72
55013: ST_TO_ADDR
// if not fac then
55014: LD_VAR 0 6
55018: NOT
55019: IFFALSE 55023
// continue ;
55021: GO 54871
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55023: LD_ADDR_VAR 0 7
55027: PUSH
55028: LD_EXP 124
55032: PUSH
55033: LD_VAR 0 2
55037: ARRAY
55038: PPUSH
55039: LD_INT 22
55041: PUSH
55042: LD_VAR 0 5
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: PUSH
55051: LD_INT 21
55053: PUSH
55054: LD_INT 2
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: PUSH
55061: LD_INT 3
55063: PUSH
55064: LD_INT 60
55066: PUSH
55067: EMPTY
55068: LIST
55069: PUSH
55070: EMPTY
55071: LIST
55072: LIST
55073: PUSH
55074: LD_INT 3
55076: PUSH
55077: LD_INT 24
55079: PUSH
55080: LD_INT 1000
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: PPUSH
55097: CALL_OW 70
55101: ST_TO_ADDR
// for j in fac do
55102: LD_ADDR_VAR 0 3
55106: PUSH
55107: LD_VAR 0 6
55111: PUSH
55112: FOR_IN
55113: IFFALSE 55208
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55115: LD_ADDR_VAR 0 7
55119: PUSH
55120: LD_VAR 0 7
55124: PUSH
55125: LD_INT 22
55127: PUSH
55128: LD_VAR 0 5
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: PUSH
55137: LD_INT 91
55139: PUSH
55140: LD_VAR 0 3
55144: PUSH
55145: LD_INT 15
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: LIST
55152: PUSH
55153: LD_INT 21
55155: PUSH
55156: LD_INT 2
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PUSH
55163: LD_INT 3
55165: PUSH
55166: LD_INT 60
55168: PUSH
55169: EMPTY
55170: LIST
55171: PUSH
55172: EMPTY
55173: LIST
55174: LIST
55175: PUSH
55176: LD_INT 3
55178: PUSH
55179: LD_INT 24
55181: PUSH
55182: LD_INT 1000
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: PUSH
55193: EMPTY
55194: LIST
55195: LIST
55196: LIST
55197: LIST
55198: LIST
55199: PPUSH
55200: CALL_OW 69
55204: UNION
55205: ST_TO_ADDR
55206: GO 55112
55208: POP
55209: POP
// if not vehs then
55210: LD_VAR 0 7
55214: NOT
55215: IFFALSE 55241
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55217: LD_ADDR_EXP 112
55221: PUSH
55222: LD_EXP 112
55226: PPUSH
55227: LD_VAR 0 2
55231: PPUSH
55232: EMPTY
55233: PPUSH
55234: CALL_OW 1
55238: ST_TO_ADDR
// continue ;
55239: GO 54871
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55241: LD_ADDR_VAR 0 8
55245: PUSH
55246: LD_EXP 100
55250: PUSH
55251: LD_VAR 0 2
55255: ARRAY
55256: PPUSH
55257: LD_INT 30
55259: PUSH
55260: LD_INT 3
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: PPUSH
55267: CALL_OW 72
55271: ST_TO_ADDR
// if tmp then
55272: LD_VAR 0 8
55276: IFFALSE 55379
// begin for j in tmp do
55278: LD_ADDR_VAR 0 3
55282: PUSH
55283: LD_VAR 0 8
55287: PUSH
55288: FOR_IN
55289: IFFALSE 55377
// for k in UnitsInside ( j ) do
55291: LD_ADDR_VAR 0 4
55295: PUSH
55296: LD_VAR 0 3
55300: PPUSH
55301: CALL_OW 313
55305: PUSH
55306: FOR_IN
55307: IFFALSE 55373
// if k then
55309: LD_VAR 0 4
55313: IFFALSE 55371
// if not k in mc_repair_vehicle [ i ] then
55315: LD_VAR 0 4
55319: PUSH
55320: LD_EXP 112
55324: PUSH
55325: LD_VAR 0 2
55329: ARRAY
55330: IN
55331: NOT
55332: IFFALSE 55371
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55334: LD_ADDR_EXP 112
55338: PUSH
55339: LD_EXP 112
55343: PPUSH
55344: LD_VAR 0 2
55348: PPUSH
55349: LD_EXP 112
55353: PUSH
55354: LD_VAR 0 2
55358: ARRAY
55359: PUSH
55360: LD_VAR 0 4
55364: UNION
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
55371: GO 55306
55373: POP
55374: POP
55375: GO 55288
55377: POP
55378: POP
// end ; if not mc_repair_vehicle [ i ] then
55379: LD_EXP 112
55383: PUSH
55384: LD_VAR 0 2
55388: ARRAY
55389: NOT
55390: IFFALSE 55394
// continue ;
55392: GO 54871
// for j in mc_repair_vehicle [ i ] do
55394: LD_ADDR_VAR 0 3
55398: PUSH
55399: LD_EXP 112
55403: PUSH
55404: LD_VAR 0 2
55408: ARRAY
55409: PUSH
55410: FOR_IN
55411: IFFALSE 55588
// begin if GetClass ( j ) <> 3 then
55413: LD_VAR 0 3
55417: PPUSH
55418: CALL_OW 257
55422: PUSH
55423: LD_INT 3
55425: NONEQUAL
55426: IFFALSE 55467
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55428: LD_ADDR_EXP 112
55432: PUSH
55433: LD_EXP 112
55437: PPUSH
55438: LD_VAR 0 2
55442: PPUSH
55443: LD_EXP 112
55447: PUSH
55448: LD_VAR 0 2
55452: ARRAY
55453: PUSH
55454: LD_VAR 0 3
55458: DIFF
55459: PPUSH
55460: CALL_OW 1
55464: ST_TO_ADDR
// continue ;
55465: GO 55410
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55467: LD_VAR 0 3
55471: PPUSH
55472: CALL_OW 311
55476: NOT
55477: PUSH
55478: LD_VAR 0 3
55482: PUSH
55483: LD_EXP 103
55487: PUSH
55488: LD_VAR 0 2
55492: ARRAY
55493: PUSH
55494: LD_INT 1
55496: ARRAY
55497: IN
55498: NOT
55499: AND
55500: PUSH
55501: LD_VAR 0 3
55505: PUSH
55506: LD_EXP 103
55510: PUSH
55511: LD_VAR 0 2
55515: ARRAY
55516: PUSH
55517: LD_INT 2
55519: ARRAY
55520: IN
55521: NOT
55522: AND
55523: IFFALSE 55586
// begin if IsInUnit ( j ) then
55525: LD_VAR 0 3
55529: PPUSH
55530: CALL_OW 310
55534: IFFALSE 55547
// ComExitBuilding ( j ) else
55536: LD_VAR 0 3
55540: PPUSH
55541: CALL_OW 122
55545: GO 55586
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55547: LD_VAR 0 3
55551: PPUSH
55552: LD_VAR 0 7
55556: PUSH
55557: LD_INT 1
55559: ARRAY
55560: PPUSH
55561: CALL 107024 0 2
55565: NOT
55566: IFFALSE 55586
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55568: LD_VAR 0 3
55572: PPUSH
55573: LD_VAR 0 7
55577: PUSH
55578: LD_INT 1
55580: ARRAY
55581: PPUSH
55582: CALL_OW 129
// end ; end ;
55586: GO 55410
55588: POP
55589: POP
// end ;
55590: GO 54871
55592: POP
55593: POP
// end ;
55594: LD_VAR 0 1
55598: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55599: LD_INT 0
55601: PPUSH
55602: PPUSH
55603: PPUSH
55604: PPUSH
55605: PPUSH
55606: PPUSH
55607: PPUSH
55608: PPUSH
55609: PPUSH
55610: PPUSH
55611: PPUSH
// if not mc_bases then
55612: LD_EXP 100
55616: NOT
55617: IFFALSE 55621
// exit ;
55619: GO 56423
// for i = 1 to mc_bases do
55621: LD_ADDR_VAR 0 2
55625: PUSH
55626: DOUBLE
55627: LD_INT 1
55629: DEC
55630: ST_TO_ADDR
55631: LD_EXP 100
55635: PUSH
55636: FOR_TO
55637: IFFALSE 56421
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55639: LD_EXP 128
55643: PUSH
55644: LD_VAR 0 2
55648: ARRAY
55649: NOT
55650: PUSH
55651: LD_EXP 103
55655: PUSH
55656: LD_VAR 0 2
55660: ARRAY
55661: PUSH
55662: LD_INT 1
55664: ARRAY
55665: OR
55666: PUSH
55667: LD_EXP 103
55671: PUSH
55672: LD_VAR 0 2
55676: ARRAY
55677: PUSH
55678: LD_INT 2
55680: ARRAY
55681: OR
55682: PUSH
55683: LD_EXP 126
55687: PUSH
55688: LD_VAR 0 2
55692: ARRAY
55693: PPUSH
55694: LD_INT 1
55696: PPUSH
55697: CALL_OW 325
55701: NOT
55702: OR
55703: PUSH
55704: LD_EXP 123
55708: PUSH
55709: LD_VAR 0 2
55713: ARRAY
55714: OR
55715: IFFALSE 55719
// continue ;
55717: GO 55636
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55719: LD_ADDR_VAR 0 8
55723: PUSH
55724: LD_EXP 100
55728: PUSH
55729: LD_VAR 0 2
55733: ARRAY
55734: PPUSH
55735: LD_INT 25
55737: PUSH
55738: LD_INT 4
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PUSH
55745: LD_INT 50
55747: PUSH
55748: EMPTY
55749: LIST
55750: PUSH
55751: LD_INT 3
55753: PUSH
55754: LD_INT 60
55756: PUSH
55757: EMPTY
55758: LIST
55759: PUSH
55760: EMPTY
55761: LIST
55762: LIST
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: LIST
55768: PPUSH
55769: CALL_OW 72
55773: PUSH
55774: LD_EXP 104
55778: PUSH
55779: LD_VAR 0 2
55783: ARRAY
55784: DIFF
55785: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55786: LD_ADDR_VAR 0 9
55790: PUSH
55791: LD_EXP 100
55795: PUSH
55796: LD_VAR 0 2
55800: ARRAY
55801: PPUSH
55802: LD_INT 2
55804: PUSH
55805: LD_INT 30
55807: PUSH
55808: LD_INT 0
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: PUSH
55815: LD_INT 30
55817: PUSH
55818: LD_INT 1
55820: PUSH
55821: EMPTY
55822: LIST
55823: LIST
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: LIST
55829: PPUSH
55830: CALL_OW 72
55834: ST_TO_ADDR
// if not tmp or not dep then
55835: LD_VAR 0 8
55839: NOT
55840: PUSH
55841: LD_VAR 0 9
55845: NOT
55846: OR
55847: IFFALSE 55851
// continue ;
55849: GO 55636
// side := GetSide ( tmp [ 1 ] ) ;
55851: LD_ADDR_VAR 0 11
55855: PUSH
55856: LD_VAR 0 8
55860: PUSH
55861: LD_INT 1
55863: ARRAY
55864: PPUSH
55865: CALL_OW 255
55869: ST_TO_ADDR
// dep := dep [ 1 ] ;
55870: LD_ADDR_VAR 0 9
55874: PUSH
55875: LD_VAR 0 9
55879: PUSH
55880: LD_INT 1
55882: ARRAY
55883: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55884: LD_ADDR_VAR 0 7
55888: PUSH
55889: LD_EXP 128
55893: PUSH
55894: LD_VAR 0 2
55898: ARRAY
55899: PPUSH
55900: LD_INT 22
55902: PUSH
55903: LD_INT 0
55905: PUSH
55906: EMPTY
55907: LIST
55908: LIST
55909: PUSH
55910: LD_INT 25
55912: PUSH
55913: LD_INT 12
55915: PUSH
55916: EMPTY
55917: LIST
55918: LIST
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: PPUSH
55924: CALL_OW 70
55928: PUSH
55929: LD_INT 22
55931: PUSH
55932: LD_INT 0
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: LD_INT 25
55941: PUSH
55942: LD_INT 12
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: PUSH
55949: LD_INT 91
55951: PUSH
55952: LD_VAR 0 9
55956: PUSH
55957: LD_INT 20
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: LIST
55964: PUSH
55965: EMPTY
55966: LIST
55967: LIST
55968: LIST
55969: PPUSH
55970: CALL_OW 69
55974: UNION
55975: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55976: LD_ADDR_VAR 0 10
55980: PUSH
55981: LD_EXP 128
55985: PUSH
55986: LD_VAR 0 2
55990: ARRAY
55991: PPUSH
55992: LD_INT 81
55994: PUSH
55995: LD_VAR 0 11
55999: PUSH
56000: EMPTY
56001: LIST
56002: LIST
56003: PPUSH
56004: CALL_OW 70
56008: ST_TO_ADDR
// if not apes or danger_at_area then
56009: LD_VAR 0 7
56013: NOT
56014: PUSH
56015: LD_VAR 0 10
56019: OR
56020: IFFALSE 56070
// begin if mc_taming [ i ] then
56022: LD_EXP 131
56026: PUSH
56027: LD_VAR 0 2
56031: ARRAY
56032: IFFALSE 56068
// begin MC_Reset ( i , 121 ) ;
56034: LD_VAR 0 2
56038: PPUSH
56039: LD_INT 121
56041: PPUSH
56042: CALL 41007 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56046: LD_ADDR_EXP 131
56050: PUSH
56051: LD_EXP 131
56055: PPUSH
56056: LD_VAR 0 2
56060: PPUSH
56061: EMPTY
56062: PPUSH
56063: CALL_OW 1
56067: ST_TO_ADDR
// end ; continue ;
56068: GO 55636
// end ; for j in tmp do
56070: LD_ADDR_VAR 0 3
56074: PUSH
56075: LD_VAR 0 8
56079: PUSH
56080: FOR_IN
56081: IFFALSE 56417
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
56083: LD_VAR 0 3
56087: PUSH
56088: LD_EXP 131
56092: PUSH
56093: LD_VAR 0 2
56097: ARRAY
56098: IN
56099: NOT
56100: PUSH
56101: LD_EXP 131
56105: PUSH
56106: LD_VAR 0 2
56110: ARRAY
56111: PUSH
56112: LD_INT 3
56114: LESS
56115: AND
56116: IFFALSE 56174
// begin SetTag ( j , 121 ) ;
56118: LD_VAR 0 3
56122: PPUSH
56123: LD_INT 121
56125: PPUSH
56126: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
56130: LD_ADDR_EXP 131
56134: PUSH
56135: LD_EXP 131
56139: PPUSH
56140: LD_VAR 0 2
56144: PUSH
56145: LD_EXP 131
56149: PUSH
56150: LD_VAR 0 2
56154: ARRAY
56155: PUSH
56156: LD_INT 1
56158: PLUS
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: PPUSH
56164: LD_VAR 0 3
56168: PPUSH
56169: CALL 72647 0 3
56173: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
56174: LD_VAR 0 3
56178: PUSH
56179: LD_EXP 131
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: IN
56190: IFFALSE 56415
// begin if GetClass ( j ) <> 4 then
56192: LD_VAR 0 3
56196: PPUSH
56197: CALL_OW 257
56201: PUSH
56202: LD_INT 4
56204: NONEQUAL
56205: IFFALSE 56258
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56207: LD_ADDR_EXP 131
56211: PUSH
56212: LD_EXP 131
56216: PPUSH
56217: LD_VAR 0 2
56221: PPUSH
56222: LD_EXP 131
56226: PUSH
56227: LD_VAR 0 2
56231: ARRAY
56232: PUSH
56233: LD_VAR 0 3
56237: DIFF
56238: PPUSH
56239: CALL_OW 1
56243: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56244: LD_VAR 0 3
56248: PPUSH
56249: LD_INT 0
56251: PPUSH
56252: CALL_OW 109
// continue ;
56256: GO 56080
// end ; if IsInUnit ( j ) then
56258: LD_VAR 0 3
56262: PPUSH
56263: CALL_OW 310
56267: IFFALSE 56278
// ComExitBuilding ( j ) ;
56269: LD_VAR 0 3
56273: PPUSH
56274: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56278: LD_ADDR_VAR 0 6
56282: PUSH
56283: LD_VAR 0 7
56287: PPUSH
56288: LD_VAR 0 3
56292: PPUSH
56293: CALL_OW 74
56297: ST_TO_ADDR
// if not ape then
56298: LD_VAR 0 6
56302: NOT
56303: IFFALSE 56307
// break ;
56305: GO 56417
// x := GetX ( ape ) ;
56307: LD_ADDR_VAR 0 4
56311: PUSH
56312: LD_VAR 0 6
56316: PPUSH
56317: CALL_OW 250
56321: ST_TO_ADDR
// y := GetY ( ape ) ;
56322: LD_ADDR_VAR 0 5
56326: PUSH
56327: LD_VAR 0 6
56331: PPUSH
56332: CALL_OW 251
56336: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56337: LD_VAR 0 4
56341: PPUSH
56342: LD_VAR 0 5
56346: PPUSH
56347: CALL_OW 488
56351: NOT
56352: PUSH
56353: LD_VAR 0 11
56357: PPUSH
56358: LD_VAR 0 4
56362: PPUSH
56363: LD_VAR 0 5
56367: PPUSH
56368: LD_INT 20
56370: PPUSH
56371: CALL 73543 0 4
56375: PUSH
56376: LD_INT 4
56378: ARRAY
56379: OR
56380: IFFALSE 56384
// break ;
56382: GO 56417
// if not HasTask ( j ) then
56384: LD_VAR 0 3
56388: PPUSH
56389: CALL_OW 314
56393: NOT
56394: IFFALSE 56415
// ComTameXY ( j , x , y ) ;
56396: LD_VAR 0 3
56400: PPUSH
56401: LD_VAR 0 4
56405: PPUSH
56406: LD_VAR 0 5
56410: PPUSH
56411: CALL_OW 131
// end ; end ;
56415: GO 56080
56417: POP
56418: POP
// end ;
56419: GO 55636
56421: POP
56422: POP
// end ;
56423: LD_VAR 0 1
56427: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56428: LD_INT 0
56430: PPUSH
56431: PPUSH
56432: PPUSH
56433: PPUSH
56434: PPUSH
56435: PPUSH
56436: PPUSH
56437: PPUSH
// if not mc_bases then
56438: LD_EXP 100
56442: NOT
56443: IFFALSE 56447
// exit ;
56445: GO 57073
// for i = 1 to mc_bases do
56447: LD_ADDR_VAR 0 2
56451: PUSH
56452: DOUBLE
56453: LD_INT 1
56455: DEC
56456: ST_TO_ADDR
56457: LD_EXP 100
56461: PUSH
56462: FOR_TO
56463: IFFALSE 57071
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56465: LD_EXP 129
56469: PUSH
56470: LD_VAR 0 2
56474: ARRAY
56475: NOT
56476: PUSH
56477: LD_EXP 129
56481: PUSH
56482: LD_VAR 0 2
56486: ARRAY
56487: PPUSH
56488: LD_INT 25
56490: PUSH
56491: LD_INT 12
56493: PUSH
56494: EMPTY
56495: LIST
56496: LIST
56497: PPUSH
56498: CALL_OW 72
56502: NOT
56503: OR
56504: IFFALSE 56508
// continue ;
56506: GO 56462
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56508: LD_ADDR_VAR 0 5
56512: PUSH
56513: LD_EXP 129
56517: PUSH
56518: LD_VAR 0 2
56522: ARRAY
56523: PUSH
56524: LD_INT 1
56526: ARRAY
56527: PPUSH
56528: CALL_OW 255
56532: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56533: LD_VAR 0 5
56537: PPUSH
56538: LD_INT 2
56540: PPUSH
56541: CALL_OW 325
56545: IFFALSE 56798
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56547: LD_ADDR_VAR 0 4
56551: PUSH
56552: LD_EXP 129
56556: PUSH
56557: LD_VAR 0 2
56561: ARRAY
56562: PPUSH
56563: LD_INT 25
56565: PUSH
56566: LD_INT 16
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: PPUSH
56573: CALL_OW 72
56577: ST_TO_ADDR
// if tmp < 6 then
56578: LD_VAR 0 4
56582: PUSH
56583: LD_INT 6
56585: LESS
56586: IFFALSE 56798
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56588: LD_ADDR_VAR 0 6
56592: PUSH
56593: LD_EXP 100
56597: PUSH
56598: LD_VAR 0 2
56602: ARRAY
56603: PPUSH
56604: LD_INT 2
56606: PUSH
56607: LD_INT 30
56609: PUSH
56610: LD_INT 0
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: PUSH
56617: LD_INT 30
56619: PUSH
56620: LD_INT 1
56622: PUSH
56623: EMPTY
56624: LIST
56625: LIST
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: LIST
56631: PPUSH
56632: CALL_OW 72
56636: ST_TO_ADDR
// if depot then
56637: LD_VAR 0 6
56641: IFFALSE 56798
// begin selected := 0 ;
56643: LD_ADDR_VAR 0 7
56647: PUSH
56648: LD_INT 0
56650: ST_TO_ADDR
// for j in depot do
56651: LD_ADDR_VAR 0 3
56655: PUSH
56656: LD_VAR 0 6
56660: PUSH
56661: FOR_IN
56662: IFFALSE 56693
// begin if UnitsInside ( j ) < 6 then
56664: LD_VAR 0 3
56668: PPUSH
56669: CALL_OW 313
56673: PUSH
56674: LD_INT 6
56676: LESS
56677: IFFALSE 56691
// begin selected := j ;
56679: LD_ADDR_VAR 0 7
56683: PUSH
56684: LD_VAR 0 3
56688: ST_TO_ADDR
// break ;
56689: GO 56693
// end ; end ;
56691: GO 56661
56693: POP
56694: POP
// if selected then
56695: LD_VAR 0 7
56699: IFFALSE 56798
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56701: LD_ADDR_VAR 0 3
56705: PUSH
56706: LD_EXP 129
56710: PUSH
56711: LD_VAR 0 2
56715: ARRAY
56716: PPUSH
56717: LD_INT 25
56719: PUSH
56720: LD_INT 12
56722: PUSH
56723: EMPTY
56724: LIST
56725: LIST
56726: PPUSH
56727: CALL_OW 72
56731: PUSH
56732: FOR_IN
56733: IFFALSE 56796
// if not HasTask ( j ) then
56735: LD_VAR 0 3
56739: PPUSH
56740: CALL_OW 314
56744: NOT
56745: IFFALSE 56794
// begin if not IsInUnit ( j ) then
56747: LD_VAR 0 3
56751: PPUSH
56752: CALL_OW 310
56756: NOT
56757: IFFALSE 56773
// ComEnterUnit ( j , selected ) ;
56759: LD_VAR 0 3
56763: PPUSH
56764: LD_VAR 0 7
56768: PPUSH
56769: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56773: LD_VAR 0 3
56777: PPUSH
56778: LD_INT 16
56780: PPUSH
56781: CALL_OW 183
// AddComExitBuilding ( j ) ;
56785: LD_VAR 0 3
56789: PPUSH
56790: CALL_OW 182
// end ;
56794: GO 56732
56796: POP
56797: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56798: LD_VAR 0 5
56802: PPUSH
56803: LD_INT 11
56805: PPUSH
56806: CALL_OW 325
56810: IFFALSE 57069
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56812: LD_ADDR_VAR 0 4
56816: PUSH
56817: LD_EXP 129
56821: PUSH
56822: LD_VAR 0 2
56826: ARRAY
56827: PPUSH
56828: LD_INT 25
56830: PUSH
56831: LD_INT 16
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PPUSH
56838: CALL_OW 72
56842: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56843: LD_VAR 0 4
56847: PUSH
56848: LD_INT 6
56850: GREATEREQUAL
56851: PUSH
56852: LD_VAR 0 5
56856: PPUSH
56857: LD_INT 2
56859: PPUSH
56860: CALL_OW 325
56864: NOT
56865: OR
56866: IFFALSE 57069
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56868: LD_ADDR_VAR 0 8
56872: PUSH
56873: LD_EXP 100
56877: PUSH
56878: LD_VAR 0 2
56882: ARRAY
56883: PPUSH
56884: LD_INT 2
56886: PUSH
56887: LD_INT 30
56889: PUSH
56890: LD_INT 4
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: PUSH
56897: LD_INT 30
56899: PUSH
56900: LD_INT 5
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: LIST
56911: PPUSH
56912: CALL_OW 72
56916: ST_TO_ADDR
// if barracks then
56917: LD_VAR 0 8
56921: IFFALSE 57069
// begin selected := 0 ;
56923: LD_ADDR_VAR 0 7
56927: PUSH
56928: LD_INT 0
56930: ST_TO_ADDR
// for j in barracks do
56931: LD_ADDR_VAR 0 3
56935: PUSH
56936: LD_VAR 0 8
56940: PUSH
56941: FOR_IN
56942: IFFALSE 56973
// begin if UnitsInside ( j ) < 6 then
56944: LD_VAR 0 3
56948: PPUSH
56949: CALL_OW 313
56953: PUSH
56954: LD_INT 6
56956: LESS
56957: IFFALSE 56971
// begin selected := j ;
56959: LD_ADDR_VAR 0 7
56963: PUSH
56964: LD_VAR 0 3
56968: ST_TO_ADDR
// break ;
56969: GO 56973
// end ; end ;
56971: GO 56941
56973: POP
56974: POP
// if selected then
56975: LD_VAR 0 7
56979: IFFALSE 57069
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56981: LD_ADDR_VAR 0 3
56985: PUSH
56986: LD_EXP 129
56990: PUSH
56991: LD_VAR 0 2
56995: ARRAY
56996: PPUSH
56997: LD_INT 25
56999: PUSH
57000: LD_INT 12
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: PPUSH
57007: CALL_OW 72
57011: PUSH
57012: FOR_IN
57013: IFFALSE 57067
// if not IsInUnit ( j ) and not HasTask ( j ) then
57015: LD_VAR 0 3
57019: PPUSH
57020: CALL_OW 310
57024: NOT
57025: PUSH
57026: LD_VAR 0 3
57030: PPUSH
57031: CALL_OW 314
57035: NOT
57036: AND
57037: IFFALSE 57065
// begin ComEnterUnit ( j , selected ) ;
57039: LD_VAR 0 3
57043: PPUSH
57044: LD_VAR 0 7
57048: PPUSH
57049: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
57053: LD_VAR 0 3
57057: PPUSH
57058: LD_INT 15
57060: PPUSH
57061: CALL_OW 183
// end ;
57065: GO 57012
57067: POP
57068: POP
// end ; end ; end ; end ; end ;
57069: GO 56462
57071: POP
57072: POP
// end ;
57073: LD_VAR 0 1
57077: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
57078: LD_INT 0
57080: PPUSH
57081: PPUSH
57082: PPUSH
57083: PPUSH
// if not mc_bases then
57084: LD_EXP 100
57088: NOT
57089: IFFALSE 57093
// exit ;
57091: GO 57271
// for i = 1 to mc_bases do
57093: LD_ADDR_VAR 0 2
57097: PUSH
57098: DOUBLE
57099: LD_INT 1
57101: DEC
57102: ST_TO_ADDR
57103: LD_EXP 100
57107: PUSH
57108: FOR_TO
57109: IFFALSE 57269
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
57111: LD_ADDR_VAR 0 4
57115: PUSH
57116: LD_EXP 100
57120: PUSH
57121: LD_VAR 0 2
57125: ARRAY
57126: PPUSH
57127: LD_INT 25
57129: PUSH
57130: LD_INT 9
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: PPUSH
57137: CALL_OW 72
57141: ST_TO_ADDR
// if not tmp then
57142: LD_VAR 0 4
57146: NOT
57147: IFFALSE 57151
// continue ;
57149: GO 57108
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
57151: LD_EXP 126
57155: PUSH
57156: LD_VAR 0 2
57160: ARRAY
57161: PPUSH
57162: LD_INT 29
57164: PPUSH
57165: CALL_OW 325
57169: NOT
57170: PUSH
57171: LD_EXP 126
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: PPUSH
57182: LD_INT 28
57184: PPUSH
57185: CALL_OW 325
57189: NOT
57190: AND
57191: IFFALSE 57195
// continue ;
57193: GO 57108
// for j in tmp do
57195: LD_ADDR_VAR 0 3
57199: PUSH
57200: LD_VAR 0 4
57204: PUSH
57205: FOR_IN
57206: IFFALSE 57265
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57208: LD_VAR 0 3
57212: PUSH
57213: LD_EXP 103
57217: PUSH
57218: LD_VAR 0 2
57222: ARRAY
57223: PUSH
57224: LD_INT 1
57226: ARRAY
57227: IN
57228: NOT
57229: PUSH
57230: LD_VAR 0 3
57234: PUSH
57235: LD_EXP 103
57239: PUSH
57240: LD_VAR 0 2
57244: ARRAY
57245: PUSH
57246: LD_INT 2
57248: ARRAY
57249: IN
57250: NOT
57251: AND
57252: IFFALSE 57263
// ComSpaceTimeShoot ( j ) ;
57254: LD_VAR 0 3
57258: PPUSH
57259: CALL 68457 0 1
57263: GO 57205
57265: POP
57266: POP
// end ;
57267: GO 57108
57269: POP
57270: POP
// end ;
57271: LD_VAR 0 1
57275: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57276: LD_INT 0
57278: PPUSH
57279: PPUSH
57280: PPUSH
57281: PPUSH
57282: PPUSH
57283: PPUSH
57284: PPUSH
57285: PPUSH
57286: PPUSH
// if not mc_bases then
57287: LD_EXP 100
57291: NOT
57292: IFFALSE 57296
// exit ;
57294: GO 57918
// for i = 1 to mc_bases do
57296: LD_ADDR_VAR 0 2
57300: PUSH
57301: DOUBLE
57302: LD_INT 1
57304: DEC
57305: ST_TO_ADDR
57306: LD_EXP 100
57310: PUSH
57311: FOR_TO
57312: IFFALSE 57916
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57314: LD_EXP 135
57318: PUSH
57319: LD_VAR 0 2
57323: ARRAY
57324: NOT
57325: PUSH
57326: LD_INT 38
57328: PPUSH
57329: LD_EXP 126
57333: PUSH
57334: LD_VAR 0 2
57338: ARRAY
57339: PPUSH
57340: CALL_OW 321
57344: PUSH
57345: LD_INT 2
57347: NONEQUAL
57348: OR
57349: IFFALSE 57353
// continue ;
57351: GO 57311
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57353: LD_ADDR_VAR 0 8
57357: PUSH
57358: LD_EXP 100
57362: PUSH
57363: LD_VAR 0 2
57367: ARRAY
57368: PPUSH
57369: LD_INT 30
57371: PUSH
57372: LD_INT 34
57374: PUSH
57375: EMPTY
57376: LIST
57377: LIST
57378: PPUSH
57379: CALL_OW 72
57383: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57384: LD_ADDR_VAR 0 9
57388: PUSH
57389: LD_EXP 100
57393: PUSH
57394: LD_VAR 0 2
57398: ARRAY
57399: PPUSH
57400: LD_INT 25
57402: PUSH
57403: LD_INT 4
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: PPUSH
57410: CALL_OW 72
57414: PPUSH
57415: LD_INT 0
57417: PPUSH
57418: CALL 102533 0 2
57422: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57423: LD_VAR 0 9
57427: NOT
57428: PUSH
57429: LD_VAR 0 8
57433: NOT
57434: OR
57435: PUSH
57436: LD_EXP 100
57440: PUSH
57441: LD_VAR 0 2
57445: ARRAY
57446: PPUSH
57447: LD_INT 124
57449: PPUSH
57450: CALL 102533 0 2
57454: OR
57455: IFFALSE 57459
// continue ;
57457: GO 57311
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57459: LD_EXP 136
57463: PUSH
57464: LD_VAR 0 2
57468: ARRAY
57469: PUSH
57470: LD_EXP 135
57474: PUSH
57475: LD_VAR 0 2
57479: ARRAY
57480: LESS
57481: PUSH
57482: LD_EXP 136
57486: PUSH
57487: LD_VAR 0 2
57491: ARRAY
57492: PUSH
57493: LD_VAR 0 8
57497: LESS
57498: AND
57499: IFFALSE 57914
// begin tmp := sci [ 1 ] ;
57501: LD_ADDR_VAR 0 7
57505: PUSH
57506: LD_VAR 0 9
57510: PUSH
57511: LD_INT 1
57513: ARRAY
57514: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57515: LD_VAR 0 7
57519: PPUSH
57520: LD_INT 124
57522: PPUSH
57523: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57527: LD_ADDR_VAR 0 3
57531: PUSH
57532: DOUBLE
57533: LD_EXP 135
57537: PUSH
57538: LD_VAR 0 2
57542: ARRAY
57543: INC
57544: ST_TO_ADDR
57545: LD_EXP 135
57549: PUSH
57550: LD_VAR 0 2
57554: ARRAY
57555: PUSH
57556: FOR_DOWNTO
57557: IFFALSE 57900
// begin if IsInUnit ( tmp ) then
57559: LD_VAR 0 7
57563: PPUSH
57564: CALL_OW 310
57568: IFFALSE 57579
// ComExitBuilding ( tmp ) ;
57570: LD_VAR 0 7
57574: PPUSH
57575: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57579: LD_INT 35
57581: PPUSH
57582: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57586: LD_VAR 0 7
57590: PPUSH
57591: CALL_OW 310
57595: NOT
57596: PUSH
57597: LD_VAR 0 7
57601: PPUSH
57602: CALL_OW 314
57606: NOT
57607: AND
57608: IFFALSE 57579
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57610: LD_ADDR_VAR 0 6
57614: PUSH
57615: LD_VAR 0 7
57619: PPUSH
57620: CALL_OW 250
57624: PUSH
57625: LD_VAR 0 7
57629: PPUSH
57630: CALL_OW 251
57634: PUSH
57635: EMPTY
57636: LIST
57637: LIST
57638: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57639: LD_INT 35
57641: PPUSH
57642: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57646: LD_ADDR_VAR 0 4
57650: PUSH
57651: LD_EXP 135
57655: PUSH
57656: LD_VAR 0 2
57660: ARRAY
57661: PUSH
57662: LD_VAR 0 3
57666: ARRAY
57667: PUSH
57668: LD_INT 1
57670: ARRAY
57671: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57672: LD_ADDR_VAR 0 5
57676: PUSH
57677: LD_EXP 135
57681: PUSH
57682: LD_VAR 0 2
57686: ARRAY
57687: PUSH
57688: LD_VAR 0 3
57692: ARRAY
57693: PUSH
57694: LD_INT 2
57696: ARRAY
57697: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57698: LD_VAR 0 7
57702: PPUSH
57703: LD_INT 10
57705: PPUSH
57706: CALL 75244 0 2
57710: PUSH
57711: LD_INT 4
57713: ARRAY
57714: IFFALSE 57752
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57716: LD_VAR 0 7
57720: PPUSH
57721: LD_VAR 0 6
57725: PUSH
57726: LD_INT 1
57728: ARRAY
57729: PPUSH
57730: LD_VAR 0 6
57734: PUSH
57735: LD_INT 2
57737: ARRAY
57738: PPUSH
57739: CALL_OW 111
// wait ( 0 0$10 ) ;
57743: LD_INT 350
57745: PPUSH
57746: CALL_OW 67
// end else
57750: GO 57778
// begin ComMoveXY ( tmp , x , y ) ;
57752: LD_VAR 0 7
57756: PPUSH
57757: LD_VAR 0 4
57761: PPUSH
57762: LD_VAR 0 5
57766: PPUSH
57767: CALL_OW 111
// wait ( 0 0$3 ) ;
57771: LD_INT 105
57773: PPUSH
57774: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57778: LD_VAR 0 7
57782: PPUSH
57783: LD_VAR 0 4
57787: PPUSH
57788: LD_VAR 0 5
57792: PPUSH
57793: CALL_OW 307
57797: IFFALSE 57639
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57799: LD_VAR 0 7
57803: PPUSH
57804: LD_VAR 0 4
57808: PPUSH
57809: LD_VAR 0 5
57813: PPUSH
57814: LD_VAR 0 8
57818: PUSH
57819: LD_VAR 0 3
57823: ARRAY
57824: PPUSH
57825: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57829: LD_INT 35
57831: PPUSH
57832: CALL_OW 67
// until not HasTask ( tmp ) ;
57836: LD_VAR 0 7
57840: PPUSH
57841: CALL_OW 314
57845: NOT
57846: IFFALSE 57829
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57848: LD_ADDR_EXP 136
57852: PUSH
57853: LD_EXP 136
57857: PPUSH
57858: LD_VAR 0 2
57862: PUSH
57863: LD_EXP 136
57867: PUSH
57868: LD_VAR 0 2
57872: ARRAY
57873: PUSH
57874: LD_INT 1
57876: PLUS
57877: PUSH
57878: EMPTY
57879: LIST
57880: LIST
57881: PPUSH
57882: LD_VAR 0 8
57886: PUSH
57887: LD_VAR 0 3
57891: ARRAY
57892: PPUSH
57893: CALL 72647 0 3
57897: ST_TO_ADDR
// end ;
57898: GO 57556
57900: POP
57901: POP
// MC_Reset ( i , 124 ) ;
57902: LD_VAR 0 2
57906: PPUSH
57907: LD_INT 124
57909: PPUSH
57910: CALL 41007 0 2
// end ; end ;
57914: GO 57311
57916: POP
57917: POP
// end ;
57918: LD_VAR 0 1
57922: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57923: LD_INT 0
57925: PPUSH
57926: PPUSH
57927: PPUSH
// if not mc_bases then
57928: LD_EXP 100
57932: NOT
57933: IFFALSE 57937
// exit ;
57935: GO 58543
// for i = 1 to mc_bases do
57937: LD_ADDR_VAR 0 2
57941: PUSH
57942: DOUBLE
57943: LD_INT 1
57945: DEC
57946: ST_TO_ADDR
57947: LD_EXP 100
57951: PUSH
57952: FOR_TO
57953: IFFALSE 58541
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57955: LD_ADDR_VAR 0 3
57959: PUSH
57960: LD_EXP 100
57964: PUSH
57965: LD_VAR 0 2
57969: ARRAY
57970: PPUSH
57971: LD_INT 25
57973: PUSH
57974: LD_INT 4
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: PPUSH
57981: CALL_OW 72
57985: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57986: LD_VAR 0 3
57990: NOT
57991: PUSH
57992: LD_EXP 137
57996: PUSH
57997: LD_VAR 0 2
58001: ARRAY
58002: NOT
58003: OR
58004: PUSH
58005: LD_EXP 100
58009: PUSH
58010: LD_VAR 0 2
58014: ARRAY
58015: PPUSH
58016: LD_INT 2
58018: PUSH
58019: LD_INT 30
58021: PUSH
58022: LD_INT 0
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: PUSH
58029: LD_INT 30
58031: PUSH
58032: LD_INT 1
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: LIST
58043: PPUSH
58044: CALL_OW 72
58048: NOT
58049: OR
58050: IFFALSE 58100
// begin if mc_deposits_finder [ i ] then
58052: LD_EXP 138
58056: PUSH
58057: LD_VAR 0 2
58061: ARRAY
58062: IFFALSE 58098
// begin MC_Reset ( i , 125 ) ;
58064: LD_VAR 0 2
58068: PPUSH
58069: LD_INT 125
58071: PPUSH
58072: CALL 41007 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58076: LD_ADDR_EXP 138
58080: PUSH
58081: LD_EXP 138
58085: PPUSH
58086: LD_VAR 0 2
58090: PPUSH
58091: EMPTY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// end ; continue ;
58098: GO 57952
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
58100: LD_EXP 137
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: PUSH
58111: LD_INT 1
58113: ARRAY
58114: PUSH
58115: LD_INT 3
58117: ARRAY
58118: PUSH
58119: LD_INT 1
58121: EQUAL
58122: PUSH
58123: LD_INT 20
58125: PPUSH
58126: LD_EXP 126
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PPUSH
58137: CALL_OW 321
58141: PUSH
58142: LD_INT 2
58144: NONEQUAL
58145: AND
58146: IFFALSE 58196
// begin if mc_deposits_finder [ i ] then
58148: LD_EXP 138
58152: PUSH
58153: LD_VAR 0 2
58157: ARRAY
58158: IFFALSE 58194
// begin MC_Reset ( i , 125 ) ;
58160: LD_VAR 0 2
58164: PPUSH
58165: LD_INT 125
58167: PPUSH
58168: CALL 41007 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58172: LD_ADDR_EXP 138
58176: PUSH
58177: LD_EXP 138
58181: PPUSH
58182: LD_VAR 0 2
58186: PPUSH
58187: EMPTY
58188: PPUSH
58189: CALL_OW 1
58193: ST_TO_ADDR
// end ; continue ;
58194: GO 57952
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58196: LD_EXP 137
58200: PUSH
58201: LD_VAR 0 2
58205: ARRAY
58206: PUSH
58207: LD_INT 1
58209: ARRAY
58210: PUSH
58211: LD_INT 1
58213: ARRAY
58214: PPUSH
58215: LD_EXP 137
58219: PUSH
58220: LD_VAR 0 2
58224: ARRAY
58225: PUSH
58226: LD_INT 1
58228: ARRAY
58229: PUSH
58230: LD_INT 2
58232: ARRAY
58233: PPUSH
58234: LD_EXP 126
58238: PUSH
58239: LD_VAR 0 2
58243: ARRAY
58244: PPUSH
58245: CALL_OW 440
58249: IFFALSE 58292
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58251: LD_ADDR_EXP 137
58255: PUSH
58256: LD_EXP 137
58260: PPUSH
58261: LD_VAR 0 2
58265: PPUSH
58266: LD_EXP 137
58270: PUSH
58271: LD_VAR 0 2
58275: ARRAY
58276: PPUSH
58277: LD_INT 1
58279: PPUSH
58280: CALL_OW 3
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
58290: GO 58539
// begin if not mc_deposits_finder [ i ] then
58292: LD_EXP 138
58296: PUSH
58297: LD_VAR 0 2
58301: ARRAY
58302: NOT
58303: IFFALSE 58355
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58305: LD_ADDR_EXP 138
58309: PUSH
58310: LD_EXP 138
58314: PPUSH
58315: LD_VAR 0 2
58319: PPUSH
58320: LD_VAR 0 3
58324: PUSH
58325: LD_INT 1
58327: ARRAY
58328: PUSH
58329: EMPTY
58330: LIST
58331: PPUSH
58332: CALL_OW 1
58336: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58337: LD_VAR 0 3
58341: PUSH
58342: LD_INT 1
58344: ARRAY
58345: PPUSH
58346: LD_INT 125
58348: PPUSH
58349: CALL_OW 109
// end else
58353: GO 58539
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58355: LD_EXP 138
58359: PUSH
58360: LD_VAR 0 2
58364: ARRAY
58365: PUSH
58366: LD_INT 1
58368: ARRAY
58369: PPUSH
58370: CALL_OW 310
58374: IFFALSE 58397
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58376: LD_EXP 138
58380: PUSH
58381: LD_VAR 0 2
58385: ARRAY
58386: PUSH
58387: LD_INT 1
58389: ARRAY
58390: PPUSH
58391: CALL_OW 122
58395: GO 58539
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58397: LD_EXP 138
58401: PUSH
58402: LD_VAR 0 2
58406: ARRAY
58407: PUSH
58408: LD_INT 1
58410: ARRAY
58411: PPUSH
58412: CALL_OW 314
58416: NOT
58417: PUSH
58418: LD_EXP 138
58422: PUSH
58423: LD_VAR 0 2
58427: ARRAY
58428: PUSH
58429: LD_INT 1
58431: ARRAY
58432: PPUSH
58433: LD_EXP 137
58437: PUSH
58438: LD_VAR 0 2
58442: ARRAY
58443: PUSH
58444: LD_INT 1
58446: ARRAY
58447: PUSH
58448: LD_INT 1
58450: ARRAY
58451: PPUSH
58452: LD_EXP 137
58456: PUSH
58457: LD_VAR 0 2
58461: ARRAY
58462: PUSH
58463: LD_INT 1
58465: ARRAY
58466: PUSH
58467: LD_INT 2
58469: ARRAY
58470: PPUSH
58471: CALL_OW 297
58475: PUSH
58476: LD_INT 6
58478: GREATER
58479: AND
58480: IFFALSE 58539
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58482: LD_EXP 138
58486: PUSH
58487: LD_VAR 0 2
58491: ARRAY
58492: PUSH
58493: LD_INT 1
58495: ARRAY
58496: PPUSH
58497: LD_EXP 137
58501: PUSH
58502: LD_VAR 0 2
58506: ARRAY
58507: PUSH
58508: LD_INT 1
58510: ARRAY
58511: PUSH
58512: LD_INT 1
58514: ARRAY
58515: PPUSH
58516: LD_EXP 137
58520: PUSH
58521: LD_VAR 0 2
58525: ARRAY
58526: PUSH
58527: LD_INT 1
58529: ARRAY
58530: PUSH
58531: LD_INT 2
58533: ARRAY
58534: PPUSH
58535: CALL_OW 111
// end ; end ; end ;
58539: GO 57952
58541: POP
58542: POP
// end ;
58543: LD_VAR 0 1
58547: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58548: LD_INT 0
58550: PPUSH
58551: PPUSH
58552: PPUSH
58553: PPUSH
58554: PPUSH
58555: PPUSH
58556: PPUSH
58557: PPUSH
58558: PPUSH
58559: PPUSH
58560: PPUSH
// if not mc_bases then
58561: LD_EXP 100
58565: NOT
58566: IFFALSE 58570
// exit ;
58568: GO 59510
// for i = 1 to mc_bases do
58570: LD_ADDR_VAR 0 2
58574: PUSH
58575: DOUBLE
58576: LD_INT 1
58578: DEC
58579: ST_TO_ADDR
58580: LD_EXP 100
58584: PUSH
58585: FOR_TO
58586: IFFALSE 59508
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58588: LD_EXP 100
58592: PUSH
58593: LD_VAR 0 2
58597: ARRAY
58598: NOT
58599: PUSH
58600: LD_EXP 123
58604: PUSH
58605: LD_VAR 0 2
58609: ARRAY
58610: OR
58611: IFFALSE 58615
// continue ;
58613: GO 58585
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58615: LD_ADDR_VAR 0 7
58619: PUSH
58620: LD_EXP 100
58624: PUSH
58625: LD_VAR 0 2
58629: ARRAY
58630: PUSH
58631: LD_INT 1
58633: ARRAY
58634: PPUSH
58635: CALL_OW 248
58639: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58640: LD_VAR 0 7
58644: PUSH
58645: LD_INT 3
58647: EQUAL
58648: PUSH
58649: LD_EXP 119
58653: PUSH
58654: LD_VAR 0 2
58658: ARRAY
58659: PUSH
58660: LD_EXP 122
58664: PUSH
58665: LD_VAR 0 2
58669: ARRAY
58670: UNION
58671: PPUSH
58672: LD_INT 33
58674: PUSH
58675: LD_INT 2
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: PPUSH
58682: CALL_OW 72
58686: NOT
58687: OR
58688: IFFALSE 58692
// continue ;
58690: GO 58585
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58692: LD_ADDR_VAR 0 9
58696: PUSH
58697: LD_EXP 100
58701: PUSH
58702: LD_VAR 0 2
58706: ARRAY
58707: PPUSH
58708: LD_INT 30
58710: PUSH
58711: LD_INT 36
58713: PUSH
58714: EMPTY
58715: LIST
58716: LIST
58717: PPUSH
58718: CALL_OW 72
58722: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58723: LD_ADDR_VAR 0 10
58727: PUSH
58728: LD_EXP 119
58732: PUSH
58733: LD_VAR 0 2
58737: ARRAY
58738: PPUSH
58739: LD_INT 34
58741: PUSH
58742: LD_INT 31
58744: PUSH
58745: EMPTY
58746: LIST
58747: LIST
58748: PPUSH
58749: CALL_OW 72
58753: ST_TO_ADDR
// if not cts and not mcts then
58754: LD_VAR 0 9
58758: NOT
58759: PUSH
58760: LD_VAR 0 10
58764: NOT
58765: AND
58766: IFFALSE 58770
// continue ;
58768: GO 58585
// x := cts ;
58770: LD_ADDR_VAR 0 11
58774: PUSH
58775: LD_VAR 0 9
58779: ST_TO_ADDR
// if not x then
58780: LD_VAR 0 11
58784: NOT
58785: IFFALSE 58797
// x := mcts ;
58787: LD_ADDR_VAR 0 11
58791: PUSH
58792: LD_VAR 0 10
58796: ST_TO_ADDR
// if not x then
58797: LD_VAR 0 11
58801: NOT
58802: IFFALSE 58806
// continue ;
58804: GO 58585
// if mc_remote_driver [ i ] then
58806: LD_EXP 140
58810: PUSH
58811: LD_VAR 0 2
58815: ARRAY
58816: IFFALSE 59203
// for j in mc_remote_driver [ i ] do
58818: LD_ADDR_VAR 0 3
58822: PUSH
58823: LD_EXP 140
58827: PUSH
58828: LD_VAR 0 2
58832: ARRAY
58833: PUSH
58834: FOR_IN
58835: IFFALSE 59201
// begin if GetClass ( j ) <> 3 then
58837: LD_VAR 0 3
58841: PPUSH
58842: CALL_OW 257
58846: PUSH
58847: LD_INT 3
58849: NONEQUAL
58850: IFFALSE 58903
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58852: LD_ADDR_EXP 140
58856: PUSH
58857: LD_EXP 140
58861: PPUSH
58862: LD_VAR 0 2
58866: PPUSH
58867: LD_EXP 140
58871: PUSH
58872: LD_VAR 0 2
58876: ARRAY
58877: PUSH
58878: LD_VAR 0 3
58882: DIFF
58883: PPUSH
58884: CALL_OW 1
58888: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58889: LD_VAR 0 3
58893: PPUSH
58894: LD_INT 0
58896: PPUSH
58897: CALL_OW 109
// continue ;
58901: GO 58834
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58903: LD_EXP 119
58907: PUSH
58908: LD_VAR 0 2
58912: ARRAY
58913: PPUSH
58914: LD_INT 34
58916: PUSH
58917: LD_INT 31
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: PUSH
58924: LD_INT 58
58926: PUSH
58927: EMPTY
58928: LIST
58929: PUSH
58930: EMPTY
58931: LIST
58932: LIST
58933: PPUSH
58934: CALL_OW 72
58938: PUSH
58939: LD_VAR 0 3
58943: PPUSH
58944: CALL 102568 0 1
58948: NOT
58949: AND
58950: IFFALSE 59021
// begin if IsInUnit ( j ) then
58952: LD_VAR 0 3
58956: PPUSH
58957: CALL_OW 310
58961: IFFALSE 58972
// ComExitBuilding ( j ) ;
58963: LD_VAR 0 3
58967: PPUSH
58968: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58972: LD_VAR 0 3
58976: PPUSH
58977: LD_EXP 119
58981: PUSH
58982: LD_VAR 0 2
58986: ARRAY
58987: PPUSH
58988: LD_INT 34
58990: PUSH
58991: LD_INT 31
58993: PUSH
58994: EMPTY
58995: LIST
58996: LIST
58997: PUSH
58998: LD_INT 58
59000: PUSH
59001: EMPTY
59002: LIST
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PPUSH
59008: CALL_OW 72
59012: PUSH
59013: LD_INT 1
59015: ARRAY
59016: PPUSH
59017: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
59021: LD_VAR 0 3
59025: PPUSH
59026: CALL_OW 310
59030: NOT
59031: PUSH
59032: LD_VAR 0 3
59036: PPUSH
59037: CALL_OW 310
59041: PPUSH
59042: CALL_OW 266
59046: PUSH
59047: LD_INT 36
59049: NONEQUAL
59050: PUSH
59051: LD_VAR 0 3
59055: PPUSH
59056: CALL 102568 0 1
59060: NOT
59061: AND
59062: OR
59063: IFFALSE 59199
// begin if IsInUnit ( j ) then
59065: LD_VAR 0 3
59069: PPUSH
59070: CALL_OW 310
59074: IFFALSE 59085
// ComExitBuilding ( j ) ;
59076: LD_VAR 0 3
59080: PPUSH
59081: CALL_OW 122
// ct := 0 ;
59085: LD_ADDR_VAR 0 8
59089: PUSH
59090: LD_INT 0
59092: ST_TO_ADDR
// for k in x do
59093: LD_ADDR_VAR 0 4
59097: PUSH
59098: LD_VAR 0 11
59102: PUSH
59103: FOR_IN
59104: IFFALSE 59177
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
59106: LD_VAR 0 4
59110: PPUSH
59111: CALL_OW 264
59115: PUSH
59116: LD_INT 31
59118: EQUAL
59119: PUSH
59120: LD_VAR 0 4
59124: PPUSH
59125: CALL_OW 311
59129: NOT
59130: AND
59131: PUSH
59132: LD_VAR 0 4
59136: PPUSH
59137: CALL_OW 266
59141: PUSH
59142: LD_INT 36
59144: EQUAL
59145: PUSH
59146: LD_VAR 0 4
59150: PPUSH
59151: CALL_OW 313
59155: PUSH
59156: LD_INT 3
59158: LESS
59159: AND
59160: OR
59161: IFFALSE 59175
// begin ct := k ;
59163: LD_ADDR_VAR 0 8
59167: PUSH
59168: LD_VAR 0 4
59172: ST_TO_ADDR
// break ;
59173: GO 59177
// end ;
59175: GO 59103
59177: POP
59178: POP
// if ct then
59179: LD_VAR 0 8
59183: IFFALSE 59199
// ComEnterUnit ( j , ct ) ;
59185: LD_VAR 0 3
59189: PPUSH
59190: LD_VAR 0 8
59194: PPUSH
59195: CALL_OW 120
// end ; end ;
59199: GO 58834
59201: POP
59202: POP
// places := 0 ;
59203: LD_ADDR_VAR 0 5
59207: PUSH
59208: LD_INT 0
59210: ST_TO_ADDR
// for j = 1 to x do
59211: LD_ADDR_VAR 0 3
59215: PUSH
59216: DOUBLE
59217: LD_INT 1
59219: DEC
59220: ST_TO_ADDR
59221: LD_VAR 0 11
59225: PUSH
59226: FOR_TO
59227: IFFALSE 59303
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59229: LD_VAR 0 11
59233: PUSH
59234: LD_VAR 0 3
59238: ARRAY
59239: PPUSH
59240: CALL_OW 264
59244: PUSH
59245: LD_INT 31
59247: EQUAL
59248: IFFALSE 59266
// places := places + 1 else
59250: LD_ADDR_VAR 0 5
59254: PUSH
59255: LD_VAR 0 5
59259: PUSH
59260: LD_INT 1
59262: PLUS
59263: ST_TO_ADDR
59264: GO 59301
// if GetBType ( x [ j ] ) = b_control_tower then
59266: LD_VAR 0 11
59270: PUSH
59271: LD_VAR 0 3
59275: ARRAY
59276: PPUSH
59277: CALL_OW 266
59281: PUSH
59282: LD_INT 36
59284: EQUAL
59285: IFFALSE 59301
// places := places + 3 ;
59287: LD_ADDR_VAR 0 5
59291: PUSH
59292: LD_VAR 0 5
59296: PUSH
59297: LD_INT 3
59299: PLUS
59300: ST_TO_ADDR
59301: GO 59226
59303: POP
59304: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59305: LD_VAR 0 5
59309: PUSH
59310: LD_INT 0
59312: EQUAL
59313: PUSH
59314: LD_VAR 0 5
59318: PUSH
59319: LD_EXP 140
59323: PUSH
59324: LD_VAR 0 2
59328: ARRAY
59329: LESSEQUAL
59330: OR
59331: IFFALSE 59335
// continue ;
59333: GO 58585
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59335: LD_ADDR_VAR 0 6
59339: PUSH
59340: LD_EXP 100
59344: PUSH
59345: LD_VAR 0 2
59349: ARRAY
59350: PPUSH
59351: LD_INT 25
59353: PUSH
59354: LD_INT 3
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PPUSH
59361: CALL_OW 72
59365: PUSH
59366: LD_EXP 140
59370: PUSH
59371: LD_VAR 0 2
59375: ARRAY
59376: DIFF
59377: PPUSH
59378: LD_INT 3
59380: PPUSH
59381: CALL 103468 0 2
59385: ST_TO_ADDR
// for j in tmp do
59386: LD_ADDR_VAR 0 3
59390: PUSH
59391: LD_VAR 0 6
59395: PUSH
59396: FOR_IN
59397: IFFALSE 59432
// if GetTag ( j ) > 0 then
59399: LD_VAR 0 3
59403: PPUSH
59404: CALL_OW 110
59408: PUSH
59409: LD_INT 0
59411: GREATER
59412: IFFALSE 59430
// tmp := tmp diff j ;
59414: LD_ADDR_VAR 0 6
59418: PUSH
59419: LD_VAR 0 6
59423: PUSH
59424: LD_VAR 0 3
59428: DIFF
59429: ST_TO_ADDR
59430: GO 59396
59432: POP
59433: POP
// if not tmp then
59434: LD_VAR 0 6
59438: NOT
59439: IFFALSE 59443
// continue ;
59441: GO 58585
// if places then
59443: LD_VAR 0 5
59447: IFFALSE 59506
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59449: LD_ADDR_EXP 140
59453: PUSH
59454: LD_EXP 140
59458: PPUSH
59459: LD_VAR 0 2
59463: PPUSH
59464: LD_EXP 140
59468: PUSH
59469: LD_VAR 0 2
59473: ARRAY
59474: PUSH
59475: LD_VAR 0 6
59479: PUSH
59480: LD_INT 1
59482: ARRAY
59483: UNION
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59490: LD_VAR 0 6
59494: PUSH
59495: LD_INT 1
59497: ARRAY
59498: PPUSH
59499: LD_INT 126
59501: PPUSH
59502: CALL_OW 109
// end ; end ;
59506: GO 58585
59508: POP
59509: POP
// end ;
59510: LD_VAR 0 1
59514: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59515: LD_INT 0
59517: PPUSH
59518: PPUSH
59519: PPUSH
59520: PPUSH
59521: PPUSH
59522: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59523: LD_VAR 0 1
59527: NOT
59528: PUSH
59529: LD_VAR 0 2
59533: NOT
59534: OR
59535: PUSH
59536: LD_VAR 0 3
59540: NOT
59541: OR
59542: PUSH
59543: LD_VAR 0 4
59547: PUSH
59548: LD_INT 1
59550: PUSH
59551: LD_INT 2
59553: PUSH
59554: LD_INT 3
59556: PUSH
59557: LD_INT 4
59559: PUSH
59560: LD_INT 5
59562: PUSH
59563: LD_INT 8
59565: PUSH
59566: LD_INT 9
59568: PUSH
59569: LD_INT 15
59571: PUSH
59572: LD_INT 16
59574: PUSH
59575: EMPTY
59576: LIST
59577: LIST
59578: LIST
59579: LIST
59580: LIST
59581: LIST
59582: LIST
59583: LIST
59584: LIST
59585: IN
59586: NOT
59587: OR
59588: IFFALSE 59592
// exit ;
59590: GO 60492
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59592: LD_ADDR_VAR 0 2
59596: PUSH
59597: LD_VAR 0 2
59601: PPUSH
59602: LD_INT 21
59604: PUSH
59605: LD_INT 3
59607: PUSH
59608: EMPTY
59609: LIST
59610: LIST
59611: PUSH
59612: LD_INT 24
59614: PUSH
59615: LD_INT 250
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PUSH
59622: EMPTY
59623: LIST
59624: LIST
59625: PPUSH
59626: CALL_OW 72
59630: ST_TO_ADDR
// case class of 1 , 15 :
59631: LD_VAR 0 4
59635: PUSH
59636: LD_INT 1
59638: DOUBLE
59639: EQUAL
59640: IFTRUE 59650
59642: LD_INT 15
59644: DOUBLE
59645: EQUAL
59646: IFTRUE 59650
59648: GO 59735
59650: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59651: LD_ADDR_VAR 0 8
59655: PUSH
59656: LD_VAR 0 2
59660: PPUSH
59661: LD_INT 2
59663: PUSH
59664: LD_INT 30
59666: PUSH
59667: LD_INT 32
59669: PUSH
59670: EMPTY
59671: LIST
59672: LIST
59673: PUSH
59674: LD_INT 30
59676: PUSH
59677: LD_INT 31
59679: PUSH
59680: EMPTY
59681: LIST
59682: LIST
59683: PUSH
59684: EMPTY
59685: LIST
59686: LIST
59687: LIST
59688: PPUSH
59689: CALL_OW 72
59693: PUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: LD_INT 2
59701: PUSH
59702: LD_INT 30
59704: PUSH
59705: LD_INT 4
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: LD_INT 30
59714: PUSH
59715: LD_INT 5
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: LIST
59726: PPUSH
59727: CALL_OW 72
59731: ADD
59732: ST_TO_ADDR
59733: GO 59981
59735: LD_INT 2
59737: DOUBLE
59738: EQUAL
59739: IFTRUE 59749
59741: LD_INT 16
59743: DOUBLE
59744: EQUAL
59745: IFTRUE 59749
59747: GO 59795
59749: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59750: LD_ADDR_VAR 0 8
59754: PUSH
59755: LD_VAR 0 2
59759: PPUSH
59760: LD_INT 2
59762: PUSH
59763: LD_INT 30
59765: PUSH
59766: LD_INT 0
59768: PUSH
59769: EMPTY
59770: LIST
59771: LIST
59772: PUSH
59773: LD_INT 30
59775: PUSH
59776: LD_INT 1
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: LIST
59787: PPUSH
59788: CALL_OW 72
59792: ST_TO_ADDR
59793: GO 59981
59795: LD_INT 3
59797: DOUBLE
59798: EQUAL
59799: IFTRUE 59803
59801: GO 59849
59803: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59804: LD_ADDR_VAR 0 8
59808: PUSH
59809: LD_VAR 0 2
59813: PPUSH
59814: LD_INT 2
59816: PUSH
59817: LD_INT 30
59819: PUSH
59820: LD_INT 2
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: PUSH
59827: LD_INT 30
59829: PUSH
59830: LD_INT 3
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: LIST
59841: PPUSH
59842: CALL_OW 72
59846: ST_TO_ADDR
59847: GO 59981
59849: LD_INT 4
59851: DOUBLE
59852: EQUAL
59853: IFTRUE 59857
59855: GO 59914
59857: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59858: LD_ADDR_VAR 0 8
59862: PUSH
59863: LD_VAR 0 2
59867: PPUSH
59868: LD_INT 2
59870: PUSH
59871: LD_INT 30
59873: PUSH
59874: LD_INT 6
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 30
59883: PUSH
59884: LD_INT 7
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 30
59893: PUSH
59894: LD_INT 8
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: LIST
59905: LIST
59906: PPUSH
59907: CALL_OW 72
59911: ST_TO_ADDR
59912: GO 59981
59914: LD_INT 5
59916: DOUBLE
59917: EQUAL
59918: IFTRUE 59934
59920: LD_INT 8
59922: DOUBLE
59923: EQUAL
59924: IFTRUE 59934
59926: LD_INT 9
59928: DOUBLE
59929: EQUAL
59930: IFTRUE 59934
59932: GO 59980
59934: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59935: LD_ADDR_VAR 0 8
59939: PUSH
59940: LD_VAR 0 2
59944: PPUSH
59945: LD_INT 2
59947: PUSH
59948: LD_INT 30
59950: PUSH
59951: LD_INT 4
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: PUSH
59958: LD_INT 30
59960: PUSH
59961: LD_INT 5
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: LIST
59972: PPUSH
59973: CALL_OW 72
59977: ST_TO_ADDR
59978: GO 59981
59980: POP
// if not tmp then
59981: LD_VAR 0 8
59985: NOT
59986: IFFALSE 59990
// exit ;
59988: GO 60492
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59990: LD_VAR 0 4
59994: PUSH
59995: LD_INT 1
59997: PUSH
59998: LD_INT 15
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: IN
60005: PUSH
60006: LD_EXP 109
60010: PUSH
60011: LD_VAR 0 1
60015: ARRAY
60016: AND
60017: IFFALSE 60173
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
60019: LD_ADDR_VAR 0 9
60023: PUSH
60024: LD_EXP 109
60028: PUSH
60029: LD_VAR 0 1
60033: ARRAY
60034: PUSH
60035: LD_INT 1
60037: ARRAY
60038: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
60039: LD_VAR 0 9
60043: PUSH
60044: LD_EXP 110
60048: PUSH
60049: LD_VAR 0 1
60053: ARRAY
60054: IN
60055: NOT
60056: IFFALSE 60171
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
60058: LD_ADDR_EXP 110
60062: PUSH
60063: LD_EXP 110
60067: PPUSH
60068: LD_VAR 0 1
60072: PUSH
60073: LD_EXP 110
60077: PUSH
60078: LD_VAR 0 1
60082: ARRAY
60083: PUSH
60084: LD_INT 1
60086: PLUS
60087: PUSH
60088: EMPTY
60089: LIST
60090: LIST
60091: PPUSH
60092: LD_VAR 0 9
60096: PPUSH
60097: CALL 72647 0 3
60101: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
60102: LD_ADDR_EXP 109
60106: PUSH
60107: LD_EXP 109
60111: PPUSH
60112: LD_VAR 0 1
60116: PPUSH
60117: LD_EXP 109
60121: PUSH
60122: LD_VAR 0 1
60126: ARRAY
60127: PUSH
60128: LD_VAR 0 9
60132: DIFF
60133: PPUSH
60134: CALL_OW 1
60138: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
60139: LD_VAR 0 3
60143: PPUSH
60144: LD_EXP 110
60148: PUSH
60149: LD_VAR 0 1
60153: ARRAY
60154: PUSH
60155: LD_EXP 110
60159: PUSH
60160: LD_VAR 0 1
60164: ARRAY
60165: ARRAY
60166: PPUSH
60167: CALL_OW 120
// end ; exit ;
60171: GO 60492
// end ; if tmp > 1 then
60173: LD_VAR 0 8
60177: PUSH
60178: LD_INT 1
60180: GREATER
60181: IFFALSE 60285
// for i = 2 to tmp do
60183: LD_ADDR_VAR 0 6
60187: PUSH
60188: DOUBLE
60189: LD_INT 2
60191: DEC
60192: ST_TO_ADDR
60193: LD_VAR 0 8
60197: PUSH
60198: FOR_TO
60199: IFFALSE 60283
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60201: LD_VAR 0 8
60205: PUSH
60206: LD_VAR 0 6
60210: ARRAY
60211: PPUSH
60212: CALL_OW 461
60216: PUSH
60217: LD_INT 6
60219: EQUAL
60220: IFFALSE 60281
// begin x := tmp [ i ] ;
60222: LD_ADDR_VAR 0 9
60226: PUSH
60227: LD_VAR 0 8
60231: PUSH
60232: LD_VAR 0 6
60236: ARRAY
60237: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60238: LD_ADDR_VAR 0 8
60242: PUSH
60243: LD_VAR 0 8
60247: PPUSH
60248: LD_VAR 0 6
60252: PPUSH
60253: CALL_OW 3
60257: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60258: LD_ADDR_VAR 0 8
60262: PUSH
60263: LD_VAR 0 8
60267: PPUSH
60268: LD_INT 1
60270: PPUSH
60271: LD_VAR 0 9
60275: PPUSH
60276: CALL_OW 2
60280: ST_TO_ADDR
// end ;
60281: GO 60198
60283: POP
60284: POP
// for i in tmp do
60285: LD_ADDR_VAR 0 6
60289: PUSH
60290: LD_VAR 0 8
60294: PUSH
60295: FOR_IN
60296: IFFALSE 60365
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60298: LD_VAR 0 6
60302: PPUSH
60303: CALL_OW 313
60307: PUSH
60308: LD_INT 6
60310: LESS
60311: PUSH
60312: LD_VAR 0 6
60316: PPUSH
60317: CALL_OW 266
60321: PUSH
60322: LD_INT 31
60324: PUSH
60325: LD_INT 32
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: IN
60332: NOT
60333: AND
60334: PUSH
60335: LD_VAR 0 6
60339: PPUSH
60340: CALL_OW 313
60344: PUSH
60345: LD_INT 0
60347: EQUAL
60348: OR
60349: IFFALSE 60363
// begin j := i ;
60351: LD_ADDR_VAR 0 7
60355: PUSH
60356: LD_VAR 0 6
60360: ST_TO_ADDR
// break ;
60361: GO 60365
// end ; end ;
60363: GO 60295
60365: POP
60366: POP
// if j then
60367: LD_VAR 0 7
60371: IFFALSE 60389
// ComEnterUnit ( unit , j ) else
60373: LD_VAR 0 3
60377: PPUSH
60378: LD_VAR 0 7
60382: PPUSH
60383: CALL_OW 120
60387: GO 60492
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60389: LD_ADDR_VAR 0 10
60393: PUSH
60394: LD_VAR 0 2
60398: PPUSH
60399: LD_INT 2
60401: PUSH
60402: LD_INT 30
60404: PUSH
60405: LD_INT 0
60407: PUSH
60408: EMPTY
60409: LIST
60410: LIST
60411: PUSH
60412: LD_INT 30
60414: PUSH
60415: LD_INT 1
60417: PUSH
60418: EMPTY
60419: LIST
60420: LIST
60421: PUSH
60422: EMPTY
60423: LIST
60424: LIST
60425: LIST
60426: PPUSH
60427: CALL_OW 72
60431: ST_TO_ADDR
// if depot then
60432: LD_VAR 0 10
60436: IFFALSE 60492
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60438: LD_ADDR_VAR 0 10
60442: PUSH
60443: LD_VAR 0 10
60447: PPUSH
60448: LD_VAR 0 3
60452: PPUSH
60453: CALL_OW 74
60457: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60458: LD_VAR 0 3
60462: PPUSH
60463: LD_VAR 0 10
60467: PPUSH
60468: CALL_OW 296
60472: PUSH
60473: LD_INT 10
60475: GREATER
60476: IFFALSE 60492
// ComStandNearbyBuilding ( unit , depot ) ;
60478: LD_VAR 0 3
60482: PPUSH
60483: LD_VAR 0 10
60487: PPUSH
60488: CALL 69074 0 2
// end ; end ; end ;
60492: LD_VAR 0 5
60496: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60497: LD_INT 0
60499: PPUSH
60500: PPUSH
60501: PPUSH
60502: PPUSH
// if not mc_bases then
60503: LD_EXP 100
60507: NOT
60508: IFFALSE 60512
// exit ;
60510: GO 60751
// for i = 1 to mc_bases do
60512: LD_ADDR_VAR 0 2
60516: PUSH
60517: DOUBLE
60518: LD_INT 1
60520: DEC
60521: ST_TO_ADDR
60522: LD_EXP 100
60526: PUSH
60527: FOR_TO
60528: IFFALSE 60749
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60530: LD_ADDR_VAR 0 4
60534: PUSH
60535: LD_EXP 100
60539: PUSH
60540: LD_VAR 0 2
60544: ARRAY
60545: PPUSH
60546: LD_INT 21
60548: PUSH
60549: LD_INT 1
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PPUSH
60556: CALL_OW 72
60560: PUSH
60561: LD_EXP 129
60565: PUSH
60566: LD_VAR 0 2
60570: ARRAY
60571: UNION
60572: ST_TO_ADDR
// if not tmp then
60573: LD_VAR 0 4
60577: NOT
60578: IFFALSE 60582
// continue ;
60580: GO 60527
// for j in tmp do
60582: LD_ADDR_VAR 0 3
60586: PUSH
60587: LD_VAR 0 4
60591: PUSH
60592: FOR_IN
60593: IFFALSE 60745
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60595: LD_VAR 0 3
60599: PPUSH
60600: CALL_OW 110
60604: NOT
60605: PUSH
60606: LD_VAR 0 3
60610: PPUSH
60611: CALL_OW 314
60615: NOT
60616: AND
60617: PUSH
60618: LD_VAR 0 3
60622: PPUSH
60623: CALL_OW 311
60627: NOT
60628: AND
60629: PUSH
60630: LD_VAR 0 3
60634: PPUSH
60635: CALL_OW 310
60639: NOT
60640: AND
60641: PUSH
60642: LD_VAR 0 3
60646: PUSH
60647: LD_EXP 103
60651: PUSH
60652: LD_VAR 0 2
60656: ARRAY
60657: PUSH
60658: LD_INT 1
60660: ARRAY
60661: IN
60662: NOT
60663: AND
60664: PUSH
60665: LD_VAR 0 3
60669: PUSH
60670: LD_EXP 103
60674: PUSH
60675: LD_VAR 0 2
60679: ARRAY
60680: PUSH
60681: LD_INT 2
60683: ARRAY
60684: IN
60685: NOT
60686: AND
60687: PUSH
60688: LD_VAR 0 3
60692: PUSH
60693: LD_EXP 112
60697: PUSH
60698: LD_VAR 0 2
60702: ARRAY
60703: IN
60704: NOT
60705: AND
60706: IFFALSE 60743
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60708: LD_VAR 0 2
60712: PPUSH
60713: LD_EXP 100
60717: PUSH
60718: LD_VAR 0 2
60722: ARRAY
60723: PPUSH
60724: LD_VAR 0 3
60728: PPUSH
60729: LD_VAR 0 3
60733: PPUSH
60734: CALL_OW 257
60738: PPUSH
60739: CALL 59515 0 4
// end ;
60743: GO 60592
60745: POP
60746: POP
// end ;
60747: GO 60527
60749: POP
60750: POP
// end ;
60751: LD_VAR 0 1
60755: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60756: LD_INT 0
60758: PPUSH
60759: PPUSH
60760: PPUSH
60761: PPUSH
60762: PPUSH
60763: PPUSH
// if not mc_bases [ base ] then
60764: LD_EXP 100
60768: PUSH
60769: LD_VAR 0 1
60773: ARRAY
60774: NOT
60775: IFFALSE 60779
// exit ;
60777: GO 60961
// tmp := [ ] ;
60779: LD_ADDR_VAR 0 6
60783: PUSH
60784: EMPTY
60785: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60786: LD_ADDR_VAR 0 7
60790: PUSH
60791: LD_VAR 0 3
60795: PPUSH
60796: LD_INT 0
60798: PPUSH
60799: CALL_OW 517
60803: ST_TO_ADDR
// if not list then
60804: LD_VAR 0 7
60808: NOT
60809: IFFALSE 60813
// exit ;
60811: GO 60961
// for i = 1 to amount do
60813: LD_ADDR_VAR 0 5
60817: PUSH
60818: DOUBLE
60819: LD_INT 1
60821: DEC
60822: ST_TO_ADDR
60823: LD_VAR 0 2
60827: PUSH
60828: FOR_TO
60829: IFFALSE 60909
// begin x := rand ( 1 , list [ 1 ] ) ;
60831: LD_ADDR_VAR 0 8
60835: PUSH
60836: LD_INT 1
60838: PPUSH
60839: LD_VAR 0 7
60843: PUSH
60844: LD_INT 1
60846: ARRAY
60847: PPUSH
60848: CALL_OW 12
60852: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60853: LD_ADDR_VAR 0 6
60857: PUSH
60858: LD_VAR 0 6
60862: PPUSH
60863: LD_VAR 0 5
60867: PPUSH
60868: LD_VAR 0 7
60872: PUSH
60873: LD_INT 1
60875: ARRAY
60876: PUSH
60877: LD_VAR 0 8
60881: ARRAY
60882: PUSH
60883: LD_VAR 0 7
60887: PUSH
60888: LD_INT 2
60890: ARRAY
60891: PUSH
60892: LD_VAR 0 8
60896: ARRAY
60897: PUSH
60898: EMPTY
60899: LIST
60900: LIST
60901: PPUSH
60902: CALL_OW 1
60906: ST_TO_ADDR
// end ;
60907: GO 60828
60909: POP
60910: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60911: LD_ADDR_EXP 113
60915: PUSH
60916: LD_EXP 113
60920: PPUSH
60921: LD_VAR 0 1
60925: PPUSH
60926: LD_VAR 0 6
60930: PPUSH
60931: CALL_OW 1
60935: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60936: LD_ADDR_EXP 115
60940: PUSH
60941: LD_EXP 115
60945: PPUSH
60946: LD_VAR 0 1
60950: PPUSH
60951: LD_VAR 0 3
60955: PPUSH
60956: CALL_OW 1
60960: ST_TO_ADDR
// end ;
60961: LD_VAR 0 4
60965: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60966: LD_INT 0
60968: PPUSH
// if not mc_bases [ base ] then
60969: LD_EXP 100
60973: PUSH
60974: LD_VAR 0 1
60978: ARRAY
60979: NOT
60980: IFFALSE 60984
// exit ;
60982: GO 61009
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60984: LD_ADDR_EXP 105
60988: PUSH
60989: LD_EXP 105
60993: PPUSH
60994: LD_VAR 0 1
60998: PPUSH
60999: LD_VAR 0 2
61003: PPUSH
61004: CALL_OW 1
61008: ST_TO_ADDR
// end ;
61009: LD_VAR 0 3
61013: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
61014: LD_INT 0
61016: PPUSH
// if not mc_bases [ base ] then
61017: LD_EXP 100
61021: PUSH
61022: LD_VAR 0 1
61026: ARRAY
61027: NOT
61028: IFFALSE 61032
// exit ;
61030: GO 61069
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
61032: LD_ADDR_EXP 105
61036: PUSH
61037: LD_EXP 105
61041: PPUSH
61042: LD_VAR 0 1
61046: PPUSH
61047: LD_EXP 105
61051: PUSH
61052: LD_VAR 0 1
61056: ARRAY
61057: PUSH
61058: LD_VAR 0 2
61062: UNION
61063: PPUSH
61064: CALL_OW 1
61068: ST_TO_ADDR
// end ;
61069: LD_VAR 0 3
61073: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
61074: LD_INT 0
61076: PPUSH
// if not mc_bases [ base ] then
61077: LD_EXP 100
61081: PUSH
61082: LD_VAR 0 1
61086: ARRAY
61087: NOT
61088: IFFALSE 61092
// exit ;
61090: GO 61117
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
61092: LD_ADDR_EXP 121
61096: PUSH
61097: LD_EXP 121
61101: PPUSH
61102: LD_VAR 0 1
61106: PPUSH
61107: LD_VAR 0 2
61111: PPUSH
61112: CALL_OW 1
61116: ST_TO_ADDR
// end ;
61117: LD_VAR 0 3
61121: RET
// export function MC_InsertProduceList ( base , components ) ; begin
61122: LD_INT 0
61124: PPUSH
// if not mc_bases [ base ] then
61125: LD_EXP 100
61129: PUSH
61130: LD_VAR 0 1
61134: ARRAY
61135: NOT
61136: IFFALSE 61140
// exit ;
61138: GO 61177
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
61140: LD_ADDR_EXP 121
61144: PUSH
61145: LD_EXP 121
61149: PPUSH
61150: LD_VAR 0 1
61154: PPUSH
61155: LD_EXP 121
61159: PUSH
61160: LD_VAR 0 1
61164: ARRAY
61165: PUSH
61166: LD_VAR 0 2
61170: ADD
61171: PPUSH
61172: CALL_OW 1
61176: ST_TO_ADDR
// end ;
61177: LD_VAR 0 3
61181: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61182: LD_INT 0
61184: PPUSH
// if not mc_bases [ base ] then
61185: LD_EXP 100
61189: PUSH
61190: LD_VAR 0 1
61194: ARRAY
61195: NOT
61196: IFFALSE 61200
// exit ;
61198: GO 61254
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61200: LD_ADDR_EXP 122
61204: PUSH
61205: LD_EXP 122
61209: PPUSH
61210: LD_VAR 0 1
61214: PPUSH
61215: LD_VAR 0 2
61219: PPUSH
61220: CALL_OW 1
61224: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61225: LD_ADDR_EXP 111
61229: PUSH
61230: LD_EXP 111
61234: PPUSH
61235: LD_VAR 0 1
61239: PPUSH
61240: LD_VAR 0 2
61244: PUSH
61245: LD_INT 0
61247: PLUS
61248: PPUSH
61249: CALL_OW 1
61253: ST_TO_ADDR
// end ;
61254: LD_VAR 0 3
61258: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61259: LD_INT 0
61261: PPUSH
// if not mc_bases [ base ] then
61262: LD_EXP 100
61266: PUSH
61267: LD_VAR 0 1
61271: ARRAY
61272: NOT
61273: IFFALSE 61277
// exit ;
61275: GO 61302
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61277: LD_ADDR_EXP 111
61281: PUSH
61282: LD_EXP 111
61286: PPUSH
61287: LD_VAR 0 1
61291: PPUSH
61292: LD_VAR 0 2
61296: PPUSH
61297: CALL_OW 1
61301: ST_TO_ADDR
// end ;
61302: LD_VAR 0 3
61306: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61307: LD_INT 0
61309: PPUSH
61310: PPUSH
61311: PPUSH
61312: PPUSH
// if not mc_bases [ base ] then
61313: LD_EXP 100
61317: PUSH
61318: LD_VAR 0 1
61322: ARRAY
61323: NOT
61324: IFFALSE 61328
// exit ;
61326: GO 61393
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61328: LD_ADDR_EXP 120
61332: PUSH
61333: LD_EXP 120
61337: PPUSH
61338: LD_VAR 0 1
61342: PUSH
61343: LD_EXP 120
61347: PUSH
61348: LD_VAR 0 1
61352: ARRAY
61353: PUSH
61354: LD_INT 1
61356: PLUS
61357: PUSH
61358: EMPTY
61359: LIST
61360: LIST
61361: PPUSH
61362: LD_VAR 0 1
61366: PUSH
61367: LD_VAR 0 2
61371: PUSH
61372: LD_VAR 0 3
61376: PUSH
61377: LD_VAR 0 4
61381: PUSH
61382: EMPTY
61383: LIST
61384: LIST
61385: LIST
61386: LIST
61387: PPUSH
61388: CALL 72647 0 3
61392: ST_TO_ADDR
// end ;
61393: LD_VAR 0 5
61397: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61398: LD_INT 0
61400: PPUSH
// if not mc_bases [ base ] then
61401: LD_EXP 100
61405: PUSH
61406: LD_VAR 0 1
61410: ARRAY
61411: NOT
61412: IFFALSE 61416
// exit ;
61414: GO 61441
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61416: LD_ADDR_EXP 137
61420: PUSH
61421: LD_EXP 137
61425: PPUSH
61426: LD_VAR 0 1
61430: PPUSH
61431: LD_VAR 0 2
61435: PPUSH
61436: CALL_OW 1
61440: ST_TO_ADDR
// end ;
61441: LD_VAR 0 3
61445: RET
// export function MC_GetMinesField ( base ) ; begin
61446: LD_INT 0
61448: PPUSH
// result := mc_mines [ base ] ;
61449: LD_ADDR_VAR 0 2
61453: PUSH
61454: LD_EXP 113
61458: PUSH
61459: LD_VAR 0 1
61463: ARRAY
61464: ST_TO_ADDR
// end ;
61465: LD_VAR 0 2
61469: RET
// export function MC_GetProduceList ( base ) ; begin
61470: LD_INT 0
61472: PPUSH
// result := mc_produce [ base ] ;
61473: LD_ADDR_VAR 0 2
61477: PUSH
61478: LD_EXP 121
61482: PUSH
61483: LD_VAR 0 1
61487: ARRAY
61488: ST_TO_ADDR
// end ;
61489: LD_VAR 0 2
61493: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61494: LD_INT 0
61496: PPUSH
61497: PPUSH
// if not mc_bases then
61498: LD_EXP 100
61502: NOT
61503: IFFALSE 61507
// exit ;
61505: GO 61572
// if mc_bases [ base ] then
61507: LD_EXP 100
61511: PUSH
61512: LD_VAR 0 1
61516: ARRAY
61517: IFFALSE 61572
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61519: LD_ADDR_VAR 0 3
61523: PUSH
61524: LD_EXP 100
61528: PUSH
61529: LD_VAR 0 1
61533: ARRAY
61534: PPUSH
61535: LD_INT 30
61537: PUSH
61538: LD_VAR 0 2
61542: PUSH
61543: EMPTY
61544: LIST
61545: LIST
61546: PPUSH
61547: CALL_OW 72
61551: ST_TO_ADDR
// if result then
61552: LD_VAR 0 3
61556: IFFALSE 61572
// result := result [ 1 ] ;
61558: LD_ADDR_VAR 0 3
61562: PUSH
61563: LD_VAR 0 3
61567: PUSH
61568: LD_INT 1
61570: ARRAY
61571: ST_TO_ADDR
// end ; end ;
61572: LD_VAR 0 3
61576: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61577: LD_INT 0
61579: PPUSH
61580: PPUSH
// if not mc_bases then
61581: LD_EXP 100
61585: NOT
61586: IFFALSE 61590
// exit ;
61588: GO 61635
// if mc_bases [ base ] then
61590: LD_EXP 100
61594: PUSH
61595: LD_VAR 0 1
61599: ARRAY
61600: IFFALSE 61635
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61602: LD_ADDR_VAR 0 3
61606: PUSH
61607: LD_EXP 100
61611: PUSH
61612: LD_VAR 0 1
61616: ARRAY
61617: PPUSH
61618: LD_INT 30
61620: PUSH
61621: LD_VAR 0 2
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: PPUSH
61630: CALL_OW 72
61634: ST_TO_ADDR
// end ;
61635: LD_VAR 0 3
61639: RET
// export function MC_SetTame ( base , area ) ; begin
61640: LD_INT 0
61642: PPUSH
// if not mc_bases or not base then
61643: LD_EXP 100
61647: NOT
61648: PUSH
61649: LD_VAR 0 1
61653: NOT
61654: OR
61655: IFFALSE 61659
// exit ;
61657: GO 61684
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61659: LD_ADDR_EXP 128
61663: PUSH
61664: LD_EXP 128
61668: PPUSH
61669: LD_VAR 0 1
61673: PPUSH
61674: LD_VAR 0 2
61678: PPUSH
61679: CALL_OW 1
61683: ST_TO_ADDR
// end ;
61684: LD_VAR 0 3
61688: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61689: LD_INT 0
61691: PPUSH
61692: PPUSH
// if not mc_bases or not base then
61693: LD_EXP 100
61697: NOT
61698: PUSH
61699: LD_VAR 0 1
61703: NOT
61704: OR
61705: IFFALSE 61709
// exit ;
61707: GO 61811
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61709: LD_ADDR_VAR 0 4
61713: PUSH
61714: LD_EXP 100
61718: PUSH
61719: LD_VAR 0 1
61723: ARRAY
61724: PPUSH
61725: LD_INT 30
61727: PUSH
61728: LD_VAR 0 2
61732: PUSH
61733: EMPTY
61734: LIST
61735: LIST
61736: PPUSH
61737: CALL_OW 72
61741: ST_TO_ADDR
// if not tmp then
61742: LD_VAR 0 4
61746: NOT
61747: IFFALSE 61751
// exit ;
61749: GO 61811
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61751: LD_ADDR_EXP 132
61755: PUSH
61756: LD_EXP 132
61760: PPUSH
61761: LD_VAR 0 1
61765: PPUSH
61766: LD_EXP 132
61770: PUSH
61771: LD_VAR 0 1
61775: ARRAY
61776: PPUSH
61777: LD_EXP 132
61781: PUSH
61782: LD_VAR 0 1
61786: ARRAY
61787: PUSH
61788: LD_INT 1
61790: PLUS
61791: PPUSH
61792: LD_VAR 0 4
61796: PUSH
61797: LD_INT 1
61799: ARRAY
61800: PPUSH
61801: CALL_OW 2
61805: PPUSH
61806: CALL_OW 1
61810: ST_TO_ADDR
// end ;
61811: LD_VAR 0 3
61815: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61816: LD_INT 0
61818: PPUSH
61819: PPUSH
// if not mc_bases or not base or not kinds then
61820: LD_EXP 100
61824: NOT
61825: PUSH
61826: LD_VAR 0 1
61830: NOT
61831: OR
61832: PUSH
61833: LD_VAR 0 2
61837: NOT
61838: OR
61839: IFFALSE 61843
// exit ;
61841: GO 61904
// for i in kinds do
61843: LD_ADDR_VAR 0 4
61847: PUSH
61848: LD_VAR 0 2
61852: PUSH
61853: FOR_IN
61854: IFFALSE 61902
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61856: LD_ADDR_EXP 134
61860: PUSH
61861: LD_EXP 134
61865: PPUSH
61866: LD_VAR 0 1
61870: PUSH
61871: LD_EXP 134
61875: PUSH
61876: LD_VAR 0 1
61880: ARRAY
61881: PUSH
61882: LD_INT 1
61884: PLUS
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: PPUSH
61890: LD_VAR 0 4
61894: PPUSH
61895: CALL 72647 0 3
61899: ST_TO_ADDR
61900: GO 61853
61902: POP
61903: POP
// end ;
61904: LD_VAR 0 3
61908: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61909: LD_INT 0
61911: PPUSH
// if not mc_bases or not base or not areas then
61912: LD_EXP 100
61916: NOT
61917: PUSH
61918: LD_VAR 0 1
61922: NOT
61923: OR
61924: PUSH
61925: LD_VAR 0 2
61929: NOT
61930: OR
61931: IFFALSE 61935
// exit ;
61933: GO 61960
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61935: LD_ADDR_EXP 118
61939: PUSH
61940: LD_EXP 118
61944: PPUSH
61945: LD_VAR 0 1
61949: PPUSH
61950: LD_VAR 0 2
61954: PPUSH
61955: CALL_OW 1
61959: ST_TO_ADDR
// end ;
61960: LD_VAR 0 3
61964: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61965: LD_INT 0
61967: PPUSH
// if not mc_bases or not base or not teleports_exit then
61968: LD_EXP 100
61972: NOT
61973: PUSH
61974: LD_VAR 0 1
61978: NOT
61979: OR
61980: PUSH
61981: LD_VAR 0 2
61985: NOT
61986: OR
61987: IFFALSE 61991
// exit ;
61989: GO 62016
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61991: LD_ADDR_EXP 135
61995: PUSH
61996: LD_EXP 135
62000: PPUSH
62001: LD_VAR 0 1
62005: PPUSH
62006: LD_VAR 0 2
62010: PPUSH
62011: CALL_OW 1
62015: ST_TO_ADDR
// end ;
62016: LD_VAR 0 3
62020: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
62021: LD_INT 0
62023: PPUSH
62024: PPUSH
62025: PPUSH
// if not mc_bases or not base or not ext_list then
62026: LD_EXP 100
62030: NOT
62031: PUSH
62032: LD_VAR 0 1
62036: NOT
62037: OR
62038: PUSH
62039: LD_VAR 0 5
62043: NOT
62044: OR
62045: IFFALSE 62049
// exit ;
62047: GO 62222
// tmp := GetFacExtXYD ( x , y , d ) ;
62049: LD_ADDR_VAR 0 8
62053: PUSH
62054: LD_VAR 0 2
62058: PPUSH
62059: LD_VAR 0 3
62063: PPUSH
62064: LD_VAR 0 4
62068: PPUSH
62069: CALL 102598 0 3
62073: ST_TO_ADDR
// if not tmp then
62074: LD_VAR 0 8
62078: NOT
62079: IFFALSE 62083
// exit ;
62081: GO 62222
// for i in tmp do
62083: LD_ADDR_VAR 0 7
62087: PUSH
62088: LD_VAR 0 8
62092: PUSH
62093: FOR_IN
62094: IFFALSE 62220
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
62096: LD_ADDR_EXP 105
62100: PUSH
62101: LD_EXP 105
62105: PPUSH
62106: LD_VAR 0 1
62110: PPUSH
62111: LD_EXP 105
62115: PUSH
62116: LD_VAR 0 1
62120: ARRAY
62121: PPUSH
62122: LD_EXP 105
62126: PUSH
62127: LD_VAR 0 1
62131: ARRAY
62132: PUSH
62133: LD_INT 1
62135: PLUS
62136: PPUSH
62137: LD_VAR 0 5
62141: PUSH
62142: LD_INT 1
62144: ARRAY
62145: PUSH
62146: LD_VAR 0 7
62150: PUSH
62151: LD_INT 1
62153: ARRAY
62154: PUSH
62155: LD_VAR 0 7
62159: PUSH
62160: LD_INT 2
62162: ARRAY
62163: PUSH
62164: LD_VAR 0 7
62168: PUSH
62169: LD_INT 3
62171: ARRAY
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: PPUSH
62179: CALL_OW 2
62183: PPUSH
62184: CALL_OW 1
62188: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62189: LD_ADDR_VAR 0 5
62193: PUSH
62194: LD_VAR 0 5
62198: PPUSH
62199: LD_INT 1
62201: PPUSH
62202: CALL_OW 3
62206: ST_TO_ADDR
// if not ext_list then
62207: LD_VAR 0 5
62211: NOT
62212: IFFALSE 62218
// exit ;
62214: POP
62215: POP
62216: GO 62222
// end ;
62218: GO 62093
62220: POP
62221: POP
// end ;
62222: LD_VAR 0 6
62226: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62227: LD_INT 0
62229: PPUSH
// if not mc_bases or not base or not weapon_list then
62230: LD_EXP 100
62234: NOT
62235: PUSH
62236: LD_VAR 0 1
62240: NOT
62241: OR
62242: PUSH
62243: LD_VAR 0 2
62247: NOT
62248: OR
62249: IFFALSE 62253
// exit ;
62251: GO 62278
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62253: LD_ADDR_EXP 139
62257: PUSH
62258: LD_EXP 139
62262: PPUSH
62263: LD_VAR 0 1
62267: PPUSH
62268: LD_VAR 0 2
62272: PPUSH
62273: CALL_OW 1
62277: ST_TO_ADDR
// end ;
62278: LD_VAR 0 3
62282: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62283: LD_INT 0
62285: PPUSH
// if not mc_bases or not base or not tech_list then
62286: LD_EXP 100
62290: NOT
62291: PUSH
62292: LD_VAR 0 1
62296: NOT
62297: OR
62298: PUSH
62299: LD_VAR 0 2
62303: NOT
62304: OR
62305: IFFALSE 62309
// exit ;
62307: GO 62334
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62309: LD_ADDR_EXP 127
62313: PUSH
62314: LD_EXP 127
62318: PPUSH
62319: LD_VAR 0 1
62323: PPUSH
62324: LD_VAR 0 2
62328: PPUSH
62329: CALL_OW 1
62333: ST_TO_ADDR
// end ;
62334: LD_VAR 0 3
62338: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62339: LD_INT 0
62341: PPUSH
// if not mc_bases or not parking_area or not base then
62342: LD_EXP 100
62346: NOT
62347: PUSH
62348: LD_VAR 0 2
62352: NOT
62353: OR
62354: PUSH
62355: LD_VAR 0 1
62359: NOT
62360: OR
62361: IFFALSE 62365
// exit ;
62363: GO 62390
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62365: LD_ADDR_EXP 124
62369: PUSH
62370: LD_EXP 124
62374: PPUSH
62375: LD_VAR 0 1
62379: PPUSH
62380: LD_VAR 0 2
62384: PPUSH
62385: CALL_OW 1
62389: ST_TO_ADDR
// end ;
62390: LD_VAR 0 3
62394: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62395: LD_INT 0
62397: PPUSH
// if not mc_bases or not base or not scan_area then
62398: LD_EXP 100
62402: NOT
62403: PUSH
62404: LD_VAR 0 1
62408: NOT
62409: OR
62410: PUSH
62411: LD_VAR 0 2
62415: NOT
62416: OR
62417: IFFALSE 62421
// exit ;
62419: GO 62446
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62421: LD_ADDR_EXP 125
62425: PUSH
62426: LD_EXP 125
62430: PPUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: LD_VAR 0 2
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// end ;
62446: LD_VAR 0 3
62450: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62451: LD_INT 0
62453: PPUSH
62454: PPUSH
// if not mc_bases or not base then
62455: LD_EXP 100
62459: NOT
62460: PUSH
62461: LD_VAR 0 1
62465: NOT
62466: OR
62467: IFFALSE 62471
// exit ;
62469: GO 62535
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62471: LD_ADDR_VAR 0 3
62475: PUSH
62476: LD_INT 1
62478: PUSH
62479: LD_INT 2
62481: PUSH
62482: LD_INT 3
62484: PUSH
62485: LD_INT 4
62487: PUSH
62488: LD_INT 11
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: LIST
62495: LIST
62496: LIST
62497: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62498: LD_ADDR_EXP 127
62502: PUSH
62503: LD_EXP 127
62507: PPUSH
62508: LD_VAR 0 1
62512: PPUSH
62513: LD_EXP 127
62517: PUSH
62518: LD_VAR 0 1
62522: ARRAY
62523: PUSH
62524: LD_VAR 0 3
62528: DIFF
62529: PPUSH
62530: CALL_OW 1
62534: ST_TO_ADDR
// end ;
62535: LD_VAR 0 2
62539: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62540: LD_INT 0
62542: PPUSH
// result := mc_vehicles [ base ] ;
62543: LD_ADDR_VAR 0 3
62547: PUSH
62548: LD_EXP 119
62552: PUSH
62553: LD_VAR 0 1
62557: ARRAY
62558: ST_TO_ADDR
// if onlyCombat then
62559: LD_VAR 0 2
62563: IFFALSE 62735
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62565: LD_ADDR_VAR 0 3
62569: PUSH
62570: LD_VAR 0 3
62574: PUSH
62575: LD_VAR 0 3
62579: PPUSH
62580: LD_INT 2
62582: PUSH
62583: LD_INT 34
62585: PUSH
62586: LD_INT 12
62588: PUSH
62589: EMPTY
62590: LIST
62591: LIST
62592: PUSH
62593: LD_INT 34
62595: PUSH
62596: LD_INT 51
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: PUSH
62603: LD_INT 34
62605: PUSH
62606: LD_INT 89
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PUSH
62613: LD_INT 34
62615: PUSH
62616: LD_INT 32
62618: PUSH
62619: EMPTY
62620: LIST
62621: LIST
62622: PUSH
62623: LD_INT 34
62625: PUSH
62626: LD_INT 13
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: PUSH
62633: LD_INT 34
62635: PUSH
62636: LD_INT 52
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: PUSH
62643: LD_INT 34
62645: PUSH
62646: LD_INT 88
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 34
62655: PUSH
62656: LD_INT 14
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PUSH
62663: LD_INT 34
62665: PUSH
62666: LD_INT 53
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: PUSH
62673: LD_INT 34
62675: PUSH
62676: LD_INT 98
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: PUSH
62683: LD_INT 34
62685: PUSH
62686: LD_INT 31
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_INT 34
62695: PUSH
62696: LD_INT 48
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: PUSH
62703: LD_INT 34
62705: PUSH
62706: LD_INT 8
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: EMPTY
62714: LIST
62715: LIST
62716: LIST
62717: LIST
62718: LIST
62719: LIST
62720: LIST
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: LIST
62727: LIST
62728: PPUSH
62729: CALL_OW 72
62733: DIFF
62734: ST_TO_ADDR
// end ; end_of_file
62735: LD_VAR 0 3
62739: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62740: LD_INT 0
62742: PPUSH
62743: PPUSH
62744: PPUSH
// if not mc_bases or not skirmish then
62745: LD_EXP 100
62749: NOT
62750: PUSH
62751: LD_EXP 98
62755: NOT
62756: OR
62757: IFFALSE 62761
// exit ;
62759: GO 62926
// for i = 1 to mc_bases do
62761: LD_ADDR_VAR 0 4
62765: PUSH
62766: DOUBLE
62767: LD_INT 1
62769: DEC
62770: ST_TO_ADDR
62771: LD_EXP 100
62775: PUSH
62776: FOR_TO
62777: IFFALSE 62924
// begin if sci in mc_bases [ i ] then
62779: LD_VAR 0 2
62783: PUSH
62784: LD_EXP 100
62788: PUSH
62789: LD_VAR 0 4
62793: ARRAY
62794: IN
62795: IFFALSE 62922
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62797: LD_ADDR_EXP 129
62801: PUSH
62802: LD_EXP 129
62806: PPUSH
62807: LD_VAR 0 4
62811: PUSH
62812: LD_EXP 129
62816: PUSH
62817: LD_VAR 0 4
62821: ARRAY
62822: PUSH
62823: LD_INT 1
62825: PLUS
62826: PUSH
62827: EMPTY
62828: LIST
62829: LIST
62830: PPUSH
62831: LD_VAR 0 1
62835: PPUSH
62836: CALL 72647 0 3
62840: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62841: LD_ADDR_VAR 0 5
62845: PUSH
62846: LD_EXP 100
62850: PUSH
62851: LD_VAR 0 4
62855: ARRAY
62856: PPUSH
62857: LD_INT 2
62859: PUSH
62860: LD_INT 30
62862: PUSH
62863: LD_INT 0
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 30
62872: PUSH
62873: LD_INT 1
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: LIST
62884: PPUSH
62885: CALL_OW 72
62889: PPUSH
62890: LD_VAR 0 1
62894: PPUSH
62895: CALL_OW 74
62899: ST_TO_ADDR
// if tmp then
62900: LD_VAR 0 5
62904: IFFALSE 62920
// ComStandNearbyBuilding ( ape , tmp ) ;
62906: LD_VAR 0 1
62910: PPUSH
62911: LD_VAR 0 5
62915: PPUSH
62916: CALL 69074 0 2
// break ;
62920: GO 62924
// end ; end ;
62922: GO 62776
62924: POP
62925: POP
// end ;
62926: LD_VAR 0 3
62930: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62931: LD_INT 0
62933: PPUSH
62934: PPUSH
62935: PPUSH
// if not mc_bases or not skirmish then
62936: LD_EXP 100
62940: NOT
62941: PUSH
62942: LD_EXP 98
62946: NOT
62947: OR
62948: IFFALSE 62952
// exit ;
62950: GO 63041
// for i = 1 to mc_bases do
62952: LD_ADDR_VAR 0 4
62956: PUSH
62957: DOUBLE
62958: LD_INT 1
62960: DEC
62961: ST_TO_ADDR
62962: LD_EXP 100
62966: PUSH
62967: FOR_TO
62968: IFFALSE 63039
// begin if building in mc_busy_turret_list [ i ] then
62970: LD_VAR 0 1
62974: PUSH
62975: LD_EXP 110
62979: PUSH
62980: LD_VAR 0 4
62984: ARRAY
62985: IN
62986: IFFALSE 63037
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62988: LD_ADDR_VAR 0 5
62992: PUSH
62993: LD_EXP 110
62997: PUSH
62998: LD_VAR 0 4
63002: ARRAY
63003: PUSH
63004: LD_VAR 0 1
63008: DIFF
63009: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
63010: LD_ADDR_EXP 110
63014: PUSH
63015: LD_EXP 110
63019: PPUSH
63020: LD_VAR 0 4
63024: PPUSH
63025: LD_VAR 0 5
63029: PPUSH
63030: CALL_OW 1
63034: ST_TO_ADDR
// break ;
63035: GO 63039
// end ; end ;
63037: GO 62967
63039: POP
63040: POP
// end ;
63041: LD_VAR 0 3
63045: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
63046: LD_INT 0
63048: PPUSH
63049: PPUSH
63050: PPUSH
// if not mc_bases or not skirmish then
63051: LD_EXP 100
63055: NOT
63056: PUSH
63057: LD_EXP 98
63061: NOT
63062: OR
63063: IFFALSE 63067
// exit ;
63065: GO 63266
// for i = 1 to mc_bases do
63067: LD_ADDR_VAR 0 5
63071: PUSH
63072: DOUBLE
63073: LD_INT 1
63075: DEC
63076: ST_TO_ADDR
63077: LD_EXP 100
63081: PUSH
63082: FOR_TO
63083: IFFALSE 63264
// if building in mc_bases [ i ] then
63085: LD_VAR 0 1
63089: PUSH
63090: LD_EXP 100
63094: PUSH
63095: LD_VAR 0 5
63099: ARRAY
63100: IN
63101: IFFALSE 63262
// begin tmp := mc_bases [ i ] diff building ;
63103: LD_ADDR_VAR 0 6
63107: PUSH
63108: LD_EXP 100
63112: PUSH
63113: LD_VAR 0 5
63117: ARRAY
63118: PUSH
63119: LD_VAR 0 1
63123: DIFF
63124: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
63125: LD_ADDR_EXP 100
63129: PUSH
63130: LD_EXP 100
63134: PPUSH
63135: LD_VAR 0 5
63139: PPUSH
63140: LD_VAR 0 6
63144: PPUSH
63145: CALL_OW 1
63149: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
63150: LD_VAR 0 1
63154: PUSH
63155: LD_EXP 108
63159: PUSH
63160: LD_VAR 0 5
63164: ARRAY
63165: IN
63166: IFFALSE 63205
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
63168: LD_ADDR_EXP 108
63172: PUSH
63173: LD_EXP 108
63177: PPUSH
63178: LD_VAR 0 5
63182: PPUSH
63183: LD_EXP 108
63187: PUSH
63188: LD_VAR 0 5
63192: ARRAY
63193: PUSH
63194: LD_VAR 0 1
63198: DIFF
63199: PPUSH
63200: CALL_OW 1
63204: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63205: LD_VAR 0 1
63209: PUSH
63210: LD_EXP 109
63214: PUSH
63215: LD_VAR 0 5
63219: ARRAY
63220: IN
63221: IFFALSE 63260
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63223: LD_ADDR_EXP 109
63227: PUSH
63228: LD_EXP 109
63232: PPUSH
63233: LD_VAR 0 5
63237: PPUSH
63238: LD_EXP 109
63242: PUSH
63243: LD_VAR 0 5
63247: ARRAY
63248: PUSH
63249: LD_VAR 0 1
63253: DIFF
63254: PPUSH
63255: CALL_OW 1
63259: ST_TO_ADDR
// break ;
63260: GO 63264
// end ;
63262: GO 63082
63264: POP
63265: POP
// end ;
63266: LD_VAR 0 4
63270: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63271: LD_INT 0
63273: PPUSH
63274: PPUSH
63275: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63276: LD_EXP 100
63280: NOT
63281: PUSH
63282: LD_EXP 98
63286: NOT
63287: OR
63288: PUSH
63289: LD_VAR 0 3
63293: PUSH
63294: LD_EXP 126
63298: IN
63299: NOT
63300: OR
63301: IFFALSE 63305
// exit ;
63303: GO 63428
// for i = 1 to mc_vehicles do
63305: LD_ADDR_VAR 0 6
63309: PUSH
63310: DOUBLE
63311: LD_INT 1
63313: DEC
63314: ST_TO_ADDR
63315: LD_EXP 119
63319: PUSH
63320: FOR_TO
63321: IFFALSE 63426
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63323: LD_VAR 0 2
63327: PUSH
63328: LD_EXP 119
63332: PUSH
63333: LD_VAR 0 6
63337: ARRAY
63338: IN
63339: PUSH
63340: LD_VAR 0 1
63344: PUSH
63345: LD_EXP 119
63349: PUSH
63350: LD_VAR 0 6
63354: ARRAY
63355: IN
63356: OR
63357: IFFALSE 63424
// begin tmp := mc_vehicles [ i ] diff old ;
63359: LD_ADDR_VAR 0 7
63363: PUSH
63364: LD_EXP 119
63368: PUSH
63369: LD_VAR 0 6
63373: ARRAY
63374: PUSH
63375: LD_VAR 0 2
63379: DIFF
63380: ST_TO_ADDR
// tmp := tmp diff new ;
63381: LD_ADDR_VAR 0 7
63385: PUSH
63386: LD_VAR 0 7
63390: PUSH
63391: LD_VAR 0 1
63395: DIFF
63396: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63397: LD_ADDR_EXP 119
63401: PUSH
63402: LD_EXP 119
63406: PPUSH
63407: LD_VAR 0 6
63411: PPUSH
63412: LD_VAR 0 7
63416: PPUSH
63417: CALL_OW 1
63421: ST_TO_ADDR
// break ;
63422: GO 63426
// end ;
63424: GO 63320
63426: POP
63427: POP
// end ;
63428: LD_VAR 0 5
63432: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63433: LD_INT 0
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
// if not mc_bases or not skirmish then
63439: LD_EXP 100
63443: NOT
63444: PUSH
63445: LD_EXP 98
63449: NOT
63450: OR
63451: IFFALSE 63455
// exit ;
63453: GO 63837
// side := GetSide ( vehicle ) ;
63455: LD_ADDR_VAR 0 5
63459: PUSH
63460: LD_VAR 0 1
63464: PPUSH
63465: CALL_OW 255
63469: ST_TO_ADDR
// for i = 1 to mc_bases do
63470: LD_ADDR_VAR 0 4
63474: PUSH
63475: DOUBLE
63476: LD_INT 1
63478: DEC
63479: ST_TO_ADDR
63480: LD_EXP 100
63484: PUSH
63485: FOR_TO
63486: IFFALSE 63835
// begin if factory in mc_bases [ i ] then
63488: LD_VAR 0 2
63492: PUSH
63493: LD_EXP 100
63497: PUSH
63498: LD_VAR 0 4
63502: ARRAY
63503: IN
63504: IFFALSE 63833
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63506: LD_EXP 122
63510: PUSH
63511: LD_VAR 0 4
63515: ARRAY
63516: PUSH
63517: LD_EXP 111
63521: PUSH
63522: LD_VAR 0 4
63526: ARRAY
63527: LESS
63528: PUSH
63529: LD_VAR 0 1
63533: PPUSH
63534: CALL_OW 264
63538: PUSH
63539: LD_INT 31
63541: PUSH
63542: LD_INT 32
63544: PUSH
63545: LD_INT 51
63547: PUSH
63548: LD_INT 89
63550: PUSH
63551: LD_INT 12
63553: PUSH
63554: LD_INT 30
63556: PUSH
63557: LD_INT 98
63559: PUSH
63560: LD_INT 11
63562: PUSH
63563: LD_INT 53
63565: PUSH
63566: LD_INT 14
63568: PUSH
63569: LD_INT 91
63571: PUSH
63572: LD_INT 29
63574: PUSH
63575: LD_INT 99
63577: PUSH
63578: LD_INT 13
63580: PUSH
63581: LD_INT 52
63583: PUSH
63584: LD_INT 88
63586: PUSH
63587: LD_INT 48
63589: PUSH
63590: LD_INT 8
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: IN
63613: NOT
63614: AND
63615: IFFALSE 63663
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63617: LD_ADDR_EXP 122
63621: PUSH
63622: LD_EXP 122
63626: PPUSH
63627: LD_VAR 0 4
63631: PUSH
63632: LD_EXP 122
63636: PUSH
63637: LD_VAR 0 4
63641: ARRAY
63642: PUSH
63643: LD_INT 1
63645: PLUS
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PPUSH
63651: LD_VAR 0 1
63655: PPUSH
63656: CALL 72647 0 3
63660: ST_TO_ADDR
63661: GO 63707
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63663: LD_ADDR_EXP 119
63667: PUSH
63668: LD_EXP 119
63672: PPUSH
63673: LD_VAR 0 4
63677: PUSH
63678: LD_EXP 119
63682: PUSH
63683: LD_VAR 0 4
63687: ARRAY
63688: PUSH
63689: LD_INT 1
63691: PLUS
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PPUSH
63697: LD_VAR 0 1
63701: PPUSH
63702: CALL 72647 0 3
63706: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63707: LD_VAR 0 1
63711: PPUSH
63712: CALL_OW 263
63716: PUSH
63717: LD_INT 2
63719: EQUAL
63720: IFFALSE 63749
// begin repeat wait ( 0 0$3 ) ;
63722: LD_INT 105
63724: PPUSH
63725: CALL_OW 67
// Connect ( vehicle ) ;
63729: LD_VAR 0 1
63733: PPUSH
63734: CALL 75616 0 1
// until IsControledBy ( vehicle ) ;
63738: LD_VAR 0 1
63742: PPUSH
63743: CALL_OW 312
63747: IFFALSE 63722
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63749: LD_VAR 0 1
63753: PPUSH
63754: LD_EXP 124
63758: PUSH
63759: LD_VAR 0 4
63763: ARRAY
63764: PPUSH
63765: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63769: LD_VAR 0 1
63773: PPUSH
63774: CALL_OW 263
63778: PUSH
63779: LD_INT 1
63781: NONEQUAL
63782: IFFALSE 63786
// break ;
63784: GO 63835
// repeat wait ( 0 0$1 ) ;
63786: LD_INT 35
63788: PPUSH
63789: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63793: LD_VAR 0 1
63797: PPUSH
63798: LD_EXP 124
63802: PUSH
63803: LD_VAR 0 4
63807: ARRAY
63808: PPUSH
63809: CALL_OW 308
63813: IFFALSE 63786
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63815: LD_VAR 0 1
63819: PPUSH
63820: CALL_OW 311
63824: PPUSH
63825: CALL_OW 121
// exit ;
63829: POP
63830: POP
63831: GO 63837
// end ; end ;
63833: GO 63485
63835: POP
63836: POP
// end ;
63837: LD_VAR 0 3
63841: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63842: LD_INT 0
63844: PPUSH
63845: PPUSH
63846: PPUSH
63847: PPUSH
// if not mc_bases or not skirmish then
63848: LD_EXP 100
63852: NOT
63853: PUSH
63854: LD_EXP 98
63858: NOT
63859: OR
63860: IFFALSE 63864
// exit ;
63862: GO 64217
// repeat wait ( 0 0$1 ) ;
63864: LD_INT 35
63866: PPUSH
63867: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63871: LD_VAR 0 2
63875: PPUSH
63876: LD_VAR 0 3
63880: PPUSH
63881: CALL_OW 284
63885: IFFALSE 63864
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63887: LD_VAR 0 2
63891: PPUSH
63892: LD_VAR 0 3
63896: PPUSH
63897: CALL_OW 283
63901: PUSH
63902: LD_INT 4
63904: EQUAL
63905: IFFALSE 63909
// exit ;
63907: GO 64217
// for i = 1 to mc_bases do
63909: LD_ADDR_VAR 0 7
63913: PUSH
63914: DOUBLE
63915: LD_INT 1
63917: DEC
63918: ST_TO_ADDR
63919: LD_EXP 100
63923: PUSH
63924: FOR_TO
63925: IFFALSE 64215
// begin if mc_crates_area [ i ] then
63927: LD_EXP 118
63931: PUSH
63932: LD_VAR 0 7
63936: ARRAY
63937: IFFALSE 64048
// for j in mc_crates_area [ i ] do
63939: LD_ADDR_VAR 0 8
63943: PUSH
63944: LD_EXP 118
63948: PUSH
63949: LD_VAR 0 7
63953: ARRAY
63954: PUSH
63955: FOR_IN
63956: IFFALSE 64046
// if InArea ( x , y , j ) then
63958: LD_VAR 0 2
63962: PPUSH
63963: LD_VAR 0 3
63967: PPUSH
63968: LD_VAR 0 8
63972: PPUSH
63973: CALL_OW 309
63977: IFFALSE 64044
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63979: LD_ADDR_EXP 116
63983: PUSH
63984: LD_EXP 116
63988: PPUSH
63989: LD_VAR 0 7
63993: PUSH
63994: LD_EXP 116
63998: PUSH
63999: LD_VAR 0 7
64003: ARRAY
64004: PUSH
64005: LD_INT 1
64007: PLUS
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: PPUSH
64013: LD_VAR 0 4
64017: PUSH
64018: LD_VAR 0 2
64022: PUSH
64023: LD_VAR 0 3
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: LIST
64032: PPUSH
64033: CALL 72647 0 3
64037: ST_TO_ADDR
// exit ;
64038: POP
64039: POP
64040: POP
64041: POP
64042: GO 64217
// end ;
64044: GO 63955
64046: POP
64047: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64048: LD_ADDR_VAR 0 9
64052: PUSH
64053: LD_EXP 100
64057: PUSH
64058: LD_VAR 0 7
64062: ARRAY
64063: PPUSH
64064: LD_INT 2
64066: PUSH
64067: LD_INT 30
64069: PUSH
64070: LD_INT 0
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: LD_INT 30
64079: PUSH
64080: LD_INT 1
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: LIST
64091: PPUSH
64092: CALL_OW 72
64096: ST_TO_ADDR
// if not depot then
64097: LD_VAR 0 9
64101: NOT
64102: IFFALSE 64106
// continue ;
64104: GO 63924
// for j in depot do
64106: LD_ADDR_VAR 0 8
64110: PUSH
64111: LD_VAR 0 9
64115: PUSH
64116: FOR_IN
64117: IFFALSE 64211
// if GetDistUnitXY ( j , x , y ) < 30 then
64119: LD_VAR 0 8
64123: PPUSH
64124: LD_VAR 0 2
64128: PPUSH
64129: LD_VAR 0 3
64133: PPUSH
64134: CALL_OW 297
64138: PUSH
64139: LD_INT 30
64141: LESS
64142: IFFALSE 64209
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64144: LD_ADDR_EXP 116
64148: PUSH
64149: LD_EXP 116
64153: PPUSH
64154: LD_VAR 0 7
64158: PUSH
64159: LD_EXP 116
64163: PUSH
64164: LD_VAR 0 7
64168: ARRAY
64169: PUSH
64170: LD_INT 1
64172: PLUS
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PPUSH
64178: LD_VAR 0 4
64182: PUSH
64183: LD_VAR 0 2
64187: PUSH
64188: LD_VAR 0 3
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: LIST
64197: PPUSH
64198: CALL 72647 0 3
64202: ST_TO_ADDR
// exit ;
64203: POP
64204: POP
64205: POP
64206: POP
64207: GO 64217
// end ;
64209: GO 64116
64211: POP
64212: POP
// end ;
64213: GO 63924
64215: POP
64216: POP
// end ;
64217: LD_VAR 0 6
64221: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64222: LD_INT 0
64224: PPUSH
64225: PPUSH
64226: PPUSH
64227: PPUSH
// if not mc_bases or not skirmish then
64228: LD_EXP 100
64232: NOT
64233: PUSH
64234: LD_EXP 98
64238: NOT
64239: OR
64240: IFFALSE 64244
// exit ;
64242: GO 64521
// side := GetSide ( lab ) ;
64244: LD_ADDR_VAR 0 4
64248: PUSH
64249: LD_VAR 0 2
64253: PPUSH
64254: CALL_OW 255
64258: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64259: LD_VAR 0 4
64263: PUSH
64264: LD_EXP 126
64268: IN
64269: NOT
64270: PUSH
64271: LD_EXP 127
64275: NOT
64276: OR
64277: PUSH
64278: LD_EXP 100
64282: NOT
64283: OR
64284: IFFALSE 64288
// exit ;
64286: GO 64521
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64288: LD_ADDR_EXP 127
64292: PUSH
64293: LD_EXP 127
64297: PPUSH
64298: LD_VAR 0 4
64302: PPUSH
64303: LD_EXP 127
64307: PUSH
64308: LD_VAR 0 4
64312: ARRAY
64313: PUSH
64314: LD_VAR 0 1
64318: DIFF
64319: PPUSH
64320: CALL_OW 1
64324: ST_TO_ADDR
// for i = 1 to mc_bases do
64325: LD_ADDR_VAR 0 5
64329: PUSH
64330: DOUBLE
64331: LD_INT 1
64333: DEC
64334: ST_TO_ADDR
64335: LD_EXP 100
64339: PUSH
64340: FOR_TO
64341: IFFALSE 64519
// begin if lab in mc_bases [ i ] then
64343: LD_VAR 0 2
64347: PUSH
64348: LD_EXP 100
64352: PUSH
64353: LD_VAR 0 5
64357: ARRAY
64358: IN
64359: IFFALSE 64517
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64361: LD_VAR 0 1
64365: PUSH
64366: LD_INT 11
64368: PUSH
64369: LD_INT 4
64371: PUSH
64372: LD_INT 3
64374: PUSH
64375: LD_INT 2
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: LIST
64382: LIST
64383: IN
64384: PUSH
64385: LD_EXP 130
64389: PUSH
64390: LD_VAR 0 5
64394: ARRAY
64395: AND
64396: IFFALSE 64517
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64398: LD_ADDR_VAR 0 6
64402: PUSH
64403: LD_EXP 130
64407: PUSH
64408: LD_VAR 0 5
64412: ARRAY
64413: PUSH
64414: LD_INT 1
64416: ARRAY
64417: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64418: LD_ADDR_EXP 130
64422: PUSH
64423: LD_EXP 130
64427: PPUSH
64428: LD_VAR 0 5
64432: PPUSH
64433: EMPTY
64434: PPUSH
64435: CALL_OW 1
64439: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64440: LD_VAR 0 6
64444: PPUSH
64445: LD_INT 0
64447: PPUSH
64448: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64452: LD_VAR 0 6
64456: PPUSH
64457: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64461: LD_ADDR_EXP 129
64465: PUSH
64466: LD_EXP 129
64470: PPUSH
64471: LD_VAR 0 5
64475: PPUSH
64476: LD_EXP 129
64480: PUSH
64481: LD_VAR 0 5
64485: ARRAY
64486: PPUSH
64487: LD_INT 1
64489: PPUSH
64490: LD_VAR 0 6
64494: PPUSH
64495: CALL_OW 2
64499: PPUSH
64500: CALL_OW 1
64504: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64505: LD_VAR 0 5
64509: PPUSH
64510: LD_INT 112
64512: PPUSH
64513: CALL 41007 0 2
// end ; end ; end ;
64517: GO 64340
64519: POP
64520: POP
// end ;
64521: LD_VAR 0 3
64525: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64526: LD_INT 0
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
// if not mc_bases or not skirmish then
64536: LD_EXP 100
64540: NOT
64541: PUSH
64542: LD_EXP 98
64546: NOT
64547: OR
64548: IFFALSE 64552
// exit ;
64550: GO 65921
// for i = 1 to mc_bases do
64552: LD_ADDR_VAR 0 3
64556: PUSH
64557: DOUBLE
64558: LD_INT 1
64560: DEC
64561: ST_TO_ADDR
64562: LD_EXP 100
64566: PUSH
64567: FOR_TO
64568: IFFALSE 65919
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64570: LD_VAR 0 1
64574: PUSH
64575: LD_EXP 100
64579: PUSH
64580: LD_VAR 0 3
64584: ARRAY
64585: IN
64586: PUSH
64587: LD_VAR 0 1
64591: PUSH
64592: LD_EXP 107
64596: PUSH
64597: LD_VAR 0 3
64601: ARRAY
64602: IN
64603: OR
64604: PUSH
64605: LD_VAR 0 1
64609: PUSH
64610: LD_EXP 122
64614: PUSH
64615: LD_VAR 0 3
64619: ARRAY
64620: IN
64621: OR
64622: PUSH
64623: LD_VAR 0 1
64627: PUSH
64628: LD_EXP 119
64632: PUSH
64633: LD_VAR 0 3
64637: ARRAY
64638: IN
64639: OR
64640: PUSH
64641: LD_VAR 0 1
64645: PUSH
64646: LD_EXP 129
64650: PUSH
64651: LD_VAR 0 3
64655: ARRAY
64656: IN
64657: OR
64658: PUSH
64659: LD_VAR 0 1
64663: PUSH
64664: LD_EXP 130
64668: PUSH
64669: LD_VAR 0 3
64673: ARRAY
64674: IN
64675: OR
64676: IFFALSE 65917
// begin if un in mc_ape [ i ] then
64678: LD_VAR 0 1
64682: PUSH
64683: LD_EXP 129
64687: PUSH
64688: LD_VAR 0 3
64692: ARRAY
64693: IN
64694: IFFALSE 64733
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64696: LD_ADDR_EXP 129
64700: PUSH
64701: LD_EXP 129
64705: PPUSH
64706: LD_VAR 0 3
64710: PPUSH
64711: LD_EXP 129
64715: PUSH
64716: LD_VAR 0 3
64720: ARRAY
64721: PUSH
64722: LD_VAR 0 1
64726: DIFF
64727: PPUSH
64728: CALL_OW 1
64732: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64733: LD_VAR 0 1
64737: PUSH
64738: LD_EXP 130
64742: PUSH
64743: LD_VAR 0 3
64747: ARRAY
64748: IN
64749: IFFALSE 64773
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64751: LD_ADDR_EXP 130
64755: PUSH
64756: LD_EXP 130
64760: PPUSH
64761: LD_VAR 0 3
64765: PPUSH
64766: EMPTY
64767: PPUSH
64768: CALL_OW 1
64772: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64773: LD_VAR 0 1
64777: PPUSH
64778: CALL_OW 247
64782: PUSH
64783: LD_INT 2
64785: EQUAL
64786: PUSH
64787: LD_VAR 0 1
64791: PPUSH
64792: CALL_OW 110
64796: PUSH
64797: LD_INT 20
64799: EQUAL
64800: PUSH
64801: LD_VAR 0 1
64805: PUSH
64806: LD_EXP 122
64810: PUSH
64811: LD_VAR 0 3
64815: ARRAY
64816: IN
64817: OR
64818: PUSH
64819: LD_VAR 0 1
64823: PPUSH
64824: CALL_OW 264
64828: PUSH
64829: LD_INT 12
64831: PUSH
64832: LD_INT 51
64834: PUSH
64835: LD_INT 89
64837: PUSH
64838: LD_INT 32
64840: PUSH
64841: LD_INT 13
64843: PUSH
64844: LD_INT 52
64846: PUSH
64847: LD_INT 31
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: LIST
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: IN
64859: OR
64860: AND
64861: IFFALSE 65169
// begin if un in mc_defender [ i ] then
64863: LD_VAR 0 1
64867: PUSH
64868: LD_EXP 122
64872: PUSH
64873: LD_VAR 0 3
64877: ARRAY
64878: IN
64879: IFFALSE 64918
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64881: LD_ADDR_EXP 122
64885: PUSH
64886: LD_EXP 122
64890: PPUSH
64891: LD_VAR 0 3
64895: PPUSH
64896: LD_EXP 122
64900: PUSH
64901: LD_VAR 0 3
64905: ARRAY
64906: PUSH
64907: LD_VAR 0 1
64911: DIFF
64912: PPUSH
64913: CALL_OW 1
64917: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64918: LD_ADDR_VAR 0 8
64922: PUSH
64923: LD_VAR 0 3
64927: PPUSH
64928: LD_INT 3
64930: PPUSH
64931: CALL 61577 0 2
64935: ST_TO_ADDR
// if fac then
64936: LD_VAR 0 8
64940: IFFALSE 65169
// begin for j in fac do
64942: LD_ADDR_VAR 0 4
64946: PUSH
64947: LD_VAR 0 8
64951: PUSH
64952: FOR_IN
64953: IFFALSE 65167
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64955: LD_ADDR_VAR 0 9
64959: PUSH
64960: LD_VAR 0 8
64964: PPUSH
64965: LD_VAR 0 1
64969: PPUSH
64970: CALL_OW 265
64974: PPUSH
64975: LD_VAR 0 1
64979: PPUSH
64980: CALL_OW 262
64984: PPUSH
64985: LD_VAR 0 1
64989: PPUSH
64990: CALL_OW 263
64994: PPUSH
64995: LD_VAR 0 1
64999: PPUSH
65000: CALL_OW 264
65004: PPUSH
65005: CALL 70145 0 5
65009: ST_TO_ADDR
// if components then
65010: LD_VAR 0 9
65014: IFFALSE 65165
// begin if GetWeapon ( un ) = ar_control_tower then
65016: LD_VAR 0 1
65020: PPUSH
65021: CALL_OW 264
65025: PUSH
65026: LD_INT 31
65028: EQUAL
65029: IFFALSE 65146
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
65031: LD_VAR 0 1
65035: PPUSH
65036: CALL_OW 311
65040: PPUSH
65041: LD_INT 0
65043: PPUSH
65044: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
65048: LD_ADDR_EXP 140
65052: PUSH
65053: LD_EXP 140
65057: PPUSH
65058: LD_VAR 0 3
65062: PPUSH
65063: LD_EXP 140
65067: PUSH
65068: LD_VAR 0 3
65072: ARRAY
65073: PUSH
65074: LD_VAR 0 1
65078: PPUSH
65079: CALL_OW 311
65083: DIFF
65084: PPUSH
65085: CALL_OW 1
65089: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
65090: LD_ADDR_VAR 0 7
65094: PUSH
65095: LD_EXP 121
65099: PUSH
65100: LD_VAR 0 3
65104: ARRAY
65105: PPUSH
65106: LD_INT 1
65108: PPUSH
65109: LD_VAR 0 9
65113: PPUSH
65114: CALL_OW 2
65118: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65119: LD_ADDR_EXP 121
65123: PUSH
65124: LD_EXP 121
65128: PPUSH
65129: LD_VAR 0 3
65133: PPUSH
65134: LD_VAR 0 7
65138: PPUSH
65139: CALL_OW 1
65143: ST_TO_ADDR
// end else
65144: GO 65163
// MC_InsertProduceList ( i , [ components ] ) ;
65146: LD_VAR 0 3
65150: PPUSH
65151: LD_VAR 0 9
65155: PUSH
65156: EMPTY
65157: LIST
65158: PPUSH
65159: CALL 61122 0 2
// break ;
65163: GO 65167
// end ; end ;
65165: GO 64952
65167: POP
65168: POP
// end ; end ; if GetType ( un ) = unit_building then
65169: LD_VAR 0 1
65173: PPUSH
65174: CALL_OW 247
65178: PUSH
65179: LD_INT 3
65181: EQUAL
65182: IFFALSE 65585
// begin btype := GetBType ( un ) ;
65184: LD_ADDR_VAR 0 5
65188: PUSH
65189: LD_VAR 0 1
65193: PPUSH
65194: CALL_OW 266
65198: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65199: LD_VAR 0 5
65203: PUSH
65204: LD_INT 29
65206: PUSH
65207: LD_INT 30
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: IN
65214: IFFALSE 65287
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65216: LD_VAR 0 1
65220: PPUSH
65221: CALL_OW 250
65225: PPUSH
65226: LD_VAR 0 1
65230: PPUSH
65231: CALL_OW 251
65235: PPUSH
65236: LD_VAR 0 1
65240: PPUSH
65241: CALL_OW 255
65245: PPUSH
65246: CALL_OW 440
65250: NOT
65251: IFFALSE 65287
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65253: LD_VAR 0 1
65257: PPUSH
65258: CALL_OW 250
65262: PPUSH
65263: LD_VAR 0 1
65267: PPUSH
65268: CALL_OW 251
65272: PPUSH
65273: LD_VAR 0 1
65277: PPUSH
65278: CALL_OW 255
65282: PPUSH
65283: CALL_OW 441
// end ; if btype = b_warehouse then
65287: LD_VAR 0 5
65291: PUSH
65292: LD_INT 1
65294: EQUAL
65295: IFFALSE 65313
// begin btype := b_depot ;
65297: LD_ADDR_VAR 0 5
65301: PUSH
65302: LD_INT 0
65304: ST_TO_ADDR
// pos := 1 ;
65305: LD_ADDR_VAR 0 6
65309: PUSH
65310: LD_INT 1
65312: ST_TO_ADDR
// end ; if btype = b_factory then
65313: LD_VAR 0 5
65317: PUSH
65318: LD_INT 3
65320: EQUAL
65321: IFFALSE 65339
// begin btype := b_workshop ;
65323: LD_ADDR_VAR 0 5
65327: PUSH
65328: LD_INT 2
65330: ST_TO_ADDR
// pos := 1 ;
65331: LD_ADDR_VAR 0 6
65335: PUSH
65336: LD_INT 1
65338: ST_TO_ADDR
// end ; if btype = b_barracks then
65339: LD_VAR 0 5
65343: PUSH
65344: LD_INT 5
65346: EQUAL
65347: IFFALSE 65357
// btype := b_armoury ;
65349: LD_ADDR_VAR 0 5
65353: PUSH
65354: LD_INT 4
65356: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65357: LD_VAR 0 5
65361: PUSH
65362: LD_INT 7
65364: PUSH
65365: LD_INT 8
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: IN
65372: IFFALSE 65382
// btype := b_lab ;
65374: LD_ADDR_VAR 0 5
65378: PUSH
65379: LD_INT 6
65381: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65382: LD_ADDR_EXP 105
65386: PUSH
65387: LD_EXP 105
65391: PPUSH
65392: LD_VAR 0 3
65396: PUSH
65397: LD_EXP 105
65401: PUSH
65402: LD_VAR 0 3
65406: ARRAY
65407: PUSH
65408: LD_INT 1
65410: PLUS
65411: PUSH
65412: EMPTY
65413: LIST
65414: LIST
65415: PPUSH
65416: LD_VAR 0 5
65420: PUSH
65421: LD_VAR 0 1
65425: PPUSH
65426: CALL_OW 250
65430: PUSH
65431: LD_VAR 0 1
65435: PPUSH
65436: CALL_OW 251
65440: PUSH
65441: LD_VAR 0 1
65445: PPUSH
65446: CALL_OW 254
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: PPUSH
65457: CALL 72647 0 3
65461: ST_TO_ADDR
// if pos = 1 then
65462: LD_VAR 0 6
65466: PUSH
65467: LD_INT 1
65469: EQUAL
65470: IFFALSE 65585
// begin tmp := mc_build_list [ i ] ;
65472: LD_ADDR_VAR 0 7
65476: PUSH
65477: LD_EXP 105
65481: PUSH
65482: LD_VAR 0 3
65486: ARRAY
65487: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65488: LD_VAR 0 7
65492: PPUSH
65493: LD_INT 2
65495: PUSH
65496: LD_INT 30
65498: PUSH
65499: LD_INT 0
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 30
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: LIST
65520: PPUSH
65521: CALL_OW 72
65525: IFFALSE 65535
// pos := 2 ;
65527: LD_ADDR_VAR 0 6
65531: PUSH
65532: LD_INT 2
65534: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65535: LD_ADDR_VAR 0 7
65539: PUSH
65540: LD_VAR 0 7
65544: PPUSH
65545: LD_VAR 0 6
65549: PPUSH
65550: LD_VAR 0 7
65554: PPUSH
65555: CALL 72973 0 3
65559: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65560: LD_ADDR_EXP 105
65564: PUSH
65565: LD_EXP 105
65569: PPUSH
65570: LD_VAR 0 3
65574: PPUSH
65575: LD_VAR 0 7
65579: PPUSH
65580: CALL_OW 1
65584: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65585: LD_VAR 0 1
65589: PUSH
65590: LD_EXP 100
65594: PUSH
65595: LD_VAR 0 3
65599: ARRAY
65600: IN
65601: IFFALSE 65640
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65603: LD_ADDR_EXP 100
65607: PUSH
65608: LD_EXP 100
65612: PPUSH
65613: LD_VAR 0 3
65617: PPUSH
65618: LD_EXP 100
65622: PUSH
65623: LD_VAR 0 3
65627: ARRAY
65628: PUSH
65629: LD_VAR 0 1
65633: DIFF
65634: PPUSH
65635: CALL_OW 1
65639: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65640: LD_VAR 0 1
65644: PUSH
65645: LD_EXP 107
65649: PUSH
65650: LD_VAR 0 3
65654: ARRAY
65655: IN
65656: IFFALSE 65695
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65658: LD_ADDR_EXP 107
65662: PUSH
65663: LD_EXP 107
65667: PPUSH
65668: LD_VAR 0 3
65672: PPUSH
65673: LD_EXP 107
65677: PUSH
65678: LD_VAR 0 3
65682: ARRAY
65683: PUSH
65684: LD_VAR 0 1
65688: DIFF
65689: PPUSH
65690: CALL_OW 1
65694: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65695: LD_VAR 0 1
65699: PUSH
65700: LD_EXP 119
65704: PUSH
65705: LD_VAR 0 3
65709: ARRAY
65710: IN
65711: IFFALSE 65750
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65713: LD_ADDR_EXP 119
65717: PUSH
65718: LD_EXP 119
65722: PPUSH
65723: LD_VAR 0 3
65727: PPUSH
65728: LD_EXP 119
65732: PUSH
65733: LD_VAR 0 3
65737: ARRAY
65738: PUSH
65739: LD_VAR 0 1
65743: DIFF
65744: PPUSH
65745: CALL_OW 1
65749: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65750: LD_VAR 0 1
65754: PUSH
65755: LD_EXP 122
65759: PUSH
65760: LD_VAR 0 3
65764: ARRAY
65765: IN
65766: IFFALSE 65805
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65768: LD_ADDR_EXP 122
65772: PUSH
65773: LD_EXP 122
65777: PPUSH
65778: LD_VAR 0 3
65782: PPUSH
65783: LD_EXP 122
65787: PUSH
65788: LD_VAR 0 3
65792: ARRAY
65793: PUSH
65794: LD_VAR 0 1
65798: DIFF
65799: PPUSH
65800: CALL_OW 1
65804: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65805: LD_VAR 0 1
65809: PUSH
65810: LD_EXP 109
65814: PUSH
65815: LD_VAR 0 3
65819: ARRAY
65820: IN
65821: IFFALSE 65860
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65823: LD_ADDR_EXP 109
65827: PUSH
65828: LD_EXP 109
65832: PPUSH
65833: LD_VAR 0 3
65837: PPUSH
65838: LD_EXP 109
65842: PUSH
65843: LD_VAR 0 3
65847: ARRAY
65848: PUSH
65849: LD_VAR 0 1
65853: DIFF
65854: PPUSH
65855: CALL_OW 1
65859: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65860: LD_VAR 0 1
65864: PUSH
65865: LD_EXP 108
65869: PUSH
65870: LD_VAR 0 3
65874: ARRAY
65875: IN
65876: IFFALSE 65915
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65878: LD_ADDR_EXP 108
65882: PUSH
65883: LD_EXP 108
65887: PPUSH
65888: LD_VAR 0 3
65892: PPUSH
65893: LD_EXP 108
65897: PUSH
65898: LD_VAR 0 3
65902: ARRAY
65903: PUSH
65904: LD_VAR 0 1
65908: DIFF
65909: PPUSH
65910: CALL_OW 1
65914: ST_TO_ADDR
// end ; break ;
65915: GO 65919
// end ;
65917: GO 64567
65919: POP
65920: POP
// end ;
65921: LD_VAR 0 2
65925: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65926: LD_INT 0
65928: PPUSH
65929: PPUSH
65930: PPUSH
// if not mc_bases or not skirmish then
65931: LD_EXP 100
65935: NOT
65936: PUSH
65937: LD_EXP 98
65941: NOT
65942: OR
65943: IFFALSE 65947
// exit ;
65945: GO 66162
// for i = 1 to mc_bases do
65947: LD_ADDR_VAR 0 3
65951: PUSH
65952: DOUBLE
65953: LD_INT 1
65955: DEC
65956: ST_TO_ADDR
65957: LD_EXP 100
65961: PUSH
65962: FOR_TO
65963: IFFALSE 66160
// begin if building in mc_construct_list [ i ] then
65965: LD_VAR 0 1
65969: PUSH
65970: LD_EXP 107
65974: PUSH
65975: LD_VAR 0 3
65979: ARRAY
65980: IN
65981: IFFALSE 66158
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65983: LD_ADDR_EXP 107
65987: PUSH
65988: LD_EXP 107
65992: PPUSH
65993: LD_VAR 0 3
65997: PPUSH
65998: LD_EXP 107
66002: PUSH
66003: LD_VAR 0 3
66007: ARRAY
66008: PUSH
66009: LD_VAR 0 1
66013: DIFF
66014: PPUSH
66015: CALL_OW 1
66019: ST_TO_ADDR
// if building in mc_lab [ i ] then
66020: LD_VAR 0 1
66024: PUSH
66025: LD_EXP 133
66029: PUSH
66030: LD_VAR 0 3
66034: ARRAY
66035: IN
66036: IFFALSE 66091
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
66038: LD_ADDR_EXP 134
66042: PUSH
66043: LD_EXP 134
66047: PPUSH
66048: LD_VAR 0 3
66052: PPUSH
66053: LD_EXP 134
66057: PUSH
66058: LD_VAR 0 3
66062: ARRAY
66063: PPUSH
66064: LD_INT 1
66066: PPUSH
66067: LD_EXP 134
66071: PUSH
66072: LD_VAR 0 3
66076: ARRAY
66077: PPUSH
66078: LD_INT 0
66080: PPUSH
66081: CALL 72065 0 4
66085: PPUSH
66086: CALL_OW 1
66090: ST_TO_ADDR
// if not building in mc_bases [ i ] then
66091: LD_VAR 0 1
66095: PUSH
66096: LD_EXP 100
66100: PUSH
66101: LD_VAR 0 3
66105: ARRAY
66106: IN
66107: NOT
66108: IFFALSE 66154
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66110: LD_ADDR_EXP 100
66114: PUSH
66115: LD_EXP 100
66119: PPUSH
66120: LD_VAR 0 3
66124: PUSH
66125: LD_EXP 100
66129: PUSH
66130: LD_VAR 0 3
66134: ARRAY
66135: PUSH
66136: LD_INT 1
66138: PLUS
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PPUSH
66144: LD_VAR 0 1
66148: PPUSH
66149: CALL 72647 0 3
66153: ST_TO_ADDR
// exit ;
66154: POP
66155: POP
66156: GO 66162
// end ; end ;
66158: GO 65962
66160: POP
66161: POP
// end ;
66162: LD_VAR 0 2
66166: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
66167: LD_INT 0
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
// if not mc_bases or not skirmish then
66176: LD_EXP 100
66180: NOT
66181: PUSH
66182: LD_EXP 98
66186: NOT
66187: OR
66188: IFFALSE 66192
// exit ;
66190: GO 66853
// for i = 1 to mc_bases do
66192: LD_ADDR_VAR 0 3
66196: PUSH
66197: DOUBLE
66198: LD_INT 1
66200: DEC
66201: ST_TO_ADDR
66202: LD_EXP 100
66206: PUSH
66207: FOR_TO
66208: IFFALSE 66851
// begin if building in mc_construct_list [ i ] then
66210: LD_VAR 0 1
66214: PUSH
66215: LD_EXP 107
66219: PUSH
66220: LD_VAR 0 3
66224: ARRAY
66225: IN
66226: IFFALSE 66849
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66228: LD_ADDR_EXP 107
66232: PUSH
66233: LD_EXP 107
66237: PPUSH
66238: LD_VAR 0 3
66242: PPUSH
66243: LD_EXP 107
66247: PUSH
66248: LD_VAR 0 3
66252: ARRAY
66253: PUSH
66254: LD_VAR 0 1
66258: DIFF
66259: PPUSH
66260: CALL_OW 1
66264: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66265: LD_ADDR_EXP 100
66269: PUSH
66270: LD_EXP 100
66274: PPUSH
66275: LD_VAR 0 3
66279: PUSH
66280: LD_EXP 100
66284: PUSH
66285: LD_VAR 0 3
66289: ARRAY
66290: PUSH
66291: LD_INT 1
66293: PLUS
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PPUSH
66299: LD_VAR 0 1
66303: PPUSH
66304: CALL 72647 0 3
66308: ST_TO_ADDR
// btype := GetBType ( building ) ;
66309: LD_ADDR_VAR 0 5
66313: PUSH
66314: LD_VAR 0 1
66318: PPUSH
66319: CALL_OW 266
66323: ST_TO_ADDR
// side := GetSide ( building ) ;
66324: LD_ADDR_VAR 0 8
66328: PUSH
66329: LD_VAR 0 1
66333: PPUSH
66334: CALL_OW 255
66338: ST_TO_ADDR
// if btype = b_lab then
66339: LD_VAR 0 5
66343: PUSH
66344: LD_INT 6
66346: EQUAL
66347: IFFALSE 66397
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66349: LD_ADDR_EXP 133
66353: PUSH
66354: LD_EXP 133
66358: PPUSH
66359: LD_VAR 0 3
66363: PUSH
66364: LD_EXP 133
66368: PUSH
66369: LD_VAR 0 3
66373: ARRAY
66374: PUSH
66375: LD_INT 1
66377: PLUS
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PPUSH
66383: LD_VAR 0 1
66387: PPUSH
66388: CALL 72647 0 3
66392: ST_TO_ADDR
// exit ;
66393: POP
66394: POP
66395: GO 66853
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66397: LD_VAR 0 5
66401: PUSH
66402: LD_INT 0
66404: PUSH
66405: LD_INT 2
66407: PUSH
66408: LD_INT 4
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: LIST
66415: IN
66416: IFFALSE 66540
// begin if btype = b_armoury then
66418: LD_VAR 0 5
66422: PUSH
66423: LD_INT 4
66425: EQUAL
66426: IFFALSE 66436
// btype := b_barracks ;
66428: LD_ADDR_VAR 0 5
66432: PUSH
66433: LD_INT 5
66435: ST_TO_ADDR
// if btype = b_depot then
66436: LD_VAR 0 5
66440: PUSH
66441: LD_INT 0
66443: EQUAL
66444: IFFALSE 66454
// btype := b_warehouse ;
66446: LD_ADDR_VAR 0 5
66450: PUSH
66451: LD_INT 1
66453: ST_TO_ADDR
// if btype = b_workshop then
66454: LD_VAR 0 5
66458: PUSH
66459: LD_INT 2
66461: EQUAL
66462: IFFALSE 66472
// btype := b_factory ;
66464: LD_ADDR_VAR 0 5
66468: PUSH
66469: LD_INT 3
66471: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66472: LD_VAR 0 5
66476: PPUSH
66477: LD_VAR 0 8
66481: PPUSH
66482: CALL_OW 323
66486: PUSH
66487: LD_INT 1
66489: EQUAL
66490: IFFALSE 66536
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66492: LD_ADDR_EXP 132
66496: PUSH
66497: LD_EXP 132
66501: PPUSH
66502: LD_VAR 0 3
66506: PUSH
66507: LD_EXP 132
66511: PUSH
66512: LD_VAR 0 3
66516: ARRAY
66517: PUSH
66518: LD_INT 1
66520: PLUS
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PPUSH
66526: LD_VAR 0 1
66530: PPUSH
66531: CALL 72647 0 3
66535: ST_TO_ADDR
// exit ;
66536: POP
66537: POP
66538: GO 66853
// end ; if btype in [ b_bunker , b_turret ] then
66540: LD_VAR 0 5
66544: PUSH
66545: LD_INT 32
66547: PUSH
66548: LD_INT 33
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: IN
66555: IFFALSE 66845
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66557: LD_ADDR_EXP 108
66561: PUSH
66562: LD_EXP 108
66566: PPUSH
66567: LD_VAR 0 3
66571: PUSH
66572: LD_EXP 108
66576: PUSH
66577: LD_VAR 0 3
66581: ARRAY
66582: PUSH
66583: LD_INT 1
66585: PLUS
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PPUSH
66591: LD_VAR 0 1
66595: PPUSH
66596: CALL 72647 0 3
66600: ST_TO_ADDR
// if btype = b_bunker then
66601: LD_VAR 0 5
66605: PUSH
66606: LD_INT 32
66608: EQUAL
66609: IFFALSE 66845
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66611: LD_ADDR_EXP 109
66615: PUSH
66616: LD_EXP 109
66620: PPUSH
66621: LD_VAR 0 3
66625: PUSH
66626: LD_EXP 109
66630: PUSH
66631: LD_VAR 0 3
66635: ARRAY
66636: PUSH
66637: LD_INT 1
66639: PLUS
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PPUSH
66645: LD_VAR 0 1
66649: PPUSH
66650: CALL 72647 0 3
66654: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66655: LD_ADDR_VAR 0 6
66659: PUSH
66660: LD_EXP 100
66664: PUSH
66665: LD_VAR 0 3
66669: ARRAY
66670: PPUSH
66671: LD_INT 25
66673: PUSH
66674: LD_INT 1
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 3
66683: PUSH
66684: LD_INT 54
66686: PUSH
66687: EMPTY
66688: LIST
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PPUSH
66698: CALL_OW 72
66702: ST_TO_ADDR
// if tmp then
66703: LD_VAR 0 6
66707: IFFALSE 66713
// exit ;
66709: POP
66710: POP
66711: GO 66853
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66713: LD_ADDR_VAR 0 6
66717: PUSH
66718: LD_EXP 100
66722: PUSH
66723: LD_VAR 0 3
66727: ARRAY
66728: PPUSH
66729: LD_INT 2
66731: PUSH
66732: LD_INT 30
66734: PUSH
66735: LD_INT 4
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 30
66744: PUSH
66745: LD_INT 5
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: LIST
66756: PPUSH
66757: CALL_OW 72
66761: ST_TO_ADDR
// if not tmp then
66762: LD_VAR 0 6
66766: NOT
66767: IFFALSE 66773
// exit ;
66769: POP
66770: POP
66771: GO 66853
// for j in tmp do
66773: LD_ADDR_VAR 0 4
66777: PUSH
66778: LD_VAR 0 6
66782: PUSH
66783: FOR_IN
66784: IFFALSE 66843
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66786: LD_ADDR_VAR 0 7
66790: PUSH
66791: LD_VAR 0 4
66795: PPUSH
66796: CALL_OW 313
66800: PPUSH
66801: LD_INT 25
66803: PUSH
66804: LD_INT 1
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PPUSH
66811: CALL_OW 72
66815: ST_TO_ADDR
// if units then
66816: LD_VAR 0 7
66820: IFFALSE 66841
// begin ComExitBuilding ( units [ 1 ] ) ;
66822: LD_VAR 0 7
66826: PUSH
66827: LD_INT 1
66829: ARRAY
66830: PPUSH
66831: CALL_OW 122
// exit ;
66835: POP
66836: POP
66837: POP
66838: POP
66839: GO 66853
// end ; end ;
66841: GO 66783
66843: POP
66844: POP
// end ; end ; exit ;
66845: POP
66846: POP
66847: GO 66853
// end ; end ;
66849: GO 66207
66851: POP
66852: POP
// end ;
66853: LD_VAR 0 2
66857: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66858: LD_INT 0
66860: PPUSH
66861: PPUSH
66862: PPUSH
66863: PPUSH
66864: PPUSH
66865: PPUSH
66866: PPUSH
// if not mc_bases or not skirmish then
66867: LD_EXP 100
66871: NOT
66872: PUSH
66873: LD_EXP 98
66877: NOT
66878: OR
66879: IFFALSE 66883
// exit ;
66881: GO 67148
// btype := GetBType ( building ) ;
66883: LD_ADDR_VAR 0 6
66887: PUSH
66888: LD_VAR 0 1
66892: PPUSH
66893: CALL_OW 266
66897: ST_TO_ADDR
// x := GetX ( building ) ;
66898: LD_ADDR_VAR 0 7
66902: PUSH
66903: LD_VAR 0 1
66907: PPUSH
66908: CALL_OW 250
66912: ST_TO_ADDR
// y := GetY ( building ) ;
66913: LD_ADDR_VAR 0 8
66917: PUSH
66918: LD_VAR 0 1
66922: PPUSH
66923: CALL_OW 251
66927: ST_TO_ADDR
// d := GetDir ( building ) ;
66928: LD_ADDR_VAR 0 9
66932: PUSH
66933: LD_VAR 0 1
66937: PPUSH
66938: CALL_OW 254
66942: ST_TO_ADDR
// for i = 1 to mc_bases do
66943: LD_ADDR_VAR 0 4
66947: PUSH
66948: DOUBLE
66949: LD_INT 1
66951: DEC
66952: ST_TO_ADDR
66953: LD_EXP 100
66957: PUSH
66958: FOR_TO
66959: IFFALSE 67146
// begin if not mc_build_list [ i ] then
66961: LD_EXP 105
66965: PUSH
66966: LD_VAR 0 4
66970: ARRAY
66971: NOT
66972: IFFALSE 66976
// continue ;
66974: GO 66958
// for j := 1 to mc_build_list [ i ] do
66976: LD_ADDR_VAR 0 5
66980: PUSH
66981: DOUBLE
66982: LD_INT 1
66984: DEC
66985: ST_TO_ADDR
66986: LD_EXP 105
66990: PUSH
66991: LD_VAR 0 4
66995: ARRAY
66996: PUSH
66997: FOR_TO
66998: IFFALSE 67142
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
67000: LD_VAR 0 6
67004: PUSH
67005: LD_VAR 0 7
67009: PUSH
67010: LD_VAR 0 8
67014: PUSH
67015: LD_VAR 0 9
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: PPUSH
67026: LD_EXP 105
67030: PUSH
67031: LD_VAR 0 4
67035: ARRAY
67036: PUSH
67037: LD_VAR 0 5
67041: ARRAY
67042: PPUSH
67043: CALL 78827 0 2
67047: IFFALSE 67140
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
67049: LD_ADDR_EXP 105
67053: PUSH
67054: LD_EXP 105
67058: PPUSH
67059: LD_VAR 0 4
67063: PPUSH
67064: LD_EXP 105
67068: PUSH
67069: LD_VAR 0 4
67073: ARRAY
67074: PPUSH
67075: LD_VAR 0 5
67079: PPUSH
67080: CALL_OW 3
67084: PPUSH
67085: CALL_OW 1
67089: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
67090: LD_ADDR_EXP 107
67094: PUSH
67095: LD_EXP 107
67099: PPUSH
67100: LD_VAR 0 4
67104: PUSH
67105: LD_EXP 107
67109: PUSH
67110: LD_VAR 0 4
67114: ARRAY
67115: PUSH
67116: LD_INT 1
67118: PLUS
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PPUSH
67124: LD_VAR 0 1
67128: PPUSH
67129: CALL 72647 0 3
67133: ST_TO_ADDR
// exit ;
67134: POP
67135: POP
67136: POP
67137: POP
67138: GO 67148
// end ;
67140: GO 66997
67142: POP
67143: POP
// end ;
67144: GO 66958
67146: POP
67147: POP
// end ;
67148: LD_VAR 0 3
67152: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
67153: LD_INT 0
67155: PPUSH
67156: PPUSH
67157: PPUSH
// if not mc_bases or not skirmish then
67158: LD_EXP 100
67162: NOT
67163: PUSH
67164: LD_EXP 98
67168: NOT
67169: OR
67170: IFFALSE 67174
// exit ;
67172: GO 67364
// for i = 1 to mc_bases do
67174: LD_ADDR_VAR 0 4
67178: PUSH
67179: DOUBLE
67180: LD_INT 1
67182: DEC
67183: ST_TO_ADDR
67184: LD_EXP 100
67188: PUSH
67189: FOR_TO
67190: IFFALSE 67277
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67192: LD_VAR 0 1
67196: PUSH
67197: LD_EXP 108
67201: PUSH
67202: LD_VAR 0 4
67206: ARRAY
67207: IN
67208: PUSH
67209: LD_VAR 0 1
67213: PUSH
67214: LD_EXP 109
67218: PUSH
67219: LD_VAR 0 4
67223: ARRAY
67224: IN
67225: NOT
67226: AND
67227: IFFALSE 67275
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67229: LD_ADDR_EXP 109
67233: PUSH
67234: LD_EXP 109
67238: PPUSH
67239: LD_VAR 0 4
67243: PUSH
67244: LD_EXP 109
67248: PUSH
67249: LD_VAR 0 4
67253: ARRAY
67254: PUSH
67255: LD_INT 1
67257: PLUS
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PPUSH
67263: LD_VAR 0 1
67267: PPUSH
67268: CALL 72647 0 3
67272: ST_TO_ADDR
// break ;
67273: GO 67277
// end ; end ;
67275: GO 67189
67277: POP
67278: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67279: LD_VAR 0 1
67283: PPUSH
67284: CALL_OW 257
67288: PUSH
67289: LD_EXP 126
67293: IN
67294: PUSH
67295: LD_VAR 0 1
67299: PPUSH
67300: CALL_OW 266
67304: PUSH
67305: LD_INT 5
67307: EQUAL
67308: AND
67309: PUSH
67310: LD_VAR 0 2
67314: PPUSH
67315: CALL_OW 110
67319: PUSH
67320: LD_INT 18
67322: NONEQUAL
67323: AND
67324: IFFALSE 67364
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67326: LD_VAR 0 2
67330: PPUSH
67331: CALL_OW 257
67335: PUSH
67336: LD_INT 5
67338: PUSH
67339: LD_INT 8
67341: PUSH
67342: LD_INT 9
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: LIST
67349: IN
67350: IFFALSE 67364
// SetClass ( unit , 1 ) ;
67352: LD_VAR 0 2
67356: PPUSH
67357: LD_INT 1
67359: PPUSH
67360: CALL_OW 336
// end ;
67364: LD_VAR 0 3
67368: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67369: LD_INT 0
67371: PPUSH
67372: PPUSH
// if not mc_bases or not skirmish then
67373: LD_EXP 100
67377: NOT
67378: PUSH
67379: LD_EXP 98
67383: NOT
67384: OR
67385: IFFALSE 67389
// exit ;
67387: GO 67505
// if GetLives ( abandoned_vehicle ) > 250 then
67389: LD_VAR 0 2
67393: PPUSH
67394: CALL_OW 256
67398: PUSH
67399: LD_INT 250
67401: GREATER
67402: IFFALSE 67406
// exit ;
67404: GO 67505
// for i = 1 to mc_bases do
67406: LD_ADDR_VAR 0 6
67410: PUSH
67411: DOUBLE
67412: LD_INT 1
67414: DEC
67415: ST_TO_ADDR
67416: LD_EXP 100
67420: PUSH
67421: FOR_TO
67422: IFFALSE 67503
// begin if driver in mc_bases [ i ] then
67424: LD_VAR 0 1
67428: PUSH
67429: LD_EXP 100
67433: PUSH
67434: LD_VAR 0 6
67438: ARRAY
67439: IN
67440: IFFALSE 67501
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67442: LD_VAR 0 1
67446: PPUSH
67447: LD_EXP 100
67451: PUSH
67452: LD_VAR 0 6
67456: ARRAY
67457: PPUSH
67458: LD_INT 2
67460: PUSH
67461: LD_INT 30
67463: PUSH
67464: LD_INT 0
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 30
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: LIST
67485: PPUSH
67486: CALL_OW 72
67490: PUSH
67491: LD_INT 1
67493: ARRAY
67494: PPUSH
67495: CALL 105836 0 2
// break ;
67499: GO 67503
// end ; end ;
67501: GO 67421
67503: POP
67504: POP
// end ; end_of_file
67505: LD_VAR 0 5
67509: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67510: LD_INT 0
67512: PPUSH
67513: PPUSH
// if exist_mode then
67514: LD_VAR 0 2
67518: IFFALSE 67543
// unit := CreateCharacter ( prefix & ident ) else
67520: LD_ADDR_VAR 0 5
67524: PUSH
67525: LD_VAR 0 3
67529: PUSH
67530: LD_VAR 0 1
67534: STR
67535: PPUSH
67536: CALL_OW 34
67540: ST_TO_ADDR
67541: GO 67558
// unit := NewCharacter ( ident ) ;
67543: LD_ADDR_VAR 0 5
67547: PUSH
67548: LD_VAR 0 1
67552: PPUSH
67553: CALL_OW 25
67557: ST_TO_ADDR
// result := unit ;
67558: LD_ADDR_VAR 0 4
67562: PUSH
67563: LD_VAR 0 5
67567: ST_TO_ADDR
// end ;
67568: LD_VAR 0 4
67572: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67573: LD_INT 0
67575: PPUSH
67576: PPUSH
// if not side or not nation then
67577: LD_VAR 0 1
67581: NOT
67582: PUSH
67583: LD_VAR 0 2
67587: NOT
67588: OR
67589: IFFALSE 67593
// exit ;
67591: GO 68361
// case nation of nation_american :
67593: LD_VAR 0 2
67597: PUSH
67598: LD_INT 1
67600: DOUBLE
67601: EQUAL
67602: IFTRUE 67606
67604: GO 67820
67606: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67607: LD_ADDR_VAR 0 4
67611: PUSH
67612: LD_INT 35
67614: PUSH
67615: LD_INT 45
67617: PUSH
67618: LD_INT 46
67620: PUSH
67621: LD_INT 47
67623: PUSH
67624: LD_INT 82
67626: PUSH
67627: LD_INT 83
67629: PUSH
67630: LD_INT 84
67632: PUSH
67633: LD_INT 85
67635: PUSH
67636: LD_INT 86
67638: PUSH
67639: LD_INT 1
67641: PUSH
67642: LD_INT 2
67644: PUSH
67645: LD_INT 6
67647: PUSH
67648: LD_INT 15
67650: PUSH
67651: LD_INT 16
67653: PUSH
67654: LD_INT 7
67656: PUSH
67657: LD_INT 12
67659: PUSH
67660: LD_INT 13
67662: PUSH
67663: LD_INT 10
67665: PUSH
67666: LD_INT 14
67668: PUSH
67669: LD_INT 20
67671: PUSH
67672: LD_INT 21
67674: PUSH
67675: LD_INT 22
67677: PUSH
67678: LD_INT 25
67680: PUSH
67681: LD_INT 32
67683: PUSH
67684: LD_INT 27
67686: PUSH
67687: LD_INT 36
67689: PUSH
67690: LD_INT 69
67692: PUSH
67693: LD_INT 39
67695: PUSH
67696: LD_INT 34
67698: PUSH
67699: LD_INT 40
67701: PUSH
67702: LD_INT 48
67704: PUSH
67705: LD_INT 49
67707: PUSH
67708: LD_INT 50
67710: PUSH
67711: LD_INT 51
67713: PUSH
67714: LD_INT 52
67716: PUSH
67717: LD_INT 53
67719: PUSH
67720: LD_INT 54
67722: PUSH
67723: LD_INT 55
67725: PUSH
67726: LD_INT 56
67728: PUSH
67729: LD_INT 57
67731: PUSH
67732: LD_INT 58
67734: PUSH
67735: LD_INT 59
67737: PUSH
67738: LD_INT 60
67740: PUSH
67741: LD_INT 61
67743: PUSH
67744: LD_INT 62
67746: PUSH
67747: LD_INT 80
67749: PUSH
67750: LD_INT 82
67752: PUSH
67753: LD_INT 83
67755: PUSH
67756: LD_INT 84
67758: PUSH
67759: LD_INT 85
67761: PUSH
67762: LD_INT 86
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: LIST
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: ST_TO_ADDR
67818: GO 68285
67820: LD_INT 2
67822: DOUBLE
67823: EQUAL
67824: IFTRUE 67828
67826: GO 68054
67828: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67829: LD_ADDR_VAR 0 4
67833: PUSH
67834: LD_INT 35
67836: PUSH
67837: LD_INT 45
67839: PUSH
67840: LD_INT 46
67842: PUSH
67843: LD_INT 47
67845: PUSH
67846: LD_INT 82
67848: PUSH
67849: LD_INT 83
67851: PUSH
67852: LD_INT 84
67854: PUSH
67855: LD_INT 85
67857: PUSH
67858: LD_INT 87
67860: PUSH
67861: LD_INT 70
67863: PUSH
67864: LD_INT 1
67866: PUSH
67867: LD_INT 11
67869: PUSH
67870: LD_INT 3
67872: PUSH
67873: LD_INT 4
67875: PUSH
67876: LD_INT 5
67878: PUSH
67879: LD_INT 6
67881: PUSH
67882: LD_INT 15
67884: PUSH
67885: LD_INT 18
67887: PUSH
67888: LD_INT 7
67890: PUSH
67891: LD_INT 17
67893: PUSH
67894: LD_INT 8
67896: PUSH
67897: LD_INT 20
67899: PUSH
67900: LD_INT 21
67902: PUSH
67903: LD_INT 22
67905: PUSH
67906: LD_INT 72
67908: PUSH
67909: LD_INT 26
67911: PUSH
67912: LD_INT 69
67914: PUSH
67915: LD_INT 39
67917: PUSH
67918: LD_INT 40
67920: PUSH
67921: LD_INT 41
67923: PUSH
67924: LD_INT 42
67926: PUSH
67927: LD_INT 43
67929: PUSH
67930: LD_INT 48
67932: PUSH
67933: LD_INT 49
67935: PUSH
67936: LD_INT 50
67938: PUSH
67939: LD_INT 51
67941: PUSH
67942: LD_INT 52
67944: PUSH
67945: LD_INT 53
67947: PUSH
67948: LD_INT 54
67950: PUSH
67951: LD_INT 55
67953: PUSH
67954: LD_INT 56
67956: PUSH
67957: LD_INT 60
67959: PUSH
67960: LD_INT 61
67962: PUSH
67963: LD_INT 62
67965: PUSH
67966: LD_INT 66
67968: PUSH
67969: LD_INT 67
67971: PUSH
67972: LD_INT 68
67974: PUSH
67975: LD_INT 81
67977: PUSH
67978: LD_INT 82
67980: PUSH
67981: LD_INT 83
67983: PUSH
67984: LD_INT 84
67986: PUSH
67987: LD_INT 85
67989: PUSH
67990: LD_INT 87
67992: PUSH
67993: LD_INT 88
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: LIST
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: ST_TO_ADDR
68052: GO 68285
68054: LD_INT 3
68056: DOUBLE
68057: EQUAL
68058: IFTRUE 68062
68060: GO 68284
68062: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
68063: LD_ADDR_VAR 0 4
68067: PUSH
68068: LD_INT 46
68070: PUSH
68071: LD_INT 47
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: LD_INT 2
68079: PUSH
68080: LD_INT 82
68082: PUSH
68083: LD_INT 83
68085: PUSH
68086: LD_INT 84
68088: PUSH
68089: LD_INT 85
68091: PUSH
68092: LD_INT 86
68094: PUSH
68095: LD_INT 11
68097: PUSH
68098: LD_INT 9
68100: PUSH
68101: LD_INT 20
68103: PUSH
68104: LD_INT 19
68106: PUSH
68107: LD_INT 21
68109: PUSH
68110: LD_INT 24
68112: PUSH
68113: LD_INT 22
68115: PUSH
68116: LD_INT 25
68118: PUSH
68119: LD_INT 28
68121: PUSH
68122: LD_INT 29
68124: PUSH
68125: LD_INT 30
68127: PUSH
68128: LD_INT 31
68130: PUSH
68131: LD_INT 37
68133: PUSH
68134: LD_INT 38
68136: PUSH
68137: LD_INT 32
68139: PUSH
68140: LD_INT 27
68142: PUSH
68143: LD_INT 33
68145: PUSH
68146: LD_INT 69
68148: PUSH
68149: LD_INT 39
68151: PUSH
68152: LD_INT 34
68154: PUSH
68155: LD_INT 40
68157: PUSH
68158: LD_INT 71
68160: PUSH
68161: LD_INT 23
68163: PUSH
68164: LD_INT 44
68166: PUSH
68167: LD_INT 48
68169: PUSH
68170: LD_INT 49
68172: PUSH
68173: LD_INT 50
68175: PUSH
68176: LD_INT 51
68178: PUSH
68179: LD_INT 52
68181: PUSH
68182: LD_INT 53
68184: PUSH
68185: LD_INT 54
68187: PUSH
68188: LD_INT 55
68190: PUSH
68191: LD_INT 56
68193: PUSH
68194: LD_INT 57
68196: PUSH
68197: LD_INT 58
68199: PUSH
68200: LD_INT 59
68202: PUSH
68203: LD_INT 63
68205: PUSH
68206: LD_INT 64
68208: PUSH
68209: LD_INT 65
68211: PUSH
68212: LD_INT 82
68214: PUSH
68215: LD_INT 83
68217: PUSH
68218: LD_INT 84
68220: PUSH
68221: LD_INT 85
68223: PUSH
68224: LD_INT 86
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: LIST
68248: LIST
68249: LIST
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: ST_TO_ADDR
68282: GO 68285
68284: POP
// if state > - 1 and state < 3 then
68285: LD_VAR 0 3
68289: PUSH
68290: LD_INT 1
68292: NEG
68293: GREATER
68294: PUSH
68295: LD_VAR 0 3
68299: PUSH
68300: LD_INT 3
68302: LESS
68303: AND
68304: IFFALSE 68361
// for i in result do
68306: LD_ADDR_VAR 0 5
68310: PUSH
68311: LD_VAR 0 4
68315: PUSH
68316: FOR_IN
68317: IFFALSE 68359
// if GetTech ( i , side ) <> state then
68319: LD_VAR 0 5
68323: PPUSH
68324: LD_VAR 0 1
68328: PPUSH
68329: CALL_OW 321
68333: PUSH
68334: LD_VAR 0 3
68338: NONEQUAL
68339: IFFALSE 68357
// result := result diff i ;
68341: LD_ADDR_VAR 0 4
68345: PUSH
68346: LD_VAR 0 4
68350: PUSH
68351: LD_VAR 0 5
68355: DIFF
68356: ST_TO_ADDR
68357: GO 68316
68359: POP
68360: POP
// end ;
68361: LD_VAR 0 4
68365: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68366: LD_INT 0
68368: PPUSH
68369: PPUSH
68370: PPUSH
// result := true ;
68371: LD_ADDR_VAR 0 3
68375: PUSH
68376: LD_INT 1
68378: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68379: LD_ADDR_VAR 0 5
68383: PUSH
68384: LD_VAR 0 2
68388: PPUSH
68389: CALL_OW 480
68393: ST_TO_ADDR
// if not tmp then
68394: LD_VAR 0 5
68398: NOT
68399: IFFALSE 68403
// exit ;
68401: GO 68452
// for i in tmp do
68403: LD_ADDR_VAR 0 4
68407: PUSH
68408: LD_VAR 0 5
68412: PUSH
68413: FOR_IN
68414: IFFALSE 68450
// if GetTech ( i , side ) <> state_researched then
68416: LD_VAR 0 4
68420: PPUSH
68421: LD_VAR 0 1
68425: PPUSH
68426: CALL_OW 321
68430: PUSH
68431: LD_INT 2
68433: NONEQUAL
68434: IFFALSE 68448
// begin result := false ;
68436: LD_ADDR_VAR 0 3
68440: PUSH
68441: LD_INT 0
68443: ST_TO_ADDR
// exit ;
68444: POP
68445: POP
68446: GO 68452
// end ;
68448: GO 68413
68450: POP
68451: POP
// end ;
68452: LD_VAR 0 3
68456: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68457: LD_INT 0
68459: PPUSH
68460: PPUSH
68461: PPUSH
68462: PPUSH
68463: PPUSH
68464: PPUSH
68465: PPUSH
68466: PPUSH
68467: PPUSH
68468: PPUSH
68469: PPUSH
68470: PPUSH
68471: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68472: LD_VAR 0 1
68476: NOT
68477: PUSH
68478: LD_VAR 0 1
68482: PPUSH
68483: CALL_OW 257
68487: PUSH
68488: LD_INT 9
68490: NONEQUAL
68491: OR
68492: IFFALSE 68496
// exit ;
68494: GO 69069
// side := GetSide ( unit ) ;
68496: LD_ADDR_VAR 0 9
68500: PUSH
68501: LD_VAR 0 1
68505: PPUSH
68506: CALL_OW 255
68510: ST_TO_ADDR
// tech_space := tech_spacanom ;
68511: LD_ADDR_VAR 0 12
68515: PUSH
68516: LD_INT 29
68518: ST_TO_ADDR
// tech_time := tech_taurad ;
68519: LD_ADDR_VAR 0 13
68523: PUSH
68524: LD_INT 28
68526: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68527: LD_ADDR_VAR 0 11
68531: PUSH
68532: LD_VAR 0 1
68536: PPUSH
68537: CALL_OW 310
68541: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68542: LD_VAR 0 11
68546: PPUSH
68547: CALL_OW 247
68551: PUSH
68552: LD_INT 2
68554: EQUAL
68555: IFFALSE 68559
// exit ;
68557: GO 69069
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68559: LD_ADDR_VAR 0 8
68563: PUSH
68564: LD_INT 81
68566: PUSH
68567: LD_VAR 0 9
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 3
68578: PUSH
68579: LD_INT 21
68581: PUSH
68582: LD_INT 3
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PPUSH
68597: CALL_OW 69
68601: ST_TO_ADDR
// if not tmp then
68602: LD_VAR 0 8
68606: NOT
68607: IFFALSE 68611
// exit ;
68609: GO 69069
// if in_unit then
68611: LD_VAR 0 11
68615: IFFALSE 68639
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68617: LD_ADDR_VAR 0 10
68621: PUSH
68622: LD_VAR 0 8
68626: PPUSH
68627: LD_VAR 0 11
68631: PPUSH
68632: CALL_OW 74
68636: ST_TO_ADDR
68637: GO 68659
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68639: LD_ADDR_VAR 0 10
68643: PUSH
68644: LD_VAR 0 8
68648: PPUSH
68649: LD_VAR 0 1
68653: PPUSH
68654: CALL_OW 74
68658: ST_TO_ADDR
// if not enemy then
68659: LD_VAR 0 10
68663: NOT
68664: IFFALSE 68668
// exit ;
68666: GO 69069
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68668: LD_VAR 0 11
68672: PUSH
68673: LD_VAR 0 11
68677: PPUSH
68678: LD_VAR 0 10
68682: PPUSH
68683: CALL_OW 296
68687: PUSH
68688: LD_INT 13
68690: GREATER
68691: AND
68692: PUSH
68693: LD_VAR 0 1
68697: PPUSH
68698: LD_VAR 0 10
68702: PPUSH
68703: CALL_OW 296
68707: PUSH
68708: LD_INT 12
68710: GREATER
68711: OR
68712: IFFALSE 68716
// exit ;
68714: GO 69069
// missile := [ 1 ] ;
68716: LD_ADDR_VAR 0 14
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: EMPTY
68725: LIST
68726: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68727: LD_VAR 0 9
68731: PPUSH
68732: LD_VAR 0 12
68736: PPUSH
68737: CALL_OW 325
68741: IFFALSE 68770
// missile := Replace ( missile , missile + 1 , 2 ) ;
68743: LD_ADDR_VAR 0 14
68747: PUSH
68748: LD_VAR 0 14
68752: PPUSH
68753: LD_VAR 0 14
68757: PUSH
68758: LD_INT 1
68760: PLUS
68761: PPUSH
68762: LD_INT 2
68764: PPUSH
68765: CALL_OW 1
68769: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68770: LD_VAR 0 9
68774: PPUSH
68775: LD_VAR 0 13
68779: PPUSH
68780: CALL_OW 325
68784: PUSH
68785: LD_VAR 0 10
68789: PPUSH
68790: CALL_OW 255
68794: PPUSH
68795: LD_VAR 0 13
68799: PPUSH
68800: CALL_OW 325
68804: NOT
68805: AND
68806: IFFALSE 68835
// missile := Replace ( missile , missile + 1 , 3 ) ;
68808: LD_ADDR_VAR 0 14
68812: PUSH
68813: LD_VAR 0 14
68817: PPUSH
68818: LD_VAR 0 14
68822: PUSH
68823: LD_INT 1
68825: PLUS
68826: PPUSH
68827: LD_INT 3
68829: PPUSH
68830: CALL_OW 1
68834: ST_TO_ADDR
// if missile < 2 then
68835: LD_VAR 0 14
68839: PUSH
68840: LD_INT 2
68842: LESS
68843: IFFALSE 68847
// exit ;
68845: GO 69069
// x := GetX ( enemy ) ;
68847: LD_ADDR_VAR 0 4
68851: PUSH
68852: LD_VAR 0 10
68856: PPUSH
68857: CALL_OW 250
68861: ST_TO_ADDR
// y := GetY ( enemy ) ;
68862: LD_ADDR_VAR 0 5
68866: PUSH
68867: LD_VAR 0 10
68871: PPUSH
68872: CALL_OW 251
68876: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68877: LD_ADDR_VAR 0 6
68881: PUSH
68882: LD_VAR 0 4
68886: PUSH
68887: LD_INT 1
68889: NEG
68890: PPUSH
68891: LD_INT 1
68893: PPUSH
68894: CALL_OW 12
68898: PLUS
68899: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68900: LD_ADDR_VAR 0 7
68904: PUSH
68905: LD_VAR 0 5
68909: PUSH
68910: LD_INT 1
68912: NEG
68913: PPUSH
68914: LD_INT 1
68916: PPUSH
68917: CALL_OW 12
68921: PLUS
68922: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68923: LD_VAR 0 6
68927: PPUSH
68928: LD_VAR 0 7
68932: PPUSH
68933: CALL_OW 488
68937: NOT
68938: IFFALSE 68960
// begin _x := x ;
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: LD_VAR 0 4
68949: ST_TO_ADDR
// _y := y ;
68950: LD_ADDR_VAR 0 7
68954: PUSH
68955: LD_VAR 0 5
68959: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68960: LD_ADDR_VAR 0 3
68964: PUSH
68965: LD_INT 1
68967: PPUSH
68968: LD_VAR 0 14
68972: PPUSH
68973: CALL_OW 12
68977: ST_TO_ADDR
// case i of 1 :
68978: LD_VAR 0 3
68982: PUSH
68983: LD_INT 1
68985: DOUBLE
68986: EQUAL
68987: IFTRUE 68991
68989: GO 69008
68991: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68992: LD_VAR 0 1
68996: PPUSH
68997: LD_VAR 0 10
69001: PPUSH
69002: CALL_OW 115
69006: GO 69069
69008: LD_INT 2
69010: DOUBLE
69011: EQUAL
69012: IFTRUE 69016
69014: GO 69038
69016: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
69017: LD_VAR 0 1
69021: PPUSH
69022: LD_VAR 0 6
69026: PPUSH
69027: LD_VAR 0 7
69031: PPUSH
69032: CALL_OW 153
69036: GO 69069
69038: LD_INT 3
69040: DOUBLE
69041: EQUAL
69042: IFTRUE 69046
69044: GO 69068
69046: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
69047: LD_VAR 0 1
69051: PPUSH
69052: LD_VAR 0 6
69056: PPUSH
69057: LD_VAR 0 7
69061: PPUSH
69062: CALL_OW 154
69066: GO 69069
69068: POP
// end ;
69069: LD_VAR 0 2
69073: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
69074: LD_INT 0
69076: PPUSH
69077: PPUSH
69078: PPUSH
69079: PPUSH
69080: PPUSH
69081: PPUSH
// if not unit or not building then
69082: LD_VAR 0 1
69086: NOT
69087: PUSH
69088: LD_VAR 0 2
69092: NOT
69093: OR
69094: IFFALSE 69098
// exit ;
69096: GO 69256
// x := GetX ( building ) ;
69098: LD_ADDR_VAR 0 5
69102: PUSH
69103: LD_VAR 0 2
69107: PPUSH
69108: CALL_OW 250
69112: ST_TO_ADDR
// y := GetY ( building ) ;
69113: LD_ADDR_VAR 0 6
69117: PUSH
69118: LD_VAR 0 2
69122: PPUSH
69123: CALL_OW 251
69127: ST_TO_ADDR
// for i = 0 to 5 do
69128: LD_ADDR_VAR 0 4
69132: PUSH
69133: DOUBLE
69134: LD_INT 0
69136: DEC
69137: ST_TO_ADDR
69138: LD_INT 5
69140: PUSH
69141: FOR_TO
69142: IFFALSE 69254
// begin _x := ShiftX ( x , i , 3 ) ;
69144: LD_ADDR_VAR 0 7
69148: PUSH
69149: LD_VAR 0 5
69153: PPUSH
69154: LD_VAR 0 4
69158: PPUSH
69159: LD_INT 3
69161: PPUSH
69162: CALL_OW 272
69166: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
69167: LD_ADDR_VAR 0 8
69171: PUSH
69172: LD_VAR 0 6
69176: PPUSH
69177: LD_VAR 0 4
69181: PPUSH
69182: LD_INT 3
69184: PPUSH
69185: CALL_OW 273
69189: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69190: LD_VAR 0 7
69194: PPUSH
69195: LD_VAR 0 8
69199: PPUSH
69200: CALL_OW 488
69204: NOT
69205: IFFALSE 69209
// continue ;
69207: GO 69141
// if HexInfo ( _x , _y ) = 0 then
69209: LD_VAR 0 7
69213: PPUSH
69214: LD_VAR 0 8
69218: PPUSH
69219: CALL_OW 428
69223: PUSH
69224: LD_INT 0
69226: EQUAL
69227: IFFALSE 69252
// begin ComMoveXY ( unit , _x , _y ) ;
69229: LD_VAR 0 1
69233: PPUSH
69234: LD_VAR 0 7
69238: PPUSH
69239: LD_VAR 0 8
69243: PPUSH
69244: CALL_OW 111
// exit ;
69248: POP
69249: POP
69250: GO 69256
// end ; end ;
69252: GO 69141
69254: POP
69255: POP
// end ;
69256: LD_VAR 0 3
69260: RET
// export function ScanBase ( side , base_area ) ; begin
69261: LD_INT 0
69263: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69264: LD_ADDR_VAR 0 3
69268: PUSH
69269: LD_VAR 0 2
69273: PPUSH
69274: LD_INT 81
69276: PUSH
69277: LD_VAR 0 1
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PPUSH
69286: CALL_OW 70
69290: ST_TO_ADDR
// end ;
69291: LD_VAR 0 3
69295: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69296: LD_INT 0
69298: PPUSH
69299: PPUSH
69300: PPUSH
69301: PPUSH
// result := false ;
69302: LD_ADDR_VAR 0 2
69306: PUSH
69307: LD_INT 0
69309: ST_TO_ADDR
// side := GetSide ( unit ) ;
69310: LD_ADDR_VAR 0 3
69314: PUSH
69315: LD_VAR 0 1
69319: PPUSH
69320: CALL_OW 255
69324: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69325: LD_ADDR_VAR 0 4
69329: PUSH
69330: LD_VAR 0 1
69334: PPUSH
69335: CALL_OW 248
69339: ST_TO_ADDR
// case nat of 1 :
69340: LD_VAR 0 4
69344: PUSH
69345: LD_INT 1
69347: DOUBLE
69348: EQUAL
69349: IFTRUE 69353
69351: GO 69364
69353: POP
// tech := tech_lassight ; 2 :
69354: LD_ADDR_VAR 0 5
69358: PUSH
69359: LD_INT 12
69361: ST_TO_ADDR
69362: GO 69403
69364: LD_INT 2
69366: DOUBLE
69367: EQUAL
69368: IFTRUE 69372
69370: GO 69383
69372: POP
// tech := tech_mortar ; 3 :
69373: LD_ADDR_VAR 0 5
69377: PUSH
69378: LD_INT 41
69380: ST_TO_ADDR
69381: GO 69403
69383: LD_INT 3
69385: DOUBLE
69386: EQUAL
69387: IFTRUE 69391
69389: GO 69402
69391: POP
// tech := tech_bazooka ; end ;
69392: LD_ADDR_VAR 0 5
69396: PUSH
69397: LD_INT 44
69399: ST_TO_ADDR
69400: GO 69403
69402: POP
// if Researched ( side , tech ) then
69403: LD_VAR 0 3
69407: PPUSH
69408: LD_VAR 0 5
69412: PPUSH
69413: CALL_OW 325
69417: IFFALSE 69444
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69419: LD_ADDR_VAR 0 2
69423: PUSH
69424: LD_INT 5
69426: PUSH
69427: LD_INT 8
69429: PUSH
69430: LD_INT 9
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: LIST
69437: PUSH
69438: LD_VAR 0 4
69442: ARRAY
69443: ST_TO_ADDR
// end ;
69444: LD_VAR 0 2
69448: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69449: LD_INT 0
69451: PPUSH
69452: PPUSH
69453: PPUSH
// if not mines then
69454: LD_VAR 0 2
69458: NOT
69459: IFFALSE 69463
// exit ;
69461: GO 69607
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69463: LD_ADDR_VAR 0 5
69467: PUSH
69468: LD_INT 81
69470: PUSH
69471: LD_VAR 0 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 3
69482: PUSH
69483: LD_INT 21
69485: PUSH
69486: LD_INT 3
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PPUSH
69501: CALL_OW 69
69505: ST_TO_ADDR
// for i in mines do
69506: LD_ADDR_VAR 0 4
69510: PUSH
69511: LD_VAR 0 2
69515: PUSH
69516: FOR_IN
69517: IFFALSE 69605
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69519: LD_VAR 0 4
69523: PUSH
69524: LD_INT 1
69526: ARRAY
69527: PPUSH
69528: LD_VAR 0 4
69532: PUSH
69533: LD_INT 2
69535: ARRAY
69536: PPUSH
69537: CALL_OW 458
69541: NOT
69542: IFFALSE 69546
// continue ;
69544: GO 69516
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69546: LD_VAR 0 4
69550: PUSH
69551: LD_INT 1
69553: ARRAY
69554: PPUSH
69555: LD_VAR 0 4
69559: PUSH
69560: LD_INT 2
69562: ARRAY
69563: PPUSH
69564: CALL_OW 428
69568: PUSH
69569: LD_VAR 0 5
69573: IN
69574: IFFALSE 69603
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69576: LD_VAR 0 4
69580: PUSH
69581: LD_INT 1
69583: ARRAY
69584: PPUSH
69585: LD_VAR 0 4
69589: PUSH
69590: LD_INT 2
69592: ARRAY
69593: PPUSH
69594: LD_VAR 0 1
69598: PPUSH
69599: CALL_OW 456
// end ;
69603: GO 69516
69605: POP
69606: POP
// end ;
69607: LD_VAR 0 3
69611: RET
// export function Count ( array ) ; var i ; begin
69612: LD_INT 0
69614: PPUSH
69615: PPUSH
// result := 0 ;
69616: LD_ADDR_VAR 0 2
69620: PUSH
69621: LD_INT 0
69623: ST_TO_ADDR
// for i in array do
69624: LD_ADDR_VAR 0 3
69628: PUSH
69629: LD_VAR 0 1
69633: PUSH
69634: FOR_IN
69635: IFFALSE 69659
// if i then
69637: LD_VAR 0 3
69641: IFFALSE 69657
// result := result + 1 ;
69643: LD_ADDR_VAR 0 2
69647: PUSH
69648: LD_VAR 0 2
69652: PUSH
69653: LD_INT 1
69655: PLUS
69656: ST_TO_ADDR
69657: GO 69634
69659: POP
69660: POP
// end ;
69661: LD_VAR 0 2
69665: RET
// export function IsEmpty ( building ) ; begin
69666: LD_INT 0
69668: PPUSH
// if not building then
69669: LD_VAR 0 1
69673: NOT
69674: IFFALSE 69678
// exit ;
69676: GO 69721
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69678: LD_ADDR_VAR 0 2
69682: PUSH
69683: LD_VAR 0 1
69687: PUSH
69688: LD_INT 22
69690: PUSH
69691: LD_VAR 0 1
69695: PPUSH
69696: CALL_OW 255
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 58
69707: PUSH
69708: EMPTY
69709: LIST
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PPUSH
69715: CALL_OW 69
69719: IN
69720: ST_TO_ADDR
// end ;
69721: LD_VAR 0 2
69725: RET
// export function IsNotFull ( building ) ; var places ; begin
69726: LD_INT 0
69728: PPUSH
69729: PPUSH
// if not building then
69730: LD_VAR 0 1
69734: NOT
69735: IFFALSE 69739
// exit ;
69737: GO 69910
// result := false ;
69739: LD_ADDR_VAR 0 2
69743: PUSH
69744: LD_INT 0
69746: ST_TO_ADDR
// places := 0 ;
69747: LD_ADDR_VAR 0 3
69751: PUSH
69752: LD_INT 0
69754: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69755: LD_VAR 0 1
69759: PPUSH
69760: CALL_OW 266
69764: PUSH
69765: LD_INT 0
69767: DOUBLE
69768: EQUAL
69769: IFTRUE 69827
69771: LD_INT 1
69773: DOUBLE
69774: EQUAL
69775: IFTRUE 69827
69777: LD_INT 6
69779: DOUBLE
69780: EQUAL
69781: IFTRUE 69827
69783: LD_INT 7
69785: DOUBLE
69786: EQUAL
69787: IFTRUE 69827
69789: LD_INT 8
69791: DOUBLE
69792: EQUAL
69793: IFTRUE 69827
69795: LD_INT 4
69797: DOUBLE
69798: EQUAL
69799: IFTRUE 69827
69801: LD_INT 5
69803: DOUBLE
69804: EQUAL
69805: IFTRUE 69827
69807: LD_INT 2
69809: DOUBLE
69810: EQUAL
69811: IFTRUE 69827
69813: LD_INT 3
69815: DOUBLE
69816: EQUAL
69817: IFTRUE 69827
69819: LD_INT 35
69821: DOUBLE
69822: EQUAL
69823: IFTRUE 69827
69825: GO 69838
69827: POP
// places := 6 ; b_bunker , b_breastwork :
69828: LD_ADDR_VAR 0 3
69832: PUSH
69833: LD_INT 6
69835: ST_TO_ADDR
69836: GO 69883
69838: LD_INT 32
69840: DOUBLE
69841: EQUAL
69842: IFTRUE 69852
69844: LD_INT 31
69846: DOUBLE
69847: EQUAL
69848: IFTRUE 69852
69850: GO 69863
69852: POP
// places := 1 ; b_control_tower :
69853: LD_ADDR_VAR 0 3
69857: PUSH
69858: LD_INT 1
69860: ST_TO_ADDR
69861: GO 69883
69863: LD_INT 36
69865: DOUBLE
69866: EQUAL
69867: IFTRUE 69871
69869: GO 69882
69871: POP
// places := 3 ; end ;
69872: LD_ADDR_VAR 0 3
69876: PUSH
69877: LD_INT 3
69879: ST_TO_ADDR
69880: GO 69883
69882: POP
// if places then
69883: LD_VAR 0 3
69887: IFFALSE 69910
// result := UnitsInside ( building ) < places ;
69889: LD_ADDR_VAR 0 2
69893: PUSH
69894: LD_VAR 0 1
69898: PPUSH
69899: CALL_OW 313
69903: PUSH
69904: LD_VAR 0 3
69908: LESS
69909: ST_TO_ADDR
// end ;
69910: LD_VAR 0 2
69914: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69915: LD_INT 0
69917: PPUSH
69918: PPUSH
69919: PPUSH
69920: PPUSH
// tmp := [ ] ;
69921: LD_ADDR_VAR 0 3
69925: PUSH
69926: EMPTY
69927: ST_TO_ADDR
// list := [ ] ;
69928: LD_ADDR_VAR 0 5
69932: PUSH
69933: EMPTY
69934: ST_TO_ADDR
// for i = 16 to 25 do
69935: LD_ADDR_VAR 0 4
69939: PUSH
69940: DOUBLE
69941: LD_INT 16
69943: DEC
69944: ST_TO_ADDR
69945: LD_INT 25
69947: PUSH
69948: FOR_TO
69949: IFFALSE 70022
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69951: LD_ADDR_VAR 0 3
69955: PUSH
69956: LD_VAR 0 3
69960: PUSH
69961: LD_INT 22
69963: PUSH
69964: LD_VAR 0 1
69968: PPUSH
69969: CALL_OW 255
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 91
69980: PUSH
69981: LD_VAR 0 1
69985: PUSH
69986: LD_INT 6
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: LIST
69993: PUSH
69994: LD_INT 30
69996: PUSH
69997: LD_VAR 0 4
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: LIST
70010: PUSH
70011: EMPTY
70012: LIST
70013: PPUSH
70014: CALL_OW 69
70018: ADD
70019: ST_TO_ADDR
70020: GO 69948
70022: POP
70023: POP
// for i = 1 to tmp do
70024: LD_ADDR_VAR 0 4
70028: PUSH
70029: DOUBLE
70030: LD_INT 1
70032: DEC
70033: ST_TO_ADDR
70034: LD_VAR 0 3
70038: PUSH
70039: FOR_TO
70040: IFFALSE 70128
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70042: LD_ADDR_VAR 0 5
70046: PUSH
70047: LD_VAR 0 5
70051: PUSH
70052: LD_VAR 0 3
70056: PUSH
70057: LD_VAR 0 4
70061: ARRAY
70062: PPUSH
70063: CALL_OW 266
70067: PUSH
70068: LD_VAR 0 3
70072: PUSH
70073: LD_VAR 0 4
70077: ARRAY
70078: PPUSH
70079: CALL_OW 250
70083: PUSH
70084: LD_VAR 0 3
70088: PUSH
70089: LD_VAR 0 4
70093: ARRAY
70094: PPUSH
70095: CALL_OW 251
70099: PUSH
70100: LD_VAR 0 3
70104: PUSH
70105: LD_VAR 0 4
70109: ARRAY
70110: PPUSH
70111: CALL_OW 254
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: PUSH
70122: EMPTY
70123: LIST
70124: ADD
70125: ST_TO_ADDR
70126: GO 70039
70128: POP
70129: POP
// result := list ;
70130: LD_ADDR_VAR 0 2
70134: PUSH
70135: LD_VAR 0 5
70139: ST_TO_ADDR
// end ;
70140: LD_VAR 0 2
70144: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
70145: LD_INT 0
70147: PPUSH
70148: PPUSH
70149: PPUSH
70150: PPUSH
70151: PPUSH
70152: PPUSH
70153: PPUSH
// if not factory then
70154: LD_VAR 0 1
70158: NOT
70159: IFFALSE 70163
// exit ;
70161: GO 70756
// if control = control_apeman then
70163: LD_VAR 0 4
70167: PUSH
70168: LD_INT 5
70170: EQUAL
70171: IFFALSE 70280
// begin tmp := UnitsInside ( factory ) ;
70173: LD_ADDR_VAR 0 8
70177: PUSH
70178: LD_VAR 0 1
70182: PPUSH
70183: CALL_OW 313
70187: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70188: LD_VAR 0 8
70192: PPUSH
70193: LD_INT 25
70195: PUSH
70196: LD_INT 12
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PPUSH
70203: CALL_OW 72
70207: NOT
70208: IFFALSE 70218
// control := control_manual ;
70210: LD_ADDR_VAR 0 4
70214: PUSH
70215: LD_INT 1
70217: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70218: LD_ADDR_VAR 0 8
70222: PUSH
70223: LD_VAR 0 1
70227: PPUSH
70228: CALL 69915 0 1
70232: ST_TO_ADDR
// if tmp then
70233: LD_VAR 0 8
70237: IFFALSE 70280
// begin for i in tmp do
70239: LD_ADDR_VAR 0 7
70243: PUSH
70244: LD_VAR 0 8
70248: PUSH
70249: FOR_IN
70250: IFFALSE 70278
// if i [ 1 ] = b_ext_radio then
70252: LD_VAR 0 7
70256: PUSH
70257: LD_INT 1
70259: ARRAY
70260: PUSH
70261: LD_INT 22
70263: EQUAL
70264: IFFALSE 70276
// begin control := control_remote ;
70266: LD_ADDR_VAR 0 4
70270: PUSH
70271: LD_INT 2
70273: ST_TO_ADDR
// break ;
70274: GO 70278
// end ;
70276: GO 70249
70278: POP
70279: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70280: LD_VAR 0 1
70284: PPUSH
70285: LD_VAR 0 2
70289: PPUSH
70290: LD_VAR 0 3
70294: PPUSH
70295: LD_VAR 0 4
70299: PPUSH
70300: LD_VAR 0 5
70304: PPUSH
70305: CALL_OW 448
70309: IFFALSE 70344
// begin result := [ chassis , engine , control , weapon ] ;
70311: LD_ADDR_VAR 0 6
70315: PUSH
70316: LD_VAR 0 2
70320: PUSH
70321: LD_VAR 0 3
70325: PUSH
70326: LD_VAR 0 4
70330: PUSH
70331: LD_VAR 0 5
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: ST_TO_ADDR
// exit ;
70342: GO 70756
// end ; _chassis := AvailableChassisList ( factory ) ;
70344: LD_ADDR_VAR 0 9
70348: PUSH
70349: LD_VAR 0 1
70353: PPUSH
70354: CALL_OW 475
70358: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70359: LD_ADDR_VAR 0 11
70363: PUSH
70364: LD_VAR 0 1
70368: PPUSH
70369: CALL_OW 476
70373: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70374: LD_ADDR_VAR 0 12
70378: PUSH
70379: LD_VAR 0 1
70383: PPUSH
70384: CALL_OW 477
70388: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70389: LD_ADDR_VAR 0 10
70393: PUSH
70394: LD_VAR 0 1
70398: PPUSH
70399: CALL_OW 478
70403: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70404: LD_VAR 0 9
70408: NOT
70409: PUSH
70410: LD_VAR 0 11
70414: NOT
70415: OR
70416: PUSH
70417: LD_VAR 0 12
70421: NOT
70422: OR
70423: PUSH
70424: LD_VAR 0 10
70428: NOT
70429: OR
70430: IFFALSE 70465
// begin result := [ chassis , engine , control , weapon ] ;
70432: LD_ADDR_VAR 0 6
70436: PUSH
70437: LD_VAR 0 2
70441: PUSH
70442: LD_VAR 0 3
70446: PUSH
70447: LD_VAR 0 4
70451: PUSH
70452: LD_VAR 0 5
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: ST_TO_ADDR
// exit ;
70463: GO 70756
// end ; if not chassis in _chassis then
70465: LD_VAR 0 2
70469: PUSH
70470: LD_VAR 0 9
70474: IN
70475: NOT
70476: IFFALSE 70502
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70478: LD_ADDR_VAR 0 2
70482: PUSH
70483: LD_VAR 0 9
70487: PUSH
70488: LD_INT 1
70490: PPUSH
70491: LD_VAR 0 9
70495: PPUSH
70496: CALL_OW 12
70500: ARRAY
70501: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70502: LD_VAR 0 2
70506: PPUSH
70507: LD_VAR 0 3
70511: PPUSH
70512: CALL 70761 0 2
70516: NOT
70517: IFFALSE 70576
// repeat engine := _engine [ 1 ] ;
70519: LD_ADDR_VAR 0 3
70523: PUSH
70524: LD_VAR 0 11
70528: PUSH
70529: LD_INT 1
70531: ARRAY
70532: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70533: LD_ADDR_VAR 0 11
70537: PUSH
70538: LD_VAR 0 11
70542: PPUSH
70543: LD_INT 1
70545: PPUSH
70546: CALL_OW 3
70550: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70551: LD_VAR 0 2
70555: PPUSH
70556: LD_VAR 0 3
70560: PPUSH
70561: CALL 70761 0 2
70565: PUSH
70566: LD_VAR 0 11
70570: PUSH
70571: EMPTY
70572: EQUAL
70573: OR
70574: IFFALSE 70519
// if not control in _control then
70576: LD_VAR 0 4
70580: PUSH
70581: LD_VAR 0 12
70585: IN
70586: NOT
70587: IFFALSE 70613
// control := _control [ rand ( 1 , _control ) ] ;
70589: LD_ADDR_VAR 0 4
70593: PUSH
70594: LD_VAR 0 12
70598: PUSH
70599: LD_INT 1
70601: PPUSH
70602: LD_VAR 0 12
70606: PPUSH
70607: CALL_OW 12
70611: ARRAY
70612: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70613: LD_VAR 0 2
70617: PPUSH
70618: LD_VAR 0 5
70622: PPUSH
70623: CALL 70981 0 2
70627: NOT
70628: IFFALSE 70687
// repeat weapon := _weapon [ 1 ] ;
70630: LD_ADDR_VAR 0 5
70634: PUSH
70635: LD_VAR 0 10
70639: PUSH
70640: LD_INT 1
70642: ARRAY
70643: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70644: LD_ADDR_VAR 0 10
70648: PUSH
70649: LD_VAR 0 10
70653: PPUSH
70654: LD_INT 1
70656: PPUSH
70657: CALL_OW 3
70661: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70662: LD_VAR 0 2
70666: PPUSH
70667: LD_VAR 0 5
70671: PPUSH
70672: CALL 70981 0 2
70676: PUSH
70677: LD_VAR 0 10
70681: PUSH
70682: EMPTY
70683: EQUAL
70684: OR
70685: IFFALSE 70630
// result := [ ] ;
70687: LD_ADDR_VAR 0 6
70691: PUSH
70692: EMPTY
70693: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70694: LD_VAR 0 1
70698: PPUSH
70699: LD_VAR 0 2
70703: PPUSH
70704: LD_VAR 0 3
70708: PPUSH
70709: LD_VAR 0 4
70713: PPUSH
70714: LD_VAR 0 5
70718: PPUSH
70719: CALL_OW 448
70723: IFFALSE 70756
// result := [ chassis , engine , control , weapon ] ;
70725: LD_ADDR_VAR 0 6
70729: PUSH
70730: LD_VAR 0 2
70734: PUSH
70735: LD_VAR 0 3
70739: PUSH
70740: LD_VAR 0 4
70744: PUSH
70745: LD_VAR 0 5
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: ST_TO_ADDR
// end ;
70756: LD_VAR 0 6
70760: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70761: LD_INT 0
70763: PPUSH
// if not chassis or not engine then
70764: LD_VAR 0 1
70768: NOT
70769: PUSH
70770: LD_VAR 0 2
70774: NOT
70775: OR
70776: IFFALSE 70780
// exit ;
70778: GO 70976
// case engine of engine_solar :
70780: LD_VAR 0 2
70784: PUSH
70785: LD_INT 2
70787: DOUBLE
70788: EQUAL
70789: IFTRUE 70793
70791: GO 70831
70793: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70794: LD_ADDR_VAR 0 3
70798: PUSH
70799: LD_INT 11
70801: PUSH
70802: LD_INT 12
70804: PUSH
70805: LD_INT 13
70807: PUSH
70808: LD_INT 14
70810: PUSH
70811: LD_INT 1
70813: PUSH
70814: LD_INT 2
70816: PUSH
70817: LD_INT 3
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: LIST
70828: ST_TO_ADDR
70829: GO 70960
70831: LD_INT 1
70833: DOUBLE
70834: EQUAL
70835: IFTRUE 70839
70837: GO 70901
70839: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70840: LD_ADDR_VAR 0 3
70844: PUSH
70845: LD_INT 11
70847: PUSH
70848: LD_INT 12
70850: PUSH
70851: LD_INT 13
70853: PUSH
70854: LD_INT 14
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: LD_INT 2
70862: PUSH
70863: LD_INT 3
70865: PUSH
70866: LD_INT 4
70868: PUSH
70869: LD_INT 5
70871: PUSH
70872: LD_INT 21
70874: PUSH
70875: LD_INT 23
70877: PUSH
70878: LD_INT 22
70880: PUSH
70881: LD_INT 24
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: ST_TO_ADDR
70899: GO 70960
70901: LD_INT 3
70903: DOUBLE
70904: EQUAL
70905: IFTRUE 70909
70907: GO 70959
70909: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70910: LD_ADDR_VAR 0 3
70914: PUSH
70915: LD_INT 13
70917: PUSH
70918: LD_INT 14
70920: PUSH
70921: LD_INT 2
70923: PUSH
70924: LD_INT 3
70926: PUSH
70927: LD_INT 4
70929: PUSH
70930: LD_INT 5
70932: PUSH
70933: LD_INT 21
70935: PUSH
70936: LD_INT 22
70938: PUSH
70939: LD_INT 23
70941: PUSH
70942: LD_INT 24
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: ST_TO_ADDR
70957: GO 70960
70959: POP
// result := ( chassis in result ) ;
70960: LD_ADDR_VAR 0 3
70964: PUSH
70965: LD_VAR 0 1
70969: PUSH
70970: LD_VAR 0 3
70974: IN
70975: ST_TO_ADDR
// end ;
70976: LD_VAR 0 3
70980: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70981: LD_INT 0
70983: PPUSH
// if not chassis or not weapon then
70984: LD_VAR 0 1
70988: NOT
70989: PUSH
70990: LD_VAR 0 2
70994: NOT
70995: OR
70996: IFFALSE 71000
// exit ;
70998: GO 72060
// case weapon of us_machine_gun :
71000: LD_VAR 0 2
71004: PUSH
71005: LD_INT 2
71007: DOUBLE
71008: EQUAL
71009: IFTRUE 71013
71011: GO 71043
71013: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71014: LD_ADDR_VAR 0 3
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 2
71024: PUSH
71025: LD_INT 3
71027: PUSH
71028: LD_INT 4
71030: PUSH
71031: LD_INT 5
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: ST_TO_ADDR
71041: GO 72044
71043: LD_INT 3
71045: DOUBLE
71046: EQUAL
71047: IFTRUE 71051
71049: GO 71081
71051: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71052: LD_ADDR_VAR 0 3
71056: PUSH
71057: LD_INT 1
71059: PUSH
71060: LD_INT 2
71062: PUSH
71063: LD_INT 3
71065: PUSH
71066: LD_INT 4
71068: PUSH
71069: LD_INT 5
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: ST_TO_ADDR
71079: GO 72044
71081: LD_INT 11
71083: DOUBLE
71084: EQUAL
71085: IFTRUE 71089
71087: GO 71119
71089: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71090: LD_ADDR_VAR 0 3
71094: PUSH
71095: LD_INT 1
71097: PUSH
71098: LD_INT 2
71100: PUSH
71101: LD_INT 3
71103: PUSH
71104: LD_INT 4
71106: PUSH
71107: LD_INT 5
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: LIST
71114: LIST
71115: LIST
71116: ST_TO_ADDR
71117: GO 72044
71119: LD_INT 4
71121: DOUBLE
71122: EQUAL
71123: IFTRUE 71127
71125: GO 71153
71127: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
71128: LD_ADDR_VAR 0 3
71132: PUSH
71133: LD_INT 2
71135: PUSH
71136: LD_INT 3
71138: PUSH
71139: LD_INT 4
71141: PUSH
71142: LD_INT 5
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: ST_TO_ADDR
71151: GO 72044
71153: LD_INT 5
71155: DOUBLE
71156: EQUAL
71157: IFTRUE 71161
71159: GO 71187
71161: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
71162: LD_ADDR_VAR 0 3
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: LD_INT 3
71172: PUSH
71173: LD_INT 4
71175: PUSH
71176: LD_INT 5
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: ST_TO_ADDR
71185: GO 72044
71187: LD_INT 9
71189: DOUBLE
71190: EQUAL
71191: IFTRUE 71195
71193: GO 71221
71195: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71196: LD_ADDR_VAR 0 3
71200: PUSH
71201: LD_INT 2
71203: PUSH
71204: LD_INT 3
71206: PUSH
71207: LD_INT 4
71209: PUSH
71210: LD_INT 5
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: ST_TO_ADDR
71219: GO 72044
71221: LD_INT 7
71223: DOUBLE
71224: EQUAL
71225: IFTRUE 71229
71227: GO 71255
71229: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71230: LD_ADDR_VAR 0 3
71234: PUSH
71235: LD_INT 2
71237: PUSH
71238: LD_INT 3
71240: PUSH
71241: LD_INT 4
71243: PUSH
71244: LD_INT 5
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: ST_TO_ADDR
71253: GO 72044
71255: LD_INT 12
71257: DOUBLE
71258: EQUAL
71259: IFTRUE 71263
71261: GO 71289
71263: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71264: LD_ADDR_VAR 0 3
71268: PUSH
71269: LD_INT 2
71271: PUSH
71272: LD_INT 3
71274: PUSH
71275: LD_INT 4
71277: PUSH
71278: LD_INT 5
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: ST_TO_ADDR
71287: GO 72044
71289: LD_INT 13
71291: DOUBLE
71292: EQUAL
71293: IFTRUE 71297
71295: GO 71323
71297: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71298: LD_ADDR_VAR 0 3
71302: PUSH
71303: LD_INT 2
71305: PUSH
71306: LD_INT 3
71308: PUSH
71309: LD_INT 4
71311: PUSH
71312: LD_INT 5
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: ST_TO_ADDR
71321: GO 72044
71323: LD_INT 14
71325: DOUBLE
71326: EQUAL
71327: IFTRUE 71331
71329: GO 71349
71331: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71332: LD_ADDR_VAR 0 3
71336: PUSH
71337: LD_INT 4
71339: PUSH
71340: LD_INT 5
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: ST_TO_ADDR
71347: GO 72044
71349: LD_INT 6
71351: DOUBLE
71352: EQUAL
71353: IFTRUE 71357
71355: GO 71375
71357: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71358: LD_ADDR_VAR 0 3
71362: PUSH
71363: LD_INT 4
71365: PUSH
71366: LD_INT 5
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: ST_TO_ADDR
71373: GO 72044
71375: LD_INT 10
71377: DOUBLE
71378: EQUAL
71379: IFTRUE 71383
71381: GO 71401
71383: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71384: LD_ADDR_VAR 0 3
71388: PUSH
71389: LD_INT 4
71391: PUSH
71392: LD_INT 5
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: ST_TO_ADDR
71399: GO 72044
71401: LD_INT 22
71403: DOUBLE
71404: EQUAL
71405: IFTRUE 71409
71407: GO 71435
71409: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71410: LD_ADDR_VAR 0 3
71414: PUSH
71415: LD_INT 11
71417: PUSH
71418: LD_INT 12
71420: PUSH
71421: LD_INT 13
71423: PUSH
71424: LD_INT 14
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: ST_TO_ADDR
71433: GO 72044
71435: LD_INT 23
71437: DOUBLE
71438: EQUAL
71439: IFTRUE 71443
71441: GO 71469
71443: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71444: LD_ADDR_VAR 0 3
71448: PUSH
71449: LD_INT 11
71451: PUSH
71452: LD_INT 12
71454: PUSH
71455: LD_INT 13
71457: PUSH
71458: LD_INT 14
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: ST_TO_ADDR
71467: GO 72044
71469: LD_INT 24
71471: DOUBLE
71472: EQUAL
71473: IFTRUE 71477
71475: GO 71503
71477: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71478: LD_ADDR_VAR 0 3
71482: PUSH
71483: LD_INT 11
71485: PUSH
71486: LD_INT 12
71488: PUSH
71489: LD_INT 13
71491: PUSH
71492: LD_INT 14
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: ST_TO_ADDR
71501: GO 72044
71503: LD_INT 30
71505: DOUBLE
71506: EQUAL
71507: IFTRUE 71511
71509: GO 71537
71511: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71512: LD_ADDR_VAR 0 3
71516: PUSH
71517: LD_INT 11
71519: PUSH
71520: LD_INT 12
71522: PUSH
71523: LD_INT 13
71525: PUSH
71526: LD_INT 14
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: ST_TO_ADDR
71535: GO 72044
71537: LD_INT 25
71539: DOUBLE
71540: EQUAL
71541: IFTRUE 71545
71543: GO 71563
71545: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71546: LD_ADDR_VAR 0 3
71550: PUSH
71551: LD_INT 13
71553: PUSH
71554: LD_INT 14
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: ST_TO_ADDR
71561: GO 72044
71563: LD_INT 27
71565: DOUBLE
71566: EQUAL
71567: IFTRUE 71571
71569: GO 71589
71571: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71572: LD_ADDR_VAR 0 3
71576: PUSH
71577: LD_INT 13
71579: PUSH
71580: LD_INT 14
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: ST_TO_ADDR
71587: GO 72044
71589: LD_INT 92
71591: DOUBLE
71592: EQUAL
71593: IFTRUE 71597
71595: GO 71623
71597: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71598: LD_ADDR_VAR 0 3
71602: PUSH
71603: LD_INT 11
71605: PUSH
71606: LD_INT 12
71608: PUSH
71609: LD_INT 13
71611: PUSH
71612: LD_INT 14
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: ST_TO_ADDR
71621: GO 72044
71623: LD_INT 28
71625: DOUBLE
71626: EQUAL
71627: IFTRUE 71631
71629: GO 71649
71631: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71632: LD_ADDR_VAR 0 3
71636: PUSH
71637: LD_INT 13
71639: PUSH
71640: LD_INT 14
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: ST_TO_ADDR
71647: GO 72044
71649: LD_INT 29
71651: DOUBLE
71652: EQUAL
71653: IFTRUE 71657
71655: GO 71675
71657: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71658: LD_ADDR_VAR 0 3
71662: PUSH
71663: LD_INT 13
71665: PUSH
71666: LD_INT 14
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: ST_TO_ADDR
71673: GO 72044
71675: LD_INT 31
71677: DOUBLE
71678: EQUAL
71679: IFTRUE 71683
71681: GO 71701
71683: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71684: LD_ADDR_VAR 0 3
71688: PUSH
71689: LD_INT 13
71691: PUSH
71692: LD_INT 14
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: ST_TO_ADDR
71699: GO 72044
71701: LD_INT 26
71703: DOUBLE
71704: EQUAL
71705: IFTRUE 71709
71707: GO 71727
71709: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71710: LD_ADDR_VAR 0 3
71714: PUSH
71715: LD_INT 13
71717: PUSH
71718: LD_INT 14
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: ST_TO_ADDR
71725: GO 72044
71727: LD_INT 42
71729: DOUBLE
71730: EQUAL
71731: IFTRUE 71735
71733: GO 71761
71735: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71736: LD_ADDR_VAR 0 3
71740: PUSH
71741: LD_INT 21
71743: PUSH
71744: LD_INT 22
71746: PUSH
71747: LD_INT 23
71749: PUSH
71750: LD_INT 24
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: ST_TO_ADDR
71759: GO 72044
71761: LD_INT 43
71763: DOUBLE
71764: EQUAL
71765: IFTRUE 71769
71767: GO 71795
71769: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71770: LD_ADDR_VAR 0 3
71774: PUSH
71775: LD_INT 21
71777: PUSH
71778: LD_INT 22
71780: PUSH
71781: LD_INT 23
71783: PUSH
71784: LD_INT 24
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: ST_TO_ADDR
71793: GO 72044
71795: LD_INT 44
71797: DOUBLE
71798: EQUAL
71799: IFTRUE 71803
71801: GO 71829
71803: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71804: LD_ADDR_VAR 0 3
71808: PUSH
71809: LD_INT 21
71811: PUSH
71812: LD_INT 22
71814: PUSH
71815: LD_INT 23
71817: PUSH
71818: LD_INT 24
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: ST_TO_ADDR
71827: GO 72044
71829: LD_INT 45
71831: DOUBLE
71832: EQUAL
71833: IFTRUE 71837
71835: GO 71863
71837: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71838: LD_ADDR_VAR 0 3
71842: PUSH
71843: LD_INT 21
71845: PUSH
71846: LD_INT 22
71848: PUSH
71849: LD_INT 23
71851: PUSH
71852: LD_INT 24
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: ST_TO_ADDR
71861: GO 72044
71863: LD_INT 49
71865: DOUBLE
71866: EQUAL
71867: IFTRUE 71871
71869: GO 71897
71871: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71872: LD_ADDR_VAR 0 3
71876: PUSH
71877: LD_INT 21
71879: PUSH
71880: LD_INT 22
71882: PUSH
71883: LD_INT 23
71885: PUSH
71886: LD_INT 24
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: ST_TO_ADDR
71895: GO 72044
71897: LD_INT 51
71899: DOUBLE
71900: EQUAL
71901: IFTRUE 71905
71903: GO 71931
71905: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71906: LD_ADDR_VAR 0 3
71910: PUSH
71911: LD_INT 21
71913: PUSH
71914: LD_INT 22
71916: PUSH
71917: LD_INT 23
71919: PUSH
71920: LD_INT 24
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: ST_TO_ADDR
71929: GO 72044
71931: LD_INT 52
71933: DOUBLE
71934: EQUAL
71935: IFTRUE 71939
71937: GO 71965
71939: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71940: LD_ADDR_VAR 0 3
71944: PUSH
71945: LD_INT 21
71947: PUSH
71948: LD_INT 22
71950: PUSH
71951: LD_INT 23
71953: PUSH
71954: LD_INT 24
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: ST_TO_ADDR
71963: GO 72044
71965: LD_INT 53
71967: DOUBLE
71968: EQUAL
71969: IFTRUE 71973
71971: GO 71991
71973: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71974: LD_ADDR_VAR 0 3
71978: PUSH
71979: LD_INT 23
71981: PUSH
71982: LD_INT 24
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: ST_TO_ADDR
71989: GO 72044
71991: LD_INT 46
71993: DOUBLE
71994: EQUAL
71995: IFTRUE 71999
71997: GO 72017
71999: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72000: LD_ADDR_VAR 0 3
72004: PUSH
72005: LD_INT 23
72007: PUSH
72008: LD_INT 24
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: ST_TO_ADDR
72015: GO 72044
72017: LD_INT 47
72019: DOUBLE
72020: EQUAL
72021: IFTRUE 72025
72023: GO 72043
72025: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72026: LD_ADDR_VAR 0 3
72030: PUSH
72031: LD_INT 23
72033: PUSH
72034: LD_INT 24
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: ST_TO_ADDR
72041: GO 72044
72043: POP
// result := ( chassis in result ) ;
72044: LD_ADDR_VAR 0 3
72048: PUSH
72049: LD_VAR 0 1
72053: PUSH
72054: LD_VAR 0 3
72058: IN
72059: ST_TO_ADDR
// end ;
72060: LD_VAR 0 3
72064: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72065: LD_INT 0
72067: PPUSH
72068: PPUSH
72069: PPUSH
72070: PPUSH
72071: PPUSH
72072: PPUSH
72073: PPUSH
// result := array ;
72074: LD_ADDR_VAR 0 5
72078: PUSH
72079: LD_VAR 0 1
72083: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72084: LD_VAR 0 1
72088: NOT
72089: PUSH
72090: LD_VAR 0 2
72094: NOT
72095: OR
72096: PUSH
72097: LD_VAR 0 3
72101: NOT
72102: OR
72103: PUSH
72104: LD_VAR 0 2
72108: PUSH
72109: LD_VAR 0 1
72113: GREATER
72114: OR
72115: PUSH
72116: LD_VAR 0 3
72120: PUSH
72121: LD_VAR 0 1
72125: GREATER
72126: OR
72127: IFFALSE 72131
// exit ;
72129: GO 72427
// if direction then
72131: LD_VAR 0 4
72135: IFFALSE 72199
// begin d := 1 ;
72137: LD_ADDR_VAR 0 9
72141: PUSH
72142: LD_INT 1
72144: ST_TO_ADDR
// if i_from > i_to then
72145: LD_VAR 0 2
72149: PUSH
72150: LD_VAR 0 3
72154: GREATER
72155: IFFALSE 72181
// length := ( array - i_from ) + i_to else
72157: LD_ADDR_VAR 0 11
72161: PUSH
72162: LD_VAR 0 1
72166: PUSH
72167: LD_VAR 0 2
72171: MINUS
72172: PUSH
72173: LD_VAR 0 3
72177: PLUS
72178: ST_TO_ADDR
72179: GO 72197
// length := i_to - i_from ;
72181: LD_ADDR_VAR 0 11
72185: PUSH
72186: LD_VAR 0 3
72190: PUSH
72191: LD_VAR 0 2
72195: MINUS
72196: ST_TO_ADDR
// end else
72197: GO 72260
// begin d := - 1 ;
72199: LD_ADDR_VAR 0 9
72203: PUSH
72204: LD_INT 1
72206: NEG
72207: ST_TO_ADDR
// if i_from > i_to then
72208: LD_VAR 0 2
72212: PUSH
72213: LD_VAR 0 3
72217: GREATER
72218: IFFALSE 72238
// length := i_from - i_to else
72220: LD_ADDR_VAR 0 11
72224: PUSH
72225: LD_VAR 0 2
72229: PUSH
72230: LD_VAR 0 3
72234: MINUS
72235: ST_TO_ADDR
72236: GO 72260
// length := ( array - i_to ) + i_from ;
72238: LD_ADDR_VAR 0 11
72242: PUSH
72243: LD_VAR 0 1
72247: PUSH
72248: LD_VAR 0 3
72252: MINUS
72253: PUSH
72254: LD_VAR 0 2
72258: PLUS
72259: ST_TO_ADDR
// end ; if not length then
72260: LD_VAR 0 11
72264: NOT
72265: IFFALSE 72269
// exit ;
72267: GO 72427
// tmp := array ;
72269: LD_ADDR_VAR 0 10
72273: PUSH
72274: LD_VAR 0 1
72278: ST_TO_ADDR
// for i = 1 to length do
72279: LD_ADDR_VAR 0 6
72283: PUSH
72284: DOUBLE
72285: LD_INT 1
72287: DEC
72288: ST_TO_ADDR
72289: LD_VAR 0 11
72293: PUSH
72294: FOR_TO
72295: IFFALSE 72415
// begin for j = 1 to array do
72297: LD_ADDR_VAR 0 7
72301: PUSH
72302: DOUBLE
72303: LD_INT 1
72305: DEC
72306: ST_TO_ADDR
72307: LD_VAR 0 1
72311: PUSH
72312: FOR_TO
72313: IFFALSE 72401
// begin k := j + d ;
72315: LD_ADDR_VAR 0 8
72319: PUSH
72320: LD_VAR 0 7
72324: PUSH
72325: LD_VAR 0 9
72329: PLUS
72330: ST_TO_ADDR
// if k > array then
72331: LD_VAR 0 8
72335: PUSH
72336: LD_VAR 0 1
72340: GREATER
72341: IFFALSE 72351
// k := 1 ;
72343: LD_ADDR_VAR 0 8
72347: PUSH
72348: LD_INT 1
72350: ST_TO_ADDR
// if not k then
72351: LD_VAR 0 8
72355: NOT
72356: IFFALSE 72368
// k := array ;
72358: LD_ADDR_VAR 0 8
72362: PUSH
72363: LD_VAR 0 1
72367: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72368: LD_ADDR_VAR 0 10
72372: PUSH
72373: LD_VAR 0 10
72377: PPUSH
72378: LD_VAR 0 8
72382: PPUSH
72383: LD_VAR 0 1
72387: PUSH
72388: LD_VAR 0 7
72392: ARRAY
72393: PPUSH
72394: CALL_OW 1
72398: ST_TO_ADDR
// end ;
72399: GO 72312
72401: POP
72402: POP
// array := tmp ;
72403: LD_ADDR_VAR 0 1
72407: PUSH
72408: LD_VAR 0 10
72412: ST_TO_ADDR
// end ;
72413: GO 72294
72415: POP
72416: POP
// result := array ;
72417: LD_ADDR_VAR 0 5
72421: PUSH
72422: LD_VAR 0 1
72426: ST_TO_ADDR
// end ;
72427: LD_VAR 0 5
72431: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72432: LD_INT 0
72434: PPUSH
72435: PPUSH
// result := 0 ;
72436: LD_ADDR_VAR 0 3
72440: PUSH
72441: LD_INT 0
72443: ST_TO_ADDR
// if not array or not value in array then
72444: LD_VAR 0 1
72448: NOT
72449: PUSH
72450: LD_VAR 0 2
72454: PUSH
72455: LD_VAR 0 1
72459: IN
72460: NOT
72461: OR
72462: IFFALSE 72466
// exit ;
72464: GO 72520
// for i = 1 to array do
72466: LD_ADDR_VAR 0 4
72470: PUSH
72471: DOUBLE
72472: LD_INT 1
72474: DEC
72475: ST_TO_ADDR
72476: LD_VAR 0 1
72480: PUSH
72481: FOR_TO
72482: IFFALSE 72518
// if value = array [ i ] then
72484: LD_VAR 0 2
72488: PUSH
72489: LD_VAR 0 1
72493: PUSH
72494: LD_VAR 0 4
72498: ARRAY
72499: EQUAL
72500: IFFALSE 72516
// begin result := i ;
72502: LD_ADDR_VAR 0 3
72506: PUSH
72507: LD_VAR 0 4
72511: ST_TO_ADDR
// exit ;
72512: POP
72513: POP
72514: GO 72520
// end ;
72516: GO 72481
72518: POP
72519: POP
// end ;
72520: LD_VAR 0 3
72524: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72525: LD_INT 0
72527: PPUSH
// vc_chassis := chassis ;
72528: LD_ADDR_OWVAR 37
72532: PUSH
72533: LD_VAR 0 1
72537: ST_TO_ADDR
// vc_engine := engine ;
72538: LD_ADDR_OWVAR 39
72542: PUSH
72543: LD_VAR 0 2
72547: ST_TO_ADDR
// vc_control := control ;
72548: LD_ADDR_OWVAR 38
72552: PUSH
72553: LD_VAR 0 3
72557: ST_TO_ADDR
// vc_weapon := weapon ;
72558: LD_ADDR_OWVAR 40
72562: PUSH
72563: LD_VAR 0 4
72567: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72568: LD_ADDR_OWVAR 41
72572: PUSH
72573: LD_VAR 0 5
72577: ST_TO_ADDR
// end ;
72578: LD_VAR 0 6
72582: RET
// export function WantPlant ( unit ) ; var task ; begin
72583: LD_INT 0
72585: PPUSH
72586: PPUSH
// result := false ;
72587: LD_ADDR_VAR 0 2
72591: PUSH
72592: LD_INT 0
72594: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72595: LD_ADDR_VAR 0 3
72599: PUSH
72600: LD_VAR 0 1
72604: PPUSH
72605: CALL_OW 437
72609: ST_TO_ADDR
// if task then
72610: LD_VAR 0 3
72614: IFFALSE 72642
// if task [ 1 ] [ 1 ] = p then
72616: LD_VAR 0 3
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: PUSH
72625: LD_INT 1
72627: ARRAY
72628: PUSH
72629: LD_STRING p
72631: EQUAL
72632: IFFALSE 72642
// result := true ;
72634: LD_ADDR_VAR 0 2
72638: PUSH
72639: LD_INT 1
72641: ST_TO_ADDR
// end ;
72642: LD_VAR 0 2
72646: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72647: LD_INT 0
72649: PPUSH
72650: PPUSH
72651: PPUSH
72652: PPUSH
// if pos < 1 then
72653: LD_VAR 0 2
72657: PUSH
72658: LD_INT 1
72660: LESS
72661: IFFALSE 72665
// exit ;
72663: GO 72968
// if pos = 1 then
72665: LD_VAR 0 2
72669: PUSH
72670: LD_INT 1
72672: EQUAL
72673: IFFALSE 72706
// result := Replace ( arr , pos [ 1 ] , value ) else
72675: LD_ADDR_VAR 0 4
72679: PUSH
72680: LD_VAR 0 1
72684: PPUSH
72685: LD_VAR 0 2
72689: PUSH
72690: LD_INT 1
72692: ARRAY
72693: PPUSH
72694: LD_VAR 0 3
72698: PPUSH
72699: CALL_OW 1
72703: ST_TO_ADDR
72704: GO 72968
// begin tmp := arr ;
72706: LD_ADDR_VAR 0 6
72710: PUSH
72711: LD_VAR 0 1
72715: ST_TO_ADDR
// s_arr := [ tmp ] ;
72716: LD_ADDR_VAR 0 7
72720: PUSH
72721: LD_VAR 0 6
72725: PUSH
72726: EMPTY
72727: LIST
72728: ST_TO_ADDR
// for i = 1 to pos - 1 do
72729: LD_ADDR_VAR 0 5
72733: PUSH
72734: DOUBLE
72735: LD_INT 1
72737: DEC
72738: ST_TO_ADDR
72739: LD_VAR 0 2
72743: PUSH
72744: LD_INT 1
72746: MINUS
72747: PUSH
72748: FOR_TO
72749: IFFALSE 72794
// begin tmp := tmp [ pos [ i ] ] ;
72751: LD_ADDR_VAR 0 6
72755: PUSH
72756: LD_VAR 0 6
72760: PUSH
72761: LD_VAR 0 2
72765: PUSH
72766: LD_VAR 0 5
72770: ARRAY
72771: ARRAY
72772: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72773: LD_ADDR_VAR 0 7
72777: PUSH
72778: LD_VAR 0 7
72782: PUSH
72783: LD_VAR 0 6
72787: PUSH
72788: EMPTY
72789: LIST
72790: ADD
72791: ST_TO_ADDR
// end ;
72792: GO 72748
72794: POP
72795: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72796: LD_ADDR_VAR 0 6
72800: PUSH
72801: LD_VAR 0 6
72805: PPUSH
72806: LD_VAR 0 2
72810: PUSH
72811: LD_VAR 0 2
72815: ARRAY
72816: PPUSH
72817: LD_VAR 0 3
72821: PPUSH
72822: CALL_OW 1
72826: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72827: LD_ADDR_VAR 0 7
72831: PUSH
72832: LD_VAR 0 7
72836: PPUSH
72837: LD_VAR 0 7
72841: PPUSH
72842: LD_VAR 0 6
72846: PPUSH
72847: CALL_OW 1
72851: ST_TO_ADDR
// for i = s_arr downto 2 do
72852: LD_ADDR_VAR 0 5
72856: PUSH
72857: DOUBLE
72858: LD_VAR 0 7
72862: INC
72863: ST_TO_ADDR
72864: LD_INT 2
72866: PUSH
72867: FOR_DOWNTO
72868: IFFALSE 72952
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72870: LD_ADDR_VAR 0 6
72874: PUSH
72875: LD_VAR 0 7
72879: PUSH
72880: LD_VAR 0 5
72884: PUSH
72885: LD_INT 1
72887: MINUS
72888: ARRAY
72889: PPUSH
72890: LD_VAR 0 2
72894: PUSH
72895: LD_VAR 0 5
72899: PUSH
72900: LD_INT 1
72902: MINUS
72903: ARRAY
72904: PPUSH
72905: LD_VAR 0 7
72909: PUSH
72910: LD_VAR 0 5
72914: ARRAY
72915: PPUSH
72916: CALL_OW 1
72920: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72921: LD_ADDR_VAR 0 7
72925: PUSH
72926: LD_VAR 0 7
72930: PPUSH
72931: LD_VAR 0 5
72935: PUSH
72936: LD_INT 1
72938: MINUS
72939: PPUSH
72940: LD_VAR 0 6
72944: PPUSH
72945: CALL_OW 1
72949: ST_TO_ADDR
// end ;
72950: GO 72867
72952: POP
72953: POP
// result := s_arr [ 1 ] ;
72954: LD_ADDR_VAR 0 4
72958: PUSH
72959: LD_VAR 0 7
72963: PUSH
72964: LD_INT 1
72966: ARRAY
72967: ST_TO_ADDR
// end ; end ;
72968: LD_VAR 0 4
72972: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72973: LD_INT 0
72975: PPUSH
72976: PPUSH
// if not list then
72977: LD_VAR 0 1
72981: NOT
72982: IFFALSE 72986
// exit ;
72984: GO 73077
// i := list [ pos1 ] ;
72986: LD_ADDR_VAR 0 5
72990: PUSH
72991: LD_VAR 0 1
72995: PUSH
72996: LD_VAR 0 2
73000: ARRAY
73001: ST_TO_ADDR
// if not i then
73002: LD_VAR 0 5
73006: NOT
73007: IFFALSE 73011
// exit ;
73009: GO 73077
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73011: LD_ADDR_VAR 0 1
73015: PUSH
73016: LD_VAR 0 1
73020: PPUSH
73021: LD_VAR 0 2
73025: PPUSH
73026: LD_VAR 0 1
73030: PUSH
73031: LD_VAR 0 3
73035: ARRAY
73036: PPUSH
73037: CALL_OW 1
73041: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73042: LD_ADDR_VAR 0 1
73046: PUSH
73047: LD_VAR 0 1
73051: PPUSH
73052: LD_VAR 0 3
73056: PPUSH
73057: LD_VAR 0 5
73061: PPUSH
73062: CALL_OW 1
73066: ST_TO_ADDR
// result := list ;
73067: LD_ADDR_VAR 0 4
73071: PUSH
73072: LD_VAR 0 1
73076: ST_TO_ADDR
// end ;
73077: LD_VAR 0 4
73081: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73082: LD_INT 0
73084: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73085: LD_ADDR_VAR 0 5
73089: PUSH
73090: LD_VAR 0 1
73094: PPUSH
73095: CALL_OW 250
73099: PPUSH
73100: LD_VAR 0 1
73104: PPUSH
73105: CALL_OW 251
73109: PPUSH
73110: LD_VAR 0 2
73114: PPUSH
73115: LD_VAR 0 3
73119: PPUSH
73120: LD_VAR 0 4
73124: PPUSH
73125: CALL 73135 0 5
73129: ST_TO_ADDR
// end ;
73130: LD_VAR 0 5
73134: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
73135: LD_INT 0
73137: PPUSH
73138: PPUSH
73139: PPUSH
73140: PPUSH
// if not list then
73141: LD_VAR 0 3
73145: NOT
73146: IFFALSE 73150
// exit ;
73148: GO 73538
// result := [ ] ;
73150: LD_ADDR_VAR 0 6
73154: PUSH
73155: EMPTY
73156: ST_TO_ADDR
// for i in list do
73157: LD_ADDR_VAR 0 7
73161: PUSH
73162: LD_VAR 0 3
73166: PUSH
73167: FOR_IN
73168: IFFALSE 73370
// begin tmp := GetDistUnitXY ( i , x , y ) ;
73170: LD_ADDR_VAR 0 9
73174: PUSH
73175: LD_VAR 0 7
73179: PPUSH
73180: LD_VAR 0 1
73184: PPUSH
73185: LD_VAR 0 2
73189: PPUSH
73190: CALL_OW 297
73194: ST_TO_ADDR
// if not result then
73195: LD_VAR 0 6
73199: NOT
73200: IFFALSE 73226
// result := [ [ i , tmp ] ] else
73202: LD_ADDR_VAR 0 6
73206: PUSH
73207: LD_VAR 0 7
73211: PUSH
73212: LD_VAR 0 9
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: EMPTY
73222: LIST
73223: ST_TO_ADDR
73224: GO 73368
// begin if result [ result ] [ 2 ] < tmp then
73226: LD_VAR 0 6
73230: PUSH
73231: LD_VAR 0 6
73235: ARRAY
73236: PUSH
73237: LD_INT 2
73239: ARRAY
73240: PUSH
73241: LD_VAR 0 9
73245: LESS
73246: IFFALSE 73288
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73248: LD_ADDR_VAR 0 6
73252: PUSH
73253: LD_VAR 0 6
73257: PPUSH
73258: LD_VAR 0 6
73262: PUSH
73263: LD_INT 1
73265: PLUS
73266: PPUSH
73267: LD_VAR 0 7
73271: PUSH
73272: LD_VAR 0 9
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 2
73285: ST_TO_ADDR
73286: GO 73368
// for j = 1 to result do
73288: LD_ADDR_VAR 0 8
73292: PUSH
73293: DOUBLE
73294: LD_INT 1
73296: DEC
73297: ST_TO_ADDR
73298: LD_VAR 0 6
73302: PUSH
73303: FOR_TO
73304: IFFALSE 73366
// begin if tmp < result [ j ] [ 2 ] then
73306: LD_VAR 0 9
73310: PUSH
73311: LD_VAR 0 6
73315: PUSH
73316: LD_VAR 0 8
73320: ARRAY
73321: PUSH
73322: LD_INT 2
73324: ARRAY
73325: LESS
73326: IFFALSE 73364
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73328: LD_ADDR_VAR 0 6
73332: PUSH
73333: LD_VAR 0 6
73337: PPUSH
73338: LD_VAR 0 8
73342: PPUSH
73343: LD_VAR 0 7
73347: PUSH
73348: LD_VAR 0 9
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PPUSH
73357: CALL_OW 2
73361: ST_TO_ADDR
// break ;
73362: GO 73366
// end ; end ;
73364: GO 73303
73366: POP
73367: POP
// end ; end ;
73368: GO 73167
73370: POP
73371: POP
// if result and not asc then
73372: LD_VAR 0 6
73376: PUSH
73377: LD_VAR 0 4
73381: NOT
73382: AND
73383: IFFALSE 73458
// begin tmp := result ;
73385: LD_ADDR_VAR 0 9
73389: PUSH
73390: LD_VAR 0 6
73394: ST_TO_ADDR
// for i = tmp downto 1 do
73395: LD_ADDR_VAR 0 7
73399: PUSH
73400: DOUBLE
73401: LD_VAR 0 9
73405: INC
73406: ST_TO_ADDR
73407: LD_INT 1
73409: PUSH
73410: FOR_DOWNTO
73411: IFFALSE 73456
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73413: LD_ADDR_VAR 0 6
73417: PUSH
73418: LD_VAR 0 6
73422: PPUSH
73423: LD_VAR 0 9
73427: PUSH
73428: LD_VAR 0 7
73432: MINUS
73433: PUSH
73434: LD_INT 1
73436: PLUS
73437: PPUSH
73438: LD_VAR 0 9
73442: PUSH
73443: LD_VAR 0 7
73447: ARRAY
73448: PPUSH
73449: CALL_OW 1
73453: ST_TO_ADDR
73454: GO 73410
73456: POP
73457: POP
// end ; tmp := [ ] ;
73458: LD_ADDR_VAR 0 9
73462: PUSH
73463: EMPTY
73464: ST_TO_ADDR
// if mode then
73465: LD_VAR 0 5
73469: IFFALSE 73538
// begin for i = 1 to result do
73471: LD_ADDR_VAR 0 7
73475: PUSH
73476: DOUBLE
73477: LD_INT 1
73479: DEC
73480: ST_TO_ADDR
73481: LD_VAR 0 6
73485: PUSH
73486: FOR_TO
73487: IFFALSE 73526
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73489: LD_ADDR_VAR 0 9
73493: PUSH
73494: LD_VAR 0 9
73498: PPUSH
73499: LD_VAR 0 7
73503: PPUSH
73504: LD_VAR 0 6
73508: PUSH
73509: LD_VAR 0 7
73513: ARRAY
73514: PUSH
73515: LD_INT 1
73517: ARRAY
73518: PPUSH
73519: CALL_OW 1
73523: ST_TO_ADDR
73524: GO 73486
73526: POP
73527: POP
// result := tmp ;
73528: LD_ADDR_VAR 0 6
73532: PUSH
73533: LD_VAR 0 9
73537: ST_TO_ADDR
// end ; end ;
73538: LD_VAR 0 6
73542: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73543: LD_INT 0
73545: PPUSH
73546: PPUSH
73547: PPUSH
73548: PPUSH
73549: PPUSH
73550: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73551: LD_ADDR_VAR 0 5
73555: PUSH
73556: LD_INT 0
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: LD_INT 0
73564: PUSH
73565: EMPTY
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: ST_TO_ADDR
// if not x or not y then
73573: LD_VAR 0 2
73577: NOT
73578: PUSH
73579: LD_VAR 0 3
73583: NOT
73584: OR
73585: IFFALSE 73589
// exit ;
73587: GO 75239
// if not range then
73589: LD_VAR 0 4
73593: NOT
73594: IFFALSE 73604
// range := 10 ;
73596: LD_ADDR_VAR 0 4
73600: PUSH
73601: LD_INT 10
73603: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73604: LD_ADDR_VAR 0 8
73608: PUSH
73609: LD_INT 81
73611: PUSH
73612: LD_VAR 0 1
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 92
73623: PUSH
73624: LD_VAR 0 2
73628: PUSH
73629: LD_VAR 0 3
73633: PUSH
73634: LD_VAR 0 4
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: PUSH
73645: LD_INT 3
73647: PUSH
73648: LD_INT 21
73650: PUSH
73651: LD_INT 3
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: LIST
73666: PPUSH
73667: CALL_OW 69
73671: ST_TO_ADDR
// if not tmp then
73672: LD_VAR 0 8
73676: NOT
73677: IFFALSE 73681
// exit ;
73679: GO 75239
// for i in tmp do
73681: LD_ADDR_VAR 0 6
73685: PUSH
73686: LD_VAR 0 8
73690: PUSH
73691: FOR_IN
73692: IFFALSE 75214
// begin points := [ 0 , 0 , 0 ] ;
73694: LD_ADDR_VAR 0 9
73698: PUSH
73699: LD_INT 0
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: LIST
73712: ST_TO_ADDR
// bpoints := 1 ;
73713: LD_ADDR_VAR 0 10
73717: PUSH
73718: LD_INT 1
73720: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73721: LD_VAR 0 6
73725: PPUSH
73726: CALL_OW 247
73730: PUSH
73731: LD_INT 1
73733: DOUBLE
73734: EQUAL
73735: IFTRUE 73739
73737: GO 74317
73739: POP
// begin if GetClass ( i ) = 1 then
73740: LD_VAR 0 6
73744: PPUSH
73745: CALL_OW 257
73749: PUSH
73750: LD_INT 1
73752: EQUAL
73753: IFFALSE 73774
// points := [ 10 , 5 , 3 ] ;
73755: LD_ADDR_VAR 0 9
73759: PUSH
73760: LD_INT 10
73762: PUSH
73763: LD_INT 5
73765: PUSH
73766: LD_INT 3
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: LIST
73773: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73774: LD_VAR 0 6
73778: PPUSH
73779: CALL_OW 257
73783: PUSH
73784: LD_INT 2
73786: PUSH
73787: LD_INT 3
73789: PUSH
73790: LD_INT 4
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: LIST
73797: IN
73798: IFFALSE 73819
// points := [ 3 , 2 , 1 ] ;
73800: LD_ADDR_VAR 0 9
73804: PUSH
73805: LD_INT 3
73807: PUSH
73808: LD_INT 2
73810: PUSH
73811: LD_INT 1
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: LIST
73818: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73819: LD_VAR 0 6
73823: PPUSH
73824: CALL_OW 257
73828: PUSH
73829: LD_INT 5
73831: EQUAL
73832: IFFALSE 73853
// points := [ 130 , 5 , 2 ] ;
73834: LD_ADDR_VAR 0 9
73838: PUSH
73839: LD_INT 130
73841: PUSH
73842: LD_INT 5
73844: PUSH
73845: LD_INT 2
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: LIST
73852: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73853: LD_VAR 0 6
73857: PPUSH
73858: CALL_OW 257
73862: PUSH
73863: LD_INT 8
73865: EQUAL
73866: IFFALSE 73887
// points := [ 35 , 35 , 30 ] ;
73868: LD_ADDR_VAR 0 9
73872: PUSH
73873: LD_INT 35
73875: PUSH
73876: LD_INT 35
73878: PUSH
73879: LD_INT 30
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: LIST
73886: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73887: LD_VAR 0 6
73891: PPUSH
73892: CALL_OW 257
73896: PUSH
73897: LD_INT 9
73899: EQUAL
73900: IFFALSE 73921
// points := [ 20 , 55 , 40 ] ;
73902: LD_ADDR_VAR 0 9
73906: PUSH
73907: LD_INT 20
73909: PUSH
73910: LD_INT 55
73912: PUSH
73913: LD_INT 40
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: LIST
73920: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73921: LD_VAR 0 6
73925: PPUSH
73926: CALL_OW 257
73930: PUSH
73931: LD_INT 12
73933: PUSH
73934: LD_INT 16
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: IN
73941: IFFALSE 73962
// points := [ 5 , 3 , 2 ] ;
73943: LD_ADDR_VAR 0 9
73947: PUSH
73948: LD_INT 5
73950: PUSH
73951: LD_INT 3
73953: PUSH
73954: LD_INT 2
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: LIST
73961: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73962: LD_VAR 0 6
73966: PPUSH
73967: CALL_OW 257
73971: PUSH
73972: LD_INT 17
73974: EQUAL
73975: IFFALSE 73996
// points := [ 100 , 50 , 75 ] ;
73977: LD_ADDR_VAR 0 9
73981: PUSH
73982: LD_INT 100
73984: PUSH
73985: LD_INT 50
73987: PUSH
73988: LD_INT 75
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: LIST
73995: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73996: LD_VAR 0 6
74000: PPUSH
74001: CALL_OW 257
74005: PUSH
74006: LD_INT 15
74008: EQUAL
74009: IFFALSE 74030
// points := [ 10 , 5 , 3 ] ;
74011: LD_ADDR_VAR 0 9
74015: PUSH
74016: LD_INT 10
74018: PUSH
74019: LD_INT 5
74021: PUSH
74022: LD_INT 3
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: LIST
74029: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74030: LD_VAR 0 6
74034: PPUSH
74035: CALL_OW 257
74039: PUSH
74040: LD_INT 14
74042: EQUAL
74043: IFFALSE 74064
// points := [ 10 , 0 , 0 ] ;
74045: LD_ADDR_VAR 0 9
74049: PUSH
74050: LD_INT 10
74052: PUSH
74053: LD_INT 0
74055: PUSH
74056: LD_INT 0
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: LIST
74063: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74064: LD_VAR 0 6
74068: PPUSH
74069: CALL_OW 257
74073: PUSH
74074: LD_INT 11
74076: EQUAL
74077: IFFALSE 74098
// points := [ 30 , 10 , 5 ] ;
74079: LD_ADDR_VAR 0 9
74083: PUSH
74084: LD_INT 30
74086: PUSH
74087: LD_INT 10
74089: PUSH
74090: LD_INT 5
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: LIST
74097: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74098: LD_VAR 0 1
74102: PPUSH
74103: LD_INT 5
74105: PPUSH
74106: CALL_OW 321
74110: PUSH
74111: LD_INT 2
74113: EQUAL
74114: IFFALSE 74131
// bpoints := bpoints * 1.8 ;
74116: LD_ADDR_VAR 0 10
74120: PUSH
74121: LD_VAR 0 10
74125: PUSH
74126: LD_REAL  1.80000000000000E+0000
74129: MUL
74130: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
74131: LD_VAR 0 6
74135: PPUSH
74136: CALL_OW 257
74140: PUSH
74141: LD_INT 1
74143: PUSH
74144: LD_INT 2
74146: PUSH
74147: LD_INT 3
74149: PUSH
74150: LD_INT 4
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: LIST
74157: LIST
74158: IN
74159: PUSH
74160: LD_VAR 0 1
74164: PPUSH
74165: LD_INT 51
74167: PPUSH
74168: CALL_OW 321
74172: PUSH
74173: LD_INT 2
74175: EQUAL
74176: AND
74177: IFFALSE 74194
// bpoints := bpoints * 1.2 ;
74179: LD_ADDR_VAR 0 10
74183: PUSH
74184: LD_VAR 0 10
74188: PUSH
74189: LD_REAL  1.20000000000000E+0000
74192: MUL
74193: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74194: LD_VAR 0 6
74198: PPUSH
74199: CALL_OW 257
74203: PUSH
74204: LD_INT 5
74206: PUSH
74207: LD_INT 7
74209: PUSH
74210: LD_INT 9
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: LIST
74217: IN
74218: PUSH
74219: LD_VAR 0 1
74223: PPUSH
74224: LD_INT 52
74226: PPUSH
74227: CALL_OW 321
74231: PUSH
74232: LD_INT 2
74234: EQUAL
74235: AND
74236: IFFALSE 74253
// bpoints := bpoints * 1.5 ;
74238: LD_ADDR_VAR 0 10
74242: PUSH
74243: LD_VAR 0 10
74247: PUSH
74248: LD_REAL  1.50000000000000E+0000
74251: MUL
74252: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74253: LD_VAR 0 1
74257: PPUSH
74258: LD_INT 66
74260: PPUSH
74261: CALL_OW 321
74265: PUSH
74266: LD_INT 2
74268: EQUAL
74269: IFFALSE 74286
// bpoints := bpoints * 1.1 ;
74271: LD_ADDR_VAR 0 10
74275: PUSH
74276: LD_VAR 0 10
74280: PUSH
74281: LD_REAL  1.10000000000000E+0000
74284: MUL
74285: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74286: LD_ADDR_VAR 0 10
74290: PUSH
74291: LD_VAR 0 10
74295: PUSH
74296: LD_VAR 0 6
74300: PPUSH
74301: LD_INT 1
74303: PPUSH
74304: CALL_OW 259
74308: PUSH
74309: LD_REAL  1.15000000000000E+0000
74312: MUL
74313: MUL
74314: ST_TO_ADDR
// end ; unit_vehicle :
74315: GO 75143
74317: LD_INT 2
74319: DOUBLE
74320: EQUAL
74321: IFTRUE 74325
74323: GO 75131
74325: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74326: LD_VAR 0 6
74330: PPUSH
74331: CALL_OW 264
74335: PUSH
74336: LD_INT 2
74338: PUSH
74339: LD_INT 42
74341: PUSH
74342: LD_INT 24
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: LIST
74349: IN
74350: IFFALSE 74371
// points := [ 25 , 5 , 3 ] ;
74352: LD_ADDR_VAR 0 9
74356: PUSH
74357: LD_INT 25
74359: PUSH
74360: LD_INT 5
74362: PUSH
74363: LD_INT 3
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: LIST
74370: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74371: LD_VAR 0 6
74375: PPUSH
74376: CALL_OW 264
74380: PUSH
74381: LD_INT 4
74383: PUSH
74384: LD_INT 43
74386: PUSH
74387: LD_INT 25
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: LIST
74394: IN
74395: IFFALSE 74416
// points := [ 40 , 15 , 5 ] ;
74397: LD_ADDR_VAR 0 9
74401: PUSH
74402: LD_INT 40
74404: PUSH
74405: LD_INT 15
74407: PUSH
74408: LD_INT 5
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: LIST
74415: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74416: LD_VAR 0 6
74420: PPUSH
74421: CALL_OW 264
74425: PUSH
74426: LD_INT 3
74428: PUSH
74429: LD_INT 23
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: IN
74436: IFFALSE 74457
// points := [ 7 , 25 , 8 ] ;
74438: LD_ADDR_VAR 0 9
74442: PUSH
74443: LD_INT 7
74445: PUSH
74446: LD_INT 25
74448: PUSH
74449: LD_INT 8
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: LIST
74456: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74457: LD_VAR 0 6
74461: PPUSH
74462: CALL_OW 264
74466: PUSH
74467: LD_INT 5
74469: PUSH
74470: LD_INT 27
74472: PUSH
74473: LD_INT 44
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: LIST
74480: IN
74481: IFFALSE 74502
// points := [ 14 , 50 , 16 ] ;
74483: LD_ADDR_VAR 0 9
74487: PUSH
74488: LD_INT 14
74490: PUSH
74491: LD_INT 50
74493: PUSH
74494: LD_INT 16
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: LIST
74501: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74502: LD_VAR 0 6
74506: PPUSH
74507: CALL_OW 264
74511: PUSH
74512: LD_INT 6
74514: PUSH
74515: LD_INT 46
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: IN
74522: IFFALSE 74543
// points := [ 32 , 120 , 70 ] ;
74524: LD_ADDR_VAR 0 9
74528: PUSH
74529: LD_INT 32
74531: PUSH
74532: LD_INT 120
74534: PUSH
74535: LD_INT 70
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: LIST
74542: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74543: LD_VAR 0 6
74547: PPUSH
74548: CALL_OW 264
74552: PUSH
74553: LD_INT 7
74555: PUSH
74556: LD_INT 28
74558: PUSH
74559: LD_INT 45
74561: PUSH
74562: LD_INT 92
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: IN
74571: IFFALSE 74592
// points := [ 35 , 20 , 45 ] ;
74573: LD_ADDR_VAR 0 9
74577: PUSH
74578: LD_INT 35
74580: PUSH
74581: LD_INT 20
74583: PUSH
74584: LD_INT 45
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74592: LD_VAR 0 6
74596: PPUSH
74597: CALL_OW 264
74601: PUSH
74602: LD_INT 47
74604: PUSH
74605: EMPTY
74606: LIST
74607: IN
74608: IFFALSE 74629
// points := [ 67 , 45 , 75 ] ;
74610: LD_ADDR_VAR 0 9
74614: PUSH
74615: LD_INT 67
74617: PUSH
74618: LD_INT 45
74620: PUSH
74621: LD_INT 75
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74629: LD_VAR 0 6
74633: PPUSH
74634: CALL_OW 264
74638: PUSH
74639: LD_INT 26
74641: PUSH
74642: EMPTY
74643: LIST
74644: IN
74645: IFFALSE 74666
// points := [ 120 , 30 , 80 ] ;
74647: LD_ADDR_VAR 0 9
74651: PUSH
74652: LD_INT 120
74654: PUSH
74655: LD_INT 30
74657: PUSH
74658: LD_INT 80
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: LIST
74665: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74666: LD_VAR 0 6
74670: PPUSH
74671: CALL_OW 264
74675: PUSH
74676: LD_INT 22
74678: PUSH
74679: EMPTY
74680: LIST
74681: IN
74682: IFFALSE 74703
// points := [ 40 , 1 , 1 ] ;
74684: LD_ADDR_VAR 0 9
74688: PUSH
74689: LD_INT 40
74691: PUSH
74692: LD_INT 1
74694: PUSH
74695: LD_INT 1
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: LIST
74702: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74703: LD_VAR 0 6
74707: PPUSH
74708: CALL_OW 264
74712: PUSH
74713: LD_INT 29
74715: PUSH
74716: EMPTY
74717: LIST
74718: IN
74719: IFFALSE 74740
// points := [ 70 , 200 , 400 ] ;
74721: LD_ADDR_VAR 0 9
74725: PUSH
74726: LD_INT 70
74728: PUSH
74729: LD_INT 200
74731: PUSH
74732: LD_INT 400
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: LIST
74739: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74740: LD_VAR 0 6
74744: PPUSH
74745: CALL_OW 264
74749: PUSH
74750: LD_INT 14
74752: PUSH
74753: LD_INT 53
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: IN
74760: IFFALSE 74781
// points := [ 40 , 10 , 20 ] ;
74762: LD_ADDR_VAR 0 9
74766: PUSH
74767: LD_INT 40
74769: PUSH
74770: LD_INT 10
74772: PUSH
74773: LD_INT 20
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: LIST
74780: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74781: LD_VAR 0 6
74785: PPUSH
74786: CALL_OW 264
74790: PUSH
74791: LD_INT 9
74793: PUSH
74794: EMPTY
74795: LIST
74796: IN
74797: IFFALSE 74818
// points := [ 5 , 70 , 20 ] ;
74799: LD_ADDR_VAR 0 9
74803: PUSH
74804: LD_INT 5
74806: PUSH
74807: LD_INT 70
74809: PUSH
74810: LD_INT 20
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: LIST
74817: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74818: LD_VAR 0 6
74822: PPUSH
74823: CALL_OW 264
74827: PUSH
74828: LD_INT 10
74830: PUSH
74831: EMPTY
74832: LIST
74833: IN
74834: IFFALSE 74855
// points := [ 35 , 110 , 70 ] ;
74836: LD_ADDR_VAR 0 9
74840: PUSH
74841: LD_INT 35
74843: PUSH
74844: LD_INT 110
74846: PUSH
74847: LD_INT 70
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: LIST
74854: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74855: LD_VAR 0 6
74859: PPUSH
74860: CALL_OW 265
74864: PUSH
74865: LD_INT 25
74867: EQUAL
74868: IFFALSE 74889
// points := [ 80 , 65 , 100 ] ;
74870: LD_ADDR_VAR 0 9
74874: PUSH
74875: LD_INT 80
74877: PUSH
74878: LD_INT 65
74880: PUSH
74881: LD_INT 100
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: LIST
74888: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74889: LD_VAR 0 6
74893: PPUSH
74894: CALL_OW 263
74898: PUSH
74899: LD_INT 1
74901: EQUAL
74902: IFFALSE 74937
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74904: LD_ADDR_VAR 0 10
74908: PUSH
74909: LD_VAR 0 10
74913: PUSH
74914: LD_VAR 0 6
74918: PPUSH
74919: CALL_OW 311
74923: PPUSH
74924: LD_INT 3
74926: PPUSH
74927: CALL_OW 259
74931: PUSH
74932: LD_INT 4
74934: MUL
74935: MUL
74936: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74937: LD_VAR 0 6
74941: PPUSH
74942: CALL_OW 263
74946: PUSH
74947: LD_INT 2
74949: EQUAL
74950: IFFALSE 75001
// begin j := IsControledBy ( i ) ;
74952: LD_ADDR_VAR 0 7
74956: PUSH
74957: LD_VAR 0 6
74961: PPUSH
74962: CALL_OW 312
74966: ST_TO_ADDR
// if j then
74967: LD_VAR 0 7
74971: IFFALSE 75001
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74973: LD_ADDR_VAR 0 10
74977: PUSH
74978: LD_VAR 0 10
74982: PUSH
74983: LD_VAR 0 7
74987: PPUSH
74988: LD_INT 3
74990: PPUSH
74991: CALL_OW 259
74995: PUSH
74996: LD_INT 3
74998: MUL
74999: MUL
75000: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75001: LD_VAR 0 6
75005: PPUSH
75006: CALL_OW 264
75010: PUSH
75011: LD_INT 5
75013: PUSH
75014: LD_INT 6
75016: PUSH
75017: LD_INT 46
75019: PUSH
75020: LD_INT 44
75022: PUSH
75023: LD_INT 47
75025: PUSH
75026: LD_INT 45
75028: PUSH
75029: LD_INT 28
75031: PUSH
75032: LD_INT 7
75034: PUSH
75035: LD_INT 27
75037: PUSH
75038: LD_INT 29
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: IN
75053: PUSH
75054: LD_VAR 0 1
75058: PPUSH
75059: LD_INT 52
75061: PPUSH
75062: CALL_OW 321
75066: PUSH
75067: LD_INT 2
75069: EQUAL
75070: AND
75071: IFFALSE 75088
// bpoints := bpoints * 1.2 ;
75073: LD_ADDR_VAR 0 10
75077: PUSH
75078: LD_VAR 0 10
75082: PUSH
75083: LD_REAL  1.20000000000000E+0000
75086: MUL
75087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75088: LD_VAR 0 6
75092: PPUSH
75093: CALL_OW 264
75097: PUSH
75098: LD_INT 6
75100: PUSH
75101: LD_INT 46
75103: PUSH
75104: LD_INT 47
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: LIST
75111: IN
75112: IFFALSE 75129
// bpoints := bpoints * 1.2 ;
75114: LD_ADDR_VAR 0 10
75118: PUSH
75119: LD_VAR 0 10
75123: PUSH
75124: LD_REAL  1.20000000000000E+0000
75127: MUL
75128: ST_TO_ADDR
// end ; unit_building :
75129: GO 75143
75131: LD_INT 3
75133: DOUBLE
75134: EQUAL
75135: IFTRUE 75139
75137: GO 75142
75139: POP
// ; end ;
75140: GO 75143
75142: POP
// for j = 1 to 3 do
75143: LD_ADDR_VAR 0 7
75147: PUSH
75148: DOUBLE
75149: LD_INT 1
75151: DEC
75152: ST_TO_ADDR
75153: LD_INT 3
75155: PUSH
75156: FOR_TO
75157: IFFALSE 75210
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
75159: LD_ADDR_VAR 0 5
75163: PUSH
75164: LD_VAR 0 5
75168: PPUSH
75169: LD_VAR 0 7
75173: PPUSH
75174: LD_VAR 0 5
75178: PUSH
75179: LD_VAR 0 7
75183: ARRAY
75184: PUSH
75185: LD_VAR 0 9
75189: PUSH
75190: LD_VAR 0 7
75194: ARRAY
75195: PUSH
75196: LD_VAR 0 10
75200: MUL
75201: PLUS
75202: PPUSH
75203: CALL_OW 1
75207: ST_TO_ADDR
75208: GO 75156
75210: POP
75211: POP
// end ;
75212: GO 73691
75214: POP
75215: POP
// result := Replace ( result , 4 , tmp ) ;
75216: LD_ADDR_VAR 0 5
75220: PUSH
75221: LD_VAR 0 5
75225: PPUSH
75226: LD_INT 4
75228: PPUSH
75229: LD_VAR 0 8
75233: PPUSH
75234: CALL_OW 1
75238: ST_TO_ADDR
// end ;
75239: LD_VAR 0 5
75243: RET
// export function DangerAtRange ( unit , range ) ; begin
75244: LD_INT 0
75246: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75247: LD_ADDR_VAR 0 3
75251: PUSH
75252: LD_VAR 0 1
75256: PPUSH
75257: CALL_OW 255
75261: PPUSH
75262: LD_VAR 0 1
75266: PPUSH
75267: CALL_OW 250
75271: PPUSH
75272: LD_VAR 0 1
75276: PPUSH
75277: CALL_OW 251
75281: PPUSH
75282: LD_VAR 0 2
75286: PPUSH
75287: CALL 73543 0 4
75291: ST_TO_ADDR
// end ;
75292: LD_VAR 0 3
75296: RET
// export function DangerInArea ( side , area ) ; begin
75297: LD_INT 0
75299: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75300: LD_ADDR_VAR 0 3
75304: PUSH
75305: LD_VAR 0 2
75309: PPUSH
75310: LD_INT 81
75312: PUSH
75313: LD_VAR 0 1
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PPUSH
75322: CALL_OW 70
75326: ST_TO_ADDR
// end ;
75327: LD_VAR 0 3
75331: RET
// export function IsExtension ( b ) ; begin
75332: LD_INT 0
75334: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75335: LD_ADDR_VAR 0 2
75339: PUSH
75340: LD_VAR 0 1
75344: PUSH
75345: LD_INT 23
75347: PUSH
75348: LD_INT 20
75350: PUSH
75351: LD_INT 22
75353: PUSH
75354: LD_INT 17
75356: PUSH
75357: LD_INT 24
75359: PUSH
75360: LD_INT 21
75362: PUSH
75363: LD_INT 19
75365: PUSH
75366: LD_INT 16
75368: PUSH
75369: LD_INT 25
75371: PUSH
75372: LD_INT 18
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: IN
75387: ST_TO_ADDR
// end ;
75388: LD_VAR 0 2
75392: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75393: LD_INT 0
75395: PPUSH
75396: PPUSH
75397: PPUSH
// result := [ ] ;
75398: LD_ADDR_VAR 0 4
75402: PUSH
75403: EMPTY
75404: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75405: LD_ADDR_VAR 0 5
75409: PUSH
75410: LD_VAR 0 2
75414: PPUSH
75415: LD_INT 21
75417: PUSH
75418: LD_INT 3
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PPUSH
75425: CALL_OW 70
75429: ST_TO_ADDR
// if not tmp then
75430: LD_VAR 0 5
75434: NOT
75435: IFFALSE 75439
// exit ;
75437: GO 75503
// if checkLink then
75439: LD_VAR 0 3
75443: IFFALSE 75493
// begin for i in tmp do
75445: LD_ADDR_VAR 0 6
75449: PUSH
75450: LD_VAR 0 5
75454: PUSH
75455: FOR_IN
75456: IFFALSE 75491
// if GetBase ( i ) <> base then
75458: LD_VAR 0 6
75462: PPUSH
75463: CALL_OW 274
75467: PUSH
75468: LD_VAR 0 1
75472: NONEQUAL
75473: IFFALSE 75489
// ComLinkToBase ( base , i ) ;
75475: LD_VAR 0 1
75479: PPUSH
75480: LD_VAR 0 6
75484: PPUSH
75485: CALL_OW 169
75489: GO 75455
75491: POP
75492: POP
// end ; result := tmp ;
75493: LD_ADDR_VAR 0 4
75497: PUSH
75498: LD_VAR 0 5
75502: ST_TO_ADDR
// end ;
75503: LD_VAR 0 4
75507: RET
// export function ComComplete ( units , b ) ; var i ; begin
75508: LD_INT 0
75510: PPUSH
75511: PPUSH
// if not units then
75512: LD_VAR 0 1
75516: NOT
75517: IFFALSE 75521
// exit ;
75519: GO 75611
// for i in units do
75521: LD_ADDR_VAR 0 4
75525: PUSH
75526: LD_VAR 0 1
75530: PUSH
75531: FOR_IN
75532: IFFALSE 75609
// if BuildingStatus ( b ) = bs_build then
75534: LD_VAR 0 2
75538: PPUSH
75539: CALL_OW 461
75543: PUSH
75544: LD_INT 1
75546: EQUAL
75547: IFFALSE 75607
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75549: LD_VAR 0 4
75553: PPUSH
75554: LD_STRING h
75556: PUSH
75557: LD_VAR 0 2
75561: PPUSH
75562: CALL_OW 250
75566: PUSH
75567: LD_VAR 0 2
75571: PPUSH
75572: CALL_OW 251
75576: PUSH
75577: LD_VAR 0 2
75581: PUSH
75582: LD_INT 0
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 0
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: PUSH
75600: EMPTY
75601: LIST
75602: PPUSH
75603: CALL_OW 446
75607: GO 75531
75609: POP
75610: POP
// end ;
75611: LD_VAR 0 3
75615: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75616: LD_INT 0
75618: PPUSH
75619: PPUSH
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75624: LD_VAR 0 1
75628: NOT
75629: PUSH
75630: LD_VAR 0 1
75634: PPUSH
75635: CALL_OW 263
75639: PUSH
75640: LD_INT 2
75642: NONEQUAL
75643: OR
75644: IFFALSE 75648
// exit ;
75646: GO 75964
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75648: LD_ADDR_VAR 0 6
75652: PUSH
75653: LD_INT 22
75655: PUSH
75656: LD_VAR 0 1
75660: PPUSH
75661: CALL_OW 255
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: PUSH
75673: LD_INT 30
75675: PUSH
75676: LD_INT 36
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 34
75685: PUSH
75686: LD_INT 31
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: LIST
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PPUSH
75702: CALL_OW 69
75706: ST_TO_ADDR
// if not tmp then
75707: LD_VAR 0 6
75711: NOT
75712: IFFALSE 75716
// exit ;
75714: GO 75964
// result := [ ] ;
75716: LD_ADDR_VAR 0 2
75720: PUSH
75721: EMPTY
75722: ST_TO_ADDR
// for i in tmp do
75723: LD_ADDR_VAR 0 3
75727: PUSH
75728: LD_VAR 0 6
75732: PUSH
75733: FOR_IN
75734: IFFALSE 75805
// begin t := UnitsInside ( i ) ;
75736: LD_ADDR_VAR 0 4
75740: PUSH
75741: LD_VAR 0 3
75745: PPUSH
75746: CALL_OW 313
75750: ST_TO_ADDR
// if t then
75751: LD_VAR 0 4
75755: IFFALSE 75803
// for j in t do
75757: LD_ADDR_VAR 0 7
75761: PUSH
75762: LD_VAR 0 4
75766: PUSH
75767: FOR_IN
75768: IFFALSE 75801
// result := Replace ( result , result + 1 , j ) ;
75770: LD_ADDR_VAR 0 2
75774: PUSH
75775: LD_VAR 0 2
75779: PPUSH
75780: LD_VAR 0 2
75784: PUSH
75785: LD_INT 1
75787: PLUS
75788: PPUSH
75789: LD_VAR 0 7
75793: PPUSH
75794: CALL_OW 1
75798: ST_TO_ADDR
75799: GO 75767
75801: POP
75802: POP
// end ;
75803: GO 75733
75805: POP
75806: POP
// if not result then
75807: LD_VAR 0 2
75811: NOT
75812: IFFALSE 75816
// exit ;
75814: GO 75964
// mech := result [ 1 ] ;
75816: LD_ADDR_VAR 0 5
75820: PUSH
75821: LD_VAR 0 2
75825: PUSH
75826: LD_INT 1
75828: ARRAY
75829: ST_TO_ADDR
// if result > 1 then
75830: LD_VAR 0 2
75834: PUSH
75835: LD_INT 1
75837: GREATER
75838: IFFALSE 75950
// begin for i = 2 to result do
75840: LD_ADDR_VAR 0 3
75844: PUSH
75845: DOUBLE
75846: LD_INT 2
75848: DEC
75849: ST_TO_ADDR
75850: LD_VAR 0 2
75854: PUSH
75855: FOR_TO
75856: IFFALSE 75948
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75858: LD_ADDR_VAR 0 4
75862: PUSH
75863: LD_VAR 0 2
75867: PUSH
75868: LD_VAR 0 3
75872: ARRAY
75873: PPUSH
75874: LD_INT 3
75876: PPUSH
75877: CALL_OW 259
75881: PUSH
75882: LD_VAR 0 2
75886: PUSH
75887: LD_VAR 0 3
75891: ARRAY
75892: PPUSH
75893: CALL_OW 432
75897: MINUS
75898: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75899: LD_VAR 0 4
75903: PUSH
75904: LD_VAR 0 5
75908: PPUSH
75909: LD_INT 3
75911: PPUSH
75912: CALL_OW 259
75916: PUSH
75917: LD_VAR 0 5
75921: PPUSH
75922: CALL_OW 432
75926: MINUS
75927: GREATEREQUAL
75928: IFFALSE 75946
// mech := result [ i ] ;
75930: LD_ADDR_VAR 0 5
75934: PUSH
75935: LD_VAR 0 2
75939: PUSH
75940: LD_VAR 0 3
75944: ARRAY
75945: ST_TO_ADDR
// end ;
75946: GO 75855
75948: POP
75949: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75950: LD_VAR 0 1
75954: PPUSH
75955: LD_VAR 0 5
75959: PPUSH
75960: CALL_OW 135
// end ;
75964: LD_VAR 0 2
75968: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75969: LD_INT 0
75971: PPUSH
75972: PPUSH
75973: PPUSH
75974: PPUSH
75975: PPUSH
75976: PPUSH
75977: PPUSH
75978: PPUSH
75979: PPUSH
75980: PPUSH
75981: PPUSH
75982: PPUSH
75983: PPUSH
// result := [ ] ;
75984: LD_ADDR_VAR 0 7
75988: PUSH
75989: EMPTY
75990: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75991: LD_VAR 0 1
75995: PPUSH
75996: CALL_OW 266
76000: PUSH
76001: LD_INT 0
76003: PUSH
76004: LD_INT 1
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: IN
76011: NOT
76012: IFFALSE 76016
// exit ;
76014: GO 77650
// if name then
76016: LD_VAR 0 3
76020: IFFALSE 76036
// SetBName ( base_dep , name ) ;
76022: LD_VAR 0 1
76026: PPUSH
76027: LD_VAR 0 3
76031: PPUSH
76032: CALL_OW 500
// base := GetBase ( base_dep ) ;
76036: LD_ADDR_VAR 0 15
76040: PUSH
76041: LD_VAR 0 1
76045: PPUSH
76046: CALL_OW 274
76050: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76051: LD_ADDR_VAR 0 16
76055: PUSH
76056: LD_VAR 0 1
76060: PPUSH
76061: CALL_OW 255
76065: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76066: LD_ADDR_VAR 0 17
76070: PUSH
76071: LD_VAR 0 1
76075: PPUSH
76076: CALL_OW 248
76080: ST_TO_ADDR
// if sources then
76081: LD_VAR 0 5
76085: IFFALSE 76132
// for i = 1 to 3 do
76087: LD_ADDR_VAR 0 8
76091: PUSH
76092: DOUBLE
76093: LD_INT 1
76095: DEC
76096: ST_TO_ADDR
76097: LD_INT 3
76099: PUSH
76100: FOR_TO
76101: IFFALSE 76130
// AddResourceType ( base , i , sources [ i ] ) ;
76103: LD_VAR 0 15
76107: PPUSH
76108: LD_VAR 0 8
76112: PPUSH
76113: LD_VAR 0 5
76117: PUSH
76118: LD_VAR 0 8
76122: ARRAY
76123: PPUSH
76124: CALL_OW 276
76128: GO 76100
76130: POP
76131: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
76132: LD_ADDR_VAR 0 18
76136: PUSH
76137: LD_VAR 0 15
76141: PPUSH
76142: LD_VAR 0 2
76146: PPUSH
76147: LD_INT 1
76149: PPUSH
76150: CALL 75393 0 3
76154: ST_TO_ADDR
// InitHc ;
76155: CALL_OW 19
// InitUc ;
76159: CALL_OW 18
// uc_side := side ;
76163: LD_ADDR_OWVAR 20
76167: PUSH
76168: LD_VAR 0 16
76172: ST_TO_ADDR
// uc_nation := nation ;
76173: LD_ADDR_OWVAR 21
76177: PUSH
76178: LD_VAR 0 17
76182: ST_TO_ADDR
// if buildings then
76183: LD_VAR 0 18
76187: IFFALSE 77509
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76189: LD_ADDR_VAR 0 19
76193: PUSH
76194: LD_VAR 0 18
76198: PPUSH
76199: LD_INT 2
76201: PUSH
76202: LD_INT 30
76204: PUSH
76205: LD_INT 29
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 30
76214: PUSH
76215: LD_INT 30
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: LIST
76226: PPUSH
76227: CALL_OW 72
76231: ST_TO_ADDR
// if tmp then
76232: LD_VAR 0 19
76236: IFFALSE 76284
// for i in tmp do
76238: LD_ADDR_VAR 0 8
76242: PUSH
76243: LD_VAR 0 19
76247: PUSH
76248: FOR_IN
76249: IFFALSE 76282
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76251: LD_VAR 0 8
76255: PPUSH
76256: CALL_OW 250
76260: PPUSH
76261: LD_VAR 0 8
76265: PPUSH
76266: CALL_OW 251
76270: PPUSH
76271: LD_VAR 0 16
76275: PPUSH
76276: CALL_OW 441
76280: GO 76248
76282: POP
76283: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76284: LD_VAR 0 18
76288: PPUSH
76289: LD_INT 2
76291: PUSH
76292: LD_INT 30
76294: PUSH
76295: LD_INT 32
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 30
76304: PUSH
76305: LD_INT 33
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: LIST
76316: PPUSH
76317: CALL_OW 72
76321: IFFALSE 76409
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76323: LD_ADDR_VAR 0 8
76327: PUSH
76328: LD_VAR 0 18
76332: PPUSH
76333: LD_INT 2
76335: PUSH
76336: LD_INT 30
76338: PUSH
76339: LD_INT 32
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 30
76348: PUSH
76349: LD_INT 33
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: LIST
76360: PPUSH
76361: CALL_OW 72
76365: PUSH
76366: FOR_IN
76367: IFFALSE 76407
// begin if not GetBWeapon ( i ) then
76369: LD_VAR 0 8
76373: PPUSH
76374: CALL_OW 269
76378: NOT
76379: IFFALSE 76405
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76381: LD_VAR 0 8
76385: PPUSH
76386: LD_VAR 0 8
76390: PPUSH
76391: LD_VAR 0 2
76395: PPUSH
76396: CALL 77655 0 2
76400: PPUSH
76401: CALL_OW 431
// end ;
76405: GO 76366
76407: POP
76408: POP
// end ; for i = 1 to personel do
76409: LD_ADDR_VAR 0 8
76413: PUSH
76414: DOUBLE
76415: LD_INT 1
76417: DEC
76418: ST_TO_ADDR
76419: LD_VAR 0 6
76423: PUSH
76424: FOR_TO
76425: IFFALSE 77489
// begin if i > 4 then
76427: LD_VAR 0 8
76431: PUSH
76432: LD_INT 4
76434: GREATER
76435: IFFALSE 76439
// break ;
76437: GO 77489
// case i of 1 :
76439: LD_VAR 0 8
76443: PUSH
76444: LD_INT 1
76446: DOUBLE
76447: EQUAL
76448: IFTRUE 76452
76450: GO 76532
76452: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76453: LD_ADDR_VAR 0 12
76457: PUSH
76458: LD_VAR 0 18
76462: PPUSH
76463: LD_INT 22
76465: PUSH
76466: LD_VAR 0 16
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 58
76477: PUSH
76478: EMPTY
76479: LIST
76480: PUSH
76481: LD_INT 2
76483: PUSH
76484: LD_INT 30
76486: PUSH
76487: LD_INT 32
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 30
76496: PUSH
76497: LD_INT 4
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 30
76506: PUSH
76507: LD_INT 5
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: LIST
76524: PPUSH
76525: CALL_OW 72
76529: ST_TO_ADDR
76530: GO 76754
76532: LD_INT 2
76534: DOUBLE
76535: EQUAL
76536: IFTRUE 76540
76538: GO 76602
76540: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76541: LD_ADDR_VAR 0 12
76545: PUSH
76546: LD_VAR 0 18
76550: PPUSH
76551: LD_INT 22
76553: PUSH
76554: LD_VAR 0 16
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 2
76565: PUSH
76566: LD_INT 30
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 30
76578: PUSH
76579: LD_INT 1
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: LIST
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PPUSH
76595: CALL_OW 72
76599: ST_TO_ADDR
76600: GO 76754
76602: LD_INT 3
76604: DOUBLE
76605: EQUAL
76606: IFTRUE 76610
76608: GO 76672
76610: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76611: LD_ADDR_VAR 0 12
76615: PUSH
76616: LD_VAR 0 18
76620: PPUSH
76621: LD_INT 22
76623: PUSH
76624: LD_VAR 0 16
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 2
76635: PUSH
76636: LD_INT 30
76638: PUSH
76639: LD_INT 2
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 30
76648: PUSH
76649: LD_INT 3
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: LIST
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PPUSH
76665: CALL_OW 72
76669: ST_TO_ADDR
76670: GO 76754
76672: LD_INT 4
76674: DOUBLE
76675: EQUAL
76676: IFTRUE 76680
76678: GO 76753
76680: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76681: LD_ADDR_VAR 0 12
76685: PUSH
76686: LD_VAR 0 18
76690: PPUSH
76691: LD_INT 22
76693: PUSH
76694: LD_VAR 0 16
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 2
76705: PUSH
76706: LD_INT 30
76708: PUSH
76709: LD_INT 6
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 30
76718: PUSH
76719: LD_INT 7
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 30
76728: PUSH
76729: LD_INT 8
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: LIST
76740: LIST
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PPUSH
76746: CALL_OW 72
76750: ST_TO_ADDR
76751: GO 76754
76753: POP
// if i = 1 then
76754: LD_VAR 0 8
76758: PUSH
76759: LD_INT 1
76761: EQUAL
76762: IFFALSE 76873
// begin tmp := [ ] ;
76764: LD_ADDR_VAR 0 19
76768: PUSH
76769: EMPTY
76770: ST_TO_ADDR
// for j in f do
76771: LD_ADDR_VAR 0 9
76775: PUSH
76776: LD_VAR 0 12
76780: PUSH
76781: FOR_IN
76782: IFFALSE 76855
// if GetBType ( j ) = b_bunker then
76784: LD_VAR 0 9
76788: PPUSH
76789: CALL_OW 266
76793: PUSH
76794: LD_INT 32
76796: EQUAL
76797: IFFALSE 76824
// tmp := Insert ( tmp , 1 , j ) else
76799: LD_ADDR_VAR 0 19
76803: PUSH
76804: LD_VAR 0 19
76808: PPUSH
76809: LD_INT 1
76811: PPUSH
76812: LD_VAR 0 9
76816: PPUSH
76817: CALL_OW 2
76821: ST_TO_ADDR
76822: GO 76853
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76824: LD_ADDR_VAR 0 19
76828: PUSH
76829: LD_VAR 0 19
76833: PPUSH
76834: LD_VAR 0 19
76838: PUSH
76839: LD_INT 1
76841: PLUS
76842: PPUSH
76843: LD_VAR 0 9
76847: PPUSH
76848: CALL_OW 2
76852: ST_TO_ADDR
76853: GO 76781
76855: POP
76856: POP
// if tmp then
76857: LD_VAR 0 19
76861: IFFALSE 76873
// f := tmp ;
76863: LD_ADDR_VAR 0 12
76867: PUSH
76868: LD_VAR 0 19
76872: ST_TO_ADDR
// end ; x := personel [ i ] ;
76873: LD_ADDR_VAR 0 13
76877: PUSH
76878: LD_VAR 0 6
76882: PUSH
76883: LD_VAR 0 8
76887: ARRAY
76888: ST_TO_ADDR
// if x = - 1 then
76889: LD_VAR 0 13
76893: PUSH
76894: LD_INT 1
76896: NEG
76897: EQUAL
76898: IFFALSE 77107
// begin for j in f do
76900: LD_ADDR_VAR 0 9
76904: PUSH
76905: LD_VAR 0 12
76909: PUSH
76910: FOR_IN
76911: IFFALSE 77103
// repeat InitHc ;
76913: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76917: LD_VAR 0 9
76921: PPUSH
76922: CALL_OW 266
76926: PUSH
76927: LD_INT 5
76929: EQUAL
76930: IFFALSE 77000
// begin if UnitsInside ( j ) < 3 then
76932: LD_VAR 0 9
76936: PPUSH
76937: CALL_OW 313
76941: PUSH
76942: LD_INT 3
76944: LESS
76945: IFFALSE 76981
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76947: LD_INT 0
76949: PPUSH
76950: LD_INT 5
76952: PUSH
76953: LD_INT 8
76955: PUSH
76956: LD_INT 9
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: LIST
76963: PUSH
76964: LD_VAR 0 17
76968: ARRAY
76969: PPUSH
76970: LD_VAR 0 4
76974: PPUSH
76975: CALL_OW 380
76979: GO 76998
// PrepareHuman ( false , i , skill ) ;
76981: LD_INT 0
76983: PPUSH
76984: LD_VAR 0 8
76988: PPUSH
76989: LD_VAR 0 4
76993: PPUSH
76994: CALL_OW 380
// end else
76998: GO 77017
// PrepareHuman ( false , i , skill ) ;
77000: LD_INT 0
77002: PPUSH
77003: LD_VAR 0 8
77007: PPUSH
77008: LD_VAR 0 4
77012: PPUSH
77013: CALL_OW 380
// un := CreateHuman ;
77017: LD_ADDR_VAR 0 14
77021: PUSH
77022: CALL_OW 44
77026: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77027: LD_ADDR_VAR 0 7
77031: PUSH
77032: LD_VAR 0 7
77036: PPUSH
77037: LD_INT 1
77039: PPUSH
77040: LD_VAR 0 14
77044: PPUSH
77045: CALL_OW 2
77049: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77050: LD_VAR 0 14
77054: PPUSH
77055: LD_VAR 0 9
77059: PPUSH
77060: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77064: LD_VAR 0 9
77068: PPUSH
77069: CALL_OW 313
77073: PUSH
77074: LD_INT 6
77076: EQUAL
77077: PUSH
77078: LD_VAR 0 9
77082: PPUSH
77083: CALL_OW 266
77087: PUSH
77088: LD_INT 32
77090: PUSH
77091: LD_INT 31
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: IN
77098: OR
77099: IFFALSE 76913
77101: GO 76910
77103: POP
77104: POP
// end else
77105: GO 77487
// for j = 1 to x do
77107: LD_ADDR_VAR 0 9
77111: PUSH
77112: DOUBLE
77113: LD_INT 1
77115: DEC
77116: ST_TO_ADDR
77117: LD_VAR 0 13
77121: PUSH
77122: FOR_TO
77123: IFFALSE 77485
// begin InitHc ;
77125: CALL_OW 19
// if not f then
77129: LD_VAR 0 12
77133: NOT
77134: IFFALSE 77223
// begin PrepareHuman ( false , i , skill ) ;
77136: LD_INT 0
77138: PPUSH
77139: LD_VAR 0 8
77143: PPUSH
77144: LD_VAR 0 4
77148: PPUSH
77149: CALL_OW 380
// un := CreateHuman ;
77153: LD_ADDR_VAR 0 14
77157: PUSH
77158: CALL_OW 44
77162: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77163: LD_ADDR_VAR 0 7
77167: PUSH
77168: LD_VAR 0 7
77172: PPUSH
77173: LD_INT 1
77175: PPUSH
77176: LD_VAR 0 14
77180: PPUSH
77181: CALL_OW 2
77185: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77186: LD_VAR 0 14
77190: PPUSH
77191: LD_VAR 0 1
77195: PPUSH
77196: CALL_OW 250
77200: PPUSH
77201: LD_VAR 0 1
77205: PPUSH
77206: CALL_OW 251
77210: PPUSH
77211: LD_INT 10
77213: PPUSH
77214: LD_INT 0
77216: PPUSH
77217: CALL_OW 50
// continue ;
77221: GO 77122
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77223: LD_VAR 0 12
77227: PUSH
77228: LD_INT 1
77230: ARRAY
77231: PPUSH
77232: CALL_OW 313
77236: PUSH
77237: LD_VAR 0 12
77241: PUSH
77242: LD_INT 1
77244: ARRAY
77245: PPUSH
77246: CALL_OW 266
77250: PUSH
77251: LD_INT 32
77253: PUSH
77254: LD_INT 31
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: IN
77261: AND
77262: PUSH
77263: LD_VAR 0 12
77267: PUSH
77268: LD_INT 1
77270: ARRAY
77271: PPUSH
77272: CALL_OW 313
77276: PUSH
77277: LD_INT 6
77279: EQUAL
77280: OR
77281: IFFALSE 77301
// f := Delete ( f , 1 ) ;
77283: LD_ADDR_VAR 0 12
77287: PUSH
77288: LD_VAR 0 12
77292: PPUSH
77293: LD_INT 1
77295: PPUSH
77296: CALL_OW 3
77300: ST_TO_ADDR
// if not f then
77301: LD_VAR 0 12
77305: NOT
77306: IFFALSE 77324
// begin x := x + 2 ;
77308: LD_ADDR_VAR 0 13
77312: PUSH
77313: LD_VAR 0 13
77317: PUSH
77318: LD_INT 2
77320: PLUS
77321: ST_TO_ADDR
// continue ;
77322: GO 77122
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77324: LD_VAR 0 12
77328: PUSH
77329: LD_INT 1
77331: ARRAY
77332: PPUSH
77333: CALL_OW 266
77337: PUSH
77338: LD_INT 5
77340: EQUAL
77341: IFFALSE 77415
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77343: LD_VAR 0 12
77347: PUSH
77348: LD_INT 1
77350: ARRAY
77351: PPUSH
77352: CALL_OW 313
77356: PUSH
77357: LD_INT 3
77359: LESS
77360: IFFALSE 77396
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77362: LD_INT 0
77364: PPUSH
77365: LD_INT 5
77367: PUSH
77368: LD_INT 8
77370: PUSH
77371: LD_INT 9
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: LIST
77378: PUSH
77379: LD_VAR 0 17
77383: ARRAY
77384: PPUSH
77385: LD_VAR 0 4
77389: PPUSH
77390: CALL_OW 380
77394: GO 77413
// PrepareHuman ( false , i , skill ) ;
77396: LD_INT 0
77398: PPUSH
77399: LD_VAR 0 8
77403: PPUSH
77404: LD_VAR 0 4
77408: PPUSH
77409: CALL_OW 380
// end else
77413: GO 77432
// PrepareHuman ( false , i , skill ) ;
77415: LD_INT 0
77417: PPUSH
77418: LD_VAR 0 8
77422: PPUSH
77423: LD_VAR 0 4
77427: PPUSH
77428: CALL_OW 380
// un := CreateHuman ;
77432: LD_ADDR_VAR 0 14
77436: PUSH
77437: CALL_OW 44
77441: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77442: LD_ADDR_VAR 0 7
77446: PUSH
77447: LD_VAR 0 7
77451: PPUSH
77452: LD_INT 1
77454: PPUSH
77455: LD_VAR 0 14
77459: PPUSH
77460: CALL_OW 2
77464: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77465: LD_VAR 0 14
77469: PPUSH
77470: LD_VAR 0 12
77474: PUSH
77475: LD_INT 1
77477: ARRAY
77478: PPUSH
77479: CALL_OW 52
// end ;
77483: GO 77122
77485: POP
77486: POP
// end ;
77487: GO 76424
77489: POP
77490: POP
// result := result ^ buildings ;
77491: LD_ADDR_VAR 0 7
77495: PUSH
77496: LD_VAR 0 7
77500: PUSH
77501: LD_VAR 0 18
77505: ADD
77506: ST_TO_ADDR
// end else
77507: GO 77650
// begin for i = 1 to personel do
77509: LD_ADDR_VAR 0 8
77513: PUSH
77514: DOUBLE
77515: LD_INT 1
77517: DEC
77518: ST_TO_ADDR
77519: LD_VAR 0 6
77523: PUSH
77524: FOR_TO
77525: IFFALSE 77648
// begin if i > 4 then
77527: LD_VAR 0 8
77531: PUSH
77532: LD_INT 4
77534: GREATER
77535: IFFALSE 77539
// break ;
77537: GO 77648
// x := personel [ i ] ;
77539: LD_ADDR_VAR 0 13
77543: PUSH
77544: LD_VAR 0 6
77548: PUSH
77549: LD_VAR 0 8
77553: ARRAY
77554: ST_TO_ADDR
// if x = - 1 then
77555: LD_VAR 0 13
77559: PUSH
77560: LD_INT 1
77562: NEG
77563: EQUAL
77564: IFFALSE 77568
// continue ;
77566: GO 77524
// PrepareHuman ( false , i , skill ) ;
77568: LD_INT 0
77570: PPUSH
77571: LD_VAR 0 8
77575: PPUSH
77576: LD_VAR 0 4
77580: PPUSH
77581: CALL_OW 380
// un := CreateHuman ;
77585: LD_ADDR_VAR 0 14
77589: PUSH
77590: CALL_OW 44
77594: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77595: LD_VAR 0 14
77599: PPUSH
77600: LD_VAR 0 1
77604: PPUSH
77605: CALL_OW 250
77609: PPUSH
77610: LD_VAR 0 1
77614: PPUSH
77615: CALL_OW 251
77619: PPUSH
77620: LD_INT 10
77622: PPUSH
77623: LD_INT 0
77625: PPUSH
77626: CALL_OW 50
// result := result ^ un ;
77630: LD_ADDR_VAR 0 7
77634: PUSH
77635: LD_VAR 0 7
77639: PUSH
77640: LD_VAR 0 14
77644: ADD
77645: ST_TO_ADDR
// end ;
77646: GO 77524
77648: POP
77649: POP
// end ; end ;
77650: LD_VAR 0 7
77654: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77655: LD_INT 0
77657: PPUSH
77658: PPUSH
77659: PPUSH
77660: PPUSH
77661: PPUSH
77662: PPUSH
77663: PPUSH
77664: PPUSH
77665: PPUSH
77666: PPUSH
77667: PPUSH
77668: PPUSH
77669: PPUSH
77670: PPUSH
77671: PPUSH
77672: PPUSH
// result := false ;
77673: LD_ADDR_VAR 0 3
77677: PUSH
77678: LD_INT 0
77680: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77681: LD_VAR 0 1
77685: NOT
77686: PUSH
77687: LD_VAR 0 1
77691: PPUSH
77692: CALL_OW 266
77696: PUSH
77697: LD_INT 32
77699: PUSH
77700: LD_INT 33
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: IN
77707: NOT
77708: OR
77709: IFFALSE 77713
// exit ;
77711: GO 78822
// nat := GetNation ( tower ) ;
77713: LD_ADDR_VAR 0 12
77717: PUSH
77718: LD_VAR 0 1
77722: PPUSH
77723: CALL_OW 248
77727: ST_TO_ADDR
// side := GetSide ( tower ) ;
77728: LD_ADDR_VAR 0 16
77732: PUSH
77733: LD_VAR 0 1
77737: PPUSH
77738: CALL_OW 255
77742: ST_TO_ADDR
// x := GetX ( tower ) ;
77743: LD_ADDR_VAR 0 10
77747: PUSH
77748: LD_VAR 0 1
77752: PPUSH
77753: CALL_OW 250
77757: ST_TO_ADDR
// y := GetY ( tower ) ;
77758: LD_ADDR_VAR 0 11
77762: PUSH
77763: LD_VAR 0 1
77767: PPUSH
77768: CALL_OW 251
77772: ST_TO_ADDR
// if not x or not y then
77773: LD_VAR 0 10
77777: NOT
77778: PUSH
77779: LD_VAR 0 11
77783: NOT
77784: OR
77785: IFFALSE 77789
// exit ;
77787: GO 78822
// weapon := 0 ;
77789: LD_ADDR_VAR 0 18
77793: PUSH
77794: LD_INT 0
77796: ST_TO_ADDR
// fac_list := [ ] ;
77797: LD_ADDR_VAR 0 17
77801: PUSH
77802: EMPTY
77803: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77804: LD_ADDR_VAR 0 6
77808: PUSH
77809: LD_VAR 0 1
77813: PPUSH
77814: CALL_OW 274
77818: PPUSH
77819: LD_VAR 0 2
77823: PPUSH
77824: LD_INT 0
77826: PPUSH
77827: CALL 75393 0 3
77831: PPUSH
77832: LD_INT 30
77834: PUSH
77835: LD_INT 3
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PPUSH
77842: CALL_OW 72
77846: ST_TO_ADDR
// if not factories then
77847: LD_VAR 0 6
77851: NOT
77852: IFFALSE 77856
// exit ;
77854: GO 78822
// for i in factories do
77856: LD_ADDR_VAR 0 8
77860: PUSH
77861: LD_VAR 0 6
77865: PUSH
77866: FOR_IN
77867: IFFALSE 77892
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77869: LD_ADDR_VAR 0 17
77873: PUSH
77874: LD_VAR 0 17
77878: PUSH
77879: LD_VAR 0 8
77883: PPUSH
77884: CALL_OW 478
77888: UNION
77889: ST_TO_ADDR
77890: GO 77866
77892: POP
77893: POP
// if not fac_list then
77894: LD_VAR 0 17
77898: NOT
77899: IFFALSE 77903
// exit ;
77901: GO 78822
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77903: LD_ADDR_VAR 0 5
77907: PUSH
77908: LD_INT 4
77910: PUSH
77911: LD_INT 5
77913: PUSH
77914: LD_INT 9
77916: PUSH
77917: LD_INT 10
77919: PUSH
77920: LD_INT 6
77922: PUSH
77923: LD_INT 7
77925: PUSH
77926: LD_INT 11
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 27
77940: PUSH
77941: LD_INT 28
77943: PUSH
77944: LD_INT 26
77946: PUSH
77947: LD_INT 30
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 43
77958: PUSH
77959: LD_INT 44
77961: PUSH
77962: LD_INT 46
77964: PUSH
77965: LD_INT 45
77967: PUSH
77968: LD_INT 47
77970: PUSH
77971: LD_INT 49
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: LIST
77986: PUSH
77987: LD_VAR 0 12
77991: ARRAY
77992: ST_TO_ADDR
// list := list isect fac_list ;
77993: LD_ADDR_VAR 0 5
77997: PUSH
77998: LD_VAR 0 5
78002: PUSH
78003: LD_VAR 0 17
78007: ISECT
78008: ST_TO_ADDR
// if not list then
78009: LD_VAR 0 5
78013: NOT
78014: IFFALSE 78018
// exit ;
78016: GO 78822
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78018: LD_VAR 0 12
78022: PUSH
78023: LD_INT 3
78025: EQUAL
78026: PUSH
78027: LD_INT 49
78029: PUSH
78030: LD_VAR 0 5
78034: IN
78035: AND
78036: PUSH
78037: LD_INT 31
78039: PPUSH
78040: LD_VAR 0 16
78044: PPUSH
78045: CALL_OW 321
78049: PUSH
78050: LD_INT 2
78052: EQUAL
78053: AND
78054: IFFALSE 78114
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78056: LD_INT 22
78058: PUSH
78059: LD_VAR 0 16
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 35
78070: PUSH
78071: LD_INT 49
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 91
78080: PUSH
78081: LD_VAR 0 1
78085: PUSH
78086: LD_INT 10
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: LIST
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: LIST
78098: PPUSH
78099: CALL_OW 69
78103: NOT
78104: IFFALSE 78114
// weapon := ru_time_lapser ;
78106: LD_ADDR_VAR 0 18
78110: PUSH
78111: LD_INT 49
78113: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78114: LD_VAR 0 12
78118: PUSH
78119: LD_INT 1
78121: PUSH
78122: LD_INT 2
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: IN
78129: PUSH
78130: LD_INT 11
78132: PUSH
78133: LD_VAR 0 5
78137: IN
78138: PUSH
78139: LD_INT 30
78141: PUSH
78142: LD_VAR 0 5
78146: IN
78147: OR
78148: AND
78149: PUSH
78150: LD_INT 6
78152: PPUSH
78153: LD_VAR 0 16
78157: PPUSH
78158: CALL_OW 321
78162: PUSH
78163: LD_INT 2
78165: EQUAL
78166: AND
78167: IFFALSE 78332
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
78169: LD_INT 22
78171: PUSH
78172: LD_VAR 0 16
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 2
78183: PUSH
78184: LD_INT 35
78186: PUSH
78187: LD_INT 11
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 35
78196: PUSH
78197: LD_INT 30
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: LIST
78208: PUSH
78209: LD_INT 91
78211: PUSH
78212: LD_VAR 0 1
78216: PUSH
78217: LD_INT 18
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: LIST
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: LIST
78229: PPUSH
78230: CALL_OW 69
78234: NOT
78235: PUSH
78236: LD_INT 22
78238: PUSH
78239: LD_VAR 0 16
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 2
78250: PUSH
78251: LD_INT 30
78253: PUSH
78254: LD_INT 32
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 30
78263: PUSH
78264: LD_INT 33
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 91
78278: PUSH
78279: LD_VAR 0 1
78283: PUSH
78284: LD_INT 12
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: LIST
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: LIST
78296: PUSH
78297: EMPTY
78298: LIST
78299: PPUSH
78300: CALL_OW 69
78304: PUSH
78305: LD_INT 2
78307: GREATER
78308: AND
78309: IFFALSE 78332
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78311: LD_ADDR_VAR 0 18
78315: PUSH
78316: LD_INT 11
78318: PUSH
78319: LD_INT 30
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_VAR 0 12
78330: ARRAY
78331: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78332: LD_VAR 0 18
78336: NOT
78337: PUSH
78338: LD_INT 40
78340: PPUSH
78341: LD_VAR 0 16
78345: PPUSH
78346: CALL_OW 321
78350: PUSH
78351: LD_INT 2
78353: EQUAL
78354: AND
78355: PUSH
78356: LD_INT 7
78358: PUSH
78359: LD_VAR 0 5
78363: IN
78364: PUSH
78365: LD_INT 28
78367: PUSH
78368: LD_VAR 0 5
78372: IN
78373: OR
78374: PUSH
78375: LD_INT 45
78377: PUSH
78378: LD_VAR 0 5
78382: IN
78383: OR
78384: AND
78385: IFFALSE 78639
// begin hex := GetHexInfo ( x , y ) ;
78387: LD_ADDR_VAR 0 4
78391: PUSH
78392: LD_VAR 0 10
78396: PPUSH
78397: LD_VAR 0 11
78401: PPUSH
78402: CALL_OW 546
78406: ST_TO_ADDR
// if hex [ 1 ] then
78407: LD_VAR 0 4
78411: PUSH
78412: LD_INT 1
78414: ARRAY
78415: IFFALSE 78419
// exit ;
78417: GO 78822
// height := hex [ 2 ] ;
78419: LD_ADDR_VAR 0 15
78423: PUSH
78424: LD_VAR 0 4
78428: PUSH
78429: LD_INT 2
78431: ARRAY
78432: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78433: LD_ADDR_VAR 0 14
78437: PUSH
78438: LD_INT 0
78440: PUSH
78441: LD_INT 2
78443: PUSH
78444: LD_INT 3
78446: PUSH
78447: LD_INT 5
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: ST_TO_ADDR
// for i in tmp do
78456: LD_ADDR_VAR 0 8
78460: PUSH
78461: LD_VAR 0 14
78465: PUSH
78466: FOR_IN
78467: IFFALSE 78637
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78469: LD_ADDR_VAR 0 9
78473: PUSH
78474: LD_VAR 0 10
78478: PPUSH
78479: LD_VAR 0 8
78483: PPUSH
78484: LD_INT 5
78486: PPUSH
78487: CALL_OW 272
78491: PUSH
78492: LD_VAR 0 11
78496: PPUSH
78497: LD_VAR 0 8
78501: PPUSH
78502: LD_INT 5
78504: PPUSH
78505: CALL_OW 273
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78514: LD_VAR 0 9
78518: PUSH
78519: LD_INT 1
78521: ARRAY
78522: PPUSH
78523: LD_VAR 0 9
78527: PUSH
78528: LD_INT 2
78530: ARRAY
78531: PPUSH
78532: CALL_OW 488
78536: IFFALSE 78635
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78538: LD_ADDR_VAR 0 4
78542: PUSH
78543: LD_VAR 0 9
78547: PUSH
78548: LD_INT 1
78550: ARRAY
78551: PPUSH
78552: LD_VAR 0 9
78556: PUSH
78557: LD_INT 2
78559: ARRAY
78560: PPUSH
78561: CALL_OW 546
78565: ST_TO_ADDR
// if hex [ 1 ] then
78566: LD_VAR 0 4
78570: PUSH
78571: LD_INT 1
78573: ARRAY
78574: IFFALSE 78578
// continue ;
78576: GO 78466
// h := hex [ 2 ] ;
78578: LD_ADDR_VAR 0 13
78582: PUSH
78583: LD_VAR 0 4
78587: PUSH
78588: LD_INT 2
78590: ARRAY
78591: ST_TO_ADDR
// if h + 7 < height then
78592: LD_VAR 0 13
78596: PUSH
78597: LD_INT 7
78599: PLUS
78600: PUSH
78601: LD_VAR 0 15
78605: LESS
78606: IFFALSE 78635
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78608: LD_ADDR_VAR 0 18
78612: PUSH
78613: LD_INT 7
78615: PUSH
78616: LD_INT 28
78618: PUSH
78619: LD_INT 45
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: LIST
78626: PUSH
78627: LD_VAR 0 12
78631: ARRAY
78632: ST_TO_ADDR
// break ;
78633: GO 78637
// end ; end ; end ;
78635: GO 78466
78637: POP
78638: POP
// end ; if not weapon then
78639: LD_VAR 0 18
78643: NOT
78644: IFFALSE 78704
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78646: LD_ADDR_VAR 0 5
78650: PUSH
78651: LD_VAR 0 5
78655: PUSH
78656: LD_INT 11
78658: PUSH
78659: LD_INT 30
78661: PUSH
78662: LD_INT 49
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: LIST
78669: DIFF
78670: ST_TO_ADDR
// if not list then
78671: LD_VAR 0 5
78675: NOT
78676: IFFALSE 78680
// exit ;
78678: GO 78822
// weapon := list [ rand ( 1 , list ) ] ;
78680: LD_ADDR_VAR 0 18
78684: PUSH
78685: LD_VAR 0 5
78689: PUSH
78690: LD_INT 1
78692: PPUSH
78693: LD_VAR 0 5
78697: PPUSH
78698: CALL_OW 12
78702: ARRAY
78703: ST_TO_ADDR
// end ; if weapon then
78704: LD_VAR 0 18
78708: IFFALSE 78822
// begin tmp := CostOfWeapon ( weapon ) ;
78710: LD_ADDR_VAR 0 14
78714: PUSH
78715: LD_VAR 0 18
78719: PPUSH
78720: CALL_OW 451
78724: ST_TO_ADDR
// j := GetBase ( tower ) ;
78725: LD_ADDR_VAR 0 9
78729: PUSH
78730: LD_VAR 0 1
78734: PPUSH
78735: CALL_OW 274
78739: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78740: LD_VAR 0 9
78744: PPUSH
78745: LD_INT 1
78747: PPUSH
78748: CALL_OW 275
78752: PUSH
78753: LD_VAR 0 14
78757: PUSH
78758: LD_INT 1
78760: ARRAY
78761: GREATEREQUAL
78762: PUSH
78763: LD_VAR 0 9
78767: PPUSH
78768: LD_INT 2
78770: PPUSH
78771: CALL_OW 275
78775: PUSH
78776: LD_VAR 0 14
78780: PUSH
78781: LD_INT 2
78783: ARRAY
78784: GREATEREQUAL
78785: AND
78786: PUSH
78787: LD_VAR 0 9
78791: PPUSH
78792: LD_INT 3
78794: PPUSH
78795: CALL_OW 275
78799: PUSH
78800: LD_VAR 0 14
78804: PUSH
78805: LD_INT 3
78807: ARRAY
78808: GREATEREQUAL
78809: AND
78810: IFFALSE 78822
// result := weapon ;
78812: LD_ADDR_VAR 0 3
78816: PUSH
78817: LD_VAR 0 18
78821: ST_TO_ADDR
// end ; end ;
78822: LD_VAR 0 3
78826: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78827: LD_INT 0
78829: PPUSH
78830: PPUSH
// result := true ;
78831: LD_ADDR_VAR 0 3
78835: PUSH
78836: LD_INT 1
78838: ST_TO_ADDR
// if array1 = array2 then
78839: LD_VAR 0 1
78843: PUSH
78844: LD_VAR 0 2
78848: EQUAL
78849: IFFALSE 78909
// begin for i = 1 to array1 do
78851: LD_ADDR_VAR 0 4
78855: PUSH
78856: DOUBLE
78857: LD_INT 1
78859: DEC
78860: ST_TO_ADDR
78861: LD_VAR 0 1
78865: PUSH
78866: FOR_TO
78867: IFFALSE 78905
// if array1 [ i ] <> array2 [ i ] then
78869: LD_VAR 0 1
78873: PUSH
78874: LD_VAR 0 4
78878: ARRAY
78879: PUSH
78880: LD_VAR 0 2
78884: PUSH
78885: LD_VAR 0 4
78889: ARRAY
78890: NONEQUAL
78891: IFFALSE 78903
// begin result := false ;
78893: LD_ADDR_VAR 0 3
78897: PUSH
78898: LD_INT 0
78900: ST_TO_ADDR
// break ;
78901: GO 78905
// end ;
78903: GO 78866
78905: POP
78906: POP
// end else
78907: GO 78917
// result := false ;
78909: LD_ADDR_VAR 0 3
78913: PUSH
78914: LD_INT 0
78916: ST_TO_ADDR
// end ;
78917: LD_VAR 0 3
78921: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78922: LD_INT 0
78924: PPUSH
78925: PPUSH
// if not array1 or not array2 then
78926: LD_VAR 0 1
78930: NOT
78931: PUSH
78932: LD_VAR 0 2
78936: NOT
78937: OR
78938: IFFALSE 78942
// exit ;
78940: GO 79006
// result := true ;
78942: LD_ADDR_VAR 0 3
78946: PUSH
78947: LD_INT 1
78949: ST_TO_ADDR
// for i = 1 to array1 do
78950: LD_ADDR_VAR 0 4
78954: PUSH
78955: DOUBLE
78956: LD_INT 1
78958: DEC
78959: ST_TO_ADDR
78960: LD_VAR 0 1
78964: PUSH
78965: FOR_TO
78966: IFFALSE 79004
// if array1 [ i ] <> array2 [ i ] then
78968: LD_VAR 0 1
78972: PUSH
78973: LD_VAR 0 4
78977: ARRAY
78978: PUSH
78979: LD_VAR 0 2
78983: PUSH
78984: LD_VAR 0 4
78988: ARRAY
78989: NONEQUAL
78990: IFFALSE 79002
// begin result := false ;
78992: LD_ADDR_VAR 0 3
78996: PUSH
78997: LD_INT 0
78999: ST_TO_ADDR
// break ;
79000: GO 79004
// end ;
79002: GO 78965
79004: POP
79005: POP
// end ;
79006: LD_VAR 0 3
79010: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79011: LD_INT 0
79013: PPUSH
79014: PPUSH
79015: PPUSH
// pom := GetBase ( fac ) ;
79016: LD_ADDR_VAR 0 5
79020: PUSH
79021: LD_VAR 0 1
79025: PPUSH
79026: CALL_OW 274
79030: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79031: LD_ADDR_VAR 0 4
79035: PUSH
79036: LD_VAR 0 2
79040: PUSH
79041: LD_INT 1
79043: ARRAY
79044: PPUSH
79045: LD_VAR 0 2
79049: PUSH
79050: LD_INT 2
79052: ARRAY
79053: PPUSH
79054: LD_VAR 0 2
79058: PUSH
79059: LD_INT 3
79061: ARRAY
79062: PPUSH
79063: LD_VAR 0 2
79067: PUSH
79068: LD_INT 4
79070: ARRAY
79071: PPUSH
79072: CALL_OW 449
79076: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79077: LD_ADDR_VAR 0 3
79081: PUSH
79082: LD_VAR 0 5
79086: PPUSH
79087: LD_INT 1
79089: PPUSH
79090: CALL_OW 275
79094: PUSH
79095: LD_VAR 0 4
79099: PUSH
79100: LD_INT 1
79102: ARRAY
79103: GREATEREQUAL
79104: PUSH
79105: LD_VAR 0 5
79109: PPUSH
79110: LD_INT 2
79112: PPUSH
79113: CALL_OW 275
79117: PUSH
79118: LD_VAR 0 4
79122: PUSH
79123: LD_INT 2
79125: ARRAY
79126: GREATEREQUAL
79127: AND
79128: PUSH
79129: LD_VAR 0 5
79133: PPUSH
79134: LD_INT 3
79136: PPUSH
79137: CALL_OW 275
79141: PUSH
79142: LD_VAR 0 4
79146: PUSH
79147: LD_INT 3
79149: ARRAY
79150: GREATEREQUAL
79151: AND
79152: ST_TO_ADDR
// end ;
79153: LD_VAR 0 3
79157: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
79158: LD_INT 0
79160: PPUSH
79161: PPUSH
79162: PPUSH
79163: PPUSH
// pom := GetBase ( building ) ;
79164: LD_ADDR_VAR 0 3
79168: PUSH
79169: LD_VAR 0 1
79173: PPUSH
79174: CALL_OW 274
79178: ST_TO_ADDR
// if not pom then
79179: LD_VAR 0 3
79183: NOT
79184: IFFALSE 79188
// exit ;
79186: GO 79358
// btype := GetBType ( building ) ;
79188: LD_ADDR_VAR 0 5
79192: PUSH
79193: LD_VAR 0 1
79197: PPUSH
79198: CALL_OW 266
79202: ST_TO_ADDR
// if btype = b_armoury then
79203: LD_VAR 0 5
79207: PUSH
79208: LD_INT 4
79210: EQUAL
79211: IFFALSE 79221
// btype := b_barracks ;
79213: LD_ADDR_VAR 0 5
79217: PUSH
79218: LD_INT 5
79220: ST_TO_ADDR
// if btype = b_depot then
79221: LD_VAR 0 5
79225: PUSH
79226: LD_INT 0
79228: EQUAL
79229: IFFALSE 79239
// btype := b_warehouse ;
79231: LD_ADDR_VAR 0 5
79235: PUSH
79236: LD_INT 1
79238: ST_TO_ADDR
// if btype = b_workshop then
79239: LD_VAR 0 5
79243: PUSH
79244: LD_INT 2
79246: EQUAL
79247: IFFALSE 79257
// btype := b_factory ;
79249: LD_ADDR_VAR 0 5
79253: PUSH
79254: LD_INT 3
79256: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79257: LD_ADDR_VAR 0 4
79261: PUSH
79262: LD_VAR 0 5
79266: PPUSH
79267: LD_VAR 0 1
79271: PPUSH
79272: CALL_OW 248
79276: PPUSH
79277: CALL_OW 450
79281: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79282: LD_ADDR_VAR 0 2
79286: PUSH
79287: LD_VAR 0 3
79291: PPUSH
79292: LD_INT 1
79294: PPUSH
79295: CALL_OW 275
79299: PUSH
79300: LD_VAR 0 4
79304: PUSH
79305: LD_INT 1
79307: ARRAY
79308: GREATEREQUAL
79309: PUSH
79310: LD_VAR 0 3
79314: PPUSH
79315: LD_INT 2
79317: PPUSH
79318: CALL_OW 275
79322: PUSH
79323: LD_VAR 0 4
79327: PUSH
79328: LD_INT 2
79330: ARRAY
79331: GREATEREQUAL
79332: AND
79333: PUSH
79334: LD_VAR 0 3
79338: PPUSH
79339: LD_INT 3
79341: PPUSH
79342: CALL_OW 275
79346: PUSH
79347: LD_VAR 0 4
79351: PUSH
79352: LD_INT 3
79354: ARRAY
79355: GREATEREQUAL
79356: AND
79357: ST_TO_ADDR
// end ;
79358: LD_VAR 0 2
79362: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79363: LD_INT 0
79365: PPUSH
79366: PPUSH
79367: PPUSH
// pom := GetBase ( building ) ;
79368: LD_ADDR_VAR 0 4
79372: PUSH
79373: LD_VAR 0 1
79377: PPUSH
79378: CALL_OW 274
79382: ST_TO_ADDR
// if not pom then
79383: LD_VAR 0 4
79387: NOT
79388: IFFALSE 79392
// exit ;
79390: GO 79493
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79392: LD_ADDR_VAR 0 5
79396: PUSH
79397: LD_VAR 0 2
79401: PPUSH
79402: LD_VAR 0 1
79406: PPUSH
79407: CALL_OW 248
79411: PPUSH
79412: CALL_OW 450
79416: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79417: LD_ADDR_VAR 0 3
79421: PUSH
79422: LD_VAR 0 4
79426: PPUSH
79427: LD_INT 1
79429: PPUSH
79430: CALL_OW 275
79434: PUSH
79435: LD_VAR 0 5
79439: PUSH
79440: LD_INT 1
79442: ARRAY
79443: GREATEREQUAL
79444: PUSH
79445: LD_VAR 0 4
79449: PPUSH
79450: LD_INT 2
79452: PPUSH
79453: CALL_OW 275
79457: PUSH
79458: LD_VAR 0 5
79462: PUSH
79463: LD_INT 2
79465: ARRAY
79466: GREATEREQUAL
79467: AND
79468: PUSH
79469: LD_VAR 0 4
79473: PPUSH
79474: LD_INT 3
79476: PPUSH
79477: CALL_OW 275
79481: PUSH
79482: LD_VAR 0 5
79486: PUSH
79487: LD_INT 3
79489: ARRAY
79490: GREATEREQUAL
79491: AND
79492: ST_TO_ADDR
// end ;
79493: LD_VAR 0 3
79497: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79498: LD_INT 0
79500: PPUSH
79501: PPUSH
79502: PPUSH
79503: PPUSH
79504: PPUSH
79505: PPUSH
79506: PPUSH
79507: PPUSH
79508: PPUSH
79509: PPUSH
79510: PPUSH
// result := false ;
79511: LD_ADDR_VAR 0 8
79515: PUSH
79516: LD_INT 0
79518: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79519: LD_VAR 0 5
79523: NOT
79524: PUSH
79525: LD_VAR 0 1
79529: NOT
79530: OR
79531: PUSH
79532: LD_VAR 0 2
79536: NOT
79537: OR
79538: PUSH
79539: LD_VAR 0 3
79543: NOT
79544: OR
79545: IFFALSE 79549
// exit ;
79547: GO 80363
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79549: LD_ADDR_VAR 0 14
79553: PUSH
79554: LD_VAR 0 1
79558: PPUSH
79559: LD_VAR 0 2
79563: PPUSH
79564: LD_VAR 0 3
79568: PPUSH
79569: LD_VAR 0 4
79573: PPUSH
79574: LD_VAR 0 5
79578: PUSH
79579: LD_INT 1
79581: ARRAY
79582: PPUSH
79583: CALL_OW 248
79587: PPUSH
79588: LD_INT 0
79590: PPUSH
79591: CALL 81596 0 6
79595: ST_TO_ADDR
// if not hexes then
79596: LD_VAR 0 14
79600: NOT
79601: IFFALSE 79605
// exit ;
79603: GO 80363
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79605: LD_ADDR_VAR 0 17
79609: PUSH
79610: LD_VAR 0 5
79614: PPUSH
79615: LD_INT 22
79617: PUSH
79618: LD_VAR 0 13
79622: PPUSH
79623: CALL_OW 255
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 2
79634: PUSH
79635: LD_INT 30
79637: PUSH
79638: LD_INT 0
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 30
79647: PUSH
79648: LD_INT 1
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: LIST
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PPUSH
79664: CALL_OW 72
79668: ST_TO_ADDR
// for i = 1 to hexes do
79669: LD_ADDR_VAR 0 9
79673: PUSH
79674: DOUBLE
79675: LD_INT 1
79677: DEC
79678: ST_TO_ADDR
79679: LD_VAR 0 14
79683: PUSH
79684: FOR_TO
79685: IFFALSE 80361
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79687: LD_ADDR_VAR 0 13
79691: PUSH
79692: LD_VAR 0 14
79696: PUSH
79697: LD_VAR 0 9
79701: ARRAY
79702: PUSH
79703: LD_INT 1
79705: ARRAY
79706: PPUSH
79707: LD_VAR 0 14
79711: PUSH
79712: LD_VAR 0 9
79716: ARRAY
79717: PUSH
79718: LD_INT 2
79720: ARRAY
79721: PPUSH
79722: CALL_OW 428
79726: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79727: LD_VAR 0 14
79731: PUSH
79732: LD_VAR 0 9
79736: ARRAY
79737: PUSH
79738: LD_INT 1
79740: ARRAY
79741: PPUSH
79742: LD_VAR 0 14
79746: PUSH
79747: LD_VAR 0 9
79751: ARRAY
79752: PUSH
79753: LD_INT 2
79755: ARRAY
79756: PPUSH
79757: CALL_OW 351
79761: PUSH
79762: LD_VAR 0 14
79766: PUSH
79767: LD_VAR 0 9
79771: ARRAY
79772: PUSH
79773: LD_INT 1
79775: ARRAY
79776: PPUSH
79777: LD_VAR 0 14
79781: PUSH
79782: LD_VAR 0 9
79786: ARRAY
79787: PUSH
79788: LD_INT 2
79790: ARRAY
79791: PPUSH
79792: CALL_OW 488
79796: NOT
79797: OR
79798: PUSH
79799: LD_VAR 0 13
79803: PPUSH
79804: CALL_OW 247
79808: PUSH
79809: LD_INT 3
79811: EQUAL
79812: OR
79813: IFFALSE 79819
// exit ;
79815: POP
79816: POP
79817: GO 80363
// if not tmp then
79819: LD_VAR 0 13
79823: NOT
79824: IFFALSE 79828
// continue ;
79826: GO 79684
// result := true ;
79828: LD_ADDR_VAR 0 8
79832: PUSH
79833: LD_INT 1
79835: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79836: LD_VAR 0 6
79840: PUSH
79841: LD_VAR 0 13
79845: PPUSH
79846: CALL_OW 247
79850: PUSH
79851: LD_INT 2
79853: EQUAL
79854: AND
79855: PUSH
79856: LD_VAR 0 13
79860: PPUSH
79861: CALL_OW 263
79865: PUSH
79866: LD_INT 1
79868: EQUAL
79869: AND
79870: IFFALSE 80034
// begin if IsDrivenBy ( tmp ) then
79872: LD_VAR 0 13
79876: PPUSH
79877: CALL_OW 311
79881: IFFALSE 79885
// continue ;
79883: GO 79684
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79885: LD_VAR 0 6
79889: PPUSH
79890: LD_INT 3
79892: PUSH
79893: LD_INT 60
79895: PUSH
79896: EMPTY
79897: LIST
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 3
79905: PUSH
79906: LD_INT 55
79908: PUSH
79909: EMPTY
79910: LIST
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PPUSH
79920: CALL_OW 72
79924: IFFALSE 80032
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79926: LD_ADDR_VAR 0 18
79930: PUSH
79931: LD_VAR 0 6
79935: PPUSH
79936: LD_INT 3
79938: PUSH
79939: LD_INT 60
79941: PUSH
79942: EMPTY
79943: LIST
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: PUSH
79952: LD_INT 55
79954: PUSH
79955: EMPTY
79956: LIST
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PPUSH
79966: CALL_OW 72
79970: PUSH
79971: LD_INT 1
79973: ARRAY
79974: ST_TO_ADDR
// if IsInUnit ( driver ) then
79975: LD_VAR 0 18
79979: PPUSH
79980: CALL_OW 310
79984: IFFALSE 79995
// ComExit ( driver ) ;
79986: LD_VAR 0 18
79990: PPUSH
79991: CALL 105357 0 1
// AddComEnterUnit ( driver , tmp ) ;
79995: LD_VAR 0 18
79999: PPUSH
80000: LD_VAR 0 13
80004: PPUSH
80005: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80009: LD_VAR 0 18
80013: PPUSH
80014: LD_VAR 0 7
80018: PPUSH
80019: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80023: LD_VAR 0 18
80027: PPUSH
80028: CALL_OW 181
// end ; continue ;
80032: GO 79684
// end ; if not cleaners or not tmp in cleaners then
80034: LD_VAR 0 6
80038: NOT
80039: PUSH
80040: LD_VAR 0 13
80044: PUSH
80045: LD_VAR 0 6
80049: IN
80050: NOT
80051: OR
80052: IFFALSE 80359
// begin if dep then
80054: LD_VAR 0 17
80058: IFFALSE 80194
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80060: LD_ADDR_VAR 0 16
80064: PUSH
80065: LD_VAR 0 17
80069: PUSH
80070: LD_INT 1
80072: ARRAY
80073: PPUSH
80074: CALL_OW 250
80078: PPUSH
80079: LD_VAR 0 17
80083: PUSH
80084: LD_INT 1
80086: ARRAY
80087: PPUSH
80088: CALL_OW 254
80092: PPUSH
80093: LD_INT 5
80095: PPUSH
80096: CALL_OW 272
80100: PUSH
80101: LD_VAR 0 17
80105: PUSH
80106: LD_INT 1
80108: ARRAY
80109: PPUSH
80110: CALL_OW 251
80114: PPUSH
80115: LD_VAR 0 17
80119: PUSH
80120: LD_INT 1
80122: ARRAY
80123: PPUSH
80124: CALL_OW 254
80128: PPUSH
80129: LD_INT 5
80131: PPUSH
80132: CALL_OW 273
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
80141: LD_VAR 0 16
80145: PUSH
80146: LD_INT 1
80148: ARRAY
80149: PPUSH
80150: LD_VAR 0 16
80154: PUSH
80155: LD_INT 2
80157: ARRAY
80158: PPUSH
80159: CALL_OW 488
80163: IFFALSE 80194
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
80165: LD_VAR 0 13
80169: PPUSH
80170: LD_VAR 0 16
80174: PUSH
80175: LD_INT 1
80177: ARRAY
80178: PPUSH
80179: LD_VAR 0 16
80183: PUSH
80184: LD_INT 2
80186: ARRAY
80187: PPUSH
80188: CALL_OW 111
// continue ;
80192: GO 79684
// end ; end ; r := GetDir ( tmp ) ;
80194: LD_ADDR_VAR 0 15
80198: PUSH
80199: LD_VAR 0 13
80203: PPUSH
80204: CALL_OW 254
80208: ST_TO_ADDR
// if r = 5 then
80209: LD_VAR 0 15
80213: PUSH
80214: LD_INT 5
80216: EQUAL
80217: IFFALSE 80227
// r := 0 ;
80219: LD_ADDR_VAR 0 15
80223: PUSH
80224: LD_INT 0
80226: ST_TO_ADDR
// for j = r to 5 do
80227: LD_ADDR_VAR 0 10
80231: PUSH
80232: DOUBLE
80233: LD_VAR 0 15
80237: DEC
80238: ST_TO_ADDR
80239: LD_INT 5
80241: PUSH
80242: FOR_TO
80243: IFFALSE 80357
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80245: LD_ADDR_VAR 0 11
80249: PUSH
80250: LD_VAR 0 13
80254: PPUSH
80255: CALL_OW 250
80259: PPUSH
80260: LD_VAR 0 10
80264: PPUSH
80265: LD_INT 2
80267: PPUSH
80268: CALL_OW 272
80272: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80273: LD_ADDR_VAR 0 12
80277: PUSH
80278: LD_VAR 0 13
80282: PPUSH
80283: CALL_OW 251
80287: PPUSH
80288: LD_VAR 0 10
80292: PPUSH
80293: LD_INT 2
80295: PPUSH
80296: CALL_OW 273
80300: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80301: LD_VAR 0 11
80305: PPUSH
80306: LD_VAR 0 12
80310: PPUSH
80311: CALL_OW 488
80315: PUSH
80316: LD_VAR 0 11
80320: PPUSH
80321: LD_VAR 0 12
80325: PPUSH
80326: CALL_OW 428
80330: NOT
80331: AND
80332: IFFALSE 80355
// begin ComMoveXY ( tmp , _x , _y ) ;
80334: LD_VAR 0 13
80338: PPUSH
80339: LD_VAR 0 11
80343: PPUSH
80344: LD_VAR 0 12
80348: PPUSH
80349: CALL_OW 111
// break ;
80353: GO 80357
// end ; end ;
80355: GO 80242
80357: POP
80358: POP
// end ; end ;
80359: GO 79684
80361: POP
80362: POP
// end ;
80363: LD_VAR 0 8
80367: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80368: LD_INT 0
80370: PPUSH
// result := true ;
80371: LD_ADDR_VAR 0 3
80375: PUSH
80376: LD_INT 1
80378: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80379: LD_VAR 0 2
80383: PUSH
80384: LD_INT 24
80386: DOUBLE
80387: EQUAL
80388: IFTRUE 80398
80390: LD_INT 33
80392: DOUBLE
80393: EQUAL
80394: IFTRUE 80398
80396: GO 80423
80398: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80399: LD_ADDR_VAR 0 3
80403: PUSH
80404: LD_INT 32
80406: PPUSH
80407: LD_VAR 0 1
80411: PPUSH
80412: CALL_OW 321
80416: PUSH
80417: LD_INT 2
80419: EQUAL
80420: ST_TO_ADDR
80421: GO 80739
80423: LD_INT 20
80425: DOUBLE
80426: EQUAL
80427: IFTRUE 80431
80429: GO 80456
80431: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80432: LD_ADDR_VAR 0 3
80436: PUSH
80437: LD_INT 6
80439: PPUSH
80440: LD_VAR 0 1
80444: PPUSH
80445: CALL_OW 321
80449: PUSH
80450: LD_INT 2
80452: EQUAL
80453: ST_TO_ADDR
80454: GO 80739
80456: LD_INT 22
80458: DOUBLE
80459: EQUAL
80460: IFTRUE 80470
80462: LD_INT 36
80464: DOUBLE
80465: EQUAL
80466: IFTRUE 80470
80468: GO 80495
80470: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80471: LD_ADDR_VAR 0 3
80475: PUSH
80476: LD_INT 15
80478: PPUSH
80479: LD_VAR 0 1
80483: PPUSH
80484: CALL_OW 321
80488: PUSH
80489: LD_INT 2
80491: EQUAL
80492: ST_TO_ADDR
80493: GO 80739
80495: LD_INT 30
80497: DOUBLE
80498: EQUAL
80499: IFTRUE 80503
80501: GO 80528
80503: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80504: LD_ADDR_VAR 0 3
80508: PUSH
80509: LD_INT 20
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: CALL_OW 321
80521: PUSH
80522: LD_INT 2
80524: EQUAL
80525: ST_TO_ADDR
80526: GO 80739
80528: LD_INT 28
80530: DOUBLE
80531: EQUAL
80532: IFTRUE 80542
80534: LD_INT 21
80536: DOUBLE
80537: EQUAL
80538: IFTRUE 80542
80540: GO 80567
80542: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80543: LD_ADDR_VAR 0 3
80547: PUSH
80548: LD_INT 21
80550: PPUSH
80551: LD_VAR 0 1
80555: PPUSH
80556: CALL_OW 321
80560: PUSH
80561: LD_INT 2
80563: EQUAL
80564: ST_TO_ADDR
80565: GO 80739
80567: LD_INT 16
80569: DOUBLE
80570: EQUAL
80571: IFTRUE 80575
80573: GO 80600
80575: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80576: LD_ADDR_VAR 0 3
80580: PUSH
80581: LD_INT 84
80583: PPUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL_OW 321
80593: PUSH
80594: LD_INT 2
80596: EQUAL
80597: ST_TO_ADDR
80598: GO 80739
80600: LD_INT 19
80602: DOUBLE
80603: EQUAL
80604: IFTRUE 80614
80606: LD_INT 23
80608: DOUBLE
80609: EQUAL
80610: IFTRUE 80614
80612: GO 80639
80614: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80615: LD_ADDR_VAR 0 3
80619: PUSH
80620: LD_INT 83
80622: PPUSH
80623: LD_VAR 0 1
80627: PPUSH
80628: CALL_OW 321
80632: PUSH
80633: LD_INT 2
80635: EQUAL
80636: ST_TO_ADDR
80637: GO 80739
80639: LD_INT 17
80641: DOUBLE
80642: EQUAL
80643: IFTRUE 80647
80645: GO 80672
80647: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80648: LD_ADDR_VAR 0 3
80652: PUSH
80653: LD_INT 39
80655: PPUSH
80656: LD_VAR 0 1
80660: PPUSH
80661: CALL_OW 321
80665: PUSH
80666: LD_INT 2
80668: EQUAL
80669: ST_TO_ADDR
80670: GO 80739
80672: LD_INT 18
80674: DOUBLE
80675: EQUAL
80676: IFTRUE 80680
80678: GO 80705
80680: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80681: LD_ADDR_VAR 0 3
80685: PUSH
80686: LD_INT 40
80688: PPUSH
80689: LD_VAR 0 1
80693: PPUSH
80694: CALL_OW 321
80698: PUSH
80699: LD_INT 2
80701: EQUAL
80702: ST_TO_ADDR
80703: GO 80739
80705: LD_INT 27
80707: DOUBLE
80708: EQUAL
80709: IFTRUE 80713
80711: GO 80738
80713: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80714: LD_ADDR_VAR 0 3
80718: PUSH
80719: LD_INT 35
80721: PPUSH
80722: LD_VAR 0 1
80726: PPUSH
80727: CALL_OW 321
80731: PUSH
80732: LD_INT 2
80734: EQUAL
80735: ST_TO_ADDR
80736: GO 80739
80738: POP
// end ;
80739: LD_VAR 0 3
80743: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80744: LD_INT 0
80746: PPUSH
80747: PPUSH
80748: PPUSH
80749: PPUSH
80750: PPUSH
80751: PPUSH
80752: PPUSH
80753: PPUSH
80754: PPUSH
80755: PPUSH
80756: PPUSH
// result := false ;
80757: LD_ADDR_VAR 0 6
80761: PUSH
80762: LD_INT 0
80764: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80765: LD_VAR 0 1
80769: NOT
80770: PUSH
80771: LD_VAR 0 1
80775: PPUSH
80776: CALL_OW 266
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: LD_INT 1
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: IN
80791: NOT
80792: OR
80793: PUSH
80794: LD_VAR 0 2
80798: NOT
80799: OR
80800: PUSH
80801: LD_VAR 0 5
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: LD_INT 2
80814: PUSH
80815: LD_INT 3
80817: PUSH
80818: LD_INT 4
80820: PUSH
80821: LD_INT 5
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: IN
80832: NOT
80833: OR
80834: PUSH
80835: LD_VAR 0 3
80839: PPUSH
80840: LD_VAR 0 4
80844: PPUSH
80845: CALL_OW 488
80849: NOT
80850: OR
80851: IFFALSE 80855
// exit ;
80853: GO 81591
// side := GetSide ( depot ) ;
80855: LD_ADDR_VAR 0 9
80859: PUSH
80860: LD_VAR 0 1
80864: PPUSH
80865: CALL_OW 255
80869: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80870: LD_VAR 0 9
80874: PPUSH
80875: LD_VAR 0 2
80879: PPUSH
80880: CALL 80368 0 2
80884: NOT
80885: IFFALSE 80889
// exit ;
80887: GO 81591
// pom := GetBase ( depot ) ;
80889: LD_ADDR_VAR 0 10
80893: PUSH
80894: LD_VAR 0 1
80898: PPUSH
80899: CALL_OW 274
80903: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80904: LD_ADDR_VAR 0 11
80908: PUSH
80909: LD_VAR 0 2
80913: PPUSH
80914: LD_VAR 0 1
80918: PPUSH
80919: CALL_OW 248
80923: PPUSH
80924: CALL_OW 450
80928: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80929: LD_VAR 0 10
80933: PPUSH
80934: LD_INT 1
80936: PPUSH
80937: CALL_OW 275
80941: PUSH
80942: LD_VAR 0 11
80946: PUSH
80947: LD_INT 1
80949: ARRAY
80950: GREATEREQUAL
80951: PUSH
80952: LD_VAR 0 10
80956: PPUSH
80957: LD_INT 2
80959: PPUSH
80960: CALL_OW 275
80964: PUSH
80965: LD_VAR 0 11
80969: PUSH
80970: LD_INT 2
80972: ARRAY
80973: GREATEREQUAL
80974: AND
80975: PUSH
80976: LD_VAR 0 10
80980: PPUSH
80981: LD_INT 3
80983: PPUSH
80984: CALL_OW 275
80988: PUSH
80989: LD_VAR 0 11
80993: PUSH
80994: LD_INT 3
80996: ARRAY
80997: GREATEREQUAL
80998: AND
80999: NOT
81000: IFFALSE 81004
// exit ;
81002: GO 81591
// if GetBType ( depot ) = b_depot then
81004: LD_VAR 0 1
81008: PPUSH
81009: CALL_OW 266
81013: PUSH
81014: LD_INT 0
81016: EQUAL
81017: IFFALSE 81029
// dist := 28 else
81019: LD_ADDR_VAR 0 14
81023: PUSH
81024: LD_INT 28
81026: ST_TO_ADDR
81027: GO 81037
// dist := 36 ;
81029: LD_ADDR_VAR 0 14
81033: PUSH
81034: LD_INT 36
81036: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81037: LD_VAR 0 1
81041: PPUSH
81042: LD_VAR 0 3
81046: PPUSH
81047: LD_VAR 0 4
81051: PPUSH
81052: CALL_OW 297
81056: PUSH
81057: LD_VAR 0 14
81061: GREATER
81062: IFFALSE 81066
// exit ;
81064: GO 81591
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81066: LD_ADDR_VAR 0 12
81070: PUSH
81071: LD_VAR 0 2
81075: PPUSH
81076: LD_VAR 0 3
81080: PPUSH
81081: LD_VAR 0 4
81085: PPUSH
81086: LD_VAR 0 5
81090: PPUSH
81091: LD_VAR 0 1
81095: PPUSH
81096: CALL_OW 248
81100: PPUSH
81101: LD_INT 0
81103: PPUSH
81104: CALL 81596 0 6
81108: ST_TO_ADDR
// if not hexes then
81109: LD_VAR 0 12
81113: NOT
81114: IFFALSE 81118
// exit ;
81116: GO 81591
// hex := GetHexInfo ( x , y ) ;
81118: LD_ADDR_VAR 0 15
81122: PUSH
81123: LD_VAR 0 3
81127: PPUSH
81128: LD_VAR 0 4
81132: PPUSH
81133: CALL_OW 546
81137: ST_TO_ADDR
// if hex [ 1 ] then
81138: LD_VAR 0 15
81142: PUSH
81143: LD_INT 1
81145: ARRAY
81146: IFFALSE 81150
// exit ;
81148: GO 81591
// height := hex [ 2 ] ;
81150: LD_ADDR_VAR 0 13
81154: PUSH
81155: LD_VAR 0 15
81159: PUSH
81160: LD_INT 2
81162: ARRAY
81163: ST_TO_ADDR
// for i = 1 to hexes do
81164: LD_ADDR_VAR 0 7
81168: PUSH
81169: DOUBLE
81170: LD_INT 1
81172: DEC
81173: ST_TO_ADDR
81174: LD_VAR 0 12
81178: PUSH
81179: FOR_TO
81180: IFFALSE 81510
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81182: LD_VAR 0 12
81186: PUSH
81187: LD_VAR 0 7
81191: ARRAY
81192: PUSH
81193: LD_INT 1
81195: ARRAY
81196: PPUSH
81197: LD_VAR 0 12
81201: PUSH
81202: LD_VAR 0 7
81206: ARRAY
81207: PUSH
81208: LD_INT 2
81210: ARRAY
81211: PPUSH
81212: CALL_OW 488
81216: NOT
81217: PUSH
81218: LD_VAR 0 12
81222: PUSH
81223: LD_VAR 0 7
81227: ARRAY
81228: PUSH
81229: LD_INT 1
81231: ARRAY
81232: PPUSH
81233: LD_VAR 0 12
81237: PUSH
81238: LD_VAR 0 7
81242: ARRAY
81243: PUSH
81244: LD_INT 2
81246: ARRAY
81247: PPUSH
81248: CALL_OW 428
81252: PUSH
81253: LD_INT 0
81255: GREATER
81256: OR
81257: PUSH
81258: LD_VAR 0 12
81262: PUSH
81263: LD_VAR 0 7
81267: ARRAY
81268: PUSH
81269: LD_INT 1
81271: ARRAY
81272: PPUSH
81273: LD_VAR 0 12
81277: PUSH
81278: LD_VAR 0 7
81282: ARRAY
81283: PUSH
81284: LD_INT 2
81286: ARRAY
81287: PPUSH
81288: CALL_OW 351
81292: OR
81293: IFFALSE 81299
// exit ;
81295: POP
81296: POP
81297: GO 81591
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81299: LD_ADDR_VAR 0 8
81303: PUSH
81304: LD_VAR 0 12
81308: PUSH
81309: LD_VAR 0 7
81313: ARRAY
81314: PUSH
81315: LD_INT 1
81317: ARRAY
81318: PPUSH
81319: LD_VAR 0 12
81323: PUSH
81324: LD_VAR 0 7
81328: ARRAY
81329: PUSH
81330: LD_INT 2
81332: ARRAY
81333: PPUSH
81334: CALL_OW 546
81338: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81339: LD_VAR 0 8
81343: PUSH
81344: LD_INT 1
81346: ARRAY
81347: PUSH
81348: LD_VAR 0 8
81352: PUSH
81353: LD_INT 2
81355: ARRAY
81356: PUSH
81357: LD_VAR 0 13
81361: PUSH
81362: LD_INT 2
81364: PLUS
81365: GREATER
81366: OR
81367: PUSH
81368: LD_VAR 0 8
81372: PUSH
81373: LD_INT 2
81375: ARRAY
81376: PUSH
81377: LD_VAR 0 13
81381: PUSH
81382: LD_INT 2
81384: MINUS
81385: LESS
81386: OR
81387: PUSH
81388: LD_VAR 0 8
81392: PUSH
81393: LD_INT 3
81395: ARRAY
81396: PUSH
81397: LD_INT 0
81399: PUSH
81400: LD_INT 8
81402: PUSH
81403: LD_INT 9
81405: PUSH
81406: LD_INT 10
81408: PUSH
81409: LD_INT 11
81411: PUSH
81412: LD_INT 12
81414: PUSH
81415: LD_INT 13
81417: PUSH
81418: LD_INT 16
81420: PUSH
81421: LD_INT 17
81423: PUSH
81424: LD_INT 18
81426: PUSH
81427: LD_INT 19
81429: PUSH
81430: LD_INT 20
81432: PUSH
81433: LD_INT 21
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: IN
81451: NOT
81452: OR
81453: PUSH
81454: LD_VAR 0 8
81458: PUSH
81459: LD_INT 5
81461: ARRAY
81462: NOT
81463: OR
81464: PUSH
81465: LD_VAR 0 8
81469: PUSH
81470: LD_INT 6
81472: ARRAY
81473: PUSH
81474: LD_INT 1
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: LD_INT 7
81482: PUSH
81483: LD_INT 9
81485: PUSH
81486: LD_INT 10
81488: PUSH
81489: LD_INT 11
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: IN
81500: NOT
81501: OR
81502: IFFALSE 81508
// exit ;
81504: POP
81505: POP
81506: GO 81591
// end ;
81508: GO 81179
81510: POP
81511: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81512: LD_VAR 0 9
81516: PPUSH
81517: LD_VAR 0 3
81521: PPUSH
81522: LD_VAR 0 4
81526: PPUSH
81527: LD_INT 20
81529: PPUSH
81530: CALL 73543 0 4
81534: PUSH
81535: LD_INT 4
81537: ARRAY
81538: IFFALSE 81542
// exit ;
81540: GO 81591
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81542: LD_VAR 0 2
81546: PUSH
81547: LD_INT 29
81549: PUSH
81550: LD_INT 30
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: IN
81557: PUSH
81558: LD_VAR 0 3
81562: PPUSH
81563: LD_VAR 0 4
81567: PPUSH
81568: LD_VAR 0 9
81572: PPUSH
81573: CALL_OW 440
81577: NOT
81578: AND
81579: IFFALSE 81583
// exit ;
81581: GO 81591
// result := true ;
81583: LD_ADDR_VAR 0 6
81587: PUSH
81588: LD_INT 1
81590: ST_TO_ADDR
// end ;
81591: LD_VAR 0 6
81595: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81596: LD_INT 0
81598: PPUSH
81599: PPUSH
81600: PPUSH
81601: PPUSH
81602: PPUSH
81603: PPUSH
81604: PPUSH
81605: PPUSH
81606: PPUSH
81607: PPUSH
81608: PPUSH
81609: PPUSH
81610: PPUSH
81611: PPUSH
81612: PPUSH
81613: PPUSH
81614: PPUSH
81615: PPUSH
81616: PPUSH
81617: PPUSH
81618: PPUSH
81619: PPUSH
81620: PPUSH
81621: PPUSH
81622: PPUSH
81623: PPUSH
81624: PPUSH
81625: PPUSH
81626: PPUSH
81627: PPUSH
81628: PPUSH
81629: PPUSH
81630: PPUSH
81631: PPUSH
81632: PPUSH
81633: PPUSH
81634: PPUSH
81635: PPUSH
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
81645: PPUSH
81646: PPUSH
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
81651: PPUSH
81652: PPUSH
81653: PPUSH
81654: PPUSH
81655: PPUSH
// result = [ ] ;
81656: LD_ADDR_VAR 0 7
81660: PUSH
81661: EMPTY
81662: ST_TO_ADDR
// temp_list = [ ] ;
81663: LD_ADDR_VAR 0 9
81667: PUSH
81668: EMPTY
81669: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81670: LD_VAR 0 4
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: LD_INT 1
81680: PUSH
81681: LD_INT 2
81683: PUSH
81684: LD_INT 3
81686: PUSH
81687: LD_INT 4
81689: PUSH
81690: LD_INT 5
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: IN
81701: NOT
81702: PUSH
81703: LD_VAR 0 1
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 1
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: IN
81718: PUSH
81719: LD_VAR 0 5
81723: PUSH
81724: LD_INT 1
81726: PUSH
81727: LD_INT 2
81729: PUSH
81730: LD_INT 3
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: LIST
81737: IN
81738: NOT
81739: AND
81740: OR
81741: IFFALSE 81745
// exit ;
81743: GO 100136
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81745: LD_VAR 0 1
81749: PUSH
81750: LD_INT 6
81752: PUSH
81753: LD_INT 7
81755: PUSH
81756: LD_INT 8
81758: PUSH
81759: LD_INT 13
81761: PUSH
81762: LD_INT 12
81764: PUSH
81765: LD_INT 15
81767: PUSH
81768: LD_INT 11
81770: PUSH
81771: LD_INT 14
81773: PUSH
81774: LD_INT 10
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: IN
81788: IFFALSE 81798
// btype = b_lab ;
81790: LD_ADDR_VAR 0 1
81794: PUSH
81795: LD_INT 6
81797: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81798: LD_VAR 0 6
81802: PUSH
81803: LD_INT 0
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: LD_INT 2
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: LIST
81816: IN
81817: NOT
81818: PUSH
81819: LD_VAR 0 1
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: LD_INT 1
81829: PUSH
81830: LD_INT 2
81832: PUSH
81833: LD_INT 3
81835: PUSH
81836: LD_INT 6
81838: PUSH
81839: LD_INT 36
81841: PUSH
81842: LD_INT 4
81844: PUSH
81845: LD_INT 5
81847: PUSH
81848: LD_INT 31
81850: PUSH
81851: LD_INT 32
81853: PUSH
81854: LD_INT 33
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: IN
81870: NOT
81871: PUSH
81872: LD_VAR 0 6
81876: PUSH
81877: LD_INT 1
81879: EQUAL
81880: AND
81881: OR
81882: PUSH
81883: LD_VAR 0 1
81887: PUSH
81888: LD_INT 2
81890: PUSH
81891: LD_INT 3
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: IN
81898: NOT
81899: PUSH
81900: LD_VAR 0 6
81904: PUSH
81905: LD_INT 2
81907: EQUAL
81908: AND
81909: OR
81910: IFFALSE 81920
// mode = 0 ;
81912: LD_ADDR_VAR 0 6
81916: PUSH
81917: LD_INT 0
81919: ST_TO_ADDR
// case mode of 0 :
81920: LD_VAR 0 6
81924: PUSH
81925: LD_INT 0
81927: DOUBLE
81928: EQUAL
81929: IFTRUE 81933
81931: GO 93386
81933: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81934: LD_ADDR_VAR 0 11
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 0
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 0
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: LD_INT 0
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 1
81972: PUSH
81973: LD_INT 1
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 0
81982: PUSH
81983: LD_INT 1
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 1
81992: NEG
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 1
82003: NEG
82004: PUSH
82005: LD_INT 1
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 2
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: LD_INT 2
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: PUSH
82050: LD_INT 2
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 0
82059: PUSH
82060: LD_INT 2
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 1
82069: NEG
82070: PUSH
82071: LD_INT 1
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 1
82080: PUSH
82081: LD_INT 3
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 0
82090: PUSH
82091: LD_INT 3
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 1
82100: NEG
82101: PUSH
82102: LD_INT 2
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82127: LD_ADDR_VAR 0 12
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: LD_INT 0
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 0
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 1
82155: PUSH
82156: LD_INT 0
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 1
82165: PUSH
82166: LD_INT 1
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: LD_INT 1
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 1
82185: NEG
82186: PUSH
82187: LD_INT 0
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: LD_INT 1
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 1
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 2
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 2
82229: PUSH
82230: LD_INT 1
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 1
82239: NEG
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 2
82250: NEG
82251: PUSH
82252: LD_INT 0
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 2
82261: NEG
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 2
82273: NEG
82274: PUSH
82275: LD_INT 1
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 3
82284: NEG
82285: PUSH
82286: LD_INT 0
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 3
82295: NEG
82296: PUSH
82297: LD_INT 1
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82323: LD_ADDR_VAR 0 13
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 0
82340: PUSH
82341: LD_INT 1
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 1
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 1
82361: PUSH
82362: LD_INT 1
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 0
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 1
82381: NEG
82382: PUSH
82383: LD_INT 0
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 1
82392: NEG
82393: PUSH
82394: LD_INT 1
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 1
82404: NEG
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 2
82416: PUSH
82417: LD_INT 1
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 2
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 2
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 2
82446: NEG
82447: PUSH
82448: LD_INT 1
82450: NEG
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 2
82458: NEG
82459: PUSH
82460: LD_INT 2
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 2
82470: NEG
82471: PUSH
82472: LD_INT 3
82474: NEG
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 3
82482: NEG
82483: PUSH
82484: LD_INT 2
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 3
82494: NEG
82495: PUSH
82496: LD_INT 3
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82522: LD_ADDR_VAR 0 14
82526: PUSH
82527: LD_INT 0
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 0
82539: PUSH
82540: LD_INT 1
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 1
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: LD_INT 1
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 0
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: LD_INT 0
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 1
82591: NEG
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 1
82603: NEG
82604: PUSH
82605: LD_INT 2
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 0
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: LD_INT 1
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 1
82637: PUSH
82638: LD_INT 2
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 0
82647: PUSH
82648: LD_INT 2
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 1
82657: NEG
82658: PUSH
82659: LD_INT 1
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 1
82668: NEG
82669: PUSH
82670: LD_INT 3
82672: NEG
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 0
82680: PUSH
82681: LD_INT 3
82683: NEG
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 1
82691: PUSH
82692: LD_INT 2
82694: NEG
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82718: LD_ADDR_VAR 0 15
82722: PUSH
82723: LD_INT 0
82725: PUSH
82726: LD_INT 0
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 0
82735: PUSH
82736: LD_INT 1
82738: NEG
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 1
82746: PUSH
82747: LD_INT 0
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PUSH
82754: LD_INT 1
82756: PUSH
82757: LD_INT 1
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 0
82766: PUSH
82767: LD_INT 1
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: LD_INT 0
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: LD_INT 1
82791: NEG
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 1
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 2
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 2
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 1
82830: NEG
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 2
82841: NEG
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 2
82864: PUSH
82865: LD_INT 1
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 3
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 3
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82911: LD_ADDR_VAR 0 16
82915: PUSH
82916: LD_INT 0
82918: PUSH
82919: LD_INT 0
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: LD_INT 1
82931: NEG
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: LD_INT 0
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: LD_INT 1
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 0
82959: PUSH
82960: LD_INT 1
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 0
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: NEG
82981: PUSH
82982: LD_INT 1
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 1
82992: NEG
82993: PUSH
82994: LD_INT 2
82996: NEG
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 2
83004: PUSH
83005: LD_INT 1
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 2
83014: PUSH
83015: LD_INT 2
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: LD_INT 2
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 2
83034: NEG
83035: PUSH
83036: LD_INT 1
83038: NEG
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 2
83046: NEG
83047: PUSH
83048: LD_INT 2
83050: NEG
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 3
83058: PUSH
83059: LD_INT 2
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 3
83068: PUSH
83069: LD_INT 3
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: LD_INT 3
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83104: LD_ADDR_VAR 0 17
83108: PUSH
83109: LD_INT 0
83111: PUSH
83112: LD_INT 0
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: LD_INT 1
83124: NEG
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 1
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: PUSH
83143: LD_INT 1
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 0
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 1
83173: NEG
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: LD_INT 2
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 1
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 2
83219: PUSH
83220: LD_INT 0
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 2
83229: PUSH
83230: LD_INT 1
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: LD_INT 2
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 1
83249: PUSH
83250: LD_INT 2
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: LD_INT 2
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 1
83269: NEG
83270: PUSH
83271: LD_INT 1
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 2
83280: NEG
83281: PUSH
83282: LD_INT 0
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 2
83291: NEG
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 2
83303: NEG
83304: PUSH
83305: LD_INT 2
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83334: LD_ADDR_VAR 0 18
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: LD_INT 0
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 0
83351: PUSH
83352: LD_INT 1
83354: NEG
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 1
83362: PUSH
83363: LD_INT 0
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 1
83372: PUSH
83373: LD_INT 1
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 0
83382: PUSH
83383: LD_INT 1
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 1
83392: NEG
83393: PUSH
83394: LD_INT 0
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 1
83403: NEG
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 1
83415: NEG
83416: PUSH
83417: LD_INT 2
83419: NEG
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 0
83427: PUSH
83428: LD_INT 2
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: LD_INT 1
83441: NEG
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 2
83449: PUSH
83450: LD_INT 0
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 2
83459: PUSH
83460: LD_INT 1
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 2
83469: PUSH
83470: LD_INT 2
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 1
83479: PUSH
83480: LD_INT 2
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: LD_INT 2
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 1
83499: NEG
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 2
83510: NEG
83511: PUSH
83512: LD_INT 0
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 2
83521: NEG
83522: PUSH
83523: LD_INT 1
83525: NEG
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 2
83533: NEG
83534: PUSH
83535: LD_INT 2
83537: NEG
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83564: LD_ADDR_VAR 0 19
83568: PUSH
83569: LD_INT 0
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 1
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 0
83612: PUSH
83613: LD_INT 1
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 0
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: LD_INT 1
83637: NEG
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 1
83645: NEG
83646: PUSH
83647: LD_INT 2
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 0
83657: PUSH
83658: LD_INT 2
83660: NEG
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 1
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 0
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: LD_INT 1
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 2
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: LD_INT 2
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 0
83719: PUSH
83720: LD_INT 2
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 1
83729: NEG
83730: PUSH
83731: LD_INT 1
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 2
83740: NEG
83741: PUSH
83742: LD_INT 0
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 2
83751: NEG
83752: PUSH
83753: LD_INT 1
83755: NEG
83756: PUSH
83757: EMPTY
83758: LIST
83759: LIST
83760: PUSH
83761: LD_INT 2
83763: NEG
83764: PUSH
83765: LD_INT 2
83767: NEG
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83794: LD_ADDR_VAR 0 20
83798: PUSH
83799: LD_INT 0
83801: PUSH
83802: LD_INT 0
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 0
83811: PUSH
83812: LD_INT 1
83814: NEG
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 1
83822: PUSH
83823: LD_INT 0
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 1
83832: PUSH
83833: LD_INT 1
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: LD_INT 1
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 1
83852: NEG
83853: PUSH
83854: LD_INT 0
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 1
83863: NEG
83864: PUSH
83865: LD_INT 1
83867: NEG
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: NEG
83876: PUSH
83877: LD_INT 2
83879: NEG
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: LD_INT 2
83890: NEG
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 1
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 2
83909: PUSH
83910: LD_INT 0
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 2
83919: PUSH
83920: LD_INT 1
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 2
83929: PUSH
83930: LD_INT 2
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: LD_INT 1
83939: PUSH
83940: LD_INT 2
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: LD_INT 2
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 1
83959: NEG
83960: PUSH
83961: LD_INT 1
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 2
83970: NEG
83971: PUSH
83972: LD_INT 0
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 2
83981: NEG
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: LD_INT 2
83993: NEG
83994: PUSH
83995: LD_INT 2
83997: NEG
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84024: LD_ADDR_VAR 0 21
84028: PUSH
84029: LD_INT 0
84031: PUSH
84032: LD_INT 0
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: LD_INT 0
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: LD_INT 1
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: NEG
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 1
84105: NEG
84106: PUSH
84107: LD_INT 2
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 0
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 1
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 2
84139: PUSH
84140: LD_INT 0
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 2
84149: PUSH
84150: LD_INT 1
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 2
84159: PUSH
84160: LD_INT 2
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: LD_INT 2
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: PUSH
84191: LD_INT 1
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 2
84200: NEG
84201: PUSH
84202: LD_INT 0
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 2
84211: NEG
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 2
84223: NEG
84224: PUSH
84225: LD_INT 2
84227: NEG
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: LIST
84253: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84254: LD_ADDR_VAR 0 22
84258: PUSH
84259: LD_INT 0
84261: PUSH
84262: LD_INT 0
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 0
84271: PUSH
84272: LD_INT 1
84274: NEG
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: PUSH
84283: LD_INT 0
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: PUSH
84290: LD_INT 1
84292: PUSH
84293: LD_INT 1
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: LD_INT 1
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: LD_INT 0
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: NEG
84324: PUSH
84325: LD_INT 1
84327: NEG
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 1
84335: NEG
84336: PUSH
84337: LD_INT 2
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: LD_INT 2
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 1
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 2
84369: PUSH
84370: LD_INT 0
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 2
84379: PUSH
84380: LD_INT 1
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 2
84389: PUSH
84390: LD_INT 2
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 1
84399: PUSH
84400: LD_INT 2
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 0
84409: PUSH
84410: LD_INT 2
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 1
84419: NEG
84420: PUSH
84421: LD_INT 1
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 2
84430: NEG
84431: PUSH
84432: LD_INT 0
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: NEG
84442: PUSH
84443: LD_INT 1
84445: NEG
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 2
84453: NEG
84454: PUSH
84455: LD_INT 2
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84484: LD_ADDR_VAR 0 23
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: LD_INT 0
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 0
84501: PUSH
84502: LD_INT 1
84504: NEG
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 1
84512: PUSH
84513: LD_INT 0
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 1
84522: PUSH
84523: LD_INT 1
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 0
84532: PUSH
84533: LD_INT 1
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 1
84542: NEG
84543: PUSH
84544: LD_INT 0
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 1
84553: NEG
84554: PUSH
84555: LD_INT 1
84557: NEG
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: PUSH
84563: LD_INT 1
84565: NEG
84566: PUSH
84567: LD_INT 2
84569: NEG
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 0
84577: PUSH
84578: LD_INT 2
84580: NEG
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 1
84588: PUSH
84589: LD_INT 1
84591: NEG
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: LD_INT 2
84599: PUSH
84600: LD_INT 0
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 2
84609: PUSH
84610: LD_INT 1
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: LD_INT 2
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 1
84629: PUSH
84630: LD_INT 2
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: LD_INT 2
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: NEG
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 2
84660: NEG
84661: PUSH
84662: LD_INT 0
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 2
84671: NEG
84672: PUSH
84673: LD_INT 1
84675: NEG
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 2
84683: NEG
84684: PUSH
84685: LD_INT 2
84687: NEG
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 2
84695: NEG
84696: PUSH
84697: LD_INT 3
84699: NEG
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 1
84707: NEG
84708: PUSH
84709: LD_INT 3
84711: NEG
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: PUSH
84720: LD_INT 2
84722: NEG
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 2
84730: PUSH
84731: LD_INT 1
84733: NEG
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84764: LD_ADDR_VAR 0 24
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 0
84781: PUSH
84782: LD_INT 1
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: LD_INT 0
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 1
84802: PUSH
84803: LD_INT 1
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: LD_INT 1
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: NEG
84823: PUSH
84824: LD_INT 0
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 1
84833: NEG
84834: PUSH
84835: LD_INT 1
84837: NEG
84838: PUSH
84839: EMPTY
84840: LIST
84841: LIST
84842: PUSH
84843: LD_INT 1
84845: NEG
84846: PUSH
84847: LD_INT 2
84849: NEG
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 0
84857: PUSH
84858: LD_INT 2
84860: NEG
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 1
84868: PUSH
84869: LD_INT 1
84871: NEG
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 2
84879: PUSH
84880: LD_INT 0
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 2
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 2
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: LD_INT 2
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 0
84919: PUSH
84920: LD_INT 2
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: LD_INT 1
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 2
84940: NEG
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 2
84951: NEG
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 2
84963: NEG
84964: PUSH
84965: LD_INT 2
84967: NEG
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: LD_INT 2
84978: NEG
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 2
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 3
84997: PUSH
84998: LD_INT 1
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 3
85007: PUSH
85008: LD_INT 2
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85040: LD_ADDR_VAR 0 25
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: LD_INT 0
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PUSH
85055: LD_INT 0
85057: PUSH
85058: LD_INT 1
85060: NEG
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 1
85068: PUSH
85069: LD_INT 0
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: PUSH
85076: LD_INT 1
85078: PUSH
85079: LD_INT 1
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 0
85088: PUSH
85089: LD_INT 1
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 1
85098: NEG
85099: PUSH
85100: LD_INT 0
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: LD_INT 1
85113: NEG
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 1
85121: NEG
85122: PUSH
85123: LD_INT 2
85125: NEG
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 0
85133: PUSH
85134: LD_INT 2
85136: NEG
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 1
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 2
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 2
85165: PUSH
85166: LD_INT 1
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 2
85175: PUSH
85176: LD_INT 2
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: LD_INT 2
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: LD_INT 2
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: LD_INT 1
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 2
85216: NEG
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 2
85227: NEG
85228: PUSH
85229: LD_INT 1
85231: NEG
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 2
85239: NEG
85240: PUSH
85241: LD_INT 2
85243: NEG
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 3
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 3
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: LD_INT 3
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: LD_INT 3
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85314: LD_ADDR_VAR 0 26
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 0
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 0
85331: PUSH
85332: LD_INT 1
85334: NEG
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 1
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 0
85362: PUSH
85363: LD_INT 1
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 1
85372: NEG
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 1
85383: NEG
85384: PUSH
85385: LD_INT 1
85387: NEG
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 1
85395: NEG
85396: PUSH
85397: LD_INT 2
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 0
85407: PUSH
85408: LD_INT 2
85410: NEG
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 1
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 2
85429: PUSH
85430: LD_INT 0
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 2
85439: PUSH
85440: LD_INT 1
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 2
85449: PUSH
85450: LD_INT 2
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 1
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 0
85469: PUSH
85470: LD_INT 2
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 1
85479: NEG
85480: PUSH
85481: LD_INT 1
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 2
85501: NEG
85502: PUSH
85503: LD_INT 1
85505: NEG
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 2
85513: NEG
85514: PUSH
85515: LD_INT 2
85517: NEG
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 2
85525: PUSH
85526: LD_INT 3
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 1
85535: PUSH
85536: LD_INT 3
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: LD_INT 1
85545: NEG
85546: PUSH
85547: LD_INT 2
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 2
85556: NEG
85557: PUSH
85558: LD_INT 1
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85590: LD_ADDR_VAR 0 27
85594: PUSH
85595: LD_INT 0
85597: PUSH
85598: LD_INT 0
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 0
85607: PUSH
85608: LD_INT 1
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 1
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 0
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 1
85648: NEG
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: NEG
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 1
85671: NEG
85672: PUSH
85673: LD_INT 2
85675: NEG
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 0
85683: PUSH
85684: LD_INT 2
85686: NEG
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PUSH
85692: LD_INT 1
85694: PUSH
85695: LD_INT 1
85697: NEG
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 2
85705: PUSH
85706: LD_INT 0
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: LD_INT 2
85715: PUSH
85716: LD_INT 1
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 2
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: LD_INT 2
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: LD_INT 2
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 2
85766: NEG
85767: PUSH
85768: LD_INT 0
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: LD_INT 2
85777: NEG
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 2
85789: NEG
85790: PUSH
85791: LD_INT 2
85793: NEG
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: NEG
85802: PUSH
85803: LD_INT 2
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 2
85812: NEG
85813: PUSH
85814: LD_INT 1
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: LD_INT 3
85823: NEG
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 3
85835: NEG
85836: PUSH
85837: LD_INT 2
85839: NEG
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85870: LD_ADDR_VAR 0 28
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: LD_INT 0
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 0
85887: PUSH
85888: LD_INT 1
85890: NEG
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 1
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 1
85908: PUSH
85909: LD_INT 1
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: LD_INT 1
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: LD_INT 0
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: NEG
85940: PUSH
85941: LD_INT 1
85943: NEG
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 1
85951: NEG
85952: PUSH
85953: LD_INT 2
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 0
85963: PUSH
85964: LD_INT 2
85966: NEG
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 2
85985: PUSH
85986: LD_INT 0
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 2
85995: PUSH
85996: LD_INT 1
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 2
86005: PUSH
86006: LD_INT 2
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 1
86015: PUSH
86016: LD_INT 2
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: LD_INT 2
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: LD_INT 1
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 2
86046: NEG
86047: PUSH
86048: LD_INT 0
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 2
86057: NEG
86058: PUSH
86059: LD_INT 1
86061: NEG
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 2
86069: NEG
86070: PUSH
86071: LD_INT 2
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 2
86081: NEG
86082: PUSH
86083: LD_INT 3
86085: NEG
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_INT 1
86093: NEG
86094: PUSH
86095: LD_INT 3
86097: NEG
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 3
86105: NEG
86106: PUSH
86107: LD_INT 1
86109: NEG
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 3
86117: NEG
86118: PUSH
86119: LD_INT 2
86121: NEG
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86152: LD_ADDR_VAR 0 29
86156: PUSH
86157: LD_INT 0
86159: PUSH
86160: LD_INT 0
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: LD_INT 1
86172: NEG
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 1
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 0
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: NEG
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 1
86221: NEG
86222: PUSH
86223: LD_INT 1
86225: NEG
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 1
86233: NEG
86234: PUSH
86235: LD_INT 2
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: LD_INT 2
86248: NEG
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: LD_INT 1
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 2
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 2
86277: PUSH
86278: LD_INT 1
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: PUSH
86288: LD_INT 2
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 0
86297: PUSH
86298: LD_INT 2
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 1
86307: NEG
86308: PUSH
86309: LD_INT 1
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 2
86318: NEG
86319: PUSH
86320: LD_INT 1
86322: NEG
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 2
86330: NEG
86331: PUSH
86332: LD_INT 2
86334: NEG
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 2
86342: NEG
86343: PUSH
86344: LD_INT 3
86346: NEG
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 2
86354: PUSH
86355: LD_INT 1
86357: NEG
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 3
86365: PUSH
86366: LD_INT 1
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 1
86375: PUSH
86376: LD_INT 3
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 1
86385: NEG
86386: PUSH
86387: LD_INT 2
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 3
86396: NEG
86397: PUSH
86398: LD_INT 2
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86431: LD_ADDR_VAR 0 30
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: LD_INT 0
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: LD_INT 1
86451: NEG
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: LD_INT 0
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: LD_INT 1
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 0
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 0
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 1
86500: NEG
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: LD_INT 2
86516: NEG
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 0
86524: PUSH
86525: LD_INT 2
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: LD_INT 1
86538: NEG
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 2
86546: PUSH
86547: LD_INT 0
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 2
86556: PUSH
86557: LD_INT 1
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: LD_INT 2
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: LD_INT 2
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: NEG
86587: PUSH
86588: LD_INT 1
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 2
86597: NEG
86598: PUSH
86599: LD_INT 0
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 2
86608: NEG
86609: PUSH
86610: LD_INT 1
86612: NEG
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 1
86620: NEG
86621: PUSH
86622: LD_INT 3
86624: NEG
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: PUSH
86630: LD_INT 1
86632: PUSH
86633: LD_INT 2
86635: NEG
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: LD_INT 3
86643: PUSH
86644: LD_INT 2
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 2
86653: PUSH
86654: LD_INT 3
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: PUSH
86661: LD_INT 2
86663: NEG
86664: PUSH
86665: LD_INT 1
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 3
86674: NEG
86675: PUSH
86676: LD_INT 1
86678: NEG
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86709: LD_ADDR_VAR 0 31
86713: PUSH
86714: LD_INT 0
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: LD_INT 1
86729: NEG
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: PUSH
86738: LD_INT 0
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 1
86747: PUSH
86748: LD_INT 1
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: LD_INT 1
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: PUSH
86765: LD_INT 1
86767: NEG
86768: PUSH
86769: LD_INT 0
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 1
86778: NEG
86779: PUSH
86780: LD_INT 1
86782: NEG
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: PUSH
86788: LD_INT 1
86790: NEG
86791: PUSH
86792: LD_INT 2
86794: NEG
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 1
86802: PUSH
86803: LD_INT 1
86805: NEG
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 2
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 2
86833: PUSH
86834: LD_INT 2
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: LD_INT 2
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 0
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: LD_INT 1
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: LD_INT 2
86874: NEG
86875: PUSH
86876: LD_INT 1
86878: NEG
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 2
86886: NEG
86887: PUSH
86888: LD_INT 2
86890: NEG
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 2
86898: NEG
86899: PUSH
86900: LD_INT 3
86902: NEG
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 2
86910: PUSH
86911: LD_INT 1
86913: NEG
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 3
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: LD_INT 3
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 1
86941: NEG
86942: PUSH
86943: LD_INT 2
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 3
86952: NEG
86953: PUSH
86954: LD_INT 2
86956: NEG
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86987: LD_ADDR_VAR 0 32
86991: PUSH
86992: LD_INT 0
86994: PUSH
86995: LD_INT 0
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: LD_INT 1
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 1
87015: PUSH
87016: LD_INT 0
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 1
87025: PUSH
87026: LD_INT 1
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: LD_INT 1
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 1
87045: NEG
87046: PUSH
87047: LD_INT 0
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 1
87056: NEG
87057: PUSH
87058: LD_INT 1
87060: NEG
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 1
87068: NEG
87069: PUSH
87070: LD_INT 2
87072: NEG
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 0
87080: PUSH
87081: LD_INT 2
87083: NEG
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 1
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 2
87102: PUSH
87103: LD_INT 1
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 2
87112: PUSH
87113: LD_INT 2
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 1
87122: PUSH
87123: LD_INT 2
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 2
87153: NEG
87154: PUSH
87155: LD_INT 0
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: LD_INT 3
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 1
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 3
87199: PUSH
87200: LD_INT 2
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 2
87209: PUSH
87210: LD_INT 3
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: PUSH
87217: LD_INT 2
87219: NEG
87220: PUSH
87221: LD_INT 1
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: LD_INT 3
87230: NEG
87231: PUSH
87232: LD_INT 1
87234: NEG
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87265: LD_ADDR_VAR 0 33
87269: PUSH
87270: LD_INT 0
87272: PUSH
87273: LD_INT 0
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: LD_INT 1
87285: NEG
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 0
87313: PUSH
87314: LD_INT 1
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: LD_INT 0
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: NEG
87335: PUSH
87336: LD_INT 1
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 1
87346: NEG
87347: PUSH
87348: LD_INT 2
87350: NEG
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 1
87358: PUSH
87359: LD_INT 1
87361: NEG
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 2
87369: PUSH
87370: LD_INT 0
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 2
87379: PUSH
87380: LD_INT 1
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 1
87389: PUSH
87390: LD_INT 2
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 0
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 1
87409: NEG
87410: PUSH
87411: LD_INT 1
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: LD_INT 2
87420: NEG
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 2
87431: NEG
87432: PUSH
87433: LD_INT 1
87435: NEG
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 2
87443: NEG
87444: PUSH
87445: LD_INT 2
87447: NEG
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 2
87455: NEG
87456: PUSH
87457: LD_INT 3
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 2
87467: PUSH
87468: LD_INT 1
87470: NEG
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 3
87478: PUSH
87479: LD_INT 1
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 1
87488: PUSH
87489: LD_INT 3
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 1
87498: NEG
87499: PUSH
87500: LD_INT 2
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 3
87509: NEG
87510: PUSH
87511: LD_INT 2
87513: NEG
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87544: LD_ADDR_VAR 0 34
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: LD_INT 1
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 1
87602: NEG
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: LD_INT 1
87617: NEG
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: LD_INT 2
87629: NEG
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: LD_INT 2
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 1
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 2
87659: PUSH
87660: LD_INT 1
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: PUSH
87670: LD_INT 2
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 1
87679: PUSH
87680: LD_INT 2
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 1
87689: NEG
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 2
87700: NEG
87701: PUSH
87702: LD_INT 0
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 2
87711: NEG
87712: PUSH
87713: LD_INT 1
87715: NEG
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 2
87723: NEG
87724: PUSH
87725: LD_INT 2
87727: NEG
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: LD_INT 3
87739: NEG
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 1
87747: PUSH
87748: LD_INT 2
87750: NEG
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 3
87758: PUSH
87759: LD_INT 2
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: PUSH
87766: LD_INT 2
87768: PUSH
87769: LD_INT 3
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 2
87778: NEG
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 3
87789: NEG
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87824: LD_ADDR_VAR 0 35
87828: PUSH
87829: LD_INT 0
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: LD_INT 1
87844: NEG
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 1
87852: PUSH
87853: LD_INT 0
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: PUSH
87863: LD_INT 1
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PUSH
87870: LD_INT 0
87872: PUSH
87873: LD_INT 1
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: PUSH
87884: LD_INT 0
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: LD_INT 1
87897: NEG
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 2
87905: PUSH
87906: LD_INT 1
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 2
87915: NEG
87916: PUSH
87917: LD_INT 1
87919: NEG
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87936: LD_ADDR_VAR 0 36
87940: PUSH
87941: LD_INT 0
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 1
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 1
87974: PUSH
87975: LD_INT 1
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: LD_INT 1
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 1
87994: NEG
87995: PUSH
87996: LD_INT 0
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 1
88005: NEG
88006: PUSH
88007: LD_INT 1
88009: NEG
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 1
88017: NEG
88018: PUSH
88019: LD_INT 2
88021: NEG
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 1
88029: PUSH
88030: LD_INT 2
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88048: LD_ADDR_VAR 0 37
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: LD_INT 0
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: LD_INT 1
88068: NEG
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 1
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: LD_INT 1
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: LD_INT 1
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: LD_INT 0
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: LD_INT 1
88121: NEG
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 1
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 1
88140: NEG
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88160: LD_ADDR_VAR 0 38
88164: PUSH
88165: LD_INT 0
88167: PUSH
88168: LD_INT 0
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 0
88177: PUSH
88178: LD_INT 1
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 1
88229: NEG
88230: PUSH
88231: LD_INT 1
88233: NEG
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 1
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 2
88251: NEG
88252: PUSH
88253: LD_INT 1
88255: NEG
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88272: LD_ADDR_VAR 0 39
88276: PUSH
88277: LD_INT 0
88279: PUSH
88280: LD_INT 0
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 0
88289: PUSH
88290: LD_INT 1
88292: NEG
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 1
88300: PUSH
88301: LD_INT 0
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 1
88310: PUSH
88311: LD_INT 1
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 0
88320: PUSH
88321: LD_INT 1
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: LD_INT 0
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: NEG
88342: PUSH
88343: LD_INT 1
88345: NEG
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: NEG
88354: PUSH
88355: LD_INT 2
88357: NEG
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 1
88365: PUSH
88366: LD_INT 2
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88384: LD_ADDR_VAR 0 40
88388: PUSH
88389: LD_INT 0
88391: PUSH
88392: LD_INT 0
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 0
88401: PUSH
88402: LD_INT 1
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 1
88412: PUSH
88413: LD_INT 0
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: LD_INT 1
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: LD_INT 1
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 1
88442: NEG
88443: PUSH
88444: LD_INT 0
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: NEG
88454: PUSH
88455: LD_INT 1
88457: NEG
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: LD_INT 1
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88496: LD_ADDR_VAR 0 41
88500: PUSH
88501: LD_INT 0
88503: PUSH
88504: LD_INT 0
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 0
88513: PUSH
88514: LD_INT 1
88516: NEG
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: LD_INT 0
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: LD_INT 1
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 0
88544: PUSH
88545: LD_INT 1
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 1
88554: NEG
88555: PUSH
88556: LD_INT 0
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 1
88565: NEG
88566: PUSH
88567: LD_INT 1
88569: NEG
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: LD_INT 1
88577: NEG
88578: PUSH
88579: LD_INT 2
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: LD_INT 1
88592: NEG
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 2
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 2
88610: PUSH
88611: LD_INT 1
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 2
88620: PUSH
88621: LD_INT 2
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: PUSH
88631: LD_INT 2
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: NEG
88641: PUSH
88642: LD_INT 1
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 2
88651: NEG
88652: PUSH
88653: LD_INT 0
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 2
88662: NEG
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 2
88674: NEG
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 2
88686: NEG
88687: PUSH
88688: LD_INT 3
88690: NEG
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 2
88698: PUSH
88699: LD_INT 1
88701: NEG
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 3
88709: PUSH
88710: LD_INT 0
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 3
88719: PUSH
88720: LD_INT 1
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 3
88729: PUSH
88730: LD_INT 2
88732: PUSH
88733: EMPTY
88734: LIST
88735: LIST
88736: PUSH
88737: LD_INT 3
88739: PUSH
88740: LD_INT 3
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 2
88749: PUSH
88750: LD_INT 3
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 2
88759: NEG
88760: PUSH
88761: LD_INT 1
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 3
88770: NEG
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 3
88781: NEG
88782: PUSH
88783: LD_INT 1
88785: NEG
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 3
88793: NEG
88794: PUSH
88795: LD_INT 2
88797: NEG
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 3
88805: NEG
88806: PUSH
88807: LD_INT 3
88809: NEG
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88846: LD_ADDR_VAR 0 42
88850: PUSH
88851: LD_INT 0
88853: PUSH
88854: LD_INT 0
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 0
88863: PUSH
88864: LD_INT 1
88866: NEG
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 1
88874: PUSH
88875: LD_INT 0
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 1
88884: PUSH
88885: LD_INT 1
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 0
88894: PUSH
88895: LD_INT 1
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: LD_INT 1
88904: NEG
88905: PUSH
88906: LD_INT 0
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 1
88915: NEG
88916: PUSH
88917: LD_INT 1
88919: NEG
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 1
88927: NEG
88928: PUSH
88929: LD_INT 2
88931: NEG
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: LD_INT 0
88939: PUSH
88940: LD_INT 2
88942: NEG
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 1
88950: PUSH
88951: LD_INT 1
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 2
88961: PUSH
88962: LD_INT 1
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 2
88971: PUSH
88972: LD_INT 2
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: LD_INT 1
88981: PUSH
88982: LD_INT 2
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 0
88991: PUSH
88992: LD_INT 2
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: NEG
89002: PUSH
89003: LD_INT 1
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 2
89012: NEG
89013: PUSH
89014: LD_INT 1
89016: NEG
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 2
89024: NEG
89025: PUSH
89026: LD_INT 2
89028: NEG
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 2
89036: NEG
89037: PUSH
89038: LD_INT 3
89040: NEG
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: LD_INT 3
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: LD_INT 3
89063: NEG
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 2
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 3
89082: PUSH
89083: LD_INT 2
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 3
89092: PUSH
89093: LD_INT 3
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 2
89102: PUSH
89103: LD_INT 3
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: PUSH
89113: LD_INT 3
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 3
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: LD_INT 2
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 3
89143: NEG
89144: PUSH
89145: LD_INT 2
89147: NEG
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 3
89155: NEG
89156: PUSH
89157: LD_INT 3
89159: NEG
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89196: LD_ADDR_VAR 0 43
89200: PUSH
89201: LD_INT 0
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 0
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: PUSH
89225: LD_INT 0
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 1
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 0
89244: PUSH
89245: LD_INT 1
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 1
89254: NEG
89255: PUSH
89256: LD_INT 0
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 1
89265: NEG
89266: PUSH
89267: LD_INT 1
89269: NEG
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 1
89277: NEG
89278: PUSH
89279: LD_INT 2
89281: NEG
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 0
89289: PUSH
89290: LD_INT 2
89292: NEG
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 1
89300: PUSH
89301: LD_INT 1
89303: NEG
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 2
89311: PUSH
89312: LD_INT 0
89314: PUSH
89315: EMPTY
89316: LIST
89317: LIST
89318: PUSH
89319: LD_INT 2
89321: PUSH
89322: LD_INT 1
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 1
89331: PUSH
89332: LD_INT 2
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 0
89341: PUSH
89342: LD_INT 2
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 1
89351: NEG
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 2
89362: NEG
89363: PUSH
89364: LD_INT 0
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 3
89389: NEG
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 0
89397: PUSH
89398: LD_INT 3
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 1
89408: PUSH
89409: LD_INT 2
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 2
89419: PUSH
89420: LD_INT 1
89422: NEG
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 3
89430: PUSH
89431: LD_INT 0
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 3
89440: PUSH
89441: LD_INT 1
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 1
89450: PUSH
89451: LD_INT 3
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 0
89460: PUSH
89461: LD_INT 3
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 1
89470: NEG
89471: PUSH
89472: LD_INT 2
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 2
89481: NEG
89482: PUSH
89483: LD_INT 1
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 3
89492: NEG
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 3
89503: NEG
89504: PUSH
89505: LD_INT 1
89507: NEG
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: PUSH
89513: EMPTY
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89544: LD_ADDR_VAR 0 44
89548: PUSH
89549: LD_INT 0
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 0
89561: PUSH
89562: LD_INT 1
89564: NEG
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: PUSH
89573: LD_INT 0
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 1
89582: PUSH
89583: LD_INT 1
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 0
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 1
89602: NEG
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: NEG
89614: PUSH
89615: LD_INT 1
89617: NEG
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 2
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 2
89648: PUSH
89649: LD_INT 0
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 2
89668: PUSH
89669: LD_INT 2
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: LD_INT 2
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 1
89688: NEG
89689: PUSH
89690: LD_INT 1
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 2
89699: NEG
89700: PUSH
89701: LD_INT 0
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 2
89710: NEG
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 2
89722: NEG
89723: PUSH
89724: LD_INT 2
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 2
89734: NEG
89735: PUSH
89736: LD_INT 3
89738: NEG
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 2
89746: PUSH
89747: LD_INT 1
89749: NEG
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 3
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 3
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 3
89777: PUSH
89778: LD_INT 2
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 3
89787: PUSH
89788: LD_INT 3
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 2
89797: PUSH
89798: LD_INT 3
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 2
89807: NEG
89808: PUSH
89809: LD_INT 1
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 3
89818: NEG
89819: PUSH
89820: LD_INT 0
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 3
89829: NEG
89830: PUSH
89831: LD_INT 1
89833: NEG
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: PUSH
89839: LD_INT 3
89841: NEG
89842: PUSH
89843: LD_INT 2
89845: NEG
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 3
89853: NEG
89854: PUSH
89855: LD_INT 3
89857: NEG
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89894: LD_ADDR_VAR 0 45
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 0
89911: PUSH
89912: LD_INT 1
89914: NEG
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: PUSH
89920: LD_INT 1
89922: PUSH
89923: LD_INT 0
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 1
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: LD_INT 1
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 1
89952: NEG
89953: PUSH
89954: LD_INT 0
89956: PUSH
89957: EMPTY
89958: LIST
89959: LIST
89960: PUSH
89961: LD_INT 1
89963: NEG
89964: PUSH
89965: LD_INT 1
89967: NEG
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 1
89975: NEG
89976: PUSH
89977: LD_INT 2
89979: NEG
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: LD_INT 2
89990: NEG
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 1
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 2
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 2
90019: PUSH
90020: LD_INT 2
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 1
90029: PUSH
90030: LD_INT 2
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: LD_INT 0
90039: PUSH
90040: LD_INT 2
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 1
90049: NEG
90050: PUSH
90051: LD_INT 1
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 2
90060: NEG
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 2
90072: NEG
90073: PUSH
90074: LD_INT 2
90076: NEG
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 2
90084: NEG
90085: PUSH
90086: LD_INT 3
90088: NEG
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: PUSH
90098: LD_INT 3
90100: NEG
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: PUSH
90106: LD_INT 0
90108: PUSH
90109: LD_INT 3
90111: NEG
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 1
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 3
90130: PUSH
90131: LD_INT 2
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 3
90140: PUSH
90141: LD_INT 3
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 2
90150: PUSH
90151: LD_INT 3
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: PUSH
90161: LD_INT 3
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 0
90170: PUSH
90171: LD_INT 3
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 1
90180: NEG
90181: PUSH
90182: LD_INT 2
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 3
90191: NEG
90192: PUSH
90193: LD_INT 2
90195: NEG
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 3
90203: NEG
90204: PUSH
90205: LD_INT 3
90207: NEG
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90244: LD_ADDR_VAR 0 46
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: LD_INT 0
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 0
90261: PUSH
90262: LD_INT 1
90264: NEG
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 1
90272: PUSH
90273: LD_INT 0
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 1
90282: PUSH
90283: LD_INT 1
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 0
90292: PUSH
90293: LD_INT 1
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 1
90302: NEG
90303: PUSH
90304: LD_INT 0
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 1
90313: NEG
90314: PUSH
90315: LD_INT 1
90317: NEG
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 1
90325: NEG
90326: PUSH
90327: LD_INT 2
90329: NEG
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 0
90337: PUSH
90338: LD_INT 2
90340: NEG
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: PUSH
90346: LD_INT 1
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 2
90359: PUSH
90360: LD_INT 0
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: LD_INT 2
90369: PUSH
90370: LD_INT 1
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 1
90379: PUSH
90380: LD_INT 2
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 0
90389: PUSH
90390: LD_INT 2
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 1
90399: NEG
90400: PUSH
90401: LD_INT 1
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 2
90410: NEG
90411: PUSH
90412: LD_INT 0
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 2
90421: NEG
90422: PUSH
90423: LD_INT 1
90425: NEG
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 1
90433: NEG
90434: PUSH
90435: LD_INT 3
90437: NEG
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 0
90445: PUSH
90446: LD_INT 3
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: LD_INT 2
90459: NEG
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 2
90467: PUSH
90468: LD_INT 1
90470: NEG
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 3
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 3
90488: PUSH
90489: LD_INT 1
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PUSH
90496: LD_INT 1
90498: PUSH
90499: LD_INT 3
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 0
90508: PUSH
90509: LD_INT 3
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: LD_INT 2
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 2
90529: NEG
90530: PUSH
90531: LD_INT 1
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: LD_INT 3
90540: NEG
90541: PUSH
90542: LD_INT 0
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 3
90551: NEG
90552: PUSH
90553: LD_INT 1
90555: NEG
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90592: LD_ADDR_VAR 0 47
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: LD_INT 0
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 0
90609: PUSH
90610: LD_INT 1
90612: NEG
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 1
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 1
90630: PUSH
90631: LD_INT 1
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: LD_INT 1
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 1
90650: NEG
90651: PUSH
90652: LD_INT 0
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 1
90661: NEG
90662: PUSH
90663: LD_INT 1
90665: NEG
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 1
90673: NEG
90674: PUSH
90675: LD_INT 2
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 0
90685: PUSH
90686: LD_INT 2
90688: NEG
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 1
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 2
90707: NEG
90708: PUSH
90709: LD_INT 1
90711: NEG
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 2
90719: NEG
90720: PUSH
90721: LD_INT 2
90723: NEG
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90743: LD_ADDR_VAR 0 48
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: LD_INT 0
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 0
90760: PUSH
90761: LD_INT 1
90763: NEG
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: LD_INT 0
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 1
90781: PUSH
90782: LD_INT 1
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 0
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 1
90801: NEG
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: LD_INT 1
90812: NEG
90813: PUSH
90814: LD_INT 1
90816: NEG
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: LD_INT 2
90828: NEG
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: LD_INT 2
90839: NEG
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 1
90847: PUSH
90848: LD_INT 1
90850: NEG
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 2
90858: PUSH
90859: LD_INT 0
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 2
90868: PUSH
90869: LD_INT 1
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90890: LD_ADDR_VAR 0 49
90894: PUSH
90895: LD_INT 0
90897: PUSH
90898: LD_INT 0
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 0
90907: PUSH
90908: LD_INT 1
90910: NEG
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 1
90918: PUSH
90919: LD_INT 0
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: LD_INT 1
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: PUSH
90936: LD_INT 0
90938: PUSH
90939: LD_INT 1
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 1
90948: NEG
90949: PUSH
90950: LD_INT 0
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 1
90959: NEG
90960: PUSH
90961: LD_INT 1
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 1
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 2
90982: PUSH
90983: LD_INT 0
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: PUSH
90990: LD_INT 2
90992: PUSH
90993: LD_INT 1
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: LD_INT 2
91002: PUSH
91003: LD_INT 2
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 1
91012: PUSH
91013: LD_INT 2
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91034: LD_ADDR_VAR 0 50
91038: PUSH
91039: LD_INT 0
91041: PUSH
91042: LD_INT 0
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 1
91054: NEG
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 1
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 1
91072: PUSH
91073: LD_INT 1
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 0
91082: PUSH
91083: LD_INT 1
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 1
91092: NEG
91093: PUSH
91094: LD_INT 0
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: NEG
91104: PUSH
91105: LD_INT 1
91107: NEG
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 2
91115: PUSH
91116: LD_INT 1
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 2
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: LD_INT 2
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 0
91145: PUSH
91146: LD_INT 2
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: NEG
91156: PUSH
91157: LD_INT 1
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91178: LD_ADDR_VAR 0 51
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 0
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 0
91195: PUSH
91196: LD_INT 1
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 1
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 1
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 0
91226: PUSH
91227: LD_INT 1
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: LD_INT 0
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 1
91247: NEG
91248: PUSH
91249: LD_INT 1
91251: NEG
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 1
91259: PUSH
91260: LD_INT 2
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: LD_INT 2
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 1
91279: NEG
91280: PUSH
91281: LD_INT 1
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 2
91290: NEG
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 2
91301: NEG
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91325: LD_ADDR_VAR 0 52
91329: PUSH
91330: LD_INT 0
91332: PUSH
91333: LD_INT 0
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 0
91342: PUSH
91343: LD_INT 1
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 1
91353: PUSH
91354: LD_INT 0
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 1
91363: PUSH
91364: LD_INT 1
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: LD_INT 1
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: NEG
91384: PUSH
91385: LD_INT 0
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PUSH
91392: LD_INT 1
91394: NEG
91395: PUSH
91396: LD_INT 1
91398: NEG
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 1
91406: NEG
91407: PUSH
91408: LD_INT 2
91410: NEG
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 1
91418: NEG
91419: PUSH
91420: LD_INT 1
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 2
91429: NEG
91430: PUSH
91431: LD_INT 0
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 2
91440: NEG
91441: PUSH
91442: LD_INT 1
91444: NEG
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 2
91452: NEG
91453: PUSH
91454: LD_INT 2
91456: NEG
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91476: LD_ADDR_VAR 0 53
91480: PUSH
91481: LD_INT 0
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: PUSH
91491: LD_INT 0
91493: PUSH
91494: LD_INT 1
91496: NEG
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 1
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: PUSH
91515: LD_INT 1
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 0
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 1
91534: NEG
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 1
91545: NEG
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 1
91557: NEG
91558: PUSH
91559: LD_INT 2
91561: NEG
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 0
91569: PUSH
91570: LD_INT 2
91572: NEG
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 1
91580: PUSH
91581: LD_INT 1
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 2
91591: PUSH
91592: LD_INT 0
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: PUSH
91599: LD_INT 2
91601: PUSH
91602: LD_INT 1
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: PUSH
91609: LD_INT 2
91611: PUSH
91612: LD_INT 2
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 1
91621: PUSH
91622: LD_INT 2
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: LD_INT 2
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 1
91641: NEG
91642: PUSH
91643: LD_INT 1
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 2
91652: NEG
91653: PUSH
91654: LD_INT 0
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 2
91663: NEG
91664: PUSH
91665: LD_INT 1
91667: NEG
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 2
91675: NEG
91676: PUSH
91677: LD_INT 2
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91706: LD_ADDR_VAR 0 54
91710: PUSH
91711: LD_INT 0
91713: PUSH
91714: LD_INT 0
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: LD_INT 0
91723: PUSH
91724: LD_INT 1
91726: NEG
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 1
91734: PUSH
91735: LD_INT 0
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 1
91744: PUSH
91745: LD_INT 1
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 0
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: NEG
91765: PUSH
91766: LD_INT 0
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 1
91787: NEG
91788: PUSH
91789: LD_INT 2
91791: NEG
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 0
91799: PUSH
91800: LD_INT 2
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 1
91810: PUSH
91811: LD_INT 1
91813: NEG
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 2
91821: PUSH
91822: LD_INT 0
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 2
91831: PUSH
91832: LD_INT 1
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 2
91841: PUSH
91842: LD_INT 2
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: PUSH
91849: LD_INT 1
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: LD_INT 0
91861: PUSH
91862: LD_INT 2
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 1
91871: NEG
91872: PUSH
91873: LD_INT 1
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 2
91882: NEG
91883: PUSH
91884: LD_INT 0
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: LD_INT 2
91893: NEG
91894: PUSH
91895: LD_INT 1
91897: NEG
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 2
91905: NEG
91906: PUSH
91907: LD_INT 2
91909: NEG
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91936: LD_ADDR_VAR 0 55
91940: PUSH
91941: LD_INT 0
91943: PUSH
91944: LD_INT 0
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 0
91953: PUSH
91954: LD_INT 1
91956: NEG
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: PUSH
91965: LD_INT 0
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 1
91974: PUSH
91975: LD_INT 1
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 0
91984: PUSH
91985: LD_INT 1
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 1
91994: NEG
91995: PUSH
91996: LD_INT 0
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 1
92005: NEG
92006: PUSH
92007: LD_INT 1
92009: NEG
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 1
92017: NEG
92018: PUSH
92019: LD_INT 2
92021: NEG
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: LD_INT 0
92029: PUSH
92030: LD_INT 2
92032: NEG
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: PUSH
92038: LD_INT 1
92040: PUSH
92041: LD_INT 1
92043: NEG
92044: PUSH
92045: EMPTY
92046: LIST
92047: LIST
92048: PUSH
92049: LD_INT 2
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 2
92061: PUSH
92062: LD_INT 1
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 2
92071: PUSH
92072: LD_INT 2
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 1
92081: PUSH
92082: LD_INT 2
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 0
92091: PUSH
92092: LD_INT 2
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_INT 1
92101: NEG
92102: PUSH
92103: LD_INT 1
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PUSH
92110: LD_INT 2
92112: NEG
92113: PUSH
92114: LD_INT 0
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: PUSH
92121: LD_INT 2
92123: NEG
92124: PUSH
92125: LD_INT 1
92127: NEG
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: PUSH
92133: LD_INT 2
92135: NEG
92136: PUSH
92137: LD_INT 2
92139: NEG
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92166: LD_ADDR_VAR 0 56
92170: PUSH
92171: LD_INT 0
92173: PUSH
92174: LD_INT 0
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: LD_INT 1
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 1
92194: PUSH
92195: LD_INT 0
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: PUSH
92202: LD_INT 1
92204: PUSH
92205: LD_INT 1
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 0
92214: PUSH
92215: LD_INT 1
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: LD_INT 0
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 1
92235: NEG
92236: PUSH
92237: LD_INT 1
92239: NEG
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: LD_INT 1
92247: NEG
92248: PUSH
92249: LD_INT 2
92251: NEG
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 0
92259: PUSH
92260: LD_INT 2
92262: NEG
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 1
92270: PUSH
92271: LD_INT 1
92273: NEG
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 2
92281: PUSH
92282: LD_INT 0
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 2
92291: PUSH
92292: LD_INT 1
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 2
92301: PUSH
92302: LD_INT 2
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 1
92311: PUSH
92312: LD_INT 2
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 0
92321: PUSH
92322: LD_INT 2
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 1
92331: NEG
92332: PUSH
92333: LD_INT 1
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 2
92342: NEG
92343: PUSH
92344: LD_INT 0
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 2
92353: NEG
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 2
92365: NEG
92366: PUSH
92367: LD_INT 2
92369: NEG
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92396: LD_ADDR_VAR 0 57
92400: PUSH
92401: LD_INT 0
92403: PUSH
92404: LD_INT 0
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 0
92413: PUSH
92414: LD_INT 1
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 1
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 1
92434: PUSH
92435: LD_INT 1
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 0
92444: PUSH
92445: LD_INT 1
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 1
92454: NEG
92455: PUSH
92456: LD_INT 0
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 1
92465: NEG
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: LD_INT 2
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 0
92489: PUSH
92490: LD_INT 2
92492: NEG
92493: PUSH
92494: EMPTY
92495: LIST
92496: LIST
92497: PUSH
92498: LD_INT 1
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 2
92511: PUSH
92512: LD_INT 0
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: PUSH
92519: LD_INT 2
92521: PUSH
92522: LD_INT 1
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PUSH
92529: LD_INT 2
92531: PUSH
92532: LD_INT 2
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: LD_INT 2
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: PUSH
92549: LD_INT 0
92551: PUSH
92552: LD_INT 2
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 1
92561: NEG
92562: PUSH
92563: LD_INT 1
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 2
92572: NEG
92573: PUSH
92574: LD_INT 0
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: LD_INT 2
92583: NEG
92584: PUSH
92585: LD_INT 1
92587: NEG
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 2
92595: NEG
92596: PUSH
92597: LD_INT 2
92599: NEG
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92626: LD_ADDR_VAR 0 58
92630: PUSH
92631: LD_INT 0
92633: PUSH
92634: LD_INT 0
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 0
92643: PUSH
92644: LD_INT 1
92646: NEG
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 1
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: LD_INT 1
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 0
92674: PUSH
92675: LD_INT 1
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 1
92684: NEG
92685: PUSH
92686: LD_INT 0
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 1
92695: NEG
92696: PUSH
92697: LD_INT 1
92699: NEG
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 1
92707: NEG
92708: PUSH
92709: LD_INT 2
92711: NEG
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 0
92719: PUSH
92720: LD_INT 2
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 1
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 2
92741: PUSH
92742: LD_INT 0
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 1
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 2
92761: PUSH
92762: LD_INT 2
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 1
92771: PUSH
92772: LD_INT 2
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 0
92781: PUSH
92782: LD_INT 2
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 1
92791: NEG
92792: PUSH
92793: LD_INT 1
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 2
92802: NEG
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 2
92813: NEG
92814: PUSH
92815: LD_INT 1
92817: NEG
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 2
92825: NEG
92826: PUSH
92827: LD_INT 2
92829: NEG
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92856: LD_ADDR_VAR 0 59
92860: PUSH
92861: LD_INT 0
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 0
92873: PUSH
92874: LD_INT 1
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 1
92884: PUSH
92885: LD_INT 0
92887: PUSH
92888: EMPTY
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 1
92894: PUSH
92895: LD_INT 1
92897: PUSH
92898: EMPTY
92899: LIST
92900: LIST
92901: PUSH
92902: LD_INT 0
92904: PUSH
92905: LD_INT 1
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: LD_INT 1
92914: NEG
92915: PUSH
92916: LD_INT 0
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 1
92925: NEG
92926: PUSH
92927: LD_INT 1
92929: NEG
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92944: LD_ADDR_VAR 0 60
92948: PUSH
92949: LD_INT 0
92951: PUSH
92952: LD_INT 0
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 0
92961: PUSH
92962: LD_INT 1
92964: NEG
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: PUSH
92970: LD_INT 1
92972: PUSH
92973: LD_INT 0
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 1
92982: PUSH
92983: LD_INT 1
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 0
92992: PUSH
92993: LD_INT 1
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 1
93002: NEG
93003: PUSH
93004: LD_INT 0
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 1
93013: NEG
93014: PUSH
93015: LD_INT 1
93017: NEG
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93032: LD_ADDR_VAR 0 61
93036: PUSH
93037: LD_INT 0
93039: PUSH
93040: LD_INT 0
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PUSH
93047: LD_INT 0
93049: PUSH
93050: LD_INT 1
93052: NEG
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 1
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 1
93070: PUSH
93071: LD_INT 1
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 0
93080: PUSH
93081: LD_INT 1
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 1
93090: NEG
93091: PUSH
93092: LD_INT 0
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 1
93101: NEG
93102: PUSH
93103: LD_INT 1
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93120: LD_ADDR_VAR 0 62
93124: PUSH
93125: LD_INT 0
93127: PUSH
93128: LD_INT 0
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 0
93137: PUSH
93138: LD_INT 1
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 1
93148: PUSH
93149: LD_INT 0
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 1
93158: PUSH
93159: LD_INT 1
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 0
93168: PUSH
93169: LD_INT 1
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 1
93178: NEG
93179: PUSH
93180: LD_INT 0
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 1
93189: NEG
93190: PUSH
93191: LD_INT 1
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93208: LD_ADDR_VAR 0 63
93212: PUSH
93213: LD_INT 0
93215: PUSH
93216: LD_INT 0
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 0
93225: PUSH
93226: LD_INT 1
93228: NEG
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 1
93236: PUSH
93237: LD_INT 0
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 1
93246: PUSH
93247: LD_INT 1
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 0
93256: PUSH
93257: LD_INT 1
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 1
93266: NEG
93267: PUSH
93268: LD_INT 0
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 1
93277: NEG
93278: PUSH
93279: LD_INT 1
93281: NEG
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93296: LD_ADDR_VAR 0 64
93300: PUSH
93301: LD_INT 0
93303: PUSH
93304: LD_INT 0
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 0
93313: PUSH
93314: LD_INT 1
93316: NEG
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 1
93324: PUSH
93325: LD_INT 0
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 1
93334: PUSH
93335: LD_INT 1
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 0
93344: PUSH
93345: LD_INT 1
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 1
93354: NEG
93355: PUSH
93356: LD_INT 0
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 1
93365: NEG
93366: PUSH
93367: LD_INT 1
93369: NEG
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: ST_TO_ADDR
// end ; 1 :
93384: GO 99281
93386: LD_INT 1
93388: DOUBLE
93389: EQUAL
93390: IFTRUE 93394
93392: GO 96017
93394: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93395: LD_ADDR_VAR 0 11
93399: PUSH
93400: LD_INT 1
93402: NEG
93403: PUSH
93404: LD_INT 3
93406: NEG
93407: PUSH
93408: EMPTY
93409: LIST
93410: LIST
93411: PUSH
93412: LD_INT 0
93414: PUSH
93415: LD_INT 3
93417: NEG
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 1
93425: PUSH
93426: LD_INT 2
93428: NEG
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: LIST
93438: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93439: LD_ADDR_VAR 0 12
93443: PUSH
93444: LD_INT 2
93446: PUSH
93447: LD_INT 1
93449: NEG
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 3
93457: PUSH
93458: LD_INT 0
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 3
93467: PUSH
93468: LD_INT 1
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: LIST
93479: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93480: LD_ADDR_VAR 0 13
93484: PUSH
93485: LD_INT 3
93487: PUSH
93488: LD_INT 2
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 3
93497: PUSH
93498: LD_INT 3
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 2
93507: PUSH
93508: LD_INT 3
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: LIST
93519: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93520: LD_ADDR_VAR 0 14
93524: PUSH
93525: LD_INT 1
93527: PUSH
93528: LD_INT 3
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: LD_INT 3
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: LD_INT 1
93547: NEG
93548: PUSH
93549: LD_INT 2
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93561: LD_ADDR_VAR 0 15
93565: PUSH
93566: LD_INT 2
93568: NEG
93569: PUSH
93570: LD_INT 1
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 3
93579: NEG
93580: PUSH
93581: LD_INT 0
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 3
93590: NEG
93591: PUSH
93592: LD_INT 1
93594: NEG
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: LIST
93604: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93605: LD_ADDR_VAR 0 16
93609: PUSH
93610: LD_INT 2
93612: NEG
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 3
93624: NEG
93625: PUSH
93626: LD_INT 2
93628: NEG
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 3
93636: NEG
93637: PUSH
93638: LD_INT 3
93640: NEG
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: LIST
93650: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93651: LD_ADDR_VAR 0 17
93655: PUSH
93656: LD_INT 1
93658: NEG
93659: PUSH
93660: LD_INT 3
93662: NEG
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 0
93670: PUSH
93671: LD_INT 3
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 1
93681: PUSH
93682: LD_INT 2
93684: NEG
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: LIST
93694: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93695: LD_ADDR_VAR 0 18
93699: PUSH
93700: LD_INT 2
93702: PUSH
93703: LD_INT 1
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 3
93713: PUSH
93714: LD_INT 0
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 3
93723: PUSH
93724: LD_INT 1
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: LIST
93735: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93736: LD_ADDR_VAR 0 19
93740: PUSH
93741: LD_INT 3
93743: PUSH
93744: LD_INT 2
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 3
93753: PUSH
93754: LD_INT 3
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PUSH
93761: LD_INT 2
93763: PUSH
93764: LD_INT 3
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: LIST
93775: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93776: LD_ADDR_VAR 0 20
93780: PUSH
93781: LD_INT 1
93783: PUSH
93784: LD_INT 3
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 0
93793: PUSH
93794: LD_INT 3
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 1
93803: NEG
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: LIST
93816: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93817: LD_ADDR_VAR 0 21
93821: PUSH
93822: LD_INT 2
93824: NEG
93825: PUSH
93826: LD_INT 1
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 3
93835: NEG
93836: PUSH
93837: LD_INT 0
93839: PUSH
93840: EMPTY
93841: LIST
93842: LIST
93843: PUSH
93844: LD_INT 3
93846: NEG
93847: PUSH
93848: LD_INT 1
93850: NEG
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: LIST
93860: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93861: LD_ADDR_VAR 0 22
93865: PUSH
93866: LD_INT 2
93868: NEG
93869: PUSH
93870: LD_INT 3
93872: NEG
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 3
93880: NEG
93881: PUSH
93882: LD_INT 2
93884: NEG
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: LD_INT 3
93892: NEG
93893: PUSH
93894: LD_INT 3
93896: NEG
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: LIST
93906: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93907: LD_ADDR_VAR 0 23
93911: PUSH
93912: LD_INT 0
93914: PUSH
93915: LD_INT 3
93917: NEG
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: PUSH
93923: LD_INT 1
93925: NEG
93926: PUSH
93927: LD_INT 4
93929: NEG
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: PUSH
93935: LD_INT 1
93937: PUSH
93938: LD_INT 3
93940: NEG
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: LIST
93950: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93951: LD_ADDR_VAR 0 24
93955: PUSH
93956: LD_INT 3
93958: PUSH
93959: LD_INT 0
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 3
93968: PUSH
93969: LD_INT 1
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 4
93979: PUSH
93980: LD_INT 1
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: LIST
93991: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93992: LD_ADDR_VAR 0 25
93996: PUSH
93997: LD_INT 3
93999: PUSH
94000: LD_INT 3
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 4
94009: PUSH
94010: LD_INT 3
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 3
94019: PUSH
94020: LD_INT 4
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: LIST
94031: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94032: LD_ADDR_VAR 0 26
94036: PUSH
94037: LD_INT 0
94039: PUSH
94040: LD_INT 3
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 1
94049: PUSH
94050: LD_INT 4
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 1
94059: NEG
94060: PUSH
94061: LD_INT 3
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: LIST
94072: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94073: LD_ADDR_VAR 0 27
94077: PUSH
94078: LD_INT 3
94080: NEG
94081: PUSH
94082: LD_INT 0
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 3
94091: NEG
94092: PUSH
94093: LD_INT 1
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 4
94102: NEG
94103: PUSH
94104: LD_INT 1
94106: NEG
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: LIST
94116: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94117: LD_ADDR_VAR 0 28
94121: PUSH
94122: LD_INT 3
94124: NEG
94125: PUSH
94126: LD_INT 3
94128: NEG
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: LD_INT 3
94136: NEG
94137: PUSH
94138: LD_INT 4
94140: NEG
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 4
94148: NEG
94149: PUSH
94150: LD_INT 3
94152: NEG
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: LIST
94162: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
94163: LD_ADDR_VAR 0 29
94167: PUSH
94168: LD_INT 1
94170: NEG
94171: PUSH
94172: LD_INT 3
94174: NEG
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: LD_INT 0
94182: PUSH
94183: LD_INT 3
94185: NEG
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 1
94193: PUSH
94194: LD_INT 2
94196: NEG
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 1
94204: NEG
94205: PUSH
94206: LD_INT 4
94208: NEG
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: PUSH
94214: LD_INT 0
94216: PUSH
94217: LD_INT 4
94219: NEG
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 1
94227: PUSH
94228: LD_INT 3
94230: NEG
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PUSH
94236: LD_INT 1
94238: NEG
94239: PUSH
94240: LD_INT 5
94242: NEG
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 0
94250: PUSH
94251: LD_INT 5
94253: NEG
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PUSH
94259: LD_INT 1
94261: PUSH
94262: LD_INT 4
94264: NEG
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: LD_INT 1
94272: NEG
94273: PUSH
94274: LD_INT 6
94276: NEG
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 0
94284: PUSH
94285: LD_INT 6
94287: NEG
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 1
94295: PUSH
94296: LD_INT 5
94298: NEG
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94318: LD_ADDR_VAR 0 30
94322: PUSH
94323: LD_INT 2
94325: PUSH
94326: LD_INT 1
94328: NEG
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 3
94336: PUSH
94337: LD_INT 0
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 3
94346: PUSH
94347: LD_INT 1
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 3
94356: PUSH
94357: LD_INT 1
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 4
94367: PUSH
94368: LD_INT 0
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 4
94377: PUSH
94378: LD_INT 1
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 4
94387: PUSH
94388: LD_INT 1
94390: NEG
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 5
94398: PUSH
94399: LD_INT 0
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 5
94408: PUSH
94409: LD_INT 1
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 5
94418: PUSH
94419: LD_INT 1
94421: NEG
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 6
94429: PUSH
94430: LD_INT 0
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 6
94439: PUSH
94440: LD_INT 1
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94461: LD_ADDR_VAR 0 31
94465: PUSH
94466: LD_INT 3
94468: PUSH
94469: LD_INT 2
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 3
94478: PUSH
94479: LD_INT 3
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 2
94488: PUSH
94489: LD_INT 3
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 4
94498: PUSH
94499: LD_INT 3
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 4
94508: PUSH
94509: LD_INT 4
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 3
94518: PUSH
94519: LD_INT 4
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 5
94528: PUSH
94529: LD_INT 4
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 5
94538: PUSH
94539: LD_INT 5
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 4
94548: PUSH
94549: LD_INT 5
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 6
94558: PUSH
94559: LD_INT 5
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 6
94568: PUSH
94569: LD_INT 6
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 5
94578: PUSH
94579: LD_INT 6
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94600: LD_ADDR_VAR 0 32
94604: PUSH
94605: LD_INT 1
94607: PUSH
94608: LD_INT 3
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 0
94617: PUSH
94618: LD_INT 3
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 1
94627: NEG
94628: PUSH
94629: LD_INT 2
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 1
94638: PUSH
94639: LD_INT 4
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 0
94648: PUSH
94649: LD_INT 4
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 1
94658: NEG
94659: PUSH
94660: LD_INT 3
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 1
94669: PUSH
94670: LD_INT 5
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 0
94679: PUSH
94680: LD_INT 5
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 1
94689: NEG
94690: PUSH
94691: LD_INT 4
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: LD_INT 6
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 0
94710: PUSH
94711: LD_INT 6
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 1
94720: NEG
94721: PUSH
94722: LD_INT 5
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94743: LD_ADDR_VAR 0 33
94747: PUSH
94748: LD_INT 2
94750: NEG
94751: PUSH
94752: LD_INT 1
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 3
94761: NEG
94762: PUSH
94763: LD_INT 0
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 3
94772: NEG
94773: PUSH
94774: LD_INT 1
94776: NEG
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 3
94784: NEG
94785: PUSH
94786: LD_INT 1
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 4
94795: NEG
94796: PUSH
94797: LD_INT 0
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 4
94806: NEG
94807: PUSH
94808: LD_INT 1
94810: NEG
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 4
94818: NEG
94819: PUSH
94820: LD_INT 1
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: LD_INT 5
94829: NEG
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 5
94840: NEG
94841: PUSH
94842: LD_INT 1
94844: NEG
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 5
94852: NEG
94853: PUSH
94854: LD_INT 1
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 6
94863: NEG
94864: PUSH
94865: LD_INT 0
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 6
94874: NEG
94875: PUSH
94876: LD_INT 1
94878: NEG
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94898: LD_ADDR_VAR 0 34
94902: PUSH
94903: LD_INT 2
94905: NEG
94906: PUSH
94907: LD_INT 3
94909: NEG
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 3
94917: NEG
94918: PUSH
94919: LD_INT 2
94921: NEG
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: PUSH
94927: LD_INT 3
94929: NEG
94930: PUSH
94931: LD_INT 3
94933: NEG
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 3
94941: NEG
94942: PUSH
94943: LD_INT 4
94945: NEG
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: LD_INT 4
94953: NEG
94954: PUSH
94955: LD_INT 3
94957: NEG
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 4
94965: NEG
94966: PUSH
94967: LD_INT 4
94969: NEG
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 4
94977: NEG
94978: PUSH
94979: LD_INT 5
94981: NEG
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 5
94989: NEG
94990: PUSH
94991: LD_INT 4
94993: NEG
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 5
95001: NEG
95002: PUSH
95003: LD_INT 5
95005: NEG
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 5
95013: NEG
95014: PUSH
95015: LD_INT 6
95017: NEG
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 6
95025: NEG
95026: PUSH
95027: LD_INT 5
95029: NEG
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 6
95037: NEG
95038: PUSH
95039: LD_INT 6
95041: NEG
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95061: LD_ADDR_VAR 0 41
95065: PUSH
95066: LD_INT 0
95068: PUSH
95069: LD_INT 2
95071: NEG
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 1
95079: NEG
95080: PUSH
95081: LD_INT 3
95083: NEG
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 1
95091: PUSH
95092: LD_INT 2
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: LIST
95104: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95105: LD_ADDR_VAR 0 42
95109: PUSH
95110: LD_INT 2
95112: PUSH
95113: LD_INT 0
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 2
95122: PUSH
95123: LD_INT 1
95125: NEG
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 3
95133: PUSH
95134: LD_INT 1
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: LIST
95145: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
95146: LD_ADDR_VAR 0 43
95150: PUSH
95151: LD_INT 2
95153: PUSH
95154: LD_INT 2
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 3
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 2
95173: PUSH
95174: LD_INT 3
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: LIST
95185: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95186: LD_ADDR_VAR 0 44
95190: PUSH
95191: LD_INT 0
95193: PUSH
95194: LD_INT 2
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 1
95203: PUSH
95204: LD_INT 3
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: PUSH
95211: LD_INT 1
95213: NEG
95214: PUSH
95215: LD_INT 2
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: LIST
95226: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95227: LD_ADDR_VAR 0 45
95231: PUSH
95232: LD_INT 2
95234: NEG
95235: PUSH
95236: LD_INT 0
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 2
95245: NEG
95246: PUSH
95247: LD_INT 1
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: LD_INT 3
95256: NEG
95257: PUSH
95258: LD_INT 1
95260: NEG
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: LIST
95270: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95271: LD_ADDR_VAR 0 46
95275: PUSH
95276: LD_INT 2
95278: NEG
95279: PUSH
95280: LD_INT 2
95282: NEG
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 2
95290: NEG
95291: PUSH
95292: LD_INT 3
95294: NEG
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 3
95302: NEG
95303: PUSH
95304: LD_INT 2
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: EMPTY
95313: LIST
95314: LIST
95315: LIST
95316: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95317: LD_ADDR_VAR 0 47
95321: PUSH
95322: LD_INT 2
95324: NEG
95325: PUSH
95326: LD_INT 3
95328: NEG
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 1
95336: NEG
95337: PUSH
95338: LD_INT 3
95340: NEG
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95350: LD_ADDR_VAR 0 48
95354: PUSH
95355: LD_INT 1
95357: PUSH
95358: LD_INT 2
95360: NEG
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 2
95368: PUSH
95369: LD_INT 1
95371: NEG
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95381: LD_ADDR_VAR 0 49
95385: PUSH
95386: LD_INT 3
95388: PUSH
95389: LD_INT 1
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 3
95398: PUSH
95399: LD_INT 2
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95410: LD_ADDR_VAR 0 50
95414: PUSH
95415: LD_INT 2
95417: PUSH
95418: LD_INT 3
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 1
95427: PUSH
95428: LD_INT 3
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95439: LD_ADDR_VAR 0 51
95443: PUSH
95444: LD_INT 1
95446: NEG
95447: PUSH
95448: LD_INT 2
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: PUSH
95455: LD_INT 2
95457: NEG
95458: PUSH
95459: LD_INT 1
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95470: LD_ADDR_VAR 0 52
95474: PUSH
95475: LD_INT 3
95477: NEG
95478: PUSH
95479: LD_INT 1
95481: NEG
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 3
95489: NEG
95490: PUSH
95491: LD_INT 2
95493: NEG
95494: PUSH
95495: EMPTY
95496: LIST
95497: LIST
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95503: LD_ADDR_VAR 0 53
95507: PUSH
95508: LD_INT 1
95510: NEG
95511: PUSH
95512: LD_INT 3
95514: NEG
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 0
95522: PUSH
95523: LD_INT 3
95525: NEG
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 1
95533: PUSH
95534: LD_INT 2
95536: NEG
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: LIST
95546: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95547: LD_ADDR_VAR 0 54
95551: PUSH
95552: LD_INT 2
95554: PUSH
95555: LD_INT 1
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 3
95565: PUSH
95566: LD_INT 0
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: LD_INT 3
95575: PUSH
95576: LD_INT 1
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: LIST
95587: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95588: LD_ADDR_VAR 0 55
95592: PUSH
95593: LD_INT 3
95595: PUSH
95596: LD_INT 2
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 3
95605: PUSH
95606: LD_INT 3
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 2
95615: PUSH
95616: LD_INT 3
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: LIST
95627: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95628: LD_ADDR_VAR 0 56
95632: PUSH
95633: LD_INT 1
95635: PUSH
95636: LD_INT 3
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 0
95645: PUSH
95646: LD_INT 3
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 1
95655: NEG
95656: PUSH
95657: LD_INT 2
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: LIST
95668: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95669: LD_ADDR_VAR 0 57
95673: PUSH
95674: LD_INT 2
95676: NEG
95677: PUSH
95678: LD_INT 1
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 3
95687: NEG
95688: PUSH
95689: LD_INT 0
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: LD_INT 3
95698: NEG
95699: PUSH
95700: LD_INT 1
95702: NEG
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: LIST
95712: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95713: LD_ADDR_VAR 0 58
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: LD_INT 3
95724: NEG
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PUSH
95730: LD_INT 3
95732: NEG
95733: PUSH
95734: LD_INT 2
95736: NEG
95737: PUSH
95738: EMPTY
95739: LIST
95740: LIST
95741: PUSH
95742: LD_INT 3
95744: NEG
95745: PUSH
95746: LD_INT 3
95748: NEG
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: LIST
95758: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95759: LD_ADDR_VAR 0 59
95763: PUSH
95764: LD_INT 1
95766: NEG
95767: PUSH
95768: LD_INT 2
95770: NEG
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: PUSH
95776: LD_INT 0
95778: PUSH
95779: LD_INT 2
95781: NEG
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 1
95789: PUSH
95790: LD_INT 1
95792: NEG
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: LIST
95802: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95803: LD_ADDR_VAR 0 60
95807: PUSH
95808: LD_INT 1
95810: PUSH
95811: LD_INT 1
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 2
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: LD_INT 2
95831: PUSH
95832: LD_INT 1
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: LIST
95843: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95844: LD_ADDR_VAR 0 61
95848: PUSH
95849: LD_INT 2
95851: PUSH
95852: LD_INT 1
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 2
95861: PUSH
95862: LD_INT 2
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 1
95871: PUSH
95872: LD_INT 2
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: LIST
95883: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95884: LD_ADDR_VAR 0 62
95888: PUSH
95889: LD_INT 1
95891: PUSH
95892: LD_INT 2
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 0
95901: PUSH
95902: LD_INT 2
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 1
95911: NEG
95912: PUSH
95913: LD_INT 1
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: LIST
95924: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95925: LD_ADDR_VAR 0 63
95929: PUSH
95930: LD_INT 1
95932: NEG
95933: PUSH
95934: LD_INT 1
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 2
95943: NEG
95944: PUSH
95945: LD_INT 0
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: PUSH
95952: LD_INT 2
95954: NEG
95955: PUSH
95956: LD_INT 1
95958: NEG
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: LIST
95968: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95969: LD_ADDR_VAR 0 64
95973: PUSH
95974: LD_INT 1
95976: NEG
95977: PUSH
95978: LD_INT 2
95980: NEG
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 2
95988: NEG
95989: PUSH
95990: LD_INT 1
95992: NEG
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 2
96000: NEG
96001: PUSH
96002: LD_INT 2
96004: NEG
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: LIST
96014: ST_TO_ADDR
// end ; 2 :
96015: GO 99281
96017: LD_INT 2
96019: DOUBLE
96020: EQUAL
96021: IFTRUE 96025
96023: GO 99280
96025: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96026: LD_ADDR_VAR 0 29
96030: PUSH
96031: LD_INT 4
96033: PUSH
96034: LD_INT 0
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 4
96043: PUSH
96044: LD_INT 1
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 5
96054: PUSH
96055: LD_INT 0
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 5
96064: PUSH
96065: LD_INT 1
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 4
96074: PUSH
96075: LD_INT 1
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 3
96084: PUSH
96085: LD_INT 0
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 3
96094: PUSH
96095: LD_INT 1
96097: NEG
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 3
96105: PUSH
96106: LD_INT 2
96108: NEG
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PUSH
96114: LD_INT 5
96116: PUSH
96117: LD_INT 2
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 3
96126: PUSH
96127: LD_INT 3
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: LD_INT 3
96136: PUSH
96137: LD_INT 2
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: PUSH
96144: LD_INT 4
96146: PUSH
96147: LD_INT 3
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PUSH
96154: LD_INT 4
96156: PUSH
96157: LD_INT 4
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 3
96166: PUSH
96167: LD_INT 4
96169: PUSH
96170: EMPTY
96171: LIST
96172: LIST
96173: PUSH
96174: LD_INT 2
96176: PUSH
96177: LD_INT 3
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: LD_INT 2
96186: PUSH
96187: LD_INT 2
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: PUSH
96194: LD_INT 4
96196: PUSH
96197: LD_INT 2
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 2
96206: PUSH
96207: LD_INT 4
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: PUSH
96214: LD_INT 0
96216: PUSH
96217: LD_INT 4
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 0
96226: PUSH
96227: LD_INT 3
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 1
96236: PUSH
96237: LD_INT 4
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: PUSH
96244: LD_INT 1
96246: PUSH
96247: LD_INT 5
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: PUSH
96254: LD_INT 0
96256: PUSH
96257: LD_INT 5
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 1
96266: NEG
96267: PUSH
96268: LD_INT 4
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: PUSH
96275: LD_INT 1
96277: NEG
96278: PUSH
96279: LD_INT 3
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 2
96288: PUSH
96289: LD_INT 5
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: PUSH
96296: LD_INT 2
96298: NEG
96299: PUSH
96300: LD_INT 3
96302: PUSH
96303: EMPTY
96304: LIST
96305: LIST
96306: PUSH
96307: LD_INT 3
96309: NEG
96310: PUSH
96311: LD_INT 0
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 3
96320: NEG
96321: PUSH
96322: LD_INT 1
96324: NEG
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: PUSH
96330: LD_INT 2
96332: NEG
96333: PUSH
96334: LD_INT 0
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 2
96343: NEG
96344: PUSH
96345: LD_INT 1
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: PUSH
96352: LD_INT 3
96354: NEG
96355: PUSH
96356: LD_INT 1
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 4
96365: NEG
96366: PUSH
96367: LD_INT 0
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 4
96376: NEG
96377: PUSH
96378: LD_INT 1
96380: NEG
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 4
96388: NEG
96389: PUSH
96390: LD_INT 2
96392: NEG
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 2
96400: NEG
96401: PUSH
96402: LD_INT 2
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 4
96411: NEG
96412: PUSH
96413: LD_INT 4
96415: NEG
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: LD_INT 4
96423: NEG
96424: PUSH
96425: LD_INT 5
96427: NEG
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 3
96435: NEG
96436: PUSH
96437: LD_INT 4
96439: NEG
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 3
96447: NEG
96448: PUSH
96449: LD_INT 3
96451: NEG
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 4
96459: NEG
96460: PUSH
96461: LD_INT 3
96463: NEG
96464: PUSH
96465: EMPTY
96466: LIST
96467: LIST
96468: PUSH
96469: LD_INT 5
96471: NEG
96472: PUSH
96473: LD_INT 4
96475: NEG
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 5
96483: NEG
96484: PUSH
96485: LD_INT 5
96487: NEG
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 3
96495: NEG
96496: PUSH
96497: LD_INT 5
96499: NEG
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 5
96507: NEG
96508: PUSH
96509: LD_INT 3
96511: NEG
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96564: LD_ADDR_VAR 0 30
96568: PUSH
96569: LD_INT 4
96571: PUSH
96572: LD_INT 4
96574: PUSH
96575: EMPTY
96576: LIST
96577: LIST
96578: PUSH
96579: LD_INT 4
96581: PUSH
96582: LD_INT 3
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: PUSH
96589: LD_INT 5
96591: PUSH
96592: LD_INT 4
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: PUSH
96599: LD_INT 5
96601: PUSH
96602: LD_INT 5
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: LD_INT 4
96611: PUSH
96612: LD_INT 5
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: LD_INT 3
96621: PUSH
96622: LD_INT 4
96624: PUSH
96625: EMPTY
96626: LIST
96627: LIST
96628: PUSH
96629: LD_INT 3
96631: PUSH
96632: LD_INT 3
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: PUSH
96639: LD_INT 5
96641: PUSH
96642: LD_INT 3
96644: PUSH
96645: EMPTY
96646: LIST
96647: LIST
96648: PUSH
96649: LD_INT 3
96651: PUSH
96652: LD_INT 5
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: PUSH
96659: LD_INT 0
96661: PUSH
96662: LD_INT 3
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 0
96671: PUSH
96672: LD_INT 2
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: LD_INT 1
96681: PUSH
96682: LD_INT 3
96684: PUSH
96685: EMPTY
96686: LIST
96687: LIST
96688: PUSH
96689: LD_INT 1
96691: PUSH
96692: LD_INT 4
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: PUSH
96699: LD_INT 0
96701: PUSH
96702: LD_INT 4
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 1
96711: NEG
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 1
96722: NEG
96723: PUSH
96724: LD_INT 2
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 2
96733: PUSH
96734: LD_INT 4
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 2
96743: NEG
96744: PUSH
96745: LD_INT 2
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PUSH
96752: LD_INT 4
96754: NEG
96755: PUSH
96756: LD_INT 0
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PUSH
96763: LD_INT 4
96765: NEG
96766: PUSH
96767: LD_INT 1
96769: NEG
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 3
96777: NEG
96778: PUSH
96779: LD_INT 0
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 3
96788: NEG
96789: PUSH
96790: LD_INT 1
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 4
96799: NEG
96800: PUSH
96801: LD_INT 1
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 5
96810: NEG
96811: PUSH
96812: LD_INT 0
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: LD_INT 5
96821: NEG
96822: PUSH
96823: LD_INT 1
96825: NEG
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 5
96833: NEG
96834: PUSH
96835: LD_INT 2
96837: NEG
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: LD_INT 3
96845: NEG
96846: PUSH
96847: LD_INT 2
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 3
96856: NEG
96857: PUSH
96858: LD_INT 3
96860: NEG
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 3
96868: NEG
96869: PUSH
96870: LD_INT 4
96872: NEG
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 2
96880: NEG
96881: PUSH
96882: LD_INT 3
96884: NEG
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 2
96892: NEG
96893: PUSH
96894: LD_INT 2
96896: NEG
96897: PUSH
96898: EMPTY
96899: LIST
96900: LIST
96901: PUSH
96902: LD_INT 3
96904: NEG
96905: PUSH
96906: LD_INT 2
96908: NEG
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: PUSH
96914: LD_INT 4
96916: NEG
96917: PUSH
96918: LD_INT 3
96920: NEG
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 4
96928: NEG
96929: PUSH
96930: LD_INT 4
96932: NEG
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 2
96940: NEG
96941: PUSH
96942: LD_INT 4
96944: NEG
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PUSH
96950: LD_INT 4
96952: NEG
96953: PUSH
96954: LD_INT 2
96956: NEG
96957: PUSH
96958: EMPTY
96959: LIST
96960: LIST
96961: PUSH
96962: LD_INT 0
96964: PUSH
96965: LD_INT 4
96967: NEG
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 0
96975: PUSH
96976: LD_INT 5
96978: NEG
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 1
96986: PUSH
96987: LD_INT 4
96989: NEG
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 1
96997: PUSH
96998: LD_INT 3
97000: NEG
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 0
97008: PUSH
97009: LD_INT 3
97011: NEG
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 1
97019: NEG
97020: PUSH
97021: LD_INT 4
97023: NEG
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: PUSH
97029: LD_INT 1
97031: NEG
97032: PUSH
97033: LD_INT 5
97035: NEG
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 2
97043: PUSH
97044: LD_INT 3
97046: NEG
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 2
97054: NEG
97055: PUSH
97056: LD_INT 5
97058: NEG
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97111: LD_ADDR_VAR 0 31
97115: PUSH
97116: LD_INT 0
97118: PUSH
97119: LD_INT 4
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 0
97128: PUSH
97129: LD_INT 3
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 1
97138: PUSH
97139: LD_INT 4
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: PUSH
97146: LD_INT 1
97148: PUSH
97149: LD_INT 5
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: PUSH
97156: LD_INT 0
97158: PUSH
97159: LD_INT 5
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: LD_INT 1
97168: NEG
97169: PUSH
97170: LD_INT 4
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_INT 1
97179: NEG
97180: PUSH
97181: LD_INT 3
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: LD_INT 2
97190: PUSH
97191: LD_INT 5
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 2
97200: NEG
97201: PUSH
97202: LD_INT 3
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: PUSH
97209: LD_INT 3
97211: NEG
97212: PUSH
97213: LD_INT 0
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 3
97222: NEG
97223: PUSH
97224: LD_INT 1
97226: NEG
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 2
97234: NEG
97235: PUSH
97236: LD_INT 0
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 2
97245: NEG
97246: PUSH
97247: LD_INT 1
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 3
97256: NEG
97257: PUSH
97258: LD_INT 1
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 4
97267: NEG
97268: PUSH
97269: LD_INT 0
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 4
97278: NEG
97279: PUSH
97280: LD_INT 1
97282: NEG
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 4
97290: NEG
97291: PUSH
97292: LD_INT 2
97294: NEG
97295: PUSH
97296: EMPTY
97297: LIST
97298: LIST
97299: PUSH
97300: LD_INT 2
97302: NEG
97303: PUSH
97304: LD_INT 2
97306: PUSH
97307: EMPTY
97308: LIST
97309: LIST
97310: PUSH
97311: LD_INT 4
97313: NEG
97314: PUSH
97315: LD_INT 4
97317: NEG
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: LD_INT 4
97325: NEG
97326: PUSH
97327: LD_INT 5
97329: NEG
97330: PUSH
97331: EMPTY
97332: LIST
97333: LIST
97334: PUSH
97335: LD_INT 3
97337: NEG
97338: PUSH
97339: LD_INT 4
97341: NEG
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: PUSH
97347: LD_INT 3
97349: NEG
97350: PUSH
97351: LD_INT 3
97353: NEG
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 4
97361: NEG
97362: PUSH
97363: LD_INT 3
97365: NEG
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: PUSH
97371: LD_INT 5
97373: NEG
97374: PUSH
97375: LD_INT 4
97377: NEG
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 5
97385: NEG
97386: PUSH
97387: LD_INT 5
97389: NEG
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PUSH
97395: LD_INT 3
97397: NEG
97398: PUSH
97399: LD_INT 5
97401: NEG
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 5
97409: NEG
97410: PUSH
97411: LD_INT 3
97413: NEG
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PUSH
97419: LD_INT 0
97421: PUSH
97422: LD_INT 3
97424: NEG
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 0
97432: PUSH
97433: LD_INT 4
97435: NEG
97436: PUSH
97437: EMPTY
97438: LIST
97439: LIST
97440: PUSH
97441: LD_INT 1
97443: PUSH
97444: LD_INT 3
97446: NEG
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PUSH
97452: LD_INT 1
97454: PUSH
97455: LD_INT 2
97457: NEG
97458: PUSH
97459: EMPTY
97460: LIST
97461: LIST
97462: PUSH
97463: LD_INT 0
97465: PUSH
97466: LD_INT 2
97468: NEG
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PUSH
97474: LD_INT 1
97476: NEG
97477: PUSH
97478: LD_INT 3
97480: NEG
97481: PUSH
97482: EMPTY
97483: LIST
97484: LIST
97485: PUSH
97486: LD_INT 1
97488: NEG
97489: PUSH
97490: LD_INT 4
97492: NEG
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: LD_INT 2
97500: PUSH
97501: LD_INT 2
97503: NEG
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 2
97511: NEG
97512: PUSH
97513: LD_INT 4
97515: NEG
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 4
97523: PUSH
97524: LD_INT 0
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 4
97533: PUSH
97534: LD_INT 1
97536: NEG
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: PUSH
97542: LD_INT 5
97544: PUSH
97545: LD_INT 0
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 5
97554: PUSH
97555: LD_INT 1
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: PUSH
97562: LD_INT 4
97564: PUSH
97565: LD_INT 1
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: PUSH
97572: LD_INT 3
97574: PUSH
97575: LD_INT 0
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: PUSH
97582: LD_INT 3
97584: PUSH
97585: LD_INT 1
97587: NEG
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: LD_INT 3
97595: PUSH
97596: LD_INT 2
97598: NEG
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_INT 5
97606: PUSH
97607: LD_INT 2
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: LIST
97618: LIST
97619: LIST
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97661: LD_ADDR_VAR 0 32
97665: PUSH
97666: LD_INT 4
97668: NEG
97669: PUSH
97670: LD_INT 0
97672: PUSH
97673: EMPTY
97674: LIST
97675: LIST
97676: PUSH
97677: LD_INT 4
97679: NEG
97680: PUSH
97681: LD_INT 1
97683: NEG
97684: PUSH
97685: EMPTY
97686: LIST
97687: LIST
97688: PUSH
97689: LD_INT 3
97691: NEG
97692: PUSH
97693: LD_INT 0
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: PUSH
97700: LD_INT 3
97702: NEG
97703: PUSH
97704: LD_INT 1
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: PUSH
97711: LD_INT 4
97713: NEG
97714: PUSH
97715: LD_INT 1
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: PUSH
97722: LD_INT 5
97724: NEG
97725: PUSH
97726: LD_INT 0
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: LD_INT 5
97735: NEG
97736: PUSH
97737: LD_INT 1
97739: NEG
97740: PUSH
97741: EMPTY
97742: LIST
97743: LIST
97744: PUSH
97745: LD_INT 5
97747: NEG
97748: PUSH
97749: LD_INT 2
97751: NEG
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: PUSH
97757: LD_INT 3
97759: NEG
97760: PUSH
97761: LD_INT 2
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 3
97770: NEG
97771: PUSH
97772: LD_INT 3
97774: NEG
97775: PUSH
97776: EMPTY
97777: LIST
97778: LIST
97779: PUSH
97780: LD_INT 3
97782: NEG
97783: PUSH
97784: LD_INT 4
97786: NEG
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: PUSH
97792: LD_INT 2
97794: NEG
97795: PUSH
97796: LD_INT 3
97798: NEG
97799: PUSH
97800: EMPTY
97801: LIST
97802: LIST
97803: PUSH
97804: LD_INT 2
97806: NEG
97807: PUSH
97808: LD_INT 2
97810: NEG
97811: PUSH
97812: EMPTY
97813: LIST
97814: LIST
97815: PUSH
97816: LD_INT 3
97818: NEG
97819: PUSH
97820: LD_INT 2
97822: NEG
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: PUSH
97828: LD_INT 4
97830: NEG
97831: PUSH
97832: LD_INT 3
97834: NEG
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 4
97842: NEG
97843: PUSH
97844: LD_INT 4
97846: NEG
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 2
97854: NEG
97855: PUSH
97856: LD_INT 4
97858: NEG
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: PUSH
97864: LD_INT 4
97866: NEG
97867: PUSH
97868: LD_INT 2
97870: NEG
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: PUSH
97876: LD_INT 0
97878: PUSH
97879: LD_INT 4
97881: NEG
97882: PUSH
97883: EMPTY
97884: LIST
97885: LIST
97886: PUSH
97887: LD_INT 0
97889: PUSH
97890: LD_INT 5
97892: NEG
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 1
97900: PUSH
97901: LD_INT 4
97903: NEG
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: PUSH
97909: LD_INT 1
97911: PUSH
97912: LD_INT 3
97914: NEG
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PUSH
97920: LD_INT 0
97922: PUSH
97923: LD_INT 3
97925: NEG
97926: PUSH
97927: EMPTY
97928: LIST
97929: LIST
97930: PUSH
97931: LD_INT 1
97933: NEG
97934: PUSH
97935: LD_INT 4
97937: NEG
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PUSH
97943: LD_INT 1
97945: NEG
97946: PUSH
97947: LD_INT 5
97949: NEG
97950: PUSH
97951: EMPTY
97952: LIST
97953: LIST
97954: PUSH
97955: LD_INT 2
97957: PUSH
97958: LD_INT 3
97960: NEG
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 2
97968: NEG
97969: PUSH
97970: LD_INT 5
97972: NEG
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: PUSH
97978: LD_INT 3
97980: PUSH
97981: LD_INT 0
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PUSH
97988: LD_INT 3
97990: PUSH
97991: LD_INT 1
97993: NEG
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PUSH
97999: LD_INT 4
98001: PUSH
98002: LD_INT 0
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: PUSH
98009: LD_INT 4
98011: PUSH
98012: LD_INT 1
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: PUSH
98019: LD_INT 3
98021: PUSH
98022: LD_INT 1
98024: PUSH
98025: EMPTY
98026: LIST
98027: LIST
98028: PUSH
98029: LD_INT 2
98031: PUSH
98032: LD_INT 0
98034: PUSH
98035: EMPTY
98036: LIST
98037: LIST
98038: PUSH
98039: LD_INT 2
98041: PUSH
98042: LD_INT 1
98044: NEG
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 2
98052: PUSH
98053: LD_INT 2
98055: NEG
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: PUSH
98061: LD_INT 4
98063: PUSH
98064: LD_INT 2
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: PUSH
98071: LD_INT 4
98073: PUSH
98074: LD_INT 4
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 4
98083: PUSH
98084: LD_INT 3
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 5
98093: PUSH
98094: LD_INT 4
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PUSH
98101: LD_INT 5
98103: PUSH
98104: LD_INT 5
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: LD_INT 4
98113: PUSH
98114: LD_INT 5
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: PUSH
98121: LD_INT 3
98123: PUSH
98124: LD_INT 4
98126: PUSH
98127: EMPTY
98128: LIST
98129: LIST
98130: PUSH
98131: LD_INT 3
98133: PUSH
98134: LD_INT 3
98136: PUSH
98137: EMPTY
98138: LIST
98139: LIST
98140: PUSH
98141: LD_INT 5
98143: PUSH
98144: LD_INT 3
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 3
98153: PUSH
98154: LD_INT 5
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: LIST
98165: LIST
98166: LIST
98167: LIST
98168: LIST
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98208: LD_ADDR_VAR 0 33
98212: PUSH
98213: LD_INT 4
98215: NEG
98216: PUSH
98217: LD_INT 4
98219: NEG
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 4
98227: NEG
98228: PUSH
98229: LD_INT 5
98231: NEG
98232: PUSH
98233: EMPTY
98234: LIST
98235: LIST
98236: PUSH
98237: LD_INT 3
98239: NEG
98240: PUSH
98241: LD_INT 4
98243: NEG
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: PUSH
98249: LD_INT 3
98251: NEG
98252: PUSH
98253: LD_INT 3
98255: NEG
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: PUSH
98261: LD_INT 4
98263: NEG
98264: PUSH
98265: LD_INT 3
98267: NEG
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PUSH
98273: LD_INT 5
98275: NEG
98276: PUSH
98277: LD_INT 4
98279: NEG
98280: PUSH
98281: EMPTY
98282: LIST
98283: LIST
98284: PUSH
98285: LD_INT 5
98287: NEG
98288: PUSH
98289: LD_INT 5
98291: NEG
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PUSH
98297: LD_INT 3
98299: NEG
98300: PUSH
98301: LD_INT 5
98303: NEG
98304: PUSH
98305: EMPTY
98306: LIST
98307: LIST
98308: PUSH
98309: LD_INT 5
98311: NEG
98312: PUSH
98313: LD_INT 3
98315: NEG
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: PUSH
98321: LD_INT 0
98323: PUSH
98324: LD_INT 3
98326: NEG
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: PUSH
98332: LD_INT 0
98334: PUSH
98335: LD_INT 4
98337: NEG
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: PUSH
98343: LD_INT 1
98345: PUSH
98346: LD_INT 3
98348: NEG
98349: PUSH
98350: EMPTY
98351: LIST
98352: LIST
98353: PUSH
98354: LD_INT 1
98356: PUSH
98357: LD_INT 2
98359: NEG
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 0
98367: PUSH
98368: LD_INT 2
98370: NEG
98371: PUSH
98372: EMPTY
98373: LIST
98374: LIST
98375: PUSH
98376: LD_INT 1
98378: NEG
98379: PUSH
98380: LD_INT 3
98382: NEG
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: PUSH
98388: LD_INT 1
98390: NEG
98391: PUSH
98392: LD_INT 4
98394: NEG
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: LD_INT 2
98402: PUSH
98403: LD_INT 2
98405: NEG
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 2
98413: NEG
98414: PUSH
98415: LD_INT 4
98417: NEG
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: LD_INT 4
98425: PUSH
98426: LD_INT 0
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: LD_INT 4
98435: PUSH
98436: LD_INT 1
98438: NEG
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: PUSH
98444: LD_INT 5
98446: PUSH
98447: LD_INT 0
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: PUSH
98454: LD_INT 5
98456: PUSH
98457: LD_INT 1
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: PUSH
98464: LD_INT 4
98466: PUSH
98467: LD_INT 1
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: PUSH
98474: LD_INT 3
98476: PUSH
98477: LD_INT 0
98479: PUSH
98480: EMPTY
98481: LIST
98482: LIST
98483: PUSH
98484: LD_INT 3
98486: PUSH
98487: LD_INT 1
98489: NEG
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PUSH
98495: LD_INT 3
98497: PUSH
98498: LD_INT 2
98500: NEG
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PUSH
98506: LD_INT 5
98508: PUSH
98509: LD_INT 2
98511: PUSH
98512: EMPTY
98513: LIST
98514: LIST
98515: PUSH
98516: LD_INT 3
98518: PUSH
98519: LD_INT 3
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: LD_INT 3
98528: PUSH
98529: LD_INT 2
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 4
98538: PUSH
98539: LD_INT 3
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: LD_INT 4
98548: PUSH
98549: LD_INT 4
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 3
98558: PUSH
98559: LD_INT 4
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: PUSH
98566: LD_INT 2
98568: PUSH
98569: LD_INT 3
98571: PUSH
98572: EMPTY
98573: LIST
98574: LIST
98575: PUSH
98576: LD_INT 2
98578: PUSH
98579: LD_INT 2
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: LD_INT 4
98588: PUSH
98589: LD_INT 2
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: PUSH
98596: LD_INT 2
98598: PUSH
98599: LD_INT 4
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: PUSH
98606: LD_INT 0
98608: PUSH
98609: LD_INT 4
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: PUSH
98616: LD_INT 0
98618: PUSH
98619: LD_INT 3
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PUSH
98626: LD_INT 1
98628: PUSH
98629: LD_INT 4
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 1
98638: PUSH
98639: LD_INT 5
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PUSH
98646: LD_INT 0
98648: PUSH
98649: LD_INT 5
98651: PUSH
98652: EMPTY
98653: LIST
98654: LIST
98655: PUSH
98656: LD_INT 1
98658: NEG
98659: PUSH
98660: LD_INT 4
98662: PUSH
98663: EMPTY
98664: LIST
98665: LIST
98666: PUSH
98667: LD_INT 1
98669: NEG
98670: PUSH
98671: LD_INT 3
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 2
98680: PUSH
98681: LD_INT 5
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 2
98690: NEG
98691: PUSH
98692: LD_INT 3
98694: PUSH
98695: EMPTY
98696: LIST
98697: LIST
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98746: LD_ADDR_VAR 0 34
98750: PUSH
98751: LD_INT 0
98753: PUSH
98754: LD_INT 4
98756: NEG
98757: PUSH
98758: EMPTY
98759: LIST
98760: LIST
98761: PUSH
98762: LD_INT 0
98764: PUSH
98765: LD_INT 5
98767: NEG
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PUSH
98773: LD_INT 1
98775: PUSH
98776: LD_INT 4
98778: NEG
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: LD_INT 1
98786: PUSH
98787: LD_INT 3
98789: NEG
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 0
98797: PUSH
98798: LD_INT 3
98800: NEG
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: PUSH
98806: LD_INT 1
98808: NEG
98809: PUSH
98810: LD_INT 4
98812: NEG
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: PUSH
98818: LD_INT 1
98820: NEG
98821: PUSH
98822: LD_INT 5
98824: NEG
98825: PUSH
98826: EMPTY
98827: LIST
98828: LIST
98829: PUSH
98830: LD_INT 2
98832: PUSH
98833: LD_INT 3
98835: NEG
98836: PUSH
98837: EMPTY
98838: LIST
98839: LIST
98840: PUSH
98841: LD_INT 2
98843: NEG
98844: PUSH
98845: LD_INT 5
98847: NEG
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: LD_INT 3
98855: PUSH
98856: LD_INT 0
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 3
98865: PUSH
98866: LD_INT 1
98868: NEG
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PUSH
98874: LD_INT 4
98876: PUSH
98877: LD_INT 0
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: PUSH
98884: LD_INT 4
98886: PUSH
98887: LD_INT 1
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PUSH
98894: LD_INT 3
98896: PUSH
98897: LD_INT 1
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 2
98906: PUSH
98907: LD_INT 0
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 2
98916: PUSH
98917: LD_INT 1
98919: NEG
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 2
98927: PUSH
98928: LD_INT 2
98930: NEG
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_INT 4
98938: PUSH
98939: LD_INT 2
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 4
98948: PUSH
98949: LD_INT 4
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PUSH
98956: LD_INT 4
98958: PUSH
98959: LD_INT 3
98961: PUSH
98962: EMPTY
98963: LIST
98964: LIST
98965: PUSH
98966: LD_INT 5
98968: PUSH
98969: LD_INT 4
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PUSH
98976: LD_INT 5
98978: PUSH
98979: LD_INT 5
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 4
98988: PUSH
98989: LD_INT 5
98991: PUSH
98992: EMPTY
98993: LIST
98994: LIST
98995: PUSH
98996: LD_INT 3
98998: PUSH
98999: LD_INT 4
99001: PUSH
99002: EMPTY
99003: LIST
99004: LIST
99005: PUSH
99006: LD_INT 3
99008: PUSH
99009: LD_INT 3
99011: PUSH
99012: EMPTY
99013: LIST
99014: LIST
99015: PUSH
99016: LD_INT 5
99018: PUSH
99019: LD_INT 3
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: LD_INT 3
99028: PUSH
99029: LD_INT 5
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: LD_INT 0
99038: PUSH
99039: LD_INT 3
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 0
99048: PUSH
99049: LD_INT 2
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 1
99058: PUSH
99059: LD_INT 3
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 1
99068: PUSH
99069: LD_INT 4
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 0
99078: PUSH
99079: LD_INT 4
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: PUSH
99086: LD_INT 1
99088: NEG
99089: PUSH
99090: LD_INT 3
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: PUSH
99097: LD_INT 1
99099: NEG
99100: PUSH
99101: LD_INT 2
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 2
99110: PUSH
99111: LD_INT 4
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 2
99120: NEG
99121: PUSH
99122: LD_INT 2
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 4
99131: NEG
99132: PUSH
99133: LD_INT 0
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: PUSH
99140: LD_INT 4
99142: NEG
99143: PUSH
99144: LD_INT 1
99146: NEG
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: LD_INT 3
99154: NEG
99155: PUSH
99156: LD_INT 0
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: PUSH
99163: LD_INT 3
99165: NEG
99166: PUSH
99167: LD_INT 1
99169: PUSH
99170: EMPTY
99171: LIST
99172: LIST
99173: PUSH
99174: LD_INT 4
99176: NEG
99177: PUSH
99178: LD_INT 1
99180: PUSH
99181: EMPTY
99182: LIST
99183: LIST
99184: PUSH
99185: LD_INT 5
99187: NEG
99188: PUSH
99189: LD_INT 0
99191: PUSH
99192: EMPTY
99193: LIST
99194: LIST
99195: PUSH
99196: LD_INT 5
99198: NEG
99199: PUSH
99200: LD_INT 1
99202: NEG
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 5
99210: NEG
99211: PUSH
99212: LD_INT 2
99214: NEG
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: LD_INT 3
99222: NEG
99223: PUSH
99224: LD_INT 2
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: ST_TO_ADDR
// end ; end ;
99278: GO 99281
99280: POP
// case btype of b_depot , b_warehouse :
99281: LD_VAR 0 1
99285: PUSH
99286: LD_INT 0
99288: DOUBLE
99289: EQUAL
99290: IFTRUE 99300
99292: LD_INT 1
99294: DOUBLE
99295: EQUAL
99296: IFTRUE 99300
99298: GO 99501
99300: POP
// case nation of nation_american :
99301: LD_VAR 0 5
99305: PUSH
99306: LD_INT 1
99308: DOUBLE
99309: EQUAL
99310: IFTRUE 99314
99312: GO 99370
99314: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99315: LD_ADDR_VAR 0 9
99319: PUSH
99320: LD_VAR 0 11
99324: PUSH
99325: LD_VAR 0 12
99329: PUSH
99330: LD_VAR 0 13
99334: PUSH
99335: LD_VAR 0 14
99339: PUSH
99340: LD_VAR 0 15
99344: PUSH
99345: LD_VAR 0 16
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: PUSH
99358: LD_VAR 0 4
99362: PUSH
99363: LD_INT 1
99365: PLUS
99366: ARRAY
99367: ST_TO_ADDR
99368: GO 99499
99370: LD_INT 2
99372: DOUBLE
99373: EQUAL
99374: IFTRUE 99378
99376: GO 99434
99378: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99379: LD_ADDR_VAR 0 9
99383: PUSH
99384: LD_VAR 0 17
99388: PUSH
99389: LD_VAR 0 18
99393: PUSH
99394: LD_VAR 0 19
99398: PUSH
99399: LD_VAR 0 20
99403: PUSH
99404: LD_VAR 0 21
99408: PUSH
99409: LD_VAR 0 22
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: PUSH
99422: LD_VAR 0 4
99426: PUSH
99427: LD_INT 1
99429: PLUS
99430: ARRAY
99431: ST_TO_ADDR
99432: GO 99499
99434: LD_INT 3
99436: DOUBLE
99437: EQUAL
99438: IFTRUE 99442
99440: GO 99498
99442: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99443: LD_ADDR_VAR 0 9
99447: PUSH
99448: LD_VAR 0 23
99452: PUSH
99453: LD_VAR 0 24
99457: PUSH
99458: LD_VAR 0 25
99462: PUSH
99463: LD_VAR 0 26
99467: PUSH
99468: LD_VAR 0 27
99472: PUSH
99473: LD_VAR 0 28
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: PUSH
99486: LD_VAR 0 4
99490: PUSH
99491: LD_INT 1
99493: PLUS
99494: ARRAY
99495: ST_TO_ADDR
99496: GO 99499
99498: POP
99499: GO 100054
99501: LD_INT 2
99503: DOUBLE
99504: EQUAL
99505: IFTRUE 99515
99507: LD_INT 3
99509: DOUBLE
99510: EQUAL
99511: IFTRUE 99515
99513: GO 99571
99515: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99516: LD_ADDR_VAR 0 9
99520: PUSH
99521: LD_VAR 0 29
99525: PUSH
99526: LD_VAR 0 30
99530: PUSH
99531: LD_VAR 0 31
99535: PUSH
99536: LD_VAR 0 32
99540: PUSH
99541: LD_VAR 0 33
99545: PUSH
99546: LD_VAR 0 34
99550: PUSH
99551: EMPTY
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: PUSH
99559: LD_VAR 0 4
99563: PUSH
99564: LD_INT 1
99566: PLUS
99567: ARRAY
99568: ST_TO_ADDR
99569: GO 100054
99571: LD_INT 16
99573: DOUBLE
99574: EQUAL
99575: IFTRUE 99633
99577: LD_INT 17
99579: DOUBLE
99580: EQUAL
99581: IFTRUE 99633
99583: LD_INT 18
99585: DOUBLE
99586: EQUAL
99587: IFTRUE 99633
99589: LD_INT 19
99591: DOUBLE
99592: EQUAL
99593: IFTRUE 99633
99595: LD_INT 22
99597: DOUBLE
99598: EQUAL
99599: IFTRUE 99633
99601: LD_INT 20
99603: DOUBLE
99604: EQUAL
99605: IFTRUE 99633
99607: LD_INT 21
99609: DOUBLE
99610: EQUAL
99611: IFTRUE 99633
99613: LD_INT 23
99615: DOUBLE
99616: EQUAL
99617: IFTRUE 99633
99619: LD_INT 24
99621: DOUBLE
99622: EQUAL
99623: IFTRUE 99633
99625: LD_INT 25
99627: DOUBLE
99628: EQUAL
99629: IFTRUE 99633
99631: GO 99689
99633: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99634: LD_ADDR_VAR 0 9
99638: PUSH
99639: LD_VAR 0 35
99643: PUSH
99644: LD_VAR 0 36
99648: PUSH
99649: LD_VAR 0 37
99653: PUSH
99654: LD_VAR 0 38
99658: PUSH
99659: LD_VAR 0 39
99663: PUSH
99664: LD_VAR 0 40
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: PUSH
99677: LD_VAR 0 4
99681: PUSH
99682: LD_INT 1
99684: PLUS
99685: ARRAY
99686: ST_TO_ADDR
99687: GO 100054
99689: LD_INT 6
99691: DOUBLE
99692: EQUAL
99693: IFTRUE 99745
99695: LD_INT 7
99697: DOUBLE
99698: EQUAL
99699: IFTRUE 99745
99701: LD_INT 8
99703: DOUBLE
99704: EQUAL
99705: IFTRUE 99745
99707: LD_INT 13
99709: DOUBLE
99710: EQUAL
99711: IFTRUE 99745
99713: LD_INT 12
99715: DOUBLE
99716: EQUAL
99717: IFTRUE 99745
99719: LD_INT 15
99721: DOUBLE
99722: EQUAL
99723: IFTRUE 99745
99725: LD_INT 11
99727: DOUBLE
99728: EQUAL
99729: IFTRUE 99745
99731: LD_INT 14
99733: DOUBLE
99734: EQUAL
99735: IFTRUE 99745
99737: LD_INT 10
99739: DOUBLE
99740: EQUAL
99741: IFTRUE 99745
99743: GO 99801
99745: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99746: LD_ADDR_VAR 0 9
99750: PUSH
99751: LD_VAR 0 41
99755: PUSH
99756: LD_VAR 0 42
99760: PUSH
99761: LD_VAR 0 43
99765: PUSH
99766: LD_VAR 0 44
99770: PUSH
99771: LD_VAR 0 45
99775: PUSH
99776: LD_VAR 0 46
99780: PUSH
99781: EMPTY
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: PUSH
99789: LD_VAR 0 4
99793: PUSH
99794: LD_INT 1
99796: PLUS
99797: ARRAY
99798: ST_TO_ADDR
99799: GO 100054
99801: LD_INT 36
99803: DOUBLE
99804: EQUAL
99805: IFTRUE 99809
99807: GO 99865
99809: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99810: LD_ADDR_VAR 0 9
99814: PUSH
99815: LD_VAR 0 47
99819: PUSH
99820: LD_VAR 0 48
99824: PUSH
99825: LD_VAR 0 49
99829: PUSH
99830: LD_VAR 0 50
99834: PUSH
99835: LD_VAR 0 51
99839: PUSH
99840: LD_VAR 0 52
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: LIST
99849: LIST
99850: LIST
99851: LIST
99852: PUSH
99853: LD_VAR 0 4
99857: PUSH
99858: LD_INT 1
99860: PLUS
99861: ARRAY
99862: ST_TO_ADDR
99863: GO 100054
99865: LD_INT 4
99867: DOUBLE
99868: EQUAL
99869: IFTRUE 99891
99871: LD_INT 5
99873: DOUBLE
99874: EQUAL
99875: IFTRUE 99891
99877: LD_INT 34
99879: DOUBLE
99880: EQUAL
99881: IFTRUE 99891
99883: LD_INT 37
99885: DOUBLE
99886: EQUAL
99887: IFTRUE 99891
99889: GO 99947
99891: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99892: LD_ADDR_VAR 0 9
99896: PUSH
99897: LD_VAR 0 53
99901: PUSH
99902: LD_VAR 0 54
99906: PUSH
99907: LD_VAR 0 55
99911: PUSH
99912: LD_VAR 0 56
99916: PUSH
99917: LD_VAR 0 57
99921: PUSH
99922: LD_VAR 0 58
99926: PUSH
99927: EMPTY
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: PUSH
99935: LD_VAR 0 4
99939: PUSH
99940: LD_INT 1
99942: PLUS
99943: ARRAY
99944: ST_TO_ADDR
99945: GO 100054
99947: LD_INT 31
99949: DOUBLE
99950: EQUAL
99951: IFTRUE 99997
99953: LD_INT 32
99955: DOUBLE
99956: EQUAL
99957: IFTRUE 99997
99959: LD_INT 33
99961: DOUBLE
99962: EQUAL
99963: IFTRUE 99997
99965: LD_INT 27
99967: DOUBLE
99968: EQUAL
99969: IFTRUE 99997
99971: LD_INT 26
99973: DOUBLE
99974: EQUAL
99975: IFTRUE 99997
99977: LD_INT 28
99979: DOUBLE
99980: EQUAL
99981: IFTRUE 99997
99983: LD_INT 29
99985: DOUBLE
99986: EQUAL
99987: IFTRUE 99997
99989: LD_INT 30
99991: DOUBLE
99992: EQUAL
99993: IFTRUE 99997
99995: GO 100053
99997: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99998: LD_ADDR_VAR 0 9
100002: PUSH
100003: LD_VAR 0 59
100007: PUSH
100008: LD_VAR 0 60
100012: PUSH
100013: LD_VAR 0 61
100017: PUSH
100018: LD_VAR 0 62
100022: PUSH
100023: LD_VAR 0 63
100027: PUSH
100028: LD_VAR 0 64
100032: PUSH
100033: EMPTY
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: PUSH
100041: LD_VAR 0 4
100045: PUSH
100046: LD_INT 1
100048: PLUS
100049: ARRAY
100050: ST_TO_ADDR
100051: GO 100054
100053: POP
// temp_list2 = [ ] ;
100054: LD_ADDR_VAR 0 10
100058: PUSH
100059: EMPTY
100060: ST_TO_ADDR
// for i in temp_list do
100061: LD_ADDR_VAR 0 8
100065: PUSH
100066: LD_VAR 0 9
100070: PUSH
100071: FOR_IN
100072: IFFALSE 100124
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100074: LD_ADDR_VAR 0 10
100078: PUSH
100079: LD_VAR 0 10
100083: PUSH
100084: LD_VAR 0 8
100088: PUSH
100089: LD_INT 1
100091: ARRAY
100092: PUSH
100093: LD_VAR 0 2
100097: PLUS
100098: PUSH
100099: LD_VAR 0 8
100103: PUSH
100104: LD_INT 2
100106: ARRAY
100107: PUSH
100108: LD_VAR 0 3
100112: PLUS
100113: PUSH
100114: EMPTY
100115: LIST
100116: LIST
100117: PUSH
100118: EMPTY
100119: LIST
100120: ADD
100121: ST_TO_ADDR
100122: GO 100071
100124: POP
100125: POP
// result = temp_list2 ;
100126: LD_ADDR_VAR 0 7
100130: PUSH
100131: LD_VAR 0 10
100135: ST_TO_ADDR
// end ;
100136: LD_VAR 0 7
100140: RET
// export function EnemyInRange ( unit , dist ) ; begin
100141: LD_INT 0
100143: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
100144: LD_ADDR_VAR 0 3
100148: PUSH
100149: LD_VAR 0 1
100153: PPUSH
100154: CALL_OW 255
100158: PPUSH
100159: LD_VAR 0 1
100163: PPUSH
100164: CALL_OW 250
100168: PPUSH
100169: LD_VAR 0 1
100173: PPUSH
100174: CALL_OW 251
100178: PPUSH
100179: LD_VAR 0 2
100183: PPUSH
100184: CALL 73543 0 4
100188: PUSH
100189: LD_INT 4
100191: ARRAY
100192: ST_TO_ADDR
// end ;
100193: LD_VAR 0 3
100197: RET
// export function PlayerSeeMe ( unit ) ; begin
100198: LD_INT 0
100200: PPUSH
// result := See ( your_side , unit ) ;
100201: LD_ADDR_VAR 0 2
100205: PUSH
100206: LD_OWVAR 2
100210: PPUSH
100211: LD_VAR 0 1
100215: PPUSH
100216: CALL_OW 292
100220: ST_TO_ADDR
// end ;
100221: LD_VAR 0 2
100225: RET
// export function ReverseDir ( unit ) ; begin
100226: LD_INT 0
100228: PPUSH
// if not unit then
100229: LD_VAR 0 1
100233: NOT
100234: IFFALSE 100238
// exit ;
100236: GO 100261
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100238: LD_ADDR_VAR 0 2
100242: PUSH
100243: LD_VAR 0 1
100247: PPUSH
100248: CALL_OW 254
100252: PUSH
100253: LD_INT 3
100255: PLUS
100256: PUSH
100257: LD_INT 6
100259: MOD
100260: ST_TO_ADDR
// end ;
100261: LD_VAR 0 2
100265: RET
// export function ReverseArray ( array ) ; var i ; begin
100266: LD_INT 0
100268: PPUSH
100269: PPUSH
// if not array then
100270: LD_VAR 0 1
100274: NOT
100275: IFFALSE 100279
// exit ;
100277: GO 100334
// result := [ ] ;
100279: LD_ADDR_VAR 0 2
100283: PUSH
100284: EMPTY
100285: ST_TO_ADDR
// for i := array downto 1 do
100286: LD_ADDR_VAR 0 3
100290: PUSH
100291: DOUBLE
100292: LD_VAR 0 1
100296: INC
100297: ST_TO_ADDR
100298: LD_INT 1
100300: PUSH
100301: FOR_DOWNTO
100302: IFFALSE 100332
// result := Join ( result , array [ i ] ) ;
100304: LD_ADDR_VAR 0 2
100308: PUSH
100309: LD_VAR 0 2
100313: PPUSH
100314: LD_VAR 0 1
100318: PUSH
100319: LD_VAR 0 3
100323: ARRAY
100324: PPUSH
100325: CALL 104959 0 2
100329: ST_TO_ADDR
100330: GO 100301
100332: POP
100333: POP
// end ;
100334: LD_VAR 0 2
100338: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100339: LD_INT 0
100341: PPUSH
100342: PPUSH
100343: PPUSH
100344: PPUSH
100345: PPUSH
100346: PPUSH
// if not unit or not hexes then
100347: LD_VAR 0 1
100351: NOT
100352: PUSH
100353: LD_VAR 0 2
100357: NOT
100358: OR
100359: IFFALSE 100363
// exit ;
100361: GO 100486
// dist := 9999 ;
100363: LD_ADDR_VAR 0 5
100367: PUSH
100368: LD_INT 9999
100370: ST_TO_ADDR
// for i = 1 to hexes do
100371: LD_ADDR_VAR 0 4
100375: PUSH
100376: DOUBLE
100377: LD_INT 1
100379: DEC
100380: ST_TO_ADDR
100381: LD_VAR 0 2
100385: PUSH
100386: FOR_TO
100387: IFFALSE 100474
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100389: LD_ADDR_VAR 0 6
100393: PUSH
100394: LD_VAR 0 1
100398: PPUSH
100399: LD_VAR 0 2
100403: PUSH
100404: LD_VAR 0 4
100408: ARRAY
100409: PUSH
100410: LD_INT 1
100412: ARRAY
100413: PPUSH
100414: LD_VAR 0 2
100418: PUSH
100419: LD_VAR 0 4
100423: ARRAY
100424: PUSH
100425: LD_INT 2
100427: ARRAY
100428: PPUSH
100429: CALL_OW 297
100433: ST_TO_ADDR
// if tdist < dist then
100434: LD_VAR 0 6
100438: PUSH
100439: LD_VAR 0 5
100443: LESS
100444: IFFALSE 100472
// begin hex := hexes [ i ] ;
100446: LD_ADDR_VAR 0 8
100450: PUSH
100451: LD_VAR 0 2
100455: PUSH
100456: LD_VAR 0 4
100460: ARRAY
100461: ST_TO_ADDR
// dist := tdist ;
100462: LD_ADDR_VAR 0 5
100466: PUSH
100467: LD_VAR 0 6
100471: ST_TO_ADDR
// end ; end ;
100472: GO 100386
100474: POP
100475: POP
// result := hex ;
100476: LD_ADDR_VAR 0 3
100480: PUSH
100481: LD_VAR 0 8
100485: ST_TO_ADDR
// end ;
100486: LD_VAR 0 3
100490: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100491: LD_INT 0
100493: PPUSH
100494: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100495: LD_VAR 0 1
100499: NOT
100500: PUSH
100501: LD_VAR 0 1
100505: PUSH
100506: LD_INT 21
100508: PUSH
100509: LD_INT 2
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: PUSH
100516: LD_INT 23
100518: PUSH
100519: LD_INT 2
100521: PUSH
100522: EMPTY
100523: LIST
100524: LIST
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PPUSH
100530: CALL_OW 69
100534: IN
100535: NOT
100536: OR
100537: IFFALSE 100541
// exit ;
100539: GO 100588
// for i = 1 to 3 do
100541: LD_ADDR_VAR 0 3
100545: PUSH
100546: DOUBLE
100547: LD_INT 1
100549: DEC
100550: ST_TO_ADDR
100551: LD_INT 3
100553: PUSH
100554: FOR_TO
100555: IFFALSE 100586
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100557: LD_VAR 0 1
100561: PPUSH
100562: CALL_OW 250
100566: PPUSH
100567: LD_VAR 0 1
100571: PPUSH
100572: CALL_OW 251
100576: PPUSH
100577: LD_INT 1
100579: PPUSH
100580: CALL_OW 453
100584: GO 100554
100586: POP
100587: POP
// end ;
100588: LD_VAR 0 2
100592: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100593: LD_INT 0
100595: PPUSH
100596: PPUSH
100597: PPUSH
100598: PPUSH
100599: PPUSH
100600: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100601: LD_VAR 0 1
100605: NOT
100606: PUSH
100607: LD_VAR 0 2
100611: NOT
100612: OR
100613: PUSH
100614: LD_VAR 0 1
100618: PPUSH
100619: CALL_OW 314
100623: OR
100624: IFFALSE 100628
// exit ;
100626: GO 101069
// x := GetX ( enemy_unit ) ;
100628: LD_ADDR_VAR 0 7
100632: PUSH
100633: LD_VAR 0 2
100637: PPUSH
100638: CALL_OW 250
100642: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100643: LD_ADDR_VAR 0 8
100647: PUSH
100648: LD_VAR 0 2
100652: PPUSH
100653: CALL_OW 251
100657: ST_TO_ADDR
// if not x or not y then
100658: LD_VAR 0 7
100662: NOT
100663: PUSH
100664: LD_VAR 0 8
100668: NOT
100669: OR
100670: IFFALSE 100674
// exit ;
100672: GO 101069
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100674: LD_ADDR_VAR 0 6
100678: PUSH
100679: LD_VAR 0 7
100683: PPUSH
100684: LD_INT 0
100686: PPUSH
100687: LD_INT 4
100689: PPUSH
100690: CALL_OW 272
100694: PUSH
100695: LD_VAR 0 8
100699: PPUSH
100700: LD_INT 0
100702: PPUSH
100703: LD_INT 4
100705: PPUSH
100706: CALL_OW 273
100710: PUSH
100711: EMPTY
100712: LIST
100713: LIST
100714: PUSH
100715: LD_VAR 0 7
100719: PPUSH
100720: LD_INT 1
100722: PPUSH
100723: LD_INT 4
100725: PPUSH
100726: CALL_OW 272
100730: PUSH
100731: LD_VAR 0 8
100735: PPUSH
100736: LD_INT 1
100738: PPUSH
100739: LD_INT 4
100741: PPUSH
100742: CALL_OW 273
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: LD_VAR 0 7
100755: PPUSH
100756: LD_INT 2
100758: PPUSH
100759: LD_INT 4
100761: PPUSH
100762: CALL_OW 272
100766: PUSH
100767: LD_VAR 0 8
100771: PPUSH
100772: LD_INT 2
100774: PPUSH
100775: LD_INT 4
100777: PPUSH
100778: CALL_OW 273
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PUSH
100787: LD_VAR 0 7
100791: PPUSH
100792: LD_INT 3
100794: PPUSH
100795: LD_INT 4
100797: PPUSH
100798: CALL_OW 272
100802: PUSH
100803: LD_VAR 0 8
100807: PPUSH
100808: LD_INT 3
100810: PPUSH
100811: LD_INT 4
100813: PPUSH
100814: CALL_OW 273
100818: PUSH
100819: EMPTY
100820: LIST
100821: LIST
100822: PUSH
100823: LD_VAR 0 7
100827: PPUSH
100828: LD_INT 4
100830: PPUSH
100831: LD_INT 4
100833: PPUSH
100834: CALL_OW 272
100838: PUSH
100839: LD_VAR 0 8
100843: PPUSH
100844: LD_INT 4
100846: PPUSH
100847: LD_INT 4
100849: PPUSH
100850: CALL_OW 273
100854: PUSH
100855: EMPTY
100856: LIST
100857: LIST
100858: PUSH
100859: LD_VAR 0 7
100863: PPUSH
100864: LD_INT 5
100866: PPUSH
100867: LD_INT 4
100869: PPUSH
100870: CALL_OW 272
100874: PUSH
100875: LD_VAR 0 8
100879: PPUSH
100880: LD_INT 5
100882: PPUSH
100883: LD_INT 4
100885: PPUSH
100886: CALL_OW 273
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: PUSH
100895: EMPTY
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: LIST
100902: ST_TO_ADDR
// for i = tmp downto 1 do
100903: LD_ADDR_VAR 0 4
100907: PUSH
100908: DOUBLE
100909: LD_VAR 0 6
100913: INC
100914: ST_TO_ADDR
100915: LD_INT 1
100917: PUSH
100918: FOR_DOWNTO
100919: IFFALSE 101020
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100921: LD_VAR 0 6
100925: PUSH
100926: LD_VAR 0 4
100930: ARRAY
100931: PUSH
100932: LD_INT 1
100934: ARRAY
100935: PPUSH
100936: LD_VAR 0 6
100940: PUSH
100941: LD_VAR 0 4
100945: ARRAY
100946: PUSH
100947: LD_INT 2
100949: ARRAY
100950: PPUSH
100951: CALL_OW 488
100955: NOT
100956: PUSH
100957: LD_VAR 0 6
100961: PUSH
100962: LD_VAR 0 4
100966: ARRAY
100967: PUSH
100968: LD_INT 1
100970: ARRAY
100971: PPUSH
100972: LD_VAR 0 6
100976: PUSH
100977: LD_VAR 0 4
100981: ARRAY
100982: PUSH
100983: LD_INT 2
100985: ARRAY
100986: PPUSH
100987: CALL_OW 428
100991: PUSH
100992: LD_INT 0
100994: NONEQUAL
100995: OR
100996: IFFALSE 101018
// tmp := Delete ( tmp , i ) ;
100998: LD_ADDR_VAR 0 6
101002: PUSH
101003: LD_VAR 0 6
101007: PPUSH
101008: LD_VAR 0 4
101012: PPUSH
101013: CALL_OW 3
101017: ST_TO_ADDR
101018: GO 100918
101020: POP
101021: POP
// j := GetClosestHex ( unit , tmp ) ;
101022: LD_ADDR_VAR 0 5
101026: PUSH
101027: LD_VAR 0 1
101031: PPUSH
101032: LD_VAR 0 6
101036: PPUSH
101037: CALL 100339 0 2
101041: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101042: LD_VAR 0 1
101046: PPUSH
101047: LD_VAR 0 5
101051: PUSH
101052: LD_INT 1
101054: ARRAY
101055: PPUSH
101056: LD_VAR 0 5
101060: PUSH
101061: LD_INT 2
101063: ARRAY
101064: PPUSH
101065: CALL_OW 111
// end ;
101069: LD_VAR 0 3
101073: RET
// export function PrepareApemanSoldier ( ) ; begin
101074: LD_INT 0
101076: PPUSH
// uc_nation := 0 ;
101077: LD_ADDR_OWVAR 21
101081: PUSH
101082: LD_INT 0
101084: ST_TO_ADDR
// hc_sex := sex_male ;
101085: LD_ADDR_OWVAR 27
101089: PUSH
101090: LD_INT 1
101092: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101093: LD_ADDR_OWVAR 28
101097: PUSH
101098: LD_INT 15
101100: ST_TO_ADDR
// hc_gallery :=  ;
101101: LD_ADDR_OWVAR 33
101105: PUSH
101106: LD_STRING 
101108: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101109: LD_ADDR_OWVAR 31
101113: PUSH
101114: LD_INT 0
101116: PPUSH
101117: LD_INT 3
101119: PPUSH
101120: CALL_OW 12
101124: PUSH
101125: LD_INT 0
101127: PPUSH
101128: LD_INT 3
101130: PPUSH
101131: CALL_OW 12
101135: PUSH
101136: LD_INT 0
101138: PUSH
101139: LD_INT 0
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: LIST
101146: LIST
101147: ST_TO_ADDR
// end ;
101148: LD_VAR 0 1
101152: RET
// export function PrepareApemanEngineer ( ) ; begin
101153: LD_INT 0
101155: PPUSH
// uc_nation := 0 ;
101156: LD_ADDR_OWVAR 21
101160: PUSH
101161: LD_INT 0
101163: ST_TO_ADDR
// hc_sex := sex_male ;
101164: LD_ADDR_OWVAR 27
101168: PUSH
101169: LD_INT 1
101171: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
101172: LD_ADDR_OWVAR 28
101176: PUSH
101177: LD_INT 16
101179: ST_TO_ADDR
// hc_gallery :=  ;
101180: LD_ADDR_OWVAR 33
101184: PUSH
101185: LD_STRING 
101187: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101188: LD_ADDR_OWVAR 31
101192: PUSH
101193: LD_INT 0
101195: PPUSH
101196: LD_INT 3
101198: PPUSH
101199: CALL_OW 12
101203: PUSH
101204: LD_INT 0
101206: PPUSH
101207: LD_INT 3
101209: PPUSH
101210: CALL_OW 12
101214: PUSH
101215: LD_INT 0
101217: PUSH
101218: LD_INT 0
101220: PUSH
101221: EMPTY
101222: LIST
101223: LIST
101224: LIST
101225: LIST
101226: ST_TO_ADDR
// end ;
101227: LD_VAR 0 1
101231: RET
// export function PrepareApeman ( agressivity ) ; begin
101232: LD_INT 0
101234: PPUSH
// uc_side := 0 ;
101235: LD_ADDR_OWVAR 20
101239: PUSH
101240: LD_INT 0
101242: ST_TO_ADDR
// uc_nation := 0 ;
101243: LD_ADDR_OWVAR 21
101247: PUSH
101248: LD_INT 0
101250: ST_TO_ADDR
// hc_sex := sex_male ;
101251: LD_ADDR_OWVAR 27
101255: PUSH
101256: LD_INT 1
101258: ST_TO_ADDR
// hc_class := class_apeman ;
101259: LD_ADDR_OWVAR 28
101263: PUSH
101264: LD_INT 12
101266: ST_TO_ADDR
// hc_gallery :=  ;
101267: LD_ADDR_OWVAR 33
101271: PUSH
101272: LD_STRING 
101274: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101275: LD_ADDR_OWVAR 35
101279: PUSH
101280: LD_VAR 0 1
101284: NEG
101285: PPUSH
101286: LD_VAR 0 1
101290: PPUSH
101291: CALL_OW 12
101295: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101296: LD_ADDR_OWVAR 31
101300: PUSH
101301: LD_INT 0
101303: PPUSH
101304: LD_INT 3
101306: PPUSH
101307: CALL_OW 12
101311: PUSH
101312: LD_INT 0
101314: PPUSH
101315: LD_INT 3
101317: PPUSH
101318: CALL_OW 12
101322: PUSH
101323: LD_INT 0
101325: PUSH
101326: LD_INT 0
101328: PUSH
101329: EMPTY
101330: LIST
101331: LIST
101332: LIST
101333: LIST
101334: ST_TO_ADDR
// end ;
101335: LD_VAR 0 2
101339: RET
// export function PrepareTiger ( agressivity ) ; begin
101340: LD_INT 0
101342: PPUSH
// uc_side := 0 ;
101343: LD_ADDR_OWVAR 20
101347: PUSH
101348: LD_INT 0
101350: ST_TO_ADDR
// uc_nation := 0 ;
101351: LD_ADDR_OWVAR 21
101355: PUSH
101356: LD_INT 0
101358: ST_TO_ADDR
// hc_class := class_tiger ;
101359: LD_ADDR_OWVAR 28
101363: PUSH
101364: LD_INT 14
101366: ST_TO_ADDR
// hc_gallery :=  ;
101367: LD_ADDR_OWVAR 33
101371: PUSH
101372: LD_STRING 
101374: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101375: LD_ADDR_OWVAR 35
101379: PUSH
101380: LD_VAR 0 1
101384: NEG
101385: PPUSH
101386: LD_VAR 0 1
101390: PPUSH
101391: CALL_OW 12
101395: ST_TO_ADDR
// end ;
101396: LD_VAR 0 2
101400: RET
// export function PrepareEnchidna ( ) ; begin
101401: LD_INT 0
101403: PPUSH
// uc_side := 0 ;
101404: LD_ADDR_OWVAR 20
101408: PUSH
101409: LD_INT 0
101411: ST_TO_ADDR
// uc_nation := 0 ;
101412: LD_ADDR_OWVAR 21
101416: PUSH
101417: LD_INT 0
101419: ST_TO_ADDR
// hc_class := class_baggie ;
101420: LD_ADDR_OWVAR 28
101424: PUSH
101425: LD_INT 13
101427: ST_TO_ADDR
// hc_gallery :=  ;
101428: LD_ADDR_OWVAR 33
101432: PUSH
101433: LD_STRING 
101435: ST_TO_ADDR
// end ;
101436: LD_VAR 0 1
101440: RET
// export function PrepareFrog ( ) ; begin
101441: LD_INT 0
101443: PPUSH
// uc_side := 0 ;
101444: LD_ADDR_OWVAR 20
101448: PUSH
101449: LD_INT 0
101451: ST_TO_ADDR
// uc_nation := 0 ;
101452: LD_ADDR_OWVAR 21
101456: PUSH
101457: LD_INT 0
101459: ST_TO_ADDR
// hc_class := class_frog ;
101460: LD_ADDR_OWVAR 28
101464: PUSH
101465: LD_INT 19
101467: ST_TO_ADDR
// hc_gallery :=  ;
101468: LD_ADDR_OWVAR 33
101472: PUSH
101473: LD_STRING 
101475: ST_TO_ADDR
// end ;
101476: LD_VAR 0 1
101480: RET
// export function PrepareFish ( ) ; begin
101481: LD_INT 0
101483: PPUSH
// uc_side := 0 ;
101484: LD_ADDR_OWVAR 20
101488: PUSH
101489: LD_INT 0
101491: ST_TO_ADDR
// uc_nation := 0 ;
101492: LD_ADDR_OWVAR 21
101496: PUSH
101497: LD_INT 0
101499: ST_TO_ADDR
// hc_class := class_fish ;
101500: LD_ADDR_OWVAR 28
101504: PUSH
101505: LD_INT 20
101507: ST_TO_ADDR
// hc_gallery :=  ;
101508: LD_ADDR_OWVAR 33
101512: PUSH
101513: LD_STRING 
101515: ST_TO_ADDR
// end ;
101516: LD_VAR 0 1
101520: RET
// export function PrepareBird ( ) ; begin
101521: LD_INT 0
101523: PPUSH
// uc_side := 0 ;
101524: LD_ADDR_OWVAR 20
101528: PUSH
101529: LD_INT 0
101531: ST_TO_ADDR
// uc_nation := 0 ;
101532: LD_ADDR_OWVAR 21
101536: PUSH
101537: LD_INT 0
101539: ST_TO_ADDR
// hc_class := class_phororhacos ;
101540: LD_ADDR_OWVAR 28
101544: PUSH
101545: LD_INT 18
101547: ST_TO_ADDR
// hc_gallery :=  ;
101548: LD_ADDR_OWVAR 33
101552: PUSH
101553: LD_STRING 
101555: ST_TO_ADDR
// end ;
101556: LD_VAR 0 1
101560: RET
// export function PrepareHorse ( ) ; begin
101561: LD_INT 0
101563: PPUSH
// uc_side := 0 ;
101564: LD_ADDR_OWVAR 20
101568: PUSH
101569: LD_INT 0
101571: ST_TO_ADDR
// uc_nation := 0 ;
101572: LD_ADDR_OWVAR 21
101576: PUSH
101577: LD_INT 0
101579: ST_TO_ADDR
// hc_class := class_horse ;
101580: LD_ADDR_OWVAR 28
101584: PUSH
101585: LD_INT 21
101587: ST_TO_ADDR
// hc_gallery :=  ;
101588: LD_ADDR_OWVAR 33
101592: PUSH
101593: LD_STRING 
101595: ST_TO_ADDR
// end ;
101596: LD_VAR 0 1
101600: RET
// export function PrepareMastodont ( ) ; begin
101601: LD_INT 0
101603: PPUSH
// uc_side := 0 ;
101604: LD_ADDR_OWVAR 20
101608: PUSH
101609: LD_INT 0
101611: ST_TO_ADDR
// uc_nation := 0 ;
101612: LD_ADDR_OWVAR 21
101616: PUSH
101617: LD_INT 0
101619: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101620: LD_ADDR_OWVAR 37
101624: PUSH
101625: LD_INT 31
101627: ST_TO_ADDR
// vc_control := control_rider ;
101628: LD_ADDR_OWVAR 38
101632: PUSH
101633: LD_INT 4
101635: ST_TO_ADDR
// end ;
101636: LD_VAR 0 1
101640: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101641: LD_INT 0
101643: PPUSH
101644: PPUSH
101645: PPUSH
// uc_side = 0 ;
101646: LD_ADDR_OWVAR 20
101650: PUSH
101651: LD_INT 0
101653: ST_TO_ADDR
// uc_nation = 0 ;
101654: LD_ADDR_OWVAR 21
101658: PUSH
101659: LD_INT 0
101661: ST_TO_ADDR
// InitHc_All ( ) ;
101662: CALL_OW 584
// InitVc ;
101666: CALL_OW 20
// if mastodonts then
101670: LD_VAR 0 6
101674: IFFALSE 101741
// for i = 1 to mastodonts do
101676: LD_ADDR_VAR 0 11
101680: PUSH
101681: DOUBLE
101682: LD_INT 1
101684: DEC
101685: ST_TO_ADDR
101686: LD_VAR 0 6
101690: PUSH
101691: FOR_TO
101692: IFFALSE 101739
// begin vc_chassis := 31 ;
101694: LD_ADDR_OWVAR 37
101698: PUSH
101699: LD_INT 31
101701: ST_TO_ADDR
// vc_control := control_rider ;
101702: LD_ADDR_OWVAR 38
101706: PUSH
101707: LD_INT 4
101709: ST_TO_ADDR
// animal := CreateVehicle ;
101710: LD_ADDR_VAR 0 12
101714: PUSH
101715: CALL_OW 45
101719: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101720: LD_VAR 0 12
101724: PPUSH
101725: LD_VAR 0 8
101729: PPUSH
101730: LD_INT 0
101732: PPUSH
101733: CALL 103876 0 3
// end ;
101737: GO 101691
101739: POP
101740: POP
// if horses then
101741: LD_VAR 0 5
101745: IFFALSE 101812
// for i = 1 to horses do
101747: LD_ADDR_VAR 0 11
101751: PUSH
101752: DOUBLE
101753: LD_INT 1
101755: DEC
101756: ST_TO_ADDR
101757: LD_VAR 0 5
101761: PUSH
101762: FOR_TO
101763: IFFALSE 101810
// begin hc_class := 21 ;
101765: LD_ADDR_OWVAR 28
101769: PUSH
101770: LD_INT 21
101772: ST_TO_ADDR
// hc_gallery :=  ;
101773: LD_ADDR_OWVAR 33
101777: PUSH
101778: LD_STRING 
101780: ST_TO_ADDR
// animal := CreateHuman ;
101781: LD_ADDR_VAR 0 12
101785: PUSH
101786: CALL_OW 44
101790: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101791: LD_VAR 0 12
101795: PPUSH
101796: LD_VAR 0 8
101800: PPUSH
101801: LD_INT 0
101803: PPUSH
101804: CALL 103876 0 3
// end ;
101808: GO 101762
101810: POP
101811: POP
// if birds then
101812: LD_VAR 0 1
101816: IFFALSE 101883
// for i = 1 to birds do
101818: LD_ADDR_VAR 0 11
101822: PUSH
101823: DOUBLE
101824: LD_INT 1
101826: DEC
101827: ST_TO_ADDR
101828: LD_VAR 0 1
101832: PUSH
101833: FOR_TO
101834: IFFALSE 101881
// begin hc_class = 18 ;
101836: LD_ADDR_OWVAR 28
101840: PUSH
101841: LD_INT 18
101843: ST_TO_ADDR
// hc_gallery =  ;
101844: LD_ADDR_OWVAR 33
101848: PUSH
101849: LD_STRING 
101851: ST_TO_ADDR
// animal := CreateHuman ;
101852: LD_ADDR_VAR 0 12
101856: PUSH
101857: CALL_OW 44
101861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101862: LD_VAR 0 12
101866: PPUSH
101867: LD_VAR 0 8
101871: PPUSH
101872: LD_INT 0
101874: PPUSH
101875: CALL 103876 0 3
// end ;
101879: GO 101833
101881: POP
101882: POP
// if tigers then
101883: LD_VAR 0 2
101887: IFFALSE 101971
// for i = 1 to tigers do
101889: LD_ADDR_VAR 0 11
101893: PUSH
101894: DOUBLE
101895: LD_INT 1
101897: DEC
101898: ST_TO_ADDR
101899: LD_VAR 0 2
101903: PUSH
101904: FOR_TO
101905: IFFALSE 101969
// begin hc_class = class_tiger ;
101907: LD_ADDR_OWVAR 28
101911: PUSH
101912: LD_INT 14
101914: ST_TO_ADDR
// hc_gallery =  ;
101915: LD_ADDR_OWVAR 33
101919: PUSH
101920: LD_STRING 
101922: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101923: LD_ADDR_OWVAR 35
101927: PUSH
101928: LD_INT 7
101930: NEG
101931: PPUSH
101932: LD_INT 7
101934: PPUSH
101935: CALL_OW 12
101939: ST_TO_ADDR
// animal := CreateHuman ;
101940: LD_ADDR_VAR 0 12
101944: PUSH
101945: CALL_OW 44
101949: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101950: LD_VAR 0 12
101954: PPUSH
101955: LD_VAR 0 8
101959: PPUSH
101960: LD_INT 0
101962: PPUSH
101963: CALL 103876 0 3
// end ;
101967: GO 101904
101969: POP
101970: POP
// if apemans then
101971: LD_VAR 0 3
101975: IFFALSE 102098
// for i = 1 to apemans do
101977: LD_ADDR_VAR 0 11
101981: PUSH
101982: DOUBLE
101983: LD_INT 1
101985: DEC
101986: ST_TO_ADDR
101987: LD_VAR 0 3
101991: PUSH
101992: FOR_TO
101993: IFFALSE 102096
// begin hc_class = class_apeman ;
101995: LD_ADDR_OWVAR 28
101999: PUSH
102000: LD_INT 12
102002: ST_TO_ADDR
// hc_gallery =  ;
102003: LD_ADDR_OWVAR 33
102007: PUSH
102008: LD_STRING 
102010: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102011: LD_ADDR_OWVAR 35
102015: PUSH
102016: LD_INT 2
102018: NEG
102019: PPUSH
102020: LD_INT 2
102022: PPUSH
102023: CALL_OW 12
102027: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102028: LD_ADDR_OWVAR 31
102032: PUSH
102033: LD_INT 1
102035: PPUSH
102036: LD_INT 3
102038: PPUSH
102039: CALL_OW 12
102043: PUSH
102044: LD_INT 1
102046: PPUSH
102047: LD_INT 3
102049: PPUSH
102050: CALL_OW 12
102054: PUSH
102055: LD_INT 0
102057: PUSH
102058: LD_INT 0
102060: PUSH
102061: EMPTY
102062: LIST
102063: LIST
102064: LIST
102065: LIST
102066: ST_TO_ADDR
// animal := CreateHuman ;
102067: LD_ADDR_VAR 0 12
102071: PUSH
102072: CALL_OW 44
102076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102077: LD_VAR 0 12
102081: PPUSH
102082: LD_VAR 0 8
102086: PPUSH
102087: LD_INT 0
102089: PPUSH
102090: CALL 103876 0 3
// end ;
102094: GO 101992
102096: POP
102097: POP
// if enchidnas then
102098: LD_VAR 0 4
102102: IFFALSE 102169
// for i = 1 to enchidnas do
102104: LD_ADDR_VAR 0 11
102108: PUSH
102109: DOUBLE
102110: LD_INT 1
102112: DEC
102113: ST_TO_ADDR
102114: LD_VAR 0 4
102118: PUSH
102119: FOR_TO
102120: IFFALSE 102167
// begin hc_class = 13 ;
102122: LD_ADDR_OWVAR 28
102126: PUSH
102127: LD_INT 13
102129: ST_TO_ADDR
// hc_gallery =  ;
102130: LD_ADDR_OWVAR 33
102134: PUSH
102135: LD_STRING 
102137: ST_TO_ADDR
// animal := CreateHuman ;
102138: LD_ADDR_VAR 0 12
102142: PUSH
102143: CALL_OW 44
102147: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102148: LD_VAR 0 12
102152: PPUSH
102153: LD_VAR 0 8
102157: PPUSH
102158: LD_INT 0
102160: PPUSH
102161: CALL 103876 0 3
// end ;
102165: GO 102119
102167: POP
102168: POP
// if fishes then
102169: LD_VAR 0 7
102173: IFFALSE 102240
// for i = 1 to fishes do
102175: LD_ADDR_VAR 0 11
102179: PUSH
102180: DOUBLE
102181: LD_INT 1
102183: DEC
102184: ST_TO_ADDR
102185: LD_VAR 0 7
102189: PUSH
102190: FOR_TO
102191: IFFALSE 102238
// begin hc_class = 20 ;
102193: LD_ADDR_OWVAR 28
102197: PUSH
102198: LD_INT 20
102200: ST_TO_ADDR
// hc_gallery =  ;
102201: LD_ADDR_OWVAR 33
102205: PUSH
102206: LD_STRING 
102208: ST_TO_ADDR
// animal := CreateHuman ;
102209: LD_ADDR_VAR 0 12
102213: PUSH
102214: CALL_OW 44
102218: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102219: LD_VAR 0 12
102223: PPUSH
102224: LD_VAR 0 9
102228: PPUSH
102229: LD_INT 0
102231: PPUSH
102232: CALL 103876 0 3
// end ;
102236: GO 102190
102238: POP
102239: POP
// end ;
102240: LD_VAR 0 10
102244: RET
// export function WantHeal ( sci , unit ) ; begin
102245: LD_INT 0
102247: PPUSH
// if GetTaskList ( sci ) > 0 then
102248: LD_VAR 0 1
102252: PPUSH
102253: CALL_OW 437
102257: PUSH
102258: LD_INT 0
102260: GREATER
102261: IFFALSE 102331
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102263: LD_VAR 0 1
102267: PPUSH
102268: CALL_OW 437
102272: PUSH
102273: LD_INT 1
102275: ARRAY
102276: PUSH
102277: LD_INT 1
102279: ARRAY
102280: PUSH
102281: LD_STRING l
102283: EQUAL
102284: PUSH
102285: LD_VAR 0 1
102289: PPUSH
102290: CALL_OW 437
102294: PUSH
102295: LD_INT 1
102297: ARRAY
102298: PUSH
102299: LD_INT 4
102301: ARRAY
102302: PUSH
102303: LD_VAR 0 2
102307: EQUAL
102308: AND
102309: IFFALSE 102321
// result := true else
102311: LD_ADDR_VAR 0 3
102315: PUSH
102316: LD_INT 1
102318: ST_TO_ADDR
102319: GO 102329
// result := false ;
102321: LD_ADDR_VAR 0 3
102325: PUSH
102326: LD_INT 0
102328: ST_TO_ADDR
// end else
102329: GO 102339
// result := false ;
102331: LD_ADDR_VAR 0 3
102335: PUSH
102336: LD_INT 0
102338: ST_TO_ADDR
// end ;
102339: LD_VAR 0 3
102343: RET
// export function HealTarget ( sci ) ; begin
102344: LD_INT 0
102346: PPUSH
// if not sci then
102347: LD_VAR 0 1
102351: NOT
102352: IFFALSE 102356
// exit ;
102354: GO 102421
// result := 0 ;
102356: LD_ADDR_VAR 0 2
102360: PUSH
102361: LD_INT 0
102363: ST_TO_ADDR
// if GetTaskList ( sci ) then
102364: LD_VAR 0 1
102368: PPUSH
102369: CALL_OW 437
102373: IFFALSE 102421
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102375: LD_VAR 0 1
102379: PPUSH
102380: CALL_OW 437
102384: PUSH
102385: LD_INT 1
102387: ARRAY
102388: PUSH
102389: LD_INT 1
102391: ARRAY
102392: PUSH
102393: LD_STRING l
102395: EQUAL
102396: IFFALSE 102421
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102398: LD_ADDR_VAR 0 2
102402: PUSH
102403: LD_VAR 0 1
102407: PPUSH
102408: CALL_OW 437
102412: PUSH
102413: LD_INT 1
102415: ARRAY
102416: PUSH
102417: LD_INT 4
102419: ARRAY
102420: ST_TO_ADDR
// end ;
102421: LD_VAR 0 2
102425: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102426: LD_INT 0
102428: PPUSH
102429: PPUSH
102430: PPUSH
102431: PPUSH
// if not base_units then
102432: LD_VAR 0 1
102436: NOT
102437: IFFALSE 102441
// exit ;
102439: GO 102528
// result := false ;
102441: LD_ADDR_VAR 0 2
102445: PUSH
102446: LD_INT 0
102448: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102449: LD_ADDR_VAR 0 5
102453: PUSH
102454: LD_VAR 0 1
102458: PPUSH
102459: LD_INT 21
102461: PUSH
102462: LD_INT 3
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: PPUSH
102469: CALL_OW 72
102473: ST_TO_ADDR
// if not tmp then
102474: LD_VAR 0 5
102478: NOT
102479: IFFALSE 102483
// exit ;
102481: GO 102528
// for i in tmp do
102483: LD_ADDR_VAR 0 3
102487: PUSH
102488: LD_VAR 0 5
102492: PUSH
102493: FOR_IN
102494: IFFALSE 102526
// begin result := EnemyInRange ( i , 22 ) ;
102496: LD_ADDR_VAR 0 2
102500: PUSH
102501: LD_VAR 0 3
102505: PPUSH
102506: LD_INT 22
102508: PPUSH
102509: CALL 100141 0 2
102513: ST_TO_ADDR
// if result then
102514: LD_VAR 0 2
102518: IFFALSE 102524
// exit ;
102520: POP
102521: POP
102522: GO 102528
// end ;
102524: GO 102493
102526: POP
102527: POP
// end ;
102528: LD_VAR 0 2
102532: RET
// export function FilterByTag ( units , tag ) ; begin
102533: LD_INT 0
102535: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102536: LD_ADDR_VAR 0 3
102540: PUSH
102541: LD_VAR 0 1
102545: PPUSH
102546: LD_INT 120
102548: PUSH
102549: LD_VAR 0 2
102553: PUSH
102554: EMPTY
102555: LIST
102556: LIST
102557: PPUSH
102558: CALL_OW 72
102562: ST_TO_ADDR
// end ;
102563: LD_VAR 0 3
102567: RET
// export function IsDriver ( un ) ; begin
102568: LD_INT 0
102570: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102571: LD_ADDR_VAR 0 2
102575: PUSH
102576: LD_VAR 0 1
102580: PUSH
102581: LD_INT 55
102583: PUSH
102584: EMPTY
102585: LIST
102586: PPUSH
102587: CALL_OW 69
102591: IN
102592: ST_TO_ADDR
// end ;
102593: LD_VAR 0 2
102597: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102598: LD_INT 0
102600: PPUSH
102601: PPUSH
// list := [ ] ;
102602: LD_ADDR_VAR 0 5
102606: PUSH
102607: EMPTY
102608: ST_TO_ADDR
// case d of 0 :
102609: LD_VAR 0 3
102613: PUSH
102614: LD_INT 0
102616: DOUBLE
102617: EQUAL
102618: IFTRUE 102622
102620: GO 102755
102622: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102623: LD_ADDR_VAR 0 5
102627: PUSH
102628: LD_VAR 0 1
102632: PUSH
102633: LD_INT 4
102635: MINUS
102636: PUSH
102637: LD_VAR 0 2
102641: PUSH
102642: LD_INT 4
102644: MINUS
102645: PUSH
102646: LD_INT 2
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: LIST
102653: PUSH
102654: LD_VAR 0 1
102658: PUSH
102659: LD_INT 3
102661: MINUS
102662: PUSH
102663: LD_VAR 0 2
102667: PUSH
102668: LD_INT 1
102670: PUSH
102671: EMPTY
102672: LIST
102673: LIST
102674: LIST
102675: PUSH
102676: LD_VAR 0 1
102680: PUSH
102681: LD_INT 4
102683: PLUS
102684: PUSH
102685: LD_VAR 0 2
102689: PUSH
102690: LD_INT 4
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: LIST
102697: PUSH
102698: LD_VAR 0 1
102702: PUSH
102703: LD_INT 3
102705: PLUS
102706: PUSH
102707: LD_VAR 0 2
102711: PUSH
102712: LD_INT 3
102714: PLUS
102715: PUSH
102716: LD_INT 5
102718: PUSH
102719: EMPTY
102720: LIST
102721: LIST
102722: LIST
102723: PUSH
102724: LD_VAR 0 1
102728: PUSH
102729: LD_VAR 0 2
102733: PUSH
102734: LD_INT 4
102736: PLUS
102737: PUSH
102738: LD_INT 0
102740: PUSH
102741: EMPTY
102742: LIST
102743: LIST
102744: LIST
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: LIST
102750: LIST
102751: LIST
102752: ST_TO_ADDR
// end ; 1 :
102753: GO 103453
102755: LD_INT 1
102757: DOUBLE
102758: EQUAL
102759: IFTRUE 102763
102761: GO 102896
102763: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102764: LD_ADDR_VAR 0 5
102768: PUSH
102769: LD_VAR 0 1
102773: PUSH
102774: LD_VAR 0 2
102778: PUSH
102779: LD_INT 4
102781: MINUS
102782: PUSH
102783: LD_INT 3
102785: PUSH
102786: EMPTY
102787: LIST
102788: LIST
102789: LIST
102790: PUSH
102791: LD_VAR 0 1
102795: PUSH
102796: LD_INT 3
102798: MINUS
102799: PUSH
102800: LD_VAR 0 2
102804: PUSH
102805: LD_INT 3
102807: MINUS
102808: PUSH
102809: LD_INT 2
102811: PUSH
102812: EMPTY
102813: LIST
102814: LIST
102815: LIST
102816: PUSH
102817: LD_VAR 0 1
102821: PUSH
102822: LD_INT 4
102824: MINUS
102825: PUSH
102826: LD_VAR 0 2
102830: PUSH
102831: LD_INT 1
102833: PUSH
102834: EMPTY
102835: LIST
102836: LIST
102837: LIST
102838: PUSH
102839: LD_VAR 0 1
102843: PUSH
102844: LD_VAR 0 2
102848: PUSH
102849: LD_INT 3
102851: PLUS
102852: PUSH
102853: LD_INT 0
102855: PUSH
102856: EMPTY
102857: LIST
102858: LIST
102859: LIST
102860: PUSH
102861: LD_VAR 0 1
102865: PUSH
102866: LD_INT 4
102868: PLUS
102869: PUSH
102870: LD_VAR 0 2
102874: PUSH
102875: LD_INT 4
102877: PLUS
102878: PUSH
102879: LD_INT 5
102881: PUSH
102882: EMPTY
102883: LIST
102884: LIST
102885: LIST
102886: PUSH
102887: EMPTY
102888: LIST
102889: LIST
102890: LIST
102891: LIST
102892: LIST
102893: ST_TO_ADDR
// end ; 2 :
102894: GO 103453
102896: LD_INT 2
102898: DOUBLE
102899: EQUAL
102900: IFTRUE 102904
102902: GO 103033
102904: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102905: LD_ADDR_VAR 0 5
102909: PUSH
102910: LD_VAR 0 1
102914: PUSH
102915: LD_VAR 0 2
102919: PUSH
102920: LD_INT 3
102922: MINUS
102923: PUSH
102924: LD_INT 3
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: LIST
102931: PUSH
102932: LD_VAR 0 1
102936: PUSH
102937: LD_INT 4
102939: PLUS
102940: PUSH
102941: LD_VAR 0 2
102945: PUSH
102946: LD_INT 4
102948: PUSH
102949: EMPTY
102950: LIST
102951: LIST
102952: LIST
102953: PUSH
102954: LD_VAR 0 1
102958: PUSH
102959: LD_VAR 0 2
102963: PUSH
102964: LD_INT 4
102966: PLUS
102967: PUSH
102968: LD_INT 0
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: LIST
102975: PUSH
102976: LD_VAR 0 1
102980: PUSH
102981: LD_INT 3
102983: MINUS
102984: PUSH
102985: LD_VAR 0 2
102989: PUSH
102990: LD_INT 1
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: LIST
102997: PUSH
102998: LD_VAR 0 1
103002: PUSH
103003: LD_INT 4
103005: MINUS
103006: PUSH
103007: LD_VAR 0 2
103011: PUSH
103012: LD_INT 4
103014: MINUS
103015: PUSH
103016: LD_INT 2
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: LIST
103023: PUSH
103024: EMPTY
103025: LIST
103026: LIST
103027: LIST
103028: LIST
103029: LIST
103030: ST_TO_ADDR
// end ; 3 :
103031: GO 103453
103033: LD_INT 3
103035: DOUBLE
103036: EQUAL
103037: IFTRUE 103041
103039: GO 103174
103041: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103042: LD_ADDR_VAR 0 5
103046: PUSH
103047: LD_VAR 0 1
103051: PUSH
103052: LD_INT 3
103054: PLUS
103055: PUSH
103056: LD_VAR 0 2
103060: PUSH
103061: LD_INT 4
103063: PUSH
103064: EMPTY
103065: LIST
103066: LIST
103067: LIST
103068: PUSH
103069: LD_VAR 0 1
103073: PUSH
103074: LD_INT 4
103076: PLUS
103077: PUSH
103078: LD_VAR 0 2
103082: PUSH
103083: LD_INT 4
103085: PLUS
103086: PUSH
103087: LD_INT 5
103089: PUSH
103090: EMPTY
103091: LIST
103092: LIST
103093: LIST
103094: PUSH
103095: LD_VAR 0 1
103099: PUSH
103100: LD_INT 4
103102: MINUS
103103: PUSH
103104: LD_VAR 0 2
103108: PUSH
103109: LD_INT 1
103111: PUSH
103112: EMPTY
103113: LIST
103114: LIST
103115: LIST
103116: PUSH
103117: LD_VAR 0 1
103121: PUSH
103122: LD_VAR 0 2
103126: PUSH
103127: LD_INT 4
103129: MINUS
103130: PUSH
103131: LD_INT 3
103133: PUSH
103134: EMPTY
103135: LIST
103136: LIST
103137: LIST
103138: PUSH
103139: LD_VAR 0 1
103143: PUSH
103144: LD_INT 3
103146: MINUS
103147: PUSH
103148: LD_VAR 0 2
103152: PUSH
103153: LD_INT 3
103155: MINUS
103156: PUSH
103157: LD_INT 2
103159: PUSH
103160: EMPTY
103161: LIST
103162: LIST
103163: LIST
103164: PUSH
103165: EMPTY
103166: LIST
103167: LIST
103168: LIST
103169: LIST
103170: LIST
103171: ST_TO_ADDR
// end ; 4 :
103172: GO 103453
103174: LD_INT 4
103176: DOUBLE
103177: EQUAL
103178: IFTRUE 103182
103180: GO 103315
103182: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103183: LD_ADDR_VAR 0 5
103187: PUSH
103188: LD_VAR 0 1
103192: PUSH
103193: LD_VAR 0 2
103197: PUSH
103198: LD_INT 4
103200: PLUS
103201: PUSH
103202: LD_INT 0
103204: PUSH
103205: EMPTY
103206: LIST
103207: LIST
103208: LIST
103209: PUSH
103210: LD_VAR 0 1
103214: PUSH
103215: LD_INT 3
103217: PLUS
103218: PUSH
103219: LD_VAR 0 2
103223: PUSH
103224: LD_INT 3
103226: PLUS
103227: PUSH
103228: LD_INT 5
103230: PUSH
103231: EMPTY
103232: LIST
103233: LIST
103234: LIST
103235: PUSH
103236: LD_VAR 0 1
103240: PUSH
103241: LD_INT 4
103243: PLUS
103244: PUSH
103245: LD_VAR 0 2
103249: PUSH
103250: LD_INT 4
103252: PUSH
103253: EMPTY
103254: LIST
103255: LIST
103256: LIST
103257: PUSH
103258: LD_VAR 0 1
103262: PUSH
103263: LD_VAR 0 2
103267: PUSH
103268: LD_INT 3
103270: MINUS
103271: PUSH
103272: LD_INT 3
103274: PUSH
103275: EMPTY
103276: LIST
103277: LIST
103278: LIST
103279: PUSH
103280: LD_VAR 0 1
103284: PUSH
103285: LD_INT 4
103287: MINUS
103288: PUSH
103289: LD_VAR 0 2
103293: PUSH
103294: LD_INT 4
103296: MINUS
103297: PUSH
103298: LD_INT 2
103300: PUSH
103301: EMPTY
103302: LIST
103303: LIST
103304: LIST
103305: PUSH
103306: EMPTY
103307: LIST
103308: LIST
103309: LIST
103310: LIST
103311: LIST
103312: ST_TO_ADDR
// end ; 5 :
103313: GO 103453
103315: LD_INT 5
103317: DOUBLE
103318: EQUAL
103319: IFTRUE 103323
103321: GO 103452
103323: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103324: LD_ADDR_VAR 0 5
103328: PUSH
103329: LD_VAR 0 1
103333: PUSH
103334: LD_INT 4
103336: MINUS
103337: PUSH
103338: LD_VAR 0 2
103342: PUSH
103343: LD_INT 1
103345: PUSH
103346: EMPTY
103347: LIST
103348: LIST
103349: LIST
103350: PUSH
103351: LD_VAR 0 1
103355: PUSH
103356: LD_VAR 0 2
103360: PUSH
103361: LD_INT 4
103363: MINUS
103364: PUSH
103365: LD_INT 3
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: LIST
103372: PUSH
103373: LD_VAR 0 1
103377: PUSH
103378: LD_INT 4
103380: PLUS
103381: PUSH
103382: LD_VAR 0 2
103386: PUSH
103387: LD_INT 4
103389: PLUS
103390: PUSH
103391: LD_INT 5
103393: PUSH
103394: EMPTY
103395: LIST
103396: LIST
103397: LIST
103398: PUSH
103399: LD_VAR 0 1
103403: PUSH
103404: LD_INT 3
103406: PLUS
103407: PUSH
103408: LD_VAR 0 2
103412: PUSH
103413: LD_INT 4
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: LIST
103420: PUSH
103421: LD_VAR 0 1
103425: PUSH
103426: LD_VAR 0 2
103430: PUSH
103431: LD_INT 3
103433: PLUS
103434: PUSH
103435: LD_INT 0
103437: PUSH
103438: EMPTY
103439: LIST
103440: LIST
103441: LIST
103442: PUSH
103443: EMPTY
103444: LIST
103445: LIST
103446: LIST
103447: LIST
103448: LIST
103449: ST_TO_ADDR
// end ; end ;
103450: GO 103453
103452: POP
// result := list ;
103453: LD_ADDR_VAR 0 4
103457: PUSH
103458: LD_VAR 0 5
103462: ST_TO_ADDR
// end ;
103463: LD_VAR 0 4
103467: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103468: LD_INT 0
103470: PPUSH
103471: PPUSH
103472: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103473: LD_VAR 0 1
103477: NOT
103478: PUSH
103479: LD_VAR 0 2
103483: PUSH
103484: LD_INT 1
103486: PUSH
103487: LD_INT 2
103489: PUSH
103490: LD_INT 3
103492: PUSH
103493: LD_INT 4
103495: PUSH
103496: EMPTY
103497: LIST
103498: LIST
103499: LIST
103500: LIST
103501: IN
103502: NOT
103503: OR
103504: IFFALSE 103508
// exit ;
103506: GO 103600
// tmp := [ ] ;
103508: LD_ADDR_VAR 0 5
103512: PUSH
103513: EMPTY
103514: ST_TO_ADDR
// for i in units do
103515: LD_ADDR_VAR 0 4
103519: PUSH
103520: LD_VAR 0 1
103524: PUSH
103525: FOR_IN
103526: IFFALSE 103569
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103528: LD_ADDR_VAR 0 5
103532: PUSH
103533: LD_VAR 0 5
103537: PPUSH
103538: LD_VAR 0 5
103542: PUSH
103543: LD_INT 1
103545: PLUS
103546: PPUSH
103547: LD_VAR 0 4
103551: PPUSH
103552: LD_VAR 0 2
103556: PPUSH
103557: CALL_OW 259
103561: PPUSH
103562: CALL_OW 2
103566: ST_TO_ADDR
103567: GO 103525
103569: POP
103570: POP
// if not tmp then
103571: LD_VAR 0 5
103575: NOT
103576: IFFALSE 103580
// exit ;
103578: GO 103600
// result := SortListByListDesc ( units , tmp ) ;
103580: LD_ADDR_VAR 0 3
103584: PUSH
103585: LD_VAR 0 1
103589: PPUSH
103590: LD_VAR 0 5
103594: PPUSH
103595: CALL_OW 77
103599: ST_TO_ADDR
// end ;
103600: LD_VAR 0 3
103604: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103605: LD_INT 0
103607: PPUSH
103608: PPUSH
103609: PPUSH
// result := false ;
103610: LD_ADDR_VAR 0 3
103614: PUSH
103615: LD_INT 0
103617: ST_TO_ADDR
// x := GetX ( building ) ;
103618: LD_ADDR_VAR 0 4
103622: PUSH
103623: LD_VAR 0 2
103627: PPUSH
103628: CALL_OW 250
103632: ST_TO_ADDR
// y := GetY ( building ) ;
103633: LD_ADDR_VAR 0 5
103637: PUSH
103638: LD_VAR 0 2
103642: PPUSH
103643: CALL_OW 251
103647: ST_TO_ADDR
// if not building or not x or not y then
103648: LD_VAR 0 2
103652: NOT
103653: PUSH
103654: LD_VAR 0 4
103658: NOT
103659: OR
103660: PUSH
103661: LD_VAR 0 5
103665: NOT
103666: OR
103667: IFFALSE 103671
// exit ;
103669: GO 103763
// if GetTaskList ( unit ) then
103671: LD_VAR 0 1
103675: PPUSH
103676: CALL_OW 437
103680: IFFALSE 103763
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103682: LD_STRING e
103684: PUSH
103685: LD_VAR 0 1
103689: PPUSH
103690: CALL_OW 437
103694: PUSH
103695: LD_INT 1
103697: ARRAY
103698: PUSH
103699: LD_INT 1
103701: ARRAY
103702: EQUAL
103703: PUSH
103704: LD_VAR 0 4
103708: PUSH
103709: LD_VAR 0 1
103713: PPUSH
103714: CALL_OW 437
103718: PUSH
103719: LD_INT 1
103721: ARRAY
103722: PUSH
103723: LD_INT 2
103725: ARRAY
103726: EQUAL
103727: AND
103728: PUSH
103729: LD_VAR 0 5
103733: PUSH
103734: LD_VAR 0 1
103738: PPUSH
103739: CALL_OW 437
103743: PUSH
103744: LD_INT 1
103746: ARRAY
103747: PUSH
103748: LD_INT 3
103750: ARRAY
103751: EQUAL
103752: AND
103753: IFFALSE 103763
// result := true end ;
103755: LD_ADDR_VAR 0 3
103759: PUSH
103760: LD_INT 1
103762: ST_TO_ADDR
// end ;
103763: LD_VAR 0 3
103767: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103768: LD_INT 0
103770: PPUSH
// result := false ;
103771: LD_ADDR_VAR 0 4
103775: PUSH
103776: LD_INT 0
103778: ST_TO_ADDR
// if GetTaskList ( unit ) then
103779: LD_VAR 0 1
103783: PPUSH
103784: CALL_OW 437
103788: IFFALSE 103871
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103790: LD_STRING M
103792: PUSH
103793: LD_VAR 0 1
103797: PPUSH
103798: CALL_OW 437
103802: PUSH
103803: LD_INT 1
103805: ARRAY
103806: PUSH
103807: LD_INT 1
103809: ARRAY
103810: EQUAL
103811: PUSH
103812: LD_VAR 0 2
103816: PUSH
103817: LD_VAR 0 1
103821: PPUSH
103822: CALL_OW 437
103826: PUSH
103827: LD_INT 1
103829: ARRAY
103830: PUSH
103831: LD_INT 2
103833: ARRAY
103834: EQUAL
103835: AND
103836: PUSH
103837: LD_VAR 0 3
103841: PUSH
103842: LD_VAR 0 1
103846: PPUSH
103847: CALL_OW 437
103851: PUSH
103852: LD_INT 1
103854: ARRAY
103855: PUSH
103856: LD_INT 3
103858: ARRAY
103859: EQUAL
103860: AND
103861: IFFALSE 103871
// result := true ;
103863: LD_ADDR_VAR 0 4
103867: PUSH
103868: LD_INT 1
103870: ST_TO_ADDR
// end ; end ;
103871: LD_VAR 0 4
103875: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103876: LD_INT 0
103878: PPUSH
103879: PPUSH
103880: PPUSH
103881: PPUSH
// if not unit or not area then
103882: LD_VAR 0 1
103886: NOT
103887: PUSH
103888: LD_VAR 0 2
103892: NOT
103893: OR
103894: IFFALSE 103898
// exit ;
103896: GO 104062
// tmp := AreaToList ( area , i ) ;
103898: LD_ADDR_VAR 0 6
103902: PUSH
103903: LD_VAR 0 2
103907: PPUSH
103908: LD_VAR 0 5
103912: PPUSH
103913: CALL_OW 517
103917: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103918: LD_ADDR_VAR 0 5
103922: PUSH
103923: DOUBLE
103924: LD_INT 1
103926: DEC
103927: ST_TO_ADDR
103928: LD_VAR 0 6
103932: PUSH
103933: LD_INT 1
103935: ARRAY
103936: PUSH
103937: FOR_TO
103938: IFFALSE 104060
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103940: LD_ADDR_VAR 0 7
103944: PUSH
103945: LD_VAR 0 6
103949: PUSH
103950: LD_INT 1
103952: ARRAY
103953: PUSH
103954: LD_VAR 0 5
103958: ARRAY
103959: PUSH
103960: LD_VAR 0 6
103964: PUSH
103965: LD_INT 2
103967: ARRAY
103968: PUSH
103969: LD_VAR 0 5
103973: ARRAY
103974: PUSH
103975: EMPTY
103976: LIST
103977: LIST
103978: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103979: LD_VAR 0 7
103983: PUSH
103984: LD_INT 1
103986: ARRAY
103987: PPUSH
103988: LD_VAR 0 7
103992: PUSH
103993: LD_INT 2
103995: ARRAY
103996: PPUSH
103997: CALL_OW 428
104001: PUSH
104002: LD_INT 0
104004: EQUAL
104005: IFFALSE 104058
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104007: LD_VAR 0 1
104011: PPUSH
104012: LD_VAR 0 7
104016: PUSH
104017: LD_INT 1
104019: ARRAY
104020: PPUSH
104021: LD_VAR 0 7
104025: PUSH
104026: LD_INT 2
104028: ARRAY
104029: PPUSH
104030: LD_VAR 0 3
104034: PPUSH
104035: CALL_OW 48
// result := IsPlaced ( unit ) ;
104039: LD_ADDR_VAR 0 4
104043: PUSH
104044: LD_VAR 0 1
104048: PPUSH
104049: CALL_OW 305
104053: ST_TO_ADDR
// exit ;
104054: POP
104055: POP
104056: GO 104062
// end ; end ;
104058: GO 103937
104060: POP
104061: POP
// end ;
104062: LD_VAR 0 4
104066: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104067: LD_INT 0
104069: PPUSH
104070: PPUSH
104071: PPUSH
// if not side or side > 8 then
104072: LD_VAR 0 1
104076: NOT
104077: PUSH
104078: LD_VAR 0 1
104082: PUSH
104083: LD_INT 8
104085: GREATER
104086: OR
104087: IFFALSE 104091
// exit ;
104089: GO 104278
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104091: LD_ADDR_VAR 0 4
104095: PUSH
104096: LD_INT 22
104098: PUSH
104099: LD_VAR 0 1
104103: PUSH
104104: EMPTY
104105: LIST
104106: LIST
104107: PUSH
104108: LD_INT 21
104110: PUSH
104111: LD_INT 3
104113: PUSH
104114: EMPTY
104115: LIST
104116: LIST
104117: PUSH
104118: EMPTY
104119: LIST
104120: LIST
104121: PPUSH
104122: CALL_OW 69
104126: ST_TO_ADDR
// if not tmp then
104127: LD_VAR 0 4
104131: NOT
104132: IFFALSE 104136
// exit ;
104134: GO 104278
// enable_addtolog := true ;
104136: LD_ADDR_OWVAR 81
104140: PUSH
104141: LD_INT 1
104143: ST_TO_ADDR
// AddToLog ( [ ) ;
104144: LD_STRING [
104146: PPUSH
104147: CALL_OW 561
// for i in tmp do
104151: LD_ADDR_VAR 0 3
104155: PUSH
104156: LD_VAR 0 4
104160: PUSH
104161: FOR_IN
104162: IFFALSE 104269
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104164: LD_STRING [
104166: PUSH
104167: LD_VAR 0 3
104171: PPUSH
104172: CALL_OW 266
104176: STR
104177: PUSH
104178: LD_STRING , 
104180: STR
104181: PUSH
104182: LD_VAR 0 3
104186: PPUSH
104187: CALL_OW 250
104191: STR
104192: PUSH
104193: LD_STRING , 
104195: STR
104196: PUSH
104197: LD_VAR 0 3
104201: PPUSH
104202: CALL_OW 251
104206: STR
104207: PUSH
104208: LD_STRING , 
104210: STR
104211: PUSH
104212: LD_VAR 0 3
104216: PPUSH
104217: CALL_OW 254
104221: STR
104222: PUSH
104223: LD_STRING , 
104225: STR
104226: PUSH
104227: LD_VAR 0 3
104231: PPUSH
104232: LD_INT 1
104234: PPUSH
104235: CALL_OW 268
104239: STR
104240: PUSH
104241: LD_STRING , 
104243: STR
104244: PUSH
104245: LD_VAR 0 3
104249: PPUSH
104250: LD_INT 2
104252: PPUSH
104253: CALL_OW 268
104257: STR
104258: PUSH
104259: LD_STRING ],
104261: STR
104262: PPUSH
104263: CALL_OW 561
// end ;
104267: GO 104161
104269: POP
104270: POP
// AddToLog ( ]; ) ;
104271: LD_STRING ];
104273: PPUSH
104274: CALL_OW 561
// end ;
104278: LD_VAR 0 2
104282: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104283: LD_INT 0
104285: PPUSH
104286: PPUSH
104287: PPUSH
104288: PPUSH
104289: PPUSH
// if not area or not rate or not max then
104290: LD_VAR 0 1
104294: NOT
104295: PUSH
104296: LD_VAR 0 2
104300: NOT
104301: OR
104302: PUSH
104303: LD_VAR 0 4
104307: NOT
104308: OR
104309: IFFALSE 104313
// exit ;
104311: GO 104502
// while 1 do
104313: LD_INT 1
104315: IFFALSE 104502
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104317: LD_ADDR_VAR 0 9
104321: PUSH
104322: LD_VAR 0 1
104326: PPUSH
104327: LD_INT 1
104329: PPUSH
104330: CALL_OW 287
104334: PUSH
104335: LD_INT 10
104337: MUL
104338: ST_TO_ADDR
// r := rate / 10 ;
104339: LD_ADDR_VAR 0 7
104343: PUSH
104344: LD_VAR 0 2
104348: PUSH
104349: LD_INT 10
104351: DIVREAL
104352: ST_TO_ADDR
// time := 1 1$00 ;
104353: LD_ADDR_VAR 0 8
104357: PUSH
104358: LD_INT 2100
104360: ST_TO_ADDR
// if amount < min then
104361: LD_VAR 0 9
104365: PUSH
104366: LD_VAR 0 3
104370: LESS
104371: IFFALSE 104389
// r := r * 2 else
104373: LD_ADDR_VAR 0 7
104377: PUSH
104378: LD_VAR 0 7
104382: PUSH
104383: LD_INT 2
104385: MUL
104386: ST_TO_ADDR
104387: GO 104415
// if amount > max then
104389: LD_VAR 0 9
104393: PUSH
104394: LD_VAR 0 4
104398: GREATER
104399: IFFALSE 104415
// r := r / 2 ;
104401: LD_ADDR_VAR 0 7
104405: PUSH
104406: LD_VAR 0 7
104410: PUSH
104411: LD_INT 2
104413: DIVREAL
104414: ST_TO_ADDR
// time := time / r ;
104415: LD_ADDR_VAR 0 8
104419: PUSH
104420: LD_VAR 0 8
104424: PUSH
104425: LD_VAR 0 7
104429: DIVREAL
104430: ST_TO_ADDR
// if time < 0 then
104431: LD_VAR 0 8
104435: PUSH
104436: LD_INT 0
104438: LESS
104439: IFFALSE 104456
// time := time * - 1 ;
104441: LD_ADDR_VAR 0 8
104445: PUSH
104446: LD_VAR 0 8
104450: PUSH
104451: LD_INT 1
104453: NEG
104454: MUL
104455: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104456: LD_VAR 0 8
104460: PUSH
104461: LD_INT 35
104463: PPUSH
104464: LD_INT 875
104466: PPUSH
104467: CALL_OW 12
104471: PLUS
104472: PPUSH
104473: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104477: LD_INT 1
104479: PPUSH
104480: LD_INT 5
104482: PPUSH
104483: CALL_OW 12
104487: PPUSH
104488: LD_VAR 0 1
104492: PPUSH
104493: LD_INT 1
104495: PPUSH
104496: CALL_OW 55
// end ;
104500: GO 104313
// end ;
104502: LD_VAR 0 5
104506: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104507: LD_INT 0
104509: PPUSH
104510: PPUSH
104511: PPUSH
104512: PPUSH
104513: PPUSH
104514: PPUSH
104515: PPUSH
104516: PPUSH
// if not turrets or not factories then
104517: LD_VAR 0 1
104521: NOT
104522: PUSH
104523: LD_VAR 0 2
104527: NOT
104528: OR
104529: IFFALSE 104533
// exit ;
104531: GO 104840
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104533: LD_ADDR_VAR 0 10
104537: PUSH
104538: LD_INT 5
104540: PUSH
104541: LD_INT 6
104543: PUSH
104544: EMPTY
104545: LIST
104546: LIST
104547: PUSH
104548: LD_INT 2
104550: PUSH
104551: LD_INT 4
104553: PUSH
104554: EMPTY
104555: LIST
104556: LIST
104557: PUSH
104558: LD_INT 3
104560: PUSH
104561: LD_INT 5
104563: PUSH
104564: EMPTY
104565: LIST
104566: LIST
104567: PUSH
104568: EMPTY
104569: LIST
104570: LIST
104571: LIST
104572: PUSH
104573: LD_INT 24
104575: PUSH
104576: LD_INT 25
104578: PUSH
104579: EMPTY
104580: LIST
104581: LIST
104582: PUSH
104583: LD_INT 23
104585: PUSH
104586: LD_INT 27
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: PUSH
104593: EMPTY
104594: LIST
104595: LIST
104596: PUSH
104597: LD_INT 42
104599: PUSH
104600: LD_INT 43
104602: PUSH
104603: EMPTY
104604: LIST
104605: LIST
104606: PUSH
104607: LD_INT 44
104609: PUSH
104610: LD_INT 46
104612: PUSH
104613: EMPTY
104614: LIST
104615: LIST
104616: PUSH
104617: LD_INT 45
104619: PUSH
104620: LD_INT 47
104622: PUSH
104623: EMPTY
104624: LIST
104625: LIST
104626: PUSH
104627: EMPTY
104628: LIST
104629: LIST
104630: LIST
104631: PUSH
104632: EMPTY
104633: LIST
104634: LIST
104635: LIST
104636: ST_TO_ADDR
// result := [ ] ;
104637: LD_ADDR_VAR 0 3
104641: PUSH
104642: EMPTY
104643: ST_TO_ADDR
// for i in turrets do
104644: LD_ADDR_VAR 0 4
104648: PUSH
104649: LD_VAR 0 1
104653: PUSH
104654: FOR_IN
104655: IFFALSE 104838
// begin nat := GetNation ( i ) ;
104657: LD_ADDR_VAR 0 7
104661: PUSH
104662: LD_VAR 0 4
104666: PPUSH
104667: CALL_OW 248
104671: ST_TO_ADDR
// weapon := 0 ;
104672: LD_ADDR_VAR 0 8
104676: PUSH
104677: LD_INT 0
104679: ST_TO_ADDR
// if not nat then
104680: LD_VAR 0 7
104684: NOT
104685: IFFALSE 104689
// continue ;
104687: GO 104654
// for j in list [ nat ] do
104689: LD_ADDR_VAR 0 5
104693: PUSH
104694: LD_VAR 0 10
104698: PUSH
104699: LD_VAR 0 7
104703: ARRAY
104704: PUSH
104705: FOR_IN
104706: IFFALSE 104747
// if GetBWeapon ( i ) = j [ 1 ] then
104708: LD_VAR 0 4
104712: PPUSH
104713: CALL_OW 269
104717: PUSH
104718: LD_VAR 0 5
104722: PUSH
104723: LD_INT 1
104725: ARRAY
104726: EQUAL
104727: IFFALSE 104745
// begin weapon := j [ 2 ] ;
104729: LD_ADDR_VAR 0 8
104733: PUSH
104734: LD_VAR 0 5
104738: PUSH
104739: LD_INT 2
104741: ARRAY
104742: ST_TO_ADDR
// break ;
104743: GO 104747
// end ;
104745: GO 104705
104747: POP
104748: POP
// if not weapon then
104749: LD_VAR 0 8
104753: NOT
104754: IFFALSE 104758
// continue ;
104756: GO 104654
// for k in factories do
104758: LD_ADDR_VAR 0 6
104762: PUSH
104763: LD_VAR 0 2
104767: PUSH
104768: FOR_IN
104769: IFFALSE 104834
// begin weapons := AvailableWeaponList ( k ) ;
104771: LD_ADDR_VAR 0 9
104775: PUSH
104776: LD_VAR 0 6
104780: PPUSH
104781: CALL_OW 478
104785: ST_TO_ADDR
// if not weapons then
104786: LD_VAR 0 9
104790: NOT
104791: IFFALSE 104795
// continue ;
104793: GO 104768
// if weapon in weapons then
104795: LD_VAR 0 8
104799: PUSH
104800: LD_VAR 0 9
104804: IN
104805: IFFALSE 104832
// begin result := [ i , weapon ] ;
104807: LD_ADDR_VAR 0 3
104811: PUSH
104812: LD_VAR 0 4
104816: PUSH
104817: LD_VAR 0 8
104821: PUSH
104822: EMPTY
104823: LIST
104824: LIST
104825: ST_TO_ADDR
// exit ;
104826: POP
104827: POP
104828: POP
104829: POP
104830: GO 104840
// end ; end ;
104832: GO 104768
104834: POP
104835: POP
// end ;
104836: GO 104654
104838: POP
104839: POP
// end ;
104840: LD_VAR 0 3
104844: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104845: LD_INT 0
104847: PPUSH
// if not side or side > 8 then
104848: LD_VAR 0 3
104852: NOT
104853: PUSH
104854: LD_VAR 0 3
104858: PUSH
104859: LD_INT 8
104861: GREATER
104862: OR
104863: IFFALSE 104867
// exit ;
104865: GO 104926
// if not range then
104867: LD_VAR 0 4
104871: NOT
104872: IFFALSE 104883
// range := - 12 ;
104874: LD_ADDR_VAR 0 4
104878: PUSH
104879: LD_INT 12
104881: NEG
104882: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104883: LD_VAR 0 1
104887: PPUSH
104888: LD_VAR 0 2
104892: PPUSH
104893: LD_VAR 0 3
104897: PPUSH
104898: LD_VAR 0 4
104902: PPUSH
104903: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104907: LD_VAR 0 1
104911: PPUSH
104912: LD_VAR 0 2
104916: PPUSH
104917: LD_VAR 0 3
104921: PPUSH
104922: CALL_OW 331
// end ;
104926: LD_VAR 0 5
104930: RET
// export function Video ( mode ) ; begin
104931: LD_INT 0
104933: PPUSH
// ingame_video = mode ;
104934: LD_ADDR_OWVAR 52
104938: PUSH
104939: LD_VAR 0 1
104943: ST_TO_ADDR
// interface_hidden = mode ;
104944: LD_ADDR_OWVAR 54
104948: PUSH
104949: LD_VAR 0 1
104953: ST_TO_ADDR
// end ;
104954: LD_VAR 0 2
104958: RET
// export function Join ( array , element ) ; begin
104959: LD_INT 0
104961: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104962: LD_ADDR_VAR 0 3
104966: PUSH
104967: LD_VAR 0 1
104971: PPUSH
104972: LD_VAR 0 1
104976: PUSH
104977: LD_INT 1
104979: PLUS
104980: PPUSH
104981: LD_VAR 0 2
104985: PPUSH
104986: CALL_OW 1
104990: ST_TO_ADDR
// end ;
104991: LD_VAR 0 3
104995: RET
// export function JoinUnion ( array , element ) ; begin
104996: LD_INT 0
104998: PPUSH
// result := array union element ;
104999: LD_ADDR_VAR 0 3
105003: PUSH
105004: LD_VAR 0 1
105008: PUSH
105009: LD_VAR 0 2
105013: UNION
105014: ST_TO_ADDR
// end ;
105015: LD_VAR 0 3
105019: RET
// export function GetBehemoths ( side ) ; begin
105020: LD_INT 0
105022: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105023: LD_ADDR_VAR 0 2
105027: PUSH
105028: LD_INT 22
105030: PUSH
105031: LD_VAR 0 1
105035: PUSH
105036: EMPTY
105037: LIST
105038: LIST
105039: PUSH
105040: LD_INT 31
105042: PUSH
105043: LD_INT 25
105045: PUSH
105046: EMPTY
105047: LIST
105048: LIST
105049: PUSH
105050: EMPTY
105051: LIST
105052: LIST
105053: PPUSH
105054: CALL_OW 69
105058: ST_TO_ADDR
// end ;
105059: LD_VAR 0 2
105063: RET
// export function Shuffle ( array ) ; var i , index ; begin
105064: LD_INT 0
105066: PPUSH
105067: PPUSH
105068: PPUSH
// result := [ ] ;
105069: LD_ADDR_VAR 0 2
105073: PUSH
105074: EMPTY
105075: ST_TO_ADDR
// if not array then
105076: LD_VAR 0 1
105080: NOT
105081: IFFALSE 105085
// exit ;
105083: GO 105184
// Randomize ;
105085: CALL_OW 10
// for i = array downto 1 do
105089: LD_ADDR_VAR 0 3
105093: PUSH
105094: DOUBLE
105095: LD_VAR 0 1
105099: INC
105100: ST_TO_ADDR
105101: LD_INT 1
105103: PUSH
105104: FOR_DOWNTO
105105: IFFALSE 105182
// begin index := rand ( 1 , array ) ;
105107: LD_ADDR_VAR 0 4
105111: PUSH
105112: LD_INT 1
105114: PPUSH
105115: LD_VAR 0 1
105119: PPUSH
105120: CALL_OW 12
105124: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105125: LD_ADDR_VAR 0 2
105129: PUSH
105130: LD_VAR 0 2
105134: PPUSH
105135: LD_VAR 0 2
105139: PUSH
105140: LD_INT 1
105142: PLUS
105143: PPUSH
105144: LD_VAR 0 1
105148: PUSH
105149: LD_VAR 0 4
105153: ARRAY
105154: PPUSH
105155: CALL_OW 2
105159: ST_TO_ADDR
// array := Delete ( array , index ) ;
105160: LD_ADDR_VAR 0 1
105164: PUSH
105165: LD_VAR 0 1
105169: PPUSH
105170: LD_VAR 0 4
105174: PPUSH
105175: CALL_OW 3
105179: ST_TO_ADDR
// end ;
105180: GO 105104
105182: POP
105183: POP
// end ;
105184: LD_VAR 0 2
105188: RET
// export function GetBaseMaterials ( base ) ; begin
105189: LD_INT 0
105191: PPUSH
// result := [ 0 , 0 , 0 ] ;
105192: LD_ADDR_VAR 0 2
105196: PUSH
105197: LD_INT 0
105199: PUSH
105200: LD_INT 0
105202: PUSH
105203: LD_INT 0
105205: PUSH
105206: EMPTY
105207: LIST
105208: LIST
105209: LIST
105210: ST_TO_ADDR
// if not base then
105211: LD_VAR 0 1
105215: NOT
105216: IFFALSE 105220
// exit ;
105218: GO 105269
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105220: LD_ADDR_VAR 0 2
105224: PUSH
105225: LD_VAR 0 1
105229: PPUSH
105230: LD_INT 1
105232: PPUSH
105233: CALL_OW 275
105237: PUSH
105238: LD_VAR 0 1
105242: PPUSH
105243: LD_INT 2
105245: PPUSH
105246: CALL_OW 275
105250: PUSH
105251: LD_VAR 0 1
105255: PPUSH
105256: LD_INT 3
105258: PPUSH
105259: CALL_OW 275
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: LIST
105268: ST_TO_ADDR
// end ;
105269: LD_VAR 0 2
105273: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105274: LD_INT 0
105276: PPUSH
105277: PPUSH
// result := array ;
105278: LD_ADDR_VAR 0 3
105282: PUSH
105283: LD_VAR 0 1
105287: ST_TO_ADDR
// if size >= result then
105288: LD_VAR 0 2
105292: PUSH
105293: LD_VAR 0 3
105297: GREATEREQUAL
105298: IFFALSE 105302
// exit ;
105300: GO 105352
// if size then
105302: LD_VAR 0 2
105306: IFFALSE 105352
// for i := array downto size do
105308: LD_ADDR_VAR 0 4
105312: PUSH
105313: DOUBLE
105314: LD_VAR 0 1
105318: INC
105319: ST_TO_ADDR
105320: LD_VAR 0 2
105324: PUSH
105325: FOR_DOWNTO
105326: IFFALSE 105350
// result := Delete ( result , result ) ;
105328: LD_ADDR_VAR 0 3
105332: PUSH
105333: LD_VAR 0 3
105337: PPUSH
105338: LD_VAR 0 3
105342: PPUSH
105343: CALL_OW 3
105347: ST_TO_ADDR
105348: GO 105325
105350: POP
105351: POP
// end ;
105352: LD_VAR 0 3
105356: RET
// export function ComExit ( unit ) ; var tmp ; begin
105357: LD_INT 0
105359: PPUSH
105360: PPUSH
// if not IsInUnit ( unit ) then
105361: LD_VAR 0 1
105365: PPUSH
105366: CALL_OW 310
105370: NOT
105371: IFFALSE 105375
// exit ;
105373: GO 105435
// tmp := IsInUnit ( unit ) ;
105375: LD_ADDR_VAR 0 3
105379: PUSH
105380: LD_VAR 0 1
105384: PPUSH
105385: CALL_OW 310
105389: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105390: LD_VAR 0 3
105394: PPUSH
105395: CALL_OW 247
105399: PUSH
105400: LD_INT 2
105402: EQUAL
105403: IFFALSE 105416
// ComExitVehicle ( unit ) else
105405: LD_VAR 0 1
105409: PPUSH
105410: CALL_OW 121
105414: GO 105425
// ComExitBuilding ( unit ) ;
105416: LD_VAR 0 1
105420: PPUSH
105421: CALL_OW 122
// result := tmp ;
105425: LD_ADDR_VAR 0 2
105429: PUSH
105430: LD_VAR 0 3
105434: ST_TO_ADDR
// end ;
105435: LD_VAR 0 2
105439: RET
// export function ComExitAll ( units ) ; var i ; begin
105440: LD_INT 0
105442: PPUSH
105443: PPUSH
// if not units then
105444: LD_VAR 0 1
105448: NOT
105449: IFFALSE 105453
// exit ;
105451: GO 105479
// for i in units do
105453: LD_ADDR_VAR 0 3
105457: PUSH
105458: LD_VAR 0 1
105462: PUSH
105463: FOR_IN
105464: IFFALSE 105477
// ComExit ( i ) ;
105466: LD_VAR 0 3
105470: PPUSH
105471: CALL 105357 0 1
105475: GO 105463
105477: POP
105478: POP
// end ;
105479: LD_VAR 0 2
105483: RET
// export function ResetHc ; begin
105484: LD_INT 0
105486: PPUSH
// InitHc ;
105487: CALL_OW 19
// hc_importance := 0 ;
105491: LD_ADDR_OWVAR 32
105495: PUSH
105496: LD_INT 0
105498: ST_TO_ADDR
// end ;
105499: LD_VAR 0 1
105503: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105504: LD_INT 0
105506: PPUSH
105507: PPUSH
105508: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105509: LD_ADDR_VAR 0 6
105513: PUSH
105514: LD_VAR 0 1
105518: PUSH
105519: LD_VAR 0 3
105523: PLUS
105524: PUSH
105525: LD_INT 2
105527: DIV
105528: ST_TO_ADDR
// if _x < 0 then
105529: LD_VAR 0 6
105533: PUSH
105534: LD_INT 0
105536: LESS
105537: IFFALSE 105554
// _x := _x * - 1 ;
105539: LD_ADDR_VAR 0 6
105543: PUSH
105544: LD_VAR 0 6
105548: PUSH
105549: LD_INT 1
105551: NEG
105552: MUL
105553: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105554: LD_ADDR_VAR 0 7
105558: PUSH
105559: LD_VAR 0 2
105563: PUSH
105564: LD_VAR 0 4
105568: PLUS
105569: PUSH
105570: LD_INT 2
105572: DIV
105573: ST_TO_ADDR
// if _y < 0 then
105574: LD_VAR 0 7
105578: PUSH
105579: LD_INT 0
105581: LESS
105582: IFFALSE 105599
// _y := _y * - 1 ;
105584: LD_ADDR_VAR 0 7
105588: PUSH
105589: LD_VAR 0 7
105593: PUSH
105594: LD_INT 1
105596: NEG
105597: MUL
105598: ST_TO_ADDR
// result := [ _x , _y ] ;
105599: LD_ADDR_VAR 0 5
105603: PUSH
105604: LD_VAR 0 6
105608: PUSH
105609: LD_VAR 0 7
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: ST_TO_ADDR
// end ;
105618: LD_VAR 0 5
105622: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105623: LD_INT 0
105625: PPUSH
105626: PPUSH
105627: PPUSH
105628: PPUSH
// task := GetTaskList ( unit ) ;
105629: LD_ADDR_VAR 0 7
105633: PUSH
105634: LD_VAR 0 1
105638: PPUSH
105639: CALL_OW 437
105643: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105644: LD_VAR 0 7
105648: NOT
105649: PUSH
105650: LD_VAR 0 1
105654: PPUSH
105655: LD_VAR 0 2
105659: PPUSH
105660: CALL_OW 308
105664: NOT
105665: AND
105666: IFFALSE 105670
// exit ;
105668: GO 105788
// if IsInArea ( unit , area ) then
105670: LD_VAR 0 1
105674: PPUSH
105675: LD_VAR 0 2
105679: PPUSH
105680: CALL_OW 308
105684: IFFALSE 105702
// begin ComMoveToArea ( unit , goAway ) ;
105686: LD_VAR 0 1
105690: PPUSH
105691: LD_VAR 0 3
105695: PPUSH
105696: CALL_OW 113
// exit ;
105700: GO 105788
// end ; if task [ 1 ] [ 1 ] <> M then
105702: LD_VAR 0 7
105706: PUSH
105707: LD_INT 1
105709: ARRAY
105710: PUSH
105711: LD_INT 1
105713: ARRAY
105714: PUSH
105715: LD_STRING M
105717: NONEQUAL
105718: IFFALSE 105722
// exit ;
105720: GO 105788
// x := task [ 1 ] [ 2 ] ;
105722: LD_ADDR_VAR 0 5
105726: PUSH
105727: LD_VAR 0 7
105731: PUSH
105732: LD_INT 1
105734: ARRAY
105735: PUSH
105736: LD_INT 2
105738: ARRAY
105739: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105740: LD_ADDR_VAR 0 6
105744: PUSH
105745: LD_VAR 0 7
105749: PUSH
105750: LD_INT 1
105752: ARRAY
105753: PUSH
105754: LD_INT 3
105756: ARRAY
105757: ST_TO_ADDR
// if InArea ( x , y , area ) then
105758: LD_VAR 0 5
105762: PPUSH
105763: LD_VAR 0 6
105767: PPUSH
105768: LD_VAR 0 2
105772: PPUSH
105773: CALL_OW 309
105777: IFFALSE 105788
// ComStop ( unit ) ;
105779: LD_VAR 0 1
105783: PPUSH
105784: CALL_OW 141
// end ;
105788: LD_VAR 0 4
105792: RET
// export function Abs ( value ) ; begin
105793: LD_INT 0
105795: PPUSH
// result := value ;
105796: LD_ADDR_VAR 0 2
105800: PUSH
105801: LD_VAR 0 1
105805: ST_TO_ADDR
// if value < 0 then
105806: LD_VAR 0 1
105810: PUSH
105811: LD_INT 0
105813: LESS
105814: IFFALSE 105831
// result := value * - 1 ;
105816: LD_ADDR_VAR 0 2
105820: PUSH
105821: LD_VAR 0 1
105825: PUSH
105826: LD_INT 1
105828: NEG
105829: MUL
105830: ST_TO_ADDR
// end ;
105831: LD_VAR 0 2
105835: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105836: LD_INT 0
105838: PPUSH
105839: PPUSH
105840: PPUSH
105841: PPUSH
105842: PPUSH
105843: PPUSH
105844: PPUSH
105845: PPUSH
// if not unit or not building then
105846: LD_VAR 0 1
105850: NOT
105851: PUSH
105852: LD_VAR 0 2
105856: NOT
105857: OR
105858: IFFALSE 105862
// exit ;
105860: GO 106088
// x := GetX ( building ) ;
105862: LD_ADDR_VAR 0 4
105866: PUSH
105867: LD_VAR 0 2
105871: PPUSH
105872: CALL_OW 250
105876: ST_TO_ADDR
// y := GetY ( building ) ;
105877: LD_ADDR_VAR 0 6
105881: PUSH
105882: LD_VAR 0 2
105886: PPUSH
105887: CALL_OW 251
105891: ST_TO_ADDR
// d := GetDir ( building ) ;
105892: LD_ADDR_VAR 0 8
105896: PUSH
105897: LD_VAR 0 2
105901: PPUSH
105902: CALL_OW 254
105906: ST_TO_ADDR
// r := 4 ;
105907: LD_ADDR_VAR 0 9
105911: PUSH
105912: LD_INT 4
105914: ST_TO_ADDR
// for i := 1 to 5 do
105915: LD_ADDR_VAR 0 10
105919: PUSH
105920: DOUBLE
105921: LD_INT 1
105923: DEC
105924: ST_TO_ADDR
105925: LD_INT 5
105927: PUSH
105928: FOR_TO
105929: IFFALSE 106086
// begin _x := ShiftX ( x , d , r + i ) ;
105931: LD_ADDR_VAR 0 5
105935: PUSH
105936: LD_VAR 0 4
105940: PPUSH
105941: LD_VAR 0 8
105945: PPUSH
105946: LD_VAR 0 9
105950: PUSH
105951: LD_VAR 0 10
105955: PLUS
105956: PPUSH
105957: CALL_OW 272
105961: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105962: LD_ADDR_VAR 0 7
105966: PUSH
105967: LD_VAR 0 6
105971: PPUSH
105972: LD_VAR 0 8
105976: PPUSH
105977: LD_VAR 0 9
105981: PUSH
105982: LD_VAR 0 10
105986: PLUS
105987: PPUSH
105988: CALL_OW 273
105992: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105993: LD_VAR 0 5
105997: PPUSH
105998: LD_VAR 0 7
106002: PPUSH
106003: CALL_OW 488
106007: PUSH
106008: LD_VAR 0 5
106012: PPUSH
106013: LD_VAR 0 7
106017: PPUSH
106018: CALL_OW 428
106022: PPUSH
106023: CALL_OW 247
106027: PUSH
106028: LD_INT 3
106030: PUSH
106031: LD_INT 2
106033: PUSH
106034: EMPTY
106035: LIST
106036: LIST
106037: IN
106038: NOT
106039: AND
106040: IFFALSE 106084
// begin ComMoveXY ( unit , _x , _y ) ;
106042: LD_VAR 0 1
106046: PPUSH
106047: LD_VAR 0 5
106051: PPUSH
106052: LD_VAR 0 7
106056: PPUSH
106057: CALL_OW 111
// result := [ _x , _y ] ;
106061: LD_ADDR_VAR 0 3
106065: PUSH
106066: LD_VAR 0 5
106070: PUSH
106071: LD_VAR 0 7
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: ST_TO_ADDR
// exit ;
106080: POP
106081: POP
106082: GO 106088
// end ; end ;
106084: GO 105928
106086: POP
106087: POP
// end ;
106088: LD_VAR 0 3
106092: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106093: LD_INT 0
106095: PPUSH
106096: PPUSH
106097: PPUSH
// result := 0 ;
106098: LD_ADDR_VAR 0 3
106102: PUSH
106103: LD_INT 0
106105: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106106: LD_VAR 0 1
106110: PUSH
106111: LD_INT 0
106113: LESS
106114: PUSH
106115: LD_VAR 0 1
106119: PUSH
106120: LD_INT 8
106122: GREATER
106123: OR
106124: PUSH
106125: LD_VAR 0 2
106129: PUSH
106130: LD_INT 0
106132: LESS
106133: OR
106134: PUSH
106135: LD_VAR 0 2
106139: PUSH
106140: LD_INT 8
106142: GREATER
106143: OR
106144: IFFALSE 106148
// exit ;
106146: GO 106223
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
106148: LD_ADDR_VAR 0 4
106152: PUSH
106153: LD_INT 22
106155: PUSH
106156: LD_VAR 0 2
106160: PUSH
106161: EMPTY
106162: LIST
106163: LIST
106164: PPUSH
106165: CALL_OW 69
106169: PUSH
106170: FOR_IN
106171: IFFALSE 106221
// begin un := UnitShoot ( i ) ;
106173: LD_ADDR_VAR 0 5
106177: PUSH
106178: LD_VAR 0 4
106182: PPUSH
106183: CALL_OW 504
106187: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106188: LD_VAR 0 5
106192: PPUSH
106193: CALL_OW 255
106197: PUSH
106198: LD_VAR 0 1
106202: EQUAL
106203: IFFALSE 106219
// begin result := un ;
106205: LD_ADDR_VAR 0 3
106209: PUSH
106210: LD_VAR 0 5
106214: ST_TO_ADDR
// exit ;
106215: POP
106216: POP
106217: GO 106223
// end ; end ;
106219: GO 106170
106221: POP
106222: POP
// end ;
106223: LD_VAR 0 3
106227: RET
// export function GetCargoBay ( units ) ; begin
106228: LD_INT 0
106230: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106231: LD_ADDR_VAR 0 2
106235: PUSH
106236: LD_VAR 0 1
106240: PPUSH
106241: LD_INT 2
106243: PUSH
106244: LD_INT 34
106246: PUSH
106247: LD_INT 12
106249: PUSH
106250: EMPTY
106251: LIST
106252: LIST
106253: PUSH
106254: LD_INT 34
106256: PUSH
106257: LD_INT 51
106259: PUSH
106260: EMPTY
106261: LIST
106262: LIST
106263: PUSH
106264: LD_INT 34
106266: PUSH
106267: LD_INT 32
106269: PUSH
106270: EMPTY
106271: LIST
106272: LIST
106273: PUSH
106274: LD_INT 34
106276: PUSH
106277: LD_INT 89
106279: PUSH
106280: EMPTY
106281: LIST
106282: LIST
106283: PUSH
106284: EMPTY
106285: LIST
106286: LIST
106287: LIST
106288: LIST
106289: LIST
106290: PPUSH
106291: CALL_OW 72
106295: ST_TO_ADDR
// end ;
106296: LD_VAR 0 2
106300: RET
// export function Negate ( value ) ; begin
106301: LD_INT 0
106303: PPUSH
// result := not value ;
106304: LD_ADDR_VAR 0 2
106308: PUSH
106309: LD_VAR 0 1
106313: NOT
106314: ST_TO_ADDR
// end ;
106315: LD_VAR 0 2
106319: RET
// export function Inc ( value ) ; begin
106320: LD_INT 0
106322: PPUSH
// result := value + 1 ;
106323: LD_ADDR_VAR 0 2
106327: PUSH
106328: LD_VAR 0 1
106332: PUSH
106333: LD_INT 1
106335: PLUS
106336: ST_TO_ADDR
// end ;
106337: LD_VAR 0 2
106341: RET
// export function Dec ( value ) ; begin
106342: LD_INT 0
106344: PPUSH
// result := value - 1 ;
106345: LD_ADDR_VAR 0 2
106349: PUSH
106350: LD_VAR 0 1
106354: PUSH
106355: LD_INT 1
106357: MINUS
106358: ST_TO_ADDR
// end ;
106359: LD_VAR 0 2
106363: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106364: LD_INT 0
106366: PPUSH
106367: PPUSH
106368: PPUSH
106369: PPUSH
106370: PPUSH
106371: PPUSH
106372: PPUSH
106373: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106374: LD_VAR 0 1
106378: PPUSH
106379: LD_VAR 0 2
106383: PPUSH
106384: CALL_OW 488
106388: NOT
106389: PUSH
106390: LD_VAR 0 3
106394: PPUSH
106395: LD_VAR 0 4
106399: PPUSH
106400: CALL_OW 488
106404: NOT
106405: OR
106406: IFFALSE 106419
// begin result := - 1 ;
106408: LD_ADDR_VAR 0 5
106412: PUSH
106413: LD_INT 1
106415: NEG
106416: ST_TO_ADDR
// exit ;
106417: GO 106654
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106419: LD_ADDR_VAR 0 12
106423: PUSH
106424: LD_VAR 0 1
106428: PPUSH
106429: LD_VAR 0 2
106433: PPUSH
106434: LD_VAR 0 3
106438: PPUSH
106439: LD_VAR 0 4
106443: PPUSH
106444: CALL 105504 0 4
106448: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106449: LD_ADDR_VAR 0 11
106453: PUSH
106454: LD_VAR 0 1
106458: PPUSH
106459: LD_VAR 0 2
106463: PPUSH
106464: LD_VAR 0 12
106468: PUSH
106469: LD_INT 1
106471: ARRAY
106472: PPUSH
106473: LD_VAR 0 12
106477: PUSH
106478: LD_INT 2
106480: ARRAY
106481: PPUSH
106482: CALL_OW 298
106486: ST_TO_ADDR
// distance := 9999 ;
106487: LD_ADDR_VAR 0 10
106491: PUSH
106492: LD_INT 9999
106494: ST_TO_ADDR
// for i := 0 to 5 do
106495: LD_ADDR_VAR 0 6
106499: PUSH
106500: DOUBLE
106501: LD_INT 0
106503: DEC
106504: ST_TO_ADDR
106505: LD_INT 5
106507: PUSH
106508: FOR_TO
106509: IFFALSE 106652
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106511: LD_ADDR_VAR 0 7
106515: PUSH
106516: LD_VAR 0 1
106520: PPUSH
106521: LD_VAR 0 6
106525: PPUSH
106526: LD_VAR 0 11
106530: PPUSH
106531: CALL_OW 272
106535: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106536: LD_ADDR_VAR 0 8
106540: PUSH
106541: LD_VAR 0 2
106545: PPUSH
106546: LD_VAR 0 6
106550: PPUSH
106551: LD_VAR 0 11
106555: PPUSH
106556: CALL_OW 273
106560: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106561: LD_VAR 0 7
106565: PPUSH
106566: LD_VAR 0 8
106570: PPUSH
106571: CALL_OW 488
106575: NOT
106576: IFFALSE 106580
// continue ;
106578: GO 106508
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106580: LD_ADDR_VAR 0 9
106584: PUSH
106585: LD_VAR 0 12
106589: PUSH
106590: LD_INT 1
106592: ARRAY
106593: PPUSH
106594: LD_VAR 0 12
106598: PUSH
106599: LD_INT 2
106601: ARRAY
106602: PPUSH
106603: LD_VAR 0 7
106607: PPUSH
106608: LD_VAR 0 8
106612: PPUSH
106613: CALL_OW 298
106617: ST_TO_ADDR
// if tmp < distance then
106618: LD_VAR 0 9
106622: PUSH
106623: LD_VAR 0 10
106627: LESS
106628: IFFALSE 106650
// begin result := i ;
106630: LD_ADDR_VAR 0 5
106634: PUSH
106635: LD_VAR 0 6
106639: ST_TO_ADDR
// distance := tmp ;
106640: LD_ADDR_VAR 0 10
106644: PUSH
106645: LD_VAR 0 9
106649: ST_TO_ADDR
// end ; end ;
106650: GO 106508
106652: POP
106653: POP
// end ;
106654: LD_VAR 0 5
106658: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106659: LD_INT 0
106661: PPUSH
106662: PPUSH
// if not driver or not IsInUnit ( driver ) then
106663: LD_VAR 0 1
106667: NOT
106668: PUSH
106669: LD_VAR 0 1
106673: PPUSH
106674: CALL_OW 310
106678: NOT
106679: OR
106680: IFFALSE 106684
// exit ;
106682: GO 106774
// vehicle := IsInUnit ( driver ) ;
106684: LD_ADDR_VAR 0 3
106688: PUSH
106689: LD_VAR 0 1
106693: PPUSH
106694: CALL_OW 310
106698: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106699: LD_VAR 0 1
106703: PPUSH
106704: LD_STRING \
106706: PUSH
106707: LD_INT 0
106709: PUSH
106710: LD_INT 0
106712: PUSH
106713: LD_INT 0
106715: PUSH
106716: LD_INT 0
106718: PUSH
106719: LD_INT 0
106721: PUSH
106722: LD_INT 0
106724: PUSH
106725: EMPTY
106726: LIST
106727: LIST
106728: LIST
106729: LIST
106730: LIST
106731: LIST
106732: LIST
106733: PUSH
106734: LD_STRING E
106736: PUSH
106737: LD_INT 0
106739: PUSH
106740: LD_INT 0
106742: PUSH
106743: LD_VAR 0 3
106747: PUSH
106748: LD_INT 0
106750: PUSH
106751: LD_INT 0
106753: PUSH
106754: LD_INT 0
106756: PUSH
106757: EMPTY
106758: LIST
106759: LIST
106760: LIST
106761: LIST
106762: LIST
106763: LIST
106764: LIST
106765: PUSH
106766: EMPTY
106767: LIST
106768: LIST
106769: PPUSH
106770: CALL_OW 446
// end ;
106774: LD_VAR 0 2
106778: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106779: LD_INT 0
106781: PPUSH
106782: PPUSH
// if not driver or not IsInUnit ( driver ) then
106783: LD_VAR 0 1
106787: NOT
106788: PUSH
106789: LD_VAR 0 1
106793: PPUSH
106794: CALL_OW 310
106798: NOT
106799: OR
106800: IFFALSE 106804
// exit ;
106802: GO 106894
// vehicle := IsInUnit ( driver ) ;
106804: LD_ADDR_VAR 0 3
106808: PUSH
106809: LD_VAR 0 1
106813: PPUSH
106814: CALL_OW 310
106818: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106819: LD_VAR 0 1
106823: PPUSH
106824: LD_STRING \
106826: PUSH
106827: LD_INT 0
106829: PUSH
106830: LD_INT 0
106832: PUSH
106833: LD_INT 0
106835: PUSH
106836: LD_INT 0
106838: PUSH
106839: LD_INT 0
106841: PUSH
106842: LD_INT 0
106844: PUSH
106845: EMPTY
106846: LIST
106847: LIST
106848: LIST
106849: LIST
106850: LIST
106851: LIST
106852: LIST
106853: PUSH
106854: LD_STRING E
106856: PUSH
106857: LD_INT 0
106859: PUSH
106860: LD_INT 0
106862: PUSH
106863: LD_VAR 0 3
106867: PUSH
106868: LD_INT 0
106870: PUSH
106871: LD_INT 0
106873: PUSH
106874: LD_INT 0
106876: PUSH
106877: EMPTY
106878: LIST
106879: LIST
106880: LIST
106881: LIST
106882: LIST
106883: LIST
106884: LIST
106885: PUSH
106886: EMPTY
106887: LIST
106888: LIST
106889: PPUSH
106890: CALL_OW 447
// end ;
106894: LD_VAR 0 2
106898: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106899: LD_INT 0
106901: PPUSH
106902: PPUSH
106903: PPUSH
// tmp := [ ] ;
106904: LD_ADDR_VAR 0 5
106908: PUSH
106909: EMPTY
106910: ST_TO_ADDR
// for i in units do
106911: LD_ADDR_VAR 0 4
106915: PUSH
106916: LD_VAR 0 1
106920: PUSH
106921: FOR_IN
106922: IFFALSE 106960
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106924: LD_ADDR_VAR 0 5
106928: PUSH
106929: LD_VAR 0 5
106933: PPUSH
106934: LD_VAR 0 5
106938: PUSH
106939: LD_INT 1
106941: PLUS
106942: PPUSH
106943: LD_VAR 0 4
106947: PPUSH
106948: CALL_OW 256
106952: PPUSH
106953: CALL_OW 2
106957: ST_TO_ADDR
106958: GO 106921
106960: POP
106961: POP
// if not tmp then
106962: LD_VAR 0 5
106966: NOT
106967: IFFALSE 106971
// exit ;
106969: GO 107019
// if asc then
106971: LD_VAR 0 2
106975: IFFALSE 106999
// result := SortListByListAsc ( units , tmp ) else
106977: LD_ADDR_VAR 0 3
106981: PUSH
106982: LD_VAR 0 1
106986: PPUSH
106987: LD_VAR 0 5
106991: PPUSH
106992: CALL_OW 76
106996: ST_TO_ADDR
106997: GO 107019
// result := SortListByListDesc ( units , tmp ) ;
106999: LD_ADDR_VAR 0 3
107003: PUSH
107004: LD_VAR 0 1
107008: PPUSH
107009: LD_VAR 0 5
107013: PPUSH
107014: CALL_OW 77
107018: ST_TO_ADDR
// end ;
107019: LD_VAR 0 3
107023: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107024: LD_INT 0
107026: PPUSH
107027: PPUSH
// task := GetTaskList ( mech ) ;
107028: LD_ADDR_VAR 0 4
107032: PUSH
107033: LD_VAR 0 1
107037: PPUSH
107038: CALL_OW 437
107042: ST_TO_ADDR
// if not task then
107043: LD_VAR 0 4
107047: NOT
107048: IFFALSE 107052
// exit ;
107050: GO 107094
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107052: LD_ADDR_VAR 0 3
107056: PUSH
107057: LD_VAR 0 4
107061: PUSH
107062: LD_INT 1
107064: ARRAY
107065: PUSH
107066: LD_INT 1
107068: ARRAY
107069: PUSH
107070: LD_STRING r
107072: EQUAL
107073: PUSH
107074: LD_VAR 0 4
107078: PUSH
107079: LD_INT 1
107081: ARRAY
107082: PUSH
107083: LD_INT 4
107085: ARRAY
107086: PUSH
107087: LD_VAR 0 2
107091: EQUAL
107092: AND
107093: ST_TO_ADDR
// end ;
107094: LD_VAR 0 3
107098: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107099: LD_INT 0
107101: PPUSH
// SetDir ( unit , d ) ;
107102: LD_VAR 0 1
107106: PPUSH
107107: LD_VAR 0 4
107111: PPUSH
107112: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
107116: LD_VAR 0 1
107120: PPUSH
107121: LD_VAR 0 2
107125: PPUSH
107126: LD_VAR 0 3
107130: PPUSH
107131: LD_VAR 0 5
107135: PPUSH
107136: CALL_OW 48
// end ;
107140: LD_VAR 0 6
107144: RET
// export function ToNaturalNumber ( number ) ; begin
107145: LD_INT 0
107147: PPUSH
// result := number div 1 ;
107148: LD_ADDR_VAR 0 2
107152: PUSH
107153: LD_VAR 0 1
107157: PUSH
107158: LD_INT 1
107160: DIV
107161: ST_TO_ADDR
// if number < 0 then
107162: LD_VAR 0 1
107166: PUSH
107167: LD_INT 0
107169: LESS
107170: IFFALSE 107180
// result := 0 ;
107172: LD_ADDR_VAR 0 2
107176: PUSH
107177: LD_INT 0
107179: ST_TO_ADDR
// end ;
107180: LD_VAR 0 2
107184: RET
// export function SortByClass ( units , class ) ; var un ; begin
107185: LD_INT 0
107187: PPUSH
107188: PPUSH
// if not units or not class then
107189: LD_VAR 0 1
107193: NOT
107194: PUSH
107195: LD_VAR 0 2
107199: NOT
107200: OR
107201: IFFALSE 107205
// exit ;
107203: GO 107300
// result := [ ] ;
107205: LD_ADDR_VAR 0 3
107209: PUSH
107210: EMPTY
107211: ST_TO_ADDR
// for un in units do
107212: LD_ADDR_VAR 0 4
107216: PUSH
107217: LD_VAR 0 1
107221: PUSH
107222: FOR_IN
107223: IFFALSE 107298
// if GetClass ( un ) = class then
107225: LD_VAR 0 4
107229: PPUSH
107230: CALL_OW 257
107234: PUSH
107235: LD_VAR 0 2
107239: EQUAL
107240: IFFALSE 107267
// result := Insert ( result , 1 , un ) else
107242: LD_ADDR_VAR 0 3
107246: PUSH
107247: LD_VAR 0 3
107251: PPUSH
107252: LD_INT 1
107254: PPUSH
107255: LD_VAR 0 4
107259: PPUSH
107260: CALL_OW 2
107264: ST_TO_ADDR
107265: GO 107296
// result := Replace ( result , result + 1 , un ) ;
107267: LD_ADDR_VAR 0 3
107271: PUSH
107272: LD_VAR 0 3
107276: PPUSH
107277: LD_VAR 0 3
107281: PUSH
107282: LD_INT 1
107284: PLUS
107285: PPUSH
107286: LD_VAR 0 4
107290: PPUSH
107291: CALL_OW 1
107295: ST_TO_ADDR
107296: GO 107222
107298: POP
107299: POP
// end ;
107300: LD_VAR 0 3
107304: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107305: LD_INT 0
107307: PPUSH
107308: PPUSH
107309: PPUSH
107310: PPUSH
107311: PPUSH
107312: PPUSH
107313: PPUSH
// result := [ ] ;
107314: LD_ADDR_VAR 0 4
107318: PUSH
107319: EMPTY
107320: ST_TO_ADDR
// if x - r < 0 then
107321: LD_VAR 0 1
107325: PUSH
107326: LD_VAR 0 3
107330: MINUS
107331: PUSH
107332: LD_INT 0
107334: LESS
107335: IFFALSE 107347
// min_x := 0 else
107337: LD_ADDR_VAR 0 8
107341: PUSH
107342: LD_INT 0
107344: ST_TO_ADDR
107345: GO 107363
// min_x := x - r ;
107347: LD_ADDR_VAR 0 8
107351: PUSH
107352: LD_VAR 0 1
107356: PUSH
107357: LD_VAR 0 3
107361: MINUS
107362: ST_TO_ADDR
// if y - r < 0 then
107363: LD_VAR 0 2
107367: PUSH
107368: LD_VAR 0 3
107372: MINUS
107373: PUSH
107374: LD_INT 0
107376: LESS
107377: IFFALSE 107389
// min_y := 0 else
107379: LD_ADDR_VAR 0 7
107383: PUSH
107384: LD_INT 0
107386: ST_TO_ADDR
107387: GO 107405
// min_y := y - r ;
107389: LD_ADDR_VAR 0 7
107393: PUSH
107394: LD_VAR 0 2
107398: PUSH
107399: LD_VAR 0 3
107403: MINUS
107404: ST_TO_ADDR
// max_x := x + r ;
107405: LD_ADDR_VAR 0 9
107409: PUSH
107410: LD_VAR 0 1
107414: PUSH
107415: LD_VAR 0 3
107419: PLUS
107420: ST_TO_ADDR
// max_y := y + r ;
107421: LD_ADDR_VAR 0 10
107425: PUSH
107426: LD_VAR 0 2
107430: PUSH
107431: LD_VAR 0 3
107435: PLUS
107436: ST_TO_ADDR
// for _x = min_x to max_x do
107437: LD_ADDR_VAR 0 5
107441: PUSH
107442: DOUBLE
107443: LD_VAR 0 8
107447: DEC
107448: ST_TO_ADDR
107449: LD_VAR 0 9
107453: PUSH
107454: FOR_TO
107455: IFFALSE 107556
// for _y = min_y to max_y do
107457: LD_ADDR_VAR 0 6
107461: PUSH
107462: DOUBLE
107463: LD_VAR 0 7
107467: DEC
107468: ST_TO_ADDR
107469: LD_VAR 0 10
107473: PUSH
107474: FOR_TO
107475: IFFALSE 107552
// begin if not ValidHex ( _x , _y ) then
107477: LD_VAR 0 5
107481: PPUSH
107482: LD_VAR 0 6
107486: PPUSH
107487: CALL_OW 488
107491: NOT
107492: IFFALSE 107496
// continue ;
107494: GO 107474
// if GetResourceTypeXY ( _x , _y ) then
107496: LD_VAR 0 5
107500: PPUSH
107501: LD_VAR 0 6
107505: PPUSH
107506: CALL_OW 283
107510: IFFALSE 107550
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107512: LD_ADDR_VAR 0 4
107516: PUSH
107517: LD_VAR 0 4
107521: PPUSH
107522: LD_VAR 0 4
107526: PUSH
107527: LD_INT 1
107529: PLUS
107530: PPUSH
107531: LD_VAR 0 5
107535: PUSH
107536: LD_VAR 0 6
107540: PUSH
107541: EMPTY
107542: LIST
107543: LIST
107544: PPUSH
107545: CALL_OW 1
107549: ST_TO_ADDR
// end ;
107550: GO 107474
107552: POP
107553: POP
107554: GO 107454
107556: POP
107557: POP
// end ;
107558: LD_VAR 0 4
107562: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107563: LD_INT 0
107565: PPUSH
107566: PPUSH
107567: PPUSH
107568: PPUSH
107569: PPUSH
107570: PPUSH
107571: PPUSH
107572: PPUSH
// if not units then
107573: LD_VAR 0 1
107577: NOT
107578: IFFALSE 107582
// exit ;
107580: GO 108106
// result := UnitFilter ( units , [ f_ok ] ) ;
107582: LD_ADDR_VAR 0 3
107586: PUSH
107587: LD_VAR 0 1
107591: PPUSH
107592: LD_INT 50
107594: PUSH
107595: EMPTY
107596: LIST
107597: PPUSH
107598: CALL_OW 72
107602: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107603: LD_ADDR_VAR 0 8
107607: PUSH
107608: LD_VAR 0 1
107612: PUSH
107613: LD_INT 1
107615: ARRAY
107616: PPUSH
107617: CALL_OW 255
107621: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107622: LD_ADDR_VAR 0 10
107626: PUSH
107627: LD_INT 29
107629: PUSH
107630: LD_INT 91
107632: PUSH
107633: LD_INT 49
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: LIST
107640: ST_TO_ADDR
// if not result then
107641: LD_VAR 0 3
107645: NOT
107646: IFFALSE 107650
// exit ;
107648: GO 108106
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107650: LD_ADDR_VAR 0 5
107654: PUSH
107655: LD_INT 81
107657: PUSH
107658: LD_VAR 0 8
107662: PUSH
107663: EMPTY
107664: LIST
107665: LIST
107666: PPUSH
107667: CALL_OW 69
107671: ST_TO_ADDR
// for i in result do
107672: LD_ADDR_VAR 0 4
107676: PUSH
107677: LD_VAR 0 3
107681: PUSH
107682: FOR_IN
107683: IFFALSE 108104
// begin tag := GetTag ( i ) + 1 ;
107685: LD_ADDR_VAR 0 9
107689: PUSH
107690: LD_VAR 0 4
107694: PPUSH
107695: CALL_OW 110
107699: PUSH
107700: LD_INT 1
107702: PLUS
107703: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107704: LD_ADDR_VAR 0 7
107708: PUSH
107709: LD_VAR 0 4
107713: PPUSH
107714: CALL_OW 250
107718: PPUSH
107719: LD_VAR 0 4
107723: PPUSH
107724: CALL_OW 251
107728: PPUSH
107729: LD_INT 6
107731: PPUSH
107732: CALL 107305 0 3
107736: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107737: LD_VAR 0 4
107741: PPUSH
107742: CALL_OW 247
107746: PUSH
107747: LD_INT 2
107749: EQUAL
107750: PUSH
107751: LD_VAR 0 7
107755: AND
107756: PUSH
107757: LD_VAR 0 4
107761: PPUSH
107762: CALL_OW 264
107766: PUSH
107767: LD_VAR 0 10
107771: IN
107772: NOT
107773: AND
107774: IFFALSE 107813
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107776: LD_VAR 0 4
107780: PPUSH
107781: LD_VAR 0 7
107785: PUSH
107786: LD_INT 1
107788: ARRAY
107789: PUSH
107790: LD_INT 1
107792: ARRAY
107793: PPUSH
107794: LD_VAR 0 7
107798: PUSH
107799: LD_INT 1
107801: ARRAY
107802: PUSH
107803: LD_INT 2
107805: ARRAY
107806: PPUSH
107807: CALL_OW 116
107811: GO 108102
// if path > tag then
107813: LD_VAR 0 2
107817: PUSH
107818: LD_VAR 0 9
107822: GREATER
107823: IFFALSE 108031
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107825: LD_ADDR_VAR 0 6
107829: PUSH
107830: LD_VAR 0 5
107834: PPUSH
107835: LD_INT 91
107837: PUSH
107838: LD_VAR 0 4
107842: PUSH
107843: LD_INT 8
107845: PUSH
107846: EMPTY
107847: LIST
107848: LIST
107849: LIST
107850: PPUSH
107851: CALL_OW 72
107855: ST_TO_ADDR
// if nearEnemy then
107856: LD_VAR 0 6
107860: IFFALSE 107929
// begin if GetWeapon ( i ) = ru_time_lapser then
107862: LD_VAR 0 4
107866: PPUSH
107867: CALL_OW 264
107871: PUSH
107872: LD_INT 49
107874: EQUAL
107875: IFFALSE 107903
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107877: LD_VAR 0 4
107881: PPUSH
107882: LD_VAR 0 6
107886: PPUSH
107887: LD_VAR 0 4
107891: PPUSH
107892: CALL_OW 74
107896: PPUSH
107897: CALL_OW 112
107901: GO 107927
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107903: LD_VAR 0 4
107907: PPUSH
107908: LD_VAR 0 6
107912: PPUSH
107913: LD_VAR 0 4
107917: PPUSH
107918: CALL_OW 74
107922: PPUSH
107923: CALL_OW 115
// end else
107927: GO 108029
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107929: LD_VAR 0 4
107933: PPUSH
107934: LD_VAR 0 2
107938: PUSH
107939: LD_VAR 0 9
107943: ARRAY
107944: PUSH
107945: LD_INT 1
107947: ARRAY
107948: PPUSH
107949: LD_VAR 0 2
107953: PUSH
107954: LD_VAR 0 9
107958: ARRAY
107959: PUSH
107960: LD_INT 2
107962: ARRAY
107963: PPUSH
107964: CALL_OW 297
107968: PUSH
107969: LD_INT 6
107971: GREATER
107972: IFFALSE 108015
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107974: LD_VAR 0 4
107978: PPUSH
107979: LD_VAR 0 2
107983: PUSH
107984: LD_VAR 0 9
107988: ARRAY
107989: PUSH
107990: LD_INT 1
107992: ARRAY
107993: PPUSH
107994: LD_VAR 0 2
107998: PUSH
107999: LD_VAR 0 9
108003: ARRAY
108004: PUSH
108005: LD_INT 2
108007: ARRAY
108008: PPUSH
108009: CALL_OW 114
108013: GO 108029
// SetTag ( i , tag ) ;
108015: LD_VAR 0 4
108019: PPUSH
108020: LD_VAR 0 9
108024: PPUSH
108025: CALL_OW 109
// end else
108029: GO 108102
// if enemy then
108031: LD_VAR 0 5
108035: IFFALSE 108102
// begin if GetWeapon ( i ) = ru_time_lapser then
108037: LD_VAR 0 4
108041: PPUSH
108042: CALL_OW 264
108046: PUSH
108047: LD_INT 49
108049: EQUAL
108050: IFFALSE 108078
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108052: LD_VAR 0 4
108056: PPUSH
108057: LD_VAR 0 5
108061: PPUSH
108062: LD_VAR 0 4
108066: PPUSH
108067: CALL_OW 74
108071: PPUSH
108072: CALL_OW 112
108076: GO 108102
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108078: LD_VAR 0 4
108082: PPUSH
108083: LD_VAR 0 5
108087: PPUSH
108088: LD_VAR 0 4
108092: PPUSH
108093: CALL_OW 74
108097: PPUSH
108098: CALL_OW 115
// end ; end ;
108102: GO 107682
108104: POP
108105: POP
// end ;
108106: LD_VAR 0 3
108110: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
108111: LD_INT 0
108113: PPUSH
108114: PPUSH
108115: PPUSH
// if not unit or IsInUnit ( unit ) then
108116: LD_VAR 0 1
108120: NOT
108121: PUSH
108122: LD_VAR 0 1
108126: PPUSH
108127: CALL_OW 310
108131: OR
108132: IFFALSE 108136
// exit ;
108134: GO 108227
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
108136: LD_ADDR_VAR 0 4
108140: PUSH
108141: LD_VAR 0 1
108145: PPUSH
108146: CALL_OW 250
108150: PPUSH
108151: LD_VAR 0 2
108155: PPUSH
108156: LD_INT 1
108158: PPUSH
108159: CALL_OW 272
108163: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
108164: LD_ADDR_VAR 0 5
108168: PUSH
108169: LD_VAR 0 1
108173: PPUSH
108174: CALL_OW 251
108178: PPUSH
108179: LD_VAR 0 2
108183: PPUSH
108184: LD_INT 1
108186: PPUSH
108187: CALL_OW 273
108191: ST_TO_ADDR
// if ValidHex ( x , y ) then
108192: LD_VAR 0 4
108196: PPUSH
108197: LD_VAR 0 5
108201: PPUSH
108202: CALL_OW 488
108206: IFFALSE 108227
// ComTurnXY ( unit , x , y ) ;
108208: LD_VAR 0 1
108212: PPUSH
108213: LD_VAR 0 4
108217: PPUSH
108218: LD_VAR 0 5
108222: PPUSH
108223: CALL_OW 118
// end ;
108227: LD_VAR 0 3
108231: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108232: LD_INT 0
108234: PPUSH
108235: PPUSH
// result := false ;
108236: LD_ADDR_VAR 0 3
108240: PUSH
108241: LD_INT 0
108243: ST_TO_ADDR
// if not units then
108244: LD_VAR 0 2
108248: NOT
108249: IFFALSE 108253
// exit ;
108251: GO 108298
// for i in units do
108253: LD_ADDR_VAR 0 4
108257: PUSH
108258: LD_VAR 0 2
108262: PUSH
108263: FOR_IN
108264: IFFALSE 108296
// if See ( side , i ) then
108266: LD_VAR 0 1
108270: PPUSH
108271: LD_VAR 0 4
108275: PPUSH
108276: CALL_OW 292
108280: IFFALSE 108294
// begin result := true ;
108282: LD_ADDR_VAR 0 3
108286: PUSH
108287: LD_INT 1
108289: ST_TO_ADDR
// exit ;
108290: POP
108291: POP
108292: GO 108298
// end ;
108294: GO 108263
108296: POP
108297: POP
// end ;
108298: LD_VAR 0 3
108302: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108303: LD_INT 0
108305: PPUSH
108306: PPUSH
108307: PPUSH
108308: PPUSH
// if not unit or not points then
108309: LD_VAR 0 1
108313: NOT
108314: PUSH
108315: LD_VAR 0 2
108319: NOT
108320: OR
108321: IFFALSE 108325
// exit ;
108323: GO 108415
// dist := 99999 ;
108325: LD_ADDR_VAR 0 5
108329: PUSH
108330: LD_INT 99999
108332: ST_TO_ADDR
// for i in points do
108333: LD_ADDR_VAR 0 4
108337: PUSH
108338: LD_VAR 0 2
108342: PUSH
108343: FOR_IN
108344: IFFALSE 108413
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108346: LD_ADDR_VAR 0 6
108350: PUSH
108351: LD_VAR 0 1
108355: PPUSH
108356: LD_VAR 0 4
108360: PUSH
108361: LD_INT 1
108363: ARRAY
108364: PPUSH
108365: LD_VAR 0 4
108369: PUSH
108370: LD_INT 2
108372: ARRAY
108373: PPUSH
108374: CALL_OW 297
108378: ST_TO_ADDR
// if tmpDist < dist then
108379: LD_VAR 0 6
108383: PUSH
108384: LD_VAR 0 5
108388: LESS
108389: IFFALSE 108411
// begin result := i ;
108391: LD_ADDR_VAR 0 3
108395: PUSH
108396: LD_VAR 0 4
108400: ST_TO_ADDR
// dist := tmpDist ;
108401: LD_ADDR_VAR 0 5
108405: PUSH
108406: LD_VAR 0 6
108410: ST_TO_ADDR
// end ; end ;
108411: GO 108343
108413: POP
108414: POP
// end ;
108415: LD_VAR 0 3
108419: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108420: LD_INT 0
108422: PPUSH
// uc_side := side ;
108423: LD_ADDR_OWVAR 20
108427: PUSH
108428: LD_VAR 0 1
108432: ST_TO_ADDR
// uc_nation := 3 ;
108433: LD_ADDR_OWVAR 21
108437: PUSH
108438: LD_INT 3
108440: ST_TO_ADDR
// vc_chassis := 25 ;
108441: LD_ADDR_OWVAR 37
108445: PUSH
108446: LD_INT 25
108448: ST_TO_ADDR
// vc_engine := engine_siberite ;
108449: LD_ADDR_OWVAR 39
108453: PUSH
108454: LD_INT 3
108456: ST_TO_ADDR
// vc_control := control_computer ;
108457: LD_ADDR_OWVAR 38
108461: PUSH
108462: LD_INT 3
108464: ST_TO_ADDR
// vc_weapon := 59 ;
108465: LD_ADDR_OWVAR 40
108469: PUSH
108470: LD_INT 59
108472: ST_TO_ADDR
// result := CreateVehicle ;
108473: LD_ADDR_VAR 0 5
108477: PUSH
108478: CALL_OW 45
108482: ST_TO_ADDR
// SetDir ( result , d ) ;
108483: LD_VAR 0 5
108487: PPUSH
108488: LD_VAR 0 4
108492: PPUSH
108493: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108497: LD_VAR 0 5
108501: PPUSH
108502: LD_VAR 0 2
108506: PPUSH
108507: LD_VAR 0 3
108511: PPUSH
108512: LD_INT 0
108514: PPUSH
108515: CALL_OW 48
// end ;
108519: LD_VAR 0 5
108523: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108524: LD_INT 0
108526: PPUSH
108527: PPUSH
108528: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108529: LD_ADDR_VAR 0 2
108533: PUSH
108534: LD_INT 0
108536: PUSH
108537: LD_INT 0
108539: PUSH
108540: LD_INT 0
108542: PUSH
108543: LD_INT 0
108545: PUSH
108546: EMPTY
108547: LIST
108548: LIST
108549: LIST
108550: LIST
108551: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108552: LD_VAR 0 1
108556: NOT
108557: PUSH
108558: LD_VAR 0 1
108562: PPUSH
108563: CALL_OW 264
108567: PUSH
108568: LD_INT 12
108570: PUSH
108571: LD_INT 51
108573: PUSH
108574: LD_INT 32
108576: PUSH
108577: LD_INT 89
108579: PUSH
108580: EMPTY
108581: LIST
108582: LIST
108583: LIST
108584: LIST
108585: IN
108586: NOT
108587: OR
108588: IFFALSE 108592
// exit ;
108590: GO 108690
// for i := 1 to 3 do
108592: LD_ADDR_VAR 0 3
108596: PUSH
108597: DOUBLE
108598: LD_INT 1
108600: DEC
108601: ST_TO_ADDR
108602: LD_INT 3
108604: PUSH
108605: FOR_TO
108606: IFFALSE 108688
// begin tmp := GetCargo ( cargo , i ) ;
108608: LD_ADDR_VAR 0 4
108612: PUSH
108613: LD_VAR 0 1
108617: PPUSH
108618: LD_VAR 0 3
108622: PPUSH
108623: CALL_OW 289
108627: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108628: LD_ADDR_VAR 0 2
108632: PUSH
108633: LD_VAR 0 2
108637: PPUSH
108638: LD_VAR 0 3
108642: PPUSH
108643: LD_VAR 0 4
108647: PPUSH
108648: CALL_OW 1
108652: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108653: LD_ADDR_VAR 0 2
108657: PUSH
108658: LD_VAR 0 2
108662: PPUSH
108663: LD_INT 4
108665: PPUSH
108666: LD_VAR 0 2
108670: PUSH
108671: LD_INT 4
108673: ARRAY
108674: PUSH
108675: LD_VAR 0 4
108679: PLUS
108680: PPUSH
108681: CALL_OW 1
108685: ST_TO_ADDR
// end ;
108686: GO 108605
108688: POP
108689: POP
// end ;
108690: LD_VAR 0 2
108694: RET
// export function Length ( array ) ; begin
108695: LD_INT 0
108697: PPUSH
// result := array + 0 ;
108698: LD_ADDR_VAR 0 2
108702: PUSH
108703: LD_VAR 0 1
108707: PUSH
108708: LD_INT 0
108710: PLUS
108711: ST_TO_ADDR
// end ;
108712: LD_VAR 0 2
108716: RET
// export function PrepareArray ( array ) ; begin
108717: LD_INT 0
108719: PPUSH
// result := array diff 0 ;
108720: LD_ADDR_VAR 0 2
108724: PUSH
108725: LD_VAR 0 1
108729: PUSH
108730: LD_INT 0
108732: DIFF
108733: ST_TO_ADDR
// if not result [ 1 ] then
108734: LD_VAR 0 2
108738: PUSH
108739: LD_INT 1
108741: ARRAY
108742: NOT
108743: IFFALSE 108763
// result := Delete ( result , 1 ) ;
108745: LD_ADDR_VAR 0 2
108749: PUSH
108750: LD_VAR 0 2
108754: PPUSH
108755: LD_INT 1
108757: PPUSH
108758: CALL_OW 3
108762: ST_TO_ADDR
// end ;
108763: LD_VAR 0 2
108767: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108768: LD_INT 0
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
// sibRocketRange := 25 ;
108774: LD_ADDR_VAR 0 6
108778: PUSH
108779: LD_INT 25
108781: ST_TO_ADDR
// result := false ;
108782: LD_ADDR_VAR 0 4
108786: PUSH
108787: LD_INT 0
108789: ST_TO_ADDR
// for i := 0 to 5 do
108790: LD_ADDR_VAR 0 5
108794: PUSH
108795: DOUBLE
108796: LD_INT 0
108798: DEC
108799: ST_TO_ADDR
108800: LD_INT 5
108802: PUSH
108803: FOR_TO
108804: IFFALSE 108871
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108806: LD_VAR 0 1
108810: PPUSH
108811: LD_VAR 0 5
108815: PPUSH
108816: LD_VAR 0 6
108820: PPUSH
108821: CALL_OW 272
108825: PPUSH
108826: LD_VAR 0 2
108830: PPUSH
108831: LD_VAR 0 5
108835: PPUSH
108836: LD_VAR 0 6
108840: PPUSH
108841: CALL_OW 273
108845: PPUSH
108846: LD_VAR 0 3
108850: PPUSH
108851: CALL_OW 309
108855: IFFALSE 108869
// begin result := true ;
108857: LD_ADDR_VAR 0 4
108861: PUSH
108862: LD_INT 1
108864: ST_TO_ADDR
// exit ;
108865: POP
108866: POP
108867: GO 108873
// end ;
108869: GO 108803
108871: POP
108872: POP
// end ;
108873: LD_VAR 0 4
108877: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
108878: LD_INT 0
108880: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
108881: LD_VAR 0 1
108885: PPUSH
108886: LD_VAR 0 2
108890: PPUSH
108891: LD_INT 0
108893: PPUSH
108894: LD_INT 0
108896: PPUSH
108897: LD_INT 1
108899: PPUSH
108900: LD_INT 0
108902: PPUSH
108903: CALL_OW 587
// end ; end_of_file end_of_file
108907: LD_VAR 0 3
108911: RET
// every 0 0$1 do
108912: GO 108914
108914: DISABLE
// begin enable ;
108915: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108916: LD_STRING updateTimer(
108918: PUSH
108919: LD_OWVAR 1
108923: STR
108924: PUSH
108925: LD_STRING );
108927: STR
108928: PPUSH
108929: CALL_OW 559
// end ;
108933: END
// export function SOS_MapStart ( ) ; begin
108934: LD_INT 0
108936: PPUSH
// if streamModeActive then
108937: LD_EXP 144
108941: IFFALSE 108950
// DefineStreamItems ( true ) ;
108943: LD_INT 1
108945: PPUSH
108946: CALL 110604 0 1
// UpdateFactoryWaypoints ( ) ;
108950: CALL 123465 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108954: CALL 123722 0 0
// end ;
108958: LD_VAR 0 1
108962: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108963: LD_INT 0
108965: PPUSH
// if p2 = hack_mode then
108966: LD_VAR 0 2
108970: PUSH
108971: LD_INT 100
108973: EQUAL
108974: IFFALSE 109977
// begin if not StreamModeActive then
108976: LD_EXP 144
108980: NOT
108981: IFFALSE 108991
// StreamModeActive := true ;
108983: LD_ADDR_EXP 144
108987: PUSH
108988: LD_INT 1
108990: ST_TO_ADDR
// if p3 = 0 then
108991: LD_VAR 0 3
108995: PUSH
108996: LD_INT 0
108998: EQUAL
108999: IFFALSE 109005
// InitStreamMode ;
109001: CALL 110140 0 0
// if p3 = 1 then
109005: LD_VAR 0 3
109009: PUSH
109010: LD_INT 1
109012: EQUAL
109013: IFFALSE 109023
// sRocket := true ;
109015: LD_ADDR_EXP 149
109019: PUSH
109020: LD_INT 1
109022: ST_TO_ADDR
// if p3 = 2 then
109023: LD_VAR 0 3
109027: PUSH
109028: LD_INT 2
109030: EQUAL
109031: IFFALSE 109041
// sSpeed := true ;
109033: LD_ADDR_EXP 148
109037: PUSH
109038: LD_INT 1
109040: ST_TO_ADDR
// if p3 = 3 then
109041: LD_VAR 0 3
109045: PUSH
109046: LD_INT 3
109048: EQUAL
109049: IFFALSE 109059
// sEngine := true ;
109051: LD_ADDR_EXP 150
109055: PUSH
109056: LD_INT 1
109058: ST_TO_ADDR
// if p3 = 4 then
109059: LD_VAR 0 3
109063: PUSH
109064: LD_INT 4
109066: EQUAL
109067: IFFALSE 109077
// sSpec := true ;
109069: LD_ADDR_EXP 147
109073: PUSH
109074: LD_INT 1
109076: ST_TO_ADDR
// if p3 = 5 then
109077: LD_VAR 0 3
109081: PUSH
109082: LD_INT 5
109084: EQUAL
109085: IFFALSE 109095
// sLevel := true ;
109087: LD_ADDR_EXP 151
109091: PUSH
109092: LD_INT 1
109094: ST_TO_ADDR
// if p3 = 6 then
109095: LD_VAR 0 3
109099: PUSH
109100: LD_INT 6
109102: EQUAL
109103: IFFALSE 109113
// sArmoury := true ;
109105: LD_ADDR_EXP 152
109109: PUSH
109110: LD_INT 1
109112: ST_TO_ADDR
// if p3 = 7 then
109113: LD_VAR 0 3
109117: PUSH
109118: LD_INT 7
109120: EQUAL
109121: IFFALSE 109131
// sRadar := true ;
109123: LD_ADDR_EXP 153
109127: PUSH
109128: LD_INT 1
109130: ST_TO_ADDR
// if p3 = 8 then
109131: LD_VAR 0 3
109135: PUSH
109136: LD_INT 8
109138: EQUAL
109139: IFFALSE 109149
// sBunker := true ;
109141: LD_ADDR_EXP 154
109145: PUSH
109146: LD_INT 1
109148: ST_TO_ADDR
// if p3 = 9 then
109149: LD_VAR 0 3
109153: PUSH
109154: LD_INT 9
109156: EQUAL
109157: IFFALSE 109167
// sHack := true ;
109159: LD_ADDR_EXP 155
109163: PUSH
109164: LD_INT 1
109166: ST_TO_ADDR
// if p3 = 10 then
109167: LD_VAR 0 3
109171: PUSH
109172: LD_INT 10
109174: EQUAL
109175: IFFALSE 109185
// sFire := true ;
109177: LD_ADDR_EXP 156
109181: PUSH
109182: LD_INT 1
109184: ST_TO_ADDR
// if p3 = 11 then
109185: LD_VAR 0 3
109189: PUSH
109190: LD_INT 11
109192: EQUAL
109193: IFFALSE 109203
// sRefresh := true ;
109195: LD_ADDR_EXP 157
109199: PUSH
109200: LD_INT 1
109202: ST_TO_ADDR
// if p3 = 12 then
109203: LD_VAR 0 3
109207: PUSH
109208: LD_INT 12
109210: EQUAL
109211: IFFALSE 109221
// sExp := true ;
109213: LD_ADDR_EXP 158
109217: PUSH
109218: LD_INT 1
109220: ST_TO_ADDR
// if p3 = 13 then
109221: LD_VAR 0 3
109225: PUSH
109226: LD_INT 13
109228: EQUAL
109229: IFFALSE 109239
// sDepot := true ;
109231: LD_ADDR_EXP 159
109235: PUSH
109236: LD_INT 1
109238: ST_TO_ADDR
// if p3 = 14 then
109239: LD_VAR 0 3
109243: PUSH
109244: LD_INT 14
109246: EQUAL
109247: IFFALSE 109257
// sFlag := true ;
109249: LD_ADDR_EXP 160
109253: PUSH
109254: LD_INT 1
109256: ST_TO_ADDR
// if p3 = 15 then
109257: LD_VAR 0 3
109261: PUSH
109262: LD_INT 15
109264: EQUAL
109265: IFFALSE 109275
// sKamikadze := true ;
109267: LD_ADDR_EXP 168
109271: PUSH
109272: LD_INT 1
109274: ST_TO_ADDR
// if p3 = 16 then
109275: LD_VAR 0 3
109279: PUSH
109280: LD_INT 16
109282: EQUAL
109283: IFFALSE 109293
// sTroll := true ;
109285: LD_ADDR_EXP 169
109289: PUSH
109290: LD_INT 1
109292: ST_TO_ADDR
// if p3 = 17 then
109293: LD_VAR 0 3
109297: PUSH
109298: LD_INT 17
109300: EQUAL
109301: IFFALSE 109311
// sSlow := true ;
109303: LD_ADDR_EXP 170
109307: PUSH
109308: LD_INT 1
109310: ST_TO_ADDR
// if p3 = 18 then
109311: LD_VAR 0 3
109315: PUSH
109316: LD_INT 18
109318: EQUAL
109319: IFFALSE 109329
// sLack := true ;
109321: LD_ADDR_EXP 171
109325: PUSH
109326: LD_INT 1
109328: ST_TO_ADDR
// if p3 = 19 then
109329: LD_VAR 0 3
109333: PUSH
109334: LD_INT 19
109336: EQUAL
109337: IFFALSE 109347
// sTank := true ;
109339: LD_ADDR_EXP 173
109343: PUSH
109344: LD_INT 1
109346: ST_TO_ADDR
// if p3 = 20 then
109347: LD_VAR 0 3
109351: PUSH
109352: LD_INT 20
109354: EQUAL
109355: IFFALSE 109365
// sRemote := true ;
109357: LD_ADDR_EXP 174
109361: PUSH
109362: LD_INT 1
109364: ST_TO_ADDR
// if p3 = 21 then
109365: LD_VAR 0 3
109369: PUSH
109370: LD_INT 21
109372: EQUAL
109373: IFFALSE 109383
// sPowell := true ;
109375: LD_ADDR_EXP 175
109379: PUSH
109380: LD_INT 1
109382: ST_TO_ADDR
// if p3 = 22 then
109383: LD_VAR 0 3
109387: PUSH
109388: LD_INT 22
109390: EQUAL
109391: IFFALSE 109401
// sTeleport := true ;
109393: LD_ADDR_EXP 178
109397: PUSH
109398: LD_INT 1
109400: ST_TO_ADDR
// if p3 = 23 then
109401: LD_VAR 0 3
109405: PUSH
109406: LD_INT 23
109408: EQUAL
109409: IFFALSE 109419
// sOilTower := true ;
109411: LD_ADDR_EXP 180
109415: PUSH
109416: LD_INT 1
109418: ST_TO_ADDR
// if p3 = 24 then
109419: LD_VAR 0 3
109423: PUSH
109424: LD_INT 24
109426: EQUAL
109427: IFFALSE 109437
// sShovel := true ;
109429: LD_ADDR_EXP 181
109433: PUSH
109434: LD_INT 1
109436: ST_TO_ADDR
// if p3 = 25 then
109437: LD_VAR 0 3
109441: PUSH
109442: LD_INT 25
109444: EQUAL
109445: IFFALSE 109455
// sSheik := true ;
109447: LD_ADDR_EXP 182
109451: PUSH
109452: LD_INT 1
109454: ST_TO_ADDR
// if p3 = 26 then
109455: LD_VAR 0 3
109459: PUSH
109460: LD_INT 26
109462: EQUAL
109463: IFFALSE 109473
// sEarthquake := true ;
109465: LD_ADDR_EXP 184
109469: PUSH
109470: LD_INT 1
109472: ST_TO_ADDR
// if p3 = 27 then
109473: LD_VAR 0 3
109477: PUSH
109478: LD_INT 27
109480: EQUAL
109481: IFFALSE 109491
// sAI := true ;
109483: LD_ADDR_EXP 185
109487: PUSH
109488: LD_INT 1
109490: ST_TO_ADDR
// if p3 = 28 then
109491: LD_VAR 0 3
109495: PUSH
109496: LD_INT 28
109498: EQUAL
109499: IFFALSE 109509
// sCargo := true ;
109501: LD_ADDR_EXP 188
109505: PUSH
109506: LD_INT 1
109508: ST_TO_ADDR
// if p3 = 29 then
109509: LD_VAR 0 3
109513: PUSH
109514: LD_INT 29
109516: EQUAL
109517: IFFALSE 109527
// sDLaser := true ;
109519: LD_ADDR_EXP 189
109523: PUSH
109524: LD_INT 1
109526: ST_TO_ADDR
// if p3 = 30 then
109527: LD_VAR 0 3
109531: PUSH
109532: LD_INT 30
109534: EQUAL
109535: IFFALSE 109545
// sExchange := true ;
109537: LD_ADDR_EXP 190
109541: PUSH
109542: LD_INT 1
109544: ST_TO_ADDR
// if p3 = 31 then
109545: LD_VAR 0 3
109549: PUSH
109550: LD_INT 31
109552: EQUAL
109553: IFFALSE 109563
// sFac := true ;
109555: LD_ADDR_EXP 191
109559: PUSH
109560: LD_INT 1
109562: ST_TO_ADDR
// if p3 = 32 then
109563: LD_VAR 0 3
109567: PUSH
109568: LD_INT 32
109570: EQUAL
109571: IFFALSE 109581
// sPower := true ;
109573: LD_ADDR_EXP 192
109577: PUSH
109578: LD_INT 1
109580: ST_TO_ADDR
// if p3 = 33 then
109581: LD_VAR 0 3
109585: PUSH
109586: LD_INT 33
109588: EQUAL
109589: IFFALSE 109599
// sRandom := true ;
109591: LD_ADDR_EXP 193
109595: PUSH
109596: LD_INT 1
109598: ST_TO_ADDR
// if p3 = 34 then
109599: LD_VAR 0 3
109603: PUSH
109604: LD_INT 34
109606: EQUAL
109607: IFFALSE 109617
// sShield := true ;
109609: LD_ADDR_EXP 194
109613: PUSH
109614: LD_INT 1
109616: ST_TO_ADDR
// if p3 = 35 then
109617: LD_VAR 0 3
109621: PUSH
109622: LD_INT 35
109624: EQUAL
109625: IFFALSE 109635
// sTime := true ;
109627: LD_ADDR_EXP 195
109631: PUSH
109632: LD_INT 1
109634: ST_TO_ADDR
// if p3 = 36 then
109635: LD_VAR 0 3
109639: PUSH
109640: LD_INT 36
109642: EQUAL
109643: IFFALSE 109653
// sTools := true ;
109645: LD_ADDR_EXP 196
109649: PUSH
109650: LD_INT 1
109652: ST_TO_ADDR
// if p3 = 101 then
109653: LD_VAR 0 3
109657: PUSH
109658: LD_INT 101
109660: EQUAL
109661: IFFALSE 109671
// sSold := true ;
109663: LD_ADDR_EXP 161
109667: PUSH
109668: LD_INT 1
109670: ST_TO_ADDR
// if p3 = 102 then
109671: LD_VAR 0 3
109675: PUSH
109676: LD_INT 102
109678: EQUAL
109679: IFFALSE 109689
// sDiff := true ;
109681: LD_ADDR_EXP 162
109685: PUSH
109686: LD_INT 1
109688: ST_TO_ADDR
// if p3 = 103 then
109689: LD_VAR 0 3
109693: PUSH
109694: LD_INT 103
109696: EQUAL
109697: IFFALSE 109707
// sFog := true ;
109699: LD_ADDR_EXP 165
109703: PUSH
109704: LD_INT 1
109706: ST_TO_ADDR
// if p3 = 104 then
109707: LD_VAR 0 3
109711: PUSH
109712: LD_INT 104
109714: EQUAL
109715: IFFALSE 109725
// sReset := true ;
109717: LD_ADDR_EXP 166
109721: PUSH
109722: LD_INT 1
109724: ST_TO_ADDR
// if p3 = 105 then
109725: LD_VAR 0 3
109729: PUSH
109730: LD_INT 105
109732: EQUAL
109733: IFFALSE 109743
// sSun := true ;
109735: LD_ADDR_EXP 167
109739: PUSH
109740: LD_INT 1
109742: ST_TO_ADDR
// if p3 = 106 then
109743: LD_VAR 0 3
109747: PUSH
109748: LD_INT 106
109750: EQUAL
109751: IFFALSE 109761
// sTiger := true ;
109753: LD_ADDR_EXP 163
109757: PUSH
109758: LD_INT 1
109760: ST_TO_ADDR
// if p3 = 107 then
109761: LD_VAR 0 3
109765: PUSH
109766: LD_INT 107
109768: EQUAL
109769: IFFALSE 109779
// sBomb := true ;
109771: LD_ADDR_EXP 164
109775: PUSH
109776: LD_INT 1
109778: ST_TO_ADDR
// if p3 = 108 then
109779: LD_VAR 0 3
109783: PUSH
109784: LD_INT 108
109786: EQUAL
109787: IFFALSE 109797
// sWound := true ;
109789: LD_ADDR_EXP 172
109793: PUSH
109794: LD_INT 1
109796: ST_TO_ADDR
// if p3 = 109 then
109797: LD_VAR 0 3
109801: PUSH
109802: LD_INT 109
109804: EQUAL
109805: IFFALSE 109815
// sBetray := true ;
109807: LD_ADDR_EXP 176
109811: PUSH
109812: LD_INT 1
109814: ST_TO_ADDR
// if p3 = 110 then
109815: LD_VAR 0 3
109819: PUSH
109820: LD_INT 110
109822: EQUAL
109823: IFFALSE 109833
// sContamin := true ;
109825: LD_ADDR_EXP 177
109829: PUSH
109830: LD_INT 1
109832: ST_TO_ADDR
// if p3 = 111 then
109833: LD_VAR 0 3
109837: PUSH
109838: LD_INT 111
109840: EQUAL
109841: IFFALSE 109851
// sOil := true ;
109843: LD_ADDR_EXP 179
109847: PUSH
109848: LD_INT 1
109850: ST_TO_ADDR
// if p3 = 112 then
109851: LD_VAR 0 3
109855: PUSH
109856: LD_INT 112
109858: EQUAL
109859: IFFALSE 109869
// sStu := true ;
109861: LD_ADDR_EXP 183
109865: PUSH
109866: LD_INT 1
109868: ST_TO_ADDR
// if p3 = 113 then
109869: LD_VAR 0 3
109873: PUSH
109874: LD_INT 113
109876: EQUAL
109877: IFFALSE 109887
// sBazooka := true ;
109879: LD_ADDR_EXP 186
109883: PUSH
109884: LD_INT 1
109886: ST_TO_ADDR
// if p3 = 114 then
109887: LD_VAR 0 3
109891: PUSH
109892: LD_INT 114
109894: EQUAL
109895: IFFALSE 109905
// sMortar := true ;
109897: LD_ADDR_EXP 187
109901: PUSH
109902: LD_INT 1
109904: ST_TO_ADDR
// if p3 = 115 then
109905: LD_VAR 0 3
109909: PUSH
109910: LD_INT 115
109912: EQUAL
109913: IFFALSE 109923
// sRanger := true ;
109915: LD_ADDR_EXP 197
109919: PUSH
109920: LD_INT 1
109922: ST_TO_ADDR
// if p3 = 116 then
109923: LD_VAR 0 3
109927: PUSH
109928: LD_INT 116
109930: EQUAL
109931: IFFALSE 109941
// sComputer := true ;
109933: LD_ADDR_EXP 198
109937: PUSH
109938: LD_INT 1
109940: ST_TO_ADDR
// if p3 = 117 then
109941: LD_VAR 0 3
109945: PUSH
109946: LD_INT 117
109948: EQUAL
109949: IFFALSE 109959
// s30 := true ;
109951: LD_ADDR_EXP 199
109955: PUSH
109956: LD_INT 1
109958: ST_TO_ADDR
// if p3 = 118 then
109959: LD_VAR 0 3
109963: PUSH
109964: LD_INT 118
109966: EQUAL
109967: IFFALSE 109977
// s60 := true ;
109969: LD_ADDR_EXP 200
109973: PUSH
109974: LD_INT 1
109976: ST_TO_ADDR
// end ; if p2 = stream_mode then
109977: LD_VAR 0 2
109981: PUSH
109982: LD_INT 101
109984: EQUAL
109985: IFFALSE 110113
// begin case p3 of 1 :
109987: LD_VAR 0 3
109991: PUSH
109992: LD_INT 1
109994: DOUBLE
109995: EQUAL
109996: IFTRUE 110000
109998: GO 110007
110000: POP
// hHackUnlimitedResources ; 2 :
110001: CALL 122211 0 0
110005: GO 110113
110007: LD_INT 2
110009: DOUBLE
110010: EQUAL
110011: IFTRUE 110015
110013: GO 110022
110015: POP
// hHackSetLevel10 ; 3 :
110016: CALL 122344 0 0
110020: GO 110113
110022: LD_INT 3
110024: DOUBLE
110025: EQUAL
110026: IFTRUE 110030
110028: GO 110037
110030: POP
// hHackSetLevel10YourUnits ; 4 :
110031: CALL 122429 0 0
110035: GO 110113
110037: LD_INT 4
110039: DOUBLE
110040: EQUAL
110041: IFTRUE 110045
110043: GO 110052
110045: POP
// hHackInvincible ; 5 :
110046: CALL 122877 0 0
110050: GO 110113
110052: LD_INT 5
110054: DOUBLE
110055: EQUAL
110056: IFTRUE 110060
110058: GO 110067
110060: POP
// hHackInvisible ; 6 :
110061: CALL 122988 0 0
110065: GO 110113
110067: LD_INT 6
110069: DOUBLE
110070: EQUAL
110071: IFTRUE 110075
110073: GO 110082
110075: POP
// hHackChangeYourSide ; 7 :
110076: CALL 123045 0 0
110080: GO 110113
110082: LD_INT 7
110084: DOUBLE
110085: EQUAL
110086: IFTRUE 110090
110088: GO 110097
110090: POP
// hHackChangeUnitSide ; 8 :
110091: CALL 123087 0 0
110095: GO 110113
110097: LD_INT 8
110099: DOUBLE
110100: EQUAL
110101: IFTRUE 110105
110103: GO 110112
110105: POP
// hHackFog ; end ;
110106: CALL 123188 0 0
110110: GO 110113
110112: POP
// end ; end ;
110113: LD_VAR 0 7
110117: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
110118: GO 110120
110120: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
110121: LD_STRING initStreamRollete();
110123: PPUSH
110124: CALL_OW 559
// InitStreamMode ;
110128: CALL 110140 0 0
// DefineStreamItems ( false ) ;
110132: LD_INT 0
110134: PPUSH
110135: CALL 110604 0 1
// end ;
110139: END
// function InitStreamMode ; begin
110140: LD_INT 0
110142: PPUSH
// streamModeActive := false ;
110143: LD_ADDR_EXP 144
110147: PUSH
110148: LD_INT 0
110150: ST_TO_ADDR
// normalCounter := 36 ;
110151: LD_ADDR_EXP 145
110155: PUSH
110156: LD_INT 36
110158: ST_TO_ADDR
// hardcoreCounter := 18 ;
110159: LD_ADDR_EXP 146
110163: PUSH
110164: LD_INT 18
110166: ST_TO_ADDR
// sRocket := false ;
110167: LD_ADDR_EXP 149
110171: PUSH
110172: LD_INT 0
110174: ST_TO_ADDR
// sSpeed := false ;
110175: LD_ADDR_EXP 148
110179: PUSH
110180: LD_INT 0
110182: ST_TO_ADDR
// sEngine := false ;
110183: LD_ADDR_EXP 150
110187: PUSH
110188: LD_INT 0
110190: ST_TO_ADDR
// sSpec := false ;
110191: LD_ADDR_EXP 147
110195: PUSH
110196: LD_INT 0
110198: ST_TO_ADDR
// sLevel := false ;
110199: LD_ADDR_EXP 151
110203: PUSH
110204: LD_INT 0
110206: ST_TO_ADDR
// sArmoury := false ;
110207: LD_ADDR_EXP 152
110211: PUSH
110212: LD_INT 0
110214: ST_TO_ADDR
// sRadar := false ;
110215: LD_ADDR_EXP 153
110219: PUSH
110220: LD_INT 0
110222: ST_TO_ADDR
// sBunker := false ;
110223: LD_ADDR_EXP 154
110227: PUSH
110228: LD_INT 0
110230: ST_TO_ADDR
// sHack := false ;
110231: LD_ADDR_EXP 155
110235: PUSH
110236: LD_INT 0
110238: ST_TO_ADDR
// sFire := false ;
110239: LD_ADDR_EXP 156
110243: PUSH
110244: LD_INT 0
110246: ST_TO_ADDR
// sRefresh := false ;
110247: LD_ADDR_EXP 157
110251: PUSH
110252: LD_INT 0
110254: ST_TO_ADDR
// sExp := false ;
110255: LD_ADDR_EXP 158
110259: PUSH
110260: LD_INT 0
110262: ST_TO_ADDR
// sDepot := false ;
110263: LD_ADDR_EXP 159
110267: PUSH
110268: LD_INT 0
110270: ST_TO_ADDR
// sFlag := false ;
110271: LD_ADDR_EXP 160
110275: PUSH
110276: LD_INT 0
110278: ST_TO_ADDR
// sKamikadze := false ;
110279: LD_ADDR_EXP 168
110283: PUSH
110284: LD_INT 0
110286: ST_TO_ADDR
// sTroll := false ;
110287: LD_ADDR_EXP 169
110291: PUSH
110292: LD_INT 0
110294: ST_TO_ADDR
// sSlow := false ;
110295: LD_ADDR_EXP 170
110299: PUSH
110300: LD_INT 0
110302: ST_TO_ADDR
// sLack := false ;
110303: LD_ADDR_EXP 171
110307: PUSH
110308: LD_INT 0
110310: ST_TO_ADDR
// sTank := false ;
110311: LD_ADDR_EXP 173
110315: PUSH
110316: LD_INT 0
110318: ST_TO_ADDR
// sRemote := false ;
110319: LD_ADDR_EXP 174
110323: PUSH
110324: LD_INT 0
110326: ST_TO_ADDR
// sPowell := false ;
110327: LD_ADDR_EXP 175
110331: PUSH
110332: LD_INT 0
110334: ST_TO_ADDR
// sTeleport := false ;
110335: LD_ADDR_EXP 178
110339: PUSH
110340: LD_INT 0
110342: ST_TO_ADDR
// sOilTower := false ;
110343: LD_ADDR_EXP 180
110347: PUSH
110348: LD_INT 0
110350: ST_TO_ADDR
// sShovel := false ;
110351: LD_ADDR_EXP 181
110355: PUSH
110356: LD_INT 0
110358: ST_TO_ADDR
// sSheik := false ;
110359: LD_ADDR_EXP 182
110363: PUSH
110364: LD_INT 0
110366: ST_TO_ADDR
// sEarthquake := false ;
110367: LD_ADDR_EXP 184
110371: PUSH
110372: LD_INT 0
110374: ST_TO_ADDR
// sAI := false ;
110375: LD_ADDR_EXP 185
110379: PUSH
110380: LD_INT 0
110382: ST_TO_ADDR
// sCargo := false ;
110383: LD_ADDR_EXP 188
110387: PUSH
110388: LD_INT 0
110390: ST_TO_ADDR
// sDLaser := false ;
110391: LD_ADDR_EXP 189
110395: PUSH
110396: LD_INT 0
110398: ST_TO_ADDR
// sExchange := false ;
110399: LD_ADDR_EXP 190
110403: PUSH
110404: LD_INT 0
110406: ST_TO_ADDR
// sFac := false ;
110407: LD_ADDR_EXP 191
110411: PUSH
110412: LD_INT 0
110414: ST_TO_ADDR
// sPower := false ;
110415: LD_ADDR_EXP 192
110419: PUSH
110420: LD_INT 0
110422: ST_TO_ADDR
// sRandom := false ;
110423: LD_ADDR_EXP 193
110427: PUSH
110428: LD_INT 0
110430: ST_TO_ADDR
// sShield := false ;
110431: LD_ADDR_EXP 194
110435: PUSH
110436: LD_INT 0
110438: ST_TO_ADDR
// sTime := false ;
110439: LD_ADDR_EXP 195
110443: PUSH
110444: LD_INT 0
110446: ST_TO_ADDR
// sTools := false ;
110447: LD_ADDR_EXP 196
110451: PUSH
110452: LD_INT 0
110454: ST_TO_ADDR
// sSold := false ;
110455: LD_ADDR_EXP 161
110459: PUSH
110460: LD_INT 0
110462: ST_TO_ADDR
// sDiff := false ;
110463: LD_ADDR_EXP 162
110467: PUSH
110468: LD_INT 0
110470: ST_TO_ADDR
// sFog := false ;
110471: LD_ADDR_EXP 165
110475: PUSH
110476: LD_INT 0
110478: ST_TO_ADDR
// sReset := false ;
110479: LD_ADDR_EXP 166
110483: PUSH
110484: LD_INT 0
110486: ST_TO_ADDR
// sSun := false ;
110487: LD_ADDR_EXP 167
110491: PUSH
110492: LD_INT 0
110494: ST_TO_ADDR
// sTiger := false ;
110495: LD_ADDR_EXP 163
110499: PUSH
110500: LD_INT 0
110502: ST_TO_ADDR
// sBomb := false ;
110503: LD_ADDR_EXP 164
110507: PUSH
110508: LD_INT 0
110510: ST_TO_ADDR
// sWound := false ;
110511: LD_ADDR_EXP 172
110515: PUSH
110516: LD_INT 0
110518: ST_TO_ADDR
// sBetray := false ;
110519: LD_ADDR_EXP 176
110523: PUSH
110524: LD_INT 0
110526: ST_TO_ADDR
// sContamin := false ;
110527: LD_ADDR_EXP 177
110531: PUSH
110532: LD_INT 0
110534: ST_TO_ADDR
// sOil := false ;
110535: LD_ADDR_EXP 179
110539: PUSH
110540: LD_INT 0
110542: ST_TO_ADDR
// sStu := false ;
110543: LD_ADDR_EXP 183
110547: PUSH
110548: LD_INT 0
110550: ST_TO_ADDR
// sBazooka := false ;
110551: LD_ADDR_EXP 186
110555: PUSH
110556: LD_INT 0
110558: ST_TO_ADDR
// sMortar := false ;
110559: LD_ADDR_EXP 187
110563: PUSH
110564: LD_INT 0
110566: ST_TO_ADDR
// sRanger := false ;
110567: LD_ADDR_EXP 197
110571: PUSH
110572: LD_INT 0
110574: ST_TO_ADDR
// sComputer := false ;
110575: LD_ADDR_EXP 198
110579: PUSH
110580: LD_INT 0
110582: ST_TO_ADDR
// s30 := false ;
110583: LD_ADDR_EXP 199
110587: PUSH
110588: LD_INT 0
110590: ST_TO_ADDR
// s60 := false ;
110591: LD_ADDR_EXP 200
110595: PUSH
110596: LD_INT 0
110598: ST_TO_ADDR
// end ;
110599: LD_VAR 0 1
110603: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110604: LD_INT 0
110606: PPUSH
110607: PPUSH
110608: PPUSH
110609: PPUSH
110610: PPUSH
110611: PPUSH
110612: PPUSH
// result := [ ] ;
110613: LD_ADDR_VAR 0 2
110617: PUSH
110618: EMPTY
110619: ST_TO_ADDR
// if campaign_id = 1 then
110620: LD_OWVAR 69
110624: PUSH
110625: LD_INT 1
110627: EQUAL
110628: IFFALSE 113794
// begin case mission_number of 1 :
110630: LD_OWVAR 70
110634: PUSH
110635: LD_INT 1
110637: DOUBLE
110638: EQUAL
110639: IFTRUE 110643
110641: GO 110719
110643: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110644: LD_ADDR_VAR 0 2
110648: PUSH
110649: LD_INT 2
110651: PUSH
110652: LD_INT 4
110654: PUSH
110655: LD_INT 11
110657: PUSH
110658: LD_INT 12
110660: PUSH
110661: LD_INT 15
110663: PUSH
110664: LD_INT 16
110666: PUSH
110667: LD_INT 22
110669: PUSH
110670: LD_INT 23
110672: PUSH
110673: LD_INT 26
110675: PUSH
110676: EMPTY
110677: LIST
110678: LIST
110679: LIST
110680: LIST
110681: LIST
110682: LIST
110683: LIST
110684: LIST
110685: LIST
110686: PUSH
110687: LD_INT 101
110689: PUSH
110690: LD_INT 102
110692: PUSH
110693: LD_INT 106
110695: PUSH
110696: LD_INT 116
110698: PUSH
110699: LD_INT 117
110701: PUSH
110702: LD_INT 118
110704: PUSH
110705: EMPTY
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: LIST
110711: LIST
110712: PUSH
110713: EMPTY
110714: LIST
110715: LIST
110716: ST_TO_ADDR
110717: GO 113792
110719: LD_INT 2
110721: DOUBLE
110722: EQUAL
110723: IFTRUE 110727
110725: GO 110811
110727: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110728: LD_ADDR_VAR 0 2
110732: PUSH
110733: LD_INT 2
110735: PUSH
110736: LD_INT 4
110738: PUSH
110739: LD_INT 11
110741: PUSH
110742: LD_INT 12
110744: PUSH
110745: LD_INT 15
110747: PUSH
110748: LD_INT 16
110750: PUSH
110751: LD_INT 22
110753: PUSH
110754: LD_INT 23
110756: PUSH
110757: LD_INT 26
110759: PUSH
110760: EMPTY
110761: LIST
110762: LIST
110763: LIST
110764: LIST
110765: LIST
110766: LIST
110767: LIST
110768: LIST
110769: LIST
110770: PUSH
110771: LD_INT 101
110773: PUSH
110774: LD_INT 102
110776: PUSH
110777: LD_INT 105
110779: PUSH
110780: LD_INT 106
110782: PUSH
110783: LD_INT 108
110785: PUSH
110786: LD_INT 116
110788: PUSH
110789: LD_INT 117
110791: PUSH
110792: LD_INT 118
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: LIST
110799: LIST
110800: LIST
110801: LIST
110802: LIST
110803: LIST
110804: PUSH
110805: EMPTY
110806: LIST
110807: LIST
110808: ST_TO_ADDR
110809: GO 113792
110811: LD_INT 3
110813: DOUBLE
110814: EQUAL
110815: IFTRUE 110819
110817: GO 110907
110819: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110820: LD_ADDR_VAR 0 2
110824: PUSH
110825: LD_INT 2
110827: PUSH
110828: LD_INT 4
110830: PUSH
110831: LD_INT 5
110833: PUSH
110834: LD_INT 11
110836: PUSH
110837: LD_INT 12
110839: PUSH
110840: LD_INT 15
110842: PUSH
110843: LD_INT 16
110845: PUSH
110846: LD_INT 22
110848: PUSH
110849: LD_INT 26
110851: PUSH
110852: LD_INT 36
110854: PUSH
110855: EMPTY
110856: LIST
110857: LIST
110858: LIST
110859: LIST
110860: LIST
110861: LIST
110862: LIST
110863: LIST
110864: LIST
110865: LIST
110866: PUSH
110867: LD_INT 101
110869: PUSH
110870: LD_INT 102
110872: PUSH
110873: LD_INT 105
110875: PUSH
110876: LD_INT 106
110878: PUSH
110879: LD_INT 108
110881: PUSH
110882: LD_INT 116
110884: PUSH
110885: LD_INT 117
110887: PUSH
110888: LD_INT 118
110890: PUSH
110891: EMPTY
110892: LIST
110893: LIST
110894: LIST
110895: LIST
110896: LIST
110897: LIST
110898: LIST
110899: LIST
110900: PUSH
110901: EMPTY
110902: LIST
110903: LIST
110904: ST_TO_ADDR
110905: GO 113792
110907: LD_INT 4
110909: DOUBLE
110910: EQUAL
110911: IFTRUE 110915
110913: GO 111011
110915: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110916: LD_ADDR_VAR 0 2
110920: PUSH
110921: LD_INT 2
110923: PUSH
110924: LD_INT 4
110926: PUSH
110927: LD_INT 5
110929: PUSH
110930: LD_INT 8
110932: PUSH
110933: LD_INT 11
110935: PUSH
110936: LD_INT 12
110938: PUSH
110939: LD_INT 15
110941: PUSH
110942: LD_INT 16
110944: PUSH
110945: LD_INT 22
110947: PUSH
110948: LD_INT 23
110950: PUSH
110951: LD_INT 26
110953: PUSH
110954: LD_INT 36
110956: PUSH
110957: EMPTY
110958: LIST
110959: LIST
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: LIST
110965: LIST
110966: LIST
110967: LIST
110968: LIST
110969: LIST
110970: PUSH
110971: LD_INT 101
110973: PUSH
110974: LD_INT 102
110976: PUSH
110977: LD_INT 105
110979: PUSH
110980: LD_INT 106
110982: PUSH
110983: LD_INT 108
110985: PUSH
110986: LD_INT 116
110988: PUSH
110989: LD_INT 117
110991: PUSH
110992: LD_INT 118
110994: PUSH
110995: EMPTY
110996: LIST
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: PUSH
111005: EMPTY
111006: LIST
111007: LIST
111008: ST_TO_ADDR
111009: GO 113792
111011: LD_INT 5
111013: DOUBLE
111014: EQUAL
111015: IFTRUE 111019
111017: GO 111131
111019: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
111020: LD_ADDR_VAR 0 2
111024: PUSH
111025: LD_INT 2
111027: PUSH
111028: LD_INT 4
111030: PUSH
111031: LD_INT 5
111033: PUSH
111034: LD_INT 6
111036: PUSH
111037: LD_INT 8
111039: PUSH
111040: LD_INT 11
111042: PUSH
111043: LD_INT 12
111045: PUSH
111046: LD_INT 15
111048: PUSH
111049: LD_INT 16
111051: PUSH
111052: LD_INT 22
111054: PUSH
111055: LD_INT 23
111057: PUSH
111058: LD_INT 25
111060: PUSH
111061: LD_INT 26
111063: PUSH
111064: LD_INT 36
111066: PUSH
111067: EMPTY
111068: LIST
111069: LIST
111070: LIST
111071: LIST
111072: LIST
111073: LIST
111074: LIST
111075: LIST
111076: LIST
111077: LIST
111078: LIST
111079: LIST
111080: LIST
111081: LIST
111082: PUSH
111083: LD_INT 101
111085: PUSH
111086: LD_INT 102
111088: PUSH
111089: LD_INT 105
111091: PUSH
111092: LD_INT 106
111094: PUSH
111095: LD_INT 108
111097: PUSH
111098: LD_INT 109
111100: PUSH
111101: LD_INT 112
111103: PUSH
111104: LD_INT 116
111106: PUSH
111107: LD_INT 117
111109: PUSH
111110: LD_INT 118
111112: PUSH
111113: EMPTY
111114: LIST
111115: LIST
111116: LIST
111117: LIST
111118: LIST
111119: LIST
111120: LIST
111121: LIST
111122: LIST
111123: LIST
111124: PUSH
111125: EMPTY
111126: LIST
111127: LIST
111128: ST_TO_ADDR
111129: GO 113792
111131: LD_INT 6
111133: DOUBLE
111134: EQUAL
111135: IFTRUE 111139
111137: GO 111271
111139: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
111140: LD_ADDR_VAR 0 2
111144: PUSH
111145: LD_INT 2
111147: PUSH
111148: LD_INT 4
111150: PUSH
111151: LD_INT 5
111153: PUSH
111154: LD_INT 6
111156: PUSH
111157: LD_INT 8
111159: PUSH
111160: LD_INT 11
111162: PUSH
111163: LD_INT 12
111165: PUSH
111166: LD_INT 15
111168: PUSH
111169: LD_INT 16
111171: PUSH
111172: LD_INT 20
111174: PUSH
111175: LD_INT 21
111177: PUSH
111178: LD_INT 22
111180: PUSH
111181: LD_INT 23
111183: PUSH
111184: LD_INT 25
111186: PUSH
111187: LD_INT 26
111189: PUSH
111190: LD_INT 30
111192: PUSH
111193: LD_INT 31
111195: PUSH
111196: LD_INT 32
111198: PUSH
111199: LD_INT 36
111201: PUSH
111202: EMPTY
111203: LIST
111204: LIST
111205: LIST
111206: LIST
111207: LIST
111208: LIST
111209: LIST
111210: LIST
111211: LIST
111212: LIST
111213: LIST
111214: LIST
111215: LIST
111216: LIST
111217: LIST
111218: LIST
111219: LIST
111220: LIST
111221: LIST
111222: PUSH
111223: LD_INT 101
111225: PUSH
111226: LD_INT 102
111228: PUSH
111229: LD_INT 105
111231: PUSH
111232: LD_INT 106
111234: PUSH
111235: LD_INT 108
111237: PUSH
111238: LD_INT 109
111240: PUSH
111241: LD_INT 112
111243: PUSH
111244: LD_INT 116
111246: PUSH
111247: LD_INT 117
111249: PUSH
111250: LD_INT 118
111252: PUSH
111253: EMPTY
111254: LIST
111255: LIST
111256: LIST
111257: LIST
111258: LIST
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: LIST
111264: PUSH
111265: EMPTY
111266: LIST
111267: LIST
111268: ST_TO_ADDR
111269: GO 113792
111271: LD_INT 7
111273: DOUBLE
111274: EQUAL
111275: IFTRUE 111279
111277: GO 111391
111279: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111280: LD_ADDR_VAR 0 2
111284: PUSH
111285: LD_INT 2
111287: PUSH
111288: LD_INT 4
111290: PUSH
111291: LD_INT 5
111293: PUSH
111294: LD_INT 7
111296: PUSH
111297: LD_INT 11
111299: PUSH
111300: LD_INT 12
111302: PUSH
111303: LD_INT 15
111305: PUSH
111306: LD_INT 16
111308: PUSH
111309: LD_INT 20
111311: PUSH
111312: LD_INT 21
111314: PUSH
111315: LD_INT 22
111317: PUSH
111318: LD_INT 23
111320: PUSH
111321: LD_INT 25
111323: PUSH
111324: LD_INT 26
111326: PUSH
111327: EMPTY
111328: LIST
111329: LIST
111330: LIST
111331: LIST
111332: LIST
111333: LIST
111334: LIST
111335: LIST
111336: LIST
111337: LIST
111338: LIST
111339: LIST
111340: LIST
111341: LIST
111342: PUSH
111343: LD_INT 101
111345: PUSH
111346: LD_INT 102
111348: PUSH
111349: LD_INT 103
111351: PUSH
111352: LD_INT 105
111354: PUSH
111355: LD_INT 106
111357: PUSH
111358: LD_INT 108
111360: PUSH
111361: LD_INT 112
111363: PUSH
111364: LD_INT 116
111366: PUSH
111367: LD_INT 117
111369: PUSH
111370: LD_INT 118
111372: PUSH
111373: EMPTY
111374: LIST
111375: LIST
111376: LIST
111377: LIST
111378: LIST
111379: LIST
111380: LIST
111381: LIST
111382: LIST
111383: LIST
111384: PUSH
111385: EMPTY
111386: LIST
111387: LIST
111388: ST_TO_ADDR
111389: GO 113792
111391: LD_INT 8
111393: DOUBLE
111394: EQUAL
111395: IFTRUE 111399
111397: GO 111539
111399: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111400: LD_ADDR_VAR 0 2
111404: PUSH
111405: LD_INT 2
111407: PUSH
111408: LD_INT 4
111410: PUSH
111411: LD_INT 5
111413: PUSH
111414: LD_INT 6
111416: PUSH
111417: LD_INT 7
111419: PUSH
111420: LD_INT 8
111422: PUSH
111423: LD_INT 11
111425: PUSH
111426: LD_INT 12
111428: PUSH
111429: LD_INT 15
111431: PUSH
111432: LD_INT 16
111434: PUSH
111435: LD_INT 20
111437: PUSH
111438: LD_INT 21
111440: PUSH
111441: LD_INT 22
111443: PUSH
111444: LD_INT 23
111446: PUSH
111447: LD_INT 25
111449: PUSH
111450: LD_INT 26
111452: PUSH
111453: LD_INT 30
111455: PUSH
111456: LD_INT 31
111458: PUSH
111459: LD_INT 32
111461: PUSH
111462: LD_INT 36
111464: PUSH
111465: EMPTY
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: LIST
111476: LIST
111477: LIST
111478: LIST
111479: LIST
111480: LIST
111481: LIST
111482: LIST
111483: LIST
111484: LIST
111485: LIST
111486: PUSH
111487: LD_INT 101
111489: PUSH
111490: LD_INT 102
111492: PUSH
111493: LD_INT 103
111495: PUSH
111496: LD_INT 105
111498: PUSH
111499: LD_INT 106
111501: PUSH
111502: LD_INT 108
111504: PUSH
111505: LD_INT 109
111507: PUSH
111508: LD_INT 112
111510: PUSH
111511: LD_INT 116
111513: PUSH
111514: LD_INT 117
111516: PUSH
111517: LD_INT 118
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: LIST
111524: LIST
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: LIST
111531: LIST
111532: PUSH
111533: EMPTY
111534: LIST
111535: LIST
111536: ST_TO_ADDR
111537: GO 113792
111539: LD_INT 9
111541: DOUBLE
111542: EQUAL
111543: IFTRUE 111547
111545: GO 111695
111547: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111548: LD_ADDR_VAR 0 2
111552: PUSH
111553: LD_INT 2
111555: PUSH
111556: LD_INT 4
111558: PUSH
111559: LD_INT 5
111561: PUSH
111562: LD_INT 6
111564: PUSH
111565: LD_INT 7
111567: PUSH
111568: LD_INT 8
111570: PUSH
111571: LD_INT 11
111573: PUSH
111574: LD_INT 12
111576: PUSH
111577: LD_INT 15
111579: PUSH
111580: LD_INT 16
111582: PUSH
111583: LD_INT 20
111585: PUSH
111586: LD_INT 21
111588: PUSH
111589: LD_INT 22
111591: PUSH
111592: LD_INT 23
111594: PUSH
111595: LD_INT 25
111597: PUSH
111598: LD_INT 26
111600: PUSH
111601: LD_INT 28
111603: PUSH
111604: LD_INT 30
111606: PUSH
111607: LD_INT 31
111609: PUSH
111610: LD_INT 32
111612: PUSH
111613: LD_INT 36
111615: PUSH
111616: EMPTY
111617: LIST
111618: LIST
111619: LIST
111620: LIST
111621: LIST
111622: LIST
111623: LIST
111624: LIST
111625: LIST
111626: LIST
111627: LIST
111628: LIST
111629: LIST
111630: LIST
111631: LIST
111632: LIST
111633: LIST
111634: LIST
111635: LIST
111636: LIST
111637: LIST
111638: PUSH
111639: LD_INT 101
111641: PUSH
111642: LD_INT 102
111644: PUSH
111645: LD_INT 103
111647: PUSH
111648: LD_INT 105
111650: PUSH
111651: LD_INT 106
111653: PUSH
111654: LD_INT 108
111656: PUSH
111657: LD_INT 109
111659: PUSH
111660: LD_INT 112
111662: PUSH
111663: LD_INT 114
111665: PUSH
111666: LD_INT 116
111668: PUSH
111669: LD_INT 117
111671: PUSH
111672: LD_INT 118
111674: PUSH
111675: EMPTY
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: LIST
111682: LIST
111683: LIST
111684: LIST
111685: LIST
111686: LIST
111687: LIST
111688: PUSH
111689: EMPTY
111690: LIST
111691: LIST
111692: ST_TO_ADDR
111693: GO 113792
111695: LD_INT 10
111697: DOUBLE
111698: EQUAL
111699: IFTRUE 111703
111701: GO 111899
111703: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111704: LD_ADDR_VAR 0 2
111708: PUSH
111709: LD_INT 2
111711: PUSH
111712: LD_INT 4
111714: PUSH
111715: LD_INT 5
111717: PUSH
111718: LD_INT 6
111720: PUSH
111721: LD_INT 7
111723: PUSH
111724: LD_INT 8
111726: PUSH
111727: LD_INT 9
111729: PUSH
111730: LD_INT 10
111732: PUSH
111733: LD_INT 11
111735: PUSH
111736: LD_INT 12
111738: PUSH
111739: LD_INT 13
111741: PUSH
111742: LD_INT 14
111744: PUSH
111745: LD_INT 15
111747: PUSH
111748: LD_INT 16
111750: PUSH
111751: LD_INT 17
111753: PUSH
111754: LD_INT 18
111756: PUSH
111757: LD_INT 19
111759: PUSH
111760: LD_INT 20
111762: PUSH
111763: LD_INT 21
111765: PUSH
111766: LD_INT 22
111768: PUSH
111769: LD_INT 23
111771: PUSH
111772: LD_INT 24
111774: PUSH
111775: LD_INT 25
111777: PUSH
111778: LD_INT 26
111780: PUSH
111781: LD_INT 28
111783: PUSH
111784: LD_INT 30
111786: PUSH
111787: LD_INT 31
111789: PUSH
111790: LD_INT 32
111792: PUSH
111793: LD_INT 36
111795: PUSH
111796: EMPTY
111797: LIST
111798: LIST
111799: LIST
111800: LIST
111801: LIST
111802: LIST
111803: LIST
111804: LIST
111805: LIST
111806: LIST
111807: LIST
111808: LIST
111809: LIST
111810: LIST
111811: LIST
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: LIST
111819: LIST
111820: LIST
111821: LIST
111822: LIST
111823: LIST
111824: LIST
111825: LIST
111826: PUSH
111827: LD_INT 101
111829: PUSH
111830: LD_INT 102
111832: PUSH
111833: LD_INT 103
111835: PUSH
111836: LD_INT 104
111838: PUSH
111839: LD_INT 105
111841: PUSH
111842: LD_INT 106
111844: PUSH
111845: LD_INT 107
111847: PUSH
111848: LD_INT 108
111850: PUSH
111851: LD_INT 109
111853: PUSH
111854: LD_INT 110
111856: PUSH
111857: LD_INT 111
111859: PUSH
111860: LD_INT 112
111862: PUSH
111863: LD_INT 114
111865: PUSH
111866: LD_INT 116
111868: PUSH
111869: LD_INT 117
111871: PUSH
111872: LD_INT 118
111874: PUSH
111875: EMPTY
111876: LIST
111877: LIST
111878: LIST
111879: LIST
111880: LIST
111881: LIST
111882: LIST
111883: LIST
111884: LIST
111885: LIST
111886: LIST
111887: LIST
111888: LIST
111889: LIST
111890: LIST
111891: LIST
111892: PUSH
111893: EMPTY
111894: LIST
111895: LIST
111896: ST_TO_ADDR
111897: GO 113792
111899: LD_INT 11
111901: DOUBLE
111902: EQUAL
111903: IFTRUE 111907
111905: GO 112111
111907: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111908: LD_ADDR_VAR 0 2
111912: PUSH
111913: LD_INT 2
111915: PUSH
111916: LD_INT 3
111918: PUSH
111919: LD_INT 4
111921: PUSH
111922: LD_INT 5
111924: PUSH
111925: LD_INT 6
111927: PUSH
111928: LD_INT 7
111930: PUSH
111931: LD_INT 8
111933: PUSH
111934: LD_INT 9
111936: PUSH
111937: LD_INT 10
111939: PUSH
111940: LD_INT 11
111942: PUSH
111943: LD_INT 12
111945: PUSH
111946: LD_INT 13
111948: PUSH
111949: LD_INT 14
111951: PUSH
111952: LD_INT 15
111954: PUSH
111955: LD_INT 16
111957: PUSH
111958: LD_INT 17
111960: PUSH
111961: LD_INT 18
111963: PUSH
111964: LD_INT 19
111966: PUSH
111967: LD_INT 20
111969: PUSH
111970: LD_INT 21
111972: PUSH
111973: LD_INT 22
111975: PUSH
111976: LD_INT 23
111978: PUSH
111979: LD_INT 24
111981: PUSH
111982: LD_INT 25
111984: PUSH
111985: LD_INT 26
111987: PUSH
111988: LD_INT 28
111990: PUSH
111991: LD_INT 30
111993: PUSH
111994: LD_INT 31
111996: PUSH
111997: LD_INT 32
111999: PUSH
112000: LD_INT 34
112002: PUSH
112003: LD_INT 36
112005: PUSH
112006: EMPTY
112007: LIST
112008: LIST
112009: LIST
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: LIST
112021: LIST
112022: LIST
112023: LIST
112024: LIST
112025: LIST
112026: LIST
112027: LIST
112028: LIST
112029: LIST
112030: LIST
112031: LIST
112032: LIST
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: PUSH
112039: LD_INT 101
112041: PUSH
112042: LD_INT 102
112044: PUSH
112045: LD_INT 103
112047: PUSH
112048: LD_INT 104
112050: PUSH
112051: LD_INT 105
112053: PUSH
112054: LD_INT 106
112056: PUSH
112057: LD_INT 107
112059: PUSH
112060: LD_INT 108
112062: PUSH
112063: LD_INT 109
112065: PUSH
112066: LD_INT 110
112068: PUSH
112069: LD_INT 111
112071: PUSH
112072: LD_INT 112
112074: PUSH
112075: LD_INT 114
112077: PUSH
112078: LD_INT 116
112080: PUSH
112081: LD_INT 117
112083: PUSH
112084: LD_INT 118
112086: PUSH
112087: EMPTY
112088: LIST
112089: LIST
112090: LIST
112091: LIST
112092: LIST
112093: LIST
112094: LIST
112095: LIST
112096: LIST
112097: LIST
112098: LIST
112099: LIST
112100: LIST
112101: LIST
112102: LIST
112103: LIST
112104: PUSH
112105: EMPTY
112106: LIST
112107: LIST
112108: ST_TO_ADDR
112109: GO 113792
112111: LD_INT 12
112113: DOUBLE
112114: EQUAL
112115: IFTRUE 112119
112117: GO 112339
112119: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
112120: LD_ADDR_VAR 0 2
112124: PUSH
112125: LD_INT 1
112127: PUSH
112128: LD_INT 2
112130: PUSH
112131: LD_INT 3
112133: PUSH
112134: LD_INT 4
112136: PUSH
112137: LD_INT 5
112139: PUSH
112140: LD_INT 6
112142: PUSH
112143: LD_INT 7
112145: PUSH
112146: LD_INT 8
112148: PUSH
112149: LD_INT 9
112151: PUSH
112152: LD_INT 10
112154: PUSH
112155: LD_INT 11
112157: PUSH
112158: LD_INT 12
112160: PUSH
112161: LD_INT 13
112163: PUSH
112164: LD_INT 14
112166: PUSH
112167: LD_INT 15
112169: PUSH
112170: LD_INT 16
112172: PUSH
112173: LD_INT 17
112175: PUSH
112176: LD_INT 18
112178: PUSH
112179: LD_INT 19
112181: PUSH
112182: LD_INT 20
112184: PUSH
112185: LD_INT 21
112187: PUSH
112188: LD_INT 22
112190: PUSH
112191: LD_INT 23
112193: PUSH
112194: LD_INT 24
112196: PUSH
112197: LD_INT 25
112199: PUSH
112200: LD_INT 26
112202: PUSH
112203: LD_INT 27
112205: PUSH
112206: LD_INT 28
112208: PUSH
112209: LD_INT 30
112211: PUSH
112212: LD_INT 31
112214: PUSH
112215: LD_INT 32
112217: PUSH
112218: LD_INT 33
112220: PUSH
112221: LD_INT 34
112223: PUSH
112224: LD_INT 36
112226: PUSH
112227: EMPTY
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: LIST
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: PUSH
112263: LD_INT 101
112265: PUSH
112266: LD_INT 102
112268: PUSH
112269: LD_INT 103
112271: PUSH
112272: LD_INT 104
112274: PUSH
112275: LD_INT 105
112277: PUSH
112278: LD_INT 106
112280: PUSH
112281: LD_INT 107
112283: PUSH
112284: LD_INT 108
112286: PUSH
112287: LD_INT 109
112289: PUSH
112290: LD_INT 110
112292: PUSH
112293: LD_INT 111
112295: PUSH
112296: LD_INT 112
112298: PUSH
112299: LD_INT 113
112301: PUSH
112302: LD_INT 114
112304: PUSH
112305: LD_INT 116
112307: PUSH
112308: LD_INT 117
112310: PUSH
112311: LD_INT 118
112313: PUSH
112314: EMPTY
112315: LIST
112316: LIST
112317: LIST
112318: LIST
112319: LIST
112320: LIST
112321: LIST
112322: LIST
112323: LIST
112324: LIST
112325: LIST
112326: LIST
112327: LIST
112328: LIST
112329: LIST
112330: LIST
112331: LIST
112332: PUSH
112333: EMPTY
112334: LIST
112335: LIST
112336: ST_TO_ADDR
112337: GO 113792
112339: LD_INT 13
112341: DOUBLE
112342: EQUAL
112343: IFTRUE 112347
112345: GO 112555
112347: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112348: LD_ADDR_VAR 0 2
112352: PUSH
112353: LD_INT 1
112355: PUSH
112356: LD_INT 2
112358: PUSH
112359: LD_INT 3
112361: PUSH
112362: LD_INT 4
112364: PUSH
112365: LD_INT 5
112367: PUSH
112368: LD_INT 8
112370: PUSH
112371: LD_INT 9
112373: PUSH
112374: LD_INT 10
112376: PUSH
112377: LD_INT 11
112379: PUSH
112380: LD_INT 12
112382: PUSH
112383: LD_INT 14
112385: PUSH
112386: LD_INT 15
112388: PUSH
112389: LD_INT 16
112391: PUSH
112392: LD_INT 17
112394: PUSH
112395: LD_INT 18
112397: PUSH
112398: LD_INT 19
112400: PUSH
112401: LD_INT 20
112403: PUSH
112404: LD_INT 21
112406: PUSH
112407: LD_INT 22
112409: PUSH
112410: LD_INT 23
112412: PUSH
112413: LD_INT 24
112415: PUSH
112416: LD_INT 25
112418: PUSH
112419: LD_INT 26
112421: PUSH
112422: LD_INT 27
112424: PUSH
112425: LD_INT 28
112427: PUSH
112428: LD_INT 30
112430: PUSH
112431: LD_INT 31
112433: PUSH
112434: LD_INT 32
112436: PUSH
112437: LD_INT 33
112439: PUSH
112440: LD_INT 34
112442: PUSH
112443: LD_INT 36
112445: PUSH
112446: EMPTY
112447: LIST
112448: LIST
112449: LIST
112450: LIST
112451: LIST
112452: LIST
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: LIST
112458: LIST
112459: LIST
112460: LIST
112461: LIST
112462: LIST
112463: LIST
112464: LIST
112465: LIST
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: PUSH
112479: LD_INT 101
112481: PUSH
112482: LD_INT 102
112484: PUSH
112485: LD_INT 103
112487: PUSH
112488: LD_INT 104
112490: PUSH
112491: LD_INT 105
112493: PUSH
112494: LD_INT 106
112496: PUSH
112497: LD_INT 107
112499: PUSH
112500: LD_INT 108
112502: PUSH
112503: LD_INT 109
112505: PUSH
112506: LD_INT 110
112508: PUSH
112509: LD_INT 111
112511: PUSH
112512: LD_INT 112
112514: PUSH
112515: LD_INT 113
112517: PUSH
112518: LD_INT 114
112520: PUSH
112521: LD_INT 116
112523: PUSH
112524: LD_INT 117
112526: PUSH
112527: LD_INT 118
112529: PUSH
112530: EMPTY
112531: LIST
112532: LIST
112533: LIST
112534: LIST
112535: LIST
112536: LIST
112537: LIST
112538: LIST
112539: LIST
112540: LIST
112541: LIST
112542: LIST
112543: LIST
112544: LIST
112545: LIST
112546: LIST
112547: LIST
112548: PUSH
112549: EMPTY
112550: LIST
112551: LIST
112552: ST_TO_ADDR
112553: GO 113792
112555: LD_INT 14
112557: DOUBLE
112558: EQUAL
112559: IFTRUE 112563
112561: GO 112787
112563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112564: LD_ADDR_VAR 0 2
112568: PUSH
112569: LD_INT 1
112571: PUSH
112572: LD_INT 2
112574: PUSH
112575: LD_INT 3
112577: PUSH
112578: LD_INT 4
112580: PUSH
112581: LD_INT 5
112583: PUSH
112584: LD_INT 6
112586: PUSH
112587: LD_INT 7
112589: PUSH
112590: LD_INT 8
112592: PUSH
112593: LD_INT 9
112595: PUSH
112596: LD_INT 10
112598: PUSH
112599: LD_INT 11
112601: PUSH
112602: LD_INT 12
112604: PUSH
112605: LD_INT 13
112607: PUSH
112608: LD_INT 14
112610: PUSH
112611: LD_INT 15
112613: PUSH
112614: LD_INT 16
112616: PUSH
112617: LD_INT 17
112619: PUSH
112620: LD_INT 18
112622: PUSH
112623: LD_INT 19
112625: PUSH
112626: LD_INT 20
112628: PUSH
112629: LD_INT 21
112631: PUSH
112632: LD_INT 22
112634: PUSH
112635: LD_INT 23
112637: PUSH
112638: LD_INT 24
112640: PUSH
112641: LD_INT 25
112643: PUSH
112644: LD_INT 26
112646: PUSH
112647: LD_INT 27
112649: PUSH
112650: LD_INT 28
112652: PUSH
112653: LD_INT 29
112655: PUSH
112656: LD_INT 30
112658: PUSH
112659: LD_INT 31
112661: PUSH
112662: LD_INT 32
112664: PUSH
112665: LD_INT 33
112667: PUSH
112668: LD_INT 34
112670: PUSH
112671: LD_INT 36
112673: PUSH
112674: EMPTY
112675: LIST
112676: LIST
112677: LIST
112678: LIST
112679: LIST
112680: LIST
112681: LIST
112682: LIST
112683: LIST
112684: LIST
112685: LIST
112686: LIST
112687: LIST
112688: LIST
112689: LIST
112690: LIST
112691: LIST
112692: LIST
112693: LIST
112694: LIST
112695: LIST
112696: LIST
112697: LIST
112698: LIST
112699: LIST
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: PUSH
112711: LD_INT 101
112713: PUSH
112714: LD_INT 102
112716: PUSH
112717: LD_INT 103
112719: PUSH
112720: LD_INT 104
112722: PUSH
112723: LD_INT 105
112725: PUSH
112726: LD_INT 106
112728: PUSH
112729: LD_INT 107
112731: PUSH
112732: LD_INT 108
112734: PUSH
112735: LD_INT 109
112737: PUSH
112738: LD_INT 110
112740: PUSH
112741: LD_INT 111
112743: PUSH
112744: LD_INT 112
112746: PUSH
112747: LD_INT 113
112749: PUSH
112750: LD_INT 114
112752: PUSH
112753: LD_INT 116
112755: PUSH
112756: LD_INT 117
112758: PUSH
112759: LD_INT 118
112761: PUSH
112762: EMPTY
112763: LIST
112764: LIST
112765: LIST
112766: LIST
112767: LIST
112768: LIST
112769: LIST
112770: LIST
112771: LIST
112772: LIST
112773: LIST
112774: LIST
112775: LIST
112776: LIST
112777: LIST
112778: LIST
112779: LIST
112780: PUSH
112781: EMPTY
112782: LIST
112783: LIST
112784: ST_TO_ADDR
112785: GO 113792
112787: LD_INT 15
112789: DOUBLE
112790: EQUAL
112791: IFTRUE 112795
112793: GO 113019
112795: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112796: LD_ADDR_VAR 0 2
112800: PUSH
112801: LD_INT 1
112803: PUSH
112804: LD_INT 2
112806: PUSH
112807: LD_INT 3
112809: PUSH
112810: LD_INT 4
112812: PUSH
112813: LD_INT 5
112815: PUSH
112816: LD_INT 6
112818: PUSH
112819: LD_INT 7
112821: PUSH
112822: LD_INT 8
112824: PUSH
112825: LD_INT 9
112827: PUSH
112828: LD_INT 10
112830: PUSH
112831: LD_INT 11
112833: PUSH
112834: LD_INT 12
112836: PUSH
112837: LD_INT 13
112839: PUSH
112840: LD_INT 14
112842: PUSH
112843: LD_INT 15
112845: PUSH
112846: LD_INT 16
112848: PUSH
112849: LD_INT 17
112851: PUSH
112852: LD_INT 18
112854: PUSH
112855: LD_INT 19
112857: PUSH
112858: LD_INT 20
112860: PUSH
112861: LD_INT 21
112863: PUSH
112864: LD_INT 22
112866: PUSH
112867: LD_INT 23
112869: PUSH
112870: LD_INT 24
112872: PUSH
112873: LD_INT 25
112875: PUSH
112876: LD_INT 26
112878: PUSH
112879: LD_INT 27
112881: PUSH
112882: LD_INT 28
112884: PUSH
112885: LD_INT 29
112887: PUSH
112888: LD_INT 30
112890: PUSH
112891: LD_INT 31
112893: PUSH
112894: LD_INT 32
112896: PUSH
112897: LD_INT 33
112899: PUSH
112900: LD_INT 34
112902: PUSH
112903: LD_INT 36
112905: PUSH
112906: EMPTY
112907: LIST
112908: LIST
112909: LIST
112910: LIST
112911: LIST
112912: LIST
112913: LIST
112914: LIST
112915: LIST
112916: LIST
112917: LIST
112918: LIST
112919: LIST
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: LIST
112925: LIST
112926: LIST
112927: LIST
112928: LIST
112929: LIST
112930: LIST
112931: LIST
112932: LIST
112933: LIST
112934: LIST
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: LIST
112942: PUSH
112943: LD_INT 101
112945: PUSH
112946: LD_INT 102
112948: PUSH
112949: LD_INT 103
112951: PUSH
112952: LD_INT 104
112954: PUSH
112955: LD_INT 105
112957: PUSH
112958: LD_INT 106
112960: PUSH
112961: LD_INT 107
112963: PUSH
112964: LD_INT 108
112966: PUSH
112967: LD_INT 109
112969: PUSH
112970: LD_INT 110
112972: PUSH
112973: LD_INT 111
112975: PUSH
112976: LD_INT 112
112978: PUSH
112979: LD_INT 113
112981: PUSH
112982: LD_INT 114
112984: PUSH
112985: LD_INT 116
112987: PUSH
112988: LD_INT 117
112990: PUSH
112991: LD_INT 118
112993: PUSH
112994: EMPTY
112995: LIST
112996: LIST
112997: LIST
112998: LIST
112999: LIST
113000: LIST
113001: LIST
113002: LIST
113003: LIST
113004: LIST
113005: LIST
113006: LIST
113007: LIST
113008: LIST
113009: LIST
113010: LIST
113011: LIST
113012: PUSH
113013: EMPTY
113014: LIST
113015: LIST
113016: ST_TO_ADDR
113017: GO 113792
113019: LD_INT 16
113021: DOUBLE
113022: EQUAL
113023: IFTRUE 113027
113025: GO 113163
113027: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
113028: LD_ADDR_VAR 0 2
113032: PUSH
113033: LD_INT 2
113035: PUSH
113036: LD_INT 4
113038: PUSH
113039: LD_INT 5
113041: PUSH
113042: LD_INT 7
113044: PUSH
113045: LD_INT 11
113047: PUSH
113048: LD_INT 12
113050: PUSH
113051: LD_INT 15
113053: PUSH
113054: LD_INT 16
113056: PUSH
113057: LD_INT 20
113059: PUSH
113060: LD_INT 21
113062: PUSH
113063: LD_INT 22
113065: PUSH
113066: LD_INT 23
113068: PUSH
113069: LD_INT 25
113071: PUSH
113072: LD_INT 26
113074: PUSH
113075: LD_INT 30
113077: PUSH
113078: LD_INT 31
113080: PUSH
113081: LD_INT 32
113083: PUSH
113084: LD_INT 33
113086: PUSH
113087: LD_INT 34
113089: PUSH
113090: EMPTY
113091: LIST
113092: LIST
113093: LIST
113094: LIST
113095: LIST
113096: LIST
113097: LIST
113098: LIST
113099: LIST
113100: LIST
113101: LIST
113102: LIST
113103: LIST
113104: LIST
113105: LIST
113106: LIST
113107: LIST
113108: LIST
113109: LIST
113110: PUSH
113111: LD_INT 101
113113: PUSH
113114: LD_INT 102
113116: PUSH
113117: LD_INT 103
113119: PUSH
113120: LD_INT 106
113122: PUSH
113123: LD_INT 108
113125: PUSH
113126: LD_INT 112
113128: PUSH
113129: LD_INT 113
113131: PUSH
113132: LD_INT 114
113134: PUSH
113135: LD_INT 116
113137: PUSH
113138: LD_INT 117
113140: PUSH
113141: LD_INT 118
113143: PUSH
113144: EMPTY
113145: LIST
113146: LIST
113147: LIST
113148: LIST
113149: LIST
113150: LIST
113151: LIST
113152: LIST
113153: LIST
113154: LIST
113155: LIST
113156: PUSH
113157: EMPTY
113158: LIST
113159: LIST
113160: ST_TO_ADDR
113161: GO 113792
113163: LD_INT 17
113165: DOUBLE
113166: EQUAL
113167: IFTRUE 113171
113169: GO 113395
113171: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
113172: LD_ADDR_VAR 0 2
113176: PUSH
113177: LD_INT 1
113179: PUSH
113180: LD_INT 2
113182: PUSH
113183: LD_INT 3
113185: PUSH
113186: LD_INT 4
113188: PUSH
113189: LD_INT 5
113191: PUSH
113192: LD_INT 6
113194: PUSH
113195: LD_INT 7
113197: PUSH
113198: LD_INT 8
113200: PUSH
113201: LD_INT 9
113203: PUSH
113204: LD_INT 10
113206: PUSH
113207: LD_INT 11
113209: PUSH
113210: LD_INT 12
113212: PUSH
113213: LD_INT 13
113215: PUSH
113216: LD_INT 14
113218: PUSH
113219: LD_INT 15
113221: PUSH
113222: LD_INT 16
113224: PUSH
113225: LD_INT 17
113227: PUSH
113228: LD_INT 18
113230: PUSH
113231: LD_INT 19
113233: PUSH
113234: LD_INT 20
113236: PUSH
113237: LD_INT 21
113239: PUSH
113240: LD_INT 22
113242: PUSH
113243: LD_INT 23
113245: PUSH
113246: LD_INT 24
113248: PUSH
113249: LD_INT 25
113251: PUSH
113252: LD_INT 26
113254: PUSH
113255: LD_INT 27
113257: PUSH
113258: LD_INT 28
113260: PUSH
113261: LD_INT 29
113263: PUSH
113264: LD_INT 30
113266: PUSH
113267: LD_INT 31
113269: PUSH
113270: LD_INT 32
113272: PUSH
113273: LD_INT 33
113275: PUSH
113276: LD_INT 34
113278: PUSH
113279: LD_INT 36
113281: PUSH
113282: EMPTY
113283: LIST
113284: LIST
113285: LIST
113286: LIST
113287: LIST
113288: LIST
113289: LIST
113290: LIST
113291: LIST
113292: LIST
113293: LIST
113294: LIST
113295: LIST
113296: LIST
113297: LIST
113298: LIST
113299: LIST
113300: LIST
113301: LIST
113302: LIST
113303: LIST
113304: LIST
113305: LIST
113306: LIST
113307: LIST
113308: LIST
113309: LIST
113310: LIST
113311: LIST
113312: LIST
113313: LIST
113314: LIST
113315: LIST
113316: LIST
113317: LIST
113318: PUSH
113319: LD_INT 101
113321: PUSH
113322: LD_INT 102
113324: PUSH
113325: LD_INT 103
113327: PUSH
113328: LD_INT 104
113330: PUSH
113331: LD_INT 105
113333: PUSH
113334: LD_INT 106
113336: PUSH
113337: LD_INT 107
113339: PUSH
113340: LD_INT 108
113342: PUSH
113343: LD_INT 109
113345: PUSH
113346: LD_INT 110
113348: PUSH
113349: LD_INT 111
113351: PUSH
113352: LD_INT 112
113354: PUSH
113355: LD_INT 113
113357: PUSH
113358: LD_INT 114
113360: PUSH
113361: LD_INT 116
113363: PUSH
113364: LD_INT 117
113366: PUSH
113367: LD_INT 118
113369: PUSH
113370: EMPTY
113371: LIST
113372: LIST
113373: LIST
113374: LIST
113375: LIST
113376: LIST
113377: LIST
113378: LIST
113379: LIST
113380: LIST
113381: LIST
113382: LIST
113383: LIST
113384: LIST
113385: LIST
113386: LIST
113387: LIST
113388: PUSH
113389: EMPTY
113390: LIST
113391: LIST
113392: ST_TO_ADDR
113393: GO 113792
113395: LD_INT 18
113397: DOUBLE
113398: EQUAL
113399: IFTRUE 113403
113401: GO 113551
113403: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113404: LD_ADDR_VAR 0 2
113408: PUSH
113409: LD_INT 2
113411: PUSH
113412: LD_INT 4
113414: PUSH
113415: LD_INT 5
113417: PUSH
113418: LD_INT 7
113420: PUSH
113421: LD_INT 11
113423: PUSH
113424: LD_INT 12
113426: PUSH
113427: LD_INT 15
113429: PUSH
113430: LD_INT 16
113432: PUSH
113433: LD_INT 20
113435: PUSH
113436: LD_INT 21
113438: PUSH
113439: LD_INT 22
113441: PUSH
113442: LD_INT 23
113444: PUSH
113445: LD_INT 25
113447: PUSH
113448: LD_INT 26
113450: PUSH
113451: LD_INT 30
113453: PUSH
113454: LD_INT 31
113456: PUSH
113457: LD_INT 32
113459: PUSH
113460: LD_INT 33
113462: PUSH
113463: LD_INT 34
113465: PUSH
113466: LD_INT 35
113468: PUSH
113469: LD_INT 36
113471: PUSH
113472: EMPTY
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: PUSH
113495: LD_INT 101
113497: PUSH
113498: LD_INT 102
113500: PUSH
113501: LD_INT 103
113503: PUSH
113504: LD_INT 106
113506: PUSH
113507: LD_INT 108
113509: PUSH
113510: LD_INT 112
113512: PUSH
113513: LD_INT 113
113515: PUSH
113516: LD_INT 114
113518: PUSH
113519: LD_INT 115
113521: PUSH
113522: LD_INT 116
113524: PUSH
113525: LD_INT 117
113527: PUSH
113528: LD_INT 118
113530: PUSH
113531: EMPTY
113532: LIST
113533: LIST
113534: LIST
113535: LIST
113536: LIST
113537: LIST
113538: LIST
113539: LIST
113540: LIST
113541: LIST
113542: LIST
113543: LIST
113544: PUSH
113545: EMPTY
113546: LIST
113547: LIST
113548: ST_TO_ADDR
113549: GO 113792
113551: LD_INT 19
113553: DOUBLE
113554: EQUAL
113555: IFTRUE 113559
113557: GO 113791
113559: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113560: LD_ADDR_VAR 0 2
113564: PUSH
113565: LD_INT 1
113567: PUSH
113568: LD_INT 2
113570: PUSH
113571: LD_INT 3
113573: PUSH
113574: LD_INT 4
113576: PUSH
113577: LD_INT 5
113579: PUSH
113580: LD_INT 6
113582: PUSH
113583: LD_INT 7
113585: PUSH
113586: LD_INT 8
113588: PUSH
113589: LD_INT 9
113591: PUSH
113592: LD_INT 10
113594: PUSH
113595: LD_INT 11
113597: PUSH
113598: LD_INT 12
113600: PUSH
113601: LD_INT 13
113603: PUSH
113604: LD_INT 14
113606: PUSH
113607: LD_INT 15
113609: PUSH
113610: LD_INT 16
113612: PUSH
113613: LD_INT 17
113615: PUSH
113616: LD_INT 18
113618: PUSH
113619: LD_INT 19
113621: PUSH
113622: LD_INT 20
113624: PUSH
113625: LD_INT 21
113627: PUSH
113628: LD_INT 22
113630: PUSH
113631: LD_INT 23
113633: PUSH
113634: LD_INT 24
113636: PUSH
113637: LD_INT 25
113639: PUSH
113640: LD_INT 26
113642: PUSH
113643: LD_INT 27
113645: PUSH
113646: LD_INT 28
113648: PUSH
113649: LD_INT 29
113651: PUSH
113652: LD_INT 30
113654: PUSH
113655: LD_INT 31
113657: PUSH
113658: LD_INT 32
113660: PUSH
113661: LD_INT 33
113663: PUSH
113664: LD_INT 34
113666: PUSH
113667: LD_INT 35
113669: PUSH
113670: LD_INT 36
113672: PUSH
113673: EMPTY
113674: LIST
113675: LIST
113676: LIST
113677: LIST
113678: LIST
113679: LIST
113680: LIST
113681: LIST
113682: LIST
113683: LIST
113684: LIST
113685: LIST
113686: LIST
113687: LIST
113688: LIST
113689: LIST
113690: LIST
113691: LIST
113692: LIST
113693: LIST
113694: LIST
113695: LIST
113696: LIST
113697: LIST
113698: LIST
113699: LIST
113700: LIST
113701: LIST
113702: LIST
113703: LIST
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: PUSH
113711: LD_INT 101
113713: PUSH
113714: LD_INT 102
113716: PUSH
113717: LD_INT 103
113719: PUSH
113720: LD_INT 104
113722: PUSH
113723: LD_INT 105
113725: PUSH
113726: LD_INT 106
113728: PUSH
113729: LD_INT 107
113731: PUSH
113732: LD_INT 108
113734: PUSH
113735: LD_INT 109
113737: PUSH
113738: LD_INT 110
113740: PUSH
113741: LD_INT 111
113743: PUSH
113744: LD_INT 112
113746: PUSH
113747: LD_INT 113
113749: PUSH
113750: LD_INT 114
113752: PUSH
113753: LD_INT 115
113755: PUSH
113756: LD_INT 116
113758: PUSH
113759: LD_INT 117
113761: PUSH
113762: LD_INT 118
113764: PUSH
113765: EMPTY
113766: LIST
113767: LIST
113768: LIST
113769: LIST
113770: LIST
113771: LIST
113772: LIST
113773: LIST
113774: LIST
113775: LIST
113776: LIST
113777: LIST
113778: LIST
113779: LIST
113780: LIST
113781: LIST
113782: LIST
113783: LIST
113784: PUSH
113785: EMPTY
113786: LIST
113787: LIST
113788: ST_TO_ADDR
113789: GO 113792
113791: POP
// end else
113792: GO 114023
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113794: LD_ADDR_VAR 0 2
113798: PUSH
113799: LD_INT 1
113801: PUSH
113802: LD_INT 2
113804: PUSH
113805: LD_INT 3
113807: PUSH
113808: LD_INT 4
113810: PUSH
113811: LD_INT 5
113813: PUSH
113814: LD_INT 6
113816: PUSH
113817: LD_INT 7
113819: PUSH
113820: LD_INT 8
113822: PUSH
113823: LD_INT 9
113825: PUSH
113826: LD_INT 10
113828: PUSH
113829: LD_INT 11
113831: PUSH
113832: LD_INT 12
113834: PUSH
113835: LD_INT 13
113837: PUSH
113838: LD_INT 14
113840: PUSH
113841: LD_INT 15
113843: PUSH
113844: LD_INT 16
113846: PUSH
113847: LD_INT 17
113849: PUSH
113850: LD_INT 18
113852: PUSH
113853: LD_INT 19
113855: PUSH
113856: LD_INT 20
113858: PUSH
113859: LD_INT 21
113861: PUSH
113862: LD_INT 22
113864: PUSH
113865: LD_INT 23
113867: PUSH
113868: LD_INT 24
113870: PUSH
113871: LD_INT 25
113873: PUSH
113874: LD_INT 26
113876: PUSH
113877: LD_INT 27
113879: PUSH
113880: LD_INT 28
113882: PUSH
113883: LD_INT 29
113885: PUSH
113886: LD_INT 30
113888: PUSH
113889: LD_INT 31
113891: PUSH
113892: LD_INT 32
113894: PUSH
113895: LD_INT 33
113897: PUSH
113898: LD_INT 34
113900: PUSH
113901: LD_INT 35
113903: PUSH
113904: LD_INT 36
113906: PUSH
113907: EMPTY
113908: LIST
113909: LIST
113910: LIST
113911: LIST
113912: LIST
113913: LIST
113914: LIST
113915: LIST
113916: LIST
113917: LIST
113918: LIST
113919: LIST
113920: LIST
113921: LIST
113922: LIST
113923: LIST
113924: LIST
113925: LIST
113926: LIST
113927: LIST
113928: LIST
113929: LIST
113930: LIST
113931: LIST
113932: LIST
113933: LIST
113934: LIST
113935: LIST
113936: LIST
113937: LIST
113938: LIST
113939: LIST
113940: LIST
113941: LIST
113942: LIST
113943: LIST
113944: PUSH
113945: LD_INT 101
113947: PUSH
113948: LD_INT 102
113950: PUSH
113951: LD_INT 103
113953: PUSH
113954: LD_INT 104
113956: PUSH
113957: LD_INT 105
113959: PUSH
113960: LD_INT 106
113962: PUSH
113963: LD_INT 107
113965: PUSH
113966: LD_INT 108
113968: PUSH
113969: LD_INT 109
113971: PUSH
113972: LD_INT 110
113974: PUSH
113975: LD_INT 111
113977: PUSH
113978: LD_INT 112
113980: PUSH
113981: LD_INT 113
113983: PUSH
113984: LD_INT 114
113986: PUSH
113987: LD_INT 115
113989: PUSH
113990: LD_INT 116
113992: PUSH
113993: LD_INT 117
113995: PUSH
113996: LD_INT 118
113998: PUSH
113999: EMPTY
114000: LIST
114001: LIST
114002: LIST
114003: LIST
114004: LIST
114005: LIST
114006: LIST
114007: LIST
114008: LIST
114009: LIST
114010: LIST
114011: LIST
114012: LIST
114013: LIST
114014: LIST
114015: LIST
114016: LIST
114017: LIST
114018: PUSH
114019: EMPTY
114020: LIST
114021: LIST
114022: ST_TO_ADDR
// if result then
114023: LD_VAR 0 2
114027: IFFALSE 114813
// begin normal :=  ;
114029: LD_ADDR_VAR 0 5
114033: PUSH
114034: LD_STRING 
114036: ST_TO_ADDR
// hardcore :=  ;
114037: LD_ADDR_VAR 0 6
114041: PUSH
114042: LD_STRING 
114044: ST_TO_ADDR
// active :=  ;
114045: LD_ADDR_VAR 0 7
114049: PUSH
114050: LD_STRING 
114052: ST_TO_ADDR
// for i = 1 to normalCounter do
114053: LD_ADDR_VAR 0 8
114057: PUSH
114058: DOUBLE
114059: LD_INT 1
114061: DEC
114062: ST_TO_ADDR
114063: LD_EXP 145
114067: PUSH
114068: FOR_TO
114069: IFFALSE 114170
// begin tmp := 0 ;
114071: LD_ADDR_VAR 0 3
114075: PUSH
114076: LD_STRING 0
114078: ST_TO_ADDR
// if result [ 1 ] then
114079: LD_VAR 0 2
114083: PUSH
114084: LD_INT 1
114086: ARRAY
114087: IFFALSE 114152
// if result [ 1 ] [ 1 ] = i then
114089: LD_VAR 0 2
114093: PUSH
114094: LD_INT 1
114096: ARRAY
114097: PUSH
114098: LD_INT 1
114100: ARRAY
114101: PUSH
114102: LD_VAR 0 8
114106: EQUAL
114107: IFFALSE 114152
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
114109: LD_ADDR_VAR 0 2
114113: PUSH
114114: LD_VAR 0 2
114118: PPUSH
114119: LD_INT 1
114121: PPUSH
114122: LD_VAR 0 2
114126: PUSH
114127: LD_INT 1
114129: ARRAY
114130: PPUSH
114131: LD_INT 1
114133: PPUSH
114134: CALL_OW 3
114138: PPUSH
114139: CALL_OW 1
114143: ST_TO_ADDR
// tmp := 1 ;
114144: LD_ADDR_VAR 0 3
114148: PUSH
114149: LD_STRING 1
114151: ST_TO_ADDR
// end ; normal := normal & tmp ;
114152: LD_ADDR_VAR 0 5
114156: PUSH
114157: LD_VAR 0 5
114161: PUSH
114162: LD_VAR 0 3
114166: STR
114167: ST_TO_ADDR
// end ;
114168: GO 114068
114170: POP
114171: POP
// for i = 1 to hardcoreCounter do
114172: LD_ADDR_VAR 0 8
114176: PUSH
114177: DOUBLE
114178: LD_INT 1
114180: DEC
114181: ST_TO_ADDR
114182: LD_EXP 146
114186: PUSH
114187: FOR_TO
114188: IFFALSE 114293
// begin tmp := 0 ;
114190: LD_ADDR_VAR 0 3
114194: PUSH
114195: LD_STRING 0
114197: ST_TO_ADDR
// if result [ 2 ] then
114198: LD_VAR 0 2
114202: PUSH
114203: LD_INT 2
114205: ARRAY
114206: IFFALSE 114275
// if result [ 2 ] [ 1 ] = 100 + i then
114208: LD_VAR 0 2
114212: PUSH
114213: LD_INT 2
114215: ARRAY
114216: PUSH
114217: LD_INT 1
114219: ARRAY
114220: PUSH
114221: LD_INT 100
114223: PUSH
114224: LD_VAR 0 8
114228: PLUS
114229: EQUAL
114230: IFFALSE 114275
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114232: LD_ADDR_VAR 0 2
114236: PUSH
114237: LD_VAR 0 2
114241: PPUSH
114242: LD_INT 2
114244: PPUSH
114245: LD_VAR 0 2
114249: PUSH
114250: LD_INT 2
114252: ARRAY
114253: PPUSH
114254: LD_INT 1
114256: PPUSH
114257: CALL_OW 3
114261: PPUSH
114262: CALL_OW 1
114266: ST_TO_ADDR
// tmp := 1 ;
114267: LD_ADDR_VAR 0 3
114271: PUSH
114272: LD_STRING 1
114274: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114275: LD_ADDR_VAR 0 6
114279: PUSH
114280: LD_VAR 0 6
114284: PUSH
114285: LD_VAR 0 3
114289: STR
114290: ST_TO_ADDR
// end ;
114291: GO 114187
114293: POP
114294: POP
// if isGameLoad then
114295: LD_VAR 0 1
114299: IFFALSE 114774
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114301: LD_ADDR_VAR 0 4
114305: PUSH
114306: LD_EXP 149
114310: PUSH
114311: LD_EXP 148
114315: PUSH
114316: LD_EXP 150
114320: PUSH
114321: LD_EXP 147
114325: PUSH
114326: LD_EXP 151
114330: PUSH
114331: LD_EXP 152
114335: PUSH
114336: LD_EXP 153
114340: PUSH
114341: LD_EXP 154
114345: PUSH
114346: LD_EXP 155
114350: PUSH
114351: LD_EXP 156
114355: PUSH
114356: LD_EXP 157
114360: PUSH
114361: LD_EXP 158
114365: PUSH
114366: LD_EXP 159
114370: PUSH
114371: LD_EXP 160
114375: PUSH
114376: LD_EXP 168
114380: PUSH
114381: LD_EXP 169
114385: PUSH
114386: LD_EXP 170
114390: PUSH
114391: LD_EXP 171
114395: PUSH
114396: LD_EXP 173
114400: PUSH
114401: LD_EXP 174
114405: PUSH
114406: LD_EXP 175
114410: PUSH
114411: LD_EXP 178
114415: PUSH
114416: LD_EXP 180
114420: PUSH
114421: LD_EXP 181
114425: PUSH
114426: LD_EXP 182
114430: PUSH
114431: LD_EXP 184
114435: PUSH
114436: LD_EXP 185
114440: PUSH
114441: LD_EXP 188
114445: PUSH
114446: LD_EXP 189
114450: PUSH
114451: LD_EXP 190
114455: PUSH
114456: LD_EXP 191
114460: PUSH
114461: LD_EXP 192
114465: PUSH
114466: LD_EXP 193
114470: PUSH
114471: LD_EXP 194
114475: PUSH
114476: LD_EXP 195
114480: PUSH
114481: LD_EXP 196
114485: PUSH
114486: LD_EXP 161
114490: PUSH
114491: LD_EXP 162
114495: PUSH
114496: LD_EXP 165
114500: PUSH
114501: LD_EXP 166
114505: PUSH
114506: LD_EXP 167
114510: PUSH
114511: LD_EXP 163
114515: PUSH
114516: LD_EXP 164
114520: PUSH
114521: LD_EXP 172
114525: PUSH
114526: LD_EXP 176
114530: PUSH
114531: LD_EXP 177
114535: PUSH
114536: LD_EXP 179
114540: PUSH
114541: LD_EXP 183
114545: PUSH
114546: LD_EXP 186
114550: PUSH
114551: LD_EXP 187
114555: PUSH
114556: LD_EXP 197
114560: PUSH
114561: LD_EXP 198
114565: PUSH
114566: LD_EXP 199
114570: PUSH
114571: LD_EXP 200
114575: PUSH
114576: EMPTY
114577: LIST
114578: LIST
114579: LIST
114580: LIST
114581: LIST
114582: LIST
114583: LIST
114584: LIST
114585: LIST
114586: LIST
114587: LIST
114588: LIST
114589: LIST
114590: LIST
114591: LIST
114592: LIST
114593: LIST
114594: LIST
114595: LIST
114596: LIST
114597: LIST
114598: LIST
114599: LIST
114600: LIST
114601: LIST
114602: LIST
114603: LIST
114604: LIST
114605: LIST
114606: LIST
114607: LIST
114608: LIST
114609: LIST
114610: LIST
114611: LIST
114612: LIST
114613: LIST
114614: LIST
114615: LIST
114616: LIST
114617: LIST
114618: LIST
114619: LIST
114620: LIST
114621: LIST
114622: LIST
114623: LIST
114624: LIST
114625: LIST
114626: LIST
114627: LIST
114628: LIST
114629: LIST
114630: LIST
114631: ST_TO_ADDR
// tmp :=  ;
114632: LD_ADDR_VAR 0 3
114636: PUSH
114637: LD_STRING 
114639: ST_TO_ADDR
// for i = 1 to normalCounter do
114640: LD_ADDR_VAR 0 8
114644: PUSH
114645: DOUBLE
114646: LD_INT 1
114648: DEC
114649: ST_TO_ADDR
114650: LD_EXP 145
114654: PUSH
114655: FOR_TO
114656: IFFALSE 114692
// begin if flags [ i ] then
114658: LD_VAR 0 4
114662: PUSH
114663: LD_VAR 0 8
114667: ARRAY
114668: IFFALSE 114690
// tmp := tmp & i & ; ;
114670: LD_ADDR_VAR 0 3
114674: PUSH
114675: LD_VAR 0 3
114679: PUSH
114680: LD_VAR 0 8
114684: STR
114685: PUSH
114686: LD_STRING ;
114688: STR
114689: ST_TO_ADDR
// end ;
114690: GO 114655
114692: POP
114693: POP
// for i = 1 to hardcoreCounter do
114694: LD_ADDR_VAR 0 8
114698: PUSH
114699: DOUBLE
114700: LD_INT 1
114702: DEC
114703: ST_TO_ADDR
114704: LD_EXP 146
114708: PUSH
114709: FOR_TO
114710: IFFALSE 114756
// begin if flags [ normalCounter + i ] then
114712: LD_VAR 0 4
114716: PUSH
114717: LD_EXP 145
114721: PUSH
114722: LD_VAR 0 8
114726: PLUS
114727: ARRAY
114728: IFFALSE 114754
// tmp := tmp & ( 100 + i ) & ; ;
114730: LD_ADDR_VAR 0 3
114734: PUSH
114735: LD_VAR 0 3
114739: PUSH
114740: LD_INT 100
114742: PUSH
114743: LD_VAR 0 8
114747: PLUS
114748: STR
114749: PUSH
114750: LD_STRING ;
114752: STR
114753: ST_TO_ADDR
// end ;
114754: GO 114709
114756: POP
114757: POP
// if tmp then
114758: LD_VAR 0 3
114762: IFFALSE 114774
// active := tmp ;
114764: LD_ADDR_VAR 0 7
114768: PUSH
114769: LD_VAR 0 3
114773: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114774: LD_STRING getStreamItemsFromMission("
114776: PUSH
114777: LD_VAR 0 5
114781: STR
114782: PUSH
114783: LD_STRING ","
114785: STR
114786: PUSH
114787: LD_VAR 0 6
114791: STR
114792: PUSH
114793: LD_STRING ","
114795: STR
114796: PUSH
114797: LD_VAR 0 7
114801: STR
114802: PUSH
114803: LD_STRING ")
114805: STR
114806: PPUSH
114807: CALL_OW 559
// end else
114811: GO 114820
// ToLua ( getStreamItemsFromMission("","","") ) ;
114813: LD_STRING getStreamItemsFromMission("","","")
114815: PPUSH
114816: CALL_OW 559
// end ;
114820: LD_VAR 0 2
114824: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114825: LD_EXP 144
114829: PUSH
114830: LD_EXP 149
114834: AND
114835: IFFALSE 114959
114837: GO 114839
114839: DISABLE
114840: LD_INT 0
114842: PPUSH
114843: PPUSH
// begin enable ;
114844: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114845: LD_ADDR_VAR 0 2
114849: PUSH
114850: LD_INT 22
114852: PUSH
114853: LD_OWVAR 2
114857: PUSH
114858: EMPTY
114859: LIST
114860: LIST
114861: PUSH
114862: LD_INT 2
114864: PUSH
114865: LD_INT 34
114867: PUSH
114868: LD_INT 7
114870: PUSH
114871: EMPTY
114872: LIST
114873: LIST
114874: PUSH
114875: LD_INT 34
114877: PUSH
114878: LD_INT 45
114880: PUSH
114881: EMPTY
114882: LIST
114883: LIST
114884: PUSH
114885: LD_INT 34
114887: PUSH
114888: LD_INT 28
114890: PUSH
114891: EMPTY
114892: LIST
114893: LIST
114894: PUSH
114895: LD_INT 34
114897: PUSH
114898: LD_INT 47
114900: PUSH
114901: EMPTY
114902: LIST
114903: LIST
114904: PUSH
114905: EMPTY
114906: LIST
114907: LIST
114908: LIST
114909: LIST
114910: LIST
114911: PUSH
114912: EMPTY
114913: LIST
114914: LIST
114915: PPUSH
114916: CALL_OW 69
114920: ST_TO_ADDR
// if not tmp then
114921: LD_VAR 0 2
114925: NOT
114926: IFFALSE 114930
// exit ;
114928: GO 114959
// for i in tmp do
114930: LD_ADDR_VAR 0 1
114934: PUSH
114935: LD_VAR 0 2
114939: PUSH
114940: FOR_IN
114941: IFFALSE 114957
// begin SetLives ( i , 0 ) ;
114943: LD_VAR 0 1
114947: PPUSH
114948: LD_INT 0
114950: PPUSH
114951: CALL_OW 234
// end ;
114955: GO 114940
114957: POP
114958: POP
// end ;
114959: PPOPN 2
114961: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114962: LD_EXP 144
114966: PUSH
114967: LD_EXP 150
114971: AND
114972: IFFALSE 115056
114974: GO 114976
114976: DISABLE
114977: LD_INT 0
114979: PPUSH
114980: PPUSH
// begin enable ;
114981: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114982: LD_ADDR_VAR 0 2
114986: PUSH
114987: LD_INT 22
114989: PUSH
114990: LD_OWVAR 2
114994: PUSH
114995: EMPTY
114996: LIST
114997: LIST
114998: PUSH
114999: LD_INT 32
115001: PUSH
115002: LD_INT 3
115004: PUSH
115005: EMPTY
115006: LIST
115007: LIST
115008: PUSH
115009: EMPTY
115010: LIST
115011: LIST
115012: PPUSH
115013: CALL_OW 69
115017: ST_TO_ADDR
// if not tmp then
115018: LD_VAR 0 2
115022: NOT
115023: IFFALSE 115027
// exit ;
115025: GO 115056
// for i in tmp do
115027: LD_ADDR_VAR 0 1
115031: PUSH
115032: LD_VAR 0 2
115036: PUSH
115037: FOR_IN
115038: IFFALSE 115054
// begin SetLives ( i , 0 ) ;
115040: LD_VAR 0 1
115044: PPUSH
115045: LD_INT 0
115047: PPUSH
115048: CALL_OW 234
// end ;
115052: GO 115037
115054: POP
115055: POP
// end ;
115056: PPOPN 2
115058: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
115059: LD_EXP 144
115063: PUSH
115064: LD_EXP 147
115068: AND
115069: IFFALSE 115162
115071: GO 115073
115073: DISABLE
115074: LD_INT 0
115076: PPUSH
// begin enable ;
115077: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
115078: LD_ADDR_VAR 0 1
115082: PUSH
115083: LD_INT 22
115085: PUSH
115086: LD_OWVAR 2
115090: PUSH
115091: EMPTY
115092: LIST
115093: LIST
115094: PUSH
115095: LD_INT 2
115097: PUSH
115098: LD_INT 25
115100: PUSH
115101: LD_INT 5
115103: PUSH
115104: EMPTY
115105: LIST
115106: LIST
115107: PUSH
115108: LD_INT 25
115110: PUSH
115111: LD_INT 9
115113: PUSH
115114: EMPTY
115115: LIST
115116: LIST
115117: PUSH
115118: LD_INT 25
115120: PUSH
115121: LD_INT 8
115123: PUSH
115124: EMPTY
115125: LIST
115126: LIST
115127: PUSH
115128: EMPTY
115129: LIST
115130: LIST
115131: LIST
115132: LIST
115133: PUSH
115134: EMPTY
115135: LIST
115136: LIST
115137: PPUSH
115138: CALL_OW 69
115142: PUSH
115143: FOR_IN
115144: IFFALSE 115160
// begin SetClass ( i , 1 ) ;
115146: LD_VAR 0 1
115150: PPUSH
115151: LD_INT 1
115153: PPUSH
115154: CALL_OW 336
// end ;
115158: GO 115143
115160: POP
115161: POP
// end ;
115162: PPOPN 1
115164: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
115165: LD_EXP 144
115169: PUSH
115170: LD_EXP 148
115174: AND
115175: PUSH
115176: LD_OWVAR 65
115180: PUSH
115181: LD_INT 7
115183: LESS
115184: AND
115185: IFFALSE 115199
115187: GO 115189
115189: DISABLE
// begin enable ;
115190: ENABLE
// game_speed := 7 ;
115191: LD_ADDR_OWVAR 65
115195: PUSH
115196: LD_INT 7
115198: ST_TO_ADDR
// end ;
115199: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
115200: LD_EXP 144
115204: PUSH
115205: LD_EXP 151
115209: AND
115210: IFFALSE 115412
115212: GO 115214
115214: DISABLE
115215: LD_INT 0
115217: PPUSH
115218: PPUSH
115219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115220: LD_ADDR_VAR 0 3
115224: PUSH
115225: LD_INT 81
115227: PUSH
115228: LD_OWVAR 2
115232: PUSH
115233: EMPTY
115234: LIST
115235: LIST
115236: PUSH
115237: LD_INT 21
115239: PUSH
115240: LD_INT 1
115242: PUSH
115243: EMPTY
115244: LIST
115245: LIST
115246: PUSH
115247: EMPTY
115248: LIST
115249: LIST
115250: PPUSH
115251: CALL_OW 69
115255: ST_TO_ADDR
// if not tmp then
115256: LD_VAR 0 3
115260: NOT
115261: IFFALSE 115265
// exit ;
115263: GO 115412
// if tmp > 5 then
115265: LD_VAR 0 3
115269: PUSH
115270: LD_INT 5
115272: GREATER
115273: IFFALSE 115285
// k := 5 else
115275: LD_ADDR_VAR 0 2
115279: PUSH
115280: LD_INT 5
115282: ST_TO_ADDR
115283: GO 115295
// k := tmp ;
115285: LD_ADDR_VAR 0 2
115289: PUSH
115290: LD_VAR 0 3
115294: ST_TO_ADDR
// for i := 1 to k do
115295: LD_ADDR_VAR 0 1
115299: PUSH
115300: DOUBLE
115301: LD_INT 1
115303: DEC
115304: ST_TO_ADDR
115305: LD_VAR 0 2
115309: PUSH
115310: FOR_TO
115311: IFFALSE 115410
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115313: LD_VAR 0 3
115317: PUSH
115318: LD_VAR 0 1
115322: ARRAY
115323: PPUSH
115324: LD_VAR 0 1
115328: PUSH
115329: LD_INT 4
115331: MOD
115332: PUSH
115333: LD_INT 1
115335: PLUS
115336: PPUSH
115337: CALL_OW 259
115341: PUSH
115342: LD_INT 10
115344: LESS
115345: IFFALSE 115408
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115347: LD_VAR 0 3
115351: PUSH
115352: LD_VAR 0 1
115356: ARRAY
115357: PPUSH
115358: LD_VAR 0 1
115362: PUSH
115363: LD_INT 4
115365: MOD
115366: PUSH
115367: LD_INT 1
115369: PLUS
115370: PPUSH
115371: LD_VAR 0 3
115375: PUSH
115376: LD_VAR 0 1
115380: ARRAY
115381: PPUSH
115382: LD_VAR 0 1
115386: PUSH
115387: LD_INT 4
115389: MOD
115390: PUSH
115391: LD_INT 1
115393: PLUS
115394: PPUSH
115395: CALL_OW 259
115399: PUSH
115400: LD_INT 1
115402: PLUS
115403: PPUSH
115404: CALL_OW 237
115408: GO 115310
115410: POP
115411: POP
// end ;
115412: PPOPN 3
115414: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115415: LD_EXP 144
115419: PUSH
115420: LD_EXP 152
115424: AND
115425: IFFALSE 115445
115427: GO 115429
115429: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115430: LD_INT 4
115432: PPUSH
115433: LD_OWVAR 2
115437: PPUSH
115438: LD_INT 0
115440: PPUSH
115441: CALL_OW 324
115445: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115446: LD_EXP 144
115450: PUSH
115451: LD_EXP 181
115455: AND
115456: IFFALSE 115476
115458: GO 115460
115460: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115461: LD_INT 19
115463: PPUSH
115464: LD_OWVAR 2
115468: PPUSH
115469: LD_INT 0
115471: PPUSH
115472: CALL_OW 324
115476: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115477: LD_EXP 144
115481: PUSH
115482: LD_EXP 153
115486: AND
115487: IFFALSE 115589
115489: GO 115491
115491: DISABLE
115492: LD_INT 0
115494: PPUSH
115495: PPUSH
// begin enable ;
115496: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115497: LD_ADDR_VAR 0 2
115501: PUSH
115502: LD_INT 22
115504: PUSH
115505: LD_OWVAR 2
115509: PUSH
115510: EMPTY
115511: LIST
115512: LIST
115513: PUSH
115514: LD_INT 2
115516: PUSH
115517: LD_INT 34
115519: PUSH
115520: LD_INT 11
115522: PUSH
115523: EMPTY
115524: LIST
115525: LIST
115526: PUSH
115527: LD_INT 34
115529: PUSH
115530: LD_INT 30
115532: PUSH
115533: EMPTY
115534: LIST
115535: LIST
115536: PUSH
115537: EMPTY
115538: LIST
115539: LIST
115540: LIST
115541: PUSH
115542: EMPTY
115543: LIST
115544: LIST
115545: PPUSH
115546: CALL_OW 69
115550: ST_TO_ADDR
// if not tmp then
115551: LD_VAR 0 2
115555: NOT
115556: IFFALSE 115560
// exit ;
115558: GO 115589
// for i in tmp do
115560: LD_ADDR_VAR 0 1
115564: PUSH
115565: LD_VAR 0 2
115569: PUSH
115570: FOR_IN
115571: IFFALSE 115587
// begin SetLives ( i , 0 ) ;
115573: LD_VAR 0 1
115577: PPUSH
115578: LD_INT 0
115580: PPUSH
115581: CALL_OW 234
// end ;
115585: GO 115570
115587: POP
115588: POP
// end ;
115589: PPOPN 2
115591: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115592: LD_EXP 144
115596: PUSH
115597: LD_EXP 154
115601: AND
115602: IFFALSE 115622
115604: GO 115606
115606: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115607: LD_INT 32
115609: PPUSH
115610: LD_OWVAR 2
115614: PPUSH
115615: LD_INT 0
115617: PPUSH
115618: CALL_OW 324
115622: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115623: LD_EXP 144
115627: PUSH
115628: LD_EXP 155
115632: AND
115633: IFFALSE 115814
115635: GO 115637
115637: DISABLE
115638: LD_INT 0
115640: PPUSH
115641: PPUSH
115642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115643: LD_ADDR_VAR 0 2
115647: PUSH
115648: LD_INT 22
115650: PUSH
115651: LD_OWVAR 2
115655: PUSH
115656: EMPTY
115657: LIST
115658: LIST
115659: PUSH
115660: LD_INT 33
115662: PUSH
115663: LD_INT 3
115665: PUSH
115666: EMPTY
115667: LIST
115668: LIST
115669: PUSH
115670: EMPTY
115671: LIST
115672: LIST
115673: PPUSH
115674: CALL_OW 69
115678: ST_TO_ADDR
// if not tmp then
115679: LD_VAR 0 2
115683: NOT
115684: IFFALSE 115688
// exit ;
115686: GO 115814
// side := 0 ;
115688: LD_ADDR_VAR 0 3
115692: PUSH
115693: LD_INT 0
115695: ST_TO_ADDR
// for i := 1 to 8 do
115696: LD_ADDR_VAR 0 1
115700: PUSH
115701: DOUBLE
115702: LD_INT 1
115704: DEC
115705: ST_TO_ADDR
115706: LD_INT 8
115708: PUSH
115709: FOR_TO
115710: IFFALSE 115758
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115712: LD_OWVAR 2
115716: PUSH
115717: LD_VAR 0 1
115721: NONEQUAL
115722: PUSH
115723: LD_OWVAR 2
115727: PPUSH
115728: LD_VAR 0 1
115732: PPUSH
115733: CALL_OW 81
115737: PUSH
115738: LD_INT 2
115740: EQUAL
115741: AND
115742: IFFALSE 115756
// begin side := i ;
115744: LD_ADDR_VAR 0 3
115748: PUSH
115749: LD_VAR 0 1
115753: ST_TO_ADDR
// break ;
115754: GO 115758
// end ;
115756: GO 115709
115758: POP
115759: POP
// if not side then
115760: LD_VAR 0 3
115764: NOT
115765: IFFALSE 115769
// exit ;
115767: GO 115814
// for i := 1 to tmp do
115769: LD_ADDR_VAR 0 1
115773: PUSH
115774: DOUBLE
115775: LD_INT 1
115777: DEC
115778: ST_TO_ADDR
115779: LD_VAR 0 2
115783: PUSH
115784: FOR_TO
115785: IFFALSE 115812
// if Prob ( 60 ) then
115787: LD_INT 60
115789: PPUSH
115790: CALL_OW 13
115794: IFFALSE 115810
// SetSide ( i , side ) ;
115796: LD_VAR 0 1
115800: PPUSH
115801: LD_VAR 0 3
115805: PPUSH
115806: CALL_OW 235
115810: GO 115784
115812: POP
115813: POP
// end ;
115814: PPOPN 3
115816: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115817: LD_EXP 144
115821: PUSH
115822: LD_EXP 157
115826: AND
115827: IFFALSE 115946
115829: GO 115831
115831: DISABLE
115832: LD_INT 0
115834: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115835: LD_ADDR_VAR 0 1
115839: PUSH
115840: LD_INT 22
115842: PUSH
115843: LD_OWVAR 2
115847: PUSH
115848: EMPTY
115849: LIST
115850: LIST
115851: PUSH
115852: LD_INT 21
115854: PUSH
115855: LD_INT 1
115857: PUSH
115858: EMPTY
115859: LIST
115860: LIST
115861: PUSH
115862: LD_INT 3
115864: PUSH
115865: LD_INT 23
115867: PUSH
115868: LD_INT 0
115870: PUSH
115871: EMPTY
115872: LIST
115873: LIST
115874: PUSH
115875: EMPTY
115876: LIST
115877: LIST
115878: PUSH
115879: EMPTY
115880: LIST
115881: LIST
115882: LIST
115883: PPUSH
115884: CALL_OW 69
115888: PUSH
115889: FOR_IN
115890: IFFALSE 115944
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115892: LD_VAR 0 1
115896: PPUSH
115897: CALL_OW 257
115901: PUSH
115902: LD_INT 1
115904: PUSH
115905: LD_INT 2
115907: PUSH
115908: LD_INT 3
115910: PUSH
115911: LD_INT 4
115913: PUSH
115914: EMPTY
115915: LIST
115916: LIST
115917: LIST
115918: LIST
115919: IN
115920: IFFALSE 115942
// SetClass ( un , rand ( 1 , 4 ) ) ;
115922: LD_VAR 0 1
115926: PPUSH
115927: LD_INT 1
115929: PPUSH
115930: LD_INT 4
115932: PPUSH
115933: CALL_OW 12
115937: PPUSH
115938: CALL_OW 336
115942: GO 115889
115944: POP
115945: POP
// end ;
115946: PPOPN 1
115948: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115949: LD_EXP 144
115953: PUSH
115954: LD_EXP 156
115958: AND
115959: IFFALSE 116038
115961: GO 115963
115963: DISABLE
115964: LD_INT 0
115966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115967: LD_ADDR_VAR 0 1
115971: PUSH
115972: LD_INT 22
115974: PUSH
115975: LD_OWVAR 2
115979: PUSH
115980: EMPTY
115981: LIST
115982: LIST
115983: PUSH
115984: LD_INT 21
115986: PUSH
115987: LD_INT 3
115989: PUSH
115990: EMPTY
115991: LIST
115992: LIST
115993: PUSH
115994: EMPTY
115995: LIST
115996: LIST
115997: PPUSH
115998: CALL_OW 69
116002: ST_TO_ADDR
// if not tmp then
116003: LD_VAR 0 1
116007: NOT
116008: IFFALSE 116012
// exit ;
116010: GO 116038
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
116012: LD_VAR 0 1
116016: PUSH
116017: LD_INT 1
116019: PPUSH
116020: LD_VAR 0 1
116024: PPUSH
116025: CALL_OW 12
116029: ARRAY
116030: PPUSH
116031: LD_INT 100
116033: PPUSH
116034: CALL_OW 234
// end ;
116038: PPOPN 1
116040: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
116041: LD_EXP 144
116045: PUSH
116046: LD_EXP 158
116050: AND
116051: IFFALSE 116149
116053: GO 116055
116055: DISABLE
116056: LD_INT 0
116058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116059: LD_ADDR_VAR 0 1
116063: PUSH
116064: LD_INT 22
116066: PUSH
116067: LD_OWVAR 2
116071: PUSH
116072: EMPTY
116073: LIST
116074: LIST
116075: PUSH
116076: LD_INT 21
116078: PUSH
116079: LD_INT 1
116081: PUSH
116082: EMPTY
116083: LIST
116084: LIST
116085: PUSH
116086: EMPTY
116087: LIST
116088: LIST
116089: PPUSH
116090: CALL_OW 69
116094: ST_TO_ADDR
// if not tmp then
116095: LD_VAR 0 1
116099: NOT
116100: IFFALSE 116104
// exit ;
116102: GO 116149
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
116104: LD_VAR 0 1
116108: PUSH
116109: LD_INT 1
116111: PPUSH
116112: LD_VAR 0 1
116116: PPUSH
116117: CALL_OW 12
116121: ARRAY
116122: PPUSH
116123: LD_INT 1
116125: PPUSH
116126: LD_INT 4
116128: PPUSH
116129: CALL_OW 12
116133: PPUSH
116134: LD_INT 3000
116136: PPUSH
116137: LD_INT 9000
116139: PPUSH
116140: CALL_OW 12
116144: PPUSH
116145: CALL_OW 492
// end ;
116149: PPOPN 1
116151: END
// every 0 0$1 trigger StreamModeActive and sDepot do
116152: LD_EXP 144
116156: PUSH
116157: LD_EXP 159
116161: AND
116162: IFFALSE 116182
116164: GO 116166
116166: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
116167: LD_INT 1
116169: PPUSH
116170: LD_OWVAR 2
116174: PPUSH
116175: LD_INT 0
116177: PPUSH
116178: CALL_OW 324
116182: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
116183: LD_EXP 144
116187: PUSH
116188: LD_EXP 160
116192: AND
116193: IFFALSE 116276
116195: GO 116197
116197: DISABLE
116198: LD_INT 0
116200: PPUSH
116201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116202: LD_ADDR_VAR 0 2
116206: PUSH
116207: LD_INT 22
116209: PUSH
116210: LD_OWVAR 2
116214: PUSH
116215: EMPTY
116216: LIST
116217: LIST
116218: PUSH
116219: LD_INT 21
116221: PUSH
116222: LD_INT 3
116224: PUSH
116225: EMPTY
116226: LIST
116227: LIST
116228: PUSH
116229: EMPTY
116230: LIST
116231: LIST
116232: PPUSH
116233: CALL_OW 69
116237: ST_TO_ADDR
// if not tmp then
116238: LD_VAR 0 2
116242: NOT
116243: IFFALSE 116247
// exit ;
116245: GO 116276
// for i in tmp do
116247: LD_ADDR_VAR 0 1
116251: PUSH
116252: LD_VAR 0 2
116256: PUSH
116257: FOR_IN
116258: IFFALSE 116274
// SetBLevel ( i , 10 ) ;
116260: LD_VAR 0 1
116264: PPUSH
116265: LD_INT 10
116267: PPUSH
116268: CALL_OW 241
116272: GO 116257
116274: POP
116275: POP
// end ;
116276: PPOPN 2
116278: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116279: LD_EXP 144
116283: PUSH
116284: LD_EXP 161
116288: AND
116289: IFFALSE 116400
116291: GO 116293
116293: DISABLE
116294: LD_INT 0
116296: PPUSH
116297: PPUSH
116298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116299: LD_ADDR_VAR 0 3
116303: PUSH
116304: LD_INT 22
116306: PUSH
116307: LD_OWVAR 2
116311: PUSH
116312: EMPTY
116313: LIST
116314: LIST
116315: PUSH
116316: LD_INT 25
116318: PUSH
116319: LD_INT 1
116321: PUSH
116322: EMPTY
116323: LIST
116324: LIST
116325: PUSH
116326: EMPTY
116327: LIST
116328: LIST
116329: PPUSH
116330: CALL_OW 69
116334: ST_TO_ADDR
// if not tmp then
116335: LD_VAR 0 3
116339: NOT
116340: IFFALSE 116344
// exit ;
116342: GO 116400
// un := tmp [ rand ( 1 , tmp ) ] ;
116344: LD_ADDR_VAR 0 2
116348: PUSH
116349: LD_VAR 0 3
116353: PUSH
116354: LD_INT 1
116356: PPUSH
116357: LD_VAR 0 3
116361: PPUSH
116362: CALL_OW 12
116366: ARRAY
116367: ST_TO_ADDR
// if Crawls ( un ) then
116368: LD_VAR 0 2
116372: PPUSH
116373: CALL_OW 318
116377: IFFALSE 116388
// ComWalk ( un ) ;
116379: LD_VAR 0 2
116383: PPUSH
116384: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116388: LD_VAR 0 2
116392: PPUSH
116393: LD_INT 5
116395: PPUSH
116396: CALL_OW 336
// end ;
116400: PPOPN 3
116402: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116403: LD_EXP 144
116407: PUSH
116408: LD_EXP 162
116412: AND
116413: PUSH
116414: LD_OWVAR 67
116418: PUSH
116419: LD_INT 4
116421: LESS
116422: AND
116423: IFFALSE 116442
116425: GO 116427
116427: DISABLE
// begin Difficulty := Difficulty + 1 ;
116428: LD_ADDR_OWVAR 67
116432: PUSH
116433: LD_OWVAR 67
116437: PUSH
116438: LD_INT 1
116440: PLUS
116441: ST_TO_ADDR
// end ;
116442: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116443: LD_EXP 144
116447: PUSH
116448: LD_EXP 163
116452: AND
116453: IFFALSE 116556
116455: GO 116457
116457: DISABLE
116458: LD_INT 0
116460: PPUSH
// begin for i := 1 to 5 do
116461: LD_ADDR_VAR 0 1
116465: PUSH
116466: DOUBLE
116467: LD_INT 1
116469: DEC
116470: ST_TO_ADDR
116471: LD_INT 5
116473: PUSH
116474: FOR_TO
116475: IFFALSE 116554
// begin uc_nation := nation_nature ;
116477: LD_ADDR_OWVAR 21
116481: PUSH
116482: LD_INT 0
116484: ST_TO_ADDR
// uc_side := 0 ;
116485: LD_ADDR_OWVAR 20
116489: PUSH
116490: LD_INT 0
116492: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116493: LD_ADDR_OWVAR 29
116497: PUSH
116498: LD_INT 12
116500: PUSH
116501: LD_INT 12
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: ST_TO_ADDR
// hc_agressivity := 20 ;
116508: LD_ADDR_OWVAR 35
116512: PUSH
116513: LD_INT 20
116515: ST_TO_ADDR
// hc_class := class_tiger ;
116516: LD_ADDR_OWVAR 28
116520: PUSH
116521: LD_INT 14
116523: ST_TO_ADDR
// hc_gallery :=  ;
116524: LD_ADDR_OWVAR 33
116528: PUSH
116529: LD_STRING 
116531: ST_TO_ADDR
// hc_name :=  ;
116532: LD_ADDR_OWVAR 26
116536: PUSH
116537: LD_STRING 
116539: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116540: CALL_OW 44
116544: PPUSH
116545: LD_INT 0
116547: PPUSH
116548: CALL_OW 51
// end ;
116552: GO 116474
116554: POP
116555: POP
// end ;
116556: PPOPN 1
116558: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116559: LD_EXP 144
116563: PUSH
116564: LD_EXP 164
116568: AND
116569: IFFALSE 116578
116571: GO 116573
116573: DISABLE
// StreamSibBomb ;
116574: CALL 116579 0 0
116578: END
// export function StreamSibBomb ; var i , x , y ; begin
116579: LD_INT 0
116581: PPUSH
116582: PPUSH
116583: PPUSH
116584: PPUSH
// result := false ;
116585: LD_ADDR_VAR 0 1
116589: PUSH
116590: LD_INT 0
116592: ST_TO_ADDR
// for i := 1 to 16 do
116593: LD_ADDR_VAR 0 2
116597: PUSH
116598: DOUBLE
116599: LD_INT 1
116601: DEC
116602: ST_TO_ADDR
116603: LD_INT 16
116605: PUSH
116606: FOR_TO
116607: IFFALSE 116806
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116609: LD_ADDR_VAR 0 3
116613: PUSH
116614: LD_INT 10
116616: PUSH
116617: LD_INT 20
116619: PUSH
116620: LD_INT 30
116622: PUSH
116623: LD_INT 40
116625: PUSH
116626: LD_INT 50
116628: PUSH
116629: LD_INT 60
116631: PUSH
116632: LD_INT 70
116634: PUSH
116635: LD_INT 80
116637: PUSH
116638: LD_INT 90
116640: PUSH
116641: LD_INT 100
116643: PUSH
116644: LD_INT 110
116646: PUSH
116647: LD_INT 120
116649: PUSH
116650: LD_INT 130
116652: PUSH
116653: LD_INT 140
116655: PUSH
116656: LD_INT 150
116658: PUSH
116659: EMPTY
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: LIST
116672: LIST
116673: LIST
116674: LIST
116675: PUSH
116676: LD_INT 1
116678: PPUSH
116679: LD_INT 15
116681: PPUSH
116682: CALL_OW 12
116686: ARRAY
116687: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116688: LD_ADDR_VAR 0 4
116692: PUSH
116693: LD_INT 10
116695: PUSH
116696: LD_INT 20
116698: PUSH
116699: LD_INT 30
116701: PUSH
116702: LD_INT 40
116704: PUSH
116705: LD_INT 50
116707: PUSH
116708: LD_INT 60
116710: PUSH
116711: LD_INT 70
116713: PUSH
116714: LD_INT 80
116716: PUSH
116717: LD_INT 90
116719: PUSH
116720: LD_INT 100
116722: PUSH
116723: LD_INT 110
116725: PUSH
116726: LD_INT 120
116728: PUSH
116729: LD_INT 130
116731: PUSH
116732: LD_INT 140
116734: PUSH
116735: LD_INT 150
116737: PUSH
116738: EMPTY
116739: LIST
116740: LIST
116741: LIST
116742: LIST
116743: LIST
116744: LIST
116745: LIST
116746: LIST
116747: LIST
116748: LIST
116749: LIST
116750: LIST
116751: LIST
116752: LIST
116753: LIST
116754: PUSH
116755: LD_INT 1
116757: PPUSH
116758: LD_INT 15
116760: PPUSH
116761: CALL_OW 12
116765: ARRAY
116766: ST_TO_ADDR
// if ValidHex ( x , y ) then
116767: LD_VAR 0 3
116771: PPUSH
116772: LD_VAR 0 4
116776: PPUSH
116777: CALL_OW 488
116781: IFFALSE 116804
// begin result := [ x , y ] ;
116783: LD_ADDR_VAR 0 1
116787: PUSH
116788: LD_VAR 0 3
116792: PUSH
116793: LD_VAR 0 4
116797: PUSH
116798: EMPTY
116799: LIST
116800: LIST
116801: ST_TO_ADDR
// break ;
116802: GO 116806
// end ; end ;
116804: GO 116606
116806: POP
116807: POP
// if result then
116808: LD_VAR 0 1
116812: IFFALSE 116872
// begin ToLua ( playSibBomb() ) ;
116814: LD_STRING playSibBomb()
116816: PPUSH
116817: CALL_OW 559
// wait ( 0 0$14 ) ;
116821: LD_INT 490
116823: PPUSH
116824: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116828: LD_VAR 0 1
116832: PUSH
116833: LD_INT 1
116835: ARRAY
116836: PPUSH
116837: LD_VAR 0 1
116841: PUSH
116842: LD_INT 2
116844: ARRAY
116845: PPUSH
116846: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116850: LD_VAR 0 1
116854: PUSH
116855: LD_INT 1
116857: ARRAY
116858: PPUSH
116859: LD_VAR 0 1
116863: PUSH
116864: LD_INT 2
116866: ARRAY
116867: PPUSH
116868: CALL_OW 429
// end ; end ;
116872: LD_VAR 0 1
116876: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116877: LD_EXP 144
116881: PUSH
116882: LD_EXP 166
116886: AND
116887: IFFALSE 116899
116889: GO 116891
116891: DISABLE
// YouLost (  ) ;
116892: LD_STRING 
116894: PPUSH
116895: CALL_OW 104
116899: END
// every 0 0$1 trigger StreamModeActive and sFog do
116900: LD_EXP 144
116904: PUSH
116905: LD_EXP 165
116909: AND
116910: IFFALSE 116924
116912: GO 116914
116914: DISABLE
// FogOff ( your_side ) ;
116915: LD_OWVAR 2
116919: PPUSH
116920: CALL_OW 344
116924: END
// every 0 0$1 trigger StreamModeActive and sSun do
116925: LD_EXP 144
116929: PUSH
116930: LD_EXP 167
116934: AND
116935: IFFALSE 116963
116937: GO 116939
116939: DISABLE
// begin solar_recharge_percent := 0 ;
116940: LD_ADDR_OWVAR 79
116944: PUSH
116945: LD_INT 0
116947: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116948: LD_INT 10500
116950: PPUSH
116951: CALL_OW 67
// solar_recharge_percent := 100 ;
116955: LD_ADDR_OWVAR 79
116959: PUSH
116960: LD_INT 100
116962: ST_TO_ADDR
// end ;
116963: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116964: LD_EXP 144
116968: PUSH
116969: LD_EXP 168
116973: AND
116974: IFFALSE 117213
116976: GO 116978
116978: DISABLE
116979: LD_INT 0
116981: PPUSH
116982: PPUSH
116983: PPUSH
// begin tmp := [ ] ;
116984: LD_ADDR_VAR 0 3
116988: PUSH
116989: EMPTY
116990: ST_TO_ADDR
// for i := 1 to 6 do
116991: LD_ADDR_VAR 0 1
116995: PUSH
116996: DOUBLE
116997: LD_INT 1
116999: DEC
117000: ST_TO_ADDR
117001: LD_INT 6
117003: PUSH
117004: FOR_TO
117005: IFFALSE 117110
// begin uc_nation := nation_nature ;
117007: LD_ADDR_OWVAR 21
117011: PUSH
117012: LD_INT 0
117014: ST_TO_ADDR
// uc_side := 0 ;
117015: LD_ADDR_OWVAR 20
117019: PUSH
117020: LD_INT 0
117022: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117023: LD_ADDR_OWVAR 29
117027: PUSH
117028: LD_INT 12
117030: PUSH
117031: LD_INT 12
117033: PUSH
117034: EMPTY
117035: LIST
117036: LIST
117037: ST_TO_ADDR
// hc_agressivity := 20 ;
117038: LD_ADDR_OWVAR 35
117042: PUSH
117043: LD_INT 20
117045: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
117046: LD_ADDR_OWVAR 28
117050: PUSH
117051: LD_INT 17
117053: ST_TO_ADDR
// hc_gallery :=  ;
117054: LD_ADDR_OWVAR 33
117058: PUSH
117059: LD_STRING 
117061: ST_TO_ADDR
// hc_name :=  ;
117062: LD_ADDR_OWVAR 26
117066: PUSH
117067: LD_STRING 
117069: ST_TO_ADDR
// un := CreateHuman ;
117070: LD_ADDR_VAR 0 2
117074: PUSH
117075: CALL_OW 44
117079: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
117080: LD_VAR 0 2
117084: PPUSH
117085: LD_INT 1
117087: PPUSH
117088: CALL_OW 51
// tmp := tmp ^ un ;
117092: LD_ADDR_VAR 0 3
117096: PUSH
117097: LD_VAR 0 3
117101: PUSH
117102: LD_VAR 0 2
117106: ADD
117107: ST_TO_ADDR
// end ;
117108: GO 117004
117110: POP
117111: POP
// repeat wait ( 0 0$1 ) ;
117112: LD_INT 35
117114: PPUSH
117115: CALL_OW 67
// for un in tmp do
117119: LD_ADDR_VAR 0 2
117123: PUSH
117124: LD_VAR 0 3
117128: PUSH
117129: FOR_IN
117130: IFFALSE 117204
// begin if IsDead ( un ) then
117132: LD_VAR 0 2
117136: PPUSH
117137: CALL_OW 301
117141: IFFALSE 117161
// begin tmp := tmp diff un ;
117143: LD_ADDR_VAR 0 3
117147: PUSH
117148: LD_VAR 0 3
117152: PUSH
117153: LD_VAR 0 2
117157: DIFF
117158: ST_TO_ADDR
// continue ;
117159: GO 117129
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
117161: LD_VAR 0 2
117165: PPUSH
117166: LD_INT 3
117168: PUSH
117169: LD_INT 22
117171: PUSH
117172: LD_INT 0
117174: PUSH
117175: EMPTY
117176: LIST
117177: LIST
117178: PUSH
117179: EMPTY
117180: LIST
117181: LIST
117182: PPUSH
117183: CALL_OW 69
117187: PPUSH
117188: LD_VAR 0 2
117192: PPUSH
117193: CALL_OW 74
117197: PPUSH
117198: CALL_OW 115
// end ;
117202: GO 117129
117204: POP
117205: POP
// until not tmp ;
117206: LD_VAR 0 3
117210: NOT
117211: IFFALSE 117112
// end ;
117213: PPOPN 3
117215: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117216: LD_EXP 144
117220: PUSH
117221: LD_EXP 169
117225: AND
117226: IFFALSE 117280
117228: GO 117230
117230: DISABLE
// begin ToLua ( displayTroll(); ) ;
117231: LD_STRING displayTroll();
117233: PPUSH
117234: CALL_OW 559
// wait ( 3 3$00 ) ;
117238: LD_INT 6300
117240: PPUSH
117241: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117245: LD_STRING hideTroll();
117247: PPUSH
117248: CALL_OW 559
// wait ( 1 1$00 ) ;
117252: LD_INT 2100
117254: PPUSH
117255: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117259: LD_STRING displayTroll();
117261: PPUSH
117262: CALL_OW 559
// wait ( 1 1$00 ) ;
117266: LD_INT 2100
117268: PPUSH
117269: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117273: LD_STRING hideTroll();
117275: PPUSH
117276: CALL_OW 559
// end ;
117280: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117281: LD_EXP 144
117285: PUSH
117286: LD_EXP 170
117290: AND
117291: IFFALSE 117354
117293: GO 117295
117295: DISABLE
117296: LD_INT 0
117298: PPUSH
// begin p := 0 ;
117299: LD_ADDR_VAR 0 1
117303: PUSH
117304: LD_INT 0
117306: ST_TO_ADDR
// repeat game_speed := 1 ;
117307: LD_ADDR_OWVAR 65
117311: PUSH
117312: LD_INT 1
117314: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117315: LD_INT 35
117317: PPUSH
117318: CALL_OW 67
// p := p + 1 ;
117322: LD_ADDR_VAR 0 1
117326: PUSH
117327: LD_VAR 0 1
117331: PUSH
117332: LD_INT 1
117334: PLUS
117335: ST_TO_ADDR
// until p >= 60 ;
117336: LD_VAR 0 1
117340: PUSH
117341: LD_INT 60
117343: GREATEREQUAL
117344: IFFALSE 117307
// game_speed := 4 ;
117346: LD_ADDR_OWVAR 65
117350: PUSH
117351: LD_INT 4
117353: ST_TO_ADDR
// end ;
117354: PPOPN 1
117356: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117357: LD_EXP 144
117361: PUSH
117362: LD_EXP 171
117366: AND
117367: IFFALSE 117513
117369: GO 117371
117371: DISABLE
117372: LD_INT 0
117374: PPUSH
117375: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117376: LD_ADDR_VAR 0 1
117380: PUSH
117381: LD_INT 22
117383: PUSH
117384: LD_OWVAR 2
117388: PUSH
117389: EMPTY
117390: LIST
117391: LIST
117392: PUSH
117393: LD_INT 2
117395: PUSH
117396: LD_INT 30
117398: PUSH
117399: LD_INT 0
117401: PUSH
117402: EMPTY
117403: LIST
117404: LIST
117405: PUSH
117406: LD_INT 30
117408: PUSH
117409: LD_INT 1
117411: PUSH
117412: EMPTY
117413: LIST
117414: LIST
117415: PUSH
117416: EMPTY
117417: LIST
117418: LIST
117419: LIST
117420: PUSH
117421: EMPTY
117422: LIST
117423: LIST
117424: PPUSH
117425: CALL_OW 69
117429: ST_TO_ADDR
// if not depot then
117430: LD_VAR 0 1
117434: NOT
117435: IFFALSE 117439
// exit ;
117437: GO 117513
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117439: LD_ADDR_VAR 0 2
117443: PUSH
117444: LD_VAR 0 1
117448: PUSH
117449: LD_INT 1
117451: PPUSH
117452: LD_VAR 0 1
117456: PPUSH
117457: CALL_OW 12
117461: ARRAY
117462: PPUSH
117463: CALL_OW 274
117467: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117468: LD_VAR 0 2
117472: PPUSH
117473: LD_INT 1
117475: PPUSH
117476: LD_INT 0
117478: PPUSH
117479: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117483: LD_VAR 0 2
117487: PPUSH
117488: LD_INT 2
117490: PPUSH
117491: LD_INT 0
117493: PPUSH
117494: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117498: LD_VAR 0 2
117502: PPUSH
117503: LD_INT 3
117505: PPUSH
117506: LD_INT 0
117508: PPUSH
117509: CALL_OW 277
// end ;
117513: PPOPN 2
117515: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117516: LD_EXP 144
117520: PUSH
117521: LD_EXP 172
117525: AND
117526: IFFALSE 117623
117528: GO 117530
117530: DISABLE
117531: LD_INT 0
117533: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117534: LD_ADDR_VAR 0 1
117538: PUSH
117539: LD_INT 22
117541: PUSH
117542: LD_OWVAR 2
117546: PUSH
117547: EMPTY
117548: LIST
117549: LIST
117550: PUSH
117551: LD_INT 21
117553: PUSH
117554: LD_INT 1
117556: PUSH
117557: EMPTY
117558: LIST
117559: LIST
117560: PUSH
117561: LD_INT 3
117563: PUSH
117564: LD_INT 23
117566: PUSH
117567: LD_INT 0
117569: PUSH
117570: EMPTY
117571: LIST
117572: LIST
117573: PUSH
117574: EMPTY
117575: LIST
117576: LIST
117577: PUSH
117578: EMPTY
117579: LIST
117580: LIST
117581: LIST
117582: PPUSH
117583: CALL_OW 69
117587: ST_TO_ADDR
// if not tmp then
117588: LD_VAR 0 1
117592: NOT
117593: IFFALSE 117597
// exit ;
117595: GO 117623
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117597: LD_VAR 0 1
117601: PUSH
117602: LD_INT 1
117604: PPUSH
117605: LD_VAR 0 1
117609: PPUSH
117610: CALL_OW 12
117614: ARRAY
117615: PPUSH
117616: LD_INT 200
117618: PPUSH
117619: CALL_OW 234
// end ;
117623: PPOPN 1
117625: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117626: LD_EXP 144
117630: PUSH
117631: LD_EXP 173
117635: AND
117636: IFFALSE 117715
117638: GO 117640
117640: DISABLE
117641: LD_INT 0
117643: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117644: LD_ADDR_VAR 0 1
117648: PUSH
117649: LD_INT 22
117651: PUSH
117652: LD_OWVAR 2
117656: PUSH
117657: EMPTY
117658: LIST
117659: LIST
117660: PUSH
117661: LD_INT 21
117663: PUSH
117664: LD_INT 2
117666: PUSH
117667: EMPTY
117668: LIST
117669: LIST
117670: PUSH
117671: EMPTY
117672: LIST
117673: LIST
117674: PPUSH
117675: CALL_OW 69
117679: ST_TO_ADDR
// if not tmp then
117680: LD_VAR 0 1
117684: NOT
117685: IFFALSE 117689
// exit ;
117687: GO 117715
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117689: LD_VAR 0 1
117693: PUSH
117694: LD_INT 1
117696: PPUSH
117697: LD_VAR 0 1
117701: PPUSH
117702: CALL_OW 12
117706: ARRAY
117707: PPUSH
117708: LD_INT 60
117710: PPUSH
117711: CALL_OW 234
// end ;
117715: PPOPN 1
117717: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117718: LD_EXP 144
117722: PUSH
117723: LD_EXP 174
117727: AND
117728: IFFALSE 117827
117730: GO 117732
117732: DISABLE
117733: LD_INT 0
117735: PPUSH
117736: PPUSH
// begin enable ;
117737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117738: LD_ADDR_VAR 0 1
117742: PUSH
117743: LD_INT 22
117745: PUSH
117746: LD_OWVAR 2
117750: PUSH
117751: EMPTY
117752: LIST
117753: LIST
117754: PUSH
117755: LD_INT 61
117757: PUSH
117758: EMPTY
117759: LIST
117760: PUSH
117761: LD_INT 33
117763: PUSH
117764: LD_INT 2
117766: PUSH
117767: EMPTY
117768: LIST
117769: LIST
117770: PUSH
117771: EMPTY
117772: LIST
117773: LIST
117774: LIST
117775: PPUSH
117776: CALL_OW 69
117780: ST_TO_ADDR
// if not tmp then
117781: LD_VAR 0 1
117785: NOT
117786: IFFALSE 117790
// exit ;
117788: GO 117827
// for i in tmp do
117790: LD_ADDR_VAR 0 2
117794: PUSH
117795: LD_VAR 0 1
117799: PUSH
117800: FOR_IN
117801: IFFALSE 117825
// if IsControledBy ( i ) then
117803: LD_VAR 0 2
117807: PPUSH
117808: CALL_OW 312
117812: IFFALSE 117823
// ComUnlink ( i ) ;
117814: LD_VAR 0 2
117818: PPUSH
117819: CALL_OW 136
117823: GO 117800
117825: POP
117826: POP
// end ;
117827: PPOPN 2
117829: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117830: LD_EXP 144
117834: PUSH
117835: LD_EXP 175
117839: AND
117840: IFFALSE 117980
117842: GO 117844
117844: DISABLE
117845: LD_INT 0
117847: PPUSH
117848: PPUSH
// begin ToLua ( displayPowell(); ) ;
117849: LD_STRING displayPowell();
117851: PPUSH
117852: CALL_OW 559
// uc_side := 0 ;
117856: LD_ADDR_OWVAR 20
117860: PUSH
117861: LD_INT 0
117863: ST_TO_ADDR
// uc_nation := 2 ;
117864: LD_ADDR_OWVAR 21
117868: PUSH
117869: LD_INT 2
117871: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117872: LD_ADDR_OWVAR 37
117876: PUSH
117877: LD_INT 14
117879: ST_TO_ADDR
// vc_engine := engine_siberite ;
117880: LD_ADDR_OWVAR 39
117884: PUSH
117885: LD_INT 3
117887: ST_TO_ADDR
// vc_control := control_apeman ;
117888: LD_ADDR_OWVAR 38
117892: PUSH
117893: LD_INT 5
117895: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117896: LD_ADDR_OWVAR 40
117900: PUSH
117901: LD_INT 29
117903: ST_TO_ADDR
// un := CreateVehicle ;
117904: LD_ADDR_VAR 0 2
117908: PUSH
117909: CALL_OW 45
117913: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117914: LD_VAR 0 2
117918: PPUSH
117919: LD_INT 1
117921: PPUSH
117922: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117926: LD_INT 35
117928: PPUSH
117929: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117933: LD_VAR 0 2
117937: PPUSH
117938: LD_INT 22
117940: PUSH
117941: LD_OWVAR 2
117945: PUSH
117946: EMPTY
117947: LIST
117948: LIST
117949: PPUSH
117950: CALL_OW 69
117954: PPUSH
117955: LD_VAR 0 2
117959: PPUSH
117960: CALL_OW 74
117964: PPUSH
117965: CALL_OW 115
// until IsDead ( un ) ;
117969: LD_VAR 0 2
117973: PPUSH
117974: CALL_OW 301
117978: IFFALSE 117926
// end ;
117980: PPOPN 2
117982: END
// every 0 0$1 trigger StreamModeActive and sStu do
117983: LD_EXP 144
117987: PUSH
117988: LD_EXP 183
117992: AND
117993: IFFALSE 118009
117995: GO 117997
117997: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117998: LD_STRING displayStucuk();
118000: PPUSH
118001: CALL_OW 559
// ResetFog ;
118005: CALL_OW 335
// end ;
118009: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
118010: LD_EXP 144
118014: PUSH
118015: LD_EXP 176
118019: AND
118020: IFFALSE 118161
118022: GO 118024
118024: DISABLE
118025: LD_INT 0
118027: PPUSH
118028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118029: LD_ADDR_VAR 0 2
118033: PUSH
118034: LD_INT 22
118036: PUSH
118037: LD_OWVAR 2
118041: PUSH
118042: EMPTY
118043: LIST
118044: LIST
118045: PUSH
118046: LD_INT 21
118048: PUSH
118049: LD_INT 1
118051: PUSH
118052: EMPTY
118053: LIST
118054: LIST
118055: PUSH
118056: EMPTY
118057: LIST
118058: LIST
118059: PPUSH
118060: CALL_OW 69
118064: ST_TO_ADDR
// if not tmp then
118065: LD_VAR 0 2
118069: NOT
118070: IFFALSE 118074
// exit ;
118072: GO 118161
// un := tmp [ rand ( 1 , tmp ) ] ;
118074: LD_ADDR_VAR 0 1
118078: PUSH
118079: LD_VAR 0 2
118083: PUSH
118084: LD_INT 1
118086: PPUSH
118087: LD_VAR 0 2
118091: PPUSH
118092: CALL_OW 12
118096: ARRAY
118097: ST_TO_ADDR
// SetSide ( un , 0 ) ;
118098: LD_VAR 0 1
118102: PPUSH
118103: LD_INT 0
118105: PPUSH
118106: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
118110: LD_VAR 0 1
118114: PPUSH
118115: LD_OWVAR 3
118119: PUSH
118120: LD_VAR 0 1
118124: DIFF
118125: PPUSH
118126: LD_VAR 0 1
118130: PPUSH
118131: CALL_OW 74
118135: PPUSH
118136: CALL_OW 115
// wait ( 0 0$20 ) ;
118140: LD_INT 700
118142: PPUSH
118143: CALL_OW 67
// SetSide ( un , your_side ) ;
118147: LD_VAR 0 1
118151: PPUSH
118152: LD_OWVAR 2
118156: PPUSH
118157: CALL_OW 235
// end ;
118161: PPOPN 2
118163: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
118164: LD_EXP 144
118168: PUSH
118169: LD_EXP 177
118173: AND
118174: IFFALSE 118280
118176: GO 118178
118178: DISABLE
118179: LD_INT 0
118181: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118182: LD_ADDR_VAR 0 1
118186: PUSH
118187: LD_INT 22
118189: PUSH
118190: LD_OWVAR 2
118194: PUSH
118195: EMPTY
118196: LIST
118197: LIST
118198: PUSH
118199: LD_INT 2
118201: PUSH
118202: LD_INT 30
118204: PUSH
118205: LD_INT 0
118207: PUSH
118208: EMPTY
118209: LIST
118210: LIST
118211: PUSH
118212: LD_INT 30
118214: PUSH
118215: LD_INT 1
118217: PUSH
118218: EMPTY
118219: LIST
118220: LIST
118221: PUSH
118222: EMPTY
118223: LIST
118224: LIST
118225: LIST
118226: PUSH
118227: EMPTY
118228: LIST
118229: LIST
118230: PPUSH
118231: CALL_OW 69
118235: ST_TO_ADDR
// if not depot then
118236: LD_VAR 0 1
118240: NOT
118241: IFFALSE 118245
// exit ;
118243: GO 118280
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118245: LD_VAR 0 1
118249: PUSH
118250: LD_INT 1
118252: ARRAY
118253: PPUSH
118254: CALL_OW 250
118258: PPUSH
118259: LD_VAR 0 1
118263: PUSH
118264: LD_INT 1
118266: ARRAY
118267: PPUSH
118268: CALL_OW 251
118272: PPUSH
118273: LD_INT 70
118275: PPUSH
118276: CALL_OW 495
// end ;
118280: PPOPN 1
118282: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118283: LD_EXP 144
118287: PUSH
118288: LD_EXP 178
118292: AND
118293: IFFALSE 118504
118295: GO 118297
118297: DISABLE
118298: LD_INT 0
118300: PPUSH
118301: PPUSH
118302: PPUSH
118303: PPUSH
118304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118305: LD_ADDR_VAR 0 5
118309: PUSH
118310: LD_INT 22
118312: PUSH
118313: LD_OWVAR 2
118317: PUSH
118318: EMPTY
118319: LIST
118320: LIST
118321: PUSH
118322: LD_INT 21
118324: PUSH
118325: LD_INT 1
118327: PUSH
118328: EMPTY
118329: LIST
118330: LIST
118331: PUSH
118332: EMPTY
118333: LIST
118334: LIST
118335: PPUSH
118336: CALL_OW 69
118340: ST_TO_ADDR
// if not tmp then
118341: LD_VAR 0 5
118345: NOT
118346: IFFALSE 118350
// exit ;
118348: GO 118504
// for i in tmp do
118350: LD_ADDR_VAR 0 1
118354: PUSH
118355: LD_VAR 0 5
118359: PUSH
118360: FOR_IN
118361: IFFALSE 118502
// begin d := rand ( 0 , 5 ) ;
118363: LD_ADDR_VAR 0 4
118367: PUSH
118368: LD_INT 0
118370: PPUSH
118371: LD_INT 5
118373: PPUSH
118374: CALL_OW 12
118378: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118379: LD_ADDR_VAR 0 2
118383: PUSH
118384: LD_VAR 0 1
118388: PPUSH
118389: CALL_OW 250
118393: PPUSH
118394: LD_VAR 0 4
118398: PPUSH
118399: LD_INT 3
118401: PPUSH
118402: LD_INT 12
118404: PPUSH
118405: CALL_OW 12
118409: PPUSH
118410: CALL_OW 272
118414: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118415: LD_ADDR_VAR 0 3
118419: PUSH
118420: LD_VAR 0 1
118424: PPUSH
118425: CALL_OW 251
118429: PPUSH
118430: LD_VAR 0 4
118434: PPUSH
118435: LD_INT 3
118437: PPUSH
118438: LD_INT 12
118440: PPUSH
118441: CALL_OW 12
118445: PPUSH
118446: CALL_OW 273
118450: ST_TO_ADDR
// if ValidHex ( x , y ) then
118451: LD_VAR 0 2
118455: PPUSH
118456: LD_VAR 0 3
118460: PPUSH
118461: CALL_OW 488
118465: IFFALSE 118500
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118467: LD_VAR 0 1
118471: PPUSH
118472: LD_VAR 0 2
118476: PPUSH
118477: LD_VAR 0 3
118481: PPUSH
118482: LD_INT 3
118484: PPUSH
118485: LD_INT 6
118487: PPUSH
118488: CALL_OW 12
118492: PPUSH
118493: LD_INT 1
118495: PPUSH
118496: CALL_OW 483
// end ;
118500: GO 118360
118502: POP
118503: POP
// end ;
118504: PPOPN 5
118506: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118507: LD_EXP 144
118511: PUSH
118512: LD_EXP 179
118516: AND
118517: IFFALSE 118611
118519: GO 118521
118521: DISABLE
118522: LD_INT 0
118524: PPUSH
118525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118526: LD_ADDR_VAR 0 2
118530: PUSH
118531: LD_INT 22
118533: PUSH
118534: LD_OWVAR 2
118538: PUSH
118539: EMPTY
118540: LIST
118541: LIST
118542: PUSH
118543: LD_INT 32
118545: PUSH
118546: LD_INT 1
118548: PUSH
118549: EMPTY
118550: LIST
118551: LIST
118552: PUSH
118553: LD_INT 21
118555: PUSH
118556: LD_INT 2
118558: PUSH
118559: EMPTY
118560: LIST
118561: LIST
118562: PUSH
118563: EMPTY
118564: LIST
118565: LIST
118566: LIST
118567: PPUSH
118568: CALL_OW 69
118572: ST_TO_ADDR
// if not tmp then
118573: LD_VAR 0 2
118577: NOT
118578: IFFALSE 118582
// exit ;
118580: GO 118611
// for i in tmp do
118582: LD_ADDR_VAR 0 1
118586: PUSH
118587: LD_VAR 0 2
118591: PUSH
118592: FOR_IN
118593: IFFALSE 118609
// SetFuel ( i , 0 ) ;
118595: LD_VAR 0 1
118599: PPUSH
118600: LD_INT 0
118602: PPUSH
118603: CALL_OW 240
118607: GO 118592
118609: POP
118610: POP
// end ;
118611: PPOPN 2
118613: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118614: LD_EXP 144
118618: PUSH
118619: LD_EXP 180
118623: AND
118624: IFFALSE 118690
118626: GO 118628
118628: DISABLE
118629: LD_INT 0
118631: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118632: LD_ADDR_VAR 0 1
118636: PUSH
118637: LD_INT 22
118639: PUSH
118640: LD_OWVAR 2
118644: PUSH
118645: EMPTY
118646: LIST
118647: LIST
118648: PUSH
118649: LD_INT 30
118651: PUSH
118652: LD_INT 29
118654: PUSH
118655: EMPTY
118656: LIST
118657: LIST
118658: PUSH
118659: EMPTY
118660: LIST
118661: LIST
118662: PPUSH
118663: CALL_OW 69
118667: ST_TO_ADDR
// if not tmp then
118668: LD_VAR 0 1
118672: NOT
118673: IFFALSE 118677
// exit ;
118675: GO 118690
// DestroyUnit ( tmp [ 1 ] ) ;
118677: LD_VAR 0 1
118681: PUSH
118682: LD_INT 1
118684: ARRAY
118685: PPUSH
118686: CALL_OW 65
// end ;
118690: PPOPN 1
118692: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118693: LD_EXP 144
118697: PUSH
118698: LD_EXP 182
118702: AND
118703: IFFALSE 118832
118705: GO 118707
118707: DISABLE
118708: LD_INT 0
118710: PPUSH
// begin uc_side := 0 ;
118711: LD_ADDR_OWVAR 20
118715: PUSH
118716: LD_INT 0
118718: ST_TO_ADDR
// uc_nation := nation_arabian ;
118719: LD_ADDR_OWVAR 21
118723: PUSH
118724: LD_INT 2
118726: ST_TO_ADDR
// hc_gallery :=  ;
118727: LD_ADDR_OWVAR 33
118731: PUSH
118732: LD_STRING 
118734: ST_TO_ADDR
// hc_name :=  ;
118735: LD_ADDR_OWVAR 26
118739: PUSH
118740: LD_STRING 
118742: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118743: LD_INT 1
118745: PPUSH
118746: LD_INT 11
118748: PPUSH
118749: LD_INT 10
118751: PPUSH
118752: CALL_OW 380
// un := CreateHuman ;
118756: LD_ADDR_VAR 0 1
118760: PUSH
118761: CALL_OW 44
118765: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118766: LD_VAR 0 1
118770: PPUSH
118771: LD_INT 1
118773: PPUSH
118774: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118778: LD_INT 35
118780: PPUSH
118781: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118785: LD_VAR 0 1
118789: PPUSH
118790: LD_INT 22
118792: PUSH
118793: LD_OWVAR 2
118797: PUSH
118798: EMPTY
118799: LIST
118800: LIST
118801: PPUSH
118802: CALL_OW 69
118806: PPUSH
118807: LD_VAR 0 1
118811: PPUSH
118812: CALL_OW 74
118816: PPUSH
118817: CALL_OW 115
// until IsDead ( un ) ;
118821: LD_VAR 0 1
118825: PPUSH
118826: CALL_OW 301
118830: IFFALSE 118778
// end ;
118832: PPOPN 1
118834: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118835: LD_EXP 144
118839: PUSH
118840: LD_EXP 184
118844: AND
118845: IFFALSE 118857
118847: GO 118849
118849: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118850: LD_STRING earthquake(getX(game), 0, 32)
118852: PPUSH
118853: CALL_OW 559
118857: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118858: LD_EXP 144
118862: PUSH
118863: LD_EXP 185
118867: AND
118868: IFFALSE 118959
118870: GO 118872
118872: DISABLE
118873: LD_INT 0
118875: PPUSH
// begin enable ;
118876: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118877: LD_ADDR_VAR 0 1
118881: PUSH
118882: LD_INT 22
118884: PUSH
118885: LD_OWVAR 2
118889: PUSH
118890: EMPTY
118891: LIST
118892: LIST
118893: PUSH
118894: LD_INT 21
118896: PUSH
118897: LD_INT 2
118899: PUSH
118900: EMPTY
118901: LIST
118902: LIST
118903: PUSH
118904: LD_INT 33
118906: PUSH
118907: LD_INT 3
118909: PUSH
118910: EMPTY
118911: LIST
118912: LIST
118913: PUSH
118914: EMPTY
118915: LIST
118916: LIST
118917: LIST
118918: PPUSH
118919: CALL_OW 69
118923: ST_TO_ADDR
// if not tmp then
118924: LD_VAR 0 1
118928: NOT
118929: IFFALSE 118933
// exit ;
118931: GO 118959
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118933: LD_VAR 0 1
118937: PUSH
118938: LD_INT 1
118940: PPUSH
118941: LD_VAR 0 1
118945: PPUSH
118946: CALL_OW 12
118950: ARRAY
118951: PPUSH
118952: LD_INT 1
118954: PPUSH
118955: CALL_OW 234
// end ;
118959: PPOPN 1
118961: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118962: LD_EXP 144
118966: PUSH
118967: LD_EXP 186
118971: AND
118972: IFFALSE 119113
118974: GO 118976
118976: DISABLE
118977: LD_INT 0
118979: PPUSH
118980: PPUSH
118981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118982: LD_ADDR_VAR 0 3
118986: PUSH
118987: LD_INT 22
118989: PUSH
118990: LD_OWVAR 2
118994: PUSH
118995: EMPTY
118996: LIST
118997: LIST
118998: PUSH
118999: LD_INT 25
119001: PUSH
119002: LD_INT 1
119004: PUSH
119005: EMPTY
119006: LIST
119007: LIST
119008: PUSH
119009: EMPTY
119010: LIST
119011: LIST
119012: PPUSH
119013: CALL_OW 69
119017: ST_TO_ADDR
// if not tmp then
119018: LD_VAR 0 3
119022: NOT
119023: IFFALSE 119027
// exit ;
119025: GO 119113
// un := tmp [ rand ( 1 , tmp ) ] ;
119027: LD_ADDR_VAR 0 2
119031: PUSH
119032: LD_VAR 0 3
119036: PUSH
119037: LD_INT 1
119039: PPUSH
119040: LD_VAR 0 3
119044: PPUSH
119045: CALL_OW 12
119049: ARRAY
119050: ST_TO_ADDR
// if Crawls ( un ) then
119051: LD_VAR 0 2
119055: PPUSH
119056: CALL_OW 318
119060: IFFALSE 119071
// ComWalk ( un ) ;
119062: LD_VAR 0 2
119066: PPUSH
119067: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
119071: LD_VAR 0 2
119075: PPUSH
119076: LD_INT 9
119078: PPUSH
119079: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
119083: LD_INT 28
119085: PPUSH
119086: LD_OWVAR 2
119090: PPUSH
119091: LD_INT 2
119093: PPUSH
119094: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
119098: LD_INT 29
119100: PPUSH
119101: LD_OWVAR 2
119105: PPUSH
119106: LD_INT 2
119108: PPUSH
119109: CALL_OW 322
// end ;
119113: PPOPN 3
119115: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
119116: LD_EXP 144
119120: PUSH
119121: LD_EXP 187
119125: AND
119126: IFFALSE 119237
119128: GO 119130
119130: DISABLE
119131: LD_INT 0
119133: PPUSH
119134: PPUSH
119135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119136: LD_ADDR_VAR 0 3
119140: PUSH
119141: LD_INT 22
119143: PUSH
119144: LD_OWVAR 2
119148: PUSH
119149: EMPTY
119150: LIST
119151: LIST
119152: PUSH
119153: LD_INT 25
119155: PUSH
119156: LD_INT 1
119158: PUSH
119159: EMPTY
119160: LIST
119161: LIST
119162: PUSH
119163: EMPTY
119164: LIST
119165: LIST
119166: PPUSH
119167: CALL_OW 69
119171: ST_TO_ADDR
// if not tmp then
119172: LD_VAR 0 3
119176: NOT
119177: IFFALSE 119181
// exit ;
119179: GO 119237
// un := tmp [ rand ( 1 , tmp ) ] ;
119181: LD_ADDR_VAR 0 2
119185: PUSH
119186: LD_VAR 0 3
119190: PUSH
119191: LD_INT 1
119193: PPUSH
119194: LD_VAR 0 3
119198: PPUSH
119199: CALL_OW 12
119203: ARRAY
119204: ST_TO_ADDR
// if Crawls ( un ) then
119205: LD_VAR 0 2
119209: PPUSH
119210: CALL_OW 318
119214: IFFALSE 119225
// ComWalk ( un ) ;
119216: LD_VAR 0 2
119220: PPUSH
119221: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119225: LD_VAR 0 2
119229: PPUSH
119230: LD_INT 8
119232: PPUSH
119233: CALL_OW 336
// end ;
119237: PPOPN 3
119239: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119240: LD_EXP 144
119244: PUSH
119245: LD_EXP 188
119249: AND
119250: IFFALSE 119394
119252: GO 119254
119254: DISABLE
119255: LD_INT 0
119257: PPUSH
119258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119259: LD_ADDR_VAR 0 2
119263: PUSH
119264: LD_INT 22
119266: PUSH
119267: LD_OWVAR 2
119271: PUSH
119272: EMPTY
119273: LIST
119274: LIST
119275: PUSH
119276: LD_INT 21
119278: PUSH
119279: LD_INT 2
119281: PUSH
119282: EMPTY
119283: LIST
119284: LIST
119285: PUSH
119286: LD_INT 2
119288: PUSH
119289: LD_INT 34
119291: PUSH
119292: LD_INT 12
119294: PUSH
119295: EMPTY
119296: LIST
119297: LIST
119298: PUSH
119299: LD_INT 34
119301: PUSH
119302: LD_INT 51
119304: PUSH
119305: EMPTY
119306: LIST
119307: LIST
119308: PUSH
119309: LD_INT 34
119311: PUSH
119312: LD_INT 32
119314: PUSH
119315: EMPTY
119316: LIST
119317: LIST
119318: PUSH
119319: EMPTY
119320: LIST
119321: LIST
119322: LIST
119323: LIST
119324: PUSH
119325: EMPTY
119326: LIST
119327: LIST
119328: LIST
119329: PPUSH
119330: CALL_OW 69
119334: ST_TO_ADDR
// if not tmp then
119335: LD_VAR 0 2
119339: NOT
119340: IFFALSE 119344
// exit ;
119342: GO 119394
// for i in tmp do
119344: LD_ADDR_VAR 0 1
119348: PUSH
119349: LD_VAR 0 2
119353: PUSH
119354: FOR_IN
119355: IFFALSE 119392
// if GetCargo ( i , mat_artifact ) = 0 then
119357: LD_VAR 0 1
119361: PPUSH
119362: LD_INT 4
119364: PPUSH
119365: CALL_OW 289
119369: PUSH
119370: LD_INT 0
119372: EQUAL
119373: IFFALSE 119390
// SetCargo ( i , mat_siberit , 100 ) ;
119375: LD_VAR 0 1
119379: PPUSH
119380: LD_INT 3
119382: PPUSH
119383: LD_INT 100
119385: PPUSH
119386: CALL_OW 290
119390: GO 119354
119392: POP
119393: POP
// end ;
119394: PPOPN 2
119396: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119397: LD_EXP 144
119401: PUSH
119402: LD_EXP 189
119406: AND
119407: IFFALSE 119590
119409: GO 119411
119411: DISABLE
119412: LD_INT 0
119414: PPUSH
119415: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119416: LD_ADDR_VAR 0 2
119420: PUSH
119421: LD_INT 22
119423: PUSH
119424: LD_OWVAR 2
119428: PUSH
119429: EMPTY
119430: LIST
119431: LIST
119432: PPUSH
119433: CALL_OW 69
119437: ST_TO_ADDR
// if not tmp then
119438: LD_VAR 0 2
119442: NOT
119443: IFFALSE 119447
// exit ;
119445: GO 119590
// for i := 1 to 2 do
119447: LD_ADDR_VAR 0 1
119451: PUSH
119452: DOUBLE
119453: LD_INT 1
119455: DEC
119456: ST_TO_ADDR
119457: LD_INT 2
119459: PUSH
119460: FOR_TO
119461: IFFALSE 119588
// begin uc_side := your_side ;
119463: LD_ADDR_OWVAR 20
119467: PUSH
119468: LD_OWVAR 2
119472: ST_TO_ADDR
// uc_nation := nation_american ;
119473: LD_ADDR_OWVAR 21
119477: PUSH
119478: LD_INT 1
119480: ST_TO_ADDR
// vc_chassis := us_morphling ;
119481: LD_ADDR_OWVAR 37
119485: PUSH
119486: LD_INT 5
119488: ST_TO_ADDR
// vc_engine := engine_siberite ;
119489: LD_ADDR_OWVAR 39
119493: PUSH
119494: LD_INT 3
119496: ST_TO_ADDR
// vc_control := control_computer ;
119497: LD_ADDR_OWVAR 38
119501: PUSH
119502: LD_INT 3
119504: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119505: LD_ADDR_OWVAR 40
119509: PUSH
119510: LD_INT 10
119512: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119513: LD_VAR 0 2
119517: PUSH
119518: LD_INT 1
119520: ARRAY
119521: PPUSH
119522: CALL_OW 310
119526: NOT
119527: IFFALSE 119574
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119529: CALL_OW 45
119533: PPUSH
119534: LD_VAR 0 2
119538: PUSH
119539: LD_INT 1
119541: ARRAY
119542: PPUSH
119543: CALL_OW 250
119547: PPUSH
119548: LD_VAR 0 2
119552: PUSH
119553: LD_INT 1
119555: ARRAY
119556: PPUSH
119557: CALL_OW 251
119561: PPUSH
119562: LD_INT 12
119564: PPUSH
119565: LD_INT 1
119567: PPUSH
119568: CALL_OW 50
119572: GO 119586
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119574: CALL_OW 45
119578: PPUSH
119579: LD_INT 1
119581: PPUSH
119582: CALL_OW 51
// end ;
119586: GO 119460
119588: POP
119589: POP
// end ;
119590: PPOPN 2
119592: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119593: LD_EXP 144
119597: PUSH
119598: LD_EXP 190
119602: AND
119603: IFFALSE 119825
119605: GO 119607
119607: DISABLE
119608: LD_INT 0
119610: PPUSH
119611: PPUSH
119612: PPUSH
119613: PPUSH
119614: PPUSH
119615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119616: LD_ADDR_VAR 0 6
119620: PUSH
119621: LD_INT 22
119623: PUSH
119624: LD_OWVAR 2
119628: PUSH
119629: EMPTY
119630: LIST
119631: LIST
119632: PUSH
119633: LD_INT 21
119635: PUSH
119636: LD_INT 1
119638: PUSH
119639: EMPTY
119640: LIST
119641: LIST
119642: PUSH
119643: LD_INT 3
119645: PUSH
119646: LD_INT 23
119648: PUSH
119649: LD_INT 0
119651: PUSH
119652: EMPTY
119653: LIST
119654: LIST
119655: PUSH
119656: EMPTY
119657: LIST
119658: LIST
119659: PUSH
119660: EMPTY
119661: LIST
119662: LIST
119663: LIST
119664: PPUSH
119665: CALL_OW 69
119669: ST_TO_ADDR
// if not tmp then
119670: LD_VAR 0 6
119674: NOT
119675: IFFALSE 119679
// exit ;
119677: GO 119825
// s1 := rand ( 1 , 4 ) ;
119679: LD_ADDR_VAR 0 2
119683: PUSH
119684: LD_INT 1
119686: PPUSH
119687: LD_INT 4
119689: PPUSH
119690: CALL_OW 12
119694: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119695: LD_ADDR_VAR 0 4
119699: PUSH
119700: LD_VAR 0 6
119704: PUSH
119705: LD_INT 1
119707: ARRAY
119708: PPUSH
119709: LD_VAR 0 2
119713: PPUSH
119714: CALL_OW 259
119718: ST_TO_ADDR
// if s1 = 1 then
119719: LD_VAR 0 2
119723: PUSH
119724: LD_INT 1
119726: EQUAL
119727: IFFALSE 119747
// s2 := rand ( 2 , 4 ) else
119729: LD_ADDR_VAR 0 3
119733: PUSH
119734: LD_INT 2
119736: PPUSH
119737: LD_INT 4
119739: PPUSH
119740: CALL_OW 12
119744: ST_TO_ADDR
119745: GO 119755
// s2 := 1 ;
119747: LD_ADDR_VAR 0 3
119751: PUSH
119752: LD_INT 1
119754: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119755: LD_ADDR_VAR 0 5
119759: PUSH
119760: LD_VAR 0 6
119764: PUSH
119765: LD_INT 1
119767: ARRAY
119768: PPUSH
119769: LD_VAR 0 3
119773: PPUSH
119774: CALL_OW 259
119778: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119779: LD_VAR 0 6
119783: PUSH
119784: LD_INT 1
119786: ARRAY
119787: PPUSH
119788: LD_VAR 0 2
119792: PPUSH
119793: LD_VAR 0 5
119797: PPUSH
119798: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119802: LD_VAR 0 6
119806: PUSH
119807: LD_INT 1
119809: ARRAY
119810: PPUSH
119811: LD_VAR 0 3
119815: PPUSH
119816: LD_VAR 0 4
119820: PPUSH
119821: CALL_OW 237
// end ;
119825: PPOPN 6
119827: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119828: LD_EXP 144
119832: PUSH
119833: LD_EXP 191
119837: AND
119838: IFFALSE 119917
119840: GO 119842
119842: DISABLE
119843: LD_INT 0
119845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119846: LD_ADDR_VAR 0 1
119850: PUSH
119851: LD_INT 22
119853: PUSH
119854: LD_OWVAR 2
119858: PUSH
119859: EMPTY
119860: LIST
119861: LIST
119862: PUSH
119863: LD_INT 30
119865: PUSH
119866: LD_INT 3
119868: PUSH
119869: EMPTY
119870: LIST
119871: LIST
119872: PUSH
119873: EMPTY
119874: LIST
119875: LIST
119876: PPUSH
119877: CALL_OW 69
119881: ST_TO_ADDR
// if not tmp then
119882: LD_VAR 0 1
119886: NOT
119887: IFFALSE 119891
// exit ;
119889: GO 119917
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119891: LD_VAR 0 1
119895: PUSH
119896: LD_INT 1
119898: PPUSH
119899: LD_VAR 0 1
119903: PPUSH
119904: CALL_OW 12
119908: ARRAY
119909: PPUSH
119910: LD_INT 1
119912: PPUSH
119913: CALL_OW 234
// end ;
119917: PPOPN 1
119919: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119920: LD_EXP 144
119924: PUSH
119925: LD_EXP 192
119929: AND
119930: IFFALSE 120042
119932: GO 119934
119934: DISABLE
119935: LD_INT 0
119937: PPUSH
119938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119939: LD_ADDR_VAR 0 2
119943: PUSH
119944: LD_INT 22
119946: PUSH
119947: LD_OWVAR 2
119951: PUSH
119952: EMPTY
119953: LIST
119954: LIST
119955: PUSH
119956: LD_INT 2
119958: PUSH
119959: LD_INT 30
119961: PUSH
119962: LD_INT 27
119964: PUSH
119965: EMPTY
119966: LIST
119967: LIST
119968: PUSH
119969: LD_INT 30
119971: PUSH
119972: LD_INT 26
119974: PUSH
119975: EMPTY
119976: LIST
119977: LIST
119978: PUSH
119979: LD_INT 30
119981: PUSH
119982: LD_INT 28
119984: PUSH
119985: EMPTY
119986: LIST
119987: LIST
119988: PUSH
119989: EMPTY
119990: LIST
119991: LIST
119992: LIST
119993: LIST
119994: PUSH
119995: EMPTY
119996: LIST
119997: LIST
119998: PPUSH
119999: CALL_OW 69
120003: ST_TO_ADDR
// if not tmp then
120004: LD_VAR 0 2
120008: NOT
120009: IFFALSE 120013
// exit ;
120011: GO 120042
// for i in tmp do
120013: LD_ADDR_VAR 0 1
120017: PUSH
120018: LD_VAR 0 2
120022: PUSH
120023: FOR_IN
120024: IFFALSE 120040
// SetLives ( i , 1 ) ;
120026: LD_VAR 0 1
120030: PPUSH
120031: LD_INT 1
120033: PPUSH
120034: CALL_OW 234
120038: GO 120023
120040: POP
120041: POP
// end ;
120042: PPOPN 2
120044: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
120045: LD_EXP 144
120049: PUSH
120050: LD_EXP 193
120054: AND
120055: IFFALSE 120342
120057: GO 120059
120059: DISABLE
120060: LD_INT 0
120062: PPUSH
120063: PPUSH
120064: PPUSH
// begin i := rand ( 1 , 7 ) ;
120065: LD_ADDR_VAR 0 1
120069: PUSH
120070: LD_INT 1
120072: PPUSH
120073: LD_INT 7
120075: PPUSH
120076: CALL_OW 12
120080: ST_TO_ADDR
// case i of 1 :
120081: LD_VAR 0 1
120085: PUSH
120086: LD_INT 1
120088: DOUBLE
120089: EQUAL
120090: IFTRUE 120094
120092: GO 120104
120094: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
120095: LD_STRING earthquake(getX(game), 0, 32)
120097: PPUSH
120098: CALL_OW 559
120102: GO 120342
120104: LD_INT 2
120106: DOUBLE
120107: EQUAL
120108: IFTRUE 120112
120110: GO 120126
120112: POP
// begin ToLua ( displayStucuk(); ) ;
120113: LD_STRING displayStucuk();
120115: PPUSH
120116: CALL_OW 559
// ResetFog ;
120120: CALL_OW 335
// end ; 3 :
120124: GO 120342
120126: LD_INT 3
120128: DOUBLE
120129: EQUAL
120130: IFTRUE 120134
120132: GO 120238
120134: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120135: LD_ADDR_VAR 0 2
120139: PUSH
120140: LD_INT 22
120142: PUSH
120143: LD_OWVAR 2
120147: PUSH
120148: EMPTY
120149: LIST
120150: LIST
120151: PUSH
120152: LD_INT 25
120154: PUSH
120155: LD_INT 1
120157: PUSH
120158: EMPTY
120159: LIST
120160: LIST
120161: PUSH
120162: EMPTY
120163: LIST
120164: LIST
120165: PPUSH
120166: CALL_OW 69
120170: ST_TO_ADDR
// if not tmp then
120171: LD_VAR 0 2
120175: NOT
120176: IFFALSE 120180
// exit ;
120178: GO 120342
// un := tmp [ rand ( 1 , tmp ) ] ;
120180: LD_ADDR_VAR 0 3
120184: PUSH
120185: LD_VAR 0 2
120189: PUSH
120190: LD_INT 1
120192: PPUSH
120193: LD_VAR 0 2
120197: PPUSH
120198: CALL_OW 12
120202: ARRAY
120203: ST_TO_ADDR
// if Crawls ( un ) then
120204: LD_VAR 0 3
120208: PPUSH
120209: CALL_OW 318
120213: IFFALSE 120224
// ComWalk ( un ) ;
120215: LD_VAR 0 3
120219: PPUSH
120220: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120224: LD_VAR 0 3
120228: PPUSH
120229: LD_INT 8
120231: PPUSH
120232: CALL_OW 336
// end ; 4 :
120236: GO 120342
120238: LD_INT 4
120240: DOUBLE
120241: EQUAL
120242: IFTRUE 120246
120244: GO 120320
120246: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120247: LD_ADDR_VAR 0 2
120251: PUSH
120252: LD_INT 22
120254: PUSH
120255: LD_OWVAR 2
120259: PUSH
120260: EMPTY
120261: LIST
120262: LIST
120263: PUSH
120264: LD_INT 30
120266: PUSH
120267: LD_INT 29
120269: PUSH
120270: EMPTY
120271: LIST
120272: LIST
120273: PUSH
120274: EMPTY
120275: LIST
120276: LIST
120277: PPUSH
120278: CALL_OW 69
120282: ST_TO_ADDR
// if not tmp then
120283: LD_VAR 0 2
120287: NOT
120288: IFFALSE 120292
// exit ;
120290: GO 120342
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120292: LD_VAR 0 2
120296: PUSH
120297: LD_INT 1
120299: ARRAY
120300: PPUSH
120301: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120305: LD_VAR 0 2
120309: PUSH
120310: LD_INT 1
120312: ARRAY
120313: PPUSH
120314: CALL_OW 65
// end ; 5 .. 7 :
120318: GO 120342
120320: LD_INT 5
120322: DOUBLE
120323: GREATEREQUAL
120324: IFFALSE 120332
120326: LD_INT 7
120328: DOUBLE
120329: LESSEQUAL
120330: IFTRUE 120334
120332: GO 120341
120334: POP
// StreamSibBomb ; end ;
120335: CALL 116579 0 0
120339: GO 120342
120341: POP
// end ;
120342: PPOPN 3
120344: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120345: LD_EXP 144
120349: PUSH
120350: LD_EXP 194
120354: AND
120355: IFFALSE 120511
120357: GO 120359
120359: DISABLE
120360: LD_INT 0
120362: PPUSH
120363: PPUSH
120364: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120365: LD_ADDR_VAR 0 2
120369: PUSH
120370: LD_INT 81
120372: PUSH
120373: LD_OWVAR 2
120377: PUSH
120378: EMPTY
120379: LIST
120380: LIST
120381: PUSH
120382: LD_INT 2
120384: PUSH
120385: LD_INT 21
120387: PUSH
120388: LD_INT 1
120390: PUSH
120391: EMPTY
120392: LIST
120393: LIST
120394: PUSH
120395: LD_INT 21
120397: PUSH
120398: LD_INT 2
120400: PUSH
120401: EMPTY
120402: LIST
120403: LIST
120404: PUSH
120405: EMPTY
120406: LIST
120407: LIST
120408: LIST
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: PPUSH
120414: CALL_OW 69
120418: ST_TO_ADDR
// if not tmp then
120419: LD_VAR 0 2
120423: NOT
120424: IFFALSE 120428
// exit ;
120426: GO 120511
// p := 0 ;
120428: LD_ADDR_VAR 0 3
120432: PUSH
120433: LD_INT 0
120435: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120436: LD_INT 35
120438: PPUSH
120439: CALL_OW 67
// p := p + 1 ;
120443: LD_ADDR_VAR 0 3
120447: PUSH
120448: LD_VAR 0 3
120452: PUSH
120453: LD_INT 1
120455: PLUS
120456: ST_TO_ADDR
// for i in tmp do
120457: LD_ADDR_VAR 0 1
120461: PUSH
120462: LD_VAR 0 2
120466: PUSH
120467: FOR_IN
120468: IFFALSE 120499
// if GetLives ( i ) < 1000 then
120470: LD_VAR 0 1
120474: PPUSH
120475: CALL_OW 256
120479: PUSH
120480: LD_INT 1000
120482: LESS
120483: IFFALSE 120497
// SetLives ( i , 1000 ) ;
120485: LD_VAR 0 1
120489: PPUSH
120490: LD_INT 1000
120492: PPUSH
120493: CALL_OW 234
120497: GO 120467
120499: POP
120500: POP
// until p > 20 ;
120501: LD_VAR 0 3
120505: PUSH
120506: LD_INT 20
120508: GREATER
120509: IFFALSE 120436
// end ;
120511: PPOPN 3
120513: END
// every 0 0$1 trigger StreamModeActive and sTime do
120514: LD_EXP 144
120518: PUSH
120519: LD_EXP 195
120523: AND
120524: IFFALSE 120559
120526: GO 120528
120528: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120529: LD_INT 28
120531: PPUSH
120532: LD_OWVAR 2
120536: PPUSH
120537: LD_INT 2
120539: PPUSH
120540: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120544: LD_INT 30
120546: PPUSH
120547: LD_OWVAR 2
120551: PPUSH
120552: LD_INT 2
120554: PPUSH
120555: CALL_OW 322
// end ;
120559: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120560: LD_EXP 144
120564: PUSH
120565: LD_EXP 196
120569: AND
120570: IFFALSE 120691
120572: GO 120574
120574: DISABLE
120575: LD_INT 0
120577: PPUSH
120578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120579: LD_ADDR_VAR 0 2
120583: PUSH
120584: LD_INT 22
120586: PUSH
120587: LD_OWVAR 2
120591: PUSH
120592: EMPTY
120593: LIST
120594: LIST
120595: PUSH
120596: LD_INT 21
120598: PUSH
120599: LD_INT 1
120601: PUSH
120602: EMPTY
120603: LIST
120604: LIST
120605: PUSH
120606: LD_INT 3
120608: PUSH
120609: LD_INT 23
120611: PUSH
120612: LD_INT 0
120614: PUSH
120615: EMPTY
120616: LIST
120617: LIST
120618: PUSH
120619: EMPTY
120620: LIST
120621: LIST
120622: PUSH
120623: EMPTY
120624: LIST
120625: LIST
120626: LIST
120627: PPUSH
120628: CALL_OW 69
120632: ST_TO_ADDR
// if not tmp then
120633: LD_VAR 0 2
120637: NOT
120638: IFFALSE 120642
// exit ;
120640: GO 120691
// for i in tmp do
120642: LD_ADDR_VAR 0 1
120646: PUSH
120647: LD_VAR 0 2
120651: PUSH
120652: FOR_IN
120653: IFFALSE 120689
// begin if Crawls ( i ) then
120655: LD_VAR 0 1
120659: PPUSH
120660: CALL_OW 318
120664: IFFALSE 120675
// ComWalk ( i ) ;
120666: LD_VAR 0 1
120670: PPUSH
120671: CALL_OW 138
// SetClass ( i , 2 ) ;
120675: LD_VAR 0 1
120679: PPUSH
120680: LD_INT 2
120682: PPUSH
120683: CALL_OW 336
// end ;
120687: GO 120652
120689: POP
120690: POP
// end ;
120691: PPOPN 2
120693: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120694: LD_EXP 144
120698: PUSH
120699: LD_EXP 197
120703: AND
120704: IFFALSE 120992
120706: GO 120708
120708: DISABLE
120709: LD_INT 0
120711: PPUSH
120712: PPUSH
120713: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120714: LD_OWVAR 2
120718: PPUSH
120719: LD_INT 9
120721: PPUSH
120722: LD_INT 1
120724: PPUSH
120725: LD_INT 1
120727: PPUSH
120728: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120732: LD_INT 9
120734: PPUSH
120735: LD_OWVAR 2
120739: PPUSH
120740: CALL_OW 343
// uc_side := 9 ;
120744: LD_ADDR_OWVAR 20
120748: PUSH
120749: LD_INT 9
120751: ST_TO_ADDR
// uc_nation := 2 ;
120752: LD_ADDR_OWVAR 21
120756: PUSH
120757: LD_INT 2
120759: ST_TO_ADDR
// hc_name := Dark Warrior ;
120760: LD_ADDR_OWVAR 26
120764: PUSH
120765: LD_STRING Dark Warrior
120767: ST_TO_ADDR
// hc_gallery :=  ;
120768: LD_ADDR_OWVAR 33
120772: PUSH
120773: LD_STRING 
120775: ST_TO_ADDR
// hc_noskilllimit := true ;
120776: LD_ADDR_OWVAR 76
120780: PUSH
120781: LD_INT 1
120783: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120784: LD_ADDR_OWVAR 31
120788: PUSH
120789: LD_INT 30
120791: PUSH
120792: LD_INT 30
120794: PUSH
120795: LD_INT 30
120797: PUSH
120798: LD_INT 30
120800: PUSH
120801: EMPTY
120802: LIST
120803: LIST
120804: LIST
120805: LIST
120806: ST_TO_ADDR
// un := CreateHuman ;
120807: LD_ADDR_VAR 0 3
120811: PUSH
120812: CALL_OW 44
120816: ST_TO_ADDR
// hc_noskilllimit := false ;
120817: LD_ADDR_OWVAR 76
120821: PUSH
120822: LD_INT 0
120824: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120825: LD_VAR 0 3
120829: PPUSH
120830: LD_INT 1
120832: PPUSH
120833: CALL_OW 51
// ToLua ( playRanger() ) ;
120837: LD_STRING playRanger()
120839: PPUSH
120840: CALL_OW 559
// p := 0 ;
120844: LD_ADDR_VAR 0 2
120848: PUSH
120849: LD_INT 0
120851: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120852: LD_INT 35
120854: PPUSH
120855: CALL_OW 67
// p := p + 1 ;
120859: LD_ADDR_VAR 0 2
120863: PUSH
120864: LD_VAR 0 2
120868: PUSH
120869: LD_INT 1
120871: PLUS
120872: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120873: LD_VAR 0 3
120877: PPUSH
120878: CALL_OW 256
120882: PUSH
120883: LD_INT 1000
120885: LESS
120886: IFFALSE 120900
// SetLives ( un , 1000 ) ;
120888: LD_VAR 0 3
120892: PPUSH
120893: LD_INT 1000
120895: PPUSH
120896: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120900: LD_VAR 0 3
120904: PPUSH
120905: LD_INT 81
120907: PUSH
120908: LD_OWVAR 2
120912: PUSH
120913: EMPTY
120914: LIST
120915: LIST
120916: PUSH
120917: LD_INT 91
120919: PUSH
120920: LD_VAR 0 3
120924: PUSH
120925: LD_INT 30
120927: PUSH
120928: EMPTY
120929: LIST
120930: LIST
120931: LIST
120932: PUSH
120933: EMPTY
120934: LIST
120935: LIST
120936: PPUSH
120937: CALL_OW 69
120941: PPUSH
120942: LD_VAR 0 3
120946: PPUSH
120947: CALL_OW 74
120951: PPUSH
120952: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120956: LD_VAR 0 2
120960: PUSH
120961: LD_INT 80
120963: GREATER
120964: PUSH
120965: LD_VAR 0 3
120969: PPUSH
120970: CALL_OW 301
120974: OR
120975: IFFALSE 120852
// if un then
120977: LD_VAR 0 3
120981: IFFALSE 120992
// RemoveUnit ( un ) ;
120983: LD_VAR 0 3
120987: PPUSH
120988: CALL_OW 64
// end ;
120992: PPOPN 3
120994: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120995: LD_EXP 198
120999: IFFALSE 121115
121001: GO 121003
121003: DISABLE
121004: LD_INT 0
121006: PPUSH
121007: PPUSH
121008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
121009: LD_ADDR_VAR 0 2
121013: PUSH
121014: LD_INT 81
121016: PUSH
121017: LD_OWVAR 2
121021: PUSH
121022: EMPTY
121023: LIST
121024: LIST
121025: PUSH
121026: LD_INT 21
121028: PUSH
121029: LD_INT 1
121031: PUSH
121032: EMPTY
121033: LIST
121034: LIST
121035: PUSH
121036: EMPTY
121037: LIST
121038: LIST
121039: PPUSH
121040: CALL_OW 69
121044: ST_TO_ADDR
// ToLua ( playComputer() ) ;
121045: LD_STRING playComputer()
121047: PPUSH
121048: CALL_OW 559
// if not tmp then
121052: LD_VAR 0 2
121056: NOT
121057: IFFALSE 121061
// exit ;
121059: GO 121115
// for i in tmp do
121061: LD_ADDR_VAR 0 1
121065: PUSH
121066: LD_VAR 0 2
121070: PUSH
121071: FOR_IN
121072: IFFALSE 121113
// for j := 1 to 4 do
121074: LD_ADDR_VAR 0 3
121078: PUSH
121079: DOUBLE
121080: LD_INT 1
121082: DEC
121083: ST_TO_ADDR
121084: LD_INT 4
121086: PUSH
121087: FOR_TO
121088: IFFALSE 121109
// SetSkill ( i , j , 10 ) ;
121090: LD_VAR 0 1
121094: PPUSH
121095: LD_VAR 0 3
121099: PPUSH
121100: LD_INT 10
121102: PPUSH
121103: CALL_OW 237
121107: GO 121087
121109: POP
121110: POP
121111: GO 121071
121113: POP
121114: POP
// end ;
121115: PPOPN 3
121117: END
// every 0 0$1 trigger s30 do var i , tmp ;
121118: LD_EXP 199
121122: IFFALSE 121191
121124: GO 121126
121126: DISABLE
121127: LD_INT 0
121129: PPUSH
121130: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121131: LD_ADDR_VAR 0 2
121135: PUSH
121136: LD_INT 22
121138: PUSH
121139: LD_OWVAR 2
121143: PUSH
121144: EMPTY
121145: LIST
121146: LIST
121147: PPUSH
121148: CALL_OW 69
121152: ST_TO_ADDR
// if not tmp then
121153: LD_VAR 0 2
121157: NOT
121158: IFFALSE 121162
// exit ;
121160: GO 121191
// for i in tmp do
121162: LD_ADDR_VAR 0 1
121166: PUSH
121167: LD_VAR 0 2
121171: PUSH
121172: FOR_IN
121173: IFFALSE 121189
// SetLives ( i , 300 ) ;
121175: LD_VAR 0 1
121179: PPUSH
121180: LD_INT 300
121182: PPUSH
121183: CALL_OW 234
121187: GO 121172
121189: POP
121190: POP
// end ;
121191: PPOPN 2
121193: END
// every 0 0$1 trigger s60 do var i , tmp ;
121194: LD_EXP 200
121198: IFFALSE 121267
121200: GO 121202
121202: DISABLE
121203: LD_INT 0
121205: PPUSH
121206: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121207: LD_ADDR_VAR 0 2
121211: PUSH
121212: LD_INT 22
121214: PUSH
121215: LD_OWVAR 2
121219: PUSH
121220: EMPTY
121221: LIST
121222: LIST
121223: PPUSH
121224: CALL_OW 69
121228: ST_TO_ADDR
// if not tmp then
121229: LD_VAR 0 2
121233: NOT
121234: IFFALSE 121238
// exit ;
121236: GO 121267
// for i in tmp do
121238: LD_ADDR_VAR 0 1
121242: PUSH
121243: LD_VAR 0 2
121247: PUSH
121248: FOR_IN
121249: IFFALSE 121265
// SetLives ( i , 600 ) ;
121251: LD_VAR 0 1
121255: PPUSH
121256: LD_INT 600
121258: PPUSH
121259: CALL_OW 234
121263: GO 121248
121265: POP
121266: POP
// end ;
121267: PPOPN 2
121269: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121270: LD_INT 0
121272: PPUSH
// case cmd of 301 :
121273: LD_VAR 0 1
121277: PUSH
121278: LD_INT 301
121280: DOUBLE
121281: EQUAL
121282: IFTRUE 121286
121284: GO 121318
121286: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121287: LD_VAR 0 6
121291: PPUSH
121292: LD_VAR 0 7
121296: PPUSH
121297: LD_VAR 0 8
121301: PPUSH
121302: LD_VAR 0 4
121306: PPUSH
121307: LD_VAR 0 5
121311: PPUSH
121312: CALL 122519 0 5
121316: GO 121439
121318: LD_INT 302
121320: DOUBLE
121321: EQUAL
121322: IFTRUE 121326
121324: GO 121363
121326: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121327: LD_VAR 0 6
121331: PPUSH
121332: LD_VAR 0 7
121336: PPUSH
121337: LD_VAR 0 8
121341: PPUSH
121342: LD_VAR 0 9
121346: PPUSH
121347: LD_VAR 0 4
121351: PPUSH
121352: LD_VAR 0 5
121356: PPUSH
121357: CALL 122610 0 6
121361: GO 121439
121363: LD_INT 303
121365: DOUBLE
121366: EQUAL
121367: IFTRUE 121371
121369: GO 121408
121371: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121372: LD_VAR 0 6
121376: PPUSH
121377: LD_VAR 0 7
121381: PPUSH
121382: LD_VAR 0 8
121386: PPUSH
121387: LD_VAR 0 9
121391: PPUSH
121392: LD_VAR 0 4
121396: PPUSH
121397: LD_VAR 0 5
121401: PPUSH
121402: CALL 121444 0 6
121406: GO 121439
121408: LD_INT 304
121410: DOUBLE
121411: EQUAL
121412: IFTRUE 121416
121414: GO 121438
121416: POP
// hHackTeleport ( unit , x , y ) ; end ;
121417: LD_VAR 0 2
121421: PPUSH
121422: LD_VAR 0 4
121426: PPUSH
121427: LD_VAR 0 5
121431: PPUSH
121432: CALL 123203 0 3
121436: GO 121439
121438: POP
// end ;
121439: LD_VAR 0 12
121443: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121444: LD_INT 0
121446: PPUSH
121447: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121448: LD_VAR 0 1
121452: PUSH
121453: LD_INT 1
121455: LESS
121456: PUSH
121457: LD_VAR 0 1
121461: PUSH
121462: LD_INT 3
121464: GREATER
121465: OR
121466: PUSH
121467: LD_VAR 0 5
121471: PPUSH
121472: LD_VAR 0 6
121476: PPUSH
121477: CALL_OW 428
121481: OR
121482: IFFALSE 121486
// exit ;
121484: GO 122206
// uc_side := your_side ;
121486: LD_ADDR_OWVAR 20
121490: PUSH
121491: LD_OWVAR 2
121495: ST_TO_ADDR
// uc_nation := nation ;
121496: LD_ADDR_OWVAR 21
121500: PUSH
121501: LD_VAR 0 1
121505: ST_TO_ADDR
// bc_level = 1 ;
121506: LD_ADDR_OWVAR 43
121510: PUSH
121511: LD_INT 1
121513: ST_TO_ADDR
// case btype of 1 :
121514: LD_VAR 0 2
121518: PUSH
121519: LD_INT 1
121521: DOUBLE
121522: EQUAL
121523: IFTRUE 121527
121525: GO 121538
121527: POP
// bc_type := b_depot ; 2 :
121528: LD_ADDR_OWVAR 42
121532: PUSH
121533: LD_INT 0
121535: ST_TO_ADDR
121536: GO 122150
121538: LD_INT 2
121540: DOUBLE
121541: EQUAL
121542: IFTRUE 121546
121544: GO 121557
121546: POP
// bc_type := b_warehouse ; 3 :
121547: LD_ADDR_OWVAR 42
121551: PUSH
121552: LD_INT 1
121554: ST_TO_ADDR
121555: GO 122150
121557: LD_INT 3
121559: DOUBLE
121560: EQUAL
121561: IFTRUE 121565
121563: GO 121576
121565: POP
// bc_type := b_lab ; 4 .. 9 :
121566: LD_ADDR_OWVAR 42
121570: PUSH
121571: LD_INT 6
121573: ST_TO_ADDR
121574: GO 122150
121576: LD_INT 4
121578: DOUBLE
121579: GREATEREQUAL
121580: IFFALSE 121588
121582: LD_INT 9
121584: DOUBLE
121585: LESSEQUAL
121586: IFTRUE 121590
121588: GO 121642
121590: POP
// begin bc_type := b_lab_half ;
121591: LD_ADDR_OWVAR 42
121595: PUSH
121596: LD_INT 7
121598: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121599: LD_ADDR_OWVAR 44
121603: PUSH
121604: LD_INT 10
121606: PUSH
121607: LD_INT 11
121609: PUSH
121610: LD_INT 12
121612: PUSH
121613: LD_INT 15
121615: PUSH
121616: LD_INT 14
121618: PUSH
121619: LD_INT 13
121621: PUSH
121622: EMPTY
121623: LIST
121624: LIST
121625: LIST
121626: LIST
121627: LIST
121628: LIST
121629: PUSH
121630: LD_VAR 0 2
121634: PUSH
121635: LD_INT 3
121637: MINUS
121638: ARRAY
121639: ST_TO_ADDR
// end ; 10 .. 13 :
121640: GO 122150
121642: LD_INT 10
121644: DOUBLE
121645: GREATEREQUAL
121646: IFFALSE 121654
121648: LD_INT 13
121650: DOUBLE
121651: LESSEQUAL
121652: IFTRUE 121656
121654: GO 121733
121656: POP
// begin bc_type := b_lab_full ;
121657: LD_ADDR_OWVAR 42
121661: PUSH
121662: LD_INT 8
121664: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121665: LD_ADDR_OWVAR 44
121669: PUSH
121670: LD_INT 10
121672: PUSH
121673: LD_INT 12
121675: PUSH
121676: LD_INT 14
121678: PUSH
121679: LD_INT 13
121681: PUSH
121682: EMPTY
121683: LIST
121684: LIST
121685: LIST
121686: LIST
121687: PUSH
121688: LD_VAR 0 2
121692: PUSH
121693: LD_INT 9
121695: MINUS
121696: ARRAY
121697: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121698: LD_ADDR_OWVAR 45
121702: PUSH
121703: LD_INT 11
121705: PUSH
121706: LD_INT 15
121708: PUSH
121709: LD_INT 12
121711: PUSH
121712: LD_INT 15
121714: PUSH
121715: EMPTY
121716: LIST
121717: LIST
121718: LIST
121719: LIST
121720: PUSH
121721: LD_VAR 0 2
121725: PUSH
121726: LD_INT 9
121728: MINUS
121729: ARRAY
121730: ST_TO_ADDR
// end ; 14 :
121731: GO 122150
121733: LD_INT 14
121735: DOUBLE
121736: EQUAL
121737: IFTRUE 121741
121739: GO 121752
121741: POP
// bc_type := b_workshop ; 15 :
121742: LD_ADDR_OWVAR 42
121746: PUSH
121747: LD_INT 2
121749: ST_TO_ADDR
121750: GO 122150
121752: LD_INT 15
121754: DOUBLE
121755: EQUAL
121756: IFTRUE 121760
121758: GO 121771
121760: POP
// bc_type := b_factory ; 16 :
121761: LD_ADDR_OWVAR 42
121765: PUSH
121766: LD_INT 3
121768: ST_TO_ADDR
121769: GO 122150
121771: LD_INT 16
121773: DOUBLE
121774: EQUAL
121775: IFTRUE 121779
121777: GO 121790
121779: POP
// bc_type := b_ext_gun ; 17 :
121780: LD_ADDR_OWVAR 42
121784: PUSH
121785: LD_INT 17
121787: ST_TO_ADDR
121788: GO 122150
121790: LD_INT 17
121792: DOUBLE
121793: EQUAL
121794: IFTRUE 121798
121796: GO 121826
121798: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121799: LD_ADDR_OWVAR 42
121803: PUSH
121804: LD_INT 19
121806: PUSH
121807: LD_INT 23
121809: PUSH
121810: LD_INT 19
121812: PUSH
121813: EMPTY
121814: LIST
121815: LIST
121816: LIST
121817: PUSH
121818: LD_VAR 0 1
121822: ARRAY
121823: ST_TO_ADDR
121824: GO 122150
121826: LD_INT 18
121828: DOUBLE
121829: EQUAL
121830: IFTRUE 121834
121832: GO 121845
121834: POP
// bc_type := b_ext_radar ; 19 :
121835: LD_ADDR_OWVAR 42
121839: PUSH
121840: LD_INT 20
121842: ST_TO_ADDR
121843: GO 122150
121845: LD_INT 19
121847: DOUBLE
121848: EQUAL
121849: IFTRUE 121853
121851: GO 121864
121853: POP
// bc_type := b_ext_radio ; 20 :
121854: LD_ADDR_OWVAR 42
121858: PUSH
121859: LD_INT 22
121861: ST_TO_ADDR
121862: GO 122150
121864: LD_INT 20
121866: DOUBLE
121867: EQUAL
121868: IFTRUE 121872
121870: GO 121883
121872: POP
// bc_type := b_ext_siberium ; 21 :
121873: LD_ADDR_OWVAR 42
121877: PUSH
121878: LD_INT 21
121880: ST_TO_ADDR
121881: GO 122150
121883: LD_INT 21
121885: DOUBLE
121886: EQUAL
121887: IFTRUE 121891
121889: GO 121902
121891: POP
// bc_type := b_ext_computer ; 22 :
121892: LD_ADDR_OWVAR 42
121896: PUSH
121897: LD_INT 24
121899: ST_TO_ADDR
121900: GO 122150
121902: LD_INT 22
121904: DOUBLE
121905: EQUAL
121906: IFTRUE 121910
121908: GO 121921
121910: POP
// bc_type := b_ext_track ; 23 :
121911: LD_ADDR_OWVAR 42
121915: PUSH
121916: LD_INT 16
121918: ST_TO_ADDR
121919: GO 122150
121921: LD_INT 23
121923: DOUBLE
121924: EQUAL
121925: IFTRUE 121929
121927: GO 121940
121929: POP
// bc_type := b_ext_laser ; 24 :
121930: LD_ADDR_OWVAR 42
121934: PUSH
121935: LD_INT 25
121937: ST_TO_ADDR
121938: GO 122150
121940: LD_INT 24
121942: DOUBLE
121943: EQUAL
121944: IFTRUE 121948
121946: GO 121959
121948: POP
// bc_type := b_control_tower ; 25 :
121949: LD_ADDR_OWVAR 42
121953: PUSH
121954: LD_INT 36
121956: ST_TO_ADDR
121957: GO 122150
121959: LD_INT 25
121961: DOUBLE
121962: EQUAL
121963: IFTRUE 121967
121965: GO 121978
121967: POP
// bc_type := b_breastwork ; 26 :
121968: LD_ADDR_OWVAR 42
121972: PUSH
121973: LD_INT 31
121975: ST_TO_ADDR
121976: GO 122150
121978: LD_INT 26
121980: DOUBLE
121981: EQUAL
121982: IFTRUE 121986
121984: GO 121997
121986: POP
// bc_type := b_bunker ; 27 :
121987: LD_ADDR_OWVAR 42
121991: PUSH
121992: LD_INT 32
121994: ST_TO_ADDR
121995: GO 122150
121997: LD_INT 27
121999: DOUBLE
122000: EQUAL
122001: IFTRUE 122005
122003: GO 122016
122005: POP
// bc_type := b_turret ; 28 :
122006: LD_ADDR_OWVAR 42
122010: PUSH
122011: LD_INT 33
122013: ST_TO_ADDR
122014: GO 122150
122016: LD_INT 28
122018: DOUBLE
122019: EQUAL
122020: IFTRUE 122024
122022: GO 122035
122024: POP
// bc_type := b_armoury ; 29 :
122025: LD_ADDR_OWVAR 42
122029: PUSH
122030: LD_INT 4
122032: ST_TO_ADDR
122033: GO 122150
122035: LD_INT 29
122037: DOUBLE
122038: EQUAL
122039: IFTRUE 122043
122041: GO 122054
122043: POP
// bc_type := b_barracks ; 30 :
122044: LD_ADDR_OWVAR 42
122048: PUSH
122049: LD_INT 5
122051: ST_TO_ADDR
122052: GO 122150
122054: LD_INT 30
122056: DOUBLE
122057: EQUAL
122058: IFTRUE 122062
122060: GO 122073
122062: POP
// bc_type := b_solar_power ; 31 :
122063: LD_ADDR_OWVAR 42
122067: PUSH
122068: LD_INT 27
122070: ST_TO_ADDR
122071: GO 122150
122073: LD_INT 31
122075: DOUBLE
122076: EQUAL
122077: IFTRUE 122081
122079: GO 122092
122081: POP
// bc_type := b_oil_power ; 32 :
122082: LD_ADDR_OWVAR 42
122086: PUSH
122087: LD_INT 26
122089: ST_TO_ADDR
122090: GO 122150
122092: LD_INT 32
122094: DOUBLE
122095: EQUAL
122096: IFTRUE 122100
122098: GO 122111
122100: POP
// bc_type := b_siberite_power ; 33 :
122101: LD_ADDR_OWVAR 42
122105: PUSH
122106: LD_INT 28
122108: ST_TO_ADDR
122109: GO 122150
122111: LD_INT 33
122113: DOUBLE
122114: EQUAL
122115: IFTRUE 122119
122117: GO 122130
122119: POP
// bc_type := b_oil_mine ; 34 :
122120: LD_ADDR_OWVAR 42
122124: PUSH
122125: LD_INT 29
122127: ST_TO_ADDR
122128: GO 122150
122130: LD_INT 34
122132: DOUBLE
122133: EQUAL
122134: IFTRUE 122138
122136: GO 122149
122138: POP
// bc_type := b_siberite_mine ; end ;
122139: LD_ADDR_OWVAR 42
122143: PUSH
122144: LD_INT 30
122146: ST_TO_ADDR
122147: GO 122150
122149: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
122150: LD_ADDR_VAR 0 8
122154: PUSH
122155: LD_VAR 0 5
122159: PPUSH
122160: LD_VAR 0 6
122164: PPUSH
122165: LD_VAR 0 3
122169: PPUSH
122170: CALL_OW 47
122174: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
122175: LD_OWVAR 42
122179: PUSH
122180: LD_INT 32
122182: PUSH
122183: LD_INT 33
122185: PUSH
122186: EMPTY
122187: LIST
122188: LIST
122189: IN
122190: IFFALSE 122206
// PlaceWeaponTurret ( b , weapon ) ;
122192: LD_VAR 0 8
122196: PPUSH
122197: LD_VAR 0 4
122201: PPUSH
122202: CALL_OW 431
// end ;
122206: LD_VAR 0 7
122210: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122211: LD_INT 0
122213: PPUSH
122214: PPUSH
122215: PPUSH
122216: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122217: LD_ADDR_VAR 0 4
122221: PUSH
122222: LD_INT 22
122224: PUSH
122225: LD_OWVAR 2
122229: PUSH
122230: EMPTY
122231: LIST
122232: LIST
122233: PUSH
122234: LD_INT 2
122236: PUSH
122237: LD_INT 30
122239: PUSH
122240: LD_INT 0
122242: PUSH
122243: EMPTY
122244: LIST
122245: LIST
122246: PUSH
122247: LD_INT 30
122249: PUSH
122250: LD_INT 1
122252: PUSH
122253: EMPTY
122254: LIST
122255: LIST
122256: PUSH
122257: EMPTY
122258: LIST
122259: LIST
122260: LIST
122261: PUSH
122262: EMPTY
122263: LIST
122264: LIST
122265: PPUSH
122266: CALL_OW 69
122270: ST_TO_ADDR
// if not tmp then
122271: LD_VAR 0 4
122275: NOT
122276: IFFALSE 122280
// exit ;
122278: GO 122339
// for i in tmp do
122280: LD_ADDR_VAR 0 2
122284: PUSH
122285: LD_VAR 0 4
122289: PUSH
122290: FOR_IN
122291: IFFALSE 122337
// for j = 1 to 3 do
122293: LD_ADDR_VAR 0 3
122297: PUSH
122298: DOUBLE
122299: LD_INT 1
122301: DEC
122302: ST_TO_ADDR
122303: LD_INT 3
122305: PUSH
122306: FOR_TO
122307: IFFALSE 122333
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122309: LD_VAR 0 2
122313: PPUSH
122314: CALL_OW 274
122318: PPUSH
122319: LD_VAR 0 3
122323: PPUSH
122324: LD_INT 99999
122326: PPUSH
122327: CALL_OW 277
122331: GO 122306
122333: POP
122334: POP
122335: GO 122290
122337: POP
122338: POP
// end ;
122339: LD_VAR 0 1
122343: RET
// export function hHackSetLevel10 ; var i , j ; begin
122344: LD_INT 0
122346: PPUSH
122347: PPUSH
122348: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122349: LD_ADDR_VAR 0 2
122353: PUSH
122354: LD_INT 21
122356: PUSH
122357: LD_INT 1
122359: PUSH
122360: EMPTY
122361: LIST
122362: LIST
122363: PPUSH
122364: CALL_OW 69
122368: PUSH
122369: FOR_IN
122370: IFFALSE 122422
// if IsSelected ( i ) then
122372: LD_VAR 0 2
122376: PPUSH
122377: CALL_OW 306
122381: IFFALSE 122420
// begin for j := 1 to 4 do
122383: LD_ADDR_VAR 0 3
122387: PUSH
122388: DOUBLE
122389: LD_INT 1
122391: DEC
122392: ST_TO_ADDR
122393: LD_INT 4
122395: PUSH
122396: FOR_TO
122397: IFFALSE 122418
// SetSkill ( i , j , 10 ) ;
122399: LD_VAR 0 2
122403: PPUSH
122404: LD_VAR 0 3
122408: PPUSH
122409: LD_INT 10
122411: PPUSH
122412: CALL_OW 237
122416: GO 122396
122418: POP
122419: POP
// end ;
122420: GO 122369
122422: POP
122423: POP
// end ;
122424: LD_VAR 0 1
122428: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122429: LD_INT 0
122431: PPUSH
122432: PPUSH
122433: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122434: LD_ADDR_VAR 0 2
122438: PUSH
122439: LD_INT 22
122441: PUSH
122442: LD_OWVAR 2
122446: PUSH
122447: EMPTY
122448: LIST
122449: LIST
122450: PUSH
122451: LD_INT 21
122453: PUSH
122454: LD_INT 1
122456: PUSH
122457: EMPTY
122458: LIST
122459: LIST
122460: PUSH
122461: EMPTY
122462: LIST
122463: LIST
122464: PPUSH
122465: CALL_OW 69
122469: PUSH
122470: FOR_IN
122471: IFFALSE 122512
// begin for j := 1 to 4 do
122473: LD_ADDR_VAR 0 3
122477: PUSH
122478: DOUBLE
122479: LD_INT 1
122481: DEC
122482: ST_TO_ADDR
122483: LD_INT 4
122485: PUSH
122486: FOR_TO
122487: IFFALSE 122508
// SetSkill ( i , j , 10 ) ;
122489: LD_VAR 0 2
122493: PPUSH
122494: LD_VAR 0 3
122498: PPUSH
122499: LD_INT 10
122501: PPUSH
122502: CALL_OW 237
122506: GO 122486
122508: POP
122509: POP
// end ;
122510: GO 122470
122512: POP
122513: POP
// end ;
122514: LD_VAR 0 1
122518: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122519: LD_INT 0
122521: PPUSH
// uc_side := your_side ;
122522: LD_ADDR_OWVAR 20
122526: PUSH
122527: LD_OWVAR 2
122531: ST_TO_ADDR
// uc_nation := nation ;
122532: LD_ADDR_OWVAR 21
122536: PUSH
122537: LD_VAR 0 1
122541: ST_TO_ADDR
// InitHc ;
122542: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122546: LD_INT 0
122548: PPUSH
122549: LD_VAR 0 2
122553: PPUSH
122554: LD_VAR 0 3
122558: PPUSH
122559: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122563: LD_VAR 0 4
122567: PPUSH
122568: LD_VAR 0 5
122572: PPUSH
122573: CALL_OW 428
122577: PUSH
122578: LD_INT 0
122580: EQUAL
122581: IFFALSE 122605
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122583: CALL_OW 44
122587: PPUSH
122588: LD_VAR 0 4
122592: PPUSH
122593: LD_VAR 0 5
122597: PPUSH
122598: LD_INT 1
122600: PPUSH
122601: CALL_OW 48
// end ;
122605: LD_VAR 0 6
122609: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122610: LD_INT 0
122612: PPUSH
122613: PPUSH
// uc_side := your_side ;
122614: LD_ADDR_OWVAR 20
122618: PUSH
122619: LD_OWVAR 2
122623: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122624: LD_VAR 0 1
122628: PUSH
122629: LD_INT 1
122631: PUSH
122632: LD_INT 2
122634: PUSH
122635: LD_INT 3
122637: PUSH
122638: LD_INT 4
122640: PUSH
122641: LD_INT 5
122643: PUSH
122644: EMPTY
122645: LIST
122646: LIST
122647: LIST
122648: LIST
122649: LIST
122650: IN
122651: IFFALSE 122663
// uc_nation := nation_american else
122653: LD_ADDR_OWVAR 21
122657: PUSH
122658: LD_INT 1
122660: ST_TO_ADDR
122661: GO 122706
// if chassis in [ 11 , 12 , 13 , 14 ] then
122663: LD_VAR 0 1
122667: PUSH
122668: LD_INT 11
122670: PUSH
122671: LD_INT 12
122673: PUSH
122674: LD_INT 13
122676: PUSH
122677: LD_INT 14
122679: PUSH
122680: EMPTY
122681: LIST
122682: LIST
122683: LIST
122684: LIST
122685: IN
122686: IFFALSE 122698
// uc_nation := nation_arabian else
122688: LD_ADDR_OWVAR 21
122692: PUSH
122693: LD_INT 2
122695: ST_TO_ADDR
122696: GO 122706
// uc_nation := nation_russian ;
122698: LD_ADDR_OWVAR 21
122702: PUSH
122703: LD_INT 3
122705: ST_TO_ADDR
// vc_chassis := chassis ;
122706: LD_ADDR_OWVAR 37
122710: PUSH
122711: LD_VAR 0 1
122715: ST_TO_ADDR
// vc_engine := engine ;
122716: LD_ADDR_OWVAR 39
122720: PUSH
122721: LD_VAR 0 2
122725: ST_TO_ADDR
// vc_control := control ;
122726: LD_ADDR_OWVAR 38
122730: PUSH
122731: LD_VAR 0 3
122735: ST_TO_ADDR
// vc_weapon := weapon ;
122736: LD_ADDR_OWVAR 40
122740: PUSH
122741: LD_VAR 0 4
122745: ST_TO_ADDR
// un := CreateVehicle ;
122746: LD_ADDR_VAR 0 8
122750: PUSH
122751: CALL_OW 45
122755: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122756: LD_VAR 0 8
122760: PPUSH
122761: LD_INT 0
122763: PPUSH
122764: LD_INT 5
122766: PPUSH
122767: CALL_OW 12
122771: PPUSH
122772: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122776: LD_VAR 0 8
122780: PPUSH
122781: LD_VAR 0 5
122785: PPUSH
122786: LD_VAR 0 6
122790: PPUSH
122791: LD_INT 1
122793: PPUSH
122794: CALL_OW 48
// end ;
122798: LD_VAR 0 7
122802: RET
// export hInvincible ; every 1 do
122803: GO 122805
122805: DISABLE
// hInvincible := [ ] ;
122806: LD_ADDR_EXP 201
122810: PUSH
122811: EMPTY
122812: ST_TO_ADDR
122813: END
// every 10 do var i ;
122814: GO 122816
122816: DISABLE
122817: LD_INT 0
122819: PPUSH
// begin enable ;
122820: ENABLE
// if not hInvincible then
122821: LD_EXP 201
122825: NOT
122826: IFFALSE 122830
// exit ;
122828: GO 122874
// for i in hInvincible do
122830: LD_ADDR_VAR 0 1
122834: PUSH
122835: LD_EXP 201
122839: PUSH
122840: FOR_IN
122841: IFFALSE 122872
// if GetLives ( i ) < 1000 then
122843: LD_VAR 0 1
122847: PPUSH
122848: CALL_OW 256
122852: PUSH
122853: LD_INT 1000
122855: LESS
122856: IFFALSE 122870
// SetLives ( i , 1000 ) ;
122858: LD_VAR 0 1
122862: PPUSH
122863: LD_INT 1000
122865: PPUSH
122866: CALL_OW 234
122870: GO 122840
122872: POP
122873: POP
// end ;
122874: PPOPN 1
122876: END
// export function hHackInvincible ; var i ; begin
122877: LD_INT 0
122879: PPUSH
122880: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122881: LD_ADDR_VAR 0 2
122885: PUSH
122886: LD_INT 2
122888: PUSH
122889: LD_INT 21
122891: PUSH
122892: LD_INT 1
122894: PUSH
122895: EMPTY
122896: LIST
122897: LIST
122898: PUSH
122899: LD_INT 21
122901: PUSH
122902: LD_INT 2
122904: PUSH
122905: EMPTY
122906: LIST
122907: LIST
122908: PUSH
122909: EMPTY
122910: LIST
122911: LIST
122912: LIST
122913: PPUSH
122914: CALL_OW 69
122918: PUSH
122919: FOR_IN
122920: IFFALSE 122981
// if IsSelected ( i ) then
122922: LD_VAR 0 2
122926: PPUSH
122927: CALL_OW 306
122931: IFFALSE 122979
// begin if i in hInvincible then
122933: LD_VAR 0 2
122937: PUSH
122938: LD_EXP 201
122942: IN
122943: IFFALSE 122963
// hInvincible := hInvincible diff i else
122945: LD_ADDR_EXP 201
122949: PUSH
122950: LD_EXP 201
122954: PUSH
122955: LD_VAR 0 2
122959: DIFF
122960: ST_TO_ADDR
122961: GO 122979
// hInvincible := hInvincible union i ;
122963: LD_ADDR_EXP 201
122967: PUSH
122968: LD_EXP 201
122972: PUSH
122973: LD_VAR 0 2
122977: UNION
122978: ST_TO_ADDR
// end ;
122979: GO 122919
122981: POP
122982: POP
// end ;
122983: LD_VAR 0 1
122987: RET
// export function hHackInvisible ; var i , j ; begin
122988: LD_INT 0
122990: PPUSH
122991: PPUSH
122992: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122993: LD_ADDR_VAR 0 2
122997: PUSH
122998: LD_INT 21
123000: PUSH
123001: LD_INT 1
123003: PUSH
123004: EMPTY
123005: LIST
123006: LIST
123007: PPUSH
123008: CALL_OW 69
123012: PUSH
123013: FOR_IN
123014: IFFALSE 123038
// if IsSelected ( i ) then
123016: LD_VAR 0 2
123020: PPUSH
123021: CALL_OW 306
123025: IFFALSE 123036
// ComForceInvisible ( i ) ;
123027: LD_VAR 0 2
123031: PPUSH
123032: CALL_OW 496
123036: GO 123013
123038: POP
123039: POP
// end ;
123040: LD_VAR 0 1
123044: RET
// export function hHackChangeYourSide ; begin
123045: LD_INT 0
123047: PPUSH
// if your_side = 8 then
123048: LD_OWVAR 2
123052: PUSH
123053: LD_INT 8
123055: EQUAL
123056: IFFALSE 123068
// your_side := 0 else
123058: LD_ADDR_OWVAR 2
123062: PUSH
123063: LD_INT 0
123065: ST_TO_ADDR
123066: GO 123082
// your_side := your_side + 1 ;
123068: LD_ADDR_OWVAR 2
123072: PUSH
123073: LD_OWVAR 2
123077: PUSH
123078: LD_INT 1
123080: PLUS
123081: ST_TO_ADDR
// end ;
123082: LD_VAR 0 1
123086: RET
// export function hHackChangeUnitSide ; var i , j ; begin
123087: LD_INT 0
123089: PPUSH
123090: PPUSH
123091: PPUSH
// for i in all_units do
123092: LD_ADDR_VAR 0 2
123096: PUSH
123097: LD_OWVAR 3
123101: PUSH
123102: FOR_IN
123103: IFFALSE 123181
// if IsSelected ( i ) then
123105: LD_VAR 0 2
123109: PPUSH
123110: CALL_OW 306
123114: IFFALSE 123179
// begin j := GetSide ( i ) ;
123116: LD_ADDR_VAR 0 3
123120: PUSH
123121: LD_VAR 0 2
123125: PPUSH
123126: CALL_OW 255
123130: ST_TO_ADDR
// if j = 8 then
123131: LD_VAR 0 3
123135: PUSH
123136: LD_INT 8
123138: EQUAL
123139: IFFALSE 123151
// j := 0 else
123141: LD_ADDR_VAR 0 3
123145: PUSH
123146: LD_INT 0
123148: ST_TO_ADDR
123149: GO 123165
// j := j + 1 ;
123151: LD_ADDR_VAR 0 3
123155: PUSH
123156: LD_VAR 0 3
123160: PUSH
123161: LD_INT 1
123163: PLUS
123164: ST_TO_ADDR
// SetSide ( i , j ) ;
123165: LD_VAR 0 2
123169: PPUSH
123170: LD_VAR 0 3
123174: PPUSH
123175: CALL_OW 235
// end ;
123179: GO 123102
123181: POP
123182: POP
// end ;
123183: LD_VAR 0 1
123187: RET
// export function hHackFog ; begin
123188: LD_INT 0
123190: PPUSH
// FogOff ( true ) ;
123191: LD_INT 1
123193: PPUSH
123194: CALL_OW 344
// end ;
123198: LD_VAR 0 1
123202: RET
// export function hHackTeleport ( unit , x , y ) ; begin
123203: LD_INT 0
123205: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
123206: LD_VAR 0 1
123210: PPUSH
123211: LD_VAR 0 2
123215: PPUSH
123216: LD_VAR 0 3
123220: PPUSH
123221: LD_INT 1
123223: PPUSH
123224: LD_INT 1
123226: PPUSH
123227: CALL_OW 483
// CenterOnXY ( x , y ) ;
123231: LD_VAR 0 2
123235: PPUSH
123236: LD_VAR 0 3
123240: PPUSH
123241: CALL_OW 84
// end ;
123245: LD_VAR 0 4
123249: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123250: LD_INT 0
123252: PPUSH
123253: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123254: LD_VAR 0 1
123258: NOT
123259: PUSH
123260: LD_VAR 0 2
123264: PPUSH
123265: LD_VAR 0 3
123269: PPUSH
123270: CALL_OW 488
123274: NOT
123275: OR
123276: PUSH
123277: LD_VAR 0 1
123281: PPUSH
123282: CALL_OW 266
123286: PUSH
123287: LD_INT 3
123289: NONEQUAL
123290: PUSH
123291: LD_VAR 0 1
123295: PPUSH
123296: CALL_OW 247
123300: PUSH
123301: LD_INT 1
123303: EQUAL
123304: NOT
123305: AND
123306: OR
123307: IFFALSE 123311
// exit ;
123309: GO 123460
// if GetType ( factory ) = unit_human then
123311: LD_VAR 0 1
123315: PPUSH
123316: CALL_OW 247
123320: PUSH
123321: LD_INT 1
123323: EQUAL
123324: IFFALSE 123341
// factory := IsInUnit ( factory ) ;
123326: LD_ADDR_VAR 0 1
123330: PUSH
123331: LD_VAR 0 1
123335: PPUSH
123336: CALL_OW 310
123340: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123341: LD_VAR 0 1
123345: PPUSH
123346: CALL_OW 266
123350: PUSH
123351: LD_INT 3
123353: NONEQUAL
123354: IFFALSE 123358
// exit ;
123356: GO 123460
// if HexInfo ( x , y ) = factory then
123358: LD_VAR 0 2
123362: PPUSH
123363: LD_VAR 0 3
123367: PPUSH
123368: CALL_OW 428
123372: PUSH
123373: LD_VAR 0 1
123377: EQUAL
123378: IFFALSE 123405
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123380: LD_ADDR_EXP 202
123384: PUSH
123385: LD_EXP 202
123389: PPUSH
123390: LD_VAR 0 1
123394: PPUSH
123395: LD_INT 0
123397: PPUSH
123398: CALL_OW 1
123402: ST_TO_ADDR
123403: GO 123456
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123405: LD_ADDR_EXP 202
123409: PUSH
123410: LD_EXP 202
123414: PPUSH
123415: LD_VAR 0 1
123419: PPUSH
123420: LD_VAR 0 1
123424: PPUSH
123425: CALL_OW 255
123429: PUSH
123430: LD_VAR 0 1
123434: PUSH
123435: LD_VAR 0 2
123439: PUSH
123440: LD_VAR 0 3
123444: PUSH
123445: EMPTY
123446: LIST
123447: LIST
123448: LIST
123449: LIST
123450: PPUSH
123451: CALL_OW 1
123455: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123456: CALL 123465 0 0
// end ;
123460: LD_VAR 0 4
123464: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123465: LD_INT 0
123467: PPUSH
123468: PPUSH
123469: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123470: LD_STRING resetFactoryWaypoint();
123472: PPUSH
123473: CALL_OW 559
// if factoryWaypoints then
123477: LD_EXP 202
123481: IFFALSE 123607
// begin list := PrepareArray ( factoryWaypoints ) ;
123483: LD_ADDR_VAR 0 3
123487: PUSH
123488: LD_EXP 202
123492: PPUSH
123493: CALL 108717 0 1
123497: ST_TO_ADDR
// for i := 1 to list do
123498: LD_ADDR_VAR 0 2
123502: PUSH
123503: DOUBLE
123504: LD_INT 1
123506: DEC
123507: ST_TO_ADDR
123508: LD_VAR 0 3
123512: PUSH
123513: FOR_TO
123514: IFFALSE 123605
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123516: LD_STRING setFactoryWaypointXY(
123518: PUSH
123519: LD_VAR 0 3
123523: PUSH
123524: LD_VAR 0 2
123528: ARRAY
123529: PUSH
123530: LD_INT 1
123532: ARRAY
123533: STR
123534: PUSH
123535: LD_STRING ,
123537: STR
123538: PUSH
123539: LD_VAR 0 3
123543: PUSH
123544: LD_VAR 0 2
123548: ARRAY
123549: PUSH
123550: LD_INT 2
123552: ARRAY
123553: STR
123554: PUSH
123555: LD_STRING ,
123557: STR
123558: PUSH
123559: LD_VAR 0 3
123563: PUSH
123564: LD_VAR 0 2
123568: ARRAY
123569: PUSH
123570: LD_INT 3
123572: ARRAY
123573: STR
123574: PUSH
123575: LD_STRING ,
123577: STR
123578: PUSH
123579: LD_VAR 0 3
123583: PUSH
123584: LD_VAR 0 2
123588: ARRAY
123589: PUSH
123590: LD_INT 4
123592: ARRAY
123593: STR
123594: PUSH
123595: LD_STRING )
123597: STR
123598: PPUSH
123599: CALL_OW 559
123603: GO 123513
123605: POP
123606: POP
// end ; end ;
123607: LD_VAR 0 1
123611: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123612: LD_INT 0
123614: PPUSH
// if HexInfo ( x , y ) = warehouse then
123615: LD_VAR 0 2
123619: PPUSH
123620: LD_VAR 0 3
123624: PPUSH
123625: CALL_OW 428
123629: PUSH
123630: LD_VAR 0 1
123634: EQUAL
123635: IFFALSE 123662
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123637: LD_ADDR_EXP 203
123641: PUSH
123642: LD_EXP 203
123646: PPUSH
123647: LD_VAR 0 1
123651: PPUSH
123652: LD_INT 0
123654: PPUSH
123655: CALL_OW 1
123659: ST_TO_ADDR
123660: GO 123713
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123662: LD_ADDR_EXP 203
123666: PUSH
123667: LD_EXP 203
123671: PPUSH
123672: LD_VAR 0 1
123676: PPUSH
123677: LD_VAR 0 1
123681: PPUSH
123682: CALL_OW 255
123686: PUSH
123687: LD_VAR 0 1
123691: PUSH
123692: LD_VAR 0 2
123696: PUSH
123697: LD_VAR 0 3
123701: PUSH
123702: EMPTY
123703: LIST
123704: LIST
123705: LIST
123706: LIST
123707: PPUSH
123708: CALL_OW 1
123712: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123713: CALL 123722 0 0
// end ;
123717: LD_VAR 0 4
123721: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123722: LD_INT 0
123724: PPUSH
123725: PPUSH
123726: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123727: LD_STRING resetWarehouseGatheringPoints();
123729: PPUSH
123730: CALL_OW 559
// if warehouseGatheringPoints then
123734: LD_EXP 203
123738: IFFALSE 123864
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123740: LD_ADDR_VAR 0 3
123744: PUSH
123745: LD_EXP 203
123749: PPUSH
123750: CALL 108717 0 1
123754: ST_TO_ADDR
// for i := 1 to list do
123755: LD_ADDR_VAR 0 2
123759: PUSH
123760: DOUBLE
123761: LD_INT 1
123763: DEC
123764: ST_TO_ADDR
123765: LD_VAR 0 3
123769: PUSH
123770: FOR_TO
123771: IFFALSE 123862
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123773: LD_STRING setWarehouseGatheringPointXY(
123775: PUSH
123776: LD_VAR 0 3
123780: PUSH
123781: LD_VAR 0 2
123785: ARRAY
123786: PUSH
123787: LD_INT 1
123789: ARRAY
123790: STR
123791: PUSH
123792: LD_STRING ,
123794: STR
123795: PUSH
123796: LD_VAR 0 3
123800: PUSH
123801: LD_VAR 0 2
123805: ARRAY
123806: PUSH
123807: LD_INT 2
123809: ARRAY
123810: STR
123811: PUSH
123812: LD_STRING ,
123814: STR
123815: PUSH
123816: LD_VAR 0 3
123820: PUSH
123821: LD_VAR 0 2
123825: ARRAY
123826: PUSH
123827: LD_INT 3
123829: ARRAY
123830: STR
123831: PUSH
123832: LD_STRING ,
123834: STR
123835: PUSH
123836: LD_VAR 0 3
123840: PUSH
123841: LD_VAR 0 2
123845: ARRAY
123846: PUSH
123847: LD_INT 4
123849: ARRAY
123850: STR
123851: PUSH
123852: LD_STRING )
123854: STR
123855: PPUSH
123856: CALL_OW 559
123860: GO 123770
123862: POP
123863: POP
// end ; end ;
123864: LD_VAR 0 1
123868: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123869: LD_EXP 203
123873: IFFALSE 124558
123875: GO 123877
123877: DISABLE
123878: LD_INT 0
123880: PPUSH
123881: PPUSH
123882: PPUSH
123883: PPUSH
123884: PPUSH
123885: PPUSH
123886: PPUSH
123887: PPUSH
123888: PPUSH
// begin enable ;
123889: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123890: LD_ADDR_VAR 0 3
123894: PUSH
123895: LD_EXP 203
123899: PPUSH
123900: CALL 108717 0 1
123904: ST_TO_ADDR
// if not list then
123905: LD_VAR 0 3
123909: NOT
123910: IFFALSE 123914
// exit ;
123912: GO 124558
// for i := 1 to list do
123914: LD_ADDR_VAR 0 1
123918: PUSH
123919: DOUBLE
123920: LD_INT 1
123922: DEC
123923: ST_TO_ADDR
123924: LD_VAR 0 3
123928: PUSH
123929: FOR_TO
123930: IFFALSE 124556
// begin depot := list [ i ] [ 2 ] ;
123932: LD_ADDR_VAR 0 8
123936: PUSH
123937: LD_VAR 0 3
123941: PUSH
123942: LD_VAR 0 1
123946: ARRAY
123947: PUSH
123948: LD_INT 2
123950: ARRAY
123951: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123952: LD_ADDR_VAR 0 5
123956: PUSH
123957: LD_VAR 0 3
123961: PUSH
123962: LD_VAR 0 1
123966: ARRAY
123967: PUSH
123968: LD_INT 1
123970: ARRAY
123971: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123972: LD_VAR 0 8
123976: PPUSH
123977: CALL_OW 301
123981: PUSH
123982: LD_VAR 0 5
123986: PUSH
123987: LD_VAR 0 8
123991: PPUSH
123992: CALL_OW 255
123996: NONEQUAL
123997: OR
123998: IFFALSE 124027
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
124000: LD_ADDR_EXP 203
124004: PUSH
124005: LD_EXP 203
124009: PPUSH
124010: LD_VAR 0 8
124014: PPUSH
124015: LD_INT 0
124017: PPUSH
124018: CALL_OW 1
124022: ST_TO_ADDR
// exit ;
124023: POP
124024: POP
124025: GO 124558
// end ; x := list [ i ] [ 3 ] ;
124027: LD_ADDR_VAR 0 6
124031: PUSH
124032: LD_VAR 0 3
124036: PUSH
124037: LD_VAR 0 1
124041: ARRAY
124042: PUSH
124043: LD_INT 3
124045: ARRAY
124046: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
124047: LD_ADDR_VAR 0 7
124051: PUSH
124052: LD_VAR 0 3
124056: PUSH
124057: LD_VAR 0 1
124061: ARRAY
124062: PUSH
124063: LD_INT 4
124065: ARRAY
124066: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
124067: LD_ADDR_VAR 0 9
124071: PUSH
124072: LD_VAR 0 6
124076: PPUSH
124077: LD_VAR 0 7
124081: PPUSH
124082: LD_INT 16
124084: PPUSH
124085: CALL 107305 0 3
124089: ST_TO_ADDR
// if not cratesNearbyPoint then
124090: LD_VAR 0 9
124094: NOT
124095: IFFALSE 124101
// exit ;
124097: POP
124098: POP
124099: GO 124558
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
124101: LD_ADDR_VAR 0 4
124105: PUSH
124106: LD_INT 22
124108: PUSH
124109: LD_VAR 0 5
124113: PUSH
124114: EMPTY
124115: LIST
124116: LIST
124117: PUSH
124118: LD_INT 3
124120: PUSH
124121: LD_INT 60
124123: PUSH
124124: EMPTY
124125: LIST
124126: PUSH
124127: EMPTY
124128: LIST
124129: LIST
124130: PUSH
124131: LD_INT 91
124133: PUSH
124134: LD_VAR 0 8
124138: PUSH
124139: LD_INT 6
124141: PUSH
124142: EMPTY
124143: LIST
124144: LIST
124145: LIST
124146: PUSH
124147: LD_INT 2
124149: PUSH
124150: LD_INT 25
124152: PUSH
124153: LD_INT 2
124155: PUSH
124156: EMPTY
124157: LIST
124158: LIST
124159: PUSH
124160: LD_INT 25
124162: PUSH
124163: LD_INT 16
124165: PUSH
124166: EMPTY
124167: LIST
124168: LIST
124169: PUSH
124170: EMPTY
124171: LIST
124172: LIST
124173: LIST
124174: PUSH
124175: EMPTY
124176: LIST
124177: LIST
124178: LIST
124179: LIST
124180: PPUSH
124181: CALL_OW 69
124185: PUSH
124186: LD_VAR 0 8
124190: PPUSH
124191: CALL_OW 313
124195: PPUSH
124196: LD_INT 3
124198: PUSH
124199: LD_INT 60
124201: PUSH
124202: EMPTY
124203: LIST
124204: PUSH
124205: EMPTY
124206: LIST
124207: LIST
124208: PUSH
124209: LD_INT 2
124211: PUSH
124212: LD_INT 25
124214: PUSH
124215: LD_INT 2
124217: PUSH
124218: EMPTY
124219: LIST
124220: LIST
124221: PUSH
124222: LD_INT 25
124224: PUSH
124225: LD_INT 16
124227: PUSH
124228: EMPTY
124229: LIST
124230: LIST
124231: PUSH
124232: EMPTY
124233: LIST
124234: LIST
124235: LIST
124236: PUSH
124237: EMPTY
124238: LIST
124239: LIST
124240: PPUSH
124241: CALL_OW 72
124245: UNION
124246: ST_TO_ADDR
// if tmp then
124247: LD_VAR 0 4
124251: IFFALSE 124331
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124253: LD_ADDR_VAR 0 4
124257: PUSH
124258: LD_VAR 0 4
124262: PPUSH
124263: LD_INT 3
124265: PPUSH
124266: CALL 105274 0 2
124270: ST_TO_ADDR
// for j in tmp do
124271: LD_ADDR_VAR 0 2
124275: PUSH
124276: LD_VAR 0 4
124280: PUSH
124281: FOR_IN
124282: IFFALSE 124325
// begin if IsInUnit ( j ) then
124284: LD_VAR 0 2
124288: PPUSH
124289: CALL_OW 310
124293: IFFALSE 124304
// ComExit ( j ) ;
124295: LD_VAR 0 2
124299: PPUSH
124300: CALL 105357 0 1
// AddComCollect ( j , x , y ) ;
124304: LD_VAR 0 2
124308: PPUSH
124309: LD_VAR 0 6
124313: PPUSH
124314: LD_VAR 0 7
124318: PPUSH
124319: CALL_OW 177
// end ;
124323: GO 124281
124325: POP
124326: POP
// exit ;
124327: POP
124328: POP
124329: GO 124558
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124331: LD_ADDR_VAR 0 4
124335: PUSH
124336: LD_INT 22
124338: PUSH
124339: LD_VAR 0 5
124343: PUSH
124344: EMPTY
124345: LIST
124346: LIST
124347: PUSH
124348: LD_INT 91
124350: PUSH
124351: LD_VAR 0 8
124355: PUSH
124356: LD_INT 8
124358: PUSH
124359: EMPTY
124360: LIST
124361: LIST
124362: LIST
124363: PUSH
124364: LD_INT 2
124366: PUSH
124367: LD_INT 34
124369: PUSH
124370: LD_INT 12
124372: PUSH
124373: EMPTY
124374: LIST
124375: LIST
124376: PUSH
124377: LD_INT 34
124379: PUSH
124380: LD_INT 51
124382: PUSH
124383: EMPTY
124384: LIST
124385: LIST
124386: PUSH
124387: LD_INT 34
124389: PUSH
124390: LD_INT 32
124392: PUSH
124393: EMPTY
124394: LIST
124395: LIST
124396: PUSH
124397: LD_INT 34
124399: PUSH
124400: LD_INT 89
124402: PUSH
124403: EMPTY
124404: LIST
124405: LIST
124406: PUSH
124407: EMPTY
124408: LIST
124409: LIST
124410: LIST
124411: LIST
124412: LIST
124413: PUSH
124414: EMPTY
124415: LIST
124416: LIST
124417: LIST
124418: PPUSH
124419: CALL_OW 69
124423: ST_TO_ADDR
// if tmp then
124424: LD_VAR 0 4
124428: IFFALSE 124554
// begin for j in tmp do
124430: LD_ADDR_VAR 0 2
124434: PUSH
124435: LD_VAR 0 4
124439: PUSH
124440: FOR_IN
124441: IFFALSE 124552
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124443: LD_VAR 0 2
124447: PPUSH
124448: CALL_OW 262
124452: PUSH
124453: LD_INT 3
124455: EQUAL
124456: PUSH
124457: LD_VAR 0 2
124461: PPUSH
124462: CALL_OW 261
124466: PUSH
124467: LD_INT 20
124469: GREATER
124470: OR
124471: PUSH
124472: LD_VAR 0 2
124476: PPUSH
124477: CALL_OW 314
124481: NOT
124482: AND
124483: PUSH
124484: LD_VAR 0 2
124488: PPUSH
124489: CALL_OW 263
124493: PUSH
124494: LD_INT 1
124496: NONEQUAL
124497: PUSH
124498: LD_VAR 0 2
124502: PPUSH
124503: CALL_OW 311
124507: OR
124508: AND
124509: IFFALSE 124550
// begin ComCollect ( j , x , y ) ;
124511: LD_VAR 0 2
124515: PPUSH
124516: LD_VAR 0 6
124520: PPUSH
124521: LD_VAR 0 7
124525: PPUSH
124526: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124530: LD_VAR 0 2
124534: PPUSH
124535: LD_VAR 0 8
124539: PPUSH
124540: CALL_OW 172
// exit ;
124544: POP
124545: POP
124546: POP
124547: POP
124548: GO 124558
// end ;
124550: GO 124440
124552: POP
124553: POP
// end ; end ;
124554: GO 123929
124556: POP
124557: POP
// end ; end_of_file
124558: PPOPN 9
124560: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124561: LD_INT 0
124563: PPUSH
124564: PPUSH
124565: PPUSH
124566: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124567: LD_VAR 0 1
124571: PPUSH
124572: CALL_OW 264
124576: PUSH
124577: LD_INT 91
124579: EQUAL
124580: IFFALSE 124652
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124582: LD_INT 68
124584: PPUSH
124585: LD_VAR 0 1
124589: PPUSH
124590: CALL_OW 255
124594: PPUSH
124595: CALL_OW 321
124599: PUSH
124600: LD_INT 2
124602: EQUAL
124603: IFFALSE 124615
// eff := 70 else
124605: LD_ADDR_VAR 0 4
124609: PUSH
124610: LD_INT 70
124612: ST_TO_ADDR
124613: GO 124623
// eff := 30 ;
124615: LD_ADDR_VAR 0 4
124619: PUSH
124620: LD_INT 30
124622: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124623: LD_VAR 0 1
124627: PPUSH
124628: CALL_OW 250
124632: PPUSH
124633: LD_VAR 0 1
124637: PPUSH
124638: CALL_OW 251
124642: PPUSH
124643: LD_VAR 0 4
124647: PPUSH
124648: CALL_OW 495
// end ; end ;
124652: LD_VAR 0 2
124656: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124657: LD_INT 0
124659: PPUSH
// end ;
124660: LD_VAR 0 4
124664: RET
// export function SOS_Command ( cmd ) ; begin
124665: LD_INT 0
124667: PPUSH
// end ;
124668: LD_VAR 0 2
124672: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124673: LD_INT 0
124675: PPUSH
// end ;
124676: LD_VAR 0 6
124680: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124681: LD_INT 0
124683: PPUSH
124684: PPUSH
// if not vehicle or not factory then
124685: LD_VAR 0 1
124689: NOT
124690: PUSH
124691: LD_VAR 0 2
124695: NOT
124696: OR
124697: IFFALSE 124701
// exit ;
124699: GO 124932
// if factoryWaypoints >= factory then
124701: LD_EXP 202
124705: PUSH
124706: LD_VAR 0 2
124710: GREATEREQUAL
124711: IFFALSE 124932
// if factoryWaypoints [ factory ] then
124713: LD_EXP 202
124717: PUSH
124718: LD_VAR 0 2
124722: ARRAY
124723: IFFALSE 124932
// begin if GetControl ( vehicle ) = control_manual then
124725: LD_VAR 0 1
124729: PPUSH
124730: CALL_OW 263
124734: PUSH
124735: LD_INT 1
124737: EQUAL
124738: IFFALSE 124819
// begin driver := IsDrivenBy ( vehicle ) ;
124740: LD_ADDR_VAR 0 4
124744: PUSH
124745: LD_VAR 0 1
124749: PPUSH
124750: CALL_OW 311
124754: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124755: LD_VAR 0 4
124759: PPUSH
124760: LD_EXP 202
124764: PUSH
124765: LD_VAR 0 2
124769: ARRAY
124770: PUSH
124771: LD_INT 3
124773: ARRAY
124774: PPUSH
124775: LD_EXP 202
124779: PUSH
124780: LD_VAR 0 2
124784: ARRAY
124785: PUSH
124786: LD_INT 4
124788: ARRAY
124789: PPUSH
124790: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124794: LD_VAR 0 4
124798: PPUSH
124799: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124803: LD_VAR 0 4
124807: PPUSH
124808: LD_VAR 0 2
124812: PPUSH
124813: CALL_OW 180
// end else
124817: GO 124932
// if GetControl ( vehicle ) = control_remote then
124819: LD_VAR 0 1
124823: PPUSH
124824: CALL_OW 263
124828: PUSH
124829: LD_INT 2
124831: EQUAL
124832: IFFALSE 124893
// begin wait ( 0 0$2 ) ;
124834: LD_INT 70
124836: PPUSH
124837: CALL_OW 67
// if Connect ( vehicle ) then
124841: LD_VAR 0 1
124845: PPUSH
124846: CALL 75616 0 1
124850: IFFALSE 124891
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124852: LD_VAR 0 1
124856: PPUSH
124857: LD_EXP 202
124861: PUSH
124862: LD_VAR 0 2
124866: ARRAY
124867: PUSH
124868: LD_INT 3
124870: ARRAY
124871: PPUSH
124872: LD_EXP 202
124876: PUSH
124877: LD_VAR 0 2
124881: ARRAY
124882: PUSH
124883: LD_INT 4
124885: ARRAY
124886: PPUSH
124887: CALL_OW 171
// end else
124891: GO 124932
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124893: LD_VAR 0 1
124897: PPUSH
124898: LD_EXP 202
124902: PUSH
124903: LD_VAR 0 2
124907: ARRAY
124908: PUSH
124909: LD_INT 3
124911: ARRAY
124912: PPUSH
124913: LD_EXP 202
124917: PUSH
124918: LD_VAR 0 2
124922: ARRAY
124923: PUSH
124924: LD_INT 4
124926: ARRAY
124927: PPUSH
124928: CALL_OW 171
// end ; end ;
124932: LD_VAR 0 3
124936: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124937: LD_INT 0
124939: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124940: LD_VAR 0 1
124944: PUSH
124945: LD_INT 250
124947: EQUAL
124948: PUSH
124949: LD_VAR 0 2
124953: PPUSH
124954: CALL_OW 264
124958: PUSH
124959: LD_INT 81
124961: EQUAL
124962: AND
124963: IFFALSE 124984
// MinerPlaceMine ( unit , x , y ) ;
124965: LD_VAR 0 2
124969: PPUSH
124970: LD_VAR 0 4
124974: PPUSH
124975: LD_VAR 0 5
124979: PPUSH
124980: CALL 127369 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124984: LD_VAR 0 1
124988: PUSH
124989: LD_INT 251
124991: EQUAL
124992: PUSH
124993: LD_VAR 0 2
124997: PPUSH
124998: CALL_OW 264
125002: PUSH
125003: LD_INT 81
125005: EQUAL
125006: AND
125007: IFFALSE 125028
// MinerDetonateMine ( unit , x , y ) ;
125009: LD_VAR 0 2
125013: PPUSH
125014: LD_VAR 0 4
125018: PPUSH
125019: LD_VAR 0 5
125023: PPUSH
125024: CALL 127644 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
125028: LD_VAR 0 1
125032: PUSH
125033: LD_INT 252
125035: EQUAL
125036: PUSH
125037: LD_VAR 0 2
125041: PPUSH
125042: CALL_OW 264
125046: PUSH
125047: LD_INT 81
125049: EQUAL
125050: AND
125051: IFFALSE 125072
// MinerCreateMinefield ( unit , x , y ) ;
125053: LD_VAR 0 2
125057: PPUSH
125058: LD_VAR 0 4
125062: PPUSH
125063: LD_VAR 0 5
125067: PPUSH
125068: CALL 128061 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
125072: LD_VAR 0 1
125076: PUSH
125077: LD_INT 253
125079: EQUAL
125080: PUSH
125081: LD_VAR 0 2
125085: PPUSH
125086: CALL_OW 257
125090: PUSH
125091: LD_INT 5
125093: EQUAL
125094: AND
125095: IFFALSE 125116
// ComBinocular ( unit , x , y ) ;
125097: LD_VAR 0 2
125101: PPUSH
125102: LD_VAR 0 4
125106: PPUSH
125107: LD_VAR 0 5
125111: PPUSH
125112: CALL 128430 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
125116: LD_VAR 0 1
125120: PUSH
125121: LD_INT 254
125123: EQUAL
125124: PUSH
125125: LD_VAR 0 2
125129: PPUSH
125130: CALL_OW 264
125134: PUSH
125135: LD_INT 99
125137: EQUAL
125138: AND
125139: PUSH
125140: LD_VAR 0 3
125144: PPUSH
125145: CALL_OW 263
125149: PUSH
125150: LD_INT 3
125152: EQUAL
125153: AND
125154: IFFALSE 125170
// HackDestroyVehicle ( unit , selectedUnit ) ;
125156: LD_VAR 0 2
125160: PPUSH
125161: LD_VAR 0 3
125165: PPUSH
125166: CALL 126733 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
125170: LD_VAR 0 1
125174: PUSH
125175: LD_INT 255
125177: EQUAL
125178: PUSH
125179: LD_VAR 0 2
125183: PPUSH
125184: CALL_OW 264
125188: PUSH
125189: LD_INT 14
125191: PUSH
125192: LD_INT 53
125194: PUSH
125195: EMPTY
125196: LIST
125197: LIST
125198: IN
125199: AND
125200: PUSH
125201: LD_VAR 0 4
125205: PPUSH
125206: LD_VAR 0 5
125210: PPUSH
125211: CALL_OW 488
125215: AND
125216: IFFALSE 125240
// CutTreeXYR ( unit , x , y , 12 ) ;
125218: LD_VAR 0 2
125222: PPUSH
125223: LD_VAR 0 4
125227: PPUSH
125228: LD_VAR 0 5
125232: PPUSH
125233: LD_INT 12
125235: PPUSH
125236: CALL 125303 0 4
// if cmd = 256 then
125240: LD_VAR 0 1
125244: PUSH
125245: LD_INT 256
125247: EQUAL
125248: IFFALSE 125269
// SetFactoryWaypoint ( unit , x , y ) ;
125250: LD_VAR 0 2
125254: PPUSH
125255: LD_VAR 0 4
125259: PPUSH
125260: LD_VAR 0 5
125264: PPUSH
125265: CALL 123250 0 3
// if cmd = 257 then
125269: LD_VAR 0 1
125273: PUSH
125274: LD_INT 257
125276: EQUAL
125277: IFFALSE 125298
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125279: LD_VAR 0 2
125283: PPUSH
125284: LD_VAR 0 4
125288: PPUSH
125289: LD_VAR 0 5
125293: PPUSH
125294: CALL 123612 0 3
// end ;
125298: LD_VAR 0 6
125302: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125303: LD_INT 0
125305: PPUSH
125306: PPUSH
125307: PPUSH
125308: PPUSH
125309: PPUSH
125310: PPUSH
125311: PPUSH
125312: PPUSH
125313: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125314: LD_VAR 0 1
125318: NOT
125319: PUSH
125320: LD_VAR 0 2
125324: PPUSH
125325: LD_VAR 0 3
125329: PPUSH
125330: CALL_OW 488
125334: NOT
125335: OR
125336: PUSH
125337: LD_VAR 0 4
125341: NOT
125342: OR
125343: IFFALSE 125347
// exit ;
125345: GO 125687
// list := [ ] ;
125347: LD_ADDR_VAR 0 13
125351: PUSH
125352: EMPTY
125353: ST_TO_ADDR
// if x - r < 0 then
125354: LD_VAR 0 2
125358: PUSH
125359: LD_VAR 0 4
125363: MINUS
125364: PUSH
125365: LD_INT 0
125367: LESS
125368: IFFALSE 125380
// min_x := 0 else
125370: LD_ADDR_VAR 0 7
125374: PUSH
125375: LD_INT 0
125377: ST_TO_ADDR
125378: GO 125396
// min_x := x - r ;
125380: LD_ADDR_VAR 0 7
125384: PUSH
125385: LD_VAR 0 2
125389: PUSH
125390: LD_VAR 0 4
125394: MINUS
125395: ST_TO_ADDR
// if y - r < 0 then
125396: LD_VAR 0 3
125400: PUSH
125401: LD_VAR 0 4
125405: MINUS
125406: PUSH
125407: LD_INT 0
125409: LESS
125410: IFFALSE 125422
// min_y := 0 else
125412: LD_ADDR_VAR 0 8
125416: PUSH
125417: LD_INT 0
125419: ST_TO_ADDR
125420: GO 125438
// min_y := y - r ;
125422: LD_ADDR_VAR 0 8
125426: PUSH
125427: LD_VAR 0 3
125431: PUSH
125432: LD_VAR 0 4
125436: MINUS
125437: ST_TO_ADDR
// max_x := x + r ;
125438: LD_ADDR_VAR 0 9
125442: PUSH
125443: LD_VAR 0 2
125447: PUSH
125448: LD_VAR 0 4
125452: PLUS
125453: ST_TO_ADDR
// max_y := y + r ;
125454: LD_ADDR_VAR 0 10
125458: PUSH
125459: LD_VAR 0 3
125463: PUSH
125464: LD_VAR 0 4
125468: PLUS
125469: ST_TO_ADDR
// for _x = min_x to max_x do
125470: LD_ADDR_VAR 0 11
125474: PUSH
125475: DOUBLE
125476: LD_VAR 0 7
125480: DEC
125481: ST_TO_ADDR
125482: LD_VAR 0 9
125486: PUSH
125487: FOR_TO
125488: IFFALSE 125605
// for _y = min_y to max_y do
125490: LD_ADDR_VAR 0 12
125494: PUSH
125495: DOUBLE
125496: LD_VAR 0 8
125500: DEC
125501: ST_TO_ADDR
125502: LD_VAR 0 10
125506: PUSH
125507: FOR_TO
125508: IFFALSE 125601
// begin if not ValidHex ( _x , _y ) then
125510: LD_VAR 0 11
125514: PPUSH
125515: LD_VAR 0 12
125519: PPUSH
125520: CALL_OW 488
125524: NOT
125525: IFFALSE 125529
// continue ;
125527: GO 125507
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125529: LD_VAR 0 11
125533: PPUSH
125534: LD_VAR 0 12
125538: PPUSH
125539: CALL_OW 351
125543: PUSH
125544: LD_VAR 0 11
125548: PPUSH
125549: LD_VAR 0 12
125553: PPUSH
125554: CALL_OW 554
125558: AND
125559: IFFALSE 125599
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125561: LD_ADDR_VAR 0 13
125565: PUSH
125566: LD_VAR 0 13
125570: PPUSH
125571: LD_VAR 0 13
125575: PUSH
125576: LD_INT 1
125578: PLUS
125579: PPUSH
125580: LD_VAR 0 11
125584: PUSH
125585: LD_VAR 0 12
125589: PUSH
125590: EMPTY
125591: LIST
125592: LIST
125593: PPUSH
125594: CALL_OW 2
125598: ST_TO_ADDR
// end ;
125599: GO 125507
125601: POP
125602: POP
125603: GO 125487
125605: POP
125606: POP
// if not list then
125607: LD_VAR 0 13
125611: NOT
125612: IFFALSE 125616
// exit ;
125614: GO 125687
// for i in list do
125616: LD_ADDR_VAR 0 6
125620: PUSH
125621: LD_VAR 0 13
125625: PUSH
125626: FOR_IN
125627: IFFALSE 125685
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125629: LD_VAR 0 1
125633: PPUSH
125634: LD_STRING M
125636: PUSH
125637: LD_VAR 0 6
125641: PUSH
125642: LD_INT 1
125644: ARRAY
125645: PUSH
125646: LD_VAR 0 6
125650: PUSH
125651: LD_INT 2
125653: ARRAY
125654: PUSH
125655: LD_INT 0
125657: PUSH
125658: LD_INT 0
125660: PUSH
125661: LD_INT 0
125663: PUSH
125664: LD_INT 0
125666: PUSH
125667: EMPTY
125668: LIST
125669: LIST
125670: LIST
125671: LIST
125672: LIST
125673: LIST
125674: LIST
125675: PUSH
125676: EMPTY
125677: LIST
125678: PPUSH
125679: CALL_OW 447
125683: GO 125626
125685: POP
125686: POP
// end ;
125687: LD_VAR 0 5
125691: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125692: LD_EXP 205
125696: NOT
125697: IFFALSE 125747
125699: GO 125701
125701: DISABLE
// begin initHack := true ;
125702: LD_ADDR_EXP 205
125706: PUSH
125707: LD_INT 1
125709: ST_TO_ADDR
// hackTanks := [ ] ;
125710: LD_ADDR_EXP 206
125714: PUSH
125715: EMPTY
125716: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125717: LD_ADDR_EXP 207
125721: PUSH
125722: EMPTY
125723: ST_TO_ADDR
// hackLimit := 3 ;
125724: LD_ADDR_EXP 208
125728: PUSH
125729: LD_INT 3
125731: ST_TO_ADDR
// hackDist := 12 ;
125732: LD_ADDR_EXP 209
125736: PUSH
125737: LD_INT 12
125739: ST_TO_ADDR
// hackCounter := [ ] ;
125740: LD_ADDR_EXP 210
125744: PUSH
125745: EMPTY
125746: ST_TO_ADDR
// end ;
125747: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125748: LD_EXP 205
125752: PUSH
125753: LD_INT 34
125755: PUSH
125756: LD_INT 99
125758: PUSH
125759: EMPTY
125760: LIST
125761: LIST
125762: PPUSH
125763: CALL_OW 69
125767: AND
125768: IFFALSE 126021
125770: GO 125772
125772: DISABLE
125773: LD_INT 0
125775: PPUSH
125776: PPUSH
// begin enable ;
125777: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125778: LD_ADDR_VAR 0 1
125782: PUSH
125783: LD_INT 34
125785: PUSH
125786: LD_INT 99
125788: PUSH
125789: EMPTY
125790: LIST
125791: LIST
125792: PPUSH
125793: CALL_OW 69
125797: PUSH
125798: FOR_IN
125799: IFFALSE 126019
// begin if not i in hackTanks then
125801: LD_VAR 0 1
125805: PUSH
125806: LD_EXP 206
125810: IN
125811: NOT
125812: IFFALSE 125895
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125814: LD_ADDR_EXP 206
125818: PUSH
125819: LD_EXP 206
125823: PPUSH
125824: LD_EXP 206
125828: PUSH
125829: LD_INT 1
125831: PLUS
125832: PPUSH
125833: LD_VAR 0 1
125837: PPUSH
125838: CALL_OW 1
125842: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125843: LD_ADDR_EXP 207
125847: PUSH
125848: LD_EXP 207
125852: PPUSH
125853: LD_EXP 207
125857: PUSH
125858: LD_INT 1
125860: PLUS
125861: PPUSH
125862: EMPTY
125863: PPUSH
125864: CALL_OW 1
125868: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125869: LD_ADDR_EXP 210
125873: PUSH
125874: LD_EXP 210
125878: PPUSH
125879: LD_EXP 210
125883: PUSH
125884: LD_INT 1
125886: PLUS
125887: PPUSH
125888: EMPTY
125889: PPUSH
125890: CALL_OW 1
125894: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125895: LD_VAR 0 1
125899: PPUSH
125900: CALL_OW 302
125904: NOT
125905: IFFALSE 125918
// begin HackUnlinkAll ( i ) ;
125907: LD_VAR 0 1
125911: PPUSH
125912: CALL 126024 0 1
// continue ;
125916: GO 125798
// end ; HackCheckCapturedStatus ( i ) ;
125918: LD_VAR 0 1
125922: PPUSH
125923: CALL 126467 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125927: LD_ADDR_VAR 0 2
125931: PUSH
125932: LD_INT 81
125934: PUSH
125935: LD_VAR 0 1
125939: PPUSH
125940: CALL_OW 255
125944: PUSH
125945: EMPTY
125946: LIST
125947: LIST
125948: PUSH
125949: LD_INT 33
125951: PUSH
125952: LD_INT 3
125954: PUSH
125955: EMPTY
125956: LIST
125957: LIST
125958: PUSH
125959: LD_INT 91
125961: PUSH
125962: LD_VAR 0 1
125966: PUSH
125967: LD_EXP 209
125971: PUSH
125972: EMPTY
125973: LIST
125974: LIST
125975: LIST
125976: PUSH
125977: LD_INT 50
125979: PUSH
125980: EMPTY
125981: LIST
125982: PUSH
125983: EMPTY
125984: LIST
125985: LIST
125986: LIST
125987: LIST
125988: PPUSH
125989: CALL_OW 69
125993: ST_TO_ADDR
// if not tmp then
125994: LD_VAR 0 2
125998: NOT
125999: IFFALSE 126003
// continue ;
126001: GO 125798
// HackLink ( i , tmp ) ;
126003: LD_VAR 0 1
126007: PPUSH
126008: LD_VAR 0 2
126012: PPUSH
126013: CALL 126160 0 2
// end ;
126017: GO 125798
126019: POP
126020: POP
// end ;
126021: PPOPN 2
126023: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
126024: LD_INT 0
126026: PPUSH
126027: PPUSH
126028: PPUSH
// if not hack in hackTanks then
126029: LD_VAR 0 1
126033: PUSH
126034: LD_EXP 206
126038: IN
126039: NOT
126040: IFFALSE 126044
// exit ;
126042: GO 126155
// index := GetElementIndex ( hackTanks , hack ) ;
126044: LD_ADDR_VAR 0 4
126048: PUSH
126049: LD_EXP 206
126053: PPUSH
126054: LD_VAR 0 1
126058: PPUSH
126059: CALL 72432 0 2
126063: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
126064: LD_EXP 207
126068: PUSH
126069: LD_VAR 0 4
126073: ARRAY
126074: IFFALSE 126155
// begin for i in hackTanksCaptured [ index ] do
126076: LD_ADDR_VAR 0 3
126080: PUSH
126081: LD_EXP 207
126085: PUSH
126086: LD_VAR 0 4
126090: ARRAY
126091: PUSH
126092: FOR_IN
126093: IFFALSE 126119
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
126095: LD_VAR 0 3
126099: PUSH
126100: LD_INT 1
126102: ARRAY
126103: PPUSH
126104: LD_VAR 0 3
126108: PUSH
126109: LD_INT 2
126111: ARRAY
126112: PPUSH
126113: CALL_OW 235
126117: GO 126092
126119: POP
126120: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
126121: LD_ADDR_EXP 207
126125: PUSH
126126: LD_EXP 207
126130: PPUSH
126131: LD_VAR 0 4
126135: PPUSH
126136: EMPTY
126137: PPUSH
126138: CALL_OW 1
126142: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
126143: LD_VAR 0 1
126147: PPUSH
126148: LD_INT 0
126150: PPUSH
126151: CALL_OW 505
// end ; end ;
126155: LD_VAR 0 2
126159: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
126160: LD_INT 0
126162: PPUSH
126163: PPUSH
126164: PPUSH
// if not hack in hackTanks or not vehicles then
126165: LD_VAR 0 1
126169: PUSH
126170: LD_EXP 206
126174: IN
126175: NOT
126176: PUSH
126177: LD_VAR 0 2
126181: NOT
126182: OR
126183: IFFALSE 126187
// exit ;
126185: GO 126462
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
126187: LD_ADDR_VAR 0 2
126191: PUSH
126192: LD_VAR 0 1
126196: PPUSH
126197: LD_VAR 0 2
126201: PPUSH
126202: LD_INT 1
126204: PPUSH
126205: LD_INT 1
126207: PPUSH
126208: CALL 73082 0 4
126212: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126213: LD_ADDR_VAR 0 5
126217: PUSH
126218: LD_EXP 206
126222: PPUSH
126223: LD_VAR 0 1
126227: PPUSH
126228: CALL 72432 0 2
126232: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126233: LD_EXP 207
126237: PUSH
126238: LD_VAR 0 5
126242: ARRAY
126243: PUSH
126244: LD_EXP 208
126248: LESS
126249: IFFALSE 126438
// begin for i := 1 to vehicles do
126251: LD_ADDR_VAR 0 4
126255: PUSH
126256: DOUBLE
126257: LD_INT 1
126259: DEC
126260: ST_TO_ADDR
126261: LD_VAR 0 2
126265: PUSH
126266: FOR_TO
126267: IFFALSE 126436
// begin if hackTanksCaptured [ index ] = hackLimit then
126269: LD_EXP 207
126273: PUSH
126274: LD_VAR 0 5
126278: ARRAY
126279: PUSH
126280: LD_EXP 208
126284: EQUAL
126285: IFFALSE 126289
// break ;
126287: GO 126436
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126289: LD_ADDR_EXP 210
126293: PUSH
126294: LD_EXP 210
126298: PPUSH
126299: LD_VAR 0 5
126303: PPUSH
126304: LD_EXP 210
126308: PUSH
126309: LD_VAR 0 5
126313: ARRAY
126314: PUSH
126315: LD_INT 1
126317: PLUS
126318: PPUSH
126319: CALL_OW 1
126323: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126324: LD_ADDR_EXP 207
126328: PUSH
126329: LD_EXP 207
126333: PPUSH
126334: LD_VAR 0 5
126338: PUSH
126339: LD_EXP 207
126343: PUSH
126344: LD_VAR 0 5
126348: ARRAY
126349: PUSH
126350: LD_INT 1
126352: PLUS
126353: PUSH
126354: EMPTY
126355: LIST
126356: LIST
126357: PPUSH
126358: LD_VAR 0 2
126362: PUSH
126363: LD_VAR 0 4
126367: ARRAY
126368: PUSH
126369: LD_VAR 0 2
126373: PUSH
126374: LD_VAR 0 4
126378: ARRAY
126379: PPUSH
126380: CALL_OW 255
126384: PUSH
126385: EMPTY
126386: LIST
126387: LIST
126388: PPUSH
126389: CALL 72647 0 3
126393: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126394: LD_VAR 0 2
126398: PUSH
126399: LD_VAR 0 4
126403: ARRAY
126404: PPUSH
126405: LD_VAR 0 1
126409: PPUSH
126410: CALL_OW 255
126414: PPUSH
126415: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126419: LD_VAR 0 2
126423: PUSH
126424: LD_VAR 0 4
126428: ARRAY
126429: PPUSH
126430: CALL_OW 141
// end ;
126434: GO 126266
126436: POP
126437: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126438: LD_VAR 0 1
126442: PPUSH
126443: LD_EXP 207
126447: PUSH
126448: LD_VAR 0 5
126452: ARRAY
126453: PUSH
126454: LD_INT 0
126456: PLUS
126457: PPUSH
126458: CALL_OW 505
// end ;
126462: LD_VAR 0 3
126466: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126467: LD_INT 0
126469: PPUSH
126470: PPUSH
126471: PPUSH
126472: PPUSH
// if not hack in hackTanks then
126473: LD_VAR 0 1
126477: PUSH
126478: LD_EXP 206
126482: IN
126483: NOT
126484: IFFALSE 126488
// exit ;
126486: GO 126728
// index := GetElementIndex ( hackTanks , hack ) ;
126488: LD_ADDR_VAR 0 4
126492: PUSH
126493: LD_EXP 206
126497: PPUSH
126498: LD_VAR 0 1
126502: PPUSH
126503: CALL 72432 0 2
126507: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126508: LD_ADDR_VAR 0 3
126512: PUSH
126513: DOUBLE
126514: LD_EXP 207
126518: PUSH
126519: LD_VAR 0 4
126523: ARRAY
126524: INC
126525: ST_TO_ADDR
126526: LD_INT 1
126528: PUSH
126529: FOR_DOWNTO
126530: IFFALSE 126702
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126532: LD_ADDR_VAR 0 5
126536: PUSH
126537: LD_EXP 207
126541: PUSH
126542: LD_VAR 0 4
126546: ARRAY
126547: PUSH
126548: LD_VAR 0 3
126552: ARRAY
126553: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126554: LD_VAR 0 5
126558: PUSH
126559: LD_INT 1
126561: ARRAY
126562: PPUSH
126563: CALL_OW 302
126567: NOT
126568: PUSH
126569: LD_VAR 0 5
126573: PUSH
126574: LD_INT 1
126576: ARRAY
126577: PPUSH
126578: CALL_OW 255
126582: PUSH
126583: LD_VAR 0 1
126587: PPUSH
126588: CALL_OW 255
126592: NONEQUAL
126593: OR
126594: IFFALSE 126700
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126596: LD_VAR 0 5
126600: PUSH
126601: LD_INT 1
126603: ARRAY
126604: PPUSH
126605: CALL_OW 305
126609: PUSH
126610: LD_VAR 0 5
126614: PUSH
126615: LD_INT 1
126617: ARRAY
126618: PPUSH
126619: CALL_OW 255
126623: PUSH
126624: LD_VAR 0 1
126628: PPUSH
126629: CALL_OW 255
126633: EQUAL
126634: AND
126635: IFFALSE 126659
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126637: LD_VAR 0 5
126641: PUSH
126642: LD_INT 1
126644: ARRAY
126645: PPUSH
126646: LD_VAR 0 5
126650: PUSH
126651: LD_INT 2
126653: ARRAY
126654: PPUSH
126655: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126659: LD_ADDR_EXP 207
126663: PUSH
126664: LD_EXP 207
126668: PPUSH
126669: LD_VAR 0 4
126673: PPUSH
126674: LD_EXP 207
126678: PUSH
126679: LD_VAR 0 4
126683: ARRAY
126684: PPUSH
126685: LD_VAR 0 3
126689: PPUSH
126690: CALL_OW 3
126694: PPUSH
126695: CALL_OW 1
126699: ST_TO_ADDR
// end ; end ;
126700: GO 126529
126702: POP
126703: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126704: LD_VAR 0 1
126708: PPUSH
126709: LD_EXP 207
126713: PUSH
126714: LD_VAR 0 4
126718: ARRAY
126719: PUSH
126720: LD_INT 0
126722: PLUS
126723: PPUSH
126724: CALL_OW 505
// end ;
126728: LD_VAR 0 2
126732: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126733: LD_INT 0
126735: PPUSH
126736: PPUSH
126737: PPUSH
126738: PPUSH
// if not hack in hackTanks then
126739: LD_VAR 0 1
126743: PUSH
126744: LD_EXP 206
126748: IN
126749: NOT
126750: IFFALSE 126754
// exit ;
126752: GO 126839
// index := GetElementIndex ( hackTanks , hack ) ;
126754: LD_ADDR_VAR 0 5
126758: PUSH
126759: LD_EXP 206
126763: PPUSH
126764: LD_VAR 0 1
126768: PPUSH
126769: CALL 72432 0 2
126773: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126774: LD_ADDR_VAR 0 4
126778: PUSH
126779: DOUBLE
126780: LD_INT 1
126782: DEC
126783: ST_TO_ADDR
126784: LD_EXP 207
126788: PUSH
126789: LD_VAR 0 5
126793: ARRAY
126794: PUSH
126795: FOR_TO
126796: IFFALSE 126837
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126798: LD_EXP 207
126802: PUSH
126803: LD_VAR 0 5
126807: ARRAY
126808: PUSH
126809: LD_VAR 0 4
126813: ARRAY
126814: PUSH
126815: LD_INT 1
126817: ARRAY
126818: PUSH
126819: LD_VAR 0 2
126823: EQUAL
126824: IFFALSE 126835
// KillUnit ( vehicle ) ;
126826: LD_VAR 0 2
126830: PPUSH
126831: CALL_OW 66
126835: GO 126795
126837: POP
126838: POP
// end ;
126839: LD_VAR 0 3
126843: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126844: LD_EXP 211
126848: NOT
126849: IFFALSE 126884
126851: GO 126853
126853: DISABLE
// begin initMiner := true ;
126854: LD_ADDR_EXP 211
126858: PUSH
126859: LD_INT 1
126861: ST_TO_ADDR
// minersList := [ ] ;
126862: LD_ADDR_EXP 212
126866: PUSH
126867: EMPTY
126868: ST_TO_ADDR
// minerMinesList := [ ] ;
126869: LD_ADDR_EXP 213
126873: PUSH
126874: EMPTY
126875: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126876: LD_ADDR_EXP 214
126880: PUSH
126881: LD_INT 5
126883: ST_TO_ADDR
// end ;
126884: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126885: LD_EXP 211
126889: PUSH
126890: LD_INT 34
126892: PUSH
126893: LD_INT 81
126895: PUSH
126896: EMPTY
126897: LIST
126898: LIST
126899: PPUSH
126900: CALL_OW 69
126904: AND
126905: IFFALSE 127366
126907: GO 126909
126909: DISABLE
126910: LD_INT 0
126912: PPUSH
126913: PPUSH
126914: PPUSH
126915: PPUSH
// begin enable ;
126916: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126917: LD_ADDR_VAR 0 1
126921: PUSH
126922: LD_INT 34
126924: PUSH
126925: LD_INT 81
126927: PUSH
126928: EMPTY
126929: LIST
126930: LIST
126931: PPUSH
126932: CALL_OW 69
126936: PUSH
126937: FOR_IN
126938: IFFALSE 127010
// begin if not i in minersList then
126940: LD_VAR 0 1
126944: PUSH
126945: LD_EXP 212
126949: IN
126950: NOT
126951: IFFALSE 127008
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126953: LD_ADDR_EXP 212
126957: PUSH
126958: LD_EXP 212
126962: PPUSH
126963: LD_EXP 212
126967: PUSH
126968: LD_INT 1
126970: PLUS
126971: PPUSH
126972: LD_VAR 0 1
126976: PPUSH
126977: CALL_OW 1
126981: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126982: LD_ADDR_EXP 213
126986: PUSH
126987: LD_EXP 213
126991: PPUSH
126992: LD_EXP 213
126996: PUSH
126997: LD_INT 1
126999: PLUS
127000: PPUSH
127001: EMPTY
127002: PPUSH
127003: CALL_OW 1
127007: ST_TO_ADDR
// end end ;
127008: GO 126937
127010: POP
127011: POP
// for i := minerMinesList downto 1 do
127012: LD_ADDR_VAR 0 1
127016: PUSH
127017: DOUBLE
127018: LD_EXP 213
127022: INC
127023: ST_TO_ADDR
127024: LD_INT 1
127026: PUSH
127027: FOR_DOWNTO
127028: IFFALSE 127364
// begin if IsLive ( minersList [ i ] ) then
127030: LD_EXP 212
127034: PUSH
127035: LD_VAR 0 1
127039: ARRAY
127040: PPUSH
127041: CALL_OW 300
127045: IFFALSE 127073
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
127047: LD_EXP 212
127051: PUSH
127052: LD_VAR 0 1
127056: ARRAY
127057: PPUSH
127058: LD_EXP 213
127062: PUSH
127063: LD_VAR 0 1
127067: ARRAY
127068: PPUSH
127069: CALL_OW 505
// if not minerMinesList [ i ] then
127073: LD_EXP 213
127077: PUSH
127078: LD_VAR 0 1
127082: ARRAY
127083: NOT
127084: IFFALSE 127088
// continue ;
127086: GO 127027
// for j := minerMinesList [ i ] downto 1 do
127088: LD_ADDR_VAR 0 2
127092: PUSH
127093: DOUBLE
127094: LD_EXP 213
127098: PUSH
127099: LD_VAR 0 1
127103: ARRAY
127104: INC
127105: ST_TO_ADDR
127106: LD_INT 1
127108: PUSH
127109: FOR_DOWNTO
127110: IFFALSE 127360
// begin side := GetSide ( minersList [ i ] ) ;
127112: LD_ADDR_VAR 0 3
127116: PUSH
127117: LD_EXP 212
127121: PUSH
127122: LD_VAR 0 1
127126: ARRAY
127127: PPUSH
127128: CALL_OW 255
127132: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
127133: LD_ADDR_VAR 0 4
127137: PUSH
127138: LD_EXP 213
127142: PUSH
127143: LD_VAR 0 1
127147: ARRAY
127148: PUSH
127149: LD_VAR 0 2
127153: ARRAY
127154: PUSH
127155: LD_INT 1
127157: ARRAY
127158: PPUSH
127159: LD_EXP 213
127163: PUSH
127164: LD_VAR 0 1
127168: ARRAY
127169: PUSH
127170: LD_VAR 0 2
127174: ARRAY
127175: PUSH
127176: LD_INT 2
127178: ARRAY
127179: PPUSH
127180: CALL_OW 428
127184: ST_TO_ADDR
// if not tmp then
127185: LD_VAR 0 4
127189: NOT
127190: IFFALSE 127194
// continue ;
127192: GO 127109
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
127194: LD_VAR 0 4
127198: PUSH
127199: LD_INT 81
127201: PUSH
127202: LD_VAR 0 3
127206: PUSH
127207: EMPTY
127208: LIST
127209: LIST
127210: PPUSH
127211: CALL_OW 69
127215: IN
127216: PUSH
127217: LD_EXP 213
127221: PUSH
127222: LD_VAR 0 1
127226: ARRAY
127227: PUSH
127228: LD_VAR 0 2
127232: ARRAY
127233: PUSH
127234: LD_INT 1
127236: ARRAY
127237: PPUSH
127238: LD_EXP 213
127242: PUSH
127243: LD_VAR 0 1
127247: ARRAY
127248: PUSH
127249: LD_VAR 0 2
127253: ARRAY
127254: PUSH
127255: LD_INT 2
127257: ARRAY
127258: PPUSH
127259: CALL_OW 458
127263: AND
127264: IFFALSE 127358
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127266: LD_EXP 213
127270: PUSH
127271: LD_VAR 0 1
127275: ARRAY
127276: PUSH
127277: LD_VAR 0 2
127281: ARRAY
127282: PUSH
127283: LD_INT 1
127285: ARRAY
127286: PPUSH
127287: LD_EXP 213
127291: PUSH
127292: LD_VAR 0 1
127296: ARRAY
127297: PUSH
127298: LD_VAR 0 2
127302: ARRAY
127303: PUSH
127304: LD_INT 2
127306: ARRAY
127307: PPUSH
127308: LD_VAR 0 3
127312: PPUSH
127313: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127317: LD_ADDR_EXP 213
127321: PUSH
127322: LD_EXP 213
127326: PPUSH
127327: LD_VAR 0 1
127331: PPUSH
127332: LD_EXP 213
127336: PUSH
127337: LD_VAR 0 1
127341: ARRAY
127342: PPUSH
127343: LD_VAR 0 2
127347: PPUSH
127348: CALL_OW 3
127352: PPUSH
127353: CALL_OW 1
127357: ST_TO_ADDR
// end ; end ;
127358: GO 127109
127360: POP
127361: POP
// end ;
127362: GO 127027
127364: POP
127365: POP
// end ;
127366: PPOPN 4
127368: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127369: LD_INT 0
127371: PPUSH
127372: PPUSH
// result := false ;
127373: LD_ADDR_VAR 0 4
127377: PUSH
127378: LD_INT 0
127380: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127381: LD_VAR 0 1
127385: PPUSH
127386: CALL_OW 264
127390: PUSH
127391: LD_INT 81
127393: EQUAL
127394: NOT
127395: IFFALSE 127399
// exit ;
127397: GO 127639
// index := GetElementIndex ( minersList , unit ) ;
127399: LD_ADDR_VAR 0 5
127403: PUSH
127404: LD_EXP 212
127408: PPUSH
127409: LD_VAR 0 1
127413: PPUSH
127414: CALL 72432 0 2
127418: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127419: LD_EXP 213
127423: PUSH
127424: LD_VAR 0 5
127428: ARRAY
127429: PUSH
127430: LD_EXP 214
127434: GREATEREQUAL
127435: IFFALSE 127439
// exit ;
127437: GO 127639
// ComMoveXY ( unit , x , y ) ;
127439: LD_VAR 0 1
127443: PPUSH
127444: LD_VAR 0 2
127448: PPUSH
127449: LD_VAR 0 3
127453: PPUSH
127454: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127458: LD_INT 35
127460: PPUSH
127461: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127465: LD_VAR 0 1
127469: PPUSH
127470: LD_VAR 0 2
127474: PPUSH
127475: LD_VAR 0 3
127479: PPUSH
127480: CALL 103768 0 3
127484: NOT
127485: PUSH
127486: LD_VAR 0 1
127490: PPUSH
127491: CALL_OW 314
127495: AND
127496: IFFALSE 127500
// exit ;
127498: GO 127639
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127500: LD_VAR 0 2
127504: PPUSH
127505: LD_VAR 0 3
127509: PPUSH
127510: CALL_OW 428
127514: PUSH
127515: LD_VAR 0 1
127519: EQUAL
127520: PUSH
127521: LD_VAR 0 1
127525: PPUSH
127526: CALL_OW 314
127530: NOT
127531: AND
127532: IFFALSE 127458
// PlaySoundXY ( x , y , PlantMine ) ;
127534: LD_VAR 0 2
127538: PPUSH
127539: LD_VAR 0 3
127543: PPUSH
127544: LD_STRING PlantMine
127546: PPUSH
127547: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127551: LD_VAR 0 2
127555: PPUSH
127556: LD_VAR 0 3
127560: PPUSH
127561: LD_VAR 0 1
127565: PPUSH
127566: CALL_OW 255
127570: PPUSH
127571: LD_INT 0
127573: PPUSH
127574: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127578: LD_ADDR_EXP 213
127582: PUSH
127583: LD_EXP 213
127587: PPUSH
127588: LD_VAR 0 5
127592: PUSH
127593: LD_EXP 213
127597: PUSH
127598: LD_VAR 0 5
127602: ARRAY
127603: PUSH
127604: LD_INT 1
127606: PLUS
127607: PUSH
127608: EMPTY
127609: LIST
127610: LIST
127611: PPUSH
127612: LD_VAR 0 2
127616: PUSH
127617: LD_VAR 0 3
127621: PUSH
127622: EMPTY
127623: LIST
127624: LIST
127625: PPUSH
127626: CALL 72647 0 3
127630: ST_TO_ADDR
// result := true ;
127631: LD_ADDR_VAR 0 4
127635: PUSH
127636: LD_INT 1
127638: ST_TO_ADDR
// end ;
127639: LD_VAR 0 4
127643: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127644: LD_INT 0
127646: PPUSH
127647: PPUSH
127648: PPUSH
// if not unit in minersList then
127649: LD_VAR 0 1
127653: PUSH
127654: LD_EXP 212
127658: IN
127659: NOT
127660: IFFALSE 127664
// exit ;
127662: GO 128056
// index := GetElementIndex ( minersList , unit ) ;
127664: LD_ADDR_VAR 0 6
127668: PUSH
127669: LD_EXP 212
127673: PPUSH
127674: LD_VAR 0 1
127678: PPUSH
127679: CALL 72432 0 2
127683: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127684: LD_ADDR_VAR 0 5
127688: PUSH
127689: DOUBLE
127690: LD_EXP 213
127694: PUSH
127695: LD_VAR 0 6
127699: ARRAY
127700: INC
127701: ST_TO_ADDR
127702: LD_INT 1
127704: PUSH
127705: FOR_DOWNTO
127706: IFFALSE 127867
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127708: LD_EXP 213
127712: PUSH
127713: LD_VAR 0 6
127717: ARRAY
127718: PUSH
127719: LD_VAR 0 5
127723: ARRAY
127724: PUSH
127725: LD_INT 1
127727: ARRAY
127728: PUSH
127729: LD_VAR 0 2
127733: EQUAL
127734: PUSH
127735: LD_EXP 213
127739: PUSH
127740: LD_VAR 0 6
127744: ARRAY
127745: PUSH
127746: LD_VAR 0 5
127750: ARRAY
127751: PUSH
127752: LD_INT 2
127754: ARRAY
127755: PUSH
127756: LD_VAR 0 3
127760: EQUAL
127761: AND
127762: IFFALSE 127865
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127764: LD_EXP 213
127768: PUSH
127769: LD_VAR 0 6
127773: ARRAY
127774: PUSH
127775: LD_VAR 0 5
127779: ARRAY
127780: PUSH
127781: LD_INT 1
127783: ARRAY
127784: PPUSH
127785: LD_EXP 213
127789: PUSH
127790: LD_VAR 0 6
127794: ARRAY
127795: PUSH
127796: LD_VAR 0 5
127800: ARRAY
127801: PUSH
127802: LD_INT 2
127804: ARRAY
127805: PPUSH
127806: LD_VAR 0 1
127810: PPUSH
127811: CALL_OW 255
127815: PPUSH
127816: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127820: LD_ADDR_EXP 213
127824: PUSH
127825: LD_EXP 213
127829: PPUSH
127830: LD_VAR 0 6
127834: PPUSH
127835: LD_EXP 213
127839: PUSH
127840: LD_VAR 0 6
127844: ARRAY
127845: PPUSH
127846: LD_VAR 0 5
127850: PPUSH
127851: CALL_OW 3
127855: PPUSH
127856: CALL_OW 1
127860: ST_TO_ADDR
// exit ;
127861: POP
127862: POP
127863: GO 128056
// end ; end ;
127865: GO 127705
127867: POP
127868: POP
// for i := minerMinesList [ index ] downto 1 do
127869: LD_ADDR_VAR 0 5
127873: PUSH
127874: DOUBLE
127875: LD_EXP 213
127879: PUSH
127880: LD_VAR 0 6
127884: ARRAY
127885: INC
127886: ST_TO_ADDR
127887: LD_INT 1
127889: PUSH
127890: FOR_DOWNTO
127891: IFFALSE 128054
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127893: LD_EXP 213
127897: PUSH
127898: LD_VAR 0 6
127902: ARRAY
127903: PUSH
127904: LD_VAR 0 5
127908: ARRAY
127909: PUSH
127910: LD_INT 1
127912: ARRAY
127913: PPUSH
127914: LD_EXP 213
127918: PUSH
127919: LD_VAR 0 6
127923: ARRAY
127924: PUSH
127925: LD_VAR 0 5
127929: ARRAY
127930: PUSH
127931: LD_INT 2
127933: ARRAY
127934: PPUSH
127935: LD_VAR 0 2
127939: PPUSH
127940: LD_VAR 0 3
127944: PPUSH
127945: CALL_OW 298
127949: PUSH
127950: LD_INT 6
127952: LESS
127953: IFFALSE 128052
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127955: LD_EXP 213
127959: PUSH
127960: LD_VAR 0 6
127964: ARRAY
127965: PUSH
127966: LD_VAR 0 5
127970: ARRAY
127971: PUSH
127972: LD_INT 1
127974: ARRAY
127975: PPUSH
127976: LD_EXP 213
127980: PUSH
127981: LD_VAR 0 6
127985: ARRAY
127986: PUSH
127987: LD_VAR 0 5
127991: ARRAY
127992: PUSH
127993: LD_INT 2
127995: ARRAY
127996: PPUSH
127997: LD_VAR 0 1
128001: PPUSH
128002: CALL_OW 255
128006: PPUSH
128007: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128011: LD_ADDR_EXP 213
128015: PUSH
128016: LD_EXP 213
128020: PPUSH
128021: LD_VAR 0 6
128025: PPUSH
128026: LD_EXP 213
128030: PUSH
128031: LD_VAR 0 6
128035: ARRAY
128036: PPUSH
128037: LD_VAR 0 5
128041: PPUSH
128042: CALL_OW 3
128046: PPUSH
128047: CALL_OW 1
128051: ST_TO_ADDR
// end ; end ;
128052: GO 127890
128054: POP
128055: POP
// end ;
128056: LD_VAR 0 4
128060: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
128061: LD_INT 0
128063: PPUSH
128064: PPUSH
128065: PPUSH
128066: PPUSH
128067: PPUSH
128068: PPUSH
128069: PPUSH
128070: PPUSH
128071: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
128072: LD_VAR 0 1
128076: PPUSH
128077: CALL_OW 264
128081: PUSH
128082: LD_INT 81
128084: EQUAL
128085: NOT
128086: PUSH
128087: LD_VAR 0 1
128091: PUSH
128092: LD_EXP 212
128096: IN
128097: NOT
128098: OR
128099: IFFALSE 128103
// exit ;
128101: GO 128425
// index := GetElementIndex ( minersList , unit ) ;
128103: LD_ADDR_VAR 0 6
128107: PUSH
128108: LD_EXP 212
128112: PPUSH
128113: LD_VAR 0 1
128117: PPUSH
128118: CALL 72432 0 2
128122: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
128123: LD_ADDR_VAR 0 8
128127: PUSH
128128: LD_EXP 214
128132: PUSH
128133: LD_EXP 213
128137: PUSH
128138: LD_VAR 0 6
128142: ARRAY
128143: MINUS
128144: ST_TO_ADDR
// if not minesFreeAmount then
128145: LD_VAR 0 8
128149: NOT
128150: IFFALSE 128154
// exit ;
128152: GO 128425
// tmp := [ ] ;
128154: LD_ADDR_VAR 0 7
128158: PUSH
128159: EMPTY
128160: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
128161: LD_ADDR_VAR 0 5
128165: PUSH
128166: DOUBLE
128167: LD_INT 1
128169: DEC
128170: ST_TO_ADDR
128171: LD_VAR 0 8
128175: PUSH
128176: FOR_TO
128177: IFFALSE 128372
// begin _d := rand ( 0 , 5 ) ;
128179: LD_ADDR_VAR 0 11
128183: PUSH
128184: LD_INT 0
128186: PPUSH
128187: LD_INT 5
128189: PPUSH
128190: CALL_OW 12
128194: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
128195: LD_ADDR_VAR 0 12
128199: PUSH
128200: LD_INT 2
128202: PPUSH
128203: LD_INT 6
128205: PPUSH
128206: CALL_OW 12
128210: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128211: LD_ADDR_VAR 0 9
128215: PUSH
128216: LD_VAR 0 2
128220: PPUSH
128221: LD_VAR 0 11
128225: PPUSH
128226: LD_VAR 0 12
128230: PPUSH
128231: CALL_OW 272
128235: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128236: LD_ADDR_VAR 0 10
128240: PUSH
128241: LD_VAR 0 3
128245: PPUSH
128246: LD_VAR 0 11
128250: PPUSH
128251: LD_VAR 0 12
128255: PPUSH
128256: CALL_OW 273
128260: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128261: LD_VAR 0 9
128265: PPUSH
128266: LD_VAR 0 10
128270: PPUSH
128271: CALL_OW 488
128275: PUSH
128276: LD_VAR 0 9
128280: PUSH
128281: LD_VAR 0 10
128285: PUSH
128286: EMPTY
128287: LIST
128288: LIST
128289: PUSH
128290: LD_VAR 0 7
128294: IN
128295: NOT
128296: AND
128297: PUSH
128298: LD_VAR 0 9
128302: PPUSH
128303: LD_VAR 0 10
128307: PPUSH
128308: CALL_OW 458
128312: NOT
128313: AND
128314: IFFALSE 128356
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128316: LD_ADDR_VAR 0 7
128320: PUSH
128321: LD_VAR 0 7
128325: PPUSH
128326: LD_VAR 0 7
128330: PUSH
128331: LD_INT 1
128333: PLUS
128334: PPUSH
128335: LD_VAR 0 9
128339: PUSH
128340: LD_VAR 0 10
128344: PUSH
128345: EMPTY
128346: LIST
128347: LIST
128348: PPUSH
128349: CALL_OW 1
128353: ST_TO_ADDR
128354: GO 128370
// i := i - 1 ;
128356: LD_ADDR_VAR 0 5
128360: PUSH
128361: LD_VAR 0 5
128365: PUSH
128366: LD_INT 1
128368: MINUS
128369: ST_TO_ADDR
// end ;
128370: GO 128176
128372: POP
128373: POP
// for i in tmp do
128374: LD_ADDR_VAR 0 5
128378: PUSH
128379: LD_VAR 0 7
128383: PUSH
128384: FOR_IN
128385: IFFALSE 128423
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128387: LD_VAR 0 1
128391: PPUSH
128392: LD_VAR 0 5
128396: PUSH
128397: LD_INT 1
128399: ARRAY
128400: PPUSH
128401: LD_VAR 0 5
128405: PUSH
128406: LD_INT 2
128408: ARRAY
128409: PPUSH
128410: CALL 127369 0 3
128414: NOT
128415: IFFALSE 128421
// exit ;
128417: POP
128418: POP
128419: GO 128425
128421: GO 128384
128423: POP
128424: POP
// end ;
128425: LD_VAR 0 4
128429: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128430: LD_INT 0
128432: PPUSH
128433: PPUSH
128434: PPUSH
128435: PPUSH
128436: PPUSH
128437: PPUSH
128438: PPUSH
// if not GetClass ( unit ) = class_sniper then
128439: LD_VAR 0 1
128443: PPUSH
128444: CALL_OW 257
128448: PUSH
128449: LD_INT 5
128451: EQUAL
128452: NOT
128453: IFFALSE 128457
// exit ;
128455: GO 128845
// dist := 8 ;
128457: LD_ADDR_VAR 0 5
128461: PUSH
128462: LD_INT 8
128464: ST_TO_ADDR
// viewRange := 12 ;
128465: LD_ADDR_VAR 0 7
128469: PUSH
128470: LD_INT 12
128472: ST_TO_ADDR
// side := GetSide ( unit ) ;
128473: LD_ADDR_VAR 0 6
128477: PUSH
128478: LD_VAR 0 1
128482: PPUSH
128483: CALL_OW 255
128487: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128488: LD_INT 61
128490: PPUSH
128491: LD_VAR 0 6
128495: PPUSH
128496: CALL_OW 321
128500: PUSH
128501: LD_INT 2
128503: EQUAL
128504: IFFALSE 128514
// viewRange := 16 ;
128506: LD_ADDR_VAR 0 7
128510: PUSH
128511: LD_INT 16
128513: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128514: LD_VAR 0 1
128518: PPUSH
128519: LD_VAR 0 2
128523: PPUSH
128524: LD_VAR 0 3
128528: PPUSH
128529: CALL_OW 297
128533: PUSH
128534: LD_VAR 0 5
128538: GREATER
128539: IFFALSE 128618
// begin ComMoveXY ( unit , x , y ) ;
128541: LD_VAR 0 1
128545: PPUSH
128546: LD_VAR 0 2
128550: PPUSH
128551: LD_VAR 0 3
128555: PPUSH
128556: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128560: LD_INT 35
128562: PPUSH
128563: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128567: LD_VAR 0 1
128571: PPUSH
128572: LD_VAR 0 2
128576: PPUSH
128577: LD_VAR 0 3
128581: PPUSH
128582: CALL 103768 0 3
128586: NOT
128587: IFFALSE 128591
// exit ;
128589: GO 128845
// until GetDistUnitXY ( unit , x , y ) < dist ;
128591: LD_VAR 0 1
128595: PPUSH
128596: LD_VAR 0 2
128600: PPUSH
128601: LD_VAR 0 3
128605: PPUSH
128606: CALL_OW 297
128610: PUSH
128611: LD_VAR 0 5
128615: LESS
128616: IFFALSE 128560
// end ; ComTurnXY ( unit , x , y ) ;
128618: LD_VAR 0 1
128622: PPUSH
128623: LD_VAR 0 2
128627: PPUSH
128628: LD_VAR 0 3
128632: PPUSH
128633: CALL_OW 118
// wait ( 5 ) ;
128637: LD_INT 5
128639: PPUSH
128640: CALL_OW 67
// _d := GetDir ( unit ) ;
128644: LD_ADDR_VAR 0 10
128648: PUSH
128649: LD_VAR 0 1
128653: PPUSH
128654: CALL_OW 254
128658: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128659: LD_ADDR_VAR 0 8
128663: PUSH
128664: LD_VAR 0 1
128668: PPUSH
128669: CALL_OW 250
128673: PPUSH
128674: LD_VAR 0 10
128678: PPUSH
128679: LD_VAR 0 5
128683: PPUSH
128684: CALL_OW 272
128688: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128689: LD_ADDR_VAR 0 9
128693: PUSH
128694: LD_VAR 0 1
128698: PPUSH
128699: CALL_OW 251
128703: PPUSH
128704: LD_VAR 0 10
128708: PPUSH
128709: LD_VAR 0 5
128713: PPUSH
128714: CALL_OW 273
128718: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128719: LD_VAR 0 8
128723: PPUSH
128724: LD_VAR 0 9
128728: PPUSH
128729: CALL_OW 488
128733: NOT
128734: IFFALSE 128738
// exit ;
128736: GO 128845
// ComAnimCustom ( unit , 1 ) ;
128738: LD_VAR 0 1
128742: PPUSH
128743: LD_INT 1
128745: PPUSH
128746: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128750: LD_VAR 0 8
128754: PPUSH
128755: LD_VAR 0 9
128759: PPUSH
128760: LD_VAR 0 6
128764: PPUSH
128765: LD_VAR 0 7
128769: PPUSH
128770: CALL_OW 330
// repeat wait ( 1 ) ;
128774: LD_INT 1
128776: PPUSH
128777: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128781: LD_VAR 0 1
128785: PPUSH
128786: CALL_OW 316
128790: PUSH
128791: LD_VAR 0 1
128795: PPUSH
128796: CALL_OW 314
128800: OR
128801: PUSH
128802: LD_VAR 0 1
128806: PPUSH
128807: CALL_OW 302
128811: NOT
128812: OR
128813: PUSH
128814: LD_VAR 0 1
128818: PPUSH
128819: CALL_OW 301
128823: OR
128824: IFFALSE 128774
// RemoveSeeing ( _x , _y , side ) ;
128826: LD_VAR 0 8
128830: PPUSH
128831: LD_VAR 0 9
128835: PPUSH
128836: LD_VAR 0 6
128840: PPUSH
128841: CALL_OW 331
// end ; end_of_file
128845: LD_VAR 0 4
128849: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128850: LD_INT 0
128852: PPUSH
128853: PPUSH
128854: PPUSH
128855: PPUSH
128856: PPUSH
128857: PPUSH
128858: PPUSH
128859: PPUSH
128860: PPUSH
128861: PPUSH
128862: PPUSH
128863: PPUSH
128864: PPUSH
128865: PPUSH
128866: PPUSH
128867: PPUSH
128868: PPUSH
128869: PPUSH
128870: PPUSH
128871: PPUSH
128872: PPUSH
128873: PPUSH
128874: PPUSH
128875: PPUSH
128876: PPUSH
128877: PPUSH
128878: PPUSH
128879: PPUSH
128880: PPUSH
128881: PPUSH
128882: PPUSH
128883: PPUSH
128884: PPUSH
128885: PPUSH
// if not list then
128886: LD_VAR 0 1
128890: NOT
128891: IFFALSE 128895
// exit ;
128893: GO 133554
// base := list [ 1 ] ;
128895: LD_ADDR_VAR 0 3
128899: PUSH
128900: LD_VAR 0 1
128904: PUSH
128905: LD_INT 1
128907: ARRAY
128908: ST_TO_ADDR
// group := list [ 2 ] ;
128909: LD_ADDR_VAR 0 4
128913: PUSH
128914: LD_VAR 0 1
128918: PUSH
128919: LD_INT 2
128921: ARRAY
128922: ST_TO_ADDR
// path := list [ 3 ] ;
128923: LD_ADDR_VAR 0 5
128927: PUSH
128928: LD_VAR 0 1
128932: PUSH
128933: LD_INT 3
128935: ARRAY
128936: ST_TO_ADDR
// flags := list [ 4 ] ;
128937: LD_ADDR_VAR 0 6
128941: PUSH
128942: LD_VAR 0 1
128946: PUSH
128947: LD_INT 4
128949: ARRAY
128950: ST_TO_ADDR
// mined := [ ] ;
128951: LD_ADDR_VAR 0 27
128955: PUSH
128956: EMPTY
128957: ST_TO_ADDR
// bombed := [ ] ;
128958: LD_ADDR_VAR 0 28
128962: PUSH
128963: EMPTY
128964: ST_TO_ADDR
// healers := [ ] ;
128965: LD_ADDR_VAR 0 31
128969: PUSH
128970: EMPTY
128971: ST_TO_ADDR
// to_heal := [ ] ;
128972: LD_ADDR_VAR 0 30
128976: PUSH
128977: EMPTY
128978: ST_TO_ADDR
// repairs := [ ] ;
128979: LD_ADDR_VAR 0 33
128983: PUSH
128984: EMPTY
128985: ST_TO_ADDR
// to_repair := [ ] ;
128986: LD_ADDR_VAR 0 32
128990: PUSH
128991: EMPTY
128992: ST_TO_ADDR
// if not group or not path then
128993: LD_VAR 0 4
128997: NOT
128998: PUSH
128999: LD_VAR 0 5
129003: NOT
129004: OR
129005: IFFALSE 129009
// exit ;
129007: GO 133554
// side := GetSide ( group [ 1 ] ) ;
129009: LD_ADDR_VAR 0 35
129013: PUSH
129014: LD_VAR 0 4
129018: PUSH
129019: LD_INT 1
129021: ARRAY
129022: PPUSH
129023: CALL_OW 255
129027: ST_TO_ADDR
// if flags then
129028: LD_VAR 0 6
129032: IFFALSE 129176
// begin f_ignore_area := flags [ 1 ] ;
129034: LD_ADDR_VAR 0 17
129038: PUSH
129039: LD_VAR 0 6
129043: PUSH
129044: LD_INT 1
129046: ARRAY
129047: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
129048: LD_ADDR_VAR 0 18
129052: PUSH
129053: LD_VAR 0 6
129057: PUSH
129058: LD_INT 2
129060: ARRAY
129061: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
129062: LD_ADDR_VAR 0 19
129066: PUSH
129067: LD_VAR 0 6
129071: PUSH
129072: LD_INT 3
129074: ARRAY
129075: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
129076: LD_ADDR_VAR 0 20
129080: PUSH
129081: LD_VAR 0 6
129085: PUSH
129086: LD_INT 4
129088: ARRAY
129089: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
129090: LD_ADDR_VAR 0 21
129094: PUSH
129095: LD_VAR 0 6
129099: PUSH
129100: LD_INT 5
129102: ARRAY
129103: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
129104: LD_ADDR_VAR 0 22
129108: PUSH
129109: LD_VAR 0 6
129113: PUSH
129114: LD_INT 6
129116: ARRAY
129117: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
129118: LD_ADDR_VAR 0 23
129122: PUSH
129123: LD_VAR 0 6
129127: PUSH
129128: LD_INT 7
129130: ARRAY
129131: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
129132: LD_ADDR_VAR 0 24
129136: PUSH
129137: LD_VAR 0 6
129141: PUSH
129142: LD_INT 8
129144: ARRAY
129145: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
129146: LD_ADDR_VAR 0 25
129150: PUSH
129151: LD_VAR 0 6
129155: PUSH
129156: LD_INT 9
129158: ARRAY
129159: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
129160: LD_ADDR_VAR 0 26
129164: PUSH
129165: LD_VAR 0 6
129169: PUSH
129170: LD_INT 10
129172: ARRAY
129173: ST_TO_ADDR
// end else
129174: GO 129256
// begin f_ignore_area := false ;
129176: LD_ADDR_VAR 0 17
129180: PUSH
129181: LD_INT 0
129183: ST_TO_ADDR
// f_capture := false ;
129184: LD_ADDR_VAR 0 18
129188: PUSH
129189: LD_INT 0
129191: ST_TO_ADDR
// f_ignore_civ := false ;
129192: LD_ADDR_VAR 0 19
129196: PUSH
129197: LD_INT 0
129199: ST_TO_ADDR
// f_murder := false ;
129200: LD_ADDR_VAR 0 20
129204: PUSH
129205: LD_INT 0
129207: ST_TO_ADDR
// f_mines := false ;
129208: LD_ADDR_VAR 0 21
129212: PUSH
129213: LD_INT 0
129215: ST_TO_ADDR
// f_repair := false ;
129216: LD_ADDR_VAR 0 22
129220: PUSH
129221: LD_INT 0
129223: ST_TO_ADDR
// f_heal := false ;
129224: LD_ADDR_VAR 0 23
129228: PUSH
129229: LD_INT 0
129231: ST_TO_ADDR
// f_spacetime := false ;
129232: LD_ADDR_VAR 0 24
129236: PUSH
129237: LD_INT 0
129239: ST_TO_ADDR
// f_attack_depot := false ;
129240: LD_ADDR_VAR 0 25
129244: PUSH
129245: LD_INT 0
129247: ST_TO_ADDR
// f_crawl := false ;
129248: LD_ADDR_VAR 0 26
129252: PUSH
129253: LD_INT 0
129255: ST_TO_ADDR
// end ; if f_heal then
129256: LD_VAR 0 23
129260: IFFALSE 129287
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129262: LD_ADDR_VAR 0 31
129266: PUSH
129267: LD_VAR 0 4
129271: PPUSH
129272: LD_INT 25
129274: PUSH
129275: LD_INT 4
129277: PUSH
129278: EMPTY
129279: LIST
129280: LIST
129281: PPUSH
129282: CALL_OW 72
129286: ST_TO_ADDR
// if f_repair then
129287: LD_VAR 0 22
129291: IFFALSE 129318
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129293: LD_ADDR_VAR 0 33
129297: PUSH
129298: LD_VAR 0 4
129302: PPUSH
129303: LD_INT 25
129305: PUSH
129306: LD_INT 3
129308: PUSH
129309: EMPTY
129310: LIST
129311: LIST
129312: PPUSH
129313: CALL_OW 72
129317: ST_TO_ADDR
// units_path := [ ] ;
129318: LD_ADDR_VAR 0 16
129322: PUSH
129323: EMPTY
129324: ST_TO_ADDR
// for i = 1 to group do
129325: LD_ADDR_VAR 0 7
129329: PUSH
129330: DOUBLE
129331: LD_INT 1
129333: DEC
129334: ST_TO_ADDR
129335: LD_VAR 0 4
129339: PUSH
129340: FOR_TO
129341: IFFALSE 129370
// units_path := Replace ( units_path , i , path ) ;
129343: LD_ADDR_VAR 0 16
129347: PUSH
129348: LD_VAR 0 16
129352: PPUSH
129353: LD_VAR 0 7
129357: PPUSH
129358: LD_VAR 0 5
129362: PPUSH
129363: CALL_OW 1
129367: ST_TO_ADDR
129368: GO 129340
129370: POP
129371: POP
// repeat for i = group downto 1 do
129372: LD_ADDR_VAR 0 7
129376: PUSH
129377: DOUBLE
129378: LD_VAR 0 4
129382: INC
129383: ST_TO_ADDR
129384: LD_INT 1
129386: PUSH
129387: FOR_DOWNTO
129388: IFFALSE 133510
// begin wait ( 5 ) ;
129390: LD_INT 5
129392: PPUSH
129393: CALL_OW 67
// tmp := [ ] ;
129397: LD_ADDR_VAR 0 14
129401: PUSH
129402: EMPTY
129403: ST_TO_ADDR
// attacking := false ;
129404: LD_ADDR_VAR 0 29
129408: PUSH
129409: LD_INT 0
129411: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129412: LD_VAR 0 4
129416: PUSH
129417: LD_VAR 0 7
129421: ARRAY
129422: PPUSH
129423: CALL_OW 301
129427: PUSH
129428: LD_VAR 0 4
129432: PUSH
129433: LD_VAR 0 7
129437: ARRAY
129438: NOT
129439: OR
129440: IFFALSE 129549
// begin if GetType ( group [ i ] ) = unit_human then
129442: LD_VAR 0 4
129446: PUSH
129447: LD_VAR 0 7
129451: ARRAY
129452: PPUSH
129453: CALL_OW 247
129457: PUSH
129458: LD_INT 1
129460: EQUAL
129461: IFFALSE 129507
// begin to_heal := to_heal diff group [ i ] ;
129463: LD_ADDR_VAR 0 30
129467: PUSH
129468: LD_VAR 0 30
129472: PUSH
129473: LD_VAR 0 4
129477: PUSH
129478: LD_VAR 0 7
129482: ARRAY
129483: DIFF
129484: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129485: LD_ADDR_VAR 0 31
129489: PUSH
129490: LD_VAR 0 31
129494: PUSH
129495: LD_VAR 0 4
129499: PUSH
129500: LD_VAR 0 7
129504: ARRAY
129505: DIFF
129506: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129507: LD_ADDR_VAR 0 4
129511: PUSH
129512: LD_VAR 0 4
129516: PPUSH
129517: LD_VAR 0 7
129521: PPUSH
129522: CALL_OW 3
129526: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129527: LD_ADDR_VAR 0 16
129531: PUSH
129532: LD_VAR 0 16
129536: PPUSH
129537: LD_VAR 0 7
129541: PPUSH
129542: CALL_OW 3
129546: ST_TO_ADDR
// continue ;
129547: GO 129387
// end ; if f_repair then
129549: LD_VAR 0 22
129553: IFFALSE 130042
// begin if GetType ( group [ i ] ) = unit_vehicle then
129555: LD_VAR 0 4
129559: PUSH
129560: LD_VAR 0 7
129564: ARRAY
129565: PPUSH
129566: CALL_OW 247
129570: PUSH
129571: LD_INT 2
129573: EQUAL
129574: IFFALSE 129764
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129576: LD_VAR 0 4
129580: PUSH
129581: LD_VAR 0 7
129585: ARRAY
129586: PPUSH
129587: CALL_OW 256
129591: PUSH
129592: LD_INT 700
129594: LESS
129595: PUSH
129596: LD_VAR 0 4
129600: PUSH
129601: LD_VAR 0 7
129605: ARRAY
129606: PUSH
129607: LD_VAR 0 32
129611: IN
129612: NOT
129613: AND
129614: IFFALSE 129638
// to_repair := to_repair union group [ i ] ;
129616: LD_ADDR_VAR 0 32
129620: PUSH
129621: LD_VAR 0 32
129625: PUSH
129626: LD_VAR 0 4
129630: PUSH
129631: LD_VAR 0 7
129635: ARRAY
129636: UNION
129637: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129638: LD_VAR 0 4
129642: PUSH
129643: LD_VAR 0 7
129647: ARRAY
129648: PPUSH
129649: CALL_OW 256
129653: PUSH
129654: LD_INT 1000
129656: EQUAL
129657: PUSH
129658: LD_VAR 0 4
129662: PUSH
129663: LD_VAR 0 7
129667: ARRAY
129668: PUSH
129669: LD_VAR 0 32
129673: IN
129674: AND
129675: IFFALSE 129699
// to_repair := to_repair diff group [ i ] ;
129677: LD_ADDR_VAR 0 32
129681: PUSH
129682: LD_VAR 0 32
129686: PUSH
129687: LD_VAR 0 4
129691: PUSH
129692: LD_VAR 0 7
129696: ARRAY
129697: DIFF
129698: ST_TO_ADDR
// if group [ i ] in to_repair then
129699: LD_VAR 0 4
129703: PUSH
129704: LD_VAR 0 7
129708: ARRAY
129709: PUSH
129710: LD_VAR 0 32
129714: IN
129715: IFFALSE 129762
// begin if not IsInArea ( group [ i ] , f_repair ) then
129717: LD_VAR 0 4
129721: PUSH
129722: LD_VAR 0 7
129726: ARRAY
129727: PPUSH
129728: LD_VAR 0 22
129732: PPUSH
129733: CALL_OW 308
129737: NOT
129738: IFFALSE 129760
// ComMoveToArea ( group [ i ] , f_repair ) ;
129740: LD_VAR 0 4
129744: PUSH
129745: LD_VAR 0 7
129749: ARRAY
129750: PPUSH
129751: LD_VAR 0 22
129755: PPUSH
129756: CALL_OW 113
// continue ;
129760: GO 129387
// end ; end else
129762: GO 130042
// if group [ i ] in repairs then
129764: LD_VAR 0 4
129768: PUSH
129769: LD_VAR 0 7
129773: ARRAY
129774: PUSH
129775: LD_VAR 0 33
129779: IN
129780: IFFALSE 130042
// begin if IsInUnit ( group [ i ] ) then
129782: LD_VAR 0 4
129786: PUSH
129787: LD_VAR 0 7
129791: ARRAY
129792: PPUSH
129793: CALL_OW 310
129797: IFFALSE 129865
// begin z := IsInUnit ( group [ i ] ) ;
129799: LD_ADDR_VAR 0 13
129803: PUSH
129804: LD_VAR 0 4
129808: PUSH
129809: LD_VAR 0 7
129813: ARRAY
129814: PPUSH
129815: CALL_OW 310
129819: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129820: LD_VAR 0 13
129824: PUSH
129825: LD_VAR 0 32
129829: IN
129830: PUSH
129831: LD_VAR 0 13
129835: PPUSH
129836: LD_VAR 0 22
129840: PPUSH
129841: CALL_OW 308
129845: AND
129846: IFFALSE 129863
// ComExitVehicle ( group [ i ] ) ;
129848: LD_VAR 0 4
129852: PUSH
129853: LD_VAR 0 7
129857: ARRAY
129858: PPUSH
129859: CALL_OW 121
// end else
129863: GO 130042
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129865: LD_ADDR_VAR 0 13
129869: PUSH
129870: LD_VAR 0 4
129874: PPUSH
129875: LD_INT 95
129877: PUSH
129878: LD_VAR 0 22
129882: PUSH
129883: EMPTY
129884: LIST
129885: LIST
129886: PUSH
129887: LD_INT 58
129889: PUSH
129890: EMPTY
129891: LIST
129892: PUSH
129893: EMPTY
129894: LIST
129895: LIST
129896: PPUSH
129897: CALL_OW 72
129901: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129902: LD_VAR 0 4
129906: PUSH
129907: LD_VAR 0 7
129911: ARRAY
129912: PPUSH
129913: CALL_OW 314
129917: NOT
129918: IFFALSE 130040
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129920: LD_ADDR_VAR 0 10
129924: PUSH
129925: LD_VAR 0 13
129929: PPUSH
129930: LD_VAR 0 4
129934: PUSH
129935: LD_VAR 0 7
129939: ARRAY
129940: PPUSH
129941: CALL_OW 74
129945: ST_TO_ADDR
// if not x then
129946: LD_VAR 0 10
129950: NOT
129951: IFFALSE 129955
// continue ;
129953: GO 129387
// if GetLives ( x ) < 1000 then
129955: LD_VAR 0 10
129959: PPUSH
129960: CALL_OW 256
129964: PUSH
129965: LD_INT 1000
129967: LESS
129968: IFFALSE 129992
// ComRepairVehicle ( group [ i ] , x ) else
129970: LD_VAR 0 4
129974: PUSH
129975: LD_VAR 0 7
129979: ARRAY
129980: PPUSH
129981: LD_VAR 0 10
129985: PPUSH
129986: CALL_OW 129
129990: GO 130040
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129992: LD_VAR 0 23
129996: PUSH
129997: LD_VAR 0 4
130001: PUSH
130002: LD_VAR 0 7
130006: ARRAY
130007: PPUSH
130008: CALL_OW 256
130012: PUSH
130013: LD_INT 1000
130015: LESS
130016: AND
130017: NOT
130018: IFFALSE 130040
// ComEnterUnit ( group [ i ] , x ) ;
130020: LD_VAR 0 4
130024: PUSH
130025: LD_VAR 0 7
130029: ARRAY
130030: PPUSH
130031: LD_VAR 0 10
130035: PPUSH
130036: CALL_OW 120
// end ; continue ;
130040: GO 129387
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
130042: LD_VAR 0 23
130046: PUSH
130047: LD_VAR 0 4
130051: PUSH
130052: LD_VAR 0 7
130056: ARRAY
130057: PPUSH
130058: CALL_OW 247
130062: PUSH
130063: LD_INT 1
130065: EQUAL
130066: AND
130067: IFFALSE 130545
// begin if group [ i ] in healers then
130069: LD_VAR 0 4
130073: PUSH
130074: LD_VAR 0 7
130078: ARRAY
130079: PUSH
130080: LD_VAR 0 31
130084: IN
130085: IFFALSE 130358
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
130087: LD_VAR 0 4
130091: PUSH
130092: LD_VAR 0 7
130096: ARRAY
130097: PPUSH
130098: LD_VAR 0 23
130102: PPUSH
130103: CALL_OW 308
130107: NOT
130108: PUSH
130109: LD_VAR 0 4
130113: PUSH
130114: LD_VAR 0 7
130118: ARRAY
130119: PPUSH
130120: CALL_OW 314
130124: NOT
130125: AND
130126: IFFALSE 130150
// ComMoveToArea ( group [ i ] , f_heal ) else
130128: LD_VAR 0 4
130132: PUSH
130133: LD_VAR 0 7
130137: ARRAY
130138: PPUSH
130139: LD_VAR 0 23
130143: PPUSH
130144: CALL_OW 113
130148: GO 130356
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
130150: LD_VAR 0 4
130154: PUSH
130155: LD_VAR 0 7
130159: ARRAY
130160: PPUSH
130161: CALL 102344 0 1
130165: PPUSH
130166: CALL_OW 256
130170: PUSH
130171: LD_INT 1000
130173: EQUAL
130174: IFFALSE 130193
// ComStop ( group [ i ] ) else
130176: LD_VAR 0 4
130180: PUSH
130181: LD_VAR 0 7
130185: ARRAY
130186: PPUSH
130187: CALL_OW 141
130191: GO 130356
// if not HasTask ( group [ i ] ) and to_heal then
130193: LD_VAR 0 4
130197: PUSH
130198: LD_VAR 0 7
130202: ARRAY
130203: PPUSH
130204: CALL_OW 314
130208: NOT
130209: PUSH
130210: LD_VAR 0 30
130214: AND
130215: IFFALSE 130356
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130217: LD_ADDR_VAR 0 13
130221: PUSH
130222: LD_VAR 0 30
130226: PPUSH
130227: LD_INT 3
130229: PUSH
130230: LD_INT 54
130232: PUSH
130233: EMPTY
130234: LIST
130235: PUSH
130236: EMPTY
130237: LIST
130238: LIST
130239: PPUSH
130240: CALL_OW 72
130244: PPUSH
130245: LD_VAR 0 4
130249: PUSH
130250: LD_VAR 0 7
130254: ARRAY
130255: PPUSH
130256: CALL_OW 74
130260: ST_TO_ADDR
// if z then
130261: LD_VAR 0 13
130265: IFFALSE 130356
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130267: LD_INT 91
130269: PUSH
130270: LD_VAR 0 13
130274: PUSH
130275: LD_INT 10
130277: PUSH
130278: EMPTY
130279: LIST
130280: LIST
130281: LIST
130282: PUSH
130283: LD_INT 81
130285: PUSH
130286: LD_VAR 0 13
130290: PPUSH
130291: CALL_OW 255
130295: PUSH
130296: EMPTY
130297: LIST
130298: LIST
130299: PUSH
130300: EMPTY
130301: LIST
130302: LIST
130303: PPUSH
130304: CALL_OW 69
130308: PUSH
130309: LD_INT 0
130311: EQUAL
130312: IFFALSE 130336
// ComHeal ( group [ i ] , z ) else
130314: LD_VAR 0 4
130318: PUSH
130319: LD_VAR 0 7
130323: ARRAY
130324: PPUSH
130325: LD_VAR 0 13
130329: PPUSH
130330: CALL_OW 128
130334: GO 130356
// ComMoveToArea ( group [ i ] , f_heal ) ;
130336: LD_VAR 0 4
130340: PUSH
130341: LD_VAR 0 7
130345: ARRAY
130346: PPUSH
130347: LD_VAR 0 23
130351: PPUSH
130352: CALL_OW 113
// end ; continue ;
130356: GO 129387
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130358: LD_VAR 0 4
130362: PUSH
130363: LD_VAR 0 7
130367: ARRAY
130368: PPUSH
130369: CALL_OW 256
130373: PUSH
130374: LD_INT 700
130376: LESS
130377: PUSH
130378: LD_VAR 0 4
130382: PUSH
130383: LD_VAR 0 7
130387: ARRAY
130388: PUSH
130389: LD_VAR 0 30
130393: IN
130394: NOT
130395: AND
130396: IFFALSE 130420
// to_heal := to_heal union group [ i ] ;
130398: LD_ADDR_VAR 0 30
130402: PUSH
130403: LD_VAR 0 30
130407: PUSH
130408: LD_VAR 0 4
130412: PUSH
130413: LD_VAR 0 7
130417: ARRAY
130418: UNION
130419: ST_TO_ADDR
// if group [ i ] in to_heal then
130420: LD_VAR 0 4
130424: PUSH
130425: LD_VAR 0 7
130429: ARRAY
130430: PUSH
130431: LD_VAR 0 30
130435: IN
130436: IFFALSE 130545
// begin if GetLives ( group [ i ] ) = 1000 then
130438: LD_VAR 0 4
130442: PUSH
130443: LD_VAR 0 7
130447: ARRAY
130448: PPUSH
130449: CALL_OW 256
130453: PUSH
130454: LD_INT 1000
130456: EQUAL
130457: IFFALSE 130483
// to_heal := to_heal diff group [ i ] else
130459: LD_ADDR_VAR 0 30
130463: PUSH
130464: LD_VAR 0 30
130468: PUSH
130469: LD_VAR 0 4
130473: PUSH
130474: LD_VAR 0 7
130478: ARRAY
130479: DIFF
130480: ST_TO_ADDR
130481: GO 130545
// begin if not IsInArea ( group [ i ] , to_heal ) then
130483: LD_VAR 0 4
130487: PUSH
130488: LD_VAR 0 7
130492: ARRAY
130493: PPUSH
130494: LD_VAR 0 30
130498: PPUSH
130499: CALL_OW 308
130503: NOT
130504: IFFALSE 130528
// ComMoveToArea ( group [ i ] , f_heal ) else
130506: LD_VAR 0 4
130510: PUSH
130511: LD_VAR 0 7
130515: ARRAY
130516: PPUSH
130517: LD_VAR 0 23
130521: PPUSH
130522: CALL_OW 113
130526: GO 130543
// ComHold ( group [ i ] ) ;
130528: LD_VAR 0 4
130532: PUSH
130533: LD_VAR 0 7
130537: ARRAY
130538: PPUSH
130539: CALL_OW 140
// continue ;
130543: GO 129387
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130545: LD_VAR 0 4
130549: PUSH
130550: LD_VAR 0 7
130554: ARRAY
130555: PPUSH
130556: LD_INT 10
130558: PPUSH
130559: CALL 100141 0 2
130563: NOT
130564: PUSH
130565: LD_VAR 0 16
130569: PUSH
130570: LD_VAR 0 7
130574: ARRAY
130575: PUSH
130576: EMPTY
130577: EQUAL
130578: NOT
130579: AND
130580: IFFALSE 130846
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130582: LD_VAR 0 4
130586: PUSH
130587: LD_VAR 0 7
130591: ARRAY
130592: PPUSH
130593: CALL_OW 262
130597: PUSH
130598: LD_INT 1
130600: PUSH
130601: LD_INT 2
130603: PUSH
130604: EMPTY
130605: LIST
130606: LIST
130607: IN
130608: IFFALSE 130649
// if GetFuel ( group [ i ] ) < 10 then
130610: LD_VAR 0 4
130614: PUSH
130615: LD_VAR 0 7
130619: ARRAY
130620: PPUSH
130621: CALL_OW 261
130625: PUSH
130626: LD_INT 10
130628: LESS
130629: IFFALSE 130649
// SetFuel ( group [ i ] , 12 ) ;
130631: LD_VAR 0 4
130635: PUSH
130636: LD_VAR 0 7
130640: ARRAY
130641: PPUSH
130642: LD_INT 12
130644: PPUSH
130645: CALL_OW 240
// if units_path [ i ] then
130649: LD_VAR 0 16
130653: PUSH
130654: LD_VAR 0 7
130658: ARRAY
130659: IFFALSE 130844
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130661: LD_VAR 0 4
130665: PUSH
130666: LD_VAR 0 7
130670: ARRAY
130671: PPUSH
130672: LD_VAR 0 16
130676: PUSH
130677: LD_VAR 0 7
130681: ARRAY
130682: PUSH
130683: LD_INT 1
130685: ARRAY
130686: PUSH
130687: LD_INT 1
130689: ARRAY
130690: PPUSH
130691: LD_VAR 0 16
130695: PUSH
130696: LD_VAR 0 7
130700: ARRAY
130701: PUSH
130702: LD_INT 1
130704: ARRAY
130705: PUSH
130706: LD_INT 2
130708: ARRAY
130709: PPUSH
130710: CALL_OW 297
130714: PUSH
130715: LD_INT 6
130717: GREATER
130718: IFFALSE 130793
// begin if not HasTask ( group [ i ] ) then
130720: LD_VAR 0 4
130724: PUSH
130725: LD_VAR 0 7
130729: ARRAY
130730: PPUSH
130731: CALL_OW 314
130735: NOT
130736: IFFALSE 130791
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130738: LD_VAR 0 4
130742: PUSH
130743: LD_VAR 0 7
130747: ARRAY
130748: PPUSH
130749: LD_VAR 0 16
130753: PUSH
130754: LD_VAR 0 7
130758: ARRAY
130759: PUSH
130760: LD_INT 1
130762: ARRAY
130763: PUSH
130764: LD_INT 1
130766: ARRAY
130767: PPUSH
130768: LD_VAR 0 16
130772: PUSH
130773: LD_VAR 0 7
130777: ARRAY
130778: PUSH
130779: LD_INT 1
130781: ARRAY
130782: PUSH
130783: LD_INT 2
130785: ARRAY
130786: PPUSH
130787: CALL_OW 114
// end else
130791: GO 130844
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130793: LD_ADDR_VAR 0 15
130797: PUSH
130798: LD_VAR 0 16
130802: PUSH
130803: LD_VAR 0 7
130807: ARRAY
130808: PPUSH
130809: LD_INT 1
130811: PPUSH
130812: CALL_OW 3
130816: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130817: LD_ADDR_VAR 0 16
130821: PUSH
130822: LD_VAR 0 16
130826: PPUSH
130827: LD_VAR 0 7
130831: PPUSH
130832: LD_VAR 0 15
130836: PPUSH
130837: CALL_OW 1
130841: ST_TO_ADDR
// continue ;
130842: GO 129387
// end ; end ; end else
130844: GO 133508
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130846: LD_ADDR_VAR 0 14
130850: PUSH
130851: LD_INT 81
130853: PUSH
130854: LD_VAR 0 4
130858: PUSH
130859: LD_VAR 0 7
130863: ARRAY
130864: PPUSH
130865: CALL_OW 255
130869: PUSH
130870: EMPTY
130871: LIST
130872: LIST
130873: PPUSH
130874: CALL_OW 69
130878: ST_TO_ADDR
// if not tmp then
130879: LD_VAR 0 14
130883: NOT
130884: IFFALSE 130888
// continue ;
130886: GO 129387
// if f_ignore_area then
130888: LD_VAR 0 17
130892: IFFALSE 130980
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130894: LD_ADDR_VAR 0 15
130898: PUSH
130899: LD_VAR 0 14
130903: PPUSH
130904: LD_INT 3
130906: PUSH
130907: LD_INT 92
130909: PUSH
130910: LD_VAR 0 17
130914: PUSH
130915: LD_INT 1
130917: ARRAY
130918: PUSH
130919: LD_VAR 0 17
130923: PUSH
130924: LD_INT 2
130926: ARRAY
130927: PUSH
130928: LD_VAR 0 17
130932: PUSH
130933: LD_INT 3
130935: ARRAY
130936: PUSH
130937: EMPTY
130938: LIST
130939: LIST
130940: LIST
130941: LIST
130942: PUSH
130943: EMPTY
130944: LIST
130945: LIST
130946: PPUSH
130947: CALL_OW 72
130951: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130952: LD_VAR 0 14
130956: PUSH
130957: LD_VAR 0 15
130961: DIFF
130962: IFFALSE 130980
// tmp := tmp diff tmp2 ;
130964: LD_ADDR_VAR 0 14
130968: PUSH
130969: LD_VAR 0 14
130973: PUSH
130974: LD_VAR 0 15
130978: DIFF
130979: ST_TO_ADDR
// end ; if not f_murder then
130980: LD_VAR 0 20
130984: NOT
130985: IFFALSE 131043
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130987: LD_ADDR_VAR 0 15
130991: PUSH
130992: LD_VAR 0 14
130996: PPUSH
130997: LD_INT 3
130999: PUSH
131000: LD_INT 50
131002: PUSH
131003: EMPTY
131004: LIST
131005: PUSH
131006: EMPTY
131007: LIST
131008: LIST
131009: PPUSH
131010: CALL_OW 72
131014: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131015: LD_VAR 0 14
131019: PUSH
131020: LD_VAR 0 15
131024: DIFF
131025: IFFALSE 131043
// tmp := tmp diff tmp2 ;
131027: LD_ADDR_VAR 0 14
131031: PUSH
131032: LD_VAR 0 14
131036: PUSH
131037: LD_VAR 0 15
131041: DIFF
131042: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
131043: LD_ADDR_VAR 0 14
131047: PUSH
131048: LD_VAR 0 4
131052: PUSH
131053: LD_VAR 0 7
131057: ARRAY
131058: PPUSH
131059: LD_VAR 0 14
131063: PPUSH
131064: LD_INT 1
131066: PPUSH
131067: LD_INT 1
131069: PPUSH
131070: CALL 73082 0 4
131074: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
131075: LD_VAR 0 4
131079: PUSH
131080: LD_VAR 0 7
131084: ARRAY
131085: PPUSH
131086: CALL_OW 257
131090: PUSH
131091: LD_INT 1
131093: EQUAL
131094: IFFALSE 131542
// begin if WantPlant ( group [ i ] ) then
131096: LD_VAR 0 4
131100: PUSH
131101: LD_VAR 0 7
131105: ARRAY
131106: PPUSH
131107: CALL 72583 0 1
131111: IFFALSE 131115
// continue ;
131113: GO 129387
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
131115: LD_VAR 0 18
131119: PUSH
131120: LD_VAR 0 4
131124: PUSH
131125: LD_VAR 0 7
131129: ARRAY
131130: PPUSH
131131: CALL_OW 310
131135: NOT
131136: AND
131137: PUSH
131138: LD_VAR 0 14
131142: PUSH
131143: LD_INT 1
131145: ARRAY
131146: PUSH
131147: LD_VAR 0 14
131151: PPUSH
131152: LD_INT 21
131154: PUSH
131155: LD_INT 2
131157: PUSH
131158: EMPTY
131159: LIST
131160: LIST
131161: PUSH
131162: LD_INT 58
131164: PUSH
131165: EMPTY
131166: LIST
131167: PUSH
131168: EMPTY
131169: LIST
131170: LIST
131171: PPUSH
131172: CALL_OW 72
131176: IN
131177: AND
131178: IFFALSE 131214
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
131180: LD_VAR 0 4
131184: PUSH
131185: LD_VAR 0 7
131189: ARRAY
131190: PPUSH
131191: LD_VAR 0 14
131195: PUSH
131196: LD_INT 1
131198: ARRAY
131199: PPUSH
131200: CALL_OW 120
// attacking := true ;
131204: LD_ADDR_VAR 0 29
131208: PUSH
131209: LD_INT 1
131211: ST_TO_ADDR
// continue ;
131212: GO 129387
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131214: LD_VAR 0 26
131218: PUSH
131219: LD_VAR 0 4
131223: PUSH
131224: LD_VAR 0 7
131228: ARRAY
131229: PPUSH
131230: CALL_OW 257
131234: PUSH
131235: LD_INT 1
131237: EQUAL
131238: AND
131239: PUSH
131240: LD_VAR 0 4
131244: PUSH
131245: LD_VAR 0 7
131249: ARRAY
131250: PPUSH
131251: CALL_OW 256
131255: PUSH
131256: LD_INT 800
131258: LESS
131259: AND
131260: PUSH
131261: LD_VAR 0 4
131265: PUSH
131266: LD_VAR 0 7
131270: ARRAY
131271: PPUSH
131272: CALL_OW 318
131276: NOT
131277: AND
131278: IFFALSE 131295
// ComCrawl ( group [ i ] ) ;
131280: LD_VAR 0 4
131284: PUSH
131285: LD_VAR 0 7
131289: ARRAY
131290: PPUSH
131291: CALL_OW 137
// if f_mines then
131295: LD_VAR 0 21
131299: IFFALSE 131542
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131301: LD_VAR 0 14
131305: PUSH
131306: LD_INT 1
131308: ARRAY
131309: PPUSH
131310: CALL_OW 247
131314: PUSH
131315: LD_INT 3
131317: EQUAL
131318: PUSH
131319: LD_VAR 0 14
131323: PUSH
131324: LD_INT 1
131326: ARRAY
131327: PUSH
131328: LD_VAR 0 27
131332: IN
131333: NOT
131334: AND
131335: IFFALSE 131542
// begin x := GetX ( tmp [ 1 ] ) ;
131337: LD_ADDR_VAR 0 10
131341: PUSH
131342: LD_VAR 0 14
131346: PUSH
131347: LD_INT 1
131349: ARRAY
131350: PPUSH
131351: CALL_OW 250
131355: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131356: LD_ADDR_VAR 0 11
131360: PUSH
131361: LD_VAR 0 14
131365: PUSH
131366: LD_INT 1
131368: ARRAY
131369: PPUSH
131370: CALL_OW 251
131374: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131375: LD_ADDR_VAR 0 12
131379: PUSH
131380: LD_VAR 0 4
131384: PUSH
131385: LD_VAR 0 7
131389: ARRAY
131390: PPUSH
131391: CALL 100226 0 1
131395: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131396: LD_VAR 0 4
131400: PUSH
131401: LD_VAR 0 7
131405: ARRAY
131406: PPUSH
131407: LD_VAR 0 10
131411: PPUSH
131412: LD_VAR 0 11
131416: PPUSH
131417: LD_VAR 0 14
131421: PUSH
131422: LD_INT 1
131424: ARRAY
131425: PPUSH
131426: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131430: LD_VAR 0 4
131434: PUSH
131435: LD_VAR 0 7
131439: ARRAY
131440: PPUSH
131441: LD_VAR 0 10
131445: PPUSH
131446: LD_VAR 0 12
131450: PPUSH
131451: LD_INT 7
131453: PPUSH
131454: CALL_OW 272
131458: PPUSH
131459: LD_VAR 0 11
131463: PPUSH
131464: LD_VAR 0 12
131468: PPUSH
131469: LD_INT 7
131471: PPUSH
131472: CALL_OW 273
131476: PPUSH
131477: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131481: LD_VAR 0 4
131485: PUSH
131486: LD_VAR 0 7
131490: ARRAY
131491: PPUSH
131492: LD_INT 71
131494: PPUSH
131495: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131499: LD_ADDR_VAR 0 27
131503: PUSH
131504: LD_VAR 0 27
131508: PPUSH
131509: LD_VAR 0 27
131513: PUSH
131514: LD_INT 1
131516: PLUS
131517: PPUSH
131518: LD_VAR 0 14
131522: PUSH
131523: LD_INT 1
131525: ARRAY
131526: PPUSH
131527: CALL_OW 1
131531: ST_TO_ADDR
// attacking := true ;
131532: LD_ADDR_VAR 0 29
131536: PUSH
131537: LD_INT 1
131539: ST_TO_ADDR
// continue ;
131540: GO 129387
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131542: LD_VAR 0 4
131546: PUSH
131547: LD_VAR 0 7
131551: ARRAY
131552: PPUSH
131553: CALL_OW 257
131557: PUSH
131558: LD_INT 17
131560: EQUAL
131561: PUSH
131562: LD_VAR 0 4
131566: PUSH
131567: LD_VAR 0 7
131571: ARRAY
131572: PPUSH
131573: CALL_OW 110
131577: PUSH
131578: LD_INT 71
131580: EQUAL
131581: NOT
131582: AND
131583: IFFALSE 131729
// begin attacking := false ;
131585: LD_ADDR_VAR 0 29
131589: PUSH
131590: LD_INT 0
131592: ST_TO_ADDR
// k := 5 ;
131593: LD_ADDR_VAR 0 9
131597: PUSH
131598: LD_INT 5
131600: ST_TO_ADDR
// if tmp < k then
131601: LD_VAR 0 14
131605: PUSH
131606: LD_VAR 0 9
131610: LESS
131611: IFFALSE 131623
// k := tmp ;
131613: LD_ADDR_VAR 0 9
131617: PUSH
131618: LD_VAR 0 14
131622: ST_TO_ADDR
// for j = 1 to k do
131623: LD_ADDR_VAR 0 8
131627: PUSH
131628: DOUBLE
131629: LD_INT 1
131631: DEC
131632: ST_TO_ADDR
131633: LD_VAR 0 9
131637: PUSH
131638: FOR_TO
131639: IFFALSE 131727
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131641: LD_VAR 0 14
131645: PUSH
131646: LD_VAR 0 8
131650: ARRAY
131651: PUSH
131652: LD_VAR 0 14
131656: PPUSH
131657: LD_INT 58
131659: PUSH
131660: EMPTY
131661: LIST
131662: PPUSH
131663: CALL_OW 72
131667: IN
131668: NOT
131669: IFFALSE 131725
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131671: LD_VAR 0 4
131675: PUSH
131676: LD_VAR 0 7
131680: ARRAY
131681: PPUSH
131682: LD_VAR 0 14
131686: PUSH
131687: LD_VAR 0 8
131691: ARRAY
131692: PPUSH
131693: CALL_OW 115
// attacking := true ;
131697: LD_ADDR_VAR 0 29
131701: PUSH
131702: LD_INT 1
131704: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131705: LD_VAR 0 4
131709: PUSH
131710: LD_VAR 0 7
131714: ARRAY
131715: PPUSH
131716: LD_INT 71
131718: PPUSH
131719: CALL_OW 109
// continue ;
131723: GO 131638
// end ; end ;
131725: GO 131638
131727: POP
131728: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131729: LD_VAR 0 4
131733: PUSH
131734: LD_VAR 0 7
131738: ARRAY
131739: PPUSH
131740: CALL_OW 257
131744: PUSH
131745: LD_INT 8
131747: EQUAL
131748: PUSH
131749: LD_VAR 0 4
131753: PUSH
131754: LD_VAR 0 7
131758: ARRAY
131759: PPUSH
131760: CALL_OW 264
131764: PUSH
131765: LD_INT 28
131767: PUSH
131768: LD_INT 45
131770: PUSH
131771: LD_INT 7
131773: PUSH
131774: LD_INT 47
131776: PUSH
131777: EMPTY
131778: LIST
131779: LIST
131780: LIST
131781: LIST
131782: IN
131783: OR
131784: IFFALSE 132040
// begin attacking := false ;
131786: LD_ADDR_VAR 0 29
131790: PUSH
131791: LD_INT 0
131793: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131794: LD_VAR 0 14
131798: PUSH
131799: LD_INT 1
131801: ARRAY
131802: PPUSH
131803: CALL_OW 266
131807: PUSH
131808: LD_INT 32
131810: PUSH
131811: LD_INT 31
131813: PUSH
131814: LD_INT 33
131816: PUSH
131817: LD_INT 4
131819: PUSH
131820: LD_INT 5
131822: PUSH
131823: EMPTY
131824: LIST
131825: LIST
131826: LIST
131827: LIST
131828: LIST
131829: IN
131830: IFFALSE 132016
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131832: LD_ADDR_VAR 0 9
131836: PUSH
131837: LD_VAR 0 14
131841: PUSH
131842: LD_INT 1
131844: ARRAY
131845: PPUSH
131846: CALL_OW 266
131850: PPUSH
131851: LD_VAR 0 14
131855: PUSH
131856: LD_INT 1
131858: ARRAY
131859: PPUSH
131860: CALL_OW 250
131864: PPUSH
131865: LD_VAR 0 14
131869: PUSH
131870: LD_INT 1
131872: ARRAY
131873: PPUSH
131874: CALL_OW 251
131878: PPUSH
131879: LD_VAR 0 14
131883: PUSH
131884: LD_INT 1
131886: ARRAY
131887: PPUSH
131888: CALL_OW 254
131892: PPUSH
131893: LD_VAR 0 14
131897: PUSH
131898: LD_INT 1
131900: ARRAY
131901: PPUSH
131902: CALL_OW 248
131906: PPUSH
131907: LD_INT 0
131909: PPUSH
131910: CALL 81596 0 6
131914: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131915: LD_ADDR_VAR 0 8
131919: PUSH
131920: LD_VAR 0 4
131924: PUSH
131925: LD_VAR 0 7
131929: ARRAY
131930: PPUSH
131931: LD_VAR 0 9
131935: PPUSH
131936: CALL 100339 0 2
131940: ST_TO_ADDR
// if j then
131941: LD_VAR 0 8
131945: IFFALSE 132014
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131947: LD_VAR 0 8
131951: PUSH
131952: LD_INT 1
131954: ARRAY
131955: PPUSH
131956: LD_VAR 0 8
131960: PUSH
131961: LD_INT 2
131963: ARRAY
131964: PPUSH
131965: CALL_OW 488
131969: IFFALSE 132014
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131971: LD_VAR 0 4
131975: PUSH
131976: LD_VAR 0 7
131980: ARRAY
131981: PPUSH
131982: LD_VAR 0 8
131986: PUSH
131987: LD_INT 1
131989: ARRAY
131990: PPUSH
131991: LD_VAR 0 8
131995: PUSH
131996: LD_INT 2
131998: ARRAY
131999: PPUSH
132000: CALL_OW 116
// attacking := true ;
132004: LD_ADDR_VAR 0 29
132008: PUSH
132009: LD_INT 1
132011: ST_TO_ADDR
// continue ;
132012: GO 129387
// end ; end else
132014: GO 132040
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132016: LD_VAR 0 4
132020: PUSH
132021: LD_VAR 0 7
132025: ARRAY
132026: PPUSH
132027: LD_VAR 0 14
132031: PUSH
132032: LD_INT 1
132034: ARRAY
132035: PPUSH
132036: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
132040: LD_VAR 0 4
132044: PUSH
132045: LD_VAR 0 7
132049: ARRAY
132050: PPUSH
132051: CALL_OW 265
132055: PUSH
132056: LD_INT 11
132058: EQUAL
132059: IFFALSE 132337
// begin k := 10 ;
132061: LD_ADDR_VAR 0 9
132065: PUSH
132066: LD_INT 10
132068: ST_TO_ADDR
// x := 0 ;
132069: LD_ADDR_VAR 0 10
132073: PUSH
132074: LD_INT 0
132076: ST_TO_ADDR
// if tmp < k then
132077: LD_VAR 0 14
132081: PUSH
132082: LD_VAR 0 9
132086: LESS
132087: IFFALSE 132099
// k := tmp ;
132089: LD_ADDR_VAR 0 9
132093: PUSH
132094: LD_VAR 0 14
132098: ST_TO_ADDR
// for j = k downto 1 do
132099: LD_ADDR_VAR 0 8
132103: PUSH
132104: DOUBLE
132105: LD_VAR 0 9
132109: INC
132110: ST_TO_ADDR
132111: LD_INT 1
132113: PUSH
132114: FOR_DOWNTO
132115: IFFALSE 132190
// begin if GetType ( tmp [ j ] ) = unit_human then
132117: LD_VAR 0 14
132121: PUSH
132122: LD_VAR 0 8
132126: ARRAY
132127: PPUSH
132128: CALL_OW 247
132132: PUSH
132133: LD_INT 1
132135: EQUAL
132136: IFFALSE 132188
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
132138: LD_VAR 0 4
132142: PUSH
132143: LD_VAR 0 7
132147: ARRAY
132148: PPUSH
132149: LD_VAR 0 14
132153: PUSH
132154: LD_VAR 0 8
132158: ARRAY
132159: PPUSH
132160: CALL 100593 0 2
// x := tmp [ j ] ;
132164: LD_ADDR_VAR 0 10
132168: PUSH
132169: LD_VAR 0 14
132173: PUSH
132174: LD_VAR 0 8
132178: ARRAY
132179: ST_TO_ADDR
// attacking := true ;
132180: LD_ADDR_VAR 0 29
132184: PUSH
132185: LD_INT 1
132187: ST_TO_ADDR
// end ; end ;
132188: GO 132114
132190: POP
132191: POP
// if not x then
132192: LD_VAR 0 10
132196: NOT
132197: IFFALSE 132337
// begin attacking := true ;
132199: LD_ADDR_VAR 0 29
132203: PUSH
132204: LD_INT 1
132206: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
132207: LD_VAR 0 4
132211: PUSH
132212: LD_VAR 0 7
132216: ARRAY
132217: PPUSH
132218: CALL_OW 250
132222: PPUSH
132223: LD_VAR 0 4
132227: PUSH
132228: LD_VAR 0 7
132232: ARRAY
132233: PPUSH
132234: CALL_OW 251
132238: PPUSH
132239: CALL_OW 546
132243: PUSH
132244: LD_INT 2
132246: ARRAY
132247: PUSH
132248: LD_VAR 0 14
132252: PUSH
132253: LD_INT 1
132255: ARRAY
132256: PPUSH
132257: CALL_OW 250
132261: PPUSH
132262: LD_VAR 0 14
132266: PUSH
132267: LD_INT 1
132269: ARRAY
132270: PPUSH
132271: CALL_OW 251
132275: PPUSH
132276: CALL_OW 546
132280: PUSH
132281: LD_INT 2
132283: ARRAY
132284: EQUAL
132285: IFFALSE 132313
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132287: LD_VAR 0 4
132291: PUSH
132292: LD_VAR 0 7
132296: ARRAY
132297: PPUSH
132298: LD_VAR 0 14
132302: PUSH
132303: LD_INT 1
132305: ARRAY
132306: PPUSH
132307: CALL 100593 0 2
132311: GO 132337
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132313: LD_VAR 0 4
132317: PUSH
132318: LD_VAR 0 7
132322: ARRAY
132323: PPUSH
132324: LD_VAR 0 14
132328: PUSH
132329: LD_INT 1
132331: ARRAY
132332: PPUSH
132333: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132337: LD_VAR 0 4
132341: PUSH
132342: LD_VAR 0 7
132346: ARRAY
132347: PPUSH
132348: CALL_OW 264
132352: PUSH
132353: LD_INT 29
132355: EQUAL
132356: IFFALSE 132722
// begin if WantsToAttack ( group [ i ] ) in bombed then
132358: LD_VAR 0 4
132362: PUSH
132363: LD_VAR 0 7
132367: ARRAY
132368: PPUSH
132369: CALL_OW 319
132373: PUSH
132374: LD_VAR 0 28
132378: IN
132379: IFFALSE 132383
// continue ;
132381: GO 129387
// k := 8 ;
132383: LD_ADDR_VAR 0 9
132387: PUSH
132388: LD_INT 8
132390: ST_TO_ADDR
// x := 0 ;
132391: LD_ADDR_VAR 0 10
132395: PUSH
132396: LD_INT 0
132398: ST_TO_ADDR
// if tmp < k then
132399: LD_VAR 0 14
132403: PUSH
132404: LD_VAR 0 9
132408: LESS
132409: IFFALSE 132421
// k := tmp ;
132411: LD_ADDR_VAR 0 9
132415: PUSH
132416: LD_VAR 0 14
132420: ST_TO_ADDR
// for j = 1 to k do
132421: LD_ADDR_VAR 0 8
132425: PUSH
132426: DOUBLE
132427: LD_INT 1
132429: DEC
132430: ST_TO_ADDR
132431: LD_VAR 0 9
132435: PUSH
132436: FOR_TO
132437: IFFALSE 132569
// begin if GetType ( tmp [ j ] ) = unit_building then
132439: LD_VAR 0 14
132443: PUSH
132444: LD_VAR 0 8
132448: ARRAY
132449: PPUSH
132450: CALL_OW 247
132454: PUSH
132455: LD_INT 3
132457: EQUAL
132458: IFFALSE 132567
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132460: LD_VAR 0 14
132464: PUSH
132465: LD_VAR 0 8
132469: ARRAY
132470: PUSH
132471: LD_VAR 0 28
132475: IN
132476: NOT
132477: PUSH
132478: LD_VAR 0 14
132482: PUSH
132483: LD_VAR 0 8
132487: ARRAY
132488: PPUSH
132489: CALL_OW 313
132493: AND
132494: IFFALSE 132567
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132496: LD_VAR 0 4
132500: PUSH
132501: LD_VAR 0 7
132505: ARRAY
132506: PPUSH
132507: LD_VAR 0 14
132511: PUSH
132512: LD_VAR 0 8
132516: ARRAY
132517: PPUSH
132518: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132522: LD_ADDR_VAR 0 28
132526: PUSH
132527: LD_VAR 0 28
132531: PPUSH
132532: LD_VAR 0 28
132536: PUSH
132537: LD_INT 1
132539: PLUS
132540: PPUSH
132541: LD_VAR 0 14
132545: PUSH
132546: LD_VAR 0 8
132550: ARRAY
132551: PPUSH
132552: CALL_OW 1
132556: ST_TO_ADDR
// attacking := true ;
132557: LD_ADDR_VAR 0 29
132561: PUSH
132562: LD_INT 1
132564: ST_TO_ADDR
// break ;
132565: GO 132569
// end ; end ;
132567: GO 132436
132569: POP
132570: POP
// if not attacking and f_attack_depot then
132571: LD_VAR 0 29
132575: NOT
132576: PUSH
132577: LD_VAR 0 25
132581: AND
132582: IFFALSE 132677
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132584: LD_ADDR_VAR 0 13
132588: PUSH
132589: LD_VAR 0 14
132593: PPUSH
132594: LD_INT 2
132596: PUSH
132597: LD_INT 30
132599: PUSH
132600: LD_INT 0
132602: PUSH
132603: EMPTY
132604: LIST
132605: LIST
132606: PUSH
132607: LD_INT 30
132609: PUSH
132610: LD_INT 1
132612: PUSH
132613: EMPTY
132614: LIST
132615: LIST
132616: PUSH
132617: EMPTY
132618: LIST
132619: LIST
132620: LIST
132621: PPUSH
132622: CALL_OW 72
132626: ST_TO_ADDR
// if z then
132627: LD_VAR 0 13
132631: IFFALSE 132677
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132633: LD_VAR 0 4
132637: PUSH
132638: LD_VAR 0 7
132642: ARRAY
132643: PPUSH
132644: LD_VAR 0 13
132648: PPUSH
132649: LD_VAR 0 4
132653: PUSH
132654: LD_VAR 0 7
132658: ARRAY
132659: PPUSH
132660: CALL_OW 74
132664: PPUSH
132665: CALL_OW 115
// attacking := true ;
132669: LD_ADDR_VAR 0 29
132673: PUSH
132674: LD_INT 1
132676: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132677: LD_VAR 0 4
132681: PUSH
132682: LD_VAR 0 7
132686: ARRAY
132687: PPUSH
132688: CALL_OW 256
132692: PUSH
132693: LD_INT 500
132695: LESS
132696: IFFALSE 132722
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132698: LD_VAR 0 4
132702: PUSH
132703: LD_VAR 0 7
132707: ARRAY
132708: PPUSH
132709: LD_VAR 0 14
132713: PUSH
132714: LD_INT 1
132716: ARRAY
132717: PPUSH
132718: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132722: LD_VAR 0 4
132726: PUSH
132727: LD_VAR 0 7
132731: ARRAY
132732: PPUSH
132733: CALL_OW 264
132737: PUSH
132738: LD_INT 49
132740: EQUAL
132741: IFFALSE 132862
// begin if not HasTask ( group [ i ] ) then
132743: LD_VAR 0 4
132747: PUSH
132748: LD_VAR 0 7
132752: ARRAY
132753: PPUSH
132754: CALL_OW 314
132758: NOT
132759: IFFALSE 132862
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132761: LD_ADDR_VAR 0 9
132765: PUSH
132766: LD_INT 81
132768: PUSH
132769: LD_VAR 0 4
132773: PUSH
132774: LD_VAR 0 7
132778: ARRAY
132779: PPUSH
132780: CALL_OW 255
132784: PUSH
132785: EMPTY
132786: LIST
132787: LIST
132788: PPUSH
132789: CALL_OW 69
132793: PPUSH
132794: LD_VAR 0 4
132798: PUSH
132799: LD_VAR 0 7
132803: ARRAY
132804: PPUSH
132805: CALL_OW 74
132809: ST_TO_ADDR
// if k then
132810: LD_VAR 0 9
132814: IFFALSE 132862
// if GetDistUnits ( group [ i ] , k ) > 10 then
132816: LD_VAR 0 4
132820: PUSH
132821: LD_VAR 0 7
132825: ARRAY
132826: PPUSH
132827: LD_VAR 0 9
132831: PPUSH
132832: CALL_OW 296
132836: PUSH
132837: LD_INT 10
132839: GREATER
132840: IFFALSE 132862
// ComMoveUnit ( group [ i ] , k ) ;
132842: LD_VAR 0 4
132846: PUSH
132847: LD_VAR 0 7
132851: ARRAY
132852: PPUSH
132853: LD_VAR 0 9
132857: PPUSH
132858: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132862: LD_VAR 0 4
132866: PUSH
132867: LD_VAR 0 7
132871: ARRAY
132872: PPUSH
132873: CALL_OW 256
132877: PUSH
132878: LD_INT 250
132880: LESS
132881: PUSH
132882: LD_VAR 0 4
132886: PUSH
132887: LD_VAR 0 7
132891: ARRAY
132892: PUSH
132893: LD_INT 21
132895: PUSH
132896: LD_INT 2
132898: PUSH
132899: EMPTY
132900: LIST
132901: LIST
132902: PUSH
132903: LD_INT 23
132905: PUSH
132906: LD_INT 2
132908: PUSH
132909: EMPTY
132910: LIST
132911: LIST
132912: PUSH
132913: EMPTY
132914: LIST
132915: LIST
132916: PPUSH
132917: CALL_OW 69
132921: IN
132922: AND
132923: IFFALSE 133048
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132925: LD_ADDR_VAR 0 9
132929: PUSH
132930: LD_OWVAR 3
132934: PUSH
132935: LD_VAR 0 4
132939: PUSH
132940: LD_VAR 0 7
132944: ARRAY
132945: DIFF
132946: PPUSH
132947: LD_VAR 0 4
132951: PUSH
132952: LD_VAR 0 7
132956: ARRAY
132957: PPUSH
132958: CALL_OW 74
132962: ST_TO_ADDR
// if not k then
132963: LD_VAR 0 9
132967: NOT
132968: IFFALSE 132972
// continue ;
132970: GO 129387
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132972: LD_VAR 0 9
132976: PUSH
132977: LD_INT 81
132979: PUSH
132980: LD_VAR 0 4
132984: PUSH
132985: LD_VAR 0 7
132989: ARRAY
132990: PPUSH
132991: CALL_OW 255
132995: PUSH
132996: EMPTY
132997: LIST
132998: LIST
132999: PPUSH
133000: CALL_OW 69
133004: IN
133005: PUSH
133006: LD_VAR 0 9
133010: PPUSH
133011: LD_VAR 0 4
133015: PUSH
133016: LD_VAR 0 7
133020: ARRAY
133021: PPUSH
133022: CALL_OW 296
133026: PUSH
133027: LD_INT 5
133029: LESS
133030: AND
133031: IFFALSE 133048
// ComAutodestruct ( group [ i ] ) ;
133033: LD_VAR 0 4
133037: PUSH
133038: LD_VAR 0 7
133042: ARRAY
133043: PPUSH
133044: CALL 100491 0 1
// end ; if f_attack_depot then
133048: LD_VAR 0 25
133052: IFFALSE 133164
// begin k := 6 ;
133054: LD_ADDR_VAR 0 9
133058: PUSH
133059: LD_INT 6
133061: ST_TO_ADDR
// if tmp < k then
133062: LD_VAR 0 14
133066: PUSH
133067: LD_VAR 0 9
133071: LESS
133072: IFFALSE 133084
// k := tmp ;
133074: LD_ADDR_VAR 0 9
133078: PUSH
133079: LD_VAR 0 14
133083: ST_TO_ADDR
// for j = 1 to k do
133084: LD_ADDR_VAR 0 8
133088: PUSH
133089: DOUBLE
133090: LD_INT 1
133092: DEC
133093: ST_TO_ADDR
133094: LD_VAR 0 9
133098: PUSH
133099: FOR_TO
133100: IFFALSE 133162
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
133102: LD_VAR 0 8
133106: PPUSH
133107: CALL_OW 266
133111: PUSH
133112: LD_INT 0
133114: PUSH
133115: LD_INT 1
133117: PUSH
133118: EMPTY
133119: LIST
133120: LIST
133121: IN
133122: IFFALSE 133160
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133124: LD_VAR 0 4
133128: PUSH
133129: LD_VAR 0 7
133133: ARRAY
133134: PPUSH
133135: LD_VAR 0 14
133139: PUSH
133140: LD_VAR 0 8
133144: ARRAY
133145: PPUSH
133146: CALL_OW 115
// attacking := true ;
133150: LD_ADDR_VAR 0 29
133154: PUSH
133155: LD_INT 1
133157: ST_TO_ADDR
// break ;
133158: GO 133162
// end ;
133160: GO 133099
133162: POP
133163: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
133164: LD_VAR 0 4
133168: PUSH
133169: LD_VAR 0 7
133173: ARRAY
133174: PPUSH
133175: CALL_OW 302
133179: PUSH
133180: LD_VAR 0 29
133184: NOT
133185: AND
133186: IFFALSE 133508
// begin if GetTag ( group [ i ] ) = 71 then
133188: LD_VAR 0 4
133192: PUSH
133193: LD_VAR 0 7
133197: ARRAY
133198: PPUSH
133199: CALL_OW 110
133203: PUSH
133204: LD_INT 71
133206: EQUAL
133207: IFFALSE 133248
// begin if HasTask ( group [ i ] ) then
133209: LD_VAR 0 4
133213: PUSH
133214: LD_VAR 0 7
133218: ARRAY
133219: PPUSH
133220: CALL_OW 314
133224: IFFALSE 133230
// continue else
133226: GO 129387
133228: GO 133248
// SetTag ( group [ i ] , 0 ) ;
133230: LD_VAR 0 4
133234: PUSH
133235: LD_VAR 0 7
133239: ARRAY
133240: PPUSH
133241: LD_INT 0
133243: PPUSH
133244: CALL_OW 109
// end ; k := 8 ;
133248: LD_ADDR_VAR 0 9
133252: PUSH
133253: LD_INT 8
133255: ST_TO_ADDR
// x := 0 ;
133256: LD_ADDR_VAR 0 10
133260: PUSH
133261: LD_INT 0
133263: ST_TO_ADDR
// if tmp < k then
133264: LD_VAR 0 14
133268: PUSH
133269: LD_VAR 0 9
133273: LESS
133274: IFFALSE 133286
// k := tmp ;
133276: LD_ADDR_VAR 0 9
133280: PUSH
133281: LD_VAR 0 14
133285: ST_TO_ADDR
// for j = 1 to k do
133286: LD_ADDR_VAR 0 8
133290: PUSH
133291: DOUBLE
133292: LD_INT 1
133294: DEC
133295: ST_TO_ADDR
133296: LD_VAR 0 9
133300: PUSH
133301: FOR_TO
133302: IFFALSE 133400
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133304: LD_VAR 0 14
133308: PUSH
133309: LD_VAR 0 8
133313: ARRAY
133314: PPUSH
133315: CALL_OW 247
133319: PUSH
133320: LD_INT 1
133322: EQUAL
133323: PUSH
133324: LD_VAR 0 14
133328: PUSH
133329: LD_VAR 0 8
133333: ARRAY
133334: PPUSH
133335: CALL_OW 256
133339: PUSH
133340: LD_INT 250
133342: LESS
133343: PUSH
133344: LD_VAR 0 20
133348: AND
133349: PUSH
133350: LD_VAR 0 20
133354: NOT
133355: PUSH
133356: LD_VAR 0 14
133360: PUSH
133361: LD_VAR 0 8
133365: ARRAY
133366: PPUSH
133367: CALL_OW 256
133371: PUSH
133372: LD_INT 250
133374: GREATEREQUAL
133375: AND
133376: OR
133377: AND
133378: IFFALSE 133398
// begin x := tmp [ j ] ;
133380: LD_ADDR_VAR 0 10
133384: PUSH
133385: LD_VAR 0 14
133389: PUSH
133390: LD_VAR 0 8
133394: ARRAY
133395: ST_TO_ADDR
// break ;
133396: GO 133400
// end ;
133398: GO 133301
133400: POP
133401: POP
// if x then
133402: LD_VAR 0 10
133406: IFFALSE 133430
// ComAttackUnit ( group [ i ] , x ) else
133408: LD_VAR 0 4
133412: PUSH
133413: LD_VAR 0 7
133417: ARRAY
133418: PPUSH
133419: LD_VAR 0 10
133423: PPUSH
133424: CALL_OW 115
133428: GO 133454
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133430: LD_VAR 0 4
133434: PUSH
133435: LD_VAR 0 7
133439: ARRAY
133440: PPUSH
133441: LD_VAR 0 14
133445: PUSH
133446: LD_INT 1
133448: ARRAY
133449: PPUSH
133450: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133454: LD_VAR 0 4
133458: PUSH
133459: LD_VAR 0 7
133463: ARRAY
133464: PPUSH
133465: CALL_OW 314
133469: NOT
133470: IFFALSE 133508
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133472: LD_VAR 0 4
133476: PUSH
133477: LD_VAR 0 7
133481: ARRAY
133482: PPUSH
133483: LD_VAR 0 14
133487: PPUSH
133488: LD_VAR 0 4
133492: PUSH
133493: LD_VAR 0 7
133497: ARRAY
133498: PPUSH
133499: CALL_OW 74
133503: PPUSH
133504: CALL_OW 115
// end ; end ; end ;
133508: GO 129387
133510: POP
133511: POP
// wait ( 0 0$2 ) ;
133512: LD_INT 70
133514: PPUSH
133515: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133519: LD_VAR 0 4
133523: NOT
133524: PUSH
133525: LD_VAR 0 4
133529: PUSH
133530: EMPTY
133531: EQUAL
133532: OR
133533: PUSH
133534: LD_INT 81
133536: PUSH
133537: LD_VAR 0 35
133541: PUSH
133542: EMPTY
133543: LIST
133544: LIST
133545: PPUSH
133546: CALL_OW 69
133550: NOT
133551: OR
133552: IFFALSE 129372
// end ;
133554: LD_VAR 0 2
133558: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133559: LD_INT 0
133561: PPUSH
133562: PPUSH
133563: PPUSH
133564: PPUSH
133565: PPUSH
133566: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133567: LD_VAR 0 1
133571: NOT
133572: PUSH
133573: LD_EXP 100
133577: PUSH
133578: LD_VAR 0 1
133582: ARRAY
133583: NOT
133584: OR
133585: PUSH
133586: LD_VAR 0 2
133590: NOT
133591: OR
133592: IFFALSE 133596
// exit ;
133594: GO 134150
// side := mc_sides [ base ] ;
133596: LD_ADDR_VAR 0 6
133600: PUSH
133601: LD_EXP 126
133605: PUSH
133606: LD_VAR 0 1
133610: ARRAY
133611: ST_TO_ADDR
// if not side then
133612: LD_VAR 0 6
133616: NOT
133617: IFFALSE 133621
// exit ;
133619: GO 134150
// for i in solds do
133621: LD_ADDR_VAR 0 7
133625: PUSH
133626: LD_VAR 0 2
133630: PUSH
133631: FOR_IN
133632: IFFALSE 133693
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133634: LD_VAR 0 7
133638: PPUSH
133639: CALL_OW 310
133643: PPUSH
133644: CALL_OW 266
133648: PUSH
133649: LD_INT 32
133651: PUSH
133652: LD_INT 31
133654: PUSH
133655: EMPTY
133656: LIST
133657: LIST
133658: IN
133659: IFFALSE 133679
// solds := solds diff i else
133661: LD_ADDR_VAR 0 2
133665: PUSH
133666: LD_VAR 0 2
133670: PUSH
133671: LD_VAR 0 7
133675: DIFF
133676: ST_TO_ADDR
133677: GO 133691
// SetTag ( i , 18 ) ;
133679: LD_VAR 0 7
133683: PPUSH
133684: LD_INT 18
133686: PPUSH
133687: CALL_OW 109
133691: GO 133631
133693: POP
133694: POP
// if not solds then
133695: LD_VAR 0 2
133699: NOT
133700: IFFALSE 133704
// exit ;
133702: GO 134150
// repeat wait ( 0 0$2 ) ;
133704: LD_INT 70
133706: PPUSH
133707: CALL_OW 67
// enemy := mc_scan [ base ] ;
133711: LD_ADDR_VAR 0 4
133715: PUSH
133716: LD_EXP 123
133720: PUSH
133721: LD_VAR 0 1
133725: ARRAY
133726: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133727: LD_EXP 100
133731: PUSH
133732: LD_VAR 0 1
133736: ARRAY
133737: NOT
133738: PUSH
133739: LD_EXP 100
133743: PUSH
133744: LD_VAR 0 1
133748: ARRAY
133749: PUSH
133750: EMPTY
133751: EQUAL
133752: OR
133753: IFFALSE 133790
// begin for i in solds do
133755: LD_ADDR_VAR 0 7
133759: PUSH
133760: LD_VAR 0 2
133764: PUSH
133765: FOR_IN
133766: IFFALSE 133779
// ComStop ( i ) ;
133768: LD_VAR 0 7
133772: PPUSH
133773: CALL_OW 141
133777: GO 133765
133779: POP
133780: POP
// solds := [ ] ;
133781: LD_ADDR_VAR 0 2
133785: PUSH
133786: EMPTY
133787: ST_TO_ADDR
// exit ;
133788: GO 134150
// end ; for i in solds do
133790: LD_ADDR_VAR 0 7
133794: PUSH
133795: LD_VAR 0 2
133799: PUSH
133800: FOR_IN
133801: IFFALSE 134122
// begin if IsInUnit ( i ) then
133803: LD_VAR 0 7
133807: PPUSH
133808: CALL_OW 310
133812: IFFALSE 133823
// ComExitBuilding ( i ) ;
133814: LD_VAR 0 7
133818: PPUSH
133819: CALL_OW 122
// if GetLives ( i ) > 500 then
133823: LD_VAR 0 7
133827: PPUSH
133828: CALL_OW 256
133832: PUSH
133833: LD_INT 500
133835: GREATER
133836: IFFALSE 133889
// begin e := NearestUnitToUnit ( enemy , i ) ;
133838: LD_ADDR_VAR 0 5
133842: PUSH
133843: LD_VAR 0 4
133847: PPUSH
133848: LD_VAR 0 7
133852: PPUSH
133853: CALL_OW 74
133857: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133858: LD_VAR 0 7
133862: PPUSH
133863: LD_VAR 0 5
133867: PPUSH
133868: CALL_OW 250
133872: PPUSH
133873: LD_VAR 0 5
133877: PPUSH
133878: CALL_OW 251
133882: PPUSH
133883: CALL_OW 114
// end else
133887: GO 134120
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133889: LD_VAR 0 7
133893: PPUSH
133894: LD_EXP 100
133898: PUSH
133899: LD_VAR 0 1
133903: ARRAY
133904: PPUSH
133905: LD_INT 2
133907: PUSH
133908: LD_INT 30
133910: PUSH
133911: LD_INT 0
133913: PUSH
133914: EMPTY
133915: LIST
133916: LIST
133917: PUSH
133918: LD_INT 30
133920: PUSH
133921: LD_INT 1
133923: PUSH
133924: EMPTY
133925: LIST
133926: LIST
133927: PUSH
133928: LD_INT 30
133930: PUSH
133931: LD_INT 6
133933: PUSH
133934: EMPTY
133935: LIST
133936: LIST
133937: PUSH
133938: EMPTY
133939: LIST
133940: LIST
133941: LIST
133942: LIST
133943: PPUSH
133944: CALL_OW 72
133948: PPUSH
133949: LD_VAR 0 7
133953: PPUSH
133954: CALL_OW 74
133958: PPUSH
133959: CALL_OW 296
133963: PUSH
133964: LD_INT 10
133966: GREATER
133967: IFFALSE 134120
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133969: LD_ADDR_VAR 0 8
133973: PUSH
133974: LD_EXP 100
133978: PUSH
133979: LD_VAR 0 1
133983: ARRAY
133984: PPUSH
133985: LD_INT 2
133987: PUSH
133988: LD_INT 30
133990: PUSH
133991: LD_INT 0
133993: PUSH
133994: EMPTY
133995: LIST
133996: LIST
133997: PUSH
133998: LD_INT 30
134000: PUSH
134001: LD_INT 1
134003: PUSH
134004: EMPTY
134005: LIST
134006: LIST
134007: PUSH
134008: LD_INT 30
134010: PUSH
134011: LD_INT 6
134013: PUSH
134014: EMPTY
134015: LIST
134016: LIST
134017: PUSH
134018: EMPTY
134019: LIST
134020: LIST
134021: LIST
134022: LIST
134023: PPUSH
134024: CALL_OW 72
134028: PPUSH
134029: LD_VAR 0 7
134033: PPUSH
134034: CALL_OW 74
134038: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
134039: LD_VAR 0 7
134043: PPUSH
134044: LD_VAR 0 8
134048: PPUSH
134049: CALL_OW 250
134053: PPUSH
134054: LD_INT 3
134056: PPUSH
134057: LD_INT 5
134059: PPUSH
134060: CALL_OW 272
134064: PPUSH
134065: LD_VAR 0 8
134069: PPUSH
134070: CALL_OW 251
134074: PPUSH
134075: LD_INT 3
134077: PPUSH
134078: LD_INT 5
134080: PPUSH
134081: CALL_OW 273
134085: PPUSH
134086: CALL_OW 111
// SetTag ( i , 0 ) ;
134090: LD_VAR 0 7
134094: PPUSH
134095: LD_INT 0
134097: PPUSH
134098: CALL_OW 109
// solds := solds diff i ;
134102: LD_ADDR_VAR 0 2
134106: PUSH
134107: LD_VAR 0 2
134111: PUSH
134112: LD_VAR 0 7
134116: DIFF
134117: ST_TO_ADDR
// continue ;
134118: GO 133800
// end ; end ;
134120: GO 133800
134122: POP
134123: POP
// until not solds or not enemy ;
134124: LD_VAR 0 2
134128: NOT
134129: PUSH
134130: LD_VAR 0 4
134134: NOT
134135: OR
134136: IFFALSE 133704
// MC_Reset ( base , 18 ) ;
134138: LD_VAR 0 1
134142: PPUSH
134143: LD_INT 18
134145: PPUSH
134146: CALL 41007 0 2
// end ;
134150: LD_VAR 0 3
134154: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
134155: LD_INT 0
134157: PPUSH
134158: PPUSH
134159: PPUSH
134160: PPUSH
134161: PPUSH
134162: PPUSH
134163: PPUSH
134164: PPUSH
134165: PPUSH
134166: PPUSH
134167: PPUSH
134168: PPUSH
134169: PPUSH
134170: PPUSH
134171: PPUSH
134172: PPUSH
134173: PPUSH
134174: PPUSH
134175: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
134176: LD_ADDR_VAR 0 12
134180: PUSH
134181: LD_EXP 100
134185: PUSH
134186: LD_VAR 0 1
134190: ARRAY
134191: PPUSH
134192: LD_INT 25
134194: PUSH
134195: LD_INT 3
134197: PUSH
134198: EMPTY
134199: LIST
134200: LIST
134201: PPUSH
134202: CALL_OW 72
134206: ST_TO_ADDR
// if mc_remote_driver [ base ] then
134207: LD_EXP 140
134211: PUSH
134212: LD_VAR 0 1
134216: ARRAY
134217: IFFALSE 134241
// mechs := mechs diff mc_remote_driver [ base ] ;
134219: LD_ADDR_VAR 0 12
134223: PUSH
134224: LD_VAR 0 12
134228: PUSH
134229: LD_EXP 140
134233: PUSH
134234: LD_VAR 0 1
134238: ARRAY
134239: DIFF
134240: ST_TO_ADDR
// for i in mechs do
134241: LD_ADDR_VAR 0 4
134245: PUSH
134246: LD_VAR 0 12
134250: PUSH
134251: FOR_IN
134252: IFFALSE 134287
// if GetTag ( i ) > 0 then
134254: LD_VAR 0 4
134258: PPUSH
134259: CALL_OW 110
134263: PUSH
134264: LD_INT 0
134266: GREATER
134267: IFFALSE 134285
// mechs := mechs diff i ;
134269: LD_ADDR_VAR 0 12
134273: PUSH
134274: LD_VAR 0 12
134278: PUSH
134279: LD_VAR 0 4
134283: DIFF
134284: ST_TO_ADDR
134285: GO 134251
134287: POP
134288: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134289: LD_ADDR_VAR 0 8
134293: PUSH
134294: LD_EXP 100
134298: PUSH
134299: LD_VAR 0 1
134303: ARRAY
134304: PPUSH
134305: LD_INT 2
134307: PUSH
134308: LD_INT 25
134310: PUSH
134311: LD_INT 1
134313: PUSH
134314: EMPTY
134315: LIST
134316: LIST
134317: PUSH
134318: LD_INT 25
134320: PUSH
134321: LD_INT 5
134323: PUSH
134324: EMPTY
134325: LIST
134326: LIST
134327: PUSH
134328: LD_INT 25
134330: PUSH
134331: LD_INT 8
134333: PUSH
134334: EMPTY
134335: LIST
134336: LIST
134337: PUSH
134338: LD_INT 25
134340: PUSH
134341: LD_INT 9
134343: PUSH
134344: EMPTY
134345: LIST
134346: LIST
134347: PUSH
134348: EMPTY
134349: LIST
134350: LIST
134351: LIST
134352: LIST
134353: LIST
134354: PPUSH
134355: CALL_OW 72
134359: ST_TO_ADDR
// if not defenders and not solds then
134360: LD_VAR 0 2
134364: NOT
134365: PUSH
134366: LD_VAR 0 8
134370: NOT
134371: AND
134372: IFFALSE 134376
// exit ;
134374: GO 136146
// depot_under_attack := false ;
134376: LD_ADDR_VAR 0 16
134380: PUSH
134381: LD_INT 0
134383: ST_TO_ADDR
// sold_defenders := [ ] ;
134384: LD_ADDR_VAR 0 17
134388: PUSH
134389: EMPTY
134390: ST_TO_ADDR
// if mechs then
134391: LD_VAR 0 12
134395: IFFALSE 134548
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134397: LD_ADDR_VAR 0 4
134401: PUSH
134402: LD_VAR 0 2
134406: PPUSH
134407: LD_INT 21
134409: PUSH
134410: LD_INT 2
134412: PUSH
134413: EMPTY
134414: LIST
134415: LIST
134416: PPUSH
134417: CALL_OW 72
134421: PUSH
134422: FOR_IN
134423: IFFALSE 134546
// begin if GetTag ( i ) <> 20 then
134425: LD_VAR 0 4
134429: PPUSH
134430: CALL_OW 110
134434: PUSH
134435: LD_INT 20
134437: NONEQUAL
134438: IFFALSE 134452
// SetTag ( i , 20 ) ;
134440: LD_VAR 0 4
134444: PPUSH
134445: LD_INT 20
134447: PPUSH
134448: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134452: LD_VAR 0 4
134456: PPUSH
134457: CALL_OW 263
134461: PUSH
134462: LD_INT 1
134464: EQUAL
134465: PUSH
134466: LD_VAR 0 4
134470: PPUSH
134471: CALL_OW 311
134475: NOT
134476: AND
134477: IFFALSE 134544
// begin un := mechs [ 1 ] ;
134479: LD_ADDR_VAR 0 10
134483: PUSH
134484: LD_VAR 0 12
134488: PUSH
134489: LD_INT 1
134491: ARRAY
134492: ST_TO_ADDR
// ComExit ( un ) ;
134493: LD_VAR 0 10
134497: PPUSH
134498: CALL 105357 0 1
// AddComEnterUnit ( un , i ) ;
134502: LD_VAR 0 10
134506: PPUSH
134507: LD_VAR 0 4
134511: PPUSH
134512: CALL_OW 180
// SetTag ( un , 19 ) ;
134516: LD_VAR 0 10
134520: PPUSH
134521: LD_INT 19
134523: PPUSH
134524: CALL_OW 109
// mechs := mechs diff un ;
134528: LD_ADDR_VAR 0 12
134532: PUSH
134533: LD_VAR 0 12
134537: PUSH
134538: LD_VAR 0 10
134542: DIFF
134543: ST_TO_ADDR
// end ; end ;
134544: GO 134422
134546: POP
134547: POP
// if solds then
134548: LD_VAR 0 8
134552: IFFALSE 134611
// for i in solds do
134554: LD_ADDR_VAR 0 4
134558: PUSH
134559: LD_VAR 0 8
134563: PUSH
134564: FOR_IN
134565: IFFALSE 134609
// if not GetTag ( i ) then
134567: LD_VAR 0 4
134571: PPUSH
134572: CALL_OW 110
134576: NOT
134577: IFFALSE 134607
// begin defenders := defenders union i ;
134579: LD_ADDR_VAR 0 2
134583: PUSH
134584: LD_VAR 0 2
134588: PUSH
134589: LD_VAR 0 4
134593: UNION
134594: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134595: LD_VAR 0 4
134599: PPUSH
134600: LD_INT 18
134602: PPUSH
134603: CALL_OW 109
// end ;
134607: GO 134564
134609: POP
134610: POP
// repeat wait ( 0 0$2 ) ;
134611: LD_INT 70
134613: PPUSH
134614: CALL_OW 67
// enemy := mc_scan [ base ] ;
134618: LD_ADDR_VAR 0 21
134622: PUSH
134623: LD_EXP 123
134627: PUSH
134628: LD_VAR 0 1
134632: ARRAY
134633: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134634: LD_EXP 100
134638: PUSH
134639: LD_VAR 0 1
134643: ARRAY
134644: NOT
134645: PUSH
134646: LD_EXP 100
134650: PUSH
134651: LD_VAR 0 1
134655: ARRAY
134656: PUSH
134657: EMPTY
134658: EQUAL
134659: OR
134660: IFFALSE 134697
// begin for i in defenders do
134662: LD_ADDR_VAR 0 4
134666: PUSH
134667: LD_VAR 0 2
134671: PUSH
134672: FOR_IN
134673: IFFALSE 134686
// ComStop ( i ) ;
134675: LD_VAR 0 4
134679: PPUSH
134680: CALL_OW 141
134684: GO 134672
134686: POP
134687: POP
// defenders := [ ] ;
134688: LD_ADDR_VAR 0 2
134692: PUSH
134693: EMPTY
134694: ST_TO_ADDR
// exit ;
134695: GO 136146
// end ; for i in defenders do
134697: LD_ADDR_VAR 0 4
134701: PUSH
134702: LD_VAR 0 2
134706: PUSH
134707: FOR_IN
134708: IFFALSE 135606
// begin e := NearestUnitToUnit ( enemy , i ) ;
134710: LD_ADDR_VAR 0 13
134714: PUSH
134715: LD_VAR 0 21
134719: PPUSH
134720: LD_VAR 0 4
134724: PPUSH
134725: CALL_OW 74
134729: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134730: LD_ADDR_VAR 0 7
134734: PUSH
134735: LD_EXP 100
134739: PUSH
134740: LD_VAR 0 1
134744: ARRAY
134745: PPUSH
134746: LD_INT 2
134748: PUSH
134749: LD_INT 30
134751: PUSH
134752: LD_INT 0
134754: PUSH
134755: EMPTY
134756: LIST
134757: LIST
134758: PUSH
134759: LD_INT 30
134761: PUSH
134762: LD_INT 1
134764: PUSH
134765: EMPTY
134766: LIST
134767: LIST
134768: PUSH
134769: EMPTY
134770: LIST
134771: LIST
134772: LIST
134773: PPUSH
134774: CALL_OW 72
134778: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134779: LD_ADDR_VAR 0 16
134783: PUSH
134784: LD_VAR 0 7
134788: NOT
134789: PUSH
134790: LD_VAR 0 7
134794: PPUSH
134795: LD_INT 3
134797: PUSH
134798: LD_INT 24
134800: PUSH
134801: LD_INT 600
134803: PUSH
134804: EMPTY
134805: LIST
134806: LIST
134807: PUSH
134808: EMPTY
134809: LIST
134810: LIST
134811: PPUSH
134812: CALL_OW 72
134816: OR
134817: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134818: LD_VAR 0 4
134822: PPUSH
134823: CALL_OW 247
134827: PUSH
134828: LD_INT 2
134830: DOUBLE
134831: EQUAL
134832: IFTRUE 134836
134834: GO 135232
134836: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134837: LD_VAR 0 4
134841: PPUSH
134842: CALL_OW 256
134846: PUSH
134847: LD_INT 1000
134849: EQUAL
134850: PUSH
134851: LD_VAR 0 4
134855: PPUSH
134856: LD_VAR 0 13
134860: PPUSH
134861: CALL_OW 296
134865: PUSH
134866: LD_INT 40
134868: LESS
134869: PUSH
134870: LD_VAR 0 13
134874: PPUSH
134875: LD_EXP 125
134879: PUSH
134880: LD_VAR 0 1
134884: ARRAY
134885: PPUSH
134886: CALL_OW 308
134890: OR
134891: AND
134892: IFFALSE 135014
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134894: LD_VAR 0 4
134898: PPUSH
134899: CALL_OW 262
134903: PUSH
134904: LD_INT 1
134906: EQUAL
134907: PUSH
134908: LD_VAR 0 4
134912: PPUSH
134913: CALL_OW 261
134917: PUSH
134918: LD_INT 30
134920: LESS
134921: AND
134922: PUSH
134923: LD_VAR 0 7
134927: AND
134928: IFFALSE 134998
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134930: LD_VAR 0 4
134934: PPUSH
134935: LD_VAR 0 7
134939: PPUSH
134940: LD_VAR 0 4
134944: PPUSH
134945: CALL_OW 74
134949: PPUSH
134950: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134954: LD_VAR 0 4
134958: PPUSH
134959: LD_VAR 0 7
134963: PPUSH
134964: LD_VAR 0 4
134968: PPUSH
134969: CALL_OW 74
134973: PPUSH
134974: CALL_OW 296
134978: PUSH
134979: LD_INT 6
134981: LESS
134982: IFFALSE 134996
// SetFuel ( i , 100 ) ;
134984: LD_VAR 0 4
134988: PPUSH
134989: LD_INT 100
134991: PPUSH
134992: CALL_OW 240
// end else
134996: GO 135012
// ComAttackUnit ( i , e ) ;
134998: LD_VAR 0 4
135002: PPUSH
135003: LD_VAR 0 13
135007: PPUSH
135008: CALL_OW 115
// end else
135012: GO 135115
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
135014: LD_VAR 0 13
135018: PPUSH
135019: LD_EXP 125
135023: PUSH
135024: LD_VAR 0 1
135028: ARRAY
135029: PPUSH
135030: CALL_OW 308
135034: NOT
135035: PUSH
135036: LD_VAR 0 4
135040: PPUSH
135041: LD_VAR 0 13
135045: PPUSH
135046: CALL_OW 296
135050: PUSH
135051: LD_INT 40
135053: GREATEREQUAL
135054: AND
135055: PUSH
135056: LD_VAR 0 4
135060: PPUSH
135061: CALL_OW 256
135065: PUSH
135066: LD_INT 650
135068: LESSEQUAL
135069: OR
135070: PUSH
135071: LD_VAR 0 4
135075: PPUSH
135076: LD_EXP 124
135080: PUSH
135081: LD_VAR 0 1
135085: ARRAY
135086: PPUSH
135087: CALL_OW 308
135091: NOT
135092: AND
135093: IFFALSE 135115
// ComMoveToArea ( i , mc_parking [ base ] ) ;
135095: LD_VAR 0 4
135099: PPUSH
135100: LD_EXP 124
135104: PUSH
135105: LD_VAR 0 1
135109: ARRAY
135110: PPUSH
135111: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
135115: LD_VAR 0 4
135119: PPUSH
135120: CALL_OW 256
135124: PUSH
135125: LD_INT 1000
135127: LESS
135128: PUSH
135129: LD_VAR 0 4
135133: PPUSH
135134: CALL_OW 263
135138: PUSH
135139: LD_INT 1
135141: EQUAL
135142: AND
135143: PUSH
135144: LD_VAR 0 4
135148: PPUSH
135149: CALL_OW 311
135153: AND
135154: PUSH
135155: LD_VAR 0 4
135159: PPUSH
135160: LD_EXP 124
135164: PUSH
135165: LD_VAR 0 1
135169: ARRAY
135170: PPUSH
135171: CALL_OW 308
135175: AND
135176: IFFALSE 135230
// begin mech := IsDrivenBy ( i ) ;
135178: LD_ADDR_VAR 0 9
135182: PUSH
135183: LD_VAR 0 4
135187: PPUSH
135188: CALL_OW 311
135192: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
135193: LD_VAR 0 9
135197: PPUSH
135198: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
135202: LD_VAR 0 9
135206: PPUSH
135207: LD_VAR 0 4
135211: PPUSH
135212: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135216: LD_VAR 0 9
135220: PPUSH
135221: LD_VAR 0 4
135225: PPUSH
135226: CALL_OW 180
// end ; end ; unit_human :
135230: GO 135577
135232: LD_INT 1
135234: DOUBLE
135235: EQUAL
135236: IFTRUE 135240
135238: GO 135576
135240: POP
// begin b := IsInUnit ( i ) ;
135241: LD_ADDR_VAR 0 18
135245: PUSH
135246: LD_VAR 0 4
135250: PPUSH
135251: CALL_OW 310
135255: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135256: LD_ADDR_VAR 0 19
135260: PUSH
135261: LD_VAR 0 18
135265: NOT
135266: PUSH
135267: LD_VAR 0 18
135271: PPUSH
135272: CALL_OW 266
135276: PUSH
135277: LD_INT 32
135279: PUSH
135280: LD_INT 31
135282: PUSH
135283: EMPTY
135284: LIST
135285: LIST
135286: IN
135287: OR
135288: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135289: LD_VAR 0 18
135293: PPUSH
135294: CALL_OW 266
135298: PUSH
135299: LD_INT 5
135301: EQUAL
135302: PUSH
135303: LD_VAR 0 4
135307: PPUSH
135308: CALL_OW 257
135312: PUSH
135313: LD_INT 1
135315: PUSH
135316: LD_INT 2
135318: PUSH
135319: LD_INT 3
135321: PUSH
135322: LD_INT 4
135324: PUSH
135325: EMPTY
135326: LIST
135327: LIST
135328: LIST
135329: LIST
135330: IN
135331: AND
135332: IFFALSE 135369
// begin class := AllowSpecClass ( i ) ;
135334: LD_ADDR_VAR 0 20
135338: PUSH
135339: LD_VAR 0 4
135343: PPUSH
135344: CALL 69296 0 1
135348: ST_TO_ADDR
// if class then
135349: LD_VAR 0 20
135353: IFFALSE 135369
// ComChangeProfession ( i , class ) ;
135355: LD_VAR 0 4
135359: PPUSH
135360: LD_VAR 0 20
135364: PPUSH
135365: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135369: LD_VAR 0 16
135373: PUSH
135374: LD_VAR 0 2
135378: PPUSH
135379: LD_INT 21
135381: PUSH
135382: LD_INT 2
135384: PUSH
135385: EMPTY
135386: LIST
135387: LIST
135388: PPUSH
135389: CALL_OW 72
135393: PUSH
135394: LD_INT 1
135396: LESSEQUAL
135397: OR
135398: PUSH
135399: LD_VAR 0 19
135403: AND
135404: PUSH
135405: LD_VAR 0 4
135409: PUSH
135410: LD_VAR 0 17
135414: IN
135415: NOT
135416: AND
135417: IFFALSE 135510
// begin if b then
135419: LD_VAR 0 18
135423: IFFALSE 135472
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135425: LD_VAR 0 18
135429: PPUSH
135430: LD_VAR 0 21
135434: PPUSH
135435: LD_VAR 0 18
135439: PPUSH
135440: CALL_OW 74
135444: PPUSH
135445: CALL_OW 296
135449: PUSH
135450: LD_INT 10
135452: LESS
135453: PUSH
135454: LD_VAR 0 18
135458: PPUSH
135459: CALL_OW 461
135463: PUSH
135464: LD_INT 7
135466: NONEQUAL
135467: AND
135468: IFFALSE 135472
// continue ;
135470: GO 134707
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135472: LD_ADDR_VAR 0 17
135476: PUSH
135477: LD_VAR 0 17
135481: PPUSH
135482: LD_VAR 0 17
135486: PUSH
135487: LD_INT 1
135489: PLUS
135490: PPUSH
135491: LD_VAR 0 4
135495: PPUSH
135496: CALL_OW 1
135500: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135501: LD_VAR 0 4
135505: PPUSH
135506: CALL_OW 122
// end ; if sold_defenders then
135510: LD_VAR 0 17
135514: IFFALSE 135574
// if i in sold_defenders then
135516: LD_VAR 0 4
135520: PUSH
135521: LD_VAR 0 17
135525: IN
135526: IFFALSE 135574
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135528: LD_VAR 0 4
135532: PPUSH
135533: CALL_OW 314
135537: NOT
135538: PUSH
135539: LD_VAR 0 4
135543: PPUSH
135544: LD_VAR 0 13
135548: PPUSH
135549: CALL_OW 296
135553: PUSH
135554: LD_INT 30
135556: LESS
135557: AND
135558: IFFALSE 135574
// ComAttackUnit ( i , e ) ;
135560: LD_VAR 0 4
135564: PPUSH
135565: LD_VAR 0 13
135569: PPUSH
135570: CALL_OW 115
// end ; end ; end ;
135574: GO 135577
135576: POP
// if IsDead ( i ) then
135577: LD_VAR 0 4
135581: PPUSH
135582: CALL_OW 301
135586: IFFALSE 135604
// defenders := defenders diff i ;
135588: LD_ADDR_VAR 0 2
135592: PUSH
135593: LD_VAR 0 2
135597: PUSH
135598: LD_VAR 0 4
135602: DIFF
135603: ST_TO_ADDR
// end ;
135604: GO 134707
135606: POP
135607: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135608: LD_VAR 0 21
135612: NOT
135613: PUSH
135614: LD_VAR 0 2
135618: NOT
135619: OR
135620: PUSH
135621: LD_EXP 100
135625: PUSH
135626: LD_VAR 0 1
135630: ARRAY
135631: NOT
135632: OR
135633: IFFALSE 134611
// MC_Reset ( base , 18 ) ;
135635: LD_VAR 0 1
135639: PPUSH
135640: LD_INT 18
135642: PPUSH
135643: CALL 41007 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135647: LD_ADDR_VAR 0 2
135651: PUSH
135652: LD_VAR 0 2
135656: PUSH
135657: LD_VAR 0 2
135661: PPUSH
135662: LD_INT 2
135664: PUSH
135665: LD_INT 25
135667: PUSH
135668: LD_INT 1
135670: PUSH
135671: EMPTY
135672: LIST
135673: LIST
135674: PUSH
135675: LD_INT 25
135677: PUSH
135678: LD_INT 5
135680: PUSH
135681: EMPTY
135682: LIST
135683: LIST
135684: PUSH
135685: LD_INT 25
135687: PUSH
135688: LD_INT 8
135690: PUSH
135691: EMPTY
135692: LIST
135693: LIST
135694: PUSH
135695: LD_INT 25
135697: PUSH
135698: LD_INT 9
135700: PUSH
135701: EMPTY
135702: LIST
135703: LIST
135704: PUSH
135705: EMPTY
135706: LIST
135707: LIST
135708: LIST
135709: LIST
135710: LIST
135711: PPUSH
135712: CALL_OW 72
135716: DIFF
135717: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135718: LD_VAR 0 21
135722: NOT
135723: PUSH
135724: LD_VAR 0 2
135728: PPUSH
135729: LD_INT 21
135731: PUSH
135732: LD_INT 2
135734: PUSH
135735: EMPTY
135736: LIST
135737: LIST
135738: PPUSH
135739: CALL_OW 72
135743: AND
135744: IFFALSE 136082
// begin tmp := FilterByTag ( defenders , 19 ) ;
135746: LD_ADDR_VAR 0 11
135750: PUSH
135751: LD_VAR 0 2
135755: PPUSH
135756: LD_INT 19
135758: PPUSH
135759: CALL 102533 0 2
135763: ST_TO_ADDR
// if tmp then
135764: LD_VAR 0 11
135768: IFFALSE 135838
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135770: LD_ADDR_VAR 0 11
135774: PUSH
135775: LD_VAR 0 11
135779: PPUSH
135780: LD_INT 25
135782: PUSH
135783: LD_INT 3
135785: PUSH
135786: EMPTY
135787: LIST
135788: LIST
135789: PPUSH
135790: CALL_OW 72
135794: ST_TO_ADDR
// if tmp then
135795: LD_VAR 0 11
135799: IFFALSE 135838
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135801: LD_ADDR_EXP 112
135805: PUSH
135806: LD_EXP 112
135810: PPUSH
135811: LD_VAR 0 1
135815: PPUSH
135816: LD_EXP 112
135820: PUSH
135821: LD_VAR 0 1
135825: ARRAY
135826: PUSH
135827: LD_VAR 0 11
135831: UNION
135832: PPUSH
135833: CALL_OW 1
135837: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135838: LD_VAR 0 1
135842: PPUSH
135843: LD_INT 19
135845: PPUSH
135846: CALL 41007 0 2
// repeat wait ( 0 0$1 ) ;
135850: LD_INT 35
135852: PPUSH
135853: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135857: LD_EXP 100
135861: PUSH
135862: LD_VAR 0 1
135866: ARRAY
135867: NOT
135868: PUSH
135869: LD_EXP 100
135873: PUSH
135874: LD_VAR 0 1
135878: ARRAY
135879: PUSH
135880: EMPTY
135881: EQUAL
135882: OR
135883: IFFALSE 135920
// begin for i in defenders do
135885: LD_ADDR_VAR 0 4
135889: PUSH
135890: LD_VAR 0 2
135894: PUSH
135895: FOR_IN
135896: IFFALSE 135909
// ComStop ( i ) ;
135898: LD_VAR 0 4
135902: PPUSH
135903: CALL_OW 141
135907: GO 135895
135909: POP
135910: POP
// defenders := [ ] ;
135911: LD_ADDR_VAR 0 2
135915: PUSH
135916: EMPTY
135917: ST_TO_ADDR
// exit ;
135918: GO 136146
// end ; for i in defenders do
135920: LD_ADDR_VAR 0 4
135924: PUSH
135925: LD_VAR 0 2
135929: PUSH
135930: FOR_IN
135931: IFFALSE 136020
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135933: LD_VAR 0 4
135937: PPUSH
135938: LD_EXP 124
135942: PUSH
135943: LD_VAR 0 1
135947: ARRAY
135948: PPUSH
135949: CALL_OW 308
135953: NOT
135954: IFFALSE 135978
// ComMoveToArea ( i , mc_parking [ base ] ) else
135956: LD_VAR 0 4
135960: PPUSH
135961: LD_EXP 124
135965: PUSH
135966: LD_VAR 0 1
135970: ARRAY
135971: PPUSH
135972: CALL_OW 113
135976: GO 136018
// if GetControl ( i ) = control_manual then
135978: LD_VAR 0 4
135982: PPUSH
135983: CALL_OW 263
135987: PUSH
135988: LD_INT 1
135990: EQUAL
135991: IFFALSE 136018
// if IsDrivenBy ( i ) then
135993: LD_VAR 0 4
135997: PPUSH
135998: CALL_OW 311
136002: IFFALSE 136018
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
136004: LD_VAR 0 4
136008: PPUSH
136009: CALL_OW 311
136013: PPUSH
136014: CALL_OW 121
// end ;
136018: GO 135930
136020: POP
136021: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
136022: LD_VAR 0 2
136026: PPUSH
136027: LD_INT 95
136029: PUSH
136030: LD_EXP 124
136034: PUSH
136035: LD_VAR 0 1
136039: ARRAY
136040: PUSH
136041: EMPTY
136042: LIST
136043: LIST
136044: PPUSH
136045: CALL_OW 72
136049: PUSH
136050: LD_VAR 0 2
136054: EQUAL
136055: PUSH
136056: LD_EXP 123
136060: PUSH
136061: LD_VAR 0 1
136065: ARRAY
136066: OR
136067: PUSH
136068: LD_EXP 100
136072: PUSH
136073: LD_VAR 0 1
136077: ARRAY
136078: NOT
136079: OR
136080: IFFALSE 135850
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
136082: LD_ADDR_EXP 122
136086: PUSH
136087: LD_EXP 122
136091: PPUSH
136092: LD_VAR 0 1
136096: PPUSH
136097: LD_VAR 0 2
136101: PPUSH
136102: LD_INT 21
136104: PUSH
136105: LD_INT 2
136107: PUSH
136108: EMPTY
136109: LIST
136110: LIST
136111: PPUSH
136112: CALL_OW 72
136116: PPUSH
136117: CALL_OW 1
136121: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
136122: LD_VAR 0 1
136126: PPUSH
136127: LD_INT 19
136129: PPUSH
136130: CALL 41007 0 2
// MC_Reset ( base , 20 ) ;
136134: LD_VAR 0 1
136138: PPUSH
136139: LD_INT 20
136141: PPUSH
136142: CALL 41007 0 2
// end ; end_of_file
136146: LD_VAR 0 3
136150: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
136151: LD_VAR 0 1
136155: PUSH
136156: LD_INT 200
136158: DOUBLE
136159: GREATEREQUAL
136160: IFFALSE 136168
136162: LD_INT 299
136164: DOUBLE
136165: LESSEQUAL
136166: IFTRUE 136170
136168: GO 136202
136170: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
136171: LD_VAR 0 1
136175: PPUSH
136176: LD_VAR 0 2
136180: PPUSH
136181: LD_VAR 0 3
136185: PPUSH
136186: LD_VAR 0 4
136190: PPUSH
136191: LD_VAR 0 5
136195: PPUSH
136196: CALL 124937 0 5
136200: GO 136279
136202: LD_INT 300
136204: DOUBLE
136205: GREATEREQUAL
136206: IFFALSE 136214
136208: LD_INT 399
136210: DOUBLE
136211: LESSEQUAL
136212: IFTRUE 136216
136214: GO 136278
136216: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136217: LD_VAR 0 1
136221: PPUSH
136222: LD_VAR 0 2
136226: PPUSH
136227: LD_VAR 0 3
136231: PPUSH
136232: LD_VAR 0 4
136236: PPUSH
136237: LD_VAR 0 5
136241: PPUSH
136242: LD_VAR 0 6
136246: PPUSH
136247: LD_VAR 0 7
136251: PPUSH
136252: LD_VAR 0 8
136256: PPUSH
136257: LD_VAR 0 9
136261: PPUSH
136262: LD_VAR 0 10
136266: PPUSH
136267: LD_VAR 0 11
136271: PPUSH
136272: CALL 121270 0 11
136276: GO 136279
136278: POP
// end ;
136279: PPOPN 11
136281: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136282: LD_VAR 0 1
136286: PPUSH
136287: LD_VAR 0 2
136291: PPUSH
136292: LD_VAR 0 3
136296: PPUSH
136297: LD_VAR 0 4
136301: PPUSH
136302: LD_VAR 0 5
136306: PPUSH
136307: CALL 124673 0 5
// end ; end_of_file
136311: PPOPN 5
136313: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136314: LD_VAR 0 1
136318: PPUSH
136319: LD_VAR 0 2
136323: PPUSH
136324: LD_VAR 0 3
136328: PPUSH
136329: LD_VAR 0 4
136333: PPUSH
136334: LD_VAR 0 5
136338: PPUSH
136339: LD_VAR 0 6
136343: PPUSH
136344: CALL 108963 0 6
// end ;
136348: PPOPN 6
136350: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136351: LD_INT 0
136353: PPUSH
// begin if not units then
136354: LD_VAR 0 1
136358: NOT
136359: IFFALSE 136363
// exit ;
136361: GO 136363
// end ;
136363: PPOPN 7
136365: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136366: CALL 108934 0 0
// end ;
136370: PPOPN 1
136372: END
