// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33930 0 0
// InitNature ;
  19: CALL 33754 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10891 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14798 0 0
// MC_Start ( ) ;
  60: CALL 36042 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58423 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58516 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57866 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57681 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58423 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58516 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57681 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57866 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 58296 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57363 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58423 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58516 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57681 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58423 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58516 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57573 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58834 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 58005 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 58296 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 58296 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58628 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57681 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 58247 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 64073 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 71099 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 71099 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 71099 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 71099 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 71099 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 64073 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64073 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64073 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 64073 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 64073 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 64073 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 64073 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 64073 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 64073 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 64073 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 64073 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 64073 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 64073 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 64073 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 64073 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 64073 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 64073 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 64073 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 64073 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 64073 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 64073 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 64073 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 64073 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 64073 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 64073 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 64073 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 64073 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 64073 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 71099 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 64073 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 64073 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 64073 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 74508 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 71099 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57866 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57729 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 59147 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57729 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57729 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 59147 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 59147 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 71099 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 74508 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106844 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106844 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106892 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106892 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 71099 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 5
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 71099 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 5
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 71099 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 6
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 71099 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 71099 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 71099 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 71099 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 71099 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9901
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 9100
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: PUSH
9334: LD_OWVAR 67
9338: PUSH
9339: LD_INT 1
9341: GREATER
9342: AND
9343: IFFALSE 9371
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9345: LD_INT 53
9347: PPUSH
9348: LD_INT 6
9350: PPUSH
9351: LD_INT 2
9353: PPUSH
9354: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9358: LD_INT 59
9360: PPUSH
9361: LD_INT 6
9363: PPUSH
9364: LD_INT 2
9366: PPUSH
9367: CALL_OW 322
// end ; if activeAttacks then
9371: LD_EXP 16
9375: IFFALSE 9895
// begin if missionStage = 2 then
9377: LD_EXP 15
9381: PUSH
9382: LD_INT 2
9384: EQUAL
9385: IFFALSE 9395
// strength := 1 ;
9387: LD_ADDR_VAR 0 5
9391: PUSH
9392: LD_INT 1
9394: ST_TO_ADDR
// if missionStage > 2 then
9395: LD_EXP 15
9399: PUSH
9400: LD_INT 2
9402: GREATER
9403: IFFALSE 9413
// strength := 2 ;
9405: LD_ADDR_VAR 0 5
9409: PUSH
9410: LD_INT 2
9412: ST_TO_ADDR
// if missionStage > 6 then
9413: LD_EXP 15
9417: PUSH
9418: LD_INT 6
9420: GREATER
9421: IFFALSE 9431
// strength := 3 ;
9423: LD_ADDR_VAR 0 5
9427: PUSH
9428: LD_INT 3
9430: ST_TO_ADDR
// if missionStage > 10 then
9431: LD_EXP 15
9435: PUSH
9436: LD_INT 10
9438: GREATER
9439: IFFALSE 9449
// strength := 4 ;
9441: LD_ADDR_VAR 0 5
9445: PUSH
9446: LD_INT 4
9448: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9449: LD_ADDR_VAR 0 2
9453: PUSH
9454: LD_VAR 0 5
9458: PPUSH
9459: CALL 8011 0 1
9463: ST_TO_ADDR
// for i in tmp do
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: FOR_IN
9475: IFFALSE 9575
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9477: LD_VAR 0 1
9481: PPUSH
9482: LD_VAR 0 4
9486: PUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 2
9492: PPUSH
9493: CALL_OW 12
9497: ARRAY
9498: PPUSH
9499: LD_INT 0
9501: PPUSH
9502: CALL_OW 49
// if i = sewiVeh then
9506: LD_VAR 0 1
9510: PUSH
9511: LD_EXP 68
9515: EQUAL
9516: IFFALSE 9551
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9518: LD_ADDR_EXP 67
9522: PUSH
9523: LD_STRING Vsevolod
9525: PPUSH
9526: LD_INT 0
9528: PPUSH
9529: LD_STRING 
9531: PPUSH
9532: CALL 64073 0 3
9536: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9537: LD_EXP 67
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9551: LD_VAR 0 1
9555: PPUSH
9556: LD_INT 111
9558: PPUSH
9559: LD_INT 197
9561: PPUSH
9562: CALL_OW 111
// wait ( 0 0$2 ) ;
9566: LD_INT 70
9568: PPUSH
9569: CALL_OW 67
// end ;
9573: GO 9474
9575: POP
9576: POP
// repeat wait ( 0 0$1 ) ;
9577: LD_INT 35
9579: PPUSH
9580: CALL_OW 67
// for i in tmp do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_VAR 0 2
9593: PUSH
9594: FOR_IN
9595: IFFALSE 9876
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9597: LD_INT 81
9599: PUSH
9600: LD_INT 6
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_VAR 0 1
9614: PUSH
9615: LD_INT 12
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PPUSH
9627: CALL_OW 69
9631: IFFALSE 9689
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9633: LD_VAR 0 1
9637: PPUSH
9638: LD_INT 81
9640: PUSH
9641: LD_INT 6
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 91
9650: PUSH
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 12
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: PPUSH
9673: LD_VAR 0 1
9677: PPUSH
9678: CALL_OW 74
9682: PPUSH
9683: CALL_OW 115
9687: GO 9874
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9689: LD_INT 9
9691: PPUSH
9692: LD_INT 81
9694: PUSH
9695: LD_INT 6
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 70
9706: IFFALSE 9840
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9708: LD_VAR 0 1
9712: PPUSH
9713: LD_VAR 0 6
9717: PUSH
9718: LD_INT 1
9720: ARRAY
9721: PUSH
9722: LD_INT 1
9724: ARRAY
9725: PPUSH
9726: LD_VAR 0 6
9730: PUSH
9731: LD_INT 1
9733: ARRAY
9734: PUSH
9735: LD_INT 2
9737: ARRAY
9738: PPUSH
9739: CALL_OW 297
9743: PUSH
9744: LD_INT 10
9746: GREATER
9747: PUSH
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_INT 9
9755: PPUSH
9756: CALL_OW 308
9760: NOT
9761: AND
9762: IFFALSE 9801
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9764: LD_VAR 0 1
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 1
9780: ARRAY
9781: PPUSH
9782: LD_VAR 0 6
9786: PUSH
9787: LD_INT 1
9789: ARRAY
9790: PUSH
9791: LD_INT 2
9793: ARRAY
9794: PPUSH
9795: CALL_OW 114
9799: GO 9838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9801: LD_VAR 0 1
9805: PPUSH
9806: LD_INT 9
9808: PPUSH
9809: LD_INT 81
9811: PUSH
9812: LD_INT 6
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PPUSH
9819: CALL_OW 70
9823: PPUSH
9824: LD_VAR 0 1
9828: PPUSH
9829: CALL_OW 74
9833: PPUSH
9834: CALL_OW 115
// end else
9838: GO 9874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9840: LD_VAR 0 1
9844: PPUSH
9845: LD_INT 81
9847: PUSH
9848: LD_INT 6
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PPUSH
9855: CALL_OW 69
9859: PPUSH
9860: LD_VAR 0 1
9864: PPUSH
9865: CALL_OW 74
9869: PPUSH
9870: CALL_OW 115
// end ;
9874: GO 9594
9876: POP
9877: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9878: LD_INT 22
9880: PUSH
9881: LD_INT 6
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PPUSH
9888: CALL_OW 69
9892: NOT
9893: IFFALSE 9577
// end ; until russianDestroyed ;
9895: LD_EXP 21
9899: IFFALSE 9225
// end ;
9901: PPOPN 6
9903: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9904: LD_EXP 21
9908: NOT
9909: PUSH
9910: LD_EXP 15
9914: PUSH
9915: LD_INT 6
9917: GREATEREQUAL
9918: AND
9919: PUSH
9920: LD_INT 2
9922: PPUSH
9923: LD_INT 1
9925: PPUSH
9926: CALL 59147 0 2
9930: NOT
9931: AND
9932: IFFALSE 10888
9934: GO 9936
9936: DISABLE
9937: LD_INT 0
9939: PPUSH
9940: PPUSH
9941: PPUSH
9942: PPUSH
// begin enable ;
9943: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9944: LD_INT 22
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: LD_INT 30
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 69
9972: NOT
9973: IFFALSE 9977
// exit ;
9975: GO 10888
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9977: LD_ADDR_VAR 0 4
9981: PUSH
9982: LD_INT 22
9984: PUSH
9985: LD_INT 3
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: LD_INT 30
9994: PUSH
9995: LD_INT 34
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: ST_TO_ADDR
// if Prob ( 40 ) then
10011: LD_INT 40
10013: PPUSH
10014: CALL_OW 13
10018: IFFALSE 10145
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10020: LD_INT 2
10022: PPUSH
10023: LD_INT 22
10025: PUSH
10026: LD_INT 3
10028: PUSH
10029: LD_INT 3
10031: PUSH
10032: LD_INT 49
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 22
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: LD_INT 3
10049: PUSH
10050: LD_INT 49
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: PUSH
10059: LD_INT 22
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 49
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 24
10079: PUSH
10080: LD_INT 3
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 46
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: PUSH
10095: LD_INT 24
10097: PUSH
10098: LD_INT 3
10100: PUSH
10101: LD_INT 3
10103: PUSH
10104: LD_INT 46
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 46
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PPUSH
10139: CALL 57729 0 2
// end else
10143: GO 10268
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10145: LD_INT 2
10147: PPUSH
10148: LD_INT 24
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: LD_INT 3
10156: PUSH
10157: LD_INT 47
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 24
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 47
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: PUSH
10184: LD_INT 24
10186: PUSH
10187: LD_INT 3
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: LD_INT 47
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 24
10204: PUSH
10205: LD_INT 3
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: LD_INT 46
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 24
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: LD_INT 46
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 24
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 46
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PPUSH
10264: CALL 57729 0 2
// end ; if Difficulty > 1 then
10268: LD_OWVAR 67
10272: PUSH
10273: LD_INT 1
10275: GREATER
10276: IFFALSE 10306
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 47
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: PPUSH
10302: CALL 57729 0 2
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10313: LD_INT 2
10315: PPUSH
10316: LD_INT 1
10318: PPUSH
10319: CALL 59147 0 2
10323: PUSH
10324: LD_INT 6
10326: PUSH
10327: LD_INT 7
10329: PUSH
10330: LD_INT 7
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: PUSH
10338: LD_OWVAR 67
10342: ARRAY
10343: GREATEREQUAL
10344: IFFALSE 10306
// wait ( 0 0$30 ) ;
10346: LD_INT 1050
10348: PPUSH
10349: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10353: LD_ADDR_VAR 0 2
10357: PUSH
10358: LD_INT 2
10360: PPUSH
10361: LD_INT 1
10363: PPUSH
10364: CALL 59147 0 2
10368: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10369: LD_ADDR_EXP 118
10373: PUSH
10374: LD_EXP 118
10378: PPUSH
10379: LD_INT 2
10381: PPUSH
10382: LD_EXP 118
10386: PUSH
10387: LD_INT 2
10389: ARRAY
10390: PUSH
10391: LD_VAR 0 2
10395: DIFF
10396: PPUSH
10397: CALL_OW 1
10401: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10402: LD_ADDR_VAR 0 3
10406: PUSH
10407: LD_INT 0
10409: PPUSH
10410: LD_INT 1
10412: PPUSH
10413: CALL_OW 12
10417: ST_TO_ADDR
// if target then
10418: LD_VAR 0 3
10422: IFFALSE 10550
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 250
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PPUSH
10444: CALL_OW 72
10448: ST_TO_ADDR
// for i in tmp do
10449: LD_ADDR_VAR 0 1
10453: PUSH
10454: LD_VAR 0 2
10458: PUSH
10459: FOR_IN
10460: IFFALSE 10500
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10462: LD_VAR 0 1
10466: PPUSH
10467: LD_INT 139
10469: PPUSH
10470: LD_INT 89
10472: PPUSH
10473: CALL_OW 297
10477: PUSH
10478: LD_INT 9
10480: GREATER
10481: IFFALSE 10498
// ComMoveXY ( i , 139 , 89 ) ;
10483: LD_VAR 0 1
10487: PPUSH
10488: LD_INT 139
10490: PPUSH
10491: LD_INT 89
10493: PPUSH
10494: CALL_OW 111
10498: GO 10459
10500: POP
10501: POP
// wait ( 0 0$1 ) ;
10502: LD_INT 35
10504: PPUSH
10505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10509: LD_VAR 0 2
10513: PPUSH
10514: LD_INT 92
10516: PUSH
10517: LD_INT 139
10519: PUSH
10520: LD_INT 89
10522: PUSH
10523: LD_INT 9
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: PPUSH
10532: CALL_OW 72
10536: PUSH
10537: LD_VAR 0 2
10541: PUSH
10542: LD_INT 1
10544: MINUS
10545: GREATEREQUAL
10546: IFFALSE 10424
// end else
10548: GO 10692
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ARRAY
10563: PPUSH
10564: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10568: LD_ADDR_VAR 0 2
10572: PUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 250
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 72
10592: ST_TO_ADDR
// for i in tmp do
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_VAR 0 2
10602: PUSH
10603: FOR_IN
10604: IFFALSE 10644
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_INT 124
10613: PPUSH
10614: LD_INT 139
10616: PPUSH
10617: CALL_OW 297
10621: PUSH
10622: LD_INT 9
10624: GREATER
10625: IFFALSE 10642
// ComMoveXY ( i , 124 , 139 ) ;
10627: LD_VAR 0 1
10631: PPUSH
10632: LD_INT 124
10634: PPUSH
10635: LD_INT 139
10637: PPUSH
10638: CALL_OW 111
10642: GO 10603
10644: POP
10645: POP
// wait ( 0 0$1 ) ;
10646: LD_INT 35
10648: PPUSH
10649: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10653: LD_VAR 0 2
10657: PPUSH
10658: LD_INT 92
10660: PUSH
10661: LD_INT 124
10663: PUSH
10664: LD_INT 139
10666: PUSH
10667: LD_INT 9
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 72
10680: PUSH
10681: LD_VAR 0 2
10685: PUSH
10686: LD_INT 1
10688: MINUS
10689: GREATEREQUAL
10690: IFFALSE 10568
// end ; repeat wait ( 0 0$1 ) ;
10692: LD_INT 35
10694: PPUSH
10695: CALL_OW 67
// for i in tmp do
10699: LD_ADDR_VAR 0 1
10703: PUSH
10704: LD_VAR 0 2
10708: PUSH
10709: FOR_IN
10710: IFFALSE 10879
// begin if GetLives ( i ) > 251 then
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL_OW 256
10721: PUSH
10722: LD_INT 251
10724: GREATER
10725: IFFALSE 10850
// begin if GetWeapon ( i ) = ru_time_lapser then
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 264
10736: PUSH
10737: LD_INT 49
10739: EQUAL
10740: IFFALSE 10796
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10742: LD_VAR 0 1
10746: PPUSH
10747: LD_INT 2
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 1
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: LD_INT 22
10762: PUSH
10763: LD_INT 8
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: LIST
10774: PPUSH
10775: CALL_OW 69
10779: PPUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 74
10789: PPUSH
10790: CALL_OW 112
10794: GO 10848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10796: LD_VAR 0 1
10800: PPUSH
10801: LD_INT 2
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 1
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 22
10816: PUSH
10817: LD_INT 8
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: LIST
10828: PPUSH
10829: CALL_OW 69
10833: PPUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 74
10843: PPUSH
10844: CALL_OW 115
// end else
10848: GO 10877
// if IsDead ( i ) then
10850: LD_VAR 0 1
10854: PPUSH
10855: CALL_OW 301
10859: IFFALSE 10877
// tmp := tmp diff i ;
10861: LD_ADDR_VAR 0 2
10865: PUSH
10866: LD_VAR 0 2
10870: PUSH
10871: LD_VAR 0 1
10875: DIFF
10876: ST_TO_ADDR
// end ;
10877: GO 10709
10879: POP
10880: POP
// until not tmp ;
10881: LD_VAR 0 2
10885: NOT
10886: IFFALSE 10692
// end ; end_of_file
10888: PPOPN 4
10890: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10891: LD_INT 0
10893: PPUSH
10894: PPUSH
10895: PPUSH
10896: PPUSH
10897: PPUSH
10898: PPUSH
// side := 7 ;
10899: LD_ADDR_VAR 0 5
10903: PUSH
10904: LD_INT 7
10906: ST_TO_ADDR
// uc_side := side ;
10907: LD_ADDR_OWVAR 20
10911: PUSH
10912: LD_VAR 0 5
10916: ST_TO_ADDR
// uc_nation := 1 ;
10917: LD_ADDR_OWVAR 21
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10925: LD_ADDR_VAR 0 2
10929: PUSH
10930: LD_INT 22
10932: PUSH
10933: LD_VAR 0 5
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: LD_INT 21
10944: PUSH
10945: LD_INT 3
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PUSH
10961: FOR_IN
10962: IFFALSE 10978
// SetBLevel ( i , 10 ) ;
10964: LD_VAR 0 2
10968: PPUSH
10969: LD_INT 10
10971: PPUSH
10972: CALL_OW 241
10976: GO 10961
10978: POP
10979: POP
// base := GetBase ( al_depot ) ;
10980: LD_ADDR_VAR 0 4
10984: PUSH
10985: LD_INT 2
10987: PPUSH
10988: CALL_OW 274
10992: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10993: LD_ADDR_VAR 0 6
10997: PUSH
10998: LD_INT 22
11000: PUSH
11001: LD_VAR 0 5
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 30
11012: PUSH
11013: LD_INT 34
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PPUSH
11024: CALL_OW 69
11028: ST_TO_ADDR
// if teleport then
11029: LD_VAR 0 6
11033: IFFALSE 11054
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11035: LD_VAR 0 6
11039: PUSH
11040: LD_INT 1
11042: ARRAY
11043: PPUSH
11044: LD_INT 262
11046: PPUSH
11047: LD_INT 119
11049: PPUSH
11050: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11054: LD_VAR 0 4
11058: PPUSH
11059: LD_INT 1
11061: PPUSH
11062: LD_INT 19500
11064: PPUSH
11065: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11069: LD_VAR 0 4
11073: PPUSH
11074: LD_INT 2
11076: PPUSH
11077: LD_INT 200
11079: PPUSH
11080: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11084: LD_VAR 0 4
11088: PPUSH
11089: LD_INT 3
11091: PPUSH
11092: LD_INT 650
11094: PPUSH
11095: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11099: LD_ADDR_EXP 71
11103: PUSH
11104: LD_STRING Roth
11106: PPUSH
11107: CALL_OW 25
11111: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11112: LD_ADDR_EXP 72
11116: PUSH
11117: LD_STRING Simms
11119: PPUSH
11120: LD_EXP 1
11124: NOT
11125: PPUSH
11126: LD_STRING 10c_
11128: PPUSH
11129: CALL 64073 0 3
11133: ST_TO_ADDR
// if not Simms then
11134: LD_EXP 72
11138: NOT
11139: IFFALSE 11169
// begin uc_nation := 1 ;
11141: LD_ADDR_OWVAR 21
11145: PUSH
11146: LD_INT 1
11148: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11149: LD_INT 2
11151: PPUSH
11152: LD_INT 10
11154: PPUSH
11155: CALL_OW 384
// Simms := CreateHuman ;
11159: LD_ADDR_EXP 72
11163: PUSH
11164: CALL_OW 44
11168: ST_TO_ADDR
// end ; uc_nation := 3 ;
11169: LD_ADDR_OWVAR 21
11173: PUSH
11174: LD_INT 3
11176: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11177: LD_ADDR_EXP 73
11181: PUSH
11182: LD_STRING Kirilenkova
11184: PPUSH
11185: CALL_OW 25
11189: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11190: LD_ADDR_EXP 87
11194: PUSH
11195: LD_STRING Oblukov
11197: PPUSH
11198: CALL_OW 25
11202: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11203: LD_ADDR_EXP 74
11207: PUSH
11208: LD_STRING Dolgov
11210: PPUSH
11211: CALL_OW 25
11215: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11216: LD_ADDR_EXP 75
11220: PUSH
11221: LD_STRING Petrosyan
11223: PPUSH
11224: CALL_OW 25
11228: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11229: LD_ADDR_EXP 86
11233: PUSH
11234: LD_STRING Scholtze
11236: PPUSH
11237: CALL_OW 25
11241: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11242: LD_ADDR_EXP 85
11246: PUSH
11247: LD_STRING Kapitsova
11249: PPUSH
11250: CALL_OW 25
11254: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11255: LD_ADDR_EXP 76
11259: PUSH
11260: LD_STRING Petrovova
11262: PPUSH
11263: CALL_OW 25
11267: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11268: LD_ADDR_EXP 77
11272: PUSH
11273: LD_STRING Kuzmov
11275: PPUSH
11276: CALL_OW 25
11280: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11281: LD_ADDR_EXP 84
11285: PUSH
11286: LD_STRING Karamazov
11288: PPUSH
11289: CALL_OW 25
11293: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11294: LD_STRING 13_Lipshchin_1
11296: PPUSH
11297: LD_INT 0
11299: PPUSH
11300: CALL_OW 30
11304: IFFALSE 11319
// Lipshchin := NewCharacter ( Lipshchin ) ;
11306: LD_ADDR_EXP 78
11310: PUSH
11311: LD_STRING Lipshchin
11313: PPUSH
11314: CALL_OW 25
11318: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11319: LD_STRING 13_Titov_1
11321: PPUSH
11322: LD_INT 0
11324: PPUSH
11325: CALL_OW 30
11329: IFFALSE 11344
// Titov := NewCharacter ( Titov ) ;
11331: LD_ADDR_EXP 80
11335: PUSH
11336: LD_STRING Titov
11338: PPUSH
11339: CALL_OW 25
11343: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11344: LD_STRING 13_Gnyevko_1
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 30
11354: IFFALSE 11369
// Gnyevko := NewCharacter ( Gnyevko ) ;
11356: LD_ADDR_EXP 79
11360: PUSH
11361: LD_STRING Gnyevko
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11369: LD_STRING 13_Xavier_1
11371: PPUSH
11372: LD_INT 0
11374: PPUSH
11375: CALL_OW 30
11379: IFFALSE 11394
// Xavier := NewCharacter ( Xavier2 ) ;
11381: LD_ADDR_EXP 81
11385: PUSH
11386: LD_STRING Xavier2
11388: PPUSH
11389: CALL_OW 25
11393: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11394: LD_STRING 13_Belkov_1
11396: PPUSH
11397: LD_INT 0
11399: PPUSH
11400: CALL_OW 30
11404: IFFALSE 11419
// Belkov := NewCharacter ( Belkov ) ;
11406: LD_ADDR_EXP 82
11410: PUSH
11411: LD_STRING Belkov
11413: PPUSH
11414: CALL_OW 25
11418: ST_TO_ADDR
// if not BurlakStatus then
11419: LD_EXP 9
11423: NOT
11424: IFFALSE 11439
// Burlak = NewCharacter ( Burlak ) ;
11426: LD_ADDR_EXP 83
11430: PUSH
11431: LD_STRING Burlak
11433: PPUSH
11434: CALL_OW 25
11438: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11439: LD_ADDR_VAR 0 3
11443: PUSH
11444: LD_EXP 71
11448: PUSH
11449: LD_EXP 73
11453: PUSH
11454: LD_EXP 87
11458: PUSH
11459: LD_EXP 74
11463: PUSH
11464: LD_EXP 75
11468: PUSH
11469: LD_EXP 86
11473: PUSH
11474: LD_EXP 85
11478: PUSH
11479: LD_EXP 76
11483: PUSH
11484: LD_EXP 77
11488: PUSH
11489: LD_EXP 84
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: ST_TO_ADDR
// if Simms then
11506: LD_EXP 72
11510: IFFALSE 11528
// tmp := tmp ^ Simms ;
11512: LD_ADDR_VAR 0 3
11516: PUSH
11517: LD_VAR 0 3
11521: PUSH
11522: LD_EXP 72
11526: ADD
11527: ST_TO_ADDR
// if Titov then
11528: LD_EXP 80
11532: IFFALSE 11550
// tmp := tmp ^ Titov ;
11534: LD_ADDR_VAR 0 3
11538: PUSH
11539: LD_VAR 0 3
11543: PUSH
11544: LD_EXP 80
11548: ADD
11549: ST_TO_ADDR
// if Lipshchin then
11550: LD_EXP 78
11554: IFFALSE 11572
// tmp := tmp ^ Lipshchin ;
11556: LD_ADDR_VAR 0 3
11560: PUSH
11561: LD_VAR 0 3
11565: PUSH
11566: LD_EXP 78
11570: ADD
11571: ST_TO_ADDR
// if Gnyevko then
11572: LD_EXP 79
11576: IFFALSE 11594
// tmp := tmp ^ Gnyevko ;
11578: LD_ADDR_VAR 0 3
11582: PUSH
11583: LD_VAR 0 3
11587: PUSH
11588: LD_EXP 79
11592: ADD
11593: ST_TO_ADDR
// if Xavier then
11594: LD_EXP 81
11598: IFFALSE 11616
// tmp := tmp ^ Xavier ;
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: LD_VAR 0 3
11609: PUSH
11610: LD_EXP 81
11614: ADD
11615: ST_TO_ADDR
// if Belkov then
11616: LD_EXP 82
11620: IFFALSE 11638
// tmp := tmp ^ Belkov ;
11622: LD_ADDR_VAR 0 3
11626: PUSH
11627: LD_VAR 0 3
11631: PUSH
11632: LD_EXP 82
11636: ADD
11637: ST_TO_ADDR
// if Burlak then
11638: LD_EXP 83
11642: IFFALSE 11660
// tmp := tmp ^ Burlak ;
11644: LD_ADDR_VAR 0 3
11648: PUSH
11649: LD_VAR 0 3
11653: PUSH
11654: LD_EXP 83
11658: ADD
11659: ST_TO_ADDR
// for i = 1 to 8 do
11660: LD_ADDR_VAR 0 2
11664: PUSH
11665: DOUBLE
11666: LD_INT 1
11668: DEC
11669: ST_TO_ADDR
11670: LD_INT 8
11672: PUSH
11673: FOR_TO
11674: IFFALSE 11740
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11676: LD_ADDR_OWVAR 21
11680: PUSH
11681: LD_INT 1
11683: PUSH
11684: LD_INT 3
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 2
11696: PPUSH
11697: CALL_OW 12
11701: ARRAY
11702: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11703: LD_INT 0
11705: PPUSH
11706: LD_VAR 0 2
11710: PUSH
11711: LD_INT 2
11713: DIV
11714: PPUSH
11715: LD_INT 10
11717: PPUSH
11718: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: CALL_OW 44
11736: ADD
11737: ST_TO_ADDR
// end ;
11738: GO 11673
11740: POP
11741: POP
// for i in tmp do
11742: LD_ADDR_VAR 0 2
11746: PUSH
11747: LD_VAR 0 3
11751: PUSH
11752: FOR_IN
11753: IFFALSE 11778
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11755: LD_VAR 0 2
11759: PPUSH
11760: LD_INT 260
11762: PPUSH
11763: LD_INT 235
11765: PPUSH
11766: LD_INT 8
11768: PPUSH
11769: LD_INT 0
11771: PPUSH
11772: CALL_OW 50
11776: GO 11752
11778: POP
11779: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11780: LD_ADDR_EXP 99
11784: PUSH
11785: LD_EXP 99
11789: PPUSH
11790: LD_INT 1
11792: PPUSH
11793: LD_INT 22
11795: PUSH
11796: LD_VAR 0 5
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 3
11807: PUSH
11808: LD_INT 21
11810: PUSH
11811: LD_INT 2
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: PPUSH
11826: CALL_OW 69
11830: PUSH
11831: LD_EXP 71
11835: PUSH
11836: LD_EXP 72
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: DIFF
11845: PPUSH
11846: CALL_OW 1
11850: ST_TO_ADDR
// uc_side := 0 ;
11851: LD_ADDR_OWVAR 20
11855: PUSH
11856: LD_INT 0
11858: ST_TO_ADDR
// uc_nation := 0 ;
11859: LD_ADDR_OWVAR 21
11863: PUSH
11864: LD_INT 0
11866: ST_TO_ADDR
// for i = 1 to 5 do
11867: LD_ADDR_VAR 0 2
11871: PUSH
11872: DOUBLE
11873: LD_INT 1
11875: DEC
11876: ST_TO_ADDR
11877: LD_INT 5
11879: PUSH
11880: FOR_TO
11881: IFFALSE 11918
// begin InitHc ;
11883: CALL_OW 19
// hc_class := class_apeman ;
11887: LD_ADDR_OWVAR 28
11891: PUSH
11892: LD_INT 12
11894: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11895: CALL_OW 44
11899: PPUSH
11900: LD_INT 299
11902: PPUSH
11903: LD_INT 229
11905: PPUSH
11906: LD_INT 10
11908: PPUSH
11909: LD_INT 0
11911: PPUSH
11912: CALL_OW 50
// end ;
11916: GO 11880
11918: POP
11919: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11920: LD_EXP 71
11924: PPUSH
11925: LD_INT 259
11927: PPUSH
11928: LD_INT 235
11930: PPUSH
11931: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11935: LD_EXP 71
11939: PPUSH
11940: LD_INT 262
11942: PPUSH
11943: LD_INT 235
11945: PPUSH
11946: CALL_OW 178
// if Simms then
11950: LD_EXP 72
11954: IFFALSE 11985
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11956: LD_EXP 72
11960: PPUSH
11961: LD_INT 262
11963: PPUSH
11964: LD_INT 235
11966: PPUSH
11967: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11971: LD_EXP 72
11975: PPUSH
11976: LD_EXP 71
11980: PPUSH
11981: CALL_OW 179
// end ; end ;
11985: LD_VAR 0 1
11989: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11990: LD_EXP 31
11994: PUSH
11995: LD_EXP 23
11999: NOT
12000: AND
12001: IFFALSE 12177
12003: GO 12005
12005: DISABLE
12006: LD_INT 0
12008: PPUSH
12009: PPUSH
12010: PPUSH
// begin enable ;
12011: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_INT 81
12019: PUSH
12020: LD_INT 7
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 32
12032: PUSH
12033: LD_INT 3
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 30
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 30
12052: PUSH
12053: LD_INT 28
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 49
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 10
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: LD_INT 34
12082: PUSH
12083: LD_INT 8
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PPUSH
12103: CALL_OW 69
12107: ST_TO_ADDR
// if not tmp then
12108: LD_VAR 0 2
12112: NOT
12113: IFFALSE 12117
// exit ;
12115: GO 12177
// target := tmp [ rand ( 1 , tmp ) ] ;
12117: LD_ADDR_VAR 0 3
12121: PUSH
12122: LD_VAR 0 2
12126: PUSH
12127: LD_INT 1
12129: PPUSH
12130: LD_VAR 0 2
12134: PPUSH
12135: CALL_OW 12
12139: ARRAY
12140: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12141: LD_VAR 0 3
12145: PPUSH
12146: CALL_OW 255
12150: PUSH
12151: LD_INT 1
12153: EQUAL
12154: IFFALSE 12165
// CenterNowOnUnits ( target ) ;
12156: LD_VAR 0 3
12160: PPUSH
12161: CALL_OW 87
// SetLives ( target , 0 ) ;
12165: LD_VAR 0 3
12169: PPUSH
12170: LD_INT 0
12172: PPUSH
12173: CALL_OW 234
// end ;
12177: PPOPN 3
12179: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12180: LD_EXP 23
12184: NOT
12185: PUSH
12186: LD_EXP 31
12190: AND
12191: IFFALSE 12713
12193: GO 12195
12195: DISABLE
12196: LD_INT 0
12198: PPUSH
12199: PPUSH
12200: PPUSH
// begin uc_side := 7 ;
12201: LD_ADDR_OWVAR 20
12205: PUSH
12206: LD_INT 7
12208: ST_TO_ADDR
// uc_nation := 1 ;
12209: LD_ADDR_OWVAR 21
12213: PUSH
12214: LD_INT 1
12216: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_INT 125
12224: PUSH
12225: LD_INT 163
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 185
12234: PUSH
12235: LD_INT 168
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 111
12244: PUSH
12245: LD_INT 97
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: PPUSH
12257: CALL 106936 0 1
12261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12262: LD_ADDR_EXP 88
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// for i = 1 to Difficulty do
12269: LD_ADDR_VAR 0 1
12273: PUSH
12274: DOUBLE
12275: LD_INT 1
12277: DEC
12278: ST_TO_ADDR
12279: LD_OWVAR 67
12283: PUSH
12284: FOR_TO
12285: IFFALSE 12443
// begin InitHc ;
12287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12291: LD_INT 0
12293: PPUSH
12294: LD_INT 8
12296: PPUSH
12297: CALL_OW 381
// un := CreateHuman ;
12301: LD_ADDR_VAR 0 2
12305: PUSH
12306: CALL_OW 44
12310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12311: LD_VAR 0 2
12315: PPUSH
12316: LD_INT 258
12318: PPUSH
12319: LD_INT 267
12321: PPUSH
12322: LD_INT 4
12324: PPUSH
12325: LD_INT 0
12327: PPUSH
12328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12332: LD_ADDR_EXP 88
12336: PUSH
12337: LD_EXP 88
12341: PUSH
12342: LD_VAR 0 2
12346: UNION
12347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_VAR 0 3
12357: PUSH
12358: LD_VAR 0 1
12362: ARRAY
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 3
12372: PUSH
12373: LD_VAR 0 1
12377: ARRAY
12378: PUSH
12379: LD_INT 2
12381: ARRAY
12382: PPUSH
12383: LD_INT 4
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12393: LD_VAR 0 2
12397: PPUSH
12398: LD_VAR 0 3
12402: PUSH
12403: LD_VAR 0 1
12407: ARRAY
12408: PUSH
12409: LD_INT 1
12411: ARRAY
12412: PPUSH
12413: LD_VAR 0 3
12417: PUSH
12418: LD_VAR 0 1
12422: ARRAY
12423: PUSH
12424: LD_INT 2
12426: ARRAY
12427: PPUSH
12428: CALL_OW 171
// AddComInvisible ( un ) ;
12432: LD_VAR 0 2
12436: PPUSH
12437: CALL_OW 212
// end ;
12441: GO 12284
12443: POP
12444: POP
// repeat wait ( 0 0$20 ) ;
12445: LD_INT 700
12447: PPUSH
12448: CALL_OW 67
// for i in allianceSpecialForce do
12452: LD_ADDR_VAR 0 1
12456: PUSH
12457: LD_EXP 88
12461: PUSH
12462: FOR_IN
12463: IFFALSE 12698
// begin if IsInvisible ( i ) then
12465: LD_VAR 0 1
12469: PPUSH
12470: CALL_OW 571
12474: IFFALSE 12667
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_INT 22
12483: PUSH
12484: LD_INT 1
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: PUSH
12491: LD_INT 50
12493: PUSH
12494: EMPTY
12495: LIST
12496: PUSH
12497: LD_INT 56
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 91
12505: PUSH
12506: LD_VAR 0 1
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 30
12516: PUSH
12517: LD_INT 35
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: PUSH
12525: LD_OWVAR 67
12529: ARRAY
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 2
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 1
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 2
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 3
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 4
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 5
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: LD_INT 25
12591: PUSH
12592: LD_INT 8
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: PPUSH
12615: CALL_OW 69
12619: ST_TO_ADDR
// if not tmp then
12620: LD_VAR 0 3
12624: NOT
12625: IFFALSE 12629
// continue ;
12627: GO 12462
// if Prob ( 30 * Difficulty ) then
12629: LD_INT 30
12631: PUSH
12632: LD_OWVAR 67
12636: MUL
12637: PPUSH
12638: CALL_OW 13
12642: IFFALSE 12667
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12644: LD_VAR 0 3
12648: PUSH
12649: LD_INT 1
12651: PPUSH
12652: LD_VAR 0 3
12656: PPUSH
12657: CALL_OW 12
12661: ARRAY
12662: PPUSH
12663: CALL 30136 0 1
// end ; if IsDead ( i ) then
12667: LD_VAR 0 1
12671: PPUSH
12672: CALL_OW 301
12676: IFFALSE 12696
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12678: LD_ADDR_EXP 88
12682: PUSH
12683: LD_EXP 88
12687: PUSH
12688: LD_VAR 0 1
12692: DIFF
12693: ST_TO_ADDR
// continue ;
12694: GO 12462
// end ; end ;
12696: GO 12462
12698: POP
12699: POP
// until allianceDestroyed or not allianceSpecialForce ;
12700: LD_EXP 23
12704: PUSH
12705: LD_EXP 88
12709: NOT
12710: OR
12711: IFFALSE 12445
// end ;
12713: PPOPN 3
12715: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12716: LD_EXP 23
12720: NOT
12721: PUSH
12722: LD_EXP 31
12726: AND
12727: PUSH
12728: LD_INT 1
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: CALL 59147 0 2
12738: NOT
12739: AND
12740: IFFALSE 13707
12742: GO 12744
12744: DISABLE
12745: LD_INT 0
12747: PPUSH
12748: PPUSH
12749: PPUSH
12750: PPUSH
// begin enable ;
12751: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12752: LD_INT 22
12754: PUSH
12755: LD_INT 7
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 30
12764: PUSH
12765: LD_INT 3
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PPUSH
12776: CALL_OW 69
12780: NOT
12781: IFFALSE 12785
// exit ;
12783: GO 13707
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12785: LD_ADDR_VAR 0 4
12789: PUSH
12790: LD_INT 22
12792: PUSH
12793: LD_INT 7
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: LD_INT 34
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PPUSH
12814: CALL_OW 69
12818: ST_TO_ADDR
// if Prob ( 40 ) then
12819: LD_INT 40
12821: PPUSH
12822: CALL_OW 13
12826: IFFALSE 12953
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12828: LD_INT 1
12830: PPUSH
12831: LD_INT 5
12833: PUSH
12834: LD_INT 3
12836: PUSH
12837: LD_INT 2
12839: PUSH
12840: LD_INT 6
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: PUSH
12849: LD_INT 5
12851: PUSH
12852: LD_INT 3
12854: PUSH
12855: LD_INT 2
12857: PUSH
12858: LD_INT 6
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 5
12869: PUSH
12870: LD_INT 3
12872: PUSH
12873: LD_INT 2
12875: PUSH
12876: LD_INT 6
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 24
12887: PUSH
12888: LD_INT 3
12890: PUSH
12891: LD_INT 3
12893: PUSH
12894: LD_INT 45
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 24
12905: PUSH
12906: LD_INT 3
12908: PUSH
12909: LD_INT 3
12911: PUSH
12912: LD_INT 47
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 24
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: LD_INT 45
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: LIST
12937: LIST
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PPUSH
12947: CALL 57729 0 2
// end else
12951: GO 13076
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12953: LD_INT 1
12955: PPUSH
12956: LD_INT 24
12958: PUSH
12959: LD_INT 3
12961: PUSH
12962: LD_INT 3
12964: PUSH
12965: LD_INT 47
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 24
12976: PUSH
12977: LD_INT 3
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: LD_INT 47
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 5
12994: PUSH
12995: LD_INT 3
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 9
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: PUSH
13010: LD_INT 5
13012: PUSH
13013: LD_INT 3
13015: PUSH
13016: LD_INT 2
13018: PUSH
13019: LD_INT 9
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 24
13030: PUSH
13031: LD_INT 1
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: LD_INT 45
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PUSH
13046: LD_INT 24
13048: PUSH
13049: LD_INT 1
13051: PUSH
13052: LD_INT 3
13054: PUSH
13055: LD_INT 45
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: LIST
13071: PPUSH
13072: CALL 57729 0 2
// end ; if Difficulty > 1 then
13076: LD_OWVAR 67
13080: PUSH
13081: LD_INT 1
13083: GREATER
13084: IFFALSE 13114
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13086: LD_INT 1
13088: PPUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 47
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: PPUSH
13110: CALL 57729 0 2
// repeat wait ( 0 0$1 ) ;
13114: LD_INT 35
13116: PPUSH
13117: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 1
13126: PPUSH
13127: CALL 59147 0 2
13131: PUSH
13132: LD_INT 6
13134: PUSH
13135: LD_INT 7
13137: PUSH
13138: LD_INT 7
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: PUSH
13146: LD_OWVAR 67
13150: ARRAY
13151: GREATEREQUAL
13152: IFFALSE 13114
// wait ( 0 0$40 ) ;
13154: LD_INT 1400
13156: PPUSH
13157: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13161: LD_ADDR_VAR 0 2
13165: PUSH
13166: LD_INT 1
13168: PPUSH
13169: LD_INT 1
13171: PPUSH
13172: CALL 59147 0 2
13176: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13177: LD_ADDR_EXP 118
13181: PUSH
13182: LD_EXP 118
13186: PPUSH
13187: LD_INT 1
13189: PPUSH
13190: LD_EXP 118
13194: PUSH
13195: LD_INT 1
13197: ARRAY
13198: PUSH
13199: LD_VAR 0 2
13203: DIFF
13204: PPUSH
13205: CALL_OW 1
13209: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: PPUSH
13218: LD_INT 1
13220: PPUSH
13221: CALL_OW 12
13225: ST_TO_ADDR
// if target then
13226: LD_VAR 0 3
13230: IFFALSE 13396
// begin for i in tmp do
13232: LD_ADDR_VAR 0 1
13236: PUSH
13237: LD_VAR 0 2
13241: PUSH
13242: FOR_IN
13243: IFFALSE 13268
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13245: LD_VAR 0 1
13249: PPUSH
13250: LD_INT 179
13252: PPUSH
13253: LD_INT 209
13255: PPUSH
13256: LD_INT 8
13258: PPUSH
13259: LD_INT 1
13261: PPUSH
13262: CALL_OW 483
13266: GO 13242
13268: POP
13269: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13270: LD_ADDR_VAR 0 2
13274: PUSH
13275: LD_VAR 0 2
13279: PPUSH
13280: LD_INT 24
13282: PUSH
13283: LD_INT 250
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PPUSH
13290: CALL_OW 72
13294: ST_TO_ADDR
// for i in tmp do
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: FOR_IN
13306: IFFALSE 13346
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13308: LD_VAR 0 1
13312: PPUSH
13313: LD_INT 179
13315: PPUSH
13316: LD_INT 209
13318: PPUSH
13319: CALL_OW 297
13323: PUSH
13324: LD_INT 9
13326: GREATER
13327: IFFALSE 13344
// ComMoveXY ( i , 179 , 209 ) ;
13329: LD_VAR 0 1
13333: PPUSH
13334: LD_INT 179
13336: PPUSH
13337: LD_INT 209
13339: PPUSH
13340: CALL_OW 111
13344: GO 13305
13346: POP
13347: POP
// wait ( 0 0$1 ) ;
13348: LD_INT 35
13350: PPUSH
13351: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13355: LD_VAR 0 2
13359: PPUSH
13360: LD_INT 92
13362: PUSH
13363: LD_INT 179
13365: PUSH
13366: LD_INT 209
13368: PUSH
13369: LD_INT 9
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: PPUSH
13378: CALL_OW 72
13382: PUSH
13383: LD_VAR 0 2
13387: PUSH
13388: LD_INT 1
13390: MINUS
13391: GREATEREQUAL
13392: IFFALSE 13270
// end else
13394: GO 13558
// begin for i in tmp do
13396: LD_ADDR_VAR 0 1
13400: PUSH
13401: LD_VAR 0 2
13405: PUSH
13406: FOR_IN
13407: IFFALSE 13432
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13409: LD_VAR 0 1
13413: PPUSH
13414: LD_INT 285
13416: PPUSH
13417: LD_INT 163
13419: PPUSH
13420: LD_INT 8
13422: PPUSH
13423: LD_INT 1
13425: PPUSH
13426: CALL_OW 483
13430: GO 13406
13432: POP
13433: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_VAR 0 2
13443: PPUSH
13444: LD_INT 24
13446: PUSH
13447: LD_INT 250
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 72
13458: ST_TO_ADDR
// for i in tmp do
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_VAR 0 2
13468: PUSH
13469: FOR_IN
13470: IFFALSE 13510
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13472: LD_VAR 0 1
13476: PPUSH
13477: LD_INT 285
13479: PPUSH
13480: LD_INT 163
13482: PPUSH
13483: CALL_OW 297
13487: PUSH
13488: LD_INT 9
13490: GREATER
13491: IFFALSE 13508
// ComMoveXY ( i , 285 , 163 ) ;
13493: LD_VAR 0 1
13497: PPUSH
13498: LD_INT 285
13500: PPUSH
13501: LD_INT 163
13503: PPUSH
13504: CALL_OW 111
13508: GO 13469
13510: POP
13511: POP
// wait ( 0 0$1 ) ;
13512: LD_INT 35
13514: PPUSH
13515: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13519: LD_VAR 0 2
13523: PPUSH
13524: LD_INT 92
13526: PUSH
13527: LD_INT 285
13529: PUSH
13530: LD_INT 163
13532: PUSH
13533: LD_INT 9
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 72
13546: PUSH
13547: LD_VAR 0 2
13551: PUSH
13552: LD_INT 1
13554: MINUS
13555: GREATEREQUAL
13556: IFFALSE 13434
// end ; repeat wait ( 0 0$1 ) ;
13558: LD_INT 35
13560: PPUSH
13561: CALL_OW 67
// for i in tmp do
13565: LD_ADDR_VAR 0 1
13569: PUSH
13570: LD_VAR 0 2
13574: PUSH
13575: FOR_IN
13576: IFFALSE 13698
// if GetLives ( i ) > 251 then
13578: LD_VAR 0 1
13582: PPUSH
13583: CALL_OW 256
13587: PUSH
13588: LD_INT 251
13590: GREATER
13591: IFFALSE 13680
// begin if GetWeapon ( i ) = ru_time_lapser then
13593: LD_VAR 0 1
13597: PPUSH
13598: CALL_OW 264
13602: PUSH
13603: LD_INT 49
13605: EQUAL
13606: IFFALSE 13644
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13608: LD_VAR 0 1
13612: PPUSH
13613: LD_INT 81
13615: PUSH
13616: LD_INT 7
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PPUSH
13623: CALL_OW 69
13627: PPUSH
13628: LD_VAR 0 1
13632: PPUSH
13633: CALL_OW 74
13637: PPUSH
13638: CALL_OW 112
13642: GO 13678
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13644: LD_VAR 0 1
13648: PPUSH
13649: LD_INT 81
13651: PUSH
13652: LD_INT 7
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: PPUSH
13659: CALL_OW 69
13663: PPUSH
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL_OW 74
13673: PPUSH
13674: CALL_OW 115
// end else
13678: GO 13696
// tmp := tmp diff i ;
13680: LD_ADDR_VAR 0 2
13684: PUSH
13685: LD_VAR 0 2
13689: PUSH
13690: LD_VAR 0 1
13694: DIFF
13695: ST_TO_ADDR
13696: GO 13575
13698: POP
13699: POP
// until not tmp ;
13700: LD_VAR 0 2
13704: NOT
13705: IFFALSE 13558
// end ; end_of_file
13707: PPOPN 4
13709: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13710: LD_INT 0
13712: PPUSH
13713: PPUSH
13714: PPUSH
13715: PPUSH
// missionStage := 13 ;
13716: LD_ADDR_EXP 15
13720: PUSH
13721: LD_INT 13
13723: ST_TO_ADDR
// uc_side := 2 ;
13724: LD_ADDR_OWVAR 20
13728: PUSH
13729: LD_INT 2
13731: ST_TO_ADDR
// uc_nation := 2 ;
13732: LD_ADDR_OWVAR 21
13736: PUSH
13737: LD_INT 2
13739: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13740: LD_ADDR_EXP 89
13744: PUSH
13745: LD_STRING Omar
13747: PPUSH
13748: CALL_OW 25
13752: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13753: LD_EXP 89
13757: PPUSH
13758: LD_INT 4
13760: PPUSH
13761: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13765: LD_EXP 89
13769: PPUSH
13770: LD_INT 242
13772: PPUSH
13773: LD_INT 75
13775: PPUSH
13776: LD_INT 0
13778: PPUSH
13779: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13783: LD_ADDR_EXP 90
13787: PUSH
13788: LD_STRING Heike
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13796: LD_INT 14
13798: PPUSH
13799: LD_INT 3
13801: PPUSH
13802: LD_INT 1
13804: PPUSH
13805: LD_INT 27
13807: PPUSH
13808: LD_INT 100
13810: PPUSH
13811: CALL 71099 0 5
// veh := CreateVehicle ;
13815: LD_ADDR_VAR 0 3
13819: PUSH
13820: CALL_OW 45
13824: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13825: LD_VAR 0 3
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL_OW 242
// SetDir ( veh , 4 ) ;
13837: LD_VAR 0 3
13841: PPUSH
13842: LD_INT 4
13844: PPUSH
13845: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13849: LD_VAR 0 3
13853: PPUSH
13854: LD_INT 241
13856: PPUSH
13857: LD_INT 72
13859: PPUSH
13860: LD_INT 0
13862: PPUSH
13863: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13867: LD_EXP 90
13871: PPUSH
13872: LD_VAR 0 3
13876: PPUSH
13877: CALL_OW 52
// if KhatamStatus then
13881: LD_EXP 8
13885: IFFALSE 13936
// begin Khatam := NewCharacter ( Khatam ) ;
13887: LD_ADDR_EXP 91
13891: PUSH
13892: LD_STRING Khatam
13894: PPUSH
13895: CALL_OW 25
13899: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13900: LD_EXP 91
13904: PPUSH
13905: LD_INT 245
13907: PPUSH
13908: LD_INT 78
13910: PPUSH
13911: LD_INT 3
13913: PPUSH
13914: LD_INT 0
13916: PPUSH
13917: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13921: LD_EXP 91
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: LD_INT 10
13931: PPUSH
13932: CALL_OW 237
// end ; for i = 1 to Difficulty do
13936: LD_ADDR_VAR 0 2
13940: PUSH
13941: DOUBLE
13942: LD_INT 1
13944: DEC
13945: ST_TO_ADDR
13946: LD_OWVAR 67
13950: PUSH
13951: FOR_TO
13952: IFFALSE 14018
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13954: LD_INT 0
13956: PPUSH
13957: LD_INT 7
13959: PUSH
13960: LD_OWVAR 67
13964: PLUS
13965: PPUSH
13966: CALL_OW 384
// un := CreateHuman ;
13970: LD_ADDR_VAR 0 4
13974: PUSH
13975: CALL_OW 44
13979: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13980: LD_VAR 0 4
13984: PPUSH
13985: LD_INT 28
13987: PUSH
13988: LD_INT 29
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PUSH
13995: LD_VAR 0 2
13999: PUSH
14000: LD_INT 2
14002: MOD
14003: PUSH
14004: LD_INT 1
14006: PLUS
14007: ARRAY
14008: PPUSH
14009: LD_INT 0
14011: PPUSH
14012: CALL_OW 49
// end ;
14016: GO 13951
14018: POP
14019: POP
// for i = 1 to 6 do
14020: LD_ADDR_VAR 0 2
14024: PUSH
14025: DOUBLE
14026: LD_INT 1
14028: DEC
14029: ST_TO_ADDR
14030: LD_INT 6
14032: PUSH
14033: FOR_TO
14034: IFFALSE 14079
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14036: LD_INT 0
14038: PPUSH
14039: LD_INT 7
14041: PUSH
14042: LD_OWVAR 67
14046: PLUS
14047: PPUSH
14048: CALL_OW 381
// un := CreateHuman ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: CALL_OW 44
14061: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14062: LD_VAR 0 4
14066: PPUSH
14067: LD_INT 28
14069: PPUSH
14070: LD_INT 0
14072: PPUSH
14073: CALL_OW 49
// end ;
14077: GO 14033
14079: POP
14080: POP
// for i = 1 to 3 do
14081: LD_ADDR_VAR 0 2
14085: PUSH
14086: DOUBLE
14087: LD_INT 1
14089: DEC
14090: ST_TO_ADDR
14091: LD_INT 3
14093: PUSH
14094: FOR_TO
14095: IFFALSE 14143
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14097: LD_INT 0
14099: PPUSH
14100: LD_INT 8
14102: PPUSH
14103: LD_INT 7
14105: PUSH
14106: LD_OWVAR 67
14110: PLUS
14111: PPUSH
14112: CALL_OW 380
// un := CreateHuman ;
14116: LD_ADDR_VAR 0 4
14120: PUSH
14121: CALL_OW 44
14125: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14126: LD_VAR 0 4
14130: PPUSH
14131: LD_INT 28
14133: PPUSH
14134: LD_INT 0
14136: PPUSH
14137: CALL_OW 49
// end ;
14141: GO 14094
14143: POP
14144: POP
// for i = 1 to 3 do
14145: LD_ADDR_VAR 0 2
14149: PUSH
14150: DOUBLE
14151: LD_INT 1
14153: DEC
14154: ST_TO_ADDR
14155: LD_INT 3
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14249
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14161: LD_INT 14
14163: PPUSH
14164: LD_INT 2
14166: PPUSH
14167: LD_INT 1
14169: PPUSH
14170: LD_INT 28
14172: PPUSH
14173: LD_INT 80
14175: PPUSH
14176: CALL 71099 0 5
// veh := CreateVehicle ;
14180: LD_ADDR_VAR 0 3
14184: PUSH
14185: CALL_OW 45
14189: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14190: LD_VAR 0 3
14194: PPUSH
14195: LD_INT 3
14197: PPUSH
14198: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14202: LD_VAR 0 3
14206: PPUSH
14207: LD_INT 29
14209: PPUSH
14210: LD_INT 0
14212: PPUSH
14213: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14217: LD_INT 0
14219: PPUSH
14220: LD_INT 7
14222: PUSH
14223: LD_OWVAR 67
14227: PLUS
14228: PPUSH
14229: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14233: CALL_OW 44
14237: PPUSH
14238: LD_VAR 0 3
14242: PPUSH
14243: CALL_OW 52
// end ;
14247: GO 14158
14249: POP
14250: POP
// for i = 1 to 5 + Difficulty do
14251: LD_ADDR_VAR 0 2
14255: PUSH
14256: DOUBLE
14257: LD_INT 1
14259: DEC
14260: ST_TO_ADDR
14261: LD_INT 5
14263: PUSH
14264: LD_OWVAR 67
14268: PLUS
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14398
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14273: LD_INT 14
14275: PPUSH
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 3
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: LD_INT 28
14292: PUSH
14293: LD_INT 26
14295: PUSH
14296: LD_INT 27
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: EMPTY
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: PUSH
14308: LD_VAR 0 2
14312: PUSH
14313: LD_INT 4
14315: MOD
14316: PUSH
14317: LD_INT 1
14319: PLUS
14320: ARRAY
14321: PPUSH
14322: LD_INT 80
14324: PPUSH
14325: CALL 71099 0 5
// veh := CreateVehicle ;
14329: LD_ADDR_VAR 0 3
14333: PUSH
14334: CALL_OW 45
14338: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14339: LD_VAR 0 3
14343: PPUSH
14344: LD_INT 4
14346: PPUSH
14347: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14351: LD_VAR 0 3
14355: PPUSH
14356: LD_INT 28
14358: PPUSH
14359: LD_INT 0
14361: PPUSH
14362: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14366: LD_INT 0
14368: PPUSH
14369: LD_INT 7
14371: PUSH
14372: LD_OWVAR 67
14376: PLUS
14377: PPUSH
14378: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14382: CALL_OW 44
14386: PPUSH
14387: LD_VAR 0 3
14391: PPUSH
14392: CALL_OW 52
// end ;
14396: GO 14270
14398: POP
14399: POP
// for i = 1 to 3 do
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: DOUBLE
14406: LD_INT 1
14408: DEC
14409: ST_TO_ADDR
14410: LD_INT 3
14412: PUSH
14413: FOR_TO
14414: IFFALSE 14474
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14416: LD_INT 14
14418: PPUSH
14419: LD_INT 3
14421: PPUSH
14422: LD_INT 5
14424: PPUSH
14425: LD_INT 29
14427: PPUSH
14428: LD_INT 80
14430: PPUSH
14431: CALL 71099 0 5
// veh := CreateVehicle ;
14435: LD_ADDR_VAR 0 3
14439: PUSH
14440: CALL_OW 45
14444: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14445: LD_VAR 0 3
14449: PPUSH
14450: LD_INT 4
14452: PPUSH
14453: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14457: LD_VAR 0 3
14461: PPUSH
14462: LD_INT 28
14464: PPUSH
14465: LD_INT 0
14467: PPUSH
14468: CALL_OW 49
// end ;
14472: GO 14413
14474: POP
14475: POP
// end ;
14476: LD_VAR 0 1
14480: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14481: LD_INT 22
14483: PUSH
14484: LD_INT 2
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PPUSH
14491: CALL_OW 69
14495: IFFALSE 14795
14497: GO 14499
14499: DISABLE
14500: LD_INT 0
14502: PPUSH
14503: PPUSH
14504: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14505: LD_ADDR_VAR 0 3
14509: PUSH
14510: LD_INT 22
14512: PUSH
14513: LD_INT 2
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: LD_INT 25
14522: PUSH
14523: LD_INT 4
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: PUSH
14539: LD_EXP 91
14543: DIFF
14544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14545: LD_ADDR_VAR 0 2
14549: PUSH
14550: LD_INT 22
14552: PUSH
14553: LD_INT 2
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: PPUSH
14560: CALL_OW 69
14564: PUSH
14565: LD_EXP 91
14569: PUSH
14570: LD_VAR 0 3
14574: UNION
14575: DIFF
14576: ST_TO_ADDR
// if Khatam then
14577: LD_EXP 91
14581: IFFALSE 14598
// ComMoveXY ( Khatam , 211 , 92 ) ;
14583: LD_EXP 91
14587: PPUSH
14588: LD_INT 211
14590: PPUSH
14591: LD_INT 92
14593: PPUSH
14594: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14598: LD_INT 197
14600: PPUSH
14601: LD_INT 80
14603: PPUSH
14604: LD_INT 2
14606: PPUSH
14607: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14611: LD_INT 213
14613: PPUSH
14614: LD_INT 90
14616: PPUSH
14617: LD_INT 2
14619: PPUSH
14620: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14624: LD_INT 215
14626: PPUSH
14627: LD_INT 129
14629: PPUSH
14630: LD_INT 2
14632: PPUSH
14633: CALL_OW 441
// if sci then
14637: LD_VAR 0 3
14641: IFFALSE 14662
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14643: LD_VAR 0 3
14647: PUSH
14648: LD_INT 1
14650: ARRAY
14651: PPUSH
14652: LD_INT 197
14654: PPUSH
14655: LD_INT 80
14657: PPUSH
14658: CALL_OW 158
// if sci > 1 then
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 1
14669: GREATER
14670: IFFALSE 14691
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14672: LD_VAR 0 3
14676: PUSH
14677: LD_INT 2
14679: ARRAY
14680: PPUSH
14681: LD_INT 213
14683: PPUSH
14684: LD_INT 90
14686: PPUSH
14687: CALL_OW 158
// if sci > 2 then
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 2
14698: GREATER
14699: IFFALSE 14720
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14701: LD_VAR 0 3
14705: PUSH
14706: LD_INT 3
14708: ARRAY
14709: PPUSH
14710: LD_INT 215
14712: PPUSH
14713: LD_INT 129
14715: PPUSH
14716: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14720: LD_INT 35
14722: PPUSH
14723: CALL_OW 67
// for i in tmp do
14727: LD_ADDR_VAR 0 1
14731: PUSH
14732: LD_VAR 0 2
14736: PUSH
14737: FOR_IN
14738: IFFALSE 14776
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_INT 81
14747: PUSH
14748: LD_INT 2
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 69
14759: PPUSH
14760: LD_VAR 0 1
14764: PPUSH
14765: CALL_OW 74
14769: PPUSH
14770: CALL_OW 115
14774: GO 14737
14776: POP
14777: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14778: LD_INT 22
14780: PUSH
14781: LD_INT 2
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 69
14792: NOT
14793: IFFALSE 14720
// end ; end_of_file
14795: PPOPN 3
14797: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14798: LD_INT 0
14800: PPUSH
14801: PPUSH
14802: PPUSH
14803: PPUSH
14804: PPUSH
14805: PPUSH
14806: PPUSH
14807: PPUSH
14808: PPUSH
// Video ( true ) ;
14809: LD_INT 1
14811: PPUSH
14812: CALL 106816 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14816: LD_ADDR_VAR 0 5
14820: PUSH
14821: LD_INT 7
14823: PPUSH
14824: LD_INT 0
14826: PPUSH
14827: CALL_OW 517
14831: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14832: LD_ADDR_VAR 0 2
14836: PUSH
14837: DOUBLE
14838: LD_INT 1
14840: DEC
14841: ST_TO_ADDR
14842: LD_VAR 0 5
14846: PUSH
14847: LD_INT 1
14849: ARRAY
14850: PUSH
14851: FOR_TO
14852: IFFALSE 14897
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14854: LD_VAR 0 5
14858: PUSH
14859: LD_INT 1
14861: ARRAY
14862: PUSH
14863: LD_VAR 0 2
14867: ARRAY
14868: PPUSH
14869: LD_VAR 0 5
14873: PUSH
14874: LD_INT 2
14876: ARRAY
14877: PUSH
14878: LD_VAR 0 2
14882: ARRAY
14883: PPUSH
14884: LD_INT 1
14886: PPUSH
14887: LD_INT 15
14889: NEG
14890: PPUSH
14891: CALL 106730 0 4
14895: GO 14851
14897: POP
14898: POP
// CenterNowOnUnits ( Powell ) ;
14899: LD_EXP 55
14903: PPUSH
14904: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14908: LD_ADDR_VAR 0 5
14912: PUSH
14913: LD_EXP 53
14917: PUSH
14918: EMPTY
14919: LIST
14920: ST_TO_ADDR
// if GirlNewVeh then
14921: LD_EXP 54
14925: IFFALSE 14943
// tmp := tmp ^ GirlNewVeh ;
14927: LD_ADDR_VAR 0 5
14931: PUSH
14932: LD_VAR 0 5
14936: PUSH
14937: LD_EXP 54
14941: ADD
14942: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14943: LD_VAR 0 5
14947: PPUSH
14948: LD_INT 60
14950: PPUSH
14951: LD_INT 109
14953: PPUSH
14954: CALL_OW 111
// if KappaStatus then
14958: LD_EXP 2
14962: IFFALSE 15014
// begin Say ( JMM , D1nT-JMM-1 ) ;
14964: LD_EXP 36
14968: PPUSH
14969: LD_STRING D1nT-JMM-1
14971: PPUSH
14972: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14976: LD_EXP 55
14980: PPUSH
14981: LD_STRING D1T-Pow-1
14983: PPUSH
14984: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14988: LD_EXP 36
14992: PPUSH
14993: LD_STRING D1T-JMM-2
14995: PPUSH
14996: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15000: LD_EXP 55
15004: PPUSH
15005: LD_STRING D1T-Pow-2
15007: PPUSH
15008: CALL_OW 88
// end else
15012: GO 15220
// if JMMGirlStatus then
15014: LD_EXP 6
15018: IFFALSE 15163
// begin Say ( JMM , D1T-JMM-1 ) ;
15020: LD_EXP 36
15024: PPUSH
15025: LD_STRING D1T-JMM-1
15027: PPUSH
15028: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15032: LD_EXP 55
15036: PPUSH
15037: LD_STRING D1T-Pow-1
15039: PPUSH
15040: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15044: LD_EXP 36
15048: PPUSH
15049: LD_STRING D1T-JMM-3
15051: PPUSH
15052: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15056: LD_EXP 55
15060: PPUSH
15061: LD_STRING D1T-Pow-3
15063: PPUSH
15064: CALL_OW 88
// if JMMGirl then
15068: LD_EXP 7
15072: IFFALSE 15161
// begin case JMMGirl of 1 :
15074: LD_EXP 7
15078: PUSH
15079: LD_INT 1
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15102
15087: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15088: LD_EXP 37
15092: PPUSH
15093: LD_STRING D1T-Joan-3
15095: PPUSH
15096: CALL_OW 88
15100: GO 15149
15102: LD_INT 2
15104: DOUBLE
15105: EQUAL
15106: IFTRUE 15110
15108: GO 15125
15110: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15111: LD_EXP 39
15115: PPUSH
15116: LD_STRING D1T-Lisa-3
15118: PPUSH
15119: CALL_OW 88
15123: GO 15149
15125: LD_INT 3
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15148
15133: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15134: LD_EXP 51
15138: PPUSH
15139: LD_STRING D1T-Con-3
15141: PPUSH
15142: CALL_OW 88
15146: GO 15149
15148: POP
// Say ( Powell , D1T-Pow-4 ) ;
15149: LD_EXP 55
15153: PPUSH
15154: LD_STRING D1T-Pow-4
15156: PPUSH
15157: CALL_OW 88
// end ; end else
15161: GO 15220
// if not FastEnd then
15163: LD_EXP 11
15167: NOT
15168: IFFALSE 15196
// begin Say ( JMM , D1T-JMM-4 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_STRING D1T-JMM-4
15177: PPUSH
15178: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15182: LD_EXP 55
15186: PPUSH
15187: LD_STRING D1T-Pow-5
15189: PPUSH
15190: CALL_OW 88
// end else
15194: GO 15220
// begin Say ( JMM , D1nT-JMM-1 ) ;
15196: LD_EXP 36
15200: PPUSH
15201: LD_STRING D1nT-JMM-1
15203: PPUSH
15204: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15208: LD_EXP 55
15212: PPUSH
15213: LD_STRING D1nT-Pow-1
15215: PPUSH
15216: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15220: LD_INT 35
15222: PPUSH
15223: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15227: LD_EXP 53
15231: PPUSH
15232: CALL_OW 314
15236: NOT
15237: IFFALSE 15220
// ComExitVehicle ( JMM ) ;
15239: LD_EXP 36
15243: PPUSH
15244: CALL_OW 121
// wait ( 3 ) ;
15248: LD_INT 3
15250: PPUSH
15251: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15255: LD_EXP 36
15259: PPUSH
15260: LD_INT 60
15262: PPUSH
15263: LD_INT 94
15265: PPUSH
15266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15270: LD_EXP 36
15274: PPUSH
15275: LD_EXP 55
15279: PPUSH
15280: CALL_OW 179
// if Joan then
15284: LD_EXP 37
15288: IFFALSE 15342
// begin ComExitVehicle ( Joan ) ;
15290: LD_EXP 37
15294: PPUSH
15295: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15299: LD_EXP 37
15303: PPUSH
15304: LD_INT 35
15306: PPUSH
15307: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15311: LD_EXP 37
15315: PPUSH
15316: LD_INT 65
15318: PPUSH
15319: LD_INT 104
15321: PPUSH
15322: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15326: LD_EXP 37
15330: PPUSH
15331: LD_EXP 36
15335: PPUSH
15336: CALL_OW 179
// end else
15340: GO 15476
// if Lisa and JMMGirl = 2 then
15342: LD_EXP 39
15346: PUSH
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 2
15354: EQUAL
15355: AND
15356: IFFALSE 15410
// begin ComExitVehicle ( Lisa ) ;
15358: LD_EXP 39
15362: PPUSH
15363: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15367: LD_EXP 39
15371: PPUSH
15372: LD_INT 35
15374: PPUSH
15375: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15379: LD_EXP 39
15383: PPUSH
15384: LD_INT 65
15386: PPUSH
15387: LD_INT 104
15389: PPUSH
15390: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15394: LD_EXP 39
15398: PPUSH
15399: LD_EXP 36
15403: PPUSH
15404: CALL_OW 179
// end else
15408: GO 15476
// if Connie and JMMGirl = 3 then
15410: LD_EXP 51
15414: PUSH
15415: LD_EXP 7
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15476
// begin ComExitVehicle ( Connie ) ;
15426: LD_EXP 51
15430: PPUSH
15431: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15435: LD_EXP 51
15439: PPUSH
15440: LD_INT 35
15442: PPUSH
15443: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15447: LD_EXP 51
15451: PPUSH
15452: LD_INT 65
15454: PPUSH
15455: LD_INT 104
15457: PPUSH
15458: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15462: LD_EXP 51
15466: PPUSH
15467: LD_EXP 36
15471: PPUSH
15472: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15476: LD_INT 35
15478: PPUSH
15479: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15483: LD_EXP 36
15487: PPUSH
15488: LD_EXP 55
15492: PPUSH
15493: CALL_OW 296
15497: PUSH
15498: LD_INT 6
15500: LESS
15501: IFFALSE 15476
// wait ( 0 0$0.5 ) ;
15503: LD_INT 18
15505: PPUSH
15506: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15510: LD_EXP 36
15514: PPUSH
15515: LD_STRING D1-JMM-1
15517: PPUSH
15518: CALL_OW 88
// async ;
15522: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15523: LD_EXP 55
15527: PPUSH
15528: LD_STRING D1-Pow-1
15530: PPUSH
15531: CALL_OW 88
// if not dialogue_skipped then
15535: LD_OWVAR 59
15539: NOT
15540: IFFALSE 15549
// wait ( 0 0$2 ) ;
15542: LD_INT 70
15544: PPUSH
15545: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15549: LD_INT 170
15551: PPUSH
15552: LD_INT 99
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 6
15560: NEG
15561: PPUSH
15562: CALL 106730 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15566: LD_INT 174
15568: PPUSH
15569: LD_INT 115
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: LD_INT 6
15577: NEG
15578: PPUSH
15579: CALL 106730 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15583: LD_INT 169
15585: PPUSH
15586: LD_INT 71
15588: PPUSH
15589: LD_INT 1
15591: PPUSH
15592: LD_INT 6
15594: NEG
15595: PPUSH
15596: CALL 106730 0 4
// if not dialogue_skipped then
15600: LD_OWVAR 59
15604: NOT
15605: IFFALSE 15624
// begin CenterOnXY ( 170 , 99 ) ;
15607: LD_INT 170
15609: PPUSH
15610: LD_INT 99
15612: PPUSH
15613: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15617: LD_INT 80
15619: PPUSH
15620: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15624: LD_INT 75
15626: PPUSH
15627: LD_INT 53
15629: PPUSH
15630: LD_INT 1
15632: PPUSH
15633: LD_INT 9
15635: NEG
15636: PPUSH
15637: CALL 106730 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15641: LD_INT 54
15643: PPUSH
15644: LD_INT 42
15646: PPUSH
15647: LD_INT 1
15649: PPUSH
15650: LD_INT 9
15652: NEG
15653: PPUSH
15654: CALL 106730 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15658: LD_INT 62
15660: PPUSH
15661: LD_INT 51
15663: PPUSH
15664: LD_INT 1
15666: PPUSH
15667: LD_INT 9
15669: NEG
15670: PPUSH
15671: CALL 106730 0 4
// if not dialogue_skipped then
15675: LD_OWVAR 59
15679: NOT
15680: IFFALSE 15699
// begin CenterOnXY ( 75 , 53 ) ;
15682: LD_INT 75
15684: PPUSH
15685: LD_INT 53
15687: PPUSH
15688: CALL_OW 84
// wait ( 0 0$4 ) ;
15692: LD_INT 140
15694: PPUSH
15695: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15699: LD_EXP 55
15703: PPUSH
15704: CALL_OW 87
// if not dialogue_skipped then
15708: LD_OWVAR 59
15712: NOT
15713: IFFALSE 15722
// wait ( 0 0$2 ) ;
15715: LD_INT 70
15717: PPUSH
15718: CALL_OW 67
// sync ;
15722: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15723: LD_EXP 36
15727: PPUSH
15728: LD_STRING D1-JMM-2
15730: PPUSH
15731: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15735: LD_EXP 55
15739: PPUSH
15740: LD_STRING D1-Pow-2
15742: PPUSH
15743: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15747: LD_EXP 36
15751: PPUSH
15752: LD_STRING D1-JMM-3
15754: PPUSH
15755: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15759: LD_EXP 55
15763: PPUSH
15764: LD_STRING D1-Pow-3
15766: PPUSH
15767: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15771: LD_EXP 36
15775: PPUSH
15776: LD_STRING D1-JMM-4
15778: PPUSH
15779: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15783: LD_EXP 55
15787: PPUSH
15788: LD_STRING D1-Pow-4
15790: PPUSH
15791: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15795: LD_EXP 36
15799: PPUSH
15800: LD_STRING D1-JMM-5
15802: PPUSH
15803: CALL_OW 88
// async ;
15807: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15808: LD_EXP 55
15812: PPUSH
15813: LD_STRING D1-Pow-5
15815: PPUSH
15816: CALL_OW 88
// if not dialogue_skipped then
15820: LD_OWVAR 59
15824: NOT
15825: IFFALSE 15834
// wait ( 0 0$3.6 ) ;
15827: LD_INT 126
15829: PPUSH
15830: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15834: LD_INT 134
15836: PPUSH
15837: LD_INT 210
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 11
15845: NEG
15846: PPUSH
15847: CALL 106730 0 4
// if not dialogue_skipped then
15851: LD_OWVAR 59
15855: NOT
15856: IFFALSE 15875
// begin CenterOnXY ( 134 , 210 ) ;
15858: LD_INT 134
15860: PPUSH
15861: LD_INT 210
15863: PPUSH
15864: CALL_OW 84
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15875: LD_INT 101
15877: PPUSH
15878: LD_INT 159
15880: PPUSH
15881: LD_INT 1
15883: PPUSH
15884: LD_INT 10
15886: NEG
15887: PPUSH
15888: CALL 106730 0 4
// if not dialogue_skipped then
15892: LD_OWVAR 59
15896: NOT
15897: IFFALSE 15916
// begin CenterOnXY ( 101 , 159 ) ;
15899: LD_INT 101
15901: PPUSH
15902: LD_INT 159
15904: PPUSH
15905: CALL_OW 84
// wait ( 0 0$2 ) ;
15909: LD_INT 70
15911: PPUSH
15912: CALL_OW 67
// end ; sync ;
15916: SYNC
// CenterNowOnUnits ( Powell ) ;
15917: LD_EXP 55
15921: PPUSH
15922: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15926: LD_ADDR_VAR 0 6
15930: PUSH
15931: LD_INT 1
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: LD_INT 5
15945: PUSH
15946: LD_INT 6
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: LIST
15956: ST_TO_ADDR
// if not dialogue_skipped then
15957: LD_OWVAR 59
15961: NOT
15962: IFFALSE 16131
// begin game_speed := 4 ;
15964: LD_ADDR_OWVAR 65
15968: PUSH
15969: LD_INT 4
15971: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15972: LD_INT 210
15974: PPUSH
15975: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15979: LD_ADDR_VAR 0 7
15983: PUSH
15984: LD_STRING Q1
15986: PPUSH
15987: LD_VAR 0 6
15991: PPUSH
15992: CALL_OW 98
15996: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15997: LD_ADDR_VAR 0 7
16001: PUSH
16002: LD_STRING Q1
16004: PPUSH
16005: LD_VAR 0 6
16009: PPUSH
16010: CALL_OW 98
16014: ST_TO_ADDR
// options = options diff dec ;
16015: LD_ADDR_VAR 0 6
16019: PUSH
16020: LD_VAR 0 6
16024: PUSH
16025: LD_VAR 0 7
16029: DIFF
16030: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16031: LD_VAR 0 7
16035: PPUSH
16036: LD_VAR 0 6
16040: PPUSH
16041: CALL 17434 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16045: LD_VAR 0 7
16049: PUSH
16050: LD_INT 5
16052: PUSH
16053: LD_INT 6
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: IN
16060: PUSH
16061: LD_VAR 0 6
16065: PUSH
16066: LD_INT 2
16068: EQUAL
16069: OR
16070: IFFALSE 15997
// if not ( dec in [ 5 , 6 ] ) then
16072: LD_VAR 0 7
16076: PUSH
16077: LD_INT 5
16079: PUSH
16080: LD_INT 6
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: IN
16087: NOT
16088: IFFALSE 16131
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16090: LD_ADDR_VAR 0 7
16094: PUSH
16095: LD_STRING Q1a
16097: PPUSH
16098: LD_INT 1
16100: PUSH
16101: LD_INT 2
16103: PUSH
16104: EMPTY
16105: LIST
16106: LIST
16107: PPUSH
16108: CALL_OW 98
16112: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16113: LD_VAR 0 7
16117: PUSH
16118: LD_INT 4
16120: PLUS
16121: PPUSH
16122: LD_VAR 0 6
16126: PPUSH
16127: CALL 17434 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16131: LD_INT 81
16133: PPUSH
16134: LD_INT 127
16136: PPUSH
16137: CALL_OW 84
// amount := 5 ;
16141: LD_ADDR_VAR 0 8
16145: PUSH
16146: LD_INT 5
16148: ST_TO_ADDR
// macmilan_squad := [ ] ;
16149: LD_ADDR_VAR 0 9
16153: PUSH
16154: EMPTY
16155: ST_TO_ADDR
// if vip < amount then
16156: LD_EXP 56
16160: PUSH
16161: LD_VAR 0 8
16165: LESS
16166: IFFALSE 16210
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16168: LD_ADDR_VAR 0 5
16172: PUSH
16173: LD_EXP 56
16177: PUSH
16178: LD_INT 22
16180: PUSH
16181: LD_INT 4
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: LD_INT 21
16190: PUSH
16191: LD_INT 1
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: PUSH
16198: EMPTY
16199: LIST
16200: LIST
16201: PPUSH
16202: CALL_OW 69
16206: UNION
16207: ST_TO_ADDR
16208: GO 16220
// tmp := vip ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_EXP 56
16219: ST_TO_ADDR
// tmp := tmp diff Powell ;
16220: LD_ADDR_VAR 0 5
16224: PUSH
16225: LD_VAR 0 5
16229: PUSH
16230: LD_EXP 55
16234: DIFF
16235: ST_TO_ADDR
// if tmp < amount then
16236: LD_VAR 0 5
16240: PUSH
16241: LD_VAR 0 8
16245: LESS
16246: IFFALSE 16258
// amount := tmp ;
16248: LD_ADDR_VAR 0 8
16252: PUSH
16253: LD_VAR 0 5
16257: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16258: LD_VAR 0 5
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: CALL_OW 257
16271: PUSH
16272: LD_INT 2
16274: NONEQUAL
16275: IFFALSE 16337
// begin if IsInUnit ( tmp [ 1 ] ) then
16277: LD_VAR 0 5
16281: PUSH
16282: LD_INT 1
16284: ARRAY
16285: PPUSH
16286: CALL_OW 310
16290: IFFALSE 16305
// ComExitBuilding ( tmp [ 1 ] ) ;
16292: LD_VAR 0 5
16296: PUSH
16297: LD_INT 1
16299: ARRAY
16300: PPUSH
16301: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16305: LD_VAR 0 5
16309: PUSH
16310: LD_INT 1
16312: ARRAY
16313: PPUSH
16314: LD_INT 387
16316: PPUSH
16317: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16321: LD_VAR 0 5
16325: PUSH
16326: LD_INT 1
16328: ARRAY
16329: PPUSH
16330: LD_INT 2
16332: PPUSH
16333: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16337: LD_EXP 36
16341: PPUSH
16342: LD_INT 82
16344: PPUSH
16345: LD_INT 129
16347: PPUSH
16348: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16352: LD_EXP 36
16356: PPUSH
16357: LD_EXP 55
16361: PPUSH
16362: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16366: LD_INT 22
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: PUSH
16381: LD_EXP 36
16385: DIFF
16386: PPUSH
16387: LD_INT 84
16389: PPUSH
16390: LD_INT 128
16392: PPUSH
16393: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16397: LD_INT 22
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: PUSH
16412: LD_EXP 36
16416: DIFF
16417: PPUSH
16418: LD_EXP 36
16422: PPUSH
16423: CALL_OW 179
// for i = 1 to amount do
16427: LD_ADDR_VAR 0 2
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 8
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16611
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 9
16454: PUSH
16455: LD_VAR 0 5
16459: PUSH
16460: LD_VAR 0 2
16464: ARRAY
16465: ADD
16466: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16467: LD_VAR 0 5
16471: PUSH
16472: LD_VAR 0 2
16476: ARRAY
16477: PPUSH
16478: CALL_OW 310
16482: IFFALSE 16499
// AddComExitBuilding ( tmp [ i ] ) ;
16484: LD_VAR 0 5
16488: PUSH
16489: LD_VAR 0 2
16493: ARRAY
16494: PPUSH
16495: CALL_OW 182
// if i = 2 and JMMNewVeh then
16499: LD_VAR 0 2
16503: PUSH
16504: LD_INT 2
16506: EQUAL
16507: PUSH
16508: LD_EXP 53
16512: AND
16513: IFFALSE 16571
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16515: LD_VAR 0 5
16519: PUSH
16520: LD_VAR 0 2
16524: ARRAY
16525: PPUSH
16526: LD_EXP 53
16530: PPUSH
16531: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16535: LD_VAR 0 5
16539: PUSH
16540: LD_VAR 0 2
16544: ARRAY
16545: PPUSH
16546: LD_INT 86
16548: PPUSH
16549: LD_INT 133
16551: PPUSH
16552: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16556: LD_VAR 0 5
16560: PUSH
16561: LD_VAR 0 2
16565: ARRAY
16566: PPUSH
16567: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16571: LD_VAR 0 5
16575: PUSH
16576: LD_VAR 0 2
16580: ARRAY
16581: PPUSH
16582: LD_INT 8
16584: PPUSH
16585: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16589: LD_VAR 0 5
16593: PUSH
16594: LD_VAR 0 2
16598: ARRAY
16599: PPUSH
16600: LD_EXP 36
16604: PPUSH
16605: CALL_OW 179
// end ;
16609: GO 16442
16611: POP
16612: POP
// if GirlNewVeh then
16613: LD_EXP 54
16617: IFFALSE 16631
// SetSide ( GirlNewVeh , 4 ) ;
16619: LD_EXP 54
16623: PPUSH
16624: LD_INT 4
16626: PPUSH
16627: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16631: LD_INT 35
16633: PPUSH
16634: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16638: LD_VAR 0 9
16642: PPUSH
16643: LD_INT 95
16645: PUSH
16646: LD_INT 9
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PPUSH
16653: CALL_OW 72
16657: PUSH
16658: LD_INT 0
16660: EQUAL
16661: PUSH
16662: LD_EXP 36
16666: PPUSH
16667: LD_INT 9
16669: PPUSH
16670: CALL_OW 308
16674: NOT
16675: AND
16676: IFFALSE 16631
// wait ( 0 0$2 ) ;
16678: LD_INT 70
16680: PPUSH
16681: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16685: LD_VAR 0 9
16689: PPUSH
16690: LD_INT 1
16692: PPUSH
16693: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16697: LD_INT 21
16699: PUSH
16700: LD_INT 2
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PUSH
16707: LD_INT 92
16709: PUSH
16710: LD_INT 83
16712: PUSH
16713: LD_INT 130
16715: PUSH
16716: LD_INT 10
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PPUSH
16729: CALL_OW 69
16733: PPUSH
16734: LD_INT 1
16736: PPUSH
16737: CALL_OW 235
// Video ( false ) ;
16741: LD_INT 0
16743: PPUSH
16744: CALL 106816 0 1
// ChangeMissionObjectives ( M1 ) ;
16748: LD_STRING M1
16750: PPUSH
16751: CALL_OW 337
// SaveForQuickRestart ;
16755: CALL_OW 22
// missionStart := true ;
16759: LD_ADDR_EXP 13
16763: PUSH
16764: LD_INT 1
16766: ST_TO_ADDR
// missionStage := 2 ;
16767: LD_ADDR_EXP 15
16771: PUSH
16772: LD_INT 2
16774: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16775: LD_INT 105
16777: PPUSH
16778: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16782: LD_ADDR_VAR 0 5
16786: PUSH
16787: LD_INT 22
16789: PUSH
16790: LD_INT 4
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 21
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 69
16815: PUSH
16816: LD_EXP 55
16820: DIFF
16821: ST_TO_ADDR
// if not tmp then
16822: LD_VAR 0 5
16826: NOT
16827: IFFALSE 16842
// tmp := [ Powell ] ;
16829: LD_ADDR_VAR 0 5
16833: PUSH
16834: LD_EXP 55
16838: PUSH
16839: EMPTY
16840: LIST
16841: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16842: LD_ADDR_EXP 99
16846: PUSH
16847: LD_EXP 99
16851: PPUSH
16852: LD_INT 4
16854: PPUSH
16855: LD_INT 22
16857: PUSH
16858: LD_INT 4
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 23
16867: PUSH
16868: LD_INT 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: LD_INT 21
16880: PUSH
16881: LD_INT 2
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PUSH
16902: LD_EXP 55
16906: DIFF
16907: PPUSH
16908: CALL_OW 1
16912: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16913: LD_ADDR_VAR 0 4
16917: PUSH
16918: LD_INT 22
16920: PUSH
16921: LD_INT 4
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 34
16930: PUSH
16931: LD_INT 12
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PPUSH
16942: CALL_OW 69
16946: PUSH
16947: LD_INT 1
16949: ARRAY
16950: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16951: LD_VAR 0 5
16955: PUSH
16956: LD_INT 1
16958: ARRAY
16959: PPUSH
16960: CALL_OW 310
16964: IFFALSE 16979
// ComExitBuilding ( tmp [ 1 ] ) ;
16966: LD_VAR 0 5
16970: PUSH
16971: LD_INT 1
16973: ARRAY
16974: PPUSH
16975: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16979: LD_VAR 0 5
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: PPUSH
16988: LD_VAR 0 4
16992: PPUSH
16993: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16997: LD_VAR 0 5
17001: PUSH
17002: LD_INT 1
17004: ARRAY
17005: PPUSH
17006: LD_INT 80
17008: PPUSH
17009: LD_INT 136
17011: PPUSH
17012: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17016: LD_VAR 0 5
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17029: LD_VAR 0 5
17033: PUSH
17034: LD_INT 1
17036: ARRAY
17037: PPUSH
17038: LD_INT 59
17040: PPUSH
17041: LD_INT 112
17043: PPUSH
17044: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17048: LD_VAR 0 5
17052: PUSH
17053: LD_INT 1
17055: ARRAY
17056: PPUSH
17057: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17061: LD_EXP 39
17065: PUSH
17066: LD_EXP 56
17070: IN
17071: PUSH
17072: LD_EXP 39
17076: PPUSH
17077: CALL_OW 255
17081: PUSH
17082: LD_INT 1
17084: EQUAL
17085: AND
17086: IFFALSE 17102
// Say ( Lisa , D3nW-Lisa-1 ) else
17088: LD_EXP 39
17092: PPUSH
17093: LD_STRING D3nW-Lisa-1
17095: PPUSH
17096: CALL_OW 88
17100: GO 17346
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17102: LD_EXP 42
17106: PUSH
17107: LD_EXP 56
17111: IN
17112: PUSH
17113: LD_EXP 42
17117: PPUSH
17118: CALL_OW 255
17122: PUSH
17123: LD_INT 1
17125: EQUAL
17126: AND
17127: IFFALSE 17143
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17129: LD_EXP 42
17133: PPUSH
17134: LD_STRING D3nW-Cyrus-1
17136: PPUSH
17137: CALL_OW 88
17141: GO 17346
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17143: LD_EXP 41
17147: PUSH
17148: LD_EXP 56
17152: IN
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: IFFALSE 17184
// Say ( Bobby , D3nW-Bobby-1 ) else
17170: LD_EXP 41
17174: PPUSH
17175: LD_STRING D3nW-Bobby-1
17177: PPUSH
17178: CALL_OW 88
17182: GO 17346
// if Gary in vip and GetSide ( Gary ) = 1 then
17184: LD_EXP 48
17188: PUSH
17189: LD_EXP 56
17193: IN
17194: PUSH
17195: LD_EXP 48
17199: PPUSH
17200: CALL_OW 255
17204: PUSH
17205: LD_INT 1
17207: EQUAL
17208: AND
17209: IFFALSE 17225
// Say ( Gary , D3nW-Gary-1 ) else
17211: LD_EXP 48
17215: PPUSH
17216: LD_STRING D3nW-Gary-1
17218: PPUSH
17219: CALL_OW 88
17223: GO 17346
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17225: LD_EXP 40
17229: PUSH
17230: LD_EXP 56
17234: IN
17235: PUSH
17236: LD_EXP 40
17240: PPUSH
17241: CALL_OW 255
17245: PUSH
17246: LD_INT 1
17248: EQUAL
17249: AND
17250: IFFALSE 17266
// Say ( Donaldson , D3nW-Don-1 ) else
17252: LD_EXP 40
17256: PPUSH
17257: LD_STRING D3nW-Don-1
17259: PPUSH
17260: CALL_OW 88
17264: GO 17346
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17266: LD_EXP 47
17270: PUSH
17271: LD_EXP 56
17275: IN
17276: PUSH
17277: LD_EXP 47
17281: PPUSH
17282: CALL_OW 255
17286: PUSH
17287: LD_INT 1
17289: EQUAL
17290: AND
17291: IFFALSE 17307
// Say ( Cornel , D3nW-Corn-1 ) else
17293: LD_EXP 47
17297: PPUSH
17298: LD_STRING D3nW-Corn-1
17300: PPUSH
17301: CALL_OW 88
17305: GO 17346
// if Frank in vip and GetSide ( Frank ) = 1 then
17307: LD_EXP 49
17311: PUSH
17312: LD_EXP 56
17316: IN
17317: PUSH
17318: LD_EXP 49
17322: PPUSH
17323: CALL_OW 255
17327: PUSH
17328: LD_INT 1
17330: EQUAL
17331: AND
17332: IFFALSE 17346
// Say ( Frank , D3nW-Frank-1 ) ;
17334: LD_EXP 49
17338: PPUSH
17339: LD_STRING D3nW-Frank-1
17341: PPUSH
17342: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17346: LD_EXP 36
17350: PPUSH
17351: LD_STRING D3nW-JMM-1
17353: PPUSH
17354: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17358: LD_EXP 36
17362: PPUSH
17363: LD_STRING D3nW-JMM-1a
17365: PPUSH
17366: CALL_OW 88
// t := 0 0$00 ;
17370: LD_ADDR_VAR 0 3
17374: PUSH
17375: LD_INT 0
17377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17378: LD_INT 35
17380: PPUSH
17381: CALL_OW 67
// t := t + 0 0$1 ;
17385: LD_ADDR_VAR 0 3
17389: PUSH
17390: LD_VAR 0 3
17394: PUSH
17395: LD_INT 35
17397: PLUS
17398: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17399: LD_INT 59
17401: PPUSH
17402: LD_INT 112
17404: PPUSH
17405: CALL_OW 428
17409: PUSH
17410: LD_VAR 0 3
17414: PUSH
17415: LD_INT 2100
17417: GREATER
17418: OR
17419: IFFALSE 17378
// activeAttacks := true ;
17421: LD_ADDR_EXP 16
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// end ;
17429: LD_VAR 0 1
17433: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17434: LD_INT 0
17436: PPUSH
// case question of 1 :
17437: LD_VAR 0 1
17441: PUSH
17442: LD_INT 1
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17501
17450: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17451: LD_EXP 36
17455: PPUSH
17456: LD_STRING D2Mot-JMM-1
17458: PPUSH
17459: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17463: LD_EXP 55
17467: PPUSH
17468: LD_STRING D2Mot-Pow-1
17470: PPUSH
17471: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17475: LD_EXP 36
17479: PPUSH
17480: LD_STRING D2Mot-JMM-2
17482: PPUSH
17483: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17487: LD_EXP 55
17491: PPUSH
17492: LD_STRING D2Mot-Pow-2
17494: PPUSH
17495: CALL_OW 88
// end ; 2 :
17499: GO 17844
17501: LD_INT 2
17503: DOUBLE
17504: EQUAL
17505: IFTRUE 17509
17507: GO 17585
17509: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17510: LD_EXP 36
17514: PPUSH
17515: LD_STRING D2Rus-JMM-1
17517: PPUSH
17518: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17522: LD_EXP 55
17526: PPUSH
17527: LD_STRING D2Rus-Pow-1
17529: PPUSH
17530: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17534: LD_EXP 36
17538: PPUSH
17539: LD_STRING D2Rus-JMM-2
17541: PPUSH
17542: CALL_OW 88
// if not ( 3 in list_of_q ) then
17546: LD_INT 3
17548: PUSH
17549: LD_VAR 0 2
17553: IN
17554: NOT
17555: IFFALSE 17571
// Say ( Powell , D2Rus-Pow-2 ) else
17557: LD_EXP 55
17561: PPUSH
17562: LD_STRING D2Rus-Pow-2
17564: PPUSH
17565: CALL_OW 88
17569: GO 17583
// Say ( Powell , D2Rus-Pow-2a ) ;
17571: LD_EXP 55
17575: PPUSH
17576: LD_STRING D2Rus-Pow-2a
17578: PPUSH
17579: CALL_OW 88
// end ; 3 :
17583: GO 17844
17585: LD_INT 3
17587: DOUBLE
17588: EQUAL
17589: IFTRUE 17593
17591: GO 17678
17593: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17594: LD_EXP 36
17598: PPUSH
17599: LD_STRING D2Leg-JMM-1
17601: PPUSH
17602: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17606: LD_EXP 55
17610: PPUSH
17611: LD_STRING D2Leg-Pow-1
17613: PPUSH
17614: CALL_OW 88
// if 2 in list_of_q then
17618: LD_INT 2
17620: PUSH
17621: LD_VAR 0 2
17625: IN
17626: IFFALSE 17652
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17628: LD_EXP 36
17632: PPUSH
17633: LD_STRING D2Leg-JMM-2
17635: PPUSH
17636: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17640: LD_EXP 55
17644: PPUSH
17645: LD_STRING D2Leg-Pow-2
17647: PPUSH
17648: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17652: LD_EXP 36
17656: PPUSH
17657: LD_STRING D2Leg-JMM-3
17659: PPUSH
17660: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17664: LD_EXP 55
17668: PPUSH
17669: LD_STRING D2Leg-Pow-3
17671: PPUSH
17672: CALL_OW 88
// end ; 4 :
17676: GO 17844
17678: LD_INT 4
17680: DOUBLE
17681: EQUAL
17682: IFTRUE 17686
17684: GO 17761
17686: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17687: LD_EXP 36
17691: PPUSH
17692: LD_STRING D2Ar-JMM-1
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17699: LD_EXP 55
17703: PPUSH
17704: LD_STRING D2Ar-Pow-1
17706: PPUSH
17707: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17711: LD_EXP 36
17715: PPUSH
17716: LD_STRING D2Ar-JMM-2
17718: PPUSH
17719: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17723: LD_EXP 55
17727: PPUSH
17728: LD_STRING D2Ar-Pow-2
17730: PPUSH
17731: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17735: LD_EXP 36
17739: PPUSH
17740: LD_STRING D2Ar-JMM-3
17742: PPUSH
17743: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17747: LD_EXP 55
17751: PPUSH
17752: LD_STRING D2Ar-Pow-3
17754: PPUSH
17755: CALL_OW 88
// end ; 5 :
17759: GO 17844
17761: LD_INT 5
17763: DOUBLE
17764: EQUAL
17765: IFTRUE 17769
17767: GO 17784
17769: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17770: LD_EXP 36
17774: PPUSH
17775: LD_STRING D2Conf-JMM-1
17777: PPUSH
17778: CALL_OW 88
17782: GO 17844
17784: LD_INT 6
17786: DOUBLE
17787: EQUAL
17788: IFTRUE 17792
17790: GO 17843
17792: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17793: LD_EXP 36
17797: PPUSH
17798: LD_STRING D2Com-JMM-1
17800: PPUSH
17801: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17805: LD_EXP 55
17809: PPUSH
17810: LD_STRING D2Com-Pow-1
17812: PPUSH
17813: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17817: LD_EXP 36
17821: PPUSH
17822: LD_STRING D2Com-JMM-2
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17829: LD_EXP 55
17833: PPUSH
17834: LD_STRING D2Com-Pow-2
17836: PPUSH
17837: CALL_OW 88
// end ; end ;
17841: GO 17844
17843: POP
// end ;
17844: LD_VAR 0 3
17848: RET
// every 0 0$5 trigger missionStart do var tmp ;
17849: LD_EXP 13
17853: IFFALSE 18136
17855: GO 17857
17857: DISABLE
17858: LD_INT 0
17860: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17861: LD_INT 35
17863: PPUSH
17864: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17868: LD_INT 14
17870: PPUSH
17871: LD_INT 22
17873: PUSH
17874: LD_INT 1
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PPUSH
17881: CALL_OW 70
17885: PUSH
17886: LD_EXP 15
17890: PUSH
17891: LD_INT 2
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: LD_INT 4
17899: PUSH
17900: LD_INT 5
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: IN
17909: AND
17910: IFFALSE 18126
// begin powellAnger := powellAnger + 1 ;
17912: LD_ADDR_EXP 17
17916: PUSH
17917: LD_EXP 17
17921: PUSH
17922: LD_INT 1
17924: PLUS
17925: ST_TO_ADDR
// Video ( true ) ;
17926: LD_INT 1
17928: PPUSH
17929: CALL 106816 0 1
// CenterNowOnUnits ( tmp ) ;
17933: LD_VAR 0 1
17937: PPUSH
17938: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17942: LD_INT 14
17944: PPUSH
17945: LD_INT 22
17947: PUSH
17948: LD_INT 1
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PPUSH
17955: CALL_OW 70
17959: PPUSH
17960: LD_INT 86
17962: PPUSH
17963: LD_INT 133
17965: PPUSH
17966: CALL_OW 111
// async ;
17970: ASYNC
// case powellAnger of 1 :
17971: LD_EXP 17
17975: PUSH
17976: LD_INT 1
17978: DOUBLE
17979: EQUAL
17980: IFTRUE 17984
17982: GO 17999
17984: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17985: LD_EXP 55
17989: PPUSH
17990: LD_STRING DBack1-Pow-1
17992: PPUSH
17993: CALL_OW 88
17997: GO 18046
17999: LD_INT 2
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18022
18007: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18008: LD_EXP 55
18012: PPUSH
18013: LD_STRING DBack2-Pow-1
18015: PPUSH
18016: CALL_OW 88
18020: GO 18046
18022: LD_INT 3
18024: DOUBLE
18025: EQUAL
18026: IFTRUE 18030
18028: GO 18045
18030: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18031: LD_EXP 55
18035: PPUSH
18036: LD_STRING DBack3-Pow-1
18038: PPUSH
18039: CALL_OW 88
18043: GO 18046
18045: POP
// sync ;
18046: SYNC
// repeat wait ( 0 0$1 ) ;
18047: LD_INT 35
18049: PPUSH
18050: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18054: LD_INT 14
18056: PPUSH
18057: LD_INT 22
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: PPUSH
18067: CALL_OW 70
18071: PPUSH
18072: LD_INT 86
18074: PPUSH
18075: LD_INT 133
18077: PPUSH
18078: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18082: LD_INT 14
18084: PPUSH
18085: LD_INT 22
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 70
18099: NOT
18100: IFFALSE 18047
// if powellAnger >= 3 then
18102: LD_EXP 17
18106: PUSH
18107: LD_INT 3
18109: GREATEREQUAL
18110: IFFALSE 18119
// YouLost ( Dismissed ) ;
18112: LD_STRING Dismissed
18114: PPUSH
18115: CALL_OW 104
// Video ( false ) ;
18119: LD_INT 0
18121: PPUSH
18122: CALL 106816 0 1
// end ; until missionStage > 5 ;
18126: LD_EXP 15
18130: PUSH
18131: LD_INT 5
18133: GREATER
18134: IFFALSE 17861
// end ;
18136: PPOPN 1
18138: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18139: LD_EXP 13
18143: PUSH
18144: LD_INT 22
18146: PUSH
18147: LD_INT 4
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: LD_INT 21
18156: PUSH
18157: LD_INT 2
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PPUSH
18168: CALL_OW 69
18172: PUSH
18173: LD_INT 4
18175: GREATEREQUAL
18176: AND
18177: PUSH
18178: LD_EXP 15
18182: PUSH
18183: LD_INT 2
18185: EQUAL
18186: AND
18187: IFFALSE 20010
18189: GO 18191
18191: DISABLE
18192: LD_INT 0
18194: PPUSH
18195: PPUSH
18196: PPUSH
18197: PPUSH
18198: PPUSH
18199: PPUSH
18200: PPUSH
18201: PPUSH
// begin missionStage := 3 ;
18202: LD_ADDR_EXP 15
18206: PUSH
18207: LD_INT 3
18209: ST_TO_ADDR
// retreat := false ;
18210: LD_ADDR_VAR 0 4
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18218: LD_ADDR_VAR 0 5
18222: PUSH
18223: LD_INT 22
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: LD_INT 30
18235: PUSH
18236: LD_INT 4
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PPUSH
18247: CALL_OW 69
18251: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18252: LD_ADDR_VAR 0 6
18256: PUSH
18257: LD_INT 22
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 69
18285: ST_TO_ADDR
// if not bar then
18286: LD_VAR 0 6
18290: NOT
18291: IFFALSE 18344
// begin repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18300: LD_INT 22
18302: PUSH
18303: LD_INT 4
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PUSH
18310: LD_INT 3
18312: PUSH
18313: LD_INT 57
18315: PUSH
18316: EMPTY
18317: LIST
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 5
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: PPUSH
18338: CALL_OW 69
18342: IFFALSE 18293
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18344: LD_ADDR_VAR 0 6
18348: PUSH
18349: LD_INT 22
18351: PUSH
18352: LD_INT 4
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 30
18361: PUSH
18362: LD_INT 5
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PPUSH
18373: CALL_OW 69
18377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18378: LD_INT 35
18380: PPUSH
18381: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18385: LD_EXP 118
18389: PUSH
18390: LD_INT 4
18392: ARRAY
18393: PUSH
18394: LD_INT 4
18396: GREATEREQUAL
18397: IFFALSE 18378
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18399: LD_ADDR_VAR 0 2
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 4
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: LD_INT 2
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 1
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 2
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 3
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 25
18459: PUSH
18460: LD_INT 5
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PPUSH
18479: CALL_OW 69
18483: PUSH
18484: LD_EXP 55
18488: PUSH
18489: LD_EXP 56
18493: ADD
18494: DIFF
18495: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 2
18505: PPUSH
18506: LD_INT 26
18508: PUSH
18509: LD_INT 1
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: PPUSH
18516: CALL_OW 72
18520: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18521: LD_ADDR_VAR 0 2
18525: PUSH
18526: LD_VAR 0 2
18530: PUSH
18531: LD_VAR 0 3
18535: DIFF
18536: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 2
18546: PPUSH
18547: LD_INT 1
18549: PPUSH
18550: CALL 105469 0 2
18554: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18555: LD_ADDR_VAR 0 3
18559: PUSH
18560: LD_VAR 0 3
18564: PPUSH
18565: LD_INT 1
18567: PPUSH
18568: CALL 105469 0 2
18572: ST_TO_ADDR
// for i = 1 to 4 do
18573: LD_ADDR_VAR 0 1
18577: PUSH
18578: DOUBLE
18579: LD_INT 1
18581: DEC
18582: ST_TO_ADDR
18583: LD_INT 4
18585: PUSH
18586: FOR_TO
18587: IFFALSE 18753
// begin if tmp2 then
18589: LD_VAR 0 3
18593: IFFALSE 18674
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18595: LD_ADDR_EXP 18
18599: PUSH
18600: LD_EXP 18
18604: PPUSH
18605: LD_INT 1
18607: PPUSH
18608: LD_EXP 18
18612: PUSH
18613: LD_INT 1
18615: ARRAY
18616: PUSH
18617: LD_VAR 0 3
18621: PUSH
18622: LD_VAR 0 3
18626: ARRAY
18627: ADD
18628: PPUSH
18629: CALL_OW 1
18633: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18634: LD_VAR 0 3
18638: PUSH
18639: LD_VAR 0 3
18643: ARRAY
18644: PPUSH
18645: LD_INT 1
18647: PPUSH
18648: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18652: LD_ADDR_VAR 0 3
18656: PUSH
18657: LD_VAR 0 3
18661: PPUSH
18662: LD_VAR 0 3
18666: PPUSH
18667: CALL_OW 3
18671: ST_TO_ADDR
// end else
18672: GO 18751
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18674: LD_ADDR_EXP 18
18678: PUSH
18679: LD_EXP 18
18683: PPUSH
18684: LD_INT 1
18686: PPUSH
18687: LD_EXP 18
18691: PUSH
18692: LD_INT 1
18694: ARRAY
18695: PUSH
18696: LD_VAR 0 2
18700: PUSH
18701: LD_VAR 0 2
18705: ARRAY
18706: ADD
18707: PPUSH
18708: CALL_OW 1
18712: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18713: LD_VAR 0 2
18717: PUSH
18718: LD_VAR 0 2
18722: ARRAY
18723: PPUSH
18724: LD_INT 1
18726: PPUSH
18727: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18731: LD_ADDR_VAR 0 2
18735: PUSH
18736: LD_VAR 0 2
18740: PPUSH
18741: LD_VAR 0 2
18745: PPUSH
18746: CALL_OW 3
18750: ST_TO_ADDR
// end ; end ;
18751: GO 18586
18753: POP
18754: POP
// if tmp2 then
18755: LD_VAR 0 3
18759: IFFALSE 18777
// tmp := tmp union tmp2 ;
18761: LD_ADDR_VAR 0 2
18765: PUSH
18766: LD_VAR 0 2
18770: PUSH
18771: LD_VAR 0 3
18775: UNION
18776: ST_TO_ADDR
// for i = 1 to 4 do
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: DOUBLE
18783: LD_INT 1
18785: DEC
18786: ST_TO_ADDR
18787: LD_INT 4
18789: PUSH
18790: FOR_TO
18791: IFFALSE 18840
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18793: LD_ADDR_EXP 18
18797: PUSH
18798: LD_EXP 18
18802: PPUSH
18803: LD_INT 2
18805: PPUSH
18806: LD_EXP 18
18810: PUSH
18811: LD_INT 2
18813: ARRAY
18814: PUSH
18815: LD_VAR 0 2
18819: PUSH
18820: LD_VAR 0 2
18824: PUSH
18825: LD_VAR 0 1
18829: MINUS
18830: ARRAY
18831: ADD
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
18838: GO 18790
18840: POP
18841: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18842: LD_ADDR_EXP 99
18846: PUSH
18847: LD_EXP 99
18851: PPUSH
18852: LD_INT 4
18854: PPUSH
18855: LD_EXP 99
18859: PUSH
18860: LD_INT 4
18862: ARRAY
18863: PUSH
18864: LD_EXP 18
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: DIFF
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18879: LD_VAR 0 5
18883: PUSH
18884: LD_INT 1
18886: ARRAY
18887: PPUSH
18888: CALL_OW 313
18892: IFFALSE 18947
// begin for i in UnitsInside ( arm [ 1 ] ) do
18894: LD_ADDR_VAR 0 1
18898: PUSH
18899: LD_VAR 0 5
18903: PUSH
18904: LD_INT 1
18906: ARRAY
18907: PPUSH
18908: CALL_OW 313
18912: PUSH
18913: FOR_IN
18914: IFFALSE 18945
// begin ComExitBuilding ( i ) ;
18916: LD_VAR 0 1
18920: PPUSH
18921: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18925: LD_VAR 0 1
18929: PPUSH
18930: LD_VAR 0 6
18934: PUSH
18935: LD_INT 1
18937: ARRAY
18938: PPUSH
18939: CALL_OW 180
// end ;
18943: GO 18913
18945: POP
18946: POP
// end ; wait ( 0 0$3 ) ;
18947: LD_INT 105
18949: PPUSH
18950: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18954: LD_ADDR_VAR 0 1
18958: PUSH
18959: LD_EXP 18
18963: PUSH
18964: LD_INT 1
18966: ARRAY
18967: PUSH
18968: FOR_IN
18969: IFFALSE 19076
// begin if IsInUnit ( i ) then
18971: LD_VAR 0 1
18975: PPUSH
18976: CALL_OW 310
18980: IFFALSE 18991
// ComExitBuilding ( i ) ;
18982: LD_VAR 0 1
18986: PPUSH
18987: CALL_OW 122
// if GetClass ( i ) <> 1 then
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 257
19000: PUSH
19001: LD_INT 1
19003: NONEQUAL
19004: IFFALSE 19045
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19006: LD_VAR 0 1
19010: PPUSH
19011: LD_VAR 0 5
19015: PUSH
19016: LD_INT 1
19018: ARRAY
19019: PPUSH
19020: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19024: LD_VAR 0 1
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: CALL_OW 183
// AddComExitBuilding ( i ) ;
19036: LD_VAR 0 1
19040: PPUSH
19041: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19045: LD_VAR 0 1
19049: PPUSH
19050: LD_INT 60
19052: PPUSH
19053: LD_INT 94
19055: PPUSH
19056: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19060: LD_VAR 0 1
19064: PPUSH
19065: LD_EXP 55
19069: PPUSH
19070: CALL_OW 179
// end ;
19074: GO 18968
19076: POP
19077: POP
// wait ( 0 0$15 ) ;
19078: LD_INT 525
19080: PPUSH
19081: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19085: LD_EXP 55
19089: PPUSH
19090: LD_STRING D4-Pow-1
19092: PPUSH
19093: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19097: LD_ADDR_VAR 0 2
19101: PUSH
19102: LD_EXP 18
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_INT 26
19113: PUSH
19114: LD_INT 1
19116: PUSH
19117: EMPTY
19118: LIST
19119: LIST
19120: PPUSH
19121: CALL_OW 72
19125: ST_TO_ADDR
// if tmp then
19126: LD_VAR 0 2
19130: IFFALSE 19148
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19132: LD_VAR 0 2
19136: PUSH
19137: LD_INT 1
19139: ARRAY
19140: PPUSH
19141: LD_STRING D4-Sol1-1
19143: PPUSH
19144: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19148: LD_EXP 55
19152: PPUSH
19153: LD_STRING D4-Pow-2
19155: PPUSH
19156: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19160: LD_ADDR_VAR 0 1
19164: PUSH
19165: DOUBLE
19166: LD_INT 1
19168: DEC
19169: ST_TO_ADDR
19170: LD_EXP 18
19174: PUSH
19175: LD_INT 1
19177: ARRAY
19178: PUSH
19179: FOR_TO
19180: IFFALSE 19273
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19182: LD_EXP 18
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: PUSH
19191: LD_VAR 0 1
19195: ARRAY
19196: PPUSH
19197: LD_EXP 118
19201: PUSH
19202: LD_INT 4
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19214: LD_ADDR_EXP 118
19218: PUSH
19219: LD_EXP 118
19223: PPUSH
19224: LD_INT 4
19226: PPUSH
19227: LD_EXP 118
19231: PUSH
19232: LD_INT 4
19234: ARRAY
19235: PPUSH
19236: LD_INT 1
19238: PPUSH
19239: CALL_OW 3
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19249: LD_INT 8
19251: PPUSH
19252: LD_EXP 18
19256: PUSH
19257: LD_INT 1
19259: ARRAY
19260: PUSH
19261: LD_VAR 0 1
19265: ARRAY
19266: PPUSH
19267: CALL_OW 471
// end ;
19271: GO 19179
19273: POP
19274: POP
// repeat wait ( 0 0$1 ) ;
19275: LD_INT 35
19277: PPUSH
19278: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19282: LD_EXP 18
19286: PUSH
19287: LD_INT 1
19289: ARRAY
19290: PPUSH
19291: LD_INT 55
19293: PUSH
19294: EMPTY
19295: LIST
19296: PPUSH
19297: CALL_OW 72
19301: PUSH
19302: LD_INT 4
19304: GREATEREQUAL
19305: IFFALSE 19275
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19307: LD_EXP 18
19311: PUSH
19312: LD_INT 1
19314: ARRAY
19315: PPUSH
19316: LD_INT 69
19318: PPUSH
19319: LD_INT 94
19321: PPUSH
19322: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19326: LD_EXP 18
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: PPUSH
19335: LD_INT 82
19337: PPUSH
19338: LD_INT 83
19340: PPUSH
19341: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19345: LD_EXP 18
19349: PUSH
19350: LD_INT 1
19352: ARRAY
19353: PPUSH
19354: LD_INT 77
19356: PPUSH
19357: LD_INT 69
19359: PPUSH
19360: CALL_OW 174
// repeat wait ( 3 ) ;
19364: LD_INT 3
19366: PPUSH
19367: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19371: LD_ADDR_VAR 0 1
19375: PUSH
19376: LD_EXP 18
19380: PUSH
19381: LD_INT 1
19383: ARRAY
19384: PUSH
19385: FOR_IN
19386: IFFALSE 19522
// begin if GetLives ( i ) < 990 then
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL_OW 256
19397: PUSH
19398: LD_INT 990
19400: LESS
19401: IFFALSE 19415
// SetLives ( i , 1000 ) ;
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 1000
19410: PPUSH
19411: CALL_OW 234
// if not IsInUnit ( i ) then
19415: LD_VAR 0 1
19419: PPUSH
19420: CALL_OW 310
19424: NOT
19425: IFFALSE 19520
// begin if not HasTask ( i ) then
19427: LD_VAR 0 1
19431: PPUSH
19432: CALL_OW 314
19436: NOT
19437: IFFALSE 19454
// ComMoveXY ( i , 64 , 93 ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: LD_INT 64
19446: PPUSH
19447: LD_INT 93
19449: PPUSH
19450: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19454: LD_VAR 0 4
19458: NOT
19459: PUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: CALL_OW 258
19469: PUSH
19470: LD_INT 1
19472: EQUAL
19473: AND
19474: IFFALSE 19520
// begin retreat := true ;
19476: LD_ADDR_VAR 0 4
19480: PUSH
19481: LD_INT 1
19483: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19484: LD_VAR 0 1
19488: PPUSH
19489: LD_INT 2
19491: PPUSH
19492: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19496: LD_VAR 0 1
19500: PPUSH
19501: LD_STRING D4a-Sol1-1
19503: PPUSH
19504: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19508: LD_EXP 55
19512: PPUSH
19513: LD_STRING D4a-Pow-1
19515: PPUSH
19516: CALL_OW 88
// end ; end ; end ;
19520: GO 19385
19522: POP
19523: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19524: LD_EXP 18
19528: PUSH
19529: LD_INT 1
19531: ARRAY
19532: PPUSH
19533: LD_INT 95
19535: PUSH
19536: LD_INT 9
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 3
19545: PUSH
19546: LD_INT 55
19548: PUSH
19549: EMPTY
19550: LIST
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: PUSH
19556: EMPTY
19557: LIST
19558: LIST
19559: PPUSH
19560: CALL_OW 72
19564: PUSH
19565: LD_INT 4
19567: GREATEREQUAL
19568: IFFALSE 19364
// for i in powellSquadAttack [ 1 ] do
19570: LD_ADDR_VAR 0 1
19574: PUSH
19575: LD_EXP 18
19579: PUSH
19580: LD_INT 1
19582: ARRAY
19583: PUSH
19584: FOR_IN
19585: IFFALSE 19721
// begin if GetTag ( i ) = 2 then
19587: LD_VAR 0 1
19591: PPUSH
19592: CALL_OW 110
19596: PUSH
19597: LD_INT 2
19599: EQUAL
19600: IFFALSE 19662
// begin ComMoveXY ( i , 60 , 94 ) ;
19602: LD_VAR 0 1
19606: PPUSH
19607: LD_INT 60
19609: PPUSH
19610: LD_INT 94
19612: PPUSH
19613: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19617: LD_VAR 0 1
19621: PPUSH
19622: LD_EXP 55
19626: PPUSH
19627: CALL_OW 179
// wait ( 0 0$3 ) ;
19631: LD_INT 105
19633: PPUSH
19634: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_STRING D4a-Sol1-2
19645: PPUSH
19646: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19650: LD_EXP 55
19654: PPUSH
19655: LD_STRING D4a-Pow-2
19657: PPUSH
19658: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19662: LD_VAR 0 1
19666: PPUSH
19667: LD_INT 0
19669: PPUSH
19670: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19674: LD_ADDR_EXP 99
19678: PUSH
19679: LD_EXP 99
19683: PPUSH
19684: LD_INT 4
19686: PPUSH
19687: LD_EXP 99
19691: PUSH
19692: LD_INT 4
19694: ARRAY
19695: PUSH
19696: LD_VAR 0 1
19700: UNION
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19707: LD_INT 8
19709: PPUSH
19710: LD_VAR 0 1
19714: PPUSH
19715: CALL_OW 472
// end ;
19719: GO 19584
19721: POP
19722: POP
// wait ( 4 4$00 ) ;
19723: LD_INT 8400
19725: PPUSH
19726: CALL_OW 67
// uc_side := 6 ;
19730: LD_ADDR_OWVAR 20
19734: PUSH
19735: LD_INT 6
19737: ST_TO_ADDR
// uc_nation := 3 ;
19738: LD_ADDR_OWVAR 21
19742: PUSH
19743: LD_INT 3
19745: ST_TO_ADDR
// ru := [ ] ;
19746: LD_ADDR_VAR 0 7
19750: PUSH
19751: EMPTY
19752: ST_TO_ADDR
// for i = 1 to 4 do
19753: LD_ADDR_VAR 0 1
19757: PUSH
19758: DOUBLE
19759: LD_INT 1
19761: DEC
19762: ST_TO_ADDR
19763: LD_INT 4
19765: PUSH
19766: FOR_TO
19767: IFFALSE 19868
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19769: LD_INT 22
19771: PPUSH
19772: LD_INT 1
19774: PPUSH
19775: LD_INT 3
19777: PPUSH
19778: LD_INT 43
19780: PUSH
19781: LD_INT 44
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: PUSH
19788: LD_INT 1
19790: PPUSH
19791: LD_INT 2
19793: PPUSH
19794: CALL_OW 12
19798: ARRAY
19799: PPUSH
19800: LD_INT 89
19802: PPUSH
19803: CALL 71099 0 5
// un := CreateVehicle ;
19807: LD_ADDR_VAR 0 8
19811: PUSH
19812: CALL_OW 45
19816: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19817: LD_VAR 0 8
19821: PPUSH
19822: LD_INT 4
19824: PPUSH
19825: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19829: LD_VAR 0 8
19833: PPUSH
19834: LD_INT 136
19836: PPUSH
19837: LD_INT 90
19839: PPUSH
19840: LD_INT 8
19842: PPUSH
19843: LD_INT 0
19845: PPUSH
19846: CALL_OW 50
// ru := ru ^ un ;
19850: LD_ADDR_VAR 0 7
19854: PUSH
19855: LD_VAR 0 7
19859: PUSH
19860: LD_VAR 0 8
19864: ADD
19865: ST_TO_ADDR
// end ;
19866: GO 19766
19868: POP
19869: POP
// if ru then
19870: LD_VAR 0 7
19874: IFFALSE 19891
// ComAgressiveMove ( ru , 80 , 92 ) ;
19876: LD_VAR 0 7
19880: PPUSH
19881: LD_INT 80
19883: PPUSH
19884: LD_INT 92
19886: PPUSH
19887: CALL_OW 114
// wait ( 8 8$00 ) ;
19891: LD_INT 16800
19893: PPUSH
19894: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19898: LD_INT 4
19900: PPUSH
19901: LD_INT 3
19903: PUSH
19904: LD_INT 1
19906: PUSH
19907: LD_INT 1
19909: PUSH
19910: LD_INT 5
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: PUSH
19919: LD_INT 4
19921: PUSH
19922: LD_INT 1
19924: PUSH
19925: LD_INT 1
19927: PUSH
19928: LD_INT 6
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: LIST
19936: PUSH
19937: LD_INT 4
19939: PUSH
19940: LD_INT 1
19942: PUSH
19943: LD_INT 1
19945: PUSH
19946: LD_INT 7
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: PUSH
19955: LD_INT 3
19957: PUSH
19958: LD_INT 1
19960: PUSH
19961: LD_INT 1
19963: PUSH
19964: LD_INT 7
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: PUSH
19973: LD_INT 3
19975: PUSH
19976: LD_INT 1
19978: PUSH
19979: LD_INT 1
19981: PUSH
19982: LD_INT 5
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: PPUSH
19998: CALL 57681 0 2
// missionStage := 4 ;
20002: LD_ADDR_EXP 15
20006: PUSH
20007: LD_INT 4
20009: ST_TO_ADDR
// end ;
20010: PPOPN 8
20012: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20013: LD_EXP 15
20017: PUSH
20018: LD_INT 4
20020: EQUAL
20021: PUSH
20022: LD_INT 22
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 21
20034: PUSH
20035: LD_INT 2
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: PPUSH
20046: CALL_OW 69
20050: PUSH
20051: LD_INT 5
20053: GREATEREQUAL
20054: AND
20055: IFFALSE 24160
20057: GO 20059
20059: DISABLE
20060: LD_INT 0
20062: PPUSH
20063: PPUSH
20064: PPUSH
20065: PPUSH
20066: PPUSH
20067: PPUSH
20068: PPUSH
20069: PPUSH
20070: PPUSH
20071: PPUSH
20072: PPUSH
20073: PPUSH
20074: PPUSH
// begin missionStage := 5 ;
20075: LD_ADDR_EXP 15
20079: PUSH
20080: LD_INT 5
20082: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20083: LD_ADDR_VAR 0 10
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 2
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 4
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: LD_INT 30
20113: PUSH
20114: LD_INT 5
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: PUSH
20126: EMPTY
20127: LIST
20128: LIST
20129: PPUSH
20130: CALL_OW 69
20134: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20135: LD_ADDR_VAR 0 6
20139: PUSH
20140: LD_INT 22
20142: PUSH
20143: LD_INT 4
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 21
20152: PUSH
20153: LD_INT 1
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 3
20162: PUSH
20163: LD_INT 25
20165: PUSH
20166: LD_INT 16
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PUSH
20177: LD_INT 3
20179: PUSH
20180: LD_INT 25
20182: PUSH
20183: LD_INT 12
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: PPUSH
20200: CALL_OW 69
20204: PUSH
20205: LD_EXP 55
20209: DIFF
20210: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20211: LD_ADDR_VAR 0 9
20215: PUSH
20216: LD_INT 22
20218: PUSH
20219: LD_INT 4
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: LD_INT 30
20228: PUSH
20229: LD_INT 3
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 69
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20249: LD_INT 35
20251: PPUSH
20252: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20256: LD_EXP 118
20260: PUSH
20261: LD_INT 4
20263: ARRAY
20264: PUSH
20265: LD_INT 5
20267: GREATEREQUAL
20268: PUSH
20269: LD_EXP 118
20273: PUSH
20274: LD_INT 4
20276: ARRAY
20277: PPUSH
20278: LD_INT 58
20280: PUSH
20281: EMPTY
20282: LIST
20283: PPUSH
20284: CALL_OW 72
20288: PUSH
20289: LD_INT 5
20291: GREATEREQUAL
20292: AND
20293: IFFALSE 20249
// powellAllowRetreat := false ;
20295: LD_ADDR_EXP 19
20299: PUSH
20300: LD_INT 0
20302: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20303: LD_INT 700
20305: PPUSH
20306: CALL_OW 67
// activeAttacks := false ;
20310: LD_ADDR_EXP 16
20314: PUSH
20315: LD_INT 0
20317: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20318: LD_INT 35
20320: PPUSH
20321: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20325: LD_INT 22
20327: PUSH
20328: LD_INT 6
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PPUSH
20335: CALL_OW 69
20339: PUSH
20340: LD_INT 0
20342: EQUAL
20343: IFFALSE 20318
// tmp := mc_vehicles [ 4 ] ;
20345: LD_ADDR_VAR 0 3
20349: PUSH
20350: LD_EXP 118
20354: PUSH
20355: LD_INT 4
20357: ARRAY
20358: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20359: LD_ADDR_VAR 0 1
20363: PUSH
20364: DOUBLE
20365: LD_INT 1
20367: DEC
20368: ST_TO_ADDR
20369: LD_EXP 18
20373: PUSH
20374: FOR_TO
20375: IFFALSE 20636
// begin for j in powellSquadAttack [ i ] do
20377: LD_ADDR_VAR 0 2
20381: PUSH
20382: LD_EXP 18
20386: PUSH
20387: LD_VAR 0 1
20391: ARRAY
20392: PUSH
20393: FOR_IN
20394: IFFALSE 20632
// begin forces := forces diff j ;
20396: LD_ADDR_VAR 0 6
20400: PUSH
20401: LD_VAR 0 6
20405: PUSH
20406: LD_VAR 0 2
20410: DIFF
20411: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20412: LD_VAR 0 2
20416: PPUSH
20417: LD_INT 1
20419: PPUSH
20420: CALL_OW 109
// wait ( 0 0$2 ) ;
20424: LD_INT 70
20426: PPUSH
20427: CALL_OW 67
// if IsInUnit ( j ) then
20431: LD_VAR 0 2
20435: PPUSH
20436: CALL_OW 310
20440: IFFALSE 20451
// ComExitBuilding ( j ) ;
20442: LD_VAR 0 2
20446: PPUSH
20447: CALL_OW 122
// if GetClass ( j ) <> 1 then
20451: LD_VAR 0 2
20455: PPUSH
20456: CALL_OW 257
20460: PUSH
20461: LD_INT 1
20463: NONEQUAL
20464: IFFALSE 20544
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20466: LD_VAR 0 10
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: CALL_OW 313
20479: PUSH
20480: LD_INT 5
20482: GREATEREQUAL
20483: IFFALSE 20505
// AddComEnterUnit ( j , arm [ 2 ] ) else
20485: LD_VAR 0 2
20489: PPUSH
20490: LD_VAR 0 10
20494: PUSH
20495: LD_INT 2
20497: ARRAY
20498: PPUSH
20499: CALL_OW 180
20503: GO 20523
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20505: LD_VAR 0 2
20509: PPUSH
20510: LD_VAR 0 10
20514: PUSH
20515: LD_INT 1
20517: ARRAY
20518: PPUSH
20519: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20523: LD_VAR 0 2
20527: PPUSH
20528: LD_INT 1
20530: PPUSH
20531: CALL_OW 183
// AddComExitBuilding ( j ) ;
20535: LD_VAR 0 2
20539: PPUSH
20540: CALL_OW 182
// end ; if i = 2 then
20544: LD_VAR 0 1
20548: PUSH
20549: LD_INT 2
20551: EQUAL
20552: IFFALSE 20569
// AddComMoveXY ( j , 61 , 93 ) ;
20554: LD_VAR 0 2
20558: PPUSH
20559: LD_INT 61
20561: PPUSH
20562: LD_INT 93
20564: PPUSH
20565: CALL_OW 171
// if i = 1 then
20569: LD_VAR 0 1
20573: PUSH
20574: LD_INT 1
20576: EQUAL
20577: IFFALSE 20630
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20579: LD_VAR 0 2
20583: PPUSH
20584: LD_VAR 0 3
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: PPUSH
20593: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20597: LD_ADDR_VAR 0 3
20601: PUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: LD_INT 1
20609: PPUSH
20610: CALL_OW 3
20614: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20615: LD_VAR 0 2
20619: PPUSH
20620: LD_INT 69
20622: PPUSH
20623: LD_INT 94
20625: PPUSH
20626: CALL_OW 171
// end ; end ;
20630: GO 20393
20632: POP
20633: POP
// end ;
20634: GO 20374
20636: POP
20637: POP
// wait ( 0 0$55 ) ;
20638: LD_INT 1925
20640: PPUSH
20641: CALL_OW 67
// MC_Kill ( 4 ) ;
20645: LD_INT 4
20647: PPUSH
20648: CALL 34165 0 1
// tmp := UnitsInside ( fac ) ;
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_VAR 0 9
20661: PPUSH
20662: CALL_OW 313
20666: ST_TO_ADDR
// if tmp then
20667: LD_VAR 0 3
20671: IFFALSE 20792
// for i in tmp do
20673: LD_ADDR_VAR 0 1
20677: PUSH
20678: LD_VAR 0 3
20682: PUSH
20683: FOR_IN
20684: IFFALSE 20790
// begin ComExitBuilding ( i ) ;
20686: LD_VAR 0 1
20690: PPUSH
20691: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20695: LD_VAR 0 10
20699: PUSH
20700: LD_INT 2
20702: ARRAY
20703: PPUSH
20704: CALL_OW 313
20708: PUSH
20709: LD_INT 6
20711: LESS
20712: IFFALSE 20734
// AddComEnterUnit ( i , arm [ 2 ] ) else
20714: LD_VAR 0 1
20718: PPUSH
20719: LD_VAR 0 10
20723: PUSH
20724: LD_INT 2
20726: ARRAY
20727: PPUSH
20728: CALL_OW 180
20732: GO 20788
// if UnitsInside ( arm [ 1 ] ) < 6 then
20734: LD_VAR 0 10
20738: PUSH
20739: LD_INT 1
20741: ARRAY
20742: PPUSH
20743: CALL_OW 313
20747: PUSH
20748: LD_INT 6
20750: LESS
20751: IFFALSE 20773
// AddComEnterUnit ( i , arm [ 1 ] ) else
20753: LD_VAR 0 1
20757: PPUSH
20758: LD_VAR 0 10
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: PPUSH
20767: CALL_OW 180
20771: GO 20788
// AddComMoveXY ( i , 37 , 68 ) ;
20773: LD_VAR 0 1
20777: PPUSH
20778: LD_INT 37
20780: PPUSH
20781: LD_INT 68
20783: PPUSH
20784: CALL_OW 171
// end ;
20788: GO 20683
20790: POP
20791: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20792: LD_ADDR_VAR 0 11
20796: PUSH
20797: LD_VAR 0 6
20801: PPUSH
20802: LD_INT 26
20804: PUSH
20805: LD_INT 1
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PPUSH
20812: CALL_OW 72
20816: PUSH
20817: LD_EXP 56
20821: DIFF
20822: ST_TO_ADDR
// if not speaker then
20823: LD_VAR 0 11
20827: NOT
20828: IFFALSE 20855
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20830: LD_ADDR_VAR 0 11
20834: PUSH
20835: LD_VAR 0 6
20839: PPUSH
20840: LD_INT 26
20842: PUSH
20843: LD_INT 1
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PPUSH
20850: CALL_OW 72
20854: ST_TO_ADDR
// if speaker then
20855: LD_VAR 0 11
20859: IFFALSE 20875
// speaker := speaker [ 1 ] ;
20861: LD_ADDR_VAR 0 11
20865: PUSH
20866: LD_VAR 0 11
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: ST_TO_ADDR
// Video ( true ) ;
20875: LD_INT 1
20877: PPUSH
20878: CALL 106816 0 1
// CenterNowOnUnits ( Powell ) ;
20882: LD_EXP 55
20886: PPUSH
20887: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20891: LD_ADDR_VAR 0 3
20895: PUSH
20896: LD_VAR 0 6
20900: PPUSH
20901: LD_INT 3
20903: PUSH
20904: LD_INT 25
20906: PUSH
20907: LD_INT 1
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: PPUSH
20918: CALL_OW 72
20922: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20923: LD_ADDR_VAR 0 12
20927: PUSH
20928: LD_INT 22
20930: PUSH
20931: LD_INT 4
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 30
20940: PUSH
20941: LD_INT 32
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PUSH
20948: LD_INT 58
20950: PUSH
20951: EMPTY
20952: LIST
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: LIST
20958: PPUSH
20959: CALL_OW 69
20963: ST_TO_ADDR
// for i = 1 to 6 do
20964: LD_ADDR_VAR 0 1
20968: PUSH
20969: DOUBLE
20970: LD_INT 1
20972: DEC
20973: ST_TO_ADDR
20974: LD_INT 6
20976: PUSH
20977: FOR_TO
20978: IFFALSE 21119
// begin if IsInUnit ( tmp [ i ] ) then
20980: LD_VAR 0 3
20984: PUSH
20985: LD_VAR 0 1
20989: ARRAY
20990: PPUSH
20991: CALL_OW 310
20995: IFFALSE 21012
// ComExitBuilding ( tmp [ i ] ) ;
20997: LD_VAR 0 3
21001: PUSH
21002: LD_VAR 0 1
21006: ARRAY
21007: PPUSH
21008: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21012: LD_VAR 0 3
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: PPUSH
21023: LD_VAR 0 10
21027: PUSH
21028: LD_INT 1
21030: ARRAY
21031: PPUSH
21032: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21036: LD_VAR 0 3
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: PPUSH
21047: LD_INT 1
21049: PPUSH
21050: CALL_OW 183
// if emp_towers then
21054: LD_VAR 0 12
21058: IFFALSE 21117
// begin AddComExitBuilding ( tmp [ i ] ) ;
21060: LD_VAR 0 3
21064: PUSH
21065: LD_VAR 0 1
21069: ARRAY
21070: PPUSH
21071: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21075: LD_VAR 0 3
21079: PUSH
21080: LD_VAR 0 1
21084: ARRAY
21085: PPUSH
21086: LD_VAR 0 12
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: PPUSH
21095: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21099: LD_ADDR_VAR 0 12
21103: PUSH
21104: LD_VAR 0 12
21108: PPUSH
21109: LD_INT 1
21111: PPUSH
21112: CALL_OW 3
21116: ST_TO_ADDR
// end ; end ;
21117: GO 20977
21119: POP
21120: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21121: LD_ADDR_VAR 0 3
21125: PUSH
21126: LD_EXP 18
21130: PUSH
21131: LD_INT 1
21133: ARRAY
21134: PUSH
21135: LD_EXP 18
21139: PUSH
21140: LD_INT 2
21142: ARRAY
21143: ADD
21144: PPUSH
21145: LD_INT 26
21147: PUSH
21148: LD_INT 1
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: PPUSH
21155: CALL_OW 72
21159: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21160: LD_ADDR_VAR 0 1
21164: PUSH
21165: LD_EXP 18
21169: PUSH
21170: LD_INT 2
21172: ARRAY
21173: PUSH
21174: FOR_IN
21175: IFFALSE 21193
// ComTurnUnit ( i , Powell ) ;
21177: LD_VAR 0 1
21181: PPUSH
21182: LD_EXP 55
21186: PPUSH
21187: CALL_OW 119
21191: GO 21174
21193: POP
21194: POP
// Say ( Powell , D5-Pow-1 ) ;
21195: LD_EXP 55
21199: PPUSH
21200: LD_STRING D5-Pow-1
21202: PPUSH
21203: CALL_OW 88
// if tmp then
21207: LD_VAR 0 3
21211: IFFALSE 21229
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21213: LD_VAR 0 3
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: LD_STRING D5-Sol2-1
21224: PPUSH
21225: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21229: LD_EXP 55
21233: PPUSH
21234: LD_STRING D5-Pow-2
21236: PPUSH
21237: CALL_OW 88
// if tmp > 1 then
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 1
21248: GREATER
21249: IFFALSE 21267
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21251: LD_VAR 0 3
21255: PUSH
21256: LD_INT 2
21258: ARRAY
21259: PPUSH
21260: LD_STRING D5-Sol2-2
21262: PPUSH
21263: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21267: LD_EXP 55
21271: PPUSH
21272: LD_STRING D5-Pow-3
21274: PPUSH
21275: CALL_OW 88
// wait ( 0 0$1 ) ;
21279: LD_INT 35
21281: PPUSH
21282: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21286: LD_ADDR_VAR 0 3
21290: PUSH
21291: LD_EXP 18
21295: PUSH
21296: LD_INT 1
21298: ARRAY
21299: PUSH
21300: LD_EXP 18
21304: PUSH
21305: LD_INT 2
21307: ARRAY
21308: UNION
21309: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21310: LD_VAR 0 3
21314: PPUSH
21315: LD_INT 80
21317: PPUSH
21318: LD_INT 67
21320: PPUSH
21321: CALL_OW 114
// wait ( 0 0$2 ) ;
21325: LD_INT 70
21327: PPUSH
21328: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21332: LD_INT 79
21334: PPUSH
21335: LD_INT 72
21337: PPUSH
21338: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21342: LD_INT 35
21344: PPUSH
21345: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21349: LD_VAR 0 3
21353: PPUSH
21354: LD_INT 3
21356: PUSH
21357: LD_INT 24
21359: PUSH
21360: LD_INT 1000
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PPUSH
21371: CALL_OW 72
21375: IFFALSE 21342
// Say ( Powell , D5a-Pow-1 ) ;
21377: LD_EXP 55
21381: PPUSH
21382: LD_STRING D5a-Pow-1
21384: PPUSH
21385: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21389: LD_EXP 55
21393: PPUSH
21394: LD_STRING D5a-Pow-1a
21396: PPUSH
21397: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21401: LD_INT 10
21403: PPUSH
21404: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21408: LD_EXP 55
21412: PPUSH
21413: LD_STRING D5a-Pow-1b
21415: PPUSH
21416: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21420: LD_EXP 55
21424: PPUSH
21425: LD_STRING D5a-Pow-1c
21427: PPUSH
21428: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21432: LD_EXP 55
21436: PPUSH
21437: LD_STRING D5a-Pow-1d
21439: PPUSH
21440: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21444: LD_INT 35
21446: PPUSH
21447: CALL_OW 67
// if not HasTask ( tmp ) then
21451: LD_VAR 0 3
21455: PPUSH
21456: CALL_OW 314
21460: NOT
21461: IFFALSE 21478
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21463: LD_VAR 0 3
21467: PPUSH
21468: LD_INT 80
21470: PPUSH
21471: LD_INT 67
21473: PPUSH
21474: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21478: LD_VAR 0 3
21482: PPUSH
21483: LD_INT 24
21485: PUSH
21486: LD_INT 1
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: PPUSH
21493: CALL_OW 72
21497: NOT
21498: IFFALSE 21444
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21500: LD_ADDR_VAR 0 3
21504: PUSH
21505: LD_INT 22
21507: PUSH
21508: LD_INT 4
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 92
21517: PUSH
21518: LD_INT 60
21520: PUSH
21521: LD_INT 93
21523: PUSH
21524: LD_INT 10
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: PUSH
21533: LD_INT 3
21535: PUSH
21536: LD_INT 54
21538: PUSH
21539: EMPTY
21540: LIST
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: PPUSH
21551: CALL_OW 69
21555: PUSH
21556: LD_EXP 55
21560: DIFF
21561: ST_TO_ADDR
// if tmp then
21562: LD_VAR 0 3
21566: IFFALSE 21600
// for i in tmp do
21568: LD_ADDR_VAR 0 1
21572: PUSH
21573: LD_VAR 0 3
21577: PUSH
21578: FOR_IN
21579: IFFALSE 21598
// ComMoveXY ( i , 36 , 67 ) ;
21581: LD_VAR 0 1
21585: PPUSH
21586: LD_INT 36
21588: PPUSH
21589: LD_INT 67
21591: PPUSH
21592: CALL_OW 111
21596: GO 21578
21598: POP
21599: POP
// wait ( 0 0$3 ) ;
21600: LD_INT 105
21602: PPUSH
21603: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21607: LD_VAR 0 11
21611: PPUSH
21612: LD_STRING D6-Sol3-1
21614: PPUSH
21615: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21619: LD_EXP 55
21623: PPUSH
21624: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21628: LD_EXP 55
21632: PPUSH
21633: LD_STRING D6-Pow-1
21635: PPUSH
21636: CALL_OW 88
// tmp := [ ] ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: EMPTY
21646: ST_TO_ADDR
// for i = 1 to 2 do
21647: LD_ADDR_VAR 0 1
21651: PUSH
21652: DOUBLE
21653: LD_INT 1
21655: DEC
21656: ST_TO_ADDR
21657: LD_INT 2
21659: PUSH
21660: FOR_TO
21661: IFFALSE 21775
// begin uc_side := 8 ;
21663: LD_ADDR_OWVAR 20
21667: PUSH
21668: LD_INT 8
21670: ST_TO_ADDR
// uc_nation := 2 ;
21671: LD_ADDR_OWVAR 21
21675: PUSH
21676: LD_INT 2
21678: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21679: LD_INT 14
21681: PPUSH
21682: LD_INT 3
21684: PPUSH
21685: LD_INT 2
21687: PPUSH
21688: LD_INT 29
21690: PPUSH
21691: LD_INT 100
21693: PPUSH
21694: CALL 71099 0 5
// veh := CreateVehicle ;
21698: LD_ADDR_VAR 0 13
21702: PUSH
21703: CALL_OW 45
21707: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21708: LD_VAR 0 13
21712: PPUSH
21713: LD_INT 4
21715: PPUSH
21716: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21720: LD_VAR 0 13
21724: PPUSH
21725: LD_INT 99
21727: PPUSH
21728: LD_INT 83
21730: PPUSH
21731: LD_INT 6
21733: PPUSH
21734: LD_INT 0
21736: PPUSH
21737: CALL_OW 50
// wait ( 3 ) ;
21741: LD_INT 3
21743: PPUSH
21744: CALL_OW 67
// Connect ( veh ) ;
21748: LD_VAR 0 13
21752: PPUSH
21753: CALL 74154 0 1
// tmp := tmp ^ veh ;
21757: LD_ADDR_VAR 0 3
21761: PUSH
21762: LD_VAR 0 3
21766: PUSH
21767: LD_VAR 0 13
21771: ADD
21772: ST_TO_ADDR
// end ;
21773: GO 21660
21775: POP
21776: POP
// wait ( 0 0$1 ) ;
21777: LD_INT 35
21779: PPUSH
21780: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21784: LD_INT 99
21786: PPUSH
21787: LD_INT 83
21789: PPUSH
21790: LD_INT 1
21792: PPUSH
21793: LD_INT 10
21795: PPUSH
21796: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21800: LD_INT 99
21802: PPUSH
21803: LD_INT 83
21805: PPUSH
21806: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21810: LD_VAR 0 11
21814: PPUSH
21815: LD_STRING D6-Sol3-2
21817: PPUSH
21818: CALL_OW 88
// async ;
21822: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21823: LD_EXP 55
21827: PPUSH
21828: LD_STRING D6-Pow-2
21830: PPUSH
21831: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21835: LD_VAR 0 3
21839: PUSH
21840: LD_INT 1
21842: ARRAY
21843: PPUSH
21844: LD_VAR 0 9
21848: PPUSH
21849: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21853: LD_VAR 0 3
21857: PUSH
21858: LD_INT 2
21860: ARRAY
21861: PPUSH
21862: LD_INT 22
21864: PUSH
21865: LD_INT 4
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 21
21874: PUSH
21875: LD_INT 3
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PPUSH
21886: CALL_OW 69
21890: PPUSH
21891: LD_VAR 0 3
21895: PUSH
21896: LD_INT 2
21898: ARRAY
21899: PPUSH
21900: CALL_OW 74
21904: PPUSH
21905: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21909: LD_EXP 55
21913: PPUSH
21914: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21918: LD_INT 99
21920: PPUSH
21921: LD_INT 83
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 331
// repeat wait ( 4 ) ;
21931: LD_INT 4
21933: PPUSH
21934: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21938: LD_VAR 0 3
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: CALL_OW 256
21951: PUSH
21952: LD_INT 1000
21954: LESS
21955: IFFALSE 21973
// SetLives ( tmp [ 1 ] , 1000 ) ;
21957: LD_VAR 0 3
21961: PUSH
21962: LD_INT 1
21964: ARRAY
21965: PPUSH
21966: LD_INT 1000
21968: PPUSH
21969: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21973: LD_INT 22
21975: PUSH
21976: LD_INT 4
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 30
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: PPUSH
21997: CALL_OW 69
22001: PUSH
22002: LD_INT 0
22004: EQUAL
22005: IFFALSE 21931
// sync ;
22007: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22008: LD_EXP 55
22012: PPUSH
22013: LD_STRING D6a-Pow-1
22015: PPUSH
22016: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22020: LD_VAR 0 11
22024: PPUSH
22025: LD_STRING D6a-Sol3-1
22027: PPUSH
22028: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22032: LD_EXP 55
22036: PPUSH
22037: LD_STRING D6a-Pow-2
22039: PPUSH
22040: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22044: LD_VAR 0 11
22048: PPUSH
22049: LD_STRING D6a-Sol3-2
22051: PPUSH
22052: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22056: LD_EXP 55
22060: PPUSH
22061: LD_STRING D6a-Pow-3
22063: PPUSH
22064: CALL_OW 88
// powellCenterCameraMode := true ;
22068: LD_ADDR_EXP 20
22072: PUSH
22073: LD_INT 1
22075: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22076: LD_ADDR_VAR 0 1
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 8
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 25
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PPUSH
22105: CALL_OW 69
22109: PUSH
22110: FOR_IN
22111: IFFALSE 22166
// begin SetTag ( i , 1 ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_INT 1
22120: PPUSH
22121: CALL_OW 109
// ComExitBuilding ( i ) ;
22125: LD_VAR 0 1
22129: PPUSH
22130: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22134: LD_VAR 0 1
22138: PPUSH
22139: LD_INT 35
22141: PPUSH
22142: LD_INT 6
22144: PPUSH
22145: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22149: LD_VAR 0 1
22153: PPUSH
22154: LD_INT 53
22156: PPUSH
22157: LD_INT 4
22159: PPUSH
22160: CALL_OW 171
// end ;
22164: GO 22110
22166: POP
22167: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22168: LD_ADDR_VAR 0 3
22172: PUSH
22173: LD_INT 22
22175: PUSH
22176: LD_INT 4
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 21
22185: PUSH
22186: LD_INT 2
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 3
22195: PUSH
22196: LD_INT 34
22198: PUSH
22199: LD_INT 12
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: PPUSH
22215: CALL_OW 69
22219: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22220: LD_EXP 55
22224: PPUSH
22225: LD_VAR 0 3
22229: PPUSH
22230: LD_EXP 55
22234: PPUSH
22235: CALL_OW 74
22239: PPUSH
22240: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22244: LD_EXP 55
22248: PPUSH
22249: LD_INT 100
22251: PPUSH
22252: LD_INT 88
22254: PPUSH
22255: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22259: LD_EXP 55
22263: PPUSH
22264: LD_INT 100
22266: PPUSH
22267: LD_INT 75
22269: PPUSH
22270: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22274: LD_EXP 55
22278: PPUSH
22279: LD_INT 88
22281: PPUSH
22282: LD_INT 53
22284: PPUSH
22285: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22289: LD_INT 8
22291: PPUSH
22292: LD_EXP 55
22296: PPUSH
22297: CALL_OW 471
// repeat wait ( 3 ) ;
22301: LD_INT 3
22303: PPUSH
22304: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22308: LD_INT 22
22310: PUSH
22311: LD_INT 4
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PUSH
22318: LD_INT 92
22320: PUSH
22321: LD_INT 100
22323: PUSH
22324: LD_INT 75
22326: PUSH
22327: LD_INT 6
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: LIST
22334: LIST
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PPUSH
22340: CALL_OW 69
22344: IFFALSE 22301
// async ;
22346: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22347: LD_EXP 55
22351: PPUSH
22352: LD_STRING D6b-Pow-1
22354: PPUSH
22355: CALL_OW 88
// repeat wait ( 3 ) ;
22359: LD_INT 3
22361: PPUSH
22362: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22366: LD_EXP 55
22370: PPUSH
22371: CALL_OW 310
22375: PPUSH
22376: CALL_OW 256
22380: PUSH
22381: LD_INT 1000
22383: LESS
22384: IFFALSE 22403
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22386: LD_EXP 55
22390: PPUSH
22391: CALL_OW 310
22395: PPUSH
22396: LD_INT 1000
22398: PPUSH
22399: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22403: LD_EXP 55
22407: PPUSH
22408: CALL_OW 256
22412: PUSH
22413: LD_INT 1000
22415: LESS
22416: IFFALSE 22430
// SetLives ( Powell , 1000 ) ;
22418: LD_EXP 55
22422: PPUSH
22423: LD_INT 1000
22425: PPUSH
22426: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22430: LD_EXP 55
22434: PPUSH
22435: LD_EXP 60
22439: PPUSH
22440: CALL_OW 296
22444: PUSH
22445: LD_INT 5
22447: LESS
22448: PUSH
22449: LD_EXP 55
22453: PPUSH
22454: CALL_OW 310
22458: PPUSH
22459: LD_EXP 60
22463: PPUSH
22464: CALL_OW 296
22468: PUSH
22469: LD_INT 5
22471: LESS
22472: OR
22473: IFFALSE 22492
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22475: LD_EXP 55
22479: PPUSH
22480: CALL_OW 310
22484: PPUSH
22485: LD_INT 100
22487: PPUSH
22488: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22492: LD_EXP 55
22496: PPUSH
22497: CALL_OW 310
22501: NOT
22502: IFFALSE 22359
// DoNotAttack ( 8 , powellBomb ) ;
22504: LD_INT 8
22506: PPUSH
22507: LD_EXP 60
22511: PPUSH
22512: CALL_OW 471
// game_speed := 4 ;
22516: LD_ADDR_OWVAR 65
22520: PUSH
22521: LD_INT 4
22523: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22524: LD_EXP 55
22528: PPUSH
22529: LD_STRING D6b-Pow-1a
22531: PPUSH
22532: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22536: LD_EXP 55
22540: PPUSH
22541: LD_EXP 60
22545: PPUSH
22546: CALL_OW 180
// sync ;
22550: SYNC
// repeat wait ( 0 0$1 ) ;
22551: LD_INT 35
22553: PPUSH
22554: CALL_OW 67
// until IsInUnit ( Powell ) ;
22558: LD_EXP 55
22562: PPUSH
22563: CALL_OW 310
22567: IFFALSE 22551
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22569: LD_INT 8
22571: PPUSH
22572: LD_EXP 55
22576: PPUSH
22577: CALL_OW 310
22581: PPUSH
22582: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22586: LD_EXP 55
22590: PPUSH
22591: LD_INT 91
22593: PPUSH
22594: LD_INT 44
22596: PPUSH
22597: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22601: LD_EXP 55
22605: PPUSH
22606: LD_INT 96
22608: PPUSH
22609: LD_INT 44
22611: PPUSH
22612: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22616: LD_EXP 55
22620: PPUSH
22621: LD_INT 96
22623: PPUSH
22624: LD_INT 41
22626: PPUSH
22627: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22631: LD_EXP 55
22635: PPUSH
22636: LD_INT 92
22638: PPUSH
22639: LD_INT 39
22641: PPUSH
22642: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22646: LD_EXP 55
22650: PPUSH
22651: LD_INT 88
22653: PPUSH
22654: LD_INT 41
22656: PPUSH
22657: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22661: LD_EXP 55
22665: PPUSH
22666: LD_INT 91
22668: PPUSH
22669: LD_INT 44
22671: PPUSH
22672: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22676: LD_EXP 55
22680: PPUSH
22681: LD_INT 96
22683: PPUSH
22684: LD_INT 44
22686: PPUSH
22687: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22691: LD_EXP 55
22695: PPUSH
22696: LD_INT 96
22698: PPUSH
22699: LD_INT 41
22701: PPUSH
22702: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22706: LD_EXP 55
22710: PPUSH
22711: LD_INT 92
22713: PPUSH
22714: LD_INT 39
22716: PPUSH
22717: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22721: LD_EXP 55
22725: PPUSH
22726: LD_INT 88
22728: PPUSH
22729: LD_INT 41
22731: PPUSH
22732: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22736: LD_EXP 55
22740: PPUSH
22741: LD_INT 91
22743: PPUSH
22744: LD_INT 44
22746: PPUSH
22747: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22751: LD_EXP 55
22755: PPUSH
22756: LD_INT 93
22758: PPUSH
22759: LD_INT 39
22761: PPUSH
22762: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22766: LD_EXP 55
22770: PPUSH
22771: LD_INT 93
22773: PPUSH
22774: LD_INT 36
22776: PPUSH
22777: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22781: LD_INT 122
22783: PPUSH
22784: CALL_OW 67
// game_speed := 4 ;
22788: LD_ADDR_OWVAR 65
22792: PUSH
22793: LD_INT 4
22795: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22796: LD_EXP 55
22800: PPUSH
22801: LD_STRING D6b-Pow-1b
22803: PPUSH
22804: CALL_OW 88
// tmp := [ ] ;
22808: LD_ADDR_VAR 0 3
22812: PUSH
22813: EMPTY
22814: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22815: LD_ADDR_VAR 0 5
22819: PUSH
22820: LD_INT 78
22822: PUSH
22823: LD_INT 47
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: PUSH
22830: LD_INT 106
22832: PUSH
22833: LD_INT 53
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22844: LD_ADDR_VAR 0 1
22848: PUSH
22849: LD_INT 22
22851: PUSH
22852: LD_INT 8
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: PUSH
22859: LD_INT 21
22861: PUSH
22862: LD_INT 3
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PUSH
22869: LD_INT 92
22871: PUSH
22872: LD_INT 90
22874: PUSH
22875: LD_INT 52
22877: PUSH
22878: LD_INT 12
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: LIST
22885: LIST
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: PPUSH
22892: CALL_OW 69
22896: PUSH
22897: FOR_IN
22898: IFFALSE 22923
// tmp := tmp ^ UnitsInside ( i ) ;
22900: LD_ADDR_VAR 0 3
22904: PUSH
22905: LD_VAR 0 3
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 313
22919: ADD
22920: ST_TO_ADDR
22921: GO 22897
22923: POP
22924: POP
// for i in tmp do
22925: LD_ADDR_VAR 0 1
22929: PUSH
22930: LD_VAR 0 3
22934: PUSH
22935: FOR_IN
22936: IFFALSE 23098
// begin dist := 9999 ;
22938: LD_ADDR_VAR 0 8
22942: PUSH
22943: LD_INT 9999
22945: ST_TO_ADDR
// _xy := [ ] ;
22946: LD_ADDR_VAR 0 7
22950: PUSH
22951: EMPTY
22952: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22953: LD_VAR 0 1
22957: PPUSH
22958: LD_INT 1
22960: PPUSH
22961: CALL_OW 109
// ComExitBuilding ( i ) ;
22965: LD_VAR 0 1
22969: PPUSH
22970: CALL_OW 122
// for j in xy do
22974: LD_ADDR_VAR 0 2
22978: PUSH
22979: LD_VAR 0 5
22983: PUSH
22984: FOR_IN
22985: IFFALSE 23067
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22987: LD_VAR 0 1
22991: PPUSH
22992: LD_VAR 0 2
22996: PUSH
22997: LD_INT 1
22999: ARRAY
23000: PPUSH
23001: LD_VAR 0 2
23005: PUSH
23006: LD_INT 2
23008: ARRAY
23009: PPUSH
23010: CALL_OW 297
23014: PUSH
23015: LD_VAR 0 8
23019: LESS
23020: IFFALSE 23065
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23022: LD_ADDR_VAR 0 8
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: LD_VAR 0 2
23036: PUSH
23037: LD_INT 1
23039: ARRAY
23040: PPUSH
23041: LD_VAR 0 2
23045: PUSH
23046: LD_INT 2
23048: ARRAY
23049: PPUSH
23050: CALL_OW 297
23054: ST_TO_ADDR
// _xy := j ;
23055: LD_ADDR_VAR 0 7
23059: PUSH
23060: LD_VAR 0 2
23064: ST_TO_ADDR
// end ;
23065: GO 22984
23067: POP
23068: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23069: LD_VAR 0 1
23073: PPUSH
23074: LD_VAR 0 7
23078: PUSH
23079: LD_INT 1
23081: ARRAY
23082: PPUSH
23083: LD_VAR 0 7
23087: PUSH
23088: LD_INT 2
23090: ARRAY
23091: PPUSH
23092: CALL_OW 171
// end ;
23096: GO 22935
23098: POP
23099: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23100: LD_ADDR_VAR 0 4
23104: PUSH
23105: LD_VAR 0 3
23109: PPUSH
23110: LD_INT 26
23112: PUSH
23113: LD_INT 1
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: PUSH
23120: LD_INT 25
23122: PUSH
23123: LD_INT 1
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: PPUSH
23134: CALL_OW 72
23138: ST_TO_ADDR
// if tmp2 < 2 then
23139: LD_VAR 0 4
23143: PUSH
23144: LD_INT 2
23146: LESS
23147: IFFALSE 23216
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23149: LD_ADDR_VAR 0 4
23153: PUSH
23154: LD_INT 22
23156: PUSH
23157: LD_INT 8
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: PUSH
23164: LD_INT 26
23166: PUSH
23167: LD_INT 1
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PUSH
23174: LD_INT 3
23176: PUSH
23177: LD_INT 25
23179: PUSH
23180: LD_INT 15
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: LIST
23194: LIST
23195: PPUSH
23196: CALL_OW 69
23200: PUSH
23201: LD_EXP 57
23205: PUSH
23206: LD_EXP 58
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: DIFF
23215: ST_TO_ADDR
// if tmp2 then
23216: LD_VAR 0 4
23220: IFFALSE 23238
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23222: LD_VAR 0 4
23226: PUSH
23227: LD_INT 1
23229: ARRAY
23230: PPUSH
23231: LD_STRING D6b-ArSol1-1
23233: PPUSH
23234: CALL_OW 88
// async ;
23238: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23239: LD_EXP 55
23243: PPUSH
23244: LD_STRING D6b-Pow-2
23246: PPUSH
23247: CALL_OW 88
// wait ( 0 0$1 ) ;
23251: LD_INT 35
23253: PPUSH
23254: CALL_OW 67
// if tmp2 > 1 then
23258: LD_VAR 0 4
23262: PUSH
23263: LD_INT 1
23265: GREATER
23266: IFFALSE 23284
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23268: LD_VAR 0 4
23272: PUSH
23273: LD_INT 2
23275: ARRAY
23276: PPUSH
23277: LD_STRING D6b-ArSol2-1
23279: PPUSH
23280: CALL_OW 88
// sync ;
23284: SYNC
// repeat wait ( 5 ) ;
23285: LD_INT 5
23287: PPUSH
23288: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23292: LD_INT 93
23294: PPUSH
23295: LD_INT 36
23297: PPUSH
23298: CALL_OW 428
23302: PPUSH
23303: CALL_OW 255
23307: PUSH
23308: LD_INT 4
23310: EQUAL
23311: IFFALSE 23285
// DialogueOn ;
23313: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23317: LD_INT 10
23319: PPUSH
23320: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23324: LD_EXP 55
23328: PPUSH
23329: LD_STRING D6b-Pow-2a
23331: PPUSH
23332: CALL_OW 88
// DialogueOff ;
23336: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23340: LD_EXP 55
23344: PPUSH
23345: CALL_OW 310
23349: PPUSH
23350: LD_INT 332
23352: PPUSH
23353: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23357: LD_INT 93
23359: PPUSH
23360: LD_INT 35
23362: PPUSH
23363: LD_INT 1
23365: PPUSH
23366: LD_INT 6
23368: NEG
23369: PPUSH
23370: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23381: LD_INT 332
23383: PPUSH
23384: CALL_OW 256
23388: PUSH
23389: LD_INT 1000
23391: LESS
23392: PUSH
23393: LD_INT 332
23395: PPUSH
23396: CALL_OW 300
23400: AND
23401: IFFALSE 23413
// SetLives ( kozlov_fac , 0 ) ;
23403: LD_INT 332
23405: PPUSH
23406: LD_INT 0
23408: PPUSH
23409: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23413: LD_INT 332
23415: PPUSH
23416: CALL_OW 301
23420: PUSH
23421: LD_EXP 55
23425: PPUSH
23426: CALL_OW 301
23430: OR
23431: IFFALSE 23374
// game_speed := 4 ;
23433: LD_ADDR_OWVAR 65
23437: PUSH
23438: LD_INT 4
23440: ST_TO_ADDR
// powellCenterCameraMode := false ;
23441: LD_ADDR_EXP 20
23445: PUSH
23446: LD_INT 0
23448: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23449: LD_ADDR_VAR 0 1
23453: PUSH
23454: LD_VAR 0 3
23458: PUSH
23459: LD_INT 22
23461: PUSH
23462: LD_INT 8
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PUSH
23469: LD_INT 25
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PPUSH
23483: CALL_OW 69
23487: UNION
23488: PUSH
23489: FOR_IN
23490: IFFALSE 23506
// SetTag ( i , 0 ) ;
23492: LD_VAR 0 1
23496: PPUSH
23497: LD_INT 0
23499: PPUSH
23500: CALL_OW 109
23504: GO 23489
23506: POP
23507: POP
// wait ( 0 0$3 ) ;
23508: LD_INT 105
23510: PPUSH
23511: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23515: LD_INT 93
23517: PPUSH
23518: LD_INT 35
23520: PPUSH
23521: LD_INT 1
23523: PPUSH
23524: CALL_OW 331
// DialogueOn ;
23528: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23532: LD_VAR 0 11
23536: PPUSH
23537: LD_STRING D6c-Sol3-1
23539: PPUSH
23540: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23544: LD_INT 10
23546: PPUSH
23547: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23551: LD_EXP 36
23555: PPUSH
23556: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23560: LD_EXP 36
23564: PPUSH
23565: LD_STRING D6c-JMM-1
23567: PPUSH
23568: CALL_OW 88
// if Cyrus then
23572: LD_EXP 42
23576: IFFALSE 23590
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23578: LD_EXP 42
23582: PPUSH
23583: LD_STRING D6c-Cyrus-1
23585: PPUSH
23586: CALL_OW 88
// if Bobby then
23590: LD_EXP 41
23594: IFFALSE 23608
// Say ( Bobby , D6c-Bobby-1 ) ;
23596: LD_EXP 41
23600: PPUSH
23601: LD_STRING D6c-Bobby-1
23603: PPUSH
23604: CALL_OW 88
// if Cornel then
23608: LD_EXP 47
23612: IFFALSE 23626
// Say ( Cornel , D6c-Corn-1 ) ;
23614: LD_EXP 47
23618: PPUSH
23619: LD_STRING D6c-Corn-1
23621: PPUSH
23622: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23626: LD_ADDR_VAR 0 4
23630: PUSH
23631: LD_INT 2
23633: PUSH
23634: LD_INT 22
23636: PUSH
23637: LD_INT 1
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: PUSH
23644: LD_INT 22
23646: PUSH
23647: LD_INT 4
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: LIST
23658: PUSH
23659: LD_INT 26
23661: PUSH
23662: LD_INT 1
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: PUSH
23669: LD_INT 3
23671: PUSH
23672: LD_INT 25
23674: PUSH
23675: LD_INT 16
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 25
23684: PUSH
23685: LD_INT 12
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: LIST
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 69
23706: PUSH
23707: LD_VAR 0 11
23711: PUSH
23712: LD_EXP 36
23716: UNION
23717: PUSH
23718: LD_EXP 56
23722: UNION
23723: PUSH
23724: EMPTY
23725: LIST
23726: DIFF
23727: ST_TO_ADDR
// if tmp2 then
23728: LD_VAR 0 4
23732: IFFALSE 23750
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23734: LD_VAR 0 4
23738: PUSH
23739: LD_INT 1
23741: ARRAY
23742: PPUSH
23743: LD_STRING D6c-Sol1-1
23745: PPUSH
23746: CALL_OW 88
// if Lisa then
23750: LD_EXP 39
23754: IFFALSE 23768
// Say ( Lisa , D6c-Lisa-1 ) ;
23756: LD_EXP 39
23760: PPUSH
23761: LD_STRING D6c-Lisa-1
23763: PPUSH
23764: CALL_OW 88
// if Gary then
23768: LD_EXP 48
23772: IFFALSE 23786
// Say ( Gary , D6c-Gary-1 ) ;
23774: LD_EXP 48
23778: PPUSH
23779: LD_STRING D6c-Gary-1
23781: PPUSH
23782: CALL_OW 88
// if Donaldson then
23786: LD_EXP 40
23790: IFFALSE 23804
// Say ( Donaldson , D6c-Don-1 ) ;
23792: LD_EXP 40
23796: PPUSH
23797: LD_STRING D6c-Don-1
23799: PPUSH
23800: CALL_OW 88
// if tmp2 > 1 then
23804: LD_VAR 0 4
23808: PUSH
23809: LD_INT 1
23811: GREATER
23812: IFFALSE 23830
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23814: LD_VAR 0 4
23818: PUSH
23819: LD_INT 2
23821: ARRAY
23822: PPUSH
23823: LD_STRING D6c-Sol2-1
23825: PPUSH
23826: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23830: LD_VAR 0 11
23834: PPUSH
23835: LD_STRING D6c-Sol3-2
23837: PPUSH
23838: CALL_OW 88
// dwait ( 0 0$1 ) ;
23842: LD_INT 35
23844: PPUSH
23845: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23849: LD_EXP 36
23853: PPUSH
23854: LD_STRING D6c-JMM-2
23856: PPUSH
23857: CALL_OW 88
// DialogueOff ;
23861: CALL_OW 7
// Video ( false ) ;
23865: LD_INT 0
23867: PPUSH
23868: CALL 106816 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23872: LD_INT 22
23874: PUSH
23875: LD_INT 4
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PPUSH
23882: CALL_OW 69
23886: PPUSH
23887: LD_INT 1
23889: PPUSH
23890: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23894: LD_INT 4
23896: PPUSH
23897: LD_INT 4
23899: PPUSH
23900: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23904: LD_ADDR_VAR 0 1
23908: PUSH
23909: LD_INT 4
23911: PPUSH
23912: LD_INT 1
23914: PPUSH
23915: LD_INT 2
23917: PPUSH
23918: CALL 64136 0 3
23922: PUSH
23923: FOR_IN
23924: IFFALSE 23961
// if GetTech ( i , 1 ) <> state_researched then
23926: LD_VAR 0 1
23930: PPUSH
23931: LD_INT 1
23933: PPUSH
23934: CALL_OW 321
23938: PUSH
23939: LD_INT 2
23941: NONEQUAL
23942: IFFALSE 23959
// SetTech ( i , 1 , state_researched ) ;
23944: LD_VAR 0 1
23948: PPUSH
23949: LD_INT 1
23951: PPUSH
23952: LD_INT 2
23954: PPUSH
23955: CALL_OW 322
23959: GO 23923
23961: POP
23962: POP
// missionStage := 6 ;
23963: LD_ADDR_EXP 15
23967: PUSH
23968: LD_INT 6
23970: ST_TO_ADDR
// activeAttacks := true ;
23971: LD_ADDR_EXP 16
23975: PUSH
23976: LD_INT 1
23978: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23979: LD_STRING M2
23981: PPUSH
23982: CALL_OW 337
// SaveForQuickRestart ;
23986: CALL_OW 22
// wait ( 0 0$40 ) ;
23990: LD_INT 1400
23992: PPUSH
23993: CALL_OW 67
// DialogueOn ;
23997: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24001: LD_EXP 59
24005: PPUSH
24006: LD_STRING D7-Friend-1
24008: PPUSH
24009: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24013: LD_EXP 36
24017: PPUSH
24018: LD_STRING D7-JMM-1
24020: PPUSH
24021: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24025: LD_EXP 59
24029: PPUSH
24030: LD_STRING D7-Friend-2
24032: PPUSH
24033: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24037: LD_EXP 36
24041: PPUSH
24042: LD_STRING D7-JMM-2
24044: PPUSH
24045: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24049: LD_EXP 59
24053: PPUSH
24054: LD_STRING D7-Friend-3
24056: PPUSH
24057: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24061: LD_EXP 36
24065: PPUSH
24066: LD_STRING D7-JMM-3
24068: PPUSH
24069: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24073: LD_EXP 59
24077: PPUSH
24078: LD_STRING D7-Friend-4
24080: PPUSH
24081: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24085: LD_EXP 36
24089: PPUSH
24090: LD_STRING D7-JMM-4
24092: PPUSH
24093: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24097: LD_EXP 59
24101: PPUSH
24102: LD_STRING D7-Friend-5
24104: PPUSH
24105: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24109: LD_EXP 36
24113: PPUSH
24114: LD_STRING D7-JMM-5
24116: PPUSH
24117: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24121: LD_EXP 59
24125: PPUSH
24126: LD_STRING D7-Friend-6
24128: PPUSH
24129: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24133: LD_EXP 36
24137: PPUSH
24138: LD_STRING D7-JMM-6
24140: PPUSH
24141: CALL_OW 88
// DialogueOff ;
24145: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24149: LD_STRING Mlegion
24151: PPUSH
24152: CALL_OW 337
// RebuildKozlovFactory ;
24156: CALL 4773 0 0
// end ;
24160: PPOPN 13
24162: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24163: LD_EXP 20
24167: PUSH
24168: LD_EXP 55
24172: PPUSH
24173: CALL_OW 300
24177: AND
24178: IFFALSE 24220
24180: GO 24182
24182: DISABLE
// begin enable ;
24183: ENABLE
// if IsInUnit ( Powell ) then
24184: LD_EXP 55
24188: PPUSH
24189: CALL_OW 310
24193: IFFALSE 24211
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24195: LD_EXP 55
24199: PPUSH
24200: CALL_OW 310
24204: PPUSH
24205: CALL_OW 85
24209: GO 24220
// CenterOnUnits ( Powell ) ;
24211: LD_EXP 55
24215: PPUSH
24216: CALL_OW 85
// end ;
24220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24221: LD_INT 22
24223: PUSH
24224: LD_INT 8
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 34
24233: PUSH
24234: LD_INT 48
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PPUSH
24245: CALL_OW 69
24249: IFFALSE 24512
24251: GO 24253
24253: DISABLE
24254: LD_INT 0
24256: PPUSH
24257: PPUSH
// begin if missionStage < 9 then
24258: LD_EXP 15
24262: PUSH
24263: LD_INT 9
24265: LESS
24266: IFFALSE 24276
// missionStage := 9 ;
24268: LD_ADDR_EXP 15
24272: PUSH
24273: LD_INT 9
24275: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24276: LD_ADDR_VAR 0 1
24280: PUSH
24281: LD_INT 22
24283: PUSH
24284: LD_INT 8
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: LD_INT 34
24293: PUSH
24294: LD_INT 48
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PPUSH
24305: CALL_OW 69
24309: PUSH
24310: LD_INT 1
24312: ARRAY
24313: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24314: LD_INT 175
24316: PPUSH
24317: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24321: LD_EXP 12
24325: PUSH
24326: LD_EXP 3
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: LD_INT 2
24336: PUSH
24337: EMPTY
24338: LIST
24339: LIST
24340: IN
24341: OR
24342: IFFALSE 24365
// target := [ 68 , 108 , 1 ] else
24344: LD_ADDR_VAR 0 2
24348: PUSH
24349: LD_INT 68
24351: PUSH
24352: LD_INT 108
24354: PUSH
24355: LD_INT 1
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24384
// target := [ 181 , 88 , 2 ] ;
24365: LD_ADDR_VAR 0 2
24369: PUSH
24370: LD_INT 181
24372: PUSH
24373: LD_INT 88
24375: PUSH
24376: LD_INT 2
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: LIST
24383: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24384: LD_VAR 0 1
24388: PPUSH
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 1
24396: ARRAY
24397: PPUSH
24398: LD_VAR 0 2
24402: PUSH
24403: LD_INT 2
24405: ARRAY
24406: PPUSH
24407: CALL_OW 176
// if target [ 3 ] = 1 then
24411: LD_VAR 0 2
24415: PUSH
24416: LD_INT 3
24418: ARRAY
24419: PUSH
24420: LD_INT 1
24422: EQUAL
24423: IFFALSE 24439
// SayRadio ( Kurt , D12-Kurt-1 ) else
24425: LD_EXP 57
24429: PPUSH
24430: LD_STRING D12-Kurt-1
24432: PPUSH
24433: CALL_OW 94
24437: GO 24463
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24439: LD_EXP 57
24443: PPUSH
24444: LD_STRING D12a-Kurt-1
24446: PPUSH
24447: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24451: LD_EXP 71
24455: PPUSH
24456: LD_STRING D12a-Roth-1
24458: PPUSH
24459: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24463: LD_INT 350
24465: PPUSH
24466: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24470: LD_VAR 0 1
24474: PPUSH
24475: LD_INT 22
24477: PUSH
24478: LD_INT 8
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 30
24487: PUSH
24488: LD_INT 3
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: PPUSH
24499: CALL_OW 69
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 228
// end ;
24512: PPOPN 2
24514: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24515: LD_INT 22
24517: PUSH
24518: LD_INT 8
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 21
24527: PUSH
24528: LD_INT 1
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 23
24537: PUSH
24538: LD_INT 2
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: PPUSH
24550: CALL_OW 69
24554: PUSH
24555: LD_INT 8
24557: PUSH
24558: LD_INT 7
24560: PUSH
24561: LD_INT 6
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: LIST
24568: PUSH
24569: LD_OWVAR 67
24573: ARRAY
24574: LESSEQUAL
24575: PUSH
24576: LD_INT 22
24578: PUSH
24579: LD_INT 8
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 34
24588: PUSH
24589: LD_INT 48
24591: PUSH
24592: EMPTY
24593: LIST
24594: LIST
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PPUSH
24600: CALL_OW 69
24604: NOT
24605: AND
24606: PUSH
24607: LD_EXP 57
24611: PPUSH
24612: CALL_OW 302
24616: AND
24617: IFFALSE 24934
24619: GO 24621
24621: DISABLE
// begin DialogueOn ;
24622: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24626: LD_EXP 36
24630: PPUSH
24631: LD_STRING D13-JMM-1
24633: PPUSH
24634: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24638: LD_EXP 57
24642: PPUSH
24643: LD_STRING D13-Kurt-1
24645: PPUSH
24646: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24650: LD_EXP 36
24654: PPUSH
24655: LD_STRING D13-JMM-2
24657: PPUSH
24658: CALL_OW 88
// if FakeInfo then
24662: LD_EXP 12
24666: IFFALSE 24686
// begin Say ( Kurt , D13-Kurt-2 ) ;
24668: LD_EXP 57
24672: PPUSH
24673: LD_STRING D13-Kurt-2
24675: PPUSH
24676: CALL_OW 88
// DialogueOff ;
24680: CALL_OW 7
// exit ;
24684: GO 24934
// end ; if not KurtStatus then
24686: LD_EXP 3
24690: NOT
24691: IFFALSE 24707
// Say ( Kurt , D13-Kurt-2b ) else
24693: LD_EXP 57
24697: PPUSH
24698: LD_STRING D13-Kurt-2b
24700: PPUSH
24701: CALL_OW 88
24705: GO 24719
// Say ( Kurt , D13-Kurt-2a ) ;
24707: LD_EXP 57
24711: PPUSH
24712: LD_STRING D13-Kurt-2a
24714: PPUSH
24715: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24719: LD_EXP 57
24723: PPUSH
24724: LD_STRING D13-Kurt-2a
24726: PPUSH
24727: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24731: LD_EXP 36
24735: PPUSH
24736: LD_STRING D13-JMM-3
24738: PPUSH
24739: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24743: LD_EXP 57
24747: PPUSH
24748: LD_STRING D13-Kurt-3
24750: PPUSH
24751: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24755: LD_EXP 36
24759: PPUSH
24760: LD_STRING D13-JMM-4
24762: PPUSH
24763: CALL_OW 88
// DialogueOff ;
24767: CALL_OW 7
// MC_Kill ( 3 ) ;
24771: LD_INT 3
24773: PPUSH
24774: CALL 34165 0 1
// KillUnit ( Kozlov ) ;
24778: LD_EXP 58
24782: PPUSH
24783: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24787: LD_INT 22
24789: PUSH
24790: LD_INT 8
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 21
24799: PUSH
24800: LD_INT 3
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 23
24809: PUSH
24810: LD_INT 3
24812: PUSH
24813: EMPTY
24814: LIST
24815: LIST
24816: PUSH
24817: LD_INT 30
24819: PUSH
24820: LD_INT 3
24822: PUSH
24823: EMPTY
24824: LIST
24825: LIST
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: LIST
24831: LIST
24832: PPUSH
24833: CALL_OW 69
24837: PUSH
24838: LD_INT 1
24840: ARRAY
24841: PPUSH
24842: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24846: LD_INT 8
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24856: LD_INT 22
24858: PUSH
24859: LD_INT 8
24861: PUSH
24862: EMPTY
24863: LIST
24864: LIST
24865: PPUSH
24866: CALL_OW 69
24870: PPUSH
24871: LD_INT 1
24873: PPUSH
24874: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24878: LD_INT 8
24880: PPUSH
24881: LD_INT 1
24883: PPUSH
24884: LD_INT 1
24886: PPUSH
24887: LD_INT 1
24889: PPUSH
24890: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24894: LD_EXP 59
24898: PPUSH
24899: LD_INT 37
24901: PPUSH
24902: LD_INT 1
24904: PPUSH
24905: LD_INT 0
24907: PPUSH
24908: CALL_OW 48
// wait ( 0 0$1 ) ;
24912: LD_INT 35
24914: PPUSH
24915: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24919: LD_EXP 59
24923: PPUSH
24924: LD_INT 60
24926: PPUSH
24927: LD_INT 95
24929: PPUSH
24930: CALL_OW 111
// end ;
24934: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24935: LD_INT 22
24937: PUSH
24938: LD_INT 8
24940: PUSH
24941: EMPTY
24942: LIST
24943: LIST
24944: PUSH
24945: LD_INT 21
24947: PUSH
24948: LD_INT 1
24950: PUSH
24951: EMPTY
24952: LIST
24953: LIST
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: PPUSH
24959: CALL_OW 69
24963: PUSH
24964: LD_INT 0
24966: EQUAL
24967: IFFALSE 24987
24969: GO 24971
24971: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24972: LD_STRING MlegionOut
24974: PPUSH
24975: CALL_OW 337
// legionDestroyed := true ;
24979: LD_ADDR_EXP 22
24983: PUSH
24984: LD_INT 1
24986: ST_TO_ADDR
// end ;
24987: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24988: LD_INT 1
24990: PPUSH
24991: LD_EXP 59
24995: PPUSH
24996: CALL_OW 292
25000: IFFALSE 25300
25002: GO 25004
25004: DISABLE
25005: LD_INT 0
25007: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
25008: LD_EXP 59
25012: PPUSH
25013: CALL_OW 87
// DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25021: LD_EXP 36
25025: PPUSH
25026: LD_STRING D14-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25033: LD_EXP 59
25037: PPUSH
25038: LD_STRING D14-Friend-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25045: LD_EXP 36
25049: PPUSH
25050: LD_STRING D14-JMM-2
25052: PPUSH
25053: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25057: LD_EXP 59
25061: PPUSH
25062: LD_STRING D14-Friend-2
25064: PPUSH
25065: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25069: LD_EXP 36
25073: PPUSH
25074: LD_STRING D14-JMM-3
25076: PPUSH
25077: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25081: LD_EXP 59
25085: PPUSH
25086: LD_STRING D14-Friend-3
25088: PPUSH
25089: CALL_OW 88
// DialogueOff ;
25093: CALL_OW 7
// dec = Query ( Q14 ) ;
25097: LD_ADDR_VAR 0 1
25101: PUSH
25102: LD_STRING Q14
25104: PPUSH
25105: CALL_OW 97
25109: ST_TO_ADDR
// if dec = 1 then
25110: LD_VAR 0 1
25114: PUSH
25115: LD_INT 1
25117: EQUAL
25118: IFFALSE 25152
// begin DialogueOn ;
25120: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25124: LD_EXP 36
25128: PPUSH
25129: LD_STRING D14a-JMM-1
25131: PPUSH
25132: CALL_OW 88
// DialogueOff ;
25136: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25140: LD_EXP 59
25144: PPUSH
25145: LD_INT 1
25147: PPUSH
25148: CALL_OW 235
// end ; if dec = 2 then
25152: LD_VAR 0 1
25156: PUSH
25157: LD_INT 2
25159: EQUAL
25160: IFFALSE 25206
// begin DialogueOn ;
25162: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25166: LD_EXP 36
25170: PPUSH
25171: LD_STRING D14b-JMM-1
25173: PPUSH
25174: CALL_OW 88
// DialogueOff ;
25178: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25182: LD_EXP 59
25186: PPUSH
25187: LD_INT 9
25189: PPUSH
25190: LD_INT 2
25192: PPUSH
25193: CALL_OW 111
// AddComHold ( Friend ) ;
25197: LD_EXP 59
25201: PPUSH
25202: CALL_OW 200
// end ; if dec = 3 then
25206: LD_VAR 0 1
25210: PUSH
25211: LD_INT 3
25213: EQUAL
25214: IFFALSE 25300
// begin DialogueOn ;
25216: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25220: LD_EXP 36
25224: PPUSH
25225: LD_STRING D14c-JMM-1
25227: PPUSH
25228: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25232: LD_EXP 59
25236: PPUSH
25237: LD_STRING D14c-Friend-1
25239: PPUSH
25240: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25244: LD_EXP 36
25248: PPUSH
25249: LD_STRING D14c-JMM-2
25251: PPUSH
25252: CALL_OW 88
// DialogueOff ;
25256: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25260: LD_INT 8
25262: PPUSH
25263: LD_INT 1
25265: PPUSH
25266: LD_INT 2
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25276: LD_EXP 59
25280: PPUSH
25281: LD_INT 9
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: CALL_OW 111
// AddComHold ( Friend ) ;
25291: LD_EXP 59
25295: PPUSH
25296: CALL_OW 200
// end ; end ;
25300: PPOPN 1
25302: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25303: LD_INT 9
25305: PPUSH
25306: LD_INT 2
25308: PPUSH
25309: CALL_OW 428
25313: PUSH
25314: LD_EXP 59
25318: EQUAL
25319: PUSH
25320: LD_EXP 59
25324: PPUSH
25325: CALL_OW 255
25329: PUSH
25330: LD_INT 8
25332: EQUAL
25333: AND
25334: IFFALSE 25348
25336: GO 25338
25338: DISABLE
// RemoveUnit ( Friend ) ;
25339: LD_EXP 59
25343: PPUSH
25344: CALL_OW 64
25348: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25349: LD_EXP 14
25353: PUSH
25354: LD_INT 31500
25356: GREATEREQUAL
25357: PUSH
25358: LD_EXP 7
25362: AND
25363: PUSH
25364: LD_EXP 2
25368: AND
25369: IFFALSE 25799
25371: GO 25373
25373: DISABLE
25374: LD_INT 0
25376: PPUSH
25377: PPUSH
25378: PPUSH
// begin missionStage := 7 ;
25379: LD_ADDR_EXP 15
25383: PUSH
25384: LD_INT 7
25386: ST_TO_ADDR
// uc_side = 1 ;
25387: LD_ADDR_OWVAR 20
25391: PUSH
25392: LD_INT 1
25394: ST_TO_ADDR
// uc_nation = 1 ;
25395: LD_ADDR_OWVAR 21
25399: PUSH
25400: LD_INT 1
25402: ST_TO_ADDR
// for i = 1 to 5 do
25403: LD_ADDR_VAR 0 1
25407: PUSH
25408: DOUBLE
25409: LD_INT 1
25411: DEC
25412: ST_TO_ADDR
25413: LD_INT 5
25415: PUSH
25416: FOR_TO
25417: IFFALSE 25513
// begin vc_engine = 3 ;
25419: LD_ADDR_OWVAR 39
25423: PUSH
25424: LD_INT 3
25426: ST_TO_ADDR
// vc_control = 3 ;
25427: LD_ADDR_OWVAR 38
25431: PUSH
25432: LD_INT 3
25434: ST_TO_ADDR
// vc_chassis = 3 ;
25435: LD_ADDR_OWVAR 37
25439: PUSH
25440: LD_INT 3
25442: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25443: LD_ADDR_OWVAR 40
25447: PUSH
25448: LD_INT 5
25450: PUSH
25451: LD_INT 9
25453: PUSH
25454: LD_INT 7
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: LIST
25461: PUSH
25462: LD_INT 1
25464: PPUSH
25465: LD_INT 3
25467: PPUSH
25468: CALL_OW 12
25472: ARRAY
25473: ST_TO_ADDR
// veh = CreateVehicle ;
25474: LD_ADDR_VAR 0 2
25478: PUSH
25479: CALL_OW 45
25483: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_INT 1
25491: PPUSH
25492: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25496: LD_VAR 0 2
25500: PPUSH
25501: LD_INT 19
25503: PPUSH
25504: LD_INT 0
25506: PPUSH
25507: CALL_OW 49
// end ;
25511: GO 25416
25513: POP
25514: POP
// vc_engine = 3 ;
25515: LD_ADDR_OWVAR 39
25519: PUSH
25520: LD_INT 3
25522: ST_TO_ADDR
// vc_control = 1 ;
25523: LD_ADDR_OWVAR 38
25527: PUSH
25528: LD_INT 1
25530: ST_TO_ADDR
// vc_chassis = 3 ;
25531: LD_ADDR_OWVAR 37
25535: PUSH
25536: LD_INT 3
25538: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25539: LD_ADDR_OWVAR 40
25543: PUSH
25544: LD_INT 5
25546: PUSH
25547: LD_INT 9
25549: PUSH
25550: LD_INT 7
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 1
25560: PPUSH
25561: LD_INT 3
25563: PPUSH
25564: CALL_OW 12
25568: ARRAY
25569: ST_TO_ADDR
// vehG = CreateVehicle ;
25570: LD_ADDR_VAR 0 3
25574: PUSH
25575: CALL_OW 45
25579: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25580: LD_VAR 0 3
25584: PPUSH
25585: LD_INT 1
25587: PPUSH
25588: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25592: LD_VAR 0 3
25596: PPUSH
25597: LD_INT 19
25599: PPUSH
25600: LD_INT 0
25602: PPUSH
25603: CALL_OW 49
// if JMMGirl = 1 then
25607: LD_EXP 7
25611: PUSH
25612: LD_INT 1
25614: EQUAL
25615: IFFALSE 25671
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25617: LD_ADDR_EXP 37
25621: PUSH
25622: LD_STRING Joan
25624: PPUSH
25625: LD_INT 1
25627: PPUSH
25628: LD_STRING 14_
25630: PPUSH
25631: CALL 64073 0 3
25635: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25636: LD_EXP 37
25640: PPUSH
25641: LD_VAR 0 3
25645: PPUSH
25646: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25650: LD_VAR 0 3
25654: PPUSH
25655: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25659: LD_EXP 37
25663: PPUSH
25664: LD_STRING D10BW-Joan-1
25666: PPUSH
25667: CALL_OW 94
// end ; if JMMGirl = 2 then
25671: LD_EXP 7
25675: PUSH
25676: LD_INT 2
25678: EQUAL
25679: IFFALSE 25735
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25681: LD_ADDR_EXP 39
25685: PUSH
25686: LD_STRING Lisa
25688: PPUSH
25689: LD_INT 1
25691: PPUSH
25692: LD_STRING 14_
25694: PPUSH
25695: CALL 64073 0 3
25699: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25700: LD_EXP 39
25704: PPUSH
25705: LD_VAR 0 3
25709: PPUSH
25710: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25714: LD_VAR 0 3
25718: PPUSH
25719: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25723: LD_EXP 39
25727: PPUSH
25728: LD_STRING D10BW-Lisa-1
25730: PPUSH
25731: CALL_OW 94
// end ; if JMMGirl = 3 then
25735: LD_EXP 7
25739: PUSH
25740: LD_INT 3
25742: EQUAL
25743: IFFALSE 25799
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25745: LD_ADDR_EXP 51
25749: PUSH
25750: LD_STRING Connie
25752: PPUSH
25753: LD_INT 1
25755: PPUSH
25756: LD_STRING 14_
25758: PPUSH
25759: CALL 64073 0 3
25763: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25764: LD_EXP 51
25768: PPUSH
25769: LD_VAR 0 3
25773: PPUSH
25774: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25778: LD_VAR 0 3
25782: PPUSH
25783: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25787: LD_EXP 39
25791: PPUSH
25792: LD_STRING D10BW-Con-1
25794: PPUSH
25795: CALL_OW 94
// end ; end ;
25799: PPOPN 3
25801: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25802: LD_EXP 14
25806: PUSH
25807: LD_INT 94500
25809: GREATEREQUAL
25810: IFFALSE 26222
25812: GO 25814
25814: DISABLE
25815: LD_INT 0
25817: PPUSH
25818: PPUSH
25819: PPUSH
// begin tmp := PrepareStevensSquad ;
25820: LD_ADDR_VAR 0 3
25824: PUSH
25825: CALL 2147 0 0
25829: ST_TO_ADDR
// if not tmp then
25830: LD_VAR 0 3
25834: NOT
25835: IFFALSE 25839
// exit ;
25837: GO 26222
// uc_side := 1 ;
25839: LD_ADDR_OWVAR 20
25843: PUSH
25844: LD_INT 1
25846: ST_TO_ADDR
// uc_nation := 1 ;
25847: LD_ADDR_OWVAR 21
25851: PUSH
25852: LD_INT 1
25854: ST_TO_ADDR
// for i in tmp do
25855: LD_ADDR_VAR 0 1
25859: PUSH
25860: LD_VAR 0 3
25864: PUSH
25865: FOR_IN
25866: IFFALSE 25963
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25868: LD_INT 3
25870: PPUSH
25871: LD_INT 3
25873: PPUSH
25874: LD_INT 1
25876: PPUSH
25877: LD_INT 5
25879: PUSH
25880: LD_INT 9
25882: PUSH
25883: LD_INT 7
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: LIST
25890: PUSH
25891: LD_INT 1
25893: PPUSH
25894: LD_INT 3
25896: PPUSH
25897: CALL_OW 12
25901: ARRAY
25902: PPUSH
25903: LD_INT 40
25905: PPUSH
25906: CALL 71099 0 5
// veh := CreateVehicle ;
25910: LD_ADDR_VAR 0 2
25914: PUSH
25915: CALL_OW 45
25919: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25920: LD_VAR 0 2
25924: PPUSH
25925: LD_INT 1
25927: PPUSH
25928: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25932: LD_VAR 0 2
25936: PPUSH
25937: LD_INT 19
25939: PPUSH
25940: LD_INT 0
25942: PPUSH
25943: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25947: LD_VAR 0 1
25951: PPUSH
25952: LD_VAR 0 2
25956: PPUSH
25957: CALL_OW 52
// end ;
25961: GO 25865
25963: POP
25964: POP
// missionStage := 8 ;
25965: LD_ADDR_EXP 15
25969: PUSH
25970: LD_INT 8
25972: ST_TO_ADDR
// DialogueOn ;
25973: CALL_OW 6
// if Stevens then
25977: LD_EXP 38
25981: IFFALSE 26095
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25983: LD_EXP 38
25987: PPUSH
25988: CALL_OW 310
25992: PPUSH
25993: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25997: LD_EXP 38
26001: PPUSH
26002: LD_STRING D8-Huck-1
26004: PPUSH
26005: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26009: LD_EXP 36
26013: PPUSH
26014: LD_STRING D8-JMM-1
26016: PPUSH
26017: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26021: LD_EXP 38
26025: PPUSH
26026: LD_STRING D8-Huck-2
26028: PPUSH
26029: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26033: LD_EXP 36
26037: PPUSH
26038: LD_STRING D8-JMM-2
26040: PPUSH
26041: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26045: LD_EXP 38
26049: PPUSH
26050: LD_STRING D8-Huck-3
26052: PPUSH
26053: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26057: LD_EXP 36
26061: PPUSH
26062: LD_STRING D8-JMM-3
26064: PPUSH
26065: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26069: LD_EXP 38
26073: PPUSH
26074: LD_STRING D8-Huck-4
26076: PPUSH
26077: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26081: LD_EXP 36
26085: PPUSH
26086: LD_STRING D8-JMM-4
26088: PPUSH
26089: CALL_OW 88
// end else
26093: GO 26205
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26095: LD_EXP 52
26099: PPUSH
26100: CALL_OW 310
26104: PPUSH
26105: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26109: LD_EXP 52
26113: PPUSH
26114: LD_STRING D8-Huck-1
26116: PPUSH
26117: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26121: LD_EXP 36
26125: PPUSH
26126: LD_STRING D8-JMM-1a
26128: PPUSH
26129: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26133: LD_EXP 52
26137: PPUSH
26138: LD_STRING D8-Huck-2
26140: PPUSH
26141: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26145: LD_EXP 36
26149: PPUSH
26150: LD_STRING D8-JMM-2
26152: PPUSH
26153: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26157: LD_EXP 52
26161: PPUSH
26162: LD_STRING D8-Huck-3
26164: PPUSH
26165: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26169: LD_EXP 36
26173: PPUSH
26174: LD_STRING D8-JMM-3
26176: PPUSH
26177: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26181: LD_EXP 52
26185: PPUSH
26186: LD_STRING D8-Huck-4
26188: PPUSH
26189: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26193: LD_EXP 36
26197: PPUSH
26198: LD_STRING D8-JMM-4
26200: PPUSH
26201: CALL_OW 88
// end ; DialogueOff ;
26205: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26209: LD_INT 25
26211: PPUSH
26212: LD_INT 1
26214: PPUSH
26215: LD_INT 1
26217: PPUSH
26218: CALL_OW 322
// end ;
26222: PPOPN 3
26224: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26225: LD_INT 1
26227: PPUSH
26228: LD_EXP 68
26232: PPUSH
26233: CALL_OW 292
26237: IFFALSE 26488
26239: GO 26241
26241: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26242: LD_EXP 68
26246: PPUSH
26247: CALL_OW 87
// DialogueOn ;
26251: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26255: LD_EXP 36
26259: PPUSH
26260: LD_STRING D10nB-JMM-1
26262: PPUSH
26263: CALL_OW 88
// if BurlakStatus = 1 then
26267: LD_EXP 9
26271: PUSH
26272: LD_INT 1
26274: EQUAL
26275: IFFALSE 26289
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26277: LD_EXP 67
26281: PPUSH
26282: LD_STRING D10nB-Vse-1a
26284: PPUSH
26285: CALL_OW 94
// end ; if BurlakStatus = 0 then
26289: LD_EXP 9
26293: PUSH
26294: LD_INT 0
26296: EQUAL
26297: IFFALSE 26311
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26299: LD_EXP 67
26303: PPUSH
26304: LD_STRING D10nB-Vse-1
26306: PPUSH
26307: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26311: LD_EXP 36
26315: PPUSH
26316: LD_STRING D10nB-JMM-2
26318: PPUSH
26319: CALL_OW 88
// if KappaStatus then
26323: LD_EXP 2
26327: IFFALSE 26341
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26329: LD_EXP 67
26333: PPUSH
26334: LD_STRING D10nB-Vse-5a
26336: PPUSH
26337: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26341: LD_EXP 2
26345: NOT
26346: PUSH
26347: LD_EXP 6
26351: PUSH
26352: LD_INT 0
26354: EQUAL
26355: AND
26356: IFFALSE 26484
// begin if JMMGirl = 1 then
26358: LD_EXP 7
26362: PUSH
26363: LD_INT 1
26365: EQUAL
26366: IFFALSE 26416
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26368: LD_EXP 67
26372: PPUSH
26373: LD_STRING D10nB-Vse-2
26375: PPUSH
26376: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26380: LD_EXP 36
26384: PPUSH
26385: LD_STRING D10nB-JMM-3
26387: PPUSH
26388: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26392: LD_EXP 67
26396: PPUSH
26397: LD_STRING D10nB-Vse-3
26399: PPUSH
26400: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26404: LD_EXP 36
26408: PPUSH
26409: LD_STRING D10nB-JMM-4
26411: PPUSH
26412: CALL_OW 88
// end ; if JMMGirl = 2 then
26416: LD_EXP 7
26420: PUSH
26421: LD_INT 2
26423: EQUAL
26424: IFFALSE 26450
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26426: LD_EXP 67
26430: PPUSH
26431: LD_STRING D10nB-Vse-4
26433: PPUSH
26434: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26438: LD_EXP 36
26442: PPUSH
26443: LD_STRING D10nB-JMM-5
26445: PPUSH
26446: CALL_OW 88
// end ; if JMMGirl = 3 then
26450: LD_EXP 7
26454: PUSH
26455: LD_INT 3
26457: EQUAL
26458: IFFALSE 26484
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26460: LD_EXP 67
26464: PPUSH
26465: LD_STRING D10nB-Vse-5
26467: PPUSH
26468: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26472: LD_EXP 36
26476: PPUSH
26477: LD_STRING D10nB-JMM-6
26479: PPUSH
26480: CALL_OW 88
// end ; end ; DialogueOff ;
26484: CALL_OW 7
// end ;
26488: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26489: LD_EXP 14
26493: PUSH
26494: LD_INT 115500
26496: GREATEREQUAL
26497: IFFALSE 26856
26499: GO 26501
26501: DISABLE
26502: LD_INT 0
26504: PPUSH
// begin missionStage := 10 ;
26505: LD_ADDR_EXP 15
26509: PUSH
26510: LD_INT 10
26512: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26513: LD_ADDR_VAR 0 1
26517: PUSH
26518: LD_INT 22
26520: PUSH
26521: LD_INT 1
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 26
26530: PUSH
26531: LD_INT 1
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: LD_INT 3
26540: PUSH
26541: LD_INT 25
26543: PUSH
26544: LD_INT 12
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 3
26557: PUSH
26558: LD_INT 25
26560: PUSH
26561: LD_INT 16
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: LIST
26576: LIST
26577: PPUSH
26578: CALL_OW 69
26582: PUSH
26583: LD_EXP 36
26587: PUSH
26588: LD_EXP 38
26592: PUSH
26593: LD_EXP 52
26597: PUSH
26598: LD_EXP 39
26602: PUSH
26603: LD_EXP 40
26607: PUSH
26608: LD_EXP 41
26612: PUSH
26613: LD_EXP 42
26617: PUSH
26618: LD_EXP 43
26622: PUSH
26623: LD_EXP 44
26627: PUSH
26628: LD_EXP 45
26632: PUSH
26633: LD_EXP 46
26637: PUSH
26638: LD_EXP 47
26642: PUSH
26643: LD_EXP 48
26647: PUSH
26648: LD_EXP 49
26652: PUSH
26653: LD_EXP 50
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: DIFF
26675: ST_TO_ADDR
// if not tmp and Brown then
26676: LD_VAR 0 1
26680: NOT
26681: PUSH
26682: LD_EXP 44
26686: AND
26687: IFFALSE 26702
// tmp := [ Brown ] ;
26689: LD_ADDR_VAR 0 1
26693: PUSH
26694: LD_EXP 44
26698: PUSH
26699: EMPTY
26700: LIST
26701: ST_TO_ADDR
// DialogueOn ;
26702: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26706: LD_VAR 0 1
26710: PUSH
26711: LD_INT 1
26713: ARRAY
26714: PPUSH
26715: LD_STRING D11-Sol1-1
26717: PPUSH
26718: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26722: LD_EXP 61
26726: PPUSH
26727: LD_STRING D11-Pla-1
26729: PPUSH
26730: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26734: LD_EXP 62
26738: PPUSH
26739: LD_STRING D11-Kov-1
26741: PPUSH
26742: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26746: LD_EXP 61
26750: PPUSH
26751: LD_STRING D11-Pla-2
26753: PPUSH
26754: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26758: LD_VAR 0 1
26762: PUSH
26763: LD_INT 1
26765: ARRAY
26766: PPUSH
26767: LD_STRING D11-Sol1-2
26769: PPUSH
26770: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26774: LD_EXP 36
26778: PPUSH
26779: LD_STRING D11-JMM-2
26781: PPUSH
26782: CALL_OW 88
// DialogueOff ;
26786: CALL_OW 7
// allowBehemothConstruct := true ;
26790: LD_ADDR_EXP 25
26794: PUSH
26795: LD_INT 1
26797: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26798: LD_STRING M4
26800: PPUSH
26801: CALL_OW 337
// BuildBehemoths ;
26805: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26809: LD_INT 31500
26811: PPUSH
26812: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26816: LD_EXP 27
26820: IFFALSE 26824
// break ;
26822: GO 26856
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26824: LD_INT 267
26826: PPUSH
26827: CALL_OW 274
26831: PPUSH
26832: LD_INT 1
26834: PPUSH
26835: CALL_OW 275
26839: PUSH
26840: LD_INT 1000
26842: GREATEREQUAL
26843: IFFALSE 26849
// BuildBehemoths ;
26845: CALL 7577 0 0
// until not behemothBuilders ;
26849: LD_EXP 70
26853: NOT
26854: IFFALSE 26809
// end ;
26856: PPOPN 1
26858: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26859: LD_EXP 70
26863: NOT
26864: PUSH
26865: LD_EXP 28
26869: NOT
26870: AND
26871: PUSH
26872: LD_EXP 25
26876: AND
26877: IFFALSE 26897
26879: GO 26881
26881: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26882: LD_STRING M4a
26884: PPUSH
26885: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26889: LD_ADDR_EXP 27
26893: PUSH
26894: LD_INT 1
26896: ST_TO_ADDR
// end ;
26897: END
// every 0 0$1 trigger behemothDone do
26898: LD_EXP 28
26902: IFFALSE 26914
26904: GO 26906
26906: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26907: LD_STRING M4b
26909: PPUSH
26910: CALL_OW 337
26914: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26915: LD_EXP 29
26919: NOT
26920: IFFALSE 27116
26922: GO 26924
26924: DISABLE
26925: LD_INT 0
26927: PPUSH
26928: PPUSH
// begin enable ;
26929: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26930: LD_ADDR_VAR 0 1
26934: PUSH
26935: LD_INT 3
26937: PPUSH
26938: CALL 106892 0 1
26942: ST_TO_ADDR
// if not tmp and not behemothDone then
26943: LD_VAR 0 1
26947: NOT
26948: PUSH
26949: LD_EXP 28
26953: NOT
26954: AND
26955: IFFALSE 26991
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26957: LD_ADDR_VAR 0 1
26961: PUSH
26962: LD_INT 22
26964: PUSH
26965: LD_INT 3
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 30
26974: PUSH
26975: LD_INT 37
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PPUSH
26986: CALL_OW 69
26990: ST_TO_ADDR
// if not tmp then
26991: LD_VAR 0 1
26995: NOT
26996: IFFALSE 27000
// exit ;
26998: GO 27116
// for i in tmp do
27000: LD_ADDR_VAR 0 2
27004: PUSH
27005: LD_VAR 0 1
27009: PUSH
27010: FOR_IN
27011: IFFALSE 27114
// if See ( 1 , i ) then
27013: LD_INT 1
27015: PPUSH
27016: LD_VAR 0 2
27020: PPUSH
27021: CALL_OW 292
27025: IFFALSE 27112
// begin if GetType ( i ) = unit_building then
27027: LD_VAR 0 2
27031: PPUSH
27032: CALL_OW 247
27036: PUSH
27037: LD_INT 3
27039: EQUAL
27040: IFFALSE 27078
// begin CenterNowOnUnits ( i ) ;
27042: LD_VAR 0 2
27046: PPUSH
27047: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27051: LD_EXP 36
27055: PPUSH
27056: LD_STRING D17a-JMM-1
27058: PPUSH
27059: CALL_OW 88
// seeBehemoth := true ;
27063: LD_ADDR_EXP 29
27067: PUSH
27068: LD_INT 1
27070: ST_TO_ADDR
// disable ;
27071: DISABLE
// exit ;
27072: POP
27073: POP
27074: GO 27116
// end else
27076: GO 27112
// begin CenterNowOnUnits ( i ) ;
27078: LD_VAR 0 2
27082: PPUSH
27083: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27087: LD_EXP 36
27091: PPUSH
27092: LD_STRING D17b-JMM-1
27094: PPUSH
27095: CALL_OW 88
// seeBehemoth := true ;
27099: LD_ADDR_EXP 29
27103: PUSH
27104: LD_INT 1
27106: ST_TO_ADDR
// disable ;
27107: DISABLE
// exit ;
27108: POP
27109: POP
27110: GO 27116
// end ; end ;
27112: GO 27010
27114: POP
27115: POP
// end ;
27116: PPOPN 2
27118: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27119: LD_EXP 14
27123: PUSH
27124: LD_INT 116550
27126: GREATEREQUAL
27127: IFFALSE 28303
27129: GO 27131
27131: DISABLE
27132: LD_INT 0
27134: PPUSH
27135: PPUSH
27136: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27137: LD_INT 2
27139: PPUSH
27140: LD_INT 23
27142: PUSH
27143: LD_INT 3
27145: PUSH
27146: LD_INT 3
27148: PUSH
27149: LD_INT 48
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: LIST
27156: LIST
27157: PUSH
27158: EMPTY
27159: LIST
27160: PPUSH
27161: CALL 57729 0 2
// repeat wait ( 0 0$1 ) ;
27165: LD_INT 35
27167: PPUSH
27168: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27172: LD_INT 22
27174: PUSH
27175: LD_INT 3
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 34
27184: PUSH
27185: LD_INT 48
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PPUSH
27196: CALL_OW 69
27200: IFFALSE 27165
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27202: LD_ADDR_VAR 0 1
27206: PUSH
27207: LD_INT 22
27209: PUSH
27210: LD_INT 3
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 34
27219: PUSH
27220: LD_INT 48
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PPUSH
27231: CALL_OW 69
27235: PUSH
27236: LD_INT 1
27238: ARRAY
27239: ST_TO_ADDR
// missionStage := 12 ;
27240: LD_ADDR_EXP 15
27244: PUSH
27245: LD_INT 12
27247: ST_TO_ADDR
// platonovHasBomb := true ;
27248: LD_ADDR_EXP 30
27252: PUSH
27253: LD_INT 1
27255: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27256: LD_VAR 0 1
27260: PPUSH
27261: LD_INT 181
27263: PPUSH
27264: LD_INT 86
27266: PPUSH
27267: CALL_OW 171
// AddComHold ( bomb ) ;
27271: LD_VAR 0 1
27275: PPUSH
27276: CALL_OW 200
// wait ( 0 0$10 ) ;
27280: LD_INT 350
27282: PPUSH
27283: CALL_OW 67
// DialogueOn ;
27287: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27291: LD_EXP 61
27295: PPUSH
27296: LD_STRING D15-Pla-1
27298: PPUSH
27299: CALL_OW 94
// dec = Query ( Q15a ) ;
27303: LD_ADDR_VAR 0 2
27307: PUSH
27308: LD_STRING Q15a
27310: PPUSH
27311: CALL_OW 97
27315: ST_TO_ADDR
// if dec = 1 then
27316: LD_VAR 0 2
27320: PUSH
27321: LD_INT 1
27323: EQUAL
27324: IFFALSE 27347
// begin Say ( JMM , D15a-JMM-1 ) ;
27326: LD_EXP 36
27330: PPUSH
27331: LD_STRING D15a-JMM-1
27333: PPUSH
27334: CALL_OW 88
// YouLost ( Surrender ) ;
27338: LD_STRING Surrender
27340: PPUSH
27341: CALL_OW 104
// exit ;
27345: GO 28303
// end ; if dec = 2 then
27347: LD_VAR 0 2
27351: PUSH
27352: LD_INT 2
27354: EQUAL
27355: IFFALSE 27424
// begin Say ( JMM , D15b-JMM-1 ) ;
27357: LD_EXP 36
27361: PPUSH
27362: LD_STRING D15b-JMM-1
27364: PPUSH
27365: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27369: LD_EXP 61
27373: PPUSH
27374: LD_STRING D15b-Pla-1
27376: PPUSH
27377: CALL_OW 94
// DialogueOff ;
27381: CALL_OW 7
// wait ( 3 3$00 ) ;
27385: LD_INT 6300
27387: PPUSH
27388: CALL_OW 67
// DialogueOn ;
27392: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27396: LD_EXP 36
27400: PPUSH
27401: LD_STRING D15d-JMM-1a
27403: PPUSH
27404: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27408: LD_EXP 61
27412: PPUSH
27413: LD_STRING D15d-Pla-1
27415: PPUSH
27416: CALL_OW 94
// DialogueOff ;
27420: CALL_OW 7
// end ; if dec = 3 then
27424: LD_VAR 0 2
27428: PUSH
27429: LD_INT 3
27431: EQUAL
27432: IFFALSE 27486
// begin Say ( JMM , D15c-JMM-1 ) ;
27434: LD_EXP 36
27438: PPUSH
27439: LD_STRING D15c-JMM-1
27441: PPUSH
27442: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27446: LD_EXP 61
27450: PPUSH
27451: LD_STRING D15c-Pla-1
27453: PPUSH
27454: CALL_OW 94
// DialogueOff ;
27458: CALL_OW 7
// wait ( 0 0$15 ) ;
27462: LD_INT 525
27464: PPUSH
27465: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27469: LD_VAR 0 1
27473: PPUSH
27474: LD_INT 60
27476: PPUSH
27477: LD_INT 95
27479: PPUSH
27480: CALL_OW 116
// exit ;
27484: GO 28303
// end ; if dec = 4 then
27486: LD_VAR 0 2
27490: PUSH
27491: LD_INT 4
27493: EQUAL
27494: IFFALSE 27524
// begin Say ( JMM , D15d-JMM-1 ) ;
27496: LD_EXP 36
27500: PPUSH
27501: LD_STRING D15d-JMM-1
27503: PPUSH
27504: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27508: LD_EXP 61
27512: PPUSH
27513: LD_STRING D15d-Pla-1
27515: PPUSH
27516: CALL_OW 94
// DialogueOff ;
27520: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27524: LD_EXP 59
27528: PPUSH
27529: CALL_OW 302
27533: PUSH
27534: LD_EXP 59
27538: PPUSH
27539: CALL_OW 255
27543: PUSH
27544: LD_INT 1
27546: EQUAL
27547: AND
27548: PUSH
27549: LD_INT 22
27551: PUSH
27552: LD_INT 1
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: LD_INT 34
27561: PUSH
27562: LD_INT 8
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: PUSH
27569: EMPTY
27570: LIST
27571: LIST
27572: PPUSH
27573: CALL_OW 69
27577: NOT
27578: AND
27579: IFFALSE 28204
// begin SetSide ( Friend , 8 ) ;
27581: LD_EXP 59
27585: PPUSH
27586: LD_INT 8
27588: PPUSH
27589: CALL_OW 235
// if IsInUnit ( Friend ) then
27593: LD_EXP 59
27597: PPUSH
27598: CALL_OW 310
27602: IFFALSE 27613
// ComExitBuilding ( Friend ) ;
27604: LD_EXP 59
27608: PPUSH
27609: CALL_OW 122
// if IsDriver ( Friend ) then
27613: LD_EXP 59
27617: PPUSH
27618: CALL 104569 0 1
27622: IFFALSE 27633
// ComExitVehicle ( Friend ) ;
27624: LD_EXP 59
27628: PPUSH
27629: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27633: LD_EXP 59
27637: PPUSH
27638: LD_INT 9
27640: PPUSH
27641: LD_INT 2
27643: PPUSH
27644: CALL_OW 171
// wait ( 0 0$05 ) ;
27648: LD_INT 175
27650: PPUSH
27651: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27655: LD_EXP 59
27659: PPUSH
27660: CALL_OW 87
// DialogueOn ;
27664: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27668: LD_EXP 36
27672: PPUSH
27673: LD_STRING D16-JMM-1
27675: PPUSH
27676: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27680: LD_EXP 59
27684: PPUSH
27685: LD_STRING D16-Friend-1
27687: PPUSH
27688: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27692: LD_EXP 36
27696: PPUSH
27697: LD_STRING D16-JMM-2
27699: PPUSH
27700: CALL_OW 88
// DialogueOff ;
27704: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27708: LD_EXP 59
27712: PPUSH
27713: LD_INT 1
27715: PPUSH
27716: CALL_OW 235
// ComHold ( Friend ) ;
27720: LD_EXP 59
27724: PPUSH
27725: CALL_OW 140
// wait ( 0 0$20 ) ;
27729: LD_INT 700
27731: PPUSH
27732: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27736: LD_EXP 59
27740: PPUSH
27741: LD_INT 9
27743: PPUSH
27744: LD_INT 2
27746: PPUSH
27747: CALL_OW 297
27751: PUSH
27752: LD_INT 30
27754: LESS
27755: IFFALSE 27824
// begin SetSide ( Friend , 8 ) ;
27757: LD_EXP 59
27761: PPUSH
27762: LD_INT 8
27764: PPUSH
27765: CALL_OW 235
// if IsInUnit ( Friend ) then
27769: LD_EXP 59
27773: PPUSH
27774: CALL_OW 310
27778: IFFALSE 27789
// ComExitBuilding ( Friend ) ;
27780: LD_EXP 59
27784: PPUSH
27785: CALL_OW 122
// if IsDriver ( Friend ) then
27789: LD_EXP 59
27793: PPUSH
27794: CALL 104569 0 1
27798: IFFALSE 27809
// ComExitVehicle ( Friend ) ;
27800: LD_EXP 59
27804: PPUSH
27805: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27809: LD_EXP 59
27813: PPUSH
27814: LD_INT 9
27816: PPUSH
27817: LD_INT 2
27819: PPUSH
27820: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27824: LD_INT 1050
27826: PPUSH
27827: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27831: LD_INT 22
27833: PUSH
27834: LD_INT 1
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 34
27843: PUSH
27844: LD_INT 8
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PPUSH
27855: CALL_OW 69
27859: NOT
27860: IFFALSE 28182
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27862: LD_ADDR_VAR 0 3
27866: PUSH
27867: LD_INT 22
27869: PUSH
27870: LD_INT 1
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 26
27879: PUSH
27880: LD_INT 1
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 3
27889: PUSH
27890: LD_INT 25
27892: PUSH
27893: LD_INT 12
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: LD_INT 25
27902: PUSH
27903: LD_INT 16
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: LIST
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: LIST
27919: PPUSH
27920: CALL_OW 69
27924: PUSH
27925: LD_EXP 36
27929: PUSH
27930: LD_EXP 38
27934: PUSH
27935: LD_EXP 52
27939: PUSH
27940: LD_EXP 39
27944: PUSH
27945: LD_EXP 40
27949: PUSH
27950: LD_EXP 41
27954: PUSH
27955: LD_EXP 42
27959: PUSH
27960: LD_EXP 43
27964: PUSH
27965: LD_EXP 44
27969: PUSH
27970: LD_EXP 45
27974: PUSH
27975: LD_EXP 46
27979: PUSH
27980: LD_EXP 47
27984: PUSH
27985: LD_EXP 48
27989: PUSH
27990: LD_EXP 49
27994: PUSH
27995: LD_EXP 50
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: LIST
28016: DIFF
28017: ST_TO_ADDR
// DialogueOn ;
28018: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28022: LD_EXP 61
28026: PPUSH
28027: LD_STRING D16a-Pla-1
28029: PPUSH
28030: CALL_OW 94
// if Stevens then
28034: LD_EXP 38
28038: IFFALSE 28054
// Say ( Stevens , D16a-Huck-1 ) else
28040: LD_EXP 38
28044: PPUSH
28045: LD_STRING D16a-Huck-1
28047: PPUSH
28048: CALL_OW 88
28052: GO 28096
// if Baker then
28054: LD_EXP 52
28058: IFFALSE 28074
// Say ( Baker , D16a-Huck-1 ) else
28060: LD_EXP 52
28064: PPUSH
28065: LD_STRING D16a-Huck-1
28067: PPUSH
28068: CALL_OW 88
28072: GO 28096
// if tmp then
28074: LD_VAR 0 3
28078: IFFALSE 28096
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28080: LD_VAR 0 3
28084: PUSH
28085: LD_INT 1
28087: ARRAY
28088: PPUSH
28089: LD_STRING D16a-Sol1-1
28091: PPUSH
28092: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28096: LD_EXP 59
28100: PPUSH
28101: CALL_OW 255
28105: PUSH
28106: LD_INT 8
28108: EQUAL
28109: IFFALSE 28125
// Say ( JMM , D16a-JMM-1 ) else
28111: LD_EXP 36
28115: PPUSH
28116: LD_STRING D16a-JMM-1
28118: PPUSH
28119: CALL_OW 88
28123: GO 28161
// begin Say ( JMM , D16a-JMM-1a ) ;
28125: LD_EXP 36
28129: PPUSH
28130: LD_STRING D16a-JMM-1a
28132: PPUSH
28133: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28137: LD_EXP 59
28141: PPUSH
28142: LD_STRING D16a-Friend-1
28144: PPUSH
28145: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28149: LD_EXP 59
28153: PPUSH
28154: LD_INT 3
28156: PPUSH
28157: CALL_OW 235
// end ; DialogueOff ;
28161: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 60
28172: PPUSH
28173: LD_INT 95
28175: PPUSH
28176: CALL_OW 116
// end else
28180: GO 28202
// begin DialogueOn ;
28182: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28186: LD_EXP 61
28190: PPUSH
28191: LD_STRING D16c-Pla-
28193: PPUSH
28194: CALL_OW 94
// DialogueOff ;
28198: CALL_OW 7
// end ; end else
28202: GO 28303
// begin wait ( 3 3$00 ) ;
28204: LD_INT 6300
28206: PPUSH
28207: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28211: LD_INT 22
28213: PUSH
28214: LD_INT 1
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 34
28223: PUSH
28224: LD_INT 8
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PPUSH
28235: CALL_OW 69
28239: NOT
28240: IFFALSE 28283
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28242: LD_EXP 61
28246: PPUSH
28247: LD_STRING D16b-Pla-1
28249: PPUSH
28250: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28254: LD_EXP 36
28258: PPUSH
28259: LD_STRING D16b-JMM-
28261: PPUSH
28262: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28266: LD_VAR 0 1
28270: PPUSH
28271: LD_INT 60
28273: PPUSH
28274: LD_INT 95
28276: PPUSH
28277: CALL_OW 116
// end else
28281: GO 28303
// begin DialogueOn ;
28283: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28287: LD_EXP 61
28291: PPUSH
28292: LD_STRING D16c-Pla-
28294: PPUSH
28295: CALL_OW 94
// DialogueOff ;
28299: CALL_OW 7
// end ; end ; end ;
28303: PPOPN 3
28305: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28306: LD_EXP 14
28310: PUSH
28311: LD_INT 126000
28313: GREATEREQUAL
28314: PUSH
28315: LD_EXP 23
28319: NOT
28320: AND
28321: PUSH
28322: LD_EXP 71
28326: PPUSH
28327: CALL_OW 302
28331: AND
28332: IFFALSE 28690
28334: GO 28336
28336: DISABLE
28337: LD_INT 0
28339: PPUSH
// begin missionStage = 11 ;
28340: LD_ADDR_EXP 15
28344: PUSH
28345: LD_INT 11
28347: ST_TO_ADDR
// DialogueOn ;
28348: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28352: LD_EXP 71
28356: PPUSH
28357: LD_STRING D9-Roth-1
28359: PPUSH
28360: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28364: LD_EXP 36
28368: PPUSH
28369: LD_STRING D9-JMM-1
28371: PPUSH
28372: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28376: LD_EXP 71
28380: PPUSH
28381: LD_STRING D9-Roth-2
28383: PPUSH
28384: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28388: LD_EXP 71
28392: PPUSH
28393: LD_STRING D9-Roth-2a
28395: PPUSH
28396: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28400: LD_EXP 61
28404: PPUSH
28405: LD_STRING D9-Pla-2
28407: PPUSH
28408: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28412: LD_EXP 71
28416: PPUSH
28417: LD_STRING D9-Roth-3
28419: PPUSH
28420: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28424: LD_EXP 61
28428: PPUSH
28429: LD_STRING D9-Pla-3
28431: PPUSH
28432: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28436: LD_EXP 71
28440: PPUSH
28441: LD_STRING D9-Roth-4
28443: PPUSH
28444: CALL_OW 94
// dec = Query ( Q9 ) ;
28448: LD_ADDR_VAR 0 1
28452: PUSH
28453: LD_STRING Q9
28455: PPUSH
28456: CALL_OW 97
28460: ST_TO_ADDR
// if dec = 1 then
28461: LD_VAR 0 1
28465: PUSH
28466: LD_INT 1
28468: EQUAL
28469: IFFALSE 28483
// SayRadio ( Roth , D9a-Roth-1 ) ;
28471: LD_EXP 71
28475: PPUSH
28476: LD_STRING D9a-Roth-1
28478: PPUSH
28479: CALL_OW 94
// if dec = 2 then
28483: LD_VAR 0 1
28487: PUSH
28488: LD_INT 2
28490: EQUAL
28491: IFFALSE 28517
// begin Say ( JMM , D9b-JMM-1 ) ;
28493: LD_EXP 36
28497: PPUSH
28498: LD_STRING D9b-JMM-1
28500: PPUSH
28501: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28505: LD_EXP 71
28509: PPUSH
28510: LD_STRING D9b-Roth-1
28512: PPUSH
28513: CALL_OW 94
// end ; if dec = 3 then
28517: LD_VAR 0 1
28521: PUSH
28522: LD_INT 3
28524: EQUAL
28525: IFFALSE 28587
// begin Say ( JMM , D9c-JMM-1 ) ;
28527: LD_EXP 36
28531: PPUSH
28532: LD_STRING D9c-JMM-1
28534: PPUSH
28535: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28539: LD_EXP 71
28543: PPUSH
28544: LD_STRING D9c-Roth-1
28546: PPUSH
28547: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28551: LD_EXP 36
28555: PPUSH
28556: LD_STRING D9c-JMM-2
28558: PPUSH
28559: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28563: LD_EXP 71
28567: PPUSH
28568: LD_STRING D9c-Roth-2
28570: PPUSH
28571: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28575: LD_EXP 36
28579: PPUSH
28580: LD_STRING D9c-JMM-3
28582: PPUSH
28583: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28587: LD_EXP 71
28591: PPUSH
28592: LD_STRING D9c-Roth-3
28594: PPUSH
28595: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28599: LD_EXP 71
28603: PPUSH
28604: LD_STRING D9cont-Roth-1
28606: PPUSH
28607: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28611: LD_EXP 36
28615: PPUSH
28616: LD_STRING D9cont-JMM-1
28618: PPUSH
28619: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28623: LD_EXP 71
28627: PPUSH
28628: LD_STRING D9cont-Roth-2
28630: PPUSH
28631: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28635: LD_EXP 36
28639: PPUSH
28640: LD_STRING D9cont-JMM-2
28642: PPUSH
28643: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28647: LD_EXP 71
28651: PPUSH
28652: LD_STRING D9cont-Roth-3
28654: PPUSH
28655: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28659: LD_EXP 36
28663: PPUSH
28664: LD_STRING D9cont-JMM-3
28666: PPUSH
28667: CALL_OW 88
// DialogueOff ;
28671: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28675: LD_STRING M3
28677: PPUSH
28678: CALL_OW 337
// allianceActive := true ;
28682: LD_ADDR_EXP 31
28686: PUSH
28687: LD_INT 1
28689: ST_TO_ADDR
// end ;
28690: PPOPN 1
28692: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28693: LD_EXP 61
28697: PPUSH
28698: CALL_OW 301
28702: PUSH
28703: LD_EXP 64
28707: PPUSH
28708: CALL_OW 301
28712: AND
28713: PUSH
28714: LD_INT 22
28716: PUSH
28717: LD_INT 3
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 21
28726: PUSH
28727: LD_INT 1
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 50
28736: PUSH
28737: EMPTY
28738: LIST
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: LIST
28744: PPUSH
28745: CALL_OW 69
28749: PUSH
28750: LD_INT 7
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: LD_INT 9
28758: PUSH
28759: EMPTY
28760: LIST
28761: LIST
28762: LIST
28763: PUSH
28764: LD_OWVAR 67
28768: ARRAY
28769: LESS
28770: AND
28771: IFFALSE 29542
28773: GO 28775
28775: DISABLE
28776: LD_INT 0
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
// begin MC_Kill ( 1 ) ;
28782: LD_INT 1
28784: PPUSH
28785: CALL 34165 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28789: LD_INT 1
28791: PPUSH
28792: LD_INT 3
28794: PPUSH
28795: LD_INT 1
28797: PPUSH
28798: LD_INT 1
28800: PPUSH
28801: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28805: LD_ADDR_VAR 0 1
28809: PUSH
28810: LD_INT 22
28812: PUSH
28813: LD_INT 3
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 21
28822: PUSH
28823: LD_INT 1
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 24
28832: PUSH
28833: LD_INT 900
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: PPUSH
28845: CALL_OW 69
28849: PUSH
28850: FOR_IN
28851: IFFALSE 28882
// if GetSex ( i ) = sex_male then
28853: LD_VAR 0 1
28857: PPUSH
28858: CALL_OW 258
28862: PUSH
28863: LD_INT 1
28865: EQUAL
28866: IFFALSE 28880
// begin tmp = i ;
28868: LD_ADDR_VAR 0 2
28872: PUSH
28873: LD_VAR 0 1
28877: ST_TO_ADDR
// break ;
28878: GO 28882
// end ;
28880: GO 28850
28882: POP
28883: POP
// if tmp = 0 then
28884: LD_VAR 0 2
28888: PUSH
28889: LD_INT 0
28891: EQUAL
28892: IFFALSE 28946
// begin uc_side = 3 ;
28894: LD_ADDR_OWVAR 20
28898: PUSH
28899: LD_INT 3
28901: ST_TO_ADDR
// uc_nation = 3 ;
28902: LD_ADDR_OWVAR 21
28906: PUSH
28907: LD_INT 3
28909: ST_TO_ADDR
// hc_name =  ;
28910: LD_ADDR_OWVAR 26
28914: PUSH
28915: LD_STRING 
28917: ST_TO_ADDR
// hc_gallery =  ;
28918: LD_ADDR_OWVAR 33
28922: PUSH
28923: LD_STRING 
28925: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28926: LD_INT 1
28928: PPUSH
28929: LD_INT 10
28931: PPUSH
28932: CALL_OW 381
// tmp = CreateHuman ;
28936: LD_ADDR_VAR 0 2
28940: PUSH
28941: CALL_OW 44
28945: ST_TO_ADDR
// end ; DialogueOn ;
28946: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28950: LD_VAR 0 2
28954: PPUSH
28955: LD_STRING DSurrenderRussians-RSol1-1a
28957: PPUSH
28958: CALL_OW 88
// DialogueOff ;
28962: CALL_OW 7
// russianDestroyed := true ;
28966: LD_ADDR_EXP 21
28970: PUSH
28971: LD_INT 1
28973: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28974: LD_INT 22
28976: PUSH
28977: LD_INT 3
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 21
28986: PUSH
28987: LD_INT 1
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PPUSH
28998: CALL_OW 69
29002: PPUSH
29003: CALL_OW 122
// wait ( 0 0$1 ) ;
29007: LD_INT 35
29009: PPUSH
29010: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29014: LD_INT 22
29016: PUSH
29017: LD_INT 3
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 21
29026: PUSH
29027: LD_INT 1
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PPUSH
29038: CALL_OW 69
29042: PPUSH
29043: LD_INT 25
29045: PPUSH
29046: CALL_OW 173
// wait ( 0 0$10 ) ;
29050: LD_INT 350
29052: PPUSH
29053: CALL_OW 67
// PrepareOmarInvasion ;
29057: CALL 13710 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29061: LD_ADDR_VAR 0 2
29065: PUSH
29066: LD_EXP 89
29070: PPUSH
29071: CALL_OW 250
29075: PUSH
29076: LD_EXP 89
29080: PPUSH
29081: CALL_OW 251
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29090: LD_VAR 0 2
29094: PUSH
29095: LD_INT 1
29097: ARRAY
29098: PPUSH
29099: LD_VAR 0 2
29103: PUSH
29104: LD_INT 2
29106: ARRAY
29107: PPUSH
29108: LD_INT 1
29110: PPUSH
29111: LD_INT 8
29113: NEG
29114: PPUSH
29115: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29119: LD_EXP 89
29123: PPUSH
29124: CALL_OW 87
// DialogueOn ;
29128: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29132: LD_EXP 36
29136: PPUSH
29137: LD_STRING D19-JMM-1
29139: PPUSH
29140: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29144: LD_ADDR_VAR 0 3
29148: PUSH
29149: LD_INT 22
29151: PUSH
29152: LD_INT 1
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 26
29161: PUSH
29162: LD_INT 1
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 2
29171: PUSH
29172: LD_INT 25
29174: PUSH
29175: LD_INT 1
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 25
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 25
29194: PUSH
29195: LD_INT 3
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 25
29204: PUSH
29205: LD_INT 4
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: LD_INT 25
29214: PUSH
29215: LD_INT 5
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 25
29224: PUSH
29225: LD_INT 8
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: LIST
29245: PPUSH
29246: CALL_OW 69
29250: PUSH
29251: LD_EXP 36
29255: PUSH
29256: LD_EXP 37
29260: PUSH
29261: LD_EXP 38
29265: PUSH
29266: LD_EXP 39
29270: PUSH
29271: LD_EXP 40
29275: PUSH
29276: LD_EXP 41
29280: PUSH
29281: LD_EXP 42
29285: PUSH
29286: LD_EXP 43
29290: PUSH
29291: LD_EXP 44
29295: PUSH
29296: LD_EXP 45
29300: PUSH
29301: LD_EXP 46
29305: PUSH
29306: LD_EXP 47
29310: PUSH
29311: LD_EXP 48
29315: PUSH
29316: LD_EXP 49
29320: PUSH
29321: LD_EXP 50
29325: PUSH
29326: LD_EXP 51
29330: PUSH
29331: LD_EXP 52
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: LIST
29346: LIST
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: DIFF
29355: ST_TO_ADDR
// if tmp2 then
29356: LD_VAR 0 3
29360: IFFALSE 29378
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29362: LD_VAR 0 3
29366: PUSH
29367: LD_INT 1
29369: ARRAY
29370: PPUSH
29371: LD_STRING D19-Sol1-1
29373: PPUSH
29374: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29378: LD_EXP 36
29382: PPUSH
29383: LD_STRING D19-JMM-2
29385: PPUSH
29386: CALL_OW 88
// DialogueOff ;
29390: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29394: LD_VAR 0 2
29398: PUSH
29399: LD_INT 1
29401: ARRAY
29402: PPUSH
29403: LD_VAR 0 2
29407: PUSH
29408: LD_INT 2
29410: ARRAY
29411: PPUSH
29412: LD_INT 1
29414: PPUSH
29415: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29419: LD_STRING M5
29421: PPUSH
29422: CALL_OW 337
// omarOnMotherLode := false ;
29426: LD_ADDR_VAR 0 4
29430: PUSH
29431: LD_INT 0
29433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29434: LD_INT 35
29436: PPUSH
29437: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29441: LD_EXP 89
29445: PPUSH
29446: LD_INT 215
29448: PPUSH
29449: LD_INT 100
29451: PPUSH
29452: CALL_OW 297
29456: PUSH
29457: LD_INT 10
29459: LESS
29460: PUSH
29461: LD_VAR 0 4
29465: NOT
29466: AND
29467: IFFALSE 29501
// begin omarOnMotherLode := true ;
29469: LD_ADDR_VAR 0 4
29473: PUSH
29474: LD_INT 1
29476: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29477: LD_EXP 36
29481: PPUSH
29482: LD_STRING D19b-JMM-1
29484: PPUSH
29485: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29489: LD_EXP 89
29493: PPUSH
29494: LD_STRING DOmarContam-Omar-1
29496: PPUSH
29497: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29501: LD_EXP 89
29505: PPUSH
29506: CALL_OW 301
29510: IFFALSE 29434
// Say ( JMM , D19a-JMM-1 ) ;
29512: LD_EXP 36
29516: PPUSH
29517: LD_STRING D19a-JMM-1
29519: PPUSH
29520: CALL_OW 88
// if Heike then
29524: LD_EXP 90
29528: IFFALSE 29542
// Say ( Heike , D19a-Hke-1 ) ;
29530: LD_EXP 90
29534: PPUSH
29535: LD_STRING D19a-Hke-1
29537: PPUSH
29538: CALL_OW 88
// end ;
29542: PPOPN 4
29544: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29545: LD_INT 22
29547: PUSH
29548: LD_INT 3
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 21
29557: PUSH
29558: LD_INT 1
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PPUSH
29569: CALL_OW 69
29573: PUSH
29574: LD_EXP 21
29578: AND
29579: IFFALSE 29647
29581: GO 29583
29583: DISABLE
29584: LD_INT 0
29586: PPUSH
29587: PPUSH
// begin enable ;
29588: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29589: LD_ADDR_VAR 0 2
29593: PUSH
29594: LD_INT 25
29596: PPUSH
29597: LD_INT 22
29599: PUSH
29600: LD_INT 3
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PPUSH
29607: CALL_OW 70
29611: ST_TO_ADDR
// if not tmp then
29612: LD_VAR 0 2
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 29647
// for i in tmp do
29621: LD_ADDR_VAR 0 1
29625: PUSH
29626: LD_VAR 0 2
29630: PUSH
29631: FOR_IN
29632: IFFALSE 29645
// RemoveUnit ( i ) ;
29634: LD_VAR 0 1
29638: PPUSH
29639: CALL_OW 64
29643: GO 29631
29645: POP
29646: POP
// end ;
29647: PPOPN 2
29649: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29650: LD_INT 22
29652: PUSH
29653: LD_INT 7
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 21
29662: PUSH
29663: LD_INT 1
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PPUSH
29674: CALL_OW 69
29678: PUSH
29679: LD_INT 6
29681: LESS
29682: IFFALSE 30133
29684: GO 29686
29686: DISABLE
29687: LD_INT 0
29689: PPUSH
29690: PPUSH
// begin MC_Kill ( 1 ) ;
29691: LD_INT 1
29693: PPUSH
29694: CALL 34165 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29698: LD_INT 7
29700: PPUSH
29701: LD_INT 1
29703: PPUSH
29704: LD_INT 1
29706: PPUSH
29707: LD_INT 1
29709: PPUSH
29710: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29714: LD_ADDR_VAR 0 1
29718: PUSH
29719: LD_INT 22
29721: PUSH
29722: LD_INT 7
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 26
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: CALL_OW 69
29747: PUSH
29748: LD_EXP 71
29752: DIFF
29753: ST_TO_ADDR
// if tmp then
29754: LD_VAR 0 1
29758: IFFALSE 29776
// tmp := tmp [ 1 ] else
29760: LD_ADDR_VAR 0 1
29764: PUSH
29765: LD_VAR 0 1
29769: PUSH
29770: LD_INT 1
29772: ARRAY
29773: ST_TO_ADDR
29774: GO 29812
// begin uc_side := 7 ;
29776: LD_ADDR_OWVAR 20
29780: PUSH
29781: LD_INT 7
29783: ST_TO_ADDR
// uc_nation := 1 ;
29784: LD_ADDR_OWVAR 21
29788: PUSH
29789: LD_INT 1
29791: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29792: LD_INT 1
29794: PPUSH
29795: LD_INT 8
29797: PPUSH
29798: CALL_OW 384
// tmp := CreateHuman ;
29802: LD_ADDR_VAR 0 1
29806: PUSH
29807: CALL_OW 44
29811: ST_TO_ADDR
// end ; DialogueOn ;
29812: CALL_OW 6
// if IsOK ( Roth ) then
29816: LD_EXP 71
29820: PPUSH
29821: CALL_OW 302
29825: IFFALSE 29839
// Say ( JMM , DAb-JMM-1 ) ;
29827: LD_EXP 36
29831: PPUSH
29832: LD_STRING DAb-JMM-1
29834: PPUSH
29835: CALL_OW 88
// if IsOK ( Roth ) then
29839: LD_EXP 71
29843: PPUSH
29844: CALL_OW 302
29848: IFFALSE 29872
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29850: LD_EXP 71
29854: PPUSH
29855: LD_STRING DSurrenderAlliance-Roth-1
29857: PPUSH
29858: CALL_OW 88
// RothCaptured := true ;
29862: LD_ADDR_EXP 33
29866: PUSH
29867: LD_INT 1
29869: ST_TO_ADDR
// end else
29870: GO 29884
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29872: LD_VAR 0 1
29876: PPUSH
29877: LD_STRING DSurrenderAlliance-Sci1-1
29879: PPUSH
29880: CALL_OW 88
// DialogueOff ;
29884: CALL_OW 7
// allianceDestroyed := true ;
29888: LD_ADDR_EXP 23
29892: PUSH
29893: LD_INT 1
29895: ST_TO_ADDR
// if trueAmericans then
29896: LD_EXP 35
29900: IFFALSE 29976
// begin if trueAmericans = 1 then
29902: LD_EXP 35
29906: PUSH
29907: LD_INT 1
29909: EQUAL
29910: IFFALSE 29926
// Say ( JMM , DAb-JMM-1a ) else
29912: LD_EXP 36
29916: PPUSH
29917: LD_STRING DAb-JMM-1a
29919: PPUSH
29920: CALL_OW 88
29924: GO 29938
// Say ( JMM , DAb-JMM-1b ) ;
29926: LD_EXP 36
29930: PPUSH
29931: LD_STRING DAb-JMM-1b
29933: PPUSH
29934: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29938: LD_EXP 35
29942: PPUSH
29943: CALL_OW 87
// for i in trueAmericans do
29947: LD_ADDR_VAR 0 2
29951: PUSH
29952: LD_EXP 35
29956: PUSH
29957: FOR_IN
29958: IFFALSE 29974
// SetSide ( i , 1 ) ;
29960: LD_VAR 0 2
29964: PPUSH
29965: LD_INT 1
29967: PPUSH
29968: CALL_OW 235
29972: GO 29957
29974: POP
29975: POP
// end ; repeat wait ( 0 0$1 ) ;
29976: LD_INT 35
29978: PPUSH
29979: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29983: LD_ADDR_VAR 0 2
29987: PUSH
29988: LD_INT 22
29990: PUSH
29991: LD_INT 7
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 21
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PPUSH
30012: CALL_OW 69
30016: PUSH
30017: FOR_IN
30018: IFFALSE 30100
// begin if IsInUnit ( i ) then
30020: LD_VAR 0 2
30024: PPUSH
30025: CALL_OW 310
30029: IFFALSE 30040
// ComExitBuilding ( i ) ;
30031: LD_VAR 0 2
30035: PPUSH
30036: CALL_OW 122
// if IsDriver ( i ) then
30040: LD_VAR 0 2
30044: PPUSH
30045: CALL 104569 0 1
30049: IFFALSE 30060
// ComExitVehicle ( i ) ;
30051: LD_VAR 0 2
30055: PPUSH
30056: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30060: LD_VAR 0 2
30064: PPUSH
30065: LD_INT 26
30067: PPUSH
30068: CALL_OW 308
30072: NOT
30073: IFFALSE 30089
// AddComMoveToArea ( i , allianceEscapeArea ) else
30075: LD_VAR 0 2
30079: PPUSH
30080: LD_INT 26
30082: PPUSH
30083: CALL_OW 173
30087: GO 30098
// RemoveUnit ( i ) ;
30089: LD_VAR 0 2
30093: PPUSH
30094: CALL_OW 64
// end ;
30098: GO 30017
30100: POP
30101: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30102: LD_INT 22
30104: PUSH
30105: LD_INT 7
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 21
30114: PUSH
30115: LD_INT 1
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PPUSH
30126: CALL_OW 69
30130: NOT
30131: IFFALSE 29976
// end ;
30133: PPOPN 2
30135: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30136: LD_INT 0
30138: PPUSH
30139: PPUSH
// if not unit then
30140: LD_VAR 0 1
30144: NOT
30145: IFFALSE 30149
// exit ;
30147: GO 31647
// DoNotAttack ( 7 , unit ) ;
30149: LD_INT 7
30151: PPUSH
30152: LD_VAR 0 1
30156: PPUSH
30157: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30161: LD_VAR 0 1
30165: PPUSH
30166: LD_INT 260
30168: PPUSH
30169: LD_INT 235
30171: PPUSH
30172: LD_INT 3
30174: PPUSH
30175: LD_INT 1
30177: PPUSH
30178: CALL_OW 483
// SetSide ( unit , 4 ) ;
30182: LD_VAR 0 1
30186: PPUSH
30187: LD_INT 4
30189: PPUSH
30190: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30194: LD_ADDR_EXP 34
30198: PUSH
30199: LD_EXP 34
30203: PUSH
30204: LD_INT 1
30206: PLUS
30207: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30208: LD_INT 70
30210: PPUSH
30211: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30215: LD_INT 260
30217: PPUSH
30218: LD_INT 235
30220: PPUSH
30221: LD_INT 1
30223: PPUSH
30224: LD_INT 8
30226: NEG
30227: PPUSH
30228: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30232: LD_VAR 0 1
30236: PPUSH
30237: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30241: LD_VAR 0 1
30245: PPUSH
30246: LD_EXP 71
30250: PPUSH
30251: CALL_OW 119
// DialogueOn ;
30255: CALL_OW 6
// case unit of JMM :
30259: LD_VAR 0 1
30263: PUSH
30264: LD_EXP 36
30268: DOUBLE
30269: EQUAL
30270: IFTRUE 30274
30272: GO 30289
30274: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30275: LD_EXP 36
30279: PPUSH
30280: LD_STRING DA1-JMM-1
30282: PPUSH
30283: CALL_OW 91
30287: GO 30731
30289: LD_EXP 37
30293: DOUBLE
30294: EQUAL
30295: IFTRUE 30299
30297: GO 30314
30299: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30300: LD_EXP 37
30304: PPUSH
30305: LD_STRING DA1-Joan-1
30307: PPUSH
30308: CALL_OW 91
30312: GO 30731
30314: LD_EXP 39
30318: DOUBLE
30319: EQUAL
30320: IFTRUE 30324
30322: GO 30339
30324: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30325: LD_EXP 39
30329: PPUSH
30330: LD_STRING DA1-Lisa-1
30332: PPUSH
30333: CALL_OW 91
30337: GO 30731
30339: LD_EXP 40
30343: DOUBLE
30344: EQUAL
30345: IFTRUE 30349
30347: GO 30364
30349: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30350: LD_EXP 40
30354: PPUSH
30355: LD_STRING DA1-Don-1
30357: PPUSH
30358: CALL_OW 91
30362: GO 30731
30364: LD_EXP 47
30368: DOUBLE
30369: EQUAL
30370: IFTRUE 30374
30372: GO 30389
30374: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30375: LD_EXP 47
30379: PPUSH
30380: LD_STRING DA1-Corn-1
30382: PPUSH
30383: CALL_OW 91
30387: GO 30731
30389: LD_EXP 43
30393: DOUBLE
30394: EQUAL
30395: IFTRUE 30399
30397: GO 30414
30399: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30400: LD_EXP 43
30404: PPUSH
30405: LD_STRING DA1-Den-1
30407: PPUSH
30408: CALL_OW 91
30412: GO 30731
30414: LD_EXP 41
30418: DOUBLE
30419: EQUAL
30420: IFTRUE 30424
30422: GO 30439
30424: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30425: LD_EXP 41
30429: PPUSH
30430: LD_STRING DA1-Bobby-1
30432: PPUSH
30433: CALL_OW 91
30437: GO 30731
30439: LD_EXP 45
30443: DOUBLE
30444: EQUAL
30445: IFTRUE 30449
30447: GO 30464
30449: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30450: LD_EXP 45
30454: PPUSH
30455: LD_STRING DA1-Glad-1
30457: PPUSH
30458: CALL_OW 91
30462: GO 30731
30464: LD_EXP 42
30468: DOUBLE
30469: EQUAL
30470: IFTRUE 30474
30472: GO 30489
30474: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30475: LD_EXP 42
30479: PPUSH
30480: LD_STRING DA1-Cyrus-1
30482: PPUSH
30483: CALL_OW 91
30487: GO 30731
30489: LD_EXP 38
30493: DOUBLE
30494: EQUAL
30495: IFTRUE 30499
30497: GO 30514
30499: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30500: LD_EXP 38
30504: PPUSH
30505: LD_STRING DA1-Huck-1
30507: PPUSH
30508: CALL_OW 91
30512: GO 30731
30514: LD_EXP 52
30518: DOUBLE
30519: EQUAL
30520: IFTRUE 30524
30522: GO 30539
30524: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30525: LD_EXP 52
30529: PPUSH
30530: LD_STRING DA1-Huck-1
30532: PPUSH
30533: CALL_OW 91
30537: GO 30731
30539: LD_EXP 44
30543: DOUBLE
30544: EQUAL
30545: IFTRUE 30549
30547: GO 30564
30549: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30550: LD_EXP 44
30554: PPUSH
30555: LD_STRING DA1-Brown-1
30557: PPUSH
30558: CALL_OW 91
30562: GO 30731
30564: LD_EXP 48
30568: DOUBLE
30569: EQUAL
30570: IFTRUE 30574
30572: GO 30589
30574: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30575: LD_EXP 48
30579: PPUSH
30580: LD_STRING DA1-Gary-1
30582: PPUSH
30583: CALL_OW 91
30587: GO 30731
30589: LD_EXP 51
30593: DOUBLE
30594: EQUAL
30595: IFTRUE 30599
30597: GO 30614
30599: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30600: LD_EXP 51
30604: PPUSH
30605: LD_STRING DA1-Con-1
30607: PPUSH
30608: CALL_OW 91
30612: GO 30731
30614: LD_EXP 57
30618: DOUBLE
30619: EQUAL
30620: IFTRUE 30624
30622: GO 30639
30624: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30625: LD_EXP 57
30629: PPUSH
30630: LD_STRING DA1-Kurt-1
30632: PPUSH
30633: CALL_OW 91
30637: GO 30731
30639: LD_EXP 50
30643: DOUBLE
30644: EQUAL
30645: IFTRUE 30649
30647: GO 30664
30649: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30650: LD_EXP 50
30654: PPUSH
30655: LD_STRING DA1-Yam-1
30657: PPUSH
30658: CALL_OW 91
30662: GO 30731
30664: LD_EXP 49
30668: DOUBLE
30669: EQUAL
30670: IFTRUE 30674
30672: GO 30689
30674: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30675: LD_EXP 49
30679: PPUSH
30680: LD_STRING DA1-Frank-1
30682: PPUSH
30683: CALL_OW 91
30687: GO 30731
30689: POP
// begin if GetSex ( unit ) = sex_male then
30690: LD_VAR 0 1
30694: PPUSH
30695: CALL_OW 258
30699: PUSH
30700: LD_INT 1
30702: EQUAL
30703: IFFALSE 30719
// ForceSay ( unit , DA1-Sol1-1 ) else
30705: LD_VAR 0 1
30709: PPUSH
30710: LD_STRING DA1-Sol1-1
30712: PPUSH
30713: CALL_OW 91
30717: GO 30731
// ForceSay ( unit , DA1-FSol1-1 ) ;
30719: LD_VAR 0 1
30723: PPUSH
30724: LD_STRING DA1-FSol1-1
30726: PPUSH
30727: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30731: LD_EXP 71
30735: PPUSH
30736: LD_STRING DA-Roth-1
30738: PPUSH
30739: CALL_OW 88
// if capturedUnit = 1 then
30743: LD_EXP 34
30747: PUSH
30748: LD_INT 1
30750: EQUAL
30751: IFFALSE 30779
// begin Say ( Simms , DA-Sim-1 ) ;
30753: LD_EXP 72
30757: PPUSH
30758: LD_STRING DA-Sim-1
30760: PPUSH
30761: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30765: LD_EXP 71
30769: PPUSH
30770: LD_STRING DA-Roth-2
30772: PPUSH
30773: CALL_OW 88
// end else
30777: GO 30791
// Say ( Simms , DA-Sim-2 ) ;
30779: LD_EXP 72
30783: PPUSH
30784: LD_STRING DA-Sim-2
30786: PPUSH
30787: CALL_OW 88
// case unit of JMM :
30791: LD_VAR 0 1
30795: PUSH
30796: LD_EXP 36
30800: DOUBLE
30801: EQUAL
30802: IFTRUE 30806
30804: GO 30821
30806: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30807: LD_EXP 36
30811: PPUSH
30812: LD_STRING DA1-JMM-1a
30814: PPUSH
30815: CALL_OW 91
30819: GO 31328
30821: LD_EXP 37
30825: DOUBLE
30826: EQUAL
30827: IFTRUE 30831
30829: GO 30846
30831: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30832: LD_EXP 37
30836: PPUSH
30837: LD_STRING DA1-Joan-1a
30839: PPUSH
30840: CALL_OW 91
30844: GO 31328
30846: LD_EXP 39
30850: DOUBLE
30851: EQUAL
30852: IFTRUE 30856
30854: GO 30871
30856: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30857: LD_EXP 39
30861: PPUSH
30862: LD_STRING DA1-Lisa-1a
30864: PPUSH
30865: CALL_OW 91
30869: GO 31328
30871: LD_EXP 40
30875: DOUBLE
30876: EQUAL
30877: IFTRUE 30881
30879: GO 30896
30881: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30882: LD_EXP 40
30886: PPUSH
30887: LD_STRING DA1-Don-1a
30889: PPUSH
30890: CALL_OW 91
30894: GO 31328
30896: LD_EXP 47
30900: DOUBLE
30901: EQUAL
30902: IFTRUE 30906
30904: GO 30921
30906: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30907: LD_EXP 47
30911: PPUSH
30912: LD_STRING DA1-Corn-1a
30914: PPUSH
30915: CALL_OW 91
30919: GO 31328
30921: LD_EXP 43
30925: DOUBLE
30926: EQUAL
30927: IFTRUE 30931
30929: GO 30946
30931: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30932: LD_EXP 43
30936: PPUSH
30937: LD_STRING DA1-Den-1a
30939: PPUSH
30940: CALL_OW 91
30944: GO 31328
30946: LD_EXP 41
30950: DOUBLE
30951: EQUAL
30952: IFTRUE 30956
30954: GO 30971
30956: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30957: LD_EXP 41
30961: PPUSH
30962: LD_STRING DA1-Bobby-1a
30964: PPUSH
30965: CALL_OW 91
30969: GO 31328
30971: LD_EXP 45
30975: DOUBLE
30976: EQUAL
30977: IFTRUE 30981
30979: GO 30996
30981: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30982: LD_EXP 45
30986: PPUSH
30987: LD_STRING DA1-Glad-1a
30989: PPUSH
30990: CALL_OW 91
30994: GO 31328
30996: LD_EXP 42
31000: DOUBLE
31001: EQUAL
31002: IFTRUE 31006
31004: GO 31021
31006: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31007: LD_EXP 42
31011: PPUSH
31012: LD_STRING DA1-Cyrus-1a
31014: PPUSH
31015: CALL_OW 91
31019: GO 31328
31021: LD_EXP 38
31025: DOUBLE
31026: EQUAL
31027: IFTRUE 31031
31029: GO 31046
31031: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31032: LD_EXP 38
31036: PPUSH
31037: LD_STRING DA1-Huck-1a
31039: PPUSH
31040: CALL_OW 91
31044: GO 31328
31046: LD_EXP 52
31050: DOUBLE
31051: EQUAL
31052: IFTRUE 31056
31054: GO 31071
31056: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31057: LD_EXP 52
31061: PPUSH
31062: LD_STRING DA1-Huck-1a
31064: PPUSH
31065: CALL_OW 91
31069: GO 31328
31071: LD_EXP 44
31075: DOUBLE
31076: EQUAL
31077: IFTRUE 31081
31079: GO 31096
31081: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31082: LD_EXP 44
31086: PPUSH
31087: LD_STRING DA1-Brown-1a
31089: PPUSH
31090: CALL_OW 91
31094: GO 31328
31096: LD_EXP 48
31100: DOUBLE
31101: EQUAL
31102: IFTRUE 31106
31104: GO 31121
31106: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31107: LD_EXP 48
31111: PPUSH
31112: LD_STRING DA1-Gary-1a
31114: PPUSH
31115: CALL_OW 91
31119: GO 31328
31121: LD_EXP 51
31125: DOUBLE
31126: EQUAL
31127: IFTRUE 31131
31129: GO 31146
31131: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31132: LD_EXP 51
31136: PPUSH
31137: LD_STRING DA1-Con-1a
31139: PPUSH
31140: CALL_OW 91
31144: GO 31328
31146: LD_EXP 57
31150: DOUBLE
31151: EQUAL
31152: IFTRUE 31156
31154: GO 31171
31156: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31157: LD_EXP 57
31161: PPUSH
31162: LD_STRING DA1-Kurt-1a
31164: PPUSH
31165: CALL_OW 91
31169: GO 31328
31171: LD_EXP 50
31175: DOUBLE
31176: EQUAL
31177: IFTRUE 31181
31179: GO 31196
31181: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31182: LD_EXP 50
31186: PPUSH
31187: LD_STRING DA1-Yam-1a
31189: PPUSH
31190: CALL_OW 91
31194: GO 31328
31196: LD_EXP 49
31200: DOUBLE
31201: EQUAL
31202: IFTRUE 31206
31204: GO 31221
31206: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31207: LD_EXP 49
31211: PPUSH
31212: LD_STRING DA1-Frank-1a
31214: PPUSH
31215: CALL_OW 91
31219: GO 31328
31221: POP
// begin join := rand ( 0 , 1 ) ;
31222: LD_ADDR_VAR 0 3
31226: PUSH
31227: LD_INT 0
31229: PPUSH
31230: LD_INT 1
31232: PPUSH
31233: CALL_OW 12
31237: ST_TO_ADDR
// if join then
31238: LD_VAR 0 3
31242: IFFALSE 31287
// begin if GetSex ( unit ) = sex_male then
31244: LD_VAR 0 1
31248: PPUSH
31249: CALL_OW 258
31253: PUSH
31254: LD_INT 1
31256: EQUAL
31257: IFFALSE 31273
// ForceSay ( unit , DA1-Sol1-1b ) else
31259: LD_VAR 0 1
31263: PPUSH
31264: LD_STRING DA1-Sol1-1b
31266: PPUSH
31267: CALL_OW 91
31271: GO 31285
// ForceSay ( unit , DA1-FSol1-1b ) ;
31273: LD_VAR 0 1
31277: PPUSH
31278: LD_STRING DA1-FSol1-1b
31280: PPUSH
31281: CALL_OW 91
// end else
31285: GO 31328
// begin if GetSex ( unit ) = sex_male then
31287: LD_VAR 0 1
31291: PPUSH
31292: CALL_OW 258
31296: PUSH
31297: LD_INT 1
31299: EQUAL
31300: IFFALSE 31316
// ForceSay ( unit , DA1-Sol1-1a ) else
31302: LD_VAR 0 1
31306: PPUSH
31307: LD_STRING DA1-Sol1-1a
31309: PPUSH
31310: CALL_OW 91
31314: GO 31328
// ForceSay ( unit , DA1-FSol1-1a ) ;
31316: LD_VAR 0 1
31320: PPUSH
31321: LD_STRING DA1-FSol1-1a
31323: PPUSH
31324: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31328: LD_VAR 0 1
31332: PUSH
31333: LD_EXP 36
31337: EQUAL
31338: IFFALSE 31349
// begin YouLost ( JMMCaptured ) ;
31340: LD_STRING JMMCaptured
31342: PPUSH
31343: CALL_OW 104
// exit ;
31347: GO 31647
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31349: LD_VAR 0 1
31353: PUSH
31354: LD_EXP 40
31358: PUSH
31359: LD_EXP 43
31363: PUSH
31364: LD_EXP 41
31368: PUSH
31369: LD_EXP 38
31373: PUSH
31374: LD_EXP 52
31378: PUSH
31379: LD_EXP 44
31383: PUSH
31384: LD_EXP 50
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: IN
31398: PUSH
31399: LD_VAR 0 3
31403: OR
31404: IFFALSE 31503
// begin Say ( Roth , DA-Roth-3 ) ;
31406: LD_EXP 71
31410: PPUSH
31411: LD_STRING DA-Roth-3
31413: PPUSH
31414: CALL_OW 88
// SetSide ( unit , 7 ) ;
31418: LD_VAR 0 1
31422: PPUSH
31423: LD_INT 7
31425: PPUSH
31426: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31430: LD_ADDR_EXP 99
31434: PUSH
31435: LD_EXP 99
31439: PPUSH
31440: LD_INT 1
31442: PPUSH
31443: LD_EXP 99
31447: PUSH
31448: LD_INT 1
31450: ARRAY
31451: PUSH
31452: LD_VAR 0 1
31456: ADD
31457: PPUSH
31458: CALL_OW 1
31462: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31463: LD_INT 260
31465: PPUSH
31466: LD_INT 235
31468: PPUSH
31469: LD_INT 1
31471: PPUSH
31472: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31476: LD_VAR 0 1
31480: PPUSH
31481: LD_INT 1000
31483: PPUSH
31484: CALL_OW 234
// DialogueOff ;
31488: CALL_OW 7
// ComFree ( unit ) ;
31492: LD_VAR 0 1
31496: PPUSH
31497: CALL_OW 139
// end else
31501: GO 31584
// begin Say ( Roth , DA-Roth-3a ) ;
31503: LD_EXP 71
31507: PPUSH
31508: LD_STRING DA-Roth-3a
31510: PPUSH
31511: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31515: LD_ADDR_EXP 35
31519: PUSH
31520: LD_EXP 35
31524: PUSH
31525: LD_VAR 0 1
31529: ADD
31530: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31531: LD_INT 260
31533: PPUSH
31534: LD_INT 235
31536: PPUSH
31537: LD_INT 1
31539: PPUSH
31540: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31544: LD_VAR 0 1
31548: PPUSH
31549: LD_INT 1000
31551: PPUSH
31552: CALL_OW 234
// DialogueOff ;
31556: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31560: LD_VAR 0 1
31564: PPUSH
31565: LD_INT 272
31567: PPUSH
31568: LD_INT 254
31570: PPUSH
31571: CALL_OW 111
// AddComHold ( unit ) ;
31575: LD_VAR 0 1
31579: PPUSH
31580: CALL_OW 200
// end ; if capturedUnit = 1 then
31584: LD_EXP 34
31588: PUSH
31589: LD_INT 1
31591: EQUAL
31592: IFFALSE 31647
// begin DialogueOn ;
31594: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31598: LD_EXP 36
31602: PPUSH
31603: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31607: LD_EXP 36
31611: PPUSH
31612: LD_STRING DAa-JMM-1
31614: PPUSH
31615: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31619: LD_EXP 36
31623: PPUSH
31624: LD_STRING DAa-JMM-1a
31626: PPUSH
31627: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31631: LD_EXP 36
31635: PPUSH
31636: LD_STRING DAa-JMM-1b
31638: PPUSH
31639: CALL_OW 88
// DialogueOff ;
31643: CALL_OW 7
// end ; end ;
31647: LD_VAR 0 2
31651: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31652: LD_EXP 15
31656: PUSH
31657: LD_INT 13
31659: GREATEREQUAL
31660: PUSH
31661: LD_INT 22
31663: PUSH
31664: LD_INT 2
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: LD_INT 21
31673: PUSH
31674: LD_INT 1
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PPUSH
31685: CALL_OW 69
31689: PUSH
31690: LD_INT 0
31692: EQUAL
31693: AND
31694: PUSH
31695: LD_INT 22
31697: PUSH
31698: LD_INT 2
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 21
31707: PUSH
31708: LD_INT 2
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 50
31717: PUSH
31718: EMPTY
31719: LIST
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: LIST
31725: PPUSH
31726: CALL_OW 69
31730: PUSH
31731: LD_INT 0
31733: EQUAL
31734: AND
31735: PUSH
31736: LD_EXP 21
31740: AND
31741: PUSH
31742: LD_EXP 22
31746: AND
31747: PUSH
31748: LD_EXP 23
31752: AND
31753: IFFALSE 32357
31755: GO 31757
31757: DISABLE
31758: LD_INT 0
31760: PPUSH
31761: PPUSH
31762: PPUSH
// begin m1 := false ;
31763: LD_ADDR_VAR 0 1
31767: PUSH
31768: LD_INT 0
31770: ST_TO_ADDR
// m2 := false ;
31771: LD_ADDR_VAR 0 2
31775: PUSH
31776: LD_INT 0
31778: ST_TO_ADDR
// m3 := false ;
31779: LD_ADDR_VAR 0 3
31783: PUSH
31784: LD_INT 0
31786: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
31787: LD_EXP 36
31791: PPUSH
31792: CALL_OW 87
// music_class := 5 ;
31796: LD_ADDR_OWVAR 72
31800: PUSH
31801: LD_INT 5
31803: ST_TO_ADDR
// music_nat := 5 ;
31804: LD_ADDR_OWVAR 71
31808: PUSH
31809: LD_INT 5
31811: ST_TO_ADDR
// DialogueOn ;
31812: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31816: LD_EXP 36
31820: PPUSH
31821: LD_STRING D20-JMM-1
31823: PPUSH
31824: CALL_OW 88
// if IsOK ( Joan ) then
31828: LD_EXP 37
31832: PPUSH
31833: CALL_OW 302
31837: IFFALSE 31851
// Say ( Joan , D20-Joan-1 ) ;
31839: LD_EXP 37
31843: PPUSH
31844: LD_STRING D20-Joan-1
31846: PPUSH
31847: CALL_OW 88
// if IsOk ( Lisa ) then
31851: LD_EXP 39
31855: PPUSH
31856: CALL_OW 302
31860: IFFALSE 31874
// Say ( Lisa , D20-Lisa-1 ) ;
31862: LD_EXP 39
31866: PPUSH
31867: LD_STRING D20-Lisa-1
31869: PPUSH
31870: CALL_OW 88
// if IsOk ( Donaldson ) then
31874: LD_EXP 40
31878: PPUSH
31879: CALL_OW 302
31883: IFFALSE 31897
// Say ( Donaldson , D20-Don-1 ) ;
31885: LD_EXP 40
31889: PPUSH
31890: LD_STRING D20-Don-1
31892: PPUSH
31893: CALL_OW 88
// if IsOK ( Cornel ) then
31897: LD_EXP 47
31901: PPUSH
31902: CALL_OW 302
31906: IFFALSE 31920
// Say ( Cornel , D20-Corn-1 ) ;
31908: LD_EXP 47
31912: PPUSH
31913: LD_STRING D20-Corn-1
31915: PPUSH
31916: CALL_OW 88
// if IsOk ( Denis ) then
31920: LD_EXP 43
31924: PPUSH
31925: CALL_OW 302
31929: IFFALSE 31943
// Say ( Denis , D20-Den-1 ) ;
31931: LD_EXP 43
31935: PPUSH
31936: LD_STRING D20-Den-1
31938: PPUSH
31939: CALL_OW 88
// if IsOk ( Bobby ) then
31943: LD_EXP 41
31947: PPUSH
31948: CALL_OW 302
31952: IFFALSE 31966
// Say ( Bobby , D20-Bobby-1 ) ;
31954: LD_EXP 41
31958: PPUSH
31959: LD_STRING D20-Bobby-1
31961: PPUSH
31962: CALL_OW 88
// if IsOk ( Gladstone ) then
31966: LD_EXP 45
31970: PPUSH
31971: CALL_OW 302
31975: IFFALSE 31989
// Say ( Gladstone , D20-Glad-1 ) ;
31977: LD_EXP 45
31981: PPUSH
31982: LD_STRING D20-Glad-1
31984: PPUSH
31985: CALL_OW 88
// if IsOk ( Cyrus ) then
31989: LD_EXP 42
31993: PPUSH
31994: CALL_OW 302
31998: IFFALSE 32012
// Say ( Cyrus , D20-Cyrus-1 ) ;
32000: LD_EXP 42
32004: PPUSH
32005: LD_STRING D20-Cyrus-1
32007: PPUSH
32008: CALL_OW 88
// if IsOk ( Stevens ) then
32012: LD_EXP 38
32016: PPUSH
32017: CALL_OW 302
32021: IFFALSE 32035
// Say ( Stevens , D20-Huck-1 ) ;
32023: LD_EXP 38
32027: PPUSH
32028: LD_STRING D20-Huck-1
32030: PPUSH
32031: CALL_OW 88
// if IsOk ( Brown ) then
32035: LD_EXP 44
32039: PPUSH
32040: CALL_OW 302
32044: IFFALSE 32058
// Say ( Brown , D20-Brown-1 ) ;
32046: LD_EXP 44
32050: PPUSH
32051: LD_STRING D20-Brown-1
32053: PPUSH
32054: CALL_OW 88
// if IsOk ( Gary ) then
32058: LD_EXP 48
32062: PPUSH
32063: CALL_OW 302
32067: IFFALSE 32081
// Say ( Gary , D20-Gary-1 ) ;
32069: LD_EXP 48
32073: PPUSH
32074: LD_STRING D20-Gary-1
32076: PPUSH
32077: CALL_OW 88
// if IsOk ( Connie ) then
32081: LD_EXP 51
32085: PPUSH
32086: CALL_OW 302
32090: IFFALSE 32104
// Say ( Connie , D20-Con-1 ) ;
32092: LD_EXP 51
32096: PPUSH
32097: LD_STRING D20-Con-1
32099: PPUSH
32100: CALL_OW 88
// if IsOk ( Kurt ) then
32104: LD_EXP 57
32108: PPUSH
32109: CALL_OW 302
32113: IFFALSE 32127
// Say ( Kurt , D20-Kurt-1 ) ;
32115: LD_EXP 57
32119: PPUSH
32120: LD_STRING D20-Kurt-1
32122: PPUSH
32123: CALL_OW 88
// if IsOk ( Kikuchi ) then
32127: LD_EXP 50
32131: PPUSH
32132: CALL_OW 302
32136: IFFALSE 32150
// Say ( Kikuchi , D20-Yam-1 ) ;
32138: LD_EXP 50
32142: PPUSH
32143: LD_STRING D20-Yam-1
32145: PPUSH
32146: CALL_OW 88
// if IsOk ( Frank ) then
32150: LD_EXP 49
32154: PPUSH
32155: CALL_OW 302
32159: IFFALSE 32173
// Say ( Frank , D20-Frank-1 ) ;
32161: LD_EXP 49
32165: PPUSH
32166: LD_STRING D20-Frank-1
32168: PPUSH
32169: CALL_OW 88
// DialogueOff ;
32173: CALL_OW 7
// if RothCaptured then
32177: LD_EXP 33
32181: IFFALSE 32203
// begin m1 := true ;
32183: LD_ADDR_VAR 0 1
32187: PUSH
32188: LD_INT 1
32190: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32191: LD_STRING Roth
32193: PPUSH
32194: LD_INT 1
32196: PPUSH
32197: CALL_OW 101
// end else
32201: GO 32214
// AddMedal ( Roth , - 1 ) ;
32203: LD_STRING Roth
32205: PPUSH
32206: LD_INT 1
32208: NEG
32209: PPUSH
32210: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32214: LD_EXP 27
32218: IFFALSE 32240
// begin m2 := true ;
32220: LD_ADDR_VAR 0 2
32224: PUSH
32225: LD_INT 1
32227: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32228: LD_STRING Project
32230: PPUSH
32231: LD_INT 1
32233: PPUSH
32234: CALL_OW 101
// end else
32238: GO 32251
// AddMedal ( Project , - 1 ) ;
32240: LD_STRING Project
32242: PPUSH
32243: LD_INT 1
32245: NEG
32246: PPUSH
32247: CALL_OW 101
// if lostCounter = 0 then
32251: LD_EXP 32
32255: PUSH
32256: LD_INT 0
32258: EQUAL
32259: IFFALSE 32281
// begin m3 := true ;
32261: LD_ADDR_VAR 0 3
32265: PUSH
32266: LD_INT 1
32268: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32269: LD_STRING NoLosses
32271: PPUSH
32272: LD_INT 1
32274: PPUSH
32275: CALL_OW 101
// end else
32279: GO 32292
// AddMedal ( NoLosses , - 1 ) ;
32281: LD_STRING NoLosses
32283: PPUSH
32284: LD_INT 1
32286: NEG
32287: PPUSH
32288: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32292: LD_VAR 0 1
32296: PUSH
32297: LD_VAR 0 2
32301: AND
32302: PUSH
32303: LD_VAR 0 3
32307: AND
32308: PUSH
32309: LD_OWVAR 67
32313: PUSH
32314: LD_INT 3
32316: EQUAL
32317: AND
32318: IFFALSE 32330
// SetAchievementEX ( ACH_AMER , 15 ) ;
32320: LD_STRING ACH_AMER
32322: PPUSH
32323: LD_INT 15
32325: PPUSH
32326: CALL_OW 564
// GiveMedals ( MAIN ) ;
32330: LD_STRING MAIN
32332: PPUSH
32333: CALL_OW 102
// music_class := 4 ;
32337: LD_ADDR_OWVAR 72
32341: PUSH
32342: LD_INT 4
32344: ST_TO_ADDR
// music_nat := 1 ;
32345: LD_ADDR_OWVAR 71
32349: PUSH
32350: LD_INT 1
32352: ST_TO_ADDR
// YouWin ;
32353: CALL_OW 103
// end ; end_of_file
32357: PPOPN 3
32359: END
// export function CustomEvent ( event ) ; begin
32360: LD_INT 0
32362: PPUSH
// end ;
32363: LD_VAR 0 2
32367: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32368: LD_VAR 0 1
32372: PUSH
32373: LD_INT 1
32375: EQUAL
32376: PUSH
32377: LD_VAR 0 2
32381: PUSH
32382: LD_INT 4
32384: EQUAL
32385: AND
32386: PUSH
32387: LD_EXP 55
32391: PPUSH
32392: CALL_OW 300
32396: AND
32397: IFFALSE 32413
// begin wait ( 0 0$2 ) ;
32399: LD_INT 70
32401: PPUSH
32402: CALL_OW 67
// YouLost ( Dismissed ) ;
32406: LD_STRING Dismissed
32408: PPUSH
32409: CALL_OW 104
// end ; end ;
32413: PPOPN 2
32415: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32416: LD_VAR 0 2
32420: PPUSH
32421: LD_VAR 0 3
32425: PPUSH
32426: LD_INT 18
32428: PPUSH
32429: CALL_OW 309
32433: IFFALSE 32442
// YouLost ( Motherlode3 ) ;
32435: LD_STRING Motherlode3
32437: PPUSH
32438: CALL_OW 104
// end ;
32442: PPOPN 3
32444: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32445: LD_EXP 27
32449: NOT
32450: IFFALSE 32460
// behemothDone := true ;
32452: LD_ADDR_EXP 28
32456: PUSH
32457: LD_INT 1
32459: ST_TO_ADDR
// end ;
32460: PPOPN 1
32462: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32463: LD_VAR 0 1
32467: PPUSH
32468: CALL_OW 255
32472: PUSH
32473: LD_INT 1
32475: EQUAL
32476: PUSH
32477: LD_EXP 30
32481: AND
32482: PUSH
32483: LD_INT 22
32485: PUSH
32486: LD_INT 3
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 34
32495: PUSH
32496: LD_INT 48
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PPUSH
32507: CALL_OW 69
32511: AND
32512: PUSH
32513: LD_INT 22
32515: PUSH
32516: LD_INT 1
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 34
32525: PUSH
32526: LD_INT 8
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PPUSH
32537: CALL_OW 69
32541: NOT
32542: AND
32543: IFFALSE 32595
// begin wait ( 0 0$5 ) ;
32545: LD_INT 175
32547: PPUSH
32548: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32552: LD_INT 22
32554: PUSH
32555: LD_INT 3
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 34
32564: PUSH
32565: LD_INT 48
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PPUSH
32576: CALL_OW 69
32580: PUSH
32581: LD_INT 1
32583: ARRAY
32584: PPUSH
32585: LD_INT 60
32587: PPUSH
32588: LD_INT 95
32590: PPUSH
32591: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32595: LD_VAR 0 2
32599: PPUSH
32600: LD_VAR 0 3
32604: PPUSH
32605: LD_INT 18
32607: PPUSH
32608: CALL_OW 309
32612: IFFALSE 32672
// begin if GetSide ( unit ) = 1 then
32614: LD_VAR 0 1
32618: PPUSH
32619: CALL_OW 255
32623: PUSH
32624: LD_INT 1
32626: EQUAL
32627: IFFALSE 32643
// begin wait ( 0 0$6 ) ;
32629: LD_INT 210
32631: PPUSH
32632: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32636: LD_STRING Motherlode2
32638: PPUSH
32639: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32643: LD_VAR 0 1
32647: PPUSH
32648: CALL_OW 255
32652: PUSH
32653: LD_INT 8
32655: EQUAL
32656: IFFALSE 32672
// begin wait ( 0 0$6 ) ;
32658: LD_INT 210
32660: PPUSH
32661: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32665: LD_STRING Motherlode1
32667: PPUSH
32668: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32672: LD_VAR 0 1
32676: PPUSH
32677: CALL_OW 255
32681: PUSH
32682: LD_INT 3
32684: EQUAL
32685: IFFALSE 32706
// begin wait ( 0 0$5 ) ;
32687: LD_INT 175
32689: PPUSH
32690: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32694: LD_EXP 61
32698: PPUSH
32699: LD_STRING D18-Pla-1
32701: PPUSH
32702: CALL_OW 94
// end ; end ;
32706: PPOPN 3
32708: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32709: LD_VAR 0 1
32713: PUSH
32714: LD_EXP 70
32718: IN
32719: IFFALSE 32739
// begin behemothBuilders := behemothBuilders diff un ;
32721: LD_ADDR_EXP 70
32725: PUSH
32726: LD_EXP 70
32730: PUSH
32731: LD_VAR 0 1
32735: DIFF
32736: ST_TO_ADDR
// exit ;
32737: GO 32837
// end ; if un = JMM then
32739: LD_VAR 0 1
32743: PUSH
32744: LD_EXP 36
32748: EQUAL
32749: IFFALSE 32760
// begin YouLost ( JMM ) ;
32751: LD_STRING JMM
32753: PPUSH
32754: CALL_OW 104
// exit ;
32758: GO 32837
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32760: LD_VAR 0 1
32764: PUSH
32765: LD_INT 22
32767: PUSH
32768: LD_INT 1
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 3
32777: PUSH
32778: LD_INT 25
32780: PUSH
32781: LD_INT 16
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 25
32790: PUSH
32791: LD_INT 12
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: LIST
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PPUSH
32807: CALL_OW 69
32811: IN
32812: IFFALSE 32828
// lostCounter := lostCounter + 1 ;
32814: LD_ADDR_EXP 32
32818: PUSH
32819: LD_EXP 32
32823: PUSH
32824: LD_INT 1
32826: PLUS
32827: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32828: LD_VAR 0 1
32832: PPUSH
32833: CALL 61121 0 1
// end ;
32837: PPOPN 1
32839: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32840: LD_VAR 0 1
32844: PPUSH
32845: LD_VAR 0 2
32849: PPUSH
32850: CALL 63455 0 2
// end ;
32854: PPOPN 2
32856: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32857: LD_VAR 0 1
32861: PPUSH
32862: CALL 62523 0 1
// end ;
32866: PPOPN 1
32868: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32869: LD_VAR 0 1
32873: PUSH
32874: LD_INT 22
32876: PUSH
32877: LD_INT 8
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 30
32886: PUSH
32887: LD_INT 2
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 23
32896: PUSH
32897: LD_INT 3
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: LIST
32908: PPUSH
32909: CALL_OW 69
32913: IN
32914: IFFALSE 32941
// begin ComUpgrade ( building ) ;
32916: LD_VAR 0 1
32920: PPUSH
32921: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32925: LD_EXP 58
32929: PPUSH
32930: LD_VAR 0 1
32934: PPUSH
32935: CALL 74072 0 2
// exit ;
32939: GO 32950
// end ; MCE_BuildingComplete ( building ) ;
32941: LD_VAR 0 1
32945: PPUSH
32946: CALL 62764 0 1
// end ;
32950: PPOPN 1
32952: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32953: LD_VAR 0 1
32957: PPUSH
32958: LD_VAR 0 2
32962: PPUSH
32963: CALL 60817 0 2
// end ;
32967: PPOPN 2
32969: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32970: LD_VAR 0 1
32974: PPUSH
32975: LD_VAR 0 2
32979: PPUSH
32980: LD_VAR 0 3
32984: PPUSH
32985: LD_VAR 0 4
32989: PPUSH
32990: LD_VAR 0 5
32994: PPUSH
32995: CALL 60437 0 5
// end ;
32999: PPOPN 5
33001: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33002: LD_VAR 0 1
33006: PPUSH
33007: LD_VAR 0 2
33011: PPUSH
33012: CALL 60033 0 2
// end ;
33016: PPOPN 2
33018: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33019: LD_VAR 0 1
33023: PPUSH
33024: LD_VAR 0 2
33028: PPUSH
33029: LD_VAR 0 3
33033: PPUSH
33034: LD_VAR 0 4
33038: PPUSH
33039: CALL 59871 0 4
// end ;
33043: PPOPN 4
33045: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33046: LD_VAR 0 1
33050: PPUSH
33051: LD_VAR 0 2
33055: PPUSH
33056: LD_VAR 0 3
33060: PPUSH
33061: CALL 59646 0 3
// end ;
33065: PPOPN 3
33067: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33068: LD_VAR 0 1
33072: PPUSH
33073: LD_VAR 0 2
33077: PPUSH
33078: CALL 59531 0 2
// end ;
33082: PPOPN 2
33084: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33085: LD_VAR 0 1
33089: PPUSH
33090: LD_VAR 0 2
33094: PPUSH
33095: CALL 63716 0 2
// end ;
33099: PPOPN 2
33101: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33102: LD_VAR 0 1
33106: PPUSH
33107: CALL_OW 255
33111: PUSH
33112: LD_INT 4
33114: EQUAL
33115: PUSH
33116: LD_VAR 0 1
33120: PUSH
33121: LD_EXP 18
33125: PUSH
33126: LD_INT 1
33128: ARRAY
33129: IN
33130: AND
33131: PUSH
33132: LD_EXP 19
33136: AND
33137: IFFALSE 33156
// begin ComMoveXY ( driver , 61 , 93 ) ;
33139: LD_VAR 0 1
33143: PPUSH
33144: LD_INT 61
33146: PPUSH
33147: LD_INT 93
33149: PPUSH
33150: CALL_OW 111
// exit ;
33154: GO 33180
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33156: LD_VAR 0 1
33160: PPUSH
33161: LD_VAR 0 2
33165: PPUSH
33166: LD_VAR 0 3
33170: PPUSH
33171: LD_VAR 0 4
33175: PPUSH
33176: CALL 63932 0 4
// end ;
33180: PPOPN 4
33182: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33183: LD_VAR 0 1
33187: PPUSH
33188: LD_VAR 0 2
33192: PPUSH
33193: CALL 59340 0 2
// end ;
33197: PPOPN 2
33199: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33200: LD_VAR 0 1
33204: PPUSH
33205: CALL 107244 0 1
// end ; end_of_file
33209: PPOPN 1
33211: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33212: LD_EXP 15
33216: PUSH
33217: LD_INT 2
33219: EQUAL
33220: IFFALSE 33699
33222: GO 33224
33224: DISABLE
33225: LD_INT 0
33227: PPUSH
// begin time := 0 0$40 ;
33228: LD_ADDR_VAR 0 1
33232: PUSH
33233: LD_INT 1400
33235: ST_TO_ADDR
// repeat wait ( time ) ;
33236: LD_VAR 0 1
33240: PPUSH
33241: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33245: LD_INT 1
33247: PPUSH
33248: LD_INT 5
33250: PPUSH
33251: CALL_OW 12
33255: PPUSH
33256: LD_INT 106
33258: PPUSH
33259: LD_INT 150
33261: PPUSH
33262: LD_INT 19
33264: PPUSH
33265: LD_INT 1
33267: PPUSH
33268: CALL_OW 56
// time := time + 0 0$9 ;
33272: LD_ADDR_VAR 0 1
33276: PUSH
33277: LD_VAR 0 1
33281: PUSH
33282: LD_INT 315
33284: PLUS
33285: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33286: LD_INT 455
33288: PPUSH
33289: LD_INT 840
33291: PPUSH
33292: CALL_OW 12
33296: PPUSH
33297: CALL_OW 67
// if Prob ( 50 ) then
33301: LD_INT 50
33303: PPUSH
33304: CALL_OW 13
33308: IFFALSE 33337
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33310: LD_INT 1
33312: PPUSH
33313: LD_INT 5
33315: PPUSH
33316: CALL_OW 12
33320: PPUSH
33321: LD_INT 62
33323: PPUSH
33324: LD_INT 108
33326: PPUSH
33327: LD_INT 10
33329: PPUSH
33330: LD_INT 1
33332: PPUSH
33333: CALL_OW 56
// until missionStage > 4 ;
33337: LD_EXP 15
33341: PUSH
33342: LD_INT 4
33344: GREATER
33345: IFFALSE 33236
// repeat wait ( 0 0$1 ) ;
33347: LD_INT 35
33349: PPUSH
33350: CALL_OW 67
// until missionStage = 6 ;
33354: LD_EXP 15
33358: PUSH
33359: LD_INT 6
33361: EQUAL
33362: IFFALSE 33347
// time := 0 0$50 ;
33364: LD_ADDR_VAR 0 1
33368: PUSH
33369: LD_INT 1750
33371: ST_TO_ADDR
// repeat wait ( time ) ;
33372: LD_VAR 0 1
33376: PPUSH
33377: CALL_OW 67
// if Prob ( 50 ) then
33381: LD_INT 50
33383: PPUSH
33384: CALL_OW 13
33388: IFFALSE 33417
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33390: LD_INT 1
33392: PPUSH
33393: LD_INT 5
33395: PPUSH
33396: CALL_OW 12
33400: PPUSH
33401: LD_INT 106
33403: PPUSH
33404: LD_INT 89
33406: PPUSH
33407: LD_INT 45
33409: PPUSH
33410: LD_INT 1
33412: PPUSH
33413: CALL_OW 56
// time := time + 0 0$3 ;
33417: LD_ADDR_VAR 0 1
33421: PUSH
33422: LD_VAR 0 1
33426: PUSH
33427: LD_INT 105
33429: PLUS
33430: ST_TO_ADDR
// if Prob ( 30 ) then
33431: LD_INT 30
33433: PPUSH
33434: CALL_OW 13
33438: IFFALSE 33484
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33440: LD_INT 525
33442: PPUSH
33443: LD_INT 735
33445: PPUSH
33446: CALL_OW 12
33450: PPUSH
33451: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33455: LD_INT 1
33457: PPUSH
33458: LD_INT 5
33460: PPUSH
33461: CALL_OW 12
33465: PPUSH
33466: LD_INT 21
33468: PPUSH
33469: LD_INT 26
33471: PPUSH
33472: LD_INT 12
33474: PPUSH
33475: LD_INT 1
33477: PPUSH
33478: CALL_OW 56
// end else
33482: GO 33520
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33484: LD_INT 700
33486: PPUSH
33487: LD_INT 1225
33489: PPUSH
33490: CALL_OW 12
33494: PPUSH
33495: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33499: LD_INT 1
33501: PPUSH
33502: LD_INT 5
33504: PPUSH
33505: CALL_OW 12
33509: PPUSH
33510: LD_INT 16
33512: PPUSH
33513: LD_INT 1
33515: PPUSH
33516: CALL_OW 55
// end ; if Prob ( 50 ) then
33520: LD_INT 50
33522: PPUSH
33523: CALL_OW 13
33527: IFFALSE 33573
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33529: LD_INT 700
33531: PPUSH
33532: LD_INT 1050
33534: PPUSH
33535: CALL_OW 12
33539: PPUSH
33540: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33544: LD_INT 1
33546: PPUSH
33547: LD_INT 5
33549: PPUSH
33550: CALL_OW 12
33554: PPUSH
33555: LD_INT 181
33557: PPUSH
33558: LD_INT 218
33560: PPUSH
33561: LD_INT 16
33563: PPUSH
33564: LD_INT 1
33566: PPUSH
33567: CALL_OW 56
// end else
33571: GO 33609
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33573: LD_INT 350
33575: PPUSH
33576: LD_INT 525
33578: PPUSH
33579: CALL_OW 12
33583: PPUSH
33584: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33588: LD_INT 1
33590: PPUSH
33591: LD_INT 5
33593: PPUSH
33594: CALL_OW 12
33598: PPUSH
33599: LD_INT 15
33601: PPUSH
33602: LD_INT 1
33604: PPUSH
33605: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33609: LD_INT 45
33611: PUSH
33612: LD_INT 32
33614: PUSH
33615: LD_INT 25
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: LIST
33622: PUSH
33623: LD_OWVAR 67
33627: ARRAY
33628: PPUSH
33629: CALL_OW 13
33633: IFFALSE 33677
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33635: LD_INT 525
33637: PPUSH
33638: LD_INT 875
33640: PPUSH
33641: CALL_OW 12
33645: PPUSH
33646: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33650: LD_INT 1
33652: PPUSH
33653: LD_INT 5
33655: PPUSH
33656: CALL_OW 12
33660: PPUSH
33661: LD_INT 103
33663: PPUSH
33664: LD_INT 140
33666: PPUSH
33667: LD_INT 20
33669: PPUSH
33670: LD_INT 1
33672: PPUSH
33673: CALL_OW 56
// end ; if time > 2 2$20 then
33677: LD_VAR 0 1
33681: PUSH
33682: LD_INT 4900
33684: GREATER
33685: IFFALSE 33695
// time := 0 0$50 ;
33687: LD_ADDR_VAR 0 1
33691: PUSH
33692: LD_INT 1750
33694: ST_TO_ADDR
// until false ;
33695: LD_INT 0
33697: IFFALSE 33372
// end ; end_of_file
33699: PPOPN 1
33701: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33702: LD_EXP 13
33706: PUSH
33707: LD_EXP 15
33711: PUSH
33712: LD_INT 6
33714: GREATEREQUAL
33715: AND
33716: IFFALSE 33753
33718: GO 33720
33720: DISABLE
// begin enable ;
33721: ENABLE
// missionTime := missionTime + 0 0$1 ;
33722: LD_ADDR_EXP 14
33726: PUSH
33727: LD_EXP 14
33731: PUSH
33732: LD_INT 35
33734: PLUS
33735: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33736: LD_ADDR_OWVAR 47
33740: PUSH
33741: LD_STRING #Am15-1
33743: PUSH
33744: LD_EXP 14
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: ST_TO_ADDR
// end ; end_of_file
33753: END
// export function InitNature ; begin
33754: LD_INT 0
33756: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33757: LD_INT 3
33759: PPUSH
33760: LD_INT 3
33762: PPUSH
33763: LD_INT 2
33765: PPUSH
33766: LD_INT 1
33768: PPUSH
33769: LD_INT 1
33771: PPUSH
33772: LD_INT 0
33774: PPUSH
33775: LD_INT 0
33777: PPUSH
33778: LD_INT 20
33780: PPUSH
33781: LD_INT 0
33783: PPUSH
33784: CALL 98913 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33788: LD_INT 2
33790: PPUSH
33791: LD_INT 1
33793: PPUSH
33794: LD_INT 1
33796: PPUSH
33797: LD_INT 1
33799: PPUSH
33800: LD_INT 1
33802: PPUSH
33803: LD_INT 0
33805: PPUSH
33806: LD_INT 0
33808: PPUSH
33809: LD_INT 21
33811: PPUSH
33812: LD_INT 0
33814: PPUSH
33815: CALL 98913 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33819: LD_INT 4
33821: PPUSH
33822: LD_INT 1
33824: PPUSH
33825: LD_INT 2
33827: PPUSH
33828: LD_INT 4
33830: PPUSH
33831: LD_INT 2
33833: PPUSH
33834: LD_INT 1
33836: PPUSH
33837: LD_INT 0
33839: PPUSH
33840: LD_INT 22
33842: PPUSH
33843: LD_INT 0
33845: PPUSH
33846: CALL 98913 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33850: LD_INT 0
33852: PPUSH
33853: LD_INT 0
33855: PPUSH
33856: LD_INT 0
33858: PPUSH
33859: LD_INT 0
33861: PPUSH
33862: LD_INT 0
33864: PPUSH
33865: LD_INT 0
33867: PPUSH
33868: LD_INT 9
33870: PPUSH
33871: LD_INT 0
33873: PPUSH
33874: LD_INT 23
33876: PPUSH
33877: CALL 98913 0 9
// end ; end_of_file
33881: LD_VAR 0 1
33885: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33886: GO 33888
33888: DISABLE
// begin ru_radar := 98 ;
33889: LD_ADDR_EXP 92
33893: PUSH
33894: LD_INT 98
33896: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33897: LD_ADDR_EXP 93
33901: PUSH
33902: LD_INT 89
33904: ST_TO_ADDR
// us_hack := 99 ;
33905: LD_ADDR_EXP 94
33909: PUSH
33910: LD_INT 99
33912: ST_TO_ADDR
// us_artillery := 97 ;
33913: LD_ADDR_EXP 95
33917: PUSH
33918: LD_INT 97
33920: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33921: LD_ADDR_EXP 96
33925: PUSH
33926: LD_INT 91
33928: ST_TO_ADDR
// end ; end_of_file
33929: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33930: LD_INT 0
33932: PPUSH
33933: PPUSH
// skirmish := false ;
33934: LD_ADDR_EXP 97
33938: PUSH
33939: LD_INT 0
33941: ST_TO_ADDR
// debug_mc := false ;
33942: LD_ADDR_EXP 98
33946: PUSH
33947: LD_INT 0
33949: ST_TO_ADDR
// mc_bases := [ ] ;
33950: LD_ADDR_EXP 99
33954: PUSH
33955: EMPTY
33956: ST_TO_ADDR
// mc_sides := [ ] ;
33957: LD_ADDR_EXP 125
33961: PUSH
33962: EMPTY
33963: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33964: LD_ADDR_EXP 100
33968: PUSH
33969: EMPTY
33970: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33971: LD_ADDR_EXP 101
33975: PUSH
33976: EMPTY
33977: ST_TO_ADDR
// mc_need_heal := [ ] ;
33978: LD_ADDR_EXP 102
33982: PUSH
33983: EMPTY
33984: ST_TO_ADDR
// mc_healers := [ ] ;
33985: LD_ADDR_EXP 103
33989: PUSH
33990: EMPTY
33991: ST_TO_ADDR
// mc_build_list := [ ] ;
33992: LD_ADDR_EXP 104
33996: PUSH
33997: EMPTY
33998: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33999: LD_ADDR_EXP 131
34003: PUSH
34004: EMPTY
34005: ST_TO_ADDR
// mc_builders := [ ] ;
34006: LD_ADDR_EXP 105
34010: PUSH
34011: EMPTY
34012: ST_TO_ADDR
// mc_construct_list := [ ] ;
34013: LD_ADDR_EXP 106
34017: PUSH
34018: EMPTY
34019: ST_TO_ADDR
// mc_turret_list := [ ] ;
34020: LD_ADDR_EXP 107
34024: PUSH
34025: EMPTY
34026: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34027: LD_ADDR_EXP 108
34031: PUSH
34032: EMPTY
34033: ST_TO_ADDR
// mc_miners := [ ] ;
34034: LD_ADDR_EXP 113
34038: PUSH
34039: EMPTY
34040: ST_TO_ADDR
// mc_mines := [ ] ;
34041: LD_ADDR_EXP 112
34045: PUSH
34046: EMPTY
34047: ST_TO_ADDR
// mc_minefields := [ ] ;
34048: LD_ADDR_EXP 114
34052: PUSH
34053: EMPTY
34054: ST_TO_ADDR
// mc_crates := [ ] ;
34055: LD_ADDR_EXP 115
34059: PUSH
34060: EMPTY
34061: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34062: LD_ADDR_EXP 116
34066: PUSH
34067: EMPTY
34068: ST_TO_ADDR
// mc_crates_area := [ ] ;
34069: LD_ADDR_EXP 117
34073: PUSH
34074: EMPTY
34075: ST_TO_ADDR
// mc_vehicles := [ ] ;
34076: LD_ADDR_EXP 118
34080: PUSH
34081: EMPTY
34082: ST_TO_ADDR
// mc_attack := [ ] ;
34083: LD_ADDR_EXP 119
34087: PUSH
34088: EMPTY
34089: ST_TO_ADDR
// mc_produce := [ ] ;
34090: LD_ADDR_EXP 120
34094: PUSH
34095: EMPTY
34096: ST_TO_ADDR
// mc_defender := [ ] ;
34097: LD_ADDR_EXP 121
34101: PUSH
34102: EMPTY
34103: ST_TO_ADDR
// mc_parking := [ ] ;
34104: LD_ADDR_EXP 123
34108: PUSH
34109: EMPTY
34110: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34111: LD_ADDR_EXP 109
34115: PUSH
34116: EMPTY
34117: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34118: LD_ADDR_EXP 111
34122: PUSH
34123: EMPTY
34124: ST_TO_ADDR
// mc_scan := [ ] ;
34125: LD_ADDR_EXP 122
34129: PUSH
34130: EMPTY
34131: ST_TO_ADDR
// mc_scan_area := [ ] ;
34132: LD_ADDR_EXP 124
34136: PUSH
34137: EMPTY
34138: ST_TO_ADDR
// mc_tech := [ ] ;
34139: LD_ADDR_EXP 126
34143: PUSH
34144: EMPTY
34145: ST_TO_ADDR
// mc_class := [ ] ;
34146: LD_ADDR_EXP 140
34150: PUSH
34151: EMPTY
34152: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34153: LD_ADDR_EXP 141
34157: PUSH
34158: EMPTY
34159: ST_TO_ADDR
// end ;
34160: LD_VAR 0 1
34164: RET
// export function MC_Kill ( base ) ; begin
34165: LD_INT 0
34167: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34168: LD_ADDR_EXP 99
34172: PUSH
34173: LD_EXP 99
34177: PPUSH
34178: LD_VAR 0 1
34182: PPUSH
34183: EMPTY
34184: PPUSH
34185: CALL_OW 1
34189: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34190: LD_ADDR_EXP 100
34194: PUSH
34195: LD_EXP 100
34199: PPUSH
34200: LD_VAR 0 1
34204: PPUSH
34205: EMPTY
34206: PPUSH
34207: CALL_OW 1
34211: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34212: LD_ADDR_EXP 101
34216: PUSH
34217: LD_EXP 101
34221: PPUSH
34222: LD_VAR 0 1
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34234: LD_ADDR_EXP 102
34238: PUSH
34239: LD_EXP 102
34243: PPUSH
34244: LD_VAR 0 1
34248: PPUSH
34249: EMPTY
34250: PPUSH
34251: CALL_OW 1
34255: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34256: LD_ADDR_EXP 103
34260: PUSH
34261: LD_EXP 103
34265: PPUSH
34266: LD_VAR 0 1
34270: PPUSH
34271: EMPTY
34272: PPUSH
34273: CALL_OW 1
34277: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34278: LD_ADDR_EXP 104
34282: PUSH
34283: LD_EXP 104
34287: PPUSH
34288: LD_VAR 0 1
34292: PPUSH
34293: EMPTY
34294: PPUSH
34295: CALL_OW 1
34299: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34300: LD_ADDR_EXP 105
34304: PUSH
34305: LD_EXP 105
34309: PPUSH
34310: LD_VAR 0 1
34314: PPUSH
34315: EMPTY
34316: PPUSH
34317: CALL_OW 1
34321: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34322: LD_ADDR_EXP 106
34326: PUSH
34327: LD_EXP 106
34331: PPUSH
34332: LD_VAR 0 1
34336: PPUSH
34337: EMPTY
34338: PPUSH
34339: CALL_OW 1
34343: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34344: LD_ADDR_EXP 107
34348: PUSH
34349: LD_EXP 107
34353: PPUSH
34354: LD_VAR 0 1
34358: PPUSH
34359: EMPTY
34360: PPUSH
34361: CALL_OW 1
34365: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34366: LD_ADDR_EXP 108
34370: PUSH
34371: LD_EXP 108
34375: PPUSH
34376: LD_VAR 0 1
34380: PPUSH
34381: EMPTY
34382: PPUSH
34383: CALL_OW 1
34387: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34388: LD_ADDR_EXP 109
34392: PUSH
34393: LD_EXP 109
34397: PPUSH
34398: LD_VAR 0 1
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL_OW 1
34409: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34410: LD_ADDR_EXP 110
34414: PUSH
34415: LD_EXP 110
34419: PPUSH
34420: LD_VAR 0 1
34424: PPUSH
34425: LD_INT 0
34427: PPUSH
34428: CALL_OW 1
34432: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34433: LD_ADDR_EXP 111
34437: PUSH
34438: LD_EXP 111
34442: PPUSH
34443: LD_VAR 0 1
34447: PPUSH
34448: EMPTY
34449: PPUSH
34450: CALL_OW 1
34454: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34455: LD_ADDR_EXP 112
34459: PUSH
34460: LD_EXP 112
34464: PPUSH
34465: LD_VAR 0 1
34469: PPUSH
34470: EMPTY
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34477: LD_ADDR_EXP 113
34481: PUSH
34482: LD_EXP 113
34486: PPUSH
34487: LD_VAR 0 1
34491: PPUSH
34492: EMPTY
34493: PPUSH
34494: CALL_OW 1
34498: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34499: LD_ADDR_EXP 114
34503: PUSH
34504: LD_EXP 114
34508: PPUSH
34509: LD_VAR 0 1
34513: PPUSH
34514: EMPTY
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34521: LD_ADDR_EXP 115
34525: PUSH
34526: LD_EXP 115
34530: PPUSH
34531: LD_VAR 0 1
34535: PPUSH
34536: EMPTY
34537: PPUSH
34538: CALL_OW 1
34542: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34543: LD_ADDR_EXP 116
34547: PUSH
34548: LD_EXP 116
34552: PPUSH
34553: LD_VAR 0 1
34557: PPUSH
34558: EMPTY
34559: PPUSH
34560: CALL_OW 1
34564: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34565: LD_ADDR_EXP 117
34569: PUSH
34570: LD_EXP 117
34574: PPUSH
34575: LD_VAR 0 1
34579: PPUSH
34580: EMPTY
34581: PPUSH
34582: CALL_OW 1
34586: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34587: LD_ADDR_EXP 118
34591: PUSH
34592: LD_EXP 118
34596: PPUSH
34597: LD_VAR 0 1
34601: PPUSH
34602: EMPTY
34603: PPUSH
34604: CALL_OW 1
34608: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34609: LD_ADDR_EXP 119
34613: PUSH
34614: LD_EXP 119
34618: PPUSH
34619: LD_VAR 0 1
34623: PPUSH
34624: EMPTY
34625: PPUSH
34626: CALL_OW 1
34630: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34631: LD_ADDR_EXP 120
34635: PUSH
34636: LD_EXP 120
34640: PPUSH
34641: LD_VAR 0 1
34645: PPUSH
34646: EMPTY
34647: PPUSH
34648: CALL_OW 1
34652: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34653: LD_ADDR_EXP 121
34657: PUSH
34658: LD_EXP 121
34662: PPUSH
34663: LD_VAR 0 1
34667: PPUSH
34668: EMPTY
34669: PPUSH
34670: CALL_OW 1
34674: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34675: LD_ADDR_EXP 122
34679: PUSH
34680: LD_EXP 122
34684: PPUSH
34685: LD_VAR 0 1
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL_OW 1
34696: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34697: LD_ADDR_EXP 123
34701: PUSH
34702: LD_EXP 123
34706: PPUSH
34707: LD_VAR 0 1
34711: PPUSH
34712: EMPTY
34713: PPUSH
34714: CALL_OW 1
34718: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34719: LD_ADDR_EXP 124
34723: PUSH
34724: LD_EXP 124
34728: PPUSH
34729: LD_VAR 0 1
34733: PPUSH
34734: EMPTY
34735: PPUSH
34736: CALL_OW 1
34740: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34741: LD_ADDR_EXP 126
34745: PUSH
34746: LD_EXP 126
34750: PPUSH
34751: LD_VAR 0 1
34755: PPUSH
34756: EMPTY
34757: PPUSH
34758: CALL_OW 1
34762: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34763: LD_ADDR_EXP 128
34767: PUSH
34768: LD_EXP 128
34772: PPUSH
34773: LD_VAR 0 1
34777: PPUSH
34778: EMPTY
34779: PPUSH
34780: CALL_OW 1
34784: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34785: LD_ADDR_EXP 129
34789: PUSH
34790: LD_EXP 129
34794: PPUSH
34795: LD_VAR 0 1
34799: PPUSH
34800: EMPTY
34801: PPUSH
34802: CALL_OW 1
34806: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34807: LD_ADDR_EXP 130
34811: PUSH
34812: LD_EXP 130
34816: PPUSH
34817: LD_VAR 0 1
34821: PPUSH
34822: EMPTY
34823: PPUSH
34824: CALL_OW 1
34828: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34829: LD_ADDR_EXP 131
34833: PUSH
34834: LD_EXP 131
34838: PPUSH
34839: LD_VAR 0 1
34843: PPUSH
34844: EMPTY
34845: PPUSH
34846: CALL_OW 1
34850: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34851: LD_ADDR_EXP 132
34855: PUSH
34856: LD_EXP 132
34860: PPUSH
34861: LD_VAR 0 1
34865: PPUSH
34866: EMPTY
34867: PPUSH
34868: CALL_OW 1
34872: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34873: LD_ADDR_EXP 133
34877: PUSH
34878: LD_EXP 133
34882: PPUSH
34883: LD_VAR 0 1
34887: PPUSH
34888: EMPTY
34889: PPUSH
34890: CALL_OW 1
34894: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34895: LD_ADDR_EXP 134
34899: PUSH
34900: LD_EXP 134
34904: PPUSH
34905: LD_VAR 0 1
34909: PPUSH
34910: EMPTY
34911: PPUSH
34912: CALL_OW 1
34916: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34917: LD_ADDR_EXP 135
34921: PUSH
34922: LD_EXP 135
34926: PPUSH
34927: LD_VAR 0 1
34931: PPUSH
34932: EMPTY
34933: PPUSH
34934: CALL_OW 1
34938: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34939: LD_ADDR_EXP 136
34943: PUSH
34944: LD_EXP 136
34948: PPUSH
34949: LD_VAR 0 1
34953: PPUSH
34954: EMPTY
34955: PPUSH
34956: CALL_OW 1
34960: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34961: LD_ADDR_EXP 137
34965: PUSH
34966: LD_EXP 137
34970: PPUSH
34971: LD_VAR 0 1
34975: PPUSH
34976: EMPTY
34977: PPUSH
34978: CALL_OW 1
34982: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34983: LD_ADDR_EXP 138
34987: PUSH
34988: LD_EXP 138
34992: PPUSH
34993: LD_VAR 0 1
34997: PPUSH
34998: EMPTY
34999: PPUSH
35000: CALL_OW 1
35004: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35005: LD_ADDR_EXP 139
35009: PUSH
35010: LD_EXP 139
35014: PPUSH
35015: LD_VAR 0 1
35019: PPUSH
35020: EMPTY
35021: PPUSH
35022: CALL_OW 1
35026: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35027: LD_ADDR_EXP 140
35031: PUSH
35032: LD_EXP 140
35036: PPUSH
35037: LD_VAR 0 1
35041: PPUSH
35042: EMPTY
35043: PPUSH
35044: CALL_OW 1
35048: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35049: LD_ADDR_EXP 141
35053: PUSH
35054: LD_EXP 141
35058: PPUSH
35059: LD_VAR 0 1
35063: PPUSH
35064: LD_INT 0
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// end ;
35072: LD_VAR 0 2
35076: RET
// export function MC_Add ( side , units ) ; var base ; begin
35077: LD_INT 0
35079: PPUSH
35080: PPUSH
// base := mc_bases + 1 ;
35081: LD_ADDR_VAR 0 4
35085: PUSH
35086: LD_EXP 99
35090: PUSH
35091: LD_INT 1
35093: PLUS
35094: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35095: LD_ADDR_EXP 125
35099: PUSH
35100: LD_EXP 125
35104: PPUSH
35105: LD_VAR 0 4
35109: PPUSH
35110: LD_VAR 0 1
35114: PPUSH
35115: CALL_OW 1
35119: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35120: LD_ADDR_EXP 99
35124: PUSH
35125: LD_EXP 99
35129: PPUSH
35130: LD_VAR 0 4
35134: PPUSH
35135: LD_VAR 0 2
35139: PPUSH
35140: CALL_OW 1
35144: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35145: LD_ADDR_EXP 100
35149: PUSH
35150: LD_EXP 100
35154: PPUSH
35155: LD_VAR 0 4
35159: PPUSH
35160: EMPTY
35161: PPUSH
35162: CALL_OW 1
35166: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35167: LD_ADDR_EXP 101
35171: PUSH
35172: LD_EXP 101
35176: PPUSH
35177: LD_VAR 0 4
35181: PPUSH
35182: EMPTY
35183: PPUSH
35184: CALL_OW 1
35188: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35189: LD_ADDR_EXP 102
35193: PUSH
35194: LD_EXP 102
35198: PPUSH
35199: LD_VAR 0 4
35203: PPUSH
35204: EMPTY
35205: PPUSH
35206: CALL_OW 1
35210: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35211: LD_ADDR_EXP 103
35215: PUSH
35216: LD_EXP 103
35220: PPUSH
35221: LD_VAR 0 4
35225: PPUSH
35226: EMPTY
35227: PPUSH
35228: CALL_OW 1
35232: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35233: LD_ADDR_EXP 104
35237: PUSH
35238: LD_EXP 104
35242: PPUSH
35243: LD_VAR 0 4
35247: PPUSH
35248: EMPTY
35249: PPUSH
35250: CALL_OW 1
35254: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35255: LD_ADDR_EXP 105
35259: PUSH
35260: LD_EXP 105
35264: PPUSH
35265: LD_VAR 0 4
35269: PPUSH
35270: EMPTY
35271: PPUSH
35272: CALL_OW 1
35276: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35277: LD_ADDR_EXP 106
35281: PUSH
35282: LD_EXP 106
35286: PPUSH
35287: LD_VAR 0 4
35291: PPUSH
35292: EMPTY
35293: PPUSH
35294: CALL_OW 1
35298: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35299: LD_ADDR_EXP 107
35303: PUSH
35304: LD_EXP 107
35308: PPUSH
35309: LD_VAR 0 4
35313: PPUSH
35314: EMPTY
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35321: LD_ADDR_EXP 108
35325: PUSH
35326: LD_EXP 108
35330: PPUSH
35331: LD_VAR 0 4
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL_OW 1
35342: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35343: LD_ADDR_EXP 109
35347: PUSH
35348: LD_EXP 109
35352: PPUSH
35353: LD_VAR 0 4
35357: PPUSH
35358: EMPTY
35359: PPUSH
35360: CALL_OW 1
35364: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35365: LD_ADDR_EXP 110
35369: PUSH
35370: LD_EXP 110
35374: PPUSH
35375: LD_VAR 0 4
35379: PPUSH
35380: LD_INT 0
35382: PPUSH
35383: CALL_OW 1
35387: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35388: LD_ADDR_EXP 111
35392: PUSH
35393: LD_EXP 111
35397: PPUSH
35398: LD_VAR 0 4
35402: PPUSH
35403: EMPTY
35404: PPUSH
35405: CALL_OW 1
35409: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35410: LD_ADDR_EXP 112
35414: PUSH
35415: LD_EXP 112
35419: PPUSH
35420: LD_VAR 0 4
35424: PPUSH
35425: EMPTY
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35432: LD_ADDR_EXP 113
35436: PUSH
35437: LD_EXP 113
35441: PPUSH
35442: LD_VAR 0 4
35446: PPUSH
35447: EMPTY
35448: PPUSH
35449: CALL_OW 1
35453: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35454: LD_ADDR_EXP 114
35458: PUSH
35459: LD_EXP 114
35463: PPUSH
35464: LD_VAR 0 4
35468: PPUSH
35469: EMPTY
35470: PPUSH
35471: CALL_OW 1
35475: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35476: LD_ADDR_EXP 115
35480: PUSH
35481: LD_EXP 115
35485: PPUSH
35486: LD_VAR 0 4
35490: PPUSH
35491: EMPTY
35492: PPUSH
35493: CALL_OW 1
35497: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35498: LD_ADDR_EXP 116
35502: PUSH
35503: LD_EXP 116
35507: PPUSH
35508: LD_VAR 0 4
35512: PPUSH
35513: EMPTY
35514: PPUSH
35515: CALL_OW 1
35519: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35520: LD_ADDR_EXP 117
35524: PUSH
35525: LD_EXP 117
35529: PPUSH
35530: LD_VAR 0 4
35534: PPUSH
35535: EMPTY
35536: PPUSH
35537: CALL_OW 1
35541: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35542: LD_ADDR_EXP 118
35546: PUSH
35547: LD_EXP 118
35551: PPUSH
35552: LD_VAR 0 4
35556: PPUSH
35557: EMPTY
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35564: LD_ADDR_EXP 119
35568: PUSH
35569: LD_EXP 119
35573: PPUSH
35574: LD_VAR 0 4
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35586: LD_ADDR_EXP 120
35590: PUSH
35591: LD_EXP 120
35595: PPUSH
35596: LD_VAR 0 4
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35608: LD_ADDR_EXP 121
35612: PUSH
35613: LD_EXP 121
35617: PPUSH
35618: LD_VAR 0 4
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35630: LD_ADDR_EXP 122
35634: PUSH
35635: LD_EXP 122
35639: PPUSH
35640: LD_VAR 0 4
35644: PPUSH
35645: EMPTY
35646: PPUSH
35647: CALL_OW 1
35651: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35652: LD_ADDR_EXP 123
35656: PUSH
35657: LD_EXP 123
35661: PPUSH
35662: LD_VAR 0 4
35666: PPUSH
35667: EMPTY
35668: PPUSH
35669: CALL_OW 1
35673: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35674: LD_ADDR_EXP 124
35678: PUSH
35679: LD_EXP 124
35683: PPUSH
35684: LD_VAR 0 4
35688: PPUSH
35689: EMPTY
35690: PPUSH
35691: CALL_OW 1
35695: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35696: LD_ADDR_EXP 126
35700: PUSH
35701: LD_EXP 126
35705: PPUSH
35706: LD_VAR 0 4
35710: PPUSH
35711: EMPTY
35712: PPUSH
35713: CALL_OW 1
35717: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35718: LD_ADDR_EXP 128
35722: PUSH
35723: LD_EXP 128
35727: PPUSH
35728: LD_VAR 0 4
35732: PPUSH
35733: EMPTY
35734: PPUSH
35735: CALL_OW 1
35739: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35740: LD_ADDR_EXP 129
35744: PUSH
35745: LD_EXP 129
35749: PPUSH
35750: LD_VAR 0 4
35754: PPUSH
35755: EMPTY
35756: PPUSH
35757: CALL_OW 1
35761: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35762: LD_ADDR_EXP 130
35766: PUSH
35767: LD_EXP 130
35771: PPUSH
35772: LD_VAR 0 4
35776: PPUSH
35777: EMPTY
35778: PPUSH
35779: CALL_OW 1
35783: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35784: LD_ADDR_EXP 131
35788: PUSH
35789: LD_EXP 131
35793: PPUSH
35794: LD_VAR 0 4
35798: PPUSH
35799: EMPTY
35800: PPUSH
35801: CALL_OW 1
35805: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35806: LD_ADDR_EXP 132
35810: PUSH
35811: LD_EXP 132
35815: PPUSH
35816: LD_VAR 0 4
35820: PPUSH
35821: EMPTY
35822: PPUSH
35823: CALL_OW 1
35827: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35828: LD_ADDR_EXP 133
35832: PUSH
35833: LD_EXP 133
35837: PPUSH
35838: LD_VAR 0 4
35842: PPUSH
35843: EMPTY
35844: PPUSH
35845: CALL_OW 1
35849: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35850: LD_ADDR_EXP 134
35854: PUSH
35855: LD_EXP 134
35859: PPUSH
35860: LD_VAR 0 4
35864: PPUSH
35865: EMPTY
35866: PPUSH
35867: CALL_OW 1
35871: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35872: LD_ADDR_EXP 135
35876: PUSH
35877: LD_EXP 135
35881: PPUSH
35882: LD_VAR 0 4
35886: PPUSH
35887: EMPTY
35888: PPUSH
35889: CALL_OW 1
35893: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35894: LD_ADDR_EXP 136
35898: PUSH
35899: LD_EXP 136
35903: PPUSH
35904: LD_VAR 0 4
35908: PPUSH
35909: EMPTY
35910: PPUSH
35911: CALL_OW 1
35915: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35916: LD_ADDR_EXP 137
35920: PUSH
35921: LD_EXP 137
35925: PPUSH
35926: LD_VAR 0 4
35930: PPUSH
35931: EMPTY
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35938: LD_ADDR_EXP 138
35942: PUSH
35943: LD_EXP 138
35947: PPUSH
35948: LD_VAR 0 4
35952: PPUSH
35953: EMPTY
35954: PPUSH
35955: CALL_OW 1
35959: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35960: LD_ADDR_EXP 139
35964: PUSH
35965: LD_EXP 139
35969: PPUSH
35970: LD_VAR 0 4
35974: PPUSH
35975: EMPTY
35976: PPUSH
35977: CALL_OW 1
35981: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35982: LD_ADDR_EXP 140
35986: PUSH
35987: LD_EXP 140
35991: PPUSH
35992: LD_VAR 0 4
35996: PPUSH
35997: EMPTY
35998: PPUSH
35999: CALL_OW 1
36003: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36004: LD_ADDR_EXP 141
36008: PUSH
36009: LD_EXP 141
36013: PPUSH
36014: LD_VAR 0 4
36018: PPUSH
36019: LD_INT 0
36021: PPUSH
36022: CALL_OW 1
36026: ST_TO_ADDR
// result := base ;
36027: LD_ADDR_VAR 0 3
36031: PUSH
36032: LD_VAR 0 4
36036: ST_TO_ADDR
// end ;
36037: LD_VAR 0 3
36041: RET
// export function MC_Start ( ) ; var i ; begin
36042: LD_INT 0
36044: PPUSH
36045: PPUSH
// for i = 1 to mc_bases do
36046: LD_ADDR_VAR 0 2
36050: PUSH
36051: DOUBLE
36052: LD_INT 1
36054: DEC
36055: ST_TO_ADDR
36056: LD_EXP 99
36060: PUSH
36061: FOR_TO
36062: IFFALSE 37139
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36064: LD_ADDR_EXP 99
36068: PUSH
36069: LD_EXP 99
36073: PPUSH
36074: LD_VAR 0 2
36078: PPUSH
36079: LD_EXP 99
36083: PUSH
36084: LD_VAR 0 2
36088: ARRAY
36089: PUSH
36090: LD_INT 0
36092: DIFF
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36099: LD_ADDR_EXP 100
36103: PUSH
36104: LD_EXP 100
36108: PPUSH
36109: LD_VAR 0 2
36113: PPUSH
36114: EMPTY
36115: PPUSH
36116: CALL_OW 1
36120: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36121: LD_ADDR_EXP 101
36125: PUSH
36126: LD_EXP 101
36130: PPUSH
36131: LD_VAR 0 2
36135: PPUSH
36136: EMPTY
36137: PPUSH
36138: CALL_OW 1
36142: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36143: LD_ADDR_EXP 102
36147: PUSH
36148: LD_EXP 102
36152: PPUSH
36153: LD_VAR 0 2
36157: PPUSH
36158: EMPTY
36159: PPUSH
36160: CALL_OW 1
36164: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36165: LD_ADDR_EXP 103
36169: PUSH
36170: LD_EXP 103
36174: PPUSH
36175: LD_VAR 0 2
36179: PPUSH
36180: EMPTY
36181: PUSH
36182: EMPTY
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PPUSH
36188: CALL_OW 1
36192: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36193: LD_ADDR_EXP 104
36197: PUSH
36198: LD_EXP 104
36202: PPUSH
36203: LD_VAR 0 2
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL_OW 1
36214: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36215: LD_ADDR_EXP 131
36219: PUSH
36220: LD_EXP 131
36224: PPUSH
36225: LD_VAR 0 2
36229: PPUSH
36230: EMPTY
36231: PPUSH
36232: CALL_OW 1
36236: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36237: LD_ADDR_EXP 105
36241: PUSH
36242: LD_EXP 105
36246: PPUSH
36247: LD_VAR 0 2
36251: PPUSH
36252: EMPTY
36253: PPUSH
36254: CALL_OW 1
36258: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36259: LD_ADDR_EXP 106
36263: PUSH
36264: LD_EXP 106
36268: PPUSH
36269: LD_VAR 0 2
36273: PPUSH
36274: EMPTY
36275: PPUSH
36276: CALL_OW 1
36280: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36281: LD_ADDR_EXP 107
36285: PUSH
36286: LD_EXP 107
36290: PPUSH
36291: LD_VAR 0 2
36295: PPUSH
36296: LD_EXP 99
36300: PUSH
36301: LD_VAR 0 2
36305: ARRAY
36306: PPUSH
36307: LD_INT 2
36309: PUSH
36310: LD_INT 30
36312: PUSH
36313: LD_INT 32
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 30
36322: PUSH
36323: LD_INT 33
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: LIST
36334: PPUSH
36335: CALL_OW 72
36339: PPUSH
36340: CALL_OW 1
36344: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36345: LD_ADDR_EXP 108
36349: PUSH
36350: LD_EXP 108
36354: PPUSH
36355: LD_VAR 0 2
36359: PPUSH
36360: LD_EXP 99
36364: PUSH
36365: LD_VAR 0 2
36369: ARRAY
36370: PPUSH
36371: LD_INT 2
36373: PUSH
36374: LD_INT 30
36376: PUSH
36377: LD_INT 32
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 30
36386: PUSH
36387: LD_INT 31
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 58
36401: PUSH
36402: EMPTY
36403: LIST
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PPUSH
36409: CALL_OW 72
36413: PPUSH
36414: CALL_OW 1
36418: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36419: LD_ADDR_EXP 109
36423: PUSH
36424: LD_EXP 109
36428: PPUSH
36429: LD_VAR 0 2
36433: PPUSH
36434: EMPTY
36435: PPUSH
36436: CALL_OW 1
36440: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36441: LD_ADDR_EXP 113
36445: PUSH
36446: LD_EXP 113
36450: PPUSH
36451: LD_VAR 0 2
36455: PPUSH
36456: EMPTY
36457: PPUSH
36458: CALL_OW 1
36462: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36463: LD_ADDR_EXP 112
36467: PUSH
36468: LD_EXP 112
36472: PPUSH
36473: LD_VAR 0 2
36477: PPUSH
36478: EMPTY
36479: PPUSH
36480: CALL_OW 1
36484: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36485: LD_ADDR_EXP 114
36489: PUSH
36490: LD_EXP 114
36494: PPUSH
36495: LD_VAR 0 2
36499: PPUSH
36500: EMPTY
36501: PPUSH
36502: CALL_OW 1
36506: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36507: LD_ADDR_EXP 115
36511: PUSH
36512: LD_EXP 115
36516: PPUSH
36517: LD_VAR 0 2
36521: PPUSH
36522: EMPTY
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36529: LD_ADDR_EXP 116
36533: PUSH
36534: LD_EXP 116
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36551: LD_ADDR_EXP 117
36555: PUSH
36556: LD_EXP 117
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: EMPTY
36567: PPUSH
36568: CALL_OW 1
36572: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36573: LD_ADDR_EXP 118
36577: PUSH
36578: LD_EXP 118
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: EMPTY
36589: PPUSH
36590: CALL_OW 1
36594: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36595: LD_ADDR_EXP 119
36599: PUSH
36600: LD_EXP 119
36604: PPUSH
36605: LD_VAR 0 2
36609: PPUSH
36610: EMPTY
36611: PPUSH
36612: CALL_OW 1
36616: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36617: LD_ADDR_EXP 120
36621: PUSH
36622: LD_EXP 120
36626: PPUSH
36627: LD_VAR 0 2
36631: PPUSH
36632: EMPTY
36633: PPUSH
36634: CALL_OW 1
36638: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36639: LD_ADDR_EXP 121
36643: PUSH
36644: LD_EXP 121
36648: PPUSH
36649: LD_VAR 0 2
36653: PPUSH
36654: EMPTY
36655: PPUSH
36656: CALL_OW 1
36660: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36661: LD_ADDR_EXP 110
36665: PUSH
36666: LD_EXP 110
36670: PPUSH
36671: LD_VAR 0 2
36675: PPUSH
36676: LD_INT 0
36678: PPUSH
36679: CALL_OW 1
36683: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36684: LD_ADDR_EXP 123
36688: PUSH
36689: LD_EXP 123
36693: PPUSH
36694: LD_VAR 0 2
36698: PPUSH
36699: LD_INT 0
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36707: LD_ADDR_EXP 111
36711: PUSH
36712: LD_EXP 111
36716: PPUSH
36717: LD_VAR 0 2
36721: PPUSH
36722: EMPTY
36723: PPUSH
36724: CALL_OW 1
36728: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36729: LD_ADDR_EXP 122
36733: PUSH
36734: LD_EXP 122
36738: PPUSH
36739: LD_VAR 0 2
36743: PPUSH
36744: LD_INT 0
36746: PPUSH
36747: CALL_OW 1
36751: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36752: LD_ADDR_EXP 124
36756: PUSH
36757: LD_EXP 124
36761: PPUSH
36762: LD_VAR 0 2
36766: PPUSH
36767: EMPTY
36768: PPUSH
36769: CALL_OW 1
36773: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36774: LD_ADDR_EXP 127
36778: PUSH
36779: LD_EXP 127
36783: PPUSH
36784: LD_VAR 0 2
36788: PPUSH
36789: LD_INT 0
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36797: LD_ADDR_EXP 128
36801: PUSH
36802: LD_EXP 128
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36819: LD_ADDR_EXP 129
36823: PUSH
36824: LD_EXP 129
36828: PPUSH
36829: LD_VAR 0 2
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36841: LD_ADDR_EXP 130
36845: PUSH
36846: LD_EXP 130
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36863: LD_ADDR_EXP 132
36867: PUSH
36868: LD_EXP 132
36872: PPUSH
36873: LD_VAR 0 2
36877: PPUSH
36878: LD_EXP 99
36882: PUSH
36883: LD_VAR 0 2
36887: ARRAY
36888: PPUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 30
36894: PUSH
36895: LD_INT 6
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 30
36904: PUSH
36905: LD_INT 7
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 30
36914: PUSH
36915: LD_INT 8
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: LIST
36926: LIST
36927: PPUSH
36928: CALL_OW 72
36932: PPUSH
36933: CALL_OW 1
36937: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36938: LD_ADDR_EXP 133
36942: PUSH
36943: LD_EXP 133
36947: PPUSH
36948: LD_VAR 0 2
36952: PPUSH
36953: EMPTY
36954: PPUSH
36955: CALL_OW 1
36959: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36960: LD_ADDR_EXP 134
36964: PUSH
36965: LD_EXP 134
36969: PPUSH
36970: LD_VAR 0 2
36974: PPUSH
36975: EMPTY
36976: PPUSH
36977: CALL_OW 1
36981: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36982: LD_ADDR_EXP 135
36986: PUSH
36987: LD_EXP 135
36991: PPUSH
36992: LD_VAR 0 2
36996: PPUSH
36997: EMPTY
36998: PPUSH
36999: CALL_OW 1
37003: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37004: LD_ADDR_EXP 136
37008: PUSH
37009: LD_EXP 136
37013: PPUSH
37014: LD_VAR 0 2
37018: PPUSH
37019: EMPTY
37020: PPUSH
37021: CALL_OW 1
37025: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37026: LD_ADDR_EXP 137
37030: PUSH
37031: LD_EXP 137
37035: PPUSH
37036: LD_VAR 0 2
37040: PPUSH
37041: EMPTY
37042: PPUSH
37043: CALL_OW 1
37047: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37048: LD_ADDR_EXP 138
37052: PUSH
37053: LD_EXP 138
37057: PPUSH
37058: LD_VAR 0 2
37062: PPUSH
37063: EMPTY
37064: PPUSH
37065: CALL_OW 1
37069: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37070: LD_ADDR_EXP 139
37074: PUSH
37075: LD_EXP 139
37079: PPUSH
37080: LD_VAR 0 2
37084: PPUSH
37085: EMPTY
37086: PPUSH
37087: CALL_OW 1
37091: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37092: LD_ADDR_EXP 140
37096: PUSH
37097: LD_EXP 140
37101: PPUSH
37102: LD_VAR 0 2
37106: PPUSH
37107: EMPTY
37108: PPUSH
37109: CALL_OW 1
37113: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37114: LD_ADDR_EXP 141
37118: PUSH
37119: LD_EXP 141
37123: PPUSH
37124: LD_VAR 0 2
37128: PPUSH
37129: LD_INT 0
37131: PPUSH
37132: CALL_OW 1
37136: ST_TO_ADDR
// end ;
37137: GO 36061
37139: POP
37140: POP
// MC_InitSides ( ) ;
37141: CALL 37427 0 0
// MC_InitResearch ( ) ;
37145: CALL 37166 0 0
// CustomInitMacro ( ) ;
37149: CALL 444 0 0
// skirmish := true ;
37153: LD_ADDR_EXP 97
37157: PUSH
37158: LD_INT 1
37160: ST_TO_ADDR
// end ;
37161: LD_VAR 0 1
37165: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37166: LD_INT 0
37168: PPUSH
37169: PPUSH
37170: PPUSH
37171: PPUSH
37172: PPUSH
37173: PPUSH
// if not mc_bases then
37174: LD_EXP 99
37178: NOT
37179: IFFALSE 37183
// exit ;
37181: GO 37422
// for i = 1 to 8 do
37183: LD_ADDR_VAR 0 2
37187: PUSH
37188: DOUBLE
37189: LD_INT 1
37191: DEC
37192: ST_TO_ADDR
37193: LD_INT 8
37195: PUSH
37196: FOR_TO
37197: IFFALSE 37223
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37199: LD_ADDR_EXP 126
37203: PUSH
37204: LD_EXP 126
37208: PPUSH
37209: LD_VAR 0 2
37213: PPUSH
37214: EMPTY
37215: PPUSH
37216: CALL_OW 1
37220: ST_TO_ADDR
37221: GO 37196
37223: POP
37224: POP
// tmp := [ ] ;
37225: LD_ADDR_VAR 0 5
37229: PUSH
37230: EMPTY
37231: ST_TO_ADDR
// for i = 1 to mc_sides do
37232: LD_ADDR_VAR 0 2
37236: PUSH
37237: DOUBLE
37238: LD_INT 1
37240: DEC
37241: ST_TO_ADDR
37242: LD_EXP 125
37246: PUSH
37247: FOR_TO
37248: IFFALSE 37306
// if not mc_sides [ i ] in tmp then
37250: LD_EXP 125
37254: PUSH
37255: LD_VAR 0 2
37259: ARRAY
37260: PUSH
37261: LD_VAR 0 5
37265: IN
37266: NOT
37267: IFFALSE 37304
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37269: LD_ADDR_VAR 0 5
37273: PUSH
37274: LD_VAR 0 5
37278: PPUSH
37279: LD_VAR 0 5
37283: PUSH
37284: LD_INT 1
37286: PLUS
37287: PPUSH
37288: LD_EXP 125
37292: PUSH
37293: LD_VAR 0 2
37297: ARRAY
37298: PPUSH
37299: CALL_OW 2
37303: ST_TO_ADDR
37304: GO 37247
37306: POP
37307: POP
// if not tmp then
37308: LD_VAR 0 5
37312: NOT
37313: IFFALSE 37317
// exit ;
37315: GO 37422
// for j in tmp do
37317: LD_ADDR_VAR 0 3
37321: PUSH
37322: LD_VAR 0 5
37326: PUSH
37327: FOR_IN
37328: IFFALSE 37420
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37330: LD_ADDR_VAR 0 6
37334: PUSH
37335: LD_INT 22
37337: PUSH
37338: LD_VAR 0 3
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PPUSH
37347: CALL_OW 69
37351: ST_TO_ADDR
// if not un then
37352: LD_VAR 0 6
37356: NOT
37357: IFFALSE 37361
// continue ;
37359: GO 37327
// nation := GetNation ( un [ 1 ] ) ;
37361: LD_ADDR_VAR 0 4
37365: PUSH
37366: LD_VAR 0 6
37370: PUSH
37371: LD_INT 1
37373: ARRAY
37374: PPUSH
37375: CALL_OW 248
37379: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37380: LD_ADDR_EXP 126
37384: PUSH
37385: LD_EXP 126
37389: PPUSH
37390: LD_VAR 0 3
37394: PPUSH
37395: LD_VAR 0 3
37399: PPUSH
37400: LD_VAR 0 4
37404: PPUSH
37405: LD_INT 1
37407: PPUSH
37408: CALL 64136 0 3
37412: PPUSH
37413: CALL_OW 1
37417: ST_TO_ADDR
// end ;
37418: GO 37327
37420: POP
37421: POP
// end ;
37422: LD_VAR 0 1
37426: RET
// export function MC_InitSides ( ) ; var i ; begin
37427: LD_INT 0
37429: PPUSH
37430: PPUSH
// if not mc_bases then
37431: LD_EXP 99
37435: NOT
37436: IFFALSE 37440
// exit ;
37438: GO 37514
// for i = 1 to mc_bases do
37440: LD_ADDR_VAR 0 2
37444: PUSH
37445: DOUBLE
37446: LD_INT 1
37448: DEC
37449: ST_TO_ADDR
37450: LD_EXP 99
37454: PUSH
37455: FOR_TO
37456: IFFALSE 37512
// if mc_bases [ i ] then
37458: LD_EXP 99
37462: PUSH
37463: LD_VAR 0 2
37467: ARRAY
37468: IFFALSE 37510
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37470: LD_ADDR_EXP 125
37474: PUSH
37475: LD_EXP 125
37479: PPUSH
37480: LD_VAR 0 2
37484: PPUSH
37485: LD_EXP 99
37489: PUSH
37490: LD_VAR 0 2
37494: ARRAY
37495: PUSH
37496: LD_INT 1
37498: ARRAY
37499: PPUSH
37500: CALL_OW 255
37504: PPUSH
37505: CALL_OW 1
37509: ST_TO_ADDR
37510: GO 37455
37512: POP
37513: POP
// end ;
37514: LD_VAR 0 1
37518: RET
// every 0 0$01 trigger skirmish do
37519: LD_EXP 97
37523: IFFALSE 37677
37525: GO 37527
37527: DISABLE
// begin enable ;
37528: ENABLE
// MC_CheckBuildings ( ) ;
37529: CALL 42175 0 0
// MC_CheckPeopleLife ( ) ;
37533: CALL 42300 0 0
// RaiseSailEvent ( 100 ) ;
37537: LD_INT 100
37539: PPUSH
37540: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37544: LD_INT 103
37546: PPUSH
37547: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37551: LD_INT 104
37553: PPUSH
37554: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37558: LD_INT 105
37560: PPUSH
37561: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37565: LD_INT 106
37567: PPUSH
37568: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37572: LD_INT 107
37574: PPUSH
37575: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37579: LD_INT 108
37581: PPUSH
37582: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37586: LD_INT 109
37588: PPUSH
37589: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37593: LD_INT 110
37595: PPUSH
37596: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37600: LD_INT 111
37602: PPUSH
37603: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37607: LD_INT 112
37609: PPUSH
37610: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37614: LD_INT 113
37616: PPUSH
37617: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37621: LD_INT 120
37623: PPUSH
37624: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37628: LD_INT 121
37630: PPUSH
37631: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37635: LD_INT 122
37637: PPUSH
37638: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37642: LD_INT 123
37644: PPUSH
37645: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37649: LD_INT 124
37651: PPUSH
37652: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37656: LD_INT 125
37658: PPUSH
37659: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37663: LD_INT 126
37665: PPUSH
37666: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37670: LD_INT 200
37672: PPUSH
37673: CALL_OW 427
// end ;
37677: END
// on SailEvent ( event ) do begin if event < 100 then
37678: LD_VAR 0 1
37682: PUSH
37683: LD_INT 100
37685: LESS
37686: IFFALSE 37697
// CustomEvent ( event ) ;
37688: LD_VAR 0 1
37692: PPUSH
37693: CALL 32360 0 1
// if event = 100 then
37697: LD_VAR 0 1
37701: PUSH
37702: LD_INT 100
37704: EQUAL
37705: IFFALSE 37711
// MC_ClassManager ( ) ;
37707: CALL 38103 0 0
// if event = 101 then
37711: LD_VAR 0 1
37715: PUSH
37716: LD_INT 101
37718: EQUAL
37719: IFFALSE 37725
// MC_RepairBuildings ( ) ;
37721: CALL 42896 0 0
// if event = 102 then
37725: LD_VAR 0 1
37729: PUSH
37730: LD_INT 102
37732: EQUAL
37733: IFFALSE 37739
// MC_Heal ( ) ;
37735: CALL 43628 0 0
// if event = 103 then
37739: LD_VAR 0 1
37743: PUSH
37744: LD_INT 103
37746: EQUAL
37747: IFFALSE 37753
// MC_Build ( ) ;
37749: CALL 44050 0 0
// if event = 104 then
37753: LD_VAR 0 1
37757: PUSH
37758: LD_INT 104
37760: EQUAL
37761: IFFALSE 37767
// MC_TurretWeapon ( ) ;
37763: CALL 45663 0 0
// if event = 105 then
37767: LD_VAR 0 1
37771: PUSH
37772: LD_INT 105
37774: EQUAL
37775: IFFALSE 37781
// MC_BuildUpgrade ( ) ;
37777: CALL 45214 0 0
// if event = 106 then
37781: LD_VAR 0 1
37785: PUSH
37786: LD_INT 106
37788: EQUAL
37789: IFFALSE 37795
// MC_PlantMines ( ) ;
37791: CALL 46093 0 0
// if event = 107 then
37795: LD_VAR 0 1
37799: PUSH
37800: LD_INT 107
37802: EQUAL
37803: IFFALSE 37809
// MC_CollectCrates ( ) ;
37805: CALL 47127 0 0
// if event = 108 then
37809: LD_VAR 0 1
37813: PUSH
37814: LD_INT 108
37816: EQUAL
37817: IFFALSE 37823
// MC_LinkRemoteControl ( ) ;
37819: CALL 48903 0 0
// if event = 109 then
37823: LD_VAR 0 1
37827: PUSH
37828: LD_INT 109
37830: EQUAL
37831: IFFALSE 37837
// MC_ProduceVehicle ( ) ;
37833: CALL 49084 0 0
// if event = 110 then
37837: LD_VAR 0 1
37841: PUSH
37842: LD_INT 110
37844: EQUAL
37845: IFFALSE 37851
// MC_SendAttack ( ) ;
37847: CALL 49550 0 0
// if event = 111 then
37851: LD_VAR 0 1
37855: PUSH
37856: LD_INT 111
37858: EQUAL
37859: IFFALSE 37865
// MC_Defend ( ) ;
37861: CALL 49658 0 0
// if event = 112 then
37865: LD_VAR 0 1
37869: PUSH
37870: LD_INT 112
37872: EQUAL
37873: IFFALSE 37879
// MC_Research ( ) ;
37875: CALL 50263 0 0
// if event = 113 then
37879: LD_VAR 0 1
37883: PUSH
37884: LD_INT 113
37886: EQUAL
37887: IFFALSE 37893
// MC_MinesTrigger ( ) ;
37889: CALL 51377 0 0
// if event = 120 then
37893: LD_VAR 0 1
37897: PUSH
37898: LD_INT 120
37900: EQUAL
37901: IFFALSE 37907
// MC_RepairVehicle ( ) ;
37903: CALL 51476 0 0
// if event = 121 then
37907: LD_VAR 0 1
37911: PUSH
37912: LD_INT 121
37914: EQUAL
37915: IFFALSE 37921
// MC_TameApe ( ) ;
37917: CALL 52206 0 0
// if event = 122 then
37921: LD_VAR 0 1
37925: PUSH
37926: LD_INT 122
37928: EQUAL
37929: IFFALSE 37935
// MC_ChangeApeClass ( ) ;
37931: CALL 53035 0 0
// if event = 123 then
37935: LD_VAR 0 1
37939: PUSH
37940: LD_INT 123
37942: EQUAL
37943: IFFALSE 37949
// MC_Bazooka ( ) ;
37945: CALL 53685 0 0
// if event = 124 then
37949: LD_VAR 0 1
37953: PUSH
37954: LD_INT 124
37956: EQUAL
37957: IFFALSE 37963
// MC_TeleportExit ( ) ;
37959: CALL 53883 0 0
// if event = 125 then
37963: LD_VAR 0 1
37967: PUSH
37968: LD_INT 125
37970: EQUAL
37971: IFFALSE 37977
// MC_Deposits ( ) ;
37973: CALL 54530 0 0
// if event = 126 then
37977: LD_VAR 0 1
37981: PUSH
37982: LD_INT 126
37984: EQUAL
37985: IFFALSE 37991
// MC_RemoteDriver ( ) ;
37987: CALL 55155 0 0
// if event = 200 then
37991: LD_VAR 0 1
37995: PUSH
37996: LD_INT 200
37998: EQUAL
37999: IFFALSE 38005
// MC_Idle ( ) ;
38001: CALL 57104 0 0
// end ;
38005: PPOPN 1
38007: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38008: LD_INT 0
38010: PPUSH
38011: PPUSH
// if not mc_bases [ base ] or not tag then
38012: LD_EXP 99
38016: PUSH
38017: LD_VAR 0 1
38021: ARRAY
38022: NOT
38023: PUSH
38024: LD_VAR 0 2
38028: NOT
38029: OR
38030: IFFALSE 38034
// exit ;
38032: GO 38098
// for i in mc_bases [ base ] union mc_ape [ base ] do
38034: LD_ADDR_VAR 0 4
38038: PUSH
38039: LD_EXP 99
38043: PUSH
38044: LD_VAR 0 1
38048: ARRAY
38049: PUSH
38050: LD_EXP 128
38054: PUSH
38055: LD_VAR 0 1
38059: ARRAY
38060: UNION
38061: PUSH
38062: FOR_IN
38063: IFFALSE 38096
// if GetTag ( i ) = tag then
38065: LD_VAR 0 4
38069: PPUSH
38070: CALL_OW 110
38074: PUSH
38075: LD_VAR 0 2
38079: EQUAL
38080: IFFALSE 38094
// SetTag ( i , 0 ) ;
38082: LD_VAR 0 4
38086: PPUSH
38087: LD_INT 0
38089: PPUSH
38090: CALL_OW 109
38094: GO 38062
38096: POP
38097: POP
// end ;
38098: LD_VAR 0 3
38102: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38103: LD_INT 0
38105: PPUSH
38106: PPUSH
38107: PPUSH
38108: PPUSH
38109: PPUSH
38110: PPUSH
38111: PPUSH
38112: PPUSH
// if not mc_bases then
38113: LD_EXP 99
38117: NOT
38118: IFFALSE 38122
// exit ;
38120: GO 38580
// for i = 1 to mc_bases do
38122: LD_ADDR_VAR 0 2
38126: PUSH
38127: DOUBLE
38128: LD_INT 1
38130: DEC
38131: ST_TO_ADDR
38132: LD_EXP 99
38136: PUSH
38137: FOR_TO
38138: IFFALSE 38578
// begin tmp := MC_ClassCheckReq ( i ) ;
38140: LD_ADDR_VAR 0 4
38144: PUSH
38145: LD_VAR 0 2
38149: PPUSH
38150: CALL 38585 0 1
38154: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38155: LD_ADDR_EXP 140
38159: PUSH
38160: LD_EXP 140
38164: PPUSH
38165: LD_VAR 0 2
38169: PPUSH
38170: LD_VAR 0 4
38174: PPUSH
38175: CALL_OW 1
38179: ST_TO_ADDR
// if not tmp then
38180: LD_VAR 0 4
38184: NOT
38185: IFFALSE 38189
// continue ;
38187: GO 38137
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38189: LD_ADDR_VAR 0 6
38193: PUSH
38194: LD_EXP 99
38198: PUSH
38199: LD_VAR 0 2
38203: ARRAY
38204: PPUSH
38205: LD_INT 2
38207: PUSH
38208: LD_INT 30
38210: PUSH
38211: LD_INT 4
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 30
38220: PUSH
38221: LD_INT 5
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: LIST
38232: PPUSH
38233: CALL_OW 72
38237: PUSH
38238: LD_EXP 99
38242: PUSH
38243: LD_VAR 0 2
38247: ARRAY
38248: PPUSH
38249: LD_INT 2
38251: PUSH
38252: LD_INT 30
38254: PUSH
38255: LD_INT 0
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 30
38264: PUSH
38265: LD_INT 1
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: LIST
38276: PPUSH
38277: CALL_OW 72
38281: PUSH
38282: LD_EXP 99
38286: PUSH
38287: LD_VAR 0 2
38291: ARRAY
38292: PPUSH
38293: LD_INT 30
38295: PUSH
38296: LD_INT 3
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PPUSH
38303: CALL_OW 72
38307: PUSH
38308: LD_EXP 99
38312: PUSH
38313: LD_VAR 0 2
38317: ARRAY
38318: PPUSH
38319: LD_INT 2
38321: PUSH
38322: LD_INT 30
38324: PUSH
38325: LD_INT 6
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 30
38334: PUSH
38335: LD_INT 7
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 30
38344: PUSH
38345: LD_INT 8
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: PPUSH
38358: CALL_OW 72
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: ST_TO_ADDR
// for j = 1 to 4 do
38369: LD_ADDR_VAR 0 3
38373: PUSH
38374: DOUBLE
38375: LD_INT 1
38377: DEC
38378: ST_TO_ADDR
38379: LD_INT 4
38381: PUSH
38382: FOR_TO
38383: IFFALSE 38574
// begin if not tmp [ j ] then
38385: LD_VAR 0 4
38389: PUSH
38390: LD_VAR 0 3
38394: ARRAY
38395: NOT
38396: IFFALSE 38400
// continue ;
38398: GO 38382
// for p in tmp [ j ] do
38400: LD_ADDR_VAR 0 5
38404: PUSH
38405: LD_VAR 0 4
38409: PUSH
38410: LD_VAR 0 3
38414: ARRAY
38415: PUSH
38416: FOR_IN
38417: IFFALSE 38570
// begin if not b [ j ] then
38419: LD_VAR 0 6
38423: PUSH
38424: LD_VAR 0 3
38428: ARRAY
38429: NOT
38430: IFFALSE 38434
// break ;
38432: GO 38570
// e := 0 ;
38434: LD_ADDR_VAR 0 7
38438: PUSH
38439: LD_INT 0
38441: ST_TO_ADDR
// for k in b [ j ] do
38442: LD_ADDR_VAR 0 8
38446: PUSH
38447: LD_VAR 0 6
38451: PUSH
38452: LD_VAR 0 3
38456: ARRAY
38457: PUSH
38458: FOR_IN
38459: IFFALSE 38486
// if IsNotFull ( k ) then
38461: LD_VAR 0 8
38465: PPUSH
38466: CALL 68487 0 1
38470: IFFALSE 38484
// begin e := k ;
38472: LD_ADDR_VAR 0 7
38476: PUSH
38477: LD_VAR 0 8
38481: ST_TO_ADDR
// break ;
38482: GO 38486
// end ;
38484: GO 38458
38486: POP
38487: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38488: LD_VAR 0 7
38492: PUSH
38493: LD_VAR 0 5
38497: PPUSH
38498: LD_VAR 0 7
38502: PPUSH
38503: CALL 105606 0 2
38507: NOT
38508: AND
38509: IFFALSE 38568
// begin if IsInUnit ( p ) then
38511: LD_VAR 0 5
38515: PPUSH
38516: CALL_OW 310
38520: IFFALSE 38531
// ComExitBuilding ( p ) ;
38522: LD_VAR 0 5
38526: PPUSH
38527: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38531: LD_VAR 0 5
38535: PPUSH
38536: LD_VAR 0 7
38540: PPUSH
38541: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38545: LD_VAR 0 5
38549: PPUSH
38550: LD_VAR 0 3
38554: PPUSH
38555: CALL_OW 183
// AddComExitBuilding ( p ) ;
38559: LD_VAR 0 5
38563: PPUSH
38564: CALL_OW 182
// end ; end ;
38568: GO 38416
38570: POP
38571: POP
// end ;
38572: GO 38382
38574: POP
38575: POP
// end ;
38576: GO 38137
38578: POP
38579: POP
// end ;
38580: LD_VAR 0 1
38584: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38585: LD_INT 0
38587: PPUSH
38588: PPUSH
38589: PPUSH
38590: PPUSH
38591: PPUSH
38592: PPUSH
38593: PPUSH
38594: PPUSH
38595: PPUSH
38596: PPUSH
38597: PPUSH
38598: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38599: LD_VAR 0 1
38603: NOT
38604: PUSH
38605: LD_EXP 99
38609: PUSH
38610: LD_VAR 0 1
38614: ARRAY
38615: NOT
38616: OR
38617: PUSH
38618: LD_EXP 99
38622: PUSH
38623: LD_VAR 0 1
38627: ARRAY
38628: PPUSH
38629: LD_INT 2
38631: PUSH
38632: LD_INT 30
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 30
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: LIST
38656: PPUSH
38657: CALL_OW 72
38661: NOT
38662: OR
38663: IFFALSE 38667
// exit ;
38665: GO 42170
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38667: LD_ADDR_VAR 0 4
38671: PUSH
38672: LD_EXP 99
38676: PUSH
38677: LD_VAR 0 1
38681: ARRAY
38682: PPUSH
38683: LD_INT 2
38685: PUSH
38686: LD_INT 25
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 25
38698: PUSH
38699: LD_INT 2
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 25
38708: PUSH
38709: LD_INT 3
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 25
38718: PUSH
38719: LD_INT 4
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 25
38728: PUSH
38729: LD_INT 5
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 25
38738: PUSH
38739: LD_INT 8
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: LD_INT 25
38748: PUSH
38749: LD_INT 9
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: PPUSH
38766: CALL_OW 72
38770: ST_TO_ADDR
// if not tmp then
38771: LD_VAR 0 4
38775: NOT
38776: IFFALSE 38780
// exit ;
38778: GO 42170
// for i in tmp do
38780: LD_ADDR_VAR 0 3
38784: PUSH
38785: LD_VAR 0 4
38789: PUSH
38790: FOR_IN
38791: IFFALSE 38822
// if GetTag ( i ) then
38793: LD_VAR 0 3
38797: PPUSH
38798: CALL_OW 110
38802: IFFALSE 38820
// tmp := tmp diff i ;
38804: LD_ADDR_VAR 0 4
38808: PUSH
38809: LD_VAR 0 4
38813: PUSH
38814: LD_VAR 0 3
38818: DIFF
38819: ST_TO_ADDR
38820: GO 38790
38822: POP
38823: POP
// if not tmp then
38824: LD_VAR 0 4
38828: NOT
38829: IFFALSE 38833
// exit ;
38831: GO 42170
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38833: LD_ADDR_VAR 0 5
38837: PUSH
38838: LD_EXP 99
38842: PUSH
38843: LD_VAR 0 1
38847: ARRAY
38848: PPUSH
38849: LD_INT 2
38851: PUSH
38852: LD_INT 25
38854: PUSH
38855: LD_INT 1
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 25
38864: PUSH
38865: LD_INT 5
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 25
38874: PUSH
38875: LD_INT 8
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 25
38884: PUSH
38885: LD_INT 9
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: PPUSH
38899: CALL_OW 72
38903: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38904: LD_ADDR_VAR 0 6
38908: PUSH
38909: LD_EXP 99
38913: PUSH
38914: LD_VAR 0 1
38918: ARRAY
38919: PPUSH
38920: LD_INT 25
38922: PUSH
38923: LD_INT 2
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PPUSH
38930: CALL_OW 72
38934: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38935: LD_ADDR_VAR 0 7
38939: PUSH
38940: LD_EXP 99
38944: PUSH
38945: LD_VAR 0 1
38949: ARRAY
38950: PPUSH
38951: LD_INT 25
38953: PUSH
38954: LD_INT 3
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PPUSH
38961: CALL_OW 72
38965: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38966: LD_ADDR_VAR 0 8
38970: PUSH
38971: LD_EXP 99
38975: PUSH
38976: LD_VAR 0 1
38980: ARRAY
38981: PPUSH
38982: LD_INT 25
38984: PUSH
38985: LD_INT 4
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 24
38994: PUSH
38995: LD_INT 251
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PPUSH
39006: CALL_OW 72
39010: ST_TO_ADDR
// if mc_scan [ base ] then
39011: LD_EXP 122
39015: PUSH
39016: LD_VAR 0 1
39020: ARRAY
39021: IFFALSE 39482
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39023: LD_ADDR_EXP 141
39027: PUSH
39028: LD_EXP 141
39032: PPUSH
39033: LD_VAR 0 1
39037: PPUSH
39038: LD_INT 4
39040: PPUSH
39041: CALL_OW 1
39045: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39046: LD_ADDR_VAR 0 12
39050: PUSH
39051: LD_EXP 99
39055: PUSH
39056: LD_VAR 0 1
39060: ARRAY
39061: PPUSH
39062: LD_INT 2
39064: PUSH
39065: LD_INT 30
39067: PUSH
39068: LD_INT 4
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 30
39077: PUSH
39078: LD_INT 5
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: LIST
39089: PPUSH
39090: CALL_OW 72
39094: ST_TO_ADDR
// if not b then
39095: LD_VAR 0 12
39099: NOT
39100: IFFALSE 39104
// exit ;
39102: GO 42170
// p := [ ] ;
39104: LD_ADDR_VAR 0 11
39108: PUSH
39109: EMPTY
39110: ST_TO_ADDR
// if sci >= 2 then
39111: LD_VAR 0 8
39115: PUSH
39116: LD_INT 2
39118: GREATEREQUAL
39119: IFFALSE 39150
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39121: LD_ADDR_VAR 0 8
39125: PUSH
39126: LD_VAR 0 8
39130: PUSH
39131: LD_INT 1
39133: ARRAY
39134: PUSH
39135: LD_VAR 0 8
39139: PUSH
39140: LD_INT 2
39142: ARRAY
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: ST_TO_ADDR
39148: GO 39211
// if sci = 1 then
39150: LD_VAR 0 8
39154: PUSH
39155: LD_INT 1
39157: EQUAL
39158: IFFALSE 39179
// sci := [ sci [ 1 ] ] else
39160: LD_ADDR_VAR 0 8
39164: PUSH
39165: LD_VAR 0 8
39169: PUSH
39170: LD_INT 1
39172: ARRAY
39173: PUSH
39174: EMPTY
39175: LIST
39176: ST_TO_ADDR
39177: GO 39211
// if sci = 0 then
39179: LD_VAR 0 8
39183: PUSH
39184: LD_INT 0
39186: EQUAL
39187: IFFALSE 39211
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39189: LD_ADDR_VAR 0 11
39193: PUSH
39194: LD_VAR 0 4
39198: PPUSH
39199: LD_INT 4
39201: PPUSH
39202: CALL 105469 0 2
39206: PUSH
39207: LD_INT 1
39209: ARRAY
39210: ST_TO_ADDR
// if eng > 4 then
39211: LD_VAR 0 6
39215: PUSH
39216: LD_INT 4
39218: GREATER
39219: IFFALSE 39265
// for i = eng downto 4 do
39221: LD_ADDR_VAR 0 3
39225: PUSH
39226: DOUBLE
39227: LD_VAR 0 6
39231: INC
39232: ST_TO_ADDR
39233: LD_INT 4
39235: PUSH
39236: FOR_DOWNTO
39237: IFFALSE 39263
// eng := eng diff eng [ i ] ;
39239: LD_ADDR_VAR 0 6
39243: PUSH
39244: LD_VAR 0 6
39248: PUSH
39249: LD_VAR 0 6
39253: PUSH
39254: LD_VAR 0 3
39258: ARRAY
39259: DIFF
39260: ST_TO_ADDR
39261: GO 39236
39263: POP
39264: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39265: LD_ADDR_VAR 0 4
39269: PUSH
39270: LD_VAR 0 4
39274: PUSH
39275: LD_VAR 0 5
39279: PUSH
39280: LD_VAR 0 6
39284: UNION
39285: PUSH
39286: LD_VAR 0 7
39290: UNION
39291: PUSH
39292: LD_VAR 0 8
39296: UNION
39297: DIFF
39298: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39299: LD_ADDR_VAR 0 13
39303: PUSH
39304: LD_EXP 99
39308: PUSH
39309: LD_VAR 0 1
39313: ARRAY
39314: PPUSH
39315: LD_INT 2
39317: PUSH
39318: LD_INT 30
39320: PUSH
39321: LD_INT 32
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 30
39330: PUSH
39331: LD_INT 31
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: LIST
39342: PPUSH
39343: CALL_OW 72
39347: PUSH
39348: LD_EXP 99
39352: PUSH
39353: LD_VAR 0 1
39357: ARRAY
39358: PPUSH
39359: LD_INT 2
39361: PUSH
39362: LD_INT 30
39364: PUSH
39365: LD_INT 4
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 30
39374: PUSH
39375: LD_INT 5
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: LIST
39386: PPUSH
39387: CALL_OW 72
39391: PUSH
39392: LD_INT 6
39394: MUL
39395: PLUS
39396: ST_TO_ADDR
// if bcount < tmp then
39397: LD_VAR 0 13
39401: PUSH
39402: LD_VAR 0 4
39406: LESS
39407: IFFALSE 39453
// for i = tmp downto bcount do
39409: LD_ADDR_VAR 0 3
39413: PUSH
39414: DOUBLE
39415: LD_VAR 0 4
39419: INC
39420: ST_TO_ADDR
39421: LD_VAR 0 13
39425: PUSH
39426: FOR_DOWNTO
39427: IFFALSE 39451
// tmp := Delete ( tmp , tmp ) ;
39429: LD_ADDR_VAR 0 4
39433: PUSH
39434: LD_VAR 0 4
39438: PPUSH
39439: LD_VAR 0 4
39443: PPUSH
39444: CALL_OW 3
39448: ST_TO_ADDR
39449: GO 39426
39451: POP
39452: POP
// result := [ tmp , 0 , 0 , p ] ;
39453: LD_ADDR_VAR 0 2
39457: PUSH
39458: LD_VAR 0 4
39462: PUSH
39463: LD_INT 0
39465: PUSH
39466: LD_INT 0
39468: PUSH
39469: LD_VAR 0 11
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: LIST
39478: LIST
39479: ST_TO_ADDR
// exit ;
39480: GO 42170
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39482: LD_EXP 99
39486: PUSH
39487: LD_VAR 0 1
39491: ARRAY
39492: PPUSH
39493: LD_INT 2
39495: PUSH
39496: LD_INT 30
39498: PUSH
39499: LD_INT 6
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 30
39508: PUSH
39509: LD_INT 7
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 30
39518: PUSH
39519: LD_INT 8
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: PPUSH
39532: CALL_OW 72
39536: NOT
39537: PUSH
39538: LD_EXP 99
39542: PUSH
39543: LD_VAR 0 1
39547: ARRAY
39548: PPUSH
39549: LD_INT 30
39551: PUSH
39552: LD_INT 3
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PPUSH
39559: CALL_OW 72
39563: NOT
39564: AND
39565: IFFALSE 39637
// begin if eng = tmp then
39567: LD_VAR 0 6
39571: PUSH
39572: LD_VAR 0 4
39576: EQUAL
39577: IFFALSE 39581
// exit ;
39579: GO 42170
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39581: LD_ADDR_EXP 141
39585: PUSH
39586: LD_EXP 141
39590: PPUSH
39591: LD_VAR 0 1
39595: PPUSH
39596: LD_INT 1
39598: PPUSH
39599: CALL_OW 1
39603: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39604: LD_ADDR_VAR 0 2
39608: PUSH
39609: LD_INT 0
39611: PUSH
39612: LD_VAR 0 4
39616: PUSH
39617: LD_VAR 0 6
39621: DIFF
39622: PUSH
39623: LD_INT 0
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: ST_TO_ADDR
// exit ;
39635: GO 42170
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39637: LD_EXP 126
39641: PUSH
39642: LD_EXP 125
39646: PUSH
39647: LD_VAR 0 1
39651: ARRAY
39652: ARRAY
39653: PUSH
39654: LD_EXP 99
39658: PUSH
39659: LD_VAR 0 1
39663: ARRAY
39664: PPUSH
39665: LD_INT 2
39667: PUSH
39668: LD_INT 30
39670: PUSH
39671: LD_INT 6
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 30
39680: PUSH
39681: LD_INT 7
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 30
39690: PUSH
39691: LD_INT 8
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: PPUSH
39704: CALL_OW 72
39708: AND
39709: PUSH
39710: LD_EXP 99
39714: PUSH
39715: LD_VAR 0 1
39719: ARRAY
39720: PPUSH
39721: LD_INT 30
39723: PUSH
39724: LD_INT 3
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PPUSH
39731: CALL_OW 72
39735: NOT
39736: AND
39737: IFFALSE 39951
// begin if sci >= 6 then
39739: LD_VAR 0 8
39743: PUSH
39744: LD_INT 6
39746: GREATEREQUAL
39747: IFFALSE 39751
// exit ;
39749: GO 42170
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39751: LD_ADDR_EXP 141
39755: PUSH
39756: LD_EXP 141
39760: PPUSH
39761: LD_VAR 0 1
39765: PPUSH
39766: LD_INT 2
39768: PPUSH
39769: CALL_OW 1
39773: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39774: LD_ADDR_VAR 0 9
39778: PUSH
39779: LD_VAR 0 4
39783: PUSH
39784: LD_VAR 0 8
39788: DIFF
39789: PPUSH
39790: LD_INT 4
39792: PPUSH
39793: CALL 105469 0 2
39797: ST_TO_ADDR
// p := [ ] ;
39798: LD_ADDR_VAR 0 11
39802: PUSH
39803: EMPTY
39804: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39805: LD_VAR 0 8
39809: PUSH
39810: LD_INT 6
39812: LESS
39813: PUSH
39814: LD_VAR 0 9
39818: PUSH
39819: LD_INT 6
39821: GREATER
39822: AND
39823: IFFALSE 39904
// begin for i = 1 to 6 - sci do
39825: LD_ADDR_VAR 0 3
39829: PUSH
39830: DOUBLE
39831: LD_INT 1
39833: DEC
39834: ST_TO_ADDR
39835: LD_INT 6
39837: PUSH
39838: LD_VAR 0 8
39842: MINUS
39843: PUSH
39844: FOR_TO
39845: IFFALSE 39900
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39847: LD_ADDR_VAR 0 11
39851: PUSH
39852: LD_VAR 0 11
39856: PPUSH
39857: LD_VAR 0 11
39861: PUSH
39862: LD_INT 1
39864: PLUS
39865: PPUSH
39866: LD_VAR 0 9
39870: PUSH
39871: LD_INT 1
39873: ARRAY
39874: PPUSH
39875: CALL_OW 2
39879: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39880: LD_ADDR_VAR 0 9
39884: PUSH
39885: LD_VAR 0 9
39889: PPUSH
39890: LD_INT 1
39892: PPUSH
39893: CALL_OW 3
39897: ST_TO_ADDR
// end ;
39898: GO 39844
39900: POP
39901: POP
// end else
39902: GO 39924
// if sort then
39904: LD_VAR 0 9
39908: IFFALSE 39924
// p := sort [ 1 ] ;
39910: LD_ADDR_VAR 0 11
39914: PUSH
39915: LD_VAR 0 9
39919: PUSH
39920: LD_INT 1
39922: ARRAY
39923: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39924: LD_ADDR_VAR 0 2
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: LD_INT 0
39937: PUSH
39938: LD_VAR 0 11
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: ST_TO_ADDR
// exit ;
39949: GO 42170
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39951: LD_EXP 126
39955: PUSH
39956: LD_EXP 125
39960: PUSH
39961: LD_VAR 0 1
39965: ARRAY
39966: ARRAY
39967: PUSH
39968: LD_EXP 99
39972: PUSH
39973: LD_VAR 0 1
39977: ARRAY
39978: PPUSH
39979: LD_INT 2
39981: PUSH
39982: LD_INT 30
39984: PUSH
39985: LD_INT 6
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 30
39994: PUSH
39995: LD_INT 7
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 30
40004: PUSH
40005: LD_INT 8
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: PPUSH
40018: CALL_OW 72
40022: AND
40023: PUSH
40024: LD_EXP 99
40028: PUSH
40029: LD_VAR 0 1
40033: ARRAY
40034: PPUSH
40035: LD_INT 30
40037: PUSH
40038: LD_INT 3
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PPUSH
40045: CALL_OW 72
40049: AND
40050: IFFALSE 40784
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40052: LD_ADDR_EXP 141
40056: PUSH
40057: LD_EXP 141
40061: PPUSH
40062: LD_VAR 0 1
40066: PPUSH
40067: LD_INT 3
40069: PPUSH
40070: CALL_OW 1
40074: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40075: LD_ADDR_VAR 0 2
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 0
40088: PUSH
40089: LD_INT 0
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: ST_TO_ADDR
// if not eng then
40098: LD_VAR 0 6
40102: NOT
40103: IFFALSE 40166
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40105: LD_ADDR_VAR 0 11
40109: PUSH
40110: LD_VAR 0 4
40114: PPUSH
40115: LD_INT 2
40117: PPUSH
40118: CALL 105469 0 2
40122: PUSH
40123: LD_INT 1
40125: ARRAY
40126: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40127: LD_ADDR_VAR 0 2
40131: PUSH
40132: LD_VAR 0 2
40136: PPUSH
40137: LD_INT 2
40139: PPUSH
40140: LD_VAR 0 11
40144: PPUSH
40145: CALL_OW 1
40149: ST_TO_ADDR
// tmp := tmp diff p ;
40150: LD_ADDR_VAR 0 4
40154: PUSH
40155: LD_VAR 0 4
40159: PUSH
40160: LD_VAR 0 11
40164: DIFF
40165: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40166: LD_VAR 0 4
40170: PUSH
40171: LD_VAR 0 8
40175: PUSH
40176: LD_INT 6
40178: LESS
40179: AND
40180: IFFALSE 40368
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40182: LD_ADDR_VAR 0 9
40186: PUSH
40187: LD_VAR 0 4
40191: PUSH
40192: LD_VAR 0 8
40196: PUSH
40197: LD_VAR 0 7
40201: UNION
40202: DIFF
40203: PPUSH
40204: LD_INT 4
40206: PPUSH
40207: CALL 105469 0 2
40211: ST_TO_ADDR
// p := [ ] ;
40212: LD_ADDR_VAR 0 11
40216: PUSH
40217: EMPTY
40218: ST_TO_ADDR
// if sort then
40219: LD_VAR 0 9
40223: IFFALSE 40339
// for i = 1 to 6 - sci do
40225: LD_ADDR_VAR 0 3
40229: PUSH
40230: DOUBLE
40231: LD_INT 1
40233: DEC
40234: ST_TO_ADDR
40235: LD_INT 6
40237: PUSH
40238: LD_VAR 0 8
40242: MINUS
40243: PUSH
40244: FOR_TO
40245: IFFALSE 40337
// begin if i = sort then
40247: LD_VAR 0 3
40251: PUSH
40252: LD_VAR 0 9
40256: EQUAL
40257: IFFALSE 40261
// break ;
40259: GO 40337
// if GetClass ( i ) = 4 then
40261: LD_VAR 0 3
40265: PPUSH
40266: CALL_OW 257
40270: PUSH
40271: LD_INT 4
40273: EQUAL
40274: IFFALSE 40278
// continue ;
40276: GO 40244
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40278: LD_ADDR_VAR 0 11
40282: PUSH
40283: LD_VAR 0 11
40287: PPUSH
40288: LD_VAR 0 11
40292: PUSH
40293: LD_INT 1
40295: PLUS
40296: PPUSH
40297: LD_VAR 0 9
40301: PUSH
40302: LD_VAR 0 3
40306: ARRAY
40307: PPUSH
40308: CALL_OW 2
40312: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40313: LD_ADDR_VAR 0 4
40317: PUSH
40318: LD_VAR 0 4
40322: PUSH
40323: LD_VAR 0 9
40327: PUSH
40328: LD_VAR 0 3
40332: ARRAY
40333: DIFF
40334: ST_TO_ADDR
// end ;
40335: GO 40244
40337: POP
40338: POP
// if p then
40339: LD_VAR 0 11
40343: IFFALSE 40368
// result := Replace ( result , 4 , p ) ;
40345: LD_ADDR_VAR 0 2
40349: PUSH
40350: LD_VAR 0 2
40354: PPUSH
40355: LD_INT 4
40357: PPUSH
40358: LD_VAR 0 11
40362: PPUSH
40363: CALL_OW 1
40367: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40368: LD_VAR 0 4
40372: PUSH
40373: LD_VAR 0 7
40377: PUSH
40378: LD_INT 6
40380: LESS
40381: AND
40382: IFFALSE 40570
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40384: LD_ADDR_VAR 0 9
40388: PUSH
40389: LD_VAR 0 4
40393: PUSH
40394: LD_VAR 0 8
40398: PUSH
40399: LD_VAR 0 7
40403: UNION
40404: DIFF
40405: PPUSH
40406: LD_INT 3
40408: PPUSH
40409: CALL 105469 0 2
40413: ST_TO_ADDR
// p := [ ] ;
40414: LD_ADDR_VAR 0 11
40418: PUSH
40419: EMPTY
40420: ST_TO_ADDR
// if sort then
40421: LD_VAR 0 9
40425: IFFALSE 40541
// for i = 1 to 6 - mech do
40427: LD_ADDR_VAR 0 3
40431: PUSH
40432: DOUBLE
40433: LD_INT 1
40435: DEC
40436: ST_TO_ADDR
40437: LD_INT 6
40439: PUSH
40440: LD_VAR 0 7
40444: MINUS
40445: PUSH
40446: FOR_TO
40447: IFFALSE 40539
// begin if i = sort then
40449: LD_VAR 0 3
40453: PUSH
40454: LD_VAR 0 9
40458: EQUAL
40459: IFFALSE 40463
// break ;
40461: GO 40539
// if GetClass ( i ) = 3 then
40463: LD_VAR 0 3
40467: PPUSH
40468: CALL_OW 257
40472: PUSH
40473: LD_INT 3
40475: EQUAL
40476: IFFALSE 40480
// continue ;
40478: GO 40446
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40480: LD_ADDR_VAR 0 11
40484: PUSH
40485: LD_VAR 0 11
40489: PPUSH
40490: LD_VAR 0 11
40494: PUSH
40495: LD_INT 1
40497: PLUS
40498: PPUSH
40499: LD_VAR 0 9
40503: PUSH
40504: LD_VAR 0 3
40508: ARRAY
40509: PPUSH
40510: CALL_OW 2
40514: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40515: LD_ADDR_VAR 0 4
40519: PUSH
40520: LD_VAR 0 4
40524: PUSH
40525: LD_VAR 0 9
40529: PUSH
40530: LD_VAR 0 3
40534: ARRAY
40535: DIFF
40536: ST_TO_ADDR
// end ;
40537: GO 40446
40539: POP
40540: POP
// if p then
40541: LD_VAR 0 11
40545: IFFALSE 40570
// result := Replace ( result , 3 , p ) ;
40547: LD_ADDR_VAR 0 2
40551: PUSH
40552: LD_VAR 0 2
40556: PPUSH
40557: LD_INT 3
40559: PPUSH
40560: LD_VAR 0 11
40564: PPUSH
40565: CALL_OW 1
40569: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40570: LD_VAR 0 4
40574: PUSH
40575: LD_INT 6
40577: GREATER
40578: PUSH
40579: LD_VAR 0 6
40583: PUSH
40584: LD_INT 6
40586: LESS
40587: AND
40588: IFFALSE 40782
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40590: LD_ADDR_VAR 0 9
40594: PUSH
40595: LD_VAR 0 4
40599: PUSH
40600: LD_VAR 0 8
40604: PUSH
40605: LD_VAR 0 7
40609: UNION
40610: PUSH
40611: LD_VAR 0 6
40615: UNION
40616: DIFF
40617: PPUSH
40618: LD_INT 2
40620: PPUSH
40621: CALL 105469 0 2
40625: ST_TO_ADDR
// p := [ ] ;
40626: LD_ADDR_VAR 0 11
40630: PUSH
40631: EMPTY
40632: ST_TO_ADDR
// if sort then
40633: LD_VAR 0 9
40637: IFFALSE 40753
// for i = 1 to 6 - eng do
40639: LD_ADDR_VAR 0 3
40643: PUSH
40644: DOUBLE
40645: LD_INT 1
40647: DEC
40648: ST_TO_ADDR
40649: LD_INT 6
40651: PUSH
40652: LD_VAR 0 6
40656: MINUS
40657: PUSH
40658: FOR_TO
40659: IFFALSE 40751
// begin if i = sort then
40661: LD_VAR 0 3
40665: PUSH
40666: LD_VAR 0 9
40670: EQUAL
40671: IFFALSE 40675
// break ;
40673: GO 40751
// if GetClass ( i ) = 2 then
40675: LD_VAR 0 3
40679: PPUSH
40680: CALL_OW 257
40684: PUSH
40685: LD_INT 2
40687: EQUAL
40688: IFFALSE 40692
// continue ;
40690: GO 40658
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40692: LD_ADDR_VAR 0 11
40696: PUSH
40697: LD_VAR 0 11
40701: PPUSH
40702: LD_VAR 0 11
40706: PUSH
40707: LD_INT 1
40709: PLUS
40710: PPUSH
40711: LD_VAR 0 9
40715: PUSH
40716: LD_VAR 0 3
40720: ARRAY
40721: PPUSH
40722: CALL_OW 2
40726: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40727: LD_ADDR_VAR 0 4
40731: PUSH
40732: LD_VAR 0 4
40736: PUSH
40737: LD_VAR 0 9
40741: PUSH
40742: LD_VAR 0 3
40746: ARRAY
40747: DIFF
40748: ST_TO_ADDR
// end ;
40749: GO 40658
40751: POP
40752: POP
// if p then
40753: LD_VAR 0 11
40757: IFFALSE 40782
// result := Replace ( result , 2 , p ) ;
40759: LD_ADDR_VAR 0 2
40763: PUSH
40764: LD_VAR 0 2
40768: PPUSH
40769: LD_INT 2
40771: PPUSH
40772: LD_VAR 0 11
40776: PPUSH
40777: CALL_OW 1
40781: ST_TO_ADDR
// end ; exit ;
40782: GO 42170
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40784: LD_EXP 126
40788: PUSH
40789: LD_EXP 125
40793: PUSH
40794: LD_VAR 0 1
40798: ARRAY
40799: ARRAY
40800: NOT
40801: PUSH
40802: LD_EXP 99
40806: PUSH
40807: LD_VAR 0 1
40811: ARRAY
40812: PPUSH
40813: LD_INT 30
40815: PUSH
40816: LD_INT 3
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PPUSH
40823: CALL_OW 72
40827: AND
40828: PUSH
40829: LD_EXP 104
40833: PUSH
40834: LD_VAR 0 1
40838: ARRAY
40839: AND
40840: IFFALSE 41448
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40842: LD_ADDR_EXP 141
40846: PUSH
40847: LD_EXP 141
40851: PPUSH
40852: LD_VAR 0 1
40856: PPUSH
40857: LD_INT 5
40859: PPUSH
40860: CALL_OW 1
40864: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40865: LD_ADDR_VAR 0 2
40869: PUSH
40870: LD_INT 0
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: ST_TO_ADDR
// if sci > 1 then
40888: LD_VAR 0 8
40892: PUSH
40893: LD_INT 1
40895: GREATER
40896: IFFALSE 40924
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40898: LD_ADDR_VAR 0 4
40902: PUSH
40903: LD_VAR 0 4
40907: PUSH
40908: LD_VAR 0 8
40912: PUSH
40913: LD_VAR 0 8
40917: PUSH
40918: LD_INT 1
40920: ARRAY
40921: DIFF
40922: DIFF
40923: ST_TO_ADDR
// if tmp and not sci then
40924: LD_VAR 0 4
40928: PUSH
40929: LD_VAR 0 8
40933: NOT
40934: AND
40935: IFFALSE 41004
// begin sort := SortBySkill ( tmp , 4 ) ;
40937: LD_ADDR_VAR 0 9
40941: PUSH
40942: LD_VAR 0 4
40946: PPUSH
40947: LD_INT 4
40949: PPUSH
40950: CALL 105469 0 2
40954: ST_TO_ADDR
// if sort then
40955: LD_VAR 0 9
40959: IFFALSE 40975
// p := sort [ 1 ] ;
40961: LD_ADDR_VAR 0 11
40965: PUSH
40966: LD_VAR 0 9
40970: PUSH
40971: LD_INT 1
40973: ARRAY
40974: ST_TO_ADDR
// if p then
40975: LD_VAR 0 11
40979: IFFALSE 41004
// result := Replace ( result , 4 , p ) ;
40981: LD_ADDR_VAR 0 2
40985: PUSH
40986: LD_VAR 0 2
40990: PPUSH
40991: LD_INT 4
40993: PPUSH
40994: LD_VAR 0 11
40998: PPUSH
40999: CALL_OW 1
41003: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41004: LD_ADDR_VAR 0 4
41008: PUSH
41009: LD_VAR 0 4
41013: PUSH
41014: LD_VAR 0 7
41018: DIFF
41019: ST_TO_ADDR
// if tmp and mech < 6 then
41020: LD_VAR 0 4
41024: PUSH
41025: LD_VAR 0 7
41029: PUSH
41030: LD_INT 6
41032: LESS
41033: AND
41034: IFFALSE 41222
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41036: LD_ADDR_VAR 0 9
41040: PUSH
41041: LD_VAR 0 4
41045: PUSH
41046: LD_VAR 0 8
41050: PUSH
41051: LD_VAR 0 7
41055: UNION
41056: DIFF
41057: PPUSH
41058: LD_INT 3
41060: PPUSH
41061: CALL 105469 0 2
41065: ST_TO_ADDR
// p := [ ] ;
41066: LD_ADDR_VAR 0 11
41070: PUSH
41071: EMPTY
41072: ST_TO_ADDR
// if sort then
41073: LD_VAR 0 9
41077: IFFALSE 41193
// for i = 1 to 6 - mech do
41079: LD_ADDR_VAR 0 3
41083: PUSH
41084: DOUBLE
41085: LD_INT 1
41087: DEC
41088: ST_TO_ADDR
41089: LD_INT 6
41091: PUSH
41092: LD_VAR 0 7
41096: MINUS
41097: PUSH
41098: FOR_TO
41099: IFFALSE 41191
// begin if i = sort then
41101: LD_VAR 0 3
41105: PUSH
41106: LD_VAR 0 9
41110: EQUAL
41111: IFFALSE 41115
// break ;
41113: GO 41191
// if GetClass ( i ) = 3 then
41115: LD_VAR 0 3
41119: PPUSH
41120: CALL_OW 257
41124: PUSH
41125: LD_INT 3
41127: EQUAL
41128: IFFALSE 41132
// continue ;
41130: GO 41098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41132: LD_ADDR_VAR 0 11
41136: PUSH
41137: LD_VAR 0 11
41141: PPUSH
41142: LD_VAR 0 11
41146: PUSH
41147: LD_INT 1
41149: PLUS
41150: PPUSH
41151: LD_VAR 0 9
41155: PUSH
41156: LD_VAR 0 3
41160: ARRAY
41161: PPUSH
41162: CALL_OW 2
41166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41167: LD_ADDR_VAR 0 4
41171: PUSH
41172: LD_VAR 0 4
41176: PUSH
41177: LD_VAR 0 9
41181: PUSH
41182: LD_VAR 0 3
41186: ARRAY
41187: DIFF
41188: ST_TO_ADDR
// end ;
41189: GO 41098
41191: POP
41192: POP
// if p then
41193: LD_VAR 0 11
41197: IFFALSE 41222
// result := Replace ( result , 3 , p ) ;
41199: LD_ADDR_VAR 0 2
41203: PUSH
41204: LD_VAR 0 2
41208: PPUSH
41209: LD_INT 3
41211: PPUSH
41212: LD_VAR 0 11
41216: PPUSH
41217: CALL_OW 1
41221: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41222: LD_ADDR_VAR 0 4
41226: PUSH
41227: LD_VAR 0 4
41231: PUSH
41232: LD_VAR 0 6
41236: DIFF
41237: ST_TO_ADDR
// if tmp and eng < 6 then
41238: LD_VAR 0 4
41242: PUSH
41243: LD_VAR 0 6
41247: PUSH
41248: LD_INT 6
41250: LESS
41251: AND
41252: IFFALSE 41446
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41254: LD_ADDR_VAR 0 9
41258: PUSH
41259: LD_VAR 0 4
41263: PUSH
41264: LD_VAR 0 8
41268: PUSH
41269: LD_VAR 0 7
41273: UNION
41274: PUSH
41275: LD_VAR 0 6
41279: UNION
41280: DIFF
41281: PPUSH
41282: LD_INT 2
41284: PPUSH
41285: CALL 105469 0 2
41289: ST_TO_ADDR
// p := [ ] ;
41290: LD_ADDR_VAR 0 11
41294: PUSH
41295: EMPTY
41296: ST_TO_ADDR
// if sort then
41297: LD_VAR 0 9
41301: IFFALSE 41417
// for i = 1 to 6 - eng do
41303: LD_ADDR_VAR 0 3
41307: PUSH
41308: DOUBLE
41309: LD_INT 1
41311: DEC
41312: ST_TO_ADDR
41313: LD_INT 6
41315: PUSH
41316: LD_VAR 0 6
41320: MINUS
41321: PUSH
41322: FOR_TO
41323: IFFALSE 41415
// begin if i = sort then
41325: LD_VAR 0 3
41329: PUSH
41330: LD_VAR 0 9
41334: EQUAL
41335: IFFALSE 41339
// break ;
41337: GO 41415
// if GetClass ( i ) = 2 then
41339: LD_VAR 0 3
41343: PPUSH
41344: CALL_OW 257
41348: PUSH
41349: LD_INT 2
41351: EQUAL
41352: IFFALSE 41356
// continue ;
41354: GO 41322
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41356: LD_ADDR_VAR 0 11
41360: PUSH
41361: LD_VAR 0 11
41365: PPUSH
41366: LD_VAR 0 11
41370: PUSH
41371: LD_INT 1
41373: PLUS
41374: PPUSH
41375: LD_VAR 0 9
41379: PUSH
41380: LD_VAR 0 3
41384: ARRAY
41385: PPUSH
41386: CALL_OW 2
41390: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41391: LD_ADDR_VAR 0 4
41395: PUSH
41396: LD_VAR 0 4
41400: PUSH
41401: LD_VAR 0 9
41405: PUSH
41406: LD_VAR 0 3
41410: ARRAY
41411: DIFF
41412: ST_TO_ADDR
// end ;
41413: GO 41322
41415: POP
41416: POP
// if p then
41417: LD_VAR 0 11
41421: IFFALSE 41446
// result := Replace ( result , 2 , p ) ;
41423: LD_ADDR_VAR 0 2
41427: PUSH
41428: LD_VAR 0 2
41432: PPUSH
41433: LD_INT 2
41435: PPUSH
41436: LD_VAR 0 11
41440: PPUSH
41441: CALL_OW 1
41445: ST_TO_ADDR
// end ; exit ;
41446: GO 42170
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41448: LD_EXP 126
41452: PUSH
41453: LD_EXP 125
41457: PUSH
41458: LD_VAR 0 1
41462: ARRAY
41463: ARRAY
41464: NOT
41465: PUSH
41466: LD_EXP 99
41470: PUSH
41471: LD_VAR 0 1
41475: ARRAY
41476: PPUSH
41477: LD_INT 30
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PPUSH
41487: CALL_OW 72
41491: AND
41492: PUSH
41493: LD_EXP 104
41497: PUSH
41498: LD_VAR 0 1
41502: ARRAY
41503: NOT
41504: AND
41505: IFFALSE 42170
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41507: LD_ADDR_EXP 141
41511: PUSH
41512: LD_EXP 141
41516: PPUSH
41517: LD_VAR 0 1
41521: PPUSH
41522: LD_INT 6
41524: PPUSH
41525: CALL_OW 1
41529: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41530: LD_ADDR_VAR 0 2
41534: PUSH
41535: LD_INT 0
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: LD_INT 0
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: ST_TO_ADDR
// if sci >= 1 then
41553: LD_VAR 0 8
41557: PUSH
41558: LD_INT 1
41560: GREATEREQUAL
41561: IFFALSE 41583
// tmp := tmp diff sci [ 1 ] ;
41563: LD_ADDR_VAR 0 4
41567: PUSH
41568: LD_VAR 0 4
41572: PUSH
41573: LD_VAR 0 8
41577: PUSH
41578: LD_INT 1
41580: ARRAY
41581: DIFF
41582: ST_TO_ADDR
// if tmp and not sci then
41583: LD_VAR 0 4
41587: PUSH
41588: LD_VAR 0 8
41592: NOT
41593: AND
41594: IFFALSE 41663
// begin sort := SortBySkill ( tmp , 4 ) ;
41596: LD_ADDR_VAR 0 9
41600: PUSH
41601: LD_VAR 0 4
41605: PPUSH
41606: LD_INT 4
41608: PPUSH
41609: CALL 105469 0 2
41613: ST_TO_ADDR
// if sort then
41614: LD_VAR 0 9
41618: IFFALSE 41634
// p := sort [ 1 ] ;
41620: LD_ADDR_VAR 0 11
41624: PUSH
41625: LD_VAR 0 9
41629: PUSH
41630: LD_INT 1
41632: ARRAY
41633: ST_TO_ADDR
// if p then
41634: LD_VAR 0 11
41638: IFFALSE 41663
// result := Replace ( result , 4 , p ) ;
41640: LD_ADDR_VAR 0 2
41644: PUSH
41645: LD_VAR 0 2
41649: PPUSH
41650: LD_INT 4
41652: PPUSH
41653: LD_VAR 0 11
41657: PPUSH
41658: CALL_OW 1
41662: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41663: LD_ADDR_VAR 0 4
41667: PUSH
41668: LD_VAR 0 4
41672: PUSH
41673: LD_VAR 0 7
41677: DIFF
41678: ST_TO_ADDR
// if tmp and mech < 6 then
41679: LD_VAR 0 4
41683: PUSH
41684: LD_VAR 0 7
41688: PUSH
41689: LD_INT 6
41691: LESS
41692: AND
41693: IFFALSE 41875
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41695: LD_ADDR_VAR 0 9
41699: PUSH
41700: LD_VAR 0 4
41704: PUSH
41705: LD_VAR 0 7
41709: DIFF
41710: PPUSH
41711: LD_INT 3
41713: PPUSH
41714: CALL 105469 0 2
41718: ST_TO_ADDR
// p := [ ] ;
41719: LD_ADDR_VAR 0 11
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// if sort then
41726: LD_VAR 0 9
41730: IFFALSE 41846
// for i = 1 to 6 - mech do
41732: LD_ADDR_VAR 0 3
41736: PUSH
41737: DOUBLE
41738: LD_INT 1
41740: DEC
41741: ST_TO_ADDR
41742: LD_INT 6
41744: PUSH
41745: LD_VAR 0 7
41749: MINUS
41750: PUSH
41751: FOR_TO
41752: IFFALSE 41844
// begin if i = sort then
41754: LD_VAR 0 3
41758: PUSH
41759: LD_VAR 0 9
41763: EQUAL
41764: IFFALSE 41768
// break ;
41766: GO 41844
// if GetClass ( i ) = 3 then
41768: LD_VAR 0 3
41772: PPUSH
41773: CALL_OW 257
41777: PUSH
41778: LD_INT 3
41780: EQUAL
41781: IFFALSE 41785
// continue ;
41783: GO 41751
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41785: LD_ADDR_VAR 0 11
41789: PUSH
41790: LD_VAR 0 11
41794: PPUSH
41795: LD_VAR 0 11
41799: PUSH
41800: LD_INT 1
41802: PLUS
41803: PPUSH
41804: LD_VAR 0 9
41808: PUSH
41809: LD_VAR 0 3
41813: ARRAY
41814: PPUSH
41815: CALL_OW 2
41819: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41820: LD_ADDR_VAR 0 4
41824: PUSH
41825: LD_VAR 0 4
41829: PUSH
41830: LD_VAR 0 9
41834: PUSH
41835: LD_VAR 0 3
41839: ARRAY
41840: DIFF
41841: ST_TO_ADDR
// end ;
41842: GO 41751
41844: POP
41845: POP
// if p then
41846: LD_VAR 0 11
41850: IFFALSE 41875
// result := Replace ( result , 3 , p ) ;
41852: LD_ADDR_VAR 0 2
41856: PUSH
41857: LD_VAR 0 2
41861: PPUSH
41862: LD_INT 3
41864: PPUSH
41865: LD_VAR 0 11
41869: PPUSH
41870: CALL_OW 1
41874: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41875: LD_ADDR_VAR 0 4
41879: PUSH
41880: LD_VAR 0 4
41884: PUSH
41885: LD_VAR 0 6
41889: DIFF
41890: ST_TO_ADDR
// if tmp and eng < 4 then
41891: LD_VAR 0 4
41895: PUSH
41896: LD_VAR 0 6
41900: PUSH
41901: LD_INT 4
41903: LESS
41904: AND
41905: IFFALSE 42095
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41907: LD_ADDR_VAR 0 9
41911: PUSH
41912: LD_VAR 0 4
41916: PUSH
41917: LD_VAR 0 7
41921: PUSH
41922: LD_VAR 0 6
41926: UNION
41927: DIFF
41928: PPUSH
41929: LD_INT 2
41931: PPUSH
41932: CALL 105469 0 2
41936: ST_TO_ADDR
// p := [ ] ;
41937: LD_ADDR_VAR 0 11
41941: PUSH
41942: EMPTY
41943: ST_TO_ADDR
// if sort then
41944: LD_VAR 0 9
41948: IFFALSE 42064
// for i = 1 to 4 - eng do
41950: LD_ADDR_VAR 0 3
41954: PUSH
41955: DOUBLE
41956: LD_INT 1
41958: DEC
41959: ST_TO_ADDR
41960: LD_INT 4
41962: PUSH
41963: LD_VAR 0 6
41967: MINUS
41968: PUSH
41969: FOR_TO
41970: IFFALSE 42062
// begin if i = sort then
41972: LD_VAR 0 3
41976: PUSH
41977: LD_VAR 0 9
41981: EQUAL
41982: IFFALSE 41986
// break ;
41984: GO 42062
// if GetClass ( i ) = 2 then
41986: LD_VAR 0 3
41990: PPUSH
41991: CALL_OW 257
41995: PUSH
41996: LD_INT 2
41998: EQUAL
41999: IFFALSE 42003
// continue ;
42001: GO 41969
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42003: LD_ADDR_VAR 0 11
42007: PUSH
42008: LD_VAR 0 11
42012: PPUSH
42013: LD_VAR 0 11
42017: PUSH
42018: LD_INT 1
42020: PLUS
42021: PPUSH
42022: LD_VAR 0 9
42026: PUSH
42027: LD_VAR 0 3
42031: ARRAY
42032: PPUSH
42033: CALL_OW 2
42037: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42038: LD_ADDR_VAR 0 4
42042: PUSH
42043: LD_VAR 0 4
42047: PUSH
42048: LD_VAR 0 9
42052: PUSH
42053: LD_VAR 0 3
42057: ARRAY
42058: DIFF
42059: ST_TO_ADDR
// end ;
42060: GO 41969
42062: POP
42063: POP
// if p then
42064: LD_VAR 0 11
42068: IFFALSE 42093
// result := Replace ( result , 2 , p ) ;
42070: LD_ADDR_VAR 0 2
42074: PUSH
42075: LD_VAR 0 2
42079: PPUSH
42080: LD_INT 2
42082: PPUSH
42083: LD_VAR 0 11
42087: PPUSH
42088: CALL_OW 1
42092: ST_TO_ADDR
// end else
42093: GO 42139
// for i = eng downto 5 do
42095: LD_ADDR_VAR 0 3
42099: PUSH
42100: DOUBLE
42101: LD_VAR 0 6
42105: INC
42106: ST_TO_ADDR
42107: LD_INT 5
42109: PUSH
42110: FOR_DOWNTO
42111: IFFALSE 42137
// tmp := tmp union eng [ i ] ;
42113: LD_ADDR_VAR 0 4
42117: PUSH
42118: LD_VAR 0 4
42122: PUSH
42123: LD_VAR 0 6
42127: PUSH
42128: LD_VAR 0 3
42132: ARRAY
42133: UNION
42134: ST_TO_ADDR
42135: GO 42110
42137: POP
42138: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42139: LD_ADDR_VAR 0 2
42143: PUSH
42144: LD_VAR 0 2
42148: PPUSH
42149: LD_INT 1
42151: PPUSH
42152: LD_VAR 0 4
42156: PUSH
42157: LD_VAR 0 5
42161: DIFF
42162: PPUSH
42163: CALL_OW 1
42167: ST_TO_ADDR
// exit ;
42168: GO 42170
// end ; end ;
42170: LD_VAR 0 2
42174: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42175: LD_INT 0
42177: PPUSH
42178: PPUSH
42179: PPUSH
// if not mc_bases then
42180: LD_EXP 99
42184: NOT
42185: IFFALSE 42189
// exit ;
42187: GO 42295
// for i = 1 to mc_bases do
42189: LD_ADDR_VAR 0 2
42193: PUSH
42194: DOUBLE
42195: LD_INT 1
42197: DEC
42198: ST_TO_ADDR
42199: LD_EXP 99
42203: PUSH
42204: FOR_TO
42205: IFFALSE 42286
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42207: LD_ADDR_VAR 0 3
42211: PUSH
42212: LD_EXP 99
42216: PUSH
42217: LD_VAR 0 2
42221: ARRAY
42222: PPUSH
42223: LD_INT 21
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: LD_INT 24
42238: PUSH
42239: LD_INT 1000
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PPUSH
42254: CALL_OW 72
42258: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42259: LD_ADDR_EXP 100
42263: PUSH
42264: LD_EXP 100
42268: PPUSH
42269: LD_VAR 0 2
42273: PPUSH
42274: LD_VAR 0 3
42278: PPUSH
42279: CALL_OW 1
42283: ST_TO_ADDR
// end ;
42284: GO 42204
42286: POP
42287: POP
// RaiseSailEvent ( 101 ) ;
42288: LD_INT 101
42290: PPUSH
42291: CALL_OW 427
// end ;
42295: LD_VAR 0 1
42299: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42300: LD_INT 0
42302: PPUSH
42303: PPUSH
42304: PPUSH
42305: PPUSH
42306: PPUSH
42307: PPUSH
42308: PPUSH
// if not mc_bases then
42309: LD_EXP 99
42313: NOT
42314: IFFALSE 42318
// exit ;
42316: GO 42891
// for i = 1 to mc_bases do
42318: LD_ADDR_VAR 0 2
42322: PUSH
42323: DOUBLE
42324: LD_INT 1
42326: DEC
42327: ST_TO_ADDR
42328: LD_EXP 99
42332: PUSH
42333: FOR_TO
42334: IFFALSE 42882
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42336: LD_ADDR_VAR 0 5
42340: PUSH
42341: LD_EXP 99
42345: PUSH
42346: LD_VAR 0 2
42350: ARRAY
42351: PUSH
42352: LD_EXP 128
42356: PUSH
42357: LD_VAR 0 2
42361: ARRAY
42362: UNION
42363: PPUSH
42364: LD_INT 21
42366: PUSH
42367: LD_INT 1
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 1
42376: PUSH
42377: LD_INT 3
42379: PUSH
42380: LD_INT 54
42382: PUSH
42383: EMPTY
42384: LIST
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 3
42392: PUSH
42393: LD_INT 24
42395: PUSH
42396: LD_INT 800
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: LIST
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PPUSH
42416: CALL_OW 72
42420: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42421: LD_ADDR_VAR 0 6
42425: PUSH
42426: LD_EXP 99
42430: PUSH
42431: LD_VAR 0 2
42435: ARRAY
42436: PPUSH
42437: LD_INT 21
42439: PUSH
42440: LD_INT 1
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PUSH
42447: LD_INT 1
42449: PUSH
42450: LD_INT 3
42452: PUSH
42453: LD_INT 54
42455: PUSH
42456: EMPTY
42457: LIST
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 3
42465: PUSH
42466: LD_INT 24
42468: PUSH
42469: LD_INT 250
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: LIST
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PPUSH
42489: CALL_OW 72
42493: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42494: LD_ADDR_VAR 0 7
42498: PUSH
42499: LD_VAR 0 5
42503: PUSH
42504: LD_VAR 0 6
42508: DIFF
42509: ST_TO_ADDR
// if not need_heal_1 then
42510: LD_VAR 0 6
42514: NOT
42515: IFFALSE 42548
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42517: LD_ADDR_EXP 102
42521: PUSH
42522: LD_EXP 102
42526: PPUSH
42527: LD_VAR 0 2
42531: PUSH
42532: LD_INT 1
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PPUSH
42539: EMPTY
42540: PPUSH
42541: CALL 71221 0 3
42545: ST_TO_ADDR
42546: GO 42618
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42548: LD_ADDR_EXP 102
42552: PUSH
42553: LD_EXP 102
42557: PPUSH
42558: LD_VAR 0 2
42562: PUSH
42563: LD_INT 1
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PPUSH
42570: LD_EXP 102
42574: PUSH
42575: LD_VAR 0 2
42579: ARRAY
42580: PUSH
42581: LD_INT 1
42583: ARRAY
42584: PPUSH
42585: LD_INT 3
42587: PUSH
42588: LD_INT 24
42590: PUSH
42591: LD_INT 1000
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PPUSH
42602: CALL_OW 72
42606: PUSH
42607: LD_VAR 0 6
42611: UNION
42612: PPUSH
42613: CALL 71221 0 3
42617: ST_TO_ADDR
// if not need_heal_2 then
42618: LD_VAR 0 7
42622: NOT
42623: IFFALSE 42656
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42625: LD_ADDR_EXP 102
42629: PUSH
42630: LD_EXP 102
42634: PPUSH
42635: LD_VAR 0 2
42639: PUSH
42640: LD_INT 2
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: PPUSH
42647: EMPTY
42648: PPUSH
42649: CALL 71221 0 3
42653: ST_TO_ADDR
42654: GO 42688
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42656: LD_ADDR_EXP 102
42660: PUSH
42661: LD_EXP 102
42665: PPUSH
42666: LD_VAR 0 2
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PPUSH
42678: LD_VAR 0 7
42682: PPUSH
42683: CALL 71221 0 3
42687: ST_TO_ADDR
// if need_heal_2 then
42688: LD_VAR 0 7
42692: IFFALSE 42864
// for j in need_heal_2 do
42694: LD_ADDR_VAR 0 3
42698: PUSH
42699: LD_VAR 0 7
42703: PUSH
42704: FOR_IN
42705: IFFALSE 42862
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42707: LD_ADDR_VAR 0 5
42711: PUSH
42712: LD_EXP 99
42716: PUSH
42717: LD_VAR 0 2
42721: ARRAY
42722: PPUSH
42723: LD_INT 2
42725: PUSH
42726: LD_INT 30
42728: PUSH
42729: LD_INT 6
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 30
42738: PUSH
42739: LD_INT 7
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 30
42748: PUSH
42749: LD_INT 8
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 30
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 30
42768: PUSH
42769: LD_INT 1
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 25
42778: PUSH
42779: LD_INT 4
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: PPUSH
42795: CALL_OW 72
42799: ST_TO_ADDR
// if tmp then
42800: LD_VAR 0 5
42804: IFFALSE 42860
// begin k := NearestUnitToUnit ( tmp , j ) ;
42806: LD_ADDR_VAR 0 4
42810: PUSH
42811: LD_VAR 0 5
42815: PPUSH
42816: LD_VAR 0 3
42820: PPUSH
42821: CALL_OW 74
42825: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42826: LD_VAR 0 3
42830: PPUSH
42831: LD_VAR 0 4
42835: PPUSH
42836: CALL_OW 296
42840: PUSH
42841: LD_INT 7
42843: GREATER
42844: IFFALSE 42860
// ComMoveUnit ( j , k ) ;
42846: LD_VAR 0 3
42850: PPUSH
42851: LD_VAR 0 4
42855: PPUSH
42856: CALL_OW 112
// end ; end ;
42860: GO 42704
42862: POP
42863: POP
// if not need_heal_1 and not need_heal_2 then
42864: LD_VAR 0 6
42868: NOT
42869: PUSH
42870: LD_VAR 0 7
42874: NOT
42875: AND
42876: IFFALSE 42880
// continue ;
42878: GO 42333
// end ;
42880: GO 42333
42882: POP
42883: POP
// RaiseSailEvent ( 102 ) ;
42884: LD_INT 102
42886: PPUSH
42887: CALL_OW 427
// end ;
42891: LD_VAR 0 1
42895: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42896: LD_INT 0
42898: PPUSH
42899: PPUSH
42900: PPUSH
42901: PPUSH
42902: PPUSH
42903: PPUSH
// if not mc_bases then
42904: LD_EXP 99
42908: NOT
42909: IFFALSE 42913
// exit ;
42911: GO 43623
// for i = 1 to mc_bases do
42913: LD_ADDR_VAR 0 2
42917: PUSH
42918: DOUBLE
42919: LD_INT 1
42921: DEC
42922: ST_TO_ADDR
42923: LD_EXP 99
42927: PUSH
42928: FOR_TO
42929: IFFALSE 43621
// begin if not mc_building_need_repair [ i ] then
42931: LD_EXP 100
42935: PUSH
42936: LD_VAR 0 2
42940: ARRAY
42941: NOT
42942: IFFALSE 43116
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42944: LD_ADDR_VAR 0 6
42948: PUSH
42949: LD_EXP 118
42953: PUSH
42954: LD_VAR 0 2
42958: ARRAY
42959: PPUSH
42960: LD_INT 3
42962: PUSH
42963: LD_INT 24
42965: PUSH
42966: LD_INT 1000
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: PUSH
42977: LD_INT 2
42979: PUSH
42980: LD_INT 34
42982: PUSH
42983: LD_INT 13
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 34
42992: PUSH
42993: LD_INT 52
42995: PUSH
42996: EMPTY
42997: LIST
42998: LIST
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: LIST
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PPUSH
43009: CALL_OW 72
43013: ST_TO_ADDR
// if cranes then
43014: LD_VAR 0 6
43018: IFFALSE 43080
// for j in cranes do
43020: LD_ADDR_VAR 0 3
43024: PUSH
43025: LD_VAR 0 6
43029: PUSH
43030: FOR_IN
43031: IFFALSE 43078
// if not IsInArea ( j , mc_parking [ i ] ) then
43033: LD_VAR 0 3
43037: PPUSH
43038: LD_EXP 123
43042: PUSH
43043: LD_VAR 0 2
43047: ARRAY
43048: PPUSH
43049: CALL_OW 308
43053: NOT
43054: IFFALSE 43076
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43056: LD_VAR 0 3
43060: PPUSH
43061: LD_EXP 123
43065: PUSH
43066: LD_VAR 0 2
43070: ARRAY
43071: PPUSH
43072: CALL_OW 113
43076: GO 43030
43078: POP
43079: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43080: LD_ADDR_EXP 101
43084: PUSH
43085: LD_EXP 101
43089: PPUSH
43090: LD_VAR 0 2
43094: PPUSH
43095: EMPTY
43096: PPUSH
43097: CALL_OW 1
43101: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43102: LD_VAR 0 2
43106: PPUSH
43107: LD_INT 101
43109: PPUSH
43110: CALL 38008 0 2
// continue ;
43114: GO 42928
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43116: LD_ADDR_EXP 105
43120: PUSH
43121: LD_EXP 105
43125: PPUSH
43126: LD_VAR 0 2
43130: PPUSH
43131: EMPTY
43132: PPUSH
43133: CALL_OW 1
43137: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43138: LD_VAR 0 2
43142: PPUSH
43143: LD_INT 103
43145: PPUSH
43146: CALL 38008 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43150: LD_ADDR_VAR 0 5
43154: PUSH
43155: LD_EXP 99
43159: PUSH
43160: LD_VAR 0 2
43164: ARRAY
43165: PUSH
43166: LD_EXP 128
43170: PUSH
43171: LD_VAR 0 2
43175: ARRAY
43176: UNION
43177: PPUSH
43178: LD_INT 2
43180: PUSH
43181: LD_INT 25
43183: PUSH
43184: LD_INT 2
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 25
43193: PUSH
43194: LD_INT 16
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: LIST
43205: PUSH
43206: EMPTY
43207: LIST
43208: PPUSH
43209: CALL_OW 72
43213: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43214: LD_ADDR_VAR 0 6
43218: PUSH
43219: LD_EXP 118
43223: PUSH
43224: LD_VAR 0 2
43228: ARRAY
43229: PPUSH
43230: LD_INT 2
43232: PUSH
43233: LD_INT 34
43235: PUSH
43236: LD_INT 13
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 34
43245: PUSH
43246: LD_INT 52
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: LIST
43257: PPUSH
43258: CALL_OW 72
43262: ST_TO_ADDR
// if cranes then
43263: LD_VAR 0 6
43267: IFFALSE 43403
// begin for j in cranes do
43269: LD_ADDR_VAR 0 3
43273: PUSH
43274: LD_VAR 0 6
43278: PUSH
43279: FOR_IN
43280: IFFALSE 43401
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43282: LD_VAR 0 3
43286: PPUSH
43287: CALL_OW 256
43291: PUSH
43292: LD_INT 500
43294: GREATEREQUAL
43295: PUSH
43296: LD_VAR 0 3
43300: PPUSH
43301: CALL_OW 314
43305: NOT
43306: AND
43307: IFFALSE 43341
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43309: LD_VAR 0 3
43313: PPUSH
43314: LD_EXP 100
43318: PUSH
43319: LD_VAR 0 2
43323: ARRAY
43324: PPUSH
43325: LD_VAR 0 3
43329: PPUSH
43330: CALL_OW 74
43334: PPUSH
43335: CALL_OW 130
43339: GO 43399
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43341: LD_VAR 0 3
43345: PPUSH
43346: CALL_OW 256
43350: PUSH
43351: LD_INT 500
43353: LESS
43354: PUSH
43355: LD_VAR 0 3
43359: PPUSH
43360: LD_EXP 123
43364: PUSH
43365: LD_VAR 0 2
43369: ARRAY
43370: PPUSH
43371: CALL_OW 308
43375: NOT
43376: AND
43377: IFFALSE 43399
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43379: LD_VAR 0 3
43383: PPUSH
43384: LD_EXP 123
43388: PUSH
43389: LD_VAR 0 2
43393: ARRAY
43394: PPUSH
43395: CALL_OW 113
43399: GO 43279
43401: POP
43402: POP
// end ; if not tmp then
43403: LD_VAR 0 5
43407: NOT
43408: IFFALSE 43412
// continue ;
43410: GO 42928
// for j in tmp do
43412: LD_ADDR_VAR 0 3
43416: PUSH
43417: LD_VAR 0 5
43421: PUSH
43422: FOR_IN
43423: IFFALSE 43617
// begin if mc_need_heal [ i ] then
43425: LD_EXP 102
43429: PUSH
43430: LD_VAR 0 2
43434: ARRAY
43435: IFFALSE 43483
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43437: LD_VAR 0 3
43441: PUSH
43442: LD_EXP 102
43446: PUSH
43447: LD_VAR 0 2
43451: ARRAY
43452: PUSH
43453: LD_INT 1
43455: ARRAY
43456: IN
43457: PUSH
43458: LD_VAR 0 3
43462: PUSH
43463: LD_EXP 102
43467: PUSH
43468: LD_VAR 0 2
43472: ARRAY
43473: PUSH
43474: LD_INT 2
43476: ARRAY
43477: IN
43478: OR
43479: IFFALSE 43483
// continue ;
43481: GO 43422
// if IsInUnit ( j ) then
43483: LD_VAR 0 3
43487: PPUSH
43488: CALL_OW 310
43492: IFFALSE 43503
// ComExitBuilding ( j ) ;
43494: LD_VAR 0 3
43498: PPUSH
43499: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43503: LD_VAR 0 3
43507: PUSH
43508: LD_EXP 101
43512: PUSH
43513: LD_VAR 0 2
43517: ARRAY
43518: IN
43519: NOT
43520: IFFALSE 43578
// begin SetTag ( j , 101 ) ;
43522: LD_VAR 0 3
43526: PPUSH
43527: LD_INT 101
43529: PPUSH
43530: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43534: LD_ADDR_EXP 101
43538: PUSH
43539: LD_EXP 101
43543: PPUSH
43544: LD_VAR 0 2
43548: PUSH
43549: LD_EXP 101
43553: PUSH
43554: LD_VAR 0 2
43558: ARRAY
43559: PUSH
43560: LD_INT 1
43562: PLUS
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PPUSH
43568: LD_VAR 0 3
43572: PPUSH
43573: CALL 71221 0 3
43577: ST_TO_ADDR
// end ; wait ( 1 ) ;
43578: LD_INT 1
43580: PPUSH
43581: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43585: LD_VAR 0 3
43589: PPUSH
43590: LD_EXP 100
43594: PUSH
43595: LD_VAR 0 2
43599: ARRAY
43600: PPUSH
43601: LD_VAR 0 3
43605: PPUSH
43606: CALL_OW 74
43610: PPUSH
43611: CALL_OW 130
// end ;
43615: GO 43422
43617: POP
43618: POP
// end ;
43619: GO 42928
43621: POP
43622: POP
// end ;
43623: LD_VAR 0 1
43627: RET
// export function MC_Heal ; var i , j , tmp ; begin
43628: LD_INT 0
43630: PPUSH
43631: PPUSH
43632: PPUSH
43633: PPUSH
// if not mc_bases then
43634: LD_EXP 99
43638: NOT
43639: IFFALSE 43643
// exit ;
43641: GO 44045
// for i = 1 to mc_bases do
43643: LD_ADDR_VAR 0 2
43647: PUSH
43648: DOUBLE
43649: LD_INT 1
43651: DEC
43652: ST_TO_ADDR
43653: LD_EXP 99
43657: PUSH
43658: FOR_TO
43659: IFFALSE 44043
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43661: LD_EXP 102
43665: PUSH
43666: LD_VAR 0 2
43670: ARRAY
43671: PUSH
43672: LD_INT 1
43674: ARRAY
43675: NOT
43676: PUSH
43677: LD_EXP 102
43681: PUSH
43682: LD_VAR 0 2
43686: ARRAY
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: NOT
43692: AND
43693: IFFALSE 43731
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43695: LD_ADDR_EXP 103
43699: PUSH
43700: LD_EXP 103
43704: PPUSH
43705: LD_VAR 0 2
43709: PPUSH
43710: EMPTY
43711: PPUSH
43712: CALL_OW 1
43716: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43717: LD_VAR 0 2
43721: PPUSH
43722: LD_INT 102
43724: PPUSH
43725: CALL 38008 0 2
// continue ;
43729: GO 43658
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43731: LD_ADDR_VAR 0 4
43735: PUSH
43736: LD_EXP 99
43740: PUSH
43741: LD_VAR 0 2
43745: ARRAY
43746: PPUSH
43747: LD_INT 25
43749: PUSH
43750: LD_INT 4
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PPUSH
43757: CALL_OW 72
43761: ST_TO_ADDR
// if not tmp then
43762: LD_VAR 0 4
43766: NOT
43767: IFFALSE 43771
// continue ;
43769: GO 43658
// if mc_taming [ i ] then
43771: LD_EXP 130
43775: PUSH
43776: LD_VAR 0 2
43780: ARRAY
43781: IFFALSE 43805
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43783: LD_ADDR_EXP 130
43787: PUSH
43788: LD_EXP 130
43792: PPUSH
43793: LD_VAR 0 2
43797: PPUSH
43798: EMPTY
43799: PPUSH
43800: CALL_OW 1
43804: ST_TO_ADDR
// for j in tmp do
43805: LD_ADDR_VAR 0 3
43809: PUSH
43810: LD_VAR 0 4
43814: PUSH
43815: FOR_IN
43816: IFFALSE 44039
// begin if IsInUnit ( j ) then
43818: LD_VAR 0 3
43822: PPUSH
43823: CALL_OW 310
43827: IFFALSE 43838
// ComExitBuilding ( j ) ;
43829: LD_VAR 0 3
43833: PPUSH
43834: CALL_OW 122
// if not j in mc_healers [ i ] then
43838: LD_VAR 0 3
43842: PUSH
43843: LD_EXP 103
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: IN
43854: NOT
43855: IFFALSE 43901
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43857: LD_ADDR_EXP 103
43861: PUSH
43862: LD_EXP 103
43866: PPUSH
43867: LD_VAR 0 2
43871: PUSH
43872: LD_EXP 103
43876: PUSH
43877: LD_VAR 0 2
43881: ARRAY
43882: PUSH
43883: LD_INT 1
43885: PLUS
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PPUSH
43891: LD_VAR 0 3
43895: PPUSH
43896: CALL 71221 0 3
43900: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43901: LD_VAR 0 3
43905: PPUSH
43906: CALL_OW 110
43910: PUSH
43911: LD_INT 102
43913: NONEQUAL
43914: IFFALSE 43928
// SetTag ( j , 102 ) ;
43916: LD_VAR 0 3
43920: PPUSH
43921: LD_INT 102
43923: PPUSH
43924: CALL_OW 109
// Wait ( 3 ) ;
43928: LD_INT 3
43930: PPUSH
43931: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43935: LD_EXP 102
43939: PUSH
43940: LD_VAR 0 2
43944: ARRAY
43945: PUSH
43946: LD_INT 1
43948: ARRAY
43949: IFFALSE 43981
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43951: LD_VAR 0 3
43955: PPUSH
43956: LD_EXP 102
43960: PUSH
43961: LD_VAR 0 2
43965: ARRAY
43966: PUSH
43967: LD_INT 1
43969: ARRAY
43970: PUSH
43971: LD_INT 1
43973: ARRAY
43974: PPUSH
43975: CALL_OW 128
43979: GO 44037
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43981: LD_VAR 0 3
43985: PPUSH
43986: CALL_OW 314
43990: NOT
43991: PUSH
43992: LD_EXP 102
43996: PUSH
43997: LD_VAR 0 2
44001: ARRAY
44002: PUSH
44003: LD_INT 2
44005: ARRAY
44006: AND
44007: IFFALSE 44037
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44009: LD_VAR 0 3
44013: PPUSH
44014: LD_EXP 102
44018: PUSH
44019: LD_VAR 0 2
44023: ARRAY
44024: PUSH
44025: LD_INT 2
44027: ARRAY
44028: PUSH
44029: LD_INT 1
44031: ARRAY
44032: PPUSH
44033: CALL_OW 128
// end ;
44037: GO 43815
44039: POP
44040: POP
// end ;
44041: GO 43658
44043: POP
44044: POP
// end ;
44045: LD_VAR 0 1
44049: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44050: LD_INT 0
44052: PPUSH
44053: PPUSH
44054: PPUSH
44055: PPUSH
44056: PPUSH
// if not mc_bases then
44057: LD_EXP 99
44061: NOT
44062: IFFALSE 44066
// exit ;
44064: GO 45209
// for i = 1 to mc_bases do
44066: LD_ADDR_VAR 0 2
44070: PUSH
44071: DOUBLE
44072: LD_INT 1
44074: DEC
44075: ST_TO_ADDR
44076: LD_EXP 99
44080: PUSH
44081: FOR_TO
44082: IFFALSE 45207
// begin if mc_scan [ i ] then
44084: LD_EXP 122
44088: PUSH
44089: LD_VAR 0 2
44093: ARRAY
44094: IFFALSE 44098
// continue ;
44096: GO 44081
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44098: LD_EXP 104
44102: PUSH
44103: LD_VAR 0 2
44107: ARRAY
44108: NOT
44109: PUSH
44110: LD_EXP 106
44114: PUSH
44115: LD_VAR 0 2
44119: ARRAY
44120: NOT
44121: AND
44122: PUSH
44123: LD_EXP 105
44127: PUSH
44128: LD_VAR 0 2
44132: ARRAY
44133: AND
44134: IFFALSE 44172
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44136: LD_ADDR_EXP 105
44140: PUSH
44141: LD_EXP 105
44145: PPUSH
44146: LD_VAR 0 2
44150: PPUSH
44151: EMPTY
44152: PPUSH
44153: CALL_OW 1
44157: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44158: LD_VAR 0 2
44162: PPUSH
44163: LD_INT 103
44165: PPUSH
44166: CALL 38008 0 2
// continue ;
44170: GO 44081
// end ; if mc_construct_list [ i ] then
44172: LD_EXP 106
44176: PUSH
44177: LD_VAR 0 2
44181: ARRAY
44182: IFFALSE 44402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44184: LD_ADDR_VAR 0 4
44188: PUSH
44189: LD_EXP 99
44193: PUSH
44194: LD_VAR 0 2
44198: ARRAY
44199: PPUSH
44200: LD_INT 25
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PPUSH
44210: CALL_OW 72
44214: PUSH
44215: LD_EXP 101
44219: PUSH
44220: LD_VAR 0 2
44224: ARRAY
44225: DIFF
44226: ST_TO_ADDR
// if not tmp then
44227: LD_VAR 0 4
44231: NOT
44232: IFFALSE 44236
// continue ;
44234: GO 44081
// for j in tmp do
44236: LD_ADDR_VAR 0 3
44240: PUSH
44241: LD_VAR 0 4
44245: PUSH
44246: FOR_IN
44247: IFFALSE 44398
// begin if not mc_builders [ i ] then
44249: LD_EXP 105
44253: PUSH
44254: LD_VAR 0 2
44258: ARRAY
44259: NOT
44260: IFFALSE 44318
// begin SetTag ( j , 103 ) ;
44262: LD_VAR 0 3
44266: PPUSH
44267: LD_INT 103
44269: PPUSH
44270: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44274: LD_ADDR_EXP 105
44278: PUSH
44279: LD_EXP 105
44283: PPUSH
44284: LD_VAR 0 2
44288: PUSH
44289: LD_EXP 105
44293: PUSH
44294: LD_VAR 0 2
44298: ARRAY
44299: PUSH
44300: LD_INT 1
44302: PLUS
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PPUSH
44308: LD_VAR 0 3
44312: PPUSH
44313: CALL 71221 0 3
44317: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44318: LD_VAR 0 3
44322: PPUSH
44323: CALL_OW 310
44327: IFFALSE 44338
// ComExitBuilding ( j ) ;
44329: LD_VAR 0 3
44333: PPUSH
44334: CALL_OW 122
// wait ( 3 ) ;
44338: LD_INT 3
44340: PPUSH
44341: CALL_OW 67
// if not mc_construct_list [ i ] then
44345: LD_EXP 106
44349: PUSH
44350: LD_VAR 0 2
44354: ARRAY
44355: NOT
44356: IFFALSE 44360
// break ;
44358: GO 44398
// if not HasTask ( j ) then
44360: LD_VAR 0 3
44364: PPUSH
44365: CALL_OW 314
44369: NOT
44370: IFFALSE 44396
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44372: LD_VAR 0 3
44376: PPUSH
44377: LD_EXP 106
44381: PUSH
44382: LD_VAR 0 2
44386: ARRAY
44387: PUSH
44388: LD_INT 1
44390: ARRAY
44391: PPUSH
44392: CALL 74072 0 2
// end ;
44396: GO 44246
44398: POP
44399: POP
// end else
44400: GO 45205
// if mc_build_list [ i ] then
44402: LD_EXP 104
44406: PUSH
44407: LD_VAR 0 2
44411: ARRAY
44412: IFFALSE 45205
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44414: LD_ADDR_VAR 0 5
44418: PUSH
44419: LD_EXP 99
44423: PUSH
44424: LD_VAR 0 2
44428: ARRAY
44429: PPUSH
44430: LD_INT 2
44432: PUSH
44433: LD_INT 30
44435: PUSH
44436: LD_INT 0
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 30
44445: PUSH
44446: LD_INT 1
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: LIST
44457: PPUSH
44458: CALL_OW 72
44462: ST_TO_ADDR
// if depot then
44463: LD_VAR 0 5
44467: IFFALSE 44485
// depot := depot [ 1 ] else
44469: LD_ADDR_VAR 0 5
44473: PUSH
44474: LD_VAR 0 5
44478: PUSH
44479: LD_INT 1
44481: ARRAY
44482: ST_TO_ADDR
44483: GO 44493
// depot := 0 ;
44485: LD_ADDR_VAR 0 5
44489: PUSH
44490: LD_INT 0
44492: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44493: LD_EXP 104
44497: PUSH
44498: LD_VAR 0 2
44502: ARRAY
44503: PUSH
44504: LD_INT 1
44506: ARRAY
44507: PUSH
44508: LD_INT 1
44510: ARRAY
44511: PPUSH
44512: CALL 73902 0 1
44516: PUSH
44517: LD_EXP 99
44521: PUSH
44522: LD_VAR 0 2
44526: ARRAY
44527: PPUSH
44528: LD_INT 2
44530: PUSH
44531: LD_INT 30
44533: PUSH
44534: LD_INT 2
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 30
44543: PUSH
44544: LD_INT 3
44546: PUSH
44547: EMPTY
44548: LIST
44549: LIST
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: LIST
44555: PPUSH
44556: CALL_OW 72
44560: NOT
44561: AND
44562: IFFALSE 44667
// begin for j = 1 to mc_build_list [ i ] do
44564: LD_ADDR_VAR 0 3
44568: PUSH
44569: DOUBLE
44570: LD_INT 1
44572: DEC
44573: ST_TO_ADDR
44574: LD_EXP 104
44578: PUSH
44579: LD_VAR 0 2
44583: ARRAY
44584: PUSH
44585: FOR_TO
44586: IFFALSE 44665
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44588: LD_EXP 104
44592: PUSH
44593: LD_VAR 0 2
44597: ARRAY
44598: PUSH
44599: LD_VAR 0 3
44603: ARRAY
44604: PUSH
44605: LD_INT 1
44607: ARRAY
44608: PUSH
44609: LD_INT 2
44611: EQUAL
44612: IFFALSE 44663
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44614: LD_ADDR_EXP 104
44618: PUSH
44619: LD_EXP 104
44623: PPUSH
44624: LD_VAR 0 2
44628: PPUSH
44629: LD_EXP 104
44633: PUSH
44634: LD_VAR 0 2
44638: ARRAY
44639: PPUSH
44640: LD_VAR 0 3
44644: PPUSH
44645: LD_INT 1
44647: PPUSH
44648: LD_INT 0
44650: PPUSH
44651: CALL 70639 0 4
44655: PPUSH
44656: CALL_OW 1
44660: ST_TO_ADDR
// break ;
44661: GO 44665
// end ;
44663: GO 44585
44665: POP
44666: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44667: LD_EXP 104
44671: PUSH
44672: LD_VAR 0 2
44676: ARRAY
44677: PUSH
44678: LD_INT 1
44680: ARRAY
44681: PUSH
44682: LD_INT 1
44684: ARRAY
44685: PUSH
44686: LD_INT 0
44688: EQUAL
44689: PUSH
44690: LD_VAR 0 5
44694: PUSH
44695: LD_VAR 0 5
44699: PPUSH
44700: LD_EXP 104
44704: PUSH
44705: LD_VAR 0 2
44709: ARRAY
44710: PUSH
44711: LD_INT 1
44713: ARRAY
44714: PUSH
44715: LD_INT 1
44717: ARRAY
44718: PPUSH
44719: LD_EXP 104
44723: PUSH
44724: LD_VAR 0 2
44728: ARRAY
44729: PUSH
44730: LD_INT 1
44732: ARRAY
44733: PUSH
44734: LD_INT 2
44736: ARRAY
44737: PPUSH
44738: LD_EXP 104
44742: PUSH
44743: LD_VAR 0 2
44747: ARRAY
44748: PUSH
44749: LD_INT 1
44751: ARRAY
44752: PUSH
44753: LD_INT 3
44755: ARRAY
44756: PPUSH
44757: LD_EXP 104
44761: PUSH
44762: LD_VAR 0 2
44766: ARRAY
44767: PUSH
44768: LD_INT 1
44770: ARRAY
44771: PUSH
44772: LD_INT 4
44774: ARRAY
44775: PPUSH
44776: CALL 78636 0 5
44780: AND
44781: OR
44782: IFFALSE 45063
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44784: LD_ADDR_VAR 0 4
44788: PUSH
44789: LD_EXP 99
44793: PUSH
44794: LD_VAR 0 2
44798: ARRAY
44799: PPUSH
44800: LD_INT 25
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PPUSH
44810: CALL_OW 72
44814: PUSH
44815: LD_EXP 101
44819: PUSH
44820: LD_VAR 0 2
44824: ARRAY
44825: DIFF
44826: ST_TO_ADDR
// if not tmp then
44827: LD_VAR 0 4
44831: NOT
44832: IFFALSE 44836
// continue ;
44834: GO 44081
// for j in tmp do
44836: LD_ADDR_VAR 0 3
44840: PUSH
44841: LD_VAR 0 4
44845: PUSH
44846: FOR_IN
44847: IFFALSE 45059
// begin if not mc_builders [ i ] then
44849: LD_EXP 105
44853: PUSH
44854: LD_VAR 0 2
44858: ARRAY
44859: NOT
44860: IFFALSE 44918
// begin SetTag ( j , 103 ) ;
44862: LD_VAR 0 3
44866: PPUSH
44867: LD_INT 103
44869: PPUSH
44870: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44874: LD_ADDR_EXP 105
44878: PUSH
44879: LD_EXP 105
44883: PPUSH
44884: LD_VAR 0 2
44888: PUSH
44889: LD_EXP 105
44893: PUSH
44894: LD_VAR 0 2
44898: ARRAY
44899: PUSH
44900: LD_INT 1
44902: PLUS
44903: PUSH
44904: EMPTY
44905: LIST
44906: LIST
44907: PPUSH
44908: LD_VAR 0 3
44912: PPUSH
44913: CALL 71221 0 3
44917: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44918: LD_VAR 0 3
44922: PPUSH
44923: CALL_OW 310
44927: IFFALSE 44938
// ComExitBuilding ( j ) ;
44929: LD_VAR 0 3
44933: PPUSH
44934: CALL_OW 122
// wait ( 3 ) ;
44938: LD_INT 3
44940: PPUSH
44941: CALL_OW 67
// if not mc_build_list [ i ] then
44945: LD_EXP 104
44949: PUSH
44950: LD_VAR 0 2
44954: ARRAY
44955: NOT
44956: IFFALSE 44960
// break ;
44958: GO 45059
// if not HasTask ( j ) then
44960: LD_VAR 0 3
44964: PPUSH
44965: CALL_OW 314
44969: NOT
44970: IFFALSE 45057
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44972: LD_VAR 0 3
44976: PPUSH
44977: LD_EXP 104
44981: PUSH
44982: LD_VAR 0 2
44986: ARRAY
44987: PUSH
44988: LD_INT 1
44990: ARRAY
44991: PUSH
44992: LD_INT 1
44994: ARRAY
44995: PPUSH
44996: LD_EXP 104
45000: PUSH
45001: LD_VAR 0 2
45005: ARRAY
45006: PUSH
45007: LD_INT 1
45009: ARRAY
45010: PUSH
45011: LD_INT 2
45013: ARRAY
45014: PPUSH
45015: LD_EXP 104
45019: PUSH
45020: LD_VAR 0 2
45024: ARRAY
45025: PUSH
45026: LD_INT 1
45028: ARRAY
45029: PUSH
45030: LD_INT 3
45032: ARRAY
45033: PPUSH
45034: LD_EXP 104
45038: PUSH
45039: LD_VAR 0 2
45043: ARRAY
45044: PUSH
45045: LD_INT 1
45047: ARRAY
45048: PUSH
45049: LD_INT 4
45051: ARRAY
45052: PPUSH
45053: CALL_OW 145
// end ;
45057: GO 44846
45059: POP
45060: POP
// end else
45061: GO 45205
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45063: LD_EXP 99
45067: PUSH
45068: LD_VAR 0 2
45072: ARRAY
45073: PPUSH
45074: LD_EXP 104
45078: PUSH
45079: LD_VAR 0 2
45083: ARRAY
45084: PUSH
45085: LD_INT 1
45087: ARRAY
45088: PUSH
45089: LD_INT 1
45091: ARRAY
45092: PPUSH
45093: LD_EXP 104
45097: PUSH
45098: LD_VAR 0 2
45102: ARRAY
45103: PUSH
45104: LD_INT 1
45106: ARRAY
45107: PUSH
45108: LD_INT 2
45110: ARRAY
45111: PPUSH
45112: LD_EXP 104
45116: PUSH
45117: LD_VAR 0 2
45121: ARRAY
45122: PUSH
45123: LD_INT 1
45125: ARRAY
45126: PUSH
45127: LD_INT 3
45129: ARRAY
45130: PPUSH
45131: LD_EXP 104
45135: PUSH
45136: LD_VAR 0 2
45140: ARRAY
45141: PUSH
45142: LD_INT 1
45144: ARRAY
45145: PUSH
45146: LD_INT 4
45148: ARRAY
45149: PPUSH
45150: CALL 77972 0 5
45154: NOT
45155: IFFALSE 45205
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45157: LD_ADDR_EXP 104
45161: PUSH
45162: LD_EXP 104
45166: PPUSH
45167: LD_VAR 0 2
45171: PPUSH
45172: LD_EXP 104
45176: PUSH
45177: LD_VAR 0 2
45181: ARRAY
45182: PPUSH
45183: LD_INT 1
45185: PPUSH
45186: LD_INT 1
45188: NEG
45189: PPUSH
45190: LD_INT 0
45192: PPUSH
45193: CALL 70639 0 4
45197: PPUSH
45198: CALL_OW 1
45202: ST_TO_ADDR
// continue ;
45203: GO 44081
// end ; end ; end ;
45205: GO 44081
45207: POP
45208: POP
// end ;
45209: LD_VAR 0 1
45213: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45214: LD_INT 0
45216: PPUSH
45217: PPUSH
45218: PPUSH
45219: PPUSH
45220: PPUSH
45221: PPUSH
// if not mc_bases then
45222: LD_EXP 99
45226: NOT
45227: IFFALSE 45231
// exit ;
45229: GO 45658
// for i = 1 to mc_bases do
45231: LD_ADDR_VAR 0 2
45235: PUSH
45236: DOUBLE
45237: LD_INT 1
45239: DEC
45240: ST_TO_ADDR
45241: LD_EXP 99
45245: PUSH
45246: FOR_TO
45247: IFFALSE 45656
// begin tmp := mc_build_upgrade [ i ] ;
45249: LD_ADDR_VAR 0 4
45253: PUSH
45254: LD_EXP 131
45258: PUSH
45259: LD_VAR 0 2
45263: ARRAY
45264: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45265: LD_ADDR_VAR 0 6
45269: PUSH
45270: LD_EXP 132
45274: PUSH
45275: LD_VAR 0 2
45279: ARRAY
45280: PPUSH
45281: LD_INT 2
45283: PUSH
45284: LD_INT 30
45286: PUSH
45287: LD_INT 6
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 30
45296: PUSH
45297: LD_INT 7
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: LIST
45308: PPUSH
45309: CALL_OW 72
45313: ST_TO_ADDR
// if not tmp and not lab then
45314: LD_VAR 0 4
45318: NOT
45319: PUSH
45320: LD_VAR 0 6
45324: NOT
45325: AND
45326: IFFALSE 45330
// continue ;
45328: GO 45246
// if tmp then
45330: LD_VAR 0 4
45334: IFFALSE 45454
// for j in tmp do
45336: LD_ADDR_VAR 0 3
45340: PUSH
45341: LD_VAR 0 4
45345: PUSH
45346: FOR_IN
45347: IFFALSE 45452
// begin if UpgradeCost ( j ) then
45349: LD_VAR 0 3
45353: PPUSH
45354: CALL 77632 0 1
45358: IFFALSE 45450
// begin ComUpgrade ( j ) ;
45360: LD_VAR 0 3
45364: PPUSH
45365: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45369: LD_ADDR_EXP 131
45373: PUSH
45374: LD_EXP 131
45378: PPUSH
45379: LD_VAR 0 2
45383: PPUSH
45384: LD_EXP 131
45388: PUSH
45389: LD_VAR 0 2
45393: ARRAY
45394: PUSH
45395: LD_VAR 0 3
45399: DIFF
45400: PPUSH
45401: CALL_OW 1
45405: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45406: LD_ADDR_EXP 106
45410: PUSH
45411: LD_EXP 106
45415: PPUSH
45416: LD_VAR 0 2
45420: PUSH
45421: LD_EXP 106
45425: PUSH
45426: LD_VAR 0 2
45430: ARRAY
45431: PUSH
45432: LD_INT 1
45434: PLUS
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: PPUSH
45440: LD_VAR 0 3
45444: PPUSH
45445: CALL 71221 0 3
45449: ST_TO_ADDR
// end ; end ;
45450: GO 45346
45452: POP
45453: POP
// if not lab or not mc_lab_upgrade [ i ] then
45454: LD_VAR 0 6
45458: NOT
45459: PUSH
45460: LD_EXP 133
45464: PUSH
45465: LD_VAR 0 2
45469: ARRAY
45470: NOT
45471: OR
45472: IFFALSE 45476
// continue ;
45474: GO 45246
// for j in lab do
45476: LD_ADDR_VAR 0 3
45480: PUSH
45481: LD_VAR 0 6
45485: PUSH
45486: FOR_IN
45487: IFFALSE 45652
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45489: LD_VAR 0 3
45493: PPUSH
45494: CALL_OW 266
45498: PUSH
45499: LD_INT 6
45501: PUSH
45502: LD_INT 7
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: IN
45509: PUSH
45510: LD_VAR 0 3
45514: PPUSH
45515: CALL_OW 461
45519: PUSH
45520: LD_INT 1
45522: NONEQUAL
45523: AND
45524: IFFALSE 45650
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45526: LD_VAR 0 3
45530: PPUSH
45531: LD_EXP 133
45535: PUSH
45536: LD_VAR 0 2
45540: ARRAY
45541: PUSH
45542: LD_INT 1
45544: ARRAY
45545: PPUSH
45546: CALL 77837 0 2
45550: IFFALSE 45650
// begin ComCancel ( j ) ;
45552: LD_VAR 0 3
45556: PPUSH
45557: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45561: LD_VAR 0 3
45565: PPUSH
45566: LD_EXP 133
45570: PUSH
45571: LD_VAR 0 2
45575: ARRAY
45576: PUSH
45577: LD_INT 1
45579: ARRAY
45580: PPUSH
45581: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45585: LD_VAR 0 3
45589: PUSH
45590: LD_EXP 106
45594: PUSH
45595: LD_VAR 0 2
45599: ARRAY
45600: IN
45601: NOT
45602: IFFALSE 45648
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45604: LD_ADDR_EXP 106
45608: PUSH
45609: LD_EXP 106
45613: PPUSH
45614: LD_VAR 0 2
45618: PUSH
45619: LD_EXP 106
45623: PUSH
45624: LD_VAR 0 2
45628: ARRAY
45629: PUSH
45630: LD_INT 1
45632: PLUS
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PPUSH
45638: LD_VAR 0 3
45642: PPUSH
45643: CALL 71221 0 3
45647: ST_TO_ADDR
// break ;
45648: GO 45652
// end ; end ; end ;
45650: GO 45486
45652: POP
45653: POP
// end ;
45654: GO 45246
45656: POP
45657: POP
// end ;
45658: LD_VAR 0 1
45662: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45663: LD_INT 0
45665: PPUSH
45666: PPUSH
45667: PPUSH
45668: PPUSH
45669: PPUSH
45670: PPUSH
45671: PPUSH
45672: PPUSH
45673: PPUSH
// if not mc_bases then
45674: LD_EXP 99
45678: NOT
45679: IFFALSE 45683
// exit ;
45681: GO 46088
// for i = 1 to mc_bases do
45683: LD_ADDR_VAR 0 2
45687: PUSH
45688: DOUBLE
45689: LD_INT 1
45691: DEC
45692: ST_TO_ADDR
45693: LD_EXP 99
45697: PUSH
45698: FOR_TO
45699: IFFALSE 46086
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45701: LD_EXP 107
45705: PUSH
45706: LD_VAR 0 2
45710: ARRAY
45711: NOT
45712: PUSH
45713: LD_EXP 99
45717: PUSH
45718: LD_VAR 0 2
45722: ARRAY
45723: PPUSH
45724: LD_INT 30
45726: PUSH
45727: LD_INT 3
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PPUSH
45734: CALL_OW 72
45738: NOT
45739: OR
45740: IFFALSE 45744
// continue ;
45742: GO 45698
// busy := false ;
45744: LD_ADDR_VAR 0 8
45748: PUSH
45749: LD_INT 0
45751: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45752: LD_ADDR_VAR 0 4
45756: PUSH
45757: LD_EXP 99
45761: PUSH
45762: LD_VAR 0 2
45766: ARRAY
45767: PPUSH
45768: LD_INT 30
45770: PUSH
45771: LD_INT 3
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: PPUSH
45778: CALL_OW 72
45782: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45783: LD_ADDR_VAR 0 6
45787: PUSH
45788: LD_EXP 107
45792: PUSH
45793: LD_VAR 0 2
45797: ARRAY
45798: PPUSH
45799: LD_INT 2
45801: PUSH
45802: LD_INT 30
45804: PUSH
45805: LD_INT 32
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PUSH
45812: LD_INT 30
45814: PUSH
45815: LD_INT 33
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: LIST
45826: PPUSH
45827: CALL_OW 72
45831: ST_TO_ADDR
// if not t then
45832: LD_VAR 0 6
45836: NOT
45837: IFFALSE 45841
// continue ;
45839: GO 45698
// for j in tmp do
45841: LD_ADDR_VAR 0 3
45845: PUSH
45846: LD_VAR 0 4
45850: PUSH
45851: FOR_IN
45852: IFFALSE 45882
// if not BuildingStatus ( j ) = bs_idle then
45854: LD_VAR 0 3
45858: PPUSH
45859: CALL_OW 461
45863: PUSH
45864: LD_INT 2
45866: EQUAL
45867: NOT
45868: IFFALSE 45880
// begin busy := true ;
45870: LD_ADDR_VAR 0 8
45874: PUSH
45875: LD_INT 1
45877: ST_TO_ADDR
// break ;
45878: GO 45882
// end ;
45880: GO 45851
45882: POP
45883: POP
// if busy then
45884: LD_VAR 0 8
45888: IFFALSE 45892
// continue ;
45890: GO 45698
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45892: LD_ADDR_VAR 0 7
45896: PUSH
45897: LD_VAR 0 6
45901: PPUSH
45902: LD_INT 35
45904: PUSH
45905: LD_INT 0
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: PPUSH
45912: CALL_OW 72
45916: ST_TO_ADDR
// if tw then
45917: LD_VAR 0 7
45921: IFFALSE 45998
// begin tw := tw [ 1 ] ;
45923: LD_ADDR_VAR 0 7
45927: PUSH
45928: LD_VAR 0 7
45932: PUSH
45933: LD_INT 1
45935: ARRAY
45936: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45937: LD_ADDR_VAR 0 9
45941: PUSH
45942: LD_VAR 0 7
45946: PPUSH
45947: LD_EXP 124
45951: PUSH
45952: LD_VAR 0 2
45956: ARRAY
45957: PPUSH
45958: CALL 76191 0 2
45962: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45963: LD_EXP 138
45967: PUSH
45968: LD_VAR 0 2
45972: ARRAY
45973: IFFALSE 45996
// if not weapon in mc_allowed_tower_weapons [ i ] then
45975: LD_VAR 0 9
45979: PUSH
45980: LD_EXP 138
45984: PUSH
45985: LD_VAR 0 2
45989: ARRAY
45990: IN
45991: NOT
45992: IFFALSE 45996
// continue ;
45994: GO 45698
// end else
45996: GO 46061
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45998: LD_ADDR_VAR 0 5
46002: PUSH
46003: LD_EXP 107
46007: PUSH
46008: LD_VAR 0 2
46012: ARRAY
46013: PPUSH
46014: LD_VAR 0 4
46018: PPUSH
46019: CALL 106392 0 2
46023: ST_TO_ADDR
// if not tmp2 then
46024: LD_VAR 0 5
46028: NOT
46029: IFFALSE 46033
// continue ;
46031: GO 45698
// tw := tmp2 [ 1 ] ;
46033: LD_ADDR_VAR 0 7
46037: PUSH
46038: LD_VAR 0 5
46042: PUSH
46043: LD_INT 1
46045: ARRAY
46046: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46047: LD_ADDR_VAR 0 9
46051: PUSH
46052: LD_VAR 0 5
46056: PUSH
46057: LD_INT 2
46059: ARRAY
46060: ST_TO_ADDR
// end ; if not weapon then
46061: LD_VAR 0 9
46065: NOT
46066: IFFALSE 46070
// continue ;
46068: GO 45698
// ComPlaceWeapon ( tw , weapon ) ;
46070: LD_VAR 0 7
46074: PPUSH
46075: LD_VAR 0 9
46079: PPUSH
46080: CALL_OW 148
// end ;
46084: GO 45698
46086: POP
46087: POP
// end ;
46088: LD_VAR 0 1
46092: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46093: LD_INT 0
46095: PPUSH
46096: PPUSH
46097: PPUSH
46098: PPUSH
46099: PPUSH
46100: PPUSH
// if not mc_bases then
46101: LD_EXP 99
46105: NOT
46106: IFFALSE 46110
// exit ;
46108: GO 47122
// for i = 1 to mc_bases do
46110: LD_ADDR_VAR 0 2
46114: PUSH
46115: DOUBLE
46116: LD_INT 1
46118: DEC
46119: ST_TO_ADDR
46120: LD_EXP 99
46124: PUSH
46125: FOR_TO
46126: IFFALSE 47120
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46128: LD_EXP 112
46132: PUSH
46133: LD_VAR 0 2
46137: ARRAY
46138: NOT
46139: PUSH
46140: LD_EXP 112
46144: PUSH
46145: LD_VAR 0 2
46149: ARRAY
46150: PUSH
46151: LD_EXP 113
46155: PUSH
46156: LD_VAR 0 2
46160: ARRAY
46161: EQUAL
46162: OR
46163: IFFALSE 46167
// continue ;
46165: GO 46125
// if mc_miners [ i ] then
46167: LD_EXP 113
46171: PUSH
46172: LD_VAR 0 2
46176: ARRAY
46177: IFFALSE 46807
// begin k := 1 ;
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: LD_INT 1
46186: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46187: LD_ADDR_VAR 0 3
46191: PUSH
46192: DOUBLE
46193: LD_EXP 113
46197: PUSH
46198: LD_VAR 0 2
46202: ARRAY
46203: INC
46204: ST_TO_ADDR
46205: LD_INT 1
46207: PUSH
46208: FOR_DOWNTO
46209: IFFALSE 46805
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46211: LD_EXP 113
46215: PUSH
46216: LD_VAR 0 2
46220: ARRAY
46221: PUSH
46222: LD_VAR 0 3
46226: ARRAY
46227: PPUSH
46228: CALL_OW 301
46232: PUSH
46233: LD_EXP 113
46237: PUSH
46238: LD_VAR 0 2
46242: ARRAY
46243: PUSH
46244: LD_VAR 0 3
46248: ARRAY
46249: PPUSH
46250: CALL_OW 257
46254: PUSH
46255: LD_INT 1
46257: NONEQUAL
46258: OR
46259: IFFALSE 46322
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46261: LD_ADDR_VAR 0 5
46265: PUSH
46266: LD_EXP 113
46270: PUSH
46271: LD_VAR 0 2
46275: ARRAY
46276: PUSH
46277: LD_EXP 113
46281: PUSH
46282: LD_VAR 0 2
46286: ARRAY
46287: PUSH
46288: LD_VAR 0 3
46292: ARRAY
46293: DIFF
46294: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46295: LD_ADDR_EXP 113
46299: PUSH
46300: LD_EXP 113
46304: PPUSH
46305: LD_VAR 0 2
46309: PPUSH
46310: LD_VAR 0 5
46314: PPUSH
46315: CALL_OW 1
46319: ST_TO_ADDR
// continue ;
46320: GO 46208
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46322: LD_EXP 113
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_VAR 0 3
46337: ARRAY
46338: PPUSH
46339: CALL 71157 0 1
46343: PUSH
46344: LD_EXP 113
46348: PUSH
46349: LD_VAR 0 2
46353: ARRAY
46354: PUSH
46355: LD_VAR 0 3
46359: ARRAY
46360: PPUSH
46361: CALL_OW 255
46365: PPUSH
46366: LD_EXP 112
46370: PUSH
46371: LD_VAR 0 2
46375: ARRAY
46376: PUSH
46377: LD_VAR 0 4
46381: ARRAY
46382: PUSH
46383: LD_INT 1
46385: ARRAY
46386: PPUSH
46387: LD_EXP 112
46391: PUSH
46392: LD_VAR 0 2
46396: ARRAY
46397: PUSH
46398: LD_VAR 0 4
46402: ARRAY
46403: PUSH
46404: LD_INT 2
46406: ARRAY
46407: PPUSH
46408: LD_INT 15
46410: PPUSH
46411: CALL 72117 0 4
46415: PUSH
46416: LD_INT 4
46418: ARRAY
46419: PUSH
46420: LD_EXP 113
46424: PUSH
46425: LD_VAR 0 2
46429: ARRAY
46430: PUSH
46431: LD_VAR 0 3
46435: ARRAY
46436: PPUSH
46437: LD_INT 10
46439: PPUSH
46440: CALL 73814 0 2
46444: PUSH
46445: LD_INT 4
46447: ARRAY
46448: OR
46449: AND
46450: IFFALSE 46473
// ComStop ( mc_miners [ i ] [ j ] ) ;
46452: LD_EXP 113
46456: PUSH
46457: LD_VAR 0 2
46461: ARRAY
46462: PUSH
46463: LD_VAR 0 3
46467: ARRAY
46468: PPUSH
46469: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46473: LD_EXP 113
46477: PUSH
46478: LD_VAR 0 2
46482: ARRAY
46483: PUSH
46484: LD_VAR 0 3
46488: ARRAY
46489: PPUSH
46490: CALL_OW 257
46494: PUSH
46495: LD_INT 1
46497: EQUAL
46498: PUSH
46499: LD_EXP 113
46503: PUSH
46504: LD_VAR 0 2
46508: ARRAY
46509: PUSH
46510: LD_VAR 0 3
46514: ARRAY
46515: PPUSH
46516: CALL_OW 459
46520: NOT
46521: AND
46522: PUSH
46523: LD_EXP 113
46527: PUSH
46528: LD_VAR 0 2
46532: ARRAY
46533: PUSH
46534: LD_VAR 0 3
46538: ARRAY
46539: PPUSH
46540: CALL_OW 255
46544: PPUSH
46545: LD_EXP 112
46549: PUSH
46550: LD_VAR 0 2
46554: ARRAY
46555: PUSH
46556: LD_VAR 0 4
46560: ARRAY
46561: PUSH
46562: LD_INT 1
46564: ARRAY
46565: PPUSH
46566: LD_EXP 112
46570: PUSH
46571: LD_VAR 0 2
46575: ARRAY
46576: PUSH
46577: LD_VAR 0 4
46581: ARRAY
46582: PUSH
46583: LD_INT 2
46585: ARRAY
46586: PPUSH
46587: LD_INT 15
46589: PPUSH
46590: CALL 72117 0 4
46594: PUSH
46595: LD_INT 4
46597: ARRAY
46598: PUSH
46599: LD_INT 0
46601: EQUAL
46602: AND
46603: PUSH
46604: LD_EXP 113
46608: PUSH
46609: LD_VAR 0 2
46613: ARRAY
46614: PUSH
46615: LD_VAR 0 3
46619: ARRAY
46620: PPUSH
46621: CALL_OW 314
46625: NOT
46626: AND
46627: IFFALSE 46803
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46629: LD_EXP 113
46633: PUSH
46634: LD_VAR 0 2
46638: ARRAY
46639: PUSH
46640: LD_VAR 0 3
46644: ARRAY
46645: PPUSH
46646: CALL_OW 310
46650: IFFALSE 46673
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46652: LD_EXP 113
46656: PUSH
46657: LD_VAR 0 2
46661: ARRAY
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: PPUSH
46669: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46673: LD_EXP 113
46677: PUSH
46678: LD_VAR 0 2
46682: ARRAY
46683: PUSH
46684: LD_VAR 0 3
46688: ARRAY
46689: PPUSH
46690: CALL_OW 314
46694: NOT
46695: IFFALSE 46763
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46697: LD_EXP 113
46701: PUSH
46702: LD_VAR 0 2
46706: ARRAY
46707: PUSH
46708: LD_VAR 0 3
46712: ARRAY
46713: PPUSH
46714: LD_EXP 112
46718: PUSH
46719: LD_VAR 0 2
46723: ARRAY
46724: PUSH
46725: LD_VAR 0 4
46729: ARRAY
46730: PUSH
46731: LD_INT 1
46733: ARRAY
46734: PPUSH
46735: LD_EXP 112
46739: PUSH
46740: LD_VAR 0 2
46744: ARRAY
46745: PUSH
46746: LD_VAR 0 4
46750: ARRAY
46751: PUSH
46752: LD_INT 2
46754: ARRAY
46755: PPUSH
46756: LD_INT 0
46758: PPUSH
46759: CALL_OW 193
// k := k + 1 ;
46763: LD_ADDR_VAR 0 4
46767: PUSH
46768: LD_VAR 0 4
46772: PUSH
46773: LD_INT 1
46775: PLUS
46776: ST_TO_ADDR
// if k > mc_mines [ i ] then
46777: LD_VAR 0 4
46781: PUSH
46782: LD_EXP 112
46786: PUSH
46787: LD_VAR 0 2
46791: ARRAY
46792: GREATER
46793: IFFALSE 46803
// k := 1 ;
46795: LD_ADDR_VAR 0 4
46799: PUSH
46800: LD_INT 1
46802: ST_TO_ADDR
// end ; end ;
46803: GO 46208
46805: POP
46806: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46807: LD_ADDR_VAR 0 5
46811: PUSH
46812: LD_EXP 99
46816: PUSH
46817: LD_VAR 0 2
46821: ARRAY
46822: PPUSH
46823: LD_INT 2
46825: PUSH
46826: LD_INT 30
46828: PUSH
46829: LD_INT 4
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 30
46838: PUSH
46839: LD_INT 5
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: LD_INT 30
46848: PUSH
46849: LD_INT 32
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: PPUSH
46862: CALL_OW 72
46866: ST_TO_ADDR
// if not tmp then
46867: LD_VAR 0 5
46871: NOT
46872: IFFALSE 46876
// continue ;
46874: GO 46125
// list := [ ] ;
46876: LD_ADDR_VAR 0 6
46880: PUSH
46881: EMPTY
46882: ST_TO_ADDR
// for j in tmp do
46883: LD_ADDR_VAR 0 3
46887: PUSH
46888: LD_VAR 0 5
46892: PUSH
46893: FOR_IN
46894: IFFALSE 46963
// begin for k in UnitsInside ( j ) do
46896: LD_ADDR_VAR 0 4
46900: PUSH
46901: LD_VAR 0 3
46905: PPUSH
46906: CALL_OW 313
46910: PUSH
46911: FOR_IN
46912: IFFALSE 46959
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46914: LD_VAR 0 4
46918: PPUSH
46919: CALL_OW 257
46923: PUSH
46924: LD_INT 1
46926: EQUAL
46927: PUSH
46928: LD_VAR 0 4
46932: PPUSH
46933: CALL_OW 459
46937: NOT
46938: AND
46939: IFFALSE 46957
// list := list ^ k ;
46941: LD_ADDR_VAR 0 6
46945: PUSH
46946: LD_VAR 0 6
46950: PUSH
46951: LD_VAR 0 4
46955: ADD
46956: ST_TO_ADDR
46957: GO 46911
46959: POP
46960: POP
// end ;
46961: GO 46893
46963: POP
46964: POP
// list := list diff mc_miners [ i ] ;
46965: LD_ADDR_VAR 0 6
46969: PUSH
46970: LD_VAR 0 6
46974: PUSH
46975: LD_EXP 113
46979: PUSH
46980: LD_VAR 0 2
46984: ARRAY
46985: DIFF
46986: ST_TO_ADDR
// if not list then
46987: LD_VAR 0 6
46991: NOT
46992: IFFALSE 46996
// continue ;
46994: GO 46125
// k := mc_mines [ i ] - mc_miners [ i ] ;
46996: LD_ADDR_VAR 0 4
47000: PUSH
47001: LD_EXP 112
47005: PUSH
47006: LD_VAR 0 2
47010: ARRAY
47011: PUSH
47012: LD_EXP 113
47016: PUSH
47017: LD_VAR 0 2
47021: ARRAY
47022: MINUS
47023: ST_TO_ADDR
// if k > list then
47024: LD_VAR 0 4
47028: PUSH
47029: LD_VAR 0 6
47033: GREATER
47034: IFFALSE 47046
// k := list ;
47036: LD_ADDR_VAR 0 4
47040: PUSH
47041: LD_VAR 0 6
47045: ST_TO_ADDR
// for j = 1 to k do
47046: LD_ADDR_VAR 0 3
47050: PUSH
47051: DOUBLE
47052: LD_INT 1
47054: DEC
47055: ST_TO_ADDR
47056: LD_VAR 0 4
47060: PUSH
47061: FOR_TO
47062: IFFALSE 47116
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47064: LD_ADDR_EXP 113
47068: PUSH
47069: LD_EXP 113
47073: PPUSH
47074: LD_VAR 0 2
47078: PUSH
47079: LD_EXP 113
47083: PUSH
47084: LD_VAR 0 2
47088: ARRAY
47089: PUSH
47090: LD_INT 1
47092: PLUS
47093: PUSH
47094: EMPTY
47095: LIST
47096: LIST
47097: PPUSH
47098: LD_VAR 0 6
47102: PUSH
47103: LD_VAR 0 3
47107: ARRAY
47108: PPUSH
47109: CALL 71221 0 3
47113: ST_TO_ADDR
47114: GO 47061
47116: POP
47117: POP
// end ;
47118: GO 46125
47120: POP
47121: POP
// end ;
47122: LD_VAR 0 1
47126: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47127: LD_INT 0
47129: PPUSH
47130: PPUSH
47131: PPUSH
47132: PPUSH
47133: PPUSH
47134: PPUSH
47135: PPUSH
47136: PPUSH
47137: PPUSH
47138: PPUSH
// if not mc_bases then
47139: LD_EXP 99
47143: NOT
47144: IFFALSE 47148
// exit ;
47146: GO 48898
// for i = 1 to mc_bases do
47148: LD_ADDR_VAR 0 2
47152: PUSH
47153: DOUBLE
47154: LD_INT 1
47156: DEC
47157: ST_TO_ADDR
47158: LD_EXP 99
47162: PUSH
47163: FOR_TO
47164: IFFALSE 48896
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47166: LD_EXP 99
47170: PUSH
47171: LD_VAR 0 2
47175: ARRAY
47176: NOT
47177: PUSH
47178: LD_EXP 106
47182: PUSH
47183: LD_VAR 0 2
47187: ARRAY
47188: OR
47189: IFFALSE 47193
// continue ;
47191: GO 47163
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47193: LD_EXP 115
47197: PUSH
47198: LD_VAR 0 2
47202: ARRAY
47203: NOT
47204: PUSH
47205: LD_EXP 116
47209: PUSH
47210: LD_VAR 0 2
47214: ARRAY
47215: AND
47216: IFFALSE 47254
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47218: LD_ADDR_EXP 116
47222: PUSH
47223: LD_EXP 116
47227: PPUSH
47228: LD_VAR 0 2
47232: PPUSH
47233: EMPTY
47234: PPUSH
47235: CALL_OW 1
47239: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47240: LD_VAR 0 2
47244: PPUSH
47245: LD_INT 107
47247: PPUSH
47248: CALL 38008 0 2
// continue ;
47252: GO 47163
// end ; target := [ ] ;
47254: LD_ADDR_VAR 0 6
47258: PUSH
47259: EMPTY
47260: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47261: LD_ADDR_VAR 0 3
47265: PUSH
47266: DOUBLE
47267: LD_EXP 115
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: INC
47278: ST_TO_ADDR
47279: LD_INT 1
47281: PUSH
47282: FOR_DOWNTO
47283: IFFALSE 47543
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47285: LD_EXP 115
47289: PUSH
47290: LD_VAR 0 2
47294: ARRAY
47295: PUSH
47296: LD_VAR 0 3
47300: ARRAY
47301: PUSH
47302: LD_INT 2
47304: ARRAY
47305: PPUSH
47306: LD_EXP 115
47310: PUSH
47311: LD_VAR 0 2
47315: ARRAY
47316: PUSH
47317: LD_VAR 0 3
47321: ARRAY
47322: PUSH
47323: LD_INT 3
47325: ARRAY
47326: PPUSH
47327: CALL_OW 488
47331: PUSH
47332: LD_EXP 115
47336: PUSH
47337: LD_VAR 0 2
47341: ARRAY
47342: PUSH
47343: LD_VAR 0 3
47347: ARRAY
47348: PUSH
47349: LD_INT 2
47351: ARRAY
47352: PPUSH
47353: LD_EXP 115
47357: PUSH
47358: LD_VAR 0 2
47362: ARRAY
47363: PUSH
47364: LD_VAR 0 3
47368: ARRAY
47369: PUSH
47370: LD_INT 3
47372: ARRAY
47373: PPUSH
47374: CALL_OW 284
47378: PUSH
47379: LD_INT 0
47381: EQUAL
47382: AND
47383: IFFALSE 47438
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47385: LD_ADDR_VAR 0 5
47389: PUSH
47390: LD_EXP 115
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PPUSH
47401: LD_VAR 0 3
47405: PPUSH
47406: CALL_OW 3
47410: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47411: LD_ADDR_EXP 115
47415: PUSH
47416: LD_EXP 115
47420: PPUSH
47421: LD_VAR 0 2
47425: PPUSH
47426: LD_VAR 0 5
47430: PPUSH
47431: CALL_OW 1
47435: ST_TO_ADDR
// continue ;
47436: GO 47282
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47438: LD_EXP 99
47442: PUSH
47443: LD_VAR 0 2
47447: ARRAY
47448: PUSH
47449: LD_INT 1
47451: ARRAY
47452: PPUSH
47453: CALL_OW 255
47457: PPUSH
47458: LD_EXP 115
47462: PUSH
47463: LD_VAR 0 2
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 3
47473: ARRAY
47474: PUSH
47475: LD_INT 2
47477: ARRAY
47478: PPUSH
47479: LD_EXP 115
47483: PUSH
47484: LD_VAR 0 2
47488: ARRAY
47489: PUSH
47490: LD_VAR 0 3
47494: ARRAY
47495: PUSH
47496: LD_INT 3
47498: ARRAY
47499: PPUSH
47500: LD_INT 30
47502: PPUSH
47503: CALL 72117 0 4
47507: PUSH
47508: LD_INT 4
47510: ARRAY
47511: PUSH
47512: LD_INT 0
47514: EQUAL
47515: IFFALSE 47541
// begin target := mc_crates [ i ] [ j ] ;
47517: LD_ADDR_VAR 0 6
47521: PUSH
47522: LD_EXP 115
47526: PUSH
47527: LD_VAR 0 2
47531: ARRAY
47532: PUSH
47533: LD_VAR 0 3
47537: ARRAY
47538: ST_TO_ADDR
// break ;
47539: GO 47543
// end ; end ;
47541: GO 47282
47543: POP
47544: POP
// if not target then
47545: LD_VAR 0 6
47549: NOT
47550: IFFALSE 47554
// continue ;
47552: GO 47163
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47554: LD_ADDR_VAR 0 7
47558: PUSH
47559: LD_EXP 118
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: PPUSH
47570: LD_INT 2
47572: PUSH
47573: LD_INT 3
47575: PUSH
47576: LD_INT 58
47578: PUSH
47579: EMPTY
47580: LIST
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: LD_INT 61
47588: PUSH
47589: EMPTY
47590: LIST
47591: PUSH
47592: LD_INT 33
47594: PUSH
47595: LD_INT 5
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: PUSH
47602: LD_INT 33
47604: PUSH
47605: LD_INT 3
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: EMPTY
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: PUSH
47619: LD_INT 2
47621: PUSH
47622: LD_INT 34
47624: PUSH
47625: LD_INT 32
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PUSH
47632: LD_INT 34
47634: PUSH
47635: LD_INT 51
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 34
47644: PUSH
47645: LD_INT 12
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PPUSH
47662: CALL_OW 72
47666: ST_TO_ADDR
// if not cargo then
47667: LD_VAR 0 7
47671: NOT
47672: IFFALSE 48315
// begin if mc_crates_collector [ i ] < 5 then
47674: LD_EXP 116
47678: PUSH
47679: LD_VAR 0 2
47683: ARRAY
47684: PUSH
47685: LD_INT 5
47687: LESS
47688: IFFALSE 48054
// begin if mc_ape [ i ] then
47690: LD_EXP 128
47694: PUSH
47695: LD_VAR 0 2
47699: ARRAY
47700: IFFALSE 47747
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47702: LD_ADDR_VAR 0 5
47706: PUSH
47707: LD_EXP 128
47711: PUSH
47712: LD_VAR 0 2
47716: ARRAY
47717: PPUSH
47718: LD_INT 25
47720: PUSH
47721: LD_INT 16
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PUSH
47728: LD_INT 24
47730: PUSH
47731: LD_INT 750
47733: PUSH
47734: EMPTY
47735: LIST
47736: LIST
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PPUSH
47742: CALL_OW 72
47746: ST_TO_ADDR
// if not tmp then
47747: LD_VAR 0 5
47751: NOT
47752: IFFALSE 47799
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47754: LD_ADDR_VAR 0 5
47758: PUSH
47759: LD_EXP 99
47763: PUSH
47764: LD_VAR 0 2
47768: ARRAY
47769: PPUSH
47770: LD_INT 25
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: LD_INT 24
47782: PUSH
47783: LD_INT 750
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PPUSH
47794: CALL_OW 72
47798: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47799: LD_EXP 128
47803: PUSH
47804: LD_VAR 0 2
47808: ARRAY
47809: PUSH
47810: LD_EXP 99
47814: PUSH
47815: LD_VAR 0 2
47819: ARRAY
47820: PPUSH
47821: LD_INT 25
47823: PUSH
47824: LD_INT 2
47826: PUSH
47827: EMPTY
47828: LIST
47829: LIST
47830: PUSH
47831: LD_INT 24
47833: PUSH
47834: LD_INT 750
47836: PUSH
47837: EMPTY
47838: LIST
47839: LIST
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PPUSH
47845: CALL_OW 72
47849: AND
47850: PUSH
47851: LD_VAR 0 5
47855: PUSH
47856: LD_INT 5
47858: LESS
47859: AND
47860: IFFALSE 47942
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47862: LD_ADDR_VAR 0 3
47866: PUSH
47867: LD_EXP 99
47871: PUSH
47872: LD_VAR 0 2
47876: ARRAY
47877: PPUSH
47878: LD_INT 25
47880: PUSH
47881: LD_INT 2
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_INT 24
47890: PUSH
47891: LD_INT 750
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: EMPTY
47899: LIST
47900: LIST
47901: PPUSH
47902: CALL_OW 72
47906: PUSH
47907: FOR_IN
47908: IFFALSE 47940
// begin tmp := tmp union j ;
47910: LD_ADDR_VAR 0 5
47914: PUSH
47915: LD_VAR 0 5
47919: PUSH
47920: LD_VAR 0 3
47924: UNION
47925: ST_TO_ADDR
// if tmp >= 5 then
47926: LD_VAR 0 5
47930: PUSH
47931: LD_INT 5
47933: GREATEREQUAL
47934: IFFALSE 47938
// break ;
47936: GO 47940
// end ;
47938: GO 47907
47940: POP
47941: POP
// end ; if not tmp then
47942: LD_VAR 0 5
47946: NOT
47947: IFFALSE 47951
// continue ;
47949: GO 47163
// for j in tmp do
47951: LD_ADDR_VAR 0 3
47955: PUSH
47956: LD_VAR 0 5
47960: PUSH
47961: FOR_IN
47962: IFFALSE 48052
// if not GetTag ( j ) then
47964: LD_VAR 0 3
47968: PPUSH
47969: CALL_OW 110
47973: NOT
47974: IFFALSE 48050
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47976: LD_ADDR_EXP 116
47980: PUSH
47981: LD_EXP 116
47985: PPUSH
47986: LD_VAR 0 2
47990: PUSH
47991: LD_EXP 116
47995: PUSH
47996: LD_VAR 0 2
48000: ARRAY
48001: PUSH
48002: LD_INT 1
48004: PLUS
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PPUSH
48010: LD_VAR 0 3
48014: PPUSH
48015: CALL 71221 0 3
48019: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48020: LD_VAR 0 3
48024: PPUSH
48025: LD_INT 107
48027: PPUSH
48028: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48032: LD_EXP 116
48036: PUSH
48037: LD_VAR 0 2
48041: ARRAY
48042: PUSH
48043: LD_INT 5
48045: GREATEREQUAL
48046: IFFALSE 48050
// break ;
48048: GO 48052
// end ;
48050: GO 47961
48052: POP
48053: POP
// end ; if mc_crates_collector [ i ] and target then
48054: LD_EXP 116
48058: PUSH
48059: LD_VAR 0 2
48063: ARRAY
48064: PUSH
48065: LD_VAR 0 6
48069: AND
48070: IFFALSE 48313
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48072: LD_EXP 116
48076: PUSH
48077: LD_VAR 0 2
48081: ARRAY
48082: PUSH
48083: LD_VAR 0 6
48087: PUSH
48088: LD_INT 1
48090: ARRAY
48091: LESS
48092: IFFALSE 48112
// tmp := mc_crates_collector [ i ] else
48094: LD_ADDR_VAR 0 5
48098: PUSH
48099: LD_EXP 116
48103: PUSH
48104: LD_VAR 0 2
48108: ARRAY
48109: ST_TO_ADDR
48110: GO 48126
// tmp := target [ 1 ] ;
48112: LD_ADDR_VAR 0 5
48116: PUSH
48117: LD_VAR 0 6
48121: PUSH
48122: LD_INT 1
48124: ARRAY
48125: ST_TO_ADDR
// k := 0 ;
48126: LD_ADDR_VAR 0 4
48130: PUSH
48131: LD_INT 0
48133: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48134: LD_ADDR_VAR 0 3
48138: PUSH
48139: LD_EXP 116
48143: PUSH
48144: LD_VAR 0 2
48148: ARRAY
48149: PUSH
48150: FOR_IN
48151: IFFALSE 48311
// begin k := k + 1 ;
48153: LD_ADDR_VAR 0 4
48157: PUSH
48158: LD_VAR 0 4
48162: PUSH
48163: LD_INT 1
48165: PLUS
48166: ST_TO_ADDR
// if k > tmp then
48167: LD_VAR 0 4
48171: PUSH
48172: LD_VAR 0 5
48176: GREATER
48177: IFFALSE 48181
// break ;
48179: GO 48311
// if not GetClass ( j ) in [ 2 , 16 ] then
48181: LD_VAR 0 3
48185: PPUSH
48186: CALL_OW 257
48190: PUSH
48191: LD_INT 2
48193: PUSH
48194: LD_INT 16
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: IN
48201: NOT
48202: IFFALSE 48255
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48204: LD_ADDR_EXP 116
48208: PUSH
48209: LD_EXP 116
48213: PPUSH
48214: LD_VAR 0 2
48218: PPUSH
48219: LD_EXP 116
48223: PUSH
48224: LD_VAR 0 2
48228: ARRAY
48229: PUSH
48230: LD_VAR 0 3
48234: DIFF
48235: PPUSH
48236: CALL_OW 1
48240: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48241: LD_VAR 0 3
48245: PPUSH
48246: LD_INT 0
48248: PPUSH
48249: CALL_OW 109
// continue ;
48253: GO 48150
// end ; if IsInUnit ( j ) then
48255: LD_VAR 0 3
48259: PPUSH
48260: CALL_OW 310
48264: IFFALSE 48275
// ComExitBuilding ( j ) ;
48266: LD_VAR 0 3
48270: PPUSH
48271: CALL_OW 122
// wait ( 3 ) ;
48275: LD_INT 3
48277: PPUSH
48278: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48282: LD_VAR 0 3
48286: PPUSH
48287: LD_VAR 0 6
48291: PUSH
48292: LD_INT 2
48294: ARRAY
48295: PPUSH
48296: LD_VAR 0 6
48300: PUSH
48301: LD_INT 3
48303: ARRAY
48304: PPUSH
48305: CALL_OW 117
// end ;
48309: GO 48150
48311: POP
48312: POP
// end ; end else
48313: GO 48894
// begin for j in cargo do
48315: LD_ADDR_VAR 0 3
48319: PUSH
48320: LD_VAR 0 7
48324: PUSH
48325: FOR_IN
48326: IFFALSE 48892
// begin if GetTag ( j ) <> 0 then
48328: LD_VAR 0 3
48332: PPUSH
48333: CALL_OW 110
48337: PUSH
48338: LD_INT 0
48340: NONEQUAL
48341: IFFALSE 48345
// continue ;
48343: GO 48325
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48345: LD_VAR 0 3
48349: PPUSH
48350: CALL_OW 256
48354: PUSH
48355: LD_INT 1000
48357: LESS
48358: PUSH
48359: LD_VAR 0 3
48363: PPUSH
48364: LD_EXP 123
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: PPUSH
48375: CALL_OW 308
48379: NOT
48380: AND
48381: IFFALSE 48403
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48383: LD_VAR 0 3
48387: PPUSH
48388: LD_EXP 123
48392: PUSH
48393: LD_VAR 0 2
48397: ARRAY
48398: PPUSH
48399: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48403: LD_VAR 0 3
48407: PPUSH
48408: CALL_OW 256
48412: PUSH
48413: LD_INT 1000
48415: LESS
48416: PUSH
48417: LD_VAR 0 3
48421: PPUSH
48422: LD_EXP 123
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PPUSH
48433: CALL_OW 308
48437: AND
48438: IFFALSE 48442
// continue ;
48440: GO 48325
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48442: LD_VAR 0 3
48446: PPUSH
48447: CALL_OW 262
48451: PUSH
48452: LD_INT 2
48454: EQUAL
48455: PUSH
48456: LD_VAR 0 3
48460: PPUSH
48461: CALL_OW 261
48465: PUSH
48466: LD_INT 15
48468: LESS
48469: AND
48470: IFFALSE 48474
// continue ;
48472: GO 48325
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48474: LD_VAR 0 3
48478: PPUSH
48479: CALL_OW 262
48483: PUSH
48484: LD_INT 1
48486: EQUAL
48487: PUSH
48488: LD_VAR 0 3
48492: PPUSH
48493: CALL_OW 261
48497: PUSH
48498: LD_INT 10
48500: LESS
48501: AND
48502: IFFALSE 48831
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48504: LD_ADDR_VAR 0 8
48508: PUSH
48509: LD_EXP 99
48513: PUSH
48514: LD_VAR 0 2
48518: ARRAY
48519: PPUSH
48520: LD_INT 2
48522: PUSH
48523: LD_INT 30
48525: PUSH
48526: LD_INT 0
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PUSH
48533: LD_INT 30
48535: PUSH
48536: LD_INT 1
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: EMPTY
48544: LIST
48545: LIST
48546: LIST
48547: PPUSH
48548: CALL_OW 72
48552: ST_TO_ADDR
// if not depot then
48553: LD_VAR 0 8
48557: NOT
48558: IFFALSE 48562
// continue ;
48560: GO 48325
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48562: LD_VAR 0 3
48566: PPUSH
48567: LD_VAR 0 8
48571: PPUSH
48572: LD_VAR 0 3
48576: PPUSH
48577: CALL_OW 74
48581: PPUSH
48582: CALL_OW 296
48586: PUSH
48587: LD_INT 6
48589: LESS
48590: IFFALSE 48606
// SetFuel ( j , 100 ) else
48592: LD_VAR 0 3
48596: PPUSH
48597: LD_INT 100
48599: PPUSH
48600: CALL_OW 240
48604: GO 48831
// if GetFuel ( j ) = 0 then
48606: LD_VAR 0 3
48610: PPUSH
48611: CALL_OW 261
48615: PUSH
48616: LD_INT 0
48618: EQUAL
48619: IFFALSE 48831
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48621: LD_ADDR_EXP 118
48625: PUSH
48626: LD_EXP 118
48630: PPUSH
48631: LD_VAR 0 2
48635: PPUSH
48636: LD_EXP 118
48640: PUSH
48641: LD_VAR 0 2
48645: ARRAY
48646: PUSH
48647: LD_VAR 0 3
48651: DIFF
48652: PPUSH
48653: CALL_OW 1
48657: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48658: LD_VAR 0 3
48662: PPUSH
48663: CALL_OW 263
48667: PUSH
48668: LD_INT 1
48670: EQUAL
48671: IFFALSE 48687
// ComExitVehicle ( IsInUnit ( j ) ) ;
48673: LD_VAR 0 3
48677: PPUSH
48678: CALL_OW 310
48682: PPUSH
48683: CALL_OW 121
// if GetControl ( j ) = control_remote then
48687: LD_VAR 0 3
48691: PPUSH
48692: CALL_OW 263
48696: PUSH
48697: LD_INT 2
48699: EQUAL
48700: IFFALSE 48711
// ComUnlink ( j ) ;
48702: LD_VAR 0 3
48706: PPUSH
48707: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48711: LD_ADDR_VAR 0 9
48715: PUSH
48716: LD_VAR 0 2
48720: PPUSH
48721: LD_INT 3
48723: PPUSH
48724: CALL 58184 0 2
48728: ST_TO_ADDR
// if fac then
48729: LD_VAR 0 9
48733: IFFALSE 48829
// begin for k in fac do
48735: LD_ADDR_VAR 0 4
48739: PUSH
48740: LD_VAR 0 9
48744: PUSH
48745: FOR_IN
48746: IFFALSE 48827
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48748: LD_ADDR_VAR 0 10
48752: PUSH
48753: LD_VAR 0 9
48757: PPUSH
48758: LD_VAR 0 3
48762: PPUSH
48763: CALL_OW 265
48767: PPUSH
48768: LD_VAR 0 3
48772: PPUSH
48773: CALL_OW 262
48777: PPUSH
48778: LD_VAR 0 3
48782: PPUSH
48783: CALL_OW 263
48787: PPUSH
48788: LD_VAR 0 3
48792: PPUSH
48793: CALL_OW 264
48797: PPUSH
48798: CALL 68753 0 5
48802: ST_TO_ADDR
// if components then
48803: LD_VAR 0 10
48807: IFFALSE 48825
// begin MC_InsertProduceList ( i , components ) ;
48809: LD_VAR 0 2
48813: PPUSH
48814: LD_VAR 0 10
48818: PPUSH
48819: CALL 57729 0 2
// break ;
48823: GO 48827
// end ; end ;
48825: GO 48745
48827: POP
48828: POP
// end ; continue ;
48829: GO 48325
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48831: LD_VAR 0 3
48835: PPUSH
48836: LD_INT 1
48838: PPUSH
48839: CALL_OW 289
48843: PUSH
48844: LD_INT 100
48846: LESS
48847: PUSH
48848: LD_VAR 0 3
48852: PPUSH
48853: CALL_OW 314
48857: NOT
48858: AND
48859: IFFALSE 48888
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48861: LD_VAR 0 3
48865: PPUSH
48866: LD_VAR 0 6
48870: PUSH
48871: LD_INT 2
48873: ARRAY
48874: PPUSH
48875: LD_VAR 0 6
48879: PUSH
48880: LD_INT 3
48882: ARRAY
48883: PPUSH
48884: CALL_OW 117
// break ;
48888: GO 48892
// end ;
48890: GO 48325
48892: POP
48893: POP
// end ; end ;
48894: GO 47163
48896: POP
48897: POP
// end ;
48898: LD_VAR 0 1
48902: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48903: LD_INT 0
48905: PPUSH
48906: PPUSH
48907: PPUSH
48908: PPUSH
// if not mc_bases then
48909: LD_EXP 99
48913: NOT
48914: IFFALSE 48918
// exit ;
48916: GO 49079
// for i = 1 to mc_bases do
48918: LD_ADDR_VAR 0 2
48922: PUSH
48923: DOUBLE
48924: LD_INT 1
48926: DEC
48927: ST_TO_ADDR
48928: LD_EXP 99
48932: PUSH
48933: FOR_TO
48934: IFFALSE 49077
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48936: LD_ADDR_VAR 0 4
48940: PUSH
48941: LD_EXP 118
48945: PUSH
48946: LD_VAR 0 2
48950: ARRAY
48951: PUSH
48952: LD_EXP 121
48956: PUSH
48957: LD_VAR 0 2
48961: ARRAY
48962: UNION
48963: PPUSH
48964: LD_INT 33
48966: PUSH
48967: LD_INT 2
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: PPUSH
48974: CALL_OW 72
48978: ST_TO_ADDR
// if tmp then
48979: LD_VAR 0 4
48983: IFFALSE 49075
// for j in tmp do
48985: LD_ADDR_VAR 0 3
48989: PUSH
48990: LD_VAR 0 4
48994: PUSH
48995: FOR_IN
48996: IFFALSE 49073
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48998: LD_VAR 0 3
49002: PPUSH
49003: CALL_OW 312
49007: NOT
49008: PUSH
49009: LD_VAR 0 3
49013: PPUSH
49014: CALL_OW 256
49018: PUSH
49019: LD_INT 250
49021: GREATEREQUAL
49022: AND
49023: IFFALSE 49036
// Connect ( j ) else
49025: LD_VAR 0 3
49029: PPUSH
49030: CALL 74154 0 1
49034: GO 49071
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49036: LD_VAR 0 3
49040: PPUSH
49041: CALL_OW 256
49045: PUSH
49046: LD_INT 250
49048: LESS
49049: PUSH
49050: LD_VAR 0 3
49054: PPUSH
49055: CALL_OW 312
49059: AND
49060: IFFALSE 49071
// ComUnlink ( j ) ;
49062: LD_VAR 0 3
49066: PPUSH
49067: CALL_OW 136
49071: GO 48995
49073: POP
49074: POP
// end ;
49075: GO 48933
49077: POP
49078: POP
// end ;
49079: LD_VAR 0 1
49083: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49084: LD_INT 0
49086: PPUSH
49087: PPUSH
49088: PPUSH
49089: PPUSH
49090: PPUSH
// if not mc_bases then
49091: LD_EXP 99
49095: NOT
49096: IFFALSE 49100
// exit ;
49098: GO 49545
// for i = 1 to mc_bases do
49100: LD_ADDR_VAR 0 2
49104: PUSH
49105: DOUBLE
49106: LD_INT 1
49108: DEC
49109: ST_TO_ADDR
49110: LD_EXP 99
49114: PUSH
49115: FOR_TO
49116: IFFALSE 49543
// begin if not mc_produce [ i ] then
49118: LD_EXP 120
49122: PUSH
49123: LD_VAR 0 2
49127: ARRAY
49128: NOT
49129: IFFALSE 49133
// continue ;
49131: GO 49115
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49133: LD_ADDR_VAR 0 5
49137: PUSH
49138: LD_EXP 99
49142: PUSH
49143: LD_VAR 0 2
49147: ARRAY
49148: PPUSH
49149: LD_INT 30
49151: PUSH
49152: LD_INT 3
49154: PUSH
49155: EMPTY
49156: LIST
49157: LIST
49158: PPUSH
49159: CALL_OW 72
49163: ST_TO_ADDR
// if not fac then
49164: LD_VAR 0 5
49168: NOT
49169: IFFALSE 49173
// continue ;
49171: GO 49115
// for j in fac do
49173: LD_ADDR_VAR 0 3
49177: PUSH
49178: LD_VAR 0 5
49182: PUSH
49183: FOR_IN
49184: IFFALSE 49539
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49186: LD_VAR 0 3
49190: PPUSH
49191: CALL_OW 461
49195: PUSH
49196: LD_INT 2
49198: NONEQUAL
49199: PUSH
49200: LD_VAR 0 3
49204: PPUSH
49205: LD_INT 15
49207: PPUSH
49208: CALL 73814 0 2
49212: PUSH
49213: LD_INT 4
49215: ARRAY
49216: OR
49217: IFFALSE 49221
// continue ;
49219: GO 49183
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49221: LD_VAR 0 3
49225: PPUSH
49226: LD_EXP 120
49230: PUSH
49231: LD_VAR 0 2
49235: ARRAY
49236: PUSH
49237: LD_INT 1
49239: ARRAY
49240: PUSH
49241: LD_INT 1
49243: ARRAY
49244: PPUSH
49245: LD_EXP 120
49249: PUSH
49250: LD_VAR 0 2
49254: ARRAY
49255: PUSH
49256: LD_INT 1
49258: ARRAY
49259: PUSH
49260: LD_INT 2
49262: ARRAY
49263: PPUSH
49264: LD_EXP 120
49268: PUSH
49269: LD_VAR 0 2
49273: ARRAY
49274: PUSH
49275: LD_INT 1
49277: ARRAY
49278: PUSH
49279: LD_INT 3
49281: ARRAY
49282: PPUSH
49283: LD_EXP 120
49287: PUSH
49288: LD_VAR 0 2
49292: ARRAY
49293: PUSH
49294: LD_INT 1
49296: ARRAY
49297: PUSH
49298: LD_INT 4
49300: ARRAY
49301: PPUSH
49302: CALL_OW 448
49306: PUSH
49307: LD_VAR 0 3
49311: PPUSH
49312: LD_EXP 120
49316: PUSH
49317: LD_VAR 0 2
49321: ARRAY
49322: PUSH
49323: LD_INT 1
49325: ARRAY
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PUSH
49331: LD_EXP 120
49335: PUSH
49336: LD_VAR 0 2
49340: ARRAY
49341: PUSH
49342: LD_INT 1
49344: ARRAY
49345: PUSH
49346: LD_INT 2
49348: ARRAY
49349: PUSH
49350: LD_EXP 120
49354: PUSH
49355: LD_VAR 0 2
49359: ARRAY
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PUSH
49365: LD_INT 3
49367: ARRAY
49368: PUSH
49369: LD_EXP 120
49373: PUSH
49374: LD_VAR 0 2
49378: ARRAY
49379: PUSH
49380: LD_INT 1
49382: ARRAY
49383: PUSH
49384: LD_INT 4
49386: ARRAY
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: PPUSH
49394: CALL 77485 0 2
49398: AND
49399: IFFALSE 49537
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49401: LD_VAR 0 3
49405: PPUSH
49406: LD_EXP 120
49410: PUSH
49411: LD_VAR 0 2
49415: ARRAY
49416: PUSH
49417: LD_INT 1
49419: ARRAY
49420: PUSH
49421: LD_INT 1
49423: ARRAY
49424: PPUSH
49425: LD_EXP 120
49429: PUSH
49430: LD_VAR 0 2
49434: ARRAY
49435: PUSH
49436: LD_INT 1
49438: ARRAY
49439: PUSH
49440: LD_INT 2
49442: ARRAY
49443: PPUSH
49444: LD_EXP 120
49448: PUSH
49449: LD_VAR 0 2
49453: ARRAY
49454: PUSH
49455: LD_INT 1
49457: ARRAY
49458: PUSH
49459: LD_INT 3
49461: ARRAY
49462: PPUSH
49463: LD_EXP 120
49467: PUSH
49468: LD_VAR 0 2
49472: ARRAY
49473: PUSH
49474: LD_INT 1
49476: ARRAY
49477: PUSH
49478: LD_INT 4
49480: ARRAY
49481: PPUSH
49482: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49486: LD_ADDR_VAR 0 4
49490: PUSH
49491: LD_EXP 120
49495: PUSH
49496: LD_VAR 0 2
49500: ARRAY
49501: PPUSH
49502: LD_INT 1
49504: PPUSH
49505: CALL_OW 3
49509: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49510: LD_ADDR_EXP 120
49514: PUSH
49515: LD_EXP 120
49519: PPUSH
49520: LD_VAR 0 2
49524: PPUSH
49525: LD_VAR 0 4
49529: PPUSH
49530: CALL_OW 1
49534: ST_TO_ADDR
// break ;
49535: GO 49539
// end ; end ;
49537: GO 49183
49539: POP
49540: POP
// end ;
49541: GO 49115
49543: POP
49544: POP
// end ;
49545: LD_VAR 0 1
49549: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49550: LD_INT 0
49552: PPUSH
49553: PPUSH
49554: PPUSH
// if not mc_bases then
49555: LD_EXP 99
49559: NOT
49560: IFFALSE 49564
// exit ;
49562: GO 49653
// for i = 1 to mc_bases do
49564: LD_ADDR_VAR 0 2
49568: PUSH
49569: DOUBLE
49570: LD_INT 1
49572: DEC
49573: ST_TO_ADDR
49574: LD_EXP 99
49578: PUSH
49579: FOR_TO
49580: IFFALSE 49651
// begin if mc_attack [ i ] then
49582: LD_EXP 119
49586: PUSH
49587: LD_VAR 0 2
49591: ARRAY
49592: IFFALSE 49649
// begin tmp := mc_attack [ i ] [ 1 ] ;
49594: LD_ADDR_VAR 0 3
49598: PUSH
49599: LD_EXP 119
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PUSH
49610: LD_INT 1
49612: ARRAY
49613: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49614: LD_ADDR_EXP 119
49618: PUSH
49619: LD_EXP 119
49623: PPUSH
49624: LD_VAR 0 2
49628: PPUSH
49629: EMPTY
49630: PPUSH
49631: CALL_OW 1
49635: ST_TO_ADDR
// Attack ( tmp ) ;
49636: LD_VAR 0 3
49640: PPUSH
49641: CALL 99698 0 1
// exit ;
49645: POP
49646: POP
49647: GO 49653
// end ; end ;
49649: GO 49579
49651: POP
49652: POP
// end ;
49653: LD_VAR 0 1
49657: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49658: LD_INT 0
49660: PPUSH
49661: PPUSH
49662: PPUSH
49663: PPUSH
49664: PPUSH
49665: PPUSH
49666: PPUSH
// if not mc_bases then
49667: LD_EXP 99
49671: NOT
49672: IFFALSE 49676
// exit ;
49674: GO 50258
// for i = 1 to mc_bases do
49676: LD_ADDR_VAR 0 2
49680: PUSH
49681: DOUBLE
49682: LD_INT 1
49684: DEC
49685: ST_TO_ADDR
49686: LD_EXP 99
49690: PUSH
49691: FOR_TO
49692: IFFALSE 50256
// begin if not mc_bases [ i ] then
49694: LD_EXP 99
49698: PUSH
49699: LD_VAR 0 2
49703: ARRAY
49704: NOT
49705: IFFALSE 49709
// continue ;
49707: GO 49691
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49709: LD_ADDR_VAR 0 7
49713: PUSH
49714: LD_EXP 99
49718: PUSH
49719: LD_VAR 0 2
49723: ARRAY
49724: PUSH
49725: LD_INT 1
49727: ARRAY
49728: PPUSH
49729: CALL 68057 0 1
49733: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49734: LD_ADDR_EXP 122
49738: PUSH
49739: LD_EXP 122
49743: PPUSH
49744: LD_VAR 0 2
49748: PPUSH
49749: LD_EXP 99
49753: PUSH
49754: LD_VAR 0 2
49758: ARRAY
49759: PUSH
49760: LD_INT 1
49762: ARRAY
49763: PPUSH
49764: CALL_OW 255
49768: PPUSH
49769: LD_EXP 124
49773: PUSH
49774: LD_VAR 0 2
49778: ARRAY
49779: PPUSH
49780: CALL 65700 0 2
49784: PPUSH
49785: CALL_OW 1
49789: ST_TO_ADDR
// if not mc_scan [ i ] then
49790: LD_EXP 122
49794: PUSH
49795: LD_VAR 0 2
49799: ARRAY
49800: NOT
49801: IFFALSE 49956
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49803: LD_ADDR_VAR 0 4
49807: PUSH
49808: LD_EXP 99
49812: PUSH
49813: LD_VAR 0 2
49817: ARRAY
49818: PPUSH
49819: LD_INT 2
49821: PUSH
49822: LD_INT 25
49824: PUSH
49825: LD_INT 5
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PUSH
49832: LD_INT 25
49834: PUSH
49835: LD_INT 8
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 25
49844: PUSH
49845: LD_INT 9
49847: PUSH
49848: EMPTY
49849: LIST
49850: LIST
49851: PUSH
49852: EMPTY
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: PPUSH
49858: CALL_OW 72
49862: ST_TO_ADDR
// if not tmp then
49863: LD_VAR 0 4
49867: NOT
49868: IFFALSE 49872
// continue ;
49870: GO 49691
// for j in tmp do
49872: LD_ADDR_VAR 0 3
49876: PUSH
49877: LD_VAR 0 4
49881: PUSH
49882: FOR_IN
49883: IFFALSE 49954
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49885: LD_VAR 0 3
49889: PPUSH
49890: CALL_OW 310
49894: PPUSH
49895: CALL_OW 266
49899: PUSH
49900: LD_INT 5
49902: EQUAL
49903: PUSH
49904: LD_VAR 0 3
49908: PPUSH
49909: CALL_OW 257
49913: PUSH
49914: LD_INT 1
49916: EQUAL
49917: AND
49918: PUSH
49919: LD_VAR 0 3
49923: PPUSH
49924: CALL_OW 459
49928: NOT
49929: AND
49930: PUSH
49931: LD_VAR 0 7
49935: AND
49936: IFFALSE 49952
// ComChangeProfession ( j , class ) ;
49938: LD_VAR 0 3
49942: PPUSH
49943: LD_VAR 0 7
49947: PPUSH
49948: CALL_OW 123
49952: GO 49882
49954: POP
49955: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49956: LD_EXP 122
49960: PUSH
49961: LD_VAR 0 2
49965: ARRAY
49966: PUSH
49967: LD_EXP 121
49971: PUSH
49972: LD_VAR 0 2
49976: ARRAY
49977: NOT
49978: AND
49979: PUSH
49980: LD_EXP 99
49984: PUSH
49985: LD_VAR 0 2
49989: ARRAY
49990: PPUSH
49991: LD_INT 30
49993: PUSH
49994: LD_INT 32
49996: PUSH
49997: EMPTY
49998: LIST
49999: LIST
50000: PPUSH
50001: CALL_OW 72
50005: NOT
50006: AND
50007: PUSH
50008: LD_EXP 99
50012: PUSH
50013: LD_VAR 0 2
50017: ARRAY
50018: PPUSH
50019: LD_INT 2
50021: PUSH
50022: LD_INT 30
50024: PUSH
50025: LD_INT 4
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: LD_INT 30
50034: PUSH
50035: LD_INT 5
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: LIST
50046: PPUSH
50047: CALL_OW 72
50051: NOT
50052: AND
50053: IFFALSE 50185
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50055: LD_ADDR_VAR 0 4
50059: PUSH
50060: LD_EXP 99
50064: PUSH
50065: LD_VAR 0 2
50069: ARRAY
50070: PPUSH
50071: LD_INT 2
50073: PUSH
50074: LD_INT 25
50076: PUSH
50077: LD_INT 1
50079: PUSH
50080: EMPTY
50081: LIST
50082: LIST
50083: PUSH
50084: LD_INT 25
50086: PUSH
50087: LD_INT 5
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_INT 25
50096: PUSH
50097: LD_INT 8
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PUSH
50104: LD_INT 25
50106: PUSH
50107: LD_INT 9
50109: PUSH
50110: EMPTY
50111: LIST
50112: LIST
50113: PUSH
50114: EMPTY
50115: LIST
50116: LIST
50117: LIST
50118: LIST
50119: LIST
50120: PPUSH
50121: CALL_OW 72
50125: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50126: LD_ADDR_VAR 0 4
50130: PUSH
50131: LD_VAR 0 4
50135: PUSH
50136: LD_VAR 0 4
50140: PPUSH
50141: LD_INT 18
50143: PPUSH
50144: CALL 104481 0 2
50148: DIFF
50149: ST_TO_ADDR
// if tmp then
50150: LD_VAR 0 4
50154: IFFALSE 50185
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50156: LD_VAR 0 2
50160: PPUSH
50161: LD_VAR 0 4
50165: PPUSH
50166: LD_EXP 124
50170: PUSH
50171: LD_VAR 0 2
50175: ARRAY
50176: PPUSH
50177: CALL 65735 0 3
// exit ;
50181: POP
50182: POP
50183: GO 50258
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50185: LD_EXP 122
50189: PUSH
50190: LD_VAR 0 2
50194: ARRAY
50195: PUSH
50196: LD_EXP 121
50200: PUSH
50201: LD_VAR 0 2
50205: ARRAY
50206: AND
50207: IFFALSE 50254
// begin tmp := mc_defender [ i ] ;
50209: LD_ADDR_VAR 0 4
50213: PUSH
50214: LD_EXP 121
50218: PUSH
50219: LD_VAR 0 2
50223: ARRAY
50224: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50225: LD_VAR 0 2
50229: PPUSH
50230: LD_VAR 0 4
50234: PPUSH
50235: LD_EXP 122
50239: PUSH
50240: LD_VAR 0 2
50244: ARRAY
50245: PPUSH
50246: CALL 66296 0 3
// exit ;
50250: POP
50251: POP
50252: GO 50258
// end ; end ;
50254: GO 49691
50256: POP
50257: POP
// end ;
50258: LD_VAR 0 1
50262: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50263: LD_INT 0
50265: PPUSH
50266: PPUSH
50267: PPUSH
50268: PPUSH
50269: PPUSH
50270: PPUSH
50271: PPUSH
50272: PPUSH
50273: PPUSH
50274: PPUSH
50275: PPUSH
// if not mc_bases then
50276: LD_EXP 99
50280: NOT
50281: IFFALSE 50285
// exit ;
50283: GO 51372
// for i = 1 to mc_bases do
50285: LD_ADDR_VAR 0 2
50289: PUSH
50290: DOUBLE
50291: LD_INT 1
50293: DEC
50294: ST_TO_ADDR
50295: LD_EXP 99
50299: PUSH
50300: FOR_TO
50301: IFFALSE 51370
// begin tmp := mc_lab [ i ] ;
50303: LD_ADDR_VAR 0 6
50307: PUSH
50308: LD_EXP 132
50312: PUSH
50313: LD_VAR 0 2
50317: ARRAY
50318: ST_TO_ADDR
// if not tmp then
50319: LD_VAR 0 6
50323: NOT
50324: IFFALSE 50328
// continue ;
50326: GO 50300
// idle_lab := 0 ;
50328: LD_ADDR_VAR 0 11
50332: PUSH
50333: LD_INT 0
50335: ST_TO_ADDR
// for j in tmp do
50336: LD_ADDR_VAR 0 3
50340: PUSH
50341: LD_VAR 0 6
50345: PUSH
50346: FOR_IN
50347: IFFALSE 51366
// begin researching := false ;
50349: LD_ADDR_VAR 0 10
50353: PUSH
50354: LD_INT 0
50356: ST_TO_ADDR
// side := GetSide ( j ) ;
50357: LD_ADDR_VAR 0 4
50361: PUSH
50362: LD_VAR 0 3
50366: PPUSH
50367: CALL_OW 255
50371: ST_TO_ADDR
// if not mc_tech [ side ] then
50372: LD_EXP 126
50376: PUSH
50377: LD_VAR 0 4
50381: ARRAY
50382: NOT
50383: IFFALSE 50387
// continue ;
50385: GO 50346
// if BuildingStatus ( j ) = bs_idle then
50387: LD_VAR 0 3
50391: PPUSH
50392: CALL_OW 461
50396: PUSH
50397: LD_INT 2
50399: EQUAL
50400: IFFALSE 50588
// begin if idle_lab and UnitsInside ( j ) < 6 then
50402: LD_VAR 0 11
50406: PUSH
50407: LD_VAR 0 3
50411: PPUSH
50412: CALL_OW 313
50416: PUSH
50417: LD_INT 6
50419: LESS
50420: AND
50421: IFFALSE 50492
// begin tmp2 := UnitsInside ( idle_lab ) ;
50423: LD_ADDR_VAR 0 9
50427: PUSH
50428: LD_VAR 0 11
50432: PPUSH
50433: CALL_OW 313
50437: ST_TO_ADDR
// if tmp2 then
50438: LD_VAR 0 9
50442: IFFALSE 50484
// for x in tmp2 do
50444: LD_ADDR_VAR 0 7
50448: PUSH
50449: LD_VAR 0 9
50453: PUSH
50454: FOR_IN
50455: IFFALSE 50482
// begin ComExitBuilding ( x ) ;
50457: LD_VAR 0 7
50461: PPUSH
50462: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50466: LD_VAR 0 7
50470: PPUSH
50471: LD_VAR 0 3
50475: PPUSH
50476: CALL_OW 180
// end ;
50480: GO 50454
50482: POP
50483: POP
// idle_lab := 0 ;
50484: LD_ADDR_VAR 0 11
50488: PUSH
50489: LD_INT 0
50491: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50492: LD_ADDR_VAR 0 5
50496: PUSH
50497: LD_EXP 126
50501: PUSH
50502: LD_VAR 0 4
50506: ARRAY
50507: PUSH
50508: FOR_IN
50509: IFFALSE 50569
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50511: LD_VAR 0 3
50515: PPUSH
50516: LD_VAR 0 5
50520: PPUSH
50521: CALL_OW 430
50525: PUSH
50526: LD_VAR 0 4
50530: PPUSH
50531: LD_VAR 0 5
50535: PPUSH
50536: CALL 64805 0 2
50540: AND
50541: IFFALSE 50567
// begin researching := true ;
50543: LD_ADDR_VAR 0 10
50547: PUSH
50548: LD_INT 1
50550: ST_TO_ADDR
// ComResearch ( j , t ) ;
50551: LD_VAR 0 3
50555: PPUSH
50556: LD_VAR 0 5
50560: PPUSH
50561: CALL_OW 124
// break ;
50565: GO 50569
// end ;
50567: GO 50508
50569: POP
50570: POP
// if not researching then
50571: LD_VAR 0 10
50575: NOT
50576: IFFALSE 50588
// idle_lab := j ;
50578: LD_ADDR_VAR 0 11
50582: PUSH
50583: LD_VAR 0 3
50587: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50588: LD_VAR 0 3
50592: PPUSH
50593: CALL_OW 461
50597: PUSH
50598: LD_INT 10
50600: EQUAL
50601: IFFALSE 51189
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50603: LD_EXP 128
50607: PUSH
50608: LD_VAR 0 2
50612: ARRAY
50613: NOT
50614: PUSH
50615: LD_EXP 129
50619: PUSH
50620: LD_VAR 0 2
50624: ARRAY
50625: NOT
50626: AND
50627: PUSH
50628: LD_EXP 126
50632: PUSH
50633: LD_VAR 0 4
50637: ARRAY
50638: PUSH
50639: LD_INT 1
50641: GREATER
50642: AND
50643: IFFALSE 50774
// begin ComCancel ( j ) ;
50645: LD_VAR 0 3
50649: PPUSH
50650: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50654: LD_ADDR_EXP 126
50658: PUSH
50659: LD_EXP 126
50663: PPUSH
50664: LD_VAR 0 4
50668: PPUSH
50669: LD_EXP 126
50673: PUSH
50674: LD_VAR 0 4
50678: ARRAY
50679: PPUSH
50680: LD_EXP 126
50684: PUSH
50685: LD_VAR 0 4
50689: ARRAY
50690: PUSH
50691: LD_INT 1
50693: MINUS
50694: PPUSH
50695: LD_EXP 126
50699: PUSH
50700: LD_VAR 0 4
50704: ARRAY
50705: PPUSH
50706: LD_INT 0
50708: PPUSH
50709: CALL 70639 0 4
50713: PPUSH
50714: CALL_OW 1
50718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50719: LD_ADDR_EXP 126
50723: PUSH
50724: LD_EXP 126
50728: PPUSH
50729: LD_VAR 0 4
50733: PPUSH
50734: LD_EXP 126
50738: PUSH
50739: LD_VAR 0 4
50743: ARRAY
50744: PPUSH
50745: LD_EXP 126
50749: PUSH
50750: LD_VAR 0 4
50754: ARRAY
50755: PPUSH
50756: LD_INT 1
50758: PPUSH
50759: LD_INT 0
50761: PPUSH
50762: CALL 70639 0 4
50766: PPUSH
50767: CALL_OW 1
50771: ST_TO_ADDR
// continue ;
50772: GO 50346
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50774: LD_EXP 128
50778: PUSH
50779: LD_VAR 0 2
50783: ARRAY
50784: PUSH
50785: LD_EXP 129
50789: PUSH
50790: LD_VAR 0 2
50794: ARRAY
50795: NOT
50796: AND
50797: IFFALSE 50924
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50799: LD_ADDR_EXP 129
50803: PUSH
50804: LD_EXP 129
50808: PPUSH
50809: LD_VAR 0 2
50813: PUSH
50814: LD_EXP 129
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: PUSH
50825: LD_INT 1
50827: PLUS
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PPUSH
50833: LD_EXP 128
50837: PUSH
50838: LD_VAR 0 2
50842: ARRAY
50843: PUSH
50844: LD_INT 1
50846: ARRAY
50847: PPUSH
50848: CALL 71221 0 3
50852: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50853: LD_EXP 128
50857: PUSH
50858: LD_VAR 0 2
50862: ARRAY
50863: PUSH
50864: LD_INT 1
50866: ARRAY
50867: PPUSH
50868: LD_INT 112
50870: PPUSH
50871: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50875: LD_ADDR_VAR 0 9
50879: PUSH
50880: LD_EXP 128
50884: PUSH
50885: LD_VAR 0 2
50889: ARRAY
50890: PPUSH
50891: LD_INT 1
50893: PPUSH
50894: CALL_OW 3
50898: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50899: LD_ADDR_EXP 128
50903: PUSH
50904: LD_EXP 128
50908: PPUSH
50909: LD_VAR 0 2
50913: PPUSH
50914: LD_VAR 0 9
50918: PPUSH
50919: CALL_OW 1
50923: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50924: LD_EXP 128
50928: PUSH
50929: LD_VAR 0 2
50933: ARRAY
50934: PUSH
50935: LD_EXP 129
50939: PUSH
50940: LD_VAR 0 2
50944: ARRAY
50945: AND
50946: PUSH
50947: LD_EXP 129
50951: PUSH
50952: LD_VAR 0 2
50956: ARRAY
50957: PUSH
50958: LD_INT 1
50960: ARRAY
50961: PPUSH
50962: CALL_OW 310
50966: NOT
50967: AND
50968: PUSH
50969: LD_VAR 0 3
50973: PPUSH
50974: CALL_OW 313
50978: PUSH
50979: LD_INT 6
50981: EQUAL
50982: AND
50983: IFFALSE 51039
// begin tmp2 := UnitsInside ( j ) ;
50985: LD_ADDR_VAR 0 9
50989: PUSH
50990: LD_VAR 0 3
50994: PPUSH
50995: CALL_OW 313
50999: ST_TO_ADDR
// if tmp2 = 6 then
51000: LD_VAR 0 9
51004: PUSH
51005: LD_INT 6
51007: EQUAL
51008: IFFALSE 51039
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51010: LD_VAR 0 9
51014: PUSH
51015: LD_INT 1
51017: ARRAY
51018: PPUSH
51019: LD_INT 112
51021: PPUSH
51022: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51026: LD_VAR 0 9
51030: PUSH
51031: LD_INT 1
51033: ARRAY
51034: PPUSH
51035: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51039: LD_EXP 129
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: PUSH
51050: LD_EXP 129
51054: PUSH
51055: LD_VAR 0 2
51059: ARRAY
51060: PUSH
51061: LD_INT 1
51063: ARRAY
51064: PPUSH
51065: CALL_OW 314
51069: NOT
51070: AND
51071: PUSH
51072: LD_EXP 129
51076: PUSH
51077: LD_VAR 0 2
51081: ARRAY
51082: PUSH
51083: LD_INT 1
51085: ARRAY
51086: PPUSH
51087: CALL_OW 310
51091: NOT
51092: AND
51093: IFFALSE 51119
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51095: LD_EXP 129
51099: PUSH
51100: LD_VAR 0 2
51104: ARRAY
51105: PUSH
51106: LD_INT 1
51108: ARRAY
51109: PPUSH
51110: LD_VAR 0 3
51114: PPUSH
51115: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51119: LD_EXP 129
51123: PUSH
51124: LD_VAR 0 2
51128: ARRAY
51129: PUSH
51130: LD_INT 1
51132: ARRAY
51133: PPUSH
51134: CALL_OW 310
51138: PUSH
51139: LD_EXP 129
51143: PUSH
51144: LD_VAR 0 2
51148: ARRAY
51149: PUSH
51150: LD_INT 1
51152: ARRAY
51153: PPUSH
51154: CALL_OW 310
51158: PPUSH
51159: CALL_OW 461
51163: PUSH
51164: LD_INT 3
51166: NONEQUAL
51167: AND
51168: IFFALSE 51189
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51170: LD_EXP 129
51174: PUSH
51175: LD_VAR 0 2
51179: ARRAY
51180: PUSH
51181: LD_INT 1
51183: ARRAY
51184: PPUSH
51185: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51189: LD_VAR 0 3
51193: PPUSH
51194: CALL_OW 461
51198: PUSH
51199: LD_INT 6
51201: EQUAL
51202: PUSH
51203: LD_VAR 0 6
51207: PUSH
51208: LD_INT 1
51210: GREATER
51211: AND
51212: IFFALSE 51364
// begin sci := [ ] ;
51214: LD_ADDR_VAR 0 8
51218: PUSH
51219: EMPTY
51220: ST_TO_ADDR
// for x in ( tmp diff j ) do
51221: LD_ADDR_VAR 0 7
51225: PUSH
51226: LD_VAR 0 6
51230: PUSH
51231: LD_VAR 0 3
51235: DIFF
51236: PUSH
51237: FOR_IN
51238: IFFALSE 51290
// begin if sci = 6 then
51240: LD_VAR 0 8
51244: PUSH
51245: LD_INT 6
51247: EQUAL
51248: IFFALSE 51252
// break ;
51250: GO 51290
// if BuildingStatus ( x ) = bs_idle then
51252: LD_VAR 0 7
51256: PPUSH
51257: CALL_OW 461
51261: PUSH
51262: LD_INT 2
51264: EQUAL
51265: IFFALSE 51288
// sci := sci ^ UnitsInside ( x ) ;
51267: LD_ADDR_VAR 0 8
51271: PUSH
51272: LD_VAR 0 8
51276: PUSH
51277: LD_VAR 0 7
51281: PPUSH
51282: CALL_OW 313
51286: ADD
51287: ST_TO_ADDR
// end ;
51288: GO 51237
51290: POP
51291: POP
// if not sci then
51292: LD_VAR 0 8
51296: NOT
51297: IFFALSE 51301
// continue ;
51299: GO 50346
// for x in sci do
51301: LD_ADDR_VAR 0 7
51305: PUSH
51306: LD_VAR 0 8
51310: PUSH
51311: FOR_IN
51312: IFFALSE 51362
// if IsInUnit ( x ) and not HasTask ( x ) then
51314: LD_VAR 0 7
51318: PPUSH
51319: CALL_OW 310
51323: PUSH
51324: LD_VAR 0 7
51328: PPUSH
51329: CALL_OW 314
51333: NOT
51334: AND
51335: IFFALSE 51360
// begin ComExitBuilding ( x ) ;
51337: LD_VAR 0 7
51341: PPUSH
51342: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51346: LD_VAR 0 7
51350: PPUSH
51351: LD_VAR 0 3
51355: PPUSH
51356: CALL_OW 180
// end ;
51360: GO 51311
51362: POP
51363: POP
// end ; end ;
51364: GO 50346
51366: POP
51367: POP
// end ;
51368: GO 50300
51370: POP
51371: POP
// end ;
51372: LD_VAR 0 1
51376: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51377: LD_INT 0
51379: PPUSH
51380: PPUSH
// if not mc_bases then
51381: LD_EXP 99
51385: NOT
51386: IFFALSE 51390
// exit ;
51388: GO 51471
// for i = 1 to mc_bases do
51390: LD_ADDR_VAR 0 2
51394: PUSH
51395: DOUBLE
51396: LD_INT 1
51398: DEC
51399: ST_TO_ADDR
51400: LD_EXP 99
51404: PUSH
51405: FOR_TO
51406: IFFALSE 51469
// if mc_mines [ i ] and mc_miners [ i ] then
51408: LD_EXP 112
51412: PUSH
51413: LD_VAR 0 2
51417: ARRAY
51418: PUSH
51419: LD_EXP 113
51423: PUSH
51424: LD_VAR 0 2
51428: ARRAY
51429: AND
51430: IFFALSE 51467
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51432: LD_EXP 113
51436: PUSH
51437: LD_VAR 0 2
51441: ARRAY
51442: PUSH
51443: LD_INT 1
51445: ARRAY
51446: PPUSH
51447: CALL_OW 255
51451: PPUSH
51452: LD_EXP 112
51456: PUSH
51457: LD_VAR 0 2
51461: ARRAY
51462: PPUSH
51463: CALL 68210 0 2
51467: GO 51405
51469: POP
51470: POP
// end ;
51471: LD_VAR 0 1
51475: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51476: LD_INT 0
51478: PPUSH
51479: PPUSH
51480: PPUSH
51481: PPUSH
51482: PPUSH
51483: PPUSH
51484: PPUSH
51485: PPUSH
// if not mc_bases or not mc_parking then
51486: LD_EXP 99
51490: NOT
51491: PUSH
51492: LD_EXP 123
51496: NOT
51497: OR
51498: IFFALSE 51502
// exit ;
51500: GO 52201
// for i = 1 to mc_bases do
51502: LD_ADDR_VAR 0 2
51506: PUSH
51507: DOUBLE
51508: LD_INT 1
51510: DEC
51511: ST_TO_ADDR
51512: LD_EXP 99
51516: PUSH
51517: FOR_TO
51518: IFFALSE 52199
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51520: LD_EXP 99
51524: PUSH
51525: LD_VAR 0 2
51529: ARRAY
51530: NOT
51531: PUSH
51532: LD_EXP 123
51536: PUSH
51537: LD_VAR 0 2
51541: ARRAY
51542: NOT
51543: OR
51544: IFFALSE 51548
// continue ;
51546: GO 51517
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51548: LD_ADDR_VAR 0 5
51552: PUSH
51553: LD_EXP 99
51557: PUSH
51558: LD_VAR 0 2
51562: ARRAY
51563: PUSH
51564: LD_INT 1
51566: ARRAY
51567: PPUSH
51568: CALL_OW 255
51572: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51573: LD_ADDR_VAR 0 6
51577: PUSH
51578: LD_EXP 99
51582: PUSH
51583: LD_VAR 0 2
51587: ARRAY
51588: PPUSH
51589: LD_INT 30
51591: PUSH
51592: LD_INT 3
51594: PUSH
51595: EMPTY
51596: LIST
51597: LIST
51598: PPUSH
51599: CALL_OW 72
51603: ST_TO_ADDR
// if not fac then
51604: LD_VAR 0 6
51608: NOT
51609: IFFALSE 51660
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51611: LD_ADDR_VAR 0 6
51615: PUSH
51616: LD_EXP 99
51620: PUSH
51621: LD_VAR 0 2
51625: ARRAY
51626: PPUSH
51627: LD_INT 2
51629: PUSH
51630: LD_INT 30
51632: PUSH
51633: LD_INT 0
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PUSH
51640: LD_INT 30
51642: PUSH
51643: LD_INT 1
51645: PUSH
51646: EMPTY
51647: LIST
51648: LIST
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: LIST
51654: PPUSH
51655: CALL_OW 72
51659: ST_TO_ADDR
// if not fac then
51660: LD_VAR 0 6
51664: NOT
51665: IFFALSE 51669
// continue ;
51667: GO 51517
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51669: LD_ADDR_VAR 0 7
51673: PUSH
51674: LD_EXP 123
51678: PUSH
51679: LD_VAR 0 2
51683: ARRAY
51684: PPUSH
51685: LD_INT 22
51687: PUSH
51688: LD_VAR 0 5
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: PUSH
51697: LD_INT 21
51699: PUSH
51700: LD_INT 2
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PUSH
51707: LD_INT 3
51709: PUSH
51710: LD_INT 24
51712: PUSH
51713: LD_INT 1000
51715: PUSH
51716: EMPTY
51717: LIST
51718: LIST
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: PPUSH
51729: CALL_OW 70
51733: ST_TO_ADDR
// for j in fac do
51734: LD_ADDR_VAR 0 3
51738: PUSH
51739: LD_VAR 0 6
51743: PUSH
51744: FOR_IN
51745: IFFALSE 51826
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51747: LD_ADDR_VAR 0 7
51751: PUSH
51752: LD_VAR 0 7
51756: PUSH
51757: LD_INT 22
51759: PUSH
51760: LD_VAR 0 5
51764: PUSH
51765: EMPTY
51766: LIST
51767: LIST
51768: PUSH
51769: LD_INT 91
51771: PUSH
51772: LD_VAR 0 3
51776: PUSH
51777: LD_INT 15
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: LIST
51784: PUSH
51785: LD_INT 21
51787: PUSH
51788: LD_INT 2
51790: PUSH
51791: EMPTY
51792: LIST
51793: LIST
51794: PUSH
51795: LD_INT 3
51797: PUSH
51798: LD_INT 24
51800: PUSH
51801: LD_INT 1000
51803: PUSH
51804: EMPTY
51805: LIST
51806: LIST
51807: PUSH
51808: EMPTY
51809: LIST
51810: LIST
51811: PUSH
51812: EMPTY
51813: LIST
51814: LIST
51815: LIST
51816: LIST
51817: PPUSH
51818: CALL_OW 69
51822: UNION
51823: ST_TO_ADDR
51824: GO 51744
51826: POP
51827: POP
// if not vehs then
51828: LD_VAR 0 7
51832: NOT
51833: IFFALSE 51859
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51835: LD_ADDR_EXP 111
51839: PUSH
51840: LD_EXP 111
51844: PPUSH
51845: LD_VAR 0 2
51849: PPUSH
51850: EMPTY
51851: PPUSH
51852: CALL_OW 1
51856: ST_TO_ADDR
// continue ;
51857: GO 51517
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51859: LD_ADDR_VAR 0 8
51863: PUSH
51864: LD_EXP 99
51868: PUSH
51869: LD_VAR 0 2
51873: ARRAY
51874: PPUSH
51875: LD_INT 30
51877: PUSH
51878: LD_INT 3
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: PPUSH
51885: CALL_OW 72
51889: ST_TO_ADDR
// if tmp then
51890: LD_VAR 0 8
51894: IFFALSE 51997
// begin for j in tmp do
51896: LD_ADDR_VAR 0 3
51900: PUSH
51901: LD_VAR 0 8
51905: PUSH
51906: FOR_IN
51907: IFFALSE 51995
// for k in UnitsInside ( j ) do
51909: LD_ADDR_VAR 0 4
51913: PUSH
51914: LD_VAR 0 3
51918: PPUSH
51919: CALL_OW 313
51923: PUSH
51924: FOR_IN
51925: IFFALSE 51991
// if k then
51927: LD_VAR 0 4
51931: IFFALSE 51989
// if not k in mc_repair_vehicle [ i ] then
51933: LD_VAR 0 4
51937: PUSH
51938: LD_EXP 111
51942: PUSH
51943: LD_VAR 0 2
51947: ARRAY
51948: IN
51949: NOT
51950: IFFALSE 51989
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51952: LD_ADDR_EXP 111
51956: PUSH
51957: LD_EXP 111
51961: PPUSH
51962: LD_VAR 0 2
51966: PPUSH
51967: LD_EXP 111
51971: PUSH
51972: LD_VAR 0 2
51976: ARRAY
51977: PUSH
51978: LD_VAR 0 4
51982: UNION
51983: PPUSH
51984: CALL_OW 1
51988: ST_TO_ADDR
51989: GO 51924
51991: POP
51992: POP
51993: GO 51906
51995: POP
51996: POP
// end ; if not mc_repair_vehicle [ i ] then
51997: LD_EXP 111
52001: PUSH
52002: LD_VAR 0 2
52006: ARRAY
52007: NOT
52008: IFFALSE 52012
// continue ;
52010: GO 51517
// for j in mc_repair_vehicle [ i ] do
52012: LD_ADDR_VAR 0 3
52016: PUSH
52017: LD_EXP 111
52021: PUSH
52022: LD_VAR 0 2
52026: ARRAY
52027: PUSH
52028: FOR_IN
52029: IFFALSE 52195
// begin if GetClass ( j ) <> 3 then
52031: LD_VAR 0 3
52035: PPUSH
52036: CALL_OW 257
52040: PUSH
52041: LD_INT 3
52043: NONEQUAL
52044: IFFALSE 52085
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52046: LD_ADDR_EXP 111
52050: PUSH
52051: LD_EXP 111
52055: PPUSH
52056: LD_VAR 0 2
52060: PPUSH
52061: LD_EXP 111
52065: PUSH
52066: LD_VAR 0 2
52070: ARRAY
52071: PUSH
52072: LD_VAR 0 3
52076: DIFF
52077: PPUSH
52078: CALL_OW 1
52082: ST_TO_ADDR
// continue ;
52083: GO 52028
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52085: LD_VAR 0 3
52089: PPUSH
52090: CALL_OW 311
52094: NOT
52095: PUSH
52096: LD_VAR 0 3
52100: PUSH
52101: LD_EXP 102
52105: PUSH
52106: LD_VAR 0 2
52110: ARRAY
52111: PUSH
52112: LD_INT 1
52114: ARRAY
52115: IN
52116: NOT
52117: AND
52118: PUSH
52119: LD_VAR 0 3
52123: PUSH
52124: LD_EXP 102
52128: PUSH
52129: LD_VAR 0 2
52133: ARRAY
52134: PUSH
52135: LD_INT 2
52137: ARRAY
52138: IN
52139: NOT
52140: AND
52141: IFFALSE 52193
// begin if IsInUnit ( j ) then
52143: LD_VAR 0 3
52147: PPUSH
52148: CALL_OW 310
52152: IFFALSE 52163
// ComExitBuilding ( j ) ;
52154: LD_VAR 0 3
52158: PPUSH
52159: CALL_OW 122
// if not HasTask ( j ) then
52163: LD_VAR 0 3
52167: PPUSH
52168: CALL_OW 314
52172: NOT
52173: IFFALSE 52193
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52175: LD_VAR 0 3
52179: PPUSH
52180: LD_VAR 0 7
52184: PUSH
52185: LD_INT 1
52187: ARRAY
52188: PPUSH
52189: CALL_OW 189
// end ; end ;
52193: GO 52028
52195: POP
52196: POP
// end ;
52197: GO 51517
52199: POP
52200: POP
// end ;
52201: LD_VAR 0 1
52205: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52206: LD_INT 0
52208: PPUSH
52209: PPUSH
52210: PPUSH
52211: PPUSH
52212: PPUSH
52213: PPUSH
52214: PPUSH
52215: PPUSH
52216: PPUSH
52217: PPUSH
52218: PPUSH
// if not mc_bases then
52219: LD_EXP 99
52223: NOT
52224: IFFALSE 52228
// exit ;
52226: GO 53030
// for i = 1 to mc_bases do
52228: LD_ADDR_VAR 0 2
52232: PUSH
52233: DOUBLE
52234: LD_INT 1
52236: DEC
52237: ST_TO_ADDR
52238: LD_EXP 99
52242: PUSH
52243: FOR_TO
52244: IFFALSE 53028
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52246: LD_EXP 127
52250: PUSH
52251: LD_VAR 0 2
52255: ARRAY
52256: NOT
52257: PUSH
52258: LD_EXP 102
52262: PUSH
52263: LD_VAR 0 2
52267: ARRAY
52268: PUSH
52269: LD_INT 1
52271: ARRAY
52272: OR
52273: PUSH
52274: LD_EXP 102
52278: PUSH
52279: LD_VAR 0 2
52283: ARRAY
52284: PUSH
52285: LD_INT 2
52287: ARRAY
52288: OR
52289: PUSH
52290: LD_EXP 125
52294: PUSH
52295: LD_VAR 0 2
52299: ARRAY
52300: PPUSH
52301: LD_INT 1
52303: PPUSH
52304: CALL_OW 325
52308: NOT
52309: OR
52310: PUSH
52311: LD_EXP 122
52315: PUSH
52316: LD_VAR 0 2
52320: ARRAY
52321: OR
52322: IFFALSE 52326
// continue ;
52324: GO 52243
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52326: LD_ADDR_VAR 0 8
52330: PUSH
52331: LD_EXP 99
52335: PUSH
52336: LD_VAR 0 2
52340: ARRAY
52341: PPUSH
52342: LD_INT 25
52344: PUSH
52345: LD_INT 4
52347: PUSH
52348: EMPTY
52349: LIST
52350: LIST
52351: PUSH
52352: LD_INT 50
52354: PUSH
52355: EMPTY
52356: LIST
52357: PUSH
52358: LD_INT 3
52360: PUSH
52361: LD_INT 60
52363: PUSH
52364: EMPTY
52365: LIST
52366: PUSH
52367: EMPTY
52368: LIST
52369: LIST
52370: PUSH
52371: EMPTY
52372: LIST
52373: LIST
52374: LIST
52375: PPUSH
52376: CALL_OW 72
52380: PUSH
52381: LD_EXP 103
52385: PUSH
52386: LD_VAR 0 2
52390: ARRAY
52391: DIFF
52392: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52393: LD_ADDR_VAR 0 9
52397: PUSH
52398: LD_EXP 99
52402: PUSH
52403: LD_VAR 0 2
52407: ARRAY
52408: PPUSH
52409: LD_INT 2
52411: PUSH
52412: LD_INT 30
52414: PUSH
52415: LD_INT 0
52417: PUSH
52418: EMPTY
52419: LIST
52420: LIST
52421: PUSH
52422: LD_INT 30
52424: PUSH
52425: LD_INT 1
52427: PUSH
52428: EMPTY
52429: LIST
52430: LIST
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: LIST
52436: PPUSH
52437: CALL_OW 72
52441: ST_TO_ADDR
// if not tmp or not dep then
52442: LD_VAR 0 8
52446: NOT
52447: PUSH
52448: LD_VAR 0 9
52452: NOT
52453: OR
52454: IFFALSE 52458
// continue ;
52456: GO 52243
// side := GetSide ( tmp [ 1 ] ) ;
52458: LD_ADDR_VAR 0 11
52462: PUSH
52463: LD_VAR 0 8
52467: PUSH
52468: LD_INT 1
52470: ARRAY
52471: PPUSH
52472: CALL_OW 255
52476: ST_TO_ADDR
// dep := dep [ 1 ] ;
52477: LD_ADDR_VAR 0 9
52481: PUSH
52482: LD_VAR 0 9
52486: PUSH
52487: LD_INT 1
52489: ARRAY
52490: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52491: LD_ADDR_VAR 0 7
52495: PUSH
52496: LD_EXP 127
52500: PUSH
52501: LD_VAR 0 2
52505: ARRAY
52506: PPUSH
52507: LD_INT 22
52509: PUSH
52510: LD_INT 0
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PUSH
52517: LD_INT 25
52519: PUSH
52520: LD_INT 12
52522: PUSH
52523: EMPTY
52524: LIST
52525: LIST
52526: PUSH
52527: EMPTY
52528: LIST
52529: LIST
52530: PPUSH
52531: CALL_OW 70
52535: PUSH
52536: LD_INT 22
52538: PUSH
52539: LD_INT 0
52541: PUSH
52542: EMPTY
52543: LIST
52544: LIST
52545: PUSH
52546: LD_INT 25
52548: PUSH
52549: LD_INT 12
52551: PUSH
52552: EMPTY
52553: LIST
52554: LIST
52555: PUSH
52556: LD_INT 91
52558: PUSH
52559: LD_VAR 0 9
52563: PUSH
52564: LD_INT 20
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: LIST
52571: PUSH
52572: EMPTY
52573: LIST
52574: LIST
52575: LIST
52576: PPUSH
52577: CALL_OW 69
52581: UNION
52582: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52583: LD_ADDR_VAR 0 10
52587: PUSH
52588: LD_EXP 127
52592: PUSH
52593: LD_VAR 0 2
52597: ARRAY
52598: PPUSH
52599: LD_INT 81
52601: PUSH
52602: LD_VAR 0 11
52606: PUSH
52607: EMPTY
52608: LIST
52609: LIST
52610: PPUSH
52611: CALL_OW 70
52615: ST_TO_ADDR
// if not apes or danger_at_area then
52616: LD_VAR 0 7
52620: NOT
52621: PUSH
52622: LD_VAR 0 10
52626: OR
52627: IFFALSE 52677
// begin if mc_taming [ i ] then
52629: LD_EXP 130
52633: PUSH
52634: LD_VAR 0 2
52638: ARRAY
52639: IFFALSE 52675
// begin MC_Reset ( i , 121 ) ;
52641: LD_VAR 0 2
52645: PPUSH
52646: LD_INT 121
52648: PPUSH
52649: CALL 38008 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52653: LD_ADDR_EXP 130
52657: PUSH
52658: LD_EXP 130
52662: PPUSH
52663: LD_VAR 0 2
52667: PPUSH
52668: EMPTY
52669: PPUSH
52670: CALL_OW 1
52674: ST_TO_ADDR
// end ; continue ;
52675: GO 52243
// end ; for j in tmp do
52677: LD_ADDR_VAR 0 3
52681: PUSH
52682: LD_VAR 0 8
52686: PUSH
52687: FOR_IN
52688: IFFALSE 53024
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52690: LD_VAR 0 3
52694: PUSH
52695: LD_EXP 130
52699: PUSH
52700: LD_VAR 0 2
52704: ARRAY
52705: IN
52706: NOT
52707: PUSH
52708: LD_EXP 130
52712: PUSH
52713: LD_VAR 0 2
52717: ARRAY
52718: PUSH
52719: LD_INT 3
52721: LESS
52722: AND
52723: IFFALSE 52781
// begin SetTag ( j , 121 ) ;
52725: LD_VAR 0 3
52729: PPUSH
52730: LD_INT 121
52732: PPUSH
52733: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52737: LD_ADDR_EXP 130
52741: PUSH
52742: LD_EXP 130
52746: PPUSH
52747: LD_VAR 0 2
52751: PUSH
52752: LD_EXP 130
52756: PUSH
52757: LD_VAR 0 2
52761: ARRAY
52762: PUSH
52763: LD_INT 1
52765: PLUS
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: PPUSH
52771: LD_VAR 0 3
52775: PPUSH
52776: CALL 71221 0 3
52780: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52781: LD_VAR 0 3
52785: PUSH
52786: LD_EXP 130
52790: PUSH
52791: LD_VAR 0 2
52795: ARRAY
52796: IN
52797: IFFALSE 53022
// begin if GetClass ( j ) <> 4 then
52799: LD_VAR 0 3
52803: PPUSH
52804: CALL_OW 257
52808: PUSH
52809: LD_INT 4
52811: NONEQUAL
52812: IFFALSE 52865
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52814: LD_ADDR_EXP 130
52818: PUSH
52819: LD_EXP 130
52823: PPUSH
52824: LD_VAR 0 2
52828: PPUSH
52829: LD_EXP 130
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: PUSH
52840: LD_VAR 0 3
52844: DIFF
52845: PPUSH
52846: CALL_OW 1
52850: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52851: LD_VAR 0 3
52855: PPUSH
52856: LD_INT 0
52858: PPUSH
52859: CALL_OW 109
// continue ;
52863: GO 52687
// end ; if IsInUnit ( j ) then
52865: LD_VAR 0 3
52869: PPUSH
52870: CALL_OW 310
52874: IFFALSE 52885
// ComExitBuilding ( j ) ;
52876: LD_VAR 0 3
52880: PPUSH
52881: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52885: LD_ADDR_VAR 0 6
52889: PUSH
52890: LD_VAR 0 7
52894: PPUSH
52895: LD_VAR 0 3
52899: PPUSH
52900: CALL_OW 74
52904: ST_TO_ADDR
// if not ape then
52905: LD_VAR 0 6
52909: NOT
52910: IFFALSE 52914
// break ;
52912: GO 53024
// x := GetX ( ape ) ;
52914: LD_ADDR_VAR 0 4
52918: PUSH
52919: LD_VAR 0 6
52923: PPUSH
52924: CALL_OW 250
52928: ST_TO_ADDR
// y := GetY ( ape ) ;
52929: LD_ADDR_VAR 0 5
52933: PUSH
52934: LD_VAR 0 6
52938: PPUSH
52939: CALL_OW 251
52943: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52944: LD_VAR 0 4
52948: PPUSH
52949: LD_VAR 0 5
52953: PPUSH
52954: CALL_OW 488
52958: NOT
52959: PUSH
52960: LD_VAR 0 11
52964: PPUSH
52965: LD_VAR 0 4
52969: PPUSH
52970: LD_VAR 0 5
52974: PPUSH
52975: LD_INT 20
52977: PPUSH
52978: CALL 72117 0 4
52982: PUSH
52983: LD_INT 4
52985: ARRAY
52986: OR
52987: IFFALSE 52991
// break ;
52989: GO 53024
// if not HasTask ( j ) then
52991: LD_VAR 0 3
52995: PPUSH
52996: CALL_OW 314
53000: NOT
53001: IFFALSE 53022
// ComTameXY ( j , x , y ) ;
53003: LD_VAR 0 3
53007: PPUSH
53008: LD_VAR 0 4
53012: PPUSH
53013: LD_VAR 0 5
53017: PPUSH
53018: CALL_OW 131
// end ; end ;
53022: GO 52687
53024: POP
53025: POP
// end ;
53026: GO 52243
53028: POP
53029: POP
// end ;
53030: LD_VAR 0 1
53034: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53035: LD_INT 0
53037: PPUSH
53038: PPUSH
53039: PPUSH
53040: PPUSH
53041: PPUSH
53042: PPUSH
53043: PPUSH
53044: PPUSH
// if not mc_bases then
53045: LD_EXP 99
53049: NOT
53050: IFFALSE 53054
// exit ;
53052: GO 53680
// for i = 1 to mc_bases do
53054: LD_ADDR_VAR 0 2
53058: PUSH
53059: DOUBLE
53060: LD_INT 1
53062: DEC
53063: ST_TO_ADDR
53064: LD_EXP 99
53068: PUSH
53069: FOR_TO
53070: IFFALSE 53678
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53072: LD_EXP 128
53076: PUSH
53077: LD_VAR 0 2
53081: ARRAY
53082: NOT
53083: PUSH
53084: LD_EXP 128
53088: PUSH
53089: LD_VAR 0 2
53093: ARRAY
53094: PPUSH
53095: LD_INT 25
53097: PUSH
53098: LD_INT 12
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PPUSH
53105: CALL_OW 72
53109: NOT
53110: OR
53111: IFFALSE 53115
// continue ;
53113: GO 53069
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53115: LD_ADDR_VAR 0 5
53119: PUSH
53120: LD_EXP 128
53124: PUSH
53125: LD_VAR 0 2
53129: ARRAY
53130: PUSH
53131: LD_INT 1
53133: ARRAY
53134: PPUSH
53135: CALL_OW 255
53139: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53140: LD_VAR 0 5
53144: PPUSH
53145: LD_INT 2
53147: PPUSH
53148: CALL_OW 325
53152: IFFALSE 53405
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53154: LD_ADDR_VAR 0 4
53158: PUSH
53159: LD_EXP 128
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PPUSH
53170: LD_INT 25
53172: PUSH
53173: LD_INT 16
53175: PUSH
53176: EMPTY
53177: LIST
53178: LIST
53179: PPUSH
53180: CALL_OW 72
53184: ST_TO_ADDR
// if tmp < 6 then
53185: LD_VAR 0 4
53189: PUSH
53190: LD_INT 6
53192: LESS
53193: IFFALSE 53405
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53195: LD_ADDR_VAR 0 6
53199: PUSH
53200: LD_EXP 99
53204: PUSH
53205: LD_VAR 0 2
53209: ARRAY
53210: PPUSH
53211: LD_INT 2
53213: PUSH
53214: LD_INT 30
53216: PUSH
53217: LD_INT 0
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: PUSH
53224: LD_INT 30
53226: PUSH
53227: LD_INT 1
53229: PUSH
53230: EMPTY
53231: LIST
53232: LIST
53233: PUSH
53234: EMPTY
53235: LIST
53236: LIST
53237: LIST
53238: PPUSH
53239: CALL_OW 72
53243: ST_TO_ADDR
// if depot then
53244: LD_VAR 0 6
53248: IFFALSE 53405
// begin selected := 0 ;
53250: LD_ADDR_VAR 0 7
53254: PUSH
53255: LD_INT 0
53257: ST_TO_ADDR
// for j in depot do
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_VAR 0 6
53267: PUSH
53268: FOR_IN
53269: IFFALSE 53300
// begin if UnitsInside ( j ) < 6 then
53271: LD_VAR 0 3
53275: PPUSH
53276: CALL_OW 313
53280: PUSH
53281: LD_INT 6
53283: LESS
53284: IFFALSE 53298
// begin selected := j ;
53286: LD_ADDR_VAR 0 7
53290: PUSH
53291: LD_VAR 0 3
53295: ST_TO_ADDR
// break ;
53296: GO 53300
// end ; end ;
53298: GO 53268
53300: POP
53301: POP
// if selected then
53302: LD_VAR 0 7
53306: IFFALSE 53405
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53308: LD_ADDR_VAR 0 3
53312: PUSH
53313: LD_EXP 128
53317: PUSH
53318: LD_VAR 0 2
53322: ARRAY
53323: PPUSH
53324: LD_INT 25
53326: PUSH
53327: LD_INT 12
53329: PUSH
53330: EMPTY
53331: LIST
53332: LIST
53333: PPUSH
53334: CALL_OW 72
53338: PUSH
53339: FOR_IN
53340: IFFALSE 53403
// if not HasTask ( j ) then
53342: LD_VAR 0 3
53346: PPUSH
53347: CALL_OW 314
53351: NOT
53352: IFFALSE 53401
// begin if not IsInUnit ( j ) then
53354: LD_VAR 0 3
53358: PPUSH
53359: CALL_OW 310
53363: NOT
53364: IFFALSE 53380
// ComEnterUnit ( j , selected ) ;
53366: LD_VAR 0 3
53370: PPUSH
53371: LD_VAR 0 7
53375: PPUSH
53376: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53380: LD_VAR 0 3
53384: PPUSH
53385: LD_INT 16
53387: PPUSH
53388: CALL_OW 183
// AddComExitBuilding ( j ) ;
53392: LD_VAR 0 3
53396: PPUSH
53397: CALL_OW 182
// end ;
53401: GO 53339
53403: POP
53404: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53405: LD_VAR 0 5
53409: PPUSH
53410: LD_INT 11
53412: PPUSH
53413: CALL_OW 325
53417: IFFALSE 53676
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53419: LD_ADDR_VAR 0 4
53423: PUSH
53424: LD_EXP 128
53428: PUSH
53429: LD_VAR 0 2
53433: ARRAY
53434: PPUSH
53435: LD_INT 25
53437: PUSH
53438: LD_INT 16
53440: PUSH
53441: EMPTY
53442: LIST
53443: LIST
53444: PPUSH
53445: CALL_OW 72
53449: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53450: LD_VAR 0 4
53454: PUSH
53455: LD_INT 6
53457: GREATEREQUAL
53458: PUSH
53459: LD_VAR 0 5
53463: PPUSH
53464: LD_INT 2
53466: PPUSH
53467: CALL_OW 325
53471: NOT
53472: OR
53473: IFFALSE 53676
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53475: LD_ADDR_VAR 0 8
53479: PUSH
53480: LD_EXP 99
53484: PUSH
53485: LD_VAR 0 2
53489: ARRAY
53490: PPUSH
53491: LD_INT 2
53493: PUSH
53494: LD_INT 30
53496: PUSH
53497: LD_INT 4
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: PUSH
53504: LD_INT 30
53506: PUSH
53507: LD_INT 5
53509: PUSH
53510: EMPTY
53511: LIST
53512: LIST
53513: PUSH
53514: EMPTY
53515: LIST
53516: LIST
53517: LIST
53518: PPUSH
53519: CALL_OW 72
53523: ST_TO_ADDR
// if barracks then
53524: LD_VAR 0 8
53528: IFFALSE 53676
// begin selected := 0 ;
53530: LD_ADDR_VAR 0 7
53534: PUSH
53535: LD_INT 0
53537: ST_TO_ADDR
// for j in barracks do
53538: LD_ADDR_VAR 0 3
53542: PUSH
53543: LD_VAR 0 8
53547: PUSH
53548: FOR_IN
53549: IFFALSE 53580
// begin if UnitsInside ( j ) < 6 then
53551: LD_VAR 0 3
53555: PPUSH
53556: CALL_OW 313
53560: PUSH
53561: LD_INT 6
53563: LESS
53564: IFFALSE 53578
// begin selected := j ;
53566: LD_ADDR_VAR 0 7
53570: PUSH
53571: LD_VAR 0 3
53575: ST_TO_ADDR
// break ;
53576: GO 53580
// end ; end ;
53578: GO 53548
53580: POP
53581: POP
// if selected then
53582: LD_VAR 0 7
53586: IFFALSE 53676
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53588: LD_ADDR_VAR 0 3
53592: PUSH
53593: LD_EXP 128
53597: PUSH
53598: LD_VAR 0 2
53602: ARRAY
53603: PPUSH
53604: LD_INT 25
53606: PUSH
53607: LD_INT 12
53609: PUSH
53610: EMPTY
53611: LIST
53612: LIST
53613: PPUSH
53614: CALL_OW 72
53618: PUSH
53619: FOR_IN
53620: IFFALSE 53674
// if not IsInUnit ( j ) and not HasTask ( j ) then
53622: LD_VAR 0 3
53626: PPUSH
53627: CALL_OW 310
53631: NOT
53632: PUSH
53633: LD_VAR 0 3
53637: PPUSH
53638: CALL_OW 314
53642: NOT
53643: AND
53644: IFFALSE 53672
// begin ComEnterUnit ( j , selected ) ;
53646: LD_VAR 0 3
53650: PPUSH
53651: LD_VAR 0 7
53655: PPUSH
53656: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53660: LD_VAR 0 3
53664: PPUSH
53665: LD_INT 15
53667: PPUSH
53668: CALL_OW 183
// end ;
53672: GO 53619
53674: POP
53675: POP
// end ; end ; end ; end ; end ;
53676: GO 53069
53678: POP
53679: POP
// end ;
53680: LD_VAR 0 1
53684: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53685: LD_INT 0
53687: PPUSH
53688: PPUSH
53689: PPUSH
53690: PPUSH
// if not mc_bases then
53691: LD_EXP 99
53695: NOT
53696: IFFALSE 53700
// exit ;
53698: GO 53878
// for i = 1 to mc_bases do
53700: LD_ADDR_VAR 0 2
53704: PUSH
53705: DOUBLE
53706: LD_INT 1
53708: DEC
53709: ST_TO_ADDR
53710: LD_EXP 99
53714: PUSH
53715: FOR_TO
53716: IFFALSE 53876
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53718: LD_ADDR_VAR 0 4
53722: PUSH
53723: LD_EXP 99
53727: PUSH
53728: LD_VAR 0 2
53732: ARRAY
53733: PPUSH
53734: LD_INT 25
53736: PUSH
53737: LD_INT 9
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: PPUSH
53744: CALL_OW 72
53748: ST_TO_ADDR
// if not tmp then
53749: LD_VAR 0 4
53753: NOT
53754: IFFALSE 53758
// continue ;
53756: GO 53715
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53758: LD_EXP 125
53762: PUSH
53763: LD_VAR 0 2
53767: ARRAY
53768: PPUSH
53769: LD_INT 29
53771: PPUSH
53772: CALL_OW 325
53776: NOT
53777: PUSH
53778: LD_EXP 125
53782: PUSH
53783: LD_VAR 0 2
53787: ARRAY
53788: PPUSH
53789: LD_INT 28
53791: PPUSH
53792: CALL_OW 325
53796: NOT
53797: AND
53798: IFFALSE 53802
// continue ;
53800: GO 53715
// for j in tmp do
53802: LD_ADDR_VAR 0 3
53806: PUSH
53807: LD_VAR 0 4
53811: PUSH
53812: FOR_IN
53813: IFFALSE 53872
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53815: LD_VAR 0 3
53819: PUSH
53820: LD_EXP 102
53824: PUSH
53825: LD_VAR 0 2
53829: ARRAY
53830: PUSH
53831: LD_INT 1
53833: ARRAY
53834: IN
53835: NOT
53836: PUSH
53837: LD_VAR 0 3
53841: PUSH
53842: LD_EXP 102
53846: PUSH
53847: LD_VAR 0 2
53851: ARRAY
53852: PUSH
53853: LD_INT 2
53855: ARRAY
53856: IN
53857: NOT
53858: AND
53859: IFFALSE 53870
// ComSpaceTimeShoot ( j ) ;
53861: LD_VAR 0 3
53865: PPUSH
53866: CALL 64896 0 1
53870: GO 53812
53872: POP
53873: POP
// end ;
53874: GO 53715
53876: POP
53877: POP
// end ;
53878: LD_VAR 0 1
53882: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53883: LD_INT 0
53885: PPUSH
53886: PPUSH
53887: PPUSH
53888: PPUSH
53889: PPUSH
53890: PPUSH
53891: PPUSH
53892: PPUSH
53893: PPUSH
// if not mc_bases then
53894: LD_EXP 99
53898: NOT
53899: IFFALSE 53903
// exit ;
53901: GO 54525
// for i = 1 to mc_bases do
53903: LD_ADDR_VAR 0 2
53907: PUSH
53908: DOUBLE
53909: LD_INT 1
53911: DEC
53912: ST_TO_ADDR
53913: LD_EXP 99
53917: PUSH
53918: FOR_TO
53919: IFFALSE 54523
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53921: LD_EXP 134
53925: PUSH
53926: LD_VAR 0 2
53930: ARRAY
53931: NOT
53932: PUSH
53933: LD_INT 38
53935: PPUSH
53936: LD_EXP 125
53940: PUSH
53941: LD_VAR 0 2
53945: ARRAY
53946: PPUSH
53947: CALL_OW 321
53951: PUSH
53952: LD_INT 2
53954: NONEQUAL
53955: OR
53956: IFFALSE 53960
// continue ;
53958: GO 53918
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53960: LD_ADDR_VAR 0 8
53964: PUSH
53965: LD_EXP 99
53969: PUSH
53970: LD_VAR 0 2
53974: ARRAY
53975: PPUSH
53976: LD_INT 30
53978: PUSH
53979: LD_INT 34
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: PPUSH
53986: CALL_OW 72
53990: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53991: LD_ADDR_VAR 0 9
53995: PUSH
53996: LD_EXP 99
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: PPUSH
54007: LD_INT 25
54009: PUSH
54010: LD_INT 4
54012: PUSH
54013: EMPTY
54014: LIST
54015: LIST
54016: PPUSH
54017: CALL_OW 72
54021: PPUSH
54022: LD_INT 0
54024: PPUSH
54025: CALL 104481 0 2
54029: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54030: LD_VAR 0 9
54034: NOT
54035: PUSH
54036: LD_VAR 0 8
54040: NOT
54041: OR
54042: PUSH
54043: LD_EXP 99
54047: PUSH
54048: LD_VAR 0 2
54052: ARRAY
54053: PPUSH
54054: LD_INT 124
54056: PPUSH
54057: CALL 104481 0 2
54061: OR
54062: IFFALSE 54066
// continue ;
54064: GO 53918
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54066: LD_EXP 135
54070: PUSH
54071: LD_VAR 0 2
54075: ARRAY
54076: PUSH
54077: LD_EXP 134
54081: PUSH
54082: LD_VAR 0 2
54086: ARRAY
54087: LESS
54088: PUSH
54089: LD_EXP 135
54093: PUSH
54094: LD_VAR 0 2
54098: ARRAY
54099: PUSH
54100: LD_VAR 0 8
54104: LESS
54105: AND
54106: IFFALSE 54521
// begin tmp := sci [ 1 ] ;
54108: LD_ADDR_VAR 0 7
54112: PUSH
54113: LD_VAR 0 9
54117: PUSH
54118: LD_INT 1
54120: ARRAY
54121: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54122: LD_VAR 0 7
54126: PPUSH
54127: LD_INT 124
54129: PPUSH
54130: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54134: LD_ADDR_VAR 0 3
54138: PUSH
54139: DOUBLE
54140: LD_EXP 134
54144: PUSH
54145: LD_VAR 0 2
54149: ARRAY
54150: INC
54151: ST_TO_ADDR
54152: LD_EXP 134
54156: PUSH
54157: LD_VAR 0 2
54161: ARRAY
54162: PUSH
54163: FOR_DOWNTO
54164: IFFALSE 54507
// begin if IsInUnit ( tmp ) then
54166: LD_VAR 0 7
54170: PPUSH
54171: CALL_OW 310
54175: IFFALSE 54186
// ComExitBuilding ( tmp ) ;
54177: LD_VAR 0 7
54181: PPUSH
54182: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54186: LD_INT 35
54188: PPUSH
54189: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54193: LD_VAR 0 7
54197: PPUSH
54198: CALL_OW 310
54202: NOT
54203: PUSH
54204: LD_VAR 0 7
54208: PPUSH
54209: CALL_OW 314
54213: NOT
54214: AND
54215: IFFALSE 54186
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54217: LD_ADDR_VAR 0 6
54221: PUSH
54222: LD_VAR 0 7
54226: PPUSH
54227: CALL_OW 250
54231: PUSH
54232: LD_VAR 0 7
54236: PPUSH
54237: CALL_OW 251
54241: PUSH
54242: EMPTY
54243: LIST
54244: LIST
54245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54246: LD_INT 35
54248: PPUSH
54249: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54253: LD_ADDR_VAR 0 4
54257: PUSH
54258: LD_EXP 134
54262: PUSH
54263: LD_VAR 0 2
54267: ARRAY
54268: PUSH
54269: LD_VAR 0 3
54273: ARRAY
54274: PUSH
54275: LD_INT 1
54277: ARRAY
54278: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54279: LD_ADDR_VAR 0 5
54283: PUSH
54284: LD_EXP 134
54288: PUSH
54289: LD_VAR 0 2
54293: ARRAY
54294: PUSH
54295: LD_VAR 0 3
54299: ARRAY
54300: PUSH
54301: LD_INT 2
54303: ARRAY
54304: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54305: LD_VAR 0 7
54309: PPUSH
54310: LD_INT 10
54312: PPUSH
54313: CALL 73814 0 2
54317: PUSH
54318: LD_INT 4
54320: ARRAY
54321: IFFALSE 54359
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54323: LD_VAR 0 7
54327: PPUSH
54328: LD_VAR 0 6
54332: PUSH
54333: LD_INT 1
54335: ARRAY
54336: PPUSH
54337: LD_VAR 0 6
54341: PUSH
54342: LD_INT 2
54344: ARRAY
54345: PPUSH
54346: CALL_OW 111
// wait ( 0 0$10 ) ;
54350: LD_INT 350
54352: PPUSH
54353: CALL_OW 67
// end else
54357: GO 54385
// begin ComMoveXY ( tmp , x , y ) ;
54359: LD_VAR 0 7
54363: PPUSH
54364: LD_VAR 0 4
54368: PPUSH
54369: LD_VAR 0 5
54373: PPUSH
54374: CALL_OW 111
// wait ( 0 0$3 ) ;
54378: LD_INT 105
54380: PPUSH
54381: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54385: LD_VAR 0 7
54389: PPUSH
54390: LD_VAR 0 4
54394: PPUSH
54395: LD_VAR 0 5
54399: PPUSH
54400: CALL_OW 307
54404: IFFALSE 54246
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54406: LD_VAR 0 7
54410: PPUSH
54411: LD_VAR 0 4
54415: PPUSH
54416: LD_VAR 0 5
54420: PPUSH
54421: LD_VAR 0 8
54425: PUSH
54426: LD_VAR 0 3
54430: ARRAY
54431: PPUSH
54432: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54436: LD_INT 35
54438: PPUSH
54439: CALL_OW 67
// until not HasTask ( tmp ) ;
54443: LD_VAR 0 7
54447: PPUSH
54448: CALL_OW 314
54452: NOT
54453: IFFALSE 54436
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54455: LD_ADDR_EXP 135
54459: PUSH
54460: LD_EXP 135
54464: PPUSH
54465: LD_VAR 0 2
54469: PUSH
54470: LD_EXP 135
54474: PUSH
54475: LD_VAR 0 2
54479: ARRAY
54480: PUSH
54481: LD_INT 1
54483: PLUS
54484: PUSH
54485: EMPTY
54486: LIST
54487: LIST
54488: PPUSH
54489: LD_VAR 0 8
54493: PUSH
54494: LD_VAR 0 3
54498: ARRAY
54499: PPUSH
54500: CALL 71221 0 3
54504: ST_TO_ADDR
// end ;
54505: GO 54163
54507: POP
54508: POP
// MC_Reset ( i , 124 ) ;
54509: LD_VAR 0 2
54513: PPUSH
54514: LD_INT 124
54516: PPUSH
54517: CALL 38008 0 2
// end ; end ;
54521: GO 53918
54523: POP
54524: POP
// end ;
54525: LD_VAR 0 1
54529: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54530: LD_INT 0
54532: PPUSH
54533: PPUSH
54534: PPUSH
// if not mc_bases then
54535: LD_EXP 99
54539: NOT
54540: IFFALSE 54544
// exit ;
54542: GO 55150
// for i = 1 to mc_bases do
54544: LD_ADDR_VAR 0 2
54548: PUSH
54549: DOUBLE
54550: LD_INT 1
54552: DEC
54553: ST_TO_ADDR
54554: LD_EXP 99
54558: PUSH
54559: FOR_TO
54560: IFFALSE 55148
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54562: LD_ADDR_VAR 0 3
54566: PUSH
54567: LD_EXP 99
54571: PUSH
54572: LD_VAR 0 2
54576: ARRAY
54577: PPUSH
54578: LD_INT 25
54580: PUSH
54581: LD_INT 4
54583: PUSH
54584: EMPTY
54585: LIST
54586: LIST
54587: PPUSH
54588: CALL_OW 72
54592: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54593: LD_VAR 0 3
54597: NOT
54598: PUSH
54599: LD_EXP 136
54603: PUSH
54604: LD_VAR 0 2
54608: ARRAY
54609: NOT
54610: OR
54611: PUSH
54612: LD_EXP 99
54616: PUSH
54617: LD_VAR 0 2
54621: ARRAY
54622: PPUSH
54623: LD_INT 2
54625: PUSH
54626: LD_INT 30
54628: PUSH
54629: LD_INT 0
54631: PUSH
54632: EMPTY
54633: LIST
54634: LIST
54635: PUSH
54636: LD_INT 30
54638: PUSH
54639: LD_INT 1
54641: PUSH
54642: EMPTY
54643: LIST
54644: LIST
54645: PUSH
54646: EMPTY
54647: LIST
54648: LIST
54649: LIST
54650: PPUSH
54651: CALL_OW 72
54655: NOT
54656: OR
54657: IFFALSE 54707
// begin if mc_deposits_finder [ i ] then
54659: LD_EXP 137
54663: PUSH
54664: LD_VAR 0 2
54668: ARRAY
54669: IFFALSE 54705
// begin MC_Reset ( i , 125 ) ;
54671: LD_VAR 0 2
54675: PPUSH
54676: LD_INT 125
54678: PPUSH
54679: CALL 38008 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54683: LD_ADDR_EXP 137
54687: PUSH
54688: LD_EXP 137
54692: PPUSH
54693: LD_VAR 0 2
54697: PPUSH
54698: EMPTY
54699: PPUSH
54700: CALL_OW 1
54704: ST_TO_ADDR
// end ; continue ;
54705: GO 54559
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54707: LD_EXP 136
54711: PUSH
54712: LD_VAR 0 2
54716: ARRAY
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 3
54724: ARRAY
54725: PUSH
54726: LD_INT 1
54728: EQUAL
54729: PUSH
54730: LD_INT 20
54732: PPUSH
54733: LD_EXP 125
54737: PUSH
54738: LD_VAR 0 2
54742: ARRAY
54743: PPUSH
54744: CALL_OW 321
54748: PUSH
54749: LD_INT 2
54751: NONEQUAL
54752: AND
54753: IFFALSE 54803
// begin if mc_deposits_finder [ i ] then
54755: LD_EXP 137
54759: PUSH
54760: LD_VAR 0 2
54764: ARRAY
54765: IFFALSE 54801
// begin MC_Reset ( i , 125 ) ;
54767: LD_VAR 0 2
54771: PPUSH
54772: LD_INT 125
54774: PPUSH
54775: CALL 38008 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54779: LD_ADDR_EXP 137
54783: PUSH
54784: LD_EXP 137
54788: PPUSH
54789: LD_VAR 0 2
54793: PPUSH
54794: EMPTY
54795: PPUSH
54796: CALL_OW 1
54800: ST_TO_ADDR
// end ; continue ;
54801: GO 54559
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54803: LD_EXP 136
54807: PUSH
54808: LD_VAR 0 2
54812: ARRAY
54813: PUSH
54814: LD_INT 1
54816: ARRAY
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: PPUSH
54822: LD_EXP 136
54826: PUSH
54827: LD_VAR 0 2
54831: ARRAY
54832: PUSH
54833: LD_INT 1
54835: ARRAY
54836: PUSH
54837: LD_INT 2
54839: ARRAY
54840: PPUSH
54841: LD_EXP 125
54845: PUSH
54846: LD_VAR 0 2
54850: ARRAY
54851: PPUSH
54852: CALL_OW 440
54856: IFFALSE 54899
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54858: LD_ADDR_EXP 136
54862: PUSH
54863: LD_EXP 136
54867: PPUSH
54868: LD_VAR 0 2
54872: PPUSH
54873: LD_EXP 136
54877: PUSH
54878: LD_VAR 0 2
54882: ARRAY
54883: PPUSH
54884: LD_INT 1
54886: PPUSH
54887: CALL_OW 3
54891: PPUSH
54892: CALL_OW 1
54896: ST_TO_ADDR
54897: GO 55146
// begin if not mc_deposits_finder [ i ] then
54899: LD_EXP 137
54903: PUSH
54904: LD_VAR 0 2
54908: ARRAY
54909: NOT
54910: IFFALSE 54962
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54912: LD_ADDR_EXP 137
54916: PUSH
54917: LD_EXP 137
54921: PPUSH
54922: LD_VAR 0 2
54926: PPUSH
54927: LD_VAR 0 3
54931: PUSH
54932: LD_INT 1
54934: ARRAY
54935: PUSH
54936: EMPTY
54937: LIST
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54944: LD_VAR 0 3
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PPUSH
54953: LD_INT 125
54955: PPUSH
54956: CALL_OW 109
// end else
54960: GO 55146
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54962: LD_EXP 137
54966: PUSH
54967: LD_VAR 0 2
54971: ARRAY
54972: PUSH
54973: LD_INT 1
54975: ARRAY
54976: PPUSH
54977: CALL_OW 310
54981: IFFALSE 55004
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54983: LD_EXP 137
54987: PUSH
54988: LD_VAR 0 2
54992: ARRAY
54993: PUSH
54994: LD_INT 1
54996: ARRAY
54997: PPUSH
54998: CALL_OW 122
55002: GO 55146
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55004: LD_EXP 137
55008: PUSH
55009: LD_VAR 0 2
55013: ARRAY
55014: PUSH
55015: LD_INT 1
55017: ARRAY
55018: PPUSH
55019: CALL_OW 314
55023: NOT
55024: PUSH
55025: LD_EXP 137
55029: PUSH
55030: LD_VAR 0 2
55034: ARRAY
55035: PUSH
55036: LD_INT 1
55038: ARRAY
55039: PPUSH
55040: LD_EXP 136
55044: PUSH
55045: LD_VAR 0 2
55049: ARRAY
55050: PUSH
55051: LD_INT 1
55053: ARRAY
55054: PUSH
55055: LD_INT 1
55057: ARRAY
55058: PPUSH
55059: LD_EXP 136
55063: PUSH
55064: LD_VAR 0 2
55068: ARRAY
55069: PUSH
55070: LD_INT 1
55072: ARRAY
55073: PUSH
55074: LD_INT 2
55076: ARRAY
55077: PPUSH
55078: CALL_OW 297
55082: PUSH
55083: LD_INT 6
55085: GREATER
55086: AND
55087: IFFALSE 55146
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55089: LD_EXP 137
55093: PUSH
55094: LD_VAR 0 2
55098: ARRAY
55099: PUSH
55100: LD_INT 1
55102: ARRAY
55103: PPUSH
55104: LD_EXP 136
55108: PUSH
55109: LD_VAR 0 2
55113: ARRAY
55114: PUSH
55115: LD_INT 1
55117: ARRAY
55118: PUSH
55119: LD_INT 1
55121: ARRAY
55122: PPUSH
55123: LD_EXP 136
55127: PUSH
55128: LD_VAR 0 2
55132: ARRAY
55133: PUSH
55134: LD_INT 1
55136: ARRAY
55137: PUSH
55138: LD_INT 2
55140: ARRAY
55141: PPUSH
55142: CALL_OW 111
// end ; end ; end ;
55146: GO 54559
55148: POP
55149: POP
// end ;
55150: LD_VAR 0 1
55154: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55155: LD_INT 0
55157: PPUSH
55158: PPUSH
55159: PPUSH
55160: PPUSH
55161: PPUSH
55162: PPUSH
55163: PPUSH
55164: PPUSH
55165: PPUSH
55166: PPUSH
55167: PPUSH
// if not mc_bases then
55168: LD_EXP 99
55172: NOT
55173: IFFALSE 55177
// exit ;
55175: GO 56117
// for i = 1 to mc_bases do
55177: LD_ADDR_VAR 0 2
55181: PUSH
55182: DOUBLE
55183: LD_INT 1
55185: DEC
55186: ST_TO_ADDR
55187: LD_EXP 99
55191: PUSH
55192: FOR_TO
55193: IFFALSE 56115
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55195: LD_EXP 99
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: NOT
55206: PUSH
55207: LD_EXP 122
55211: PUSH
55212: LD_VAR 0 2
55216: ARRAY
55217: OR
55218: IFFALSE 55222
// continue ;
55220: GO 55192
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55222: LD_ADDR_VAR 0 7
55226: PUSH
55227: LD_EXP 99
55231: PUSH
55232: LD_VAR 0 2
55236: ARRAY
55237: PUSH
55238: LD_INT 1
55240: ARRAY
55241: PPUSH
55242: CALL_OW 248
55246: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55247: LD_VAR 0 7
55251: PUSH
55252: LD_INT 3
55254: EQUAL
55255: PUSH
55256: LD_EXP 118
55260: PUSH
55261: LD_VAR 0 2
55265: ARRAY
55266: PUSH
55267: LD_EXP 121
55271: PUSH
55272: LD_VAR 0 2
55276: ARRAY
55277: UNION
55278: PPUSH
55279: LD_INT 33
55281: PUSH
55282: LD_INT 2
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: PPUSH
55289: CALL_OW 72
55293: NOT
55294: OR
55295: IFFALSE 55299
// continue ;
55297: GO 55192
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55299: LD_ADDR_VAR 0 9
55303: PUSH
55304: LD_EXP 99
55308: PUSH
55309: LD_VAR 0 2
55313: ARRAY
55314: PPUSH
55315: LD_INT 30
55317: PUSH
55318: LD_INT 36
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: PPUSH
55325: CALL_OW 72
55329: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55330: LD_ADDR_VAR 0 10
55334: PUSH
55335: LD_EXP 118
55339: PUSH
55340: LD_VAR 0 2
55344: ARRAY
55345: PPUSH
55346: LD_INT 34
55348: PUSH
55349: LD_INT 31
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: PPUSH
55356: CALL_OW 72
55360: ST_TO_ADDR
// if not cts and not mcts then
55361: LD_VAR 0 9
55365: NOT
55366: PUSH
55367: LD_VAR 0 10
55371: NOT
55372: AND
55373: IFFALSE 55377
// continue ;
55375: GO 55192
// x := cts ;
55377: LD_ADDR_VAR 0 11
55381: PUSH
55382: LD_VAR 0 9
55386: ST_TO_ADDR
// if not x then
55387: LD_VAR 0 11
55391: NOT
55392: IFFALSE 55404
// x := mcts ;
55394: LD_ADDR_VAR 0 11
55398: PUSH
55399: LD_VAR 0 10
55403: ST_TO_ADDR
// if not x then
55404: LD_VAR 0 11
55408: NOT
55409: IFFALSE 55413
// continue ;
55411: GO 55192
// if mc_remote_driver [ i ] then
55413: LD_EXP 139
55417: PUSH
55418: LD_VAR 0 2
55422: ARRAY
55423: IFFALSE 55810
// for j in mc_remote_driver [ i ] do
55425: LD_ADDR_VAR 0 3
55429: PUSH
55430: LD_EXP 139
55434: PUSH
55435: LD_VAR 0 2
55439: ARRAY
55440: PUSH
55441: FOR_IN
55442: IFFALSE 55808
// begin if GetClass ( j ) <> 3 then
55444: LD_VAR 0 3
55448: PPUSH
55449: CALL_OW 257
55453: PUSH
55454: LD_INT 3
55456: NONEQUAL
55457: IFFALSE 55510
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55459: LD_ADDR_EXP 139
55463: PUSH
55464: LD_EXP 139
55468: PPUSH
55469: LD_VAR 0 2
55473: PPUSH
55474: LD_EXP 139
55478: PUSH
55479: LD_VAR 0 2
55483: ARRAY
55484: PUSH
55485: LD_VAR 0 3
55489: DIFF
55490: PPUSH
55491: CALL_OW 1
55495: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55496: LD_VAR 0 3
55500: PPUSH
55501: LD_INT 0
55503: PPUSH
55504: CALL_OW 109
// continue ;
55508: GO 55441
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55510: LD_EXP 118
55514: PUSH
55515: LD_VAR 0 2
55519: ARRAY
55520: PPUSH
55521: LD_INT 34
55523: PUSH
55524: LD_INT 31
55526: PUSH
55527: EMPTY
55528: LIST
55529: LIST
55530: PUSH
55531: LD_INT 58
55533: PUSH
55534: EMPTY
55535: LIST
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: PPUSH
55541: CALL_OW 72
55545: PUSH
55546: LD_VAR 0 3
55550: PPUSH
55551: CALL 104569 0 1
55555: NOT
55556: AND
55557: IFFALSE 55628
// begin if IsInUnit ( j ) then
55559: LD_VAR 0 3
55563: PPUSH
55564: CALL_OW 310
55568: IFFALSE 55579
// ComExitBuilding ( j ) ;
55570: LD_VAR 0 3
55574: PPUSH
55575: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55579: LD_VAR 0 3
55583: PPUSH
55584: LD_EXP 118
55588: PUSH
55589: LD_VAR 0 2
55593: ARRAY
55594: PPUSH
55595: LD_INT 34
55597: PUSH
55598: LD_INT 31
55600: PUSH
55601: EMPTY
55602: LIST
55603: LIST
55604: PUSH
55605: LD_INT 58
55607: PUSH
55608: EMPTY
55609: LIST
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: PPUSH
55615: CALL_OW 72
55619: PUSH
55620: LD_INT 1
55622: ARRAY
55623: PPUSH
55624: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55628: LD_VAR 0 3
55632: PPUSH
55633: CALL_OW 310
55637: NOT
55638: PUSH
55639: LD_VAR 0 3
55643: PPUSH
55644: CALL_OW 310
55648: PPUSH
55649: CALL_OW 266
55653: PUSH
55654: LD_INT 36
55656: NONEQUAL
55657: PUSH
55658: LD_VAR 0 3
55662: PPUSH
55663: CALL 104569 0 1
55667: NOT
55668: AND
55669: OR
55670: IFFALSE 55806
// begin if IsInUnit ( j ) then
55672: LD_VAR 0 3
55676: PPUSH
55677: CALL_OW 310
55681: IFFALSE 55692
// ComExitBuilding ( j ) ;
55683: LD_VAR 0 3
55687: PPUSH
55688: CALL_OW 122
// ct := 0 ;
55692: LD_ADDR_VAR 0 8
55696: PUSH
55697: LD_INT 0
55699: ST_TO_ADDR
// for k in x do
55700: LD_ADDR_VAR 0 4
55704: PUSH
55705: LD_VAR 0 11
55709: PUSH
55710: FOR_IN
55711: IFFALSE 55784
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55713: LD_VAR 0 4
55717: PPUSH
55718: CALL_OW 264
55722: PUSH
55723: LD_INT 31
55725: EQUAL
55726: PUSH
55727: LD_VAR 0 4
55731: PPUSH
55732: CALL_OW 311
55736: NOT
55737: AND
55738: PUSH
55739: LD_VAR 0 4
55743: PPUSH
55744: CALL_OW 266
55748: PUSH
55749: LD_INT 36
55751: EQUAL
55752: PUSH
55753: LD_VAR 0 4
55757: PPUSH
55758: CALL_OW 313
55762: PUSH
55763: LD_INT 3
55765: LESS
55766: AND
55767: OR
55768: IFFALSE 55782
// begin ct := k ;
55770: LD_ADDR_VAR 0 8
55774: PUSH
55775: LD_VAR 0 4
55779: ST_TO_ADDR
// break ;
55780: GO 55784
// end ;
55782: GO 55710
55784: POP
55785: POP
// if ct then
55786: LD_VAR 0 8
55790: IFFALSE 55806
// ComEnterUnit ( j , ct ) ;
55792: LD_VAR 0 3
55796: PPUSH
55797: LD_VAR 0 8
55801: PPUSH
55802: CALL_OW 120
// end ; end ;
55806: GO 55441
55808: POP
55809: POP
// places := 0 ;
55810: LD_ADDR_VAR 0 5
55814: PUSH
55815: LD_INT 0
55817: ST_TO_ADDR
// for j = 1 to x do
55818: LD_ADDR_VAR 0 3
55822: PUSH
55823: DOUBLE
55824: LD_INT 1
55826: DEC
55827: ST_TO_ADDR
55828: LD_VAR 0 11
55832: PUSH
55833: FOR_TO
55834: IFFALSE 55910
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55836: LD_VAR 0 11
55840: PUSH
55841: LD_VAR 0 3
55845: ARRAY
55846: PPUSH
55847: CALL_OW 264
55851: PUSH
55852: LD_INT 31
55854: EQUAL
55855: IFFALSE 55873
// places := places + 1 else
55857: LD_ADDR_VAR 0 5
55861: PUSH
55862: LD_VAR 0 5
55866: PUSH
55867: LD_INT 1
55869: PLUS
55870: ST_TO_ADDR
55871: GO 55908
// if GetBType ( x [ j ] ) = b_control_tower then
55873: LD_VAR 0 11
55877: PUSH
55878: LD_VAR 0 3
55882: ARRAY
55883: PPUSH
55884: CALL_OW 266
55888: PUSH
55889: LD_INT 36
55891: EQUAL
55892: IFFALSE 55908
// places := places + 3 ;
55894: LD_ADDR_VAR 0 5
55898: PUSH
55899: LD_VAR 0 5
55903: PUSH
55904: LD_INT 3
55906: PLUS
55907: ST_TO_ADDR
55908: GO 55833
55910: POP
55911: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
55912: LD_VAR 0 5
55916: PUSH
55917: LD_INT 0
55919: EQUAL
55920: PUSH
55921: LD_VAR 0 5
55925: PUSH
55926: LD_EXP 139
55930: PUSH
55931: LD_VAR 0 2
55935: ARRAY
55936: LESSEQUAL
55937: OR
55938: IFFALSE 55942
// continue ;
55940: GO 55192
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55942: LD_ADDR_VAR 0 6
55946: PUSH
55947: LD_EXP 99
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: PPUSH
55958: LD_INT 25
55960: PUSH
55961: LD_INT 3
55963: PUSH
55964: EMPTY
55965: LIST
55966: LIST
55967: PPUSH
55968: CALL_OW 72
55972: PUSH
55973: LD_EXP 139
55977: PUSH
55978: LD_VAR 0 2
55982: ARRAY
55983: DIFF
55984: PPUSH
55985: LD_INT 3
55987: PPUSH
55988: CALL 105469 0 2
55992: ST_TO_ADDR
// for j in tmp do
55993: LD_ADDR_VAR 0 3
55997: PUSH
55998: LD_VAR 0 6
56002: PUSH
56003: FOR_IN
56004: IFFALSE 56039
// if GetTag ( j ) > 0 then
56006: LD_VAR 0 3
56010: PPUSH
56011: CALL_OW 110
56015: PUSH
56016: LD_INT 0
56018: GREATER
56019: IFFALSE 56037
// tmp := tmp diff j ;
56021: LD_ADDR_VAR 0 6
56025: PUSH
56026: LD_VAR 0 6
56030: PUSH
56031: LD_VAR 0 3
56035: DIFF
56036: ST_TO_ADDR
56037: GO 56003
56039: POP
56040: POP
// if not tmp then
56041: LD_VAR 0 6
56045: NOT
56046: IFFALSE 56050
// continue ;
56048: GO 55192
// if places then
56050: LD_VAR 0 5
56054: IFFALSE 56113
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56056: LD_ADDR_EXP 139
56060: PUSH
56061: LD_EXP 139
56065: PPUSH
56066: LD_VAR 0 2
56070: PPUSH
56071: LD_EXP 139
56075: PUSH
56076: LD_VAR 0 2
56080: ARRAY
56081: PUSH
56082: LD_VAR 0 6
56086: PUSH
56087: LD_INT 1
56089: ARRAY
56090: UNION
56091: PPUSH
56092: CALL_OW 1
56096: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56097: LD_VAR 0 6
56101: PUSH
56102: LD_INT 1
56104: ARRAY
56105: PPUSH
56106: LD_INT 126
56108: PPUSH
56109: CALL_OW 109
// end ; end ;
56113: GO 55192
56115: POP
56116: POP
// end ;
56117: LD_VAR 0 1
56121: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56122: LD_INT 0
56124: PPUSH
56125: PPUSH
56126: PPUSH
56127: PPUSH
56128: PPUSH
56129: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56130: LD_VAR 0 1
56134: NOT
56135: PUSH
56136: LD_VAR 0 2
56140: NOT
56141: OR
56142: PUSH
56143: LD_VAR 0 3
56147: NOT
56148: OR
56149: PUSH
56150: LD_VAR 0 4
56154: PUSH
56155: LD_INT 1
56157: PUSH
56158: LD_INT 2
56160: PUSH
56161: LD_INT 3
56163: PUSH
56164: LD_INT 4
56166: PUSH
56167: LD_INT 5
56169: PUSH
56170: LD_INT 8
56172: PUSH
56173: LD_INT 9
56175: PUSH
56176: LD_INT 15
56178: PUSH
56179: LD_INT 16
56181: PUSH
56182: EMPTY
56183: LIST
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: IN
56193: NOT
56194: OR
56195: IFFALSE 56199
// exit ;
56197: GO 57099
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56199: LD_ADDR_VAR 0 2
56203: PUSH
56204: LD_VAR 0 2
56208: PPUSH
56209: LD_INT 21
56211: PUSH
56212: LD_INT 3
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: PUSH
56219: LD_INT 24
56221: PUSH
56222: LD_INT 250
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: PUSH
56229: EMPTY
56230: LIST
56231: LIST
56232: PPUSH
56233: CALL_OW 72
56237: ST_TO_ADDR
// case class of 1 , 15 :
56238: LD_VAR 0 4
56242: PUSH
56243: LD_INT 1
56245: DOUBLE
56246: EQUAL
56247: IFTRUE 56257
56249: LD_INT 15
56251: DOUBLE
56252: EQUAL
56253: IFTRUE 56257
56255: GO 56342
56257: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56258: LD_ADDR_VAR 0 8
56262: PUSH
56263: LD_VAR 0 2
56267: PPUSH
56268: LD_INT 2
56270: PUSH
56271: LD_INT 30
56273: PUSH
56274: LD_INT 32
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PUSH
56281: LD_INT 30
56283: PUSH
56284: LD_INT 31
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: LIST
56295: PPUSH
56296: CALL_OW 72
56300: PUSH
56301: LD_VAR 0 2
56305: PPUSH
56306: LD_INT 2
56308: PUSH
56309: LD_INT 30
56311: PUSH
56312: LD_INT 4
56314: PUSH
56315: EMPTY
56316: LIST
56317: LIST
56318: PUSH
56319: LD_INT 30
56321: PUSH
56322: LD_INT 5
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: LIST
56333: PPUSH
56334: CALL_OW 72
56338: ADD
56339: ST_TO_ADDR
56340: GO 56588
56342: LD_INT 2
56344: DOUBLE
56345: EQUAL
56346: IFTRUE 56356
56348: LD_INT 16
56350: DOUBLE
56351: EQUAL
56352: IFTRUE 56356
56354: GO 56402
56356: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56357: LD_ADDR_VAR 0 8
56361: PUSH
56362: LD_VAR 0 2
56366: PPUSH
56367: LD_INT 2
56369: PUSH
56370: LD_INT 30
56372: PUSH
56373: LD_INT 0
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: PUSH
56380: LD_INT 30
56382: PUSH
56383: LD_INT 1
56385: PUSH
56386: EMPTY
56387: LIST
56388: LIST
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: LIST
56394: PPUSH
56395: CALL_OW 72
56399: ST_TO_ADDR
56400: GO 56588
56402: LD_INT 3
56404: DOUBLE
56405: EQUAL
56406: IFTRUE 56410
56408: GO 56456
56410: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56411: LD_ADDR_VAR 0 8
56415: PUSH
56416: LD_VAR 0 2
56420: PPUSH
56421: LD_INT 2
56423: PUSH
56424: LD_INT 30
56426: PUSH
56427: LD_INT 2
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: PUSH
56434: LD_INT 30
56436: PUSH
56437: LD_INT 3
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: LIST
56448: PPUSH
56449: CALL_OW 72
56453: ST_TO_ADDR
56454: GO 56588
56456: LD_INT 4
56458: DOUBLE
56459: EQUAL
56460: IFTRUE 56464
56462: GO 56521
56464: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56465: LD_ADDR_VAR 0 8
56469: PUSH
56470: LD_VAR 0 2
56474: PPUSH
56475: LD_INT 2
56477: PUSH
56478: LD_INT 30
56480: PUSH
56481: LD_INT 6
56483: PUSH
56484: EMPTY
56485: LIST
56486: LIST
56487: PUSH
56488: LD_INT 30
56490: PUSH
56491: LD_INT 7
56493: PUSH
56494: EMPTY
56495: LIST
56496: LIST
56497: PUSH
56498: LD_INT 30
56500: PUSH
56501: LD_INT 8
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: LIST
56512: LIST
56513: PPUSH
56514: CALL_OW 72
56518: ST_TO_ADDR
56519: GO 56588
56521: LD_INT 5
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56541
56527: LD_INT 8
56529: DOUBLE
56530: EQUAL
56531: IFTRUE 56541
56533: LD_INT 9
56535: DOUBLE
56536: EQUAL
56537: IFTRUE 56541
56539: GO 56587
56541: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56542: LD_ADDR_VAR 0 8
56546: PUSH
56547: LD_VAR 0 2
56551: PPUSH
56552: LD_INT 2
56554: PUSH
56555: LD_INT 30
56557: PUSH
56558: LD_INT 4
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: PUSH
56565: LD_INT 30
56567: PUSH
56568: LD_INT 5
56570: PUSH
56571: EMPTY
56572: LIST
56573: LIST
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: LIST
56579: PPUSH
56580: CALL_OW 72
56584: ST_TO_ADDR
56585: GO 56588
56587: POP
// if not tmp then
56588: LD_VAR 0 8
56592: NOT
56593: IFFALSE 56597
// exit ;
56595: GO 57099
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56597: LD_VAR 0 4
56601: PUSH
56602: LD_INT 1
56604: PUSH
56605: LD_INT 15
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: IN
56612: PUSH
56613: LD_EXP 108
56617: PUSH
56618: LD_VAR 0 1
56622: ARRAY
56623: AND
56624: IFFALSE 56780
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56626: LD_ADDR_VAR 0 9
56630: PUSH
56631: LD_EXP 108
56635: PUSH
56636: LD_VAR 0 1
56640: ARRAY
56641: PUSH
56642: LD_INT 1
56644: ARRAY
56645: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56646: LD_VAR 0 9
56650: PUSH
56651: LD_EXP 109
56655: PUSH
56656: LD_VAR 0 1
56660: ARRAY
56661: IN
56662: NOT
56663: IFFALSE 56778
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56665: LD_ADDR_EXP 109
56669: PUSH
56670: LD_EXP 109
56674: PPUSH
56675: LD_VAR 0 1
56679: PUSH
56680: LD_EXP 109
56684: PUSH
56685: LD_VAR 0 1
56689: ARRAY
56690: PUSH
56691: LD_INT 1
56693: PLUS
56694: PUSH
56695: EMPTY
56696: LIST
56697: LIST
56698: PPUSH
56699: LD_VAR 0 9
56703: PPUSH
56704: CALL 71221 0 3
56708: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56709: LD_ADDR_EXP 108
56713: PUSH
56714: LD_EXP 108
56718: PPUSH
56719: LD_VAR 0 1
56723: PPUSH
56724: LD_EXP 108
56728: PUSH
56729: LD_VAR 0 1
56733: ARRAY
56734: PUSH
56735: LD_VAR 0 9
56739: DIFF
56740: PPUSH
56741: CALL_OW 1
56745: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56746: LD_VAR 0 3
56750: PPUSH
56751: LD_EXP 109
56755: PUSH
56756: LD_VAR 0 1
56760: ARRAY
56761: PUSH
56762: LD_EXP 109
56766: PUSH
56767: LD_VAR 0 1
56771: ARRAY
56772: ARRAY
56773: PPUSH
56774: CALL_OW 120
// end ; exit ;
56778: GO 57099
// end ; if tmp > 1 then
56780: LD_VAR 0 8
56784: PUSH
56785: LD_INT 1
56787: GREATER
56788: IFFALSE 56892
// for i = 2 to tmp do
56790: LD_ADDR_VAR 0 6
56794: PUSH
56795: DOUBLE
56796: LD_INT 2
56798: DEC
56799: ST_TO_ADDR
56800: LD_VAR 0 8
56804: PUSH
56805: FOR_TO
56806: IFFALSE 56890
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56808: LD_VAR 0 8
56812: PUSH
56813: LD_VAR 0 6
56817: ARRAY
56818: PPUSH
56819: CALL_OW 461
56823: PUSH
56824: LD_INT 6
56826: EQUAL
56827: IFFALSE 56888
// begin x := tmp [ i ] ;
56829: LD_ADDR_VAR 0 9
56833: PUSH
56834: LD_VAR 0 8
56838: PUSH
56839: LD_VAR 0 6
56843: ARRAY
56844: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56845: LD_ADDR_VAR 0 8
56849: PUSH
56850: LD_VAR 0 8
56854: PPUSH
56855: LD_VAR 0 6
56859: PPUSH
56860: CALL_OW 3
56864: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56865: LD_ADDR_VAR 0 8
56869: PUSH
56870: LD_VAR 0 8
56874: PPUSH
56875: LD_INT 1
56877: PPUSH
56878: LD_VAR 0 9
56882: PPUSH
56883: CALL_OW 2
56887: ST_TO_ADDR
// end ;
56888: GO 56805
56890: POP
56891: POP
// for i in tmp do
56892: LD_ADDR_VAR 0 6
56896: PUSH
56897: LD_VAR 0 8
56901: PUSH
56902: FOR_IN
56903: IFFALSE 56972
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56905: LD_VAR 0 6
56909: PPUSH
56910: CALL_OW 313
56914: PUSH
56915: LD_INT 6
56917: LESS
56918: PUSH
56919: LD_VAR 0 6
56923: PPUSH
56924: CALL_OW 266
56928: PUSH
56929: LD_INT 31
56931: PUSH
56932: LD_INT 32
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: IN
56939: NOT
56940: AND
56941: PUSH
56942: LD_VAR 0 6
56946: PPUSH
56947: CALL_OW 313
56951: PUSH
56952: LD_INT 0
56954: EQUAL
56955: OR
56956: IFFALSE 56970
// begin j := i ;
56958: LD_ADDR_VAR 0 7
56962: PUSH
56963: LD_VAR 0 6
56967: ST_TO_ADDR
// break ;
56968: GO 56972
// end ; end ;
56970: GO 56902
56972: POP
56973: POP
// if j then
56974: LD_VAR 0 7
56978: IFFALSE 56996
// ComEnterUnit ( unit , j ) else
56980: LD_VAR 0 3
56984: PPUSH
56985: LD_VAR 0 7
56989: PPUSH
56990: CALL_OW 120
56994: GO 57099
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56996: LD_ADDR_VAR 0 10
57000: PUSH
57001: LD_VAR 0 2
57005: PPUSH
57006: LD_INT 2
57008: PUSH
57009: LD_INT 30
57011: PUSH
57012: LD_INT 0
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: PUSH
57019: LD_INT 30
57021: PUSH
57022: LD_INT 1
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: LIST
57033: PPUSH
57034: CALL_OW 72
57038: ST_TO_ADDR
// if depot then
57039: LD_VAR 0 10
57043: IFFALSE 57099
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57045: LD_ADDR_VAR 0 10
57049: PUSH
57050: LD_VAR 0 10
57054: PPUSH
57055: LD_VAR 0 3
57059: PPUSH
57060: CALL_OW 74
57064: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57065: LD_VAR 0 3
57069: PPUSH
57070: LD_VAR 0 10
57074: PPUSH
57075: CALL_OW 296
57079: PUSH
57080: LD_INT 10
57082: GREATER
57083: IFFALSE 57099
// ComStandNearbyBuilding ( unit , depot ) ;
57085: LD_VAR 0 3
57089: PPUSH
57090: LD_VAR 0 10
57094: PPUSH
57095: CALL 65513 0 2
// end ; end ; end ;
57099: LD_VAR 0 5
57103: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57104: LD_INT 0
57106: PPUSH
57107: PPUSH
57108: PPUSH
57109: PPUSH
// if not mc_bases then
57110: LD_EXP 99
57114: NOT
57115: IFFALSE 57119
// exit ;
57117: GO 57358
// for i = 1 to mc_bases do
57119: LD_ADDR_VAR 0 2
57123: PUSH
57124: DOUBLE
57125: LD_INT 1
57127: DEC
57128: ST_TO_ADDR
57129: LD_EXP 99
57133: PUSH
57134: FOR_TO
57135: IFFALSE 57356
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57137: LD_ADDR_VAR 0 4
57141: PUSH
57142: LD_EXP 99
57146: PUSH
57147: LD_VAR 0 2
57151: ARRAY
57152: PPUSH
57153: LD_INT 21
57155: PUSH
57156: LD_INT 1
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PPUSH
57163: CALL_OW 72
57167: PUSH
57168: LD_EXP 128
57172: PUSH
57173: LD_VAR 0 2
57177: ARRAY
57178: UNION
57179: ST_TO_ADDR
// if not tmp then
57180: LD_VAR 0 4
57184: NOT
57185: IFFALSE 57189
// continue ;
57187: GO 57134
// for j in tmp do
57189: LD_ADDR_VAR 0 3
57193: PUSH
57194: LD_VAR 0 4
57198: PUSH
57199: FOR_IN
57200: IFFALSE 57352
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57202: LD_VAR 0 3
57206: PPUSH
57207: CALL_OW 110
57211: NOT
57212: PUSH
57213: LD_VAR 0 3
57217: PPUSH
57218: CALL_OW 314
57222: NOT
57223: AND
57224: PUSH
57225: LD_VAR 0 3
57229: PPUSH
57230: CALL_OW 311
57234: NOT
57235: AND
57236: PUSH
57237: LD_VAR 0 3
57241: PPUSH
57242: CALL_OW 310
57246: NOT
57247: AND
57248: PUSH
57249: LD_VAR 0 3
57253: PUSH
57254: LD_EXP 102
57258: PUSH
57259: LD_VAR 0 2
57263: ARRAY
57264: PUSH
57265: LD_INT 1
57267: ARRAY
57268: IN
57269: NOT
57270: AND
57271: PUSH
57272: LD_VAR 0 3
57276: PUSH
57277: LD_EXP 102
57281: PUSH
57282: LD_VAR 0 2
57286: ARRAY
57287: PUSH
57288: LD_INT 2
57290: ARRAY
57291: IN
57292: NOT
57293: AND
57294: PUSH
57295: LD_VAR 0 3
57299: PUSH
57300: LD_EXP 111
57304: PUSH
57305: LD_VAR 0 2
57309: ARRAY
57310: IN
57311: NOT
57312: AND
57313: IFFALSE 57350
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57315: LD_VAR 0 2
57319: PPUSH
57320: LD_EXP 99
57324: PUSH
57325: LD_VAR 0 2
57329: ARRAY
57330: PPUSH
57331: LD_VAR 0 3
57335: PPUSH
57336: LD_VAR 0 3
57340: PPUSH
57341: CALL_OW 257
57345: PPUSH
57346: CALL 56122 0 4
// end ;
57350: GO 57199
57352: POP
57353: POP
// end ;
57354: GO 57134
57356: POP
57357: POP
// end ;
57358: LD_VAR 0 1
57362: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57363: LD_INT 0
57365: PPUSH
57366: PPUSH
57367: PPUSH
57368: PPUSH
57369: PPUSH
57370: PPUSH
// if not mc_bases [ base ] then
57371: LD_EXP 99
57375: PUSH
57376: LD_VAR 0 1
57380: ARRAY
57381: NOT
57382: IFFALSE 57386
// exit ;
57384: GO 57568
// tmp := [ ] ;
57386: LD_ADDR_VAR 0 6
57390: PUSH
57391: EMPTY
57392: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57393: LD_ADDR_VAR 0 7
57397: PUSH
57398: LD_VAR 0 3
57402: PPUSH
57403: LD_INT 0
57405: PPUSH
57406: CALL_OW 517
57410: ST_TO_ADDR
// if not list then
57411: LD_VAR 0 7
57415: NOT
57416: IFFALSE 57420
// exit ;
57418: GO 57568
// for i = 1 to amount do
57420: LD_ADDR_VAR 0 5
57424: PUSH
57425: DOUBLE
57426: LD_INT 1
57428: DEC
57429: ST_TO_ADDR
57430: LD_VAR 0 2
57434: PUSH
57435: FOR_TO
57436: IFFALSE 57516
// begin x := rand ( 1 , list [ 1 ] ) ;
57438: LD_ADDR_VAR 0 8
57442: PUSH
57443: LD_INT 1
57445: PPUSH
57446: LD_VAR 0 7
57450: PUSH
57451: LD_INT 1
57453: ARRAY
57454: PPUSH
57455: CALL_OW 12
57459: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57460: LD_ADDR_VAR 0 6
57464: PUSH
57465: LD_VAR 0 6
57469: PPUSH
57470: LD_VAR 0 5
57474: PPUSH
57475: LD_VAR 0 7
57479: PUSH
57480: LD_INT 1
57482: ARRAY
57483: PUSH
57484: LD_VAR 0 8
57488: ARRAY
57489: PUSH
57490: LD_VAR 0 7
57494: PUSH
57495: LD_INT 2
57497: ARRAY
57498: PUSH
57499: LD_VAR 0 8
57503: ARRAY
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: PPUSH
57509: CALL_OW 1
57513: ST_TO_ADDR
// end ;
57514: GO 57435
57516: POP
57517: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57518: LD_ADDR_EXP 112
57522: PUSH
57523: LD_EXP 112
57527: PPUSH
57528: LD_VAR 0 1
57532: PPUSH
57533: LD_VAR 0 6
57537: PPUSH
57538: CALL_OW 1
57542: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57543: LD_ADDR_EXP 114
57547: PUSH
57548: LD_EXP 114
57552: PPUSH
57553: LD_VAR 0 1
57557: PPUSH
57558: LD_VAR 0 3
57562: PPUSH
57563: CALL_OW 1
57567: ST_TO_ADDR
// end ;
57568: LD_VAR 0 4
57572: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57573: LD_INT 0
57575: PPUSH
// if not mc_bases [ base ] then
57576: LD_EXP 99
57580: PUSH
57581: LD_VAR 0 1
57585: ARRAY
57586: NOT
57587: IFFALSE 57591
// exit ;
57589: GO 57616
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57591: LD_ADDR_EXP 104
57595: PUSH
57596: LD_EXP 104
57600: PPUSH
57601: LD_VAR 0 1
57605: PPUSH
57606: LD_VAR 0 2
57610: PPUSH
57611: CALL_OW 1
57615: ST_TO_ADDR
// end ;
57616: LD_VAR 0 3
57620: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57621: LD_INT 0
57623: PPUSH
// if not mc_bases [ base ] then
57624: LD_EXP 99
57628: PUSH
57629: LD_VAR 0 1
57633: ARRAY
57634: NOT
57635: IFFALSE 57639
// exit ;
57637: GO 57676
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57639: LD_ADDR_EXP 104
57643: PUSH
57644: LD_EXP 104
57648: PPUSH
57649: LD_VAR 0 1
57653: PPUSH
57654: LD_EXP 104
57658: PUSH
57659: LD_VAR 0 1
57663: ARRAY
57664: PUSH
57665: LD_VAR 0 2
57669: UNION
57670: PPUSH
57671: CALL_OW 1
57675: ST_TO_ADDR
// end ;
57676: LD_VAR 0 3
57680: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57681: LD_INT 0
57683: PPUSH
// if not mc_bases [ base ] then
57684: LD_EXP 99
57688: PUSH
57689: LD_VAR 0 1
57693: ARRAY
57694: NOT
57695: IFFALSE 57699
// exit ;
57697: GO 57724
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57699: LD_ADDR_EXP 120
57703: PUSH
57704: LD_EXP 120
57708: PPUSH
57709: LD_VAR 0 1
57713: PPUSH
57714: LD_VAR 0 2
57718: PPUSH
57719: CALL_OW 1
57723: ST_TO_ADDR
// end ;
57724: LD_VAR 0 3
57728: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57729: LD_INT 0
57731: PPUSH
// if not mc_bases [ base ] then
57732: LD_EXP 99
57736: PUSH
57737: LD_VAR 0 1
57741: ARRAY
57742: NOT
57743: IFFALSE 57747
// exit ;
57745: GO 57784
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57747: LD_ADDR_EXP 120
57751: PUSH
57752: LD_EXP 120
57756: PPUSH
57757: LD_VAR 0 1
57761: PPUSH
57762: LD_EXP 120
57766: PUSH
57767: LD_VAR 0 1
57771: ARRAY
57772: PUSH
57773: LD_VAR 0 2
57777: ADD
57778: PPUSH
57779: CALL_OW 1
57783: ST_TO_ADDR
// end ;
57784: LD_VAR 0 3
57788: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57789: LD_INT 0
57791: PPUSH
// if not mc_bases [ base ] then
57792: LD_EXP 99
57796: PUSH
57797: LD_VAR 0 1
57801: ARRAY
57802: NOT
57803: IFFALSE 57807
// exit ;
57805: GO 57861
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57807: LD_ADDR_EXP 121
57811: PUSH
57812: LD_EXP 121
57816: PPUSH
57817: LD_VAR 0 1
57821: PPUSH
57822: LD_VAR 0 2
57826: PPUSH
57827: CALL_OW 1
57831: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57832: LD_ADDR_EXP 110
57836: PUSH
57837: LD_EXP 110
57841: PPUSH
57842: LD_VAR 0 1
57846: PPUSH
57847: LD_VAR 0 2
57851: PUSH
57852: LD_INT 0
57854: PLUS
57855: PPUSH
57856: CALL_OW 1
57860: ST_TO_ADDR
// end ;
57861: LD_VAR 0 3
57865: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57866: LD_INT 0
57868: PPUSH
// if not mc_bases [ base ] then
57869: LD_EXP 99
57873: PUSH
57874: LD_VAR 0 1
57878: ARRAY
57879: NOT
57880: IFFALSE 57884
// exit ;
57882: GO 57909
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57884: LD_ADDR_EXP 110
57888: PUSH
57889: LD_EXP 110
57893: PPUSH
57894: LD_VAR 0 1
57898: PPUSH
57899: LD_VAR 0 2
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// end ;
57909: LD_VAR 0 3
57913: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57914: LD_INT 0
57916: PPUSH
57917: PPUSH
57918: PPUSH
57919: PPUSH
// if not mc_bases [ base ] then
57920: LD_EXP 99
57924: PUSH
57925: LD_VAR 0 1
57929: ARRAY
57930: NOT
57931: IFFALSE 57935
// exit ;
57933: GO 58000
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57935: LD_ADDR_EXP 119
57939: PUSH
57940: LD_EXP 119
57944: PPUSH
57945: LD_VAR 0 1
57949: PUSH
57950: LD_EXP 119
57954: PUSH
57955: LD_VAR 0 1
57959: ARRAY
57960: PUSH
57961: LD_INT 1
57963: PLUS
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PPUSH
57969: LD_VAR 0 1
57973: PUSH
57974: LD_VAR 0 2
57978: PUSH
57979: LD_VAR 0 3
57983: PUSH
57984: LD_VAR 0 4
57988: PUSH
57989: EMPTY
57990: LIST
57991: LIST
57992: LIST
57993: LIST
57994: PPUSH
57995: CALL 71221 0 3
57999: ST_TO_ADDR
// end ;
58000: LD_VAR 0 5
58004: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58005: LD_INT 0
58007: PPUSH
// if not mc_bases [ base ] then
58008: LD_EXP 99
58012: PUSH
58013: LD_VAR 0 1
58017: ARRAY
58018: NOT
58019: IFFALSE 58023
// exit ;
58021: GO 58048
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58023: LD_ADDR_EXP 136
58027: PUSH
58028: LD_EXP 136
58032: PPUSH
58033: LD_VAR 0 1
58037: PPUSH
58038: LD_VAR 0 2
58042: PPUSH
58043: CALL_OW 1
58047: ST_TO_ADDR
// end ;
58048: LD_VAR 0 3
58052: RET
// export function MC_GetMinesField ( base ) ; begin
58053: LD_INT 0
58055: PPUSH
// result := mc_mines [ base ] ;
58056: LD_ADDR_VAR 0 2
58060: PUSH
58061: LD_EXP 112
58065: PUSH
58066: LD_VAR 0 1
58070: ARRAY
58071: ST_TO_ADDR
// end ;
58072: LD_VAR 0 2
58076: RET
// export function MC_GetProduceList ( base ) ; begin
58077: LD_INT 0
58079: PPUSH
// result := mc_produce [ base ] ;
58080: LD_ADDR_VAR 0 2
58084: PUSH
58085: LD_EXP 120
58089: PUSH
58090: LD_VAR 0 1
58094: ARRAY
58095: ST_TO_ADDR
// end ;
58096: LD_VAR 0 2
58100: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58101: LD_INT 0
58103: PPUSH
58104: PPUSH
// if not mc_bases then
58105: LD_EXP 99
58109: NOT
58110: IFFALSE 58114
// exit ;
58112: GO 58179
// if mc_bases [ base ] then
58114: LD_EXP 99
58118: PUSH
58119: LD_VAR 0 1
58123: ARRAY
58124: IFFALSE 58179
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58126: LD_ADDR_VAR 0 3
58130: PUSH
58131: LD_EXP 99
58135: PUSH
58136: LD_VAR 0 1
58140: ARRAY
58141: PPUSH
58142: LD_INT 30
58144: PUSH
58145: LD_VAR 0 2
58149: PUSH
58150: EMPTY
58151: LIST
58152: LIST
58153: PPUSH
58154: CALL_OW 72
58158: ST_TO_ADDR
// if result then
58159: LD_VAR 0 3
58163: IFFALSE 58179
// result := result [ 1 ] ;
58165: LD_ADDR_VAR 0 3
58169: PUSH
58170: LD_VAR 0 3
58174: PUSH
58175: LD_INT 1
58177: ARRAY
58178: ST_TO_ADDR
// end ; end ;
58179: LD_VAR 0 3
58183: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58184: LD_INT 0
58186: PPUSH
58187: PPUSH
// if not mc_bases then
58188: LD_EXP 99
58192: NOT
58193: IFFALSE 58197
// exit ;
58195: GO 58242
// if mc_bases [ base ] then
58197: LD_EXP 99
58201: PUSH
58202: LD_VAR 0 1
58206: ARRAY
58207: IFFALSE 58242
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58209: LD_ADDR_VAR 0 3
58213: PUSH
58214: LD_EXP 99
58218: PUSH
58219: LD_VAR 0 1
58223: ARRAY
58224: PPUSH
58225: LD_INT 30
58227: PUSH
58228: LD_VAR 0 2
58232: PUSH
58233: EMPTY
58234: LIST
58235: LIST
58236: PPUSH
58237: CALL_OW 72
58241: ST_TO_ADDR
// end ;
58242: LD_VAR 0 3
58246: RET
// export function MC_SetTame ( base , area ) ; begin
58247: LD_INT 0
58249: PPUSH
// if not mc_bases or not base then
58250: LD_EXP 99
58254: NOT
58255: PUSH
58256: LD_VAR 0 1
58260: NOT
58261: OR
58262: IFFALSE 58266
// exit ;
58264: GO 58291
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58266: LD_ADDR_EXP 127
58270: PUSH
58271: LD_EXP 127
58275: PPUSH
58276: LD_VAR 0 1
58280: PPUSH
58281: LD_VAR 0 2
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// end ;
58291: LD_VAR 0 3
58295: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58296: LD_INT 0
58298: PPUSH
58299: PPUSH
// if not mc_bases or not base then
58300: LD_EXP 99
58304: NOT
58305: PUSH
58306: LD_VAR 0 1
58310: NOT
58311: OR
58312: IFFALSE 58316
// exit ;
58314: GO 58418
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58316: LD_ADDR_VAR 0 4
58320: PUSH
58321: LD_EXP 99
58325: PUSH
58326: LD_VAR 0 1
58330: ARRAY
58331: PPUSH
58332: LD_INT 30
58334: PUSH
58335: LD_VAR 0 2
58339: PUSH
58340: EMPTY
58341: LIST
58342: LIST
58343: PPUSH
58344: CALL_OW 72
58348: ST_TO_ADDR
// if not tmp then
58349: LD_VAR 0 4
58353: NOT
58354: IFFALSE 58358
// exit ;
58356: GO 58418
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58358: LD_ADDR_EXP 131
58362: PUSH
58363: LD_EXP 131
58367: PPUSH
58368: LD_VAR 0 1
58372: PPUSH
58373: LD_EXP 131
58377: PUSH
58378: LD_VAR 0 1
58382: ARRAY
58383: PPUSH
58384: LD_EXP 131
58388: PUSH
58389: LD_VAR 0 1
58393: ARRAY
58394: PUSH
58395: LD_INT 1
58397: PLUS
58398: PPUSH
58399: LD_VAR 0 4
58403: PUSH
58404: LD_INT 1
58406: ARRAY
58407: PPUSH
58408: CALL_OW 2
58412: PPUSH
58413: CALL_OW 1
58417: ST_TO_ADDR
// end ;
58418: LD_VAR 0 3
58422: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58423: LD_INT 0
58425: PPUSH
58426: PPUSH
// if not mc_bases or not base or not kinds then
58427: LD_EXP 99
58431: NOT
58432: PUSH
58433: LD_VAR 0 1
58437: NOT
58438: OR
58439: PUSH
58440: LD_VAR 0 2
58444: NOT
58445: OR
58446: IFFALSE 58450
// exit ;
58448: GO 58511
// for i in kinds do
58450: LD_ADDR_VAR 0 4
58454: PUSH
58455: LD_VAR 0 2
58459: PUSH
58460: FOR_IN
58461: IFFALSE 58509
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58463: LD_ADDR_EXP 133
58467: PUSH
58468: LD_EXP 133
58472: PPUSH
58473: LD_VAR 0 1
58477: PUSH
58478: LD_EXP 133
58482: PUSH
58483: LD_VAR 0 1
58487: ARRAY
58488: PUSH
58489: LD_INT 1
58491: PLUS
58492: PUSH
58493: EMPTY
58494: LIST
58495: LIST
58496: PPUSH
58497: LD_VAR 0 4
58501: PPUSH
58502: CALL 71221 0 3
58506: ST_TO_ADDR
58507: GO 58460
58509: POP
58510: POP
// end ;
58511: LD_VAR 0 3
58515: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58516: LD_INT 0
58518: PPUSH
// if not mc_bases or not base or not areas then
58519: LD_EXP 99
58523: NOT
58524: PUSH
58525: LD_VAR 0 1
58529: NOT
58530: OR
58531: PUSH
58532: LD_VAR 0 2
58536: NOT
58537: OR
58538: IFFALSE 58542
// exit ;
58540: GO 58567
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58542: LD_ADDR_EXP 117
58546: PUSH
58547: LD_EXP 117
58551: PPUSH
58552: LD_VAR 0 1
58556: PPUSH
58557: LD_VAR 0 2
58561: PPUSH
58562: CALL_OW 1
58566: ST_TO_ADDR
// end ;
58567: LD_VAR 0 3
58571: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58572: LD_INT 0
58574: PPUSH
// if not mc_bases or not base or not teleports_exit then
58575: LD_EXP 99
58579: NOT
58580: PUSH
58581: LD_VAR 0 1
58585: NOT
58586: OR
58587: PUSH
58588: LD_VAR 0 2
58592: NOT
58593: OR
58594: IFFALSE 58598
// exit ;
58596: GO 58623
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58598: LD_ADDR_EXP 134
58602: PUSH
58603: LD_EXP 134
58607: PPUSH
58608: LD_VAR 0 1
58612: PPUSH
58613: LD_VAR 0 2
58617: PPUSH
58618: CALL_OW 1
58622: ST_TO_ADDR
// end ;
58623: LD_VAR 0 3
58627: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58628: LD_INT 0
58630: PPUSH
58631: PPUSH
58632: PPUSH
// if not mc_bases or not base or not ext_list then
58633: LD_EXP 99
58637: NOT
58638: PUSH
58639: LD_VAR 0 1
58643: NOT
58644: OR
58645: PUSH
58646: LD_VAR 0 5
58650: NOT
58651: OR
58652: IFFALSE 58656
// exit ;
58654: GO 58829
// tmp := GetFacExtXYD ( x , y , d ) ;
58656: LD_ADDR_VAR 0 8
58660: PUSH
58661: LD_VAR 0 2
58665: PPUSH
58666: LD_VAR 0 3
58670: PPUSH
58671: LD_VAR 0 4
58675: PPUSH
58676: CALL 104599 0 3
58680: ST_TO_ADDR
// if not tmp then
58681: LD_VAR 0 8
58685: NOT
58686: IFFALSE 58690
// exit ;
58688: GO 58829
// for i in tmp do
58690: LD_ADDR_VAR 0 7
58694: PUSH
58695: LD_VAR 0 8
58699: PUSH
58700: FOR_IN
58701: IFFALSE 58827
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58703: LD_ADDR_EXP 104
58707: PUSH
58708: LD_EXP 104
58712: PPUSH
58713: LD_VAR 0 1
58717: PPUSH
58718: LD_EXP 104
58722: PUSH
58723: LD_VAR 0 1
58727: ARRAY
58728: PPUSH
58729: LD_EXP 104
58733: PUSH
58734: LD_VAR 0 1
58738: ARRAY
58739: PUSH
58740: LD_INT 1
58742: PLUS
58743: PPUSH
58744: LD_VAR 0 5
58748: PUSH
58749: LD_INT 1
58751: ARRAY
58752: PUSH
58753: LD_VAR 0 7
58757: PUSH
58758: LD_INT 1
58760: ARRAY
58761: PUSH
58762: LD_VAR 0 7
58766: PUSH
58767: LD_INT 2
58769: ARRAY
58770: PUSH
58771: LD_VAR 0 7
58775: PUSH
58776: LD_INT 3
58778: ARRAY
58779: PUSH
58780: EMPTY
58781: LIST
58782: LIST
58783: LIST
58784: LIST
58785: PPUSH
58786: CALL_OW 2
58790: PPUSH
58791: CALL_OW 1
58795: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58796: LD_ADDR_VAR 0 5
58800: PUSH
58801: LD_VAR 0 5
58805: PPUSH
58806: LD_INT 1
58808: PPUSH
58809: CALL_OW 3
58813: ST_TO_ADDR
// if not ext_list then
58814: LD_VAR 0 5
58818: NOT
58819: IFFALSE 58825
// exit ;
58821: POP
58822: POP
58823: GO 58829
// end ;
58825: GO 58700
58827: POP
58828: POP
// end ;
58829: LD_VAR 0 6
58833: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58834: LD_INT 0
58836: PPUSH
// if not mc_bases or not base or not weapon_list then
58837: LD_EXP 99
58841: NOT
58842: PUSH
58843: LD_VAR 0 1
58847: NOT
58848: OR
58849: PUSH
58850: LD_VAR 0 2
58854: NOT
58855: OR
58856: IFFALSE 58860
// exit ;
58858: GO 58885
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58860: LD_ADDR_EXP 138
58864: PUSH
58865: LD_EXP 138
58869: PPUSH
58870: LD_VAR 0 1
58874: PPUSH
58875: LD_VAR 0 2
58879: PPUSH
58880: CALL_OW 1
58884: ST_TO_ADDR
// end ;
58885: LD_VAR 0 3
58889: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58890: LD_INT 0
58892: PPUSH
// if not mc_bases or not base or not tech_list then
58893: LD_EXP 99
58897: NOT
58898: PUSH
58899: LD_VAR 0 1
58903: NOT
58904: OR
58905: PUSH
58906: LD_VAR 0 2
58910: NOT
58911: OR
58912: IFFALSE 58916
// exit ;
58914: GO 58941
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58916: LD_ADDR_EXP 126
58920: PUSH
58921: LD_EXP 126
58925: PPUSH
58926: LD_VAR 0 1
58930: PPUSH
58931: LD_VAR 0 2
58935: PPUSH
58936: CALL_OW 1
58940: ST_TO_ADDR
// end ;
58941: LD_VAR 0 3
58945: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58946: LD_INT 0
58948: PPUSH
// if not mc_bases or not parking_area or not base then
58949: LD_EXP 99
58953: NOT
58954: PUSH
58955: LD_VAR 0 2
58959: NOT
58960: OR
58961: PUSH
58962: LD_VAR 0 1
58966: NOT
58967: OR
58968: IFFALSE 58972
// exit ;
58970: GO 58997
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58972: LD_ADDR_EXP 123
58976: PUSH
58977: LD_EXP 123
58981: PPUSH
58982: LD_VAR 0 1
58986: PPUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: CALL_OW 1
58996: ST_TO_ADDR
// end ;
58997: LD_VAR 0 3
59001: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59002: LD_INT 0
59004: PPUSH
// if not mc_bases or not base or not scan_area then
59005: LD_EXP 99
59009: NOT
59010: PUSH
59011: LD_VAR 0 1
59015: NOT
59016: OR
59017: PUSH
59018: LD_VAR 0 2
59022: NOT
59023: OR
59024: IFFALSE 59028
// exit ;
59026: GO 59053
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59028: LD_ADDR_EXP 124
59032: PUSH
59033: LD_EXP 124
59037: PPUSH
59038: LD_VAR 0 1
59042: PPUSH
59043: LD_VAR 0 2
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// end ;
59053: LD_VAR 0 3
59057: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59058: LD_INT 0
59060: PPUSH
59061: PPUSH
// if not mc_bases or not base then
59062: LD_EXP 99
59066: NOT
59067: PUSH
59068: LD_VAR 0 1
59072: NOT
59073: OR
59074: IFFALSE 59078
// exit ;
59076: GO 59142
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59078: LD_ADDR_VAR 0 3
59082: PUSH
59083: LD_INT 1
59085: PUSH
59086: LD_INT 2
59088: PUSH
59089: LD_INT 3
59091: PUSH
59092: LD_INT 4
59094: PUSH
59095: LD_INT 11
59097: PUSH
59098: EMPTY
59099: LIST
59100: LIST
59101: LIST
59102: LIST
59103: LIST
59104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59105: LD_ADDR_EXP 126
59109: PUSH
59110: LD_EXP 126
59114: PPUSH
59115: LD_VAR 0 1
59119: PPUSH
59120: LD_EXP 126
59124: PUSH
59125: LD_VAR 0 1
59129: ARRAY
59130: PUSH
59131: LD_VAR 0 3
59135: DIFF
59136: PPUSH
59137: CALL_OW 1
59141: ST_TO_ADDR
// end ;
59142: LD_VAR 0 2
59146: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59147: LD_INT 0
59149: PPUSH
// result := mc_vehicles [ base ] ;
59150: LD_ADDR_VAR 0 3
59154: PUSH
59155: LD_EXP 118
59159: PUSH
59160: LD_VAR 0 1
59164: ARRAY
59165: ST_TO_ADDR
// if onlyCombat then
59166: LD_VAR 0 2
59170: IFFALSE 59335
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59172: LD_ADDR_VAR 0 3
59176: PUSH
59177: LD_VAR 0 3
59181: PUSH
59182: LD_VAR 0 3
59186: PPUSH
59187: LD_INT 2
59189: PUSH
59190: LD_INT 34
59192: PUSH
59193: LD_INT 12
59195: PUSH
59196: EMPTY
59197: LIST
59198: LIST
59199: PUSH
59200: LD_INT 34
59202: PUSH
59203: LD_INT 51
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 34
59212: PUSH
59213: LD_EXP 93
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_INT 34
59224: PUSH
59225: LD_INT 32
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: PUSH
59232: LD_INT 34
59234: PUSH
59235: LD_INT 13
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: PUSH
59242: LD_INT 34
59244: PUSH
59245: LD_INT 52
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: PUSH
59252: LD_INT 34
59254: PUSH
59255: LD_INT 14
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PUSH
59262: LD_INT 34
59264: PUSH
59265: LD_INT 53
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PUSH
59272: LD_INT 34
59274: PUSH
59275: LD_EXP 92
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: PUSH
59284: LD_INT 34
59286: PUSH
59287: LD_INT 31
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PUSH
59294: LD_INT 34
59296: PUSH
59297: LD_INT 48
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: PUSH
59304: LD_INT 34
59306: PUSH
59307: LD_INT 8
59309: PUSH
59310: EMPTY
59311: LIST
59312: LIST
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: LIST
59322: LIST
59323: LIST
59324: LIST
59325: LIST
59326: LIST
59327: LIST
59328: PPUSH
59329: CALL_OW 72
59333: DIFF
59334: ST_TO_ADDR
// end ; end_of_file
59335: LD_VAR 0 3
59339: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59340: LD_INT 0
59342: PPUSH
59343: PPUSH
59344: PPUSH
// if not mc_bases or not skirmish then
59345: LD_EXP 99
59349: NOT
59350: PUSH
59351: LD_EXP 97
59355: NOT
59356: OR
59357: IFFALSE 59361
// exit ;
59359: GO 59526
// for i = 1 to mc_bases do
59361: LD_ADDR_VAR 0 4
59365: PUSH
59366: DOUBLE
59367: LD_INT 1
59369: DEC
59370: ST_TO_ADDR
59371: LD_EXP 99
59375: PUSH
59376: FOR_TO
59377: IFFALSE 59524
// begin if sci in mc_bases [ i ] then
59379: LD_VAR 0 2
59383: PUSH
59384: LD_EXP 99
59388: PUSH
59389: LD_VAR 0 4
59393: ARRAY
59394: IN
59395: IFFALSE 59522
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59397: LD_ADDR_EXP 128
59401: PUSH
59402: LD_EXP 128
59406: PPUSH
59407: LD_VAR 0 4
59411: PUSH
59412: LD_EXP 128
59416: PUSH
59417: LD_VAR 0 4
59421: ARRAY
59422: PUSH
59423: LD_INT 1
59425: PLUS
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PPUSH
59431: LD_VAR 0 1
59435: PPUSH
59436: CALL 71221 0 3
59440: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59441: LD_ADDR_VAR 0 5
59445: PUSH
59446: LD_EXP 99
59450: PUSH
59451: LD_VAR 0 4
59455: ARRAY
59456: PPUSH
59457: LD_INT 2
59459: PUSH
59460: LD_INT 30
59462: PUSH
59463: LD_INT 0
59465: PUSH
59466: EMPTY
59467: LIST
59468: LIST
59469: PUSH
59470: LD_INT 30
59472: PUSH
59473: LD_INT 1
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: LIST
59484: PPUSH
59485: CALL_OW 72
59489: PPUSH
59490: LD_VAR 0 1
59494: PPUSH
59495: CALL_OW 74
59499: ST_TO_ADDR
// if tmp then
59500: LD_VAR 0 5
59504: IFFALSE 59520
// ComStandNearbyBuilding ( ape , tmp ) ;
59506: LD_VAR 0 1
59510: PPUSH
59511: LD_VAR 0 5
59515: PPUSH
59516: CALL 65513 0 2
// break ;
59520: GO 59524
// end ; end ;
59522: GO 59376
59524: POP
59525: POP
// end ;
59526: LD_VAR 0 3
59530: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59531: LD_INT 0
59533: PPUSH
59534: PPUSH
59535: PPUSH
// if not mc_bases or not skirmish then
59536: LD_EXP 99
59540: NOT
59541: PUSH
59542: LD_EXP 97
59546: NOT
59547: OR
59548: IFFALSE 59552
// exit ;
59550: GO 59641
// for i = 1 to mc_bases do
59552: LD_ADDR_VAR 0 4
59556: PUSH
59557: DOUBLE
59558: LD_INT 1
59560: DEC
59561: ST_TO_ADDR
59562: LD_EXP 99
59566: PUSH
59567: FOR_TO
59568: IFFALSE 59639
// begin if building in mc_busy_turret_list [ i ] then
59570: LD_VAR 0 1
59574: PUSH
59575: LD_EXP 109
59579: PUSH
59580: LD_VAR 0 4
59584: ARRAY
59585: IN
59586: IFFALSE 59637
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59588: LD_ADDR_VAR 0 5
59592: PUSH
59593: LD_EXP 109
59597: PUSH
59598: LD_VAR 0 4
59602: ARRAY
59603: PUSH
59604: LD_VAR 0 1
59608: DIFF
59609: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59610: LD_ADDR_EXP 109
59614: PUSH
59615: LD_EXP 109
59619: PPUSH
59620: LD_VAR 0 4
59624: PPUSH
59625: LD_VAR 0 5
59629: PPUSH
59630: CALL_OW 1
59634: ST_TO_ADDR
// break ;
59635: GO 59639
// end ; end ;
59637: GO 59567
59639: POP
59640: POP
// end ;
59641: LD_VAR 0 3
59645: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59646: LD_INT 0
59648: PPUSH
59649: PPUSH
59650: PPUSH
// if not mc_bases or not skirmish then
59651: LD_EXP 99
59655: NOT
59656: PUSH
59657: LD_EXP 97
59661: NOT
59662: OR
59663: IFFALSE 59667
// exit ;
59665: GO 59866
// for i = 1 to mc_bases do
59667: LD_ADDR_VAR 0 5
59671: PUSH
59672: DOUBLE
59673: LD_INT 1
59675: DEC
59676: ST_TO_ADDR
59677: LD_EXP 99
59681: PUSH
59682: FOR_TO
59683: IFFALSE 59864
// if building in mc_bases [ i ] then
59685: LD_VAR 0 1
59689: PUSH
59690: LD_EXP 99
59694: PUSH
59695: LD_VAR 0 5
59699: ARRAY
59700: IN
59701: IFFALSE 59862
// begin tmp := mc_bases [ i ] diff building ;
59703: LD_ADDR_VAR 0 6
59707: PUSH
59708: LD_EXP 99
59712: PUSH
59713: LD_VAR 0 5
59717: ARRAY
59718: PUSH
59719: LD_VAR 0 1
59723: DIFF
59724: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59725: LD_ADDR_EXP 99
59729: PUSH
59730: LD_EXP 99
59734: PPUSH
59735: LD_VAR 0 5
59739: PPUSH
59740: LD_VAR 0 6
59744: PPUSH
59745: CALL_OW 1
59749: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59750: LD_VAR 0 1
59754: PUSH
59755: LD_EXP 107
59759: PUSH
59760: LD_VAR 0 5
59764: ARRAY
59765: IN
59766: IFFALSE 59805
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59768: LD_ADDR_EXP 107
59772: PUSH
59773: LD_EXP 107
59777: PPUSH
59778: LD_VAR 0 5
59782: PPUSH
59783: LD_EXP 107
59787: PUSH
59788: LD_VAR 0 5
59792: ARRAY
59793: PUSH
59794: LD_VAR 0 1
59798: DIFF
59799: PPUSH
59800: CALL_OW 1
59804: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59805: LD_VAR 0 1
59809: PUSH
59810: LD_EXP 108
59814: PUSH
59815: LD_VAR 0 5
59819: ARRAY
59820: IN
59821: IFFALSE 59860
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59823: LD_ADDR_EXP 108
59827: PUSH
59828: LD_EXP 108
59832: PPUSH
59833: LD_VAR 0 5
59837: PPUSH
59838: LD_EXP 108
59842: PUSH
59843: LD_VAR 0 5
59847: ARRAY
59848: PUSH
59849: LD_VAR 0 1
59853: DIFF
59854: PPUSH
59855: CALL_OW 1
59859: ST_TO_ADDR
// break ;
59860: GO 59864
// end ;
59862: GO 59682
59864: POP
59865: POP
// end ;
59866: LD_VAR 0 4
59870: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59871: LD_INT 0
59873: PPUSH
59874: PPUSH
59875: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59876: LD_EXP 99
59880: NOT
59881: PUSH
59882: LD_EXP 97
59886: NOT
59887: OR
59888: PUSH
59889: LD_VAR 0 3
59893: PUSH
59894: LD_EXP 125
59898: IN
59899: NOT
59900: OR
59901: IFFALSE 59905
// exit ;
59903: GO 60028
// for i = 1 to mc_vehicles do
59905: LD_ADDR_VAR 0 6
59909: PUSH
59910: DOUBLE
59911: LD_INT 1
59913: DEC
59914: ST_TO_ADDR
59915: LD_EXP 118
59919: PUSH
59920: FOR_TO
59921: IFFALSE 60026
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59923: LD_VAR 0 2
59927: PUSH
59928: LD_EXP 118
59932: PUSH
59933: LD_VAR 0 6
59937: ARRAY
59938: IN
59939: PUSH
59940: LD_VAR 0 1
59944: PUSH
59945: LD_EXP 118
59949: PUSH
59950: LD_VAR 0 6
59954: ARRAY
59955: IN
59956: OR
59957: IFFALSE 60024
// begin tmp := mc_vehicles [ i ] diff old ;
59959: LD_ADDR_VAR 0 7
59963: PUSH
59964: LD_EXP 118
59968: PUSH
59969: LD_VAR 0 6
59973: ARRAY
59974: PUSH
59975: LD_VAR 0 2
59979: DIFF
59980: ST_TO_ADDR
// tmp := tmp diff new ;
59981: LD_ADDR_VAR 0 7
59985: PUSH
59986: LD_VAR 0 7
59990: PUSH
59991: LD_VAR 0 1
59995: DIFF
59996: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59997: LD_ADDR_EXP 118
60001: PUSH
60002: LD_EXP 118
60006: PPUSH
60007: LD_VAR 0 6
60011: PPUSH
60012: LD_VAR 0 7
60016: PPUSH
60017: CALL_OW 1
60021: ST_TO_ADDR
// break ;
60022: GO 60026
// end ;
60024: GO 59920
60026: POP
60027: POP
// end ;
60028: LD_VAR 0 5
60032: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60033: LD_INT 0
60035: PPUSH
60036: PPUSH
60037: PPUSH
60038: PPUSH
// if not mc_bases or not skirmish then
60039: LD_EXP 99
60043: NOT
60044: PUSH
60045: LD_EXP 97
60049: NOT
60050: OR
60051: IFFALSE 60055
// exit ;
60053: GO 60432
// side := GetSide ( vehicle ) ;
60055: LD_ADDR_VAR 0 5
60059: PUSH
60060: LD_VAR 0 1
60064: PPUSH
60065: CALL_OW 255
60069: ST_TO_ADDR
// for i = 1 to mc_bases do
60070: LD_ADDR_VAR 0 4
60074: PUSH
60075: DOUBLE
60076: LD_INT 1
60078: DEC
60079: ST_TO_ADDR
60080: LD_EXP 99
60084: PUSH
60085: FOR_TO
60086: IFFALSE 60430
// begin if factory in mc_bases [ i ] then
60088: LD_VAR 0 2
60092: PUSH
60093: LD_EXP 99
60097: PUSH
60098: LD_VAR 0 4
60102: ARRAY
60103: IN
60104: IFFALSE 60428
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60106: LD_EXP 121
60110: PUSH
60111: LD_VAR 0 4
60115: ARRAY
60116: PUSH
60117: LD_EXP 110
60121: PUSH
60122: LD_VAR 0 4
60126: ARRAY
60127: LESS
60128: PUSH
60129: LD_VAR 0 1
60133: PPUSH
60134: CALL_OW 264
60138: PUSH
60139: LD_INT 31
60141: PUSH
60142: LD_INT 32
60144: PUSH
60145: LD_INT 51
60147: PUSH
60148: LD_EXP 93
60152: PUSH
60153: LD_INT 12
60155: PUSH
60156: LD_INT 30
60158: PUSH
60159: LD_EXP 92
60163: PUSH
60164: LD_INT 11
60166: PUSH
60167: LD_INT 53
60169: PUSH
60170: LD_INT 14
60172: PUSH
60173: LD_EXP 96
60177: PUSH
60178: LD_INT 29
60180: PUSH
60181: LD_EXP 94
60185: PUSH
60186: LD_INT 13
60188: PUSH
60189: LD_INT 52
60191: PUSH
60192: LD_INT 48
60194: PUSH
60195: LD_INT 8
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: LIST
60202: LIST
60203: LIST
60204: LIST
60205: LIST
60206: LIST
60207: LIST
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: IN
60217: NOT
60218: AND
60219: IFFALSE 60267
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60221: LD_ADDR_EXP 121
60225: PUSH
60226: LD_EXP 121
60230: PPUSH
60231: LD_VAR 0 4
60235: PUSH
60236: LD_EXP 121
60240: PUSH
60241: LD_VAR 0 4
60245: ARRAY
60246: PUSH
60247: LD_INT 1
60249: PLUS
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: PPUSH
60255: LD_VAR 0 1
60259: PPUSH
60260: CALL 71221 0 3
60264: ST_TO_ADDR
60265: GO 60311
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60267: LD_ADDR_EXP 118
60271: PUSH
60272: LD_EXP 118
60276: PPUSH
60277: LD_VAR 0 4
60281: PUSH
60282: LD_EXP 118
60286: PUSH
60287: LD_VAR 0 4
60291: ARRAY
60292: PUSH
60293: LD_INT 1
60295: PLUS
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PPUSH
60301: LD_VAR 0 1
60305: PPUSH
60306: CALL 71221 0 3
60310: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 263
60320: PUSH
60321: LD_INT 2
60323: EQUAL
60324: IFFALSE 60344
// begin repeat wait ( 0 0$1 ) ;
60326: LD_INT 35
60328: PPUSH
60329: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60333: LD_VAR 0 1
60337: PPUSH
60338: CALL_OW 312
60342: IFFALSE 60326
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60344: LD_VAR 0 1
60348: PPUSH
60349: LD_EXP 123
60353: PUSH
60354: LD_VAR 0 4
60358: ARRAY
60359: PPUSH
60360: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60364: LD_VAR 0 1
60368: PPUSH
60369: CALL_OW 263
60373: PUSH
60374: LD_INT 1
60376: NONEQUAL
60377: IFFALSE 60381
// break ;
60379: GO 60430
// repeat wait ( 0 0$1 ) ;
60381: LD_INT 35
60383: PPUSH
60384: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60388: LD_VAR 0 1
60392: PPUSH
60393: LD_EXP 123
60397: PUSH
60398: LD_VAR 0 4
60402: ARRAY
60403: PPUSH
60404: CALL_OW 308
60408: IFFALSE 60381
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60410: LD_VAR 0 1
60414: PPUSH
60415: CALL_OW 311
60419: PPUSH
60420: CALL_OW 121
// exit ;
60424: POP
60425: POP
60426: GO 60432
// end ; end ;
60428: GO 60085
60430: POP
60431: POP
// end ;
60432: LD_VAR 0 3
60436: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60437: LD_INT 0
60439: PPUSH
60440: PPUSH
60441: PPUSH
60442: PPUSH
// if not mc_bases or not skirmish then
60443: LD_EXP 99
60447: NOT
60448: PUSH
60449: LD_EXP 97
60453: NOT
60454: OR
60455: IFFALSE 60459
// exit ;
60457: GO 60812
// repeat wait ( 0 0$1 ) ;
60459: LD_INT 35
60461: PPUSH
60462: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60466: LD_VAR 0 2
60470: PPUSH
60471: LD_VAR 0 3
60475: PPUSH
60476: CALL_OW 284
60480: IFFALSE 60459
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60482: LD_VAR 0 2
60486: PPUSH
60487: LD_VAR 0 3
60491: PPUSH
60492: CALL_OW 283
60496: PUSH
60497: LD_INT 4
60499: EQUAL
60500: IFFALSE 60504
// exit ;
60502: GO 60812
// for i = 1 to mc_bases do
60504: LD_ADDR_VAR 0 7
60508: PUSH
60509: DOUBLE
60510: LD_INT 1
60512: DEC
60513: ST_TO_ADDR
60514: LD_EXP 99
60518: PUSH
60519: FOR_TO
60520: IFFALSE 60810
// begin if mc_crates_area [ i ] then
60522: LD_EXP 117
60526: PUSH
60527: LD_VAR 0 7
60531: ARRAY
60532: IFFALSE 60643
// for j in mc_crates_area [ i ] do
60534: LD_ADDR_VAR 0 8
60538: PUSH
60539: LD_EXP 117
60543: PUSH
60544: LD_VAR 0 7
60548: ARRAY
60549: PUSH
60550: FOR_IN
60551: IFFALSE 60641
// if InArea ( x , y , j ) then
60553: LD_VAR 0 2
60557: PPUSH
60558: LD_VAR 0 3
60562: PPUSH
60563: LD_VAR 0 8
60567: PPUSH
60568: CALL_OW 309
60572: IFFALSE 60639
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60574: LD_ADDR_EXP 115
60578: PUSH
60579: LD_EXP 115
60583: PPUSH
60584: LD_VAR 0 7
60588: PUSH
60589: LD_EXP 115
60593: PUSH
60594: LD_VAR 0 7
60598: ARRAY
60599: PUSH
60600: LD_INT 1
60602: PLUS
60603: PUSH
60604: EMPTY
60605: LIST
60606: LIST
60607: PPUSH
60608: LD_VAR 0 4
60612: PUSH
60613: LD_VAR 0 2
60617: PUSH
60618: LD_VAR 0 3
60622: PUSH
60623: EMPTY
60624: LIST
60625: LIST
60626: LIST
60627: PPUSH
60628: CALL 71221 0 3
60632: ST_TO_ADDR
// exit ;
60633: POP
60634: POP
60635: POP
60636: POP
60637: GO 60812
// end ;
60639: GO 60550
60641: POP
60642: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60643: LD_ADDR_VAR 0 9
60647: PUSH
60648: LD_EXP 99
60652: PUSH
60653: LD_VAR 0 7
60657: ARRAY
60658: PPUSH
60659: LD_INT 2
60661: PUSH
60662: LD_INT 30
60664: PUSH
60665: LD_INT 0
60667: PUSH
60668: EMPTY
60669: LIST
60670: LIST
60671: PUSH
60672: LD_INT 30
60674: PUSH
60675: LD_INT 1
60677: PUSH
60678: EMPTY
60679: LIST
60680: LIST
60681: PUSH
60682: EMPTY
60683: LIST
60684: LIST
60685: LIST
60686: PPUSH
60687: CALL_OW 72
60691: ST_TO_ADDR
// if not depot then
60692: LD_VAR 0 9
60696: NOT
60697: IFFALSE 60701
// continue ;
60699: GO 60519
// for j in depot do
60701: LD_ADDR_VAR 0 8
60705: PUSH
60706: LD_VAR 0 9
60710: PUSH
60711: FOR_IN
60712: IFFALSE 60806
// if GetDistUnitXY ( j , x , y ) < 30 then
60714: LD_VAR 0 8
60718: PPUSH
60719: LD_VAR 0 2
60723: PPUSH
60724: LD_VAR 0 3
60728: PPUSH
60729: CALL_OW 297
60733: PUSH
60734: LD_INT 30
60736: LESS
60737: IFFALSE 60804
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60739: LD_ADDR_EXP 115
60743: PUSH
60744: LD_EXP 115
60748: PPUSH
60749: LD_VAR 0 7
60753: PUSH
60754: LD_EXP 115
60758: PUSH
60759: LD_VAR 0 7
60763: ARRAY
60764: PUSH
60765: LD_INT 1
60767: PLUS
60768: PUSH
60769: EMPTY
60770: LIST
60771: LIST
60772: PPUSH
60773: LD_VAR 0 4
60777: PUSH
60778: LD_VAR 0 2
60782: PUSH
60783: LD_VAR 0 3
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: PPUSH
60793: CALL 71221 0 3
60797: ST_TO_ADDR
// exit ;
60798: POP
60799: POP
60800: POP
60801: POP
60802: GO 60812
// end ;
60804: GO 60711
60806: POP
60807: POP
// end ;
60808: GO 60519
60810: POP
60811: POP
// end ;
60812: LD_VAR 0 6
60816: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60817: LD_INT 0
60819: PPUSH
60820: PPUSH
60821: PPUSH
60822: PPUSH
// if not mc_bases or not skirmish then
60823: LD_EXP 99
60827: NOT
60828: PUSH
60829: LD_EXP 97
60833: NOT
60834: OR
60835: IFFALSE 60839
// exit ;
60837: GO 61116
// side := GetSide ( lab ) ;
60839: LD_ADDR_VAR 0 4
60843: PUSH
60844: LD_VAR 0 2
60848: PPUSH
60849: CALL_OW 255
60853: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60854: LD_VAR 0 4
60858: PUSH
60859: LD_EXP 125
60863: IN
60864: NOT
60865: PUSH
60866: LD_EXP 126
60870: NOT
60871: OR
60872: PUSH
60873: LD_EXP 99
60877: NOT
60878: OR
60879: IFFALSE 60883
// exit ;
60881: GO 61116
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60883: LD_ADDR_EXP 126
60887: PUSH
60888: LD_EXP 126
60892: PPUSH
60893: LD_VAR 0 4
60897: PPUSH
60898: LD_EXP 126
60902: PUSH
60903: LD_VAR 0 4
60907: ARRAY
60908: PUSH
60909: LD_VAR 0 1
60913: DIFF
60914: PPUSH
60915: CALL_OW 1
60919: ST_TO_ADDR
// for i = 1 to mc_bases do
60920: LD_ADDR_VAR 0 5
60924: PUSH
60925: DOUBLE
60926: LD_INT 1
60928: DEC
60929: ST_TO_ADDR
60930: LD_EXP 99
60934: PUSH
60935: FOR_TO
60936: IFFALSE 61114
// begin if lab in mc_bases [ i ] then
60938: LD_VAR 0 2
60942: PUSH
60943: LD_EXP 99
60947: PUSH
60948: LD_VAR 0 5
60952: ARRAY
60953: IN
60954: IFFALSE 61112
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60956: LD_VAR 0 1
60960: PUSH
60961: LD_INT 11
60963: PUSH
60964: LD_INT 4
60966: PUSH
60967: LD_INT 3
60969: PUSH
60970: LD_INT 2
60972: PUSH
60973: EMPTY
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: IN
60979: PUSH
60980: LD_EXP 129
60984: PUSH
60985: LD_VAR 0 5
60989: ARRAY
60990: AND
60991: IFFALSE 61112
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60993: LD_ADDR_VAR 0 6
60997: PUSH
60998: LD_EXP 129
61002: PUSH
61003: LD_VAR 0 5
61007: ARRAY
61008: PUSH
61009: LD_INT 1
61011: ARRAY
61012: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61013: LD_ADDR_EXP 129
61017: PUSH
61018: LD_EXP 129
61022: PPUSH
61023: LD_VAR 0 5
61027: PPUSH
61028: EMPTY
61029: PPUSH
61030: CALL_OW 1
61034: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61035: LD_VAR 0 6
61039: PPUSH
61040: LD_INT 0
61042: PPUSH
61043: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61047: LD_VAR 0 6
61051: PPUSH
61052: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61056: LD_ADDR_EXP 128
61060: PUSH
61061: LD_EXP 128
61065: PPUSH
61066: LD_VAR 0 5
61070: PPUSH
61071: LD_EXP 128
61075: PUSH
61076: LD_VAR 0 5
61080: ARRAY
61081: PPUSH
61082: LD_INT 1
61084: PPUSH
61085: LD_VAR 0 6
61089: PPUSH
61090: CALL_OW 2
61094: PPUSH
61095: CALL_OW 1
61099: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61100: LD_VAR 0 5
61104: PPUSH
61105: LD_INT 112
61107: PPUSH
61108: CALL 38008 0 2
// end ; end ; end ;
61112: GO 60935
61114: POP
61115: POP
// end ;
61116: LD_VAR 0 3
61120: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61121: LD_INT 0
61123: PPUSH
61124: PPUSH
61125: PPUSH
61126: PPUSH
61127: PPUSH
61128: PPUSH
61129: PPUSH
61130: PPUSH
// if not mc_bases or not skirmish then
61131: LD_EXP 99
61135: NOT
61136: PUSH
61137: LD_EXP 97
61141: NOT
61142: OR
61143: IFFALSE 61147
// exit ;
61145: GO 62518
// for i = 1 to mc_bases do
61147: LD_ADDR_VAR 0 3
61151: PUSH
61152: DOUBLE
61153: LD_INT 1
61155: DEC
61156: ST_TO_ADDR
61157: LD_EXP 99
61161: PUSH
61162: FOR_TO
61163: IFFALSE 62516
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61165: LD_VAR 0 1
61169: PUSH
61170: LD_EXP 99
61174: PUSH
61175: LD_VAR 0 3
61179: ARRAY
61180: IN
61181: PUSH
61182: LD_VAR 0 1
61186: PUSH
61187: LD_EXP 106
61191: PUSH
61192: LD_VAR 0 3
61196: ARRAY
61197: IN
61198: OR
61199: PUSH
61200: LD_VAR 0 1
61204: PUSH
61205: LD_EXP 121
61209: PUSH
61210: LD_VAR 0 3
61214: ARRAY
61215: IN
61216: OR
61217: PUSH
61218: LD_VAR 0 1
61222: PUSH
61223: LD_EXP 118
61227: PUSH
61228: LD_VAR 0 3
61232: ARRAY
61233: IN
61234: OR
61235: PUSH
61236: LD_VAR 0 1
61240: PUSH
61241: LD_EXP 128
61245: PUSH
61246: LD_VAR 0 3
61250: ARRAY
61251: IN
61252: OR
61253: PUSH
61254: LD_VAR 0 1
61258: PUSH
61259: LD_EXP 129
61263: PUSH
61264: LD_VAR 0 3
61268: ARRAY
61269: IN
61270: OR
61271: IFFALSE 62514
// begin if un in mc_ape [ i ] then
61273: LD_VAR 0 1
61277: PUSH
61278: LD_EXP 128
61282: PUSH
61283: LD_VAR 0 3
61287: ARRAY
61288: IN
61289: IFFALSE 61328
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61291: LD_ADDR_EXP 128
61295: PUSH
61296: LD_EXP 128
61300: PPUSH
61301: LD_VAR 0 3
61305: PPUSH
61306: LD_EXP 128
61310: PUSH
61311: LD_VAR 0 3
61315: ARRAY
61316: PUSH
61317: LD_VAR 0 1
61321: DIFF
61322: PPUSH
61323: CALL_OW 1
61327: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61328: LD_VAR 0 1
61332: PUSH
61333: LD_EXP 129
61337: PUSH
61338: LD_VAR 0 3
61342: ARRAY
61343: IN
61344: IFFALSE 61368
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61346: LD_ADDR_EXP 129
61350: PUSH
61351: LD_EXP 129
61355: PPUSH
61356: LD_VAR 0 3
61360: PPUSH
61361: EMPTY
61362: PPUSH
61363: CALL_OW 1
61367: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61368: LD_VAR 0 1
61372: PPUSH
61373: CALL_OW 247
61377: PUSH
61378: LD_INT 2
61380: EQUAL
61381: PUSH
61382: LD_VAR 0 1
61386: PPUSH
61387: CALL_OW 110
61391: PUSH
61392: LD_INT 20
61394: EQUAL
61395: PUSH
61396: LD_VAR 0 1
61400: PUSH
61401: LD_EXP 121
61405: PUSH
61406: LD_VAR 0 3
61410: ARRAY
61411: IN
61412: OR
61413: PUSH
61414: LD_VAR 0 1
61418: PPUSH
61419: CALL_OW 264
61423: PUSH
61424: LD_INT 12
61426: PUSH
61427: LD_INT 51
61429: PUSH
61430: LD_EXP 93
61434: PUSH
61435: LD_INT 32
61437: PUSH
61438: LD_INT 13
61440: PUSH
61441: LD_INT 52
61443: PUSH
61444: LD_INT 31
61446: PUSH
61447: EMPTY
61448: LIST
61449: LIST
61450: LIST
61451: LIST
61452: LIST
61453: LIST
61454: LIST
61455: IN
61456: OR
61457: AND
61458: IFFALSE 61766
// begin if un in mc_defender [ i ] then
61460: LD_VAR 0 1
61464: PUSH
61465: LD_EXP 121
61469: PUSH
61470: LD_VAR 0 3
61474: ARRAY
61475: IN
61476: IFFALSE 61515
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61478: LD_ADDR_EXP 121
61482: PUSH
61483: LD_EXP 121
61487: PPUSH
61488: LD_VAR 0 3
61492: PPUSH
61493: LD_EXP 121
61497: PUSH
61498: LD_VAR 0 3
61502: ARRAY
61503: PUSH
61504: LD_VAR 0 1
61508: DIFF
61509: PPUSH
61510: CALL_OW 1
61514: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61515: LD_ADDR_VAR 0 8
61519: PUSH
61520: LD_VAR 0 3
61524: PPUSH
61525: LD_INT 3
61527: PPUSH
61528: CALL 58184 0 2
61532: ST_TO_ADDR
// if fac then
61533: LD_VAR 0 8
61537: IFFALSE 61766
// begin for j in fac do
61539: LD_ADDR_VAR 0 4
61543: PUSH
61544: LD_VAR 0 8
61548: PUSH
61549: FOR_IN
61550: IFFALSE 61764
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61552: LD_ADDR_VAR 0 9
61556: PUSH
61557: LD_VAR 0 8
61561: PPUSH
61562: LD_VAR 0 1
61566: PPUSH
61567: CALL_OW 265
61571: PPUSH
61572: LD_VAR 0 1
61576: PPUSH
61577: CALL_OW 262
61581: PPUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: CALL_OW 263
61591: PPUSH
61592: LD_VAR 0 1
61596: PPUSH
61597: CALL_OW 264
61601: PPUSH
61602: CALL 68753 0 5
61606: ST_TO_ADDR
// if components then
61607: LD_VAR 0 9
61611: IFFALSE 61762
// begin if GetWeapon ( un ) = ar_control_tower then
61613: LD_VAR 0 1
61617: PPUSH
61618: CALL_OW 264
61622: PUSH
61623: LD_INT 31
61625: EQUAL
61626: IFFALSE 61743
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61628: LD_VAR 0 1
61632: PPUSH
61633: CALL_OW 311
61637: PPUSH
61638: LD_INT 0
61640: PPUSH
61641: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61645: LD_ADDR_EXP 139
61649: PUSH
61650: LD_EXP 139
61654: PPUSH
61655: LD_VAR 0 3
61659: PPUSH
61660: LD_EXP 139
61664: PUSH
61665: LD_VAR 0 3
61669: ARRAY
61670: PUSH
61671: LD_VAR 0 1
61675: PPUSH
61676: CALL_OW 311
61680: DIFF
61681: PPUSH
61682: CALL_OW 1
61686: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61687: LD_ADDR_VAR 0 7
61691: PUSH
61692: LD_EXP 120
61696: PUSH
61697: LD_VAR 0 3
61701: ARRAY
61702: PPUSH
61703: LD_INT 1
61705: PPUSH
61706: LD_VAR 0 9
61710: PPUSH
61711: CALL_OW 2
61715: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61716: LD_ADDR_EXP 120
61720: PUSH
61721: LD_EXP 120
61725: PPUSH
61726: LD_VAR 0 3
61730: PPUSH
61731: LD_VAR 0 7
61735: PPUSH
61736: CALL_OW 1
61740: ST_TO_ADDR
// end else
61741: GO 61760
// MC_InsertProduceList ( i , [ components ] ) ;
61743: LD_VAR 0 3
61747: PPUSH
61748: LD_VAR 0 9
61752: PUSH
61753: EMPTY
61754: LIST
61755: PPUSH
61756: CALL 57729 0 2
// break ;
61760: GO 61764
// end ; end ;
61762: GO 61549
61764: POP
61765: POP
// end ; end ; if GetType ( un ) = unit_building then
61766: LD_VAR 0 1
61770: PPUSH
61771: CALL_OW 247
61775: PUSH
61776: LD_INT 3
61778: EQUAL
61779: IFFALSE 62182
// begin btype := GetBType ( un ) ;
61781: LD_ADDR_VAR 0 5
61785: PUSH
61786: LD_VAR 0 1
61790: PPUSH
61791: CALL_OW 266
61795: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61796: LD_VAR 0 5
61800: PUSH
61801: LD_INT 29
61803: PUSH
61804: LD_INT 30
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: IN
61811: IFFALSE 61884
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61813: LD_VAR 0 1
61817: PPUSH
61818: CALL_OW 250
61822: PPUSH
61823: LD_VAR 0 1
61827: PPUSH
61828: CALL_OW 251
61832: PPUSH
61833: LD_VAR 0 1
61837: PPUSH
61838: CALL_OW 255
61842: PPUSH
61843: CALL_OW 440
61847: NOT
61848: IFFALSE 61884
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61850: LD_VAR 0 1
61854: PPUSH
61855: CALL_OW 250
61859: PPUSH
61860: LD_VAR 0 1
61864: PPUSH
61865: CALL_OW 251
61869: PPUSH
61870: LD_VAR 0 1
61874: PPUSH
61875: CALL_OW 255
61879: PPUSH
61880: CALL_OW 441
// end ; if btype = b_warehouse then
61884: LD_VAR 0 5
61888: PUSH
61889: LD_INT 1
61891: EQUAL
61892: IFFALSE 61910
// begin btype := b_depot ;
61894: LD_ADDR_VAR 0 5
61898: PUSH
61899: LD_INT 0
61901: ST_TO_ADDR
// pos := 1 ;
61902: LD_ADDR_VAR 0 6
61906: PUSH
61907: LD_INT 1
61909: ST_TO_ADDR
// end ; if btype = b_factory then
61910: LD_VAR 0 5
61914: PUSH
61915: LD_INT 3
61917: EQUAL
61918: IFFALSE 61936
// begin btype := b_workshop ;
61920: LD_ADDR_VAR 0 5
61924: PUSH
61925: LD_INT 2
61927: ST_TO_ADDR
// pos := 1 ;
61928: LD_ADDR_VAR 0 6
61932: PUSH
61933: LD_INT 1
61935: ST_TO_ADDR
// end ; if btype = b_barracks then
61936: LD_VAR 0 5
61940: PUSH
61941: LD_INT 5
61943: EQUAL
61944: IFFALSE 61954
// btype := b_armoury ;
61946: LD_ADDR_VAR 0 5
61950: PUSH
61951: LD_INT 4
61953: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61954: LD_VAR 0 5
61958: PUSH
61959: LD_INT 7
61961: PUSH
61962: LD_INT 8
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: IN
61969: IFFALSE 61979
// btype := b_lab ;
61971: LD_ADDR_VAR 0 5
61975: PUSH
61976: LD_INT 6
61978: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61979: LD_ADDR_EXP 104
61983: PUSH
61984: LD_EXP 104
61988: PPUSH
61989: LD_VAR 0 3
61993: PUSH
61994: LD_EXP 104
61998: PUSH
61999: LD_VAR 0 3
62003: ARRAY
62004: PUSH
62005: LD_INT 1
62007: PLUS
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: PPUSH
62013: LD_VAR 0 5
62017: PUSH
62018: LD_VAR 0 1
62022: PPUSH
62023: CALL_OW 250
62027: PUSH
62028: LD_VAR 0 1
62032: PPUSH
62033: CALL_OW 251
62037: PUSH
62038: LD_VAR 0 1
62042: PPUSH
62043: CALL_OW 254
62047: PUSH
62048: EMPTY
62049: LIST
62050: LIST
62051: LIST
62052: LIST
62053: PPUSH
62054: CALL 71221 0 3
62058: ST_TO_ADDR
// if pos = 1 then
62059: LD_VAR 0 6
62063: PUSH
62064: LD_INT 1
62066: EQUAL
62067: IFFALSE 62182
// begin tmp := mc_build_list [ i ] ;
62069: LD_ADDR_VAR 0 7
62073: PUSH
62074: LD_EXP 104
62078: PUSH
62079: LD_VAR 0 3
62083: ARRAY
62084: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62085: LD_VAR 0 7
62089: PPUSH
62090: LD_INT 2
62092: PUSH
62093: LD_INT 30
62095: PUSH
62096: LD_INT 0
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: PUSH
62103: LD_INT 30
62105: PUSH
62106: LD_INT 1
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: LIST
62117: PPUSH
62118: CALL_OW 72
62122: IFFALSE 62132
// pos := 2 ;
62124: LD_ADDR_VAR 0 6
62128: PUSH
62129: LD_INT 2
62131: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62132: LD_ADDR_VAR 0 7
62136: PUSH
62137: LD_VAR 0 7
62141: PPUSH
62142: LD_VAR 0 6
62146: PPUSH
62147: LD_VAR 0 7
62151: PPUSH
62152: CALL 71547 0 3
62156: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62157: LD_ADDR_EXP 104
62161: PUSH
62162: LD_EXP 104
62166: PPUSH
62167: LD_VAR 0 3
62171: PPUSH
62172: LD_VAR 0 7
62176: PPUSH
62177: CALL_OW 1
62181: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62182: LD_VAR 0 1
62186: PUSH
62187: LD_EXP 99
62191: PUSH
62192: LD_VAR 0 3
62196: ARRAY
62197: IN
62198: IFFALSE 62237
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62200: LD_ADDR_EXP 99
62204: PUSH
62205: LD_EXP 99
62209: PPUSH
62210: LD_VAR 0 3
62214: PPUSH
62215: LD_EXP 99
62219: PUSH
62220: LD_VAR 0 3
62224: ARRAY
62225: PUSH
62226: LD_VAR 0 1
62230: DIFF
62231: PPUSH
62232: CALL_OW 1
62236: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62237: LD_VAR 0 1
62241: PUSH
62242: LD_EXP 106
62246: PUSH
62247: LD_VAR 0 3
62251: ARRAY
62252: IN
62253: IFFALSE 62292
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62255: LD_ADDR_EXP 106
62259: PUSH
62260: LD_EXP 106
62264: PPUSH
62265: LD_VAR 0 3
62269: PPUSH
62270: LD_EXP 106
62274: PUSH
62275: LD_VAR 0 3
62279: ARRAY
62280: PUSH
62281: LD_VAR 0 1
62285: DIFF
62286: PPUSH
62287: CALL_OW 1
62291: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62292: LD_VAR 0 1
62296: PUSH
62297: LD_EXP 118
62301: PUSH
62302: LD_VAR 0 3
62306: ARRAY
62307: IN
62308: IFFALSE 62347
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62310: LD_ADDR_EXP 118
62314: PUSH
62315: LD_EXP 118
62319: PPUSH
62320: LD_VAR 0 3
62324: PPUSH
62325: LD_EXP 118
62329: PUSH
62330: LD_VAR 0 3
62334: ARRAY
62335: PUSH
62336: LD_VAR 0 1
62340: DIFF
62341: PPUSH
62342: CALL_OW 1
62346: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62347: LD_VAR 0 1
62351: PUSH
62352: LD_EXP 121
62356: PUSH
62357: LD_VAR 0 3
62361: ARRAY
62362: IN
62363: IFFALSE 62402
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62365: LD_ADDR_EXP 121
62369: PUSH
62370: LD_EXP 121
62374: PPUSH
62375: LD_VAR 0 3
62379: PPUSH
62380: LD_EXP 121
62384: PUSH
62385: LD_VAR 0 3
62389: ARRAY
62390: PUSH
62391: LD_VAR 0 1
62395: DIFF
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62402: LD_VAR 0 1
62406: PUSH
62407: LD_EXP 108
62411: PUSH
62412: LD_VAR 0 3
62416: ARRAY
62417: IN
62418: IFFALSE 62457
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62420: LD_ADDR_EXP 108
62424: PUSH
62425: LD_EXP 108
62429: PPUSH
62430: LD_VAR 0 3
62434: PPUSH
62435: LD_EXP 108
62439: PUSH
62440: LD_VAR 0 3
62444: ARRAY
62445: PUSH
62446: LD_VAR 0 1
62450: DIFF
62451: PPUSH
62452: CALL_OW 1
62456: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62457: LD_VAR 0 1
62461: PUSH
62462: LD_EXP 107
62466: PUSH
62467: LD_VAR 0 3
62471: ARRAY
62472: IN
62473: IFFALSE 62512
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62475: LD_ADDR_EXP 107
62479: PUSH
62480: LD_EXP 107
62484: PPUSH
62485: LD_VAR 0 3
62489: PPUSH
62490: LD_EXP 107
62494: PUSH
62495: LD_VAR 0 3
62499: ARRAY
62500: PUSH
62501: LD_VAR 0 1
62505: DIFF
62506: PPUSH
62507: CALL_OW 1
62511: ST_TO_ADDR
// end ; break ;
62512: GO 62516
// end ;
62514: GO 61162
62516: POP
62517: POP
// end ;
62518: LD_VAR 0 2
62522: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62523: LD_INT 0
62525: PPUSH
62526: PPUSH
62527: PPUSH
// if not mc_bases or not skirmish then
62528: LD_EXP 99
62532: NOT
62533: PUSH
62534: LD_EXP 97
62538: NOT
62539: OR
62540: IFFALSE 62544
// exit ;
62542: GO 62759
// for i = 1 to mc_bases do
62544: LD_ADDR_VAR 0 3
62548: PUSH
62549: DOUBLE
62550: LD_INT 1
62552: DEC
62553: ST_TO_ADDR
62554: LD_EXP 99
62558: PUSH
62559: FOR_TO
62560: IFFALSE 62757
// begin if building in mc_construct_list [ i ] then
62562: LD_VAR 0 1
62566: PUSH
62567: LD_EXP 106
62571: PUSH
62572: LD_VAR 0 3
62576: ARRAY
62577: IN
62578: IFFALSE 62755
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62580: LD_ADDR_EXP 106
62584: PUSH
62585: LD_EXP 106
62589: PPUSH
62590: LD_VAR 0 3
62594: PPUSH
62595: LD_EXP 106
62599: PUSH
62600: LD_VAR 0 3
62604: ARRAY
62605: PUSH
62606: LD_VAR 0 1
62610: DIFF
62611: PPUSH
62612: CALL_OW 1
62616: ST_TO_ADDR
// if building in mc_lab [ i ] then
62617: LD_VAR 0 1
62621: PUSH
62622: LD_EXP 132
62626: PUSH
62627: LD_VAR 0 3
62631: ARRAY
62632: IN
62633: IFFALSE 62688
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62635: LD_ADDR_EXP 133
62639: PUSH
62640: LD_EXP 133
62644: PPUSH
62645: LD_VAR 0 3
62649: PPUSH
62650: LD_EXP 133
62654: PUSH
62655: LD_VAR 0 3
62659: ARRAY
62660: PPUSH
62661: LD_INT 1
62663: PPUSH
62664: LD_EXP 133
62668: PUSH
62669: LD_VAR 0 3
62673: ARRAY
62674: PPUSH
62675: LD_INT 0
62677: PPUSH
62678: CALL 70639 0 4
62682: PPUSH
62683: CALL_OW 1
62687: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62688: LD_VAR 0 1
62692: PUSH
62693: LD_EXP 99
62697: PUSH
62698: LD_VAR 0 3
62702: ARRAY
62703: IN
62704: NOT
62705: IFFALSE 62751
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62707: LD_ADDR_EXP 99
62711: PUSH
62712: LD_EXP 99
62716: PPUSH
62717: LD_VAR 0 3
62721: PUSH
62722: LD_EXP 99
62726: PUSH
62727: LD_VAR 0 3
62731: ARRAY
62732: PUSH
62733: LD_INT 1
62735: PLUS
62736: PUSH
62737: EMPTY
62738: LIST
62739: LIST
62740: PPUSH
62741: LD_VAR 0 1
62745: PPUSH
62746: CALL 71221 0 3
62750: ST_TO_ADDR
// exit ;
62751: POP
62752: POP
62753: GO 62759
// end ; end ;
62755: GO 62559
62757: POP
62758: POP
// end ;
62759: LD_VAR 0 2
62763: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62764: LD_INT 0
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
// if not mc_bases or not skirmish then
62773: LD_EXP 99
62777: NOT
62778: PUSH
62779: LD_EXP 97
62783: NOT
62784: OR
62785: IFFALSE 62789
// exit ;
62787: GO 63450
// for i = 1 to mc_bases do
62789: LD_ADDR_VAR 0 3
62793: PUSH
62794: DOUBLE
62795: LD_INT 1
62797: DEC
62798: ST_TO_ADDR
62799: LD_EXP 99
62803: PUSH
62804: FOR_TO
62805: IFFALSE 63448
// begin if building in mc_construct_list [ i ] then
62807: LD_VAR 0 1
62811: PUSH
62812: LD_EXP 106
62816: PUSH
62817: LD_VAR 0 3
62821: ARRAY
62822: IN
62823: IFFALSE 63446
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62825: LD_ADDR_EXP 106
62829: PUSH
62830: LD_EXP 106
62834: PPUSH
62835: LD_VAR 0 3
62839: PPUSH
62840: LD_EXP 106
62844: PUSH
62845: LD_VAR 0 3
62849: ARRAY
62850: PUSH
62851: LD_VAR 0 1
62855: DIFF
62856: PPUSH
62857: CALL_OW 1
62861: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62862: LD_ADDR_EXP 99
62866: PUSH
62867: LD_EXP 99
62871: PPUSH
62872: LD_VAR 0 3
62876: PUSH
62877: LD_EXP 99
62881: PUSH
62882: LD_VAR 0 3
62886: ARRAY
62887: PUSH
62888: LD_INT 1
62890: PLUS
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: PPUSH
62896: LD_VAR 0 1
62900: PPUSH
62901: CALL 71221 0 3
62905: ST_TO_ADDR
// btype := GetBType ( building ) ;
62906: LD_ADDR_VAR 0 5
62910: PUSH
62911: LD_VAR 0 1
62915: PPUSH
62916: CALL_OW 266
62920: ST_TO_ADDR
// side := GetSide ( building ) ;
62921: LD_ADDR_VAR 0 8
62925: PUSH
62926: LD_VAR 0 1
62930: PPUSH
62931: CALL_OW 255
62935: ST_TO_ADDR
// if btype = b_lab then
62936: LD_VAR 0 5
62940: PUSH
62941: LD_INT 6
62943: EQUAL
62944: IFFALSE 62994
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62946: LD_ADDR_EXP 132
62950: PUSH
62951: LD_EXP 132
62955: PPUSH
62956: LD_VAR 0 3
62960: PUSH
62961: LD_EXP 132
62965: PUSH
62966: LD_VAR 0 3
62970: ARRAY
62971: PUSH
62972: LD_INT 1
62974: PLUS
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PPUSH
62980: LD_VAR 0 1
62984: PPUSH
62985: CALL 71221 0 3
62989: ST_TO_ADDR
// exit ;
62990: POP
62991: POP
62992: GO 63450
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62994: LD_VAR 0 5
62998: PUSH
62999: LD_INT 0
63001: PUSH
63002: LD_INT 2
63004: PUSH
63005: LD_INT 4
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: LIST
63012: IN
63013: IFFALSE 63137
// begin if btype = b_armoury then
63015: LD_VAR 0 5
63019: PUSH
63020: LD_INT 4
63022: EQUAL
63023: IFFALSE 63033
// btype := b_barracks ;
63025: LD_ADDR_VAR 0 5
63029: PUSH
63030: LD_INT 5
63032: ST_TO_ADDR
// if btype = b_depot then
63033: LD_VAR 0 5
63037: PUSH
63038: LD_INT 0
63040: EQUAL
63041: IFFALSE 63051
// btype := b_warehouse ;
63043: LD_ADDR_VAR 0 5
63047: PUSH
63048: LD_INT 1
63050: ST_TO_ADDR
// if btype = b_workshop then
63051: LD_VAR 0 5
63055: PUSH
63056: LD_INT 2
63058: EQUAL
63059: IFFALSE 63069
// btype := b_factory ;
63061: LD_ADDR_VAR 0 5
63065: PUSH
63066: LD_INT 3
63068: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63069: LD_VAR 0 5
63073: PPUSH
63074: LD_VAR 0 8
63078: PPUSH
63079: CALL_OW 323
63083: PUSH
63084: LD_INT 1
63086: EQUAL
63087: IFFALSE 63133
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63089: LD_ADDR_EXP 131
63093: PUSH
63094: LD_EXP 131
63098: PPUSH
63099: LD_VAR 0 3
63103: PUSH
63104: LD_EXP 131
63108: PUSH
63109: LD_VAR 0 3
63113: ARRAY
63114: PUSH
63115: LD_INT 1
63117: PLUS
63118: PUSH
63119: EMPTY
63120: LIST
63121: LIST
63122: PPUSH
63123: LD_VAR 0 1
63127: PPUSH
63128: CALL 71221 0 3
63132: ST_TO_ADDR
// exit ;
63133: POP
63134: POP
63135: GO 63450
// end ; if btype in [ b_bunker , b_turret ] then
63137: LD_VAR 0 5
63141: PUSH
63142: LD_INT 32
63144: PUSH
63145: LD_INT 33
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: IN
63152: IFFALSE 63442
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63154: LD_ADDR_EXP 107
63158: PUSH
63159: LD_EXP 107
63163: PPUSH
63164: LD_VAR 0 3
63168: PUSH
63169: LD_EXP 107
63173: PUSH
63174: LD_VAR 0 3
63178: ARRAY
63179: PUSH
63180: LD_INT 1
63182: PLUS
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PPUSH
63188: LD_VAR 0 1
63192: PPUSH
63193: CALL 71221 0 3
63197: ST_TO_ADDR
// if btype = b_bunker then
63198: LD_VAR 0 5
63202: PUSH
63203: LD_INT 32
63205: EQUAL
63206: IFFALSE 63442
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63208: LD_ADDR_EXP 108
63212: PUSH
63213: LD_EXP 108
63217: PPUSH
63218: LD_VAR 0 3
63222: PUSH
63223: LD_EXP 108
63227: PUSH
63228: LD_VAR 0 3
63232: ARRAY
63233: PUSH
63234: LD_INT 1
63236: PLUS
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: PPUSH
63242: LD_VAR 0 1
63246: PPUSH
63247: CALL 71221 0 3
63251: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63252: LD_ADDR_VAR 0 6
63256: PUSH
63257: LD_EXP 99
63261: PUSH
63262: LD_VAR 0 3
63266: ARRAY
63267: PPUSH
63268: LD_INT 25
63270: PUSH
63271: LD_INT 1
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: LD_INT 3
63280: PUSH
63281: LD_INT 54
63283: PUSH
63284: EMPTY
63285: LIST
63286: PUSH
63287: EMPTY
63288: LIST
63289: LIST
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PPUSH
63295: CALL_OW 72
63299: ST_TO_ADDR
// if tmp then
63300: LD_VAR 0 6
63304: IFFALSE 63310
// exit ;
63306: POP
63307: POP
63308: GO 63450
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63310: LD_ADDR_VAR 0 6
63314: PUSH
63315: LD_EXP 99
63319: PUSH
63320: LD_VAR 0 3
63324: ARRAY
63325: PPUSH
63326: LD_INT 2
63328: PUSH
63329: LD_INT 30
63331: PUSH
63332: LD_INT 4
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 30
63341: PUSH
63342: LD_INT 5
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: PUSH
63349: EMPTY
63350: LIST
63351: LIST
63352: LIST
63353: PPUSH
63354: CALL_OW 72
63358: ST_TO_ADDR
// if not tmp then
63359: LD_VAR 0 6
63363: NOT
63364: IFFALSE 63370
// exit ;
63366: POP
63367: POP
63368: GO 63450
// for j in tmp do
63370: LD_ADDR_VAR 0 4
63374: PUSH
63375: LD_VAR 0 6
63379: PUSH
63380: FOR_IN
63381: IFFALSE 63440
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63383: LD_ADDR_VAR 0 7
63387: PUSH
63388: LD_VAR 0 4
63392: PPUSH
63393: CALL_OW 313
63397: PPUSH
63398: LD_INT 25
63400: PUSH
63401: LD_INT 1
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: PPUSH
63408: CALL_OW 72
63412: ST_TO_ADDR
// if units then
63413: LD_VAR 0 7
63417: IFFALSE 63438
// begin ComExitBuilding ( units [ 1 ] ) ;
63419: LD_VAR 0 7
63423: PUSH
63424: LD_INT 1
63426: ARRAY
63427: PPUSH
63428: CALL_OW 122
// exit ;
63432: POP
63433: POP
63434: POP
63435: POP
63436: GO 63450
// end ; end ;
63438: GO 63380
63440: POP
63441: POP
// end ; end ; exit ;
63442: POP
63443: POP
63444: GO 63450
// end ; end ;
63446: GO 62804
63448: POP
63449: POP
// end ;
63450: LD_VAR 0 2
63454: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63455: LD_INT 0
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
63461: PPUSH
63462: PPUSH
63463: PPUSH
// if not mc_bases or not skirmish then
63464: LD_EXP 99
63468: NOT
63469: PUSH
63470: LD_EXP 97
63474: NOT
63475: OR
63476: IFFALSE 63480
// exit ;
63478: GO 63711
// btype := GetBType ( building ) ;
63480: LD_ADDR_VAR 0 6
63484: PUSH
63485: LD_VAR 0 1
63489: PPUSH
63490: CALL_OW 266
63494: ST_TO_ADDR
// x := GetX ( building ) ;
63495: LD_ADDR_VAR 0 7
63499: PUSH
63500: LD_VAR 0 1
63504: PPUSH
63505: CALL_OW 250
63509: ST_TO_ADDR
// y := GetY ( building ) ;
63510: LD_ADDR_VAR 0 8
63514: PUSH
63515: LD_VAR 0 1
63519: PPUSH
63520: CALL_OW 251
63524: ST_TO_ADDR
// d := GetDir ( building ) ;
63525: LD_ADDR_VAR 0 9
63529: PUSH
63530: LD_VAR 0 1
63534: PPUSH
63535: CALL_OW 254
63539: ST_TO_ADDR
// for i = 1 to mc_bases do
63540: LD_ADDR_VAR 0 4
63544: PUSH
63545: DOUBLE
63546: LD_INT 1
63548: DEC
63549: ST_TO_ADDR
63550: LD_EXP 99
63554: PUSH
63555: FOR_TO
63556: IFFALSE 63709
// begin if not mc_build_list [ i ] then
63558: LD_EXP 104
63562: PUSH
63563: LD_VAR 0 4
63567: ARRAY
63568: NOT
63569: IFFALSE 63573
// continue ;
63571: GO 63555
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63573: LD_VAR 0 6
63577: PUSH
63578: LD_VAR 0 7
63582: PUSH
63583: LD_VAR 0 8
63587: PUSH
63588: LD_VAR 0 9
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: PPUSH
63599: LD_EXP 104
63603: PUSH
63604: LD_VAR 0 4
63608: ARRAY
63609: PUSH
63610: LD_INT 1
63612: ARRAY
63613: PPUSH
63614: CALL 77390 0 2
63618: IFFALSE 63707
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63620: LD_ADDR_EXP 104
63624: PUSH
63625: LD_EXP 104
63629: PPUSH
63630: LD_VAR 0 4
63634: PPUSH
63635: LD_EXP 104
63639: PUSH
63640: LD_VAR 0 4
63644: ARRAY
63645: PPUSH
63646: LD_INT 1
63648: PPUSH
63649: CALL_OW 3
63653: PPUSH
63654: CALL_OW 1
63658: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63659: LD_ADDR_EXP 106
63663: PUSH
63664: LD_EXP 106
63668: PPUSH
63669: LD_VAR 0 4
63673: PUSH
63674: LD_EXP 106
63678: PUSH
63679: LD_VAR 0 4
63683: ARRAY
63684: PUSH
63685: LD_INT 1
63687: PLUS
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: PPUSH
63693: LD_VAR 0 1
63697: PPUSH
63698: CALL 71221 0 3
63702: ST_TO_ADDR
// exit ;
63703: POP
63704: POP
63705: GO 63711
// end ; end ;
63707: GO 63555
63709: POP
63710: POP
// end ;
63711: LD_VAR 0 3
63715: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63716: LD_INT 0
63718: PPUSH
63719: PPUSH
63720: PPUSH
// if not mc_bases or not skirmish then
63721: LD_EXP 99
63725: NOT
63726: PUSH
63727: LD_EXP 97
63731: NOT
63732: OR
63733: IFFALSE 63737
// exit ;
63735: GO 63927
// for i = 1 to mc_bases do
63737: LD_ADDR_VAR 0 4
63741: PUSH
63742: DOUBLE
63743: LD_INT 1
63745: DEC
63746: ST_TO_ADDR
63747: LD_EXP 99
63751: PUSH
63752: FOR_TO
63753: IFFALSE 63840
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63755: LD_VAR 0 1
63759: PUSH
63760: LD_EXP 107
63764: PUSH
63765: LD_VAR 0 4
63769: ARRAY
63770: IN
63771: PUSH
63772: LD_VAR 0 1
63776: PUSH
63777: LD_EXP 108
63781: PUSH
63782: LD_VAR 0 4
63786: ARRAY
63787: IN
63788: NOT
63789: AND
63790: IFFALSE 63838
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63792: LD_ADDR_EXP 108
63796: PUSH
63797: LD_EXP 108
63801: PPUSH
63802: LD_VAR 0 4
63806: PUSH
63807: LD_EXP 108
63811: PUSH
63812: LD_VAR 0 4
63816: ARRAY
63817: PUSH
63818: LD_INT 1
63820: PLUS
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PPUSH
63826: LD_VAR 0 1
63830: PPUSH
63831: CALL 71221 0 3
63835: ST_TO_ADDR
// break ;
63836: GO 63840
// end ; end ;
63838: GO 63752
63840: POP
63841: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63842: LD_VAR 0 1
63846: PPUSH
63847: CALL_OW 257
63851: PUSH
63852: LD_EXP 125
63856: IN
63857: PUSH
63858: LD_VAR 0 1
63862: PPUSH
63863: CALL_OW 266
63867: PUSH
63868: LD_INT 5
63870: EQUAL
63871: AND
63872: PUSH
63873: LD_VAR 0 2
63877: PPUSH
63878: CALL_OW 110
63882: PUSH
63883: LD_INT 18
63885: NONEQUAL
63886: AND
63887: IFFALSE 63927
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63889: LD_VAR 0 2
63893: PPUSH
63894: CALL_OW 257
63898: PUSH
63899: LD_INT 5
63901: PUSH
63902: LD_INT 8
63904: PUSH
63905: LD_INT 9
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: LIST
63912: IN
63913: IFFALSE 63927
// SetClass ( unit , 1 ) ;
63915: LD_VAR 0 2
63919: PPUSH
63920: LD_INT 1
63922: PPUSH
63923: CALL_OW 336
// end ;
63927: LD_VAR 0 3
63931: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63932: LD_INT 0
63934: PPUSH
63935: PPUSH
// if not mc_bases or not skirmish then
63936: LD_EXP 99
63940: NOT
63941: PUSH
63942: LD_EXP 97
63946: NOT
63947: OR
63948: IFFALSE 63952
// exit ;
63950: GO 64068
// if GetLives ( abandoned_vehicle ) > 250 then
63952: LD_VAR 0 2
63956: PPUSH
63957: CALL_OW 256
63961: PUSH
63962: LD_INT 250
63964: GREATER
63965: IFFALSE 63969
// exit ;
63967: GO 64068
// for i = 1 to mc_bases do
63969: LD_ADDR_VAR 0 6
63973: PUSH
63974: DOUBLE
63975: LD_INT 1
63977: DEC
63978: ST_TO_ADDR
63979: LD_EXP 99
63983: PUSH
63984: FOR_TO
63985: IFFALSE 64066
// begin if driver in mc_bases [ i ] then
63987: LD_VAR 0 1
63991: PUSH
63992: LD_EXP 99
63996: PUSH
63997: LD_VAR 0 6
64001: ARRAY
64002: IN
64003: IFFALSE 64064
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64005: LD_VAR 0 1
64009: PPUSH
64010: LD_EXP 99
64014: PUSH
64015: LD_VAR 0 6
64019: ARRAY
64020: PPUSH
64021: LD_INT 2
64023: PUSH
64024: LD_INT 30
64026: PUSH
64027: LD_INT 0
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 30
64036: PUSH
64037: LD_INT 1
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: LIST
64048: PPUSH
64049: CALL_OW 72
64053: PUSH
64054: LD_INT 1
64056: ARRAY
64057: PPUSH
64058: CALL_OW 112
// break ;
64062: GO 64066
// end ; end ;
64064: GO 63984
64066: POP
64067: POP
// end ; end_of_file
64068: LD_VAR 0 5
64072: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64073: LD_INT 0
64075: PPUSH
64076: PPUSH
// if exist_mode then
64077: LD_VAR 0 2
64081: IFFALSE 64106
// unit := CreateCharacter ( prefix & ident ) else
64083: LD_ADDR_VAR 0 5
64087: PUSH
64088: LD_VAR 0 3
64092: PUSH
64093: LD_VAR 0 1
64097: STR
64098: PPUSH
64099: CALL_OW 34
64103: ST_TO_ADDR
64104: GO 64121
// unit := NewCharacter ( ident ) ;
64106: LD_ADDR_VAR 0 5
64110: PUSH
64111: LD_VAR 0 1
64115: PPUSH
64116: CALL_OW 25
64120: ST_TO_ADDR
// result := unit ;
64121: LD_ADDR_VAR 0 4
64125: PUSH
64126: LD_VAR 0 5
64130: ST_TO_ADDR
// end ;
64131: LD_VAR 0 4
64135: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64136: LD_INT 0
64138: PPUSH
64139: PPUSH
// if not side or not nation then
64140: LD_VAR 0 1
64144: NOT
64145: PUSH
64146: LD_VAR 0 2
64150: NOT
64151: OR
64152: IFFALSE 64156
// exit ;
64154: GO 64800
// case nation of nation_american :
64156: LD_VAR 0 2
64160: PUSH
64161: LD_INT 1
64163: DOUBLE
64164: EQUAL
64165: IFTRUE 64169
64167: GO 64343
64169: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64170: LD_ADDR_VAR 0 4
64174: PUSH
64175: LD_INT 35
64177: PUSH
64178: LD_INT 45
64180: PUSH
64181: LD_INT 46
64183: PUSH
64184: LD_INT 47
64186: PUSH
64187: LD_INT 1
64189: PUSH
64190: LD_INT 2
64192: PUSH
64193: LD_INT 6
64195: PUSH
64196: LD_INT 15
64198: PUSH
64199: LD_INT 16
64201: PUSH
64202: LD_INT 7
64204: PUSH
64205: LD_INT 12
64207: PUSH
64208: LD_INT 13
64210: PUSH
64211: LD_INT 10
64213: PUSH
64214: LD_INT 14
64216: PUSH
64217: LD_INT 20
64219: PUSH
64220: LD_INT 21
64222: PUSH
64223: LD_INT 22
64225: PUSH
64226: LD_INT 25
64228: PUSH
64229: LD_INT 32
64231: PUSH
64232: LD_INT 27
64234: PUSH
64235: LD_INT 36
64237: PUSH
64238: LD_INT 69
64240: PUSH
64241: LD_INT 39
64243: PUSH
64244: LD_INT 34
64246: PUSH
64247: LD_INT 40
64249: PUSH
64250: LD_INT 48
64252: PUSH
64253: LD_INT 49
64255: PUSH
64256: LD_INT 50
64258: PUSH
64259: LD_INT 51
64261: PUSH
64262: LD_INT 52
64264: PUSH
64265: LD_INT 53
64267: PUSH
64268: LD_INT 54
64270: PUSH
64271: LD_INT 55
64273: PUSH
64274: LD_INT 56
64276: PUSH
64277: LD_INT 57
64279: PUSH
64280: LD_INT 58
64282: PUSH
64283: LD_INT 59
64285: PUSH
64286: LD_INT 60
64288: PUSH
64289: LD_INT 61
64291: PUSH
64292: LD_INT 62
64294: PUSH
64295: LD_INT 80
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: LIST
64339: LIST
64340: ST_TO_ADDR
64341: GO 64724
64343: LD_INT 2
64345: DOUBLE
64346: EQUAL
64347: IFTRUE 64351
64349: GO 64533
64351: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64352: LD_ADDR_VAR 0 4
64356: PUSH
64357: LD_INT 35
64359: PUSH
64360: LD_INT 45
64362: PUSH
64363: LD_INT 46
64365: PUSH
64366: LD_INT 47
64368: PUSH
64369: LD_INT 70
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: LD_INT 11
64377: PUSH
64378: LD_INT 3
64380: PUSH
64381: LD_INT 4
64383: PUSH
64384: LD_INT 5
64386: PUSH
64387: LD_INT 6
64389: PUSH
64390: LD_INT 15
64392: PUSH
64393: LD_INT 18
64395: PUSH
64396: LD_INT 7
64398: PUSH
64399: LD_INT 17
64401: PUSH
64402: LD_INT 8
64404: PUSH
64405: LD_INT 20
64407: PUSH
64408: LD_INT 21
64410: PUSH
64411: LD_INT 22
64413: PUSH
64414: LD_INT 72
64416: PUSH
64417: LD_INT 26
64419: PUSH
64420: LD_INT 69
64422: PUSH
64423: LD_INT 39
64425: PUSH
64426: LD_INT 40
64428: PUSH
64429: LD_INT 41
64431: PUSH
64432: LD_INT 42
64434: PUSH
64435: LD_INT 43
64437: PUSH
64438: LD_INT 48
64440: PUSH
64441: LD_INT 49
64443: PUSH
64444: LD_INT 50
64446: PUSH
64447: LD_INT 51
64449: PUSH
64450: LD_INT 52
64452: PUSH
64453: LD_INT 53
64455: PUSH
64456: LD_INT 54
64458: PUSH
64459: LD_INT 55
64461: PUSH
64462: LD_INT 56
64464: PUSH
64465: LD_INT 60
64467: PUSH
64468: LD_INT 61
64470: PUSH
64471: LD_INT 62
64473: PUSH
64474: LD_INT 66
64476: PUSH
64477: LD_INT 67
64479: PUSH
64480: LD_INT 68
64482: PUSH
64483: LD_INT 81
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: ST_TO_ADDR
64531: GO 64724
64533: LD_INT 3
64535: DOUBLE
64536: EQUAL
64537: IFTRUE 64541
64539: GO 64723
64541: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64542: LD_ADDR_VAR 0 4
64546: PUSH
64547: LD_INT 46
64549: PUSH
64550: LD_INT 47
64552: PUSH
64553: LD_INT 1
64555: PUSH
64556: LD_INT 2
64558: PUSH
64559: LD_INT 11
64561: PUSH
64562: LD_INT 9
64564: PUSH
64565: LD_INT 20
64567: PUSH
64568: LD_INT 19
64570: PUSH
64571: LD_INT 21
64573: PUSH
64574: LD_INT 24
64576: PUSH
64577: LD_INT 22
64579: PUSH
64580: LD_INT 25
64582: PUSH
64583: LD_INT 28
64585: PUSH
64586: LD_INT 29
64588: PUSH
64589: LD_INT 30
64591: PUSH
64592: LD_INT 31
64594: PUSH
64595: LD_INT 37
64597: PUSH
64598: LD_INT 38
64600: PUSH
64601: LD_INT 32
64603: PUSH
64604: LD_INT 27
64606: PUSH
64607: LD_INT 33
64609: PUSH
64610: LD_INT 69
64612: PUSH
64613: LD_INT 39
64615: PUSH
64616: LD_INT 34
64618: PUSH
64619: LD_INT 40
64621: PUSH
64622: LD_INT 71
64624: PUSH
64625: LD_INT 23
64627: PUSH
64628: LD_INT 44
64630: PUSH
64631: LD_INT 48
64633: PUSH
64634: LD_INT 49
64636: PUSH
64637: LD_INT 50
64639: PUSH
64640: LD_INT 51
64642: PUSH
64643: LD_INT 52
64645: PUSH
64646: LD_INT 53
64648: PUSH
64649: LD_INT 54
64651: PUSH
64652: LD_INT 55
64654: PUSH
64655: LD_INT 56
64657: PUSH
64658: LD_INT 57
64660: PUSH
64661: LD_INT 58
64663: PUSH
64664: LD_INT 59
64666: PUSH
64667: LD_INT 63
64669: PUSH
64670: LD_INT 64
64672: PUSH
64673: LD_INT 65
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: ST_TO_ADDR
64721: GO 64724
64723: POP
// if state > - 1 and state < 3 then
64724: LD_VAR 0 3
64728: PUSH
64729: LD_INT 1
64731: NEG
64732: GREATER
64733: PUSH
64734: LD_VAR 0 3
64738: PUSH
64739: LD_INT 3
64741: LESS
64742: AND
64743: IFFALSE 64800
// for i in result do
64745: LD_ADDR_VAR 0 5
64749: PUSH
64750: LD_VAR 0 4
64754: PUSH
64755: FOR_IN
64756: IFFALSE 64798
// if GetTech ( i , side ) <> state then
64758: LD_VAR 0 5
64762: PPUSH
64763: LD_VAR 0 1
64767: PPUSH
64768: CALL_OW 321
64772: PUSH
64773: LD_VAR 0 3
64777: NONEQUAL
64778: IFFALSE 64796
// result := result diff i ;
64780: LD_ADDR_VAR 0 4
64784: PUSH
64785: LD_VAR 0 4
64789: PUSH
64790: LD_VAR 0 5
64794: DIFF
64795: ST_TO_ADDR
64796: GO 64755
64798: POP
64799: POP
// end ;
64800: LD_VAR 0 4
64804: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64805: LD_INT 0
64807: PPUSH
64808: PPUSH
64809: PPUSH
// result := true ;
64810: LD_ADDR_VAR 0 3
64814: PUSH
64815: LD_INT 1
64817: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64818: LD_ADDR_VAR 0 5
64822: PUSH
64823: LD_VAR 0 2
64827: PPUSH
64828: CALL_OW 480
64832: ST_TO_ADDR
// if not tmp then
64833: LD_VAR 0 5
64837: NOT
64838: IFFALSE 64842
// exit ;
64840: GO 64891
// for i in tmp do
64842: LD_ADDR_VAR 0 4
64846: PUSH
64847: LD_VAR 0 5
64851: PUSH
64852: FOR_IN
64853: IFFALSE 64889
// if GetTech ( i , side ) <> state_researched then
64855: LD_VAR 0 4
64859: PPUSH
64860: LD_VAR 0 1
64864: PPUSH
64865: CALL_OW 321
64869: PUSH
64870: LD_INT 2
64872: NONEQUAL
64873: IFFALSE 64887
// begin result := false ;
64875: LD_ADDR_VAR 0 3
64879: PUSH
64880: LD_INT 0
64882: ST_TO_ADDR
// exit ;
64883: POP
64884: POP
64885: GO 64891
// end ;
64887: GO 64852
64889: POP
64890: POP
// end ;
64891: LD_VAR 0 3
64895: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64896: LD_INT 0
64898: PPUSH
64899: PPUSH
64900: PPUSH
64901: PPUSH
64902: PPUSH
64903: PPUSH
64904: PPUSH
64905: PPUSH
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64911: LD_VAR 0 1
64915: NOT
64916: PUSH
64917: LD_VAR 0 1
64921: PPUSH
64922: CALL_OW 257
64926: PUSH
64927: LD_INT 9
64929: NONEQUAL
64930: OR
64931: IFFALSE 64935
// exit ;
64933: GO 65508
// side := GetSide ( unit ) ;
64935: LD_ADDR_VAR 0 9
64939: PUSH
64940: LD_VAR 0 1
64944: PPUSH
64945: CALL_OW 255
64949: ST_TO_ADDR
// tech_space := tech_spacanom ;
64950: LD_ADDR_VAR 0 12
64954: PUSH
64955: LD_INT 29
64957: ST_TO_ADDR
// tech_time := tech_taurad ;
64958: LD_ADDR_VAR 0 13
64962: PUSH
64963: LD_INT 28
64965: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64966: LD_ADDR_VAR 0 11
64970: PUSH
64971: LD_VAR 0 1
64975: PPUSH
64976: CALL_OW 310
64980: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64981: LD_VAR 0 11
64985: PPUSH
64986: CALL_OW 247
64990: PUSH
64991: LD_INT 2
64993: EQUAL
64994: IFFALSE 64998
// exit ;
64996: GO 65508
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64998: LD_ADDR_VAR 0 8
65002: PUSH
65003: LD_INT 81
65005: PUSH
65006: LD_VAR 0 9
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 3
65017: PUSH
65018: LD_INT 21
65020: PUSH
65021: LD_INT 3
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PPUSH
65036: CALL_OW 69
65040: ST_TO_ADDR
// if not tmp then
65041: LD_VAR 0 8
65045: NOT
65046: IFFALSE 65050
// exit ;
65048: GO 65508
// if in_unit then
65050: LD_VAR 0 11
65054: IFFALSE 65078
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65056: LD_ADDR_VAR 0 10
65060: PUSH
65061: LD_VAR 0 8
65065: PPUSH
65066: LD_VAR 0 11
65070: PPUSH
65071: CALL_OW 74
65075: ST_TO_ADDR
65076: GO 65098
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65078: LD_ADDR_VAR 0 10
65082: PUSH
65083: LD_VAR 0 8
65087: PPUSH
65088: LD_VAR 0 1
65092: PPUSH
65093: CALL_OW 74
65097: ST_TO_ADDR
// if not enemy then
65098: LD_VAR 0 10
65102: NOT
65103: IFFALSE 65107
// exit ;
65105: GO 65508
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65107: LD_VAR 0 11
65111: PUSH
65112: LD_VAR 0 11
65116: PPUSH
65117: LD_VAR 0 10
65121: PPUSH
65122: CALL_OW 296
65126: PUSH
65127: LD_INT 13
65129: GREATER
65130: AND
65131: PUSH
65132: LD_VAR 0 1
65136: PPUSH
65137: LD_VAR 0 10
65141: PPUSH
65142: CALL_OW 296
65146: PUSH
65147: LD_INT 12
65149: GREATER
65150: OR
65151: IFFALSE 65155
// exit ;
65153: GO 65508
// missile := [ 1 ] ;
65155: LD_ADDR_VAR 0 14
65159: PUSH
65160: LD_INT 1
65162: PUSH
65163: EMPTY
65164: LIST
65165: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65166: LD_VAR 0 9
65170: PPUSH
65171: LD_VAR 0 12
65175: PPUSH
65176: CALL_OW 325
65180: IFFALSE 65209
// missile := Insert ( missile , missile + 1 , 2 ) ;
65182: LD_ADDR_VAR 0 14
65186: PUSH
65187: LD_VAR 0 14
65191: PPUSH
65192: LD_VAR 0 14
65196: PUSH
65197: LD_INT 1
65199: PLUS
65200: PPUSH
65201: LD_INT 2
65203: PPUSH
65204: CALL_OW 2
65208: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65209: LD_VAR 0 9
65213: PPUSH
65214: LD_VAR 0 13
65218: PPUSH
65219: CALL_OW 325
65223: PUSH
65224: LD_VAR 0 10
65228: PPUSH
65229: CALL_OW 255
65233: PPUSH
65234: LD_VAR 0 13
65238: PPUSH
65239: CALL_OW 325
65243: NOT
65244: AND
65245: IFFALSE 65274
// missile := Insert ( missile , missile + 1 , 3 ) ;
65247: LD_ADDR_VAR 0 14
65251: PUSH
65252: LD_VAR 0 14
65256: PPUSH
65257: LD_VAR 0 14
65261: PUSH
65262: LD_INT 1
65264: PLUS
65265: PPUSH
65266: LD_INT 3
65268: PPUSH
65269: CALL_OW 2
65273: ST_TO_ADDR
// if missile < 2 then
65274: LD_VAR 0 14
65278: PUSH
65279: LD_INT 2
65281: LESS
65282: IFFALSE 65286
// exit ;
65284: GO 65508
// x := GetX ( enemy ) ;
65286: LD_ADDR_VAR 0 4
65290: PUSH
65291: LD_VAR 0 10
65295: PPUSH
65296: CALL_OW 250
65300: ST_TO_ADDR
// y := GetY ( enemy ) ;
65301: LD_ADDR_VAR 0 5
65305: PUSH
65306: LD_VAR 0 10
65310: PPUSH
65311: CALL_OW 251
65315: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65316: LD_ADDR_VAR 0 6
65320: PUSH
65321: LD_VAR 0 4
65325: PUSH
65326: LD_INT 1
65328: NEG
65329: PPUSH
65330: LD_INT 1
65332: PPUSH
65333: CALL_OW 12
65337: PLUS
65338: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65339: LD_ADDR_VAR 0 7
65343: PUSH
65344: LD_VAR 0 5
65348: PUSH
65349: LD_INT 1
65351: NEG
65352: PPUSH
65353: LD_INT 1
65355: PPUSH
65356: CALL_OW 12
65360: PLUS
65361: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65362: LD_VAR 0 6
65366: PPUSH
65367: LD_VAR 0 7
65371: PPUSH
65372: CALL_OW 488
65376: NOT
65377: IFFALSE 65399
// begin _x := x ;
65379: LD_ADDR_VAR 0 6
65383: PUSH
65384: LD_VAR 0 4
65388: ST_TO_ADDR
// _y := y ;
65389: LD_ADDR_VAR 0 7
65393: PUSH
65394: LD_VAR 0 5
65398: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65399: LD_ADDR_VAR 0 3
65403: PUSH
65404: LD_INT 1
65406: PPUSH
65407: LD_VAR 0 14
65411: PPUSH
65412: CALL_OW 12
65416: ST_TO_ADDR
// case i of 1 :
65417: LD_VAR 0 3
65421: PUSH
65422: LD_INT 1
65424: DOUBLE
65425: EQUAL
65426: IFTRUE 65430
65428: GO 65447
65430: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65431: LD_VAR 0 1
65435: PPUSH
65436: LD_VAR 0 10
65440: PPUSH
65441: CALL_OW 115
65445: GO 65508
65447: LD_INT 2
65449: DOUBLE
65450: EQUAL
65451: IFTRUE 65455
65453: GO 65477
65455: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65456: LD_VAR 0 1
65460: PPUSH
65461: LD_VAR 0 6
65465: PPUSH
65466: LD_VAR 0 7
65470: PPUSH
65471: CALL_OW 153
65475: GO 65508
65477: LD_INT 3
65479: DOUBLE
65480: EQUAL
65481: IFTRUE 65485
65483: GO 65507
65485: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65486: LD_VAR 0 1
65490: PPUSH
65491: LD_VAR 0 6
65495: PPUSH
65496: LD_VAR 0 7
65500: PPUSH
65501: CALL_OW 154
65505: GO 65508
65507: POP
// end ;
65508: LD_VAR 0 2
65512: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65513: LD_INT 0
65515: PPUSH
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
// if not unit or not building then
65521: LD_VAR 0 1
65525: NOT
65526: PUSH
65527: LD_VAR 0 2
65531: NOT
65532: OR
65533: IFFALSE 65537
// exit ;
65535: GO 65695
// x := GetX ( building ) ;
65537: LD_ADDR_VAR 0 5
65541: PUSH
65542: LD_VAR 0 2
65546: PPUSH
65547: CALL_OW 250
65551: ST_TO_ADDR
// y := GetY ( building ) ;
65552: LD_ADDR_VAR 0 6
65556: PUSH
65557: LD_VAR 0 2
65561: PPUSH
65562: CALL_OW 251
65566: ST_TO_ADDR
// for i = 0 to 5 do
65567: LD_ADDR_VAR 0 4
65571: PUSH
65572: DOUBLE
65573: LD_INT 0
65575: DEC
65576: ST_TO_ADDR
65577: LD_INT 5
65579: PUSH
65580: FOR_TO
65581: IFFALSE 65693
// begin _x := ShiftX ( x , i , 3 ) ;
65583: LD_ADDR_VAR 0 7
65587: PUSH
65588: LD_VAR 0 5
65592: PPUSH
65593: LD_VAR 0 4
65597: PPUSH
65598: LD_INT 3
65600: PPUSH
65601: CALL_OW 272
65605: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65606: LD_ADDR_VAR 0 8
65610: PUSH
65611: LD_VAR 0 6
65615: PPUSH
65616: LD_VAR 0 4
65620: PPUSH
65621: LD_INT 3
65623: PPUSH
65624: CALL_OW 273
65628: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65629: LD_VAR 0 7
65633: PPUSH
65634: LD_VAR 0 8
65638: PPUSH
65639: CALL_OW 488
65643: NOT
65644: IFFALSE 65648
// continue ;
65646: GO 65580
// if HexInfo ( _x , _y ) = 0 then
65648: LD_VAR 0 7
65652: PPUSH
65653: LD_VAR 0 8
65657: PPUSH
65658: CALL_OW 428
65662: PUSH
65663: LD_INT 0
65665: EQUAL
65666: IFFALSE 65691
// begin ComMoveXY ( unit , _x , _y ) ;
65668: LD_VAR 0 1
65672: PPUSH
65673: LD_VAR 0 7
65677: PPUSH
65678: LD_VAR 0 8
65682: PPUSH
65683: CALL_OW 111
// exit ;
65687: POP
65688: POP
65689: GO 65695
// end ; end ;
65691: GO 65580
65693: POP
65694: POP
// end ;
65695: LD_VAR 0 3
65699: RET
// export function ScanBase ( side , base_area ) ; begin
65700: LD_INT 0
65702: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65703: LD_ADDR_VAR 0 3
65707: PUSH
65708: LD_VAR 0 2
65712: PPUSH
65713: LD_INT 81
65715: PUSH
65716: LD_VAR 0 1
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PPUSH
65725: CALL_OW 70
65729: ST_TO_ADDR
// end ;
65730: LD_VAR 0 3
65734: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65735: LD_INT 0
65737: PPUSH
65738: PPUSH
65739: PPUSH
65740: PPUSH
65741: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65742: LD_VAR 0 1
65746: NOT
65747: PUSH
65748: LD_EXP 99
65752: PUSH
65753: LD_VAR 0 1
65757: ARRAY
65758: NOT
65759: OR
65760: PUSH
65761: LD_VAR 0 2
65765: NOT
65766: OR
65767: PUSH
65768: LD_VAR 0 3
65772: NOT
65773: OR
65774: IFFALSE 65778
// exit ;
65776: GO 66291
// side := mc_sides [ base ] ;
65778: LD_ADDR_VAR 0 6
65782: PUSH
65783: LD_EXP 125
65787: PUSH
65788: LD_VAR 0 1
65792: ARRAY
65793: ST_TO_ADDR
// if not side then
65794: LD_VAR 0 6
65798: NOT
65799: IFFALSE 65803
// exit ;
65801: GO 66291
// for i in solds do
65803: LD_ADDR_VAR 0 7
65807: PUSH
65808: LD_VAR 0 2
65812: PUSH
65813: FOR_IN
65814: IFFALSE 65875
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65816: LD_VAR 0 7
65820: PPUSH
65821: CALL_OW 310
65825: PPUSH
65826: CALL_OW 266
65830: PUSH
65831: LD_INT 32
65833: PUSH
65834: LD_INT 31
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: IN
65841: IFFALSE 65861
// solds := solds diff i else
65843: LD_ADDR_VAR 0 2
65847: PUSH
65848: LD_VAR 0 2
65852: PUSH
65853: LD_VAR 0 7
65857: DIFF
65858: ST_TO_ADDR
65859: GO 65873
// SetTag ( i , 18 ) ;
65861: LD_VAR 0 7
65865: PPUSH
65866: LD_INT 18
65868: PPUSH
65869: CALL_OW 109
65873: GO 65813
65875: POP
65876: POP
// if not solds then
65877: LD_VAR 0 2
65881: NOT
65882: IFFALSE 65886
// exit ;
65884: GO 66291
// repeat wait ( 0 0$1 ) ;
65886: LD_INT 35
65888: PPUSH
65889: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65893: LD_ADDR_VAR 0 5
65897: PUSH
65898: LD_VAR 0 6
65902: PPUSH
65903: LD_VAR 0 3
65907: PPUSH
65908: CALL 65700 0 2
65912: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
65913: LD_EXP 99
65917: PUSH
65918: LD_VAR 0 1
65922: ARRAY
65923: NOT
65924: PUSH
65925: LD_EXP 99
65929: PUSH
65930: LD_VAR 0 1
65934: ARRAY
65935: PUSH
65936: EMPTY
65937: EQUAL
65938: OR
65939: IFFALSE 65976
// begin for i in solds do
65941: LD_ADDR_VAR 0 7
65945: PUSH
65946: LD_VAR 0 2
65950: PUSH
65951: FOR_IN
65952: IFFALSE 65965
// ComStop ( i ) ;
65954: LD_VAR 0 7
65958: PPUSH
65959: CALL_OW 141
65963: GO 65951
65965: POP
65966: POP
// solds := [ ] ;
65967: LD_ADDR_VAR 0 2
65971: PUSH
65972: EMPTY
65973: ST_TO_ADDR
// exit ;
65974: GO 66291
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
65976: LD_VAR 0 5
65980: NOT
65981: PUSH
65982: LD_VAR 0 5
65986: PUSH
65987: LD_INT 3
65989: GREATER
65990: OR
65991: PUSH
65992: LD_EXP 121
65996: PUSH
65997: LD_VAR 0 1
66001: ARRAY
66002: OR
66003: IFFALSE 66044
// begin for i in solds do
66005: LD_ADDR_VAR 0 7
66009: PUSH
66010: LD_VAR 0 2
66014: PUSH
66015: FOR_IN
66016: IFFALSE 66040
// if HasTask ( i ) then
66018: LD_VAR 0 7
66022: PPUSH
66023: CALL_OW 314
66027: IFFALSE 66038
// ComStop ( i ) ;
66029: LD_VAR 0 7
66033: PPUSH
66034: CALL_OW 141
66038: GO 66015
66040: POP
66041: POP
// break ;
66042: GO 66279
// end ; for i in solds do
66044: LD_ADDR_VAR 0 7
66048: PUSH
66049: LD_VAR 0 2
66053: PUSH
66054: FOR_IN
66055: IFFALSE 66271
// begin if IsInUnit ( i ) then
66057: LD_VAR 0 7
66061: PPUSH
66062: CALL_OW 310
66066: IFFALSE 66077
// ComExitBuilding ( i ) ;
66068: LD_VAR 0 7
66072: PPUSH
66073: CALL_OW 122
// if GetLives ( i ) > 333 then
66077: LD_VAR 0 7
66081: PPUSH
66082: CALL_OW 256
66086: PUSH
66087: LD_INT 333
66089: GREATER
66090: IFFALSE 66118
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66092: LD_VAR 0 7
66096: PPUSH
66097: LD_VAR 0 5
66101: PPUSH
66102: LD_VAR 0 7
66106: PPUSH
66107: CALL_OW 74
66111: PPUSH
66112: CALL_OW 115
66116: GO 66269
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66118: LD_ADDR_VAR 0 8
66122: PUSH
66123: LD_EXP 99
66127: PUSH
66128: LD_VAR 0 1
66132: ARRAY
66133: PPUSH
66134: LD_INT 2
66136: PUSH
66137: LD_INT 30
66139: PUSH
66140: LD_INT 0
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 30
66149: PUSH
66150: LD_INT 1
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 30
66159: PUSH
66160: LD_INT 6
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: PPUSH
66173: CALL_OW 72
66177: PPUSH
66178: LD_VAR 0 7
66182: PPUSH
66183: CALL_OW 74
66187: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66188: LD_VAR 0 7
66192: PPUSH
66193: LD_VAR 0 8
66197: PPUSH
66198: CALL_OW 250
66202: PPUSH
66203: LD_INT 3
66205: PPUSH
66206: LD_INT 5
66208: PPUSH
66209: CALL_OW 272
66213: PPUSH
66214: LD_VAR 0 8
66218: PPUSH
66219: CALL_OW 251
66223: PPUSH
66224: LD_INT 3
66226: PPUSH
66227: LD_INT 5
66229: PPUSH
66230: CALL_OW 273
66234: PPUSH
66235: CALL_OW 111
// SetTag ( i , 0 ) ;
66239: LD_VAR 0 7
66243: PPUSH
66244: LD_INT 0
66246: PPUSH
66247: CALL_OW 109
// solds := solds diff i ;
66251: LD_ADDR_VAR 0 2
66255: PUSH
66256: LD_VAR 0 2
66260: PUSH
66261: LD_VAR 0 7
66265: DIFF
66266: ST_TO_ADDR
// continue ;
66267: GO 66054
// end ; end ;
66269: GO 66054
66271: POP
66272: POP
// until solds ;
66273: LD_VAR 0 2
66277: IFFALSE 65886
// MC_Reset ( base , 18 ) ;
66279: LD_VAR 0 1
66283: PPUSH
66284: LD_INT 18
66286: PPUSH
66287: CALL 38008 0 2
// end ;
66291: LD_VAR 0 4
66295: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66296: LD_INT 0
66298: PPUSH
66299: PPUSH
66300: PPUSH
66301: PPUSH
66302: PPUSH
66303: PPUSH
66304: PPUSH
66305: PPUSH
66306: PPUSH
66307: PPUSH
66308: PPUSH
66309: PPUSH
66310: PPUSH
66311: PPUSH
66312: PPUSH
66313: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66314: LD_ADDR_VAR 0 12
66318: PUSH
66319: LD_EXP 99
66323: PUSH
66324: LD_VAR 0 1
66328: ARRAY
66329: PPUSH
66330: LD_INT 25
66332: PUSH
66333: LD_INT 3
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PPUSH
66340: CALL_OW 72
66344: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66345: LD_EXP 139
66349: PUSH
66350: LD_VAR 0 1
66354: ARRAY
66355: IFFALSE 66379
// mechs := mechs diff mc_remote_driver [ base ] ;
66357: LD_ADDR_VAR 0 12
66361: PUSH
66362: LD_VAR 0 12
66366: PUSH
66367: LD_EXP 139
66371: PUSH
66372: LD_VAR 0 1
66376: ARRAY
66377: DIFF
66378: ST_TO_ADDR
// for i in mechs do
66379: LD_ADDR_VAR 0 5
66383: PUSH
66384: LD_VAR 0 12
66388: PUSH
66389: FOR_IN
66390: IFFALSE 66425
// if GetTag ( i ) > 0 then
66392: LD_VAR 0 5
66396: PPUSH
66397: CALL_OW 110
66401: PUSH
66402: LD_INT 0
66404: GREATER
66405: IFFALSE 66423
// mechs := mechs diff i ;
66407: LD_ADDR_VAR 0 12
66411: PUSH
66412: LD_VAR 0 12
66416: PUSH
66417: LD_VAR 0 5
66421: DIFF
66422: ST_TO_ADDR
66423: GO 66389
66425: POP
66426: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66427: LD_ADDR_VAR 0 8
66431: PUSH
66432: LD_EXP 99
66436: PUSH
66437: LD_VAR 0 1
66441: ARRAY
66442: PPUSH
66443: LD_INT 2
66445: PUSH
66446: LD_INT 25
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 25
66458: PUSH
66459: LD_INT 5
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 25
66468: PUSH
66469: LD_INT 8
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 25
66478: PUSH
66479: LD_INT 9
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: PPUSH
66493: CALL_OW 72
66497: ST_TO_ADDR
// if not defenders and not solds then
66498: LD_VAR 0 2
66502: NOT
66503: PUSH
66504: LD_VAR 0 8
66508: NOT
66509: AND
66510: IFFALSE 66514
// exit ;
66512: GO 68052
// depot_under_attack := false ;
66514: LD_ADDR_VAR 0 16
66518: PUSH
66519: LD_INT 0
66521: ST_TO_ADDR
// sold_defenders := [ ] ;
66522: LD_ADDR_VAR 0 17
66526: PUSH
66527: EMPTY
66528: ST_TO_ADDR
// if mechs then
66529: LD_VAR 0 12
66533: IFFALSE 66662
// for i in defenders do
66535: LD_ADDR_VAR 0 5
66539: PUSH
66540: LD_VAR 0 2
66544: PUSH
66545: FOR_IN
66546: IFFALSE 66660
// begin SetTag ( i , 20 ) ;
66548: LD_VAR 0 5
66552: PPUSH
66553: LD_INT 20
66555: PPUSH
66556: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66560: LD_VAR 0 5
66564: PPUSH
66565: CALL_OW 263
66569: PUSH
66570: LD_INT 1
66572: EQUAL
66573: PUSH
66574: LD_VAR 0 5
66578: PPUSH
66579: CALL_OW 311
66583: NOT
66584: AND
66585: PUSH
66586: LD_VAR 0 12
66590: AND
66591: IFFALSE 66658
// begin un := mechs [ 1 ] ;
66593: LD_ADDR_VAR 0 10
66597: PUSH
66598: LD_VAR 0 12
66602: PUSH
66603: LD_INT 1
66605: ARRAY
66606: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66607: LD_VAR 0 10
66611: PPUSH
66612: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66616: LD_VAR 0 10
66620: PPUSH
66621: LD_VAR 0 5
66625: PPUSH
66626: CALL_OW 180
// SetTag ( un , 19 ) ;
66630: LD_VAR 0 10
66634: PPUSH
66635: LD_INT 19
66637: PPUSH
66638: CALL_OW 109
// mechs := mechs diff un ;
66642: LD_ADDR_VAR 0 12
66646: PUSH
66647: LD_VAR 0 12
66651: PUSH
66652: LD_VAR 0 10
66656: DIFF
66657: ST_TO_ADDR
// end ; end ;
66658: GO 66545
66660: POP
66661: POP
// if solds then
66662: LD_VAR 0 8
66666: IFFALSE 66725
// for i in solds do
66668: LD_ADDR_VAR 0 5
66672: PUSH
66673: LD_VAR 0 8
66677: PUSH
66678: FOR_IN
66679: IFFALSE 66723
// if not GetTag ( i ) then
66681: LD_VAR 0 5
66685: PPUSH
66686: CALL_OW 110
66690: NOT
66691: IFFALSE 66721
// begin defenders := defenders union i ;
66693: LD_ADDR_VAR 0 2
66697: PUSH
66698: LD_VAR 0 2
66702: PUSH
66703: LD_VAR 0 5
66707: UNION
66708: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66709: LD_VAR 0 5
66713: PPUSH
66714: LD_INT 18
66716: PPUSH
66717: CALL_OW 109
// end ;
66721: GO 66678
66723: POP
66724: POP
// repeat wait ( 0 0$1 ) ;
66725: LD_INT 35
66727: PPUSH
66728: CALL_OW 67
// enemy := mc_scan [ base ] ;
66732: LD_ADDR_VAR 0 3
66736: PUSH
66737: LD_EXP 122
66741: PUSH
66742: LD_VAR 0 1
66746: ARRAY
66747: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66748: LD_EXP 99
66752: PUSH
66753: LD_VAR 0 1
66757: ARRAY
66758: NOT
66759: PUSH
66760: LD_EXP 99
66764: PUSH
66765: LD_VAR 0 1
66769: ARRAY
66770: PUSH
66771: EMPTY
66772: EQUAL
66773: OR
66774: IFFALSE 66811
// begin for i in defenders do
66776: LD_ADDR_VAR 0 5
66780: PUSH
66781: LD_VAR 0 2
66785: PUSH
66786: FOR_IN
66787: IFFALSE 66800
// ComStop ( i ) ;
66789: LD_VAR 0 5
66793: PPUSH
66794: CALL_OW 141
66798: GO 66786
66800: POP
66801: POP
// defenders := [ ] ;
66802: LD_ADDR_VAR 0 2
66806: PUSH
66807: EMPTY
66808: ST_TO_ADDR
// exit ;
66809: GO 68052
// end ; for i in defenders do
66811: LD_ADDR_VAR 0 5
66815: PUSH
66816: LD_VAR 0 2
66820: PUSH
66821: FOR_IN
66822: IFFALSE 67552
// begin e := NearestUnitToUnit ( enemy , i ) ;
66824: LD_ADDR_VAR 0 13
66828: PUSH
66829: LD_VAR 0 3
66833: PPUSH
66834: LD_VAR 0 5
66838: PPUSH
66839: CALL_OW 74
66843: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66844: LD_ADDR_VAR 0 16
66848: PUSH
66849: LD_EXP 99
66853: PUSH
66854: LD_VAR 0 1
66858: ARRAY
66859: PPUSH
66860: LD_INT 2
66862: PUSH
66863: LD_INT 30
66865: PUSH
66866: LD_INT 0
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 30
66875: PUSH
66876: LD_INT 1
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: PPUSH
66888: CALL_OW 72
66892: NOT
66893: PUSH
66894: LD_EXP 99
66898: PUSH
66899: LD_VAR 0 1
66903: ARRAY
66904: PPUSH
66905: LD_INT 2
66907: PUSH
66908: LD_INT 30
66910: PUSH
66911: LD_INT 0
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: PUSH
66918: LD_INT 30
66920: PUSH
66921: LD_INT 1
66923: PUSH
66924: EMPTY
66925: LIST
66926: LIST
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: LIST
66932: PPUSH
66933: CALL_OW 72
66937: PPUSH
66938: CALL_OW 256
66942: PUSH
66943: LD_INT 600
66945: LESS
66946: OR
66947: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66948: LD_VAR 0 5
66952: PPUSH
66953: CALL_OW 247
66957: PUSH
66958: LD_INT 2
66960: DOUBLE
66961: EQUAL
66962: IFTRUE 66966
66964: GO 67258
66966: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66967: LD_VAR 0 5
66971: PPUSH
66972: CALL_OW 256
66976: PUSH
66977: LD_INT 650
66979: GREATER
66980: PUSH
66981: LD_VAR 0 5
66985: PPUSH
66986: LD_VAR 0 13
66990: PPUSH
66991: CALL_OW 296
66995: PUSH
66996: LD_INT 40
66998: LESS
66999: PUSH
67000: LD_VAR 0 13
67004: PPUSH
67005: LD_EXP 124
67009: PUSH
67010: LD_VAR 0 1
67014: ARRAY
67015: PPUSH
67016: CALL_OW 308
67020: OR
67021: AND
67022: IFFALSE 67040
// ComAttackUnit ( i , e ) else
67024: LD_VAR 0 5
67028: PPUSH
67029: LD_VAR 0 13
67033: PPUSH
67034: CALL_OW 115
67038: GO 67141
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67040: LD_VAR 0 13
67044: PPUSH
67045: LD_EXP 124
67049: PUSH
67050: LD_VAR 0 1
67054: ARRAY
67055: PPUSH
67056: CALL_OW 308
67060: NOT
67061: PUSH
67062: LD_VAR 0 5
67066: PPUSH
67067: LD_VAR 0 13
67071: PPUSH
67072: CALL_OW 296
67076: PUSH
67077: LD_INT 40
67079: GREATEREQUAL
67080: AND
67081: PUSH
67082: LD_VAR 0 5
67086: PPUSH
67087: CALL_OW 256
67091: PUSH
67092: LD_INT 650
67094: LESSEQUAL
67095: OR
67096: PUSH
67097: LD_VAR 0 5
67101: PPUSH
67102: LD_EXP 123
67106: PUSH
67107: LD_VAR 0 1
67111: ARRAY
67112: PPUSH
67113: CALL_OW 308
67117: NOT
67118: AND
67119: IFFALSE 67141
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67121: LD_VAR 0 5
67125: PPUSH
67126: LD_EXP 123
67130: PUSH
67131: LD_VAR 0 1
67135: ARRAY
67136: PPUSH
67137: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67141: LD_VAR 0 5
67145: PPUSH
67146: CALL_OW 256
67150: PUSH
67151: LD_INT 998
67153: LESS
67154: PUSH
67155: LD_VAR 0 5
67159: PPUSH
67160: CALL_OW 263
67164: PUSH
67165: LD_INT 1
67167: EQUAL
67168: AND
67169: PUSH
67170: LD_VAR 0 5
67174: PPUSH
67175: CALL_OW 311
67179: AND
67180: PUSH
67181: LD_VAR 0 5
67185: PPUSH
67186: LD_EXP 123
67190: PUSH
67191: LD_VAR 0 1
67195: ARRAY
67196: PPUSH
67197: CALL_OW 308
67201: AND
67202: IFFALSE 67256
// begin mech := IsDrivenBy ( i ) ;
67204: LD_ADDR_VAR 0 9
67208: PUSH
67209: LD_VAR 0 5
67213: PPUSH
67214: CALL_OW 311
67218: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67219: LD_VAR 0 9
67223: PPUSH
67224: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67228: LD_VAR 0 9
67232: PPUSH
67233: LD_VAR 0 5
67237: PPUSH
67238: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67242: LD_VAR 0 9
67246: PPUSH
67247: LD_VAR 0 5
67251: PPUSH
67252: CALL_OW 180
// end ; end ; unit_human :
67256: GO 67523
67258: LD_INT 1
67260: DOUBLE
67261: EQUAL
67262: IFTRUE 67266
67264: GO 67522
67266: POP
// begin b := IsInUnit ( i ) ;
67267: LD_ADDR_VAR 0 18
67271: PUSH
67272: LD_VAR 0 5
67276: PPUSH
67277: CALL_OW 310
67281: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67282: LD_ADDR_VAR 0 19
67286: PUSH
67287: LD_VAR 0 18
67291: NOT
67292: PUSH
67293: LD_VAR 0 18
67297: PPUSH
67298: CALL_OW 266
67302: PUSH
67303: LD_INT 32
67305: PUSH
67306: LD_INT 31
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: IN
67313: OR
67314: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67315: LD_VAR 0 16
67319: PUSH
67320: LD_VAR 0 2
67324: PPUSH
67325: LD_INT 21
67327: PUSH
67328: LD_INT 2
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PPUSH
67335: CALL_OW 72
67339: PUSH
67340: LD_INT 1
67342: LESSEQUAL
67343: OR
67344: PUSH
67345: LD_VAR 0 19
67349: AND
67350: PUSH
67351: LD_VAR 0 5
67355: PUSH
67356: LD_VAR 0 17
67360: IN
67361: NOT
67362: AND
67363: IFFALSE 67456
// begin if b then
67365: LD_VAR 0 18
67369: IFFALSE 67418
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67371: LD_VAR 0 18
67375: PPUSH
67376: LD_VAR 0 3
67380: PPUSH
67381: LD_VAR 0 18
67385: PPUSH
67386: CALL_OW 74
67390: PPUSH
67391: CALL_OW 296
67395: PUSH
67396: LD_INT 10
67398: LESS
67399: PUSH
67400: LD_VAR 0 18
67404: PPUSH
67405: CALL_OW 461
67409: PUSH
67410: LD_INT 7
67412: NONEQUAL
67413: AND
67414: IFFALSE 67418
// continue ;
67416: GO 66821
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67418: LD_ADDR_VAR 0 17
67422: PUSH
67423: LD_VAR 0 17
67427: PPUSH
67428: LD_VAR 0 17
67432: PUSH
67433: LD_INT 1
67435: PLUS
67436: PPUSH
67437: LD_VAR 0 5
67441: PPUSH
67442: CALL_OW 1
67446: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67447: LD_VAR 0 5
67451: PPUSH
67452: CALL_OW 122
// end ; if sold_defenders then
67456: LD_VAR 0 17
67460: IFFALSE 67520
// if i in sold_defenders then
67462: LD_VAR 0 5
67466: PUSH
67467: LD_VAR 0 17
67471: IN
67472: IFFALSE 67520
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67474: LD_VAR 0 5
67478: PPUSH
67479: CALL_OW 314
67483: NOT
67484: PUSH
67485: LD_VAR 0 5
67489: PPUSH
67490: LD_VAR 0 13
67494: PPUSH
67495: CALL_OW 296
67499: PUSH
67500: LD_INT 30
67502: LESS
67503: AND
67504: IFFALSE 67520
// ComAttackUnit ( i , e ) ;
67506: LD_VAR 0 5
67510: PPUSH
67511: LD_VAR 0 13
67515: PPUSH
67516: CALL_OW 115
// end ; end ; end ;
67520: GO 67523
67522: POP
// if IsDead ( i ) then
67523: LD_VAR 0 5
67527: PPUSH
67528: CALL_OW 301
67532: IFFALSE 67550
// defenders := defenders diff i ;
67534: LD_ADDR_VAR 0 2
67538: PUSH
67539: LD_VAR 0 2
67543: PUSH
67544: LD_VAR 0 5
67548: DIFF
67549: ST_TO_ADDR
// end ;
67550: GO 66821
67552: POP
67553: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67554: LD_VAR 0 3
67558: NOT
67559: PUSH
67560: LD_VAR 0 2
67564: NOT
67565: OR
67566: PUSH
67567: LD_EXP 99
67571: PUSH
67572: LD_VAR 0 1
67576: ARRAY
67577: NOT
67578: OR
67579: IFFALSE 66725
// MC_Reset ( base , 18 ) ;
67581: LD_VAR 0 1
67585: PPUSH
67586: LD_INT 18
67588: PPUSH
67589: CALL 38008 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67593: LD_ADDR_VAR 0 2
67597: PUSH
67598: LD_VAR 0 2
67602: PUSH
67603: LD_VAR 0 2
67607: PPUSH
67608: LD_INT 2
67610: PUSH
67611: LD_INT 25
67613: PUSH
67614: LD_INT 1
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 25
67623: PUSH
67624: LD_INT 5
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 25
67633: PUSH
67634: LD_INT 8
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 25
67643: PUSH
67644: LD_INT 9
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: PPUSH
67658: CALL_OW 72
67662: DIFF
67663: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67664: LD_VAR 0 3
67668: NOT
67669: PUSH
67670: LD_VAR 0 2
67674: PPUSH
67675: LD_INT 21
67677: PUSH
67678: LD_INT 2
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PPUSH
67685: CALL_OW 72
67689: AND
67690: IFFALSE 68028
// begin tmp := FilterByTag ( defenders , 19 ) ;
67692: LD_ADDR_VAR 0 11
67696: PUSH
67697: LD_VAR 0 2
67701: PPUSH
67702: LD_INT 19
67704: PPUSH
67705: CALL 104481 0 2
67709: ST_TO_ADDR
// if tmp then
67710: LD_VAR 0 11
67714: IFFALSE 67784
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67716: LD_ADDR_VAR 0 11
67720: PUSH
67721: LD_VAR 0 11
67725: PPUSH
67726: LD_INT 25
67728: PUSH
67729: LD_INT 3
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PPUSH
67736: CALL_OW 72
67740: ST_TO_ADDR
// if tmp then
67741: LD_VAR 0 11
67745: IFFALSE 67784
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67747: LD_ADDR_EXP 111
67751: PUSH
67752: LD_EXP 111
67756: PPUSH
67757: LD_VAR 0 1
67761: PPUSH
67762: LD_EXP 111
67766: PUSH
67767: LD_VAR 0 1
67771: ARRAY
67772: PUSH
67773: LD_VAR 0 11
67777: UNION
67778: PPUSH
67779: CALL_OW 1
67783: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67784: LD_VAR 0 1
67788: PPUSH
67789: LD_INT 19
67791: PPUSH
67792: CALL 38008 0 2
// repeat wait ( 0 0$1 ) ;
67796: LD_INT 35
67798: PPUSH
67799: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67803: LD_EXP 99
67807: PUSH
67808: LD_VAR 0 1
67812: ARRAY
67813: NOT
67814: PUSH
67815: LD_EXP 99
67819: PUSH
67820: LD_VAR 0 1
67824: ARRAY
67825: PUSH
67826: EMPTY
67827: EQUAL
67828: OR
67829: IFFALSE 67866
// begin for i in defenders do
67831: LD_ADDR_VAR 0 5
67835: PUSH
67836: LD_VAR 0 2
67840: PUSH
67841: FOR_IN
67842: IFFALSE 67855
// ComStop ( i ) ;
67844: LD_VAR 0 5
67848: PPUSH
67849: CALL_OW 141
67853: GO 67841
67855: POP
67856: POP
// defenders := [ ] ;
67857: LD_ADDR_VAR 0 2
67861: PUSH
67862: EMPTY
67863: ST_TO_ADDR
// exit ;
67864: GO 68052
// end ; for i in defenders do
67866: LD_ADDR_VAR 0 5
67870: PUSH
67871: LD_VAR 0 2
67875: PUSH
67876: FOR_IN
67877: IFFALSE 67966
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67879: LD_VAR 0 5
67883: PPUSH
67884: LD_EXP 123
67888: PUSH
67889: LD_VAR 0 1
67893: ARRAY
67894: PPUSH
67895: CALL_OW 308
67899: NOT
67900: IFFALSE 67924
// ComMoveToArea ( i , mc_parking [ base ] ) else
67902: LD_VAR 0 5
67906: PPUSH
67907: LD_EXP 123
67911: PUSH
67912: LD_VAR 0 1
67916: ARRAY
67917: PPUSH
67918: CALL_OW 113
67922: GO 67964
// if GetControl ( i ) = control_manual then
67924: LD_VAR 0 5
67928: PPUSH
67929: CALL_OW 263
67933: PUSH
67934: LD_INT 1
67936: EQUAL
67937: IFFALSE 67964
// if IsDrivenBy ( i ) then
67939: LD_VAR 0 5
67943: PPUSH
67944: CALL_OW 311
67948: IFFALSE 67964
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67950: LD_VAR 0 5
67954: PPUSH
67955: CALL_OW 311
67959: PPUSH
67960: CALL_OW 121
// end ;
67964: GO 67876
67966: POP
67967: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
67968: LD_VAR 0 2
67972: PPUSH
67973: LD_INT 95
67975: PUSH
67976: LD_EXP 123
67980: PUSH
67981: LD_VAR 0 1
67985: ARRAY
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PPUSH
67991: CALL_OW 72
67995: PUSH
67996: LD_VAR 0 2
68000: EQUAL
68001: PUSH
68002: LD_EXP 122
68006: PUSH
68007: LD_VAR 0 1
68011: ARRAY
68012: OR
68013: PUSH
68014: LD_EXP 99
68018: PUSH
68019: LD_VAR 0 1
68023: ARRAY
68024: NOT
68025: OR
68026: IFFALSE 67796
// end ; MC_Reset ( base , 19 ) ;
68028: LD_VAR 0 1
68032: PPUSH
68033: LD_INT 19
68035: PPUSH
68036: CALL 38008 0 2
// MC_Reset ( base , 20 ) ;
68040: LD_VAR 0 1
68044: PPUSH
68045: LD_INT 20
68047: PPUSH
68048: CALL 38008 0 2
// end ;
68052: LD_VAR 0 4
68056: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68057: LD_INT 0
68059: PPUSH
68060: PPUSH
68061: PPUSH
68062: PPUSH
// result := false ;
68063: LD_ADDR_VAR 0 2
68067: PUSH
68068: LD_INT 0
68070: ST_TO_ADDR
// side := GetSide ( unit ) ;
68071: LD_ADDR_VAR 0 3
68075: PUSH
68076: LD_VAR 0 1
68080: PPUSH
68081: CALL_OW 255
68085: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68086: LD_ADDR_VAR 0 4
68090: PUSH
68091: LD_VAR 0 1
68095: PPUSH
68096: CALL_OW 248
68100: ST_TO_ADDR
// case nat of 1 :
68101: LD_VAR 0 4
68105: PUSH
68106: LD_INT 1
68108: DOUBLE
68109: EQUAL
68110: IFTRUE 68114
68112: GO 68125
68114: POP
// tech := tech_lassight ; 2 :
68115: LD_ADDR_VAR 0 5
68119: PUSH
68120: LD_INT 12
68122: ST_TO_ADDR
68123: GO 68164
68125: LD_INT 2
68127: DOUBLE
68128: EQUAL
68129: IFTRUE 68133
68131: GO 68144
68133: POP
// tech := tech_mortar ; 3 :
68134: LD_ADDR_VAR 0 5
68138: PUSH
68139: LD_INT 41
68141: ST_TO_ADDR
68142: GO 68164
68144: LD_INT 3
68146: DOUBLE
68147: EQUAL
68148: IFTRUE 68152
68150: GO 68163
68152: POP
// tech := tech_bazooka ; end ;
68153: LD_ADDR_VAR 0 5
68157: PUSH
68158: LD_INT 44
68160: ST_TO_ADDR
68161: GO 68164
68163: POP
// if Researched ( side , tech ) then
68164: LD_VAR 0 3
68168: PPUSH
68169: LD_VAR 0 5
68173: PPUSH
68174: CALL_OW 325
68178: IFFALSE 68205
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68180: LD_ADDR_VAR 0 2
68184: PUSH
68185: LD_INT 5
68187: PUSH
68188: LD_INT 8
68190: PUSH
68191: LD_INT 9
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: LIST
68198: PUSH
68199: LD_VAR 0 4
68203: ARRAY
68204: ST_TO_ADDR
// end ;
68205: LD_VAR 0 2
68209: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68210: LD_INT 0
68212: PPUSH
68213: PPUSH
68214: PPUSH
// if not mines then
68215: LD_VAR 0 2
68219: NOT
68220: IFFALSE 68224
// exit ;
68222: GO 68368
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68224: LD_ADDR_VAR 0 5
68228: PUSH
68229: LD_INT 81
68231: PUSH
68232: LD_VAR 0 1
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 3
68243: PUSH
68244: LD_INT 21
68246: PUSH
68247: LD_INT 3
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PPUSH
68262: CALL_OW 69
68266: ST_TO_ADDR
// for i in mines do
68267: LD_ADDR_VAR 0 4
68271: PUSH
68272: LD_VAR 0 2
68276: PUSH
68277: FOR_IN
68278: IFFALSE 68366
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68280: LD_VAR 0 4
68284: PUSH
68285: LD_INT 1
68287: ARRAY
68288: PPUSH
68289: LD_VAR 0 4
68293: PUSH
68294: LD_INT 2
68296: ARRAY
68297: PPUSH
68298: CALL_OW 458
68302: NOT
68303: IFFALSE 68307
// continue ;
68305: GO 68277
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68307: LD_VAR 0 4
68311: PUSH
68312: LD_INT 1
68314: ARRAY
68315: PPUSH
68316: LD_VAR 0 4
68320: PUSH
68321: LD_INT 2
68323: ARRAY
68324: PPUSH
68325: CALL_OW 428
68329: PUSH
68330: LD_VAR 0 5
68334: IN
68335: IFFALSE 68364
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68337: LD_VAR 0 4
68341: PUSH
68342: LD_INT 1
68344: ARRAY
68345: PPUSH
68346: LD_VAR 0 4
68350: PUSH
68351: LD_INT 2
68353: ARRAY
68354: PPUSH
68355: LD_VAR 0 1
68359: PPUSH
68360: CALL_OW 456
// end ;
68364: GO 68277
68366: POP
68367: POP
// end ;
68368: LD_VAR 0 3
68372: RET
// export function Count ( array ) ; var i ; begin
68373: LD_INT 0
68375: PPUSH
68376: PPUSH
// result := 0 ;
68377: LD_ADDR_VAR 0 2
68381: PUSH
68382: LD_INT 0
68384: ST_TO_ADDR
// for i in array do
68385: LD_ADDR_VAR 0 3
68389: PUSH
68390: LD_VAR 0 1
68394: PUSH
68395: FOR_IN
68396: IFFALSE 68420
// if i then
68398: LD_VAR 0 3
68402: IFFALSE 68418
// result := result + 1 ;
68404: LD_ADDR_VAR 0 2
68408: PUSH
68409: LD_VAR 0 2
68413: PUSH
68414: LD_INT 1
68416: PLUS
68417: ST_TO_ADDR
68418: GO 68395
68420: POP
68421: POP
// end ;
68422: LD_VAR 0 2
68426: RET
// export function IsEmpty ( building ) ; begin
68427: LD_INT 0
68429: PPUSH
// if not building then
68430: LD_VAR 0 1
68434: NOT
68435: IFFALSE 68439
// exit ;
68437: GO 68482
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68439: LD_ADDR_VAR 0 2
68443: PUSH
68444: LD_VAR 0 1
68448: PUSH
68449: LD_INT 22
68451: PUSH
68452: LD_VAR 0 1
68456: PPUSH
68457: CALL_OW 255
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 58
68468: PUSH
68469: EMPTY
68470: LIST
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PPUSH
68476: CALL_OW 69
68480: IN
68481: ST_TO_ADDR
// end ;
68482: LD_VAR 0 2
68486: RET
// export function IsNotFull ( building ) ; begin
68487: LD_INT 0
68489: PPUSH
// if not building then
68490: LD_VAR 0 1
68494: NOT
68495: IFFALSE 68499
// exit ;
68497: GO 68518
// result := UnitsInside ( building ) < 6 ;
68499: LD_ADDR_VAR 0 2
68503: PUSH
68504: LD_VAR 0 1
68508: PPUSH
68509: CALL_OW 313
68513: PUSH
68514: LD_INT 6
68516: LESS
68517: ST_TO_ADDR
// end ;
68518: LD_VAR 0 2
68522: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68523: LD_INT 0
68525: PPUSH
68526: PPUSH
68527: PPUSH
68528: PPUSH
// tmp := [ ] ;
68529: LD_ADDR_VAR 0 3
68533: PUSH
68534: EMPTY
68535: ST_TO_ADDR
// list := [ ] ;
68536: LD_ADDR_VAR 0 5
68540: PUSH
68541: EMPTY
68542: ST_TO_ADDR
// for i = 16 to 25 do
68543: LD_ADDR_VAR 0 4
68547: PUSH
68548: DOUBLE
68549: LD_INT 16
68551: DEC
68552: ST_TO_ADDR
68553: LD_INT 25
68555: PUSH
68556: FOR_TO
68557: IFFALSE 68630
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68559: LD_ADDR_VAR 0 3
68563: PUSH
68564: LD_VAR 0 3
68568: PUSH
68569: LD_INT 22
68571: PUSH
68572: LD_VAR 0 1
68576: PPUSH
68577: CALL_OW 255
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 91
68588: PUSH
68589: LD_VAR 0 1
68593: PUSH
68594: LD_INT 6
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 30
68604: PUSH
68605: LD_VAR 0 4
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: LIST
68618: PUSH
68619: EMPTY
68620: LIST
68621: PPUSH
68622: CALL_OW 69
68626: ADD
68627: ST_TO_ADDR
68628: GO 68556
68630: POP
68631: POP
// for i = 1 to tmp do
68632: LD_ADDR_VAR 0 4
68636: PUSH
68637: DOUBLE
68638: LD_INT 1
68640: DEC
68641: ST_TO_ADDR
68642: LD_VAR 0 3
68646: PUSH
68647: FOR_TO
68648: IFFALSE 68736
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68650: LD_ADDR_VAR 0 5
68654: PUSH
68655: LD_VAR 0 5
68659: PUSH
68660: LD_VAR 0 3
68664: PUSH
68665: LD_VAR 0 4
68669: ARRAY
68670: PPUSH
68671: CALL_OW 266
68675: PUSH
68676: LD_VAR 0 3
68680: PUSH
68681: LD_VAR 0 4
68685: ARRAY
68686: PPUSH
68687: CALL_OW 250
68691: PUSH
68692: LD_VAR 0 3
68696: PUSH
68697: LD_VAR 0 4
68701: ARRAY
68702: PPUSH
68703: CALL_OW 251
68707: PUSH
68708: LD_VAR 0 3
68712: PUSH
68713: LD_VAR 0 4
68717: ARRAY
68718: PPUSH
68719: CALL_OW 254
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: PUSH
68730: EMPTY
68731: LIST
68732: ADD
68733: ST_TO_ADDR
68734: GO 68647
68736: POP
68737: POP
// result := list ;
68738: LD_ADDR_VAR 0 2
68742: PUSH
68743: LD_VAR 0 5
68747: ST_TO_ADDR
// end ;
68748: LD_VAR 0 2
68752: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68753: LD_INT 0
68755: PPUSH
68756: PPUSH
68757: PPUSH
68758: PPUSH
68759: PPUSH
68760: PPUSH
68761: PPUSH
// if not factory then
68762: LD_VAR 0 1
68766: NOT
68767: IFFALSE 68771
// exit ;
68769: GO 69364
// if control = control_apeman then
68771: LD_VAR 0 4
68775: PUSH
68776: LD_INT 5
68778: EQUAL
68779: IFFALSE 68888
// begin tmp := UnitsInside ( factory ) ;
68781: LD_ADDR_VAR 0 8
68785: PUSH
68786: LD_VAR 0 1
68790: PPUSH
68791: CALL_OW 313
68795: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68796: LD_VAR 0 8
68800: PPUSH
68801: LD_INT 25
68803: PUSH
68804: LD_INT 12
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PPUSH
68811: CALL_OW 72
68815: NOT
68816: IFFALSE 68826
// control := control_manual ;
68818: LD_ADDR_VAR 0 4
68822: PUSH
68823: LD_INT 1
68825: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68826: LD_ADDR_VAR 0 8
68830: PUSH
68831: LD_VAR 0 1
68835: PPUSH
68836: CALL 68523 0 1
68840: ST_TO_ADDR
// if tmp then
68841: LD_VAR 0 8
68845: IFFALSE 68888
// begin for i in tmp do
68847: LD_ADDR_VAR 0 7
68851: PUSH
68852: LD_VAR 0 8
68856: PUSH
68857: FOR_IN
68858: IFFALSE 68886
// if i [ 1 ] = b_ext_radio then
68860: LD_VAR 0 7
68864: PUSH
68865: LD_INT 1
68867: ARRAY
68868: PUSH
68869: LD_INT 22
68871: EQUAL
68872: IFFALSE 68884
// begin control := control_remote ;
68874: LD_ADDR_VAR 0 4
68878: PUSH
68879: LD_INT 2
68881: ST_TO_ADDR
// break ;
68882: GO 68886
// end ;
68884: GO 68857
68886: POP
68887: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68888: LD_VAR 0 1
68892: PPUSH
68893: LD_VAR 0 2
68897: PPUSH
68898: LD_VAR 0 3
68902: PPUSH
68903: LD_VAR 0 4
68907: PPUSH
68908: LD_VAR 0 5
68912: PPUSH
68913: CALL_OW 448
68917: IFFALSE 68952
// begin result := [ chassis , engine , control , weapon ] ;
68919: LD_ADDR_VAR 0 6
68923: PUSH
68924: LD_VAR 0 2
68928: PUSH
68929: LD_VAR 0 3
68933: PUSH
68934: LD_VAR 0 4
68938: PUSH
68939: LD_VAR 0 5
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: ST_TO_ADDR
// exit ;
68950: GO 69364
// end ; _chassis := AvailableChassisList ( factory ) ;
68952: LD_ADDR_VAR 0 9
68956: PUSH
68957: LD_VAR 0 1
68961: PPUSH
68962: CALL_OW 475
68966: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68967: LD_ADDR_VAR 0 11
68971: PUSH
68972: LD_VAR 0 1
68976: PPUSH
68977: CALL_OW 476
68981: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68982: LD_ADDR_VAR 0 12
68986: PUSH
68987: LD_VAR 0 1
68991: PPUSH
68992: CALL_OW 477
68996: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68997: LD_ADDR_VAR 0 10
69001: PUSH
69002: LD_VAR 0 1
69006: PPUSH
69007: CALL_OW 478
69011: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69012: LD_VAR 0 9
69016: NOT
69017: PUSH
69018: LD_VAR 0 11
69022: NOT
69023: OR
69024: PUSH
69025: LD_VAR 0 12
69029: NOT
69030: OR
69031: PUSH
69032: LD_VAR 0 10
69036: NOT
69037: OR
69038: IFFALSE 69073
// begin result := [ chassis , engine , control , weapon ] ;
69040: LD_ADDR_VAR 0 6
69044: PUSH
69045: LD_VAR 0 2
69049: PUSH
69050: LD_VAR 0 3
69054: PUSH
69055: LD_VAR 0 4
69059: PUSH
69060: LD_VAR 0 5
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: ST_TO_ADDR
// exit ;
69071: GO 69364
// end ; if not chassis in _chassis then
69073: LD_VAR 0 2
69077: PUSH
69078: LD_VAR 0 9
69082: IN
69083: NOT
69084: IFFALSE 69110
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69086: LD_ADDR_VAR 0 2
69090: PUSH
69091: LD_VAR 0 9
69095: PUSH
69096: LD_INT 1
69098: PPUSH
69099: LD_VAR 0 9
69103: PPUSH
69104: CALL_OW 12
69108: ARRAY
69109: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69110: LD_VAR 0 2
69114: PPUSH
69115: LD_VAR 0 3
69119: PPUSH
69120: CALL 69369 0 2
69124: NOT
69125: IFFALSE 69184
// repeat engine := _engine [ 1 ] ;
69127: LD_ADDR_VAR 0 3
69131: PUSH
69132: LD_VAR 0 11
69136: PUSH
69137: LD_INT 1
69139: ARRAY
69140: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69141: LD_ADDR_VAR 0 11
69145: PUSH
69146: LD_VAR 0 11
69150: PPUSH
69151: LD_INT 1
69153: PPUSH
69154: CALL_OW 3
69158: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69159: LD_VAR 0 2
69163: PPUSH
69164: LD_VAR 0 3
69168: PPUSH
69169: CALL 69369 0 2
69173: PUSH
69174: LD_VAR 0 11
69178: PUSH
69179: EMPTY
69180: EQUAL
69181: OR
69182: IFFALSE 69127
// if not control in _control then
69184: LD_VAR 0 4
69188: PUSH
69189: LD_VAR 0 12
69193: IN
69194: NOT
69195: IFFALSE 69221
// control := _control [ rand ( 1 , _control ) ] ;
69197: LD_ADDR_VAR 0 4
69201: PUSH
69202: LD_VAR 0 12
69206: PUSH
69207: LD_INT 1
69209: PPUSH
69210: LD_VAR 0 12
69214: PPUSH
69215: CALL_OW 12
69219: ARRAY
69220: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69221: LD_VAR 0 2
69225: PPUSH
69226: LD_VAR 0 5
69230: PPUSH
69231: CALL 69589 0 2
69235: NOT
69236: IFFALSE 69295
// repeat weapon := _weapon [ 1 ] ;
69238: LD_ADDR_VAR 0 5
69242: PUSH
69243: LD_VAR 0 10
69247: PUSH
69248: LD_INT 1
69250: ARRAY
69251: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69252: LD_ADDR_VAR 0 10
69256: PUSH
69257: LD_VAR 0 10
69261: PPUSH
69262: LD_INT 1
69264: PPUSH
69265: CALL_OW 3
69269: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69270: LD_VAR 0 2
69274: PPUSH
69275: LD_VAR 0 5
69279: PPUSH
69280: CALL 69589 0 2
69284: PUSH
69285: LD_VAR 0 10
69289: PUSH
69290: EMPTY
69291: EQUAL
69292: OR
69293: IFFALSE 69238
// result := [ ] ;
69295: LD_ADDR_VAR 0 6
69299: PUSH
69300: EMPTY
69301: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69302: LD_VAR 0 1
69306: PPUSH
69307: LD_VAR 0 2
69311: PPUSH
69312: LD_VAR 0 3
69316: PPUSH
69317: LD_VAR 0 4
69321: PPUSH
69322: LD_VAR 0 5
69326: PPUSH
69327: CALL_OW 448
69331: IFFALSE 69364
// result := [ chassis , engine , control , weapon ] ;
69333: LD_ADDR_VAR 0 6
69337: PUSH
69338: LD_VAR 0 2
69342: PUSH
69343: LD_VAR 0 3
69347: PUSH
69348: LD_VAR 0 4
69352: PUSH
69353: LD_VAR 0 5
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: ST_TO_ADDR
// end ;
69364: LD_VAR 0 6
69368: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69369: LD_INT 0
69371: PPUSH
// if not chassis or not engine then
69372: LD_VAR 0 1
69376: NOT
69377: PUSH
69378: LD_VAR 0 2
69382: NOT
69383: OR
69384: IFFALSE 69388
// exit ;
69386: GO 69584
// case engine of engine_solar :
69388: LD_VAR 0 2
69392: PUSH
69393: LD_INT 2
69395: DOUBLE
69396: EQUAL
69397: IFTRUE 69401
69399: GO 69439
69401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69402: LD_ADDR_VAR 0 3
69406: PUSH
69407: LD_INT 11
69409: PUSH
69410: LD_INT 12
69412: PUSH
69413: LD_INT 13
69415: PUSH
69416: LD_INT 14
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: LD_INT 2
69424: PUSH
69425: LD_INT 3
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: ST_TO_ADDR
69437: GO 69568
69439: LD_INT 1
69441: DOUBLE
69442: EQUAL
69443: IFTRUE 69447
69445: GO 69509
69447: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69448: LD_ADDR_VAR 0 3
69452: PUSH
69453: LD_INT 11
69455: PUSH
69456: LD_INT 12
69458: PUSH
69459: LD_INT 13
69461: PUSH
69462: LD_INT 14
69464: PUSH
69465: LD_INT 1
69467: PUSH
69468: LD_INT 2
69470: PUSH
69471: LD_INT 3
69473: PUSH
69474: LD_INT 4
69476: PUSH
69477: LD_INT 5
69479: PUSH
69480: LD_INT 21
69482: PUSH
69483: LD_INT 23
69485: PUSH
69486: LD_INT 22
69488: PUSH
69489: LD_INT 24
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: LIST
69496: LIST
69497: LIST
69498: LIST
69499: LIST
69500: LIST
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: ST_TO_ADDR
69507: GO 69568
69509: LD_INT 3
69511: DOUBLE
69512: EQUAL
69513: IFTRUE 69517
69515: GO 69567
69517: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69518: LD_ADDR_VAR 0 3
69522: PUSH
69523: LD_INT 13
69525: PUSH
69526: LD_INT 14
69528: PUSH
69529: LD_INT 2
69531: PUSH
69532: LD_INT 3
69534: PUSH
69535: LD_INT 4
69537: PUSH
69538: LD_INT 5
69540: PUSH
69541: LD_INT 21
69543: PUSH
69544: LD_INT 22
69546: PUSH
69547: LD_INT 23
69549: PUSH
69550: LD_INT 24
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: ST_TO_ADDR
69565: GO 69568
69567: POP
// result := ( chassis in result ) ;
69568: LD_ADDR_VAR 0 3
69572: PUSH
69573: LD_VAR 0 1
69577: PUSH
69578: LD_VAR 0 3
69582: IN
69583: ST_TO_ADDR
// end ;
69584: LD_VAR 0 3
69588: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69589: LD_INT 0
69591: PPUSH
// if not chassis or not weapon then
69592: LD_VAR 0 1
69596: NOT
69597: PUSH
69598: LD_VAR 0 2
69602: NOT
69603: OR
69604: IFFALSE 69608
// exit ;
69606: GO 70634
// case weapon of us_machine_gun :
69608: LD_VAR 0 2
69612: PUSH
69613: LD_INT 2
69615: DOUBLE
69616: EQUAL
69617: IFTRUE 69621
69619: GO 69651
69621: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69622: LD_ADDR_VAR 0 3
69626: PUSH
69627: LD_INT 1
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: LD_INT 3
69635: PUSH
69636: LD_INT 4
69638: PUSH
69639: LD_INT 5
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: ST_TO_ADDR
69649: GO 70618
69651: LD_INT 3
69653: DOUBLE
69654: EQUAL
69655: IFTRUE 69659
69657: GO 69689
69659: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69660: LD_ADDR_VAR 0 3
69664: PUSH
69665: LD_INT 1
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: LD_INT 3
69673: PUSH
69674: LD_INT 4
69676: PUSH
69677: LD_INT 5
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: ST_TO_ADDR
69687: GO 70618
69689: LD_INT 11
69691: DOUBLE
69692: EQUAL
69693: IFTRUE 69697
69695: GO 69727
69697: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69698: LD_ADDR_VAR 0 3
69702: PUSH
69703: LD_INT 1
69705: PUSH
69706: LD_INT 2
69708: PUSH
69709: LD_INT 3
69711: PUSH
69712: LD_INT 4
69714: PUSH
69715: LD_INT 5
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: ST_TO_ADDR
69725: GO 70618
69727: LD_INT 4
69729: DOUBLE
69730: EQUAL
69731: IFTRUE 69735
69733: GO 69761
69735: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69736: LD_ADDR_VAR 0 3
69740: PUSH
69741: LD_INT 2
69743: PUSH
69744: LD_INT 3
69746: PUSH
69747: LD_INT 4
69749: PUSH
69750: LD_INT 5
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: ST_TO_ADDR
69759: GO 70618
69761: LD_INT 5
69763: DOUBLE
69764: EQUAL
69765: IFTRUE 69769
69767: GO 69795
69769: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69770: LD_ADDR_VAR 0 3
69774: PUSH
69775: LD_INT 2
69777: PUSH
69778: LD_INT 3
69780: PUSH
69781: LD_INT 4
69783: PUSH
69784: LD_INT 5
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: ST_TO_ADDR
69793: GO 70618
69795: LD_INT 9
69797: DOUBLE
69798: EQUAL
69799: IFTRUE 69803
69801: GO 69829
69803: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69804: LD_ADDR_VAR 0 3
69808: PUSH
69809: LD_INT 2
69811: PUSH
69812: LD_INT 3
69814: PUSH
69815: LD_INT 4
69817: PUSH
69818: LD_INT 5
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: ST_TO_ADDR
69827: GO 70618
69829: LD_INT 7
69831: DOUBLE
69832: EQUAL
69833: IFTRUE 69837
69835: GO 69863
69837: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69838: LD_ADDR_VAR 0 3
69842: PUSH
69843: LD_INT 2
69845: PUSH
69846: LD_INT 3
69848: PUSH
69849: LD_INT 4
69851: PUSH
69852: LD_INT 5
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: ST_TO_ADDR
69861: GO 70618
69863: LD_INT 12
69865: DOUBLE
69866: EQUAL
69867: IFTRUE 69871
69869: GO 69897
69871: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69872: LD_ADDR_VAR 0 3
69876: PUSH
69877: LD_INT 2
69879: PUSH
69880: LD_INT 3
69882: PUSH
69883: LD_INT 4
69885: PUSH
69886: LD_INT 5
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: ST_TO_ADDR
69895: GO 70618
69897: LD_INT 13
69899: DOUBLE
69900: EQUAL
69901: IFTRUE 69905
69903: GO 69931
69905: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69906: LD_ADDR_VAR 0 3
69910: PUSH
69911: LD_INT 2
69913: PUSH
69914: LD_INT 3
69916: PUSH
69917: LD_INT 4
69919: PUSH
69920: LD_INT 5
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: LIST
69927: LIST
69928: ST_TO_ADDR
69929: GO 70618
69931: LD_INT 14
69933: DOUBLE
69934: EQUAL
69935: IFTRUE 69939
69937: GO 69957
69939: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69940: LD_ADDR_VAR 0 3
69944: PUSH
69945: LD_INT 4
69947: PUSH
69948: LD_INT 5
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: ST_TO_ADDR
69955: GO 70618
69957: LD_INT 6
69959: DOUBLE
69960: EQUAL
69961: IFTRUE 69965
69963: GO 69983
69965: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69966: LD_ADDR_VAR 0 3
69970: PUSH
69971: LD_INT 4
69973: PUSH
69974: LD_INT 5
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: ST_TO_ADDR
69981: GO 70618
69983: LD_INT 10
69985: DOUBLE
69986: EQUAL
69987: IFTRUE 69991
69989: GO 70009
69991: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69992: LD_ADDR_VAR 0 3
69996: PUSH
69997: LD_INT 4
69999: PUSH
70000: LD_INT 5
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: ST_TO_ADDR
70007: GO 70618
70009: LD_INT 22
70011: DOUBLE
70012: EQUAL
70013: IFTRUE 70017
70015: GO 70043
70017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70018: LD_ADDR_VAR 0 3
70022: PUSH
70023: LD_INT 11
70025: PUSH
70026: LD_INT 12
70028: PUSH
70029: LD_INT 13
70031: PUSH
70032: LD_INT 14
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: ST_TO_ADDR
70041: GO 70618
70043: LD_INT 23
70045: DOUBLE
70046: EQUAL
70047: IFTRUE 70051
70049: GO 70077
70051: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70052: LD_ADDR_VAR 0 3
70056: PUSH
70057: LD_INT 11
70059: PUSH
70060: LD_INT 12
70062: PUSH
70063: LD_INT 13
70065: PUSH
70066: LD_INT 14
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: ST_TO_ADDR
70075: GO 70618
70077: LD_INT 24
70079: DOUBLE
70080: EQUAL
70081: IFTRUE 70085
70083: GO 70111
70085: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70086: LD_ADDR_VAR 0 3
70090: PUSH
70091: LD_INT 11
70093: PUSH
70094: LD_INT 12
70096: PUSH
70097: LD_INT 13
70099: PUSH
70100: LD_INT 14
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: ST_TO_ADDR
70109: GO 70618
70111: LD_INT 30
70113: DOUBLE
70114: EQUAL
70115: IFTRUE 70119
70117: GO 70145
70119: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70120: LD_ADDR_VAR 0 3
70124: PUSH
70125: LD_INT 11
70127: PUSH
70128: LD_INT 12
70130: PUSH
70131: LD_INT 13
70133: PUSH
70134: LD_INT 14
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: ST_TO_ADDR
70143: GO 70618
70145: LD_INT 25
70147: DOUBLE
70148: EQUAL
70149: IFTRUE 70153
70151: GO 70171
70153: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70154: LD_ADDR_VAR 0 3
70158: PUSH
70159: LD_INT 13
70161: PUSH
70162: LD_INT 14
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: ST_TO_ADDR
70169: GO 70618
70171: LD_INT 27
70173: DOUBLE
70174: EQUAL
70175: IFTRUE 70179
70177: GO 70197
70179: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70180: LD_ADDR_VAR 0 3
70184: PUSH
70185: LD_INT 13
70187: PUSH
70188: LD_INT 14
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: ST_TO_ADDR
70195: GO 70618
70197: LD_INT 28
70199: DOUBLE
70200: EQUAL
70201: IFTRUE 70205
70203: GO 70223
70205: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70206: LD_ADDR_VAR 0 3
70210: PUSH
70211: LD_INT 13
70213: PUSH
70214: LD_INT 14
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: ST_TO_ADDR
70221: GO 70618
70223: LD_INT 29
70225: DOUBLE
70226: EQUAL
70227: IFTRUE 70231
70229: GO 70249
70231: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70232: LD_ADDR_VAR 0 3
70236: PUSH
70237: LD_INT 13
70239: PUSH
70240: LD_INT 14
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: ST_TO_ADDR
70247: GO 70618
70249: LD_INT 31
70251: DOUBLE
70252: EQUAL
70253: IFTRUE 70257
70255: GO 70275
70257: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70258: LD_ADDR_VAR 0 3
70262: PUSH
70263: LD_INT 13
70265: PUSH
70266: LD_INT 14
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: ST_TO_ADDR
70273: GO 70618
70275: LD_INT 26
70277: DOUBLE
70278: EQUAL
70279: IFTRUE 70283
70281: GO 70301
70283: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70284: LD_ADDR_VAR 0 3
70288: PUSH
70289: LD_INT 13
70291: PUSH
70292: LD_INT 14
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: ST_TO_ADDR
70299: GO 70618
70301: LD_INT 42
70303: DOUBLE
70304: EQUAL
70305: IFTRUE 70309
70307: GO 70335
70309: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70310: LD_ADDR_VAR 0 3
70314: PUSH
70315: LD_INT 21
70317: PUSH
70318: LD_INT 22
70320: PUSH
70321: LD_INT 23
70323: PUSH
70324: LD_INT 24
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: ST_TO_ADDR
70333: GO 70618
70335: LD_INT 43
70337: DOUBLE
70338: EQUAL
70339: IFTRUE 70343
70341: GO 70369
70343: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70344: LD_ADDR_VAR 0 3
70348: PUSH
70349: LD_INT 21
70351: PUSH
70352: LD_INT 22
70354: PUSH
70355: LD_INT 23
70357: PUSH
70358: LD_INT 24
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: LIST
70365: LIST
70366: ST_TO_ADDR
70367: GO 70618
70369: LD_INT 44
70371: DOUBLE
70372: EQUAL
70373: IFTRUE 70377
70375: GO 70403
70377: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70378: LD_ADDR_VAR 0 3
70382: PUSH
70383: LD_INT 21
70385: PUSH
70386: LD_INT 22
70388: PUSH
70389: LD_INT 23
70391: PUSH
70392: LD_INT 24
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: ST_TO_ADDR
70401: GO 70618
70403: LD_INT 45
70405: DOUBLE
70406: EQUAL
70407: IFTRUE 70411
70409: GO 70437
70411: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70412: LD_ADDR_VAR 0 3
70416: PUSH
70417: LD_INT 21
70419: PUSH
70420: LD_INT 22
70422: PUSH
70423: LD_INT 23
70425: PUSH
70426: LD_INT 24
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: ST_TO_ADDR
70435: GO 70618
70437: LD_INT 49
70439: DOUBLE
70440: EQUAL
70441: IFTRUE 70445
70443: GO 70471
70445: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70446: LD_ADDR_VAR 0 3
70450: PUSH
70451: LD_INT 21
70453: PUSH
70454: LD_INT 22
70456: PUSH
70457: LD_INT 23
70459: PUSH
70460: LD_INT 24
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: ST_TO_ADDR
70469: GO 70618
70471: LD_INT 51
70473: DOUBLE
70474: EQUAL
70475: IFTRUE 70479
70477: GO 70505
70479: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70480: LD_ADDR_VAR 0 3
70484: PUSH
70485: LD_INT 21
70487: PUSH
70488: LD_INT 22
70490: PUSH
70491: LD_INT 23
70493: PUSH
70494: LD_INT 24
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: LIST
70501: LIST
70502: ST_TO_ADDR
70503: GO 70618
70505: LD_INT 52
70507: DOUBLE
70508: EQUAL
70509: IFTRUE 70513
70511: GO 70539
70513: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70514: LD_ADDR_VAR 0 3
70518: PUSH
70519: LD_INT 21
70521: PUSH
70522: LD_INT 22
70524: PUSH
70525: LD_INT 23
70527: PUSH
70528: LD_INT 24
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: ST_TO_ADDR
70537: GO 70618
70539: LD_INT 53
70541: DOUBLE
70542: EQUAL
70543: IFTRUE 70547
70545: GO 70565
70547: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70548: LD_ADDR_VAR 0 3
70552: PUSH
70553: LD_INT 23
70555: PUSH
70556: LD_INT 24
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: ST_TO_ADDR
70563: GO 70618
70565: LD_INT 46
70567: DOUBLE
70568: EQUAL
70569: IFTRUE 70573
70571: GO 70591
70573: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70574: LD_ADDR_VAR 0 3
70578: PUSH
70579: LD_INT 23
70581: PUSH
70582: LD_INT 24
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: ST_TO_ADDR
70589: GO 70618
70591: LD_INT 47
70593: DOUBLE
70594: EQUAL
70595: IFTRUE 70599
70597: GO 70617
70599: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70600: LD_ADDR_VAR 0 3
70604: PUSH
70605: LD_INT 23
70607: PUSH
70608: LD_INT 24
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: ST_TO_ADDR
70615: GO 70618
70617: POP
// result := ( chassis in result ) ;
70618: LD_ADDR_VAR 0 3
70622: PUSH
70623: LD_VAR 0 1
70627: PUSH
70628: LD_VAR 0 3
70632: IN
70633: ST_TO_ADDR
// end ;
70634: LD_VAR 0 3
70638: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70639: LD_INT 0
70641: PPUSH
70642: PPUSH
70643: PPUSH
70644: PPUSH
70645: PPUSH
70646: PPUSH
70647: PPUSH
// result := array ;
70648: LD_ADDR_VAR 0 5
70652: PUSH
70653: LD_VAR 0 1
70657: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70658: LD_VAR 0 1
70662: NOT
70663: PUSH
70664: LD_VAR 0 2
70668: NOT
70669: OR
70670: PUSH
70671: LD_VAR 0 3
70675: NOT
70676: OR
70677: PUSH
70678: LD_VAR 0 2
70682: PUSH
70683: LD_VAR 0 1
70687: GREATER
70688: OR
70689: PUSH
70690: LD_VAR 0 3
70694: PUSH
70695: LD_VAR 0 1
70699: GREATER
70700: OR
70701: IFFALSE 70705
// exit ;
70703: GO 71001
// if direction then
70705: LD_VAR 0 4
70709: IFFALSE 70773
// begin d := 1 ;
70711: LD_ADDR_VAR 0 9
70715: PUSH
70716: LD_INT 1
70718: ST_TO_ADDR
// if i_from > i_to then
70719: LD_VAR 0 2
70723: PUSH
70724: LD_VAR 0 3
70728: GREATER
70729: IFFALSE 70755
// length := ( array - i_from ) + i_to else
70731: LD_ADDR_VAR 0 11
70735: PUSH
70736: LD_VAR 0 1
70740: PUSH
70741: LD_VAR 0 2
70745: MINUS
70746: PUSH
70747: LD_VAR 0 3
70751: PLUS
70752: ST_TO_ADDR
70753: GO 70771
// length := i_to - i_from ;
70755: LD_ADDR_VAR 0 11
70759: PUSH
70760: LD_VAR 0 3
70764: PUSH
70765: LD_VAR 0 2
70769: MINUS
70770: ST_TO_ADDR
// end else
70771: GO 70834
// begin d := - 1 ;
70773: LD_ADDR_VAR 0 9
70777: PUSH
70778: LD_INT 1
70780: NEG
70781: ST_TO_ADDR
// if i_from > i_to then
70782: LD_VAR 0 2
70786: PUSH
70787: LD_VAR 0 3
70791: GREATER
70792: IFFALSE 70812
// length := i_from - i_to else
70794: LD_ADDR_VAR 0 11
70798: PUSH
70799: LD_VAR 0 2
70803: PUSH
70804: LD_VAR 0 3
70808: MINUS
70809: ST_TO_ADDR
70810: GO 70834
// length := ( array - i_to ) + i_from ;
70812: LD_ADDR_VAR 0 11
70816: PUSH
70817: LD_VAR 0 1
70821: PUSH
70822: LD_VAR 0 3
70826: MINUS
70827: PUSH
70828: LD_VAR 0 2
70832: PLUS
70833: ST_TO_ADDR
// end ; if not length then
70834: LD_VAR 0 11
70838: NOT
70839: IFFALSE 70843
// exit ;
70841: GO 71001
// tmp := array ;
70843: LD_ADDR_VAR 0 10
70847: PUSH
70848: LD_VAR 0 1
70852: ST_TO_ADDR
// for i = 1 to length do
70853: LD_ADDR_VAR 0 6
70857: PUSH
70858: DOUBLE
70859: LD_INT 1
70861: DEC
70862: ST_TO_ADDR
70863: LD_VAR 0 11
70867: PUSH
70868: FOR_TO
70869: IFFALSE 70989
// begin for j = 1 to array do
70871: LD_ADDR_VAR 0 7
70875: PUSH
70876: DOUBLE
70877: LD_INT 1
70879: DEC
70880: ST_TO_ADDR
70881: LD_VAR 0 1
70885: PUSH
70886: FOR_TO
70887: IFFALSE 70975
// begin k := j + d ;
70889: LD_ADDR_VAR 0 8
70893: PUSH
70894: LD_VAR 0 7
70898: PUSH
70899: LD_VAR 0 9
70903: PLUS
70904: ST_TO_ADDR
// if k > array then
70905: LD_VAR 0 8
70909: PUSH
70910: LD_VAR 0 1
70914: GREATER
70915: IFFALSE 70925
// k := 1 ;
70917: LD_ADDR_VAR 0 8
70921: PUSH
70922: LD_INT 1
70924: ST_TO_ADDR
// if not k then
70925: LD_VAR 0 8
70929: NOT
70930: IFFALSE 70942
// k := array ;
70932: LD_ADDR_VAR 0 8
70936: PUSH
70937: LD_VAR 0 1
70941: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70942: LD_ADDR_VAR 0 10
70946: PUSH
70947: LD_VAR 0 10
70951: PPUSH
70952: LD_VAR 0 8
70956: PPUSH
70957: LD_VAR 0 1
70961: PUSH
70962: LD_VAR 0 7
70966: ARRAY
70967: PPUSH
70968: CALL_OW 1
70972: ST_TO_ADDR
// end ;
70973: GO 70886
70975: POP
70976: POP
// array := tmp ;
70977: LD_ADDR_VAR 0 1
70981: PUSH
70982: LD_VAR 0 10
70986: ST_TO_ADDR
// end ;
70987: GO 70868
70989: POP
70990: POP
// result := array ;
70991: LD_ADDR_VAR 0 5
70995: PUSH
70996: LD_VAR 0 1
71000: ST_TO_ADDR
// end ;
71001: LD_VAR 0 5
71005: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71006: LD_INT 0
71008: PPUSH
71009: PPUSH
// result := 0 ;
71010: LD_ADDR_VAR 0 3
71014: PUSH
71015: LD_INT 0
71017: ST_TO_ADDR
// if not array or not value in array then
71018: LD_VAR 0 1
71022: NOT
71023: PUSH
71024: LD_VAR 0 2
71028: PUSH
71029: LD_VAR 0 1
71033: IN
71034: NOT
71035: OR
71036: IFFALSE 71040
// exit ;
71038: GO 71094
// for i = 1 to array do
71040: LD_ADDR_VAR 0 4
71044: PUSH
71045: DOUBLE
71046: LD_INT 1
71048: DEC
71049: ST_TO_ADDR
71050: LD_VAR 0 1
71054: PUSH
71055: FOR_TO
71056: IFFALSE 71092
// if value = array [ i ] then
71058: LD_VAR 0 2
71062: PUSH
71063: LD_VAR 0 1
71067: PUSH
71068: LD_VAR 0 4
71072: ARRAY
71073: EQUAL
71074: IFFALSE 71090
// begin result := i ;
71076: LD_ADDR_VAR 0 3
71080: PUSH
71081: LD_VAR 0 4
71085: ST_TO_ADDR
// exit ;
71086: POP
71087: POP
71088: GO 71094
// end ;
71090: GO 71055
71092: POP
71093: POP
// end ;
71094: LD_VAR 0 3
71098: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71099: LD_INT 0
71101: PPUSH
// vc_chassis := chassis ;
71102: LD_ADDR_OWVAR 37
71106: PUSH
71107: LD_VAR 0 1
71111: ST_TO_ADDR
// vc_engine := engine ;
71112: LD_ADDR_OWVAR 39
71116: PUSH
71117: LD_VAR 0 2
71121: ST_TO_ADDR
// vc_control := control ;
71122: LD_ADDR_OWVAR 38
71126: PUSH
71127: LD_VAR 0 3
71131: ST_TO_ADDR
// vc_weapon := weapon ;
71132: LD_ADDR_OWVAR 40
71136: PUSH
71137: LD_VAR 0 4
71141: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71142: LD_ADDR_OWVAR 41
71146: PUSH
71147: LD_VAR 0 5
71151: ST_TO_ADDR
// end ;
71152: LD_VAR 0 6
71156: RET
// export function WantPlant ( unit ) ; var task ; begin
71157: LD_INT 0
71159: PPUSH
71160: PPUSH
// result := false ;
71161: LD_ADDR_VAR 0 2
71165: PUSH
71166: LD_INT 0
71168: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71169: LD_ADDR_VAR 0 3
71173: PUSH
71174: LD_VAR 0 1
71178: PPUSH
71179: CALL_OW 437
71183: ST_TO_ADDR
// if task then
71184: LD_VAR 0 3
71188: IFFALSE 71216
// if task [ 1 ] [ 1 ] = p then
71190: LD_VAR 0 3
71194: PUSH
71195: LD_INT 1
71197: ARRAY
71198: PUSH
71199: LD_INT 1
71201: ARRAY
71202: PUSH
71203: LD_STRING p
71205: EQUAL
71206: IFFALSE 71216
// result := true ;
71208: LD_ADDR_VAR 0 2
71212: PUSH
71213: LD_INT 1
71215: ST_TO_ADDR
// end ;
71216: LD_VAR 0 2
71220: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71221: LD_INT 0
71223: PPUSH
71224: PPUSH
71225: PPUSH
71226: PPUSH
// if pos < 1 then
71227: LD_VAR 0 2
71231: PUSH
71232: LD_INT 1
71234: LESS
71235: IFFALSE 71239
// exit ;
71237: GO 71542
// if pos = 1 then
71239: LD_VAR 0 2
71243: PUSH
71244: LD_INT 1
71246: EQUAL
71247: IFFALSE 71280
// result := Replace ( arr , pos [ 1 ] , value ) else
71249: LD_ADDR_VAR 0 4
71253: PUSH
71254: LD_VAR 0 1
71258: PPUSH
71259: LD_VAR 0 2
71263: PUSH
71264: LD_INT 1
71266: ARRAY
71267: PPUSH
71268: LD_VAR 0 3
71272: PPUSH
71273: CALL_OW 1
71277: ST_TO_ADDR
71278: GO 71542
// begin tmp := arr ;
71280: LD_ADDR_VAR 0 6
71284: PUSH
71285: LD_VAR 0 1
71289: ST_TO_ADDR
// s_arr := [ tmp ] ;
71290: LD_ADDR_VAR 0 7
71294: PUSH
71295: LD_VAR 0 6
71299: PUSH
71300: EMPTY
71301: LIST
71302: ST_TO_ADDR
// for i = 1 to pos - 1 do
71303: LD_ADDR_VAR 0 5
71307: PUSH
71308: DOUBLE
71309: LD_INT 1
71311: DEC
71312: ST_TO_ADDR
71313: LD_VAR 0 2
71317: PUSH
71318: LD_INT 1
71320: MINUS
71321: PUSH
71322: FOR_TO
71323: IFFALSE 71368
// begin tmp := tmp [ pos [ i ] ] ;
71325: LD_ADDR_VAR 0 6
71329: PUSH
71330: LD_VAR 0 6
71334: PUSH
71335: LD_VAR 0 2
71339: PUSH
71340: LD_VAR 0 5
71344: ARRAY
71345: ARRAY
71346: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71347: LD_ADDR_VAR 0 7
71351: PUSH
71352: LD_VAR 0 7
71356: PUSH
71357: LD_VAR 0 6
71361: PUSH
71362: EMPTY
71363: LIST
71364: ADD
71365: ST_TO_ADDR
// end ;
71366: GO 71322
71368: POP
71369: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71370: LD_ADDR_VAR 0 6
71374: PUSH
71375: LD_VAR 0 6
71379: PPUSH
71380: LD_VAR 0 2
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PPUSH
71391: LD_VAR 0 3
71395: PPUSH
71396: CALL_OW 1
71400: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71401: LD_ADDR_VAR 0 7
71405: PUSH
71406: LD_VAR 0 7
71410: PPUSH
71411: LD_VAR 0 7
71415: PPUSH
71416: LD_VAR 0 6
71420: PPUSH
71421: CALL_OW 1
71425: ST_TO_ADDR
// for i = s_arr downto 2 do
71426: LD_ADDR_VAR 0 5
71430: PUSH
71431: DOUBLE
71432: LD_VAR 0 7
71436: INC
71437: ST_TO_ADDR
71438: LD_INT 2
71440: PUSH
71441: FOR_DOWNTO
71442: IFFALSE 71526
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71444: LD_ADDR_VAR 0 6
71448: PUSH
71449: LD_VAR 0 7
71453: PUSH
71454: LD_VAR 0 5
71458: PUSH
71459: LD_INT 1
71461: MINUS
71462: ARRAY
71463: PPUSH
71464: LD_VAR 0 2
71468: PUSH
71469: LD_VAR 0 5
71473: PUSH
71474: LD_INT 1
71476: MINUS
71477: ARRAY
71478: PPUSH
71479: LD_VAR 0 7
71483: PUSH
71484: LD_VAR 0 5
71488: ARRAY
71489: PPUSH
71490: CALL_OW 1
71494: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71495: LD_ADDR_VAR 0 7
71499: PUSH
71500: LD_VAR 0 7
71504: PPUSH
71505: LD_VAR 0 5
71509: PUSH
71510: LD_INT 1
71512: MINUS
71513: PPUSH
71514: LD_VAR 0 6
71518: PPUSH
71519: CALL_OW 1
71523: ST_TO_ADDR
// end ;
71524: GO 71441
71526: POP
71527: POP
// result := s_arr [ 1 ] ;
71528: LD_ADDR_VAR 0 4
71532: PUSH
71533: LD_VAR 0 7
71537: PUSH
71538: LD_INT 1
71540: ARRAY
71541: ST_TO_ADDR
// end ; end ;
71542: LD_VAR 0 4
71546: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71547: LD_INT 0
71549: PPUSH
71550: PPUSH
// if not list then
71551: LD_VAR 0 1
71555: NOT
71556: IFFALSE 71560
// exit ;
71558: GO 71651
// i := list [ pos1 ] ;
71560: LD_ADDR_VAR 0 5
71564: PUSH
71565: LD_VAR 0 1
71569: PUSH
71570: LD_VAR 0 2
71574: ARRAY
71575: ST_TO_ADDR
// if not i then
71576: LD_VAR 0 5
71580: NOT
71581: IFFALSE 71585
// exit ;
71583: GO 71651
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71585: LD_ADDR_VAR 0 1
71589: PUSH
71590: LD_VAR 0 1
71594: PPUSH
71595: LD_VAR 0 2
71599: PPUSH
71600: LD_VAR 0 1
71604: PUSH
71605: LD_VAR 0 3
71609: ARRAY
71610: PPUSH
71611: CALL_OW 1
71615: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71616: LD_ADDR_VAR 0 1
71620: PUSH
71621: LD_VAR 0 1
71625: PPUSH
71626: LD_VAR 0 3
71630: PPUSH
71631: LD_VAR 0 5
71635: PPUSH
71636: CALL_OW 1
71640: ST_TO_ADDR
// result := list ;
71641: LD_ADDR_VAR 0 4
71645: PUSH
71646: LD_VAR 0 1
71650: ST_TO_ADDR
// end ;
71651: LD_VAR 0 4
71655: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71656: LD_INT 0
71658: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71659: LD_ADDR_VAR 0 5
71663: PUSH
71664: LD_VAR 0 1
71668: PPUSH
71669: CALL_OW 250
71673: PPUSH
71674: LD_VAR 0 1
71678: PPUSH
71679: CALL_OW 251
71683: PPUSH
71684: LD_VAR 0 2
71688: PPUSH
71689: LD_VAR 0 3
71693: PPUSH
71694: LD_VAR 0 4
71698: PPUSH
71699: CALL 71709 0 5
71703: ST_TO_ADDR
// end ;
71704: LD_VAR 0 5
71708: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71709: LD_INT 0
71711: PPUSH
71712: PPUSH
71713: PPUSH
71714: PPUSH
// if not list then
71715: LD_VAR 0 3
71719: NOT
71720: IFFALSE 71724
// exit ;
71722: GO 72112
// result := [ ] ;
71724: LD_ADDR_VAR 0 6
71728: PUSH
71729: EMPTY
71730: ST_TO_ADDR
// for i in list do
71731: LD_ADDR_VAR 0 7
71735: PUSH
71736: LD_VAR 0 3
71740: PUSH
71741: FOR_IN
71742: IFFALSE 71944
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71744: LD_ADDR_VAR 0 9
71748: PUSH
71749: LD_VAR 0 7
71753: PPUSH
71754: LD_VAR 0 1
71758: PPUSH
71759: LD_VAR 0 2
71763: PPUSH
71764: CALL_OW 297
71768: ST_TO_ADDR
// if not result then
71769: LD_VAR 0 6
71773: NOT
71774: IFFALSE 71800
// result := [ [ i , tmp ] ] else
71776: LD_ADDR_VAR 0 6
71780: PUSH
71781: LD_VAR 0 7
71785: PUSH
71786: LD_VAR 0 9
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: EMPTY
71796: LIST
71797: ST_TO_ADDR
71798: GO 71942
// begin if result [ result ] [ 2 ] < tmp then
71800: LD_VAR 0 6
71804: PUSH
71805: LD_VAR 0 6
71809: ARRAY
71810: PUSH
71811: LD_INT 2
71813: ARRAY
71814: PUSH
71815: LD_VAR 0 9
71819: LESS
71820: IFFALSE 71862
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71822: LD_ADDR_VAR 0 6
71826: PUSH
71827: LD_VAR 0 6
71831: PPUSH
71832: LD_VAR 0 6
71836: PUSH
71837: LD_INT 1
71839: PLUS
71840: PPUSH
71841: LD_VAR 0 7
71845: PUSH
71846: LD_VAR 0 9
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PPUSH
71855: CALL_OW 2
71859: ST_TO_ADDR
71860: GO 71942
// for j = 1 to result do
71862: LD_ADDR_VAR 0 8
71866: PUSH
71867: DOUBLE
71868: LD_INT 1
71870: DEC
71871: ST_TO_ADDR
71872: LD_VAR 0 6
71876: PUSH
71877: FOR_TO
71878: IFFALSE 71940
// begin if tmp < result [ j ] [ 2 ] then
71880: LD_VAR 0 9
71884: PUSH
71885: LD_VAR 0 6
71889: PUSH
71890: LD_VAR 0 8
71894: ARRAY
71895: PUSH
71896: LD_INT 2
71898: ARRAY
71899: LESS
71900: IFFALSE 71938
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71902: LD_ADDR_VAR 0 6
71906: PUSH
71907: LD_VAR 0 6
71911: PPUSH
71912: LD_VAR 0 8
71916: PPUSH
71917: LD_VAR 0 7
71921: PUSH
71922: LD_VAR 0 9
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PPUSH
71931: CALL_OW 2
71935: ST_TO_ADDR
// break ;
71936: GO 71940
// end ; end ;
71938: GO 71877
71940: POP
71941: POP
// end ; end ;
71942: GO 71741
71944: POP
71945: POP
// if result and not asc then
71946: LD_VAR 0 6
71950: PUSH
71951: LD_VAR 0 4
71955: NOT
71956: AND
71957: IFFALSE 72032
// begin tmp := result ;
71959: LD_ADDR_VAR 0 9
71963: PUSH
71964: LD_VAR 0 6
71968: ST_TO_ADDR
// for i = tmp downto 1 do
71969: LD_ADDR_VAR 0 7
71973: PUSH
71974: DOUBLE
71975: LD_VAR 0 9
71979: INC
71980: ST_TO_ADDR
71981: LD_INT 1
71983: PUSH
71984: FOR_DOWNTO
71985: IFFALSE 72030
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71987: LD_ADDR_VAR 0 6
71991: PUSH
71992: LD_VAR 0 6
71996: PPUSH
71997: LD_VAR 0 9
72001: PUSH
72002: LD_VAR 0 7
72006: MINUS
72007: PUSH
72008: LD_INT 1
72010: PLUS
72011: PPUSH
72012: LD_VAR 0 9
72016: PUSH
72017: LD_VAR 0 7
72021: ARRAY
72022: PPUSH
72023: CALL_OW 1
72027: ST_TO_ADDR
72028: GO 71984
72030: POP
72031: POP
// end ; tmp := [ ] ;
72032: LD_ADDR_VAR 0 9
72036: PUSH
72037: EMPTY
72038: ST_TO_ADDR
// if mode then
72039: LD_VAR 0 5
72043: IFFALSE 72112
// begin for i = 1 to result do
72045: LD_ADDR_VAR 0 7
72049: PUSH
72050: DOUBLE
72051: LD_INT 1
72053: DEC
72054: ST_TO_ADDR
72055: LD_VAR 0 6
72059: PUSH
72060: FOR_TO
72061: IFFALSE 72100
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72063: LD_ADDR_VAR 0 9
72067: PUSH
72068: LD_VAR 0 9
72072: PPUSH
72073: LD_VAR 0 7
72077: PPUSH
72078: LD_VAR 0 6
72082: PUSH
72083: LD_VAR 0 7
72087: ARRAY
72088: PUSH
72089: LD_INT 1
72091: ARRAY
72092: PPUSH
72093: CALL_OW 1
72097: ST_TO_ADDR
72098: GO 72060
72100: POP
72101: POP
// result := tmp ;
72102: LD_ADDR_VAR 0 6
72106: PUSH
72107: LD_VAR 0 9
72111: ST_TO_ADDR
// end ; end ;
72112: LD_VAR 0 6
72116: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72117: LD_INT 0
72119: PPUSH
72120: PPUSH
72121: PPUSH
72122: PPUSH
72123: PPUSH
72124: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72125: LD_ADDR_VAR 0 5
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: LD_INT 0
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: EMPTY
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: ST_TO_ADDR
// if not x or not y then
72147: LD_VAR 0 2
72151: NOT
72152: PUSH
72153: LD_VAR 0 3
72157: NOT
72158: OR
72159: IFFALSE 72163
// exit ;
72161: GO 73809
// if not range then
72163: LD_VAR 0 4
72167: NOT
72168: IFFALSE 72178
// range := 10 ;
72170: LD_ADDR_VAR 0 4
72174: PUSH
72175: LD_INT 10
72177: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72178: LD_ADDR_VAR 0 8
72182: PUSH
72183: LD_INT 81
72185: PUSH
72186: LD_VAR 0 1
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 92
72197: PUSH
72198: LD_VAR 0 2
72202: PUSH
72203: LD_VAR 0 3
72207: PUSH
72208: LD_VAR 0 4
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 3
72221: PUSH
72222: LD_INT 21
72224: PUSH
72225: LD_INT 3
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: LIST
72240: PPUSH
72241: CALL_OW 69
72245: ST_TO_ADDR
// if not tmp then
72246: LD_VAR 0 8
72250: NOT
72251: IFFALSE 72255
// exit ;
72253: GO 73809
// for i in tmp do
72255: LD_ADDR_VAR 0 6
72259: PUSH
72260: LD_VAR 0 8
72264: PUSH
72265: FOR_IN
72266: IFFALSE 73784
// begin points := [ 0 , 0 , 0 ] ;
72268: LD_ADDR_VAR 0 9
72272: PUSH
72273: LD_INT 0
72275: PUSH
72276: LD_INT 0
72278: PUSH
72279: LD_INT 0
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: LIST
72286: ST_TO_ADDR
// bpoints := 1 ;
72287: LD_ADDR_VAR 0 10
72291: PUSH
72292: LD_INT 1
72294: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72295: LD_VAR 0 6
72299: PPUSH
72300: CALL_OW 247
72304: PUSH
72305: LD_INT 1
72307: DOUBLE
72308: EQUAL
72309: IFTRUE 72313
72311: GO 72891
72313: POP
// begin if GetClass ( i ) = 1 then
72314: LD_VAR 0 6
72318: PPUSH
72319: CALL_OW 257
72323: PUSH
72324: LD_INT 1
72326: EQUAL
72327: IFFALSE 72348
// points := [ 10 , 5 , 3 ] ;
72329: LD_ADDR_VAR 0 9
72333: PUSH
72334: LD_INT 10
72336: PUSH
72337: LD_INT 5
72339: PUSH
72340: LD_INT 3
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: LIST
72347: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72348: LD_VAR 0 6
72352: PPUSH
72353: CALL_OW 257
72357: PUSH
72358: LD_INT 2
72360: PUSH
72361: LD_INT 3
72363: PUSH
72364: LD_INT 4
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: LIST
72371: IN
72372: IFFALSE 72393
// points := [ 3 , 2 , 1 ] ;
72374: LD_ADDR_VAR 0 9
72378: PUSH
72379: LD_INT 3
72381: PUSH
72382: LD_INT 2
72384: PUSH
72385: LD_INT 1
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: LIST
72392: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72393: LD_VAR 0 6
72397: PPUSH
72398: CALL_OW 257
72402: PUSH
72403: LD_INT 5
72405: EQUAL
72406: IFFALSE 72427
// points := [ 130 , 5 , 2 ] ;
72408: LD_ADDR_VAR 0 9
72412: PUSH
72413: LD_INT 130
72415: PUSH
72416: LD_INT 5
72418: PUSH
72419: LD_INT 2
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: LIST
72426: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72427: LD_VAR 0 6
72431: PPUSH
72432: CALL_OW 257
72436: PUSH
72437: LD_INT 8
72439: EQUAL
72440: IFFALSE 72461
// points := [ 35 , 35 , 30 ] ;
72442: LD_ADDR_VAR 0 9
72446: PUSH
72447: LD_INT 35
72449: PUSH
72450: LD_INT 35
72452: PUSH
72453: LD_INT 30
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: LIST
72460: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72461: LD_VAR 0 6
72465: PPUSH
72466: CALL_OW 257
72470: PUSH
72471: LD_INT 9
72473: EQUAL
72474: IFFALSE 72495
// points := [ 20 , 55 , 40 ] ;
72476: LD_ADDR_VAR 0 9
72480: PUSH
72481: LD_INT 20
72483: PUSH
72484: LD_INT 55
72486: PUSH
72487: LD_INT 40
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: LIST
72494: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72495: LD_VAR 0 6
72499: PPUSH
72500: CALL_OW 257
72504: PUSH
72505: LD_INT 12
72507: PUSH
72508: LD_INT 16
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: IN
72515: IFFALSE 72536
// points := [ 5 , 3 , 2 ] ;
72517: LD_ADDR_VAR 0 9
72521: PUSH
72522: LD_INT 5
72524: PUSH
72525: LD_INT 3
72527: PUSH
72528: LD_INT 2
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: LIST
72535: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72536: LD_VAR 0 6
72540: PPUSH
72541: CALL_OW 257
72545: PUSH
72546: LD_INT 17
72548: EQUAL
72549: IFFALSE 72570
// points := [ 100 , 50 , 75 ] ;
72551: LD_ADDR_VAR 0 9
72555: PUSH
72556: LD_INT 100
72558: PUSH
72559: LD_INT 50
72561: PUSH
72562: LD_INT 75
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: LIST
72569: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72570: LD_VAR 0 6
72574: PPUSH
72575: CALL_OW 257
72579: PUSH
72580: LD_INT 15
72582: EQUAL
72583: IFFALSE 72604
// points := [ 10 , 5 , 3 ] ;
72585: LD_ADDR_VAR 0 9
72589: PUSH
72590: LD_INT 10
72592: PUSH
72593: LD_INT 5
72595: PUSH
72596: LD_INT 3
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: LIST
72603: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72604: LD_VAR 0 6
72608: PPUSH
72609: CALL_OW 257
72613: PUSH
72614: LD_INT 14
72616: EQUAL
72617: IFFALSE 72638
// points := [ 10 , 0 , 0 ] ;
72619: LD_ADDR_VAR 0 9
72623: PUSH
72624: LD_INT 10
72626: PUSH
72627: LD_INT 0
72629: PUSH
72630: LD_INT 0
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: LIST
72637: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72638: LD_VAR 0 6
72642: PPUSH
72643: CALL_OW 257
72647: PUSH
72648: LD_INT 11
72650: EQUAL
72651: IFFALSE 72672
// points := [ 30 , 10 , 5 ] ;
72653: LD_ADDR_VAR 0 9
72657: PUSH
72658: LD_INT 30
72660: PUSH
72661: LD_INT 10
72663: PUSH
72664: LD_INT 5
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: LIST
72671: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72672: LD_VAR 0 1
72676: PPUSH
72677: LD_INT 5
72679: PPUSH
72680: CALL_OW 321
72684: PUSH
72685: LD_INT 2
72687: EQUAL
72688: IFFALSE 72705
// bpoints := bpoints * 1.8 ;
72690: LD_ADDR_VAR 0 10
72694: PUSH
72695: LD_VAR 0 10
72699: PUSH
72700: LD_REAL  1.80000000000000E+0000
72703: MUL
72704: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72705: LD_VAR 0 6
72709: PPUSH
72710: CALL_OW 257
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 2
72720: PUSH
72721: LD_INT 3
72723: PUSH
72724: LD_INT 4
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: IN
72733: PUSH
72734: LD_VAR 0 1
72738: PPUSH
72739: LD_INT 51
72741: PPUSH
72742: CALL_OW 321
72746: PUSH
72747: LD_INT 2
72749: EQUAL
72750: AND
72751: IFFALSE 72768
// bpoints := bpoints * 1.2 ;
72753: LD_ADDR_VAR 0 10
72757: PUSH
72758: LD_VAR 0 10
72762: PUSH
72763: LD_REAL  1.20000000000000E+0000
72766: MUL
72767: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72768: LD_VAR 0 6
72772: PPUSH
72773: CALL_OW 257
72777: PUSH
72778: LD_INT 5
72780: PUSH
72781: LD_INT 7
72783: PUSH
72784: LD_INT 9
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: LIST
72791: IN
72792: PUSH
72793: LD_VAR 0 1
72797: PPUSH
72798: LD_INT 52
72800: PPUSH
72801: CALL_OW 321
72805: PUSH
72806: LD_INT 2
72808: EQUAL
72809: AND
72810: IFFALSE 72827
// bpoints := bpoints * 1.5 ;
72812: LD_ADDR_VAR 0 10
72816: PUSH
72817: LD_VAR 0 10
72821: PUSH
72822: LD_REAL  1.50000000000000E+0000
72825: MUL
72826: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72827: LD_VAR 0 1
72831: PPUSH
72832: LD_INT 66
72834: PPUSH
72835: CALL_OW 321
72839: PUSH
72840: LD_INT 2
72842: EQUAL
72843: IFFALSE 72860
// bpoints := bpoints * 1.1 ;
72845: LD_ADDR_VAR 0 10
72849: PUSH
72850: LD_VAR 0 10
72854: PUSH
72855: LD_REAL  1.10000000000000E+0000
72858: MUL
72859: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72860: LD_ADDR_VAR 0 10
72864: PUSH
72865: LD_VAR 0 10
72869: PUSH
72870: LD_VAR 0 6
72874: PPUSH
72875: LD_INT 1
72877: PPUSH
72878: CALL_OW 259
72882: PUSH
72883: LD_REAL  1.15000000000000E+0000
72886: MUL
72887: MUL
72888: ST_TO_ADDR
// end ; unit_vehicle :
72889: GO 73713
72891: LD_INT 2
72893: DOUBLE
72894: EQUAL
72895: IFTRUE 72899
72897: GO 73701
72899: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72900: LD_VAR 0 6
72904: PPUSH
72905: CALL_OW 264
72909: PUSH
72910: LD_INT 2
72912: PUSH
72913: LD_INT 42
72915: PUSH
72916: LD_INT 24
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: LIST
72923: IN
72924: IFFALSE 72945
// points := [ 25 , 5 , 3 ] ;
72926: LD_ADDR_VAR 0 9
72930: PUSH
72931: LD_INT 25
72933: PUSH
72934: LD_INT 5
72936: PUSH
72937: LD_INT 3
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: LIST
72944: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72945: LD_VAR 0 6
72949: PPUSH
72950: CALL_OW 264
72954: PUSH
72955: LD_INT 4
72957: PUSH
72958: LD_INT 43
72960: PUSH
72961: LD_INT 25
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: LIST
72968: IN
72969: IFFALSE 72990
// points := [ 40 , 15 , 5 ] ;
72971: LD_ADDR_VAR 0 9
72975: PUSH
72976: LD_INT 40
72978: PUSH
72979: LD_INT 15
72981: PUSH
72982: LD_INT 5
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: LIST
72989: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72990: LD_VAR 0 6
72994: PPUSH
72995: CALL_OW 264
72999: PUSH
73000: LD_INT 3
73002: PUSH
73003: LD_INT 23
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: IN
73010: IFFALSE 73031
// points := [ 7 , 25 , 8 ] ;
73012: LD_ADDR_VAR 0 9
73016: PUSH
73017: LD_INT 7
73019: PUSH
73020: LD_INT 25
73022: PUSH
73023: LD_INT 8
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: LIST
73030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73031: LD_VAR 0 6
73035: PPUSH
73036: CALL_OW 264
73040: PUSH
73041: LD_INT 5
73043: PUSH
73044: LD_INT 27
73046: PUSH
73047: LD_INT 44
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: LIST
73054: IN
73055: IFFALSE 73076
// points := [ 14 , 50 , 16 ] ;
73057: LD_ADDR_VAR 0 9
73061: PUSH
73062: LD_INT 14
73064: PUSH
73065: LD_INT 50
73067: PUSH
73068: LD_INT 16
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: LIST
73075: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73076: LD_VAR 0 6
73080: PPUSH
73081: CALL_OW 264
73085: PUSH
73086: LD_INT 6
73088: PUSH
73089: LD_INT 46
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: IN
73096: IFFALSE 73117
// points := [ 32 , 120 , 70 ] ;
73098: LD_ADDR_VAR 0 9
73102: PUSH
73103: LD_INT 32
73105: PUSH
73106: LD_INT 120
73108: PUSH
73109: LD_INT 70
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: LIST
73116: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73117: LD_VAR 0 6
73121: PPUSH
73122: CALL_OW 264
73126: PUSH
73127: LD_INT 7
73129: PUSH
73130: LD_INT 28
73132: PUSH
73133: LD_INT 45
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: LIST
73140: IN
73141: IFFALSE 73162
// points := [ 35 , 20 , 45 ] ;
73143: LD_ADDR_VAR 0 9
73147: PUSH
73148: LD_INT 35
73150: PUSH
73151: LD_INT 20
73153: PUSH
73154: LD_INT 45
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: LIST
73161: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73162: LD_VAR 0 6
73166: PPUSH
73167: CALL_OW 264
73171: PUSH
73172: LD_INT 47
73174: PUSH
73175: EMPTY
73176: LIST
73177: IN
73178: IFFALSE 73199
// points := [ 67 , 45 , 75 ] ;
73180: LD_ADDR_VAR 0 9
73184: PUSH
73185: LD_INT 67
73187: PUSH
73188: LD_INT 45
73190: PUSH
73191: LD_INT 75
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: LIST
73198: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73199: LD_VAR 0 6
73203: PPUSH
73204: CALL_OW 264
73208: PUSH
73209: LD_INT 26
73211: PUSH
73212: EMPTY
73213: LIST
73214: IN
73215: IFFALSE 73236
// points := [ 120 , 30 , 80 ] ;
73217: LD_ADDR_VAR 0 9
73221: PUSH
73222: LD_INT 120
73224: PUSH
73225: LD_INT 30
73227: PUSH
73228: LD_INT 80
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: LIST
73235: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73236: LD_VAR 0 6
73240: PPUSH
73241: CALL_OW 264
73245: PUSH
73246: LD_INT 22
73248: PUSH
73249: EMPTY
73250: LIST
73251: IN
73252: IFFALSE 73273
// points := [ 40 , 1 , 1 ] ;
73254: LD_ADDR_VAR 0 9
73258: PUSH
73259: LD_INT 40
73261: PUSH
73262: LD_INT 1
73264: PUSH
73265: LD_INT 1
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: LIST
73272: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73273: LD_VAR 0 6
73277: PPUSH
73278: CALL_OW 264
73282: PUSH
73283: LD_INT 29
73285: PUSH
73286: EMPTY
73287: LIST
73288: IN
73289: IFFALSE 73310
// points := [ 70 , 200 , 400 ] ;
73291: LD_ADDR_VAR 0 9
73295: PUSH
73296: LD_INT 70
73298: PUSH
73299: LD_INT 200
73301: PUSH
73302: LD_INT 400
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: LIST
73309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73310: LD_VAR 0 6
73314: PPUSH
73315: CALL_OW 264
73319: PUSH
73320: LD_INT 14
73322: PUSH
73323: LD_INT 53
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: IN
73330: IFFALSE 73351
// points := [ 40 , 10 , 20 ] ;
73332: LD_ADDR_VAR 0 9
73336: PUSH
73337: LD_INT 40
73339: PUSH
73340: LD_INT 10
73342: PUSH
73343: LD_INT 20
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: LIST
73350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73351: LD_VAR 0 6
73355: PPUSH
73356: CALL_OW 264
73360: PUSH
73361: LD_INT 9
73363: PUSH
73364: EMPTY
73365: LIST
73366: IN
73367: IFFALSE 73388
// points := [ 5 , 70 , 20 ] ;
73369: LD_ADDR_VAR 0 9
73373: PUSH
73374: LD_INT 5
73376: PUSH
73377: LD_INT 70
73379: PUSH
73380: LD_INT 20
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: LIST
73387: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73388: LD_VAR 0 6
73392: PPUSH
73393: CALL_OW 264
73397: PUSH
73398: LD_INT 10
73400: PUSH
73401: EMPTY
73402: LIST
73403: IN
73404: IFFALSE 73425
// points := [ 35 , 110 , 70 ] ;
73406: LD_ADDR_VAR 0 9
73410: PUSH
73411: LD_INT 35
73413: PUSH
73414: LD_INT 110
73416: PUSH
73417: LD_INT 70
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: LIST
73424: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73425: LD_VAR 0 6
73429: PPUSH
73430: CALL_OW 265
73434: PUSH
73435: LD_INT 25
73437: EQUAL
73438: IFFALSE 73459
// points := [ 80 , 65 , 100 ] ;
73440: LD_ADDR_VAR 0 9
73444: PUSH
73445: LD_INT 80
73447: PUSH
73448: LD_INT 65
73450: PUSH
73451: LD_INT 100
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: LIST
73458: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73459: LD_VAR 0 6
73463: PPUSH
73464: CALL_OW 263
73468: PUSH
73469: LD_INT 1
73471: EQUAL
73472: IFFALSE 73507
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73474: LD_ADDR_VAR 0 10
73478: PUSH
73479: LD_VAR 0 10
73483: PUSH
73484: LD_VAR 0 6
73488: PPUSH
73489: CALL_OW 311
73493: PPUSH
73494: LD_INT 3
73496: PPUSH
73497: CALL_OW 259
73501: PUSH
73502: LD_INT 4
73504: MUL
73505: MUL
73506: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73507: LD_VAR 0 6
73511: PPUSH
73512: CALL_OW 263
73516: PUSH
73517: LD_INT 2
73519: EQUAL
73520: IFFALSE 73571
// begin j := IsControledBy ( i ) ;
73522: LD_ADDR_VAR 0 7
73526: PUSH
73527: LD_VAR 0 6
73531: PPUSH
73532: CALL_OW 312
73536: ST_TO_ADDR
// if j then
73537: LD_VAR 0 7
73541: IFFALSE 73571
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73543: LD_ADDR_VAR 0 10
73547: PUSH
73548: LD_VAR 0 10
73552: PUSH
73553: LD_VAR 0 7
73557: PPUSH
73558: LD_INT 3
73560: PPUSH
73561: CALL_OW 259
73565: PUSH
73566: LD_INT 3
73568: MUL
73569: MUL
73570: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73571: LD_VAR 0 6
73575: PPUSH
73576: CALL_OW 264
73580: PUSH
73581: LD_INT 5
73583: PUSH
73584: LD_INT 6
73586: PUSH
73587: LD_INT 46
73589: PUSH
73590: LD_INT 44
73592: PUSH
73593: LD_INT 47
73595: PUSH
73596: LD_INT 45
73598: PUSH
73599: LD_INT 28
73601: PUSH
73602: LD_INT 7
73604: PUSH
73605: LD_INT 27
73607: PUSH
73608: LD_INT 29
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: IN
73623: PUSH
73624: LD_VAR 0 1
73628: PPUSH
73629: LD_INT 52
73631: PPUSH
73632: CALL_OW 321
73636: PUSH
73637: LD_INT 2
73639: EQUAL
73640: AND
73641: IFFALSE 73658
// bpoints := bpoints * 1.2 ;
73643: LD_ADDR_VAR 0 10
73647: PUSH
73648: LD_VAR 0 10
73652: PUSH
73653: LD_REAL  1.20000000000000E+0000
73656: MUL
73657: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73658: LD_VAR 0 6
73662: PPUSH
73663: CALL_OW 264
73667: PUSH
73668: LD_INT 6
73670: PUSH
73671: LD_INT 46
73673: PUSH
73674: LD_INT 47
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: LIST
73681: IN
73682: IFFALSE 73699
// bpoints := bpoints * 1.2 ;
73684: LD_ADDR_VAR 0 10
73688: PUSH
73689: LD_VAR 0 10
73693: PUSH
73694: LD_REAL  1.20000000000000E+0000
73697: MUL
73698: ST_TO_ADDR
// end ; unit_building :
73699: GO 73713
73701: LD_INT 3
73703: DOUBLE
73704: EQUAL
73705: IFTRUE 73709
73707: GO 73712
73709: POP
// ; end ;
73710: GO 73713
73712: POP
// for j = 1 to 3 do
73713: LD_ADDR_VAR 0 7
73717: PUSH
73718: DOUBLE
73719: LD_INT 1
73721: DEC
73722: ST_TO_ADDR
73723: LD_INT 3
73725: PUSH
73726: FOR_TO
73727: IFFALSE 73780
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73729: LD_ADDR_VAR 0 5
73733: PUSH
73734: LD_VAR 0 5
73738: PPUSH
73739: LD_VAR 0 7
73743: PPUSH
73744: LD_VAR 0 5
73748: PUSH
73749: LD_VAR 0 7
73753: ARRAY
73754: PUSH
73755: LD_VAR 0 9
73759: PUSH
73760: LD_VAR 0 7
73764: ARRAY
73765: PUSH
73766: LD_VAR 0 10
73770: MUL
73771: PLUS
73772: PPUSH
73773: CALL_OW 1
73777: ST_TO_ADDR
73778: GO 73726
73780: POP
73781: POP
// end ;
73782: GO 72265
73784: POP
73785: POP
// result := Replace ( result , 4 , tmp ) ;
73786: LD_ADDR_VAR 0 5
73790: PUSH
73791: LD_VAR 0 5
73795: PPUSH
73796: LD_INT 4
73798: PPUSH
73799: LD_VAR 0 8
73803: PPUSH
73804: CALL_OW 1
73808: ST_TO_ADDR
// end ;
73809: LD_VAR 0 5
73813: RET
// export function DangerAtRange ( unit , range ) ; begin
73814: LD_INT 0
73816: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73817: LD_ADDR_VAR 0 3
73821: PUSH
73822: LD_VAR 0 1
73826: PPUSH
73827: CALL_OW 255
73831: PPUSH
73832: LD_VAR 0 1
73836: PPUSH
73837: CALL_OW 250
73841: PPUSH
73842: LD_VAR 0 1
73846: PPUSH
73847: CALL_OW 251
73851: PPUSH
73852: LD_VAR 0 2
73856: PPUSH
73857: CALL 72117 0 4
73861: ST_TO_ADDR
// end ;
73862: LD_VAR 0 3
73866: RET
// export function DangerInArea ( side , area ) ; begin
73867: LD_INT 0
73869: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73870: LD_ADDR_VAR 0 3
73874: PUSH
73875: LD_VAR 0 2
73879: PPUSH
73880: LD_INT 81
73882: PUSH
73883: LD_VAR 0 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PPUSH
73892: CALL_OW 70
73896: ST_TO_ADDR
// end ;
73897: LD_VAR 0 3
73901: RET
// export function IsExtension ( b ) ; begin
73902: LD_INT 0
73904: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73905: LD_ADDR_VAR 0 2
73909: PUSH
73910: LD_VAR 0 1
73914: PUSH
73915: LD_INT 23
73917: PUSH
73918: LD_INT 20
73920: PUSH
73921: LD_INT 22
73923: PUSH
73924: LD_INT 17
73926: PUSH
73927: LD_INT 24
73929: PUSH
73930: LD_INT 21
73932: PUSH
73933: LD_INT 19
73935: PUSH
73936: LD_INT 16
73938: PUSH
73939: LD_INT 25
73941: PUSH
73942: LD_INT 18
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: IN
73957: ST_TO_ADDR
// end ;
73958: LD_VAR 0 2
73962: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73963: LD_INT 0
73965: PPUSH
73966: PPUSH
73967: PPUSH
// result := [ ] ;
73968: LD_ADDR_VAR 0 3
73972: PUSH
73973: EMPTY
73974: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73975: LD_ADDR_VAR 0 4
73979: PUSH
73980: LD_VAR 0 2
73984: PPUSH
73985: LD_INT 21
73987: PUSH
73988: LD_INT 3
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PPUSH
73995: CALL_OW 70
73999: ST_TO_ADDR
// if not tmp then
74000: LD_VAR 0 4
74004: NOT
74005: IFFALSE 74009
// exit ;
74007: GO 74067
// for i in tmp do
74009: LD_ADDR_VAR 0 5
74013: PUSH
74014: LD_VAR 0 4
74018: PUSH
74019: FOR_IN
74020: IFFALSE 74055
// if GetBase ( i ) <> base then
74022: LD_VAR 0 5
74026: PPUSH
74027: CALL_OW 274
74031: PUSH
74032: LD_VAR 0 1
74036: NONEQUAL
74037: IFFALSE 74053
// ComLinkToBase ( base , i ) ;
74039: LD_VAR 0 1
74043: PPUSH
74044: LD_VAR 0 5
74048: PPUSH
74049: CALL_OW 169
74053: GO 74019
74055: POP
74056: POP
// result := tmp ;
74057: LD_ADDR_VAR 0 3
74061: PUSH
74062: LD_VAR 0 4
74066: ST_TO_ADDR
// end ;
74067: LD_VAR 0 3
74071: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74072: LD_INT 0
74074: PPUSH
74075: PPUSH
// if BuildingStatus ( b ) = bs_build then
74076: LD_VAR 0 2
74080: PPUSH
74081: CALL_OW 461
74085: PUSH
74086: LD_INT 1
74088: EQUAL
74089: IFFALSE 74149
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74091: LD_VAR 0 1
74095: PPUSH
74096: LD_STRING h
74098: PUSH
74099: LD_VAR 0 2
74103: PPUSH
74104: CALL_OW 250
74108: PUSH
74109: LD_VAR 0 2
74113: PPUSH
74114: CALL_OW 251
74118: PUSH
74119: LD_VAR 0 2
74123: PUSH
74124: LD_INT 0
74126: PUSH
74127: LD_INT 0
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: PUSH
74142: EMPTY
74143: LIST
74144: PPUSH
74145: CALL_OW 446
// end ;
74149: LD_VAR 0 3
74153: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74154: LD_INT 0
74156: PPUSH
74157: PPUSH
74158: PPUSH
74159: PPUSH
74160: PPUSH
74161: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74162: LD_VAR 0 1
74166: NOT
74167: PUSH
74168: LD_VAR 0 1
74172: PPUSH
74173: CALL_OW 263
74177: PUSH
74178: LD_INT 2
74180: EQUAL
74181: NOT
74182: OR
74183: IFFALSE 74187
// exit ;
74185: GO 74503
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74187: LD_ADDR_VAR 0 6
74191: PUSH
74192: LD_INT 22
74194: PUSH
74195: LD_VAR 0 1
74199: PPUSH
74200: CALL_OW 255
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: LD_INT 2
74211: PUSH
74212: LD_INT 30
74214: PUSH
74215: LD_INT 36
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 34
74224: PUSH
74225: LD_INT 31
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: LIST
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PPUSH
74241: CALL_OW 69
74245: ST_TO_ADDR
// if not tmp then
74246: LD_VAR 0 6
74250: NOT
74251: IFFALSE 74255
// exit ;
74253: GO 74503
// result := [ ] ;
74255: LD_ADDR_VAR 0 2
74259: PUSH
74260: EMPTY
74261: ST_TO_ADDR
// for i in tmp do
74262: LD_ADDR_VAR 0 3
74266: PUSH
74267: LD_VAR 0 6
74271: PUSH
74272: FOR_IN
74273: IFFALSE 74344
// begin t := UnitsInside ( i ) ;
74275: LD_ADDR_VAR 0 4
74279: PUSH
74280: LD_VAR 0 3
74284: PPUSH
74285: CALL_OW 313
74289: ST_TO_ADDR
// if t then
74290: LD_VAR 0 4
74294: IFFALSE 74342
// for j in t do
74296: LD_ADDR_VAR 0 7
74300: PUSH
74301: LD_VAR 0 4
74305: PUSH
74306: FOR_IN
74307: IFFALSE 74340
// result := Insert ( result , result + 1 , j ) ;
74309: LD_ADDR_VAR 0 2
74313: PUSH
74314: LD_VAR 0 2
74318: PPUSH
74319: LD_VAR 0 2
74323: PUSH
74324: LD_INT 1
74326: PLUS
74327: PPUSH
74328: LD_VAR 0 7
74332: PPUSH
74333: CALL_OW 2
74337: ST_TO_ADDR
74338: GO 74306
74340: POP
74341: POP
// end ;
74342: GO 74272
74344: POP
74345: POP
// if not result then
74346: LD_VAR 0 2
74350: NOT
74351: IFFALSE 74355
// exit ;
74353: GO 74503
// mech := result [ 1 ] ;
74355: LD_ADDR_VAR 0 5
74359: PUSH
74360: LD_VAR 0 2
74364: PUSH
74365: LD_INT 1
74367: ARRAY
74368: ST_TO_ADDR
// if result > 1 then
74369: LD_VAR 0 2
74373: PUSH
74374: LD_INT 1
74376: GREATER
74377: IFFALSE 74489
// for i = 2 to result do
74379: LD_ADDR_VAR 0 3
74383: PUSH
74384: DOUBLE
74385: LD_INT 2
74387: DEC
74388: ST_TO_ADDR
74389: LD_VAR 0 2
74393: PUSH
74394: FOR_TO
74395: IFFALSE 74487
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74397: LD_ADDR_VAR 0 4
74401: PUSH
74402: LD_VAR 0 2
74406: PUSH
74407: LD_VAR 0 3
74411: ARRAY
74412: PPUSH
74413: LD_INT 3
74415: PPUSH
74416: CALL_OW 259
74420: PUSH
74421: LD_VAR 0 2
74425: PUSH
74426: LD_VAR 0 3
74430: ARRAY
74431: PPUSH
74432: CALL_OW 432
74436: MINUS
74437: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74438: LD_VAR 0 4
74442: PUSH
74443: LD_VAR 0 5
74447: PPUSH
74448: LD_INT 3
74450: PPUSH
74451: CALL_OW 259
74455: PUSH
74456: LD_VAR 0 5
74460: PPUSH
74461: CALL_OW 432
74465: MINUS
74466: GREATEREQUAL
74467: IFFALSE 74485
// mech := result [ i ] ;
74469: LD_ADDR_VAR 0 5
74473: PUSH
74474: LD_VAR 0 2
74478: PUSH
74479: LD_VAR 0 3
74483: ARRAY
74484: ST_TO_ADDR
// end ;
74485: GO 74394
74487: POP
74488: POP
// ComLinkTo ( vehicle , mech ) ;
74489: LD_VAR 0 1
74493: PPUSH
74494: LD_VAR 0 5
74498: PPUSH
74499: CALL_OW 135
// end ;
74503: LD_VAR 0 2
74507: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74508: LD_INT 0
74510: PPUSH
74511: PPUSH
74512: PPUSH
74513: PPUSH
74514: PPUSH
74515: PPUSH
74516: PPUSH
74517: PPUSH
74518: PPUSH
74519: PPUSH
74520: PPUSH
74521: PPUSH
74522: PPUSH
// result := [ ] ;
74523: LD_ADDR_VAR 0 7
74527: PUSH
74528: EMPTY
74529: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74530: LD_VAR 0 1
74534: PPUSH
74535: CALL_OW 266
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: LD_INT 1
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: IN
74550: NOT
74551: IFFALSE 74555
// exit ;
74553: GO 76186
// if name then
74555: LD_VAR 0 3
74559: IFFALSE 74575
// SetBName ( base_dep , name ) ;
74561: LD_VAR 0 1
74565: PPUSH
74566: LD_VAR 0 3
74570: PPUSH
74571: CALL_OW 500
// base := GetBase ( base_dep ) ;
74575: LD_ADDR_VAR 0 15
74579: PUSH
74580: LD_VAR 0 1
74584: PPUSH
74585: CALL_OW 274
74589: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74590: LD_ADDR_VAR 0 16
74594: PUSH
74595: LD_VAR 0 1
74599: PPUSH
74600: CALL_OW 255
74604: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74605: LD_ADDR_VAR 0 17
74609: PUSH
74610: LD_VAR 0 1
74614: PPUSH
74615: CALL_OW 248
74619: ST_TO_ADDR
// if sources then
74620: LD_VAR 0 5
74624: IFFALSE 74671
// for i = 1 to 3 do
74626: LD_ADDR_VAR 0 8
74630: PUSH
74631: DOUBLE
74632: LD_INT 1
74634: DEC
74635: ST_TO_ADDR
74636: LD_INT 3
74638: PUSH
74639: FOR_TO
74640: IFFALSE 74669
// AddResourceType ( base , i , sources [ i ] ) ;
74642: LD_VAR 0 15
74646: PPUSH
74647: LD_VAR 0 8
74651: PPUSH
74652: LD_VAR 0 5
74656: PUSH
74657: LD_VAR 0 8
74661: ARRAY
74662: PPUSH
74663: CALL_OW 276
74667: GO 74639
74669: POP
74670: POP
// buildings := GetBaseBuildings ( base , area ) ;
74671: LD_ADDR_VAR 0 18
74675: PUSH
74676: LD_VAR 0 15
74680: PPUSH
74681: LD_VAR 0 2
74685: PPUSH
74686: CALL 73963 0 2
74690: ST_TO_ADDR
// InitHc ;
74691: CALL_OW 19
// InitUc ;
74695: CALL_OW 18
// uc_side := side ;
74699: LD_ADDR_OWVAR 20
74703: PUSH
74704: LD_VAR 0 16
74708: ST_TO_ADDR
// uc_nation := nation ;
74709: LD_ADDR_OWVAR 21
74713: PUSH
74714: LD_VAR 0 17
74718: ST_TO_ADDR
// if buildings then
74719: LD_VAR 0 18
74723: IFFALSE 76045
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74725: LD_ADDR_VAR 0 19
74729: PUSH
74730: LD_VAR 0 18
74734: PPUSH
74735: LD_INT 2
74737: PUSH
74738: LD_INT 30
74740: PUSH
74741: LD_INT 29
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 30
74750: PUSH
74751: LD_INT 30
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: LIST
74762: PPUSH
74763: CALL_OW 72
74767: ST_TO_ADDR
// if tmp then
74768: LD_VAR 0 19
74772: IFFALSE 74820
// for i in tmp do
74774: LD_ADDR_VAR 0 8
74778: PUSH
74779: LD_VAR 0 19
74783: PUSH
74784: FOR_IN
74785: IFFALSE 74818
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74787: LD_VAR 0 8
74791: PPUSH
74792: CALL_OW 250
74796: PPUSH
74797: LD_VAR 0 8
74801: PPUSH
74802: CALL_OW 251
74806: PPUSH
74807: LD_VAR 0 16
74811: PPUSH
74812: CALL_OW 441
74816: GO 74784
74818: POP
74819: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74820: LD_VAR 0 18
74824: PPUSH
74825: LD_INT 2
74827: PUSH
74828: LD_INT 30
74830: PUSH
74831: LD_INT 32
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 30
74840: PUSH
74841: LD_INT 33
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: LIST
74852: PPUSH
74853: CALL_OW 72
74857: IFFALSE 74945
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74859: LD_ADDR_VAR 0 8
74863: PUSH
74864: LD_VAR 0 18
74868: PPUSH
74869: LD_INT 2
74871: PUSH
74872: LD_INT 30
74874: PUSH
74875: LD_INT 32
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 30
74884: PUSH
74885: LD_INT 33
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: LIST
74896: PPUSH
74897: CALL_OW 72
74901: PUSH
74902: FOR_IN
74903: IFFALSE 74943
// begin if not GetBWeapon ( i ) then
74905: LD_VAR 0 8
74909: PPUSH
74910: CALL_OW 269
74914: NOT
74915: IFFALSE 74941
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74917: LD_VAR 0 8
74921: PPUSH
74922: LD_VAR 0 8
74926: PPUSH
74927: LD_VAR 0 2
74931: PPUSH
74932: CALL 76191 0 2
74936: PPUSH
74937: CALL_OW 431
// end ;
74941: GO 74902
74943: POP
74944: POP
// end ; for i = 1 to personel do
74945: LD_ADDR_VAR 0 8
74949: PUSH
74950: DOUBLE
74951: LD_INT 1
74953: DEC
74954: ST_TO_ADDR
74955: LD_VAR 0 6
74959: PUSH
74960: FOR_TO
74961: IFFALSE 76025
// begin if i > 4 then
74963: LD_VAR 0 8
74967: PUSH
74968: LD_INT 4
74970: GREATER
74971: IFFALSE 74975
// break ;
74973: GO 76025
// case i of 1 :
74975: LD_VAR 0 8
74979: PUSH
74980: LD_INT 1
74982: DOUBLE
74983: EQUAL
74984: IFTRUE 74988
74986: GO 75068
74988: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74989: LD_ADDR_VAR 0 12
74993: PUSH
74994: LD_VAR 0 18
74998: PPUSH
74999: LD_INT 22
75001: PUSH
75002: LD_VAR 0 16
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 58
75013: PUSH
75014: EMPTY
75015: LIST
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: LD_INT 30
75022: PUSH
75023: LD_INT 32
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 30
75032: PUSH
75033: LD_INT 4
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 30
75042: PUSH
75043: LD_INT 5
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: LIST
75054: LIST
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: LIST
75060: PPUSH
75061: CALL_OW 72
75065: ST_TO_ADDR
75066: GO 75290
75068: LD_INT 2
75070: DOUBLE
75071: EQUAL
75072: IFTRUE 75076
75074: GO 75138
75076: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75077: LD_ADDR_VAR 0 12
75081: PUSH
75082: LD_VAR 0 18
75086: PPUSH
75087: LD_INT 22
75089: PUSH
75090: LD_VAR 0 16
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: LD_INT 2
75101: PUSH
75102: LD_INT 30
75104: PUSH
75105: LD_INT 0
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 30
75114: PUSH
75115: LD_INT 1
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: LIST
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PPUSH
75131: CALL_OW 72
75135: ST_TO_ADDR
75136: GO 75290
75138: LD_INT 3
75140: DOUBLE
75141: EQUAL
75142: IFTRUE 75146
75144: GO 75208
75146: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75147: LD_ADDR_VAR 0 12
75151: PUSH
75152: LD_VAR 0 18
75156: PPUSH
75157: LD_INT 22
75159: PUSH
75160: LD_VAR 0 16
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 2
75171: PUSH
75172: LD_INT 30
75174: PUSH
75175: LD_INT 2
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 30
75184: PUSH
75185: LD_INT 3
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: LIST
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PPUSH
75201: CALL_OW 72
75205: ST_TO_ADDR
75206: GO 75290
75208: LD_INT 4
75210: DOUBLE
75211: EQUAL
75212: IFTRUE 75216
75214: GO 75289
75216: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75217: LD_ADDR_VAR 0 12
75221: PUSH
75222: LD_VAR 0 18
75226: PPUSH
75227: LD_INT 22
75229: PUSH
75230: LD_VAR 0 16
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 2
75241: PUSH
75242: LD_INT 30
75244: PUSH
75245: LD_INT 6
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 30
75254: PUSH
75255: LD_INT 7
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: LD_INT 30
75264: PUSH
75265: LD_INT 8
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PPUSH
75282: CALL_OW 72
75286: ST_TO_ADDR
75287: GO 75290
75289: POP
// if i = 1 then
75290: LD_VAR 0 8
75294: PUSH
75295: LD_INT 1
75297: EQUAL
75298: IFFALSE 75409
// begin tmp := [ ] ;
75300: LD_ADDR_VAR 0 19
75304: PUSH
75305: EMPTY
75306: ST_TO_ADDR
// for j in f do
75307: LD_ADDR_VAR 0 9
75311: PUSH
75312: LD_VAR 0 12
75316: PUSH
75317: FOR_IN
75318: IFFALSE 75391
// if GetBType ( j ) = b_bunker then
75320: LD_VAR 0 9
75324: PPUSH
75325: CALL_OW 266
75329: PUSH
75330: LD_INT 32
75332: EQUAL
75333: IFFALSE 75360
// tmp := Insert ( tmp , 1 , j ) else
75335: LD_ADDR_VAR 0 19
75339: PUSH
75340: LD_VAR 0 19
75344: PPUSH
75345: LD_INT 1
75347: PPUSH
75348: LD_VAR 0 9
75352: PPUSH
75353: CALL_OW 2
75357: ST_TO_ADDR
75358: GO 75389
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75360: LD_ADDR_VAR 0 19
75364: PUSH
75365: LD_VAR 0 19
75369: PPUSH
75370: LD_VAR 0 19
75374: PUSH
75375: LD_INT 1
75377: PLUS
75378: PPUSH
75379: LD_VAR 0 9
75383: PPUSH
75384: CALL_OW 2
75388: ST_TO_ADDR
75389: GO 75317
75391: POP
75392: POP
// if tmp then
75393: LD_VAR 0 19
75397: IFFALSE 75409
// f := tmp ;
75399: LD_ADDR_VAR 0 12
75403: PUSH
75404: LD_VAR 0 19
75408: ST_TO_ADDR
// end ; x := personel [ i ] ;
75409: LD_ADDR_VAR 0 13
75413: PUSH
75414: LD_VAR 0 6
75418: PUSH
75419: LD_VAR 0 8
75423: ARRAY
75424: ST_TO_ADDR
// if x = - 1 then
75425: LD_VAR 0 13
75429: PUSH
75430: LD_INT 1
75432: NEG
75433: EQUAL
75434: IFFALSE 75643
// begin for j in f do
75436: LD_ADDR_VAR 0 9
75440: PUSH
75441: LD_VAR 0 12
75445: PUSH
75446: FOR_IN
75447: IFFALSE 75639
// repeat InitHc ;
75449: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75453: LD_VAR 0 9
75457: PPUSH
75458: CALL_OW 266
75462: PUSH
75463: LD_INT 5
75465: EQUAL
75466: IFFALSE 75536
// begin if UnitsInside ( j ) < 3 then
75468: LD_VAR 0 9
75472: PPUSH
75473: CALL_OW 313
75477: PUSH
75478: LD_INT 3
75480: LESS
75481: IFFALSE 75517
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75483: LD_INT 0
75485: PPUSH
75486: LD_INT 5
75488: PUSH
75489: LD_INT 8
75491: PUSH
75492: LD_INT 9
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: LIST
75499: PUSH
75500: LD_VAR 0 17
75504: ARRAY
75505: PPUSH
75506: LD_VAR 0 4
75510: PPUSH
75511: CALL_OW 380
75515: GO 75534
// PrepareHuman ( false , i , skill ) ;
75517: LD_INT 0
75519: PPUSH
75520: LD_VAR 0 8
75524: PPUSH
75525: LD_VAR 0 4
75529: PPUSH
75530: CALL_OW 380
// end else
75534: GO 75553
// PrepareHuman ( false , i , skill ) ;
75536: LD_INT 0
75538: PPUSH
75539: LD_VAR 0 8
75543: PPUSH
75544: LD_VAR 0 4
75548: PPUSH
75549: CALL_OW 380
// un := CreateHuman ;
75553: LD_ADDR_VAR 0 14
75557: PUSH
75558: CALL_OW 44
75562: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75563: LD_ADDR_VAR 0 7
75567: PUSH
75568: LD_VAR 0 7
75572: PPUSH
75573: LD_INT 1
75575: PPUSH
75576: LD_VAR 0 14
75580: PPUSH
75581: CALL_OW 2
75585: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75586: LD_VAR 0 14
75590: PPUSH
75591: LD_VAR 0 9
75595: PPUSH
75596: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75600: LD_VAR 0 9
75604: PPUSH
75605: CALL_OW 313
75609: PUSH
75610: LD_INT 6
75612: EQUAL
75613: PUSH
75614: LD_VAR 0 9
75618: PPUSH
75619: CALL_OW 266
75623: PUSH
75624: LD_INT 32
75626: PUSH
75627: LD_INT 31
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: IN
75634: OR
75635: IFFALSE 75449
75637: GO 75446
75639: POP
75640: POP
// end else
75641: GO 76023
// for j = 1 to x do
75643: LD_ADDR_VAR 0 9
75647: PUSH
75648: DOUBLE
75649: LD_INT 1
75651: DEC
75652: ST_TO_ADDR
75653: LD_VAR 0 13
75657: PUSH
75658: FOR_TO
75659: IFFALSE 76021
// begin InitHc ;
75661: CALL_OW 19
// if not f then
75665: LD_VAR 0 12
75669: NOT
75670: IFFALSE 75759
// begin PrepareHuman ( false , i , skill ) ;
75672: LD_INT 0
75674: PPUSH
75675: LD_VAR 0 8
75679: PPUSH
75680: LD_VAR 0 4
75684: PPUSH
75685: CALL_OW 380
// un := CreateHuman ;
75689: LD_ADDR_VAR 0 14
75693: PUSH
75694: CALL_OW 44
75698: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75699: LD_ADDR_VAR 0 7
75703: PUSH
75704: LD_VAR 0 7
75708: PPUSH
75709: LD_INT 1
75711: PPUSH
75712: LD_VAR 0 14
75716: PPUSH
75717: CALL_OW 2
75721: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75722: LD_VAR 0 14
75726: PPUSH
75727: LD_VAR 0 1
75731: PPUSH
75732: CALL_OW 250
75736: PPUSH
75737: LD_VAR 0 1
75741: PPUSH
75742: CALL_OW 251
75746: PPUSH
75747: LD_INT 10
75749: PPUSH
75750: LD_INT 0
75752: PPUSH
75753: CALL_OW 50
// continue ;
75757: GO 75658
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75759: LD_VAR 0 12
75763: PUSH
75764: LD_INT 1
75766: ARRAY
75767: PPUSH
75768: CALL_OW 313
75772: PUSH
75773: LD_VAR 0 12
75777: PUSH
75778: LD_INT 1
75780: ARRAY
75781: PPUSH
75782: CALL_OW 266
75786: PUSH
75787: LD_INT 32
75789: PUSH
75790: LD_INT 31
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: IN
75797: AND
75798: PUSH
75799: LD_VAR 0 12
75803: PUSH
75804: LD_INT 1
75806: ARRAY
75807: PPUSH
75808: CALL_OW 313
75812: PUSH
75813: LD_INT 6
75815: EQUAL
75816: OR
75817: IFFALSE 75837
// f := Delete ( f , 1 ) ;
75819: LD_ADDR_VAR 0 12
75823: PUSH
75824: LD_VAR 0 12
75828: PPUSH
75829: LD_INT 1
75831: PPUSH
75832: CALL_OW 3
75836: ST_TO_ADDR
// if not f then
75837: LD_VAR 0 12
75841: NOT
75842: IFFALSE 75860
// begin x := x + 2 ;
75844: LD_ADDR_VAR 0 13
75848: PUSH
75849: LD_VAR 0 13
75853: PUSH
75854: LD_INT 2
75856: PLUS
75857: ST_TO_ADDR
// continue ;
75858: GO 75658
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75860: LD_VAR 0 12
75864: PUSH
75865: LD_INT 1
75867: ARRAY
75868: PPUSH
75869: CALL_OW 266
75873: PUSH
75874: LD_INT 5
75876: EQUAL
75877: IFFALSE 75951
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75879: LD_VAR 0 12
75883: PUSH
75884: LD_INT 1
75886: ARRAY
75887: PPUSH
75888: CALL_OW 313
75892: PUSH
75893: LD_INT 3
75895: LESS
75896: IFFALSE 75932
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75898: LD_INT 0
75900: PPUSH
75901: LD_INT 5
75903: PUSH
75904: LD_INT 8
75906: PUSH
75907: LD_INT 9
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: LIST
75914: PUSH
75915: LD_VAR 0 17
75919: ARRAY
75920: PPUSH
75921: LD_VAR 0 4
75925: PPUSH
75926: CALL_OW 380
75930: GO 75949
// PrepareHuman ( false , i , skill ) ;
75932: LD_INT 0
75934: PPUSH
75935: LD_VAR 0 8
75939: PPUSH
75940: LD_VAR 0 4
75944: PPUSH
75945: CALL_OW 380
// end else
75949: GO 75968
// PrepareHuman ( false , i , skill ) ;
75951: LD_INT 0
75953: PPUSH
75954: LD_VAR 0 8
75958: PPUSH
75959: LD_VAR 0 4
75963: PPUSH
75964: CALL_OW 380
// un := CreateHuman ;
75968: LD_ADDR_VAR 0 14
75972: PUSH
75973: CALL_OW 44
75977: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75978: LD_ADDR_VAR 0 7
75982: PUSH
75983: LD_VAR 0 7
75987: PPUSH
75988: LD_INT 1
75990: PPUSH
75991: LD_VAR 0 14
75995: PPUSH
75996: CALL_OW 2
76000: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76001: LD_VAR 0 14
76005: PPUSH
76006: LD_VAR 0 12
76010: PUSH
76011: LD_INT 1
76013: ARRAY
76014: PPUSH
76015: CALL_OW 52
// end ;
76019: GO 75658
76021: POP
76022: POP
// end ;
76023: GO 74960
76025: POP
76026: POP
// result := result ^ buildings ;
76027: LD_ADDR_VAR 0 7
76031: PUSH
76032: LD_VAR 0 7
76036: PUSH
76037: LD_VAR 0 18
76041: ADD
76042: ST_TO_ADDR
// end else
76043: GO 76186
// begin for i = 1 to personel do
76045: LD_ADDR_VAR 0 8
76049: PUSH
76050: DOUBLE
76051: LD_INT 1
76053: DEC
76054: ST_TO_ADDR
76055: LD_VAR 0 6
76059: PUSH
76060: FOR_TO
76061: IFFALSE 76184
// begin if i > 4 then
76063: LD_VAR 0 8
76067: PUSH
76068: LD_INT 4
76070: GREATER
76071: IFFALSE 76075
// break ;
76073: GO 76184
// x := personel [ i ] ;
76075: LD_ADDR_VAR 0 13
76079: PUSH
76080: LD_VAR 0 6
76084: PUSH
76085: LD_VAR 0 8
76089: ARRAY
76090: ST_TO_ADDR
// if x = - 1 then
76091: LD_VAR 0 13
76095: PUSH
76096: LD_INT 1
76098: NEG
76099: EQUAL
76100: IFFALSE 76104
// continue ;
76102: GO 76060
// PrepareHuman ( false , i , skill ) ;
76104: LD_INT 0
76106: PPUSH
76107: LD_VAR 0 8
76111: PPUSH
76112: LD_VAR 0 4
76116: PPUSH
76117: CALL_OW 380
// un := CreateHuman ;
76121: LD_ADDR_VAR 0 14
76125: PUSH
76126: CALL_OW 44
76130: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76131: LD_VAR 0 14
76135: PPUSH
76136: LD_VAR 0 1
76140: PPUSH
76141: CALL_OW 250
76145: PPUSH
76146: LD_VAR 0 1
76150: PPUSH
76151: CALL_OW 251
76155: PPUSH
76156: LD_INT 10
76158: PPUSH
76159: LD_INT 0
76161: PPUSH
76162: CALL_OW 50
// result := result ^ un ;
76166: LD_ADDR_VAR 0 7
76170: PUSH
76171: LD_VAR 0 7
76175: PUSH
76176: LD_VAR 0 14
76180: ADD
76181: ST_TO_ADDR
// end ;
76182: GO 76060
76184: POP
76185: POP
// end ; end ;
76186: LD_VAR 0 7
76190: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76191: LD_INT 0
76193: PPUSH
76194: PPUSH
76195: PPUSH
76196: PPUSH
76197: PPUSH
76198: PPUSH
76199: PPUSH
76200: PPUSH
76201: PPUSH
76202: PPUSH
76203: PPUSH
76204: PPUSH
76205: PPUSH
76206: PPUSH
76207: PPUSH
76208: PPUSH
// result := false ;
76209: LD_ADDR_VAR 0 3
76213: PUSH
76214: LD_INT 0
76216: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76217: LD_VAR 0 1
76221: NOT
76222: PUSH
76223: LD_VAR 0 1
76227: PPUSH
76228: CALL_OW 266
76232: PUSH
76233: LD_INT 32
76235: PUSH
76236: LD_INT 33
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: IN
76243: NOT
76244: OR
76245: IFFALSE 76249
// exit ;
76247: GO 77385
// nat := GetNation ( tower ) ;
76249: LD_ADDR_VAR 0 12
76253: PUSH
76254: LD_VAR 0 1
76258: PPUSH
76259: CALL_OW 248
76263: ST_TO_ADDR
// side := GetSide ( tower ) ;
76264: LD_ADDR_VAR 0 16
76268: PUSH
76269: LD_VAR 0 1
76273: PPUSH
76274: CALL_OW 255
76278: ST_TO_ADDR
// x := GetX ( tower ) ;
76279: LD_ADDR_VAR 0 10
76283: PUSH
76284: LD_VAR 0 1
76288: PPUSH
76289: CALL_OW 250
76293: ST_TO_ADDR
// y := GetY ( tower ) ;
76294: LD_ADDR_VAR 0 11
76298: PUSH
76299: LD_VAR 0 1
76303: PPUSH
76304: CALL_OW 251
76308: ST_TO_ADDR
// if not x or not y then
76309: LD_VAR 0 10
76313: NOT
76314: PUSH
76315: LD_VAR 0 11
76319: NOT
76320: OR
76321: IFFALSE 76325
// exit ;
76323: GO 77385
// weapon := 0 ;
76325: LD_ADDR_VAR 0 18
76329: PUSH
76330: LD_INT 0
76332: ST_TO_ADDR
// fac_list := [ ] ;
76333: LD_ADDR_VAR 0 17
76337: PUSH
76338: EMPTY
76339: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76340: LD_ADDR_VAR 0 6
76344: PUSH
76345: LD_VAR 0 1
76349: PPUSH
76350: CALL_OW 274
76354: PPUSH
76355: LD_VAR 0 2
76359: PPUSH
76360: CALL 73963 0 2
76364: PPUSH
76365: LD_INT 30
76367: PUSH
76368: LD_INT 3
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PPUSH
76375: CALL_OW 72
76379: ST_TO_ADDR
// if not factories then
76380: LD_VAR 0 6
76384: NOT
76385: IFFALSE 76389
// exit ;
76387: GO 77385
// for i in factories do
76389: LD_ADDR_VAR 0 8
76393: PUSH
76394: LD_VAR 0 6
76398: PUSH
76399: FOR_IN
76400: IFFALSE 76425
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76402: LD_ADDR_VAR 0 17
76406: PUSH
76407: LD_VAR 0 17
76411: PUSH
76412: LD_VAR 0 8
76416: PPUSH
76417: CALL_OW 478
76421: UNION
76422: ST_TO_ADDR
76423: GO 76399
76425: POP
76426: POP
// if not fac_list then
76427: LD_VAR 0 17
76431: NOT
76432: IFFALSE 76436
// exit ;
76434: GO 77385
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76436: LD_ADDR_VAR 0 5
76440: PUSH
76441: LD_INT 4
76443: PUSH
76444: LD_INT 5
76446: PUSH
76447: LD_INT 9
76449: PUSH
76450: LD_INT 10
76452: PUSH
76453: LD_INT 6
76455: PUSH
76456: LD_INT 7
76458: PUSH
76459: LD_INT 11
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 27
76473: PUSH
76474: LD_INT 28
76476: PUSH
76477: LD_INT 26
76479: PUSH
76480: LD_INT 30
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 43
76491: PUSH
76492: LD_INT 44
76494: PUSH
76495: LD_INT 46
76497: PUSH
76498: LD_INT 45
76500: PUSH
76501: LD_INT 47
76503: PUSH
76504: LD_INT 49
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: LIST
76511: LIST
76512: LIST
76513: LIST
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: LIST
76519: PUSH
76520: LD_VAR 0 12
76524: ARRAY
76525: ST_TO_ADDR
// for i in list do
76526: LD_ADDR_VAR 0 8
76530: PUSH
76531: LD_VAR 0 5
76535: PUSH
76536: FOR_IN
76537: IFFALSE 76570
// if not i in fac_list then
76539: LD_VAR 0 8
76543: PUSH
76544: LD_VAR 0 17
76548: IN
76549: NOT
76550: IFFALSE 76568
// list := list diff i ;
76552: LD_ADDR_VAR 0 5
76556: PUSH
76557: LD_VAR 0 5
76561: PUSH
76562: LD_VAR 0 8
76566: DIFF
76567: ST_TO_ADDR
76568: GO 76536
76570: POP
76571: POP
// if not list then
76572: LD_VAR 0 5
76576: NOT
76577: IFFALSE 76581
// exit ;
76579: GO 77385
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76581: LD_VAR 0 12
76585: PUSH
76586: LD_INT 3
76588: EQUAL
76589: PUSH
76590: LD_INT 49
76592: PUSH
76593: LD_VAR 0 5
76597: IN
76598: AND
76599: PUSH
76600: LD_INT 31
76602: PPUSH
76603: LD_VAR 0 16
76607: PPUSH
76608: CALL_OW 321
76612: PUSH
76613: LD_INT 2
76615: EQUAL
76616: AND
76617: IFFALSE 76677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76619: LD_INT 22
76621: PUSH
76622: LD_VAR 0 16
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 35
76633: PUSH
76634: LD_INT 49
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 91
76643: PUSH
76644: LD_VAR 0 1
76648: PUSH
76649: LD_INT 10
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: LIST
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: LIST
76661: PPUSH
76662: CALL_OW 69
76666: NOT
76667: IFFALSE 76677
// weapon := ru_time_lapser ;
76669: LD_ADDR_VAR 0 18
76673: PUSH
76674: LD_INT 49
76676: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76677: LD_VAR 0 12
76681: PUSH
76682: LD_INT 1
76684: PUSH
76685: LD_INT 2
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: IN
76692: PUSH
76693: LD_INT 11
76695: PUSH
76696: LD_VAR 0 5
76700: IN
76701: PUSH
76702: LD_INT 30
76704: PUSH
76705: LD_VAR 0 5
76709: IN
76710: OR
76711: AND
76712: PUSH
76713: LD_INT 6
76715: PPUSH
76716: LD_VAR 0 16
76720: PPUSH
76721: CALL_OW 321
76725: PUSH
76726: LD_INT 2
76728: EQUAL
76729: AND
76730: IFFALSE 76895
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76732: LD_INT 22
76734: PUSH
76735: LD_VAR 0 16
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 2
76746: PUSH
76747: LD_INT 35
76749: PUSH
76750: LD_INT 11
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 35
76759: PUSH
76760: LD_INT 30
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 91
76774: PUSH
76775: LD_VAR 0 1
76779: PUSH
76780: LD_INT 18
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: LIST
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: LIST
76792: PPUSH
76793: CALL_OW 69
76797: NOT
76798: PUSH
76799: LD_INT 22
76801: PUSH
76802: LD_VAR 0 16
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 2
76813: PUSH
76814: LD_INT 30
76816: PUSH
76817: LD_INT 32
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 30
76826: PUSH
76827: LD_INT 33
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 91
76841: PUSH
76842: LD_VAR 0 1
76846: PUSH
76847: LD_INT 12
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: LIST
76859: PUSH
76860: EMPTY
76861: LIST
76862: PPUSH
76863: CALL_OW 69
76867: PUSH
76868: LD_INT 2
76870: GREATER
76871: AND
76872: IFFALSE 76895
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76874: LD_ADDR_VAR 0 18
76878: PUSH
76879: LD_INT 11
76881: PUSH
76882: LD_INT 30
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: PUSH
76889: LD_VAR 0 12
76893: ARRAY
76894: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76895: LD_VAR 0 18
76899: NOT
76900: PUSH
76901: LD_INT 40
76903: PPUSH
76904: LD_VAR 0 16
76908: PPUSH
76909: CALL_OW 321
76913: PUSH
76914: LD_INT 2
76916: EQUAL
76917: AND
76918: PUSH
76919: LD_INT 7
76921: PUSH
76922: LD_VAR 0 5
76926: IN
76927: PUSH
76928: LD_INT 28
76930: PUSH
76931: LD_VAR 0 5
76935: IN
76936: OR
76937: PUSH
76938: LD_INT 45
76940: PUSH
76941: LD_VAR 0 5
76945: IN
76946: OR
76947: AND
76948: IFFALSE 77202
// begin hex := GetHexInfo ( x , y ) ;
76950: LD_ADDR_VAR 0 4
76954: PUSH
76955: LD_VAR 0 10
76959: PPUSH
76960: LD_VAR 0 11
76964: PPUSH
76965: CALL_OW 546
76969: ST_TO_ADDR
// if hex [ 1 ] then
76970: LD_VAR 0 4
76974: PUSH
76975: LD_INT 1
76977: ARRAY
76978: IFFALSE 76982
// exit ;
76980: GO 77385
// height := hex [ 2 ] ;
76982: LD_ADDR_VAR 0 15
76986: PUSH
76987: LD_VAR 0 4
76991: PUSH
76992: LD_INT 2
76994: ARRAY
76995: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76996: LD_ADDR_VAR 0 14
77000: PUSH
77001: LD_INT 0
77003: PUSH
77004: LD_INT 2
77006: PUSH
77007: LD_INT 3
77009: PUSH
77010: LD_INT 5
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: LIST
77017: LIST
77018: ST_TO_ADDR
// for i in tmp do
77019: LD_ADDR_VAR 0 8
77023: PUSH
77024: LD_VAR 0 14
77028: PUSH
77029: FOR_IN
77030: IFFALSE 77200
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77032: LD_ADDR_VAR 0 9
77036: PUSH
77037: LD_VAR 0 10
77041: PPUSH
77042: LD_VAR 0 8
77046: PPUSH
77047: LD_INT 5
77049: PPUSH
77050: CALL_OW 272
77054: PUSH
77055: LD_VAR 0 11
77059: PPUSH
77060: LD_VAR 0 8
77064: PPUSH
77065: LD_INT 5
77067: PPUSH
77068: CALL_OW 273
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77077: LD_VAR 0 9
77081: PUSH
77082: LD_INT 1
77084: ARRAY
77085: PPUSH
77086: LD_VAR 0 9
77090: PUSH
77091: LD_INT 2
77093: ARRAY
77094: PPUSH
77095: CALL_OW 488
77099: IFFALSE 77198
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77101: LD_ADDR_VAR 0 4
77105: PUSH
77106: LD_VAR 0 9
77110: PUSH
77111: LD_INT 1
77113: ARRAY
77114: PPUSH
77115: LD_VAR 0 9
77119: PUSH
77120: LD_INT 2
77122: ARRAY
77123: PPUSH
77124: CALL_OW 546
77128: ST_TO_ADDR
// if hex [ 1 ] then
77129: LD_VAR 0 4
77133: PUSH
77134: LD_INT 1
77136: ARRAY
77137: IFFALSE 77141
// continue ;
77139: GO 77029
// h := hex [ 2 ] ;
77141: LD_ADDR_VAR 0 13
77145: PUSH
77146: LD_VAR 0 4
77150: PUSH
77151: LD_INT 2
77153: ARRAY
77154: ST_TO_ADDR
// if h + 7 < height then
77155: LD_VAR 0 13
77159: PUSH
77160: LD_INT 7
77162: PLUS
77163: PUSH
77164: LD_VAR 0 15
77168: LESS
77169: IFFALSE 77198
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77171: LD_ADDR_VAR 0 18
77175: PUSH
77176: LD_INT 7
77178: PUSH
77179: LD_INT 28
77181: PUSH
77182: LD_INT 45
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: LIST
77189: PUSH
77190: LD_VAR 0 12
77194: ARRAY
77195: ST_TO_ADDR
// break ;
77196: GO 77200
// end ; end ; end ;
77198: GO 77029
77200: POP
77201: POP
// end ; if not weapon then
77202: LD_VAR 0 18
77206: NOT
77207: IFFALSE 77267
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77209: LD_ADDR_VAR 0 5
77213: PUSH
77214: LD_VAR 0 5
77218: PUSH
77219: LD_INT 11
77221: PUSH
77222: LD_INT 30
77224: PUSH
77225: LD_INT 49
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: LIST
77232: DIFF
77233: ST_TO_ADDR
// if not list then
77234: LD_VAR 0 5
77238: NOT
77239: IFFALSE 77243
// exit ;
77241: GO 77385
// weapon := list [ rand ( 1 , list ) ] ;
77243: LD_ADDR_VAR 0 18
77247: PUSH
77248: LD_VAR 0 5
77252: PUSH
77253: LD_INT 1
77255: PPUSH
77256: LD_VAR 0 5
77260: PPUSH
77261: CALL_OW 12
77265: ARRAY
77266: ST_TO_ADDR
// end ; if weapon then
77267: LD_VAR 0 18
77271: IFFALSE 77385
// begin tmp := CostOfWeapon ( weapon ) ;
77273: LD_ADDR_VAR 0 14
77277: PUSH
77278: LD_VAR 0 18
77282: PPUSH
77283: CALL_OW 451
77287: ST_TO_ADDR
// j := GetBase ( tower ) ;
77288: LD_ADDR_VAR 0 9
77292: PUSH
77293: LD_VAR 0 1
77297: PPUSH
77298: CALL_OW 274
77302: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77303: LD_VAR 0 9
77307: PPUSH
77308: LD_INT 1
77310: PPUSH
77311: CALL_OW 275
77315: PUSH
77316: LD_VAR 0 14
77320: PUSH
77321: LD_INT 1
77323: ARRAY
77324: GREATEREQUAL
77325: PUSH
77326: LD_VAR 0 9
77330: PPUSH
77331: LD_INT 2
77333: PPUSH
77334: CALL_OW 275
77338: PUSH
77339: LD_VAR 0 14
77343: PUSH
77344: LD_INT 2
77346: ARRAY
77347: GREATEREQUAL
77348: AND
77349: PUSH
77350: LD_VAR 0 9
77354: PPUSH
77355: LD_INT 3
77357: PPUSH
77358: CALL_OW 275
77362: PUSH
77363: LD_VAR 0 14
77367: PUSH
77368: LD_INT 3
77370: ARRAY
77371: GREATEREQUAL
77372: AND
77373: IFFALSE 77385
// result := weapon ;
77375: LD_ADDR_VAR 0 3
77379: PUSH
77380: LD_VAR 0 18
77384: ST_TO_ADDR
// end ; end ;
77385: LD_VAR 0 3
77389: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77390: LD_INT 0
77392: PPUSH
77393: PPUSH
// result := true ;
77394: LD_ADDR_VAR 0 3
77398: PUSH
77399: LD_INT 1
77401: ST_TO_ADDR
// if array1 = array2 then
77402: LD_VAR 0 1
77406: PUSH
77407: LD_VAR 0 2
77411: EQUAL
77412: IFFALSE 77472
// begin for i = 1 to array1 do
77414: LD_ADDR_VAR 0 4
77418: PUSH
77419: DOUBLE
77420: LD_INT 1
77422: DEC
77423: ST_TO_ADDR
77424: LD_VAR 0 1
77428: PUSH
77429: FOR_TO
77430: IFFALSE 77468
// if array1 [ i ] <> array2 [ i ] then
77432: LD_VAR 0 1
77436: PUSH
77437: LD_VAR 0 4
77441: ARRAY
77442: PUSH
77443: LD_VAR 0 2
77447: PUSH
77448: LD_VAR 0 4
77452: ARRAY
77453: NONEQUAL
77454: IFFALSE 77466
// begin result := false ;
77456: LD_ADDR_VAR 0 3
77460: PUSH
77461: LD_INT 0
77463: ST_TO_ADDR
// break ;
77464: GO 77468
// end ;
77466: GO 77429
77468: POP
77469: POP
// end else
77470: GO 77480
// result := false ;
77472: LD_ADDR_VAR 0 3
77476: PUSH
77477: LD_INT 0
77479: ST_TO_ADDR
// end ;
77480: LD_VAR 0 3
77484: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77485: LD_INT 0
77487: PPUSH
77488: PPUSH
77489: PPUSH
// pom := GetBase ( fac ) ;
77490: LD_ADDR_VAR 0 5
77494: PUSH
77495: LD_VAR 0 1
77499: PPUSH
77500: CALL_OW 274
77504: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77505: LD_ADDR_VAR 0 4
77509: PUSH
77510: LD_VAR 0 2
77514: PUSH
77515: LD_INT 1
77517: ARRAY
77518: PPUSH
77519: LD_VAR 0 2
77523: PUSH
77524: LD_INT 2
77526: ARRAY
77527: PPUSH
77528: LD_VAR 0 2
77532: PUSH
77533: LD_INT 3
77535: ARRAY
77536: PPUSH
77537: LD_VAR 0 2
77541: PUSH
77542: LD_INT 4
77544: ARRAY
77545: PPUSH
77546: CALL_OW 449
77550: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77551: LD_ADDR_VAR 0 3
77555: PUSH
77556: LD_VAR 0 5
77560: PPUSH
77561: LD_INT 1
77563: PPUSH
77564: CALL_OW 275
77568: PUSH
77569: LD_VAR 0 4
77573: PUSH
77574: LD_INT 1
77576: ARRAY
77577: GREATEREQUAL
77578: PUSH
77579: LD_VAR 0 5
77583: PPUSH
77584: LD_INT 2
77586: PPUSH
77587: CALL_OW 275
77591: PUSH
77592: LD_VAR 0 4
77596: PUSH
77597: LD_INT 2
77599: ARRAY
77600: GREATEREQUAL
77601: AND
77602: PUSH
77603: LD_VAR 0 5
77607: PPUSH
77608: LD_INT 3
77610: PPUSH
77611: CALL_OW 275
77615: PUSH
77616: LD_VAR 0 4
77620: PUSH
77621: LD_INT 3
77623: ARRAY
77624: GREATEREQUAL
77625: AND
77626: ST_TO_ADDR
// end ;
77627: LD_VAR 0 3
77631: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77632: LD_INT 0
77634: PPUSH
77635: PPUSH
77636: PPUSH
77637: PPUSH
// pom := GetBase ( building ) ;
77638: LD_ADDR_VAR 0 3
77642: PUSH
77643: LD_VAR 0 1
77647: PPUSH
77648: CALL_OW 274
77652: ST_TO_ADDR
// if not pom then
77653: LD_VAR 0 3
77657: NOT
77658: IFFALSE 77662
// exit ;
77660: GO 77832
// btype := GetBType ( building ) ;
77662: LD_ADDR_VAR 0 5
77666: PUSH
77667: LD_VAR 0 1
77671: PPUSH
77672: CALL_OW 266
77676: ST_TO_ADDR
// if btype = b_armoury then
77677: LD_VAR 0 5
77681: PUSH
77682: LD_INT 4
77684: EQUAL
77685: IFFALSE 77695
// btype := b_barracks ;
77687: LD_ADDR_VAR 0 5
77691: PUSH
77692: LD_INT 5
77694: ST_TO_ADDR
// if btype = b_depot then
77695: LD_VAR 0 5
77699: PUSH
77700: LD_INT 0
77702: EQUAL
77703: IFFALSE 77713
// btype := b_warehouse ;
77705: LD_ADDR_VAR 0 5
77709: PUSH
77710: LD_INT 1
77712: ST_TO_ADDR
// if btype = b_workshop then
77713: LD_VAR 0 5
77717: PUSH
77718: LD_INT 2
77720: EQUAL
77721: IFFALSE 77731
// btype := b_factory ;
77723: LD_ADDR_VAR 0 5
77727: PUSH
77728: LD_INT 3
77730: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77731: LD_ADDR_VAR 0 4
77735: PUSH
77736: LD_VAR 0 5
77740: PPUSH
77741: LD_VAR 0 1
77745: PPUSH
77746: CALL_OW 248
77750: PPUSH
77751: CALL_OW 450
77755: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77756: LD_ADDR_VAR 0 2
77760: PUSH
77761: LD_VAR 0 3
77765: PPUSH
77766: LD_INT 1
77768: PPUSH
77769: CALL_OW 275
77773: PUSH
77774: LD_VAR 0 4
77778: PUSH
77779: LD_INT 1
77781: ARRAY
77782: GREATEREQUAL
77783: PUSH
77784: LD_VAR 0 3
77788: PPUSH
77789: LD_INT 2
77791: PPUSH
77792: CALL_OW 275
77796: PUSH
77797: LD_VAR 0 4
77801: PUSH
77802: LD_INT 2
77804: ARRAY
77805: GREATEREQUAL
77806: AND
77807: PUSH
77808: LD_VAR 0 3
77812: PPUSH
77813: LD_INT 3
77815: PPUSH
77816: CALL_OW 275
77820: PUSH
77821: LD_VAR 0 4
77825: PUSH
77826: LD_INT 3
77828: ARRAY
77829: GREATEREQUAL
77830: AND
77831: ST_TO_ADDR
// end ;
77832: LD_VAR 0 2
77836: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77837: LD_INT 0
77839: PPUSH
77840: PPUSH
77841: PPUSH
// pom := GetBase ( building ) ;
77842: LD_ADDR_VAR 0 4
77846: PUSH
77847: LD_VAR 0 1
77851: PPUSH
77852: CALL_OW 274
77856: ST_TO_ADDR
// if not pom then
77857: LD_VAR 0 4
77861: NOT
77862: IFFALSE 77866
// exit ;
77864: GO 77967
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77866: LD_ADDR_VAR 0 5
77870: PUSH
77871: LD_VAR 0 2
77875: PPUSH
77876: LD_VAR 0 1
77880: PPUSH
77881: CALL_OW 248
77885: PPUSH
77886: CALL_OW 450
77890: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77891: LD_ADDR_VAR 0 3
77895: PUSH
77896: LD_VAR 0 4
77900: PPUSH
77901: LD_INT 1
77903: PPUSH
77904: CALL_OW 275
77908: PUSH
77909: LD_VAR 0 5
77913: PUSH
77914: LD_INT 1
77916: ARRAY
77917: GREATEREQUAL
77918: PUSH
77919: LD_VAR 0 4
77923: PPUSH
77924: LD_INT 2
77926: PPUSH
77927: CALL_OW 275
77931: PUSH
77932: LD_VAR 0 5
77936: PUSH
77937: LD_INT 2
77939: ARRAY
77940: GREATEREQUAL
77941: AND
77942: PUSH
77943: LD_VAR 0 4
77947: PPUSH
77948: LD_INT 3
77950: PPUSH
77951: CALL_OW 275
77955: PUSH
77956: LD_VAR 0 5
77960: PUSH
77961: LD_INT 3
77963: ARRAY
77964: GREATEREQUAL
77965: AND
77966: ST_TO_ADDR
// end ;
77967: LD_VAR 0 3
77971: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77972: LD_INT 0
77974: PPUSH
77975: PPUSH
77976: PPUSH
77977: PPUSH
77978: PPUSH
77979: PPUSH
77980: PPUSH
77981: PPUSH
77982: PPUSH
77983: PPUSH
// result := false ;
77984: LD_ADDR_VAR 0 6
77988: PUSH
77989: LD_INT 0
77991: ST_TO_ADDR
// if not base or not btype or not x or not y then
77992: LD_VAR 0 1
77996: NOT
77997: PUSH
77998: LD_VAR 0 2
78002: NOT
78003: OR
78004: PUSH
78005: LD_VAR 0 3
78009: NOT
78010: OR
78011: PUSH
78012: LD_VAR 0 4
78016: NOT
78017: OR
78018: IFFALSE 78022
// exit ;
78020: GO 78631
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78022: LD_ADDR_VAR 0 12
78026: PUSH
78027: LD_VAR 0 2
78031: PPUSH
78032: LD_VAR 0 3
78036: PPUSH
78037: LD_VAR 0 4
78041: PPUSH
78042: LD_VAR 0 5
78046: PPUSH
78047: LD_VAR 0 1
78051: PUSH
78052: LD_INT 1
78054: ARRAY
78055: PPUSH
78056: CALL_OW 248
78060: PPUSH
78061: LD_INT 0
78063: PPUSH
78064: CALL 79468 0 6
78068: ST_TO_ADDR
// if not hexes then
78069: LD_VAR 0 12
78073: NOT
78074: IFFALSE 78078
// exit ;
78076: GO 78631
// for i = 1 to hexes do
78078: LD_ADDR_VAR 0 7
78082: PUSH
78083: DOUBLE
78084: LD_INT 1
78086: DEC
78087: ST_TO_ADDR
78088: LD_VAR 0 12
78092: PUSH
78093: FOR_TO
78094: IFFALSE 78629
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78096: LD_ADDR_VAR 0 11
78100: PUSH
78101: LD_VAR 0 12
78105: PUSH
78106: LD_VAR 0 7
78110: ARRAY
78111: PUSH
78112: LD_INT 1
78114: ARRAY
78115: PPUSH
78116: LD_VAR 0 12
78120: PUSH
78121: LD_VAR 0 7
78125: ARRAY
78126: PUSH
78127: LD_INT 2
78129: ARRAY
78130: PPUSH
78131: CALL_OW 428
78135: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78136: LD_VAR 0 12
78140: PUSH
78141: LD_VAR 0 7
78145: ARRAY
78146: PUSH
78147: LD_INT 1
78149: ARRAY
78150: PPUSH
78151: LD_VAR 0 12
78155: PUSH
78156: LD_VAR 0 7
78160: ARRAY
78161: PUSH
78162: LD_INT 2
78164: ARRAY
78165: PPUSH
78166: CALL_OW 351
78170: PUSH
78171: LD_VAR 0 12
78175: PUSH
78176: LD_VAR 0 7
78180: ARRAY
78181: PUSH
78182: LD_INT 1
78184: ARRAY
78185: PPUSH
78186: LD_VAR 0 12
78190: PUSH
78191: LD_VAR 0 7
78195: ARRAY
78196: PUSH
78197: LD_INT 2
78199: ARRAY
78200: PPUSH
78201: CALL_OW 488
78205: NOT
78206: OR
78207: PUSH
78208: LD_VAR 0 11
78212: PPUSH
78213: CALL_OW 247
78217: PUSH
78218: LD_INT 3
78220: EQUAL
78221: OR
78222: IFFALSE 78228
// exit ;
78224: POP
78225: POP
78226: GO 78631
// if not tmp or not tmp in base then
78228: LD_VAR 0 11
78232: NOT
78233: PUSH
78234: LD_VAR 0 11
78238: PUSH
78239: LD_VAR 0 1
78243: IN
78244: NOT
78245: OR
78246: IFFALSE 78250
// continue ;
78248: GO 78093
// result := true ;
78250: LD_ADDR_VAR 0 6
78254: PUSH
78255: LD_INT 1
78257: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78258: LD_ADDR_VAR 0 15
78262: PUSH
78263: LD_VAR 0 1
78267: PPUSH
78268: LD_INT 22
78270: PUSH
78271: LD_VAR 0 11
78275: PPUSH
78276: CALL_OW 255
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 2
78287: PUSH
78288: LD_INT 30
78290: PUSH
78291: LD_INT 0
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 30
78300: PUSH
78301: LD_INT 1
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: LIST
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PPUSH
78317: CALL_OW 72
78321: ST_TO_ADDR
// if dep then
78322: LD_VAR 0 15
78326: IFFALSE 78462
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78328: LD_ADDR_VAR 0 14
78332: PUSH
78333: LD_VAR 0 15
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PPUSH
78342: CALL_OW 250
78346: PPUSH
78347: LD_VAR 0 15
78351: PUSH
78352: LD_INT 1
78354: ARRAY
78355: PPUSH
78356: CALL_OW 254
78360: PPUSH
78361: LD_INT 5
78363: PPUSH
78364: CALL_OW 272
78368: PUSH
78369: LD_VAR 0 15
78373: PUSH
78374: LD_INT 1
78376: ARRAY
78377: PPUSH
78378: CALL_OW 251
78382: PPUSH
78383: LD_VAR 0 15
78387: PUSH
78388: LD_INT 1
78390: ARRAY
78391: PPUSH
78392: CALL_OW 254
78396: PPUSH
78397: LD_INT 5
78399: PPUSH
78400: CALL_OW 273
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78409: LD_VAR 0 14
78413: PUSH
78414: LD_INT 1
78416: ARRAY
78417: PPUSH
78418: LD_VAR 0 14
78422: PUSH
78423: LD_INT 2
78425: ARRAY
78426: PPUSH
78427: CALL_OW 488
78431: IFFALSE 78462
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78433: LD_VAR 0 11
78437: PPUSH
78438: LD_VAR 0 14
78442: PUSH
78443: LD_INT 1
78445: ARRAY
78446: PPUSH
78447: LD_VAR 0 14
78451: PUSH
78452: LD_INT 2
78454: ARRAY
78455: PPUSH
78456: CALL_OW 111
// continue ;
78460: GO 78093
// end ; end ; r := GetDir ( tmp ) ;
78462: LD_ADDR_VAR 0 13
78466: PUSH
78467: LD_VAR 0 11
78471: PPUSH
78472: CALL_OW 254
78476: ST_TO_ADDR
// if r = 5 then
78477: LD_VAR 0 13
78481: PUSH
78482: LD_INT 5
78484: EQUAL
78485: IFFALSE 78495
// r := 0 ;
78487: LD_ADDR_VAR 0 13
78491: PUSH
78492: LD_INT 0
78494: ST_TO_ADDR
// for j = r to 5 do
78495: LD_ADDR_VAR 0 8
78499: PUSH
78500: DOUBLE
78501: LD_VAR 0 13
78505: DEC
78506: ST_TO_ADDR
78507: LD_INT 5
78509: PUSH
78510: FOR_TO
78511: IFFALSE 78625
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78513: LD_ADDR_VAR 0 9
78517: PUSH
78518: LD_VAR 0 11
78522: PPUSH
78523: CALL_OW 250
78527: PPUSH
78528: LD_VAR 0 8
78532: PPUSH
78533: LD_INT 2
78535: PPUSH
78536: CALL_OW 272
78540: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78541: LD_ADDR_VAR 0 10
78545: PUSH
78546: LD_VAR 0 11
78550: PPUSH
78551: CALL_OW 251
78555: PPUSH
78556: LD_VAR 0 8
78560: PPUSH
78561: LD_INT 2
78563: PPUSH
78564: CALL_OW 273
78568: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78569: LD_VAR 0 9
78573: PPUSH
78574: LD_VAR 0 10
78578: PPUSH
78579: CALL_OW 488
78583: PUSH
78584: LD_VAR 0 9
78588: PPUSH
78589: LD_VAR 0 10
78593: PPUSH
78594: CALL_OW 428
78598: NOT
78599: AND
78600: IFFALSE 78623
// begin ComMoveXY ( tmp , _x , _y ) ;
78602: LD_VAR 0 11
78606: PPUSH
78607: LD_VAR 0 9
78611: PPUSH
78612: LD_VAR 0 10
78616: PPUSH
78617: CALL_OW 111
// break ;
78621: GO 78625
// end ; end ;
78623: GO 78510
78625: POP
78626: POP
// end ;
78627: GO 78093
78629: POP
78630: POP
// end ;
78631: LD_VAR 0 6
78635: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78636: LD_INT 0
78638: PPUSH
78639: PPUSH
78640: PPUSH
78641: PPUSH
78642: PPUSH
78643: PPUSH
78644: PPUSH
78645: PPUSH
78646: PPUSH
78647: PPUSH
// result := false ;
78648: LD_ADDR_VAR 0 6
78652: PUSH
78653: LD_INT 0
78655: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78656: LD_VAR 0 1
78660: NOT
78661: PUSH
78662: LD_VAR 0 1
78666: PPUSH
78667: CALL_OW 266
78671: PUSH
78672: LD_INT 0
78674: PUSH
78675: LD_INT 1
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: IN
78682: NOT
78683: OR
78684: PUSH
78685: LD_VAR 0 2
78689: NOT
78690: OR
78691: PUSH
78692: LD_VAR 0 5
78696: PUSH
78697: LD_INT 0
78699: PUSH
78700: LD_INT 1
78702: PUSH
78703: LD_INT 2
78705: PUSH
78706: LD_INT 3
78708: PUSH
78709: LD_INT 4
78711: PUSH
78712: LD_INT 5
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: IN
78723: NOT
78724: OR
78725: PUSH
78726: LD_VAR 0 3
78730: PPUSH
78731: LD_VAR 0 4
78735: PPUSH
78736: CALL_OW 488
78740: NOT
78741: OR
78742: IFFALSE 78746
// exit ;
78744: GO 79463
// pom := GetBase ( depot ) ;
78746: LD_ADDR_VAR 0 10
78750: PUSH
78751: LD_VAR 0 1
78755: PPUSH
78756: CALL_OW 274
78760: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78761: LD_ADDR_VAR 0 11
78765: PUSH
78766: LD_VAR 0 2
78770: PPUSH
78771: LD_VAR 0 1
78775: PPUSH
78776: CALL_OW 248
78780: PPUSH
78781: CALL_OW 450
78785: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78786: LD_VAR 0 10
78790: PPUSH
78791: LD_INT 1
78793: PPUSH
78794: CALL_OW 275
78798: PUSH
78799: LD_VAR 0 11
78803: PUSH
78804: LD_INT 1
78806: ARRAY
78807: GREATEREQUAL
78808: PUSH
78809: LD_VAR 0 10
78813: PPUSH
78814: LD_INT 2
78816: PPUSH
78817: CALL_OW 275
78821: PUSH
78822: LD_VAR 0 11
78826: PUSH
78827: LD_INT 2
78829: ARRAY
78830: GREATEREQUAL
78831: AND
78832: PUSH
78833: LD_VAR 0 10
78837: PPUSH
78838: LD_INT 3
78840: PPUSH
78841: CALL_OW 275
78845: PUSH
78846: LD_VAR 0 11
78850: PUSH
78851: LD_INT 3
78853: ARRAY
78854: GREATEREQUAL
78855: AND
78856: NOT
78857: IFFALSE 78861
// exit ;
78859: GO 79463
// if GetBType ( depot ) = b_depot then
78861: LD_VAR 0 1
78865: PPUSH
78866: CALL_OW 266
78870: PUSH
78871: LD_INT 0
78873: EQUAL
78874: IFFALSE 78886
// dist := 28 else
78876: LD_ADDR_VAR 0 14
78880: PUSH
78881: LD_INT 28
78883: ST_TO_ADDR
78884: GO 78894
// dist := 36 ;
78886: LD_ADDR_VAR 0 14
78890: PUSH
78891: LD_INT 36
78893: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78894: LD_VAR 0 1
78898: PPUSH
78899: LD_VAR 0 3
78903: PPUSH
78904: LD_VAR 0 4
78908: PPUSH
78909: CALL_OW 297
78913: PUSH
78914: LD_VAR 0 14
78918: GREATER
78919: IFFALSE 78923
// exit ;
78921: GO 79463
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78923: LD_ADDR_VAR 0 12
78927: PUSH
78928: LD_VAR 0 2
78932: PPUSH
78933: LD_VAR 0 3
78937: PPUSH
78938: LD_VAR 0 4
78942: PPUSH
78943: LD_VAR 0 5
78947: PPUSH
78948: LD_VAR 0 1
78952: PPUSH
78953: CALL_OW 248
78957: PPUSH
78958: LD_INT 0
78960: PPUSH
78961: CALL 79468 0 6
78965: ST_TO_ADDR
// if not hexes then
78966: LD_VAR 0 12
78970: NOT
78971: IFFALSE 78975
// exit ;
78973: GO 79463
// hex := GetHexInfo ( x , y ) ;
78975: LD_ADDR_VAR 0 15
78979: PUSH
78980: LD_VAR 0 3
78984: PPUSH
78985: LD_VAR 0 4
78989: PPUSH
78990: CALL_OW 546
78994: ST_TO_ADDR
// if hex [ 1 ] then
78995: LD_VAR 0 15
78999: PUSH
79000: LD_INT 1
79002: ARRAY
79003: IFFALSE 79007
// exit ;
79005: GO 79463
// height := hex [ 2 ] ;
79007: LD_ADDR_VAR 0 13
79011: PUSH
79012: LD_VAR 0 15
79016: PUSH
79017: LD_INT 2
79019: ARRAY
79020: ST_TO_ADDR
// for i = 1 to hexes do
79021: LD_ADDR_VAR 0 7
79025: PUSH
79026: DOUBLE
79027: LD_INT 1
79029: DEC
79030: ST_TO_ADDR
79031: LD_VAR 0 12
79035: PUSH
79036: FOR_TO
79037: IFFALSE 79367
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79039: LD_VAR 0 12
79043: PUSH
79044: LD_VAR 0 7
79048: ARRAY
79049: PUSH
79050: LD_INT 1
79052: ARRAY
79053: PPUSH
79054: LD_VAR 0 12
79058: PUSH
79059: LD_VAR 0 7
79063: ARRAY
79064: PUSH
79065: LD_INT 2
79067: ARRAY
79068: PPUSH
79069: CALL_OW 488
79073: NOT
79074: PUSH
79075: LD_VAR 0 12
79079: PUSH
79080: LD_VAR 0 7
79084: ARRAY
79085: PUSH
79086: LD_INT 1
79088: ARRAY
79089: PPUSH
79090: LD_VAR 0 12
79094: PUSH
79095: LD_VAR 0 7
79099: ARRAY
79100: PUSH
79101: LD_INT 2
79103: ARRAY
79104: PPUSH
79105: CALL_OW 428
79109: PUSH
79110: LD_INT 0
79112: GREATER
79113: OR
79114: PUSH
79115: LD_VAR 0 12
79119: PUSH
79120: LD_VAR 0 7
79124: ARRAY
79125: PUSH
79126: LD_INT 1
79128: ARRAY
79129: PPUSH
79130: LD_VAR 0 12
79134: PUSH
79135: LD_VAR 0 7
79139: ARRAY
79140: PUSH
79141: LD_INT 2
79143: ARRAY
79144: PPUSH
79145: CALL_OW 351
79149: OR
79150: IFFALSE 79156
// exit ;
79152: POP
79153: POP
79154: GO 79463
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79156: LD_ADDR_VAR 0 8
79160: PUSH
79161: LD_VAR 0 12
79165: PUSH
79166: LD_VAR 0 7
79170: ARRAY
79171: PUSH
79172: LD_INT 1
79174: ARRAY
79175: PPUSH
79176: LD_VAR 0 12
79180: PUSH
79181: LD_VAR 0 7
79185: ARRAY
79186: PUSH
79187: LD_INT 2
79189: ARRAY
79190: PPUSH
79191: CALL_OW 546
79195: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79196: LD_VAR 0 8
79200: PUSH
79201: LD_INT 1
79203: ARRAY
79204: PUSH
79205: LD_VAR 0 8
79209: PUSH
79210: LD_INT 2
79212: ARRAY
79213: PUSH
79214: LD_VAR 0 13
79218: PUSH
79219: LD_INT 2
79221: PLUS
79222: GREATER
79223: OR
79224: PUSH
79225: LD_VAR 0 8
79229: PUSH
79230: LD_INT 2
79232: ARRAY
79233: PUSH
79234: LD_VAR 0 13
79238: PUSH
79239: LD_INT 2
79241: MINUS
79242: LESS
79243: OR
79244: PUSH
79245: LD_VAR 0 8
79249: PUSH
79250: LD_INT 3
79252: ARRAY
79253: PUSH
79254: LD_INT 0
79256: PUSH
79257: LD_INT 8
79259: PUSH
79260: LD_INT 9
79262: PUSH
79263: LD_INT 10
79265: PUSH
79266: LD_INT 11
79268: PUSH
79269: LD_INT 12
79271: PUSH
79272: LD_INT 13
79274: PUSH
79275: LD_INT 16
79277: PUSH
79278: LD_INT 17
79280: PUSH
79281: LD_INT 18
79283: PUSH
79284: LD_INT 19
79286: PUSH
79287: LD_INT 20
79289: PUSH
79290: LD_INT 21
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: IN
79308: NOT
79309: OR
79310: PUSH
79311: LD_VAR 0 8
79315: PUSH
79316: LD_INT 5
79318: ARRAY
79319: NOT
79320: OR
79321: PUSH
79322: LD_VAR 0 8
79326: PUSH
79327: LD_INT 6
79329: ARRAY
79330: PUSH
79331: LD_INT 1
79333: PUSH
79334: LD_INT 2
79336: PUSH
79337: LD_INT 7
79339: PUSH
79340: LD_INT 9
79342: PUSH
79343: LD_INT 10
79345: PUSH
79346: LD_INT 11
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: IN
79357: NOT
79358: OR
79359: IFFALSE 79365
// exit ;
79361: POP
79362: POP
79363: GO 79463
// end ;
79365: GO 79036
79367: POP
79368: POP
// side := GetSide ( depot ) ;
79369: LD_ADDR_VAR 0 9
79373: PUSH
79374: LD_VAR 0 1
79378: PPUSH
79379: CALL_OW 255
79383: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79384: LD_VAR 0 9
79388: PPUSH
79389: LD_VAR 0 3
79393: PPUSH
79394: LD_VAR 0 4
79398: PPUSH
79399: LD_INT 20
79401: PPUSH
79402: CALL 72117 0 4
79406: PUSH
79407: LD_INT 4
79409: ARRAY
79410: IFFALSE 79414
// exit ;
79412: GO 79463
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79414: LD_VAR 0 2
79418: PUSH
79419: LD_INT 29
79421: PUSH
79422: LD_INT 30
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: IN
79429: PUSH
79430: LD_VAR 0 3
79434: PPUSH
79435: LD_VAR 0 4
79439: PPUSH
79440: LD_VAR 0 9
79444: PPUSH
79445: CALL_OW 440
79449: NOT
79450: AND
79451: IFFALSE 79455
// exit ;
79453: GO 79463
// result := true ;
79455: LD_ADDR_VAR 0 6
79459: PUSH
79460: LD_INT 1
79462: ST_TO_ADDR
// end ;
79463: LD_VAR 0 6
79467: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79468: LD_INT 0
79470: PPUSH
79471: PPUSH
79472: PPUSH
79473: PPUSH
79474: PPUSH
79475: PPUSH
79476: PPUSH
79477: PPUSH
79478: PPUSH
79479: PPUSH
79480: PPUSH
79481: PPUSH
79482: PPUSH
79483: PPUSH
79484: PPUSH
79485: PPUSH
79486: PPUSH
79487: PPUSH
79488: PPUSH
79489: PPUSH
79490: PPUSH
79491: PPUSH
79492: PPUSH
79493: PPUSH
79494: PPUSH
79495: PPUSH
79496: PPUSH
79497: PPUSH
79498: PPUSH
79499: PPUSH
79500: PPUSH
79501: PPUSH
79502: PPUSH
79503: PPUSH
79504: PPUSH
79505: PPUSH
79506: PPUSH
79507: PPUSH
79508: PPUSH
79509: PPUSH
79510: PPUSH
79511: PPUSH
79512: PPUSH
79513: PPUSH
79514: PPUSH
79515: PPUSH
79516: PPUSH
79517: PPUSH
79518: PPUSH
79519: PPUSH
79520: PPUSH
79521: PPUSH
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
79526: PPUSH
79527: PPUSH
// result = [ ] ;
79528: LD_ADDR_VAR 0 7
79532: PUSH
79533: EMPTY
79534: ST_TO_ADDR
// temp_list = [ ] ;
79535: LD_ADDR_VAR 0 9
79539: PUSH
79540: EMPTY
79541: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79542: LD_VAR 0 4
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: LD_INT 1
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: LD_INT 3
79558: PUSH
79559: LD_INT 4
79561: PUSH
79562: LD_INT 5
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: IN
79573: NOT
79574: PUSH
79575: LD_VAR 0 1
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: LD_INT 1
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: IN
79590: PUSH
79591: LD_VAR 0 5
79595: PUSH
79596: LD_INT 1
79598: PUSH
79599: LD_INT 2
79601: PUSH
79602: LD_INT 3
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: LIST
79609: IN
79610: NOT
79611: AND
79612: OR
79613: IFFALSE 79617
// exit ;
79615: GO 98008
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79617: LD_VAR 0 1
79621: PUSH
79622: LD_INT 6
79624: PUSH
79625: LD_INT 7
79627: PUSH
79628: LD_INT 8
79630: PUSH
79631: LD_INT 13
79633: PUSH
79634: LD_INT 12
79636: PUSH
79637: LD_INT 15
79639: PUSH
79640: LD_INT 11
79642: PUSH
79643: LD_INT 14
79645: PUSH
79646: LD_INT 10
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: IN
79660: IFFALSE 79670
// btype = b_lab ;
79662: LD_ADDR_VAR 0 1
79666: PUSH
79667: LD_INT 6
79669: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79670: LD_VAR 0 6
79674: PUSH
79675: LD_INT 0
79677: PUSH
79678: LD_INT 1
79680: PUSH
79681: LD_INT 2
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: LIST
79688: IN
79689: NOT
79690: PUSH
79691: LD_VAR 0 1
79695: PUSH
79696: LD_INT 0
79698: PUSH
79699: LD_INT 1
79701: PUSH
79702: LD_INT 2
79704: PUSH
79705: LD_INT 3
79707: PUSH
79708: LD_INT 6
79710: PUSH
79711: LD_INT 36
79713: PUSH
79714: LD_INT 4
79716: PUSH
79717: LD_INT 5
79719: PUSH
79720: LD_INT 31
79722: PUSH
79723: LD_INT 32
79725: PUSH
79726: LD_INT 33
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: LIST
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: IN
79742: NOT
79743: PUSH
79744: LD_VAR 0 6
79748: PUSH
79749: LD_INT 1
79751: EQUAL
79752: AND
79753: OR
79754: PUSH
79755: LD_VAR 0 1
79759: PUSH
79760: LD_INT 2
79762: PUSH
79763: LD_INT 3
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: IN
79770: NOT
79771: PUSH
79772: LD_VAR 0 6
79776: PUSH
79777: LD_INT 2
79779: EQUAL
79780: AND
79781: OR
79782: IFFALSE 79792
// mode = 0 ;
79784: LD_ADDR_VAR 0 6
79788: PUSH
79789: LD_INT 0
79791: ST_TO_ADDR
// case mode of 0 :
79792: LD_VAR 0 6
79796: PUSH
79797: LD_INT 0
79799: DOUBLE
79800: EQUAL
79801: IFTRUE 79805
79803: GO 91258
79805: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79806: LD_ADDR_VAR 0 11
79810: PUSH
79811: LD_INT 0
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 0
79823: PUSH
79824: LD_INT 1
79826: NEG
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 1
79834: PUSH
79835: LD_INT 0
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: LD_INT 1
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 0
79854: PUSH
79855: LD_INT 1
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 1
79864: NEG
79865: PUSH
79866: LD_INT 0
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: LD_INT 2
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: LD_INT 2
79902: NEG
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: LD_INT 1
79913: NEG
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: LD_INT 2
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: LD_INT 2
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: LD_INT 1
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: LD_INT 3
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: LD_INT 3
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 1
79972: NEG
79973: PUSH
79974: LD_INT 2
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79999: LD_ADDR_VAR 0 12
80003: PUSH
80004: LD_INT 0
80006: PUSH
80007: LD_INT 0
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: LD_INT 1
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: LD_INT 0
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: LD_INT 1
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: NEG
80058: PUSH
80059: LD_INT 0
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 1
80068: NEG
80069: PUSH
80070: LD_INT 1
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 1
80080: PUSH
80081: LD_INT 1
80083: NEG
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 2
80091: PUSH
80092: LD_INT 0
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: PUSH
80099: LD_INT 2
80101: PUSH
80102: LD_INT 1
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 1
80111: NEG
80112: PUSH
80113: LD_INT 1
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: NEG
80123: PUSH
80124: LD_INT 0
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 2
80133: NEG
80134: PUSH
80135: LD_INT 1
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 2
80145: NEG
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 3
80156: NEG
80157: PUSH
80158: LD_INT 0
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 3
80167: NEG
80168: PUSH
80169: LD_INT 1
80171: NEG
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80195: LD_ADDR_VAR 0 13
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 0
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 0
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: LD_INT 1
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: LD_INT 1
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: LD_INT 0
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: NEG
80265: PUSH
80266: LD_INT 1
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 1
80276: NEG
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 2
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 2
80298: PUSH
80299: LD_INT 2
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 1
80308: PUSH
80309: LD_INT 2
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 2
80318: NEG
80319: PUSH
80320: LD_INT 1
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: LD_INT 2
80334: NEG
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 2
80342: NEG
80343: PUSH
80344: LD_INT 3
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 3
80354: NEG
80355: PUSH
80356: LD_INT 2
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 3
80366: NEG
80367: PUSH
80368: LD_INT 3
80370: NEG
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80394: LD_ADDR_VAR 0 14
80398: PUSH
80399: LD_INT 0
80401: PUSH
80402: LD_INT 0
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 0
80411: PUSH
80412: LD_INT 1
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 1
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 1
80432: PUSH
80433: LD_INT 1
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 0
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: LD_INT 0
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 1
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: NEG
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: LD_INT 2
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 1
80498: PUSH
80499: LD_INT 1
80501: NEG
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 1
80509: PUSH
80510: LD_INT 2
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: LD_INT 2
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 1
80540: NEG
80541: PUSH
80542: LD_INT 3
80544: NEG
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 3
80555: NEG
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 1
80563: PUSH
80564: LD_INT 2
80566: NEG
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80590: LD_ADDR_VAR 0 15
80594: PUSH
80595: LD_INT 0
80597: PUSH
80598: LD_INT 0
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: LD_INT 1
80610: NEG
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 1
80618: PUSH
80619: LD_INT 0
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 1
80628: PUSH
80629: LD_INT 1
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 0
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 0
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: NEG
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: PUSH
80672: LD_INT 1
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: LD_INT 0
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 2
80692: PUSH
80693: LD_INT 1
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 2
80713: NEG
80714: PUSH
80715: LD_INT 0
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 2
80724: NEG
80725: PUSH
80726: LD_INT 1
80728: NEG
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 2
80736: PUSH
80737: LD_INT 1
80739: NEG
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 3
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 3
80757: PUSH
80758: LD_INT 1
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80783: LD_ADDR_VAR 0 16
80787: PUSH
80788: LD_INT 0
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: LD_INT 1
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 2
80876: PUSH
80877: LD_INT 1
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 2
80886: PUSH
80887: LD_INT 2
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 1
80896: PUSH
80897: LD_INT 2
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 2
80906: NEG
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 2
80918: NEG
80919: PUSH
80920: LD_INT 2
80922: NEG
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 3
80930: PUSH
80931: LD_INT 2
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 3
80940: PUSH
80941: LD_INT 3
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 3
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80976: LD_ADDR_VAR 0 17
80980: PUSH
80981: LD_INT 0
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 0
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 1
81004: PUSH
81005: LD_INT 0
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: LD_INT 1
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 1
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: LD_INT 0
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 1
81045: NEG
81046: PUSH
81047: LD_INT 1
81049: NEG
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 1
81057: NEG
81058: PUSH
81059: LD_INT 2
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 2
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: LD_INT 1
81083: NEG
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 2
81091: PUSH
81092: LD_INT 0
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: PUSH
81099: LD_INT 2
81101: PUSH
81102: LD_INT 1
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 2
81111: PUSH
81112: LD_INT 2
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 1
81121: PUSH
81122: LD_INT 2
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 0
81131: PUSH
81132: LD_INT 2
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: LD_INT 1
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 2
81152: NEG
81153: PUSH
81154: LD_INT 0
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 2
81163: NEG
81164: PUSH
81165: LD_INT 1
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 2
81175: NEG
81176: PUSH
81177: LD_INT 2
81179: NEG
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81206: LD_ADDR_VAR 0 18
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: LD_INT 1
81226: NEG
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 1
81234: PUSH
81235: LD_INT 0
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 1
81244: PUSH
81245: LD_INT 1
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 0
81254: PUSH
81255: LD_INT 1
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 1
81264: NEG
81265: PUSH
81266: LD_INT 0
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 1
81275: NEG
81276: PUSH
81277: LD_INT 1
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 1
81287: NEG
81288: PUSH
81289: LD_INT 2
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: LD_INT 2
81302: NEG
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 1
81310: PUSH
81311: LD_INT 1
81313: NEG
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: LD_INT 0
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: LD_INT 2
81331: PUSH
81332: LD_INT 1
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 2
81341: PUSH
81342: LD_INT 2
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 1
81351: PUSH
81352: LD_INT 2
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 0
81361: PUSH
81362: LD_INT 2
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 1
81371: NEG
81372: PUSH
81373: LD_INT 1
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 2
81382: NEG
81383: PUSH
81384: LD_INT 0
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 2
81393: NEG
81394: PUSH
81395: LD_INT 1
81397: NEG
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 2
81405: NEG
81406: PUSH
81407: LD_INT 2
81409: NEG
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81436: LD_ADDR_VAR 0 19
81440: PUSH
81441: LD_INT 0
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 0
81453: PUSH
81454: LD_INT 1
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 1
81464: PUSH
81465: LD_INT 0
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 1
81474: PUSH
81475: LD_INT 1
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 0
81484: PUSH
81485: LD_INT 1
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: LD_INT 1
81494: NEG
81495: PUSH
81496: LD_INT 0
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: LD_INT 1
81509: NEG
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 1
81517: NEG
81518: PUSH
81519: LD_INT 2
81521: NEG
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 2
81532: NEG
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 1
81540: PUSH
81541: LD_INT 1
81543: NEG
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 0
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 1
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 2
81571: PUSH
81572: LD_INT 2
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: LD_INT 2
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: LD_INT 2
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 1
81601: NEG
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 2
81612: NEG
81613: PUSH
81614: LD_INT 0
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 2
81623: NEG
81624: PUSH
81625: LD_INT 1
81627: NEG
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 2
81635: NEG
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81666: LD_ADDR_VAR 0 20
81670: PUSH
81671: LD_INT 0
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 1
81694: PUSH
81695: LD_INT 0
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 1
81704: PUSH
81705: LD_INT 1
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 0
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: LD_INT 0
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 1
81735: NEG
81736: PUSH
81737: LD_INT 1
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: LD_INT 2
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 2
81781: PUSH
81782: LD_INT 0
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 2
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: LD_INT 2
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: LD_INT 2
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 0
81821: PUSH
81822: LD_INT 2
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 1
81831: NEG
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 2
81842: NEG
81843: PUSH
81844: LD_INT 0
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: NEG
81854: PUSH
81855: LD_INT 1
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 2
81865: NEG
81866: PUSH
81867: LD_INT 2
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: LIST
81894: LIST
81895: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81896: LD_ADDR_VAR 0 21
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 1
81924: PUSH
81925: LD_INT 0
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 1
81934: PUSH
81935: LD_INT 1
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 0
81944: PUSH
81945: LD_INT 1
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: LD_INT 0
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 1
81965: NEG
81966: PUSH
81967: LD_INT 1
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 1
81977: NEG
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 0
81989: PUSH
81990: LD_INT 2
81992: NEG
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 1
82000: PUSH
82001: LD_INT 1
82003: NEG
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 2
82021: PUSH
82022: LD_INT 1
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 2
82031: PUSH
82032: LD_INT 2
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: LD_INT 2
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 0
82051: PUSH
82052: LD_INT 2
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 1
82061: NEG
82062: PUSH
82063: LD_INT 1
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 2
82072: NEG
82073: PUSH
82074: LD_INT 0
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 2
82083: NEG
82084: PUSH
82085: LD_INT 1
82087: NEG
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 2
82095: NEG
82096: PUSH
82097: LD_INT 2
82099: NEG
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82126: LD_ADDR_VAR 0 22
82130: PUSH
82131: LD_INT 0
82133: PUSH
82134: LD_INT 0
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 0
82143: PUSH
82144: LD_INT 1
82146: NEG
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 1
82154: PUSH
82155: LD_INT 0
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 1
82164: PUSH
82165: LD_INT 1
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 0
82174: PUSH
82175: LD_INT 1
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 1
82184: NEG
82185: PUSH
82186: LD_INT 0
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 1
82195: NEG
82196: PUSH
82197: LD_INT 1
82199: NEG
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 0
82219: PUSH
82220: LD_INT 2
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 1
82230: PUSH
82231: LD_INT 1
82233: NEG
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 2
82241: PUSH
82242: LD_INT 0
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 2
82251: PUSH
82252: LD_INT 1
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 2
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 1
82271: PUSH
82272: LD_INT 2
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: LD_INT 2
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: LD_INT 1
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: LD_INT 0
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: NEG
82314: PUSH
82315: LD_INT 1
82317: NEG
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: LD_INT 2
82325: NEG
82326: PUSH
82327: LD_INT 2
82329: NEG
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82356: LD_ADDR_VAR 0 23
82360: PUSH
82361: LD_INT 0
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 1
82384: PUSH
82385: LD_INT 0
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 1
82394: PUSH
82395: LD_INT 1
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 0
82404: PUSH
82405: LD_INT 1
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 1
82414: NEG
82415: PUSH
82416: LD_INT 0
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 1
82425: NEG
82426: PUSH
82427: LD_INT 1
82429: NEG
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: LD_INT 2
82441: NEG
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: LD_INT 2
82452: NEG
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 1
82460: PUSH
82461: LD_INT 1
82463: NEG
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 2
82471: PUSH
82472: LD_INT 0
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 2
82481: PUSH
82482: LD_INT 1
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 2
82491: PUSH
82492: LD_INT 2
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 1
82501: PUSH
82502: LD_INT 2
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 0
82511: PUSH
82512: LD_INT 2
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 1
82521: NEG
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 2
82532: NEG
82533: PUSH
82534: LD_INT 0
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 2
82543: NEG
82544: PUSH
82545: LD_INT 1
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 2
82555: NEG
82556: PUSH
82557: LD_INT 2
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: NEG
82568: PUSH
82569: LD_INT 3
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 1
82579: NEG
82580: PUSH
82581: LD_INT 3
82583: NEG
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 1
82591: PUSH
82592: LD_INT 2
82594: NEG
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 2
82602: PUSH
82603: LD_INT 1
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82636: LD_ADDR_VAR 0 24
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: LD_INT 0
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 0
82653: PUSH
82654: LD_INT 1
82656: NEG
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 1
82664: PUSH
82665: LD_INT 0
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: LD_INT 1
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 0
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: NEG
82695: PUSH
82696: LD_INT 0
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: NEG
82718: PUSH
82719: LD_INT 2
82721: NEG
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 0
82729: PUSH
82730: LD_INT 2
82732: NEG
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: PUSH
82741: LD_INT 1
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 2
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 2
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: LD_INT 2
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 0
82791: PUSH
82792: LD_INT 2
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 1
82801: NEG
82802: PUSH
82803: LD_INT 1
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 2
82812: NEG
82813: PUSH
82814: LD_INT 0
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 2
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 2
82835: NEG
82836: PUSH
82837: LD_INT 2
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 2
82858: PUSH
82859: LD_INT 1
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 3
82869: PUSH
82870: LD_INT 1
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 3
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82912: LD_ADDR_VAR 0 25
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: LD_INT 0
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 0
82929: PUSH
82930: LD_INT 1
82932: NEG
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 1
82940: PUSH
82941: LD_INT 0
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 1
82950: PUSH
82951: LD_INT 1
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: LD_INT 1
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 1
82970: NEG
82971: PUSH
82972: LD_INT 0
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: NEG
82982: PUSH
82983: LD_INT 1
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: LD_INT 2
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 0
83005: PUSH
83006: LD_INT 2
83008: NEG
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 1
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: PUSH
83028: LD_INT 0
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 2
83037: PUSH
83038: LD_INT 1
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 2
83047: PUSH
83048: LD_INT 2
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: LD_INT 2
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 0
83067: PUSH
83068: LD_INT 2
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 1
83077: NEG
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 2
83088: NEG
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 2
83099: NEG
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: NEG
83112: PUSH
83113: LD_INT 2
83115: NEG
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 3
83123: PUSH
83124: LD_INT 1
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 3
83133: PUSH
83134: LD_INT 2
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: LD_INT 3
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: LD_INT 3
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83186: LD_ADDR_VAR 0 26
83190: PUSH
83191: LD_INT 0
83193: PUSH
83194: LD_INT 0
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 0
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 1
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 0
83234: PUSH
83235: LD_INT 1
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 1
83244: NEG
83245: PUSH
83246: LD_INT 0
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 1
83255: NEG
83256: PUSH
83257: LD_INT 1
83259: NEG
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 1
83267: NEG
83268: PUSH
83269: LD_INT 2
83271: NEG
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 0
83279: PUSH
83280: LD_INT 2
83282: NEG
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 2
83301: PUSH
83302: LD_INT 0
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 2
83311: PUSH
83312: LD_INT 1
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 2
83321: PUSH
83322: LD_INT 2
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 1
83331: PUSH
83332: LD_INT 2
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: LD_INT 2
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 1
83351: NEG
83352: PUSH
83353: LD_INT 1
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 2
83362: NEG
83363: PUSH
83364: LD_INT 0
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 2
83373: NEG
83374: PUSH
83375: LD_INT 1
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 2
83385: NEG
83386: PUSH
83387: LD_INT 2
83389: NEG
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 2
83397: PUSH
83398: LD_INT 3
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: PUSH
83408: LD_INT 3
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 1
83417: NEG
83418: PUSH
83419: LD_INT 2
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 2
83428: NEG
83429: PUSH
83430: LD_INT 1
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83462: LD_ADDR_VAR 0 27
83466: PUSH
83467: LD_INT 0
83469: PUSH
83470: LD_INT 0
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: LD_INT 1
83482: NEG
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: LD_INT 0
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 1
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 0
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 1
83520: NEG
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 1
83531: NEG
83532: PUSH
83533: LD_INT 1
83535: NEG
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: LD_INT 2
83558: NEG
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 1
83566: PUSH
83567: LD_INT 1
83569: NEG
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 2
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 2
83587: PUSH
83588: LD_INT 1
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 2
83597: PUSH
83598: LD_INT 2
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 1
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: LD_INT 2
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 1
83627: NEG
83628: PUSH
83629: LD_INT 1
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 2
83638: NEG
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 2
83649: NEG
83650: PUSH
83651: LD_INT 1
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 2
83661: NEG
83662: PUSH
83663: LD_INT 2
83665: NEG
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 1
83673: NEG
83674: PUSH
83675: LD_INT 2
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: PUSH
83682: LD_INT 2
83684: NEG
83685: PUSH
83686: LD_INT 1
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 3
83695: NEG
83696: PUSH
83697: LD_INT 1
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 3
83707: NEG
83708: PUSH
83709: LD_INT 2
83711: NEG
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83742: LD_ADDR_VAR 0 28
83746: PUSH
83747: LD_INT 0
83749: PUSH
83750: LD_INT 0
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: PUSH
83757: LD_INT 0
83759: PUSH
83760: LD_INT 1
83762: NEG
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PUSH
83768: LD_INT 1
83770: PUSH
83771: LD_INT 0
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 0
83790: PUSH
83791: LD_INT 1
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 1
83800: NEG
83801: PUSH
83802: LD_INT 0
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 1
83811: NEG
83812: PUSH
83813: LD_INT 1
83815: NEG
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 1
83823: NEG
83824: PUSH
83825: LD_INT 2
83827: NEG
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 0
83835: PUSH
83836: LD_INT 2
83838: NEG
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 1
83846: PUSH
83847: LD_INT 1
83849: NEG
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 2
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 2
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 2
83877: PUSH
83878: LD_INT 2
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 1
83887: PUSH
83888: LD_INT 2
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: LD_INT 2
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 1
83907: NEG
83908: PUSH
83909: LD_INT 1
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 2
83918: NEG
83919: PUSH
83920: LD_INT 0
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 2
83929: NEG
83930: PUSH
83931: LD_INT 1
83933: NEG
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 2
83941: NEG
83942: PUSH
83943: LD_INT 2
83945: NEG
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 2
83953: NEG
83954: PUSH
83955: LD_INT 3
83957: NEG
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: NEG
83966: PUSH
83967: LD_INT 3
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 3
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 3
83989: NEG
83990: PUSH
83991: LD_INT 2
83993: NEG
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84024: LD_ADDR_VAR 0 29
84028: PUSH
84029: LD_INT 0
84031: PUSH
84032: LD_INT 0
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: LD_INT 0
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: LD_INT 1
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: NEG
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 1
84105: NEG
84106: PUSH
84107: LD_INT 2
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 0
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 1
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 2
84139: PUSH
84140: LD_INT 0
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 2
84149: PUSH
84150: LD_INT 1
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: LD_INT 2
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 1
84179: NEG
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 2
84190: NEG
84191: PUSH
84192: LD_INT 1
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 2
84202: NEG
84203: PUSH
84204: LD_INT 2
84206: NEG
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 2
84214: NEG
84215: PUSH
84216: LD_INT 3
84218: NEG
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 2
84226: PUSH
84227: LD_INT 1
84229: NEG
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 3
84237: PUSH
84238: LD_INT 1
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 1
84247: PUSH
84248: LD_INT 3
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 1
84257: NEG
84258: PUSH
84259: LD_INT 2
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 3
84268: NEG
84269: PUSH
84270: LD_INT 2
84272: NEG
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84303: LD_ADDR_VAR 0 30
84307: PUSH
84308: LD_INT 0
84310: PUSH
84311: LD_INT 0
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 0
84320: PUSH
84321: LD_INT 1
84323: NEG
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 1
84331: PUSH
84332: LD_INT 0
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 1
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 0
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 0
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 1
84372: NEG
84373: PUSH
84374: LD_INT 1
84376: NEG
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: LD_INT 2
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: LD_INT 2
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: PUSH
84408: LD_INT 1
84410: NEG
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: LD_INT 0
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 1
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 1
84458: NEG
84459: PUSH
84460: LD_INT 1
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 2
84469: NEG
84470: PUSH
84471: LD_INT 0
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 2
84480: NEG
84481: PUSH
84482: LD_INT 1
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 1
84492: NEG
84493: PUSH
84494: LD_INT 3
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 1
84504: PUSH
84505: LD_INT 2
84507: NEG
84508: PUSH
84509: EMPTY
84510: LIST
84511: LIST
84512: PUSH
84513: LD_INT 3
84515: PUSH
84516: LD_INT 2
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 2
84525: PUSH
84526: LD_INT 3
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 2
84535: NEG
84536: PUSH
84537: LD_INT 1
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 3
84546: NEG
84547: PUSH
84548: LD_INT 1
84550: NEG
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84581: LD_ADDR_VAR 0 31
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 0
84598: PUSH
84599: LD_INT 1
84601: NEG
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 1
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 1
84619: PUSH
84620: LD_INT 1
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 0
84629: PUSH
84630: LD_INT 1
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 1
84639: NEG
84640: PUSH
84641: LD_INT 0
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 1
84650: NEG
84651: PUSH
84652: LD_INT 1
84654: NEG
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 1
84662: NEG
84663: PUSH
84664: LD_INT 2
84666: NEG
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: LD_INT 1
84677: NEG
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 2
84685: PUSH
84686: LD_INT 0
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 2
84695: PUSH
84696: LD_INT 1
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 2
84705: PUSH
84706: LD_INT 2
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 1
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 0
84725: PUSH
84726: LD_INT 2
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 1
84735: NEG
84736: PUSH
84737: LD_INT 1
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: LD_INT 1
84750: NEG
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 2
84758: NEG
84759: PUSH
84760: LD_INT 2
84762: NEG
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 2
84770: NEG
84771: PUSH
84772: LD_INT 3
84774: NEG
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 2
84782: PUSH
84783: LD_INT 1
84785: NEG
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 3
84793: PUSH
84794: LD_INT 1
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 1
84803: PUSH
84804: LD_INT 3
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 1
84813: NEG
84814: PUSH
84815: LD_INT 2
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 3
84824: NEG
84825: PUSH
84826: LD_INT 2
84828: NEG
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84859: LD_ADDR_VAR 0 32
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 0
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 0
84876: PUSH
84877: LD_INT 1
84879: NEG
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 0
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: NEG
84941: PUSH
84942: LD_INT 2
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: PUSH
84964: LD_INT 1
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 0
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 1
85014: NEG
85015: PUSH
85016: LD_INT 1
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PUSH
85023: LD_INT 2
85025: NEG
85026: PUSH
85027: LD_INT 0
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PUSH
85034: LD_INT 2
85036: NEG
85037: PUSH
85038: LD_INT 1
85040: NEG
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 1
85048: NEG
85049: PUSH
85050: LD_INT 3
85052: NEG
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 1
85060: PUSH
85061: LD_INT 2
85063: NEG
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 3
85071: PUSH
85072: LD_INT 2
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 2
85081: PUSH
85082: LD_INT 3
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 2
85091: NEG
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 3
85102: NEG
85103: PUSH
85104: LD_INT 1
85106: NEG
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85137: LD_ADDR_VAR 0 33
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: LD_INT 0
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 0
85154: PUSH
85155: LD_INT 1
85157: NEG
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 1
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 1
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 0
85185: PUSH
85186: LD_INT 1
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 1
85195: NEG
85196: PUSH
85197: LD_INT 0
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: LD_INT 1
85210: NEG
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 1
85218: NEG
85219: PUSH
85220: LD_INT 2
85222: NEG
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 2
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 2
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: NEG
85282: PUSH
85283: LD_INT 1
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 2
85292: NEG
85293: PUSH
85294: LD_INT 0
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 2
85303: NEG
85304: PUSH
85305: LD_INT 1
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 2
85315: NEG
85316: PUSH
85317: LD_INT 2
85319: NEG
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 2
85327: NEG
85328: PUSH
85329: LD_INT 3
85331: NEG
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: LD_INT 2
85339: PUSH
85340: LD_INT 1
85342: NEG
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 3
85350: PUSH
85351: LD_INT 1
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 1
85360: PUSH
85361: LD_INT 3
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: LD_INT 2
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 3
85381: NEG
85382: PUSH
85383: LD_INT 2
85385: NEG
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85416: LD_ADDR_VAR 0 34
85420: PUSH
85421: LD_INT 0
85423: PUSH
85424: LD_INT 0
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 1
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: PUSH
85455: LD_INT 1
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 0
85464: PUSH
85465: LD_INT 1
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: NEG
85475: PUSH
85476: LD_INT 0
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 1
85485: NEG
85486: PUSH
85487: LD_INT 1
85489: NEG
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 1
85497: NEG
85498: PUSH
85499: LD_INT 2
85501: NEG
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 0
85509: PUSH
85510: LD_INT 2
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 1
85520: PUSH
85521: LD_INT 1
85523: NEG
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: LD_INT 2
85531: PUSH
85532: LD_INT 1
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 2
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 1
85551: PUSH
85552: LD_INT 2
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 1
85561: NEG
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 2
85572: NEG
85573: PUSH
85574: LD_INT 0
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 2
85583: NEG
85584: PUSH
85585: LD_INT 1
85587: NEG
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 2
85595: NEG
85596: PUSH
85597: LD_INT 2
85599: NEG
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 1
85607: NEG
85608: PUSH
85609: LD_INT 3
85611: NEG
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 2
85622: NEG
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 3
85630: PUSH
85631: LD_INT 2
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 2
85640: PUSH
85641: LD_INT 3
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: NEG
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 3
85661: NEG
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85696: LD_ADDR_VAR 0 35
85700: PUSH
85701: LD_INT 0
85703: PUSH
85704: LD_INT 0
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: LD_INT 0
85713: PUSH
85714: LD_INT 1
85716: NEG
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PUSH
85722: LD_INT 1
85724: PUSH
85725: LD_INT 0
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: LD_INT 1
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 0
85744: PUSH
85745: LD_INT 1
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 1
85754: NEG
85755: PUSH
85756: LD_INT 0
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 1
85765: NEG
85766: PUSH
85767: LD_INT 1
85769: NEG
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: LD_INT 2
85777: PUSH
85778: LD_INT 1
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 2
85787: NEG
85788: PUSH
85789: LD_INT 1
85791: NEG
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85808: LD_ADDR_VAR 0 36
85812: PUSH
85813: LD_INT 0
85815: PUSH
85816: LD_INT 0
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 0
85825: PUSH
85826: LD_INT 1
85828: NEG
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 1
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 1
85846: PUSH
85847: LD_INT 1
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 0
85856: PUSH
85857: LD_INT 1
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 1
85866: NEG
85867: PUSH
85868: LD_INT 0
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 1
85877: NEG
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 1
85889: NEG
85890: PUSH
85891: LD_INT 2
85893: NEG
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: PUSH
85902: LD_INT 2
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85920: LD_ADDR_VAR 0 37
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: LD_INT 0
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: LD_INT 1
85940: NEG
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: LD_INT 1
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 1
85958: PUSH
85959: LD_INT 1
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 0
85968: PUSH
85969: LD_INT 1
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: NEG
85979: PUSH
85980: LD_INT 0
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: NEG
85990: PUSH
85991: LD_INT 1
85993: NEG
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86032: LD_ADDR_VAR 0 38
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: LD_INT 0
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: PUSH
86047: LD_INT 0
86049: PUSH
86050: LD_INT 1
86052: NEG
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: PUSH
86061: LD_INT 0
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: LD_INT 1
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 0
86080: PUSH
86081: LD_INT 1
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 1
86090: NEG
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 2
86113: PUSH
86114: LD_INT 1
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 2
86123: NEG
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86144: LD_ADDR_VAR 0 39
86148: PUSH
86149: LD_INT 0
86151: PUSH
86152: LD_INT 0
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 0
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 1
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 1
86182: PUSH
86183: LD_INT 1
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: LD_INT 1
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: NEG
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 1
86225: NEG
86226: PUSH
86227: LD_INT 2
86229: NEG
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: LD_INT 2
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: LIST
86254: LIST
86255: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86256: LD_ADDR_VAR 0 40
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: LD_INT 1
86276: NEG
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: LD_INT 1
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: LD_INT 1
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 1
86325: NEG
86326: PUSH
86327: LD_INT 1
86329: NEG
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: LD_INT 1
86340: NEG
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 1
86348: NEG
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86368: LD_ADDR_VAR 0 41
86372: PUSH
86373: LD_INT 0
86375: PUSH
86376: LD_INT 0
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: LD_INT 1
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 1
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 1
86406: PUSH
86407: LD_INT 1
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: LD_INT 1
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 1
86426: NEG
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 1
86437: NEG
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 1
86449: NEG
86450: PUSH
86451: LD_INT 2
86453: NEG
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: LD_INT 1
86464: NEG
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: LD_INT 0
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 2
86482: PUSH
86483: LD_INT 1
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 2
86492: PUSH
86493: LD_INT 2
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 1
86502: PUSH
86503: LD_INT 2
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: LD_INT 1
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 2
86523: NEG
86524: PUSH
86525: LD_INT 0
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: LD_INT 1
86538: NEG
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 2
86546: NEG
86547: PUSH
86548: LD_INT 2
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 2
86558: NEG
86559: PUSH
86560: LD_INT 3
86562: NEG
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 2
86570: PUSH
86571: LD_INT 1
86573: NEG
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 3
86581: PUSH
86582: LD_INT 0
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 3
86591: PUSH
86592: LD_INT 1
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 3
86601: PUSH
86602: LD_INT 2
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 3
86611: PUSH
86612: LD_INT 3
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: LD_INT 2
86621: PUSH
86622: LD_INT 3
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 2
86631: NEG
86632: PUSH
86633: LD_INT 1
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 3
86642: NEG
86643: PUSH
86644: LD_INT 0
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 3
86653: NEG
86654: PUSH
86655: LD_INT 1
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 3
86665: NEG
86666: PUSH
86667: LD_INT 2
86669: NEG
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: LD_INT 3
86677: NEG
86678: PUSH
86679: LD_INT 3
86681: NEG
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86718: LD_ADDR_VAR 0 42
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 1
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 0
86811: PUSH
86812: LD_INT 2
86814: NEG
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: LD_INT 1
86825: NEG
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 2
86833: PUSH
86834: LD_INT 1
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 2
86843: PUSH
86844: LD_INT 2
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 0
86863: PUSH
86864: LD_INT 2
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 1
86873: NEG
86874: PUSH
86875: LD_INT 1
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 2
86896: NEG
86897: PUSH
86898: LD_INT 2
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 1
86920: NEG
86921: PUSH
86922: LD_INT 3
86924: NEG
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 0
86932: PUSH
86933: LD_INT 3
86935: NEG
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 1
86943: PUSH
86944: LD_INT 2
86946: NEG
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 3
86954: PUSH
86955: LD_INT 2
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: LD_INT 3
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: LD_INT 2
86974: PUSH
86975: LD_INT 3
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: LD_INT 3
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 0
86994: PUSH
86995: LD_INT 3
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 1
87004: NEG
87005: PUSH
87006: LD_INT 2
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 3
87027: NEG
87028: PUSH
87029: LD_INT 3
87031: NEG
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87068: LD_ADDR_VAR 0 43
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: LD_INT 0
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 1
87106: PUSH
87107: LD_INT 1
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 1
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 1
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: LD_INT 2
87153: NEG
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: LD_INT 0
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: LD_INT 1
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 2
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 2
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 1
87223: NEG
87224: PUSH
87225: LD_INT 1
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 2
87234: NEG
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 2
87245: NEG
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: NEG
87258: PUSH
87259: LD_INT 3
87261: NEG
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: LD_INT 3
87272: NEG
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 1
87280: PUSH
87281: LD_INT 2
87283: NEG
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: PUSH
87289: LD_INT 2
87291: PUSH
87292: LD_INT 1
87294: NEG
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: LD_INT 3
87302: PUSH
87303: LD_INT 0
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: LD_INT 1
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: LD_INT 3
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: LD_INT 3
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: NEG
87343: PUSH
87344: LD_INT 2
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 2
87353: NEG
87354: PUSH
87355: LD_INT 1
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 3
87364: NEG
87365: PUSH
87366: LD_INT 0
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 3
87375: NEG
87376: PUSH
87377: LD_INT 1
87379: NEG
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87416: LD_ADDR_VAR 0 44
87420: PUSH
87421: LD_INT 0
87423: PUSH
87424: LD_INT 0
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 1
87436: NEG
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: LD_INT 0
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: LD_INT 1
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 1
87485: NEG
87486: PUSH
87487: LD_INT 1
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: NEG
87498: PUSH
87499: LD_INT 2
87501: NEG
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 2
87530: PUSH
87531: LD_INT 1
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: PUSH
87541: LD_INT 2
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: LD_INT 2
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 1
87560: NEG
87561: PUSH
87562: LD_INT 1
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 2
87571: NEG
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 2
87582: NEG
87583: PUSH
87584: LD_INT 1
87586: NEG
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 2
87594: NEG
87595: PUSH
87596: LD_INT 2
87598: NEG
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 2
87606: NEG
87607: PUSH
87608: LD_INT 3
87610: NEG
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 2
87618: PUSH
87619: LD_INT 1
87621: NEG
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 3
87629: PUSH
87630: LD_INT 0
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 3
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 3
87649: PUSH
87650: LD_INT 2
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 3
87659: PUSH
87660: LD_INT 3
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: PUSH
87670: LD_INT 3
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 2
87679: NEG
87680: PUSH
87681: LD_INT 1
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 3
87690: NEG
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 3
87701: NEG
87702: PUSH
87703: LD_INT 1
87705: NEG
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 3
87713: NEG
87714: PUSH
87715: LD_INT 2
87717: NEG
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 3
87725: NEG
87726: PUSH
87727: LD_INT 3
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87766: LD_ADDR_VAR 0 45
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 1
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: NEG
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: LD_INT 2
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: LD_INT 2
87862: NEG
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 1
87870: PUSH
87871: LD_INT 1
87873: NEG
87874: PUSH
87875: EMPTY
87876: LIST
87877: LIST
87878: PUSH
87879: LD_INT 2
87881: PUSH
87882: LD_INT 1
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 2
87891: PUSH
87892: LD_INT 2
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 1
87901: PUSH
87902: LD_INT 2
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 0
87911: PUSH
87912: LD_INT 2
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 1
87921: NEG
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: NEG
87945: PUSH
87946: LD_INT 2
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: LD_INT 3
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 1
87968: NEG
87969: PUSH
87970: LD_INT 3
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 0
87980: PUSH
87981: LD_INT 3
87983: NEG
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 1
87991: PUSH
87992: LD_INT 2
87994: NEG
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 3
88002: PUSH
88003: LD_INT 2
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 3
88012: PUSH
88013: LD_INT 3
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 2
88022: PUSH
88023: LD_INT 3
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 1
88032: PUSH
88033: LD_INT 3
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 0
88042: PUSH
88043: LD_INT 3
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: LD_INT 2
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 3
88063: NEG
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 3
88075: NEG
88076: PUSH
88077: LD_INT 3
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88116: LD_ADDR_VAR 0 46
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: LD_INT 1
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: LD_INT 1
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 1
88174: NEG
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: LD_INT 2
88201: NEG
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 1
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 2
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 1
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: LD_INT 2
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: NEG
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: NEG
88283: PUSH
88284: LD_INT 0
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 2
88293: NEG
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: LD_INT 3
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: LD_INT 3
88320: NEG
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: LD_INT 2
88331: NEG
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: LD_INT 1
88342: NEG
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 3
88350: PUSH
88351: LD_INT 0
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 3
88360: PUSH
88361: LD_INT 1
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 1
88370: PUSH
88371: LD_INT 3
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 0
88380: PUSH
88381: LD_INT 3
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 1
88390: NEG
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 2
88401: NEG
88402: PUSH
88403: LD_INT 1
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 3
88412: NEG
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 3
88423: NEG
88424: PUSH
88425: LD_INT 1
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88464: LD_ADDR_VAR 0 47
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: LD_INT 0
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: PUSH
88479: LD_INT 0
88481: PUSH
88482: LD_INT 1
88484: NEG
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 1
88492: PUSH
88493: LD_INT 0
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: PUSH
88503: LD_INT 1
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 0
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 1
88522: NEG
88523: PUSH
88524: LD_INT 0
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 1
88533: NEG
88534: PUSH
88535: LD_INT 1
88537: NEG
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 1
88545: NEG
88546: PUSH
88547: LD_INT 2
88549: NEG
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: LD_INT 2
88560: NEG
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 1
88568: PUSH
88569: LD_INT 1
88571: NEG
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: NEG
88580: PUSH
88581: LD_INT 1
88583: NEG
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 2
88591: NEG
88592: PUSH
88593: LD_INT 2
88595: NEG
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88615: LD_ADDR_VAR 0 48
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: LD_INT 0
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: LD_INT 1
88635: NEG
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 1
88643: PUSH
88644: LD_INT 0
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 0
88663: PUSH
88664: LD_INT 1
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 1
88673: NEG
88674: PUSH
88675: LD_INT 0
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: LD_INT 1
88684: NEG
88685: PUSH
88686: LD_INT 1
88688: NEG
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PUSH
88694: LD_INT 1
88696: NEG
88697: PUSH
88698: LD_INT 2
88700: NEG
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PUSH
88706: LD_INT 0
88708: PUSH
88709: LD_INT 2
88711: NEG
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 1
88719: PUSH
88720: LD_INT 1
88722: NEG
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 2
88730: PUSH
88731: LD_INT 0
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 2
88740: PUSH
88741: LD_INT 1
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88762: LD_ADDR_VAR 0 49
88766: PUSH
88767: LD_INT 0
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 0
88779: PUSH
88780: LD_INT 1
88782: NEG
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 1
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: LD_INT 1
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: LD_INT 1
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 1
88820: NEG
88821: PUSH
88822: LD_INT 0
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 1
88831: NEG
88832: PUSH
88833: LD_INT 1
88835: NEG
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: LD_INT 1
88843: PUSH
88844: LD_INT 1
88846: NEG
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PUSH
88852: LD_INT 2
88854: PUSH
88855: LD_INT 0
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: PUSH
88862: LD_INT 2
88864: PUSH
88865: LD_INT 1
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 2
88874: PUSH
88875: LD_INT 2
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 1
88884: PUSH
88885: LD_INT 2
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88906: LD_ADDR_VAR 0 50
88910: PUSH
88911: LD_INT 0
88913: PUSH
88914: LD_INT 0
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: LD_INT 1
88926: NEG
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 1
88934: PUSH
88935: LD_INT 0
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: PUSH
88945: LD_INT 1
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 0
88954: PUSH
88955: LD_INT 1
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 1
88964: NEG
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 1
88975: NEG
88976: PUSH
88977: LD_INT 1
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 1
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 0
89017: PUSH
89018: LD_INT 2
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 1
89027: NEG
89028: PUSH
89029: LD_INT 1
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89050: LD_ADDR_VAR 0 51
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 0
89067: PUSH
89068: LD_INT 1
89070: NEG
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 1
89078: PUSH
89079: LD_INT 0
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 1
89088: PUSH
89089: LD_INT 1
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 0
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: NEG
89120: PUSH
89121: LD_INT 1
89123: NEG
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 1
89131: PUSH
89132: LD_INT 2
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PUSH
89139: LD_INT 0
89141: PUSH
89142: LD_INT 2
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 1
89151: NEG
89152: PUSH
89153: LD_INT 1
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 2
89162: NEG
89163: PUSH
89164: LD_INT 0
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: LD_INT 1
89177: NEG
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89197: LD_ADDR_VAR 0 52
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: LD_INT 0
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 1
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: LD_INT 1
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 1
89255: NEG
89256: PUSH
89257: LD_INT 0
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 1
89270: NEG
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: LD_INT 2
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 2
89301: NEG
89302: PUSH
89303: LD_INT 0
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 2
89312: NEG
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 2
89324: NEG
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89348: LD_ADDR_VAR 0 53
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 0
89365: PUSH
89366: LD_INT 1
89368: NEG
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: PUSH
89374: LD_INT 1
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 1
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 0
89396: PUSH
89397: LD_INT 1
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PUSH
89404: LD_INT 1
89406: NEG
89407: PUSH
89408: LD_INT 0
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 1
89417: NEG
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: PUSH
89427: LD_INT 1
89429: NEG
89430: PUSH
89431: LD_INT 2
89433: NEG
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: LD_INT 2
89444: NEG
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 1
89452: PUSH
89453: LD_INT 1
89455: NEG
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PUSH
89461: LD_INT 2
89463: PUSH
89464: LD_INT 0
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 2
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: LD_INT 2
89483: PUSH
89484: LD_INT 2
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PUSH
89491: LD_INT 1
89493: PUSH
89494: LD_INT 2
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: LD_INT 2
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: NEG
89514: PUSH
89515: LD_INT 1
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 2
89524: NEG
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 2
89535: NEG
89536: PUSH
89537: LD_INT 1
89539: NEG
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 2
89547: NEG
89548: PUSH
89549: LD_INT 2
89551: NEG
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89578: LD_ADDR_VAR 0 54
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: LD_INT 0
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: PUSH
89617: LD_INT 1
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 0
89626: PUSH
89627: LD_INT 1
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 1
89647: NEG
89648: PUSH
89649: LD_INT 1
89651: NEG
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 1
89659: NEG
89660: PUSH
89661: LD_INT 2
89663: NEG
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 0
89671: PUSH
89672: LD_INT 2
89674: NEG
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 1
89682: PUSH
89683: LD_INT 1
89685: NEG
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 2
89693: PUSH
89694: LD_INT 0
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 2
89703: PUSH
89704: LD_INT 1
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 2
89713: PUSH
89714: LD_INT 2
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: LD_INT 2
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: PUSH
89731: LD_INT 0
89733: PUSH
89734: LD_INT 2
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 1
89743: NEG
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 2
89754: NEG
89755: PUSH
89756: LD_INT 0
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 2
89765: NEG
89766: PUSH
89767: LD_INT 1
89769: NEG
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 2
89777: NEG
89778: PUSH
89779: LD_INT 2
89781: NEG
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89808: LD_ADDR_VAR 0 55
89812: PUSH
89813: LD_INT 0
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 0
89825: PUSH
89826: LD_INT 1
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 1
89836: PUSH
89837: LD_INT 0
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 0
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 1
89866: NEG
89867: PUSH
89868: LD_INT 0
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 1
89877: NEG
89878: PUSH
89879: LD_INT 1
89881: NEG
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: LD_INT 2
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: LD_INT 2
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 1
89912: PUSH
89913: LD_INT 1
89915: NEG
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PUSH
89921: LD_INT 2
89923: PUSH
89924: LD_INT 0
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: PUSH
89931: LD_INT 2
89933: PUSH
89934: LD_INT 1
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 2
89943: PUSH
89944: LD_INT 2
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 1
89953: PUSH
89954: LD_INT 2
89956: PUSH
89957: EMPTY
89958: LIST
89959: LIST
89960: PUSH
89961: LD_INT 0
89963: PUSH
89964: LD_INT 2
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 1
89973: NEG
89974: PUSH
89975: LD_INT 1
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 2
89984: NEG
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 2
89995: NEG
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 2
90007: NEG
90008: PUSH
90009: LD_INT 2
90011: NEG
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90038: LD_ADDR_VAR 0 56
90042: PUSH
90043: LD_INT 0
90045: PUSH
90046: LD_INT 0
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 0
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 1
90066: PUSH
90067: LD_INT 0
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 1
90076: PUSH
90077: LD_INT 1
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: LD_INT 1
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: PUSH
90098: LD_INT 0
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 1
90107: NEG
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 1
90119: NEG
90120: PUSH
90121: LD_INT 2
90123: NEG
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: LD_INT 0
90131: PUSH
90132: LD_INT 2
90134: NEG
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 1
90142: PUSH
90143: LD_INT 1
90145: NEG
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 2
90153: PUSH
90154: LD_INT 0
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 2
90163: PUSH
90164: LD_INT 1
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 2
90173: PUSH
90174: LD_INT 2
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: LD_INT 2
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 0
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 1
90203: NEG
90204: PUSH
90205: LD_INT 1
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 2
90214: NEG
90215: PUSH
90216: LD_INT 0
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: NEG
90226: PUSH
90227: LD_INT 1
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 2
90237: NEG
90238: PUSH
90239: LD_INT 2
90241: NEG
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90268: LD_ADDR_VAR 0 57
90272: PUSH
90273: LD_INT 0
90275: PUSH
90276: LD_INT 0
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PUSH
90283: LD_INT 0
90285: PUSH
90286: LD_INT 1
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 1
90296: PUSH
90297: LD_INT 0
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PUSH
90304: LD_INT 1
90306: PUSH
90307: LD_INT 1
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: LD_INT 1
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: LD_INT 0
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: NEG
90338: PUSH
90339: LD_INT 1
90341: NEG
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 1
90349: NEG
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 0
90361: PUSH
90362: LD_INT 2
90364: NEG
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: LD_INT 1
90372: PUSH
90373: LD_INT 1
90375: NEG
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 2
90383: PUSH
90384: LD_INT 0
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 2
90393: PUSH
90394: LD_INT 1
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: LD_INT 2
90403: PUSH
90404: LD_INT 2
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 1
90413: PUSH
90414: LD_INT 2
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 0
90423: PUSH
90424: LD_INT 2
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 1
90433: NEG
90434: PUSH
90435: LD_INT 1
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 2
90444: NEG
90445: PUSH
90446: LD_INT 0
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: NEG
90456: PUSH
90457: LD_INT 1
90459: NEG
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 2
90467: NEG
90468: PUSH
90469: LD_INT 2
90471: NEG
90472: PUSH
90473: EMPTY
90474: LIST
90475: LIST
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90498: LD_ADDR_VAR 0 58
90502: PUSH
90503: LD_INT 0
90505: PUSH
90506: LD_INT 0
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 0
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: PUSH
90527: LD_INT 0
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 1
90536: PUSH
90537: LD_INT 1
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PUSH
90544: LD_INT 0
90546: PUSH
90547: LD_INT 1
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 1
90556: NEG
90557: PUSH
90558: LD_INT 0
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 1
90567: NEG
90568: PUSH
90569: LD_INT 1
90571: NEG
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 1
90579: NEG
90580: PUSH
90581: LD_INT 2
90583: NEG
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: LD_INT 2
90594: NEG
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 1
90602: PUSH
90603: LD_INT 1
90605: NEG
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 2
90613: PUSH
90614: LD_INT 0
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 2
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 2
90633: PUSH
90634: LD_INT 2
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 1
90643: PUSH
90644: LD_INT 2
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 0
90653: PUSH
90654: LD_INT 2
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 1
90663: NEG
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 2
90674: NEG
90675: PUSH
90676: LD_INT 0
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 2
90685: NEG
90686: PUSH
90687: LD_INT 1
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 2
90697: NEG
90698: PUSH
90699: LD_INT 2
90701: NEG
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90728: LD_ADDR_VAR 0 59
90732: PUSH
90733: LD_INT 0
90735: PUSH
90736: LD_INT 0
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 0
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 1
90756: PUSH
90757: LD_INT 0
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 1
90766: PUSH
90767: LD_INT 1
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: LD_INT 1
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: LD_INT 0
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 1
90797: NEG
90798: PUSH
90799: LD_INT 1
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90816: LD_ADDR_VAR 0 60
90820: PUSH
90821: LD_INT 0
90823: PUSH
90824: LD_INT 0
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 0
90833: PUSH
90834: LD_INT 1
90836: NEG
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: LD_INT 0
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: LD_INT 1
90854: PUSH
90855: LD_INT 1
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: PUSH
90862: LD_INT 0
90864: PUSH
90865: LD_INT 1
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 1
90874: NEG
90875: PUSH
90876: LD_INT 0
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: LD_INT 1
90889: NEG
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90904: LD_ADDR_VAR 0 61
90908: PUSH
90909: LD_INT 0
90911: PUSH
90912: LD_INT 0
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 0
90921: PUSH
90922: LD_INT 1
90924: NEG
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: LD_INT 1
90932: PUSH
90933: LD_INT 0
90935: PUSH
90936: EMPTY
90937: LIST
90938: LIST
90939: PUSH
90940: LD_INT 1
90942: PUSH
90943: LD_INT 1
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 0
90952: PUSH
90953: LD_INT 1
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PUSH
90960: LD_INT 1
90962: NEG
90963: PUSH
90964: LD_INT 0
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 1
90973: NEG
90974: PUSH
90975: LD_INT 1
90977: NEG
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90992: LD_ADDR_VAR 0 62
90996: PUSH
90997: LD_INT 0
90999: PUSH
91000: LD_INT 0
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: LD_INT 1
91012: NEG
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 1
91020: PUSH
91021: LD_INT 0
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 1
91030: PUSH
91031: LD_INT 1
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 0
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 1
91050: NEG
91051: PUSH
91052: LD_INT 0
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 1
91061: NEG
91062: PUSH
91063: LD_INT 1
91065: NEG
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91080: LD_ADDR_VAR 0 63
91084: PUSH
91085: LD_INT 0
91087: PUSH
91088: LD_INT 0
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: LD_INT 1
91100: NEG
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 1
91108: PUSH
91109: LD_INT 0
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 1
91118: PUSH
91119: LD_INT 1
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 0
91128: PUSH
91129: LD_INT 1
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: LD_INT 1
91138: NEG
91139: PUSH
91140: LD_INT 0
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 1
91149: NEG
91150: PUSH
91151: LD_INT 1
91153: NEG
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91168: LD_ADDR_VAR 0 64
91172: PUSH
91173: LD_INT 0
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 1
91188: NEG
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: PUSH
91194: LD_INT 1
91196: PUSH
91197: LD_INT 0
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 1
91206: PUSH
91207: LD_INT 1
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 1
91226: NEG
91227: PUSH
91228: LD_INT 0
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: LD_INT 1
91241: NEG
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: ST_TO_ADDR
// end ; 1 :
91256: GO 97153
91258: LD_INT 1
91260: DOUBLE
91261: EQUAL
91262: IFTRUE 91266
91264: GO 93889
91266: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91267: LD_ADDR_VAR 0 11
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: LD_INT 3
91278: NEG
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: LD_INT 3
91289: NEG
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 1
91297: PUSH
91298: LD_INT 2
91300: NEG
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: LIST
91310: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91311: LD_ADDR_VAR 0 12
91315: PUSH
91316: LD_INT 2
91318: PUSH
91319: LD_INT 1
91321: NEG
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 3
91329: PUSH
91330: LD_INT 0
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 3
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: LIST
91351: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91352: LD_ADDR_VAR 0 13
91356: PUSH
91357: LD_INT 3
91359: PUSH
91360: LD_INT 2
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 3
91369: PUSH
91370: LD_INT 3
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 2
91379: PUSH
91380: LD_INT 3
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91392: LD_ADDR_VAR 0 14
91396: PUSH
91397: LD_INT 1
91399: PUSH
91400: LD_INT 3
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 0
91409: PUSH
91410: LD_INT 3
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: NEG
91420: PUSH
91421: LD_INT 2
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: LIST
91432: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91433: LD_ADDR_VAR 0 15
91437: PUSH
91438: LD_INT 2
91440: NEG
91441: PUSH
91442: LD_INT 1
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 3
91451: NEG
91452: PUSH
91453: LD_INT 0
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 3
91462: NEG
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: LIST
91476: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91477: LD_ADDR_VAR 0 16
91481: PUSH
91482: LD_INT 2
91484: NEG
91485: PUSH
91486: LD_INT 3
91488: NEG
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 3
91496: NEG
91497: PUSH
91498: LD_INT 2
91500: NEG
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 3
91508: NEG
91509: PUSH
91510: LD_INT 3
91512: NEG
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: LIST
91522: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91523: LD_ADDR_VAR 0 17
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: LD_INT 3
91534: NEG
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: LD_INT 3
91545: NEG
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: LD_INT 2
91556: NEG
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: LIST
91566: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91567: LD_ADDR_VAR 0 18
91571: PUSH
91572: LD_INT 2
91574: PUSH
91575: LD_INT 1
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 3
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 3
91595: PUSH
91596: LD_INT 1
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: LIST
91607: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91608: LD_ADDR_VAR 0 19
91612: PUSH
91613: LD_INT 3
91615: PUSH
91616: LD_INT 2
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 3
91625: PUSH
91626: LD_INT 3
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 2
91635: PUSH
91636: LD_INT 3
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: LIST
91647: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91648: LD_ADDR_VAR 0 20
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: LD_INT 3
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: PUSH
91663: LD_INT 0
91665: PUSH
91666: LD_INT 3
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 1
91675: NEG
91676: PUSH
91677: LD_INT 2
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: LIST
91688: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91689: LD_ADDR_VAR 0 21
91693: PUSH
91694: LD_INT 2
91696: NEG
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 3
91707: NEG
91708: PUSH
91709: LD_INT 0
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 3
91718: NEG
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91733: LD_ADDR_VAR 0 22
91737: PUSH
91738: LD_INT 2
91740: NEG
91741: PUSH
91742: LD_INT 3
91744: NEG
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 3
91752: NEG
91753: PUSH
91754: LD_INT 2
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: LD_INT 3
91768: NEG
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91779: LD_ADDR_VAR 0 23
91783: PUSH
91784: LD_INT 0
91786: PUSH
91787: LD_INT 3
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 1
91797: NEG
91798: PUSH
91799: LD_INT 4
91801: NEG
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 1
91809: PUSH
91810: LD_INT 3
91812: NEG
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: LIST
91822: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91823: LD_ADDR_VAR 0 24
91827: PUSH
91828: LD_INT 3
91830: PUSH
91831: LD_INT 0
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: PUSH
91838: LD_INT 3
91840: PUSH
91841: LD_INT 1
91843: NEG
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: PUSH
91849: LD_INT 4
91851: PUSH
91852: LD_INT 1
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: LIST
91863: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91864: LD_ADDR_VAR 0 25
91868: PUSH
91869: LD_INT 3
91871: PUSH
91872: LD_INT 3
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 4
91881: PUSH
91882: LD_INT 3
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: LD_INT 3
91891: PUSH
91892: LD_INT 4
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: LIST
91903: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91904: LD_ADDR_VAR 0 26
91908: PUSH
91909: LD_INT 0
91911: PUSH
91912: LD_INT 3
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 1
91921: PUSH
91922: LD_INT 4
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 1
91931: NEG
91932: PUSH
91933: LD_INT 3
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: LIST
91944: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91945: LD_ADDR_VAR 0 27
91949: PUSH
91950: LD_INT 3
91952: NEG
91953: PUSH
91954: LD_INT 0
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 3
91963: NEG
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 4
91974: NEG
91975: PUSH
91976: LD_INT 1
91978: NEG
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: LIST
91988: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91989: LD_ADDR_VAR 0 28
91993: PUSH
91994: LD_INT 3
91996: NEG
91997: PUSH
91998: LD_INT 3
92000: NEG
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 3
92008: NEG
92009: PUSH
92010: LD_INT 4
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 4
92020: NEG
92021: PUSH
92022: LD_INT 3
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: LIST
92034: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92035: LD_ADDR_VAR 0 29
92039: PUSH
92040: LD_INT 1
92042: NEG
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 1
92065: PUSH
92066: LD_INT 2
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 1
92076: NEG
92077: PUSH
92078: LD_INT 4
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 4
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 1
92110: NEG
92111: PUSH
92112: LD_INT 5
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 0
92122: PUSH
92123: LD_INT 5
92125: NEG
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: LD_INT 1
92133: PUSH
92134: LD_INT 4
92136: NEG
92137: PUSH
92138: EMPTY
92139: LIST
92140: LIST
92141: PUSH
92142: LD_INT 1
92144: NEG
92145: PUSH
92146: LD_INT 6
92148: NEG
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: LD_INT 0
92156: PUSH
92157: LD_INT 6
92159: NEG
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 1
92167: PUSH
92168: LD_INT 5
92170: NEG
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92190: LD_ADDR_VAR 0 30
92194: PUSH
92195: LD_INT 2
92197: PUSH
92198: LD_INT 1
92200: NEG
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 3
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 3
92218: PUSH
92219: LD_INT 1
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 3
92228: PUSH
92229: LD_INT 1
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 4
92239: PUSH
92240: LD_INT 0
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 4
92249: PUSH
92250: LD_INT 1
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 4
92259: PUSH
92260: LD_INT 1
92262: NEG
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 5
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 5
92280: PUSH
92281: LD_INT 1
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 5
92290: PUSH
92291: LD_INT 1
92293: NEG
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 6
92301: PUSH
92302: LD_INT 0
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 6
92311: PUSH
92312: LD_INT 1
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92333: LD_ADDR_VAR 0 31
92337: PUSH
92338: LD_INT 3
92340: PUSH
92341: LD_INT 2
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PUSH
92348: LD_INT 3
92350: PUSH
92351: LD_INT 3
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 2
92360: PUSH
92361: LD_INT 3
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 4
92370: PUSH
92371: LD_INT 3
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 4
92380: PUSH
92381: LD_INT 4
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 3
92390: PUSH
92391: LD_INT 4
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: LD_INT 5
92400: PUSH
92401: LD_INT 4
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: PUSH
92408: LD_INT 5
92410: PUSH
92411: LD_INT 5
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: PUSH
92418: LD_INT 4
92420: PUSH
92421: LD_INT 5
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: PUSH
92428: LD_INT 6
92430: PUSH
92431: LD_INT 5
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: PUSH
92438: LD_INT 6
92440: PUSH
92441: LD_INT 6
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 5
92450: PUSH
92451: LD_INT 6
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92472: LD_ADDR_VAR 0 32
92476: PUSH
92477: LD_INT 1
92479: PUSH
92480: LD_INT 3
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 0
92489: PUSH
92490: LD_INT 3
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 1
92499: NEG
92500: PUSH
92501: LD_INT 2
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 1
92510: PUSH
92511: LD_INT 4
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 0
92520: PUSH
92521: LD_INT 4
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 1
92530: NEG
92531: PUSH
92532: LD_INT 3
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: LD_INT 5
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: PUSH
92549: LD_INT 0
92551: PUSH
92552: LD_INT 5
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 1
92561: NEG
92562: PUSH
92563: LD_INT 4
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: LD_INT 6
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 0
92582: PUSH
92583: LD_INT 6
92585: PUSH
92586: EMPTY
92587: LIST
92588: LIST
92589: PUSH
92590: LD_INT 1
92592: NEG
92593: PUSH
92594: LD_INT 5
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92615: LD_ADDR_VAR 0 33
92619: PUSH
92620: LD_INT 2
92622: NEG
92623: PUSH
92624: LD_INT 1
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 3
92633: NEG
92634: PUSH
92635: LD_INT 0
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 3
92644: NEG
92645: PUSH
92646: LD_INT 1
92648: NEG
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 3
92656: NEG
92657: PUSH
92658: LD_INT 1
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 4
92667: NEG
92668: PUSH
92669: LD_INT 0
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 4
92678: NEG
92679: PUSH
92680: LD_INT 1
92682: NEG
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 4
92690: NEG
92691: PUSH
92692: LD_INT 1
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 5
92701: NEG
92702: PUSH
92703: LD_INT 0
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 5
92712: NEG
92713: PUSH
92714: LD_INT 1
92716: NEG
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 5
92724: NEG
92725: PUSH
92726: LD_INT 1
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 6
92735: NEG
92736: PUSH
92737: LD_INT 0
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 6
92746: NEG
92747: PUSH
92748: LD_INT 1
92750: NEG
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92770: LD_ADDR_VAR 0 34
92774: PUSH
92775: LD_INT 2
92777: NEG
92778: PUSH
92779: LD_INT 3
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 3
92789: NEG
92790: PUSH
92791: LD_INT 2
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 3
92801: NEG
92802: PUSH
92803: LD_INT 3
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 3
92813: NEG
92814: PUSH
92815: LD_INT 4
92817: NEG
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 4
92825: NEG
92826: PUSH
92827: LD_INT 3
92829: NEG
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 4
92837: NEG
92838: PUSH
92839: LD_INT 4
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 4
92849: NEG
92850: PUSH
92851: LD_INT 5
92853: NEG
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 5
92861: NEG
92862: PUSH
92863: LD_INT 4
92865: NEG
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 5
92873: NEG
92874: PUSH
92875: LD_INT 5
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 5
92885: NEG
92886: PUSH
92887: LD_INT 6
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 6
92897: NEG
92898: PUSH
92899: LD_INT 5
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 6
92909: NEG
92910: PUSH
92911: LD_INT 6
92913: NEG
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92933: LD_ADDR_VAR 0 41
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 2
92943: NEG
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 1
92951: NEG
92952: PUSH
92953: LD_INT 3
92955: NEG
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 1
92963: PUSH
92964: LD_INT 2
92966: NEG
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: LIST
92976: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92977: LD_ADDR_VAR 0 42
92981: PUSH
92982: LD_INT 2
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 2
92994: PUSH
92995: LD_INT 1
92997: NEG
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 3
93005: PUSH
93006: LD_INT 1
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: LIST
93017: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93018: LD_ADDR_VAR 0 43
93022: PUSH
93023: LD_INT 2
93025: PUSH
93026: LD_INT 2
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 3
93035: PUSH
93036: LD_INT 2
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 2
93045: PUSH
93046: LD_INT 3
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: LIST
93057: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93058: LD_ADDR_VAR 0 44
93062: PUSH
93063: LD_INT 0
93065: PUSH
93066: LD_INT 2
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 1
93075: PUSH
93076: LD_INT 3
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 1
93085: NEG
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: LIST
93098: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93099: LD_ADDR_VAR 0 45
93103: PUSH
93104: LD_INT 2
93106: NEG
93107: PUSH
93108: LD_INT 0
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 2
93117: NEG
93118: PUSH
93119: LD_INT 1
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 3
93128: NEG
93129: PUSH
93130: LD_INT 1
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: LIST
93142: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93143: LD_ADDR_VAR 0 46
93147: PUSH
93148: LD_INT 2
93150: NEG
93151: PUSH
93152: LD_INT 2
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 2
93162: NEG
93163: PUSH
93164: LD_INT 3
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 3
93174: NEG
93175: PUSH
93176: LD_INT 2
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: LIST
93188: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93189: LD_ADDR_VAR 0 47
93193: PUSH
93194: LD_INT 2
93196: NEG
93197: PUSH
93198: LD_INT 3
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 1
93208: NEG
93209: PUSH
93210: LD_INT 3
93212: NEG
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93222: LD_ADDR_VAR 0 48
93226: PUSH
93227: LD_INT 1
93229: PUSH
93230: LD_INT 2
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 2
93240: PUSH
93241: LD_INT 1
93243: NEG
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93253: LD_ADDR_VAR 0 49
93257: PUSH
93258: LD_INT 3
93260: PUSH
93261: LD_INT 1
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 3
93270: PUSH
93271: LD_INT 2
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93282: LD_ADDR_VAR 0 50
93286: PUSH
93287: LD_INT 2
93289: PUSH
93290: LD_INT 3
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 1
93299: PUSH
93300: LD_INT 3
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93311: LD_ADDR_VAR 0 51
93315: PUSH
93316: LD_INT 1
93318: NEG
93319: PUSH
93320: LD_INT 2
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: PUSH
93327: LD_INT 2
93329: NEG
93330: PUSH
93331: LD_INT 1
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93342: LD_ADDR_VAR 0 52
93346: PUSH
93347: LD_INT 3
93349: NEG
93350: PUSH
93351: LD_INT 1
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 3
93361: NEG
93362: PUSH
93363: LD_INT 2
93365: NEG
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93375: LD_ADDR_VAR 0 53
93379: PUSH
93380: LD_INT 1
93382: NEG
93383: PUSH
93384: LD_INT 3
93386: NEG
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: LD_INT 3
93397: NEG
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 1
93405: PUSH
93406: LD_INT 2
93408: NEG
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: LIST
93418: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93419: LD_ADDR_VAR 0 54
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: LD_INT 1
93429: NEG
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 3
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 3
93447: PUSH
93448: LD_INT 1
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: LIST
93459: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93460: LD_ADDR_VAR 0 55
93464: PUSH
93465: LD_INT 3
93467: PUSH
93468: LD_INT 2
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 3
93477: PUSH
93478: LD_INT 3
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 2
93487: PUSH
93488: LD_INT 3
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: LIST
93499: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93500: LD_ADDR_VAR 0 56
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: LD_INT 3
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 0
93517: PUSH
93518: LD_INT 3
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 1
93527: NEG
93528: PUSH
93529: LD_INT 2
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: LIST
93540: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93541: LD_ADDR_VAR 0 57
93545: PUSH
93546: LD_INT 2
93548: NEG
93549: PUSH
93550: LD_INT 1
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 3
93559: NEG
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: LD_INT 1
93574: NEG
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: LIST
93584: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93585: LD_ADDR_VAR 0 58
93589: PUSH
93590: LD_INT 2
93592: NEG
93593: PUSH
93594: LD_INT 3
93596: NEG
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 3
93604: NEG
93605: PUSH
93606: LD_INT 2
93608: NEG
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: LD_INT 3
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: LIST
93630: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93631: LD_ADDR_VAR 0 59
93635: PUSH
93636: LD_INT 1
93638: NEG
93639: PUSH
93640: LD_INT 2
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 0
93650: PUSH
93651: LD_INT 2
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 1
93661: PUSH
93662: LD_INT 1
93664: NEG
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: LIST
93674: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93675: LD_ADDR_VAR 0 60
93679: PUSH
93680: LD_INT 1
93682: PUSH
93683: LD_INT 1
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 2
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 2
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: LIST
93715: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93716: LD_ADDR_VAR 0 61
93720: PUSH
93721: LD_INT 2
93723: PUSH
93724: LD_INT 1
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: LD_INT 2
93733: PUSH
93734: LD_INT 2
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 1
93743: PUSH
93744: LD_INT 2
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: LIST
93755: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93756: LD_ADDR_VAR 0 62
93760: PUSH
93761: LD_INT 1
93763: PUSH
93764: LD_INT 2
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 0
93773: PUSH
93774: LD_INT 2
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 1
93783: NEG
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: LIST
93796: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93797: LD_ADDR_VAR 0 63
93801: PUSH
93802: LD_INT 1
93804: NEG
93805: PUSH
93806: LD_INT 1
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: LD_INT 2
93815: NEG
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 2
93826: NEG
93827: PUSH
93828: LD_INT 1
93830: NEG
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: LIST
93840: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93841: LD_ADDR_VAR 0 64
93845: PUSH
93846: LD_INT 1
93848: NEG
93849: PUSH
93850: LD_INT 2
93852: NEG
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: LD_INT 2
93860: NEG
93861: PUSH
93862: LD_INT 1
93864: NEG
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 2
93872: NEG
93873: PUSH
93874: LD_INT 2
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// end ; 2 :
93887: GO 97153
93889: LD_INT 2
93891: DOUBLE
93892: EQUAL
93893: IFTRUE 93897
93895: GO 97152
93897: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93898: LD_ADDR_VAR 0 29
93902: PUSH
93903: LD_INT 4
93905: PUSH
93906: LD_INT 0
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 4
93915: PUSH
93916: LD_INT 1
93918: NEG
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 5
93926: PUSH
93927: LD_INT 0
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: PUSH
93934: LD_INT 5
93936: PUSH
93937: LD_INT 1
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 4
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PUSH
93954: LD_INT 3
93956: PUSH
93957: LD_INT 0
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 3
93966: PUSH
93967: LD_INT 1
93969: NEG
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 3
93977: PUSH
93978: LD_INT 2
93980: NEG
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: PUSH
93986: LD_INT 5
93988: PUSH
93989: LD_INT 2
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 3
93998: PUSH
93999: LD_INT 3
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 3
94008: PUSH
94009: LD_INT 2
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: PUSH
94016: LD_INT 4
94018: PUSH
94019: LD_INT 3
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: PUSH
94026: LD_INT 4
94028: PUSH
94029: LD_INT 4
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 3
94038: PUSH
94039: LD_INT 4
94041: PUSH
94042: EMPTY
94043: LIST
94044: LIST
94045: PUSH
94046: LD_INT 2
94048: PUSH
94049: LD_INT 3
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PUSH
94056: LD_INT 2
94058: PUSH
94059: LD_INT 2
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 4
94068: PUSH
94069: LD_INT 2
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 2
94078: PUSH
94079: LD_INT 4
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: LD_INT 0
94088: PUSH
94089: LD_INT 4
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 0
94098: PUSH
94099: LD_INT 3
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PUSH
94106: LD_INT 1
94108: PUSH
94109: LD_INT 4
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 1
94118: PUSH
94119: LD_INT 5
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 0
94128: PUSH
94129: LD_INT 5
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 1
94138: NEG
94139: PUSH
94140: LD_INT 4
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 1
94149: NEG
94150: PUSH
94151: LD_INT 3
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 2
94160: PUSH
94161: LD_INT 5
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 2
94170: NEG
94171: PUSH
94172: LD_INT 3
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 3
94181: NEG
94182: PUSH
94183: LD_INT 0
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 3
94192: NEG
94193: PUSH
94194: LD_INT 1
94196: NEG
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 2
94204: NEG
94205: PUSH
94206: LD_INT 0
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 2
94215: NEG
94216: PUSH
94217: LD_INT 1
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 3
94226: NEG
94227: PUSH
94228: LD_INT 1
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 4
94237: NEG
94238: PUSH
94239: LD_INT 0
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 4
94248: NEG
94249: PUSH
94250: LD_INT 1
94252: NEG
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 4
94260: NEG
94261: PUSH
94262: LD_INT 2
94264: NEG
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: LD_INT 2
94272: NEG
94273: PUSH
94274: LD_INT 2
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 4
94283: NEG
94284: PUSH
94285: LD_INT 4
94287: NEG
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 4
94295: NEG
94296: PUSH
94297: LD_INT 5
94299: NEG
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 3
94307: NEG
94308: PUSH
94309: LD_INT 4
94311: NEG
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 3
94319: NEG
94320: PUSH
94321: LD_INT 3
94323: NEG
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 4
94331: NEG
94332: PUSH
94333: LD_INT 3
94335: NEG
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 5
94343: NEG
94344: PUSH
94345: LD_INT 4
94347: NEG
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 5
94355: NEG
94356: PUSH
94357: LD_INT 5
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 3
94367: NEG
94368: PUSH
94369: LD_INT 5
94371: NEG
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 5
94379: NEG
94380: PUSH
94381: LD_INT 3
94383: NEG
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94436: LD_ADDR_VAR 0 30
94440: PUSH
94441: LD_INT 4
94443: PUSH
94444: LD_INT 4
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: PUSH
94451: LD_INT 4
94453: PUSH
94454: LD_INT 3
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 5
94463: PUSH
94464: LD_INT 4
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: PUSH
94471: LD_INT 5
94473: PUSH
94474: LD_INT 5
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 4
94483: PUSH
94484: LD_INT 5
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: PUSH
94491: LD_INT 3
94493: PUSH
94494: LD_INT 4
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 3
94503: PUSH
94504: LD_INT 3
94506: PUSH
94507: EMPTY
94508: LIST
94509: LIST
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: LD_INT 3
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: LD_INT 3
94523: PUSH
94524: LD_INT 5
94526: PUSH
94527: EMPTY
94528: LIST
94529: LIST
94530: PUSH
94531: LD_INT 0
94533: PUSH
94534: LD_INT 3
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: LD_INT 2
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 1
94553: PUSH
94554: LD_INT 3
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 1
94563: PUSH
94564: LD_INT 4
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: LD_INT 4
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 1
94583: NEG
94584: PUSH
94585: LD_INT 3
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 1
94594: NEG
94595: PUSH
94596: LD_INT 2
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 2
94605: PUSH
94606: LD_INT 4
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 2
94615: NEG
94616: PUSH
94617: LD_INT 2
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 4
94626: NEG
94627: PUSH
94628: LD_INT 0
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: LD_INT 1
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 3
94649: NEG
94650: PUSH
94651: LD_INT 0
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 3
94660: NEG
94661: PUSH
94662: LD_INT 1
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 4
94671: NEG
94672: PUSH
94673: LD_INT 1
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: LD_INT 5
94682: NEG
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: LD_INT 1
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 5
94705: NEG
94706: PUSH
94707: LD_INT 2
94709: NEG
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 3
94717: NEG
94718: PUSH
94719: LD_INT 2
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 3
94728: NEG
94729: PUSH
94730: LD_INT 3
94732: NEG
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 3
94740: NEG
94741: PUSH
94742: LD_INT 4
94744: NEG
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 2
94752: NEG
94753: PUSH
94754: LD_INT 3
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 2
94764: NEG
94765: PUSH
94766: LD_INT 2
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 3
94776: NEG
94777: PUSH
94778: LD_INT 2
94780: NEG
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 4
94788: NEG
94789: PUSH
94790: LD_INT 3
94792: NEG
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 4
94800: NEG
94801: PUSH
94802: LD_INT 4
94804: NEG
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 2
94812: NEG
94813: PUSH
94814: LD_INT 4
94816: NEG
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 4
94824: NEG
94825: PUSH
94826: LD_INT 2
94828: NEG
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 0
94836: PUSH
94837: LD_INT 4
94839: NEG
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 0
94847: PUSH
94848: LD_INT 5
94850: NEG
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 1
94858: PUSH
94859: LD_INT 4
94861: NEG
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: PUSH
94867: LD_INT 1
94869: PUSH
94870: LD_INT 3
94872: NEG
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 0
94880: PUSH
94881: LD_INT 3
94883: NEG
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 1
94891: NEG
94892: PUSH
94893: LD_INT 4
94895: NEG
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 1
94903: NEG
94904: PUSH
94905: LD_INT 5
94907: NEG
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 2
94915: PUSH
94916: LD_INT 3
94918: NEG
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 2
94926: NEG
94927: PUSH
94928: LD_INT 5
94930: NEG
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94983: LD_ADDR_VAR 0 31
94987: PUSH
94988: LD_INT 0
94990: PUSH
94991: LD_INT 4
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 0
95000: PUSH
95001: LD_INT 3
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 1
95010: PUSH
95011: LD_INT 4
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 1
95020: PUSH
95021: LD_INT 5
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 0
95030: PUSH
95031: LD_INT 5
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 1
95040: NEG
95041: PUSH
95042: LD_INT 4
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 1
95051: NEG
95052: PUSH
95053: LD_INT 3
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: PUSH
95060: LD_INT 2
95062: PUSH
95063: LD_INT 5
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: LD_INT 2
95072: NEG
95073: PUSH
95074: LD_INT 3
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 3
95083: NEG
95084: PUSH
95085: LD_INT 0
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 3
95094: NEG
95095: PUSH
95096: LD_INT 1
95098: NEG
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 2
95106: NEG
95107: PUSH
95108: LD_INT 0
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 2
95117: NEG
95118: PUSH
95119: LD_INT 1
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 3
95128: NEG
95129: PUSH
95130: LD_INT 1
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PUSH
95137: LD_INT 4
95139: NEG
95140: PUSH
95141: LD_INT 0
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 4
95150: NEG
95151: PUSH
95152: LD_INT 1
95154: NEG
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 4
95162: NEG
95163: PUSH
95164: LD_INT 2
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 2
95174: NEG
95175: PUSH
95176: LD_INT 2
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 4
95185: NEG
95186: PUSH
95187: LD_INT 4
95189: NEG
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: LD_INT 5
95201: NEG
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 3
95209: NEG
95210: PUSH
95211: LD_INT 4
95213: NEG
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 3
95221: NEG
95222: PUSH
95223: LD_INT 3
95225: NEG
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: PUSH
95231: LD_INT 4
95233: NEG
95234: PUSH
95235: LD_INT 3
95237: NEG
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 5
95245: NEG
95246: PUSH
95247: LD_INT 4
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 5
95257: NEG
95258: PUSH
95259: LD_INT 5
95261: NEG
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 3
95269: NEG
95270: PUSH
95271: LD_INT 5
95273: NEG
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 5
95281: NEG
95282: PUSH
95283: LD_INT 3
95285: NEG
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: LD_INT 0
95293: PUSH
95294: LD_INT 3
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 0
95304: PUSH
95305: LD_INT 4
95307: NEG
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 1
95315: PUSH
95316: LD_INT 3
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 1
95326: PUSH
95327: LD_INT 2
95329: NEG
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 0
95337: PUSH
95338: LD_INT 2
95340: NEG
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 1
95348: NEG
95349: PUSH
95350: LD_INT 3
95352: NEG
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 1
95360: NEG
95361: PUSH
95362: LD_INT 4
95364: NEG
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 2
95372: PUSH
95373: LD_INT 2
95375: NEG
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 2
95383: NEG
95384: PUSH
95385: LD_INT 4
95387: NEG
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: LD_INT 4
95395: PUSH
95396: LD_INT 0
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 4
95405: PUSH
95406: LD_INT 1
95408: NEG
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: LD_INT 5
95416: PUSH
95417: LD_INT 0
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PUSH
95424: LD_INT 5
95426: PUSH
95427: LD_INT 1
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: PUSH
95434: LD_INT 4
95436: PUSH
95437: LD_INT 1
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: LD_INT 3
95446: PUSH
95447: LD_INT 0
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 3
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 3
95467: PUSH
95468: LD_INT 2
95470: NEG
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 5
95478: PUSH
95479: LD_INT 2
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95533: LD_ADDR_VAR 0 32
95537: PUSH
95538: LD_INT 4
95540: NEG
95541: PUSH
95542: LD_INT 0
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 4
95551: NEG
95552: PUSH
95553: LD_INT 1
95555: NEG
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 3
95563: NEG
95564: PUSH
95565: LD_INT 0
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 3
95574: NEG
95575: PUSH
95576: LD_INT 1
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 4
95585: NEG
95586: PUSH
95587: LD_INT 1
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: PUSH
95594: LD_INT 5
95596: NEG
95597: PUSH
95598: LD_INT 0
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 5
95607: NEG
95608: PUSH
95609: LD_INT 1
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 5
95619: NEG
95620: PUSH
95621: LD_INT 2
95623: NEG
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 3
95631: NEG
95632: PUSH
95633: LD_INT 2
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 3
95642: NEG
95643: PUSH
95644: LD_INT 3
95646: NEG
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 3
95654: NEG
95655: PUSH
95656: LD_INT 4
95658: NEG
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 2
95666: NEG
95667: PUSH
95668: LD_INT 3
95670: NEG
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 2
95678: NEG
95679: PUSH
95680: LD_INT 2
95682: NEG
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 3
95690: NEG
95691: PUSH
95692: LD_INT 2
95694: NEG
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 4
95702: NEG
95703: PUSH
95704: LD_INT 3
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 4
95714: NEG
95715: PUSH
95716: LD_INT 4
95718: NEG
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 2
95726: NEG
95727: PUSH
95728: LD_INT 4
95730: NEG
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 4
95738: NEG
95739: PUSH
95740: LD_INT 2
95742: NEG
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 0
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 0
95761: PUSH
95762: LD_INT 5
95764: NEG
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 1
95772: PUSH
95773: LD_INT 4
95775: NEG
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 1
95783: PUSH
95784: LD_INT 3
95786: NEG
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 0
95794: PUSH
95795: LD_INT 3
95797: NEG
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: PUSH
95803: LD_INT 1
95805: NEG
95806: PUSH
95807: LD_INT 4
95809: NEG
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 1
95817: NEG
95818: PUSH
95819: LD_INT 5
95821: NEG
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 2
95829: PUSH
95830: LD_INT 3
95832: NEG
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 2
95840: NEG
95841: PUSH
95842: LD_INT 5
95844: NEG
95845: PUSH
95846: EMPTY
95847: LIST
95848: LIST
95849: PUSH
95850: LD_INT 3
95852: PUSH
95853: LD_INT 0
95855: PUSH
95856: EMPTY
95857: LIST
95858: LIST
95859: PUSH
95860: LD_INT 3
95862: PUSH
95863: LD_INT 1
95865: NEG
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 4
95873: PUSH
95874: LD_INT 0
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 4
95883: PUSH
95884: LD_INT 1
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 3
95893: PUSH
95894: LD_INT 1
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: LD_INT 2
95903: PUSH
95904: LD_INT 0
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 2
95913: PUSH
95914: LD_INT 1
95916: NEG
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 2
95924: PUSH
95925: LD_INT 2
95927: NEG
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 4
95935: PUSH
95936: LD_INT 2
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 4
95945: PUSH
95946: LD_INT 4
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 4
95955: PUSH
95956: LD_INT 3
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 5
95965: PUSH
95966: LD_INT 4
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 5
95975: PUSH
95976: LD_INT 5
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 4
95985: PUSH
95986: LD_INT 5
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 3
95995: PUSH
95996: LD_INT 4
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: LD_INT 3
96005: PUSH
96006: LD_INT 3
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 5
96015: PUSH
96016: LD_INT 3
96018: PUSH
96019: EMPTY
96020: LIST
96021: LIST
96022: PUSH
96023: LD_INT 3
96025: PUSH
96026: LD_INT 5
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96080: LD_ADDR_VAR 0 33
96084: PUSH
96085: LD_INT 4
96087: NEG
96088: PUSH
96089: LD_INT 4
96091: NEG
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 4
96099: NEG
96100: PUSH
96101: LD_INT 5
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 3
96111: NEG
96112: PUSH
96113: LD_INT 4
96115: NEG
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 3
96123: NEG
96124: PUSH
96125: LD_INT 3
96127: NEG
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 4
96135: NEG
96136: PUSH
96137: LD_INT 3
96139: NEG
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 5
96147: NEG
96148: PUSH
96149: LD_INT 4
96151: NEG
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: PUSH
96157: LD_INT 5
96159: NEG
96160: PUSH
96161: LD_INT 5
96163: NEG
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 3
96171: NEG
96172: PUSH
96173: LD_INT 5
96175: NEG
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 5
96183: NEG
96184: PUSH
96185: LD_INT 3
96187: NEG
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 0
96195: PUSH
96196: LD_INT 3
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 0
96206: PUSH
96207: LD_INT 4
96209: NEG
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 1
96217: PUSH
96218: LD_INT 3
96220: NEG
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 1
96228: PUSH
96229: LD_INT 2
96231: NEG
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: PUSH
96237: LD_INT 0
96239: PUSH
96240: LD_INT 2
96242: NEG
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 1
96250: NEG
96251: PUSH
96252: LD_INT 3
96254: NEG
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 1
96262: NEG
96263: PUSH
96264: LD_INT 4
96266: NEG
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 2
96274: PUSH
96275: LD_INT 2
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 2
96285: NEG
96286: PUSH
96287: LD_INT 4
96289: NEG
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 4
96297: PUSH
96298: LD_INT 0
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 4
96307: PUSH
96308: LD_INT 1
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 5
96318: PUSH
96319: LD_INT 0
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: LD_INT 1
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 4
96338: PUSH
96339: LD_INT 1
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 3
96348: PUSH
96349: LD_INT 0
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 3
96358: PUSH
96359: LD_INT 1
96361: NEG
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 3
96369: PUSH
96370: LD_INT 2
96372: NEG
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 5
96380: PUSH
96381: LD_INT 2
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 3
96390: PUSH
96391: LD_INT 3
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 3
96400: PUSH
96401: LD_INT 2
96403: PUSH
96404: EMPTY
96405: LIST
96406: LIST
96407: PUSH
96408: LD_INT 4
96410: PUSH
96411: LD_INT 3
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: LD_INT 4
96420: PUSH
96421: LD_INT 4
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 3
96430: PUSH
96431: LD_INT 4
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 2
96440: PUSH
96441: LD_INT 3
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 2
96450: PUSH
96451: LD_INT 2
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 4
96460: PUSH
96461: LD_INT 2
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 2
96470: PUSH
96471: LD_INT 4
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: LD_INT 0
96480: PUSH
96481: LD_INT 4
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: LD_INT 0
96490: PUSH
96491: LD_INT 3
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 1
96500: PUSH
96501: LD_INT 4
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: PUSH
96508: LD_INT 1
96510: PUSH
96511: LD_INT 5
96513: PUSH
96514: EMPTY
96515: LIST
96516: LIST
96517: PUSH
96518: LD_INT 0
96520: PUSH
96521: LD_INT 5
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 1
96530: NEG
96531: PUSH
96532: LD_INT 4
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: LD_INT 3
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 2
96552: PUSH
96553: LD_INT 5
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 2
96562: NEG
96563: PUSH
96564: LD_INT 3
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96618: LD_ADDR_VAR 0 34
96622: PUSH
96623: LD_INT 0
96625: PUSH
96626: LD_INT 4
96628: NEG
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 0
96636: PUSH
96637: LD_INT 5
96639: NEG
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 1
96647: PUSH
96648: LD_INT 4
96650: NEG
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 1
96658: PUSH
96659: LD_INT 3
96661: NEG
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_INT 0
96669: PUSH
96670: LD_INT 3
96672: NEG
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 1
96680: NEG
96681: PUSH
96682: LD_INT 4
96684: NEG
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 1
96692: NEG
96693: PUSH
96694: LD_INT 5
96696: NEG
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 2
96704: PUSH
96705: LD_INT 3
96707: NEG
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 2
96715: NEG
96716: PUSH
96717: LD_INT 5
96719: NEG
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 3
96727: PUSH
96728: LD_INT 0
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 3
96737: PUSH
96738: LD_INT 1
96740: NEG
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 4
96748: PUSH
96749: LD_INT 0
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 4
96758: PUSH
96759: LD_INT 1
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 3
96768: PUSH
96769: LD_INT 1
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 2
96778: PUSH
96779: LD_INT 0
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 2
96788: PUSH
96789: LD_INT 1
96791: NEG
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 2
96799: PUSH
96800: LD_INT 2
96802: NEG
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 4
96810: PUSH
96811: LD_INT 2
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 4
96820: PUSH
96821: LD_INT 4
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 4
96830: PUSH
96831: LD_INT 3
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 5
96840: PUSH
96841: LD_INT 4
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 5
96850: PUSH
96851: LD_INT 5
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 4
96860: PUSH
96861: LD_INT 5
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: LD_INT 3
96870: PUSH
96871: LD_INT 4
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 3
96880: PUSH
96881: LD_INT 3
96883: PUSH
96884: EMPTY
96885: LIST
96886: LIST
96887: PUSH
96888: LD_INT 5
96890: PUSH
96891: LD_INT 3
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PUSH
96898: LD_INT 3
96900: PUSH
96901: LD_INT 5
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 0
96910: PUSH
96911: LD_INT 3
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 0
96920: PUSH
96921: LD_INT 2
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 1
96930: PUSH
96931: LD_INT 3
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 1
96940: PUSH
96941: LD_INT 4
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 0
96950: PUSH
96951: LD_INT 4
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 1
96960: NEG
96961: PUSH
96962: LD_INT 3
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 1
96971: NEG
96972: PUSH
96973: LD_INT 2
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: PUSH
96980: LD_INT 2
96982: PUSH
96983: LD_INT 4
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: PUSH
96990: LD_INT 2
96992: NEG
96993: PUSH
96994: LD_INT 2
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 4
97003: NEG
97004: PUSH
97005: LD_INT 0
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 4
97014: NEG
97015: PUSH
97016: LD_INT 1
97018: NEG
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 3
97026: NEG
97027: PUSH
97028: LD_INT 0
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 3
97037: NEG
97038: PUSH
97039: LD_INT 1
97041: PUSH
97042: EMPTY
97043: LIST
97044: LIST
97045: PUSH
97046: LD_INT 4
97048: NEG
97049: PUSH
97050: LD_INT 1
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PUSH
97057: LD_INT 5
97059: NEG
97060: PUSH
97061: LD_INT 0
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 5
97070: NEG
97071: PUSH
97072: LD_INT 1
97074: NEG
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: PUSH
97080: LD_INT 5
97082: NEG
97083: PUSH
97084: LD_INT 2
97086: NEG
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 3
97094: NEG
97095: PUSH
97096: LD_INT 2
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: ST_TO_ADDR
// end ; end ;
97150: GO 97153
97152: POP
// case btype of b_depot , b_warehouse :
97153: LD_VAR 0 1
97157: PUSH
97158: LD_INT 0
97160: DOUBLE
97161: EQUAL
97162: IFTRUE 97172
97164: LD_INT 1
97166: DOUBLE
97167: EQUAL
97168: IFTRUE 97172
97170: GO 97373
97172: POP
// case nation of nation_american :
97173: LD_VAR 0 5
97177: PUSH
97178: LD_INT 1
97180: DOUBLE
97181: EQUAL
97182: IFTRUE 97186
97184: GO 97242
97186: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97187: LD_ADDR_VAR 0 9
97191: PUSH
97192: LD_VAR 0 11
97196: PUSH
97197: LD_VAR 0 12
97201: PUSH
97202: LD_VAR 0 13
97206: PUSH
97207: LD_VAR 0 14
97211: PUSH
97212: LD_VAR 0 15
97216: PUSH
97217: LD_VAR 0 16
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: PUSH
97230: LD_VAR 0 4
97234: PUSH
97235: LD_INT 1
97237: PLUS
97238: ARRAY
97239: ST_TO_ADDR
97240: GO 97371
97242: LD_INT 2
97244: DOUBLE
97245: EQUAL
97246: IFTRUE 97250
97248: GO 97306
97250: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97251: LD_ADDR_VAR 0 9
97255: PUSH
97256: LD_VAR 0 17
97260: PUSH
97261: LD_VAR 0 18
97265: PUSH
97266: LD_VAR 0 19
97270: PUSH
97271: LD_VAR 0 20
97275: PUSH
97276: LD_VAR 0 21
97280: PUSH
97281: LD_VAR 0 22
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: PUSH
97294: LD_VAR 0 4
97298: PUSH
97299: LD_INT 1
97301: PLUS
97302: ARRAY
97303: ST_TO_ADDR
97304: GO 97371
97306: LD_INT 3
97308: DOUBLE
97309: EQUAL
97310: IFTRUE 97314
97312: GO 97370
97314: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97315: LD_ADDR_VAR 0 9
97319: PUSH
97320: LD_VAR 0 23
97324: PUSH
97325: LD_VAR 0 24
97329: PUSH
97330: LD_VAR 0 25
97334: PUSH
97335: LD_VAR 0 26
97339: PUSH
97340: LD_VAR 0 27
97344: PUSH
97345: LD_VAR 0 28
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: PUSH
97358: LD_VAR 0 4
97362: PUSH
97363: LD_INT 1
97365: PLUS
97366: ARRAY
97367: ST_TO_ADDR
97368: GO 97371
97370: POP
97371: GO 97926
97373: LD_INT 2
97375: DOUBLE
97376: EQUAL
97377: IFTRUE 97387
97379: LD_INT 3
97381: DOUBLE
97382: EQUAL
97383: IFTRUE 97387
97385: GO 97443
97387: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97388: LD_ADDR_VAR 0 9
97392: PUSH
97393: LD_VAR 0 29
97397: PUSH
97398: LD_VAR 0 30
97402: PUSH
97403: LD_VAR 0 31
97407: PUSH
97408: LD_VAR 0 32
97412: PUSH
97413: LD_VAR 0 33
97417: PUSH
97418: LD_VAR 0 34
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: PUSH
97431: LD_VAR 0 4
97435: PUSH
97436: LD_INT 1
97438: PLUS
97439: ARRAY
97440: ST_TO_ADDR
97441: GO 97926
97443: LD_INT 16
97445: DOUBLE
97446: EQUAL
97447: IFTRUE 97505
97449: LD_INT 17
97451: DOUBLE
97452: EQUAL
97453: IFTRUE 97505
97455: LD_INT 18
97457: DOUBLE
97458: EQUAL
97459: IFTRUE 97505
97461: LD_INT 19
97463: DOUBLE
97464: EQUAL
97465: IFTRUE 97505
97467: LD_INT 22
97469: DOUBLE
97470: EQUAL
97471: IFTRUE 97505
97473: LD_INT 20
97475: DOUBLE
97476: EQUAL
97477: IFTRUE 97505
97479: LD_INT 21
97481: DOUBLE
97482: EQUAL
97483: IFTRUE 97505
97485: LD_INT 23
97487: DOUBLE
97488: EQUAL
97489: IFTRUE 97505
97491: LD_INT 24
97493: DOUBLE
97494: EQUAL
97495: IFTRUE 97505
97497: LD_INT 25
97499: DOUBLE
97500: EQUAL
97501: IFTRUE 97505
97503: GO 97561
97505: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97506: LD_ADDR_VAR 0 9
97510: PUSH
97511: LD_VAR 0 35
97515: PUSH
97516: LD_VAR 0 36
97520: PUSH
97521: LD_VAR 0 37
97525: PUSH
97526: LD_VAR 0 38
97530: PUSH
97531: LD_VAR 0 39
97535: PUSH
97536: LD_VAR 0 40
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: PUSH
97549: LD_VAR 0 4
97553: PUSH
97554: LD_INT 1
97556: PLUS
97557: ARRAY
97558: ST_TO_ADDR
97559: GO 97926
97561: LD_INT 6
97563: DOUBLE
97564: EQUAL
97565: IFTRUE 97617
97567: LD_INT 7
97569: DOUBLE
97570: EQUAL
97571: IFTRUE 97617
97573: LD_INT 8
97575: DOUBLE
97576: EQUAL
97577: IFTRUE 97617
97579: LD_INT 13
97581: DOUBLE
97582: EQUAL
97583: IFTRUE 97617
97585: LD_INT 12
97587: DOUBLE
97588: EQUAL
97589: IFTRUE 97617
97591: LD_INT 15
97593: DOUBLE
97594: EQUAL
97595: IFTRUE 97617
97597: LD_INT 11
97599: DOUBLE
97600: EQUAL
97601: IFTRUE 97617
97603: LD_INT 14
97605: DOUBLE
97606: EQUAL
97607: IFTRUE 97617
97609: LD_INT 10
97611: DOUBLE
97612: EQUAL
97613: IFTRUE 97617
97615: GO 97673
97617: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97618: LD_ADDR_VAR 0 9
97622: PUSH
97623: LD_VAR 0 41
97627: PUSH
97628: LD_VAR 0 42
97632: PUSH
97633: LD_VAR 0 43
97637: PUSH
97638: LD_VAR 0 44
97642: PUSH
97643: LD_VAR 0 45
97647: PUSH
97648: LD_VAR 0 46
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: PUSH
97661: LD_VAR 0 4
97665: PUSH
97666: LD_INT 1
97668: PLUS
97669: ARRAY
97670: ST_TO_ADDR
97671: GO 97926
97673: LD_INT 36
97675: DOUBLE
97676: EQUAL
97677: IFTRUE 97681
97679: GO 97737
97681: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97682: LD_ADDR_VAR 0 9
97686: PUSH
97687: LD_VAR 0 47
97691: PUSH
97692: LD_VAR 0 48
97696: PUSH
97697: LD_VAR 0 49
97701: PUSH
97702: LD_VAR 0 50
97706: PUSH
97707: LD_VAR 0 51
97711: PUSH
97712: LD_VAR 0 52
97716: PUSH
97717: EMPTY
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: PUSH
97725: LD_VAR 0 4
97729: PUSH
97730: LD_INT 1
97732: PLUS
97733: ARRAY
97734: ST_TO_ADDR
97735: GO 97926
97737: LD_INT 4
97739: DOUBLE
97740: EQUAL
97741: IFTRUE 97763
97743: LD_INT 5
97745: DOUBLE
97746: EQUAL
97747: IFTRUE 97763
97749: LD_INT 34
97751: DOUBLE
97752: EQUAL
97753: IFTRUE 97763
97755: LD_INT 37
97757: DOUBLE
97758: EQUAL
97759: IFTRUE 97763
97761: GO 97819
97763: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97764: LD_ADDR_VAR 0 9
97768: PUSH
97769: LD_VAR 0 53
97773: PUSH
97774: LD_VAR 0 54
97778: PUSH
97779: LD_VAR 0 55
97783: PUSH
97784: LD_VAR 0 56
97788: PUSH
97789: LD_VAR 0 57
97793: PUSH
97794: LD_VAR 0 58
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: PUSH
97807: LD_VAR 0 4
97811: PUSH
97812: LD_INT 1
97814: PLUS
97815: ARRAY
97816: ST_TO_ADDR
97817: GO 97926
97819: LD_INT 31
97821: DOUBLE
97822: EQUAL
97823: IFTRUE 97869
97825: LD_INT 32
97827: DOUBLE
97828: EQUAL
97829: IFTRUE 97869
97831: LD_INT 33
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97869
97837: LD_INT 27
97839: DOUBLE
97840: EQUAL
97841: IFTRUE 97869
97843: LD_INT 26
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97869
97849: LD_INT 28
97851: DOUBLE
97852: EQUAL
97853: IFTRUE 97869
97855: LD_INT 29
97857: DOUBLE
97858: EQUAL
97859: IFTRUE 97869
97861: LD_INT 30
97863: DOUBLE
97864: EQUAL
97865: IFTRUE 97869
97867: GO 97925
97869: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97870: LD_ADDR_VAR 0 9
97874: PUSH
97875: LD_VAR 0 59
97879: PUSH
97880: LD_VAR 0 60
97884: PUSH
97885: LD_VAR 0 61
97889: PUSH
97890: LD_VAR 0 62
97894: PUSH
97895: LD_VAR 0 63
97899: PUSH
97900: LD_VAR 0 64
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: PUSH
97913: LD_VAR 0 4
97917: PUSH
97918: LD_INT 1
97920: PLUS
97921: ARRAY
97922: ST_TO_ADDR
97923: GO 97926
97925: POP
// temp_list2 = [ ] ;
97926: LD_ADDR_VAR 0 10
97930: PUSH
97931: EMPTY
97932: ST_TO_ADDR
// for i in temp_list do
97933: LD_ADDR_VAR 0 8
97937: PUSH
97938: LD_VAR 0 9
97942: PUSH
97943: FOR_IN
97944: IFFALSE 97996
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97946: LD_ADDR_VAR 0 10
97950: PUSH
97951: LD_VAR 0 10
97955: PUSH
97956: LD_VAR 0 8
97960: PUSH
97961: LD_INT 1
97963: ARRAY
97964: PUSH
97965: LD_VAR 0 2
97969: PLUS
97970: PUSH
97971: LD_VAR 0 8
97975: PUSH
97976: LD_INT 2
97978: ARRAY
97979: PUSH
97980: LD_VAR 0 3
97984: PLUS
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: PUSH
97990: EMPTY
97991: LIST
97992: ADD
97993: ST_TO_ADDR
97994: GO 97943
97996: POP
97997: POP
// result = temp_list2 ;
97998: LD_ADDR_VAR 0 7
98002: PUSH
98003: LD_VAR 0 10
98007: ST_TO_ADDR
// end ;
98008: LD_VAR 0 7
98012: RET
// export function EnemyInRange ( unit , dist ) ; begin
98013: LD_INT 0
98015: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98016: LD_ADDR_VAR 0 3
98020: PUSH
98021: LD_VAR 0 1
98025: PPUSH
98026: CALL_OW 255
98030: PPUSH
98031: LD_VAR 0 1
98035: PPUSH
98036: CALL_OW 250
98040: PPUSH
98041: LD_VAR 0 1
98045: PPUSH
98046: CALL_OW 251
98050: PPUSH
98051: LD_VAR 0 2
98055: PPUSH
98056: CALL 72117 0 4
98060: PUSH
98061: LD_INT 4
98063: ARRAY
98064: ST_TO_ADDR
// end ;
98065: LD_VAR 0 3
98069: RET
// export function PlayerSeeMe ( unit ) ; begin
98070: LD_INT 0
98072: PPUSH
// result := See ( your_side , unit ) ;
98073: LD_ADDR_VAR 0 2
98077: PUSH
98078: LD_OWVAR 2
98082: PPUSH
98083: LD_VAR 0 1
98087: PPUSH
98088: CALL_OW 292
98092: ST_TO_ADDR
// end ;
98093: LD_VAR 0 2
98097: RET
// export function ReverseDir ( unit ) ; begin
98098: LD_INT 0
98100: PPUSH
// if not unit then
98101: LD_VAR 0 1
98105: NOT
98106: IFFALSE 98110
// exit ;
98108: GO 98156
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98110: LD_ADDR_VAR 0 2
98114: PUSH
98115: LD_INT 3
98117: PUSH
98118: LD_INT 4
98120: PUSH
98121: LD_INT 5
98123: PUSH
98124: LD_INT 0
98126: PUSH
98127: LD_INT 1
98129: PUSH
98130: LD_INT 2
98132: PUSH
98133: EMPTY
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: PUSH
98141: LD_VAR 0 1
98145: PPUSH
98146: CALL_OW 254
98150: PUSH
98151: LD_INT 1
98153: PLUS
98154: ARRAY
98155: ST_TO_ADDR
// end ;
98156: LD_VAR 0 2
98160: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98161: LD_INT 0
98163: PPUSH
98164: PPUSH
98165: PPUSH
98166: PPUSH
98167: PPUSH
// if not hexes then
98168: LD_VAR 0 2
98172: NOT
98173: IFFALSE 98177
// exit ;
98175: GO 98325
// dist := 9999 ;
98177: LD_ADDR_VAR 0 5
98181: PUSH
98182: LD_INT 9999
98184: ST_TO_ADDR
// for i = 1 to hexes do
98185: LD_ADDR_VAR 0 4
98189: PUSH
98190: DOUBLE
98191: LD_INT 1
98193: DEC
98194: ST_TO_ADDR
98195: LD_VAR 0 2
98199: PUSH
98200: FOR_TO
98201: IFFALSE 98313
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98203: LD_VAR 0 1
98207: PPUSH
98208: LD_VAR 0 2
98212: PUSH
98213: LD_VAR 0 4
98217: ARRAY
98218: PUSH
98219: LD_INT 1
98221: ARRAY
98222: PPUSH
98223: LD_VAR 0 2
98227: PUSH
98228: LD_VAR 0 4
98232: ARRAY
98233: PUSH
98234: LD_INT 2
98236: ARRAY
98237: PPUSH
98238: CALL_OW 297
98242: PUSH
98243: LD_VAR 0 5
98247: LESS
98248: IFFALSE 98311
// begin hex := hexes [ i ] ;
98250: LD_ADDR_VAR 0 7
98254: PUSH
98255: LD_VAR 0 2
98259: PUSH
98260: LD_VAR 0 4
98264: ARRAY
98265: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98266: LD_ADDR_VAR 0 5
98270: PUSH
98271: LD_VAR 0 1
98275: PPUSH
98276: LD_VAR 0 2
98280: PUSH
98281: LD_VAR 0 4
98285: ARRAY
98286: PUSH
98287: LD_INT 1
98289: ARRAY
98290: PPUSH
98291: LD_VAR 0 2
98295: PUSH
98296: LD_VAR 0 4
98300: ARRAY
98301: PUSH
98302: LD_INT 2
98304: ARRAY
98305: PPUSH
98306: CALL_OW 297
98310: ST_TO_ADDR
// end ; end ;
98311: GO 98200
98313: POP
98314: POP
// result := hex ;
98315: LD_ADDR_VAR 0 3
98319: PUSH
98320: LD_VAR 0 7
98324: ST_TO_ADDR
// end ;
98325: LD_VAR 0 3
98329: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98330: LD_INT 0
98332: PPUSH
98333: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98334: LD_VAR 0 1
98338: NOT
98339: PUSH
98340: LD_VAR 0 1
98344: PUSH
98345: LD_INT 21
98347: PUSH
98348: LD_INT 2
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: PUSH
98355: LD_INT 23
98357: PUSH
98358: LD_INT 2
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PPUSH
98369: CALL_OW 69
98373: IN
98374: NOT
98375: OR
98376: IFFALSE 98380
// exit ;
98378: GO 98427
// for i = 1 to 3 do
98380: LD_ADDR_VAR 0 3
98384: PUSH
98385: DOUBLE
98386: LD_INT 1
98388: DEC
98389: ST_TO_ADDR
98390: LD_INT 3
98392: PUSH
98393: FOR_TO
98394: IFFALSE 98425
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98396: LD_VAR 0 1
98400: PPUSH
98401: CALL_OW 250
98405: PPUSH
98406: LD_VAR 0 1
98410: PPUSH
98411: CALL_OW 251
98415: PPUSH
98416: LD_INT 1
98418: PPUSH
98419: CALL_OW 453
98423: GO 98393
98425: POP
98426: POP
// end ;
98427: LD_VAR 0 2
98431: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98432: LD_INT 0
98434: PPUSH
98435: PPUSH
98436: PPUSH
98437: PPUSH
98438: PPUSH
98439: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98440: LD_VAR 0 1
98444: NOT
98445: PUSH
98446: LD_VAR 0 2
98450: NOT
98451: OR
98452: PUSH
98453: LD_VAR 0 1
98457: PPUSH
98458: CALL_OW 314
98462: OR
98463: IFFALSE 98467
// exit ;
98465: GO 98908
// x := GetX ( enemy_unit ) ;
98467: LD_ADDR_VAR 0 7
98471: PUSH
98472: LD_VAR 0 2
98476: PPUSH
98477: CALL_OW 250
98481: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98482: LD_ADDR_VAR 0 8
98486: PUSH
98487: LD_VAR 0 2
98491: PPUSH
98492: CALL_OW 251
98496: ST_TO_ADDR
// if not x or not y then
98497: LD_VAR 0 7
98501: NOT
98502: PUSH
98503: LD_VAR 0 8
98507: NOT
98508: OR
98509: IFFALSE 98513
// exit ;
98511: GO 98908
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98513: LD_ADDR_VAR 0 6
98517: PUSH
98518: LD_VAR 0 7
98522: PPUSH
98523: LD_INT 0
98525: PPUSH
98526: LD_INT 4
98528: PPUSH
98529: CALL_OW 272
98533: PUSH
98534: LD_VAR 0 8
98538: PPUSH
98539: LD_INT 0
98541: PPUSH
98542: LD_INT 4
98544: PPUSH
98545: CALL_OW 273
98549: PUSH
98550: EMPTY
98551: LIST
98552: LIST
98553: PUSH
98554: LD_VAR 0 7
98558: PPUSH
98559: LD_INT 1
98561: PPUSH
98562: LD_INT 4
98564: PPUSH
98565: CALL_OW 272
98569: PUSH
98570: LD_VAR 0 8
98574: PPUSH
98575: LD_INT 1
98577: PPUSH
98578: LD_INT 4
98580: PPUSH
98581: CALL_OW 273
98585: PUSH
98586: EMPTY
98587: LIST
98588: LIST
98589: PUSH
98590: LD_VAR 0 7
98594: PPUSH
98595: LD_INT 2
98597: PPUSH
98598: LD_INT 4
98600: PPUSH
98601: CALL_OW 272
98605: PUSH
98606: LD_VAR 0 8
98610: PPUSH
98611: LD_INT 2
98613: PPUSH
98614: LD_INT 4
98616: PPUSH
98617: CALL_OW 273
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PUSH
98626: LD_VAR 0 7
98630: PPUSH
98631: LD_INT 3
98633: PPUSH
98634: LD_INT 4
98636: PPUSH
98637: CALL_OW 272
98641: PUSH
98642: LD_VAR 0 8
98646: PPUSH
98647: LD_INT 3
98649: PPUSH
98650: LD_INT 4
98652: PPUSH
98653: CALL_OW 273
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_VAR 0 7
98666: PPUSH
98667: LD_INT 4
98669: PPUSH
98670: LD_INT 4
98672: PPUSH
98673: CALL_OW 272
98677: PUSH
98678: LD_VAR 0 8
98682: PPUSH
98683: LD_INT 4
98685: PPUSH
98686: LD_INT 4
98688: PPUSH
98689: CALL_OW 273
98693: PUSH
98694: EMPTY
98695: LIST
98696: LIST
98697: PUSH
98698: LD_VAR 0 7
98702: PPUSH
98703: LD_INT 5
98705: PPUSH
98706: LD_INT 4
98708: PPUSH
98709: CALL_OW 272
98713: PUSH
98714: LD_VAR 0 8
98718: PPUSH
98719: LD_INT 5
98721: PPUSH
98722: LD_INT 4
98724: PPUSH
98725: CALL_OW 273
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: PUSH
98734: EMPTY
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: ST_TO_ADDR
// for i = tmp downto 1 do
98742: LD_ADDR_VAR 0 4
98746: PUSH
98747: DOUBLE
98748: LD_VAR 0 6
98752: INC
98753: ST_TO_ADDR
98754: LD_INT 1
98756: PUSH
98757: FOR_DOWNTO
98758: IFFALSE 98859
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98760: LD_VAR 0 6
98764: PUSH
98765: LD_VAR 0 4
98769: ARRAY
98770: PUSH
98771: LD_INT 1
98773: ARRAY
98774: PPUSH
98775: LD_VAR 0 6
98779: PUSH
98780: LD_VAR 0 4
98784: ARRAY
98785: PUSH
98786: LD_INT 2
98788: ARRAY
98789: PPUSH
98790: CALL_OW 488
98794: NOT
98795: PUSH
98796: LD_VAR 0 6
98800: PUSH
98801: LD_VAR 0 4
98805: ARRAY
98806: PUSH
98807: LD_INT 1
98809: ARRAY
98810: PPUSH
98811: LD_VAR 0 6
98815: PUSH
98816: LD_VAR 0 4
98820: ARRAY
98821: PUSH
98822: LD_INT 2
98824: ARRAY
98825: PPUSH
98826: CALL_OW 428
98830: PUSH
98831: LD_INT 0
98833: NONEQUAL
98834: OR
98835: IFFALSE 98857
// tmp := Delete ( tmp , i ) ;
98837: LD_ADDR_VAR 0 6
98841: PUSH
98842: LD_VAR 0 6
98846: PPUSH
98847: LD_VAR 0 4
98851: PPUSH
98852: CALL_OW 3
98856: ST_TO_ADDR
98857: GO 98757
98859: POP
98860: POP
// j := GetClosestHex ( unit , tmp ) ;
98861: LD_ADDR_VAR 0 5
98865: PUSH
98866: LD_VAR 0 1
98870: PPUSH
98871: LD_VAR 0 6
98875: PPUSH
98876: CALL 98161 0 2
98880: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98881: LD_VAR 0 1
98885: PPUSH
98886: LD_VAR 0 5
98890: PUSH
98891: LD_INT 1
98893: ARRAY
98894: PPUSH
98895: LD_VAR 0 5
98899: PUSH
98900: LD_INT 2
98902: ARRAY
98903: PPUSH
98904: CALL_OW 111
// end ;
98908: LD_VAR 0 3
98912: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98913: LD_INT 0
98915: PPUSH
98916: PPUSH
98917: PPUSH
// uc_side = 0 ;
98918: LD_ADDR_OWVAR 20
98922: PUSH
98923: LD_INT 0
98925: ST_TO_ADDR
// uc_nation = 0 ;
98926: LD_ADDR_OWVAR 21
98930: PUSH
98931: LD_INT 0
98933: ST_TO_ADDR
// InitHc ;
98934: CALL_OW 19
// InitVc ;
98938: CALL_OW 20
// if mastodonts then
98942: LD_VAR 0 6
98946: IFFALSE 99013
// for i = 1 to mastodonts do
98948: LD_ADDR_VAR 0 11
98952: PUSH
98953: DOUBLE
98954: LD_INT 1
98956: DEC
98957: ST_TO_ADDR
98958: LD_VAR 0 6
98962: PUSH
98963: FOR_TO
98964: IFFALSE 99011
// begin vc_chassis := 31 ;
98966: LD_ADDR_OWVAR 37
98970: PUSH
98971: LD_INT 31
98973: ST_TO_ADDR
// vc_control := control_rider ;
98974: LD_ADDR_OWVAR 38
98978: PUSH
98979: LD_INT 4
98981: ST_TO_ADDR
// animal := CreateVehicle ;
98982: LD_ADDR_VAR 0 12
98986: PUSH
98987: CALL_OW 45
98991: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98992: LD_VAR 0 12
98996: PPUSH
98997: LD_VAR 0 8
99001: PPUSH
99002: LD_INT 0
99004: PPUSH
99005: CALL 105758 0 3
// end ;
99009: GO 98963
99011: POP
99012: POP
// if horses then
99013: LD_VAR 0 5
99017: IFFALSE 99084
// for i = 1 to horses do
99019: LD_ADDR_VAR 0 11
99023: PUSH
99024: DOUBLE
99025: LD_INT 1
99027: DEC
99028: ST_TO_ADDR
99029: LD_VAR 0 5
99033: PUSH
99034: FOR_TO
99035: IFFALSE 99082
// begin hc_class := 21 ;
99037: LD_ADDR_OWVAR 28
99041: PUSH
99042: LD_INT 21
99044: ST_TO_ADDR
// hc_gallery :=  ;
99045: LD_ADDR_OWVAR 33
99049: PUSH
99050: LD_STRING 
99052: ST_TO_ADDR
// animal := CreateHuman ;
99053: LD_ADDR_VAR 0 12
99057: PUSH
99058: CALL_OW 44
99062: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99063: LD_VAR 0 12
99067: PPUSH
99068: LD_VAR 0 8
99072: PPUSH
99073: LD_INT 0
99075: PPUSH
99076: CALL 105758 0 3
// end ;
99080: GO 99034
99082: POP
99083: POP
// if birds then
99084: LD_VAR 0 1
99088: IFFALSE 99155
// for i = 1 to birds do
99090: LD_ADDR_VAR 0 11
99094: PUSH
99095: DOUBLE
99096: LD_INT 1
99098: DEC
99099: ST_TO_ADDR
99100: LD_VAR 0 1
99104: PUSH
99105: FOR_TO
99106: IFFALSE 99153
// begin hc_class = 18 ;
99108: LD_ADDR_OWVAR 28
99112: PUSH
99113: LD_INT 18
99115: ST_TO_ADDR
// hc_gallery =  ;
99116: LD_ADDR_OWVAR 33
99120: PUSH
99121: LD_STRING 
99123: ST_TO_ADDR
// animal := CreateHuman ;
99124: LD_ADDR_VAR 0 12
99128: PUSH
99129: CALL_OW 44
99133: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99134: LD_VAR 0 12
99138: PPUSH
99139: LD_VAR 0 8
99143: PPUSH
99144: LD_INT 0
99146: PPUSH
99147: CALL 105758 0 3
// end ;
99151: GO 99105
99153: POP
99154: POP
// if tigers then
99155: LD_VAR 0 2
99159: IFFALSE 99243
// for i = 1 to tigers do
99161: LD_ADDR_VAR 0 11
99165: PUSH
99166: DOUBLE
99167: LD_INT 1
99169: DEC
99170: ST_TO_ADDR
99171: LD_VAR 0 2
99175: PUSH
99176: FOR_TO
99177: IFFALSE 99241
// begin hc_class = class_tiger ;
99179: LD_ADDR_OWVAR 28
99183: PUSH
99184: LD_INT 14
99186: ST_TO_ADDR
// hc_gallery =  ;
99187: LD_ADDR_OWVAR 33
99191: PUSH
99192: LD_STRING 
99194: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99195: LD_ADDR_OWVAR 35
99199: PUSH
99200: LD_INT 7
99202: NEG
99203: PPUSH
99204: LD_INT 7
99206: PPUSH
99207: CALL_OW 12
99211: ST_TO_ADDR
// animal := CreateHuman ;
99212: LD_ADDR_VAR 0 12
99216: PUSH
99217: CALL_OW 44
99221: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99222: LD_VAR 0 12
99226: PPUSH
99227: LD_VAR 0 8
99231: PPUSH
99232: LD_INT 0
99234: PPUSH
99235: CALL 105758 0 3
// end ;
99239: GO 99176
99241: POP
99242: POP
// if apemans then
99243: LD_VAR 0 3
99247: IFFALSE 99370
// for i = 1 to apemans do
99249: LD_ADDR_VAR 0 11
99253: PUSH
99254: DOUBLE
99255: LD_INT 1
99257: DEC
99258: ST_TO_ADDR
99259: LD_VAR 0 3
99263: PUSH
99264: FOR_TO
99265: IFFALSE 99368
// begin hc_class = class_apeman ;
99267: LD_ADDR_OWVAR 28
99271: PUSH
99272: LD_INT 12
99274: ST_TO_ADDR
// hc_gallery =  ;
99275: LD_ADDR_OWVAR 33
99279: PUSH
99280: LD_STRING 
99282: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99283: LD_ADDR_OWVAR 35
99287: PUSH
99288: LD_INT 5
99290: NEG
99291: PPUSH
99292: LD_INT 5
99294: PPUSH
99295: CALL_OW 12
99299: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99300: LD_ADDR_OWVAR 31
99304: PUSH
99305: LD_INT 1
99307: PPUSH
99308: LD_INT 3
99310: PPUSH
99311: CALL_OW 12
99315: PUSH
99316: LD_INT 1
99318: PPUSH
99319: LD_INT 3
99321: PPUSH
99322: CALL_OW 12
99326: PUSH
99327: LD_INT 0
99329: PUSH
99330: LD_INT 0
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: ST_TO_ADDR
// animal := CreateHuman ;
99339: LD_ADDR_VAR 0 12
99343: PUSH
99344: CALL_OW 44
99348: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99349: LD_VAR 0 12
99353: PPUSH
99354: LD_VAR 0 8
99358: PPUSH
99359: LD_INT 0
99361: PPUSH
99362: CALL 105758 0 3
// end ;
99366: GO 99264
99368: POP
99369: POP
// if enchidnas then
99370: LD_VAR 0 4
99374: IFFALSE 99441
// for i = 1 to enchidnas do
99376: LD_ADDR_VAR 0 11
99380: PUSH
99381: DOUBLE
99382: LD_INT 1
99384: DEC
99385: ST_TO_ADDR
99386: LD_VAR 0 4
99390: PUSH
99391: FOR_TO
99392: IFFALSE 99439
// begin hc_class = 13 ;
99394: LD_ADDR_OWVAR 28
99398: PUSH
99399: LD_INT 13
99401: ST_TO_ADDR
// hc_gallery =  ;
99402: LD_ADDR_OWVAR 33
99406: PUSH
99407: LD_STRING 
99409: ST_TO_ADDR
// animal := CreateHuman ;
99410: LD_ADDR_VAR 0 12
99414: PUSH
99415: CALL_OW 44
99419: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99420: LD_VAR 0 12
99424: PPUSH
99425: LD_VAR 0 8
99429: PPUSH
99430: LD_INT 0
99432: PPUSH
99433: CALL 105758 0 3
// end ;
99437: GO 99391
99439: POP
99440: POP
// if fishes then
99441: LD_VAR 0 7
99445: IFFALSE 99512
// for i = 1 to fishes do
99447: LD_ADDR_VAR 0 11
99451: PUSH
99452: DOUBLE
99453: LD_INT 1
99455: DEC
99456: ST_TO_ADDR
99457: LD_VAR 0 7
99461: PUSH
99462: FOR_TO
99463: IFFALSE 99510
// begin hc_class = 20 ;
99465: LD_ADDR_OWVAR 28
99469: PUSH
99470: LD_INT 20
99472: ST_TO_ADDR
// hc_gallery =  ;
99473: LD_ADDR_OWVAR 33
99477: PUSH
99478: LD_STRING 
99480: ST_TO_ADDR
// animal := CreateHuman ;
99481: LD_ADDR_VAR 0 12
99485: PUSH
99486: CALL_OW 44
99490: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99491: LD_VAR 0 12
99495: PPUSH
99496: LD_VAR 0 9
99500: PPUSH
99501: LD_INT 0
99503: PPUSH
99504: CALL 105758 0 3
// end ;
99508: GO 99462
99510: POP
99511: POP
// end ;
99512: LD_VAR 0 10
99516: RET
// export function WantHeal ( sci , unit ) ; begin
99517: LD_INT 0
99519: PPUSH
// if GetTaskList ( sci ) > 0 then
99520: LD_VAR 0 1
99524: PPUSH
99525: CALL_OW 437
99529: PUSH
99530: LD_INT 0
99532: GREATER
99533: IFFALSE 99603
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99535: LD_VAR 0 1
99539: PPUSH
99540: CALL_OW 437
99544: PUSH
99545: LD_INT 1
99547: ARRAY
99548: PUSH
99549: LD_INT 1
99551: ARRAY
99552: PUSH
99553: LD_STRING l
99555: EQUAL
99556: PUSH
99557: LD_VAR 0 1
99561: PPUSH
99562: CALL_OW 437
99566: PUSH
99567: LD_INT 1
99569: ARRAY
99570: PUSH
99571: LD_INT 4
99573: ARRAY
99574: PUSH
99575: LD_VAR 0 2
99579: EQUAL
99580: AND
99581: IFFALSE 99593
// result := true else
99583: LD_ADDR_VAR 0 3
99587: PUSH
99588: LD_INT 1
99590: ST_TO_ADDR
99591: GO 99601
// result := false ;
99593: LD_ADDR_VAR 0 3
99597: PUSH
99598: LD_INT 0
99600: ST_TO_ADDR
// end else
99601: GO 99611
// result := false ;
99603: LD_ADDR_VAR 0 3
99607: PUSH
99608: LD_INT 0
99610: ST_TO_ADDR
// end ;
99611: LD_VAR 0 3
99615: RET
// export function HealTarget ( sci ) ; begin
99616: LD_INT 0
99618: PPUSH
// if not sci then
99619: LD_VAR 0 1
99623: NOT
99624: IFFALSE 99628
// exit ;
99626: GO 99693
// result := 0 ;
99628: LD_ADDR_VAR 0 2
99632: PUSH
99633: LD_INT 0
99635: ST_TO_ADDR
// if GetTaskList ( sci ) then
99636: LD_VAR 0 1
99640: PPUSH
99641: CALL_OW 437
99645: IFFALSE 99693
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99647: LD_VAR 0 1
99651: PPUSH
99652: CALL_OW 437
99656: PUSH
99657: LD_INT 1
99659: ARRAY
99660: PUSH
99661: LD_INT 1
99663: ARRAY
99664: PUSH
99665: LD_STRING l
99667: EQUAL
99668: IFFALSE 99693
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99670: LD_ADDR_VAR 0 2
99674: PUSH
99675: LD_VAR 0 1
99679: PPUSH
99680: CALL_OW 437
99684: PUSH
99685: LD_INT 1
99687: ARRAY
99688: PUSH
99689: LD_INT 4
99691: ARRAY
99692: ST_TO_ADDR
// end ;
99693: LD_VAR 0 2
99697: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99698: LD_INT 0
99700: PPUSH
99701: PPUSH
99702: PPUSH
99703: PPUSH
99704: PPUSH
99705: PPUSH
99706: PPUSH
99707: PPUSH
99708: PPUSH
99709: PPUSH
99710: PPUSH
99711: PPUSH
99712: PPUSH
99713: PPUSH
99714: PPUSH
99715: PPUSH
99716: PPUSH
99717: PPUSH
99718: PPUSH
99719: PPUSH
99720: PPUSH
99721: PPUSH
99722: PPUSH
99723: PPUSH
99724: PPUSH
99725: PPUSH
99726: PPUSH
99727: PPUSH
99728: PPUSH
99729: PPUSH
99730: PPUSH
99731: PPUSH
99732: PPUSH
99733: PPUSH
// if not list then
99734: LD_VAR 0 1
99738: NOT
99739: IFFALSE 99743
// exit ;
99741: GO 104369
// base := list [ 1 ] ;
99743: LD_ADDR_VAR 0 3
99747: PUSH
99748: LD_VAR 0 1
99752: PUSH
99753: LD_INT 1
99755: ARRAY
99756: ST_TO_ADDR
// group := list [ 2 ] ;
99757: LD_ADDR_VAR 0 4
99761: PUSH
99762: LD_VAR 0 1
99766: PUSH
99767: LD_INT 2
99769: ARRAY
99770: ST_TO_ADDR
// path := list [ 3 ] ;
99771: LD_ADDR_VAR 0 5
99775: PUSH
99776: LD_VAR 0 1
99780: PUSH
99781: LD_INT 3
99783: ARRAY
99784: ST_TO_ADDR
// flags := list [ 4 ] ;
99785: LD_ADDR_VAR 0 6
99789: PUSH
99790: LD_VAR 0 1
99794: PUSH
99795: LD_INT 4
99797: ARRAY
99798: ST_TO_ADDR
// mined := [ ] ;
99799: LD_ADDR_VAR 0 27
99803: PUSH
99804: EMPTY
99805: ST_TO_ADDR
// bombed := [ ] ;
99806: LD_ADDR_VAR 0 28
99810: PUSH
99811: EMPTY
99812: ST_TO_ADDR
// healers := [ ] ;
99813: LD_ADDR_VAR 0 31
99817: PUSH
99818: EMPTY
99819: ST_TO_ADDR
// to_heal := [ ] ;
99820: LD_ADDR_VAR 0 30
99824: PUSH
99825: EMPTY
99826: ST_TO_ADDR
// repairs := [ ] ;
99827: LD_ADDR_VAR 0 33
99831: PUSH
99832: EMPTY
99833: ST_TO_ADDR
// to_repair := [ ] ;
99834: LD_ADDR_VAR 0 32
99838: PUSH
99839: EMPTY
99840: ST_TO_ADDR
// if not group or not path then
99841: LD_VAR 0 4
99845: NOT
99846: PUSH
99847: LD_VAR 0 5
99851: NOT
99852: OR
99853: IFFALSE 99857
// exit ;
99855: GO 104369
// side := GetSide ( group [ 1 ] ) ;
99857: LD_ADDR_VAR 0 35
99861: PUSH
99862: LD_VAR 0 4
99866: PUSH
99867: LD_INT 1
99869: ARRAY
99870: PPUSH
99871: CALL_OW 255
99875: ST_TO_ADDR
// if flags then
99876: LD_VAR 0 6
99880: IFFALSE 100024
// begin f_ignore_area := flags [ 1 ] ;
99882: LD_ADDR_VAR 0 17
99886: PUSH
99887: LD_VAR 0 6
99891: PUSH
99892: LD_INT 1
99894: ARRAY
99895: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99896: LD_ADDR_VAR 0 18
99900: PUSH
99901: LD_VAR 0 6
99905: PUSH
99906: LD_INT 2
99908: ARRAY
99909: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99910: LD_ADDR_VAR 0 19
99914: PUSH
99915: LD_VAR 0 6
99919: PUSH
99920: LD_INT 3
99922: ARRAY
99923: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99924: LD_ADDR_VAR 0 20
99928: PUSH
99929: LD_VAR 0 6
99933: PUSH
99934: LD_INT 4
99936: ARRAY
99937: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99938: LD_ADDR_VAR 0 21
99942: PUSH
99943: LD_VAR 0 6
99947: PUSH
99948: LD_INT 5
99950: ARRAY
99951: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99952: LD_ADDR_VAR 0 22
99956: PUSH
99957: LD_VAR 0 6
99961: PUSH
99962: LD_INT 6
99964: ARRAY
99965: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99966: LD_ADDR_VAR 0 23
99970: PUSH
99971: LD_VAR 0 6
99975: PUSH
99976: LD_INT 7
99978: ARRAY
99979: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99980: LD_ADDR_VAR 0 24
99984: PUSH
99985: LD_VAR 0 6
99989: PUSH
99990: LD_INT 8
99992: ARRAY
99993: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99994: LD_ADDR_VAR 0 25
99998: PUSH
99999: LD_VAR 0 6
100003: PUSH
100004: LD_INT 9
100006: ARRAY
100007: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100008: LD_ADDR_VAR 0 26
100012: PUSH
100013: LD_VAR 0 6
100017: PUSH
100018: LD_INT 10
100020: ARRAY
100021: ST_TO_ADDR
// end else
100022: GO 100104
// begin f_ignore_area := false ;
100024: LD_ADDR_VAR 0 17
100028: PUSH
100029: LD_INT 0
100031: ST_TO_ADDR
// f_capture := false ;
100032: LD_ADDR_VAR 0 18
100036: PUSH
100037: LD_INT 0
100039: ST_TO_ADDR
// f_ignore_civ := false ;
100040: LD_ADDR_VAR 0 19
100044: PUSH
100045: LD_INT 0
100047: ST_TO_ADDR
// f_murder := false ;
100048: LD_ADDR_VAR 0 20
100052: PUSH
100053: LD_INT 0
100055: ST_TO_ADDR
// f_mines := false ;
100056: LD_ADDR_VAR 0 21
100060: PUSH
100061: LD_INT 0
100063: ST_TO_ADDR
// f_repair := false ;
100064: LD_ADDR_VAR 0 22
100068: PUSH
100069: LD_INT 0
100071: ST_TO_ADDR
// f_heal := false ;
100072: LD_ADDR_VAR 0 23
100076: PUSH
100077: LD_INT 0
100079: ST_TO_ADDR
// f_spacetime := false ;
100080: LD_ADDR_VAR 0 24
100084: PUSH
100085: LD_INT 0
100087: ST_TO_ADDR
// f_attack_depot := false ;
100088: LD_ADDR_VAR 0 25
100092: PUSH
100093: LD_INT 0
100095: ST_TO_ADDR
// f_crawl := false ;
100096: LD_ADDR_VAR 0 26
100100: PUSH
100101: LD_INT 0
100103: ST_TO_ADDR
// end ; if f_heal then
100104: LD_VAR 0 23
100108: IFFALSE 100135
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100110: LD_ADDR_VAR 0 31
100114: PUSH
100115: LD_VAR 0 4
100119: PPUSH
100120: LD_INT 25
100122: PUSH
100123: LD_INT 4
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: PPUSH
100130: CALL_OW 72
100134: ST_TO_ADDR
// if f_repair then
100135: LD_VAR 0 22
100139: IFFALSE 100166
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100141: LD_ADDR_VAR 0 33
100145: PUSH
100146: LD_VAR 0 4
100150: PPUSH
100151: LD_INT 25
100153: PUSH
100154: LD_INT 3
100156: PUSH
100157: EMPTY
100158: LIST
100159: LIST
100160: PPUSH
100161: CALL_OW 72
100165: ST_TO_ADDR
// units_path := [ ] ;
100166: LD_ADDR_VAR 0 16
100170: PUSH
100171: EMPTY
100172: ST_TO_ADDR
// for i = 1 to group do
100173: LD_ADDR_VAR 0 7
100177: PUSH
100178: DOUBLE
100179: LD_INT 1
100181: DEC
100182: ST_TO_ADDR
100183: LD_VAR 0 4
100187: PUSH
100188: FOR_TO
100189: IFFALSE 100218
// units_path := Replace ( units_path , i , path ) ;
100191: LD_ADDR_VAR 0 16
100195: PUSH
100196: LD_VAR 0 16
100200: PPUSH
100201: LD_VAR 0 7
100205: PPUSH
100206: LD_VAR 0 5
100210: PPUSH
100211: CALL_OW 1
100215: ST_TO_ADDR
100216: GO 100188
100218: POP
100219: POP
// repeat for i = group downto 1 do
100220: LD_ADDR_VAR 0 7
100224: PUSH
100225: DOUBLE
100226: LD_VAR 0 4
100230: INC
100231: ST_TO_ADDR
100232: LD_INT 1
100234: PUSH
100235: FOR_DOWNTO
100236: IFFALSE 104332
// begin wait ( 5 ) ;
100238: LD_INT 5
100240: PPUSH
100241: CALL_OW 67
// tmp := [ ] ;
100245: LD_ADDR_VAR 0 14
100249: PUSH
100250: EMPTY
100251: ST_TO_ADDR
// attacking := false ;
100252: LD_ADDR_VAR 0 29
100256: PUSH
100257: LD_INT 0
100259: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100260: LD_VAR 0 4
100264: PUSH
100265: LD_VAR 0 7
100269: ARRAY
100270: PPUSH
100271: CALL_OW 301
100275: PUSH
100276: LD_VAR 0 4
100280: PUSH
100281: LD_VAR 0 7
100285: ARRAY
100286: NOT
100287: OR
100288: IFFALSE 100397
// begin if GetType ( group [ i ] ) = unit_human then
100290: LD_VAR 0 4
100294: PUSH
100295: LD_VAR 0 7
100299: ARRAY
100300: PPUSH
100301: CALL_OW 247
100305: PUSH
100306: LD_INT 1
100308: EQUAL
100309: IFFALSE 100355
// begin to_heal := to_heal diff group [ i ] ;
100311: LD_ADDR_VAR 0 30
100315: PUSH
100316: LD_VAR 0 30
100320: PUSH
100321: LD_VAR 0 4
100325: PUSH
100326: LD_VAR 0 7
100330: ARRAY
100331: DIFF
100332: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100333: LD_ADDR_VAR 0 31
100337: PUSH
100338: LD_VAR 0 31
100342: PUSH
100343: LD_VAR 0 4
100347: PUSH
100348: LD_VAR 0 7
100352: ARRAY
100353: DIFF
100354: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100355: LD_ADDR_VAR 0 4
100359: PUSH
100360: LD_VAR 0 4
100364: PPUSH
100365: LD_VAR 0 7
100369: PPUSH
100370: CALL_OW 3
100374: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100375: LD_ADDR_VAR 0 16
100379: PUSH
100380: LD_VAR 0 16
100384: PPUSH
100385: LD_VAR 0 7
100389: PPUSH
100390: CALL_OW 3
100394: ST_TO_ADDR
// continue ;
100395: GO 100235
// end ; if f_repair then
100397: LD_VAR 0 22
100401: IFFALSE 100890
// begin if GetType ( group [ i ] ) = unit_vehicle then
100403: LD_VAR 0 4
100407: PUSH
100408: LD_VAR 0 7
100412: ARRAY
100413: PPUSH
100414: CALL_OW 247
100418: PUSH
100419: LD_INT 2
100421: EQUAL
100422: IFFALSE 100612
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100424: LD_VAR 0 4
100428: PUSH
100429: LD_VAR 0 7
100433: ARRAY
100434: PPUSH
100435: CALL_OW 256
100439: PUSH
100440: LD_INT 700
100442: LESS
100443: PUSH
100444: LD_VAR 0 4
100448: PUSH
100449: LD_VAR 0 7
100453: ARRAY
100454: PUSH
100455: LD_VAR 0 32
100459: IN
100460: NOT
100461: AND
100462: IFFALSE 100486
// to_repair := to_repair union group [ i ] ;
100464: LD_ADDR_VAR 0 32
100468: PUSH
100469: LD_VAR 0 32
100473: PUSH
100474: LD_VAR 0 4
100478: PUSH
100479: LD_VAR 0 7
100483: ARRAY
100484: UNION
100485: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100486: LD_VAR 0 4
100490: PUSH
100491: LD_VAR 0 7
100495: ARRAY
100496: PPUSH
100497: CALL_OW 256
100501: PUSH
100502: LD_INT 1000
100504: EQUAL
100505: PUSH
100506: LD_VAR 0 4
100510: PUSH
100511: LD_VAR 0 7
100515: ARRAY
100516: PUSH
100517: LD_VAR 0 32
100521: IN
100522: AND
100523: IFFALSE 100547
// to_repair := to_repair diff group [ i ] ;
100525: LD_ADDR_VAR 0 32
100529: PUSH
100530: LD_VAR 0 32
100534: PUSH
100535: LD_VAR 0 4
100539: PUSH
100540: LD_VAR 0 7
100544: ARRAY
100545: DIFF
100546: ST_TO_ADDR
// if group [ i ] in to_repair then
100547: LD_VAR 0 4
100551: PUSH
100552: LD_VAR 0 7
100556: ARRAY
100557: PUSH
100558: LD_VAR 0 32
100562: IN
100563: IFFALSE 100610
// begin if not IsInArea ( group [ i ] , f_repair ) then
100565: LD_VAR 0 4
100569: PUSH
100570: LD_VAR 0 7
100574: ARRAY
100575: PPUSH
100576: LD_VAR 0 22
100580: PPUSH
100581: CALL_OW 308
100585: NOT
100586: IFFALSE 100608
// ComMoveToArea ( group [ i ] , f_repair ) ;
100588: LD_VAR 0 4
100592: PUSH
100593: LD_VAR 0 7
100597: ARRAY
100598: PPUSH
100599: LD_VAR 0 22
100603: PPUSH
100604: CALL_OW 113
// continue ;
100608: GO 100235
// end ; end else
100610: GO 100890
// if group [ i ] in repairs then
100612: LD_VAR 0 4
100616: PUSH
100617: LD_VAR 0 7
100621: ARRAY
100622: PUSH
100623: LD_VAR 0 33
100627: IN
100628: IFFALSE 100890
// begin if IsInUnit ( group [ i ] ) then
100630: LD_VAR 0 4
100634: PUSH
100635: LD_VAR 0 7
100639: ARRAY
100640: PPUSH
100641: CALL_OW 310
100645: IFFALSE 100713
// begin z := IsInUnit ( group [ i ] ) ;
100647: LD_ADDR_VAR 0 13
100651: PUSH
100652: LD_VAR 0 4
100656: PUSH
100657: LD_VAR 0 7
100661: ARRAY
100662: PPUSH
100663: CALL_OW 310
100667: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100668: LD_VAR 0 13
100672: PUSH
100673: LD_VAR 0 32
100677: IN
100678: PUSH
100679: LD_VAR 0 13
100683: PPUSH
100684: LD_VAR 0 22
100688: PPUSH
100689: CALL_OW 308
100693: AND
100694: IFFALSE 100711
// ComExitVehicle ( group [ i ] ) ;
100696: LD_VAR 0 4
100700: PUSH
100701: LD_VAR 0 7
100705: ARRAY
100706: PPUSH
100707: CALL_OW 121
// end else
100711: GO 100890
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100713: LD_ADDR_VAR 0 13
100717: PUSH
100718: LD_VAR 0 4
100722: PPUSH
100723: LD_INT 95
100725: PUSH
100726: LD_VAR 0 22
100730: PUSH
100731: EMPTY
100732: LIST
100733: LIST
100734: PUSH
100735: LD_INT 58
100737: PUSH
100738: EMPTY
100739: LIST
100740: PUSH
100741: EMPTY
100742: LIST
100743: LIST
100744: PPUSH
100745: CALL_OW 72
100749: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100750: LD_VAR 0 4
100754: PUSH
100755: LD_VAR 0 7
100759: ARRAY
100760: PPUSH
100761: CALL_OW 314
100765: NOT
100766: IFFALSE 100888
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100768: LD_ADDR_VAR 0 10
100772: PUSH
100773: LD_VAR 0 13
100777: PPUSH
100778: LD_VAR 0 4
100782: PUSH
100783: LD_VAR 0 7
100787: ARRAY
100788: PPUSH
100789: CALL_OW 74
100793: ST_TO_ADDR
// if not x then
100794: LD_VAR 0 10
100798: NOT
100799: IFFALSE 100803
// continue ;
100801: GO 100235
// if GetLives ( x ) < 1000 then
100803: LD_VAR 0 10
100807: PPUSH
100808: CALL_OW 256
100812: PUSH
100813: LD_INT 1000
100815: LESS
100816: IFFALSE 100840
// ComRepairVehicle ( group [ i ] , x ) else
100818: LD_VAR 0 4
100822: PUSH
100823: LD_VAR 0 7
100827: ARRAY
100828: PPUSH
100829: LD_VAR 0 10
100833: PPUSH
100834: CALL_OW 129
100838: GO 100888
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100840: LD_VAR 0 23
100844: PUSH
100845: LD_VAR 0 4
100849: PUSH
100850: LD_VAR 0 7
100854: ARRAY
100855: PPUSH
100856: CALL_OW 256
100860: PUSH
100861: LD_INT 1000
100863: LESS
100864: AND
100865: NOT
100866: IFFALSE 100888
// ComEnterUnit ( group [ i ] , x ) ;
100868: LD_VAR 0 4
100872: PUSH
100873: LD_VAR 0 7
100877: ARRAY
100878: PPUSH
100879: LD_VAR 0 10
100883: PPUSH
100884: CALL_OW 120
// end ; continue ;
100888: GO 100235
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100890: LD_VAR 0 23
100894: PUSH
100895: LD_VAR 0 4
100899: PUSH
100900: LD_VAR 0 7
100904: ARRAY
100905: PPUSH
100906: CALL_OW 247
100910: PUSH
100911: LD_INT 1
100913: EQUAL
100914: AND
100915: IFFALSE 101393
// begin if group [ i ] in healers then
100917: LD_VAR 0 4
100921: PUSH
100922: LD_VAR 0 7
100926: ARRAY
100927: PUSH
100928: LD_VAR 0 31
100932: IN
100933: IFFALSE 101206
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100935: LD_VAR 0 4
100939: PUSH
100940: LD_VAR 0 7
100944: ARRAY
100945: PPUSH
100946: LD_VAR 0 23
100950: PPUSH
100951: CALL_OW 308
100955: NOT
100956: PUSH
100957: LD_VAR 0 4
100961: PUSH
100962: LD_VAR 0 7
100966: ARRAY
100967: PPUSH
100968: CALL_OW 314
100972: NOT
100973: AND
100974: IFFALSE 100998
// ComMoveToArea ( group [ i ] , f_heal ) else
100976: LD_VAR 0 4
100980: PUSH
100981: LD_VAR 0 7
100985: ARRAY
100986: PPUSH
100987: LD_VAR 0 23
100991: PPUSH
100992: CALL_OW 113
100996: GO 101204
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100998: LD_VAR 0 4
101002: PUSH
101003: LD_VAR 0 7
101007: ARRAY
101008: PPUSH
101009: CALL 99616 0 1
101013: PPUSH
101014: CALL_OW 256
101018: PUSH
101019: LD_INT 1000
101021: EQUAL
101022: IFFALSE 101041
// ComStop ( group [ i ] ) else
101024: LD_VAR 0 4
101028: PUSH
101029: LD_VAR 0 7
101033: ARRAY
101034: PPUSH
101035: CALL_OW 141
101039: GO 101204
// if not HasTask ( group [ i ] ) and to_heal then
101041: LD_VAR 0 4
101045: PUSH
101046: LD_VAR 0 7
101050: ARRAY
101051: PPUSH
101052: CALL_OW 314
101056: NOT
101057: PUSH
101058: LD_VAR 0 30
101062: AND
101063: IFFALSE 101204
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101065: LD_ADDR_VAR 0 13
101069: PUSH
101070: LD_VAR 0 30
101074: PPUSH
101075: LD_INT 3
101077: PUSH
101078: LD_INT 54
101080: PUSH
101081: EMPTY
101082: LIST
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: PPUSH
101088: CALL_OW 72
101092: PPUSH
101093: LD_VAR 0 4
101097: PUSH
101098: LD_VAR 0 7
101102: ARRAY
101103: PPUSH
101104: CALL_OW 74
101108: ST_TO_ADDR
// if z then
101109: LD_VAR 0 13
101113: IFFALSE 101204
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101115: LD_INT 91
101117: PUSH
101118: LD_VAR 0 13
101122: PUSH
101123: LD_INT 10
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: LIST
101130: PUSH
101131: LD_INT 81
101133: PUSH
101134: LD_VAR 0 13
101138: PPUSH
101139: CALL_OW 255
101143: PUSH
101144: EMPTY
101145: LIST
101146: LIST
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: PPUSH
101152: CALL_OW 69
101156: PUSH
101157: LD_INT 0
101159: EQUAL
101160: IFFALSE 101184
// ComHeal ( group [ i ] , z ) else
101162: LD_VAR 0 4
101166: PUSH
101167: LD_VAR 0 7
101171: ARRAY
101172: PPUSH
101173: LD_VAR 0 13
101177: PPUSH
101178: CALL_OW 128
101182: GO 101204
// ComMoveToArea ( group [ i ] , f_heal ) ;
101184: LD_VAR 0 4
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PPUSH
101195: LD_VAR 0 23
101199: PPUSH
101200: CALL_OW 113
// end ; continue ;
101204: GO 100235
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101206: LD_VAR 0 4
101210: PUSH
101211: LD_VAR 0 7
101215: ARRAY
101216: PPUSH
101217: CALL_OW 256
101221: PUSH
101222: LD_INT 700
101224: LESS
101225: PUSH
101226: LD_VAR 0 4
101230: PUSH
101231: LD_VAR 0 7
101235: ARRAY
101236: PUSH
101237: LD_VAR 0 30
101241: IN
101242: NOT
101243: AND
101244: IFFALSE 101268
// to_heal := to_heal union group [ i ] ;
101246: LD_ADDR_VAR 0 30
101250: PUSH
101251: LD_VAR 0 30
101255: PUSH
101256: LD_VAR 0 4
101260: PUSH
101261: LD_VAR 0 7
101265: ARRAY
101266: UNION
101267: ST_TO_ADDR
// if group [ i ] in to_heal then
101268: LD_VAR 0 4
101272: PUSH
101273: LD_VAR 0 7
101277: ARRAY
101278: PUSH
101279: LD_VAR 0 30
101283: IN
101284: IFFALSE 101393
// begin if GetLives ( group [ i ] ) = 1000 then
101286: LD_VAR 0 4
101290: PUSH
101291: LD_VAR 0 7
101295: ARRAY
101296: PPUSH
101297: CALL_OW 256
101301: PUSH
101302: LD_INT 1000
101304: EQUAL
101305: IFFALSE 101331
// to_heal := to_heal diff group [ i ] else
101307: LD_ADDR_VAR 0 30
101311: PUSH
101312: LD_VAR 0 30
101316: PUSH
101317: LD_VAR 0 4
101321: PUSH
101322: LD_VAR 0 7
101326: ARRAY
101327: DIFF
101328: ST_TO_ADDR
101329: GO 101393
// begin if not IsInArea ( group [ i ] , to_heal ) then
101331: LD_VAR 0 4
101335: PUSH
101336: LD_VAR 0 7
101340: ARRAY
101341: PPUSH
101342: LD_VAR 0 30
101346: PPUSH
101347: CALL_OW 308
101351: NOT
101352: IFFALSE 101376
// ComMoveToArea ( group [ i ] , f_heal ) else
101354: LD_VAR 0 4
101358: PUSH
101359: LD_VAR 0 7
101363: ARRAY
101364: PPUSH
101365: LD_VAR 0 23
101369: PPUSH
101370: CALL_OW 113
101374: GO 101391
// ComHold ( group [ i ] ) ;
101376: LD_VAR 0 4
101380: PUSH
101381: LD_VAR 0 7
101385: ARRAY
101386: PPUSH
101387: CALL_OW 140
// continue ;
101391: GO 100235
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101393: LD_VAR 0 4
101397: PUSH
101398: LD_VAR 0 7
101402: ARRAY
101403: PPUSH
101404: LD_INT 10
101406: PPUSH
101407: CALL 98013 0 2
101411: NOT
101412: PUSH
101413: LD_VAR 0 16
101417: PUSH
101418: LD_VAR 0 7
101422: ARRAY
101423: PUSH
101424: EMPTY
101425: EQUAL
101426: NOT
101427: AND
101428: IFFALSE 101694
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101430: LD_VAR 0 4
101434: PUSH
101435: LD_VAR 0 7
101439: ARRAY
101440: PPUSH
101441: CALL_OW 262
101445: PUSH
101446: LD_INT 1
101448: PUSH
101449: LD_INT 2
101451: PUSH
101452: EMPTY
101453: LIST
101454: LIST
101455: IN
101456: IFFALSE 101497
// if GetFuel ( group [ i ] ) < 10 then
101458: LD_VAR 0 4
101462: PUSH
101463: LD_VAR 0 7
101467: ARRAY
101468: PPUSH
101469: CALL_OW 261
101473: PUSH
101474: LD_INT 10
101476: LESS
101477: IFFALSE 101497
// SetFuel ( group [ i ] , 12 ) ;
101479: LD_VAR 0 4
101483: PUSH
101484: LD_VAR 0 7
101488: ARRAY
101489: PPUSH
101490: LD_INT 12
101492: PPUSH
101493: CALL_OW 240
// if units_path [ i ] then
101497: LD_VAR 0 16
101501: PUSH
101502: LD_VAR 0 7
101506: ARRAY
101507: IFFALSE 101692
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101509: LD_VAR 0 4
101513: PUSH
101514: LD_VAR 0 7
101518: ARRAY
101519: PPUSH
101520: LD_VAR 0 16
101524: PUSH
101525: LD_VAR 0 7
101529: ARRAY
101530: PUSH
101531: LD_INT 1
101533: ARRAY
101534: PUSH
101535: LD_INT 1
101537: ARRAY
101538: PPUSH
101539: LD_VAR 0 16
101543: PUSH
101544: LD_VAR 0 7
101548: ARRAY
101549: PUSH
101550: LD_INT 1
101552: ARRAY
101553: PUSH
101554: LD_INT 2
101556: ARRAY
101557: PPUSH
101558: CALL_OW 297
101562: PUSH
101563: LD_INT 6
101565: GREATER
101566: IFFALSE 101641
// begin if not HasTask ( group [ i ] ) then
101568: LD_VAR 0 4
101572: PUSH
101573: LD_VAR 0 7
101577: ARRAY
101578: PPUSH
101579: CALL_OW 314
101583: NOT
101584: IFFALSE 101639
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101586: LD_VAR 0 4
101590: PUSH
101591: LD_VAR 0 7
101595: ARRAY
101596: PPUSH
101597: LD_VAR 0 16
101601: PUSH
101602: LD_VAR 0 7
101606: ARRAY
101607: PUSH
101608: LD_INT 1
101610: ARRAY
101611: PUSH
101612: LD_INT 1
101614: ARRAY
101615: PPUSH
101616: LD_VAR 0 16
101620: PUSH
101621: LD_VAR 0 7
101625: ARRAY
101626: PUSH
101627: LD_INT 1
101629: ARRAY
101630: PUSH
101631: LD_INT 2
101633: ARRAY
101634: PPUSH
101635: CALL_OW 114
// end else
101639: GO 101692
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101641: LD_ADDR_VAR 0 15
101645: PUSH
101646: LD_VAR 0 16
101650: PUSH
101651: LD_VAR 0 7
101655: ARRAY
101656: PPUSH
101657: LD_INT 1
101659: PPUSH
101660: CALL_OW 3
101664: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101665: LD_ADDR_VAR 0 16
101669: PUSH
101670: LD_VAR 0 16
101674: PPUSH
101675: LD_VAR 0 7
101679: PPUSH
101680: LD_VAR 0 15
101684: PPUSH
101685: CALL_OW 1
101689: ST_TO_ADDR
// continue ;
101690: GO 100235
// end ; end ; end else
101692: GO 104330
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101694: LD_ADDR_VAR 0 14
101698: PUSH
101699: LD_INT 81
101701: PUSH
101702: LD_VAR 0 4
101706: PUSH
101707: LD_VAR 0 7
101711: ARRAY
101712: PPUSH
101713: CALL_OW 255
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: PPUSH
101722: CALL_OW 69
101726: ST_TO_ADDR
// if not tmp then
101727: LD_VAR 0 14
101731: NOT
101732: IFFALSE 101736
// continue ;
101734: GO 100235
// if f_ignore_area then
101736: LD_VAR 0 17
101740: IFFALSE 101828
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101742: LD_ADDR_VAR 0 15
101746: PUSH
101747: LD_VAR 0 14
101751: PPUSH
101752: LD_INT 3
101754: PUSH
101755: LD_INT 92
101757: PUSH
101758: LD_VAR 0 17
101762: PUSH
101763: LD_INT 1
101765: ARRAY
101766: PUSH
101767: LD_VAR 0 17
101771: PUSH
101772: LD_INT 2
101774: ARRAY
101775: PUSH
101776: LD_VAR 0 17
101780: PUSH
101781: LD_INT 3
101783: ARRAY
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: PUSH
101791: EMPTY
101792: LIST
101793: LIST
101794: PPUSH
101795: CALL_OW 72
101799: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101800: LD_VAR 0 14
101804: PUSH
101805: LD_VAR 0 15
101809: DIFF
101810: IFFALSE 101828
// tmp := tmp diff tmp2 ;
101812: LD_ADDR_VAR 0 14
101816: PUSH
101817: LD_VAR 0 14
101821: PUSH
101822: LD_VAR 0 15
101826: DIFF
101827: ST_TO_ADDR
// end ; if not f_murder then
101828: LD_VAR 0 20
101832: NOT
101833: IFFALSE 101891
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101835: LD_ADDR_VAR 0 15
101839: PUSH
101840: LD_VAR 0 14
101844: PPUSH
101845: LD_INT 3
101847: PUSH
101848: LD_INT 50
101850: PUSH
101851: EMPTY
101852: LIST
101853: PUSH
101854: EMPTY
101855: LIST
101856: LIST
101857: PPUSH
101858: CALL_OW 72
101862: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101863: LD_VAR 0 14
101867: PUSH
101868: LD_VAR 0 15
101872: DIFF
101873: IFFALSE 101891
// tmp := tmp diff tmp2 ;
101875: LD_ADDR_VAR 0 14
101879: PUSH
101880: LD_VAR 0 14
101884: PUSH
101885: LD_VAR 0 15
101889: DIFF
101890: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101891: LD_ADDR_VAR 0 14
101895: PUSH
101896: LD_VAR 0 4
101900: PUSH
101901: LD_VAR 0 7
101905: ARRAY
101906: PPUSH
101907: LD_VAR 0 14
101911: PPUSH
101912: LD_INT 1
101914: PPUSH
101915: LD_INT 1
101917: PPUSH
101918: CALL 71656 0 4
101922: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101923: LD_VAR 0 4
101927: PUSH
101928: LD_VAR 0 7
101932: ARRAY
101933: PPUSH
101934: CALL_OW 257
101938: PUSH
101939: LD_INT 1
101941: EQUAL
101942: IFFALSE 102390
// begin if WantPlant ( group [ i ] ) then
101944: LD_VAR 0 4
101948: PUSH
101949: LD_VAR 0 7
101953: ARRAY
101954: PPUSH
101955: CALL 71157 0 1
101959: IFFALSE 101963
// continue ;
101961: GO 100235
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101963: LD_VAR 0 18
101967: PUSH
101968: LD_VAR 0 4
101972: PUSH
101973: LD_VAR 0 7
101977: ARRAY
101978: PPUSH
101979: CALL_OW 310
101983: NOT
101984: AND
101985: PUSH
101986: LD_VAR 0 14
101990: PUSH
101991: LD_INT 1
101993: ARRAY
101994: PUSH
101995: LD_VAR 0 14
101999: PPUSH
102000: LD_INT 21
102002: PUSH
102003: LD_INT 2
102005: PUSH
102006: EMPTY
102007: LIST
102008: LIST
102009: PUSH
102010: LD_INT 58
102012: PUSH
102013: EMPTY
102014: LIST
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: PPUSH
102020: CALL_OW 72
102024: IN
102025: AND
102026: IFFALSE 102062
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102028: LD_VAR 0 4
102032: PUSH
102033: LD_VAR 0 7
102037: ARRAY
102038: PPUSH
102039: LD_VAR 0 14
102043: PUSH
102044: LD_INT 1
102046: ARRAY
102047: PPUSH
102048: CALL_OW 120
// attacking := true ;
102052: LD_ADDR_VAR 0 29
102056: PUSH
102057: LD_INT 1
102059: ST_TO_ADDR
// continue ;
102060: GO 100235
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102062: LD_VAR 0 26
102066: PUSH
102067: LD_VAR 0 4
102071: PUSH
102072: LD_VAR 0 7
102076: ARRAY
102077: PPUSH
102078: CALL_OW 257
102082: PUSH
102083: LD_INT 1
102085: EQUAL
102086: AND
102087: PUSH
102088: LD_VAR 0 4
102092: PUSH
102093: LD_VAR 0 7
102097: ARRAY
102098: PPUSH
102099: CALL_OW 256
102103: PUSH
102104: LD_INT 800
102106: LESS
102107: AND
102108: PUSH
102109: LD_VAR 0 4
102113: PUSH
102114: LD_VAR 0 7
102118: ARRAY
102119: PPUSH
102120: CALL_OW 318
102124: NOT
102125: AND
102126: IFFALSE 102143
// ComCrawl ( group [ i ] ) ;
102128: LD_VAR 0 4
102132: PUSH
102133: LD_VAR 0 7
102137: ARRAY
102138: PPUSH
102139: CALL_OW 137
// if f_mines then
102143: LD_VAR 0 21
102147: IFFALSE 102390
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102149: LD_VAR 0 14
102153: PUSH
102154: LD_INT 1
102156: ARRAY
102157: PPUSH
102158: CALL_OW 247
102162: PUSH
102163: LD_INT 3
102165: EQUAL
102166: PUSH
102167: LD_VAR 0 14
102171: PUSH
102172: LD_INT 1
102174: ARRAY
102175: PUSH
102176: LD_VAR 0 27
102180: IN
102181: NOT
102182: AND
102183: IFFALSE 102390
// begin x := GetX ( tmp [ 1 ] ) ;
102185: LD_ADDR_VAR 0 10
102189: PUSH
102190: LD_VAR 0 14
102194: PUSH
102195: LD_INT 1
102197: ARRAY
102198: PPUSH
102199: CALL_OW 250
102203: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102204: LD_ADDR_VAR 0 11
102208: PUSH
102209: LD_VAR 0 14
102213: PUSH
102214: LD_INT 1
102216: ARRAY
102217: PPUSH
102218: CALL_OW 251
102222: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102223: LD_ADDR_VAR 0 12
102227: PUSH
102228: LD_VAR 0 4
102232: PUSH
102233: LD_VAR 0 7
102237: ARRAY
102238: PPUSH
102239: CALL 98098 0 1
102243: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102244: LD_VAR 0 4
102248: PUSH
102249: LD_VAR 0 7
102253: ARRAY
102254: PPUSH
102255: LD_VAR 0 10
102259: PPUSH
102260: LD_VAR 0 11
102264: PPUSH
102265: LD_VAR 0 14
102269: PUSH
102270: LD_INT 1
102272: ARRAY
102273: PPUSH
102274: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102278: LD_VAR 0 4
102282: PUSH
102283: LD_VAR 0 7
102287: ARRAY
102288: PPUSH
102289: LD_VAR 0 10
102293: PPUSH
102294: LD_VAR 0 12
102298: PPUSH
102299: LD_INT 7
102301: PPUSH
102302: CALL_OW 272
102306: PPUSH
102307: LD_VAR 0 11
102311: PPUSH
102312: LD_VAR 0 12
102316: PPUSH
102317: LD_INT 7
102319: PPUSH
102320: CALL_OW 273
102324: PPUSH
102325: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102329: LD_VAR 0 4
102333: PUSH
102334: LD_VAR 0 7
102338: ARRAY
102339: PPUSH
102340: LD_INT 71
102342: PPUSH
102343: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102347: LD_ADDR_VAR 0 27
102351: PUSH
102352: LD_VAR 0 27
102356: PPUSH
102357: LD_VAR 0 27
102361: PUSH
102362: LD_INT 1
102364: PLUS
102365: PPUSH
102366: LD_VAR 0 14
102370: PUSH
102371: LD_INT 1
102373: ARRAY
102374: PPUSH
102375: CALL_OW 1
102379: ST_TO_ADDR
// attacking := true ;
102380: LD_ADDR_VAR 0 29
102384: PUSH
102385: LD_INT 1
102387: ST_TO_ADDR
// continue ;
102388: GO 100235
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102390: LD_VAR 0 4
102394: PUSH
102395: LD_VAR 0 7
102399: ARRAY
102400: PPUSH
102401: CALL_OW 257
102405: PUSH
102406: LD_INT 17
102408: EQUAL
102409: PUSH
102410: LD_VAR 0 4
102414: PUSH
102415: LD_VAR 0 7
102419: ARRAY
102420: PPUSH
102421: CALL_OW 110
102425: PUSH
102426: LD_INT 71
102428: EQUAL
102429: NOT
102430: AND
102431: IFFALSE 102577
// begin attacking := false ;
102433: LD_ADDR_VAR 0 29
102437: PUSH
102438: LD_INT 0
102440: ST_TO_ADDR
// k := 5 ;
102441: LD_ADDR_VAR 0 9
102445: PUSH
102446: LD_INT 5
102448: ST_TO_ADDR
// if tmp < k then
102449: LD_VAR 0 14
102453: PUSH
102454: LD_VAR 0 9
102458: LESS
102459: IFFALSE 102471
// k := tmp ;
102461: LD_ADDR_VAR 0 9
102465: PUSH
102466: LD_VAR 0 14
102470: ST_TO_ADDR
// for j = 1 to k do
102471: LD_ADDR_VAR 0 8
102475: PUSH
102476: DOUBLE
102477: LD_INT 1
102479: DEC
102480: ST_TO_ADDR
102481: LD_VAR 0 9
102485: PUSH
102486: FOR_TO
102487: IFFALSE 102575
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102489: LD_VAR 0 14
102493: PUSH
102494: LD_VAR 0 8
102498: ARRAY
102499: PUSH
102500: LD_VAR 0 14
102504: PPUSH
102505: LD_INT 58
102507: PUSH
102508: EMPTY
102509: LIST
102510: PPUSH
102511: CALL_OW 72
102515: IN
102516: NOT
102517: IFFALSE 102573
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102519: LD_VAR 0 4
102523: PUSH
102524: LD_VAR 0 7
102528: ARRAY
102529: PPUSH
102530: LD_VAR 0 14
102534: PUSH
102535: LD_VAR 0 8
102539: ARRAY
102540: PPUSH
102541: CALL_OW 115
// attacking := true ;
102545: LD_ADDR_VAR 0 29
102549: PUSH
102550: LD_INT 1
102552: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102553: LD_VAR 0 4
102557: PUSH
102558: LD_VAR 0 7
102562: ARRAY
102563: PPUSH
102564: LD_INT 71
102566: PPUSH
102567: CALL_OW 109
// continue ;
102571: GO 102486
// end ; end ;
102573: GO 102486
102575: POP
102576: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102577: LD_VAR 0 4
102581: PUSH
102582: LD_VAR 0 7
102586: ARRAY
102587: PPUSH
102588: CALL_OW 257
102592: PUSH
102593: LD_INT 8
102595: EQUAL
102596: PUSH
102597: LD_VAR 0 4
102601: PUSH
102602: LD_VAR 0 7
102606: ARRAY
102607: PPUSH
102608: CALL_OW 264
102612: PUSH
102613: LD_INT 28
102615: PUSH
102616: LD_INT 45
102618: PUSH
102619: LD_INT 7
102621: PUSH
102622: LD_INT 47
102624: PUSH
102625: EMPTY
102626: LIST
102627: LIST
102628: LIST
102629: LIST
102630: IN
102631: OR
102632: IFFALSE 102862
// begin attacking := false ;
102634: LD_ADDR_VAR 0 29
102638: PUSH
102639: LD_INT 0
102641: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102642: LD_VAR 0 14
102646: PUSH
102647: LD_INT 1
102649: ARRAY
102650: PPUSH
102651: CALL_OW 266
102655: PUSH
102656: LD_INT 32
102658: PUSH
102659: LD_INT 31
102661: PUSH
102662: LD_INT 33
102664: PUSH
102665: LD_INT 4
102667: PUSH
102668: LD_INT 5
102670: PUSH
102671: EMPTY
102672: LIST
102673: LIST
102674: LIST
102675: LIST
102676: LIST
102677: IN
102678: IFFALSE 102862
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102680: LD_ADDR_VAR 0 9
102684: PUSH
102685: LD_VAR 0 14
102689: PUSH
102690: LD_INT 1
102692: ARRAY
102693: PPUSH
102694: CALL_OW 266
102698: PPUSH
102699: LD_VAR 0 14
102703: PUSH
102704: LD_INT 1
102706: ARRAY
102707: PPUSH
102708: CALL_OW 250
102712: PPUSH
102713: LD_VAR 0 14
102717: PUSH
102718: LD_INT 1
102720: ARRAY
102721: PPUSH
102722: CALL_OW 251
102726: PPUSH
102727: LD_VAR 0 14
102731: PUSH
102732: LD_INT 1
102734: ARRAY
102735: PPUSH
102736: CALL_OW 254
102740: PPUSH
102741: LD_VAR 0 14
102745: PUSH
102746: LD_INT 1
102748: ARRAY
102749: PPUSH
102750: CALL_OW 248
102754: PPUSH
102755: LD_INT 0
102757: PPUSH
102758: CALL 79468 0 6
102762: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102763: LD_ADDR_VAR 0 8
102767: PUSH
102768: LD_VAR 0 4
102772: PUSH
102773: LD_VAR 0 7
102777: ARRAY
102778: PPUSH
102779: LD_VAR 0 9
102783: PPUSH
102784: CALL 98161 0 2
102788: ST_TO_ADDR
// if j then
102789: LD_VAR 0 8
102793: IFFALSE 102862
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102795: LD_VAR 0 8
102799: PUSH
102800: LD_INT 1
102802: ARRAY
102803: PPUSH
102804: LD_VAR 0 8
102808: PUSH
102809: LD_INT 2
102811: ARRAY
102812: PPUSH
102813: CALL_OW 488
102817: IFFALSE 102862
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102819: LD_VAR 0 4
102823: PUSH
102824: LD_VAR 0 7
102828: ARRAY
102829: PPUSH
102830: LD_VAR 0 8
102834: PUSH
102835: LD_INT 1
102837: ARRAY
102838: PPUSH
102839: LD_VAR 0 8
102843: PUSH
102844: LD_INT 2
102846: ARRAY
102847: PPUSH
102848: CALL_OW 116
// attacking := true ;
102852: LD_ADDR_VAR 0 29
102856: PUSH
102857: LD_INT 1
102859: ST_TO_ADDR
// continue ;
102860: GO 100235
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102862: LD_VAR 0 4
102866: PUSH
102867: LD_VAR 0 7
102871: ARRAY
102872: PPUSH
102873: CALL_OW 265
102877: PUSH
102878: LD_INT 11
102880: EQUAL
102881: IFFALSE 103159
// begin k := 10 ;
102883: LD_ADDR_VAR 0 9
102887: PUSH
102888: LD_INT 10
102890: ST_TO_ADDR
// x := 0 ;
102891: LD_ADDR_VAR 0 10
102895: PUSH
102896: LD_INT 0
102898: ST_TO_ADDR
// if tmp < k then
102899: LD_VAR 0 14
102903: PUSH
102904: LD_VAR 0 9
102908: LESS
102909: IFFALSE 102921
// k := tmp ;
102911: LD_ADDR_VAR 0 9
102915: PUSH
102916: LD_VAR 0 14
102920: ST_TO_ADDR
// for j = k downto 1 do
102921: LD_ADDR_VAR 0 8
102925: PUSH
102926: DOUBLE
102927: LD_VAR 0 9
102931: INC
102932: ST_TO_ADDR
102933: LD_INT 1
102935: PUSH
102936: FOR_DOWNTO
102937: IFFALSE 103012
// begin if GetType ( tmp [ j ] ) = unit_human then
102939: LD_VAR 0 14
102943: PUSH
102944: LD_VAR 0 8
102948: ARRAY
102949: PPUSH
102950: CALL_OW 247
102954: PUSH
102955: LD_INT 1
102957: EQUAL
102958: IFFALSE 103010
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102960: LD_VAR 0 4
102964: PUSH
102965: LD_VAR 0 7
102969: ARRAY
102970: PPUSH
102971: LD_VAR 0 14
102975: PUSH
102976: LD_VAR 0 8
102980: ARRAY
102981: PPUSH
102982: CALL 98432 0 2
// x := tmp [ j ] ;
102986: LD_ADDR_VAR 0 10
102990: PUSH
102991: LD_VAR 0 14
102995: PUSH
102996: LD_VAR 0 8
103000: ARRAY
103001: ST_TO_ADDR
// attacking := true ;
103002: LD_ADDR_VAR 0 29
103006: PUSH
103007: LD_INT 1
103009: ST_TO_ADDR
// end ; end ;
103010: GO 102936
103012: POP
103013: POP
// if not x then
103014: LD_VAR 0 10
103018: NOT
103019: IFFALSE 103159
// begin attacking := true ;
103021: LD_ADDR_VAR 0 29
103025: PUSH
103026: LD_INT 1
103028: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103029: LD_VAR 0 4
103033: PUSH
103034: LD_VAR 0 7
103038: ARRAY
103039: PPUSH
103040: CALL_OW 250
103044: PPUSH
103045: LD_VAR 0 4
103049: PUSH
103050: LD_VAR 0 7
103054: ARRAY
103055: PPUSH
103056: CALL_OW 251
103060: PPUSH
103061: CALL_OW 546
103065: PUSH
103066: LD_INT 2
103068: ARRAY
103069: PUSH
103070: LD_VAR 0 14
103074: PUSH
103075: LD_INT 1
103077: ARRAY
103078: PPUSH
103079: CALL_OW 250
103083: PPUSH
103084: LD_VAR 0 14
103088: PUSH
103089: LD_INT 1
103091: ARRAY
103092: PPUSH
103093: CALL_OW 251
103097: PPUSH
103098: CALL_OW 546
103102: PUSH
103103: LD_INT 2
103105: ARRAY
103106: EQUAL
103107: IFFALSE 103135
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103109: LD_VAR 0 4
103113: PUSH
103114: LD_VAR 0 7
103118: ARRAY
103119: PPUSH
103120: LD_VAR 0 14
103124: PUSH
103125: LD_INT 1
103127: ARRAY
103128: PPUSH
103129: CALL 98432 0 2
103133: GO 103159
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103135: LD_VAR 0 4
103139: PUSH
103140: LD_VAR 0 7
103144: ARRAY
103145: PPUSH
103146: LD_VAR 0 14
103150: PUSH
103151: LD_INT 1
103153: ARRAY
103154: PPUSH
103155: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103159: LD_VAR 0 4
103163: PUSH
103164: LD_VAR 0 7
103168: ARRAY
103169: PPUSH
103170: CALL_OW 264
103174: PUSH
103175: LD_INT 29
103177: EQUAL
103178: IFFALSE 103544
// begin if WantsToAttack ( group [ i ] ) in bombed then
103180: LD_VAR 0 4
103184: PUSH
103185: LD_VAR 0 7
103189: ARRAY
103190: PPUSH
103191: CALL_OW 319
103195: PUSH
103196: LD_VAR 0 28
103200: IN
103201: IFFALSE 103205
// continue ;
103203: GO 100235
// k := 8 ;
103205: LD_ADDR_VAR 0 9
103209: PUSH
103210: LD_INT 8
103212: ST_TO_ADDR
// x := 0 ;
103213: LD_ADDR_VAR 0 10
103217: PUSH
103218: LD_INT 0
103220: ST_TO_ADDR
// if tmp < k then
103221: LD_VAR 0 14
103225: PUSH
103226: LD_VAR 0 9
103230: LESS
103231: IFFALSE 103243
// k := tmp ;
103233: LD_ADDR_VAR 0 9
103237: PUSH
103238: LD_VAR 0 14
103242: ST_TO_ADDR
// for j = 1 to k do
103243: LD_ADDR_VAR 0 8
103247: PUSH
103248: DOUBLE
103249: LD_INT 1
103251: DEC
103252: ST_TO_ADDR
103253: LD_VAR 0 9
103257: PUSH
103258: FOR_TO
103259: IFFALSE 103391
// begin if GetType ( tmp [ j ] ) = unit_building then
103261: LD_VAR 0 14
103265: PUSH
103266: LD_VAR 0 8
103270: ARRAY
103271: PPUSH
103272: CALL_OW 247
103276: PUSH
103277: LD_INT 3
103279: EQUAL
103280: IFFALSE 103389
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103282: LD_VAR 0 14
103286: PUSH
103287: LD_VAR 0 8
103291: ARRAY
103292: PUSH
103293: LD_VAR 0 28
103297: IN
103298: NOT
103299: PUSH
103300: LD_VAR 0 14
103304: PUSH
103305: LD_VAR 0 8
103309: ARRAY
103310: PPUSH
103311: CALL_OW 313
103315: AND
103316: IFFALSE 103389
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103318: LD_VAR 0 4
103322: PUSH
103323: LD_VAR 0 7
103327: ARRAY
103328: PPUSH
103329: LD_VAR 0 14
103333: PUSH
103334: LD_VAR 0 8
103338: ARRAY
103339: PPUSH
103340: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103344: LD_ADDR_VAR 0 28
103348: PUSH
103349: LD_VAR 0 28
103353: PPUSH
103354: LD_VAR 0 28
103358: PUSH
103359: LD_INT 1
103361: PLUS
103362: PPUSH
103363: LD_VAR 0 14
103367: PUSH
103368: LD_VAR 0 8
103372: ARRAY
103373: PPUSH
103374: CALL_OW 1
103378: ST_TO_ADDR
// attacking := true ;
103379: LD_ADDR_VAR 0 29
103383: PUSH
103384: LD_INT 1
103386: ST_TO_ADDR
// break ;
103387: GO 103391
// end ; end ;
103389: GO 103258
103391: POP
103392: POP
// if not attacking and f_attack_depot then
103393: LD_VAR 0 29
103397: NOT
103398: PUSH
103399: LD_VAR 0 25
103403: AND
103404: IFFALSE 103499
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103406: LD_ADDR_VAR 0 13
103410: PUSH
103411: LD_VAR 0 14
103415: PPUSH
103416: LD_INT 2
103418: PUSH
103419: LD_INT 30
103421: PUSH
103422: LD_INT 0
103424: PUSH
103425: EMPTY
103426: LIST
103427: LIST
103428: PUSH
103429: LD_INT 30
103431: PUSH
103432: LD_INT 1
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: LIST
103443: PPUSH
103444: CALL_OW 72
103448: ST_TO_ADDR
// if z then
103449: LD_VAR 0 13
103453: IFFALSE 103499
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103455: LD_VAR 0 4
103459: PUSH
103460: LD_VAR 0 7
103464: ARRAY
103465: PPUSH
103466: LD_VAR 0 13
103470: PPUSH
103471: LD_VAR 0 4
103475: PUSH
103476: LD_VAR 0 7
103480: ARRAY
103481: PPUSH
103482: CALL_OW 74
103486: PPUSH
103487: CALL_OW 115
// attacking := true ;
103491: LD_ADDR_VAR 0 29
103495: PUSH
103496: LD_INT 1
103498: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103499: LD_VAR 0 4
103503: PUSH
103504: LD_VAR 0 7
103508: ARRAY
103509: PPUSH
103510: CALL_OW 256
103514: PUSH
103515: LD_INT 500
103517: LESS
103518: IFFALSE 103544
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103520: LD_VAR 0 4
103524: PUSH
103525: LD_VAR 0 7
103529: ARRAY
103530: PPUSH
103531: LD_VAR 0 14
103535: PUSH
103536: LD_INT 1
103538: ARRAY
103539: PPUSH
103540: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103544: LD_VAR 0 4
103548: PUSH
103549: LD_VAR 0 7
103553: ARRAY
103554: PPUSH
103555: CALL_OW 264
103559: PUSH
103560: LD_INT 49
103562: EQUAL
103563: IFFALSE 103684
// begin if not HasTask ( group [ i ] ) then
103565: LD_VAR 0 4
103569: PUSH
103570: LD_VAR 0 7
103574: ARRAY
103575: PPUSH
103576: CALL_OW 314
103580: NOT
103581: IFFALSE 103684
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103583: LD_ADDR_VAR 0 9
103587: PUSH
103588: LD_INT 81
103590: PUSH
103591: LD_VAR 0 4
103595: PUSH
103596: LD_VAR 0 7
103600: ARRAY
103601: PPUSH
103602: CALL_OW 255
103606: PUSH
103607: EMPTY
103608: LIST
103609: LIST
103610: PPUSH
103611: CALL_OW 69
103615: PPUSH
103616: LD_VAR 0 4
103620: PUSH
103621: LD_VAR 0 7
103625: ARRAY
103626: PPUSH
103627: CALL_OW 74
103631: ST_TO_ADDR
// if k then
103632: LD_VAR 0 9
103636: IFFALSE 103684
// if GetDistUnits ( group [ i ] , k ) > 10 then
103638: LD_VAR 0 4
103642: PUSH
103643: LD_VAR 0 7
103647: ARRAY
103648: PPUSH
103649: LD_VAR 0 9
103653: PPUSH
103654: CALL_OW 296
103658: PUSH
103659: LD_INT 10
103661: GREATER
103662: IFFALSE 103684
// ComMoveUnit ( group [ i ] , k ) ;
103664: LD_VAR 0 4
103668: PUSH
103669: LD_VAR 0 7
103673: ARRAY
103674: PPUSH
103675: LD_VAR 0 9
103679: PPUSH
103680: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103684: LD_VAR 0 4
103688: PUSH
103689: LD_VAR 0 7
103693: ARRAY
103694: PPUSH
103695: CALL_OW 256
103699: PUSH
103700: LD_INT 250
103702: LESS
103703: PUSH
103704: LD_VAR 0 4
103708: PUSH
103709: LD_VAR 0 7
103713: ARRAY
103714: PUSH
103715: LD_INT 21
103717: PUSH
103718: LD_INT 2
103720: PUSH
103721: EMPTY
103722: LIST
103723: LIST
103724: PUSH
103725: LD_INT 23
103727: PUSH
103728: LD_INT 2
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: PUSH
103735: EMPTY
103736: LIST
103737: LIST
103738: PPUSH
103739: CALL_OW 69
103743: IN
103744: AND
103745: IFFALSE 103870
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103747: LD_ADDR_VAR 0 9
103751: PUSH
103752: LD_OWVAR 3
103756: PUSH
103757: LD_VAR 0 4
103761: PUSH
103762: LD_VAR 0 7
103766: ARRAY
103767: DIFF
103768: PPUSH
103769: LD_VAR 0 4
103773: PUSH
103774: LD_VAR 0 7
103778: ARRAY
103779: PPUSH
103780: CALL_OW 74
103784: ST_TO_ADDR
// if not k then
103785: LD_VAR 0 9
103789: NOT
103790: IFFALSE 103794
// continue ;
103792: GO 100235
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103794: LD_VAR 0 9
103798: PUSH
103799: LD_INT 81
103801: PUSH
103802: LD_VAR 0 4
103806: PUSH
103807: LD_VAR 0 7
103811: ARRAY
103812: PPUSH
103813: CALL_OW 255
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PPUSH
103822: CALL_OW 69
103826: IN
103827: PUSH
103828: LD_VAR 0 9
103832: PPUSH
103833: LD_VAR 0 4
103837: PUSH
103838: LD_VAR 0 7
103842: ARRAY
103843: PPUSH
103844: CALL_OW 296
103848: PUSH
103849: LD_INT 5
103851: LESS
103852: AND
103853: IFFALSE 103870
// ComAutodestruct ( group [ i ] ) ;
103855: LD_VAR 0 4
103859: PUSH
103860: LD_VAR 0 7
103864: ARRAY
103865: PPUSH
103866: CALL 98330 0 1
// end ; if f_attack_depot then
103870: LD_VAR 0 25
103874: IFFALSE 103986
// begin k := 6 ;
103876: LD_ADDR_VAR 0 9
103880: PUSH
103881: LD_INT 6
103883: ST_TO_ADDR
// if tmp < k then
103884: LD_VAR 0 14
103888: PUSH
103889: LD_VAR 0 9
103893: LESS
103894: IFFALSE 103906
// k := tmp ;
103896: LD_ADDR_VAR 0 9
103900: PUSH
103901: LD_VAR 0 14
103905: ST_TO_ADDR
// for j = 1 to k do
103906: LD_ADDR_VAR 0 8
103910: PUSH
103911: DOUBLE
103912: LD_INT 1
103914: DEC
103915: ST_TO_ADDR
103916: LD_VAR 0 9
103920: PUSH
103921: FOR_TO
103922: IFFALSE 103984
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103924: LD_VAR 0 8
103928: PPUSH
103929: CALL_OW 266
103933: PUSH
103934: LD_INT 0
103936: PUSH
103937: LD_INT 1
103939: PUSH
103940: EMPTY
103941: LIST
103942: LIST
103943: IN
103944: IFFALSE 103982
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103946: LD_VAR 0 4
103950: PUSH
103951: LD_VAR 0 7
103955: ARRAY
103956: PPUSH
103957: LD_VAR 0 14
103961: PUSH
103962: LD_VAR 0 8
103966: ARRAY
103967: PPUSH
103968: CALL_OW 115
// attacking := true ;
103972: LD_ADDR_VAR 0 29
103976: PUSH
103977: LD_INT 1
103979: ST_TO_ADDR
// break ;
103980: GO 103984
// end ;
103982: GO 103921
103984: POP
103985: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103986: LD_VAR 0 4
103990: PUSH
103991: LD_VAR 0 7
103995: ARRAY
103996: PPUSH
103997: CALL_OW 302
104001: PUSH
104002: LD_VAR 0 29
104006: NOT
104007: AND
104008: IFFALSE 104330
// begin if GetTag ( group [ i ] ) = 71 then
104010: LD_VAR 0 4
104014: PUSH
104015: LD_VAR 0 7
104019: ARRAY
104020: PPUSH
104021: CALL_OW 110
104025: PUSH
104026: LD_INT 71
104028: EQUAL
104029: IFFALSE 104070
// begin if HasTask ( group [ i ] ) then
104031: LD_VAR 0 4
104035: PUSH
104036: LD_VAR 0 7
104040: ARRAY
104041: PPUSH
104042: CALL_OW 314
104046: IFFALSE 104052
// continue else
104048: GO 100235
104050: GO 104070
// SetTag ( group [ i ] , 0 ) ;
104052: LD_VAR 0 4
104056: PUSH
104057: LD_VAR 0 7
104061: ARRAY
104062: PPUSH
104063: LD_INT 0
104065: PPUSH
104066: CALL_OW 109
// end ; k := 8 ;
104070: LD_ADDR_VAR 0 9
104074: PUSH
104075: LD_INT 8
104077: ST_TO_ADDR
// x := 0 ;
104078: LD_ADDR_VAR 0 10
104082: PUSH
104083: LD_INT 0
104085: ST_TO_ADDR
// if tmp < k then
104086: LD_VAR 0 14
104090: PUSH
104091: LD_VAR 0 9
104095: LESS
104096: IFFALSE 104108
// k := tmp ;
104098: LD_ADDR_VAR 0 9
104102: PUSH
104103: LD_VAR 0 14
104107: ST_TO_ADDR
// for j = 1 to k do
104108: LD_ADDR_VAR 0 8
104112: PUSH
104113: DOUBLE
104114: LD_INT 1
104116: DEC
104117: ST_TO_ADDR
104118: LD_VAR 0 9
104122: PUSH
104123: FOR_TO
104124: IFFALSE 104222
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104126: LD_VAR 0 14
104130: PUSH
104131: LD_VAR 0 8
104135: ARRAY
104136: PPUSH
104137: CALL_OW 247
104141: PUSH
104142: LD_INT 1
104144: EQUAL
104145: PUSH
104146: LD_VAR 0 14
104150: PUSH
104151: LD_VAR 0 8
104155: ARRAY
104156: PPUSH
104157: CALL_OW 256
104161: PUSH
104162: LD_INT 250
104164: LESS
104165: PUSH
104166: LD_VAR 0 20
104170: AND
104171: PUSH
104172: LD_VAR 0 20
104176: NOT
104177: PUSH
104178: LD_VAR 0 14
104182: PUSH
104183: LD_VAR 0 8
104187: ARRAY
104188: PPUSH
104189: CALL_OW 256
104193: PUSH
104194: LD_INT 250
104196: GREATEREQUAL
104197: AND
104198: OR
104199: AND
104200: IFFALSE 104220
// begin x := tmp [ j ] ;
104202: LD_ADDR_VAR 0 10
104206: PUSH
104207: LD_VAR 0 14
104211: PUSH
104212: LD_VAR 0 8
104216: ARRAY
104217: ST_TO_ADDR
// break ;
104218: GO 104222
// end ;
104220: GO 104123
104222: POP
104223: POP
// if x then
104224: LD_VAR 0 10
104228: IFFALSE 104252
// ComAttackUnit ( group [ i ] , x ) else
104230: LD_VAR 0 4
104234: PUSH
104235: LD_VAR 0 7
104239: ARRAY
104240: PPUSH
104241: LD_VAR 0 10
104245: PPUSH
104246: CALL_OW 115
104250: GO 104276
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104252: LD_VAR 0 4
104256: PUSH
104257: LD_VAR 0 7
104261: ARRAY
104262: PPUSH
104263: LD_VAR 0 14
104267: PUSH
104268: LD_INT 1
104270: ARRAY
104271: PPUSH
104272: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104276: LD_VAR 0 4
104280: PUSH
104281: LD_VAR 0 7
104285: ARRAY
104286: PPUSH
104287: CALL_OW 314
104291: NOT
104292: IFFALSE 104330
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104294: LD_VAR 0 4
104298: PUSH
104299: LD_VAR 0 7
104303: ARRAY
104304: PPUSH
104305: LD_VAR 0 14
104309: PPUSH
104310: LD_VAR 0 4
104314: PUSH
104315: LD_VAR 0 7
104319: ARRAY
104320: PPUSH
104321: CALL_OW 74
104325: PPUSH
104326: CALL_OW 115
// end ; end ; end ;
104330: GO 100235
104332: POP
104333: POP
// wait ( 0 0$1 ) ;
104334: LD_INT 35
104336: PPUSH
104337: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104341: LD_VAR 0 4
104345: PUSH
104346: EMPTY
104347: EQUAL
104348: PUSH
104349: LD_INT 81
104351: PUSH
104352: LD_VAR 0 35
104356: PUSH
104357: EMPTY
104358: LIST
104359: LIST
104360: PPUSH
104361: CALL_OW 69
104365: NOT
104366: OR
104367: IFFALSE 100220
// end ;
104369: LD_VAR 0 2
104373: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104374: LD_INT 0
104376: PPUSH
104377: PPUSH
104378: PPUSH
104379: PPUSH
// if not base_units then
104380: LD_VAR 0 1
104384: NOT
104385: IFFALSE 104389
// exit ;
104387: GO 104476
// result := false ;
104389: LD_ADDR_VAR 0 2
104393: PUSH
104394: LD_INT 0
104396: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104397: LD_ADDR_VAR 0 5
104401: PUSH
104402: LD_VAR 0 1
104406: PPUSH
104407: LD_INT 21
104409: PUSH
104410: LD_INT 3
104412: PUSH
104413: EMPTY
104414: LIST
104415: LIST
104416: PPUSH
104417: CALL_OW 72
104421: ST_TO_ADDR
// if not tmp then
104422: LD_VAR 0 5
104426: NOT
104427: IFFALSE 104431
// exit ;
104429: GO 104476
// for i in tmp do
104431: LD_ADDR_VAR 0 3
104435: PUSH
104436: LD_VAR 0 5
104440: PUSH
104441: FOR_IN
104442: IFFALSE 104474
// begin result := EnemyInRange ( i , 22 ) ;
104444: LD_ADDR_VAR 0 2
104448: PUSH
104449: LD_VAR 0 3
104453: PPUSH
104454: LD_INT 22
104456: PPUSH
104457: CALL 98013 0 2
104461: ST_TO_ADDR
// if result then
104462: LD_VAR 0 2
104466: IFFALSE 104472
// exit ;
104468: POP
104469: POP
104470: GO 104476
// end ;
104472: GO 104441
104474: POP
104475: POP
// end ;
104476: LD_VAR 0 2
104480: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104481: LD_INT 0
104483: PPUSH
104484: PPUSH
// if not units then
104485: LD_VAR 0 1
104489: NOT
104490: IFFALSE 104494
// exit ;
104492: GO 104564
// result := [ ] ;
104494: LD_ADDR_VAR 0 3
104498: PUSH
104499: EMPTY
104500: ST_TO_ADDR
// for i in units do
104501: LD_ADDR_VAR 0 4
104505: PUSH
104506: LD_VAR 0 1
104510: PUSH
104511: FOR_IN
104512: IFFALSE 104562
// if GetTag ( i ) = tag then
104514: LD_VAR 0 4
104518: PPUSH
104519: CALL_OW 110
104523: PUSH
104524: LD_VAR 0 2
104528: EQUAL
104529: IFFALSE 104560
// result := Insert ( result , result + 1 , i ) ;
104531: LD_ADDR_VAR 0 3
104535: PUSH
104536: LD_VAR 0 3
104540: PPUSH
104541: LD_VAR 0 3
104545: PUSH
104546: LD_INT 1
104548: PLUS
104549: PPUSH
104550: LD_VAR 0 4
104554: PPUSH
104555: CALL_OW 2
104559: ST_TO_ADDR
104560: GO 104511
104562: POP
104563: POP
// end ;
104564: LD_VAR 0 3
104568: RET
// export function IsDriver ( un ) ; begin
104569: LD_INT 0
104571: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104572: LD_ADDR_VAR 0 2
104576: PUSH
104577: LD_VAR 0 1
104581: PUSH
104582: LD_INT 55
104584: PUSH
104585: EMPTY
104586: LIST
104587: PPUSH
104588: CALL_OW 69
104592: IN
104593: ST_TO_ADDR
// end ;
104594: LD_VAR 0 2
104598: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104599: LD_INT 0
104601: PPUSH
104602: PPUSH
// list := [ ] ;
104603: LD_ADDR_VAR 0 5
104607: PUSH
104608: EMPTY
104609: ST_TO_ADDR
// case d of 0 :
104610: LD_VAR 0 3
104614: PUSH
104615: LD_INT 0
104617: DOUBLE
104618: EQUAL
104619: IFTRUE 104623
104621: GO 104756
104623: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104624: LD_ADDR_VAR 0 5
104628: PUSH
104629: LD_VAR 0 1
104633: PUSH
104634: LD_INT 4
104636: MINUS
104637: PUSH
104638: LD_VAR 0 2
104642: PUSH
104643: LD_INT 4
104645: MINUS
104646: PUSH
104647: LD_INT 2
104649: PUSH
104650: EMPTY
104651: LIST
104652: LIST
104653: LIST
104654: PUSH
104655: LD_VAR 0 1
104659: PUSH
104660: LD_INT 3
104662: MINUS
104663: PUSH
104664: LD_VAR 0 2
104668: PUSH
104669: LD_INT 1
104671: PUSH
104672: EMPTY
104673: LIST
104674: LIST
104675: LIST
104676: PUSH
104677: LD_VAR 0 1
104681: PUSH
104682: LD_INT 4
104684: PLUS
104685: PUSH
104686: LD_VAR 0 2
104690: PUSH
104691: LD_INT 4
104693: PUSH
104694: EMPTY
104695: LIST
104696: LIST
104697: LIST
104698: PUSH
104699: LD_VAR 0 1
104703: PUSH
104704: LD_INT 3
104706: PLUS
104707: PUSH
104708: LD_VAR 0 2
104712: PUSH
104713: LD_INT 3
104715: PLUS
104716: PUSH
104717: LD_INT 5
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: LIST
104724: PUSH
104725: LD_VAR 0 1
104729: PUSH
104730: LD_VAR 0 2
104734: PUSH
104735: LD_INT 4
104737: PLUS
104738: PUSH
104739: LD_INT 0
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: LIST
104746: PUSH
104747: EMPTY
104748: LIST
104749: LIST
104750: LIST
104751: LIST
104752: LIST
104753: ST_TO_ADDR
// end ; 1 :
104754: GO 105454
104756: LD_INT 1
104758: DOUBLE
104759: EQUAL
104760: IFTRUE 104764
104762: GO 104897
104764: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104765: LD_ADDR_VAR 0 5
104769: PUSH
104770: LD_VAR 0 1
104774: PUSH
104775: LD_VAR 0 2
104779: PUSH
104780: LD_INT 4
104782: MINUS
104783: PUSH
104784: LD_INT 3
104786: PUSH
104787: EMPTY
104788: LIST
104789: LIST
104790: LIST
104791: PUSH
104792: LD_VAR 0 1
104796: PUSH
104797: LD_INT 3
104799: MINUS
104800: PUSH
104801: LD_VAR 0 2
104805: PUSH
104806: LD_INT 3
104808: MINUS
104809: PUSH
104810: LD_INT 2
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: LIST
104817: PUSH
104818: LD_VAR 0 1
104822: PUSH
104823: LD_INT 4
104825: MINUS
104826: PUSH
104827: LD_VAR 0 2
104831: PUSH
104832: LD_INT 1
104834: PUSH
104835: EMPTY
104836: LIST
104837: LIST
104838: LIST
104839: PUSH
104840: LD_VAR 0 1
104844: PUSH
104845: LD_VAR 0 2
104849: PUSH
104850: LD_INT 3
104852: PLUS
104853: PUSH
104854: LD_INT 0
104856: PUSH
104857: EMPTY
104858: LIST
104859: LIST
104860: LIST
104861: PUSH
104862: LD_VAR 0 1
104866: PUSH
104867: LD_INT 4
104869: PLUS
104870: PUSH
104871: LD_VAR 0 2
104875: PUSH
104876: LD_INT 4
104878: PLUS
104879: PUSH
104880: LD_INT 5
104882: PUSH
104883: EMPTY
104884: LIST
104885: LIST
104886: LIST
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: LIST
104892: LIST
104893: LIST
104894: ST_TO_ADDR
// end ; 2 :
104895: GO 105454
104897: LD_INT 2
104899: DOUBLE
104900: EQUAL
104901: IFTRUE 104905
104903: GO 105034
104905: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104906: LD_ADDR_VAR 0 5
104910: PUSH
104911: LD_VAR 0 1
104915: PUSH
104916: LD_VAR 0 2
104920: PUSH
104921: LD_INT 3
104923: MINUS
104924: PUSH
104925: LD_INT 3
104927: PUSH
104928: EMPTY
104929: LIST
104930: LIST
104931: LIST
104932: PUSH
104933: LD_VAR 0 1
104937: PUSH
104938: LD_INT 4
104940: PLUS
104941: PUSH
104942: LD_VAR 0 2
104946: PUSH
104947: LD_INT 4
104949: PUSH
104950: EMPTY
104951: LIST
104952: LIST
104953: LIST
104954: PUSH
104955: LD_VAR 0 1
104959: PUSH
104960: LD_VAR 0 2
104964: PUSH
104965: LD_INT 4
104967: PLUS
104968: PUSH
104969: LD_INT 0
104971: PUSH
104972: EMPTY
104973: LIST
104974: LIST
104975: LIST
104976: PUSH
104977: LD_VAR 0 1
104981: PUSH
104982: LD_INT 3
104984: MINUS
104985: PUSH
104986: LD_VAR 0 2
104990: PUSH
104991: LD_INT 1
104993: PUSH
104994: EMPTY
104995: LIST
104996: LIST
104997: LIST
104998: PUSH
104999: LD_VAR 0 1
105003: PUSH
105004: LD_INT 4
105006: MINUS
105007: PUSH
105008: LD_VAR 0 2
105012: PUSH
105013: LD_INT 4
105015: MINUS
105016: PUSH
105017: LD_INT 2
105019: PUSH
105020: EMPTY
105021: LIST
105022: LIST
105023: LIST
105024: PUSH
105025: EMPTY
105026: LIST
105027: LIST
105028: LIST
105029: LIST
105030: LIST
105031: ST_TO_ADDR
// end ; 3 :
105032: GO 105454
105034: LD_INT 3
105036: DOUBLE
105037: EQUAL
105038: IFTRUE 105042
105040: GO 105175
105042: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105043: LD_ADDR_VAR 0 5
105047: PUSH
105048: LD_VAR 0 1
105052: PUSH
105053: LD_INT 3
105055: PLUS
105056: PUSH
105057: LD_VAR 0 2
105061: PUSH
105062: LD_INT 4
105064: PUSH
105065: EMPTY
105066: LIST
105067: LIST
105068: LIST
105069: PUSH
105070: LD_VAR 0 1
105074: PUSH
105075: LD_INT 4
105077: PLUS
105078: PUSH
105079: LD_VAR 0 2
105083: PUSH
105084: LD_INT 4
105086: PLUS
105087: PUSH
105088: LD_INT 5
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: LIST
105095: PUSH
105096: LD_VAR 0 1
105100: PUSH
105101: LD_INT 4
105103: MINUS
105104: PUSH
105105: LD_VAR 0 2
105109: PUSH
105110: LD_INT 1
105112: PUSH
105113: EMPTY
105114: LIST
105115: LIST
105116: LIST
105117: PUSH
105118: LD_VAR 0 1
105122: PUSH
105123: LD_VAR 0 2
105127: PUSH
105128: LD_INT 4
105130: MINUS
105131: PUSH
105132: LD_INT 3
105134: PUSH
105135: EMPTY
105136: LIST
105137: LIST
105138: LIST
105139: PUSH
105140: LD_VAR 0 1
105144: PUSH
105145: LD_INT 3
105147: MINUS
105148: PUSH
105149: LD_VAR 0 2
105153: PUSH
105154: LD_INT 3
105156: MINUS
105157: PUSH
105158: LD_INT 2
105160: PUSH
105161: EMPTY
105162: LIST
105163: LIST
105164: LIST
105165: PUSH
105166: EMPTY
105167: LIST
105168: LIST
105169: LIST
105170: LIST
105171: LIST
105172: ST_TO_ADDR
// end ; 4 :
105173: GO 105454
105175: LD_INT 4
105177: DOUBLE
105178: EQUAL
105179: IFTRUE 105183
105181: GO 105316
105183: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105184: LD_ADDR_VAR 0 5
105188: PUSH
105189: LD_VAR 0 1
105193: PUSH
105194: LD_VAR 0 2
105198: PUSH
105199: LD_INT 4
105201: PLUS
105202: PUSH
105203: LD_INT 0
105205: PUSH
105206: EMPTY
105207: LIST
105208: LIST
105209: LIST
105210: PUSH
105211: LD_VAR 0 1
105215: PUSH
105216: LD_INT 3
105218: PLUS
105219: PUSH
105220: LD_VAR 0 2
105224: PUSH
105225: LD_INT 3
105227: PLUS
105228: PUSH
105229: LD_INT 5
105231: PUSH
105232: EMPTY
105233: LIST
105234: LIST
105235: LIST
105236: PUSH
105237: LD_VAR 0 1
105241: PUSH
105242: LD_INT 4
105244: PLUS
105245: PUSH
105246: LD_VAR 0 2
105250: PUSH
105251: LD_INT 4
105253: PUSH
105254: EMPTY
105255: LIST
105256: LIST
105257: LIST
105258: PUSH
105259: LD_VAR 0 1
105263: PUSH
105264: LD_VAR 0 2
105268: PUSH
105269: LD_INT 3
105271: MINUS
105272: PUSH
105273: LD_INT 3
105275: PUSH
105276: EMPTY
105277: LIST
105278: LIST
105279: LIST
105280: PUSH
105281: LD_VAR 0 1
105285: PUSH
105286: LD_INT 4
105288: MINUS
105289: PUSH
105290: LD_VAR 0 2
105294: PUSH
105295: LD_INT 4
105297: MINUS
105298: PUSH
105299: LD_INT 2
105301: PUSH
105302: EMPTY
105303: LIST
105304: LIST
105305: LIST
105306: PUSH
105307: EMPTY
105308: LIST
105309: LIST
105310: LIST
105311: LIST
105312: LIST
105313: ST_TO_ADDR
// end ; 5 :
105314: GO 105454
105316: LD_INT 5
105318: DOUBLE
105319: EQUAL
105320: IFTRUE 105324
105322: GO 105453
105324: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105325: LD_ADDR_VAR 0 5
105329: PUSH
105330: LD_VAR 0 1
105334: PUSH
105335: LD_INT 4
105337: MINUS
105338: PUSH
105339: LD_VAR 0 2
105343: PUSH
105344: LD_INT 1
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: LIST
105351: PUSH
105352: LD_VAR 0 1
105356: PUSH
105357: LD_VAR 0 2
105361: PUSH
105362: LD_INT 4
105364: MINUS
105365: PUSH
105366: LD_INT 3
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: LIST
105373: PUSH
105374: LD_VAR 0 1
105378: PUSH
105379: LD_INT 4
105381: PLUS
105382: PUSH
105383: LD_VAR 0 2
105387: PUSH
105388: LD_INT 4
105390: PLUS
105391: PUSH
105392: LD_INT 5
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: LIST
105399: PUSH
105400: LD_VAR 0 1
105404: PUSH
105405: LD_INT 3
105407: PLUS
105408: PUSH
105409: LD_VAR 0 2
105413: PUSH
105414: LD_INT 4
105416: PUSH
105417: EMPTY
105418: LIST
105419: LIST
105420: LIST
105421: PUSH
105422: LD_VAR 0 1
105426: PUSH
105427: LD_VAR 0 2
105431: PUSH
105432: LD_INT 3
105434: PLUS
105435: PUSH
105436: LD_INT 0
105438: PUSH
105439: EMPTY
105440: LIST
105441: LIST
105442: LIST
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: LIST
105448: LIST
105449: LIST
105450: ST_TO_ADDR
// end ; end ;
105451: GO 105454
105453: POP
// result := list ;
105454: LD_ADDR_VAR 0 4
105458: PUSH
105459: LD_VAR 0 5
105463: ST_TO_ADDR
// end ;
105464: LD_VAR 0 4
105468: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105469: LD_INT 0
105471: PPUSH
105472: PPUSH
105473: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105474: LD_VAR 0 1
105478: NOT
105479: PUSH
105480: LD_VAR 0 2
105484: PUSH
105485: LD_INT 1
105487: PUSH
105488: LD_INT 2
105490: PUSH
105491: LD_INT 3
105493: PUSH
105494: LD_INT 4
105496: PUSH
105497: EMPTY
105498: LIST
105499: LIST
105500: LIST
105501: LIST
105502: IN
105503: NOT
105504: OR
105505: IFFALSE 105509
// exit ;
105507: GO 105601
// tmp := [ ] ;
105509: LD_ADDR_VAR 0 5
105513: PUSH
105514: EMPTY
105515: ST_TO_ADDR
// for i in units do
105516: LD_ADDR_VAR 0 4
105520: PUSH
105521: LD_VAR 0 1
105525: PUSH
105526: FOR_IN
105527: IFFALSE 105570
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105529: LD_ADDR_VAR 0 5
105533: PUSH
105534: LD_VAR 0 5
105538: PPUSH
105539: LD_VAR 0 5
105543: PUSH
105544: LD_INT 1
105546: PLUS
105547: PPUSH
105548: LD_VAR 0 4
105552: PPUSH
105553: LD_VAR 0 2
105557: PPUSH
105558: CALL_OW 259
105562: PPUSH
105563: CALL_OW 2
105567: ST_TO_ADDR
105568: GO 105526
105570: POP
105571: POP
// if not tmp then
105572: LD_VAR 0 5
105576: NOT
105577: IFFALSE 105581
// exit ;
105579: GO 105601
// result := SortListByListDesc ( units , tmp ) ;
105581: LD_ADDR_VAR 0 3
105585: PUSH
105586: LD_VAR 0 1
105590: PPUSH
105591: LD_VAR 0 5
105595: PPUSH
105596: CALL_OW 77
105600: ST_TO_ADDR
// end ;
105601: LD_VAR 0 3
105605: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105606: LD_INT 0
105608: PPUSH
105609: PPUSH
105610: PPUSH
// x := GetX ( building ) ;
105611: LD_ADDR_VAR 0 4
105615: PUSH
105616: LD_VAR 0 2
105620: PPUSH
105621: CALL_OW 250
105625: ST_TO_ADDR
// y := GetY ( building ) ;
105626: LD_ADDR_VAR 0 5
105630: PUSH
105631: LD_VAR 0 2
105635: PPUSH
105636: CALL_OW 251
105640: ST_TO_ADDR
// if GetTaskList ( unit ) then
105641: LD_VAR 0 1
105645: PPUSH
105646: CALL_OW 437
105650: IFFALSE 105745
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105652: LD_STRING e
105654: PUSH
105655: LD_VAR 0 1
105659: PPUSH
105660: CALL_OW 437
105664: PUSH
105665: LD_INT 1
105667: ARRAY
105668: PUSH
105669: LD_INT 1
105671: ARRAY
105672: EQUAL
105673: PUSH
105674: LD_VAR 0 4
105678: PUSH
105679: LD_VAR 0 1
105683: PPUSH
105684: CALL_OW 437
105688: PUSH
105689: LD_INT 1
105691: ARRAY
105692: PUSH
105693: LD_INT 2
105695: ARRAY
105696: EQUAL
105697: AND
105698: PUSH
105699: LD_VAR 0 5
105703: PUSH
105704: LD_VAR 0 1
105708: PPUSH
105709: CALL_OW 437
105713: PUSH
105714: LD_INT 1
105716: ARRAY
105717: PUSH
105718: LD_INT 3
105720: ARRAY
105721: EQUAL
105722: AND
105723: IFFALSE 105735
// result := true else
105725: LD_ADDR_VAR 0 3
105729: PUSH
105730: LD_INT 1
105732: ST_TO_ADDR
105733: GO 105743
// result := false ;
105735: LD_ADDR_VAR 0 3
105739: PUSH
105740: LD_INT 0
105742: ST_TO_ADDR
// end else
105743: GO 105753
// result := false ;
105745: LD_ADDR_VAR 0 3
105749: PUSH
105750: LD_INT 0
105752: ST_TO_ADDR
// end ;
105753: LD_VAR 0 3
105757: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105758: LD_INT 0
105760: PPUSH
105761: PPUSH
105762: PPUSH
105763: PPUSH
// if not unit or not area then
105764: LD_VAR 0 1
105768: NOT
105769: PUSH
105770: LD_VAR 0 2
105774: NOT
105775: OR
105776: IFFALSE 105780
// exit ;
105778: GO 105944
// tmp := AreaToList ( area , i ) ;
105780: LD_ADDR_VAR 0 6
105784: PUSH
105785: LD_VAR 0 2
105789: PPUSH
105790: LD_VAR 0 5
105794: PPUSH
105795: CALL_OW 517
105799: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105800: LD_ADDR_VAR 0 5
105804: PUSH
105805: DOUBLE
105806: LD_INT 1
105808: DEC
105809: ST_TO_ADDR
105810: LD_VAR 0 6
105814: PUSH
105815: LD_INT 1
105817: ARRAY
105818: PUSH
105819: FOR_TO
105820: IFFALSE 105942
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105822: LD_ADDR_VAR 0 7
105826: PUSH
105827: LD_VAR 0 6
105831: PUSH
105832: LD_INT 1
105834: ARRAY
105835: PUSH
105836: LD_VAR 0 5
105840: ARRAY
105841: PUSH
105842: LD_VAR 0 6
105846: PUSH
105847: LD_INT 2
105849: ARRAY
105850: PUSH
105851: LD_VAR 0 5
105855: ARRAY
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105861: LD_VAR 0 7
105865: PUSH
105866: LD_INT 1
105868: ARRAY
105869: PPUSH
105870: LD_VAR 0 7
105874: PUSH
105875: LD_INT 2
105877: ARRAY
105878: PPUSH
105879: CALL_OW 428
105883: PUSH
105884: LD_INT 0
105886: EQUAL
105887: IFFALSE 105940
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105889: LD_VAR 0 1
105893: PPUSH
105894: LD_VAR 0 7
105898: PUSH
105899: LD_INT 1
105901: ARRAY
105902: PPUSH
105903: LD_VAR 0 7
105907: PUSH
105908: LD_INT 2
105910: ARRAY
105911: PPUSH
105912: LD_VAR 0 3
105916: PPUSH
105917: CALL_OW 48
// result := IsPlaced ( unit ) ;
105921: LD_ADDR_VAR 0 4
105925: PUSH
105926: LD_VAR 0 1
105930: PPUSH
105931: CALL_OW 305
105935: ST_TO_ADDR
// exit ;
105936: POP
105937: POP
105938: GO 105944
// end ; end ;
105940: GO 105819
105942: POP
105943: POP
// end ;
105944: LD_VAR 0 4
105948: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105949: LD_INT 0
105951: PPUSH
105952: PPUSH
105953: PPUSH
// if not side or side > 8 then
105954: LD_VAR 0 1
105958: NOT
105959: PUSH
105960: LD_VAR 0 1
105964: PUSH
105965: LD_INT 8
105967: GREATER
105968: OR
105969: IFFALSE 105973
// exit ;
105971: GO 106160
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105973: LD_ADDR_VAR 0 4
105977: PUSH
105978: LD_INT 22
105980: PUSH
105981: LD_VAR 0 1
105985: PUSH
105986: EMPTY
105987: LIST
105988: LIST
105989: PUSH
105990: LD_INT 21
105992: PUSH
105993: LD_INT 3
105995: PUSH
105996: EMPTY
105997: LIST
105998: LIST
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: PPUSH
106004: CALL_OW 69
106008: ST_TO_ADDR
// if not tmp then
106009: LD_VAR 0 4
106013: NOT
106014: IFFALSE 106018
// exit ;
106016: GO 106160
// enable_addtolog := true ;
106018: LD_ADDR_OWVAR 81
106022: PUSH
106023: LD_INT 1
106025: ST_TO_ADDR
// AddToLog ( [ ) ;
106026: LD_STRING [
106028: PPUSH
106029: CALL_OW 561
// for i in tmp do
106033: LD_ADDR_VAR 0 3
106037: PUSH
106038: LD_VAR 0 4
106042: PUSH
106043: FOR_IN
106044: IFFALSE 106151
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106046: LD_STRING [
106048: PUSH
106049: LD_VAR 0 3
106053: PPUSH
106054: CALL_OW 266
106058: STR
106059: PUSH
106060: LD_STRING , 
106062: STR
106063: PUSH
106064: LD_VAR 0 3
106068: PPUSH
106069: CALL_OW 250
106073: STR
106074: PUSH
106075: LD_STRING , 
106077: STR
106078: PUSH
106079: LD_VAR 0 3
106083: PPUSH
106084: CALL_OW 251
106088: STR
106089: PUSH
106090: LD_STRING , 
106092: STR
106093: PUSH
106094: LD_VAR 0 3
106098: PPUSH
106099: CALL_OW 254
106103: STR
106104: PUSH
106105: LD_STRING , 
106107: STR
106108: PUSH
106109: LD_VAR 0 3
106113: PPUSH
106114: LD_INT 1
106116: PPUSH
106117: CALL_OW 268
106121: STR
106122: PUSH
106123: LD_STRING , 
106125: STR
106126: PUSH
106127: LD_VAR 0 3
106131: PPUSH
106132: LD_INT 2
106134: PPUSH
106135: CALL_OW 268
106139: STR
106140: PUSH
106141: LD_STRING ],
106143: STR
106144: PPUSH
106145: CALL_OW 561
// end ;
106149: GO 106043
106151: POP
106152: POP
// AddToLog ( ]; ) ;
106153: LD_STRING ];
106155: PPUSH
106156: CALL_OW 561
// end ;
106160: LD_VAR 0 2
106164: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106165: LD_INT 0
106167: PPUSH
106168: PPUSH
106169: PPUSH
106170: PPUSH
106171: PPUSH
// if not area or not rate or not max then
106172: LD_VAR 0 1
106176: NOT
106177: PUSH
106178: LD_VAR 0 2
106182: NOT
106183: OR
106184: PUSH
106185: LD_VAR 0 4
106189: NOT
106190: OR
106191: IFFALSE 106195
// exit ;
106193: GO 106387
// while 1 do
106195: LD_INT 1
106197: IFFALSE 106387
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106199: LD_ADDR_VAR 0 9
106203: PUSH
106204: LD_VAR 0 1
106208: PPUSH
106209: LD_INT 1
106211: PPUSH
106212: CALL_OW 287
106216: PUSH
106217: LD_INT 10
106219: MUL
106220: ST_TO_ADDR
// r := rate / 10 ;
106221: LD_ADDR_VAR 0 7
106225: PUSH
106226: LD_VAR 0 2
106230: PUSH
106231: LD_INT 10
106233: DIVREAL
106234: ST_TO_ADDR
// time := 1 1$00 ;
106235: LD_ADDR_VAR 0 8
106239: PUSH
106240: LD_INT 2100
106242: ST_TO_ADDR
// if amount < min then
106243: LD_VAR 0 9
106247: PUSH
106248: LD_VAR 0 3
106252: LESS
106253: IFFALSE 106271
// r := r * 2 else
106255: LD_ADDR_VAR 0 7
106259: PUSH
106260: LD_VAR 0 7
106264: PUSH
106265: LD_INT 2
106267: MUL
106268: ST_TO_ADDR
106269: GO 106297
// if amount > max then
106271: LD_VAR 0 9
106275: PUSH
106276: LD_VAR 0 4
106280: GREATER
106281: IFFALSE 106297
// r := r / 2 ;
106283: LD_ADDR_VAR 0 7
106287: PUSH
106288: LD_VAR 0 7
106292: PUSH
106293: LD_INT 2
106295: DIVREAL
106296: ST_TO_ADDR
// time := time / r ;
106297: LD_ADDR_VAR 0 8
106301: PUSH
106302: LD_VAR 0 8
106306: PUSH
106307: LD_VAR 0 7
106311: DIVREAL
106312: ST_TO_ADDR
// if time < 0 then
106313: LD_VAR 0 8
106317: PUSH
106318: LD_INT 0
106320: LESS
106321: IFFALSE 106338
// time := time * - 1 ;
106323: LD_ADDR_VAR 0 8
106327: PUSH
106328: LD_VAR 0 8
106332: PUSH
106333: LD_INT 1
106335: NEG
106336: MUL
106337: ST_TO_ADDR
// wait ( time ) ;
106338: LD_VAR 0 8
106342: PPUSH
106343: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106347: LD_INT 35
106349: PPUSH
106350: LD_INT 875
106352: PPUSH
106353: CALL_OW 12
106357: PPUSH
106358: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106362: LD_INT 1
106364: PPUSH
106365: LD_INT 5
106367: PPUSH
106368: CALL_OW 12
106372: PPUSH
106373: LD_VAR 0 1
106377: PPUSH
106378: LD_INT 1
106380: PPUSH
106381: CALL_OW 55
// end ;
106385: GO 106195
// end ;
106387: LD_VAR 0 5
106391: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106392: LD_INT 0
106394: PPUSH
106395: PPUSH
106396: PPUSH
106397: PPUSH
106398: PPUSH
106399: PPUSH
106400: PPUSH
106401: PPUSH
// if not turrets or not factories then
106402: LD_VAR 0 1
106406: NOT
106407: PUSH
106408: LD_VAR 0 2
106412: NOT
106413: OR
106414: IFFALSE 106418
// exit ;
106416: GO 106725
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106418: LD_ADDR_VAR 0 10
106422: PUSH
106423: LD_INT 5
106425: PUSH
106426: LD_INT 6
106428: PUSH
106429: EMPTY
106430: LIST
106431: LIST
106432: PUSH
106433: LD_INT 2
106435: PUSH
106436: LD_INT 4
106438: PUSH
106439: EMPTY
106440: LIST
106441: LIST
106442: PUSH
106443: LD_INT 3
106445: PUSH
106446: LD_INT 5
106448: PUSH
106449: EMPTY
106450: LIST
106451: LIST
106452: PUSH
106453: EMPTY
106454: LIST
106455: LIST
106456: LIST
106457: PUSH
106458: LD_INT 24
106460: PUSH
106461: LD_INT 25
106463: PUSH
106464: EMPTY
106465: LIST
106466: LIST
106467: PUSH
106468: LD_INT 23
106470: PUSH
106471: LD_INT 27
106473: PUSH
106474: EMPTY
106475: LIST
106476: LIST
106477: PUSH
106478: EMPTY
106479: LIST
106480: LIST
106481: PUSH
106482: LD_INT 42
106484: PUSH
106485: LD_INT 43
106487: PUSH
106488: EMPTY
106489: LIST
106490: LIST
106491: PUSH
106492: LD_INT 44
106494: PUSH
106495: LD_INT 46
106497: PUSH
106498: EMPTY
106499: LIST
106500: LIST
106501: PUSH
106502: LD_INT 45
106504: PUSH
106505: LD_INT 47
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: PUSH
106512: EMPTY
106513: LIST
106514: LIST
106515: LIST
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: LIST
106521: ST_TO_ADDR
// result := [ ] ;
106522: LD_ADDR_VAR 0 3
106526: PUSH
106527: EMPTY
106528: ST_TO_ADDR
// for i in turrets do
106529: LD_ADDR_VAR 0 4
106533: PUSH
106534: LD_VAR 0 1
106538: PUSH
106539: FOR_IN
106540: IFFALSE 106723
// begin nat := GetNation ( i ) ;
106542: LD_ADDR_VAR 0 7
106546: PUSH
106547: LD_VAR 0 4
106551: PPUSH
106552: CALL_OW 248
106556: ST_TO_ADDR
// weapon := 0 ;
106557: LD_ADDR_VAR 0 8
106561: PUSH
106562: LD_INT 0
106564: ST_TO_ADDR
// if not nat then
106565: LD_VAR 0 7
106569: NOT
106570: IFFALSE 106574
// continue ;
106572: GO 106539
// for j in list [ nat ] do
106574: LD_ADDR_VAR 0 5
106578: PUSH
106579: LD_VAR 0 10
106583: PUSH
106584: LD_VAR 0 7
106588: ARRAY
106589: PUSH
106590: FOR_IN
106591: IFFALSE 106632
// if GetBWeapon ( i ) = j [ 1 ] then
106593: LD_VAR 0 4
106597: PPUSH
106598: CALL_OW 269
106602: PUSH
106603: LD_VAR 0 5
106607: PUSH
106608: LD_INT 1
106610: ARRAY
106611: EQUAL
106612: IFFALSE 106630
// begin weapon := j [ 2 ] ;
106614: LD_ADDR_VAR 0 8
106618: PUSH
106619: LD_VAR 0 5
106623: PUSH
106624: LD_INT 2
106626: ARRAY
106627: ST_TO_ADDR
// break ;
106628: GO 106632
// end ;
106630: GO 106590
106632: POP
106633: POP
// if not weapon then
106634: LD_VAR 0 8
106638: NOT
106639: IFFALSE 106643
// continue ;
106641: GO 106539
// for k in factories do
106643: LD_ADDR_VAR 0 6
106647: PUSH
106648: LD_VAR 0 2
106652: PUSH
106653: FOR_IN
106654: IFFALSE 106719
// begin weapons := AvailableWeaponList ( k ) ;
106656: LD_ADDR_VAR 0 9
106660: PUSH
106661: LD_VAR 0 6
106665: PPUSH
106666: CALL_OW 478
106670: ST_TO_ADDR
// if not weapons then
106671: LD_VAR 0 9
106675: NOT
106676: IFFALSE 106680
// continue ;
106678: GO 106653
// if weapon in weapons then
106680: LD_VAR 0 8
106684: PUSH
106685: LD_VAR 0 9
106689: IN
106690: IFFALSE 106717
// begin result := [ i , weapon ] ;
106692: LD_ADDR_VAR 0 3
106696: PUSH
106697: LD_VAR 0 4
106701: PUSH
106702: LD_VAR 0 8
106706: PUSH
106707: EMPTY
106708: LIST
106709: LIST
106710: ST_TO_ADDR
// exit ;
106711: POP
106712: POP
106713: POP
106714: POP
106715: GO 106725
// end ; end ;
106717: GO 106653
106719: POP
106720: POP
// end ;
106721: GO 106539
106723: POP
106724: POP
// end ;
106725: LD_VAR 0 3
106729: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106730: LD_INT 0
106732: PPUSH
// if not side or side > 8 then
106733: LD_VAR 0 3
106737: NOT
106738: PUSH
106739: LD_VAR 0 3
106743: PUSH
106744: LD_INT 8
106746: GREATER
106747: OR
106748: IFFALSE 106752
// exit ;
106750: GO 106811
// if not range then
106752: LD_VAR 0 4
106756: NOT
106757: IFFALSE 106768
// range := - 12 ;
106759: LD_ADDR_VAR 0 4
106763: PUSH
106764: LD_INT 12
106766: NEG
106767: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106768: LD_VAR 0 1
106772: PPUSH
106773: LD_VAR 0 2
106777: PPUSH
106778: LD_VAR 0 3
106782: PPUSH
106783: LD_VAR 0 4
106787: PPUSH
106788: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106792: LD_VAR 0 1
106796: PPUSH
106797: LD_VAR 0 2
106801: PPUSH
106802: LD_VAR 0 3
106806: PPUSH
106807: CALL_OW 331
// end ;
106811: LD_VAR 0 5
106815: RET
// export function Video ( mode ) ; begin
106816: LD_INT 0
106818: PPUSH
// ingame_video = mode ;
106819: LD_ADDR_OWVAR 52
106823: PUSH
106824: LD_VAR 0 1
106828: ST_TO_ADDR
// interface_hidden = mode ;
106829: LD_ADDR_OWVAR 54
106833: PUSH
106834: LD_VAR 0 1
106838: ST_TO_ADDR
// end ;
106839: LD_VAR 0 2
106843: RET
// export function Join ( array , element ) ; begin
106844: LD_INT 0
106846: PPUSH
// result := array ^ element ;
106847: LD_ADDR_VAR 0 3
106851: PUSH
106852: LD_VAR 0 1
106856: PUSH
106857: LD_VAR 0 2
106861: ADD
106862: ST_TO_ADDR
// end ;
106863: LD_VAR 0 3
106867: RET
// export function JoinUnion ( array , element ) ; begin
106868: LD_INT 0
106870: PPUSH
// result := array union element ;
106871: LD_ADDR_VAR 0 3
106875: PUSH
106876: LD_VAR 0 1
106880: PUSH
106881: LD_VAR 0 2
106885: UNION
106886: ST_TO_ADDR
// end ;
106887: LD_VAR 0 3
106891: RET
// export function GetBehemoths ( side ) ; begin
106892: LD_INT 0
106894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106895: LD_ADDR_VAR 0 2
106899: PUSH
106900: LD_INT 22
106902: PUSH
106903: LD_VAR 0 1
106907: PUSH
106908: EMPTY
106909: LIST
106910: LIST
106911: PUSH
106912: LD_INT 31
106914: PUSH
106915: LD_INT 25
106917: PUSH
106918: EMPTY
106919: LIST
106920: LIST
106921: PUSH
106922: EMPTY
106923: LIST
106924: LIST
106925: PPUSH
106926: CALL_OW 69
106930: ST_TO_ADDR
// end ;
106931: LD_VAR 0 2
106935: RET
// export function Shuffle ( array ) ; var i , index ; begin
106936: LD_INT 0
106938: PPUSH
106939: PPUSH
106940: PPUSH
// result := [ ] ;
106941: LD_ADDR_VAR 0 2
106945: PUSH
106946: EMPTY
106947: ST_TO_ADDR
// if not array then
106948: LD_VAR 0 1
106952: NOT
106953: IFFALSE 106957
// exit ;
106955: GO 107056
// Randomize ;
106957: CALL_OW 10
// for i = array downto 1 do
106961: LD_ADDR_VAR 0 3
106965: PUSH
106966: DOUBLE
106967: LD_VAR 0 1
106971: INC
106972: ST_TO_ADDR
106973: LD_INT 1
106975: PUSH
106976: FOR_DOWNTO
106977: IFFALSE 107054
// begin index := rand ( 1 , array ) ;
106979: LD_ADDR_VAR 0 4
106983: PUSH
106984: LD_INT 1
106986: PPUSH
106987: LD_VAR 0 1
106991: PPUSH
106992: CALL_OW 12
106996: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106997: LD_ADDR_VAR 0 2
107001: PUSH
107002: LD_VAR 0 2
107006: PPUSH
107007: LD_VAR 0 2
107011: PUSH
107012: LD_INT 1
107014: PLUS
107015: PPUSH
107016: LD_VAR 0 1
107020: PUSH
107021: LD_VAR 0 4
107025: ARRAY
107026: PPUSH
107027: CALL_OW 2
107031: ST_TO_ADDR
// array := Delete ( array , index ) ;
107032: LD_ADDR_VAR 0 1
107036: PUSH
107037: LD_VAR 0 1
107041: PPUSH
107042: LD_VAR 0 4
107046: PPUSH
107047: CALL_OW 3
107051: ST_TO_ADDR
// end ;
107052: GO 106976
107054: POP
107055: POP
// end ;
107056: LD_VAR 0 2
107060: RET
// export function GetBaseMaterials ( base ) ; begin
107061: LD_INT 0
107063: PPUSH
// result := [ 0 , 0 , 0 ] ;
107064: LD_ADDR_VAR 0 2
107068: PUSH
107069: LD_INT 0
107071: PUSH
107072: LD_INT 0
107074: PUSH
107075: LD_INT 0
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: LIST
107082: ST_TO_ADDR
// if not base then
107083: LD_VAR 0 1
107087: NOT
107088: IFFALSE 107092
// exit ;
107090: GO 107141
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107092: LD_ADDR_VAR 0 2
107096: PUSH
107097: LD_VAR 0 1
107101: PPUSH
107102: LD_INT 1
107104: PPUSH
107105: CALL_OW 275
107109: PUSH
107110: LD_VAR 0 1
107114: PPUSH
107115: LD_INT 2
107117: PPUSH
107118: CALL_OW 275
107122: PUSH
107123: LD_VAR 0 1
107127: PPUSH
107128: LD_INT 3
107130: PPUSH
107131: CALL_OW 275
107135: PUSH
107136: EMPTY
107137: LIST
107138: LIST
107139: LIST
107140: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107141: LD_VAR 0 2
107145: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107146: LD_INT 0
107148: PPUSH
107149: PPUSH
107150: PPUSH
107151: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107152: LD_VAR 0 1
107156: PPUSH
107157: CALL_OW 264
107161: PUSH
107162: LD_EXP 96
107166: EQUAL
107167: IFFALSE 107239
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107169: LD_INT 68
107171: PPUSH
107172: LD_VAR 0 1
107176: PPUSH
107177: CALL_OW 255
107181: PPUSH
107182: CALL_OW 321
107186: PUSH
107187: LD_INT 2
107189: EQUAL
107190: IFFALSE 107202
// eff := 70 else
107192: LD_ADDR_VAR 0 6
107196: PUSH
107197: LD_INT 70
107199: ST_TO_ADDR
107200: GO 107210
// eff := 30 ;
107202: LD_ADDR_VAR 0 6
107206: PUSH
107207: LD_INT 30
107209: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107210: LD_VAR 0 1
107214: PPUSH
107215: CALL_OW 250
107219: PPUSH
107220: LD_VAR 0 1
107224: PPUSH
107225: CALL_OW 251
107229: PPUSH
107230: LD_VAR 0 6
107234: PPUSH
107235: CALL_OW 495
// end ; end ;
107239: LD_VAR 0 4
107243: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107244: LD_INT 0
107246: PPUSH
107247: PPUSH
107248: PPUSH
107249: PPUSH
107250: PPUSH
107251: PPUSH
// if cmd = 124 then
107252: LD_VAR 0 1
107256: PUSH
107257: LD_INT 124
107259: EQUAL
107260: IFFALSE 107466
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107262: LD_ADDR_VAR 0 5
107266: PUSH
107267: LD_INT 2
107269: PUSH
107270: LD_INT 34
107272: PUSH
107273: LD_INT 53
107275: PUSH
107276: EMPTY
107277: LIST
107278: LIST
107279: PUSH
107280: LD_INT 34
107282: PUSH
107283: LD_INT 14
107285: PUSH
107286: EMPTY
107287: LIST
107288: LIST
107289: PUSH
107290: EMPTY
107291: LIST
107292: LIST
107293: LIST
107294: PPUSH
107295: CALL_OW 69
107299: ST_TO_ADDR
// if not tmp then
107300: LD_VAR 0 5
107304: NOT
107305: IFFALSE 107309
// exit ;
107307: GO 107466
// for i in tmp do
107309: LD_ADDR_VAR 0 3
107313: PUSH
107314: LD_VAR 0 5
107318: PUSH
107319: FOR_IN
107320: IFFALSE 107464
// begin taskList := GetTaskList ( i ) ;
107322: LD_ADDR_VAR 0 6
107326: PUSH
107327: LD_VAR 0 3
107331: PPUSH
107332: CALL_OW 437
107336: ST_TO_ADDR
// if not taskList then
107337: LD_VAR 0 6
107341: NOT
107342: IFFALSE 107346
// continue ;
107344: GO 107319
// for j = 1 to taskList do
107346: LD_ADDR_VAR 0 4
107350: PUSH
107351: DOUBLE
107352: LD_INT 1
107354: DEC
107355: ST_TO_ADDR
107356: LD_VAR 0 6
107360: PUSH
107361: FOR_TO
107362: IFFALSE 107460
// if taskList [ j ] [ 1 ] = | then
107364: LD_VAR 0 6
107368: PUSH
107369: LD_VAR 0 4
107373: ARRAY
107374: PUSH
107375: LD_INT 1
107377: ARRAY
107378: PUSH
107379: LD_STRING |
107381: EQUAL
107382: IFFALSE 107458
// begin _taskList := Delete ( taskList , 1 ) ;
107384: LD_ADDR_VAR 0 7
107388: PUSH
107389: LD_VAR 0 6
107393: PPUSH
107394: LD_INT 1
107396: PPUSH
107397: CALL_OW 3
107401: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107402: LD_VAR 0 3
107406: PPUSH
107407: LD_VAR 0 7
107411: PPUSH
107412: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107416: LD_VAR 0 3
107420: PPUSH
107421: LD_VAR 0 6
107425: PUSH
107426: LD_VAR 0 4
107430: ARRAY
107431: PUSH
107432: LD_INT 2
107434: ARRAY
107435: PPUSH
107436: LD_VAR 0 6
107440: PUSH
107441: LD_VAR 0 4
107445: ARRAY
107446: PUSH
107447: LD_INT 3
107449: ARRAY
107450: PPUSH
107451: LD_INT 8
107453: PPUSH
107454: CALL 107471 0 4
// end ;
107458: GO 107361
107460: POP
107461: POP
// end ;
107462: GO 107319
107464: POP
107465: POP
// end ; end ;
107466: LD_VAR 0 2
107470: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107471: LD_INT 0
107473: PPUSH
107474: PPUSH
107475: PPUSH
107476: PPUSH
107477: PPUSH
107478: PPUSH
107479: PPUSH
107480: PPUSH
107481: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107482: LD_VAR 0 1
107486: NOT
107487: PUSH
107488: LD_VAR 0 2
107492: PPUSH
107493: LD_VAR 0 3
107497: PPUSH
107498: CALL_OW 488
107502: NOT
107503: OR
107504: PUSH
107505: LD_VAR 0 4
107509: NOT
107510: OR
107511: IFFALSE 107515
// exit ;
107513: GO 107855
// list := [ ] ;
107515: LD_ADDR_VAR 0 13
107519: PUSH
107520: EMPTY
107521: ST_TO_ADDR
// if x - r < 0 then
107522: LD_VAR 0 2
107526: PUSH
107527: LD_VAR 0 4
107531: MINUS
107532: PUSH
107533: LD_INT 0
107535: LESS
107536: IFFALSE 107548
// min_x := 0 else
107538: LD_ADDR_VAR 0 7
107542: PUSH
107543: LD_INT 0
107545: ST_TO_ADDR
107546: GO 107564
// min_x := x - r ;
107548: LD_ADDR_VAR 0 7
107552: PUSH
107553: LD_VAR 0 2
107557: PUSH
107558: LD_VAR 0 4
107562: MINUS
107563: ST_TO_ADDR
// if y - r < 0 then
107564: LD_VAR 0 3
107568: PUSH
107569: LD_VAR 0 4
107573: MINUS
107574: PUSH
107575: LD_INT 0
107577: LESS
107578: IFFALSE 107590
// min_y := 0 else
107580: LD_ADDR_VAR 0 8
107584: PUSH
107585: LD_INT 0
107587: ST_TO_ADDR
107588: GO 107606
// min_y := y - r ;
107590: LD_ADDR_VAR 0 8
107594: PUSH
107595: LD_VAR 0 3
107599: PUSH
107600: LD_VAR 0 4
107604: MINUS
107605: ST_TO_ADDR
// max_x := x + r ;
107606: LD_ADDR_VAR 0 9
107610: PUSH
107611: LD_VAR 0 2
107615: PUSH
107616: LD_VAR 0 4
107620: PLUS
107621: ST_TO_ADDR
// max_y := y + r ;
107622: LD_ADDR_VAR 0 10
107626: PUSH
107627: LD_VAR 0 3
107631: PUSH
107632: LD_VAR 0 4
107636: PLUS
107637: ST_TO_ADDR
// for _x = min_x to max_x do
107638: LD_ADDR_VAR 0 11
107642: PUSH
107643: DOUBLE
107644: LD_VAR 0 7
107648: DEC
107649: ST_TO_ADDR
107650: LD_VAR 0 9
107654: PUSH
107655: FOR_TO
107656: IFFALSE 107773
// for _y = min_y to max_y do
107658: LD_ADDR_VAR 0 12
107662: PUSH
107663: DOUBLE
107664: LD_VAR 0 8
107668: DEC
107669: ST_TO_ADDR
107670: LD_VAR 0 10
107674: PUSH
107675: FOR_TO
107676: IFFALSE 107769
// begin if not ValidHex ( _x , _y ) then
107678: LD_VAR 0 11
107682: PPUSH
107683: LD_VAR 0 12
107687: PPUSH
107688: CALL_OW 488
107692: NOT
107693: IFFALSE 107697
// continue ;
107695: GO 107675
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107697: LD_VAR 0 11
107701: PPUSH
107702: LD_VAR 0 12
107706: PPUSH
107707: CALL_OW 351
107711: PUSH
107712: LD_VAR 0 11
107716: PPUSH
107717: LD_VAR 0 12
107721: PPUSH
107722: CALL_OW 554
107726: AND
107727: IFFALSE 107767
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107729: LD_ADDR_VAR 0 13
107733: PUSH
107734: LD_VAR 0 13
107738: PPUSH
107739: LD_VAR 0 13
107743: PUSH
107744: LD_INT 1
107746: PLUS
107747: PPUSH
107748: LD_VAR 0 11
107752: PUSH
107753: LD_VAR 0 12
107757: PUSH
107758: EMPTY
107759: LIST
107760: LIST
107761: PPUSH
107762: CALL_OW 2
107766: ST_TO_ADDR
// end ;
107767: GO 107675
107769: POP
107770: POP
107771: GO 107655
107773: POP
107774: POP
// if not list then
107775: LD_VAR 0 13
107779: NOT
107780: IFFALSE 107784
// exit ;
107782: GO 107855
// for i in list do
107784: LD_ADDR_VAR 0 6
107788: PUSH
107789: LD_VAR 0 13
107793: PUSH
107794: FOR_IN
107795: IFFALSE 107853
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107797: LD_VAR 0 1
107801: PPUSH
107802: LD_STRING M
107804: PUSH
107805: LD_VAR 0 6
107809: PUSH
107810: LD_INT 1
107812: ARRAY
107813: PUSH
107814: LD_VAR 0 6
107818: PUSH
107819: LD_INT 2
107821: ARRAY
107822: PUSH
107823: LD_INT 0
107825: PUSH
107826: LD_INT 0
107828: PUSH
107829: LD_INT 0
107831: PUSH
107832: LD_INT 0
107834: PUSH
107835: EMPTY
107836: LIST
107837: LIST
107838: LIST
107839: LIST
107840: LIST
107841: LIST
107842: LIST
107843: PUSH
107844: EMPTY
107845: LIST
107846: PPUSH
107847: CALL_OW 447
107851: GO 107794
107853: POP
107854: POP
// end ;
107855: LD_VAR 0 5
107859: RET
