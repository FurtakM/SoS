// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39010 0 0
// InitNature ;
  19: CALL 38878 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12577 0 0
// PrepareRussian ;
  40: CALL 7543 0 0
// PrepareLegion ;
  44: CALL 4619 0 0
// PreparePowell ;
  48: CALL 3153 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17507 0 0
// MC_Start ( ) ;
  60: CALL 41190 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63986 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64079 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63429 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63244 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63986 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64079 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63244 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63429 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63859 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62907 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63986 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64079 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63244 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63986 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64079 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63136 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64397 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63568 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63859 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63859 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64191 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63244 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63810 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69718 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74558 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74558 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 59
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 59
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74558 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 59
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 59
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 59
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 59
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74558 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74558 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 60
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 60
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 60
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69718 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 60
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69718 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 60
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69718 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 60
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69718 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2491
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2413: LD_ADDR_OWVAR 30
2417: PUSH
2418: LD_INT 2
2420: PUSH
2421: LD_INT 2
2423: PUSH
2424: LD_INT 0
2426: PUSH
2427: LD_INT 2
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2436: LD_ADDR_OWVAR 31
2440: PUSH
2441: LD_INT 4
2443: PUSH
2444: LD_INT 5
2446: PUSH
2447: LD_INT 2
2449: PUSH
2450: LD_INT 10
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: ST_TO_ADDR
// Baker := CreateHuman ;
2459: LD_ADDR_EXP 56
2463: PUSH
2464: CALL_OW 44
2468: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: LD_VAR 0 2
2478: PUSH
2479: LD_EXP 56
2483: ADD
2484: ST_TO_ADDR
// InitHc ;
2485: CALL_OW 19
// end else
2489: GO 2507
// tmp := tmp ^ Stevens ;
2491: LD_ADDR_VAR 0 2
2495: PUSH
2496: LD_VAR 0 2
2500: PUSH
2501: LD_EXP 42
2505: ADD
2506: ST_TO_ADDR
// if not Lisa then
2507: LD_EXP 43
2511: NOT
2512: IFFALSE 2558
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2514: LD_ADDR_EXP 43
2518: PUSH
2519: LD_STRING Lisa
2521: PPUSH
2522: LD_EXP 1
2526: NOT
2527: PPUSH
2528: LD_STRING 13f_
2530: PPUSH
2531: CALL 69718 0 3
2535: ST_TO_ADDR
// if Lisa then
2536: LD_EXP 43
2540: IFFALSE 2558
// tmp := tmp ^ Lisa ;
2542: LD_ADDR_VAR 0 2
2546: PUSH
2547: LD_VAR 0 2
2551: PUSH
2552: LD_EXP 43
2556: ADD
2557: ST_TO_ADDR
// end ; if not Donaldson then
2558: LD_EXP 44
2562: NOT
2563: IFFALSE 2609
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2565: LD_ADDR_EXP 44
2569: PUSH
2570: LD_STRING Donaldson
2572: PPUSH
2573: LD_EXP 1
2577: NOT
2578: PPUSH
2579: LD_STRING 13f_
2581: PPUSH
2582: CALL 69718 0 3
2586: ST_TO_ADDR
// if Donaldson then
2587: LD_EXP 44
2591: IFFALSE 2609
// tmp := tmp ^ Donaldson ;
2593: LD_ADDR_VAR 0 2
2597: PUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_EXP 44
2607: ADD
2608: ST_TO_ADDR
// end ; if not Bobby then
2609: LD_EXP 45
2613: NOT
2614: IFFALSE 2660
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2616: LD_ADDR_EXP 45
2620: PUSH
2621: LD_STRING Bobby
2623: PPUSH
2624: LD_EXP 1
2628: NOT
2629: PPUSH
2630: LD_STRING 13f_
2632: PPUSH
2633: CALL 69718 0 3
2637: ST_TO_ADDR
// if Bobby then
2638: LD_EXP 45
2642: IFFALSE 2660
// tmp := tmp ^ Bobby ;
2644: LD_ADDR_VAR 0 2
2648: PUSH
2649: LD_VAR 0 2
2653: PUSH
2654: LD_EXP 45
2658: ADD
2659: ST_TO_ADDR
// end ; if not Cyrus then
2660: LD_EXP 46
2664: NOT
2665: IFFALSE 2711
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2667: LD_ADDR_EXP 46
2671: PUSH
2672: LD_STRING Cyrus
2674: PPUSH
2675: LD_EXP 1
2679: NOT
2680: PPUSH
2681: LD_STRING 13f_
2683: PPUSH
2684: CALL 69718 0 3
2688: ST_TO_ADDR
// if Cyrus then
2689: LD_EXP 46
2693: IFFALSE 2711
// tmp := tmp ^ Cyrus ;
2695: LD_ADDR_VAR 0 2
2699: PUSH
2700: LD_VAR 0 2
2704: PUSH
2705: LD_EXP 46
2709: ADD
2710: ST_TO_ADDR
// end ; if not Brown then
2711: LD_EXP 48
2715: NOT
2716: IFFALSE 2762
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2718: LD_ADDR_EXP 48
2722: PUSH
2723: LD_STRING Brown
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_STRING 13f_
2734: PPUSH
2735: CALL 69718 0 3
2739: ST_TO_ADDR
// if Brown then
2740: LD_EXP 48
2744: IFFALSE 2762
// tmp := tmp ^ Brown ;
2746: LD_ADDR_VAR 0 2
2750: PUSH
2751: LD_VAR 0 2
2755: PUSH
2756: LD_EXP 48
2760: ADD
2761: ST_TO_ADDR
// end ; if not Gladstone then
2762: LD_EXP 49
2766: NOT
2767: IFFALSE 2813
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2769: LD_ADDR_EXP 49
2773: PUSH
2774: LD_STRING Gladstone
2776: PPUSH
2777: LD_EXP 1
2781: NOT
2782: PPUSH
2783: LD_STRING 13f_
2785: PPUSH
2786: CALL 69718 0 3
2790: ST_TO_ADDR
// if Gladstone then
2791: LD_EXP 49
2795: IFFALSE 2813
// tmp := tmp ^ Gladstone ;
2797: LD_ADDR_VAR 0 2
2801: PUSH
2802: LD_VAR 0 2
2806: PUSH
2807: LD_EXP 49
2811: ADD
2812: ST_TO_ADDR
// end ; if not Houten then
2813: LD_EXP 50
2817: NOT
2818: IFFALSE 2864
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2820: LD_ADDR_EXP 50
2824: PUSH
2825: LD_STRING Houten
2827: PPUSH
2828: LD_EXP 1
2832: NOT
2833: PPUSH
2834: LD_STRING 13f_
2836: PPUSH
2837: CALL 69718 0 3
2841: ST_TO_ADDR
// if Houten then
2842: LD_EXP 50
2846: IFFALSE 2864
// tmp := tmp ^ Houten ;
2848: LD_ADDR_VAR 0 2
2852: PUSH
2853: LD_VAR 0 2
2857: PUSH
2858: LD_EXP 50
2862: ADD
2863: ST_TO_ADDR
// end ; if not Cornel then
2864: LD_EXP 51
2868: NOT
2869: IFFALSE 2915
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2871: LD_ADDR_EXP 51
2875: PUSH
2876: LD_STRING Cornell
2878: PPUSH
2879: LD_EXP 1
2883: NOT
2884: PPUSH
2885: LD_STRING 13f_
2887: PPUSH
2888: CALL 69718 0 3
2892: ST_TO_ADDR
// if Cornel then
2893: LD_EXP 51
2897: IFFALSE 2915
// tmp := tmp ^ Cornel ;
2899: LD_ADDR_VAR 0 2
2903: PUSH
2904: LD_VAR 0 2
2908: PUSH
2909: LD_EXP 51
2913: ADD
2914: ST_TO_ADDR
// end ; if not Gary then
2915: LD_EXP 52
2919: NOT
2920: IFFALSE 2966
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2922: LD_ADDR_EXP 52
2926: PUSH
2927: LD_STRING Gary
2929: PPUSH
2930: LD_EXP 1
2934: NOT
2935: PPUSH
2936: LD_STRING 13f_
2938: PPUSH
2939: CALL 69718 0 3
2943: ST_TO_ADDR
// if Gary then
2944: LD_EXP 52
2948: IFFALSE 2966
// tmp := tmp ^ Gary ;
2950: LD_ADDR_VAR 0 2
2954: PUSH
2955: LD_VAR 0 2
2959: PUSH
2960: LD_EXP 52
2964: ADD
2965: ST_TO_ADDR
// end ; if not Frank then
2966: LD_EXP 53
2970: NOT
2971: IFFALSE 3017
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2973: LD_ADDR_EXP 53
2977: PUSH
2978: LD_STRING Frank
2980: PPUSH
2981: LD_EXP 1
2985: NOT
2986: PPUSH
2987: LD_STRING 13f_
2989: PPUSH
2990: CALL 69718 0 3
2994: ST_TO_ADDR
// if Frank then
2995: LD_EXP 53
2999: IFFALSE 3017
// tmp := tmp ^ Frank ;
3001: LD_ADDR_VAR 0 2
3005: PUSH
3006: LD_VAR 0 2
3010: PUSH
3011: LD_EXP 53
3015: ADD
3016: ST_TO_ADDR
// end ; if not Kikuchi then
3017: LD_EXP 54
3021: NOT
3022: IFFALSE 3068
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3024: LD_ADDR_EXP 54
3028: PUSH
3029: LD_STRING Kikuchi
3031: PPUSH
3032: LD_EXP 1
3036: NOT
3037: PPUSH
3038: LD_STRING 13f_
3040: PPUSH
3041: CALL 69718 0 3
3045: ST_TO_ADDR
// if Kikuchi then
3046: LD_EXP 54
3050: IFFALSE 3068
// tmp := tmp ^ Kikuchi ;
3052: LD_ADDR_VAR 0 2
3056: PUSH
3057: LD_VAR 0 2
3061: PUSH
3062: LD_EXP 54
3066: ADD
3067: ST_TO_ADDR
// end ; if not DeltaDoctor then
3068: LD_EXP 58
3072: NOT
3073: IFFALSE 3119
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3075: LD_ADDR_EXP 58
3079: PUSH
3080: LD_STRING DeltaDoctor
3082: PPUSH
3083: LD_EXP 1
3087: NOT
3088: PPUSH
3089: LD_STRING 13f_
3091: PPUSH
3092: CALL 69718 0 3
3096: ST_TO_ADDR
// if Bobby then
3097: LD_EXP 45
3101: IFFALSE 3119
// tmp := tmp ^ DeltaDoctor ;
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: LD_VAR 0 2
3112: PUSH
3113: LD_EXP 58
3117: ADD
3118: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3119: LD_ADDR_VAR 0 2
3123: PUSH
3124: LD_VAR 0 2
3128: PUSH
3129: LD_STRING 13_other_survivors
3131: PPUSH
3132: CALL_OW 31
3136: UNION
3137: ST_TO_ADDR
// result := tmp ;
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 2
3147: ST_TO_ADDR
// end ; end_of_file
3148: LD_VAR 0 1
3152: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3153: LD_INT 0
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
3159: PPUSH
3160: PPUSH
3161: PPUSH
3162: PPUSH
3163: PPUSH
3164: PPUSH
// uc_side := 4 ;
3165: LD_ADDR_OWVAR 20
3169: PUSH
3170: LD_INT 4
3172: ST_TO_ADDR
// uc_nation := 1 ;
3173: LD_ADDR_OWVAR 21
3177: PUSH
3178: LD_INT 1
3180: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3181: LD_INT 387
3183: PPUSH
3184: CALL_OW 274
3188: PPUSH
3189: LD_INT 1
3191: PPUSH
3192: LD_INT 3500
3194: PUSH
3195: LD_INT 3000
3197: PUSH
3198: LD_INT 2500
3200: PUSH
3201: LD_INT 2000
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: PUSH
3210: LD_OWVAR 67
3214: ARRAY
3215: PPUSH
3216: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3220: LD_INT 387
3222: PPUSH
3223: CALL_OW 274
3227: PPUSH
3228: LD_INT 2
3230: PPUSH
3231: LD_INT 400
3233: PPUSH
3234: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3238: LD_INT 387
3240: PPUSH
3241: CALL_OW 274
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 10
3251: PPUSH
3252: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3256: LD_INT 387
3258: PPUSH
3259: LD_STRING sigma
3261: PPUSH
3262: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3266: LD_ADDR_EXP 61
3270: PUSH
3271: LD_STRING Powell
3273: PPUSH
3274: CALL_OW 25
3278: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3279: LD_EXP 61
3283: PPUSH
3284: LD_INT 57
3286: PPUSH
3287: LD_INT 94
3289: PPUSH
3290: LD_INT 0
3292: PPUSH
3293: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3297: LD_EXP 61
3301: PPUSH
3302: LD_INT 58
3304: PPUSH
3305: LD_INT 94
3307: PPUSH
3308: CALL_OW 118
// vip := [ ] ;
3312: LD_ADDR_EXP 62
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// extraSquad := [ ] ;
3319: LD_ADDR_EXP 63
3323: PUSH
3324: EMPTY
3325: ST_TO_ADDR
// tmp := [ ] ;
3326: LD_ADDR_VAR 0 5
3330: PUSH
3331: EMPTY
3332: ST_TO_ADDR
// if JMMGirl <> 2 then
3333: LD_EXP 7
3337: PUSH
3338: LD_INT 2
3340: NONEQUAL
3341: IFFALSE 3365
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3343: LD_ADDR_EXP 43
3347: PUSH
3348: LD_STRING Lisa
3350: PPUSH
3351: LD_EXP 1
3355: NOT
3356: PPUSH
3357: LD_STRING 13s_
3359: PPUSH
3360: CALL 69718 0 3
3364: ST_TO_ADDR
// if Lisa then
3365: LD_EXP 43
3369: IFFALSE 3387
// tmp := tmp ^ Lisa ;
3371: LD_ADDR_VAR 0 5
3375: PUSH
3376: LD_VAR 0 5
3380: PUSH
3381: LD_EXP 43
3385: ADD
3386: ST_TO_ADDR
// if JMMGirl < 3 then
3387: LD_EXP 7
3391: PUSH
3392: LD_INT 3
3394: LESS
3395: IFFALSE 3426
// begin Connie := NewCharacter ( Coonie ) ;
3397: LD_ADDR_EXP 55
3401: PUSH
3402: LD_STRING Coonie
3404: PPUSH
3405: CALL_OW 25
3409: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3410: LD_ADDR_VAR 0 5
3414: PUSH
3415: LD_VAR 0 5
3419: PUSH
3420: LD_EXP 55
3424: ADD
3425: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3426: LD_ADDR_EXP 44
3430: PUSH
3431: LD_STRING Donaldson
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: LD_STRING 13s_
3442: PPUSH
3443: CALL 69718 0 3
3447: ST_TO_ADDR
// if Donaldson then
3448: LD_EXP 44
3452: IFFALSE 3470
// tmp := tmp ^ Donaldson ;
3454: LD_ADDR_VAR 0 5
3458: PUSH
3459: LD_VAR 0 5
3463: PUSH
3464: LD_EXP 44
3468: ADD
3469: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3470: LD_ADDR_EXP 45
3474: PUSH
3475: LD_STRING Bobby
3477: PPUSH
3478: LD_EXP 1
3482: NOT
3483: PPUSH
3484: LD_STRING 13s_
3486: PPUSH
3487: CALL 69718 0 3
3491: ST_TO_ADDR
// if Bobby then
3492: LD_EXP 45
3496: IFFALSE 3514
// tmp := tmp ^ Bobby ;
3498: LD_ADDR_VAR 0 5
3502: PUSH
3503: LD_VAR 0 5
3507: PUSH
3508: LD_EXP 45
3512: ADD
3513: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3514: LD_ADDR_EXP 46
3518: PUSH
3519: LD_STRING Cyrus
3521: PPUSH
3522: LD_EXP 1
3526: NOT
3527: PPUSH
3528: LD_STRING 13s_
3530: PPUSH
3531: CALL 69718 0 3
3535: ST_TO_ADDR
// if Cyrus then
3536: LD_EXP 46
3540: IFFALSE 3558
// tmp := tmp ^ Cyrus ;
3542: LD_ADDR_VAR 0 5
3546: PUSH
3547: LD_VAR 0 5
3551: PUSH
3552: LD_EXP 46
3556: ADD
3557: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3558: LD_ADDR_EXP 47
3562: PUSH
3563: LD_STRING Denis
3565: PPUSH
3566: LD_EXP 1
3570: NOT
3571: PPUSH
3572: LD_STRING 13s_
3574: PPUSH
3575: CALL 69718 0 3
3579: ST_TO_ADDR
// if not Denis then
3580: LD_EXP 47
3584: NOT
3585: IFFALSE 3609
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3587: LD_ADDR_EXP 47
3591: PUSH
3592: LD_STRING Denis
3594: PPUSH
3595: LD_EXP 1
3599: NOT
3600: PPUSH
3601: LD_STRING 13f_
3603: PPUSH
3604: CALL 69718 0 3
3608: ST_TO_ADDR
// if Denis then
3609: LD_EXP 47
3613: IFFALSE 3631
// tmp := tmp ^ Denis ;
3615: LD_ADDR_VAR 0 5
3619: PUSH
3620: LD_VAR 0 5
3624: PUSH
3625: LD_EXP 47
3629: ADD
3630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3631: LD_ADDR_EXP 48
3635: PUSH
3636: LD_STRING Brown
3638: PPUSH
3639: LD_EXP 1
3643: NOT
3644: PPUSH
3645: LD_STRING 13s_
3647: PPUSH
3648: CALL 69718 0 3
3652: ST_TO_ADDR
// if Brown then
3653: LD_EXP 48
3657: IFFALSE 3675
// tmp := tmp ^ Brown ;
3659: LD_ADDR_VAR 0 5
3663: PUSH
3664: LD_VAR 0 5
3668: PUSH
3669: LD_EXP 48
3673: ADD
3674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3675: LD_ADDR_EXP 49
3679: PUSH
3680: LD_STRING Gladstone
3682: PPUSH
3683: LD_EXP 1
3687: NOT
3688: PPUSH
3689: LD_STRING 13s_
3691: PPUSH
3692: CALL 69718 0 3
3696: ST_TO_ADDR
// if Gladstone then
3697: LD_EXP 49
3701: IFFALSE 3719
// tmp := tmp ^ Gladstone ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: LD_VAR 0 5
3712: PUSH
3713: LD_EXP 49
3717: ADD
3718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3719: LD_ADDR_EXP 50
3723: PUSH
3724: LD_STRING Houten
3726: PPUSH
3727: LD_EXP 1
3731: NOT
3732: PPUSH
3733: LD_STRING 13s_
3735: PPUSH
3736: CALL 69718 0 3
3740: ST_TO_ADDR
// if Houten then
3741: LD_EXP 50
3745: IFFALSE 3763
// tmp := tmp ^ Houten ;
3747: LD_ADDR_VAR 0 5
3751: PUSH
3752: LD_VAR 0 5
3756: PUSH
3757: LD_EXP 50
3761: ADD
3762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3763: LD_ADDR_EXP 51
3767: PUSH
3768: LD_STRING Cornel
3770: PPUSH
3771: LD_EXP 1
3775: NOT
3776: PPUSH
3777: LD_STRING 13s_
3779: PPUSH
3780: CALL 69718 0 3
3784: ST_TO_ADDR
// if Cornel then
3785: LD_EXP 51
3789: IFFALSE 3807
// tmp := tmp ^ Cornel ;
3791: LD_ADDR_VAR 0 5
3795: PUSH
3796: LD_VAR 0 5
3800: PUSH
3801: LD_EXP 51
3805: ADD
3806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3807: LD_ADDR_EXP 52
3811: PUSH
3812: LD_STRING Gary
3814: PPUSH
3815: LD_EXP 1
3819: NOT
3820: PPUSH
3821: LD_STRING 13s_
3823: PPUSH
3824: CALL 69718 0 3
3828: ST_TO_ADDR
// if Gary then
3829: LD_EXP 52
3833: IFFALSE 3851
// tmp := tmp ^ Gary ;
3835: LD_ADDR_VAR 0 5
3839: PUSH
3840: LD_VAR 0 5
3844: PUSH
3845: LD_EXP 52
3849: ADD
3850: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3851: LD_ADDR_EXP 53
3855: PUSH
3856: LD_STRING Frank
3858: PPUSH
3859: LD_EXP 1
3863: NOT
3864: PPUSH
3865: LD_STRING 13s_
3867: PPUSH
3868: CALL 69718 0 3
3872: ST_TO_ADDR
// if Frank then
3873: LD_EXP 53
3877: IFFALSE 3895
// tmp := tmp ^ Frank ;
3879: LD_ADDR_VAR 0 5
3883: PUSH
3884: LD_VAR 0 5
3888: PUSH
3889: LD_EXP 53
3893: ADD
3894: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3895: LD_ADDR_EXP 54
3899: PUSH
3900: LD_STRING Kikuchi
3902: PPUSH
3903: LD_EXP 1
3907: NOT
3908: PPUSH
3909: LD_STRING 13s_
3911: PPUSH
3912: CALL 69718 0 3
3916: ST_TO_ADDR
// if Kikuchi then
3917: LD_EXP 54
3921: IFFALSE 3939
// tmp := tmp ^ Kikuchi ;
3923: LD_ADDR_VAR 0 5
3927: PUSH
3928: LD_VAR 0 5
3932: PUSH
3933: LD_EXP 54
3937: ADD
3938: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3939: LD_ADDR_EXP 58
3943: PUSH
3944: LD_STRING DeltaDoctor
3946: PPUSH
3947: LD_EXP 1
3951: NOT
3952: PPUSH
3953: LD_STRING 13s_
3955: PPUSH
3956: CALL 69718 0 3
3960: ST_TO_ADDR
// if DeltaDoctor then
3961: LD_EXP 58
3965: IFFALSE 3983
// tmp := tmp ^ DeltaDoctor ;
3967: LD_ADDR_VAR 0 5
3971: PUSH
3972: LD_VAR 0 5
3976: PUSH
3977: LD_EXP 58
3981: ADD
3982: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3983: LD_ADDR_EXP 57
3987: PUSH
3988: LD_STRING Mike
3990: PPUSH
3991: LD_EXP 1
3995: NOT
3996: PPUSH
3997: LD_STRING 10c_
3999: PPUSH
4000: CALL 69718 0 3
4004: ST_TO_ADDR
// if Mike then
4005: LD_EXP 57
4009: IFFALSE 4032
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4011: LD_EXP 57
4015: PPUSH
4016: LD_INT 61
4018: PPUSH
4019: LD_INT 89
4021: PPUSH
4022: LD_INT 8
4024: PPUSH
4025: LD_INT 0
4027: PPUSH
4028: CALL_OW 50
// vip := tmp ;
4032: LD_ADDR_EXP 62
4036: PUSH
4037: LD_VAR 0 5
4041: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4042: LD_ADDR_VAR 0 5
4046: PUSH
4047: LD_VAR 0 5
4051: PUSH
4052: LD_STRING 13s_others
4054: PPUSH
4055: CALL_OW 31
4059: UNION
4060: ST_TO_ADDR
// if tmp < 18 then
4061: LD_VAR 0 5
4065: PUSH
4066: LD_INT 18
4068: LESS
4069: IFFALSE 4174
// begin InitHC_All ( ) ;
4071: CALL_OW 584
// for i = 1 to 18 - tmp do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 18
4087: PUSH
4088: LD_VAR 0 5
4092: MINUS
4093: PUSH
4094: FOR_TO
4095: IFFALSE 4172
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4097: LD_INT 1
4099: PPUSH
4100: LD_VAR 0 2
4104: PUSH
4105: LD_INT 4
4107: MOD
4108: PUSH
4109: LD_INT 1
4111: PLUS
4112: PPUSH
4113: LD_INT 4
4115: PPUSH
4116: CALL_OW 380
// un := CreateHuman ;
4120: LD_ADDR_VAR 0 10
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4130: LD_ADDR_VAR 0 5
4134: PUSH
4135: LD_VAR 0 5
4139: PPUSH
4140: LD_VAR 0 10
4144: PPUSH
4145: CALL 107409 0 2
4149: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4150: LD_ADDR_EXP 63
4154: PUSH
4155: LD_EXP 63
4159: PPUSH
4160: LD_VAR 0 10
4164: PPUSH
4165: CALL 107409 0 2
4169: ST_TO_ADDR
// end ;
4170: GO 4094
4172: POP
4173: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_INT 53
4181: PPUSH
4182: LD_INT 94
4184: PPUSH
4185: CALL_OW 428
4189: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4190: LD_ADDR_VAR 0 7
4194: PUSH
4195: LD_INT 56
4197: PPUSH
4198: LD_INT 101
4200: PPUSH
4201: CALL_OW 428
4205: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4206: LD_ADDR_VAR 0 8
4210: PUSH
4211: LD_INT 67
4213: PPUSH
4214: LD_INT 101
4216: PPUSH
4217: CALL_OW 428
4221: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4222: LD_ADDR_VAR 0 9
4226: PUSH
4227: LD_INT 54
4229: PPUSH
4230: LD_INT 85
4232: PPUSH
4233: CALL_OW 428
4237: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4238: LD_ADDR_VAR 0 3
4242: PUSH
4243: LD_VAR 0 8
4247: PUSH
4248: LD_VAR 0 6
4252: PUSH
4253: LD_VAR 0 9
4257: PUSH
4258: LD_VAR 0 7
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: ST_TO_ADDR
// for i in tmp do
4269: LD_ADDR_VAR 0 2
4273: PUSH
4274: LD_VAR 0 5
4278: PUSH
4279: FOR_IN
4280: IFFALSE 4475
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4282: LD_VAR 0 3
4286: PUSH
4287: LD_INT 1
4289: ARRAY
4290: PPUSH
4291: CALL_OW 266
4295: PUSH
4296: LD_INT 4
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4319
4304: POP
// SetClass ( i , class_soldier ) ; b_depot :
4305: LD_VAR 0 2
4309: PPUSH
4310: LD_INT 1
4312: PPUSH
4313: CALL_OW 336
4317: GO 4389
4319: LD_INT 0
4321: DOUBLE
4322: EQUAL
4323: IFTRUE 4327
4325: GO 4342
4327: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4328: LD_VAR 0 2
4332: PPUSH
4333: LD_INT 2
4335: PPUSH
4336: CALL_OW 336
4340: GO 4389
4342: LD_INT 2
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4365
4350: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4351: LD_VAR 0 2
4355: PPUSH
4356: LD_INT 3
4358: PPUSH
4359: CALL_OW 336
4363: GO 4389
4365: LD_INT 6
4367: DOUBLE
4368: EQUAL
4369: IFTRUE 4373
4371: GO 4388
4373: POP
// SetClass ( i , class_scientistic ) ; end ;
4374: LD_VAR 0 2
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: CALL_OW 336
4386: GO 4389
4388: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4389: LD_VAR 0 3
4393: PUSH
4394: LD_INT 1
4396: ARRAY
4397: PPUSH
4398: CALL_OW 313
4402: PUSH
4403: LD_INT 6
4405: EQUAL
4406: IFFALSE 4426
// b := Delete ( b , 1 ) ;
4408: LD_ADDR_VAR 0 3
4412: PUSH
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: CALL_OW 3
4425: ST_TO_ADDR
// if b then
4426: LD_VAR 0 3
4430: IFFALSE 4452
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4432: LD_VAR 0 2
4436: PPUSH
4437: LD_VAR 0 3
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: PPUSH
4446: CALL_OW 52
4450: GO 4473
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4452: LD_VAR 0 2
4456: PPUSH
4457: LD_INT 61
4459: PPUSH
4460: LD_INT 89
4462: PPUSH
4463: LD_INT 8
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 50
// end ;
4473: GO 4279
4475: POP
4476: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4477: LD_INT 2
4479: PPUSH
4480: LD_INT 1
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: LD_INT 12
4488: PPUSH
4489: LD_INT 100
4491: PPUSH
4492: CALL 74558 0 5
// veh := CreateVehicle ;
4496: LD_ADDR_VAR 0 4
4500: PUSH
4501: CALL_OW 45
4505: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4506: LD_VAR 0 4
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4518: LD_VAR 0 4
4522: PPUSH
4523: LD_INT 49
4525: PPUSH
4526: LD_INT 88
4528: PPUSH
4529: LD_INT 0
4531: PPUSH
4532: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4536: LD_VAR 0 4
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: LD_INT 100
4546: PPUSH
4547: CALL_OW 290
// uc_side := 0 ;
4551: LD_ADDR_OWVAR 20
4555: PUSH
4556: LD_INT 0
4558: ST_TO_ADDR
// uc_nation := 0 ;
4559: LD_ADDR_OWVAR 21
4563: PUSH
4564: LD_INT 0
4566: ST_TO_ADDR
// for i := 1 to 3 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 3
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4612
// begin InitHc ;
4583: CALL_OW 19
// hc_class := class_apeman ;
4587: LD_ADDR_OWVAR 28
4591: PUSH
4592: LD_INT 12
4594: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4595: CALL_OW 44
4599: PPUSH
4600: LD_INT 13
4602: PPUSH
4603: LD_INT 0
4605: PPUSH
4606: CALL_OW 49
// end ;
4610: GO 4580
4612: POP
4613: POP
// end ; end_of_file
4614: LD_VAR 0 1
4618: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4619: LD_INT 0
4621: PPUSH
4622: PPUSH
4623: PPUSH
4624: PPUSH
4625: PPUSH
// side := 8 ;
4626: LD_ADDR_VAR 0 3
4630: PUSH
4631: LD_INT 8
4633: ST_TO_ADDR
// uc_side := side ;
4634: LD_ADDR_OWVAR 20
4638: PUSH
4639: LD_VAR 0 3
4643: ST_TO_ADDR
// uc_nation := 2 ;
4644: LD_ADDR_OWVAR 21
4648: PUSH
4649: LD_INT 2
4651: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4652: LD_ADDR_VAR 0 2
4656: PUSH
4657: LD_INT 22
4659: PUSH
4660: LD_VAR 0 3
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 21
4671: PUSH
4672: LD_INT 3
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 69
4687: PUSH
4688: FOR_IN
4689: IFFALSE 4705
// SetBLevel ( i , 10 ) ;
4691: LD_VAR 0 2
4695: PPUSH
4696: LD_INT 10
4698: PPUSH
4699: CALL_OW 241
4703: GO 4688
4705: POP
4706: POP
// if KurtStatus then
4707: LD_EXP 3
4711: IFFALSE 4734
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4713: LD_ADDR_EXP 64
4717: PUSH
4718: LD_STRING Kurt
4720: PPUSH
4721: LD_INT 0
4723: PPUSH
4724: LD_STRING 
4726: PPUSH
4727: CALL 69718 0 3
4731: ST_TO_ADDR
4732: GO 4756
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4734: LD_ADDR_EXP 64
4738: PUSH
4739: LD_STRING AltKurt
4741: PPUSH
4742: LD_EXP 1
4746: NOT
4747: PPUSH
4748: LD_STRING 
4750: PPUSH
4751: CALL 69718 0 3
4755: ST_TO_ADDR
// if not Kurt then
4756: LD_EXP 64
4760: NOT
4761: IFFALSE 4787
// begin InitHc ;
4763: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4767: LD_INT 1
4769: PPUSH
4770: LD_INT 10
4772: PPUSH
4773: CALL_OW 381
// Kurt := CreateHuman ;
4777: LD_ADDR_EXP 64
4781: PUSH
4782: CALL_OW 44
4786: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4787: LD_EXP 64
4791: PPUSH
4792: LD_INT 324
4794: PPUSH
4795: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4799: LD_ADDR_EXP 65
4803: PUSH
4804: LD_STRING Kozlov
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: LD_STRING 
4812: PPUSH
4813: CALL 69718 0 3
4817: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4818: LD_EXP 65
4822: PPUSH
4823: LD_INT 22
4825: PUSH
4826: LD_INT 8
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 23
4835: PUSH
4836: LD_INT 3
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_INT 30
4845: PUSH
4846: LD_INT 8
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: LIST
4857: PPUSH
4858: CALL_OW 69
4862: PUSH
4863: LD_INT 1
4865: ARRAY
4866: PPUSH
4867: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4871: LD_EXP 65
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 10
4881: PPUSH
4882: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4886: LD_EXP 65
4890: PPUSH
4891: LD_INT 4
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4901: LD_ADDR_VAR 0 5
4905: PUSH
4906: LD_INT 22
4908: PUSH
4909: LD_VAR 0 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 30
4920: PUSH
4921: LD_INT 32
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: LD_INT 58
4930: PUSH
4931: EMPTY
4932: LIST
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: PPUSH
4939: CALL_OW 69
4943: ST_TO_ADDR
// for i = 1 to 10 do
4944: LD_ADDR_VAR 0 2
4948: PUSH
4949: DOUBLE
4950: LD_INT 1
4952: DEC
4953: ST_TO_ADDR
4954: LD_INT 10
4956: PUSH
4957: FOR_TO
4958: IFFALSE 5030
// begin uc_nation := nation_nature ;
4960: LD_ADDR_OWVAR 21
4964: PUSH
4965: LD_INT 0
4967: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4968: LD_ADDR_OWVAR 28
4972: PUSH
4973: LD_INT 15
4975: ST_TO_ADDR
// hc_gallery :=  ;
4976: LD_ADDR_OWVAR 33
4980: PUSH
4981: LD_STRING 
4983: ST_TO_ADDR
// hc_name :=  ;
4984: LD_ADDR_OWVAR 26
4988: PUSH
4989: LD_STRING 
4991: ST_TO_ADDR
// un := CreateHuman ;
4992: LD_ADDR_VAR 0 4
4996: PUSH
4997: CALL_OW 44
5001: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5002: LD_VAR 0 4
5006: PPUSH
5007: LD_VAR 0 5
5011: PUSH
5012: LD_VAR 0 5
5016: PUSH
5017: LD_VAR 0 2
5021: MINUS
5022: ARRAY
5023: PPUSH
5024: CALL_OW 52
// end ;
5028: GO 4957
5030: POP
5031: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_STRING 12_kurt_squad
5039: PPUSH
5040: CALL_OW 31
5044: ST_TO_ADDR
// if tmp then
5045: LD_VAR 0 5
5049: IFFALSE 5083
// for i in tmp do
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_VAR 0 5
5060: PUSH
5061: FOR_IN
5062: IFFALSE 5081
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5064: LD_VAR 0 2
5068: PPUSH
5069: LD_INT 5
5071: PPUSH
5072: LD_INT 0
5074: PPUSH
5075: CALL_OW 49
5079: GO 5061
5081: POP
5082: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5083: LD_INT 324
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_STRING 
5091: PPUSH
5092: LD_INT 8
5094: PUSH
5095: LD_INT 9
5097: PUSH
5098: LD_INT 10
5100: PUSH
5101: LD_INT 10
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: PUSH
5110: LD_OWVAR 67
5114: ARRAY
5115: PPUSH
5116: LD_INT 3000
5118: PUSH
5119: LD_INT 500
5121: PUSH
5122: LD_INT 150
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: PPUSH
5130: LD_INT 16
5132: PUSH
5133: LD_INT 6
5135: PUSH
5136: LD_INT 6
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PPUSH
5148: CALL 78379 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5152: LD_ADDR_EXP 102
5156: PUSH
5157: LD_EXP 102
5161: PPUSH
5162: LD_INT 3
5164: PPUSH
5165: LD_INT 22
5167: PUSH
5168: LD_VAR 0 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 3
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 2
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: PUSH
5214: LD_EXP 64
5218: DIFF
5219: PPUSH
5220: CALL_OW 1
5224: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5225: LD_INT 1
5227: PPUSH
5228: LD_INT 7
5230: PPUSH
5231: CALL_OW 383
// hc_name := Ali Hadrach ;
5235: LD_ADDR_OWVAR 26
5239: PUSH
5240: LD_STRING Ali Hadrach
5242: ST_TO_ADDR
// hc_face_number := 31 ;
5243: LD_ADDR_OWVAR 34
5247: PUSH
5248: LD_INT 31
5250: ST_TO_ADDR
// Friend := CreateHuman ;
5251: LD_ADDR_EXP 66
5255: PUSH
5256: CALL_OW 44
5260: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5261: LD_INT 14
5263: PPUSH
5264: LD_INT 3
5266: PPUSH
5267: LD_INT 1
5269: PPUSH
5270: LD_INT 29
5272: PPUSH
5273: LD_INT 100
5275: PPUSH
5276: CALL 74558 0 5
// powellBomb := CreateVehicle ;
5280: LD_ADDR_EXP 67
5284: PUSH
5285: CALL_OW 45
5289: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5290: LD_EXP 67
5294: PPUSH
5295: LD_INT 90
5297: PPUSH
5298: LD_INT 51
5300: PPUSH
5301: LD_INT 0
5303: PPUSH
5304: CALL_OW 48
// end ;
5308: LD_VAR 0 1
5312: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5313: LD_INT 0
5315: PPUSH
5316: PPUSH
5317: PPUSH
// if IsLive ( kozlov_fac ) then
5318: LD_INT 332
5320: PPUSH
5321: CALL_OW 300
5325: IFFALSE 5329
// exit ;
5327: GO 5896
// ComExitBuilding ( Kozlov ) ;
5329: LD_EXP 65
5333: PPUSH
5334: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5338: LD_EXP 65
5342: PPUSH
5343: CALL_OW 257
5347: PUSH
5348: LD_INT 2
5350: NONEQUAL
5351: IFFALSE 5386
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5353: LD_EXP 65
5357: PPUSH
5358: LD_INT 324
5360: PPUSH
5361: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5365: LD_EXP 65
5369: PPUSH
5370: LD_INT 2
5372: PPUSH
5373: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5377: LD_EXP 65
5381: PPUSH
5382: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5386: LD_EXP 65
5390: PPUSH
5391: LD_INT 2
5393: PPUSH
5394: LD_INT 93
5396: PPUSH
5397: LD_INT 32
5399: PPUSH
5400: LD_INT 3
5402: PPUSH
5403: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5407: LD_INT 35
5409: PPUSH
5410: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5414: LD_INT 22
5416: PUSH
5417: LD_INT 8
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: PUSH
5424: LD_INT 30
5426: PUSH
5427: LD_INT 3
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PUSH
5434: LD_INT 23
5436: PUSH
5437: LD_INT 3
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 57
5446: PUSH
5447: EMPTY
5448: LIST
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: LIST
5454: LIST
5455: PPUSH
5456: CALL_OW 69
5460: IFFALSE 5407
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5462: LD_ADDR_VAR 0 2
5466: PUSH
5467: LD_INT 22
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 30
5479: PUSH
5480: LD_INT 3
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PUSH
5487: LD_INT 23
5489: PUSH
5490: LD_INT 3
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 57
5499: PUSH
5500: EMPTY
5501: LIST
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5518: LD_INT 22
5520: PUSH
5521: LD_INT 8
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: PUSH
5528: LD_INT 23
5530: PUSH
5531: LD_INT 3
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 30
5540: PUSH
5541: LD_INT 21
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: NOT
5558: IFFALSE 5636
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5560: LD_EXP 65
5564: PPUSH
5565: LD_INT 21
5567: PPUSH
5568: LD_INT 97
5570: PPUSH
5571: LD_INT 36
5573: PPUSH
5574: LD_INT 5
5576: PPUSH
5577: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5581: LD_INT 35
5583: PPUSH
5584: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5588: LD_INT 22
5590: PUSH
5591: LD_INT 8
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 23
5600: PUSH
5601: LD_INT 3
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 30
5610: PUSH
5611: LD_INT 21
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 57
5620: PUSH
5621: EMPTY
5622: LIST
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 69
5634: IFFALSE 5581
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5636: LD_INT 22
5638: PUSH
5639: LD_INT 8
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 23
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 30
5658: PUSH
5659: LD_INT 18
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: LIST
5670: PPUSH
5671: CALL_OW 69
5675: NOT
5676: IFFALSE 5754
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5678: LD_EXP 65
5682: PPUSH
5683: LD_INT 18
5685: PPUSH
5686: LD_INT 89
5688: PPUSH
5689: LD_INT 32
5691: PPUSH
5692: LD_INT 1
5694: PPUSH
5695: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5699: LD_INT 35
5701: PPUSH
5702: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5706: LD_INT 22
5708: PUSH
5709: LD_INT 8
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 23
5718: PUSH
5719: LD_INT 3
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 30
5728: PUSH
5729: LD_INT 18
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 57
5738: PUSH
5739: EMPTY
5740: LIST
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PPUSH
5748: CALL_OW 69
5752: IFFALSE 5699
// end ; lab := kozlov_lab ;
5754: LD_ADDR_VAR 0 3
5758: PUSH
5759: LD_INT 336
5761: ST_TO_ADDR
// if not lab then
5762: LD_VAR 0 3
5766: NOT
5767: IFFALSE 5771
// exit ;
5769: GO 5896
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5771: LD_EXP 65
5775: PPUSH
5776: LD_VAR 0 3
5780: PUSH
5781: LD_INT 1
5783: ARRAY
5784: PPUSH
5785: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5789: LD_EXP 65
5793: PPUSH
5794: LD_INT 4
5796: PPUSH
5797: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5801: LD_VAR 0 3
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PPUSH
5810: LD_INT 25
5812: PPUSH
5813: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5817: LD_INT 35
5819: PPUSH
5820: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5824: LD_INT 25
5826: PPUSH
5827: LD_INT 8
5829: PPUSH
5830: CALL_OW 321
5834: PUSH
5835: LD_INT 2
5837: EQUAL
5838: IFFALSE 5817
// ComExitBuilding ( Kozlov ) ;
5840: LD_EXP 65
5844: PPUSH
5845: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5849: LD_EXP 65
5853: PPUSH
5854: LD_VAR 0 2
5858: PPUSH
5859: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5863: LD_EXP 65
5867: PPUSH
5868: LD_INT 3
5870: PPUSH
5871: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5875: LD_VAR 0 2
5879: PPUSH
5880: LD_INT 23
5882: PPUSH
5883: LD_INT 3
5885: PPUSH
5886: LD_INT 1
5888: PPUSH
5889: LD_INT 48
5891: PPUSH
5892: CALL_OW 125
// end ;
5896: LD_VAR 0 1
5900: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5901: LD_EXP 22
5905: NOT
5906: PUSH
5907: LD_EXP 15
5911: PUSH
5912: LD_INT 6
5914: GREATEREQUAL
5915: AND
5916: IFFALSE 5997
5918: GO 5920
5920: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5921: LD_INT 3
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: CALL 63429 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5931: LD_INT 3
5933: PPUSH
5934: LD_INT 14
5936: PUSH
5937: LD_INT 1
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: LD_INT 28
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: PUSH
5952: LD_INT 14
5954: PUSH
5955: LD_INT 1
5957: PUSH
5958: LD_INT 1
5960: PUSH
5961: LD_INT 28
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: LIST
5968: LIST
5969: PUSH
5970: LD_INT 14
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: LD_INT 1
5978: PUSH
5979: LD_INT 28
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL 63292 0 2
// end ;
5997: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5998: LD_EXP 22
6002: NOT
6003: PUSH
6004: LD_EXP 15
6008: PUSH
6009: LD_INT 6
6011: GREATEREQUAL
6012: AND
6013: PUSH
6014: LD_INT 3
6016: PPUSH
6017: LD_INT 1
6019: PPUSH
6020: CALL 64710 0 2
6024: NOT
6025: AND
6026: IFFALSE 6979
6028: GO 6030
6030: DISABLE
6031: LD_INT 0
6033: PPUSH
6034: PPUSH
6035: PPUSH
6036: PPUSH
// begin enable ;
6037: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6038: LD_INT 22
6040: PUSH
6041: LD_INT 8
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 23
6050: PUSH
6051: LD_INT 2
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: PPUSH
6073: CALL_OW 69
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6979
// if Prob ( 40 ) then
6082: LD_INT 40
6084: PPUSH
6085: CALL_OW 13
6089: IFFALSE 6216
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6091: LD_INT 3
6093: PPUSH
6094: LD_INT 14
6096: PUSH
6097: LD_INT 1
6099: PUSH
6100: LD_INT 2
6102: PUSH
6103: LD_INT 28
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PUSH
6112: LD_INT 14
6114: PUSH
6115: LD_INT 1
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: LD_INT 28
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 14
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 14
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 28
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 14
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 28
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 14
6186: PUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 26
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL 63292 0 2
// end else
6214: GO 6423
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6216: LD_INT 3
6218: PPUSH
6219: LD_INT 14
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: LD_INT 2
6227: PUSH
6228: LD_INT 27
6230: PUSH
6231: LD_INT 26
6233: PUSH
6234: LD_INT 26
6236: PUSH
6237: LD_INT 28
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_OWVAR 67
6250: ARRAY
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 14
6260: PUSH
6261: LD_INT 1
6263: PUSH
6264: LD_INT 2
6266: PUSH
6267: LD_INT 27
6269: PUSH
6270: LD_INT 26
6272: PUSH
6273: LD_INT 26
6275: PUSH
6276: LD_INT 26
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: LD_OWVAR 67
6289: ARRAY
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 14
6299: PUSH
6300: LD_INT 1
6302: PUSH
6303: LD_INT 2
6305: PUSH
6306: LD_INT 26
6308: PUSH
6309: LD_INT 26
6311: PUSH
6312: LD_INT 29
6314: PUSH
6315: LD_INT 29
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: LD_OWVAR 67
6328: ARRAY
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 13
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 26
6347: PUSH
6348: LD_INT 29
6350: PUSH
6351: LD_INT 29
6353: PUSH
6354: LD_INT 29
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 13
6377: PUSH
6378: LD_INT 1
6380: PUSH
6381: LD_INT 2
6383: PUSH
6384: LD_INT 29
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PUSH
6393: LD_INT 14
6395: PUSH
6396: LD_INT 1
6398: PUSH
6399: LD_INT 2
6401: PUSH
6402: LD_INT 26
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: PPUSH
6419: CALL 63292 0 2
// end ; wait ( 2 2$00 ) ;
6423: LD_INT 4200
6425: PPUSH
6426: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 8
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 34
6460: PUSH
6461: LD_INT 31
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 3
6474: PUSH
6475: LD_INT 34
6477: PUSH
6478: LD_INT 32
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 3
6491: PUSH
6492: LD_INT 34
6494: PUSH
6495: LD_INT 88
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PPUSH
6513: CALL_OW 69
6517: PUSH
6518: LD_EXP 124
6522: PUSH
6523: LD_INT 3
6525: ARRAY
6526: DIFF
6527: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6528: LD_ADDR_EXP 121
6532: PUSH
6533: LD_EXP 121
6537: PPUSH
6538: LD_INT 3
6540: PPUSH
6541: LD_EXP 121
6545: PUSH
6546: LD_INT 3
6548: ARRAY
6549: PUSH
6550: LD_VAR 0 2
6554: DIFF
6555: PPUSH
6556: CALL_OW 1
6560: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6561: LD_ADDR_VAR 0 3
6565: PUSH
6566: LD_INT 0
6568: PPUSH
6569: LD_INT 2
6571: PPUSH
6572: CALL_OW 12
6576: ST_TO_ADDR
// if target then
6577: LD_VAR 0 3
6581: IFFALSE 6739
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_VAR 0 2
6592: PPUSH
6593: LD_INT 50
6595: PUSH
6596: EMPTY
6597: LIST
6598: PPUSH
6599: CALL_OW 72
6603: ST_TO_ADDR
// if not tmp then
6604: LD_VAR 0 2
6608: NOT
6609: IFFALSE 6613
// break ;
6611: GO 6737
// for i in tmp do
6613: LD_ADDR_VAR 0 1
6617: PUSH
6618: LD_VAR 0 2
6622: PUSH
6623: FOR_IN
6624: IFFALSE 6664
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6626: LD_VAR 0 1
6630: PPUSH
6631: LD_INT 89
6633: PPUSH
6634: LD_INT 71
6636: PPUSH
6637: CALL_OW 297
6641: PUSH
6642: LD_INT 9
6644: GREATER
6645: IFFALSE 6662
// ComMoveXY ( i , 89 , 71 ) ;
6647: LD_VAR 0 1
6651: PPUSH
6652: LD_INT 89
6654: PPUSH
6655: LD_INT 71
6657: PPUSH
6658: CALL_OW 111
6662: GO 6623
6664: POP
6665: POP
// wait ( 0 0$1 ) ;
6666: LD_INT 35
6668: PPUSH
6669: CALL_OW 67
// p := Inc ( p ) ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: LD_VAR 0 4
6682: PPUSH
6683: CALL 108770 0 1
6687: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6688: LD_VAR 0 2
6692: PPUSH
6693: LD_INT 92
6695: PUSH
6696: LD_INT 89
6698: PUSH
6699: LD_INT 71
6701: PUSH
6702: LD_INT 9
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: PPUSH
6711: CALL_OW 72
6715: PUSH
6716: LD_VAR 0 2
6720: PUSH
6721: LD_INT 1
6723: MINUS
6724: GREATEREQUAL
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 30
6733: GREATER
6734: OR
6735: IFFALSE 6583
// end else
6737: GO 6893
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6739: LD_ADDR_VAR 0 2
6743: PUSH
6744: LD_VAR 0 2
6748: PPUSH
6749: LD_INT 50
6751: PUSH
6752: EMPTY
6753: LIST
6754: PPUSH
6755: CALL_OW 72
6759: ST_TO_ADDR
// if not tmp then
6760: LD_VAR 0 2
6764: NOT
6765: IFFALSE 6769
// break ;
6767: GO 6893
// for i in tmp do
6769: LD_ADDR_VAR 0 1
6773: PUSH
6774: LD_VAR 0 2
6778: PUSH
6779: FOR_IN
6780: IFFALSE 6820
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6782: LD_VAR 0 1
6786: PPUSH
6787: LD_INT 125
6789: PPUSH
6790: LD_INT 129
6792: PPUSH
6793: CALL_OW 297
6797: PUSH
6798: LD_INT 9
6800: GREATER
6801: IFFALSE 6818
// ComMoveXY ( i , 125 , 129 ) ;
6803: LD_VAR 0 1
6807: PPUSH
6808: LD_INT 125
6810: PPUSH
6811: LD_INT 129
6813: PPUSH
6814: CALL_OW 111
6818: GO 6779
6820: POP
6821: POP
// wait ( 0 0$1 ) ;
6822: LD_INT 35
6824: PPUSH
6825: CALL_OW 67
// p := Inc ( p ) ;
6829: LD_ADDR_VAR 0 4
6833: PUSH
6834: LD_VAR 0 4
6838: PPUSH
6839: CALL 108770 0 1
6843: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 92
6851: PUSH
6852: LD_INT 125
6854: PUSH
6855: LD_INT 129
6857: PUSH
6858: LD_INT 9
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: PPUSH
6867: CALL_OW 72
6871: PUSH
6872: LD_VAR 0 2
6876: PUSH
6877: LD_INT 1
6879: MINUS
6880: GREATEREQUAL
6881: PUSH
6882: LD_VAR 0 4
6886: PUSH
6887: LD_INT 30
6889: GREATER
6890: OR
6891: IFFALSE 6739
// end ; repeat wait ( 0 0$1 ) ;
6893: LD_INT 35
6895: PPUSH
6896: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6900: LD_ADDR_VAR 0 2
6904: PUSH
6905: LD_VAR 0 2
6909: PPUSH
6910: LD_INT 50
6912: PUSH
6913: EMPTY
6914: LIST
6915: PPUSH
6916: CALL_OW 72
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 1
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6970
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6934: LD_VAR 0 1
6938: PPUSH
6939: LD_INT 81
6941: PUSH
6942: LD_INT 8
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PPUSH
6949: CALL_OW 69
6953: PPUSH
6954: LD_VAR 0 1
6958: PPUSH
6959: CALL_OW 74
6963: PPUSH
6964: CALL_OW 115
6968: GO 6931
6970: POP
6971: POP
// until not tmp ;
6972: LD_VAR 0 2
6976: NOT
6977: IFFALSE 6893
// end ;
6979: PPOPN 4
6981: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6982: LD_EXP 22
6986: NOT
6987: PUSH
6988: LD_EXP 15
6992: PUSH
6993: LD_INT 6
6995: GREATEREQUAL
6996: AND
6997: PUSH
6998: LD_OWVAR 67
7002: PUSH
7003: LD_INT 1
7005: GREATER
7006: AND
7007: IFFALSE 7540
7009: GO 7011
7011: DISABLE
7012: LD_INT 0
7014: PPUSH
7015: PPUSH
7016: PPUSH
// begin enable ;
7017: ENABLE
// tmp := [ ] ;
7018: LD_ADDR_VAR 0 3
7022: PUSH
7023: EMPTY
7024: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7025: LD_ADDR_VAR 0 1
7029: PUSH
7030: DOUBLE
7031: LD_INT 1
7033: DEC
7034: ST_TO_ADDR
7035: LD_INT 4
7037: PUSH
7038: LD_INT 6
7040: PUSH
7041: LD_INT 7
7043: PUSH
7044: LD_INT 8
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: PUSH
7053: LD_OWVAR 67
7057: ARRAY
7058: PUSH
7059: FOR_TO
7060: IFFALSE 7220
// begin uc_side := 8 ;
7062: LD_ADDR_OWVAR 20
7066: PUSH
7067: LD_INT 8
7069: ST_TO_ADDR
// uc_nation := 2 ;
7070: LD_ADDR_OWVAR 21
7074: PUSH
7075: LD_INT 2
7077: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7078: LD_INT 13
7080: PUSH
7081: LD_INT 14
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 1
7090: PPUSH
7091: LD_INT 2
7093: PPUSH
7094: CALL_OW 12
7098: ARRAY
7099: PPUSH
7100: LD_INT 1
7102: PPUSH
7103: LD_INT 5
7105: PPUSH
7106: LD_INT 27
7108: PUSH
7109: LD_INT 28
7111: PUSH
7112: LD_INT 26
7114: PUSH
7115: LD_INT 25
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: PUSH
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 4
7129: PPUSH
7130: CALL_OW 12
7134: ARRAY
7135: PPUSH
7136: LD_INT 88
7138: PPUSH
7139: CALL 74558 0 5
// un := CreateVehicle ;
7143: LD_ADDR_VAR 0 2
7147: PUSH
7148: CALL_OW 45
7152: ST_TO_ADDR
// tmp := tmp ^ un ;
7153: LD_ADDR_VAR 0 3
7157: PUSH
7158: LD_VAR 0 3
7162: PUSH
7163: LD_VAR 0 2
7167: ADD
7168: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7181: LD_VAR 0 2
7185: PPUSH
7186: LD_INT 30
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7196: LD_VAR 0 2
7200: PPUSH
7201: LD_INT 16
7203: PPUSH
7204: LD_INT 11
7206: PPUSH
7207: CALL_OW 111
// wait ( 0 0$2 ) ;
7211: LD_INT 70
7213: PPUSH
7214: CALL_OW 67
// end ;
7218: GO 7059
7220: POP
7221: POP
// for i = 1 to Difficulty do
7222: LD_ADDR_VAR 0 1
7226: PUSH
7227: DOUBLE
7228: LD_INT 1
7230: DEC
7231: ST_TO_ADDR
7232: LD_OWVAR 67
7236: PUSH
7237: FOR_TO
7238: IFFALSE 7367
// begin uc_side := 8 ;
7240: LD_ADDR_OWVAR 20
7244: PUSH
7245: LD_INT 8
7247: ST_TO_ADDR
// uc_nation := 2 ;
7248: LD_ADDR_OWVAR 21
7252: PUSH
7253: LD_INT 2
7255: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7256: LD_INT 0
7258: PPUSH
7259: LD_INT 8
7261: PPUSH
7262: LD_INT 8
7264: PUSH
7265: LD_INT 8
7267: PUSH
7268: LD_INT 9
7270: PUSH
7271: LD_INT 10
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: PUSH
7280: LD_OWVAR 67
7284: ARRAY
7285: PPUSH
7286: CALL_OW 380
// un := CreateHuman ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: CALL_OW 44
7299: ST_TO_ADDR
// tmp := tmp ^ un ;
7300: LD_ADDR_VAR 0 3
7304: PUSH
7305: LD_VAR 0 3
7309: PUSH
7310: LD_VAR 0 2
7314: ADD
7315: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_INT 3
7323: PPUSH
7324: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7328: LD_VAR 0 2
7332: PPUSH
7333: LD_INT 30
7335: PPUSH
7336: LD_INT 0
7338: PPUSH
7339: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7343: LD_VAR 0 2
7347: PPUSH
7348: LD_INT 16
7350: PPUSH
7351: LD_INT 11
7353: PPUSH
7354: CALL_OW 111
// wait ( 0 0$2 ) ;
7358: LD_INT 70
7360: PPUSH
7361: CALL_OW 67
// end ;
7365: GO 7237
7367: POP
7368: POP
// repeat wait ( 0 0$1 ) ;
7369: LD_INT 35
7371: PPUSH
7372: CALL_OW 67
// if legionDestroyed then
7376: LD_EXP 22
7380: IFFALSE 7384
// exit ;
7382: GO 7540
// for i in tmp do
7384: LD_ADDR_VAR 0 1
7388: PUSH
7389: LD_VAR 0 3
7393: PUSH
7394: FOR_IN
7395: IFFALSE 7531
// begin if GetLives ( i ) > 250 then
7397: LD_VAR 0 1
7401: PPUSH
7402: CALL_OW 256
7406: PUSH
7407: LD_INT 250
7409: GREATER
7410: IFFALSE 7502
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7412: LD_INT 81
7414: PUSH
7415: LD_INT 8
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: LD_INT 91
7424: PUSH
7425: LD_VAR 0 1
7429: PUSH
7430: LD_INT 10
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: PPUSH
7442: CALL_OW 69
7446: NOT
7447: IFFALSE 7466
// ComAgressiveMove ( i , 67 , 110 ) else
7449: LD_VAR 0 1
7453: PPUSH
7454: LD_INT 67
7456: PPUSH
7457: LD_INT 110
7459: PPUSH
7460: CALL_OW 114
7464: GO 7500
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7466: LD_VAR 0 1
7470: PPUSH
7471: LD_INT 81
7473: PUSH
7474: LD_INT 8
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PPUSH
7481: CALL_OW 69
7485: PPUSH
7486: LD_VAR 0 1
7490: PPUSH
7491: CALL_OW 74
7495: PPUSH
7496: CALL_OW 115
// end else
7500: GO 7529
// if IsDead ( i ) then
7502: LD_VAR 0 1
7506: PPUSH
7507: CALL_OW 301
7511: IFFALSE 7529
// tmp := tmp diff i ;
7513: LD_ADDR_VAR 0 3
7517: PUSH
7518: LD_VAR 0 3
7522: PUSH
7523: LD_VAR 0 1
7527: DIFF
7528: ST_TO_ADDR
// end ;
7529: GO 7394
7531: POP
7532: POP
// until not tmp ;
7533: LD_VAR 0 3
7537: NOT
7538: IFFALSE 7369
// end ; end_of_file
7540: PPOPN 3
7542: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7543: LD_INT 0
7545: PPUSH
7546: PPUSH
7547: PPUSH
7548: PPUSH
7549: PPUSH
7550: PPUSH
7551: PPUSH
7552: PPUSH
7553: PPUSH
7554: PPUSH
// side := 3 ;
7555: LD_ADDR_VAR 0 6
7559: PUSH
7560: LD_INT 3
7562: ST_TO_ADDR
// uc_side := side ;
7563: LD_ADDR_OWVAR 20
7567: PUSH
7568: LD_VAR 0 6
7572: ST_TO_ADDR
// uc_nation := 3 ;
7573: LD_ADDR_OWVAR 21
7577: PUSH
7578: LD_INT 3
7580: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7581: LD_ADDR_VAR 0 2
7585: PUSH
7586: LD_INT 22
7588: PUSH
7589: LD_VAR 0 6
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 21
7600: PUSH
7601: LD_INT 3
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PPUSH
7612: CALL_OW 69
7616: PUSH
7617: FOR_IN
7618: IFFALSE 7634
// SetBLevel ( i , 10 ) ;
7620: LD_VAR 0 2
7624: PPUSH
7625: LD_INT 10
7627: PPUSH
7628: CALL_OW 241
7632: GO 7617
7634: POP
7635: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7636: LD_ADDR_VAR 0 10
7640: PUSH
7641: LD_INT 22
7643: PUSH
7644: LD_VAR 0 6
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 30
7655: PUSH
7656: LD_INT 34
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: ST_TO_ADDR
// if teleport then
7672: LD_VAR 0 10
7676: IFFALSE 7697
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7678: LD_VAR 0 10
7682: PUSH
7683: LD_INT 1
7685: ARRAY
7686: PPUSH
7687: LD_INT 123
7689: PPUSH
7690: LD_INT 122
7692: PPUSH
7693: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7697: LD_ADDR_EXP 68
7701: PUSH
7702: LD_STRING Platonov
7704: PPUSH
7705: CALL_OW 25
7709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7710: LD_ADDR_EXP 69
7714: PUSH
7715: LD_STRING Kovalyuk
7717: PPUSH
7718: CALL_OW 25
7722: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7723: LD_ADDR_EXP 71
7727: PUSH
7728: LD_STRING Yakotich
7730: PPUSH
7731: LD_EXP 1
7735: NOT
7736: PPUSH
7737: LD_STRING 09_
7739: PPUSH
7740: CALL 69718 0 3
7744: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7745: LD_ADDR_EXP 70
7749: PUSH
7750: LD_STRING Bystrov
7752: PPUSH
7753: CALL_OW 25
7757: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7758: LD_ADDR_EXP 72
7762: PUSH
7763: LD_STRING Gleb
7765: PPUSH
7766: CALL_OW 25
7770: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7771: LD_STRING 03_Cornel
7773: PPUSH
7774: CALL_OW 28
7778: IFFALSE 7826
// begin Bierezov := NewCharacter ( Mikhail ) ;
7780: LD_ADDR_EXP 73
7784: PUSH
7785: LD_STRING Mikhail
7787: PPUSH
7788: CALL_OW 25
7792: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7793: LD_EXP 73
7797: PPUSH
7798: LD_INT 197
7800: PPUSH
7801: LD_INT 111
7803: PPUSH
7804: LD_INT 9
7806: PPUSH
7807: LD_INT 0
7809: PPUSH
7810: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7814: LD_EXP 73
7818: PPUSH
7819: LD_INT 3
7821: PPUSH
7822: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7826: LD_EXP 68
7830: PPUSH
7831: LD_INT 126
7833: PPUSH
7834: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7838: LD_EXP 69
7842: PPUSH
7843: LD_INT 134
7845: PPUSH
7846: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7850: LD_EXP 71
7854: PPUSH
7855: LD_INT 197
7857: PPUSH
7858: LD_INT 111
7860: PPUSH
7861: LD_INT 9
7863: PPUSH
7864: LD_INT 0
7866: PPUSH
7867: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7871: LD_EXP 70
7875: PPUSH
7876: LD_INT 197
7878: PPUSH
7879: LD_INT 111
7881: PPUSH
7882: LD_INT 9
7884: PPUSH
7885: LD_INT 0
7887: PPUSH
7888: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7892: LD_EXP 72
7896: PPUSH
7897: LD_INT 197
7899: PPUSH
7900: LD_INT 111
7902: PPUSH
7903: LD_INT 9
7905: PPUSH
7906: LD_INT 0
7908: PPUSH
7909: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7913: LD_ADDR_VAR 0 5
7917: PUSH
7918: LD_INT 126
7920: PPUSH
7921: LD_INT 4
7923: PPUSH
7924: LD_STRING zhukov
7926: PPUSH
7927: LD_INT 9
7929: PUSH
7930: LD_INT 10
7932: PUSH
7933: LD_INT 10
7935: PUSH
7936: LD_INT 10
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_OWVAR 67
7949: ARRAY
7950: PPUSH
7951: LD_INT 90000
7953: PUSH
7954: LD_INT 1000
7956: PUSH
7957: LD_INT 300
7959: PUSH
7960: EMPTY
7961: LIST
7962: LIST
7963: LIST
7964: PPUSH
7965: LD_INT 18
7967: PUSH
7968: LD_INT 8
7970: PUSH
7971: LD_INT 12
7973: PUSH
7974: LD_INT 6
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: LIST
7981: LIST
7982: PPUSH
7983: CALL 78379 0 6
7987: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7988: LD_ADDR_EXP 102
7992: PUSH
7993: LD_EXP 102
7997: PPUSH
7998: LD_INT 2
8000: PPUSH
8001: LD_VAR 0 5
8005: PUSH
8006: LD_EXP 71
8010: PUSH
8011: LD_EXP 70
8015: PUSH
8016: LD_EXP 72
8020: PUSH
8021: LD_EXP 73
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: UNION
8032: PPUSH
8033: CALL_OW 1
8037: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8038: LD_ADDR_VAR 0 4
8042: PUSH
8043: LD_INT 267
8045: PPUSH
8046: CALL_OW 274
8050: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8051: LD_VAR 0 4
8055: PPUSH
8056: LD_INT 1
8058: PPUSH
8059: LD_INT 5000
8061: PPUSH
8062: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8066: LD_VAR 0 4
8070: PPUSH
8071: LD_INT 2
8073: PPUSH
8074: LD_INT 200
8076: PPUSH
8077: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8081: LD_VAR 0 4
8085: PPUSH
8086: LD_INT 3
8088: PPUSH
8089: LD_INT 200
8091: PPUSH
8092: CALL_OW 277
// for i := 1 to 6 do
8096: LD_ADDR_VAR 0 2
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 6
8108: PUSH
8109: FOR_TO
8110: IFFALSE 8193
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8112: LD_INT 0
8114: PPUSH
8115: LD_INT 8
8117: PUSH
8118: LD_INT 9
8120: PUSH
8121: LD_INT 10
8123: PUSH
8124: LD_INT 10
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_OWVAR 67
8137: ARRAY
8138: PPUSH
8139: CALL_OW 381
// un := CreateHuman ;
8143: LD_ADDR_VAR 0 8
8147: PUSH
8148: CALL_OW 44
8152: ST_TO_ADDR
// if i mod 2 = 0 then
8153: LD_VAR 0 2
8157: PUSH
8158: LD_INT 2
8160: MOD
8161: PUSH
8162: LD_INT 0
8164: EQUAL
8165: IFFALSE 8179
// SetClass ( un , class_bazooker ) ;
8167: LD_VAR 0 8
8171: PPUSH
8172: LD_INT 9
8174: PPUSH
8175: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8179: LD_VAR 0 8
8183: PPUSH
8184: LD_INT 460
8186: PPUSH
8187: CALL_OW 52
// end ;
8191: GO 8109
8193: POP
8194: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8195: LD_INT 21
8197: PPUSH
8198: LD_INT 3
8200: PPUSH
8201: LD_INT 3
8203: PPUSH
8204: LD_INT 52
8206: PPUSH
8207: LD_INT 100
8209: PPUSH
8210: CALL 74558 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8214: CALL_OW 45
8218: PPUSH
8219: LD_INT 259
8221: PPUSH
8222: LD_INT 145
8224: PPUSH
8225: LD_INT 3
8227: PPUSH
8228: LD_INT 0
8230: PPUSH
8231: CALL 109549 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8235: CALL_OW 45
8239: PPUSH
8240: LD_INT 245
8242: PPUSH
8243: LD_INT 139
8245: PPUSH
8246: LD_INT 3
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL 109549 0 5
// behemoths := [ ] ;
8256: LD_ADDR_EXP 76
8260: PUSH
8261: EMPTY
8262: ST_TO_ADDR
// behemothBuilders := [ ] ;
8263: LD_ADDR_EXP 77
8267: PUSH
8268: EMPTY
8269: ST_TO_ADDR
// if Kovalyuk then
8270: LD_EXP 69
8274: IFFALSE 8296
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8276: LD_ADDR_EXP 77
8280: PUSH
8281: LD_EXP 77
8285: PPUSH
8286: LD_EXP 69
8290: PPUSH
8291: CALL 107409 0 2
8295: ST_TO_ADDR
// end ;
8296: LD_VAR 0 1
8300: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8301: LD_INT 0
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8308: LD_ADDR_VAR 0 4
8312: PUSH
8313: LD_INT 221
8315: PUSH
8316: LD_INT 154
8318: PUSH
8319: EMPTY
8320: LIST
8321: LIST
8322: PUSH
8323: LD_INT 223
8325: PUSH
8326: LD_INT 149
8328: PUSH
8329: EMPTY
8330: LIST
8331: LIST
8332: PUSH
8333: LD_INT 228
8335: PUSH
8336: LD_INT 147
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 232
8345: PUSH
8346: LD_INT 155
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: LIST
8357: LIST
8358: ST_TO_ADDR
// if not behemothBuilders then
8359: LD_EXP 77
8363: NOT
8364: IFFALSE 8368
// exit ;
8366: GO 8499
// j := 1 ;
8368: LD_ADDR_VAR 0 3
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// for i in behemothBuilders do
8376: LD_ADDR_VAR 0 2
8380: PUSH
8381: LD_EXP 77
8385: PUSH
8386: FOR_IN
8387: IFFALSE 8497
// begin if GetClass ( i ) <> class_mechanic then
8389: LD_VAR 0 2
8393: PPUSH
8394: CALL_OW 257
8398: PUSH
8399: LD_INT 3
8401: NONEQUAL
8402: IFFALSE 8416
// SetClass ( i , class_mechanic ) ;
8404: LD_VAR 0 2
8408: PPUSH
8409: LD_INT 3
8411: PPUSH
8412: CALL_OW 336
// if IsInUnit ( i ) then
8416: LD_VAR 0 2
8420: PPUSH
8421: CALL_OW 310
8425: IFFALSE 8436
// ComExitBuilding ( i ) ;
8427: LD_VAR 0 2
8431: PPUSH
8432: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8436: LD_VAR 0 2
8440: PPUSH
8441: LD_INT 37
8443: PPUSH
8444: LD_VAR 0 4
8448: PUSH
8449: LD_VAR 0 3
8453: ARRAY
8454: PUSH
8455: LD_INT 1
8457: ARRAY
8458: PPUSH
8459: LD_VAR 0 4
8463: PUSH
8464: LD_VAR 0 3
8468: ARRAY
8469: PUSH
8470: LD_INT 2
8472: ARRAY
8473: PPUSH
8474: LD_INT 0
8476: PPUSH
8477: CALL_OW 230
// j := j + 1 ;
8481: LD_ADDR_VAR 0 3
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 1
8493: PLUS
8494: ST_TO_ADDR
// end ;
8495: GO 8386
8497: POP
8498: POP
// end ;
8499: LD_VAR 0 1
8503: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8504: LD_INT 24
8506: PPUSH
8507: LD_INT 30
8509: PUSH
8510: LD_INT 37
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PPUSH
8517: CALL_OW 70
8521: IFFALSE 8534
8523: GO 8525
8525: DISABLE
// behemothUnderConstruct := true ;
8526: LD_ADDR_EXP 26
8530: PUSH
8531: LD_INT 1
8533: ST_TO_ADDR
8534: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8535: LD_INT 3
8537: PPUSH
8538: CALL 107470 0 1
8542: PUSH
8543: LD_INT 22
8545: PUSH
8546: LD_INT 3
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: PUSH
8553: LD_INT 30
8555: PUSH
8556: LD_INT 37
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: EMPTY
8564: LIST
8565: LIST
8566: PPUSH
8567: CALL_OW 69
8571: NOT
8572: AND
8573: IFFALSE 8759
8575: GO 8577
8577: DISABLE
8578: LD_INT 0
8580: PPUSH
8581: PPUSH
// begin enable ;
8582: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8583: LD_ADDR_VAR 0 2
8587: PUSH
8588: LD_INT 3
8590: PPUSH
8591: CALL 107470 0 1
8595: ST_TO_ADDR
// for i in tmp do
8596: LD_ADDR_VAR 0 1
8600: PUSH
8601: LD_VAR 0 2
8605: PUSH
8606: FOR_IN
8607: IFFALSE 8757
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8609: LD_VAR 0 1
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: CALL_OW 308
8621: PUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 110
8631: PUSH
8632: LD_INT 2
8634: EQUAL
8635: NOT
8636: AND
8637: IFFALSE 8651
// SetTag ( i , 2 ) ;
8639: LD_VAR 0 1
8643: PPUSH
8644: LD_INT 2
8646: PPUSH
8647: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8651: LD_INT 81
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 91
8663: PUSH
8664: LD_VAR 0 1
8668: PUSH
8669: LD_INT 12
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: LIST
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PPUSH
8681: CALL_OW 69
8685: NOT
8686: PUSH
8687: LD_VAR 0 1
8691: PPUSH
8692: CALL_OW 110
8696: PUSH
8697: LD_INT 2
8699: EQUAL
8700: NOT
8701: AND
8702: IFFALSE 8721
// ComAgressiveMove ( i , 64 , 93 ) else
8704: LD_VAR 0 1
8708: PPUSH
8709: LD_INT 64
8711: PPUSH
8712: LD_INT 93
8714: PPUSH
8715: CALL_OW 114
8719: GO 8755
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8721: LD_VAR 0 1
8725: PPUSH
8726: LD_INT 81
8728: PUSH
8729: LD_INT 3
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PPUSH
8736: CALL_OW 69
8740: PPUSH
8741: LD_VAR 0 1
8745: PPUSH
8746: CALL_OW 74
8750: PPUSH
8751: CALL_OW 115
// end ;
8755: GO 8606
8757: POP
8758: POP
// end ;
8759: PPOPN 2
8761: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8762: LD_INT 0
8764: PPUSH
8765: PPUSH
8766: PPUSH
// result := [ ] ;
8767: LD_ADDR_VAR 0 2
8771: PUSH
8772: EMPTY
8773: ST_TO_ADDR
// uc_side := 6 ;
8774: LD_ADDR_OWVAR 20
8778: PUSH
8779: LD_INT 6
8781: ST_TO_ADDR
// uc_nation := 3 ;
8782: LD_ADDR_OWVAR 21
8786: PUSH
8787: LD_INT 3
8789: ST_TO_ADDR
// case strength of 1 :
8790: LD_VAR 0 1
8794: PUSH
8795: LD_INT 1
8797: DOUBLE
8798: EQUAL
8799: IFTRUE 8803
8801: GO 8945
8803: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_INT 4
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 6
8822: PUSH
8823: LD_INT 7
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_OWVAR 67
8836: ARRAY
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8941
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8841: LD_INT 22
8843: PUSH
8844: LD_INT 24
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_VAR 0 3
8855: PUSH
8856: LD_INT 2
8858: MOD
8859: PUSH
8860: LD_INT 1
8862: PLUS
8863: ARRAY
8864: PPUSH
8865: LD_INT 1
8867: PUSH
8868: LD_INT 3
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 2
8880: PPUSH
8881: CALL_OW 12
8885: ARRAY
8886: PPUSH
8887: LD_INT 3
8889: PPUSH
8890: LD_INT 43
8892: PUSH
8893: LD_INT 44
8895: PUSH
8896: LD_INT 45
8898: PUSH
8899: EMPTY
8900: LIST
8901: LIST
8902: LIST
8903: PUSH
8904: LD_INT 1
8906: PPUSH
8907: LD_INT 3
8909: PPUSH
8910: CALL_OW 12
8914: ARRAY
8915: PPUSH
8916: LD_INT 80
8918: PPUSH
8919: CALL 74558 0 5
// result := result union CreateVehicle ;
8923: LD_ADDR_VAR 0 2
8927: PUSH
8928: LD_VAR 0 2
8932: PUSH
8933: CALL_OW 45
8937: UNION
8938: ST_TO_ADDR
// end ;
8939: GO 8838
8941: POP
8942: POP
// end ; 2 :
8943: GO 9940
8945: LD_INT 2
8947: DOUBLE
8948: EQUAL
8949: IFTRUE 8953
8951: GO 9121
8953: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8954: LD_ADDR_VAR 0 3
8958: PUSH
8959: DOUBLE
8960: LD_INT 1
8962: DEC
8963: ST_TO_ADDR
8964: LD_INT 5
8966: PUSH
8967: LD_INT 6
8969: PUSH
8970: LD_INT 7
8972: PUSH
8973: LD_INT 8
8975: PUSH
8976: EMPTY
8977: LIST
8978: LIST
8979: LIST
8980: LIST
8981: PUSH
8982: LD_OWVAR 67
8986: ARRAY
8987: PUSH
8988: FOR_TO
8989: IFFALSE 9117
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8991: LD_INT 22
8993: PUSH
8994: LD_INT 24
8996: PUSH
8997: LD_INT 24
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: LIST
9004: PUSH
9005: LD_VAR 0 3
9009: PUSH
9010: LD_INT 3
9012: MOD
9013: PUSH
9014: LD_INT 1
9016: PLUS
9017: ARRAY
9018: PPUSH
9019: LD_INT 1
9021: PUSH
9022: LD_INT 3
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: PUSH
9029: LD_INT 1
9031: PPUSH
9032: LD_INT 2
9034: PPUSH
9035: CALL_OW 12
9039: ARRAY
9040: PPUSH
9041: LD_INT 3
9043: PPUSH
9044: LD_INT 43
9046: PUSH
9047: LD_INT 44
9049: PUSH
9050: LD_INT 45
9052: PUSH
9053: LD_INT 44
9055: PUSH
9056: LD_INT 46
9058: PUSH
9059: LD_INT 46
9061: PUSH
9062: LD_INT 49
9064: PUSH
9065: LD_INT 49
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: PUSH
9078: LD_VAR 0 3
9082: PUSH
9083: LD_INT 8
9085: MOD
9086: PUSH
9087: LD_INT 1
9089: PLUS
9090: ARRAY
9091: PPUSH
9092: LD_INT 80
9094: PPUSH
9095: CALL 74558 0 5
// result := result union CreateVehicle ;
9099: LD_ADDR_VAR 0 2
9103: PUSH
9104: LD_VAR 0 2
9108: PUSH
9109: CALL_OW 45
9113: UNION
9114: ST_TO_ADDR
// end ;
9115: GO 8988
9117: POP
9118: POP
// end ; 3 :
9119: GO 9940
9121: LD_INT 3
9123: DOUBLE
9124: EQUAL
9125: IFTRUE 9129
9127: GO 9301
9129: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9130: LD_ADDR_VAR 0 3
9134: PUSH
9135: DOUBLE
9136: LD_INT 1
9138: DEC
9139: ST_TO_ADDR
9140: LD_INT 6
9142: PUSH
9143: LD_INT 7
9145: PUSH
9146: LD_INT 8
9148: PUSH
9149: LD_INT 9
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: PUSH
9158: LD_OWVAR 67
9162: ARRAY
9163: PUSH
9164: FOR_TO
9165: IFFALSE 9297
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9167: LD_INT 22
9169: PUSH
9170: LD_INT 24
9172: PUSH
9173: LD_INT 24
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: LIST
9180: PUSH
9181: LD_VAR 0 3
9185: PUSH
9186: LD_INT 3
9188: MOD
9189: PUSH
9190: LD_INT 1
9192: PLUS
9193: ARRAY
9194: PPUSH
9195: LD_INT 1
9197: PUSH
9198: LD_INT 3
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: PUSH
9205: LD_INT 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: CALL_OW 12
9215: ARRAY
9216: PPUSH
9217: LD_INT 3
9219: PPUSH
9220: LD_INT 43
9222: PUSH
9223: LD_INT 47
9225: PUSH
9226: LD_INT 45
9228: PUSH
9229: LD_INT 45
9231: PUSH
9232: LD_INT 46
9234: PUSH
9235: LD_INT 46
9237: PUSH
9238: LD_INT 49
9240: PUSH
9241: LD_INT 49
9243: PUSH
9244: LD_INT 49
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: LIST
9256: LIST
9257: PUSH
9258: LD_VAR 0 3
9262: PUSH
9263: LD_INT 9
9265: MOD
9266: PUSH
9267: LD_INT 1
9269: PLUS
9270: ARRAY
9271: PPUSH
9272: LD_INT 80
9274: PPUSH
9275: CALL 74558 0 5
// result := result union CreateVehicle ;
9279: LD_ADDR_VAR 0 2
9283: PUSH
9284: LD_VAR 0 2
9288: PUSH
9289: CALL_OW 45
9293: UNION
9294: ST_TO_ADDR
// end ;
9295: GO 9164
9297: POP
9298: POP
// end ; 4 :
9299: GO 9940
9301: LD_INT 4
9303: DOUBLE
9304: EQUAL
9305: IFTRUE 9309
9307: GO 9939
9309: POP
// begin uc_nation := 3 ;
9310: LD_ADDR_OWVAR 21
9314: PUSH
9315: LD_INT 3
9317: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9318: LD_ADDR_VAR 0 3
9322: PUSH
9323: DOUBLE
9324: LD_INT 1
9326: DEC
9327: ST_TO_ADDR
9328: LD_INT 6
9330: PUSH
9331: LD_INT 8
9333: PUSH
9334: LD_INT 9
9336: PUSH
9337: LD_INT 10
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: PUSH
9346: LD_OWVAR 67
9350: ARRAY
9351: PUSH
9352: FOR_TO
9353: IFFALSE 9485
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9355: LD_INT 22
9357: PUSH
9358: LD_INT 24
9360: PUSH
9361: LD_INT 24
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: LIST
9368: PUSH
9369: LD_VAR 0 3
9373: PUSH
9374: LD_INT 3
9376: MOD
9377: PUSH
9378: LD_INT 1
9380: PLUS
9381: ARRAY
9382: PPUSH
9383: LD_INT 1
9385: PUSH
9386: LD_INT 3
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: PUSH
9393: LD_INT 1
9395: PPUSH
9396: LD_INT 2
9398: PPUSH
9399: CALL_OW 12
9403: ARRAY
9404: PPUSH
9405: LD_INT 3
9407: PPUSH
9408: LD_INT 45
9410: PUSH
9411: LD_INT 47
9413: PUSH
9414: LD_INT 47
9416: PUSH
9417: LD_INT 45
9419: PUSH
9420: LD_INT 46
9422: PUSH
9423: LD_INT 46
9425: PUSH
9426: LD_INT 49
9428: PUSH
9429: LD_INT 49
9431: PUSH
9432: LD_INT 49
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: PUSH
9446: LD_VAR 0 3
9450: PUSH
9451: LD_INT 9
9453: MOD
9454: PUSH
9455: LD_INT 1
9457: PLUS
9458: ARRAY
9459: PPUSH
9460: LD_INT 80
9462: PPUSH
9463: CALL 74558 0 5
// result := result union CreateVehicle ;
9467: LD_ADDR_VAR 0 2
9471: PUSH
9472: LD_VAR 0 2
9476: PUSH
9477: CALL_OW 45
9481: UNION
9482: ST_TO_ADDR
// end ;
9483: GO 9352
9485: POP
9486: POP
// if not KappaStatus then
9487: LD_EXP 2
9491: NOT
9492: IFFALSE 9727
// begin uc_nation := 1 ;
9494: LD_ADDR_OWVAR 21
9498: PUSH
9499: LD_INT 1
9501: ST_TO_ADDR
// for i = 1 to 3 do
9502: LD_ADDR_VAR 0 3
9506: PUSH
9507: DOUBLE
9508: LD_INT 1
9510: DEC
9511: ST_TO_ADDR
9512: LD_INT 3
9514: PUSH
9515: FOR_TO
9516: IFFALSE 9652
// begin j := rand ( 0 , 1 ) ;
9518: LD_ADDR_VAR 0 4
9522: PUSH
9523: LD_INT 0
9525: PPUSH
9526: LD_INT 1
9528: PPUSH
9529: CALL_OW 12
9533: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9534: LD_INT 3
9536: PUSH
9537: LD_INT 5
9539: PUSH
9540: LD_INT 5
9542: PUSH
9543: LD_INT 4
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: PUSH
9552: LD_VAR 0 4
9556: PUSH
9557: LD_INT 1
9559: PPUSH
9560: LD_INT 3
9562: PPUSH
9563: CALL_OW 12
9567: PLUS
9568: ARRAY
9569: PPUSH
9570: LD_INT 1
9572: PUSH
9573: LD_INT 3
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 1
9582: PPUSH
9583: LD_INT 2
9585: PPUSH
9586: CALL_OW 12
9590: ARRAY
9591: PPUSH
9592: LD_INT 3
9594: PPUSH
9595: LD_INT 9
9597: PUSH
9598: LD_INT 7
9600: PUSH
9601: LD_INT 6
9603: PUSH
9604: EMPTY
9605: LIST
9606: LIST
9607: LIST
9608: PUSH
9609: LD_VAR 0 4
9613: PUSH
9614: LD_INT 1
9616: PPUSH
9617: LD_INT 2
9619: PPUSH
9620: CALL_OW 12
9624: PLUS
9625: ARRAY
9626: PPUSH
9627: LD_INT 85
9629: PPUSH
9630: CALL 74558 0 5
// result := result union CreateVehicle ;
9634: LD_ADDR_VAR 0 2
9638: PUSH
9639: LD_VAR 0 2
9643: PUSH
9644: CALL_OW 45
9648: UNION
9649: ST_TO_ADDR
// end ;
9650: GO 9515
9652: POP
9653: POP
// if vsevolodFirstAttack then
9654: LD_EXP 24
9658: IFFALSE 9725
// begin vsevolodFirstAttack := false ;
9660: LD_ADDR_EXP 24
9664: PUSH
9665: LD_INT 0
9667: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9668: LD_INT 5
9670: PPUSH
9671: LD_INT 3
9673: PPUSH
9674: LD_INT 1
9676: PPUSH
9677: LD_INT 6
9679: PPUSH
9680: LD_INT 100
9682: PPUSH
9683: CALL 74558 0 5
// sewiVeh := CreateVehicle ;
9687: LD_ADDR_EXP 75
9691: PUSH
9692: CALL_OW 45
9696: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9697: LD_EXP 75
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: CALL_OW 242
// result := result union sewiVeh ;
9709: LD_ADDR_VAR 0 2
9713: PUSH
9714: LD_VAR 0 2
9718: PUSH
9719: LD_EXP 75
9723: UNION
9724: ST_TO_ADDR
// end ; end else
9725: GO 9937
// if vsevolodFirstAttack then
9727: LD_EXP 24
9731: IFFALSE 9937
// begin vsevolodFirstAttack := false ;
9733: LD_ADDR_EXP 24
9737: PUSH
9738: LD_INT 0
9740: ST_TO_ADDR
// uc_nation := 3 ;
9741: LD_ADDR_OWVAR 21
9745: PUSH
9746: LD_INT 3
9748: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9749: LD_ADDR_VAR 0 3
9753: PUSH
9754: DOUBLE
9755: LD_INT 1
9757: DEC
9758: ST_TO_ADDR
9759: LD_INT 2
9761: PUSH
9762: LD_OWVAR 67
9766: PLUS
9767: PUSH
9768: FOR_TO
9769: IFFALSE 9877
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9771: LD_INT 22
9773: PUSH
9774: LD_INT 24
9776: PUSH
9777: LD_INT 24
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: LIST
9784: PUSH
9785: LD_VAR 0 3
9789: PUSH
9790: LD_INT 3
9792: MOD
9793: PUSH
9794: LD_INT 1
9796: PLUS
9797: ARRAY
9798: PPUSH
9799: LD_INT 1
9801: PUSH
9802: LD_INT 3
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PUSH
9809: LD_INT 1
9811: PPUSH
9812: LD_INT 2
9814: PPUSH
9815: CALL_OW 12
9819: ARRAY
9820: PPUSH
9821: LD_INT 1
9823: PPUSH
9824: LD_INT 45
9826: PUSH
9827: LD_INT 47
9829: PUSH
9830: LD_INT 47
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: LIST
9837: PUSH
9838: LD_VAR 0 3
9842: PUSH
9843: LD_INT 3
9845: MOD
9846: PUSH
9847: LD_INT 1
9849: PLUS
9850: ARRAY
9851: PPUSH
9852: LD_INT 80
9854: PPUSH
9855: CALL 74558 0 5
// result := result union CreateVehicle ;
9859: LD_ADDR_VAR 0 2
9863: PUSH
9864: LD_VAR 0 2
9868: PUSH
9869: CALL_OW 45
9873: UNION
9874: ST_TO_ADDR
// end ;
9875: GO 9768
9877: POP
9878: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9879: LD_INT 24
9881: PPUSH
9882: LD_INT 3
9884: PPUSH
9885: LD_INT 1
9887: PPUSH
9888: LD_INT 47
9890: PPUSH
9891: LD_INT 100
9893: PPUSH
9894: CALL 74558 0 5
// sewiVeh := CreateVehicle ;
9898: LD_ADDR_EXP 75
9902: PUSH
9903: CALL_OW 45
9907: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9908: LD_EXP 75
9912: PPUSH
9913: LD_INT 6
9915: NEG
9916: PPUSH
9917: CALL_OW 242
// result := result union sewiVeh ;
9921: LD_ADDR_VAR 0 2
9925: PUSH
9926: LD_VAR 0 2
9930: PUSH
9931: LD_EXP 75
9935: UNION
9936: ST_TO_ADDR
// end ; end ; end ;
9937: GO 9940
9939: POP
// end ;
9940: LD_VAR 0 2
9944: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9945: LD_EXP 16
9949: IFFALSE 10690
9951: GO 9953
9953: DISABLE
9954: LD_INT 0
9956: PPUSH
9957: PPUSH
9958: PPUSH
9959: PPUSH
9960: PPUSH
9961: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9962: LD_ADDR_VAR 0 4
9966: PUSH
9967: LD_INT 11
9969: PUSH
9970: LD_INT 12
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9977: LD_ADDR_VAR 0 3
9981: PUSH
9982: LD_INT 11550
9984: PUSH
9985: LD_INT 10150
9987: PUSH
9988: LD_INT 9800
9990: PUSH
9991: LD_INT 9450
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: PUSH
10000: LD_OWVAR 67
10004: ARRAY
10005: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10006: LD_ADDR_VAR 0 6
10010: PUSH
10011: LD_INT 70
10013: PUSH
10014: LD_INT 118
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 78
10023: PUSH
10024: LD_INT 31
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: ST_TO_ADDR
// repeat if missionStage = 2 then
10035: LD_EXP 15
10039: PUSH
10040: LD_INT 2
10042: EQUAL
10043: IFFALSE 10054
// wait ( 1 1$30 ) else
10045: LD_INT 3150
10047: PPUSH
10048: CALL_OW 67
10052: GO 10063
// wait ( time ) ;
10054: LD_VAR 0 3
10058: PPUSH
10059: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10063: LD_EXP 15
10067: PUSH
10068: LD_INT 6
10070: EQUAL
10071: PUSH
10072: LD_OWVAR 67
10076: PUSH
10077: LD_INT 2
10079: GREATER
10080: OR
10081: IFFALSE 10109
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10083: LD_INT 51
10085: PPUSH
10086: LD_INT 6
10088: PPUSH
10089: LD_INT 2
10091: PPUSH
10092: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10096: LD_INT 57
10098: PPUSH
10099: LD_INT 6
10101: PPUSH
10102: LD_INT 2
10104: PPUSH
10105: CALL_OW 322
// end ; if missionStage = 8 then
10109: LD_EXP 15
10113: PUSH
10114: LD_INT 8
10116: EQUAL
10117: IFFALSE 10145
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10119: LD_INT 52
10121: PPUSH
10122: LD_INT 6
10124: PPUSH
10125: LD_INT 2
10127: PPUSH
10128: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10132: LD_INT 58
10134: PPUSH
10135: LD_INT 6
10137: PPUSH
10138: LD_INT 2
10140: PPUSH
10141: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10145: LD_OWVAR 67
10149: PUSH
10150: LD_INT 4
10152: EQUAL
10153: PUSH
10154: LD_EXP 15
10158: PUSH
10159: LD_INT 10
10161: EQUAL
10162: OR
10163: IFFALSE 10191
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10165: LD_INT 53
10167: PPUSH
10168: LD_INT 6
10170: PPUSH
10171: LD_INT 2
10173: PPUSH
10174: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10178: LD_INT 59
10180: PPUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 2
10186: PPUSH
10187: CALL_OW 322
// end ; if activeAttacks then
10191: LD_EXP 16
10195: IFFALSE 10684
// begin if missionStage = 2 then
10197: LD_EXP 15
10201: PUSH
10202: LD_INT 2
10204: EQUAL
10205: IFFALSE 10215
// strength := 1 ;
10207: LD_ADDR_VAR 0 5
10211: PUSH
10212: LD_INT 1
10214: ST_TO_ADDR
// if missionStage > 2 then
10215: LD_EXP 15
10219: PUSH
10220: LD_INT 2
10222: GREATER
10223: IFFALSE 10233
// strength := 2 ;
10225: LD_ADDR_VAR 0 5
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
// if missionStage > 6 then
10233: LD_EXP 15
10237: PUSH
10238: LD_INT 6
10240: GREATER
10241: IFFALSE 10251
// strength := 3 ;
10243: LD_ADDR_VAR 0 5
10247: PUSH
10248: LD_INT 3
10250: ST_TO_ADDR
// if missionStage > 10 then
10251: LD_EXP 15
10255: PUSH
10256: LD_INT 10
10258: GREATER
10259: IFFALSE 10269
// strength := 4 ;
10261: LD_ADDR_VAR 0 5
10265: PUSH
10266: LD_INT 4
10268: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10269: LD_ADDR_VAR 0 2
10273: PUSH
10274: LD_VAR 0 5
10278: PPUSH
10279: CALL 8762 0 1
10283: ST_TO_ADDR
// for i in tmp do
10284: LD_ADDR_VAR 0 1
10288: PUSH
10289: LD_VAR 0 2
10293: PUSH
10294: FOR_IN
10295: IFFALSE 10553
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10297: LD_VAR 0 1
10301: PPUSH
10302: LD_VAR 0 4
10306: PUSH
10307: LD_INT 1
10309: PPUSH
10310: LD_INT 2
10312: PPUSH
10313: CALL_OW 12
10317: ARRAY
10318: PPUSH
10319: LD_INT 0
10321: PPUSH
10322: CALL_OW 49
// if i = sewiVeh then
10326: LD_VAR 0 1
10330: PUSH
10331: LD_EXP 75
10335: EQUAL
10336: IFFALSE 10373
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10338: LD_ADDR_EXP 74
10342: PUSH
10343: LD_STRING Vsevolod
10345: PPUSH
10346: LD_INT 0
10348: PPUSH
10349: LD_STRING 
10351: PPUSH
10352: CALL 69718 0 3
10356: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10357: LD_EXP 74
10361: PPUSH
10362: LD_VAR 0 1
10366: PPUSH
10367: CALL_OW 52
// end else
10371: GO 10454
// if GetControl ( i ) = control_manual then
10373: LD_VAR 0 1
10377: PPUSH
10378: CALL_OW 263
10382: PUSH
10383: LD_INT 1
10385: EQUAL
10386: IFFALSE 10454
// begin uc_side := 6 ;
10388: LD_ADDR_OWVAR 20
10392: PUSH
10393: LD_INT 6
10395: ST_TO_ADDR
// uc_nation := 3 ;
10396: LD_ADDR_OWVAR 21
10400: PUSH
10401: LD_INT 3
10403: ST_TO_ADDR
// hc_gallery :=  ;
10404: LD_ADDR_OWVAR 33
10408: PUSH
10409: LD_STRING 
10411: ST_TO_ADDR
// hc_name :=  ;
10412: LD_ADDR_OWVAR 26
10416: PUSH
10417: LD_STRING 
10419: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10420: LD_INT 0
10422: PPUSH
10423: LD_INT 3
10425: PPUSH
10426: LD_INT 10
10428: PPUSH
10429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10433: CALL_OW 44
10437: PPUSH
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10447: LD_INT 10
10449: PPUSH
10450: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10454: LD_INT 1
10456: PPUSH
10457: LD_INT 3
10459: PPUSH
10460: CALL_OW 12
10464: PUSH
10465: LD_INT 1
10467: DOUBLE
10468: EQUAL
10469: IFTRUE 10473
10471: GO 10491
10473: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10474: LD_VAR 0 1
10478: PPUSH
10479: LD_INT 111
10481: PPUSH
10482: LD_INT 197
10484: PPUSH
10485: CALL_OW 111
10489: GO 10544
10491: LD_INT 2
10493: DOUBLE
10494: EQUAL
10495: IFTRUE 10499
10497: GO 10517
10499: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10500: LD_VAR 0 1
10504: PPUSH
10505: LD_INT 91
10507: PPUSH
10508: LD_INT 165
10510: PPUSH
10511: CALL_OW 111
10515: GO 10544
10517: LD_INT 3
10519: DOUBLE
10520: EQUAL
10521: IFTRUE 10525
10523: GO 10543
10525: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 137
10533: PPUSH
10534: LD_INT 157
10536: PPUSH
10537: CALL_OW 111
10541: GO 10544
10543: POP
// wait ( 0 0$2 ) ;
10544: LD_INT 70
10546: PPUSH
10547: CALL_OW 67
// end ;
10551: GO 10294
10553: POP
10554: POP
// repeat wait ( 0 0$1 ) ;
10555: LD_INT 35
10557: PPUSH
10558: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: LD_VAR 0 2
10571: PPUSH
10572: LD_INT 50
10574: PUSH
10575: EMPTY
10576: LIST
10577: PPUSH
10578: CALL_OW 72
10582: PUSH
10583: FOR_IN
10584: IFFALSE 10643
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10586: LD_VAR 0 1
10590: PPUSH
10591: LD_INT 108
10593: PUSH
10594: LD_INT 153
10596: PUSH
10597: EMPTY
10598: LIST
10599: LIST
10600: PUSH
10601: LD_INT 105
10603: PUSH
10604: LD_INT 149
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 85
10613: PUSH
10614: LD_INT 131
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 64
10623: PUSH
10624: LD_INT 105
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: PPUSH
10637: CALL 110013 0 2
10641: GO 10583
10643: POP
10644: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10645: LD_VAR 0 2
10649: PPUSH
10650: LD_INT 3
10652: PUSH
10653: LD_INT 34
10655: PUSH
10656: LD_INT 49
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 50
10669: PUSH
10670: EMPTY
10671: LIST
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PPUSH
10677: CALL_OW 72
10681: NOT
10682: IFFALSE 10555
// end ; until russianDestroyed ;
10684: LD_EXP 21
10688: IFFALSE 10035
// end ;
10690: PPOPN 6
10692: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10693: LD_EXP 21
10697: NOT
10698: PUSH
10699: LD_EXP 15
10703: PUSH
10704: LD_INT 6
10706: GREATEREQUAL
10707: AND
10708: IFFALSE 11745
10710: GO 10712
10712: DISABLE
10713: LD_INT 0
10715: PPUSH
10716: PPUSH
10717: PPUSH
10718: PPUSH
10719: PPUSH
// begin enable ;
10720: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10721: LD_INT 22
10723: PUSH
10724: LD_INT 3
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: PUSH
10731: LD_INT 30
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PPUSH
10745: CALL_OW 69
10749: NOT
10750: IFFALSE 10754
// exit ;
10752: GO 11745
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10754: LD_ADDR_VAR 0 4
10758: PUSH
10759: LD_INT 22
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PUSH
10769: LD_INT 30
10771: PUSH
10772: LD_INT 34
10774: PUSH
10775: EMPTY
10776: LIST
10777: LIST
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: PPUSH
10783: CALL_OW 69
10787: ST_TO_ADDR
// if Prob ( 40 ) then
10788: LD_INT 40
10790: PPUSH
10791: CALL_OW 13
10795: IFFALSE 10941
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10797: LD_INT 2
10799: PPUSH
10800: LD_INT 22
10802: PUSH
10803: LD_INT 3
10805: PUSH
10806: LD_INT 3
10808: PUSH
10809: LD_INT 49
10811: PUSH
10812: EMPTY
10813: LIST
10814: LIST
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 22
10820: PUSH
10821: LD_INT 3
10823: PUSH
10824: LD_INT 3
10826: PUSH
10827: LD_INT 49
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PUSH
10836: LD_INT 22
10838: PUSH
10839: LD_INT 3
10841: PUSH
10842: LD_INT 3
10844: PUSH
10845: LD_INT 49
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: PUSH
10854: LD_INT 24
10856: PUSH
10857: LD_INT 3
10859: PUSH
10860: LD_INT 3
10862: PUSH
10863: LD_INT 46
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: PUSH
10872: LD_INT 24
10874: PUSH
10875: LD_INT 3
10877: PUSH
10878: LD_INT 3
10880: PUSH
10881: LD_INT 46
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 24
10892: PUSH
10893: LD_INT 3
10895: PUSH
10896: LD_INT 3
10898: PUSH
10899: LD_INT 46
10901: PUSH
10902: EMPTY
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: PUSH
10908: LD_INT 24
10910: PUSH
10911: LD_INT 3
10913: PUSH
10914: LD_INT 3
10916: PUSH
10917: LD_INT 46
10919: PUSH
10920: EMPTY
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: LIST
10934: PPUSH
10935: CALL 63292 0 2
// end else
10939: GO 11083
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10941: LD_INT 2
10943: PPUSH
10944: LD_INT 24
10946: PUSH
10947: LD_INT 3
10949: PUSH
10950: LD_INT 3
10952: PUSH
10953: LD_INT 47
10955: PUSH
10956: EMPTY
10957: LIST
10958: LIST
10959: LIST
10960: LIST
10961: PUSH
10962: LD_INT 24
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: LD_INT 3
10970: PUSH
10971: LD_INT 47
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 24
10982: PUSH
10983: LD_INT 3
10985: PUSH
10986: LD_INT 3
10988: PUSH
10989: LD_INT 47
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: LIST
10996: LIST
10997: PUSH
10998: LD_INT 24
11000: PUSH
11001: LD_INT 3
11003: PUSH
11004: LD_INT 3
11006: PUSH
11007: LD_INT 46
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: PUSH
11016: LD_INT 24
11018: PUSH
11019: LD_INT 3
11021: PUSH
11022: LD_INT 3
11024: PUSH
11025: LD_INT 46
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 24
11036: PUSH
11037: LD_INT 3
11039: PUSH
11040: LD_INT 3
11042: PUSH
11043: LD_INT 46
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: PUSH
11052: LD_INT 24
11054: PUSH
11055: LD_INT 3
11057: PUSH
11058: LD_INT 3
11060: PUSH
11061: LD_INT 46
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL 63292 0 2
// end ; wait ( 2 2$00 ) ;
11083: LD_INT 4200
11085: PPUSH
11086: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11090: LD_ADDR_VAR 0 2
11094: PUSH
11095: LD_INT 22
11097: PUSH
11098: LD_INT 3
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: LD_INT 23
11107: PUSH
11108: LD_INT 3
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: PUSH
11115: LD_INT 21
11117: PUSH
11118: LD_INT 2
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: PUSH
11125: LD_INT 3
11127: PUSH
11128: LD_INT 34
11130: PUSH
11131: LD_INT 48
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: PUSH
11138: EMPTY
11139: LIST
11140: LIST
11141: PUSH
11142: LD_INT 3
11144: PUSH
11145: LD_INT 34
11147: PUSH
11148: LD_INT 51
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 3
11161: PUSH
11162: LD_INT 34
11164: PUSH
11165: LD_INT 52
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: EMPTY
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: LIST
11183: PPUSH
11184: CALL_OW 69
11188: PUSH
11189: LD_EXP 124
11193: PUSH
11194: LD_INT 2
11196: ARRAY
11197: DIFF
11198: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11199: LD_ADDR_EXP 121
11203: PUSH
11204: LD_EXP 121
11208: PPUSH
11209: LD_INT 2
11211: PPUSH
11212: LD_EXP 121
11216: PUSH
11217: LD_INT 2
11219: ARRAY
11220: PUSH
11221: LD_VAR 0 2
11225: DIFF
11226: PPUSH
11227: CALL_OW 1
11231: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11232: LD_ADDR_VAR 0 3
11236: PUSH
11237: LD_INT 0
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: CALL_OW 12
11247: ST_TO_ADDR
// p := 0 ;
11248: LD_ADDR_VAR 0 5
11252: PUSH
11253: LD_INT 0
11255: ST_TO_ADDR
// if target then
11256: LD_VAR 0 3
11260: IFFALSE 11409
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11262: LD_ADDR_VAR 0 2
11266: PUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: LD_INT 50
11274: PUSH
11275: EMPTY
11276: LIST
11277: PPUSH
11278: CALL_OW 72
11282: ST_TO_ADDR
// for i in tmp do
11283: LD_ADDR_VAR 0 1
11287: PUSH
11288: LD_VAR 0 2
11292: PUSH
11293: FOR_IN
11294: IFFALSE 11334
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11296: LD_VAR 0 1
11300: PPUSH
11301: LD_INT 139
11303: PPUSH
11304: LD_INT 89
11306: PPUSH
11307: CALL_OW 297
11311: PUSH
11312: LD_INT 9
11314: GREATER
11315: IFFALSE 11332
// ComMoveXY ( i , 139 , 89 ) ;
11317: LD_VAR 0 1
11321: PPUSH
11322: LD_INT 139
11324: PPUSH
11325: LD_INT 89
11327: PPUSH
11328: CALL_OW 111
11332: GO 11293
11334: POP
11335: POP
// wait ( 0 0$1 ) ;
11336: LD_INT 35
11338: PPUSH
11339: CALL_OW 67
// p := Inc ( p ) ;
11343: LD_ADDR_VAR 0 5
11347: PUSH
11348: LD_VAR 0 5
11352: PPUSH
11353: CALL 108770 0 1
11357: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11358: LD_VAR 0 2
11362: PPUSH
11363: LD_INT 92
11365: PUSH
11366: LD_INT 139
11368: PUSH
11369: LD_INT 89
11371: PUSH
11372: LD_INT 9
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: PPUSH
11381: CALL_OW 72
11385: PUSH
11386: LD_VAR 0 2
11390: PUSH
11391: LD_INT 1
11393: MINUS
11394: GREATEREQUAL
11395: PUSH
11396: LD_VAR 0 5
11400: PUSH
11401: LD_INT 60
11403: GREATER
11404: OR
11405: IFFALSE 11262
// end else
11407: GO 11572
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11409: LD_VAR 0 2
11413: PPUSH
11414: LD_VAR 0 4
11418: PUSH
11419: LD_INT 1
11421: ARRAY
11422: PPUSH
11423: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11427: LD_ADDR_VAR 0 2
11431: PUSH
11432: LD_VAR 0 2
11436: PPUSH
11437: LD_INT 50
11439: PUSH
11440: EMPTY
11441: LIST
11442: PPUSH
11443: CALL_OW 72
11447: ST_TO_ADDR
// for i in tmp do
11448: LD_ADDR_VAR 0 1
11452: PUSH
11453: LD_VAR 0 2
11457: PUSH
11458: FOR_IN
11459: IFFALSE 11499
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11461: LD_VAR 0 1
11465: PPUSH
11466: LD_INT 124
11468: PPUSH
11469: LD_INT 139
11471: PPUSH
11472: CALL_OW 297
11476: PUSH
11477: LD_INT 9
11479: GREATER
11480: IFFALSE 11497
// ComMoveXY ( i , 124 , 139 ) ;
11482: LD_VAR 0 1
11486: PPUSH
11487: LD_INT 124
11489: PPUSH
11490: LD_INT 139
11492: PPUSH
11493: CALL_OW 111
11497: GO 11458
11499: POP
11500: POP
// wait ( 0 0$1 ) ;
11501: LD_INT 35
11503: PPUSH
11504: CALL_OW 67
// p := Inc ( p ) ;
11508: LD_ADDR_VAR 0 5
11512: PUSH
11513: LD_VAR 0 5
11517: PPUSH
11518: CALL 108770 0 1
11522: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11523: LD_VAR 0 2
11527: PPUSH
11528: LD_INT 92
11530: PUSH
11531: LD_INT 124
11533: PUSH
11534: LD_INT 139
11536: PUSH
11537: LD_INT 9
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: PPUSH
11546: CALL_OW 72
11550: PUSH
11551: LD_VAR 0 2
11555: PUSH
11556: LD_INT 1
11558: MINUS
11559: GREATEREQUAL
11560: PUSH
11561: LD_VAR 0 5
11565: PUSH
11566: LD_INT 60
11568: GREATER
11569: OR
11570: IFFALSE 11427
// end ; repeat wait ( 0 0$1 ) ;
11572: LD_INT 35
11574: PPUSH
11575: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11579: LD_ADDR_VAR 0 2
11583: PUSH
11584: LD_VAR 0 2
11588: PPUSH
11589: LD_INT 50
11591: PUSH
11592: EMPTY
11593: LIST
11594: PPUSH
11595: CALL_OW 72
11599: ST_TO_ADDR
// for i in tmp do
11600: LD_ADDR_VAR 0 1
11604: PUSH
11605: LD_VAR 0 2
11609: PUSH
11610: FOR_IN
11611: IFFALSE 11736
// begin if GetWeapon ( i ) = ru_time_lapser then
11613: LD_VAR 0 1
11617: PPUSH
11618: CALL_OW 264
11622: PUSH
11623: LD_INT 49
11625: EQUAL
11626: IFFALSE 11682
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11628: LD_VAR 0 1
11632: PPUSH
11633: LD_INT 2
11635: PUSH
11636: LD_INT 22
11638: PUSH
11639: LD_INT 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 22
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 69
11665: PPUSH
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 74
11675: PPUSH
11676: CALL_OW 112
11680: GO 11734
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11682: LD_VAR 0 1
11686: PPUSH
11687: LD_INT 2
11689: PUSH
11690: LD_INT 22
11692: PUSH
11693: LD_INT 1
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: LD_INT 22
11702: PUSH
11703: LD_INT 8
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: LIST
11714: PPUSH
11715: CALL_OW 69
11719: PPUSH
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 74
11729: PPUSH
11730: CALL_OW 115
// end ;
11734: GO 11610
11736: POP
11737: POP
// until not tmp ;
11738: LD_VAR 0 2
11742: NOT
11743: IFFALSE 11572
// end ;
11745: PPOPN 5
11747: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11748: LD_EXP 15
11752: PUSH
11753: LD_INT 7
11755: GREATEREQUAL
11756: PUSH
11757: LD_OWVAR 67
11761: PUSH
11762: LD_INT 1
11764: GREATER
11765: AND
11766: IFFALSE 12058
11768: GO 11770
11770: DISABLE
11771: LD_INT 0
11773: PPUSH
11774: PPUSH
11775: PPUSH
// begin ruMobile := [ ] ;
11776: LD_ADDR_EXP 78
11780: PUSH
11781: EMPTY
11782: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11783: LD_ADDR_VAR 0 1
11787: PUSH
11788: DOUBLE
11789: LD_INT 1
11791: DEC
11792: ST_TO_ADDR
11793: LD_INT 4
11795: PUSH
11796: LD_INT 5
11798: PUSH
11799: LD_INT 6
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: PUSH
11807: LD_OWVAR 67
11811: PUSH
11812: LD_INT 1
11814: MINUS
11815: ARRAY
11816: PUSH
11817: FOR_TO
11818: IFFALSE 12056
// begin uc_side := 3 ;
11820: LD_ADDR_OWVAR 20
11824: PUSH
11825: LD_INT 3
11827: ST_TO_ADDR
// uc_nation := 1 ;
11828: LD_ADDR_OWVAR 21
11832: PUSH
11833: LD_INT 1
11835: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11836: LD_INT 5
11838: PPUSH
11839: LD_INT 3
11841: PPUSH
11842: LD_INT 1
11844: PPUSH
11845: LD_INT 9
11847: PUSH
11848: LD_INT 7
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_VAR 0 1
11859: PUSH
11860: LD_INT 2
11862: MOD
11863: PUSH
11864: LD_INT 1
11866: PLUS
11867: ARRAY
11868: PPUSH
11869: LD_INT 100
11871: PPUSH
11872: CALL 74558 0 5
// veh := CreateVehicle ;
11876: LD_ADDR_VAR 0 2
11880: PUSH
11881: CALL_OW 45
11885: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11886: LD_VAR 0 2
11890: PPUSH
11891: LD_INT 3
11893: PPUSH
11894: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11898: LD_VAR 0 2
11902: PPUSH
11903: LD_INT 29
11905: PPUSH
11906: LD_INT 0
11908: PPUSH
11909: CALL_OW 49
// uc_nation := 3 ;
11913: LD_ADDR_OWVAR 21
11917: PUSH
11918: LD_INT 3
11920: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11921: LD_INT 0
11923: PPUSH
11924: LD_INT 10
11926: PPUSH
11927: CALL_OW 383
// un := CreateHuman ;
11931: LD_ADDR_VAR 0 3
11935: PUSH
11936: CALL_OW 44
11940: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11941: LD_VAR 0 3
11945: PPUSH
11946: LD_INT 105
11948: PPUSH
11949: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11953: LD_VAR 0 3
11957: PPUSH
11958: LD_INT 3
11960: PPUSH
11961: CALL_OW 259
11965: PUSH
11966: LD_INT 8
11968: PUSH
11969: LD_INT 9
11971: PUSH
11972: LD_INT 10
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: LIST
11979: PUSH
11980: LD_OWVAR 67
11984: ARRAY
11985: LESS
11986: IFFALSE 12020
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11988: LD_VAR 0 3
11992: PPUSH
11993: LD_INT 3
11995: PPUSH
11996: LD_INT 8
11998: PUSH
11999: LD_INT 9
12001: PUSH
12002: LD_INT 10
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: LIST
12009: PUSH
12010: LD_OWVAR 67
12014: ARRAY
12015: PPUSH
12016: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12020: LD_VAR 0 3
12024: PPUSH
12025: LD_VAR 0 2
12029: PPUSH
12030: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12034: LD_ADDR_EXP 78
12038: PUSH
12039: LD_EXP 78
12043: PPUSH
12044: LD_VAR 0 2
12048: PPUSH
12049: CALL 107409 0 2
12053: ST_TO_ADDR
// end ;
12054: GO 11817
12056: POP
12057: POP
// end ;
12058: PPOPN 3
12060: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12061: LD_EXP 78
12065: IFFALSE 12574
12067: GO 12069
12069: DISABLE
12070: LD_INT 0
12072: PPUSH
12073: PPUSH
12074: PPUSH
// begin enable ;
12075: ENABLE
// if not ruMobile then
12076: LD_EXP 78
12080: NOT
12081: IFFALSE 12086
// begin disable ;
12083: DISABLE
// exit ;
12084: GO 12574
// end ; for i in ruMobile do
12086: LD_ADDR_VAR 0 1
12090: PUSH
12091: LD_EXP 78
12095: PUSH
12096: FOR_IN
12097: IFFALSE 12572
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12099: LD_VAR 0 1
12103: PPUSH
12104: CALL_OW 302
12108: NOT
12109: PUSH
12110: LD_VAR 0 1
12114: PPUSH
12115: CALL_OW 255
12119: PUSH
12120: LD_INT 3
12122: NONEQUAL
12123: OR
12124: IFFALSE 12144
// begin ruMobile := ruMobile diff i ;
12126: LD_ADDR_EXP 78
12130: PUSH
12131: LD_EXP 78
12135: PUSH
12136: LD_VAR 0 1
12140: DIFF
12141: ST_TO_ADDR
// continue ;
12142: GO 12096
// end ; if GetTag ( i ) = 300 then
12144: LD_VAR 0 1
12148: PPUSH
12149: CALL_OW 110
12153: PUSH
12154: LD_INT 300
12156: EQUAL
12157: IFFALSE 12207
// begin ComMoveXY ( i , 160 , 81 ) ;
12159: LD_VAR 0 1
12163: PPUSH
12164: LD_INT 160
12166: PPUSH
12167: LD_INT 81
12169: PPUSH
12170: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12174: LD_VAR 0 1
12178: PPUSH
12179: LD_INT 160
12181: PPUSH
12182: LD_INT 81
12184: PPUSH
12185: CALL_OW 297
12189: PUSH
12190: LD_INT 8
12192: LESS
12193: IFFALSE 12207
// SetTag ( i , 301 ) ;
12195: LD_VAR 0 1
12199: PPUSH
12200: LD_INT 301
12202: PPUSH
12203: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12207: LD_VAR 0 1
12211: PPUSH
12212: CALL_OW 110
12216: PUSH
12217: LD_INT 301
12219: EQUAL
12220: IFFALSE 12263
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12222: LD_VAR 0 1
12226: PPUSH
12227: LD_INT 33
12229: PPUSH
12230: CALL_OW 308
12234: NOT
12235: IFFALSE 12251
// ComMoveToArea ( i , ruMobileParkingArea ) else
12237: LD_VAR 0 1
12241: PPUSH
12242: LD_INT 33
12244: PPUSH
12245: CALL_OW 113
12249: GO 12263
// SetTag ( i , 302 ) ;
12251: LD_VAR 0 1
12255: PPUSH
12256: LD_INT 302
12258: PPUSH
12259: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12263: LD_VAR 0 1
12267: PPUSH
12268: CALL_OW 110
12272: PUSH
12273: LD_INT 302
12275: EQUAL
12276: IFFALSE 12406
// begin if GetLives ( i ) < 1000 then
12278: LD_VAR 0 1
12282: PPUSH
12283: CALL_OW 256
12287: PUSH
12288: LD_INT 1000
12290: LESS
12291: IFFALSE 12383
// begin if not IsDrivenBy ( i ) then
12293: LD_VAR 0 1
12297: PPUSH
12298: CALL_OW 311
12302: NOT
12303: IFFALSE 12307
// continue ;
12305: GO 12096
// mech := IsDrivenBy ( i ) ;
12307: LD_ADDR_VAR 0 2
12311: PUSH
12312: LD_VAR 0 1
12316: PPUSH
12317: CALL_OW 311
12321: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12322: LD_VAR 0 2
12326: PPUSH
12327: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12331: LD_VAR 0 2
12335: PPUSH
12336: LD_VAR 0 1
12340: PPUSH
12341: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12345: LD_INT 35
12347: PPUSH
12348: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 256
12361: PUSH
12362: LD_INT 1000
12364: EQUAL
12365: IFFALSE 12345
// ComEnterUnit ( mech , i ) ;
12367: LD_VAR 0 2
12371: PPUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 120
// end else
12381: GO 12406
// if IsDrivenBy ( i ) then
12383: LD_VAR 0 1
12387: PPUSH
12388: CALL_OW 311
12392: IFFALSE 12406
// SetTag ( i , 0 ) ;
12394: LD_VAR 0 1
12398: PPUSH
12399: LD_INT 0
12401: PPUSH
12402: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12406: LD_VAR 0 1
12410: PPUSH
12411: CALL_OW 110
12415: PUSH
12416: LD_INT 300
12418: LESS
12419: IFFALSE 12570
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12421: LD_ADDR_VAR 0 3
12425: PUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 81
12431: PUSH
12432: LD_INT 3
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: PPUSH
12439: CALL_OW 70
12443: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12444: LD_VAR 0 1
12448: PPUSH
12449: CALL_OW 256
12453: PUSH
12454: LD_INT 650
12456: LESS
12457: IFFALSE 12482
// begin ComStop ( i ) ;
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 141
// SetTag ( i , 300 ) ;
12468: LD_VAR 0 1
12472: PPUSH
12473: LD_INT 300
12475: PPUSH
12476: CALL_OW 109
// continue ;
12480: GO 12096
// end ; if enemy then
12482: LD_VAR 0 3
12486: IFFALSE 12526
// begin if not HasTask ( i ) then
12488: LD_VAR 0 1
12492: PPUSH
12493: CALL_OW 314
12497: NOT
12498: IFFALSE 12524
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12500: LD_VAR 0 1
12504: PPUSH
12505: LD_VAR 0 3
12509: PPUSH
12510: LD_VAR 0 1
12514: PPUSH
12515: CALL_OW 74
12519: PPUSH
12520: CALL_OW 115
// end else
12524: GO 12570
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12526: LD_VAR 0 1
12530: PPUSH
12531: LD_INT 158
12533: PUSH
12534: LD_INT 61
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 98
12543: PUSH
12544: LD_INT 100
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 78
12553: PUSH
12554: LD_INT 93
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: PPUSH
12566: CALL 110013 0 2
// end ; end ;
12570: GO 12096
12572: POP
12573: POP
// end ; end_of_file
12574: PPOPN 3
12576: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12577: LD_INT 0
12579: PPUSH
12580: PPUSH
12581: PPUSH
12582: PPUSH
12583: PPUSH
12584: PPUSH
12585: PPUSH
// if Difficulty = 1 then
12586: LD_OWVAR 67
12590: PUSH
12591: LD_INT 1
12593: EQUAL
12594: IFFALSE 12632
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12596: LD_ADDR_VAR 0 2
12600: PUSH
12601: LD_INT 95
12603: PUSH
12604: LD_INT 34
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PPUSH
12611: CALL_OW 69
12615: PUSH
12616: FOR_IN
12617: IFFALSE 12630
// RemoveUnit ( i ) ;
12619: LD_VAR 0 2
12623: PPUSH
12624: CALL_OW 64
12628: GO 12616
12630: POP
12631: POP
// SetInvulnrability ( alien , true ) ;
12632: LD_INT 1
12634: PPUSH
12635: LD_INT 1
12637: PPUSH
12638: CALL_OW 607
// side := 7 ;
12642: LD_ADDR_VAR 0 5
12646: PUSH
12647: LD_INT 7
12649: ST_TO_ADDR
// uc_side := side ;
12650: LD_ADDR_OWVAR 20
12654: PUSH
12655: LD_VAR 0 5
12659: ST_TO_ADDR
// uc_nation := 1 ;
12660: LD_ADDR_OWVAR 21
12664: PUSH
12665: LD_INT 1
12667: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12668: LD_ADDR_VAR 0 2
12672: PUSH
12673: LD_INT 22
12675: PUSH
12676: LD_VAR 0 5
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: LD_INT 21
12687: PUSH
12688: LD_INT 3
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: EMPTY
12696: LIST
12697: LIST
12698: PPUSH
12699: CALL_OW 69
12703: PUSH
12704: FOR_IN
12705: IFFALSE 12721
// SetBLevel ( i , 10 ) ;
12707: LD_VAR 0 2
12711: PPUSH
12712: LD_INT 10
12714: PPUSH
12715: CALL_OW 241
12719: GO 12704
12721: POP
12722: POP
// base := GetBase ( al_depot ) ;
12723: LD_ADDR_VAR 0 4
12727: PUSH
12728: LD_INT 2
12730: PPUSH
12731: CALL_OW 274
12735: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12736: LD_ADDR_VAR 0 6
12740: PUSH
12741: LD_INT 22
12743: PUSH
12744: LD_VAR 0 5
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 30
12755: PUSH
12756: LD_INT 34
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PPUSH
12767: CALL_OW 69
12771: ST_TO_ADDR
// if teleport then
12772: LD_VAR 0 6
12776: IFFALSE 12797
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12778: LD_VAR 0 6
12782: PUSH
12783: LD_INT 1
12785: ARRAY
12786: PPUSH
12787: LD_INT 262
12789: PPUSH
12790: LD_INT 119
12792: PPUSH
12793: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12797: LD_VAR 0 4
12801: PPUSH
12802: LD_INT 1
12804: PPUSH
12805: LD_INT 19500
12807: PPUSH
12808: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12812: LD_VAR 0 4
12816: PPUSH
12817: LD_INT 2
12819: PPUSH
12820: LD_INT 200
12822: PPUSH
12823: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12827: LD_VAR 0 4
12831: PPUSH
12832: LD_INT 3
12834: PPUSH
12835: LD_INT 650
12837: PPUSH
12838: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12842: LD_ADDR_EXP 79
12846: PUSH
12847: LD_STRING Roth
12849: PPUSH
12850: CALL_OW 25
12854: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12855: LD_ADDR_EXP 80
12859: PUSH
12860: LD_STRING Simms
12862: PPUSH
12863: LD_EXP 1
12867: NOT
12868: PPUSH
12869: LD_STRING 10c_
12871: PPUSH
12872: CALL 69718 0 3
12876: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12877: LD_EXP 80
12881: PPUSH
12882: LD_INT 4
12884: PPUSH
12885: CALL_OW 336
// if not Simms then
12889: LD_EXP 80
12893: NOT
12894: IFFALSE 12924
// begin uc_nation := 1 ;
12896: LD_ADDR_OWVAR 21
12900: PUSH
12901: LD_INT 1
12903: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12904: LD_INT 2
12906: PPUSH
12907: LD_INT 10
12909: PPUSH
12910: CALL_OW 384
// Simms := CreateHuman ;
12914: LD_ADDR_EXP 80
12918: PUSH
12919: CALL_OW 44
12923: ST_TO_ADDR
// end ; uc_nation := 3 ;
12924: LD_ADDR_OWVAR 21
12928: PUSH
12929: LD_INT 3
12931: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12932: LD_ADDR_EXP 81
12936: PUSH
12937: LD_STRING Kirilenkova
12939: PPUSH
12940: CALL_OW 25
12944: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12945: LD_ADDR_EXP 95
12949: PUSH
12950: LD_STRING Oblukov
12952: PPUSH
12953: CALL_OW 25
12957: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12958: LD_ADDR_EXP 82
12962: PUSH
12963: LD_STRING Dolgov
12965: PPUSH
12966: CALL_OW 25
12970: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12971: LD_ADDR_EXP 83
12975: PUSH
12976: LD_STRING Petrosyan
12978: PPUSH
12979: CALL_OW 25
12983: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12984: LD_ADDR_EXP 94
12988: PUSH
12989: LD_STRING Scholtze
12991: PPUSH
12992: CALL_OW 25
12996: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12997: LD_ADDR_EXP 93
13001: PUSH
13002: LD_STRING Kapitsova
13004: PPUSH
13005: CALL_OW 25
13009: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13010: LD_ADDR_EXP 84
13014: PUSH
13015: LD_STRING Petrovova
13017: PPUSH
13018: CALL_OW 25
13022: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13023: LD_ADDR_EXP 85
13027: PUSH
13028: LD_STRING Kuzmov
13030: PPUSH
13031: CALL_OW 25
13035: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13036: LD_ADDR_EXP 92
13040: PUSH
13041: LD_STRING Karamazov
13043: PPUSH
13044: CALL_OW 25
13048: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13049: LD_STRING 13_Lipshchin_1
13051: PPUSH
13052: LD_INT 0
13054: PPUSH
13055: CALL_OW 30
13059: IFFALSE 13074
// Lipshchin := NewCharacter ( Lipshchin ) ;
13061: LD_ADDR_EXP 86
13065: PUSH
13066: LD_STRING Lipshchin
13068: PPUSH
13069: CALL_OW 25
13073: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13074: LD_STRING 13_Titov_1
13076: PPUSH
13077: LD_INT 0
13079: PPUSH
13080: CALL_OW 30
13084: IFFALSE 13099
// Titov := NewCharacter ( Titov ) ;
13086: LD_ADDR_EXP 88
13090: PUSH
13091: LD_STRING Titov
13093: PPUSH
13094: CALL_OW 25
13098: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13099: LD_STRING 13_Gnyevko_1
13101: PPUSH
13102: LD_INT 0
13104: PPUSH
13105: CALL_OW 30
13109: IFFALSE 13124
// Gnyevko := NewCharacter ( Gnyevko ) ;
13111: LD_ADDR_EXP 87
13115: PUSH
13116: LD_STRING Gnyevko
13118: PPUSH
13119: CALL_OW 25
13123: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13124: LD_STRING 13_Xavier_1
13126: PPUSH
13127: LD_INT 0
13129: PPUSH
13130: CALL_OW 30
13134: IFFALSE 13149
// Xavier := NewCharacter ( Xavier2 ) ;
13136: LD_ADDR_EXP 89
13140: PUSH
13141: LD_STRING Xavier2
13143: PPUSH
13144: CALL_OW 25
13148: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13149: LD_STRING 13_Belkov_1
13151: PPUSH
13152: LD_INT 0
13154: PPUSH
13155: CALL_OW 30
13159: IFFALSE 13174
// Belkov := NewCharacter ( Belkov ) ;
13161: LD_ADDR_EXP 90
13165: PUSH
13166: LD_STRING Belkov
13168: PPUSH
13169: CALL_OW 25
13173: ST_TO_ADDR
// if not BurlakStatus then
13174: LD_EXP 9
13178: NOT
13179: IFFALSE 13194
// Burlak = NewCharacter ( Burlak ) ;
13181: LD_ADDR_EXP 91
13185: PUSH
13186: LD_STRING Burlak
13188: PPUSH
13189: CALL_OW 25
13193: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13194: LD_ADDR_VAR 0 3
13198: PUSH
13199: LD_EXP 79
13203: PUSH
13204: LD_EXP 81
13208: PUSH
13209: LD_EXP 95
13213: PUSH
13214: LD_EXP 82
13218: PUSH
13219: LD_EXP 83
13223: PUSH
13224: LD_EXP 94
13228: PUSH
13229: LD_EXP 93
13233: PUSH
13234: LD_EXP 84
13238: PUSH
13239: LD_EXP 85
13243: PUSH
13244: LD_EXP 92
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: ST_TO_ADDR
// if Simms then
13261: LD_EXP 80
13265: IFFALSE 13283
// tmp := tmp ^ Simms ;
13267: LD_ADDR_VAR 0 3
13271: PUSH
13272: LD_VAR 0 3
13276: PUSH
13277: LD_EXP 80
13281: ADD
13282: ST_TO_ADDR
// if Titov then
13283: LD_EXP 88
13287: IFFALSE 13305
// tmp := tmp ^ Titov ;
13289: LD_ADDR_VAR 0 3
13293: PUSH
13294: LD_VAR 0 3
13298: PUSH
13299: LD_EXP 88
13303: ADD
13304: ST_TO_ADDR
// if Lipshchin then
13305: LD_EXP 86
13309: IFFALSE 13327
// tmp := tmp ^ Lipshchin ;
13311: LD_ADDR_VAR 0 3
13315: PUSH
13316: LD_VAR 0 3
13320: PUSH
13321: LD_EXP 86
13325: ADD
13326: ST_TO_ADDR
// if Gnyevko then
13327: LD_EXP 87
13331: IFFALSE 13349
// tmp := tmp ^ Gnyevko ;
13333: LD_ADDR_VAR 0 3
13337: PUSH
13338: LD_VAR 0 3
13342: PUSH
13343: LD_EXP 87
13347: ADD
13348: ST_TO_ADDR
// if Xavier then
13349: LD_EXP 89
13353: IFFALSE 13371
// tmp := tmp ^ Xavier ;
13355: LD_ADDR_VAR 0 3
13359: PUSH
13360: LD_VAR 0 3
13364: PUSH
13365: LD_EXP 89
13369: ADD
13370: ST_TO_ADDR
// if Belkov then
13371: LD_EXP 90
13375: IFFALSE 13393
// tmp := tmp ^ Belkov ;
13377: LD_ADDR_VAR 0 3
13381: PUSH
13382: LD_VAR 0 3
13386: PUSH
13387: LD_EXP 90
13391: ADD
13392: ST_TO_ADDR
// if Burlak then
13393: LD_EXP 91
13397: IFFALSE 13415
// tmp := tmp ^ Burlak ;
13399: LD_ADDR_VAR 0 3
13403: PUSH
13404: LD_VAR 0 3
13408: PUSH
13409: LD_EXP 91
13413: ADD
13414: ST_TO_ADDR
// for i = 1 to 11 do
13415: LD_ADDR_VAR 0 2
13419: PUSH
13420: DOUBLE
13421: LD_INT 1
13423: DEC
13424: ST_TO_ADDR
13425: LD_INT 11
13427: PUSH
13428: FOR_TO
13429: IFFALSE 13497
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13431: LD_ADDR_OWVAR 21
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 3
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 1
13448: PPUSH
13449: LD_INT 2
13451: PPUSH
13452: CALL_OW 12
13456: ARRAY
13457: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13458: LD_INT 0
13460: PPUSH
13461: LD_INT 1
13463: PPUSH
13464: LD_INT 4
13466: PPUSH
13467: CALL_OW 12
13471: PPUSH
13472: LD_INT 10
13474: PPUSH
13475: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13479: LD_ADDR_VAR 0 3
13483: PUSH
13484: LD_VAR 0 3
13488: PUSH
13489: CALL_OW 44
13493: ADD
13494: ST_TO_ADDR
// end ;
13495: GO 13428
13497: POP
13498: POP
// for i in tmp do
13499: LD_ADDR_VAR 0 2
13503: PUSH
13504: LD_VAR 0 3
13508: PUSH
13509: FOR_IN
13510: IFFALSE 13535
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13512: LD_VAR 0 2
13516: PPUSH
13517: LD_INT 260
13519: PPUSH
13520: LD_INT 235
13522: PPUSH
13523: LD_INT 8
13525: PPUSH
13526: LD_INT 0
13528: PPUSH
13529: CALL_OW 50
13533: GO 13509
13535: POP
13536: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13537: LD_ADDR_EXP 102
13541: PUSH
13542: LD_EXP 102
13546: PPUSH
13547: LD_INT 1
13549: PPUSH
13550: LD_INT 22
13552: PUSH
13553: LD_VAR 0 5
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 3
13564: PUSH
13565: LD_INT 21
13567: PUSH
13568: LD_INT 2
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PPUSH
13583: CALL_OW 69
13587: PUSH
13588: LD_EXP 79
13592: PUSH
13593: LD_EXP 80
13597: PUSH
13598: EMPTY
13599: LIST
13600: LIST
13601: DIFF
13602: PPUSH
13603: CALL_OW 1
13607: ST_TO_ADDR
// uc_side := 0 ;
13608: LD_ADDR_OWVAR 20
13612: PUSH
13613: LD_INT 0
13615: ST_TO_ADDR
// uc_nation := 0 ;
13616: LD_ADDR_OWVAR 21
13620: PUSH
13621: LD_INT 0
13623: ST_TO_ADDR
// for i = 1 to 5 do
13624: LD_ADDR_VAR 0 2
13628: PUSH
13629: DOUBLE
13630: LD_INT 1
13632: DEC
13633: ST_TO_ADDR
13634: LD_INT 5
13636: PUSH
13637: FOR_TO
13638: IFFALSE 13675
// begin InitHc ;
13640: CALL_OW 19
// hc_class := class_apeman ;
13644: LD_ADDR_OWVAR 28
13648: PUSH
13649: LD_INT 12
13651: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13652: CALL_OW 44
13656: PPUSH
13657: LD_INT 299
13659: PPUSH
13660: LD_INT 229
13662: PPUSH
13663: LD_INT 10
13665: PPUSH
13666: LD_INT 0
13668: PPUSH
13669: CALL_OW 50
// end ;
13673: GO 13637
13675: POP
13676: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13677: LD_EXP 79
13681: PPUSH
13682: LD_INT 259
13684: PPUSH
13685: LD_INT 235
13687: PPUSH
13688: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13692: LD_EXP 79
13696: PPUSH
13697: LD_INT 262
13699: PPUSH
13700: LD_INT 235
13702: PPUSH
13703: CALL_OW 178
// if Simms then
13707: LD_EXP 80
13711: IFFALSE 13742
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13713: LD_EXP 80
13717: PPUSH
13718: LD_INT 262
13720: PPUSH
13721: LD_INT 235
13723: PPUSH
13724: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13728: LD_EXP 80
13732: PPUSH
13733: LD_EXP 79
13737: PPUSH
13738: CALL_OW 179
// end ; uc_side := 7 ;
13742: LD_ADDR_OWVAR 20
13746: PUSH
13747: LD_INT 7
13749: ST_TO_ADDR
// uc_nation := 1 ;
13750: LD_ADDR_OWVAR 21
13754: PUSH
13755: LD_INT 1
13757: ST_TO_ADDR
// bc_type := b_control_tower ;
13758: LD_ADDR_OWVAR 42
13762: PUSH
13763: LD_INT 36
13765: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13766: LD_ADDR_VAR 0 7
13770: PUSH
13771: LD_INT 268
13773: PPUSH
13774: LD_INT 251
13776: PPUSH
13777: LD_INT 4
13779: PPUSH
13780: CALL_OW 47
13784: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13785: LD_INT 0
13787: PPUSH
13788: LD_INT 10
13790: PPUSH
13791: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13795: CALL_OW 44
13799: PPUSH
13800: LD_VAR 0 7
13804: PPUSH
13805: CALL_OW 52
// end ;
13809: LD_VAR 0 1
13813: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13814: LD_EXP 31
13818: PUSH
13819: LD_EXP 23
13823: NOT
13824: AND
13825: PUSH
13826: LD_INT 22
13828: PUSH
13829: LD_INT 7
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 30
13838: PUSH
13839: LD_INT 8
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: PPUSH
13850: CALL_OW 69
13854: AND
13855: IFFALSE 14083
13857: GO 13859
13859: DISABLE
13860: LD_INT 0
13862: PPUSH
13863: PPUSH
13864: PPUSH
// begin enable ;
13865: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13866: LD_ADDR_VAR 0 2
13870: PUSH
13871: LD_INT 81
13873: PUSH
13874: LD_INT 7
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PUSH
13881: LD_INT 2
13883: PUSH
13884: LD_INT 32
13886: PUSH
13887: LD_INT 3
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: LD_INT 30
13896: PUSH
13897: LD_INT 30
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: PUSH
13904: LD_INT 30
13906: PUSH
13907: LD_INT 28
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PUSH
13914: LD_INT 34
13916: PUSH
13917: LD_INT 49
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PUSH
13924: LD_INT 34
13926: PUSH
13927: LD_INT 10
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: LD_INT 34
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: PUSH
13953: EMPTY
13954: LIST
13955: LIST
13956: PPUSH
13957: CALL_OW 69
13961: ST_TO_ADDR
// if not tmp then
13962: LD_VAR 0 2
13966: NOT
13967: IFFALSE 13971
// exit ;
13969: GO 14083
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13971: LD_VAR 0 2
13975: PPUSH
13976: LD_INT 34
13978: PUSH
13979: LD_INT 8
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PPUSH
13986: CALL_OW 72
13990: IFFALSE 14023
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13992: LD_ADDR_VAR 0 3
13996: PUSH
13997: LD_VAR 0 2
14001: PPUSH
14002: LD_INT 34
14004: PUSH
14005: LD_INT 8
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: PPUSH
14012: CALL_OW 72
14016: PUSH
14017: LD_INT 1
14019: ARRAY
14020: ST_TO_ADDR
14021: GO 14047
// target := tmp [ rand ( 1 , tmp ) ] ;
14023: LD_ADDR_VAR 0 3
14027: PUSH
14028: LD_VAR 0 2
14032: PUSH
14033: LD_INT 1
14035: PPUSH
14036: LD_VAR 0 2
14040: PPUSH
14041: CALL_OW 12
14045: ARRAY
14046: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14047: LD_VAR 0 3
14051: PPUSH
14052: CALL_OW 255
14056: PUSH
14057: LD_INT 1
14059: EQUAL
14060: IFFALSE 14071
// CenterNowOnUnits ( target ) ;
14062: LD_VAR 0 3
14066: PPUSH
14067: CALL_OW 87
// SetLives ( target , 0 ) ;
14071: LD_VAR 0 3
14075: PPUSH
14076: LD_INT 0
14078: PPUSH
14079: CALL_OW 234
// end ;
14083: PPOPN 3
14085: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14086: LD_EXP 23
14090: NOT
14091: PUSH
14092: LD_EXP 31
14096: AND
14097: IFFALSE 14613
14099: GO 14101
14101: DISABLE
14102: LD_INT 0
14104: PPUSH
14105: PPUSH
14106: PPUSH
// begin uc_side := 7 ;
14107: LD_ADDR_OWVAR 20
14111: PUSH
14112: LD_INT 7
14114: ST_TO_ADDR
// uc_nation := 1 ;
14115: LD_ADDR_OWVAR 21
14119: PUSH
14120: LD_INT 1
14122: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14123: LD_ADDR_VAR 0 3
14127: PUSH
14128: LD_INT 125
14130: PUSH
14131: LD_INT 163
14133: PUSH
14134: EMPTY
14135: LIST
14136: LIST
14137: PUSH
14138: LD_INT 185
14140: PUSH
14141: LD_INT 168
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_INT 111
14150: PUSH
14151: LD_INT 97
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: PUSH
14158: LD_INT 94
14160: PUSH
14161: LD_INT 114
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: PPUSH
14174: CALL 107514 0 1
14178: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14179: LD_ADDR_EXP 96
14183: PUSH
14184: EMPTY
14185: ST_TO_ADDR
// for i = 1 to Difficulty do
14186: LD_ADDR_VAR 0 1
14190: PUSH
14191: DOUBLE
14192: LD_INT 1
14194: DEC
14195: ST_TO_ADDR
14196: LD_OWVAR 67
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14360
// begin InitHc ;
14204: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14208: LD_INT 0
14210: PPUSH
14211: LD_INT 8
14213: PPUSH
14214: CALL_OW 381
// un := CreateHuman ;
14218: LD_ADDR_VAR 0 2
14222: PUSH
14223: CALL_OW 44
14227: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14228: LD_VAR 0 2
14232: PPUSH
14233: LD_INT 258
14235: PPUSH
14236: LD_INT 267
14238: PPUSH
14239: LD_INT 4
14241: PPUSH
14242: LD_INT 0
14244: PPUSH
14245: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14249: LD_ADDR_EXP 96
14253: PUSH
14254: LD_EXP 96
14258: PUSH
14259: LD_VAR 0 2
14263: UNION
14264: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14265: LD_VAR 0 2
14269: PPUSH
14270: LD_VAR 0 3
14274: PUSH
14275: LD_VAR 0 1
14279: ARRAY
14280: PUSH
14281: LD_INT 1
14283: ARRAY
14284: PPUSH
14285: LD_VAR 0 3
14289: PUSH
14290: LD_VAR 0 1
14294: ARRAY
14295: PUSH
14296: LD_INT 2
14298: ARRAY
14299: PPUSH
14300: LD_INT 4
14302: PPUSH
14303: LD_INT 1
14305: PPUSH
14306: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14310: LD_VAR 0 2
14314: PPUSH
14315: LD_VAR 0 3
14319: PUSH
14320: LD_VAR 0 1
14324: ARRAY
14325: PUSH
14326: LD_INT 1
14328: ARRAY
14329: PPUSH
14330: LD_VAR 0 3
14334: PUSH
14335: LD_VAR 0 1
14339: ARRAY
14340: PUSH
14341: LD_INT 2
14343: ARRAY
14344: PPUSH
14345: CALL_OW 171
// AddComInvisible ( un ) ;
14349: LD_VAR 0 2
14353: PPUSH
14354: CALL_OW 212
// end ;
14358: GO 14201
14360: POP
14361: POP
// repeat wait ( 0 0$45 ) ;
14362: LD_INT 1575
14364: PPUSH
14365: CALL_OW 67
// for i in allianceSpecialForce do
14369: LD_ADDR_VAR 0 1
14373: PUSH
14374: LD_EXP 96
14378: PUSH
14379: FOR_IN
14380: IFFALSE 14598
// begin if IsInvisible ( i ) then
14382: LD_VAR 0 1
14386: PPUSH
14387: CALL_OW 571
14391: IFFALSE 14567
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 22
14400: PUSH
14401: LD_INT 1
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: PUSH
14408: LD_INT 50
14410: PUSH
14411: EMPTY
14412: LIST
14413: PUSH
14414: LD_INT 56
14416: PUSH
14417: EMPTY
14418: LIST
14419: PUSH
14420: LD_INT 91
14422: PUSH
14423: LD_VAR 0 1
14427: PUSH
14428: LD_INT 25
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: LIST
14435: PUSH
14436: LD_INT 2
14438: PUSH
14439: LD_INT 25
14441: PUSH
14442: LD_INT 1
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 25
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 25
14461: PUSH
14462: LD_INT 3
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: LD_INT 25
14471: PUSH
14472: LD_INT 4
14474: PUSH
14475: EMPTY
14476: LIST
14477: LIST
14478: PUSH
14479: LD_INT 25
14481: PUSH
14482: LD_INT 5
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 25
14491: PUSH
14492: LD_INT 8
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: PPUSH
14515: CALL_OW 69
14519: ST_TO_ADDR
// if not tmp then
14520: LD_VAR 0 3
14524: NOT
14525: IFFALSE 14529
// continue ;
14527: GO 14379
// if Prob ( 30 * Difficulty ) then
14529: LD_INT 30
14531: PUSH
14532: LD_OWVAR 67
14536: MUL
14537: PPUSH
14538: CALL_OW 13
14542: IFFALSE 14567
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14544: LD_VAR 0 3
14548: PUSH
14549: LD_INT 1
14551: PPUSH
14552: LD_VAR 0 3
14556: PPUSH
14557: CALL_OW 12
14561: ARRAY
14562: PPUSH
14563: CALL 34808 0 1
// end ; if IsDead ( i ) then
14567: LD_VAR 0 1
14571: PPUSH
14572: CALL_OW 301
14576: IFFALSE 14596
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14578: LD_ADDR_EXP 96
14582: PUSH
14583: LD_EXP 96
14587: PUSH
14588: LD_VAR 0 1
14592: DIFF
14593: ST_TO_ADDR
// continue ;
14594: GO 14379
// end ; end ;
14596: GO 14379
14598: POP
14599: POP
// until allianceDestroyed or not allianceSpecialForce ;
14600: LD_EXP 23
14604: PUSH
14605: LD_EXP 96
14609: NOT
14610: OR
14611: IFFALSE 14362
// end ;
14613: PPOPN 3
14615: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14616: LD_EXP 31
14620: PUSH
14621: LD_INT 22
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: LD_INT 35
14636: PUSH
14637: LD_INT 8
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PUSH
14644: LD_INT 34
14646: PUSH
14647: LD_INT 8
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: LIST
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PPUSH
14663: CALL_OW 69
14667: AND
14668: IFFALSE 15068
14670: GO 14672
14672: DISABLE
14673: LD_INT 0
14675: PPUSH
14676: PPUSH
14677: PPUSH
14678: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14679: LD_ADDR_VAR 0 1
14683: PUSH
14684: DOUBLE
14685: LD_INT 1
14687: DEC
14688: ST_TO_ADDR
14689: LD_INT 6
14691: PUSH
14692: LD_INT 8
14694: PUSH
14695: LD_INT 10
14697: PUSH
14698: LD_INT 12
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: PUSH
14707: LD_OWVAR 67
14711: ARRAY
14712: PUSH
14713: FOR_TO
14714: IFFALSE 14906
// begin uc_side := 7 ;
14716: LD_ADDR_OWVAR 20
14720: PUSH
14721: LD_INT 7
14723: ST_TO_ADDR
// uc_nation := 1 ;
14724: LD_ADDR_OWVAR 21
14728: PUSH
14729: LD_INT 1
14731: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14732: LD_INT 5
14734: PPUSH
14735: LD_INT 3
14737: PPUSH
14738: LD_INT 2
14740: PUSH
14741: LD_INT 3
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: PUSH
14748: LD_INT 1
14750: PPUSH
14751: LD_INT 2
14753: PPUSH
14754: CALL_OW 12
14758: ARRAY
14759: PPUSH
14760: LD_INT 6
14762: PUSH
14763: LD_INT 9
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: PUSH
14770: LD_INT 1
14772: PPUSH
14773: LD_INT 2
14775: PPUSH
14776: CALL_OW 12
14780: ARRAY
14781: PPUSH
14782: LD_INT 100
14784: PPUSH
14785: CALL 74558 0 5
// un := CreateVehicle ;
14789: LD_ADDR_VAR 0 2
14793: PUSH
14794: CALL_OW 45
14798: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14799: LD_VAR 0 2
14803: PPUSH
14804: LD_INT 4
14806: PPUSH
14807: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14811: LD_VAR 0 2
14815: PPUSH
14816: LD_INT 307
14818: PPUSH
14819: LD_INT 219
14821: PPUSH
14822: LD_INT 6
14824: PPUSH
14825: LD_INT 0
14827: PPUSH
14828: CALL_OW 50
// if GetControl ( un ) = control_remote then
14832: LD_VAR 0 2
14836: PPUSH
14837: CALL_OW 263
14841: PUSH
14842: LD_INT 2
14844: EQUAL
14845: IFFALSE 14856
// Connect ( un ) ;
14847: LD_VAR 0 2
14851: PPUSH
14852: CALL 78026 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14856: LD_VAR 0 2
14860: PPUSH
14861: LD_INT 124
14863: PPUSH
14864: LD_INT 92
14866: PPUSH
14867: LD_INT 12
14869: PPUSH
14870: LD_INT 1
14872: PPUSH
14873: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14877: LD_ADDR_VAR 0 3
14881: PUSH
14882: LD_VAR 0 3
14886: PPUSH
14887: LD_VAR 0 2
14891: PPUSH
14892: CALL 107409 0 2
14896: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14897: LD_INT 10
14899: PPUSH
14900: CALL_OW 67
// end ;
14904: GO 14713
14906: POP
14907: POP
// repeat wait ( 0 0$2 ) ;
14908: LD_INT 70
14910: PPUSH
14911: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14915: LD_ADDR_VAR 0 4
14919: PUSH
14920: LD_INT 22
14922: PUSH
14923: LD_INT 1
14925: PUSH
14926: EMPTY
14927: LIST
14928: LIST
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 8
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: PUSH
14940: EMPTY
14941: LIST
14942: LIST
14943: PPUSH
14944: CALL_OW 69
14948: ST_TO_ADDR
// if not e then
14949: LD_VAR 0 4
14953: NOT
14954: IFFALSE 14990
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14956: LD_ADDR_VAR 0 4
14960: PUSH
14961: LD_INT 22
14963: PUSH
14964: LD_INT 1
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: LD_INT 21
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PUSH
14981: EMPTY
14982: LIST
14983: LIST
14984: PPUSH
14985: CALL_OW 69
14989: ST_TO_ADDR
// for i in tmp do
14990: LD_ADDR_VAR 0 1
14994: PUSH
14995: LD_VAR 0 3
14999: PUSH
15000: FOR_IN
15001: IFFALSE 15059
// if not IsOK ( i ) then
15003: LD_VAR 0 1
15007: PPUSH
15008: CALL_OW 302
15012: NOT
15013: IFFALSE 15033
// tmp := tmp diff i else
15015: LD_ADDR_VAR 0 3
15019: PUSH
15020: LD_VAR 0 3
15024: PUSH
15025: LD_VAR 0 1
15029: DIFF
15030: ST_TO_ADDR
15031: GO 15057
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15033: LD_VAR 0 1
15037: PPUSH
15038: LD_VAR 0 4
15042: PPUSH
15043: LD_VAR 0 1
15047: PPUSH
15048: CALL_OW 74
15052: PPUSH
15053: CALL_OW 115
15057: GO 15000
15059: POP
15060: POP
// until not tmp ;
15061: LD_VAR 0 3
15065: NOT
15066: IFFALSE 14908
// end ;
15068: PPOPN 4
15070: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15071: LD_EXP 23
15075: NOT
15076: PUSH
15077: LD_EXP 31
15081: AND
15082: IFFALSE 16156
15084: GO 15086
15086: DISABLE
15087: LD_INT 0
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
15093: PPUSH
// begin enable ;
15094: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15095: LD_INT 22
15097: PUSH
15098: LD_INT 7
15100: PUSH
15101: EMPTY
15102: LIST
15103: LIST
15104: PUSH
15105: LD_INT 30
15107: PUSH
15108: LD_INT 3
15110: PUSH
15111: EMPTY
15112: LIST
15113: LIST
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: NOT
15124: IFFALSE 15128
// exit ;
15126: GO 16156
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15128: LD_ADDR_VAR 0 4
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_INT 7
15138: PUSH
15139: EMPTY
15140: LIST
15141: LIST
15142: PUSH
15143: LD_INT 30
15145: PUSH
15146: LD_INT 34
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: PPUSH
15157: CALL_OW 69
15161: ST_TO_ADDR
// if Prob ( 40 ) then
15162: LD_INT 40
15164: PPUSH
15165: CALL_OW 13
15169: IFFALSE 15315
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15171: LD_INT 1
15173: PPUSH
15174: LD_INT 5
15176: PUSH
15177: LD_INT 3
15179: PUSH
15180: LD_INT 2
15182: PUSH
15183: LD_INT 6
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 5
15194: PUSH
15195: LD_INT 3
15197: PUSH
15198: LD_INT 2
15200: PUSH
15201: LD_INT 6
15203: PUSH
15204: EMPTY
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: PUSH
15210: LD_INT 5
15212: PUSH
15213: LD_INT 3
15215: PUSH
15216: LD_INT 2
15218: PUSH
15219: LD_INT 6
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: PUSH
15228: LD_INT 5
15230: PUSH
15231: LD_INT 3
15233: PUSH
15234: LD_INT 2
15236: PUSH
15237: LD_INT 9
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 24
15248: PUSH
15249: LD_INT 3
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: LD_INT 45
15257: PUSH
15258: EMPTY
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: PUSH
15264: LD_INT 24
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: LD_INT 3
15272: PUSH
15273: LD_INT 47
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: LIST
15280: LIST
15281: PUSH
15282: LD_INT 24
15284: PUSH
15285: LD_INT 3
15287: PUSH
15288: LD_INT 3
15290: PUSH
15291: LD_INT 45
15293: PUSH
15294: EMPTY
15295: LIST
15296: LIST
15297: LIST
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: PPUSH
15309: CALL 63292 0 2
// end else
15313: GO 15457
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15315: LD_INT 1
15317: PPUSH
15318: LD_INT 24
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: LD_INT 3
15326: PUSH
15327: LD_INT 47
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: PUSH
15336: LD_INT 24
15338: PUSH
15339: LD_INT 3
15341: PUSH
15342: LD_INT 3
15344: PUSH
15345: LD_INT 47
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 5
15356: PUSH
15357: LD_INT 3
15359: PUSH
15360: LD_INT 2
15362: PUSH
15363: LD_INT 9
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: PUSH
15372: LD_INT 5
15374: PUSH
15375: LD_INT 3
15377: PUSH
15378: LD_INT 2
15380: PUSH
15381: LD_INT 9
15383: PUSH
15384: EMPTY
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: PUSH
15390: LD_INT 5
15392: PUSH
15393: LD_INT 3
15395: PUSH
15396: LD_INT 2
15398: PUSH
15399: LD_INT 9
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 24
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: LD_INT 3
15416: PUSH
15417: LD_INT 45
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: PUSH
15426: LD_INT 24
15428: PUSH
15429: LD_INT 1
15431: PUSH
15432: LD_INT 3
15434: PUSH
15435: LD_INT 45
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: PPUSH
15453: CALL 63292 0 2
// end ; wait ( 2 2$00 ) ;
15457: LD_INT 4200
15459: PPUSH
15460: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15464: LD_ADDR_VAR 0 2
15468: PUSH
15469: LD_INT 22
15471: PUSH
15472: LD_INT 7
15474: PUSH
15475: EMPTY
15476: LIST
15477: LIST
15478: PUSH
15479: LD_INT 21
15481: PUSH
15482: LD_INT 2
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: LD_INT 34
15494: PUSH
15495: LD_INT 13
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: EMPTY
15503: LIST
15504: LIST
15505: PUSH
15506: LD_INT 3
15508: PUSH
15509: LD_INT 34
15511: PUSH
15512: LD_INT 12
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: PUSH
15523: LD_INT 3
15525: PUSH
15526: LD_INT 34
15528: PUSH
15529: LD_INT 51
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PUSH
15536: EMPTY
15537: LIST
15538: LIST
15539: PUSH
15540: LD_INT 3
15542: PUSH
15543: LD_INT 34
15545: PUSH
15546: LD_INT 52
15548: PUSH
15549: EMPTY
15550: LIST
15551: LIST
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: PPUSH
15565: CALL_OW 69
15569: PUSH
15570: LD_EXP 124
15574: PUSH
15575: LD_INT 1
15577: ARRAY
15578: DIFF
15579: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15580: LD_ADDR_EXP 121
15584: PUSH
15585: LD_EXP 121
15589: PPUSH
15590: LD_INT 1
15592: PPUSH
15593: LD_EXP 121
15597: PUSH
15598: LD_INT 1
15600: ARRAY
15601: PUSH
15602: LD_VAR 0 2
15606: DIFF
15607: PPUSH
15608: CALL_OW 1
15612: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15613: LD_ADDR_VAR 0 3
15617: PUSH
15618: LD_INT 0
15620: PPUSH
15621: LD_INT 1
15623: PPUSH
15624: CALL_OW 12
15628: ST_TO_ADDR
// p := 0 ;
15629: LD_ADDR_VAR 0 5
15633: PUSH
15634: LD_INT 0
15636: ST_TO_ADDR
// if target then
15637: LD_VAR 0 3
15641: IFFALSE 15832
// begin for i in tmp do
15643: LD_ADDR_VAR 0 1
15647: PUSH
15648: LD_VAR 0 2
15652: PUSH
15653: FOR_IN
15654: IFFALSE 15679
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15656: LD_VAR 0 1
15660: PPUSH
15661: LD_INT 179
15663: PPUSH
15664: LD_INT 209
15666: PPUSH
15667: LD_INT 8
15669: PPUSH
15670: LD_INT 1
15672: PPUSH
15673: CALL_OW 483
15677: GO 15653
15679: POP
15680: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15681: LD_ADDR_VAR 0 2
15685: PUSH
15686: LD_VAR 0 2
15690: PPUSH
15691: LD_INT 24
15693: PUSH
15694: LD_INT 250
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PPUSH
15701: CALL_OW 72
15705: ST_TO_ADDR
// for i in tmp do
15706: LD_ADDR_VAR 0 1
15710: PUSH
15711: LD_VAR 0 2
15715: PUSH
15716: FOR_IN
15717: IFFALSE 15757
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15719: LD_VAR 0 1
15723: PPUSH
15724: LD_INT 179
15726: PPUSH
15727: LD_INT 209
15729: PPUSH
15730: CALL_OW 297
15734: PUSH
15735: LD_INT 9
15737: GREATER
15738: IFFALSE 15755
// ComMoveXY ( i , 179 , 209 ) ;
15740: LD_VAR 0 1
15744: PPUSH
15745: LD_INT 179
15747: PPUSH
15748: LD_INT 209
15750: PPUSH
15751: CALL_OW 111
15755: GO 15716
15757: POP
15758: POP
// wait ( 0 0$1 ) ;
15759: LD_INT 35
15761: PPUSH
15762: CALL_OW 67
// p := Inc ( p ) ;
15766: LD_ADDR_VAR 0 5
15770: PUSH
15771: LD_VAR 0 5
15775: PPUSH
15776: CALL 108770 0 1
15780: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15781: LD_VAR 0 2
15785: PPUSH
15786: LD_INT 92
15788: PUSH
15789: LD_INT 179
15791: PUSH
15792: LD_INT 209
15794: PUSH
15795: LD_INT 9
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: LIST
15802: LIST
15803: PPUSH
15804: CALL_OW 72
15808: PUSH
15809: LD_VAR 0 2
15813: PUSH
15814: LD_INT 1
15816: MINUS
15817: GREATEREQUAL
15818: PUSH
15819: LD_VAR 0 5
15823: PUSH
15824: LD_INT 30
15826: GREATER
15827: OR
15828: IFFALSE 15681
// end else
15830: GO 16019
// begin for i in tmp do
15832: LD_ADDR_VAR 0 1
15836: PUSH
15837: LD_VAR 0 2
15841: PUSH
15842: FOR_IN
15843: IFFALSE 15868
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15845: LD_VAR 0 1
15849: PPUSH
15850: LD_INT 285
15852: PPUSH
15853: LD_INT 163
15855: PPUSH
15856: LD_INT 8
15858: PPUSH
15859: LD_INT 1
15861: PPUSH
15862: CALL_OW 483
15866: GO 15842
15868: POP
15869: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15870: LD_ADDR_VAR 0 2
15874: PUSH
15875: LD_VAR 0 2
15879: PPUSH
15880: LD_INT 24
15882: PUSH
15883: LD_INT 250
15885: PUSH
15886: EMPTY
15887: LIST
15888: LIST
15889: PPUSH
15890: CALL_OW 72
15894: ST_TO_ADDR
// for i in tmp do
15895: LD_ADDR_VAR 0 1
15899: PUSH
15900: LD_VAR 0 2
15904: PUSH
15905: FOR_IN
15906: IFFALSE 15946
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15908: LD_VAR 0 1
15912: PPUSH
15913: LD_INT 285
15915: PPUSH
15916: LD_INT 163
15918: PPUSH
15919: CALL_OW 297
15923: PUSH
15924: LD_INT 9
15926: GREATER
15927: IFFALSE 15944
// ComMoveXY ( i , 285 , 163 ) ;
15929: LD_VAR 0 1
15933: PPUSH
15934: LD_INT 285
15936: PPUSH
15937: LD_INT 163
15939: PPUSH
15940: CALL_OW 111
15944: GO 15905
15946: POP
15947: POP
// wait ( 0 0$1 ) ;
15948: LD_INT 35
15950: PPUSH
15951: CALL_OW 67
// p := Inc ( p ) ;
15955: LD_ADDR_VAR 0 5
15959: PUSH
15960: LD_VAR 0 5
15964: PPUSH
15965: CALL 108770 0 1
15969: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15970: LD_VAR 0 2
15974: PPUSH
15975: LD_INT 92
15977: PUSH
15978: LD_INT 285
15980: PUSH
15981: LD_INT 163
15983: PUSH
15984: LD_INT 9
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: PPUSH
15993: CALL_OW 72
15997: PUSH
15998: LD_VAR 0 2
16002: PUSH
16003: LD_INT 1
16005: MINUS
16006: GREATEREQUAL
16007: PUSH
16008: LD_VAR 0 5
16012: PUSH
16013: LD_INT 30
16015: GREATER
16016: OR
16017: IFFALSE 15870
// end ; repeat wait ( 0 0$1 ) ;
16019: LD_INT 35
16021: PPUSH
16022: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16026: LD_ADDR_VAR 0 2
16030: PUSH
16031: LD_VAR 0 2
16035: PPUSH
16036: LD_INT 50
16038: PUSH
16039: EMPTY
16040: LIST
16041: PPUSH
16042: CALL_OW 72
16046: ST_TO_ADDR
// for i in tmp do
16047: LD_ADDR_VAR 0 1
16051: PUSH
16052: LD_VAR 0 2
16056: PUSH
16057: FOR_IN
16058: IFFALSE 16147
// if GetWeapon ( i ) = ru_time_lapser then
16060: LD_VAR 0 1
16064: PPUSH
16065: CALL_OW 264
16069: PUSH
16070: LD_INT 49
16072: EQUAL
16073: IFFALSE 16111
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16075: LD_VAR 0 1
16079: PPUSH
16080: LD_INT 81
16082: PUSH
16083: LD_INT 7
16085: PUSH
16086: EMPTY
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL_OW 69
16094: PPUSH
16095: LD_VAR 0 1
16099: PPUSH
16100: CALL_OW 74
16104: PPUSH
16105: CALL_OW 112
16109: GO 16145
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16111: LD_VAR 0 1
16115: PPUSH
16116: LD_INT 81
16118: PUSH
16119: LD_INT 7
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PPUSH
16126: CALL_OW 69
16130: PPUSH
16131: LD_VAR 0 1
16135: PPUSH
16136: CALL_OW 74
16140: PPUSH
16141: CALL_OW 115
16145: GO 16057
16147: POP
16148: POP
// until not tmp ;
16149: LD_VAR 0 2
16153: NOT
16154: IFFALSE 16019
// end ;
16156: PPOPN 5
16158: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16159: LD_EXP 31
16163: PUSH
16164: LD_EXP 79
16168: PPUSH
16169: CALL_OW 302
16173: AND
16174: PUSH
16175: LD_OWVAR 67
16179: PUSH
16180: LD_INT 2
16182: GREATER
16183: AND
16184: IFFALSE 16284
16186: GO 16188
16188: DISABLE
// begin enable ;
16189: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16190: LD_EXP 79
16194: PPUSH
16195: LD_INT 245
16197: PPUSH
16198: LD_INT 234
16200: PPUSH
16201: CALL_OW 297
16205: PUSH
16206: LD_INT 6
16208: GREATER
16209: IFFALSE 16228
// ComMoveXY ( Roth , 245 , 234 ) else
16211: LD_EXP 79
16215: PPUSH
16216: LD_INT 245
16218: PPUSH
16219: LD_INT 234
16221: PPUSH
16222: CALL_OW 111
16226: GO 16284
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16228: LD_EXP 79
16232: PPUSH
16233: LD_INT 259
16235: PUSH
16236: LD_INT 235
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: PUSH
16243: LD_INT 252
16245: PUSH
16246: LD_INT 209
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: PUSH
16253: LD_INT 275
16255: PUSH
16256: LD_INT 235
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: LIST
16267: PUSH
16268: LD_INT 1
16270: PPUSH
16271: LD_INT 3
16273: PPUSH
16274: CALL_OW 12
16278: ARRAY
16279: PPUSH
16280: CALL 111557 0 2
// end ; end_of_file
16284: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16285: LD_INT 0
16287: PPUSH
16288: PPUSH
16289: PPUSH
16290: PPUSH
// missionStage := 13 ;
16291: LD_ADDR_EXP 15
16295: PUSH
16296: LD_INT 13
16298: ST_TO_ADDR
// uc_side := 2 ;
16299: LD_ADDR_OWVAR 20
16303: PUSH
16304: LD_INT 2
16306: ST_TO_ADDR
// uc_nation := 2 ;
16307: LD_ADDR_OWVAR 21
16311: PUSH
16312: LD_INT 2
16314: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16315: LD_ADDR_EXP 97
16319: PUSH
16320: LD_STRING Omar
16322: PPUSH
16323: CALL_OW 25
16327: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16328: LD_EXP 97
16332: PPUSH
16333: LD_INT 4
16335: PPUSH
16336: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16340: LD_EXP 97
16344: PPUSH
16345: LD_INT 242
16347: PPUSH
16348: LD_INT 75
16350: PPUSH
16351: LD_INT 0
16353: PPUSH
16354: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16358: LD_ADDR_EXP 98
16362: PUSH
16363: LD_STRING Heike
16365: PPUSH
16366: CALL_OW 25
16370: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16371: LD_INT 14
16373: PPUSH
16374: LD_INT 3
16376: PPUSH
16377: LD_INT 1
16379: PPUSH
16380: LD_INT 27
16382: PPUSH
16383: LD_INT 100
16385: PPUSH
16386: CALL 74558 0 5
// veh := CreateVehicle ;
16390: LD_ADDR_VAR 0 3
16394: PUSH
16395: CALL_OW 45
16399: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16400: LD_VAR 0 3
16404: PPUSH
16405: LD_INT 2
16407: NEG
16408: PPUSH
16409: CALL_OW 242
// SetDir ( veh , 4 ) ;
16413: LD_VAR 0 3
16417: PPUSH
16418: LD_INT 4
16420: PPUSH
16421: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: LD_INT 241
16432: PPUSH
16433: LD_INT 72
16435: PPUSH
16436: LD_INT 0
16438: PPUSH
16439: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16443: LD_EXP 98
16447: PPUSH
16448: LD_VAR 0 3
16452: PPUSH
16453: CALL_OW 52
// if KhatamStatus then
16457: LD_EXP 8
16461: IFFALSE 16524
// begin Khatam := NewCharacter ( Khatam ) ;
16463: LD_ADDR_EXP 99
16467: PUSH
16468: LD_STRING Khatam
16470: PPUSH
16471: CALL_OW 25
16475: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16476: LD_EXP 99
16480: PPUSH
16481: LD_INT 245
16483: PPUSH
16484: LD_INT 78
16486: PPUSH
16487: LD_INT 3
16489: PPUSH
16490: LD_INT 0
16492: PPUSH
16493: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16497: LD_EXP 99
16501: PPUSH
16502: LD_INT 4
16504: PPUSH
16505: LD_INT 10
16507: PPUSH
16508: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16512: LD_EXP 99
16516: PPUSH
16517: LD_INT 4
16519: PPUSH
16520: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16524: LD_ADDR_VAR 0 2
16528: PUSH
16529: DOUBLE
16530: LD_INT 1
16532: DEC
16533: ST_TO_ADDR
16534: LD_INT 2
16536: PUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 3
16542: PUSH
16543: LD_INT 3
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: LIST
16550: LIST
16551: PUSH
16552: LD_OWVAR 67
16556: ARRAY
16557: PUSH
16558: FOR_TO
16559: IFFALSE 16625
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16561: LD_INT 0
16563: PPUSH
16564: LD_INT 6
16566: PUSH
16567: LD_OWVAR 67
16571: PLUS
16572: PPUSH
16573: CALL_OW 384
// un := CreateHuman ;
16577: LD_ADDR_VAR 0 4
16581: PUSH
16582: CALL_OW 44
16586: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16587: LD_VAR 0 4
16591: PPUSH
16592: LD_INT 28
16594: PUSH
16595: LD_INT 29
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_VAR 0 2
16606: PUSH
16607: LD_INT 2
16609: MOD
16610: PUSH
16611: LD_INT 1
16613: PLUS
16614: ARRAY
16615: PPUSH
16616: LD_INT 0
16618: PPUSH
16619: CALL_OW 49
// end ;
16623: GO 16558
16625: POP
16626: POP
// for i = 1 to 6 do
16627: LD_ADDR_VAR 0 2
16631: PUSH
16632: DOUBLE
16633: LD_INT 1
16635: DEC
16636: ST_TO_ADDR
16637: LD_INT 6
16639: PUSH
16640: FOR_TO
16641: IFFALSE 16686
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16643: LD_INT 0
16645: PPUSH
16646: LD_INT 6
16648: PUSH
16649: LD_OWVAR 67
16653: PLUS
16654: PPUSH
16655: CALL_OW 381
// un := CreateHuman ;
16659: LD_ADDR_VAR 0 4
16663: PUSH
16664: CALL_OW 44
16668: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16669: LD_VAR 0 4
16673: PPUSH
16674: LD_INT 32
16676: PPUSH
16677: LD_INT 0
16679: PPUSH
16680: CALL_OW 49
// end ;
16684: GO 16640
16686: POP
16687: POP
// for i = 1 to 3 do
16688: LD_ADDR_VAR 0 2
16692: PUSH
16693: DOUBLE
16694: LD_INT 1
16696: DEC
16697: ST_TO_ADDR
16698: LD_INT 3
16700: PUSH
16701: FOR_TO
16702: IFFALSE 16750
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16704: LD_INT 0
16706: PPUSH
16707: LD_INT 8
16709: PPUSH
16710: LD_INT 6
16712: PUSH
16713: LD_OWVAR 67
16717: PLUS
16718: PPUSH
16719: CALL_OW 380
// un := CreateHuman ;
16723: LD_ADDR_VAR 0 4
16727: PUSH
16728: CALL_OW 44
16732: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16733: LD_VAR 0 4
16737: PPUSH
16738: LD_INT 32
16740: PPUSH
16741: LD_INT 0
16743: PPUSH
16744: CALL_OW 49
// end ;
16748: GO 16701
16750: POP
16751: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16752: LD_ADDR_VAR 0 2
16756: PUSH
16757: DOUBLE
16758: LD_INT 1
16760: DEC
16761: ST_TO_ADDR
16762: LD_INT 2
16764: PUSH
16765: LD_INT 3
16767: PUSH
16768: LD_INT 4
16770: PUSH
16771: LD_INT 4
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: PUSH
16780: LD_OWVAR 67
16784: ARRAY
16785: PUSH
16786: FOR_TO
16787: IFFALSE 16877
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16789: LD_INT 14
16791: PPUSH
16792: LD_INT 2
16794: PPUSH
16795: LD_INT 1
16797: PPUSH
16798: LD_INT 28
16800: PPUSH
16801: LD_INT 80
16803: PPUSH
16804: CALL 74558 0 5
// veh := CreateVehicle ;
16808: LD_ADDR_VAR 0 3
16812: PUSH
16813: CALL_OW 45
16817: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16818: LD_VAR 0 3
16822: PPUSH
16823: LD_INT 3
16825: PPUSH
16826: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16830: LD_VAR 0 3
16834: PPUSH
16835: LD_INT 29
16837: PPUSH
16838: LD_INT 0
16840: PPUSH
16841: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16845: LD_INT 0
16847: PPUSH
16848: LD_INT 6
16850: PUSH
16851: LD_OWVAR 67
16855: PLUS
16856: PPUSH
16857: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16861: CALL_OW 44
16865: PPUSH
16866: LD_VAR 0 3
16870: PPUSH
16871: CALL_OW 52
// end ;
16875: GO 16786
16877: POP
16878: POP
// for i = 1 to 5 + Difficulty do
16879: LD_ADDR_VAR 0 2
16883: PUSH
16884: DOUBLE
16885: LD_INT 1
16887: DEC
16888: ST_TO_ADDR
16889: LD_INT 5
16891: PUSH
16892: LD_OWVAR 67
16896: PLUS
16897: PUSH
16898: FOR_TO
16899: IFFALSE 17026
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16901: LD_INT 14
16903: PPUSH
16904: LD_INT 1
16906: PPUSH
16907: LD_INT 3
16909: PPUSH
16910: CALL_OW 12
16914: PPUSH
16915: LD_INT 1
16917: PPUSH
16918: LD_INT 28
16920: PUSH
16921: LD_INT 26
16923: PUSH
16924: LD_INT 27
16926: PUSH
16927: LD_INT 25
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: PUSH
16936: LD_VAR 0 2
16940: PUSH
16941: LD_INT 4
16943: MOD
16944: PUSH
16945: LD_INT 1
16947: PLUS
16948: ARRAY
16949: PPUSH
16950: LD_INT 80
16952: PPUSH
16953: CALL 74558 0 5
// veh := CreateVehicle ;
16957: LD_ADDR_VAR 0 3
16961: PUSH
16962: CALL_OW 45
16966: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16967: LD_VAR 0 3
16971: PPUSH
16972: LD_INT 4
16974: PPUSH
16975: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16979: LD_VAR 0 3
16983: PPUSH
16984: LD_INT 28
16986: PPUSH
16987: LD_INT 0
16989: PPUSH
16990: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16994: LD_INT 0
16996: PPUSH
16997: LD_INT 6
16999: PUSH
17000: LD_OWVAR 67
17004: PLUS
17005: PPUSH
17006: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17010: CALL_OW 44
17014: PPUSH
17015: LD_VAR 0 3
17019: PPUSH
17020: CALL_OW 52
// end ;
17024: GO 16898
17026: POP
17027: POP
// for i = 1 to Difficulty do
17028: LD_ADDR_VAR 0 2
17032: PUSH
17033: DOUBLE
17034: LD_INT 1
17036: DEC
17037: ST_TO_ADDR
17038: LD_OWVAR 67
17042: PUSH
17043: FOR_TO
17044: IFFALSE 17104
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17046: LD_INT 14
17048: PPUSH
17049: LD_INT 3
17051: PPUSH
17052: LD_INT 5
17054: PPUSH
17055: LD_INT 29
17057: PPUSH
17058: LD_INT 80
17060: PPUSH
17061: CALL 74558 0 5
// veh := CreateVehicle ;
17065: LD_ADDR_VAR 0 3
17069: PUSH
17070: CALL_OW 45
17074: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17075: LD_VAR 0 3
17079: PPUSH
17080: LD_INT 4
17082: PPUSH
17083: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17087: LD_VAR 0 3
17091: PPUSH
17092: LD_INT 28
17094: PPUSH
17095: LD_INT 0
17097: PPUSH
17098: CALL_OW 49
// end ;
17102: GO 17043
17104: POP
17105: POP
// end ;
17106: LD_VAR 0 1
17110: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17111: LD_INT 22
17113: PUSH
17114: LD_INT 2
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PPUSH
17121: CALL_OW 69
17125: IFFALSE 17504
17127: GO 17129
17129: DISABLE
17130: LD_INT 0
17132: PPUSH
17133: PPUSH
17134: PPUSH
17135: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17136: LD_ADDR_VAR 0 3
17140: PUSH
17141: LD_INT 22
17143: PUSH
17144: LD_INT 2
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: PUSH
17151: LD_INT 25
17153: PUSH
17154: LD_INT 4
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PPUSH
17165: CALL_OW 69
17169: PUSH
17170: LD_EXP 99
17174: DIFF
17175: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17176: LD_ADDR_VAR 0 2
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PPUSH
17191: CALL_OW 69
17195: PUSH
17196: LD_EXP 99
17200: PUSH
17201: LD_VAR 0 3
17205: UNION
17206: DIFF
17207: ST_TO_ADDR
// if Khatam then
17208: LD_EXP 99
17212: IFFALSE 17229
// ComMoveXY ( Khatam , 211 , 92 ) ;
17214: LD_EXP 99
17218: PPUSH
17219: LD_INT 211
17221: PPUSH
17222: LD_INT 92
17224: PPUSH
17225: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17229: LD_INT 197
17231: PPUSH
17232: LD_INT 80
17234: PPUSH
17235: LD_INT 2
17237: PPUSH
17238: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17242: LD_INT 213
17244: PPUSH
17245: LD_INT 90
17247: PPUSH
17248: LD_INT 2
17250: PPUSH
17251: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17255: LD_INT 215
17257: PPUSH
17258: LD_INT 129
17260: PPUSH
17261: LD_INT 2
17263: PPUSH
17264: CALL_OW 441
// if sci then
17268: LD_VAR 0 3
17272: IFFALSE 17293
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17274: LD_VAR 0 3
17278: PUSH
17279: LD_INT 1
17281: ARRAY
17282: PPUSH
17283: LD_INT 197
17285: PPUSH
17286: LD_INT 80
17288: PPUSH
17289: CALL_OW 158
// if sci > 1 then
17293: LD_VAR 0 3
17297: PUSH
17298: LD_INT 1
17300: GREATER
17301: IFFALSE 17322
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17303: LD_VAR 0 3
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_INT 213
17314: PPUSH
17315: LD_INT 90
17317: PPUSH
17318: CALL_OW 158
// if sci > 2 then
17322: LD_VAR 0 3
17326: PUSH
17327: LD_INT 2
17329: GREATER
17330: IFFALSE 17351
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17332: LD_VAR 0 3
17336: PUSH
17337: LD_INT 3
17339: ARRAY
17340: PPUSH
17341: LD_INT 215
17343: PPUSH
17344: LD_INT 129
17346: PPUSH
17347: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17351: LD_VAR 0 2
17355: PPUSH
17356: LD_INT 195
17358: PPUSH
17359: LD_INT 102
17361: PPUSH
17362: CALL_OW 114
// wait ( 0 0$5 ) ;
17366: LD_INT 175
17368: PPUSH
17369: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17373: LD_INT 70
17375: PPUSH
17376: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17380: LD_ADDR_VAR 0 4
17384: PUSH
17385: LD_INT 92
17387: PUSH
17388: LD_INT 195
17390: PUSH
17391: LD_INT 102
17393: PUSH
17394: LD_INT 36
17396: PUSH
17397: EMPTY
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: PUSH
17403: LD_INT 22
17405: PUSH
17406: LD_INT 1
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: PPUSH
17417: CALL_OW 69
17421: ST_TO_ADDR
// for i in tmp do
17422: LD_ADDR_VAR 0 1
17426: PUSH
17427: LD_VAR 0 2
17431: PUSH
17432: FOR_IN
17433: IFFALSE 17484
// if enemy then
17435: LD_VAR 0 4
17439: IFFALSE 17467
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17441: LD_VAR 0 1
17445: PPUSH
17446: LD_VAR 0 4
17450: PPUSH
17451: LD_VAR 0 1
17455: PPUSH
17456: CALL_OW 74
17460: PPUSH
17461: CALL_OW 115
17465: GO 17482
// ComAgressiveMove ( i , 195 , 102 ) ;
17467: LD_VAR 0 1
17471: PPUSH
17472: LD_INT 195
17474: PPUSH
17475: LD_INT 102
17477: PPUSH
17478: CALL_OW 114
17482: GO 17432
17484: POP
17485: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17486: LD_VAR 0 2
17490: PPUSH
17491: LD_INT 50
17493: PUSH
17494: EMPTY
17495: LIST
17496: PPUSH
17497: CALL_OW 72
17501: NOT
17502: IFFALSE 17373
// end ; end_of_file
17504: PPOPN 4
17506: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17507: LD_INT 0
17509: PPUSH
17510: PPUSH
17511: PPUSH
17512: PPUSH
17513: PPUSH
17514: PPUSH
17515: PPUSH
17516: PPUSH
17517: PPUSH
// Video ( true ) ;
17518: LD_INT 1
17520: PPUSH
17521: CALL 107381 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17525: LD_ADDR_VAR 0 5
17529: PUSH
17530: LD_INT 7
17532: PPUSH
17533: LD_INT 0
17535: PPUSH
17536: CALL_OW 517
17540: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17541: LD_ADDR_VAR 0 2
17545: PUSH
17546: DOUBLE
17547: LD_INT 1
17549: DEC
17550: ST_TO_ADDR
17551: LD_VAR 0 5
17555: PUSH
17556: LD_INT 1
17558: ARRAY
17559: PUSH
17560: FOR_TO
17561: IFFALSE 17606
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17563: LD_VAR 0 5
17567: PUSH
17568: LD_INT 1
17570: ARRAY
17571: PUSH
17572: LD_VAR 0 2
17576: ARRAY
17577: PPUSH
17578: LD_VAR 0 5
17582: PUSH
17583: LD_INT 2
17585: ARRAY
17586: PUSH
17587: LD_VAR 0 2
17591: ARRAY
17592: PPUSH
17593: LD_INT 1
17595: PPUSH
17596: LD_INT 15
17598: NEG
17599: PPUSH
17600: CALL 107295 0 4
17604: GO 17560
17606: POP
17607: POP
// CenterNowOnUnits ( Powell ) ;
17608: LD_EXP 61
17612: PPUSH
17613: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17617: LD_ADDR_VAR 0 5
17621: PUSH
17622: LD_EXP 59
17626: PUSH
17627: EMPTY
17628: LIST
17629: ST_TO_ADDR
// if GirlNewVeh then
17630: LD_EXP 60
17634: IFFALSE 17652
// tmp := tmp ^ GirlNewVeh ;
17636: LD_ADDR_VAR 0 5
17640: PUSH
17641: LD_VAR 0 5
17645: PUSH
17646: LD_EXP 60
17650: ADD
17651: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17652: LD_VAR 0 5
17656: PPUSH
17657: LD_INT 60
17659: PPUSH
17660: LD_INT 109
17662: PPUSH
17663: CALL_OW 111
// if KappaStatus then
17667: LD_EXP 2
17671: IFFALSE 17723
// begin Say ( JMM , D1nT-JMM-1 ) ;
17673: LD_EXP 40
17677: PPUSH
17678: LD_STRING D1nT-JMM-1
17680: PPUSH
17681: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17685: LD_EXP 61
17689: PPUSH
17690: LD_STRING D1T-Pow-1
17692: PPUSH
17693: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17697: LD_EXP 40
17701: PPUSH
17702: LD_STRING D1T-JMM-2
17704: PPUSH
17705: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17709: LD_EXP 61
17713: PPUSH
17714: LD_STRING D1T-Pow-2
17716: PPUSH
17717: CALL_OW 88
// end else
17721: GO 17929
// if JMMGirlStatus then
17723: LD_EXP 6
17727: IFFALSE 17872
// begin Say ( JMM , D1T-JMM-1 ) ;
17729: LD_EXP 40
17733: PPUSH
17734: LD_STRING D1T-JMM-1
17736: PPUSH
17737: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17741: LD_EXP 61
17745: PPUSH
17746: LD_STRING D1T-Pow-1
17748: PPUSH
17749: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17753: LD_EXP 40
17757: PPUSH
17758: LD_STRING D1T-JMM-3
17760: PPUSH
17761: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17765: LD_EXP 61
17769: PPUSH
17770: LD_STRING D1T-Pow-3
17772: PPUSH
17773: CALL_OW 88
// if JMMGirl then
17777: LD_EXP 7
17781: IFFALSE 17870
// begin case JMMGirl of 1 :
17783: LD_EXP 7
17787: PUSH
17788: LD_INT 1
17790: DOUBLE
17791: EQUAL
17792: IFTRUE 17796
17794: GO 17811
17796: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17797: LD_EXP 41
17801: PPUSH
17802: LD_STRING D1T-Joan-3
17804: PPUSH
17805: CALL_OW 88
17809: GO 17858
17811: LD_INT 2
17813: DOUBLE
17814: EQUAL
17815: IFTRUE 17819
17817: GO 17834
17819: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17820: LD_EXP 43
17824: PPUSH
17825: LD_STRING D1T-Lisa-3
17827: PPUSH
17828: CALL_OW 88
17832: GO 17858
17834: LD_INT 3
17836: DOUBLE
17837: EQUAL
17838: IFTRUE 17842
17840: GO 17857
17842: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17843: LD_EXP 55
17847: PPUSH
17848: LD_STRING D1T-Con-3
17850: PPUSH
17851: CALL_OW 88
17855: GO 17858
17857: POP
// Say ( Powell , D1T-Pow-4 ) ;
17858: LD_EXP 61
17862: PPUSH
17863: LD_STRING D1T-Pow-4
17865: PPUSH
17866: CALL_OW 88
// end ; end else
17870: GO 17929
// if not FastEnd then
17872: LD_EXP 11
17876: NOT
17877: IFFALSE 17905
// begin Say ( JMM , D1T-JMM-4 ) ;
17879: LD_EXP 40
17883: PPUSH
17884: LD_STRING D1T-JMM-4
17886: PPUSH
17887: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17891: LD_EXP 61
17895: PPUSH
17896: LD_STRING D1T-Pow-5
17898: PPUSH
17899: CALL_OW 88
// end else
17903: GO 17929
// begin Say ( JMM , D1nT-JMM-1 ) ;
17905: LD_EXP 40
17909: PPUSH
17910: LD_STRING D1nT-JMM-1
17912: PPUSH
17913: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17917: LD_EXP 61
17921: PPUSH
17922: LD_STRING D1nT-Pow-1
17924: PPUSH
17925: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17929: LD_INT 3
17931: PPUSH
17932: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17936: LD_EXP 59
17940: PPUSH
17941: CALL_OW 314
17945: NOT
17946: IFFALSE 17929
// ComExitVehicle ( JMM ) ;
17948: LD_EXP 40
17952: PPUSH
17953: CALL_OW 121
// repeat wait ( 3 ) ;
17957: LD_INT 3
17959: PPUSH
17960: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17964: LD_EXP 40
17968: PPUSH
17969: CALL_OW 310
17973: NOT
17974: IFFALSE 17957
// ComMoveXY ( JMM , 60 , 94 ) ;
17976: LD_EXP 40
17980: PPUSH
17981: LD_INT 60
17983: PPUSH
17984: LD_INT 94
17986: PPUSH
17987: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17991: LD_EXP 40
17995: PPUSH
17996: LD_EXP 61
18000: PPUSH
18001: CALL_OW 179
// if Joan then
18005: LD_EXP 41
18009: IFFALSE 18063
// begin ComExitVehicle ( Joan ) ;
18011: LD_EXP 41
18015: PPUSH
18016: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18020: LD_EXP 41
18024: PPUSH
18025: LD_INT 35
18027: PPUSH
18028: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18032: LD_EXP 41
18036: PPUSH
18037: LD_INT 65
18039: PPUSH
18040: LD_INT 104
18042: PPUSH
18043: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18047: LD_EXP 41
18051: PPUSH
18052: LD_EXP 40
18056: PPUSH
18057: CALL_OW 179
// end else
18061: GO 18197
// if Lisa and JMMGirl = 2 then
18063: LD_EXP 43
18067: PUSH
18068: LD_EXP 7
18072: PUSH
18073: LD_INT 2
18075: EQUAL
18076: AND
18077: IFFALSE 18131
// begin ComExitVehicle ( Lisa ) ;
18079: LD_EXP 43
18083: PPUSH
18084: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18088: LD_EXP 43
18092: PPUSH
18093: LD_INT 35
18095: PPUSH
18096: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18100: LD_EXP 43
18104: PPUSH
18105: LD_INT 65
18107: PPUSH
18108: LD_INT 104
18110: PPUSH
18111: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18115: LD_EXP 43
18119: PPUSH
18120: LD_EXP 40
18124: PPUSH
18125: CALL_OW 179
// end else
18129: GO 18197
// if Connie and JMMGirl = 3 then
18131: LD_EXP 55
18135: PUSH
18136: LD_EXP 7
18140: PUSH
18141: LD_INT 3
18143: EQUAL
18144: AND
18145: IFFALSE 18197
// begin ComExitVehicle ( Connie ) ;
18147: LD_EXP 55
18151: PPUSH
18152: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18156: LD_EXP 55
18160: PPUSH
18161: LD_INT 35
18163: PPUSH
18164: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18168: LD_EXP 55
18172: PPUSH
18173: LD_INT 65
18175: PPUSH
18176: LD_INT 104
18178: PPUSH
18179: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18183: LD_EXP 55
18187: PPUSH
18188: LD_EXP 40
18192: PPUSH
18193: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18197: LD_INT 35
18199: PPUSH
18200: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18204: LD_EXP 40
18208: PPUSH
18209: LD_EXP 61
18213: PPUSH
18214: CALL_OW 296
18218: PUSH
18219: LD_INT 8
18221: LESS
18222: IFFALSE 18197
// wait ( 0 0$0.5 ) ;
18224: LD_INT 18
18226: PPUSH
18227: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18231: LD_EXP 40
18235: PPUSH
18236: LD_STRING D1-JMM-1
18238: PPUSH
18239: CALL_OW 88
// async ;
18243: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18244: LD_EXP 61
18248: PPUSH
18249: LD_STRING D1-Pow-1
18251: PPUSH
18252: CALL_OW 88
// if not dialogue_skipped then
18256: LD_OWVAR 59
18260: NOT
18261: IFFALSE 18270
// wait ( 0 0$2 ) ;
18263: LD_INT 70
18265: PPUSH
18266: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18270: LD_INT 170
18272: PPUSH
18273: LD_INT 99
18275: PPUSH
18276: LD_INT 1
18278: PPUSH
18279: LD_INT 6
18281: NEG
18282: PPUSH
18283: CALL 107295 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18287: LD_INT 174
18289: PPUSH
18290: LD_INT 115
18292: PPUSH
18293: LD_INT 1
18295: PPUSH
18296: LD_INT 6
18298: NEG
18299: PPUSH
18300: CALL 107295 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18304: LD_INT 169
18306: PPUSH
18307: LD_INT 71
18309: PPUSH
18310: LD_INT 1
18312: PPUSH
18313: LD_INT 6
18315: NEG
18316: PPUSH
18317: CALL 107295 0 4
// if not dialogue_skipped then
18321: LD_OWVAR 59
18325: NOT
18326: IFFALSE 18345
// begin CenterOnXY ( 170 , 99 ) ;
18328: LD_INT 170
18330: PPUSH
18331: LD_INT 99
18333: PPUSH
18334: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18338: LD_INT 80
18340: PPUSH
18341: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18345: LD_INT 75
18347: PPUSH
18348: LD_INT 53
18350: PPUSH
18351: LD_INT 1
18353: PPUSH
18354: LD_INT 9
18356: NEG
18357: PPUSH
18358: CALL 107295 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18362: LD_INT 54
18364: PPUSH
18365: LD_INT 42
18367: PPUSH
18368: LD_INT 1
18370: PPUSH
18371: LD_INT 9
18373: NEG
18374: PPUSH
18375: CALL 107295 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18379: LD_INT 62
18381: PPUSH
18382: LD_INT 51
18384: PPUSH
18385: LD_INT 1
18387: PPUSH
18388: LD_INT 9
18390: NEG
18391: PPUSH
18392: CALL 107295 0 4
// if not dialogue_skipped then
18396: LD_OWVAR 59
18400: NOT
18401: IFFALSE 18420
// begin CenterOnXY ( 75 , 53 ) ;
18403: LD_INT 75
18405: PPUSH
18406: LD_INT 53
18408: PPUSH
18409: CALL_OW 84
// wait ( 0 0$4 ) ;
18413: LD_INT 140
18415: PPUSH
18416: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18420: LD_EXP 61
18424: PPUSH
18425: CALL_OW 87
// if not dialogue_skipped then
18429: LD_OWVAR 59
18433: NOT
18434: IFFALSE 18443
// wait ( 0 0$2 ) ;
18436: LD_INT 70
18438: PPUSH
18439: CALL_OW 67
// sync ;
18443: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18444: LD_EXP 40
18448: PPUSH
18449: LD_STRING D1-JMM-2
18451: PPUSH
18452: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18456: LD_EXP 61
18460: PPUSH
18461: LD_STRING D1-Pow-2
18463: PPUSH
18464: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18468: LD_EXP 40
18472: PPUSH
18473: LD_STRING D1-JMM-3
18475: PPUSH
18476: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18480: LD_EXP 61
18484: PPUSH
18485: LD_STRING D1-Pow-3
18487: PPUSH
18488: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18492: LD_EXP 40
18496: PPUSH
18497: LD_STRING D1-JMM-4
18499: PPUSH
18500: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18504: LD_EXP 61
18508: PPUSH
18509: LD_STRING D1-Pow-4
18511: PPUSH
18512: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18516: LD_EXP 40
18520: PPUSH
18521: LD_STRING D1-JMM-5
18523: PPUSH
18524: CALL_OW 88
// async ;
18528: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18529: LD_EXP 61
18533: PPUSH
18534: LD_STRING D1-Pow-5
18536: PPUSH
18537: CALL_OW 88
// if not dialogue_skipped then
18541: LD_OWVAR 59
18545: NOT
18546: IFFALSE 18555
// wait ( 0 0$3.6 ) ;
18548: LD_INT 126
18550: PPUSH
18551: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18555: LD_INT 134
18557: PPUSH
18558: LD_INT 210
18560: PPUSH
18561: LD_INT 1
18563: PPUSH
18564: LD_INT 11
18566: NEG
18567: PPUSH
18568: CALL 107295 0 4
// if not dialogue_skipped then
18572: LD_OWVAR 59
18576: NOT
18577: IFFALSE 18596
// begin CenterOnXY ( 134 , 210 ) ;
18579: LD_INT 134
18581: PPUSH
18582: LD_INT 210
18584: PPUSH
18585: CALL_OW 84
// wait ( 0 0$2 ) ;
18589: LD_INT 70
18591: PPUSH
18592: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18596: LD_INT 101
18598: PPUSH
18599: LD_INT 159
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: LD_INT 10
18607: NEG
18608: PPUSH
18609: CALL 107295 0 4
// if not dialogue_skipped then
18613: LD_OWVAR 59
18617: NOT
18618: IFFALSE 18637
// begin CenterOnXY ( 101 , 159 ) ;
18620: LD_INT 101
18622: PPUSH
18623: LD_INT 159
18625: PPUSH
18626: CALL_OW 84
// wait ( 0 0$2 ) ;
18630: LD_INT 70
18632: PPUSH
18633: CALL_OW 67
// end ; sync ;
18637: SYNC
// CenterNowOnUnits ( Powell ) ;
18638: LD_EXP 61
18642: PPUSH
18643: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18647: LD_ADDR_VAR 0 6
18651: PUSH
18652: LD_INT 1
18654: PUSH
18655: LD_INT 2
18657: PUSH
18658: LD_INT 3
18660: PUSH
18661: LD_INT 4
18663: PUSH
18664: LD_INT 5
18666: PUSH
18667: LD_INT 6
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: LIST
18676: LIST
18677: ST_TO_ADDR
// if not dialogue_skipped then
18678: LD_OWVAR 59
18682: NOT
18683: IFFALSE 18852
// begin game_speed := 4 ;
18685: LD_ADDR_OWVAR 65
18689: PUSH
18690: LD_INT 4
18692: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18693: LD_INT 210
18695: PPUSH
18696: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18700: LD_ADDR_VAR 0 7
18704: PUSH
18705: LD_STRING Q1
18707: PPUSH
18708: LD_VAR 0 6
18712: PPUSH
18713: CALL_OW 98
18717: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18718: LD_ADDR_VAR 0 7
18722: PUSH
18723: LD_STRING Q1
18725: PPUSH
18726: LD_VAR 0 6
18730: PPUSH
18731: CALL_OW 98
18735: ST_TO_ADDR
// options := options diff dec ;
18736: LD_ADDR_VAR 0 6
18740: PUSH
18741: LD_VAR 0 6
18745: PUSH
18746: LD_VAR 0 7
18750: DIFF
18751: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18752: LD_VAR 0 7
18756: PPUSH
18757: LD_VAR 0 6
18761: PPUSH
18762: CALL 20416 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18766: LD_VAR 0 7
18770: PUSH
18771: LD_INT 5
18773: PUSH
18774: LD_INT 6
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: IN
18781: PUSH
18782: LD_VAR 0 6
18786: PUSH
18787: LD_INT 2
18789: EQUAL
18790: OR
18791: IFFALSE 18718
// if not ( dec in [ 5 , 6 ] ) then
18793: LD_VAR 0 7
18797: PUSH
18798: LD_INT 5
18800: PUSH
18801: LD_INT 6
18803: PUSH
18804: EMPTY
18805: LIST
18806: LIST
18807: IN
18808: NOT
18809: IFFALSE 18852
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18811: LD_ADDR_VAR 0 7
18815: PUSH
18816: LD_STRING Q1a
18818: PPUSH
18819: LD_INT 1
18821: PUSH
18822: LD_INT 2
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PPUSH
18829: CALL_OW 98
18833: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18834: LD_VAR 0 7
18838: PUSH
18839: LD_INT 4
18841: PLUS
18842: PPUSH
18843: LD_VAR 0 6
18847: PPUSH
18848: CALL 20416 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18852: LD_INT 81
18854: PPUSH
18855: LD_INT 127
18857: PPUSH
18858: CALL_OW 84
// amount := 8 ;
18862: LD_ADDR_VAR 0 8
18866: PUSH
18867: LD_INT 8
18869: ST_TO_ADDR
// macmilan_squad := [ ] ;
18870: LD_ADDR_VAR 0 9
18874: PUSH
18875: EMPTY
18876: ST_TO_ADDR
// if vip < amount then
18877: LD_EXP 62
18881: PUSH
18882: LD_VAR 0 8
18886: LESS
18887: IFFALSE 18931
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18889: LD_ADDR_VAR 0 5
18893: PUSH
18894: LD_EXP 62
18898: PUSH
18899: LD_INT 22
18901: PUSH
18902: LD_INT 4
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: PUSH
18909: LD_INT 21
18911: PUSH
18912: LD_INT 1
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: PUSH
18919: EMPTY
18920: LIST
18921: LIST
18922: PPUSH
18923: CALL_OW 69
18927: UNION
18928: ST_TO_ADDR
18929: GO 18941
// tmp := vip ;
18931: LD_ADDR_VAR 0 5
18935: PUSH
18936: LD_EXP 62
18940: ST_TO_ADDR
// tmp := tmp diff Powell ;
18941: LD_ADDR_VAR 0 5
18945: PUSH
18946: LD_VAR 0 5
18950: PUSH
18951: LD_EXP 61
18955: DIFF
18956: ST_TO_ADDR
// if tmp < amount then
18957: LD_VAR 0 5
18961: PUSH
18962: LD_VAR 0 8
18966: LESS
18967: IFFALSE 18979
// amount := tmp ;
18969: LD_ADDR_VAR 0 8
18973: PUSH
18974: LD_VAR 0 5
18978: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18979: LD_VAR 0 5
18983: PUSH
18984: LD_INT 1
18986: ARRAY
18987: PPUSH
18988: CALL_OW 257
18992: PUSH
18993: LD_INT 2
18995: NONEQUAL
18996: IFFALSE 19094
// begin if IsInUnit ( tmp [ 1 ] ) then
18998: LD_VAR 0 5
19002: PUSH
19003: LD_INT 1
19005: ARRAY
19006: PPUSH
19007: CALL_OW 310
19011: IFFALSE 19026
// ComExitBuilding ( tmp [ 1 ] ) ;
19013: LD_VAR 0 5
19017: PUSH
19018: LD_INT 1
19020: ARRAY
19021: PPUSH
19022: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19026: LD_INT 387
19028: PPUSH
19029: CALL_OW 313
19033: PUSH
19034: LD_INT 6
19036: EQUAL
19037: IFFALSE 19062
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19039: LD_INT 387
19041: PPUSH
19042: CALL_OW 313
19046: PUSH
19047: LD_INT 1
19049: ARRAY
19050: PPUSH
19051: CALL_OW 122
// wait ( 3 ) ;
19055: LD_INT 3
19057: PPUSH
19058: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: LD_INT 387
19073: PPUSH
19074: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19078: LD_VAR 0 5
19082: PUSH
19083: LD_INT 1
19085: ARRAY
19086: PPUSH
19087: LD_INT 2
19089: PPUSH
19090: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19094: LD_EXP 40
19098: PPUSH
19099: LD_INT 82
19101: PPUSH
19102: LD_INT 129
19104: PPUSH
19105: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19109: LD_EXP 40
19113: PPUSH
19114: LD_EXP 61
19118: PPUSH
19119: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19123: LD_INT 22
19125: PUSH
19126: LD_INT 1
19128: PUSH
19129: EMPTY
19130: LIST
19131: LIST
19132: PPUSH
19133: CALL_OW 69
19137: PUSH
19138: LD_EXP 40
19142: DIFF
19143: PPUSH
19144: LD_INT 84
19146: PPUSH
19147: LD_INT 128
19149: PPUSH
19150: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19154: LD_INT 22
19156: PUSH
19157: LD_INT 1
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: PPUSH
19164: CALL_OW 69
19168: PUSH
19169: LD_EXP 40
19173: DIFF
19174: PPUSH
19175: LD_EXP 40
19179: PPUSH
19180: CALL_OW 179
// for i = 1 to amount do
19184: LD_ADDR_VAR 0 2
19188: PUSH
19189: DOUBLE
19190: LD_INT 1
19192: DEC
19193: ST_TO_ADDR
19194: LD_VAR 0 8
19198: PUSH
19199: FOR_TO
19200: IFFALSE 19368
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19202: LD_ADDR_VAR 0 9
19206: PUSH
19207: LD_VAR 0 9
19211: PUSH
19212: LD_VAR 0 5
19216: PUSH
19217: LD_VAR 0 2
19221: ARRAY
19222: ADD
19223: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_VAR 0 2
19233: ARRAY
19234: PPUSH
19235: CALL_OW 310
19239: IFFALSE 19256
// AddComExitBuilding ( tmp [ i ] ) ;
19241: LD_VAR 0 5
19245: PUSH
19246: LD_VAR 0 2
19250: ARRAY
19251: PPUSH
19252: CALL_OW 182
// if i = 2 and JMMNewVeh then
19256: LD_VAR 0 2
19260: PUSH
19261: LD_INT 2
19263: EQUAL
19264: PUSH
19265: LD_EXP 59
19269: AND
19270: IFFALSE 19328
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19272: LD_VAR 0 5
19276: PUSH
19277: LD_VAR 0 2
19281: ARRAY
19282: PPUSH
19283: LD_EXP 59
19287: PPUSH
19288: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19292: LD_VAR 0 5
19296: PUSH
19297: LD_VAR 0 2
19301: ARRAY
19302: PPUSH
19303: LD_INT 86
19305: PPUSH
19306: LD_INT 133
19308: PPUSH
19309: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19313: LD_VAR 0 5
19317: PUSH
19318: LD_VAR 0 2
19322: ARRAY
19323: PPUSH
19324: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19328: LD_VAR 0 5
19332: PUSH
19333: LD_VAR 0 2
19337: ARRAY
19338: PPUSH
19339: LD_INT 8
19341: PPUSH
19342: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19346: LD_VAR 0 5
19350: PUSH
19351: LD_VAR 0 2
19355: ARRAY
19356: PPUSH
19357: LD_EXP 40
19361: PPUSH
19362: CALL_OW 179
// end ;
19366: GO 19199
19368: POP
19369: POP
// if GirlNewVeh then
19370: LD_EXP 60
19374: IFFALSE 19388
// SetSide ( GirlNewVeh , 4 ) ;
19376: LD_EXP 60
19380: PPUSH
19381: LD_INT 4
19383: PPUSH
19384: CALL_OW 235
// if Mike then
19388: LD_EXP 57
19392: IFFALSE 19429
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19394: LD_ADDR_VAR 0 9
19398: PUSH
19399: LD_VAR 0 9
19403: PPUSH
19404: LD_EXP 57
19408: PPUSH
19409: CALL 107409 0 2
19413: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19414: LD_EXP 57
19418: PPUSH
19419: LD_INT 86
19421: PPUSH
19422: LD_INT 133
19424: PPUSH
19425: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19429: LD_INT 35
19431: PPUSH
19432: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19436: LD_VAR 0 9
19440: PPUSH
19441: LD_INT 95
19443: PUSH
19444: LD_INT 9
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: PUSH
19456: LD_INT 0
19458: EQUAL
19459: PUSH
19460: LD_EXP 40
19464: PPUSH
19465: LD_INT 9
19467: PPUSH
19468: CALL_OW 308
19472: NOT
19473: AND
19474: IFFALSE 19429
// wait ( 0 0$2 ) ;
19476: LD_INT 70
19478: PPUSH
19479: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19483: LD_VAR 0 9
19487: PPUSH
19488: LD_INT 1
19490: PPUSH
19491: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19495: LD_INT 21
19497: PUSH
19498: LD_INT 2
19500: PUSH
19501: EMPTY
19502: LIST
19503: LIST
19504: PUSH
19505: LD_INT 92
19507: PUSH
19508: LD_INT 83
19510: PUSH
19511: LD_INT 130
19513: PUSH
19514: LD_INT 10
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: PUSH
19523: EMPTY
19524: LIST
19525: LIST
19526: PPUSH
19527: CALL_OW 69
19531: PPUSH
19532: LD_INT 1
19534: PPUSH
19535: CALL_OW 235
// tick := 0 ;
19539: LD_ADDR_OWVAR 1
19543: PUSH
19544: LD_INT 0
19546: ST_TO_ADDR
// Video ( false ) ;
19547: LD_INT 0
19549: PPUSH
19550: CALL 107381 0 1
// ChangeMissionObjectives ( M1 ) ;
19554: LD_STRING M1
19556: PPUSH
19557: CALL_OW 337
// SaveForQuickRestart ;
19561: CALL_OW 22
// missionStart := true ;
19565: LD_ADDR_EXP 13
19569: PUSH
19570: LD_INT 1
19572: ST_TO_ADDR
// missionStage := 2 ;
19573: LD_ADDR_EXP 15
19577: PUSH
19578: LD_INT 2
19580: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19581: LD_INT 35
19583: PPUSH
19584: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19588: LD_ADDR_VAR 0 5
19592: PUSH
19593: LD_INT 22
19595: PUSH
19596: LD_INT 4
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: LD_INT 21
19605: PUSH
19606: LD_INT 1
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PUSH
19613: EMPTY
19614: LIST
19615: LIST
19616: PPUSH
19617: CALL_OW 69
19621: PUSH
19622: LD_EXP 61
19626: DIFF
19627: ST_TO_ADDR
// if not tmp then
19628: LD_VAR 0 5
19632: NOT
19633: IFFALSE 19648
// tmp := [ Powell ] ;
19635: LD_ADDR_VAR 0 5
19639: PUSH
19640: LD_EXP 61
19644: PUSH
19645: EMPTY
19646: LIST
19647: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19648: LD_ADDR_VAR 0 4
19652: PUSH
19653: LD_INT 22
19655: PUSH
19656: LD_INT 4
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: PUSH
19663: LD_INT 34
19665: PUSH
19666: LD_INT 12
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PPUSH
19677: CALL_OW 69
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19686: LD_VAR 0 5
19690: PUSH
19691: LD_INT 1
19693: ARRAY
19694: PPUSH
19695: CALL_OW 310
19699: IFFALSE 19714
// ComExitBuilding ( tmp [ 1 ] ) ;
19701: LD_VAR 0 5
19705: PUSH
19706: LD_INT 1
19708: ARRAY
19709: PPUSH
19710: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19714: LD_VAR 0 5
19718: PUSH
19719: LD_INT 1
19721: ARRAY
19722: PPUSH
19723: LD_VAR 0 4
19727: PPUSH
19728: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19732: LD_VAR 0 5
19736: PUSH
19737: LD_INT 1
19739: ARRAY
19740: PPUSH
19741: LD_INT 80
19743: PPUSH
19744: LD_INT 136
19746: PPUSH
19747: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19751: LD_VAR 0 5
19755: PUSH
19756: LD_INT 1
19758: ARRAY
19759: PPUSH
19760: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19764: LD_VAR 0 5
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_INT 59
19775: PPUSH
19776: LD_INT 112
19778: PPUSH
19779: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19783: LD_VAR 0 5
19787: PUSH
19788: LD_INT 1
19790: ARRAY
19791: PPUSH
19792: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19796: LD_EXP 41
19800: PUSH
19801: LD_EXP 41
19805: PPUSH
19806: CALL_OW 255
19810: PUSH
19811: LD_INT 1
19813: EQUAL
19814: AND
19815: IFFALSE 19841
// begin Say ( Joan , D3W-Joan-1 ) ;
19817: LD_EXP 41
19821: PPUSH
19822: LD_STRING D3W-Joan-1
19824: PPUSH
19825: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19829: LD_EXP 40
19833: PPUSH
19834: LD_STRING D3W-JMM-1
19836: PPUSH
19837: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19841: LD_EXP 43
19845: PUSH
19846: LD_EXP 43
19850: PPUSH
19851: CALL_OW 255
19855: PUSH
19856: LD_INT 1
19858: EQUAL
19859: AND
19860: PUSH
19861: LD_EXP 43
19865: PUSH
19866: LD_EXP 62
19870: IN
19871: NOT
19872: AND
19873: IFFALSE 19899
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19875: LD_EXP 43
19879: PPUSH
19880: LD_STRING D3W-Lisa-1
19882: PPUSH
19883: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19887: LD_EXP 40
19891: PPUSH
19892: LD_STRING D3W-JMM-1
19894: PPUSH
19895: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19899: LD_EXP 55
19903: PUSH
19904: LD_EXP 55
19908: PPUSH
19909: CALL_OW 255
19913: PUSH
19914: LD_INT 1
19916: EQUAL
19917: AND
19918: IFFALSE 19944
// begin Say ( Connie , D3W-Con-1 ) ;
19920: LD_EXP 55
19924: PPUSH
19925: LD_STRING D3W-Con-1
19927: PPUSH
19928: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19932: LD_EXP 40
19936: PPUSH
19937: LD_STRING D3W-JMM-1
19939: PPUSH
19940: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19944: LD_INT 18
19946: PPUSH
19947: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19951: LD_EXP 43
19955: PUSH
19956: LD_EXP 62
19960: IN
19961: PUSH
19962: LD_EXP 43
19966: PPUSH
19967: CALL_OW 255
19971: PUSH
19972: LD_INT 1
19974: EQUAL
19975: AND
19976: IFFALSE 19992
// Say ( Lisa , D3nW-Lisa-1 ) else
19978: LD_EXP 43
19982: PPUSH
19983: LD_STRING D3nW-Lisa-1
19985: PPUSH
19986: CALL_OW 88
19990: GO 20236
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19992: LD_EXP 46
19996: PUSH
19997: LD_EXP 62
20001: IN
20002: PUSH
20003: LD_EXP 46
20007: PPUSH
20008: CALL_OW 255
20012: PUSH
20013: LD_INT 1
20015: EQUAL
20016: AND
20017: IFFALSE 20033
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20019: LD_EXP 46
20023: PPUSH
20024: LD_STRING D3nW-Cyrus-1
20026: PPUSH
20027: CALL_OW 88
20031: GO 20236
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20033: LD_EXP 45
20037: PUSH
20038: LD_EXP 62
20042: IN
20043: PUSH
20044: LD_EXP 45
20048: PPUSH
20049: CALL_OW 255
20053: PUSH
20054: LD_INT 1
20056: EQUAL
20057: AND
20058: IFFALSE 20074
// Say ( Bobby , D3nW-Bobby-1 ) else
20060: LD_EXP 45
20064: PPUSH
20065: LD_STRING D3nW-Bobby-1
20067: PPUSH
20068: CALL_OW 88
20072: GO 20236
// if Gary in vip and GetSide ( Gary ) = 1 then
20074: LD_EXP 52
20078: PUSH
20079: LD_EXP 62
20083: IN
20084: PUSH
20085: LD_EXP 52
20089: PPUSH
20090: CALL_OW 255
20094: PUSH
20095: LD_INT 1
20097: EQUAL
20098: AND
20099: IFFALSE 20115
// Say ( Gary , D3nW-Gary-1 ) else
20101: LD_EXP 52
20105: PPUSH
20106: LD_STRING D3nW-Gary-1
20108: PPUSH
20109: CALL_OW 88
20113: GO 20236
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20115: LD_EXP 44
20119: PUSH
20120: LD_EXP 62
20124: IN
20125: PUSH
20126: LD_EXP 44
20130: PPUSH
20131: CALL_OW 255
20135: PUSH
20136: LD_INT 1
20138: EQUAL
20139: AND
20140: IFFALSE 20156
// Say ( Donaldson , D3nW-Don-1 ) else
20142: LD_EXP 44
20146: PPUSH
20147: LD_STRING D3nW-Don-1
20149: PPUSH
20150: CALL_OW 88
20154: GO 20236
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20156: LD_EXP 51
20160: PUSH
20161: LD_EXP 62
20165: IN
20166: PUSH
20167: LD_EXP 51
20171: PPUSH
20172: CALL_OW 255
20176: PUSH
20177: LD_INT 1
20179: EQUAL
20180: AND
20181: IFFALSE 20197
// Say ( Cornel , D3nW-Corn-1 ) else
20183: LD_EXP 51
20187: PPUSH
20188: LD_STRING D3nW-Corn-1
20190: PPUSH
20191: CALL_OW 88
20195: GO 20236
// if Frank in vip and GetSide ( Frank ) = 1 then
20197: LD_EXP 53
20201: PUSH
20202: LD_EXP 62
20206: IN
20207: PUSH
20208: LD_EXP 53
20212: PPUSH
20213: CALL_OW 255
20217: PUSH
20218: LD_INT 1
20220: EQUAL
20221: AND
20222: IFFALSE 20236
// Say ( Frank , D3nW-Frank-1 ) ;
20224: LD_EXP 53
20228: PPUSH
20229: LD_STRING D3nW-Frank-1
20231: PPUSH
20232: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20236: LD_EXP 62
20240: PPUSH
20241: LD_INT 22
20243: PUSH
20244: LD_INT 1
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PPUSH
20251: CALL_OW 72
20255: IFFALSE 20281
// begin Say ( JMM , D3nW-JMM-1 ) ;
20257: LD_EXP 40
20261: PPUSH
20262: LD_STRING D3nW-JMM-1
20264: PPUSH
20265: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20269: LD_EXP 40
20273: PPUSH
20274: LD_STRING D3nW-JMM-1a
20276: PPUSH
20277: CALL_OW 88
// end ; t := 0 0$00 ;
20281: LD_ADDR_VAR 0 3
20285: PUSH
20286: LD_INT 0
20288: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20289: LD_INT 35
20291: PPUSH
20292: CALL_OW 67
// t := t + 0 0$1 ;
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_VAR 0 3
20305: PUSH
20306: LD_INT 35
20308: PLUS
20309: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20310: LD_INT 59
20312: PPUSH
20313: LD_INT 112
20315: PPUSH
20316: CALL_OW 428
20320: PUSH
20321: LD_VAR 0 3
20325: PUSH
20326: LD_INT 2100
20328: GREATER
20329: OR
20330: IFFALSE 20289
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20332: LD_ADDR_EXP 102
20336: PUSH
20337: LD_EXP 102
20341: PPUSH
20342: LD_INT 4
20344: PPUSH
20345: LD_INT 22
20347: PUSH
20348: LD_INT 4
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: PUSH
20355: LD_INT 23
20357: PUSH
20358: LD_INT 1
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: PUSH
20365: LD_INT 3
20367: PUSH
20368: LD_INT 21
20370: PUSH
20371: LD_INT 2
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: LIST
20386: PPUSH
20387: CALL_OW 69
20391: PUSH
20392: LD_EXP 61
20396: DIFF
20397: PPUSH
20398: CALL_OW 1
20402: ST_TO_ADDR
// activeAttacks := true ;
20403: LD_ADDR_EXP 16
20407: PUSH
20408: LD_INT 1
20410: ST_TO_ADDR
// end ;
20411: LD_VAR 0 1
20415: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20416: LD_INT 0
20418: PPUSH
// case question of 1 :
20419: LD_VAR 0 1
20423: PUSH
20424: LD_INT 1
20426: DOUBLE
20427: EQUAL
20428: IFTRUE 20432
20430: GO 20483
20432: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20433: LD_EXP 40
20437: PPUSH
20438: LD_STRING D2Mot-JMM-1
20440: PPUSH
20441: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20445: LD_EXP 61
20449: PPUSH
20450: LD_STRING D2Mot-Pow-1
20452: PPUSH
20453: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20457: LD_EXP 40
20461: PPUSH
20462: LD_STRING D2Mot-JMM-2
20464: PPUSH
20465: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20469: LD_EXP 61
20473: PPUSH
20474: LD_STRING D2Mot-Pow-2
20476: PPUSH
20477: CALL_OW 88
// end ; 2 :
20481: GO 20834
20483: LD_INT 2
20485: DOUBLE
20486: EQUAL
20487: IFTRUE 20491
20489: GO 20567
20491: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20492: LD_EXP 40
20496: PPUSH
20497: LD_STRING D2Rus-JMM-1
20499: PPUSH
20500: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20504: LD_EXP 61
20508: PPUSH
20509: LD_STRING D2Rus-Pow-1
20511: PPUSH
20512: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20516: LD_EXP 40
20520: PPUSH
20521: LD_STRING D2Rus-JMM-2
20523: PPUSH
20524: CALL_OW 88
// if not ( 3 in list_of_q ) then
20528: LD_INT 3
20530: PUSH
20531: LD_VAR 0 2
20535: IN
20536: NOT
20537: IFFALSE 20553
// Say ( Powell , D2Rus-Pow-2 ) else
20539: LD_EXP 61
20543: PPUSH
20544: LD_STRING D2Rus-Pow-2
20546: PPUSH
20547: CALL_OW 88
20551: GO 20565
// Say ( Powell , D2Rus-Pow-2a ) ;
20553: LD_EXP 61
20557: PPUSH
20558: LD_STRING D2Rus-Pow-2a
20560: PPUSH
20561: CALL_OW 88
// end ; 3 :
20565: GO 20834
20567: LD_INT 3
20569: DOUBLE
20570: EQUAL
20571: IFTRUE 20575
20573: GO 20660
20575: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20576: LD_EXP 40
20580: PPUSH
20581: LD_STRING D2Leg-JMM-1
20583: PPUSH
20584: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20588: LD_EXP 61
20592: PPUSH
20593: LD_STRING D2Leg-Pow-1
20595: PPUSH
20596: CALL_OW 88
// if 2 in list_of_q then
20600: LD_INT 2
20602: PUSH
20603: LD_VAR 0 2
20607: IN
20608: IFFALSE 20634
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20610: LD_EXP 40
20614: PPUSH
20615: LD_STRING D2Leg-JMM-2
20617: PPUSH
20618: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20622: LD_EXP 61
20626: PPUSH
20627: LD_STRING D2Leg-Pow-2
20629: PPUSH
20630: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20634: LD_EXP 40
20638: PPUSH
20639: LD_STRING D2Leg-JMM-3
20641: PPUSH
20642: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20646: LD_EXP 61
20650: PPUSH
20651: LD_STRING D2Leg-Pow-3
20653: PPUSH
20654: CALL_OW 88
// end ; 4 :
20658: GO 20834
20660: LD_INT 4
20662: DOUBLE
20663: EQUAL
20664: IFTRUE 20668
20666: GO 20743
20668: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20669: LD_EXP 40
20673: PPUSH
20674: LD_STRING D2Ar-JMM-1
20676: PPUSH
20677: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20681: LD_EXP 61
20685: PPUSH
20686: LD_STRING D2Ar-Pow-1
20688: PPUSH
20689: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20693: LD_EXP 40
20697: PPUSH
20698: LD_STRING D2Ar-JMM-2
20700: PPUSH
20701: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20705: LD_EXP 61
20709: PPUSH
20710: LD_STRING D2Ar-Pow-2
20712: PPUSH
20713: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20717: LD_EXP 40
20721: PPUSH
20722: LD_STRING D2Ar-JMM-3
20724: PPUSH
20725: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20729: LD_EXP 61
20733: PPUSH
20734: LD_STRING D2Ar-Pow-3
20736: PPUSH
20737: CALL_OW 88
// end ; 5 :
20741: GO 20834
20743: LD_INT 5
20745: DOUBLE
20746: EQUAL
20747: IFTRUE 20751
20749: GO 20766
20751: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20752: LD_EXP 40
20756: PPUSH
20757: LD_STRING D2Conf-JMM-1
20759: PPUSH
20760: CALL_OW 88
20764: GO 20834
20766: LD_INT 6
20768: DOUBLE
20769: EQUAL
20770: IFTRUE 20774
20772: GO 20833
20774: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20775: LD_EXP 40
20779: PPUSH
20780: LD_STRING D2Com-JMM-1
20782: PPUSH
20783: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20787: LD_EXP 61
20791: PPUSH
20792: LD_STRING D2Com-Pow-1
20794: PPUSH
20795: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20799: LD_EXP 40
20803: PPUSH
20804: LD_STRING D2Com-JMM-2
20806: PPUSH
20807: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20811: LD_EXP 61
20815: PPUSH
20816: LD_STRING D2Com-Pow-2
20818: PPUSH
20819: CALL_OW 88
// powellAngerQuery := true ;
20823: LD_ADDR_EXP 36
20827: PUSH
20828: LD_INT 1
20830: ST_TO_ADDR
// end ; end ;
20831: GO 20834
20833: POP
// end ;
20834: LD_VAR 0 3
20838: RET
// every 0 0$5 trigger missionStart do var tmp ;
20839: LD_EXP 13
20843: IFFALSE 21168
20845: GO 20847
20847: DISABLE
20848: LD_INT 0
20850: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20851: LD_INT 35
20853: PPUSH
20854: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20858: LD_INT 14
20860: PPUSH
20861: LD_INT 22
20863: PUSH
20864: LD_INT 1
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: PUSH
20871: LD_INT 3
20873: PUSH
20874: LD_INT 21
20876: PUSH
20877: LD_INT 3
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: EMPTY
20885: LIST
20886: LIST
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: PPUSH
20892: CALL_OW 70
20896: PUSH
20897: LD_EXP 15
20901: PUSH
20902: LD_INT 2
20904: PUSH
20905: LD_INT 3
20907: PUSH
20908: LD_INT 4
20910: PUSH
20911: LD_INT 5
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: LIST
20918: LIST
20919: IN
20920: AND
20921: IFFALSE 21158
// begin powellAnger := powellAnger + 1 ;
20923: LD_ADDR_EXP 17
20927: PUSH
20928: LD_EXP 17
20932: PUSH
20933: LD_INT 1
20935: PLUS
20936: ST_TO_ADDR
// Video ( true ) ;
20937: LD_INT 1
20939: PPUSH
20940: CALL 107381 0 1
// CenterNowOnUnits ( tmp ) ;
20944: LD_VAR 0 1
20948: PPUSH
20949: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20953: LD_INT 14
20955: PPUSH
20956: LD_INT 22
20958: PUSH
20959: LD_INT 1
20961: PUSH
20962: EMPTY
20963: LIST
20964: LIST
20965: PPUSH
20966: CALL_OW 70
20970: PPUSH
20971: LD_INT 86
20973: PPUSH
20974: LD_INT 133
20976: PPUSH
20977: CALL_OW 111
// async ;
20981: ASYNC
// case powellAnger of 1 :
20982: LD_EXP 17
20986: PUSH
20987: LD_INT 1
20989: DOUBLE
20990: EQUAL
20991: IFTRUE 20995
20993: GO 21010
20995: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20996: LD_EXP 61
21000: PPUSH
21001: LD_STRING DBack1-Pow-1
21003: PPUSH
21004: CALL_OW 88
21008: GO 21057
21010: LD_INT 2
21012: DOUBLE
21013: EQUAL
21014: IFTRUE 21018
21016: GO 21033
21018: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21019: LD_EXP 61
21023: PPUSH
21024: LD_STRING DBack2-Pow-1
21026: PPUSH
21027: CALL_OW 88
21031: GO 21057
21033: LD_INT 3
21035: DOUBLE
21036: EQUAL
21037: IFTRUE 21041
21039: GO 21056
21041: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21042: LD_EXP 61
21046: PPUSH
21047: LD_STRING DBack3-Pow-1
21049: PPUSH
21050: CALL_OW 88
21054: GO 21057
21056: POP
// sync ;
21057: SYNC
// repeat wait ( 0 0$1 ) ;
21058: LD_INT 35
21060: PPUSH
21061: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21065: LD_INT 14
21067: PPUSH
21068: LD_INT 22
21070: PUSH
21071: LD_INT 1
21073: PUSH
21074: EMPTY
21075: LIST
21076: LIST
21077: PPUSH
21078: CALL_OW 70
21082: PPUSH
21083: LD_INT 86
21085: PPUSH
21086: LD_INT 133
21088: PPUSH
21089: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21093: LD_INT 14
21095: PPUSH
21096: LD_INT 22
21098: PUSH
21099: LD_INT 1
21101: PUSH
21102: EMPTY
21103: LIST
21104: LIST
21105: PUSH
21106: LD_INT 3
21108: PUSH
21109: LD_INT 21
21111: PUSH
21112: LD_INT 3
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: PUSH
21119: EMPTY
21120: LIST
21121: LIST
21122: PUSH
21123: EMPTY
21124: LIST
21125: LIST
21126: PPUSH
21127: CALL_OW 70
21131: NOT
21132: IFFALSE 21058
// if powellAnger >= 3 then
21134: LD_EXP 17
21138: PUSH
21139: LD_INT 3
21141: GREATEREQUAL
21142: IFFALSE 21151
// YouLost ( Dismissed ) ;
21144: LD_STRING Dismissed
21146: PPUSH
21147: CALL_OW 104
// Video ( false ) ;
21151: LD_INT 0
21153: PPUSH
21154: CALL 107381 0 1
// end ; until missionStage > 5 ;
21158: LD_EXP 15
21162: PUSH
21163: LD_INT 5
21165: GREATER
21166: IFFALSE 20851
// end ;
21168: PPOPN 1
21170: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21171: LD_EXP 13
21175: PUSH
21176: LD_INT 22
21178: PUSH
21179: LD_INT 4
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: PUSH
21186: LD_INT 21
21188: PUSH
21189: LD_INT 2
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: PUSH
21196: EMPTY
21197: LIST
21198: LIST
21199: PPUSH
21200: CALL_OW 69
21204: PUSH
21205: LD_INT 4
21207: GREATEREQUAL
21208: AND
21209: PUSH
21210: LD_EXP 15
21214: PUSH
21215: LD_INT 2
21217: EQUAL
21218: AND
21219: IFFALSE 23469
21221: GO 21223
21223: DISABLE
21224: LD_INT 0
21226: PPUSH
21227: PPUSH
21228: PPUSH
21229: PPUSH
21230: PPUSH
21231: PPUSH
21232: PPUSH
21233: PPUSH
21234: PPUSH
21235: PPUSH
21236: PPUSH
// begin missionStage := 3 ;
21237: LD_ADDR_EXP 15
21241: PUSH
21242: LD_INT 3
21244: ST_TO_ADDR
// retreat := false ;
21245: LD_ADDR_VAR 0 4
21249: PUSH
21250: LD_INT 0
21252: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21253: LD_ADDR_VAR 0 5
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 4
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: PPUSH
21282: CALL_OW 69
21286: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21287: LD_ADDR_VAR 0 6
21291: PUSH
21292: LD_INT 22
21294: PUSH
21295: LD_INT 4
21297: PUSH
21298: EMPTY
21299: LIST
21300: LIST
21301: PUSH
21302: LD_INT 30
21304: PUSH
21305: LD_INT 5
21307: PUSH
21308: EMPTY
21309: LIST
21310: LIST
21311: PUSH
21312: EMPTY
21313: LIST
21314: LIST
21315: PPUSH
21316: CALL_OW 69
21320: ST_TO_ADDR
// if not bar then
21321: LD_VAR 0 6
21325: NOT
21326: IFFALSE 21379
// begin repeat wait ( 0 0$1 ) ;
21328: LD_INT 35
21330: PPUSH
21331: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21335: LD_INT 22
21337: PUSH
21338: LD_INT 4
21340: PUSH
21341: EMPTY
21342: LIST
21343: LIST
21344: PUSH
21345: LD_INT 3
21347: PUSH
21348: LD_INT 57
21350: PUSH
21351: EMPTY
21352: LIST
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PUSH
21358: LD_INT 30
21360: PUSH
21361: LD_INT 5
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: LIST
21372: PPUSH
21373: CALL_OW 69
21377: IFFALSE 21328
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21379: LD_ADDR_VAR 0 6
21383: PUSH
21384: LD_INT 22
21386: PUSH
21387: LD_INT 4
21389: PUSH
21390: EMPTY
21391: LIST
21392: LIST
21393: PUSH
21394: LD_INT 30
21396: PUSH
21397: LD_INT 5
21399: PUSH
21400: EMPTY
21401: LIST
21402: LIST
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: PPUSH
21408: CALL_OW 69
21412: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21413: LD_INT 35
21415: PPUSH
21416: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21420: LD_EXP 121
21424: PUSH
21425: LD_INT 4
21427: ARRAY
21428: PUSH
21429: LD_INT 4
21431: GREATEREQUAL
21432: IFFALSE 21413
// tmp := [ ] ;
21434: LD_ADDR_VAR 0 2
21438: PUSH
21439: EMPTY
21440: ST_TO_ADDR
// tmp2 := [ ] ;
21441: LD_ADDR_VAR 0 3
21445: PUSH
21446: EMPTY
21447: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21448: LD_ADDR_VAR 0 1
21452: PUSH
21453: LD_INT 22
21455: PUSH
21456: LD_INT 4
21458: PUSH
21459: EMPTY
21460: LIST
21461: LIST
21462: PUSH
21463: LD_INT 2
21465: PUSH
21466: LD_INT 25
21468: PUSH
21469: LD_INT 1
21471: PUSH
21472: EMPTY
21473: LIST
21474: LIST
21475: PUSH
21476: LD_INT 25
21478: PUSH
21479: LD_INT 2
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: PUSH
21486: LD_INT 25
21488: PUSH
21489: LD_INT 3
21491: PUSH
21492: EMPTY
21493: LIST
21494: LIST
21495: PUSH
21496: LD_INT 25
21498: PUSH
21499: LD_INT 4
21501: PUSH
21502: EMPTY
21503: LIST
21504: LIST
21505: PUSH
21506: LD_INT 25
21508: PUSH
21509: LD_INT 5
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: PUSH
21524: EMPTY
21525: LIST
21526: LIST
21527: PPUSH
21528: CALL_OW 69
21532: PUSH
21533: LD_EXP 61
21537: PUSH
21538: LD_EXP 62
21542: UNION
21543: DIFF
21544: PUSH
21545: FOR_IN
21546: IFFALSE 21608
// if not i in extraSquad then
21548: LD_VAR 0 1
21552: PUSH
21553: LD_EXP 63
21557: IN
21558: NOT
21559: IFFALSE 21583
// tmp := Join ( tmp , i ) else
21561: LD_ADDR_VAR 0 2
21565: PUSH
21566: LD_VAR 0 2
21570: PPUSH
21571: LD_VAR 0 1
21575: PPUSH
21576: CALL 107409 0 2
21580: ST_TO_ADDR
21581: GO 21606
// tmp := Insert ( tmp , 1 , i ) ;
21583: LD_ADDR_VAR 0 2
21587: PUSH
21588: LD_VAR 0 2
21592: PPUSH
21593: LD_INT 1
21595: PPUSH
21596: LD_VAR 0 1
21600: PPUSH
21601: CALL_OW 2
21605: ST_TO_ADDR
21606: GO 21545
21608: POP
21609: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21610: LD_ADDR_VAR 0 1
21614: PUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: LD_INT 26
21622: PUSH
21623: LD_INT 1
21625: PUSH
21626: EMPTY
21627: LIST
21628: LIST
21629: PPUSH
21630: CALL_OW 72
21634: PUSH
21635: FOR_IN
21636: IFFALSE 21687
// begin p := Inc ( p ) ;
21638: LD_ADDR_VAR 0 11
21642: PUSH
21643: LD_VAR 0 11
21647: PPUSH
21648: CALL 108770 0 1
21652: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21653: LD_ADDR_VAR 0 3
21657: PUSH
21658: LD_VAR 0 3
21662: PPUSH
21663: LD_VAR 0 1
21667: PPUSH
21668: CALL 107409 0 2
21672: ST_TO_ADDR
// if p = 4 then
21673: LD_VAR 0 11
21677: PUSH
21678: LD_INT 4
21680: EQUAL
21681: IFFALSE 21685
// break ;
21683: GO 21687
// end ;
21685: GO 21635
21687: POP
21688: POP
// tmp := tmp diff tmp2 ;
21689: LD_ADDR_VAR 0 2
21693: PUSH
21694: LD_VAR 0 2
21698: PUSH
21699: LD_VAR 0 3
21703: DIFF
21704: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21705: LD_ADDR_VAR 0 2
21709: PUSH
21710: LD_VAR 0 2
21714: PPUSH
21715: LD_INT 3
21717: PPUSH
21718: CALL 105913 0 2
21722: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21723: LD_ADDR_VAR 0 3
21727: PUSH
21728: LD_VAR 0 3
21732: PPUSH
21733: LD_INT 3
21735: PPUSH
21736: CALL 105913 0 2
21740: ST_TO_ADDR
// for i := 1 to 4 do
21741: LD_ADDR_VAR 0 1
21745: PUSH
21746: DOUBLE
21747: LD_INT 1
21749: DEC
21750: ST_TO_ADDR
21751: LD_INT 4
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21908
// begin if tmp2 then
21757: LD_VAR 0 3
21761: IFFALSE 21829
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21763: LD_ADDR_EXP 18
21767: PUSH
21768: LD_EXP 18
21772: PPUSH
21773: LD_INT 1
21775: PPUSH
21776: LD_EXP 18
21780: PUSH
21781: LD_INT 1
21783: ARRAY
21784: PUSH
21785: LD_VAR 0 3
21789: PUSH
21790: LD_VAR 0 3
21794: ARRAY
21795: ADD
21796: PPUSH
21797: CALL_OW 1
21801: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21802: LD_VAR 0 3
21806: PUSH
21807: LD_VAR 0 3
21811: ARRAY
21812: PPUSH
21813: LD_INT 1
21815: PPUSH
21816: CALL_OW 109
// tmp2 := [ ] ;
21820: LD_ADDR_VAR 0 3
21824: PUSH
21825: EMPTY
21826: ST_TO_ADDR
// end else
21827: GO 21906
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21829: LD_ADDR_EXP 18
21833: PUSH
21834: LD_EXP 18
21838: PPUSH
21839: LD_INT 1
21841: PPUSH
21842: LD_EXP 18
21846: PUSH
21847: LD_INT 1
21849: ARRAY
21850: PUSH
21851: LD_VAR 0 2
21855: PUSH
21856: LD_VAR 0 2
21860: ARRAY
21861: ADD
21862: PPUSH
21863: CALL_OW 1
21867: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21868: LD_VAR 0 2
21872: PUSH
21873: LD_VAR 0 2
21877: ARRAY
21878: PPUSH
21879: LD_INT 1
21881: PPUSH
21882: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21886: LD_ADDR_VAR 0 2
21890: PUSH
21891: LD_VAR 0 2
21895: PPUSH
21896: LD_VAR 0 2
21900: PPUSH
21901: CALL_OW 3
21905: ST_TO_ADDR
// end ; end ;
21906: GO 21754
21908: POP
21909: POP
// if tmp2 then
21910: LD_VAR 0 3
21914: IFFALSE 21932
// tmp := tmp union tmp2 ;
21916: LD_ADDR_VAR 0 2
21920: PUSH
21921: LD_VAR 0 2
21925: PUSH
21926: LD_VAR 0 3
21930: UNION
21931: ST_TO_ADDR
// for i := 1 to 4 do
21932: LD_ADDR_VAR 0 1
21936: PUSH
21937: DOUBLE
21938: LD_INT 1
21940: DEC
21941: ST_TO_ADDR
21942: LD_INT 4
21944: PUSH
21945: FOR_TO
21946: IFFALSE 21995
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21948: LD_ADDR_EXP 18
21952: PUSH
21953: LD_EXP 18
21957: PPUSH
21958: LD_INT 2
21960: PPUSH
21961: LD_EXP 18
21965: PUSH
21966: LD_INT 2
21968: ARRAY
21969: PUSH
21970: LD_VAR 0 2
21974: PUSH
21975: LD_VAR 0 2
21979: PUSH
21980: LD_VAR 0 1
21984: MINUS
21985: ARRAY
21986: ADD
21987: PPUSH
21988: CALL_OW 1
21992: ST_TO_ADDR
21993: GO 21945
21995: POP
21996: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21997: LD_ADDR_EXP 102
22001: PUSH
22002: LD_EXP 102
22006: PPUSH
22007: LD_INT 4
22009: PPUSH
22010: LD_EXP 102
22014: PUSH
22015: LD_INT 4
22017: ARRAY
22018: PUSH
22019: LD_EXP 18
22023: PUSH
22024: LD_INT 1
22026: ARRAY
22027: DIFF
22028: PPUSH
22029: CALL_OW 1
22033: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22034: LD_VAR 0 5
22038: PUSH
22039: LD_INT 1
22041: ARRAY
22042: PPUSH
22043: CALL_OW 313
22047: IFFALSE 22102
// begin for i in UnitsInside ( arm [ 1 ] ) do
22049: LD_ADDR_VAR 0 1
22053: PUSH
22054: LD_VAR 0 5
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PPUSH
22063: CALL_OW 313
22067: PUSH
22068: FOR_IN
22069: IFFALSE 22100
// begin ComExitBuilding ( i ) ;
22071: LD_VAR 0 1
22075: PPUSH
22076: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22080: LD_VAR 0 1
22084: PPUSH
22085: LD_VAR 0 6
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: PPUSH
22094: CALL_OW 180
// end ;
22098: GO 22068
22100: POP
22101: POP
// end ; wait ( 0 0$3 ) ;
22102: LD_INT 105
22104: PPUSH
22105: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22109: LD_ADDR_VAR 0 1
22113: PUSH
22114: LD_EXP 18
22118: PUSH
22119: LD_INT 1
22121: ARRAY
22122: PUSH
22123: FOR_IN
22124: IFFALSE 22231
// begin if IsInUnit ( i ) then
22126: LD_VAR 0 1
22130: PPUSH
22131: CALL_OW 310
22135: IFFALSE 22146
// ComExitBuilding ( i ) ;
22137: LD_VAR 0 1
22141: PPUSH
22142: CALL_OW 122
// if GetClass ( i ) <> 1 then
22146: LD_VAR 0 1
22150: PPUSH
22151: CALL_OW 257
22155: PUSH
22156: LD_INT 1
22158: NONEQUAL
22159: IFFALSE 22200
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22161: LD_VAR 0 1
22165: PPUSH
22166: LD_VAR 0 5
22170: PUSH
22171: LD_INT 1
22173: ARRAY
22174: PPUSH
22175: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22179: LD_VAR 0 1
22183: PPUSH
22184: LD_INT 1
22186: PPUSH
22187: CALL_OW 183
// AddComExitBuilding ( i ) ;
22191: LD_VAR 0 1
22195: PPUSH
22196: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22200: LD_VAR 0 1
22204: PPUSH
22205: LD_INT 60
22207: PPUSH
22208: LD_INT 94
22210: PPUSH
22211: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22215: LD_VAR 0 1
22219: PPUSH
22220: LD_EXP 61
22224: PPUSH
22225: CALL_OW 179
// end ;
22229: GO 22123
22231: POP
22232: POP
// wait ( 0 0$45 ) ;
22233: LD_INT 1575
22235: PPUSH
22236: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22240: LD_EXP 61
22244: PPUSH
22245: LD_STRING D4-Pow-1
22247: PPUSH
22248: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22252: LD_ADDR_VAR 0 2
22256: PUSH
22257: LD_EXP 18
22261: PUSH
22262: LD_INT 1
22264: ARRAY
22265: PPUSH
22266: LD_INT 26
22268: PUSH
22269: LD_INT 1
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: PPUSH
22276: CALL_OW 72
22280: ST_TO_ADDR
// if tmp then
22281: LD_VAR 0 2
22285: IFFALSE 22303
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22287: LD_VAR 0 2
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_STRING D4-Sol1-1
22298: PPUSH
22299: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22303: LD_EXP 61
22307: PPUSH
22308: LD_STRING D4-Pow-2
22310: PPUSH
22311: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22315: LD_ADDR_VAR 0 1
22319: PUSH
22320: DOUBLE
22321: LD_INT 1
22323: DEC
22324: ST_TO_ADDR
22325: LD_EXP 18
22329: PUSH
22330: LD_INT 1
22332: ARRAY
22333: PUSH
22334: FOR_TO
22335: IFFALSE 22428
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22337: LD_EXP 18
22341: PUSH
22342: LD_INT 1
22344: ARRAY
22345: PUSH
22346: LD_VAR 0 1
22350: ARRAY
22351: PPUSH
22352: LD_EXP 121
22356: PUSH
22357: LD_INT 4
22359: ARRAY
22360: PUSH
22361: LD_INT 1
22363: ARRAY
22364: PPUSH
22365: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22369: LD_ADDR_EXP 121
22373: PUSH
22374: LD_EXP 121
22378: PPUSH
22379: LD_INT 4
22381: PPUSH
22382: LD_EXP 121
22386: PUSH
22387: LD_INT 4
22389: ARRAY
22390: PPUSH
22391: LD_INT 1
22393: PPUSH
22394: CALL_OW 3
22398: PPUSH
22399: CALL_OW 1
22403: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22404: LD_INT 8
22406: PPUSH
22407: LD_EXP 18
22411: PUSH
22412: LD_INT 1
22414: ARRAY
22415: PUSH
22416: LD_VAR 0 1
22420: ARRAY
22421: PPUSH
22422: CALL_OW 471
// end ;
22426: GO 22334
22428: POP
22429: POP
// repeat wait ( 0 0$1 ) ;
22430: LD_INT 35
22432: PPUSH
22433: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22437: LD_EXP 18
22441: PUSH
22442: LD_INT 1
22444: ARRAY
22445: PPUSH
22446: LD_INT 55
22448: PUSH
22449: EMPTY
22450: LIST
22451: PPUSH
22452: CALL_OW 72
22456: PUSH
22457: LD_INT 4
22459: GREATEREQUAL
22460: IFFALSE 22430
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22462: LD_EXP 18
22466: PUSH
22467: LD_INT 1
22469: ARRAY
22470: PPUSH
22471: LD_INT 69
22473: PPUSH
22474: LD_INT 94
22476: PPUSH
22477: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22481: LD_EXP 18
22485: PUSH
22486: LD_INT 1
22488: ARRAY
22489: PPUSH
22490: LD_INT 82
22492: PPUSH
22493: LD_INT 83
22495: PPUSH
22496: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22500: LD_EXP 18
22504: PUSH
22505: LD_INT 1
22507: ARRAY
22508: PPUSH
22509: LD_INT 77
22511: PPUSH
22512: LD_INT 69
22514: PPUSH
22515: CALL_OW 174
// repeat wait ( 3 ) ;
22519: LD_INT 3
22521: PPUSH
22522: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22526: LD_ADDR_VAR 0 1
22530: PUSH
22531: LD_EXP 18
22535: PUSH
22536: LD_INT 1
22538: ARRAY
22539: PUSH
22540: FOR_IN
22541: IFFALSE 22677
// begin if GetLives ( i ) < 990 then
22543: LD_VAR 0 1
22547: PPUSH
22548: CALL_OW 256
22552: PUSH
22553: LD_INT 990
22555: LESS
22556: IFFALSE 22570
// SetLives ( i , 1000 ) ;
22558: LD_VAR 0 1
22562: PPUSH
22563: LD_INT 1000
22565: PPUSH
22566: CALL_OW 234
// if not IsInUnit ( i ) then
22570: LD_VAR 0 1
22574: PPUSH
22575: CALL_OW 310
22579: NOT
22580: IFFALSE 22675
// begin if not HasTask ( i ) then
22582: LD_VAR 0 1
22586: PPUSH
22587: CALL_OW 314
22591: NOT
22592: IFFALSE 22609
// ComMoveXY ( i , 64 , 93 ) ;
22594: LD_VAR 0 1
22598: PPUSH
22599: LD_INT 64
22601: PPUSH
22602: LD_INT 93
22604: PPUSH
22605: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22609: LD_VAR 0 4
22613: NOT
22614: PUSH
22615: LD_VAR 0 1
22619: PPUSH
22620: CALL_OW 258
22624: PUSH
22625: LD_INT 1
22627: EQUAL
22628: AND
22629: IFFALSE 22675
// begin retreat := true ;
22631: LD_ADDR_VAR 0 4
22635: PUSH
22636: LD_INT 1
22638: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22639: LD_VAR 0 1
22643: PPUSH
22644: LD_INT 2
22646: PPUSH
22647: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22651: LD_VAR 0 1
22655: PPUSH
22656: LD_STRING D4a-Sol1-1
22658: PPUSH
22659: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22663: LD_EXP 61
22667: PPUSH
22668: LD_STRING D4a-Pow-1
22670: PPUSH
22671: CALL_OW 88
// end ; end ; end ;
22675: GO 22540
22677: POP
22678: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22679: LD_EXP 18
22683: PUSH
22684: LD_INT 1
22686: ARRAY
22687: PPUSH
22688: LD_INT 95
22690: PUSH
22691: LD_INT 9
22693: PUSH
22694: EMPTY
22695: LIST
22696: LIST
22697: PUSH
22698: LD_INT 3
22700: PUSH
22701: LD_INT 55
22703: PUSH
22704: EMPTY
22705: LIST
22706: PUSH
22707: EMPTY
22708: LIST
22709: LIST
22710: PUSH
22711: EMPTY
22712: LIST
22713: LIST
22714: PPUSH
22715: CALL_OW 72
22719: PUSH
22720: LD_INT 4
22722: GREATEREQUAL
22723: IFFALSE 22519
// for i in powellSquadAttack [ 1 ] do
22725: LD_ADDR_VAR 0 1
22729: PUSH
22730: LD_EXP 18
22734: PUSH
22735: LD_INT 1
22737: ARRAY
22738: PUSH
22739: FOR_IN
22740: IFFALSE 22876
// begin if GetTag ( i ) = 2 then
22742: LD_VAR 0 1
22746: PPUSH
22747: CALL_OW 110
22751: PUSH
22752: LD_INT 2
22754: EQUAL
22755: IFFALSE 22817
// begin ComMoveXY ( i , 60 , 94 ) ;
22757: LD_VAR 0 1
22761: PPUSH
22762: LD_INT 60
22764: PPUSH
22765: LD_INT 94
22767: PPUSH
22768: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_EXP 61
22781: PPUSH
22782: CALL_OW 179
// wait ( 0 0$3 ) ;
22786: LD_INT 105
22788: PPUSH
22789: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22793: LD_VAR 0 1
22797: PPUSH
22798: LD_STRING D4a-Sol1-2
22800: PPUSH
22801: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22805: LD_EXP 61
22809: PPUSH
22810: LD_STRING D4a-Pow-2
22812: PPUSH
22813: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22817: LD_VAR 0 1
22821: PPUSH
22822: LD_INT 0
22824: PPUSH
22825: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22829: LD_ADDR_EXP 102
22833: PUSH
22834: LD_EXP 102
22838: PPUSH
22839: LD_INT 4
22841: PPUSH
22842: LD_EXP 102
22846: PUSH
22847: LD_INT 4
22849: ARRAY
22850: PUSH
22851: LD_VAR 0 1
22855: UNION
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22862: LD_INT 8
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: CALL_OW 472
// end ;
22874: GO 22739
22876: POP
22877: POP
// wait ( 2 2$00 ) ;
22878: LD_INT 4200
22880: PPUSH
22881: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22885: LD_ADDR_VAR 0 9
22889: PUSH
22890: LD_INT 22
22892: PUSH
22893: LD_INT 4
22895: PUSH
22896: EMPTY
22897: LIST
22898: LIST
22899: PUSH
22900: LD_INT 30
22902: PUSH
22903: LD_INT 32
22905: PUSH
22906: EMPTY
22907: LIST
22908: LIST
22909: PUSH
22910: LD_INT 58
22912: PUSH
22913: EMPTY
22914: LIST
22915: PUSH
22916: EMPTY
22917: LIST
22918: LIST
22919: LIST
22920: PPUSH
22921: CALL_OW 69
22925: ST_TO_ADDR
// if tmp then
22926: LD_VAR 0 2
22930: IFFALSE 23170
// begin for i := 1 to tmp do
22932: LD_ADDR_VAR 0 1
22936: PUSH
22937: DOUBLE
22938: LD_INT 1
22940: DEC
22941: ST_TO_ADDR
22942: LD_VAR 0 2
22946: PUSH
22947: FOR_TO
22948: IFFALSE 23161
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22950: LD_ADDR_EXP 102
22954: PUSH
22955: LD_EXP 102
22959: PPUSH
22960: LD_INT 4
22962: PPUSH
22963: LD_EXP 102
22967: PUSH
22968: LD_INT 4
22970: ARRAY
22971: PUSH
22972: LD_VAR 0 2
22976: PUSH
22977: LD_VAR 0 1
22981: ARRAY
22982: DIFF
22983: PPUSH
22984: CALL_OW 1
22988: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22989: LD_ADDR_VAR 0 10
22993: PUSH
22994: LD_VAR 0 2
22998: PUSH
22999: LD_VAR 0 1
23003: ARRAY
23004: PPUSH
23005: CALL_OW 310
23009: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23010: LD_VAR 0 10
23014: PUSH
23015: LD_VAR 0 10
23019: PPUSH
23020: CALL_OW 266
23024: PUSH
23025: LD_INT 32
23027: EQUAL
23028: AND
23029: IFFALSE 23033
// continue ;
23031: GO 22947
// if t then
23033: LD_VAR 0 10
23037: IFFALSE 23054
// ComExitBuilding ( tmp [ i ] ) ;
23039: LD_VAR 0 2
23043: PUSH
23044: LD_VAR 0 1
23048: ARRAY
23049: PPUSH
23050: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23054: LD_VAR 0 2
23058: PUSH
23059: LD_VAR 0 1
23063: ARRAY
23064: PPUSH
23065: LD_VAR 0 5
23069: PUSH
23070: LD_INT 1
23072: ARRAY
23073: PPUSH
23074: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23078: LD_VAR 0 2
23082: PUSH
23083: LD_VAR 0 1
23087: ARRAY
23088: PPUSH
23089: LD_INT 1
23091: PPUSH
23092: CALL_OW 183
// if emptyTowers then
23096: LD_VAR 0 9
23100: IFFALSE 23159
// begin AddComExitBuilding ( tmp [ i ] ) ;
23102: LD_VAR 0 2
23106: PUSH
23107: LD_VAR 0 1
23111: ARRAY
23112: PPUSH
23113: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23117: LD_VAR 0 2
23121: PUSH
23122: LD_VAR 0 1
23126: ARRAY
23127: PPUSH
23128: LD_VAR 0 9
23132: PUSH
23133: LD_INT 1
23135: ARRAY
23136: PPUSH
23137: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23141: LD_ADDR_VAR 0 9
23145: PUSH
23146: LD_VAR 0 9
23150: PPUSH
23151: LD_INT 1
23153: PPUSH
23154: CALL_OW 3
23158: ST_TO_ADDR
// end ; end ;
23159: GO 22947
23161: POP
23162: POP
// wait ( 0 0$30 ) ;
23163: LD_INT 1050
23165: PPUSH
23166: CALL_OW 67
// end ; uc_side := 6 ;
23170: LD_ADDR_OWVAR 20
23174: PUSH
23175: LD_INT 6
23177: ST_TO_ADDR
// uc_nation := 3 ;
23178: LD_ADDR_OWVAR 21
23182: PUSH
23183: LD_INT 3
23185: ST_TO_ADDR
// ru := [ ] ;
23186: LD_ADDR_VAR 0 7
23190: PUSH
23191: EMPTY
23192: ST_TO_ADDR
// for i = 1 to 5 do
23193: LD_ADDR_VAR 0 1
23197: PUSH
23198: DOUBLE
23199: LD_INT 1
23201: DEC
23202: ST_TO_ADDR
23203: LD_INT 5
23205: PUSH
23206: FOR_TO
23207: IFFALSE 23327
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23209: LD_INT 22
23211: PUSH
23212: LD_INT 23
23214: PUSH
23215: EMPTY
23216: LIST
23217: LIST
23218: PUSH
23219: LD_INT 1
23221: PPUSH
23222: LD_INT 2
23224: PPUSH
23225: CALL_OW 12
23229: ARRAY
23230: PPUSH
23231: LD_INT 1
23233: PPUSH
23234: LD_INT 3
23236: PPUSH
23237: LD_INT 43
23239: PUSH
23240: LD_INT 44
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 1
23249: PPUSH
23250: LD_INT 2
23252: PPUSH
23253: CALL_OW 12
23257: ARRAY
23258: PPUSH
23259: LD_INT 89
23261: PPUSH
23262: CALL 74558 0 5
// un := CreateVehicle ;
23266: LD_ADDR_VAR 0 8
23270: PUSH
23271: CALL_OW 45
23275: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23276: LD_VAR 0 8
23280: PPUSH
23281: LD_INT 4
23283: PPUSH
23284: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23288: LD_VAR 0 8
23292: PPUSH
23293: LD_INT 136
23295: PPUSH
23296: LD_INT 90
23298: PPUSH
23299: LD_INT 8
23301: PPUSH
23302: LD_INT 0
23304: PPUSH
23305: CALL_OW 50
// ru := ru ^ un ;
23309: LD_ADDR_VAR 0 7
23313: PUSH
23314: LD_VAR 0 7
23318: PUSH
23319: LD_VAR 0 8
23323: ADD
23324: ST_TO_ADDR
// end ;
23325: GO 23206
23327: POP
23328: POP
// if ru then
23329: LD_VAR 0 7
23333: IFFALSE 23350
// ComAgressiveMove ( ru , 57 , 94 ) ;
23335: LD_VAR 0 7
23339: PPUSH
23340: LD_INT 57
23342: PPUSH
23343: LD_INT 94
23345: PPUSH
23346: CALL_OW 114
// wait ( 3 3$00 ) ;
23350: LD_INT 6300
23352: PPUSH
23353: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23357: LD_INT 4
23359: PPUSH
23360: LD_INT 3
23362: PUSH
23363: LD_INT 1
23365: PUSH
23366: LD_INT 1
23368: PUSH
23369: LD_INT 5
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: PUSH
23378: LD_INT 4
23380: PUSH
23381: LD_INT 1
23383: PUSH
23384: LD_INT 1
23386: PUSH
23387: LD_INT 6
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: PUSH
23396: LD_INT 4
23398: PUSH
23399: LD_INT 1
23401: PUSH
23402: LD_INT 1
23404: PUSH
23405: LD_INT 7
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: PUSH
23414: LD_INT 3
23416: PUSH
23417: LD_INT 1
23419: PUSH
23420: LD_INT 1
23422: PUSH
23423: LD_INT 7
23425: PUSH
23426: EMPTY
23427: LIST
23428: LIST
23429: LIST
23430: LIST
23431: PUSH
23432: LD_INT 3
23434: PUSH
23435: LD_INT 1
23437: PUSH
23438: LD_INT 1
23440: PUSH
23441: LD_INT 5
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: LIST
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL 63244 0 2
// missionStage := 4 ;
23461: LD_ADDR_EXP 15
23465: PUSH
23466: LD_INT 4
23468: ST_TO_ADDR
// end ;
23469: PPOPN 11
23471: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23472: LD_EXP 15
23476: PUSH
23477: LD_INT 4
23479: EQUAL
23480: PUSH
23481: LD_INT 22
23483: PUSH
23484: LD_INT 4
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PUSH
23491: LD_INT 21
23493: PUSH
23494: LD_INT 2
23496: PUSH
23497: EMPTY
23498: LIST
23499: LIST
23500: PUSH
23501: EMPTY
23502: LIST
23503: LIST
23504: PPUSH
23505: CALL_OW 69
23509: PUSH
23510: LD_INT 5
23512: GREATEREQUAL
23513: AND
23514: IFFALSE 27781
23516: GO 23518
23518: DISABLE
23519: LD_INT 0
23521: PPUSH
23522: PPUSH
23523: PPUSH
23524: PPUSH
23525: PPUSH
23526: PPUSH
23527: PPUSH
23528: PPUSH
23529: PPUSH
23530: PPUSH
23531: PPUSH
23532: PPUSH
23533: PPUSH
// begin wait ( 0 0$10 ) ;
23534: LD_INT 350
23536: PPUSH
23537: CALL_OW 67
// missionStage := 5 ;
23541: LD_ADDR_EXP 15
23545: PUSH
23546: LD_INT 5
23548: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23549: LD_ADDR_VAR 0 10
23553: PUSH
23554: LD_INT 22
23556: PUSH
23557: LD_INT 4
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 2
23566: PUSH
23567: LD_INT 30
23569: PUSH
23570: LD_INT 4
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: PUSH
23577: LD_INT 30
23579: PUSH
23580: LD_INT 5
23582: PUSH
23583: EMPTY
23584: LIST
23585: LIST
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: LIST
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PPUSH
23596: CALL_OW 69
23600: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23601: LD_ADDR_VAR 0 6
23605: PUSH
23606: LD_INT 22
23608: PUSH
23609: LD_INT 4
23611: PUSH
23612: EMPTY
23613: LIST
23614: LIST
23615: PUSH
23616: LD_INT 21
23618: PUSH
23619: LD_INT 1
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 3
23628: PUSH
23629: LD_INT 25
23631: PUSH
23632: LD_INT 16
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: PUSH
23643: LD_INT 3
23645: PUSH
23646: LD_INT 25
23648: PUSH
23649: LD_INT 12
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: PPUSH
23666: CALL_OW 69
23670: PUSH
23671: LD_EXP 61
23675: DIFF
23676: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23677: LD_ADDR_VAR 0 9
23681: PUSH
23682: LD_INT 22
23684: PUSH
23685: LD_INT 4
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: LD_INT 30
23694: PUSH
23695: LD_INT 3
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PPUSH
23706: CALL_OW 69
23710: PUSH
23711: LD_INT 1
23713: ARRAY
23714: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23715: LD_INT 350
23717: PPUSH
23718: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23722: LD_EXP 121
23726: PUSH
23727: LD_INT 4
23729: ARRAY
23730: PUSH
23731: LD_INT 5
23733: LESS
23734: PUSH
23735: LD_VAR 0 9
23739: PPUSH
23740: CALL_OW 461
23744: PUSH
23745: LD_INT 2
23747: EQUAL
23748: AND
23749: IFFALSE 23779
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23751: LD_INT 4
23753: PPUSH
23754: LD_INT 3
23756: PUSH
23757: LD_INT 1
23759: PUSH
23760: LD_INT 1
23762: PUSH
23763: LD_INT 5
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: PUSH
23772: EMPTY
23773: LIST
23774: PPUSH
23775: CALL 63292 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23779: LD_EXP 121
23783: PUSH
23784: LD_INT 4
23786: ARRAY
23787: PUSH
23788: LD_INT 5
23790: GREATEREQUAL
23791: PUSH
23792: LD_EXP 121
23796: PUSH
23797: LD_INT 4
23799: ARRAY
23800: PPUSH
23801: LD_INT 58
23803: PUSH
23804: EMPTY
23805: LIST
23806: PPUSH
23807: CALL_OW 72
23811: PUSH
23812: LD_INT 5
23814: GREATEREQUAL
23815: AND
23816: IFFALSE 23715
// powellAllowRetreat := false ;
23818: LD_ADDR_EXP 19
23822: PUSH
23823: LD_INT 0
23825: ST_TO_ADDR
// activeAttacks := false ;
23826: LD_ADDR_EXP 16
23830: PUSH
23831: LD_INT 0
23833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23834: LD_INT 35
23836: PPUSH
23837: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23841: LD_INT 22
23843: PUSH
23844: LD_INT 6
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PPUSH
23851: CALL_OW 69
23855: PUSH
23856: LD_INT 0
23858: EQUAL
23859: IFFALSE 23834
// tmp := mc_vehicles [ 4 ] ;
23861: LD_ADDR_VAR 0 3
23865: PUSH
23866: LD_EXP 121
23870: PUSH
23871: LD_INT 4
23873: ARRAY
23874: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23875: LD_ADDR_VAR 0 1
23879: PUSH
23880: DOUBLE
23881: LD_INT 1
23883: DEC
23884: ST_TO_ADDR
23885: LD_EXP 18
23889: PUSH
23890: FOR_TO
23891: IFFALSE 24152
// begin for j in powellSquadAttack [ i ] do
23893: LD_ADDR_VAR 0 2
23897: PUSH
23898: LD_EXP 18
23902: PUSH
23903: LD_VAR 0 1
23907: ARRAY
23908: PUSH
23909: FOR_IN
23910: IFFALSE 24148
// begin forces := forces diff j ;
23912: LD_ADDR_VAR 0 6
23916: PUSH
23917: LD_VAR 0 6
23921: PUSH
23922: LD_VAR 0 2
23926: DIFF
23927: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23928: LD_VAR 0 2
23932: PPUSH
23933: LD_INT 1
23935: PPUSH
23936: CALL_OW 109
// wait ( 0 0$2 ) ;
23940: LD_INT 70
23942: PPUSH
23943: CALL_OW 67
// if IsInUnit ( j ) then
23947: LD_VAR 0 2
23951: PPUSH
23952: CALL_OW 310
23956: IFFALSE 23967
// ComExitBuilding ( j ) ;
23958: LD_VAR 0 2
23962: PPUSH
23963: CALL_OW 122
// if GetClass ( j ) <> 1 then
23967: LD_VAR 0 2
23971: PPUSH
23972: CALL_OW 257
23976: PUSH
23977: LD_INT 1
23979: NONEQUAL
23980: IFFALSE 24060
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23982: LD_VAR 0 10
23986: PUSH
23987: LD_INT 1
23989: ARRAY
23990: PPUSH
23991: CALL_OW 313
23995: PUSH
23996: LD_INT 5
23998: GREATEREQUAL
23999: IFFALSE 24021
// AddComEnterUnit ( j , arm [ 2 ] ) else
24001: LD_VAR 0 2
24005: PPUSH
24006: LD_VAR 0 10
24010: PUSH
24011: LD_INT 2
24013: ARRAY
24014: PPUSH
24015: CALL_OW 180
24019: GO 24039
// AddComEnterUnit ( j , arm [ 1 ] ) ;
24021: LD_VAR 0 2
24025: PPUSH
24026: LD_VAR 0 10
24030: PUSH
24031: LD_INT 1
24033: ARRAY
24034: PPUSH
24035: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
24039: LD_VAR 0 2
24043: PPUSH
24044: LD_INT 1
24046: PPUSH
24047: CALL_OW 183
// AddComExitBuilding ( j ) ;
24051: LD_VAR 0 2
24055: PPUSH
24056: CALL_OW 182
// end ; if i = 2 then
24060: LD_VAR 0 1
24064: PUSH
24065: LD_INT 2
24067: EQUAL
24068: IFFALSE 24085
// AddComMoveXY ( j , 61 , 93 ) ;
24070: LD_VAR 0 2
24074: PPUSH
24075: LD_INT 61
24077: PPUSH
24078: LD_INT 93
24080: PPUSH
24081: CALL_OW 171
// if i = 1 then
24085: LD_VAR 0 1
24089: PUSH
24090: LD_INT 1
24092: EQUAL
24093: IFFALSE 24146
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24095: LD_VAR 0 2
24099: PPUSH
24100: LD_VAR 0 3
24104: PUSH
24105: LD_INT 1
24107: ARRAY
24108: PPUSH
24109: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24113: LD_ADDR_VAR 0 3
24117: PUSH
24118: LD_VAR 0 3
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: CALL_OW 3
24130: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24131: LD_VAR 0 2
24135: PPUSH
24136: LD_INT 69
24138: PPUSH
24139: LD_INT 94
24141: PPUSH
24142: CALL_OW 171
// end ; end ;
24146: GO 23909
24148: POP
24149: POP
// end ;
24150: GO 23890
24152: POP
24153: POP
// wait ( 0 0$30 ) ;
24154: LD_INT 1050
24156: PPUSH
24157: CALL_OW 67
// MC_Kill ( 4 ) ;
24161: LD_INT 4
24163: PPUSH
24164: CALL 39267 0 1
// tmp := UnitsInside ( fac ) ;
24168: LD_ADDR_VAR 0 3
24172: PUSH
24173: LD_VAR 0 9
24177: PPUSH
24178: CALL_OW 313
24182: ST_TO_ADDR
// if tmp then
24183: LD_VAR 0 3
24187: IFFALSE 24308
// for i in tmp do
24189: LD_ADDR_VAR 0 1
24193: PUSH
24194: LD_VAR 0 3
24198: PUSH
24199: FOR_IN
24200: IFFALSE 24306
// begin ComExitBuilding ( i ) ;
24202: LD_VAR 0 1
24206: PPUSH
24207: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24211: LD_VAR 0 10
24215: PUSH
24216: LD_INT 2
24218: ARRAY
24219: PPUSH
24220: CALL_OW 313
24224: PUSH
24225: LD_INT 6
24227: LESS
24228: IFFALSE 24250
// AddComEnterUnit ( i , arm [ 2 ] ) else
24230: LD_VAR 0 1
24234: PPUSH
24235: LD_VAR 0 10
24239: PUSH
24240: LD_INT 2
24242: ARRAY
24243: PPUSH
24244: CALL_OW 180
24248: GO 24304
// if UnitsInside ( arm [ 1 ] ) < 6 then
24250: LD_VAR 0 10
24254: PUSH
24255: LD_INT 1
24257: ARRAY
24258: PPUSH
24259: CALL_OW 313
24263: PUSH
24264: LD_INT 6
24266: LESS
24267: IFFALSE 24289
// AddComEnterUnit ( i , arm [ 1 ] ) else
24269: LD_VAR 0 1
24273: PPUSH
24274: LD_VAR 0 10
24278: PUSH
24279: LD_INT 1
24281: ARRAY
24282: PPUSH
24283: CALL_OW 180
24287: GO 24304
// AddComMoveXY ( i , 37 , 68 ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 37
24296: PPUSH
24297: LD_INT 68
24299: PPUSH
24300: CALL_OW 171
// end ;
24304: GO 24199
24306: POP
24307: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24308: LD_ADDR_VAR 0 11
24312: PUSH
24313: LD_VAR 0 6
24317: PPUSH
24318: LD_INT 26
24320: PUSH
24321: LD_INT 1
24323: PUSH
24324: EMPTY
24325: LIST
24326: LIST
24327: PPUSH
24328: CALL_OW 72
24332: PUSH
24333: LD_EXP 62
24337: DIFF
24338: ST_TO_ADDR
// if not speaker then
24339: LD_VAR 0 11
24343: NOT
24344: IFFALSE 24371
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24346: LD_ADDR_VAR 0 11
24350: PUSH
24351: LD_VAR 0 6
24355: PPUSH
24356: LD_INT 26
24358: PUSH
24359: LD_INT 1
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PPUSH
24366: CALL_OW 72
24370: ST_TO_ADDR
// if speaker then
24371: LD_VAR 0 11
24375: IFFALSE 24391
// speaker := speaker [ 1 ] ;
24377: LD_ADDR_VAR 0 11
24381: PUSH
24382: LD_VAR 0 11
24386: PUSH
24387: LD_INT 1
24389: ARRAY
24390: ST_TO_ADDR
// Video ( true ) ;
24391: LD_INT 1
24393: PPUSH
24394: CALL 107381 0 1
// CenterNowOnUnits ( Powell ) ;
24398: LD_EXP 61
24402: PPUSH
24403: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24407: LD_ADDR_VAR 0 3
24411: PUSH
24412: LD_VAR 0 6
24416: PPUSH
24417: LD_INT 3
24419: PUSH
24420: LD_INT 25
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: PUSH
24430: EMPTY
24431: LIST
24432: LIST
24433: PPUSH
24434: CALL_OW 72
24438: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24439: LD_ADDR_VAR 0 12
24443: PUSH
24444: LD_INT 22
24446: PUSH
24447: LD_INT 4
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: PUSH
24454: LD_INT 30
24456: PUSH
24457: LD_INT 32
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PUSH
24464: LD_INT 58
24466: PUSH
24467: EMPTY
24468: LIST
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: LIST
24474: PPUSH
24475: CALL_OW 69
24479: ST_TO_ADDR
// for i := 1 to 4 do
24480: LD_ADDR_VAR 0 1
24484: PUSH
24485: DOUBLE
24486: LD_INT 1
24488: DEC
24489: ST_TO_ADDR
24490: LD_INT 4
24492: PUSH
24493: FOR_TO
24494: IFFALSE 24640
// begin if IsInUnit ( tmp [ i ] ) then
24496: LD_VAR 0 3
24500: PUSH
24501: LD_VAR 0 1
24505: ARRAY
24506: PPUSH
24507: CALL_OW 310
24511: IFFALSE 24528
// ComExitBuilding ( tmp [ i ] ) ;
24513: LD_VAR 0 3
24517: PUSH
24518: LD_VAR 0 1
24522: ARRAY
24523: PPUSH
24524: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24528: LD_VAR 0 3
24532: PUSH
24533: LD_VAR 0 1
24537: ARRAY
24538: PPUSH
24539: LD_VAR 0 10
24543: PUSH
24544: LD_INT 1
24546: ARRAY
24547: PPUSH
24548: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24552: LD_VAR 0 3
24556: PUSH
24557: LD_VAR 0 1
24561: ARRAY
24562: PPUSH
24563: LD_INT 1
24565: PPUSH
24566: CALL_OW 183
// if Count ( emp_towers ) then
24570: LD_VAR 0 12
24574: PPUSH
24575: CALL 71820 0 1
24579: IFFALSE 24638
// begin AddComExitBuilding ( tmp [ i ] ) ;
24581: LD_VAR 0 3
24585: PUSH
24586: LD_VAR 0 1
24590: ARRAY
24591: PPUSH
24592: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24596: LD_VAR 0 3
24600: PUSH
24601: LD_VAR 0 1
24605: ARRAY
24606: PPUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_INT 1
24614: ARRAY
24615: PPUSH
24616: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24620: LD_ADDR_VAR 0 12
24624: PUSH
24625: LD_VAR 0 12
24629: PPUSH
24630: LD_INT 1
24632: PPUSH
24633: CALL_OW 3
24637: ST_TO_ADDR
// end ; end ;
24638: GO 24493
24640: POP
24641: POP
// wait ( 0 0$5 ) ;
24642: LD_INT 175
24644: PPUSH
24645: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24649: LD_VAR 0 3
24653: PPUSH
24654: LD_INT 3
24656: PUSH
24657: LD_INT 54
24659: PUSH
24660: EMPTY
24661: LIST
24662: PUSH
24663: EMPTY
24664: LIST
24665: LIST
24666: PPUSH
24667: CALL_OW 72
24671: IFFALSE 24691
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24673: LD_VAR 0 3
24677: PPUSH
24678: LD_VAR 0 10
24682: PUSH
24683: LD_INT 1
24685: ARRAY
24686: PPUSH
24687: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24691: LD_ADDR_VAR 0 3
24695: PUSH
24696: LD_EXP 18
24700: PUSH
24701: LD_INT 1
24703: ARRAY
24704: PUSH
24705: LD_EXP 18
24709: PUSH
24710: LD_INT 2
24712: ARRAY
24713: ADD
24714: PPUSH
24715: LD_INT 26
24717: PUSH
24718: LD_INT 1
24720: PUSH
24721: EMPTY
24722: LIST
24723: LIST
24724: PPUSH
24725: CALL_OW 72
24729: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24730: LD_ADDR_VAR 0 1
24734: PUSH
24735: LD_EXP 18
24739: PUSH
24740: LD_INT 2
24742: ARRAY
24743: PUSH
24744: FOR_IN
24745: IFFALSE 24763
// ComTurnUnit ( i , Powell ) ;
24747: LD_VAR 0 1
24751: PPUSH
24752: LD_EXP 61
24756: PPUSH
24757: CALL_OW 119
24761: GO 24744
24763: POP
24764: POP
// Say ( Powell , D5-Pow-1 ) ;
24765: LD_EXP 61
24769: PPUSH
24770: LD_STRING D5-Pow-1
24772: PPUSH
24773: CALL_OW 88
// if tmp then
24777: LD_VAR 0 3
24781: IFFALSE 24799
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24783: LD_VAR 0 3
24787: PUSH
24788: LD_INT 1
24790: ARRAY
24791: PPUSH
24792: LD_STRING D5-Sol2-1
24794: PPUSH
24795: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24799: LD_EXP 61
24803: PPUSH
24804: LD_STRING D5-Pow-2
24806: PPUSH
24807: CALL_OW 88
// if tmp > 1 then
24811: LD_VAR 0 3
24815: PUSH
24816: LD_INT 1
24818: GREATER
24819: IFFALSE 24837
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24821: LD_VAR 0 3
24825: PUSH
24826: LD_INT 2
24828: ARRAY
24829: PPUSH
24830: LD_STRING D5-Sol2-2
24832: PPUSH
24833: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24837: LD_EXP 61
24841: PPUSH
24842: LD_STRING D5-Pow-3
24844: PPUSH
24845: CALL_OW 88
// wait ( 0 0$1 ) ;
24849: LD_INT 35
24851: PPUSH
24852: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24856: LD_ADDR_VAR 0 3
24860: PUSH
24861: LD_EXP 18
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PUSH
24870: LD_EXP 18
24874: PUSH
24875: LD_INT 2
24877: ARRAY
24878: UNION
24879: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24880: LD_VAR 0 3
24884: PPUSH
24885: LD_INT 80
24887: PPUSH
24888: LD_INT 67
24890: PPUSH
24891: CALL_OW 114
// wait ( 0 0$2 ) ;
24895: LD_INT 70
24897: PPUSH
24898: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24902: LD_INT 79
24904: PPUSH
24905: LD_INT 72
24907: PPUSH
24908: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24912: LD_INT 70
24914: PPUSH
24915: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24919: LD_VAR 0 3
24923: PPUSH
24924: LD_INT 3
24926: PUSH
24927: LD_INT 24
24929: PUSH
24930: LD_INT 1000
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PPUSH
24941: CALL_OW 72
24945: IFFALSE 24912
// Say ( Powell , D5a-Pow-1 ) ;
24947: LD_EXP 61
24951: PPUSH
24952: LD_STRING D5a-Pow-1
24954: PPUSH
24955: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24959: LD_EXP 61
24963: PPUSH
24964: LD_STRING D5a-Pow-1a
24966: PPUSH
24967: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24971: LD_INT 24
24973: PPUSH
24974: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24978: LD_EXP 61
24982: PPUSH
24983: LD_STRING D5a-Pow-1b
24985: PPUSH
24986: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24990: LD_INT 10
24992: PPUSH
24993: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24997: LD_EXP 61
25001: PPUSH
25002: LD_STRING D5a-Pow-1c
25004: PPUSH
25005: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25009: LD_VAR 0 3
25013: PPUSH
25014: LD_INT 68
25016: PPUSH
25017: LD_INT 63
25019: PPUSH
25020: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25024: LD_INT 18
25026: PPUSH
25027: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25031: LD_EXP 61
25035: PPUSH
25036: LD_STRING D5a-Pow-1d
25038: PPUSH
25039: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25043: LD_INT 35
25045: PPUSH
25046: CALL_OW 67
// if not HasTask ( tmp ) then
25050: LD_VAR 0 3
25054: PPUSH
25055: CALL_OW 314
25059: NOT
25060: IFFALSE 25077
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25062: LD_VAR 0 3
25066: PPUSH
25067: LD_INT 68
25069: PPUSH
25070: LD_INT 63
25072: PPUSH
25073: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25077: LD_VAR 0 3
25081: PPUSH
25082: LD_INT 24
25084: PUSH
25085: LD_INT 1
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: PPUSH
25092: CALL_OW 72
25096: NOT
25097: IFFALSE 25043
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25099: LD_ADDR_VAR 0 3
25103: PUSH
25104: LD_INT 22
25106: PUSH
25107: LD_INT 4
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: PUSH
25114: LD_INT 92
25116: PUSH
25117: LD_INT 60
25119: PUSH
25120: LD_INT 93
25122: PUSH
25123: LD_INT 10
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: LIST
25131: PUSH
25132: LD_INT 3
25134: PUSH
25135: LD_INT 54
25137: PUSH
25138: EMPTY
25139: LIST
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: PPUSH
25150: CALL_OW 69
25154: PUSH
25155: LD_EXP 61
25159: DIFF
25160: ST_TO_ADDR
// if tmp then
25161: LD_VAR 0 3
25165: IFFALSE 25199
// for i in tmp do
25167: LD_ADDR_VAR 0 1
25171: PUSH
25172: LD_VAR 0 3
25176: PUSH
25177: FOR_IN
25178: IFFALSE 25197
// ComMoveXY ( i , 36 , 67 ) ;
25180: LD_VAR 0 1
25184: PPUSH
25185: LD_INT 36
25187: PPUSH
25188: LD_INT 67
25190: PPUSH
25191: CALL_OW 111
25195: GO 25177
25197: POP
25198: POP
// wait ( 0 0$3 ) ;
25199: LD_INT 105
25201: PPUSH
25202: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25206: LD_VAR 0 11
25210: PPUSH
25211: LD_STRING D6-Sol3-1
25213: PPUSH
25214: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25218: LD_EXP 61
25222: PPUSH
25223: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25227: LD_EXP 61
25231: PPUSH
25232: LD_STRING D6-Pow-1
25234: PPUSH
25235: CALL_OW 88
// tmp := [ ] ;
25239: LD_ADDR_VAR 0 3
25243: PUSH
25244: EMPTY
25245: ST_TO_ADDR
// for i = 1 to 2 do
25246: LD_ADDR_VAR 0 1
25250: PUSH
25251: DOUBLE
25252: LD_INT 1
25254: DEC
25255: ST_TO_ADDR
25256: LD_INT 2
25258: PUSH
25259: FOR_TO
25260: IFFALSE 25374
// begin uc_side := 8 ;
25262: LD_ADDR_OWVAR 20
25266: PUSH
25267: LD_INT 8
25269: ST_TO_ADDR
// uc_nation := 2 ;
25270: LD_ADDR_OWVAR 21
25274: PUSH
25275: LD_INT 2
25277: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25278: LD_INT 14
25280: PPUSH
25281: LD_INT 3
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: LD_INT 29
25289: PPUSH
25290: LD_INT 100
25292: PPUSH
25293: CALL 74558 0 5
// veh := CreateVehicle ;
25297: LD_ADDR_VAR 0 13
25301: PUSH
25302: CALL_OW 45
25306: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25307: LD_VAR 0 13
25311: PPUSH
25312: LD_INT 4
25314: PPUSH
25315: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25319: LD_VAR 0 13
25323: PPUSH
25324: LD_INT 99
25326: PPUSH
25327: LD_INT 83
25329: PPUSH
25330: LD_INT 3
25332: PPUSH
25333: LD_INT 0
25335: PPUSH
25336: CALL_OW 50
// wait ( 3 ) ;
25340: LD_INT 3
25342: PPUSH
25343: CALL_OW 67
// Connect ( veh ) ;
25347: LD_VAR 0 13
25351: PPUSH
25352: CALL 78026 0 1
// tmp := tmp ^ veh ;
25356: LD_ADDR_VAR 0 3
25360: PUSH
25361: LD_VAR 0 3
25365: PUSH
25366: LD_VAR 0 13
25370: ADD
25371: ST_TO_ADDR
// end ;
25372: GO 25259
25374: POP
25375: POP
// wait ( 0 0$1 ) ;
25376: LD_INT 35
25378: PPUSH
25379: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25383: LD_INT 99
25385: PPUSH
25386: LD_INT 83
25388: PPUSH
25389: LD_INT 1
25391: PPUSH
25392: LD_INT 10
25394: PPUSH
25395: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25399: LD_INT 99
25401: PPUSH
25402: LD_INT 83
25404: PPUSH
25405: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25409: LD_VAR 0 11
25413: PPUSH
25414: LD_STRING D6-Sol3-2
25416: PPUSH
25417: CALL_OW 88
// async ;
25421: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25422: LD_EXP 61
25426: PPUSH
25427: LD_STRING D6-Pow-2
25429: PPUSH
25430: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25434: LD_VAR 0 3
25438: PUSH
25439: LD_INT 1
25441: ARRAY
25442: PPUSH
25443: LD_VAR 0 9
25447: PPUSH
25448: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25452: LD_VAR 0 3
25456: PUSH
25457: LD_INT 2
25459: ARRAY
25460: PPUSH
25461: LD_INT 22
25463: PUSH
25464: LD_INT 4
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 21
25473: PUSH
25474: LD_INT 3
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PPUSH
25485: CALL_OW 69
25489: PPUSH
25490: LD_VAR 0 3
25494: PUSH
25495: LD_INT 2
25497: ARRAY
25498: PPUSH
25499: CALL_OW 74
25503: PPUSH
25504: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25508: LD_EXP 61
25512: PPUSH
25513: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25517: LD_INT 99
25519: PPUSH
25520: LD_INT 83
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 331
// repeat wait ( 4 ) ;
25530: LD_INT 4
25532: PPUSH
25533: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25537: LD_VAR 0 3
25541: PUSH
25542: LD_INT 1
25544: ARRAY
25545: PPUSH
25546: CALL_OW 256
25550: PUSH
25551: LD_INT 1000
25553: LESS
25554: IFFALSE 25572
// SetLives ( tmp [ 1 ] , 1000 ) ;
25556: LD_VAR 0 3
25560: PUSH
25561: LD_INT 1
25563: ARRAY
25564: PPUSH
25565: LD_INT 1000
25567: PPUSH
25568: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25572: LD_INT 22
25574: PUSH
25575: LD_INT 4
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PUSH
25582: LD_INT 30
25584: PUSH
25585: LD_INT 3
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: EMPTY
25593: LIST
25594: LIST
25595: PPUSH
25596: CALL_OW 69
25600: PUSH
25601: LD_INT 0
25603: EQUAL
25604: IFFALSE 25530
// skirmish := false ;
25606: LD_ADDR_EXP 100
25610: PUSH
25611: LD_INT 0
25613: ST_TO_ADDR
// sync ;
25614: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25615: LD_EXP 61
25619: PPUSH
25620: LD_STRING D6a-Pow-1
25622: PPUSH
25623: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25627: LD_VAR 0 11
25631: PPUSH
25632: LD_STRING D6a-Sol3-1
25634: PPUSH
25635: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25639: LD_EXP 61
25643: PPUSH
25644: LD_STRING D6a-Pow-2
25646: PPUSH
25647: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25651: LD_VAR 0 11
25655: PPUSH
25656: LD_STRING D6a-Sol3-2
25658: PPUSH
25659: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25663: LD_EXP 61
25667: PPUSH
25668: LD_STRING D6a-Pow-3
25670: PPUSH
25671: CALL_OW 88
// powellCenterCameraMode := true ;
25675: LD_ADDR_EXP 20
25679: PUSH
25680: LD_INT 1
25682: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25683: LD_ADDR_VAR 0 1
25687: PUSH
25688: LD_INT 22
25690: PUSH
25691: LD_INT 8
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 25
25700: PUSH
25701: LD_INT 2
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: PPUSH
25712: CALL_OW 69
25716: PUSH
25717: FOR_IN
25718: IFFALSE 25773
// begin SetTag ( i , 1 ) ;
25720: LD_VAR 0 1
25724: PPUSH
25725: LD_INT 1
25727: PPUSH
25728: CALL_OW 109
// ComExitBuilding ( i ) ;
25732: LD_VAR 0 1
25736: PPUSH
25737: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25741: LD_VAR 0 1
25745: PPUSH
25746: LD_INT 35
25748: PPUSH
25749: LD_INT 6
25751: PPUSH
25752: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25756: LD_VAR 0 1
25760: PPUSH
25761: LD_INT 53
25763: PPUSH
25764: LD_INT 4
25766: PPUSH
25767: CALL_OW 171
// end ;
25771: GO 25717
25773: POP
25774: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25775: LD_ADDR_VAR 0 3
25779: PUSH
25780: LD_INT 22
25782: PUSH
25783: LD_INT 4
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PUSH
25790: LD_INT 21
25792: PUSH
25793: LD_INT 2
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PUSH
25800: LD_INT 3
25802: PUSH
25803: LD_INT 34
25805: PUSH
25806: LD_INT 12
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: LIST
25821: PPUSH
25822: CALL_OW 69
25826: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25827: LD_EXP 61
25831: PPUSH
25832: LD_VAR 0 3
25836: PPUSH
25837: LD_EXP 61
25841: PPUSH
25842: CALL_OW 74
25846: PPUSH
25847: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25851: LD_EXP 61
25855: PPUSH
25856: LD_INT 100
25858: PPUSH
25859: LD_INT 88
25861: PPUSH
25862: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25866: LD_EXP 61
25870: PPUSH
25871: LD_INT 100
25873: PPUSH
25874: LD_INT 75
25876: PPUSH
25877: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25881: LD_EXP 61
25885: PPUSH
25886: LD_INT 88
25888: PPUSH
25889: LD_INT 53
25891: PPUSH
25892: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25896: LD_INT 8
25898: PPUSH
25899: LD_EXP 61
25903: PPUSH
25904: CALL_OW 471
// repeat wait ( 3 ) ;
25908: LD_INT 3
25910: PPUSH
25911: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25915: LD_INT 22
25917: PUSH
25918: LD_INT 4
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 92
25927: PUSH
25928: LD_INT 100
25930: PUSH
25931: LD_INT 75
25933: PUSH
25934: LD_INT 6
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: PPUSH
25947: CALL_OW 69
25951: IFFALSE 25908
// async ;
25953: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25954: LD_EXP 61
25958: PPUSH
25959: LD_STRING D6b-Pow-1
25961: PPUSH
25962: CALL_OW 88
// repeat wait ( 3 ) ;
25966: LD_INT 3
25968: PPUSH
25969: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25973: LD_EXP 61
25977: PPUSH
25978: CALL_OW 310
25982: PPUSH
25983: CALL_OW 256
25987: PUSH
25988: LD_INT 1000
25990: LESS
25991: IFFALSE 26010
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25993: LD_EXP 61
25997: PPUSH
25998: CALL_OW 310
26002: PPUSH
26003: LD_INT 1000
26005: PPUSH
26006: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26010: LD_EXP 61
26014: PPUSH
26015: CALL_OW 256
26019: PUSH
26020: LD_INT 1000
26022: LESS
26023: IFFALSE 26037
// SetLives ( Powell , 1000 ) ;
26025: LD_EXP 61
26029: PPUSH
26030: LD_INT 1000
26032: PPUSH
26033: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26037: LD_EXP 61
26041: PPUSH
26042: LD_EXP 67
26046: PPUSH
26047: CALL_OW 296
26051: PUSH
26052: LD_INT 5
26054: LESS
26055: PUSH
26056: LD_EXP 61
26060: PPUSH
26061: CALL_OW 310
26065: PPUSH
26066: LD_EXP 67
26070: PPUSH
26071: CALL_OW 296
26075: PUSH
26076: LD_INT 5
26078: LESS
26079: OR
26080: IFFALSE 26099
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26082: LD_EXP 61
26086: PPUSH
26087: CALL_OW 310
26091: PPUSH
26092: LD_INT 100
26094: PPUSH
26095: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26099: LD_EXP 61
26103: PPUSH
26104: CALL_OW 310
26108: NOT
26109: IFFALSE 25966
// DoNotAttack ( 8 , powellBomb ) ;
26111: LD_INT 8
26113: PPUSH
26114: LD_EXP 67
26118: PPUSH
26119: CALL_OW 471
// game_speed := 4 ;
26123: LD_ADDR_OWVAR 65
26127: PUSH
26128: LD_INT 4
26130: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26131: LD_EXP 61
26135: PPUSH
26136: LD_STRING D6b-Pow-1a
26138: PPUSH
26139: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26143: LD_EXP 61
26147: PPUSH
26148: LD_EXP 67
26152: PPUSH
26153: CALL_OW 180
// sync ;
26157: SYNC
// repeat wait ( 0 0$1 ) ;
26158: LD_INT 35
26160: PPUSH
26161: CALL_OW 67
// until IsInUnit ( Powell ) ;
26165: LD_EXP 61
26169: PPUSH
26170: CALL_OW 310
26174: IFFALSE 26158
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26176: LD_INT 8
26178: PPUSH
26179: LD_EXP 61
26183: PPUSH
26184: CALL_OW 310
26188: PPUSH
26189: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26193: LD_EXP 61
26197: PPUSH
26198: LD_INT 91
26200: PPUSH
26201: LD_INT 44
26203: PPUSH
26204: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26208: LD_EXP 61
26212: PPUSH
26213: LD_INT 96
26215: PPUSH
26216: LD_INT 44
26218: PPUSH
26219: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26223: LD_EXP 61
26227: PPUSH
26228: LD_INT 96
26230: PPUSH
26231: LD_INT 41
26233: PPUSH
26234: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26238: LD_EXP 61
26242: PPUSH
26243: LD_INT 92
26245: PPUSH
26246: LD_INT 39
26248: PPUSH
26249: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26253: LD_EXP 61
26257: PPUSH
26258: LD_INT 88
26260: PPUSH
26261: LD_INT 41
26263: PPUSH
26264: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26268: LD_EXP 61
26272: PPUSH
26273: LD_INT 91
26275: PPUSH
26276: LD_INT 44
26278: PPUSH
26279: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26283: LD_EXP 61
26287: PPUSH
26288: LD_INT 96
26290: PPUSH
26291: LD_INT 44
26293: PPUSH
26294: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26298: LD_EXP 61
26302: PPUSH
26303: LD_INT 96
26305: PPUSH
26306: LD_INT 41
26308: PPUSH
26309: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26313: LD_EXP 61
26317: PPUSH
26318: LD_INT 92
26320: PPUSH
26321: LD_INT 39
26323: PPUSH
26324: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26328: LD_EXP 61
26332: PPUSH
26333: LD_INT 88
26335: PPUSH
26336: LD_INT 41
26338: PPUSH
26339: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26343: LD_EXP 61
26347: PPUSH
26348: LD_INT 91
26350: PPUSH
26351: LD_INT 44
26353: PPUSH
26354: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26358: LD_EXP 61
26362: PPUSH
26363: LD_INT 93
26365: PPUSH
26366: LD_INT 39
26368: PPUSH
26369: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26373: LD_EXP 61
26377: PPUSH
26378: LD_INT 93
26380: PPUSH
26381: LD_INT 36
26383: PPUSH
26384: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26388: LD_INT 122
26390: PPUSH
26391: CALL_OW 67
// game_speed := 4 ;
26395: LD_ADDR_OWVAR 65
26399: PUSH
26400: LD_INT 4
26402: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26403: LD_EXP 61
26407: PPUSH
26408: LD_STRING D6b-Pow-1b
26410: PPUSH
26411: CALL_OW 88
// tmp := [ ] ;
26415: LD_ADDR_VAR 0 3
26419: PUSH
26420: EMPTY
26421: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26422: LD_ADDR_VAR 0 5
26426: PUSH
26427: LD_INT 78
26429: PUSH
26430: LD_INT 47
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 106
26439: PUSH
26440: LD_INT 53
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26451: LD_ADDR_VAR 0 1
26455: PUSH
26456: LD_INT 22
26458: PUSH
26459: LD_INT 8
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: LD_INT 21
26468: PUSH
26469: LD_INT 3
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 92
26478: PUSH
26479: LD_INT 90
26481: PUSH
26482: LD_INT 52
26484: PUSH
26485: LD_INT 12
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: LIST
26492: LIST
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: LIST
26498: PPUSH
26499: CALL_OW 69
26503: PUSH
26504: FOR_IN
26505: IFFALSE 26530
// tmp := tmp ^ UnitsInside ( i ) ;
26507: LD_ADDR_VAR 0 3
26511: PUSH
26512: LD_VAR 0 3
26516: PUSH
26517: LD_VAR 0 1
26521: PPUSH
26522: CALL_OW 313
26526: ADD
26527: ST_TO_ADDR
26528: GO 26504
26530: POP
26531: POP
// for i in tmp do
26532: LD_ADDR_VAR 0 1
26536: PUSH
26537: LD_VAR 0 3
26541: PUSH
26542: FOR_IN
26543: IFFALSE 26705
// begin dist := 9999 ;
26545: LD_ADDR_VAR 0 8
26549: PUSH
26550: LD_INT 9999
26552: ST_TO_ADDR
// _xy := [ ] ;
26553: LD_ADDR_VAR 0 7
26557: PUSH
26558: EMPTY
26559: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26560: LD_VAR 0 1
26564: PPUSH
26565: LD_INT 1
26567: PPUSH
26568: CALL_OW 109
// ComExitBuilding ( i ) ;
26572: LD_VAR 0 1
26576: PPUSH
26577: CALL_OW 122
// for j in xy do
26581: LD_ADDR_VAR 0 2
26585: PUSH
26586: LD_VAR 0 5
26590: PUSH
26591: FOR_IN
26592: IFFALSE 26674
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26594: LD_VAR 0 1
26598: PPUSH
26599: LD_VAR 0 2
26603: PUSH
26604: LD_INT 1
26606: ARRAY
26607: PPUSH
26608: LD_VAR 0 2
26612: PUSH
26613: LD_INT 2
26615: ARRAY
26616: PPUSH
26617: CALL_OW 297
26621: PUSH
26622: LD_VAR 0 8
26626: LESS
26627: IFFALSE 26672
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26629: LD_ADDR_VAR 0 8
26633: PUSH
26634: LD_VAR 0 1
26638: PPUSH
26639: LD_VAR 0 2
26643: PUSH
26644: LD_INT 1
26646: ARRAY
26647: PPUSH
26648: LD_VAR 0 2
26652: PUSH
26653: LD_INT 2
26655: ARRAY
26656: PPUSH
26657: CALL_OW 297
26661: ST_TO_ADDR
// _xy := j ;
26662: LD_ADDR_VAR 0 7
26666: PUSH
26667: LD_VAR 0 2
26671: ST_TO_ADDR
// end ;
26672: GO 26591
26674: POP
26675: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26676: LD_VAR 0 1
26680: PPUSH
26681: LD_VAR 0 7
26685: PUSH
26686: LD_INT 1
26688: ARRAY
26689: PPUSH
26690: LD_VAR 0 7
26694: PUSH
26695: LD_INT 2
26697: ARRAY
26698: PPUSH
26699: CALL_OW 171
// end ;
26703: GO 26542
26705: POP
26706: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26707: LD_ADDR_VAR 0 4
26711: PUSH
26712: LD_VAR 0 3
26716: PPUSH
26717: LD_INT 26
26719: PUSH
26720: LD_INT 1
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PUSH
26727: LD_INT 25
26729: PUSH
26730: LD_INT 1
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PPUSH
26741: CALL_OW 72
26745: ST_TO_ADDR
// if tmp2 < 2 then
26746: LD_VAR 0 4
26750: PUSH
26751: LD_INT 2
26753: LESS
26754: IFFALSE 26823
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26756: LD_ADDR_VAR 0 4
26760: PUSH
26761: LD_INT 22
26763: PUSH
26764: LD_INT 8
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 26
26773: PUSH
26774: LD_INT 1
26776: PUSH
26777: EMPTY
26778: LIST
26779: LIST
26780: PUSH
26781: LD_INT 3
26783: PUSH
26784: LD_INT 25
26786: PUSH
26787: LD_INT 15
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: EMPTY
26799: LIST
26800: LIST
26801: LIST
26802: PPUSH
26803: CALL_OW 69
26807: PUSH
26808: LD_EXP 64
26812: PUSH
26813: LD_EXP 65
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: DIFF
26822: ST_TO_ADDR
// if tmp2 then
26823: LD_VAR 0 4
26827: IFFALSE 26845
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26829: LD_VAR 0 4
26833: PUSH
26834: LD_INT 1
26836: ARRAY
26837: PPUSH
26838: LD_STRING D6b-ArSol1-1
26840: PPUSH
26841: CALL_OW 88
// async ;
26845: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26846: LD_EXP 61
26850: PPUSH
26851: LD_STRING D6b-Pow-2
26853: PPUSH
26854: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26858: LD_INT 18
26860: PPUSH
26861: CALL_OW 67
// if tmp2 > 1 then
26865: LD_VAR 0 4
26869: PUSH
26870: LD_INT 1
26872: GREATER
26873: IFFALSE 26891
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26875: LD_VAR 0 4
26879: PUSH
26880: LD_INT 2
26882: ARRAY
26883: PPUSH
26884: LD_STRING D6b-ArSol2-1
26886: PPUSH
26887: CALL_OW 88
// sync ;
26891: SYNC
// repeat wait ( 5 ) ;
26892: LD_INT 5
26894: PPUSH
26895: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26899: LD_INT 93
26901: PPUSH
26902: LD_INT 36
26904: PPUSH
26905: CALL_OW 428
26909: PPUSH
26910: CALL_OW 255
26914: PUSH
26915: LD_INT 4
26917: EQUAL
26918: IFFALSE 26892
// DialogueOn ;
26920: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26924: LD_INT 10
26926: PPUSH
26927: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26931: LD_EXP 61
26935: PPUSH
26936: LD_STRING D6b-Pow-2a
26938: PPUSH
26939: CALL_OW 88
// DialogueOff ;
26943: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26947: LD_EXP 61
26951: PPUSH
26952: CALL_OW 310
26956: PPUSH
26957: LD_INT 332
26959: PPUSH
26960: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26964: LD_INT 93
26966: PPUSH
26967: LD_INT 35
26969: PPUSH
26970: LD_INT 1
26972: PPUSH
26973: LD_INT 6
26975: NEG
26976: PPUSH
26977: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26981: LD_INT 35
26983: PPUSH
26984: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26988: LD_INT 332
26990: PPUSH
26991: CALL_OW 256
26995: PUSH
26996: LD_INT 1000
26998: LESS
26999: PUSH
27000: LD_INT 332
27002: PPUSH
27003: CALL_OW 300
27007: AND
27008: IFFALSE 27020
// SetLives ( kozlov_fac , 0 ) ;
27010: LD_INT 332
27012: PPUSH
27013: LD_INT 0
27015: PPUSH
27016: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27020: LD_INT 332
27022: PPUSH
27023: CALL_OW 301
27027: PUSH
27028: LD_EXP 61
27032: PPUSH
27033: CALL_OW 301
27037: OR
27038: IFFALSE 26981
// game_speed := 4 ;
27040: LD_ADDR_OWVAR 65
27044: PUSH
27045: LD_INT 4
27047: ST_TO_ADDR
// powellCenterCameraMode := false ;
27048: LD_ADDR_EXP 20
27052: PUSH
27053: LD_INT 0
27055: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27056: LD_ADDR_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: PUSH
27066: LD_INT 22
27068: PUSH
27069: LD_INT 8
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 25
27078: PUSH
27079: LD_INT 2
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: PUSH
27086: EMPTY
27087: LIST
27088: LIST
27089: PPUSH
27090: CALL_OW 69
27094: UNION
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27113
// SetTag ( i , 0 ) ;
27099: LD_VAR 0 1
27103: PPUSH
27104: LD_INT 0
27106: PPUSH
27107: CALL_OW 109
27111: GO 27096
27113: POP
27114: POP
// wait ( 0 0$3 ) ;
27115: LD_INT 105
27117: PPUSH
27118: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27122: LD_INT 93
27124: PPUSH
27125: LD_INT 35
27127: PPUSH
27128: LD_INT 1
27130: PPUSH
27131: CALL_OW 331
// DialogueOn ;
27135: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27139: LD_VAR 0 11
27143: PPUSH
27144: LD_STRING D6c-Sol3-1
27146: PPUSH
27147: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27151: LD_INT 10
27153: PPUSH
27154: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27158: LD_EXP 40
27162: PPUSH
27163: LD_STRING D6c-JMM-1
27165: PPUSH
27166: CALL_OW 88
// if Cyrus then
27170: LD_EXP 46
27174: IFFALSE 27188
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27176: LD_EXP 46
27180: PPUSH
27181: LD_STRING D6c-Cyrus-1
27183: PPUSH
27184: CALL_OW 88
// if Bobby then
27188: LD_EXP 45
27192: IFFALSE 27206
// Say ( Bobby , D6c-Bobby-1 ) ;
27194: LD_EXP 45
27198: PPUSH
27199: LD_STRING D6c-Bobby-1
27201: PPUSH
27202: CALL_OW 88
// if Cornel then
27206: LD_EXP 51
27210: IFFALSE 27224
// Say ( Cornel , D6c-Corn-1 ) ;
27212: LD_EXP 51
27216: PPUSH
27217: LD_STRING D6c-Corn-1
27219: PPUSH
27220: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27224: LD_ADDR_VAR 0 4
27228: PUSH
27229: LD_INT 2
27231: PUSH
27232: LD_INT 22
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 22
27244: PUSH
27245: LD_INT 4
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: LIST
27256: PUSH
27257: LD_INT 26
27259: PUSH
27260: LD_INT 1
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PUSH
27267: LD_INT 23
27269: PUSH
27270: LD_INT 1
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: LIST
27281: PPUSH
27282: CALL_OW 69
27286: PUSH
27287: LD_VAR 0 11
27291: PUSH
27292: LD_EXP 40
27296: UNION
27297: PUSH
27298: LD_EXP 62
27302: UNION
27303: DIFF
27304: ST_TO_ADDR
// if tmp2 then
27305: LD_VAR 0 4
27309: IFFALSE 27327
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27311: LD_VAR 0 4
27315: PUSH
27316: LD_INT 1
27318: ARRAY
27319: PPUSH
27320: LD_STRING D6c-Sol1-1
27322: PPUSH
27323: CALL_OW 88
// if Lisa then
27327: LD_EXP 43
27331: IFFALSE 27345
// Say ( Lisa , D6c-Lisa-1 ) ;
27333: LD_EXP 43
27337: PPUSH
27338: LD_STRING D6c-Lisa-1
27340: PPUSH
27341: CALL_OW 88
// if Gary then
27345: LD_EXP 52
27349: IFFALSE 27363
// Say ( Gary , D6c-Gary-1 ) ;
27351: LD_EXP 52
27355: PPUSH
27356: LD_STRING D6c-Gary-1
27358: PPUSH
27359: CALL_OW 88
// if Donaldson then
27363: LD_EXP 44
27367: IFFALSE 27381
// Say ( Donaldson , D6c-Don-1 ) ;
27369: LD_EXP 44
27373: PPUSH
27374: LD_STRING D6c-Don-1
27376: PPUSH
27377: CALL_OW 88
// if tmp2 > 1 then
27381: LD_VAR 0 4
27385: PUSH
27386: LD_INT 1
27388: GREATER
27389: IFFALSE 27407
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27391: LD_VAR 0 4
27395: PUSH
27396: LD_INT 2
27398: ARRAY
27399: PPUSH
27400: LD_STRING D6c-Sol2-1
27402: PPUSH
27403: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27407: LD_VAR 0 11
27411: PPUSH
27412: LD_STRING D6c-Sol3-2
27414: PPUSH
27415: CALL_OW 88
// if IsInUnit ( JMM ) then
27419: LD_EXP 40
27423: PPUSH
27424: CALL_OW 310
27428: IFFALSE 27446
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27430: LD_EXP 40
27434: PPUSH
27435: CALL_OW 310
27439: PPUSH
27440: CALL_OW 87
27444: GO 27455
// CenterNowOnUnits ( JMM ) ;
27446: LD_EXP 40
27450: PPUSH
27451: CALL_OW 87
// dwait ( 0 0$2 ) ;
27455: LD_INT 70
27457: PPUSH
27458: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27462: LD_EXP 40
27466: PPUSH
27467: LD_STRING D6c-JMM-2
27469: PPUSH
27470: CALL_OW 88
// DialogueOff ;
27474: CALL_OW 7
// Video ( false ) ;
27478: LD_INT 0
27480: PPUSH
27481: CALL 107381 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27485: LD_INT 22
27487: PUSH
27488: LD_INT 4
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PPUSH
27495: CALL_OW 69
27499: PPUSH
27500: LD_INT 1
27502: PPUSH
27503: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27507: LD_INT 4
27509: PPUSH
27510: LD_INT 4
27512: PPUSH
27513: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27517: LD_ADDR_VAR 0 1
27521: PUSH
27522: LD_INT 4
27524: PPUSH
27525: LD_INT 1
27527: PPUSH
27528: LD_INT 2
27530: PPUSH
27531: CALL 69781 0 3
27535: PUSH
27536: FOR_IN
27537: IFFALSE 27574
// if GetTech ( i , 1 ) <> state_researched then
27539: LD_VAR 0 1
27543: PPUSH
27544: LD_INT 1
27546: PPUSH
27547: CALL_OW 321
27551: PUSH
27552: LD_INT 2
27554: NONEQUAL
27555: IFFALSE 27572
// SetTech ( i , 1 , state_researched ) ;
27557: LD_VAR 0 1
27561: PPUSH
27562: LD_INT 1
27564: PPUSH
27565: LD_INT 2
27567: PPUSH
27568: CALL_OW 322
27572: GO 27536
27574: POP
27575: POP
// missionStage := 6 ;
27576: LD_ADDR_EXP 15
27580: PUSH
27581: LD_INT 6
27583: ST_TO_ADDR
// activeAttacks := true ;
27584: LD_ADDR_EXP 16
27588: PUSH
27589: LD_INT 1
27591: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27592: LD_STRING M2
27594: PPUSH
27595: CALL_OW 337
// SaveForQuickRestart ;
27599: CALL_OW 22
// wait ( 0 0$40 ) ;
27603: LD_INT 1400
27605: PPUSH
27606: CALL_OW 67
// DialogueOn ;
27610: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27614: LD_EXP 66
27618: PPUSH
27619: LD_STRING D7-Friend-1
27621: PPUSH
27622: CALL 111474 0 2
// Say ( JMM , D7-JMM-1 ) ;
27626: LD_EXP 40
27630: PPUSH
27631: LD_STRING D7-JMM-1
27633: PPUSH
27634: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27638: LD_EXP 66
27642: PPUSH
27643: LD_STRING D7-Friend-2
27645: PPUSH
27646: CALL 111474 0 2
// Say ( JMM , D7-JMM-2 ) ;
27650: LD_EXP 40
27654: PPUSH
27655: LD_STRING D7-JMM-2
27657: PPUSH
27658: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27662: LD_EXP 66
27666: PPUSH
27667: LD_STRING D7-Friend-3
27669: PPUSH
27670: CALL 111474 0 2
// Say ( JMM , D7-JMM-3 ) ;
27674: LD_EXP 40
27678: PPUSH
27679: LD_STRING D7-JMM-3
27681: PPUSH
27682: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27686: LD_EXP 66
27690: PPUSH
27691: LD_STRING D7-Friend-4
27693: PPUSH
27694: CALL 111474 0 2
// Say ( JMM , D7-JMM-4 ) ;
27698: LD_EXP 40
27702: PPUSH
27703: LD_STRING D7-JMM-4
27705: PPUSH
27706: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27710: LD_EXP 66
27714: PPUSH
27715: LD_STRING D7-Friend-5
27717: PPUSH
27718: CALL 111474 0 2
// Say ( JMM , D7-JMM-5 ) ;
27722: LD_EXP 40
27726: PPUSH
27727: LD_STRING D7-JMM-5
27729: PPUSH
27730: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27734: LD_EXP 66
27738: PPUSH
27739: LD_STRING D7-Friend-6
27741: PPUSH
27742: CALL 111474 0 2
// Say ( JMM , D7-JMM-6 ) ;
27746: LD_EXP 40
27750: PPUSH
27751: LD_STRING D7-JMM-6
27753: PPUSH
27754: CALL_OW 88
// DialogueOff ;
27758: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27762: LD_STRING Mlegion
27764: PPUSH
27765: CALL_OW 337
// skirmish := true ;
27769: LD_ADDR_EXP 100
27773: PUSH
27774: LD_INT 1
27776: ST_TO_ADDR
// RebuildKozlovFactory ;
27777: CALL 5313 0 0
// end ;
27781: PPOPN 13
27783: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27784: LD_EXP 20
27788: PUSH
27789: LD_EXP 61
27793: PPUSH
27794: CALL_OW 300
27798: AND
27799: IFFALSE 27841
27801: GO 27803
27803: DISABLE
// begin enable ;
27804: ENABLE
// if IsInUnit ( Powell ) then
27805: LD_EXP 61
27809: PPUSH
27810: CALL_OW 310
27814: IFFALSE 27832
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27816: LD_EXP 61
27820: PPUSH
27821: CALL_OW 310
27825: PPUSH
27826: CALL_OW 85
27830: GO 27841
// CenterOnUnits ( Powell ) ;
27832: LD_EXP 61
27836: PPUSH
27837: CALL_OW 85
// end ;
27841: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27842: LD_INT 22
27844: PUSH
27845: LD_INT 8
27847: PUSH
27848: EMPTY
27849: LIST
27850: LIST
27851: PUSH
27852: LD_INT 34
27854: PUSH
27855: LD_INT 48
27857: PUSH
27858: EMPTY
27859: LIST
27860: LIST
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PPUSH
27866: CALL_OW 69
27870: IFFALSE 28144
27872: GO 27874
27874: DISABLE
27875: LD_INT 0
27877: PPUSH
27878: PPUSH
// begin if missionStage < 9 then
27879: LD_EXP 15
27883: PUSH
27884: LD_INT 9
27886: LESS
27887: IFFALSE 27897
// missionStage := 9 ;
27889: LD_ADDR_EXP 15
27893: PUSH
27894: LD_INT 9
27896: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27897: LD_ADDR_VAR 0 1
27901: PUSH
27902: LD_INT 22
27904: PUSH
27905: LD_INT 8
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 34
27914: PUSH
27915: LD_INT 48
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PPUSH
27926: CALL_OW 69
27930: PUSH
27931: LD_INT 1
27933: ARRAY
27934: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27935: LD_INT 175
27937: PPUSH
27938: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27942: LD_EXP 12
27946: PUSH
27947: LD_EXP 3
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: LD_INT 2
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: IN
27962: OR
27963: IFFALSE 27986
// target := [ 68 , 108 , 1 ] else
27965: LD_ADDR_VAR 0 2
27969: PUSH
27970: LD_INT 68
27972: PUSH
27973: LD_INT 108
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: LIST
27983: ST_TO_ADDR
27984: GO 28005
// target := [ 181 , 88 , 2 ] ;
27986: LD_ADDR_VAR 0 2
27990: PUSH
27991: LD_INT 181
27993: PUSH
27994: LD_INT 88
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: LIST
28004: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28005: LD_VAR 0 1
28009: PPUSH
28010: LD_VAR 0 2
28014: PUSH
28015: LD_INT 1
28017: ARRAY
28018: PPUSH
28019: LD_VAR 0 2
28023: PUSH
28024: LD_INT 2
28026: ARRAY
28027: PPUSH
28028: CALL_OW 176
// if target [ 3 ] = 1 then
28032: LD_VAR 0 2
28036: PUSH
28037: LD_INT 3
28039: ARRAY
28040: PUSH
28041: LD_INT 1
28043: EQUAL
28044: IFFALSE 28060
// SayRadio ( Kurt , D12-Kurt-1 ) else
28046: LD_EXP 64
28050: PPUSH
28051: LD_STRING D12-Kurt-1
28053: PPUSH
28054: CALL_OW 94
28058: GO 28084
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28060: LD_EXP 64
28064: PPUSH
28065: LD_STRING D12a-Kurt-1
28067: PPUSH
28068: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28072: LD_EXP 79
28076: PPUSH
28077: LD_STRING D12a-Roth-1
28079: PPUSH
28080: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28084: LD_INT 350
28086: PPUSH
28087: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28091: LD_VAR 0 1
28095: PPUSH
28096: LD_INT 22
28098: PUSH
28099: LD_INT 8
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 23
28108: PUSH
28109: LD_INT 2
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 30
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: LIST
28130: PPUSH
28131: CALL_OW 69
28135: PUSH
28136: LD_INT 1
28138: ARRAY
28139: PPUSH
28140: CALL_OW 228
// end ;
28144: PPOPN 2
28146: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28147: LD_EXP 64
28151: PPUSH
28152: CALL_OW 256
28156: PUSH
28157: LD_INT 999
28159: LESS
28160: PUSH
28161: LD_INT 22
28163: PUSH
28164: LD_INT 8
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 21
28173: PUSH
28174: LD_INT 1
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 23
28183: PUSH
28184: LD_INT 2
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: LIST
28195: PPUSH
28196: CALL_OW 69
28200: PUSH
28201: LD_INT 9
28203: PUSH
28204: LD_INT 8
28206: PUSH
28207: LD_INT 7
28209: PUSH
28210: LD_INT 6
28212: PUSH
28213: EMPTY
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: PUSH
28219: LD_OWVAR 67
28223: ARRAY
28224: LESSEQUAL
28225: OR
28226: PUSH
28227: LD_INT 22
28229: PUSH
28230: LD_INT 8
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 34
28239: PUSH
28240: LD_INT 48
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PPUSH
28251: CALL_OW 69
28255: NOT
28256: AND
28257: PUSH
28258: LD_EXP 64
28262: PPUSH
28263: CALL_OW 302
28267: AND
28268: PUSH
28269: LD_INT 5
28271: PPUSH
28272: LD_INT 22
28274: PUSH
28275: LD_INT 1
28277: PUSH
28278: EMPTY
28279: LIST
28280: LIST
28281: PPUSH
28282: CALL_OW 70
28286: AND
28287: IFFALSE 29049
28289: GO 28291
28291: DISABLE
28292: LD_INT 0
28294: PPUSH
28295: PPUSH
28296: PPUSH
// begin legionDestroyed := true ;
28297: LD_ADDR_EXP 22
28301: PUSH
28302: LD_INT 1
28304: ST_TO_ADDR
// DialogueOn ;
28305: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28309: LD_EXP 40
28313: PPUSH
28314: LD_STRING D13-JMM-1
28316: PPUSH
28317: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28321: LD_EXP 64
28325: PPUSH
28326: LD_STRING D13-Kurt-1
28328: PPUSH
28329: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28333: LD_EXP 40
28337: PPUSH
28338: LD_STRING D13-JMM-2
28340: PPUSH
28341: CALL_OW 88
// if FakeInfo then
28345: LD_EXP 12
28349: IFFALSE 28369
// begin Say ( Kurt , D13-Kurt-2 ) ;
28351: LD_EXP 64
28355: PPUSH
28356: LD_STRING D13-Kurt-2
28358: PPUSH
28359: CALL_OW 88
// DialogueOff ;
28363: CALL_OW 7
// exit ;
28367: GO 29049
// end ; if not KurtStatus then
28369: LD_EXP 3
28373: NOT
28374: IFFALSE 28390
// Say ( Kurt , D13-Kurt-2b ) else
28376: LD_EXP 64
28380: PPUSH
28381: LD_STRING D13-Kurt-2b
28383: PPUSH
28384: CALL_OW 88
28388: GO 28402
// Say ( Kurt , D13-Kurt-2a ) ;
28390: LD_EXP 64
28394: PPUSH
28395: LD_STRING D13-Kurt-2a
28397: PPUSH
28398: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28402: LD_EXP 40
28406: PPUSH
28407: LD_STRING D13-JMM-3
28409: PPUSH
28410: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28414: LD_EXP 64
28418: PPUSH
28419: LD_STRING D13-Kurt-3
28421: PPUSH
28422: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28426: LD_EXP 40
28430: PPUSH
28431: LD_STRING D13-JMM-4
28433: PPUSH
28434: CALL_OW 88
// DialogueOff ;
28438: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28442: LD_STRING MlegionOut
28444: PPUSH
28445: CALL_OW 337
// MC_Kill ( 3 ) ;
28449: LD_INT 3
28451: PPUSH
28452: CALL 39267 0 1
// KillUnit ( Kozlov ) ;
28456: LD_EXP 65
28460: PPUSH
28461: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28465: LD_ADDR_VAR 0 1
28469: PUSH
28470: LD_INT 22
28472: PUSH
28473: LD_INT 8
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 23
28482: PUSH
28483: LD_INT 3
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 3
28492: PUSH
28493: LD_INT 21
28495: PUSH
28496: LD_INT 33
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: EMPTY
28504: LIST
28505: LIST
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: LIST
28511: PPUSH
28512: CALL_OW 69
28516: PUSH
28517: FOR_IN
28518: IFFALSE 28531
// KillUnit ( i ) ;
28520: LD_VAR 0 1
28524: PPUSH
28525: CALL_OW 66
28529: GO 28517
28531: POP
28532: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28533: LD_ADDR_VAR 0 1
28537: PUSH
28538: LD_INT 22
28540: PUSH
28541: LD_INT 8
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 21
28550: PUSH
28551: LD_INT 2
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PPUSH
28562: CALL_OW 69
28566: PUSH
28567: FOR_IN
28568: IFFALSE 28581
// KillUnit ( i ) ;
28570: LD_VAR 0 1
28574: PPUSH
28575: CALL_OW 66
28579: GO 28567
28581: POP
28582: POP
// wait ( 0 0$0.6 ) ;
28583: LD_INT 21
28585: PPUSH
28586: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
28590: LD_INT 8
28592: PPUSH
28593: LD_INT 1
28595: PPUSH
28596: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28600: LD_ADDR_VAR 0 2
28604: PUSH
28605: LD_INT 22
28607: PUSH
28608: LD_INT 8
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: LD_INT 21
28617: PUSH
28618: LD_INT 1
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PPUSH
28629: CALL_OW 69
28633: PUSH
28634: LD_EXP 65
28638: PUSH
28639: LD_EXP 64
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: DIFF
28648: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28649: LD_VAR 0 2
28653: PUSH
28654: LD_INT 6
28656: PUSH
28657: LD_INT 5
28659: PUSH
28660: LD_INT 4
28662: PUSH
28663: LD_INT 3
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: PUSH
28672: LD_OWVAR 67
28676: ARRAY
28677: GREATEREQUAL
28678: IFFALSE 28830
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28680: LD_ADDR_VAR 0 3
28684: PUSH
28685: LD_INT 6
28687: PUSH
28688: LD_INT 5
28690: PUSH
28691: LD_INT 4
28693: PUSH
28694: LD_INT 3
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: PUSH
28703: LD_OWVAR 67
28707: ARRAY
28708: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28709: LD_ADDR_VAR 0 1
28713: PUSH
28714: DOUBLE
28715: LD_VAR 0 2
28719: PUSH
28720: LD_VAR 0 3
28724: PUSH
28725: LD_INT 1
28727: PLUS
28728: MINUS
28729: INC
28730: ST_TO_ADDR
28731: LD_INT 1
28733: PUSH
28734: FOR_DOWNTO
28735: IFFALSE 28826
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28737: LD_ADDR_EXP 38
28741: PUSH
28742: LD_EXP 38
28746: PUSH
28747: LD_VAR 0 2
28751: PUSH
28752: LD_VAR 0 1
28756: ARRAY
28757: ADD
28758: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28759: LD_VAR 0 2
28763: PUSH
28764: LD_VAR 0 1
28768: ARRAY
28769: PPUSH
28770: CALL_OW 310
28774: IFFALSE 28791
// ComExit ( tmp [ i ] ) ;
28776: LD_VAR 0 2
28780: PUSH
28781: LD_VAR 0 1
28785: ARRAY
28786: PPUSH
28787: CALL 107807 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28791: LD_VAR 0 2
28795: PUSH
28796: LD_VAR 0 1
28800: ARRAY
28801: PPUSH
28802: LD_INT 34
28804: PUSH
28805: LD_INT 0
28807: PPUSH
28808: LD_INT 6
28810: PPUSH
28811: CALL_OW 12
28815: PLUS
28816: PPUSH
28817: LD_INT 1
28819: PPUSH
28820: CALL_OW 171
// end ;
28824: GO 28734
28826: POP
28827: POP
// end else
28828: GO 28840
// x := tmp ;
28830: LD_ADDR_VAR 0 3
28834: PUSH
28835: LD_VAR 0 2
28839: ST_TO_ADDR
// for i := tmp downto tmp - x do
28840: LD_ADDR_VAR 0 1
28844: PUSH
28845: DOUBLE
28846: LD_VAR 0 2
28850: INC
28851: ST_TO_ADDR
28852: LD_VAR 0 2
28856: PUSH
28857: LD_VAR 0 3
28861: MINUS
28862: PUSH
28863: FOR_DOWNTO
28864: IFFALSE 28936
// begin if IsInUnit ( tmp [ i ] ) then
28866: LD_VAR 0 2
28870: PUSH
28871: LD_VAR 0 1
28875: ARRAY
28876: PPUSH
28877: CALL_OW 310
28881: IFFALSE 28898
// ComExit ( tmp [ i ] ) ;
28883: LD_VAR 0 2
28887: PUSH
28888: LD_VAR 0 1
28892: ARRAY
28893: PPUSH
28894: CALL 107807 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28898: LD_VAR 0 2
28902: PUSH
28903: LD_VAR 0 1
28907: ARRAY
28908: PPUSH
28909: LD_INT 1
28911: PPUSH
28912: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28916: LD_VAR 0 2
28920: PUSH
28921: LD_VAR 0 1
28925: ARRAY
28926: PPUSH
28927: LD_INT 1000
28929: PPUSH
28930: CALL_OW 234
// end ;
28934: GO 28863
28936: POP
28937: POP
// SetSide ( Kurt , 1 ) ;
28938: LD_EXP 64
28942: PPUSH
28943: LD_INT 1
28945: PPUSH
28946: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28950: LD_INT 22
28952: PUSH
28953: LD_INT 8
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 21
28962: PUSH
28963: LD_INT 3
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PPUSH
28974: CALL_OW 69
28978: PPUSH
28979: LD_INT 1
28981: PPUSH
28982: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28986: LD_INT 8
28988: PPUSH
28989: LD_INT 1
28991: PPUSH
28992: LD_INT 1
28994: PPUSH
28995: LD_INT 1
28997: PPUSH
28998: CALL_OW 80
// wait ( 1 1$20 ) ;
29002: LD_INT 2800
29004: PPUSH
29005: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29009: LD_EXP 66
29013: PPUSH
29014: LD_INT 37
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_INT 0
29022: PPUSH
29023: CALL_OW 48
// wait ( 0 0$1 ) ;
29027: LD_INT 35
29029: PPUSH
29030: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29034: LD_EXP 66
29038: PPUSH
29039: LD_INT 60
29041: PPUSH
29042: LD_INT 95
29044: PPUSH
29045: CALL_OW 111
// end ;
29049: PPOPN 3
29051: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29052: LD_EXP 22
29056: NOT
29057: PUSH
29058: LD_INT 22
29060: PUSH
29061: LD_INT 8
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 21
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PPUSH
29082: CALL_OW 69
29086: PUSH
29087: LD_INT 0
29089: EQUAL
29090: AND
29091: IFFALSE 29111
29093: GO 29095
29095: DISABLE
// begin legionDestroyed := true ;
29096: LD_ADDR_EXP 22
29100: PUSH
29101: LD_INT 1
29103: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29104: LD_STRING MlegionOut
29106: PPUSH
29107: CALL_OW 337
// end ;
29111: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29112: LD_EXP 38
29116: IFFALSE 29191
29118: GO 29120
29120: DISABLE
29121: LD_INT 0
29123: PPUSH
// begin enable ;
29124: ENABLE
// for i in legionEscapeUnits do
29125: LD_ADDR_VAR 0 1
29129: PUSH
29130: LD_EXP 38
29134: PUSH
29135: FOR_IN
29136: IFFALSE 29189
// begin if IsInArea ( i , legionEscapeArea ) then
29138: LD_VAR 0 1
29142: PPUSH
29143: LD_INT 31
29145: PPUSH
29146: CALL_OW 308
29150: IFFALSE 29163
// RemoveUnit ( i ) else
29152: LD_VAR 0 1
29156: PPUSH
29157: CALL_OW 64
29161: GO 29187
// if not HasTask ( i ) then
29163: LD_VAR 0 1
29167: PPUSH
29168: CALL_OW 314
29172: NOT
29173: IFFALSE 29187
// ComMoveToArea ( i , legionEscapeArea ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 31
29182: PPUSH
29183: CALL_OW 113
// end ;
29187: GO 29135
29189: POP
29190: POP
// end ;
29191: PPOPN 1
29193: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29194: LD_INT 1
29196: PPUSH
29197: LD_EXP 66
29201: PPUSH
29202: CALL_OW 292
29206: IFFALSE 29504
29208: GO 29210
29210: DISABLE
29211: LD_INT 0
29213: PPUSH
// begin wait ( 0 0$2 ) ;
29214: LD_INT 70
29216: PPUSH
29217: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29221: LD_EXP 66
29225: PPUSH
29226: CALL_OW 87
// DialogueOn ;
29230: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29234: LD_EXP 40
29238: PPUSH
29239: LD_STRING D14-JMM-1
29241: PPUSH
29242: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29246: LD_EXP 66
29250: PPUSH
29251: LD_STRING D14-Friend-1
29253: PPUSH
29254: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29258: LD_EXP 40
29262: PPUSH
29263: LD_STRING D14-JMM-2
29265: PPUSH
29266: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29270: LD_EXP 66
29274: PPUSH
29275: LD_STRING D14-Friend-2
29277: PPUSH
29278: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29282: LD_EXP 40
29286: PPUSH
29287: LD_STRING D14-JMM-3
29289: PPUSH
29290: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29294: LD_EXP 66
29298: PPUSH
29299: LD_STRING D14-Friend-3
29301: PPUSH
29302: CALL_OW 88
// DialogueOff ;
29306: CALL_OW 7
// dec := Query ( Q14 ) ;
29310: LD_ADDR_VAR 0 1
29314: PUSH
29315: LD_STRING Q14
29317: PPUSH
29318: CALL_OW 97
29322: ST_TO_ADDR
// if dec = 1 then
29323: LD_VAR 0 1
29327: PUSH
29328: LD_INT 1
29330: EQUAL
29331: IFFALSE 29365
// begin DialogueOn ;
29333: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29337: LD_EXP 40
29341: PPUSH
29342: LD_STRING D14a-JMM-1
29344: PPUSH
29345: CALL_OW 88
// DialogueOff ;
29349: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29353: LD_EXP 66
29357: PPUSH
29358: LD_INT 1
29360: PPUSH
29361: CALL_OW 235
// end ; if dec = 2 then
29365: LD_VAR 0 1
29369: PUSH
29370: LD_INT 2
29372: EQUAL
29373: IFFALSE 29426
// begin DialogueOn ;
29375: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29379: LD_EXP 40
29383: PPUSH
29384: LD_STRING D14b-JMM-1
29386: PPUSH
29387: CALL_OW 88
// DialogueOff ;
29391: CALL_OW 7
// wait ( 0 0$1 ) ;
29395: LD_INT 35
29397: PPUSH
29398: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29402: LD_EXP 66
29406: PPUSH
29407: LD_INT 9
29409: PPUSH
29410: LD_INT 2
29412: PPUSH
29413: CALL_OW 111
// AddComHold ( Friend ) ;
29417: LD_EXP 66
29421: PPUSH
29422: CALL_OW 200
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29504
// begin DialogueOn ;
29436: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29440: LD_EXP 40
29444: PPUSH
29445: LD_STRING D14c-JMM-1
29447: PPUSH
29448: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29452: LD_EXP 66
29456: PPUSH
29457: LD_STRING D14c-Friend-1
29459: PPUSH
29460: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29464: LD_EXP 40
29468: PPUSH
29469: LD_STRING D14c-JMM-2
29471: PPUSH
29472: CALL_OW 88
// DialogueOff ;
29476: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29480: LD_EXP 66
29484: PPUSH
29485: LD_INT 9
29487: PPUSH
29488: LD_INT 2
29490: PPUSH
29491: CALL_OW 111
// AddComHold ( Friend ) ;
29495: LD_EXP 66
29499: PPUSH
29500: CALL_OW 200
// end ; end ;
29504: PPOPN 1
29506: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29507: LD_INT 9
29509: PPUSH
29510: LD_INT 2
29512: PPUSH
29513: CALL_OW 428
29517: PUSH
29518: LD_EXP 66
29522: EQUAL
29523: PUSH
29524: LD_EXP 66
29528: PPUSH
29529: CALL_OW 255
29533: PUSH
29534: LD_INT 8
29536: EQUAL
29537: AND
29538: IFFALSE 29552
29540: GO 29542
29542: DISABLE
// RemoveUnit ( Friend ) ;
29543: LD_EXP 66
29547: PPUSH
29548: CALL_OW 64
29552: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29553: LD_EXP 14
29557: PUSH
29558: LD_INT 31500
29560: GREATEREQUAL
29561: PUSH
29562: LD_EXP 7
29566: AND
29567: PUSH
29568: LD_EXP 2
29572: AND
29573: IFFALSE 30019
29575: GO 29577
29577: DISABLE
29578: LD_INT 0
29580: PPUSH
29581: PPUSH
29582: PPUSH
// begin missionStage := 7 ;
29583: LD_ADDR_EXP 15
29587: PUSH
29588: LD_INT 7
29590: ST_TO_ADDR
// for i := 1 to 5 do
29591: LD_ADDR_VAR 0 1
29595: PUSH
29596: DOUBLE
29597: LD_INT 1
29599: DEC
29600: ST_TO_ADDR
29601: LD_INT 5
29603: PUSH
29604: FOR_TO
29605: IFFALSE 29717
// begin uc_side = 1 ;
29607: LD_ADDR_OWVAR 20
29611: PUSH
29612: LD_INT 1
29614: ST_TO_ADDR
// uc_nation = 1 ;
29615: LD_ADDR_OWVAR 21
29619: PUSH
29620: LD_INT 1
29622: ST_TO_ADDR
// vc_engine = 3 ;
29623: LD_ADDR_OWVAR 39
29627: PUSH
29628: LD_INT 3
29630: ST_TO_ADDR
// vc_control = 3 ;
29631: LD_ADDR_OWVAR 38
29635: PUSH
29636: LD_INT 3
29638: ST_TO_ADDR
// vc_chassis = 3 ;
29639: LD_ADDR_OWVAR 37
29643: PUSH
29644: LD_INT 3
29646: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29647: LD_ADDR_OWVAR 40
29651: PUSH
29652: LD_INT 5
29654: PUSH
29655: LD_INT 9
29657: PUSH
29658: LD_INT 7
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 1
29668: PPUSH
29669: LD_INT 3
29671: PPUSH
29672: CALL_OW 12
29676: ARRAY
29677: ST_TO_ADDR
// veh = CreateVehicle ;
29678: LD_ADDR_VAR 0 2
29682: PUSH
29683: CALL_OW 45
29687: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29688: LD_VAR 0 2
29692: PPUSH
29693: LD_INT 1
29695: PPUSH
29696: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29700: LD_VAR 0 2
29704: PPUSH
29705: LD_INT 19
29707: PPUSH
29708: LD_INT 0
29710: PPUSH
29711: CALL_OW 49
// end ;
29715: GO 29604
29717: POP
29718: POP
// uc_side = 1 ;
29719: LD_ADDR_OWVAR 20
29723: PUSH
29724: LD_INT 1
29726: ST_TO_ADDR
// uc_nation = 1 ;
29727: LD_ADDR_OWVAR 21
29731: PUSH
29732: LD_INT 1
29734: ST_TO_ADDR
// vc_engine = 3 ;
29735: LD_ADDR_OWVAR 39
29739: PUSH
29740: LD_INT 3
29742: ST_TO_ADDR
// vc_control = 1 ;
29743: LD_ADDR_OWVAR 38
29747: PUSH
29748: LD_INT 1
29750: ST_TO_ADDR
// vc_chassis = 3 ;
29751: LD_ADDR_OWVAR 37
29755: PUSH
29756: LD_INT 3
29758: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29759: LD_ADDR_OWVAR 40
29763: PUSH
29764: LD_INT 5
29766: PUSH
29767: LD_INT 9
29769: PUSH
29770: LD_INT 7
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 1
29780: PPUSH
29781: LD_INT 3
29783: PPUSH
29784: CALL_OW 12
29788: ARRAY
29789: ST_TO_ADDR
// vehG = CreateVehicle ;
29790: LD_ADDR_VAR 0 3
29794: PUSH
29795: CALL_OW 45
29799: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29800: LD_VAR 0 3
29804: PPUSH
29805: LD_INT 1
29807: PPUSH
29808: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29812: LD_VAR 0 3
29816: PPUSH
29817: LD_INT 19
29819: PPUSH
29820: LD_INT 0
29822: PPUSH
29823: CALL_OW 49
// if JMMGirl = 1 then
29827: LD_EXP 7
29831: PUSH
29832: LD_INT 1
29834: EQUAL
29835: IFFALSE 29891
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29837: LD_ADDR_EXP 41
29841: PUSH
29842: LD_STRING Joan
29844: PPUSH
29845: LD_INT 1
29847: PPUSH
29848: LD_STRING 14_
29850: PPUSH
29851: CALL 69718 0 3
29855: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29856: LD_EXP 41
29860: PPUSH
29861: LD_VAR 0 3
29865: PPUSH
29866: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29870: LD_VAR 0 3
29874: PPUSH
29875: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29879: LD_EXP 41
29883: PPUSH
29884: LD_STRING D10BW-Joan-1
29886: PPUSH
29887: CALL_OW 94
// end ; if JMMGirl = 2 then
29891: LD_EXP 7
29895: PUSH
29896: LD_INT 2
29898: EQUAL
29899: IFFALSE 29955
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29901: LD_ADDR_EXP 43
29905: PUSH
29906: LD_STRING Lisa
29908: PPUSH
29909: LD_INT 1
29911: PPUSH
29912: LD_STRING 14_
29914: PPUSH
29915: CALL 69718 0 3
29919: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29920: LD_EXP 43
29924: PPUSH
29925: LD_VAR 0 3
29929: PPUSH
29930: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29934: LD_VAR 0 3
29938: PPUSH
29939: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29943: LD_EXP 43
29947: PPUSH
29948: LD_STRING D10BW-Lisa-1
29950: PPUSH
29951: CALL_OW 94
// end ; if JMMGirl = 3 then
29955: LD_EXP 7
29959: PUSH
29960: LD_INT 3
29962: EQUAL
29963: IFFALSE 30019
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29965: LD_ADDR_EXP 55
29969: PUSH
29970: LD_STRING Connie
29972: PPUSH
29973: LD_INT 1
29975: PPUSH
29976: LD_STRING 14_
29978: PPUSH
29979: CALL 69718 0 3
29983: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29984: LD_EXP 55
29988: PPUSH
29989: LD_VAR 0 3
29993: PPUSH
29994: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29998: LD_VAR 0 3
30002: PPUSH
30003: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30007: LD_EXP 55
30011: PPUSH
30012: LD_STRING D10BW-Con-1
30014: PPUSH
30015: CALL_OW 94
// end ; end ;
30019: PPOPN 3
30021: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30022: LD_EXP 14
30026: PUSH
30027: LD_INT 94500
30029: GREATEREQUAL
30030: IFFALSE 30442
30032: GO 30034
30034: DISABLE
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
// begin tmp := PrepareStevensSquad ;
30040: LD_ADDR_VAR 0 3
30044: PUSH
30045: CALL 2323 0 0
30049: ST_TO_ADDR
// if not tmp then
30050: LD_VAR 0 3
30054: NOT
30055: IFFALSE 30059
// exit ;
30057: GO 30442
// uc_side := 1 ;
30059: LD_ADDR_OWVAR 20
30063: PUSH
30064: LD_INT 1
30066: ST_TO_ADDR
// uc_nation := 1 ;
30067: LD_ADDR_OWVAR 21
30071: PUSH
30072: LD_INT 1
30074: ST_TO_ADDR
// for i in tmp do
30075: LD_ADDR_VAR 0 1
30079: PUSH
30080: LD_VAR 0 3
30084: PUSH
30085: FOR_IN
30086: IFFALSE 30183
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30088: LD_INT 3
30090: PPUSH
30091: LD_INT 3
30093: PPUSH
30094: LD_INT 1
30096: PPUSH
30097: LD_INT 5
30099: PUSH
30100: LD_INT 9
30102: PUSH
30103: LD_INT 7
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 1
30113: PPUSH
30114: LD_INT 3
30116: PPUSH
30117: CALL_OW 12
30121: ARRAY
30122: PPUSH
30123: LD_INT 40
30125: PPUSH
30126: CALL 74558 0 5
// veh := CreateVehicle ;
30130: LD_ADDR_VAR 0 2
30134: PUSH
30135: CALL_OW 45
30139: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30140: LD_VAR 0 2
30144: PPUSH
30145: LD_INT 1
30147: PPUSH
30148: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30152: LD_VAR 0 2
30156: PPUSH
30157: LD_INT 19
30159: PPUSH
30160: LD_INT 0
30162: PPUSH
30163: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30167: LD_VAR 0 1
30171: PPUSH
30172: LD_VAR 0 2
30176: PPUSH
30177: CALL_OW 52
// end ;
30181: GO 30085
30183: POP
30184: POP
// missionStage := 8 ;
30185: LD_ADDR_EXP 15
30189: PUSH
30190: LD_INT 8
30192: ST_TO_ADDR
// DialogueOn ;
30193: CALL_OW 6
// if Stevens then
30197: LD_EXP 42
30201: IFFALSE 30315
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30203: LD_EXP 42
30207: PPUSH
30208: CALL_OW 310
30212: PPUSH
30213: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30217: LD_EXP 42
30221: PPUSH
30222: LD_STRING D8-Huck-1
30224: PPUSH
30225: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30229: LD_EXP 40
30233: PPUSH
30234: LD_STRING D8-JMM-1
30236: PPUSH
30237: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30241: LD_EXP 42
30245: PPUSH
30246: LD_STRING D8-Huck-2
30248: PPUSH
30249: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30253: LD_EXP 40
30257: PPUSH
30258: LD_STRING D8-JMM-2
30260: PPUSH
30261: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30265: LD_EXP 42
30269: PPUSH
30270: LD_STRING D8-Huck-3
30272: PPUSH
30273: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30277: LD_EXP 40
30281: PPUSH
30282: LD_STRING D8-JMM-3
30284: PPUSH
30285: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30289: LD_EXP 42
30293: PPUSH
30294: LD_STRING D8-Huck-4
30296: PPUSH
30297: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30301: LD_EXP 40
30305: PPUSH
30306: LD_STRING D8-JMM-4
30308: PPUSH
30309: CALL_OW 88
// end else
30313: GO 30425
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30315: LD_EXP 56
30319: PPUSH
30320: CALL_OW 310
30324: PPUSH
30325: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30329: LD_EXP 56
30333: PPUSH
30334: LD_STRING D8-Huck-1
30336: PPUSH
30337: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30341: LD_EXP 40
30345: PPUSH
30346: LD_STRING D8-JMM-1a
30348: PPUSH
30349: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30353: LD_EXP 56
30357: PPUSH
30358: LD_STRING D8-Huck-2
30360: PPUSH
30361: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30365: LD_EXP 40
30369: PPUSH
30370: LD_STRING D8-JMM-2
30372: PPUSH
30373: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30377: LD_EXP 56
30381: PPUSH
30382: LD_STRING D8-Huck-3
30384: PPUSH
30385: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30389: LD_EXP 40
30393: PPUSH
30394: LD_STRING D8-JMM-3
30396: PPUSH
30397: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30401: LD_EXP 56
30405: PPUSH
30406: LD_STRING D8-Huck-4
30408: PPUSH
30409: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30413: LD_EXP 40
30417: PPUSH
30418: LD_STRING D8-JMM-4
30420: PPUSH
30421: CALL_OW 88
// end ; DialogueOff ;
30425: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30429: LD_INT 25
30431: PPUSH
30432: LD_INT 1
30434: PPUSH
30435: LD_INT 1
30437: PPUSH
30438: CALL_OW 322
// end ;
30442: PPOPN 3
30444: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30445: LD_EXP 75
30449: PPUSH
30450: CALL_OW 302
30454: PUSH
30455: LD_INT 1
30457: PPUSH
30458: LD_EXP 75
30462: PPUSH
30463: CALL_OW 292
30467: AND
30468: IFFALSE 30719
30470: GO 30472
30472: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30473: LD_EXP 75
30477: PPUSH
30478: CALL_OW 87
// DialogueOn ;
30482: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30486: LD_EXP 40
30490: PPUSH
30491: LD_STRING D10nB-JMM-1
30493: PPUSH
30494: CALL_OW 88
// if BurlakStatus = 1 then
30498: LD_EXP 9
30502: PUSH
30503: LD_INT 1
30505: EQUAL
30506: IFFALSE 30520
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30508: LD_EXP 74
30512: PPUSH
30513: LD_STRING D10nB-Vse-1a
30515: PPUSH
30516: CALL_OW 94
// end ; if BurlakStatus = 0 then
30520: LD_EXP 9
30524: PUSH
30525: LD_INT 0
30527: EQUAL
30528: IFFALSE 30542
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30530: LD_EXP 74
30534: PPUSH
30535: LD_STRING D10nB-Vse-1
30537: PPUSH
30538: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30542: LD_EXP 40
30546: PPUSH
30547: LD_STRING D10nB-JMM-2
30549: PPUSH
30550: CALL_OW 88
// if KappaStatus then
30554: LD_EXP 2
30558: IFFALSE 30572
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30560: LD_EXP 74
30564: PPUSH
30565: LD_STRING D10nB-Vse-5a
30567: PPUSH
30568: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30572: LD_EXP 2
30576: NOT
30577: PUSH
30578: LD_EXP 6
30582: PUSH
30583: LD_INT 0
30585: EQUAL
30586: AND
30587: IFFALSE 30715
// begin if JMMGirl = 1 then
30589: LD_EXP 7
30593: PUSH
30594: LD_INT 1
30596: EQUAL
30597: IFFALSE 30647
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30599: LD_EXP 74
30603: PPUSH
30604: LD_STRING D10nB-Vse-2
30606: PPUSH
30607: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30611: LD_EXP 40
30615: PPUSH
30616: LD_STRING D10nB-JMM-3
30618: PPUSH
30619: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30623: LD_EXP 74
30627: PPUSH
30628: LD_STRING D10nB-Vse-3
30630: PPUSH
30631: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30635: LD_EXP 40
30639: PPUSH
30640: LD_STRING D10nB-JMM-4
30642: PPUSH
30643: CALL_OW 88
// end ; if JMMGirl = 2 then
30647: LD_EXP 7
30651: PUSH
30652: LD_INT 2
30654: EQUAL
30655: IFFALSE 30681
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30657: LD_EXP 74
30661: PPUSH
30662: LD_STRING D10nB-Vse-4
30664: PPUSH
30665: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30669: LD_EXP 40
30673: PPUSH
30674: LD_STRING D10nB-JMM-5
30676: PPUSH
30677: CALL_OW 88
// end ; if JMMGirl = 3 then
30681: LD_EXP 7
30685: PUSH
30686: LD_INT 3
30688: EQUAL
30689: IFFALSE 30715
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30691: LD_EXP 74
30695: PPUSH
30696: LD_STRING D10nB-Vse-5
30698: PPUSH
30699: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30703: LD_EXP 40
30707: PPUSH
30708: LD_STRING D10nB-JMM-6
30710: PPUSH
30711: CALL_OW 88
// end ; end ; DialogueOff ;
30715: CALL_OW 7
// end ;
30719: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
30720: LD_EXP 14
30724: PUSH
30725: LD_INT 115500
30727: GREATEREQUAL
30728: PUSH
30729: LD_EXP 69
30733: PPUSH
30734: CALL_OW 302
30738: AND
30739: PUSH
30740: LD_INT 267
30742: PPUSH
30743: CALL_OW 302
30747: AND
30748: IFFALSE 31262
30750: GO 30752
30752: DISABLE
30753: LD_INT 0
30755: PPUSH
30756: PPUSH
30757: PPUSH
// begin missionStage := 10 ;
30758: LD_ADDR_EXP 15
30762: PUSH
30763: LD_INT 10
30765: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30766: LD_ADDR_VAR 0 3
30770: PUSH
30771: LD_INT 22
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 23
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 26
30793: PUSH
30794: LD_INT 1
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 3
30803: PUSH
30804: LD_INT 25
30806: PUSH
30807: LD_INT 12
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 25
30823: PUSH
30824: LD_INT 16
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: PPUSH
30842: CALL_OW 69
30846: PUSH
30847: LD_EXP 40
30851: PUSH
30852: LD_EXP 64
30856: PUSH
30857: LD_EXP 42
30861: PUSH
30862: LD_EXP 56
30866: PUSH
30867: LD_EXP 43
30871: PUSH
30872: LD_EXP 44
30876: PUSH
30877: LD_EXP 45
30881: PUSH
30882: LD_EXP 46
30886: PUSH
30887: LD_EXP 47
30891: PUSH
30892: LD_EXP 48
30896: PUSH
30897: LD_EXP 49
30901: PUSH
30902: LD_EXP 50
30906: PUSH
30907: LD_EXP 51
30911: PUSH
30912: LD_EXP 52
30916: PUSH
30917: LD_EXP 53
30921: PUSH
30922: LD_EXP 54
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: DIFF
30945: ST_TO_ADDR
// if not tmp and Brown then
30946: LD_VAR 0 3
30950: NOT
30951: PUSH
30952: LD_EXP 48
30956: AND
30957: IFFALSE 30972
// tmp := [ Brown ] ;
30959: LD_ADDR_VAR 0 3
30963: PUSH
30964: LD_EXP 48
30968: PUSH
30969: EMPTY
30970: LIST
30971: ST_TO_ADDR
// DialogueOn ;
30972: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30976: LD_VAR 0 3
30980: PUSH
30981: LD_INT 1
30983: ARRAY
30984: PPUSH
30985: LD_STRING D11-Sol1-1
30987: PPUSH
30988: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30992: LD_EXP 68
30996: PPUSH
30997: LD_STRING D11-Pla-1
30999: PPUSH
31000: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31004: LD_EXP 69
31008: PPUSH
31009: LD_STRING D11-Kov-1
31011: PPUSH
31012: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31016: LD_EXP 68
31020: PPUSH
31021: LD_STRING D11-Pla-2
31023: PPUSH
31024: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31028: LD_VAR 0 3
31032: PUSH
31033: LD_INT 1
31035: ARRAY
31036: PPUSH
31037: LD_STRING D11-Sol1-2
31039: PPUSH
31040: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31044: LD_EXP 40
31048: PPUSH
31049: LD_STRING D11-JMM-2
31051: PPUSH
31052: CALL_OW 88
// DialogueOff ;
31056: CALL_OW 7
// allowBehemothConstruct := true ;
31060: LD_ADDR_EXP 25
31064: PUSH
31065: LD_INT 1
31067: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31068: LD_STRING M4
31070: PPUSH
31071: CALL_OW 337
// j := 3 ;
31075: LD_ADDR_VAR 0 2
31079: PUSH
31080: LD_INT 3
31082: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31083: LD_ADDR_VAR 0 3
31087: PUSH
31088: LD_INT 22
31090: PUSH
31091: LD_INT 3
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 50
31100: PUSH
31101: EMPTY
31102: LIST
31103: PUSH
31104: LD_INT 3
31106: PUSH
31107: LD_INT 120
31109: PUSH
31110: LD_INT 105
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 25
31123: PUSH
31124: LD_INT 3
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: PPUSH
31137: CALL_OW 69
31141: PUSH
31142: LD_EXP 69
31146: DIFF
31147: ST_TO_ADDR
// for i in tmp do
31148: LD_ADDR_VAR 0 1
31152: PUSH
31153: LD_VAR 0 3
31157: PUSH
31158: FOR_IN
31159: IFFALSE 31209
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31161: LD_ADDR_EXP 77
31165: PUSH
31166: LD_EXP 77
31170: PPUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: CALL 107409 0 2
31180: ST_TO_ADDR
// j := j - 1 ;
31181: LD_ADDR_VAR 0 2
31185: PUSH
31186: LD_VAR 0 2
31190: PUSH
31191: LD_INT 1
31193: MINUS
31194: ST_TO_ADDR
// if j = 0 then
31195: LD_VAR 0 2
31199: PUSH
31200: LD_INT 0
31202: EQUAL
31203: IFFALSE 31207
// break ;
31205: GO 31209
// end ;
31207: GO 31158
31209: POP
31210: POP
// BuildBehemoths ;
31211: CALL 8301 0 0
// repeat wait ( 15 15$00 ) ;
31215: LD_INT 31500
31217: PPUSH
31218: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31222: LD_EXP 27
31226: IFFALSE 31230
// break ;
31228: GO 31262
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31230: LD_INT 267
31232: PPUSH
31233: CALL_OW 274
31237: PPUSH
31238: LD_INT 1
31240: PPUSH
31241: CALL_OW 275
31245: PUSH
31246: LD_INT 1000
31248: GREATEREQUAL
31249: IFFALSE 31255
// BuildBehemoths ;
31251: CALL 8301 0 0
// until not behemothBuilders ;
31255: LD_EXP 77
31259: NOT
31260: IFFALSE 31215
// end ;
31262: PPOPN 3
31264: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31265: LD_EXP 77
31269: NOT
31270: PUSH
31271: LD_EXP 28
31275: NOT
31276: AND
31277: PUSH
31278: LD_EXP 25
31282: AND
31283: IFFALSE 31303
31285: GO 31287
31287: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31288: LD_STRING M4a
31290: PPUSH
31291: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31295: LD_ADDR_EXP 27
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// end ;
31303: END
// every 0 0$1 trigger behemothDone do
31304: LD_EXP 28
31308: IFFALSE 31320
31310: GO 31312
31312: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31313: LD_STRING M4b
31315: PPUSH
31316: CALL_OW 337
31320: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31321: LD_EXP 29
31325: NOT
31326: IFFALSE 31522
31328: GO 31330
31330: DISABLE
31331: LD_INT 0
31333: PPUSH
31334: PPUSH
// begin enable ;
31335: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31336: LD_ADDR_VAR 0 1
31340: PUSH
31341: LD_INT 3
31343: PPUSH
31344: CALL 107470 0 1
31348: ST_TO_ADDR
// if not tmp and not behemothDone then
31349: LD_VAR 0 1
31353: NOT
31354: PUSH
31355: LD_EXP 28
31359: NOT
31360: AND
31361: IFFALSE 31397
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31363: LD_ADDR_VAR 0 1
31367: PUSH
31368: LD_INT 22
31370: PUSH
31371: LD_INT 3
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 30
31380: PUSH
31381: LD_INT 37
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PPUSH
31392: CALL_OW 69
31396: ST_TO_ADDR
// if not tmp then
31397: LD_VAR 0 1
31401: NOT
31402: IFFALSE 31406
// exit ;
31404: GO 31522
// for i in tmp do
31406: LD_ADDR_VAR 0 2
31410: PUSH
31411: LD_VAR 0 1
31415: PUSH
31416: FOR_IN
31417: IFFALSE 31520
// if See ( 1 , i ) then
31419: LD_INT 1
31421: PPUSH
31422: LD_VAR 0 2
31426: PPUSH
31427: CALL_OW 292
31431: IFFALSE 31518
// begin if GetType ( i ) = unit_building then
31433: LD_VAR 0 2
31437: PPUSH
31438: CALL_OW 247
31442: PUSH
31443: LD_INT 3
31445: EQUAL
31446: IFFALSE 31484
// begin disable ;
31448: DISABLE
// CenterNowOnUnits ( i ) ;
31449: LD_VAR 0 2
31453: PPUSH
31454: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31458: LD_EXP 40
31462: PPUSH
31463: LD_STRING D17a-JMM-1
31465: PPUSH
31466: CALL_OW 88
// seeBehemoth := true ;
31470: LD_ADDR_EXP 29
31474: PUSH
31475: LD_INT 1
31477: ST_TO_ADDR
// exit ;
31478: POP
31479: POP
31480: GO 31522
// end else
31482: GO 31518
// begin disable ;
31484: DISABLE
// CenterNowOnUnits ( i ) ;
31485: LD_VAR 0 2
31489: PPUSH
31490: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31494: LD_EXP 40
31498: PPUSH
31499: LD_STRING D17b-JMM-1
31501: PPUSH
31502: CALL_OW 88
// seeBehemoth := true ;
31506: LD_ADDR_EXP 29
31510: PUSH
31511: LD_INT 1
31513: ST_TO_ADDR
// exit ;
31514: POP
31515: POP
31516: GO 31522
// end ; end ;
31518: GO 31416
31520: POP
31521: POP
// end ;
31522: PPOPN 2
31524: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31525: LD_EXP 14
31529: PUSH
31530: LD_INT 123200
31532: GREATEREQUAL
31533: IFFALSE 32733
31535: GO 31537
31537: DISABLE
31538: LD_INT 0
31540: PPUSH
31541: PPUSH
31542: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31543: LD_INT 2
31545: PPUSH
31546: LD_INT 23
31548: PUSH
31549: LD_INT 3
31551: PUSH
31552: LD_INT 3
31554: PUSH
31555: LD_INT 48
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: PUSH
31564: EMPTY
31565: LIST
31566: PPUSH
31567: CALL 63292 0 2
// repeat wait ( 0 0$1 ) ;
31571: LD_INT 35
31573: PPUSH
31574: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31578: LD_INT 22
31580: PUSH
31581: LD_INT 3
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 34
31590: PUSH
31591: LD_INT 48
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PPUSH
31602: CALL_OW 69
31606: IFFALSE 31571
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31608: LD_ADDR_VAR 0 1
31612: PUSH
31613: LD_INT 22
31615: PUSH
31616: LD_INT 3
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 34
31625: PUSH
31626: LD_INT 48
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PPUSH
31637: CALL_OW 69
31641: PUSH
31642: LD_INT 1
31644: ARRAY
31645: ST_TO_ADDR
// missionStage := 12 ;
31646: LD_ADDR_EXP 15
31650: PUSH
31651: LD_INT 12
31653: ST_TO_ADDR
// platonovHasBomb := true ;
31654: LD_ADDR_EXP 30
31658: PUSH
31659: LD_INT 1
31661: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31662: LD_VAR 0 1
31666: PPUSH
31667: LD_INT 181
31669: PPUSH
31670: LD_INT 86
31672: PPUSH
31673: CALL_OW 171
// AddComHold ( bomb ) ;
31677: LD_VAR 0 1
31681: PPUSH
31682: CALL_OW 200
// wait ( 0 0$10 ) ;
31686: LD_INT 350
31688: PPUSH
31689: CALL_OW 67
// DialogueOn ;
31693: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31697: LD_EXP 68
31701: PPUSH
31702: LD_STRING D15-Pla-1
31704: PPUSH
31705: CALL_OW 94
// dec := Query ( Q15a ) ;
31709: LD_ADDR_VAR 0 2
31713: PUSH
31714: LD_STRING Q15a
31716: PPUSH
31717: CALL_OW 97
31721: ST_TO_ADDR
// if dec = 1 then
31722: LD_VAR 0 2
31726: PUSH
31727: LD_INT 1
31729: EQUAL
31730: IFFALSE 31753
// begin Say ( JMM , D15a-JMM-1 ) ;
31732: LD_EXP 40
31736: PPUSH
31737: LD_STRING D15a-JMM-1
31739: PPUSH
31740: CALL_OW 88
// YouLost ( Surrender ) ;
31744: LD_STRING Surrender
31746: PPUSH
31747: CALL_OW 104
// exit ;
31751: GO 32733
// end ; if dec = 2 then
31753: LD_VAR 0 2
31757: PUSH
31758: LD_INT 2
31760: EQUAL
31761: IFFALSE 31830
// begin Say ( JMM , D15b-JMM-1 ) ;
31763: LD_EXP 40
31767: PPUSH
31768: LD_STRING D15b-JMM-1
31770: PPUSH
31771: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31775: LD_EXP 68
31779: PPUSH
31780: LD_STRING D15b-Pla-1
31782: PPUSH
31783: CALL_OW 94
// DialogueOff ;
31787: CALL_OW 7
// wait ( 3 3$00 ) ;
31791: LD_INT 6300
31793: PPUSH
31794: CALL_OW 67
// DialogueOn ;
31798: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31802: LD_EXP 40
31806: PPUSH
31807: LD_STRING D15d-JMM-1a
31809: PPUSH
31810: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31814: LD_EXP 68
31818: PPUSH
31819: LD_STRING D15d-Pla-1
31821: PPUSH
31822: CALL_OW 94
// DialogueOff ;
31826: CALL_OW 7
// end ; if dec = 3 then
31830: LD_VAR 0 2
31834: PUSH
31835: LD_INT 3
31837: EQUAL
31838: IFFALSE 31892
// begin Say ( JMM , D15c-JMM-1 ) ;
31840: LD_EXP 40
31844: PPUSH
31845: LD_STRING D15c-JMM-1
31847: PPUSH
31848: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31852: LD_EXP 68
31856: PPUSH
31857: LD_STRING D15c-Pla-1
31859: PPUSH
31860: CALL_OW 94
// DialogueOff ;
31864: CALL_OW 7
// wait ( 0 0$15 ) ;
31868: LD_INT 525
31870: PPUSH
31871: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31875: LD_VAR 0 1
31879: PPUSH
31880: LD_INT 60
31882: PPUSH
31883: LD_INT 95
31885: PPUSH
31886: CALL_OW 116
// exit ;
31890: GO 32733
// end ; if dec = 4 then
31892: LD_VAR 0 2
31896: PUSH
31897: LD_INT 4
31899: EQUAL
31900: IFFALSE 31930
// begin Say ( JMM , D15d-JMM-1 ) ;
31902: LD_EXP 40
31906: PPUSH
31907: LD_STRING D15d-JMM-1
31909: PPUSH
31910: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31914: LD_EXP 68
31918: PPUSH
31919: LD_STRING D15d-Pla-1
31921: PPUSH
31922: CALL_OW 94
// DialogueOff ;
31926: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31930: LD_EXP 66
31934: PPUSH
31935: CALL_OW 302
31939: PUSH
31940: LD_EXP 66
31944: PPUSH
31945: CALL_OW 255
31949: PUSH
31950: LD_INT 1
31952: EQUAL
31953: AND
31954: PUSH
31955: LD_INT 22
31957: PUSH
31958: LD_INT 1
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 34
31967: PUSH
31968: LD_INT 8
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PPUSH
31979: CALL_OW 69
31983: NOT
31984: AND
31985: IFFALSE 32634
// begin SetSide ( Friend , 8 ) ;
31987: LD_EXP 66
31991: PPUSH
31992: LD_INT 8
31994: PPUSH
31995: CALL_OW 235
// if IsInUnit ( Friend ) then
31999: LD_EXP 66
32003: PPUSH
32004: CALL_OW 310
32008: IFFALSE 32019
// ComExitBuilding ( Friend ) ;
32010: LD_EXP 66
32014: PPUSH
32015: CALL_OW 122
// if IsDriver ( Friend ) then
32019: LD_EXP 66
32023: PPUSH
32024: CALL 105013 0 1
32028: IFFALSE 32039
// ComExitVehicle ( Friend ) ;
32030: LD_EXP 66
32034: PPUSH
32035: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32039: LD_EXP 66
32043: PPUSH
32044: LD_INT 9
32046: PPUSH
32047: LD_INT 2
32049: PPUSH
32050: CALL_OW 171
// wait ( 0 0$05 ) ;
32054: LD_INT 175
32056: PPUSH
32057: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32061: LD_EXP 66
32065: PPUSH
32066: CALL_OW 87
// DialogueOn ;
32070: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32074: LD_EXP 40
32078: PPUSH
32079: LD_STRING D16-JMM-1
32081: PPUSH
32082: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32086: LD_EXP 66
32090: PPUSH
32091: LD_STRING D16-Friend-1
32093: PPUSH
32094: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32098: LD_EXP 40
32102: PPUSH
32103: LD_STRING D16-JMM-2
32105: PPUSH
32106: CALL_OW 88
// DialogueOff ;
32110: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32114: LD_EXP 66
32118: PPUSH
32119: LD_INT 1
32121: PPUSH
32122: CALL_OW 235
// ComHold ( Friend ) ;
32126: LD_EXP 66
32130: PPUSH
32131: CALL_OW 140
// wait ( 0 0$20 ) ;
32135: LD_INT 700
32137: PPUSH
32138: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32142: LD_EXP 66
32146: PPUSH
32147: LD_INT 9
32149: PPUSH
32150: LD_INT 2
32152: PPUSH
32153: CALL_OW 297
32157: PUSH
32158: LD_INT 30
32160: LESS
32161: IFFALSE 32230
// begin SetSide ( Friend , 8 ) ;
32163: LD_EXP 66
32167: PPUSH
32168: LD_INT 8
32170: PPUSH
32171: CALL_OW 235
// if IsInUnit ( Friend ) then
32175: LD_EXP 66
32179: PPUSH
32180: CALL_OW 310
32184: IFFALSE 32195
// ComExitBuilding ( Friend ) ;
32186: LD_EXP 66
32190: PPUSH
32191: CALL_OW 122
// if IsDriver ( Friend ) then
32195: LD_EXP 66
32199: PPUSH
32200: CALL 105013 0 1
32204: IFFALSE 32215
// ComExitVehicle ( Friend ) ;
32206: LD_EXP 66
32210: PPUSH
32211: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32215: LD_EXP 66
32219: PPUSH
32220: LD_INT 9
32222: PPUSH
32223: LD_INT 2
32225: PPUSH
32226: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32230: LD_INT 1050
32232: PPUSH
32233: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32237: LD_INT 22
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 34
32249: PUSH
32250: LD_INT 8
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PPUSH
32261: CALL_OW 69
32265: NOT
32266: IFFALSE 32612
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32268: LD_ADDR_VAR 0 3
32272: PUSH
32273: LD_INT 22
32275: PUSH
32276: LD_INT 1
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 26
32285: PUSH
32286: LD_INT 1
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 3
32295: PUSH
32296: LD_INT 25
32298: PUSH
32299: LD_INT 12
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 25
32308: PUSH
32309: LD_INT 16
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: LIST
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: LIST
32325: PPUSH
32326: CALL_OW 69
32330: PUSH
32331: LD_EXP 40
32335: PUSH
32336: LD_EXP 42
32340: PUSH
32341: LD_EXP 56
32345: PUSH
32346: LD_EXP 43
32350: PUSH
32351: LD_EXP 44
32355: PUSH
32356: LD_EXP 45
32360: PUSH
32361: LD_EXP 46
32365: PUSH
32366: LD_EXP 47
32370: PUSH
32371: LD_EXP 48
32375: PUSH
32376: LD_EXP 49
32380: PUSH
32381: LD_EXP 50
32385: PUSH
32386: LD_EXP 51
32390: PUSH
32391: LD_EXP 52
32395: PUSH
32396: LD_EXP 53
32400: PUSH
32401: LD_EXP 54
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: DIFF
32423: ST_TO_ADDR
// DialogueOn ;
32424: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32428: LD_EXP 68
32432: PPUSH
32433: LD_STRING D16a-Pla-1
32435: PPUSH
32436: CALL_OW 94
// if Stevens then
32440: LD_EXP 42
32444: IFFALSE 32460
// Say ( Stevens , D16a-Huck-1 ) else
32446: LD_EXP 42
32450: PPUSH
32451: LD_STRING D16a-Huck-1
32453: PPUSH
32454: CALL_OW 88
32458: GO 32502
// if Baker then
32460: LD_EXP 56
32464: IFFALSE 32480
// Say ( Baker , D16a-Huck-1 ) else
32466: LD_EXP 56
32470: PPUSH
32471: LD_STRING D16a-Huck-1
32473: PPUSH
32474: CALL_OW 88
32478: GO 32502
// if tmp then
32480: LD_VAR 0 3
32484: IFFALSE 32502
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32486: LD_VAR 0 3
32490: PUSH
32491: LD_INT 1
32493: ARRAY
32494: PPUSH
32495: LD_STRING D16a-Sol1-1
32497: PPUSH
32498: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32502: LD_EXP 66
32506: PPUSH
32507: CALL_OW 255
32511: PUSH
32512: LD_INT 8
32514: EQUAL
32515: IFFALSE 32531
// Say ( JMM , D16a-JMM-1 ) else
32517: LD_EXP 40
32521: PPUSH
32522: LD_STRING D16a-JMM-1
32524: PPUSH
32525: CALL_OW 88
32529: GO 32591
// begin Say ( JMM , D16a-JMM-1a ) ;
32531: LD_EXP 40
32535: PPUSH
32536: LD_STRING D16a-JMM-1a
32538: PPUSH
32539: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32543: LD_EXP 66
32547: PPUSH
32548: LD_STRING D16a-Friend-1
32550: PPUSH
32551: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32555: LD_EXP 66
32559: PPUSH
32560: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32564: LD_EXP 66
32568: PPUSH
32569: LD_INT 191
32571: PPUSH
32572: LD_INT 103
32574: PPUSH
32575: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32579: LD_EXP 66
32583: PPUSH
32584: LD_INT 3
32586: PPUSH
32587: CALL_OW 235
// end ; DialogueOff ;
32591: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32595: LD_VAR 0 1
32599: PPUSH
32600: LD_INT 60
32602: PPUSH
32603: LD_INT 95
32605: PPUSH
32606: CALL_OW 116
// end else
32610: GO 32632
// begin DialogueOn ;
32612: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32616: LD_EXP 68
32620: PPUSH
32621: LD_STRING D16c-Pla-1
32623: PPUSH
32624: CALL_OW 94
// DialogueOff ;
32628: CALL_OW 7
// end ; end else
32632: GO 32733
// begin wait ( 3 3$00 ) ;
32634: LD_INT 6300
32636: PPUSH
32637: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32641: LD_INT 22
32643: PUSH
32644: LD_INT 1
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: LD_INT 34
32653: PUSH
32654: LD_INT 8
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PPUSH
32665: CALL_OW 69
32669: NOT
32670: IFFALSE 32713
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32672: LD_EXP 68
32676: PPUSH
32677: LD_STRING D16b-Pla-1
32679: PPUSH
32680: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32684: LD_EXP 40
32688: PPUSH
32689: LD_STRING D16b-JMM-1
32691: PPUSH
32692: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32696: LD_VAR 0 1
32700: PPUSH
32701: LD_INT 60
32703: PPUSH
32704: LD_INT 95
32706: PPUSH
32707: CALL_OW 116
// end else
32711: GO 32733
// begin DialogueOn ;
32713: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32717: LD_EXP 68
32721: PPUSH
32722: LD_STRING D16c-Pla-1
32724: PPUSH
32725: CALL_OW 94
// DialogueOff ;
32729: CALL_OW 7
// end ; end ; end ;
32733: PPOPN 3
32735: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32736: LD_INT 25
32738: PPUSH
32739: LD_INT 1
32741: PPUSH
32742: CALL_OW 321
32746: PUSH
32747: LD_INT 2
32749: EQUAL
32750: PUSH
32751: LD_EXP 14
32755: PUSH
32756: LD_INT 126000
32758: GREATEREQUAL
32759: OR
32760: PUSH
32761: LD_EXP 23
32765: NOT
32766: AND
32767: PUSH
32768: LD_EXP 79
32772: PPUSH
32773: CALL_OW 302
32777: AND
32778: IFFALSE 33136
32780: GO 32782
32782: DISABLE
32783: LD_INT 0
32785: PPUSH
// begin missionStage := 11 ;
32786: LD_ADDR_EXP 15
32790: PUSH
32791: LD_INT 11
32793: ST_TO_ADDR
// DialogueOn ;
32794: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32798: LD_EXP 79
32802: PPUSH
32803: LD_STRING D9-Roth-1
32805: PPUSH
32806: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32810: LD_EXP 40
32814: PPUSH
32815: LD_STRING D9-JMM-1
32817: PPUSH
32818: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32822: LD_EXP 79
32826: PPUSH
32827: LD_STRING D9-Roth-2
32829: PPUSH
32830: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32834: LD_EXP 79
32838: PPUSH
32839: LD_STRING D9-Roth-2a
32841: PPUSH
32842: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32846: LD_EXP 68
32850: PPUSH
32851: LD_STRING D9-Pla-2
32853: PPUSH
32854: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32858: LD_EXP 79
32862: PPUSH
32863: LD_STRING D9-Roth-3
32865: PPUSH
32866: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32870: LD_EXP 68
32874: PPUSH
32875: LD_STRING D9-Pla-3
32877: PPUSH
32878: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32882: LD_EXP 79
32886: PPUSH
32887: LD_STRING D9-Roth-4
32889: PPUSH
32890: CALL_OW 94
// dec := Query ( Q9 ) ;
32894: LD_ADDR_VAR 0 1
32898: PUSH
32899: LD_STRING Q9
32901: PPUSH
32902: CALL_OW 97
32906: ST_TO_ADDR
// if dec = 1 then
32907: LD_VAR 0 1
32911: PUSH
32912: LD_INT 1
32914: EQUAL
32915: IFFALSE 32929
// SayRadio ( Roth , D9a-Roth-1 ) ;
32917: LD_EXP 79
32921: PPUSH
32922: LD_STRING D9a-Roth-1
32924: PPUSH
32925: CALL_OW 94
// if dec = 2 then
32929: LD_VAR 0 1
32933: PUSH
32934: LD_INT 2
32936: EQUAL
32937: IFFALSE 32963
// begin Say ( JMM , D9b-JMM-1 ) ;
32939: LD_EXP 40
32943: PPUSH
32944: LD_STRING D9b-JMM-1
32946: PPUSH
32947: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32951: LD_EXP 79
32955: PPUSH
32956: LD_STRING D9b-Roth-1
32958: PPUSH
32959: CALL_OW 94
// end ; if dec = 3 then
32963: LD_VAR 0 1
32967: PUSH
32968: LD_INT 3
32970: EQUAL
32971: IFFALSE 33033
// begin Say ( JMM , D9c-JMM-1 ) ;
32973: LD_EXP 40
32977: PPUSH
32978: LD_STRING D9c-JMM-1
32980: PPUSH
32981: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32985: LD_EXP 79
32989: PPUSH
32990: LD_STRING D9c-Roth-1
32992: PPUSH
32993: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32997: LD_EXP 40
33001: PPUSH
33002: LD_STRING D9c-JMM-2
33004: PPUSH
33005: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33009: LD_EXP 79
33013: PPUSH
33014: LD_STRING D9c-Roth-2
33016: PPUSH
33017: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33021: LD_EXP 40
33025: PPUSH
33026: LD_STRING D9c-JMM-3
33028: PPUSH
33029: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33033: LD_EXP 79
33037: PPUSH
33038: LD_STRING D9c-Roth-3
33040: PPUSH
33041: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33045: LD_EXP 79
33049: PPUSH
33050: LD_STRING D9cont-Roth-1
33052: PPUSH
33053: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33057: LD_EXP 40
33061: PPUSH
33062: LD_STRING D9cont-JMM-1
33064: PPUSH
33065: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33069: LD_EXP 79
33073: PPUSH
33074: LD_STRING D9cont-Roth-2
33076: PPUSH
33077: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33081: LD_EXP 40
33085: PPUSH
33086: LD_STRING D9cont-JMM-2
33088: PPUSH
33089: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33093: LD_EXP 79
33097: PPUSH
33098: LD_STRING D9cont-Roth-3
33100: PPUSH
33101: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33105: LD_EXP 40
33109: PPUSH
33110: LD_STRING D9cont-JMM-3
33112: PPUSH
33113: CALL_OW 88
// DialogueOff ;
33117: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33121: LD_STRING M3
33123: PPUSH
33124: CALL_OW 337
// allianceActive := true ;
33128: LD_ADDR_EXP 31
33132: PUSH
33133: LD_INT 1
33135: ST_TO_ADDR
// end ;
33136: PPOPN 1
33138: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33139: LD_INT 1
33141: PPUSH
33142: LD_INT 126
33144: PPUSH
33145: CALL_OW 292
33149: PUSH
33150: LD_EXP 68
33154: PPUSH
33155: CALL_OW 310
33159: AND
33160: IFFALSE 33313
33162: GO 33164
33164: DISABLE
33165: LD_INT 0
33167: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33168: LD_EXP 68
33172: PPUSH
33173: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33177: LD_ADDR_VAR 0 1
33181: PUSH
33182: LD_INT 4
33184: PPUSH
33185: LD_INT 22
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PPUSH
33195: CALL_OW 70
33199: PPUSH
33200: LD_EXP 68
33204: PPUSH
33205: CALL_OW 74
33209: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33210: LD_EXP 68
33214: PPUSH
33215: LD_VAR 0 1
33219: PUSH
33220: LD_INT 1
33222: ARRAY
33223: PPUSH
33224: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33228: LD_EXP 68
33232: PPUSH
33233: LD_STRING D18-Pla-1
33235: PPUSH
33236: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33240: LD_INT 22
33242: PUSH
33243: LD_INT 3
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 34
33252: PUSH
33253: LD_INT 48
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PPUSH
33264: CALL_OW 69
33268: IFFALSE 33313
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33270: LD_INT 22
33272: PUSH
33273: LD_INT 3
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 34
33282: PUSH
33283: LD_INT 48
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PPUSH
33294: CALL_OW 69
33298: PUSH
33299: LD_INT 1
33301: ARRAY
33302: PPUSH
33303: LD_INT 111
33305: PPUSH
33306: LD_INT 97
33308: PPUSH
33309: CALL_OW 116
// end ;
33313: PPOPN 1
33315: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33316: LD_EXP 68
33320: PPUSH
33321: CALL_OW 301
33325: PUSH
33326: LD_EXP 71
33330: PPUSH
33331: CALL_OW 301
33335: AND
33336: PUSH
33337: LD_INT 22
33339: PUSH
33340: LD_INT 3
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 21
33349: PUSH
33350: LD_INT 1
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 50
33359: PUSH
33360: EMPTY
33361: LIST
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: LIST
33367: PPUSH
33368: CALL_OW 69
33372: PUSH
33373: LD_INT 7
33375: PUSH
33376: LD_INT 8
33378: PUSH
33379: LD_INT 9
33381: PUSH
33382: LD_INT 10
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: PUSH
33391: LD_OWVAR 67
33395: ARRAY
33396: LESS
33397: AND
33398: IFFALSE 34197
33400: GO 33402
33402: DISABLE
33403: LD_INT 0
33405: PPUSH
33406: PPUSH
33407: PPUSH
33408: PPUSH
// begin MC_Kill ( 2 ) ;
33409: LD_INT 2
33411: PPUSH
33412: CALL 39267 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33416: LD_INT 1
33418: PPUSH
33419: LD_INT 3
33421: PPUSH
33422: LD_INT 1
33424: PPUSH
33425: LD_INT 1
33427: PPUSH
33428: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33432: LD_ADDR_VAR 0 2
33436: PUSH
33437: LD_INT 22
33439: PUSH
33440: LD_INT 3
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 21
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 50
33459: PUSH
33460: EMPTY
33461: LIST
33462: PUSH
33463: LD_INT 26
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: PPUSH
33479: CALL_OW 69
33483: ST_TO_ADDR
// if not tmp then
33484: LD_VAR 0 2
33488: NOT
33489: IFFALSE 33545
// begin uc_side = 3 ;
33491: LD_ADDR_OWVAR 20
33495: PUSH
33496: LD_INT 3
33498: ST_TO_ADDR
// uc_nation = 3 ;
33499: LD_ADDR_OWVAR 21
33503: PUSH
33504: LD_INT 3
33506: ST_TO_ADDR
// hc_name =  ;
33507: LD_ADDR_OWVAR 26
33511: PUSH
33512: LD_STRING 
33514: ST_TO_ADDR
// hc_gallery =  ;
33515: LD_ADDR_OWVAR 33
33519: PUSH
33520: LD_STRING 
33522: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33523: LD_INT 1
33525: PPUSH
33526: LD_INT 10
33528: PPUSH
33529: CALL_OW 381
// tmp = CreateHuman ;
33533: LD_ADDR_VAR 0 2
33537: PUSH
33538: CALL_OW 44
33542: ST_TO_ADDR
// end else
33543: GO 33559
// tmp := tmp [ 1 ] ;
33545: LD_ADDR_VAR 0 2
33549: PUSH
33550: LD_VAR 0 2
33554: PUSH
33555: LD_INT 1
33557: ARRAY
33558: ST_TO_ADDR
// DialogueOn ;
33559: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33563: LD_VAR 0 2
33567: PPUSH
33568: LD_STRING DSurrenderRussians-RSol1-1a
33570: PPUSH
33571: CALL_OW 94
// DialogueOff ;
33575: CALL_OW 7
// russianDestroyed := true ;
33579: LD_ADDR_EXP 21
33583: PUSH
33584: LD_INT 1
33586: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33587: LD_ADDR_VAR 0 1
33591: PUSH
33592: LD_INT 22
33594: PUSH
33595: LD_INT 6
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PPUSH
33602: CALL_OW 69
33606: PUSH
33607: FOR_IN
33608: IFFALSE 33621
// KillUnit ( i ) ;
33610: LD_VAR 0 1
33614: PPUSH
33615: CALL_OW 66
33619: GO 33607
33621: POP
33622: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33623: LD_INT 22
33625: PUSH
33626: LD_INT 3
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 21
33635: PUSH
33636: LD_INT 1
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PPUSH
33647: CALL_OW 69
33651: PPUSH
33652: CALL_OW 122
// wait ( 0 0$1 ) ;
33656: LD_INT 35
33658: PPUSH
33659: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33663: LD_INT 22
33665: PUSH
33666: LD_INT 3
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 21
33675: PUSH
33676: LD_INT 1
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PPUSH
33687: CALL_OW 69
33691: PPUSH
33692: LD_INT 25
33694: PPUSH
33695: CALL_OW 173
// wait ( 0 0$35 ) ;
33699: LD_INT 1225
33701: PPUSH
33702: CALL_OW 67
// PrepareOmarInvasion ;
33706: CALL 16285 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33710: LD_ADDR_VAR 0 2
33714: PUSH
33715: LD_EXP 97
33719: PPUSH
33720: CALL_OW 250
33724: PUSH
33725: LD_EXP 97
33729: PPUSH
33730: CALL_OW 251
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33739: LD_VAR 0 2
33743: PUSH
33744: LD_INT 1
33746: ARRAY
33747: PPUSH
33748: LD_VAR 0 2
33752: PUSH
33753: LD_INT 2
33755: ARRAY
33756: PPUSH
33757: LD_INT 1
33759: PPUSH
33760: LD_INT 8
33762: NEG
33763: PPUSH
33764: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33768: LD_EXP 97
33772: PPUSH
33773: CALL_OW 87
// DialogueOn ;
33777: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33781: LD_EXP 40
33785: PPUSH
33786: LD_STRING D19-JMM-1
33788: PPUSH
33789: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33793: LD_ADDR_VAR 0 3
33797: PUSH
33798: LD_INT 22
33800: PUSH
33801: LD_INT 1
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 26
33810: PUSH
33811: LD_INT 1
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: LD_INT 25
33823: PUSH
33824: LD_INT 1
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 25
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 25
33843: PUSH
33844: LD_INT 3
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 25
33853: PUSH
33854: LD_INT 4
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 25
33863: PUSH
33864: LD_INT 5
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 25
33873: PUSH
33874: LD_INT 8
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: LIST
33894: PPUSH
33895: CALL_OW 69
33899: PUSH
33900: LD_EXP 40
33904: PUSH
33905: LD_EXP 41
33909: PUSH
33910: LD_EXP 64
33914: PUSH
33915: LD_EXP 42
33919: PUSH
33920: LD_EXP 43
33924: PUSH
33925: LD_EXP 44
33929: PUSH
33930: LD_EXP 45
33934: PUSH
33935: LD_EXP 46
33939: PUSH
33940: LD_EXP 47
33944: PUSH
33945: LD_EXP 48
33949: PUSH
33950: LD_EXP 49
33954: PUSH
33955: LD_EXP 50
33959: PUSH
33960: LD_EXP 51
33964: PUSH
33965: LD_EXP 52
33969: PUSH
33970: LD_EXP 53
33974: PUSH
33975: LD_EXP 54
33979: PUSH
33980: LD_EXP 55
33984: PUSH
33985: LD_EXP 56
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: DIFF
34010: ST_TO_ADDR
// if tmp2 then
34011: LD_VAR 0 3
34015: IFFALSE 34033
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34017: LD_VAR 0 3
34021: PUSH
34022: LD_INT 1
34024: ARRAY
34025: PPUSH
34026: LD_STRING D19-Sol1-1
34028: PPUSH
34029: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34033: LD_EXP 40
34037: PPUSH
34038: LD_STRING D19-JMM-2
34040: PPUSH
34041: CALL_OW 88
// DialogueOff ;
34045: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34049: LD_VAR 0 2
34053: PUSH
34054: LD_INT 1
34056: ARRAY
34057: PPUSH
34058: LD_VAR 0 2
34062: PUSH
34063: LD_INT 2
34065: ARRAY
34066: PPUSH
34067: LD_INT 1
34069: PPUSH
34070: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34074: LD_STRING M5
34076: PPUSH
34077: CALL_OW 337
// omarOnMotherLode := false ;
34081: LD_ADDR_VAR 0 4
34085: PUSH
34086: LD_INT 0
34088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34089: LD_INT 35
34091: PPUSH
34092: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34096: LD_EXP 97
34100: PPUSH
34101: LD_INT 215
34103: PPUSH
34104: LD_INT 100
34106: PPUSH
34107: CALL_OW 297
34111: PUSH
34112: LD_INT 10
34114: LESS
34115: PUSH
34116: LD_VAR 0 4
34120: NOT
34121: AND
34122: IFFALSE 34156
// begin omarOnMotherLode := true ;
34124: LD_ADDR_VAR 0 4
34128: PUSH
34129: LD_INT 1
34131: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34132: LD_EXP 40
34136: PPUSH
34137: LD_STRING D19b-JMM-1
34139: PPUSH
34140: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34144: LD_EXP 97
34148: PPUSH
34149: LD_STRING DOmarContam-Omar-1
34151: PPUSH
34152: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34156: LD_EXP 97
34160: PPUSH
34161: CALL_OW 301
34165: IFFALSE 34089
// Say ( JMM , D19a-JMM-1 ) ;
34167: LD_EXP 40
34171: PPUSH
34172: LD_STRING D19a-JMM-1
34174: PPUSH
34175: CALL_OW 88
// if Heike then
34179: LD_EXP 98
34183: IFFALSE 34197
// Say ( Heike , D19a-Hke-1 ) ;
34185: LD_EXP 98
34189: PPUSH
34190: LD_STRING D19a-Hke-1
34192: PPUSH
34193: CALL_OW 88
// end ;
34197: PPOPN 4
34199: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34200: LD_INT 22
34202: PUSH
34203: LD_INT 3
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 21
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PPUSH
34224: CALL_OW 69
34228: PUSH
34229: LD_EXP 21
34233: AND
34234: IFFALSE 34302
34236: GO 34238
34238: DISABLE
34239: LD_INT 0
34241: PPUSH
34242: PPUSH
// begin enable ;
34243: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34244: LD_ADDR_VAR 0 2
34248: PUSH
34249: LD_INT 25
34251: PPUSH
34252: LD_INT 22
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PPUSH
34262: CALL_OW 70
34266: ST_TO_ADDR
// if not tmp then
34267: LD_VAR 0 2
34271: NOT
34272: IFFALSE 34276
// exit ;
34274: GO 34302
// for i in tmp do
34276: LD_ADDR_VAR 0 1
34280: PUSH
34281: LD_VAR 0 2
34285: PUSH
34286: FOR_IN
34287: IFFALSE 34300
// RemoveUnit ( i ) ;
34289: LD_VAR 0 1
34293: PPUSH
34294: CALL_OW 64
34298: GO 34286
34300: POP
34301: POP
// end ;
34302: PPOPN 2
34304: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34305: LD_INT 22
34307: PUSH
34308: LD_INT 7
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 21
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PPUSH
34329: CALL_OW 69
34333: PUSH
34334: LD_INT 6
34336: LESS
34337: IFFALSE 34805
34339: GO 34341
34341: DISABLE
34342: LD_INT 0
34344: PPUSH
34345: PPUSH
// begin MC_Kill ( 1 ) ;
34346: LD_INT 1
34348: PPUSH
34349: CALL 39267 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34353: LD_INT 7
34355: PPUSH
34356: LD_INT 1
34358: PPUSH
34359: LD_INT 1
34361: PPUSH
34362: LD_INT 1
34364: PPUSH
34365: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34369: LD_ADDR_VAR 0 1
34373: PUSH
34374: LD_INT 22
34376: PUSH
34377: LD_INT 7
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 26
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PPUSH
34398: CALL_OW 69
34402: PUSH
34403: LD_EXP 79
34407: DIFF
34408: ST_TO_ADDR
// if tmp then
34409: LD_VAR 0 1
34413: IFFALSE 34431
// tmp := tmp [ 1 ] else
34415: LD_ADDR_VAR 0 1
34419: PUSH
34420: LD_VAR 0 1
34424: PUSH
34425: LD_INT 1
34427: ARRAY
34428: ST_TO_ADDR
34429: GO 34467
// begin uc_side := 7 ;
34431: LD_ADDR_OWVAR 20
34435: PUSH
34436: LD_INT 7
34438: ST_TO_ADDR
// uc_nation := 1 ;
34439: LD_ADDR_OWVAR 21
34443: PUSH
34444: LD_INT 1
34446: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34447: LD_INT 1
34449: PPUSH
34450: LD_INT 8
34452: PPUSH
34453: CALL_OW 384
// tmp := CreateHuman ;
34457: LD_ADDR_VAR 0 1
34461: PUSH
34462: CALL_OW 44
34466: ST_TO_ADDR
// end ; DialogueOn ;
34467: CALL_OW 6
// if IsOK ( Roth ) then
34471: LD_EXP 79
34475: PPUSH
34476: CALL_OW 302
34480: IFFALSE 34494
// Say ( JMM , DAb-JMM-1 ) ;
34482: LD_EXP 40
34486: PPUSH
34487: LD_STRING DAb-JMM-1
34489: PPUSH
34490: CALL_OW 88
// if IsOK ( Roth ) then
34494: LD_EXP 79
34498: PPUSH
34499: CALL_OW 302
34503: IFFALSE 34527
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34505: LD_EXP 79
34509: PPUSH
34510: LD_STRING DSurrenderAlliance-Roth-1
34512: PPUSH
34513: CALL_OW 88
// RothCaptured := true ;
34517: LD_ADDR_EXP 33
34521: PUSH
34522: LD_INT 1
34524: ST_TO_ADDR
// end else
34525: GO 34539
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34527: LD_VAR 0 1
34531: PPUSH
34532: LD_STRING DSurrenderAlliance-Sci1-1
34534: PPUSH
34535: CALL_OW 88
// DialogueOff ;
34539: CALL_OW 7
// allianceDestroyed := true ;
34543: LD_ADDR_EXP 23
34547: PUSH
34548: LD_INT 1
34550: ST_TO_ADDR
// if capturedUnit = 0 then
34551: LD_EXP 34
34555: PUSH
34556: LD_INT 0
34558: EQUAL
34559: IFFALSE 34568
// SetAchievement ( ACH_ALLIANCE ) ;
34561: LD_STRING ACH_ALLIANCE
34563: PPUSH
34564: CALL_OW 543
// if trueAmericans then
34568: LD_EXP 35
34572: IFFALSE 34648
// begin if trueAmericans = 1 then
34574: LD_EXP 35
34578: PUSH
34579: LD_INT 1
34581: EQUAL
34582: IFFALSE 34598
// Say ( JMM , DAb-JMM-1a ) else
34584: LD_EXP 40
34588: PPUSH
34589: LD_STRING DAb-JMM-1a
34591: PPUSH
34592: CALL_OW 88
34596: GO 34610
// Say ( JMM , DAb-JMM-1b ) ;
34598: LD_EXP 40
34602: PPUSH
34603: LD_STRING DAb-JMM-1b
34605: PPUSH
34606: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34610: LD_EXP 35
34614: PPUSH
34615: CALL_OW 87
// for i in trueAmericans do
34619: LD_ADDR_VAR 0 2
34623: PUSH
34624: LD_EXP 35
34628: PUSH
34629: FOR_IN
34630: IFFALSE 34646
// SetSide ( i , 1 ) ;
34632: LD_VAR 0 2
34636: PPUSH
34637: LD_INT 1
34639: PPUSH
34640: CALL_OW 235
34644: GO 34629
34646: POP
34647: POP
// end ; repeat wait ( 0 0$1 ) ;
34648: LD_INT 35
34650: PPUSH
34651: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34655: LD_ADDR_VAR 0 2
34659: PUSH
34660: LD_INT 22
34662: PUSH
34663: LD_INT 7
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 21
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PPUSH
34684: CALL_OW 69
34688: PUSH
34689: FOR_IN
34690: IFFALSE 34772
// begin if IsInUnit ( i ) then
34692: LD_VAR 0 2
34696: PPUSH
34697: CALL_OW 310
34701: IFFALSE 34712
// ComExitBuilding ( i ) ;
34703: LD_VAR 0 2
34707: PPUSH
34708: CALL_OW 122
// if IsDriver ( i ) then
34712: LD_VAR 0 2
34716: PPUSH
34717: CALL 105013 0 1
34721: IFFALSE 34732
// ComExitVehicle ( i ) ;
34723: LD_VAR 0 2
34727: PPUSH
34728: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34732: LD_VAR 0 2
34736: PPUSH
34737: LD_INT 26
34739: PPUSH
34740: CALL_OW 308
34744: NOT
34745: IFFALSE 34761
// AddComMoveToArea ( i , allianceEscapeArea ) else
34747: LD_VAR 0 2
34751: PPUSH
34752: LD_INT 26
34754: PPUSH
34755: CALL_OW 173
34759: GO 34770
// RemoveUnit ( i ) ;
34761: LD_VAR 0 2
34765: PPUSH
34766: CALL_OW 64
// end ;
34770: GO 34689
34772: POP
34773: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34774: LD_INT 22
34776: PUSH
34777: LD_INT 7
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 21
34786: PUSH
34787: LD_INT 1
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PPUSH
34798: CALL_OW 69
34802: NOT
34803: IFFALSE 34648
// end ;
34805: PPOPN 2
34807: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34808: LD_INT 0
34810: PPUSH
34811: PPUSH
// if not unit then
34812: LD_VAR 0 1
34816: NOT
34817: IFFALSE 34821
// exit ;
34819: GO 36335
// DoNotAttack ( 7 , unit ) ;
34821: LD_INT 7
34823: PPUSH
34824: LD_VAR 0 1
34828: PPUSH
34829: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34833: LD_VAR 0 1
34837: PPUSH
34838: LD_INT 260
34840: PPUSH
34841: LD_INT 235
34843: PPUSH
34844: LD_INT 3
34846: PPUSH
34847: LD_INT 1
34849: PPUSH
34850: CALL_OW 483
// SetSide ( unit , 4 ) ;
34854: LD_VAR 0 1
34858: PPUSH
34859: LD_INT 4
34861: PPUSH
34862: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34866: LD_ADDR_EXP 34
34870: PUSH
34871: LD_EXP 34
34875: PUSH
34876: LD_INT 1
34878: PLUS
34879: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34880: LD_INT 70
34882: PPUSH
34883: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34887: LD_INT 260
34889: PPUSH
34890: LD_INT 235
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 8
34898: NEG
34899: PPUSH
34900: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34904: LD_VAR 0 1
34908: PPUSH
34909: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34913: LD_VAR 0 1
34917: PPUSH
34918: LD_EXP 79
34922: PPUSH
34923: CALL_OW 119
// DialogueOn ;
34927: CALL_OW 6
// case unit of JMM :
34931: LD_VAR 0 1
34935: PUSH
34936: LD_EXP 40
34940: DOUBLE
34941: EQUAL
34942: IFTRUE 34946
34944: GO 34961
34946: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34947: LD_EXP 40
34951: PPUSH
34952: LD_STRING DA1-JMM-1
34954: PPUSH
34955: CALL_OW 91
34959: GO 35403
34961: LD_EXP 41
34965: DOUBLE
34966: EQUAL
34967: IFTRUE 34971
34969: GO 34986
34971: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34972: LD_EXP 41
34976: PPUSH
34977: LD_STRING DA1-Joan-1
34979: PPUSH
34980: CALL_OW 91
34984: GO 35403
34986: LD_EXP 43
34990: DOUBLE
34991: EQUAL
34992: IFTRUE 34996
34994: GO 35011
34996: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34997: LD_EXP 43
35001: PPUSH
35002: LD_STRING DA1-Lisa-1
35004: PPUSH
35005: CALL_OW 91
35009: GO 35403
35011: LD_EXP 44
35015: DOUBLE
35016: EQUAL
35017: IFTRUE 35021
35019: GO 35036
35021: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35022: LD_EXP 44
35026: PPUSH
35027: LD_STRING DA1-Don-1
35029: PPUSH
35030: CALL_OW 91
35034: GO 35403
35036: LD_EXP 51
35040: DOUBLE
35041: EQUAL
35042: IFTRUE 35046
35044: GO 35061
35046: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35047: LD_EXP 51
35051: PPUSH
35052: LD_STRING DA1-Corn-1
35054: PPUSH
35055: CALL_OW 91
35059: GO 35403
35061: LD_EXP 47
35065: DOUBLE
35066: EQUAL
35067: IFTRUE 35071
35069: GO 35086
35071: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35072: LD_EXP 47
35076: PPUSH
35077: LD_STRING DA1-Den-1
35079: PPUSH
35080: CALL_OW 91
35084: GO 35403
35086: LD_EXP 45
35090: DOUBLE
35091: EQUAL
35092: IFTRUE 35096
35094: GO 35111
35096: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35097: LD_EXP 45
35101: PPUSH
35102: LD_STRING DA1-Bobby-1
35104: PPUSH
35105: CALL_OW 91
35109: GO 35403
35111: LD_EXP 49
35115: DOUBLE
35116: EQUAL
35117: IFTRUE 35121
35119: GO 35136
35121: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35122: LD_EXP 49
35126: PPUSH
35127: LD_STRING DA1-Glad-1
35129: PPUSH
35130: CALL_OW 91
35134: GO 35403
35136: LD_EXP 46
35140: DOUBLE
35141: EQUAL
35142: IFTRUE 35146
35144: GO 35161
35146: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35147: LD_EXP 46
35151: PPUSH
35152: LD_STRING DA1-Cyrus-1
35154: PPUSH
35155: CALL_OW 91
35159: GO 35403
35161: LD_EXP 42
35165: DOUBLE
35166: EQUAL
35167: IFTRUE 35171
35169: GO 35186
35171: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35172: LD_EXP 42
35176: PPUSH
35177: LD_STRING DA1-Huck-1
35179: PPUSH
35180: CALL_OW 91
35184: GO 35403
35186: LD_EXP 56
35190: DOUBLE
35191: EQUAL
35192: IFTRUE 35196
35194: GO 35211
35196: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35197: LD_EXP 56
35201: PPUSH
35202: LD_STRING DA1-Huck-1
35204: PPUSH
35205: CALL_OW 91
35209: GO 35403
35211: LD_EXP 48
35215: DOUBLE
35216: EQUAL
35217: IFTRUE 35221
35219: GO 35236
35221: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35222: LD_EXP 48
35226: PPUSH
35227: LD_STRING DA1-Brown-1
35229: PPUSH
35230: CALL_OW 91
35234: GO 35403
35236: LD_EXP 52
35240: DOUBLE
35241: EQUAL
35242: IFTRUE 35246
35244: GO 35261
35246: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35247: LD_EXP 52
35251: PPUSH
35252: LD_STRING DA1-Gary-1
35254: PPUSH
35255: CALL_OW 91
35259: GO 35403
35261: LD_EXP 55
35265: DOUBLE
35266: EQUAL
35267: IFTRUE 35271
35269: GO 35286
35271: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35272: LD_EXP 55
35276: PPUSH
35277: LD_STRING DA1-Con-1
35279: PPUSH
35280: CALL_OW 91
35284: GO 35403
35286: LD_EXP 64
35290: DOUBLE
35291: EQUAL
35292: IFTRUE 35296
35294: GO 35311
35296: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35297: LD_EXP 64
35301: PPUSH
35302: LD_STRING DA1-Kurt-1
35304: PPUSH
35305: CALL_OW 91
35309: GO 35403
35311: LD_EXP 54
35315: DOUBLE
35316: EQUAL
35317: IFTRUE 35321
35319: GO 35336
35321: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35322: LD_EXP 54
35326: PPUSH
35327: LD_STRING DA1-Yam-1
35329: PPUSH
35330: CALL_OW 91
35334: GO 35403
35336: LD_EXP 53
35340: DOUBLE
35341: EQUAL
35342: IFTRUE 35346
35344: GO 35361
35346: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35347: LD_EXP 53
35351: PPUSH
35352: LD_STRING DA1-Frank-1
35354: PPUSH
35355: CALL_OW 91
35359: GO 35403
35361: POP
// begin if GetSex ( unit ) = sex_male then
35362: LD_VAR 0 1
35366: PPUSH
35367: CALL_OW 258
35371: PUSH
35372: LD_INT 1
35374: EQUAL
35375: IFFALSE 35391
// ForceSay ( unit , DA1-Sol1-1 ) else
35377: LD_VAR 0 1
35381: PPUSH
35382: LD_STRING DA1-Sol1-1
35384: PPUSH
35385: CALL_OW 91
35389: GO 35403
// ForceSay ( unit , DA1-FSol1-1 ) ;
35391: LD_VAR 0 1
35395: PPUSH
35396: LD_STRING DA1-FSol1-1
35398: PPUSH
35399: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35403: LD_EXP 79
35407: PPUSH
35408: LD_STRING DA-Roth-1
35410: PPUSH
35411: CALL_OW 88
// if capturedUnit = 1 then
35415: LD_EXP 34
35419: PUSH
35420: LD_INT 1
35422: EQUAL
35423: IFFALSE 35451
// begin Say ( Simms , DA-Sim-1 ) ;
35425: LD_EXP 80
35429: PPUSH
35430: LD_STRING DA-Sim-1
35432: PPUSH
35433: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35437: LD_EXP 79
35441: PPUSH
35442: LD_STRING DA-Roth-2
35444: PPUSH
35445: CALL_OW 88
// end else
35449: GO 35463
// Say ( Simms , DA-Sim-2 ) ;
35451: LD_EXP 80
35455: PPUSH
35456: LD_STRING DA-Sim-2
35458: PPUSH
35459: CALL_OW 88
// case unit of JMM :
35463: LD_VAR 0 1
35467: PUSH
35468: LD_EXP 40
35472: DOUBLE
35473: EQUAL
35474: IFTRUE 35478
35476: GO 35493
35478: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35479: LD_EXP 40
35483: PPUSH
35484: LD_STRING DA1-JMM-1a
35486: PPUSH
35487: CALL_OW 91
35491: GO 36010
35493: LD_EXP 41
35497: DOUBLE
35498: EQUAL
35499: IFTRUE 35503
35501: GO 35518
35503: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35504: LD_EXP 41
35508: PPUSH
35509: LD_STRING DA1-Joan-1a
35511: PPUSH
35512: CALL_OW 91
35516: GO 36010
35518: LD_EXP 43
35522: DOUBLE
35523: EQUAL
35524: IFTRUE 35528
35526: GO 35543
35528: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35529: LD_EXP 43
35533: PPUSH
35534: LD_STRING DA1-Lisa-1a
35536: PPUSH
35537: CALL_OW 91
35541: GO 36010
35543: LD_EXP 44
35547: DOUBLE
35548: EQUAL
35549: IFTRUE 35553
35551: GO 35568
35553: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35554: LD_EXP 44
35558: PPUSH
35559: LD_STRING DA1-Don-1a
35561: PPUSH
35562: CALL_OW 91
35566: GO 36010
35568: LD_EXP 51
35572: DOUBLE
35573: EQUAL
35574: IFTRUE 35578
35576: GO 35593
35578: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35579: LD_EXP 51
35583: PPUSH
35584: LD_STRING DA1-Corn-1a
35586: PPUSH
35587: CALL_OW 91
35591: GO 36010
35593: LD_EXP 47
35597: DOUBLE
35598: EQUAL
35599: IFTRUE 35603
35601: GO 35618
35603: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35604: LD_EXP 47
35608: PPUSH
35609: LD_STRING DA1-Den-1a
35611: PPUSH
35612: CALL_OW 91
35616: GO 36010
35618: LD_EXP 45
35622: DOUBLE
35623: EQUAL
35624: IFTRUE 35628
35626: GO 35643
35628: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35629: LD_EXP 45
35633: PPUSH
35634: LD_STRING DA1-Bobby-1a
35636: PPUSH
35637: CALL_OW 91
35641: GO 36010
35643: LD_EXP 49
35647: DOUBLE
35648: EQUAL
35649: IFTRUE 35653
35651: GO 35668
35653: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35654: LD_EXP 49
35658: PPUSH
35659: LD_STRING DA1-Glad-1a
35661: PPUSH
35662: CALL_OW 91
35666: GO 36010
35668: LD_EXP 46
35672: DOUBLE
35673: EQUAL
35674: IFTRUE 35678
35676: GO 35693
35678: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35679: LD_EXP 46
35683: PPUSH
35684: LD_STRING DA1-Cyrus-1a
35686: PPUSH
35687: CALL_OW 91
35691: GO 36010
35693: LD_EXP 42
35697: DOUBLE
35698: EQUAL
35699: IFTRUE 35703
35701: GO 35718
35703: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35704: LD_EXP 42
35708: PPUSH
35709: LD_STRING DA1-Huck-1a
35711: PPUSH
35712: CALL_OW 91
35716: GO 36010
35718: LD_EXP 56
35722: DOUBLE
35723: EQUAL
35724: IFTRUE 35728
35726: GO 35743
35728: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35729: LD_EXP 56
35733: PPUSH
35734: LD_STRING DA1-Huck-1a
35736: PPUSH
35737: CALL_OW 91
35741: GO 36010
35743: LD_EXP 48
35747: DOUBLE
35748: EQUAL
35749: IFTRUE 35753
35751: GO 35768
35753: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35754: LD_EXP 48
35758: PPUSH
35759: LD_STRING DA1-Brown-1a
35761: PPUSH
35762: CALL_OW 91
35766: GO 36010
35768: LD_EXP 52
35772: DOUBLE
35773: EQUAL
35774: IFTRUE 35778
35776: GO 35793
35778: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35779: LD_EXP 52
35783: PPUSH
35784: LD_STRING DA1-Gary-1a
35786: PPUSH
35787: CALL_OW 91
35791: GO 36010
35793: LD_EXP 55
35797: DOUBLE
35798: EQUAL
35799: IFTRUE 35803
35801: GO 35828
35803: POP
// if JMMGirl = 3 then
35804: LD_EXP 7
35808: PUSH
35809: LD_INT 3
35811: EQUAL
35812: IFFALSE 35826
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35814: LD_EXP 55
35818: PPUSH
35819: LD_STRING DA1-Con-1a
35821: PPUSH
35822: CALL_OW 91
35826: GO 36010
35828: LD_EXP 64
35832: DOUBLE
35833: EQUAL
35834: IFTRUE 35838
35836: GO 35853
35838: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35839: LD_EXP 64
35843: PPUSH
35844: LD_STRING DA1-Kurt-1a
35846: PPUSH
35847: CALL_OW 91
35851: GO 36010
35853: LD_EXP 54
35857: DOUBLE
35858: EQUAL
35859: IFTRUE 35863
35861: GO 35878
35863: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35864: LD_EXP 54
35868: PPUSH
35869: LD_STRING DA1-Yam-1a
35871: PPUSH
35872: CALL_OW 91
35876: GO 36010
35878: LD_EXP 53
35882: DOUBLE
35883: EQUAL
35884: IFTRUE 35888
35886: GO 35903
35888: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35889: LD_EXP 53
35893: PPUSH
35894: LD_STRING DA1-Frank-1a
35896: PPUSH
35897: CALL_OW 91
35901: GO 36010
35903: POP
// begin join := rand ( 0 , 1 ) ;
35904: LD_ADDR_VAR 0 3
35908: PUSH
35909: LD_INT 0
35911: PPUSH
35912: LD_INT 1
35914: PPUSH
35915: CALL_OW 12
35919: ST_TO_ADDR
// if join then
35920: LD_VAR 0 3
35924: IFFALSE 35969
// begin if GetSex ( unit ) = sex_male then
35926: LD_VAR 0 1
35930: PPUSH
35931: CALL_OW 258
35935: PUSH
35936: LD_INT 1
35938: EQUAL
35939: IFFALSE 35955
// ForceSay ( unit , DA1-Sol1-1b ) else
35941: LD_VAR 0 1
35945: PPUSH
35946: LD_STRING DA1-Sol1-1b
35948: PPUSH
35949: CALL_OW 91
35953: GO 35967
// ForceSay ( unit , DA1-FSol1-1b ) ;
35955: LD_VAR 0 1
35959: PPUSH
35960: LD_STRING DA1-FSol1-1b
35962: PPUSH
35963: CALL_OW 91
// end else
35967: GO 36010
// begin if GetSex ( unit ) = sex_male then
35969: LD_VAR 0 1
35973: PPUSH
35974: CALL_OW 258
35978: PUSH
35979: LD_INT 1
35981: EQUAL
35982: IFFALSE 35998
// ForceSay ( unit , DA1-Sol1-1a ) else
35984: LD_VAR 0 1
35988: PPUSH
35989: LD_STRING DA1-Sol1-1a
35991: PPUSH
35992: CALL_OW 91
35996: GO 36010
// ForceSay ( unit , DA1-FSol1-1a ) ;
35998: LD_VAR 0 1
36002: PPUSH
36003: LD_STRING DA1-FSol1-1a
36005: PPUSH
36006: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36010: LD_VAR 0 1
36014: PUSH
36015: LD_EXP 40
36019: EQUAL
36020: IFFALSE 36031
// begin YouLost ( JMMCaptured ) ;
36022: LD_STRING JMMCaptured
36024: PPUSH
36025: CALL_OW 104
// exit ;
36029: GO 36335
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36031: LD_VAR 0 1
36035: PUSH
36036: LD_EXP 44
36040: PUSH
36041: LD_EXP 47
36045: PUSH
36046: LD_EXP 45
36050: PUSH
36051: LD_EXP 42
36055: PUSH
36056: LD_EXP 56
36060: PUSH
36061: LD_EXP 48
36065: PUSH
36066: LD_EXP 54
36070: PUSH
36071: LD_EXP 58
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: IN
36086: PUSH
36087: LD_VAR 0 3
36091: OR
36092: IFFALSE 36191
// begin Say ( Roth , DA-Roth-3 ) ;
36094: LD_EXP 79
36098: PPUSH
36099: LD_STRING DA-Roth-3
36101: PPUSH
36102: CALL_OW 88
// SetSide ( unit , 7 ) ;
36106: LD_VAR 0 1
36110: PPUSH
36111: LD_INT 7
36113: PPUSH
36114: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36118: LD_ADDR_EXP 102
36122: PUSH
36123: LD_EXP 102
36127: PPUSH
36128: LD_INT 1
36130: PPUSH
36131: LD_EXP 102
36135: PUSH
36136: LD_INT 1
36138: ARRAY
36139: PUSH
36140: LD_VAR 0 1
36144: ADD
36145: PPUSH
36146: CALL_OW 1
36150: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36151: LD_INT 260
36153: PPUSH
36154: LD_INT 235
36156: PPUSH
36157: LD_INT 1
36159: PPUSH
36160: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36164: LD_VAR 0 1
36168: PPUSH
36169: LD_INT 1000
36171: PPUSH
36172: CALL_OW 234
// DialogueOff ;
36176: CALL_OW 7
// ComFree ( unit ) ;
36180: LD_VAR 0 1
36184: PPUSH
36185: CALL_OW 139
// end else
36189: GO 36272
// begin Say ( Roth , DA-Roth-3a ) ;
36191: LD_EXP 79
36195: PPUSH
36196: LD_STRING DA-Roth-3a
36198: PPUSH
36199: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36203: LD_ADDR_EXP 35
36207: PUSH
36208: LD_EXP 35
36212: PUSH
36213: LD_VAR 0 1
36217: ADD
36218: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36219: LD_INT 260
36221: PPUSH
36222: LD_INT 235
36224: PPUSH
36225: LD_INT 1
36227: PPUSH
36228: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36232: LD_VAR 0 1
36236: PPUSH
36237: LD_INT 1000
36239: PPUSH
36240: CALL_OW 234
// DialogueOff ;
36244: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36248: LD_VAR 0 1
36252: PPUSH
36253: LD_INT 272
36255: PPUSH
36256: LD_INT 254
36258: PPUSH
36259: CALL_OW 111
// AddComHold ( unit ) ;
36263: LD_VAR 0 1
36267: PPUSH
36268: CALL_OW 200
// end ; if capturedUnit = 1 then
36272: LD_EXP 34
36276: PUSH
36277: LD_INT 1
36279: EQUAL
36280: IFFALSE 36335
// begin DialogueOn ;
36282: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36286: LD_EXP 40
36290: PPUSH
36291: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36295: LD_EXP 40
36299: PPUSH
36300: LD_STRING DAa-JMM-1
36302: PPUSH
36303: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36307: LD_EXP 40
36311: PPUSH
36312: LD_STRING DAa-JMM-1a
36314: PPUSH
36315: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36319: LD_EXP 40
36323: PPUSH
36324: LD_STRING DAa-JMM-1b
36326: PPUSH
36327: CALL_OW 88
// DialogueOff ;
36331: CALL_OW 7
// end ; end ;
36335: LD_VAR 0 2
36339: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36340: LD_EXP 15
36344: PUSH
36345: LD_INT 13
36347: GREATEREQUAL
36348: PUSH
36349: LD_INT 22
36351: PUSH
36352: LD_INT 2
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 21
36361: PUSH
36362: LD_INT 1
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PPUSH
36373: CALL_OW 69
36377: PUSH
36378: LD_INT 0
36380: EQUAL
36381: AND
36382: PUSH
36383: LD_INT 22
36385: PUSH
36386: LD_INT 2
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 33
36395: PUSH
36396: LD_INT 5
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 21
36405: PUSH
36406: LD_INT 2
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 50
36415: PUSH
36416: EMPTY
36417: LIST
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: LIST
36423: LIST
36424: PPUSH
36425: CALL_OW 69
36429: PUSH
36430: LD_INT 0
36432: EQUAL
36433: AND
36434: PUSH
36435: LD_EXP 21
36439: AND
36440: PUSH
36441: LD_EXP 22
36445: AND
36446: PUSH
36447: LD_EXP 23
36451: AND
36452: IFFALSE 37221
36454: GO 36456
36456: DISABLE
36457: LD_INT 0
36459: PPUSH
36460: PPUSH
36461: PPUSH
// begin wait ( 0 0$05 ) ;
36462: LD_INT 175
36464: PPUSH
36465: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
36469: LD_INT 22
36471: PUSH
36472: LD_INT 1
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 21
36481: PUSH
36482: LD_INT 1
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 23
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 50
36501: PUSH
36502: EMPTY
36503: LIST
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: PPUSH
36511: CALL_OW 69
36515: PPUSH
36516: CALL 71820 0 1
36520: PUSH
36521: LD_INT 2
36523: LESS
36524: IFFALSE 36535
// begin YouLost ( LostVictory ) ;
36526: LD_STRING LostVictory
36528: PPUSH
36529: CALL_OW 104
// exit ;
36533: GO 37221
// end ; m1 := false ;
36535: LD_ADDR_VAR 0 1
36539: PUSH
36540: LD_INT 0
36542: ST_TO_ADDR
// m2 := false ;
36543: LD_ADDR_VAR 0 2
36547: PUSH
36548: LD_INT 0
36550: ST_TO_ADDR
// m3 := false ;
36551: LD_ADDR_VAR 0 3
36555: PUSH
36556: LD_INT 0
36558: ST_TO_ADDR
// if not bombExploded then
36559: LD_EXP 37
36563: NOT
36564: IFFALSE 36573
// SetAchievement ( ACH_SIBROCKET ) ;
36566: LD_STRING ACH_SIBROCKET
36568: PPUSH
36569: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36573: LD_EXP 66
36577: PPUSH
36578: CALL_OW 255
36582: PUSH
36583: LD_INT 1
36585: EQUAL
36586: PUSH
36587: LD_EXP 66
36591: PPUSH
36592: CALL_OW 302
36596: AND
36597: IFFALSE 36613
// begin wait ( 3 ) ;
36599: LD_INT 3
36601: PPUSH
36602: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36606: LD_STRING ACH_OPO
36608: PPUSH
36609: CALL_OW 543
// end ; if tick <= 120 120$00 then
36613: LD_OWVAR 1
36617: PUSH
36618: LD_INT 252000
36620: LESSEQUAL
36621: IFFALSE 36637
// begin wait ( 3 ) ;
36623: LD_INT 3
36625: PPUSH
36626: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36630: LD_STRING ACH_ASPEED_15
36632: PPUSH
36633: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36637: LD_EXP 40
36641: PPUSH
36642: CALL_OW 87
// music_class := 5 ;
36646: LD_ADDR_OWVAR 72
36650: PUSH
36651: LD_INT 5
36653: ST_TO_ADDR
// music_nat := 5 ;
36654: LD_ADDR_OWVAR 71
36658: PUSH
36659: LD_INT 5
36661: ST_TO_ADDR
// DialogueOn ;
36662: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36666: LD_EXP 40
36670: PPUSH
36671: LD_STRING D20-JMM-1
36673: PPUSH
36674: CALL_OW 88
// if IsOK ( Joan ) then
36678: LD_EXP 41
36682: PPUSH
36683: CALL_OW 302
36687: IFFALSE 36701
// Say ( Joan , D20-Joan-1 ) ;
36689: LD_EXP 41
36693: PPUSH
36694: LD_STRING D20-Joan-1
36696: PPUSH
36697: CALL_OW 88
// if IsOk ( Lisa ) then
36701: LD_EXP 43
36705: PPUSH
36706: CALL_OW 302
36710: IFFALSE 36724
// Say ( Lisa , D20-Lisa-1 ) ;
36712: LD_EXP 43
36716: PPUSH
36717: LD_STRING D20-Lisa-1
36719: PPUSH
36720: CALL_OW 88
// if IsOk ( Donaldson ) then
36724: LD_EXP 44
36728: PPUSH
36729: CALL_OW 302
36733: IFFALSE 36747
// Say ( Donaldson , D20-Don-1 ) ;
36735: LD_EXP 44
36739: PPUSH
36740: LD_STRING D20-Don-1
36742: PPUSH
36743: CALL_OW 88
// if IsOK ( Cornel ) then
36747: LD_EXP 51
36751: PPUSH
36752: CALL_OW 302
36756: IFFALSE 36770
// Say ( Cornel , D20-Corn-1 ) ;
36758: LD_EXP 51
36762: PPUSH
36763: LD_STRING D20-Corn-1
36765: PPUSH
36766: CALL_OW 88
// if IsOk ( Denis ) then
36770: LD_EXP 47
36774: PPUSH
36775: CALL_OW 302
36779: IFFALSE 36793
// Say ( Denis , D20-Den-1 ) ;
36781: LD_EXP 47
36785: PPUSH
36786: LD_STRING D20-Den-1
36788: PPUSH
36789: CALL_OW 88
// if IsOk ( Bobby ) then
36793: LD_EXP 45
36797: PPUSH
36798: CALL_OW 302
36802: IFFALSE 36816
// Say ( Bobby , D20-Bobby-1 ) ;
36804: LD_EXP 45
36808: PPUSH
36809: LD_STRING D20-Bobby-1
36811: PPUSH
36812: CALL_OW 88
// if IsOk ( Gladstone ) then
36816: LD_EXP 49
36820: PPUSH
36821: CALL_OW 302
36825: IFFALSE 36839
// Say ( Gladstone , D20-Glad-1 ) ;
36827: LD_EXP 49
36831: PPUSH
36832: LD_STRING D20-Glad-1
36834: PPUSH
36835: CALL_OW 88
// if IsOk ( Cyrus ) then
36839: LD_EXP 46
36843: PPUSH
36844: CALL_OW 302
36848: IFFALSE 36862
// Say ( Cyrus , D20-Cyrus-1 ) ;
36850: LD_EXP 46
36854: PPUSH
36855: LD_STRING D20-Cyrus-1
36857: PPUSH
36858: CALL_OW 88
// if IsOk ( Stevens ) then
36862: LD_EXP 42
36866: PPUSH
36867: CALL_OW 302
36871: IFFALSE 36885
// Say ( Stevens , D20-Huck-1 ) ;
36873: LD_EXP 42
36877: PPUSH
36878: LD_STRING D20-Huck-1
36880: PPUSH
36881: CALL_OW 88
// if IsOk ( Brown ) then
36885: LD_EXP 48
36889: PPUSH
36890: CALL_OW 302
36894: IFFALSE 36908
// Say ( Brown , D20-Brown-1 ) ;
36896: LD_EXP 48
36900: PPUSH
36901: LD_STRING D20-Brown-1
36903: PPUSH
36904: CALL_OW 88
// if IsOk ( Gary ) then
36908: LD_EXP 52
36912: PPUSH
36913: CALL_OW 302
36917: IFFALSE 36931
// Say ( Gary , D20-Gary-1 ) ;
36919: LD_EXP 52
36923: PPUSH
36924: LD_STRING D20-Gary-1
36926: PPUSH
36927: CALL_OW 88
// if IsOk ( Connie ) then
36931: LD_EXP 55
36935: PPUSH
36936: CALL_OW 302
36940: IFFALSE 36954
// Say ( Connie , D20-Con-1 ) ;
36942: LD_EXP 55
36946: PPUSH
36947: LD_STRING D20-Con-1
36949: PPUSH
36950: CALL_OW 88
// if IsOk ( Kurt ) then
36954: LD_EXP 64
36958: PPUSH
36959: CALL_OW 302
36963: IFFALSE 36977
// Say ( Kurt , D20-Kurt-1 ) ;
36965: LD_EXP 64
36969: PPUSH
36970: LD_STRING D20-Kurt-1
36972: PPUSH
36973: CALL_OW 88
// if IsOk ( Kikuchi ) then
36977: LD_EXP 54
36981: PPUSH
36982: CALL_OW 302
36986: IFFALSE 37000
// Say ( Kikuchi , D20-Yam-1 ) ;
36988: LD_EXP 54
36992: PPUSH
36993: LD_STRING D20-Yam-1
36995: PPUSH
36996: CALL_OW 88
// if IsOk ( Frank ) then
37000: LD_EXP 53
37004: PPUSH
37005: CALL_OW 302
37009: IFFALSE 37023
// Say ( Frank , D20-Frank-1 ) ;
37011: LD_EXP 53
37015: PPUSH
37016: LD_STRING D20-Frank-1
37018: PPUSH
37019: CALL_OW 88
// DialogueOff ;
37023: CALL_OW 7
// if RothCaptured then
37027: LD_EXP 33
37031: IFFALSE 37053
// begin m1 := true ;
37033: LD_ADDR_VAR 0 1
37037: PUSH
37038: LD_INT 1
37040: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37041: LD_STRING Roth
37043: PPUSH
37044: LD_INT 1
37046: PPUSH
37047: CALL_OW 101
// end else
37051: GO 37064
// AddMedal ( Roth , - 1 ) ;
37053: LD_STRING Roth
37055: PPUSH
37056: LD_INT 1
37058: NEG
37059: PPUSH
37060: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37064: LD_EXP 25
37068: NOT
37069: PUSH
37070: LD_EXP 27
37074: OR
37075: PUSH
37076: LD_EXP 28
37080: NOT
37081: OR
37082: IFFALSE 37104
// begin m2 := true ;
37084: LD_ADDR_VAR 0 2
37088: PUSH
37089: LD_INT 1
37091: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37092: LD_STRING Project
37094: PPUSH
37095: LD_INT 1
37097: PPUSH
37098: CALL_OW 101
// end else
37102: GO 37115
// AddMedal ( Project , - 1 ) ;
37104: LD_STRING Project
37106: PPUSH
37107: LD_INT 1
37109: NEG
37110: PPUSH
37111: CALL_OW 101
// if lostCounter = 0 then
37115: LD_EXP 32
37119: PUSH
37120: LD_INT 0
37122: EQUAL
37123: IFFALSE 37145
// begin m3 := true ;
37125: LD_ADDR_VAR 0 3
37129: PUSH
37130: LD_INT 1
37132: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37133: LD_STRING NoLosses
37135: PPUSH
37136: LD_INT 1
37138: PPUSH
37139: CALL_OW 101
// end else
37143: GO 37156
// AddMedal ( NoLosses , - 1 ) ;
37145: LD_STRING NoLosses
37147: PPUSH
37148: LD_INT 1
37150: NEG
37151: PPUSH
37152: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37156: LD_VAR 0 1
37160: PUSH
37161: LD_VAR 0 2
37165: AND
37166: PUSH
37167: LD_VAR 0 3
37171: AND
37172: PUSH
37173: LD_OWVAR 67
37177: PUSH
37178: LD_INT 3
37180: GREATEREQUAL
37181: AND
37182: IFFALSE 37194
// SetAchievementEX ( ACH_AMER , 15 ) ;
37184: LD_STRING ACH_AMER
37186: PPUSH
37187: LD_INT 15
37189: PPUSH
37190: CALL_OW 564
// GiveMedals ( MAIN ) ;
37194: LD_STRING MAIN
37196: PPUSH
37197: CALL_OW 102
// music_class := 4 ;
37201: LD_ADDR_OWVAR 72
37205: PUSH
37206: LD_INT 4
37208: ST_TO_ADDR
// music_nat := 1 ;
37209: LD_ADDR_OWVAR 71
37213: PUSH
37214: LD_INT 1
37216: ST_TO_ADDR
// YouWin ;
37217: CALL_OW 103
// end ; end_of_file
37221: PPOPN 3
37223: END
// export function CustomEvent ( event ) ; begin
37224: LD_INT 0
37226: PPUSH
// end ;
37227: LD_VAR 0 2
37231: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37232: LD_VAR 0 1
37236: PUSH
37237: LD_INT 1
37239: EQUAL
37240: PUSH
37241: LD_VAR 0 2
37245: PUSH
37246: LD_INT 4
37248: EQUAL
37249: AND
37250: PUSH
37251: LD_EXP 61
37255: PPUSH
37256: CALL_OW 300
37260: AND
37261: IFFALSE 37277
// begin wait ( 0 0$2 ) ;
37263: LD_INT 70
37265: PPUSH
37266: CALL_OW 67
// YouLost ( Dismissed ) ;
37270: LD_STRING Dismissed
37272: PPUSH
37273: CALL_OW 104
// end ; end ;
37277: PPOPN 2
37279: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37280: LD_VAR 0 2
37284: PPUSH
37285: LD_VAR 0 3
37289: PPUSH
37290: LD_INT 18
37292: PPUSH
37293: CALL_OW 309
37297: IFFALSE 37306
// YouLost ( Motherlode3 ) ;
37299: LD_STRING Motherlode3
37301: PPUSH
37302: CALL_OW 104
// end ;
37306: PPOPN 3
37308: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37309: LD_EXP 27
37313: NOT
37314: IFFALSE 37324
// behemothDone := true ;
37316: LD_ADDR_EXP 28
37320: PUSH
37321: LD_INT 1
37323: ST_TO_ADDR
// end ;
37324: PPOPN 1
37326: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37327: LD_VAR 0 1
37331: PPUSH
37332: CALL_OW 255
37336: PUSH
37337: LD_INT 1
37339: EQUAL
37340: IFFALSE 37350
// bombExploded := true ;
37342: LD_ADDR_EXP 37
37346: PUSH
37347: LD_INT 1
37349: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37350: LD_VAR 0 1
37354: PPUSH
37355: CALL_OW 255
37359: PUSH
37360: LD_INT 3
37362: EQUAL
37363: IFFALSE 37393
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37365: LD_INT 2
37367: PPUSH
37368: LD_INT 23
37370: PUSH
37371: LD_INT 3
37373: PUSH
37374: LD_INT 3
37376: PUSH
37377: LD_INT 48
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: PUSH
37386: EMPTY
37387: LIST
37388: PPUSH
37389: CALL 63292 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37393: LD_VAR 0 1
37397: PPUSH
37398: CALL_OW 255
37402: PUSH
37403: LD_INT 1
37405: EQUAL
37406: PUSH
37407: LD_EXP 66
37411: PPUSH
37412: CALL_OW 255
37416: PUSH
37417: LD_INT 1
37419: EQUAL
37420: AND
37421: PUSH
37422: LD_EXP 66
37426: PPUSH
37427: CALL_OW 302
37431: AND
37432: PUSH
37433: LD_EXP 30
37437: AND
37438: PUSH
37439: LD_INT 22
37441: PUSH
37442: LD_INT 3
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 34
37451: PUSH
37452: LD_INT 48
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PPUSH
37463: CALL_OW 69
37467: AND
37468: PUSH
37469: LD_INT 22
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 34
37481: PUSH
37482: LD_INT 8
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PPUSH
37493: CALL_OW 69
37497: NOT
37498: AND
37499: IFFALSE 37551
// begin wait ( 0 0$5 ) ;
37501: LD_INT 175
37503: PPUSH
37504: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37508: LD_INT 22
37510: PUSH
37511: LD_INT 3
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 34
37520: PUSH
37521: LD_INT 48
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PPUSH
37532: CALL_OW 69
37536: PUSH
37537: LD_INT 1
37539: ARRAY
37540: PPUSH
37541: LD_INT 60
37543: PPUSH
37544: LD_INT 95
37546: PPUSH
37547: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37551: LD_VAR 0 2
37555: PPUSH
37556: LD_VAR 0 3
37560: PPUSH
37561: LD_INT 18
37563: PPUSH
37564: CALL_OW 309
37568: PUSH
37569: LD_VAR 0 2
37573: PPUSH
37574: LD_VAR 0 3
37578: PPUSH
37579: LD_INT 18
37581: PPUSH
37582: CALL 111218 0 3
37586: OR
37587: IFFALSE 37634
// begin if GetSide ( unit ) = 1 then
37589: LD_VAR 0 1
37593: PPUSH
37594: CALL_OW 255
37598: PUSH
37599: LD_INT 1
37601: EQUAL
37602: IFFALSE 37620
// begin wait ( 0 0$6 ) ;
37604: LD_INT 210
37606: PPUSH
37607: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37611: LD_STRING Motherlode2
37613: PPUSH
37614: CALL_OW 104
// end else
37618: GO 37634
// begin wait ( 0 0$6 ) ;
37620: LD_INT 210
37622: PPUSH
37623: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37627: LD_STRING Motherlode1
37629: PPUSH
37630: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37634: LD_VAR 0 1
37638: PPUSH
37639: CALL_OW 255
37643: PUSH
37644: LD_INT 3
37646: EQUAL
37647: IFFALSE 37668
// begin wait ( 0 0$5 ) ;
37649: LD_INT 175
37651: PPUSH
37652: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37656: LD_EXP 68
37660: PPUSH
37661: LD_STRING D18-Pla-1
37663: PPUSH
37664: CALL_OW 94
// end ; end ;
37668: PPOPN 3
37670: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37671: LD_VAR 0 1
37675: PPUSH
37676: CALL 128308 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37680: LD_VAR 0 1
37684: PUSH
37685: LD_INT 22
37687: PUSH
37688: LD_INT 1
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 21
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 23
37707: PUSH
37708: LD_INT 1
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: LIST
37719: PPUSH
37720: CALL_OW 69
37724: IN
37725: IFFALSE 37741
// lostCounter := lostCounter + 1 ;
37727: LD_ADDR_EXP 32
37731: PUSH
37732: LD_EXP 32
37736: PUSH
37737: LD_INT 1
37739: PLUS
37740: ST_TO_ADDR
// if un in behemothBuilders then
37741: LD_VAR 0 1
37745: PUSH
37746: LD_EXP 77
37750: IN
37751: IFFALSE 37771
// begin behemothBuilders := behemothBuilders diff un ;
37753: LD_ADDR_EXP 77
37757: PUSH
37758: LD_EXP 77
37762: PUSH
37763: LD_VAR 0 1
37767: DIFF
37768: ST_TO_ADDR
// exit ;
37769: GO 37801
// end ; if un = JMM then
37771: LD_VAR 0 1
37775: PUSH
37776: LD_EXP 40
37780: EQUAL
37781: IFFALSE 37792
// begin YouLost ( JMM ) ;
37783: LD_STRING JMM
37785: PPUSH
37786: CALL_OW 104
// exit ;
37790: GO 37801
// end ; MCE_UnitDestroyed ( un ) ;
37792: LD_VAR 0 1
37796: PPUSH
37797: CALL 66734 0 1
// end ;
37801: PPOPN 1
37803: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37804: LD_VAR 0 1
37808: PPUSH
37809: LD_VAR 0 2
37813: PPUSH
37814: CALL 69066 0 2
// end ;
37818: PPOPN 2
37820: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37821: LD_VAR 0 1
37825: PPUSH
37826: CALL 68134 0 1
// end ;
37830: PPOPN 1
37832: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37833: LD_VAR 0 1
37837: PUSH
37838: LD_INT 22
37840: PUSH
37841: LD_INT 8
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 30
37850: PUSH
37851: LD_INT 2
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 23
37860: PUSH
37861: LD_INT 3
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: LIST
37872: PPUSH
37873: CALL_OW 69
37877: IN
37878: IFFALSE 37905
// begin ComUpgrade ( building ) ;
37880: LD_VAR 0 1
37884: PPUSH
37885: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37889: LD_EXP 65
37893: PPUSH
37894: LD_VAR 0 1
37898: PPUSH
37899: CALL 77918 0 2
// exit ;
37903: GO 37914
// end ; MCE_BuildingComplete ( building ) ;
37905: LD_VAR 0 1
37909: PPUSH
37910: CALL 68375 0 1
// end ;
37914: PPOPN 1
37916: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37917: LD_VAR 0 1
37921: PPUSH
37922: LD_VAR 0 2
37926: PPUSH
37927: CALL 66430 0 2
// end ;
37931: PPOPN 2
37933: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37934: LD_VAR 0 1
37938: PPUSH
37939: LD_VAR 0 2
37943: PPUSH
37944: LD_VAR 0 3
37948: PPUSH
37949: LD_VAR 0 4
37953: PPUSH
37954: LD_VAR 0 5
37958: PPUSH
37959: CALL 66050 0 5
// end ;
37963: PPOPN 5
37965: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37966: LD_VAR 0 1
37970: PPUSH
37971: CALL_OW 255
37975: PUSH
37976: LD_INT 1
37978: EQUAL
37979: IFFALSE 37996
// amConstructCounter := Inc ( amConstructCounter ) ;
37981: LD_ADDR_EXP 39
37985: PUSH
37986: LD_EXP 39
37990: PPUSH
37991: CALL 108770 0 1
37995: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37996: LD_VAR 0 1
38000: PPUSH
38001: LD_VAR 0 2
38005: PPUSH
38006: CALL 128428 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38010: LD_VAR 0 1
38014: PPUSH
38015: LD_VAR 0 2
38019: PPUSH
38020: CALL 65603 0 2
// end ;
38024: PPOPN 2
38026: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38027: LD_VAR 0 1
38031: PPUSH
38032: LD_VAR 0 2
38036: PPUSH
38037: LD_VAR 0 3
38041: PPUSH
38042: LD_VAR 0 4
38046: PPUSH
38047: CALL 65441 0 4
// end ;
38051: PPOPN 4
38053: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38054: LD_VAR 0 1
38058: PPUSH
38059: LD_VAR 0 2
38063: PPUSH
38064: LD_VAR 0 3
38068: PPUSH
38069: CALL 65216 0 3
// end ;
38073: PPOPN 3
38075: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38076: LD_VAR 0 1
38080: PPUSH
38081: LD_VAR 0 2
38085: PPUSH
38086: CALL 65101 0 2
// end ;
38090: PPOPN 2
38092: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38093: LD_VAR 0 1
38097: PPUSH
38098: LD_VAR 0 2
38102: PPUSH
38103: CALL 69361 0 2
// end ;
38107: PPOPN 2
38109: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38110: LD_VAR 0 1
38114: PUSH
38115: LD_INT 460
38117: EQUAL
38118: IFFALSE 38140
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38120: LD_VAR 0 2
38124: PPUSH
38125: LD_INT 227
38127: PPUSH
38128: LD_INT 136
38130: PPUSH
38131: CALL_OW 428
38135: PPUSH
38136: CALL_OW 120
// end ;
38140: PPOPN 2
38142: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38143: LD_VAR 0 1
38147: PPUSH
38148: CALL_OW 255
38152: PUSH
38153: LD_INT 4
38155: EQUAL
38156: PUSH
38157: LD_VAR 0 1
38161: PUSH
38162: LD_EXP 18
38166: PUSH
38167: LD_INT 1
38169: ARRAY
38170: IN
38171: AND
38172: PUSH
38173: LD_EXP 19
38177: AND
38178: IFFALSE 38197
// begin ComMoveXY ( driver , 61 , 93 ) ;
38180: LD_VAR 0 1
38184: PPUSH
38185: LD_INT 61
38187: PPUSH
38188: LD_INT 93
38190: PPUSH
38191: CALL_OW 111
// exit ;
38195: GO 38266
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38197: LD_VAR 0 1
38201: PPUSH
38202: CALL_OW 255
38206: PUSH
38207: LD_INT 3
38209: EQUAL
38210: PUSH
38211: LD_VAR 0 1
38215: PPUSH
38216: CALL_OW 110
38220: PUSH
38221: LD_INT 105
38223: EQUAL
38224: AND
38225: IFFALSE 38242
// begin ComMoveXY ( driver , 187 , 92 ) ;
38227: LD_VAR 0 1
38231: PPUSH
38232: LD_INT 187
38234: PPUSH
38235: LD_INT 92
38237: PPUSH
38238: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38242: LD_VAR 0 1
38246: PPUSH
38247: LD_VAR 0 2
38251: PPUSH
38252: LD_VAR 0 3
38256: PPUSH
38257: LD_VAR 0 4
38261: PPUSH
38262: CALL 69577 0 4
// end ;
38266: PPOPN 4
38268: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38269: LD_VAR 0 1
38273: PPUSH
38274: LD_VAR 0 2
38278: PPUSH
38279: CALL 64910 0 2
// end ;
38283: PPOPN 2
38285: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38286: LD_VAR 0 1
38290: PPUSH
38291: CALL 128412 0 1
// end ; end_of_file
38295: PPOPN 1
38297: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38298: LD_EXP 15
38302: PUSH
38303: LD_INT 2
38305: EQUAL
38306: IFFALSE 38823
38308: GO 38310
38310: DISABLE
38311: LD_INT 0
38313: PPUSH
38314: PPUSH
// begin time := 0 0$35 ;
38315: LD_ADDR_VAR 0 2
38319: PUSH
38320: LD_INT 1225
38322: ST_TO_ADDR
// repeat wait ( time ) ;
38323: LD_VAR 0 2
38327: PPUSH
38328: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38332: LD_INT 1
38334: PPUSH
38335: LD_INT 5
38337: PPUSH
38338: CALL_OW 12
38342: PPUSH
38343: LD_INT 106
38345: PPUSH
38346: LD_INT 150
38348: PPUSH
38349: LD_INT 19
38351: PPUSH
38352: LD_INT 1
38354: PPUSH
38355: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38359: LD_INT 455
38361: PPUSH
38362: LD_INT 770
38364: PPUSH
38365: CALL_OW 12
38369: PPUSH
38370: CALL_OW 67
// if Prob ( 50 ) then
38374: LD_INT 50
38376: PPUSH
38377: CALL_OW 13
38381: IFFALSE 38410
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38383: LD_INT 1
38385: PPUSH
38386: LD_INT 5
38388: PPUSH
38389: CALL_OW 12
38393: PPUSH
38394: LD_INT 62
38396: PPUSH
38397: LD_INT 108
38399: PPUSH
38400: LD_INT 10
38402: PPUSH
38403: LD_INT 1
38405: PPUSH
38406: CALL_OW 56
// until missionStage > 4 ;
38410: LD_EXP 15
38414: PUSH
38415: LD_INT 4
38417: GREATER
38418: IFFALSE 38323
// repeat wait ( 0 0$1 ) ;
38420: LD_INT 35
38422: PPUSH
38423: CALL_OW 67
// until missionStage = 6 ;
38427: LD_EXP 15
38431: PUSH
38432: LD_INT 6
38434: EQUAL
38435: IFFALSE 38420
// time := 0 0$20 ;
38437: LD_ADDR_VAR 0 2
38441: PUSH
38442: LD_INT 700
38444: ST_TO_ADDR
// repeat wait ( time ) ;
38445: LD_VAR 0 2
38449: PPUSH
38450: CALL_OW 67
// if Prob ( 90 ) then
38454: LD_INT 90
38456: PPUSH
38457: CALL_OW 13
38461: IFFALSE 38504
// begin time := time + 0 0$2 ;
38463: LD_ADDR_VAR 0 2
38467: PUSH
38468: LD_VAR 0 2
38472: PUSH
38473: LD_INT 70
38475: PLUS
38476: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38477: LD_INT 1
38479: PPUSH
38480: LD_INT 5
38482: PPUSH
38483: CALL_OW 12
38487: PPUSH
38488: LD_INT 106
38490: PPUSH
38491: LD_INT 89
38493: PPUSH
38494: LD_INT 45
38496: PPUSH
38497: LD_INT 1
38499: PPUSH
38500: CALL_OW 56
// end ; if Prob ( 45 ) then
38504: LD_INT 45
38506: PPUSH
38507: CALL_OW 13
38511: IFFALSE 38567
// begin for i := 1 to 4 do
38513: LD_ADDR_VAR 0 1
38517: PUSH
38518: DOUBLE
38519: LD_INT 1
38521: DEC
38522: ST_TO_ADDR
38523: LD_INT 4
38525: PUSH
38526: FOR_TO
38527: IFFALSE 38565
// begin wait ( 0 0$5 ) ;
38529: LD_INT 175
38531: PPUSH
38532: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38536: LD_INT 1
38538: PPUSH
38539: LD_INT 5
38541: PPUSH
38542: CALL_OW 12
38546: PPUSH
38547: LD_INT 113
38549: PPUSH
38550: LD_INT 117
38552: PPUSH
38553: LD_INT 25
38555: PPUSH
38556: LD_INT 1
38558: PPUSH
38559: CALL_OW 56
// end ;
38563: GO 38526
38565: POP
38566: POP
// end ; if Prob ( 40 ) then
38567: LD_INT 40
38569: PPUSH
38570: CALL_OW 13
38574: IFFALSE 38620
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38576: LD_INT 385
38578: PPUSH
38579: LD_INT 945
38581: PPUSH
38582: CALL_OW 12
38586: PPUSH
38587: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38591: LD_INT 1
38593: PPUSH
38594: LD_INT 5
38596: PPUSH
38597: CALL_OW 12
38601: PPUSH
38602: LD_INT 21
38604: PPUSH
38605: LD_INT 26
38607: PPUSH
38608: LD_INT 12
38610: PPUSH
38611: LD_INT 1
38613: PPUSH
38614: CALL_OW 56
// end else
38618: GO 38656
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38620: LD_INT 700
38622: PPUSH
38623: LD_INT 1225
38625: PPUSH
38626: CALL_OW 12
38630: PPUSH
38631: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38635: LD_INT 1
38637: PPUSH
38638: LD_INT 5
38640: PPUSH
38641: CALL_OW 12
38645: PPUSH
38646: LD_INT 16
38648: PPUSH
38649: LD_INT 1
38651: PPUSH
38652: CALL_OW 55
// end ; if Prob ( 50 ) then
38656: LD_INT 50
38658: PPUSH
38659: CALL_OW 13
38663: IFFALSE 38709
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38665: LD_INT 700
38667: PPUSH
38668: LD_INT 1050
38670: PPUSH
38671: CALL_OW 12
38675: PPUSH
38676: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38680: LD_INT 1
38682: PPUSH
38683: LD_INT 5
38685: PPUSH
38686: CALL_OW 12
38690: PPUSH
38691: LD_INT 168
38693: PPUSH
38694: LD_INT 168
38696: PPUSH
38697: LD_INT 16
38699: PPUSH
38700: LD_INT 1
38702: PPUSH
38703: CALL_OW 56
// end else
38707: GO 38745
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38709: LD_INT 350
38711: PPUSH
38712: LD_INT 525
38714: PPUSH
38715: CALL_OW 12
38719: PPUSH
38720: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38724: LD_INT 1
38726: PPUSH
38727: LD_INT 5
38729: PPUSH
38730: CALL_OW 12
38734: PPUSH
38735: LD_INT 15
38737: PPUSH
38738: LD_INT 1
38740: PPUSH
38741: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38745: LD_INT 175
38747: PPUSH
38748: LD_INT 315
38750: PPUSH
38751: CALL_OW 12
38755: PPUSH
38756: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38760: LD_INT 1
38762: PPUSH
38763: LD_INT 5
38765: PPUSH
38766: CALL_OW 12
38770: PPUSH
38771: LD_INT 103
38773: PPUSH
38774: LD_INT 140
38776: PPUSH
38777: LD_INT 20
38779: PPUSH
38780: LD_INT 1
38782: PPUSH
38783: CALL_OW 56
// time := time + 0 0$2 ;
38787: LD_ADDR_VAR 0 2
38791: PUSH
38792: LD_VAR 0 2
38796: PUSH
38797: LD_INT 70
38799: PLUS
38800: ST_TO_ADDR
// if time > 1 1$20 then
38801: LD_VAR 0 2
38805: PUSH
38806: LD_INT 2800
38808: GREATER
38809: IFFALSE 38819
// time := 0 0$30 ;
38811: LD_ADDR_VAR 0 2
38815: PUSH
38816: LD_INT 1050
38818: ST_TO_ADDR
// until false ;
38819: LD_INT 0
38821: IFFALSE 38445
// end ; end_of_file
38823: PPOPN 2
38825: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38826: LD_EXP 13
38830: PUSH
38831: LD_EXP 15
38835: PUSH
38836: LD_INT 6
38838: GREATEREQUAL
38839: AND
38840: IFFALSE 38877
38842: GO 38844
38844: DISABLE
// begin enable ;
38845: ENABLE
// missionTime := missionTime + 0 0$1 ;
38846: LD_ADDR_EXP 14
38850: PUSH
38851: LD_EXP 14
38855: PUSH
38856: LD_INT 35
38858: PLUS
38859: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38860: LD_ADDR_OWVAR 47
38864: PUSH
38865: LD_STRING #Am15-1
38867: PUSH
38868: LD_EXP 14
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: ST_TO_ADDR
// end ; end_of_file
38877: END
// export function InitNature ; begin
38878: LD_INT 0
38880: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38881: LD_INT 3
38883: PPUSH
38884: LD_INT 3
38886: PPUSH
38887: LD_INT 2
38889: PPUSH
38890: LD_INT 1
38892: PPUSH
38893: LD_INT 1
38895: PPUSH
38896: LD_INT 0
38898: PPUSH
38899: LD_INT 0
38901: PPUSH
38902: LD_INT 20
38904: PPUSH
38905: LD_INT 0
38907: PPUSH
38908: CALL 104086 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38912: LD_INT 2
38914: PPUSH
38915: LD_INT 1
38917: PPUSH
38918: LD_INT 1
38920: PPUSH
38921: LD_INT 1
38923: PPUSH
38924: LD_INT 1
38926: PPUSH
38927: LD_INT 0
38929: PPUSH
38930: LD_INT 0
38932: PPUSH
38933: LD_INT 21
38935: PPUSH
38936: LD_INT 0
38938: PPUSH
38939: CALL 104086 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38943: LD_INT 4
38945: PPUSH
38946: LD_INT 1
38948: PPUSH
38949: LD_INT 2
38951: PPUSH
38952: LD_INT 4
38954: PPUSH
38955: LD_INT 2
38957: PPUSH
38958: LD_INT 1
38960: PPUSH
38961: LD_INT 0
38963: PPUSH
38964: LD_INT 22
38966: PPUSH
38967: LD_INT 0
38969: PPUSH
38970: CALL 104086 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38974: LD_INT 0
38976: PPUSH
38977: LD_INT 0
38979: PPUSH
38980: LD_INT 0
38982: PPUSH
38983: LD_INT 0
38985: PPUSH
38986: LD_INT 0
38988: PPUSH
38989: LD_INT 0
38991: PPUSH
38992: LD_INT 9
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: LD_INT 23
39000: PPUSH
39001: CALL 104086 0 9
// end ; end_of_file
39005: LD_VAR 0 1
39009: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39010: LD_INT 0
39012: PPUSH
39013: PPUSH
// skirmish := false ;
39014: LD_ADDR_EXP 100
39018: PUSH
39019: LD_INT 0
39021: ST_TO_ADDR
// debug_mc := false ;
39022: LD_ADDR_EXP 101
39026: PUSH
39027: LD_INT 0
39029: ST_TO_ADDR
// mc_bases := [ ] ;
39030: LD_ADDR_EXP 102
39034: PUSH
39035: EMPTY
39036: ST_TO_ADDR
// mc_sides := [ ] ;
39037: LD_ADDR_EXP 128
39041: PUSH
39042: EMPTY
39043: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39044: LD_ADDR_EXP 103
39048: PUSH
39049: EMPTY
39050: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39051: LD_ADDR_EXP 104
39055: PUSH
39056: EMPTY
39057: ST_TO_ADDR
// mc_need_heal := [ ] ;
39058: LD_ADDR_EXP 105
39062: PUSH
39063: EMPTY
39064: ST_TO_ADDR
// mc_healers := [ ] ;
39065: LD_ADDR_EXP 106
39069: PUSH
39070: EMPTY
39071: ST_TO_ADDR
// mc_build_list := [ ] ;
39072: LD_ADDR_EXP 107
39076: PUSH
39077: EMPTY
39078: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39079: LD_ADDR_EXP 134
39083: PUSH
39084: EMPTY
39085: ST_TO_ADDR
// mc_builders := [ ] ;
39086: LD_ADDR_EXP 108
39090: PUSH
39091: EMPTY
39092: ST_TO_ADDR
// mc_construct_list := [ ] ;
39093: LD_ADDR_EXP 109
39097: PUSH
39098: EMPTY
39099: ST_TO_ADDR
// mc_turret_list := [ ] ;
39100: LD_ADDR_EXP 110
39104: PUSH
39105: EMPTY
39106: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39107: LD_ADDR_EXP 111
39111: PUSH
39112: EMPTY
39113: ST_TO_ADDR
// mc_miners := [ ] ;
39114: LD_ADDR_EXP 116
39118: PUSH
39119: EMPTY
39120: ST_TO_ADDR
// mc_mines := [ ] ;
39121: LD_ADDR_EXP 115
39125: PUSH
39126: EMPTY
39127: ST_TO_ADDR
// mc_minefields := [ ] ;
39128: LD_ADDR_EXP 117
39132: PUSH
39133: EMPTY
39134: ST_TO_ADDR
// mc_crates := [ ] ;
39135: LD_ADDR_EXP 118
39139: PUSH
39140: EMPTY
39141: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39142: LD_ADDR_EXP 119
39146: PUSH
39147: EMPTY
39148: ST_TO_ADDR
// mc_crates_area := [ ] ;
39149: LD_ADDR_EXP 120
39153: PUSH
39154: EMPTY
39155: ST_TO_ADDR
// mc_vehicles := [ ] ;
39156: LD_ADDR_EXP 121
39160: PUSH
39161: EMPTY
39162: ST_TO_ADDR
// mc_attack := [ ] ;
39163: LD_ADDR_EXP 122
39167: PUSH
39168: EMPTY
39169: ST_TO_ADDR
// mc_produce := [ ] ;
39170: LD_ADDR_EXP 123
39174: PUSH
39175: EMPTY
39176: ST_TO_ADDR
// mc_defender := [ ] ;
39177: LD_ADDR_EXP 124
39181: PUSH
39182: EMPTY
39183: ST_TO_ADDR
// mc_parking := [ ] ;
39184: LD_ADDR_EXP 126
39188: PUSH
39189: EMPTY
39190: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39191: LD_ADDR_EXP 112
39195: PUSH
39196: EMPTY
39197: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39198: LD_ADDR_EXP 114
39202: PUSH
39203: EMPTY
39204: ST_TO_ADDR
// mc_scan := [ ] ;
39205: LD_ADDR_EXP 125
39209: PUSH
39210: EMPTY
39211: ST_TO_ADDR
// mc_scan_area := [ ] ;
39212: LD_ADDR_EXP 127
39216: PUSH
39217: EMPTY
39218: ST_TO_ADDR
// mc_tech := [ ] ;
39219: LD_ADDR_EXP 129
39223: PUSH
39224: EMPTY
39225: ST_TO_ADDR
// mc_class := [ ] ;
39226: LD_ADDR_EXP 143
39230: PUSH
39231: EMPTY
39232: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39233: LD_ADDR_EXP 144
39237: PUSH
39238: EMPTY
39239: ST_TO_ADDR
// mc_is_defending := [ ] ;
39240: LD_ADDR_EXP 145
39244: PUSH
39245: EMPTY
39246: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39247: LD_ADDR_EXP 136
39251: PUSH
39252: EMPTY
39253: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39254: LD_ADDR_EXP 146
39258: PUSH
39259: LD_INT 0
39261: ST_TO_ADDR
// end ;
39262: LD_VAR 0 1
39266: RET
// export function MC_Kill ( base ) ; begin
39267: LD_INT 0
39269: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39270: LD_ADDR_EXP 102
39274: PUSH
39275: LD_EXP 102
39279: PPUSH
39280: LD_VAR 0 1
39284: PPUSH
39285: EMPTY
39286: PPUSH
39287: CALL_OW 1
39291: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39292: LD_ADDR_EXP 103
39296: PUSH
39297: LD_EXP 103
39301: PPUSH
39302: LD_VAR 0 1
39306: PPUSH
39307: EMPTY
39308: PPUSH
39309: CALL_OW 1
39313: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39314: LD_ADDR_EXP 104
39318: PUSH
39319: LD_EXP 104
39323: PPUSH
39324: LD_VAR 0 1
39328: PPUSH
39329: EMPTY
39330: PPUSH
39331: CALL_OW 1
39335: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39336: LD_ADDR_EXP 105
39340: PUSH
39341: LD_EXP 105
39345: PPUSH
39346: LD_VAR 0 1
39350: PPUSH
39351: EMPTY
39352: PPUSH
39353: CALL_OW 1
39357: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39358: LD_ADDR_EXP 106
39362: PUSH
39363: LD_EXP 106
39367: PPUSH
39368: LD_VAR 0 1
39372: PPUSH
39373: EMPTY
39374: PPUSH
39375: CALL_OW 1
39379: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39380: LD_ADDR_EXP 107
39384: PUSH
39385: LD_EXP 107
39389: PPUSH
39390: LD_VAR 0 1
39394: PPUSH
39395: EMPTY
39396: PPUSH
39397: CALL_OW 1
39401: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39402: LD_ADDR_EXP 108
39406: PUSH
39407: LD_EXP 108
39411: PPUSH
39412: LD_VAR 0 1
39416: PPUSH
39417: EMPTY
39418: PPUSH
39419: CALL_OW 1
39423: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39424: LD_ADDR_EXP 109
39428: PUSH
39429: LD_EXP 109
39433: PPUSH
39434: LD_VAR 0 1
39438: PPUSH
39439: EMPTY
39440: PPUSH
39441: CALL_OW 1
39445: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39446: LD_ADDR_EXP 110
39450: PUSH
39451: LD_EXP 110
39455: PPUSH
39456: LD_VAR 0 1
39460: PPUSH
39461: EMPTY
39462: PPUSH
39463: CALL_OW 1
39467: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39468: LD_ADDR_EXP 111
39472: PUSH
39473: LD_EXP 111
39477: PPUSH
39478: LD_VAR 0 1
39482: PPUSH
39483: EMPTY
39484: PPUSH
39485: CALL_OW 1
39489: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39490: LD_ADDR_EXP 112
39494: PUSH
39495: LD_EXP 112
39499: PPUSH
39500: LD_VAR 0 1
39504: PPUSH
39505: EMPTY
39506: PPUSH
39507: CALL_OW 1
39511: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39512: LD_ADDR_EXP 113
39516: PUSH
39517: LD_EXP 113
39521: PPUSH
39522: LD_VAR 0 1
39526: PPUSH
39527: LD_INT 0
39529: PPUSH
39530: CALL_OW 1
39534: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39535: LD_ADDR_EXP 114
39539: PUSH
39540: LD_EXP 114
39544: PPUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: EMPTY
39551: PPUSH
39552: CALL_OW 1
39556: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39557: LD_ADDR_EXP 115
39561: PUSH
39562: LD_EXP 115
39566: PPUSH
39567: LD_VAR 0 1
39571: PPUSH
39572: EMPTY
39573: PPUSH
39574: CALL_OW 1
39578: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39579: LD_ADDR_EXP 116
39583: PUSH
39584: LD_EXP 116
39588: PPUSH
39589: LD_VAR 0 1
39593: PPUSH
39594: EMPTY
39595: PPUSH
39596: CALL_OW 1
39600: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39601: LD_ADDR_EXP 117
39605: PUSH
39606: LD_EXP 117
39610: PPUSH
39611: LD_VAR 0 1
39615: PPUSH
39616: EMPTY
39617: PPUSH
39618: CALL_OW 1
39622: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39623: LD_ADDR_EXP 118
39627: PUSH
39628: LD_EXP 118
39632: PPUSH
39633: LD_VAR 0 1
39637: PPUSH
39638: EMPTY
39639: PPUSH
39640: CALL_OW 1
39644: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39645: LD_ADDR_EXP 119
39649: PUSH
39650: LD_EXP 119
39654: PPUSH
39655: LD_VAR 0 1
39659: PPUSH
39660: EMPTY
39661: PPUSH
39662: CALL_OW 1
39666: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39667: LD_ADDR_EXP 120
39671: PUSH
39672: LD_EXP 120
39676: PPUSH
39677: LD_VAR 0 1
39681: PPUSH
39682: EMPTY
39683: PPUSH
39684: CALL_OW 1
39688: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39689: LD_ADDR_EXP 121
39693: PUSH
39694: LD_EXP 121
39698: PPUSH
39699: LD_VAR 0 1
39703: PPUSH
39704: EMPTY
39705: PPUSH
39706: CALL_OW 1
39710: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39711: LD_ADDR_EXP 122
39715: PUSH
39716: LD_EXP 122
39720: PPUSH
39721: LD_VAR 0 1
39725: PPUSH
39726: EMPTY
39727: PPUSH
39728: CALL_OW 1
39732: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39733: LD_ADDR_EXP 123
39737: PUSH
39738: LD_EXP 123
39742: PPUSH
39743: LD_VAR 0 1
39747: PPUSH
39748: EMPTY
39749: PPUSH
39750: CALL_OW 1
39754: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39755: LD_ADDR_EXP 124
39759: PUSH
39760: LD_EXP 124
39764: PPUSH
39765: LD_VAR 0 1
39769: PPUSH
39770: EMPTY
39771: PPUSH
39772: CALL_OW 1
39776: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39777: LD_ADDR_EXP 125
39781: PUSH
39782: LD_EXP 125
39786: PPUSH
39787: LD_VAR 0 1
39791: PPUSH
39792: EMPTY
39793: PPUSH
39794: CALL_OW 1
39798: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39799: LD_ADDR_EXP 126
39803: PUSH
39804: LD_EXP 126
39808: PPUSH
39809: LD_VAR 0 1
39813: PPUSH
39814: EMPTY
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39821: LD_ADDR_EXP 127
39825: PUSH
39826: LD_EXP 127
39830: PPUSH
39831: LD_VAR 0 1
39835: PPUSH
39836: EMPTY
39837: PPUSH
39838: CALL_OW 1
39842: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39843: LD_ADDR_EXP 129
39847: PUSH
39848: LD_EXP 129
39852: PPUSH
39853: LD_VAR 0 1
39857: PPUSH
39858: EMPTY
39859: PPUSH
39860: CALL_OW 1
39864: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39865: LD_ADDR_EXP 131
39869: PUSH
39870: LD_EXP 131
39874: PPUSH
39875: LD_VAR 0 1
39879: PPUSH
39880: EMPTY
39881: PPUSH
39882: CALL_OW 1
39886: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39887: LD_ADDR_EXP 132
39891: PUSH
39892: LD_EXP 132
39896: PPUSH
39897: LD_VAR 0 1
39901: PPUSH
39902: EMPTY
39903: PPUSH
39904: CALL_OW 1
39908: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39909: LD_ADDR_EXP 133
39913: PUSH
39914: LD_EXP 133
39918: PPUSH
39919: LD_VAR 0 1
39923: PPUSH
39924: EMPTY
39925: PPUSH
39926: CALL_OW 1
39930: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39931: LD_ADDR_EXP 134
39935: PUSH
39936: LD_EXP 134
39940: PPUSH
39941: LD_VAR 0 1
39945: PPUSH
39946: EMPTY
39947: PPUSH
39948: CALL_OW 1
39952: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39953: LD_ADDR_EXP 135
39957: PUSH
39958: LD_EXP 135
39962: PPUSH
39963: LD_VAR 0 1
39967: PPUSH
39968: EMPTY
39969: PPUSH
39970: CALL_OW 1
39974: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39975: LD_ADDR_EXP 136
39979: PUSH
39980: LD_EXP 136
39984: PPUSH
39985: LD_VAR 0 1
39989: PPUSH
39990: EMPTY
39991: PPUSH
39992: CALL_OW 1
39996: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39997: LD_ADDR_EXP 137
40001: PUSH
40002: LD_EXP 137
40006: PPUSH
40007: LD_VAR 0 1
40011: PPUSH
40012: EMPTY
40013: PPUSH
40014: CALL_OW 1
40018: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40019: LD_ADDR_EXP 138
40023: PUSH
40024: LD_EXP 138
40028: PPUSH
40029: LD_VAR 0 1
40033: PPUSH
40034: EMPTY
40035: PPUSH
40036: CALL_OW 1
40040: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40041: LD_ADDR_EXP 139
40045: PUSH
40046: LD_EXP 139
40050: PPUSH
40051: LD_VAR 0 1
40055: PPUSH
40056: EMPTY
40057: PPUSH
40058: CALL_OW 1
40062: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40063: LD_ADDR_EXP 140
40067: PUSH
40068: LD_EXP 140
40072: PPUSH
40073: LD_VAR 0 1
40077: PPUSH
40078: EMPTY
40079: PPUSH
40080: CALL_OW 1
40084: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40085: LD_ADDR_EXP 141
40089: PUSH
40090: LD_EXP 141
40094: PPUSH
40095: LD_VAR 0 1
40099: PPUSH
40100: EMPTY
40101: PPUSH
40102: CALL_OW 1
40106: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40107: LD_ADDR_EXP 142
40111: PUSH
40112: LD_EXP 142
40116: PPUSH
40117: LD_VAR 0 1
40121: PPUSH
40122: EMPTY
40123: PPUSH
40124: CALL_OW 1
40128: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40129: LD_ADDR_EXP 143
40133: PUSH
40134: LD_EXP 143
40138: PPUSH
40139: LD_VAR 0 1
40143: PPUSH
40144: EMPTY
40145: PPUSH
40146: CALL_OW 1
40150: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40151: LD_ADDR_EXP 144
40155: PUSH
40156: LD_EXP 144
40160: PPUSH
40161: LD_VAR 0 1
40165: PPUSH
40166: LD_INT 0
40168: PPUSH
40169: CALL_OW 1
40173: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40174: LD_ADDR_EXP 145
40178: PUSH
40179: LD_EXP 145
40183: PPUSH
40184: LD_VAR 0 1
40188: PPUSH
40189: LD_INT 0
40191: PPUSH
40192: CALL_OW 1
40196: ST_TO_ADDR
// end ;
40197: LD_VAR 0 2
40201: RET
// export function MC_Add ( side , units ) ; var base ; begin
40202: LD_INT 0
40204: PPUSH
40205: PPUSH
// base := mc_bases + 1 ;
40206: LD_ADDR_VAR 0 4
40210: PUSH
40211: LD_EXP 102
40215: PUSH
40216: LD_INT 1
40218: PLUS
40219: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40220: LD_ADDR_EXP 128
40224: PUSH
40225: LD_EXP 128
40229: PPUSH
40230: LD_VAR 0 4
40234: PPUSH
40235: LD_VAR 0 1
40239: PPUSH
40240: CALL_OW 1
40244: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40245: LD_ADDR_EXP 102
40249: PUSH
40250: LD_EXP 102
40254: PPUSH
40255: LD_VAR 0 4
40259: PPUSH
40260: LD_VAR 0 2
40264: PPUSH
40265: CALL_OW 1
40269: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40270: LD_ADDR_EXP 103
40274: PUSH
40275: LD_EXP 103
40279: PPUSH
40280: LD_VAR 0 4
40284: PPUSH
40285: EMPTY
40286: PPUSH
40287: CALL_OW 1
40291: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40292: LD_ADDR_EXP 104
40296: PUSH
40297: LD_EXP 104
40301: PPUSH
40302: LD_VAR 0 4
40306: PPUSH
40307: EMPTY
40308: PPUSH
40309: CALL_OW 1
40313: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40314: LD_ADDR_EXP 105
40318: PUSH
40319: LD_EXP 105
40323: PPUSH
40324: LD_VAR 0 4
40328: PPUSH
40329: EMPTY
40330: PPUSH
40331: CALL_OW 1
40335: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40336: LD_ADDR_EXP 106
40340: PUSH
40341: LD_EXP 106
40345: PPUSH
40346: LD_VAR 0 4
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL_OW 1
40357: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40358: LD_ADDR_EXP 107
40362: PUSH
40363: LD_EXP 107
40367: PPUSH
40368: LD_VAR 0 4
40372: PPUSH
40373: EMPTY
40374: PPUSH
40375: CALL_OW 1
40379: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40380: LD_ADDR_EXP 108
40384: PUSH
40385: LD_EXP 108
40389: PPUSH
40390: LD_VAR 0 4
40394: PPUSH
40395: EMPTY
40396: PPUSH
40397: CALL_OW 1
40401: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40402: LD_ADDR_EXP 109
40406: PUSH
40407: LD_EXP 109
40411: PPUSH
40412: LD_VAR 0 4
40416: PPUSH
40417: EMPTY
40418: PPUSH
40419: CALL_OW 1
40423: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40424: LD_ADDR_EXP 110
40428: PUSH
40429: LD_EXP 110
40433: PPUSH
40434: LD_VAR 0 4
40438: PPUSH
40439: EMPTY
40440: PPUSH
40441: CALL_OW 1
40445: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40446: LD_ADDR_EXP 111
40450: PUSH
40451: LD_EXP 111
40455: PPUSH
40456: LD_VAR 0 4
40460: PPUSH
40461: EMPTY
40462: PPUSH
40463: CALL_OW 1
40467: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40468: LD_ADDR_EXP 112
40472: PUSH
40473: LD_EXP 112
40477: PPUSH
40478: LD_VAR 0 4
40482: PPUSH
40483: EMPTY
40484: PPUSH
40485: CALL_OW 1
40489: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40490: LD_ADDR_EXP 113
40494: PUSH
40495: LD_EXP 113
40499: PPUSH
40500: LD_VAR 0 4
40504: PPUSH
40505: LD_INT 0
40507: PPUSH
40508: CALL_OW 1
40512: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40513: LD_ADDR_EXP 114
40517: PUSH
40518: LD_EXP 114
40522: PPUSH
40523: LD_VAR 0 4
40527: PPUSH
40528: EMPTY
40529: PPUSH
40530: CALL_OW 1
40534: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40535: LD_ADDR_EXP 115
40539: PUSH
40540: LD_EXP 115
40544: PPUSH
40545: LD_VAR 0 4
40549: PPUSH
40550: EMPTY
40551: PPUSH
40552: CALL_OW 1
40556: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40557: LD_ADDR_EXP 116
40561: PUSH
40562: LD_EXP 116
40566: PPUSH
40567: LD_VAR 0 4
40571: PPUSH
40572: EMPTY
40573: PPUSH
40574: CALL_OW 1
40578: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40579: LD_ADDR_EXP 117
40583: PUSH
40584: LD_EXP 117
40588: PPUSH
40589: LD_VAR 0 4
40593: PPUSH
40594: EMPTY
40595: PPUSH
40596: CALL_OW 1
40600: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40601: LD_ADDR_EXP 118
40605: PUSH
40606: LD_EXP 118
40610: PPUSH
40611: LD_VAR 0 4
40615: PPUSH
40616: EMPTY
40617: PPUSH
40618: CALL_OW 1
40622: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40623: LD_ADDR_EXP 119
40627: PUSH
40628: LD_EXP 119
40632: PPUSH
40633: LD_VAR 0 4
40637: PPUSH
40638: EMPTY
40639: PPUSH
40640: CALL_OW 1
40644: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40645: LD_ADDR_EXP 120
40649: PUSH
40650: LD_EXP 120
40654: PPUSH
40655: LD_VAR 0 4
40659: PPUSH
40660: EMPTY
40661: PPUSH
40662: CALL_OW 1
40666: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40667: LD_ADDR_EXP 121
40671: PUSH
40672: LD_EXP 121
40676: PPUSH
40677: LD_VAR 0 4
40681: PPUSH
40682: EMPTY
40683: PPUSH
40684: CALL_OW 1
40688: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40689: LD_ADDR_EXP 122
40693: PUSH
40694: LD_EXP 122
40698: PPUSH
40699: LD_VAR 0 4
40703: PPUSH
40704: EMPTY
40705: PPUSH
40706: CALL_OW 1
40710: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40711: LD_ADDR_EXP 123
40715: PUSH
40716: LD_EXP 123
40720: PPUSH
40721: LD_VAR 0 4
40725: PPUSH
40726: EMPTY
40727: PPUSH
40728: CALL_OW 1
40732: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40733: LD_ADDR_EXP 124
40737: PUSH
40738: LD_EXP 124
40742: PPUSH
40743: LD_VAR 0 4
40747: PPUSH
40748: EMPTY
40749: PPUSH
40750: CALL_OW 1
40754: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40755: LD_ADDR_EXP 125
40759: PUSH
40760: LD_EXP 125
40764: PPUSH
40765: LD_VAR 0 4
40769: PPUSH
40770: EMPTY
40771: PPUSH
40772: CALL_OW 1
40776: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40777: LD_ADDR_EXP 126
40781: PUSH
40782: LD_EXP 126
40786: PPUSH
40787: LD_VAR 0 4
40791: PPUSH
40792: EMPTY
40793: PPUSH
40794: CALL_OW 1
40798: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40799: LD_ADDR_EXP 127
40803: PUSH
40804: LD_EXP 127
40808: PPUSH
40809: LD_VAR 0 4
40813: PPUSH
40814: EMPTY
40815: PPUSH
40816: CALL_OW 1
40820: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40821: LD_ADDR_EXP 129
40825: PUSH
40826: LD_EXP 129
40830: PPUSH
40831: LD_VAR 0 4
40835: PPUSH
40836: EMPTY
40837: PPUSH
40838: CALL_OW 1
40842: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40843: LD_ADDR_EXP 131
40847: PUSH
40848: LD_EXP 131
40852: PPUSH
40853: LD_VAR 0 4
40857: PPUSH
40858: EMPTY
40859: PPUSH
40860: CALL_OW 1
40864: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40865: LD_ADDR_EXP 132
40869: PUSH
40870: LD_EXP 132
40874: PPUSH
40875: LD_VAR 0 4
40879: PPUSH
40880: EMPTY
40881: PPUSH
40882: CALL_OW 1
40886: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40887: LD_ADDR_EXP 133
40891: PUSH
40892: LD_EXP 133
40896: PPUSH
40897: LD_VAR 0 4
40901: PPUSH
40902: EMPTY
40903: PPUSH
40904: CALL_OW 1
40908: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40909: LD_ADDR_EXP 134
40913: PUSH
40914: LD_EXP 134
40918: PPUSH
40919: LD_VAR 0 4
40923: PPUSH
40924: EMPTY
40925: PPUSH
40926: CALL_OW 1
40930: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40931: LD_ADDR_EXP 135
40935: PUSH
40936: LD_EXP 135
40940: PPUSH
40941: LD_VAR 0 4
40945: PPUSH
40946: EMPTY
40947: PPUSH
40948: CALL_OW 1
40952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40953: LD_ADDR_EXP 136
40957: PUSH
40958: LD_EXP 136
40962: PPUSH
40963: LD_VAR 0 4
40967: PPUSH
40968: EMPTY
40969: PPUSH
40970: CALL_OW 1
40974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40975: LD_ADDR_EXP 137
40979: PUSH
40980: LD_EXP 137
40984: PPUSH
40985: LD_VAR 0 4
40989: PPUSH
40990: EMPTY
40991: PPUSH
40992: CALL_OW 1
40996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40997: LD_ADDR_EXP 138
41001: PUSH
41002: LD_EXP 138
41006: PPUSH
41007: LD_VAR 0 4
41011: PPUSH
41012: EMPTY
41013: PPUSH
41014: CALL_OW 1
41018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41019: LD_ADDR_EXP 139
41023: PUSH
41024: LD_EXP 139
41028: PPUSH
41029: LD_VAR 0 4
41033: PPUSH
41034: EMPTY
41035: PPUSH
41036: CALL_OW 1
41040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41041: LD_ADDR_EXP 140
41045: PUSH
41046: LD_EXP 140
41050: PPUSH
41051: LD_VAR 0 4
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL_OW 1
41062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41063: LD_ADDR_EXP 141
41067: PUSH
41068: LD_EXP 141
41072: PPUSH
41073: LD_VAR 0 4
41077: PPUSH
41078: EMPTY
41079: PPUSH
41080: CALL_OW 1
41084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41085: LD_ADDR_EXP 142
41089: PUSH
41090: LD_EXP 142
41094: PPUSH
41095: LD_VAR 0 4
41099: PPUSH
41100: EMPTY
41101: PPUSH
41102: CALL_OW 1
41106: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41107: LD_ADDR_EXP 143
41111: PUSH
41112: LD_EXP 143
41116: PPUSH
41117: LD_VAR 0 4
41121: PPUSH
41122: EMPTY
41123: PPUSH
41124: CALL_OW 1
41128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41129: LD_ADDR_EXP 144
41133: PUSH
41134: LD_EXP 144
41138: PPUSH
41139: LD_VAR 0 4
41143: PPUSH
41144: LD_INT 0
41146: PPUSH
41147: CALL_OW 1
41151: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41152: LD_ADDR_EXP 145
41156: PUSH
41157: LD_EXP 145
41161: PPUSH
41162: LD_VAR 0 4
41166: PPUSH
41167: LD_INT 0
41169: PPUSH
41170: CALL_OW 1
41174: ST_TO_ADDR
// result := base ;
41175: LD_ADDR_VAR 0 3
41179: PUSH
41180: LD_VAR 0 4
41184: ST_TO_ADDR
// end ;
41185: LD_VAR 0 3
41189: RET
// export function MC_Start ( ) ; var i ; begin
41190: LD_INT 0
41192: PPUSH
41193: PPUSH
// for i = 1 to mc_bases do
41194: LD_ADDR_VAR 0 2
41198: PUSH
41199: DOUBLE
41200: LD_INT 1
41202: DEC
41203: ST_TO_ADDR
41204: LD_EXP 102
41208: PUSH
41209: FOR_TO
41210: IFFALSE 42310
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41212: LD_ADDR_EXP 102
41216: PUSH
41217: LD_EXP 102
41221: PPUSH
41222: LD_VAR 0 2
41226: PPUSH
41227: LD_EXP 102
41231: PUSH
41232: LD_VAR 0 2
41236: ARRAY
41237: PUSH
41238: LD_INT 0
41240: DIFF
41241: PPUSH
41242: CALL_OW 1
41246: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41247: LD_ADDR_EXP 103
41251: PUSH
41252: LD_EXP 103
41256: PPUSH
41257: LD_VAR 0 2
41261: PPUSH
41262: EMPTY
41263: PPUSH
41264: CALL_OW 1
41268: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41269: LD_ADDR_EXP 104
41273: PUSH
41274: LD_EXP 104
41278: PPUSH
41279: LD_VAR 0 2
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41291: LD_ADDR_EXP 105
41295: PUSH
41296: LD_EXP 105
41300: PPUSH
41301: LD_VAR 0 2
41305: PPUSH
41306: EMPTY
41307: PPUSH
41308: CALL_OW 1
41312: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41313: LD_ADDR_EXP 106
41317: PUSH
41318: LD_EXP 106
41322: PPUSH
41323: LD_VAR 0 2
41327: PPUSH
41328: EMPTY
41329: PUSH
41330: EMPTY
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PPUSH
41336: CALL_OW 1
41340: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41341: LD_ADDR_EXP 107
41345: PUSH
41346: LD_EXP 107
41350: PPUSH
41351: LD_VAR 0 2
41355: PPUSH
41356: EMPTY
41357: PPUSH
41358: CALL_OW 1
41362: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41363: LD_ADDR_EXP 134
41367: PUSH
41368: LD_EXP 134
41372: PPUSH
41373: LD_VAR 0 2
41377: PPUSH
41378: EMPTY
41379: PPUSH
41380: CALL_OW 1
41384: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41385: LD_ADDR_EXP 108
41389: PUSH
41390: LD_EXP 108
41394: PPUSH
41395: LD_VAR 0 2
41399: PPUSH
41400: EMPTY
41401: PPUSH
41402: CALL_OW 1
41406: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41407: LD_ADDR_EXP 109
41411: PUSH
41412: LD_EXP 109
41416: PPUSH
41417: LD_VAR 0 2
41421: PPUSH
41422: EMPTY
41423: PPUSH
41424: CALL_OW 1
41428: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41429: LD_ADDR_EXP 110
41433: PUSH
41434: LD_EXP 110
41438: PPUSH
41439: LD_VAR 0 2
41443: PPUSH
41444: LD_EXP 102
41448: PUSH
41449: LD_VAR 0 2
41453: ARRAY
41454: PPUSH
41455: LD_INT 2
41457: PUSH
41458: LD_INT 30
41460: PUSH
41461: LD_INT 32
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 30
41470: PUSH
41471: LD_INT 33
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: LIST
41482: PPUSH
41483: CALL_OW 72
41487: PPUSH
41488: CALL_OW 1
41492: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41493: LD_ADDR_EXP 111
41497: PUSH
41498: LD_EXP 111
41502: PPUSH
41503: LD_VAR 0 2
41507: PPUSH
41508: LD_EXP 102
41512: PUSH
41513: LD_VAR 0 2
41517: ARRAY
41518: PPUSH
41519: LD_INT 2
41521: PUSH
41522: LD_INT 30
41524: PUSH
41525: LD_INT 32
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 30
41534: PUSH
41535: LD_INT 31
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 58
41549: PUSH
41550: EMPTY
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PPUSH
41557: CALL_OW 72
41561: PPUSH
41562: CALL_OW 1
41566: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41567: LD_ADDR_EXP 112
41571: PUSH
41572: LD_EXP 112
41576: PPUSH
41577: LD_VAR 0 2
41581: PPUSH
41582: EMPTY
41583: PPUSH
41584: CALL_OW 1
41588: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41589: LD_ADDR_EXP 116
41593: PUSH
41594: LD_EXP 116
41598: PPUSH
41599: LD_VAR 0 2
41603: PPUSH
41604: EMPTY
41605: PPUSH
41606: CALL_OW 1
41610: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41611: LD_ADDR_EXP 115
41615: PUSH
41616: LD_EXP 115
41620: PPUSH
41621: LD_VAR 0 2
41625: PPUSH
41626: EMPTY
41627: PPUSH
41628: CALL_OW 1
41632: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41633: LD_ADDR_EXP 117
41637: PUSH
41638: LD_EXP 117
41642: PPUSH
41643: LD_VAR 0 2
41647: PPUSH
41648: EMPTY
41649: PPUSH
41650: CALL_OW 1
41654: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41655: LD_ADDR_EXP 118
41659: PUSH
41660: LD_EXP 118
41664: PPUSH
41665: LD_VAR 0 2
41669: PPUSH
41670: EMPTY
41671: PPUSH
41672: CALL_OW 1
41676: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41677: LD_ADDR_EXP 119
41681: PUSH
41682: LD_EXP 119
41686: PPUSH
41687: LD_VAR 0 2
41691: PPUSH
41692: EMPTY
41693: PPUSH
41694: CALL_OW 1
41698: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41699: LD_ADDR_EXP 120
41703: PUSH
41704: LD_EXP 120
41708: PPUSH
41709: LD_VAR 0 2
41713: PPUSH
41714: EMPTY
41715: PPUSH
41716: CALL_OW 1
41720: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41721: LD_ADDR_EXP 121
41725: PUSH
41726: LD_EXP 121
41730: PPUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: EMPTY
41737: PPUSH
41738: CALL_OW 1
41742: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41743: LD_ADDR_EXP 122
41747: PUSH
41748: LD_EXP 122
41752: PPUSH
41753: LD_VAR 0 2
41757: PPUSH
41758: EMPTY
41759: PPUSH
41760: CALL_OW 1
41764: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41765: LD_ADDR_EXP 123
41769: PUSH
41770: LD_EXP 123
41774: PPUSH
41775: LD_VAR 0 2
41779: PPUSH
41780: EMPTY
41781: PPUSH
41782: CALL_OW 1
41786: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41787: LD_ADDR_EXP 124
41791: PUSH
41792: LD_EXP 124
41796: PPUSH
41797: LD_VAR 0 2
41801: PPUSH
41802: EMPTY
41803: PPUSH
41804: CALL_OW 1
41808: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41809: LD_ADDR_EXP 113
41813: PUSH
41814: LD_EXP 113
41818: PPUSH
41819: LD_VAR 0 2
41823: PPUSH
41824: LD_INT 0
41826: PPUSH
41827: CALL_OW 1
41831: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41832: LD_ADDR_EXP 126
41836: PUSH
41837: LD_EXP 126
41841: PPUSH
41842: LD_VAR 0 2
41846: PPUSH
41847: LD_INT 0
41849: PPUSH
41850: CALL_OW 1
41854: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41855: LD_ADDR_EXP 114
41859: PUSH
41860: LD_EXP 114
41864: PPUSH
41865: LD_VAR 0 2
41869: PPUSH
41870: EMPTY
41871: PPUSH
41872: CALL_OW 1
41876: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41877: LD_ADDR_EXP 125
41881: PUSH
41882: LD_EXP 125
41886: PPUSH
41887: LD_VAR 0 2
41891: PPUSH
41892: LD_INT 0
41894: PPUSH
41895: CALL_OW 1
41899: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41900: LD_ADDR_EXP 127
41904: PUSH
41905: LD_EXP 127
41909: PPUSH
41910: LD_VAR 0 2
41914: PPUSH
41915: EMPTY
41916: PPUSH
41917: CALL_OW 1
41921: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41922: LD_ADDR_EXP 130
41926: PUSH
41927: LD_EXP 130
41931: PPUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: LD_INT 0
41939: PPUSH
41940: CALL_OW 1
41944: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41945: LD_ADDR_EXP 131
41949: PUSH
41950: LD_EXP 131
41954: PPUSH
41955: LD_VAR 0 2
41959: PPUSH
41960: EMPTY
41961: PPUSH
41962: CALL_OW 1
41966: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41967: LD_ADDR_EXP 132
41971: PUSH
41972: LD_EXP 132
41976: PPUSH
41977: LD_VAR 0 2
41981: PPUSH
41982: EMPTY
41983: PPUSH
41984: CALL_OW 1
41988: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41989: LD_ADDR_EXP 133
41993: PUSH
41994: LD_EXP 133
41998: PPUSH
41999: LD_VAR 0 2
42003: PPUSH
42004: EMPTY
42005: PPUSH
42006: CALL_OW 1
42010: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42011: LD_ADDR_EXP 135
42015: PUSH
42016: LD_EXP 135
42020: PPUSH
42021: LD_VAR 0 2
42025: PPUSH
42026: LD_EXP 102
42030: PUSH
42031: LD_VAR 0 2
42035: ARRAY
42036: PPUSH
42037: LD_INT 2
42039: PUSH
42040: LD_INT 30
42042: PUSH
42043: LD_INT 6
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 30
42052: PUSH
42053: LD_INT 7
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 30
42062: PUSH
42063: LD_INT 8
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: PPUSH
42076: CALL_OW 72
42080: PPUSH
42081: CALL_OW 1
42085: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42086: LD_ADDR_EXP 136
42090: PUSH
42091: LD_EXP 136
42095: PPUSH
42096: LD_VAR 0 2
42100: PPUSH
42101: EMPTY
42102: PPUSH
42103: CALL_OW 1
42107: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42108: LD_ADDR_EXP 137
42112: PUSH
42113: LD_EXP 137
42117: PPUSH
42118: LD_VAR 0 2
42122: PPUSH
42123: EMPTY
42124: PPUSH
42125: CALL_OW 1
42129: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42130: LD_ADDR_EXP 138
42134: PUSH
42135: LD_EXP 138
42139: PPUSH
42140: LD_VAR 0 2
42144: PPUSH
42145: EMPTY
42146: PPUSH
42147: CALL_OW 1
42151: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42152: LD_ADDR_EXP 139
42156: PUSH
42157: LD_EXP 139
42161: PPUSH
42162: LD_VAR 0 2
42166: PPUSH
42167: EMPTY
42168: PPUSH
42169: CALL_OW 1
42173: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42174: LD_ADDR_EXP 140
42178: PUSH
42179: LD_EXP 140
42183: PPUSH
42184: LD_VAR 0 2
42188: PPUSH
42189: EMPTY
42190: PPUSH
42191: CALL_OW 1
42195: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42196: LD_ADDR_EXP 141
42200: PUSH
42201: LD_EXP 141
42205: PPUSH
42206: LD_VAR 0 2
42210: PPUSH
42211: EMPTY
42212: PPUSH
42213: CALL_OW 1
42217: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42218: LD_ADDR_EXP 142
42222: PUSH
42223: LD_EXP 142
42227: PPUSH
42228: LD_VAR 0 2
42232: PPUSH
42233: EMPTY
42234: PPUSH
42235: CALL_OW 1
42239: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42240: LD_ADDR_EXP 143
42244: PUSH
42245: LD_EXP 143
42249: PPUSH
42250: LD_VAR 0 2
42254: PPUSH
42255: EMPTY
42256: PPUSH
42257: CALL_OW 1
42261: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42262: LD_ADDR_EXP 144
42266: PUSH
42267: LD_EXP 144
42271: PPUSH
42272: LD_VAR 0 2
42276: PPUSH
42277: LD_INT 0
42279: PPUSH
42280: CALL_OW 1
42284: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42285: LD_ADDR_EXP 145
42289: PUSH
42290: LD_EXP 145
42294: PPUSH
42295: LD_VAR 0 2
42299: PPUSH
42300: LD_INT 0
42302: PPUSH
42303: CALL_OW 1
42307: ST_TO_ADDR
// end ;
42308: GO 41209
42310: POP
42311: POP
// MC_InitSides ( ) ;
42312: CALL 42598 0 0
// MC_InitResearch ( ) ;
42316: CALL 42337 0 0
// CustomInitMacro ( ) ;
42320: CALL 475 0 0
// skirmish := true ;
42324: LD_ADDR_EXP 100
42328: PUSH
42329: LD_INT 1
42331: ST_TO_ADDR
// end ;
42332: LD_VAR 0 1
42336: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42337: LD_INT 0
42339: PPUSH
42340: PPUSH
42341: PPUSH
42342: PPUSH
42343: PPUSH
42344: PPUSH
// if not mc_bases then
42345: LD_EXP 102
42349: NOT
42350: IFFALSE 42354
// exit ;
42352: GO 42593
// for i = 1 to 8 do
42354: LD_ADDR_VAR 0 2
42358: PUSH
42359: DOUBLE
42360: LD_INT 1
42362: DEC
42363: ST_TO_ADDR
42364: LD_INT 8
42366: PUSH
42367: FOR_TO
42368: IFFALSE 42394
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42370: LD_ADDR_EXP 129
42374: PUSH
42375: LD_EXP 129
42379: PPUSH
42380: LD_VAR 0 2
42384: PPUSH
42385: EMPTY
42386: PPUSH
42387: CALL_OW 1
42391: ST_TO_ADDR
42392: GO 42367
42394: POP
42395: POP
// tmp := [ ] ;
42396: LD_ADDR_VAR 0 5
42400: PUSH
42401: EMPTY
42402: ST_TO_ADDR
// for i = 1 to mc_sides do
42403: LD_ADDR_VAR 0 2
42407: PUSH
42408: DOUBLE
42409: LD_INT 1
42411: DEC
42412: ST_TO_ADDR
42413: LD_EXP 128
42417: PUSH
42418: FOR_TO
42419: IFFALSE 42477
// if not mc_sides [ i ] in tmp then
42421: LD_EXP 128
42425: PUSH
42426: LD_VAR 0 2
42430: ARRAY
42431: PUSH
42432: LD_VAR 0 5
42436: IN
42437: NOT
42438: IFFALSE 42475
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42440: LD_ADDR_VAR 0 5
42444: PUSH
42445: LD_VAR 0 5
42449: PPUSH
42450: LD_VAR 0 5
42454: PUSH
42455: LD_INT 1
42457: PLUS
42458: PPUSH
42459: LD_EXP 128
42463: PUSH
42464: LD_VAR 0 2
42468: ARRAY
42469: PPUSH
42470: CALL_OW 2
42474: ST_TO_ADDR
42475: GO 42418
42477: POP
42478: POP
// if not tmp then
42479: LD_VAR 0 5
42483: NOT
42484: IFFALSE 42488
// exit ;
42486: GO 42593
// for j in tmp do
42488: LD_ADDR_VAR 0 3
42492: PUSH
42493: LD_VAR 0 5
42497: PUSH
42498: FOR_IN
42499: IFFALSE 42591
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42501: LD_ADDR_VAR 0 6
42505: PUSH
42506: LD_INT 22
42508: PUSH
42509: LD_VAR 0 3
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PPUSH
42518: CALL_OW 69
42522: ST_TO_ADDR
// if not un then
42523: LD_VAR 0 6
42527: NOT
42528: IFFALSE 42532
// continue ;
42530: GO 42498
// nation := GetNation ( un [ 1 ] ) ;
42532: LD_ADDR_VAR 0 4
42536: PUSH
42537: LD_VAR 0 6
42541: PUSH
42542: LD_INT 1
42544: ARRAY
42545: PPUSH
42546: CALL_OW 248
42550: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42551: LD_ADDR_EXP 129
42555: PUSH
42556: LD_EXP 129
42560: PPUSH
42561: LD_VAR 0 3
42565: PPUSH
42566: LD_VAR 0 3
42570: PPUSH
42571: LD_VAR 0 4
42575: PPUSH
42576: LD_INT 1
42578: PPUSH
42579: CALL 69781 0 3
42583: PPUSH
42584: CALL_OW 1
42588: ST_TO_ADDR
// end ;
42589: GO 42498
42591: POP
42592: POP
// end ;
42593: LD_VAR 0 1
42597: RET
// export function MC_InitSides ( ) ; var i ; begin
42598: LD_INT 0
42600: PPUSH
42601: PPUSH
// if not mc_bases then
42602: LD_EXP 102
42606: NOT
42607: IFFALSE 42611
// exit ;
42609: GO 42685
// for i = 1 to mc_bases do
42611: LD_ADDR_VAR 0 2
42615: PUSH
42616: DOUBLE
42617: LD_INT 1
42619: DEC
42620: ST_TO_ADDR
42621: LD_EXP 102
42625: PUSH
42626: FOR_TO
42627: IFFALSE 42683
// if mc_bases [ i ] then
42629: LD_EXP 102
42633: PUSH
42634: LD_VAR 0 2
42638: ARRAY
42639: IFFALSE 42681
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42641: LD_ADDR_EXP 128
42645: PUSH
42646: LD_EXP 128
42650: PPUSH
42651: LD_VAR 0 2
42655: PPUSH
42656: LD_EXP 102
42660: PUSH
42661: LD_VAR 0 2
42665: ARRAY
42666: PUSH
42667: LD_INT 1
42669: ARRAY
42670: PPUSH
42671: CALL_OW 255
42675: PPUSH
42676: CALL_OW 1
42680: ST_TO_ADDR
42681: GO 42626
42683: POP
42684: POP
// end ;
42685: LD_VAR 0 1
42689: RET
// every 0 0$03 trigger skirmish do
42690: LD_EXP 100
42694: IFFALSE 42848
42696: GO 42698
42698: DISABLE
// begin enable ;
42699: ENABLE
// MC_CheckBuildings ( ) ;
42700: CALL 47360 0 0
// MC_CheckPeopleLife ( ) ;
42704: CALL 47521 0 0
// RaiseSailEvent ( 100 ) ;
42708: LD_INT 100
42710: PPUSH
42711: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42715: LD_INT 103
42717: PPUSH
42718: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42722: LD_INT 104
42724: PPUSH
42725: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42729: LD_INT 105
42731: PPUSH
42732: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42736: LD_INT 106
42738: PPUSH
42739: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42743: LD_INT 107
42745: PPUSH
42746: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42750: LD_INT 108
42752: PPUSH
42753: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42757: LD_INT 109
42759: PPUSH
42760: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42764: LD_INT 110
42766: PPUSH
42767: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42771: LD_INT 111
42773: PPUSH
42774: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42778: LD_INT 112
42780: PPUSH
42781: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42785: LD_INT 113
42787: PPUSH
42788: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42792: LD_INT 120
42794: PPUSH
42795: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42799: LD_INT 121
42801: PPUSH
42802: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42806: LD_INT 122
42808: PPUSH
42809: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42813: LD_INT 123
42815: PPUSH
42816: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42820: LD_INT 124
42822: PPUSH
42823: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42827: LD_INT 125
42829: PPUSH
42830: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42834: LD_INT 126
42836: PPUSH
42837: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42841: LD_INT 200
42843: PPUSH
42844: CALL_OW 427
// end ;
42848: END
// on SailEvent ( event ) do begin if event < 100 then
42849: LD_VAR 0 1
42853: PUSH
42854: LD_INT 100
42856: LESS
42857: IFFALSE 42868
// CustomEvent ( event ) ;
42859: LD_VAR 0 1
42863: PPUSH
42864: CALL 37224 0 1
// if event = 100 then
42868: LD_VAR 0 1
42872: PUSH
42873: LD_INT 100
42875: EQUAL
42876: IFFALSE 42882
// MC_ClassManager ( ) ;
42878: CALL 43274 0 0
// if event = 101 then
42882: LD_VAR 0 1
42886: PUSH
42887: LD_INT 101
42889: EQUAL
42890: IFFALSE 42896
// MC_RepairBuildings ( ) ;
42892: CALL 48106 0 0
// if event = 102 then
42896: LD_VAR 0 1
42900: PUSH
42901: LD_INT 102
42903: EQUAL
42904: IFFALSE 42910
// MC_Heal ( ) ;
42906: CALL 49041 0 0
// if event = 103 then
42910: LD_VAR 0 1
42914: PUSH
42915: LD_INT 103
42917: EQUAL
42918: IFFALSE 42924
// MC_Build ( ) ;
42920: CALL 49463 0 0
// if event = 104 then
42924: LD_VAR 0 1
42928: PUSH
42929: LD_INT 104
42931: EQUAL
42932: IFFALSE 42938
// MC_TurretWeapon ( ) ;
42934: CALL 51097 0 0
// if event = 105 then
42938: LD_VAR 0 1
42942: PUSH
42943: LD_INT 105
42945: EQUAL
42946: IFFALSE 42952
// MC_BuildUpgrade ( ) ;
42948: CALL 50648 0 0
// if event = 106 then
42952: LD_VAR 0 1
42956: PUSH
42957: LD_INT 106
42959: EQUAL
42960: IFFALSE 42966
// MC_PlantMines ( ) ;
42962: CALL 51527 0 0
// if event = 107 then
42966: LD_VAR 0 1
42970: PUSH
42971: LD_INT 107
42973: EQUAL
42974: IFFALSE 42980
// MC_CollectCrates ( ) ;
42976: CALL 52325 0 0
// if event = 108 then
42980: LD_VAR 0 1
42984: PUSH
42985: LD_INT 108
42987: EQUAL
42988: IFFALSE 42994
// MC_LinkRemoteControl ( ) ;
42990: CALL 54175 0 0
// if event = 109 then
42994: LD_VAR 0 1
42998: PUSH
42999: LD_INT 109
43001: EQUAL
43002: IFFALSE 43008
// MC_ProduceVehicle ( ) ;
43004: CALL 54356 0 0
// if event = 110 then
43008: LD_VAR 0 1
43012: PUSH
43013: LD_INT 110
43015: EQUAL
43016: IFFALSE 43022
// MC_SendAttack ( ) ;
43018: CALL 54822 0 0
// if event = 111 then
43022: LD_VAR 0 1
43026: PUSH
43027: LD_INT 111
43029: EQUAL
43030: IFFALSE 43036
// MC_Defend ( ) ;
43032: CALL 54930 0 0
// if event = 112 then
43036: LD_VAR 0 1
43040: PUSH
43041: LD_INT 112
43043: EQUAL
43044: IFFALSE 43050
// MC_Research ( ) ;
43046: CALL 55810 0 0
// if event = 113 then
43050: LD_VAR 0 1
43054: PUSH
43055: LD_INT 113
43057: EQUAL
43058: IFFALSE 43064
// MC_MinesTrigger ( ) ;
43060: CALL 56924 0 0
// if event = 120 then
43064: LD_VAR 0 1
43068: PUSH
43069: LD_INT 120
43071: EQUAL
43072: IFFALSE 43078
// MC_RepairVehicle ( ) ;
43074: CALL 57023 0 0
// if event = 121 then
43078: LD_VAR 0 1
43082: PUSH
43083: LD_INT 121
43085: EQUAL
43086: IFFALSE 43092
// MC_TameApe ( ) ;
43088: CALL 57792 0 0
// if event = 122 then
43092: LD_VAR 0 1
43096: PUSH
43097: LD_INT 122
43099: EQUAL
43100: IFFALSE 43106
// MC_ChangeApeClass ( ) ;
43102: CALL 58621 0 0
// if event = 123 then
43106: LD_VAR 0 1
43110: PUSH
43111: LD_INT 123
43113: EQUAL
43114: IFFALSE 43120
// MC_Bazooka ( ) ;
43116: CALL 59271 0 0
// if event = 124 then
43120: LD_VAR 0 1
43124: PUSH
43125: LD_INT 124
43127: EQUAL
43128: IFFALSE 43134
// MC_TeleportExit ( ) ;
43130: CALL 59469 0 0
// if event = 125 then
43134: LD_VAR 0 1
43138: PUSH
43139: LD_INT 125
43141: EQUAL
43142: IFFALSE 43148
// MC_Deposits ( ) ;
43144: CALL 60116 0 0
// if event = 126 then
43148: LD_VAR 0 1
43152: PUSH
43153: LD_INT 126
43155: EQUAL
43156: IFFALSE 43162
// MC_RemoteDriver ( ) ;
43158: CALL 60741 0 0
// if event = 200 then
43162: LD_VAR 0 1
43166: PUSH
43167: LD_INT 200
43169: EQUAL
43170: IFFALSE 43176
// MC_Idle ( ) ;
43172: CALL 62648 0 0
// end ;
43176: PPOPN 1
43178: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43179: LD_INT 0
43181: PPUSH
43182: PPUSH
// if not mc_bases [ base ] or not tag then
43183: LD_EXP 102
43187: PUSH
43188: LD_VAR 0 1
43192: ARRAY
43193: NOT
43194: PUSH
43195: LD_VAR 0 2
43199: NOT
43200: OR
43201: IFFALSE 43205
// exit ;
43203: GO 43269
// for i in mc_bases [ base ] union mc_ape [ base ] do
43205: LD_ADDR_VAR 0 4
43209: PUSH
43210: LD_EXP 102
43214: PUSH
43215: LD_VAR 0 1
43219: ARRAY
43220: PUSH
43221: LD_EXP 131
43225: PUSH
43226: LD_VAR 0 1
43230: ARRAY
43231: UNION
43232: PUSH
43233: FOR_IN
43234: IFFALSE 43267
// if GetTag ( i ) = tag then
43236: LD_VAR 0 4
43240: PPUSH
43241: CALL_OW 110
43245: PUSH
43246: LD_VAR 0 2
43250: EQUAL
43251: IFFALSE 43265
// SetTag ( i , 0 ) ;
43253: LD_VAR 0 4
43257: PPUSH
43258: LD_INT 0
43260: PPUSH
43261: CALL_OW 109
43265: GO 43233
43267: POP
43268: POP
// end ;
43269: LD_VAR 0 3
43273: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43274: LD_INT 0
43276: PPUSH
43277: PPUSH
43278: PPUSH
43279: PPUSH
43280: PPUSH
43281: PPUSH
43282: PPUSH
43283: PPUSH
// if not mc_bases then
43284: LD_EXP 102
43288: NOT
43289: IFFALSE 43293
// exit ;
43291: GO 43742
// for i = 1 to mc_bases do
43293: LD_ADDR_VAR 0 2
43297: PUSH
43298: DOUBLE
43299: LD_INT 1
43301: DEC
43302: ST_TO_ADDR
43303: LD_EXP 102
43307: PUSH
43308: FOR_TO
43309: IFFALSE 43740
// begin tmp := MC_ClassCheckReq ( i ) ;
43311: LD_ADDR_VAR 0 4
43315: PUSH
43316: LD_VAR 0 2
43320: PPUSH
43321: CALL 43747 0 1
43325: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43326: LD_ADDR_EXP 143
43330: PUSH
43331: LD_EXP 143
43335: PPUSH
43336: LD_VAR 0 2
43340: PPUSH
43341: LD_VAR 0 4
43345: PPUSH
43346: CALL_OW 1
43350: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43351: LD_ADDR_VAR 0 6
43355: PUSH
43356: LD_EXP 102
43360: PUSH
43361: LD_VAR 0 2
43365: ARRAY
43366: PPUSH
43367: LD_INT 2
43369: PUSH
43370: LD_INT 30
43372: PUSH
43373: LD_INT 4
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 30
43382: PUSH
43383: LD_INT 5
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: LIST
43394: PPUSH
43395: CALL_OW 72
43399: PUSH
43400: LD_EXP 102
43404: PUSH
43405: LD_VAR 0 2
43409: ARRAY
43410: PPUSH
43411: LD_INT 2
43413: PUSH
43414: LD_INT 30
43416: PUSH
43417: LD_INT 0
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 30
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: LIST
43438: PPUSH
43439: CALL_OW 72
43443: PUSH
43444: LD_EXP 102
43448: PUSH
43449: LD_VAR 0 2
43453: ARRAY
43454: PPUSH
43455: LD_INT 30
43457: PUSH
43458: LD_INT 3
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PPUSH
43465: CALL_OW 72
43469: PUSH
43470: LD_EXP 102
43474: PUSH
43475: LD_VAR 0 2
43479: ARRAY
43480: PPUSH
43481: LD_INT 2
43483: PUSH
43484: LD_INT 30
43486: PUSH
43487: LD_INT 6
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 30
43496: PUSH
43497: LD_INT 7
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 30
43506: PUSH
43507: LD_INT 8
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: PPUSH
43520: CALL_OW 72
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: ST_TO_ADDR
// for j := 1 to 4 do
43531: LD_ADDR_VAR 0 3
43535: PUSH
43536: DOUBLE
43537: LD_INT 1
43539: DEC
43540: ST_TO_ADDR
43541: LD_INT 4
43543: PUSH
43544: FOR_TO
43545: IFFALSE 43736
// begin if not tmp [ j ] then
43547: LD_VAR 0 4
43551: PUSH
43552: LD_VAR 0 3
43556: ARRAY
43557: NOT
43558: IFFALSE 43562
// continue ;
43560: GO 43544
// for p in tmp [ j ] do
43562: LD_ADDR_VAR 0 5
43566: PUSH
43567: LD_VAR 0 4
43571: PUSH
43572: LD_VAR 0 3
43576: ARRAY
43577: PUSH
43578: FOR_IN
43579: IFFALSE 43732
// begin if not b [ j ] then
43581: LD_VAR 0 6
43585: PUSH
43586: LD_VAR 0 3
43590: ARRAY
43591: NOT
43592: IFFALSE 43596
// break ;
43594: GO 43732
// e := 0 ;
43596: LD_ADDR_VAR 0 7
43600: PUSH
43601: LD_INT 0
43603: ST_TO_ADDR
// for k in b [ j ] do
43604: LD_ADDR_VAR 0 8
43608: PUSH
43609: LD_VAR 0 6
43613: PUSH
43614: LD_VAR 0 3
43618: ARRAY
43619: PUSH
43620: FOR_IN
43621: IFFALSE 43648
// if IsNotFull ( k ) then
43623: LD_VAR 0 8
43627: PPUSH
43628: CALL 71902 0 1
43632: IFFALSE 43646
// begin e := k ;
43634: LD_ADDR_VAR 0 7
43638: PUSH
43639: LD_VAR 0 8
43643: ST_TO_ADDR
// break ;
43644: GO 43648
// end ;
43646: GO 43620
43648: POP
43649: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43650: LD_VAR 0 7
43654: PUSH
43655: LD_VAR 0 5
43659: PPUSH
43660: LD_VAR 0 7
43664: PPUSH
43665: CALL 106041 0 2
43669: NOT
43670: AND
43671: IFFALSE 43730
// begin if IsInUnit ( p ) then
43673: LD_VAR 0 5
43677: PPUSH
43678: CALL_OW 310
43682: IFFALSE 43693
// ComExitBuilding ( p ) ;
43684: LD_VAR 0 5
43688: PPUSH
43689: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43693: LD_VAR 0 5
43697: PPUSH
43698: LD_VAR 0 7
43702: PPUSH
43703: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43707: LD_VAR 0 5
43711: PPUSH
43712: LD_VAR 0 3
43716: PPUSH
43717: CALL_OW 183
// AddComExitBuilding ( p ) ;
43721: LD_VAR 0 5
43725: PPUSH
43726: CALL_OW 182
// end ; end ;
43730: GO 43578
43732: POP
43733: POP
// end ;
43734: GO 43544
43736: POP
43737: POP
// end ;
43738: GO 43308
43740: POP
43741: POP
// end ;
43742: LD_VAR 0 1
43746: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43747: LD_INT 0
43749: PPUSH
43750: PPUSH
43751: PPUSH
43752: PPUSH
43753: PPUSH
43754: PPUSH
43755: PPUSH
43756: PPUSH
43757: PPUSH
43758: PPUSH
43759: PPUSH
43760: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43761: LD_ADDR_VAR 0 2
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: LD_INT 0
43771: PUSH
43772: LD_INT 0
43774: PUSH
43775: LD_INT 0
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43784: LD_VAR 0 1
43788: NOT
43789: PUSH
43790: LD_EXP 102
43794: PUSH
43795: LD_VAR 0 1
43799: ARRAY
43800: NOT
43801: OR
43802: PUSH
43803: LD_EXP 102
43807: PUSH
43808: LD_VAR 0 1
43812: ARRAY
43813: PPUSH
43814: LD_INT 2
43816: PUSH
43817: LD_INT 30
43819: PUSH
43820: LD_INT 0
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 30
43829: PUSH
43830: LD_INT 1
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: LIST
43841: PPUSH
43842: CALL_OW 72
43846: NOT
43847: OR
43848: IFFALSE 43852
// exit ;
43850: GO 47355
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43852: LD_ADDR_VAR 0 4
43856: PUSH
43857: LD_EXP 102
43861: PUSH
43862: LD_VAR 0 1
43866: ARRAY
43867: PPUSH
43868: LD_INT 2
43870: PUSH
43871: LD_INT 25
43873: PUSH
43874: LD_INT 1
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 25
43883: PUSH
43884: LD_INT 2
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 25
43893: PUSH
43894: LD_INT 3
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 25
43903: PUSH
43904: LD_INT 4
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 25
43913: PUSH
43914: LD_INT 5
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 25
43923: PUSH
43924: LD_INT 8
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 25
43933: PUSH
43934: LD_INT 9
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: PPUSH
43951: CALL_OW 72
43955: ST_TO_ADDR
// if not tmp then
43956: LD_VAR 0 4
43960: NOT
43961: IFFALSE 43965
// exit ;
43963: GO 47355
// for i in tmp do
43965: LD_ADDR_VAR 0 3
43969: PUSH
43970: LD_VAR 0 4
43974: PUSH
43975: FOR_IN
43976: IFFALSE 44007
// if GetTag ( i ) then
43978: LD_VAR 0 3
43982: PPUSH
43983: CALL_OW 110
43987: IFFALSE 44005
// tmp := tmp diff i ;
43989: LD_ADDR_VAR 0 4
43993: PUSH
43994: LD_VAR 0 4
43998: PUSH
43999: LD_VAR 0 3
44003: DIFF
44004: ST_TO_ADDR
44005: GO 43975
44007: POP
44008: POP
// if not tmp then
44009: LD_VAR 0 4
44013: NOT
44014: IFFALSE 44018
// exit ;
44016: GO 47355
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44018: LD_ADDR_VAR 0 5
44022: PUSH
44023: LD_EXP 102
44027: PUSH
44028: LD_VAR 0 1
44032: ARRAY
44033: PPUSH
44034: LD_INT 2
44036: PUSH
44037: LD_INT 25
44039: PUSH
44040: LD_INT 1
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 25
44049: PUSH
44050: LD_INT 5
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 25
44059: PUSH
44060: LD_INT 8
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 25
44069: PUSH
44070: LD_INT 9
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: PPUSH
44084: CALL_OW 72
44088: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44089: LD_ADDR_VAR 0 6
44093: PUSH
44094: LD_EXP 102
44098: PUSH
44099: LD_VAR 0 1
44103: ARRAY
44104: PPUSH
44105: LD_INT 25
44107: PUSH
44108: LD_INT 2
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PPUSH
44115: CALL_OW 72
44119: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44120: LD_ADDR_VAR 0 7
44124: PUSH
44125: LD_EXP 102
44129: PUSH
44130: LD_VAR 0 1
44134: ARRAY
44135: PPUSH
44136: LD_INT 25
44138: PUSH
44139: LD_INT 3
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PPUSH
44146: CALL_OW 72
44150: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44151: LD_ADDR_VAR 0 8
44155: PUSH
44156: LD_EXP 102
44160: PUSH
44161: LD_VAR 0 1
44165: ARRAY
44166: PPUSH
44167: LD_INT 25
44169: PUSH
44170: LD_INT 4
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 24
44179: PUSH
44180: LD_INT 251
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PPUSH
44191: CALL_OW 72
44195: ST_TO_ADDR
// if mc_is_defending [ base ] then
44196: LD_EXP 145
44200: PUSH
44201: LD_VAR 0 1
44205: ARRAY
44206: IFFALSE 44667
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44208: LD_ADDR_EXP 144
44212: PUSH
44213: LD_EXP 144
44217: PPUSH
44218: LD_VAR 0 1
44222: PPUSH
44223: LD_INT 4
44225: PPUSH
44226: CALL_OW 1
44230: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44231: LD_ADDR_VAR 0 12
44235: PUSH
44236: LD_EXP 102
44240: PUSH
44241: LD_VAR 0 1
44245: ARRAY
44246: PPUSH
44247: LD_INT 2
44249: PUSH
44250: LD_INT 30
44252: PUSH
44253: LD_INT 4
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 30
44262: PUSH
44263: LD_INT 5
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: PPUSH
44275: CALL_OW 72
44279: ST_TO_ADDR
// if not b then
44280: LD_VAR 0 12
44284: NOT
44285: IFFALSE 44289
// exit ;
44287: GO 47355
// p := [ ] ;
44289: LD_ADDR_VAR 0 11
44293: PUSH
44294: EMPTY
44295: ST_TO_ADDR
// if sci >= 2 then
44296: LD_VAR 0 8
44300: PUSH
44301: LD_INT 2
44303: GREATEREQUAL
44304: IFFALSE 44335
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44306: LD_ADDR_VAR 0 8
44310: PUSH
44311: LD_VAR 0 8
44315: PUSH
44316: LD_INT 1
44318: ARRAY
44319: PUSH
44320: LD_VAR 0 8
44324: PUSH
44325: LD_INT 2
44327: ARRAY
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: ST_TO_ADDR
44333: GO 44396
// if sci = 1 then
44335: LD_VAR 0 8
44339: PUSH
44340: LD_INT 1
44342: EQUAL
44343: IFFALSE 44364
// sci := [ sci [ 1 ] ] else
44345: LD_ADDR_VAR 0 8
44349: PUSH
44350: LD_VAR 0 8
44354: PUSH
44355: LD_INT 1
44357: ARRAY
44358: PUSH
44359: EMPTY
44360: LIST
44361: ST_TO_ADDR
44362: GO 44396
// if sci = 0 then
44364: LD_VAR 0 8
44368: PUSH
44369: LD_INT 0
44371: EQUAL
44372: IFFALSE 44396
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44374: LD_ADDR_VAR 0 11
44378: PUSH
44379: LD_VAR 0 4
44383: PPUSH
44384: LD_INT 4
44386: PPUSH
44387: CALL 105913 0 2
44391: PUSH
44392: LD_INT 1
44394: ARRAY
44395: ST_TO_ADDR
// if eng > 4 then
44396: LD_VAR 0 6
44400: PUSH
44401: LD_INT 4
44403: GREATER
44404: IFFALSE 44450
// for i = eng downto 4 do
44406: LD_ADDR_VAR 0 3
44410: PUSH
44411: DOUBLE
44412: LD_VAR 0 6
44416: INC
44417: ST_TO_ADDR
44418: LD_INT 4
44420: PUSH
44421: FOR_DOWNTO
44422: IFFALSE 44448
// eng := eng diff eng [ i ] ;
44424: LD_ADDR_VAR 0 6
44428: PUSH
44429: LD_VAR 0 6
44433: PUSH
44434: LD_VAR 0 6
44438: PUSH
44439: LD_VAR 0 3
44443: ARRAY
44444: DIFF
44445: ST_TO_ADDR
44446: GO 44421
44448: POP
44449: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44450: LD_ADDR_VAR 0 4
44454: PUSH
44455: LD_VAR 0 4
44459: PUSH
44460: LD_VAR 0 5
44464: PUSH
44465: LD_VAR 0 6
44469: UNION
44470: PUSH
44471: LD_VAR 0 7
44475: UNION
44476: PUSH
44477: LD_VAR 0 8
44481: UNION
44482: DIFF
44483: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44484: LD_ADDR_VAR 0 13
44488: PUSH
44489: LD_EXP 102
44493: PUSH
44494: LD_VAR 0 1
44498: ARRAY
44499: PPUSH
44500: LD_INT 2
44502: PUSH
44503: LD_INT 30
44505: PUSH
44506: LD_INT 32
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 30
44515: PUSH
44516: LD_INT 31
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: LIST
44527: PPUSH
44528: CALL_OW 72
44532: PUSH
44533: LD_EXP 102
44537: PUSH
44538: LD_VAR 0 1
44542: ARRAY
44543: PPUSH
44544: LD_INT 2
44546: PUSH
44547: LD_INT 30
44549: PUSH
44550: LD_INT 4
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 30
44559: PUSH
44560: LD_INT 5
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: LIST
44571: PPUSH
44572: CALL_OW 72
44576: PUSH
44577: LD_INT 6
44579: MUL
44580: PLUS
44581: ST_TO_ADDR
// if bcount < tmp then
44582: LD_VAR 0 13
44586: PUSH
44587: LD_VAR 0 4
44591: LESS
44592: IFFALSE 44638
// for i = tmp downto bcount do
44594: LD_ADDR_VAR 0 3
44598: PUSH
44599: DOUBLE
44600: LD_VAR 0 4
44604: INC
44605: ST_TO_ADDR
44606: LD_VAR 0 13
44610: PUSH
44611: FOR_DOWNTO
44612: IFFALSE 44636
// tmp := Delete ( tmp , tmp ) ;
44614: LD_ADDR_VAR 0 4
44618: PUSH
44619: LD_VAR 0 4
44623: PPUSH
44624: LD_VAR 0 4
44628: PPUSH
44629: CALL_OW 3
44633: ST_TO_ADDR
44634: GO 44611
44636: POP
44637: POP
// result := [ tmp , 0 , 0 , p ] ;
44638: LD_ADDR_VAR 0 2
44642: PUSH
44643: LD_VAR 0 4
44647: PUSH
44648: LD_INT 0
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_VAR 0 11
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: ST_TO_ADDR
// exit ;
44665: GO 47355
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44667: LD_EXP 102
44671: PUSH
44672: LD_VAR 0 1
44676: ARRAY
44677: PPUSH
44678: LD_INT 2
44680: PUSH
44681: LD_INT 30
44683: PUSH
44684: LD_INT 6
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 30
44693: PUSH
44694: LD_INT 7
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 30
44703: PUSH
44704: LD_INT 8
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: PPUSH
44717: CALL_OW 72
44721: NOT
44722: PUSH
44723: LD_EXP 102
44727: PUSH
44728: LD_VAR 0 1
44732: ARRAY
44733: PPUSH
44734: LD_INT 30
44736: PUSH
44737: LD_INT 3
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PPUSH
44744: CALL_OW 72
44748: NOT
44749: AND
44750: IFFALSE 44822
// begin if eng = tmp then
44752: LD_VAR 0 6
44756: PUSH
44757: LD_VAR 0 4
44761: EQUAL
44762: IFFALSE 44766
// exit ;
44764: GO 47355
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44766: LD_ADDR_EXP 144
44770: PUSH
44771: LD_EXP 144
44775: PPUSH
44776: LD_VAR 0 1
44780: PPUSH
44781: LD_INT 1
44783: PPUSH
44784: CALL_OW 1
44788: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44789: LD_ADDR_VAR 0 2
44793: PUSH
44794: LD_INT 0
44796: PUSH
44797: LD_VAR 0 4
44801: PUSH
44802: LD_VAR 0 6
44806: DIFF
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: LD_INT 0
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: ST_TO_ADDR
// exit ;
44820: GO 47355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44822: LD_EXP 129
44826: PUSH
44827: LD_EXP 128
44831: PUSH
44832: LD_VAR 0 1
44836: ARRAY
44837: ARRAY
44838: PUSH
44839: LD_EXP 102
44843: PUSH
44844: LD_VAR 0 1
44848: ARRAY
44849: PPUSH
44850: LD_INT 2
44852: PUSH
44853: LD_INT 30
44855: PUSH
44856: LD_INT 6
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 30
44865: PUSH
44866: LD_INT 7
44868: PUSH
44869: EMPTY
44870: LIST
44871: LIST
44872: PUSH
44873: LD_INT 30
44875: PUSH
44876: LD_INT 8
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: PPUSH
44889: CALL_OW 72
44893: AND
44894: PUSH
44895: LD_EXP 102
44899: PUSH
44900: LD_VAR 0 1
44904: ARRAY
44905: PPUSH
44906: LD_INT 30
44908: PUSH
44909: LD_INT 3
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: PPUSH
44916: CALL_OW 72
44920: NOT
44921: AND
44922: IFFALSE 45136
// begin if sci >= 6 then
44924: LD_VAR 0 8
44928: PUSH
44929: LD_INT 6
44931: GREATEREQUAL
44932: IFFALSE 44936
// exit ;
44934: GO 47355
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44936: LD_ADDR_EXP 144
44940: PUSH
44941: LD_EXP 144
44945: PPUSH
44946: LD_VAR 0 1
44950: PPUSH
44951: LD_INT 2
44953: PPUSH
44954: CALL_OW 1
44958: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44959: LD_ADDR_VAR 0 9
44963: PUSH
44964: LD_VAR 0 4
44968: PUSH
44969: LD_VAR 0 8
44973: DIFF
44974: PPUSH
44975: LD_INT 4
44977: PPUSH
44978: CALL 105913 0 2
44982: ST_TO_ADDR
// p := [ ] ;
44983: LD_ADDR_VAR 0 11
44987: PUSH
44988: EMPTY
44989: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44990: LD_VAR 0 8
44994: PUSH
44995: LD_INT 6
44997: LESS
44998: PUSH
44999: LD_VAR 0 9
45003: PUSH
45004: LD_INT 6
45006: GREATER
45007: AND
45008: IFFALSE 45089
// begin for i = 1 to 6 - sci do
45010: LD_ADDR_VAR 0 3
45014: PUSH
45015: DOUBLE
45016: LD_INT 1
45018: DEC
45019: ST_TO_ADDR
45020: LD_INT 6
45022: PUSH
45023: LD_VAR 0 8
45027: MINUS
45028: PUSH
45029: FOR_TO
45030: IFFALSE 45085
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45032: LD_ADDR_VAR 0 11
45036: PUSH
45037: LD_VAR 0 11
45041: PPUSH
45042: LD_VAR 0 11
45046: PUSH
45047: LD_INT 1
45049: PLUS
45050: PPUSH
45051: LD_VAR 0 9
45055: PUSH
45056: LD_INT 1
45058: ARRAY
45059: PPUSH
45060: CALL_OW 2
45064: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45065: LD_ADDR_VAR 0 9
45069: PUSH
45070: LD_VAR 0 9
45074: PPUSH
45075: LD_INT 1
45077: PPUSH
45078: CALL_OW 3
45082: ST_TO_ADDR
// end ;
45083: GO 45029
45085: POP
45086: POP
// end else
45087: GO 45109
// if sort then
45089: LD_VAR 0 9
45093: IFFALSE 45109
// p := sort [ 1 ] ;
45095: LD_ADDR_VAR 0 11
45099: PUSH
45100: LD_VAR 0 9
45104: PUSH
45105: LD_INT 1
45107: ARRAY
45108: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45109: LD_ADDR_VAR 0 2
45113: PUSH
45114: LD_INT 0
45116: PUSH
45117: LD_INT 0
45119: PUSH
45120: LD_INT 0
45122: PUSH
45123: LD_VAR 0 11
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: ST_TO_ADDR
// exit ;
45134: GO 47355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45136: LD_EXP 129
45140: PUSH
45141: LD_EXP 128
45145: PUSH
45146: LD_VAR 0 1
45150: ARRAY
45151: ARRAY
45152: PUSH
45153: LD_EXP 102
45157: PUSH
45158: LD_VAR 0 1
45162: ARRAY
45163: PPUSH
45164: LD_INT 2
45166: PUSH
45167: LD_INT 30
45169: PUSH
45170: LD_INT 6
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 30
45179: PUSH
45180: LD_INT 7
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 30
45189: PUSH
45190: LD_INT 8
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: PPUSH
45203: CALL_OW 72
45207: AND
45208: PUSH
45209: LD_EXP 102
45213: PUSH
45214: LD_VAR 0 1
45218: ARRAY
45219: PPUSH
45220: LD_INT 30
45222: PUSH
45223: LD_INT 3
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PPUSH
45230: CALL_OW 72
45234: AND
45235: IFFALSE 45969
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45237: LD_ADDR_EXP 144
45241: PUSH
45242: LD_EXP 144
45246: PPUSH
45247: LD_VAR 0 1
45251: PPUSH
45252: LD_INT 3
45254: PPUSH
45255: CALL_OW 1
45259: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45260: LD_ADDR_VAR 0 2
45264: PUSH
45265: LD_INT 0
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 0
45273: PUSH
45274: LD_INT 0
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: ST_TO_ADDR
// if not eng then
45283: LD_VAR 0 6
45287: NOT
45288: IFFALSE 45351
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45290: LD_ADDR_VAR 0 11
45294: PUSH
45295: LD_VAR 0 4
45299: PPUSH
45300: LD_INT 2
45302: PPUSH
45303: CALL 105913 0 2
45307: PUSH
45308: LD_INT 1
45310: ARRAY
45311: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45312: LD_ADDR_VAR 0 2
45316: PUSH
45317: LD_VAR 0 2
45321: PPUSH
45322: LD_INT 2
45324: PPUSH
45325: LD_VAR 0 11
45329: PPUSH
45330: CALL_OW 1
45334: ST_TO_ADDR
// tmp := tmp diff p ;
45335: LD_ADDR_VAR 0 4
45339: PUSH
45340: LD_VAR 0 4
45344: PUSH
45345: LD_VAR 0 11
45349: DIFF
45350: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45351: LD_VAR 0 4
45355: PUSH
45356: LD_VAR 0 8
45360: PUSH
45361: LD_INT 6
45363: LESS
45364: AND
45365: IFFALSE 45553
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45367: LD_ADDR_VAR 0 9
45371: PUSH
45372: LD_VAR 0 4
45376: PUSH
45377: LD_VAR 0 8
45381: PUSH
45382: LD_VAR 0 7
45386: UNION
45387: DIFF
45388: PPUSH
45389: LD_INT 4
45391: PPUSH
45392: CALL 105913 0 2
45396: ST_TO_ADDR
// p := [ ] ;
45397: LD_ADDR_VAR 0 11
45401: PUSH
45402: EMPTY
45403: ST_TO_ADDR
// if sort then
45404: LD_VAR 0 9
45408: IFFALSE 45524
// for i = 1 to 6 - sci do
45410: LD_ADDR_VAR 0 3
45414: PUSH
45415: DOUBLE
45416: LD_INT 1
45418: DEC
45419: ST_TO_ADDR
45420: LD_INT 6
45422: PUSH
45423: LD_VAR 0 8
45427: MINUS
45428: PUSH
45429: FOR_TO
45430: IFFALSE 45522
// begin if i = sort then
45432: LD_VAR 0 3
45436: PUSH
45437: LD_VAR 0 9
45441: EQUAL
45442: IFFALSE 45446
// break ;
45444: GO 45522
// if GetClass ( i ) = 4 then
45446: LD_VAR 0 3
45450: PPUSH
45451: CALL_OW 257
45455: PUSH
45456: LD_INT 4
45458: EQUAL
45459: IFFALSE 45463
// continue ;
45461: GO 45429
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45463: LD_ADDR_VAR 0 11
45467: PUSH
45468: LD_VAR 0 11
45472: PPUSH
45473: LD_VAR 0 11
45477: PUSH
45478: LD_INT 1
45480: PLUS
45481: PPUSH
45482: LD_VAR 0 9
45486: PUSH
45487: LD_VAR 0 3
45491: ARRAY
45492: PPUSH
45493: CALL_OW 2
45497: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45498: LD_ADDR_VAR 0 4
45502: PUSH
45503: LD_VAR 0 4
45507: PUSH
45508: LD_VAR 0 9
45512: PUSH
45513: LD_VAR 0 3
45517: ARRAY
45518: DIFF
45519: ST_TO_ADDR
// end ;
45520: GO 45429
45522: POP
45523: POP
// if p then
45524: LD_VAR 0 11
45528: IFFALSE 45553
// result := Replace ( result , 4 , p ) ;
45530: LD_ADDR_VAR 0 2
45534: PUSH
45535: LD_VAR 0 2
45539: PPUSH
45540: LD_INT 4
45542: PPUSH
45543: LD_VAR 0 11
45547: PPUSH
45548: CALL_OW 1
45552: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45553: LD_VAR 0 4
45557: PUSH
45558: LD_VAR 0 7
45562: PUSH
45563: LD_INT 6
45565: LESS
45566: AND
45567: IFFALSE 45755
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45569: LD_ADDR_VAR 0 9
45573: PUSH
45574: LD_VAR 0 4
45578: PUSH
45579: LD_VAR 0 8
45583: PUSH
45584: LD_VAR 0 7
45588: UNION
45589: DIFF
45590: PPUSH
45591: LD_INT 3
45593: PPUSH
45594: CALL 105913 0 2
45598: ST_TO_ADDR
// p := [ ] ;
45599: LD_ADDR_VAR 0 11
45603: PUSH
45604: EMPTY
45605: ST_TO_ADDR
// if sort then
45606: LD_VAR 0 9
45610: IFFALSE 45726
// for i = 1 to 6 - mech do
45612: LD_ADDR_VAR 0 3
45616: PUSH
45617: DOUBLE
45618: LD_INT 1
45620: DEC
45621: ST_TO_ADDR
45622: LD_INT 6
45624: PUSH
45625: LD_VAR 0 7
45629: MINUS
45630: PUSH
45631: FOR_TO
45632: IFFALSE 45724
// begin if i = sort then
45634: LD_VAR 0 3
45638: PUSH
45639: LD_VAR 0 9
45643: EQUAL
45644: IFFALSE 45648
// break ;
45646: GO 45724
// if GetClass ( i ) = 3 then
45648: LD_VAR 0 3
45652: PPUSH
45653: CALL_OW 257
45657: PUSH
45658: LD_INT 3
45660: EQUAL
45661: IFFALSE 45665
// continue ;
45663: GO 45631
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45665: LD_ADDR_VAR 0 11
45669: PUSH
45670: LD_VAR 0 11
45674: PPUSH
45675: LD_VAR 0 11
45679: PUSH
45680: LD_INT 1
45682: PLUS
45683: PPUSH
45684: LD_VAR 0 9
45688: PUSH
45689: LD_VAR 0 3
45693: ARRAY
45694: PPUSH
45695: CALL_OW 2
45699: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45700: LD_ADDR_VAR 0 4
45704: PUSH
45705: LD_VAR 0 4
45709: PUSH
45710: LD_VAR 0 9
45714: PUSH
45715: LD_VAR 0 3
45719: ARRAY
45720: DIFF
45721: ST_TO_ADDR
// end ;
45722: GO 45631
45724: POP
45725: POP
// if p then
45726: LD_VAR 0 11
45730: IFFALSE 45755
// result := Replace ( result , 3 , p ) ;
45732: LD_ADDR_VAR 0 2
45736: PUSH
45737: LD_VAR 0 2
45741: PPUSH
45742: LD_INT 3
45744: PPUSH
45745: LD_VAR 0 11
45749: PPUSH
45750: CALL_OW 1
45754: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45755: LD_VAR 0 4
45759: PUSH
45760: LD_INT 6
45762: GREATER
45763: PUSH
45764: LD_VAR 0 6
45768: PUSH
45769: LD_INT 6
45771: LESS
45772: AND
45773: IFFALSE 45967
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45775: LD_ADDR_VAR 0 9
45779: PUSH
45780: LD_VAR 0 4
45784: PUSH
45785: LD_VAR 0 8
45789: PUSH
45790: LD_VAR 0 7
45794: UNION
45795: PUSH
45796: LD_VAR 0 6
45800: UNION
45801: DIFF
45802: PPUSH
45803: LD_INT 2
45805: PPUSH
45806: CALL 105913 0 2
45810: ST_TO_ADDR
// p := [ ] ;
45811: LD_ADDR_VAR 0 11
45815: PUSH
45816: EMPTY
45817: ST_TO_ADDR
// if sort then
45818: LD_VAR 0 9
45822: IFFALSE 45938
// for i = 1 to 6 - eng do
45824: LD_ADDR_VAR 0 3
45828: PUSH
45829: DOUBLE
45830: LD_INT 1
45832: DEC
45833: ST_TO_ADDR
45834: LD_INT 6
45836: PUSH
45837: LD_VAR 0 6
45841: MINUS
45842: PUSH
45843: FOR_TO
45844: IFFALSE 45936
// begin if i = sort then
45846: LD_VAR 0 3
45850: PUSH
45851: LD_VAR 0 9
45855: EQUAL
45856: IFFALSE 45860
// break ;
45858: GO 45936
// if GetClass ( i ) = 2 then
45860: LD_VAR 0 3
45864: PPUSH
45865: CALL_OW 257
45869: PUSH
45870: LD_INT 2
45872: EQUAL
45873: IFFALSE 45877
// continue ;
45875: GO 45843
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45877: LD_ADDR_VAR 0 11
45881: PUSH
45882: LD_VAR 0 11
45886: PPUSH
45887: LD_VAR 0 11
45891: PUSH
45892: LD_INT 1
45894: PLUS
45895: PPUSH
45896: LD_VAR 0 9
45900: PUSH
45901: LD_VAR 0 3
45905: ARRAY
45906: PPUSH
45907: CALL_OW 2
45911: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45912: LD_ADDR_VAR 0 4
45916: PUSH
45917: LD_VAR 0 4
45921: PUSH
45922: LD_VAR 0 9
45926: PUSH
45927: LD_VAR 0 3
45931: ARRAY
45932: DIFF
45933: ST_TO_ADDR
// end ;
45934: GO 45843
45936: POP
45937: POP
// if p then
45938: LD_VAR 0 11
45942: IFFALSE 45967
// result := Replace ( result , 2 , p ) ;
45944: LD_ADDR_VAR 0 2
45948: PUSH
45949: LD_VAR 0 2
45953: PPUSH
45954: LD_INT 2
45956: PPUSH
45957: LD_VAR 0 11
45961: PPUSH
45962: CALL_OW 1
45966: ST_TO_ADDR
// end ; exit ;
45967: GO 47355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45969: LD_EXP 129
45973: PUSH
45974: LD_EXP 128
45978: PUSH
45979: LD_VAR 0 1
45983: ARRAY
45984: ARRAY
45985: NOT
45986: PUSH
45987: LD_EXP 102
45991: PUSH
45992: LD_VAR 0 1
45996: ARRAY
45997: PPUSH
45998: LD_INT 30
46000: PUSH
46001: LD_INT 3
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PPUSH
46008: CALL_OW 72
46012: AND
46013: PUSH
46014: LD_EXP 107
46018: PUSH
46019: LD_VAR 0 1
46023: ARRAY
46024: AND
46025: IFFALSE 46633
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46027: LD_ADDR_EXP 144
46031: PUSH
46032: LD_EXP 144
46036: PPUSH
46037: LD_VAR 0 1
46041: PPUSH
46042: LD_INT 5
46044: PPUSH
46045: CALL_OW 1
46049: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46050: LD_ADDR_VAR 0 2
46054: PUSH
46055: LD_INT 0
46057: PUSH
46058: LD_INT 0
46060: PUSH
46061: LD_INT 0
46063: PUSH
46064: LD_INT 0
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: ST_TO_ADDR
// if sci > 1 then
46073: LD_VAR 0 8
46077: PUSH
46078: LD_INT 1
46080: GREATER
46081: IFFALSE 46109
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46083: LD_ADDR_VAR 0 4
46087: PUSH
46088: LD_VAR 0 4
46092: PUSH
46093: LD_VAR 0 8
46097: PUSH
46098: LD_VAR 0 8
46102: PUSH
46103: LD_INT 1
46105: ARRAY
46106: DIFF
46107: DIFF
46108: ST_TO_ADDR
// if tmp and not sci then
46109: LD_VAR 0 4
46113: PUSH
46114: LD_VAR 0 8
46118: NOT
46119: AND
46120: IFFALSE 46189
// begin sort := SortBySkill ( tmp , 4 ) ;
46122: LD_ADDR_VAR 0 9
46126: PUSH
46127: LD_VAR 0 4
46131: PPUSH
46132: LD_INT 4
46134: PPUSH
46135: CALL 105913 0 2
46139: ST_TO_ADDR
// if sort then
46140: LD_VAR 0 9
46144: IFFALSE 46160
// p := sort [ 1 ] ;
46146: LD_ADDR_VAR 0 11
46150: PUSH
46151: LD_VAR 0 9
46155: PUSH
46156: LD_INT 1
46158: ARRAY
46159: ST_TO_ADDR
// if p then
46160: LD_VAR 0 11
46164: IFFALSE 46189
// result := Replace ( result , 4 , p ) ;
46166: LD_ADDR_VAR 0 2
46170: PUSH
46171: LD_VAR 0 2
46175: PPUSH
46176: LD_INT 4
46178: PPUSH
46179: LD_VAR 0 11
46183: PPUSH
46184: CALL_OW 1
46188: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46189: LD_ADDR_VAR 0 4
46193: PUSH
46194: LD_VAR 0 4
46198: PUSH
46199: LD_VAR 0 7
46203: DIFF
46204: ST_TO_ADDR
// if tmp and mech < 6 then
46205: LD_VAR 0 4
46209: PUSH
46210: LD_VAR 0 7
46214: PUSH
46215: LD_INT 6
46217: LESS
46218: AND
46219: IFFALSE 46407
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46221: LD_ADDR_VAR 0 9
46225: PUSH
46226: LD_VAR 0 4
46230: PUSH
46231: LD_VAR 0 8
46235: PUSH
46236: LD_VAR 0 7
46240: UNION
46241: DIFF
46242: PPUSH
46243: LD_INT 3
46245: PPUSH
46246: CALL 105913 0 2
46250: ST_TO_ADDR
// p := [ ] ;
46251: LD_ADDR_VAR 0 11
46255: PUSH
46256: EMPTY
46257: ST_TO_ADDR
// if sort then
46258: LD_VAR 0 9
46262: IFFALSE 46378
// for i = 1 to 6 - mech do
46264: LD_ADDR_VAR 0 3
46268: PUSH
46269: DOUBLE
46270: LD_INT 1
46272: DEC
46273: ST_TO_ADDR
46274: LD_INT 6
46276: PUSH
46277: LD_VAR 0 7
46281: MINUS
46282: PUSH
46283: FOR_TO
46284: IFFALSE 46376
// begin if i = sort then
46286: LD_VAR 0 3
46290: PUSH
46291: LD_VAR 0 9
46295: EQUAL
46296: IFFALSE 46300
// break ;
46298: GO 46376
// if GetClass ( i ) = 3 then
46300: LD_VAR 0 3
46304: PPUSH
46305: CALL_OW 257
46309: PUSH
46310: LD_INT 3
46312: EQUAL
46313: IFFALSE 46317
// continue ;
46315: GO 46283
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46317: LD_ADDR_VAR 0 11
46321: PUSH
46322: LD_VAR 0 11
46326: PPUSH
46327: LD_VAR 0 11
46331: PUSH
46332: LD_INT 1
46334: PLUS
46335: PPUSH
46336: LD_VAR 0 9
46340: PUSH
46341: LD_VAR 0 3
46345: ARRAY
46346: PPUSH
46347: CALL_OW 2
46351: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46352: LD_ADDR_VAR 0 4
46356: PUSH
46357: LD_VAR 0 4
46361: PUSH
46362: LD_VAR 0 9
46366: PUSH
46367: LD_VAR 0 3
46371: ARRAY
46372: DIFF
46373: ST_TO_ADDR
// end ;
46374: GO 46283
46376: POP
46377: POP
// if p then
46378: LD_VAR 0 11
46382: IFFALSE 46407
// result := Replace ( result , 3 , p ) ;
46384: LD_ADDR_VAR 0 2
46388: PUSH
46389: LD_VAR 0 2
46393: PPUSH
46394: LD_INT 3
46396: PPUSH
46397: LD_VAR 0 11
46401: PPUSH
46402: CALL_OW 1
46406: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46407: LD_ADDR_VAR 0 4
46411: PUSH
46412: LD_VAR 0 4
46416: PUSH
46417: LD_VAR 0 6
46421: DIFF
46422: ST_TO_ADDR
// if tmp and eng < 6 then
46423: LD_VAR 0 4
46427: PUSH
46428: LD_VAR 0 6
46432: PUSH
46433: LD_INT 6
46435: LESS
46436: AND
46437: IFFALSE 46631
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46439: LD_ADDR_VAR 0 9
46443: PUSH
46444: LD_VAR 0 4
46448: PUSH
46449: LD_VAR 0 8
46453: PUSH
46454: LD_VAR 0 7
46458: UNION
46459: PUSH
46460: LD_VAR 0 6
46464: UNION
46465: DIFF
46466: PPUSH
46467: LD_INT 2
46469: PPUSH
46470: CALL 105913 0 2
46474: ST_TO_ADDR
// p := [ ] ;
46475: LD_ADDR_VAR 0 11
46479: PUSH
46480: EMPTY
46481: ST_TO_ADDR
// if sort then
46482: LD_VAR 0 9
46486: IFFALSE 46602
// for i = 1 to 6 - eng do
46488: LD_ADDR_VAR 0 3
46492: PUSH
46493: DOUBLE
46494: LD_INT 1
46496: DEC
46497: ST_TO_ADDR
46498: LD_INT 6
46500: PUSH
46501: LD_VAR 0 6
46505: MINUS
46506: PUSH
46507: FOR_TO
46508: IFFALSE 46600
// begin if i = sort then
46510: LD_VAR 0 3
46514: PUSH
46515: LD_VAR 0 9
46519: EQUAL
46520: IFFALSE 46524
// break ;
46522: GO 46600
// if GetClass ( i ) = 2 then
46524: LD_VAR 0 3
46528: PPUSH
46529: CALL_OW 257
46533: PUSH
46534: LD_INT 2
46536: EQUAL
46537: IFFALSE 46541
// continue ;
46539: GO 46507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46541: LD_ADDR_VAR 0 11
46545: PUSH
46546: LD_VAR 0 11
46550: PPUSH
46551: LD_VAR 0 11
46555: PUSH
46556: LD_INT 1
46558: PLUS
46559: PPUSH
46560: LD_VAR 0 9
46564: PUSH
46565: LD_VAR 0 3
46569: ARRAY
46570: PPUSH
46571: CALL_OW 2
46575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46576: LD_ADDR_VAR 0 4
46580: PUSH
46581: LD_VAR 0 4
46585: PUSH
46586: LD_VAR 0 9
46590: PUSH
46591: LD_VAR 0 3
46595: ARRAY
46596: DIFF
46597: ST_TO_ADDR
// end ;
46598: GO 46507
46600: POP
46601: POP
// if p then
46602: LD_VAR 0 11
46606: IFFALSE 46631
// result := Replace ( result , 2 , p ) ;
46608: LD_ADDR_VAR 0 2
46612: PUSH
46613: LD_VAR 0 2
46617: PPUSH
46618: LD_INT 2
46620: PPUSH
46621: LD_VAR 0 11
46625: PPUSH
46626: CALL_OW 1
46630: ST_TO_ADDR
// end ; exit ;
46631: GO 47355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46633: LD_EXP 129
46637: PUSH
46638: LD_EXP 128
46642: PUSH
46643: LD_VAR 0 1
46647: ARRAY
46648: ARRAY
46649: NOT
46650: PUSH
46651: LD_EXP 102
46655: PUSH
46656: LD_VAR 0 1
46660: ARRAY
46661: PPUSH
46662: LD_INT 30
46664: PUSH
46665: LD_INT 3
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: PPUSH
46672: CALL_OW 72
46676: AND
46677: PUSH
46678: LD_EXP 107
46682: PUSH
46683: LD_VAR 0 1
46687: ARRAY
46688: NOT
46689: AND
46690: IFFALSE 47355
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46692: LD_ADDR_EXP 144
46696: PUSH
46697: LD_EXP 144
46701: PPUSH
46702: LD_VAR 0 1
46706: PPUSH
46707: LD_INT 6
46709: PPUSH
46710: CALL_OW 1
46714: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46715: LD_ADDR_VAR 0 2
46719: PUSH
46720: LD_INT 0
46722: PUSH
46723: LD_INT 0
46725: PUSH
46726: LD_INT 0
46728: PUSH
46729: LD_INT 0
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: ST_TO_ADDR
// if sci >= 1 then
46738: LD_VAR 0 8
46742: PUSH
46743: LD_INT 1
46745: GREATEREQUAL
46746: IFFALSE 46768
// tmp := tmp diff sci [ 1 ] ;
46748: LD_ADDR_VAR 0 4
46752: PUSH
46753: LD_VAR 0 4
46757: PUSH
46758: LD_VAR 0 8
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: DIFF
46767: ST_TO_ADDR
// if tmp and not sci then
46768: LD_VAR 0 4
46772: PUSH
46773: LD_VAR 0 8
46777: NOT
46778: AND
46779: IFFALSE 46848
// begin sort := SortBySkill ( tmp , 4 ) ;
46781: LD_ADDR_VAR 0 9
46785: PUSH
46786: LD_VAR 0 4
46790: PPUSH
46791: LD_INT 4
46793: PPUSH
46794: CALL 105913 0 2
46798: ST_TO_ADDR
// if sort then
46799: LD_VAR 0 9
46803: IFFALSE 46819
// p := sort [ 1 ] ;
46805: LD_ADDR_VAR 0 11
46809: PUSH
46810: LD_VAR 0 9
46814: PUSH
46815: LD_INT 1
46817: ARRAY
46818: ST_TO_ADDR
// if p then
46819: LD_VAR 0 11
46823: IFFALSE 46848
// result := Replace ( result , 4 , p ) ;
46825: LD_ADDR_VAR 0 2
46829: PUSH
46830: LD_VAR 0 2
46834: PPUSH
46835: LD_INT 4
46837: PPUSH
46838: LD_VAR 0 11
46842: PPUSH
46843: CALL_OW 1
46847: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46848: LD_ADDR_VAR 0 4
46852: PUSH
46853: LD_VAR 0 4
46857: PUSH
46858: LD_VAR 0 7
46862: DIFF
46863: ST_TO_ADDR
// if tmp and mech < 6 then
46864: LD_VAR 0 4
46868: PUSH
46869: LD_VAR 0 7
46873: PUSH
46874: LD_INT 6
46876: LESS
46877: AND
46878: IFFALSE 47060
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46880: LD_ADDR_VAR 0 9
46884: PUSH
46885: LD_VAR 0 4
46889: PUSH
46890: LD_VAR 0 7
46894: DIFF
46895: PPUSH
46896: LD_INT 3
46898: PPUSH
46899: CALL 105913 0 2
46903: ST_TO_ADDR
// p := [ ] ;
46904: LD_ADDR_VAR 0 11
46908: PUSH
46909: EMPTY
46910: ST_TO_ADDR
// if sort then
46911: LD_VAR 0 9
46915: IFFALSE 47031
// for i = 1 to 6 - mech do
46917: LD_ADDR_VAR 0 3
46921: PUSH
46922: DOUBLE
46923: LD_INT 1
46925: DEC
46926: ST_TO_ADDR
46927: LD_INT 6
46929: PUSH
46930: LD_VAR 0 7
46934: MINUS
46935: PUSH
46936: FOR_TO
46937: IFFALSE 47029
// begin if i = sort then
46939: LD_VAR 0 3
46943: PUSH
46944: LD_VAR 0 9
46948: EQUAL
46949: IFFALSE 46953
// break ;
46951: GO 47029
// if GetClass ( i ) = 3 then
46953: LD_VAR 0 3
46957: PPUSH
46958: CALL_OW 257
46962: PUSH
46963: LD_INT 3
46965: EQUAL
46966: IFFALSE 46970
// continue ;
46968: GO 46936
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46970: LD_ADDR_VAR 0 11
46974: PUSH
46975: LD_VAR 0 11
46979: PPUSH
46980: LD_VAR 0 11
46984: PUSH
46985: LD_INT 1
46987: PLUS
46988: PPUSH
46989: LD_VAR 0 9
46993: PUSH
46994: LD_VAR 0 3
46998: ARRAY
46999: PPUSH
47000: CALL_OW 2
47004: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47005: LD_ADDR_VAR 0 4
47009: PUSH
47010: LD_VAR 0 4
47014: PUSH
47015: LD_VAR 0 9
47019: PUSH
47020: LD_VAR 0 3
47024: ARRAY
47025: DIFF
47026: ST_TO_ADDR
// end ;
47027: GO 46936
47029: POP
47030: POP
// if p then
47031: LD_VAR 0 11
47035: IFFALSE 47060
// result := Replace ( result , 3 , p ) ;
47037: LD_ADDR_VAR 0 2
47041: PUSH
47042: LD_VAR 0 2
47046: PPUSH
47047: LD_INT 3
47049: PPUSH
47050: LD_VAR 0 11
47054: PPUSH
47055: CALL_OW 1
47059: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47060: LD_ADDR_VAR 0 4
47064: PUSH
47065: LD_VAR 0 4
47069: PUSH
47070: LD_VAR 0 6
47074: DIFF
47075: ST_TO_ADDR
// if tmp and eng < 4 then
47076: LD_VAR 0 4
47080: PUSH
47081: LD_VAR 0 6
47085: PUSH
47086: LD_INT 4
47088: LESS
47089: AND
47090: IFFALSE 47280
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47092: LD_ADDR_VAR 0 9
47096: PUSH
47097: LD_VAR 0 4
47101: PUSH
47102: LD_VAR 0 7
47106: PUSH
47107: LD_VAR 0 6
47111: UNION
47112: DIFF
47113: PPUSH
47114: LD_INT 2
47116: PPUSH
47117: CALL 105913 0 2
47121: ST_TO_ADDR
// p := [ ] ;
47122: LD_ADDR_VAR 0 11
47126: PUSH
47127: EMPTY
47128: ST_TO_ADDR
// if sort then
47129: LD_VAR 0 9
47133: IFFALSE 47249
// for i = 1 to 4 - eng do
47135: LD_ADDR_VAR 0 3
47139: PUSH
47140: DOUBLE
47141: LD_INT 1
47143: DEC
47144: ST_TO_ADDR
47145: LD_INT 4
47147: PUSH
47148: LD_VAR 0 6
47152: MINUS
47153: PUSH
47154: FOR_TO
47155: IFFALSE 47247
// begin if i = sort then
47157: LD_VAR 0 3
47161: PUSH
47162: LD_VAR 0 9
47166: EQUAL
47167: IFFALSE 47171
// break ;
47169: GO 47247
// if GetClass ( i ) = 2 then
47171: LD_VAR 0 3
47175: PPUSH
47176: CALL_OW 257
47180: PUSH
47181: LD_INT 2
47183: EQUAL
47184: IFFALSE 47188
// continue ;
47186: GO 47154
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47188: LD_ADDR_VAR 0 11
47192: PUSH
47193: LD_VAR 0 11
47197: PPUSH
47198: LD_VAR 0 11
47202: PUSH
47203: LD_INT 1
47205: PLUS
47206: PPUSH
47207: LD_VAR 0 9
47211: PUSH
47212: LD_VAR 0 3
47216: ARRAY
47217: PPUSH
47218: CALL_OW 2
47222: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47223: LD_ADDR_VAR 0 4
47227: PUSH
47228: LD_VAR 0 4
47232: PUSH
47233: LD_VAR 0 9
47237: PUSH
47238: LD_VAR 0 3
47242: ARRAY
47243: DIFF
47244: ST_TO_ADDR
// end ;
47245: GO 47154
47247: POP
47248: POP
// if p then
47249: LD_VAR 0 11
47253: IFFALSE 47278
// result := Replace ( result , 2 , p ) ;
47255: LD_ADDR_VAR 0 2
47259: PUSH
47260: LD_VAR 0 2
47264: PPUSH
47265: LD_INT 2
47267: PPUSH
47268: LD_VAR 0 11
47272: PPUSH
47273: CALL_OW 1
47277: ST_TO_ADDR
// end else
47278: GO 47324
// for i = eng downto 5 do
47280: LD_ADDR_VAR 0 3
47284: PUSH
47285: DOUBLE
47286: LD_VAR 0 6
47290: INC
47291: ST_TO_ADDR
47292: LD_INT 5
47294: PUSH
47295: FOR_DOWNTO
47296: IFFALSE 47322
// tmp := tmp union eng [ i ] ;
47298: LD_ADDR_VAR 0 4
47302: PUSH
47303: LD_VAR 0 4
47307: PUSH
47308: LD_VAR 0 6
47312: PUSH
47313: LD_VAR 0 3
47317: ARRAY
47318: UNION
47319: ST_TO_ADDR
47320: GO 47295
47322: POP
47323: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47324: LD_ADDR_VAR 0 2
47328: PUSH
47329: LD_VAR 0 2
47333: PPUSH
47334: LD_INT 1
47336: PPUSH
47337: LD_VAR 0 4
47341: PUSH
47342: LD_VAR 0 5
47346: DIFF
47347: PPUSH
47348: CALL_OW 1
47352: ST_TO_ADDR
// exit ;
47353: GO 47355
// end ; end ;
47355: LD_VAR 0 2
47359: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47360: LD_INT 0
47362: PPUSH
47363: PPUSH
47364: PPUSH
// if not mc_bases then
47365: LD_EXP 102
47369: NOT
47370: IFFALSE 47374
// exit ;
47372: GO 47516
// for i = 1 to mc_bases do
47374: LD_ADDR_VAR 0 2
47378: PUSH
47379: DOUBLE
47380: LD_INT 1
47382: DEC
47383: ST_TO_ADDR
47384: LD_EXP 102
47388: PUSH
47389: FOR_TO
47390: IFFALSE 47507
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47392: LD_ADDR_VAR 0 3
47396: PUSH
47397: LD_EXP 102
47401: PUSH
47402: LD_VAR 0 2
47406: ARRAY
47407: PPUSH
47408: LD_INT 21
47410: PUSH
47411: LD_INT 3
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 3
47420: PUSH
47421: LD_INT 2
47423: PUSH
47424: LD_INT 30
47426: PUSH
47427: LD_INT 29
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PUSH
47434: LD_INT 30
47436: PUSH
47437: LD_INT 30
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: LIST
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: PUSH
47453: LD_INT 3
47455: PUSH
47456: LD_INT 24
47458: PUSH
47459: LD_INT 1000
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PUSH
47466: EMPTY
47467: LIST
47468: LIST
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: LIST
47474: PPUSH
47475: CALL_OW 72
47479: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47480: LD_ADDR_EXP 103
47484: PUSH
47485: LD_EXP 103
47489: PPUSH
47490: LD_VAR 0 2
47494: PPUSH
47495: LD_VAR 0 3
47499: PPUSH
47500: CALL_OW 1
47504: ST_TO_ADDR
// end ;
47505: GO 47389
47507: POP
47508: POP
// RaiseSailEvent ( 101 ) ;
47509: LD_INT 101
47511: PPUSH
47512: CALL_OW 427
// end ;
47516: LD_VAR 0 1
47520: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
47526: PPUSH
47527: PPUSH
47528: PPUSH
47529: PPUSH
// if not mc_bases then
47530: LD_EXP 102
47534: NOT
47535: IFFALSE 47539
// exit ;
47537: GO 48101
// for i = 1 to mc_bases do
47539: LD_ADDR_VAR 0 2
47543: PUSH
47544: DOUBLE
47545: LD_INT 1
47547: DEC
47548: ST_TO_ADDR
47549: LD_EXP 102
47553: PUSH
47554: FOR_TO
47555: IFFALSE 48092
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47557: LD_ADDR_VAR 0 5
47561: PUSH
47562: LD_EXP 102
47566: PUSH
47567: LD_VAR 0 2
47571: ARRAY
47572: PUSH
47573: LD_EXP 131
47577: PUSH
47578: LD_VAR 0 2
47582: ARRAY
47583: UNION
47584: PPUSH
47585: LD_INT 21
47587: PUSH
47588: LD_INT 1
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: LD_INT 1
47597: PUSH
47598: LD_INT 3
47600: PUSH
47601: LD_INT 54
47603: PUSH
47604: EMPTY
47605: LIST
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: LD_INT 3
47613: PUSH
47614: LD_INT 24
47616: PUSH
47617: LD_INT 1000
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: LIST
47632: PUSH
47633: EMPTY
47634: LIST
47635: LIST
47636: PPUSH
47637: CALL_OW 72
47641: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47642: LD_ADDR_VAR 0 6
47646: PUSH
47647: LD_EXP 102
47651: PUSH
47652: LD_VAR 0 2
47656: ARRAY
47657: PPUSH
47658: LD_INT 21
47660: PUSH
47661: LD_INT 1
47663: PUSH
47664: EMPTY
47665: LIST
47666: LIST
47667: PUSH
47668: LD_INT 1
47670: PUSH
47671: LD_INT 3
47673: PUSH
47674: LD_INT 54
47676: PUSH
47677: EMPTY
47678: LIST
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 3
47686: PUSH
47687: LD_INT 24
47689: PUSH
47690: LD_INT 250
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: PUSH
47701: EMPTY
47702: LIST
47703: LIST
47704: LIST
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: PPUSH
47710: CALL_OW 72
47714: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47715: LD_ADDR_VAR 0 7
47719: PUSH
47720: LD_VAR 0 5
47724: PUSH
47725: LD_VAR 0 6
47729: DIFF
47730: ST_TO_ADDR
// if not need_heal_1 then
47731: LD_VAR 0 6
47735: NOT
47736: IFFALSE 47769
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47738: LD_ADDR_EXP 105
47742: PUSH
47743: LD_EXP 105
47747: PPUSH
47748: LD_VAR 0 2
47752: PUSH
47753: LD_INT 1
47755: PUSH
47756: EMPTY
47757: LIST
47758: LIST
47759: PPUSH
47760: EMPTY
47761: PPUSH
47762: CALL 74680 0 3
47766: ST_TO_ADDR
47767: GO 47839
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47769: LD_ADDR_EXP 105
47773: PUSH
47774: LD_EXP 105
47778: PPUSH
47779: LD_VAR 0 2
47783: PUSH
47784: LD_INT 1
47786: PUSH
47787: EMPTY
47788: LIST
47789: LIST
47790: PPUSH
47791: LD_EXP 105
47795: PUSH
47796: LD_VAR 0 2
47800: ARRAY
47801: PUSH
47802: LD_INT 1
47804: ARRAY
47805: PPUSH
47806: LD_INT 3
47808: PUSH
47809: LD_INT 24
47811: PUSH
47812: LD_INT 1000
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PPUSH
47823: CALL_OW 72
47827: PUSH
47828: LD_VAR 0 6
47832: UNION
47833: PPUSH
47834: CALL 74680 0 3
47838: ST_TO_ADDR
// if not need_heal_2 then
47839: LD_VAR 0 7
47843: NOT
47844: IFFALSE 47877
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47846: LD_ADDR_EXP 105
47850: PUSH
47851: LD_EXP 105
47855: PPUSH
47856: LD_VAR 0 2
47860: PUSH
47861: LD_INT 2
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PPUSH
47868: EMPTY
47869: PPUSH
47870: CALL 74680 0 3
47874: ST_TO_ADDR
47875: GO 47909
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47877: LD_ADDR_EXP 105
47881: PUSH
47882: LD_EXP 105
47886: PPUSH
47887: LD_VAR 0 2
47891: PUSH
47892: LD_INT 2
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PPUSH
47899: LD_VAR 0 7
47903: PPUSH
47904: CALL 74680 0 3
47908: ST_TO_ADDR
// if need_heal_2 then
47909: LD_VAR 0 7
47913: IFFALSE 48074
// for j in need_heal_2 do
47915: LD_ADDR_VAR 0 3
47919: PUSH
47920: LD_VAR 0 7
47924: PUSH
47925: FOR_IN
47926: IFFALSE 48072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47928: LD_ADDR_VAR 0 5
47932: PUSH
47933: LD_EXP 102
47937: PUSH
47938: LD_VAR 0 2
47942: ARRAY
47943: PPUSH
47944: LD_INT 2
47946: PUSH
47947: LD_INT 30
47949: PUSH
47950: LD_INT 6
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 30
47959: PUSH
47960: LD_INT 7
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 30
47969: PUSH
47970: LD_INT 8
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 30
47979: PUSH
47980: LD_INT 0
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 30
47989: PUSH
47990: LD_INT 1
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: PPUSH
48005: CALL_OW 72
48009: ST_TO_ADDR
// if tmp then
48010: LD_VAR 0 5
48014: IFFALSE 48070
// begin k := NearestUnitToUnit ( tmp , j ) ;
48016: LD_ADDR_VAR 0 4
48020: PUSH
48021: LD_VAR 0 5
48025: PPUSH
48026: LD_VAR 0 3
48030: PPUSH
48031: CALL_OW 74
48035: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48036: LD_VAR 0 3
48040: PPUSH
48041: LD_VAR 0 4
48045: PPUSH
48046: CALL_OW 296
48050: PUSH
48051: LD_INT 5
48053: GREATER
48054: IFFALSE 48070
// ComMoveToNearbyEntrance ( j , k ) ;
48056: LD_VAR 0 3
48060: PPUSH
48061: LD_VAR 0 4
48065: PPUSH
48066: CALL 108286 0 2
// end ; end ;
48070: GO 47925
48072: POP
48073: POP
// if not need_heal_1 and not need_heal_2 then
48074: LD_VAR 0 6
48078: NOT
48079: PUSH
48080: LD_VAR 0 7
48084: NOT
48085: AND
48086: IFFALSE 48090
// continue ;
48088: GO 47554
// end ;
48090: GO 47554
48092: POP
48093: POP
// RaiseSailEvent ( 102 ) ;
48094: LD_INT 102
48096: PPUSH
48097: CALL_OW 427
// end ;
48101: LD_VAR 0 1
48105: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48106: LD_INT 0
48108: PPUSH
48109: PPUSH
48110: PPUSH
48111: PPUSH
48112: PPUSH
48113: PPUSH
48114: PPUSH
48115: PPUSH
// if not mc_bases then
48116: LD_EXP 102
48120: NOT
48121: IFFALSE 48125
// exit ;
48123: GO 49036
// for i = 1 to mc_bases do
48125: LD_ADDR_VAR 0 2
48129: PUSH
48130: DOUBLE
48131: LD_INT 1
48133: DEC
48134: ST_TO_ADDR
48135: LD_EXP 102
48139: PUSH
48140: FOR_TO
48141: IFFALSE 49034
// begin if not mc_building_need_repair [ i ] then
48143: LD_EXP 103
48147: PUSH
48148: LD_VAR 0 2
48152: ARRAY
48153: NOT
48154: IFFALSE 48339
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48156: LD_ADDR_VAR 0 6
48160: PUSH
48161: LD_EXP 121
48165: PUSH
48166: LD_VAR 0 2
48170: ARRAY
48171: PPUSH
48172: LD_INT 3
48174: PUSH
48175: LD_INT 24
48177: PUSH
48178: LD_INT 1000
48180: PUSH
48181: EMPTY
48182: LIST
48183: LIST
48184: PUSH
48185: EMPTY
48186: LIST
48187: LIST
48188: PUSH
48189: LD_INT 2
48191: PUSH
48192: LD_INT 34
48194: PUSH
48195: LD_INT 13
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: LD_INT 34
48204: PUSH
48205: LD_INT 52
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: PUSH
48212: LD_INT 34
48214: PUSH
48215: LD_INT 88
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: PUSH
48228: EMPTY
48229: LIST
48230: LIST
48231: PPUSH
48232: CALL_OW 72
48236: ST_TO_ADDR
// if cranes then
48237: LD_VAR 0 6
48241: IFFALSE 48303
// for j in cranes do
48243: LD_ADDR_VAR 0 3
48247: PUSH
48248: LD_VAR 0 6
48252: PUSH
48253: FOR_IN
48254: IFFALSE 48301
// if not IsInArea ( j , mc_parking [ i ] ) then
48256: LD_VAR 0 3
48260: PPUSH
48261: LD_EXP 126
48265: PUSH
48266: LD_VAR 0 2
48270: ARRAY
48271: PPUSH
48272: CALL_OW 308
48276: NOT
48277: IFFALSE 48299
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48279: LD_VAR 0 3
48283: PPUSH
48284: LD_EXP 126
48288: PUSH
48289: LD_VAR 0 2
48293: ARRAY
48294: PPUSH
48295: CALL_OW 113
48299: GO 48253
48301: POP
48302: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48303: LD_ADDR_EXP 104
48307: PUSH
48308: LD_EXP 104
48312: PPUSH
48313: LD_VAR 0 2
48317: PPUSH
48318: EMPTY
48319: PPUSH
48320: CALL_OW 1
48324: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48325: LD_VAR 0 2
48329: PPUSH
48330: LD_INT 101
48332: PPUSH
48333: CALL 43179 0 2
// continue ;
48337: GO 48140
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48339: LD_ADDR_EXP 108
48343: PUSH
48344: LD_EXP 108
48348: PPUSH
48349: LD_VAR 0 2
48353: PPUSH
48354: EMPTY
48355: PPUSH
48356: CALL_OW 1
48360: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48361: LD_VAR 0 2
48365: PPUSH
48366: LD_INT 103
48368: PPUSH
48369: CALL 43179 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48373: LD_ADDR_VAR 0 5
48377: PUSH
48378: LD_EXP 102
48382: PUSH
48383: LD_VAR 0 2
48387: ARRAY
48388: PUSH
48389: LD_EXP 131
48393: PUSH
48394: LD_VAR 0 2
48398: ARRAY
48399: UNION
48400: PPUSH
48401: LD_INT 2
48403: PUSH
48404: LD_INT 25
48406: PUSH
48407: LD_INT 2
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: PUSH
48414: LD_INT 25
48416: PUSH
48417: LD_INT 16
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: PUSH
48424: EMPTY
48425: LIST
48426: LIST
48427: LIST
48428: PUSH
48429: EMPTY
48430: LIST
48431: PPUSH
48432: CALL_OW 72
48436: ST_TO_ADDR
// if mc_need_heal [ i ] then
48437: LD_EXP 105
48441: PUSH
48442: LD_VAR 0 2
48446: ARRAY
48447: IFFALSE 48491
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48449: LD_ADDR_VAR 0 5
48453: PUSH
48454: LD_VAR 0 5
48458: PUSH
48459: LD_EXP 105
48463: PUSH
48464: LD_VAR 0 2
48468: ARRAY
48469: PUSH
48470: LD_INT 1
48472: ARRAY
48473: PUSH
48474: LD_EXP 105
48478: PUSH
48479: LD_VAR 0 2
48483: ARRAY
48484: PUSH
48485: LD_INT 2
48487: ARRAY
48488: UNION
48489: DIFF
48490: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48491: LD_ADDR_VAR 0 6
48495: PUSH
48496: LD_EXP 121
48500: PUSH
48501: LD_VAR 0 2
48505: ARRAY
48506: PPUSH
48507: LD_INT 2
48509: PUSH
48510: LD_INT 34
48512: PUSH
48513: LD_INT 13
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: PUSH
48520: LD_INT 34
48522: PUSH
48523: LD_INT 52
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 34
48532: PUSH
48533: LD_INT 88
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: EMPTY
48541: LIST
48542: LIST
48543: LIST
48544: LIST
48545: PPUSH
48546: CALL_OW 72
48550: ST_TO_ADDR
// if cranes then
48551: LD_VAR 0 6
48555: IFFALSE 48723
// begin for j in cranes do
48557: LD_ADDR_VAR 0 3
48561: PUSH
48562: LD_VAR 0 6
48566: PUSH
48567: FOR_IN
48568: IFFALSE 48721
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48570: LD_VAR 0 3
48574: PPUSH
48575: CALL_OW 256
48579: PUSH
48580: LD_INT 1000
48582: EQUAL
48583: PUSH
48584: LD_VAR 0 3
48588: PPUSH
48589: CALL_OW 314
48593: NOT
48594: AND
48595: IFFALSE 48661
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48597: LD_ADDR_VAR 0 8
48601: PUSH
48602: LD_EXP 103
48606: PUSH
48607: LD_VAR 0 2
48611: ARRAY
48612: PPUSH
48613: LD_VAR 0 3
48617: PPUSH
48618: CALL_OW 74
48622: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48623: LD_VAR 0 8
48627: PPUSH
48628: LD_INT 16
48630: PPUSH
48631: CALL 77645 0 2
48635: PUSH
48636: LD_INT 4
48638: ARRAY
48639: PUSH
48640: LD_INT 10
48642: LESS
48643: IFFALSE 48659
// ComRepairBuilding ( j , to_repair ) ;
48645: LD_VAR 0 3
48649: PPUSH
48650: LD_VAR 0 8
48654: PPUSH
48655: CALL_OW 130
// end else
48659: GO 48719
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48661: LD_VAR 0 3
48665: PPUSH
48666: CALL_OW 256
48670: PUSH
48671: LD_INT 500
48673: LESS
48674: PUSH
48675: LD_VAR 0 3
48679: PPUSH
48680: LD_EXP 126
48684: PUSH
48685: LD_VAR 0 2
48689: ARRAY
48690: PPUSH
48691: CALL_OW 308
48695: NOT
48696: AND
48697: IFFALSE 48719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48699: LD_VAR 0 3
48703: PPUSH
48704: LD_EXP 126
48708: PUSH
48709: LD_VAR 0 2
48713: ARRAY
48714: PPUSH
48715: CALL_OW 113
// end ;
48719: GO 48567
48721: POP
48722: POP
// end ; if tmp > 3 then
48723: LD_VAR 0 5
48727: PUSH
48728: LD_INT 3
48730: GREATER
48731: IFFALSE 48751
// tmp := ShrinkArray ( tmp , 4 ) ;
48733: LD_ADDR_VAR 0 5
48737: PUSH
48738: LD_VAR 0 5
48742: PPUSH
48743: LD_INT 4
48745: PPUSH
48746: CALL 107724 0 2
48750: ST_TO_ADDR
// if not tmp then
48751: LD_VAR 0 5
48755: NOT
48756: IFFALSE 48760
// continue ;
48758: GO 48140
// for j in tmp do
48760: LD_ADDR_VAR 0 3
48764: PUSH
48765: LD_VAR 0 5
48769: PUSH
48770: FOR_IN
48771: IFFALSE 49030
// begin if IsInUnit ( j ) then
48773: LD_VAR 0 3
48777: PPUSH
48778: CALL_OW 310
48782: IFFALSE 48793
// ComExitBuilding ( j ) ;
48784: LD_VAR 0 3
48788: PPUSH
48789: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48793: LD_VAR 0 3
48797: PUSH
48798: LD_EXP 104
48802: PUSH
48803: LD_VAR 0 2
48807: ARRAY
48808: IN
48809: NOT
48810: IFFALSE 48868
// begin SetTag ( j , 101 ) ;
48812: LD_VAR 0 3
48816: PPUSH
48817: LD_INT 101
48819: PPUSH
48820: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48824: LD_ADDR_EXP 104
48828: PUSH
48829: LD_EXP 104
48833: PPUSH
48834: LD_VAR 0 2
48838: PUSH
48839: LD_EXP 104
48843: PUSH
48844: LD_VAR 0 2
48848: ARRAY
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PPUSH
48858: LD_VAR 0 3
48862: PPUSH
48863: CALL 74680 0 3
48867: ST_TO_ADDR
// end ; wait ( 1 ) ;
48868: LD_INT 1
48870: PPUSH
48871: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48875: LD_ADDR_VAR 0 7
48879: PUSH
48880: LD_EXP 103
48884: PUSH
48885: LD_VAR 0 2
48889: ARRAY
48890: ST_TO_ADDR
// if mc_scan [ i ] then
48891: LD_EXP 125
48895: PUSH
48896: LD_VAR 0 2
48900: ARRAY
48901: IFFALSE 48963
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48903: LD_ADDR_VAR 0 7
48907: PUSH
48908: LD_EXP 103
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: PPUSH
48919: LD_INT 3
48921: PUSH
48922: LD_INT 30
48924: PUSH
48925: LD_INT 32
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PUSH
48932: LD_INT 30
48934: PUSH
48935: LD_INT 33
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: PUSH
48942: LD_INT 30
48944: PUSH
48945: LD_INT 31
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: PPUSH
48958: CALL_OW 72
48962: ST_TO_ADDR
// if not to_repair_tmp then
48963: LD_VAR 0 7
48967: NOT
48968: IFFALSE 48972
// continue ;
48970: GO 48770
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48972: LD_ADDR_VAR 0 8
48976: PUSH
48977: LD_VAR 0 7
48981: PPUSH
48982: LD_VAR 0 3
48986: PPUSH
48987: CALL_OW 74
48991: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48992: LD_VAR 0 8
48996: PPUSH
48997: LD_INT 16
48999: PPUSH
49000: CALL 77645 0 2
49004: PUSH
49005: LD_INT 4
49007: ARRAY
49008: PUSH
49009: LD_INT 14
49011: LESS
49012: IFFALSE 49028
// ComRepairBuilding ( j , to_repair ) ;
49014: LD_VAR 0 3
49018: PPUSH
49019: LD_VAR 0 8
49023: PPUSH
49024: CALL_OW 130
// end ;
49028: GO 48770
49030: POP
49031: POP
// end ;
49032: GO 48140
49034: POP
49035: POP
// end ;
49036: LD_VAR 0 1
49040: RET
// export function MC_Heal ; var i , j , tmp ; begin
49041: LD_INT 0
49043: PPUSH
49044: PPUSH
49045: PPUSH
49046: PPUSH
// if not mc_bases then
49047: LD_EXP 102
49051: NOT
49052: IFFALSE 49056
// exit ;
49054: GO 49458
// for i = 1 to mc_bases do
49056: LD_ADDR_VAR 0 2
49060: PUSH
49061: DOUBLE
49062: LD_INT 1
49064: DEC
49065: ST_TO_ADDR
49066: LD_EXP 102
49070: PUSH
49071: FOR_TO
49072: IFFALSE 49456
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49074: LD_EXP 105
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PUSH
49085: LD_INT 1
49087: ARRAY
49088: NOT
49089: PUSH
49090: LD_EXP 105
49094: PUSH
49095: LD_VAR 0 2
49099: ARRAY
49100: PUSH
49101: LD_INT 2
49103: ARRAY
49104: NOT
49105: AND
49106: IFFALSE 49144
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49108: LD_ADDR_EXP 106
49112: PUSH
49113: LD_EXP 106
49117: PPUSH
49118: LD_VAR 0 2
49122: PPUSH
49123: EMPTY
49124: PPUSH
49125: CALL_OW 1
49129: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49130: LD_VAR 0 2
49134: PPUSH
49135: LD_INT 102
49137: PPUSH
49138: CALL 43179 0 2
// continue ;
49142: GO 49071
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49144: LD_ADDR_VAR 0 4
49148: PUSH
49149: LD_EXP 102
49153: PUSH
49154: LD_VAR 0 2
49158: ARRAY
49159: PPUSH
49160: LD_INT 25
49162: PUSH
49163: LD_INT 4
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PPUSH
49170: CALL_OW 72
49174: ST_TO_ADDR
// if not tmp then
49175: LD_VAR 0 4
49179: NOT
49180: IFFALSE 49184
// continue ;
49182: GO 49071
// if mc_taming [ i ] then
49184: LD_EXP 133
49188: PUSH
49189: LD_VAR 0 2
49193: ARRAY
49194: IFFALSE 49218
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49196: LD_ADDR_EXP 133
49200: PUSH
49201: LD_EXP 133
49205: PPUSH
49206: LD_VAR 0 2
49210: PPUSH
49211: EMPTY
49212: PPUSH
49213: CALL_OW 1
49217: ST_TO_ADDR
// for j in tmp do
49218: LD_ADDR_VAR 0 3
49222: PUSH
49223: LD_VAR 0 4
49227: PUSH
49228: FOR_IN
49229: IFFALSE 49452
// begin if IsInUnit ( j ) then
49231: LD_VAR 0 3
49235: PPUSH
49236: CALL_OW 310
49240: IFFALSE 49251
// ComExitBuilding ( j ) ;
49242: LD_VAR 0 3
49246: PPUSH
49247: CALL_OW 122
// if not j in mc_healers [ i ] then
49251: LD_VAR 0 3
49255: PUSH
49256: LD_EXP 106
49260: PUSH
49261: LD_VAR 0 2
49265: ARRAY
49266: IN
49267: NOT
49268: IFFALSE 49314
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49270: LD_ADDR_EXP 106
49274: PUSH
49275: LD_EXP 106
49279: PPUSH
49280: LD_VAR 0 2
49284: PUSH
49285: LD_EXP 106
49289: PUSH
49290: LD_VAR 0 2
49294: ARRAY
49295: PUSH
49296: LD_INT 1
49298: PLUS
49299: PUSH
49300: EMPTY
49301: LIST
49302: LIST
49303: PPUSH
49304: LD_VAR 0 3
49308: PPUSH
49309: CALL 74680 0 3
49313: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49314: LD_VAR 0 3
49318: PPUSH
49319: CALL_OW 110
49323: PUSH
49324: LD_INT 102
49326: NONEQUAL
49327: IFFALSE 49341
// SetTag ( j , 102 ) ;
49329: LD_VAR 0 3
49333: PPUSH
49334: LD_INT 102
49336: PPUSH
49337: CALL_OW 109
// Wait ( 3 ) ;
49341: LD_INT 3
49343: PPUSH
49344: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49348: LD_EXP 105
49352: PUSH
49353: LD_VAR 0 2
49357: ARRAY
49358: PUSH
49359: LD_INT 1
49361: ARRAY
49362: IFFALSE 49394
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49364: LD_VAR 0 3
49368: PPUSH
49369: LD_EXP 105
49373: PUSH
49374: LD_VAR 0 2
49378: ARRAY
49379: PUSH
49380: LD_INT 1
49382: ARRAY
49383: PUSH
49384: LD_INT 1
49386: ARRAY
49387: PPUSH
49388: CALL_OW 128
49392: GO 49450
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49394: LD_VAR 0 3
49398: PPUSH
49399: CALL_OW 314
49403: NOT
49404: PUSH
49405: LD_EXP 105
49409: PUSH
49410: LD_VAR 0 2
49414: ARRAY
49415: PUSH
49416: LD_INT 2
49418: ARRAY
49419: AND
49420: IFFALSE 49450
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49422: LD_VAR 0 3
49426: PPUSH
49427: LD_EXP 105
49431: PUSH
49432: LD_VAR 0 2
49436: ARRAY
49437: PUSH
49438: LD_INT 2
49440: ARRAY
49441: PUSH
49442: LD_INT 1
49444: ARRAY
49445: PPUSH
49446: CALL_OW 128
// end ;
49450: GO 49228
49452: POP
49453: POP
// end ;
49454: GO 49071
49456: POP
49457: POP
// end ;
49458: LD_VAR 0 1
49462: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49463: LD_INT 0
49465: PPUSH
49466: PPUSH
49467: PPUSH
49468: PPUSH
49469: PPUSH
49470: PPUSH
// if not mc_bases then
49471: LD_EXP 102
49475: NOT
49476: IFFALSE 49480
// exit ;
49478: GO 50643
// for i = 1 to mc_bases do
49480: LD_ADDR_VAR 0 2
49484: PUSH
49485: DOUBLE
49486: LD_INT 1
49488: DEC
49489: ST_TO_ADDR
49490: LD_EXP 102
49494: PUSH
49495: FOR_TO
49496: IFFALSE 50641
// begin if mc_scan [ i ] then
49498: LD_EXP 125
49502: PUSH
49503: LD_VAR 0 2
49507: ARRAY
49508: IFFALSE 49512
// continue ;
49510: GO 49495
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49512: LD_EXP 107
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: NOT
49523: PUSH
49524: LD_EXP 109
49528: PUSH
49529: LD_VAR 0 2
49533: ARRAY
49534: NOT
49535: AND
49536: PUSH
49537: LD_EXP 108
49541: PUSH
49542: LD_VAR 0 2
49546: ARRAY
49547: AND
49548: IFFALSE 49586
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49550: LD_ADDR_EXP 108
49554: PUSH
49555: LD_EXP 108
49559: PPUSH
49560: LD_VAR 0 2
49564: PPUSH
49565: EMPTY
49566: PPUSH
49567: CALL_OW 1
49571: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49572: LD_VAR 0 2
49576: PPUSH
49577: LD_INT 103
49579: PPUSH
49580: CALL 43179 0 2
// continue ;
49584: GO 49495
// end ; if mc_construct_list [ i ] then
49586: LD_EXP 109
49590: PUSH
49591: LD_VAR 0 2
49595: ARRAY
49596: IFFALSE 49816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49598: LD_ADDR_VAR 0 5
49602: PUSH
49603: LD_EXP 102
49607: PUSH
49608: LD_VAR 0 2
49612: ARRAY
49613: PPUSH
49614: LD_INT 25
49616: PUSH
49617: LD_INT 2
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PPUSH
49624: CALL_OW 72
49628: PUSH
49629: LD_EXP 104
49633: PUSH
49634: LD_VAR 0 2
49638: ARRAY
49639: DIFF
49640: ST_TO_ADDR
// if not tmp then
49641: LD_VAR 0 5
49645: NOT
49646: IFFALSE 49650
// continue ;
49648: GO 49495
// for j in tmp do
49650: LD_ADDR_VAR 0 3
49654: PUSH
49655: LD_VAR 0 5
49659: PUSH
49660: FOR_IN
49661: IFFALSE 49812
// begin if not mc_builders [ i ] then
49663: LD_EXP 108
49667: PUSH
49668: LD_VAR 0 2
49672: ARRAY
49673: NOT
49674: IFFALSE 49732
// begin SetTag ( j , 103 ) ;
49676: LD_VAR 0 3
49680: PPUSH
49681: LD_INT 103
49683: PPUSH
49684: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49688: LD_ADDR_EXP 108
49692: PUSH
49693: LD_EXP 108
49697: PPUSH
49698: LD_VAR 0 2
49702: PUSH
49703: LD_EXP 108
49707: PUSH
49708: LD_VAR 0 2
49712: ARRAY
49713: PUSH
49714: LD_INT 1
49716: PLUS
49717: PUSH
49718: EMPTY
49719: LIST
49720: LIST
49721: PPUSH
49722: LD_VAR 0 3
49726: PPUSH
49727: CALL 74680 0 3
49731: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49732: LD_VAR 0 3
49736: PPUSH
49737: CALL_OW 310
49741: IFFALSE 49752
// ComExitBuilding ( j ) ;
49743: LD_VAR 0 3
49747: PPUSH
49748: CALL_OW 122
// wait ( 3 ) ;
49752: LD_INT 3
49754: PPUSH
49755: CALL_OW 67
// if not mc_construct_list [ i ] then
49759: LD_EXP 109
49763: PUSH
49764: LD_VAR 0 2
49768: ARRAY
49769: NOT
49770: IFFALSE 49774
// break ;
49772: GO 49812
// if not HasTask ( j ) then
49774: LD_VAR 0 3
49778: PPUSH
49779: CALL_OW 314
49783: NOT
49784: IFFALSE 49810
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49786: LD_VAR 0 3
49790: PPUSH
49791: LD_EXP 109
49795: PUSH
49796: LD_VAR 0 2
49800: ARRAY
49801: PUSH
49802: LD_INT 1
49804: ARRAY
49805: PPUSH
49806: CALL 77918 0 2
// end ;
49810: GO 49660
49812: POP
49813: POP
// end else
49814: GO 50639
// if mc_build_list [ i ] then
49816: LD_EXP 107
49820: PUSH
49821: LD_VAR 0 2
49825: ARRAY
49826: IFFALSE 50639
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49828: LD_EXP 107
49832: PUSH
49833: LD_VAR 0 2
49837: ARRAY
49838: PUSH
49839: LD_INT 1
49841: ARRAY
49842: PUSH
49843: LD_INT 1
49845: ARRAY
49846: PPUSH
49847: CALL 77742 0 1
49851: PUSH
49852: LD_EXP 102
49856: PUSH
49857: LD_VAR 0 2
49861: ARRAY
49862: PPUSH
49863: LD_INT 2
49865: PUSH
49866: LD_INT 30
49868: PUSH
49869: LD_INT 2
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 30
49878: PUSH
49879: LD_INT 3
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: LIST
49890: PPUSH
49891: CALL_OW 72
49895: NOT
49896: AND
49897: IFFALSE 50002
// begin for j = 1 to mc_build_list [ i ] do
49899: LD_ADDR_VAR 0 3
49903: PUSH
49904: DOUBLE
49905: LD_INT 1
49907: DEC
49908: ST_TO_ADDR
49909: LD_EXP 107
49913: PUSH
49914: LD_VAR 0 2
49918: ARRAY
49919: PUSH
49920: FOR_TO
49921: IFFALSE 50000
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49923: LD_EXP 107
49927: PUSH
49928: LD_VAR 0 2
49932: ARRAY
49933: PUSH
49934: LD_VAR 0 3
49938: ARRAY
49939: PUSH
49940: LD_INT 1
49942: ARRAY
49943: PUSH
49944: LD_INT 2
49946: EQUAL
49947: IFFALSE 49998
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49949: LD_ADDR_EXP 107
49953: PUSH
49954: LD_EXP 107
49958: PPUSH
49959: LD_VAR 0 2
49963: PPUSH
49964: LD_EXP 107
49968: PUSH
49969: LD_VAR 0 2
49973: ARRAY
49974: PPUSH
49975: LD_VAR 0 3
49979: PPUSH
49980: LD_INT 1
49982: PPUSH
49983: LD_INT 0
49985: PPUSH
49986: CALL 74098 0 4
49990: PPUSH
49991: CALL_OW 1
49995: ST_TO_ADDR
// break ;
49996: GO 50000
// end ;
49998: GO 49920
50000: POP
50001: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50002: LD_ADDR_VAR 0 6
50006: PUSH
50007: LD_EXP 102
50011: PUSH
50012: LD_VAR 0 2
50016: ARRAY
50017: PPUSH
50018: LD_INT 2
50020: PUSH
50021: LD_INT 30
50023: PUSH
50024: LD_INT 0
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_INT 30
50033: PUSH
50034: LD_INT 1
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: LIST
50045: PPUSH
50046: CALL_OW 72
50050: ST_TO_ADDR
// for k := 1 to depot do
50051: LD_ADDR_VAR 0 4
50055: PUSH
50056: DOUBLE
50057: LD_INT 1
50059: DEC
50060: ST_TO_ADDR
50061: LD_VAR 0 6
50065: PUSH
50066: FOR_TO
50067: IFFALSE 50637
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50069: LD_EXP 107
50073: PUSH
50074: LD_VAR 0 2
50078: ARRAY
50079: PUSH
50080: LD_INT 1
50082: ARRAY
50083: PUSH
50084: LD_INT 1
50086: ARRAY
50087: PUSH
50088: LD_INT 0
50090: EQUAL
50091: PUSH
50092: LD_VAR 0 6
50096: PUSH
50097: LD_VAR 0 4
50101: ARRAY
50102: PPUSH
50103: LD_EXP 107
50107: PUSH
50108: LD_VAR 0 2
50112: ARRAY
50113: PUSH
50114: LD_INT 1
50116: ARRAY
50117: PUSH
50118: LD_INT 1
50120: ARRAY
50121: PPUSH
50122: LD_EXP 107
50126: PUSH
50127: LD_VAR 0 2
50131: ARRAY
50132: PUSH
50133: LD_INT 1
50135: ARRAY
50136: PUSH
50137: LD_INT 2
50139: ARRAY
50140: PPUSH
50141: LD_EXP 107
50145: PUSH
50146: LD_VAR 0 2
50150: ARRAY
50151: PUSH
50152: LD_INT 1
50154: ARRAY
50155: PUSH
50156: LD_INT 3
50158: ARRAY
50159: PPUSH
50160: LD_EXP 107
50164: PUSH
50165: LD_VAR 0 2
50169: ARRAY
50170: PUSH
50171: LD_INT 1
50173: ARRAY
50174: PUSH
50175: LD_INT 4
50177: ARRAY
50178: PPUSH
50179: CALL 83154 0 5
50183: OR
50184: IFFALSE 50465
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50186: LD_ADDR_VAR 0 5
50190: PUSH
50191: LD_EXP 102
50195: PUSH
50196: LD_VAR 0 2
50200: ARRAY
50201: PPUSH
50202: LD_INT 25
50204: PUSH
50205: LD_INT 2
50207: PUSH
50208: EMPTY
50209: LIST
50210: LIST
50211: PPUSH
50212: CALL_OW 72
50216: PUSH
50217: LD_EXP 104
50221: PUSH
50222: LD_VAR 0 2
50226: ARRAY
50227: DIFF
50228: ST_TO_ADDR
// if not tmp then
50229: LD_VAR 0 5
50233: NOT
50234: IFFALSE 50238
// continue ;
50236: GO 50066
// for j in tmp do
50238: LD_ADDR_VAR 0 3
50242: PUSH
50243: LD_VAR 0 5
50247: PUSH
50248: FOR_IN
50249: IFFALSE 50461
// begin if not mc_builders [ i ] then
50251: LD_EXP 108
50255: PUSH
50256: LD_VAR 0 2
50260: ARRAY
50261: NOT
50262: IFFALSE 50320
// begin SetTag ( j , 103 ) ;
50264: LD_VAR 0 3
50268: PPUSH
50269: LD_INT 103
50271: PPUSH
50272: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50276: LD_ADDR_EXP 108
50280: PUSH
50281: LD_EXP 108
50285: PPUSH
50286: LD_VAR 0 2
50290: PUSH
50291: LD_EXP 108
50295: PUSH
50296: LD_VAR 0 2
50300: ARRAY
50301: PUSH
50302: LD_INT 1
50304: PLUS
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PPUSH
50310: LD_VAR 0 3
50314: PPUSH
50315: CALL 74680 0 3
50319: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50320: LD_VAR 0 3
50324: PPUSH
50325: CALL_OW 310
50329: IFFALSE 50340
// ComExitBuilding ( j ) ;
50331: LD_VAR 0 3
50335: PPUSH
50336: CALL_OW 122
// wait ( 3 ) ;
50340: LD_INT 3
50342: PPUSH
50343: CALL_OW 67
// if not mc_build_list [ i ] then
50347: LD_EXP 107
50351: PUSH
50352: LD_VAR 0 2
50356: ARRAY
50357: NOT
50358: IFFALSE 50362
// break ;
50360: GO 50461
// if not HasTask ( j ) then
50362: LD_VAR 0 3
50366: PPUSH
50367: CALL_OW 314
50371: NOT
50372: IFFALSE 50459
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50374: LD_VAR 0 3
50378: PPUSH
50379: LD_EXP 107
50383: PUSH
50384: LD_VAR 0 2
50388: ARRAY
50389: PUSH
50390: LD_INT 1
50392: ARRAY
50393: PUSH
50394: LD_INT 1
50396: ARRAY
50397: PPUSH
50398: LD_EXP 107
50402: PUSH
50403: LD_VAR 0 2
50407: ARRAY
50408: PUSH
50409: LD_INT 1
50411: ARRAY
50412: PUSH
50413: LD_INT 2
50415: ARRAY
50416: PPUSH
50417: LD_EXP 107
50421: PUSH
50422: LD_VAR 0 2
50426: ARRAY
50427: PUSH
50428: LD_INT 1
50430: ARRAY
50431: PUSH
50432: LD_INT 3
50434: ARRAY
50435: PPUSH
50436: LD_EXP 107
50440: PUSH
50441: LD_VAR 0 2
50445: ARRAY
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: PUSH
50451: LD_INT 4
50453: ARRAY
50454: PPUSH
50455: CALL_OW 145
// end ;
50459: GO 50248
50461: POP
50462: POP
// end else
50463: GO 50635
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50465: LD_EXP 102
50469: PUSH
50470: LD_VAR 0 2
50474: ARRAY
50475: PPUSH
50476: LD_EXP 107
50480: PUSH
50481: LD_VAR 0 2
50485: ARRAY
50486: PUSH
50487: LD_INT 1
50489: ARRAY
50490: PUSH
50491: LD_INT 1
50493: ARRAY
50494: PPUSH
50495: LD_EXP 107
50499: PUSH
50500: LD_VAR 0 2
50504: ARRAY
50505: PUSH
50506: LD_INT 1
50508: ARRAY
50509: PUSH
50510: LD_INT 2
50512: ARRAY
50513: PPUSH
50514: LD_EXP 107
50518: PUSH
50519: LD_VAR 0 2
50523: ARRAY
50524: PUSH
50525: LD_INT 1
50527: ARRAY
50528: PUSH
50529: LD_INT 3
50531: ARRAY
50532: PPUSH
50533: LD_EXP 107
50537: PUSH
50538: LD_VAR 0 2
50542: ARRAY
50543: PUSH
50544: LD_INT 1
50546: ARRAY
50547: PUSH
50548: LD_INT 4
50550: ARRAY
50551: PPUSH
50552: LD_EXP 102
50556: PUSH
50557: LD_VAR 0 2
50561: ARRAY
50562: PPUSH
50563: LD_INT 21
50565: PUSH
50566: LD_INT 3
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PPUSH
50573: CALL_OW 72
50577: PPUSH
50578: EMPTY
50579: PPUSH
50580: CALL 81908 0 7
50584: NOT
50585: IFFALSE 50635
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50587: LD_ADDR_EXP 107
50591: PUSH
50592: LD_EXP 107
50596: PPUSH
50597: LD_VAR 0 2
50601: PPUSH
50602: LD_EXP 107
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PPUSH
50613: LD_INT 1
50615: PPUSH
50616: LD_INT 1
50618: NEG
50619: PPUSH
50620: LD_INT 0
50622: PPUSH
50623: CALL 74098 0 4
50627: PPUSH
50628: CALL_OW 1
50632: ST_TO_ADDR
// continue ;
50633: GO 50066
// end ; end ;
50635: GO 50066
50637: POP
50638: POP
// end ; end ;
50639: GO 49495
50641: POP
50642: POP
// end ;
50643: LD_VAR 0 1
50647: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50648: LD_INT 0
50650: PPUSH
50651: PPUSH
50652: PPUSH
50653: PPUSH
50654: PPUSH
50655: PPUSH
// if not mc_bases then
50656: LD_EXP 102
50660: NOT
50661: IFFALSE 50665
// exit ;
50663: GO 51092
// for i = 1 to mc_bases do
50665: LD_ADDR_VAR 0 2
50669: PUSH
50670: DOUBLE
50671: LD_INT 1
50673: DEC
50674: ST_TO_ADDR
50675: LD_EXP 102
50679: PUSH
50680: FOR_TO
50681: IFFALSE 51090
// begin tmp := mc_build_upgrade [ i ] ;
50683: LD_ADDR_VAR 0 4
50687: PUSH
50688: LD_EXP 134
50692: PUSH
50693: LD_VAR 0 2
50697: ARRAY
50698: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50699: LD_ADDR_VAR 0 6
50703: PUSH
50704: LD_EXP 135
50708: PUSH
50709: LD_VAR 0 2
50713: ARRAY
50714: PPUSH
50715: LD_INT 2
50717: PUSH
50718: LD_INT 30
50720: PUSH
50721: LD_INT 6
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 30
50730: PUSH
50731: LD_INT 7
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: LIST
50742: PPUSH
50743: CALL_OW 72
50747: ST_TO_ADDR
// if not tmp and not lab then
50748: LD_VAR 0 4
50752: NOT
50753: PUSH
50754: LD_VAR 0 6
50758: NOT
50759: AND
50760: IFFALSE 50764
// continue ;
50762: GO 50680
// if tmp then
50764: LD_VAR 0 4
50768: IFFALSE 50888
// for j in tmp do
50770: LD_ADDR_VAR 0 3
50774: PUSH
50775: LD_VAR 0 4
50779: PUSH
50780: FOR_IN
50781: IFFALSE 50886
// begin if UpgradeCost ( j ) then
50783: LD_VAR 0 3
50787: PPUSH
50788: CALL 81568 0 1
50792: IFFALSE 50884
// begin ComUpgrade ( j ) ;
50794: LD_VAR 0 3
50798: PPUSH
50799: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50803: LD_ADDR_EXP 134
50807: PUSH
50808: LD_EXP 134
50812: PPUSH
50813: LD_VAR 0 2
50817: PPUSH
50818: LD_EXP 134
50822: PUSH
50823: LD_VAR 0 2
50827: ARRAY
50828: PUSH
50829: LD_VAR 0 3
50833: DIFF
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50840: LD_ADDR_EXP 109
50844: PUSH
50845: LD_EXP 109
50849: PPUSH
50850: LD_VAR 0 2
50854: PUSH
50855: LD_EXP 109
50859: PUSH
50860: LD_VAR 0 2
50864: ARRAY
50865: PUSH
50866: LD_INT 1
50868: PLUS
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PPUSH
50874: LD_VAR 0 3
50878: PPUSH
50879: CALL 74680 0 3
50883: ST_TO_ADDR
// end ; end ;
50884: GO 50780
50886: POP
50887: POP
// if not lab or not mc_lab_upgrade [ i ] then
50888: LD_VAR 0 6
50892: NOT
50893: PUSH
50894: LD_EXP 136
50898: PUSH
50899: LD_VAR 0 2
50903: ARRAY
50904: NOT
50905: OR
50906: IFFALSE 50910
// continue ;
50908: GO 50680
// for j in lab do
50910: LD_ADDR_VAR 0 3
50914: PUSH
50915: LD_VAR 0 6
50919: PUSH
50920: FOR_IN
50921: IFFALSE 51086
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50923: LD_VAR 0 3
50927: PPUSH
50928: CALL_OW 266
50932: PUSH
50933: LD_INT 6
50935: PUSH
50936: LD_INT 7
50938: PUSH
50939: EMPTY
50940: LIST
50941: LIST
50942: IN
50943: PUSH
50944: LD_VAR 0 3
50948: PPUSH
50949: CALL_OW 461
50953: PUSH
50954: LD_INT 1
50956: NONEQUAL
50957: AND
50958: IFFALSE 51084
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50960: LD_VAR 0 3
50964: PPUSH
50965: LD_EXP 136
50969: PUSH
50970: LD_VAR 0 2
50974: ARRAY
50975: PUSH
50976: LD_INT 1
50978: ARRAY
50979: PPUSH
50980: CALL 81773 0 2
50984: IFFALSE 51084
// begin ComCancel ( j ) ;
50986: LD_VAR 0 3
50990: PPUSH
50991: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50995: LD_VAR 0 3
50999: PPUSH
51000: LD_EXP 136
51004: PUSH
51005: LD_VAR 0 2
51009: ARRAY
51010: PUSH
51011: LD_INT 1
51013: ARRAY
51014: PPUSH
51015: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51019: LD_VAR 0 3
51023: PUSH
51024: LD_EXP 109
51028: PUSH
51029: LD_VAR 0 2
51033: ARRAY
51034: IN
51035: NOT
51036: IFFALSE 51082
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51038: LD_ADDR_EXP 109
51042: PUSH
51043: LD_EXP 109
51047: PPUSH
51048: LD_VAR 0 2
51052: PUSH
51053: LD_EXP 109
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_INT 1
51066: PLUS
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: PPUSH
51072: LD_VAR 0 3
51076: PPUSH
51077: CALL 74680 0 3
51081: ST_TO_ADDR
// break ;
51082: GO 51086
// end ; end ; end ;
51084: GO 50920
51086: POP
51087: POP
// end ;
51088: GO 50680
51090: POP
51091: POP
// end ;
51092: LD_VAR 0 1
51096: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51097: LD_INT 0
51099: PPUSH
51100: PPUSH
51101: PPUSH
51102: PPUSH
51103: PPUSH
51104: PPUSH
51105: PPUSH
51106: PPUSH
51107: PPUSH
// if not mc_bases then
51108: LD_EXP 102
51112: NOT
51113: IFFALSE 51117
// exit ;
51115: GO 51522
// for i = 1 to mc_bases do
51117: LD_ADDR_VAR 0 2
51121: PUSH
51122: DOUBLE
51123: LD_INT 1
51125: DEC
51126: ST_TO_ADDR
51127: LD_EXP 102
51131: PUSH
51132: FOR_TO
51133: IFFALSE 51520
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51135: LD_EXP 110
51139: PUSH
51140: LD_VAR 0 2
51144: ARRAY
51145: NOT
51146: PUSH
51147: LD_EXP 102
51151: PUSH
51152: LD_VAR 0 2
51156: ARRAY
51157: PPUSH
51158: LD_INT 30
51160: PUSH
51161: LD_INT 3
51163: PUSH
51164: EMPTY
51165: LIST
51166: LIST
51167: PPUSH
51168: CALL_OW 72
51172: NOT
51173: OR
51174: IFFALSE 51178
// continue ;
51176: GO 51132
// busy := false ;
51178: LD_ADDR_VAR 0 8
51182: PUSH
51183: LD_INT 0
51185: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51186: LD_ADDR_VAR 0 4
51190: PUSH
51191: LD_EXP 102
51195: PUSH
51196: LD_VAR 0 2
51200: ARRAY
51201: PPUSH
51202: LD_INT 30
51204: PUSH
51205: LD_INT 3
51207: PUSH
51208: EMPTY
51209: LIST
51210: LIST
51211: PPUSH
51212: CALL_OW 72
51216: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51217: LD_ADDR_VAR 0 6
51221: PUSH
51222: LD_EXP 110
51226: PUSH
51227: LD_VAR 0 2
51231: ARRAY
51232: PPUSH
51233: LD_INT 2
51235: PUSH
51236: LD_INT 30
51238: PUSH
51239: LD_INT 32
51241: PUSH
51242: EMPTY
51243: LIST
51244: LIST
51245: PUSH
51246: LD_INT 30
51248: PUSH
51249: LD_INT 33
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: PUSH
51256: EMPTY
51257: LIST
51258: LIST
51259: LIST
51260: PPUSH
51261: CALL_OW 72
51265: ST_TO_ADDR
// if not t then
51266: LD_VAR 0 6
51270: NOT
51271: IFFALSE 51275
// continue ;
51273: GO 51132
// for j in tmp do
51275: LD_ADDR_VAR 0 3
51279: PUSH
51280: LD_VAR 0 4
51284: PUSH
51285: FOR_IN
51286: IFFALSE 51316
// if not BuildingStatus ( j ) = bs_idle then
51288: LD_VAR 0 3
51292: PPUSH
51293: CALL_OW 461
51297: PUSH
51298: LD_INT 2
51300: EQUAL
51301: NOT
51302: IFFALSE 51314
// begin busy := true ;
51304: LD_ADDR_VAR 0 8
51308: PUSH
51309: LD_INT 1
51311: ST_TO_ADDR
// break ;
51312: GO 51316
// end ;
51314: GO 51285
51316: POP
51317: POP
// if busy then
51318: LD_VAR 0 8
51322: IFFALSE 51326
// continue ;
51324: GO 51132
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51326: LD_ADDR_VAR 0 7
51330: PUSH
51331: LD_VAR 0 6
51335: PPUSH
51336: LD_INT 35
51338: PUSH
51339: LD_INT 0
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PPUSH
51346: CALL_OW 72
51350: ST_TO_ADDR
// if tw then
51351: LD_VAR 0 7
51355: IFFALSE 51432
// begin tw := tw [ 1 ] ;
51357: LD_ADDR_VAR 0 7
51361: PUSH
51362: LD_VAR 0 7
51366: PUSH
51367: LD_INT 1
51369: ARRAY
51370: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51371: LD_ADDR_VAR 0 9
51375: PUSH
51376: LD_VAR 0 7
51380: PPUSH
51381: LD_EXP 127
51385: PUSH
51386: LD_VAR 0 2
51390: ARRAY
51391: PPUSH
51392: CALL 80065 0 2
51396: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51397: LD_EXP 141
51401: PUSH
51402: LD_VAR 0 2
51406: ARRAY
51407: IFFALSE 51430
// if not weapon in mc_allowed_tower_weapons [ i ] then
51409: LD_VAR 0 9
51413: PUSH
51414: LD_EXP 141
51418: PUSH
51419: LD_VAR 0 2
51423: ARRAY
51424: IN
51425: NOT
51426: IFFALSE 51430
// continue ;
51428: GO 51132
// end else
51430: GO 51495
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51432: LD_ADDR_VAR 0 5
51436: PUSH
51437: LD_EXP 110
51441: PUSH
51442: LD_VAR 0 2
51446: ARRAY
51447: PPUSH
51448: LD_VAR 0 4
51452: PPUSH
51453: CALL 106957 0 2
51457: ST_TO_ADDR
// if not tmp2 then
51458: LD_VAR 0 5
51462: NOT
51463: IFFALSE 51467
// continue ;
51465: GO 51132
// tw := tmp2 [ 1 ] ;
51467: LD_ADDR_VAR 0 7
51471: PUSH
51472: LD_VAR 0 5
51476: PUSH
51477: LD_INT 1
51479: ARRAY
51480: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51481: LD_ADDR_VAR 0 9
51485: PUSH
51486: LD_VAR 0 5
51490: PUSH
51491: LD_INT 2
51493: ARRAY
51494: ST_TO_ADDR
// end ; if not weapon then
51495: LD_VAR 0 9
51499: NOT
51500: IFFALSE 51504
// continue ;
51502: GO 51132
// ComPlaceWeapon ( tw , weapon ) ;
51504: LD_VAR 0 7
51508: PPUSH
51509: LD_VAR 0 9
51513: PPUSH
51514: CALL_OW 148
// end ;
51518: GO 51132
51520: POP
51521: POP
// end ;
51522: LD_VAR 0 1
51526: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51527: LD_INT 0
51529: PPUSH
51530: PPUSH
51531: PPUSH
51532: PPUSH
51533: PPUSH
51534: PPUSH
51535: PPUSH
// if not mc_bases then
51536: LD_EXP 102
51540: NOT
51541: IFFALSE 51545
// exit ;
51543: GO 52320
// for i = 1 to mc_bases do
51545: LD_ADDR_VAR 0 2
51549: PUSH
51550: DOUBLE
51551: LD_INT 1
51553: DEC
51554: ST_TO_ADDR
51555: LD_EXP 102
51559: PUSH
51560: FOR_TO
51561: IFFALSE 52318
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51563: LD_EXP 115
51567: PUSH
51568: LD_VAR 0 2
51572: ARRAY
51573: NOT
51574: PUSH
51575: LD_EXP 115
51579: PUSH
51580: LD_VAR 0 2
51584: ARRAY
51585: PUSH
51586: LD_EXP 116
51590: PUSH
51591: LD_VAR 0 2
51595: ARRAY
51596: EQUAL
51597: OR
51598: PUSH
51599: LD_EXP 125
51603: PUSH
51604: LD_VAR 0 2
51608: ARRAY
51609: OR
51610: IFFALSE 51614
// continue ;
51612: GO 51560
// if mc_miners [ i ] then
51614: LD_EXP 116
51618: PUSH
51619: LD_VAR 0 2
51623: ARRAY
51624: IFFALSE 52005
// begin for j = mc_miners [ i ] downto 1 do
51626: LD_ADDR_VAR 0 3
51630: PUSH
51631: DOUBLE
51632: LD_EXP 116
51636: PUSH
51637: LD_VAR 0 2
51641: ARRAY
51642: INC
51643: ST_TO_ADDR
51644: LD_INT 1
51646: PUSH
51647: FOR_DOWNTO
51648: IFFALSE 52003
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51650: LD_EXP 116
51654: PUSH
51655: LD_VAR 0 2
51659: ARRAY
51660: PUSH
51661: LD_VAR 0 3
51665: ARRAY
51666: PPUSH
51667: CALL_OW 301
51671: PUSH
51672: LD_EXP 116
51676: PUSH
51677: LD_VAR 0 2
51681: ARRAY
51682: PUSH
51683: LD_VAR 0 3
51687: ARRAY
51688: PPUSH
51689: CALL_OW 257
51693: PUSH
51694: LD_INT 1
51696: NONEQUAL
51697: OR
51698: IFFALSE 51761
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51700: LD_ADDR_VAR 0 5
51704: PUSH
51705: LD_EXP 116
51709: PUSH
51710: LD_VAR 0 2
51714: ARRAY
51715: PUSH
51716: LD_EXP 116
51720: PUSH
51721: LD_VAR 0 2
51725: ARRAY
51726: PUSH
51727: LD_VAR 0 3
51731: ARRAY
51732: DIFF
51733: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51734: LD_ADDR_EXP 116
51738: PUSH
51739: LD_EXP 116
51743: PPUSH
51744: LD_VAR 0 2
51748: PPUSH
51749: LD_VAR 0 5
51753: PPUSH
51754: CALL_OW 1
51758: ST_TO_ADDR
// continue ;
51759: GO 51647
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51761: LD_EXP 116
51765: PUSH
51766: LD_VAR 0 2
51770: ARRAY
51771: PUSH
51772: LD_VAR 0 3
51776: ARRAY
51777: PPUSH
51778: CALL_OW 257
51782: PUSH
51783: LD_INT 1
51785: EQUAL
51786: PUSH
51787: LD_EXP 116
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PUSH
51798: LD_VAR 0 3
51802: ARRAY
51803: PPUSH
51804: CALL_OW 459
51808: NOT
51809: AND
51810: PUSH
51811: LD_EXP 116
51815: PUSH
51816: LD_VAR 0 2
51820: ARRAY
51821: PUSH
51822: LD_VAR 0 3
51826: ARRAY
51827: PPUSH
51828: CALL_OW 314
51832: NOT
51833: AND
51834: IFFALSE 52001
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51836: LD_EXP 116
51840: PUSH
51841: LD_VAR 0 2
51845: ARRAY
51846: PUSH
51847: LD_VAR 0 3
51851: ARRAY
51852: PPUSH
51853: CALL_OW 310
51857: IFFALSE 51880
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51859: LD_EXP 116
51863: PUSH
51864: LD_VAR 0 2
51868: ARRAY
51869: PUSH
51870: LD_VAR 0 3
51874: ARRAY
51875: PPUSH
51876: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51880: LD_EXP 116
51884: PUSH
51885: LD_VAR 0 2
51889: ARRAY
51890: PUSH
51891: LD_VAR 0 3
51895: ARRAY
51896: PPUSH
51897: CALL_OW 314
51901: NOT
51902: IFFALSE 52001
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51904: LD_ADDR_VAR 0 7
51908: PUSH
51909: LD_VAR 0 3
51913: PUSH
51914: LD_EXP 115
51918: PUSH
51919: LD_VAR 0 2
51923: ARRAY
51924: PPUSH
51925: CALL 71820 0 1
51929: MOD
51930: PUSH
51931: LD_INT 1
51933: PLUS
51934: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51935: LD_EXP 116
51939: PUSH
51940: LD_VAR 0 2
51944: ARRAY
51945: PUSH
51946: LD_VAR 0 3
51950: ARRAY
51951: PPUSH
51952: LD_EXP 115
51956: PUSH
51957: LD_VAR 0 2
51961: ARRAY
51962: PUSH
51963: LD_VAR 0 7
51967: ARRAY
51968: PUSH
51969: LD_INT 1
51971: ARRAY
51972: PPUSH
51973: LD_EXP 115
51977: PUSH
51978: LD_VAR 0 2
51982: ARRAY
51983: PUSH
51984: LD_VAR 0 7
51988: ARRAY
51989: PUSH
51990: LD_INT 2
51992: ARRAY
51993: PPUSH
51994: LD_INT 0
51996: PPUSH
51997: CALL_OW 193
// end ; end ; end ;
52001: GO 51647
52003: POP
52004: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52005: LD_ADDR_VAR 0 5
52009: PUSH
52010: LD_EXP 102
52014: PUSH
52015: LD_VAR 0 2
52019: ARRAY
52020: PPUSH
52021: LD_INT 2
52023: PUSH
52024: LD_INT 30
52026: PUSH
52027: LD_INT 4
52029: PUSH
52030: EMPTY
52031: LIST
52032: LIST
52033: PUSH
52034: LD_INT 30
52036: PUSH
52037: LD_INT 5
52039: PUSH
52040: EMPTY
52041: LIST
52042: LIST
52043: PUSH
52044: LD_INT 30
52046: PUSH
52047: LD_INT 32
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: LIST
52058: LIST
52059: PPUSH
52060: CALL_OW 72
52064: ST_TO_ADDR
// if not tmp then
52065: LD_VAR 0 5
52069: NOT
52070: IFFALSE 52074
// continue ;
52072: GO 51560
// list := [ ] ;
52074: LD_ADDR_VAR 0 6
52078: PUSH
52079: EMPTY
52080: ST_TO_ADDR
// for j in tmp do
52081: LD_ADDR_VAR 0 3
52085: PUSH
52086: LD_VAR 0 5
52090: PUSH
52091: FOR_IN
52092: IFFALSE 52161
// begin for k in UnitsInside ( j ) do
52094: LD_ADDR_VAR 0 4
52098: PUSH
52099: LD_VAR 0 3
52103: PPUSH
52104: CALL_OW 313
52108: PUSH
52109: FOR_IN
52110: IFFALSE 52157
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52112: LD_VAR 0 4
52116: PPUSH
52117: CALL_OW 257
52121: PUSH
52122: LD_INT 1
52124: EQUAL
52125: PUSH
52126: LD_VAR 0 4
52130: PPUSH
52131: CALL_OW 459
52135: NOT
52136: AND
52137: IFFALSE 52155
// list := list ^ k ;
52139: LD_ADDR_VAR 0 6
52143: PUSH
52144: LD_VAR 0 6
52148: PUSH
52149: LD_VAR 0 4
52153: ADD
52154: ST_TO_ADDR
52155: GO 52109
52157: POP
52158: POP
// end ;
52159: GO 52091
52161: POP
52162: POP
// list := list diff mc_miners [ i ] ;
52163: LD_ADDR_VAR 0 6
52167: PUSH
52168: LD_VAR 0 6
52172: PUSH
52173: LD_EXP 116
52177: PUSH
52178: LD_VAR 0 2
52182: ARRAY
52183: DIFF
52184: ST_TO_ADDR
// if not list then
52185: LD_VAR 0 6
52189: NOT
52190: IFFALSE 52194
// continue ;
52192: GO 51560
// k := mc_mines [ i ] - mc_miners [ i ] ;
52194: LD_ADDR_VAR 0 4
52198: PUSH
52199: LD_EXP 115
52203: PUSH
52204: LD_VAR 0 2
52208: ARRAY
52209: PUSH
52210: LD_EXP 116
52214: PUSH
52215: LD_VAR 0 2
52219: ARRAY
52220: MINUS
52221: ST_TO_ADDR
// if k > list then
52222: LD_VAR 0 4
52226: PUSH
52227: LD_VAR 0 6
52231: GREATER
52232: IFFALSE 52244
// k := list ;
52234: LD_ADDR_VAR 0 4
52238: PUSH
52239: LD_VAR 0 6
52243: ST_TO_ADDR
// for j = 1 to k do
52244: LD_ADDR_VAR 0 3
52248: PUSH
52249: DOUBLE
52250: LD_INT 1
52252: DEC
52253: ST_TO_ADDR
52254: LD_VAR 0 4
52258: PUSH
52259: FOR_TO
52260: IFFALSE 52314
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52262: LD_ADDR_EXP 116
52266: PUSH
52267: LD_EXP 116
52271: PPUSH
52272: LD_VAR 0 2
52276: PUSH
52277: LD_EXP 116
52281: PUSH
52282: LD_VAR 0 2
52286: ARRAY
52287: PUSH
52288: LD_INT 1
52290: PLUS
52291: PUSH
52292: EMPTY
52293: LIST
52294: LIST
52295: PPUSH
52296: LD_VAR 0 6
52300: PUSH
52301: LD_VAR 0 3
52305: ARRAY
52306: PPUSH
52307: CALL 74680 0 3
52311: ST_TO_ADDR
52312: GO 52259
52314: POP
52315: POP
// end ;
52316: GO 51560
52318: POP
52319: POP
// end ;
52320: LD_VAR 0 1
52324: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52325: LD_INT 0
52327: PPUSH
52328: PPUSH
52329: PPUSH
52330: PPUSH
52331: PPUSH
52332: PPUSH
52333: PPUSH
52334: PPUSH
52335: PPUSH
52336: PPUSH
52337: PPUSH
// if not mc_bases then
52338: LD_EXP 102
52342: NOT
52343: IFFALSE 52347
// exit ;
52345: GO 54170
// for i = 1 to mc_bases do
52347: LD_ADDR_VAR 0 2
52351: PUSH
52352: DOUBLE
52353: LD_INT 1
52355: DEC
52356: ST_TO_ADDR
52357: LD_EXP 102
52361: PUSH
52362: FOR_TO
52363: IFFALSE 54168
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52365: LD_EXP 102
52369: PUSH
52370: LD_VAR 0 2
52374: ARRAY
52375: NOT
52376: PUSH
52377: LD_EXP 109
52381: PUSH
52382: LD_VAR 0 2
52386: ARRAY
52387: OR
52388: IFFALSE 52392
// continue ;
52390: GO 52362
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52392: LD_EXP 118
52396: PUSH
52397: LD_VAR 0 2
52401: ARRAY
52402: NOT
52403: PUSH
52404: LD_EXP 119
52408: PUSH
52409: LD_VAR 0 2
52413: ARRAY
52414: AND
52415: IFFALSE 52453
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52417: LD_ADDR_EXP 119
52421: PUSH
52422: LD_EXP 119
52426: PPUSH
52427: LD_VAR 0 2
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52439: LD_VAR 0 2
52443: PPUSH
52444: LD_INT 107
52446: PPUSH
52447: CALL 43179 0 2
// continue ;
52451: GO 52362
// end ; target := [ ] ;
52453: LD_ADDR_VAR 0 7
52457: PUSH
52458: EMPTY
52459: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52460: LD_ADDR_VAR 0 6
52464: PUSH
52465: LD_EXP 102
52469: PUSH
52470: LD_VAR 0 2
52474: ARRAY
52475: PUSH
52476: LD_INT 1
52478: ARRAY
52479: PPUSH
52480: CALL_OW 255
52484: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52485: LD_ADDR_VAR 0 9
52489: PUSH
52490: LD_EXP 102
52494: PUSH
52495: LD_VAR 0 2
52499: ARRAY
52500: PPUSH
52501: LD_INT 2
52503: PUSH
52504: LD_INT 30
52506: PUSH
52507: LD_INT 0
52509: PUSH
52510: EMPTY
52511: LIST
52512: LIST
52513: PUSH
52514: LD_INT 30
52516: PUSH
52517: LD_INT 1
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: LIST
52528: PPUSH
52529: CALL_OW 72
52533: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52534: LD_ADDR_VAR 0 3
52538: PUSH
52539: DOUBLE
52540: LD_EXP 118
52544: PUSH
52545: LD_VAR 0 2
52549: ARRAY
52550: INC
52551: ST_TO_ADDR
52552: LD_INT 1
52554: PUSH
52555: FOR_DOWNTO
52556: IFFALSE 52801
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52558: LD_EXP 118
52562: PUSH
52563: LD_VAR 0 2
52567: ARRAY
52568: PUSH
52569: LD_VAR 0 3
52573: ARRAY
52574: PUSH
52575: LD_INT 2
52577: ARRAY
52578: PPUSH
52579: LD_EXP 118
52583: PUSH
52584: LD_VAR 0 2
52588: ARRAY
52589: PUSH
52590: LD_VAR 0 3
52594: ARRAY
52595: PUSH
52596: LD_INT 3
52598: ARRAY
52599: PPUSH
52600: CALL_OW 488
52604: PUSH
52605: LD_EXP 118
52609: PUSH
52610: LD_VAR 0 2
52614: ARRAY
52615: PUSH
52616: LD_VAR 0 3
52620: ARRAY
52621: PUSH
52622: LD_INT 2
52624: ARRAY
52625: PPUSH
52626: LD_EXP 118
52630: PUSH
52631: LD_VAR 0 2
52635: ARRAY
52636: PUSH
52637: LD_VAR 0 3
52641: ARRAY
52642: PUSH
52643: LD_INT 3
52645: ARRAY
52646: PPUSH
52647: CALL_OW 284
52651: PUSH
52652: LD_INT 0
52654: EQUAL
52655: AND
52656: IFFALSE 52711
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52658: LD_ADDR_VAR 0 5
52662: PUSH
52663: LD_EXP 118
52667: PUSH
52668: LD_VAR 0 2
52672: ARRAY
52673: PPUSH
52674: LD_VAR 0 3
52678: PPUSH
52679: CALL_OW 3
52683: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52684: LD_ADDR_EXP 118
52688: PUSH
52689: LD_EXP 118
52693: PPUSH
52694: LD_VAR 0 2
52698: PPUSH
52699: LD_VAR 0 5
52703: PPUSH
52704: CALL_OW 1
52708: ST_TO_ADDR
// continue ;
52709: GO 52555
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52711: LD_VAR 0 6
52715: PPUSH
52716: LD_EXP 118
52720: PUSH
52721: LD_VAR 0 2
52725: ARRAY
52726: PUSH
52727: LD_VAR 0 3
52731: ARRAY
52732: PUSH
52733: LD_INT 2
52735: ARRAY
52736: PPUSH
52737: LD_EXP 118
52741: PUSH
52742: LD_VAR 0 2
52746: ARRAY
52747: PUSH
52748: LD_VAR 0 3
52752: ARRAY
52753: PUSH
52754: LD_INT 3
52756: ARRAY
52757: PPUSH
52758: LD_INT 30
52760: PPUSH
52761: CALL 75944 0 4
52765: PUSH
52766: LD_INT 4
52768: ARRAY
52769: PUSH
52770: LD_INT 0
52772: EQUAL
52773: IFFALSE 52799
// begin target := mc_crates [ i ] [ j ] ;
52775: LD_ADDR_VAR 0 7
52779: PUSH
52780: LD_EXP 118
52784: PUSH
52785: LD_VAR 0 2
52789: ARRAY
52790: PUSH
52791: LD_VAR 0 3
52795: ARRAY
52796: ST_TO_ADDR
// break ;
52797: GO 52801
// end ; end ;
52799: GO 52555
52801: POP
52802: POP
// if not target then
52803: LD_VAR 0 7
52807: NOT
52808: IFFALSE 52812
// continue ;
52810: GO 52362
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52812: LD_ADDR_VAR 0 8
52816: PUSH
52817: LD_EXP 121
52821: PUSH
52822: LD_VAR 0 2
52826: ARRAY
52827: PPUSH
52828: LD_INT 2
52830: PUSH
52831: LD_INT 3
52833: PUSH
52834: LD_INT 58
52836: PUSH
52837: EMPTY
52838: LIST
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: PUSH
52844: LD_INT 61
52846: PUSH
52847: EMPTY
52848: LIST
52849: PUSH
52850: LD_INT 33
52852: PUSH
52853: LD_INT 5
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PUSH
52860: LD_INT 33
52862: PUSH
52863: LD_INT 3
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: LIST
52874: LIST
52875: LIST
52876: PUSH
52877: LD_INT 2
52879: PUSH
52880: LD_INT 34
52882: PUSH
52883: LD_INT 32
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 34
52892: PUSH
52893: LD_INT 51
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: LD_INT 34
52902: PUSH
52903: LD_INT 12
52905: PUSH
52906: EMPTY
52907: LIST
52908: LIST
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: LIST
52914: LIST
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: PPUSH
52920: CALL_OW 72
52924: ST_TO_ADDR
// if not cargo then
52925: LD_VAR 0 8
52929: NOT
52930: IFFALSE 53636
// begin if mc_crates_collector [ i ] < 5 then
52932: LD_EXP 119
52936: PUSH
52937: LD_VAR 0 2
52941: ARRAY
52942: PUSH
52943: LD_INT 5
52945: LESS
52946: IFFALSE 53312
// begin if mc_ape [ i ] then
52948: LD_EXP 131
52952: PUSH
52953: LD_VAR 0 2
52957: ARRAY
52958: IFFALSE 53005
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52960: LD_ADDR_VAR 0 5
52964: PUSH
52965: LD_EXP 131
52969: PUSH
52970: LD_VAR 0 2
52974: ARRAY
52975: PPUSH
52976: LD_INT 25
52978: PUSH
52979: LD_INT 16
52981: PUSH
52982: EMPTY
52983: LIST
52984: LIST
52985: PUSH
52986: LD_INT 24
52988: PUSH
52989: LD_INT 750
52991: PUSH
52992: EMPTY
52993: LIST
52994: LIST
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: PPUSH
53000: CALL_OW 72
53004: ST_TO_ADDR
// if not tmp then
53005: LD_VAR 0 5
53009: NOT
53010: IFFALSE 53057
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53012: LD_ADDR_VAR 0 5
53016: PUSH
53017: LD_EXP 102
53021: PUSH
53022: LD_VAR 0 2
53026: ARRAY
53027: PPUSH
53028: LD_INT 25
53030: PUSH
53031: LD_INT 2
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: PUSH
53038: LD_INT 24
53040: PUSH
53041: LD_INT 750
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: PUSH
53048: EMPTY
53049: LIST
53050: LIST
53051: PPUSH
53052: CALL_OW 72
53056: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53057: LD_EXP 131
53061: PUSH
53062: LD_VAR 0 2
53066: ARRAY
53067: PUSH
53068: LD_EXP 102
53072: PUSH
53073: LD_VAR 0 2
53077: ARRAY
53078: PPUSH
53079: LD_INT 25
53081: PUSH
53082: LD_INT 2
53084: PUSH
53085: EMPTY
53086: LIST
53087: LIST
53088: PUSH
53089: LD_INT 24
53091: PUSH
53092: LD_INT 750
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: PUSH
53099: EMPTY
53100: LIST
53101: LIST
53102: PPUSH
53103: CALL_OW 72
53107: AND
53108: PUSH
53109: LD_VAR 0 5
53113: PUSH
53114: LD_INT 5
53116: LESS
53117: AND
53118: IFFALSE 53200
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53120: LD_ADDR_VAR 0 3
53124: PUSH
53125: LD_EXP 102
53129: PUSH
53130: LD_VAR 0 2
53134: ARRAY
53135: PPUSH
53136: LD_INT 25
53138: PUSH
53139: LD_INT 2
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 24
53148: PUSH
53149: LD_INT 750
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PPUSH
53160: CALL_OW 72
53164: PUSH
53165: FOR_IN
53166: IFFALSE 53198
// begin tmp := tmp union j ;
53168: LD_ADDR_VAR 0 5
53172: PUSH
53173: LD_VAR 0 5
53177: PUSH
53178: LD_VAR 0 3
53182: UNION
53183: ST_TO_ADDR
// if tmp >= 5 then
53184: LD_VAR 0 5
53188: PUSH
53189: LD_INT 5
53191: GREATEREQUAL
53192: IFFALSE 53196
// break ;
53194: GO 53198
// end ;
53196: GO 53165
53198: POP
53199: POP
// end ; if not tmp then
53200: LD_VAR 0 5
53204: NOT
53205: IFFALSE 53209
// continue ;
53207: GO 52362
// for j in tmp do
53209: LD_ADDR_VAR 0 3
53213: PUSH
53214: LD_VAR 0 5
53218: PUSH
53219: FOR_IN
53220: IFFALSE 53310
// if not GetTag ( j ) then
53222: LD_VAR 0 3
53226: PPUSH
53227: CALL_OW 110
53231: NOT
53232: IFFALSE 53308
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53234: LD_ADDR_EXP 119
53238: PUSH
53239: LD_EXP 119
53243: PPUSH
53244: LD_VAR 0 2
53248: PUSH
53249: LD_EXP 119
53253: PUSH
53254: LD_VAR 0 2
53258: ARRAY
53259: PUSH
53260: LD_INT 1
53262: PLUS
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: PPUSH
53268: LD_VAR 0 3
53272: PPUSH
53273: CALL 74680 0 3
53277: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53278: LD_VAR 0 3
53282: PPUSH
53283: LD_INT 107
53285: PPUSH
53286: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53290: LD_EXP 119
53294: PUSH
53295: LD_VAR 0 2
53299: ARRAY
53300: PUSH
53301: LD_INT 5
53303: GREATEREQUAL
53304: IFFALSE 53308
// break ;
53306: GO 53310
// end ;
53308: GO 53219
53310: POP
53311: POP
// end ; if mc_crates_collector [ i ] and target then
53312: LD_EXP 119
53316: PUSH
53317: LD_VAR 0 2
53321: ARRAY
53322: PUSH
53323: LD_VAR 0 7
53327: AND
53328: IFFALSE 53634
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53330: LD_EXP 119
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: PUSH
53341: LD_VAR 0 7
53345: PUSH
53346: LD_INT 1
53348: ARRAY
53349: LESS
53350: IFFALSE 53370
// tmp := mc_crates_collector [ i ] else
53352: LD_ADDR_VAR 0 5
53356: PUSH
53357: LD_EXP 119
53361: PUSH
53362: LD_VAR 0 2
53366: ARRAY
53367: ST_TO_ADDR
53368: GO 53384
// tmp := target [ 1 ] ;
53370: LD_ADDR_VAR 0 5
53374: PUSH
53375: LD_VAR 0 7
53379: PUSH
53380: LD_INT 1
53382: ARRAY
53383: ST_TO_ADDR
// k := 0 ;
53384: LD_ADDR_VAR 0 4
53388: PUSH
53389: LD_INT 0
53391: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53392: LD_ADDR_VAR 0 3
53396: PUSH
53397: LD_EXP 119
53401: PUSH
53402: LD_VAR 0 2
53406: ARRAY
53407: PUSH
53408: FOR_IN
53409: IFFALSE 53632
// begin k := k + 1 ;
53411: LD_ADDR_VAR 0 4
53415: PUSH
53416: LD_VAR 0 4
53420: PUSH
53421: LD_INT 1
53423: PLUS
53424: ST_TO_ADDR
// if k > tmp then
53425: LD_VAR 0 4
53429: PUSH
53430: LD_VAR 0 5
53434: GREATER
53435: IFFALSE 53439
// break ;
53437: GO 53632
// if not GetClass ( j ) in [ 2 , 16 ] then
53439: LD_VAR 0 3
53443: PPUSH
53444: CALL_OW 257
53448: PUSH
53449: LD_INT 2
53451: PUSH
53452: LD_INT 16
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: IN
53459: NOT
53460: IFFALSE 53513
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53462: LD_ADDR_EXP 119
53466: PUSH
53467: LD_EXP 119
53471: PPUSH
53472: LD_VAR 0 2
53476: PPUSH
53477: LD_EXP 119
53481: PUSH
53482: LD_VAR 0 2
53486: ARRAY
53487: PUSH
53488: LD_VAR 0 3
53492: DIFF
53493: PPUSH
53494: CALL_OW 1
53498: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53499: LD_VAR 0 3
53503: PPUSH
53504: LD_INT 0
53506: PPUSH
53507: CALL_OW 109
// continue ;
53511: GO 53408
// end ; if IsInUnit ( j ) then
53513: LD_VAR 0 3
53517: PPUSH
53518: CALL_OW 310
53522: IFFALSE 53533
// ComExitBuilding ( j ) ;
53524: LD_VAR 0 3
53528: PPUSH
53529: CALL_OW 122
// wait ( 3 ) ;
53533: LD_INT 3
53535: PPUSH
53536: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53540: LD_VAR 0 3
53544: PPUSH
53545: CALL_OW 314
53549: PUSH
53550: LD_VAR 0 6
53554: PPUSH
53555: LD_VAR 0 7
53559: PUSH
53560: LD_INT 2
53562: ARRAY
53563: PPUSH
53564: LD_VAR 0 7
53568: PUSH
53569: LD_INT 3
53571: ARRAY
53572: PPUSH
53573: LD_INT 30
53575: PPUSH
53576: CALL 75944 0 4
53580: PUSH
53581: LD_INT 4
53583: ARRAY
53584: AND
53585: IFFALSE 53603
// ComStandNearbyBuilding ( j , depot ) else
53587: LD_VAR 0 3
53591: PPUSH
53592: LD_VAR 0 9
53596: PPUSH
53597: CALL 71282 0 2
53601: GO 53630
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53603: LD_VAR 0 3
53607: PPUSH
53608: LD_VAR 0 7
53612: PUSH
53613: LD_INT 2
53615: ARRAY
53616: PPUSH
53617: LD_VAR 0 7
53621: PUSH
53622: LD_INT 3
53624: ARRAY
53625: PPUSH
53626: CALL_OW 117
// end ;
53630: GO 53408
53632: POP
53633: POP
// end ; end else
53634: GO 54166
// begin for j in cargo do
53636: LD_ADDR_VAR 0 3
53640: PUSH
53641: LD_VAR 0 8
53645: PUSH
53646: FOR_IN
53647: IFFALSE 54164
// begin if GetTag ( j ) <> 0 then
53649: LD_VAR 0 3
53653: PPUSH
53654: CALL_OW 110
53658: PUSH
53659: LD_INT 0
53661: NONEQUAL
53662: IFFALSE 53666
// continue ;
53664: GO 53646
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53666: LD_VAR 0 3
53670: PPUSH
53671: CALL_OW 256
53675: PUSH
53676: LD_INT 1000
53678: LESS
53679: PUSH
53680: LD_VAR 0 3
53684: PPUSH
53685: LD_EXP 126
53689: PUSH
53690: LD_VAR 0 2
53694: ARRAY
53695: PPUSH
53696: CALL_OW 308
53700: NOT
53701: AND
53702: IFFALSE 53724
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53704: LD_VAR 0 3
53708: PPUSH
53709: LD_EXP 126
53713: PUSH
53714: LD_VAR 0 2
53718: ARRAY
53719: PPUSH
53720: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53724: LD_VAR 0 3
53728: PPUSH
53729: CALL_OW 256
53733: PUSH
53734: LD_INT 1000
53736: LESS
53737: PUSH
53738: LD_VAR 0 3
53742: PPUSH
53743: LD_EXP 126
53747: PUSH
53748: LD_VAR 0 2
53752: ARRAY
53753: PPUSH
53754: CALL_OW 308
53758: AND
53759: IFFALSE 53763
// continue ;
53761: GO 53646
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53763: LD_VAR 0 3
53767: PPUSH
53768: CALL_OW 262
53772: PUSH
53773: LD_INT 2
53775: EQUAL
53776: PUSH
53777: LD_VAR 0 3
53781: PPUSH
53782: CALL_OW 261
53786: PUSH
53787: LD_INT 15
53789: LESS
53790: AND
53791: IFFALSE 53795
// continue ;
53793: GO 53646
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53795: LD_VAR 0 3
53799: PPUSH
53800: CALL_OW 262
53804: PUSH
53805: LD_INT 1
53807: EQUAL
53808: PUSH
53809: LD_VAR 0 3
53813: PPUSH
53814: CALL_OW 261
53818: PUSH
53819: LD_INT 10
53821: LESS
53822: AND
53823: IFFALSE 54103
// begin if not depot then
53825: LD_VAR 0 9
53829: NOT
53830: IFFALSE 53834
// continue ;
53832: GO 53646
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53834: LD_VAR 0 3
53838: PPUSH
53839: LD_VAR 0 9
53843: PPUSH
53844: LD_VAR 0 3
53848: PPUSH
53849: CALL_OW 74
53853: PPUSH
53854: CALL_OW 296
53858: PUSH
53859: LD_INT 6
53861: LESS
53862: IFFALSE 53878
// SetFuel ( j , 100 ) else
53864: LD_VAR 0 3
53868: PPUSH
53869: LD_INT 100
53871: PPUSH
53872: CALL_OW 240
53876: GO 54103
// if GetFuel ( j ) = 0 then
53878: LD_VAR 0 3
53882: PPUSH
53883: CALL_OW 261
53887: PUSH
53888: LD_INT 0
53890: EQUAL
53891: IFFALSE 54103
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53893: LD_ADDR_EXP 121
53897: PUSH
53898: LD_EXP 121
53902: PPUSH
53903: LD_VAR 0 2
53907: PPUSH
53908: LD_EXP 121
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: PUSH
53919: LD_VAR 0 3
53923: DIFF
53924: PPUSH
53925: CALL_OW 1
53929: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53930: LD_VAR 0 3
53934: PPUSH
53935: CALL_OW 263
53939: PUSH
53940: LD_INT 1
53942: EQUAL
53943: IFFALSE 53959
// ComExitVehicle ( IsInUnit ( j ) ) ;
53945: LD_VAR 0 3
53949: PPUSH
53950: CALL_OW 310
53954: PPUSH
53955: CALL_OW 121
// if GetControl ( j ) = control_remote then
53959: LD_VAR 0 3
53963: PPUSH
53964: CALL_OW 263
53968: PUSH
53969: LD_INT 2
53971: EQUAL
53972: IFFALSE 53983
// ComUnlink ( j ) ;
53974: LD_VAR 0 3
53978: PPUSH
53979: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53983: LD_ADDR_VAR 0 10
53987: PUSH
53988: LD_VAR 0 2
53992: PPUSH
53993: LD_INT 3
53995: PPUSH
53996: CALL 63747 0 2
54000: ST_TO_ADDR
// if fac then
54001: LD_VAR 0 10
54005: IFFALSE 54101
// begin for k in fac do
54007: LD_ADDR_VAR 0 4
54011: PUSH
54012: LD_VAR 0 10
54016: PUSH
54017: FOR_IN
54018: IFFALSE 54099
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54020: LD_ADDR_VAR 0 11
54024: PUSH
54025: LD_VAR 0 10
54029: PPUSH
54030: LD_VAR 0 3
54034: PPUSH
54035: CALL_OW 265
54039: PPUSH
54040: LD_VAR 0 3
54044: PPUSH
54045: CALL_OW 262
54049: PPUSH
54050: LD_VAR 0 3
54054: PPUSH
54055: CALL_OW 263
54059: PPUSH
54060: LD_VAR 0 3
54064: PPUSH
54065: CALL_OW 264
54069: PPUSH
54070: CALL 72178 0 5
54074: ST_TO_ADDR
// if components then
54075: LD_VAR 0 11
54079: IFFALSE 54097
// begin MC_InsertProduceList ( i , components ) ;
54081: LD_VAR 0 2
54085: PPUSH
54086: LD_VAR 0 11
54090: PPUSH
54091: CALL 63292 0 2
// break ;
54095: GO 54099
// end ; end ;
54097: GO 54017
54099: POP
54100: POP
// end ; continue ;
54101: GO 53646
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54103: LD_VAR 0 3
54107: PPUSH
54108: LD_INT 1
54110: PPUSH
54111: CALL_OW 289
54115: PUSH
54116: LD_INT 100
54118: LESS
54119: PUSH
54120: LD_VAR 0 3
54124: PPUSH
54125: CALL_OW 314
54129: NOT
54130: AND
54131: IFFALSE 54160
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54133: LD_VAR 0 3
54137: PPUSH
54138: LD_VAR 0 7
54142: PUSH
54143: LD_INT 2
54145: ARRAY
54146: PPUSH
54147: LD_VAR 0 7
54151: PUSH
54152: LD_INT 3
54154: ARRAY
54155: PPUSH
54156: CALL_OW 117
// break ;
54160: GO 54164
// end ;
54162: GO 53646
54164: POP
54165: POP
// end ; end ;
54166: GO 52362
54168: POP
54169: POP
// end ;
54170: LD_VAR 0 1
54174: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54175: LD_INT 0
54177: PPUSH
54178: PPUSH
54179: PPUSH
54180: PPUSH
// if not mc_bases then
54181: LD_EXP 102
54185: NOT
54186: IFFALSE 54190
// exit ;
54188: GO 54351
// for i = 1 to mc_bases do
54190: LD_ADDR_VAR 0 2
54194: PUSH
54195: DOUBLE
54196: LD_INT 1
54198: DEC
54199: ST_TO_ADDR
54200: LD_EXP 102
54204: PUSH
54205: FOR_TO
54206: IFFALSE 54349
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54208: LD_ADDR_VAR 0 4
54212: PUSH
54213: LD_EXP 121
54217: PUSH
54218: LD_VAR 0 2
54222: ARRAY
54223: PUSH
54224: LD_EXP 124
54228: PUSH
54229: LD_VAR 0 2
54233: ARRAY
54234: UNION
54235: PPUSH
54236: LD_INT 33
54238: PUSH
54239: LD_INT 2
54241: PUSH
54242: EMPTY
54243: LIST
54244: LIST
54245: PPUSH
54246: CALL_OW 72
54250: ST_TO_ADDR
// if tmp then
54251: LD_VAR 0 4
54255: IFFALSE 54347
// for j in tmp do
54257: LD_ADDR_VAR 0 3
54261: PUSH
54262: LD_VAR 0 4
54266: PUSH
54267: FOR_IN
54268: IFFALSE 54345
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54270: LD_VAR 0 3
54274: PPUSH
54275: CALL_OW 312
54279: NOT
54280: PUSH
54281: LD_VAR 0 3
54285: PPUSH
54286: CALL_OW 256
54290: PUSH
54291: LD_INT 250
54293: GREATEREQUAL
54294: AND
54295: IFFALSE 54308
// Connect ( j ) else
54297: LD_VAR 0 3
54301: PPUSH
54302: CALL 78026 0 1
54306: GO 54343
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54308: LD_VAR 0 3
54312: PPUSH
54313: CALL_OW 256
54317: PUSH
54318: LD_INT 250
54320: LESS
54321: PUSH
54322: LD_VAR 0 3
54326: PPUSH
54327: CALL_OW 312
54331: AND
54332: IFFALSE 54343
// ComUnlink ( j ) ;
54334: LD_VAR 0 3
54338: PPUSH
54339: CALL_OW 136
54343: GO 54267
54345: POP
54346: POP
// end ;
54347: GO 54205
54349: POP
54350: POP
// end ;
54351: LD_VAR 0 1
54355: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54356: LD_INT 0
54358: PPUSH
54359: PPUSH
54360: PPUSH
54361: PPUSH
54362: PPUSH
// if not mc_bases then
54363: LD_EXP 102
54367: NOT
54368: IFFALSE 54372
// exit ;
54370: GO 54817
// for i = 1 to mc_bases do
54372: LD_ADDR_VAR 0 2
54376: PUSH
54377: DOUBLE
54378: LD_INT 1
54380: DEC
54381: ST_TO_ADDR
54382: LD_EXP 102
54386: PUSH
54387: FOR_TO
54388: IFFALSE 54815
// begin if not mc_produce [ i ] then
54390: LD_EXP 123
54394: PUSH
54395: LD_VAR 0 2
54399: ARRAY
54400: NOT
54401: IFFALSE 54405
// continue ;
54403: GO 54387
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54405: LD_ADDR_VAR 0 5
54409: PUSH
54410: LD_EXP 102
54414: PUSH
54415: LD_VAR 0 2
54419: ARRAY
54420: PPUSH
54421: LD_INT 30
54423: PUSH
54424: LD_INT 3
54426: PUSH
54427: EMPTY
54428: LIST
54429: LIST
54430: PPUSH
54431: CALL_OW 72
54435: ST_TO_ADDR
// if not fac then
54436: LD_VAR 0 5
54440: NOT
54441: IFFALSE 54445
// continue ;
54443: GO 54387
// for j in fac do
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: LD_VAR 0 5
54454: PUSH
54455: FOR_IN
54456: IFFALSE 54811
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54458: LD_VAR 0 3
54462: PPUSH
54463: CALL_OW 461
54467: PUSH
54468: LD_INT 2
54470: NONEQUAL
54471: PUSH
54472: LD_VAR 0 3
54476: PPUSH
54477: LD_INT 15
54479: PPUSH
54480: CALL 77645 0 2
54484: PUSH
54485: LD_INT 4
54487: ARRAY
54488: OR
54489: IFFALSE 54493
// continue ;
54491: GO 54455
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54493: LD_VAR 0 3
54497: PPUSH
54498: LD_EXP 123
54502: PUSH
54503: LD_VAR 0 2
54507: ARRAY
54508: PUSH
54509: LD_INT 1
54511: ARRAY
54512: PUSH
54513: LD_INT 1
54515: ARRAY
54516: PPUSH
54517: LD_EXP 123
54521: PUSH
54522: LD_VAR 0 2
54526: ARRAY
54527: PUSH
54528: LD_INT 1
54530: ARRAY
54531: PUSH
54532: LD_INT 2
54534: ARRAY
54535: PPUSH
54536: LD_EXP 123
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: PUSH
54547: LD_INT 1
54549: ARRAY
54550: PUSH
54551: LD_INT 3
54553: ARRAY
54554: PPUSH
54555: LD_EXP 123
54559: PUSH
54560: LD_VAR 0 2
54564: ARRAY
54565: PUSH
54566: LD_INT 1
54568: ARRAY
54569: PUSH
54570: LD_INT 4
54572: ARRAY
54573: PPUSH
54574: CALL_OW 448
54578: PUSH
54579: LD_VAR 0 3
54583: PPUSH
54584: LD_EXP 123
54588: PUSH
54589: LD_VAR 0 2
54593: ARRAY
54594: PUSH
54595: LD_INT 1
54597: ARRAY
54598: PUSH
54599: LD_INT 1
54601: ARRAY
54602: PUSH
54603: LD_EXP 123
54607: PUSH
54608: LD_VAR 0 2
54612: ARRAY
54613: PUSH
54614: LD_INT 1
54616: ARRAY
54617: PUSH
54618: LD_INT 2
54620: ARRAY
54621: PUSH
54622: LD_EXP 123
54626: PUSH
54627: LD_VAR 0 2
54631: ARRAY
54632: PUSH
54633: LD_INT 1
54635: ARRAY
54636: PUSH
54637: LD_INT 3
54639: ARRAY
54640: PUSH
54641: LD_EXP 123
54645: PUSH
54646: LD_VAR 0 2
54650: ARRAY
54651: PUSH
54652: LD_INT 1
54654: ARRAY
54655: PUSH
54656: LD_INT 4
54658: ARRAY
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: PPUSH
54666: CALL 81421 0 2
54670: AND
54671: IFFALSE 54809
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54673: LD_VAR 0 3
54677: PPUSH
54678: LD_EXP 123
54682: PUSH
54683: LD_VAR 0 2
54687: ARRAY
54688: PUSH
54689: LD_INT 1
54691: ARRAY
54692: PUSH
54693: LD_INT 1
54695: ARRAY
54696: PPUSH
54697: LD_EXP 123
54701: PUSH
54702: LD_VAR 0 2
54706: ARRAY
54707: PUSH
54708: LD_INT 1
54710: ARRAY
54711: PUSH
54712: LD_INT 2
54714: ARRAY
54715: PPUSH
54716: LD_EXP 123
54720: PUSH
54721: LD_VAR 0 2
54725: ARRAY
54726: PUSH
54727: LD_INT 1
54729: ARRAY
54730: PUSH
54731: LD_INT 3
54733: ARRAY
54734: PPUSH
54735: LD_EXP 123
54739: PUSH
54740: LD_VAR 0 2
54744: ARRAY
54745: PUSH
54746: LD_INT 1
54748: ARRAY
54749: PUSH
54750: LD_INT 4
54752: ARRAY
54753: PPUSH
54754: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54758: LD_ADDR_VAR 0 4
54762: PUSH
54763: LD_EXP 123
54767: PUSH
54768: LD_VAR 0 2
54772: ARRAY
54773: PPUSH
54774: LD_INT 1
54776: PPUSH
54777: CALL_OW 3
54781: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54782: LD_ADDR_EXP 123
54786: PUSH
54787: LD_EXP 123
54791: PPUSH
54792: LD_VAR 0 2
54796: PPUSH
54797: LD_VAR 0 4
54801: PPUSH
54802: CALL_OW 1
54806: ST_TO_ADDR
// break ;
54807: GO 54811
// end ; end ;
54809: GO 54455
54811: POP
54812: POP
// end ;
54813: GO 54387
54815: POP
54816: POP
// end ;
54817: LD_VAR 0 1
54821: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54822: LD_INT 0
54824: PPUSH
54825: PPUSH
54826: PPUSH
// if not mc_bases then
54827: LD_EXP 102
54831: NOT
54832: IFFALSE 54836
// exit ;
54834: GO 54925
// for i = 1 to mc_bases do
54836: LD_ADDR_VAR 0 2
54840: PUSH
54841: DOUBLE
54842: LD_INT 1
54844: DEC
54845: ST_TO_ADDR
54846: LD_EXP 102
54850: PUSH
54851: FOR_TO
54852: IFFALSE 54923
// begin if mc_attack [ i ] then
54854: LD_EXP 122
54858: PUSH
54859: LD_VAR 0 2
54863: ARRAY
54864: IFFALSE 54921
// begin tmp := mc_attack [ i ] [ 1 ] ;
54866: LD_ADDR_VAR 0 3
54870: PUSH
54871: LD_EXP 122
54875: PUSH
54876: LD_VAR 0 2
54880: ARRAY
54881: PUSH
54882: LD_INT 1
54884: ARRAY
54885: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54886: LD_ADDR_EXP 122
54890: PUSH
54891: LD_EXP 122
54895: PPUSH
54896: LD_VAR 0 2
54900: PPUSH
54901: EMPTY
54902: PPUSH
54903: CALL_OW 1
54907: ST_TO_ADDR
// Attack ( tmp ) ;
54908: LD_VAR 0 3
54912: PPUSH
54913: CALL 133202 0 1
// exit ;
54917: POP
54918: POP
54919: GO 54925
// end ; end ;
54921: GO 54851
54923: POP
54924: POP
// end ;
54925: LD_VAR 0 1
54929: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54930: LD_INT 0
54932: PPUSH
54933: PPUSH
54934: PPUSH
54935: PPUSH
54936: PPUSH
54937: PPUSH
54938: PPUSH
// if not mc_bases then
54939: LD_EXP 102
54943: NOT
54944: IFFALSE 54948
// exit ;
54946: GO 55805
// for i = 1 to mc_bases do
54948: LD_ADDR_VAR 0 2
54952: PUSH
54953: DOUBLE
54954: LD_INT 1
54956: DEC
54957: ST_TO_ADDR
54958: LD_EXP 102
54962: PUSH
54963: FOR_TO
54964: IFFALSE 55803
// begin if not mc_bases [ i ] then
54966: LD_EXP 102
54970: PUSH
54971: LD_VAR 0 2
54975: ARRAY
54976: NOT
54977: IFFALSE 54981
// continue ;
54979: GO 54963
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54981: LD_ADDR_VAR 0 7
54985: PUSH
54986: LD_EXP 102
54990: PUSH
54991: LD_VAR 0 2
54995: ARRAY
54996: PUSH
54997: LD_INT 1
54999: ARRAY
55000: PPUSH
55001: CALL 71504 0 1
55005: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55006: LD_ADDR_EXP 125
55010: PUSH
55011: LD_EXP 125
55015: PPUSH
55016: LD_VAR 0 2
55020: PPUSH
55021: LD_EXP 102
55025: PUSH
55026: LD_VAR 0 2
55030: ARRAY
55031: PUSH
55032: LD_INT 1
55034: ARRAY
55035: PPUSH
55036: CALL_OW 255
55040: PPUSH
55041: LD_EXP 127
55045: PUSH
55046: LD_VAR 0 2
55050: ARRAY
55051: PPUSH
55052: CALL 71469 0 2
55056: PPUSH
55057: CALL_OW 1
55061: ST_TO_ADDR
// if not mc_scan [ i ] then
55062: LD_EXP 125
55066: PUSH
55067: LD_VAR 0 2
55071: ARRAY
55072: NOT
55073: IFFALSE 55251
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55075: LD_ADDR_EXP 145
55079: PUSH
55080: LD_EXP 145
55084: PPUSH
55085: LD_VAR 0 2
55089: PPUSH
55090: LD_INT 0
55092: PPUSH
55093: CALL_OW 1
55097: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55098: LD_ADDR_VAR 0 4
55102: PUSH
55103: LD_EXP 102
55107: PUSH
55108: LD_VAR 0 2
55112: ARRAY
55113: PPUSH
55114: LD_INT 2
55116: PUSH
55117: LD_INT 25
55119: PUSH
55120: LD_INT 5
55122: PUSH
55123: EMPTY
55124: LIST
55125: LIST
55126: PUSH
55127: LD_INT 25
55129: PUSH
55130: LD_INT 8
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: PUSH
55137: LD_INT 25
55139: PUSH
55140: LD_INT 9
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: PPUSH
55153: CALL_OW 72
55157: ST_TO_ADDR
// if not tmp then
55158: LD_VAR 0 4
55162: NOT
55163: IFFALSE 55167
// continue ;
55165: GO 54963
// for j in tmp do
55167: LD_ADDR_VAR 0 3
55171: PUSH
55172: LD_VAR 0 4
55176: PUSH
55177: FOR_IN
55178: IFFALSE 55249
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55180: LD_VAR 0 3
55184: PPUSH
55185: CALL_OW 310
55189: PPUSH
55190: CALL_OW 266
55194: PUSH
55195: LD_INT 5
55197: EQUAL
55198: PUSH
55199: LD_VAR 0 3
55203: PPUSH
55204: CALL_OW 257
55208: PUSH
55209: LD_INT 1
55211: EQUAL
55212: AND
55213: PUSH
55214: LD_VAR 0 3
55218: PPUSH
55219: CALL_OW 459
55223: NOT
55224: AND
55225: PUSH
55226: LD_VAR 0 7
55230: AND
55231: IFFALSE 55247
// ComChangeProfession ( j , class ) ;
55233: LD_VAR 0 3
55237: PPUSH
55238: LD_VAR 0 7
55242: PPUSH
55243: CALL_OW 123
55247: GO 55177
55249: POP
55250: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55251: LD_EXP 125
55255: PUSH
55256: LD_VAR 0 2
55260: ARRAY
55261: PUSH
55262: LD_EXP 145
55266: PUSH
55267: LD_VAR 0 2
55271: ARRAY
55272: NOT
55273: AND
55274: PUSH
55275: LD_EXP 124
55279: PUSH
55280: LD_VAR 0 2
55284: ARRAY
55285: NOT
55286: AND
55287: PUSH
55288: LD_EXP 102
55292: PUSH
55293: LD_VAR 0 2
55297: ARRAY
55298: PPUSH
55299: LD_INT 50
55301: PUSH
55302: EMPTY
55303: LIST
55304: PUSH
55305: LD_INT 2
55307: PUSH
55308: LD_INT 30
55310: PUSH
55311: LD_INT 32
55313: PUSH
55314: EMPTY
55315: LIST
55316: LIST
55317: PUSH
55318: LD_INT 30
55320: PUSH
55321: LD_INT 33
55323: PUSH
55324: EMPTY
55325: LIST
55326: LIST
55327: PUSH
55328: LD_INT 30
55330: PUSH
55331: LD_INT 4
55333: PUSH
55334: EMPTY
55335: LIST
55336: LIST
55337: PUSH
55338: LD_INT 30
55340: PUSH
55341: LD_INT 5
55343: PUSH
55344: EMPTY
55345: LIST
55346: LIST
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: LIST
55352: LIST
55353: LIST
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: PPUSH
55359: CALL_OW 72
55363: PUSH
55364: LD_INT 4
55366: LESS
55367: PUSH
55368: LD_EXP 102
55372: PUSH
55373: LD_VAR 0 2
55377: ARRAY
55378: PPUSH
55379: LD_INT 3
55381: PUSH
55382: LD_INT 24
55384: PUSH
55385: LD_INT 1000
55387: PUSH
55388: EMPTY
55389: LIST
55390: LIST
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PUSH
55396: LD_INT 2
55398: PUSH
55399: LD_INT 30
55401: PUSH
55402: LD_INT 0
55404: PUSH
55405: EMPTY
55406: LIST
55407: LIST
55408: PUSH
55409: LD_INT 30
55411: PUSH
55412: LD_INT 1
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: PPUSH
55428: CALL_OW 72
55432: OR
55433: AND
55434: IFFALSE 55685
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55436: LD_ADDR_EXP 145
55440: PUSH
55441: LD_EXP 145
55445: PPUSH
55446: LD_VAR 0 2
55450: PPUSH
55451: LD_INT 1
55453: PPUSH
55454: CALL_OW 1
55458: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55459: LD_ADDR_VAR 0 4
55463: PUSH
55464: LD_EXP 102
55468: PUSH
55469: LD_VAR 0 2
55473: ARRAY
55474: PPUSH
55475: LD_INT 2
55477: PUSH
55478: LD_INT 25
55480: PUSH
55481: LD_INT 1
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: PUSH
55488: LD_INT 25
55490: PUSH
55491: LD_INT 5
55493: PUSH
55494: EMPTY
55495: LIST
55496: LIST
55497: PUSH
55498: LD_INT 25
55500: PUSH
55501: LD_INT 8
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: PUSH
55508: LD_INT 25
55510: PUSH
55511: LD_INT 9
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: LIST
55522: LIST
55523: LIST
55524: PPUSH
55525: CALL_OW 72
55529: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55530: LD_ADDR_VAR 0 4
55534: PUSH
55535: LD_VAR 0 4
55539: PUSH
55540: LD_VAR 0 4
55544: PPUSH
55545: LD_INT 18
55547: PPUSH
55548: CALL 104978 0 2
55552: DIFF
55553: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55554: LD_VAR 0 4
55558: NOT
55559: PUSH
55560: LD_EXP 102
55564: PUSH
55565: LD_VAR 0 2
55569: ARRAY
55570: PPUSH
55571: LD_INT 2
55573: PUSH
55574: LD_INT 30
55576: PUSH
55577: LD_INT 4
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: PUSH
55584: LD_INT 30
55586: PUSH
55587: LD_INT 5
55589: PUSH
55590: EMPTY
55591: LIST
55592: LIST
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: PPUSH
55599: CALL_OW 72
55603: NOT
55604: AND
55605: IFFALSE 55667
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55607: LD_ADDR_VAR 0 4
55611: PUSH
55612: LD_EXP 102
55616: PUSH
55617: LD_VAR 0 2
55621: ARRAY
55622: PPUSH
55623: LD_INT 2
55625: PUSH
55626: LD_INT 25
55628: PUSH
55629: LD_INT 2
55631: PUSH
55632: EMPTY
55633: LIST
55634: LIST
55635: PUSH
55636: LD_INT 25
55638: PUSH
55639: LD_INT 3
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: PUSH
55646: LD_INT 25
55648: PUSH
55649: LD_INT 4
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: LIST
55660: LIST
55661: PPUSH
55662: CALL_OW 72
55666: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55667: LD_VAR 0 2
55671: PPUSH
55672: LD_VAR 0 4
55676: PPUSH
55677: CALL 137911 0 2
// exit ;
55681: POP
55682: POP
55683: GO 55805
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55685: LD_EXP 125
55689: PUSH
55690: LD_VAR 0 2
55694: ARRAY
55695: PUSH
55696: LD_EXP 145
55700: PUSH
55701: LD_VAR 0 2
55705: ARRAY
55706: NOT
55707: AND
55708: PUSH
55709: LD_EXP 124
55713: PUSH
55714: LD_VAR 0 2
55718: ARRAY
55719: AND
55720: IFFALSE 55801
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55722: LD_ADDR_EXP 145
55726: PUSH
55727: LD_EXP 145
55731: PPUSH
55732: LD_VAR 0 2
55736: PPUSH
55737: LD_INT 1
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55745: LD_ADDR_VAR 0 4
55749: PUSH
55750: LD_EXP 124
55754: PUSH
55755: LD_VAR 0 2
55759: ARRAY
55760: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55761: LD_ADDR_EXP 124
55765: PUSH
55766: LD_EXP 124
55770: PPUSH
55771: LD_VAR 0 2
55775: PPUSH
55776: EMPTY
55777: PPUSH
55778: CALL_OW 1
55782: ST_TO_ADDR
// Defend ( i , tmp ) ;
55783: LD_VAR 0 2
55787: PPUSH
55788: LD_VAR 0 4
55792: PPUSH
55793: CALL 138507 0 2
// exit ;
55797: POP
55798: POP
55799: GO 55805
// end ; end ;
55801: GO 54963
55803: POP
55804: POP
// end ;
55805: LD_VAR 0 1
55809: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55810: LD_INT 0
55812: PPUSH
55813: PPUSH
55814: PPUSH
55815: PPUSH
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
55820: PPUSH
55821: PPUSH
55822: PPUSH
// if not mc_bases then
55823: LD_EXP 102
55827: NOT
55828: IFFALSE 55832
// exit ;
55830: GO 56919
// for i = 1 to mc_bases do
55832: LD_ADDR_VAR 0 2
55836: PUSH
55837: DOUBLE
55838: LD_INT 1
55840: DEC
55841: ST_TO_ADDR
55842: LD_EXP 102
55846: PUSH
55847: FOR_TO
55848: IFFALSE 56917
// begin tmp := mc_lab [ i ] ;
55850: LD_ADDR_VAR 0 6
55854: PUSH
55855: LD_EXP 135
55859: PUSH
55860: LD_VAR 0 2
55864: ARRAY
55865: ST_TO_ADDR
// if not tmp then
55866: LD_VAR 0 6
55870: NOT
55871: IFFALSE 55875
// continue ;
55873: GO 55847
// idle_lab := 0 ;
55875: LD_ADDR_VAR 0 11
55879: PUSH
55880: LD_INT 0
55882: ST_TO_ADDR
// for j in tmp do
55883: LD_ADDR_VAR 0 3
55887: PUSH
55888: LD_VAR 0 6
55892: PUSH
55893: FOR_IN
55894: IFFALSE 56913
// begin researching := false ;
55896: LD_ADDR_VAR 0 10
55900: PUSH
55901: LD_INT 0
55903: ST_TO_ADDR
// side := GetSide ( j ) ;
55904: LD_ADDR_VAR 0 4
55908: PUSH
55909: LD_VAR 0 3
55913: PPUSH
55914: CALL_OW 255
55918: ST_TO_ADDR
// if not mc_tech [ side ] then
55919: LD_EXP 129
55923: PUSH
55924: LD_VAR 0 4
55928: ARRAY
55929: NOT
55930: IFFALSE 55934
// continue ;
55932: GO 55893
// if BuildingStatus ( j ) = bs_idle then
55934: LD_VAR 0 3
55938: PPUSH
55939: CALL_OW 461
55943: PUSH
55944: LD_INT 2
55946: EQUAL
55947: IFFALSE 56135
// begin if idle_lab and UnitsInside ( j ) < 6 then
55949: LD_VAR 0 11
55953: PUSH
55954: LD_VAR 0 3
55958: PPUSH
55959: CALL_OW 313
55963: PUSH
55964: LD_INT 6
55966: LESS
55967: AND
55968: IFFALSE 56039
// begin tmp2 := UnitsInside ( idle_lab ) ;
55970: LD_ADDR_VAR 0 9
55974: PUSH
55975: LD_VAR 0 11
55979: PPUSH
55980: CALL_OW 313
55984: ST_TO_ADDR
// if tmp2 then
55985: LD_VAR 0 9
55989: IFFALSE 56031
// for x in tmp2 do
55991: LD_ADDR_VAR 0 7
55995: PUSH
55996: LD_VAR 0 9
56000: PUSH
56001: FOR_IN
56002: IFFALSE 56029
// begin ComExitBuilding ( x ) ;
56004: LD_VAR 0 7
56008: PPUSH
56009: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56013: LD_VAR 0 7
56017: PPUSH
56018: LD_VAR 0 3
56022: PPUSH
56023: CALL_OW 180
// end ;
56027: GO 56001
56029: POP
56030: POP
// idle_lab := 0 ;
56031: LD_ADDR_VAR 0 11
56035: PUSH
56036: LD_INT 0
56038: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56039: LD_ADDR_VAR 0 5
56043: PUSH
56044: LD_EXP 129
56048: PUSH
56049: LD_VAR 0 4
56053: ARRAY
56054: PUSH
56055: FOR_IN
56056: IFFALSE 56116
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56058: LD_VAR 0 3
56062: PPUSH
56063: LD_VAR 0 5
56067: PPUSH
56068: CALL_OW 430
56072: PUSH
56073: LD_VAR 0 4
56077: PPUSH
56078: LD_VAR 0 5
56082: PPUSH
56083: CALL 70574 0 2
56087: AND
56088: IFFALSE 56114
// begin researching := true ;
56090: LD_ADDR_VAR 0 10
56094: PUSH
56095: LD_INT 1
56097: ST_TO_ADDR
// ComResearch ( j , t ) ;
56098: LD_VAR 0 3
56102: PPUSH
56103: LD_VAR 0 5
56107: PPUSH
56108: CALL_OW 124
// break ;
56112: GO 56116
// end ;
56114: GO 56055
56116: POP
56117: POP
// if not researching then
56118: LD_VAR 0 10
56122: NOT
56123: IFFALSE 56135
// idle_lab := j ;
56125: LD_ADDR_VAR 0 11
56129: PUSH
56130: LD_VAR 0 3
56134: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56135: LD_VAR 0 3
56139: PPUSH
56140: CALL_OW 461
56144: PUSH
56145: LD_INT 10
56147: EQUAL
56148: IFFALSE 56736
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56150: LD_EXP 131
56154: PUSH
56155: LD_VAR 0 2
56159: ARRAY
56160: NOT
56161: PUSH
56162: LD_EXP 132
56166: PUSH
56167: LD_VAR 0 2
56171: ARRAY
56172: NOT
56173: AND
56174: PUSH
56175: LD_EXP 129
56179: PUSH
56180: LD_VAR 0 4
56184: ARRAY
56185: PUSH
56186: LD_INT 1
56188: GREATER
56189: AND
56190: IFFALSE 56321
// begin ComCancel ( j ) ;
56192: LD_VAR 0 3
56196: PPUSH
56197: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56201: LD_ADDR_EXP 129
56205: PUSH
56206: LD_EXP 129
56210: PPUSH
56211: LD_VAR 0 4
56215: PPUSH
56216: LD_EXP 129
56220: PUSH
56221: LD_VAR 0 4
56225: ARRAY
56226: PPUSH
56227: LD_EXP 129
56231: PUSH
56232: LD_VAR 0 4
56236: ARRAY
56237: PUSH
56238: LD_INT 1
56240: MINUS
56241: PPUSH
56242: LD_EXP 129
56246: PUSH
56247: LD_VAR 0 4
56251: ARRAY
56252: PPUSH
56253: LD_INT 0
56255: PPUSH
56256: CALL 74098 0 4
56260: PPUSH
56261: CALL_OW 1
56265: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56266: LD_ADDR_EXP 129
56270: PUSH
56271: LD_EXP 129
56275: PPUSH
56276: LD_VAR 0 4
56280: PPUSH
56281: LD_EXP 129
56285: PUSH
56286: LD_VAR 0 4
56290: ARRAY
56291: PPUSH
56292: LD_EXP 129
56296: PUSH
56297: LD_VAR 0 4
56301: ARRAY
56302: PPUSH
56303: LD_INT 1
56305: PPUSH
56306: LD_INT 0
56308: PPUSH
56309: CALL 74098 0 4
56313: PPUSH
56314: CALL_OW 1
56318: ST_TO_ADDR
// continue ;
56319: GO 55893
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56321: LD_EXP 131
56325: PUSH
56326: LD_VAR 0 2
56330: ARRAY
56331: PUSH
56332: LD_EXP 132
56336: PUSH
56337: LD_VAR 0 2
56341: ARRAY
56342: NOT
56343: AND
56344: IFFALSE 56471
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56346: LD_ADDR_EXP 132
56350: PUSH
56351: LD_EXP 132
56355: PPUSH
56356: LD_VAR 0 2
56360: PUSH
56361: LD_EXP 132
56365: PUSH
56366: LD_VAR 0 2
56370: ARRAY
56371: PUSH
56372: LD_INT 1
56374: PLUS
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: PPUSH
56380: LD_EXP 131
56384: PUSH
56385: LD_VAR 0 2
56389: ARRAY
56390: PUSH
56391: LD_INT 1
56393: ARRAY
56394: PPUSH
56395: CALL 74680 0 3
56399: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56400: LD_EXP 131
56404: PUSH
56405: LD_VAR 0 2
56409: ARRAY
56410: PUSH
56411: LD_INT 1
56413: ARRAY
56414: PPUSH
56415: LD_INT 112
56417: PPUSH
56418: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56422: LD_ADDR_VAR 0 9
56426: PUSH
56427: LD_EXP 131
56431: PUSH
56432: LD_VAR 0 2
56436: ARRAY
56437: PPUSH
56438: LD_INT 1
56440: PPUSH
56441: CALL_OW 3
56445: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56446: LD_ADDR_EXP 131
56450: PUSH
56451: LD_EXP 131
56455: PPUSH
56456: LD_VAR 0 2
56460: PPUSH
56461: LD_VAR 0 9
56465: PPUSH
56466: CALL_OW 1
56470: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56471: LD_EXP 131
56475: PUSH
56476: LD_VAR 0 2
56480: ARRAY
56481: PUSH
56482: LD_EXP 132
56486: PUSH
56487: LD_VAR 0 2
56491: ARRAY
56492: AND
56493: PUSH
56494: LD_EXP 132
56498: PUSH
56499: LD_VAR 0 2
56503: ARRAY
56504: PUSH
56505: LD_INT 1
56507: ARRAY
56508: PPUSH
56509: CALL_OW 310
56513: NOT
56514: AND
56515: PUSH
56516: LD_VAR 0 3
56520: PPUSH
56521: CALL_OW 313
56525: PUSH
56526: LD_INT 6
56528: EQUAL
56529: AND
56530: IFFALSE 56586
// begin tmp2 := UnitsInside ( j ) ;
56532: LD_ADDR_VAR 0 9
56536: PUSH
56537: LD_VAR 0 3
56541: PPUSH
56542: CALL_OW 313
56546: ST_TO_ADDR
// if tmp2 = 6 then
56547: LD_VAR 0 9
56551: PUSH
56552: LD_INT 6
56554: EQUAL
56555: IFFALSE 56586
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56557: LD_VAR 0 9
56561: PUSH
56562: LD_INT 1
56564: ARRAY
56565: PPUSH
56566: LD_INT 112
56568: PPUSH
56569: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56573: LD_VAR 0 9
56577: PUSH
56578: LD_INT 1
56580: ARRAY
56581: PPUSH
56582: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56586: LD_EXP 132
56590: PUSH
56591: LD_VAR 0 2
56595: ARRAY
56596: PUSH
56597: LD_EXP 132
56601: PUSH
56602: LD_VAR 0 2
56606: ARRAY
56607: PUSH
56608: LD_INT 1
56610: ARRAY
56611: PPUSH
56612: CALL_OW 314
56616: NOT
56617: AND
56618: PUSH
56619: LD_EXP 132
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PUSH
56630: LD_INT 1
56632: ARRAY
56633: PPUSH
56634: CALL_OW 310
56638: NOT
56639: AND
56640: IFFALSE 56666
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56642: LD_EXP 132
56646: PUSH
56647: LD_VAR 0 2
56651: ARRAY
56652: PUSH
56653: LD_INT 1
56655: ARRAY
56656: PPUSH
56657: LD_VAR 0 3
56661: PPUSH
56662: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56666: LD_EXP 132
56670: PUSH
56671: LD_VAR 0 2
56675: ARRAY
56676: PUSH
56677: LD_INT 1
56679: ARRAY
56680: PPUSH
56681: CALL_OW 310
56685: PUSH
56686: LD_EXP 132
56690: PUSH
56691: LD_VAR 0 2
56695: ARRAY
56696: PUSH
56697: LD_INT 1
56699: ARRAY
56700: PPUSH
56701: CALL_OW 310
56705: PPUSH
56706: CALL_OW 461
56710: PUSH
56711: LD_INT 3
56713: NONEQUAL
56714: AND
56715: IFFALSE 56736
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56717: LD_EXP 132
56721: PUSH
56722: LD_VAR 0 2
56726: ARRAY
56727: PUSH
56728: LD_INT 1
56730: ARRAY
56731: PPUSH
56732: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56736: LD_VAR 0 3
56740: PPUSH
56741: CALL_OW 461
56745: PUSH
56746: LD_INT 6
56748: EQUAL
56749: PUSH
56750: LD_VAR 0 6
56754: PUSH
56755: LD_INT 1
56757: GREATER
56758: AND
56759: IFFALSE 56911
// begin sci := [ ] ;
56761: LD_ADDR_VAR 0 8
56765: PUSH
56766: EMPTY
56767: ST_TO_ADDR
// for x in ( tmp diff j ) do
56768: LD_ADDR_VAR 0 7
56772: PUSH
56773: LD_VAR 0 6
56777: PUSH
56778: LD_VAR 0 3
56782: DIFF
56783: PUSH
56784: FOR_IN
56785: IFFALSE 56837
// begin if sci = 6 then
56787: LD_VAR 0 8
56791: PUSH
56792: LD_INT 6
56794: EQUAL
56795: IFFALSE 56799
// break ;
56797: GO 56837
// if BuildingStatus ( x ) = bs_idle then
56799: LD_VAR 0 7
56803: PPUSH
56804: CALL_OW 461
56808: PUSH
56809: LD_INT 2
56811: EQUAL
56812: IFFALSE 56835
// sci := sci ^ UnitsInside ( x ) ;
56814: LD_ADDR_VAR 0 8
56818: PUSH
56819: LD_VAR 0 8
56823: PUSH
56824: LD_VAR 0 7
56828: PPUSH
56829: CALL_OW 313
56833: ADD
56834: ST_TO_ADDR
// end ;
56835: GO 56784
56837: POP
56838: POP
// if not sci then
56839: LD_VAR 0 8
56843: NOT
56844: IFFALSE 56848
// continue ;
56846: GO 55893
// for x in sci do
56848: LD_ADDR_VAR 0 7
56852: PUSH
56853: LD_VAR 0 8
56857: PUSH
56858: FOR_IN
56859: IFFALSE 56909
// if IsInUnit ( x ) and not HasTask ( x ) then
56861: LD_VAR 0 7
56865: PPUSH
56866: CALL_OW 310
56870: PUSH
56871: LD_VAR 0 7
56875: PPUSH
56876: CALL_OW 314
56880: NOT
56881: AND
56882: IFFALSE 56907
// begin ComExitBuilding ( x ) ;
56884: LD_VAR 0 7
56888: PPUSH
56889: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56893: LD_VAR 0 7
56897: PPUSH
56898: LD_VAR 0 3
56902: PPUSH
56903: CALL_OW 180
// end ;
56907: GO 56858
56909: POP
56910: POP
// end ; end ;
56911: GO 55893
56913: POP
56914: POP
// end ;
56915: GO 55847
56917: POP
56918: POP
// end ;
56919: LD_VAR 0 1
56923: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56924: LD_INT 0
56926: PPUSH
56927: PPUSH
// if not mc_bases then
56928: LD_EXP 102
56932: NOT
56933: IFFALSE 56937
// exit ;
56935: GO 57018
// for i = 1 to mc_bases do
56937: LD_ADDR_VAR 0 2
56941: PUSH
56942: DOUBLE
56943: LD_INT 1
56945: DEC
56946: ST_TO_ADDR
56947: LD_EXP 102
56951: PUSH
56952: FOR_TO
56953: IFFALSE 57016
// if mc_mines [ i ] and mc_miners [ i ] then
56955: LD_EXP 115
56959: PUSH
56960: LD_VAR 0 2
56964: ARRAY
56965: PUSH
56966: LD_EXP 116
56970: PUSH
56971: LD_VAR 0 2
56975: ARRAY
56976: AND
56977: IFFALSE 57014
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56979: LD_EXP 116
56983: PUSH
56984: LD_VAR 0 2
56988: ARRAY
56989: PUSH
56990: LD_INT 1
56992: ARRAY
56993: PPUSH
56994: CALL_OW 255
56998: PPUSH
56999: LD_EXP 115
57003: PUSH
57004: LD_VAR 0 2
57008: ARRAY
57009: PPUSH
57010: CALL 71657 0 2
57014: GO 56952
57016: POP
57017: POP
// end ;
57018: LD_VAR 0 1
57022: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57023: LD_INT 0
57025: PPUSH
57026: PPUSH
57027: PPUSH
57028: PPUSH
57029: PPUSH
57030: PPUSH
57031: PPUSH
57032: PPUSH
// if not mc_bases or not mc_parking then
57033: LD_EXP 102
57037: NOT
57038: PUSH
57039: LD_EXP 126
57043: NOT
57044: OR
57045: IFFALSE 57049
// exit ;
57047: GO 57787
// for i = 1 to mc_bases do
57049: LD_ADDR_VAR 0 2
57053: PUSH
57054: DOUBLE
57055: LD_INT 1
57057: DEC
57058: ST_TO_ADDR
57059: LD_EXP 102
57063: PUSH
57064: FOR_TO
57065: IFFALSE 57785
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57067: LD_EXP 102
57071: PUSH
57072: LD_VAR 0 2
57076: ARRAY
57077: NOT
57078: PUSH
57079: LD_EXP 126
57083: PUSH
57084: LD_VAR 0 2
57088: ARRAY
57089: NOT
57090: OR
57091: IFFALSE 57095
// continue ;
57093: GO 57064
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57095: LD_ADDR_VAR 0 5
57099: PUSH
57100: LD_EXP 102
57104: PUSH
57105: LD_VAR 0 2
57109: ARRAY
57110: PUSH
57111: LD_INT 1
57113: ARRAY
57114: PPUSH
57115: CALL_OW 255
57119: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57120: LD_ADDR_VAR 0 6
57124: PUSH
57125: LD_EXP 102
57129: PUSH
57130: LD_VAR 0 2
57134: ARRAY
57135: PPUSH
57136: LD_INT 30
57138: PUSH
57139: LD_INT 3
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: PPUSH
57146: CALL_OW 72
57150: ST_TO_ADDR
// if not fac then
57151: LD_VAR 0 6
57155: NOT
57156: IFFALSE 57207
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57158: LD_ADDR_VAR 0 6
57162: PUSH
57163: LD_EXP 102
57167: PUSH
57168: LD_VAR 0 2
57172: ARRAY
57173: PPUSH
57174: LD_INT 2
57176: PUSH
57177: LD_INT 30
57179: PUSH
57180: LD_INT 0
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: PUSH
57187: LD_INT 30
57189: PUSH
57190: LD_INT 1
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: PUSH
57197: EMPTY
57198: LIST
57199: LIST
57200: LIST
57201: PPUSH
57202: CALL_OW 72
57206: ST_TO_ADDR
// if not fac then
57207: LD_VAR 0 6
57211: NOT
57212: IFFALSE 57216
// continue ;
57214: GO 57064
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57216: LD_ADDR_VAR 0 7
57220: PUSH
57221: LD_EXP 126
57225: PUSH
57226: LD_VAR 0 2
57230: ARRAY
57231: PPUSH
57232: LD_INT 22
57234: PUSH
57235: LD_VAR 0 5
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PUSH
57244: LD_INT 21
57246: PUSH
57247: LD_INT 2
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: PUSH
57254: LD_INT 3
57256: PUSH
57257: LD_INT 60
57259: PUSH
57260: EMPTY
57261: LIST
57262: PUSH
57263: EMPTY
57264: LIST
57265: LIST
57266: PUSH
57267: LD_INT 3
57269: PUSH
57270: LD_INT 24
57272: PUSH
57273: LD_INT 1000
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: LIST
57288: LIST
57289: PPUSH
57290: CALL_OW 70
57294: ST_TO_ADDR
// for j in fac do
57295: LD_ADDR_VAR 0 3
57299: PUSH
57300: LD_VAR 0 6
57304: PUSH
57305: FOR_IN
57306: IFFALSE 57401
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57308: LD_ADDR_VAR 0 7
57312: PUSH
57313: LD_VAR 0 7
57317: PUSH
57318: LD_INT 22
57320: PUSH
57321: LD_VAR 0 5
57325: PUSH
57326: EMPTY
57327: LIST
57328: LIST
57329: PUSH
57330: LD_INT 91
57332: PUSH
57333: LD_VAR 0 3
57337: PUSH
57338: LD_INT 15
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: LIST
57345: PUSH
57346: LD_INT 21
57348: PUSH
57349: LD_INT 2
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PUSH
57356: LD_INT 3
57358: PUSH
57359: LD_INT 60
57361: PUSH
57362: EMPTY
57363: LIST
57364: PUSH
57365: EMPTY
57366: LIST
57367: LIST
57368: PUSH
57369: LD_INT 3
57371: PUSH
57372: LD_INT 24
57374: PUSH
57375: LD_INT 1000
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: LIST
57390: LIST
57391: LIST
57392: PPUSH
57393: CALL_OW 69
57397: UNION
57398: ST_TO_ADDR
57399: GO 57305
57401: POP
57402: POP
// if not vehs then
57403: LD_VAR 0 7
57407: NOT
57408: IFFALSE 57434
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57410: LD_ADDR_EXP 114
57414: PUSH
57415: LD_EXP 114
57419: PPUSH
57420: LD_VAR 0 2
57424: PPUSH
57425: EMPTY
57426: PPUSH
57427: CALL_OW 1
57431: ST_TO_ADDR
// continue ;
57432: GO 57064
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57434: LD_ADDR_VAR 0 8
57438: PUSH
57439: LD_EXP 102
57443: PUSH
57444: LD_VAR 0 2
57448: ARRAY
57449: PPUSH
57450: LD_INT 30
57452: PUSH
57453: LD_INT 3
57455: PUSH
57456: EMPTY
57457: LIST
57458: LIST
57459: PPUSH
57460: CALL_OW 72
57464: ST_TO_ADDR
// if tmp then
57465: LD_VAR 0 8
57469: IFFALSE 57572
// begin for j in tmp do
57471: LD_ADDR_VAR 0 3
57475: PUSH
57476: LD_VAR 0 8
57480: PUSH
57481: FOR_IN
57482: IFFALSE 57570
// for k in UnitsInside ( j ) do
57484: LD_ADDR_VAR 0 4
57488: PUSH
57489: LD_VAR 0 3
57493: PPUSH
57494: CALL_OW 313
57498: PUSH
57499: FOR_IN
57500: IFFALSE 57566
// if k then
57502: LD_VAR 0 4
57506: IFFALSE 57564
// if not k in mc_repair_vehicle [ i ] then
57508: LD_VAR 0 4
57512: PUSH
57513: LD_EXP 114
57517: PUSH
57518: LD_VAR 0 2
57522: ARRAY
57523: IN
57524: NOT
57525: IFFALSE 57564
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57527: LD_ADDR_EXP 114
57531: PUSH
57532: LD_EXP 114
57536: PPUSH
57537: LD_VAR 0 2
57541: PPUSH
57542: LD_EXP 114
57546: PUSH
57547: LD_VAR 0 2
57551: ARRAY
57552: PUSH
57553: LD_VAR 0 4
57557: UNION
57558: PPUSH
57559: CALL_OW 1
57563: ST_TO_ADDR
57564: GO 57499
57566: POP
57567: POP
57568: GO 57481
57570: POP
57571: POP
// end ; if not mc_repair_vehicle [ i ] then
57572: LD_EXP 114
57576: PUSH
57577: LD_VAR 0 2
57581: ARRAY
57582: NOT
57583: IFFALSE 57587
// continue ;
57585: GO 57064
// for j in mc_repair_vehicle [ i ] do
57587: LD_ADDR_VAR 0 3
57591: PUSH
57592: LD_EXP 114
57596: PUSH
57597: LD_VAR 0 2
57601: ARRAY
57602: PUSH
57603: FOR_IN
57604: IFFALSE 57781
// begin if GetClass ( j ) <> 3 then
57606: LD_VAR 0 3
57610: PPUSH
57611: CALL_OW 257
57615: PUSH
57616: LD_INT 3
57618: NONEQUAL
57619: IFFALSE 57660
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57621: LD_ADDR_EXP 114
57625: PUSH
57626: LD_EXP 114
57630: PPUSH
57631: LD_VAR 0 2
57635: PPUSH
57636: LD_EXP 114
57640: PUSH
57641: LD_VAR 0 2
57645: ARRAY
57646: PUSH
57647: LD_VAR 0 3
57651: DIFF
57652: PPUSH
57653: CALL_OW 1
57657: ST_TO_ADDR
// continue ;
57658: GO 57603
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57660: LD_VAR 0 3
57664: PPUSH
57665: CALL_OW 311
57669: NOT
57670: PUSH
57671: LD_VAR 0 3
57675: PUSH
57676: LD_EXP 105
57680: PUSH
57681: LD_VAR 0 2
57685: ARRAY
57686: PUSH
57687: LD_INT 1
57689: ARRAY
57690: IN
57691: NOT
57692: AND
57693: PUSH
57694: LD_VAR 0 3
57698: PUSH
57699: LD_EXP 105
57703: PUSH
57704: LD_VAR 0 2
57708: ARRAY
57709: PUSH
57710: LD_INT 2
57712: ARRAY
57713: IN
57714: NOT
57715: AND
57716: IFFALSE 57779
// begin if IsInUnit ( j ) then
57718: LD_VAR 0 3
57722: PPUSH
57723: CALL_OW 310
57727: IFFALSE 57740
// ComExitBuilding ( j ) else
57729: LD_VAR 0 3
57733: PPUSH
57734: CALL_OW 122
57738: GO 57779
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57740: LD_VAR 0 3
57744: PPUSH
57745: LD_VAR 0 7
57749: PUSH
57750: LD_INT 1
57752: ARRAY
57753: PPUSH
57754: CALL 109474 0 2
57758: NOT
57759: IFFALSE 57779
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57761: LD_VAR 0 3
57765: PPUSH
57766: LD_VAR 0 7
57770: PUSH
57771: LD_INT 1
57773: ARRAY
57774: PPUSH
57775: CALL_OW 129
// end ; end ;
57779: GO 57603
57781: POP
57782: POP
// end ;
57783: GO 57064
57785: POP
57786: POP
// end ;
57787: LD_VAR 0 1
57791: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57792: LD_INT 0
57794: PPUSH
57795: PPUSH
57796: PPUSH
57797: PPUSH
57798: PPUSH
57799: PPUSH
57800: PPUSH
57801: PPUSH
57802: PPUSH
57803: PPUSH
57804: PPUSH
// if not mc_bases then
57805: LD_EXP 102
57809: NOT
57810: IFFALSE 57814
// exit ;
57812: GO 58616
// for i = 1 to mc_bases do
57814: LD_ADDR_VAR 0 2
57818: PUSH
57819: DOUBLE
57820: LD_INT 1
57822: DEC
57823: ST_TO_ADDR
57824: LD_EXP 102
57828: PUSH
57829: FOR_TO
57830: IFFALSE 58614
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57832: LD_EXP 130
57836: PUSH
57837: LD_VAR 0 2
57841: ARRAY
57842: NOT
57843: PUSH
57844: LD_EXP 105
57848: PUSH
57849: LD_VAR 0 2
57853: ARRAY
57854: PUSH
57855: LD_INT 1
57857: ARRAY
57858: OR
57859: PUSH
57860: LD_EXP 105
57864: PUSH
57865: LD_VAR 0 2
57869: ARRAY
57870: PUSH
57871: LD_INT 2
57873: ARRAY
57874: OR
57875: PUSH
57876: LD_EXP 128
57880: PUSH
57881: LD_VAR 0 2
57885: ARRAY
57886: PPUSH
57887: LD_INT 1
57889: PPUSH
57890: CALL_OW 325
57894: NOT
57895: OR
57896: PUSH
57897: LD_EXP 125
57901: PUSH
57902: LD_VAR 0 2
57906: ARRAY
57907: OR
57908: IFFALSE 57912
// continue ;
57910: GO 57829
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57912: LD_ADDR_VAR 0 8
57916: PUSH
57917: LD_EXP 102
57921: PUSH
57922: LD_VAR 0 2
57926: ARRAY
57927: PPUSH
57928: LD_INT 25
57930: PUSH
57931: LD_INT 4
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: PUSH
57938: LD_INT 50
57940: PUSH
57941: EMPTY
57942: LIST
57943: PUSH
57944: LD_INT 3
57946: PUSH
57947: LD_INT 60
57949: PUSH
57950: EMPTY
57951: LIST
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PUSH
57957: EMPTY
57958: LIST
57959: LIST
57960: LIST
57961: PPUSH
57962: CALL_OW 72
57966: PUSH
57967: LD_EXP 106
57971: PUSH
57972: LD_VAR 0 2
57976: ARRAY
57977: DIFF
57978: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57979: LD_ADDR_VAR 0 9
57983: PUSH
57984: LD_EXP 102
57988: PUSH
57989: LD_VAR 0 2
57993: ARRAY
57994: PPUSH
57995: LD_INT 2
57997: PUSH
57998: LD_INT 30
58000: PUSH
58001: LD_INT 0
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: PUSH
58008: LD_INT 30
58010: PUSH
58011: LD_INT 1
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: PUSH
58018: EMPTY
58019: LIST
58020: LIST
58021: LIST
58022: PPUSH
58023: CALL_OW 72
58027: ST_TO_ADDR
// if not tmp or not dep then
58028: LD_VAR 0 8
58032: NOT
58033: PUSH
58034: LD_VAR 0 9
58038: NOT
58039: OR
58040: IFFALSE 58044
// continue ;
58042: GO 57829
// side := GetSide ( tmp [ 1 ] ) ;
58044: LD_ADDR_VAR 0 11
58048: PUSH
58049: LD_VAR 0 8
58053: PUSH
58054: LD_INT 1
58056: ARRAY
58057: PPUSH
58058: CALL_OW 255
58062: ST_TO_ADDR
// dep := dep [ 1 ] ;
58063: LD_ADDR_VAR 0 9
58067: PUSH
58068: LD_VAR 0 9
58072: PUSH
58073: LD_INT 1
58075: ARRAY
58076: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58077: LD_ADDR_VAR 0 7
58081: PUSH
58082: LD_EXP 130
58086: PUSH
58087: LD_VAR 0 2
58091: ARRAY
58092: PPUSH
58093: LD_INT 22
58095: PUSH
58096: LD_INT 0
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: LD_INT 25
58105: PUSH
58106: LD_INT 12
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PUSH
58113: EMPTY
58114: LIST
58115: LIST
58116: PPUSH
58117: CALL_OW 70
58121: PUSH
58122: LD_INT 22
58124: PUSH
58125: LD_INT 0
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: LD_INT 25
58134: PUSH
58135: LD_INT 12
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PUSH
58142: LD_INT 91
58144: PUSH
58145: LD_VAR 0 9
58149: PUSH
58150: LD_INT 20
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: LIST
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: LIST
58162: PPUSH
58163: CALL_OW 69
58167: UNION
58168: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58169: LD_ADDR_VAR 0 10
58173: PUSH
58174: LD_EXP 130
58178: PUSH
58179: LD_VAR 0 2
58183: ARRAY
58184: PPUSH
58185: LD_INT 81
58187: PUSH
58188: LD_VAR 0 11
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: PPUSH
58197: CALL_OW 70
58201: ST_TO_ADDR
// if not apes or danger_at_area then
58202: LD_VAR 0 7
58206: NOT
58207: PUSH
58208: LD_VAR 0 10
58212: OR
58213: IFFALSE 58263
// begin if mc_taming [ i ] then
58215: LD_EXP 133
58219: PUSH
58220: LD_VAR 0 2
58224: ARRAY
58225: IFFALSE 58261
// begin MC_Reset ( i , 121 ) ;
58227: LD_VAR 0 2
58231: PPUSH
58232: LD_INT 121
58234: PPUSH
58235: CALL 43179 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58239: LD_ADDR_EXP 133
58243: PUSH
58244: LD_EXP 133
58248: PPUSH
58249: LD_VAR 0 2
58253: PPUSH
58254: EMPTY
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// end ; continue ;
58261: GO 57829
// end ; for j in tmp do
58263: LD_ADDR_VAR 0 3
58267: PUSH
58268: LD_VAR 0 8
58272: PUSH
58273: FOR_IN
58274: IFFALSE 58610
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58276: LD_VAR 0 3
58280: PUSH
58281: LD_EXP 133
58285: PUSH
58286: LD_VAR 0 2
58290: ARRAY
58291: IN
58292: NOT
58293: PUSH
58294: LD_EXP 133
58298: PUSH
58299: LD_VAR 0 2
58303: ARRAY
58304: PUSH
58305: LD_INT 3
58307: LESS
58308: AND
58309: IFFALSE 58367
// begin SetTag ( j , 121 ) ;
58311: LD_VAR 0 3
58315: PPUSH
58316: LD_INT 121
58318: PPUSH
58319: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58323: LD_ADDR_EXP 133
58327: PUSH
58328: LD_EXP 133
58332: PPUSH
58333: LD_VAR 0 2
58337: PUSH
58338: LD_EXP 133
58342: PUSH
58343: LD_VAR 0 2
58347: ARRAY
58348: PUSH
58349: LD_INT 1
58351: PLUS
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: PPUSH
58357: LD_VAR 0 3
58361: PPUSH
58362: CALL 74680 0 3
58366: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58367: LD_VAR 0 3
58371: PUSH
58372: LD_EXP 133
58376: PUSH
58377: LD_VAR 0 2
58381: ARRAY
58382: IN
58383: IFFALSE 58608
// begin if GetClass ( j ) <> 4 then
58385: LD_VAR 0 3
58389: PPUSH
58390: CALL_OW 257
58394: PUSH
58395: LD_INT 4
58397: NONEQUAL
58398: IFFALSE 58451
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58400: LD_ADDR_EXP 133
58404: PUSH
58405: LD_EXP 133
58409: PPUSH
58410: LD_VAR 0 2
58414: PPUSH
58415: LD_EXP 133
58419: PUSH
58420: LD_VAR 0 2
58424: ARRAY
58425: PUSH
58426: LD_VAR 0 3
58430: DIFF
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58437: LD_VAR 0 3
58441: PPUSH
58442: LD_INT 0
58444: PPUSH
58445: CALL_OW 109
// continue ;
58449: GO 58273
// end ; if IsInUnit ( j ) then
58451: LD_VAR 0 3
58455: PPUSH
58456: CALL_OW 310
58460: IFFALSE 58471
// ComExitBuilding ( j ) ;
58462: LD_VAR 0 3
58466: PPUSH
58467: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58471: LD_ADDR_VAR 0 6
58475: PUSH
58476: LD_VAR 0 7
58480: PPUSH
58481: LD_VAR 0 3
58485: PPUSH
58486: CALL_OW 74
58490: ST_TO_ADDR
// if not ape then
58491: LD_VAR 0 6
58495: NOT
58496: IFFALSE 58500
// break ;
58498: GO 58610
// x := GetX ( ape ) ;
58500: LD_ADDR_VAR 0 4
58504: PUSH
58505: LD_VAR 0 6
58509: PPUSH
58510: CALL_OW 250
58514: ST_TO_ADDR
// y := GetY ( ape ) ;
58515: LD_ADDR_VAR 0 5
58519: PUSH
58520: LD_VAR 0 6
58524: PPUSH
58525: CALL_OW 251
58529: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58530: LD_VAR 0 4
58534: PPUSH
58535: LD_VAR 0 5
58539: PPUSH
58540: CALL_OW 488
58544: NOT
58545: PUSH
58546: LD_VAR 0 11
58550: PPUSH
58551: LD_VAR 0 4
58555: PPUSH
58556: LD_VAR 0 5
58560: PPUSH
58561: LD_INT 20
58563: PPUSH
58564: CALL 75944 0 4
58568: PUSH
58569: LD_INT 4
58571: ARRAY
58572: OR
58573: IFFALSE 58577
// break ;
58575: GO 58610
// if not HasTask ( j ) then
58577: LD_VAR 0 3
58581: PPUSH
58582: CALL_OW 314
58586: NOT
58587: IFFALSE 58608
// ComTameXY ( j , x , y ) ;
58589: LD_VAR 0 3
58593: PPUSH
58594: LD_VAR 0 4
58598: PPUSH
58599: LD_VAR 0 5
58603: PPUSH
58604: CALL_OW 131
// end ; end ;
58608: GO 58273
58610: POP
58611: POP
// end ;
58612: GO 57829
58614: POP
58615: POP
// end ;
58616: LD_VAR 0 1
58620: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58621: LD_INT 0
58623: PPUSH
58624: PPUSH
58625: PPUSH
58626: PPUSH
58627: PPUSH
58628: PPUSH
58629: PPUSH
58630: PPUSH
// if not mc_bases then
58631: LD_EXP 102
58635: NOT
58636: IFFALSE 58640
// exit ;
58638: GO 59266
// for i = 1 to mc_bases do
58640: LD_ADDR_VAR 0 2
58644: PUSH
58645: DOUBLE
58646: LD_INT 1
58648: DEC
58649: ST_TO_ADDR
58650: LD_EXP 102
58654: PUSH
58655: FOR_TO
58656: IFFALSE 59264
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58658: LD_EXP 131
58662: PUSH
58663: LD_VAR 0 2
58667: ARRAY
58668: NOT
58669: PUSH
58670: LD_EXP 131
58674: PUSH
58675: LD_VAR 0 2
58679: ARRAY
58680: PPUSH
58681: LD_INT 25
58683: PUSH
58684: LD_INT 12
58686: PUSH
58687: EMPTY
58688: LIST
58689: LIST
58690: PPUSH
58691: CALL_OW 72
58695: NOT
58696: OR
58697: IFFALSE 58701
// continue ;
58699: GO 58655
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58701: LD_ADDR_VAR 0 5
58705: PUSH
58706: LD_EXP 131
58710: PUSH
58711: LD_VAR 0 2
58715: ARRAY
58716: PUSH
58717: LD_INT 1
58719: ARRAY
58720: PPUSH
58721: CALL_OW 255
58725: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58726: LD_VAR 0 5
58730: PPUSH
58731: LD_INT 2
58733: PPUSH
58734: CALL_OW 325
58738: IFFALSE 58991
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58740: LD_ADDR_VAR 0 4
58744: PUSH
58745: LD_EXP 131
58749: PUSH
58750: LD_VAR 0 2
58754: ARRAY
58755: PPUSH
58756: LD_INT 25
58758: PUSH
58759: LD_INT 16
58761: PUSH
58762: EMPTY
58763: LIST
58764: LIST
58765: PPUSH
58766: CALL_OW 72
58770: ST_TO_ADDR
// if tmp < 6 then
58771: LD_VAR 0 4
58775: PUSH
58776: LD_INT 6
58778: LESS
58779: IFFALSE 58991
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58781: LD_ADDR_VAR 0 6
58785: PUSH
58786: LD_EXP 102
58790: PUSH
58791: LD_VAR 0 2
58795: ARRAY
58796: PPUSH
58797: LD_INT 2
58799: PUSH
58800: LD_INT 30
58802: PUSH
58803: LD_INT 0
58805: PUSH
58806: EMPTY
58807: LIST
58808: LIST
58809: PUSH
58810: LD_INT 30
58812: PUSH
58813: LD_INT 1
58815: PUSH
58816: EMPTY
58817: LIST
58818: LIST
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: LIST
58824: PPUSH
58825: CALL_OW 72
58829: ST_TO_ADDR
// if depot then
58830: LD_VAR 0 6
58834: IFFALSE 58991
// begin selected := 0 ;
58836: LD_ADDR_VAR 0 7
58840: PUSH
58841: LD_INT 0
58843: ST_TO_ADDR
// for j in depot do
58844: LD_ADDR_VAR 0 3
58848: PUSH
58849: LD_VAR 0 6
58853: PUSH
58854: FOR_IN
58855: IFFALSE 58886
// begin if UnitsInside ( j ) < 6 then
58857: LD_VAR 0 3
58861: PPUSH
58862: CALL_OW 313
58866: PUSH
58867: LD_INT 6
58869: LESS
58870: IFFALSE 58884
// begin selected := j ;
58872: LD_ADDR_VAR 0 7
58876: PUSH
58877: LD_VAR 0 3
58881: ST_TO_ADDR
// break ;
58882: GO 58886
// end ; end ;
58884: GO 58854
58886: POP
58887: POP
// if selected then
58888: LD_VAR 0 7
58892: IFFALSE 58991
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58894: LD_ADDR_VAR 0 3
58898: PUSH
58899: LD_EXP 131
58903: PUSH
58904: LD_VAR 0 2
58908: ARRAY
58909: PPUSH
58910: LD_INT 25
58912: PUSH
58913: LD_INT 12
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: PPUSH
58920: CALL_OW 72
58924: PUSH
58925: FOR_IN
58926: IFFALSE 58989
// if not HasTask ( j ) then
58928: LD_VAR 0 3
58932: PPUSH
58933: CALL_OW 314
58937: NOT
58938: IFFALSE 58987
// begin if not IsInUnit ( j ) then
58940: LD_VAR 0 3
58944: PPUSH
58945: CALL_OW 310
58949: NOT
58950: IFFALSE 58966
// ComEnterUnit ( j , selected ) ;
58952: LD_VAR 0 3
58956: PPUSH
58957: LD_VAR 0 7
58961: PPUSH
58962: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58966: LD_VAR 0 3
58970: PPUSH
58971: LD_INT 16
58973: PPUSH
58974: CALL_OW 183
// AddComExitBuilding ( j ) ;
58978: LD_VAR 0 3
58982: PPUSH
58983: CALL_OW 182
// end ;
58987: GO 58925
58989: POP
58990: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58991: LD_VAR 0 5
58995: PPUSH
58996: LD_INT 11
58998: PPUSH
58999: CALL_OW 325
59003: IFFALSE 59262
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59005: LD_ADDR_VAR 0 4
59009: PUSH
59010: LD_EXP 131
59014: PUSH
59015: LD_VAR 0 2
59019: ARRAY
59020: PPUSH
59021: LD_INT 25
59023: PUSH
59024: LD_INT 16
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: PPUSH
59031: CALL_OW 72
59035: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59036: LD_VAR 0 4
59040: PUSH
59041: LD_INT 6
59043: GREATEREQUAL
59044: PUSH
59045: LD_VAR 0 5
59049: PPUSH
59050: LD_INT 2
59052: PPUSH
59053: CALL_OW 325
59057: NOT
59058: OR
59059: IFFALSE 59262
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59061: LD_ADDR_VAR 0 8
59065: PUSH
59066: LD_EXP 102
59070: PUSH
59071: LD_VAR 0 2
59075: ARRAY
59076: PPUSH
59077: LD_INT 2
59079: PUSH
59080: LD_INT 30
59082: PUSH
59083: LD_INT 4
59085: PUSH
59086: EMPTY
59087: LIST
59088: LIST
59089: PUSH
59090: LD_INT 30
59092: PUSH
59093: LD_INT 5
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: LIST
59104: PPUSH
59105: CALL_OW 72
59109: ST_TO_ADDR
// if barracks then
59110: LD_VAR 0 8
59114: IFFALSE 59262
// begin selected := 0 ;
59116: LD_ADDR_VAR 0 7
59120: PUSH
59121: LD_INT 0
59123: ST_TO_ADDR
// for j in barracks do
59124: LD_ADDR_VAR 0 3
59128: PUSH
59129: LD_VAR 0 8
59133: PUSH
59134: FOR_IN
59135: IFFALSE 59166
// begin if UnitsInside ( j ) < 6 then
59137: LD_VAR 0 3
59141: PPUSH
59142: CALL_OW 313
59146: PUSH
59147: LD_INT 6
59149: LESS
59150: IFFALSE 59164
// begin selected := j ;
59152: LD_ADDR_VAR 0 7
59156: PUSH
59157: LD_VAR 0 3
59161: ST_TO_ADDR
// break ;
59162: GO 59166
// end ; end ;
59164: GO 59134
59166: POP
59167: POP
// if selected then
59168: LD_VAR 0 7
59172: IFFALSE 59262
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59174: LD_ADDR_VAR 0 3
59178: PUSH
59179: LD_EXP 131
59183: PUSH
59184: LD_VAR 0 2
59188: ARRAY
59189: PPUSH
59190: LD_INT 25
59192: PUSH
59193: LD_INT 12
59195: PUSH
59196: EMPTY
59197: LIST
59198: LIST
59199: PPUSH
59200: CALL_OW 72
59204: PUSH
59205: FOR_IN
59206: IFFALSE 59260
// if not IsInUnit ( j ) and not HasTask ( j ) then
59208: LD_VAR 0 3
59212: PPUSH
59213: CALL_OW 310
59217: NOT
59218: PUSH
59219: LD_VAR 0 3
59223: PPUSH
59224: CALL_OW 314
59228: NOT
59229: AND
59230: IFFALSE 59258
// begin ComEnterUnit ( j , selected ) ;
59232: LD_VAR 0 3
59236: PPUSH
59237: LD_VAR 0 7
59241: PPUSH
59242: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59246: LD_VAR 0 3
59250: PPUSH
59251: LD_INT 15
59253: PPUSH
59254: CALL_OW 183
// end ;
59258: GO 59205
59260: POP
59261: POP
// end ; end ; end ; end ; end ;
59262: GO 58655
59264: POP
59265: POP
// end ;
59266: LD_VAR 0 1
59270: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59271: LD_INT 0
59273: PPUSH
59274: PPUSH
59275: PPUSH
59276: PPUSH
// if not mc_bases then
59277: LD_EXP 102
59281: NOT
59282: IFFALSE 59286
// exit ;
59284: GO 59464
// for i = 1 to mc_bases do
59286: LD_ADDR_VAR 0 2
59290: PUSH
59291: DOUBLE
59292: LD_INT 1
59294: DEC
59295: ST_TO_ADDR
59296: LD_EXP 102
59300: PUSH
59301: FOR_TO
59302: IFFALSE 59462
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59304: LD_ADDR_VAR 0 4
59308: PUSH
59309: LD_EXP 102
59313: PUSH
59314: LD_VAR 0 2
59318: ARRAY
59319: PPUSH
59320: LD_INT 25
59322: PUSH
59323: LD_INT 9
59325: PUSH
59326: EMPTY
59327: LIST
59328: LIST
59329: PPUSH
59330: CALL_OW 72
59334: ST_TO_ADDR
// if not tmp then
59335: LD_VAR 0 4
59339: NOT
59340: IFFALSE 59344
// continue ;
59342: GO 59301
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59344: LD_EXP 128
59348: PUSH
59349: LD_VAR 0 2
59353: ARRAY
59354: PPUSH
59355: LD_INT 29
59357: PPUSH
59358: CALL_OW 325
59362: NOT
59363: PUSH
59364: LD_EXP 128
59368: PUSH
59369: LD_VAR 0 2
59373: ARRAY
59374: PPUSH
59375: LD_INT 28
59377: PPUSH
59378: CALL_OW 325
59382: NOT
59383: AND
59384: IFFALSE 59388
// continue ;
59386: GO 59301
// for j in tmp do
59388: LD_ADDR_VAR 0 3
59392: PUSH
59393: LD_VAR 0 4
59397: PUSH
59398: FOR_IN
59399: IFFALSE 59458
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59401: LD_VAR 0 3
59405: PUSH
59406: LD_EXP 105
59410: PUSH
59411: LD_VAR 0 2
59415: ARRAY
59416: PUSH
59417: LD_INT 1
59419: ARRAY
59420: IN
59421: NOT
59422: PUSH
59423: LD_VAR 0 3
59427: PUSH
59428: LD_EXP 105
59432: PUSH
59433: LD_VAR 0 2
59437: ARRAY
59438: PUSH
59439: LD_INT 2
59441: ARRAY
59442: IN
59443: NOT
59444: AND
59445: IFFALSE 59456
// ComSpaceTimeShoot ( j ) ;
59447: LD_VAR 0 3
59451: PPUSH
59452: CALL 70665 0 1
59456: GO 59398
59458: POP
59459: POP
// end ;
59460: GO 59301
59462: POP
59463: POP
// end ;
59464: LD_VAR 0 1
59468: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59469: LD_INT 0
59471: PPUSH
59472: PPUSH
59473: PPUSH
59474: PPUSH
59475: PPUSH
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
// if not mc_bases then
59480: LD_EXP 102
59484: NOT
59485: IFFALSE 59489
// exit ;
59487: GO 60111
// for i = 1 to mc_bases do
59489: LD_ADDR_VAR 0 2
59493: PUSH
59494: DOUBLE
59495: LD_INT 1
59497: DEC
59498: ST_TO_ADDR
59499: LD_EXP 102
59503: PUSH
59504: FOR_TO
59505: IFFALSE 60109
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59507: LD_EXP 137
59511: PUSH
59512: LD_VAR 0 2
59516: ARRAY
59517: NOT
59518: PUSH
59519: LD_INT 38
59521: PPUSH
59522: LD_EXP 128
59526: PUSH
59527: LD_VAR 0 2
59531: ARRAY
59532: PPUSH
59533: CALL_OW 321
59537: PUSH
59538: LD_INT 2
59540: NONEQUAL
59541: OR
59542: IFFALSE 59546
// continue ;
59544: GO 59504
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59546: LD_ADDR_VAR 0 8
59550: PUSH
59551: LD_EXP 102
59555: PUSH
59556: LD_VAR 0 2
59560: ARRAY
59561: PPUSH
59562: LD_INT 30
59564: PUSH
59565: LD_INT 34
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: PPUSH
59572: CALL_OW 72
59576: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59577: LD_ADDR_VAR 0 9
59581: PUSH
59582: LD_EXP 102
59586: PUSH
59587: LD_VAR 0 2
59591: ARRAY
59592: PPUSH
59593: LD_INT 25
59595: PUSH
59596: LD_INT 4
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: PPUSH
59603: CALL_OW 72
59607: PPUSH
59608: LD_INT 0
59610: PPUSH
59611: CALL 104978 0 2
59615: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59616: LD_VAR 0 9
59620: NOT
59621: PUSH
59622: LD_VAR 0 8
59626: NOT
59627: OR
59628: PUSH
59629: LD_EXP 102
59633: PUSH
59634: LD_VAR 0 2
59638: ARRAY
59639: PPUSH
59640: LD_INT 124
59642: PPUSH
59643: CALL 104978 0 2
59647: OR
59648: IFFALSE 59652
// continue ;
59650: GO 59504
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59652: LD_EXP 138
59656: PUSH
59657: LD_VAR 0 2
59661: ARRAY
59662: PUSH
59663: LD_EXP 137
59667: PUSH
59668: LD_VAR 0 2
59672: ARRAY
59673: LESS
59674: PUSH
59675: LD_EXP 138
59679: PUSH
59680: LD_VAR 0 2
59684: ARRAY
59685: PUSH
59686: LD_VAR 0 8
59690: LESS
59691: AND
59692: IFFALSE 60107
// begin tmp := sci [ 1 ] ;
59694: LD_ADDR_VAR 0 7
59698: PUSH
59699: LD_VAR 0 9
59703: PUSH
59704: LD_INT 1
59706: ARRAY
59707: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59708: LD_VAR 0 7
59712: PPUSH
59713: LD_INT 124
59715: PPUSH
59716: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59720: LD_ADDR_VAR 0 3
59724: PUSH
59725: DOUBLE
59726: LD_EXP 137
59730: PUSH
59731: LD_VAR 0 2
59735: ARRAY
59736: INC
59737: ST_TO_ADDR
59738: LD_EXP 137
59742: PUSH
59743: LD_VAR 0 2
59747: ARRAY
59748: PUSH
59749: FOR_DOWNTO
59750: IFFALSE 60093
// begin if IsInUnit ( tmp ) then
59752: LD_VAR 0 7
59756: PPUSH
59757: CALL_OW 310
59761: IFFALSE 59772
// ComExitBuilding ( tmp ) ;
59763: LD_VAR 0 7
59767: PPUSH
59768: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59772: LD_INT 35
59774: PPUSH
59775: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59779: LD_VAR 0 7
59783: PPUSH
59784: CALL_OW 310
59788: NOT
59789: PUSH
59790: LD_VAR 0 7
59794: PPUSH
59795: CALL_OW 314
59799: NOT
59800: AND
59801: IFFALSE 59772
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59803: LD_ADDR_VAR 0 6
59807: PUSH
59808: LD_VAR 0 7
59812: PPUSH
59813: CALL_OW 250
59817: PUSH
59818: LD_VAR 0 7
59822: PPUSH
59823: CALL_OW 251
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59832: LD_INT 35
59834: PPUSH
59835: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59839: LD_ADDR_VAR 0 4
59843: PUSH
59844: LD_EXP 137
59848: PUSH
59849: LD_VAR 0 2
59853: ARRAY
59854: PUSH
59855: LD_VAR 0 3
59859: ARRAY
59860: PUSH
59861: LD_INT 1
59863: ARRAY
59864: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59865: LD_ADDR_VAR 0 5
59869: PUSH
59870: LD_EXP 137
59874: PUSH
59875: LD_VAR 0 2
59879: ARRAY
59880: PUSH
59881: LD_VAR 0 3
59885: ARRAY
59886: PUSH
59887: LD_INT 2
59889: ARRAY
59890: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59891: LD_VAR 0 7
59895: PPUSH
59896: LD_INT 10
59898: PPUSH
59899: CALL 77645 0 2
59903: PUSH
59904: LD_INT 4
59906: ARRAY
59907: IFFALSE 59945
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59909: LD_VAR 0 7
59913: PPUSH
59914: LD_VAR 0 6
59918: PUSH
59919: LD_INT 1
59921: ARRAY
59922: PPUSH
59923: LD_VAR 0 6
59927: PUSH
59928: LD_INT 2
59930: ARRAY
59931: PPUSH
59932: CALL_OW 111
// wait ( 0 0$10 ) ;
59936: LD_INT 350
59938: PPUSH
59939: CALL_OW 67
// end else
59943: GO 59971
// begin ComMoveXY ( tmp , x , y ) ;
59945: LD_VAR 0 7
59949: PPUSH
59950: LD_VAR 0 4
59954: PPUSH
59955: LD_VAR 0 5
59959: PPUSH
59960: CALL_OW 111
// wait ( 0 0$3 ) ;
59964: LD_INT 105
59966: PPUSH
59967: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59971: LD_VAR 0 7
59975: PPUSH
59976: LD_VAR 0 4
59980: PPUSH
59981: LD_VAR 0 5
59985: PPUSH
59986: CALL_OW 307
59990: IFFALSE 59832
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59992: LD_VAR 0 7
59996: PPUSH
59997: LD_VAR 0 4
60001: PPUSH
60002: LD_VAR 0 5
60006: PPUSH
60007: LD_VAR 0 8
60011: PUSH
60012: LD_VAR 0 3
60016: ARRAY
60017: PPUSH
60018: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60022: LD_INT 35
60024: PPUSH
60025: CALL_OW 67
// until not HasTask ( tmp ) ;
60029: LD_VAR 0 7
60033: PPUSH
60034: CALL_OW 314
60038: NOT
60039: IFFALSE 60022
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60041: LD_ADDR_EXP 138
60045: PUSH
60046: LD_EXP 138
60050: PPUSH
60051: LD_VAR 0 2
60055: PUSH
60056: LD_EXP 138
60060: PUSH
60061: LD_VAR 0 2
60065: ARRAY
60066: PUSH
60067: LD_INT 1
60069: PLUS
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PPUSH
60075: LD_VAR 0 8
60079: PUSH
60080: LD_VAR 0 3
60084: ARRAY
60085: PPUSH
60086: CALL 74680 0 3
60090: ST_TO_ADDR
// end ;
60091: GO 59749
60093: POP
60094: POP
// MC_Reset ( i , 124 ) ;
60095: LD_VAR 0 2
60099: PPUSH
60100: LD_INT 124
60102: PPUSH
60103: CALL 43179 0 2
// end ; end ;
60107: GO 59504
60109: POP
60110: POP
// end ;
60111: LD_VAR 0 1
60115: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60116: LD_INT 0
60118: PPUSH
60119: PPUSH
60120: PPUSH
// if not mc_bases then
60121: LD_EXP 102
60125: NOT
60126: IFFALSE 60130
// exit ;
60128: GO 60736
// for i = 1 to mc_bases do
60130: LD_ADDR_VAR 0 2
60134: PUSH
60135: DOUBLE
60136: LD_INT 1
60138: DEC
60139: ST_TO_ADDR
60140: LD_EXP 102
60144: PUSH
60145: FOR_TO
60146: IFFALSE 60734
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60148: LD_ADDR_VAR 0 3
60152: PUSH
60153: LD_EXP 102
60157: PUSH
60158: LD_VAR 0 2
60162: ARRAY
60163: PPUSH
60164: LD_INT 25
60166: PUSH
60167: LD_INT 4
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PPUSH
60174: CALL_OW 72
60178: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60179: LD_VAR 0 3
60183: NOT
60184: PUSH
60185: LD_EXP 139
60189: PUSH
60190: LD_VAR 0 2
60194: ARRAY
60195: NOT
60196: OR
60197: PUSH
60198: LD_EXP 102
60202: PUSH
60203: LD_VAR 0 2
60207: ARRAY
60208: PPUSH
60209: LD_INT 2
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 0
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 30
60224: PUSH
60225: LD_INT 1
60227: PUSH
60228: EMPTY
60229: LIST
60230: LIST
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: LIST
60236: PPUSH
60237: CALL_OW 72
60241: NOT
60242: OR
60243: IFFALSE 60293
// begin if mc_deposits_finder [ i ] then
60245: LD_EXP 140
60249: PUSH
60250: LD_VAR 0 2
60254: ARRAY
60255: IFFALSE 60291
// begin MC_Reset ( i , 125 ) ;
60257: LD_VAR 0 2
60261: PPUSH
60262: LD_INT 125
60264: PPUSH
60265: CALL 43179 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60269: LD_ADDR_EXP 140
60273: PUSH
60274: LD_EXP 140
60278: PPUSH
60279: LD_VAR 0 2
60283: PPUSH
60284: EMPTY
60285: PPUSH
60286: CALL_OW 1
60290: ST_TO_ADDR
// end ; continue ;
60291: GO 60145
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60293: LD_EXP 139
60297: PUSH
60298: LD_VAR 0 2
60302: ARRAY
60303: PUSH
60304: LD_INT 1
60306: ARRAY
60307: PUSH
60308: LD_INT 3
60310: ARRAY
60311: PUSH
60312: LD_INT 1
60314: EQUAL
60315: PUSH
60316: LD_INT 20
60318: PPUSH
60319: LD_EXP 128
60323: PUSH
60324: LD_VAR 0 2
60328: ARRAY
60329: PPUSH
60330: CALL_OW 321
60334: PUSH
60335: LD_INT 2
60337: NONEQUAL
60338: AND
60339: IFFALSE 60389
// begin if mc_deposits_finder [ i ] then
60341: LD_EXP 140
60345: PUSH
60346: LD_VAR 0 2
60350: ARRAY
60351: IFFALSE 60387
// begin MC_Reset ( i , 125 ) ;
60353: LD_VAR 0 2
60357: PPUSH
60358: LD_INT 125
60360: PPUSH
60361: CALL 43179 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60365: LD_ADDR_EXP 140
60369: PUSH
60370: LD_EXP 140
60374: PPUSH
60375: LD_VAR 0 2
60379: PPUSH
60380: EMPTY
60381: PPUSH
60382: CALL_OW 1
60386: ST_TO_ADDR
// end ; continue ;
60387: GO 60145
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60389: LD_EXP 139
60393: PUSH
60394: LD_VAR 0 2
60398: ARRAY
60399: PUSH
60400: LD_INT 1
60402: ARRAY
60403: PUSH
60404: LD_INT 1
60406: ARRAY
60407: PPUSH
60408: LD_EXP 139
60412: PUSH
60413: LD_VAR 0 2
60417: ARRAY
60418: PUSH
60419: LD_INT 1
60421: ARRAY
60422: PUSH
60423: LD_INT 2
60425: ARRAY
60426: PPUSH
60427: LD_EXP 128
60431: PUSH
60432: LD_VAR 0 2
60436: ARRAY
60437: PPUSH
60438: CALL_OW 440
60442: IFFALSE 60485
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60444: LD_ADDR_EXP 139
60448: PUSH
60449: LD_EXP 139
60453: PPUSH
60454: LD_VAR 0 2
60458: PPUSH
60459: LD_EXP 139
60463: PUSH
60464: LD_VAR 0 2
60468: ARRAY
60469: PPUSH
60470: LD_INT 1
60472: PPUSH
60473: CALL_OW 3
60477: PPUSH
60478: CALL_OW 1
60482: ST_TO_ADDR
60483: GO 60732
// begin if not mc_deposits_finder [ i ] then
60485: LD_EXP 140
60489: PUSH
60490: LD_VAR 0 2
60494: ARRAY
60495: NOT
60496: IFFALSE 60548
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60498: LD_ADDR_EXP 140
60502: PUSH
60503: LD_EXP 140
60507: PPUSH
60508: LD_VAR 0 2
60512: PPUSH
60513: LD_VAR 0 3
60517: PUSH
60518: LD_INT 1
60520: ARRAY
60521: PUSH
60522: EMPTY
60523: LIST
60524: PPUSH
60525: CALL_OW 1
60529: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60530: LD_VAR 0 3
60534: PUSH
60535: LD_INT 1
60537: ARRAY
60538: PPUSH
60539: LD_INT 125
60541: PPUSH
60542: CALL_OW 109
// end else
60546: GO 60732
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60548: LD_EXP 140
60552: PUSH
60553: LD_VAR 0 2
60557: ARRAY
60558: PUSH
60559: LD_INT 1
60561: ARRAY
60562: PPUSH
60563: CALL_OW 310
60567: IFFALSE 60590
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60569: LD_EXP 140
60573: PUSH
60574: LD_VAR 0 2
60578: ARRAY
60579: PUSH
60580: LD_INT 1
60582: ARRAY
60583: PPUSH
60584: CALL_OW 122
60588: GO 60732
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60590: LD_EXP 140
60594: PUSH
60595: LD_VAR 0 2
60599: ARRAY
60600: PUSH
60601: LD_INT 1
60603: ARRAY
60604: PPUSH
60605: CALL_OW 314
60609: NOT
60610: PUSH
60611: LD_EXP 140
60615: PUSH
60616: LD_VAR 0 2
60620: ARRAY
60621: PUSH
60622: LD_INT 1
60624: ARRAY
60625: PPUSH
60626: LD_EXP 139
60630: PUSH
60631: LD_VAR 0 2
60635: ARRAY
60636: PUSH
60637: LD_INT 1
60639: ARRAY
60640: PUSH
60641: LD_INT 1
60643: ARRAY
60644: PPUSH
60645: LD_EXP 139
60649: PUSH
60650: LD_VAR 0 2
60654: ARRAY
60655: PUSH
60656: LD_INT 1
60658: ARRAY
60659: PUSH
60660: LD_INT 2
60662: ARRAY
60663: PPUSH
60664: CALL_OW 297
60668: PUSH
60669: LD_INT 6
60671: GREATER
60672: AND
60673: IFFALSE 60732
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60675: LD_EXP 140
60679: PUSH
60680: LD_VAR 0 2
60684: ARRAY
60685: PUSH
60686: LD_INT 1
60688: ARRAY
60689: PPUSH
60690: LD_EXP 139
60694: PUSH
60695: LD_VAR 0 2
60699: ARRAY
60700: PUSH
60701: LD_INT 1
60703: ARRAY
60704: PUSH
60705: LD_INT 1
60707: ARRAY
60708: PPUSH
60709: LD_EXP 139
60713: PUSH
60714: LD_VAR 0 2
60718: ARRAY
60719: PUSH
60720: LD_INT 1
60722: ARRAY
60723: PUSH
60724: LD_INT 2
60726: ARRAY
60727: PPUSH
60728: CALL_OW 111
// end ; end ; end ;
60732: GO 60145
60734: POP
60735: POP
// end ;
60736: LD_VAR 0 1
60740: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60741: LD_INT 0
60743: PPUSH
60744: PPUSH
60745: PPUSH
60746: PPUSH
60747: PPUSH
60748: PPUSH
60749: PPUSH
60750: PPUSH
60751: PPUSH
60752: PPUSH
60753: PPUSH
// if not mc_bases then
60754: LD_EXP 102
60758: NOT
60759: IFFALSE 60763
// exit ;
60761: GO 61703
// for i = 1 to mc_bases do
60763: LD_ADDR_VAR 0 2
60767: PUSH
60768: DOUBLE
60769: LD_INT 1
60771: DEC
60772: ST_TO_ADDR
60773: LD_EXP 102
60777: PUSH
60778: FOR_TO
60779: IFFALSE 61701
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60781: LD_EXP 102
60785: PUSH
60786: LD_VAR 0 2
60790: ARRAY
60791: NOT
60792: PUSH
60793: LD_EXP 125
60797: PUSH
60798: LD_VAR 0 2
60802: ARRAY
60803: OR
60804: IFFALSE 60808
// continue ;
60806: GO 60778
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60808: LD_ADDR_VAR 0 7
60812: PUSH
60813: LD_EXP 102
60817: PUSH
60818: LD_VAR 0 2
60822: ARRAY
60823: PUSH
60824: LD_INT 1
60826: ARRAY
60827: PPUSH
60828: CALL_OW 248
60832: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60833: LD_VAR 0 7
60837: PUSH
60838: LD_INT 3
60840: EQUAL
60841: PUSH
60842: LD_EXP 121
60846: PUSH
60847: LD_VAR 0 2
60851: ARRAY
60852: PUSH
60853: LD_EXP 124
60857: PUSH
60858: LD_VAR 0 2
60862: ARRAY
60863: UNION
60864: PPUSH
60865: LD_INT 33
60867: PUSH
60868: LD_INT 2
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PPUSH
60875: CALL_OW 72
60879: NOT
60880: OR
60881: IFFALSE 60885
// continue ;
60883: GO 60778
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60885: LD_ADDR_VAR 0 9
60889: PUSH
60890: LD_EXP 102
60894: PUSH
60895: LD_VAR 0 2
60899: ARRAY
60900: PPUSH
60901: LD_INT 30
60903: PUSH
60904: LD_INT 36
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PPUSH
60911: CALL_OW 72
60915: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60916: LD_ADDR_VAR 0 10
60920: PUSH
60921: LD_EXP 121
60925: PUSH
60926: LD_VAR 0 2
60930: ARRAY
60931: PPUSH
60932: LD_INT 34
60934: PUSH
60935: LD_INT 31
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PPUSH
60942: CALL_OW 72
60946: ST_TO_ADDR
// if not cts and not mcts then
60947: LD_VAR 0 9
60951: NOT
60952: PUSH
60953: LD_VAR 0 10
60957: NOT
60958: AND
60959: IFFALSE 60963
// continue ;
60961: GO 60778
// x := cts ;
60963: LD_ADDR_VAR 0 11
60967: PUSH
60968: LD_VAR 0 9
60972: ST_TO_ADDR
// if not x then
60973: LD_VAR 0 11
60977: NOT
60978: IFFALSE 60990
// x := mcts ;
60980: LD_ADDR_VAR 0 11
60984: PUSH
60985: LD_VAR 0 10
60989: ST_TO_ADDR
// if not x then
60990: LD_VAR 0 11
60994: NOT
60995: IFFALSE 60999
// continue ;
60997: GO 60778
// if mc_remote_driver [ i ] then
60999: LD_EXP 142
61003: PUSH
61004: LD_VAR 0 2
61008: ARRAY
61009: IFFALSE 61396
// for j in mc_remote_driver [ i ] do
61011: LD_ADDR_VAR 0 3
61015: PUSH
61016: LD_EXP 142
61020: PUSH
61021: LD_VAR 0 2
61025: ARRAY
61026: PUSH
61027: FOR_IN
61028: IFFALSE 61394
// begin if GetClass ( j ) <> 3 then
61030: LD_VAR 0 3
61034: PPUSH
61035: CALL_OW 257
61039: PUSH
61040: LD_INT 3
61042: NONEQUAL
61043: IFFALSE 61096
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61045: LD_ADDR_EXP 142
61049: PUSH
61050: LD_EXP 142
61054: PPUSH
61055: LD_VAR 0 2
61059: PPUSH
61060: LD_EXP 142
61064: PUSH
61065: LD_VAR 0 2
61069: ARRAY
61070: PUSH
61071: LD_VAR 0 3
61075: DIFF
61076: PPUSH
61077: CALL_OW 1
61081: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61082: LD_VAR 0 3
61086: PPUSH
61087: LD_INT 0
61089: PPUSH
61090: CALL_OW 109
// continue ;
61094: GO 61027
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61096: LD_EXP 121
61100: PUSH
61101: LD_VAR 0 2
61105: ARRAY
61106: PPUSH
61107: LD_INT 34
61109: PUSH
61110: LD_INT 31
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: PUSH
61117: LD_INT 58
61119: PUSH
61120: EMPTY
61121: LIST
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PPUSH
61127: CALL_OW 72
61131: PUSH
61132: LD_VAR 0 3
61136: PPUSH
61137: CALL 105013 0 1
61141: NOT
61142: AND
61143: IFFALSE 61214
// begin if IsInUnit ( j ) then
61145: LD_VAR 0 3
61149: PPUSH
61150: CALL_OW 310
61154: IFFALSE 61165
// ComExitBuilding ( j ) ;
61156: LD_VAR 0 3
61160: PPUSH
61161: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61165: LD_VAR 0 3
61169: PPUSH
61170: LD_EXP 121
61174: PUSH
61175: LD_VAR 0 2
61179: ARRAY
61180: PPUSH
61181: LD_INT 34
61183: PUSH
61184: LD_INT 31
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PUSH
61191: LD_INT 58
61193: PUSH
61194: EMPTY
61195: LIST
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: PPUSH
61201: CALL_OW 72
61205: PUSH
61206: LD_INT 1
61208: ARRAY
61209: PPUSH
61210: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61214: LD_VAR 0 3
61218: PPUSH
61219: CALL_OW 310
61223: NOT
61224: PUSH
61225: LD_VAR 0 3
61229: PPUSH
61230: CALL_OW 310
61234: PPUSH
61235: CALL_OW 266
61239: PUSH
61240: LD_INT 36
61242: NONEQUAL
61243: PUSH
61244: LD_VAR 0 3
61248: PPUSH
61249: CALL 105013 0 1
61253: NOT
61254: AND
61255: OR
61256: IFFALSE 61392
// begin if IsInUnit ( j ) then
61258: LD_VAR 0 3
61262: PPUSH
61263: CALL_OW 310
61267: IFFALSE 61278
// ComExitBuilding ( j ) ;
61269: LD_VAR 0 3
61273: PPUSH
61274: CALL_OW 122
// ct := 0 ;
61278: LD_ADDR_VAR 0 8
61282: PUSH
61283: LD_INT 0
61285: ST_TO_ADDR
// for k in x do
61286: LD_ADDR_VAR 0 4
61290: PUSH
61291: LD_VAR 0 11
61295: PUSH
61296: FOR_IN
61297: IFFALSE 61370
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61299: LD_VAR 0 4
61303: PPUSH
61304: CALL_OW 264
61308: PUSH
61309: LD_INT 31
61311: EQUAL
61312: PUSH
61313: LD_VAR 0 4
61317: PPUSH
61318: CALL_OW 311
61322: NOT
61323: AND
61324: PUSH
61325: LD_VAR 0 4
61329: PPUSH
61330: CALL_OW 266
61334: PUSH
61335: LD_INT 36
61337: EQUAL
61338: PUSH
61339: LD_VAR 0 4
61343: PPUSH
61344: CALL_OW 313
61348: PUSH
61349: LD_INT 3
61351: LESS
61352: AND
61353: OR
61354: IFFALSE 61368
// begin ct := k ;
61356: LD_ADDR_VAR 0 8
61360: PUSH
61361: LD_VAR 0 4
61365: ST_TO_ADDR
// break ;
61366: GO 61370
// end ;
61368: GO 61296
61370: POP
61371: POP
// if ct then
61372: LD_VAR 0 8
61376: IFFALSE 61392
// ComEnterUnit ( j , ct ) ;
61378: LD_VAR 0 3
61382: PPUSH
61383: LD_VAR 0 8
61387: PPUSH
61388: CALL_OW 120
// end ; end ;
61392: GO 61027
61394: POP
61395: POP
// places := 0 ;
61396: LD_ADDR_VAR 0 5
61400: PUSH
61401: LD_INT 0
61403: ST_TO_ADDR
// for j = 1 to x do
61404: LD_ADDR_VAR 0 3
61408: PUSH
61409: DOUBLE
61410: LD_INT 1
61412: DEC
61413: ST_TO_ADDR
61414: LD_VAR 0 11
61418: PUSH
61419: FOR_TO
61420: IFFALSE 61496
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61422: LD_VAR 0 11
61426: PUSH
61427: LD_VAR 0 3
61431: ARRAY
61432: PPUSH
61433: CALL_OW 264
61437: PUSH
61438: LD_INT 31
61440: EQUAL
61441: IFFALSE 61459
// places := places + 1 else
61443: LD_ADDR_VAR 0 5
61447: PUSH
61448: LD_VAR 0 5
61452: PUSH
61453: LD_INT 1
61455: PLUS
61456: ST_TO_ADDR
61457: GO 61494
// if GetBType ( x [ j ] ) = b_control_tower then
61459: LD_VAR 0 11
61463: PUSH
61464: LD_VAR 0 3
61468: ARRAY
61469: PPUSH
61470: CALL_OW 266
61474: PUSH
61475: LD_INT 36
61477: EQUAL
61478: IFFALSE 61494
// places := places + 3 ;
61480: LD_ADDR_VAR 0 5
61484: PUSH
61485: LD_VAR 0 5
61489: PUSH
61490: LD_INT 3
61492: PLUS
61493: ST_TO_ADDR
61494: GO 61419
61496: POP
61497: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61498: LD_VAR 0 5
61502: PUSH
61503: LD_INT 0
61505: EQUAL
61506: PUSH
61507: LD_VAR 0 5
61511: PUSH
61512: LD_EXP 142
61516: PUSH
61517: LD_VAR 0 2
61521: ARRAY
61522: LESSEQUAL
61523: OR
61524: IFFALSE 61528
// continue ;
61526: GO 60778
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61528: LD_ADDR_VAR 0 6
61532: PUSH
61533: LD_EXP 102
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PPUSH
61544: LD_INT 25
61546: PUSH
61547: LD_INT 3
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PPUSH
61554: CALL_OW 72
61558: PUSH
61559: LD_EXP 142
61563: PUSH
61564: LD_VAR 0 2
61568: ARRAY
61569: DIFF
61570: PPUSH
61571: LD_INT 3
61573: PPUSH
61574: CALL 105913 0 2
61578: ST_TO_ADDR
// for j in tmp do
61579: LD_ADDR_VAR 0 3
61583: PUSH
61584: LD_VAR 0 6
61588: PUSH
61589: FOR_IN
61590: IFFALSE 61625
// if GetTag ( j ) > 0 then
61592: LD_VAR 0 3
61596: PPUSH
61597: CALL_OW 110
61601: PUSH
61602: LD_INT 0
61604: GREATER
61605: IFFALSE 61623
// tmp := tmp diff j ;
61607: LD_ADDR_VAR 0 6
61611: PUSH
61612: LD_VAR 0 6
61616: PUSH
61617: LD_VAR 0 3
61621: DIFF
61622: ST_TO_ADDR
61623: GO 61589
61625: POP
61626: POP
// if not tmp then
61627: LD_VAR 0 6
61631: NOT
61632: IFFALSE 61636
// continue ;
61634: GO 60778
// if places then
61636: LD_VAR 0 5
61640: IFFALSE 61699
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61642: LD_ADDR_EXP 142
61646: PUSH
61647: LD_EXP 142
61651: PPUSH
61652: LD_VAR 0 2
61656: PPUSH
61657: LD_EXP 142
61661: PUSH
61662: LD_VAR 0 2
61666: ARRAY
61667: PUSH
61668: LD_VAR 0 6
61672: PUSH
61673: LD_INT 1
61675: ARRAY
61676: UNION
61677: PPUSH
61678: CALL_OW 1
61682: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61683: LD_VAR 0 6
61687: PUSH
61688: LD_INT 1
61690: ARRAY
61691: PPUSH
61692: LD_INT 126
61694: PPUSH
61695: CALL_OW 109
// end ; end ;
61699: GO 60778
61701: POP
61702: POP
// end ;
61703: LD_VAR 0 1
61707: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61708: LD_INT 0
61710: PPUSH
61711: PPUSH
61712: PPUSH
61713: PPUSH
61714: PPUSH
61715: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61716: LD_VAR 0 1
61720: NOT
61721: PUSH
61722: LD_VAR 0 2
61726: NOT
61727: OR
61728: PUSH
61729: LD_VAR 0 3
61733: NOT
61734: OR
61735: PUSH
61736: LD_VAR 0 4
61740: PUSH
61741: LD_INT 1
61743: PUSH
61744: LD_INT 2
61746: PUSH
61747: LD_INT 3
61749: PUSH
61750: LD_INT 4
61752: PUSH
61753: LD_INT 5
61755: PUSH
61756: LD_INT 8
61758: PUSH
61759: LD_INT 9
61761: PUSH
61762: LD_INT 15
61764: PUSH
61765: LD_INT 16
61767: PUSH
61768: EMPTY
61769: LIST
61770: LIST
61771: LIST
61772: LIST
61773: LIST
61774: LIST
61775: LIST
61776: LIST
61777: LIST
61778: IN
61779: NOT
61780: OR
61781: IFFALSE 61785
// exit ;
61783: GO 62643
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61785: LD_ADDR_VAR 0 2
61789: PUSH
61790: LD_VAR 0 2
61794: PPUSH
61795: LD_INT 21
61797: PUSH
61798: LD_INT 3
61800: PUSH
61801: EMPTY
61802: LIST
61803: LIST
61804: PUSH
61805: LD_INT 24
61807: PUSH
61808: LD_INT 250
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PPUSH
61819: CALL_OW 72
61823: ST_TO_ADDR
// case class of 1 , 15 :
61824: LD_VAR 0 4
61828: PUSH
61829: LD_INT 1
61831: DOUBLE
61832: EQUAL
61833: IFTRUE 61843
61835: LD_INT 15
61837: DOUBLE
61838: EQUAL
61839: IFTRUE 61843
61841: GO 61928
61843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61844: LD_ADDR_VAR 0 8
61848: PUSH
61849: LD_VAR 0 2
61853: PPUSH
61854: LD_INT 2
61856: PUSH
61857: LD_INT 30
61859: PUSH
61860: LD_INT 32
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: PUSH
61867: LD_INT 30
61869: PUSH
61870: LD_INT 31
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: LIST
61881: PPUSH
61882: CALL_OW 72
61886: PUSH
61887: LD_VAR 0 2
61891: PPUSH
61892: LD_INT 2
61894: PUSH
61895: LD_INT 30
61897: PUSH
61898: LD_INT 4
61900: PUSH
61901: EMPTY
61902: LIST
61903: LIST
61904: PUSH
61905: LD_INT 30
61907: PUSH
61908: LD_INT 5
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: LIST
61919: PPUSH
61920: CALL_OW 72
61924: ADD
61925: ST_TO_ADDR
61926: GO 62174
61928: LD_INT 2
61930: DOUBLE
61931: EQUAL
61932: IFTRUE 61942
61934: LD_INT 16
61936: DOUBLE
61937: EQUAL
61938: IFTRUE 61942
61940: GO 61988
61942: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61943: LD_ADDR_VAR 0 8
61947: PUSH
61948: LD_VAR 0 2
61952: PPUSH
61953: LD_INT 2
61955: PUSH
61956: LD_INT 30
61958: PUSH
61959: LD_INT 0
61961: PUSH
61962: EMPTY
61963: LIST
61964: LIST
61965: PUSH
61966: LD_INT 30
61968: PUSH
61969: LD_INT 1
61971: PUSH
61972: EMPTY
61973: LIST
61974: LIST
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: LIST
61980: PPUSH
61981: CALL_OW 72
61985: ST_TO_ADDR
61986: GO 62174
61988: LD_INT 3
61990: DOUBLE
61991: EQUAL
61992: IFTRUE 61996
61994: GO 62042
61996: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61997: LD_ADDR_VAR 0 8
62001: PUSH
62002: LD_VAR 0 2
62006: PPUSH
62007: LD_INT 2
62009: PUSH
62010: LD_INT 30
62012: PUSH
62013: LD_INT 2
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: PUSH
62020: LD_INT 30
62022: PUSH
62023: LD_INT 3
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: LIST
62034: PPUSH
62035: CALL_OW 72
62039: ST_TO_ADDR
62040: GO 62174
62042: LD_INT 4
62044: DOUBLE
62045: EQUAL
62046: IFTRUE 62050
62048: GO 62107
62050: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62051: LD_ADDR_VAR 0 8
62055: PUSH
62056: LD_VAR 0 2
62060: PPUSH
62061: LD_INT 2
62063: PUSH
62064: LD_INT 30
62066: PUSH
62067: LD_INT 6
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: LD_INT 30
62076: PUSH
62077: LD_INT 7
62079: PUSH
62080: EMPTY
62081: LIST
62082: LIST
62083: PUSH
62084: LD_INT 30
62086: PUSH
62087: LD_INT 8
62089: PUSH
62090: EMPTY
62091: LIST
62092: LIST
62093: PUSH
62094: EMPTY
62095: LIST
62096: LIST
62097: LIST
62098: LIST
62099: PPUSH
62100: CALL_OW 72
62104: ST_TO_ADDR
62105: GO 62174
62107: LD_INT 5
62109: DOUBLE
62110: EQUAL
62111: IFTRUE 62127
62113: LD_INT 8
62115: DOUBLE
62116: EQUAL
62117: IFTRUE 62127
62119: LD_INT 9
62121: DOUBLE
62122: EQUAL
62123: IFTRUE 62127
62125: GO 62173
62127: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62128: LD_ADDR_VAR 0 8
62132: PUSH
62133: LD_VAR 0 2
62137: PPUSH
62138: LD_INT 2
62140: PUSH
62141: LD_INT 30
62143: PUSH
62144: LD_INT 4
62146: PUSH
62147: EMPTY
62148: LIST
62149: LIST
62150: PUSH
62151: LD_INT 30
62153: PUSH
62154: LD_INT 5
62156: PUSH
62157: EMPTY
62158: LIST
62159: LIST
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: LIST
62165: PPUSH
62166: CALL_OW 72
62170: ST_TO_ADDR
62171: GO 62174
62173: POP
// if not tmp then
62174: LD_VAR 0 8
62178: NOT
62179: IFFALSE 62183
// exit ;
62181: GO 62643
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62183: LD_VAR 0 4
62187: PUSH
62188: LD_INT 1
62190: PUSH
62191: LD_INT 15
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: IN
62198: PUSH
62199: LD_EXP 111
62203: PUSH
62204: LD_VAR 0 1
62208: ARRAY
62209: AND
62210: IFFALSE 62366
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62212: LD_ADDR_VAR 0 9
62216: PUSH
62217: LD_EXP 111
62221: PUSH
62222: LD_VAR 0 1
62226: ARRAY
62227: PUSH
62228: LD_INT 1
62230: ARRAY
62231: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62232: LD_VAR 0 9
62236: PUSH
62237: LD_EXP 112
62241: PUSH
62242: LD_VAR 0 1
62246: ARRAY
62247: IN
62248: NOT
62249: IFFALSE 62364
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62251: LD_ADDR_EXP 112
62255: PUSH
62256: LD_EXP 112
62260: PPUSH
62261: LD_VAR 0 1
62265: PUSH
62266: LD_EXP 112
62270: PUSH
62271: LD_VAR 0 1
62275: ARRAY
62276: PUSH
62277: LD_INT 1
62279: PLUS
62280: PUSH
62281: EMPTY
62282: LIST
62283: LIST
62284: PPUSH
62285: LD_VAR 0 9
62289: PPUSH
62290: CALL 74680 0 3
62294: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62295: LD_ADDR_EXP 111
62299: PUSH
62300: LD_EXP 111
62304: PPUSH
62305: LD_VAR 0 1
62309: PPUSH
62310: LD_EXP 111
62314: PUSH
62315: LD_VAR 0 1
62319: ARRAY
62320: PUSH
62321: LD_VAR 0 9
62325: DIFF
62326: PPUSH
62327: CALL_OW 1
62331: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62332: LD_VAR 0 3
62336: PPUSH
62337: LD_EXP 112
62341: PUSH
62342: LD_VAR 0 1
62346: ARRAY
62347: PUSH
62348: LD_EXP 112
62352: PUSH
62353: LD_VAR 0 1
62357: ARRAY
62358: ARRAY
62359: PPUSH
62360: CALL_OW 120
// end ; exit ;
62364: GO 62643
// end ; if tmp > 1 then
62366: LD_VAR 0 8
62370: PUSH
62371: LD_INT 1
62373: GREATER
62374: IFFALSE 62478
// for i = 2 to tmp do
62376: LD_ADDR_VAR 0 6
62380: PUSH
62381: DOUBLE
62382: LD_INT 2
62384: DEC
62385: ST_TO_ADDR
62386: LD_VAR 0 8
62390: PUSH
62391: FOR_TO
62392: IFFALSE 62476
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62394: LD_VAR 0 8
62398: PUSH
62399: LD_VAR 0 6
62403: ARRAY
62404: PPUSH
62405: CALL_OW 461
62409: PUSH
62410: LD_INT 6
62412: EQUAL
62413: IFFALSE 62474
// begin x := tmp [ i ] ;
62415: LD_ADDR_VAR 0 9
62419: PUSH
62420: LD_VAR 0 8
62424: PUSH
62425: LD_VAR 0 6
62429: ARRAY
62430: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62431: LD_ADDR_VAR 0 8
62435: PUSH
62436: LD_VAR 0 8
62440: PPUSH
62441: LD_VAR 0 6
62445: PPUSH
62446: CALL_OW 3
62450: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62451: LD_ADDR_VAR 0 8
62455: PUSH
62456: LD_VAR 0 8
62460: PPUSH
62461: LD_INT 1
62463: PPUSH
62464: LD_VAR 0 9
62468: PPUSH
62469: CALL_OW 2
62473: ST_TO_ADDR
// end ;
62474: GO 62391
62476: POP
62477: POP
// for i in tmp do
62478: LD_ADDR_VAR 0 6
62482: PUSH
62483: LD_VAR 0 8
62487: PUSH
62488: FOR_IN
62489: IFFALSE 62516
// begin if IsNotFull ( i ) then
62491: LD_VAR 0 6
62495: PPUSH
62496: CALL 71902 0 1
62500: IFFALSE 62514
// begin j := i ;
62502: LD_ADDR_VAR 0 7
62506: PUSH
62507: LD_VAR 0 6
62511: ST_TO_ADDR
// break ;
62512: GO 62516
// end ; end ;
62514: GO 62488
62516: POP
62517: POP
// if j then
62518: LD_VAR 0 7
62522: IFFALSE 62540
// ComEnterUnit ( unit , j ) else
62524: LD_VAR 0 3
62528: PPUSH
62529: LD_VAR 0 7
62533: PPUSH
62534: CALL_OW 120
62538: GO 62643
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62540: LD_ADDR_VAR 0 10
62544: PUSH
62545: LD_VAR 0 2
62549: PPUSH
62550: LD_INT 2
62552: PUSH
62553: LD_INT 30
62555: PUSH
62556: LD_INT 0
62558: PUSH
62559: EMPTY
62560: LIST
62561: LIST
62562: PUSH
62563: LD_INT 30
62565: PUSH
62566: LD_INT 1
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: LIST
62577: PPUSH
62578: CALL_OW 72
62582: ST_TO_ADDR
// if depot then
62583: LD_VAR 0 10
62587: IFFALSE 62643
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62589: LD_ADDR_VAR 0 10
62593: PUSH
62594: LD_VAR 0 10
62598: PPUSH
62599: LD_VAR 0 3
62603: PPUSH
62604: CALL_OW 74
62608: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62609: LD_VAR 0 3
62613: PPUSH
62614: LD_VAR 0 10
62618: PPUSH
62619: CALL_OW 296
62623: PUSH
62624: LD_INT 10
62626: GREATER
62627: IFFALSE 62643
// ComStandNearbyBuilding ( unit , depot ) ;
62629: LD_VAR 0 3
62633: PPUSH
62634: LD_VAR 0 10
62638: PPUSH
62639: CALL 71282 0 2
// end ; end ; end ;
62643: LD_VAR 0 5
62647: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62648: LD_INT 0
62650: PPUSH
62651: PPUSH
62652: PPUSH
62653: PPUSH
// if not mc_bases then
62654: LD_EXP 102
62658: NOT
62659: IFFALSE 62663
// exit ;
62661: GO 62902
// for i = 1 to mc_bases do
62663: LD_ADDR_VAR 0 2
62667: PUSH
62668: DOUBLE
62669: LD_INT 1
62671: DEC
62672: ST_TO_ADDR
62673: LD_EXP 102
62677: PUSH
62678: FOR_TO
62679: IFFALSE 62900
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62681: LD_ADDR_VAR 0 4
62685: PUSH
62686: LD_EXP 102
62690: PUSH
62691: LD_VAR 0 2
62695: ARRAY
62696: PPUSH
62697: LD_INT 21
62699: PUSH
62700: LD_INT 1
62702: PUSH
62703: EMPTY
62704: LIST
62705: LIST
62706: PPUSH
62707: CALL_OW 72
62711: PUSH
62712: LD_EXP 131
62716: PUSH
62717: LD_VAR 0 2
62721: ARRAY
62722: UNION
62723: ST_TO_ADDR
// if not tmp then
62724: LD_VAR 0 4
62728: NOT
62729: IFFALSE 62733
// continue ;
62731: GO 62678
// for j in tmp do
62733: LD_ADDR_VAR 0 3
62737: PUSH
62738: LD_VAR 0 4
62742: PUSH
62743: FOR_IN
62744: IFFALSE 62896
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62746: LD_VAR 0 3
62750: PPUSH
62751: CALL_OW 110
62755: NOT
62756: PUSH
62757: LD_VAR 0 3
62761: PPUSH
62762: CALL_OW 314
62766: NOT
62767: AND
62768: PUSH
62769: LD_VAR 0 3
62773: PPUSH
62774: CALL_OW 311
62778: NOT
62779: AND
62780: PUSH
62781: LD_VAR 0 3
62785: PPUSH
62786: CALL_OW 310
62790: NOT
62791: AND
62792: PUSH
62793: LD_VAR 0 3
62797: PUSH
62798: LD_EXP 105
62802: PUSH
62803: LD_VAR 0 2
62807: ARRAY
62808: PUSH
62809: LD_INT 1
62811: ARRAY
62812: IN
62813: NOT
62814: AND
62815: PUSH
62816: LD_VAR 0 3
62820: PUSH
62821: LD_EXP 105
62825: PUSH
62826: LD_VAR 0 2
62830: ARRAY
62831: PUSH
62832: LD_INT 2
62834: ARRAY
62835: IN
62836: NOT
62837: AND
62838: PUSH
62839: LD_VAR 0 3
62843: PUSH
62844: LD_EXP 114
62848: PUSH
62849: LD_VAR 0 2
62853: ARRAY
62854: IN
62855: NOT
62856: AND
62857: IFFALSE 62894
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62859: LD_VAR 0 2
62863: PPUSH
62864: LD_EXP 102
62868: PUSH
62869: LD_VAR 0 2
62873: ARRAY
62874: PPUSH
62875: LD_VAR 0 3
62879: PPUSH
62880: LD_VAR 0 3
62884: PPUSH
62885: CALL_OW 257
62889: PPUSH
62890: CALL 61708 0 4
// end ;
62894: GO 62743
62896: POP
62897: POP
// end ;
62898: GO 62678
62900: POP
62901: POP
// end ;
62902: LD_VAR 0 1
62906: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62907: LD_INT 0
62909: PPUSH
62910: PPUSH
62911: PPUSH
62912: PPUSH
62913: PPUSH
62914: PPUSH
// if not mc_bases [ base ] then
62915: LD_EXP 102
62919: PUSH
62920: LD_VAR 0 1
62924: ARRAY
62925: NOT
62926: IFFALSE 62930
// exit ;
62928: GO 63131
// tmp := [ ] ;
62930: LD_ADDR_VAR 0 6
62934: PUSH
62935: EMPTY
62936: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62937: LD_ADDR_VAR 0 7
62941: PUSH
62942: LD_VAR 0 3
62946: PPUSH
62947: LD_INT 0
62949: PPUSH
62950: CALL_OW 517
62954: ST_TO_ADDR
// if not list then
62955: LD_VAR 0 7
62959: NOT
62960: IFFALSE 62964
// exit ;
62962: GO 63131
// c := Count ( list [ 1 ] ) ;
62964: LD_ADDR_VAR 0 9
62968: PUSH
62969: LD_VAR 0 7
62973: PUSH
62974: LD_INT 1
62976: ARRAY
62977: PPUSH
62978: CALL 71820 0 1
62982: ST_TO_ADDR
// if amount > c then
62983: LD_VAR 0 2
62987: PUSH
62988: LD_VAR 0 9
62992: GREATER
62993: IFFALSE 63005
// amount := c ;
62995: LD_ADDR_VAR 0 2
62999: PUSH
63000: LD_VAR 0 9
63004: ST_TO_ADDR
// for i := 1 to amount do
63005: LD_ADDR_VAR 0 5
63009: PUSH
63010: DOUBLE
63011: LD_INT 1
63013: DEC
63014: ST_TO_ADDR
63015: LD_VAR 0 2
63019: PUSH
63020: FOR_TO
63021: IFFALSE 63079
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63023: LD_ADDR_VAR 0 6
63027: PUSH
63028: LD_VAR 0 6
63032: PPUSH
63033: LD_VAR 0 5
63037: PPUSH
63038: LD_VAR 0 7
63042: PUSH
63043: LD_INT 1
63045: ARRAY
63046: PUSH
63047: LD_VAR 0 5
63051: ARRAY
63052: PUSH
63053: LD_VAR 0 7
63057: PUSH
63058: LD_INT 2
63060: ARRAY
63061: PUSH
63062: LD_VAR 0 5
63066: ARRAY
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: PPUSH
63072: CALL_OW 1
63076: ST_TO_ADDR
63077: GO 63020
63079: POP
63080: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63081: LD_ADDR_EXP 115
63085: PUSH
63086: LD_EXP 115
63090: PPUSH
63091: LD_VAR 0 1
63095: PPUSH
63096: LD_VAR 0 6
63100: PPUSH
63101: CALL_OW 1
63105: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63106: LD_ADDR_EXP 117
63110: PUSH
63111: LD_EXP 117
63115: PPUSH
63116: LD_VAR 0 1
63120: PPUSH
63121: LD_VAR 0 3
63125: PPUSH
63126: CALL_OW 1
63130: ST_TO_ADDR
// end ;
63131: LD_VAR 0 4
63135: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63136: LD_INT 0
63138: PPUSH
// if not mc_bases [ base ] then
63139: LD_EXP 102
63143: PUSH
63144: LD_VAR 0 1
63148: ARRAY
63149: NOT
63150: IFFALSE 63154
// exit ;
63152: GO 63179
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63154: LD_ADDR_EXP 107
63158: PUSH
63159: LD_EXP 107
63163: PPUSH
63164: LD_VAR 0 1
63168: PPUSH
63169: LD_VAR 0 2
63173: PPUSH
63174: CALL_OW 1
63178: ST_TO_ADDR
// end ;
63179: LD_VAR 0 3
63183: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63184: LD_INT 0
63186: PPUSH
// if not mc_bases [ base ] then
63187: LD_EXP 102
63191: PUSH
63192: LD_VAR 0 1
63196: ARRAY
63197: NOT
63198: IFFALSE 63202
// exit ;
63200: GO 63239
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63202: LD_ADDR_EXP 107
63206: PUSH
63207: LD_EXP 107
63211: PPUSH
63212: LD_VAR 0 1
63216: PPUSH
63217: LD_EXP 107
63221: PUSH
63222: LD_VAR 0 1
63226: ARRAY
63227: PUSH
63228: LD_VAR 0 2
63232: UNION
63233: PPUSH
63234: CALL_OW 1
63238: ST_TO_ADDR
// end ;
63239: LD_VAR 0 3
63243: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63244: LD_INT 0
63246: PPUSH
// if not mc_bases [ base ] then
63247: LD_EXP 102
63251: PUSH
63252: LD_VAR 0 1
63256: ARRAY
63257: NOT
63258: IFFALSE 63262
// exit ;
63260: GO 63287
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63262: LD_ADDR_EXP 123
63266: PUSH
63267: LD_EXP 123
63271: PPUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: LD_VAR 0 2
63281: PPUSH
63282: CALL_OW 1
63286: ST_TO_ADDR
// end ;
63287: LD_VAR 0 3
63291: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63292: LD_INT 0
63294: PPUSH
// if not mc_bases [ base ] then
63295: LD_EXP 102
63299: PUSH
63300: LD_VAR 0 1
63304: ARRAY
63305: NOT
63306: IFFALSE 63310
// exit ;
63308: GO 63347
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63310: LD_ADDR_EXP 123
63314: PUSH
63315: LD_EXP 123
63319: PPUSH
63320: LD_VAR 0 1
63324: PPUSH
63325: LD_EXP 123
63329: PUSH
63330: LD_VAR 0 1
63334: ARRAY
63335: PUSH
63336: LD_VAR 0 2
63340: ADD
63341: PPUSH
63342: CALL_OW 1
63346: ST_TO_ADDR
// end ;
63347: LD_VAR 0 3
63351: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63352: LD_INT 0
63354: PPUSH
// if not mc_bases [ base ] then
63355: LD_EXP 102
63359: PUSH
63360: LD_VAR 0 1
63364: ARRAY
63365: NOT
63366: IFFALSE 63370
// exit ;
63368: GO 63424
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63370: LD_ADDR_EXP 124
63374: PUSH
63375: LD_EXP 124
63379: PPUSH
63380: LD_VAR 0 1
63384: PPUSH
63385: LD_VAR 0 2
63389: PPUSH
63390: CALL_OW 1
63394: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63395: LD_ADDR_EXP 113
63399: PUSH
63400: LD_EXP 113
63404: PPUSH
63405: LD_VAR 0 1
63409: PPUSH
63410: LD_VAR 0 2
63414: PUSH
63415: LD_INT 0
63417: PLUS
63418: PPUSH
63419: CALL_OW 1
63423: ST_TO_ADDR
// end ;
63424: LD_VAR 0 3
63428: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63429: LD_INT 0
63431: PPUSH
// if not mc_bases [ base ] then
63432: LD_EXP 102
63436: PUSH
63437: LD_VAR 0 1
63441: ARRAY
63442: NOT
63443: IFFALSE 63447
// exit ;
63445: GO 63472
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63447: LD_ADDR_EXP 113
63451: PUSH
63452: LD_EXP 113
63456: PPUSH
63457: LD_VAR 0 1
63461: PPUSH
63462: LD_VAR 0 2
63466: PPUSH
63467: CALL_OW 1
63471: ST_TO_ADDR
// end ;
63472: LD_VAR 0 3
63476: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63477: LD_INT 0
63479: PPUSH
63480: PPUSH
63481: PPUSH
63482: PPUSH
// if not mc_bases [ base ] then
63483: LD_EXP 102
63487: PUSH
63488: LD_VAR 0 1
63492: ARRAY
63493: NOT
63494: IFFALSE 63498
// exit ;
63496: GO 63563
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63498: LD_ADDR_EXP 122
63502: PUSH
63503: LD_EXP 122
63507: PPUSH
63508: LD_VAR 0 1
63512: PUSH
63513: LD_EXP 122
63517: PUSH
63518: LD_VAR 0 1
63522: ARRAY
63523: PUSH
63524: LD_INT 1
63526: PLUS
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PPUSH
63532: LD_VAR 0 1
63536: PUSH
63537: LD_VAR 0 2
63541: PUSH
63542: LD_VAR 0 3
63546: PUSH
63547: LD_VAR 0 4
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: PPUSH
63558: CALL 74680 0 3
63562: ST_TO_ADDR
// end ;
63563: LD_VAR 0 5
63567: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63568: LD_INT 0
63570: PPUSH
// if not mc_bases [ base ] then
63571: LD_EXP 102
63575: PUSH
63576: LD_VAR 0 1
63580: ARRAY
63581: NOT
63582: IFFALSE 63586
// exit ;
63584: GO 63611
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63586: LD_ADDR_EXP 139
63590: PUSH
63591: LD_EXP 139
63595: PPUSH
63596: LD_VAR 0 1
63600: PPUSH
63601: LD_VAR 0 2
63605: PPUSH
63606: CALL_OW 1
63610: ST_TO_ADDR
// end ;
63611: LD_VAR 0 3
63615: RET
// export function MC_GetMinesField ( base ) ; begin
63616: LD_INT 0
63618: PPUSH
// result := mc_mines [ base ] ;
63619: LD_ADDR_VAR 0 2
63623: PUSH
63624: LD_EXP 115
63628: PUSH
63629: LD_VAR 0 1
63633: ARRAY
63634: ST_TO_ADDR
// end ;
63635: LD_VAR 0 2
63639: RET
// export function MC_GetProduceList ( base ) ; begin
63640: LD_INT 0
63642: PPUSH
// result := mc_produce [ base ] ;
63643: LD_ADDR_VAR 0 2
63647: PUSH
63648: LD_EXP 123
63652: PUSH
63653: LD_VAR 0 1
63657: ARRAY
63658: ST_TO_ADDR
// end ;
63659: LD_VAR 0 2
63663: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63664: LD_INT 0
63666: PPUSH
63667: PPUSH
// if not mc_bases then
63668: LD_EXP 102
63672: NOT
63673: IFFALSE 63677
// exit ;
63675: GO 63742
// if mc_bases [ base ] then
63677: LD_EXP 102
63681: PUSH
63682: LD_VAR 0 1
63686: ARRAY
63687: IFFALSE 63742
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63689: LD_ADDR_VAR 0 3
63693: PUSH
63694: LD_EXP 102
63698: PUSH
63699: LD_VAR 0 1
63703: ARRAY
63704: PPUSH
63705: LD_INT 30
63707: PUSH
63708: LD_VAR 0 2
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: CALL_OW 72
63721: ST_TO_ADDR
// if result then
63722: LD_VAR 0 3
63726: IFFALSE 63742
// result := result [ 1 ] ;
63728: LD_ADDR_VAR 0 3
63732: PUSH
63733: LD_VAR 0 3
63737: PUSH
63738: LD_INT 1
63740: ARRAY
63741: ST_TO_ADDR
// end ; end ;
63742: LD_VAR 0 3
63746: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63747: LD_INT 0
63749: PPUSH
63750: PPUSH
// if not mc_bases then
63751: LD_EXP 102
63755: NOT
63756: IFFALSE 63760
// exit ;
63758: GO 63805
// if mc_bases [ base ] then
63760: LD_EXP 102
63764: PUSH
63765: LD_VAR 0 1
63769: ARRAY
63770: IFFALSE 63805
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63772: LD_ADDR_VAR 0 3
63776: PUSH
63777: LD_EXP 102
63781: PUSH
63782: LD_VAR 0 1
63786: ARRAY
63787: PPUSH
63788: LD_INT 30
63790: PUSH
63791: LD_VAR 0 2
63795: PUSH
63796: EMPTY
63797: LIST
63798: LIST
63799: PPUSH
63800: CALL_OW 72
63804: ST_TO_ADDR
// end ;
63805: LD_VAR 0 3
63809: RET
// export function MC_SetTame ( base , area ) ; begin
63810: LD_INT 0
63812: PPUSH
// if not mc_bases or not base then
63813: LD_EXP 102
63817: NOT
63818: PUSH
63819: LD_VAR 0 1
63823: NOT
63824: OR
63825: IFFALSE 63829
// exit ;
63827: GO 63854
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63829: LD_ADDR_EXP 130
63833: PUSH
63834: LD_EXP 130
63838: PPUSH
63839: LD_VAR 0 1
63843: PPUSH
63844: LD_VAR 0 2
63848: PPUSH
63849: CALL_OW 1
63853: ST_TO_ADDR
// end ;
63854: LD_VAR 0 3
63858: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63859: LD_INT 0
63861: PPUSH
63862: PPUSH
// if not mc_bases or not base then
63863: LD_EXP 102
63867: NOT
63868: PUSH
63869: LD_VAR 0 1
63873: NOT
63874: OR
63875: IFFALSE 63879
// exit ;
63877: GO 63981
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63879: LD_ADDR_VAR 0 4
63883: PUSH
63884: LD_EXP 102
63888: PUSH
63889: LD_VAR 0 1
63893: ARRAY
63894: PPUSH
63895: LD_INT 30
63897: PUSH
63898: LD_VAR 0 2
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PPUSH
63907: CALL_OW 72
63911: ST_TO_ADDR
// if not tmp then
63912: LD_VAR 0 4
63916: NOT
63917: IFFALSE 63921
// exit ;
63919: GO 63981
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63921: LD_ADDR_EXP 134
63925: PUSH
63926: LD_EXP 134
63930: PPUSH
63931: LD_VAR 0 1
63935: PPUSH
63936: LD_EXP 134
63940: PUSH
63941: LD_VAR 0 1
63945: ARRAY
63946: PPUSH
63947: LD_EXP 134
63951: PUSH
63952: LD_VAR 0 1
63956: ARRAY
63957: PUSH
63958: LD_INT 1
63960: PLUS
63961: PPUSH
63962: LD_VAR 0 4
63966: PUSH
63967: LD_INT 1
63969: ARRAY
63970: PPUSH
63971: CALL_OW 2
63975: PPUSH
63976: CALL_OW 1
63980: ST_TO_ADDR
// end ;
63981: LD_VAR 0 3
63985: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63986: LD_INT 0
63988: PPUSH
63989: PPUSH
// if not mc_bases or not base or not kinds then
63990: LD_EXP 102
63994: NOT
63995: PUSH
63996: LD_VAR 0 1
64000: NOT
64001: OR
64002: PUSH
64003: LD_VAR 0 2
64007: NOT
64008: OR
64009: IFFALSE 64013
// exit ;
64011: GO 64074
// for i in kinds do
64013: LD_ADDR_VAR 0 4
64017: PUSH
64018: LD_VAR 0 2
64022: PUSH
64023: FOR_IN
64024: IFFALSE 64072
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64026: LD_ADDR_EXP 136
64030: PUSH
64031: LD_EXP 136
64035: PPUSH
64036: LD_VAR 0 1
64040: PUSH
64041: LD_EXP 136
64045: PUSH
64046: LD_VAR 0 1
64050: ARRAY
64051: PUSH
64052: LD_INT 1
64054: PLUS
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PPUSH
64060: LD_VAR 0 4
64064: PPUSH
64065: CALL 74680 0 3
64069: ST_TO_ADDR
64070: GO 64023
64072: POP
64073: POP
// end ;
64074: LD_VAR 0 3
64078: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64079: LD_INT 0
64081: PPUSH
// if not mc_bases or not base or not areas then
64082: LD_EXP 102
64086: NOT
64087: PUSH
64088: LD_VAR 0 1
64092: NOT
64093: OR
64094: PUSH
64095: LD_VAR 0 2
64099: NOT
64100: OR
64101: IFFALSE 64105
// exit ;
64103: GO 64130
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64105: LD_ADDR_EXP 120
64109: PUSH
64110: LD_EXP 120
64114: PPUSH
64115: LD_VAR 0 1
64119: PPUSH
64120: LD_VAR 0 2
64124: PPUSH
64125: CALL_OW 1
64129: ST_TO_ADDR
// end ;
64130: LD_VAR 0 3
64134: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64135: LD_INT 0
64137: PPUSH
// if not mc_bases or not base or not teleports_exit then
64138: LD_EXP 102
64142: NOT
64143: PUSH
64144: LD_VAR 0 1
64148: NOT
64149: OR
64150: PUSH
64151: LD_VAR 0 2
64155: NOT
64156: OR
64157: IFFALSE 64161
// exit ;
64159: GO 64186
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64161: LD_ADDR_EXP 137
64165: PUSH
64166: LD_EXP 137
64170: PPUSH
64171: LD_VAR 0 1
64175: PPUSH
64176: LD_VAR 0 2
64180: PPUSH
64181: CALL_OW 1
64185: ST_TO_ADDR
// end ;
64186: LD_VAR 0 3
64190: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64191: LD_INT 0
64193: PPUSH
64194: PPUSH
64195: PPUSH
// if not mc_bases or not base or not ext_list then
64196: LD_EXP 102
64200: NOT
64201: PUSH
64202: LD_VAR 0 1
64206: NOT
64207: OR
64208: PUSH
64209: LD_VAR 0 5
64213: NOT
64214: OR
64215: IFFALSE 64219
// exit ;
64217: GO 64392
// tmp := GetFacExtXYD ( x , y , d ) ;
64219: LD_ADDR_VAR 0 8
64223: PUSH
64224: LD_VAR 0 2
64228: PPUSH
64229: LD_VAR 0 3
64233: PPUSH
64234: LD_VAR 0 4
64238: PPUSH
64239: CALL 105043 0 3
64243: ST_TO_ADDR
// if not tmp then
64244: LD_VAR 0 8
64248: NOT
64249: IFFALSE 64253
// exit ;
64251: GO 64392
// for i in tmp do
64253: LD_ADDR_VAR 0 7
64257: PUSH
64258: LD_VAR 0 8
64262: PUSH
64263: FOR_IN
64264: IFFALSE 64390
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64266: LD_ADDR_EXP 107
64270: PUSH
64271: LD_EXP 107
64275: PPUSH
64276: LD_VAR 0 1
64280: PPUSH
64281: LD_EXP 107
64285: PUSH
64286: LD_VAR 0 1
64290: ARRAY
64291: PPUSH
64292: LD_EXP 107
64296: PUSH
64297: LD_VAR 0 1
64301: ARRAY
64302: PUSH
64303: LD_INT 1
64305: PLUS
64306: PPUSH
64307: LD_VAR 0 5
64311: PUSH
64312: LD_INT 1
64314: ARRAY
64315: PUSH
64316: LD_VAR 0 7
64320: PUSH
64321: LD_INT 1
64323: ARRAY
64324: PUSH
64325: LD_VAR 0 7
64329: PUSH
64330: LD_INT 2
64332: ARRAY
64333: PUSH
64334: LD_VAR 0 7
64338: PUSH
64339: LD_INT 3
64341: ARRAY
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: PPUSH
64349: CALL_OW 2
64353: PPUSH
64354: CALL_OW 1
64358: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64359: LD_ADDR_VAR 0 5
64363: PUSH
64364: LD_VAR 0 5
64368: PPUSH
64369: LD_INT 1
64371: PPUSH
64372: CALL_OW 3
64376: ST_TO_ADDR
// if not ext_list then
64377: LD_VAR 0 5
64381: NOT
64382: IFFALSE 64388
// exit ;
64384: POP
64385: POP
64386: GO 64392
// end ;
64388: GO 64263
64390: POP
64391: POP
// end ;
64392: LD_VAR 0 6
64396: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64397: LD_INT 0
64399: PPUSH
// if not mc_bases or not base or not weapon_list then
64400: LD_EXP 102
64404: NOT
64405: PUSH
64406: LD_VAR 0 1
64410: NOT
64411: OR
64412: PUSH
64413: LD_VAR 0 2
64417: NOT
64418: OR
64419: IFFALSE 64423
// exit ;
64421: GO 64448
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64423: LD_ADDR_EXP 141
64427: PUSH
64428: LD_EXP 141
64432: PPUSH
64433: LD_VAR 0 1
64437: PPUSH
64438: LD_VAR 0 2
64442: PPUSH
64443: CALL_OW 1
64447: ST_TO_ADDR
// end ;
64448: LD_VAR 0 3
64452: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64453: LD_INT 0
64455: PPUSH
// if not mc_bases or not base or not tech_list then
64456: LD_EXP 102
64460: NOT
64461: PUSH
64462: LD_VAR 0 1
64466: NOT
64467: OR
64468: PUSH
64469: LD_VAR 0 2
64473: NOT
64474: OR
64475: IFFALSE 64479
// exit ;
64477: GO 64504
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64479: LD_ADDR_EXP 129
64483: PUSH
64484: LD_EXP 129
64488: PPUSH
64489: LD_VAR 0 1
64493: PPUSH
64494: LD_VAR 0 2
64498: PPUSH
64499: CALL_OW 1
64503: ST_TO_ADDR
// end ;
64504: LD_VAR 0 3
64508: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64509: LD_INT 0
64511: PPUSH
// if not mc_bases or not parking_area or not base then
64512: LD_EXP 102
64516: NOT
64517: PUSH
64518: LD_VAR 0 2
64522: NOT
64523: OR
64524: PUSH
64525: LD_VAR 0 1
64529: NOT
64530: OR
64531: IFFALSE 64535
// exit ;
64533: GO 64560
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64535: LD_ADDR_EXP 126
64539: PUSH
64540: LD_EXP 126
64544: PPUSH
64545: LD_VAR 0 1
64549: PPUSH
64550: LD_VAR 0 2
64554: PPUSH
64555: CALL_OW 1
64559: ST_TO_ADDR
// end ;
64560: LD_VAR 0 3
64564: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64565: LD_INT 0
64567: PPUSH
// if not mc_bases or not base or not scan_area then
64568: LD_EXP 102
64572: NOT
64573: PUSH
64574: LD_VAR 0 1
64578: NOT
64579: OR
64580: PUSH
64581: LD_VAR 0 2
64585: NOT
64586: OR
64587: IFFALSE 64591
// exit ;
64589: GO 64616
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64591: LD_ADDR_EXP 127
64595: PUSH
64596: LD_EXP 127
64600: PPUSH
64601: LD_VAR 0 1
64605: PPUSH
64606: LD_VAR 0 2
64610: PPUSH
64611: CALL_OW 1
64615: ST_TO_ADDR
// end ;
64616: LD_VAR 0 3
64620: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64621: LD_INT 0
64623: PPUSH
64624: PPUSH
// if not mc_bases or not base then
64625: LD_EXP 102
64629: NOT
64630: PUSH
64631: LD_VAR 0 1
64635: NOT
64636: OR
64637: IFFALSE 64641
// exit ;
64639: GO 64705
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64641: LD_ADDR_VAR 0 3
64645: PUSH
64646: LD_INT 1
64648: PUSH
64649: LD_INT 2
64651: PUSH
64652: LD_INT 3
64654: PUSH
64655: LD_INT 4
64657: PUSH
64658: LD_INT 11
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64668: LD_ADDR_EXP 129
64672: PUSH
64673: LD_EXP 129
64677: PPUSH
64678: LD_VAR 0 1
64682: PPUSH
64683: LD_EXP 129
64687: PUSH
64688: LD_VAR 0 1
64692: ARRAY
64693: PUSH
64694: LD_VAR 0 3
64698: DIFF
64699: PPUSH
64700: CALL_OW 1
64704: ST_TO_ADDR
// end ;
64705: LD_VAR 0 2
64709: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64710: LD_INT 0
64712: PPUSH
// result := mc_vehicles [ base ] ;
64713: LD_ADDR_VAR 0 3
64717: PUSH
64718: LD_EXP 121
64722: PUSH
64723: LD_VAR 0 1
64727: ARRAY
64728: ST_TO_ADDR
// if onlyCombat then
64729: LD_VAR 0 2
64733: IFFALSE 64905
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64735: LD_ADDR_VAR 0 3
64739: PUSH
64740: LD_VAR 0 3
64744: PUSH
64745: LD_VAR 0 3
64749: PPUSH
64750: LD_INT 2
64752: PUSH
64753: LD_INT 34
64755: PUSH
64756: LD_INT 12
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: LD_INT 34
64765: PUSH
64766: LD_INT 51
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 34
64775: PUSH
64776: LD_INT 89
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: PUSH
64783: LD_INT 34
64785: PUSH
64786: LD_INT 32
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 34
64795: PUSH
64796: LD_INT 13
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 34
64805: PUSH
64806: LD_INT 52
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 34
64815: PUSH
64816: LD_INT 88
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 34
64825: PUSH
64826: LD_INT 14
64828: PUSH
64829: EMPTY
64830: LIST
64831: LIST
64832: PUSH
64833: LD_INT 34
64835: PUSH
64836: LD_INT 53
64838: PUSH
64839: EMPTY
64840: LIST
64841: LIST
64842: PUSH
64843: LD_INT 34
64845: PUSH
64846: LD_INT 98
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PUSH
64853: LD_INT 34
64855: PUSH
64856: LD_INT 31
64858: PUSH
64859: EMPTY
64860: LIST
64861: LIST
64862: PUSH
64863: LD_INT 34
64865: PUSH
64866: LD_INT 48
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 34
64875: PUSH
64876: LD_INT 8
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: PPUSH
64899: CALL_OW 72
64903: DIFF
64904: ST_TO_ADDR
// end ; end_of_file
64905: LD_VAR 0 3
64909: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64910: LD_INT 0
64912: PPUSH
64913: PPUSH
64914: PPUSH
// if not mc_bases or not skirmish then
64915: LD_EXP 102
64919: NOT
64920: PUSH
64921: LD_EXP 100
64925: NOT
64926: OR
64927: IFFALSE 64931
// exit ;
64929: GO 65096
// for i = 1 to mc_bases do
64931: LD_ADDR_VAR 0 4
64935: PUSH
64936: DOUBLE
64937: LD_INT 1
64939: DEC
64940: ST_TO_ADDR
64941: LD_EXP 102
64945: PUSH
64946: FOR_TO
64947: IFFALSE 65094
// begin if sci in mc_bases [ i ] then
64949: LD_VAR 0 2
64953: PUSH
64954: LD_EXP 102
64958: PUSH
64959: LD_VAR 0 4
64963: ARRAY
64964: IN
64965: IFFALSE 65092
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64967: LD_ADDR_EXP 131
64971: PUSH
64972: LD_EXP 131
64976: PPUSH
64977: LD_VAR 0 4
64981: PUSH
64982: LD_EXP 131
64986: PUSH
64987: LD_VAR 0 4
64991: ARRAY
64992: PUSH
64993: LD_INT 1
64995: PLUS
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PPUSH
65001: LD_VAR 0 1
65005: PPUSH
65006: CALL 74680 0 3
65010: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65011: LD_ADDR_VAR 0 5
65015: PUSH
65016: LD_EXP 102
65020: PUSH
65021: LD_VAR 0 4
65025: ARRAY
65026: PPUSH
65027: LD_INT 2
65029: PUSH
65030: LD_INT 30
65032: PUSH
65033: LD_INT 0
65035: PUSH
65036: EMPTY
65037: LIST
65038: LIST
65039: PUSH
65040: LD_INT 30
65042: PUSH
65043: LD_INT 1
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: LIST
65054: PPUSH
65055: CALL_OW 72
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 74
65069: ST_TO_ADDR
// if tmp then
65070: LD_VAR 0 5
65074: IFFALSE 65090
// ComStandNearbyBuilding ( ape , tmp ) ;
65076: LD_VAR 0 1
65080: PPUSH
65081: LD_VAR 0 5
65085: PPUSH
65086: CALL 71282 0 2
// break ;
65090: GO 65094
// end ; end ;
65092: GO 64946
65094: POP
65095: POP
// end ;
65096: LD_VAR 0 3
65100: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65101: LD_INT 0
65103: PPUSH
65104: PPUSH
65105: PPUSH
// if not mc_bases or not skirmish then
65106: LD_EXP 102
65110: NOT
65111: PUSH
65112: LD_EXP 100
65116: NOT
65117: OR
65118: IFFALSE 65122
// exit ;
65120: GO 65211
// for i = 1 to mc_bases do
65122: LD_ADDR_VAR 0 4
65126: PUSH
65127: DOUBLE
65128: LD_INT 1
65130: DEC
65131: ST_TO_ADDR
65132: LD_EXP 102
65136: PUSH
65137: FOR_TO
65138: IFFALSE 65209
// begin if building in mc_busy_turret_list [ i ] then
65140: LD_VAR 0 1
65144: PUSH
65145: LD_EXP 112
65149: PUSH
65150: LD_VAR 0 4
65154: ARRAY
65155: IN
65156: IFFALSE 65207
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65158: LD_ADDR_VAR 0 5
65162: PUSH
65163: LD_EXP 112
65167: PUSH
65168: LD_VAR 0 4
65172: ARRAY
65173: PUSH
65174: LD_VAR 0 1
65178: DIFF
65179: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65180: LD_ADDR_EXP 112
65184: PUSH
65185: LD_EXP 112
65189: PPUSH
65190: LD_VAR 0 4
65194: PPUSH
65195: LD_VAR 0 5
65199: PPUSH
65200: CALL_OW 1
65204: ST_TO_ADDR
// break ;
65205: GO 65209
// end ; end ;
65207: GO 65137
65209: POP
65210: POP
// end ;
65211: LD_VAR 0 3
65215: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65216: LD_INT 0
65218: PPUSH
65219: PPUSH
65220: PPUSH
// if not mc_bases or not skirmish then
65221: LD_EXP 102
65225: NOT
65226: PUSH
65227: LD_EXP 100
65231: NOT
65232: OR
65233: IFFALSE 65237
// exit ;
65235: GO 65436
// for i = 1 to mc_bases do
65237: LD_ADDR_VAR 0 5
65241: PUSH
65242: DOUBLE
65243: LD_INT 1
65245: DEC
65246: ST_TO_ADDR
65247: LD_EXP 102
65251: PUSH
65252: FOR_TO
65253: IFFALSE 65434
// if building in mc_bases [ i ] then
65255: LD_VAR 0 1
65259: PUSH
65260: LD_EXP 102
65264: PUSH
65265: LD_VAR 0 5
65269: ARRAY
65270: IN
65271: IFFALSE 65432
// begin tmp := mc_bases [ i ] diff building ;
65273: LD_ADDR_VAR 0 6
65277: PUSH
65278: LD_EXP 102
65282: PUSH
65283: LD_VAR 0 5
65287: ARRAY
65288: PUSH
65289: LD_VAR 0 1
65293: DIFF
65294: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65295: LD_ADDR_EXP 102
65299: PUSH
65300: LD_EXP 102
65304: PPUSH
65305: LD_VAR 0 5
65309: PPUSH
65310: LD_VAR 0 6
65314: PPUSH
65315: CALL_OW 1
65319: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65320: LD_VAR 0 1
65324: PUSH
65325: LD_EXP 110
65329: PUSH
65330: LD_VAR 0 5
65334: ARRAY
65335: IN
65336: IFFALSE 65375
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65338: LD_ADDR_EXP 110
65342: PUSH
65343: LD_EXP 110
65347: PPUSH
65348: LD_VAR 0 5
65352: PPUSH
65353: LD_EXP 110
65357: PUSH
65358: LD_VAR 0 5
65362: ARRAY
65363: PUSH
65364: LD_VAR 0 1
65368: DIFF
65369: PPUSH
65370: CALL_OW 1
65374: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65375: LD_VAR 0 1
65379: PUSH
65380: LD_EXP 111
65384: PUSH
65385: LD_VAR 0 5
65389: ARRAY
65390: IN
65391: IFFALSE 65430
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65393: LD_ADDR_EXP 111
65397: PUSH
65398: LD_EXP 111
65402: PPUSH
65403: LD_VAR 0 5
65407: PPUSH
65408: LD_EXP 111
65412: PUSH
65413: LD_VAR 0 5
65417: ARRAY
65418: PUSH
65419: LD_VAR 0 1
65423: DIFF
65424: PPUSH
65425: CALL_OW 1
65429: ST_TO_ADDR
// break ;
65430: GO 65434
// end ;
65432: GO 65252
65434: POP
65435: POP
// end ;
65436: LD_VAR 0 4
65440: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65441: LD_INT 0
65443: PPUSH
65444: PPUSH
65445: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65446: LD_EXP 102
65450: NOT
65451: PUSH
65452: LD_EXP 100
65456: NOT
65457: OR
65458: PUSH
65459: LD_VAR 0 3
65463: PUSH
65464: LD_EXP 128
65468: IN
65469: NOT
65470: OR
65471: IFFALSE 65475
// exit ;
65473: GO 65598
// for i = 1 to mc_vehicles do
65475: LD_ADDR_VAR 0 6
65479: PUSH
65480: DOUBLE
65481: LD_INT 1
65483: DEC
65484: ST_TO_ADDR
65485: LD_EXP 121
65489: PUSH
65490: FOR_TO
65491: IFFALSE 65596
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65493: LD_VAR 0 2
65497: PUSH
65498: LD_EXP 121
65502: PUSH
65503: LD_VAR 0 6
65507: ARRAY
65508: IN
65509: PUSH
65510: LD_VAR 0 1
65514: PUSH
65515: LD_EXP 121
65519: PUSH
65520: LD_VAR 0 6
65524: ARRAY
65525: IN
65526: OR
65527: IFFALSE 65594
// begin tmp := mc_vehicles [ i ] diff old ;
65529: LD_ADDR_VAR 0 7
65533: PUSH
65534: LD_EXP 121
65538: PUSH
65539: LD_VAR 0 6
65543: ARRAY
65544: PUSH
65545: LD_VAR 0 2
65549: DIFF
65550: ST_TO_ADDR
// tmp := tmp diff new ;
65551: LD_ADDR_VAR 0 7
65555: PUSH
65556: LD_VAR 0 7
65560: PUSH
65561: LD_VAR 0 1
65565: DIFF
65566: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65567: LD_ADDR_EXP 121
65571: PUSH
65572: LD_EXP 121
65576: PPUSH
65577: LD_VAR 0 6
65581: PPUSH
65582: LD_VAR 0 7
65586: PPUSH
65587: CALL_OW 1
65591: ST_TO_ADDR
// break ;
65592: GO 65596
// end ;
65594: GO 65490
65596: POP
65597: POP
// end ;
65598: LD_VAR 0 5
65602: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65603: LD_INT 0
65605: PPUSH
65606: PPUSH
65607: PPUSH
65608: PPUSH
// if not mc_bases or not skirmish then
65609: LD_EXP 102
65613: NOT
65614: PUSH
65615: LD_EXP 100
65619: NOT
65620: OR
65621: IFFALSE 65625
// exit ;
65623: GO 66045
// repeat wait ( 0 0$1 ) ;
65625: LD_INT 35
65627: PPUSH
65628: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65632: LD_EXP 146
65636: NOT
65637: IFFALSE 65625
// mc_block_vehicle_constructed_thread := true ;
65639: LD_ADDR_EXP 146
65643: PUSH
65644: LD_INT 1
65646: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65647: LD_ADDR_VAR 0 5
65651: PUSH
65652: LD_VAR 0 1
65656: PPUSH
65657: CALL_OW 255
65661: ST_TO_ADDR
// for i = 1 to mc_bases do
65662: LD_ADDR_VAR 0 4
65666: PUSH
65667: DOUBLE
65668: LD_INT 1
65670: DEC
65671: ST_TO_ADDR
65672: LD_EXP 102
65676: PUSH
65677: FOR_TO
65678: IFFALSE 66035
// begin if factory in mc_bases [ i ] then
65680: LD_VAR 0 2
65684: PUSH
65685: LD_EXP 102
65689: PUSH
65690: LD_VAR 0 4
65694: ARRAY
65695: IN
65696: IFFALSE 66033
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65698: LD_EXP 124
65702: PUSH
65703: LD_VAR 0 4
65707: ARRAY
65708: PUSH
65709: LD_EXP 113
65713: PUSH
65714: LD_VAR 0 4
65718: ARRAY
65719: LESS
65720: PUSH
65721: LD_VAR 0 1
65725: PPUSH
65726: CALL_OW 264
65730: PUSH
65731: LD_INT 31
65733: PUSH
65734: LD_INT 32
65736: PUSH
65737: LD_INT 51
65739: PUSH
65740: LD_INT 89
65742: PUSH
65743: LD_INT 12
65745: PUSH
65746: LD_INT 30
65748: PUSH
65749: LD_INT 98
65751: PUSH
65752: LD_INT 11
65754: PUSH
65755: LD_INT 53
65757: PUSH
65758: LD_INT 14
65760: PUSH
65761: LD_INT 91
65763: PUSH
65764: LD_INT 29
65766: PUSH
65767: LD_INT 99
65769: PUSH
65770: LD_INT 13
65772: PUSH
65773: LD_INT 52
65775: PUSH
65776: LD_INT 88
65778: PUSH
65779: LD_INT 48
65781: PUSH
65782: LD_INT 8
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: IN
65805: NOT
65806: AND
65807: IFFALSE 65855
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65809: LD_ADDR_EXP 124
65813: PUSH
65814: LD_EXP 124
65818: PPUSH
65819: LD_VAR 0 4
65823: PUSH
65824: LD_EXP 124
65828: PUSH
65829: LD_VAR 0 4
65833: ARRAY
65834: PUSH
65835: LD_INT 1
65837: PLUS
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PPUSH
65843: LD_VAR 0 1
65847: PPUSH
65848: CALL 74680 0 3
65852: ST_TO_ADDR
65853: GO 65899
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65855: LD_ADDR_EXP 121
65859: PUSH
65860: LD_EXP 121
65864: PPUSH
65865: LD_VAR 0 4
65869: PUSH
65870: LD_EXP 121
65874: PUSH
65875: LD_VAR 0 4
65879: ARRAY
65880: PUSH
65881: LD_INT 1
65883: PLUS
65884: PUSH
65885: EMPTY
65886: LIST
65887: LIST
65888: PPUSH
65889: LD_VAR 0 1
65893: PPUSH
65894: CALL 74680 0 3
65898: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65899: LD_ADDR_EXP 146
65903: PUSH
65904: LD_INT 0
65906: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65907: LD_VAR 0 1
65911: PPUSH
65912: CALL_OW 263
65916: PUSH
65917: LD_INT 2
65919: EQUAL
65920: IFFALSE 65949
// begin repeat wait ( 0 0$3 ) ;
65922: LD_INT 105
65924: PPUSH
65925: CALL_OW 67
// Connect ( vehicle ) ;
65929: LD_VAR 0 1
65933: PPUSH
65934: CALL 78026 0 1
// until IsControledBy ( vehicle ) ;
65938: LD_VAR 0 1
65942: PPUSH
65943: CALL_OW 312
65947: IFFALSE 65922
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65949: LD_VAR 0 1
65953: PPUSH
65954: LD_EXP 126
65958: PUSH
65959: LD_VAR 0 4
65963: ARRAY
65964: PPUSH
65965: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65969: LD_VAR 0 1
65973: PPUSH
65974: CALL_OW 263
65978: PUSH
65979: LD_INT 1
65981: NONEQUAL
65982: IFFALSE 65986
// break ;
65984: GO 66035
// repeat wait ( 0 0$1 ) ;
65986: LD_INT 35
65988: PPUSH
65989: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65993: LD_VAR 0 1
65997: PPUSH
65998: LD_EXP 126
66002: PUSH
66003: LD_VAR 0 4
66007: ARRAY
66008: PPUSH
66009: CALL_OW 308
66013: IFFALSE 65986
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66015: LD_VAR 0 1
66019: PPUSH
66020: CALL_OW 311
66024: PPUSH
66025: CALL_OW 121
// exit ;
66029: POP
66030: POP
66031: GO 66045
// end ; end ;
66033: GO 65677
66035: POP
66036: POP
// mc_block_vehicle_constructed_thread := false ;
66037: LD_ADDR_EXP 146
66041: PUSH
66042: LD_INT 0
66044: ST_TO_ADDR
// end ;
66045: LD_VAR 0 3
66049: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66050: LD_INT 0
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
// if not mc_bases or not skirmish then
66056: LD_EXP 102
66060: NOT
66061: PUSH
66062: LD_EXP 100
66066: NOT
66067: OR
66068: IFFALSE 66072
// exit ;
66070: GO 66425
// repeat wait ( 0 0$1 ) ;
66072: LD_INT 35
66074: PPUSH
66075: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66079: LD_VAR 0 2
66083: PPUSH
66084: LD_VAR 0 3
66088: PPUSH
66089: CALL_OW 284
66093: IFFALSE 66072
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66095: LD_VAR 0 2
66099: PPUSH
66100: LD_VAR 0 3
66104: PPUSH
66105: CALL_OW 283
66109: PUSH
66110: LD_INT 4
66112: EQUAL
66113: IFFALSE 66117
// exit ;
66115: GO 66425
// for i = 1 to mc_bases do
66117: LD_ADDR_VAR 0 7
66121: PUSH
66122: DOUBLE
66123: LD_INT 1
66125: DEC
66126: ST_TO_ADDR
66127: LD_EXP 102
66131: PUSH
66132: FOR_TO
66133: IFFALSE 66423
// begin if mc_crates_area [ i ] then
66135: LD_EXP 120
66139: PUSH
66140: LD_VAR 0 7
66144: ARRAY
66145: IFFALSE 66256
// for j in mc_crates_area [ i ] do
66147: LD_ADDR_VAR 0 8
66151: PUSH
66152: LD_EXP 120
66156: PUSH
66157: LD_VAR 0 7
66161: ARRAY
66162: PUSH
66163: FOR_IN
66164: IFFALSE 66254
// if InArea ( x , y , j ) then
66166: LD_VAR 0 2
66170: PPUSH
66171: LD_VAR 0 3
66175: PPUSH
66176: LD_VAR 0 8
66180: PPUSH
66181: CALL_OW 309
66185: IFFALSE 66252
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66187: LD_ADDR_EXP 118
66191: PUSH
66192: LD_EXP 118
66196: PPUSH
66197: LD_VAR 0 7
66201: PUSH
66202: LD_EXP 118
66206: PUSH
66207: LD_VAR 0 7
66211: ARRAY
66212: PUSH
66213: LD_INT 1
66215: PLUS
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PPUSH
66221: LD_VAR 0 4
66225: PUSH
66226: LD_VAR 0 2
66230: PUSH
66231: LD_VAR 0 3
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: LIST
66240: PPUSH
66241: CALL 74680 0 3
66245: ST_TO_ADDR
// exit ;
66246: POP
66247: POP
66248: POP
66249: POP
66250: GO 66425
// end ;
66252: GO 66163
66254: POP
66255: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66256: LD_ADDR_VAR 0 9
66260: PUSH
66261: LD_EXP 102
66265: PUSH
66266: LD_VAR 0 7
66270: ARRAY
66271: PPUSH
66272: LD_INT 2
66274: PUSH
66275: LD_INT 30
66277: PUSH
66278: LD_INT 0
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 30
66287: PUSH
66288: LD_INT 1
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: LIST
66299: PPUSH
66300: CALL_OW 72
66304: ST_TO_ADDR
// if not depot then
66305: LD_VAR 0 9
66309: NOT
66310: IFFALSE 66314
// continue ;
66312: GO 66132
// for j in depot do
66314: LD_ADDR_VAR 0 8
66318: PUSH
66319: LD_VAR 0 9
66323: PUSH
66324: FOR_IN
66325: IFFALSE 66419
// if GetDistUnitXY ( j , x , y ) < 30 then
66327: LD_VAR 0 8
66331: PPUSH
66332: LD_VAR 0 2
66336: PPUSH
66337: LD_VAR 0 3
66341: PPUSH
66342: CALL_OW 297
66346: PUSH
66347: LD_INT 30
66349: LESS
66350: IFFALSE 66417
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66352: LD_ADDR_EXP 118
66356: PUSH
66357: LD_EXP 118
66361: PPUSH
66362: LD_VAR 0 7
66366: PUSH
66367: LD_EXP 118
66371: PUSH
66372: LD_VAR 0 7
66376: ARRAY
66377: PUSH
66378: LD_INT 1
66380: PLUS
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PPUSH
66386: LD_VAR 0 4
66390: PUSH
66391: LD_VAR 0 2
66395: PUSH
66396: LD_VAR 0 3
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: LIST
66405: PPUSH
66406: CALL 74680 0 3
66410: ST_TO_ADDR
// exit ;
66411: POP
66412: POP
66413: POP
66414: POP
66415: GO 66425
// end ;
66417: GO 66324
66419: POP
66420: POP
// end ;
66421: GO 66132
66423: POP
66424: POP
// end ;
66425: LD_VAR 0 6
66429: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66430: LD_INT 0
66432: PPUSH
66433: PPUSH
66434: PPUSH
66435: PPUSH
// if not mc_bases or not skirmish then
66436: LD_EXP 102
66440: NOT
66441: PUSH
66442: LD_EXP 100
66446: NOT
66447: OR
66448: IFFALSE 66452
// exit ;
66450: GO 66729
// side := GetSide ( lab ) ;
66452: LD_ADDR_VAR 0 4
66456: PUSH
66457: LD_VAR 0 2
66461: PPUSH
66462: CALL_OW 255
66466: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66467: LD_VAR 0 4
66471: PUSH
66472: LD_EXP 128
66476: IN
66477: NOT
66478: PUSH
66479: LD_EXP 129
66483: NOT
66484: OR
66485: PUSH
66486: LD_EXP 102
66490: NOT
66491: OR
66492: IFFALSE 66496
// exit ;
66494: GO 66729
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66496: LD_ADDR_EXP 129
66500: PUSH
66501: LD_EXP 129
66505: PPUSH
66506: LD_VAR 0 4
66510: PPUSH
66511: LD_EXP 129
66515: PUSH
66516: LD_VAR 0 4
66520: ARRAY
66521: PUSH
66522: LD_VAR 0 1
66526: DIFF
66527: PPUSH
66528: CALL_OW 1
66532: ST_TO_ADDR
// for i = 1 to mc_bases do
66533: LD_ADDR_VAR 0 5
66537: PUSH
66538: DOUBLE
66539: LD_INT 1
66541: DEC
66542: ST_TO_ADDR
66543: LD_EXP 102
66547: PUSH
66548: FOR_TO
66549: IFFALSE 66727
// begin if lab in mc_bases [ i ] then
66551: LD_VAR 0 2
66555: PUSH
66556: LD_EXP 102
66560: PUSH
66561: LD_VAR 0 5
66565: ARRAY
66566: IN
66567: IFFALSE 66725
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66569: LD_VAR 0 1
66573: PUSH
66574: LD_INT 11
66576: PUSH
66577: LD_INT 4
66579: PUSH
66580: LD_INT 3
66582: PUSH
66583: LD_INT 2
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: IN
66592: PUSH
66593: LD_EXP 132
66597: PUSH
66598: LD_VAR 0 5
66602: ARRAY
66603: AND
66604: IFFALSE 66725
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66606: LD_ADDR_VAR 0 6
66610: PUSH
66611: LD_EXP 132
66615: PUSH
66616: LD_VAR 0 5
66620: ARRAY
66621: PUSH
66622: LD_INT 1
66624: ARRAY
66625: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66626: LD_ADDR_EXP 132
66630: PUSH
66631: LD_EXP 132
66635: PPUSH
66636: LD_VAR 0 5
66640: PPUSH
66641: EMPTY
66642: PPUSH
66643: CALL_OW 1
66647: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66648: LD_VAR 0 6
66652: PPUSH
66653: LD_INT 0
66655: PPUSH
66656: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66660: LD_VAR 0 6
66664: PPUSH
66665: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66669: LD_ADDR_EXP 131
66673: PUSH
66674: LD_EXP 131
66678: PPUSH
66679: LD_VAR 0 5
66683: PPUSH
66684: LD_EXP 131
66688: PUSH
66689: LD_VAR 0 5
66693: ARRAY
66694: PPUSH
66695: LD_INT 1
66697: PPUSH
66698: LD_VAR 0 6
66702: PPUSH
66703: CALL_OW 2
66707: PPUSH
66708: CALL_OW 1
66712: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66713: LD_VAR 0 5
66717: PPUSH
66718: LD_INT 112
66720: PPUSH
66721: CALL 43179 0 2
// end ; end ; end ;
66725: GO 66548
66727: POP
66728: POP
// end ;
66729: LD_VAR 0 3
66733: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66734: LD_INT 0
66736: PPUSH
66737: PPUSH
66738: PPUSH
66739: PPUSH
66740: PPUSH
66741: PPUSH
66742: PPUSH
66743: PPUSH
// if not mc_bases or not skirmish then
66744: LD_EXP 102
66748: NOT
66749: PUSH
66750: LD_EXP 100
66754: NOT
66755: OR
66756: IFFALSE 66760
// exit ;
66758: GO 68129
// for i = 1 to mc_bases do
66760: LD_ADDR_VAR 0 3
66764: PUSH
66765: DOUBLE
66766: LD_INT 1
66768: DEC
66769: ST_TO_ADDR
66770: LD_EXP 102
66774: PUSH
66775: FOR_TO
66776: IFFALSE 68127
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66778: LD_VAR 0 1
66782: PUSH
66783: LD_EXP 102
66787: PUSH
66788: LD_VAR 0 3
66792: ARRAY
66793: IN
66794: PUSH
66795: LD_VAR 0 1
66799: PUSH
66800: LD_EXP 109
66804: PUSH
66805: LD_VAR 0 3
66809: ARRAY
66810: IN
66811: OR
66812: PUSH
66813: LD_VAR 0 1
66817: PUSH
66818: LD_EXP 124
66822: PUSH
66823: LD_VAR 0 3
66827: ARRAY
66828: IN
66829: OR
66830: PUSH
66831: LD_VAR 0 1
66835: PUSH
66836: LD_EXP 121
66840: PUSH
66841: LD_VAR 0 3
66845: ARRAY
66846: IN
66847: OR
66848: PUSH
66849: LD_VAR 0 1
66853: PUSH
66854: LD_EXP 131
66858: PUSH
66859: LD_VAR 0 3
66863: ARRAY
66864: IN
66865: OR
66866: PUSH
66867: LD_VAR 0 1
66871: PUSH
66872: LD_EXP 132
66876: PUSH
66877: LD_VAR 0 3
66881: ARRAY
66882: IN
66883: OR
66884: IFFALSE 68125
// begin if un in mc_ape [ i ] then
66886: LD_VAR 0 1
66890: PUSH
66891: LD_EXP 131
66895: PUSH
66896: LD_VAR 0 3
66900: ARRAY
66901: IN
66902: IFFALSE 66941
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66904: LD_ADDR_EXP 131
66908: PUSH
66909: LD_EXP 131
66913: PPUSH
66914: LD_VAR 0 3
66918: PPUSH
66919: LD_EXP 131
66923: PUSH
66924: LD_VAR 0 3
66928: ARRAY
66929: PUSH
66930: LD_VAR 0 1
66934: DIFF
66935: PPUSH
66936: CALL_OW 1
66940: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66941: LD_VAR 0 1
66945: PUSH
66946: LD_EXP 132
66950: PUSH
66951: LD_VAR 0 3
66955: ARRAY
66956: IN
66957: IFFALSE 66981
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66959: LD_ADDR_EXP 132
66963: PUSH
66964: LD_EXP 132
66968: PPUSH
66969: LD_VAR 0 3
66973: PPUSH
66974: EMPTY
66975: PPUSH
66976: CALL_OW 1
66980: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66981: LD_VAR 0 1
66985: PPUSH
66986: CALL_OW 247
66990: PUSH
66991: LD_INT 2
66993: EQUAL
66994: PUSH
66995: LD_VAR 0 1
66999: PPUSH
67000: CALL_OW 110
67004: PUSH
67005: LD_INT 20
67007: EQUAL
67008: PUSH
67009: LD_VAR 0 1
67013: PUSH
67014: LD_EXP 124
67018: PUSH
67019: LD_VAR 0 3
67023: ARRAY
67024: IN
67025: OR
67026: PUSH
67027: LD_VAR 0 1
67031: PPUSH
67032: CALL_OW 264
67036: PUSH
67037: LD_INT 12
67039: PUSH
67040: LD_INT 51
67042: PUSH
67043: LD_INT 89
67045: PUSH
67046: LD_INT 32
67048: PUSH
67049: LD_INT 13
67051: PUSH
67052: LD_INT 52
67054: PUSH
67055: LD_INT 31
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: IN
67067: OR
67068: AND
67069: IFFALSE 67377
// begin if un in mc_defender [ i ] then
67071: LD_VAR 0 1
67075: PUSH
67076: LD_EXP 124
67080: PUSH
67081: LD_VAR 0 3
67085: ARRAY
67086: IN
67087: IFFALSE 67126
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67089: LD_ADDR_EXP 124
67093: PUSH
67094: LD_EXP 124
67098: PPUSH
67099: LD_VAR 0 3
67103: PPUSH
67104: LD_EXP 124
67108: PUSH
67109: LD_VAR 0 3
67113: ARRAY
67114: PUSH
67115: LD_VAR 0 1
67119: DIFF
67120: PPUSH
67121: CALL_OW 1
67125: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67126: LD_ADDR_VAR 0 8
67130: PUSH
67131: LD_VAR 0 3
67135: PPUSH
67136: LD_INT 3
67138: PPUSH
67139: CALL 63747 0 2
67143: ST_TO_ADDR
// if fac then
67144: LD_VAR 0 8
67148: IFFALSE 67377
// begin for j in fac do
67150: LD_ADDR_VAR 0 4
67154: PUSH
67155: LD_VAR 0 8
67159: PUSH
67160: FOR_IN
67161: IFFALSE 67375
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67163: LD_ADDR_VAR 0 9
67167: PUSH
67168: LD_VAR 0 8
67172: PPUSH
67173: LD_VAR 0 1
67177: PPUSH
67178: CALL_OW 265
67182: PPUSH
67183: LD_VAR 0 1
67187: PPUSH
67188: CALL_OW 262
67192: PPUSH
67193: LD_VAR 0 1
67197: PPUSH
67198: CALL_OW 263
67202: PPUSH
67203: LD_VAR 0 1
67207: PPUSH
67208: CALL_OW 264
67212: PPUSH
67213: CALL 72178 0 5
67217: ST_TO_ADDR
// if components then
67218: LD_VAR 0 9
67222: IFFALSE 67373
// begin if GetWeapon ( un ) = ar_control_tower then
67224: LD_VAR 0 1
67228: PPUSH
67229: CALL_OW 264
67233: PUSH
67234: LD_INT 31
67236: EQUAL
67237: IFFALSE 67354
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67239: LD_VAR 0 1
67243: PPUSH
67244: CALL_OW 311
67248: PPUSH
67249: LD_INT 0
67251: PPUSH
67252: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67256: LD_ADDR_EXP 142
67260: PUSH
67261: LD_EXP 142
67265: PPUSH
67266: LD_VAR 0 3
67270: PPUSH
67271: LD_EXP 142
67275: PUSH
67276: LD_VAR 0 3
67280: ARRAY
67281: PUSH
67282: LD_VAR 0 1
67286: PPUSH
67287: CALL_OW 311
67291: DIFF
67292: PPUSH
67293: CALL_OW 1
67297: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67298: LD_ADDR_VAR 0 7
67302: PUSH
67303: LD_EXP 123
67307: PUSH
67308: LD_VAR 0 3
67312: ARRAY
67313: PPUSH
67314: LD_INT 1
67316: PPUSH
67317: LD_VAR 0 9
67321: PPUSH
67322: CALL_OW 2
67326: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67327: LD_ADDR_EXP 123
67331: PUSH
67332: LD_EXP 123
67336: PPUSH
67337: LD_VAR 0 3
67341: PPUSH
67342: LD_VAR 0 7
67346: PPUSH
67347: CALL_OW 1
67351: ST_TO_ADDR
// end else
67352: GO 67371
// MC_InsertProduceList ( i , [ components ] ) ;
67354: LD_VAR 0 3
67358: PPUSH
67359: LD_VAR 0 9
67363: PUSH
67364: EMPTY
67365: LIST
67366: PPUSH
67367: CALL 63292 0 2
// break ;
67371: GO 67375
// end ; end ;
67373: GO 67160
67375: POP
67376: POP
// end ; end ; if GetType ( un ) = unit_building then
67377: LD_VAR 0 1
67381: PPUSH
67382: CALL_OW 247
67386: PUSH
67387: LD_INT 3
67389: EQUAL
67390: IFFALSE 67793
// begin btype := GetBType ( un ) ;
67392: LD_ADDR_VAR 0 5
67396: PUSH
67397: LD_VAR 0 1
67401: PPUSH
67402: CALL_OW 266
67406: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67407: LD_VAR 0 5
67411: PUSH
67412: LD_INT 29
67414: PUSH
67415: LD_INT 30
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: IN
67422: IFFALSE 67495
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67424: LD_VAR 0 1
67428: PPUSH
67429: CALL_OW 250
67433: PPUSH
67434: LD_VAR 0 1
67438: PPUSH
67439: CALL_OW 251
67443: PPUSH
67444: LD_VAR 0 1
67448: PPUSH
67449: CALL_OW 255
67453: PPUSH
67454: CALL_OW 440
67458: NOT
67459: IFFALSE 67495
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67461: LD_VAR 0 1
67465: PPUSH
67466: CALL_OW 250
67470: PPUSH
67471: LD_VAR 0 1
67475: PPUSH
67476: CALL_OW 251
67480: PPUSH
67481: LD_VAR 0 1
67485: PPUSH
67486: CALL_OW 255
67490: PPUSH
67491: CALL_OW 441
// end ; if btype = b_warehouse then
67495: LD_VAR 0 5
67499: PUSH
67500: LD_INT 1
67502: EQUAL
67503: IFFALSE 67521
// begin btype := b_depot ;
67505: LD_ADDR_VAR 0 5
67509: PUSH
67510: LD_INT 0
67512: ST_TO_ADDR
// pos := 1 ;
67513: LD_ADDR_VAR 0 6
67517: PUSH
67518: LD_INT 1
67520: ST_TO_ADDR
// end ; if btype = b_factory then
67521: LD_VAR 0 5
67525: PUSH
67526: LD_INT 3
67528: EQUAL
67529: IFFALSE 67547
// begin btype := b_workshop ;
67531: LD_ADDR_VAR 0 5
67535: PUSH
67536: LD_INT 2
67538: ST_TO_ADDR
// pos := 1 ;
67539: LD_ADDR_VAR 0 6
67543: PUSH
67544: LD_INT 1
67546: ST_TO_ADDR
// end ; if btype = b_barracks then
67547: LD_VAR 0 5
67551: PUSH
67552: LD_INT 5
67554: EQUAL
67555: IFFALSE 67565
// btype := b_armoury ;
67557: LD_ADDR_VAR 0 5
67561: PUSH
67562: LD_INT 4
67564: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67565: LD_VAR 0 5
67569: PUSH
67570: LD_INT 7
67572: PUSH
67573: LD_INT 8
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: IN
67580: IFFALSE 67590
// btype := b_lab ;
67582: LD_ADDR_VAR 0 5
67586: PUSH
67587: LD_INT 6
67589: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67590: LD_ADDR_EXP 107
67594: PUSH
67595: LD_EXP 107
67599: PPUSH
67600: LD_VAR 0 3
67604: PUSH
67605: LD_EXP 107
67609: PUSH
67610: LD_VAR 0 3
67614: ARRAY
67615: PUSH
67616: LD_INT 1
67618: PLUS
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PPUSH
67624: LD_VAR 0 5
67628: PUSH
67629: LD_VAR 0 1
67633: PPUSH
67634: CALL_OW 250
67638: PUSH
67639: LD_VAR 0 1
67643: PPUSH
67644: CALL_OW 251
67648: PUSH
67649: LD_VAR 0 1
67653: PPUSH
67654: CALL_OW 254
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: PPUSH
67665: CALL 74680 0 3
67669: ST_TO_ADDR
// if pos = 1 then
67670: LD_VAR 0 6
67674: PUSH
67675: LD_INT 1
67677: EQUAL
67678: IFFALSE 67793
// begin tmp := mc_build_list [ i ] ;
67680: LD_ADDR_VAR 0 7
67684: PUSH
67685: LD_EXP 107
67689: PUSH
67690: LD_VAR 0 3
67694: ARRAY
67695: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67696: LD_VAR 0 7
67700: PPUSH
67701: LD_INT 2
67703: PUSH
67704: LD_INT 30
67706: PUSH
67707: LD_INT 0
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 30
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: LIST
67728: PPUSH
67729: CALL_OW 72
67733: IFFALSE 67743
// pos := 2 ;
67735: LD_ADDR_VAR 0 6
67739: PUSH
67740: LD_INT 2
67742: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67743: LD_ADDR_VAR 0 7
67747: PUSH
67748: LD_VAR 0 7
67752: PPUSH
67753: LD_VAR 0 6
67757: PPUSH
67758: LD_VAR 0 7
67762: PPUSH
67763: CALL 75006 0 3
67767: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67768: LD_ADDR_EXP 107
67772: PUSH
67773: LD_EXP 107
67777: PPUSH
67778: LD_VAR 0 3
67782: PPUSH
67783: LD_VAR 0 7
67787: PPUSH
67788: CALL_OW 1
67792: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67793: LD_VAR 0 1
67797: PUSH
67798: LD_EXP 102
67802: PUSH
67803: LD_VAR 0 3
67807: ARRAY
67808: IN
67809: IFFALSE 67848
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67811: LD_ADDR_EXP 102
67815: PUSH
67816: LD_EXP 102
67820: PPUSH
67821: LD_VAR 0 3
67825: PPUSH
67826: LD_EXP 102
67830: PUSH
67831: LD_VAR 0 3
67835: ARRAY
67836: PUSH
67837: LD_VAR 0 1
67841: DIFF
67842: PPUSH
67843: CALL_OW 1
67847: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67848: LD_VAR 0 1
67852: PUSH
67853: LD_EXP 109
67857: PUSH
67858: LD_VAR 0 3
67862: ARRAY
67863: IN
67864: IFFALSE 67903
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67866: LD_ADDR_EXP 109
67870: PUSH
67871: LD_EXP 109
67875: PPUSH
67876: LD_VAR 0 3
67880: PPUSH
67881: LD_EXP 109
67885: PUSH
67886: LD_VAR 0 3
67890: ARRAY
67891: PUSH
67892: LD_VAR 0 1
67896: DIFF
67897: PPUSH
67898: CALL_OW 1
67902: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67903: LD_VAR 0 1
67907: PUSH
67908: LD_EXP 121
67912: PUSH
67913: LD_VAR 0 3
67917: ARRAY
67918: IN
67919: IFFALSE 67958
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67921: LD_ADDR_EXP 121
67925: PUSH
67926: LD_EXP 121
67930: PPUSH
67931: LD_VAR 0 3
67935: PPUSH
67936: LD_EXP 121
67940: PUSH
67941: LD_VAR 0 3
67945: ARRAY
67946: PUSH
67947: LD_VAR 0 1
67951: DIFF
67952: PPUSH
67953: CALL_OW 1
67957: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67958: LD_VAR 0 1
67962: PUSH
67963: LD_EXP 124
67967: PUSH
67968: LD_VAR 0 3
67972: ARRAY
67973: IN
67974: IFFALSE 68013
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67976: LD_ADDR_EXP 124
67980: PUSH
67981: LD_EXP 124
67985: PPUSH
67986: LD_VAR 0 3
67990: PPUSH
67991: LD_EXP 124
67995: PUSH
67996: LD_VAR 0 3
68000: ARRAY
68001: PUSH
68002: LD_VAR 0 1
68006: DIFF
68007: PPUSH
68008: CALL_OW 1
68012: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68013: LD_VAR 0 1
68017: PUSH
68018: LD_EXP 111
68022: PUSH
68023: LD_VAR 0 3
68027: ARRAY
68028: IN
68029: IFFALSE 68068
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68031: LD_ADDR_EXP 111
68035: PUSH
68036: LD_EXP 111
68040: PPUSH
68041: LD_VAR 0 3
68045: PPUSH
68046: LD_EXP 111
68050: PUSH
68051: LD_VAR 0 3
68055: ARRAY
68056: PUSH
68057: LD_VAR 0 1
68061: DIFF
68062: PPUSH
68063: CALL_OW 1
68067: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68068: LD_VAR 0 1
68072: PUSH
68073: LD_EXP 110
68077: PUSH
68078: LD_VAR 0 3
68082: ARRAY
68083: IN
68084: IFFALSE 68123
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68086: LD_ADDR_EXP 110
68090: PUSH
68091: LD_EXP 110
68095: PPUSH
68096: LD_VAR 0 3
68100: PPUSH
68101: LD_EXP 110
68105: PUSH
68106: LD_VAR 0 3
68110: ARRAY
68111: PUSH
68112: LD_VAR 0 1
68116: DIFF
68117: PPUSH
68118: CALL_OW 1
68122: ST_TO_ADDR
// end ; break ;
68123: GO 68127
// end ;
68125: GO 66775
68127: POP
68128: POP
// end ;
68129: LD_VAR 0 2
68133: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68134: LD_INT 0
68136: PPUSH
68137: PPUSH
68138: PPUSH
// if not mc_bases or not skirmish then
68139: LD_EXP 102
68143: NOT
68144: PUSH
68145: LD_EXP 100
68149: NOT
68150: OR
68151: IFFALSE 68155
// exit ;
68153: GO 68370
// for i = 1 to mc_bases do
68155: LD_ADDR_VAR 0 3
68159: PUSH
68160: DOUBLE
68161: LD_INT 1
68163: DEC
68164: ST_TO_ADDR
68165: LD_EXP 102
68169: PUSH
68170: FOR_TO
68171: IFFALSE 68368
// begin if building in mc_construct_list [ i ] then
68173: LD_VAR 0 1
68177: PUSH
68178: LD_EXP 109
68182: PUSH
68183: LD_VAR 0 3
68187: ARRAY
68188: IN
68189: IFFALSE 68366
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68191: LD_ADDR_EXP 109
68195: PUSH
68196: LD_EXP 109
68200: PPUSH
68201: LD_VAR 0 3
68205: PPUSH
68206: LD_EXP 109
68210: PUSH
68211: LD_VAR 0 3
68215: ARRAY
68216: PUSH
68217: LD_VAR 0 1
68221: DIFF
68222: PPUSH
68223: CALL_OW 1
68227: ST_TO_ADDR
// if building in mc_lab [ i ] then
68228: LD_VAR 0 1
68232: PUSH
68233: LD_EXP 135
68237: PUSH
68238: LD_VAR 0 3
68242: ARRAY
68243: IN
68244: IFFALSE 68299
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68246: LD_ADDR_EXP 136
68250: PUSH
68251: LD_EXP 136
68255: PPUSH
68256: LD_VAR 0 3
68260: PPUSH
68261: LD_EXP 136
68265: PUSH
68266: LD_VAR 0 3
68270: ARRAY
68271: PPUSH
68272: LD_INT 1
68274: PPUSH
68275: LD_EXP 136
68279: PUSH
68280: LD_VAR 0 3
68284: ARRAY
68285: PPUSH
68286: LD_INT 0
68288: PPUSH
68289: CALL 74098 0 4
68293: PPUSH
68294: CALL_OW 1
68298: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68299: LD_VAR 0 1
68303: PUSH
68304: LD_EXP 102
68308: PUSH
68309: LD_VAR 0 3
68313: ARRAY
68314: IN
68315: NOT
68316: IFFALSE 68362
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68318: LD_ADDR_EXP 102
68322: PUSH
68323: LD_EXP 102
68327: PPUSH
68328: LD_VAR 0 3
68332: PUSH
68333: LD_EXP 102
68337: PUSH
68338: LD_VAR 0 3
68342: ARRAY
68343: PUSH
68344: LD_INT 1
68346: PLUS
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PPUSH
68352: LD_VAR 0 1
68356: PPUSH
68357: CALL 74680 0 3
68361: ST_TO_ADDR
// exit ;
68362: POP
68363: POP
68364: GO 68370
// end ; end ;
68366: GO 68170
68368: POP
68369: POP
// end ;
68370: LD_VAR 0 2
68374: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68375: LD_INT 0
68377: PPUSH
68378: PPUSH
68379: PPUSH
68380: PPUSH
68381: PPUSH
68382: PPUSH
68383: PPUSH
// if not mc_bases or not skirmish then
68384: LD_EXP 102
68388: NOT
68389: PUSH
68390: LD_EXP 100
68394: NOT
68395: OR
68396: IFFALSE 68400
// exit ;
68398: GO 69061
// for i = 1 to mc_bases do
68400: LD_ADDR_VAR 0 3
68404: PUSH
68405: DOUBLE
68406: LD_INT 1
68408: DEC
68409: ST_TO_ADDR
68410: LD_EXP 102
68414: PUSH
68415: FOR_TO
68416: IFFALSE 69059
// begin if building in mc_construct_list [ i ] then
68418: LD_VAR 0 1
68422: PUSH
68423: LD_EXP 109
68427: PUSH
68428: LD_VAR 0 3
68432: ARRAY
68433: IN
68434: IFFALSE 69057
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68436: LD_ADDR_EXP 109
68440: PUSH
68441: LD_EXP 109
68445: PPUSH
68446: LD_VAR 0 3
68450: PPUSH
68451: LD_EXP 109
68455: PUSH
68456: LD_VAR 0 3
68460: ARRAY
68461: PUSH
68462: LD_VAR 0 1
68466: DIFF
68467: PPUSH
68468: CALL_OW 1
68472: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68473: LD_ADDR_EXP 102
68477: PUSH
68478: LD_EXP 102
68482: PPUSH
68483: LD_VAR 0 3
68487: PUSH
68488: LD_EXP 102
68492: PUSH
68493: LD_VAR 0 3
68497: ARRAY
68498: PUSH
68499: LD_INT 1
68501: PLUS
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PPUSH
68507: LD_VAR 0 1
68511: PPUSH
68512: CALL 74680 0 3
68516: ST_TO_ADDR
// btype := GetBType ( building ) ;
68517: LD_ADDR_VAR 0 5
68521: PUSH
68522: LD_VAR 0 1
68526: PPUSH
68527: CALL_OW 266
68531: ST_TO_ADDR
// side := GetSide ( building ) ;
68532: LD_ADDR_VAR 0 8
68536: PUSH
68537: LD_VAR 0 1
68541: PPUSH
68542: CALL_OW 255
68546: ST_TO_ADDR
// if btype = b_lab then
68547: LD_VAR 0 5
68551: PUSH
68552: LD_INT 6
68554: EQUAL
68555: IFFALSE 68605
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68557: LD_ADDR_EXP 135
68561: PUSH
68562: LD_EXP 135
68566: PPUSH
68567: LD_VAR 0 3
68571: PUSH
68572: LD_EXP 135
68576: PUSH
68577: LD_VAR 0 3
68581: ARRAY
68582: PUSH
68583: LD_INT 1
68585: PLUS
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PPUSH
68591: LD_VAR 0 1
68595: PPUSH
68596: CALL 74680 0 3
68600: ST_TO_ADDR
// exit ;
68601: POP
68602: POP
68603: GO 69061
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68605: LD_VAR 0 5
68609: PUSH
68610: LD_INT 0
68612: PUSH
68613: LD_INT 2
68615: PUSH
68616: LD_INT 4
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: LIST
68623: IN
68624: IFFALSE 68748
// begin if btype = b_armoury then
68626: LD_VAR 0 5
68630: PUSH
68631: LD_INT 4
68633: EQUAL
68634: IFFALSE 68644
// btype := b_barracks ;
68636: LD_ADDR_VAR 0 5
68640: PUSH
68641: LD_INT 5
68643: ST_TO_ADDR
// if btype = b_depot then
68644: LD_VAR 0 5
68648: PUSH
68649: LD_INT 0
68651: EQUAL
68652: IFFALSE 68662
// btype := b_warehouse ;
68654: LD_ADDR_VAR 0 5
68658: PUSH
68659: LD_INT 1
68661: ST_TO_ADDR
// if btype = b_workshop then
68662: LD_VAR 0 5
68666: PUSH
68667: LD_INT 2
68669: EQUAL
68670: IFFALSE 68680
// btype := b_factory ;
68672: LD_ADDR_VAR 0 5
68676: PUSH
68677: LD_INT 3
68679: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68680: LD_VAR 0 5
68684: PPUSH
68685: LD_VAR 0 8
68689: PPUSH
68690: CALL_OW 323
68694: PUSH
68695: LD_INT 1
68697: EQUAL
68698: IFFALSE 68744
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68700: LD_ADDR_EXP 134
68704: PUSH
68705: LD_EXP 134
68709: PPUSH
68710: LD_VAR 0 3
68714: PUSH
68715: LD_EXP 134
68719: PUSH
68720: LD_VAR 0 3
68724: ARRAY
68725: PUSH
68726: LD_INT 1
68728: PLUS
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PPUSH
68734: LD_VAR 0 1
68738: PPUSH
68739: CALL 74680 0 3
68743: ST_TO_ADDR
// exit ;
68744: POP
68745: POP
68746: GO 69061
// end ; if btype in [ b_bunker , b_turret ] then
68748: LD_VAR 0 5
68752: PUSH
68753: LD_INT 32
68755: PUSH
68756: LD_INT 33
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: IN
68763: IFFALSE 69053
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68765: LD_ADDR_EXP 110
68769: PUSH
68770: LD_EXP 110
68774: PPUSH
68775: LD_VAR 0 3
68779: PUSH
68780: LD_EXP 110
68784: PUSH
68785: LD_VAR 0 3
68789: ARRAY
68790: PUSH
68791: LD_INT 1
68793: PLUS
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PPUSH
68799: LD_VAR 0 1
68803: PPUSH
68804: CALL 74680 0 3
68808: ST_TO_ADDR
// if btype = b_bunker then
68809: LD_VAR 0 5
68813: PUSH
68814: LD_INT 32
68816: EQUAL
68817: IFFALSE 69053
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68819: LD_ADDR_EXP 111
68823: PUSH
68824: LD_EXP 111
68828: PPUSH
68829: LD_VAR 0 3
68833: PUSH
68834: LD_EXP 111
68838: PUSH
68839: LD_VAR 0 3
68843: ARRAY
68844: PUSH
68845: LD_INT 1
68847: PLUS
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PPUSH
68853: LD_VAR 0 1
68857: PPUSH
68858: CALL 74680 0 3
68862: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68863: LD_ADDR_VAR 0 6
68867: PUSH
68868: LD_EXP 102
68872: PUSH
68873: LD_VAR 0 3
68877: ARRAY
68878: PPUSH
68879: LD_INT 25
68881: PUSH
68882: LD_INT 1
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 3
68891: PUSH
68892: LD_INT 54
68894: PUSH
68895: EMPTY
68896: LIST
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PPUSH
68906: CALL_OW 72
68910: ST_TO_ADDR
// if tmp then
68911: LD_VAR 0 6
68915: IFFALSE 68921
// exit ;
68917: POP
68918: POP
68919: GO 69061
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68921: LD_ADDR_VAR 0 6
68925: PUSH
68926: LD_EXP 102
68930: PUSH
68931: LD_VAR 0 3
68935: ARRAY
68936: PPUSH
68937: LD_INT 2
68939: PUSH
68940: LD_INT 30
68942: PUSH
68943: LD_INT 4
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 30
68952: PUSH
68953: LD_INT 5
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: LIST
68964: PPUSH
68965: CALL_OW 72
68969: ST_TO_ADDR
// if not tmp then
68970: LD_VAR 0 6
68974: NOT
68975: IFFALSE 68981
// exit ;
68977: POP
68978: POP
68979: GO 69061
// for j in tmp do
68981: LD_ADDR_VAR 0 4
68985: PUSH
68986: LD_VAR 0 6
68990: PUSH
68991: FOR_IN
68992: IFFALSE 69051
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68994: LD_ADDR_VAR 0 7
68998: PUSH
68999: LD_VAR 0 4
69003: PPUSH
69004: CALL_OW 313
69008: PPUSH
69009: LD_INT 25
69011: PUSH
69012: LD_INT 1
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PPUSH
69019: CALL_OW 72
69023: ST_TO_ADDR
// if units then
69024: LD_VAR 0 7
69028: IFFALSE 69049
// begin ComExitBuilding ( units [ 1 ] ) ;
69030: LD_VAR 0 7
69034: PUSH
69035: LD_INT 1
69037: ARRAY
69038: PPUSH
69039: CALL_OW 122
// exit ;
69043: POP
69044: POP
69045: POP
69046: POP
69047: GO 69061
// end ; end ;
69049: GO 68991
69051: POP
69052: POP
// end ; end ; exit ;
69053: POP
69054: POP
69055: GO 69061
// end ; end ;
69057: GO 68415
69059: POP
69060: POP
// end ;
69061: LD_VAR 0 2
69065: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69066: LD_INT 0
69068: PPUSH
69069: PPUSH
69070: PPUSH
69071: PPUSH
69072: PPUSH
69073: PPUSH
69074: PPUSH
// if not mc_bases or not skirmish then
69075: LD_EXP 102
69079: NOT
69080: PUSH
69081: LD_EXP 100
69085: NOT
69086: OR
69087: IFFALSE 69091
// exit ;
69089: GO 69356
// btype := GetBType ( building ) ;
69091: LD_ADDR_VAR 0 6
69095: PUSH
69096: LD_VAR 0 1
69100: PPUSH
69101: CALL_OW 266
69105: ST_TO_ADDR
// x := GetX ( building ) ;
69106: LD_ADDR_VAR 0 7
69110: PUSH
69111: LD_VAR 0 1
69115: PPUSH
69116: CALL_OW 250
69120: ST_TO_ADDR
// y := GetY ( building ) ;
69121: LD_ADDR_VAR 0 8
69125: PUSH
69126: LD_VAR 0 1
69130: PPUSH
69131: CALL_OW 251
69135: ST_TO_ADDR
// d := GetDir ( building ) ;
69136: LD_ADDR_VAR 0 9
69140: PUSH
69141: LD_VAR 0 1
69145: PPUSH
69146: CALL_OW 254
69150: ST_TO_ADDR
// for i = 1 to mc_bases do
69151: LD_ADDR_VAR 0 4
69155: PUSH
69156: DOUBLE
69157: LD_INT 1
69159: DEC
69160: ST_TO_ADDR
69161: LD_EXP 102
69165: PUSH
69166: FOR_TO
69167: IFFALSE 69354
// begin if not mc_build_list [ i ] then
69169: LD_EXP 107
69173: PUSH
69174: LD_VAR 0 4
69178: ARRAY
69179: NOT
69180: IFFALSE 69184
// continue ;
69182: GO 69166
// for j := 1 to mc_build_list [ i ] do
69184: LD_ADDR_VAR 0 5
69188: PUSH
69189: DOUBLE
69190: LD_INT 1
69192: DEC
69193: ST_TO_ADDR
69194: LD_EXP 107
69198: PUSH
69199: LD_VAR 0 4
69203: ARRAY
69204: PUSH
69205: FOR_TO
69206: IFFALSE 69350
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69208: LD_VAR 0 6
69212: PUSH
69213: LD_VAR 0 7
69217: PUSH
69218: LD_VAR 0 8
69222: PUSH
69223: LD_VAR 0 9
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: PPUSH
69234: LD_EXP 107
69238: PUSH
69239: LD_VAR 0 4
69243: ARRAY
69244: PUSH
69245: LD_VAR 0 5
69249: ARRAY
69250: PPUSH
69251: CALL 81237 0 2
69255: IFFALSE 69348
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69257: LD_ADDR_EXP 107
69261: PUSH
69262: LD_EXP 107
69266: PPUSH
69267: LD_VAR 0 4
69271: PPUSH
69272: LD_EXP 107
69276: PUSH
69277: LD_VAR 0 4
69281: ARRAY
69282: PPUSH
69283: LD_VAR 0 5
69287: PPUSH
69288: CALL_OW 3
69292: PPUSH
69293: CALL_OW 1
69297: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69298: LD_ADDR_EXP 109
69302: PUSH
69303: LD_EXP 109
69307: PPUSH
69308: LD_VAR 0 4
69312: PUSH
69313: LD_EXP 109
69317: PUSH
69318: LD_VAR 0 4
69322: ARRAY
69323: PUSH
69324: LD_INT 1
69326: PLUS
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PPUSH
69332: LD_VAR 0 1
69336: PPUSH
69337: CALL 74680 0 3
69341: ST_TO_ADDR
// exit ;
69342: POP
69343: POP
69344: POP
69345: POP
69346: GO 69356
// end ;
69348: GO 69205
69350: POP
69351: POP
// end ;
69352: GO 69166
69354: POP
69355: POP
// end ;
69356: LD_VAR 0 3
69360: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69361: LD_INT 0
69363: PPUSH
69364: PPUSH
69365: PPUSH
// if not mc_bases or not skirmish then
69366: LD_EXP 102
69370: NOT
69371: PUSH
69372: LD_EXP 100
69376: NOT
69377: OR
69378: IFFALSE 69382
// exit ;
69380: GO 69572
// for i = 1 to mc_bases do
69382: LD_ADDR_VAR 0 4
69386: PUSH
69387: DOUBLE
69388: LD_INT 1
69390: DEC
69391: ST_TO_ADDR
69392: LD_EXP 102
69396: PUSH
69397: FOR_TO
69398: IFFALSE 69485
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69400: LD_VAR 0 1
69404: PUSH
69405: LD_EXP 110
69409: PUSH
69410: LD_VAR 0 4
69414: ARRAY
69415: IN
69416: PUSH
69417: LD_VAR 0 1
69421: PUSH
69422: LD_EXP 111
69426: PUSH
69427: LD_VAR 0 4
69431: ARRAY
69432: IN
69433: NOT
69434: AND
69435: IFFALSE 69483
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69437: LD_ADDR_EXP 111
69441: PUSH
69442: LD_EXP 111
69446: PPUSH
69447: LD_VAR 0 4
69451: PUSH
69452: LD_EXP 111
69456: PUSH
69457: LD_VAR 0 4
69461: ARRAY
69462: PUSH
69463: LD_INT 1
69465: PLUS
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PPUSH
69471: LD_VAR 0 1
69475: PPUSH
69476: CALL 74680 0 3
69480: ST_TO_ADDR
// break ;
69481: GO 69485
// end ; end ;
69483: GO 69397
69485: POP
69486: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69487: LD_VAR 0 1
69491: PPUSH
69492: CALL_OW 257
69496: PUSH
69497: LD_EXP 128
69501: IN
69502: PUSH
69503: LD_VAR 0 1
69507: PPUSH
69508: CALL_OW 266
69512: PUSH
69513: LD_INT 5
69515: EQUAL
69516: AND
69517: PUSH
69518: LD_VAR 0 2
69522: PPUSH
69523: CALL_OW 110
69527: PUSH
69528: LD_INT 18
69530: NONEQUAL
69531: AND
69532: IFFALSE 69572
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69534: LD_VAR 0 2
69538: PPUSH
69539: CALL_OW 257
69543: PUSH
69544: LD_INT 5
69546: PUSH
69547: LD_INT 8
69549: PUSH
69550: LD_INT 9
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: LIST
69557: IN
69558: IFFALSE 69572
// SetClass ( unit , 1 ) ;
69560: LD_VAR 0 2
69564: PPUSH
69565: LD_INT 1
69567: PPUSH
69568: CALL_OW 336
// end ;
69572: LD_VAR 0 3
69576: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69577: LD_INT 0
69579: PPUSH
69580: PPUSH
// if not mc_bases or not skirmish then
69581: LD_EXP 102
69585: NOT
69586: PUSH
69587: LD_EXP 100
69591: NOT
69592: OR
69593: IFFALSE 69597
// exit ;
69595: GO 69713
// if GetLives ( abandoned_vehicle ) > 250 then
69597: LD_VAR 0 2
69601: PPUSH
69602: CALL_OW 256
69606: PUSH
69607: LD_INT 250
69609: GREATER
69610: IFFALSE 69614
// exit ;
69612: GO 69713
// for i = 1 to mc_bases do
69614: LD_ADDR_VAR 0 6
69618: PUSH
69619: DOUBLE
69620: LD_INT 1
69622: DEC
69623: ST_TO_ADDR
69624: LD_EXP 102
69628: PUSH
69629: FOR_TO
69630: IFFALSE 69711
// begin if driver in mc_bases [ i ] then
69632: LD_VAR 0 1
69636: PUSH
69637: LD_EXP 102
69641: PUSH
69642: LD_VAR 0 6
69646: ARRAY
69647: IN
69648: IFFALSE 69709
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69650: LD_VAR 0 1
69654: PPUSH
69655: LD_EXP 102
69659: PUSH
69660: LD_VAR 0 6
69664: ARRAY
69665: PPUSH
69666: LD_INT 2
69668: PUSH
69669: LD_INT 30
69671: PUSH
69672: LD_INT 0
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 30
69681: PUSH
69682: LD_INT 1
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: LIST
69693: PPUSH
69694: CALL_OW 72
69698: PUSH
69699: LD_INT 1
69701: ARRAY
69702: PPUSH
69703: CALL 108286 0 2
// break ;
69707: GO 69711
// end ; end ;
69709: GO 69629
69711: POP
69712: POP
// end ; end_of_file
69713: LD_VAR 0 5
69717: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69718: LD_INT 0
69720: PPUSH
69721: PPUSH
// if exist_mode then
69722: LD_VAR 0 2
69726: IFFALSE 69751
// unit := CreateCharacter ( prefix & ident ) else
69728: LD_ADDR_VAR 0 5
69732: PUSH
69733: LD_VAR 0 3
69737: PUSH
69738: LD_VAR 0 1
69742: STR
69743: PPUSH
69744: CALL_OW 34
69748: ST_TO_ADDR
69749: GO 69766
// unit := NewCharacter ( ident ) ;
69751: LD_ADDR_VAR 0 5
69755: PUSH
69756: LD_VAR 0 1
69760: PPUSH
69761: CALL_OW 25
69765: ST_TO_ADDR
// result := unit ;
69766: LD_ADDR_VAR 0 4
69770: PUSH
69771: LD_VAR 0 5
69775: ST_TO_ADDR
// end ;
69776: LD_VAR 0 4
69780: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69781: LD_INT 0
69783: PPUSH
69784: PPUSH
// if not side or not nation then
69785: LD_VAR 0 1
69789: NOT
69790: PUSH
69791: LD_VAR 0 2
69795: NOT
69796: OR
69797: IFFALSE 69801
// exit ;
69799: GO 70569
// case nation of nation_american :
69801: LD_VAR 0 2
69805: PUSH
69806: LD_INT 1
69808: DOUBLE
69809: EQUAL
69810: IFTRUE 69814
69812: GO 70028
69814: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69815: LD_ADDR_VAR 0 4
69819: PUSH
69820: LD_INT 35
69822: PUSH
69823: LD_INT 45
69825: PUSH
69826: LD_INT 46
69828: PUSH
69829: LD_INT 47
69831: PUSH
69832: LD_INT 82
69834: PUSH
69835: LD_INT 83
69837: PUSH
69838: LD_INT 84
69840: PUSH
69841: LD_INT 85
69843: PUSH
69844: LD_INT 86
69846: PUSH
69847: LD_INT 1
69849: PUSH
69850: LD_INT 2
69852: PUSH
69853: LD_INT 6
69855: PUSH
69856: LD_INT 15
69858: PUSH
69859: LD_INT 16
69861: PUSH
69862: LD_INT 7
69864: PUSH
69865: LD_INT 12
69867: PUSH
69868: LD_INT 13
69870: PUSH
69871: LD_INT 10
69873: PUSH
69874: LD_INT 14
69876: PUSH
69877: LD_INT 20
69879: PUSH
69880: LD_INT 21
69882: PUSH
69883: LD_INT 22
69885: PUSH
69886: LD_INT 25
69888: PUSH
69889: LD_INT 32
69891: PUSH
69892: LD_INT 27
69894: PUSH
69895: LD_INT 36
69897: PUSH
69898: LD_INT 69
69900: PUSH
69901: LD_INT 39
69903: PUSH
69904: LD_INT 34
69906: PUSH
69907: LD_INT 40
69909: PUSH
69910: LD_INT 48
69912: PUSH
69913: LD_INT 49
69915: PUSH
69916: LD_INT 50
69918: PUSH
69919: LD_INT 51
69921: PUSH
69922: LD_INT 52
69924: PUSH
69925: LD_INT 53
69927: PUSH
69928: LD_INT 54
69930: PUSH
69931: LD_INT 55
69933: PUSH
69934: LD_INT 56
69936: PUSH
69937: LD_INT 57
69939: PUSH
69940: LD_INT 58
69942: PUSH
69943: LD_INT 59
69945: PUSH
69946: LD_INT 60
69948: PUSH
69949: LD_INT 61
69951: PUSH
69952: LD_INT 62
69954: PUSH
69955: LD_INT 80
69957: PUSH
69958: LD_INT 82
69960: PUSH
69961: LD_INT 83
69963: PUSH
69964: LD_INT 84
69966: PUSH
69967: LD_INT 85
69969: PUSH
69970: LD_INT 86
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: ST_TO_ADDR
70026: GO 70493
70028: LD_INT 2
70030: DOUBLE
70031: EQUAL
70032: IFTRUE 70036
70034: GO 70262
70036: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70037: LD_ADDR_VAR 0 4
70041: PUSH
70042: LD_INT 35
70044: PUSH
70045: LD_INT 45
70047: PUSH
70048: LD_INT 46
70050: PUSH
70051: LD_INT 47
70053: PUSH
70054: LD_INT 82
70056: PUSH
70057: LD_INT 83
70059: PUSH
70060: LD_INT 84
70062: PUSH
70063: LD_INT 85
70065: PUSH
70066: LD_INT 87
70068: PUSH
70069: LD_INT 70
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: LD_INT 11
70077: PUSH
70078: LD_INT 3
70080: PUSH
70081: LD_INT 4
70083: PUSH
70084: LD_INT 5
70086: PUSH
70087: LD_INT 6
70089: PUSH
70090: LD_INT 15
70092: PUSH
70093: LD_INT 18
70095: PUSH
70096: LD_INT 7
70098: PUSH
70099: LD_INT 17
70101: PUSH
70102: LD_INT 8
70104: PUSH
70105: LD_INT 20
70107: PUSH
70108: LD_INT 21
70110: PUSH
70111: LD_INT 22
70113: PUSH
70114: LD_INT 72
70116: PUSH
70117: LD_INT 26
70119: PUSH
70120: LD_INT 69
70122: PUSH
70123: LD_INT 39
70125: PUSH
70126: LD_INT 40
70128: PUSH
70129: LD_INT 41
70131: PUSH
70132: LD_INT 42
70134: PUSH
70135: LD_INT 43
70137: PUSH
70138: LD_INT 48
70140: PUSH
70141: LD_INT 49
70143: PUSH
70144: LD_INT 50
70146: PUSH
70147: LD_INT 51
70149: PUSH
70150: LD_INT 52
70152: PUSH
70153: LD_INT 53
70155: PUSH
70156: LD_INT 54
70158: PUSH
70159: LD_INT 55
70161: PUSH
70162: LD_INT 56
70164: PUSH
70165: LD_INT 60
70167: PUSH
70168: LD_INT 61
70170: PUSH
70171: LD_INT 62
70173: PUSH
70174: LD_INT 66
70176: PUSH
70177: LD_INT 67
70179: PUSH
70180: LD_INT 68
70182: PUSH
70183: LD_INT 81
70185: PUSH
70186: LD_INT 82
70188: PUSH
70189: LD_INT 83
70191: PUSH
70192: LD_INT 84
70194: PUSH
70195: LD_INT 85
70197: PUSH
70198: LD_INT 87
70200: PUSH
70201: LD_INT 88
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: ST_TO_ADDR
70260: GO 70493
70262: LD_INT 3
70264: DOUBLE
70265: EQUAL
70266: IFTRUE 70270
70268: GO 70492
70270: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70271: LD_ADDR_VAR 0 4
70275: PUSH
70276: LD_INT 46
70278: PUSH
70279: LD_INT 47
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: LD_INT 2
70287: PUSH
70288: LD_INT 82
70290: PUSH
70291: LD_INT 83
70293: PUSH
70294: LD_INT 84
70296: PUSH
70297: LD_INT 85
70299: PUSH
70300: LD_INT 86
70302: PUSH
70303: LD_INT 11
70305: PUSH
70306: LD_INT 9
70308: PUSH
70309: LD_INT 20
70311: PUSH
70312: LD_INT 19
70314: PUSH
70315: LD_INT 21
70317: PUSH
70318: LD_INT 24
70320: PUSH
70321: LD_INT 22
70323: PUSH
70324: LD_INT 25
70326: PUSH
70327: LD_INT 28
70329: PUSH
70330: LD_INT 29
70332: PUSH
70333: LD_INT 30
70335: PUSH
70336: LD_INT 31
70338: PUSH
70339: LD_INT 37
70341: PUSH
70342: LD_INT 38
70344: PUSH
70345: LD_INT 32
70347: PUSH
70348: LD_INT 27
70350: PUSH
70351: LD_INT 33
70353: PUSH
70354: LD_INT 69
70356: PUSH
70357: LD_INT 39
70359: PUSH
70360: LD_INT 34
70362: PUSH
70363: LD_INT 40
70365: PUSH
70366: LD_INT 71
70368: PUSH
70369: LD_INT 23
70371: PUSH
70372: LD_INT 44
70374: PUSH
70375: LD_INT 48
70377: PUSH
70378: LD_INT 49
70380: PUSH
70381: LD_INT 50
70383: PUSH
70384: LD_INT 51
70386: PUSH
70387: LD_INT 52
70389: PUSH
70390: LD_INT 53
70392: PUSH
70393: LD_INT 54
70395: PUSH
70396: LD_INT 55
70398: PUSH
70399: LD_INT 56
70401: PUSH
70402: LD_INT 57
70404: PUSH
70405: LD_INT 58
70407: PUSH
70408: LD_INT 59
70410: PUSH
70411: LD_INT 63
70413: PUSH
70414: LD_INT 64
70416: PUSH
70417: LD_INT 65
70419: PUSH
70420: LD_INT 82
70422: PUSH
70423: LD_INT 83
70425: PUSH
70426: LD_INT 84
70428: PUSH
70429: LD_INT 85
70431: PUSH
70432: LD_INT 86
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: ST_TO_ADDR
70490: GO 70493
70492: POP
// if state > - 1 and state < 3 then
70493: LD_VAR 0 3
70497: PUSH
70498: LD_INT 1
70500: NEG
70501: GREATER
70502: PUSH
70503: LD_VAR 0 3
70507: PUSH
70508: LD_INT 3
70510: LESS
70511: AND
70512: IFFALSE 70569
// for i in result do
70514: LD_ADDR_VAR 0 5
70518: PUSH
70519: LD_VAR 0 4
70523: PUSH
70524: FOR_IN
70525: IFFALSE 70567
// if GetTech ( i , side ) <> state then
70527: LD_VAR 0 5
70531: PPUSH
70532: LD_VAR 0 1
70536: PPUSH
70537: CALL_OW 321
70541: PUSH
70542: LD_VAR 0 3
70546: NONEQUAL
70547: IFFALSE 70565
// result := result diff i ;
70549: LD_ADDR_VAR 0 4
70553: PUSH
70554: LD_VAR 0 4
70558: PUSH
70559: LD_VAR 0 5
70563: DIFF
70564: ST_TO_ADDR
70565: GO 70524
70567: POP
70568: POP
// end ;
70569: LD_VAR 0 4
70573: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70574: LD_INT 0
70576: PPUSH
70577: PPUSH
70578: PPUSH
// result := true ;
70579: LD_ADDR_VAR 0 3
70583: PUSH
70584: LD_INT 1
70586: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70587: LD_ADDR_VAR 0 5
70591: PUSH
70592: LD_VAR 0 2
70596: PPUSH
70597: CALL_OW 480
70601: ST_TO_ADDR
// if not tmp then
70602: LD_VAR 0 5
70606: NOT
70607: IFFALSE 70611
// exit ;
70609: GO 70660
// for i in tmp do
70611: LD_ADDR_VAR 0 4
70615: PUSH
70616: LD_VAR 0 5
70620: PUSH
70621: FOR_IN
70622: IFFALSE 70658
// if GetTech ( i , side ) <> state_researched then
70624: LD_VAR 0 4
70628: PPUSH
70629: LD_VAR 0 1
70633: PPUSH
70634: CALL_OW 321
70638: PUSH
70639: LD_INT 2
70641: NONEQUAL
70642: IFFALSE 70656
// begin result := false ;
70644: LD_ADDR_VAR 0 3
70648: PUSH
70649: LD_INT 0
70651: ST_TO_ADDR
// exit ;
70652: POP
70653: POP
70654: GO 70660
// end ;
70656: GO 70621
70658: POP
70659: POP
// end ;
70660: LD_VAR 0 3
70664: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70665: LD_INT 0
70667: PPUSH
70668: PPUSH
70669: PPUSH
70670: PPUSH
70671: PPUSH
70672: PPUSH
70673: PPUSH
70674: PPUSH
70675: PPUSH
70676: PPUSH
70677: PPUSH
70678: PPUSH
70679: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70680: LD_VAR 0 1
70684: NOT
70685: PUSH
70686: LD_VAR 0 1
70690: PPUSH
70691: CALL_OW 257
70695: PUSH
70696: LD_INT 9
70698: NONEQUAL
70699: OR
70700: IFFALSE 70704
// exit ;
70702: GO 71277
// side := GetSide ( unit ) ;
70704: LD_ADDR_VAR 0 9
70708: PUSH
70709: LD_VAR 0 1
70713: PPUSH
70714: CALL_OW 255
70718: ST_TO_ADDR
// tech_space := tech_spacanom ;
70719: LD_ADDR_VAR 0 12
70723: PUSH
70724: LD_INT 29
70726: ST_TO_ADDR
// tech_time := tech_taurad ;
70727: LD_ADDR_VAR 0 13
70731: PUSH
70732: LD_INT 28
70734: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70735: LD_ADDR_VAR 0 11
70739: PUSH
70740: LD_VAR 0 1
70744: PPUSH
70745: CALL_OW 310
70749: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70750: LD_VAR 0 11
70754: PPUSH
70755: CALL_OW 247
70759: PUSH
70760: LD_INT 2
70762: EQUAL
70763: IFFALSE 70767
// exit ;
70765: GO 71277
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70767: LD_ADDR_VAR 0 8
70771: PUSH
70772: LD_INT 81
70774: PUSH
70775: LD_VAR 0 9
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 3
70786: PUSH
70787: LD_INT 21
70789: PUSH
70790: LD_INT 3
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PPUSH
70805: CALL_OW 69
70809: ST_TO_ADDR
// if not tmp then
70810: LD_VAR 0 8
70814: NOT
70815: IFFALSE 70819
// exit ;
70817: GO 71277
// if in_unit then
70819: LD_VAR 0 11
70823: IFFALSE 70847
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70825: LD_ADDR_VAR 0 10
70829: PUSH
70830: LD_VAR 0 8
70834: PPUSH
70835: LD_VAR 0 11
70839: PPUSH
70840: CALL_OW 74
70844: ST_TO_ADDR
70845: GO 70867
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70847: LD_ADDR_VAR 0 10
70851: PUSH
70852: LD_VAR 0 8
70856: PPUSH
70857: LD_VAR 0 1
70861: PPUSH
70862: CALL_OW 74
70866: ST_TO_ADDR
// if not enemy then
70867: LD_VAR 0 10
70871: NOT
70872: IFFALSE 70876
// exit ;
70874: GO 71277
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70876: LD_VAR 0 11
70880: PUSH
70881: LD_VAR 0 11
70885: PPUSH
70886: LD_VAR 0 10
70890: PPUSH
70891: CALL_OW 296
70895: PUSH
70896: LD_INT 13
70898: GREATER
70899: AND
70900: PUSH
70901: LD_VAR 0 1
70905: PPUSH
70906: LD_VAR 0 10
70910: PPUSH
70911: CALL_OW 296
70915: PUSH
70916: LD_INT 12
70918: GREATER
70919: OR
70920: IFFALSE 70924
// exit ;
70922: GO 71277
// missile := [ 1 ] ;
70924: LD_ADDR_VAR 0 14
70928: PUSH
70929: LD_INT 1
70931: PUSH
70932: EMPTY
70933: LIST
70934: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70935: LD_VAR 0 9
70939: PPUSH
70940: LD_VAR 0 12
70944: PPUSH
70945: CALL_OW 325
70949: IFFALSE 70978
// missile := Replace ( missile , missile + 1 , 2 ) ;
70951: LD_ADDR_VAR 0 14
70955: PUSH
70956: LD_VAR 0 14
70960: PPUSH
70961: LD_VAR 0 14
70965: PUSH
70966: LD_INT 1
70968: PLUS
70969: PPUSH
70970: LD_INT 2
70972: PPUSH
70973: CALL_OW 1
70977: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70978: LD_VAR 0 9
70982: PPUSH
70983: LD_VAR 0 13
70987: PPUSH
70988: CALL_OW 325
70992: PUSH
70993: LD_VAR 0 10
70997: PPUSH
70998: CALL_OW 255
71002: PPUSH
71003: LD_VAR 0 13
71007: PPUSH
71008: CALL_OW 325
71012: NOT
71013: AND
71014: IFFALSE 71043
// missile := Replace ( missile , missile + 1 , 3 ) ;
71016: LD_ADDR_VAR 0 14
71020: PUSH
71021: LD_VAR 0 14
71025: PPUSH
71026: LD_VAR 0 14
71030: PUSH
71031: LD_INT 1
71033: PLUS
71034: PPUSH
71035: LD_INT 3
71037: PPUSH
71038: CALL_OW 1
71042: ST_TO_ADDR
// if missile < 2 then
71043: LD_VAR 0 14
71047: PUSH
71048: LD_INT 2
71050: LESS
71051: IFFALSE 71055
// exit ;
71053: GO 71277
// x := GetX ( enemy ) ;
71055: LD_ADDR_VAR 0 4
71059: PUSH
71060: LD_VAR 0 10
71064: PPUSH
71065: CALL_OW 250
71069: ST_TO_ADDR
// y := GetY ( enemy ) ;
71070: LD_ADDR_VAR 0 5
71074: PUSH
71075: LD_VAR 0 10
71079: PPUSH
71080: CALL_OW 251
71084: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71085: LD_ADDR_VAR 0 6
71089: PUSH
71090: LD_VAR 0 4
71094: PUSH
71095: LD_INT 1
71097: NEG
71098: PPUSH
71099: LD_INT 1
71101: PPUSH
71102: CALL_OW 12
71106: PLUS
71107: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71108: LD_ADDR_VAR 0 7
71112: PUSH
71113: LD_VAR 0 5
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PPUSH
71122: LD_INT 1
71124: PPUSH
71125: CALL_OW 12
71129: PLUS
71130: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71131: LD_VAR 0 6
71135: PPUSH
71136: LD_VAR 0 7
71140: PPUSH
71141: CALL_OW 488
71145: NOT
71146: IFFALSE 71168
// begin _x := x ;
71148: LD_ADDR_VAR 0 6
71152: PUSH
71153: LD_VAR 0 4
71157: ST_TO_ADDR
// _y := y ;
71158: LD_ADDR_VAR 0 7
71162: PUSH
71163: LD_VAR 0 5
71167: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71168: LD_ADDR_VAR 0 3
71172: PUSH
71173: LD_INT 1
71175: PPUSH
71176: LD_VAR 0 14
71180: PPUSH
71181: CALL_OW 12
71185: ST_TO_ADDR
// case i of 1 :
71186: LD_VAR 0 3
71190: PUSH
71191: LD_INT 1
71193: DOUBLE
71194: EQUAL
71195: IFTRUE 71199
71197: GO 71216
71199: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71200: LD_VAR 0 1
71204: PPUSH
71205: LD_VAR 0 10
71209: PPUSH
71210: CALL_OW 115
71214: GO 71277
71216: LD_INT 2
71218: DOUBLE
71219: EQUAL
71220: IFTRUE 71224
71222: GO 71246
71224: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71225: LD_VAR 0 1
71229: PPUSH
71230: LD_VAR 0 6
71234: PPUSH
71235: LD_VAR 0 7
71239: PPUSH
71240: CALL_OW 153
71244: GO 71277
71246: LD_INT 3
71248: DOUBLE
71249: EQUAL
71250: IFTRUE 71254
71252: GO 71276
71254: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71255: LD_VAR 0 1
71259: PPUSH
71260: LD_VAR 0 6
71264: PPUSH
71265: LD_VAR 0 7
71269: PPUSH
71270: CALL_OW 154
71274: GO 71277
71276: POP
// end ;
71277: LD_VAR 0 2
71281: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71282: LD_INT 0
71284: PPUSH
71285: PPUSH
71286: PPUSH
71287: PPUSH
71288: PPUSH
71289: PPUSH
// if not unit or not building then
71290: LD_VAR 0 1
71294: NOT
71295: PUSH
71296: LD_VAR 0 2
71300: NOT
71301: OR
71302: IFFALSE 71306
// exit ;
71304: GO 71464
// x := GetX ( building ) ;
71306: LD_ADDR_VAR 0 5
71310: PUSH
71311: LD_VAR 0 2
71315: PPUSH
71316: CALL_OW 250
71320: ST_TO_ADDR
// y := GetY ( building ) ;
71321: LD_ADDR_VAR 0 6
71325: PUSH
71326: LD_VAR 0 2
71330: PPUSH
71331: CALL_OW 251
71335: ST_TO_ADDR
// for i = 0 to 5 do
71336: LD_ADDR_VAR 0 4
71340: PUSH
71341: DOUBLE
71342: LD_INT 0
71344: DEC
71345: ST_TO_ADDR
71346: LD_INT 5
71348: PUSH
71349: FOR_TO
71350: IFFALSE 71462
// begin _x := ShiftX ( x , i , 3 ) ;
71352: LD_ADDR_VAR 0 7
71356: PUSH
71357: LD_VAR 0 5
71361: PPUSH
71362: LD_VAR 0 4
71366: PPUSH
71367: LD_INT 3
71369: PPUSH
71370: CALL_OW 272
71374: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71375: LD_ADDR_VAR 0 8
71379: PUSH
71380: LD_VAR 0 6
71384: PPUSH
71385: LD_VAR 0 4
71389: PPUSH
71390: LD_INT 3
71392: PPUSH
71393: CALL_OW 273
71397: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71398: LD_VAR 0 7
71402: PPUSH
71403: LD_VAR 0 8
71407: PPUSH
71408: CALL_OW 488
71412: NOT
71413: IFFALSE 71417
// continue ;
71415: GO 71349
// if HexInfo ( _x , _y ) = 0 then
71417: LD_VAR 0 7
71421: PPUSH
71422: LD_VAR 0 8
71426: PPUSH
71427: CALL_OW 428
71431: PUSH
71432: LD_INT 0
71434: EQUAL
71435: IFFALSE 71460
// begin ComMoveXY ( unit , _x , _y ) ;
71437: LD_VAR 0 1
71441: PPUSH
71442: LD_VAR 0 7
71446: PPUSH
71447: LD_VAR 0 8
71451: PPUSH
71452: CALL_OW 111
// exit ;
71456: POP
71457: POP
71458: GO 71464
// end ; end ;
71460: GO 71349
71462: POP
71463: POP
// end ;
71464: LD_VAR 0 3
71468: RET
// export function ScanBase ( side , base_area ) ; begin
71469: LD_INT 0
71471: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71472: LD_ADDR_VAR 0 3
71476: PUSH
71477: LD_VAR 0 2
71481: PPUSH
71482: LD_INT 81
71484: PUSH
71485: LD_VAR 0 1
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PPUSH
71494: CALL_OW 70
71498: ST_TO_ADDR
// end ;
71499: LD_VAR 0 3
71503: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71504: LD_INT 0
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
// result := false ;
71510: LD_ADDR_VAR 0 2
71514: PUSH
71515: LD_INT 0
71517: ST_TO_ADDR
// side := GetSide ( unit ) ;
71518: LD_ADDR_VAR 0 3
71522: PUSH
71523: LD_VAR 0 1
71527: PPUSH
71528: CALL_OW 255
71532: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71533: LD_ADDR_VAR 0 4
71537: PUSH
71538: LD_VAR 0 1
71542: PPUSH
71543: CALL_OW 248
71547: ST_TO_ADDR
// case nat of 1 :
71548: LD_VAR 0 4
71552: PUSH
71553: LD_INT 1
71555: DOUBLE
71556: EQUAL
71557: IFTRUE 71561
71559: GO 71572
71561: POP
// tech := tech_lassight ; 2 :
71562: LD_ADDR_VAR 0 5
71566: PUSH
71567: LD_INT 12
71569: ST_TO_ADDR
71570: GO 71611
71572: LD_INT 2
71574: DOUBLE
71575: EQUAL
71576: IFTRUE 71580
71578: GO 71591
71580: POP
// tech := tech_mortar ; 3 :
71581: LD_ADDR_VAR 0 5
71585: PUSH
71586: LD_INT 41
71588: ST_TO_ADDR
71589: GO 71611
71591: LD_INT 3
71593: DOUBLE
71594: EQUAL
71595: IFTRUE 71599
71597: GO 71610
71599: POP
// tech := tech_bazooka ; end ;
71600: LD_ADDR_VAR 0 5
71604: PUSH
71605: LD_INT 44
71607: ST_TO_ADDR
71608: GO 71611
71610: POP
// if Researched ( side , tech ) then
71611: LD_VAR 0 3
71615: PPUSH
71616: LD_VAR 0 5
71620: PPUSH
71621: CALL_OW 325
71625: IFFALSE 71652
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71627: LD_ADDR_VAR 0 2
71631: PUSH
71632: LD_INT 5
71634: PUSH
71635: LD_INT 8
71637: PUSH
71638: LD_INT 9
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: LIST
71645: PUSH
71646: LD_VAR 0 4
71650: ARRAY
71651: ST_TO_ADDR
// end ;
71652: LD_VAR 0 2
71656: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71657: LD_INT 0
71659: PPUSH
71660: PPUSH
71661: PPUSH
// if not mines then
71662: LD_VAR 0 2
71666: NOT
71667: IFFALSE 71671
// exit ;
71669: GO 71815
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71671: LD_ADDR_VAR 0 5
71675: PUSH
71676: LD_INT 81
71678: PUSH
71679: LD_VAR 0 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 3
71690: PUSH
71691: LD_INT 21
71693: PUSH
71694: LD_INT 3
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PPUSH
71709: CALL_OW 69
71713: ST_TO_ADDR
// for i in mines do
71714: LD_ADDR_VAR 0 4
71718: PUSH
71719: LD_VAR 0 2
71723: PUSH
71724: FOR_IN
71725: IFFALSE 71813
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71727: LD_VAR 0 4
71731: PUSH
71732: LD_INT 1
71734: ARRAY
71735: PPUSH
71736: LD_VAR 0 4
71740: PUSH
71741: LD_INT 2
71743: ARRAY
71744: PPUSH
71745: CALL_OW 458
71749: NOT
71750: IFFALSE 71754
// continue ;
71752: GO 71724
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71754: LD_VAR 0 4
71758: PUSH
71759: LD_INT 1
71761: ARRAY
71762: PPUSH
71763: LD_VAR 0 4
71767: PUSH
71768: LD_INT 2
71770: ARRAY
71771: PPUSH
71772: CALL_OW 428
71776: PUSH
71777: LD_VAR 0 5
71781: IN
71782: IFFALSE 71811
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71784: LD_VAR 0 4
71788: PUSH
71789: LD_INT 1
71791: ARRAY
71792: PPUSH
71793: LD_VAR 0 4
71797: PUSH
71798: LD_INT 2
71800: ARRAY
71801: PPUSH
71802: LD_VAR 0 1
71806: PPUSH
71807: CALL_OW 456
// end ;
71811: GO 71724
71813: POP
71814: POP
// end ;
71815: LD_VAR 0 3
71819: RET
// export function Count ( array ) ; begin
71820: LD_INT 0
71822: PPUSH
// result := array + 0 ;
71823: LD_ADDR_VAR 0 2
71827: PUSH
71828: LD_VAR 0 1
71832: PUSH
71833: LD_INT 0
71835: PLUS
71836: ST_TO_ADDR
// end ;
71837: LD_VAR 0 2
71841: RET
// export function IsEmpty ( building ) ; begin
71842: LD_INT 0
71844: PPUSH
// if not building then
71845: LD_VAR 0 1
71849: NOT
71850: IFFALSE 71854
// exit ;
71852: GO 71897
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71854: LD_ADDR_VAR 0 2
71858: PUSH
71859: LD_VAR 0 1
71863: PUSH
71864: LD_INT 22
71866: PUSH
71867: LD_VAR 0 1
71871: PPUSH
71872: CALL_OW 255
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: LD_INT 58
71883: PUSH
71884: EMPTY
71885: LIST
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PPUSH
71891: CALL_OW 69
71895: IN
71896: ST_TO_ADDR
// end ;
71897: LD_VAR 0 2
71901: RET
// export function IsNotFull ( building ) ; var places ; begin
71902: LD_INT 0
71904: PPUSH
71905: PPUSH
// if not building then
71906: LD_VAR 0 1
71910: NOT
71911: IFFALSE 71915
// exit ;
71913: GO 71943
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71915: LD_ADDR_VAR 0 2
71919: PUSH
71920: LD_VAR 0 1
71924: PPUSH
71925: LD_INT 3
71927: PUSH
71928: LD_INT 62
71930: PUSH
71931: EMPTY
71932: LIST
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PPUSH
71938: CALL_OW 72
71942: ST_TO_ADDR
// end ;
71943: LD_VAR 0 2
71947: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71948: LD_INT 0
71950: PPUSH
71951: PPUSH
71952: PPUSH
71953: PPUSH
// tmp := [ ] ;
71954: LD_ADDR_VAR 0 3
71958: PUSH
71959: EMPTY
71960: ST_TO_ADDR
// list := [ ] ;
71961: LD_ADDR_VAR 0 5
71965: PUSH
71966: EMPTY
71967: ST_TO_ADDR
// for i = 16 to 25 do
71968: LD_ADDR_VAR 0 4
71972: PUSH
71973: DOUBLE
71974: LD_INT 16
71976: DEC
71977: ST_TO_ADDR
71978: LD_INT 25
71980: PUSH
71981: FOR_TO
71982: IFFALSE 72055
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71984: LD_ADDR_VAR 0 3
71988: PUSH
71989: LD_VAR 0 3
71993: PUSH
71994: LD_INT 22
71996: PUSH
71997: LD_VAR 0 1
72001: PPUSH
72002: CALL_OW 255
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 91
72013: PUSH
72014: LD_VAR 0 1
72018: PUSH
72019: LD_INT 6
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: LIST
72026: PUSH
72027: LD_INT 30
72029: PUSH
72030: LD_VAR 0 4
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: LIST
72043: PUSH
72044: EMPTY
72045: LIST
72046: PPUSH
72047: CALL_OW 69
72051: ADD
72052: ST_TO_ADDR
72053: GO 71981
72055: POP
72056: POP
// for i = 1 to tmp do
72057: LD_ADDR_VAR 0 4
72061: PUSH
72062: DOUBLE
72063: LD_INT 1
72065: DEC
72066: ST_TO_ADDR
72067: LD_VAR 0 3
72071: PUSH
72072: FOR_TO
72073: IFFALSE 72161
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72075: LD_ADDR_VAR 0 5
72079: PUSH
72080: LD_VAR 0 5
72084: PUSH
72085: LD_VAR 0 3
72089: PUSH
72090: LD_VAR 0 4
72094: ARRAY
72095: PPUSH
72096: CALL_OW 266
72100: PUSH
72101: LD_VAR 0 3
72105: PUSH
72106: LD_VAR 0 4
72110: ARRAY
72111: PPUSH
72112: CALL_OW 250
72116: PUSH
72117: LD_VAR 0 3
72121: PUSH
72122: LD_VAR 0 4
72126: ARRAY
72127: PPUSH
72128: CALL_OW 251
72132: PUSH
72133: LD_VAR 0 3
72137: PUSH
72138: LD_VAR 0 4
72142: ARRAY
72143: PPUSH
72144: CALL_OW 254
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: PUSH
72155: EMPTY
72156: LIST
72157: ADD
72158: ST_TO_ADDR
72159: GO 72072
72161: POP
72162: POP
// result := list ;
72163: LD_ADDR_VAR 0 2
72167: PUSH
72168: LD_VAR 0 5
72172: ST_TO_ADDR
// end ;
72173: LD_VAR 0 2
72177: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72178: LD_INT 0
72180: PPUSH
72181: PPUSH
72182: PPUSH
72183: PPUSH
72184: PPUSH
72185: PPUSH
72186: PPUSH
// if not factory then
72187: LD_VAR 0 1
72191: NOT
72192: IFFALSE 72196
// exit ;
72194: GO 72789
// if control = control_apeman then
72196: LD_VAR 0 4
72200: PUSH
72201: LD_INT 5
72203: EQUAL
72204: IFFALSE 72313
// begin tmp := UnitsInside ( factory ) ;
72206: LD_ADDR_VAR 0 8
72210: PUSH
72211: LD_VAR 0 1
72215: PPUSH
72216: CALL_OW 313
72220: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72221: LD_VAR 0 8
72225: PPUSH
72226: LD_INT 25
72228: PUSH
72229: LD_INT 12
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PPUSH
72236: CALL_OW 72
72240: NOT
72241: IFFALSE 72251
// control := control_manual ;
72243: LD_ADDR_VAR 0 4
72247: PUSH
72248: LD_INT 1
72250: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72251: LD_ADDR_VAR 0 8
72255: PUSH
72256: LD_VAR 0 1
72260: PPUSH
72261: CALL 71948 0 1
72265: ST_TO_ADDR
// if tmp then
72266: LD_VAR 0 8
72270: IFFALSE 72313
// begin for i in tmp do
72272: LD_ADDR_VAR 0 7
72276: PUSH
72277: LD_VAR 0 8
72281: PUSH
72282: FOR_IN
72283: IFFALSE 72311
// if i [ 1 ] = b_ext_radio then
72285: LD_VAR 0 7
72289: PUSH
72290: LD_INT 1
72292: ARRAY
72293: PUSH
72294: LD_INT 22
72296: EQUAL
72297: IFFALSE 72309
// begin control := control_remote ;
72299: LD_ADDR_VAR 0 4
72303: PUSH
72304: LD_INT 2
72306: ST_TO_ADDR
// break ;
72307: GO 72311
// end ;
72309: GO 72282
72311: POP
72312: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72313: LD_VAR 0 1
72317: PPUSH
72318: LD_VAR 0 2
72322: PPUSH
72323: LD_VAR 0 3
72327: PPUSH
72328: LD_VAR 0 4
72332: PPUSH
72333: LD_VAR 0 5
72337: PPUSH
72338: CALL_OW 448
72342: IFFALSE 72377
// begin result := [ chassis , engine , control , weapon ] ;
72344: LD_ADDR_VAR 0 6
72348: PUSH
72349: LD_VAR 0 2
72353: PUSH
72354: LD_VAR 0 3
72358: PUSH
72359: LD_VAR 0 4
72363: PUSH
72364: LD_VAR 0 5
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: ST_TO_ADDR
// exit ;
72375: GO 72789
// end ; _chassis := AvailableChassisList ( factory ) ;
72377: LD_ADDR_VAR 0 9
72381: PUSH
72382: LD_VAR 0 1
72386: PPUSH
72387: CALL_OW 475
72391: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72392: LD_ADDR_VAR 0 11
72396: PUSH
72397: LD_VAR 0 1
72401: PPUSH
72402: CALL_OW 476
72406: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72407: LD_ADDR_VAR 0 12
72411: PUSH
72412: LD_VAR 0 1
72416: PPUSH
72417: CALL_OW 477
72421: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72422: LD_ADDR_VAR 0 10
72426: PUSH
72427: LD_VAR 0 1
72431: PPUSH
72432: CALL_OW 478
72436: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72437: LD_VAR 0 9
72441: NOT
72442: PUSH
72443: LD_VAR 0 11
72447: NOT
72448: OR
72449: PUSH
72450: LD_VAR 0 12
72454: NOT
72455: OR
72456: PUSH
72457: LD_VAR 0 10
72461: NOT
72462: OR
72463: IFFALSE 72498
// begin result := [ chassis , engine , control , weapon ] ;
72465: LD_ADDR_VAR 0 6
72469: PUSH
72470: LD_VAR 0 2
72474: PUSH
72475: LD_VAR 0 3
72479: PUSH
72480: LD_VAR 0 4
72484: PUSH
72485: LD_VAR 0 5
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: ST_TO_ADDR
// exit ;
72496: GO 72789
// end ; if not chassis in _chassis then
72498: LD_VAR 0 2
72502: PUSH
72503: LD_VAR 0 9
72507: IN
72508: NOT
72509: IFFALSE 72535
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72511: LD_ADDR_VAR 0 2
72515: PUSH
72516: LD_VAR 0 9
72520: PUSH
72521: LD_INT 1
72523: PPUSH
72524: LD_VAR 0 9
72528: PPUSH
72529: CALL_OW 12
72533: ARRAY
72534: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72535: LD_VAR 0 2
72539: PPUSH
72540: LD_VAR 0 3
72544: PPUSH
72545: CALL 72794 0 2
72549: NOT
72550: IFFALSE 72609
// repeat engine := _engine [ 1 ] ;
72552: LD_ADDR_VAR 0 3
72556: PUSH
72557: LD_VAR 0 11
72561: PUSH
72562: LD_INT 1
72564: ARRAY
72565: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72566: LD_ADDR_VAR 0 11
72570: PUSH
72571: LD_VAR 0 11
72575: PPUSH
72576: LD_INT 1
72578: PPUSH
72579: CALL_OW 3
72583: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72584: LD_VAR 0 2
72588: PPUSH
72589: LD_VAR 0 3
72593: PPUSH
72594: CALL 72794 0 2
72598: PUSH
72599: LD_VAR 0 11
72603: PUSH
72604: EMPTY
72605: EQUAL
72606: OR
72607: IFFALSE 72552
// if not control in _control then
72609: LD_VAR 0 4
72613: PUSH
72614: LD_VAR 0 12
72618: IN
72619: NOT
72620: IFFALSE 72646
// control := _control [ rand ( 1 , _control ) ] ;
72622: LD_ADDR_VAR 0 4
72626: PUSH
72627: LD_VAR 0 12
72631: PUSH
72632: LD_INT 1
72634: PPUSH
72635: LD_VAR 0 12
72639: PPUSH
72640: CALL_OW 12
72644: ARRAY
72645: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72646: LD_VAR 0 2
72650: PPUSH
72651: LD_VAR 0 5
72655: PPUSH
72656: CALL 73014 0 2
72660: NOT
72661: IFFALSE 72720
// repeat weapon := _weapon [ 1 ] ;
72663: LD_ADDR_VAR 0 5
72667: PUSH
72668: LD_VAR 0 10
72672: PUSH
72673: LD_INT 1
72675: ARRAY
72676: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72677: LD_ADDR_VAR 0 10
72681: PUSH
72682: LD_VAR 0 10
72686: PPUSH
72687: LD_INT 1
72689: PPUSH
72690: CALL_OW 3
72694: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72695: LD_VAR 0 2
72699: PPUSH
72700: LD_VAR 0 5
72704: PPUSH
72705: CALL 73014 0 2
72709: PUSH
72710: LD_VAR 0 10
72714: PUSH
72715: EMPTY
72716: EQUAL
72717: OR
72718: IFFALSE 72663
// result := [ ] ;
72720: LD_ADDR_VAR 0 6
72724: PUSH
72725: EMPTY
72726: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72727: LD_VAR 0 1
72731: PPUSH
72732: LD_VAR 0 2
72736: PPUSH
72737: LD_VAR 0 3
72741: PPUSH
72742: LD_VAR 0 4
72746: PPUSH
72747: LD_VAR 0 5
72751: PPUSH
72752: CALL_OW 448
72756: IFFALSE 72789
// result := [ chassis , engine , control , weapon ] ;
72758: LD_ADDR_VAR 0 6
72762: PUSH
72763: LD_VAR 0 2
72767: PUSH
72768: LD_VAR 0 3
72772: PUSH
72773: LD_VAR 0 4
72777: PUSH
72778: LD_VAR 0 5
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: ST_TO_ADDR
// end ;
72789: LD_VAR 0 6
72793: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72794: LD_INT 0
72796: PPUSH
// if not chassis or not engine then
72797: LD_VAR 0 1
72801: NOT
72802: PUSH
72803: LD_VAR 0 2
72807: NOT
72808: OR
72809: IFFALSE 72813
// exit ;
72811: GO 73009
// case engine of engine_solar :
72813: LD_VAR 0 2
72817: PUSH
72818: LD_INT 2
72820: DOUBLE
72821: EQUAL
72822: IFTRUE 72826
72824: GO 72864
72826: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72827: LD_ADDR_VAR 0 3
72831: PUSH
72832: LD_INT 11
72834: PUSH
72835: LD_INT 12
72837: PUSH
72838: LD_INT 13
72840: PUSH
72841: LD_INT 14
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: LD_INT 2
72849: PUSH
72850: LD_INT 3
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: ST_TO_ADDR
72862: GO 72993
72864: LD_INT 1
72866: DOUBLE
72867: EQUAL
72868: IFTRUE 72872
72870: GO 72934
72872: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72873: LD_ADDR_VAR 0 3
72877: PUSH
72878: LD_INT 11
72880: PUSH
72881: LD_INT 12
72883: PUSH
72884: LD_INT 13
72886: PUSH
72887: LD_INT 14
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: LD_INT 3
72898: PUSH
72899: LD_INT 4
72901: PUSH
72902: LD_INT 5
72904: PUSH
72905: LD_INT 21
72907: PUSH
72908: LD_INT 23
72910: PUSH
72911: LD_INT 22
72913: PUSH
72914: LD_INT 24
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: ST_TO_ADDR
72932: GO 72993
72934: LD_INT 3
72936: DOUBLE
72937: EQUAL
72938: IFTRUE 72942
72940: GO 72992
72942: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72943: LD_ADDR_VAR 0 3
72947: PUSH
72948: LD_INT 13
72950: PUSH
72951: LD_INT 14
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: LD_INT 3
72959: PUSH
72960: LD_INT 4
72962: PUSH
72963: LD_INT 5
72965: PUSH
72966: LD_INT 21
72968: PUSH
72969: LD_INT 22
72971: PUSH
72972: LD_INT 23
72974: PUSH
72975: LD_INT 24
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: ST_TO_ADDR
72990: GO 72993
72992: POP
// result := ( chassis in result ) ;
72993: LD_ADDR_VAR 0 3
72997: PUSH
72998: LD_VAR 0 1
73002: PUSH
73003: LD_VAR 0 3
73007: IN
73008: ST_TO_ADDR
// end ;
73009: LD_VAR 0 3
73013: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73014: LD_INT 0
73016: PPUSH
// if not chassis or not weapon then
73017: LD_VAR 0 1
73021: NOT
73022: PUSH
73023: LD_VAR 0 2
73027: NOT
73028: OR
73029: IFFALSE 73033
// exit ;
73031: GO 74093
// case weapon of us_machine_gun :
73033: LD_VAR 0 2
73037: PUSH
73038: LD_INT 2
73040: DOUBLE
73041: EQUAL
73042: IFTRUE 73046
73044: GO 73076
73046: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73047: LD_ADDR_VAR 0 3
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: LD_INT 2
73057: PUSH
73058: LD_INT 3
73060: PUSH
73061: LD_INT 4
73063: PUSH
73064: LD_INT 5
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: ST_TO_ADDR
73074: GO 74077
73076: LD_INT 3
73078: DOUBLE
73079: EQUAL
73080: IFTRUE 73084
73082: GO 73114
73084: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73085: LD_ADDR_VAR 0 3
73089: PUSH
73090: LD_INT 1
73092: PUSH
73093: LD_INT 2
73095: PUSH
73096: LD_INT 3
73098: PUSH
73099: LD_INT 4
73101: PUSH
73102: LD_INT 5
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: ST_TO_ADDR
73112: GO 74077
73114: LD_INT 11
73116: DOUBLE
73117: EQUAL
73118: IFTRUE 73122
73120: GO 73152
73122: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73123: LD_ADDR_VAR 0 3
73127: PUSH
73128: LD_INT 1
73130: PUSH
73131: LD_INT 2
73133: PUSH
73134: LD_INT 3
73136: PUSH
73137: LD_INT 4
73139: PUSH
73140: LD_INT 5
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: ST_TO_ADDR
73150: GO 74077
73152: LD_INT 4
73154: DOUBLE
73155: EQUAL
73156: IFTRUE 73160
73158: GO 73186
73160: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73161: LD_ADDR_VAR 0 3
73165: PUSH
73166: LD_INT 2
73168: PUSH
73169: LD_INT 3
73171: PUSH
73172: LD_INT 4
73174: PUSH
73175: LD_INT 5
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: ST_TO_ADDR
73184: GO 74077
73186: LD_INT 5
73188: DOUBLE
73189: EQUAL
73190: IFTRUE 73194
73192: GO 73220
73194: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73195: LD_ADDR_VAR 0 3
73199: PUSH
73200: LD_INT 2
73202: PUSH
73203: LD_INT 3
73205: PUSH
73206: LD_INT 4
73208: PUSH
73209: LD_INT 5
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: ST_TO_ADDR
73218: GO 74077
73220: LD_INT 9
73222: DOUBLE
73223: EQUAL
73224: IFTRUE 73228
73226: GO 73254
73228: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73229: LD_ADDR_VAR 0 3
73233: PUSH
73234: LD_INT 2
73236: PUSH
73237: LD_INT 3
73239: PUSH
73240: LD_INT 4
73242: PUSH
73243: LD_INT 5
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: LIST
73250: LIST
73251: ST_TO_ADDR
73252: GO 74077
73254: LD_INT 7
73256: DOUBLE
73257: EQUAL
73258: IFTRUE 73262
73260: GO 73288
73262: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73263: LD_ADDR_VAR 0 3
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 3
73273: PUSH
73274: LD_INT 4
73276: PUSH
73277: LD_INT 5
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: ST_TO_ADDR
73286: GO 74077
73288: LD_INT 12
73290: DOUBLE
73291: EQUAL
73292: IFTRUE 73296
73294: GO 73322
73296: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73297: LD_ADDR_VAR 0 3
73301: PUSH
73302: LD_INT 2
73304: PUSH
73305: LD_INT 3
73307: PUSH
73308: LD_INT 4
73310: PUSH
73311: LD_INT 5
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: ST_TO_ADDR
73320: GO 74077
73322: LD_INT 13
73324: DOUBLE
73325: EQUAL
73326: IFTRUE 73330
73328: GO 73356
73330: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73331: LD_ADDR_VAR 0 3
73335: PUSH
73336: LD_INT 2
73338: PUSH
73339: LD_INT 3
73341: PUSH
73342: LD_INT 4
73344: PUSH
73345: LD_INT 5
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: ST_TO_ADDR
73354: GO 74077
73356: LD_INT 14
73358: DOUBLE
73359: EQUAL
73360: IFTRUE 73364
73362: GO 73382
73364: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73365: LD_ADDR_VAR 0 3
73369: PUSH
73370: LD_INT 4
73372: PUSH
73373: LD_INT 5
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: ST_TO_ADDR
73380: GO 74077
73382: LD_INT 6
73384: DOUBLE
73385: EQUAL
73386: IFTRUE 73390
73388: GO 73408
73390: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73391: LD_ADDR_VAR 0 3
73395: PUSH
73396: LD_INT 4
73398: PUSH
73399: LD_INT 5
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: ST_TO_ADDR
73406: GO 74077
73408: LD_INT 10
73410: DOUBLE
73411: EQUAL
73412: IFTRUE 73416
73414: GO 73434
73416: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73417: LD_ADDR_VAR 0 3
73421: PUSH
73422: LD_INT 4
73424: PUSH
73425: LD_INT 5
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: ST_TO_ADDR
73432: GO 74077
73434: LD_INT 22
73436: DOUBLE
73437: EQUAL
73438: IFTRUE 73442
73440: GO 73468
73442: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73443: LD_ADDR_VAR 0 3
73447: PUSH
73448: LD_INT 11
73450: PUSH
73451: LD_INT 12
73453: PUSH
73454: LD_INT 13
73456: PUSH
73457: LD_INT 14
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: ST_TO_ADDR
73466: GO 74077
73468: LD_INT 23
73470: DOUBLE
73471: EQUAL
73472: IFTRUE 73476
73474: GO 73502
73476: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73477: LD_ADDR_VAR 0 3
73481: PUSH
73482: LD_INT 11
73484: PUSH
73485: LD_INT 12
73487: PUSH
73488: LD_INT 13
73490: PUSH
73491: LD_INT 14
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: LIST
73498: LIST
73499: ST_TO_ADDR
73500: GO 74077
73502: LD_INT 24
73504: DOUBLE
73505: EQUAL
73506: IFTRUE 73510
73508: GO 73536
73510: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73511: LD_ADDR_VAR 0 3
73515: PUSH
73516: LD_INT 11
73518: PUSH
73519: LD_INT 12
73521: PUSH
73522: LD_INT 13
73524: PUSH
73525: LD_INT 14
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: ST_TO_ADDR
73534: GO 74077
73536: LD_INT 30
73538: DOUBLE
73539: EQUAL
73540: IFTRUE 73544
73542: GO 73570
73544: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73545: LD_ADDR_VAR 0 3
73549: PUSH
73550: LD_INT 11
73552: PUSH
73553: LD_INT 12
73555: PUSH
73556: LD_INT 13
73558: PUSH
73559: LD_INT 14
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: ST_TO_ADDR
73568: GO 74077
73570: LD_INT 25
73572: DOUBLE
73573: EQUAL
73574: IFTRUE 73578
73576: GO 73596
73578: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73579: LD_ADDR_VAR 0 3
73583: PUSH
73584: LD_INT 13
73586: PUSH
73587: LD_INT 14
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: ST_TO_ADDR
73594: GO 74077
73596: LD_INT 27
73598: DOUBLE
73599: EQUAL
73600: IFTRUE 73604
73602: GO 73622
73604: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73605: LD_ADDR_VAR 0 3
73609: PUSH
73610: LD_INT 13
73612: PUSH
73613: LD_INT 14
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: ST_TO_ADDR
73620: GO 74077
73622: LD_INT 92
73624: DOUBLE
73625: EQUAL
73626: IFTRUE 73630
73628: GO 73656
73630: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73631: LD_ADDR_VAR 0 3
73635: PUSH
73636: LD_INT 11
73638: PUSH
73639: LD_INT 12
73641: PUSH
73642: LD_INT 13
73644: PUSH
73645: LD_INT 14
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: ST_TO_ADDR
73654: GO 74077
73656: LD_INT 28
73658: DOUBLE
73659: EQUAL
73660: IFTRUE 73664
73662: GO 73682
73664: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73665: LD_ADDR_VAR 0 3
73669: PUSH
73670: LD_INT 13
73672: PUSH
73673: LD_INT 14
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: ST_TO_ADDR
73680: GO 74077
73682: LD_INT 29
73684: DOUBLE
73685: EQUAL
73686: IFTRUE 73690
73688: GO 73708
73690: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73691: LD_ADDR_VAR 0 3
73695: PUSH
73696: LD_INT 13
73698: PUSH
73699: LD_INT 14
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: ST_TO_ADDR
73706: GO 74077
73708: LD_INT 31
73710: DOUBLE
73711: EQUAL
73712: IFTRUE 73716
73714: GO 73734
73716: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73717: LD_ADDR_VAR 0 3
73721: PUSH
73722: LD_INT 13
73724: PUSH
73725: LD_INT 14
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: ST_TO_ADDR
73732: GO 74077
73734: LD_INT 26
73736: DOUBLE
73737: EQUAL
73738: IFTRUE 73742
73740: GO 73760
73742: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73743: LD_ADDR_VAR 0 3
73747: PUSH
73748: LD_INT 13
73750: PUSH
73751: LD_INT 14
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: ST_TO_ADDR
73758: GO 74077
73760: LD_INT 42
73762: DOUBLE
73763: EQUAL
73764: IFTRUE 73768
73766: GO 73794
73768: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73769: LD_ADDR_VAR 0 3
73773: PUSH
73774: LD_INT 21
73776: PUSH
73777: LD_INT 22
73779: PUSH
73780: LD_INT 23
73782: PUSH
73783: LD_INT 24
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: ST_TO_ADDR
73792: GO 74077
73794: LD_INT 43
73796: DOUBLE
73797: EQUAL
73798: IFTRUE 73802
73800: GO 73828
73802: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73803: LD_ADDR_VAR 0 3
73807: PUSH
73808: LD_INT 21
73810: PUSH
73811: LD_INT 22
73813: PUSH
73814: LD_INT 23
73816: PUSH
73817: LD_INT 24
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: ST_TO_ADDR
73826: GO 74077
73828: LD_INT 44
73830: DOUBLE
73831: EQUAL
73832: IFTRUE 73836
73834: GO 73862
73836: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73837: LD_ADDR_VAR 0 3
73841: PUSH
73842: LD_INT 21
73844: PUSH
73845: LD_INT 22
73847: PUSH
73848: LD_INT 23
73850: PUSH
73851: LD_INT 24
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: ST_TO_ADDR
73860: GO 74077
73862: LD_INT 45
73864: DOUBLE
73865: EQUAL
73866: IFTRUE 73870
73868: GO 73896
73870: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73871: LD_ADDR_VAR 0 3
73875: PUSH
73876: LD_INT 21
73878: PUSH
73879: LD_INT 22
73881: PUSH
73882: LD_INT 23
73884: PUSH
73885: LD_INT 24
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: ST_TO_ADDR
73894: GO 74077
73896: LD_INT 49
73898: DOUBLE
73899: EQUAL
73900: IFTRUE 73904
73902: GO 73930
73904: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73905: LD_ADDR_VAR 0 3
73909: PUSH
73910: LD_INT 21
73912: PUSH
73913: LD_INT 22
73915: PUSH
73916: LD_INT 23
73918: PUSH
73919: LD_INT 24
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: ST_TO_ADDR
73928: GO 74077
73930: LD_INT 51
73932: DOUBLE
73933: EQUAL
73934: IFTRUE 73938
73936: GO 73964
73938: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73939: LD_ADDR_VAR 0 3
73943: PUSH
73944: LD_INT 21
73946: PUSH
73947: LD_INT 22
73949: PUSH
73950: LD_INT 23
73952: PUSH
73953: LD_INT 24
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: ST_TO_ADDR
73962: GO 74077
73964: LD_INT 52
73966: DOUBLE
73967: EQUAL
73968: IFTRUE 73972
73970: GO 73998
73972: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73973: LD_ADDR_VAR 0 3
73977: PUSH
73978: LD_INT 21
73980: PUSH
73981: LD_INT 22
73983: PUSH
73984: LD_INT 23
73986: PUSH
73987: LD_INT 24
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: ST_TO_ADDR
73996: GO 74077
73998: LD_INT 53
74000: DOUBLE
74001: EQUAL
74002: IFTRUE 74006
74004: GO 74024
74006: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74007: LD_ADDR_VAR 0 3
74011: PUSH
74012: LD_INT 23
74014: PUSH
74015: LD_INT 24
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: ST_TO_ADDR
74022: GO 74077
74024: LD_INT 46
74026: DOUBLE
74027: EQUAL
74028: IFTRUE 74032
74030: GO 74050
74032: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74033: LD_ADDR_VAR 0 3
74037: PUSH
74038: LD_INT 23
74040: PUSH
74041: LD_INT 24
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: ST_TO_ADDR
74048: GO 74077
74050: LD_INT 47
74052: DOUBLE
74053: EQUAL
74054: IFTRUE 74058
74056: GO 74076
74058: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74059: LD_ADDR_VAR 0 3
74063: PUSH
74064: LD_INT 23
74066: PUSH
74067: LD_INT 24
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: ST_TO_ADDR
74074: GO 74077
74076: POP
// result := ( chassis in result ) ;
74077: LD_ADDR_VAR 0 3
74081: PUSH
74082: LD_VAR 0 1
74086: PUSH
74087: LD_VAR 0 3
74091: IN
74092: ST_TO_ADDR
// end ;
74093: LD_VAR 0 3
74097: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74098: LD_INT 0
74100: PPUSH
74101: PPUSH
74102: PPUSH
74103: PPUSH
74104: PPUSH
74105: PPUSH
74106: PPUSH
// result := array ;
74107: LD_ADDR_VAR 0 5
74111: PUSH
74112: LD_VAR 0 1
74116: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74117: LD_VAR 0 1
74121: NOT
74122: PUSH
74123: LD_VAR 0 2
74127: NOT
74128: OR
74129: PUSH
74130: LD_VAR 0 3
74134: NOT
74135: OR
74136: PUSH
74137: LD_VAR 0 2
74141: PUSH
74142: LD_VAR 0 1
74146: GREATER
74147: OR
74148: PUSH
74149: LD_VAR 0 3
74153: PUSH
74154: LD_VAR 0 1
74158: GREATER
74159: OR
74160: IFFALSE 74164
// exit ;
74162: GO 74460
// if direction then
74164: LD_VAR 0 4
74168: IFFALSE 74232
// begin d := 1 ;
74170: LD_ADDR_VAR 0 9
74174: PUSH
74175: LD_INT 1
74177: ST_TO_ADDR
// if i_from > i_to then
74178: LD_VAR 0 2
74182: PUSH
74183: LD_VAR 0 3
74187: GREATER
74188: IFFALSE 74214
// length := ( array - i_from ) + i_to else
74190: LD_ADDR_VAR 0 11
74194: PUSH
74195: LD_VAR 0 1
74199: PUSH
74200: LD_VAR 0 2
74204: MINUS
74205: PUSH
74206: LD_VAR 0 3
74210: PLUS
74211: ST_TO_ADDR
74212: GO 74230
// length := i_to - i_from ;
74214: LD_ADDR_VAR 0 11
74218: PUSH
74219: LD_VAR 0 3
74223: PUSH
74224: LD_VAR 0 2
74228: MINUS
74229: ST_TO_ADDR
// end else
74230: GO 74293
// begin d := - 1 ;
74232: LD_ADDR_VAR 0 9
74236: PUSH
74237: LD_INT 1
74239: NEG
74240: ST_TO_ADDR
// if i_from > i_to then
74241: LD_VAR 0 2
74245: PUSH
74246: LD_VAR 0 3
74250: GREATER
74251: IFFALSE 74271
// length := i_from - i_to else
74253: LD_ADDR_VAR 0 11
74257: PUSH
74258: LD_VAR 0 2
74262: PUSH
74263: LD_VAR 0 3
74267: MINUS
74268: ST_TO_ADDR
74269: GO 74293
// length := ( array - i_to ) + i_from ;
74271: LD_ADDR_VAR 0 11
74275: PUSH
74276: LD_VAR 0 1
74280: PUSH
74281: LD_VAR 0 3
74285: MINUS
74286: PUSH
74287: LD_VAR 0 2
74291: PLUS
74292: ST_TO_ADDR
// end ; if not length then
74293: LD_VAR 0 11
74297: NOT
74298: IFFALSE 74302
// exit ;
74300: GO 74460
// tmp := array ;
74302: LD_ADDR_VAR 0 10
74306: PUSH
74307: LD_VAR 0 1
74311: ST_TO_ADDR
// for i = 1 to length do
74312: LD_ADDR_VAR 0 6
74316: PUSH
74317: DOUBLE
74318: LD_INT 1
74320: DEC
74321: ST_TO_ADDR
74322: LD_VAR 0 11
74326: PUSH
74327: FOR_TO
74328: IFFALSE 74448
// begin for j = 1 to array do
74330: LD_ADDR_VAR 0 7
74334: PUSH
74335: DOUBLE
74336: LD_INT 1
74338: DEC
74339: ST_TO_ADDR
74340: LD_VAR 0 1
74344: PUSH
74345: FOR_TO
74346: IFFALSE 74434
// begin k := j + d ;
74348: LD_ADDR_VAR 0 8
74352: PUSH
74353: LD_VAR 0 7
74357: PUSH
74358: LD_VAR 0 9
74362: PLUS
74363: ST_TO_ADDR
// if k > array then
74364: LD_VAR 0 8
74368: PUSH
74369: LD_VAR 0 1
74373: GREATER
74374: IFFALSE 74384
// k := 1 ;
74376: LD_ADDR_VAR 0 8
74380: PUSH
74381: LD_INT 1
74383: ST_TO_ADDR
// if not k then
74384: LD_VAR 0 8
74388: NOT
74389: IFFALSE 74401
// k := array ;
74391: LD_ADDR_VAR 0 8
74395: PUSH
74396: LD_VAR 0 1
74400: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74401: LD_ADDR_VAR 0 10
74405: PUSH
74406: LD_VAR 0 10
74410: PPUSH
74411: LD_VAR 0 8
74415: PPUSH
74416: LD_VAR 0 1
74420: PUSH
74421: LD_VAR 0 7
74425: ARRAY
74426: PPUSH
74427: CALL_OW 1
74431: ST_TO_ADDR
// end ;
74432: GO 74345
74434: POP
74435: POP
// array := tmp ;
74436: LD_ADDR_VAR 0 1
74440: PUSH
74441: LD_VAR 0 10
74445: ST_TO_ADDR
// end ;
74446: GO 74327
74448: POP
74449: POP
// result := array ;
74450: LD_ADDR_VAR 0 5
74454: PUSH
74455: LD_VAR 0 1
74459: ST_TO_ADDR
// end ;
74460: LD_VAR 0 5
74464: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74465: LD_INT 0
74467: PPUSH
74468: PPUSH
// result := 0 ;
74469: LD_ADDR_VAR 0 3
74473: PUSH
74474: LD_INT 0
74476: ST_TO_ADDR
// if not array or not value in array then
74477: LD_VAR 0 1
74481: NOT
74482: PUSH
74483: LD_VAR 0 2
74487: PUSH
74488: LD_VAR 0 1
74492: IN
74493: NOT
74494: OR
74495: IFFALSE 74499
// exit ;
74497: GO 74553
// for i = 1 to array do
74499: LD_ADDR_VAR 0 4
74503: PUSH
74504: DOUBLE
74505: LD_INT 1
74507: DEC
74508: ST_TO_ADDR
74509: LD_VAR 0 1
74513: PUSH
74514: FOR_TO
74515: IFFALSE 74551
// if value = array [ i ] then
74517: LD_VAR 0 2
74521: PUSH
74522: LD_VAR 0 1
74526: PUSH
74527: LD_VAR 0 4
74531: ARRAY
74532: EQUAL
74533: IFFALSE 74549
// begin result := i ;
74535: LD_ADDR_VAR 0 3
74539: PUSH
74540: LD_VAR 0 4
74544: ST_TO_ADDR
// exit ;
74545: POP
74546: POP
74547: GO 74553
// end ;
74549: GO 74514
74551: POP
74552: POP
// end ;
74553: LD_VAR 0 3
74557: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74558: LD_INT 0
74560: PPUSH
// vc_chassis := chassis ;
74561: LD_ADDR_OWVAR 37
74565: PUSH
74566: LD_VAR 0 1
74570: ST_TO_ADDR
// vc_engine := engine ;
74571: LD_ADDR_OWVAR 39
74575: PUSH
74576: LD_VAR 0 2
74580: ST_TO_ADDR
// vc_control := control ;
74581: LD_ADDR_OWVAR 38
74585: PUSH
74586: LD_VAR 0 3
74590: ST_TO_ADDR
// vc_weapon := weapon ;
74591: LD_ADDR_OWVAR 40
74595: PUSH
74596: LD_VAR 0 4
74600: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74601: LD_ADDR_OWVAR 41
74605: PUSH
74606: LD_VAR 0 5
74610: ST_TO_ADDR
// end ;
74611: LD_VAR 0 6
74615: RET
// export function WantPlant ( unit ) ; var task ; begin
74616: LD_INT 0
74618: PPUSH
74619: PPUSH
// result := false ;
74620: LD_ADDR_VAR 0 2
74624: PUSH
74625: LD_INT 0
74627: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74628: LD_ADDR_VAR 0 3
74632: PUSH
74633: LD_VAR 0 1
74637: PPUSH
74638: CALL_OW 437
74642: ST_TO_ADDR
// if task then
74643: LD_VAR 0 3
74647: IFFALSE 74675
// if task [ 1 ] [ 1 ] = p then
74649: LD_VAR 0 3
74653: PUSH
74654: LD_INT 1
74656: ARRAY
74657: PUSH
74658: LD_INT 1
74660: ARRAY
74661: PUSH
74662: LD_STRING p
74664: EQUAL
74665: IFFALSE 74675
// result := true ;
74667: LD_ADDR_VAR 0 2
74671: PUSH
74672: LD_INT 1
74674: ST_TO_ADDR
// end ;
74675: LD_VAR 0 2
74679: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74680: LD_INT 0
74682: PPUSH
74683: PPUSH
74684: PPUSH
74685: PPUSH
// if pos < 1 then
74686: LD_VAR 0 2
74690: PUSH
74691: LD_INT 1
74693: LESS
74694: IFFALSE 74698
// exit ;
74696: GO 75001
// if pos = 1 then
74698: LD_VAR 0 2
74702: PUSH
74703: LD_INT 1
74705: EQUAL
74706: IFFALSE 74739
// result := Replace ( arr , pos [ 1 ] , value ) else
74708: LD_ADDR_VAR 0 4
74712: PUSH
74713: LD_VAR 0 1
74717: PPUSH
74718: LD_VAR 0 2
74722: PUSH
74723: LD_INT 1
74725: ARRAY
74726: PPUSH
74727: LD_VAR 0 3
74731: PPUSH
74732: CALL_OW 1
74736: ST_TO_ADDR
74737: GO 75001
// begin tmp := arr ;
74739: LD_ADDR_VAR 0 6
74743: PUSH
74744: LD_VAR 0 1
74748: ST_TO_ADDR
// s_arr := [ tmp ] ;
74749: LD_ADDR_VAR 0 7
74753: PUSH
74754: LD_VAR 0 6
74758: PUSH
74759: EMPTY
74760: LIST
74761: ST_TO_ADDR
// for i = 1 to pos - 1 do
74762: LD_ADDR_VAR 0 5
74766: PUSH
74767: DOUBLE
74768: LD_INT 1
74770: DEC
74771: ST_TO_ADDR
74772: LD_VAR 0 2
74776: PUSH
74777: LD_INT 1
74779: MINUS
74780: PUSH
74781: FOR_TO
74782: IFFALSE 74827
// begin tmp := tmp [ pos [ i ] ] ;
74784: LD_ADDR_VAR 0 6
74788: PUSH
74789: LD_VAR 0 6
74793: PUSH
74794: LD_VAR 0 2
74798: PUSH
74799: LD_VAR 0 5
74803: ARRAY
74804: ARRAY
74805: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74806: LD_ADDR_VAR 0 7
74810: PUSH
74811: LD_VAR 0 7
74815: PUSH
74816: LD_VAR 0 6
74820: PUSH
74821: EMPTY
74822: LIST
74823: ADD
74824: ST_TO_ADDR
// end ;
74825: GO 74781
74827: POP
74828: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74829: LD_ADDR_VAR 0 6
74833: PUSH
74834: LD_VAR 0 6
74838: PPUSH
74839: LD_VAR 0 2
74843: PUSH
74844: LD_VAR 0 2
74848: ARRAY
74849: PPUSH
74850: LD_VAR 0 3
74854: PPUSH
74855: CALL_OW 1
74859: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74860: LD_ADDR_VAR 0 7
74864: PUSH
74865: LD_VAR 0 7
74869: PPUSH
74870: LD_VAR 0 7
74874: PPUSH
74875: LD_VAR 0 6
74879: PPUSH
74880: CALL_OW 1
74884: ST_TO_ADDR
// for i = s_arr downto 2 do
74885: LD_ADDR_VAR 0 5
74889: PUSH
74890: DOUBLE
74891: LD_VAR 0 7
74895: INC
74896: ST_TO_ADDR
74897: LD_INT 2
74899: PUSH
74900: FOR_DOWNTO
74901: IFFALSE 74985
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74903: LD_ADDR_VAR 0 6
74907: PUSH
74908: LD_VAR 0 7
74912: PUSH
74913: LD_VAR 0 5
74917: PUSH
74918: LD_INT 1
74920: MINUS
74921: ARRAY
74922: PPUSH
74923: LD_VAR 0 2
74927: PUSH
74928: LD_VAR 0 5
74932: PUSH
74933: LD_INT 1
74935: MINUS
74936: ARRAY
74937: PPUSH
74938: LD_VAR 0 7
74942: PUSH
74943: LD_VAR 0 5
74947: ARRAY
74948: PPUSH
74949: CALL_OW 1
74953: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74954: LD_ADDR_VAR 0 7
74958: PUSH
74959: LD_VAR 0 7
74963: PPUSH
74964: LD_VAR 0 5
74968: PUSH
74969: LD_INT 1
74971: MINUS
74972: PPUSH
74973: LD_VAR 0 6
74977: PPUSH
74978: CALL_OW 1
74982: ST_TO_ADDR
// end ;
74983: GO 74900
74985: POP
74986: POP
// result := s_arr [ 1 ] ;
74987: LD_ADDR_VAR 0 4
74991: PUSH
74992: LD_VAR 0 7
74996: PUSH
74997: LD_INT 1
74999: ARRAY
75000: ST_TO_ADDR
// end ; end ;
75001: LD_VAR 0 4
75005: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75006: LD_INT 0
75008: PPUSH
75009: PPUSH
// if not list then
75010: LD_VAR 0 1
75014: NOT
75015: IFFALSE 75019
// exit ;
75017: GO 75110
// i := list [ pos1 ] ;
75019: LD_ADDR_VAR 0 5
75023: PUSH
75024: LD_VAR 0 1
75028: PUSH
75029: LD_VAR 0 2
75033: ARRAY
75034: ST_TO_ADDR
// if not i then
75035: LD_VAR 0 5
75039: NOT
75040: IFFALSE 75044
// exit ;
75042: GO 75110
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75044: LD_ADDR_VAR 0 1
75048: PUSH
75049: LD_VAR 0 1
75053: PPUSH
75054: LD_VAR 0 2
75058: PPUSH
75059: LD_VAR 0 1
75063: PUSH
75064: LD_VAR 0 3
75068: ARRAY
75069: PPUSH
75070: CALL_OW 1
75074: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75075: LD_ADDR_VAR 0 1
75079: PUSH
75080: LD_VAR 0 1
75084: PPUSH
75085: LD_VAR 0 3
75089: PPUSH
75090: LD_VAR 0 5
75094: PPUSH
75095: CALL_OW 1
75099: ST_TO_ADDR
// result := list ;
75100: LD_ADDR_VAR 0 4
75104: PUSH
75105: LD_VAR 0 1
75109: ST_TO_ADDR
// end ;
75110: LD_VAR 0 4
75114: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75115: LD_INT 0
75117: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75118: LD_ADDR_VAR 0 5
75122: PUSH
75123: LD_VAR 0 1
75127: PPUSH
75128: CALL_OW 250
75132: PPUSH
75133: LD_VAR 0 1
75137: PPUSH
75138: CALL_OW 251
75142: PPUSH
75143: LD_VAR 0 2
75147: PPUSH
75148: LD_VAR 0 3
75152: PPUSH
75153: LD_VAR 0 4
75157: PPUSH
75158: CALL 75536 0 5
75162: ST_TO_ADDR
// end ;
75163: LD_VAR 0 5
75167: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75168: LD_INT 0
75170: PPUSH
75171: PPUSH
75172: PPUSH
75173: PPUSH
// if not list or not unit then
75174: LD_VAR 0 2
75178: NOT
75179: PUSH
75180: LD_VAR 0 1
75184: NOT
75185: OR
75186: IFFALSE 75190
// exit ;
75188: GO 75531
// result := [ ] ;
75190: LD_ADDR_VAR 0 5
75194: PUSH
75195: EMPTY
75196: ST_TO_ADDR
// for i in list do
75197: LD_ADDR_VAR 0 6
75201: PUSH
75202: LD_VAR 0 2
75206: PUSH
75207: FOR_IN
75208: IFFALSE 75426
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75210: LD_ADDR_VAR 0 8
75214: PUSH
75215: LD_VAR 0 1
75219: PPUSH
75220: LD_VAR 0 6
75224: PUSH
75225: LD_INT 1
75227: ARRAY
75228: PPUSH
75229: LD_VAR 0 6
75233: PUSH
75234: LD_INT 2
75236: ARRAY
75237: PPUSH
75238: CALL_OW 297
75242: ST_TO_ADDR
// if not Count ( result ) then
75243: LD_VAR 0 5
75247: PPUSH
75248: CALL 71820 0 1
75252: NOT
75253: IFFALSE 75286
// begin result := Join ( result , [ i , tmp ] ) ;
75255: LD_ADDR_VAR 0 5
75259: PUSH
75260: LD_VAR 0 5
75264: PPUSH
75265: LD_VAR 0 6
75269: PUSH
75270: LD_VAR 0 8
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PPUSH
75279: CALL 107409 0 2
75283: ST_TO_ADDR
// continue ;
75284: GO 75207
// end ; if result [ result ] [ 2 ] <= tmp then
75286: LD_VAR 0 5
75290: PUSH
75291: LD_VAR 0 5
75295: ARRAY
75296: PUSH
75297: LD_INT 2
75299: ARRAY
75300: PUSH
75301: LD_VAR 0 8
75305: LESSEQUAL
75306: IFFALSE 75339
// result := Join ( result , [ i , tmp ] ) else
75308: LD_ADDR_VAR 0 5
75312: PUSH
75313: LD_VAR 0 5
75317: PPUSH
75318: LD_VAR 0 6
75322: PUSH
75323: LD_VAR 0 8
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PPUSH
75332: CALL 107409 0 2
75336: ST_TO_ADDR
75337: GO 75424
// begin for j := 1 to Count ( result ) do
75339: LD_ADDR_VAR 0 7
75343: PUSH
75344: DOUBLE
75345: LD_INT 1
75347: DEC
75348: ST_TO_ADDR
75349: LD_VAR 0 5
75353: PPUSH
75354: CALL 71820 0 1
75358: PUSH
75359: FOR_TO
75360: IFFALSE 75422
// begin if tmp < result [ j ] [ 2 ] then
75362: LD_VAR 0 8
75366: PUSH
75367: LD_VAR 0 5
75371: PUSH
75372: LD_VAR 0 7
75376: ARRAY
75377: PUSH
75378: LD_INT 2
75380: ARRAY
75381: LESS
75382: IFFALSE 75420
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75384: LD_ADDR_VAR 0 5
75388: PUSH
75389: LD_VAR 0 5
75393: PPUSH
75394: LD_VAR 0 7
75398: PPUSH
75399: LD_VAR 0 6
75403: PUSH
75404: LD_VAR 0 8
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PPUSH
75413: CALL_OW 2
75417: ST_TO_ADDR
// break ;
75418: GO 75422
// end ; end ;
75420: GO 75359
75422: POP
75423: POP
// end ; end ;
75424: GO 75207
75426: POP
75427: POP
// if result and not asc then
75428: LD_VAR 0 5
75432: PUSH
75433: LD_VAR 0 3
75437: NOT
75438: AND
75439: IFFALSE 75456
// result := ReverseArray ( result ) ;
75441: LD_ADDR_VAR 0 5
75445: PUSH
75446: LD_VAR 0 5
75450: PPUSH
75451: CALL 102696 0 1
75455: ST_TO_ADDR
// tmp := [ ] ;
75456: LD_ADDR_VAR 0 8
75460: PUSH
75461: EMPTY
75462: ST_TO_ADDR
// if mode then
75463: LD_VAR 0 4
75467: IFFALSE 75531
// begin for i := 1 to result do
75469: LD_ADDR_VAR 0 6
75473: PUSH
75474: DOUBLE
75475: LD_INT 1
75477: DEC
75478: ST_TO_ADDR
75479: LD_VAR 0 5
75483: PUSH
75484: FOR_TO
75485: IFFALSE 75519
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75487: LD_ADDR_VAR 0 8
75491: PUSH
75492: LD_VAR 0 8
75496: PPUSH
75497: LD_VAR 0 5
75501: PUSH
75502: LD_VAR 0 6
75506: ARRAY
75507: PUSH
75508: LD_INT 1
75510: ARRAY
75511: PPUSH
75512: CALL 107409 0 2
75516: ST_TO_ADDR
75517: GO 75484
75519: POP
75520: POP
// result := tmp ;
75521: LD_ADDR_VAR 0 5
75525: PUSH
75526: LD_VAR 0 8
75530: ST_TO_ADDR
// end ; end ;
75531: LD_VAR 0 5
75535: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75536: LD_INT 0
75538: PPUSH
75539: PPUSH
75540: PPUSH
75541: PPUSH
// if not list then
75542: LD_VAR 0 3
75546: NOT
75547: IFFALSE 75551
// exit ;
75549: GO 75939
// result := [ ] ;
75551: LD_ADDR_VAR 0 6
75555: PUSH
75556: EMPTY
75557: ST_TO_ADDR
// for i in list do
75558: LD_ADDR_VAR 0 7
75562: PUSH
75563: LD_VAR 0 3
75567: PUSH
75568: FOR_IN
75569: IFFALSE 75771
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75571: LD_ADDR_VAR 0 9
75575: PUSH
75576: LD_VAR 0 7
75580: PPUSH
75581: LD_VAR 0 1
75585: PPUSH
75586: LD_VAR 0 2
75590: PPUSH
75591: CALL_OW 297
75595: ST_TO_ADDR
// if not result then
75596: LD_VAR 0 6
75600: NOT
75601: IFFALSE 75627
// result := [ [ i , tmp ] ] else
75603: LD_ADDR_VAR 0 6
75607: PUSH
75608: LD_VAR 0 7
75612: PUSH
75613: LD_VAR 0 9
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: EMPTY
75623: LIST
75624: ST_TO_ADDR
75625: GO 75769
// begin if result [ result ] [ 2 ] < tmp then
75627: LD_VAR 0 6
75631: PUSH
75632: LD_VAR 0 6
75636: ARRAY
75637: PUSH
75638: LD_INT 2
75640: ARRAY
75641: PUSH
75642: LD_VAR 0 9
75646: LESS
75647: IFFALSE 75689
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75649: LD_ADDR_VAR 0 6
75653: PUSH
75654: LD_VAR 0 6
75658: PPUSH
75659: LD_VAR 0 6
75663: PUSH
75664: LD_INT 1
75666: PLUS
75667: PPUSH
75668: LD_VAR 0 7
75672: PUSH
75673: LD_VAR 0 9
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PPUSH
75682: CALL_OW 2
75686: ST_TO_ADDR
75687: GO 75769
// for j = 1 to result do
75689: LD_ADDR_VAR 0 8
75693: PUSH
75694: DOUBLE
75695: LD_INT 1
75697: DEC
75698: ST_TO_ADDR
75699: LD_VAR 0 6
75703: PUSH
75704: FOR_TO
75705: IFFALSE 75767
// begin if tmp < result [ j ] [ 2 ] then
75707: LD_VAR 0 9
75711: PUSH
75712: LD_VAR 0 6
75716: PUSH
75717: LD_VAR 0 8
75721: ARRAY
75722: PUSH
75723: LD_INT 2
75725: ARRAY
75726: LESS
75727: IFFALSE 75765
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75729: LD_ADDR_VAR 0 6
75733: PUSH
75734: LD_VAR 0 6
75738: PPUSH
75739: LD_VAR 0 8
75743: PPUSH
75744: LD_VAR 0 7
75748: PUSH
75749: LD_VAR 0 9
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PPUSH
75758: CALL_OW 2
75762: ST_TO_ADDR
// break ;
75763: GO 75767
// end ; end ;
75765: GO 75704
75767: POP
75768: POP
// end ; end ;
75769: GO 75568
75771: POP
75772: POP
// if result and not asc then
75773: LD_VAR 0 6
75777: PUSH
75778: LD_VAR 0 4
75782: NOT
75783: AND
75784: IFFALSE 75859
// begin tmp := result ;
75786: LD_ADDR_VAR 0 9
75790: PUSH
75791: LD_VAR 0 6
75795: ST_TO_ADDR
// for i = tmp downto 1 do
75796: LD_ADDR_VAR 0 7
75800: PUSH
75801: DOUBLE
75802: LD_VAR 0 9
75806: INC
75807: ST_TO_ADDR
75808: LD_INT 1
75810: PUSH
75811: FOR_DOWNTO
75812: IFFALSE 75857
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75814: LD_ADDR_VAR 0 6
75818: PUSH
75819: LD_VAR 0 6
75823: PPUSH
75824: LD_VAR 0 9
75828: PUSH
75829: LD_VAR 0 7
75833: MINUS
75834: PUSH
75835: LD_INT 1
75837: PLUS
75838: PPUSH
75839: LD_VAR 0 9
75843: PUSH
75844: LD_VAR 0 7
75848: ARRAY
75849: PPUSH
75850: CALL_OW 1
75854: ST_TO_ADDR
75855: GO 75811
75857: POP
75858: POP
// end ; tmp := [ ] ;
75859: LD_ADDR_VAR 0 9
75863: PUSH
75864: EMPTY
75865: ST_TO_ADDR
// if mode then
75866: LD_VAR 0 5
75870: IFFALSE 75939
// begin for i = 1 to result do
75872: LD_ADDR_VAR 0 7
75876: PUSH
75877: DOUBLE
75878: LD_INT 1
75880: DEC
75881: ST_TO_ADDR
75882: LD_VAR 0 6
75886: PUSH
75887: FOR_TO
75888: IFFALSE 75927
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75890: LD_ADDR_VAR 0 9
75894: PUSH
75895: LD_VAR 0 9
75899: PPUSH
75900: LD_VAR 0 7
75904: PPUSH
75905: LD_VAR 0 6
75909: PUSH
75910: LD_VAR 0 7
75914: ARRAY
75915: PUSH
75916: LD_INT 1
75918: ARRAY
75919: PPUSH
75920: CALL_OW 1
75924: ST_TO_ADDR
75925: GO 75887
75927: POP
75928: POP
// result := tmp ;
75929: LD_ADDR_VAR 0 6
75933: PUSH
75934: LD_VAR 0 9
75938: ST_TO_ADDR
// end ; end ;
75939: LD_VAR 0 6
75943: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75944: LD_INT 0
75946: PPUSH
75947: PPUSH
75948: PPUSH
75949: PPUSH
75950: PPUSH
75951: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75952: LD_ADDR_VAR 0 5
75956: PUSH
75957: LD_INT 0
75959: PUSH
75960: LD_INT 0
75962: PUSH
75963: LD_INT 0
75965: PUSH
75966: EMPTY
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: ST_TO_ADDR
// if not x or not y then
75974: LD_VAR 0 2
75978: NOT
75979: PUSH
75980: LD_VAR 0 3
75984: NOT
75985: OR
75986: IFFALSE 75990
// exit ;
75988: GO 77640
// if not range then
75990: LD_VAR 0 4
75994: NOT
75995: IFFALSE 76005
// range := 10 ;
75997: LD_ADDR_VAR 0 4
76001: PUSH
76002: LD_INT 10
76004: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76005: LD_ADDR_VAR 0 8
76009: PUSH
76010: LD_INT 81
76012: PUSH
76013: LD_VAR 0 1
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 92
76024: PUSH
76025: LD_VAR 0 2
76029: PUSH
76030: LD_VAR 0 3
76034: PUSH
76035: LD_VAR 0 4
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 3
76048: PUSH
76049: LD_INT 21
76051: PUSH
76052: LD_INT 3
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: LIST
76067: PPUSH
76068: CALL_OW 69
76072: ST_TO_ADDR
// if not tmp then
76073: LD_VAR 0 8
76077: NOT
76078: IFFALSE 76082
// exit ;
76080: GO 77640
// for i in tmp do
76082: LD_ADDR_VAR 0 6
76086: PUSH
76087: LD_VAR 0 8
76091: PUSH
76092: FOR_IN
76093: IFFALSE 77615
// begin points := [ 0 , 0 , 0 ] ;
76095: LD_ADDR_VAR 0 9
76099: PUSH
76100: LD_INT 0
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: LIST
76113: ST_TO_ADDR
// bpoints := 1 ;
76114: LD_ADDR_VAR 0 10
76118: PUSH
76119: LD_INT 1
76121: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76122: LD_VAR 0 6
76126: PPUSH
76127: CALL_OW 247
76131: PUSH
76132: LD_INT 1
76134: DOUBLE
76135: EQUAL
76136: IFTRUE 76140
76138: GO 76718
76140: POP
// begin if GetClass ( i ) = 1 then
76141: LD_VAR 0 6
76145: PPUSH
76146: CALL_OW 257
76150: PUSH
76151: LD_INT 1
76153: EQUAL
76154: IFFALSE 76175
// points := [ 10 , 5 , 3 ] ;
76156: LD_ADDR_VAR 0 9
76160: PUSH
76161: LD_INT 10
76163: PUSH
76164: LD_INT 5
76166: PUSH
76167: LD_INT 3
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: LIST
76174: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76175: LD_VAR 0 6
76179: PPUSH
76180: CALL_OW 257
76184: PUSH
76185: LD_INT 2
76187: PUSH
76188: LD_INT 3
76190: PUSH
76191: LD_INT 4
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: LIST
76198: IN
76199: IFFALSE 76220
// points := [ 3 , 2 , 1 ] ;
76201: LD_ADDR_VAR 0 9
76205: PUSH
76206: LD_INT 3
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: LD_INT 1
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: LIST
76219: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76220: LD_VAR 0 6
76224: PPUSH
76225: CALL_OW 257
76229: PUSH
76230: LD_INT 5
76232: EQUAL
76233: IFFALSE 76254
// points := [ 130 , 5 , 2 ] ;
76235: LD_ADDR_VAR 0 9
76239: PUSH
76240: LD_INT 130
76242: PUSH
76243: LD_INT 5
76245: PUSH
76246: LD_INT 2
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: LIST
76253: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76254: LD_VAR 0 6
76258: PPUSH
76259: CALL_OW 257
76263: PUSH
76264: LD_INT 8
76266: EQUAL
76267: IFFALSE 76288
// points := [ 35 , 35 , 30 ] ;
76269: LD_ADDR_VAR 0 9
76273: PUSH
76274: LD_INT 35
76276: PUSH
76277: LD_INT 35
76279: PUSH
76280: LD_INT 30
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76288: LD_VAR 0 6
76292: PPUSH
76293: CALL_OW 257
76297: PUSH
76298: LD_INT 9
76300: EQUAL
76301: IFFALSE 76322
// points := [ 20 , 55 , 40 ] ;
76303: LD_ADDR_VAR 0 9
76307: PUSH
76308: LD_INT 20
76310: PUSH
76311: LD_INT 55
76313: PUSH
76314: LD_INT 40
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: LIST
76321: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76322: LD_VAR 0 6
76326: PPUSH
76327: CALL_OW 257
76331: PUSH
76332: LD_INT 12
76334: PUSH
76335: LD_INT 16
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: IN
76342: IFFALSE 76363
// points := [ 5 , 3 , 2 ] ;
76344: LD_ADDR_VAR 0 9
76348: PUSH
76349: LD_INT 5
76351: PUSH
76352: LD_INT 3
76354: PUSH
76355: LD_INT 2
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: LIST
76362: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76363: LD_VAR 0 6
76367: PPUSH
76368: CALL_OW 257
76372: PUSH
76373: LD_INT 17
76375: EQUAL
76376: IFFALSE 76397
// points := [ 100 , 50 , 75 ] ;
76378: LD_ADDR_VAR 0 9
76382: PUSH
76383: LD_INT 100
76385: PUSH
76386: LD_INT 50
76388: PUSH
76389: LD_INT 75
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: LIST
76396: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76397: LD_VAR 0 6
76401: PPUSH
76402: CALL_OW 257
76406: PUSH
76407: LD_INT 15
76409: EQUAL
76410: IFFALSE 76431
// points := [ 10 , 5 , 3 ] ;
76412: LD_ADDR_VAR 0 9
76416: PUSH
76417: LD_INT 10
76419: PUSH
76420: LD_INT 5
76422: PUSH
76423: LD_INT 3
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: LIST
76430: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76431: LD_VAR 0 6
76435: PPUSH
76436: CALL_OW 257
76440: PUSH
76441: LD_INT 14
76443: EQUAL
76444: IFFALSE 76465
// points := [ 10 , 0 , 0 ] ;
76446: LD_ADDR_VAR 0 9
76450: PUSH
76451: LD_INT 10
76453: PUSH
76454: LD_INT 0
76456: PUSH
76457: LD_INT 0
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: LIST
76464: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76465: LD_VAR 0 6
76469: PPUSH
76470: CALL_OW 257
76474: PUSH
76475: LD_INT 11
76477: EQUAL
76478: IFFALSE 76499
// points := [ 30 , 10 , 5 ] ;
76480: LD_ADDR_VAR 0 9
76484: PUSH
76485: LD_INT 30
76487: PUSH
76488: LD_INT 10
76490: PUSH
76491: LD_INT 5
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: LIST
76498: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76499: LD_VAR 0 1
76503: PPUSH
76504: LD_INT 5
76506: PPUSH
76507: CALL_OW 321
76511: PUSH
76512: LD_INT 2
76514: EQUAL
76515: IFFALSE 76532
// bpoints := bpoints * 1.8 ;
76517: LD_ADDR_VAR 0 10
76521: PUSH
76522: LD_VAR 0 10
76526: PUSH
76527: LD_REAL  1.80000000000000E+0000
76530: MUL
76531: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76532: LD_VAR 0 6
76536: PPUSH
76537: CALL_OW 257
76541: PUSH
76542: LD_INT 1
76544: PUSH
76545: LD_INT 2
76547: PUSH
76548: LD_INT 3
76550: PUSH
76551: LD_INT 4
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: IN
76560: PUSH
76561: LD_VAR 0 1
76565: PPUSH
76566: LD_INT 51
76568: PPUSH
76569: CALL_OW 321
76573: PUSH
76574: LD_INT 2
76576: EQUAL
76577: AND
76578: IFFALSE 76595
// bpoints := bpoints * 1.2 ;
76580: LD_ADDR_VAR 0 10
76584: PUSH
76585: LD_VAR 0 10
76589: PUSH
76590: LD_REAL  1.20000000000000E+0000
76593: MUL
76594: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76595: LD_VAR 0 6
76599: PPUSH
76600: CALL_OW 257
76604: PUSH
76605: LD_INT 5
76607: PUSH
76608: LD_INT 7
76610: PUSH
76611: LD_INT 9
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: LIST
76618: IN
76619: PUSH
76620: LD_VAR 0 1
76624: PPUSH
76625: LD_INT 52
76627: PPUSH
76628: CALL_OW 321
76632: PUSH
76633: LD_INT 2
76635: EQUAL
76636: AND
76637: IFFALSE 76654
// bpoints := bpoints * 1.5 ;
76639: LD_ADDR_VAR 0 10
76643: PUSH
76644: LD_VAR 0 10
76648: PUSH
76649: LD_REAL  1.50000000000000E+0000
76652: MUL
76653: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76654: LD_VAR 0 1
76658: PPUSH
76659: LD_INT 66
76661: PPUSH
76662: CALL_OW 321
76666: PUSH
76667: LD_INT 2
76669: EQUAL
76670: IFFALSE 76687
// bpoints := bpoints * 1.1 ;
76672: LD_ADDR_VAR 0 10
76676: PUSH
76677: LD_VAR 0 10
76681: PUSH
76682: LD_REAL  1.10000000000000E+0000
76685: MUL
76686: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76687: LD_ADDR_VAR 0 10
76691: PUSH
76692: LD_VAR 0 10
76696: PUSH
76697: LD_VAR 0 6
76701: PPUSH
76702: LD_INT 1
76704: PPUSH
76705: CALL_OW 259
76709: PUSH
76710: LD_REAL  1.15000000000000E+0000
76713: MUL
76714: MUL
76715: ST_TO_ADDR
// end ; unit_vehicle :
76716: GO 77544
76718: LD_INT 2
76720: DOUBLE
76721: EQUAL
76722: IFTRUE 76726
76724: GO 77532
76726: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76727: LD_VAR 0 6
76731: PPUSH
76732: CALL_OW 264
76736: PUSH
76737: LD_INT 2
76739: PUSH
76740: LD_INT 42
76742: PUSH
76743: LD_INT 24
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: IN
76751: IFFALSE 76772
// points := [ 25 , 5 , 3 ] ;
76753: LD_ADDR_VAR 0 9
76757: PUSH
76758: LD_INT 25
76760: PUSH
76761: LD_INT 5
76763: PUSH
76764: LD_INT 3
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: LIST
76771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76772: LD_VAR 0 6
76776: PPUSH
76777: CALL_OW 264
76781: PUSH
76782: LD_INT 4
76784: PUSH
76785: LD_INT 43
76787: PUSH
76788: LD_INT 25
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: LIST
76795: IN
76796: IFFALSE 76817
// points := [ 40 , 15 , 5 ] ;
76798: LD_ADDR_VAR 0 9
76802: PUSH
76803: LD_INT 40
76805: PUSH
76806: LD_INT 15
76808: PUSH
76809: LD_INT 5
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: LIST
76816: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76817: LD_VAR 0 6
76821: PPUSH
76822: CALL_OW 264
76826: PUSH
76827: LD_INT 3
76829: PUSH
76830: LD_INT 23
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: IN
76837: IFFALSE 76858
// points := [ 7 , 25 , 8 ] ;
76839: LD_ADDR_VAR 0 9
76843: PUSH
76844: LD_INT 7
76846: PUSH
76847: LD_INT 25
76849: PUSH
76850: LD_INT 8
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: LIST
76857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76858: LD_VAR 0 6
76862: PPUSH
76863: CALL_OW 264
76867: PUSH
76868: LD_INT 5
76870: PUSH
76871: LD_INT 27
76873: PUSH
76874: LD_INT 44
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: LIST
76881: IN
76882: IFFALSE 76903
// points := [ 14 , 50 , 16 ] ;
76884: LD_ADDR_VAR 0 9
76888: PUSH
76889: LD_INT 14
76891: PUSH
76892: LD_INT 50
76894: PUSH
76895: LD_INT 16
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: LIST
76902: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76903: LD_VAR 0 6
76907: PPUSH
76908: CALL_OW 264
76912: PUSH
76913: LD_INT 6
76915: PUSH
76916: LD_INT 46
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: IN
76923: IFFALSE 76944
// points := [ 32 , 120 , 70 ] ;
76925: LD_ADDR_VAR 0 9
76929: PUSH
76930: LD_INT 32
76932: PUSH
76933: LD_INT 120
76935: PUSH
76936: LD_INT 70
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: LIST
76943: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76944: LD_VAR 0 6
76948: PPUSH
76949: CALL_OW 264
76953: PUSH
76954: LD_INT 7
76956: PUSH
76957: LD_INT 28
76959: PUSH
76960: LD_INT 45
76962: PUSH
76963: LD_INT 92
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: LIST
76970: LIST
76971: IN
76972: IFFALSE 76993
// points := [ 35 , 20 , 45 ] ;
76974: LD_ADDR_VAR 0 9
76978: PUSH
76979: LD_INT 35
76981: PUSH
76982: LD_INT 20
76984: PUSH
76985: LD_INT 45
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: LIST
76992: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76993: LD_VAR 0 6
76997: PPUSH
76998: CALL_OW 264
77002: PUSH
77003: LD_INT 47
77005: PUSH
77006: EMPTY
77007: LIST
77008: IN
77009: IFFALSE 77030
// points := [ 67 , 45 , 75 ] ;
77011: LD_ADDR_VAR 0 9
77015: PUSH
77016: LD_INT 67
77018: PUSH
77019: LD_INT 45
77021: PUSH
77022: LD_INT 75
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: LIST
77029: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77030: LD_VAR 0 6
77034: PPUSH
77035: CALL_OW 264
77039: PUSH
77040: LD_INT 26
77042: PUSH
77043: EMPTY
77044: LIST
77045: IN
77046: IFFALSE 77067
// points := [ 120 , 30 , 80 ] ;
77048: LD_ADDR_VAR 0 9
77052: PUSH
77053: LD_INT 120
77055: PUSH
77056: LD_INT 30
77058: PUSH
77059: LD_INT 80
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: LIST
77066: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77067: LD_VAR 0 6
77071: PPUSH
77072: CALL_OW 264
77076: PUSH
77077: LD_INT 22
77079: PUSH
77080: EMPTY
77081: LIST
77082: IN
77083: IFFALSE 77104
// points := [ 40 , 1 , 1 ] ;
77085: LD_ADDR_VAR 0 9
77089: PUSH
77090: LD_INT 40
77092: PUSH
77093: LD_INT 1
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: LIST
77103: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77104: LD_VAR 0 6
77108: PPUSH
77109: CALL_OW 264
77113: PUSH
77114: LD_INT 29
77116: PUSH
77117: EMPTY
77118: LIST
77119: IN
77120: IFFALSE 77141
// points := [ 70 , 200 , 400 ] ;
77122: LD_ADDR_VAR 0 9
77126: PUSH
77127: LD_INT 70
77129: PUSH
77130: LD_INT 200
77132: PUSH
77133: LD_INT 400
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: LIST
77140: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77141: LD_VAR 0 6
77145: PPUSH
77146: CALL_OW 264
77150: PUSH
77151: LD_INT 14
77153: PUSH
77154: LD_INT 53
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: IN
77161: IFFALSE 77182
// points := [ 40 , 10 , 20 ] ;
77163: LD_ADDR_VAR 0 9
77167: PUSH
77168: LD_INT 40
77170: PUSH
77171: LD_INT 10
77173: PUSH
77174: LD_INT 20
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: LIST
77181: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77182: LD_VAR 0 6
77186: PPUSH
77187: CALL_OW 264
77191: PUSH
77192: LD_INT 9
77194: PUSH
77195: EMPTY
77196: LIST
77197: IN
77198: IFFALSE 77219
// points := [ 5 , 70 , 20 ] ;
77200: LD_ADDR_VAR 0 9
77204: PUSH
77205: LD_INT 5
77207: PUSH
77208: LD_INT 70
77210: PUSH
77211: LD_INT 20
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: LIST
77218: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77219: LD_VAR 0 6
77223: PPUSH
77224: CALL_OW 264
77228: PUSH
77229: LD_INT 10
77231: PUSH
77232: EMPTY
77233: LIST
77234: IN
77235: IFFALSE 77256
// points := [ 35 , 110 , 70 ] ;
77237: LD_ADDR_VAR 0 9
77241: PUSH
77242: LD_INT 35
77244: PUSH
77245: LD_INT 110
77247: PUSH
77248: LD_INT 70
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: LIST
77255: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77256: LD_VAR 0 6
77260: PPUSH
77261: CALL_OW 265
77265: PUSH
77266: LD_INT 25
77268: EQUAL
77269: IFFALSE 77290
// points := [ 80 , 65 , 100 ] ;
77271: LD_ADDR_VAR 0 9
77275: PUSH
77276: LD_INT 80
77278: PUSH
77279: LD_INT 65
77281: PUSH
77282: LD_INT 100
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: LIST
77289: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77290: LD_VAR 0 6
77294: PPUSH
77295: CALL_OW 263
77299: PUSH
77300: LD_INT 1
77302: EQUAL
77303: IFFALSE 77338
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77305: LD_ADDR_VAR 0 10
77309: PUSH
77310: LD_VAR 0 10
77314: PUSH
77315: LD_VAR 0 6
77319: PPUSH
77320: CALL_OW 311
77324: PPUSH
77325: LD_INT 3
77327: PPUSH
77328: CALL_OW 259
77332: PUSH
77333: LD_INT 4
77335: MUL
77336: MUL
77337: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77338: LD_VAR 0 6
77342: PPUSH
77343: CALL_OW 263
77347: PUSH
77348: LD_INT 2
77350: EQUAL
77351: IFFALSE 77402
// begin j := IsControledBy ( i ) ;
77353: LD_ADDR_VAR 0 7
77357: PUSH
77358: LD_VAR 0 6
77362: PPUSH
77363: CALL_OW 312
77367: ST_TO_ADDR
// if j then
77368: LD_VAR 0 7
77372: IFFALSE 77402
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77374: LD_ADDR_VAR 0 10
77378: PUSH
77379: LD_VAR 0 10
77383: PUSH
77384: LD_VAR 0 7
77388: PPUSH
77389: LD_INT 3
77391: PPUSH
77392: CALL_OW 259
77396: PUSH
77397: LD_INT 3
77399: MUL
77400: MUL
77401: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77402: LD_VAR 0 6
77406: PPUSH
77407: CALL_OW 264
77411: PUSH
77412: LD_INT 5
77414: PUSH
77415: LD_INT 6
77417: PUSH
77418: LD_INT 46
77420: PUSH
77421: LD_INT 44
77423: PUSH
77424: LD_INT 47
77426: PUSH
77427: LD_INT 45
77429: PUSH
77430: LD_INT 28
77432: PUSH
77433: LD_INT 7
77435: PUSH
77436: LD_INT 27
77438: PUSH
77439: LD_INT 29
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: IN
77454: PUSH
77455: LD_VAR 0 1
77459: PPUSH
77460: LD_INT 52
77462: PPUSH
77463: CALL_OW 321
77467: PUSH
77468: LD_INT 2
77470: EQUAL
77471: AND
77472: IFFALSE 77489
// bpoints := bpoints * 1.2 ;
77474: LD_ADDR_VAR 0 10
77478: PUSH
77479: LD_VAR 0 10
77483: PUSH
77484: LD_REAL  1.20000000000000E+0000
77487: MUL
77488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77489: LD_VAR 0 6
77493: PPUSH
77494: CALL_OW 264
77498: PUSH
77499: LD_INT 6
77501: PUSH
77502: LD_INT 46
77504: PUSH
77505: LD_INT 47
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: LIST
77512: IN
77513: IFFALSE 77530
// bpoints := bpoints * 1.2 ;
77515: LD_ADDR_VAR 0 10
77519: PUSH
77520: LD_VAR 0 10
77524: PUSH
77525: LD_REAL  1.20000000000000E+0000
77528: MUL
77529: ST_TO_ADDR
// end ; unit_building :
77530: GO 77544
77532: LD_INT 3
77534: DOUBLE
77535: EQUAL
77536: IFTRUE 77540
77538: GO 77543
77540: POP
// ; end ;
77541: GO 77544
77543: POP
// for j = 1 to 3 do
77544: LD_ADDR_VAR 0 7
77548: PUSH
77549: DOUBLE
77550: LD_INT 1
77552: DEC
77553: ST_TO_ADDR
77554: LD_INT 3
77556: PUSH
77557: FOR_TO
77558: IFFALSE 77611
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77560: LD_ADDR_VAR 0 5
77564: PUSH
77565: LD_VAR 0 5
77569: PPUSH
77570: LD_VAR 0 7
77574: PPUSH
77575: LD_VAR 0 5
77579: PUSH
77580: LD_VAR 0 7
77584: ARRAY
77585: PUSH
77586: LD_VAR 0 9
77590: PUSH
77591: LD_VAR 0 7
77595: ARRAY
77596: PUSH
77597: LD_VAR 0 10
77601: MUL
77602: PLUS
77603: PPUSH
77604: CALL_OW 1
77608: ST_TO_ADDR
77609: GO 77557
77611: POP
77612: POP
// end ;
77613: GO 76092
77615: POP
77616: POP
// result := Replace ( result , 4 , tmp ) ;
77617: LD_ADDR_VAR 0 5
77621: PUSH
77622: LD_VAR 0 5
77626: PPUSH
77627: LD_INT 4
77629: PPUSH
77630: LD_VAR 0 8
77634: PPUSH
77635: CALL_OW 1
77639: ST_TO_ADDR
// end ;
77640: LD_VAR 0 5
77644: RET
// export function DangerAtRange ( unit , range ) ; begin
77645: LD_INT 0
77647: PPUSH
// if not unit then
77648: LD_VAR 0 1
77652: NOT
77653: IFFALSE 77657
// exit ;
77655: GO 77702
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77657: LD_ADDR_VAR 0 3
77661: PUSH
77662: LD_VAR 0 1
77666: PPUSH
77667: CALL_OW 255
77671: PPUSH
77672: LD_VAR 0 1
77676: PPUSH
77677: CALL_OW 250
77681: PPUSH
77682: LD_VAR 0 1
77686: PPUSH
77687: CALL_OW 251
77691: PPUSH
77692: LD_VAR 0 2
77696: PPUSH
77697: CALL 75944 0 4
77701: ST_TO_ADDR
// end ;
77702: LD_VAR 0 3
77706: RET
// export function DangerInArea ( side , area ) ; begin
77707: LD_INT 0
77709: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77710: LD_ADDR_VAR 0 3
77714: PUSH
77715: LD_VAR 0 2
77719: PPUSH
77720: LD_INT 81
77722: PUSH
77723: LD_VAR 0 1
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PPUSH
77732: CALL_OW 70
77736: ST_TO_ADDR
// end ;
77737: LD_VAR 0 3
77741: RET
// export function IsExtension ( b ) ; begin
77742: LD_INT 0
77744: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77745: LD_ADDR_VAR 0 2
77749: PUSH
77750: LD_VAR 0 1
77754: PUSH
77755: LD_INT 23
77757: PUSH
77758: LD_INT 20
77760: PUSH
77761: LD_INT 22
77763: PUSH
77764: LD_INT 17
77766: PUSH
77767: LD_INT 24
77769: PUSH
77770: LD_INT 21
77772: PUSH
77773: LD_INT 19
77775: PUSH
77776: LD_INT 16
77778: PUSH
77779: LD_INT 25
77781: PUSH
77782: LD_INT 18
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: LIST
77789: LIST
77790: LIST
77791: LIST
77792: LIST
77793: LIST
77794: LIST
77795: LIST
77796: IN
77797: ST_TO_ADDR
// end ;
77798: LD_VAR 0 2
77802: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77803: LD_INT 0
77805: PPUSH
77806: PPUSH
77807: PPUSH
// result := [ ] ;
77808: LD_ADDR_VAR 0 4
77812: PUSH
77813: EMPTY
77814: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77815: LD_ADDR_VAR 0 5
77819: PUSH
77820: LD_VAR 0 2
77824: PPUSH
77825: LD_INT 21
77827: PUSH
77828: LD_INT 3
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PPUSH
77835: CALL_OW 70
77839: ST_TO_ADDR
// if not tmp then
77840: LD_VAR 0 5
77844: NOT
77845: IFFALSE 77849
// exit ;
77847: GO 77913
// if checkLink then
77849: LD_VAR 0 3
77853: IFFALSE 77903
// begin for i in tmp do
77855: LD_ADDR_VAR 0 6
77859: PUSH
77860: LD_VAR 0 5
77864: PUSH
77865: FOR_IN
77866: IFFALSE 77901
// if GetBase ( i ) <> base then
77868: LD_VAR 0 6
77872: PPUSH
77873: CALL_OW 274
77877: PUSH
77878: LD_VAR 0 1
77882: NONEQUAL
77883: IFFALSE 77899
// ComLinkToBase ( base , i ) ;
77885: LD_VAR 0 1
77889: PPUSH
77890: LD_VAR 0 6
77894: PPUSH
77895: CALL_OW 169
77899: GO 77865
77901: POP
77902: POP
// end ; result := tmp ;
77903: LD_ADDR_VAR 0 4
77907: PUSH
77908: LD_VAR 0 5
77912: ST_TO_ADDR
// end ;
77913: LD_VAR 0 4
77917: RET
// export function ComComplete ( units , b ) ; var i ; begin
77918: LD_INT 0
77920: PPUSH
77921: PPUSH
// if not units then
77922: LD_VAR 0 1
77926: NOT
77927: IFFALSE 77931
// exit ;
77929: GO 78021
// for i in units do
77931: LD_ADDR_VAR 0 4
77935: PUSH
77936: LD_VAR 0 1
77940: PUSH
77941: FOR_IN
77942: IFFALSE 78019
// if BuildingStatus ( b ) = bs_build then
77944: LD_VAR 0 2
77948: PPUSH
77949: CALL_OW 461
77953: PUSH
77954: LD_INT 1
77956: EQUAL
77957: IFFALSE 78017
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77959: LD_VAR 0 4
77963: PPUSH
77964: LD_STRING h
77966: PUSH
77967: LD_VAR 0 2
77971: PPUSH
77972: CALL_OW 250
77976: PUSH
77977: LD_VAR 0 2
77981: PPUSH
77982: CALL_OW 251
77986: PUSH
77987: LD_VAR 0 2
77991: PUSH
77992: LD_INT 0
77994: PUSH
77995: LD_INT 0
77997: PUSH
77998: LD_INT 0
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: PUSH
78010: EMPTY
78011: LIST
78012: PPUSH
78013: CALL_OW 446
78017: GO 77941
78019: POP
78020: POP
// end ;
78021: LD_VAR 0 3
78025: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78026: LD_INT 0
78028: PPUSH
78029: PPUSH
78030: PPUSH
78031: PPUSH
78032: PPUSH
78033: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78034: LD_VAR 0 1
78038: NOT
78039: PUSH
78040: LD_VAR 0 1
78044: PPUSH
78045: CALL_OW 263
78049: PUSH
78050: LD_INT 2
78052: NONEQUAL
78053: OR
78054: IFFALSE 78058
// exit ;
78056: GO 78374
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78058: LD_ADDR_VAR 0 6
78062: PUSH
78063: LD_INT 22
78065: PUSH
78066: LD_VAR 0 1
78070: PPUSH
78071: CALL_OW 255
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 2
78082: PUSH
78083: LD_INT 30
78085: PUSH
78086: LD_INT 36
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PUSH
78093: LD_INT 34
78095: PUSH
78096: LD_INT 31
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: LIST
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PPUSH
78112: CALL_OW 69
78116: ST_TO_ADDR
// if not tmp then
78117: LD_VAR 0 6
78121: NOT
78122: IFFALSE 78126
// exit ;
78124: GO 78374
// result := [ ] ;
78126: LD_ADDR_VAR 0 2
78130: PUSH
78131: EMPTY
78132: ST_TO_ADDR
// for i in tmp do
78133: LD_ADDR_VAR 0 3
78137: PUSH
78138: LD_VAR 0 6
78142: PUSH
78143: FOR_IN
78144: IFFALSE 78215
// begin t := UnitsInside ( i ) ;
78146: LD_ADDR_VAR 0 4
78150: PUSH
78151: LD_VAR 0 3
78155: PPUSH
78156: CALL_OW 313
78160: ST_TO_ADDR
// if t then
78161: LD_VAR 0 4
78165: IFFALSE 78213
// for j in t do
78167: LD_ADDR_VAR 0 7
78171: PUSH
78172: LD_VAR 0 4
78176: PUSH
78177: FOR_IN
78178: IFFALSE 78211
// result := Replace ( result , result + 1 , j ) ;
78180: LD_ADDR_VAR 0 2
78184: PUSH
78185: LD_VAR 0 2
78189: PPUSH
78190: LD_VAR 0 2
78194: PUSH
78195: LD_INT 1
78197: PLUS
78198: PPUSH
78199: LD_VAR 0 7
78203: PPUSH
78204: CALL_OW 1
78208: ST_TO_ADDR
78209: GO 78177
78211: POP
78212: POP
// end ;
78213: GO 78143
78215: POP
78216: POP
// if not result then
78217: LD_VAR 0 2
78221: NOT
78222: IFFALSE 78226
// exit ;
78224: GO 78374
// mech := result [ 1 ] ;
78226: LD_ADDR_VAR 0 5
78230: PUSH
78231: LD_VAR 0 2
78235: PUSH
78236: LD_INT 1
78238: ARRAY
78239: ST_TO_ADDR
// if result > 1 then
78240: LD_VAR 0 2
78244: PUSH
78245: LD_INT 1
78247: GREATER
78248: IFFALSE 78360
// begin for i = 2 to result do
78250: LD_ADDR_VAR 0 3
78254: PUSH
78255: DOUBLE
78256: LD_INT 2
78258: DEC
78259: ST_TO_ADDR
78260: LD_VAR 0 2
78264: PUSH
78265: FOR_TO
78266: IFFALSE 78358
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78268: LD_ADDR_VAR 0 4
78272: PUSH
78273: LD_VAR 0 2
78277: PUSH
78278: LD_VAR 0 3
78282: ARRAY
78283: PPUSH
78284: LD_INT 3
78286: PPUSH
78287: CALL_OW 259
78291: PUSH
78292: LD_VAR 0 2
78296: PUSH
78297: LD_VAR 0 3
78301: ARRAY
78302: PPUSH
78303: CALL_OW 432
78307: MINUS
78308: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78309: LD_VAR 0 4
78313: PUSH
78314: LD_VAR 0 5
78318: PPUSH
78319: LD_INT 3
78321: PPUSH
78322: CALL_OW 259
78326: PUSH
78327: LD_VAR 0 5
78331: PPUSH
78332: CALL_OW 432
78336: MINUS
78337: GREATEREQUAL
78338: IFFALSE 78356
// mech := result [ i ] ;
78340: LD_ADDR_VAR 0 5
78344: PUSH
78345: LD_VAR 0 2
78349: PUSH
78350: LD_VAR 0 3
78354: ARRAY
78355: ST_TO_ADDR
// end ;
78356: GO 78265
78358: POP
78359: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78360: LD_VAR 0 1
78364: PPUSH
78365: LD_VAR 0 5
78369: PPUSH
78370: CALL_OW 135
// end ;
78374: LD_VAR 0 2
78378: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78379: LD_INT 0
78381: PPUSH
78382: PPUSH
78383: PPUSH
78384: PPUSH
78385: PPUSH
78386: PPUSH
78387: PPUSH
78388: PPUSH
78389: PPUSH
78390: PPUSH
78391: PPUSH
78392: PPUSH
78393: PPUSH
// result := [ ] ;
78394: LD_ADDR_VAR 0 7
78398: PUSH
78399: EMPTY
78400: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78401: LD_VAR 0 1
78405: PPUSH
78406: CALL_OW 266
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: IN
78421: NOT
78422: IFFALSE 78426
// exit ;
78424: GO 80060
// if name then
78426: LD_VAR 0 3
78430: IFFALSE 78446
// SetBName ( base_dep , name ) ;
78432: LD_VAR 0 1
78436: PPUSH
78437: LD_VAR 0 3
78441: PPUSH
78442: CALL_OW 500
// base := GetBase ( base_dep ) ;
78446: LD_ADDR_VAR 0 15
78450: PUSH
78451: LD_VAR 0 1
78455: PPUSH
78456: CALL_OW 274
78460: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78461: LD_ADDR_VAR 0 16
78465: PUSH
78466: LD_VAR 0 1
78470: PPUSH
78471: CALL_OW 255
78475: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78476: LD_ADDR_VAR 0 17
78480: PUSH
78481: LD_VAR 0 1
78485: PPUSH
78486: CALL_OW 248
78490: ST_TO_ADDR
// if sources then
78491: LD_VAR 0 5
78495: IFFALSE 78542
// for i = 1 to 3 do
78497: LD_ADDR_VAR 0 8
78501: PUSH
78502: DOUBLE
78503: LD_INT 1
78505: DEC
78506: ST_TO_ADDR
78507: LD_INT 3
78509: PUSH
78510: FOR_TO
78511: IFFALSE 78540
// AddResourceType ( base , i , sources [ i ] ) ;
78513: LD_VAR 0 15
78517: PPUSH
78518: LD_VAR 0 8
78522: PPUSH
78523: LD_VAR 0 5
78527: PUSH
78528: LD_VAR 0 8
78532: ARRAY
78533: PPUSH
78534: CALL_OW 276
78538: GO 78510
78540: POP
78541: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78542: LD_ADDR_VAR 0 18
78546: PUSH
78547: LD_VAR 0 15
78551: PPUSH
78552: LD_VAR 0 2
78556: PPUSH
78557: LD_INT 1
78559: PPUSH
78560: CALL 77803 0 3
78564: ST_TO_ADDR
// InitHc ;
78565: CALL_OW 19
// InitUc ;
78569: CALL_OW 18
// uc_side := side ;
78573: LD_ADDR_OWVAR 20
78577: PUSH
78578: LD_VAR 0 16
78582: ST_TO_ADDR
// uc_nation := nation ;
78583: LD_ADDR_OWVAR 21
78587: PUSH
78588: LD_VAR 0 17
78592: ST_TO_ADDR
// if buildings then
78593: LD_VAR 0 18
78597: IFFALSE 79919
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78599: LD_ADDR_VAR 0 19
78603: PUSH
78604: LD_VAR 0 18
78608: PPUSH
78609: LD_INT 2
78611: PUSH
78612: LD_INT 30
78614: PUSH
78615: LD_INT 29
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 30
78624: PUSH
78625: LD_INT 30
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: LIST
78636: PPUSH
78637: CALL_OW 72
78641: ST_TO_ADDR
// if tmp then
78642: LD_VAR 0 19
78646: IFFALSE 78694
// for i in tmp do
78648: LD_ADDR_VAR 0 8
78652: PUSH
78653: LD_VAR 0 19
78657: PUSH
78658: FOR_IN
78659: IFFALSE 78692
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78661: LD_VAR 0 8
78665: PPUSH
78666: CALL_OW 250
78670: PPUSH
78671: LD_VAR 0 8
78675: PPUSH
78676: CALL_OW 251
78680: PPUSH
78681: LD_VAR 0 16
78685: PPUSH
78686: CALL_OW 441
78690: GO 78658
78692: POP
78693: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78694: LD_VAR 0 18
78698: PPUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 30
78704: PUSH
78705: LD_INT 32
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 30
78714: PUSH
78715: LD_INT 33
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: LIST
78726: PPUSH
78727: CALL_OW 72
78731: IFFALSE 78819
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78733: LD_ADDR_VAR 0 8
78737: PUSH
78738: LD_VAR 0 18
78742: PPUSH
78743: LD_INT 2
78745: PUSH
78746: LD_INT 30
78748: PUSH
78749: LD_INT 32
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 30
78758: PUSH
78759: LD_INT 33
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: LIST
78770: PPUSH
78771: CALL_OW 72
78775: PUSH
78776: FOR_IN
78777: IFFALSE 78817
// begin if not GetBWeapon ( i ) then
78779: LD_VAR 0 8
78783: PPUSH
78784: CALL_OW 269
78788: NOT
78789: IFFALSE 78815
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78791: LD_VAR 0 8
78795: PPUSH
78796: LD_VAR 0 8
78800: PPUSH
78801: LD_VAR 0 2
78805: PPUSH
78806: CALL 80065 0 2
78810: PPUSH
78811: CALL_OW 431
// end ;
78815: GO 78776
78817: POP
78818: POP
// end ; for i = 1 to personel do
78819: LD_ADDR_VAR 0 8
78823: PUSH
78824: DOUBLE
78825: LD_INT 1
78827: DEC
78828: ST_TO_ADDR
78829: LD_VAR 0 6
78833: PUSH
78834: FOR_TO
78835: IFFALSE 79899
// begin if i > 4 then
78837: LD_VAR 0 8
78841: PUSH
78842: LD_INT 4
78844: GREATER
78845: IFFALSE 78849
// break ;
78847: GO 79899
// case i of 1 :
78849: LD_VAR 0 8
78853: PUSH
78854: LD_INT 1
78856: DOUBLE
78857: EQUAL
78858: IFTRUE 78862
78860: GO 78942
78862: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78863: LD_ADDR_VAR 0 12
78867: PUSH
78868: LD_VAR 0 18
78872: PPUSH
78873: LD_INT 22
78875: PUSH
78876: LD_VAR 0 16
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 58
78887: PUSH
78888: EMPTY
78889: LIST
78890: PUSH
78891: LD_INT 2
78893: PUSH
78894: LD_INT 30
78896: PUSH
78897: LD_INT 32
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 30
78906: PUSH
78907: LD_INT 4
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 30
78916: PUSH
78917: LD_INT 5
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: LIST
78934: PPUSH
78935: CALL_OW 72
78939: ST_TO_ADDR
78940: GO 79164
78942: LD_INT 2
78944: DOUBLE
78945: EQUAL
78946: IFTRUE 78950
78948: GO 79012
78950: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78951: LD_ADDR_VAR 0 12
78955: PUSH
78956: LD_VAR 0 18
78960: PPUSH
78961: LD_INT 22
78963: PUSH
78964: LD_VAR 0 16
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 2
78975: PUSH
78976: LD_INT 30
78978: PUSH
78979: LD_INT 0
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 30
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: LIST
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PPUSH
79005: CALL_OW 72
79009: ST_TO_ADDR
79010: GO 79164
79012: LD_INT 3
79014: DOUBLE
79015: EQUAL
79016: IFTRUE 79020
79018: GO 79082
79020: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79021: LD_ADDR_VAR 0 12
79025: PUSH
79026: LD_VAR 0 18
79030: PPUSH
79031: LD_INT 22
79033: PUSH
79034: LD_VAR 0 16
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 2
79045: PUSH
79046: LD_INT 30
79048: PUSH
79049: LD_INT 2
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: LD_INT 30
79058: PUSH
79059: LD_INT 3
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: LIST
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PPUSH
79075: CALL_OW 72
79079: ST_TO_ADDR
79080: GO 79164
79082: LD_INT 4
79084: DOUBLE
79085: EQUAL
79086: IFTRUE 79090
79088: GO 79163
79090: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79091: LD_ADDR_VAR 0 12
79095: PUSH
79096: LD_VAR 0 18
79100: PPUSH
79101: LD_INT 22
79103: PUSH
79104: LD_VAR 0 16
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 2
79115: PUSH
79116: LD_INT 30
79118: PUSH
79119: LD_INT 6
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 30
79128: PUSH
79129: LD_INT 7
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 30
79138: PUSH
79139: LD_INT 8
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PPUSH
79156: CALL_OW 72
79160: ST_TO_ADDR
79161: GO 79164
79163: POP
// if i = 1 then
79164: LD_VAR 0 8
79168: PUSH
79169: LD_INT 1
79171: EQUAL
79172: IFFALSE 79283
// begin tmp := [ ] ;
79174: LD_ADDR_VAR 0 19
79178: PUSH
79179: EMPTY
79180: ST_TO_ADDR
// for j in f do
79181: LD_ADDR_VAR 0 9
79185: PUSH
79186: LD_VAR 0 12
79190: PUSH
79191: FOR_IN
79192: IFFALSE 79265
// if GetBType ( j ) = b_bunker then
79194: LD_VAR 0 9
79198: PPUSH
79199: CALL_OW 266
79203: PUSH
79204: LD_INT 32
79206: EQUAL
79207: IFFALSE 79234
// tmp := Insert ( tmp , 1 , j ) else
79209: LD_ADDR_VAR 0 19
79213: PUSH
79214: LD_VAR 0 19
79218: PPUSH
79219: LD_INT 1
79221: PPUSH
79222: LD_VAR 0 9
79226: PPUSH
79227: CALL_OW 2
79231: ST_TO_ADDR
79232: GO 79263
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79234: LD_ADDR_VAR 0 19
79238: PUSH
79239: LD_VAR 0 19
79243: PPUSH
79244: LD_VAR 0 19
79248: PUSH
79249: LD_INT 1
79251: PLUS
79252: PPUSH
79253: LD_VAR 0 9
79257: PPUSH
79258: CALL_OW 2
79262: ST_TO_ADDR
79263: GO 79191
79265: POP
79266: POP
// if tmp then
79267: LD_VAR 0 19
79271: IFFALSE 79283
// f := tmp ;
79273: LD_ADDR_VAR 0 12
79277: PUSH
79278: LD_VAR 0 19
79282: ST_TO_ADDR
// end ; x := personel [ i ] ;
79283: LD_ADDR_VAR 0 13
79287: PUSH
79288: LD_VAR 0 6
79292: PUSH
79293: LD_VAR 0 8
79297: ARRAY
79298: ST_TO_ADDR
// if x = - 1 then
79299: LD_VAR 0 13
79303: PUSH
79304: LD_INT 1
79306: NEG
79307: EQUAL
79308: IFFALSE 79517
// begin for j in f do
79310: LD_ADDR_VAR 0 9
79314: PUSH
79315: LD_VAR 0 12
79319: PUSH
79320: FOR_IN
79321: IFFALSE 79513
// repeat InitHc ;
79323: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79327: LD_VAR 0 9
79331: PPUSH
79332: CALL_OW 266
79336: PUSH
79337: LD_INT 5
79339: EQUAL
79340: IFFALSE 79410
// begin if UnitsInside ( j ) < 3 then
79342: LD_VAR 0 9
79346: PPUSH
79347: CALL_OW 313
79351: PUSH
79352: LD_INT 3
79354: LESS
79355: IFFALSE 79391
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79357: LD_INT 0
79359: PPUSH
79360: LD_INT 5
79362: PUSH
79363: LD_INT 8
79365: PUSH
79366: LD_INT 9
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: LIST
79373: PUSH
79374: LD_VAR 0 17
79378: ARRAY
79379: PPUSH
79380: LD_VAR 0 4
79384: PPUSH
79385: CALL_OW 380
79389: GO 79408
// PrepareHuman ( false , i , skill ) ;
79391: LD_INT 0
79393: PPUSH
79394: LD_VAR 0 8
79398: PPUSH
79399: LD_VAR 0 4
79403: PPUSH
79404: CALL_OW 380
// end else
79408: GO 79427
// PrepareHuman ( false , i , skill ) ;
79410: LD_INT 0
79412: PPUSH
79413: LD_VAR 0 8
79417: PPUSH
79418: LD_VAR 0 4
79422: PPUSH
79423: CALL_OW 380
// un := CreateHuman ;
79427: LD_ADDR_VAR 0 14
79431: PUSH
79432: CALL_OW 44
79436: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79437: LD_ADDR_VAR 0 7
79441: PUSH
79442: LD_VAR 0 7
79446: PPUSH
79447: LD_INT 1
79449: PPUSH
79450: LD_VAR 0 14
79454: PPUSH
79455: CALL_OW 2
79459: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79460: LD_VAR 0 14
79464: PPUSH
79465: LD_VAR 0 9
79469: PPUSH
79470: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79474: LD_VAR 0 9
79478: PPUSH
79479: CALL_OW 313
79483: PUSH
79484: LD_INT 6
79486: EQUAL
79487: PUSH
79488: LD_VAR 0 9
79492: PPUSH
79493: CALL_OW 266
79497: PUSH
79498: LD_INT 32
79500: PUSH
79501: LD_INT 31
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: IN
79508: OR
79509: IFFALSE 79323
79511: GO 79320
79513: POP
79514: POP
// end else
79515: GO 79897
// for j = 1 to x do
79517: LD_ADDR_VAR 0 9
79521: PUSH
79522: DOUBLE
79523: LD_INT 1
79525: DEC
79526: ST_TO_ADDR
79527: LD_VAR 0 13
79531: PUSH
79532: FOR_TO
79533: IFFALSE 79895
// begin InitHc ;
79535: CALL_OW 19
// if not f then
79539: LD_VAR 0 12
79543: NOT
79544: IFFALSE 79633
// begin PrepareHuman ( false , i , skill ) ;
79546: LD_INT 0
79548: PPUSH
79549: LD_VAR 0 8
79553: PPUSH
79554: LD_VAR 0 4
79558: PPUSH
79559: CALL_OW 380
// un := CreateHuman ;
79563: LD_ADDR_VAR 0 14
79567: PUSH
79568: CALL_OW 44
79572: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79573: LD_ADDR_VAR 0 7
79577: PUSH
79578: LD_VAR 0 7
79582: PPUSH
79583: LD_INT 1
79585: PPUSH
79586: LD_VAR 0 14
79590: PPUSH
79591: CALL_OW 2
79595: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79596: LD_VAR 0 14
79600: PPUSH
79601: LD_VAR 0 1
79605: PPUSH
79606: CALL_OW 250
79610: PPUSH
79611: LD_VAR 0 1
79615: PPUSH
79616: CALL_OW 251
79620: PPUSH
79621: LD_INT 10
79623: PPUSH
79624: LD_INT 0
79626: PPUSH
79627: CALL_OW 50
// continue ;
79631: GO 79532
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79633: LD_VAR 0 12
79637: PUSH
79638: LD_INT 1
79640: ARRAY
79641: PPUSH
79642: CALL_OW 313
79646: PUSH
79647: LD_VAR 0 12
79651: PUSH
79652: LD_INT 1
79654: ARRAY
79655: PPUSH
79656: CALL_OW 266
79660: PUSH
79661: LD_INT 32
79663: PUSH
79664: LD_INT 31
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: IN
79671: AND
79672: PUSH
79673: LD_VAR 0 12
79677: PUSH
79678: LD_INT 1
79680: ARRAY
79681: PPUSH
79682: CALL_OW 313
79686: PUSH
79687: LD_INT 6
79689: EQUAL
79690: OR
79691: IFFALSE 79711
// f := Delete ( f , 1 ) ;
79693: LD_ADDR_VAR 0 12
79697: PUSH
79698: LD_VAR 0 12
79702: PPUSH
79703: LD_INT 1
79705: PPUSH
79706: CALL_OW 3
79710: ST_TO_ADDR
// if not f then
79711: LD_VAR 0 12
79715: NOT
79716: IFFALSE 79734
// begin x := x + 2 ;
79718: LD_ADDR_VAR 0 13
79722: PUSH
79723: LD_VAR 0 13
79727: PUSH
79728: LD_INT 2
79730: PLUS
79731: ST_TO_ADDR
// continue ;
79732: GO 79532
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79734: LD_VAR 0 12
79738: PUSH
79739: LD_INT 1
79741: ARRAY
79742: PPUSH
79743: CALL_OW 266
79747: PUSH
79748: LD_INT 5
79750: EQUAL
79751: IFFALSE 79825
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79753: LD_VAR 0 12
79757: PUSH
79758: LD_INT 1
79760: ARRAY
79761: PPUSH
79762: CALL_OW 313
79766: PUSH
79767: LD_INT 3
79769: LESS
79770: IFFALSE 79806
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79772: LD_INT 0
79774: PPUSH
79775: LD_INT 5
79777: PUSH
79778: LD_INT 8
79780: PUSH
79781: LD_INT 9
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: LIST
79788: PUSH
79789: LD_VAR 0 17
79793: ARRAY
79794: PPUSH
79795: LD_VAR 0 4
79799: PPUSH
79800: CALL_OW 380
79804: GO 79823
// PrepareHuman ( false , i , skill ) ;
79806: LD_INT 0
79808: PPUSH
79809: LD_VAR 0 8
79813: PPUSH
79814: LD_VAR 0 4
79818: PPUSH
79819: CALL_OW 380
// end else
79823: GO 79842
// PrepareHuman ( false , i , skill ) ;
79825: LD_INT 0
79827: PPUSH
79828: LD_VAR 0 8
79832: PPUSH
79833: LD_VAR 0 4
79837: PPUSH
79838: CALL_OW 380
// un := CreateHuman ;
79842: LD_ADDR_VAR 0 14
79846: PUSH
79847: CALL_OW 44
79851: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79852: LD_ADDR_VAR 0 7
79856: PUSH
79857: LD_VAR 0 7
79861: PPUSH
79862: LD_INT 1
79864: PPUSH
79865: LD_VAR 0 14
79869: PPUSH
79870: CALL_OW 2
79874: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79875: LD_VAR 0 14
79879: PPUSH
79880: LD_VAR 0 12
79884: PUSH
79885: LD_INT 1
79887: ARRAY
79888: PPUSH
79889: CALL_OW 52
// end ;
79893: GO 79532
79895: POP
79896: POP
// end ;
79897: GO 78834
79899: POP
79900: POP
// result := result ^ buildings ;
79901: LD_ADDR_VAR 0 7
79905: PUSH
79906: LD_VAR 0 7
79910: PUSH
79911: LD_VAR 0 18
79915: ADD
79916: ST_TO_ADDR
// end else
79917: GO 80060
// begin for i = 1 to personel do
79919: LD_ADDR_VAR 0 8
79923: PUSH
79924: DOUBLE
79925: LD_INT 1
79927: DEC
79928: ST_TO_ADDR
79929: LD_VAR 0 6
79933: PUSH
79934: FOR_TO
79935: IFFALSE 80058
// begin if i > 4 then
79937: LD_VAR 0 8
79941: PUSH
79942: LD_INT 4
79944: GREATER
79945: IFFALSE 79949
// break ;
79947: GO 80058
// x := personel [ i ] ;
79949: LD_ADDR_VAR 0 13
79953: PUSH
79954: LD_VAR 0 6
79958: PUSH
79959: LD_VAR 0 8
79963: ARRAY
79964: ST_TO_ADDR
// if x = - 1 then
79965: LD_VAR 0 13
79969: PUSH
79970: LD_INT 1
79972: NEG
79973: EQUAL
79974: IFFALSE 79978
// continue ;
79976: GO 79934
// PrepareHuman ( false , i , skill ) ;
79978: LD_INT 0
79980: PPUSH
79981: LD_VAR 0 8
79985: PPUSH
79986: LD_VAR 0 4
79990: PPUSH
79991: CALL_OW 380
// un := CreateHuman ;
79995: LD_ADDR_VAR 0 14
79999: PUSH
80000: CALL_OW 44
80004: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80005: LD_VAR 0 14
80009: PPUSH
80010: LD_VAR 0 1
80014: PPUSH
80015: CALL_OW 250
80019: PPUSH
80020: LD_VAR 0 1
80024: PPUSH
80025: CALL_OW 251
80029: PPUSH
80030: LD_INT 10
80032: PPUSH
80033: LD_INT 0
80035: PPUSH
80036: CALL_OW 50
// result := result ^ un ;
80040: LD_ADDR_VAR 0 7
80044: PUSH
80045: LD_VAR 0 7
80049: PUSH
80050: LD_VAR 0 14
80054: ADD
80055: ST_TO_ADDR
// end ;
80056: GO 79934
80058: POP
80059: POP
// end ; end ;
80060: LD_VAR 0 7
80064: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80065: LD_INT 0
80067: PPUSH
80068: PPUSH
80069: PPUSH
80070: PPUSH
80071: PPUSH
80072: PPUSH
80073: PPUSH
80074: PPUSH
80075: PPUSH
80076: PPUSH
80077: PPUSH
80078: PPUSH
80079: PPUSH
80080: PPUSH
80081: PPUSH
80082: PPUSH
// result := false ;
80083: LD_ADDR_VAR 0 3
80087: PUSH
80088: LD_INT 0
80090: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80091: LD_VAR 0 1
80095: NOT
80096: PUSH
80097: LD_VAR 0 1
80101: PPUSH
80102: CALL_OW 266
80106: PUSH
80107: LD_INT 32
80109: PUSH
80110: LD_INT 33
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: IN
80117: NOT
80118: OR
80119: IFFALSE 80123
// exit ;
80121: GO 81232
// nat := GetNation ( tower ) ;
80123: LD_ADDR_VAR 0 12
80127: PUSH
80128: LD_VAR 0 1
80132: PPUSH
80133: CALL_OW 248
80137: ST_TO_ADDR
// side := GetSide ( tower ) ;
80138: LD_ADDR_VAR 0 16
80142: PUSH
80143: LD_VAR 0 1
80147: PPUSH
80148: CALL_OW 255
80152: ST_TO_ADDR
// x := GetX ( tower ) ;
80153: LD_ADDR_VAR 0 10
80157: PUSH
80158: LD_VAR 0 1
80162: PPUSH
80163: CALL_OW 250
80167: ST_TO_ADDR
// y := GetY ( tower ) ;
80168: LD_ADDR_VAR 0 11
80172: PUSH
80173: LD_VAR 0 1
80177: PPUSH
80178: CALL_OW 251
80182: ST_TO_ADDR
// if not x or not y then
80183: LD_VAR 0 10
80187: NOT
80188: PUSH
80189: LD_VAR 0 11
80193: NOT
80194: OR
80195: IFFALSE 80199
// exit ;
80197: GO 81232
// weapon := 0 ;
80199: LD_ADDR_VAR 0 18
80203: PUSH
80204: LD_INT 0
80206: ST_TO_ADDR
// fac_list := [ ] ;
80207: LD_ADDR_VAR 0 17
80211: PUSH
80212: EMPTY
80213: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80214: LD_ADDR_VAR 0 6
80218: PUSH
80219: LD_VAR 0 1
80223: PPUSH
80224: CALL_OW 274
80228: PPUSH
80229: LD_VAR 0 2
80233: PPUSH
80234: LD_INT 0
80236: PPUSH
80237: CALL 77803 0 3
80241: PPUSH
80242: LD_INT 30
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PPUSH
80252: CALL_OW 72
80256: ST_TO_ADDR
// if not factories then
80257: LD_VAR 0 6
80261: NOT
80262: IFFALSE 80266
// exit ;
80264: GO 81232
// for i in factories do
80266: LD_ADDR_VAR 0 8
80270: PUSH
80271: LD_VAR 0 6
80275: PUSH
80276: FOR_IN
80277: IFFALSE 80302
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80279: LD_ADDR_VAR 0 17
80283: PUSH
80284: LD_VAR 0 17
80288: PUSH
80289: LD_VAR 0 8
80293: PPUSH
80294: CALL_OW 478
80298: UNION
80299: ST_TO_ADDR
80300: GO 80276
80302: POP
80303: POP
// if not fac_list then
80304: LD_VAR 0 17
80308: NOT
80309: IFFALSE 80313
// exit ;
80311: GO 81232
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80313: LD_ADDR_VAR 0 5
80317: PUSH
80318: LD_INT 4
80320: PUSH
80321: LD_INT 5
80323: PUSH
80324: LD_INT 9
80326: PUSH
80327: LD_INT 10
80329: PUSH
80330: LD_INT 6
80332: PUSH
80333: LD_INT 7
80335: PUSH
80336: LD_INT 11
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 27
80350: PUSH
80351: LD_INT 28
80353: PUSH
80354: LD_INT 26
80356: PUSH
80357: LD_INT 30
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 43
80368: PUSH
80369: LD_INT 44
80371: PUSH
80372: LD_INT 46
80374: PUSH
80375: LD_INT 45
80377: PUSH
80378: LD_INT 47
80380: PUSH
80381: LD_INT 49
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: LIST
80396: PUSH
80397: LD_VAR 0 12
80401: ARRAY
80402: ST_TO_ADDR
// list := list isect fac_list ;
80403: LD_ADDR_VAR 0 5
80407: PUSH
80408: LD_VAR 0 5
80412: PUSH
80413: LD_VAR 0 17
80417: ISECT
80418: ST_TO_ADDR
// if not list then
80419: LD_VAR 0 5
80423: NOT
80424: IFFALSE 80428
// exit ;
80426: GO 81232
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80428: LD_VAR 0 12
80432: PUSH
80433: LD_INT 3
80435: EQUAL
80436: PUSH
80437: LD_INT 49
80439: PUSH
80440: LD_VAR 0 5
80444: IN
80445: AND
80446: PUSH
80447: LD_INT 31
80449: PPUSH
80450: LD_VAR 0 16
80454: PPUSH
80455: CALL_OW 321
80459: PUSH
80460: LD_INT 2
80462: EQUAL
80463: AND
80464: IFFALSE 80524
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80466: LD_INT 22
80468: PUSH
80469: LD_VAR 0 16
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 35
80480: PUSH
80481: LD_INT 49
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 91
80490: PUSH
80491: LD_VAR 0 1
80495: PUSH
80496: LD_INT 10
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: LIST
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: LIST
80508: PPUSH
80509: CALL_OW 69
80513: NOT
80514: IFFALSE 80524
// weapon := ru_time_lapser ;
80516: LD_ADDR_VAR 0 18
80520: PUSH
80521: LD_INT 49
80523: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80524: LD_VAR 0 12
80528: PUSH
80529: LD_INT 1
80531: PUSH
80532: LD_INT 2
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: IN
80539: PUSH
80540: LD_INT 11
80542: PUSH
80543: LD_VAR 0 5
80547: IN
80548: PUSH
80549: LD_INT 30
80551: PUSH
80552: LD_VAR 0 5
80556: IN
80557: OR
80558: AND
80559: PUSH
80560: LD_INT 6
80562: PPUSH
80563: LD_VAR 0 16
80567: PPUSH
80568: CALL_OW 321
80572: PUSH
80573: LD_INT 2
80575: EQUAL
80576: AND
80577: IFFALSE 80742
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80579: LD_INT 22
80581: PUSH
80582: LD_VAR 0 16
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 2
80593: PUSH
80594: LD_INT 35
80596: PUSH
80597: LD_INT 11
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 35
80606: PUSH
80607: LD_INT 30
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 91
80621: PUSH
80622: LD_VAR 0 1
80626: PUSH
80627: LD_INT 18
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: LIST
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: LIST
80639: PPUSH
80640: CALL_OW 69
80644: NOT
80645: PUSH
80646: LD_INT 22
80648: PUSH
80649: LD_VAR 0 16
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 2
80660: PUSH
80661: LD_INT 30
80663: PUSH
80664: LD_INT 32
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 30
80673: PUSH
80674: LD_INT 33
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 91
80688: PUSH
80689: LD_VAR 0 1
80693: PUSH
80694: LD_INT 12
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: LIST
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: LIST
80706: PUSH
80707: EMPTY
80708: LIST
80709: PPUSH
80710: CALL_OW 69
80714: PUSH
80715: LD_INT 2
80717: GREATER
80718: AND
80719: IFFALSE 80742
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80721: LD_ADDR_VAR 0 18
80725: PUSH
80726: LD_INT 11
80728: PUSH
80729: LD_INT 30
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_VAR 0 12
80740: ARRAY
80741: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80742: LD_VAR 0 18
80746: NOT
80747: PUSH
80748: LD_INT 40
80750: PPUSH
80751: LD_VAR 0 16
80755: PPUSH
80756: CALL_OW 321
80760: PUSH
80761: LD_INT 2
80763: EQUAL
80764: AND
80765: PUSH
80766: LD_INT 7
80768: PUSH
80769: LD_VAR 0 5
80773: IN
80774: PUSH
80775: LD_INT 28
80777: PUSH
80778: LD_VAR 0 5
80782: IN
80783: OR
80784: PUSH
80785: LD_INT 45
80787: PUSH
80788: LD_VAR 0 5
80792: IN
80793: OR
80794: AND
80795: IFFALSE 81049
// begin hex := GetHexInfo ( x , y ) ;
80797: LD_ADDR_VAR 0 4
80801: PUSH
80802: LD_VAR 0 10
80806: PPUSH
80807: LD_VAR 0 11
80811: PPUSH
80812: CALL_OW 546
80816: ST_TO_ADDR
// if hex [ 1 ] then
80817: LD_VAR 0 4
80821: PUSH
80822: LD_INT 1
80824: ARRAY
80825: IFFALSE 80829
// exit ;
80827: GO 81232
// height := hex [ 2 ] ;
80829: LD_ADDR_VAR 0 15
80833: PUSH
80834: LD_VAR 0 4
80838: PUSH
80839: LD_INT 2
80841: ARRAY
80842: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80843: LD_ADDR_VAR 0 14
80847: PUSH
80848: LD_INT 0
80850: PUSH
80851: LD_INT 2
80853: PUSH
80854: LD_INT 3
80856: PUSH
80857: LD_INT 5
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: ST_TO_ADDR
// for i in tmp do
80866: LD_ADDR_VAR 0 8
80870: PUSH
80871: LD_VAR 0 14
80875: PUSH
80876: FOR_IN
80877: IFFALSE 81047
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80879: LD_ADDR_VAR 0 9
80883: PUSH
80884: LD_VAR 0 10
80888: PPUSH
80889: LD_VAR 0 8
80893: PPUSH
80894: LD_INT 5
80896: PPUSH
80897: CALL_OW 272
80901: PUSH
80902: LD_VAR 0 11
80906: PPUSH
80907: LD_VAR 0 8
80911: PPUSH
80912: LD_INT 5
80914: PPUSH
80915: CALL_OW 273
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80924: LD_VAR 0 9
80928: PUSH
80929: LD_INT 1
80931: ARRAY
80932: PPUSH
80933: LD_VAR 0 9
80937: PUSH
80938: LD_INT 2
80940: ARRAY
80941: PPUSH
80942: CALL_OW 488
80946: IFFALSE 81045
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80948: LD_ADDR_VAR 0 4
80952: PUSH
80953: LD_VAR 0 9
80957: PUSH
80958: LD_INT 1
80960: ARRAY
80961: PPUSH
80962: LD_VAR 0 9
80966: PUSH
80967: LD_INT 2
80969: ARRAY
80970: PPUSH
80971: CALL_OW 546
80975: ST_TO_ADDR
// if hex [ 1 ] then
80976: LD_VAR 0 4
80980: PUSH
80981: LD_INT 1
80983: ARRAY
80984: IFFALSE 80988
// continue ;
80986: GO 80876
// h := hex [ 2 ] ;
80988: LD_ADDR_VAR 0 13
80992: PUSH
80993: LD_VAR 0 4
80997: PUSH
80998: LD_INT 2
81000: ARRAY
81001: ST_TO_ADDR
// if h + 7 < height then
81002: LD_VAR 0 13
81006: PUSH
81007: LD_INT 7
81009: PLUS
81010: PUSH
81011: LD_VAR 0 15
81015: LESS
81016: IFFALSE 81045
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81018: LD_ADDR_VAR 0 18
81022: PUSH
81023: LD_INT 7
81025: PUSH
81026: LD_INT 28
81028: PUSH
81029: LD_INT 45
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: LIST
81036: PUSH
81037: LD_VAR 0 12
81041: ARRAY
81042: ST_TO_ADDR
// break ;
81043: GO 81047
// end ; end ; end ;
81045: GO 80876
81047: POP
81048: POP
// end ; if not weapon then
81049: LD_VAR 0 18
81053: NOT
81054: IFFALSE 81114
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81056: LD_ADDR_VAR 0 5
81060: PUSH
81061: LD_VAR 0 5
81065: PUSH
81066: LD_INT 11
81068: PUSH
81069: LD_INT 30
81071: PUSH
81072: LD_INT 49
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: LIST
81079: DIFF
81080: ST_TO_ADDR
// if not list then
81081: LD_VAR 0 5
81085: NOT
81086: IFFALSE 81090
// exit ;
81088: GO 81232
// weapon := list [ rand ( 1 , list ) ] ;
81090: LD_ADDR_VAR 0 18
81094: PUSH
81095: LD_VAR 0 5
81099: PUSH
81100: LD_INT 1
81102: PPUSH
81103: LD_VAR 0 5
81107: PPUSH
81108: CALL_OW 12
81112: ARRAY
81113: ST_TO_ADDR
// end ; if weapon then
81114: LD_VAR 0 18
81118: IFFALSE 81232
// begin tmp := CostOfWeapon ( weapon ) ;
81120: LD_ADDR_VAR 0 14
81124: PUSH
81125: LD_VAR 0 18
81129: PPUSH
81130: CALL_OW 451
81134: ST_TO_ADDR
// j := GetBase ( tower ) ;
81135: LD_ADDR_VAR 0 9
81139: PUSH
81140: LD_VAR 0 1
81144: PPUSH
81145: CALL_OW 274
81149: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81150: LD_VAR 0 9
81154: PPUSH
81155: LD_INT 1
81157: PPUSH
81158: CALL_OW 275
81162: PUSH
81163: LD_VAR 0 14
81167: PUSH
81168: LD_INT 1
81170: ARRAY
81171: GREATEREQUAL
81172: PUSH
81173: LD_VAR 0 9
81177: PPUSH
81178: LD_INT 2
81180: PPUSH
81181: CALL_OW 275
81185: PUSH
81186: LD_VAR 0 14
81190: PUSH
81191: LD_INT 2
81193: ARRAY
81194: GREATEREQUAL
81195: AND
81196: PUSH
81197: LD_VAR 0 9
81201: PPUSH
81202: LD_INT 3
81204: PPUSH
81205: CALL_OW 275
81209: PUSH
81210: LD_VAR 0 14
81214: PUSH
81215: LD_INT 3
81217: ARRAY
81218: GREATEREQUAL
81219: AND
81220: IFFALSE 81232
// result := weapon ;
81222: LD_ADDR_VAR 0 3
81226: PUSH
81227: LD_VAR 0 18
81231: ST_TO_ADDR
// end ; end ;
81232: LD_VAR 0 3
81236: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81237: LD_INT 0
81239: PPUSH
81240: PPUSH
// result := true ;
81241: LD_ADDR_VAR 0 3
81245: PUSH
81246: LD_INT 1
81248: ST_TO_ADDR
// if array1 = array2 then
81249: LD_VAR 0 1
81253: PUSH
81254: LD_VAR 0 2
81258: EQUAL
81259: IFFALSE 81319
// begin for i = 1 to array1 do
81261: LD_ADDR_VAR 0 4
81265: PUSH
81266: DOUBLE
81267: LD_INT 1
81269: DEC
81270: ST_TO_ADDR
81271: LD_VAR 0 1
81275: PUSH
81276: FOR_TO
81277: IFFALSE 81315
// if array1 [ i ] <> array2 [ i ] then
81279: LD_VAR 0 1
81283: PUSH
81284: LD_VAR 0 4
81288: ARRAY
81289: PUSH
81290: LD_VAR 0 2
81294: PUSH
81295: LD_VAR 0 4
81299: ARRAY
81300: NONEQUAL
81301: IFFALSE 81313
// begin result := false ;
81303: LD_ADDR_VAR 0 3
81307: PUSH
81308: LD_INT 0
81310: ST_TO_ADDR
// break ;
81311: GO 81315
// end ;
81313: GO 81276
81315: POP
81316: POP
// end else
81317: GO 81327
// result := false ;
81319: LD_ADDR_VAR 0 3
81323: PUSH
81324: LD_INT 0
81326: ST_TO_ADDR
// end ;
81327: LD_VAR 0 3
81331: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81332: LD_INT 0
81334: PPUSH
81335: PPUSH
// if not array1 or not array2 then
81336: LD_VAR 0 1
81340: NOT
81341: PUSH
81342: LD_VAR 0 2
81346: NOT
81347: OR
81348: IFFALSE 81352
// exit ;
81350: GO 81416
// result := true ;
81352: LD_ADDR_VAR 0 3
81356: PUSH
81357: LD_INT 1
81359: ST_TO_ADDR
// for i = 1 to array1 do
81360: LD_ADDR_VAR 0 4
81364: PUSH
81365: DOUBLE
81366: LD_INT 1
81368: DEC
81369: ST_TO_ADDR
81370: LD_VAR 0 1
81374: PUSH
81375: FOR_TO
81376: IFFALSE 81414
// if array1 [ i ] <> array2 [ i ] then
81378: LD_VAR 0 1
81382: PUSH
81383: LD_VAR 0 4
81387: ARRAY
81388: PUSH
81389: LD_VAR 0 2
81393: PUSH
81394: LD_VAR 0 4
81398: ARRAY
81399: NONEQUAL
81400: IFFALSE 81412
// begin result := false ;
81402: LD_ADDR_VAR 0 3
81406: PUSH
81407: LD_INT 0
81409: ST_TO_ADDR
// break ;
81410: GO 81414
// end ;
81412: GO 81375
81414: POP
81415: POP
// end ;
81416: LD_VAR 0 3
81420: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81421: LD_INT 0
81423: PPUSH
81424: PPUSH
81425: PPUSH
// pom := GetBase ( fac ) ;
81426: LD_ADDR_VAR 0 5
81430: PUSH
81431: LD_VAR 0 1
81435: PPUSH
81436: CALL_OW 274
81440: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81441: LD_ADDR_VAR 0 4
81445: PUSH
81446: LD_VAR 0 2
81450: PUSH
81451: LD_INT 1
81453: ARRAY
81454: PPUSH
81455: LD_VAR 0 2
81459: PUSH
81460: LD_INT 2
81462: ARRAY
81463: PPUSH
81464: LD_VAR 0 2
81468: PUSH
81469: LD_INT 3
81471: ARRAY
81472: PPUSH
81473: LD_VAR 0 2
81477: PUSH
81478: LD_INT 4
81480: ARRAY
81481: PPUSH
81482: CALL_OW 449
81486: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81487: LD_ADDR_VAR 0 3
81491: PUSH
81492: LD_VAR 0 5
81496: PPUSH
81497: LD_INT 1
81499: PPUSH
81500: CALL_OW 275
81504: PUSH
81505: LD_VAR 0 4
81509: PUSH
81510: LD_INT 1
81512: ARRAY
81513: GREATEREQUAL
81514: PUSH
81515: LD_VAR 0 5
81519: PPUSH
81520: LD_INT 2
81522: PPUSH
81523: CALL_OW 275
81527: PUSH
81528: LD_VAR 0 4
81532: PUSH
81533: LD_INT 2
81535: ARRAY
81536: GREATEREQUAL
81537: AND
81538: PUSH
81539: LD_VAR 0 5
81543: PPUSH
81544: LD_INT 3
81546: PPUSH
81547: CALL_OW 275
81551: PUSH
81552: LD_VAR 0 4
81556: PUSH
81557: LD_INT 3
81559: ARRAY
81560: GREATEREQUAL
81561: AND
81562: ST_TO_ADDR
// end ;
81563: LD_VAR 0 3
81567: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81568: LD_INT 0
81570: PPUSH
81571: PPUSH
81572: PPUSH
81573: PPUSH
// pom := GetBase ( building ) ;
81574: LD_ADDR_VAR 0 3
81578: PUSH
81579: LD_VAR 0 1
81583: PPUSH
81584: CALL_OW 274
81588: ST_TO_ADDR
// if not pom then
81589: LD_VAR 0 3
81593: NOT
81594: IFFALSE 81598
// exit ;
81596: GO 81768
// btype := GetBType ( building ) ;
81598: LD_ADDR_VAR 0 5
81602: PUSH
81603: LD_VAR 0 1
81607: PPUSH
81608: CALL_OW 266
81612: ST_TO_ADDR
// if btype = b_armoury then
81613: LD_VAR 0 5
81617: PUSH
81618: LD_INT 4
81620: EQUAL
81621: IFFALSE 81631
// btype := b_barracks ;
81623: LD_ADDR_VAR 0 5
81627: PUSH
81628: LD_INT 5
81630: ST_TO_ADDR
// if btype = b_depot then
81631: LD_VAR 0 5
81635: PUSH
81636: LD_INT 0
81638: EQUAL
81639: IFFALSE 81649
// btype := b_warehouse ;
81641: LD_ADDR_VAR 0 5
81645: PUSH
81646: LD_INT 1
81648: ST_TO_ADDR
// if btype = b_workshop then
81649: LD_VAR 0 5
81653: PUSH
81654: LD_INT 2
81656: EQUAL
81657: IFFALSE 81667
// btype := b_factory ;
81659: LD_ADDR_VAR 0 5
81663: PUSH
81664: LD_INT 3
81666: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81667: LD_ADDR_VAR 0 4
81671: PUSH
81672: LD_VAR 0 5
81676: PPUSH
81677: LD_VAR 0 1
81681: PPUSH
81682: CALL_OW 248
81686: PPUSH
81687: CALL_OW 450
81691: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81692: LD_ADDR_VAR 0 2
81696: PUSH
81697: LD_VAR 0 3
81701: PPUSH
81702: LD_INT 1
81704: PPUSH
81705: CALL_OW 275
81709: PUSH
81710: LD_VAR 0 4
81714: PUSH
81715: LD_INT 1
81717: ARRAY
81718: GREATEREQUAL
81719: PUSH
81720: LD_VAR 0 3
81724: PPUSH
81725: LD_INT 2
81727: PPUSH
81728: CALL_OW 275
81732: PUSH
81733: LD_VAR 0 4
81737: PUSH
81738: LD_INT 2
81740: ARRAY
81741: GREATEREQUAL
81742: AND
81743: PUSH
81744: LD_VAR 0 3
81748: PPUSH
81749: LD_INT 3
81751: PPUSH
81752: CALL_OW 275
81756: PUSH
81757: LD_VAR 0 4
81761: PUSH
81762: LD_INT 3
81764: ARRAY
81765: GREATEREQUAL
81766: AND
81767: ST_TO_ADDR
// end ;
81768: LD_VAR 0 2
81772: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81773: LD_INT 0
81775: PPUSH
81776: PPUSH
81777: PPUSH
// pom := GetBase ( building ) ;
81778: LD_ADDR_VAR 0 4
81782: PUSH
81783: LD_VAR 0 1
81787: PPUSH
81788: CALL_OW 274
81792: ST_TO_ADDR
// if not pom then
81793: LD_VAR 0 4
81797: NOT
81798: IFFALSE 81802
// exit ;
81800: GO 81903
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81802: LD_ADDR_VAR 0 5
81806: PUSH
81807: LD_VAR 0 2
81811: PPUSH
81812: LD_VAR 0 1
81816: PPUSH
81817: CALL_OW 248
81821: PPUSH
81822: CALL_OW 450
81826: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81827: LD_ADDR_VAR 0 3
81831: PUSH
81832: LD_VAR 0 4
81836: PPUSH
81837: LD_INT 1
81839: PPUSH
81840: CALL_OW 275
81844: PUSH
81845: LD_VAR 0 5
81849: PUSH
81850: LD_INT 1
81852: ARRAY
81853: GREATEREQUAL
81854: PUSH
81855: LD_VAR 0 4
81859: PPUSH
81860: LD_INT 2
81862: PPUSH
81863: CALL_OW 275
81867: PUSH
81868: LD_VAR 0 5
81872: PUSH
81873: LD_INT 2
81875: ARRAY
81876: GREATEREQUAL
81877: AND
81878: PUSH
81879: LD_VAR 0 4
81883: PPUSH
81884: LD_INT 3
81886: PPUSH
81887: CALL_OW 275
81891: PUSH
81892: LD_VAR 0 5
81896: PUSH
81897: LD_INT 3
81899: ARRAY
81900: GREATEREQUAL
81901: AND
81902: ST_TO_ADDR
// end ;
81903: LD_VAR 0 3
81907: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81908: LD_INT 0
81910: PPUSH
81911: PPUSH
81912: PPUSH
81913: PPUSH
81914: PPUSH
81915: PPUSH
81916: PPUSH
81917: PPUSH
81918: PPUSH
81919: PPUSH
81920: PPUSH
// result := false ;
81921: LD_ADDR_VAR 0 8
81925: PUSH
81926: LD_INT 0
81928: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81929: LD_VAR 0 5
81933: NOT
81934: PUSH
81935: LD_VAR 0 1
81939: NOT
81940: OR
81941: PUSH
81942: LD_VAR 0 2
81946: NOT
81947: OR
81948: PUSH
81949: LD_VAR 0 3
81953: NOT
81954: OR
81955: IFFALSE 81959
// exit ;
81957: GO 82773
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81959: LD_ADDR_VAR 0 14
81963: PUSH
81964: LD_VAR 0 1
81968: PPUSH
81969: LD_VAR 0 2
81973: PPUSH
81974: LD_VAR 0 3
81978: PPUSH
81979: LD_VAR 0 4
81983: PPUSH
81984: LD_VAR 0 5
81988: PUSH
81989: LD_INT 1
81991: ARRAY
81992: PPUSH
81993: CALL_OW 248
81997: PPUSH
81998: LD_INT 0
82000: PPUSH
82001: CALL 84026 0 6
82005: ST_TO_ADDR
// if not hexes then
82006: LD_VAR 0 14
82010: NOT
82011: IFFALSE 82015
// exit ;
82013: GO 82773
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82015: LD_ADDR_VAR 0 17
82019: PUSH
82020: LD_VAR 0 5
82024: PPUSH
82025: LD_INT 22
82027: PUSH
82028: LD_VAR 0 13
82032: PPUSH
82033: CALL_OW 255
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 2
82044: PUSH
82045: LD_INT 30
82047: PUSH
82048: LD_INT 0
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 30
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: LIST
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PPUSH
82074: CALL_OW 72
82078: ST_TO_ADDR
// for i = 1 to hexes do
82079: LD_ADDR_VAR 0 9
82083: PUSH
82084: DOUBLE
82085: LD_INT 1
82087: DEC
82088: ST_TO_ADDR
82089: LD_VAR 0 14
82093: PUSH
82094: FOR_TO
82095: IFFALSE 82771
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82097: LD_ADDR_VAR 0 13
82101: PUSH
82102: LD_VAR 0 14
82106: PUSH
82107: LD_VAR 0 9
82111: ARRAY
82112: PUSH
82113: LD_INT 1
82115: ARRAY
82116: PPUSH
82117: LD_VAR 0 14
82121: PUSH
82122: LD_VAR 0 9
82126: ARRAY
82127: PUSH
82128: LD_INT 2
82130: ARRAY
82131: PPUSH
82132: CALL_OW 428
82136: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82137: LD_VAR 0 14
82141: PUSH
82142: LD_VAR 0 9
82146: ARRAY
82147: PUSH
82148: LD_INT 1
82150: ARRAY
82151: PPUSH
82152: LD_VAR 0 14
82156: PUSH
82157: LD_VAR 0 9
82161: ARRAY
82162: PUSH
82163: LD_INT 2
82165: ARRAY
82166: PPUSH
82167: CALL_OW 351
82171: PUSH
82172: LD_VAR 0 14
82176: PUSH
82177: LD_VAR 0 9
82181: ARRAY
82182: PUSH
82183: LD_INT 1
82185: ARRAY
82186: PPUSH
82187: LD_VAR 0 14
82191: PUSH
82192: LD_VAR 0 9
82196: ARRAY
82197: PUSH
82198: LD_INT 2
82200: ARRAY
82201: PPUSH
82202: CALL_OW 488
82206: NOT
82207: OR
82208: PUSH
82209: LD_VAR 0 13
82213: PPUSH
82214: CALL_OW 247
82218: PUSH
82219: LD_INT 3
82221: EQUAL
82222: OR
82223: IFFALSE 82229
// exit ;
82225: POP
82226: POP
82227: GO 82773
// if not tmp then
82229: LD_VAR 0 13
82233: NOT
82234: IFFALSE 82238
// continue ;
82236: GO 82094
// result := true ;
82238: LD_ADDR_VAR 0 8
82242: PUSH
82243: LD_INT 1
82245: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82246: LD_VAR 0 6
82250: PUSH
82251: LD_VAR 0 13
82255: PPUSH
82256: CALL_OW 247
82260: PUSH
82261: LD_INT 2
82263: EQUAL
82264: AND
82265: PUSH
82266: LD_VAR 0 13
82270: PPUSH
82271: CALL_OW 263
82275: PUSH
82276: LD_INT 1
82278: EQUAL
82279: AND
82280: IFFALSE 82444
// begin if IsDrivenBy ( tmp ) then
82282: LD_VAR 0 13
82286: PPUSH
82287: CALL_OW 311
82291: IFFALSE 82295
// continue ;
82293: GO 82094
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82295: LD_VAR 0 6
82299: PPUSH
82300: LD_INT 3
82302: PUSH
82303: LD_INT 60
82305: PUSH
82306: EMPTY
82307: LIST
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 3
82315: PUSH
82316: LD_INT 55
82318: PUSH
82319: EMPTY
82320: LIST
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PPUSH
82330: CALL_OW 72
82334: IFFALSE 82442
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82336: LD_ADDR_VAR 0 18
82340: PUSH
82341: LD_VAR 0 6
82345: PPUSH
82346: LD_INT 3
82348: PUSH
82349: LD_INT 60
82351: PUSH
82352: EMPTY
82353: LIST
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 55
82364: PUSH
82365: EMPTY
82366: LIST
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PPUSH
82376: CALL_OW 72
82380: PUSH
82381: LD_INT 1
82383: ARRAY
82384: ST_TO_ADDR
// if IsInUnit ( driver ) then
82385: LD_VAR 0 18
82389: PPUSH
82390: CALL_OW 310
82394: IFFALSE 82405
// ComExit ( driver ) ;
82396: LD_VAR 0 18
82400: PPUSH
82401: CALL 107807 0 1
// AddComEnterUnit ( driver , tmp ) ;
82405: LD_VAR 0 18
82409: PPUSH
82410: LD_VAR 0 13
82414: PPUSH
82415: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82419: LD_VAR 0 18
82423: PPUSH
82424: LD_VAR 0 7
82428: PPUSH
82429: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82433: LD_VAR 0 18
82437: PPUSH
82438: CALL_OW 181
// end ; continue ;
82442: GO 82094
// end ; if not cleaners or not tmp in cleaners then
82444: LD_VAR 0 6
82448: NOT
82449: PUSH
82450: LD_VAR 0 13
82454: PUSH
82455: LD_VAR 0 6
82459: IN
82460: NOT
82461: OR
82462: IFFALSE 82769
// begin if dep then
82464: LD_VAR 0 17
82468: IFFALSE 82604
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82470: LD_ADDR_VAR 0 16
82474: PUSH
82475: LD_VAR 0 17
82479: PUSH
82480: LD_INT 1
82482: ARRAY
82483: PPUSH
82484: CALL_OW 250
82488: PPUSH
82489: LD_VAR 0 17
82493: PUSH
82494: LD_INT 1
82496: ARRAY
82497: PPUSH
82498: CALL_OW 254
82502: PPUSH
82503: LD_INT 5
82505: PPUSH
82506: CALL_OW 272
82510: PUSH
82511: LD_VAR 0 17
82515: PUSH
82516: LD_INT 1
82518: ARRAY
82519: PPUSH
82520: CALL_OW 251
82524: PPUSH
82525: LD_VAR 0 17
82529: PUSH
82530: LD_INT 1
82532: ARRAY
82533: PPUSH
82534: CALL_OW 254
82538: PPUSH
82539: LD_INT 5
82541: PPUSH
82542: CALL_OW 273
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82551: LD_VAR 0 16
82555: PUSH
82556: LD_INT 1
82558: ARRAY
82559: PPUSH
82560: LD_VAR 0 16
82564: PUSH
82565: LD_INT 2
82567: ARRAY
82568: PPUSH
82569: CALL_OW 488
82573: IFFALSE 82604
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82575: LD_VAR 0 13
82579: PPUSH
82580: LD_VAR 0 16
82584: PUSH
82585: LD_INT 1
82587: ARRAY
82588: PPUSH
82589: LD_VAR 0 16
82593: PUSH
82594: LD_INT 2
82596: ARRAY
82597: PPUSH
82598: CALL_OW 111
// continue ;
82602: GO 82094
// end ; end ; r := GetDir ( tmp ) ;
82604: LD_ADDR_VAR 0 15
82608: PUSH
82609: LD_VAR 0 13
82613: PPUSH
82614: CALL_OW 254
82618: ST_TO_ADDR
// if r = 5 then
82619: LD_VAR 0 15
82623: PUSH
82624: LD_INT 5
82626: EQUAL
82627: IFFALSE 82637
// r := 0 ;
82629: LD_ADDR_VAR 0 15
82633: PUSH
82634: LD_INT 0
82636: ST_TO_ADDR
// for j = r to 5 do
82637: LD_ADDR_VAR 0 10
82641: PUSH
82642: DOUBLE
82643: LD_VAR 0 15
82647: DEC
82648: ST_TO_ADDR
82649: LD_INT 5
82651: PUSH
82652: FOR_TO
82653: IFFALSE 82767
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82655: LD_ADDR_VAR 0 11
82659: PUSH
82660: LD_VAR 0 13
82664: PPUSH
82665: CALL_OW 250
82669: PPUSH
82670: LD_VAR 0 10
82674: PPUSH
82675: LD_INT 2
82677: PPUSH
82678: CALL_OW 272
82682: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82683: LD_ADDR_VAR 0 12
82687: PUSH
82688: LD_VAR 0 13
82692: PPUSH
82693: CALL_OW 251
82697: PPUSH
82698: LD_VAR 0 10
82702: PPUSH
82703: LD_INT 2
82705: PPUSH
82706: CALL_OW 273
82710: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82711: LD_VAR 0 11
82715: PPUSH
82716: LD_VAR 0 12
82720: PPUSH
82721: CALL_OW 488
82725: PUSH
82726: LD_VAR 0 11
82730: PPUSH
82731: LD_VAR 0 12
82735: PPUSH
82736: CALL_OW 428
82740: NOT
82741: AND
82742: IFFALSE 82765
// begin ComMoveXY ( tmp , _x , _y ) ;
82744: LD_VAR 0 13
82748: PPUSH
82749: LD_VAR 0 11
82753: PPUSH
82754: LD_VAR 0 12
82758: PPUSH
82759: CALL_OW 111
// break ;
82763: GO 82767
// end ; end ;
82765: GO 82652
82767: POP
82768: POP
// end ; end ;
82769: GO 82094
82771: POP
82772: POP
// end ;
82773: LD_VAR 0 8
82777: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82778: LD_INT 0
82780: PPUSH
// result := true ;
82781: LD_ADDR_VAR 0 3
82785: PUSH
82786: LD_INT 1
82788: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82789: LD_VAR 0 2
82793: PUSH
82794: LD_INT 24
82796: DOUBLE
82797: EQUAL
82798: IFTRUE 82808
82800: LD_INT 33
82802: DOUBLE
82803: EQUAL
82804: IFTRUE 82808
82806: GO 82833
82808: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82809: LD_ADDR_VAR 0 3
82813: PUSH
82814: LD_INT 32
82816: PPUSH
82817: LD_VAR 0 1
82821: PPUSH
82822: CALL_OW 321
82826: PUSH
82827: LD_INT 2
82829: EQUAL
82830: ST_TO_ADDR
82831: GO 83149
82833: LD_INT 20
82835: DOUBLE
82836: EQUAL
82837: IFTRUE 82841
82839: GO 82866
82841: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82842: LD_ADDR_VAR 0 3
82846: PUSH
82847: LD_INT 6
82849: PPUSH
82850: LD_VAR 0 1
82854: PPUSH
82855: CALL_OW 321
82859: PUSH
82860: LD_INT 2
82862: EQUAL
82863: ST_TO_ADDR
82864: GO 83149
82866: LD_INT 22
82868: DOUBLE
82869: EQUAL
82870: IFTRUE 82880
82872: LD_INT 36
82874: DOUBLE
82875: EQUAL
82876: IFTRUE 82880
82878: GO 82905
82880: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82881: LD_ADDR_VAR 0 3
82885: PUSH
82886: LD_INT 15
82888: PPUSH
82889: LD_VAR 0 1
82893: PPUSH
82894: CALL_OW 321
82898: PUSH
82899: LD_INT 2
82901: EQUAL
82902: ST_TO_ADDR
82903: GO 83149
82905: LD_INT 30
82907: DOUBLE
82908: EQUAL
82909: IFTRUE 82913
82911: GO 82938
82913: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82914: LD_ADDR_VAR 0 3
82918: PUSH
82919: LD_INT 20
82921: PPUSH
82922: LD_VAR 0 1
82926: PPUSH
82927: CALL_OW 321
82931: PUSH
82932: LD_INT 2
82934: EQUAL
82935: ST_TO_ADDR
82936: GO 83149
82938: LD_INT 28
82940: DOUBLE
82941: EQUAL
82942: IFTRUE 82952
82944: LD_INT 21
82946: DOUBLE
82947: EQUAL
82948: IFTRUE 82952
82950: GO 82977
82952: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82953: LD_ADDR_VAR 0 3
82957: PUSH
82958: LD_INT 21
82960: PPUSH
82961: LD_VAR 0 1
82965: PPUSH
82966: CALL_OW 321
82970: PUSH
82971: LD_INT 2
82973: EQUAL
82974: ST_TO_ADDR
82975: GO 83149
82977: LD_INT 16
82979: DOUBLE
82980: EQUAL
82981: IFTRUE 82985
82983: GO 83010
82985: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82986: LD_ADDR_VAR 0 3
82990: PUSH
82991: LD_INT 84
82993: PPUSH
82994: LD_VAR 0 1
82998: PPUSH
82999: CALL_OW 321
83003: PUSH
83004: LD_INT 2
83006: EQUAL
83007: ST_TO_ADDR
83008: GO 83149
83010: LD_INT 19
83012: DOUBLE
83013: EQUAL
83014: IFTRUE 83024
83016: LD_INT 23
83018: DOUBLE
83019: EQUAL
83020: IFTRUE 83024
83022: GO 83049
83024: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83025: LD_ADDR_VAR 0 3
83029: PUSH
83030: LD_INT 83
83032: PPUSH
83033: LD_VAR 0 1
83037: PPUSH
83038: CALL_OW 321
83042: PUSH
83043: LD_INT 2
83045: EQUAL
83046: ST_TO_ADDR
83047: GO 83149
83049: LD_INT 17
83051: DOUBLE
83052: EQUAL
83053: IFTRUE 83057
83055: GO 83082
83057: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83058: LD_ADDR_VAR 0 3
83062: PUSH
83063: LD_INT 39
83065: PPUSH
83066: LD_VAR 0 1
83070: PPUSH
83071: CALL_OW 321
83075: PUSH
83076: LD_INT 2
83078: EQUAL
83079: ST_TO_ADDR
83080: GO 83149
83082: LD_INT 18
83084: DOUBLE
83085: EQUAL
83086: IFTRUE 83090
83088: GO 83115
83090: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83091: LD_ADDR_VAR 0 3
83095: PUSH
83096: LD_INT 40
83098: PPUSH
83099: LD_VAR 0 1
83103: PPUSH
83104: CALL_OW 321
83108: PUSH
83109: LD_INT 2
83111: EQUAL
83112: ST_TO_ADDR
83113: GO 83149
83115: LD_INT 27
83117: DOUBLE
83118: EQUAL
83119: IFTRUE 83123
83121: GO 83148
83123: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83124: LD_ADDR_VAR 0 3
83128: PUSH
83129: LD_INT 35
83131: PPUSH
83132: LD_VAR 0 1
83136: PPUSH
83137: CALL_OW 321
83141: PUSH
83142: LD_INT 2
83144: EQUAL
83145: ST_TO_ADDR
83146: GO 83149
83148: POP
// end ;
83149: LD_VAR 0 3
83153: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83154: LD_INT 0
83156: PPUSH
83157: PPUSH
83158: PPUSH
83159: PPUSH
83160: PPUSH
83161: PPUSH
83162: PPUSH
83163: PPUSH
83164: PPUSH
83165: PPUSH
83166: PPUSH
// result := false ;
83167: LD_ADDR_VAR 0 6
83171: PUSH
83172: LD_INT 0
83174: ST_TO_ADDR
// if btype = b_depot then
83175: LD_VAR 0 2
83179: PUSH
83180: LD_INT 0
83182: EQUAL
83183: IFFALSE 83195
// begin result := true ;
83185: LD_ADDR_VAR 0 6
83189: PUSH
83190: LD_INT 1
83192: ST_TO_ADDR
// exit ;
83193: GO 84021
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83195: LD_VAR 0 1
83199: NOT
83200: PUSH
83201: LD_VAR 0 1
83205: PPUSH
83206: CALL_OW 266
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: LD_INT 1
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: IN
83221: NOT
83222: OR
83223: PUSH
83224: LD_VAR 0 2
83228: NOT
83229: OR
83230: PUSH
83231: LD_VAR 0 5
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: LD_INT 2
83244: PUSH
83245: LD_INT 3
83247: PUSH
83248: LD_INT 4
83250: PUSH
83251: LD_INT 5
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: IN
83262: NOT
83263: OR
83264: PUSH
83265: LD_VAR 0 3
83269: PPUSH
83270: LD_VAR 0 4
83274: PPUSH
83275: CALL_OW 488
83279: NOT
83280: OR
83281: IFFALSE 83285
// exit ;
83283: GO 84021
// side := GetSide ( depot ) ;
83285: LD_ADDR_VAR 0 9
83289: PUSH
83290: LD_VAR 0 1
83294: PPUSH
83295: CALL_OW 255
83299: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83300: LD_VAR 0 9
83304: PPUSH
83305: LD_VAR 0 2
83309: PPUSH
83310: CALL 82778 0 2
83314: NOT
83315: IFFALSE 83319
// exit ;
83317: GO 84021
// pom := GetBase ( depot ) ;
83319: LD_ADDR_VAR 0 10
83323: PUSH
83324: LD_VAR 0 1
83328: PPUSH
83329: CALL_OW 274
83333: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83334: LD_ADDR_VAR 0 11
83338: PUSH
83339: LD_VAR 0 2
83343: PPUSH
83344: LD_VAR 0 1
83348: PPUSH
83349: CALL_OW 248
83353: PPUSH
83354: CALL_OW 450
83358: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83359: LD_VAR 0 10
83363: PPUSH
83364: LD_INT 1
83366: PPUSH
83367: CALL_OW 275
83371: PUSH
83372: LD_VAR 0 11
83376: PUSH
83377: LD_INT 1
83379: ARRAY
83380: GREATEREQUAL
83381: PUSH
83382: LD_VAR 0 10
83386: PPUSH
83387: LD_INT 2
83389: PPUSH
83390: CALL_OW 275
83394: PUSH
83395: LD_VAR 0 11
83399: PUSH
83400: LD_INT 2
83402: ARRAY
83403: GREATEREQUAL
83404: AND
83405: PUSH
83406: LD_VAR 0 10
83410: PPUSH
83411: LD_INT 3
83413: PPUSH
83414: CALL_OW 275
83418: PUSH
83419: LD_VAR 0 11
83423: PUSH
83424: LD_INT 3
83426: ARRAY
83427: GREATEREQUAL
83428: AND
83429: NOT
83430: IFFALSE 83434
// exit ;
83432: GO 84021
// if GetBType ( depot ) = b_depot then
83434: LD_VAR 0 1
83438: PPUSH
83439: CALL_OW 266
83443: PUSH
83444: LD_INT 0
83446: EQUAL
83447: IFFALSE 83459
// dist := 28 else
83449: LD_ADDR_VAR 0 14
83453: PUSH
83454: LD_INT 28
83456: ST_TO_ADDR
83457: GO 83467
// dist := 36 ;
83459: LD_ADDR_VAR 0 14
83463: PUSH
83464: LD_INT 36
83466: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83467: LD_VAR 0 1
83471: PPUSH
83472: LD_VAR 0 3
83476: PPUSH
83477: LD_VAR 0 4
83481: PPUSH
83482: CALL_OW 297
83486: PUSH
83487: LD_VAR 0 14
83491: GREATER
83492: IFFALSE 83496
// exit ;
83494: GO 84021
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83496: LD_ADDR_VAR 0 12
83500: PUSH
83501: LD_VAR 0 2
83505: PPUSH
83506: LD_VAR 0 3
83510: PPUSH
83511: LD_VAR 0 4
83515: PPUSH
83516: LD_VAR 0 5
83520: PPUSH
83521: LD_VAR 0 1
83525: PPUSH
83526: CALL_OW 248
83530: PPUSH
83531: LD_INT 0
83533: PPUSH
83534: CALL 84026 0 6
83538: ST_TO_ADDR
// if not hexes then
83539: LD_VAR 0 12
83543: NOT
83544: IFFALSE 83548
// exit ;
83546: GO 84021
// hex := GetHexInfo ( x , y ) ;
83548: LD_ADDR_VAR 0 15
83552: PUSH
83553: LD_VAR 0 3
83557: PPUSH
83558: LD_VAR 0 4
83562: PPUSH
83563: CALL_OW 546
83567: ST_TO_ADDR
// if hex [ 1 ] then
83568: LD_VAR 0 15
83572: PUSH
83573: LD_INT 1
83575: ARRAY
83576: IFFALSE 83580
// exit ;
83578: GO 84021
// height := hex [ 2 ] ;
83580: LD_ADDR_VAR 0 13
83584: PUSH
83585: LD_VAR 0 15
83589: PUSH
83590: LD_INT 2
83592: ARRAY
83593: ST_TO_ADDR
// for i = 1 to hexes do
83594: LD_ADDR_VAR 0 7
83598: PUSH
83599: DOUBLE
83600: LD_INT 1
83602: DEC
83603: ST_TO_ADDR
83604: LD_VAR 0 12
83608: PUSH
83609: FOR_TO
83610: IFFALSE 83940
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83612: LD_VAR 0 12
83616: PUSH
83617: LD_VAR 0 7
83621: ARRAY
83622: PUSH
83623: LD_INT 1
83625: ARRAY
83626: PPUSH
83627: LD_VAR 0 12
83631: PUSH
83632: LD_VAR 0 7
83636: ARRAY
83637: PUSH
83638: LD_INT 2
83640: ARRAY
83641: PPUSH
83642: CALL_OW 488
83646: NOT
83647: PUSH
83648: LD_VAR 0 12
83652: PUSH
83653: LD_VAR 0 7
83657: ARRAY
83658: PUSH
83659: LD_INT 1
83661: ARRAY
83662: PPUSH
83663: LD_VAR 0 12
83667: PUSH
83668: LD_VAR 0 7
83672: ARRAY
83673: PUSH
83674: LD_INT 2
83676: ARRAY
83677: PPUSH
83678: CALL_OW 428
83682: PUSH
83683: LD_INT 0
83685: GREATER
83686: OR
83687: PUSH
83688: LD_VAR 0 12
83692: PUSH
83693: LD_VAR 0 7
83697: ARRAY
83698: PUSH
83699: LD_INT 1
83701: ARRAY
83702: PPUSH
83703: LD_VAR 0 12
83707: PUSH
83708: LD_VAR 0 7
83712: ARRAY
83713: PUSH
83714: LD_INT 2
83716: ARRAY
83717: PPUSH
83718: CALL_OW 351
83722: OR
83723: IFFALSE 83729
// exit ;
83725: POP
83726: POP
83727: GO 84021
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83729: LD_ADDR_VAR 0 8
83733: PUSH
83734: LD_VAR 0 12
83738: PUSH
83739: LD_VAR 0 7
83743: ARRAY
83744: PUSH
83745: LD_INT 1
83747: ARRAY
83748: PPUSH
83749: LD_VAR 0 12
83753: PUSH
83754: LD_VAR 0 7
83758: ARRAY
83759: PUSH
83760: LD_INT 2
83762: ARRAY
83763: PPUSH
83764: CALL_OW 546
83768: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83769: LD_VAR 0 8
83773: PUSH
83774: LD_INT 1
83776: ARRAY
83777: PUSH
83778: LD_VAR 0 8
83782: PUSH
83783: LD_INT 2
83785: ARRAY
83786: PUSH
83787: LD_VAR 0 13
83791: PUSH
83792: LD_INT 2
83794: PLUS
83795: GREATER
83796: OR
83797: PUSH
83798: LD_VAR 0 8
83802: PUSH
83803: LD_INT 2
83805: ARRAY
83806: PUSH
83807: LD_VAR 0 13
83811: PUSH
83812: LD_INT 2
83814: MINUS
83815: LESS
83816: OR
83817: PUSH
83818: LD_VAR 0 8
83822: PUSH
83823: LD_INT 3
83825: ARRAY
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 8
83832: PUSH
83833: LD_INT 9
83835: PUSH
83836: LD_INT 10
83838: PUSH
83839: LD_INT 11
83841: PUSH
83842: LD_INT 12
83844: PUSH
83845: LD_INT 13
83847: PUSH
83848: LD_INT 16
83850: PUSH
83851: LD_INT 17
83853: PUSH
83854: LD_INT 18
83856: PUSH
83857: LD_INT 19
83859: PUSH
83860: LD_INT 20
83862: PUSH
83863: LD_INT 21
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: IN
83881: NOT
83882: OR
83883: PUSH
83884: LD_VAR 0 8
83888: PUSH
83889: LD_INT 5
83891: ARRAY
83892: NOT
83893: OR
83894: PUSH
83895: LD_VAR 0 8
83899: PUSH
83900: LD_INT 6
83902: ARRAY
83903: PUSH
83904: LD_INT 1
83906: PUSH
83907: LD_INT 2
83909: PUSH
83910: LD_INT 7
83912: PUSH
83913: LD_INT 9
83915: PUSH
83916: LD_INT 10
83918: PUSH
83919: LD_INT 11
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: IN
83930: NOT
83931: OR
83932: IFFALSE 83938
// exit ;
83934: POP
83935: POP
83936: GO 84021
// end ;
83938: GO 83609
83940: POP
83941: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83942: LD_VAR 0 9
83946: PPUSH
83947: LD_VAR 0 3
83951: PPUSH
83952: LD_VAR 0 4
83956: PPUSH
83957: LD_INT 20
83959: PPUSH
83960: CALL 75944 0 4
83964: PUSH
83965: LD_INT 4
83967: ARRAY
83968: IFFALSE 83972
// exit ;
83970: GO 84021
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83972: LD_VAR 0 2
83976: PUSH
83977: LD_INT 29
83979: PUSH
83980: LD_INT 30
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: IN
83987: PUSH
83988: LD_VAR 0 3
83992: PPUSH
83993: LD_VAR 0 4
83997: PPUSH
83998: LD_VAR 0 9
84002: PPUSH
84003: CALL_OW 440
84007: NOT
84008: AND
84009: IFFALSE 84013
// exit ;
84011: GO 84021
// result := true ;
84013: LD_ADDR_VAR 0 6
84017: PUSH
84018: LD_INT 1
84020: ST_TO_ADDR
// end ;
84021: LD_VAR 0 6
84025: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84026: LD_INT 0
84028: PPUSH
84029: PPUSH
84030: PPUSH
84031: PPUSH
84032: PPUSH
84033: PPUSH
84034: PPUSH
84035: PPUSH
84036: PPUSH
84037: PPUSH
84038: PPUSH
84039: PPUSH
84040: PPUSH
84041: PPUSH
84042: PPUSH
84043: PPUSH
84044: PPUSH
84045: PPUSH
84046: PPUSH
84047: PPUSH
84048: PPUSH
84049: PPUSH
84050: PPUSH
84051: PPUSH
84052: PPUSH
84053: PPUSH
84054: PPUSH
84055: PPUSH
84056: PPUSH
84057: PPUSH
84058: PPUSH
84059: PPUSH
84060: PPUSH
84061: PPUSH
84062: PPUSH
84063: PPUSH
84064: PPUSH
84065: PPUSH
84066: PPUSH
84067: PPUSH
84068: PPUSH
84069: PPUSH
84070: PPUSH
84071: PPUSH
84072: PPUSH
84073: PPUSH
84074: PPUSH
84075: PPUSH
84076: PPUSH
84077: PPUSH
84078: PPUSH
84079: PPUSH
84080: PPUSH
84081: PPUSH
84082: PPUSH
84083: PPUSH
84084: PPUSH
84085: PPUSH
// result = [ ] ;
84086: LD_ADDR_VAR 0 7
84090: PUSH
84091: EMPTY
84092: ST_TO_ADDR
// temp_list = [ ] ;
84093: LD_ADDR_VAR 0 9
84097: PUSH
84098: EMPTY
84099: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84100: LD_VAR 0 4
84104: PUSH
84105: LD_INT 0
84107: PUSH
84108: LD_INT 1
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: LD_INT 3
84116: PUSH
84117: LD_INT 4
84119: PUSH
84120: LD_INT 5
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: IN
84131: NOT
84132: PUSH
84133: LD_VAR 0 1
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: LD_INT 1
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: IN
84148: PUSH
84149: LD_VAR 0 5
84153: PUSH
84154: LD_INT 1
84156: PUSH
84157: LD_INT 2
84159: PUSH
84160: LD_INT 3
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: LIST
84167: IN
84168: NOT
84169: AND
84170: OR
84171: IFFALSE 84175
// exit ;
84173: GO 102566
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84175: LD_VAR 0 1
84179: PUSH
84180: LD_INT 6
84182: PUSH
84183: LD_INT 7
84185: PUSH
84186: LD_INT 8
84188: PUSH
84189: LD_INT 13
84191: PUSH
84192: LD_INT 12
84194: PUSH
84195: LD_INT 15
84197: PUSH
84198: LD_INT 11
84200: PUSH
84201: LD_INT 14
84203: PUSH
84204: LD_INT 10
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: IN
84218: IFFALSE 84228
// btype = b_lab ;
84220: LD_ADDR_VAR 0 1
84224: PUSH
84225: LD_INT 6
84227: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84228: LD_VAR 0 6
84232: PUSH
84233: LD_INT 0
84235: PUSH
84236: LD_INT 1
84238: PUSH
84239: LD_INT 2
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: LIST
84246: IN
84247: NOT
84248: PUSH
84249: LD_VAR 0 1
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: LD_INT 1
84259: PUSH
84260: LD_INT 2
84262: PUSH
84263: LD_INT 3
84265: PUSH
84266: LD_INT 6
84268: PUSH
84269: LD_INT 36
84271: PUSH
84272: LD_INT 4
84274: PUSH
84275: LD_INT 5
84277: PUSH
84278: LD_INT 31
84280: PUSH
84281: LD_INT 32
84283: PUSH
84284: LD_INT 33
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: IN
84300: NOT
84301: PUSH
84302: LD_VAR 0 6
84306: PUSH
84307: LD_INT 1
84309: EQUAL
84310: AND
84311: OR
84312: PUSH
84313: LD_VAR 0 1
84317: PUSH
84318: LD_INT 2
84320: PUSH
84321: LD_INT 3
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: IN
84328: NOT
84329: PUSH
84330: LD_VAR 0 6
84334: PUSH
84335: LD_INT 2
84337: EQUAL
84338: AND
84339: OR
84340: IFFALSE 84350
// mode = 0 ;
84342: LD_ADDR_VAR 0 6
84346: PUSH
84347: LD_INT 0
84349: ST_TO_ADDR
// case mode of 0 :
84350: LD_VAR 0 6
84354: PUSH
84355: LD_INT 0
84357: DOUBLE
84358: EQUAL
84359: IFTRUE 84363
84361: GO 95816
84363: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84364: LD_ADDR_VAR 0 11
84368: PUSH
84369: LD_INT 0
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 0
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: PUSH
84393: LD_INT 0
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: LD_INT 1
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 0
84412: PUSH
84413: LD_INT 1
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 1
84422: NEG
84423: PUSH
84424: LD_INT 0
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 1
84433: NEG
84434: PUSH
84435: LD_INT 1
84437: NEG
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 1
84445: NEG
84446: PUSH
84447: LD_INT 2
84449: NEG
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 0
84457: PUSH
84458: LD_INT 2
84460: NEG
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 1
84479: PUSH
84480: LD_INT 2
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 0
84489: PUSH
84490: LD_INT 2
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 1
84499: NEG
84500: PUSH
84501: LD_INT 1
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: LD_INT 1
84510: PUSH
84511: LD_INT 3
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: LD_INT 3
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 1
84530: NEG
84531: PUSH
84532: LD_INT 2
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84557: LD_ADDR_VAR 0 12
84561: PUSH
84562: LD_INT 0
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 0
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 1
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 1
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 0
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 1
84615: NEG
84616: PUSH
84617: LD_INT 0
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 1
84626: NEG
84627: PUSH
84628: LD_INT 1
84630: NEG
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 1
84638: PUSH
84639: LD_INT 1
84641: NEG
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 2
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 2
84659: PUSH
84660: LD_INT 1
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 1
84669: NEG
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 2
84680: NEG
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 2
84691: NEG
84692: PUSH
84693: LD_INT 1
84695: NEG
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 2
84703: NEG
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 3
84714: NEG
84715: PUSH
84716: LD_INT 0
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 3
84725: NEG
84726: PUSH
84727: LD_INT 1
84729: NEG
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84753: LD_ADDR_VAR 0 13
84757: PUSH
84758: LD_INT 0
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 0
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 0
84801: PUSH
84802: LD_INT 1
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: NEG
84812: PUSH
84813: LD_INT 0
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: NEG
84823: PUSH
84824: LD_INT 1
84826: NEG
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 1
84834: NEG
84835: PUSH
84836: LD_INT 2
84838: NEG
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 2
84846: PUSH
84847: LD_INT 1
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 2
84856: PUSH
84857: LD_INT 2
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 1
84866: PUSH
84867: LD_INT 2
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 2
84876: NEG
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: NEG
84889: PUSH
84890: LD_INT 2
84892: NEG
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: PUSH
84898: LD_INT 2
84900: NEG
84901: PUSH
84902: LD_INT 3
84904: NEG
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 3
84912: NEG
84913: PUSH
84914: LD_INT 2
84916: NEG
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 3
84924: NEG
84925: PUSH
84926: LD_INT 3
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84952: LD_ADDR_VAR 0 14
84956: PUSH
84957: LD_INT 0
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 0
84969: PUSH
84970: LD_INT 1
84972: NEG
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: LD_INT 0
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: LD_INT 1
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 1
85010: NEG
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 1
85021: NEG
85022: PUSH
85023: LD_INT 1
85025: NEG
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 1
85033: NEG
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 0
85045: PUSH
85046: LD_INT 2
85048: NEG
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PUSH
85054: LD_INT 1
85056: PUSH
85057: LD_INT 1
85059: NEG
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: LD_INT 1
85067: PUSH
85068: LD_INT 2
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: LD_INT 2
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: LD_INT 1
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 1
85098: NEG
85099: PUSH
85100: LD_INT 3
85102: NEG
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: PUSH
85108: LD_INT 0
85110: PUSH
85111: LD_INT 3
85113: NEG
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 1
85121: PUSH
85122: LD_INT 2
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85148: LD_ADDR_VAR 0 15
85152: PUSH
85153: LD_INT 0
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: LD_INT 1
85168: NEG
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: LD_INT 0
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 1
85186: PUSH
85187: LD_INT 1
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 0
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: LD_INT 0
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 1
85217: NEG
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 1
85229: PUSH
85230: LD_INT 1
85232: NEG
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: PUSH
85238: LD_INT 2
85240: PUSH
85241: LD_INT 0
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 2
85250: PUSH
85251: LD_INT 1
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 1
85260: NEG
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 2
85271: NEG
85272: PUSH
85273: LD_INT 0
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: PUSH
85280: LD_INT 2
85282: NEG
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 2
85294: PUSH
85295: LD_INT 1
85297: NEG
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_INT 3
85305: PUSH
85306: LD_INT 0
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 3
85315: PUSH
85316: LD_INT 1
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85341: LD_ADDR_VAR 0 16
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: LD_INT 0
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 0
85358: PUSH
85359: LD_INT 1
85361: NEG
85362: PUSH
85363: EMPTY
85364: LIST
85365: LIST
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: LD_INT 0
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: LD_INT 1
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 0
85389: PUSH
85390: LD_INT 1
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 1
85399: NEG
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 1
85410: NEG
85411: PUSH
85412: LD_INT 1
85414: NEG
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 1
85422: NEG
85423: PUSH
85424: LD_INT 2
85426: NEG
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: LD_INT 2
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: PUSH
85455: LD_INT 2
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 2
85464: NEG
85465: PUSH
85466: LD_INT 1
85468: NEG
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 2
85476: NEG
85477: PUSH
85478: LD_INT 2
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 3
85488: PUSH
85489: LD_INT 2
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 3
85498: PUSH
85499: LD_INT 3
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 2
85508: PUSH
85509: LD_INT 3
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85534: LD_ADDR_VAR 0 17
85538: PUSH
85539: LD_INT 0
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 0
85551: PUSH
85552: LD_INT 1
85554: NEG
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 1
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 1
85572: PUSH
85573: LD_INT 1
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 0
85582: PUSH
85583: LD_INT 1
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 1
85592: NEG
85593: PUSH
85594: LD_INT 0
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 1
85603: NEG
85604: PUSH
85605: LD_INT 1
85607: NEG
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 1
85615: NEG
85616: PUSH
85617: LD_INT 2
85619: NEG
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: PUSH
85625: LD_INT 0
85627: PUSH
85628: LD_INT 2
85630: NEG
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 1
85638: PUSH
85639: LD_INT 1
85641: NEG
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 2
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 2
85659: PUSH
85660: LD_INT 1
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: LD_INT 2
85669: PUSH
85670: LD_INT 2
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 1
85679: PUSH
85680: LD_INT 2
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 0
85689: PUSH
85690: LD_INT 2
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: LD_INT 1
85699: NEG
85700: PUSH
85701: LD_INT 1
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 2
85710: NEG
85711: PUSH
85712: LD_INT 0
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 2
85721: NEG
85722: PUSH
85723: LD_INT 1
85725: NEG
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 2
85733: NEG
85734: PUSH
85735: LD_INT 2
85737: NEG
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85764: LD_ADDR_VAR 0 18
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 0
85781: PUSH
85782: LD_INT 1
85784: NEG
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 0
85812: PUSH
85813: LD_INT 1
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: NEG
85823: PUSH
85824: LD_INT 0
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 1
85833: NEG
85834: PUSH
85835: LD_INT 1
85837: NEG
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 1
85845: NEG
85846: PUSH
85847: LD_INT 2
85849: NEG
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 0
85857: PUSH
85858: LD_INT 2
85860: NEG
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 1
85868: PUSH
85869: LD_INT 1
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 2
85879: PUSH
85880: LD_INT 0
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 2
85889: PUSH
85890: LD_INT 1
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 2
85899: PUSH
85900: LD_INT 2
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 0
85919: PUSH
85920: LD_INT 2
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 1
85929: NEG
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 2
85940: NEG
85941: PUSH
85942: LD_INT 0
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 2
85951: NEG
85952: PUSH
85953: LD_INT 1
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 2
85963: NEG
85964: PUSH
85965: LD_INT 2
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85994: LD_ADDR_VAR 0 19
85998: PUSH
85999: LD_INT 0
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 0
86011: PUSH
86012: LD_INT 1
86014: NEG
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 1
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 0
86042: PUSH
86043: LD_INT 1
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: NEG
86053: PUSH
86054: LD_INT 0
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 1
86063: NEG
86064: PUSH
86065: LD_INT 1
86067: NEG
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 1
86075: NEG
86076: PUSH
86077: LD_INT 2
86079: NEG
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 0
86087: PUSH
86088: LD_INT 2
86090: NEG
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 1
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 2
86109: PUSH
86110: LD_INT 0
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: PUSH
86130: LD_INT 2
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: LD_INT 2
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 2
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: NEG
86171: PUSH
86172: LD_INT 0
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 2
86181: NEG
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 2
86193: NEG
86194: PUSH
86195: LD_INT 2
86197: NEG
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86224: LD_ADDR_VAR 0 20
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: PUSH
86253: LD_INT 0
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: PUSH
86263: LD_INT 1
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 0
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: NEG
86283: PUSH
86284: LD_INT 0
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 1
86305: NEG
86306: PUSH
86307: LD_INT 2
86309: NEG
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 0
86317: PUSH
86318: LD_INT 2
86320: NEG
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: LD_INT 1
86331: NEG
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 0
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 2
86359: PUSH
86360: LD_INT 2
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: PUSH
86370: LD_INT 2
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 0
86379: PUSH
86380: LD_INT 2
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: NEG
86390: PUSH
86391: LD_INT 1
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 2
86400: NEG
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 1
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: LD_INT 2
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86454: LD_ADDR_VAR 0 21
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 0
86471: PUSH
86472: LD_INT 1
86474: NEG
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: LD_INT 0
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: LD_INT 1
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: LD_INT 1
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: LD_INT 0
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 1
86523: NEG
86524: PUSH
86525: LD_INT 1
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: LD_INT 2
86539: NEG
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 0
86547: PUSH
86548: LD_INT 2
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 1
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 2
86569: PUSH
86570: LD_INT 0
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 2
86579: PUSH
86580: LD_INT 1
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 2
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: LD_INT 2
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: LD_INT 2
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 1
86619: NEG
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 2
86630: NEG
86631: PUSH
86632: LD_INT 0
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: LD_INT 1
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: LD_INT 2
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86684: LD_ADDR_VAR 0 22
86688: PUSH
86689: LD_INT 0
86691: PUSH
86692: LD_INT 0
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: LD_INT 1
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 1
86712: PUSH
86713: LD_INT 0
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: PUSH
86723: LD_INT 1
86725: PUSH
86726: EMPTY
86727: LIST
86728: LIST
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: LD_INT 1
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: NEG
86743: PUSH
86744: LD_INT 0
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: LD_INT 1
86757: NEG
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 0
86777: PUSH
86778: LD_INT 2
86780: NEG
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 1
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 2
86799: PUSH
86800: LD_INT 0
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 2
86809: PUSH
86810: LD_INT 1
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: LD_INT 2
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 0
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: NEG
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: NEG
86861: PUSH
86862: LD_INT 0
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 2
86871: NEG
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 2
86883: NEG
86884: PUSH
86885: LD_INT 2
86887: NEG
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86914: LD_ADDR_VAR 0 23
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: LD_INT 0
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 0
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 1
86942: PUSH
86943: LD_INT 0
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 0
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: NEG
86973: PUSH
86974: LD_INT 0
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: LD_INT 2
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 0
87007: PUSH
87008: LD_INT 2
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 1
87018: PUSH
87019: LD_INT 1
87021: NEG
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 2
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 2
87039: PUSH
87040: LD_INT 1
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 2
87049: PUSH
87050: LD_INT 2
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: LD_INT 2
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: LD_INT 2
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: LD_INT 1
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 2
87090: NEG
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 2
87101: NEG
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 2
87113: NEG
87114: PUSH
87115: LD_INT 2
87117: NEG
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 2
87125: NEG
87126: PUSH
87127: LD_INT 3
87129: NEG
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 3
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: LD_INT 2
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 2
87160: PUSH
87161: LD_INT 1
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87194: LD_ADDR_VAR 0 24
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: LD_INT 0
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 0
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 0
87242: PUSH
87243: LD_INT 1
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 1
87252: NEG
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 1
87263: NEG
87264: PUSH
87265: LD_INT 1
87267: NEG
87268: PUSH
87269: EMPTY
87270: LIST
87271: LIST
87272: PUSH
87273: LD_INT 1
87275: NEG
87276: PUSH
87277: LD_INT 2
87279: NEG
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: LD_INT 2
87290: NEG
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: LD_INT 1
87301: NEG
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 2
87309: PUSH
87310: LD_INT 0
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 2
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 2
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 1
87339: PUSH
87340: LD_INT 2
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: LD_INT 2
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 2
87370: NEG
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: LD_INT 2
87381: NEG
87382: PUSH
87383: LD_INT 1
87385: NEG
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 2
87393: NEG
87394: PUSH
87395: LD_INT 2
87397: NEG
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 1
87405: PUSH
87406: LD_INT 2
87408: NEG
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 2
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 3
87427: PUSH
87428: LD_INT 1
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 3
87437: PUSH
87438: LD_INT 2
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87470: LD_ADDR_VAR 0 25
87474: PUSH
87475: LD_INT 0
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 0
87487: PUSH
87488: LD_INT 1
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 1
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 0
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: NEG
87529: PUSH
87530: LD_INT 0
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: LD_INT 1
87543: NEG
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: LD_INT 2
87555: NEG
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 0
87563: PUSH
87564: LD_INT 2
87566: NEG
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 1
87574: PUSH
87575: LD_INT 1
87577: NEG
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 2
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 2
87595: PUSH
87596: LD_INT 1
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 2
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 1
87615: PUSH
87616: LD_INT 2
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 0
87625: PUSH
87626: LD_INT 2
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 1
87635: NEG
87636: PUSH
87637: LD_INT 1
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 2
87646: NEG
87647: PUSH
87648: LD_INT 0
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 2
87657: NEG
87658: PUSH
87659: LD_INT 1
87661: NEG
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: NEG
87670: PUSH
87671: LD_INT 2
87673: NEG
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 3
87681: PUSH
87682: LD_INT 1
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 3
87691: PUSH
87692: LD_INT 2
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 2
87701: PUSH
87702: LD_INT 3
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 1
87711: PUSH
87712: LD_INT 3
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87744: LD_ADDR_VAR 0 26
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 1
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: LD_INT 1
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: LD_INT 1
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: LD_INT 2
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 0
87837: PUSH
87838: LD_INT 2
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 2
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 2
87879: PUSH
87880: LD_INT 2
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: LD_INT 2
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: NEG
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 2
87931: NEG
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 2
87943: NEG
87944: PUSH
87945: LD_INT 2
87947: NEG
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: PUSH
87953: LD_INT 2
87955: PUSH
87956: LD_INT 3
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: PUSH
87966: LD_INT 3
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 1
87975: NEG
87976: PUSH
87977: LD_INT 2
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: LD_INT 2
87986: NEG
87987: PUSH
87988: LD_INT 1
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88020: LD_ADDR_VAR 0 27
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: LD_INT 0
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: LD_INT 1
88040: NEG
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 1
88048: PUSH
88049: LD_INT 0
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: PUSH
88059: LD_INT 1
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 0
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 1
88078: NEG
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 1
88089: NEG
88090: PUSH
88091: LD_INT 1
88093: NEG
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 1
88101: NEG
88102: PUSH
88103: LD_INT 2
88105: NEG
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 0
88113: PUSH
88114: LD_INT 2
88116: NEG
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 1
88124: PUSH
88125: LD_INT 1
88127: NEG
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 2
88135: PUSH
88136: LD_INT 0
88138: PUSH
88139: EMPTY
88140: LIST
88141: LIST
88142: PUSH
88143: LD_INT 2
88145: PUSH
88146: LD_INT 1
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 2
88155: PUSH
88156: LD_INT 2
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: LD_INT 2
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 0
88175: PUSH
88176: LD_INT 2
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 1
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: PUSH
88194: LD_INT 2
88196: NEG
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 2
88207: NEG
88208: PUSH
88209: LD_INT 1
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 2
88219: NEG
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 2
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 2
88242: NEG
88243: PUSH
88244: LD_INT 1
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 3
88253: NEG
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 3
88265: NEG
88266: PUSH
88267: LD_INT 2
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88300: LD_ADDR_VAR 0 28
88304: PUSH
88305: LD_INT 0
88307: PUSH
88308: LD_INT 0
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: LD_INT 1
88320: NEG
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 1
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 0
88348: PUSH
88349: LD_INT 1
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: NEG
88359: PUSH
88360: LD_INT 0
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 1
88369: NEG
88370: PUSH
88371: LD_INT 1
88373: NEG
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 1
88381: NEG
88382: PUSH
88383: LD_INT 2
88385: NEG
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: LD_INT 0
88393: PUSH
88394: LD_INT 2
88396: NEG
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: LD_INT 1
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: LD_INT 2
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 2
88425: PUSH
88426: LD_INT 1
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: LD_INT 2
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 1
88445: PUSH
88446: LD_INT 2
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 0
88455: PUSH
88456: LD_INT 2
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: NEG
88466: PUSH
88467: LD_INT 1
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 2
88476: NEG
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 2
88487: NEG
88488: PUSH
88489: LD_INT 1
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 2
88499: NEG
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 2
88511: NEG
88512: PUSH
88513: LD_INT 3
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: LD_INT 3
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 3
88535: NEG
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 3
88547: NEG
88548: PUSH
88549: LD_INT 2
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88582: LD_ADDR_VAR 0 29
88586: PUSH
88587: LD_INT 0
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: LD_INT 1
88602: NEG
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 1
88610: PUSH
88611: LD_INT 0
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 1
88620: PUSH
88621: LD_INT 1
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 0
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: NEG
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 1
88651: NEG
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: NEG
88664: PUSH
88665: LD_INT 2
88667: NEG
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: PUSH
88687: LD_INT 1
88689: NEG
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: PUSH
88705: LD_INT 2
88707: PUSH
88708: LD_INT 1
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 1
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: LD_INT 2
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: PUSH
88735: LD_INT 1
88737: NEG
88738: PUSH
88739: LD_INT 1
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 2
88748: NEG
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 2
88760: NEG
88761: PUSH
88762: LD_INT 2
88764: NEG
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 2
88772: NEG
88773: PUSH
88774: LD_INT 3
88776: NEG
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 2
88784: PUSH
88785: LD_INT 1
88787: NEG
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 3
88795: PUSH
88796: LD_INT 1
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 1
88805: PUSH
88806: LD_INT 3
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: LD_INT 2
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 3
88826: NEG
88827: PUSH
88828: LD_INT 2
88830: NEG
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88861: LD_ADDR_VAR 0 30
88865: PUSH
88866: LD_INT 0
88868: PUSH
88869: LD_INT 0
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 0
88878: PUSH
88879: LD_INT 1
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 1
88899: PUSH
88900: LD_INT 1
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 0
88909: PUSH
88910: LD_INT 1
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PUSH
88917: LD_INT 1
88919: NEG
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 1
88930: NEG
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: NEG
88943: PUSH
88944: LD_INT 2
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 0
88954: PUSH
88955: LD_INT 2
88957: NEG
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 1
88965: PUSH
88966: LD_INT 1
88968: NEG
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 2
88976: PUSH
88977: LD_INT 0
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 2
88986: PUSH
88987: LD_INT 1
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 2
88996: PUSH
88997: LD_INT 2
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: LD_INT 2
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 1
89016: NEG
89017: PUSH
89018: LD_INT 1
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 2
89027: NEG
89028: PUSH
89029: LD_INT 0
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 2
89038: NEG
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 1
89050: NEG
89051: PUSH
89052: LD_INT 3
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: PUSH
89063: LD_INT 2
89065: NEG
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 3
89073: PUSH
89074: LD_INT 2
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: LD_INT 3
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 2
89093: NEG
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 3
89104: NEG
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89139: LD_ADDR_VAR 0 31
89143: PUSH
89144: LD_INT 0
89146: PUSH
89147: LD_INT 0
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: LD_INT 1
89159: NEG
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: LD_INT 1
89167: PUSH
89168: LD_INT 0
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 1
89177: PUSH
89178: LD_INT 1
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: PUSH
89185: LD_INT 0
89187: PUSH
89188: LD_INT 1
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: PUSH
89195: LD_INT 1
89197: NEG
89198: PUSH
89199: LD_INT 0
89201: PUSH
89202: EMPTY
89203: LIST
89204: LIST
89205: PUSH
89206: LD_INT 1
89208: NEG
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 1
89220: NEG
89221: PUSH
89222: LD_INT 2
89224: NEG
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 1
89232: PUSH
89233: LD_INT 1
89235: NEG
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 2
89243: PUSH
89244: LD_INT 0
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 2
89253: PUSH
89254: LD_INT 1
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 2
89263: PUSH
89264: LD_INT 2
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: LD_INT 2
89276: PUSH
89277: EMPTY
89278: LIST
89279: LIST
89280: PUSH
89281: LD_INT 0
89283: PUSH
89284: LD_INT 2
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 1
89293: NEG
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 2
89304: NEG
89305: PUSH
89306: LD_INT 1
89308: NEG
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 2
89316: NEG
89317: PUSH
89318: LD_INT 2
89320: NEG
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: LD_INT 3
89332: NEG
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: LD_INT 2
89340: PUSH
89341: LD_INT 1
89343: NEG
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 3
89351: PUSH
89352: LD_INT 1
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: LD_INT 3
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 1
89371: NEG
89372: PUSH
89373: LD_INT 2
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 3
89382: NEG
89383: PUSH
89384: LD_INT 2
89386: NEG
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89417: LD_ADDR_VAR 0 32
89421: PUSH
89422: LD_INT 0
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 0
89434: PUSH
89435: LD_INT 1
89437: NEG
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 1
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: LD_INT 1
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: LD_INT 0
89465: PUSH
89466: LD_INT 1
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 1
89475: NEG
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 1
89486: NEG
89487: PUSH
89488: LD_INT 1
89490: NEG
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 1
89498: NEG
89499: PUSH
89500: LD_INT 2
89502: NEG
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: LD_INT 0
89510: PUSH
89511: LD_INT 2
89513: NEG
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 1
89521: PUSH
89522: LD_INT 1
89524: NEG
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 2
89532: PUSH
89533: LD_INT 1
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 2
89542: PUSH
89543: LD_INT 2
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 1
89552: PUSH
89553: LD_INT 2
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: LD_INT 2
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: NEG
89573: PUSH
89574: LD_INT 1
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 2
89583: NEG
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 2
89594: NEG
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: NEG
89607: PUSH
89608: LD_INT 3
89610: NEG
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 1
89618: PUSH
89619: LD_INT 2
89621: NEG
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 3
89629: PUSH
89630: LD_INT 2
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 2
89639: PUSH
89640: LD_INT 3
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 2
89649: NEG
89650: PUSH
89651: LD_INT 1
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 3
89660: NEG
89661: PUSH
89662: LD_INT 1
89664: NEG
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89695: LD_ADDR_VAR 0 33
89699: PUSH
89700: LD_INT 0
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: LD_INT 1
89715: NEG
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: LD_INT 0
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: PUSH
89731: LD_INT 1
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: LD_INT 1
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 1
89753: NEG
89754: PUSH
89755: LD_INT 0
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: NEG
89765: PUSH
89766: LD_INT 1
89768: NEG
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: LD_INT 1
89776: NEG
89777: PUSH
89778: LD_INT 2
89780: NEG
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 1
89788: PUSH
89789: LD_INT 1
89791: NEG
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 2
89799: PUSH
89800: LD_INT 0
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: PUSH
89807: LD_INT 2
89809: PUSH
89810: LD_INT 1
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: LD_INT 1
89819: PUSH
89820: LD_INT 2
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 0
89829: PUSH
89830: LD_INT 2
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: NEG
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 2
89850: NEG
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 2
89861: NEG
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: EMPTY
89868: LIST
89869: LIST
89870: PUSH
89871: LD_INT 2
89873: NEG
89874: PUSH
89875: LD_INT 2
89877: NEG
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 2
89885: NEG
89886: PUSH
89887: LD_INT 3
89889: NEG
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 2
89897: PUSH
89898: LD_INT 1
89900: NEG
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 3
89908: PUSH
89909: LD_INT 1
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PUSH
89916: LD_INT 1
89918: PUSH
89919: LD_INT 3
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 1
89928: NEG
89929: PUSH
89930: LD_INT 2
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 3
89939: NEG
89940: PUSH
89941: LD_INT 2
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89974: LD_ADDR_VAR 0 34
89978: PUSH
89979: LD_INT 0
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 1
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: LD_INT 1
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 1
90032: NEG
90033: PUSH
90034: LD_INT 0
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 1
90043: NEG
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 1
90055: NEG
90056: PUSH
90057: LD_INT 2
90059: NEG
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 0
90067: PUSH
90068: LD_INT 2
90070: NEG
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 1
90078: PUSH
90079: LD_INT 1
90081: NEG
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: PUSH
90087: LD_INT 2
90089: PUSH
90090: LD_INT 1
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 2
90099: PUSH
90100: LD_INT 2
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 1
90109: PUSH
90110: LD_INT 2
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 1
90119: NEG
90120: PUSH
90121: LD_INT 1
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 2
90130: NEG
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 2
90141: NEG
90142: PUSH
90143: LD_INT 1
90145: NEG
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 2
90153: NEG
90154: PUSH
90155: LD_INT 2
90157: NEG
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: LD_INT 3
90169: NEG
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: PUSH
90175: LD_INT 1
90177: PUSH
90178: LD_INT 2
90180: NEG
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 3
90188: PUSH
90189: LD_INT 2
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 2
90198: PUSH
90199: LD_INT 3
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 2
90208: NEG
90209: PUSH
90210: LD_INT 1
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 3
90219: NEG
90220: PUSH
90221: LD_INT 1
90223: NEG
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90254: LD_ADDR_VAR 0 35
90258: PUSH
90259: LD_INT 0
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 0
90271: PUSH
90272: LD_INT 1
90274: NEG
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 1
90282: PUSH
90283: LD_INT 0
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 1
90292: PUSH
90293: LD_INT 1
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 0
90302: PUSH
90303: LD_INT 1
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 1
90312: NEG
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: NEG
90324: PUSH
90325: LD_INT 1
90327: NEG
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 2
90335: PUSH
90336: LD_INT 1
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 2
90345: NEG
90346: PUSH
90347: LD_INT 1
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90366: LD_ADDR_VAR 0 36
90370: PUSH
90371: LD_INT 0
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 1
90386: NEG
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 1
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 1
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 0
90414: PUSH
90415: LD_INT 1
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 1
90424: NEG
90425: PUSH
90426: LD_INT 0
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: LD_INT 1
90439: NEG
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: LD_INT 2
90451: NEG
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 1
90459: PUSH
90460: LD_INT 2
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90478: LD_ADDR_VAR 0 37
90482: PUSH
90483: LD_INT 0
90485: PUSH
90486: LD_INT 0
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 1
90498: NEG
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: PUSH
90504: LD_INT 1
90506: PUSH
90507: LD_INT 0
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 1
90516: PUSH
90517: LD_INT 1
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 0
90526: PUSH
90527: LD_INT 1
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: LD_INT 0
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: PUSH
90545: LD_INT 1
90547: NEG
90548: PUSH
90549: LD_INT 1
90551: NEG
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: LD_INT 1
90562: NEG
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 1
90570: NEG
90571: PUSH
90572: LD_INT 1
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90590: LD_ADDR_VAR 0 38
90594: PUSH
90595: LD_INT 0
90597: PUSH
90598: LD_INT 0
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: LD_INT 1
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 1
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 1
90628: PUSH
90629: LD_INT 1
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 0
90638: PUSH
90639: LD_INT 1
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 1
90648: NEG
90649: PUSH
90650: LD_INT 0
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 1
90659: NEG
90660: PUSH
90661: LD_INT 1
90663: NEG
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 2
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 2
90681: NEG
90682: PUSH
90683: LD_INT 1
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90702: LD_ADDR_VAR 0 39
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: LD_INT 0
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: LD_INT 0
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 1
90740: PUSH
90741: LD_INT 1
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 1
90760: NEG
90761: PUSH
90762: LD_INT 0
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: NEG
90784: PUSH
90785: LD_INT 2
90787: NEG
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 1
90795: PUSH
90796: LD_INT 2
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90814: LD_ADDR_VAR 0 40
90818: PUSH
90819: LD_INT 0
90821: PUSH
90822: LD_INT 0
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: LD_INT 1
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 1
90842: PUSH
90843: LD_INT 0
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 1
90852: PUSH
90853: LD_INT 1
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: LD_INT 1
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 1
90872: NEG
90873: PUSH
90874: LD_INT 0
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 1
90883: NEG
90884: PUSH
90885: LD_INT 1
90887: NEG
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 1
90895: PUSH
90896: LD_INT 1
90898: NEG
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 1
90906: NEG
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90926: LD_ADDR_VAR 0 41
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: LD_INT 0
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 0
90943: PUSH
90944: LD_INT 1
90946: NEG
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 1
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 1
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: LD_INT 1
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: PUSH
90982: LD_INT 1
90984: NEG
90985: PUSH
90986: LD_INT 0
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: LD_INT 1
90995: NEG
90996: PUSH
90997: LD_INT 1
90999: NEG
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 1
91007: NEG
91008: PUSH
91009: LD_INT 2
91011: NEG
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 1
91019: PUSH
91020: LD_INT 1
91022: NEG
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 2
91030: PUSH
91031: LD_INT 0
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 2
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 2
91050: PUSH
91051: LD_INT 2
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 1
91060: PUSH
91061: LD_INT 2
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: NEG
91071: PUSH
91072: LD_INT 1
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 2
91081: NEG
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 2
91092: NEG
91093: PUSH
91094: LD_INT 1
91096: NEG
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 2
91104: NEG
91105: PUSH
91106: LD_INT 2
91108: NEG
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: LD_INT 2
91116: NEG
91117: PUSH
91118: LD_INT 3
91120: NEG
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: LD_INT 1
91131: NEG
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 3
91139: PUSH
91140: LD_INT 0
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 3
91149: PUSH
91150: LD_INT 1
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 3
91159: PUSH
91160: LD_INT 2
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 3
91169: PUSH
91170: LD_INT 3
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: PUSH
91177: LD_INT 2
91179: PUSH
91180: LD_INT 3
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 2
91189: NEG
91190: PUSH
91191: LD_INT 1
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: PUSH
91198: LD_INT 3
91200: NEG
91201: PUSH
91202: LD_INT 0
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 3
91211: NEG
91212: PUSH
91213: LD_INT 1
91215: NEG
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 3
91223: NEG
91224: PUSH
91225: LD_INT 2
91227: NEG
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 3
91235: NEG
91236: PUSH
91237: LD_INT 3
91239: NEG
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91276: LD_ADDR_VAR 0 42
91280: PUSH
91281: LD_INT 0
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 0
91293: PUSH
91294: LD_INT 1
91296: NEG
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: PUSH
91305: LD_INT 0
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: PUSH
91312: LD_INT 1
91314: PUSH
91315: LD_INT 1
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: LD_INT 1
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: PUSH
91332: LD_INT 1
91334: NEG
91335: PUSH
91336: LD_INT 0
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PUSH
91343: LD_INT 1
91345: NEG
91346: PUSH
91347: LD_INT 1
91349: NEG
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 1
91357: NEG
91358: PUSH
91359: LD_INT 2
91361: NEG
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 0
91369: PUSH
91370: LD_INT 2
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 1
91380: PUSH
91381: LD_INT 1
91383: NEG
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PUSH
91389: LD_INT 2
91391: PUSH
91392: LD_INT 1
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 2
91401: PUSH
91402: LD_INT 2
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 1
91411: PUSH
91412: LD_INT 2
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 0
91421: PUSH
91422: LD_INT 2
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 1
91431: NEG
91432: PUSH
91433: LD_INT 1
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 2
91442: NEG
91443: PUSH
91444: LD_INT 1
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 2
91454: NEG
91455: PUSH
91456: LD_INT 2
91458: NEG
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 2
91466: NEG
91467: PUSH
91468: LD_INT 3
91470: NEG
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 1
91478: NEG
91479: PUSH
91480: LD_INT 3
91482: NEG
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 0
91490: PUSH
91491: LD_INT 3
91493: NEG
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: PUSH
91502: LD_INT 2
91504: NEG
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 3
91512: PUSH
91513: LD_INT 2
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 3
91522: PUSH
91523: LD_INT 3
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 2
91532: PUSH
91533: LD_INT 3
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 1
91542: PUSH
91543: LD_INT 3
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: LD_INT 3
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 1
91562: NEG
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: NEG
91574: PUSH
91575: LD_INT 2
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 3
91585: NEG
91586: PUSH
91587: LD_INT 3
91589: NEG
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91626: LD_ADDR_VAR 0 43
91630: PUSH
91631: LD_INT 0
91633: PUSH
91634: LD_INT 0
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: LD_INT 1
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 1
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 1
91664: PUSH
91665: LD_INT 1
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 0
91674: PUSH
91675: LD_INT 1
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: LD_INT 0
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: LD_INT 1
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 1
91707: NEG
91708: PUSH
91709: LD_INT 2
91711: NEG
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 0
91719: PUSH
91720: LD_INT 2
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 1
91730: PUSH
91731: LD_INT 1
91733: NEG
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: PUSH
91739: LD_INT 2
91741: PUSH
91742: LD_INT 0
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 2
91751: PUSH
91752: LD_INT 1
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: LD_INT 1
91761: PUSH
91762: LD_INT 2
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 0
91771: PUSH
91772: LD_INT 2
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: LD_INT 1
91781: NEG
91782: PUSH
91783: LD_INT 1
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: LD_INT 2
91792: NEG
91793: PUSH
91794: LD_INT 0
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 2
91803: NEG
91804: PUSH
91805: LD_INT 1
91807: NEG
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 1
91815: NEG
91816: PUSH
91817: LD_INT 3
91819: NEG
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: LD_INT 0
91827: PUSH
91828: LD_INT 3
91830: NEG
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 1
91838: PUSH
91839: LD_INT 2
91841: NEG
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: PUSH
91847: LD_INT 2
91849: PUSH
91850: LD_INT 1
91852: NEG
91853: PUSH
91854: EMPTY
91855: LIST
91856: LIST
91857: PUSH
91858: LD_INT 3
91860: PUSH
91861: LD_INT 0
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 3
91870: PUSH
91871: LD_INT 1
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 1
91880: PUSH
91881: LD_INT 3
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 0
91890: PUSH
91891: LD_INT 3
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 1
91900: NEG
91901: PUSH
91902: LD_INT 2
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 2
91911: NEG
91912: PUSH
91913: LD_INT 1
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 3
91922: NEG
91923: PUSH
91924: LD_INT 0
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 3
91933: NEG
91934: PUSH
91935: LD_INT 1
91937: NEG
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91974: LD_ADDR_VAR 0 44
91978: PUSH
91979: LD_INT 0
91981: PUSH
91982: LD_INT 0
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 0
91991: PUSH
91992: LD_INT 1
91994: NEG
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: PUSH
92000: LD_INT 1
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 1
92012: PUSH
92013: LD_INT 1
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: PUSH
92020: LD_INT 0
92022: PUSH
92023: LD_INT 1
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 1
92032: NEG
92033: PUSH
92034: LD_INT 0
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 1
92043: NEG
92044: PUSH
92045: LD_INT 1
92047: NEG
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 1
92055: NEG
92056: PUSH
92057: LD_INT 2
92059: NEG
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 1
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 2
92078: PUSH
92079: LD_INT 0
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 2
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 2
92098: PUSH
92099: LD_INT 2
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: PUSH
92109: LD_INT 2
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: LD_INT 1
92118: NEG
92119: PUSH
92120: LD_INT 1
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 2
92129: NEG
92130: PUSH
92131: LD_INT 0
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 2
92140: NEG
92141: PUSH
92142: LD_INT 1
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 2
92152: NEG
92153: PUSH
92154: LD_INT 2
92156: NEG
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PUSH
92162: LD_INT 2
92164: NEG
92165: PUSH
92166: LD_INT 3
92168: NEG
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 2
92176: PUSH
92177: LD_INT 1
92179: NEG
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: LD_INT 3
92187: PUSH
92188: LD_INT 0
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 3
92197: PUSH
92198: LD_INT 1
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 3
92207: PUSH
92208: LD_INT 2
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 3
92217: PUSH
92218: LD_INT 3
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 2
92227: PUSH
92228: LD_INT 3
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 2
92237: NEG
92238: PUSH
92239: LD_INT 1
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 3
92248: NEG
92249: PUSH
92250: LD_INT 0
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 3
92259: NEG
92260: PUSH
92261: LD_INT 1
92263: NEG
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 3
92271: NEG
92272: PUSH
92273: LD_INT 2
92275: NEG
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: PUSH
92281: LD_INT 3
92283: NEG
92284: PUSH
92285: LD_INT 3
92287: NEG
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92324: LD_ADDR_VAR 0 45
92328: PUSH
92329: LD_INT 0
92331: PUSH
92332: LD_INT 0
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 0
92341: PUSH
92342: LD_INT 1
92344: NEG
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 1
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 1
92362: PUSH
92363: LD_INT 1
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: LD_INT 0
92372: PUSH
92373: LD_INT 1
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 1
92382: NEG
92383: PUSH
92384: LD_INT 0
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 1
92393: NEG
92394: PUSH
92395: LD_INT 1
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 1
92405: NEG
92406: PUSH
92407: LD_INT 2
92409: NEG
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 0
92417: PUSH
92418: LD_INT 2
92420: NEG
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 1
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: LD_INT 1
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 2
92449: PUSH
92450: LD_INT 2
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 1
92459: PUSH
92460: LD_INT 2
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 0
92469: PUSH
92470: LD_INT 2
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 1
92479: NEG
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: PUSH
92488: LD_INT 2
92490: NEG
92491: PUSH
92492: LD_INT 1
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 2
92502: NEG
92503: PUSH
92504: LD_INT 2
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 2
92514: NEG
92515: PUSH
92516: LD_INT 3
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: NEG
92527: PUSH
92528: LD_INT 3
92530: NEG
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 0
92538: PUSH
92539: LD_INT 3
92541: NEG
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 1
92549: PUSH
92550: LD_INT 2
92552: NEG
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 3
92560: PUSH
92561: LD_INT 2
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 3
92570: PUSH
92571: LD_INT 3
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 2
92580: PUSH
92581: LD_INT 3
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: LD_INT 3
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: LD_INT 3
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 1
92610: NEG
92611: PUSH
92612: LD_INT 2
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 3
92621: NEG
92622: PUSH
92623: LD_INT 2
92625: NEG
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 3
92633: NEG
92634: PUSH
92635: LD_INT 3
92637: NEG
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92674: LD_ADDR_VAR 0 46
92678: PUSH
92679: LD_INT 0
92681: PUSH
92682: LD_INT 0
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: PUSH
92689: LD_INT 0
92691: PUSH
92692: LD_INT 1
92694: NEG
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 1
92702: PUSH
92703: LD_INT 0
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 1
92712: PUSH
92713: LD_INT 1
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 0
92722: PUSH
92723: LD_INT 1
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 1
92732: NEG
92733: PUSH
92734: LD_INT 0
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: LD_INT 1
92747: NEG
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 1
92755: NEG
92756: PUSH
92757: LD_INT 2
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 0
92767: PUSH
92768: LD_INT 2
92770: NEG
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 1
92778: PUSH
92779: LD_INT 1
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 2
92789: PUSH
92790: LD_INT 0
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 2
92799: PUSH
92800: LD_INT 1
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: PUSH
92807: LD_INT 1
92809: PUSH
92810: LD_INT 2
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 0
92819: PUSH
92820: LD_INT 2
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 1
92829: NEG
92830: PUSH
92831: LD_INT 1
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 2
92840: NEG
92841: PUSH
92842: LD_INT 0
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 2
92851: NEG
92852: PUSH
92853: LD_INT 1
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: NEG
92864: PUSH
92865: LD_INT 3
92867: NEG
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 0
92875: PUSH
92876: LD_INT 3
92878: NEG
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 1
92886: PUSH
92887: LD_INT 2
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 2
92897: PUSH
92898: LD_INT 1
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 3
92908: PUSH
92909: LD_INT 0
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 3
92918: PUSH
92919: LD_INT 1
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: PUSH
92926: LD_INT 1
92928: PUSH
92929: LD_INT 3
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: PUSH
92936: LD_INT 0
92938: PUSH
92939: LD_INT 3
92941: PUSH
92942: EMPTY
92943: LIST
92944: LIST
92945: PUSH
92946: LD_INT 1
92948: NEG
92949: PUSH
92950: LD_INT 2
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 2
92959: NEG
92960: PUSH
92961: LD_INT 1
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 3
92970: NEG
92971: PUSH
92972: LD_INT 0
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 3
92981: NEG
92982: PUSH
92983: LD_INT 1
92985: NEG
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93022: LD_ADDR_VAR 0 47
93026: PUSH
93027: LD_INT 0
93029: PUSH
93030: LD_INT 0
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 0
93039: PUSH
93040: LD_INT 1
93042: NEG
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 1
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 1
93060: PUSH
93061: LD_INT 1
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 0
93070: PUSH
93071: LD_INT 1
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: LD_INT 0
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 1
93091: NEG
93092: PUSH
93093: LD_INT 1
93095: NEG
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 1
93103: NEG
93104: PUSH
93105: LD_INT 2
93107: NEG
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 0
93115: PUSH
93116: LD_INT 2
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 1
93126: PUSH
93127: LD_INT 1
93129: NEG
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 2
93137: NEG
93138: PUSH
93139: LD_INT 1
93141: NEG
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 2
93149: NEG
93150: PUSH
93151: LD_INT 2
93153: NEG
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93173: LD_ADDR_VAR 0 48
93177: PUSH
93178: LD_INT 0
93180: PUSH
93181: LD_INT 0
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 0
93190: PUSH
93191: LD_INT 1
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 1
93201: PUSH
93202: LD_INT 0
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 1
93211: PUSH
93212: LD_INT 1
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: PUSH
93219: LD_INT 0
93221: PUSH
93222: LD_INT 1
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 1
93231: NEG
93232: PUSH
93233: LD_INT 0
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 1
93242: NEG
93243: PUSH
93244: LD_INT 1
93246: NEG
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PUSH
93252: LD_INT 1
93254: NEG
93255: PUSH
93256: LD_INT 2
93258: NEG
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 0
93266: PUSH
93267: LD_INT 2
93269: NEG
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: LD_INT 1
93280: NEG
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: PUSH
93286: LD_INT 2
93288: PUSH
93289: LD_INT 0
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: LD_INT 2
93298: PUSH
93299: LD_INT 1
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93320: LD_ADDR_VAR 0 49
93324: PUSH
93325: LD_INT 0
93327: PUSH
93328: LD_INT 0
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 0
93337: PUSH
93338: LD_INT 1
93340: NEG
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 1
93348: PUSH
93349: LD_INT 0
93351: PUSH
93352: EMPTY
93353: LIST
93354: LIST
93355: PUSH
93356: LD_INT 1
93358: PUSH
93359: LD_INT 1
93361: PUSH
93362: EMPTY
93363: LIST
93364: LIST
93365: PUSH
93366: LD_INT 0
93368: PUSH
93369: LD_INT 1
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: PUSH
93376: LD_INT 1
93378: NEG
93379: PUSH
93380: LD_INT 0
93382: PUSH
93383: EMPTY
93384: LIST
93385: LIST
93386: PUSH
93387: LD_INT 1
93389: NEG
93390: PUSH
93391: LD_INT 1
93393: NEG
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 1
93401: PUSH
93402: LD_INT 1
93404: NEG
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 2
93412: PUSH
93413: LD_INT 0
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 2
93422: PUSH
93423: LD_INT 1
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 2
93432: PUSH
93433: LD_INT 2
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 1
93442: PUSH
93443: LD_INT 2
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93464: LD_ADDR_VAR 0 50
93468: PUSH
93469: LD_INT 0
93471: PUSH
93472: LD_INT 0
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 0
93481: PUSH
93482: LD_INT 1
93484: NEG
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: LD_INT 0
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 1
93502: PUSH
93503: LD_INT 1
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 0
93512: PUSH
93513: LD_INT 1
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 1
93522: NEG
93523: PUSH
93524: LD_INT 0
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 1
93533: NEG
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 2
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 2
93555: PUSH
93556: LD_INT 2
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: LD_INT 1
93565: PUSH
93566: LD_INT 2
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: LD_INT 0
93575: PUSH
93576: LD_INT 2
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 1
93585: NEG
93586: PUSH
93587: LD_INT 1
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93608: LD_ADDR_VAR 0 51
93612: PUSH
93613: LD_INT 0
93615: PUSH
93616: LD_INT 0
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 0
93625: PUSH
93626: LD_INT 1
93628: NEG
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 1
93636: PUSH
93637: LD_INT 0
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 1
93646: PUSH
93647: LD_INT 1
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: LD_INT 1
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 1
93666: NEG
93667: PUSH
93668: LD_INT 0
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 1
93677: NEG
93678: PUSH
93679: LD_INT 1
93681: NEG
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 1
93689: PUSH
93690: LD_INT 2
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 0
93699: PUSH
93700: LD_INT 2
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 1
93709: NEG
93710: PUSH
93711: LD_INT 1
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 2
93720: NEG
93721: PUSH
93722: LD_INT 0
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 2
93731: NEG
93732: PUSH
93733: LD_INT 1
93735: NEG
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: EMPTY
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93755: LD_ADDR_VAR 0 52
93759: PUSH
93760: LD_INT 0
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 0
93772: PUSH
93773: LD_INT 1
93775: NEG
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 1
93783: PUSH
93784: LD_INT 0
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 1
93793: PUSH
93794: LD_INT 1
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 0
93803: PUSH
93804: LD_INT 1
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: PUSH
93811: LD_INT 1
93813: NEG
93814: PUSH
93815: LD_INT 0
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 1
93824: NEG
93825: PUSH
93826: LD_INT 1
93828: NEG
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: LD_INT 2
93840: NEG
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 1
93848: NEG
93849: PUSH
93850: LD_INT 1
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 2
93859: NEG
93860: PUSH
93861: LD_INT 0
93863: PUSH
93864: EMPTY
93865: LIST
93866: LIST
93867: PUSH
93868: LD_INT 2
93870: NEG
93871: PUSH
93872: LD_INT 1
93874: NEG
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 2
93882: NEG
93883: PUSH
93884: LD_INT 2
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93906: LD_ADDR_VAR 0 53
93910: PUSH
93911: LD_INT 0
93913: PUSH
93914: LD_INT 0
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 0
93923: PUSH
93924: LD_INT 1
93926: NEG
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 1
93934: PUSH
93935: LD_INT 0
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 1
93944: PUSH
93945: LD_INT 1
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 0
93954: PUSH
93955: LD_INT 1
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 1
93964: NEG
93965: PUSH
93966: LD_INT 0
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 1
93975: NEG
93976: PUSH
93977: LD_INT 1
93979: NEG
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 1
93987: NEG
93988: PUSH
93989: LD_INT 2
93991: NEG
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: PUSH
93997: LD_INT 0
93999: PUSH
94000: LD_INT 2
94002: NEG
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 1
94010: PUSH
94011: LD_INT 1
94013: NEG
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 2
94021: PUSH
94022: LD_INT 0
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 2
94031: PUSH
94032: LD_INT 1
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 2
94041: PUSH
94042: LD_INT 2
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 1
94051: PUSH
94052: LD_INT 2
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 0
94061: PUSH
94062: LD_INT 2
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 1
94071: NEG
94072: PUSH
94073: LD_INT 1
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 2
94082: NEG
94083: PUSH
94084: LD_INT 0
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 2
94093: NEG
94094: PUSH
94095: LD_INT 1
94097: NEG
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 2
94105: NEG
94106: PUSH
94107: LD_INT 2
94109: NEG
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94136: LD_ADDR_VAR 0 54
94140: PUSH
94141: LD_INT 0
94143: PUSH
94144: LD_INT 0
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 0
94153: PUSH
94154: LD_INT 1
94156: NEG
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 1
94164: PUSH
94165: LD_INT 0
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 1
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 0
94184: PUSH
94185: LD_INT 1
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 1
94194: NEG
94195: PUSH
94196: LD_INT 0
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 1
94205: NEG
94206: PUSH
94207: LD_INT 1
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 1
94217: NEG
94218: PUSH
94219: LD_INT 2
94221: NEG
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 0
94229: PUSH
94230: LD_INT 2
94232: NEG
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 1
94240: PUSH
94241: LD_INT 1
94243: NEG
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: PUSH
94249: LD_INT 2
94251: PUSH
94252: LD_INT 0
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PUSH
94259: LD_INT 2
94261: PUSH
94262: LD_INT 1
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: PUSH
94269: LD_INT 2
94271: PUSH
94272: LD_INT 2
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: LD_INT 1
94281: PUSH
94282: LD_INT 2
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 0
94291: PUSH
94292: LD_INT 2
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 1
94301: NEG
94302: PUSH
94303: LD_INT 1
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 2
94312: NEG
94313: PUSH
94314: LD_INT 0
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 2
94323: NEG
94324: PUSH
94325: LD_INT 1
94327: NEG
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 2
94335: NEG
94336: PUSH
94337: LD_INT 2
94339: NEG
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94366: LD_ADDR_VAR 0 55
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: LD_INT 0
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 0
94383: PUSH
94384: LD_INT 1
94386: NEG
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: LD_INT 1
94394: PUSH
94395: LD_INT 0
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 1
94404: PUSH
94405: LD_INT 1
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 0
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 1
94424: NEG
94425: PUSH
94426: LD_INT 0
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 1
94435: NEG
94436: PUSH
94437: LD_INT 1
94439: NEG
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 1
94447: NEG
94448: PUSH
94449: LD_INT 2
94451: NEG
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 0
94459: PUSH
94460: LD_INT 2
94462: NEG
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 1
94470: PUSH
94471: LD_INT 1
94473: NEG
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 2
94481: PUSH
94482: LD_INT 0
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 2
94491: PUSH
94492: LD_INT 1
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 2
94501: PUSH
94502: LD_INT 2
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 1
94511: PUSH
94512: LD_INT 2
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 0
94521: PUSH
94522: LD_INT 2
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 1
94531: NEG
94532: PUSH
94533: LD_INT 1
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 2
94542: NEG
94543: PUSH
94544: LD_INT 0
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 2
94553: NEG
94554: PUSH
94555: LD_INT 1
94557: NEG
94558: PUSH
94559: EMPTY
94560: LIST
94561: LIST
94562: PUSH
94563: LD_INT 2
94565: NEG
94566: PUSH
94567: LD_INT 2
94569: NEG
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94596: LD_ADDR_VAR 0 56
94600: PUSH
94601: LD_INT 0
94603: PUSH
94604: LD_INT 0
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: PUSH
94611: LD_INT 0
94613: PUSH
94614: LD_INT 1
94616: NEG
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 1
94624: PUSH
94625: LD_INT 0
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 1
94634: PUSH
94635: LD_INT 1
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 0
94644: PUSH
94645: LD_INT 1
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 1
94654: NEG
94655: PUSH
94656: LD_INT 0
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 1
94665: NEG
94666: PUSH
94667: LD_INT 1
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 1
94677: NEG
94678: PUSH
94679: LD_INT 2
94681: NEG
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 0
94689: PUSH
94690: LD_INT 2
94692: NEG
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: LD_INT 1
94703: NEG
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: PUSH
94709: LD_INT 2
94711: PUSH
94712: LD_INT 0
94714: PUSH
94715: EMPTY
94716: LIST
94717: LIST
94718: PUSH
94719: LD_INT 2
94721: PUSH
94722: LD_INT 1
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: LD_INT 2
94731: PUSH
94732: LD_INT 2
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: LD_INT 2
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: PUSH
94749: LD_INT 0
94751: PUSH
94752: LD_INT 2
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 1
94761: NEG
94762: PUSH
94763: LD_INT 1
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 2
94772: NEG
94773: PUSH
94774: LD_INT 0
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: PUSH
94781: LD_INT 2
94783: NEG
94784: PUSH
94785: LD_INT 1
94787: NEG
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 2
94795: NEG
94796: PUSH
94797: LD_INT 2
94799: NEG
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94826: LD_ADDR_VAR 0 57
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: LD_INT 0
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: PUSH
94841: LD_INT 0
94843: PUSH
94844: LD_INT 1
94846: NEG
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 1
94854: PUSH
94855: LD_INT 0
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 1
94864: PUSH
94865: LD_INT 1
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 0
94874: PUSH
94875: LD_INT 1
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 1
94884: NEG
94885: PUSH
94886: LD_INT 0
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 1
94895: NEG
94896: PUSH
94897: LD_INT 1
94899: NEG
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 1
94907: NEG
94908: PUSH
94909: LD_INT 2
94911: NEG
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 0
94919: PUSH
94920: LD_INT 2
94922: NEG
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 1
94930: PUSH
94931: LD_INT 1
94933: NEG
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 2
94941: PUSH
94942: LD_INT 0
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 2
94951: PUSH
94952: LD_INT 1
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: PUSH
94959: LD_INT 2
94961: PUSH
94962: LD_INT 2
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 1
94971: PUSH
94972: LD_INT 2
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: LD_INT 0
94981: PUSH
94982: LD_INT 2
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 1
94991: NEG
94992: PUSH
94993: LD_INT 1
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 2
95002: NEG
95003: PUSH
95004: LD_INT 0
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 2
95013: NEG
95014: PUSH
95015: LD_INT 1
95017: NEG
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 2
95025: NEG
95026: PUSH
95027: LD_INT 2
95029: NEG
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95056: LD_ADDR_VAR 0 58
95060: PUSH
95061: LD_INT 0
95063: PUSH
95064: LD_INT 0
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: LD_INT 0
95073: PUSH
95074: LD_INT 1
95076: NEG
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 1
95084: PUSH
95085: LD_INT 0
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 1
95094: PUSH
95095: LD_INT 1
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 0
95104: PUSH
95105: LD_INT 1
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 1
95114: NEG
95115: PUSH
95116: LD_INT 0
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 1
95125: NEG
95126: PUSH
95127: LD_INT 1
95129: NEG
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: PUSH
95135: LD_INT 1
95137: NEG
95138: PUSH
95139: LD_INT 2
95141: NEG
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: LD_INT 0
95149: PUSH
95150: LD_INT 2
95152: NEG
95153: PUSH
95154: EMPTY
95155: LIST
95156: LIST
95157: PUSH
95158: LD_INT 1
95160: PUSH
95161: LD_INT 1
95163: NEG
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: PUSH
95169: LD_INT 2
95171: PUSH
95172: LD_INT 0
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 2
95181: PUSH
95182: LD_INT 1
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 2
95191: PUSH
95192: LD_INT 2
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 0
95211: PUSH
95212: LD_INT 2
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 1
95221: NEG
95222: PUSH
95223: LD_INT 1
95225: PUSH
95226: EMPTY
95227: LIST
95228: LIST
95229: PUSH
95230: LD_INT 2
95232: NEG
95233: PUSH
95234: LD_INT 0
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PUSH
95241: LD_INT 2
95243: NEG
95244: PUSH
95245: LD_INT 1
95247: NEG
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 2
95255: NEG
95256: PUSH
95257: LD_INT 2
95259: NEG
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95286: LD_ADDR_VAR 0 59
95290: PUSH
95291: LD_INT 0
95293: PUSH
95294: LD_INT 0
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 0
95303: PUSH
95304: LD_INT 1
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 1
95314: PUSH
95315: LD_INT 0
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PUSH
95322: LD_INT 1
95324: PUSH
95325: LD_INT 1
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 0
95334: PUSH
95335: LD_INT 1
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: PUSH
95342: LD_INT 1
95344: NEG
95345: PUSH
95346: LD_INT 0
95348: PUSH
95349: EMPTY
95350: LIST
95351: LIST
95352: PUSH
95353: LD_INT 1
95355: NEG
95356: PUSH
95357: LD_INT 1
95359: NEG
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95374: LD_ADDR_VAR 0 60
95378: PUSH
95379: LD_INT 0
95381: PUSH
95382: LD_INT 0
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PUSH
95389: LD_INT 0
95391: PUSH
95392: LD_INT 1
95394: NEG
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 1
95402: PUSH
95403: LD_INT 0
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 1
95412: PUSH
95413: LD_INT 1
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 0
95422: PUSH
95423: LD_INT 1
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 1
95432: NEG
95433: PUSH
95434: LD_INT 0
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: LD_INT 1
95447: NEG
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95462: LD_ADDR_VAR 0 61
95466: PUSH
95467: LD_INT 0
95469: PUSH
95470: LD_INT 0
95472: PUSH
95473: EMPTY
95474: LIST
95475: LIST
95476: PUSH
95477: LD_INT 0
95479: PUSH
95480: LD_INT 1
95482: NEG
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 1
95490: PUSH
95491: LD_INT 0
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 1
95500: PUSH
95501: LD_INT 1
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 0
95510: PUSH
95511: LD_INT 1
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 1
95520: NEG
95521: PUSH
95522: LD_INT 0
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: PUSH
95529: LD_INT 1
95531: NEG
95532: PUSH
95533: LD_INT 1
95535: NEG
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95550: LD_ADDR_VAR 0 62
95554: PUSH
95555: LD_INT 0
95557: PUSH
95558: LD_INT 0
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 0
95567: PUSH
95568: LD_INT 1
95570: NEG
95571: PUSH
95572: EMPTY
95573: LIST
95574: LIST
95575: PUSH
95576: LD_INT 1
95578: PUSH
95579: LD_INT 0
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: PUSH
95586: LD_INT 1
95588: PUSH
95589: LD_INT 1
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 0
95598: PUSH
95599: LD_INT 1
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: LD_INT 1
95608: NEG
95609: PUSH
95610: LD_INT 0
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 1
95619: NEG
95620: PUSH
95621: LD_INT 1
95623: NEG
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95638: LD_ADDR_VAR 0 63
95642: PUSH
95643: LD_INT 0
95645: PUSH
95646: LD_INT 0
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 0
95655: PUSH
95656: LD_INT 1
95658: NEG
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 1
95666: PUSH
95667: LD_INT 0
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: LD_INT 1
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 0
95686: PUSH
95687: LD_INT 1
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 1
95696: NEG
95697: PUSH
95698: LD_INT 0
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 1
95707: NEG
95708: PUSH
95709: LD_INT 1
95711: NEG
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: PUSH
95717: EMPTY
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95726: LD_ADDR_VAR 0 64
95730: PUSH
95731: LD_INT 0
95733: PUSH
95734: LD_INT 0
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: PUSH
95741: LD_INT 0
95743: PUSH
95744: LD_INT 1
95746: NEG
95747: PUSH
95748: EMPTY
95749: LIST
95750: LIST
95751: PUSH
95752: LD_INT 1
95754: PUSH
95755: LD_INT 0
95757: PUSH
95758: EMPTY
95759: LIST
95760: LIST
95761: PUSH
95762: LD_INT 1
95764: PUSH
95765: LD_INT 1
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_INT 0
95774: PUSH
95775: LD_INT 1
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: PUSH
95782: LD_INT 1
95784: NEG
95785: PUSH
95786: LD_INT 0
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: PUSH
95793: LD_INT 1
95795: NEG
95796: PUSH
95797: LD_INT 1
95799: NEG
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: ST_TO_ADDR
// end ; 1 :
95814: GO 101711
95816: LD_INT 1
95818: DOUBLE
95819: EQUAL
95820: IFTRUE 95824
95822: GO 98447
95824: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95825: LD_ADDR_VAR 0 11
95829: PUSH
95830: LD_INT 1
95832: NEG
95833: PUSH
95834: LD_INT 3
95836: NEG
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 0
95844: PUSH
95845: LD_INT 3
95847: NEG
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 1
95855: PUSH
95856: LD_INT 2
95858: NEG
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: LIST
95868: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95869: LD_ADDR_VAR 0 12
95873: PUSH
95874: LD_INT 2
95876: PUSH
95877: LD_INT 1
95879: NEG
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 3
95887: PUSH
95888: LD_INT 0
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 3
95897: PUSH
95898: LD_INT 1
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: LIST
95909: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95910: LD_ADDR_VAR 0 13
95914: PUSH
95915: LD_INT 3
95917: PUSH
95918: LD_INT 2
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 3
95927: PUSH
95928: LD_INT 3
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 2
95937: PUSH
95938: LD_INT 3
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: LIST
95949: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95950: LD_ADDR_VAR 0 14
95954: PUSH
95955: LD_INT 1
95957: PUSH
95958: LD_INT 3
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 0
95967: PUSH
95968: LD_INT 3
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 1
95977: NEG
95978: PUSH
95979: LD_INT 2
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: LIST
95990: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95991: LD_ADDR_VAR 0 15
95995: PUSH
95996: LD_INT 2
95998: NEG
95999: PUSH
96000: LD_INT 1
96002: PUSH
96003: EMPTY
96004: LIST
96005: LIST
96006: PUSH
96007: LD_INT 3
96009: NEG
96010: PUSH
96011: LD_INT 0
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 3
96020: NEG
96021: PUSH
96022: LD_INT 1
96024: NEG
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: LIST
96034: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96035: LD_ADDR_VAR 0 16
96039: PUSH
96040: LD_INT 2
96042: NEG
96043: PUSH
96044: LD_INT 3
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 3
96054: NEG
96055: PUSH
96056: LD_INT 2
96058: NEG
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 3
96066: NEG
96067: PUSH
96068: LD_INT 3
96070: NEG
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: LIST
96080: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96081: LD_ADDR_VAR 0 17
96085: PUSH
96086: LD_INT 1
96088: NEG
96089: PUSH
96090: LD_INT 3
96092: NEG
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 0
96100: PUSH
96101: LD_INT 3
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 1
96111: PUSH
96112: LD_INT 2
96114: NEG
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: LIST
96124: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96125: LD_ADDR_VAR 0 18
96129: PUSH
96130: LD_INT 2
96132: PUSH
96133: LD_INT 1
96135: NEG
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 3
96143: PUSH
96144: LD_INT 0
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 3
96153: PUSH
96154: LD_INT 1
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: LIST
96165: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96166: LD_ADDR_VAR 0 19
96170: PUSH
96171: LD_INT 3
96173: PUSH
96174: LD_INT 2
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 3
96183: PUSH
96184: LD_INT 3
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 2
96193: PUSH
96194: LD_INT 3
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: LIST
96205: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96206: LD_ADDR_VAR 0 20
96210: PUSH
96211: LD_INT 1
96213: PUSH
96214: LD_INT 3
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 0
96223: PUSH
96224: LD_INT 3
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 1
96233: NEG
96234: PUSH
96235: LD_INT 2
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: LIST
96246: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96247: LD_ADDR_VAR 0 21
96251: PUSH
96252: LD_INT 2
96254: NEG
96255: PUSH
96256: LD_INT 1
96258: PUSH
96259: EMPTY
96260: LIST
96261: LIST
96262: PUSH
96263: LD_INT 3
96265: NEG
96266: PUSH
96267: LD_INT 0
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 3
96276: NEG
96277: PUSH
96278: LD_INT 1
96280: NEG
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96291: LD_ADDR_VAR 0 22
96295: PUSH
96296: LD_INT 2
96298: NEG
96299: PUSH
96300: LD_INT 3
96302: NEG
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: PUSH
96308: LD_INT 3
96310: NEG
96311: PUSH
96312: LD_INT 2
96314: NEG
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: PUSH
96320: LD_INT 3
96322: NEG
96323: PUSH
96324: LD_INT 3
96326: NEG
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: LIST
96336: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96337: LD_ADDR_VAR 0 23
96341: PUSH
96342: LD_INT 0
96344: PUSH
96345: LD_INT 3
96347: NEG
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 1
96355: NEG
96356: PUSH
96357: LD_INT 4
96359: NEG
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: PUSH
96365: LD_INT 1
96367: PUSH
96368: LD_INT 3
96370: NEG
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: LIST
96380: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96381: LD_ADDR_VAR 0 24
96385: PUSH
96386: LD_INT 3
96388: PUSH
96389: LD_INT 0
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 3
96398: PUSH
96399: LD_INT 1
96401: NEG
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: PUSH
96407: LD_INT 4
96409: PUSH
96410: LD_INT 1
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: LIST
96421: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96422: LD_ADDR_VAR 0 25
96426: PUSH
96427: LD_INT 3
96429: PUSH
96430: LD_INT 3
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 4
96439: PUSH
96440: LD_INT 3
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 3
96449: PUSH
96450: LD_INT 4
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: LIST
96461: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96462: LD_ADDR_VAR 0 26
96466: PUSH
96467: LD_INT 0
96469: PUSH
96470: LD_INT 3
96472: PUSH
96473: EMPTY
96474: LIST
96475: LIST
96476: PUSH
96477: LD_INT 1
96479: PUSH
96480: LD_INT 4
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PUSH
96487: LD_INT 1
96489: NEG
96490: PUSH
96491: LD_INT 3
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: LIST
96502: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96503: LD_ADDR_VAR 0 27
96507: PUSH
96508: LD_INT 3
96510: NEG
96511: PUSH
96512: LD_INT 0
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: NEG
96522: PUSH
96523: LD_INT 1
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: PUSH
96530: LD_INT 4
96532: NEG
96533: PUSH
96534: LD_INT 1
96536: NEG
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: PUSH
96542: EMPTY
96543: LIST
96544: LIST
96545: LIST
96546: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96547: LD_ADDR_VAR 0 28
96551: PUSH
96552: LD_INT 3
96554: NEG
96555: PUSH
96556: LD_INT 3
96558: NEG
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 3
96566: NEG
96567: PUSH
96568: LD_INT 4
96570: NEG
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: PUSH
96576: LD_INT 4
96578: NEG
96579: PUSH
96580: LD_INT 3
96582: NEG
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: LIST
96592: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96593: LD_ADDR_VAR 0 29
96597: PUSH
96598: LD_INT 1
96600: NEG
96601: PUSH
96602: LD_INT 3
96604: NEG
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 0
96612: PUSH
96613: LD_INT 3
96615: NEG
96616: PUSH
96617: EMPTY
96618: LIST
96619: LIST
96620: PUSH
96621: LD_INT 1
96623: PUSH
96624: LD_INT 2
96626: NEG
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 1
96634: NEG
96635: PUSH
96636: LD_INT 4
96638: NEG
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 0
96646: PUSH
96647: LD_INT 4
96649: NEG
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 1
96657: PUSH
96658: LD_INT 3
96660: NEG
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 1
96668: NEG
96669: PUSH
96670: LD_INT 5
96672: NEG
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 0
96680: PUSH
96681: LD_INT 5
96683: NEG
96684: PUSH
96685: EMPTY
96686: LIST
96687: LIST
96688: PUSH
96689: LD_INT 1
96691: PUSH
96692: LD_INT 4
96694: NEG
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 1
96702: NEG
96703: PUSH
96704: LD_INT 6
96706: NEG
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: LD_INT 0
96714: PUSH
96715: LD_INT 6
96717: NEG
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: PUSH
96723: LD_INT 1
96725: PUSH
96726: LD_INT 5
96728: NEG
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96748: LD_ADDR_VAR 0 30
96752: PUSH
96753: LD_INT 2
96755: PUSH
96756: LD_INT 1
96758: NEG
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 3
96766: PUSH
96767: LD_INT 0
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 3
96776: PUSH
96777: LD_INT 1
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 3
96786: PUSH
96787: LD_INT 1
96789: NEG
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 4
96797: PUSH
96798: LD_INT 0
96800: PUSH
96801: EMPTY
96802: LIST
96803: LIST
96804: PUSH
96805: LD_INT 4
96807: PUSH
96808: LD_INT 1
96810: PUSH
96811: EMPTY
96812: LIST
96813: LIST
96814: PUSH
96815: LD_INT 4
96817: PUSH
96818: LD_INT 1
96820: NEG
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 5
96828: PUSH
96829: LD_INT 0
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 5
96838: PUSH
96839: LD_INT 1
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 5
96848: PUSH
96849: LD_INT 1
96851: NEG
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: LD_INT 6
96859: PUSH
96860: LD_INT 0
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PUSH
96867: LD_INT 6
96869: PUSH
96870: LD_INT 1
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96891: LD_ADDR_VAR 0 31
96895: PUSH
96896: LD_INT 3
96898: PUSH
96899: LD_INT 2
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 3
96908: PUSH
96909: LD_INT 3
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 2
96918: PUSH
96919: LD_INT 3
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 4
96928: PUSH
96929: LD_INT 3
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 4
96938: PUSH
96939: LD_INT 4
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: PUSH
96946: LD_INT 3
96948: PUSH
96949: LD_INT 4
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: PUSH
96956: LD_INT 5
96958: PUSH
96959: LD_INT 4
96961: PUSH
96962: EMPTY
96963: LIST
96964: LIST
96965: PUSH
96966: LD_INT 5
96968: PUSH
96969: LD_INT 5
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: LD_INT 4
96978: PUSH
96979: LD_INT 5
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: LD_INT 6
96988: PUSH
96989: LD_INT 5
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 6
96998: PUSH
96999: LD_INT 6
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 5
97008: PUSH
97009: LD_INT 6
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97030: LD_ADDR_VAR 0 32
97034: PUSH
97035: LD_INT 1
97037: PUSH
97038: LD_INT 3
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 0
97047: PUSH
97048: LD_INT 3
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 1
97057: NEG
97058: PUSH
97059: LD_INT 2
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 1
97068: PUSH
97069: LD_INT 4
97071: PUSH
97072: EMPTY
97073: LIST
97074: LIST
97075: PUSH
97076: LD_INT 0
97078: PUSH
97079: LD_INT 4
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: LD_INT 1
97088: NEG
97089: PUSH
97090: LD_INT 3
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: LD_INT 1
97099: PUSH
97100: LD_INT 5
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 0
97109: PUSH
97110: LD_INT 5
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 1
97119: NEG
97120: PUSH
97121: LD_INT 4
97123: PUSH
97124: EMPTY
97125: LIST
97126: LIST
97127: PUSH
97128: LD_INT 1
97130: PUSH
97131: LD_INT 6
97133: PUSH
97134: EMPTY
97135: LIST
97136: LIST
97137: PUSH
97138: LD_INT 0
97140: PUSH
97141: LD_INT 6
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: LD_INT 1
97150: NEG
97151: PUSH
97152: LD_INT 5
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97173: LD_ADDR_VAR 0 33
97177: PUSH
97178: LD_INT 2
97180: NEG
97181: PUSH
97182: LD_INT 1
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PUSH
97189: LD_INT 3
97191: NEG
97192: PUSH
97193: LD_INT 0
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: PUSH
97200: LD_INT 3
97202: NEG
97203: PUSH
97204: LD_INT 1
97206: NEG
97207: PUSH
97208: EMPTY
97209: LIST
97210: LIST
97211: PUSH
97212: LD_INT 3
97214: NEG
97215: PUSH
97216: LD_INT 1
97218: PUSH
97219: EMPTY
97220: LIST
97221: LIST
97222: PUSH
97223: LD_INT 4
97225: NEG
97226: PUSH
97227: LD_INT 0
97229: PUSH
97230: EMPTY
97231: LIST
97232: LIST
97233: PUSH
97234: LD_INT 4
97236: NEG
97237: PUSH
97238: LD_INT 1
97240: NEG
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 4
97248: NEG
97249: PUSH
97250: LD_INT 1
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: LD_INT 5
97259: NEG
97260: PUSH
97261: LD_INT 0
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: PUSH
97268: LD_INT 5
97270: NEG
97271: PUSH
97272: LD_INT 1
97274: NEG
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 5
97282: NEG
97283: PUSH
97284: LD_INT 1
97286: PUSH
97287: EMPTY
97288: LIST
97289: LIST
97290: PUSH
97291: LD_INT 6
97293: NEG
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 6
97304: NEG
97305: PUSH
97306: LD_INT 1
97308: NEG
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97328: LD_ADDR_VAR 0 34
97332: PUSH
97333: LD_INT 2
97335: NEG
97336: PUSH
97337: LD_INT 3
97339: NEG
97340: PUSH
97341: EMPTY
97342: LIST
97343: LIST
97344: PUSH
97345: LD_INT 3
97347: NEG
97348: PUSH
97349: LD_INT 2
97351: NEG
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 3
97359: NEG
97360: PUSH
97361: LD_INT 3
97363: NEG
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 3
97371: NEG
97372: PUSH
97373: LD_INT 4
97375: NEG
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: PUSH
97381: LD_INT 4
97383: NEG
97384: PUSH
97385: LD_INT 3
97387: NEG
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 4
97395: NEG
97396: PUSH
97397: LD_INT 4
97399: NEG
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: PUSH
97405: LD_INT 4
97407: NEG
97408: PUSH
97409: LD_INT 5
97411: NEG
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 5
97419: NEG
97420: PUSH
97421: LD_INT 4
97423: NEG
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_INT 5
97431: NEG
97432: PUSH
97433: LD_INT 5
97435: NEG
97436: PUSH
97437: EMPTY
97438: LIST
97439: LIST
97440: PUSH
97441: LD_INT 5
97443: NEG
97444: PUSH
97445: LD_INT 6
97447: NEG
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: LD_INT 6
97455: NEG
97456: PUSH
97457: LD_INT 5
97459: NEG
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: PUSH
97465: LD_INT 6
97467: NEG
97468: PUSH
97469: LD_INT 6
97471: NEG
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97491: LD_ADDR_VAR 0 41
97495: PUSH
97496: LD_INT 0
97498: PUSH
97499: LD_INT 2
97501: NEG
97502: PUSH
97503: EMPTY
97504: LIST
97505: LIST
97506: PUSH
97507: LD_INT 1
97509: NEG
97510: PUSH
97511: LD_INT 3
97513: NEG
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 1
97521: PUSH
97522: LD_INT 2
97524: NEG
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: EMPTY
97531: LIST
97532: LIST
97533: LIST
97534: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97535: LD_ADDR_VAR 0 42
97539: PUSH
97540: LD_INT 2
97542: PUSH
97543: LD_INT 0
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 2
97552: PUSH
97553: LD_INT 1
97555: NEG
97556: PUSH
97557: EMPTY
97558: LIST
97559: LIST
97560: PUSH
97561: LD_INT 3
97563: PUSH
97564: LD_INT 1
97566: PUSH
97567: EMPTY
97568: LIST
97569: LIST
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: LIST
97575: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97576: LD_ADDR_VAR 0 43
97580: PUSH
97581: LD_INT 2
97583: PUSH
97584: LD_INT 2
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 3
97593: PUSH
97594: LD_INT 2
97596: PUSH
97597: EMPTY
97598: LIST
97599: LIST
97600: PUSH
97601: LD_INT 2
97603: PUSH
97604: LD_INT 3
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: LIST
97615: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97616: LD_ADDR_VAR 0 44
97620: PUSH
97621: LD_INT 0
97623: PUSH
97624: LD_INT 2
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: PUSH
97631: LD_INT 1
97633: PUSH
97634: LD_INT 3
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 1
97643: NEG
97644: PUSH
97645: LD_INT 2
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: LIST
97656: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97657: LD_ADDR_VAR 0 45
97661: PUSH
97662: LD_INT 2
97664: NEG
97665: PUSH
97666: LD_INT 0
97668: PUSH
97669: EMPTY
97670: LIST
97671: LIST
97672: PUSH
97673: LD_INT 2
97675: NEG
97676: PUSH
97677: LD_INT 1
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: PUSH
97684: LD_INT 3
97686: NEG
97687: PUSH
97688: LD_INT 1
97690: NEG
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: LIST
97700: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97701: LD_ADDR_VAR 0 46
97705: PUSH
97706: LD_INT 2
97708: NEG
97709: PUSH
97710: LD_INT 2
97712: NEG
97713: PUSH
97714: EMPTY
97715: LIST
97716: LIST
97717: PUSH
97718: LD_INT 2
97720: NEG
97721: PUSH
97722: LD_INT 3
97724: NEG
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: LD_INT 3
97732: NEG
97733: PUSH
97734: LD_INT 2
97736: NEG
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: LIST
97746: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97747: LD_ADDR_VAR 0 47
97751: PUSH
97752: LD_INT 2
97754: NEG
97755: PUSH
97756: LD_INT 3
97758: NEG
97759: PUSH
97760: EMPTY
97761: LIST
97762: LIST
97763: PUSH
97764: LD_INT 1
97766: NEG
97767: PUSH
97768: LD_INT 3
97770: NEG
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: PUSH
97776: EMPTY
97777: LIST
97778: LIST
97779: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97780: LD_ADDR_VAR 0 48
97784: PUSH
97785: LD_INT 1
97787: PUSH
97788: LD_INT 2
97790: NEG
97791: PUSH
97792: EMPTY
97793: LIST
97794: LIST
97795: PUSH
97796: LD_INT 2
97798: PUSH
97799: LD_INT 1
97801: NEG
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97811: LD_ADDR_VAR 0 49
97815: PUSH
97816: LD_INT 3
97818: PUSH
97819: LD_INT 1
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: PUSH
97826: LD_INT 3
97828: PUSH
97829: LD_INT 2
97831: PUSH
97832: EMPTY
97833: LIST
97834: LIST
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97840: LD_ADDR_VAR 0 50
97844: PUSH
97845: LD_INT 2
97847: PUSH
97848: LD_INT 3
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 1
97857: PUSH
97858: LD_INT 3
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97869: LD_ADDR_VAR 0 51
97873: PUSH
97874: LD_INT 1
97876: NEG
97877: PUSH
97878: LD_INT 2
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: PUSH
97885: LD_INT 2
97887: NEG
97888: PUSH
97889: LD_INT 1
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97900: LD_ADDR_VAR 0 52
97904: PUSH
97905: LD_INT 3
97907: NEG
97908: PUSH
97909: LD_INT 1
97911: NEG
97912: PUSH
97913: EMPTY
97914: LIST
97915: LIST
97916: PUSH
97917: LD_INT 3
97919: NEG
97920: PUSH
97921: LD_INT 2
97923: NEG
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97933: LD_ADDR_VAR 0 53
97937: PUSH
97938: LD_INT 1
97940: NEG
97941: PUSH
97942: LD_INT 3
97944: NEG
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 0
97952: PUSH
97953: LD_INT 3
97955: NEG
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: PUSH
97961: LD_INT 1
97963: PUSH
97964: LD_INT 2
97966: NEG
97967: PUSH
97968: EMPTY
97969: LIST
97970: LIST
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: LIST
97976: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97977: LD_ADDR_VAR 0 54
97981: PUSH
97982: LD_INT 2
97984: PUSH
97985: LD_INT 1
97987: NEG
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: LD_INT 3
97995: PUSH
97996: LD_INT 0
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: PUSH
98003: LD_INT 3
98005: PUSH
98006: LD_INT 1
98008: PUSH
98009: EMPTY
98010: LIST
98011: LIST
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: LIST
98017: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98018: LD_ADDR_VAR 0 55
98022: PUSH
98023: LD_INT 3
98025: PUSH
98026: LD_INT 2
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 3
98035: PUSH
98036: LD_INT 3
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: LD_INT 2
98045: PUSH
98046: LD_INT 3
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: LIST
98057: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98058: LD_ADDR_VAR 0 56
98062: PUSH
98063: LD_INT 1
98065: PUSH
98066: LD_INT 3
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: LD_INT 0
98075: PUSH
98076: LD_INT 3
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: LD_INT 1
98085: NEG
98086: PUSH
98087: LD_INT 2
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: EMPTY
98095: LIST
98096: LIST
98097: LIST
98098: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98099: LD_ADDR_VAR 0 57
98103: PUSH
98104: LD_INT 2
98106: NEG
98107: PUSH
98108: LD_INT 1
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: LD_INT 3
98117: NEG
98118: PUSH
98119: LD_INT 0
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 3
98128: NEG
98129: PUSH
98130: LD_INT 1
98132: NEG
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: LIST
98142: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98143: LD_ADDR_VAR 0 58
98147: PUSH
98148: LD_INT 2
98150: NEG
98151: PUSH
98152: LD_INT 3
98154: NEG
98155: PUSH
98156: EMPTY
98157: LIST
98158: LIST
98159: PUSH
98160: LD_INT 3
98162: NEG
98163: PUSH
98164: LD_INT 2
98166: NEG
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: PUSH
98172: LD_INT 3
98174: NEG
98175: PUSH
98176: LD_INT 3
98178: NEG
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: EMPTY
98185: LIST
98186: LIST
98187: LIST
98188: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98189: LD_ADDR_VAR 0 59
98193: PUSH
98194: LD_INT 1
98196: NEG
98197: PUSH
98198: LD_INT 2
98200: NEG
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: LD_INT 0
98208: PUSH
98209: LD_INT 2
98211: NEG
98212: PUSH
98213: EMPTY
98214: LIST
98215: LIST
98216: PUSH
98217: LD_INT 1
98219: PUSH
98220: LD_INT 1
98222: NEG
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: PUSH
98228: EMPTY
98229: LIST
98230: LIST
98231: LIST
98232: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98233: LD_ADDR_VAR 0 60
98237: PUSH
98238: LD_INT 1
98240: PUSH
98241: LD_INT 1
98243: NEG
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: PUSH
98249: LD_INT 2
98251: PUSH
98252: LD_INT 0
98254: PUSH
98255: EMPTY
98256: LIST
98257: LIST
98258: PUSH
98259: LD_INT 2
98261: PUSH
98262: LD_INT 1
98264: PUSH
98265: EMPTY
98266: LIST
98267: LIST
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: LIST
98273: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98274: LD_ADDR_VAR 0 61
98278: PUSH
98279: LD_INT 2
98281: PUSH
98282: LD_INT 1
98284: PUSH
98285: EMPTY
98286: LIST
98287: LIST
98288: PUSH
98289: LD_INT 2
98291: PUSH
98292: LD_INT 2
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 1
98301: PUSH
98302: LD_INT 2
98304: PUSH
98305: EMPTY
98306: LIST
98307: LIST
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: LIST
98313: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98314: LD_ADDR_VAR 0 62
98318: PUSH
98319: LD_INT 1
98321: PUSH
98322: LD_INT 2
98324: PUSH
98325: EMPTY
98326: LIST
98327: LIST
98328: PUSH
98329: LD_INT 0
98331: PUSH
98332: LD_INT 2
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PUSH
98339: LD_INT 1
98341: NEG
98342: PUSH
98343: LD_INT 1
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: EMPTY
98351: LIST
98352: LIST
98353: LIST
98354: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98355: LD_ADDR_VAR 0 63
98359: PUSH
98360: LD_INT 1
98362: NEG
98363: PUSH
98364: LD_INT 1
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 2
98373: NEG
98374: PUSH
98375: LD_INT 0
98377: PUSH
98378: EMPTY
98379: LIST
98380: LIST
98381: PUSH
98382: LD_INT 2
98384: NEG
98385: PUSH
98386: LD_INT 1
98388: NEG
98389: PUSH
98390: EMPTY
98391: LIST
98392: LIST
98393: PUSH
98394: EMPTY
98395: LIST
98396: LIST
98397: LIST
98398: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98399: LD_ADDR_VAR 0 64
98403: PUSH
98404: LD_INT 1
98406: NEG
98407: PUSH
98408: LD_INT 2
98410: NEG
98411: PUSH
98412: EMPTY
98413: LIST
98414: LIST
98415: PUSH
98416: LD_INT 2
98418: NEG
98419: PUSH
98420: LD_INT 1
98422: NEG
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: PUSH
98428: LD_INT 2
98430: NEG
98431: PUSH
98432: LD_INT 2
98434: NEG
98435: PUSH
98436: EMPTY
98437: LIST
98438: LIST
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: LIST
98444: ST_TO_ADDR
// end ; 2 :
98445: GO 101711
98447: LD_INT 2
98449: DOUBLE
98450: EQUAL
98451: IFTRUE 98455
98453: GO 101710
98455: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98456: LD_ADDR_VAR 0 29
98460: PUSH
98461: LD_INT 4
98463: PUSH
98464: LD_INT 0
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 4
98473: PUSH
98474: LD_INT 1
98476: NEG
98477: PUSH
98478: EMPTY
98479: LIST
98480: LIST
98481: PUSH
98482: LD_INT 5
98484: PUSH
98485: LD_INT 0
98487: PUSH
98488: EMPTY
98489: LIST
98490: LIST
98491: PUSH
98492: LD_INT 5
98494: PUSH
98495: LD_INT 1
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: PUSH
98502: LD_INT 4
98504: PUSH
98505: LD_INT 1
98507: PUSH
98508: EMPTY
98509: LIST
98510: LIST
98511: PUSH
98512: LD_INT 3
98514: PUSH
98515: LD_INT 0
98517: PUSH
98518: EMPTY
98519: LIST
98520: LIST
98521: PUSH
98522: LD_INT 3
98524: PUSH
98525: LD_INT 1
98527: NEG
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PUSH
98533: LD_INT 3
98535: PUSH
98536: LD_INT 2
98538: NEG
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: PUSH
98544: LD_INT 5
98546: PUSH
98547: LD_INT 2
98549: PUSH
98550: EMPTY
98551: LIST
98552: LIST
98553: PUSH
98554: LD_INT 3
98556: PUSH
98557: LD_INT 3
98559: PUSH
98560: EMPTY
98561: LIST
98562: LIST
98563: PUSH
98564: LD_INT 3
98566: PUSH
98567: LD_INT 2
98569: PUSH
98570: EMPTY
98571: LIST
98572: LIST
98573: PUSH
98574: LD_INT 4
98576: PUSH
98577: LD_INT 3
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: PUSH
98584: LD_INT 4
98586: PUSH
98587: LD_INT 4
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: LD_INT 3
98596: PUSH
98597: LD_INT 4
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PUSH
98604: LD_INT 2
98606: PUSH
98607: LD_INT 3
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: LD_INT 2
98616: PUSH
98617: LD_INT 2
98619: PUSH
98620: EMPTY
98621: LIST
98622: LIST
98623: PUSH
98624: LD_INT 4
98626: PUSH
98627: LD_INT 2
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: LD_INT 2
98636: PUSH
98637: LD_INT 4
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: LD_INT 0
98646: PUSH
98647: LD_INT 4
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 0
98656: PUSH
98657: LD_INT 3
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 1
98666: PUSH
98667: LD_INT 4
98669: PUSH
98670: EMPTY
98671: LIST
98672: LIST
98673: PUSH
98674: LD_INT 1
98676: PUSH
98677: LD_INT 5
98679: PUSH
98680: EMPTY
98681: LIST
98682: LIST
98683: PUSH
98684: LD_INT 0
98686: PUSH
98687: LD_INT 5
98689: PUSH
98690: EMPTY
98691: LIST
98692: LIST
98693: PUSH
98694: LD_INT 1
98696: NEG
98697: PUSH
98698: LD_INT 4
98700: PUSH
98701: EMPTY
98702: LIST
98703: LIST
98704: PUSH
98705: LD_INT 1
98707: NEG
98708: PUSH
98709: LD_INT 3
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: PUSH
98716: LD_INT 2
98718: PUSH
98719: LD_INT 5
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 2
98728: NEG
98729: PUSH
98730: LD_INT 3
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: PUSH
98737: LD_INT 3
98739: NEG
98740: PUSH
98741: LD_INT 0
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: LD_INT 3
98750: NEG
98751: PUSH
98752: LD_INT 1
98754: NEG
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 2
98762: NEG
98763: PUSH
98764: LD_INT 0
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: LD_INT 2
98773: NEG
98774: PUSH
98775: LD_INT 1
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: LD_INT 3
98784: NEG
98785: PUSH
98786: LD_INT 1
98788: PUSH
98789: EMPTY
98790: LIST
98791: LIST
98792: PUSH
98793: LD_INT 4
98795: NEG
98796: PUSH
98797: LD_INT 0
98799: PUSH
98800: EMPTY
98801: LIST
98802: LIST
98803: PUSH
98804: LD_INT 4
98806: NEG
98807: PUSH
98808: LD_INT 1
98810: NEG
98811: PUSH
98812: EMPTY
98813: LIST
98814: LIST
98815: PUSH
98816: LD_INT 4
98818: NEG
98819: PUSH
98820: LD_INT 2
98822: NEG
98823: PUSH
98824: EMPTY
98825: LIST
98826: LIST
98827: PUSH
98828: LD_INT 2
98830: NEG
98831: PUSH
98832: LD_INT 2
98834: PUSH
98835: EMPTY
98836: LIST
98837: LIST
98838: PUSH
98839: LD_INT 4
98841: NEG
98842: PUSH
98843: LD_INT 4
98845: NEG
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PUSH
98851: LD_INT 4
98853: NEG
98854: PUSH
98855: LD_INT 5
98857: NEG
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 3
98865: NEG
98866: PUSH
98867: LD_INT 4
98869: NEG
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PUSH
98875: LD_INT 3
98877: NEG
98878: PUSH
98879: LD_INT 3
98881: NEG
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PUSH
98887: LD_INT 4
98889: NEG
98890: PUSH
98891: LD_INT 3
98893: NEG
98894: PUSH
98895: EMPTY
98896: LIST
98897: LIST
98898: PUSH
98899: LD_INT 5
98901: NEG
98902: PUSH
98903: LD_INT 4
98905: NEG
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: PUSH
98911: LD_INT 5
98913: NEG
98914: PUSH
98915: LD_INT 5
98917: NEG
98918: PUSH
98919: EMPTY
98920: LIST
98921: LIST
98922: PUSH
98923: LD_INT 3
98925: NEG
98926: PUSH
98927: LD_INT 5
98929: NEG
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 5
98937: NEG
98938: PUSH
98939: LD_INT 3
98941: NEG
98942: PUSH
98943: EMPTY
98944: LIST
98945: LIST
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98994: LD_ADDR_VAR 0 30
98998: PUSH
98999: LD_INT 4
99001: PUSH
99002: LD_INT 4
99004: PUSH
99005: EMPTY
99006: LIST
99007: LIST
99008: PUSH
99009: LD_INT 4
99011: PUSH
99012: LD_INT 3
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PUSH
99019: LD_INT 5
99021: PUSH
99022: LD_INT 4
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: PUSH
99029: LD_INT 5
99031: PUSH
99032: LD_INT 5
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PUSH
99039: LD_INT 4
99041: PUSH
99042: LD_INT 5
99044: PUSH
99045: EMPTY
99046: LIST
99047: LIST
99048: PUSH
99049: LD_INT 3
99051: PUSH
99052: LD_INT 4
99054: PUSH
99055: EMPTY
99056: LIST
99057: LIST
99058: PUSH
99059: LD_INT 3
99061: PUSH
99062: LD_INT 3
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: PUSH
99069: LD_INT 5
99071: PUSH
99072: LD_INT 3
99074: PUSH
99075: EMPTY
99076: LIST
99077: LIST
99078: PUSH
99079: LD_INT 3
99081: PUSH
99082: LD_INT 5
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 0
99091: PUSH
99092: LD_INT 3
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: PUSH
99099: LD_INT 0
99101: PUSH
99102: LD_INT 2
99104: PUSH
99105: EMPTY
99106: LIST
99107: LIST
99108: PUSH
99109: LD_INT 1
99111: PUSH
99112: LD_INT 3
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: PUSH
99119: LD_INT 1
99121: PUSH
99122: LD_INT 4
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 0
99131: PUSH
99132: LD_INT 4
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 1
99141: NEG
99142: PUSH
99143: LD_INT 3
99145: PUSH
99146: EMPTY
99147: LIST
99148: LIST
99149: PUSH
99150: LD_INT 1
99152: NEG
99153: PUSH
99154: LD_INT 2
99156: PUSH
99157: EMPTY
99158: LIST
99159: LIST
99160: PUSH
99161: LD_INT 2
99163: PUSH
99164: LD_INT 4
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PUSH
99171: LD_INT 2
99173: NEG
99174: PUSH
99175: LD_INT 2
99177: PUSH
99178: EMPTY
99179: LIST
99180: LIST
99181: PUSH
99182: LD_INT 4
99184: NEG
99185: PUSH
99186: LD_INT 0
99188: PUSH
99189: EMPTY
99190: LIST
99191: LIST
99192: PUSH
99193: LD_INT 4
99195: NEG
99196: PUSH
99197: LD_INT 1
99199: NEG
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: PUSH
99205: LD_INT 3
99207: NEG
99208: PUSH
99209: LD_INT 0
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: PUSH
99216: LD_INT 3
99218: NEG
99219: PUSH
99220: LD_INT 1
99222: PUSH
99223: EMPTY
99224: LIST
99225: LIST
99226: PUSH
99227: LD_INT 4
99229: NEG
99230: PUSH
99231: LD_INT 1
99233: PUSH
99234: EMPTY
99235: LIST
99236: LIST
99237: PUSH
99238: LD_INT 5
99240: NEG
99241: PUSH
99242: LD_INT 0
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: LD_INT 5
99251: NEG
99252: PUSH
99253: LD_INT 1
99255: NEG
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PUSH
99261: LD_INT 5
99263: NEG
99264: PUSH
99265: LD_INT 2
99267: NEG
99268: PUSH
99269: EMPTY
99270: LIST
99271: LIST
99272: PUSH
99273: LD_INT 3
99275: NEG
99276: PUSH
99277: LD_INT 2
99279: PUSH
99280: EMPTY
99281: LIST
99282: LIST
99283: PUSH
99284: LD_INT 3
99286: NEG
99287: PUSH
99288: LD_INT 3
99290: NEG
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PUSH
99296: LD_INT 3
99298: NEG
99299: PUSH
99300: LD_INT 4
99302: NEG
99303: PUSH
99304: EMPTY
99305: LIST
99306: LIST
99307: PUSH
99308: LD_INT 2
99310: NEG
99311: PUSH
99312: LD_INT 3
99314: NEG
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 2
99322: NEG
99323: PUSH
99324: LD_INT 2
99326: NEG
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: LD_INT 3
99334: NEG
99335: PUSH
99336: LD_INT 2
99338: NEG
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 4
99346: NEG
99347: PUSH
99348: LD_INT 3
99350: NEG
99351: PUSH
99352: EMPTY
99353: LIST
99354: LIST
99355: PUSH
99356: LD_INT 4
99358: NEG
99359: PUSH
99360: LD_INT 4
99362: NEG
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: PUSH
99368: LD_INT 2
99370: NEG
99371: PUSH
99372: LD_INT 4
99374: NEG
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PUSH
99380: LD_INT 4
99382: NEG
99383: PUSH
99384: LD_INT 2
99386: NEG
99387: PUSH
99388: EMPTY
99389: LIST
99390: LIST
99391: PUSH
99392: LD_INT 0
99394: PUSH
99395: LD_INT 4
99397: NEG
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: LD_INT 0
99405: PUSH
99406: LD_INT 5
99408: NEG
99409: PUSH
99410: EMPTY
99411: LIST
99412: LIST
99413: PUSH
99414: LD_INT 1
99416: PUSH
99417: LD_INT 4
99419: NEG
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: LD_INT 1
99427: PUSH
99428: LD_INT 3
99430: NEG
99431: PUSH
99432: EMPTY
99433: LIST
99434: LIST
99435: PUSH
99436: LD_INT 0
99438: PUSH
99439: LD_INT 3
99441: NEG
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PUSH
99447: LD_INT 1
99449: NEG
99450: PUSH
99451: LD_INT 4
99453: NEG
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: PUSH
99459: LD_INT 1
99461: NEG
99462: PUSH
99463: LD_INT 5
99465: NEG
99466: PUSH
99467: EMPTY
99468: LIST
99469: LIST
99470: PUSH
99471: LD_INT 2
99473: PUSH
99474: LD_INT 3
99476: NEG
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: PUSH
99482: LD_INT 2
99484: NEG
99485: PUSH
99486: LD_INT 5
99488: NEG
99489: PUSH
99490: EMPTY
99491: LIST
99492: LIST
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: LIST
99503: LIST
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99541: LD_ADDR_VAR 0 31
99545: PUSH
99546: LD_INT 0
99548: PUSH
99549: LD_INT 4
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: PUSH
99556: LD_INT 0
99558: PUSH
99559: LD_INT 3
99561: PUSH
99562: EMPTY
99563: LIST
99564: LIST
99565: PUSH
99566: LD_INT 1
99568: PUSH
99569: LD_INT 4
99571: PUSH
99572: EMPTY
99573: LIST
99574: LIST
99575: PUSH
99576: LD_INT 1
99578: PUSH
99579: LD_INT 5
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: LD_INT 0
99588: PUSH
99589: LD_INT 5
99591: PUSH
99592: EMPTY
99593: LIST
99594: LIST
99595: PUSH
99596: LD_INT 1
99598: NEG
99599: PUSH
99600: LD_INT 4
99602: PUSH
99603: EMPTY
99604: LIST
99605: LIST
99606: PUSH
99607: LD_INT 1
99609: NEG
99610: PUSH
99611: LD_INT 3
99613: PUSH
99614: EMPTY
99615: LIST
99616: LIST
99617: PUSH
99618: LD_INT 2
99620: PUSH
99621: LD_INT 5
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: LD_INT 2
99630: NEG
99631: PUSH
99632: LD_INT 3
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: PUSH
99639: LD_INT 3
99641: NEG
99642: PUSH
99643: LD_INT 0
99645: PUSH
99646: EMPTY
99647: LIST
99648: LIST
99649: PUSH
99650: LD_INT 3
99652: NEG
99653: PUSH
99654: LD_INT 1
99656: NEG
99657: PUSH
99658: EMPTY
99659: LIST
99660: LIST
99661: PUSH
99662: LD_INT 2
99664: NEG
99665: PUSH
99666: LD_INT 0
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: PUSH
99673: LD_INT 2
99675: NEG
99676: PUSH
99677: LD_INT 1
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: LD_INT 3
99686: NEG
99687: PUSH
99688: LD_INT 1
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: PUSH
99695: LD_INT 4
99697: NEG
99698: PUSH
99699: LD_INT 0
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PUSH
99706: LD_INT 4
99708: NEG
99709: PUSH
99710: LD_INT 1
99712: NEG
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: PUSH
99718: LD_INT 4
99720: NEG
99721: PUSH
99722: LD_INT 2
99724: NEG
99725: PUSH
99726: EMPTY
99727: LIST
99728: LIST
99729: PUSH
99730: LD_INT 2
99732: NEG
99733: PUSH
99734: LD_INT 2
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: PUSH
99741: LD_INT 4
99743: NEG
99744: PUSH
99745: LD_INT 4
99747: NEG
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PUSH
99753: LD_INT 4
99755: NEG
99756: PUSH
99757: LD_INT 5
99759: NEG
99760: PUSH
99761: EMPTY
99762: LIST
99763: LIST
99764: PUSH
99765: LD_INT 3
99767: NEG
99768: PUSH
99769: LD_INT 4
99771: NEG
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 3
99779: NEG
99780: PUSH
99781: LD_INT 3
99783: NEG
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 4
99791: NEG
99792: PUSH
99793: LD_INT 3
99795: NEG
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PUSH
99801: LD_INT 5
99803: NEG
99804: PUSH
99805: LD_INT 4
99807: NEG
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 5
99815: NEG
99816: PUSH
99817: LD_INT 5
99819: NEG
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: PUSH
99825: LD_INT 3
99827: NEG
99828: PUSH
99829: LD_INT 5
99831: NEG
99832: PUSH
99833: EMPTY
99834: LIST
99835: LIST
99836: PUSH
99837: LD_INT 5
99839: NEG
99840: PUSH
99841: LD_INT 3
99843: NEG
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PUSH
99849: LD_INT 0
99851: PUSH
99852: LD_INT 3
99854: NEG
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 0
99862: PUSH
99863: LD_INT 4
99865: NEG
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: PUSH
99871: LD_INT 1
99873: PUSH
99874: LD_INT 3
99876: NEG
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: PUSH
99882: LD_INT 1
99884: PUSH
99885: LD_INT 2
99887: NEG
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PUSH
99893: LD_INT 0
99895: PUSH
99896: LD_INT 2
99898: NEG
99899: PUSH
99900: EMPTY
99901: LIST
99902: LIST
99903: PUSH
99904: LD_INT 1
99906: NEG
99907: PUSH
99908: LD_INT 3
99910: NEG
99911: PUSH
99912: EMPTY
99913: LIST
99914: LIST
99915: PUSH
99916: LD_INT 1
99918: NEG
99919: PUSH
99920: LD_INT 4
99922: NEG
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PUSH
99928: LD_INT 2
99930: PUSH
99931: LD_INT 2
99933: NEG
99934: PUSH
99935: EMPTY
99936: LIST
99937: LIST
99938: PUSH
99939: LD_INT 2
99941: NEG
99942: PUSH
99943: LD_INT 4
99945: NEG
99946: PUSH
99947: EMPTY
99948: LIST
99949: LIST
99950: PUSH
99951: LD_INT 4
99953: PUSH
99954: LD_INT 0
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: PUSH
99961: LD_INT 4
99963: PUSH
99964: LD_INT 1
99966: NEG
99967: PUSH
99968: EMPTY
99969: LIST
99970: LIST
99971: PUSH
99972: LD_INT 5
99974: PUSH
99975: LD_INT 0
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: PUSH
99982: LD_INT 5
99984: PUSH
99985: LD_INT 1
99987: PUSH
99988: EMPTY
99989: LIST
99990: LIST
99991: PUSH
99992: LD_INT 4
99994: PUSH
99995: LD_INT 1
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PUSH
100002: LD_INT 3
100004: PUSH
100005: LD_INT 0
100007: PUSH
100008: EMPTY
100009: LIST
100010: LIST
100011: PUSH
100012: LD_INT 3
100014: PUSH
100015: LD_INT 1
100017: NEG
100018: PUSH
100019: EMPTY
100020: LIST
100021: LIST
100022: PUSH
100023: LD_INT 3
100025: PUSH
100026: LD_INT 2
100028: NEG
100029: PUSH
100030: EMPTY
100031: LIST
100032: LIST
100033: PUSH
100034: LD_INT 5
100036: PUSH
100037: LD_INT 2
100039: PUSH
100040: EMPTY
100041: LIST
100042: LIST
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: LIST
100048: LIST
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100091: LD_ADDR_VAR 0 32
100095: PUSH
100096: LD_INT 4
100098: NEG
100099: PUSH
100100: LD_INT 0
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PUSH
100107: LD_INT 4
100109: NEG
100110: PUSH
100111: LD_INT 1
100113: NEG
100114: PUSH
100115: EMPTY
100116: LIST
100117: LIST
100118: PUSH
100119: LD_INT 3
100121: NEG
100122: PUSH
100123: LD_INT 0
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: PUSH
100130: LD_INT 3
100132: NEG
100133: PUSH
100134: LD_INT 1
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: PUSH
100141: LD_INT 4
100143: NEG
100144: PUSH
100145: LD_INT 1
100147: PUSH
100148: EMPTY
100149: LIST
100150: LIST
100151: PUSH
100152: LD_INT 5
100154: NEG
100155: PUSH
100156: LD_INT 0
100158: PUSH
100159: EMPTY
100160: LIST
100161: LIST
100162: PUSH
100163: LD_INT 5
100165: NEG
100166: PUSH
100167: LD_INT 1
100169: NEG
100170: PUSH
100171: EMPTY
100172: LIST
100173: LIST
100174: PUSH
100175: LD_INT 5
100177: NEG
100178: PUSH
100179: LD_INT 2
100181: NEG
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: PUSH
100187: LD_INT 3
100189: NEG
100190: PUSH
100191: LD_INT 2
100193: PUSH
100194: EMPTY
100195: LIST
100196: LIST
100197: PUSH
100198: LD_INT 3
100200: NEG
100201: PUSH
100202: LD_INT 3
100204: NEG
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PUSH
100210: LD_INT 3
100212: NEG
100213: PUSH
100214: LD_INT 4
100216: NEG
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PUSH
100222: LD_INT 2
100224: NEG
100225: PUSH
100226: LD_INT 3
100228: NEG
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: PUSH
100234: LD_INT 2
100236: NEG
100237: PUSH
100238: LD_INT 2
100240: NEG
100241: PUSH
100242: EMPTY
100243: LIST
100244: LIST
100245: PUSH
100246: LD_INT 3
100248: NEG
100249: PUSH
100250: LD_INT 2
100252: NEG
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 4
100260: NEG
100261: PUSH
100262: LD_INT 3
100264: NEG
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PUSH
100270: LD_INT 4
100272: NEG
100273: PUSH
100274: LD_INT 4
100276: NEG
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: PUSH
100282: LD_INT 2
100284: NEG
100285: PUSH
100286: LD_INT 4
100288: NEG
100289: PUSH
100290: EMPTY
100291: LIST
100292: LIST
100293: PUSH
100294: LD_INT 4
100296: NEG
100297: PUSH
100298: LD_INT 2
100300: NEG
100301: PUSH
100302: EMPTY
100303: LIST
100304: LIST
100305: PUSH
100306: LD_INT 0
100308: PUSH
100309: LD_INT 4
100311: NEG
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: LD_INT 0
100319: PUSH
100320: LD_INT 5
100322: NEG
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 1
100330: PUSH
100331: LD_INT 4
100333: NEG
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: LD_INT 1
100341: PUSH
100342: LD_INT 3
100344: NEG
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: PUSH
100350: LD_INT 0
100352: PUSH
100353: LD_INT 3
100355: NEG
100356: PUSH
100357: EMPTY
100358: LIST
100359: LIST
100360: PUSH
100361: LD_INT 1
100363: NEG
100364: PUSH
100365: LD_INT 4
100367: NEG
100368: PUSH
100369: EMPTY
100370: LIST
100371: LIST
100372: PUSH
100373: LD_INT 1
100375: NEG
100376: PUSH
100377: LD_INT 5
100379: NEG
100380: PUSH
100381: EMPTY
100382: LIST
100383: LIST
100384: PUSH
100385: LD_INT 2
100387: PUSH
100388: LD_INT 3
100390: NEG
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: PUSH
100396: LD_INT 2
100398: NEG
100399: PUSH
100400: LD_INT 5
100402: NEG
100403: PUSH
100404: EMPTY
100405: LIST
100406: LIST
100407: PUSH
100408: LD_INT 3
100410: PUSH
100411: LD_INT 0
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: LD_INT 3
100420: PUSH
100421: LD_INT 1
100423: NEG
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PUSH
100429: LD_INT 4
100431: PUSH
100432: LD_INT 0
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 4
100441: PUSH
100442: LD_INT 1
100444: PUSH
100445: EMPTY
100446: LIST
100447: LIST
100448: PUSH
100449: LD_INT 3
100451: PUSH
100452: LD_INT 1
100454: PUSH
100455: EMPTY
100456: LIST
100457: LIST
100458: PUSH
100459: LD_INT 2
100461: PUSH
100462: LD_INT 0
100464: PUSH
100465: EMPTY
100466: LIST
100467: LIST
100468: PUSH
100469: LD_INT 2
100471: PUSH
100472: LD_INT 1
100474: NEG
100475: PUSH
100476: EMPTY
100477: LIST
100478: LIST
100479: PUSH
100480: LD_INT 2
100482: PUSH
100483: LD_INT 2
100485: NEG
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: PUSH
100491: LD_INT 4
100493: PUSH
100494: LD_INT 2
100496: PUSH
100497: EMPTY
100498: LIST
100499: LIST
100500: PUSH
100501: LD_INT 4
100503: PUSH
100504: LD_INT 4
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: LD_INT 4
100513: PUSH
100514: LD_INT 3
100516: PUSH
100517: EMPTY
100518: LIST
100519: LIST
100520: PUSH
100521: LD_INT 5
100523: PUSH
100524: LD_INT 4
100526: PUSH
100527: EMPTY
100528: LIST
100529: LIST
100530: PUSH
100531: LD_INT 5
100533: PUSH
100534: LD_INT 5
100536: PUSH
100537: EMPTY
100538: LIST
100539: LIST
100540: PUSH
100541: LD_INT 4
100543: PUSH
100544: LD_INT 5
100546: PUSH
100547: EMPTY
100548: LIST
100549: LIST
100550: PUSH
100551: LD_INT 3
100553: PUSH
100554: LD_INT 4
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: PUSH
100561: LD_INT 3
100563: PUSH
100564: LD_INT 3
100566: PUSH
100567: EMPTY
100568: LIST
100569: LIST
100570: PUSH
100571: LD_INT 5
100573: PUSH
100574: LD_INT 3
100576: PUSH
100577: EMPTY
100578: LIST
100579: LIST
100580: PUSH
100581: LD_INT 3
100583: PUSH
100584: LD_INT 5
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: PUSH
100591: EMPTY
100592: LIST
100593: LIST
100594: LIST
100595: LIST
100596: LIST
100597: LIST
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: LIST
100605: LIST
100606: LIST
100607: LIST
100608: LIST
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: LIST
100615: LIST
100616: LIST
100617: LIST
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100638: LD_ADDR_VAR 0 33
100642: PUSH
100643: LD_INT 4
100645: NEG
100646: PUSH
100647: LD_INT 4
100649: NEG
100650: PUSH
100651: EMPTY
100652: LIST
100653: LIST
100654: PUSH
100655: LD_INT 4
100657: NEG
100658: PUSH
100659: LD_INT 5
100661: NEG
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: LD_INT 3
100669: NEG
100670: PUSH
100671: LD_INT 4
100673: NEG
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: PUSH
100679: LD_INT 3
100681: NEG
100682: PUSH
100683: LD_INT 3
100685: NEG
100686: PUSH
100687: EMPTY
100688: LIST
100689: LIST
100690: PUSH
100691: LD_INT 4
100693: NEG
100694: PUSH
100695: LD_INT 3
100697: NEG
100698: PUSH
100699: EMPTY
100700: LIST
100701: LIST
100702: PUSH
100703: LD_INT 5
100705: NEG
100706: PUSH
100707: LD_INT 4
100709: NEG
100710: PUSH
100711: EMPTY
100712: LIST
100713: LIST
100714: PUSH
100715: LD_INT 5
100717: NEG
100718: PUSH
100719: LD_INT 5
100721: NEG
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 3
100729: NEG
100730: PUSH
100731: LD_INT 5
100733: NEG
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 5
100741: NEG
100742: PUSH
100743: LD_INT 3
100745: NEG
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: LD_INT 0
100753: PUSH
100754: LD_INT 3
100756: NEG
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 0
100764: PUSH
100765: LD_INT 4
100767: NEG
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 1
100775: PUSH
100776: LD_INT 3
100778: NEG
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: PUSH
100784: LD_INT 1
100786: PUSH
100787: LD_INT 2
100789: NEG
100790: PUSH
100791: EMPTY
100792: LIST
100793: LIST
100794: PUSH
100795: LD_INT 0
100797: PUSH
100798: LD_INT 2
100800: NEG
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: PUSH
100806: LD_INT 1
100808: NEG
100809: PUSH
100810: LD_INT 3
100812: NEG
100813: PUSH
100814: EMPTY
100815: LIST
100816: LIST
100817: PUSH
100818: LD_INT 1
100820: NEG
100821: PUSH
100822: LD_INT 4
100824: NEG
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: PUSH
100830: LD_INT 2
100832: PUSH
100833: LD_INT 2
100835: NEG
100836: PUSH
100837: EMPTY
100838: LIST
100839: LIST
100840: PUSH
100841: LD_INT 2
100843: NEG
100844: PUSH
100845: LD_INT 4
100847: NEG
100848: PUSH
100849: EMPTY
100850: LIST
100851: LIST
100852: PUSH
100853: LD_INT 4
100855: PUSH
100856: LD_INT 0
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: PUSH
100863: LD_INT 4
100865: PUSH
100866: LD_INT 1
100868: NEG
100869: PUSH
100870: EMPTY
100871: LIST
100872: LIST
100873: PUSH
100874: LD_INT 5
100876: PUSH
100877: LD_INT 0
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PUSH
100884: LD_INT 5
100886: PUSH
100887: LD_INT 1
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PUSH
100894: LD_INT 4
100896: PUSH
100897: LD_INT 1
100899: PUSH
100900: EMPTY
100901: LIST
100902: LIST
100903: PUSH
100904: LD_INT 3
100906: PUSH
100907: LD_INT 0
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 3
100916: PUSH
100917: LD_INT 1
100919: NEG
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PUSH
100925: LD_INT 3
100927: PUSH
100928: LD_INT 2
100930: NEG
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PUSH
100936: LD_INT 5
100938: PUSH
100939: LD_INT 2
100941: PUSH
100942: EMPTY
100943: LIST
100944: LIST
100945: PUSH
100946: LD_INT 3
100948: PUSH
100949: LD_INT 3
100951: PUSH
100952: EMPTY
100953: LIST
100954: LIST
100955: PUSH
100956: LD_INT 3
100958: PUSH
100959: LD_INT 2
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PUSH
100966: LD_INT 4
100968: PUSH
100969: LD_INT 3
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: PUSH
100976: LD_INT 4
100978: PUSH
100979: LD_INT 4
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PUSH
100986: LD_INT 3
100988: PUSH
100989: LD_INT 4
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: PUSH
100996: LD_INT 2
100998: PUSH
100999: LD_INT 3
101001: PUSH
101002: EMPTY
101003: LIST
101004: LIST
101005: PUSH
101006: LD_INT 2
101008: PUSH
101009: LD_INT 2
101011: PUSH
101012: EMPTY
101013: LIST
101014: LIST
101015: PUSH
101016: LD_INT 4
101018: PUSH
101019: LD_INT 2
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: PUSH
101026: LD_INT 2
101028: PUSH
101029: LD_INT 4
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: PUSH
101036: LD_INT 0
101038: PUSH
101039: LD_INT 4
101041: PUSH
101042: EMPTY
101043: LIST
101044: LIST
101045: PUSH
101046: LD_INT 0
101048: PUSH
101049: LD_INT 3
101051: PUSH
101052: EMPTY
101053: LIST
101054: LIST
101055: PUSH
101056: LD_INT 1
101058: PUSH
101059: LD_INT 4
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PUSH
101066: LD_INT 1
101068: PUSH
101069: LD_INT 5
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PUSH
101076: LD_INT 0
101078: PUSH
101079: LD_INT 5
101081: PUSH
101082: EMPTY
101083: LIST
101084: LIST
101085: PUSH
101086: LD_INT 1
101088: NEG
101089: PUSH
101090: LD_INT 4
101092: PUSH
101093: EMPTY
101094: LIST
101095: LIST
101096: PUSH
101097: LD_INT 1
101099: NEG
101100: PUSH
101101: LD_INT 3
101103: PUSH
101104: EMPTY
101105: LIST
101106: LIST
101107: PUSH
101108: LD_INT 2
101110: PUSH
101111: LD_INT 5
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: PUSH
101118: LD_INT 2
101120: NEG
101121: PUSH
101122: LD_INT 3
101124: PUSH
101125: EMPTY
101126: LIST
101127: LIST
101128: PUSH
101129: EMPTY
101130: LIST
101131: LIST
101132: LIST
101133: LIST
101134: LIST
101135: LIST
101136: LIST
101137: LIST
101138: LIST
101139: LIST
101140: LIST
101141: LIST
101142: LIST
101143: LIST
101144: LIST
101145: LIST
101146: LIST
101147: LIST
101148: LIST
101149: LIST
101150: LIST
101151: LIST
101152: LIST
101153: LIST
101154: LIST
101155: LIST
101156: LIST
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101176: LD_ADDR_VAR 0 34
101180: PUSH
101181: LD_INT 0
101183: PUSH
101184: LD_INT 4
101186: NEG
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: PUSH
101192: LD_INT 0
101194: PUSH
101195: LD_INT 5
101197: NEG
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 1
101205: PUSH
101206: LD_INT 4
101208: NEG
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: PUSH
101214: LD_INT 1
101216: PUSH
101217: LD_INT 3
101219: NEG
101220: PUSH
101221: EMPTY
101222: LIST
101223: LIST
101224: PUSH
101225: LD_INT 0
101227: PUSH
101228: LD_INT 3
101230: NEG
101231: PUSH
101232: EMPTY
101233: LIST
101234: LIST
101235: PUSH
101236: LD_INT 1
101238: NEG
101239: PUSH
101240: LD_INT 4
101242: NEG
101243: PUSH
101244: EMPTY
101245: LIST
101246: LIST
101247: PUSH
101248: LD_INT 1
101250: NEG
101251: PUSH
101252: LD_INT 5
101254: NEG
101255: PUSH
101256: EMPTY
101257: LIST
101258: LIST
101259: PUSH
101260: LD_INT 2
101262: PUSH
101263: LD_INT 3
101265: NEG
101266: PUSH
101267: EMPTY
101268: LIST
101269: LIST
101270: PUSH
101271: LD_INT 2
101273: NEG
101274: PUSH
101275: LD_INT 5
101277: NEG
101278: PUSH
101279: EMPTY
101280: LIST
101281: LIST
101282: PUSH
101283: LD_INT 3
101285: PUSH
101286: LD_INT 0
101288: PUSH
101289: EMPTY
101290: LIST
101291: LIST
101292: PUSH
101293: LD_INT 3
101295: PUSH
101296: LD_INT 1
101298: NEG
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: LD_INT 4
101306: PUSH
101307: LD_INT 0
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 4
101316: PUSH
101317: LD_INT 1
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: LD_INT 3
101326: PUSH
101327: LD_INT 1
101329: PUSH
101330: EMPTY
101331: LIST
101332: LIST
101333: PUSH
101334: LD_INT 2
101336: PUSH
101337: LD_INT 0
101339: PUSH
101340: EMPTY
101341: LIST
101342: LIST
101343: PUSH
101344: LD_INT 2
101346: PUSH
101347: LD_INT 1
101349: NEG
101350: PUSH
101351: EMPTY
101352: LIST
101353: LIST
101354: PUSH
101355: LD_INT 2
101357: PUSH
101358: LD_INT 2
101360: NEG
101361: PUSH
101362: EMPTY
101363: LIST
101364: LIST
101365: PUSH
101366: LD_INT 4
101368: PUSH
101369: LD_INT 2
101371: PUSH
101372: EMPTY
101373: LIST
101374: LIST
101375: PUSH
101376: LD_INT 4
101378: PUSH
101379: LD_INT 4
101381: PUSH
101382: EMPTY
101383: LIST
101384: LIST
101385: PUSH
101386: LD_INT 4
101388: PUSH
101389: LD_INT 3
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: PUSH
101396: LD_INT 5
101398: PUSH
101399: LD_INT 4
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: LD_INT 5
101408: PUSH
101409: LD_INT 5
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 4
101418: PUSH
101419: LD_INT 5
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PUSH
101426: LD_INT 3
101428: PUSH
101429: LD_INT 4
101431: PUSH
101432: EMPTY
101433: LIST
101434: LIST
101435: PUSH
101436: LD_INT 3
101438: PUSH
101439: LD_INT 3
101441: PUSH
101442: EMPTY
101443: LIST
101444: LIST
101445: PUSH
101446: LD_INT 5
101448: PUSH
101449: LD_INT 3
101451: PUSH
101452: EMPTY
101453: LIST
101454: LIST
101455: PUSH
101456: LD_INT 3
101458: PUSH
101459: LD_INT 5
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: PUSH
101466: LD_INT 0
101468: PUSH
101469: LD_INT 3
101471: PUSH
101472: EMPTY
101473: LIST
101474: LIST
101475: PUSH
101476: LD_INT 0
101478: PUSH
101479: LD_INT 2
101481: PUSH
101482: EMPTY
101483: LIST
101484: LIST
101485: PUSH
101486: LD_INT 1
101488: PUSH
101489: LD_INT 3
101491: PUSH
101492: EMPTY
101493: LIST
101494: LIST
101495: PUSH
101496: LD_INT 1
101498: PUSH
101499: LD_INT 4
101501: PUSH
101502: EMPTY
101503: LIST
101504: LIST
101505: PUSH
101506: LD_INT 0
101508: PUSH
101509: LD_INT 4
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PUSH
101516: LD_INT 1
101518: NEG
101519: PUSH
101520: LD_INT 3
101522: PUSH
101523: EMPTY
101524: LIST
101525: LIST
101526: PUSH
101527: LD_INT 1
101529: NEG
101530: PUSH
101531: LD_INT 2
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PUSH
101538: LD_INT 2
101540: PUSH
101541: LD_INT 4
101543: PUSH
101544: EMPTY
101545: LIST
101546: LIST
101547: PUSH
101548: LD_INT 2
101550: NEG
101551: PUSH
101552: LD_INT 2
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: PUSH
101559: LD_INT 4
101561: NEG
101562: PUSH
101563: LD_INT 0
101565: PUSH
101566: EMPTY
101567: LIST
101568: LIST
101569: PUSH
101570: LD_INT 4
101572: NEG
101573: PUSH
101574: LD_INT 1
101576: NEG
101577: PUSH
101578: EMPTY
101579: LIST
101580: LIST
101581: PUSH
101582: LD_INT 3
101584: NEG
101585: PUSH
101586: LD_INT 0
101588: PUSH
101589: EMPTY
101590: LIST
101591: LIST
101592: PUSH
101593: LD_INT 3
101595: NEG
101596: PUSH
101597: LD_INT 1
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: PUSH
101604: LD_INT 4
101606: NEG
101607: PUSH
101608: LD_INT 1
101610: PUSH
101611: EMPTY
101612: LIST
101613: LIST
101614: PUSH
101615: LD_INT 5
101617: NEG
101618: PUSH
101619: LD_INT 0
101621: PUSH
101622: EMPTY
101623: LIST
101624: LIST
101625: PUSH
101626: LD_INT 5
101628: NEG
101629: PUSH
101630: LD_INT 1
101632: NEG
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: PUSH
101638: LD_INT 5
101640: NEG
101641: PUSH
101642: LD_INT 2
101644: NEG
101645: PUSH
101646: EMPTY
101647: LIST
101648: LIST
101649: PUSH
101650: LD_INT 3
101652: NEG
101653: PUSH
101654: LD_INT 2
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: PUSH
101661: EMPTY
101662: LIST
101663: LIST
101664: LIST
101665: LIST
101666: LIST
101667: LIST
101668: LIST
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: LIST
101674: LIST
101675: LIST
101676: LIST
101677: LIST
101678: LIST
101679: LIST
101680: LIST
101681: LIST
101682: LIST
101683: LIST
101684: LIST
101685: LIST
101686: LIST
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: LIST
101692: LIST
101693: LIST
101694: LIST
101695: LIST
101696: LIST
101697: LIST
101698: LIST
101699: LIST
101700: LIST
101701: LIST
101702: LIST
101703: LIST
101704: LIST
101705: LIST
101706: LIST
101707: ST_TO_ADDR
// end ; end ;
101708: GO 101711
101710: POP
// case btype of b_depot , b_warehouse :
101711: LD_VAR 0 1
101715: PUSH
101716: LD_INT 0
101718: DOUBLE
101719: EQUAL
101720: IFTRUE 101730
101722: LD_INT 1
101724: DOUBLE
101725: EQUAL
101726: IFTRUE 101730
101728: GO 101931
101730: POP
// case nation of nation_american :
101731: LD_VAR 0 5
101735: PUSH
101736: LD_INT 1
101738: DOUBLE
101739: EQUAL
101740: IFTRUE 101744
101742: GO 101800
101744: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101745: LD_ADDR_VAR 0 9
101749: PUSH
101750: LD_VAR 0 11
101754: PUSH
101755: LD_VAR 0 12
101759: PUSH
101760: LD_VAR 0 13
101764: PUSH
101765: LD_VAR 0 14
101769: PUSH
101770: LD_VAR 0 15
101774: PUSH
101775: LD_VAR 0 16
101779: PUSH
101780: EMPTY
101781: LIST
101782: LIST
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: PUSH
101788: LD_VAR 0 4
101792: PUSH
101793: LD_INT 1
101795: PLUS
101796: ARRAY
101797: ST_TO_ADDR
101798: GO 101929
101800: LD_INT 2
101802: DOUBLE
101803: EQUAL
101804: IFTRUE 101808
101806: GO 101864
101808: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101809: LD_ADDR_VAR 0 9
101813: PUSH
101814: LD_VAR 0 17
101818: PUSH
101819: LD_VAR 0 18
101823: PUSH
101824: LD_VAR 0 19
101828: PUSH
101829: LD_VAR 0 20
101833: PUSH
101834: LD_VAR 0 21
101838: PUSH
101839: LD_VAR 0 22
101843: PUSH
101844: EMPTY
101845: LIST
101846: LIST
101847: LIST
101848: LIST
101849: LIST
101850: LIST
101851: PUSH
101852: LD_VAR 0 4
101856: PUSH
101857: LD_INT 1
101859: PLUS
101860: ARRAY
101861: ST_TO_ADDR
101862: GO 101929
101864: LD_INT 3
101866: DOUBLE
101867: EQUAL
101868: IFTRUE 101872
101870: GO 101928
101872: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101873: LD_ADDR_VAR 0 9
101877: PUSH
101878: LD_VAR 0 23
101882: PUSH
101883: LD_VAR 0 24
101887: PUSH
101888: LD_VAR 0 25
101892: PUSH
101893: LD_VAR 0 26
101897: PUSH
101898: LD_VAR 0 27
101902: PUSH
101903: LD_VAR 0 28
101907: PUSH
101908: EMPTY
101909: LIST
101910: LIST
101911: LIST
101912: LIST
101913: LIST
101914: LIST
101915: PUSH
101916: LD_VAR 0 4
101920: PUSH
101921: LD_INT 1
101923: PLUS
101924: ARRAY
101925: ST_TO_ADDR
101926: GO 101929
101928: POP
101929: GO 102484
101931: LD_INT 2
101933: DOUBLE
101934: EQUAL
101935: IFTRUE 101945
101937: LD_INT 3
101939: DOUBLE
101940: EQUAL
101941: IFTRUE 101945
101943: GO 102001
101945: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101946: LD_ADDR_VAR 0 9
101950: PUSH
101951: LD_VAR 0 29
101955: PUSH
101956: LD_VAR 0 30
101960: PUSH
101961: LD_VAR 0 31
101965: PUSH
101966: LD_VAR 0 32
101970: PUSH
101971: LD_VAR 0 33
101975: PUSH
101976: LD_VAR 0 34
101980: PUSH
101981: EMPTY
101982: LIST
101983: LIST
101984: LIST
101985: LIST
101986: LIST
101987: LIST
101988: PUSH
101989: LD_VAR 0 4
101993: PUSH
101994: LD_INT 1
101996: PLUS
101997: ARRAY
101998: ST_TO_ADDR
101999: GO 102484
102001: LD_INT 16
102003: DOUBLE
102004: EQUAL
102005: IFTRUE 102063
102007: LD_INT 17
102009: DOUBLE
102010: EQUAL
102011: IFTRUE 102063
102013: LD_INT 18
102015: DOUBLE
102016: EQUAL
102017: IFTRUE 102063
102019: LD_INT 19
102021: DOUBLE
102022: EQUAL
102023: IFTRUE 102063
102025: LD_INT 22
102027: DOUBLE
102028: EQUAL
102029: IFTRUE 102063
102031: LD_INT 20
102033: DOUBLE
102034: EQUAL
102035: IFTRUE 102063
102037: LD_INT 21
102039: DOUBLE
102040: EQUAL
102041: IFTRUE 102063
102043: LD_INT 23
102045: DOUBLE
102046: EQUAL
102047: IFTRUE 102063
102049: LD_INT 24
102051: DOUBLE
102052: EQUAL
102053: IFTRUE 102063
102055: LD_INT 25
102057: DOUBLE
102058: EQUAL
102059: IFTRUE 102063
102061: GO 102119
102063: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102064: LD_ADDR_VAR 0 9
102068: PUSH
102069: LD_VAR 0 35
102073: PUSH
102074: LD_VAR 0 36
102078: PUSH
102079: LD_VAR 0 37
102083: PUSH
102084: LD_VAR 0 38
102088: PUSH
102089: LD_VAR 0 39
102093: PUSH
102094: LD_VAR 0 40
102098: PUSH
102099: EMPTY
102100: LIST
102101: LIST
102102: LIST
102103: LIST
102104: LIST
102105: LIST
102106: PUSH
102107: LD_VAR 0 4
102111: PUSH
102112: LD_INT 1
102114: PLUS
102115: ARRAY
102116: ST_TO_ADDR
102117: GO 102484
102119: LD_INT 6
102121: DOUBLE
102122: EQUAL
102123: IFTRUE 102175
102125: LD_INT 7
102127: DOUBLE
102128: EQUAL
102129: IFTRUE 102175
102131: LD_INT 8
102133: DOUBLE
102134: EQUAL
102135: IFTRUE 102175
102137: LD_INT 13
102139: DOUBLE
102140: EQUAL
102141: IFTRUE 102175
102143: LD_INT 12
102145: DOUBLE
102146: EQUAL
102147: IFTRUE 102175
102149: LD_INT 15
102151: DOUBLE
102152: EQUAL
102153: IFTRUE 102175
102155: LD_INT 11
102157: DOUBLE
102158: EQUAL
102159: IFTRUE 102175
102161: LD_INT 14
102163: DOUBLE
102164: EQUAL
102165: IFTRUE 102175
102167: LD_INT 10
102169: DOUBLE
102170: EQUAL
102171: IFTRUE 102175
102173: GO 102231
102175: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102176: LD_ADDR_VAR 0 9
102180: PUSH
102181: LD_VAR 0 41
102185: PUSH
102186: LD_VAR 0 42
102190: PUSH
102191: LD_VAR 0 43
102195: PUSH
102196: LD_VAR 0 44
102200: PUSH
102201: LD_VAR 0 45
102205: PUSH
102206: LD_VAR 0 46
102210: PUSH
102211: EMPTY
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: PUSH
102219: LD_VAR 0 4
102223: PUSH
102224: LD_INT 1
102226: PLUS
102227: ARRAY
102228: ST_TO_ADDR
102229: GO 102484
102231: LD_INT 36
102233: DOUBLE
102234: EQUAL
102235: IFTRUE 102239
102237: GO 102295
102239: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102240: LD_ADDR_VAR 0 9
102244: PUSH
102245: LD_VAR 0 47
102249: PUSH
102250: LD_VAR 0 48
102254: PUSH
102255: LD_VAR 0 49
102259: PUSH
102260: LD_VAR 0 50
102264: PUSH
102265: LD_VAR 0 51
102269: PUSH
102270: LD_VAR 0 52
102274: PUSH
102275: EMPTY
102276: LIST
102277: LIST
102278: LIST
102279: LIST
102280: LIST
102281: LIST
102282: PUSH
102283: LD_VAR 0 4
102287: PUSH
102288: LD_INT 1
102290: PLUS
102291: ARRAY
102292: ST_TO_ADDR
102293: GO 102484
102295: LD_INT 4
102297: DOUBLE
102298: EQUAL
102299: IFTRUE 102321
102301: LD_INT 5
102303: DOUBLE
102304: EQUAL
102305: IFTRUE 102321
102307: LD_INT 34
102309: DOUBLE
102310: EQUAL
102311: IFTRUE 102321
102313: LD_INT 37
102315: DOUBLE
102316: EQUAL
102317: IFTRUE 102321
102319: GO 102377
102321: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102322: LD_ADDR_VAR 0 9
102326: PUSH
102327: LD_VAR 0 53
102331: PUSH
102332: LD_VAR 0 54
102336: PUSH
102337: LD_VAR 0 55
102341: PUSH
102342: LD_VAR 0 56
102346: PUSH
102347: LD_VAR 0 57
102351: PUSH
102352: LD_VAR 0 58
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: LIST
102363: LIST
102364: PUSH
102365: LD_VAR 0 4
102369: PUSH
102370: LD_INT 1
102372: PLUS
102373: ARRAY
102374: ST_TO_ADDR
102375: GO 102484
102377: LD_INT 31
102379: DOUBLE
102380: EQUAL
102381: IFTRUE 102427
102383: LD_INT 32
102385: DOUBLE
102386: EQUAL
102387: IFTRUE 102427
102389: LD_INT 33
102391: DOUBLE
102392: EQUAL
102393: IFTRUE 102427
102395: LD_INT 27
102397: DOUBLE
102398: EQUAL
102399: IFTRUE 102427
102401: LD_INT 26
102403: DOUBLE
102404: EQUAL
102405: IFTRUE 102427
102407: LD_INT 28
102409: DOUBLE
102410: EQUAL
102411: IFTRUE 102427
102413: LD_INT 29
102415: DOUBLE
102416: EQUAL
102417: IFTRUE 102427
102419: LD_INT 30
102421: DOUBLE
102422: EQUAL
102423: IFTRUE 102427
102425: GO 102483
102427: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102428: LD_ADDR_VAR 0 9
102432: PUSH
102433: LD_VAR 0 59
102437: PUSH
102438: LD_VAR 0 60
102442: PUSH
102443: LD_VAR 0 61
102447: PUSH
102448: LD_VAR 0 62
102452: PUSH
102453: LD_VAR 0 63
102457: PUSH
102458: LD_VAR 0 64
102462: PUSH
102463: EMPTY
102464: LIST
102465: LIST
102466: LIST
102467: LIST
102468: LIST
102469: LIST
102470: PUSH
102471: LD_VAR 0 4
102475: PUSH
102476: LD_INT 1
102478: PLUS
102479: ARRAY
102480: ST_TO_ADDR
102481: GO 102484
102483: POP
// temp_list2 = [ ] ;
102484: LD_ADDR_VAR 0 10
102488: PUSH
102489: EMPTY
102490: ST_TO_ADDR
// for i in temp_list do
102491: LD_ADDR_VAR 0 8
102495: PUSH
102496: LD_VAR 0 9
102500: PUSH
102501: FOR_IN
102502: IFFALSE 102554
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102504: LD_ADDR_VAR 0 10
102508: PUSH
102509: LD_VAR 0 10
102513: PUSH
102514: LD_VAR 0 8
102518: PUSH
102519: LD_INT 1
102521: ARRAY
102522: PUSH
102523: LD_VAR 0 2
102527: PLUS
102528: PUSH
102529: LD_VAR 0 8
102533: PUSH
102534: LD_INT 2
102536: ARRAY
102537: PUSH
102538: LD_VAR 0 3
102542: PLUS
102543: PUSH
102544: EMPTY
102545: LIST
102546: LIST
102547: PUSH
102548: EMPTY
102549: LIST
102550: ADD
102551: ST_TO_ADDR
102552: GO 102501
102554: POP
102555: POP
// result = temp_list2 ;
102556: LD_ADDR_VAR 0 7
102560: PUSH
102561: LD_VAR 0 10
102565: ST_TO_ADDR
// end ;
102566: LD_VAR 0 7
102570: RET
// export function EnemyInRange ( unit , dist ) ; begin
102571: LD_INT 0
102573: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102574: LD_ADDR_VAR 0 3
102578: PUSH
102579: LD_VAR 0 1
102583: PPUSH
102584: CALL_OW 255
102588: PPUSH
102589: LD_VAR 0 1
102593: PPUSH
102594: CALL_OW 250
102598: PPUSH
102599: LD_VAR 0 1
102603: PPUSH
102604: CALL_OW 251
102608: PPUSH
102609: LD_VAR 0 2
102613: PPUSH
102614: CALL 75944 0 4
102618: PUSH
102619: LD_INT 4
102621: ARRAY
102622: ST_TO_ADDR
// end ;
102623: LD_VAR 0 3
102627: RET
// export function PlayerSeeMe ( unit ) ; begin
102628: LD_INT 0
102630: PPUSH
// result := See ( your_side , unit ) ;
102631: LD_ADDR_VAR 0 2
102635: PUSH
102636: LD_OWVAR 2
102640: PPUSH
102641: LD_VAR 0 1
102645: PPUSH
102646: CALL_OW 292
102650: ST_TO_ADDR
// end ;
102651: LD_VAR 0 2
102655: RET
// export function ReverseDir ( unit ) ; begin
102656: LD_INT 0
102658: PPUSH
// if not unit then
102659: LD_VAR 0 1
102663: NOT
102664: IFFALSE 102668
// exit ;
102666: GO 102691
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102668: LD_ADDR_VAR 0 2
102672: PUSH
102673: LD_VAR 0 1
102677: PPUSH
102678: CALL_OW 254
102682: PUSH
102683: LD_INT 3
102685: PLUS
102686: PUSH
102687: LD_INT 6
102689: MOD
102690: ST_TO_ADDR
// end ;
102691: LD_VAR 0 2
102695: RET
// export function ReverseArray ( array ) ; var i ; begin
102696: LD_INT 0
102698: PPUSH
102699: PPUSH
// if not array then
102700: LD_VAR 0 1
102704: NOT
102705: IFFALSE 102709
// exit ;
102707: GO 102764
// result := [ ] ;
102709: LD_ADDR_VAR 0 2
102713: PUSH
102714: EMPTY
102715: ST_TO_ADDR
// for i := array downto 1 do
102716: LD_ADDR_VAR 0 3
102720: PUSH
102721: DOUBLE
102722: LD_VAR 0 1
102726: INC
102727: ST_TO_ADDR
102728: LD_INT 1
102730: PUSH
102731: FOR_DOWNTO
102732: IFFALSE 102762
// result := Join ( result , array [ i ] ) ;
102734: LD_ADDR_VAR 0 2
102738: PUSH
102739: LD_VAR 0 2
102743: PPUSH
102744: LD_VAR 0 1
102748: PUSH
102749: LD_VAR 0 3
102753: ARRAY
102754: PPUSH
102755: CALL 107409 0 2
102759: ST_TO_ADDR
102760: GO 102731
102762: POP
102763: POP
// end ;
102764: LD_VAR 0 2
102768: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102769: LD_INT 0
102771: PPUSH
102772: PPUSH
102773: PPUSH
102774: PPUSH
102775: PPUSH
102776: PPUSH
// if not unit or not hexes then
102777: LD_VAR 0 1
102781: NOT
102782: PUSH
102783: LD_VAR 0 2
102787: NOT
102788: OR
102789: IFFALSE 102793
// exit ;
102791: GO 102916
// dist := 9999 ;
102793: LD_ADDR_VAR 0 5
102797: PUSH
102798: LD_INT 9999
102800: ST_TO_ADDR
// for i = 1 to hexes do
102801: LD_ADDR_VAR 0 4
102805: PUSH
102806: DOUBLE
102807: LD_INT 1
102809: DEC
102810: ST_TO_ADDR
102811: LD_VAR 0 2
102815: PUSH
102816: FOR_TO
102817: IFFALSE 102904
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102819: LD_ADDR_VAR 0 6
102823: PUSH
102824: LD_VAR 0 1
102828: PPUSH
102829: LD_VAR 0 2
102833: PUSH
102834: LD_VAR 0 4
102838: ARRAY
102839: PUSH
102840: LD_INT 1
102842: ARRAY
102843: PPUSH
102844: LD_VAR 0 2
102848: PUSH
102849: LD_VAR 0 4
102853: ARRAY
102854: PUSH
102855: LD_INT 2
102857: ARRAY
102858: PPUSH
102859: CALL_OW 297
102863: ST_TO_ADDR
// if tdist < dist then
102864: LD_VAR 0 6
102868: PUSH
102869: LD_VAR 0 5
102873: LESS
102874: IFFALSE 102902
// begin hex := hexes [ i ] ;
102876: LD_ADDR_VAR 0 8
102880: PUSH
102881: LD_VAR 0 2
102885: PUSH
102886: LD_VAR 0 4
102890: ARRAY
102891: ST_TO_ADDR
// dist := tdist ;
102892: LD_ADDR_VAR 0 5
102896: PUSH
102897: LD_VAR 0 6
102901: ST_TO_ADDR
// end ; end ;
102902: GO 102816
102904: POP
102905: POP
// result := hex ;
102906: LD_ADDR_VAR 0 3
102910: PUSH
102911: LD_VAR 0 8
102915: ST_TO_ADDR
// end ;
102916: LD_VAR 0 3
102920: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102921: LD_INT 0
102923: PPUSH
102924: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102925: LD_VAR 0 1
102929: NOT
102930: PUSH
102931: LD_VAR 0 1
102935: PUSH
102936: LD_INT 21
102938: PUSH
102939: LD_INT 2
102941: PUSH
102942: EMPTY
102943: LIST
102944: LIST
102945: PUSH
102946: LD_INT 23
102948: PUSH
102949: LD_INT 2
102951: PUSH
102952: EMPTY
102953: LIST
102954: LIST
102955: PUSH
102956: EMPTY
102957: LIST
102958: LIST
102959: PPUSH
102960: CALL_OW 69
102964: IN
102965: NOT
102966: OR
102967: IFFALSE 102971
// exit ;
102969: GO 103018
// for i = 1 to 3 do
102971: LD_ADDR_VAR 0 3
102975: PUSH
102976: DOUBLE
102977: LD_INT 1
102979: DEC
102980: ST_TO_ADDR
102981: LD_INT 3
102983: PUSH
102984: FOR_TO
102985: IFFALSE 103016
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102987: LD_VAR 0 1
102991: PPUSH
102992: CALL_OW 250
102996: PPUSH
102997: LD_VAR 0 1
103001: PPUSH
103002: CALL_OW 251
103006: PPUSH
103007: LD_INT 1
103009: PPUSH
103010: CALL_OW 453
103014: GO 102984
103016: POP
103017: POP
// end ;
103018: LD_VAR 0 2
103022: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103023: LD_INT 0
103025: PPUSH
103026: PPUSH
103027: PPUSH
103028: PPUSH
103029: PPUSH
103030: PPUSH
// if not unit or not enemy_unit then
103031: LD_VAR 0 1
103035: NOT
103036: PUSH
103037: LD_VAR 0 2
103041: NOT
103042: OR
103043: IFFALSE 103047
// exit ;
103045: GO 103514
// if GetLives ( i ) < 250 then
103047: LD_VAR 0 4
103051: PPUSH
103052: CALL_OW 256
103056: PUSH
103057: LD_INT 250
103059: LESS
103060: IFFALSE 103073
// begin ComAutodestruct ( i ) ;
103062: LD_VAR 0 4
103066: PPUSH
103067: CALL 102921 0 1
// exit ;
103071: GO 103514
// end ; x := GetX ( enemy_unit ) ;
103073: LD_ADDR_VAR 0 7
103077: PUSH
103078: LD_VAR 0 2
103082: PPUSH
103083: CALL_OW 250
103087: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103088: LD_ADDR_VAR 0 8
103092: PUSH
103093: LD_VAR 0 2
103097: PPUSH
103098: CALL_OW 251
103102: ST_TO_ADDR
// if not x or not y then
103103: LD_VAR 0 7
103107: NOT
103108: PUSH
103109: LD_VAR 0 8
103113: NOT
103114: OR
103115: IFFALSE 103119
// exit ;
103117: GO 103514
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103119: LD_ADDR_VAR 0 6
103123: PUSH
103124: LD_VAR 0 7
103128: PPUSH
103129: LD_INT 0
103131: PPUSH
103132: LD_INT 4
103134: PPUSH
103135: CALL_OW 272
103139: PUSH
103140: LD_VAR 0 8
103144: PPUSH
103145: LD_INT 0
103147: PPUSH
103148: LD_INT 4
103150: PPUSH
103151: CALL_OW 273
103155: PUSH
103156: EMPTY
103157: LIST
103158: LIST
103159: PUSH
103160: LD_VAR 0 7
103164: PPUSH
103165: LD_INT 1
103167: PPUSH
103168: LD_INT 4
103170: PPUSH
103171: CALL_OW 272
103175: PUSH
103176: LD_VAR 0 8
103180: PPUSH
103181: LD_INT 1
103183: PPUSH
103184: LD_INT 4
103186: PPUSH
103187: CALL_OW 273
103191: PUSH
103192: EMPTY
103193: LIST
103194: LIST
103195: PUSH
103196: LD_VAR 0 7
103200: PPUSH
103201: LD_INT 2
103203: PPUSH
103204: LD_INT 4
103206: PPUSH
103207: CALL_OW 272
103211: PUSH
103212: LD_VAR 0 8
103216: PPUSH
103217: LD_INT 2
103219: PPUSH
103220: LD_INT 4
103222: PPUSH
103223: CALL_OW 273
103227: PUSH
103228: EMPTY
103229: LIST
103230: LIST
103231: PUSH
103232: LD_VAR 0 7
103236: PPUSH
103237: LD_INT 3
103239: PPUSH
103240: LD_INT 4
103242: PPUSH
103243: CALL_OW 272
103247: PUSH
103248: LD_VAR 0 8
103252: PPUSH
103253: LD_INT 3
103255: PPUSH
103256: LD_INT 4
103258: PPUSH
103259: CALL_OW 273
103263: PUSH
103264: EMPTY
103265: LIST
103266: LIST
103267: PUSH
103268: LD_VAR 0 7
103272: PPUSH
103273: LD_INT 4
103275: PPUSH
103276: LD_INT 4
103278: PPUSH
103279: CALL_OW 272
103283: PUSH
103284: LD_VAR 0 8
103288: PPUSH
103289: LD_INT 4
103291: PPUSH
103292: LD_INT 4
103294: PPUSH
103295: CALL_OW 273
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: PUSH
103304: LD_VAR 0 7
103308: PPUSH
103309: LD_INT 5
103311: PPUSH
103312: LD_INT 4
103314: PPUSH
103315: CALL_OW 272
103319: PUSH
103320: LD_VAR 0 8
103324: PPUSH
103325: LD_INT 5
103327: PPUSH
103328: LD_INT 4
103330: PPUSH
103331: CALL_OW 273
103335: PUSH
103336: EMPTY
103337: LIST
103338: LIST
103339: PUSH
103340: EMPTY
103341: LIST
103342: LIST
103343: LIST
103344: LIST
103345: LIST
103346: LIST
103347: ST_TO_ADDR
// for i = tmp downto 1 do
103348: LD_ADDR_VAR 0 4
103352: PUSH
103353: DOUBLE
103354: LD_VAR 0 6
103358: INC
103359: ST_TO_ADDR
103360: LD_INT 1
103362: PUSH
103363: FOR_DOWNTO
103364: IFFALSE 103465
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103366: LD_VAR 0 6
103370: PUSH
103371: LD_VAR 0 4
103375: ARRAY
103376: PUSH
103377: LD_INT 1
103379: ARRAY
103380: PPUSH
103381: LD_VAR 0 6
103385: PUSH
103386: LD_VAR 0 4
103390: ARRAY
103391: PUSH
103392: LD_INT 2
103394: ARRAY
103395: PPUSH
103396: CALL_OW 488
103400: NOT
103401: PUSH
103402: LD_VAR 0 6
103406: PUSH
103407: LD_VAR 0 4
103411: ARRAY
103412: PUSH
103413: LD_INT 1
103415: ARRAY
103416: PPUSH
103417: LD_VAR 0 6
103421: PUSH
103422: LD_VAR 0 4
103426: ARRAY
103427: PUSH
103428: LD_INT 2
103430: ARRAY
103431: PPUSH
103432: CALL_OW 428
103436: PUSH
103437: LD_INT 0
103439: NONEQUAL
103440: OR
103441: IFFALSE 103463
// tmp := Delete ( tmp , i ) ;
103443: LD_ADDR_VAR 0 6
103447: PUSH
103448: LD_VAR 0 6
103452: PPUSH
103453: LD_VAR 0 4
103457: PPUSH
103458: CALL_OW 3
103462: ST_TO_ADDR
103463: GO 103363
103465: POP
103466: POP
// j := GetClosestHex ( unit , tmp ) ;
103467: LD_ADDR_VAR 0 5
103471: PUSH
103472: LD_VAR 0 1
103476: PPUSH
103477: LD_VAR 0 6
103481: PPUSH
103482: CALL 102769 0 2
103486: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103487: LD_VAR 0 1
103491: PPUSH
103492: LD_VAR 0 5
103496: PUSH
103497: LD_INT 1
103499: ARRAY
103500: PPUSH
103501: LD_VAR 0 5
103505: PUSH
103506: LD_INT 2
103508: ARRAY
103509: PPUSH
103510: CALL_OW 111
// end ;
103514: LD_VAR 0 3
103518: RET
// export function PrepareApemanSoldier ( ) ; begin
103519: LD_INT 0
103521: PPUSH
// uc_nation := 0 ;
103522: LD_ADDR_OWVAR 21
103526: PUSH
103527: LD_INT 0
103529: ST_TO_ADDR
// hc_sex := sex_male ;
103530: LD_ADDR_OWVAR 27
103534: PUSH
103535: LD_INT 1
103537: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103538: LD_ADDR_OWVAR 28
103542: PUSH
103543: LD_INT 15
103545: ST_TO_ADDR
// hc_gallery :=  ;
103546: LD_ADDR_OWVAR 33
103550: PUSH
103551: LD_STRING 
103553: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103554: LD_ADDR_OWVAR 31
103558: PUSH
103559: LD_INT 0
103561: PPUSH
103562: LD_INT 3
103564: PPUSH
103565: CALL_OW 12
103569: PUSH
103570: LD_INT 0
103572: PPUSH
103573: LD_INT 3
103575: PPUSH
103576: CALL_OW 12
103580: PUSH
103581: LD_INT 0
103583: PUSH
103584: LD_INT 0
103586: PUSH
103587: EMPTY
103588: LIST
103589: LIST
103590: LIST
103591: LIST
103592: ST_TO_ADDR
// end ;
103593: LD_VAR 0 1
103597: RET
// export function PrepareApemanEngineer ( ) ; begin
103598: LD_INT 0
103600: PPUSH
// uc_nation := 0 ;
103601: LD_ADDR_OWVAR 21
103605: PUSH
103606: LD_INT 0
103608: ST_TO_ADDR
// hc_sex := sex_male ;
103609: LD_ADDR_OWVAR 27
103613: PUSH
103614: LD_INT 1
103616: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103617: LD_ADDR_OWVAR 28
103621: PUSH
103622: LD_INT 16
103624: ST_TO_ADDR
// hc_gallery :=  ;
103625: LD_ADDR_OWVAR 33
103629: PUSH
103630: LD_STRING 
103632: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103633: LD_ADDR_OWVAR 31
103637: PUSH
103638: LD_INT 0
103640: PPUSH
103641: LD_INT 3
103643: PPUSH
103644: CALL_OW 12
103648: PUSH
103649: LD_INT 0
103651: PPUSH
103652: LD_INT 3
103654: PPUSH
103655: CALL_OW 12
103659: PUSH
103660: LD_INT 0
103662: PUSH
103663: LD_INT 0
103665: PUSH
103666: EMPTY
103667: LIST
103668: LIST
103669: LIST
103670: LIST
103671: ST_TO_ADDR
// end ;
103672: LD_VAR 0 1
103676: RET
// export function PrepareApeman ( agressivity ) ; begin
103677: LD_INT 0
103679: PPUSH
// uc_side := 0 ;
103680: LD_ADDR_OWVAR 20
103684: PUSH
103685: LD_INT 0
103687: ST_TO_ADDR
// uc_nation := 0 ;
103688: LD_ADDR_OWVAR 21
103692: PUSH
103693: LD_INT 0
103695: ST_TO_ADDR
// hc_sex := sex_male ;
103696: LD_ADDR_OWVAR 27
103700: PUSH
103701: LD_INT 1
103703: ST_TO_ADDR
// hc_class := class_apeman ;
103704: LD_ADDR_OWVAR 28
103708: PUSH
103709: LD_INT 12
103711: ST_TO_ADDR
// hc_gallery :=  ;
103712: LD_ADDR_OWVAR 33
103716: PUSH
103717: LD_STRING 
103719: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103720: LD_ADDR_OWVAR 35
103724: PUSH
103725: LD_VAR 0 1
103729: NEG
103730: PPUSH
103731: LD_VAR 0 1
103735: PPUSH
103736: CALL_OW 12
103740: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103741: LD_ADDR_OWVAR 31
103745: PUSH
103746: LD_INT 0
103748: PPUSH
103749: LD_INT 3
103751: PPUSH
103752: CALL_OW 12
103756: PUSH
103757: LD_INT 0
103759: PPUSH
103760: LD_INT 3
103762: PPUSH
103763: CALL_OW 12
103767: PUSH
103768: LD_INT 0
103770: PUSH
103771: LD_INT 0
103773: PUSH
103774: EMPTY
103775: LIST
103776: LIST
103777: LIST
103778: LIST
103779: ST_TO_ADDR
// end ;
103780: LD_VAR 0 2
103784: RET
// export function PrepareTiger ( agressivity ) ; begin
103785: LD_INT 0
103787: PPUSH
// uc_side := 0 ;
103788: LD_ADDR_OWVAR 20
103792: PUSH
103793: LD_INT 0
103795: ST_TO_ADDR
// uc_nation := 0 ;
103796: LD_ADDR_OWVAR 21
103800: PUSH
103801: LD_INT 0
103803: ST_TO_ADDR
// hc_class := class_tiger ;
103804: LD_ADDR_OWVAR 28
103808: PUSH
103809: LD_INT 14
103811: ST_TO_ADDR
// hc_gallery :=  ;
103812: LD_ADDR_OWVAR 33
103816: PUSH
103817: LD_STRING 
103819: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103820: LD_ADDR_OWVAR 35
103824: PUSH
103825: LD_VAR 0 1
103829: NEG
103830: PPUSH
103831: LD_VAR 0 1
103835: PPUSH
103836: CALL_OW 12
103840: ST_TO_ADDR
// end ;
103841: LD_VAR 0 2
103845: RET
// export function PrepareEnchidna ( ) ; begin
103846: LD_INT 0
103848: PPUSH
// uc_side := 0 ;
103849: LD_ADDR_OWVAR 20
103853: PUSH
103854: LD_INT 0
103856: ST_TO_ADDR
// uc_nation := 0 ;
103857: LD_ADDR_OWVAR 21
103861: PUSH
103862: LD_INT 0
103864: ST_TO_ADDR
// hc_class := class_baggie ;
103865: LD_ADDR_OWVAR 28
103869: PUSH
103870: LD_INT 13
103872: ST_TO_ADDR
// hc_gallery :=  ;
103873: LD_ADDR_OWVAR 33
103877: PUSH
103878: LD_STRING 
103880: ST_TO_ADDR
// end ;
103881: LD_VAR 0 1
103885: RET
// export function PrepareFrog ( ) ; begin
103886: LD_INT 0
103888: PPUSH
// uc_side := 0 ;
103889: LD_ADDR_OWVAR 20
103893: PUSH
103894: LD_INT 0
103896: ST_TO_ADDR
// uc_nation := 0 ;
103897: LD_ADDR_OWVAR 21
103901: PUSH
103902: LD_INT 0
103904: ST_TO_ADDR
// hc_class := class_frog ;
103905: LD_ADDR_OWVAR 28
103909: PUSH
103910: LD_INT 19
103912: ST_TO_ADDR
// hc_gallery :=  ;
103913: LD_ADDR_OWVAR 33
103917: PUSH
103918: LD_STRING 
103920: ST_TO_ADDR
// end ;
103921: LD_VAR 0 1
103925: RET
// export function PrepareFish ( ) ; begin
103926: LD_INT 0
103928: PPUSH
// uc_side := 0 ;
103929: LD_ADDR_OWVAR 20
103933: PUSH
103934: LD_INT 0
103936: ST_TO_ADDR
// uc_nation := 0 ;
103937: LD_ADDR_OWVAR 21
103941: PUSH
103942: LD_INT 0
103944: ST_TO_ADDR
// hc_class := class_fish ;
103945: LD_ADDR_OWVAR 28
103949: PUSH
103950: LD_INT 20
103952: ST_TO_ADDR
// hc_gallery :=  ;
103953: LD_ADDR_OWVAR 33
103957: PUSH
103958: LD_STRING 
103960: ST_TO_ADDR
// end ;
103961: LD_VAR 0 1
103965: RET
// export function PrepareBird ( ) ; begin
103966: LD_INT 0
103968: PPUSH
// uc_side := 0 ;
103969: LD_ADDR_OWVAR 20
103973: PUSH
103974: LD_INT 0
103976: ST_TO_ADDR
// uc_nation := 0 ;
103977: LD_ADDR_OWVAR 21
103981: PUSH
103982: LD_INT 0
103984: ST_TO_ADDR
// hc_class := class_phororhacos ;
103985: LD_ADDR_OWVAR 28
103989: PUSH
103990: LD_INT 18
103992: ST_TO_ADDR
// hc_gallery :=  ;
103993: LD_ADDR_OWVAR 33
103997: PUSH
103998: LD_STRING 
104000: ST_TO_ADDR
// end ;
104001: LD_VAR 0 1
104005: RET
// export function PrepareHorse ( ) ; begin
104006: LD_INT 0
104008: PPUSH
// uc_side := 0 ;
104009: LD_ADDR_OWVAR 20
104013: PUSH
104014: LD_INT 0
104016: ST_TO_ADDR
// uc_nation := 0 ;
104017: LD_ADDR_OWVAR 21
104021: PUSH
104022: LD_INT 0
104024: ST_TO_ADDR
// hc_class := class_horse ;
104025: LD_ADDR_OWVAR 28
104029: PUSH
104030: LD_INT 21
104032: ST_TO_ADDR
// hc_gallery :=  ;
104033: LD_ADDR_OWVAR 33
104037: PUSH
104038: LD_STRING 
104040: ST_TO_ADDR
// end ;
104041: LD_VAR 0 1
104045: RET
// export function PrepareMastodont ( ) ; begin
104046: LD_INT 0
104048: PPUSH
// uc_side := 0 ;
104049: LD_ADDR_OWVAR 20
104053: PUSH
104054: LD_INT 0
104056: ST_TO_ADDR
// uc_nation := 0 ;
104057: LD_ADDR_OWVAR 21
104061: PUSH
104062: LD_INT 0
104064: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104065: LD_ADDR_OWVAR 37
104069: PUSH
104070: LD_INT 31
104072: ST_TO_ADDR
// vc_control := control_rider ;
104073: LD_ADDR_OWVAR 38
104077: PUSH
104078: LD_INT 4
104080: ST_TO_ADDR
// end ;
104081: LD_VAR 0 1
104085: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104086: LD_INT 0
104088: PPUSH
104089: PPUSH
104090: PPUSH
// uc_side = 0 ;
104091: LD_ADDR_OWVAR 20
104095: PUSH
104096: LD_INT 0
104098: ST_TO_ADDR
// uc_nation = 0 ;
104099: LD_ADDR_OWVAR 21
104103: PUSH
104104: LD_INT 0
104106: ST_TO_ADDR
// InitHc_All ( ) ;
104107: CALL_OW 584
// InitVc ;
104111: CALL_OW 20
// if mastodonts then
104115: LD_VAR 0 6
104119: IFFALSE 104186
// for i = 1 to mastodonts do
104121: LD_ADDR_VAR 0 11
104125: PUSH
104126: DOUBLE
104127: LD_INT 1
104129: DEC
104130: ST_TO_ADDR
104131: LD_VAR 0 6
104135: PUSH
104136: FOR_TO
104137: IFFALSE 104184
// begin vc_chassis := 31 ;
104139: LD_ADDR_OWVAR 37
104143: PUSH
104144: LD_INT 31
104146: ST_TO_ADDR
// vc_control := control_rider ;
104147: LD_ADDR_OWVAR 38
104151: PUSH
104152: LD_INT 4
104154: ST_TO_ADDR
// animal := CreateVehicle ;
104155: LD_ADDR_VAR 0 12
104159: PUSH
104160: CALL_OW 45
104164: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104165: LD_VAR 0 12
104169: PPUSH
104170: LD_VAR 0 8
104174: PPUSH
104175: LD_INT 0
104177: PPUSH
104178: CALL 106314 0 3
// end ;
104182: GO 104136
104184: POP
104185: POP
// if horses then
104186: LD_VAR 0 5
104190: IFFALSE 104257
// for i = 1 to horses do
104192: LD_ADDR_VAR 0 11
104196: PUSH
104197: DOUBLE
104198: LD_INT 1
104200: DEC
104201: ST_TO_ADDR
104202: LD_VAR 0 5
104206: PUSH
104207: FOR_TO
104208: IFFALSE 104255
// begin hc_class := 21 ;
104210: LD_ADDR_OWVAR 28
104214: PUSH
104215: LD_INT 21
104217: ST_TO_ADDR
// hc_gallery :=  ;
104218: LD_ADDR_OWVAR 33
104222: PUSH
104223: LD_STRING 
104225: ST_TO_ADDR
// animal := CreateHuman ;
104226: LD_ADDR_VAR 0 12
104230: PUSH
104231: CALL_OW 44
104235: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104236: LD_VAR 0 12
104240: PPUSH
104241: LD_VAR 0 8
104245: PPUSH
104246: LD_INT 0
104248: PPUSH
104249: CALL 106314 0 3
// end ;
104253: GO 104207
104255: POP
104256: POP
// if birds then
104257: LD_VAR 0 1
104261: IFFALSE 104328
// for i = 1 to birds do
104263: LD_ADDR_VAR 0 11
104267: PUSH
104268: DOUBLE
104269: LD_INT 1
104271: DEC
104272: ST_TO_ADDR
104273: LD_VAR 0 1
104277: PUSH
104278: FOR_TO
104279: IFFALSE 104326
// begin hc_class := 18 ;
104281: LD_ADDR_OWVAR 28
104285: PUSH
104286: LD_INT 18
104288: ST_TO_ADDR
// hc_gallery =  ;
104289: LD_ADDR_OWVAR 33
104293: PUSH
104294: LD_STRING 
104296: ST_TO_ADDR
// animal := CreateHuman ;
104297: LD_ADDR_VAR 0 12
104301: PUSH
104302: CALL_OW 44
104306: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104307: LD_VAR 0 12
104311: PPUSH
104312: LD_VAR 0 8
104316: PPUSH
104317: LD_INT 0
104319: PPUSH
104320: CALL 106314 0 3
// end ;
104324: GO 104278
104326: POP
104327: POP
// if tigers then
104328: LD_VAR 0 2
104332: IFFALSE 104416
// for i = 1 to tigers do
104334: LD_ADDR_VAR 0 11
104338: PUSH
104339: DOUBLE
104340: LD_INT 1
104342: DEC
104343: ST_TO_ADDR
104344: LD_VAR 0 2
104348: PUSH
104349: FOR_TO
104350: IFFALSE 104414
// begin hc_class = class_tiger ;
104352: LD_ADDR_OWVAR 28
104356: PUSH
104357: LD_INT 14
104359: ST_TO_ADDR
// hc_gallery =  ;
104360: LD_ADDR_OWVAR 33
104364: PUSH
104365: LD_STRING 
104367: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104368: LD_ADDR_OWVAR 35
104372: PUSH
104373: LD_INT 7
104375: NEG
104376: PPUSH
104377: LD_INT 7
104379: PPUSH
104380: CALL_OW 12
104384: ST_TO_ADDR
// animal := CreateHuman ;
104385: LD_ADDR_VAR 0 12
104389: PUSH
104390: CALL_OW 44
104394: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104395: LD_VAR 0 12
104399: PPUSH
104400: LD_VAR 0 8
104404: PPUSH
104405: LD_INT 0
104407: PPUSH
104408: CALL 106314 0 3
// end ;
104412: GO 104349
104414: POP
104415: POP
// if apemans then
104416: LD_VAR 0 3
104420: IFFALSE 104543
// for i = 1 to apemans do
104422: LD_ADDR_VAR 0 11
104426: PUSH
104427: DOUBLE
104428: LD_INT 1
104430: DEC
104431: ST_TO_ADDR
104432: LD_VAR 0 3
104436: PUSH
104437: FOR_TO
104438: IFFALSE 104541
// begin hc_class = class_apeman ;
104440: LD_ADDR_OWVAR 28
104444: PUSH
104445: LD_INT 12
104447: ST_TO_ADDR
// hc_gallery =  ;
104448: LD_ADDR_OWVAR 33
104452: PUSH
104453: LD_STRING 
104455: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104456: LD_ADDR_OWVAR 35
104460: PUSH
104461: LD_INT 2
104463: NEG
104464: PPUSH
104465: LD_INT 2
104467: PPUSH
104468: CALL_OW 12
104472: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104473: LD_ADDR_OWVAR 31
104477: PUSH
104478: LD_INT 1
104480: PPUSH
104481: LD_INT 3
104483: PPUSH
104484: CALL_OW 12
104488: PUSH
104489: LD_INT 1
104491: PPUSH
104492: LD_INT 3
104494: PPUSH
104495: CALL_OW 12
104499: PUSH
104500: LD_INT 0
104502: PUSH
104503: LD_INT 0
104505: PUSH
104506: EMPTY
104507: LIST
104508: LIST
104509: LIST
104510: LIST
104511: ST_TO_ADDR
// animal := CreateHuman ;
104512: LD_ADDR_VAR 0 12
104516: PUSH
104517: CALL_OW 44
104521: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104522: LD_VAR 0 12
104526: PPUSH
104527: LD_VAR 0 8
104531: PPUSH
104532: LD_INT 0
104534: PPUSH
104535: CALL 106314 0 3
// end ;
104539: GO 104437
104541: POP
104542: POP
// if enchidnas then
104543: LD_VAR 0 4
104547: IFFALSE 104614
// for i = 1 to enchidnas do
104549: LD_ADDR_VAR 0 11
104553: PUSH
104554: DOUBLE
104555: LD_INT 1
104557: DEC
104558: ST_TO_ADDR
104559: LD_VAR 0 4
104563: PUSH
104564: FOR_TO
104565: IFFALSE 104612
// begin hc_class = 13 ;
104567: LD_ADDR_OWVAR 28
104571: PUSH
104572: LD_INT 13
104574: ST_TO_ADDR
// hc_gallery =  ;
104575: LD_ADDR_OWVAR 33
104579: PUSH
104580: LD_STRING 
104582: ST_TO_ADDR
// animal := CreateHuman ;
104583: LD_ADDR_VAR 0 12
104587: PUSH
104588: CALL_OW 44
104592: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104593: LD_VAR 0 12
104597: PPUSH
104598: LD_VAR 0 8
104602: PPUSH
104603: LD_INT 0
104605: PPUSH
104606: CALL 106314 0 3
// end ;
104610: GO 104564
104612: POP
104613: POP
// if fishes then
104614: LD_VAR 0 7
104618: IFFALSE 104685
// for i = 1 to fishes do
104620: LD_ADDR_VAR 0 11
104624: PUSH
104625: DOUBLE
104626: LD_INT 1
104628: DEC
104629: ST_TO_ADDR
104630: LD_VAR 0 7
104634: PUSH
104635: FOR_TO
104636: IFFALSE 104683
// begin hc_class = 20 ;
104638: LD_ADDR_OWVAR 28
104642: PUSH
104643: LD_INT 20
104645: ST_TO_ADDR
// hc_gallery =  ;
104646: LD_ADDR_OWVAR 33
104650: PUSH
104651: LD_STRING 
104653: ST_TO_ADDR
// animal := CreateHuman ;
104654: LD_ADDR_VAR 0 12
104658: PUSH
104659: CALL_OW 44
104663: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104664: LD_VAR 0 12
104668: PPUSH
104669: LD_VAR 0 9
104673: PPUSH
104674: LD_INT 0
104676: PPUSH
104677: CALL 106314 0 3
// end ;
104681: GO 104635
104683: POP
104684: POP
// end ;
104685: LD_VAR 0 10
104689: RET
// export function WantHeal ( sci , unit ) ; begin
104690: LD_INT 0
104692: PPUSH
// if GetTaskList ( sci ) > 0 then
104693: LD_VAR 0 1
104697: PPUSH
104698: CALL_OW 437
104702: PUSH
104703: LD_INT 0
104705: GREATER
104706: IFFALSE 104776
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104708: LD_VAR 0 1
104712: PPUSH
104713: CALL_OW 437
104717: PUSH
104718: LD_INT 1
104720: ARRAY
104721: PUSH
104722: LD_INT 1
104724: ARRAY
104725: PUSH
104726: LD_STRING l
104728: EQUAL
104729: PUSH
104730: LD_VAR 0 1
104734: PPUSH
104735: CALL_OW 437
104739: PUSH
104740: LD_INT 1
104742: ARRAY
104743: PUSH
104744: LD_INT 4
104746: ARRAY
104747: PUSH
104748: LD_VAR 0 2
104752: EQUAL
104753: AND
104754: IFFALSE 104766
// result := true else
104756: LD_ADDR_VAR 0 3
104760: PUSH
104761: LD_INT 1
104763: ST_TO_ADDR
104764: GO 104774
// result := false ;
104766: LD_ADDR_VAR 0 3
104770: PUSH
104771: LD_INT 0
104773: ST_TO_ADDR
// end else
104774: GO 104784
// result := false ;
104776: LD_ADDR_VAR 0 3
104780: PUSH
104781: LD_INT 0
104783: ST_TO_ADDR
// end ;
104784: LD_VAR 0 3
104788: RET
// export function HealTarget ( sci ) ; begin
104789: LD_INT 0
104791: PPUSH
// if not sci then
104792: LD_VAR 0 1
104796: NOT
104797: IFFALSE 104801
// exit ;
104799: GO 104866
// result := 0 ;
104801: LD_ADDR_VAR 0 2
104805: PUSH
104806: LD_INT 0
104808: ST_TO_ADDR
// if GetTaskList ( sci ) then
104809: LD_VAR 0 1
104813: PPUSH
104814: CALL_OW 437
104818: IFFALSE 104866
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104820: LD_VAR 0 1
104824: PPUSH
104825: CALL_OW 437
104829: PUSH
104830: LD_INT 1
104832: ARRAY
104833: PUSH
104834: LD_INT 1
104836: ARRAY
104837: PUSH
104838: LD_STRING l
104840: EQUAL
104841: IFFALSE 104866
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104843: LD_ADDR_VAR 0 2
104847: PUSH
104848: LD_VAR 0 1
104852: PPUSH
104853: CALL_OW 437
104857: PUSH
104858: LD_INT 1
104860: ARRAY
104861: PUSH
104862: LD_INT 4
104864: ARRAY
104865: ST_TO_ADDR
// end ;
104866: LD_VAR 0 2
104870: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104871: LD_INT 0
104873: PPUSH
104874: PPUSH
104875: PPUSH
104876: PPUSH
// if not base_units then
104877: LD_VAR 0 1
104881: NOT
104882: IFFALSE 104886
// exit ;
104884: GO 104973
// result := false ;
104886: LD_ADDR_VAR 0 2
104890: PUSH
104891: LD_INT 0
104893: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104894: LD_ADDR_VAR 0 5
104898: PUSH
104899: LD_VAR 0 1
104903: PPUSH
104904: LD_INT 21
104906: PUSH
104907: LD_INT 3
104909: PUSH
104910: EMPTY
104911: LIST
104912: LIST
104913: PPUSH
104914: CALL_OW 72
104918: ST_TO_ADDR
// if not tmp then
104919: LD_VAR 0 5
104923: NOT
104924: IFFALSE 104928
// exit ;
104926: GO 104973
// for i in tmp do
104928: LD_ADDR_VAR 0 3
104932: PUSH
104933: LD_VAR 0 5
104937: PUSH
104938: FOR_IN
104939: IFFALSE 104971
// begin result := EnemyInRange ( i , 22 ) ;
104941: LD_ADDR_VAR 0 2
104945: PUSH
104946: LD_VAR 0 3
104950: PPUSH
104951: LD_INT 22
104953: PPUSH
104954: CALL 102571 0 2
104958: ST_TO_ADDR
// if result then
104959: LD_VAR 0 2
104963: IFFALSE 104969
// exit ;
104965: POP
104966: POP
104967: GO 104973
// end ;
104969: GO 104938
104971: POP
104972: POP
// end ;
104973: LD_VAR 0 2
104977: RET
// export function FilterByTag ( units , tag ) ; begin
104978: LD_INT 0
104980: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104981: LD_ADDR_VAR 0 3
104985: PUSH
104986: LD_VAR 0 1
104990: PPUSH
104991: LD_INT 120
104993: PUSH
104994: LD_VAR 0 2
104998: PUSH
104999: EMPTY
105000: LIST
105001: LIST
105002: PPUSH
105003: CALL_OW 72
105007: ST_TO_ADDR
// end ;
105008: LD_VAR 0 3
105012: RET
// export function IsDriver ( un ) ; begin
105013: LD_INT 0
105015: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105016: LD_ADDR_VAR 0 2
105020: PUSH
105021: LD_VAR 0 1
105025: PUSH
105026: LD_INT 55
105028: PUSH
105029: EMPTY
105030: LIST
105031: PPUSH
105032: CALL_OW 69
105036: IN
105037: ST_TO_ADDR
// end ;
105038: LD_VAR 0 2
105042: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105043: LD_INT 0
105045: PPUSH
105046: PPUSH
// list := [ ] ;
105047: LD_ADDR_VAR 0 5
105051: PUSH
105052: EMPTY
105053: ST_TO_ADDR
// case d of 0 :
105054: LD_VAR 0 3
105058: PUSH
105059: LD_INT 0
105061: DOUBLE
105062: EQUAL
105063: IFTRUE 105067
105065: GO 105200
105067: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105068: LD_ADDR_VAR 0 5
105072: PUSH
105073: LD_VAR 0 1
105077: PUSH
105078: LD_INT 4
105080: MINUS
105081: PUSH
105082: LD_VAR 0 2
105086: PUSH
105087: LD_INT 4
105089: MINUS
105090: PUSH
105091: LD_INT 2
105093: PUSH
105094: EMPTY
105095: LIST
105096: LIST
105097: LIST
105098: PUSH
105099: LD_VAR 0 1
105103: PUSH
105104: LD_INT 3
105106: MINUS
105107: PUSH
105108: LD_VAR 0 2
105112: PUSH
105113: LD_INT 1
105115: PUSH
105116: EMPTY
105117: LIST
105118: LIST
105119: LIST
105120: PUSH
105121: LD_VAR 0 1
105125: PUSH
105126: LD_INT 4
105128: PLUS
105129: PUSH
105130: LD_VAR 0 2
105134: PUSH
105135: LD_INT 4
105137: PUSH
105138: EMPTY
105139: LIST
105140: LIST
105141: LIST
105142: PUSH
105143: LD_VAR 0 1
105147: PUSH
105148: LD_INT 3
105150: PLUS
105151: PUSH
105152: LD_VAR 0 2
105156: PUSH
105157: LD_INT 3
105159: PLUS
105160: PUSH
105161: LD_INT 5
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: LIST
105168: PUSH
105169: LD_VAR 0 1
105173: PUSH
105174: LD_VAR 0 2
105178: PUSH
105179: LD_INT 4
105181: PLUS
105182: PUSH
105183: LD_INT 0
105185: PUSH
105186: EMPTY
105187: LIST
105188: LIST
105189: LIST
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: LIST
105196: LIST
105197: ST_TO_ADDR
// end ; 1 :
105198: GO 105898
105200: LD_INT 1
105202: DOUBLE
105203: EQUAL
105204: IFTRUE 105208
105206: GO 105341
105208: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105209: LD_ADDR_VAR 0 5
105213: PUSH
105214: LD_VAR 0 1
105218: PUSH
105219: LD_VAR 0 2
105223: PUSH
105224: LD_INT 4
105226: MINUS
105227: PUSH
105228: LD_INT 3
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: LIST
105235: PUSH
105236: LD_VAR 0 1
105240: PUSH
105241: LD_INT 3
105243: MINUS
105244: PUSH
105245: LD_VAR 0 2
105249: PUSH
105250: LD_INT 3
105252: MINUS
105253: PUSH
105254: LD_INT 2
105256: PUSH
105257: EMPTY
105258: LIST
105259: LIST
105260: LIST
105261: PUSH
105262: LD_VAR 0 1
105266: PUSH
105267: LD_INT 4
105269: MINUS
105270: PUSH
105271: LD_VAR 0 2
105275: PUSH
105276: LD_INT 1
105278: PUSH
105279: EMPTY
105280: LIST
105281: LIST
105282: LIST
105283: PUSH
105284: LD_VAR 0 1
105288: PUSH
105289: LD_VAR 0 2
105293: PUSH
105294: LD_INT 3
105296: PLUS
105297: PUSH
105298: LD_INT 0
105300: PUSH
105301: EMPTY
105302: LIST
105303: LIST
105304: LIST
105305: PUSH
105306: LD_VAR 0 1
105310: PUSH
105311: LD_INT 4
105313: PLUS
105314: PUSH
105315: LD_VAR 0 2
105319: PUSH
105320: LD_INT 4
105322: PLUS
105323: PUSH
105324: LD_INT 5
105326: PUSH
105327: EMPTY
105328: LIST
105329: LIST
105330: LIST
105331: PUSH
105332: EMPTY
105333: LIST
105334: LIST
105335: LIST
105336: LIST
105337: LIST
105338: ST_TO_ADDR
// end ; 2 :
105339: GO 105898
105341: LD_INT 2
105343: DOUBLE
105344: EQUAL
105345: IFTRUE 105349
105347: GO 105478
105349: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105350: LD_ADDR_VAR 0 5
105354: PUSH
105355: LD_VAR 0 1
105359: PUSH
105360: LD_VAR 0 2
105364: PUSH
105365: LD_INT 3
105367: MINUS
105368: PUSH
105369: LD_INT 3
105371: PUSH
105372: EMPTY
105373: LIST
105374: LIST
105375: LIST
105376: PUSH
105377: LD_VAR 0 1
105381: PUSH
105382: LD_INT 4
105384: PLUS
105385: PUSH
105386: LD_VAR 0 2
105390: PUSH
105391: LD_INT 4
105393: PUSH
105394: EMPTY
105395: LIST
105396: LIST
105397: LIST
105398: PUSH
105399: LD_VAR 0 1
105403: PUSH
105404: LD_VAR 0 2
105408: PUSH
105409: LD_INT 4
105411: PLUS
105412: PUSH
105413: LD_INT 0
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: LIST
105420: PUSH
105421: LD_VAR 0 1
105425: PUSH
105426: LD_INT 3
105428: MINUS
105429: PUSH
105430: LD_VAR 0 2
105434: PUSH
105435: LD_INT 1
105437: PUSH
105438: EMPTY
105439: LIST
105440: LIST
105441: LIST
105442: PUSH
105443: LD_VAR 0 1
105447: PUSH
105448: LD_INT 4
105450: MINUS
105451: PUSH
105452: LD_VAR 0 2
105456: PUSH
105457: LD_INT 4
105459: MINUS
105460: PUSH
105461: LD_INT 2
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: LIST
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: LIST
105473: LIST
105474: LIST
105475: ST_TO_ADDR
// end ; 3 :
105476: GO 105898
105478: LD_INT 3
105480: DOUBLE
105481: EQUAL
105482: IFTRUE 105486
105484: GO 105619
105486: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105487: LD_ADDR_VAR 0 5
105491: PUSH
105492: LD_VAR 0 1
105496: PUSH
105497: LD_INT 3
105499: PLUS
105500: PUSH
105501: LD_VAR 0 2
105505: PUSH
105506: LD_INT 4
105508: PUSH
105509: EMPTY
105510: LIST
105511: LIST
105512: LIST
105513: PUSH
105514: LD_VAR 0 1
105518: PUSH
105519: LD_INT 4
105521: PLUS
105522: PUSH
105523: LD_VAR 0 2
105527: PUSH
105528: LD_INT 4
105530: PLUS
105531: PUSH
105532: LD_INT 5
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: LIST
105539: PUSH
105540: LD_VAR 0 1
105544: PUSH
105545: LD_INT 4
105547: MINUS
105548: PUSH
105549: LD_VAR 0 2
105553: PUSH
105554: LD_INT 1
105556: PUSH
105557: EMPTY
105558: LIST
105559: LIST
105560: LIST
105561: PUSH
105562: LD_VAR 0 1
105566: PUSH
105567: LD_VAR 0 2
105571: PUSH
105572: LD_INT 4
105574: MINUS
105575: PUSH
105576: LD_INT 3
105578: PUSH
105579: EMPTY
105580: LIST
105581: LIST
105582: LIST
105583: PUSH
105584: LD_VAR 0 1
105588: PUSH
105589: LD_INT 3
105591: MINUS
105592: PUSH
105593: LD_VAR 0 2
105597: PUSH
105598: LD_INT 3
105600: MINUS
105601: PUSH
105602: LD_INT 2
105604: PUSH
105605: EMPTY
105606: LIST
105607: LIST
105608: LIST
105609: PUSH
105610: EMPTY
105611: LIST
105612: LIST
105613: LIST
105614: LIST
105615: LIST
105616: ST_TO_ADDR
// end ; 4 :
105617: GO 105898
105619: LD_INT 4
105621: DOUBLE
105622: EQUAL
105623: IFTRUE 105627
105625: GO 105760
105627: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105628: LD_ADDR_VAR 0 5
105632: PUSH
105633: LD_VAR 0 1
105637: PUSH
105638: LD_VAR 0 2
105642: PUSH
105643: LD_INT 4
105645: PLUS
105646: PUSH
105647: LD_INT 0
105649: PUSH
105650: EMPTY
105651: LIST
105652: LIST
105653: LIST
105654: PUSH
105655: LD_VAR 0 1
105659: PUSH
105660: LD_INT 3
105662: PLUS
105663: PUSH
105664: LD_VAR 0 2
105668: PUSH
105669: LD_INT 3
105671: PLUS
105672: PUSH
105673: LD_INT 5
105675: PUSH
105676: EMPTY
105677: LIST
105678: LIST
105679: LIST
105680: PUSH
105681: LD_VAR 0 1
105685: PUSH
105686: LD_INT 4
105688: PLUS
105689: PUSH
105690: LD_VAR 0 2
105694: PUSH
105695: LD_INT 4
105697: PUSH
105698: EMPTY
105699: LIST
105700: LIST
105701: LIST
105702: PUSH
105703: LD_VAR 0 1
105707: PUSH
105708: LD_VAR 0 2
105712: PUSH
105713: LD_INT 3
105715: MINUS
105716: PUSH
105717: LD_INT 3
105719: PUSH
105720: EMPTY
105721: LIST
105722: LIST
105723: LIST
105724: PUSH
105725: LD_VAR 0 1
105729: PUSH
105730: LD_INT 4
105732: MINUS
105733: PUSH
105734: LD_VAR 0 2
105738: PUSH
105739: LD_INT 4
105741: MINUS
105742: PUSH
105743: LD_INT 2
105745: PUSH
105746: EMPTY
105747: LIST
105748: LIST
105749: LIST
105750: PUSH
105751: EMPTY
105752: LIST
105753: LIST
105754: LIST
105755: LIST
105756: LIST
105757: ST_TO_ADDR
// end ; 5 :
105758: GO 105898
105760: LD_INT 5
105762: DOUBLE
105763: EQUAL
105764: IFTRUE 105768
105766: GO 105897
105768: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105769: LD_ADDR_VAR 0 5
105773: PUSH
105774: LD_VAR 0 1
105778: PUSH
105779: LD_INT 4
105781: MINUS
105782: PUSH
105783: LD_VAR 0 2
105787: PUSH
105788: LD_INT 1
105790: PUSH
105791: EMPTY
105792: LIST
105793: LIST
105794: LIST
105795: PUSH
105796: LD_VAR 0 1
105800: PUSH
105801: LD_VAR 0 2
105805: PUSH
105806: LD_INT 4
105808: MINUS
105809: PUSH
105810: LD_INT 3
105812: PUSH
105813: EMPTY
105814: LIST
105815: LIST
105816: LIST
105817: PUSH
105818: LD_VAR 0 1
105822: PUSH
105823: LD_INT 4
105825: PLUS
105826: PUSH
105827: LD_VAR 0 2
105831: PUSH
105832: LD_INT 4
105834: PLUS
105835: PUSH
105836: LD_INT 5
105838: PUSH
105839: EMPTY
105840: LIST
105841: LIST
105842: LIST
105843: PUSH
105844: LD_VAR 0 1
105848: PUSH
105849: LD_INT 3
105851: PLUS
105852: PUSH
105853: LD_VAR 0 2
105857: PUSH
105858: LD_INT 4
105860: PUSH
105861: EMPTY
105862: LIST
105863: LIST
105864: LIST
105865: PUSH
105866: LD_VAR 0 1
105870: PUSH
105871: LD_VAR 0 2
105875: PUSH
105876: LD_INT 3
105878: PLUS
105879: PUSH
105880: LD_INT 0
105882: PUSH
105883: EMPTY
105884: LIST
105885: LIST
105886: LIST
105887: PUSH
105888: EMPTY
105889: LIST
105890: LIST
105891: LIST
105892: LIST
105893: LIST
105894: ST_TO_ADDR
// end ; end ;
105895: GO 105898
105897: POP
// result := list ;
105898: LD_ADDR_VAR 0 4
105902: PUSH
105903: LD_VAR 0 5
105907: ST_TO_ADDR
// end ;
105908: LD_VAR 0 4
105912: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105913: LD_INT 0
105915: PPUSH
105916: PPUSH
105917: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105918: LD_VAR 0 1
105922: NOT
105923: PUSH
105924: LD_VAR 0 2
105928: PUSH
105929: LD_INT 1
105931: PUSH
105932: LD_INT 2
105934: PUSH
105935: LD_INT 3
105937: PUSH
105938: LD_INT 4
105940: PUSH
105941: EMPTY
105942: LIST
105943: LIST
105944: LIST
105945: LIST
105946: IN
105947: NOT
105948: OR
105949: IFFALSE 105953
// exit ;
105951: GO 106036
// tmp := [ ] ;
105953: LD_ADDR_VAR 0 5
105957: PUSH
105958: EMPTY
105959: ST_TO_ADDR
// for i in units do
105960: LD_ADDR_VAR 0 4
105964: PUSH
105965: LD_VAR 0 1
105969: PUSH
105970: FOR_IN
105971: IFFALSE 106005
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105973: LD_ADDR_VAR 0 5
105977: PUSH
105978: LD_VAR 0 5
105982: PPUSH
105983: LD_VAR 0 4
105987: PPUSH
105988: LD_VAR 0 2
105992: PPUSH
105993: CALL_OW 259
105997: PPUSH
105998: CALL 107409 0 2
106002: ST_TO_ADDR
106003: GO 105970
106005: POP
106006: POP
// if not tmp then
106007: LD_VAR 0 5
106011: NOT
106012: IFFALSE 106016
// exit ;
106014: GO 106036
// result := SortListByListDesc ( units , tmp ) ;
106016: LD_ADDR_VAR 0 3
106020: PUSH
106021: LD_VAR 0 1
106025: PPUSH
106026: LD_VAR 0 5
106030: PPUSH
106031: CALL_OW 77
106035: ST_TO_ADDR
// end ;
106036: LD_VAR 0 3
106040: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106041: LD_INT 0
106043: PPUSH
106044: PPUSH
106045: PPUSH
// result := false ;
106046: LD_ADDR_VAR 0 3
106050: PUSH
106051: LD_INT 0
106053: ST_TO_ADDR
// if not building then
106054: LD_VAR 0 2
106058: NOT
106059: IFFALSE 106063
// exit ;
106061: GO 106201
// x := GetX ( building ) ;
106063: LD_ADDR_VAR 0 4
106067: PUSH
106068: LD_VAR 0 2
106072: PPUSH
106073: CALL_OW 250
106077: ST_TO_ADDR
// y := GetY ( building ) ;
106078: LD_ADDR_VAR 0 5
106082: PUSH
106083: LD_VAR 0 2
106087: PPUSH
106088: CALL_OW 251
106092: ST_TO_ADDR
// if not x or not y then
106093: LD_VAR 0 4
106097: NOT
106098: PUSH
106099: LD_VAR 0 5
106103: NOT
106104: OR
106105: IFFALSE 106109
// exit ;
106107: GO 106201
// if GetTaskList ( unit ) then
106109: LD_VAR 0 1
106113: PPUSH
106114: CALL_OW 437
106118: IFFALSE 106201
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106120: LD_STRING e
106122: PUSH
106123: LD_VAR 0 1
106127: PPUSH
106128: CALL_OW 437
106132: PUSH
106133: LD_INT 1
106135: ARRAY
106136: PUSH
106137: LD_INT 1
106139: ARRAY
106140: EQUAL
106141: PUSH
106142: LD_VAR 0 4
106146: PUSH
106147: LD_VAR 0 1
106151: PPUSH
106152: CALL_OW 437
106156: PUSH
106157: LD_INT 1
106159: ARRAY
106160: PUSH
106161: LD_INT 2
106163: ARRAY
106164: EQUAL
106165: AND
106166: PUSH
106167: LD_VAR 0 5
106171: PUSH
106172: LD_VAR 0 1
106176: PPUSH
106177: CALL_OW 437
106181: PUSH
106182: LD_INT 1
106184: ARRAY
106185: PUSH
106186: LD_INT 3
106188: ARRAY
106189: EQUAL
106190: AND
106191: IFFALSE 106201
// result := true end ;
106193: LD_ADDR_VAR 0 3
106197: PUSH
106198: LD_INT 1
106200: ST_TO_ADDR
// end ;
106201: LD_VAR 0 3
106205: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106206: LD_INT 0
106208: PPUSH
// result := false ;
106209: LD_ADDR_VAR 0 4
106213: PUSH
106214: LD_INT 0
106216: ST_TO_ADDR
// if GetTaskList ( unit ) then
106217: LD_VAR 0 1
106221: PPUSH
106222: CALL_OW 437
106226: IFFALSE 106309
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106228: LD_STRING M
106230: PUSH
106231: LD_VAR 0 1
106235: PPUSH
106236: CALL_OW 437
106240: PUSH
106241: LD_INT 1
106243: ARRAY
106244: PUSH
106245: LD_INT 1
106247: ARRAY
106248: EQUAL
106249: PUSH
106250: LD_VAR 0 2
106254: PUSH
106255: LD_VAR 0 1
106259: PPUSH
106260: CALL_OW 437
106264: PUSH
106265: LD_INT 1
106267: ARRAY
106268: PUSH
106269: LD_INT 2
106271: ARRAY
106272: EQUAL
106273: AND
106274: PUSH
106275: LD_VAR 0 3
106279: PUSH
106280: LD_VAR 0 1
106284: PPUSH
106285: CALL_OW 437
106289: PUSH
106290: LD_INT 1
106292: ARRAY
106293: PUSH
106294: LD_INT 3
106296: ARRAY
106297: EQUAL
106298: AND
106299: IFFALSE 106309
// result := true ;
106301: LD_ADDR_VAR 0 4
106305: PUSH
106306: LD_INT 1
106308: ST_TO_ADDR
// end ; end ;
106309: LD_VAR 0 4
106313: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106314: LD_INT 0
106316: PPUSH
106317: PPUSH
106318: PPUSH
106319: PPUSH
// if not unit or not area then
106320: LD_VAR 0 1
106324: NOT
106325: PUSH
106326: LD_VAR 0 2
106330: NOT
106331: OR
106332: IFFALSE 106336
// exit ;
106334: GO 106512
// tmp := AreaToList ( area , i ) ;
106336: LD_ADDR_VAR 0 6
106340: PUSH
106341: LD_VAR 0 2
106345: PPUSH
106346: LD_VAR 0 5
106350: PPUSH
106351: CALL_OW 517
106355: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106356: LD_ADDR_VAR 0 5
106360: PUSH
106361: DOUBLE
106362: LD_INT 1
106364: DEC
106365: ST_TO_ADDR
106366: LD_VAR 0 6
106370: PUSH
106371: LD_INT 1
106373: ARRAY
106374: PUSH
106375: FOR_TO
106376: IFFALSE 106510
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106378: LD_ADDR_VAR 0 7
106382: PUSH
106383: LD_VAR 0 6
106387: PUSH
106388: LD_INT 1
106390: ARRAY
106391: PUSH
106392: LD_VAR 0 5
106396: ARRAY
106397: PUSH
106398: LD_VAR 0 6
106402: PUSH
106403: LD_INT 2
106405: ARRAY
106406: PUSH
106407: LD_VAR 0 5
106411: ARRAY
106412: PUSH
106413: EMPTY
106414: LIST
106415: LIST
106416: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106417: LD_INT 92
106419: PUSH
106420: LD_VAR 0 7
106424: PUSH
106425: LD_INT 1
106427: ARRAY
106428: PUSH
106429: LD_VAR 0 7
106433: PUSH
106434: LD_INT 2
106436: ARRAY
106437: PUSH
106438: LD_INT 2
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: LIST
106445: LIST
106446: PPUSH
106447: CALL_OW 69
106451: PUSH
106452: LD_INT 0
106454: EQUAL
106455: IFFALSE 106508
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106457: LD_VAR 0 1
106461: PPUSH
106462: LD_VAR 0 7
106466: PUSH
106467: LD_INT 1
106469: ARRAY
106470: PPUSH
106471: LD_VAR 0 7
106475: PUSH
106476: LD_INT 2
106478: ARRAY
106479: PPUSH
106480: LD_VAR 0 3
106484: PPUSH
106485: CALL_OW 48
// result := IsPlaced ( unit ) ;
106489: LD_ADDR_VAR 0 4
106493: PUSH
106494: LD_VAR 0 1
106498: PPUSH
106499: CALL_OW 305
106503: ST_TO_ADDR
// exit ;
106504: POP
106505: POP
106506: GO 106512
// end ; end ;
106508: GO 106375
106510: POP
106511: POP
// end ;
106512: LD_VAR 0 4
106516: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106517: LD_INT 0
106519: PPUSH
106520: PPUSH
106521: PPUSH
// if not side or side > 8 then
106522: LD_VAR 0 1
106526: NOT
106527: PUSH
106528: LD_VAR 0 1
106532: PUSH
106533: LD_INT 8
106535: GREATER
106536: OR
106537: IFFALSE 106541
// exit ;
106539: GO 106728
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106541: LD_ADDR_VAR 0 4
106545: PUSH
106546: LD_INT 22
106548: PUSH
106549: LD_VAR 0 1
106553: PUSH
106554: EMPTY
106555: LIST
106556: LIST
106557: PUSH
106558: LD_INT 21
106560: PUSH
106561: LD_INT 3
106563: PUSH
106564: EMPTY
106565: LIST
106566: LIST
106567: PUSH
106568: EMPTY
106569: LIST
106570: LIST
106571: PPUSH
106572: CALL_OW 69
106576: ST_TO_ADDR
// if not tmp then
106577: LD_VAR 0 4
106581: NOT
106582: IFFALSE 106586
// exit ;
106584: GO 106728
// enable_addtolog := true ;
106586: LD_ADDR_OWVAR 81
106590: PUSH
106591: LD_INT 1
106593: ST_TO_ADDR
// AddToLog ( [ ) ;
106594: LD_STRING [
106596: PPUSH
106597: CALL_OW 561
// for i in tmp do
106601: LD_ADDR_VAR 0 3
106605: PUSH
106606: LD_VAR 0 4
106610: PUSH
106611: FOR_IN
106612: IFFALSE 106719
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106614: LD_STRING [
106616: PUSH
106617: LD_VAR 0 3
106621: PPUSH
106622: CALL_OW 266
106626: STR
106627: PUSH
106628: LD_STRING , 
106630: STR
106631: PUSH
106632: LD_VAR 0 3
106636: PPUSH
106637: CALL_OW 250
106641: STR
106642: PUSH
106643: LD_STRING , 
106645: STR
106646: PUSH
106647: LD_VAR 0 3
106651: PPUSH
106652: CALL_OW 251
106656: STR
106657: PUSH
106658: LD_STRING , 
106660: STR
106661: PUSH
106662: LD_VAR 0 3
106666: PPUSH
106667: CALL_OW 254
106671: STR
106672: PUSH
106673: LD_STRING , 
106675: STR
106676: PUSH
106677: LD_VAR 0 3
106681: PPUSH
106682: LD_INT 1
106684: PPUSH
106685: CALL_OW 268
106689: STR
106690: PUSH
106691: LD_STRING , 
106693: STR
106694: PUSH
106695: LD_VAR 0 3
106699: PPUSH
106700: LD_INT 2
106702: PPUSH
106703: CALL_OW 268
106707: STR
106708: PUSH
106709: LD_STRING ],
106711: STR
106712: PPUSH
106713: CALL_OW 561
// end ;
106717: GO 106611
106719: POP
106720: POP
// AddToLog ( ]; ) ;
106721: LD_STRING ];
106723: PPUSH
106724: CALL_OW 561
// end ;
106728: LD_VAR 0 2
106732: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106733: LD_INT 0
106735: PPUSH
106736: PPUSH
106737: PPUSH
106738: PPUSH
106739: PPUSH
// if not area or not rate or not max then
106740: LD_VAR 0 1
106744: NOT
106745: PUSH
106746: LD_VAR 0 2
106750: NOT
106751: OR
106752: PUSH
106753: LD_VAR 0 4
106757: NOT
106758: OR
106759: IFFALSE 106763
// exit ;
106761: GO 106952
// while 1 do
106763: LD_INT 1
106765: IFFALSE 106952
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106767: LD_ADDR_VAR 0 9
106771: PUSH
106772: LD_VAR 0 1
106776: PPUSH
106777: LD_INT 1
106779: PPUSH
106780: CALL_OW 287
106784: PUSH
106785: LD_INT 10
106787: MUL
106788: ST_TO_ADDR
// r := rate / 10 ;
106789: LD_ADDR_VAR 0 7
106793: PUSH
106794: LD_VAR 0 2
106798: PUSH
106799: LD_INT 10
106801: DIVREAL
106802: ST_TO_ADDR
// time := 1 1$00 ;
106803: LD_ADDR_VAR 0 8
106807: PUSH
106808: LD_INT 2100
106810: ST_TO_ADDR
// if amount < min then
106811: LD_VAR 0 9
106815: PUSH
106816: LD_VAR 0 3
106820: LESS
106821: IFFALSE 106839
// r := r * 2 else
106823: LD_ADDR_VAR 0 7
106827: PUSH
106828: LD_VAR 0 7
106832: PUSH
106833: LD_INT 2
106835: MUL
106836: ST_TO_ADDR
106837: GO 106865
// if amount > max then
106839: LD_VAR 0 9
106843: PUSH
106844: LD_VAR 0 4
106848: GREATER
106849: IFFALSE 106865
// r := r / 2 ;
106851: LD_ADDR_VAR 0 7
106855: PUSH
106856: LD_VAR 0 7
106860: PUSH
106861: LD_INT 2
106863: DIVREAL
106864: ST_TO_ADDR
// time := time / r ;
106865: LD_ADDR_VAR 0 8
106869: PUSH
106870: LD_VAR 0 8
106874: PUSH
106875: LD_VAR 0 7
106879: DIVREAL
106880: ST_TO_ADDR
// if time < 0 then
106881: LD_VAR 0 8
106885: PUSH
106886: LD_INT 0
106888: LESS
106889: IFFALSE 106906
// time := time * - 1 ;
106891: LD_ADDR_VAR 0 8
106895: PUSH
106896: LD_VAR 0 8
106900: PUSH
106901: LD_INT 1
106903: NEG
106904: MUL
106905: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106906: LD_VAR 0 8
106910: PUSH
106911: LD_INT 35
106913: PPUSH
106914: LD_INT 875
106916: PPUSH
106917: CALL_OW 12
106921: PLUS
106922: PPUSH
106923: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106927: LD_INT 1
106929: PPUSH
106930: LD_INT 5
106932: PPUSH
106933: CALL_OW 12
106937: PPUSH
106938: LD_VAR 0 1
106942: PPUSH
106943: LD_INT 1
106945: PPUSH
106946: CALL_OW 55
// end ;
106950: GO 106763
// end ;
106952: LD_VAR 0 5
106956: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106957: LD_INT 0
106959: PPUSH
106960: PPUSH
106961: PPUSH
106962: PPUSH
106963: PPUSH
106964: PPUSH
106965: PPUSH
106966: PPUSH
// if not turrets or not factories then
106967: LD_VAR 0 1
106971: NOT
106972: PUSH
106973: LD_VAR 0 2
106977: NOT
106978: OR
106979: IFFALSE 106983
// exit ;
106981: GO 107290
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106983: LD_ADDR_VAR 0 10
106987: PUSH
106988: LD_INT 5
106990: PUSH
106991: LD_INT 6
106993: PUSH
106994: EMPTY
106995: LIST
106996: LIST
106997: PUSH
106998: LD_INT 2
107000: PUSH
107001: LD_INT 4
107003: PUSH
107004: EMPTY
107005: LIST
107006: LIST
107007: PUSH
107008: LD_INT 3
107010: PUSH
107011: LD_INT 5
107013: PUSH
107014: EMPTY
107015: LIST
107016: LIST
107017: PUSH
107018: EMPTY
107019: LIST
107020: LIST
107021: LIST
107022: PUSH
107023: LD_INT 24
107025: PUSH
107026: LD_INT 25
107028: PUSH
107029: EMPTY
107030: LIST
107031: LIST
107032: PUSH
107033: LD_INT 23
107035: PUSH
107036: LD_INT 27
107038: PUSH
107039: EMPTY
107040: LIST
107041: LIST
107042: PUSH
107043: EMPTY
107044: LIST
107045: LIST
107046: PUSH
107047: LD_INT 42
107049: PUSH
107050: LD_INT 43
107052: PUSH
107053: EMPTY
107054: LIST
107055: LIST
107056: PUSH
107057: LD_INT 44
107059: PUSH
107060: LD_INT 46
107062: PUSH
107063: EMPTY
107064: LIST
107065: LIST
107066: PUSH
107067: LD_INT 45
107069: PUSH
107070: LD_INT 47
107072: PUSH
107073: EMPTY
107074: LIST
107075: LIST
107076: PUSH
107077: EMPTY
107078: LIST
107079: LIST
107080: LIST
107081: PUSH
107082: EMPTY
107083: LIST
107084: LIST
107085: LIST
107086: ST_TO_ADDR
// result := [ ] ;
107087: LD_ADDR_VAR 0 3
107091: PUSH
107092: EMPTY
107093: ST_TO_ADDR
// for i in turrets do
107094: LD_ADDR_VAR 0 4
107098: PUSH
107099: LD_VAR 0 1
107103: PUSH
107104: FOR_IN
107105: IFFALSE 107288
// begin nat := GetNation ( i ) ;
107107: LD_ADDR_VAR 0 7
107111: PUSH
107112: LD_VAR 0 4
107116: PPUSH
107117: CALL_OW 248
107121: ST_TO_ADDR
// weapon := 0 ;
107122: LD_ADDR_VAR 0 8
107126: PUSH
107127: LD_INT 0
107129: ST_TO_ADDR
// if not nat then
107130: LD_VAR 0 7
107134: NOT
107135: IFFALSE 107139
// continue ;
107137: GO 107104
// for j in list [ nat ] do
107139: LD_ADDR_VAR 0 5
107143: PUSH
107144: LD_VAR 0 10
107148: PUSH
107149: LD_VAR 0 7
107153: ARRAY
107154: PUSH
107155: FOR_IN
107156: IFFALSE 107197
// if GetBWeapon ( i ) = j [ 1 ] then
107158: LD_VAR 0 4
107162: PPUSH
107163: CALL_OW 269
107167: PUSH
107168: LD_VAR 0 5
107172: PUSH
107173: LD_INT 1
107175: ARRAY
107176: EQUAL
107177: IFFALSE 107195
// begin weapon := j [ 2 ] ;
107179: LD_ADDR_VAR 0 8
107183: PUSH
107184: LD_VAR 0 5
107188: PUSH
107189: LD_INT 2
107191: ARRAY
107192: ST_TO_ADDR
// break ;
107193: GO 107197
// end ;
107195: GO 107155
107197: POP
107198: POP
// if not weapon then
107199: LD_VAR 0 8
107203: NOT
107204: IFFALSE 107208
// continue ;
107206: GO 107104
// for k in factories do
107208: LD_ADDR_VAR 0 6
107212: PUSH
107213: LD_VAR 0 2
107217: PUSH
107218: FOR_IN
107219: IFFALSE 107284
// begin weapons := AvailableWeaponList ( k ) ;
107221: LD_ADDR_VAR 0 9
107225: PUSH
107226: LD_VAR 0 6
107230: PPUSH
107231: CALL_OW 478
107235: ST_TO_ADDR
// if not weapons then
107236: LD_VAR 0 9
107240: NOT
107241: IFFALSE 107245
// continue ;
107243: GO 107218
// if weapon in weapons then
107245: LD_VAR 0 8
107249: PUSH
107250: LD_VAR 0 9
107254: IN
107255: IFFALSE 107282
// begin result := [ i , weapon ] ;
107257: LD_ADDR_VAR 0 3
107261: PUSH
107262: LD_VAR 0 4
107266: PUSH
107267: LD_VAR 0 8
107271: PUSH
107272: EMPTY
107273: LIST
107274: LIST
107275: ST_TO_ADDR
// exit ;
107276: POP
107277: POP
107278: POP
107279: POP
107280: GO 107290
// end ; end ;
107282: GO 107218
107284: POP
107285: POP
// end ;
107286: GO 107104
107288: POP
107289: POP
// end ;
107290: LD_VAR 0 3
107294: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107295: LD_INT 0
107297: PPUSH
// if not side or side > 8 then
107298: LD_VAR 0 3
107302: NOT
107303: PUSH
107304: LD_VAR 0 3
107308: PUSH
107309: LD_INT 8
107311: GREATER
107312: OR
107313: IFFALSE 107317
// exit ;
107315: GO 107376
// if not range then
107317: LD_VAR 0 4
107321: NOT
107322: IFFALSE 107333
// range := - 12 ;
107324: LD_ADDR_VAR 0 4
107328: PUSH
107329: LD_INT 12
107331: NEG
107332: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107333: LD_VAR 0 1
107337: PPUSH
107338: LD_VAR 0 2
107342: PPUSH
107343: LD_VAR 0 3
107347: PPUSH
107348: LD_VAR 0 4
107352: PPUSH
107353: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107357: LD_VAR 0 1
107361: PPUSH
107362: LD_VAR 0 2
107366: PPUSH
107367: LD_VAR 0 3
107371: PPUSH
107372: CALL_OW 331
// end ;
107376: LD_VAR 0 5
107380: RET
// export function Video ( mode ) ; begin
107381: LD_INT 0
107383: PPUSH
// ingame_video = mode ;
107384: LD_ADDR_OWVAR 52
107388: PUSH
107389: LD_VAR 0 1
107393: ST_TO_ADDR
// interface_hidden = mode ;
107394: LD_ADDR_OWVAR 54
107398: PUSH
107399: LD_VAR 0 1
107403: ST_TO_ADDR
// end ;
107404: LD_VAR 0 2
107408: RET
// export function Join ( array , element ) ; begin
107409: LD_INT 0
107411: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107412: LD_ADDR_VAR 0 3
107416: PUSH
107417: LD_VAR 0 1
107421: PPUSH
107422: LD_VAR 0 1
107426: PUSH
107427: LD_INT 1
107429: PLUS
107430: PPUSH
107431: LD_VAR 0 2
107435: PPUSH
107436: CALL_OW 1
107440: ST_TO_ADDR
// end ;
107441: LD_VAR 0 3
107445: RET
// export function JoinUnion ( array , element ) ; begin
107446: LD_INT 0
107448: PPUSH
// result := array union element ;
107449: LD_ADDR_VAR 0 3
107453: PUSH
107454: LD_VAR 0 1
107458: PUSH
107459: LD_VAR 0 2
107463: UNION
107464: ST_TO_ADDR
// end ;
107465: LD_VAR 0 3
107469: RET
// export function GetBehemoths ( side ) ; begin
107470: LD_INT 0
107472: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107473: LD_ADDR_VAR 0 2
107477: PUSH
107478: LD_INT 22
107480: PUSH
107481: LD_VAR 0 1
107485: PUSH
107486: EMPTY
107487: LIST
107488: LIST
107489: PUSH
107490: LD_INT 31
107492: PUSH
107493: LD_INT 25
107495: PUSH
107496: EMPTY
107497: LIST
107498: LIST
107499: PUSH
107500: EMPTY
107501: LIST
107502: LIST
107503: PPUSH
107504: CALL_OW 69
107508: ST_TO_ADDR
// end ;
107509: LD_VAR 0 2
107513: RET
// export function Shuffle ( array ) ; var i , index ; begin
107514: LD_INT 0
107516: PPUSH
107517: PPUSH
107518: PPUSH
// result := [ ] ;
107519: LD_ADDR_VAR 0 2
107523: PUSH
107524: EMPTY
107525: ST_TO_ADDR
// if not array then
107526: LD_VAR 0 1
107530: NOT
107531: IFFALSE 107535
// exit ;
107533: GO 107634
// Randomize ;
107535: CALL_OW 10
// for i = array downto 1 do
107539: LD_ADDR_VAR 0 3
107543: PUSH
107544: DOUBLE
107545: LD_VAR 0 1
107549: INC
107550: ST_TO_ADDR
107551: LD_INT 1
107553: PUSH
107554: FOR_DOWNTO
107555: IFFALSE 107632
// begin index := rand ( 1 , array ) ;
107557: LD_ADDR_VAR 0 4
107561: PUSH
107562: LD_INT 1
107564: PPUSH
107565: LD_VAR 0 1
107569: PPUSH
107570: CALL_OW 12
107574: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107575: LD_ADDR_VAR 0 2
107579: PUSH
107580: LD_VAR 0 2
107584: PPUSH
107585: LD_VAR 0 2
107589: PUSH
107590: LD_INT 1
107592: PLUS
107593: PPUSH
107594: LD_VAR 0 1
107598: PUSH
107599: LD_VAR 0 4
107603: ARRAY
107604: PPUSH
107605: CALL_OW 2
107609: ST_TO_ADDR
// array := Delete ( array , index ) ;
107610: LD_ADDR_VAR 0 1
107614: PUSH
107615: LD_VAR 0 1
107619: PPUSH
107620: LD_VAR 0 4
107624: PPUSH
107625: CALL_OW 3
107629: ST_TO_ADDR
// end ;
107630: GO 107554
107632: POP
107633: POP
// end ;
107634: LD_VAR 0 2
107638: RET
// export function GetBaseMaterials ( base ) ; begin
107639: LD_INT 0
107641: PPUSH
// result := [ 0 , 0 , 0 ] ;
107642: LD_ADDR_VAR 0 2
107646: PUSH
107647: LD_INT 0
107649: PUSH
107650: LD_INT 0
107652: PUSH
107653: LD_INT 0
107655: PUSH
107656: EMPTY
107657: LIST
107658: LIST
107659: LIST
107660: ST_TO_ADDR
// if not base then
107661: LD_VAR 0 1
107665: NOT
107666: IFFALSE 107670
// exit ;
107668: GO 107719
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107670: LD_ADDR_VAR 0 2
107674: PUSH
107675: LD_VAR 0 1
107679: PPUSH
107680: LD_INT 1
107682: PPUSH
107683: CALL_OW 275
107687: PUSH
107688: LD_VAR 0 1
107692: PPUSH
107693: LD_INT 2
107695: PPUSH
107696: CALL_OW 275
107700: PUSH
107701: LD_VAR 0 1
107705: PPUSH
107706: LD_INT 3
107708: PPUSH
107709: CALL_OW 275
107713: PUSH
107714: EMPTY
107715: LIST
107716: LIST
107717: LIST
107718: ST_TO_ADDR
// end ;
107719: LD_VAR 0 2
107723: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107724: LD_INT 0
107726: PPUSH
107727: PPUSH
// result := array ;
107728: LD_ADDR_VAR 0 3
107732: PUSH
107733: LD_VAR 0 1
107737: ST_TO_ADDR
// if size >= result then
107738: LD_VAR 0 2
107742: PUSH
107743: LD_VAR 0 3
107747: GREATEREQUAL
107748: IFFALSE 107752
// exit ;
107750: GO 107802
// if size then
107752: LD_VAR 0 2
107756: IFFALSE 107802
// for i := array downto size do
107758: LD_ADDR_VAR 0 4
107762: PUSH
107763: DOUBLE
107764: LD_VAR 0 1
107768: INC
107769: ST_TO_ADDR
107770: LD_VAR 0 2
107774: PUSH
107775: FOR_DOWNTO
107776: IFFALSE 107800
// result := Delete ( result , result ) ;
107778: LD_ADDR_VAR 0 3
107782: PUSH
107783: LD_VAR 0 3
107787: PPUSH
107788: LD_VAR 0 3
107792: PPUSH
107793: CALL_OW 3
107797: ST_TO_ADDR
107798: GO 107775
107800: POP
107801: POP
// end ;
107802: LD_VAR 0 3
107806: RET
// export function ComExit ( unit ) ; var tmp ; begin
107807: LD_INT 0
107809: PPUSH
107810: PPUSH
// if not IsInUnit ( unit ) then
107811: LD_VAR 0 1
107815: PPUSH
107816: CALL_OW 310
107820: NOT
107821: IFFALSE 107825
// exit ;
107823: GO 107885
// tmp := IsInUnit ( unit ) ;
107825: LD_ADDR_VAR 0 3
107829: PUSH
107830: LD_VAR 0 1
107834: PPUSH
107835: CALL_OW 310
107839: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107840: LD_VAR 0 3
107844: PPUSH
107845: CALL_OW 247
107849: PUSH
107850: LD_INT 2
107852: EQUAL
107853: IFFALSE 107866
// ComExitVehicle ( unit ) else
107855: LD_VAR 0 1
107859: PPUSH
107860: CALL_OW 121
107864: GO 107875
// ComExitBuilding ( unit ) ;
107866: LD_VAR 0 1
107870: PPUSH
107871: CALL_OW 122
// result := tmp ;
107875: LD_ADDR_VAR 0 2
107879: PUSH
107880: LD_VAR 0 3
107884: ST_TO_ADDR
// end ;
107885: LD_VAR 0 2
107889: RET
// export function ComExitAll ( units ) ; var i ; begin
107890: LD_INT 0
107892: PPUSH
107893: PPUSH
// if not units then
107894: LD_VAR 0 1
107898: NOT
107899: IFFALSE 107903
// exit ;
107901: GO 107929
// for i in units do
107903: LD_ADDR_VAR 0 3
107907: PUSH
107908: LD_VAR 0 1
107912: PUSH
107913: FOR_IN
107914: IFFALSE 107927
// ComExit ( i ) ;
107916: LD_VAR 0 3
107920: PPUSH
107921: CALL 107807 0 1
107925: GO 107913
107927: POP
107928: POP
// end ;
107929: LD_VAR 0 2
107933: RET
// export function ResetHc ; begin
107934: LD_INT 0
107936: PPUSH
// InitHc ;
107937: CALL_OW 19
// hc_importance := 0 ;
107941: LD_ADDR_OWVAR 32
107945: PUSH
107946: LD_INT 0
107948: ST_TO_ADDR
// end ;
107949: LD_VAR 0 1
107953: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107954: LD_INT 0
107956: PPUSH
107957: PPUSH
107958: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107959: LD_ADDR_VAR 0 6
107963: PUSH
107964: LD_VAR 0 1
107968: PUSH
107969: LD_VAR 0 3
107973: PLUS
107974: PUSH
107975: LD_INT 2
107977: DIV
107978: ST_TO_ADDR
// if _x < 0 then
107979: LD_VAR 0 6
107983: PUSH
107984: LD_INT 0
107986: LESS
107987: IFFALSE 108004
// _x := _x * - 1 ;
107989: LD_ADDR_VAR 0 6
107993: PUSH
107994: LD_VAR 0 6
107998: PUSH
107999: LD_INT 1
108001: NEG
108002: MUL
108003: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108004: LD_ADDR_VAR 0 7
108008: PUSH
108009: LD_VAR 0 2
108013: PUSH
108014: LD_VAR 0 4
108018: PLUS
108019: PUSH
108020: LD_INT 2
108022: DIV
108023: ST_TO_ADDR
// if _y < 0 then
108024: LD_VAR 0 7
108028: PUSH
108029: LD_INT 0
108031: LESS
108032: IFFALSE 108049
// _y := _y * - 1 ;
108034: LD_ADDR_VAR 0 7
108038: PUSH
108039: LD_VAR 0 7
108043: PUSH
108044: LD_INT 1
108046: NEG
108047: MUL
108048: ST_TO_ADDR
// result := [ _x , _y ] ;
108049: LD_ADDR_VAR 0 5
108053: PUSH
108054: LD_VAR 0 6
108058: PUSH
108059: LD_VAR 0 7
108063: PUSH
108064: EMPTY
108065: LIST
108066: LIST
108067: ST_TO_ADDR
// end ;
108068: LD_VAR 0 5
108072: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108073: LD_INT 0
108075: PPUSH
108076: PPUSH
108077: PPUSH
108078: PPUSH
// task := GetTaskList ( unit ) ;
108079: LD_ADDR_VAR 0 7
108083: PUSH
108084: LD_VAR 0 1
108088: PPUSH
108089: CALL_OW 437
108093: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108094: LD_VAR 0 7
108098: NOT
108099: PUSH
108100: LD_VAR 0 1
108104: PPUSH
108105: LD_VAR 0 2
108109: PPUSH
108110: CALL_OW 308
108114: NOT
108115: AND
108116: IFFALSE 108120
// exit ;
108118: GO 108238
// if IsInArea ( unit , area ) then
108120: LD_VAR 0 1
108124: PPUSH
108125: LD_VAR 0 2
108129: PPUSH
108130: CALL_OW 308
108134: IFFALSE 108152
// begin ComMoveToArea ( unit , goAway ) ;
108136: LD_VAR 0 1
108140: PPUSH
108141: LD_VAR 0 3
108145: PPUSH
108146: CALL_OW 113
// exit ;
108150: GO 108238
// end ; if task [ 1 ] [ 1 ] <> M then
108152: LD_VAR 0 7
108156: PUSH
108157: LD_INT 1
108159: ARRAY
108160: PUSH
108161: LD_INT 1
108163: ARRAY
108164: PUSH
108165: LD_STRING M
108167: NONEQUAL
108168: IFFALSE 108172
// exit ;
108170: GO 108238
// x := task [ 1 ] [ 2 ] ;
108172: LD_ADDR_VAR 0 5
108176: PUSH
108177: LD_VAR 0 7
108181: PUSH
108182: LD_INT 1
108184: ARRAY
108185: PUSH
108186: LD_INT 2
108188: ARRAY
108189: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108190: LD_ADDR_VAR 0 6
108194: PUSH
108195: LD_VAR 0 7
108199: PUSH
108200: LD_INT 1
108202: ARRAY
108203: PUSH
108204: LD_INT 3
108206: ARRAY
108207: ST_TO_ADDR
// if InArea ( x , y , area ) then
108208: LD_VAR 0 5
108212: PPUSH
108213: LD_VAR 0 6
108217: PPUSH
108218: LD_VAR 0 2
108222: PPUSH
108223: CALL_OW 309
108227: IFFALSE 108238
// ComStop ( unit ) ;
108229: LD_VAR 0 1
108233: PPUSH
108234: CALL_OW 141
// end ;
108238: LD_VAR 0 4
108242: RET
// export function Abs ( value ) ; begin
108243: LD_INT 0
108245: PPUSH
// result := value ;
108246: LD_ADDR_VAR 0 2
108250: PUSH
108251: LD_VAR 0 1
108255: ST_TO_ADDR
// if value < 0 then
108256: LD_VAR 0 1
108260: PUSH
108261: LD_INT 0
108263: LESS
108264: IFFALSE 108281
// result := value * - 1 ;
108266: LD_ADDR_VAR 0 2
108270: PUSH
108271: LD_VAR 0 1
108275: PUSH
108276: LD_INT 1
108278: NEG
108279: MUL
108280: ST_TO_ADDR
// end ;
108281: LD_VAR 0 2
108285: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108286: LD_INT 0
108288: PPUSH
108289: PPUSH
108290: PPUSH
108291: PPUSH
108292: PPUSH
108293: PPUSH
108294: PPUSH
108295: PPUSH
// if not unit or not building then
108296: LD_VAR 0 1
108300: NOT
108301: PUSH
108302: LD_VAR 0 2
108306: NOT
108307: OR
108308: IFFALSE 108312
// exit ;
108310: GO 108538
// x := GetX ( building ) ;
108312: LD_ADDR_VAR 0 4
108316: PUSH
108317: LD_VAR 0 2
108321: PPUSH
108322: CALL_OW 250
108326: ST_TO_ADDR
// y := GetY ( building ) ;
108327: LD_ADDR_VAR 0 6
108331: PUSH
108332: LD_VAR 0 2
108336: PPUSH
108337: CALL_OW 251
108341: ST_TO_ADDR
// d := GetDir ( building ) ;
108342: LD_ADDR_VAR 0 8
108346: PUSH
108347: LD_VAR 0 2
108351: PPUSH
108352: CALL_OW 254
108356: ST_TO_ADDR
// r := 4 ;
108357: LD_ADDR_VAR 0 9
108361: PUSH
108362: LD_INT 4
108364: ST_TO_ADDR
// for i := 1 to 5 do
108365: LD_ADDR_VAR 0 10
108369: PUSH
108370: DOUBLE
108371: LD_INT 1
108373: DEC
108374: ST_TO_ADDR
108375: LD_INT 5
108377: PUSH
108378: FOR_TO
108379: IFFALSE 108536
// begin _x := ShiftX ( x , d , r + i ) ;
108381: LD_ADDR_VAR 0 5
108385: PUSH
108386: LD_VAR 0 4
108390: PPUSH
108391: LD_VAR 0 8
108395: PPUSH
108396: LD_VAR 0 9
108400: PUSH
108401: LD_VAR 0 10
108405: PLUS
108406: PPUSH
108407: CALL_OW 272
108411: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108412: LD_ADDR_VAR 0 7
108416: PUSH
108417: LD_VAR 0 6
108421: PPUSH
108422: LD_VAR 0 8
108426: PPUSH
108427: LD_VAR 0 9
108431: PUSH
108432: LD_VAR 0 10
108436: PLUS
108437: PPUSH
108438: CALL_OW 273
108442: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108443: LD_VAR 0 5
108447: PPUSH
108448: LD_VAR 0 7
108452: PPUSH
108453: CALL_OW 488
108457: PUSH
108458: LD_VAR 0 5
108462: PPUSH
108463: LD_VAR 0 7
108467: PPUSH
108468: CALL_OW 428
108472: PPUSH
108473: CALL_OW 247
108477: PUSH
108478: LD_INT 3
108480: PUSH
108481: LD_INT 2
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: IN
108488: NOT
108489: AND
108490: IFFALSE 108534
// begin ComMoveXY ( unit , _x , _y ) ;
108492: LD_VAR 0 1
108496: PPUSH
108497: LD_VAR 0 5
108501: PPUSH
108502: LD_VAR 0 7
108506: PPUSH
108507: CALL_OW 111
// result := [ _x , _y ] ;
108511: LD_ADDR_VAR 0 3
108515: PUSH
108516: LD_VAR 0 5
108520: PUSH
108521: LD_VAR 0 7
108525: PUSH
108526: EMPTY
108527: LIST
108528: LIST
108529: ST_TO_ADDR
// exit ;
108530: POP
108531: POP
108532: GO 108538
// end ; end ;
108534: GO 108378
108536: POP
108537: POP
// end ;
108538: LD_VAR 0 3
108542: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108543: LD_INT 0
108545: PPUSH
108546: PPUSH
108547: PPUSH
// result := 0 ;
108548: LD_ADDR_VAR 0 3
108552: PUSH
108553: LD_INT 0
108555: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108556: LD_VAR 0 1
108560: PUSH
108561: LD_INT 0
108563: LESS
108564: PUSH
108565: LD_VAR 0 1
108569: PUSH
108570: LD_INT 8
108572: GREATER
108573: OR
108574: PUSH
108575: LD_VAR 0 2
108579: PUSH
108580: LD_INT 0
108582: LESS
108583: OR
108584: PUSH
108585: LD_VAR 0 2
108589: PUSH
108590: LD_INT 8
108592: GREATER
108593: OR
108594: IFFALSE 108598
// exit ;
108596: GO 108673
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108598: LD_ADDR_VAR 0 4
108602: PUSH
108603: LD_INT 22
108605: PUSH
108606: LD_VAR 0 2
108610: PUSH
108611: EMPTY
108612: LIST
108613: LIST
108614: PPUSH
108615: CALL_OW 69
108619: PUSH
108620: FOR_IN
108621: IFFALSE 108671
// begin un := UnitShoot ( i ) ;
108623: LD_ADDR_VAR 0 5
108627: PUSH
108628: LD_VAR 0 4
108632: PPUSH
108633: CALL_OW 504
108637: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108638: LD_VAR 0 5
108642: PPUSH
108643: CALL_OW 255
108647: PUSH
108648: LD_VAR 0 1
108652: EQUAL
108653: IFFALSE 108669
// begin result := un ;
108655: LD_ADDR_VAR 0 3
108659: PUSH
108660: LD_VAR 0 5
108664: ST_TO_ADDR
// exit ;
108665: POP
108666: POP
108667: GO 108673
// end ; end ;
108669: GO 108620
108671: POP
108672: POP
// end ;
108673: LD_VAR 0 3
108677: RET
// export function GetCargoBay ( units ) ; begin
108678: LD_INT 0
108680: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108681: LD_ADDR_VAR 0 2
108685: PUSH
108686: LD_VAR 0 1
108690: PPUSH
108691: LD_INT 2
108693: PUSH
108694: LD_INT 34
108696: PUSH
108697: LD_INT 12
108699: PUSH
108700: EMPTY
108701: LIST
108702: LIST
108703: PUSH
108704: LD_INT 34
108706: PUSH
108707: LD_INT 51
108709: PUSH
108710: EMPTY
108711: LIST
108712: LIST
108713: PUSH
108714: LD_INT 34
108716: PUSH
108717: LD_INT 32
108719: PUSH
108720: EMPTY
108721: LIST
108722: LIST
108723: PUSH
108724: LD_INT 34
108726: PUSH
108727: LD_INT 89
108729: PUSH
108730: EMPTY
108731: LIST
108732: LIST
108733: PUSH
108734: EMPTY
108735: LIST
108736: LIST
108737: LIST
108738: LIST
108739: LIST
108740: PPUSH
108741: CALL_OW 72
108745: ST_TO_ADDR
// end ;
108746: LD_VAR 0 2
108750: RET
// export function Negate ( value ) ; begin
108751: LD_INT 0
108753: PPUSH
// result := not value ;
108754: LD_ADDR_VAR 0 2
108758: PUSH
108759: LD_VAR 0 1
108763: NOT
108764: ST_TO_ADDR
// end ;
108765: LD_VAR 0 2
108769: RET
// export function Inc ( value ) ; begin
108770: LD_INT 0
108772: PPUSH
// result := value + 1 ;
108773: LD_ADDR_VAR 0 2
108777: PUSH
108778: LD_VAR 0 1
108782: PUSH
108783: LD_INT 1
108785: PLUS
108786: ST_TO_ADDR
// end ;
108787: LD_VAR 0 2
108791: RET
// export function Dec ( value ) ; begin
108792: LD_INT 0
108794: PPUSH
// result := value - 1 ;
108795: LD_ADDR_VAR 0 2
108799: PUSH
108800: LD_VAR 0 1
108804: PUSH
108805: LD_INT 1
108807: MINUS
108808: ST_TO_ADDR
// end ;
108809: LD_VAR 0 2
108813: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108814: LD_INT 0
108816: PPUSH
108817: PPUSH
108818: PPUSH
108819: PPUSH
108820: PPUSH
108821: PPUSH
108822: PPUSH
108823: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108824: LD_VAR 0 1
108828: PPUSH
108829: LD_VAR 0 2
108833: PPUSH
108834: CALL_OW 488
108838: NOT
108839: PUSH
108840: LD_VAR 0 3
108844: PPUSH
108845: LD_VAR 0 4
108849: PPUSH
108850: CALL_OW 488
108854: NOT
108855: OR
108856: IFFALSE 108869
// begin result := - 1 ;
108858: LD_ADDR_VAR 0 5
108862: PUSH
108863: LD_INT 1
108865: NEG
108866: ST_TO_ADDR
// exit ;
108867: GO 109104
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108869: LD_ADDR_VAR 0 12
108873: PUSH
108874: LD_VAR 0 1
108878: PPUSH
108879: LD_VAR 0 2
108883: PPUSH
108884: LD_VAR 0 3
108888: PPUSH
108889: LD_VAR 0 4
108893: PPUSH
108894: CALL 107954 0 4
108898: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108899: LD_ADDR_VAR 0 11
108903: PUSH
108904: LD_VAR 0 1
108908: PPUSH
108909: LD_VAR 0 2
108913: PPUSH
108914: LD_VAR 0 12
108918: PUSH
108919: LD_INT 1
108921: ARRAY
108922: PPUSH
108923: LD_VAR 0 12
108927: PUSH
108928: LD_INT 2
108930: ARRAY
108931: PPUSH
108932: CALL_OW 298
108936: ST_TO_ADDR
// distance := 9999 ;
108937: LD_ADDR_VAR 0 10
108941: PUSH
108942: LD_INT 9999
108944: ST_TO_ADDR
// for i := 0 to 5 do
108945: LD_ADDR_VAR 0 6
108949: PUSH
108950: DOUBLE
108951: LD_INT 0
108953: DEC
108954: ST_TO_ADDR
108955: LD_INT 5
108957: PUSH
108958: FOR_TO
108959: IFFALSE 109102
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108961: LD_ADDR_VAR 0 7
108965: PUSH
108966: LD_VAR 0 1
108970: PPUSH
108971: LD_VAR 0 6
108975: PPUSH
108976: LD_VAR 0 11
108980: PPUSH
108981: CALL_OW 272
108985: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108986: LD_ADDR_VAR 0 8
108990: PUSH
108991: LD_VAR 0 2
108995: PPUSH
108996: LD_VAR 0 6
109000: PPUSH
109001: LD_VAR 0 11
109005: PPUSH
109006: CALL_OW 273
109010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109011: LD_VAR 0 7
109015: PPUSH
109016: LD_VAR 0 8
109020: PPUSH
109021: CALL_OW 488
109025: NOT
109026: IFFALSE 109030
// continue ;
109028: GO 108958
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109030: LD_ADDR_VAR 0 9
109034: PUSH
109035: LD_VAR 0 12
109039: PUSH
109040: LD_INT 1
109042: ARRAY
109043: PPUSH
109044: LD_VAR 0 12
109048: PUSH
109049: LD_INT 2
109051: ARRAY
109052: PPUSH
109053: LD_VAR 0 7
109057: PPUSH
109058: LD_VAR 0 8
109062: PPUSH
109063: CALL_OW 298
109067: ST_TO_ADDR
// if tmp < distance then
109068: LD_VAR 0 9
109072: PUSH
109073: LD_VAR 0 10
109077: LESS
109078: IFFALSE 109100
// begin result := i ;
109080: LD_ADDR_VAR 0 5
109084: PUSH
109085: LD_VAR 0 6
109089: ST_TO_ADDR
// distance := tmp ;
109090: LD_ADDR_VAR 0 10
109094: PUSH
109095: LD_VAR 0 9
109099: ST_TO_ADDR
// end ; end ;
109100: GO 108958
109102: POP
109103: POP
// end ;
109104: LD_VAR 0 5
109108: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109109: LD_INT 0
109111: PPUSH
109112: PPUSH
// if not driver or not IsInUnit ( driver ) then
109113: LD_VAR 0 1
109117: NOT
109118: PUSH
109119: LD_VAR 0 1
109123: PPUSH
109124: CALL_OW 310
109128: NOT
109129: OR
109130: IFFALSE 109134
// exit ;
109132: GO 109224
// vehicle := IsInUnit ( driver ) ;
109134: LD_ADDR_VAR 0 3
109138: PUSH
109139: LD_VAR 0 1
109143: PPUSH
109144: CALL_OW 310
109148: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109149: LD_VAR 0 1
109153: PPUSH
109154: LD_STRING \
109156: PUSH
109157: LD_INT 0
109159: PUSH
109160: LD_INT 0
109162: PUSH
109163: LD_INT 0
109165: PUSH
109166: LD_INT 0
109168: PUSH
109169: LD_INT 0
109171: PUSH
109172: LD_INT 0
109174: PUSH
109175: EMPTY
109176: LIST
109177: LIST
109178: LIST
109179: LIST
109180: LIST
109181: LIST
109182: LIST
109183: PUSH
109184: LD_STRING E
109186: PUSH
109187: LD_INT 0
109189: PUSH
109190: LD_INT 0
109192: PUSH
109193: LD_VAR 0 3
109197: PUSH
109198: LD_INT 0
109200: PUSH
109201: LD_INT 0
109203: PUSH
109204: LD_INT 0
109206: PUSH
109207: EMPTY
109208: LIST
109209: LIST
109210: LIST
109211: LIST
109212: LIST
109213: LIST
109214: LIST
109215: PUSH
109216: EMPTY
109217: LIST
109218: LIST
109219: PPUSH
109220: CALL_OW 446
// end ;
109224: LD_VAR 0 2
109228: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109229: LD_INT 0
109231: PPUSH
109232: PPUSH
// if not driver or not IsInUnit ( driver ) then
109233: LD_VAR 0 1
109237: NOT
109238: PUSH
109239: LD_VAR 0 1
109243: PPUSH
109244: CALL_OW 310
109248: NOT
109249: OR
109250: IFFALSE 109254
// exit ;
109252: GO 109344
// vehicle := IsInUnit ( driver ) ;
109254: LD_ADDR_VAR 0 3
109258: PUSH
109259: LD_VAR 0 1
109263: PPUSH
109264: CALL_OW 310
109268: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109269: LD_VAR 0 1
109273: PPUSH
109274: LD_STRING \
109276: PUSH
109277: LD_INT 0
109279: PUSH
109280: LD_INT 0
109282: PUSH
109283: LD_INT 0
109285: PUSH
109286: LD_INT 0
109288: PUSH
109289: LD_INT 0
109291: PUSH
109292: LD_INT 0
109294: PUSH
109295: EMPTY
109296: LIST
109297: LIST
109298: LIST
109299: LIST
109300: LIST
109301: LIST
109302: LIST
109303: PUSH
109304: LD_STRING E
109306: PUSH
109307: LD_INT 0
109309: PUSH
109310: LD_INT 0
109312: PUSH
109313: LD_VAR 0 3
109317: PUSH
109318: LD_INT 0
109320: PUSH
109321: LD_INT 0
109323: PUSH
109324: LD_INT 0
109326: PUSH
109327: EMPTY
109328: LIST
109329: LIST
109330: LIST
109331: LIST
109332: LIST
109333: LIST
109334: LIST
109335: PUSH
109336: EMPTY
109337: LIST
109338: LIST
109339: PPUSH
109340: CALL_OW 447
// end ;
109344: LD_VAR 0 2
109348: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109349: LD_INT 0
109351: PPUSH
109352: PPUSH
109353: PPUSH
// tmp := [ ] ;
109354: LD_ADDR_VAR 0 5
109358: PUSH
109359: EMPTY
109360: ST_TO_ADDR
// for i in units do
109361: LD_ADDR_VAR 0 4
109365: PUSH
109366: LD_VAR 0 1
109370: PUSH
109371: FOR_IN
109372: IFFALSE 109410
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109374: LD_ADDR_VAR 0 5
109378: PUSH
109379: LD_VAR 0 5
109383: PPUSH
109384: LD_VAR 0 5
109388: PUSH
109389: LD_INT 1
109391: PLUS
109392: PPUSH
109393: LD_VAR 0 4
109397: PPUSH
109398: CALL_OW 256
109402: PPUSH
109403: CALL_OW 2
109407: ST_TO_ADDR
109408: GO 109371
109410: POP
109411: POP
// if not tmp then
109412: LD_VAR 0 5
109416: NOT
109417: IFFALSE 109421
// exit ;
109419: GO 109469
// if asc then
109421: LD_VAR 0 2
109425: IFFALSE 109449
// result := SortListByListAsc ( units , tmp ) else
109427: LD_ADDR_VAR 0 3
109431: PUSH
109432: LD_VAR 0 1
109436: PPUSH
109437: LD_VAR 0 5
109441: PPUSH
109442: CALL_OW 76
109446: ST_TO_ADDR
109447: GO 109469
// result := SortListByListDesc ( units , tmp ) ;
109449: LD_ADDR_VAR 0 3
109453: PUSH
109454: LD_VAR 0 1
109458: PPUSH
109459: LD_VAR 0 5
109463: PPUSH
109464: CALL_OW 77
109468: ST_TO_ADDR
// end ;
109469: LD_VAR 0 3
109473: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109474: LD_INT 0
109476: PPUSH
109477: PPUSH
// task := GetTaskList ( mech ) ;
109478: LD_ADDR_VAR 0 4
109482: PUSH
109483: LD_VAR 0 1
109487: PPUSH
109488: CALL_OW 437
109492: ST_TO_ADDR
// if not task then
109493: LD_VAR 0 4
109497: NOT
109498: IFFALSE 109502
// exit ;
109500: GO 109544
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109502: LD_ADDR_VAR 0 3
109506: PUSH
109507: LD_VAR 0 4
109511: PUSH
109512: LD_INT 1
109514: ARRAY
109515: PUSH
109516: LD_INT 1
109518: ARRAY
109519: PUSH
109520: LD_STRING r
109522: EQUAL
109523: PUSH
109524: LD_VAR 0 4
109528: PUSH
109529: LD_INT 1
109531: ARRAY
109532: PUSH
109533: LD_INT 4
109535: ARRAY
109536: PUSH
109537: LD_VAR 0 2
109541: EQUAL
109542: AND
109543: ST_TO_ADDR
// end ;
109544: LD_VAR 0 3
109548: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109549: LD_INT 0
109551: PPUSH
// SetDir ( unit , d ) ;
109552: LD_VAR 0 1
109556: PPUSH
109557: LD_VAR 0 4
109561: PPUSH
109562: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109566: LD_VAR 0 1
109570: PPUSH
109571: LD_VAR 0 2
109575: PPUSH
109576: LD_VAR 0 3
109580: PPUSH
109581: LD_VAR 0 5
109585: PPUSH
109586: CALL_OW 48
// end ;
109590: LD_VAR 0 6
109594: RET
// export function ToNaturalNumber ( number ) ; begin
109595: LD_INT 0
109597: PPUSH
// result := number div 1 ;
109598: LD_ADDR_VAR 0 2
109602: PUSH
109603: LD_VAR 0 1
109607: PUSH
109608: LD_INT 1
109610: DIV
109611: ST_TO_ADDR
// if number < 0 then
109612: LD_VAR 0 1
109616: PUSH
109617: LD_INT 0
109619: LESS
109620: IFFALSE 109630
// result := 0 ;
109622: LD_ADDR_VAR 0 2
109626: PUSH
109627: LD_INT 0
109629: ST_TO_ADDR
// end ;
109630: LD_VAR 0 2
109634: RET
// export function SortByClass ( units , class ) ; var un ; begin
109635: LD_INT 0
109637: PPUSH
109638: PPUSH
// if not units or not class then
109639: LD_VAR 0 1
109643: NOT
109644: PUSH
109645: LD_VAR 0 2
109649: NOT
109650: OR
109651: IFFALSE 109655
// exit ;
109653: GO 109750
// result := [ ] ;
109655: LD_ADDR_VAR 0 3
109659: PUSH
109660: EMPTY
109661: ST_TO_ADDR
// for un in units do
109662: LD_ADDR_VAR 0 4
109666: PUSH
109667: LD_VAR 0 1
109671: PUSH
109672: FOR_IN
109673: IFFALSE 109748
// if GetClass ( un ) = class then
109675: LD_VAR 0 4
109679: PPUSH
109680: CALL_OW 257
109684: PUSH
109685: LD_VAR 0 2
109689: EQUAL
109690: IFFALSE 109717
// result := Insert ( result , 1 , un ) else
109692: LD_ADDR_VAR 0 3
109696: PUSH
109697: LD_VAR 0 3
109701: PPUSH
109702: LD_INT 1
109704: PPUSH
109705: LD_VAR 0 4
109709: PPUSH
109710: CALL_OW 2
109714: ST_TO_ADDR
109715: GO 109746
// result := Replace ( result , result + 1 , un ) ;
109717: LD_ADDR_VAR 0 3
109721: PUSH
109722: LD_VAR 0 3
109726: PPUSH
109727: LD_VAR 0 3
109731: PUSH
109732: LD_INT 1
109734: PLUS
109735: PPUSH
109736: LD_VAR 0 4
109740: PPUSH
109741: CALL_OW 1
109745: ST_TO_ADDR
109746: GO 109672
109748: POP
109749: POP
// end ;
109750: LD_VAR 0 3
109754: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109755: LD_INT 0
109757: PPUSH
109758: PPUSH
109759: PPUSH
109760: PPUSH
109761: PPUSH
109762: PPUSH
109763: PPUSH
// result := [ ] ;
109764: LD_ADDR_VAR 0 4
109768: PUSH
109769: EMPTY
109770: ST_TO_ADDR
// if x - r < 0 then
109771: LD_VAR 0 1
109775: PUSH
109776: LD_VAR 0 3
109780: MINUS
109781: PUSH
109782: LD_INT 0
109784: LESS
109785: IFFALSE 109797
// min_x := 0 else
109787: LD_ADDR_VAR 0 8
109791: PUSH
109792: LD_INT 0
109794: ST_TO_ADDR
109795: GO 109813
// min_x := x - r ;
109797: LD_ADDR_VAR 0 8
109801: PUSH
109802: LD_VAR 0 1
109806: PUSH
109807: LD_VAR 0 3
109811: MINUS
109812: ST_TO_ADDR
// if y - r < 0 then
109813: LD_VAR 0 2
109817: PUSH
109818: LD_VAR 0 3
109822: MINUS
109823: PUSH
109824: LD_INT 0
109826: LESS
109827: IFFALSE 109839
// min_y := 0 else
109829: LD_ADDR_VAR 0 7
109833: PUSH
109834: LD_INT 0
109836: ST_TO_ADDR
109837: GO 109855
// min_y := y - r ;
109839: LD_ADDR_VAR 0 7
109843: PUSH
109844: LD_VAR 0 2
109848: PUSH
109849: LD_VAR 0 3
109853: MINUS
109854: ST_TO_ADDR
// max_x := x + r ;
109855: LD_ADDR_VAR 0 9
109859: PUSH
109860: LD_VAR 0 1
109864: PUSH
109865: LD_VAR 0 3
109869: PLUS
109870: ST_TO_ADDR
// max_y := y + r ;
109871: LD_ADDR_VAR 0 10
109875: PUSH
109876: LD_VAR 0 2
109880: PUSH
109881: LD_VAR 0 3
109885: PLUS
109886: ST_TO_ADDR
// for _x = min_x to max_x do
109887: LD_ADDR_VAR 0 5
109891: PUSH
109892: DOUBLE
109893: LD_VAR 0 8
109897: DEC
109898: ST_TO_ADDR
109899: LD_VAR 0 9
109903: PUSH
109904: FOR_TO
109905: IFFALSE 110006
// for _y = min_y to max_y do
109907: LD_ADDR_VAR 0 6
109911: PUSH
109912: DOUBLE
109913: LD_VAR 0 7
109917: DEC
109918: ST_TO_ADDR
109919: LD_VAR 0 10
109923: PUSH
109924: FOR_TO
109925: IFFALSE 110002
// begin if not ValidHex ( _x , _y ) then
109927: LD_VAR 0 5
109931: PPUSH
109932: LD_VAR 0 6
109936: PPUSH
109937: CALL_OW 488
109941: NOT
109942: IFFALSE 109946
// continue ;
109944: GO 109924
// if GetResourceTypeXY ( _x , _y ) then
109946: LD_VAR 0 5
109950: PPUSH
109951: LD_VAR 0 6
109955: PPUSH
109956: CALL_OW 283
109960: IFFALSE 110000
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109962: LD_ADDR_VAR 0 4
109966: PUSH
109967: LD_VAR 0 4
109971: PPUSH
109972: LD_VAR 0 4
109976: PUSH
109977: LD_INT 1
109979: PLUS
109980: PPUSH
109981: LD_VAR 0 5
109985: PUSH
109986: LD_VAR 0 6
109990: PUSH
109991: EMPTY
109992: LIST
109993: LIST
109994: PPUSH
109995: CALL_OW 1
109999: ST_TO_ADDR
// end ;
110000: GO 109924
110002: POP
110003: POP
110004: GO 109904
110006: POP
110007: POP
// end ;
110008: LD_VAR 0 4
110012: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110013: LD_INT 0
110015: PPUSH
110016: PPUSH
110017: PPUSH
110018: PPUSH
110019: PPUSH
110020: PPUSH
110021: PPUSH
110022: PPUSH
// if not units then
110023: LD_VAR 0 1
110027: NOT
110028: IFFALSE 110032
// exit ;
110030: GO 110556
// result := UnitFilter ( units , [ f_ok ] ) ;
110032: LD_ADDR_VAR 0 3
110036: PUSH
110037: LD_VAR 0 1
110041: PPUSH
110042: LD_INT 50
110044: PUSH
110045: EMPTY
110046: LIST
110047: PPUSH
110048: CALL_OW 72
110052: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110053: LD_ADDR_VAR 0 8
110057: PUSH
110058: LD_VAR 0 1
110062: PUSH
110063: LD_INT 1
110065: ARRAY
110066: PPUSH
110067: CALL_OW 255
110071: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110072: LD_ADDR_VAR 0 10
110076: PUSH
110077: LD_INT 29
110079: PUSH
110080: LD_INT 91
110082: PUSH
110083: LD_INT 49
110085: PUSH
110086: EMPTY
110087: LIST
110088: LIST
110089: LIST
110090: ST_TO_ADDR
// if not result then
110091: LD_VAR 0 3
110095: NOT
110096: IFFALSE 110100
// exit ;
110098: GO 110556
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110100: LD_ADDR_VAR 0 5
110104: PUSH
110105: LD_INT 81
110107: PUSH
110108: LD_VAR 0 8
110112: PUSH
110113: EMPTY
110114: LIST
110115: LIST
110116: PPUSH
110117: CALL_OW 69
110121: ST_TO_ADDR
// for i in result do
110122: LD_ADDR_VAR 0 4
110126: PUSH
110127: LD_VAR 0 3
110131: PUSH
110132: FOR_IN
110133: IFFALSE 110554
// begin tag := GetTag ( i ) + 1 ;
110135: LD_ADDR_VAR 0 9
110139: PUSH
110140: LD_VAR 0 4
110144: PPUSH
110145: CALL_OW 110
110149: PUSH
110150: LD_INT 1
110152: PLUS
110153: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
110154: LD_ADDR_VAR 0 7
110158: PUSH
110159: LD_VAR 0 4
110163: PPUSH
110164: CALL_OW 250
110168: PPUSH
110169: LD_VAR 0 4
110173: PPUSH
110174: CALL_OW 251
110178: PPUSH
110179: LD_INT 6
110181: PPUSH
110182: CALL 109755 0 3
110186: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
110187: LD_VAR 0 4
110191: PPUSH
110192: CALL_OW 247
110196: PUSH
110197: LD_INT 2
110199: EQUAL
110200: PUSH
110201: LD_VAR 0 7
110205: AND
110206: PUSH
110207: LD_VAR 0 4
110211: PPUSH
110212: CALL_OW 264
110216: PUSH
110217: LD_VAR 0 10
110221: IN
110222: NOT
110223: AND
110224: IFFALSE 110263
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110226: LD_VAR 0 4
110230: PPUSH
110231: LD_VAR 0 7
110235: PUSH
110236: LD_INT 1
110238: ARRAY
110239: PUSH
110240: LD_INT 1
110242: ARRAY
110243: PPUSH
110244: LD_VAR 0 7
110248: PUSH
110249: LD_INT 1
110251: ARRAY
110252: PUSH
110253: LD_INT 2
110255: ARRAY
110256: PPUSH
110257: CALL_OW 116
110261: GO 110552
// if path > tag then
110263: LD_VAR 0 2
110267: PUSH
110268: LD_VAR 0 9
110272: GREATER
110273: IFFALSE 110481
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110275: LD_ADDR_VAR 0 6
110279: PUSH
110280: LD_VAR 0 5
110284: PPUSH
110285: LD_INT 91
110287: PUSH
110288: LD_VAR 0 4
110292: PUSH
110293: LD_INT 8
110295: PUSH
110296: EMPTY
110297: LIST
110298: LIST
110299: LIST
110300: PPUSH
110301: CALL_OW 72
110305: ST_TO_ADDR
// if nearEnemy then
110306: LD_VAR 0 6
110310: IFFALSE 110379
// begin if GetWeapon ( i ) = ru_time_lapser then
110312: LD_VAR 0 4
110316: PPUSH
110317: CALL_OW 264
110321: PUSH
110322: LD_INT 49
110324: EQUAL
110325: IFFALSE 110353
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110327: LD_VAR 0 4
110331: PPUSH
110332: LD_VAR 0 6
110336: PPUSH
110337: LD_VAR 0 4
110341: PPUSH
110342: CALL_OW 74
110346: PPUSH
110347: CALL_OW 112
110351: GO 110377
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110353: LD_VAR 0 4
110357: PPUSH
110358: LD_VAR 0 6
110362: PPUSH
110363: LD_VAR 0 4
110367: PPUSH
110368: CALL_OW 74
110372: PPUSH
110373: CALL 111627 0 2
// end else
110377: GO 110479
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110379: LD_VAR 0 4
110383: PPUSH
110384: LD_VAR 0 2
110388: PUSH
110389: LD_VAR 0 9
110393: ARRAY
110394: PUSH
110395: LD_INT 1
110397: ARRAY
110398: PPUSH
110399: LD_VAR 0 2
110403: PUSH
110404: LD_VAR 0 9
110408: ARRAY
110409: PUSH
110410: LD_INT 2
110412: ARRAY
110413: PPUSH
110414: CALL_OW 297
110418: PUSH
110419: LD_INT 6
110421: GREATER
110422: IFFALSE 110465
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110424: LD_VAR 0 4
110428: PPUSH
110429: LD_VAR 0 2
110433: PUSH
110434: LD_VAR 0 9
110438: ARRAY
110439: PUSH
110440: LD_INT 1
110442: ARRAY
110443: PPUSH
110444: LD_VAR 0 2
110448: PUSH
110449: LD_VAR 0 9
110453: ARRAY
110454: PUSH
110455: LD_INT 2
110457: ARRAY
110458: PPUSH
110459: CALL_OW 114
110463: GO 110479
// SetTag ( i , tag ) ;
110465: LD_VAR 0 4
110469: PPUSH
110470: LD_VAR 0 9
110474: PPUSH
110475: CALL_OW 109
// end else
110479: GO 110552
// if enemy then
110481: LD_VAR 0 5
110485: IFFALSE 110552
// begin if GetWeapon ( i ) = ru_time_lapser then
110487: LD_VAR 0 4
110491: PPUSH
110492: CALL_OW 264
110496: PUSH
110497: LD_INT 49
110499: EQUAL
110500: IFFALSE 110528
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110502: LD_VAR 0 4
110506: PPUSH
110507: LD_VAR 0 5
110511: PPUSH
110512: LD_VAR 0 4
110516: PPUSH
110517: CALL_OW 74
110521: PPUSH
110522: CALL_OW 112
110526: GO 110552
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110528: LD_VAR 0 4
110532: PPUSH
110533: LD_VAR 0 5
110537: PPUSH
110538: LD_VAR 0 4
110542: PPUSH
110543: CALL_OW 74
110547: PPUSH
110548: CALL 111627 0 2
// end ; end ;
110552: GO 110132
110554: POP
110555: POP
// end ;
110556: LD_VAR 0 3
110560: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110561: LD_INT 0
110563: PPUSH
110564: PPUSH
110565: PPUSH
// if not unit or IsInUnit ( unit ) then
110566: LD_VAR 0 1
110570: NOT
110571: PUSH
110572: LD_VAR 0 1
110576: PPUSH
110577: CALL_OW 310
110581: OR
110582: IFFALSE 110586
// exit ;
110584: GO 110677
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110586: LD_ADDR_VAR 0 4
110590: PUSH
110591: LD_VAR 0 1
110595: PPUSH
110596: CALL_OW 250
110600: PPUSH
110601: LD_VAR 0 2
110605: PPUSH
110606: LD_INT 1
110608: PPUSH
110609: CALL_OW 272
110613: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110614: LD_ADDR_VAR 0 5
110618: PUSH
110619: LD_VAR 0 1
110623: PPUSH
110624: CALL_OW 251
110628: PPUSH
110629: LD_VAR 0 2
110633: PPUSH
110634: LD_INT 1
110636: PPUSH
110637: CALL_OW 273
110641: ST_TO_ADDR
// if ValidHex ( x , y ) then
110642: LD_VAR 0 4
110646: PPUSH
110647: LD_VAR 0 5
110651: PPUSH
110652: CALL_OW 488
110656: IFFALSE 110677
// ComTurnXY ( unit , x , y ) ;
110658: LD_VAR 0 1
110662: PPUSH
110663: LD_VAR 0 4
110667: PPUSH
110668: LD_VAR 0 5
110672: PPUSH
110673: CALL_OW 118
// end ;
110677: LD_VAR 0 3
110681: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110682: LD_INT 0
110684: PPUSH
110685: PPUSH
// result := false ;
110686: LD_ADDR_VAR 0 3
110690: PUSH
110691: LD_INT 0
110693: ST_TO_ADDR
// if not units then
110694: LD_VAR 0 2
110698: NOT
110699: IFFALSE 110703
// exit ;
110701: GO 110748
// for i in units do
110703: LD_ADDR_VAR 0 4
110707: PUSH
110708: LD_VAR 0 2
110712: PUSH
110713: FOR_IN
110714: IFFALSE 110746
// if See ( side , i ) then
110716: LD_VAR 0 1
110720: PPUSH
110721: LD_VAR 0 4
110725: PPUSH
110726: CALL_OW 292
110730: IFFALSE 110744
// begin result := true ;
110732: LD_ADDR_VAR 0 3
110736: PUSH
110737: LD_INT 1
110739: ST_TO_ADDR
// exit ;
110740: POP
110741: POP
110742: GO 110748
// end ;
110744: GO 110713
110746: POP
110747: POP
// end ;
110748: LD_VAR 0 3
110752: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110753: LD_INT 0
110755: PPUSH
110756: PPUSH
110757: PPUSH
110758: PPUSH
// if not unit or not points then
110759: LD_VAR 0 1
110763: NOT
110764: PUSH
110765: LD_VAR 0 2
110769: NOT
110770: OR
110771: IFFALSE 110775
// exit ;
110773: GO 110865
// dist := 99999 ;
110775: LD_ADDR_VAR 0 5
110779: PUSH
110780: LD_INT 99999
110782: ST_TO_ADDR
// for i in points do
110783: LD_ADDR_VAR 0 4
110787: PUSH
110788: LD_VAR 0 2
110792: PUSH
110793: FOR_IN
110794: IFFALSE 110863
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110796: LD_ADDR_VAR 0 6
110800: PUSH
110801: LD_VAR 0 1
110805: PPUSH
110806: LD_VAR 0 4
110810: PUSH
110811: LD_INT 1
110813: ARRAY
110814: PPUSH
110815: LD_VAR 0 4
110819: PUSH
110820: LD_INT 2
110822: ARRAY
110823: PPUSH
110824: CALL_OW 297
110828: ST_TO_ADDR
// if tmpDist < dist then
110829: LD_VAR 0 6
110833: PUSH
110834: LD_VAR 0 5
110838: LESS
110839: IFFALSE 110861
// begin result := i ;
110841: LD_ADDR_VAR 0 3
110845: PUSH
110846: LD_VAR 0 4
110850: ST_TO_ADDR
// dist := tmpDist ;
110851: LD_ADDR_VAR 0 5
110855: PUSH
110856: LD_VAR 0 6
110860: ST_TO_ADDR
// end ; end ;
110861: GO 110793
110863: POP
110864: POP
// end ;
110865: LD_VAR 0 3
110869: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110870: LD_INT 0
110872: PPUSH
// uc_side := side ;
110873: LD_ADDR_OWVAR 20
110877: PUSH
110878: LD_VAR 0 1
110882: ST_TO_ADDR
// uc_nation := 3 ;
110883: LD_ADDR_OWVAR 21
110887: PUSH
110888: LD_INT 3
110890: ST_TO_ADDR
// vc_chassis := 25 ;
110891: LD_ADDR_OWVAR 37
110895: PUSH
110896: LD_INT 25
110898: ST_TO_ADDR
// vc_engine := engine_siberite ;
110899: LD_ADDR_OWVAR 39
110903: PUSH
110904: LD_INT 3
110906: ST_TO_ADDR
// vc_control := control_computer ;
110907: LD_ADDR_OWVAR 38
110911: PUSH
110912: LD_INT 3
110914: ST_TO_ADDR
// vc_weapon := 59 ;
110915: LD_ADDR_OWVAR 40
110919: PUSH
110920: LD_INT 59
110922: ST_TO_ADDR
// result := CreateVehicle ;
110923: LD_ADDR_VAR 0 5
110927: PUSH
110928: CALL_OW 45
110932: ST_TO_ADDR
// SetDir ( result , d ) ;
110933: LD_VAR 0 5
110937: PPUSH
110938: LD_VAR 0 4
110942: PPUSH
110943: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110947: LD_VAR 0 5
110951: PPUSH
110952: LD_VAR 0 2
110956: PPUSH
110957: LD_VAR 0 3
110961: PPUSH
110962: LD_INT 0
110964: PPUSH
110965: CALL_OW 48
// end ;
110969: LD_VAR 0 5
110973: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110974: LD_INT 0
110976: PPUSH
110977: PPUSH
110978: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110979: LD_ADDR_VAR 0 2
110983: PUSH
110984: LD_INT 0
110986: PUSH
110987: LD_INT 0
110989: PUSH
110990: LD_INT 0
110992: PUSH
110993: LD_INT 0
110995: PUSH
110996: EMPTY
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111002: LD_VAR 0 1
111006: NOT
111007: PUSH
111008: LD_VAR 0 1
111012: PPUSH
111013: CALL_OW 264
111017: PUSH
111018: LD_INT 12
111020: PUSH
111021: LD_INT 51
111023: PUSH
111024: LD_INT 32
111026: PUSH
111027: LD_INT 89
111029: PUSH
111030: EMPTY
111031: LIST
111032: LIST
111033: LIST
111034: LIST
111035: IN
111036: NOT
111037: OR
111038: IFFALSE 111042
// exit ;
111040: GO 111140
// for i := 1 to 3 do
111042: LD_ADDR_VAR 0 3
111046: PUSH
111047: DOUBLE
111048: LD_INT 1
111050: DEC
111051: ST_TO_ADDR
111052: LD_INT 3
111054: PUSH
111055: FOR_TO
111056: IFFALSE 111138
// begin tmp := GetCargo ( cargo , i ) ;
111058: LD_ADDR_VAR 0 4
111062: PUSH
111063: LD_VAR 0 1
111067: PPUSH
111068: LD_VAR 0 3
111072: PPUSH
111073: CALL_OW 289
111077: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111078: LD_ADDR_VAR 0 2
111082: PUSH
111083: LD_VAR 0 2
111087: PPUSH
111088: LD_VAR 0 3
111092: PPUSH
111093: LD_VAR 0 4
111097: PPUSH
111098: CALL_OW 1
111102: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111103: LD_ADDR_VAR 0 2
111107: PUSH
111108: LD_VAR 0 2
111112: PPUSH
111113: LD_INT 4
111115: PPUSH
111116: LD_VAR 0 2
111120: PUSH
111121: LD_INT 4
111123: ARRAY
111124: PUSH
111125: LD_VAR 0 4
111129: PLUS
111130: PPUSH
111131: CALL_OW 1
111135: ST_TO_ADDR
// end ;
111136: GO 111055
111138: POP
111139: POP
// end ;
111140: LD_VAR 0 2
111144: RET
// export function Length ( array ) ; begin
111145: LD_INT 0
111147: PPUSH
// result := array + 0 ;
111148: LD_ADDR_VAR 0 2
111152: PUSH
111153: LD_VAR 0 1
111157: PUSH
111158: LD_INT 0
111160: PLUS
111161: ST_TO_ADDR
// end ;
111162: LD_VAR 0 2
111166: RET
// export function PrepareArray ( array ) ; begin
111167: LD_INT 0
111169: PPUSH
// result := array diff 0 ;
111170: LD_ADDR_VAR 0 2
111174: PUSH
111175: LD_VAR 0 1
111179: PUSH
111180: LD_INT 0
111182: DIFF
111183: ST_TO_ADDR
// if not result [ 1 ] then
111184: LD_VAR 0 2
111188: PUSH
111189: LD_INT 1
111191: ARRAY
111192: NOT
111193: IFFALSE 111213
// result := Delete ( result , 1 ) ;
111195: LD_ADDR_VAR 0 2
111199: PUSH
111200: LD_VAR 0 2
111204: PPUSH
111205: LD_INT 1
111207: PPUSH
111208: CALL_OW 3
111212: ST_TO_ADDR
// end ;
111213: LD_VAR 0 2
111217: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111218: LD_INT 0
111220: PPUSH
111221: PPUSH
111222: PPUSH
111223: PPUSH
// sibRocketRange := 25 ;
111224: LD_ADDR_VAR 0 6
111228: PUSH
111229: LD_INT 25
111231: ST_TO_ADDR
// result := false ;
111232: LD_ADDR_VAR 0 4
111236: PUSH
111237: LD_INT 0
111239: ST_TO_ADDR
// for i := 0 to 5 do
111240: LD_ADDR_VAR 0 5
111244: PUSH
111245: DOUBLE
111246: LD_INT 0
111248: DEC
111249: ST_TO_ADDR
111250: LD_INT 5
111252: PUSH
111253: FOR_TO
111254: IFFALSE 111321
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111256: LD_VAR 0 1
111260: PPUSH
111261: LD_VAR 0 5
111265: PPUSH
111266: LD_VAR 0 6
111270: PPUSH
111271: CALL_OW 272
111275: PPUSH
111276: LD_VAR 0 2
111280: PPUSH
111281: LD_VAR 0 5
111285: PPUSH
111286: LD_VAR 0 6
111290: PPUSH
111291: CALL_OW 273
111295: PPUSH
111296: LD_VAR 0 3
111300: PPUSH
111301: CALL_OW 309
111305: IFFALSE 111319
// begin result := true ;
111307: LD_ADDR_VAR 0 4
111311: PUSH
111312: LD_INT 1
111314: ST_TO_ADDR
// exit ;
111315: POP
111316: POP
111317: GO 111323
// end ;
111319: GO 111253
111321: POP
111322: POP
// end ;
111323: LD_VAR 0 4
111327: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111328: LD_INT 0
111330: PPUSH
111331: PPUSH
111332: PPUSH
// if btype = b_depot then
111333: LD_VAR 0 2
111337: PUSH
111338: LD_INT 0
111340: EQUAL
111341: IFFALSE 111353
// begin result := true ;
111343: LD_ADDR_VAR 0 3
111347: PUSH
111348: LD_INT 1
111350: ST_TO_ADDR
// exit ;
111351: GO 111469
// end ; pom := GetBase ( depot ) ;
111353: LD_ADDR_VAR 0 4
111357: PUSH
111358: LD_VAR 0 1
111362: PPUSH
111363: CALL_OW 274
111367: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111368: LD_ADDR_VAR 0 5
111372: PUSH
111373: LD_VAR 0 2
111377: PPUSH
111378: LD_VAR 0 1
111382: PPUSH
111383: CALL_OW 248
111387: PPUSH
111388: CALL_OW 450
111392: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111393: LD_ADDR_VAR 0 3
111397: PUSH
111398: LD_VAR 0 4
111402: PPUSH
111403: LD_INT 1
111405: PPUSH
111406: CALL_OW 275
111410: PUSH
111411: LD_VAR 0 5
111415: PUSH
111416: LD_INT 1
111418: ARRAY
111419: GREATEREQUAL
111420: PUSH
111421: LD_VAR 0 4
111425: PPUSH
111426: LD_INT 2
111428: PPUSH
111429: CALL_OW 275
111433: PUSH
111434: LD_VAR 0 5
111438: PUSH
111439: LD_INT 2
111441: ARRAY
111442: GREATEREQUAL
111443: AND
111444: PUSH
111445: LD_VAR 0 4
111449: PPUSH
111450: LD_INT 3
111452: PPUSH
111453: CALL_OW 275
111457: PUSH
111458: LD_VAR 0 5
111462: PUSH
111463: LD_INT 3
111465: ARRAY
111466: GREATEREQUAL
111467: AND
111468: ST_TO_ADDR
// end ;
111469: LD_VAR 0 3
111473: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111474: LD_INT 0
111476: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111477: LD_VAR 0 1
111481: PPUSH
111482: LD_VAR 0 2
111486: PPUSH
111487: LD_INT 0
111489: PPUSH
111490: LD_INT 0
111492: PPUSH
111493: LD_INT 1
111495: PPUSH
111496: LD_INT 0
111498: PPUSH
111499: CALL_OW 587
// end ;
111503: LD_VAR 0 3
111507: RET
// export function CenterOnNow ( unit ) ; begin
111508: LD_INT 0
111510: PPUSH
// result := IsInUnit ( unit ) ;
111511: LD_ADDR_VAR 0 2
111515: PUSH
111516: LD_VAR 0 1
111520: PPUSH
111521: CALL_OW 310
111525: ST_TO_ADDR
// if not result then
111526: LD_VAR 0 2
111530: NOT
111531: IFFALSE 111543
// result := unit ;
111533: LD_ADDR_VAR 0 2
111537: PUSH
111538: LD_VAR 0 1
111542: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111543: LD_VAR 0 1
111547: PPUSH
111548: CALL_OW 87
// end ;
111552: LD_VAR 0 2
111556: RET
// export function ComMoveHex ( unit , hex ) ; begin
111557: LD_INT 0
111559: PPUSH
// if not hex then
111560: LD_VAR 0 2
111564: NOT
111565: IFFALSE 111569
// exit ;
111567: GO 111622
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111569: LD_VAR 0 2
111573: PUSH
111574: LD_INT 1
111576: ARRAY
111577: PPUSH
111578: LD_VAR 0 2
111582: PUSH
111583: LD_INT 2
111585: ARRAY
111586: PPUSH
111587: CALL_OW 428
111591: IFFALSE 111595
// exit ;
111593: GO 111622
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111595: LD_VAR 0 1
111599: PPUSH
111600: LD_VAR 0 2
111604: PUSH
111605: LD_INT 1
111607: ARRAY
111608: PPUSH
111609: LD_VAR 0 2
111613: PUSH
111614: LD_INT 2
111616: ARRAY
111617: PPUSH
111618: CALL_OW 111
// end ;
111622: LD_VAR 0 3
111626: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111627: LD_INT 0
111629: PPUSH
111630: PPUSH
111631: PPUSH
// if not unit or not enemy then
111632: LD_VAR 0 1
111636: NOT
111637: PUSH
111638: LD_VAR 0 2
111642: NOT
111643: OR
111644: IFFALSE 111648
// exit ;
111646: GO 111772
// x := GetX ( enemy ) ;
111648: LD_ADDR_VAR 0 4
111652: PUSH
111653: LD_VAR 0 2
111657: PPUSH
111658: CALL_OW 250
111662: ST_TO_ADDR
// y := GetY ( enemy ) ;
111663: LD_ADDR_VAR 0 5
111667: PUSH
111668: LD_VAR 0 2
111672: PPUSH
111673: CALL_OW 251
111677: ST_TO_ADDR
// if ValidHex ( x , y ) then
111678: LD_VAR 0 4
111682: PPUSH
111683: LD_VAR 0 5
111687: PPUSH
111688: CALL_OW 488
111692: IFFALSE 111772
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
111694: LD_VAR 0 2
111698: PPUSH
111699: CALL_OW 247
111703: PUSH
111704: LD_INT 3
111706: PUSH
111707: LD_INT 2
111709: PUSH
111710: EMPTY
111711: LIST
111712: LIST
111713: IN
111714: PUSH
111715: LD_VAR 0 1
111719: PPUSH
111720: CALL_OW 255
111724: PPUSH
111725: LD_VAR 0 2
111729: PPUSH
111730: CALL_OW 292
111734: OR
111735: IFFALSE 111753
// ComAttackUnit ( unit , enemy ) else
111737: LD_VAR 0 1
111741: PPUSH
111742: LD_VAR 0 2
111746: PPUSH
111747: CALL_OW 115
111751: GO 111772
// ComAgressiveMove ( unit , x , y ) ;
111753: LD_VAR 0 1
111757: PPUSH
111758: LD_VAR 0 4
111762: PPUSH
111763: LD_VAR 0 5
111767: PPUSH
111768: CALL_OW 114
// end ;
111772: LD_VAR 0 3
111776: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111777: LD_INT 0
111779: PPUSH
111780: PPUSH
111781: PPUSH
// list := AreaToList ( area , 0 ) ;
111782: LD_ADDR_VAR 0 5
111786: PUSH
111787: LD_VAR 0 1
111791: PPUSH
111792: LD_INT 0
111794: PPUSH
111795: CALL_OW 517
111799: ST_TO_ADDR
// if not list then
111800: LD_VAR 0 5
111804: NOT
111805: IFFALSE 111809
// exit ;
111807: GO 111939
// if all then
111809: LD_VAR 0 2
111813: IFFALSE 111901
// begin for i := 1 to list [ 1 ] do
111815: LD_ADDR_VAR 0 4
111819: PUSH
111820: DOUBLE
111821: LD_INT 1
111823: DEC
111824: ST_TO_ADDR
111825: LD_VAR 0 5
111829: PUSH
111830: LD_INT 1
111832: ARRAY
111833: PUSH
111834: FOR_TO
111835: IFFALSE 111897
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111837: LD_ADDR_VAR 0 3
111841: PUSH
111842: LD_VAR 0 3
111846: PPUSH
111847: LD_VAR 0 3
111851: PUSH
111852: LD_INT 1
111854: PLUS
111855: PPUSH
111856: LD_VAR 0 5
111860: PUSH
111861: LD_INT 1
111863: ARRAY
111864: PUSH
111865: LD_VAR 0 4
111869: ARRAY
111870: PUSH
111871: LD_VAR 0 5
111875: PUSH
111876: LD_INT 2
111878: ARRAY
111879: PUSH
111880: LD_VAR 0 4
111884: ARRAY
111885: PUSH
111886: EMPTY
111887: LIST
111888: LIST
111889: PPUSH
111890: CALL_OW 1
111894: ST_TO_ADDR
111895: GO 111834
111897: POP
111898: POP
// exit ;
111899: GO 111939
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111901: LD_ADDR_VAR 0 3
111905: PUSH
111906: LD_VAR 0 5
111910: PUSH
111911: LD_INT 1
111913: ARRAY
111914: PUSH
111915: LD_INT 1
111917: ARRAY
111918: PUSH
111919: LD_VAR 0 5
111923: PUSH
111924: LD_INT 2
111926: ARRAY
111927: PUSH
111928: LD_INT 1
111930: ARRAY
111931: PUSH
111932: EMPTY
111933: LIST
111934: LIST
111935: PUSH
111936: EMPTY
111937: LIST
111938: ST_TO_ADDR
// end ;
111939: LD_VAR 0 3
111943: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111944: LD_INT 0
111946: PPUSH
111947: PPUSH
// list := AreaToList ( area , 0 ) ;
111948: LD_ADDR_VAR 0 4
111952: PUSH
111953: LD_VAR 0 1
111957: PPUSH
111958: LD_INT 0
111960: PPUSH
111961: CALL_OW 517
111965: ST_TO_ADDR
// if not list then
111966: LD_VAR 0 4
111970: NOT
111971: IFFALSE 111975
// exit ;
111973: GO 112016
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111975: LD_ADDR_VAR 0 3
111979: PUSH
111980: LD_VAR 0 4
111984: PUSH
111985: LD_INT 1
111987: ARRAY
111988: PUSH
111989: LD_INT 1
111991: ARRAY
111992: PUSH
111993: LD_VAR 0 4
111997: PUSH
111998: LD_INT 2
112000: ARRAY
112001: PUSH
112002: LD_INT 1
112004: ARRAY
112005: PUSH
112006: LD_VAR 0 2
112010: PUSH
112011: EMPTY
112012: LIST
112013: LIST
112014: LIST
112015: ST_TO_ADDR
// end ;
112016: LD_VAR 0 3
112020: RET
// export function First ( array ) ; begin
112021: LD_INT 0
112023: PPUSH
// if not array then
112024: LD_VAR 0 1
112028: NOT
112029: IFFALSE 112033
// exit ;
112031: GO 112047
// result := array [ 1 ] ;
112033: LD_ADDR_VAR 0 2
112037: PUSH
112038: LD_VAR 0 1
112042: PUSH
112043: LD_INT 1
112045: ARRAY
112046: ST_TO_ADDR
// end ;
112047: LD_VAR 0 2
112051: RET
// export function Last ( array ) ; begin
112052: LD_INT 0
112054: PPUSH
// if not array then
112055: LD_VAR 0 1
112059: NOT
112060: IFFALSE 112064
// exit ;
112062: GO 112080
// result := array [ array ] ;
112064: LD_ADDR_VAR 0 2
112068: PUSH
112069: LD_VAR 0 1
112073: PUSH
112074: LD_VAR 0 1
112078: ARRAY
112079: ST_TO_ADDR
// end ;
112080: LD_VAR 0 2
112084: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112085: LD_INT 0
112087: PPUSH
112088: PPUSH
// result := [ ] ;
112089: LD_ADDR_VAR 0 5
112093: PUSH
112094: EMPTY
112095: ST_TO_ADDR
// if not array then
112096: LD_VAR 0 1
112100: NOT
112101: IFFALSE 112105
// exit ;
112103: GO 112217
// for i := 1 to array do
112105: LD_ADDR_VAR 0 6
112109: PUSH
112110: DOUBLE
112111: LD_INT 1
112113: DEC
112114: ST_TO_ADDR
112115: LD_VAR 0 1
112119: PUSH
112120: FOR_TO
112121: IFFALSE 112215
// if array [ i ] [ index ] = value then
112123: LD_VAR 0 1
112127: PUSH
112128: LD_VAR 0 6
112132: ARRAY
112133: PUSH
112134: LD_VAR 0 2
112138: ARRAY
112139: PUSH
112140: LD_VAR 0 3
112144: EQUAL
112145: IFFALSE 112213
// begin if indexColumn then
112147: LD_VAR 0 4
112151: IFFALSE 112187
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112153: LD_ADDR_VAR 0 5
112157: PUSH
112158: LD_VAR 0 5
112162: PPUSH
112163: LD_VAR 0 1
112167: PUSH
112168: LD_VAR 0 6
112172: ARRAY
112173: PUSH
112174: LD_VAR 0 4
112178: ARRAY
112179: PPUSH
112180: CALL 107409 0 2
112184: ST_TO_ADDR
112185: GO 112213
// result := Join ( result , array [ i ] ) ;
112187: LD_ADDR_VAR 0 5
112191: PUSH
112192: LD_VAR 0 5
112196: PPUSH
112197: LD_VAR 0 1
112201: PUSH
112202: LD_VAR 0 6
112206: ARRAY
112207: PPUSH
112208: CALL 107409 0 2
112212: ST_TO_ADDR
// end ;
112213: GO 112120
112215: POP
112216: POP
// end ;
112217: LD_VAR 0 5
112221: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112222: LD_INT 0
112224: PPUSH
// if not vehicles or not parkingPoint then
112225: LD_VAR 0 1
112229: NOT
112230: PUSH
112231: LD_VAR 0 2
112235: NOT
112236: OR
112237: IFFALSE 112241
// exit ;
112239: GO 112339
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112241: LD_ADDR_VAR 0 1
112245: PUSH
112246: LD_VAR 0 1
112250: PPUSH
112251: LD_INT 50
112253: PUSH
112254: EMPTY
112255: LIST
112256: PUSH
112257: LD_INT 3
112259: PUSH
112260: LD_INT 92
112262: PUSH
112263: LD_VAR 0 2
112267: PUSH
112268: LD_INT 1
112270: ARRAY
112271: PUSH
112272: LD_VAR 0 2
112276: PUSH
112277: LD_INT 2
112279: ARRAY
112280: PUSH
112281: LD_INT 8
112283: PUSH
112284: EMPTY
112285: LIST
112286: LIST
112287: LIST
112288: LIST
112289: PUSH
112290: EMPTY
112291: LIST
112292: LIST
112293: PUSH
112294: EMPTY
112295: LIST
112296: LIST
112297: PPUSH
112298: CALL_OW 72
112302: ST_TO_ADDR
// if not vehicles then
112303: LD_VAR 0 1
112307: NOT
112308: IFFALSE 112312
// exit ;
112310: GO 112339
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112312: LD_VAR 0 1
112316: PPUSH
112317: LD_VAR 0 2
112321: PUSH
112322: LD_INT 1
112324: ARRAY
112325: PPUSH
112326: LD_VAR 0 2
112330: PUSH
112331: LD_INT 2
112333: ARRAY
112334: PPUSH
112335: CALL_OW 111
// end ;
112339: LD_VAR 0 3
112343: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112344: LD_INT 0
112346: PPUSH
112347: PPUSH
112348: PPUSH
// if not side or not area then
112349: LD_VAR 0 1
112353: NOT
112354: PUSH
112355: LD_VAR 0 2
112359: NOT
112360: OR
112361: IFFALSE 112365
// exit ;
112363: GO 112484
// tmp := AreaToList ( area , 0 ) ;
112365: LD_ADDR_VAR 0 5
112369: PUSH
112370: LD_VAR 0 2
112374: PPUSH
112375: LD_INT 0
112377: PPUSH
112378: CALL_OW 517
112382: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112383: LD_ADDR_VAR 0 4
112387: PUSH
112388: DOUBLE
112389: LD_INT 1
112391: DEC
112392: ST_TO_ADDR
112393: LD_VAR 0 5
112397: PUSH
112398: LD_INT 1
112400: ARRAY
112401: PUSH
112402: FOR_TO
112403: IFFALSE 112482
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112405: LD_VAR 0 5
112409: PUSH
112410: LD_INT 1
112412: ARRAY
112413: PUSH
112414: LD_VAR 0 4
112418: ARRAY
112419: PPUSH
112420: LD_VAR 0 5
112424: PUSH
112425: LD_INT 2
112427: ARRAY
112428: PUSH
112429: LD_VAR 0 4
112433: ARRAY
112434: PPUSH
112435: CALL_OW 351
112439: IFFALSE 112480
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
112441: LD_VAR 0 5
112445: PUSH
112446: LD_INT 1
112448: ARRAY
112449: PUSH
112450: LD_VAR 0 4
112454: ARRAY
112455: PPUSH
112456: LD_VAR 0 5
112460: PUSH
112461: LD_INT 2
112463: ARRAY
112464: PUSH
112465: LD_VAR 0 4
112469: ARRAY
112470: PPUSH
112471: LD_VAR 0 1
112475: PPUSH
112476: CALL_OW 244
// end ;
112480: GO 112402
112482: POP
112483: POP
// end ; end_of_file end_of_file
112484: LD_VAR 0 3
112488: RET
// export globalGameSaveCounter ; every 0 0$1 do
112489: GO 112491
112491: DISABLE
// begin enable ;
112492: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
112493: LD_STRING updateTimer(
112495: PUSH
112496: LD_OWVAR 1
112500: STR
112501: PUSH
112502: LD_STRING );
112504: STR
112505: PPUSH
112506: CALL_OW 559
// end ;
112510: END
// every 0 0$1 do
112511: GO 112513
112513: DISABLE
// begin globalGameSaveCounter := 0 ;
112514: LD_ADDR_EXP 147
112518: PUSH
112519: LD_INT 0
112521: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
112522: LD_STRING setGameSaveCounter(0)
112524: PPUSH
112525: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
112529: LD_STRING initStreamRollete();
112531: PPUSH
112532: CALL_OW 559
// InitStreamMode ;
112536: CALL 113879 0 0
// DefineStreamItems ( false ) ;
112540: LD_INT 0
112542: PPUSH
112543: CALL 114343 0 1
// end ;
112547: END
// export function SOS_MapStart ( ) ; begin
112548: LD_INT 0
112550: PPUSH
// if streamModeActive then
112551: LD_EXP 148
112555: IFFALSE 112564
// DefineStreamItems ( true ) ;
112557: LD_INT 1
112559: PPUSH
112560: CALL 114343 0 1
// UpdateLuaVariables ( ) ;
112564: CALL 112581 0 0
// UpdateFactoryWaypoints ( ) ;
112568: CALL 127212 0 0
// UpdateWarehouseGatheringPoints ( ) ;
112572: CALL 127469 0 0
// end ;
112576: LD_VAR 0 1
112580: RET
// function UpdateLuaVariables ( ) ; begin
112581: LD_INT 0
112583: PPUSH
// if globalGameSaveCounter then
112584: LD_EXP 147
112588: IFFALSE 112622
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
112590: LD_ADDR_EXP 147
112594: PUSH
112595: LD_EXP 147
112599: PPUSH
112600: CALL 108770 0 1
112604: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112605: LD_STRING setGameSaveCounter(
112607: PUSH
112608: LD_EXP 147
112612: STR
112613: PUSH
112614: LD_STRING )
112616: STR
112617: PPUSH
112618: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
112622: LD_STRING setGameDifficulty(
112624: PUSH
112625: LD_OWVAR 67
112629: STR
112630: PUSH
112631: LD_STRING )
112633: STR
112634: PPUSH
112635: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
112639: LD_STRING displayDifficulty(
112641: PUSH
112642: LD_OWVAR 67
112646: STR
112647: PUSH
112648: LD_STRING )
112650: STR
112651: PPUSH
112652: CALL_OW 559
// end ;
112656: LD_VAR 0 1
112660: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112661: LD_INT 0
112663: PPUSH
// if p2 = stream_mode then
112664: LD_VAR 0 2
112668: PUSH
112669: LD_INT 100
112671: EQUAL
112672: IFFALSE 113675
// begin if not StreamModeActive then
112674: LD_EXP 148
112678: NOT
112679: IFFALSE 112689
// StreamModeActive := true ;
112681: LD_ADDR_EXP 148
112685: PUSH
112686: LD_INT 1
112688: ST_TO_ADDR
// if p3 = 0 then
112689: LD_VAR 0 3
112693: PUSH
112694: LD_INT 0
112696: EQUAL
112697: IFFALSE 112703
// InitStreamMode ;
112699: CALL 113879 0 0
// if p3 = 1 then
112703: LD_VAR 0 3
112707: PUSH
112708: LD_INT 1
112710: EQUAL
112711: IFFALSE 112721
// sRocket := true ;
112713: LD_ADDR_EXP 153
112717: PUSH
112718: LD_INT 1
112720: ST_TO_ADDR
// if p3 = 2 then
112721: LD_VAR 0 3
112725: PUSH
112726: LD_INT 2
112728: EQUAL
112729: IFFALSE 112739
// sSpeed := true ;
112731: LD_ADDR_EXP 152
112735: PUSH
112736: LD_INT 1
112738: ST_TO_ADDR
// if p3 = 3 then
112739: LD_VAR 0 3
112743: PUSH
112744: LD_INT 3
112746: EQUAL
112747: IFFALSE 112757
// sEngine := true ;
112749: LD_ADDR_EXP 154
112753: PUSH
112754: LD_INT 1
112756: ST_TO_ADDR
// if p3 = 4 then
112757: LD_VAR 0 3
112761: PUSH
112762: LD_INT 4
112764: EQUAL
112765: IFFALSE 112775
// sSpec := true ;
112767: LD_ADDR_EXP 151
112771: PUSH
112772: LD_INT 1
112774: ST_TO_ADDR
// if p3 = 5 then
112775: LD_VAR 0 3
112779: PUSH
112780: LD_INT 5
112782: EQUAL
112783: IFFALSE 112793
// sLevel := true ;
112785: LD_ADDR_EXP 155
112789: PUSH
112790: LD_INT 1
112792: ST_TO_ADDR
// if p3 = 6 then
112793: LD_VAR 0 3
112797: PUSH
112798: LD_INT 6
112800: EQUAL
112801: IFFALSE 112811
// sArmoury := true ;
112803: LD_ADDR_EXP 156
112807: PUSH
112808: LD_INT 1
112810: ST_TO_ADDR
// if p3 = 7 then
112811: LD_VAR 0 3
112815: PUSH
112816: LD_INT 7
112818: EQUAL
112819: IFFALSE 112829
// sRadar := true ;
112821: LD_ADDR_EXP 157
112825: PUSH
112826: LD_INT 1
112828: ST_TO_ADDR
// if p3 = 8 then
112829: LD_VAR 0 3
112833: PUSH
112834: LD_INT 8
112836: EQUAL
112837: IFFALSE 112847
// sBunker := true ;
112839: LD_ADDR_EXP 158
112843: PUSH
112844: LD_INT 1
112846: ST_TO_ADDR
// if p3 = 9 then
112847: LD_VAR 0 3
112851: PUSH
112852: LD_INT 9
112854: EQUAL
112855: IFFALSE 112865
// sHack := true ;
112857: LD_ADDR_EXP 159
112861: PUSH
112862: LD_INT 1
112864: ST_TO_ADDR
// if p3 = 10 then
112865: LD_VAR 0 3
112869: PUSH
112870: LD_INT 10
112872: EQUAL
112873: IFFALSE 112883
// sFire := true ;
112875: LD_ADDR_EXP 160
112879: PUSH
112880: LD_INT 1
112882: ST_TO_ADDR
// if p3 = 11 then
112883: LD_VAR 0 3
112887: PUSH
112888: LD_INT 11
112890: EQUAL
112891: IFFALSE 112901
// sRefresh := true ;
112893: LD_ADDR_EXP 161
112897: PUSH
112898: LD_INT 1
112900: ST_TO_ADDR
// if p3 = 12 then
112901: LD_VAR 0 3
112905: PUSH
112906: LD_INT 12
112908: EQUAL
112909: IFFALSE 112919
// sExp := true ;
112911: LD_ADDR_EXP 162
112915: PUSH
112916: LD_INT 1
112918: ST_TO_ADDR
// if p3 = 13 then
112919: LD_VAR 0 3
112923: PUSH
112924: LD_INT 13
112926: EQUAL
112927: IFFALSE 112937
// sDepot := true ;
112929: LD_ADDR_EXP 163
112933: PUSH
112934: LD_INT 1
112936: ST_TO_ADDR
// if p3 = 14 then
112937: LD_VAR 0 3
112941: PUSH
112942: LD_INT 14
112944: EQUAL
112945: IFFALSE 112955
// sFlag := true ;
112947: LD_ADDR_EXP 164
112951: PUSH
112952: LD_INT 1
112954: ST_TO_ADDR
// if p3 = 15 then
112955: LD_VAR 0 3
112959: PUSH
112960: LD_INT 15
112962: EQUAL
112963: IFFALSE 112973
// sKamikadze := true ;
112965: LD_ADDR_EXP 172
112969: PUSH
112970: LD_INT 1
112972: ST_TO_ADDR
// if p3 = 16 then
112973: LD_VAR 0 3
112977: PUSH
112978: LD_INT 16
112980: EQUAL
112981: IFFALSE 112991
// sTroll := true ;
112983: LD_ADDR_EXP 173
112987: PUSH
112988: LD_INT 1
112990: ST_TO_ADDR
// if p3 = 17 then
112991: LD_VAR 0 3
112995: PUSH
112996: LD_INT 17
112998: EQUAL
112999: IFFALSE 113009
// sSlow := true ;
113001: LD_ADDR_EXP 174
113005: PUSH
113006: LD_INT 1
113008: ST_TO_ADDR
// if p3 = 18 then
113009: LD_VAR 0 3
113013: PUSH
113014: LD_INT 18
113016: EQUAL
113017: IFFALSE 113027
// sLack := true ;
113019: LD_ADDR_EXP 175
113023: PUSH
113024: LD_INT 1
113026: ST_TO_ADDR
// if p3 = 19 then
113027: LD_VAR 0 3
113031: PUSH
113032: LD_INT 19
113034: EQUAL
113035: IFFALSE 113045
// sTank := true ;
113037: LD_ADDR_EXP 177
113041: PUSH
113042: LD_INT 1
113044: ST_TO_ADDR
// if p3 = 20 then
113045: LD_VAR 0 3
113049: PUSH
113050: LD_INT 20
113052: EQUAL
113053: IFFALSE 113063
// sRemote := true ;
113055: LD_ADDR_EXP 178
113059: PUSH
113060: LD_INT 1
113062: ST_TO_ADDR
// if p3 = 21 then
113063: LD_VAR 0 3
113067: PUSH
113068: LD_INT 21
113070: EQUAL
113071: IFFALSE 113081
// sPowell := true ;
113073: LD_ADDR_EXP 179
113077: PUSH
113078: LD_INT 1
113080: ST_TO_ADDR
// if p3 = 22 then
113081: LD_VAR 0 3
113085: PUSH
113086: LD_INT 22
113088: EQUAL
113089: IFFALSE 113099
// sTeleport := true ;
113091: LD_ADDR_EXP 182
113095: PUSH
113096: LD_INT 1
113098: ST_TO_ADDR
// if p3 = 23 then
113099: LD_VAR 0 3
113103: PUSH
113104: LD_INT 23
113106: EQUAL
113107: IFFALSE 113117
// sOilTower := true ;
113109: LD_ADDR_EXP 184
113113: PUSH
113114: LD_INT 1
113116: ST_TO_ADDR
// if p3 = 24 then
113117: LD_VAR 0 3
113121: PUSH
113122: LD_INT 24
113124: EQUAL
113125: IFFALSE 113135
// sShovel := true ;
113127: LD_ADDR_EXP 185
113131: PUSH
113132: LD_INT 1
113134: ST_TO_ADDR
// if p3 = 25 then
113135: LD_VAR 0 3
113139: PUSH
113140: LD_INT 25
113142: EQUAL
113143: IFFALSE 113153
// sSheik := true ;
113145: LD_ADDR_EXP 186
113149: PUSH
113150: LD_INT 1
113152: ST_TO_ADDR
// if p3 = 26 then
113153: LD_VAR 0 3
113157: PUSH
113158: LD_INT 26
113160: EQUAL
113161: IFFALSE 113171
// sEarthquake := true ;
113163: LD_ADDR_EXP 188
113167: PUSH
113168: LD_INT 1
113170: ST_TO_ADDR
// if p3 = 27 then
113171: LD_VAR 0 3
113175: PUSH
113176: LD_INT 27
113178: EQUAL
113179: IFFALSE 113189
// sAI := true ;
113181: LD_ADDR_EXP 189
113185: PUSH
113186: LD_INT 1
113188: ST_TO_ADDR
// if p3 = 28 then
113189: LD_VAR 0 3
113193: PUSH
113194: LD_INT 28
113196: EQUAL
113197: IFFALSE 113207
// sCargo := true ;
113199: LD_ADDR_EXP 192
113203: PUSH
113204: LD_INT 1
113206: ST_TO_ADDR
// if p3 = 29 then
113207: LD_VAR 0 3
113211: PUSH
113212: LD_INT 29
113214: EQUAL
113215: IFFALSE 113225
// sDLaser := true ;
113217: LD_ADDR_EXP 193
113221: PUSH
113222: LD_INT 1
113224: ST_TO_ADDR
// if p3 = 30 then
113225: LD_VAR 0 3
113229: PUSH
113230: LD_INT 30
113232: EQUAL
113233: IFFALSE 113243
// sExchange := true ;
113235: LD_ADDR_EXP 194
113239: PUSH
113240: LD_INT 1
113242: ST_TO_ADDR
// if p3 = 31 then
113243: LD_VAR 0 3
113247: PUSH
113248: LD_INT 31
113250: EQUAL
113251: IFFALSE 113261
// sFac := true ;
113253: LD_ADDR_EXP 195
113257: PUSH
113258: LD_INT 1
113260: ST_TO_ADDR
// if p3 = 32 then
113261: LD_VAR 0 3
113265: PUSH
113266: LD_INT 32
113268: EQUAL
113269: IFFALSE 113279
// sPower := true ;
113271: LD_ADDR_EXP 196
113275: PUSH
113276: LD_INT 1
113278: ST_TO_ADDR
// if p3 = 33 then
113279: LD_VAR 0 3
113283: PUSH
113284: LD_INT 33
113286: EQUAL
113287: IFFALSE 113297
// sRandom := true ;
113289: LD_ADDR_EXP 197
113293: PUSH
113294: LD_INT 1
113296: ST_TO_ADDR
// if p3 = 34 then
113297: LD_VAR 0 3
113301: PUSH
113302: LD_INT 34
113304: EQUAL
113305: IFFALSE 113315
// sShield := true ;
113307: LD_ADDR_EXP 198
113311: PUSH
113312: LD_INT 1
113314: ST_TO_ADDR
// if p3 = 35 then
113315: LD_VAR 0 3
113319: PUSH
113320: LD_INT 35
113322: EQUAL
113323: IFFALSE 113333
// sTime := true ;
113325: LD_ADDR_EXP 199
113329: PUSH
113330: LD_INT 1
113332: ST_TO_ADDR
// if p3 = 36 then
113333: LD_VAR 0 3
113337: PUSH
113338: LD_INT 36
113340: EQUAL
113341: IFFALSE 113351
// sTools := true ;
113343: LD_ADDR_EXP 200
113347: PUSH
113348: LD_INT 1
113350: ST_TO_ADDR
// if p3 = 101 then
113351: LD_VAR 0 3
113355: PUSH
113356: LD_INT 101
113358: EQUAL
113359: IFFALSE 113369
// sSold := true ;
113361: LD_ADDR_EXP 165
113365: PUSH
113366: LD_INT 1
113368: ST_TO_ADDR
// if p3 = 102 then
113369: LD_VAR 0 3
113373: PUSH
113374: LD_INT 102
113376: EQUAL
113377: IFFALSE 113387
// sDiff := true ;
113379: LD_ADDR_EXP 166
113383: PUSH
113384: LD_INT 1
113386: ST_TO_ADDR
// if p3 = 103 then
113387: LD_VAR 0 3
113391: PUSH
113392: LD_INT 103
113394: EQUAL
113395: IFFALSE 113405
// sFog := true ;
113397: LD_ADDR_EXP 169
113401: PUSH
113402: LD_INT 1
113404: ST_TO_ADDR
// if p3 = 104 then
113405: LD_VAR 0 3
113409: PUSH
113410: LD_INT 104
113412: EQUAL
113413: IFFALSE 113423
// sReset := true ;
113415: LD_ADDR_EXP 170
113419: PUSH
113420: LD_INT 1
113422: ST_TO_ADDR
// if p3 = 105 then
113423: LD_VAR 0 3
113427: PUSH
113428: LD_INT 105
113430: EQUAL
113431: IFFALSE 113441
// sSun := true ;
113433: LD_ADDR_EXP 171
113437: PUSH
113438: LD_INT 1
113440: ST_TO_ADDR
// if p3 = 106 then
113441: LD_VAR 0 3
113445: PUSH
113446: LD_INT 106
113448: EQUAL
113449: IFFALSE 113459
// sTiger := true ;
113451: LD_ADDR_EXP 167
113455: PUSH
113456: LD_INT 1
113458: ST_TO_ADDR
// if p3 = 107 then
113459: LD_VAR 0 3
113463: PUSH
113464: LD_INT 107
113466: EQUAL
113467: IFFALSE 113477
// sBomb := true ;
113469: LD_ADDR_EXP 168
113473: PUSH
113474: LD_INT 1
113476: ST_TO_ADDR
// if p3 = 108 then
113477: LD_VAR 0 3
113481: PUSH
113482: LD_INT 108
113484: EQUAL
113485: IFFALSE 113495
// sWound := true ;
113487: LD_ADDR_EXP 176
113491: PUSH
113492: LD_INT 1
113494: ST_TO_ADDR
// if p3 = 109 then
113495: LD_VAR 0 3
113499: PUSH
113500: LD_INT 109
113502: EQUAL
113503: IFFALSE 113513
// sBetray := true ;
113505: LD_ADDR_EXP 180
113509: PUSH
113510: LD_INT 1
113512: ST_TO_ADDR
// if p3 = 110 then
113513: LD_VAR 0 3
113517: PUSH
113518: LD_INT 110
113520: EQUAL
113521: IFFALSE 113531
// sContamin := true ;
113523: LD_ADDR_EXP 181
113527: PUSH
113528: LD_INT 1
113530: ST_TO_ADDR
// if p3 = 111 then
113531: LD_VAR 0 3
113535: PUSH
113536: LD_INT 111
113538: EQUAL
113539: IFFALSE 113549
// sOil := true ;
113541: LD_ADDR_EXP 183
113545: PUSH
113546: LD_INT 1
113548: ST_TO_ADDR
// if p3 = 112 then
113549: LD_VAR 0 3
113553: PUSH
113554: LD_INT 112
113556: EQUAL
113557: IFFALSE 113567
// sStu := true ;
113559: LD_ADDR_EXP 187
113563: PUSH
113564: LD_INT 1
113566: ST_TO_ADDR
// if p3 = 113 then
113567: LD_VAR 0 3
113571: PUSH
113572: LD_INT 113
113574: EQUAL
113575: IFFALSE 113585
// sBazooka := true ;
113577: LD_ADDR_EXP 190
113581: PUSH
113582: LD_INT 1
113584: ST_TO_ADDR
// if p3 = 114 then
113585: LD_VAR 0 3
113589: PUSH
113590: LD_INT 114
113592: EQUAL
113593: IFFALSE 113603
// sMortar := true ;
113595: LD_ADDR_EXP 191
113599: PUSH
113600: LD_INT 1
113602: ST_TO_ADDR
// if p3 = 115 then
113603: LD_VAR 0 3
113607: PUSH
113608: LD_INT 115
113610: EQUAL
113611: IFFALSE 113621
// sRanger := true ;
113613: LD_ADDR_EXP 201
113617: PUSH
113618: LD_INT 1
113620: ST_TO_ADDR
// if p3 = 116 then
113621: LD_VAR 0 3
113625: PUSH
113626: LD_INT 116
113628: EQUAL
113629: IFFALSE 113639
// sComputer := true ;
113631: LD_ADDR_EXP 202
113635: PUSH
113636: LD_INT 1
113638: ST_TO_ADDR
// if p3 = 117 then
113639: LD_VAR 0 3
113643: PUSH
113644: LD_INT 117
113646: EQUAL
113647: IFFALSE 113657
// s30 := true ;
113649: LD_ADDR_EXP 203
113653: PUSH
113654: LD_INT 1
113656: ST_TO_ADDR
// if p3 = 118 then
113657: LD_VAR 0 3
113661: PUSH
113662: LD_INT 118
113664: EQUAL
113665: IFFALSE 113675
// s60 := true ;
113667: LD_ADDR_EXP 204
113671: PUSH
113672: LD_INT 1
113674: ST_TO_ADDR
// end ; if p2 = hack_mode then
113675: LD_VAR 0 2
113679: PUSH
113680: LD_INT 101
113682: EQUAL
113683: IFFALSE 113811
// begin case p3 of 1 :
113685: LD_VAR 0 3
113689: PUSH
113690: LD_INT 1
113692: DOUBLE
113693: EQUAL
113694: IFTRUE 113698
113696: GO 113705
113698: POP
// hHackUnlimitedResources ; 2 :
113699: CALL 125958 0 0
113703: GO 113811
113705: LD_INT 2
113707: DOUBLE
113708: EQUAL
113709: IFTRUE 113713
113711: GO 113720
113713: POP
// hHackSetLevel10 ; 3 :
113714: CALL 126091 0 0
113718: GO 113811
113720: LD_INT 3
113722: DOUBLE
113723: EQUAL
113724: IFTRUE 113728
113726: GO 113735
113728: POP
// hHackSetLevel10YourUnits ; 4 :
113729: CALL 126176 0 0
113733: GO 113811
113735: LD_INT 4
113737: DOUBLE
113738: EQUAL
113739: IFTRUE 113743
113741: GO 113750
113743: POP
// hHackInvincible ; 5 :
113744: CALL 126624 0 0
113748: GO 113811
113750: LD_INT 5
113752: DOUBLE
113753: EQUAL
113754: IFTRUE 113758
113756: GO 113765
113758: POP
// hHackInvisible ; 6 :
113759: CALL 126735 0 0
113763: GO 113811
113765: LD_INT 6
113767: DOUBLE
113768: EQUAL
113769: IFTRUE 113773
113771: GO 113780
113773: POP
// hHackChangeYourSide ; 7 :
113774: CALL 126792 0 0
113778: GO 113811
113780: LD_INT 7
113782: DOUBLE
113783: EQUAL
113784: IFTRUE 113788
113786: GO 113795
113788: POP
// hHackChangeUnitSide ; 8 :
113789: CALL 126834 0 0
113793: GO 113811
113795: LD_INT 8
113797: DOUBLE
113798: EQUAL
113799: IFTRUE 113803
113801: GO 113810
113803: POP
// hHackFog ; end ;
113804: CALL 126935 0 0
113808: GO 113811
113810: POP
// end ; if p2 = game_save_mode then
113811: LD_VAR 0 2
113815: PUSH
113816: LD_INT 102
113818: EQUAL
113819: IFFALSE 113874
// begin if p3 = 1 then
113821: LD_VAR 0 3
113825: PUSH
113826: LD_INT 1
113828: EQUAL
113829: IFFALSE 113841
// globalGameSaveCounter := p4 ;
113831: LD_ADDR_EXP 147
113835: PUSH
113836: LD_VAR 0 4
113840: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113841: LD_VAR 0 3
113845: PUSH
113846: LD_INT 2
113848: EQUAL
113849: PUSH
113850: LD_EXP 147
113854: AND
113855: IFFALSE 113874
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113857: LD_STRING setGameSaveCounter(
113859: PUSH
113860: LD_EXP 147
113864: STR
113865: PUSH
113866: LD_STRING )
113868: STR
113869: PPUSH
113870: CALL_OW 559
// end ; end ;
113874: LD_VAR 0 7
113878: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113879: LD_INT 0
113881: PPUSH
// streamModeActive := false ;
113882: LD_ADDR_EXP 148
113886: PUSH
113887: LD_INT 0
113889: ST_TO_ADDR
// normalCounter := 36 ;
113890: LD_ADDR_EXP 149
113894: PUSH
113895: LD_INT 36
113897: ST_TO_ADDR
// hardcoreCounter := 18 ;
113898: LD_ADDR_EXP 150
113902: PUSH
113903: LD_INT 18
113905: ST_TO_ADDR
// sRocket := false ;
113906: LD_ADDR_EXP 153
113910: PUSH
113911: LD_INT 0
113913: ST_TO_ADDR
// sSpeed := false ;
113914: LD_ADDR_EXP 152
113918: PUSH
113919: LD_INT 0
113921: ST_TO_ADDR
// sEngine := false ;
113922: LD_ADDR_EXP 154
113926: PUSH
113927: LD_INT 0
113929: ST_TO_ADDR
// sSpec := false ;
113930: LD_ADDR_EXP 151
113934: PUSH
113935: LD_INT 0
113937: ST_TO_ADDR
// sLevel := false ;
113938: LD_ADDR_EXP 155
113942: PUSH
113943: LD_INT 0
113945: ST_TO_ADDR
// sArmoury := false ;
113946: LD_ADDR_EXP 156
113950: PUSH
113951: LD_INT 0
113953: ST_TO_ADDR
// sRadar := false ;
113954: LD_ADDR_EXP 157
113958: PUSH
113959: LD_INT 0
113961: ST_TO_ADDR
// sBunker := false ;
113962: LD_ADDR_EXP 158
113966: PUSH
113967: LD_INT 0
113969: ST_TO_ADDR
// sHack := false ;
113970: LD_ADDR_EXP 159
113974: PUSH
113975: LD_INT 0
113977: ST_TO_ADDR
// sFire := false ;
113978: LD_ADDR_EXP 160
113982: PUSH
113983: LD_INT 0
113985: ST_TO_ADDR
// sRefresh := false ;
113986: LD_ADDR_EXP 161
113990: PUSH
113991: LD_INT 0
113993: ST_TO_ADDR
// sExp := false ;
113994: LD_ADDR_EXP 162
113998: PUSH
113999: LD_INT 0
114001: ST_TO_ADDR
// sDepot := false ;
114002: LD_ADDR_EXP 163
114006: PUSH
114007: LD_INT 0
114009: ST_TO_ADDR
// sFlag := false ;
114010: LD_ADDR_EXP 164
114014: PUSH
114015: LD_INT 0
114017: ST_TO_ADDR
// sKamikadze := false ;
114018: LD_ADDR_EXP 172
114022: PUSH
114023: LD_INT 0
114025: ST_TO_ADDR
// sTroll := false ;
114026: LD_ADDR_EXP 173
114030: PUSH
114031: LD_INT 0
114033: ST_TO_ADDR
// sSlow := false ;
114034: LD_ADDR_EXP 174
114038: PUSH
114039: LD_INT 0
114041: ST_TO_ADDR
// sLack := false ;
114042: LD_ADDR_EXP 175
114046: PUSH
114047: LD_INT 0
114049: ST_TO_ADDR
// sTank := false ;
114050: LD_ADDR_EXP 177
114054: PUSH
114055: LD_INT 0
114057: ST_TO_ADDR
// sRemote := false ;
114058: LD_ADDR_EXP 178
114062: PUSH
114063: LD_INT 0
114065: ST_TO_ADDR
// sPowell := false ;
114066: LD_ADDR_EXP 179
114070: PUSH
114071: LD_INT 0
114073: ST_TO_ADDR
// sTeleport := false ;
114074: LD_ADDR_EXP 182
114078: PUSH
114079: LD_INT 0
114081: ST_TO_ADDR
// sOilTower := false ;
114082: LD_ADDR_EXP 184
114086: PUSH
114087: LD_INT 0
114089: ST_TO_ADDR
// sShovel := false ;
114090: LD_ADDR_EXP 185
114094: PUSH
114095: LD_INT 0
114097: ST_TO_ADDR
// sSheik := false ;
114098: LD_ADDR_EXP 186
114102: PUSH
114103: LD_INT 0
114105: ST_TO_ADDR
// sEarthquake := false ;
114106: LD_ADDR_EXP 188
114110: PUSH
114111: LD_INT 0
114113: ST_TO_ADDR
// sAI := false ;
114114: LD_ADDR_EXP 189
114118: PUSH
114119: LD_INT 0
114121: ST_TO_ADDR
// sCargo := false ;
114122: LD_ADDR_EXP 192
114126: PUSH
114127: LD_INT 0
114129: ST_TO_ADDR
// sDLaser := false ;
114130: LD_ADDR_EXP 193
114134: PUSH
114135: LD_INT 0
114137: ST_TO_ADDR
// sExchange := false ;
114138: LD_ADDR_EXP 194
114142: PUSH
114143: LD_INT 0
114145: ST_TO_ADDR
// sFac := false ;
114146: LD_ADDR_EXP 195
114150: PUSH
114151: LD_INT 0
114153: ST_TO_ADDR
// sPower := false ;
114154: LD_ADDR_EXP 196
114158: PUSH
114159: LD_INT 0
114161: ST_TO_ADDR
// sRandom := false ;
114162: LD_ADDR_EXP 197
114166: PUSH
114167: LD_INT 0
114169: ST_TO_ADDR
// sShield := false ;
114170: LD_ADDR_EXP 198
114174: PUSH
114175: LD_INT 0
114177: ST_TO_ADDR
// sTime := false ;
114178: LD_ADDR_EXP 199
114182: PUSH
114183: LD_INT 0
114185: ST_TO_ADDR
// sTools := false ;
114186: LD_ADDR_EXP 200
114190: PUSH
114191: LD_INT 0
114193: ST_TO_ADDR
// sSold := false ;
114194: LD_ADDR_EXP 165
114198: PUSH
114199: LD_INT 0
114201: ST_TO_ADDR
// sDiff := false ;
114202: LD_ADDR_EXP 166
114206: PUSH
114207: LD_INT 0
114209: ST_TO_ADDR
// sFog := false ;
114210: LD_ADDR_EXP 169
114214: PUSH
114215: LD_INT 0
114217: ST_TO_ADDR
// sReset := false ;
114218: LD_ADDR_EXP 170
114222: PUSH
114223: LD_INT 0
114225: ST_TO_ADDR
// sSun := false ;
114226: LD_ADDR_EXP 171
114230: PUSH
114231: LD_INT 0
114233: ST_TO_ADDR
// sTiger := false ;
114234: LD_ADDR_EXP 167
114238: PUSH
114239: LD_INT 0
114241: ST_TO_ADDR
// sBomb := false ;
114242: LD_ADDR_EXP 168
114246: PUSH
114247: LD_INT 0
114249: ST_TO_ADDR
// sWound := false ;
114250: LD_ADDR_EXP 176
114254: PUSH
114255: LD_INT 0
114257: ST_TO_ADDR
// sBetray := false ;
114258: LD_ADDR_EXP 180
114262: PUSH
114263: LD_INT 0
114265: ST_TO_ADDR
// sContamin := false ;
114266: LD_ADDR_EXP 181
114270: PUSH
114271: LD_INT 0
114273: ST_TO_ADDR
// sOil := false ;
114274: LD_ADDR_EXP 183
114278: PUSH
114279: LD_INT 0
114281: ST_TO_ADDR
// sStu := false ;
114282: LD_ADDR_EXP 187
114286: PUSH
114287: LD_INT 0
114289: ST_TO_ADDR
// sBazooka := false ;
114290: LD_ADDR_EXP 190
114294: PUSH
114295: LD_INT 0
114297: ST_TO_ADDR
// sMortar := false ;
114298: LD_ADDR_EXP 191
114302: PUSH
114303: LD_INT 0
114305: ST_TO_ADDR
// sRanger := false ;
114306: LD_ADDR_EXP 201
114310: PUSH
114311: LD_INT 0
114313: ST_TO_ADDR
// sComputer := false ;
114314: LD_ADDR_EXP 202
114318: PUSH
114319: LD_INT 0
114321: ST_TO_ADDR
// s30 := false ;
114322: LD_ADDR_EXP 203
114326: PUSH
114327: LD_INT 0
114329: ST_TO_ADDR
// s60 := false ;
114330: LD_ADDR_EXP 204
114334: PUSH
114335: LD_INT 0
114337: ST_TO_ADDR
// end ;
114338: LD_VAR 0 1
114342: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114343: LD_INT 0
114345: PPUSH
114346: PPUSH
114347: PPUSH
114348: PPUSH
114349: PPUSH
114350: PPUSH
114351: PPUSH
// result := [ ] ;
114352: LD_ADDR_VAR 0 2
114356: PUSH
114357: EMPTY
114358: ST_TO_ADDR
// if campaign_id = 1 then
114359: LD_OWVAR 69
114363: PUSH
114364: LD_INT 1
114366: EQUAL
114367: IFFALSE 117533
// begin case mission_number of 1 :
114369: LD_OWVAR 70
114373: PUSH
114374: LD_INT 1
114376: DOUBLE
114377: EQUAL
114378: IFTRUE 114382
114380: GO 114458
114382: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114383: LD_ADDR_VAR 0 2
114387: PUSH
114388: LD_INT 2
114390: PUSH
114391: LD_INT 4
114393: PUSH
114394: LD_INT 11
114396: PUSH
114397: LD_INT 12
114399: PUSH
114400: LD_INT 15
114402: PUSH
114403: LD_INT 16
114405: PUSH
114406: LD_INT 22
114408: PUSH
114409: LD_INT 23
114411: PUSH
114412: LD_INT 26
114414: PUSH
114415: EMPTY
114416: LIST
114417: LIST
114418: LIST
114419: LIST
114420: LIST
114421: LIST
114422: LIST
114423: LIST
114424: LIST
114425: PUSH
114426: LD_INT 101
114428: PUSH
114429: LD_INT 102
114431: PUSH
114432: LD_INT 106
114434: PUSH
114435: LD_INT 116
114437: PUSH
114438: LD_INT 117
114440: PUSH
114441: LD_INT 118
114443: PUSH
114444: EMPTY
114445: LIST
114446: LIST
114447: LIST
114448: LIST
114449: LIST
114450: LIST
114451: PUSH
114452: EMPTY
114453: LIST
114454: LIST
114455: ST_TO_ADDR
114456: GO 117531
114458: LD_INT 2
114460: DOUBLE
114461: EQUAL
114462: IFTRUE 114466
114464: GO 114550
114466: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
114467: LD_ADDR_VAR 0 2
114471: PUSH
114472: LD_INT 2
114474: PUSH
114475: LD_INT 4
114477: PUSH
114478: LD_INT 11
114480: PUSH
114481: LD_INT 12
114483: PUSH
114484: LD_INT 15
114486: PUSH
114487: LD_INT 16
114489: PUSH
114490: LD_INT 22
114492: PUSH
114493: LD_INT 23
114495: PUSH
114496: LD_INT 26
114498: PUSH
114499: EMPTY
114500: LIST
114501: LIST
114502: LIST
114503: LIST
114504: LIST
114505: LIST
114506: LIST
114507: LIST
114508: LIST
114509: PUSH
114510: LD_INT 101
114512: PUSH
114513: LD_INT 102
114515: PUSH
114516: LD_INT 105
114518: PUSH
114519: LD_INT 106
114521: PUSH
114522: LD_INT 108
114524: PUSH
114525: LD_INT 116
114527: PUSH
114528: LD_INT 117
114530: PUSH
114531: LD_INT 118
114533: PUSH
114534: EMPTY
114535: LIST
114536: LIST
114537: LIST
114538: LIST
114539: LIST
114540: LIST
114541: LIST
114542: LIST
114543: PUSH
114544: EMPTY
114545: LIST
114546: LIST
114547: ST_TO_ADDR
114548: GO 117531
114550: LD_INT 3
114552: DOUBLE
114553: EQUAL
114554: IFTRUE 114558
114556: GO 114646
114558: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
114559: LD_ADDR_VAR 0 2
114563: PUSH
114564: LD_INT 2
114566: PUSH
114567: LD_INT 4
114569: PUSH
114570: LD_INT 5
114572: PUSH
114573: LD_INT 11
114575: PUSH
114576: LD_INT 12
114578: PUSH
114579: LD_INT 15
114581: PUSH
114582: LD_INT 16
114584: PUSH
114585: LD_INT 22
114587: PUSH
114588: LD_INT 26
114590: PUSH
114591: LD_INT 36
114593: PUSH
114594: EMPTY
114595: LIST
114596: LIST
114597: LIST
114598: LIST
114599: LIST
114600: LIST
114601: LIST
114602: LIST
114603: LIST
114604: LIST
114605: PUSH
114606: LD_INT 101
114608: PUSH
114609: LD_INT 102
114611: PUSH
114612: LD_INT 105
114614: PUSH
114615: LD_INT 106
114617: PUSH
114618: LD_INT 108
114620: PUSH
114621: LD_INT 116
114623: PUSH
114624: LD_INT 117
114626: PUSH
114627: LD_INT 118
114629: PUSH
114630: EMPTY
114631: LIST
114632: LIST
114633: LIST
114634: LIST
114635: LIST
114636: LIST
114637: LIST
114638: LIST
114639: PUSH
114640: EMPTY
114641: LIST
114642: LIST
114643: ST_TO_ADDR
114644: GO 117531
114646: LD_INT 4
114648: DOUBLE
114649: EQUAL
114650: IFTRUE 114654
114652: GO 114750
114654: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
114655: LD_ADDR_VAR 0 2
114659: PUSH
114660: LD_INT 2
114662: PUSH
114663: LD_INT 4
114665: PUSH
114666: LD_INT 5
114668: PUSH
114669: LD_INT 8
114671: PUSH
114672: LD_INT 11
114674: PUSH
114675: LD_INT 12
114677: PUSH
114678: LD_INT 15
114680: PUSH
114681: LD_INT 16
114683: PUSH
114684: LD_INT 22
114686: PUSH
114687: LD_INT 23
114689: PUSH
114690: LD_INT 26
114692: PUSH
114693: LD_INT 36
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: LIST
114700: LIST
114701: LIST
114702: LIST
114703: LIST
114704: LIST
114705: LIST
114706: LIST
114707: LIST
114708: LIST
114709: PUSH
114710: LD_INT 101
114712: PUSH
114713: LD_INT 102
114715: PUSH
114716: LD_INT 105
114718: PUSH
114719: LD_INT 106
114721: PUSH
114722: LD_INT 108
114724: PUSH
114725: LD_INT 116
114727: PUSH
114728: LD_INT 117
114730: PUSH
114731: LD_INT 118
114733: PUSH
114734: EMPTY
114735: LIST
114736: LIST
114737: LIST
114738: LIST
114739: LIST
114740: LIST
114741: LIST
114742: LIST
114743: PUSH
114744: EMPTY
114745: LIST
114746: LIST
114747: ST_TO_ADDR
114748: GO 117531
114750: LD_INT 5
114752: DOUBLE
114753: EQUAL
114754: IFTRUE 114758
114756: GO 114870
114758: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
114759: LD_ADDR_VAR 0 2
114763: PUSH
114764: LD_INT 2
114766: PUSH
114767: LD_INT 4
114769: PUSH
114770: LD_INT 5
114772: PUSH
114773: LD_INT 6
114775: PUSH
114776: LD_INT 8
114778: PUSH
114779: LD_INT 11
114781: PUSH
114782: LD_INT 12
114784: PUSH
114785: LD_INT 15
114787: PUSH
114788: LD_INT 16
114790: PUSH
114791: LD_INT 22
114793: PUSH
114794: LD_INT 23
114796: PUSH
114797: LD_INT 25
114799: PUSH
114800: LD_INT 26
114802: PUSH
114803: LD_INT 36
114805: PUSH
114806: EMPTY
114807: LIST
114808: LIST
114809: LIST
114810: LIST
114811: LIST
114812: LIST
114813: LIST
114814: LIST
114815: LIST
114816: LIST
114817: LIST
114818: LIST
114819: LIST
114820: LIST
114821: PUSH
114822: LD_INT 101
114824: PUSH
114825: LD_INT 102
114827: PUSH
114828: LD_INT 105
114830: PUSH
114831: LD_INT 106
114833: PUSH
114834: LD_INT 108
114836: PUSH
114837: LD_INT 109
114839: PUSH
114840: LD_INT 112
114842: PUSH
114843: LD_INT 116
114845: PUSH
114846: LD_INT 117
114848: PUSH
114849: LD_INT 118
114851: PUSH
114852: EMPTY
114853: LIST
114854: LIST
114855: LIST
114856: LIST
114857: LIST
114858: LIST
114859: LIST
114860: LIST
114861: LIST
114862: LIST
114863: PUSH
114864: EMPTY
114865: LIST
114866: LIST
114867: ST_TO_ADDR
114868: GO 117531
114870: LD_INT 6
114872: DOUBLE
114873: EQUAL
114874: IFTRUE 114878
114876: GO 115010
114878: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114879: LD_ADDR_VAR 0 2
114883: PUSH
114884: LD_INT 2
114886: PUSH
114887: LD_INT 4
114889: PUSH
114890: LD_INT 5
114892: PUSH
114893: LD_INT 6
114895: PUSH
114896: LD_INT 8
114898: PUSH
114899: LD_INT 11
114901: PUSH
114902: LD_INT 12
114904: PUSH
114905: LD_INT 15
114907: PUSH
114908: LD_INT 16
114910: PUSH
114911: LD_INT 20
114913: PUSH
114914: LD_INT 21
114916: PUSH
114917: LD_INT 22
114919: PUSH
114920: LD_INT 23
114922: PUSH
114923: LD_INT 25
114925: PUSH
114926: LD_INT 26
114928: PUSH
114929: LD_INT 30
114931: PUSH
114932: LD_INT 31
114934: PUSH
114935: LD_INT 32
114937: PUSH
114938: LD_INT 36
114940: PUSH
114941: EMPTY
114942: LIST
114943: LIST
114944: LIST
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: LIST
114951: LIST
114952: LIST
114953: LIST
114954: LIST
114955: LIST
114956: LIST
114957: LIST
114958: LIST
114959: LIST
114960: LIST
114961: PUSH
114962: LD_INT 101
114964: PUSH
114965: LD_INT 102
114967: PUSH
114968: LD_INT 105
114970: PUSH
114971: LD_INT 106
114973: PUSH
114974: LD_INT 108
114976: PUSH
114977: LD_INT 109
114979: PUSH
114980: LD_INT 112
114982: PUSH
114983: LD_INT 116
114985: PUSH
114986: LD_INT 117
114988: PUSH
114989: LD_INT 118
114991: PUSH
114992: EMPTY
114993: LIST
114994: LIST
114995: LIST
114996: LIST
114997: LIST
114998: LIST
114999: LIST
115000: LIST
115001: LIST
115002: LIST
115003: PUSH
115004: EMPTY
115005: LIST
115006: LIST
115007: ST_TO_ADDR
115008: GO 117531
115010: LD_INT 7
115012: DOUBLE
115013: EQUAL
115014: IFTRUE 115018
115016: GO 115130
115018: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115019: LD_ADDR_VAR 0 2
115023: PUSH
115024: LD_INT 2
115026: PUSH
115027: LD_INT 4
115029: PUSH
115030: LD_INT 5
115032: PUSH
115033: LD_INT 7
115035: PUSH
115036: LD_INT 11
115038: PUSH
115039: LD_INT 12
115041: PUSH
115042: LD_INT 15
115044: PUSH
115045: LD_INT 16
115047: PUSH
115048: LD_INT 20
115050: PUSH
115051: LD_INT 21
115053: PUSH
115054: LD_INT 22
115056: PUSH
115057: LD_INT 23
115059: PUSH
115060: LD_INT 25
115062: PUSH
115063: LD_INT 26
115065: PUSH
115066: EMPTY
115067: LIST
115068: LIST
115069: LIST
115070: LIST
115071: LIST
115072: LIST
115073: LIST
115074: LIST
115075: LIST
115076: LIST
115077: LIST
115078: LIST
115079: LIST
115080: LIST
115081: PUSH
115082: LD_INT 101
115084: PUSH
115085: LD_INT 102
115087: PUSH
115088: LD_INT 103
115090: PUSH
115091: LD_INT 105
115093: PUSH
115094: LD_INT 106
115096: PUSH
115097: LD_INT 108
115099: PUSH
115100: LD_INT 112
115102: PUSH
115103: LD_INT 116
115105: PUSH
115106: LD_INT 117
115108: PUSH
115109: LD_INT 118
115111: PUSH
115112: EMPTY
115113: LIST
115114: LIST
115115: LIST
115116: LIST
115117: LIST
115118: LIST
115119: LIST
115120: LIST
115121: LIST
115122: LIST
115123: PUSH
115124: EMPTY
115125: LIST
115126: LIST
115127: ST_TO_ADDR
115128: GO 117531
115130: LD_INT 8
115132: DOUBLE
115133: EQUAL
115134: IFTRUE 115138
115136: GO 115278
115138: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115139: LD_ADDR_VAR 0 2
115143: PUSH
115144: LD_INT 2
115146: PUSH
115147: LD_INT 4
115149: PUSH
115150: LD_INT 5
115152: PUSH
115153: LD_INT 6
115155: PUSH
115156: LD_INT 7
115158: PUSH
115159: LD_INT 8
115161: PUSH
115162: LD_INT 11
115164: PUSH
115165: LD_INT 12
115167: PUSH
115168: LD_INT 15
115170: PUSH
115171: LD_INT 16
115173: PUSH
115174: LD_INT 20
115176: PUSH
115177: LD_INT 21
115179: PUSH
115180: LD_INT 22
115182: PUSH
115183: LD_INT 23
115185: PUSH
115186: LD_INT 25
115188: PUSH
115189: LD_INT 26
115191: PUSH
115192: LD_INT 30
115194: PUSH
115195: LD_INT 31
115197: PUSH
115198: LD_INT 32
115200: PUSH
115201: LD_INT 36
115203: PUSH
115204: EMPTY
115205: LIST
115206: LIST
115207: LIST
115208: LIST
115209: LIST
115210: LIST
115211: LIST
115212: LIST
115213: LIST
115214: LIST
115215: LIST
115216: LIST
115217: LIST
115218: LIST
115219: LIST
115220: LIST
115221: LIST
115222: LIST
115223: LIST
115224: LIST
115225: PUSH
115226: LD_INT 101
115228: PUSH
115229: LD_INT 102
115231: PUSH
115232: LD_INT 103
115234: PUSH
115235: LD_INT 105
115237: PUSH
115238: LD_INT 106
115240: PUSH
115241: LD_INT 108
115243: PUSH
115244: LD_INT 109
115246: PUSH
115247: LD_INT 112
115249: PUSH
115250: LD_INT 116
115252: PUSH
115253: LD_INT 117
115255: PUSH
115256: LD_INT 118
115258: PUSH
115259: EMPTY
115260: LIST
115261: LIST
115262: LIST
115263: LIST
115264: LIST
115265: LIST
115266: LIST
115267: LIST
115268: LIST
115269: LIST
115270: LIST
115271: PUSH
115272: EMPTY
115273: LIST
115274: LIST
115275: ST_TO_ADDR
115276: GO 117531
115278: LD_INT 9
115280: DOUBLE
115281: EQUAL
115282: IFTRUE 115286
115284: GO 115434
115286: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115287: LD_ADDR_VAR 0 2
115291: PUSH
115292: LD_INT 2
115294: PUSH
115295: LD_INT 4
115297: PUSH
115298: LD_INT 5
115300: PUSH
115301: LD_INT 6
115303: PUSH
115304: LD_INT 7
115306: PUSH
115307: LD_INT 8
115309: PUSH
115310: LD_INT 11
115312: PUSH
115313: LD_INT 12
115315: PUSH
115316: LD_INT 15
115318: PUSH
115319: LD_INT 16
115321: PUSH
115322: LD_INT 20
115324: PUSH
115325: LD_INT 21
115327: PUSH
115328: LD_INT 22
115330: PUSH
115331: LD_INT 23
115333: PUSH
115334: LD_INT 25
115336: PUSH
115337: LD_INT 26
115339: PUSH
115340: LD_INT 28
115342: PUSH
115343: LD_INT 30
115345: PUSH
115346: LD_INT 31
115348: PUSH
115349: LD_INT 32
115351: PUSH
115352: LD_INT 36
115354: PUSH
115355: EMPTY
115356: LIST
115357: LIST
115358: LIST
115359: LIST
115360: LIST
115361: LIST
115362: LIST
115363: LIST
115364: LIST
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: LIST
115372: LIST
115373: LIST
115374: LIST
115375: LIST
115376: LIST
115377: PUSH
115378: LD_INT 101
115380: PUSH
115381: LD_INT 102
115383: PUSH
115384: LD_INT 103
115386: PUSH
115387: LD_INT 105
115389: PUSH
115390: LD_INT 106
115392: PUSH
115393: LD_INT 108
115395: PUSH
115396: LD_INT 109
115398: PUSH
115399: LD_INT 112
115401: PUSH
115402: LD_INT 114
115404: PUSH
115405: LD_INT 116
115407: PUSH
115408: LD_INT 117
115410: PUSH
115411: LD_INT 118
115413: PUSH
115414: EMPTY
115415: LIST
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: LIST
115421: LIST
115422: LIST
115423: LIST
115424: LIST
115425: LIST
115426: LIST
115427: PUSH
115428: EMPTY
115429: LIST
115430: LIST
115431: ST_TO_ADDR
115432: GO 117531
115434: LD_INT 10
115436: DOUBLE
115437: EQUAL
115438: IFTRUE 115442
115440: GO 115638
115442: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
115443: LD_ADDR_VAR 0 2
115447: PUSH
115448: LD_INT 2
115450: PUSH
115451: LD_INT 4
115453: PUSH
115454: LD_INT 5
115456: PUSH
115457: LD_INT 6
115459: PUSH
115460: LD_INT 7
115462: PUSH
115463: LD_INT 8
115465: PUSH
115466: LD_INT 9
115468: PUSH
115469: LD_INT 10
115471: PUSH
115472: LD_INT 11
115474: PUSH
115475: LD_INT 12
115477: PUSH
115478: LD_INT 13
115480: PUSH
115481: LD_INT 14
115483: PUSH
115484: LD_INT 15
115486: PUSH
115487: LD_INT 16
115489: PUSH
115490: LD_INT 17
115492: PUSH
115493: LD_INT 18
115495: PUSH
115496: LD_INT 19
115498: PUSH
115499: LD_INT 20
115501: PUSH
115502: LD_INT 21
115504: PUSH
115505: LD_INT 22
115507: PUSH
115508: LD_INT 23
115510: PUSH
115511: LD_INT 24
115513: PUSH
115514: LD_INT 25
115516: PUSH
115517: LD_INT 26
115519: PUSH
115520: LD_INT 28
115522: PUSH
115523: LD_INT 30
115525: PUSH
115526: LD_INT 31
115528: PUSH
115529: LD_INT 32
115531: PUSH
115532: LD_INT 36
115534: PUSH
115535: EMPTY
115536: LIST
115537: LIST
115538: LIST
115539: LIST
115540: LIST
115541: LIST
115542: LIST
115543: LIST
115544: LIST
115545: LIST
115546: LIST
115547: LIST
115548: LIST
115549: LIST
115550: LIST
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: LIST
115556: LIST
115557: LIST
115558: LIST
115559: LIST
115560: LIST
115561: LIST
115562: LIST
115563: LIST
115564: LIST
115565: PUSH
115566: LD_INT 101
115568: PUSH
115569: LD_INT 102
115571: PUSH
115572: LD_INT 103
115574: PUSH
115575: LD_INT 104
115577: PUSH
115578: LD_INT 105
115580: PUSH
115581: LD_INT 106
115583: PUSH
115584: LD_INT 107
115586: PUSH
115587: LD_INT 108
115589: PUSH
115590: LD_INT 109
115592: PUSH
115593: LD_INT 110
115595: PUSH
115596: LD_INT 111
115598: PUSH
115599: LD_INT 112
115601: PUSH
115602: LD_INT 114
115604: PUSH
115605: LD_INT 116
115607: PUSH
115608: LD_INT 117
115610: PUSH
115611: LD_INT 118
115613: PUSH
115614: EMPTY
115615: LIST
115616: LIST
115617: LIST
115618: LIST
115619: LIST
115620: LIST
115621: LIST
115622: LIST
115623: LIST
115624: LIST
115625: LIST
115626: LIST
115627: LIST
115628: LIST
115629: LIST
115630: LIST
115631: PUSH
115632: EMPTY
115633: LIST
115634: LIST
115635: ST_TO_ADDR
115636: GO 117531
115638: LD_INT 11
115640: DOUBLE
115641: EQUAL
115642: IFTRUE 115646
115644: GO 115850
115646: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
115647: LD_ADDR_VAR 0 2
115651: PUSH
115652: LD_INT 2
115654: PUSH
115655: LD_INT 3
115657: PUSH
115658: LD_INT 4
115660: PUSH
115661: LD_INT 5
115663: PUSH
115664: LD_INT 6
115666: PUSH
115667: LD_INT 7
115669: PUSH
115670: LD_INT 8
115672: PUSH
115673: LD_INT 9
115675: PUSH
115676: LD_INT 10
115678: PUSH
115679: LD_INT 11
115681: PUSH
115682: LD_INT 12
115684: PUSH
115685: LD_INT 13
115687: PUSH
115688: LD_INT 14
115690: PUSH
115691: LD_INT 15
115693: PUSH
115694: LD_INT 16
115696: PUSH
115697: LD_INT 17
115699: PUSH
115700: LD_INT 18
115702: PUSH
115703: LD_INT 19
115705: PUSH
115706: LD_INT 20
115708: PUSH
115709: LD_INT 21
115711: PUSH
115712: LD_INT 22
115714: PUSH
115715: LD_INT 23
115717: PUSH
115718: LD_INT 24
115720: PUSH
115721: LD_INT 25
115723: PUSH
115724: LD_INT 26
115726: PUSH
115727: LD_INT 28
115729: PUSH
115730: LD_INT 30
115732: PUSH
115733: LD_INT 31
115735: PUSH
115736: LD_INT 32
115738: PUSH
115739: LD_INT 34
115741: PUSH
115742: LD_INT 36
115744: PUSH
115745: EMPTY
115746: LIST
115747: LIST
115748: LIST
115749: LIST
115750: LIST
115751: LIST
115752: LIST
115753: LIST
115754: LIST
115755: LIST
115756: LIST
115757: LIST
115758: LIST
115759: LIST
115760: LIST
115761: LIST
115762: LIST
115763: LIST
115764: LIST
115765: LIST
115766: LIST
115767: LIST
115768: LIST
115769: LIST
115770: LIST
115771: LIST
115772: LIST
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: PUSH
115778: LD_INT 101
115780: PUSH
115781: LD_INT 102
115783: PUSH
115784: LD_INT 103
115786: PUSH
115787: LD_INT 104
115789: PUSH
115790: LD_INT 105
115792: PUSH
115793: LD_INT 106
115795: PUSH
115796: LD_INT 107
115798: PUSH
115799: LD_INT 108
115801: PUSH
115802: LD_INT 109
115804: PUSH
115805: LD_INT 110
115807: PUSH
115808: LD_INT 111
115810: PUSH
115811: LD_INT 112
115813: PUSH
115814: LD_INT 114
115816: PUSH
115817: LD_INT 116
115819: PUSH
115820: LD_INT 117
115822: PUSH
115823: LD_INT 118
115825: PUSH
115826: EMPTY
115827: LIST
115828: LIST
115829: LIST
115830: LIST
115831: LIST
115832: LIST
115833: LIST
115834: LIST
115835: LIST
115836: LIST
115837: LIST
115838: LIST
115839: LIST
115840: LIST
115841: LIST
115842: LIST
115843: PUSH
115844: EMPTY
115845: LIST
115846: LIST
115847: ST_TO_ADDR
115848: GO 117531
115850: LD_INT 12
115852: DOUBLE
115853: EQUAL
115854: IFTRUE 115858
115856: GO 116078
115858: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115859: LD_ADDR_VAR 0 2
115863: PUSH
115864: LD_INT 1
115866: PUSH
115867: LD_INT 2
115869: PUSH
115870: LD_INT 3
115872: PUSH
115873: LD_INT 4
115875: PUSH
115876: LD_INT 5
115878: PUSH
115879: LD_INT 6
115881: PUSH
115882: LD_INT 7
115884: PUSH
115885: LD_INT 8
115887: PUSH
115888: LD_INT 9
115890: PUSH
115891: LD_INT 10
115893: PUSH
115894: LD_INT 11
115896: PUSH
115897: LD_INT 12
115899: PUSH
115900: LD_INT 13
115902: PUSH
115903: LD_INT 14
115905: PUSH
115906: LD_INT 15
115908: PUSH
115909: LD_INT 16
115911: PUSH
115912: LD_INT 17
115914: PUSH
115915: LD_INT 18
115917: PUSH
115918: LD_INT 19
115920: PUSH
115921: LD_INT 20
115923: PUSH
115924: LD_INT 21
115926: PUSH
115927: LD_INT 22
115929: PUSH
115930: LD_INT 23
115932: PUSH
115933: LD_INT 24
115935: PUSH
115936: LD_INT 25
115938: PUSH
115939: LD_INT 26
115941: PUSH
115942: LD_INT 27
115944: PUSH
115945: LD_INT 28
115947: PUSH
115948: LD_INT 30
115950: PUSH
115951: LD_INT 31
115953: PUSH
115954: LD_INT 32
115956: PUSH
115957: LD_INT 33
115959: PUSH
115960: LD_INT 34
115962: PUSH
115963: LD_INT 36
115965: PUSH
115966: EMPTY
115967: LIST
115968: LIST
115969: LIST
115970: LIST
115971: LIST
115972: LIST
115973: LIST
115974: LIST
115975: LIST
115976: LIST
115977: LIST
115978: LIST
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: LIST
115984: LIST
115985: LIST
115986: LIST
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: LIST
115992: LIST
115993: LIST
115994: LIST
115995: LIST
115996: LIST
115997: LIST
115998: LIST
115999: LIST
116000: LIST
116001: PUSH
116002: LD_INT 101
116004: PUSH
116005: LD_INT 102
116007: PUSH
116008: LD_INT 103
116010: PUSH
116011: LD_INT 104
116013: PUSH
116014: LD_INT 105
116016: PUSH
116017: LD_INT 106
116019: PUSH
116020: LD_INT 107
116022: PUSH
116023: LD_INT 108
116025: PUSH
116026: LD_INT 109
116028: PUSH
116029: LD_INT 110
116031: PUSH
116032: LD_INT 111
116034: PUSH
116035: LD_INT 112
116037: PUSH
116038: LD_INT 113
116040: PUSH
116041: LD_INT 114
116043: PUSH
116044: LD_INT 116
116046: PUSH
116047: LD_INT 117
116049: PUSH
116050: LD_INT 118
116052: PUSH
116053: EMPTY
116054: LIST
116055: LIST
116056: LIST
116057: LIST
116058: LIST
116059: LIST
116060: LIST
116061: LIST
116062: LIST
116063: LIST
116064: LIST
116065: LIST
116066: LIST
116067: LIST
116068: LIST
116069: LIST
116070: LIST
116071: PUSH
116072: EMPTY
116073: LIST
116074: LIST
116075: ST_TO_ADDR
116076: GO 117531
116078: LD_INT 13
116080: DOUBLE
116081: EQUAL
116082: IFTRUE 116086
116084: GO 116294
116086: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116087: LD_ADDR_VAR 0 2
116091: PUSH
116092: LD_INT 1
116094: PUSH
116095: LD_INT 2
116097: PUSH
116098: LD_INT 3
116100: PUSH
116101: LD_INT 4
116103: PUSH
116104: LD_INT 5
116106: PUSH
116107: LD_INT 8
116109: PUSH
116110: LD_INT 9
116112: PUSH
116113: LD_INT 10
116115: PUSH
116116: LD_INT 11
116118: PUSH
116119: LD_INT 12
116121: PUSH
116122: LD_INT 14
116124: PUSH
116125: LD_INT 15
116127: PUSH
116128: LD_INT 16
116130: PUSH
116131: LD_INT 17
116133: PUSH
116134: LD_INT 18
116136: PUSH
116137: LD_INT 19
116139: PUSH
116140: LD_INT 20
116142: PUSH
116143: LD_INT 21
116145: PUSH
116146: LD_INT 22
116148: PUSH
116149: LD_INT 23
116151: PUSH
116152: LD_INT 24
116154: PUSH
116155: LD_INT 25
116157: PUSH
116158: LD_INT 26
116160: PUSH
116161: LD_INT 27
116163: PUSH
116164: LD_INT 28
116166: PUSH
116167: LD_INT 30
116169: PUSH
116170: LD_INT 31
116172: PUSH
116173: LD_INT 32
116175: PUSH
116176: LD_INT 33
116178: PUSH
116179: LD_INT 34
116181: PUSH
116182: LD_INT 36
116184: PUSH
116185: EMPTY
116186: LIST
116187: LIST
116188: LIST
116189: LIST
116190: LIST
116191: LIST
116192: LIST
116193: LIST
116194: LIST
116195: LIST
116196: LIST
116197: LIST
116198: LIST
116199: LIST
116200: LIST
116201: LIST
116202: LIST
116203: LIST
116204: LIST
116205: LIST
116206: LIST
116207: LIST
116208: LIST
116209: LIST
116210: LIST
116211: LIST
116212: LIST
116213: LIST
116214: LIST
116215: LIST
116216: LIST
116217: PUSH
116218: LD_INT 101
116220: PUSH
116221: LD_INT 102
116223: PUSH
116224: LD_INT 103
116226: PUSH
116227: LD_INT 104
116229: PUSH
116230: LD_INT 105
116232: PUSH
116233: LD_INT 106
116235: PUSH
116236: LD_INT 107
116238: PUSH
116239: LD_INT 108
116241: PUSH
116242: LD_INT 109
116244: PUSH
116245: LD_INT 110
116247: PUSH
116248: LD_INT 111
116250: PUSH
116251: LD_INT 112
116253: PUSH
116254: LD_INT 113
116256: PUSH
116257: LD_INT 114
116259: PUSH
116260: LD_INT 116
116262: PUSH
116263: LD_INT 117
116265: PUSH
116266: LD_INT 118
116268: PUSH
116269: EMPTY
116270: LIST
116271: LIST
116272: LIST
116273: LIST
116274: LIST
116275: LIST
116276: LIST
116277: LIST
116278: LIST
116279: LIST
116280: LIST
116281: LIST
116282: LIST
116283: LIST
116284: LIST
116285: LIST
116286: LIST
116287: PUSH
116288: EMPTY
116289: LIST
116290: LIST
116291: ST_TO_ADDR
116292: GO 117531
116294: LD_INT 14
116296: DOUBLE
116297: EQUAL
116298: IFTRUE 116302
116300: GO 116526
116302: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116303: LD_ADDR_VAR 0 2
116307: PUSH
116308: LD_INT 1
116310: PUSH
116311: LD_INT 2
116313: PUSH
116314: LD_INT 3
116316: PUSH
116317: LD_INT 4
116319: PUSH
116320: LD_INT 5
116322: PUSH
116323: LD_INT 6
116325: PUSH
116326: LD_INT 7
116328: PUSH
116329: LD_INT 8
116331: PUSH
116332: LD_INT 9
116334: PUSH
116335: LD_INT 10
116337: PUSH
116338: LD_INT 11
116340: PUSH
116341: LD_INT 12
116343: PUSH
116344: LD_INT 13
116346: PUSH
116347: LD_INT 14
116349: PUSH
116350: LD_INT 15
116352: PUSH
116353: LD_INT 16
116355: PUSH
116356: LD_INT 17
116358: PUSH
116359: LD_INT 18
116361: PUSH
116362: LD_INT 19
116364: PUSH
116365: LD_INT 20
116367: PUSH
116368: LD_INT 21
116370: PUSH
116371: LD_INT 22
116373: PUSH
116374: LD_INT 23
116376: PUSH
116377: LD_INT 24
116379: PUSH
116380: LD_INT 25
116382: PUSH
116383: LD_INT 26
116385: PUSH
116386: LD_INT 27
116388: PUSH
116389: LD_INT 28
116391: PUSH
116392: LD_INT 29
116394: PUSH
116395: LD_INT 30
116397: PUSH
116398: LD_INT 31
116400: PUSH
116401: LD_INT 32
116403: PUSH
116404: LD_INT 33
116406: PUSH
116407: LD_INT 34
116409: PUSH
116410: LD_INT 36
116412: PUSH
116413: EMPTY
116414: LIST
116415: LIST
116416: LIST
116417: LIST
116418: LIST
116419: LIST
116420: LIST
116421: LIST
116422: LIST
116423: LIST
116424: LIST
116425: LIST
116426: LIST
116427: LIST
116428: LIST
116429: LIST
116430: LIST
116431: LIST
116432: LIST
116433: LIST
116434: LIST
116435: LIST
116436: LIST
116437: LIST
116438: LIST
116439: LIST
116440: LIST
116441: LIST
116442: LIST
116443: LIST
116444: LIST
116445: LIST
116446: LIST
116447: LIST
116448: LIST
116449: PUSH
116450: LD_INT 101
116452: PUSH
116453: LD_INT 102
116455: PUSH
116456: LD_INT 103
116458: PUSH
116459: LD_INT 104
116461: PUSH
116462: LD_INT 105
116464: PUSH
116465: LD_INT 106
116467: PUSH
116468: LD_INT 107
116470: PUSH
116471: LD_INT 108
116473: PUSH
116474: LD_INT 109
116476: PUSH
116477: LD_INT 110
116479: PUSH
116480: LD_INT 111
116482: PUSH
116483: LD_INT 112
116485: PUSH
116486: LD_INT 113
116488: PUSH
116489: LD_INT 114
116491: PUSH
116492: LD_INT 116
116494: PUSH
116495: LD_INT 117
116497: PUSH
116498: LD_INT 118
116500: PUSH
116501: EMPTY
116502: LIST
116503: LIST
116504: LIST
116505: LIST
116506: LIST
116507: LIST
116508: LIST
116509: LIST
116510: LIST
116511: LIST
116512: LIST
116513: LIST
116514: LIST
116515: LIST
116516: LIST
116517: LIST
116518: LIST
116519: PUSH
116520: EMPTY
116521: LIST
116522: LIST
116523: ST_TO_ADDR
116524: GO 117531
116526: LD_INT 15
116528: DOUBLE
116529: EQUAL
116530: IFTRUE 116534
116532: GO 116758
116534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
116535: LD_ADDR_VAR 0 2
116539: PUSH
116540: LD_INT 1
116542: PUSH
116543: LD_INT 2
116545: PUSH
116546: LD_INT 3
116548: PUSH
116549: LD_INT 4
116551: PUSH
116552: LD_INT 5
116554: PUSH
116555: LD_INT 6
116557: PUSH
116558: LD_INT 7
116560: PUSH
116561: LD_INT 8
116563: PUSH
116564: LD_INT 9
116566: PUSH
116567: LD_INT 10
116569: PUSH
116570: LD_INT 11
116572: PUSH
116573: LD_INT 12
116575: PUSH
116576: LD_INT 13
116578: PUSH
116579: LD_INT 14
116581: PUSH
116582: LD_INT 15
116584: PUSH
116585: LD_INT 16
116587: PUSH
116588: LD_INT 17
116590: PUSH
116591: LD_INT 18
116593: PUSH
116594: LD_INT 19
116596: PUSH
116597: LD_INT 20
116599: PUSH
116600: LD_INT 21
116602: PUSH
116603: LD_INT 22
116605: PUSH
116606: LD_INT 23
116608: PUSH
116609: LD_INT 24
116611: PUSH
116612: LD_INT 25
116614: PUSH
116615: LD_INT 26
116617: PUSH
116618: LD_INT 27
116620: PUSH
116621: LD_INT 28
116623: PUSH
116624: LD_INT 29
116626: PUSH
116627: LD_INT 30
116629: PUSH
116630: LD_INT 31
116632: PUSH
116633: LD_INT 32
116635: PUSH
116636: LD_INT 33
116638: PUSH
116639: LD_INT 34
116641: PUSH
116642: LD_INT 36
116644: PUSH
116645: EMPTY
116646: LIST
116647: LIST
116648: LIST
116649: LIST
116650: LIST
116651: LIST
116652: LIST
116653: LIST
116654: LIST
116655: LIST
116656: LIST
116657: LIST
116658: LIST
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: LIST
116672: LIST
116673: LIST
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: LIST
116679: LIST
116680: LIST
116681: PUSH
116682: LD_INT 101
116684: PUSH
116685: LD_INT 102
116687: PUSH
116688: LD_INT 103
116690: PUSH
116691: LD_INT 104
116693: PUSH
116694: LD_INT 105
116696: PUSH
116697: LD_INT 106
116699: PUSH
116700: LD_INT 107
116702: PUSH
116703: LD_INT 108
116705: PUSH
116706: LD_INT 109
116708: PUSH
116709: LD_INT 110
116711: PUSH
116712: LD_INT 111
116714: PUSH
116715: LD_INT 112
116717: PUSH
116718: LD_INT 113
116720: PUSH
116721: LD_INT 114
116723: PUSH
116724: LD_INT 116
116726: PUSH
116727: LD_INT 117
116729: PUSH
116730: LD_INT 118
116732: PUSH
116733: EMPTY
116734: LIST
116735: LIST
116736: LIST
116737: LIST
116738: LIST
116739: LIST
116740: LIST
116741: LIST
116742: LIST
116743: LIST
116744: LIST
116745: LIST
116746: LIST
116747: LIST
116748: LIST
116749: LIST
116750: LIST
116751: PUSH
116752: EMPTY
116753: LIST
116754: LIST
116755: ST_TO_ADDR
116756: GO 117531
116758: LD_INT 16
116760: DOUBLE
116761: EQUAL
116762: IFTRUE 116766
116764: GO 116902
116766: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
116767: LD_ADDR_VAR 0 2
116771: PUSH
116772: LD_INT 2
116774: PUSH
116775: LD_INT 4
116777: PUSH
116778: LD_INT 5
116780: PUSH
116781: LD_INT 7
116783: PUSH
116784: LD_INT 11
116786: PUSH
116787: LD_INT 12
116789: PUSH
116790: LD_INT 15
116792: PUSH
116793: LD_INT 16
116795: PUSH
116796: LD_INT 20
116798: PUSH
116799: LD_INT 21
116801: PUSH
116802: LD_INT 22
116804: PUSH
116805: LD_INT 23
116807: PUSH
116808: LD_INT 25
116810: PUSH
116811: LD_INT 26
116813: PUSH
116814: LD_INT 30
116816: PUSH
116817: LD_INT 31
116819: PUSH
116820: LD_INT 32
116822: PUSH
116823: LD_INT 33
116825: PUSH
116826: LD_INT 34
116828: PUSH
116829: EMPTY
116830: LIST
116831: LIST
116832: LIST
116833: LIST
116834: LIST
116835: LIST
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: LIST
116847: LIST
116848: LIST
116849: PUSH
116850: LD_INT 101
116852: PUSH
116853: LD_INT 102
116855: PUSH
116856: LD_INT 103
116858: PUSH
116859: LD_INT 106
116861: PUSH
116862: LD_INT 108
116864: PUSH
116865: LD_INT 112
116867: PUSH
116868: LD_INT 113
116870: PUSH
116871: LD_INT 114
116873: PUSH
116874: LD_INT 116
116876: PUSH
116877: LD_INT 117
116879: PUSH
116880: LD_INT 118
116882: PUSH
116883: EMPTY
116884: LIST
116885: LIST
116886: LIST
116887: LIST
116888: LIST
116889: LIST
116890: LIST
116891: LIST
116892: LIST
116893: LIST
116894: LIST
116895: PUSH
116896: EMPTY
116897: LIST
116898: LIST
116899: ST_TO_ADDR
116900: GO 117531
116902: LD_INT 17
116904: DOUBLE
116905: EQUAL
116906: IFTRUE 116910
116908: GO 117134
116910: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116911: LD_ADDR_VAR 0 2
116915: PUSH
116916: LD_INT 1
116918: PUSH
116919: LD_INT 2
116921: PUSH
116922: LD_INT 3
116924: PUSH
116925: LD_INT 4
116927: PUSH
116928: LD_INT 5
116930: PUSH
116931: LD_INT 6
116933: PUSH
116934: LD_INT 7
116936: PUSH
116937: LD_INT 8
116939: PUSH
116940: LD_INT 9
116942: PUSH
116943: LD_INT 10
116945: PUSH
116946: LD_INT 11
116948: PUSH
116949: LD_INT 12
116951: PUSH
116952: LD_INT 13
116954: PUSH
116955: LD_INT 14
116957: PUSH
116958: LD_INT 15
116960: PUSH
116961: LD_INT 16
116963: PUSH
116964: LD_INT 17
116966: PUSH
116967: LD_INT 18
116969: PUSH
116970: LD_INT 19
116972: PUSH
116973: LD_INT 20
116975: PUSH
116976: LD_INT 21
116978: PUSH
116979: LD_INT 22
116981: PUSH
116982: LD_INT 23
116984: PUSH
116985: LD_INT 24
116987: PUSH
116988: LD_INT 25
116990: PUSH
116991: LD_INT 26
116993: PUSH
116994: LD_INT 27
116996: PUSH
116997: LD_INT 28
116999: PUSH
117000: LD_INT 29
117002: PUSH
117003: LD_INT 30
117005: PUSH
117006: LD_INT 31
117008: PUSH
117009: LD_INT 32
117011: PUSH
117012: LD_INT 33
117014: PUSH
117015: LD_INT 34
117017: PUSH
117018: LD_INT 36
117020: PUSH
117021: EMPTY
117022: LIST
117023: LIST
117024: LIST
117025: LIST
117026: LIST
117027: LIST
117028: LIST
117029: LIST
117030: LIST
117031: LIST
117032: LIST
117033: LIST
117034: LIST
117035: LIST
117036: LIST
117037: LIST
117038: LIST
117039: LIST
117040: LIST
117041: LIST
117042: LIST
117043: LIST
117044: LIST
117045: LIST
117046: LIST
117047: LIST
117048: LIST
117049: LIST
117050: LIST
117051: LIST
117052: LIST
117053: LIST
117054: LIST
117055: LIST
117056: LIST
117057: PUSH
117058: LD_INT 101
117060: PUSH
117061: LD_INT 102
117063: PUSH
117064: LD_INT 103
117066: PUSH
117067: LD_INT 104
117069: PUSH
117070: LD_INT 105
117072: PUSH
117073: LD_INT 106
117075: PUSH
117076: LD_INT 107
117078: PUSH
117079: LD_INT 108
117081: PUSH
117082: LD_INT 109
117084: PUSH
117085: LD_INT 110
117087: PUSH
117088: LD_INT 111
117090: PUSH
117091: LD_INT 112
117093: PUSH
117094: LD_INT 113
117096: PUSH
117097: LD_INT 114
117099: PUSH
117100: LD_INT 116
117102: PUSH
117103: LD_INT 117
117105: PUSH
117106: LD_INT 118
117108: PUSH
117109: EMPTY
117110: LIST
117111: LIST
117112: LIST
117113: LIST
117114: LIST
117115: LIST
117116: LIST
117117: LIST
117118: LIST
117119: LIST
117120: LIST
117121: LIST
117122: LIST
117123: LIST
117124: LIST
117125: LIST
117126: LIST
117127: PUSH
117128: EMPTY
117129: LIST
117130: LIST
117131: ST_TO_ADDR
117132: GO 117531
117134: LD_INT 18
117136: DOUBLE
117137: EQUAL
117138: IFTRUE 117142
117140: GO 117290
117142: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117143: LD_ADDR_VAR 0 2
117147: PUSH
117148: LD_INT 2
117150: PUSH
117151: LD_INT 4
117153: PUSH
117154: LD_INT 5
117156: PUSH
117157: LD_INT 7
117159: PUSH
117160: LD_INT 11
117162: PUSH
117163: LD_INT 12
117165: PUSH
117166: LD_INT 15
117168: PUSH
117169: LD_INT 16
117171: PUSH
117172: LD_INT 20
117174: PUSH
117175: LD_INT 21
117177: PUSH
117178: LD_INT 22
117180: PUSH
117181: LD_INT 23
117183: PUSH
117184: LD_INT 25
117186: PUSH
117187: LD_INT 26
117189: PUSH
117190: LD_INT 30
117192: PUSH
117193: LD_INT 31
117195: PUSH
117196: LD_INT 32
117198: PUSH
117199: LD_INT 33
117201: PUSH
117202: LD_INT 34
117204: PUSH
117205: LD_INT 35
117207: PUSH
117208: LD_INT 36
117210: PUSH
117211: EMPTY
117212: LIST
117213: LIST
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: PUSH
117234: LD_INT 101
117236: PUSH
117237: LD_INT 102
117239: PUSH
117240: LD_INT 103
117242: PUSH
117243: LD_INT 106
117245: PUSH
117246: LD_INT 108
117248: PUSH
117249: LD_INT 112
117251: PUSH
117252: LD_INT 113
117254: PUSH
117255: LD_INT 114
117257: PUSH
117258: LD_INT 115
117260: PUSH
117261: LD_INT 116
117263: PUSH
117264: LD_INT 117
117266: PUSH
117267: LD_INT 118
117269: PUSH
117270: EMPTY
117271: LIST
117272: LIST
117273: LIST
117274: LIST
117275: LIST
117276: LIST
117277: LIST
117278: LIST
117279: LIST
117280: LIST
117281: LIST
117282: LIST
117283: PUSH
117284: EMPTY
117285: LIST
117286: LIST
117287: ST_TO_ADDR
117288: GO 117531
117290: LD_INT 19
117292: DOUBLE
117293: EQUAL
117294: IFTRUE 117298
117296: GO 117530
117298: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117299: LD_ADDR_VAR 0 2
117303: PUSH
117304: LD_INT 1
117306: PUSH
117307: LD_INT 2
117309: PUSH
117310: LD_INT 3
117312: PUSH
117313: LD_INT 4
117315: PUSH
117316: LD_INT 5
117318: PUSH
117319: LD_INT 6
117321: PUSH
117322: LD_INT 7
117324: PUSH
117325: LD_INT 8
117327: PUSH
117328: LD_INT 9
117330: PUSH
117331: LD_INT 10
117333: PUSH
117334: LD_INT 11
117336: PUSH
117337: LD_INT 12
117339: PUSH
117340: LD_INT 13
117342: PUSH
117343: LD_INT 14
117345: PUSH
117346: LD_INT 15
117348: PUSH
117349: LD_INT 16
117351: PUSH
117352: LD_INT 17
117354: PUSH
117355: LD_INT 18
117357: PUSH
117358: LD_INT 19
117360: PUSH
117361: LD_INT 20
117363: PUSH
117364: LD_INT 21
117366: PUSH
117367: LD_INT 22
117369: PUSH
117370: LD_INT 23
117372: PUSH
117373: LD_INT 24
117375: PUSH
117376: LD_INT 25
117378: PUSH
117379: LD_INT 26
117381: PUSH
117382: LD_INT 27
117384: PUSH
117385: LD_INT 28
117387: PUSH
117388: LD_INT 29
117390: PUSH
117391: LD_INT 30
117393: PUSH
117394: LD_INT 31
117396: PUSH
117397: LD_INT 32
117399: PUSH
117400: LD_INT 33
117402: PUSH
117403: LD_INT 34
117405: PUSH
117406: LD_INT 35
117408: PUSH
117409: LD_INT 36
117411: PUSH
117412: EMPTY
117413: LIST
117414: LIST
117415: LIST
117416: LIST
117417: LIST
117418: LIST
117419: LIST
117420: LIST
117421: LIST
117422: LIST
117423: LIST
117424: LIST
117425: LIST
117426: LIST
117427: LIST
117428: LIST
117429: LIST
117430: LIST
117431: LIST
117432: LIST
117433: LIST
117434: LIST
117435: LIST
117436: LIST
117437: LIST
117438: LIST
117439: LIST
117440: LIST
117441: LIST
117442: LIST
117443: LIST
117444: LIST
117445: LIST
117446: LIST
117447: LIST
117448: LIST
117449: PUSH
117450: LD_INT 101
117452: PUSH
117453: LD_INT 102
117455: PUSH
117456: LD_INT 103
117458: PUSH
117459: LD_INT 104
117461: PUSH
117462: LD_INT 105
117464: PUSH
117465: LD_INT 106
117467: PUSH
117468: LD_INT 107
117470: PUSH
117471: LD_INT 108
117473: PUSH
117474: LD_INT 109
117476: PUSH
117477: LD_INT 110
117479: PUSH
117480: LD_INT 111
117482: PUSH
117483: LD_INT 112
117485: PUSH
117486: LD_INT 113
117488: PUSH
117489: LD_INT 114
117491: PUSH
117492: LD_INT 115
117494: PUSH
117495: LD_INT 116
117497: PUSH
117498: LD_INT 117
117500: PUSH
117501: LD_INT 118
117503: PUSH
117504: EMPTY
117505: LIST
117506: LIST
117507: LIST
117508: LIST
117509: LIST
117510: LIST
117511: LIST
117512: LIST
117513: LIST
117514: LIST
117515: LIST
117516: LIST
117517: LIST
117518: LIST
117519: LIST
117520: LIST
117521: LIST
117522: LIST
117523: PUSH
117524: EMPTY
117525: LIST
117526: LIST
117527: ST_TO_ADDR
117528: GO 117531
117530: POP
// end else
117531: GO 117762
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
117533: LD_ADDR_VAR 0 2
117537: PUSH
117538: LD_INT 1
117540: PUSH
117541: LD_INT 2
117543: PUSH
117544: LD_INT 3
117546: PUSH
117547: LD_INT 4
117549: PUSH
117550: LD_INT 5
117552: PUSH
117553: LD_INT 6
117555: PUSH
117556: LD_INT 7
117558: PUSH
117559: LD_INT 8
117561: PUSH
117562: LD_INT 9
117564: PUSH
117565: LD_INT 10
117567: PUSH
117568: LD_INT 11
117570: PUSH
117571: LD_INT 12
117573: PUSH
117574: LD_INT 13
117576: PUSH
117577: LD_INT 14
117579: PUSH
117580: LD_INT 15
117582: PUSH
117583: LD_INT 16
117585: PUSH
117586: LD_INT 17
117588: PUSH
117589: LD_INT 18
117591: PUSH
117592: LD_INT 19
117594: PUSH
117595: LD_INT 20
117597: PUSH
117598: LD_INT 21
117600: PUSH
117601: LD_INT 22
117603: PUSH
117604: LD_INT 23
117606: PUSH
117607: LD_INT 24
117609: PUSH
117610: LD_INT 25
117612: PUSH
117613: LD_INT 26
117615: PUSH
117616: LD_INT 27
117618: PUSH
117619: LD_INT 28
117621: PUSH
117622: LD_INT 29
117624: PUSH
117625: LD_INT 30
117627: PUSH
117628: LD_INT 31
117630: PUSH
117631: LD_INT 32
117633: PUSH
117634: LD_INT 33
117636: PUSH
117637: LD_INT 34
117639: PUSH
117640: LD_INT 35
117642: PUSH
117643: LD_INT 36
117645: PUSH
117646: EMPTY
117647: LIST
117648: LIST
117649: LIST
117650: LIST
117651: LIST
117652: LIST
117653: LIST
117654: LIST
117655: LIST
117656: LIST
117657: LIST
117658: LIST
117659: LIST
117660: LIST
117661: LIST
117662: LIST
117663: LIST
117664: LIST
117665: LIST
117666: LIST
117667: LIST
117668: LIST
117669: LIST
117670: LIST
117671: LIST
117672: LIST
117673: LIST
117674: LIST
117675: LIST
117676: LIST
117677: LIST
117678: LIST
117679: LIST
117680: LIST
117681: LIST
117682: LIST
117683: PUSH
117684: LD_INT 101
117686: PUSH
117687: LD_INT 102
117689: PUSH
117690: LD_INT 103
117692: PUSH
117693: LD_INT 104
117695: PUSH
117696: LD_INT 105
117698: PUSH
117699: LD_INT 106
117701: PUSH
117702: LD_INT 107
117704: PUSH
117705: LD_INT 108
117707: PUSH
117708: LD_INT 109
117710: PUSH
117711: LD_INT 110
117713: PUSH
117714: LD_INT 111
117716: PUSH
117717: LD_INT 112
117719: PUSH
117720: LD_INT 113
117722: PUSH
117723: LD_INT 114
117725: PUSH
117726: LD_INT 115
117728: PUSH
117729: LD_INT 116
117731: PUSH
117732: LD_INT 117
117734: PUSH
117735: LD_INT 118
117737: PUSH
117738: EMPTY
117739: LIST
117740: LIST
117741: LIST
117742: LIST
117743: LIST
117744: LIST
117745: LIST
117746: LIST
117747: LIST
117748: LIST
117749: LIST
117750: LIST
117751: LIST
117752: LIST
117753: LIST
117754: LIST
117755: LIST
117756: LIST
117757: PUSH
117758: EMPTY
117759: LIST
117760: LIST
117761: ST_TO_ADDR
// if result then
117762: LD_VAR 0 2
117766: IFFALSE 118552
// begin normal :=  ;
117768: LD_ADDR_VAR 0 5
117772: PUSH
117773: LD_STRING 
117775: ST_TO_ADDR
// hardcore :=  ;
117776: LD_ADDR_VAR 0 6
117780: PUSH
117781: LD_STRING 
117783: ST_TO_ADDR
// active :=  ;
117784: LD_ADDR_VAR 0 7
117788: PUSH
117789: LD_STRING 
117791: ST_TO_ADDR
// for i = 1 to normalCounter do
117792: LD_ADDR_VAR 0 8
117796: PUSH
117797: DOUBLE
117798: LD_INT 1
117800: DEC
117801: ST_TO_ADDR
117802: LD_EXP 149
117806: PUSH
117807: FOR_TO
117808: IFFALSE 117909
// begin tmp := 0 ;
117810: LD_ADDR_VAR 0 3
117814: PUSH
117815: LD_STRING 0
117817: ST_TO_ADDR
// if result [ 1 ] then
117818: LD_VAR 0 2
117822: PUSH
117823: LD_INT 1
117825: ARRAY
117826: IFFALSE 117891
// if result [ 1 ] [ 1 ] = i then
117828: LD_VAR 0 2
117832: PUSH
117833: LD_INT 1
117835: ARRAY
117836: PUSH
117837: LD_INT 1
117839: ARRAY
117840: PUSH
117841: LD_VAR 0 8
117845: EQUAL
117846: IFFALSE 117891
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117848: LD_ADDR_VAR 0 2
117852: PUSH
117853: LD_VAR 0 2
117857: PPUSH
117858: LD_INT 1
117860: PPUSH
117861: LD_VAR 0 2
117865: PUSH
117866: LD_INT 1
117868: ARRAY
117869: PPUSH
117870: LD_INT 1
117872: PPUSH
117873: CALL_OW 3
117877: PPUSH
117878: CALL_OW 1
117882: ST_TO_ADDR
// tmp := 1 ;
117883: LD_ADDR_VAR 0 3
117887: PUSH
117888: LD_STRING 1
117890: ST_TO_ADDR
// end ; normal := normal & tmp ;
117891: LD_ADDR_VAR 0 5
117895: PUSH
117896: LD_VAR 0 5
117900: PUSH
117901: LD_VAR 0 3
117905: STR
117906: ST_TO_ADDR
// end ;
117907: GO 117807
117909: POP
117910: POP
// for i = 1 to hardcoreCounter do
117911: LD_ADDR_VAR 0 8
117915: PUSH
117916: DOUBLE
117917: LD_INT 1
117919: DEC
117920: ST_TO_ADDR
117921: LD_EXP 150
117925: PUSH
117926: FOR_TO
117927: IFFALSE 118032
// begin tmp := 0 ;
117929: LD_ADDR_VAR 0 3
117933: PUSH
117934: LD_STRING 0
117936: ST_TO_ADDR
// if result [ 2 ] then
117937: LD_VAR 0 2
117941: PUSH
117942: LD_INT 2
117944: ARRAY
117945: IFFALSE 118014
// if result [ 2 ] [ 1 ] = 100 + i then
117947: LD_VAR 0 2
117951: PUSH
117952: LD_INT 2
117954: ARRAY
117955: PUSH
117956: LD_INT 1
117958: ARRAY
117959: PUSH
117960: LD_INT 100
117962: PUSH
117963: LD_VAR 0 8
117967: PLUS
117968: EQUAL
117969: IFFALSE 118014
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117971: LD_ADDR_VAR 0 2
117975: PUSH
117976: LD_VAR 0 2
117980: PPUSH
117981: LD_INT 2
117983: PPUSH
117984: LD_VAR 0 2
117988: PUSH
117989: LD_INT 2
117991: ARRAY
117992: PPUSH
117993: LD_INT 1
117995: PPUSH
117996: CALL_OW 3
118000: PPUSH
118001: CALL_OW 1
118005: ST_TO_ADDR
// tmp := 1 ;
118006: LD_ADDR_VAR 0 3
118010: PUSH
118011: LD_STRING 1
118013: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118014: LD_ADDR_VAR 0 6
118018: PUSH
118019: LD_VAR 0 6
118023: PUSH
118024: LD_VAR 0 3
118028: STR
118029: ST_TO_ADDR
// end ;
118030: GO 117926
118032: POP
118033: POP
// if isGameLoad then
118034: LD_VAR 0 1
118038: IFFALSE 118513
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118040: LD_ADDR_VAR 0 4
118044: PUSH
118045: LD_EXP 153
118049: PUSH
118050: LD_EXP 152
118054: PUSH
118055: LD_EXP 154
118059: PUSH
118060: LD_EXP 151
118064: PUSH
118065: LD_EXP 155
118069: PUSH
118070: LD_EXP 156
118074: PUSH
118075: LD_EXP 157
118079: PUSH
118080: LD_EXP 158
118084: PUSH
118085: LD_EXP 159
118089: PUSH
118090: LD_EXP 160
118094: PUSH
118095: LD_EXP 161
118099: PUSH
118100: LD_EXP 162
118104: PUSH
118105: LD_EXP 163
118109: PUSH
118110: LD_EXP 164
118114: PUSH
118115: LD_EXP 172
118119: PUSH
118120: LD_EXP 173
118124: PUSH
118125: LD_EXP 174
118129: PUSH
118130: LD_EXP 175
118134: PUSH
118135: LD_EXP 177
118139: PUSH
118140: LD_EXP 178
118144: PUSH
118145: LD_EXP 179
118149: PUSH
118150: LD_EXP 182
118154: PUSH
118155: LD_EXP 184
118159: PUSH
118160: LD_EXP 185
118164: PUSH
118165: LD_EXP 186
118169: PUSH
118170: LD_EXP 188
118174: PUSH
118175: LD_EXP 189
118179: PUSH
118180: LD_EXP 192
118184: PUSH
118185: LD_EXP 193
118189: PUSH
118190: LD_EXP 194
118194: PUSH
118195: LD_EXP 195
118199: PUSH
118200: LD_EXP 196
118204: PUSH
118205: LD_EXP 197
118209: PUSH
118210: LD_EXP 198
118214: PUSH
118215: LD_EXP 199
118219: PUSH
118220: LD_EXP 200
118224: PUSH
118225: LD_EXP 165
118229: PUSH
118230: LD_EXP 166
118234: PUSH
118235: LD_EXP 169
118239: PUSH
118240: LD_EXP 170
118244: PUSH
118245: LD_EXP 171
118249: PUSH
118250: LD_EXP 167
118254: PUSH
118255: LD_EXP 168
118259: PUSH
118260: LD_EXP 176
118264: PUSH
118265: LD_EXP 180
118269: PUSH
118270: LD_EXP 181
118274: PUSH
118275: LD_EXP 183
118279: PUSH
118280: LD_EXP 187
118284: PUSH
118285: LD_EXP 190
118289: PUSH
118290: LD_EXP 191
118294: PUSH
118295: LD_EXP 201
118299: PUSH
118300: LD_EXP 202
118304: PUSH
118305: LD_EXP 203
118309: PUSH
118310: LD_EXP 204
118314: PUSH
118315: EMPTY
118316: LIST
118317: LIST
118318: LIST
118319: LIST
118320: LIST
118321: LIST
118322: LIST
118323: LIST
118324: LIST
118325: LIST
118326: LIST
118327: LIST
118328: LIST
118329: LIST
118330: LIST
118331: LIST
118332: LIST
118333: LIST
118334: LIST
118335: LIST
118336: LIST
118337: LIST
118338: LIST
118339: LIST
118340: LIST
118341: LIST
118342: LIST
118343: LIST
118344: LIST
118345: LIST
118346: LIST
118347: LIST
118348: LIST
118349: LIST
118350: LIST
118351: LIST
118352: LIST
118353: LIST
118354: LIST
118355: LIST
118356: LIST
118357: LIST
118358: LIST
118359: LIST
118360: LIST
118361: LIST
118362: LIST
118363: LIST
118364: LIST
118365: LIST
118366: LIST
118367: LIST
118368: LIST
118369: LIST
118370: ST_TO_ADDR
// tmp :=  ;
118371: LD_ADDR_VAR 0 3
118375: PUSH
118376: LD_STRING 
118378: ST_TO_ADDR
// for i = 1 to normalCounter do
118379: LD_ADDR_VAR 0 8
118383: PUSH
118384: DOUBLE
118385: LD_INT 1
118387: DEC
118388: ST_TO_ADDR
118389: LD_EXP 149
118393: PUSH
118394: FOR_TO
118395: IFFALSE 118431
// begin if flags [ i ] then
118397: LD_VAR 0 4
118401: PUSH
118402: LD_VAR 0 8
118406: ARRAY
118407: IFFALSE 118429
// tmp := tmp & i & ; ;
118409: LD_ADDR_VAR 0 3
118413: PUSH
118414: LD_VAR 0 3
118418: PUSH
118419: LD_VAR 0 8
118423: STR
118424: PUSH
118425: LD_STRING ;
118427: STR
118428: ST_TO_ADDR
// end ;
118429: GO 118394
118431: POP
118432: POP
// for i = 1 to hardcoreCounter do
118433: LD_ADDR_VAR 0 8
118437: PUSH
118438: DOUBLE
118439: LD_INT 1
118441: DEC
118442: ST_TO_ADDR
118443: LD_EXP 150
118447: PUSH
118448: FOR_TO
118449: IFFALSE 118495
// begin if flags [ normalCounter + i ] then
118451: LD_VAR 0 4
118455: PUSH
118456: LD_EXP 149
118460: PUSH
118461: LD_VAR 0 8
118465: PLUS
118466: ARRAY
118467: IFFALSE 118493
// tmp := tmp & ( 100 + i ) & ; ;
118469: LD_ADDR_VAR 0 3
118473: PUSH
118474: LD_VAR 0 3
118478: PUSH
118479: LD_INT 100
118481: PUSH
118482: LD_VAR 0 8
118486: PLUS
118487: STR
118488: PUSH
118489: LD_STRING ;
118491: STR
118492: ST_TO_ADDR
// end ;
118493: GO 118448
118495: POP
118496: POP
// if tmp then
118497: LD_VAR 0 3
118501: IFFALSE 118513
// active := tmp ;
118503: LD_ADDR_VAR 0 7
118507: PUSH
118508: LD_VAR 0 3
118512: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
118513: LD_STRING getStreamItemsFromMission("
118515: PUSH
118516: LD_VAR 0 5
118520: STR
118521: PUSH
118522: LD_STRING ","
118524: STR
118525: PUSH
118526: LD_VAR 0 6
118530: STR
118531: PUSH
118532: LD_STRING ","
118534: STR
118535: PUSH
118536: LD_VAR 0 7
118540: STR
118541: PUSH
118542: LD_STRING ")
118544: STR
118545: PPUSH
118546: CALL_OW 559
// end else
118550: GO 118559
// ToLua ( getStreamItemsFromMission("","","") ) ;
118552: LD_STRING getStreamItemsFromMission("","","")
118554: PPUSH
118555: CALL_OW 559
// end ;
118559: LD_VAR 0 2
118563: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
118564: LD_EXP 148
118568: PUSH
118569: LD_EXP 153
118573: AND
118574: IFFALSE 118698
118576: GO 118578
118578: DISABLE
118579: LD_INT 0
118581: PPUSH
118582: PPUSH
// begin enable ;
118583: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
118584: LD_ADDR_VAR 0 2
118588: PUSH
118589: LD_INT 22
118591: PUSH
118592: LD_OWVAR 2
118596: PUSH
118597: EMPTY
118598: LIST
118599: LIST
118600: PUSH
118601: LD_INT 2
118603: PUSH
118604: LD_INT 34
118606: PUSH
118607: LD_INT 7
118609: PUSH
118610: EMPTY
118611: LIST
118612: LIST
118613: PUSH
118614: LD_INT 34
118616: PUSH
118617: LD_INT 45
118619: PUSH
118620: EMPTY
118621: LIST
118622: LIST
118623: PUSH
118624: LD_INT 34
118626: PUSH
118627: LD_INT 28
118629: PUSH
118630: EMPTY
118631: LIST
118632: LIST
118633: PUSH
118634: LD_INT 34
118636: PUSH
118637: LD_INT 47
118639: PUSH
118640: EMPTY
118641: LIST
118642: LIST
118643: PUSH
118644: EMPTY
118645: LIST
118646: LIST
118647: LIST
118648: LIST
118649: LIST
118650: PUSH
118651: EMPTY
118652: LIST
118653: LIST
118654: PPUSH
118655: CALL_OW 69
118659: ST_TO_ADDR
// if not tmp then
118660: LD_VAR 0 2
118664: NOT
118665: IFFALSE 118669
// exit ;
118667: GO 118698
// for i in tmp do
118669: LD_ADDR_VAR 0 1
118673: PUSH
118674: LD_VAR 0 2
118678: PUSH
118679: FOR_IN
118680: IFFALSE 118696
// begin SetLives ( i , 0 ) ;
118682: LD_VAR 0 1
118686: PPUSH
118687: LD_INT 0
118689: PPUSH
118690: CALL_OW 234
// end ;
118694: GO 118679
118696: POP
118697: POP
// end ;
118698: PPOPN 2
118700: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
118701: LD_EXP 148
118705: PUSH
118706: LD_EXP 154
118710: AND
118711: IFFALSE 118795
118713: GO 118715
118715: DISABLE
118716: LD_INT 0
118718: PPUSH
118719: PPUSH
// begin enable ;
118720: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
118721: LD_ADDR_VAR 0 2
118725: PUSH
118726: LD_INT 22
118728: PUSH
118729: LD_OWVAR 2
118733: PUSH
118734: EMPTY
118735: LIST
118736: LIST
118737: PUSH
118738: LD_INT 32
118740: PUSH
118741: LD_INT 3
118743: PUSH
118744: EMPTY
118745: LIST
118746: LIST
118747: PUSH
118748: EMPTY
118749: LIST
118750: LIST
118751: PPUSH
118752: CALL_OW 69
118756: ST_TO_ADDR
// if not tmp then
118757: LD_VAR 0 2
118761: NOT
118762: IFFALSE 118766
// exit ;
118764: GO 118795
// for i in tmp do
118766: LD_ADDR_VAR 0 1
118770: PUSH
118771: LD_VAR 0 2
118775: PUSH
118776: FOR_IN
118777: IFFALSE 118793
// begin SetLives ( i , 0 ) ;
118779: LD_VAR 0 1
118783: PPUSH
118784: LD_INT 0
118786: PPUSH
118787: CALL_OW 234
// end ;
118791: GO 118776
118793: POP
118794: POP
// end ;
118795: PPOPN 2
118797: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
118798: LD_EXP 148
118802: PUSH
118803: LD_EXP 151
118807: AND
118808: IFFALSE 118901
118810: GO 118812
118812: DISABLE
118813: LD_INT 0
118815: PPUSH
// begin enable ;
118816: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
118817: LD_ADDR_VAR 0 1
118821: PUSH
118822: LD_INT 22
118824: PUSH
118825: LD_OWVAR 2
118829: PUSH
118830: EMPTY
118831: LIST
118832: LIST
118833: PUSH
118834: LD_INT 2
118836: PUSH
118837: LD_INT 25
118839: PUSH
118840: LD_INT 5
118842: PUSH
118843: EMPTY
118844: LIST
118845: LIST
118846: PUSH
118847: LD_INT 25
118849: PUSH
118850: LD_INT 9
118852: PUSH
118853: EMPTY
118854: LIST
118855: LIST
118856: PUSH
118857: LD_INT 25
118859: PUSH
118860: LD_INT 8
118862: PUSH
118863: EMPTY
118864: LIST
118865: LIST
118866: PUSH
118867: EMPTY
118868: LIST
118869: LIST
118870: LIST
118871: LIST
118872: PUSH
118873: EMPTY
118874: LIST
118875: LIST
118876: PPUSH
118877: CALL_OW 69
118881: PUSH
118882: FOR_IN
118883: IFFALSE 118899
// begin SetClass ( i , 1 ) ;
118885: LD_VAR 0 1
118889: PPUSH
118890: LD_INT 1
118892: PPUSH
118893: CALL_OW 336
// end ;
118897: GO 118882
118899: POP
118900: POP
// end ;
118901: PPOPN 1
118903: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118904: LD_EXP 148
118908: PUSH
118909: LD_EXP 152
118913: AND
118914: PUSH
118915: LD_OWVAR 65
118919: PUSH
118920: LD_INT 7
118922: LESS
118923: AND
118924: IFFALSE 118938
118926: GO 118928
118928: DISABLE
// begin enable ;
118929: ENABLE
// game_speed := 7 ;
118930: LD_ADDR_OWVAR 65
118934: PUSH
118935: LD_INT 7
118937: ST_TO_ADDR
// end ;
118938: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118939: LD_EXP 148
118943: PUSH
118944: LD_EXP 155
118948: AND
118949: IFFALSE 119151
118951: GO 118953
118953: DISABLE
118954: LD_INT 0
118956: PPUSH
118957: PPUSH
118958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118959: LD_ADDR_VAR 0 3
118963: PUSH
118964: LD_INT 81
118966: PUSH
118967: LD_OWVAR 2
118971: PUSH
118972: EMPTY
118973: LIST
118974: LIST
118975: PUSH
118976: LD_INT 21
118978: PUSH
118979: LD_INT 1
118981: PUSH
118982: EMPTY
118983: LIST
118984: LIST
118985: PUSH
118986: EMPTY
118987: LIST
118988: LIST
118989: PPUSH
118990: CALL_OW 69
118994: ST_TO_ADDR
// if not tmp then
118995: LD_VAR 0 3
118999: NOT
119000: IFFALSE 119004
// exit ;
119002: GO 119151
// if tmp > 5 then
119004: LD_VAR 0 3
119008: PUSH
119009: LD_INT 5
119011: GREATER
119012: IFFALSE 119024
// k := 5 else
119014: LD_ADDR_VAR 0 2
119018: PUSH
119019: LD_INT 5
119021: ST_TO_ADDR
119022: GO 119034
// k := tmp ;
119024: LD_ADDR_VAR 0 2
119028: PUSH
119029: LD_VAR 0 3
119033: ST_TO_ADDR
// for i := 1 to k do
119034: LD_ADDR_VAR 0 1
119038: PUSH
119039: DOUBLE
119040: LD_INT 1
119042: DEC
119043: ST_TO_ADDR
119044: LD_VAR 0 2
119048: PUSH
119049: FOR_TO
119050: IFFALSE 119149
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119052: LD_VAR 0 3
119056: PUSH
119057: LD_VAR 0 1
119061: ARRAY
119062: PPUSH
119063: LD_VAR 0 1
119067: PUSH
119068: LD_INT 4
119070: MOD
119071: PUSH
119072: LD_INT 1
119074: PLUS
119075: PPUSH
119076: CALL_OW 259
119080: PUSH
119081: LD_INT 10
119083: LESS
119084: IFFALSE 119147
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119086: LD_VAR 0 3
119090: PUSH
119091: LD_VAR 0 1
119095: ARRAY
119096: PPUSH
119097: LD_VAR 0 1
119101: PUSH
119102: LD_INT 4
119104: MOD
119105: PUSH
119106: LD_INT 1
119108: PLUS
119109: PPUSH
119110: LD_VAR 0 3
119114: PUSH
119115: LD_VAR 0 1
119119: ARRAY
119120: PPUSH
119121: LD_VAR 0 1
119125: PUSH
119126: LD_INT 4
119128: MOD
119129: PUSH
119130: LD_INT 1
119132: PLUS
119133: PPUSH
119134: CALL_OW 259
119138: PUSH
119139: LD_INT 1
119141: PLUS
119142: PPUSH
119143: CALL_OW 237
119147: GO 119049
119149: POP
119150: POP
// end ;
119151: PPOPN 3
119153: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119154: LD_EXP 148
119158: PUSH
119159: LD_EXP 156
119163: AND
119164: IFFALSE 119184
119166: GO 119168
119168: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119169: LD_INT 4
119171: PPUSH
119172: LD_OWVAR 2
119176: PPUSH
119177: LD_INT 0
119179: PPUSH
119180: CALL_OW 324
119184: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119185: LD_EXP 148
119189: PUSH
119190: LD_EXP 185
119194: AND
119195: IFFALSE 119215
119197: GO 119199
119199: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119200: LD_INT 19
119202: PPUSH
119203: LD_OWVAR 2
119207: PPUSH
119208: LD_INT 0
119210: PPUSH
119211: CALL_OW 324
119215: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119216: LD_EXP 148
119220: PUSH
119221: LD_EXP 157
119225: AND
119226: IFFALSE 119328
119228: GO 119230
119230: DISABLE
119231: LD_INT 0
119233: PPUSH
119234: PPUSH
// begin enable ;
119235: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119236: LD_ADDR_VAR 0 2
119240: PUSH
119241: LD_INT 22
119243: PUSH
119244: LD_OWVAR 2
119248: PUSH
119249: EMPTY
119250: LIST
119251: LIST
119252: PUSH
119253: LD_INT 2
119255: PUSH
119256: LD_INT 34
119258: PUSH
119259: LD_INT 11
119261: PUSH
119262: EMPTY
119263: LIST
119264: LIST
119265: PUSH
119266: LD_INT 34
119268: PUSH
119269: LD_INT 30
119271: PUSH
119272: EMPTY
119273: LIST
119274: LIST
119275: PUSH
119276: EMPTY
119277: LIST
119278: LIST
119279: LIST
119280: PUSH
119281: EMPTY
119282: LIST
119283: LIST
119284: PPUSH
119285: CALL_OW 69
119289: ST_TO_ADDR
// if not tmp then
119290: LD_VAR 0 2
119294: NOT
119295: IFFALSE 119299
// exit ;
119297: GO 119328
// for i in tmp do
119299: LD_ADDR_VAR 0 1
119303: PUSH
119304: LD_VAR 0 2
119308: PUSH
119309: FOR_IN
119310: IFFALSE 119326
// begin SetLives ( i , 0 ) ;
119312: LD_VAR 0 1
119316: PPUSH
119317: LD_INT 0
119319: PPUSH
119320: CALL_OW 234
// end ;
119324: GO 119309
119326: POP
119327: POP
// end ;
119328: PPOPN 2
119330: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119331: LD_EXP 148
119335: PUSH
119336: LD_EXP 158
119340: AND
119341: IFFALSE 119361
119343: GO 119345
119345: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119346: LD_INT 32
119348: PPUSH
119349: LD_OWVAR 2
119353: PPUSH
119354: LD_INT 0
119356: PPUSH
119357: CALL_OW 324
119361: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119362: LD_EXP 148
119366: PUSH
119367: LD_EXP 159
119371: AND
119372: IFFALSE 119553
119374: GO 119376
119376: DISABLE
119377: LD_INT 0
119379: PPUSH
119380: PPUSH
119381: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119382: LD_ADDR_VAR 0 2
119386: PUSH
119387: LD_INT 22
119389: PUSH
119390: LD_OWVAR 2
119394: PUSH
119395: EMPTY
119396: LIST
119397: LIST
119398: PUSH
119399: LD_INT 33
119401: PUSH
119402: LD_INT 3
119404: PUSH
119405: EMPTY
119406: LIST
119407: LIST
119408: PUSH
119409: EMPTY
119410: LIST
119411: LIST
119412: PPUSH
119413: CALL_OW 69
119417: ST_TO_ADDR
// if not tmp then
119418: LD_VAR 0 2
119422: NOT
119423: IFFALSE 119427
// exit ;
119425: GO 119553
// side := 0 ;
119427: LD_ADDR_VAR 0 3
119431: PUSH
119432: LD_INT 0
119434: ST_TO_ADDR
// for i := 1 to 8 do
119435: LD_ADDR_VAR 0 1
119439: PUSH
119440: DOUBLE
119441: LD_INT 1
119443: DEC
119444: ST_TO_ADDR
119445: LD_INT 8
119447: PUSH
119448: FOR_TO
119449: IFFALSE 119497
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
119451: LD_OWVAR 2
119455: PUSH
119456: LD_VAR 0 1
119460: NONEQUAL
119461: PUSH
119462: LD_OWVAR 2
119466: PPUSH
119467: LD_VAR 0 1
119471: PPUSH
119472: CALL_OW 81
119476: PUSH
119477: LD_INT 2
119479: EQUAL
119480: AND
119481: IFFALSE 119495
// begin side := i ;
119483: LD_ADDR_VAR 0 3
119487: PUSH
119488: LD_VAR 0 1
119492: ST_TO_ADDR
// break ;
119493: GO 119497
// end ;
119495: GO 119448
119497: POP
119498: POP
// if not side then
119499: LD_VAR 0 3
119503: NOT
119504: IFFALSE 119508
// exit ;
119506: GO 119553
// for i := 1 to tmp do
119508: LD_ADDR_VAR 0 1
119512: PUSH
119513: DOUBLE
119514: LD_INT 1
119516: DEC
119517: ST_TO_ADDR
119518: LD_VAR 0 2
119522: PUSH
119523: FOR_TO
119524: IFFALSE 119551
// if Prob ( 60 ) then
119526: LD_INT 60
119528: PPUSH
119529: CALL_OW 13
119533: IFFALSE 119549
// SetSide ( i , side ) ;
119535: LD_VAR 0 1
119539: PPUSH
119540: LD_VAR 0 3
119544: PPUSH
119545: CALL_OW 235
119549: GO 119523
119551: POP
119552: POP
// end ;
119553: PPOPN 3
119555: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
119556: LD_EXP 148
119560: PUSH
119561: LD_EXP 161
119565: AND
119566: IFFALSE 119685
119568: GO 119570
119570: DISABLE
119571: LD_INT 0
119573: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
119574: LD_ADDR_VAR 0 1
119578: PUSH
119579: LD_INT 22
119581: PUSH
119582: LD_OWVAR 2
119586: PUSH
119587: EMPTY
119588: LIST
119589: LIST
119590: PUSH
119591: LD_INT 21
119593: PUSH
119594: LD_INT 1
119596: PUSH
119597: EMPTY
119598: LIST
119599: LIST
119600: PUSH
119601: LD_INT 3
119603: PUSH
119604: LD_INT 23
119606: PUSH
119607: LD_INT 0
119609: PUSH
119610: EMPTY
119611: LIST
119612: LIST
119613: PUSH
119614: EMPTY
119615: LIST
119616: LIST
119617: PUSH
119618: EMPTY
119619: LIST
119620: LIST
119621: LIST
119622: PPUSH
119623: CALL_OW 69
119627: PUSH
119628: FOR_IN
119629: IFFALSE 119683
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
119631: LD_VAR 0 1
119635: PPUSH
119636: CALL_OW 257
119640: PUSH
119641: LD_INT 1
119643: PUSH
119644: LD_INT 2
119646: PUSH
119647: LD_INT 3
119649: PUSH
119650: LD_INT 4
119652: PUSH
119653: EMPTY
119654: LIST
119655: LIST
119656: LIST
119657: LIST
119658: IN
119659: IFFALSE 119681
// SetClass ( un , rand ( 1 , 4 ) ) ;
119661: LD_VAR 0 1
119665: PPUSH
119666: LD_INT 1
119668: PPUSH
119669: LD_INT 4
119671: PPUSH
119672: CALL_OW 12
119676: PPUSH
119677: CALL_OW 336
119681: GO 119628
119683: POP
119684: POP
// end ;
119685: PPOPN 1
119687: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
119688: LD_EXP 148
119692: PUSH
119693: LD_EXP 160
119697: AND
119698: IFFALSE 119777
119700: GO 119702
119702: DISABLE
119703: LD_INT 0
119705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119706: LD_ADDR_VAR 0 1
119710: PUSH
119711: LD_INT 22
119713: PUSH
119714: LD_OWVAR 2
119718: PUSH
119719: EMPTY
119720: LIST
119721: LIST
119722: PUSH
119723: LD_INT 21
119725: PUSH
119726: LD_INT 3
119728: PUSH
119729: EMPTY
119730: LIST
119731: LIST
119732: PUSH
119733: EMPTY
119734: LIST
119735: LIST
119736: PPUSH
119737: CALL_OW 69
119741: ST_TO_ADDR
// if not tmp then
119742: LD_VAR 0 1
119746: NOT
119747: IFFALSE 119751
// exit ;
119749: GO 119777
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
119751: LD_VAR 0 1
119755: PUSH
119756: LD_INT 1
119758: PPUSH
119759: LD_VAR 0 1
119763: PPUSH
119764: CALL_OW 12
119768: ARRAY
119769: PPUSH
119770: LD_INT 100
119772: PPUSH
119773: CALL_OW 234
// end ;
119777: PPOPN 1
119779: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
119780: LD_EXP 148
119784: PUSH
119785: LD_EXP 162
119789: AND
119790: IFFALSE 119888
119792: GO 119794
119794: DISABLE
119795: LD_INT 0
119797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119798: LD_ADDR_VAR 0 1
119802: PUSH
119803: LD_INT 22
119805: PUSH
119806: LD_OWVAR 2
119810: PUSH
119811: EMPTY
119812: LIST
119813: LIST
119814: PUSH
119815: LD_INT 21
119817: PUSH
119818: LD_INT 1
119820: PUSH
119821: EMPTY
119822: LIST
119823: LIST
119824: PUSH
119825: EMPTY
119826: LIST
119827: LIST
119828: PPUSH
119829: CALL_OW 69
119833: ST_TO_ADDR
// if not tmp then
119834: LD_VAR 0 1
119838: NOT
119839: IFFALSE 119843
// exit ;
119841: GO 119888
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119843: LD_VAR 0 1
119847: PUSH
119848: LD_INT 1
119850: PPUSH
119851: LD_VAR 0 1
119855: PPUSH
119856: CALL_OW 12
119860: ARRAY
119861: PPUSH
119862: LD_INT 1
119864: PPUSH
119865: LD_INT 4
119867: PPUSH
119868: CALL_OW 12
119872: PPUSH
119873: LD_INT 3000
119875: PPUSH
119876: LD_INT 9000
119878: PPUSH
119879: CALL_OW 12
119883: PPUSH
119884: CALL_OW 492
// end ;
119888: PPOPN 1
119890: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119891: LD_EXP 148
119895: PUSH
119896: LD_EXP 163
119900: AND
119901: IFFALSE 119921
119903: GO 119905
119905: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119906: LD_INT 1
119908: PPUSH
119909: LD_OWVAR 2
119913: PPUSH
119914: LD_INT 0
119916: PPUSH
119917: CALL_OW 324
119921: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119922: LD_EXP 148
119926: PUSH
119927: LD_EXP 164
119931: AND
119932: IFFALSE 120015
119934: GO 119936
119936: DISABLE
119937: LD_INT 0
119939: PPUSH
119940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119941: LD_ADDR_VAR 0 2
119945: PUSH
119946: LD_INT 22
119948: PUSH
119949: LD_OWVAR 2
119953: PUSH
119954: EMPTY
119955: LIST
119956: LIST
119957: PUSH
119958: LD_INT 21
119960: PUSH
119961: LD_INT 3
119963: PUSH
119964: EMPTY
119965: LIST
119966: LIST
119967: PUSH
119968: EMPTY
119969: LIST
119970: LIST
119971: PPUSH
119972: CALL_OW 69
119976: ST_TO_ADDR
// if not tmp then
119977: LD_VAR 0 2
119981: NOT
119982: IFFALSE 119986
// exit ;
119984: GO 120015
// for i in tmp do
119986: LD_ADDR_VAR 0 1
119990: PUSH
119991: LD_VAR 0 2
119995: PUSH
119996: FOR_IN
119997: IFFALSE 120013
// SetBLevel ( i , 10 ) ;
119999: LD_VAR 0 1
120003: PPUSH
120004: LD_INT 10
120006: PPUSH
120007: CALL_OW 241
120011: GO 119996
120013: POP
120014: POP
// end ;
120015: PPOPN 2
120017: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120018: LD_EXP 148
120022: PUSH
120023: LD_EXP 165
120027: AND
120028: IFFALSE 120139
120030: GO 120032
120032: DISABLE
120033: LD_INT 0
120035: PPUSH
120036: PPUSH
120037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120038: LD_ADDR_VAR 0 3
120042: PUSH
120043: LD_INT 22
120045: PUSH
120046: LD_OWVAR 2
120050: PUSH
120051: EMPTY
120052: LIST
120053: LIST
120054: PUSH
120055: LD_INT 25
120057: PUSH
120058: LD_INT 1
120060: PUSH
120061: EMPTY
120062: LIST
120063: LIST
120064: PUSH
120065: EMPTY
120066: LIST
120067: LIST
120068: PPUSH
120069: CALL_OW 69
120073: ST_TO_ADDR
// if not tmp then
120074: LD_VAR 0 3
120078: NOT
120079: IFFALSE 120083
// exit ;
120081: GO 120139
// un := tmp [ rand ( 1 , tmp ) ] ;
120083: LD_ADDR_VAR 0 2
120087: PUSH
120088: LD_VAR 0 3
120092: PUSH
120093: LD_INT 1
120095: PPUSH
120096: LD_VAR 0 3
120100: PPUSH
120101: CALL_OW 12
120105: ARRAY
120106: ST_TO_ADDR
// if Crawls ( un ) then
120107: LD_VAR 0 2
120111: PPUSH
120112: CALL_OW 318
120116: IFFALSE 120127
// ComWalk ( un ) ;
120118: LD_VAR 0 2
120122: PPUSH
120123: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120127: LD_VAR 0 2
120131: PPUSH
120132: LD_INT 5
120134: PPUSH
120135: CALL_OW 336
// end ;
120139: PPOPN 3
120141: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120142: LD_EXP 148
120146: PUSH
120147: LD_EXP 166
120151: AND
120152: PUSH
120153: LD_OWVAR 67
120157: PUSH
120158: LD_INT 4
120160: LESS
120161: AND
120162: IFFALSE 120181
120164: GO 120166
120166: DISABLE
// begin Difficulty := Difficulty + 1 ;
120167: LD_ADDR_OWVAR 67
120171: PUSH
120172: LD_OWVAR 67
120176: PUSH
120177: LD_INT 1
120179: PLUS
120180: ST_TO_ADDR
// end ;
120181: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120182: LD_EXP 148
120186: PUSH
120187: LD_EXP 167
120191: AND
120192: IFFALSE 120295
120194: GO 120196
120196: DISABLE
120197: LD_INT 0
120199: PPUSH
// begin for i := 1 to 5 do
120200: LD_ADDR_VAR 0 1
120204: PUSH
120205: DOUBLE
120206: LD_INT 1
120208: DEC
120209: ST_TO_ADDR
120210: LD_INT 5
120212: PUSH
120213: FOR_TO
120214: IFFALSE 120293
// begin uc_nation := nation_nature ;
120216: LD_ADDR_OWVAR 21
120220: PUSH
120221: LD_INT 0
120223: ST_TO_ADDR
// uc_side := 0 ;
120224: LD_ADDR_OWVAR 20
120228: PUSH
120229: LD_INT 0
120231: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120232: LD_ADDR_OWVAR 29
120236: PUSH
120237: LD_INT 12
120239: PUSH
120240: LD_INT 12
120242: PUSH
120243: EMPTY
120244: LIST
120245: LIST
120246: ST_TO_ADDR
// hc_agressivity := 20 ;
120247: LD_ADDR_OWVAR 35
120251: PUSH
120252: LD_INT 20
120254: ST_TO_ADDR
// hc_class := class_tiger ;
120255: LD_ADDR_OWVAR 28
120259: PUSH
120260: LD_INT 14
120262: ST_TO_ADDR
// hc_gallery :=  ;
120263: LD_ADDR_OWVAR 33
120267: PUSH
120268: LD_STRING 
120270: ST_TO_ADDR
// hc_name :=  ;
120271: LD_ADDR_OWVAR 26
120275: PUSH
120276: LD_STRING 
120278: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120279: CALL_OW 44
120283: PPUSH
120284: LD_INT 0
120286: PPUSH
120287: CALL_OW 51
// end ;
120291: GO 120213
120293: POP
120294: POP
// end ;
120295: PPOPN 1
120297: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120298: LD_EXP 148
120302: PUSH
120303: LD_EXP 168
120307: AND
120308: IFFALSE 120317
120310: GO 120312
120312: DISABLE
// StreamSibBomb ;
120313: CALL 120318 0 0
120317: END
// export function StreamSibBomb ; var i , x , y ; begin
120318: LD_INT 0
120320: PPUSH
120321: PPUSH
120322: PPUSH
120323: PPUSH
// result := false ;
120324: LD_ADDR_VAR 0 1
120328: PUSH
120329: LD_INT 0
120331: ST_TO_ADDR
// for i := 1 to 16 do
120332: LD_ADDR_VAR 0 2
120336: PUSH
120337: DOUBLE
120338: LD_INT 1
120340: DEC
120341: ST_TO_ADDR
120342: LD_INT 16
120344: PUSH
120345: FOR_TO
120346: IFFALSE 120545
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120348: LD_ADDR_VAR 0 3
120352: PUSH
120353: LD_INT 10
120355: PUSH
120356: LD_INT 20
120358: PUSH
120359: LD_INT 30
120361: PUSH
120362: LD_INT 40
120364: PUSH
120365: LD_INT 50
120367: PUSH
120368: LD_INT 60
120370: PUSH
120371: LD_INT 70
120373: PUSH
120374: LD_INT 80
120376: PUSH
120377: LD_INT 90
120379: PUSH
120380: LD_INT 100
120382: PUSH
120383: LD_INT 110
120385: PUSH
120386: LD_INT 120
120388: PUSH
120389: LD_INT 130
120391: PUSH
120392: LD_INT 140
120394: PUSH
120395: LD_INT 150
120397: PUSH
120398: EMPTY
120399: LIST
120400: LIST
120401: LIST
120402: LIST
120403: LIST
120404: LIST
120405: LIST
120406: LIST
120407: LIST
120408: LIST
120409: LIST
120410: LIST
120411: LIST
120412: LIST
120413: LIST
120414: PUSH
120415: LD_INT 1
120417: PPUSH
120418: LD_INT 15
120420: PPUSH
120421: CALL_OW 12
120425: ARRAY
120426: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120427: LD_ADDR_VAR 0 4
120431: PUSH
120432: LD_INT 10
120434: PUSH
120435: LD_INT 20
120437: PUSH
120438: LD_INT 30
120440: PUSH
120441: LD_INT 40
120443: PUSH
120444: LD_INT 50
120446: PUSH
120447: LD_INT 60
120449: PUSH
120450: LD_INT 70
120452: PUSH
120453: LD_INT 80
120455: PUSH
120456: LD_INT 90
120458: PUSH
120459: LD_INT 100
120461: PUSH
120462: LD_INT 110
120464: PUSH
120465: LD_INT 120
120467: PUSH
120468: LD_INT 130
120470: PUSH
120471: LD_INT 140
120473: PUSH
120474: LD_INT 150
120476: PUSH
120477: EMPTY
120478: LIST
120479: LIST
120480: LIST
120481: LIST
120482: LIST
120483: LIST
120484: LIST
120485: LIST
120486: LIST
120487: LIST
120488: LIST
120489: LIST
120490: LIST
120491: LIST
120492: LIST
120493: PUSH
120494: LD_INT 1
120496: PPUSH
120497: LD_INT 15
120499: PPUSH
120500: CALL_OW 12
120504: ARRAY
120505: ST_TO_ADDR
// if ValidHex ( x , y ) then
120506: LD_VAR 0 3
120510: PPUSH
120511: LD_VAR 0 4
120515: PPUSH
120516: CALL_OW 488
120520: IFFALSE 120543
// begin result := [ x , y ] ;
120522: LD_ADDR_VAR 0 1
120526: PUSH
120527: LD_VAR 0 3
120531: PUSH
120532: LD_VAR 0 4
120536: PUSH
120537: EMPTY
120538: LIST
120539: LIST
120540: ST_TO_ADDR
// break ;
120541: GO 120545
// end ; end ;
120543: GO 120345
120545: POP
120546: POP
// if result then
120547: LD_VAR 0 1
120551: IFFALSE 120611
// begin ToLua ( playSibBomb() ) ;
120553: LD_STRING playSibBomb()
120555: PPUSH
120556: CALL_OW 559
// wait ( 0 0$14 ) ;
120560: LD_INT 490
120562: PPUSH
120563: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
120567: LD_VAR 0 1
120571: PUSH
120572: LD_INT 1
120574: ARRAY
120575: PPUSH
120576: LD_VAR 0 1
120580: PUSH
120581: LD_INT 2
120583: ARRAY
120584: PPUSH
120585: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
120589: LD_VAR 0 1
120593: PUSH
120594: LD_INT 1
120596: ARRAY
120597: PPUSH
120598: LD_VAR 0 1
120602: PUSH
120603: LD_INT 2
120605: ARRAY
120606: PPUSH
120607: CALL_OW 429
// end ; end ;
120611: LD_VAR 0 1
120615: RET
// every 0 0$1 trigger StreamModeActive and sReset do
120616: LD_EXP 148
120620: PUSH
120621: LD_EXP 170
120625: AND
120626: IFFALSE 120638
120628: GO 120630
120630: DISABLE
// YouLost (  ) ;
120631: LD_STRING 
120633: PPUSH
120634: CALL_OW 104
120638: END
// every 0 0$1 trigger StreamModeActive and sFog do
120639: LD_EXP 148
120643: PUSH
120644: LD_EXP 169
120648: AND
120649: IFFALSE 120663
120651: GO 120653
120653: DISABLE
// FogOff ( your_side ) ;
120654: LD_OWVAR 2
120658: PPUSH
120659: CALL_OW 344
120663: END
// every 0 0$1 trigger StreamModeActive and sSun do
120664: LD_EXP 148
120668: PUSH
120669: LD_EXP 171
120673: AND
120674: IFFALSE 120702
120676: GO 120678
120678: DISABLE
// begin solar_recharge_percent := 0 ;
120679: LD_ADDR_OWVAR 79
120683: PUSH
120684: LD_INT 0
120686: ST_TO_ADDR
// wait ( 5 5$00 ) ;
120687: LD_INT 10500
120689: PPUSH
120690: CALL_OW 67
// solar_recharge_percent := 100 ;
120694: LD_ADDR_OWVAR 79
120698: PUSH
120699: LD_INT 100
120701: ST_TO_ADDR
// end ;
120702: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
120703: LD_EXP 148
120707: PUSH
120708: LD_EXP 172
120712: AND
120713: IFFALSE 120952
120715: GO 120717
120717: DISABLE
120718: LD_INT 0
120720: PPUSH
120721: PPUSH
120722: PPUSH
// begin tmp := [ ] ;
120723: LD_ADDR_VAR 0 3
120727: PUSH
120728: EMPTY
120729: ST_TO_ADDR
// for i := 1 to 6 do
120730: LD_ADDR_VAR 0 1
120734: PUSH
120735: DOUBLE
120736: LD_INT 1
120738: DEC
120739: ST_TO_ADDR
120740: LD_INT 6
120742: PUSH
120743: FOR_TO
120744: IFFALSE 120849
// begin uc_nation := nation_nature ;
120746: LD_ADDR_OWVAR 21
120750: PUSH
120751: LD_INT 0
120753: ST_TO_ADDR
// uc_side := 0 ;
120754: LD_ADDR_OWVAR 20
120758: PUSH
120759: LD_INT 0
120761: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120762: LD_ADDR_OWVAR 29
120766: PUSH
120767: LD_INT 12
120769: PUSH
120770: LD_INT 12
120772: PUSH
120773: EMPTY
120774: LIST
120775: LIST
120776: ST_TO_ADDR
// hc_agressivity := 20 ;
120777: LD_ADDR_OWVAR 35
120781: PUSH
120782: LD_INT 20
120784: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
120785: LD_ADDR_OWVAR 28
120789: PUSH
120790: LD_INT 17
120792: ST_TO_ADDR
// hc_gallery :=  ;
120793: LD_ADDR_OWVAR 33
120797: PUSH
120798: LD_STRING 
120800: ST_TO_ADDR
// hc_name :=  ;
120801: LD_ADDR_OWVAR 26
120805: PUSH
120806: LD_STRING 
120808: ST_TO_ADDR
// un := CreateHuman ;
120809: LD_ADDR_VAR 0 2
120813: PUSH
120814: CALL_OW 44
120818: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
120819: LD_VAR 0 2
120823: PPUSH
120824: LD_INT 1
120826: PPUSH
120827: CALL_OW 51
// tmp := tmp ^ un ;
120831: LD_ADDR_VAR 0 3
120835: PUSH
120836: LD_VAR 0 3
120840: PUSH
120841: LD_VAR 0 2
120845: ADD
120846: ST_TO_ADDR
// end ;
120847: GO 120743
120849: POP
120850: POP
// repeat wait ( 0 0$1 ) ;
120851: LD_INT 35
120853: PPUSH
120854: CALL_OW 67
// for un in tmp do
120858: LD_ADDR_VAR 0 2
120862: PUSH
120863: LD_VAR 0 3
120867: PUSH
120868: FOR_IN
120869: IFFALSE 120943
// begin if IsDead ( un ) then
120871: LD_VAR 0 2
120875: PPUSH
120876: CALL_OW 301
120880: IFFALSE 120900
// begin tmp := tmp diff un ;
120882: LD_ADDR_VAR 0 3
120886: PUSH
120887: LD_VAR 0 3
120891: PUSH
120892: LD_VAR 0 2
120896: DIFF
120897: ST_TO_ADDR
// continue ;
120898: GO 120868
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120900: LD_VAR 0 2
120904: PPUSH
120905: LD_INT 3
120907: PUSH
120908: LD_INT 22
120910: PUSH
120911: LD_INT 0
120913: PUSH
120914: EMPTY
120915: LIST
120916: LIST
120917: PUSH
120918: EMPTY
120919: LIST
120920: LIST
120921: PPUSH
120922: CALL_OW 69
120926: PPUSH
120927: LD_VAR 0 2
120931: PPUSH
120932: CALL_OW 74
120936: PPUSH
120937: CALL_OW 115
// end ;
120941: GO 120868
120943: POP
120944: POP
// until not tmp ;
120945: LD_VAR 0 3
120949: NOT
120950: IFFALSE 120851
// end ;
120952: PPOPN 3
120954: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120955: LD_EXP 148
120959: PUSH
120960: LD_EXP 173
120964: AND
120965: IFFALSE 121019
120967: GO 120969
120969: DISABLE
// begin ToLua ( displayTroll(); ) ;
120970: LD_STRING displayTroll();
120972: PPUSH
120973: CALL_OW 559
// wait ( 3 3$00 ) ;
120977: LD_INT 6300
120979: PPUSH
120980: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120984: LD_STRING hideTroll();
120986: PPUSH
120987: CALL_OW 559
// wait ( 1 1$00 ) ;
120991: LD_INT 2100
120993: PPUSH
120994: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120998: LD_STRING displayTroll();
121000: PPUSH
121001: CALL_OW 559
// wait ( 1 1$00 ) ;
121005: LD_INT 2100
121007: PPUSH
121008: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121012: LD_STRING hideTroll();
121014: PPUSH
121015: CALL_OW 559
// end ;
121019: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121020: LD_EXP 148
121024: PUSH
121025: LD_EXP 174
121029: AND
121030: IFFALSE 121093
121032: GO 121034
121034: DISABLE
121035: LD_INT 0
121037: PPUSH
// begin p := 0 ;
121038: LD_ADDR_VAR 0 1
121042: PUSH
121043: LD_INT 0
121045: ST_TO_ADDR
// repeat game_speed := 1 ;
121046: LD_ADDR_OWVAR 65
121050: PUSH
121051: LD_INT 1
121053: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121054: LD_INT 35
121056: PPUSH
121057: CALL_OW 67
// p := p + 1 ;
121061: LD_ADDR_VAR 0 1
121065: PUSH
121066: LD_VAR 0 1
121070: PUSH
121071: LD_INT 1
121073: PLUS
121074: ST_TO_ADDR
// until p >= 60 ;
121075: LD_VAR 0 1
121079: PUSH
121080: LD_INT 60
121082: GREATEREQUAL
121083: IFFALSE 121046
// game_speed := 4 ;
121085: LD_ADDR_OWVAR 65
121089: PUSH
121090: LD_INT 4
121092: ST_TO_ADDR
// end ;
121093: PPOPN 1
121095: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121096: LD_EXP 148
121100: PUSH
121101: LD_EXP 175
121105: AND
121106: IFFALSE 121252
121108: GO 121110
121110: DISABLE
121111: LD_INT 0
121113: PPUSH
121114: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121115: LD_ADDR_VAR 0 1
121119: PUSH
121120: LD_INT 22
121122: PUSH
121123: LD_OWVAR 2
121127: PUSH
121128: EMPTY
121129: LIST
121130: LIST
121131: PUSH
121132: LD_INT 2
121134: PUSH
121135: LD_INT 30
121137: PUSH
121138: LD_INT 0
121140: PUSH
121141: EMPTY
121142: LIST
121143: LIST
121144: PUSH
121145: LD_INT 30
121147: PUSH
121148: LD_INT 1
121150: PUSH
121151: EMPTY
121152: LIST
121153: LIST
121154: PUSH
121155: EMPTY
121156: LIST
121157: LIST
121158: LIST
121159: PUSH
121160: EMPTY
121161: LIST
121162: LIST
121163: PPUSH
121164: CALL_OW 69
121168: ST_TO_ADDR
// if not depot then
121169: LD_VAR 0 1
121173: NOT
121174: IFFALSE 121178
// exit ;
121176: GO 121252
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121178: LD_ADDR_VAR 0 2
121182: PUSH
121183: LD_VAR 0 1
121187: PUSH
121188: LD_INT 1
121190: PPUSH
121191: LD_VAR 0 1
121195: PPUSH
121196: CALL_OW 12
121200: ARRAY
121201: PPUSH
121202: CALL_OW 274
121206: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121207: LD_VAR 0 2
121211: PPUSH
121212: LD_INT 1
121214: PPUSH
121215: LD_INT 0
121217: PPUSH
121218: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121222: LD_VAR 0 2
121226: PPUSH
121227: LD_INT 2
121229: PPUSH
121230: LD_INT 0
121232: PPUSH
121233: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121237: LD_VAR 0 2
121241: PPUSH
121242: LD_INT 3
121244: PPUSH
121245: LD_INT 0
121247: PPUSH
121248: CALL_OW 277
// end ;
121252: PPOPN 2
121254: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121255: LD_EXP 148
121259: PUSH
121260: LD_EXP 176
121264: AND
121265: IFFALSE 121362
121267: GO 121269
121269: DISABLE
121270: LD_INT 0
121272: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121273: LD_ADDR_VAR 0 1
121277: PUSH
121278: LD_INT 22
121280: PUSH
121281: LD_OWVAR 2
121285: PUSH
121286: EMPTY
121287: LIST
121288: LIST
121289: PUSH
121290: LD_INT 21
121292: PUSH
121293: LD_INT 1
121295: PUSH
121296: EMPTY
121297: LIST
121298: LIST
121299: PUSH
121300: LD_INT 3
121302: PUSH
121303: LD_INT 23
121305: PUSH
121306: LD_INT 0
121308: PUSH
121309: EMPTY
121310: LIST
121311: LIST
121312: PUSH
121313: EMPTY
121314: LIST
121315: LIST
121316: PUSH
121317: EMPTY
121318: LIST
121319: LIST
121320: LIST
121321: PPUSH
121322: CALL_OW 69
121326: ST_TO_ADDR
// if not tmp then
121327: LD_VAR 0 1
121331: NOT
121332: IFFALSE 121336
// exit ;
121334: GO 121362
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121336: LD_VAR 0 1
121340: PUSH
121341: LD_INT 1
121343: PPUSH
121344: LD_VAR 0 1
121348: PPUSH
121349: CALL_OW 12
121353: ARRAY
121354: PPUSH
121355: LD_INT 200
121357: PPUSH
121358: CALL_OW 234
// end ;
121362: PPOPN 1
121364: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121365: LD_EXP 148
121369: PUSH
121370: LD_EXP 177
121374: AND
121375: IFFALSE 121454
121377: GO 121379
121379: DISABLE
121380: LD_INT 0
121382: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121383: LD_ADDR_VAR 0 1
121387: PUSH
121388: LD_INT 22
121390: PUSH
121391: LD_OWVAR 2
121395: PUSH
121396: EMPTY
121397: LIST
121398: LIST
121399: PUSH
121400: LD_INT 21
121402: PUSH
121403: LD_INT 2
121405: PUSH
121406: EMPTY
121407: LIST
121408: LIST
121409: PUSH
121410: EMPTY
121411: LIST
121412: LIST
121413: PPUSH
121414: CALL_OW 69
121418: ST_TO_ADDR
// if not tmp then
121419: LD_VAR 0 1
121423: NOT
121424: IFFALSE 121428
// exit ;
121426: GO 121454
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121428: LD_VAR 0 1
121432: PUSH
121433: LD_INT 1
121435: PPUSH
121436: LD_VAR 0 1
121440: PPUSH
121441: CALL_OW 12
121445: ARRAY
121446: PPUSH
121447: LD_INT 60
121449: PPUSH
121450: CALL_OW 234
// end ;
121454: PPOPN 1
121456: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
121457: LD_EXP 148
121461: PUSH
121462: LD_EXP 178
121466: AND
121467: IFFALSE 121566
121469: GO 121471
121471: DISABLE
121472: LD_INT 0
121474: PPUSH
121475: PPUSH
// begin enable ;
121476: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
121477: LD_ADDR_VAR 0 1
121481: PUSH
121482: LD_INT 22
121484: PUSH
121485: LD_OWVAR 2
121489: PUSH
121490: EMPTY
121491: LIST
121492: LIST
121493: PUSH
121494: LD_INT 61
121496: PUSH
121497: EMPTY
121498: LIST
121499: PUSH
121500: LD_INT 33
121502: PUSH
121503: LD_INT 2
121505: PUSH
121506: EMPTY
121507: LIST
121508: LIST
121509: PUSH
121510: EMPTY
121511: LIST
121512: LIST
121513: LIST
121514: PPUSH
121515: CALL_OW 69
121519: ST_TO_ADDR
// if not tmp then
121520: LD_VAR 0 1
121524: NOT
121525: IFFALSE 121529
// exit ;
121527: GO 121566
// for i in tmp do
121529: LD_ADDR_VAR 0 2
121533: PUSH
121534: LD_VAR 0 1
121538: PUSH
121539: FOR_IN
121540: IFFALSE 121564
// if IsControledBy ( i ) then
121542: LD_VAR 0 2
121546: PPUSH
121547: CALL_OW 312
121551: IFFALSE 121562
// ComUnlink ( i ) ;
121553: LD_VAR 0 2
121557: PPUSH
121558: CALL_OW 136
121562: GO 121539
121564: POP
121565: POP
// end ;
121566: PPOPN 2
121568: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
121569: LD_EXP 148
121573: PUSH
121574: LD_EXP 179
121578: AND
121579: IFFALSE 121719
121581: GO 121583
121583: DISABLE
121584: LD_INT 0
121586: PPUSH
121587: PPUSH
// begin ToLua ( displayPowell(); ) ;
121588: LD_STRING displayPowell();
121590: PPUSH
121591: CALL_OW 559
// uc_side := 0 ;
121595: LD_ADDR_OWVAR 20
121599: PUSH
121600: LD_INT 0
121602: ST_TO_ADDR
// uc_nation := 2 ;
121603: LD_ADDR_OWVAR 21
121607: PUSH
121608: LD_INT 2
121610: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
121611: LD_ADDR_OWVAR 37
121615: PUSH
121616: LD_INT 14
121618: ST_TO_ADDR
// vc_engine := engine_siberite ;
121619: LD_ADDR_OWVAR 39
121623: PUSH
121624: LD_INT 3
121626: ST_TO_ADDR
// vc_control := control_apeman ;
121627: LD_ADDR_OWVAR 38
121631: PUSH
121632: LD_INT 5
121634: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
121635: LD_ADDR_OWVAR 40
121639: PUSH
121640: LD_INT 29
121642: ST_TO_ADDR
// un := CreateVehicle ;
121643: LD_ADDR_VAR 0 2
121647: PUSH
121648: CALL_OW 45
121652: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121653: LD_VAR 0 2
121657: PPUSH
121658: LD_INT 1
121660: PPUSH
121661: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121665: LD_INT 35
121667: PPUSH
121668: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121672: LD_VAR 0 2
121676: PPUSH
121677: LD_INT 22
121679: PUSH
121680: LD_OWVAR 2
121684: PUSH
121685: EMPTY
121686: LIST
121687: LIST
121688: PPUSH
121689: CALL_OW 69
121693: PPUSH
121694: LD_VAR 0 2
121698: PPUSH
121699: CALL_OW 74
121703: PPUSH
121704: CALL_OW 115
// until IsDead ( un ) ;
121708: LD_VAR 0 2
121712: PPUSH
121713: CALL_OW 301
121717: IFFALSE 121665
// end ;
121719: PPOPN 2
121721: END
// every 0 0$1 trigger StreamModeActive and sStu do
121722: LD_EXP 148
121726: PUSH
121727: LD_EXP 187
121731: AND
121732: IFFALSE 121748
121734: GO 121736
121736: DISABLE
// begin ToLua ( displayStucuk(); ) ;
121737: LD_STRING displayStucuk();
121739: PPUSH
121740: CALL_OW 559
// ResetFog ;
121744: CALL_OW 335
// end ;
121748: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
121749: LD_EXP 148
121753: PUSH
121754: LD_EXP 180
121758: AND
121759: IFFALSE 121900
121761: GO 121763
121763: DISABLE
121764: LD_INT 0
121766: PPUSH
121767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121768: LD_ADDR_VAR 0 2
121772: PUSH
121773: LD_INT 22
121775: PUSH
121776: LD_OWVAR 2
121780: PUSH
121781: EMPTY
121782: LIST
121783: LIST
121784: PUSH
121785: LD_INT 21
121787: PUSH
121788: LD_INT 1
121790: PUSH
121791: EMPTY
121792: LIST
121793: LIST
121794: PUSH
121795: EMPTY
121796: LIST
121797: LIST
121798: PPUSH
121799: CALL_OW 69
121803: ST_TO_ADDR
// if not tmp then
121804: LD_VAR 0 2
121808: NOT
121809: IFFALSE 121813
// exit ;
121811: GO 121900
// un := tmp [ rand ( 1 , tmp ) ] ;
121813: LD_ADDR_VAR 0 1
121817: PUSH
121818: LD_VAR 0 2
121822: PUSH
121823: LD_INT 1
121825: PPUSH
121826: LD_VAR 0 2
121830: PPUSH
121831: CALL_OW 12
121835: ARRAY
121836: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121837: LD_VAR 0 1
121841: PPUSH
121842: LD_INT 0
121844: PPUSH
121845: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121849: LD_VAR 0 1
121853: PPUSH
121854: LD_OWVAR 3
121858: PUSH
121859: LD_VAR 0 1
121863: DIFF
121864: PPUSH
121865: LD_VAR 0 1
121869: PPUSH
121870: CALL_OW 74
121874: PPUSH
121875: CALL_OW 115
// wait ( 0 0$20 ) ;
121879: LD_INT 700
121881: PPUSH
121882: CALL_OW 67
// SetSide ( un , your_side ) ;
121886: LD_VAR 0 1
121890: PPUSH
121891: LD_OWVAR 2
121895: PPUSH
121896: CALL_OW 235
// end ;
121900: PPOPN 2
121902: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121903: LD_EXP 148
121907: PUSH
121908: LD_EXP 181
121912: AND
121913: IFFALSE 122019
121915: GO 121917
121917: DISABLE
121918: LD_INT 0
121920: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121921: LD_ADDR_VAR 0 1
121925: PUSH
121926: LD_INT 22
121928: PUSH
121929: LD_OWVAR 2
121933: PUSH
121934: EMPTY
121935: LIST
121936: LIST
121937: PUSH
121938: LD_INT 2
121940: PUSH
121941: LD_INT 30
121943: PUSH
121944: LD_INT 0
121946: PUSH
121947: EMPTY
121948: LIST
121949: LIST
121950: PUSH
121951: LD_INT 30
121953: PUSH
121954: LD_INT 1
121956: PUSH
121957: EMPTY
121958: LIST
121959: LIST
121960: PUSH
121961: EMPTY
121962: LIST
121963: LIST
121964: LIST
121965: PUSH
121966: EMPTY
121967: LIST
121968: LIST
121969: PPUSH
121970: CALL_OW 69
121974: ST_TO_ADDR
// if not depot then
121975: LD_VAR 0 1
121979: NOT
121980: IFFALSE 121984
// exit ;
121982: GO 122019
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121984: LD_VAR 0 1
121988: PUSH
121989: LD_INT 1
121991: ARRAY
121992: PPUSH
121993: CALL_OW 250
121997: PPUSH
121998: LD_VAR 0 1
122002: PUSH
122003: LD_INT 1
122005: ARRAY
122006: PPUSH
122007: CALL_OW 251
122011: PPUSH
122012: LD_INT 70
122014: PPUSH
122015: CALL_OW 495
// end ;
122019: PPOPN 1
122021: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122022: LD_EXP 148
122026: PUSH
122027: LD_EXP 182
122031: AND
122032: IFFALSE 122243
122034: GO 122036
122036: DISABLE
122037: LD_INT 0
122039: PPUSH
122040: PPUSH
122041: PPUSH
122042: PPUSH
122043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122044: LD_ADDR_VAR 0 5
122048: PUSH
122049: LD_INT 22
122051: PUSH
122052: LD_OWVAR 2
122056: PUSH
122057: EMPTY
122058: LIST
122059: LIST
122060: PUSH
122061: LD_INT 21
122063: PUSH
122064: LD_INT 1
122066: PUSH
122067: EMPTY
122068: LIST
122069: LIST
122070: PUSH
122071: EMPTY
122072: LIST
122073: LIST
122074: PPUSH
122075: CALL_OW 69
122079: ST_TO_ADDR
// if not tmp then
122080: LD_VAR 0 5
122084: NOT
122085: IFFALSE 122089
// exit ;
122087: GO 122243
// for i in tmp do
122089: LD_ADDR_VAR 0 1
122093: PUSH
122094: LD_VAR 0 5
122098: PUSH
122099: FOR_IN
122100: IFFALSE 122241
// begin d := rand ( 0 , 5 ) ;
122102: LD_ADDR_VAR 0 4
122106: PUSH
122107: LD_INT 0
122109: PPUSH
122110: LD_INT 5
122112: PPUSH
122113: CALL_OW 12
122117: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122118: LD_ADDR_VAR 0 2
122122: PUSH
122123: LD_VAR 0 1
122127: PPUSH
122128: CALL_OW 250
122132: PPUSH
122133: LD_VAR 0 4
122137: PPUSH
122138: LD_INT 3
122140: PPUSH
122141: LD_INT 12
122143: PPUSH
122144: CALL_OW 12
122148: PPUSH
122149: CALL_OW 272
122153: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122154: LD_ADDR_VAR 0 3
122158: PUSH
122159: LD_VAR 0 1
122163: PPUSH
122164: CALL_OW 251
122168: PPUSH
122169: LD_VAR 0 4
122173: PPUSH
122174: LD_INT 3
122176: PPUSH
122177: LD_INT 12
122179: PPUSH
122180: CALL_OW 12
122184: PPUSH
122185: CALL_OW 273
122189: ST_TO_ADDR
// if ValidHex ( x , y ) then
122190: LD_VAR 0 2
122194: PPUSH
122195: LD_VAR 0 3
122199: PPUSH
122200: CALL_OW 488
122204: IFFALSE 122239
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122206: LD_VAR 0 1
122210: PPUSH
122211: LD_VAR 0 2
122215: PPUSH
122216: LD_VAR 0 3
122220: PPUSH
122221: LD_INT 3
122223: PPUSH
122224: LD_INT 6
122226: PPUSH
122227: CALL_OW 12
122231: PPUSH
122232: LD_INT 1
122234: PPUSH
122235: CALL_OW 483
// end ;
122239: GO 122099
122241: POP
122242: POP
// end ;
122243: PPOPN 5
122245: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122246: LD_EXP 148
122250: PUSH
122251: LD_EXP 183
122255: AND
122256: IFFALSE 122350
122258: GO 122260
122260: DISABLE
122261: LD_INT 0
122263: PPUSH
122264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122265: LD_ADDR_VAR 0 2
122269: PUSH
122270: LD_INT 22
122272: PUSH
122273: LD_OWVAR 2
122277: PUSH
122278: EMPTY
122279: LIST
122280: LIST
122281: PUSH
122282: LD_INT 32
122284: PUSH
122285: LD_INT 1
122287: PUSH
122288: EMPTY
122289: LIST
122290: LIST
122291: PUSH
122292: LD_INT 21
122294: PUSH
122295: LD_INT 2
122297: PUSH
122298: EMPTY
122299: LIST
122300: LIST
122301: PUSH
122302: EMPTY
122303: LIST
122304: LIST
122305: LIST
122306: PPUSH
122307: CALL_OW 69
122311: ST_TO_ADDR
// if not tmp then
122312: LD_VAR 0 2
122316: NOT
122317: IFFALSE 122321
// exit ;
122319: GO 122350
// for i in tmp do
122321: LD_ADDR_VAR 0 1
122325: PUSH
122326: LD_VAR 0 2
122330: PUSH
122331: FOR_IN
122332: IFFALSE 122348
// SetFuel ( i , 0 ) ;
122334: LD_VAR 0 1
122338: PPUSH
122339: LD_INT 0
122341: PPUSH
122342: CALL_OW 240
122346: GO 122331
122348: POP
122349: POP
// end ;
122350: PPOPN 2
122352: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122353: LD_EXP 148
122357: PUSH
122358: LD_EXP 184
122362: AND
122363: IFFALSE 122429
122365: GO 122367
122367: DISABLE
122368: LD_INT 0
122370: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122371: LD_ADDR_VAR 0 1
122375: PUSH
122376: LD_INT 22
122378: PUSH
122379: LD_OWVAR 2
122383: PUSH
122384: EMPTY
122385: LIST
122386: LIST
122387: PUSH
122388: LD_INT 30
122390: PUSH
122391: LD_INT 29
122393: PUSH
122394: EMPTY
122395: LIST
122396: LIST
122397: PUSH
122398: EMPTY
122399: LIST
122400: LIST
122401: PPUSH
122402: CALL_OW 69
122406: ST_TO_ADDR
// if not tmp then
122407: LD_VAR 0 1
122411: NOT
122412: IFFALSE 122416
// exit ;
122414: GO 122429
// DestroyUnit ( tmp [ 1 ] ) ;
122416: LD_VAR 0 1
122420: PUSH
122421: LD_INT 1
122423: ARRAY
122424: PPUSH
122425: CALL_OW 65
// end ;
122429: PPOPN 1
122431: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
122432: LD_EXP 148
122436: PUSH
122437: LD_EXP 186
122441: AND
122442: IFFALSE 122571
122444: GO 122446
122446: DISABLE
122447: LD_INT 0
122449: PPUSH
// begin uc_side := 0 ;
122450: LD_ADDR_OWVAR 20
122454: PUSH
122455: LD_INT 0
122457: ST_TO_ADDR
// uc_nation := nation_arabian ;
122458: LD_ADDR_OWVAR 21
122462: PUSH
122463: LD_INT 2
122465: ST_TO_ADDR
// hc_gallery :=  ;
122466: LD_ADDR_OWVAR 33
122470: PUSH
122471: LD_STRING 
122473: ST_TO_ADDR
// hc_name :=  ;
122474: LD_ADDR_OWVAR 26
122478: PUSH
122479: LD_STRING 
122481: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
122482: LD_INT 1
122484: PPUSH
122485: LD_INT 11
122487: PPUSH
122488: LD_INT 10
122490: PPUSH
122491: CALL_OW 380
// un := CreateHuman ;
122495: LD_ADDR_VAR 0 1
122499: PUSH
122500: CALL_OW 44
122504: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122505: LD_VAR 0 1
122509: PPUSH
122510: LD_INT 1
122512: PPUSH
122513: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122517: LD_INT 35
122519: PPUSH
122520: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122524: LD_VAR 0 1
122528: PPUSH
122529: LD_INT 22
122531: PUSH
122532: LD_OWVAR 2
122536: PUSH
122537: EMPTY
122538: LIST
122539: LIST
122540: PPUSH
122541: CALL_OW 69
122545: PPUSH
122546: LD_VAR 0 1
122550: PPUSH
122551: CALL_OW 74
122555: PPUSH
122556: CALL_OW 115
// until IsDead ( un ) ;
122560: LD_VAR 0 1
122564: PPUSH
122565: CALL_OW 301
122569: IFFALSE 122517
// end ;
122571: PPOPN 1
122573: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
122574: LD_EXP 148
122578: PUSH
122579: LD_EXP 188
122583: AND
122584: IFFALSE 122596
122586: GO 122588
122588: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
122589: LD_STRING earthquake(getX(game), 0, 32)
122591: PPUSH
122592: CALL_OW 559
122596: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
122597: LD_EXP 148
122601: PUSH
122602: LD_EXP 189
122606: AND
122607: IFFALSE 122698
122609: GO 122611
122611: DISABLE
122612: LD_INT 0
122614: PPUSH
// begin enable ;
122615: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
122616: LD_ADDR_VAR 0 1
122620: PUSH
122621: LD_INT 22
122623: PUSH
122624: LD_OWVAR 2
122628: PUSH
122629: EMPTY
122630: LIST
122631: LIST
122632: PUSH
122633: LD_INT 21
122635: PUSH
122636: LD_INT 2
122638: PUSH
122639: EMPTY
122640: LIST
122641: LIST
122642: PUSH
122643: LD_INT 33
122645: PUSH
122646: LD_INT 3
122648: PUSH
122649: EMPTY
122650: LIST
122651: LIST
122652: PUSH
122653: EMPTY
122654: LIST
122655: LIST
122656: LIST
122657: PPUSH
122658: CALL_OW 69
122662: ST_TO_ADDR
// if not tmp then
122663: LD_VAR 0 1
122667: NOT
122668: IFFALSE 122672
// exit ;
122670: GO 122698
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122672: LD_VAR 0 1
122676: PUSH
122677: LD_INT 1
122679: PPUSH
122680: LD_VAR 0 1
122684: PPUSH
122685: CALL_OW 12
122689: ARRAY
122690: PPUSH
122691: LD_INT 1
122693: PPUSH
122694: CALL_OW 234
// end ;
122698: PPOPN 1
122700: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
122701: LD_EXP 148
122705: PUSH
122706: LD_EXP 190
122710: AND
122711: IFFALSE 122852
122713: GO 122715
122715: DISABLE
122716: LD_INT 0
122718: PPUSH
122719: PPUSH
122720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122721: LD_ADDR_VAR 0 3
122725: PUSH
122726: LD_INT 22
122728: PUSH
122729: LD_OWVAR 2
122733: PUSH
122734: EMPTY
122735: LIST
122736: LIST
122737: PUSH
122738: LD_INT 25
122740: PUSH
122741: LD_INT 1
122743: PUSH
122744: EMPTY
122745: LIST
122746: LIST
122747: PUSH
122748: EMPTY
122749: LIST
122750: LIST
122751: PPUSH
122752: CALL_OW 69
122756: ST_TO_ADDR
// if not tmp then
122757: LD_VAR 0 3
122761: NOT
122762: IFFALSE 122766
// exit ;
122764: GO 122852
// un := tmp [ rand ( 1 , tmp ) ] ;
122766: LD_ADDR_VAR 0 2
122770: PUSH
122771: LD_VAR 0 3
122775: PUSH
122776: LD_INT 1
122778: PPUSH
122779: LD_VAR 0 3
122783: PPUSH
122784: CALL_OW 12
122788: ARRAY
122789: ST_TO_ADDR
// if Crawls ( un ) then
122790: LD_VAR 0 2
122794: PPUSH
122795: CALL_OW 318
122799: IFFALSE 122810
// ComWalk ( un ) ;
122801: LD_VAR 0 2
122805: PPUSH
122806: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
122810: LD_VAR 0 2
122814: PPUSH
122815: LD_INT 9
122817: PPUSH
122818: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
122822: LD_INT 28
122824: PPUSH
122825: LD_OWVAR 2
122829: PPUSH
122830: LD_INT 2
122832: PPUSH
122833: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122837: LD_INT 29
122839: PPUSH
122840: LD_OWVAR 2
122844: PPUSH
122845: LD_INT 2
122847: PPUSH
122848: CALL_OW 322
// end ;
122852: PPOPN 3
122854: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122855: LD_EXP 148
122859: PUSH
122860: LD_EXP 191
122864: AND
122865: IFFALSE 122976
122867: GO 122869
122869: DISABLE
122870: LD_INT 0
122872: PPUSH
122873: PPUSH
122874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122875: LD_ADDR_VAR 0 3
122879: PUSH
122880: LD_INT 22
122882: PUSH
122883: LD_OWVAR 2
122887: PUSH
122888: EMPTY
122889: LIST
122890: LIST
122891: PUSH
122892: LD_INT 25
122894: PUSH
122895: LD_INT 1
122897: PUSH
122898: EMPTY
122899: LIST
122900: LIST
122901: PUSH
122902: EMPTY
122903: LIST
122904: LIST
122905: PPUSH
122906: CALL_OW 69
122910: ST_TO_ADDR
// if not tmp then
122911: LD_VAR 0 3
122915: NOT
122916: IFFALSE 122920
// exit ;
122918: GO 122976
// un := tmp [ rand ( 1 , tmp ) ] ;
122920: LD_ADDR_VAR 0 2
122924: PUSH
122925: LD_VAR 0 3
122929: PUSH
122930: LD_INT 1
122932: PPUSH
122933: LD_VAR 0 3
122937: PPUSH
122938: CALL_OW 12
122942: ARRAY
122943: ST_TO_ADDR
// if Crawls ( un ) then
122944: LD_VAR 0 2
122948: PPUSH
122949: CALL_OW 318
122953: IFFALSE 122964
// ComWalk ( un ) ;
122955: LD_VAR 0 2
122959: PPUSH
122960: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122964: LD_VAR 0 2
122968: PPUSH
122969: LD_INT 8
122971: PPUSH
122972: CALL_OW 336
// end ;
122976: PPOPN 3
122978: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122979: LD_EXP 148
122983: PUSH
122984: LD_EXP 192
122988: AND
122989: IFFALSE 123133
122991: GO 122993
122993: DISABLE
122994: LD_INT 0
122996: PPUSH
122997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122998: LD_ADDR_VAR 0 2
123002: PUSH
123003: LD_INT 22
123005: PUSH
123006: LD_OWVAR 2
123010: PUSH
123011: EMPTY
123012: LIST
123013: LIST
123014: PUSH
123015: LD_INT 21
123017: PUSH
123018: LD_INT 2
123020: PUSH
123021: EMPTY
123022: LIST
123023: LIST
123024: PUSH
123025: LD_INT 2
123027: PUSH
123028: LD_INT 34
123030: PUSH
123031: LD_INT 12
123033: PUSH
123034: EMPTY
123035: LIST
123036: LIST
123037: PUSH
123038: LD_INT 34
123040: PUSH
123041: LD_INT 51
123043: PUSH
123044: EMPTY
123045: LIST
123046: LIST
123047: PUSH
123048: LD_INT 34
123050: PUSH
123051: LD_INT 32
123053: PUSH
123054: EMPTY
123055: LIST
123056: LIST
123057: PUSH
123058: EMPTY
123059: LIST
123060: LIST
123061: LIST
123062: LIST
123063: PUSH
123064: EMPTY
123065: LIST
123066: LIST
123067: LIST
123068: PPUSH
123069: CALL_OW 69
123073: ST_TO_ADDR
// if not tmp then
123074: LD_VAR 0 2
123078: NOT
123079: IFFALSE 123083
// exit ;
123081: GO 123133
// for i in tmp do
123083: LD_ADDR_VAR 0 1
123087: PUSH
123088: LD_VAR 0 2
123092: PUSH
123093: FOR_IN
123094: IFFALSE 123131
// if GetCargo ( i , mat_artifact ) = 0 then
123096: LD_VAR 0 1
123100: PPUSH
123101: LD_INT 4
123103: PPUSH
123104: CALL_OW 289
123108: PUSH
123109: LD_INT 0
123111: EQUAL
123112: IFFALSE 123129
// SetCargo ( i , mat_siberit , 100 ) ;
123114: LD_VAR 0 1
123118: PPUSH
123119: LD_INT 3
123121: PPUSH
123122: LD_INT 100
123124: PPUSH
123125: CALL_OW 290
123129: GO 123093
123131: POP
123132: POP
// end ;
123133: PPOPN 2
123135: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123136: LD_EXP 148
123140: PUSH
123141: LD_EXP 193
123145: AND
123146: IFFALSE 123329
123148: GO 123150
123150: DISABLE
123151: LD_INT 0
123153: PPUSH
123154: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123155: LD_ADDR_VAR 0 2
123159: PUSH
123160: LD_INT 22
123162: PUSH
123163: LD_OWVAR 2
123167: PUSH
123168: EMPTY
123169: LIST
123170: LIST
123171: PPUSH
123172: CALL_OW 69
123176: ST_TO_ADDR
// if not tmp then
123177: LD_VAR 0 2
123181: NOT
123182: IFFALSE 123186
// exit ;
123184: GO 123329
// for i := 1 to 2 do
123186: LD_ADDR_VAR 0 1
123190: PUSH
123191: DOUBLE
123192: LD_INT 1
123194: DEC
123195: ST_TO_ADDR
123196: LD_INT 2
123198: PUSH
123199: FOR_TO
123200: IFFALSE 123327
// begin uc_side := your_side ;
123202: LD_ADDR_OWVAR 20
123206: PUSH
123207: LD_OWVAR 2
123211: ST_TO_ADDR
// uc_nation := nation_american ;
123212: LD_ADDR_OWVAR 21
123216: PUSH
123217: LD_INT 1
123219: ST_TO_ADDR
// vc_chassis := us_morphling ;
123220: LD_ADDR_OWVAR 37
123224: PUSH
123225: LD_INT 5
123227: ST_TO_ADDR
// vc_engine := engine_siberite ;
123228: LD_ADDR_OWVAR 39
123232: PUSH
123233: LD_INT 3
123235: ST_TO_ADDR
// vc_control := control_computer ;
123236: LD_ADDR_OWVAR 38
123240: PUSH
123241: LD_INT 3
123243: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123244: LD_ADDR_OWVAR 40
123248: PUSH
123249: LD_INT 10
123251: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123252: LD_VAR 0 2
123256: PUSH
123257: LD_INT 1
123259: ARRAY
123260: PPUSH
123261: CALL_OW 310
123265: NOT
123266: IFFALSE 123313
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123268: CALL_OW 45
123272: PPUSH
123273: LD_VAR 0 2
123277: PUSH
123278: LD_INT 1
123280: ARRAY
123281: PPUSH
123282: CALL_OW 250
123286: PPUSH
123287: LD_VAR 0 2
123291: PUSH
123292: LD_INT 1
123294: ARRAY
123295: PPUSH
123296: CALL_OW 251
123300: PPUSH
123301: LD_INT 12
123303: PPUSH
123304: LD_INT 1
123306: PPUSH
123307: CALL_OW 50
123311: GO 123325
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123313: CALL_OW 45
123317: PPUSH
123318: LD_INT 1
123320: PPUSH
123321: CALL_OW 51
// end ;
123325: GO 123199
123327: POP
123328: POP
// end ;
123329: PPOPN 2
123331: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123332: LD_EXP 148
123336: PUSH
123337: LD_EXP 194
123341: AND
123342: IFFALSE 123564
123344: GO 123346
123346: DISABLE
123347: LD_INT 0
123349: PPUSH
123350: PPUSH
123351: PPUSH
123352: PPUSH
123353: PPUSH
123354: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123355: LD_ADDR_VAR 0 6
123359: PUSH
123360: LD_INT 22
123362: PUSH
123363: LD_OWVAR 2
123367: PUSH
123368: EMPTY
123369: LIST
123370: LIST
123371: PUSH
123372: LD_INT 21
123374: PUSH
123375: LD_INT 1
123377: PUSH
123378: EMPTY
123379: LIST
123380: LIST
123381: PUSH
123382: LD_INT 3
123384: PUSH
123385: LD_INT 23
123387: PUSH
123388: LD_INT 0
123390: PUSH
123391: EMPTY
123392: LIST
123393: LIST
123394: PUSH
123395: EMPTY
123396: LIST
123397: LIST
123398: PUSH
123399: EMPTY
123400: LIST
123401: LIST
123402: LIST
123403: PPUSH
123404: CALL_OW 69
123408: ST_TO_ADDR
// if not tmp then
123409: LD_VAR 0 6
123413: NOT
123414: IFFALSE 123418
// exit ;
123416: GO 123564
// s1 := rand ( 1 , 4 ) ;
123418: LD_ADDR_VAR 0 2
123422: PUSH
123423: LD_INT 1
123425: PPUSH
123426: LD_INT 4
123428: PPUSH
123429: CALL_OW 12
123433: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
123434: LD_ADDR_VAR 0 4
123438: PUSH
123439: LD_VAR 0 6
123443: PUSH
123444: LD_INT 1
123446: ARRAY
123447: PPUSH
123448: LD_VAR 0 2
123452: PPUSH
123453: CALL_OW 259
123457: ST_TO_ADDR
// if s1 = 1 then
123458: LD_VAR 0 2
123462: PUSH
123463: LD_INT 1
123465: EQUAL
123466: IFFALSE 123486
// s2 := rand ( 2 , 4 ) else
123468: LD_ADDR_VAR 0 3
123472: PUSH
123473: LD_INT 2
123475: PPUSH
123476: LD_INT 4
123478: PPUSH
123479: CALL_OW 12
123483: ST_TO_ADDR
123484: GO 123494
// s2 := 1 ;
123486: LD_ADDR_VAR 0 3
123490: PUSH
123491: LD_INT 1
123493: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
123494: LD_ADDR_VAR 0 5
123498: PUSH
123499: LD_VAR 0 6
123503: PUSH
123504: LD_INT 1
123506: ARRAY
123507: PPUSH
123508: LD_VAR 0 3
123512: PPUSH
123513: CALL_OW 259
123517: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
123518: LD_VAR 0 6
123522: PUSH
123523: LD_INT 1
123525: ARRAY
123526: PPUSH
123527: LD_VAR 0 2
123531: PPUSH
123532: LD_VAR 0 5
123536: PPUSH
123537: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
123541: LD_VAR 0 6
123545: PUSH
123546: LD_INT 1
123548: ARRAY
123549: PPUSH
123550: LD_VAR 0 3
123554: PPUSH
123555: LD_VAR 0 4
123559: PPUSH
123560: CALL_OW 237
// end ;
123564: PPOPN 6
123566: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
123567: LD_EXP 148
123571: PUSH
123572: LD_EXP 195
123576: AND
123577: IFFALSE 123656
123579: GO 123581
123581: DISABLE
123582: LD_INT 0
123584: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
123585: LD_ADDR_VAR 0 1
123589: PUSH
123590: LD_INT 22
123592: PUSH
123593: LD_OWVAR 2
123597: PUSH
123598: EMPTY
123599: LIST
123600: LIST
123601: PUSH
123602: LD_INT 30
123604: PUSH
123605: LD_INT 3
123607: PUSH
123608: EMPTY
123609: LIST
123610: LIST
123611: PUSH
123612: EMPTY
123613: LIST
123614: LIST
123615: PPUSH
123616: CALL_OW 69
123620: ST_TO_ADDR
// if not tmp then
123621: LD_VAR 0 1
123625: NOT
123626: IFFALSE 123630
// exit ;
123628: GO 123656
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123630: LD_VAR 0 1
123634: PUSH
123635: LD_INT 1
123637: PPUSH
123638: LD_VAR 0 1
123642: PPUSH
123643: CALL_OW 12
123647: ARRAY
123648: PPUSH
123649: LD_INT 1
123651: PPUSH
123652: CALL_OW 234
// end ;
123656: PPOPN 1
123658: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
123659: LD_EXP 148
123663: PUSH
123664: LD_EXP 196
123668: AND
123669: IFFALSE 123781
123671: GO 123673
123673: DISABLE
123674: LD_INT 0
123676: PPUSH
123677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
123678: LD_ADDR_VAR 0 2
123682: PUSH
123683: LD_INT 22
123685: PUSH
123686: LD_OWVAR 2
123690: PUSH
123691: EMPTY
123692: LIST
123693: LIST
123694: PUSH
123695: LD_INT 2
123697: PUSH
123698: LD_INT 30
123700: PUSH
123701: LD_INT 27
123703: PUSH
123704: EMPTY
123705: LIST
123706: LIST
123707: PUSH
123708: LD_INT 30
123710: PUSH
123711: LD_INT 26
123713: PUSH
123714: EMPTY
123715: LIST
123716: LIST
123717: PUSH
123718: LD_INT 30
123720: PUSH
123721: LD_INT 28
123723: PUSH
123724: EMPTY
123725: LIST
123726: LIST
123727: PUSH
123728: EMPTY
123729: LIST
123730: LIST
123731: LIST
123732: LIST
123733: PUSH
123734: EMPTY
123735: LIST
123736: LIST
123737: PPUSH
123738: CALL_OW 69
123742: ST_TO_ADDR
// if not tmp then
123743: LD_VAR 0 2
123747: NOT
123748: IFFALSE 123752
// exit ;
123750: GO 123781
// for i in tmp do
123752: LD_ADDR_VAR 0 1
123756: PUSH
123757: LD_VAR 0 2
123761: PUSH
123762: FOR_IN
123763: IFFALSE 123779
// SetLives ( i , 1 ) ;
123765: LD_VAR 0 1
123769: PPUSH
123770: LD_INT 1
123772: PPUSH
123773: CALL_OW 234
123777: GO 123762
123779: POP
123780: POP
// end ;
123781: PPOPN 2
123783: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
123784: LD_EXP 148
123788: PUSH
123789: LD_EXP 197
123793: AND
123794: IFFALSE 124081
123796: GO 123798
123798: DISABLE
123799: LD_INT 0
123801: PPUSH
123802: PPUSH
123803: PPUSH
// begin i := rand ( 1 , 7 ) ;
123804: LD_ADDR_VAR 0 1
123808: PUSH
123809: LD_INT 1
123811: PPUSH
123812: LD_INT 7
123814: PPUSH
123815: CALL_OW 12
123819: ST_TO_ADDR
// case i of 1 :
123820: LD_VAR 0 1
123824: PUSH
123825: LD_INT 1
123827: DOUBLE
123828: EQUAL
123829: IFTRUE 123833
123831: GO 123843
123833: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123834: LD_STRING earthquake(getX(game), 0, 32)
123836: PPUSH
123837: CALL_OW 559
123841: GO 124081
123843: LD_INT 2
123845: DOUBLE
123846: EQUAL
123847: IFTRUE 123851
123849: GO 123865
123851: POP
// begin ToLua ( displayStucuk(); ) ;
123852: LD_STRING displayStucuk();
123854: PPUSH
123855: CALL_OW 559
// ResetFog ;
123859: CALL_OW 335
// end ; 3 :
123863: GO 124081
123865: LD_INT 3
123867: DOUBLE
123868: EQUAL
123869: IFTRUE 123873
123871: GO 123977
123873: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123874: LD_ADDR_VAR 0 2
123878: PUSH
123879: LD_INT 22
123881: PUSH
123882: LD_OWVAR 2
123886: PUSH
123887: EMPTY
123888: LIST
123889: LIST
123890: PUSH
123891: LD_INT 25
123893: PUSH
123894: LD_INT 1
123896: PUSH
123897: EMPTY
123898: LIST
123899: LIST
123900: PUSH
123901: EMPTY
123902: LIST
123903: LIST
123904: PPUSH
123905: CALL_OW 69
123909: ST_TO_ADDR
// if not tmp then
123910: LD_VAR 0 2
123914: NOT
123915: IFFALSE 123919
// exit ;
123917: GO 124081
// un := tmp [ rand ( 1 , tmp ) ] ;
123919: LD_ADDR_VAR 0 3
123923: PUSH
123924: LD_VAR 0 2
123928: PUSH
123929: LD_INT 1
123931: PPUSH
123932: LD_VAR 0 2
123936: PPUSH
123937: CALL_OW 12
123941: ARRAY
123942: ST_TO_ADDR
// if Crawls ( un ) then
123943: LD_VAR 0 3
123947: PPUSH
123948: CALL_OW 318
123952: IFFALSE 123963
// ComWalk ( un ) ;
123954: LD_VAR 0 3
123958: PPUSH
123959: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123963: LD_VAR 0 3
123967: PPUSH
123968: LD_INT 8
123970: PPUSH
123971: CALL_OW 336
// end ; 4 :
123975: GO 124081
123977: LD_INT 4
123979: DOUBLE
123980: EQUAL
123981: IFTRUE 123985
123983: GO 124059
123985: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123986: LD_ADDR_VAR 0 2
123990: PUSH
123991: LD_INT 22
123993: PUSH
123994: LD_OWVAR 2
123998: PUSH
123999: EMPTY
124000: LIST
124001: LIST
124002: PUSH
124003: LD_INT 30
124005: PUSH
124006: LD_INT 29
124008: PUSH
124009: EMPTY
124010: LIST
124011: LIST
124012: PUSH
124013: EMPTY
124014: LIST
124015: LIST
124016: PPUSH
124017: CALL_OW 69
124021: ST_TO_ADDR
// if not tmp then
124022: LD_VAR 0 2
124026: NOT
124027: IFFALSE 124031
// exit ;
124029: GO 124081
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124031: LD_VAR 0 2
124035: PUSH
124036: LD_INT 1
124038: ARRAY
124039: PPUSH
124040: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124044: LD_VAR 0 2
124048: PUSH
124049: LD_INT 1
124051: ARRAY
124052: PPUSH
124053: CALL_OW 65
// end ; 5 .. 7 :
124057: GO 124081
124059: LD_INT 5
124061: DOUBLE
124062: GREATEREQUAL
124063: IFFALSE 124071
124065: LD_INT 7
124067: DOUBLE
124068: LESSEQUAL
124069: IFTRUE 124073
124071: GO 124080
124073: POP
// StreamSibBomb ; end ;
124074: CALL 120318 0 0
124078: GO 124081
124080: POP
// end ;
124081: PPOPN 3
124083: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124084: LD_EXP 148
124088: PUSH
124089: LD_EXP 198
124093: AND
124094: IFFALSE 124250
124096: GO 124098
124098: DISABLE
124099: LD_INT 0
124101: PPUSH
124102: PPUSH
124103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124104: LD_ADDR_VAR 0 2
124108: PUSH
124109: LD_INT 81
124111: PUSH
124112: LD_OWVAR 2
124116: PUSH
124117: EMPTY
124118: LIST
124119: LIST
124120: PUSH
124121: LD_INT 2
124123: PUSH
124124: LD_INT 21
124126: PUSH
124127: LD_INT 1
124129: PUSH
124130: EMPTY
124131: LIST
124132: LIST
124133: PUSH
124134: LD_INT 21
124136: PUSH
124137: LD_INT 2
124139: PUSH
124140: EMPTY
124141: LIST
124142: LIST
124143: PUSH
124144: EMPTY
124145: LIST
124146: LIST
124147: LIST
124148: PUSH
124149: EMPTY
124150: LIST
124151: LIST
124152: PPUSH
124153: CALL_OW 69
124157: ST_TO_ADDR
// if not tmp then
124158: LD_VAR 0 2
124162: NOT
124163: IFFALSE 124167
// exit ;
124165: GO 124250
// p := 0 ;
124167: LD_ADDR_VAR 0 3
124171: PUSH
124172: LD_INT 0
124174: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124175: LD_INT 35
124177: PPUSH
124178: CALL_OW 67
// p := p + 1 ;
124182: LD_ADDR_VAR 0 3
124186: PUSH
124187: LD_VAR 0 3
124191: PUSH
124192: LD_INT 1
124194: PLUS
124195: ST_TO_ADDR
// for i in tmp do
124196: LD_ADDR_VAR 0 1
124200: PUSH
124201: LD_VAR 0 2
124205: PUSH
124206: FOR_IN
124207: IFFALSE 124238
// if GetLives ( i ) < 1000 then
124209: LD_VAR 0 1
124213: PPUSH
124214: CALL_OW 256
124218: PUSH
124219: LD_INT 1000
124221: LESS
124222: IFFALSE 124236
// SetLives ( i , 1000 ) ;
124224: LD_VAR 0 1
124228: PPUSH
124229: LD_INT 1000
124231: PPUSH
124232: CALL_OW 234
124236: GO 124206
124238: POP
124239: POP
// until p > 20 ;
124240: LD_VAR 0 3
124244: PUSH
124245: LD_INT 20
124247: GREATER
124248: IFFALSE 124175
// end ;
124250: PPOPN 3
124252: END
// every 0 0$1 trigger StreamModeActive and sTime do
124253: LD_EXP 148
124257: PUSH
124258: LD_EXP 199
124262: AND
124263: IFFALSE 124298
124265: GO 124267
124267: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124268: LD_INT 28
124270: PPUSH
124271: LD_OWVAR 2
124275: PPUSH
124276: LD_INT 2
124278: PPUSH
124279: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124283: LD_INT 30
124285: PPUSH
124286: LD_OWVAR 2
124290: PPUSH
124291: LD_INT 2
124293: PPUSH
124294: CALL_OW 322
// end ;
124298: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124299: LD_EXP 148
124303: PUSH
124304: LD_EXP 200
124308: AND
124309: IFFALSE 124430
124311: GO 124313
124313: DISABLE
124314: LD_INT 0
124316: PPUSH
124317: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124318: LD_ADDR_VAR 0 2
124322: PUSH
124323: LD_INT 22
124325: PUSH
124326: LD_OWVAR 2
124330: PUSH
124331: EMPTY
124332: LIST
124333: LIST
124334: PUSH
124335: LD_INT 21
124337: PUSH
124338: LD_INT 1
124340: PUSH
124341: EMPTY
124342: LIST
124343: LIST
124344: PUSH
124345: LD_INT 3
124347: PUSH
124348: LD_INT 23
124350: PUSH
124351: LD_INT 0
124353: PUSH
124354: EMPTY
124355: LIST
124356: LIST
124357: PUSH
124358: EMPTY
124359: LIST
124360: LIST
124361: PUSH
124362: EMPTY
124363: LIST
124364: LIST
124365: LIST
124366: PPUSH
124367: CALL_OW 69
124371: ST_TO_ADDR
// if not tmp then
124372: LD_VAR 0 2
124376: NOT
124377: IFFALSE 124381
// exit ;
124379: GO 124430
// for i in tmp do
124381: LD_ADDR_VAR 0 1
124385: PUSH
124386: LD_VAR 0 2
124390: PUSH
124391: FOR_IN
124392: IFFALSE 124428
// begin if Crawls ( i ) then
124394: LD_VAR 0 1
124398: PPUSH
124399: CALL_OW 318
124403: IFFALSE 124414
// ComWalk ( i ) ;
124405: LD_VAR 0 1
124409: PPUSH
124410: CALL_OW 138
// SetClass ( i , 2 ) ;
124414: LD_VAR 0 1
124418: PPUSH
124419: LD_INT 2
124421: PPUSH
124422: CALL_OW 336
// end ;
124426: GO 124391
124428: POP
124429: POP
// end ;
124430: PPOPN 2
124432: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
124433: LD_EXP 148
124437: PUSH
124438: LD_EXP 201
124442: AND
124443: IFFALSE 124731
124445: GO 124447
124447: DISABLE
124448: LD_INT 0
124450: PPUSH
124451: PPUSH
124452: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
124453: LD_OWVAR 2
124457: PPUSH
124458: LD_INT 9
124460: PPUSH
124461: LD_INT 1
124463: PPUSH
124464: LD_INT 1
124466: PPUSH
124467: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
124471: LD_INT 9
124473: PPUSH
124474: LD_OWVAR 2
124478: PPUSH
124479: CALL_OW 343
// uc_side := 9 ;
124483: LD_ADDR_OWVAR 20
124487: PUSH
124488: LD_INT 9
124490: ST_TO_ADDR
// uc_nation := 2 ;
124491: LD_ADDR_OWVAR 21
124495: PUSH
124496: LD_INT 2
124498: ST_TO_ADDR
// hc_name := Dark Warrior ;
124499: LD_ADDR_OWVAR 26
124503: PUSH
124504: LD_STRING Dark Warrior
124506: ST_TO_ADDR
// hc_gallery :=  ;
124507: LD_ADDR_OWVAR 33
124511: PUSH
124512: LD_STRING 
124514: ST_TO_ADDR
// hc_noskilllimit := true ;
124515: LD_ADDR_OWVAR 76
124519: PUSH
124520: LD_INT 1
124522: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
124523: LD_ADDR_OWVAR 31
124527: PUSH
124528: LD_INT 30
124530: PUSH
124531: LD_INT 30
124533: PUSH
124534: LD_INT 30
124536: PUSH
124537: LD_INT 30
124539: PUSH
124540: EMPTY
124541: LIST
124542: LIST
124543: LIST
124544: LIST
124545: ST_TO_ADDR
// un := CreateHuman ;
124546: LD_ADDR_VAR 0 3
124550: PUSH
124551: CALL_OW 44
124555: ST_TO_ADDR
// hc_noskilllimit := false ;
124556: LD_ADDR_OWVAR 76
124560: PUSH
124561: LD_INT 0
124563: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124564: LD_VAR 0 3
124568: PPUSH
124569: LD_INT 1
124571: PPUSH
124572: CALL_OW 51
// ToLua ( playRanger() ) ;
124576: LD_STRING playRanger()
124578: PPUSH
124579: CALL_OW 559
// p := 0 ;
124583: LD_ADDR_VAR 0 2
124587: PUSH
124588: LD_INT 0
124590: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124591: LD_INT 35
124593: PPUSH
124594: CALL_OW 67
// p := p + 1 ;
124598: LD_ADDR_VAR 0 2
124602: PUSH
124603: LD_VAR 0 2
124607: PUSH
124608: LD_INT 1
124610: PLUS
124611: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
124612: LD_VAR 0 3
124616: PPUSH
124617: CALL_OW 256
124621: PUSH
124622: LD_INT 1000
124624: LESS
124625: IFFALSE 124639
// SetLives ( un , 1000 ) ;
124627: LD_VAR 0 3
124631: PPUSH
124632: LD_INT 1000
124634: PPUSH
124635: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
124639: LD_VAR 0 3
124643: PPUSH
124644: LD_INT 81
124646: PUSH
124647: LD_OWVAR 2
124651: PUSH
124652: EMPTY
124653: LIST
124654: LIST
124655: PUSH
124656: LD_INT 91
124658: PUSH
124659: LD_VAR 0 3
124663: PUSH
124664: LD_INT 30
124666: PUSH
124667: EMPTY
124668: LIST
124669: LIST
124670: LIST
124671: PUSH
124672: EMPTY
124673: LIST
124674: LIST
124675: PPUSH
124676: CALL_OW 69
124680: PPUSH
124681: LD_VAR 0 3
124685: PPUSH
124686: CALL_OW 74
124690: PPUSH
124691: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
124695: LD_VAR 0 2
124699: PUSH
124700: LD_INT 80
124702: GREATER
124703: PUSH
124704: LD_VAR 0 3
124708: PPUSH
124709: CALL_OW 301
124713: OR
124714: IFFALSE 124591
// if un then
124716: LD_VAR 0 3
124720: IFFALSE 124731
// RemoveUnit ( un ) ;
124722: LD_VAR 0 3
124726: PPUSH
124727: CALL_OW 64
// end ;
124731: PPOPN 3
124733: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
124734: LD_EXP 202
124738: IFFALSE 124854
124740: GO 124742
124742: DISABLE
124743: LD_INT 0
124745: PPUSH
124746: PPUSH
124747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
124748: LD_ADDR_VAR 0 2
124752: PUSH
124753: LD_INT 81
124755: PUSH
124756: LD_OWVAR 2
124760: PUSH
124761: EMPTY
124762: LIST
124763: LIST
124764: PUSH
124765: LD_INT 21
124767: PUSH
124768: LD_INT 1
124770: PUSH
124771: EMPTY
124772: LIST
124773: LIST
124774: PUSH
124775: EMPTY
124776: LIST
124777: LIST
124778: PPUSH
124779: CALL_OW 69
124783: ST_TO_ADDR
// ToLua ( playComputer() ) ;
124784: LD_STRING playComputer()
124786: PPUSH
124787: CALL_OW 559
// if not tmp then
124791: LD_VAR 0 2
124795: NOT
124796: IFFALSE 124800
// exit ;
124798: GO 124854
// for i in tmp do
124800: LD_ADDR_VAR 0 1
124804: PUSH
124805: LD_VAR 0 2
124809: PUSH
124810: FOR_IN
124811: IFFALSE 124852
// for j := 1 to 4 do
124813: LD_ADDR_VAR 0 3
124817: PUSH
124818: DOUBLE
124819: LD_INT 1
124821: DEC
124822: ST_TO_ADDR
124823: LD_INT 4
124825: PUSH
124826: FOR_TO
124827: IFFALSE 124848
// SetSkill ( i , j , 10 ) ;
124829: LD_VAR 0 1
124833: PPUSH
124834: LD_VAR 0 3
124838: PPUSH
124839: LD_INT 10
124841: PPUSH
124842: CALL_OW 237
124846: GO 124826
124848: POP
124849: POP
124850: GO 124810
124852: POP
124853: POP
// end ;
124854: PPOPN 3
124856: END
// every 0 0$1 trigger s30 do var i , tmp ;
124857: LD_EXP 203
124861: IFFALSE 124930
124863: GO 124865
124865: DISABLE
124866: LD_INT 0
124868: PPUSH
124869: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124870: LD_ADDR_VAR 0 2
124874: PUSH
124875: LD_INT 22
124877: PUSH
124878: LD_OWVAR 2
124882: PUSH
124883: EMPTY
124884: LIST
124885: LIST
124886: PPUSH
124887: CALL_OW 69
124891: ST_TO_ADDR
// if not tmp then
124892: LD_VAR 0 2
124896: NOT
124897: IFFALSE 124901
// exit ;
124899: GO 124930
// for i in tmp do
124901: LD_ADDR_VAR 0 1
124905: PUSH
124906: LD_VAR 0 2
124910: PUSH
124911: FOR_IN
124912: IFFALSE 124928
// SetLives ( i , 300 ) ;
124914: LD_VAR 0 1
124918: PPUSH
124919: LD_INT 300
124921: PPUSH
124922: CALL_OW 234
124926: GO 124911
124928: POP
124929: POP
// end ;
124930: PPOPN 2
124932: END
// every 0 0$1 trigger s60 do var i , tmp ;
124933: LD_EXP 204
124937: IFFALSE 125006
124939: GO 124941
124941: DISABLE
124942: LD_INT 0
124944: PPUSH
124945: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124946: LD_ADDR_VAR 0 2
124950: PUSH
124951: LD_INT 22
124953: PUSH
124954: LD_OWVAR 2
124958: PUSH
124959: EMPTY
124960: LIST
124961: LIST
124962: PPUSH
124963: CALL_OW 69
124967: ST_TO_ADDR
// if not tmp then
124968: LD_VAR 0 2
124972: NOT
124973: IFFALSE 124977
// exit ;
124975: GO 125006
// for i in tmp do
124977: LD_ADDR_VAR 0 1
124981: PUSH
124982: LD_VAR 0 2
124986: PUSH
124987: FOR_IN
124988: IFFALSE 125004
// SetLives ( i , 600 ) ;
124990: LD_VAR 0 1
124994: PPUSH
124995: LD_INT 600
124997: PPUSH
124998: CALL_OW 234
125002: GO 124987
125004: POP
125005: POP
// end ;
125006: PPOPN 2
125008: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125009: LD_INT 0
125011: PPUSH
// case cmd of 301 :
125012: LD_VAR 0 1
125016: PUSH
125017: LD_INT 301
125019: DOUBLE
125020: EQUAL
125021: IFTRUE 125025
125023: GO 125057
125025: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125026: LD_VAR 0 6
125030: PPUSH
125031: LD_VAR 0 7
125035: PPUSH
125036: LD_VAR 0 8
125040: PPUSH
125041: LD_VAR 0 4
125045: PPUSH
125046: LD_VAR 0 5
125050: PPUSH
125051: CALL 126266 0 5
125055: GO 125178
125057: LD_INT 302
125059: DOUBLE
125060: EQUAL
125061: IFTRUE 125065
125063: GO 125102
125065: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125066: LD_VAR 0 6
125070: PPUSH
125071: LD_VAR 0 7
125075: PPUSH
125076: LD_VAR 0 8
125080: PPUSH
125081: LD_VAR 0 9
125085: PPUSH
125086: LD_VAR 0 4
125090: PPUSH
125091: LD_VAR 0 5
125095: PPUSH
125096: CALL 126357 0 6
125100: GO 125178
125102: LD_INT 303
125104: DOUBLE
125105: EQUAL
125106: IFTRUE 125110
125108: GO 125147
125110: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125111: LD_VAR 0 6
125115: PPUSH
125116: LD_VAR 0 7
125120: PPUSH
125121: LD_VAR 0 8
125125: PPUSH
125126: LD_VAR 0 9
125130: PPUSH
125131: LD_VAR 0 4
125135: PPUSH
125136: LD_VAR 0 5
125140: PPUSH
125141: CALL 125183 0 6
125145: GO 125178
125147: LD_INT 304
125149: DOUBLE
125150: EQUAL
125151: IFTRUE 125155
125153: GO 125177
125155: POP
// hHackTeleport ( unit , x , y ) ; end ;
125156: LD_VAR 0 2
125160: PPUSH
125161: LD_VAR 0 4
125165: PPUSH
125166: LD_VAR 0 5
125170: PPUSH
125171: CALL 126950 0 3
125175: GO 125178
125177: POP
// end ;
125178: LD_VAR 0 12
125182: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125183: LD_INT 0
125185: PPUSH
125186: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125187: LD_VAR 0 1
125191: PUSH
125192: LD_INT 1
125194: LESS
125195: PUSH
125196: LD_VAR 0 1
125200: PUSH
125201: LD_INT 3
125203: GREATER
125204: OR
125205: PUSH
125206: LD_VAR 0 5
125210: PPUSH
125211: LD_VAR 0 6
125215: PPUSH
125216: CALL_OW 428
125220: OR
125221: IFFALSE 125225
// exit ;
125223: GO 125953
// uc_side := your_side ;
125225: LD_ADDR_OWVAR 20
125229: PUSH
125230: LD_OWVAR 2
125234: ST_TO_ADDR
// uc_nation := nation ;
125235: LD_ADDR_OWVAR 21
125239: PUSH
125240: LD_VAR 0 1
125244: ST_TO_ADDR
// bc_level = 1 ;
125245: LD_ADDR_OWVAR 43
125249: PUSH
125250: LD_INT 1
125252: ST_TO_ADDR
// case btype of 1 :
125253: LD_VAR 0 2
125257: PUSH
125258: LD_INT 1
125260: DOUBLE
125261: EQUAL
125262: IFTRUE 125266
125264: GO 125277
125266: POP
// bc_type := b_depot ; 2 :
125267: LD_ADDR_OWVAR 42
125271: PUSH
125272: LD_INT 0
125274: ST_TO_ADDR
125275: GO 125897
125277: LD_INT 2
125279: DOUBLE
125280: EQUAL
125281: IFTRUE 125285
125283: GO 125296
125285: POP
// bc_type := b_warehouse ; 3 :
125286: LD_ADDR_OWVAR 42
125290: PUSH
125291: LD_INT 1
125293: ST_TO_ADDR
125294: GO 125897
125296: LD_INT 3
125298: DOUBLE
125299: EQUAL
125300: IFTRUE 125304
125302: GO 125315
125304: POP
// bc_type := b_lab ; 4 .. 9 :
125305: LD_ADDR_OWVAR 42
125309: PUSH
125310: LD_INT 6
125312: ST_TO_ADDR
125313: GO 125897
125315: LD_INT 4
125317: DOUBLE
125318: GREATEREQUAL
125319: IFFALSE 125327
125321: LD_INT 9
125323: DOUBLE
125324: LESSEQUAL
125325: IFTRUE 125329
125327: GO 125389
125329: POP
// begin bc_type := b_lab_half ;
125330: LD_ADDR_OWVAR 42
125334: PUSH
125335: LD_INT 7
125337: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125338: LD_ADDR_OWVAR 44
125342: PUSH
125343: LD_INT 10
125345: PUSH
125346: LD_INT 11
125348: PUSH
125349: LD_INT 12
125351: PUSH
125352: LD_INT 15
125354: PUSH
125355: LD_INT 14
125357: PUSH
125358: LD_INT 13
125360: PUSH
125361: EMPTY
125362: LIST
125363: LIST
125364: LIST
125365: LIST
125366: LIST
125367: LIST
125368: PUSH
125369: LD_VAR 0 2
125373: PUSH
125374: LD_INT 3
125376: MINUS
125377: ARRAY
125378: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125379: LD_ADDR_OWVAR 45
125383: PUSH
125384: LD_INT 9
125386: ST_TO_ADDR
// end ; 10 .. 13 :
125387: GO 125897
125389: LD_INT 10
125391: DOUBLE
125392: GREATEREQUAL
125393: IFFALSE 125401
125395: LD_INT 13
125397: DOUBLE
125398: LESSEQUAL
125399: IFTRUE 125403
125401: GO 125480
125403: POP
// begin bc_type := b_lab_full ;
125404: LD_ADDR_OWVAR 42
125408: PUSH
125409: LD_INT 8
125411: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125412: LD_ADDR_OWVAR 44
125416: PUSH
125417: LD_INT 10
125419: PUSH
125420: LD_INT 12
125422: PUSH
125423: LD_INT 14
125425: PUSH
125426: LD_INT 13
125428: PUSH
125429: EMPTY
125430: LIST
125431: LIST
125432: LIST
125433: LIST
125434: PUSH
125435: LD_VAR 0 2
125439: PUSH
125440: LD_INT 9
125442: MINUS
125443: ARRAY
125444: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
125445: LD_ADDR_OWVAR 45
125449: PUSH
125450: LD_INT 11
125452: PUSH
125453: LD_INT 15
125455: PUSH
125456: LD_INT 12
125458: PUSH
125459: LD_INT 15
125461: PUSH
125462: EMPTY
125463: LIST
125464: LIST
125465: LIST
125466: LIST
125467: PUSH
125468: LD_VAR 0 2
125472: PUSH
125473: LD_INT 9
125475: MINUS
125476: ARRAY
125477: ST_TO_ADDR
// end ; 14 :
125478: GO 125897
125480: LD_INT 14
125482: DOUBLE
125483: EQUAL
125484: IFTRUE 125488
125486: GO 125499
125488: POP
// bc_type := b_workshop ; 15 :
125489: LD_ADDR_OWVAR 42
125493: PUSH
125494: LD_INT 2
125496: ST_TO_ADDR
125497: GO 125897
125499: LD_INT 15
125501: DOUBLE
125502: EQUAL
125503: IFTRUE 125507
125505: GO 125518
125507: POP
// bc_type := b_factory ; 16 :
125508: LD_ADDR_OWVAR 42
125512: PUSH
125513: LD_INT 3
125515: ST_TO_ADDR
125516: GO 125897
125518: LD_INT 16
125520: DOUBLE
125521: EQUAL
125522: IFTRUE 125526
125524: GO 125537
125526: POP
// bc_type := b_ext_gun ; 17 :
125527: LD_ADDR_OWVAR 42
125531: PUSH
125532: LD_INT 17
125534: ST_TO_ADDR
125535: GO 125897
125537: LD_INT 17
125539: DOUBLE
125540: EQUAL
125541: IFTRUE 125545
125543: GO 125573
125545: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
125546: LD_ADDR_OWVAR 42
125550: PUSH
125551: LD_INT 19
125553: PUSH
125554: LD_INT 23
125556: PUSH
125557: LD_INT 19
125559: PUSH
125560: EMPTY
125561: LIST
125562: LIST
125563: LIST
125564: PUSH
125565: LD_VAR 0 1
125569: ARRAY
125570: ST_TO_ADDR
125571: GO 125897
125573: LD_INT 18
125575: DOUBLE
125576: EQUAL
125577: IFTRUE 125581
125579: GO 125592
125581: POP
// bc_type := b_ext_radar ; 19 :
125582: LD_ADDR_OWVAR 42
125586: PUSH
125587: LD_INT 20
125589: ST_TO_ADDR
125590: GO 125897
125592: LD_INT 19
125594: DOUBLE
125595: EQUAL
125596: IFTRUE 125600
125598: GO 125611
125600: POP
// bc_type := b_ext_radio ; 20 :
125601: LD_ADDR_OWVAR 42
125605: PUSH
125606: LD_INT 22
125608: ST_TO_ADDR
125609: GO 125897
125611: LD_INT 20
125613: DOUBLE
125614: EQUAL
125615: IFTRUE 125619
125617: GO 125630
125619: POP
// bc_type := b_ext_siberium ; 21 :
125620: LD_ADDR_OWVAR 42
125624: PUSH
125625: LD_INT 21
125627: ST_TO_ADDR
125628: GO 125897
125630: LD_INT 21
125632: DOUBLE
125633: EQUAL
125634: IFTRUE 125638
125636: GO 125649
125638: POP
// bc_type := b_ext_computer ; 22 :
125639: LD_ADDR_OWVAR 42
125643: PUSH
125644: LD_INT 24
125646: ST_TO_ADDR
125647: GO 125897
125649: LD_INT 22
125651: DOUBLE
125652: EQUAL
125653: IFTRUE 125657
125655: GO 125668
125657: POP
// bc_type := b_ext_track ; 23 :
125658: LD_ADDR_OWVAR 42
125662: PUSH
125663: LD_INT 16
125665: ST_TO_ADDR
125666: GO 125897
125668: LD_INT 23
125670: DOUBLE
125671: EQUAL
125672: IFTRUE 125676
125674: GO 125687
125676: POP
// bc_type := b_ext_laser ; 24 :
125677: LD_ADDR_OWVAR 42
125681: PUSH
125682: LD_INT 25
125684: ST_TO_ADDR
125685: GO 125897
125687: LD_INT 24
125689: DOUBLE
125690: EQUAL
125691: IFTRUE 125695
125693: GO 125706
125695: POP
// bc_type := b_control_tower ; 25 :
125696: LD_ADDR_OWVAR 42
125700: PUSH
125701: LD_INT 36
125703: ST_TO_ADDR
125704: GO 125897
125706: LD_INT 25
125708: DOUBLE
125709: EQUAL
125710: IFTRUE 125714
125712: GO 125725
125714: POP
// bc_type := b_breastwork ; 26 :
125715: LD_ADDR_OWVAR 42
125719: PUSH
125720: LD_INT 31
125722: ST_TO_ADDR
125723: GO 125897
125725: LD_INT 26
125727: DOUBLE
125728: EQUAL
125729: IFTRUE 125733
125731: GO 125744
125733: POP
// bc_type := b_bunker ; 27 :
125734: LD_ADDR_OWVAR 42
125738: PUSH
125739: LD_INT 32
125741: ST_TO_ADDR
125742: GO 125897
125744: LD_INT 27
125746: DOUBLE
125747: EQUAL
125748: IFTRUE 125752
125750: GO 125763
125752: POP
// bc_type := b_turret ; 28 :
125753: LD_ADDR_OWVAR 42
125757: PUSH
125758: LD_INT 33
125760: ST_TO_ADDR
125761: GO 125897
125763: LD_INT 28
125765: DOUBLE
125766: EQUAL
125767: IFTRUE 125771
125769: GO 125782
125771: POP
// bc_type := b_armoury ; 29 :
125772: LD_ADDR_OWVAR 42
125776: PUSH
125777: LD_INT 4
125779: ST_TO_ADDR
125780: GO 125897
125782: LD_INT 29
125784: DOUBLE
125785: EQUAL
125786: IFTRUE 125790
125788: GO 125801
125790: POP
// bc_type := b_barracks ; 30 :
125791: LD_ADDR_OWVAR 42
125795: PUSH
125796: LD_INT 5
125798: ST_TO_ADDR
125799: GO 125897
125801: LD_INT 30
125803: DOUBLE
125804: EQUAL
125805: IFTRUE 125809
125807: GO 125820
125809: POP
// bc_type := b_solar_power ; 31 :
125810: LD_ADDR_OWVAR 42
125814: PUSH
125815: LD_INT 27
125817: ST_TO_ADDR
125818: GO 125897
125820: LD_INT 31
125822: DOUBLE
125823: EQUAL
125824: IFTRUE 125828
125826: GO 125839
125828: POP
// bc_type := b_oil_power ; 32 :
125829: LD_ADDR_OWVAR 42
125833: PUSH
125834: LD_INT 26
125836: ST_TO_ADDR
125837: GO 125897
125839: LD_INT 32
125841: DOUBLE
125842: EQUAL
125843: IFTRUE 125847
125845: GO 125858
125847: POP
// bc_type := b_siberite_power ; 33 :
125848: LD_ADDR_OWVAR 42
125852: PUSH
125853: LD_INT 28
125855: ST_TO_ADDR
125856: GO 125897
125858: LD_INT 33
125860: DOUBLE
125861: EQUAL
125862: IFTRUE 125866
125864: GO 125877
125866: POP
// bc_type := b_oil_mine ; 34 :
125867: LD_ADDR_OWVAR 42
125871: PUSH
125872: LD_INT 29
125874: ST_TO_ADDR
125875: GO 125897
125877: LD_INT 34
125879: DOUBLE
125880: EQUAL
125881: IFTRUE 125885
125883: GO 125896
125885: POP
// bc_type := b_siberite_mine ; end ;
125886: LD_ADDR_OWVAR 42
125890: PUSH
125891: LD_INT 30
125893: ST_TO_ADDR
125894: GO 125897
125896: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125897: LD_ADDR_VAR 0 8
125901: PUSH
125902: LD_VAR 0 5
125906: PPUSH
125907: LD_VAR 0 6
125911: PPUSH
125912: LD_VAR 0 3
125916: PPUSH
125917: CALL_OW 47
125921: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125922: LD_OWVAR 42
125926: PUSH
125927: LD_INT 32
125929: PUSH
125930: LD_INT 33
125932: PUSH
125933: EMPTY
125934: LIST
125935: LIST
125936: IN
125937: IFFALSE 125953
// PlaceWeaponTurret ( b , weapon ) ;
125939: LD_VAR 0 8
125943: PPUSH
125944: LD_VAR 0 4
125948: PPUSH
125949: CALL_OW 431
// end ;
125953: LD_VAR 0 7
125957: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125958: LD_INT 0
125960: PPUSH
125961: PPUSH
125962: PPUSH
125963: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125964: LD_ADDR_VAR 0 4
125968: PUSH
125969: LD_INT 22
125971: PUSH
125972: LD_OWVAR 2
125976: PUSH
125977: EMPTY
125978: LIST
125979: LIST
125980: PUSH
125981: LD_INT 2
125983: PUSH
125984: LD_INT 30
125986: PUSH
125987: LD_INT 0
125989: PUSH
125990: EMPTY
125991: LIST
125992: LIST
125993: PUSH
125994: LD_INT 30
125996: PUSH
125997: LD_INT 1
125999: PUSH
126000: EMPTY
126001: LIST
126002: LIST
126003: PUSH
126004: EMPTY
126005: LIST
126006: LIST
126007: LIST
126008: PUSH
126009: EMPTY
126010: LIST
126011: LIST
126012: PPUSH
126013: CALL_OW 69
126017: ST_TO_ADDR
// if not tmp then
126018: LD_VAR 0 4
126022: NOT
126023: IFFALSE 126027
// exit ;
126025: GO 126086
// for i in tmp do
126027: LD_ADDR_VAR 0 2
126031: PUSH
126032: LD_VAR 0 4
126036: PUSH
126037: FOR_IN
126038: IFFALSE 126084
// for j = 1 to 3 do
126040: LD_ADDR_VAR 0 3
126044: PUSH
126045: DOUBLE
126046: LD_INT 1
126048: DEC
126049: ST_TO_ADDR
126050: LD_INT 3
126052: PUSH
126053: FOR_TO
126054: IFFALSE 126080
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126056: LD_VAR 0 2
126060: PPUSH
126061: CALL_OW 274
126065: PPUSH
126066: LD_VAR 0 3
126070: PPUSH
126071: LD_INT 99999
126073: PPUSH
126074: CALL_OW 277
126078: GO 126053
126080: POP
126081: POP
126082: GO 126037
126084: POP
126085: POP
// end ;
126086: LD_VAR 0 1
126090: RET
// export function hHackSetLevel10 ; var i , j ; begin
126091: LD_INT 0
126093: PPUSH
126094: PPUSH
126095: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126096: LD_ADDR_VAR 0 2
126100: PUSH
126101: LD_INT 21
126103: PUSH
126104: LD_INT 1
126106: PUSH
126107: EMPTY
126108: LIST
126109: LIST
126110: PPUSH
126111: CALL_OW 69
126115: PUSH
126116: FOR_IN
126117: IFFALSE 126169
// if IsSelected ( i ) then
126119: LD_VAR 0 2
126123: PPUSH
126124: CALL_OW 306
126128: IFFALSE 126167
// begin for j := 1 to 4 do
126130: LD_ADDR_VAR 0 3
126134: PUSH
126135: DOUBLE
126136: LD_INT 1
126138: DEC
126139: ST_TO_ADDR
126140: LD_INT 4
126142: PUSH
126143: FOR_TO
126144: IFFALSE 126165
// SetSkill ( i , j , 10 ) ;
126146: LD_VAR 0 2
126150: PPUSH
126151: LD_VAR 0 3
126155: PPUSH
126156: LD_INT 10
126158: PPUSH
126159: CALL_OW 237
126163: GO 126143
126165: POP
126166: POP
// end ;
126167: GO 126116
126169: POP
126170: POP
// end ;
126171: LD_VAR 0 1
126175: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126176: LD_INT 0
126178: PPUSH
126179: PPUSH
126180: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126181: LD_ADDR_VAR 0 2
126185: PUSH
126186: LD_INT 22
126188: PUSH
126189: LD_OWVAR 2
126193: PUSH
126194: EMPTY
126195: LIST
126196: LIST
126197: PUSH
126198: LD_INT 21
126200: PUSH
126201: LD_INT 1
126203: PUSH
126204: EMPTY
126205: LIST
126206: LIST
126207: PUSH
126208: EMPTY
126209: LIST
126210: LIST
126211: PPUSH
126212: CALL_OW 69
126216: PUSH
126217: FOR_IN
126218: IFFALSE 126259
// begin for j := 1 to 4 do
126220: LD_ADDR_VAR 0 3
126224: PUSH
126225: DOUBLE
126226: LD_INT 1
126228: DEC
126229: ST_TO_ADDR
126230: LD_INT 4
126232: PUSH
126233: FOR_TO
126234: IFFALSE 126255
// SetSkill ( i , j , 10 ) ;
126236: LD_VAR 0 2
126240: PPUSH
126241: LD_VAR 0 3
126245: PPUSH
126246: LD_INT 10
126248: PPUSH
126249: CALL_OW 237
126253: GO 126233
126255: POP
126256: POP
// end ;
126257: GO 126217
126259: POP
126260: POP
// end ;
126261: LD_VAR 0 1
126265: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126266: LD_INT 0
126268: PPUSH
// uc_side := your_side ;
126269: LD_ADDR_OWVAR 20
126273: PUSH
126274: LD_OWVAR 2
126278: ST_TO_ADDR
// uc_nation := nation ;
126279: LD_ADDR_OWVAR 21
126283: PUSH
126284: LD_VAR 0 1
126288: ST_TO_ADDR
// InitHc ;
126289: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126293: LD_INT 0
126295: PPUSH
126296: LD_VAR 0 2
126300: PPUSH
126301: LD_VAR 0 3
126305: PPUSH
126306: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126310: LD_VAR 0 4
126314: PPUSH
126315: LD_VAR 0 5
126319: PPUSH
126320: CALL_OW 428
126324: PUSH
126325: LD_INT 0
126327: EQUAL
126328: IFFALSE 126352
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126330: CALL_OW 44
126334: PPUSH
126335: LD_VAR 0 4
126339: PPUSH
126340: LD_VAR 0 5
126344: PPUSH
126345: LD_INT 1
126347: PPUSH
126348: CALL_OW 48
// end ;
126352: LD_VAR 0 6
126356: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126357: LD_INT 0
126359: PPUSH
126360: PPUSH
// uc_side := your_side ;
126361: LD_ADDR_OWVAR 20
126365: PUSH
126366: LD_OWVAR 2
126370: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126371: LD_VAR 0 1
126375: PUSH
126376: LD_INT 1
126378: PUSH
126379: LD_INT 2
126381: PUSH
126382: LD_INT 3
126384: PUSH
126385: LD_INT 4
126387: PUSH
126388: LD_INT 5
126390: PUSH
126391: EMPTY
126392: LIST
126393: LIST
126394: LIST
126395: LIST
126396: LIST
126397: IN
126398: IFFALSE 126410
// uc_nation := nation_american else
126400: LD_ADDR_OWVAR 21
126404: PUSH
126405: LD_INT 1
126407: ST_TO_ADDR
126408: GO 126453
// if chassis in [ 11 , 12 , 13 , 14 ] then
126410: LD_VAR 0 1
126414: PUSH
126415: LD_INT 11
126417: PUSH
126418: LD_INT 12
126420: PUSH
126421: LD_INT 13
126423: PUSH
126424: LD_INT 14
126426: PUSH
126427: EMPTY
126428: LIST
126429: LIST
126430: LIST
126431: LIST
126432: IN
126433: IFFALSE 126445
// uc_nation := nation_arabian else
126435: LD_ADDR_OWVAR 21
126439: PUSH
126440: LD_INT 2
126442: ST_TO_ADDR
126443: GO 126453
// uc_nation := nation_russian ;
126445: LD_ADDR_OWVAR 21
126449: PUSH
126450: LD_INT 3
126452: ST_TO_ADDR
// vc_chassis := chassis ;
126453: LD_ADDR_OWVAR 37
126457: PUSH
126458: LD_VAR 0 1
126462: ST_TO_ADDR
// vc_engine := engine ;
126463: LD_ADDR_OWVAR 39
126467: PUSH
126468: LD_VAR 0 2
126472: ST_TO_ADDR
// vc_control := control ;
126473: LD_ADDR_OWVAR 38
126477: PUSH
126478: LD_VAR 0 3
126482: ST_TO_ADDR
// vc_weapon := weapon ;
126483: LD_ADDR_OWVAR 40
126487: PUSH
126488: LD_VAR 0 4
126492: ST_TO_ADDR
// un := CreateVehicle ;
126493: LD_ADDR_VAR 0 8
126497: PUSH
126498: CALL_OW 45
126502: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
126503: LD_VAR 0 8
126507: PPUSH
126508: LD_INT 0
126510: PPUSH
126511: LD_INT 5
126513: PPUSH
126514: CALL_OW 12
126518: PPUSH
126519: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
126523: LD_VAR 0 8
126527: PPUSH
126528: LD_VAR 0 5
126532: PPUSH
126533: LD_VAR 0 6
126537: PPUSH
126538: LD_INT 1
126540: PPUSH
126541: CALL_OW 48
// end ;
126545: LD_VAR 0 7
126549: RET
// export hInvincible ; every 1 do
126550: GO 126552
126552: DISABLE
// hInvincible := [ ] ;
126553: LD_ADDR_EXP 205
126557: PUSH
126558: EMPTY
126559: ST_TO_ADDR
126560: END
// every 10 do var i ;
126561: GO 126563
126563: DISABLE
126564: LD_INT 0
126566: PPUSH
// begin enable ;
126567: ENABLE
// if not hInvincible then
126568: LD_EXP 205
126572: NOT
126573: IFFALSE 126577
// exit ;
126575: GO 126621
// for i in hInvincible do
126577: LD_ADDR_VAR 0 1
126581: PUSH
126582: LD_EXP 205
126586: PUSH
126587: FOR_IN
126588: IFFALSE 126619
// if GetLives ( i ) < 1000 then
126590: LD_VAR 0 1
126594: PPUSH
126595: CALL_OW 256
126599: PUSH
126600: LD_INT 1000
126602: LESS
126603: IFFALSE 126617
// SetLives ( i , 1000 ) ;
126605: LD_VAR 0 1
126609: PPUSH
126610: LD_INT 1000
126612: PPUSH
126613: CALL_OW 234
126617: GO 126587
126619: POP
126620: POP
// end ;
126621: PPOPN 1
126623: END
// export function hHackInvincible ; var i ; begin
126624: LD_INT 0
126626: PPUSH
126627: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
126628: LD_ADDR_VAR 0 2
126632: PUSH
126633: LD_INT 2
126635: PUSH
126636: LD_INT 21
126638: PUSH
126639: LD_INT 1
126641: PUSH
126642: EMPTY
126643: LIST
126644: LIST
126645: PUSH
126646: LD_INT 21
126648: PUSH
126649: LD_INT 2
126651: PUSH
126652: EMPTY
126653: LIST
126654: LIST
126655: PUSH
126656: EMPTY
126657: LIST
126658: LIST
126659: LIST
126660: PPUSH
126661: CALL_OW 69
126665: PUSH
126666: FOR_IN
126667: IFFALSE 126728
// if IsSelected ( i ) then
126669: LD_VAR 0 2
126673: PPUSH
126674: CALL_OW 306
126678: IFFALSE 126726
// begin if i in hInvincible then
126680: LD_VAR 0 2
126684: PUSH
126685: LD_EXP 205
126689: IN
126690: IFFALSE 126710
// hInvincible := hInvincible diff i else
126692: LD_ADDR_EXP 205
126696: PUSH
126697: LD_EXP 205
126701: PUSH
126702: LD_VAR 0 2
126706: DIFF
126707: ST_TO_ADDR
126708: GO 126726
// hInvincible := hInvincible union i ;
126710: LD_ADDR_EXP 205
126714: PUSH
126715: LD_EXP 205
126719: PUSH
126720: LD_VAR 0 2
126724: UNION
126725: ST_TO_ADDR
// end ;
126726: GO 126666
126728: POP
126729: POP
// end ;
126730: LD_VAR 0 1
126734: RET
// export function hHackInvisible ; var i , j ; begin
126735: LD_INT 0
126737: PPUSH
126738: PPUSH
126739: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126740: LD_ADDR_VAR 0 2
126744: PUSH
126745: LD_INT 21
126747: PUSH
126748: LD_INT 1
126750: PUSH
126751: EMPTY
126752: LIST
126753: LIST
126754: PPUSH
126755: CALL_OW 69
126759: PUSH
126760: FOR_IN
126761: IFFALSE 126785
// if IsSelected ( i ) then
126763: LD_VAR 0 2
126767: PPUSH
126768: CALL_OW 306
126772: IFFALSE 126783
// ComForceInvisible ( i ) ;
126774: LD_VAR 0 2
126778: PPUSH
126779: CALL_OW 496
126783: GO 126760
126785: POP
126786: POP
// end ;
126787: LD_VAR 0 1
126791: RET
// export function hHackChangeYourSide ; begin
126792: LD_INT 0
126794: PPUSH
// if your_side = 8 then
126795: LD_OWVAR 2
126799: PUSH
126800: LD_INT 8
126802: EQUAL
126803: IFFALSE 126815
// your_side := 0 else
126805: LD_ADDR_OWVAR 2
126809: PUSH
126810: LD_INT 0
126812: ST_TO_ADDR
126813: GO 126829
// your_side := your_side + 1 ;
126815: LD_ADDR_OWVAR 2
126819: PUSH
126820: LD_OWVAR 2
126824: PUSH
126825: LD_INT 1
126827: PLUS
126828: ST_TO_ADDR
// end ;
126829: LD_VAR 0 1
126833: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126834: LD_INT 0
126836: PPUSH
126837: PPUSH
126838: PPUSH
// for i in all_units do
126839: LD_ADDR_VAR 0 2
126843: PUSH
126844: LD_OWVAR 3
126848: PUSH
126849: FOR_IN
126850: IFFALSE 126928
// if IsSelected ( i ) then
126852: LD_VAR 0 2
126856: PPUSH
126857: CALL_OW 306
126861: IFFALSE 126926
// begin j := GetSide ( i ) ;
126863: LD_ADDR_VAR 0 3
126867: PUSH
126868: LD_VAR 0 2
126872: PPUSH
126873: CALL_OW 255
126877: ST_TO_ADDR
// if j = 8 then
126878: LD_VAR 0 3
126882: PUSH
126883: LD_INT 8
126885: EQUAL
126886: IFFALSE 126898
// j := 0 else
126888: LD_ADDR_VAR 0 3
126892: PUSH
126893: LD_INT 0
126895: ST_TO_ADDR
126896: GO 126912
// j := j + 1 ;
126898: LD_ADDR_VAR 0 3
126902: PUSH
126903: LD_VAR 0 3
126907: PUSH
126908: LD_INT 1
126910: PLUS
126911: ST_TO_ADDR
// SetSide ( i , j ) ;
126912: LD_VAR 0 2
126916: PPUSH
126917: LD_VAR 0 3
126921: PPUSH
126922: CALL_OW 235
// end ;
126926: GO 126849
126928: POP
126929: POP
// end ;
126930: LD_VAR 0 1
126934: RET
// export function hHackFog ; begin
126935: LD_INT 0
126937: PPUSH
// FogOff ( true ) ;
126938: LD_INT 1
126940: PPUSH
126941: CALL_OW 344
// end ;
126945: LD_VAR 0 1
126949: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126950: LD_INT 0
126952: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126953: LD_VAR 0 1
126957: PPUSH
126958: LD_VAR 0 2
126962: PPUSH
126963: LD_VAR 0 3
126967: PPUSH
126968: LD_INT 1
126970: PPUSH
126971: LD_INT 1
126973: PPUSH
126974: CALL_OW 483
// CenterOnXY ( x , y ) ;
126978: LD_VAR 0 2
126982: PPUSH
126983: LD_VAR 0 3
126987: PPUSH
126988: CALL_OW 84
// end ;
126992: LD_VAR 0 4
126996: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126997: LD_INT 0
126999: PPUSH
127000: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127001: LD_VAR 0 1
127005: NOT
127006: PUSH
127007: LD_VAR 0 2
127011: PPUSH
127012: LD_VAR 0 3
127016: PPUSH
127017: CALL_OW 488
127021: NOT
127022: OR
127023: PUSH
127024: LD_VAR 0 1
127028: PPUSH
127029: CALL_OW 266
127033: PUSH
127034: LD_INT 3
127036: NONEQUAL
127037: PUSH
127038: LD_VAR 0 1
127042: PPUSH
127043: CALL_OW 247
127047: PUSH
127048: LD_INT 1
127050: EQUAL
127051: NOT
127052: AND
127053: OR
127054: IFFALSE 127058
// exit ;
127056: GO 127207
// if GetType ( factory ) = unit_human then
127058: LD_VAR 0 1
127062: PPUSH
127063: CALL_OW 247
127067: PUSH
127068: LD_INT 1
127070: EQUAL
127071: IFFALSE 127088
// factory := IsInUnit ( factory ) ;
127073: LD_ADDR_VAR 0 1
127077: PUSH
127078: LD_VAR 0 1
127082: PPUSH
127083: CALL_OW 310
127087: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127088: LD_VAR 0 1
127092: PPUSH
127093: CALL_OW 266
127097: PUSH
127098: LD_INT 3
127100: NONEQUAL
127101: IFFALSE 127105
// exit ;
127103: GO 127207
// if HexInfo ( x , y ) = factory then
127105: LD_VAR 0 2
127109: PPUSH
127110: LD_VAR 0 3
127114: PPUSH
127115: CALL_OW 428
127119: PUSH
127120: LD_VAR 0 1
127124: EQUAL
127125: IFFALSE 127152
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
127127: LD_ADDR_EXP 206
127131: PUSH
127132: LD_EXP 206
127136: PPUSH
127137: LD_VAR 0 1
127141: PPUSH
127142: LD_INT 0
127144: PPUSH
127145: CALL_OW 1
127149: ST_TO_ADDR
127150: GO 127203
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
127152: LD_ADDR_EXP 206
127156: PUSH
127157: LD_EXP 206
127161: PPUSH
127162: LD_VAR 0 1
127166: PPUSH
127167: LD_VAR 0 1
127171: PPUSH
127172: CALL_OW 255
127176: PUSH
127177: LD_VAR 0 1
127181: PUSH
127182: LD_VAR 0 2
127186: PUSH
127187: LD_VAR 0 3
127191: PUSH
127192: EMPTY
127193: LIST
127194: LIST
127195: LIST
127196: LIST
127197: PPUSH
127198: CALL_OW 1
127202: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127203: CALL 127212 0 0
// end ;
127207: LD_VAR 0 4
127211: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127212: LD_INT 0
127214: PPUSH
127215: PPUSH
127216: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127217: LD_STRING resetFactoryWaypoint();
127219: PPUSH
127220: CALL_OW 559
// if factoryWaypoints then
127224: LD_EXP 206
127228: IFFALSE 127354
// begin list := PrepareArray ( factoryWaypoints ) ;
127230: LD_ADDR_VAR 0 3
127234: PUSH
127235: LD_EXP 206
127239: PPUSH
127240: CALL 111167 0 1
127244: ST_TO_ADDR
// for i := 1 to list do
127245: LD_ADDR_VAR 0 2
127249: PUSH
127250: DOUBLE
127251: LD_INT 1
127253: DEC
127254: ST_TO_ADDR
127255: LD_VAR 0 3
127259: PUSH
127260: FOR_TO
127261: IFFALSE 127352
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127263: LD_STRING setFactoryWaypointXY(
127265: PUSH
127266: LD_VAR 0 3
127270: PUSH
127271: LD_VAR 0 2
127275: ARRAY
127276: PUSH
127277: LD_INT 1
127279: ARRAY
127280: STR
127281: PUSH
127282: LD_STRING ,
127284: STR
127285: PUSH
127286: LD_VAR 0 3
127290: PUSH
127291: LD_VAR 0 2
127295: ARRAY
127296: PUSH
127297: LD_INT 2
127299: ARRAY
127300: STR
127301: PUSH
127302: LD_STRING ,
127304: STR
127305: PUSH
127306: LD_VAR 0 3
127310: PUSH
127311: LD_VAR 0 2
127315: ARRAY
127316: PUSH
127317: LD_INT 3
127319: ARRAY
127320: STR
127321: PUSH
127322: LD_STRING ,
127324: STR
127325: PUSH
127326: LD_VAR 0 3
127330: PUSH
127331: LD_VAR 0 2
127335: ARRAY
127336: PUSH
127337: LD_INT 4
127339: ARRAY
127340: STR
127341: PUSH
127342: LD_STRING )
127344: STR
127345: PPUSH
127346: CALL_OW 559
127350: GO 127260
127352: POP
127353: POP
// end ; end ;
127354: LD_VAR 0 1
127358: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127359: LD_INT 0
127361: PPUSH
// if HexInfo ( x , y ) = warehouse then
127362: LD_VAR 0 2
127366: PPUSH
127367: LD_VAR 0 3
127371: PPUSH
127372: CALL_OW 428
127376: PUSH
127377: LD_VAR 0 1
127381: EQUAL
127382: IFFALSE 127409
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127384: LD_ADDR_EXP 207
127388: PUSH
127389: LD_EXP 207
127393: PPUSH
127394: LD_VAR 0 1
127398: PPUSH
127399: LD_INT 0
127401: PPUSH
127402: CALL_OW 1
127406: ST_TO_ADDR
127407: GO 127460
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127409: LD_ADDR_EXP 207
127413: PUSH
127414: LD_EXP 207
127418: PPUSH
127419: LD_VAR 0 1
127423: PPUSH
127424: LD_VAR 0 1
127428: PPUSH
127429: CALL_OW 255
127433: PUSH
127434: LD_VAR 0 1
127438: PUSH
127439: LD_VAR 0 2
127443: PUSH
127444: LD_VAR 0 3
127448: PUSH
127449: EMPTY
127450: LIST
127451: LIST
127452: LIST
127453: LIST
127454: PPUSH
127455: CALL_OW 1
127459: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
127460: CALL 127469 0 0
// end ;
127464: LD_VAR 0 4
127468: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
127469: LD_INT 0
127471: PPUSH
127472: PPUSH
127473: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
127474: LD_STRING resetWarehouseGatheringPoints();
127476: PPUSH
127477: CALL_OW 559
// if warehouseGatheringPoints then
127481: LD_EXP 207
127485: IFFALSE 127611
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
127487: LD_ADDR_VAR 0 3
127491: PUSH
127492: LD_EXP 207
127496: PPUSH
127497: CALL 111167 0 1
127501: ST_TO_ADDR
// for i := 1 to list do
127502: LD_ADDR_VAR 0 2
127506: PUSH
127507: DOUBLE
127508: LD_INT 1
127510: DEC
127511: ST_TO_ADDR
127512: LD_VAR 0 3
127516: PUSH
127517: FOR_TO
127518: IFFALSE 127609
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127520: LD_STRING setWarehouseGatheringPointXY(
127522: PUSH
127523: LD_VAR 0 3
127527: PUSH
127528: LD_VAR 0 2
127532: ARRAY
127533: PUSH
127534: LD_INT 1
127536: ARRAY
127537: STR
127538: PUSH
127539: LD_STRING ,
127541: STR
127542: PUSH
127543: LD_VAR 0 3
127547: PUSH
127548: LD_VAR 0 2
127552: ARRAY
127553: PUSH
127554: LD_INT 2
127556: ARRAY
127557: STR
127558: PUSH
127559: LD_STRING ,
127561: STR
127562: PUSH
127563: LD_VAR 0 3
127567: PUSH
127568: LD_VAR 0 2
127572: ARRAY
127573: PUSH
127574: LD_INT 3
127576: ARRAY
127577: STR
127578: PUSH
127579: LD_STRING ,
127581: STR
127582: PUSH
127583: LD_VAR 0 3
127587: PUSH
127588: LD_VAR 0 2
127592: ARRAY
127593: PUSH
127594: LD_INT 4
127596: ARRAY
127597: STR
127598: PUSH
127599: LD_STRING )
127601: STR
127602: PPUSH
127603: CALL_OW 559
127607: GO 127517
127609: POP
127610: POP
// end ; end ;
127611: LD_VAR 0 1
127615: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
127616: LD_EXP 207
127620: IFFALSE 128305
127622: GO 127624
127624: DISABLE
127625: LD_INT 0
127627: PPUSH
127628: PPUSH
127629: PPUSH
127630: PPUSH
127631: PPUSH
127632: PPUSH
127633: PPUSH
127634: PPUSH
127635: PPUSH
// begin enable ;
127636: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
127637: LD_ADDR_VAR 0 3
127641: PUSH
127642: LD_EXP 207
127646: PPUSH
127647: CALL 111167 0 1
127651: ST_TO_ADDR
// if not list then
127652: LD_VAR 0 3
127656: NOT
127657: IFFALSE 127661
// exit ;
127659: GO 128305
// for i := 1 to list do
127661: LD_ADDR_VAR 0 1
127665: PUSH
127666: DOUBLE
127667: LD_INT 1
127669: DEC
127670: ST_TO_ADDR
127671: LD_VAR 0 3
127675: PUSH
127676: FOR_TO
127677: IFFALSE 128303
// begin depot := list [ i ] [ 2 ] ;
127679: LD_ADDR_VAR 0 8
127683: PUSH
127684: LD_VAR 0 3
127688: PUSH
127689: LD_VAR 0 1
127693: ARRAY
127694: PUSH
127695: LD_INT 2
127697: ARRAY
127698: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
127699: LD_ADDR_VAR 0 5
127703: PUSH
127704: LD_VAR 0 3
127708: PUSH
127709: LD_VAR 0 1
127713: ARRAY
127714: PUSH
127715: LD_INT 1
127717: ARRAY
127718: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
127719: LD_VAR 0 8
127723: PPUSH
127724: CALL_OW 301
127728: PUSH
127729: LD_VAR 0 5
127733: PUSH
127734: LD_VAR 0 8
127738: PPUSH
127739: CALL_OW 255
127743: NONEQUAL
127744: OR
127745: IFFALSE 127774
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
127747: LD_ADDR_EXP 207
127751: PUSH
127752: LD_EXP 207
127756: PPUSH
127757: LD_VAR 0 8
127761: PPUSH
127762: LD_INT 0
127764: PPUSH
127765: CALL_OW 1
127769: ST_TO_ADDR
// exit ;
127770: POP
127771: POP
127772: GO 128305
// end ; x := list [ i ] [ 3 ] ;
127774: LD_ADDR_VAR 0 6
127778: PUSH
127779: LD_VAR 0 3
127783: PUSH
127784: LD_VAR 0 1
127788: ARRAY
127789: PUSH
127790: LD_INT 3
127792: ARRAY
127793: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
127794: LD_ADDR_VAR 0 7
127798: PUSH
127799: LD_VAR 0 3
127803: PUSH
127804: LD_VAR 0 1
127808: ARRAY
127809: PUSH
127810: LD_INT 4
127812: ARRAY
127813: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
127814: LD_ADDR_VAR 0 9
127818: PUSH
127819: LD_VAR 0 6
127823: PPUSH
127824: LD_VAR 0 7
127828: PPUSH
127829: LD_INT 16
127831: PPUSH
127832: CALL 109755 0 3
127836: ST_TO_ADDR
// if not cratesNearbyPoint then
127837: LD_VAR 0 9
127841: NOT
127842: IFFALSE 127848
// exit ;
127844: POP
127845: POP
127846: GO 128305
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127848: LD_ADDR_VAR 0 4
127852: PUSH
127853: LD_INT 22
127855: PUSH
127856: LD_VAR 0 5
127860: PUSH
127861: EMPTY
127862: LIST
127863: LIST
127864: PUSH
127865: LD_INT 3
127867: PUSH
127868: LD_INT 60
127870: PUSH
127871: EMPTY
127872: LIST
127873: PUSH
127874: EMPTY
127875: LIST
127876: LIST
127877: PUSH
127878: LD_INT 91
127880: PUSH
127881: LD_VAR 0 8
127885: PUSH
127886: LD_INT 6
127888: PUSH
127889: EMPTY
127890: LIST
127891: LIST
127892: LIST
127893: PUSH
127894: LD_INT 2
127896: PUSH
127897: LD_INT 25
127899: PUSH
127900: LD_INT 2
127902: PUSH
127903: EMPTY
127904: LIST
127905: LIST
127906: PUSH
127907: LD_INT 25
127909: PUSH
127910: LD_INT 16
127912: PUSH
127913: EMPTY
127914: LIST
127915: LIST
127916: PUSH
127917: EMPTY
127918: LIST
127919: LIST
127920: LIST
127921: PUSH
127922: EMPTY
127923: LIST
127924: LIST
127925: LIST
127926: LIST
127927: PPUSH
127928: CALL_OW 69
127932: PUSH
127933: LD_VAR 0 8
127937: PPUSH
127938: CALL_OW 313
127942: PPUSH
127943: LD_INT 3
127945: PUSH
127946: LD_INT 60
127948: PUSH
127949: EMPTY
127950: LIST
127951: PUSH
127952: EMPTY
127953: LIST
127954: LIST
127955: PUSH
127956: LD_INT 2
127958: PUSH
127959: LD_INT 25
127961: PUSH
127962: LD_INT 2
127964: PUSH
127965: EMPTY
127966: LIST
127967: LIST
127968: PUSH
127969: LD_INT 25
127971: PUSH
127972: LD_INT 16
127974: PUSH
127975: EMPTY
127976: LIST
127977: LIST
127978: PUSH
127979: EMPTY
127980: LIST
127981: LIST
127982: LIST
127983: PUSH
127984: EMPTY
127985: LIST
127986: LIST
127987: PPUSH
127988: CALL_OW 72
127992: UNION
127993: ST_TO_ADDR
// if tmp then
127994: LD_VAR 0 4
127998: IFFALSE 128078
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128000: LD_ADDR_VAR 0 4
128004: PUSH
128005: LD_VAR 0 4
128009: PPUSH
128010: LD_INT 3
128012: PPUSH
128013: CALL 107724 0 2
128017: ST_TO_ADDR
// for j in tmp do
128018: LD_ADDR_VAR 0 2
128022: PUSH
128023: LD_VAR 0 4
128027: PUSH
128028: FOR_IN
128029: IFFALSE 128072
// begin if IsInUnit ( j ) then
128031: LD_VAR 0 2
128035: PPUSH
128036: CALL_OW 310
128040: IFFALSE 128051
// ComExit ( j ) ;
128042: LD_VAR 0 2
128046: PPUSH
128047: CALL 107807 0 1
// AddComCollect ( j , x , y ) ;
128051: LD_VAR 0 2
128055: PPUSH
128056: LD_VAR 0 6
128060: PPUSH
128061: LD_VAR 0 7
128065: PPUSH
128066: CALL_OW 177
// end ;
128070: GO 128028
128072: POP
128073: POP
// exit ;
128074: POP
128075: POP
128076: GO 128305
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128078: LD_ADDR_VAR 0 4
128082: PUSH
128083: LD_INT 22
128085: PUSH
128086: LD_VAR 0 5
128090: PUSH
128091: EMPTY
128092: LIST
128093: LIST
128094: PUSH
128095: LD_INT 91
128097: PUSH
128098: LD_VAR 0 8
128102: PUSH
128103: LD_INT 8
128105: PUSH
128106: EMPTY
128107: LIST
128108: LIST
128109: LIST
128110: PUSH
128111: LD_INT 2
128113: PUSH
128114: LD_INT 34
128116: PUSH
128117: LD_INT 12
128119: PUSH
128120: EMPTY
128121: LIST
128122: LIST
128123: PUSH
128124: LD_INT 34
128126: PUSH
128127: LD_INT 51
128129: PUSH
128130: EMPTY
128131: LIST
128132: LIST
128133: PUSH
128134: LD_INT 34
128136: PUSH
128137: LD_INT 32
128139: PUSH
128140: EMPTY
128141: LIST
128142: LIST
128143: PUSH
128144: LD_INT 34
128146: PUSH
128147: LD_INT 89
128149: PUSH
128150: EMPTY
128151: LIST
128152: LIST
128153: PUSH
128154: EMPTY
128155: LIST
128156: LIST
128157: LIST
128158: LIST
128159: LIST
128160: PUSH
128161: EMPTY
128162: LIST
128163: LIST
128164: LIST
128165: PPUSH
128166: CALL_OW 69
128170: ST_TO_ADDR
// if tmp then
128171: LD_VAR 0 4
128175: IFFALSE 128301
// begin for j in tmp do
128177: LD_ADDR_VAR 0 2
128181: PUSH
128182: LD_VAR 0 4
128186: PUSH
128187: FOR_IN
128188: IFFALSE 128299
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128190: LD_VAR 0 2
128194: PPUSH
128195: CALL_OW 262
128199: PUSH
128200: LD_INT 3
128202: EQUAL
128203: PUSH
128204: LD_VAR 0 2
128208: PPUSH
128209: CALL_OW 261
128213: PUSH
128214: LD_INT 20
128216: GREATER
128217: OR
128218: PUSH
128219: LD_VAR 0 2
128223: PPUSH
128224: CALL_OW 314
128228: NOT
128229: AND
128230: PUSH
128231: LD_VAR 0 2
128235: PPUSH
128236: CALL_OW 263
128240: PUSH
128241: LD_INT 1
128243: NONEQUAL
128244: PUSH
128245: LD_VAR 0 2
128249: PPUSH
128250: CALL_OW 311
128254: OR
128255: AND
128256: IFFALSE 128297
// begin ComCollect ( j , x , y ) ;
128258: LD_VAR 0 2
128262: PPUSH
128263: LD_VAR 0 6
128267: PPUSH
128268: LD_VAR 0 7
128272: PPUSH
128273: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128277: LD_VAR 0 2
128281: PPUSH
128282: LD_VAR 0 8
128286: PPUSH
128287: CALL_OW 172
// exit ;
128291: POP
128292: POP
128293: POP
128294: POP
128295: GO 128305
// end ;
128297: GO 128187
128299: POP
128300: POP
// end ; end ;
128301: GO 127676
128303: POP
128304: POP
// end ; end_of_file
128305: PPOPN 9
128307: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
128308: LD_INT 0
128310: PPUSH
128311: PPUSH
128312: PPUSH
128313: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
128314: LD_VAR 0 1
128318: PPUSH
128319: CALL_OW 264
128323: PUSH
128324: LD_INT 91
128326: EQUAL
128327: IFFALSE 128399
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
128329: LD_INT 68
128331: PPUSH
128332: LD_VAR 0 1
128336: PPUSH
128337: CALL_OW 255
128341: PPUSH
128342: CALL_OW 321
128346: PUSH
128347: LD_INT 2
128349: EQUAL
128350: IFFALSE 128362
// eff := 70 else
128352: LD_ADDR_VAR 0 4
128356: PUSH
128357: LD_INT 70
128359: ST_TO_ADDR
128360: GO 128370
// eff := 30 ;
128362: LD_ADDR_VAR 0 4
128366: PUSH
128367: LD_INT 30
128369: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
128370: LD_VAR 0 1
128374: PPUSH
128375: CALL_OW 250
128379: PPUSH
128380: LD_VAR 0 1
128384: PPUSH
128385: CALL_OW 251
128389: PPUSH
128390: LD_VAR 0 4
128394: PPUSH
128395: CALL_OW 495
// end ; end ;
128399: LD_VAR 0 2
128403: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128404: LD_INT 0
128406: PPUSH
// end ;
128407: LD_VAR 0 4
128411: RET
// export function SOS_Command ( cmd ) ; begin
128412: LD_INT 0
128414: PPUSH
// end ;
128415: LD_VAR 0 2
128419: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128420: LD_INT 0
128422: PPUSH
// end ;
128423: LD_VAR 0 6
128427: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
128428: LD_INT 0
128430: PPUSH
128431: PPUSH
// if not vehicle or not factory then
128432: LD_VAR 0 1
128436: NOT
128437: PUSH
128438: LD_VAR 0 2
128442: NOT
128443: OR
128444: IFFALSE 128448
// exit ;
128446: GO 128679
// if factoryWaypoints >= factory then
128448: LD_EXP 206
128452: PUSH
128453: LD_VAR 0 2
128457: GREATEREQUAL
128458: IFFALSE 128679
// if factoryWaypoints [ factory ] then
128460: LD_EXP 206
128464: PUSH
128465: LD_VAR 0 2
128469: ARRAY
128470: IFFALSE 128679
// begin if GetControl ( vehicle ) = control_manual then
128472: LD_VAR 0 1
128476: PPUSH
128477: CALL_OW 263
128481: PUSH
128482: LD_INT 1
128484: EQUAL
128485: IFFALSE 128566
// begin driver := IsDrivenBy ( vehicle ) ;
128487: LD_ADDR_VAR 0 4
128491: PUSH
128492: LD_VAR 0 1
128496: PPUSH
128497: CALL_OW 311
128501: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128502: LD_VAR 0 4
128506: PPUSH
128507: LD_EXP 206
128511: PUSH
128512: LD_VAR 0 2
128516: ARRAY
128517: PUSH
128518: LD_INT 3
128520: ARRAY
128521: PPUSH
128522: LD_EXP 206
128526: PUSH
128527: LD_VAR 0 2
128531: ARRAY
128532: PUSH
128533: LD_INT 4
128535: ARRAY
128536: PPUSH
128537: CALL_OW 171
// AddComExitVehicle ( driver ) ;
128541: LD_VAR 0 4
128545: PPUSH
128546: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
128550: LD_VAR 0 4
128554: PPUSH
128555: LD_VAR 0 2
128559: PPUSH
128560: CALL_OW 180
// end else
128564: GO 128679
// if GetControl ( vehicle ) = control_remote then
128566: LD_VAR 0 1
128570: PPUSH
128571: CALL_OW 263
128575: PUSH
128576: LD_INT 2
128578: EQUAL
128579: IFFALSE 128640
// begin wait ( 0 0$2 ) ;
128581: LD_INT 70
128583: PPUSH
128584: CALL_OW 67
// if Connect ( vehicle ) then
128588: LD_VAR 0 1
128592: PPUSH
128593: CALL 78026 0 1
128597: IFFALSE 128638
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128599: LD_VAR 0 1
128603: PPUSH
128604: LD_EXP 206
128608: PUSH
128609: LD_VAR 0 2
128613: ARRAY
128614: PUSH
128615: LD_INT 3
128617: ARRAY
128618: PPUSH
128619: LD_EXP 206
128623: PUSH
128624: LD_VAR 0 2
128628: ARRAY
128629: PUSH
128630: LD_INT 4
128632: ARRAY
128633: PPUSH
128634: CALL_OW 171
// end else
128638: GO 128679
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128640: LD_VAR 0 1
128644: PPUSH
128645: LD_EXP 206
128649: PUSH
128650: LD_VAR 0 2
128654: ARRAY
128655: PUSH
128656: LD_INT 3
128658: ARRAY
128659: PPUSH
128660: LD_EXP 206
128664: PUSH
128665: LD_VAR 0 2
128669: ARRAY
128670: PUSH
128671: LD_INT 4
128673: ARRAY
128674: PPUSH
128675: CALL_OW 171
// end ; end ;
128679: LD_VAR 0 3
128683: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
128684: LD_INT 0
128686: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
128687: LD_VAR 0 1
128691: PUSH
128692: LD_INT 250
128694: EQUAL
128695: PUSH
128696: LD_VAR 0 2
128700: PPUSH
128701: CALL_OW 264
128705: PUSH
128706: LD_INT 81
128708: EQUAL
128709: AND
128710: IFFALSE 128731
// MinerPlaceMine ( unit , x , y ) ;
128712: LD_VAR 0 2
128716: PPUSH
128717: LD_VAR 0 4
128721: PPUSH
128722: LD_VAR 0 5
128726: PPUSH
128727: CALL 131721 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
128731: LD_VAR 0 1
128735: PUSH
128736: LD_INT 251
128738: EQUAL
128739: PUSH
128740: LD_VAR 0 2
128744: PPUSH
128745: CALL_OW 264
128749: PUSH
128750: LD_INT 81
128752: EQUAL
128753: AND
128754: IFFALSE 128775
// MinerDetonateMine ( unit , x , y ) ;
128756: LD_VAR 0 2
128760: PPUSH
128761: LD_VAR 0 4
128765: PPUSH
128766: LD_VAR 0 5
128770: PPUSH
128771: CALL 131996 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
128775: LD_VAR 0 1
128779: PUSH
128780: LD_INT 252
128782: EQUAL
128783: PUSH
128784: LD_VAR 0 2
128788: PPUSH
128789: CALL_OW 264
128793: PUSH
128794: LD_INT 81
128796: EQUAL
128797: AND
128798: IFFALSE 128819
// MinerCreateMinefield ( unit , x , y ) ;
128800: LD_VAR 0 2
128804: PPUSH
128805: LD_VAR 0 4
128809: PPUSH
128810: LD_VAR 0 5
128814: PPUSH
128815: CALL 132413 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
128819: LD_VAR 0 1
128823: PUSH
128824: LD_INT 253
128826: EQUAL
128827: PUSH
128828: LD_VAR 0 2
128832: PPUSH
128833: CALL_OW 257
128837: PUSH
128838: LD_INT 5
128840: EQUAL
128841: AND
128842: IFFALSE 128863
// ComBinocular ( unit , x , y ) ;
128844: LD_VAR 0 2
128848: PPUSH
128849: LD_VAR 0 4
128853: PPUSH
128854: LD_VAR 0 5
128858: PPUSH
128859: CALL 132782 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128863: LD_VAR 0 1
128867: PUSH
128868: LD_INT 254
128870: EQUAL
128871: PUSH
128872: LD_VAR 0 2
128876: PPUSH
128877: CALL_OW 264
128881: PUSH
128882: LD_INT 99
128884: EQUAL
128885: AND
128886: PUSH
128887: LD_VAR 0 3
128891: PPUSH
128892: CALL_OW 263
128896: PUSH
128897: LD_INT 3
128899: EQUAL
128900: AND
128901: IFFALSE 128917
// HackDestroyVehicle ( unit , selectedUnit ) ;
128903: LD_VAR 0 2
128907: PPUSH
128908: LD_VAR 0 3
128912: PPUSH
128913: CALL 131085 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128917: LD_VAR 0 1
128921: PUSH
128922: LD_INT 255
128924: EQUAL
128925: PUSH
128926: LD_VAR 0 2
128930: PPUSH
128931: CALL_OW 264
128935: PUSH
128936: LD_INT 14
128938: PUSH
128939: LD_INT 53
128941: PUSH
128942: EMPTY
128943: LIST
128944: LIST
128945: IN
128946: AND
128947: PUSH
128948: LD_VAR 0 4
128952: PPUSH
128953: LD_VAR 0 5
128957: PPUSH
128958: CALL_OW 488
128962: AND
128963: IFFALSE 128987
// CutTreeXYR ( unit , x , y , 12 ) ;
128965: LD_VAR 0 2
128969: PPUSH
128970: LD_VAR 0 4
128974: PPUSH
128975: LD_VAR 0 5
128979: PPUSH
128980: LD_INT 12
128982: PPUSH
128983: CALL 129082 0 4
// if cmd = 256 then
128987: LD_VAR 0 1
128991: PUSH
128992: LD_INT 256
128994: EQUAL
128995: IFFALSE 129016
// SetFactoryWaypoint ( unit , x , y ) ;
128997: LD_VAR 0 2
129001: PPUSH
129002: LD_VAR 0 4
129006: PPUSH
129007: LD_VAR 0 5
129011: PPUSH
129012: CALL 126997 0 3
// if cmd = 257 then
129016: LD_VAR 0 1
129020: PUSH
129021: LD_INT 257
129023: EQUAL
129024: IFFALSE 129045
// SetWarehouseGatheringPoint ( unit , x , y ) ;
129026: LD_VAR 0 2
129030: PPUSH
129031: LD_VAR 0 4
129035: PPUSH
129036: LD_VAR 0 5
129040: PPUSH
129041: CALL 127359 0 3
// if cmd = 258 then
129045: LD_VAR 0 1
129049: PUSH
129050: LD_INT 258
129052: EQUAL
129053: IFFALSE 129077
// BurnTreeXYR ( unit , x , y , 8 ) ;
129055: LD_VAR 0 2
129059: PPUSH
129060: LD_VAR 0 4
129064: PPUSH
129065: LD_VAR 0 5
129069: PPUSH
129070: LD_INT 8
129072: PPUSH
129073: CALL 129476 0 4
// end ;
129077: LD_VAR 0 6
129081: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
129082: LD_INT 0
129084: PPUSH
129085: PPUSH
129086: PPUSH
129087: PPUSH
129088: PPUSH
129089: PPUSH
129090: PPUSH
129091: PPUSH
129092: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
129093: LD_VAR 0 1
129097: PPUSH
129098: CALL_OW 302
129102: NOT
129103: PUSH
129104: LD_VAR 0 2
129108: PPUSH
129109: LD_VAR 0 3
129113: PPUSH
129114: CALL_OW 488
129118: NOT
129119: OR
129120: PUSH
129121: LD_VAR 0 4
129125: NOT
129126: OR
129127: IFFALSE 129131
// exit ;
129129: GO 129471
// list := [ ] ;
129131: LD_ADDR_VAR 0 13
129135: PUSH
129136: EMPTY
129137: ST_TO_ADDR
// if x - r < 0 then
129138: LD_VAR 0 2
129142: PUSH
129143: LD_VAR 0 4
129147: MINUS
129148: PUSH
129149: LD_INT 0
129151: LESS
129152: IFFALSE 129164
// min_x := 0 else
129154: LD_ADDR_VAR 0 7
129158: PUSH
129159: LD_INT 0
129161: ST_TO_ADDR
129162: GO 129180
// min_x := x - r ;
129164: LD_ADDR_VAR 0 7
129168: PUSH
129169: LD_VAR 0 2
129173: PUSH
129174: LD_VAR 0 4
129178: MINUS
129179: ST_TO_ADDR
// if y - r < 0 then
129180: LD_VAR 0 3
129184: PUSH
129185: LD_VAR 0 4
129189: MINUS
129190: PUSH
129191: LD_INT 0
129193: LESS
129194: IFFALSE 129206
// min_y := 0 else
129196: LD_ADDR_VAR 0 8
129200: PUSH
129201: LD_INT 0
129203: ST_TO_ADDR
129204: GO 129222
// min_y := y - r ;
129206: LD_ADDR_VAR 0 8
129210: PUSH
129211: LD_VAR 0 3
129215: PUSH
129216: LD_VAR 0 4
129220: MINUS
129221: ST_TO_ADDR
// max_x := x + r ;
129222: LD_ADDR_VAR 0 9
129226: PUSH
129227: LD_VAR 0 2
129231: PUSH
129232: LD_VAR 0 4
129236: PLUS
129237: ST_TO_ADDR
// max_y := y + r ;
129238: LD_ADDR_VAR 0 10
129242: PUSH
129243: LD_VAR 0 3
129247: PUSH
129248: LD_VAR 0 4
129252: PLUS
129253: ST_TO_ADDR
// for _x = min_x to max_x do
129254: LD_ADDR_VAR 0 11
129258: PUSH
129259: DOUBLE
129260: LD_VAR 0 7
129264: DEC
129265: ST_TO_ADDR
129266: LD_VAR 0 9
129270: PUSH
129271: FOR_TO
129272: IFFALSE 129389
// for _y = min_y to max_y do
129274: LD_ADDR_VAR 0 12
129278: PUSH
129279: DOUBLE
129280: LD_VAR 0 8
129284: DEC
129285: ST_TO_ADDR
129286: LD_VAR 0 10
129290: PUSH
129291: FOR_TO
129292: IFFALSE 129385
// begin if not ValidHex ( _x , _y ) then
129294: LD_VAR 0 11
129298: PPUSH
129299: LD_VAR 0 12
129303: PPUSH
129304: CALL_OW 488
129308: NOT
129309: IFFALSE 129313
// continue ;
129311: GO 129291
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129313: LD_VAR 0 11
129317: PPUSH
129318: LD_VAR 0 12
129322: PPUSH
129323: CALL_OW 351
129327: PUSH
129328: LD_VAR 0 11
129332: PPUSH
129333: LD_VAR 0 12
129337: PPUSH
129338: CALL_OW 554
129342: AND
129343: IFFALSE 129383
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129345: LD_ADDR_VAR 0 13
129349: PUSH
129350: LD_VAR 0 13
129354: PPUSH
129355: LD_VAR 0 13
129359: PUSH
129360: LD_INT 1
129362: PLUS
129363: PPUSH
129364: LD_VAR 0 11
129368: PUSH
129369: LD_VAR 0 12
129373: PUSH
129374: EMPTY
129375: LIST
129376: LIST
129377: PPUSH
129378: CALL_OW 2
129382: ST_TO_ADDR
// end ;
129383: GO 129291
129385: POP
129386: POP
129387: GO 129271
129389: POP
129390: POP
// if not list then
129391: LD_VAR 0 13
129395: NOT
129396: IFFALSE 129400
// exit ;
129398: GO 129471
// for i in list do
129400: LD_ADDR_VAR 0 6
129404: PUSH
129405: LD_VAR 0 13
129409: PUSH
129410: FOR_IN
129411: IFFALSE 129469
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
129413: LD_VAR 0 1
129417: PPUSH
129418: LD_STRING M
129420: PUSH
129421: LD_VAR 0 6
129425: PUSH
129426: LD_INT 1
129428: ARRAY
129429: PUSH
129430: LD_VAR 0 6
129434: PUSH
129435: LD_INT 2
129437: ARRAY
129438: PUSH
129439: LD_INT 0
129441: PUSH
129442: LD_INT 0
129444: PUSH
129445: LD_INT 0
129447: PUSH
129448: LD_INT 0
129450: PUSH
129451: EMPTY
129452: LIST
129453: LIST
129454: LIST
129455: LIST
129456: LIST
129457: LIST
129458: LIST
129459: PUSH
129460: EMPTY
129461: LIST
129462: PPUSH
129463: CALL_OW 447
129467: GO 129410
129469: POP
129470: POP
// end ;
129471: LD_VAR 0 5
129475: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
129476: LD_INT 0
129478: PPUSH
129479: PPUSH
129480: PPUSH
129481: PPUSH
129482: PPUSH
129483: PPUSH
129484: PPUSH
129485: PPUSH
129486: PPUSH
129487: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
129488: LD_VAR 0 1
129492: PPUSH
129493: CALL_OW 302
129497: NOT
129498: PUSH
129499: LD_VAR 0 2
129503: PPUSH
129504: LD_VAR 0 3
129508: PPUSH
129509: CALL_OW 488
129513: NOT
129514: OR
129515: PUSH
129516: LD_VAR 0 4
129520: NOT
129521: OR
129522: IFFALSE 129526
// exit ;
129524: GO 130039
// list := [ ] ;
129526: LD_ADDR_VAR 0 13
129530: PUSH
129531: EMPTY
129532: ST_TO_ADDR
// if x - r < 0 then
129533: LD_VAR 0 2
129537: PUSH
129538: LD_VAR 0 4
129542: MINUS
129543: PUSH
129544: LD_INT 0
129546: LESS
129547: IFFALSE 129559
// min_x := 0 else
129549: LD_ADDR_VAR 0 7
129553: PUSH
129554: LD_INT 0
129556: ST_TO_ADDR
129557: GO 129575
// min_x := x - r ;
129559: LD_ADDR_VAR 0 7
129563: PUSH
129564: LD_VAR 0 2
129568: PUSH
129569: LD_VAR 0 4
129573: MINUS
129574: ST_TO_ADDR
// if y - r < 0 then
129575: LD_VAR 0 3
129579: PUSH
129580: LD_VAR 0 4
129584: MINUS
129585: PUSH
129586: LD_INT 0
129588: LESS
129589: IFFALSE 129601
// min_y := 0 else
129591: LD_ADDR_VAR 0 8
129595: PUSH
129596: LD_INT 0
129598: ST_TO_ADDR
129599: GO 129617
// min_y := y - r ;
129601: LD_ADDR_VAR 0 8
129605: PUSH
129606: LD_VAR 0 3
129610: PUSH
129611: LD_VAR 0 4
129615: MINUS
129616: ST_TO_ADDR
// max_x := x + r ;
129617: LD_ADDR_VAR 0 9
129621: PUSH
129622: LD_VAR 0 2
129626: PUSH
129627: LD_VAR 0 4
129631: PLUS
129632: ST_TO_ADDR
// max_y := y + r ;
129633: LD_ADDR_VAR 0 10
129637: PUSH
129638: LD_VAR 0 3
129642: PUSH
129643: LD_VAR 0 4
129647: PLUS
129648: ST_TO_ADDR
// for _x = min_x to max_x do
129649: LD_ADDR_VAR 0 11
129653: PUSH
129654: DOUBLE
129655: LD_VAR 0 7
129659: DEC
129660: ST_TO_ADDR
129661: LD_VAR 0 9
129665: PUSH
129666: FOR_TO
129667: IFFALSE 129784
// for _y = min_y to max_y do
129669: LD_ADDR_VAR 0 12
129673: PUSH
129674: DOUBLE
129675: LD_VAR 0 8
129679: DEC
129680: ST_TO_ADDR
129681: LD_VAR 0 10
129685: PUSH
129686: FOR_TO
129687: IFFALSE 129780
// begin if not ValidHex ( _x , _y ) then
129689: LD_VAR 0 11
129693: PPUSH
129694: LD_VAR 0 12
129698: PPUSH
129699: CALL_OW 488
129703: NOT
129704: IFFALSE 129708
// continue ;
129706: GO 129686
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129708: LD_VAR 0 11
129712: PPUSH
129713: LD_VAR 0 12
129717: PPUSH
129718: CALL_OW 351
129722: PUSH
129723: LD_VAR 0 11
129727: PPUSH
129728: LD_VAR 0 12
129732: PPUSH
129733: CALL_OW 554
129737: AND
129738: IFFALSE 129778
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129740: LD_ADDR_VAR 0 13
129744: PUSH
129745: LD_VAR 0 13
129749: PPUSH
129750: LD_VAR 0 13
129754: PUSH
129755: LD_INT 1
129757: PLUS
129758: PPUSH
129759: LD_VAR 0 11
129763: PUSH
129764: LD_VAR 0 12
129768: PUSH
129769: EMPTY
129770: LIST
129771: LIST
129772: PPUSH
129773: CALL_OW 2
129777: ST_TO_ADDR
// end ;
129778: GO 129686
129780: POP
129781: POP
129782: GO 129666
129784: POP
129785: POP
// if not list then
129786: LD_VAR 0 13
129790: NOT
129791: IFFALSE 129795
// exit ;
129793: GO 130039
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
129795: LD_ADDR_VAR 0 13
129799: PUSH
129800: LD_VAR 0 1
129804: PPUSH
129805: LD_VAR 0 13
129809: PPUSH
129810: LD_INT 1
129812: PPUSH
129813: LD_INT 1
129815: PPUSH
129816: CALL 75168 0 4
129820: ST_TO_ADDR
// ComStop ( flame ) ;
129821: LD_VAR 0 1
129825: PPUSH
129826: CALL_OW 141
// for i in list do
129830: LD_ADDR_VAR 0 6
129834: PUSH
129835: LD_VAR 0 13
129839: PUSH
129840: FOR_IN
129841: IFFALSE 129872
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129843: LD_VAR 0 1
129847: PPUSH
129848: LD_VAR 0 6
129852: PUSH
129853: LD_INT 1
129855: ARRAY
129856: PPUSH
129857: LD_VAR 0 6
129861: PUSH
129862: LD_INT 2
129864: ARRAY
129865: PPUSH
129866: CALL_OW 176
129870: GO 129840
129872: POP
129873: POP
// repeat wait ( 0 0$1 ) ;
129874: LD_INT 35
129876: PPUSH
129877: CALL_OW 67
// task := GetTaskList ( flame ) ;
129881: LD_ADDR_VAR 0 14
129885: PUSH
129886: LD_VAR 0 1
129890: PPUSH
129891: CALL_OW 437
129895: ST_TO_ADDR
// if not task then
129896: LD_VAR 0 14
129900: NOT
129901: IFFALSE 129905
// exit ;
129903: GO 130039
// if task [ 1 ] [ 1 ] <> | then
129905: LD_VAR 0 14
129909: PUSH
129910: LD_INT 1
129912: ARRAY
129913: PUSH
129914: LD_INT 1
129916: ARRAY
129917: PUSH
129918: LD_STRING |
129920: NONEQUAL
129921: IFFALSE 129925
// exit ;
129923: GO 130039
// _x := task [ 1 ] [ 2 ] ;
129925: LD_ADDR_VAR 0 11
129929: PUSH
129930: LD_VAR 0 14
129934: PUSH
129935: LD_INT 1
129937: ARRAY
129938: PUSH
129939: LD_INT 2
129941: ARRAY
129942: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129943: LD_ADDR_VAR 0 12
129947: PUSH
129948: LD_VAR 0 14
129952: PUSH
129953: LD_INT 1
129955: ARRAY
129956: PUSH
129957: LD_INT 3
129959: ARRAY
129960: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129961: LD_VAR 0 11
129965: PPUSH
129966: LD_VAR 0 12
129970: PPUSH
129971: CALL_OW 351
129975: NOT
129976: PUSH
129977: LD_VAR 0 11
129981: PPUSH
129982: LD_VAR 0 12
129986: PPUSH
129987: CALL_OW 554
129991: NOT
129992: OR
129993: IFFALSE 130027
// begin task := Delete ( task , 1 ) ;
129995: LD_ADDR_VAR 0 14
129999: PUSH
130000: LD_VAR 0 14
130004: PPUSH
130005: LD_INT 1
130007: PPUSH
130008: CALL_OW 3
130012: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
130013: LD_VAR 0 1
130017: PPUSH
130018: LD_VAR 0 14
130022: PPUSH
130023: CALL_OW 446
// end ; until not HasTask ( flame ) ;
130027: LD_VAR 0 1
130031: PPUSH
130032: CALL_OW 314
130036: NOT
130037: IFFALSE 129874
// end ;
130039: LD_VAR 0 5
130043: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
130044: LD_EXP 209
130048: NOT
130049: IFFALSE 130099
130051: GO 130053
130053: DISABLE
// begin initHack := true ;
130054: LD_ADDR_EXP 209
130058: PUSH
130059: LD_INT 1
130061: ST_TO_ADDR
// hackTanks := [ ] ;
130062: LD_ADDR_EXP 210
130066: PUSH
130067: EMPTY
130068: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
130069: LD_ADDR_EXP 211
130073: PUSH
130074: EMPTY
130075: ST_TO_ADDR
// hackLimit := 3 ;
130076: LD_ADDR_EXP 212
130080: PUSH
130081: LD_INT 3
130083: ST_TO_ADDR
// hackDist := 12 ;
130084: LD_ADDR_EXP 213
130088: PUSH
130089: LD_INT 12
130091: ST_TO_ADDR
// hackCounter := [ ] ;
130092: LD_ADDR_EXP 214
130096: PUSH
130097: EMPTY
130098: ST_TO_ADDR
// end ;
130099: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
130100: LD_EXP 209
130104: PUSH
130105: LD_INT 34
130107: PUSH
130108: LD_INT 99
130110: PUSH
130111: EMPTY
130112: LIST
130113: LIST
130114: PPUSH
130115: CALL_OW 69
130119: AND
130120: IFFALSE 130373
130122: GO 130124
130124: DISABLE
130125: LD_INT 0
130127: PPUSH
130128: PPUSH
// begin enable ;
130129: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
130130: LD_ADDR_VAR 0 1
130134: PUSH
130135: LD_INT 34
130137: PUSH
130138: LD_INT 99
130140: PUSH
130141: EMPTY
130142: LIST
130143: LIST
130144: PPUSH
130145: CALL_OW 69
130149: PUSH
130150: FOR_IN
130151: IFFALSE 130371
// begin if not i in hackTanks then
130153: LD_VAR 0 1
130157: PUSH
130158: LD_EXP 210
130162: IN
130163: NOT
130164: IFFALSE 130247
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
130166: LD_ADDR_EXP 210
130170: PUSH
130171: LD_EXP 210
130175: PPUSH
130176: LD_EXP 210
130180: PUSH
130181: LD_INT 1
130183: PLUS
130184: PPUSH
130185: LD_VAR 0 1
130189: PPUSH
130190: CALL_OW 1
130194: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
130195: LD_ADDR_EXP 211
130199: PUSH
130200: LD_EXP 211
130204: PPUSH
130205: LD_EXP 211
130209: PUSH
130210: LD_INT 1
130212: PLUS
130213: PPUSH
130214: EMPTY
130215: PPUSH
130216: CALL_OW 1
130220: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
130221: LD_ADDR_EXP 214
130225: PUSH
130226: LD_EXP 214
130230: PPUSH
130231: LD_EXP 214
130235: PUSH
130236: LD_INT 1
130238: PLUS
130239: PPUSH
130240: EMPTY
130241: PPUSH
130242: CALL_OW 1
130246: ST_TO_ADDR
// end ; if not IsOk ( i ) then
130247: LD_VAR 0 1
130251: PPUSH
130252: CALL_OW 302
130256: NOT
130257: IFFALSE 130270
// begin HackUnlinkAll ( i ) ;
130259: LD_VAR 0 1
130263: PPUSH
130264: CALL 130376 0 1
// continue ;
130268: GO 130150
// end ; HackCheckCapturedStatus ( i ) ;
130270: LD_VAR 0 1
130274: PPUSH
130275: CALL 130819 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
130279: LD_ADDR_VAR 0 2
130283: PUSH
130284: LD_INT 81
130286: PUSH
130287: LD_VAR 0 1
130291: PPUSH
130292: CALL_OW 255
130296: PUSH
130297: EMPTY
130298: LIST
130299: LIST
130300: PUSH
130301: LD_INT 33
130303: PUSH
130304: LD_INT 3
130306: PUSH
130307: EMPTY
130308: LIST
130309: LIST
130310: PUSH
130311: LD_INT 91
130313: PUSH
130314: LD_VAR 0 1
130318: PUSH
130319: LD_EXP 213
130323: PUSH
130324: EMPTY
130325: LIST
130326: LIST
130327: LIST
130328: PUSH
130329: LD_INT 50
130331: PUSH
130332: EMPTY
130333: LIST
130334: PUSH
130335: EMPTY
130336: LIST
130337: LIST
130338: LIST
130339: LIST
130340: PPUSH
130341: CALL_OW 69
130345: ST_TO_ADDR
// if not tmp then
130346: LD_VAR 0 2
130350: NOT
130351: IFFALSE 130355
// continue ;
130353: GO 130150
// HackLink ( i , tmp ) ;
130355: LD_VAR 0 1
130359: PPUSH
130360: LD_VAR 0 2
130364: PPUSH
130365: CALL 130512 0 2
// end ;
130369: GO 130150
130371: POP
130372: POP
// end ;
130373: PPOPN 2
130375: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
130376: LD_INT 0
130378: PPUSH
130379: PPUSH
130380: PPUSH
// if not hack in hackTanks then
130381: LD_VAR 0 1
130385: PUSH
130386: LD_EXP 210
130390: IN
130391: NOT
130392: IFFALSE 130396
// exit ;
130394: GO 130507
// index := GetElementIndex ( hackTanks , hack ) ;
130396: LD_ADDR_VAR 0 4
130400: PUSH
130401: LD_EXP 210
130405: PPUSH
130406: LD_VAR 0 1
130410: PPUSH
130411: CALL 74465 0 2
130415: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
130416: LD_EXP 211
130420: PUSH
130421: LD_VAR 0 4
130425: ARRAY
130426: IFFALSE 130507
// begin for i in hackTanksCaptured [ index ] do
130428: LD_ADDR_VAR 0 3
130432: PUSH
130433: LD_EXP 211
130437: PUSH
130438: LD_VAR 0 4
130442: ARRAY
130443: PUSH
130444: FOR_IN
130445: IFFALSE 130471
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
130447: LD_VAR 0 3
130451: PUSH
130452: LD_INT 1
130454: ARRAY
130455: PPUSH
130456: LD_VAR 0 3
130460: PUSH
130461: LD_INT 2
130463: ARRAY
130464: PPUSH
130465: CALL_OW 235
130469: GO 130444
130471: POP
130472: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
130473: LD_ADDR_EXP 211
130477: PUSH
130478: LD_EXP 211
130482: PPUSH
130483: LD_VAR 0 4
130487: PPUSH
130488: EMPTY
130489: PPUSH
130490: CALL_OW 1
130494: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
130495: LD_VAR 0 1
130499: PPUSH
130500: LD_INT 0
130502: PPUSH
130503: CALL_OW 505
// end ; end ;
130507: LD_VAR 0 2
130511: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
130512: LD_INT 0
130514: PPUSH
130515: PPUSH
130516: PPUSH
// if not hack in hackTanks or not vehicles then
130517: LD_VAR 0 1
130521: PUSH
130522: LD_EXP 210
130526: IN
130527: NOT
130528: PUSH
130529: LD_VAR 0 2
130533: NOT
130534: OR
130535: IFFALSE 130539
// exit ;
130537: GO 130814
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
130539: LD_ADDR_VAR 0 2
130543: PUSH
130544: LD_VAR 0 1
130548: PPUSH
130549: LD_VAR 0 2
130553: PPUSH
130554: LD_INT 1
130556: PPUSH
130557: LD_INT 1
130559: PPUSH
130560: CALL 75115 0 4
130564: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
130565: LD_ADDR_VAR 0 5
130569: PUSH
130570: LD_EXP 210
130574: PPUSH
130575: LD_VAR 0 1
130579: PPUSH
130580: CALL 74465 0 2
130584: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
130585: LD_EXP 211
130589: PUSH
130590: LD_VAR 0 5
130594: ARRAY
130595: PUSH
130596: LD_EXP 212
130600: LESS
130601: IFFALSE 130790
// begin for i := 1 to vehicles do
130603: LD_ADDR_VAR 0 4
130607: PUSH
130608: DOUBLE
130609: LD_INT 1
130611: DEC
130612: ST_TO_ADDR
130613: LD_VAR 0 2
130617: PUSH
130618: FOR_TO
130619: IFFALSE 130788
// begin if hackTanksCaptured [ index ] = hackLimit then
130621: LD_EXP 211
130625: PUSH
130626: LD_VAR 0 5
130630: ARRAY
130631: PUSH
130632: LD_EXP 212
130636: EQUAL
130637: IFFALSE 130641
// break ;
130639: GO 130788
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
130641: LD_ADDR_EXP 214
130645: PUSH
130646: LD_EXP 214
130650: PPUSH
130651: LD_VAR 0 5
130655: PPUSH
130656: LD_EXP 214
130660: PUSH
130661: LD_VAR 0 5
130665: ARRAY
130666: PUSH
130667: LD_INT 1
130669: PLUS
130670: PPUSH
130671: CALL_OW 1
130675: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
130676: LD_ADDR_EXP 211
130680: PUSH
130681: LD_EXP 211
130685: PPUSH
130686: LD_VAR 0 5
130690: PUSH
130691: LD_EXP 211
130695: PUSH
130696: LD_VAR 0 5
130700: ARRAY
130701: PUSH
130702: LD_INT 1
130704: PLUS
130705: PUSH
130706: EMPTY
130707: LIST
130708: LIST
130709: PPUSH
130710: LD_VAR 0 2
130714: PUSH
130715: LD_VAR 0 4
130719: ARRAY
130720: PUSH
130721: LD_VAR 0 2
130725: PUSH
130726: LD_VAR 0 4
130730: ARRAY
130731: PPUSH
130732: CALL_OW 255
130736: PUSH
130737: EMPTY
130738: LIST
130739: LIST
130740: PPUSH
130741: CALL 74680 0 3
130745: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
130746: LD_VAR 0 2
130750: PUSH
130751: LD_VAR 0 4
130755: ARRAY
130756: PPUSH
130757: LD_VAR 0 1
130761: PPUSH
130762: CALL_OW 255
130766: PPUSH
130767: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
130771: LD_VAR 0 2
130775: PUSH
130776: LD_VAR 0 4
130780: ARRAY
130781: PPUSH
130782: CALL_OW 141
// end ;
130786: GO 130618
130788: POP
130789: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130790: LD_VAR 0 1
130794: PPUSH
130795: LD_EXP 211
130799: PUSH
130800: LD_VAR 0 5
130804: ARRAY
130805: PUSH
130806: LD_INT 0
130808: PLUS
130809: PPUSH
130810: CALL_OW 505
// end ;
130814: LD_VAR 0 3
130818: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
130819: LD_INT 0
130821: PPUSH
130822: PPUSH
130823: PPUSH
130824: PPUSH
// if not hack in hackTanks then
130825: LD_VAR 0 1
130829: PUSH
130830: LD_EXP 210
130834: IN
130835: NOT
130836: IFFALSE 130840
// exit ;
130838: GO 131080
// index := GetElementIndex ( hackTanks , hack ) ;
130840: LD_ADDR_VAR 0 4
130844: PUSH
130845: LD_EXP 210
130849: PPUSH
130850: LD_VAR 0 1
130854: PPUSH
130855: CALL 74465 0 2
130859: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130860: LD_ADDR_VAR 0 3
130864: PUSH
130865: DOUBLE
130866: LD_EXP 211
130870: PUSH
130871: LD_VAR 0 4
130875: ARRAY
130876: INC
130877: ST_TO_ADDR
130878: LD_INT 1
130880: PUSH
130881: FOR_DOWNTO
130882: IFFALSE 131054
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130884: LD_ADDR_VAR 0 5
130888: PUSH
130889: LD_EXP 211
130893: PUSH
130894: LD_VAR 0 4
130898: ARRAY
130899: PUSH
130900: LD_VAR 0 3
130904: ARRAY
130905: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130906: LD_VAR 0 5
130910: PUSH
130911: LD_INT 1
130913: ARRAY
130914: PPUSH
130915: CALL_OW 302
130919: NOT
130920: PUSH
130921: LD_VAR 0 5
130925: PUSH
130926: LD_INT 1
130928: ARRAY
130929: PPUSH
130930: CALL_OW 255
130934: PUSH
130935: LD_VAR 0 1
130939: PPUSH
130940: CALL_OW 255
130944: NONEQUAL
130945: OR
130946: IFFALSE 131052
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130948: LD_VAR 0 5
130952: PUSH
130953: LD_INT 1
130955: ARRAY
130956: PPUSH
130957: CALL_OW 305
130961: PUSH
130962: LD_VAR 0 5
130966: PUSH
130967: LD_INT 1
130969: ARRAY
130970: PPUSH
130971: CALL_OW 255
130975: PUSH
130976: LD_VAR 0 1
130980: PPUSH
130981: CALL_OW 255
130985: EQUAL
130986: AND
130987: IFFALSE 131011
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130989: LD_VAR 0 5
130993: PUSH
130994: LD_INT 1
130996: ARRAY
130997: PPUSH
130998: LD_VAR 0 5
131002: PUSH
131003: LD_INT 2
131005: ARRAY
131006: PPUSH
131007: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
131011: LD_ADDR_EXP 211
131015: PUSH
131016: LD_EXP 211
131020: PPUSH
131021: LD_VAR 0 4
131025: PPUSH
131026: LD_EXP 211
131030: PUSH
131031: LD_VAR 0 4
131035: ARRAY
131036: PPUSH
131037: LD_VAR 0 3
131041: PPUSH
131042: CALL_OW 3
131046: PPUSH
131047: CALL_OW 1
131051: ST_TO_ADDR
// end ; end ;
131052: GO 130881
131054: POP
131055: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131056: LD_VAR 0 1
131060: PPUSH
131061: LD_EXP 211
131065: PUSH
131066: LD_VAR 0 4
131070: ARRAY
131071: PUSH
131072: LD_INT 0
131074: PLUS
131075: PPUSH
131076: CALL_OW 505
// end ;
131080: LD_VAR 0 2
131084: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
131085: LD_INT 0
131087: PPUSH
131088: PPUSH
131089: PPUSH
131090: PPUSH
// if not hack in hackTanks then
131091: LD_VAR 0 1
131095: PUSH
131096: LD_EXP 210
131100: IN
131101: NOT
131102: IFFALSE 131106
// exit ;
131104: GO 131191
// index := GetElementIndex ( hackTanks , hack ) ;
131106: LD_ADDR_VAR 0 5
131110: PUSH
131111: LD_EXP 210
131115: PPUSH
131116: LD_VAR 0 1
131120: PPUSH
131121: CALL 74465 0 2
131125: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
131126: LD_ADDR_VAR 0 4
131130: PUSH
131131: DOUBLE
131132: LD_INT 1
131134: DEC
131135: ST_TO_ADDR
131136: LD_EXP 211
131140: PUSH
131141: LD_VAR 0 5
131145: ARRAY
131146: PUSH
131147: FOR_TO
131148: IFFALSE 131189
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
131150: LD_EXP 211
131154: PUSH
131155: LD_VAR 0 5
131159: ARRAY
131160: PUSH
131161: LD_VAR 0 4
131165: ARRAY
131166: PUSH
131167: LD_INT 1
131169: ARRAY
131170: PUSH
131171: LD_VAR 0 2
131175: EQUAL
131176: IFFALSE 131187
// KillUnit ( vehicle ) ;
131178: LD_VAR 0 2
131182: PPUSH
131183: CALL_OW 66
131187: GO 131147
131189: POP
131190: POP
// end ;
131191: LD_VAR 0 3
131195: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
131196: LD_EXP 215
131200: NOT
131201: IFFALSE 131236
131203: GO 131205
131205: DISABLE
// begin initMiner := true ;
131206: LD_ADDR_EXP 215
131210: PUSH
131211: LD_INT 1
131213: ST_TO_ADDR
// minersList := [ ] ;
131214: LD_ADDR_EXP 216
131218: PUSH
131219: EMPTY
131220: ST_TO_ADDR
// minerMinesList := [ ] ;
131221: LD_ADDR_EXP 217
131225: PUSH
131226: EMPTY
131227: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
131228: LD_ADDR_EXP 218
131232: PUSH
131233: LD_INT 5
131235: ST_TO_ADDR
// end ;
131236: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
131237: LD_EXP 215
131241: PUSH
131242: LD_INT 34
131244: PUSH
131245: LD_INT 81
131247: PUSH
131248: EMPTY
131249: LIST
131250: LIST
131251: PPUSH
131252: CALL_OW 69
131256: AND
131257: IFFALSE 131718
131259: GO 131261
131261: DISABLE
131262: LD_INT 0
131264: PPUSH
131265: PPUSH
131266: PPUSH
131267: PPUSH
// begin enable ;
131268: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
131269: LD_ADDR_VAR 0 1
131273: PUSH
131274: LD_INT 34
131276: PUSH
131277: LD_INT 81
131279: PUSH
131280: EMPTY
131281: LIST
131282: LIST
131283: PPUSH
131284: CALL_OW 69
131288: PUSH
131289: FOR_IN
131290: IFFALSE 131362
// begin if not i in minersList then
131292: LD_VAR 0 1
131296: PUSH
131297: LD_EXP 216
131301: IN
131302: NOT
131303: IFFALSE 131360
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
131305: LD_ADDR_EXP 216
131309: PUSH
131310: LD_EXP 216
131314: PPUSH
131315: LD_EXP 216
131319: PUSH
131320: LD_INT 1
131322: PLUS
131323: PPUSH
131324: LD_VAR 0 1
131328: PPUSH
131329: CALL_OW 1
131333: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
131334: LD_ADDR_EXP 217
131338: PUSH
131339: LD_EXP 217
131343: PPUSH
131344: LD_EXP 217
131348: PUSH
131349: LD_INT 1
131351: PLUS
131352: PPUSH
131353: EMPTY
131354: PPUSH
131355: CALL_OW 1
131359: ST_TO_ADDR
// end end ;
131360: GO 131289
131362: POP
131363: POP
// for i := minerMinesList downto 1 do
131364: LD_ADDR_VAR 0 1
131368: PUSH
131369: DOUBLE
131370: LD_EXP 217
131374: INC
131375: ST_TO_ADDR
131376: LD_INT 1
131378: PUSH
131379: FOR_DOWNTO
131380: IFFALSE 131716
// begin if IsLive ( minersList [ i ] ) then
131382: LD_EXP 216
131386: PUSH
131387: LD_VAR 0 1
131391: ARRAY
131392: PPUSH
131393: CALL_OW 300
131397: IFFALSE 131425
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
131399: LD_EXP 216
131403: PUSH
131404: LD_VAR 0 1
131408: ARRAY
131409: PPUSH
131410: LD_EXP 217
131414: PUSH
131415: LD_VAR 0 1
131419: ARRAY
131420: PPUSH
131421: CALL_OW 505
// if not minerMinesList [ i ] then
131425: LD_EXP 217
131429: PUSH
131430: LD_VAR 0 1
131434: ARRAY
131435: NOT
131436: IFFALSE 131440
// continue ;
131438: GO 131379
// for j := minerMinesList [ i ] downto 1 do
131440: LD_ADDR_VAR 0 2
131444: PUSH
131445: DOUBLE
131446: LD_EXP 217
131450: PUSH
131451: LD_VAR 0 1
131455: ARRAY
131456: INC
131457: ST_TO_ADDR
131458: LD_INT 1
131460: PUSH
131461: FOR_DOWNTO
131462: IFFALSE 131712
// begin side := GetSide ( minersList [ i ] ) ;
131464: LD_ADDR_VAR 0 3
131468: PUSH
131469: LD_EXP 216
131473: PUSH
131474: LD_VAR 0 1
131478: ARRAY
131479: PPUSH
131480: CALL_OW 255
131484: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
131485: LD_ADDR_VAR 0 4
131489: PUSH
131490: LD_EXP 217
131494: PUSH
131495: LD_VAR 0 1
131499: ARRAY
131500: PUSH
131501: LD_VAR 0 2
131505: ARRAY
131506: PUSH
131507: LD_INT 1
131509: ARRAY
131510: PPUSH
131511: LD_EXP 217
131515: PUSH
131516: LD_VAR 0 1
131520: ARRAY
131521: PUSH
131522: LD_VAR 0 2
131526: ARRAY
131527: PUSH
131528: LD_INT 2
131530: ARRAY
131531: PPUSH
131532: CALL_OW 428
131536: ST_TO_ADDR
// if not tmp then
131537: LD_VAR 0 4
131541: NOT
131542: IFFALSE 131546
// continue ;
131544: GO 131461
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
131546: LD_VAR 0 4
131550: PUSH
131551: LD_INT 81
131553: PUSH
131554: LD_VAR 0 3
131558: PUSH
131559: EMPTY
131560: LIST
131561: LIST
131562: PPUSH
131563: CALL_OW 69
131567: IN
131568: PUSH
131569: LD_EXP 217
131573: PUSH
131574: LD_VAR 0 1
131578: ARRAY
131579: PUSH
131580: LD_VAR 0 2
131584: ARRAY
131585: PUSH
131586: LD_INT 1
131588: ARRAY
131589: PPUSH
131590: LD_EXP 217
131594: PUSH
131595: LD_VAR 0 1
131599: ARRAY
131600: PUSH
131601: LD_VAR 0 2
131605: ARRAY
131606: PUSH
131607: LD_INT 2
131609: ARRAY
131610: PPUSH
131611: CALL_OW 458
131615: AND
131616: IFFALSE 131710
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
131618: LD_EXP 217
131622: PUSH
131623: LD_VAR 0 1
131627: ARRAY
131628: PUSH
131629: LD_VAR 0 2
131633: ARRAY
131634: PUSH
131635: LD_INT 1
131637: ARRAY
131638: PPUSH
131639: LD_EXP 217
131643: PUSH
131644: LD_VAR 0 1
131648: ARRAY
131649: PUSH
131650: LD_VAR 0 2
131654: ARRAY
131655: PUSH
131656: LD_INT 2
131658: ARRAY
131659: PPUSH
131660: LD_VAR 0 3
131664: PPUSH
131665: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
131669: LD_ADDR_EXP 217
131673: PUSH
131674: LD_EXP 217
131678: PPUSH
131679: LD_VAR 0 1
131683: PPUSH
131684: LD_EXP 217
131688: PUSH
131689: LD_VAR 0 1
131693: ARRAY
131694: PPUSH
131695: LD_VAR 0 2
131699: PPUSH
131700: CALL_OW 3
131704: PPUSH
131705: CALL_OW 1
131709: ST_TO_ADDR
// end ; end ;
131710: GO 131461
131712: POP
131713: POP
// end ;
131714: GO 131379
131716: POP
131717: POP
// end ;
131718: PPOPN 4
131720: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
131721: LD_INT 0
131723: PPUSH
131724: PPUSH
// result := false ;
131725: LD_ADDR_VAR 0 4
131729: PUSH
131730: LD_INT 0
131732: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
131733: LD_VAR 0 1
131737: PPUSH
131738: CALL_OW 264
131742: PUSH
131743: LD_INT 81
131745: EQUAL
131746: NOT
131747: IFFALSE 131751
// exit ;
131749: GO 131991
// index := GetElementIndex ( minersList , unit ) ;
131751: LD_ADDR_VAR 0 5
131755: PUSH
131756: LD_EXP 216
131760: PPUSH
131761: LD_VAR 0 1
131765: PPUSH
131766: CALL 74465 0 2
131770: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
131771: LD_EXP 217
131775: PUSH
131776: LD_VAR 0 5
131780: ARRAY
131781: PUSH
131782: LD_EXP 218
131786: GREATEREQUAL
131787: IFFALSE 131791
// exit ;
131789: GO 131991
// ComMoveXY ( unit , x , y ) ;
131791: LD_VAR 0 1
131795: PPUSH
131796: LD_VAR 0 2
131800: PPUSH
131801: LD_VAR 0 3
131805: PPUSH
131806: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131810: LD_INT 35
131812: PPUSH
131813: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
131817: LD_VAR 0 1
131821: PPUSH
131822: LD_VAR 0 2
131826: PPUSH
131827: LD_VAR 0 3
131831: PPUSH
131832: CALL 106206 0 3
131836: NOT
131837: PUSH
131838: LD_VAR 0 1
131842: PPUSH
131843: CALL_OW 314
131847: AND
131848: IFFALSE 131852
// exit ;
131850: GO 131991
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131852: LD_VAR 0 2
131856: PPUSH
131857: LD_VAR 0 3
131861: PPUSH
131862: CALL_OW 428
131866: PUSH
131867: LD_VAR 0 1
131871: EQUAL
131872: PUSH
131873: LD_VAR 0 1
131877: PPUSH
131878: CALL_OW 314
131882: NOT
131883: AND
131884: IFFALSE 131810
// PlaySoundXY ( x , y , PlantMine ) ;
131886: LD_VAR 0 2
131890: PPUSH
131891: LD_VAR 0 3
131895: PPUSH
131896: LD_STRING PlantMine
131898: PPUSH
131899: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131903: LD_VAR 0 2
131907: PPUSH
131908: LD_VAR 0 3
131912: PPUSH
131913: LD_VAR 0 1
131917: PPUSH
131918: CALL_OW 255
131922: PPUSH
131923: LD_INT 0
131925: PPUSH
131926: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131930: LD_ADDR_EXP 217
131934: PUSH
131935: LD_EXP 217
131939: PPUSH
131940: LD_VAR 0 5
131944: PUSH
131945: LD_EXP 217
131949: PUSH
131950: LD_VAR 0 5
131954: ARRAY
131955: PUSH
131956: LD_INT 1
131958: PLUS
131959: PUSH
131960: EMPTY
131961: LIST
131962: LIST
131963: PPUSH
131964: LD_VAR 0 2
131968: PUSH
131969: LD_VAR 0 3
131973: PUSH
131974: EMPTY
131975: LIST
131976: LIST
131977: PPUSH
131978: CALL 74680 0 3
131982: ST_TO_ADDR
// result := true ;
131983: LD_ADDR_VAR 0 4
131987: PUSH
131988: LD_INT 1
131990: ST_TO_ADDR
// end ;
131991: LD_VAR 0 4
131995: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131996: LD_INT 0
131998: PPUSH
131999: PPUSH
132000: PPUSH
// if not unit in minersList then
132001: LD_VAR 0 1
132005: PUSH
132006: LD_EXP 216
132010: IN
132011: NOT
132012: IFFALSE 132016
// exit ;
132014: GO 132408
// index := GetElementIndex ( minersList , unit ) ;
132016: LD_ADDR_VAR 0 6
132020: PUSH
132021: LD_EXP 216
132025: PPUSH
132026: LD_VAR 0 1
132030: PPUSH
132031: CALL 74465 0 2
132035: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
132036: LD_ADDR_VAR 0 5
132040: PUSH
132041: DOUBLE
132042: LD_EXP 217
132046: PUSH
132047: LD_VAR 0 6
132051: ARRAY
132052: INC
132053: ST_TO_ADDR
132054: LD_INT 1
132056: PUSH
132057: FOR_DOWNTO
132058: IFFALSE 132219
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
132060: LD_EXP 217
132064: PUSH
132065: LD_VAR 0 6
132069: ARRAY
132070: PUSH
132071: LD_VAR 0 5
132075: ARRAY
132076: PUSH
132077: LD_INT 1
132079: ARRAY
132080: PUSH
132081: LD_VAR 0 2
132085: EQUAL
132086: PUSH
132087: LD_EXP 217
132091: PUSH
132092: LD_VAR 0 6
132096: ARRAY
132097: PUSH
132098: LD_VAR 0 5
132102: ARRAY
132103: PUSH
132104: LD_INT 2
132106: ARRAY
132107: PUSH
132108: LD_VAR 0 3
132112: EQUAL
132113: AND
132114: IFFALSE 132217
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132116: LD_EXP 217
132120: PUSH
132121: LD_VAR 0 6
132125: ARRAY
132126: PUSH
132127: LD_VAR 0 5
132131: ARRAY
132132: PUSH
132133: LD_INT 1
132135: ARRAY
132136: PPUSH
132137: LD_EXP 217
132141: PUSH
132142: LD_VAR 0 6
132146: ARRAY
132147: PUSH
132148: LD_VAR 0 5
132152: ARRAY
132153: PUSH
132154: LD_INT 2
132156: ARRAY
132157: PPUSH
132158: LD_VAR 0 1
132162: PPUSH
132163: CALL_OW 255
132167: PPUSH
132168: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132172: LD_ADDR_EXP 217
132176: PUSH
132177: LD_EXP 217
132181: PPUSH
132182: LD_VAR 0 6
132186: PPUSH
132187: LD_EXP 217
132191: PUSH
132192: LD_VAR 0 6
132196: ARRAY
132197: PPUSH
132198: LD_VAR 0 5
132202: PPUSH
132203: CALL_OW 3
132207: PPUSH
132208: CALL_OW 1
132212: ST_TO_ADDR
// exit ;
132213: POP
132214: POP
132215: GO 132408
// end ; end ;
132217: GO 132057
132219: POP
132220: POP
// for i := minerMinesList [ index ] downto 1 do
132221: LD_ADDR_VAR 0 5
132225: PUSH
132226: DOUBLE
132227: LD_EXP 217
132231: PUSH
132232: LD_VAR 0 6
132236: ARRAY
132237: INC
132238: ST_TO_ADDR
132239: LD_INT 1
132241: PUSH
132242: FOR_DOWNTO
132243: IFFALSE 132406
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
132245: LD_EXP 217
132249: PUSH
132250: LD_VAR 0 6
132254: ARRAY
132255: PUSH
132256: LD_VAR 0 5
132260: ARRAY
132261: PUSH
132262: LD_INT 1
132264: ARRAY
132265: PPUSH
132266: LD_EXP 217
132270: PUSH
132271: LD_VAR 0 6
132275: ARRAY
132276: PUSH
132277: LD_VAR 0 5
132281: ARRAY
132282: PUSH
132283: LD_INT 2
132285: ARRAY
132286: PPUSH
132287: LD_VAR 0 2
132291: PPUSH
132292: LD_VAR 0 3
132296: PPUSH
132297: CALL_OW 298
132301: PUSH
132302: LD_INT 6
132304: LESS
132305: IFFALSE 132404
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132307: LD_EXP 217
132311: PUSH
132312: LD_VAR 0 6
132316: ARRAY
132317: PUSH
132318: LD_VAR 0 5
132322: ARRAY
132323: PUSH
132324: LD_INT 1
132326: ARRAY
132327: PPUSH
132328: LD_EXP 217
132332: PUSH
132333: LD_VAR 0 6
132337: ARRAY
132338: PUSH
132339: LD_VAR 0 5
132343: ARRAY
132344: PUSH
132345: LD_INT 2
132347: ARRAY
132348: PPUSH
132349: LD_VAR 0 1
132353: PPUSH
132354: CALL_OW 255
132358: PPUSH
132359: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132363: LD_ADDR_EXP 217
132367: PUSH
132368: LD_EXP 217
132372: PPUSH
132373: LD_VAR 0 6
132377: PPUSH
132378: LD_EXP 217
132382: PUSH
132383: LD_VAR 0 6
132387: ARRAY
132388: PPUSH
132389: LD_VAR 0 5
132393: PPUSH
132394: CALL_OW 3
132398: PPUSH
132399: CALL_OW 1
132403: ST_TO_ADDR
// end ; end ;
132404: GO 132242
132406: POP
132407: POP
// end ;
132408: LD_VAR 0 4
132412: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
132413: LD_INT 0
132415: PPUSH
132416: PPUSH
132417: PPUSH
132418: PPUSH
132419: PPUSH
132420: PPUSH
132421: PPUSH
132422: PPUSH
132423: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
132424: LD_VAR 0 1
132428: PPUSH
132429: CALL_OW 264
132433: PUSH
132434: LD_INT 81
132436: EQUAL
132437: NOT
132438: PUSH
132439: LD_VAR 0 1
132443: PUSH
132444: LD_EXP 216
132448: IN
132449: NOT
132450: OR
132451: IFFALSE 132455
// exit ;
132453: GO 132777
// index := GetElementIndex ( minersList , unit ) ;
132455: LD_ADDR_VAR 0 6
132459: PUSH
132460: LD_EXP 216
132464: PPUSH
132465: LD_VAR 0 1
132469: PPUSH
132470: CALL 74465 0 2
132474: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
132475: LD_ADDR_VAR 0 8
132479: PUSH
132480: LD_EXP 218
132484: PUSH
132485: LD_EXP 217
132489: PUSH
132490: LD_VAR 0 6
132494: ARRAY
132495: MINUS
132496: ST_TO_ADDR
// if not minesFreeAmount then
132497: LD_VAR 0 8
132501: NOT
132502: IFFALSE 132506
// exit ;
132504: GO 132777
// tmp := [ ] ;
132506: LD_ADDR_VAR 0 7
132510: PUSH
132511: EMPTY
132512: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
132513: LD_ADDR_VAR 0 5
132517: PUSH
132518: DOUBLE
132519: LD_INT 1
132521: DEC
132522: ST_TO_ADDR
132523: LD_VAR 0 8
132527: PUSH
132528: FOR_TO
132529: IFFALSE 132724
// begin _d := rand ( 0 , 5 ) ;
132531: LD_ADDR_VAR 0 11
132535: PUSH
132536: LD_INT 0
132538: PPUSH
132539: LD_INT 5
132541: PPUSH
132542: CALL_OW 12
132546: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
132547: LD_ADDR_VAR 0 12
132551: PUSH
132552: LD_INT 2
132554: PPUSH
132555: LD_INT 6
132557: PPUSH
132558: CALL_OW 12
132562: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
132563: LD_ADDR_VAR 0 9
132567: PUSH
132568: LD_VAR 0 2
132572: PPUSH
132573: LD_VAR 0 11
132577: PPUSH
132578: LD_VAR 0 12
132582: PPUSH
132583: CALL_OW 272
132587: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
132588: LD_ADDR_VAR 0 10
132592: PUSH
132593: LD_VAR 0 3
132597: PPUSH
132598: LD_VAR 0 11
132602: PPUSH
132603: LD_VAR 0 12
132607: PPUSH
132608: CALL_OW 273
132612: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
132613: LD_VAR 0 9
132617: PPUSH
132618: LD_VAR 0 10
132622: PPUSH
132623: CALL_OW 488
132627: PUSH
132628: LD_VAR 0 9
132632: PUSH
132633: LD_VAR 0 10
132637: PUSH
132638: EMPTY
132639: LIST
132640: LIST
132641: PUSH
132642: LD_VAR 0 7
132646: IN
132647: NOT
132648: AND
132649: PUSH
132650: LD_VAR 0 9
132654: PPUSH
132655: LD_VAR 0 10
132659: PPUSH
132660: CALL_OW 458
132664: NOT
132665: AND
132666: IFFALSE 132708
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
132668: LD_ADDR_VAR 0 7
132672: PUSH
132673: LD_VAR 0 7
132677: PPUSH
132678: LD_VAR 0 7
132682: PUSH
132683: LD_INT 1
132685: PLUS
132686: PPUSH
132687: LD_VAR 0 9
132691: PUSH
132692: LD_VAR 0 10
132696: PUSH
132697: EMPTY
132698: LIST
132699: LIST
132700: PPUSH
132701: CALL_OW 1
132705: ST_TO_ADDR
132706: GO 132722
// i := i - 1 ;
132708: LD_ADDR_VAR 0 5
132712: PUSH
132713: LD_VAR 0 5
132717: PUSH
132718: LD_INT 1
132720: MINUS
132721: ST_TO_ADDR
// end ;
132722: GO 132528
132724: POP
132725: POP
// for i in tmp do
132726: LD_ADDR_VAR 0 5
132730: PUSH
132731: LD_VAR 0 7
132735: PUSH
132736: FOR_IN
132737: IFFALSE 132775
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
132739: LD_VAR 0 1
132743: PPUSH
132744: LD_VAR 0 5
132748: PUSH
132749: LD_INT 1
132751: ARRAY
132752: PPUSH
132753: LD_VAR 0 5
132757: PUSH
132758: LD_INT 2
132760: ARRAY
132761: PPUSH
132762: CALL 131721 0 3
132766: NOT
132767: IFFALSE 132773
// exit ;
132769: POP
132770: POP
132771: GO 132777
132773: GO 132736
132775: POP
132776: POP
// end ;
132777: LD_VAR 0 4
132781: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
132782: LD_INT 0
132784: PPUSH
132785: PPUSH
132786: PPUSH
132787: PPUSH
132788: PPUSH
132789: PPUSH
132790: PPUSH
// if not GetClass ( unit ) = class_sniper then
132791: LD_VAR 0 1
132795: PPUSH
132796: CALL_OW 257
132800: PUSH
132801: LD_INT 5
132803: EQUAL
132804: NOT
132805: IFFALSE 132809
// exit ;
132807: GO 133197
// dist := 8 ;
132809: LD_ADDR_VAR 0 5
132813: PUSH
132814: LD_INT 8
132816: ST_TO_ADDR
// viewRange := 12 ;
132817: LD_ADDR_VAR 0 7
132821: PUSH
132822: LD_INT 12
132824: ST_TO_ADDR
// side := GetSide ( unit ) ;
132825: LD_ADDR_VAR 0 6
132829: PUSH
132830: LD_VAR 0 1
132834: PPUSH
132835: CALL_OW 255
132839: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132840: LD_INT 61
132842: PPUSH
132843: LD_VAR 0 6
132847: PPUSH
132848: CALL_OW 321
132852: PUSH
132853: LD_INT 2
132855: EQUAL
132856: IFFALSE 132866
// viewRange := 16 ;
132858: LD_ADDR_VAR 0 7
132862: PUSH
132863: LD_INT 16
132865: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132866: LD_VAR 0 1
132870: PPUSH
132871: LD_VAR 0 2
132875: PPUSH
132876: LD_VAR 0 3
132880: PPUSH
132881: CALL_OW 297
132885: PUSH
132886: LD_VAR 0 5
132890: GREATER
132891: IFFALSE 132970
// begin ComMoveXY ( unit , x , y ) ;
132893: LD_VAR 0 1
132897: PPUSH
132898: LD_VAR 0 2
132902: PPUSH
132903: LD_VAR 0 3
132907: PPUSH
132908: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132912: LD_INT 35
132914: PPUSH
132915: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132919: LD_VAR 0 1
132923: PPUSH
132924: LD_VAR 0 2
132928: PPUSH
132929: LD_VAR 0 3
132933: PPUSH
132934: CALL 106206 0 3
132938: NOT
132939: IFFALSE 132943
// exit ;
132941: GO 133197
// until GetDistUnitXY ( unit , x , y ) < dist ;
132943: LD_VAR 0 1
132947: PPUSH
132948: LD_VAR 0 2
132952: PPUSH
132953: LD_VAR 0 3
132957: PPUSH
132958: CALL_OW 297
132962: PUSH
132963: LD_VAR 0 5
132967: LESS
132968: IFFALSE 132912
// end ; ComTurnXY ( unit , x , y ) ;
132970: LD_VAR 0 1
132974: PPUSH
132975: LD_VAR 0 2
132979: PPUSH
132980: LD_VAR 0 3
132984: PPUSH
132985: CALL_OW 118
// wait ( 5 ) ;
132989: LD_INT 5
132991: PPUSH
132992: CALL_OW 67
// _d := GetDir ( unit ) ;
132996: LD_ADDR_VAR 0 10
133000: PUSH
133001: LD_VAR 0 1
133005: PPUSH
133006: CALL_OW 254
133010: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
133011: LD_ADDR_VAR 0 8
133015: PUSH
133016: LD_VAR 0 1
133020: PPUSH
133021: CALL_OW 250
133025: PPUSH
133026: LD_VAR 0 10
133030: PPUSH
133031: LD_VAR 0 5
133035: PPUSH
133036: CALL_OW 272
133040: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
133041: LD_ADDR_VAR 0 9
133045: PUSH
133046: LD_VAR 0 1
133050: PPUSH
133051: CALL_OW 251
133055: PPUSH
133056: LD_VAR 0 10
133060: PPUSH
133061: LD_VAR 0 5
133065: PPUSH
133066: CALL_OW 273
133070: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
133071: LD_VAR 0 8
133075: PPUSH
133076: LD_VAR 0 9
133080: PPUSH
133081: CALL_OW 488
133085: NOT
133086: IFFALSE 133090
// exit ;
133088: GO 133197
// ComAnimCustom ( unit , 1 ) ;
133090: LD_VAR 0 1
133094: PPUSH
133095: LD_INT 1
133097: PPUSH
133098: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
133102: LD_VAR 0 8
133106: PPUSH
133107: LD_VAR 0 9
133111: PPUSH
133112: LD_VAR 0 6
133116: PPUSH
133117: LD_VAR 0 7
133121: PPUSH
133122: CALL_OW 330
// repeat wait ( 1 ) ;
133126: LD_INT 1
133128: PPUSH
133129: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
133133: LD_VAR 0 1
133137: PPUSH
133138: CALL_OW 316
133142: PUSH
133143: LD_VAR 0 1
133147: PPUSH
133148: CALL_OW 314
133152: OR
133153: PUSH
133154: LD_VAR 0 1
133158: PPUSH
133159: CALL_OW 302
133163: NOT
133164: OR
133165: PUSH
133166: LD_VAR 0 1
133170: PPUSH
133171: CALL_OW 301
133175: OR
133176: IFFALSE 133126
// RemoveSeeing ( _x , _y , side ) ;
133178: LD_VAR 0 8
133182: PPUSH
133183: LD_VAR 0 9
133187: PPUSH
133188: LD_VAR 0 6
133192: PPUSH
133193: CALL_OW 331
// end ; end_of_file
133197: LD_VAR 0 4
133201: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
133202: LD_INT 0
133204: PPUSH
133205: PPUSH
133206: PPUSH
133207: PPUSH
133208: PPUSH
133209: PPUSH
133210: PPUSH
133211: PPUSH
133212: PPUSH
133213: PPUSH
133214: PPUSH
133215: PPUSH
133216: PPUSH
133217: PPUSH
133218: PPUSH
133219: PPUSH
133220: PPUSH
133221: PPUSH
133222: PPUSH
133223: PPUSH
133224: PPUSH
133225: PPUSH
133226: PPUSH
133227: PPUSH
133228: PPUSH
133229: PPUSH
133230: PPUSH
133231: PPUSH
133232: PPUSH
133233: PPUSH
133234: PPUSH
133235: PPUSH
133236: PPUSH
133237: PPUSH
// if not list then
133238: LD_VAR 0 1
133242: NOT
133243: IFFALSE 133247
// exit ;
133245: GO 137906
// base := list [ 1 ] ;
133247: LD_ADDR_VAR 0 3
133251: PUSH
133252: LD_VAR 0 1
133256: PUSH
133257: LD_INT 1
133259: ARRAY
133260: ST_TO_ADDR
// group := list [ 2 ] ;
133261: LD_ADDR_VAR 0 4
133265: PUSH
133266: LD_VAR 0 1
133270: PUSH
133271: LD_INT 2
133273: ARRAY
133274: ST_TO_ADDR
// path := list [ 3 ] ;
133275: LD_ADDR_VAR 0 5
133279: PUSH
133280: LD_VAR 0 1
133284: PUSH
133285: LD_INT 3
133287: ARRAY
133288: ST_TO_ADDR
// flags := list [ 4 ] ;
133289: LD_ADDR_VAR 0 6
133293: PUSH
133294: LD_VAR 0 1
133298: PUSH
133299: LD_INT 4
133301: ARRAY
133302: ST_TO_ADDR
// mined := [ ] ;
133303: LD_ADDR_VAR 0 27
133307: PUSH
133308: EMPTY
133309: ST_TO_ADDR
// bombed := [ ] ;
133310: LD_ADDR_VAR 0 28
133314: PUSH
133315: EMPTY
133316: ST_TO_ADDR
// healers := [ ] ;
133317: LD_ADDR_VAR 0 31
133321: PUSH
133322: EMPTY
133323: ST_TO_ADDR
// to_heal := [ ] ;
133324: LD_ADDR_VAR 0 30
133328: PUSH
133329: EMPTY
133330: ST_TO_ADDR
// repairs := [ ] ;
133331: LD_ADDR_VAR 0 33
133335: PUSH
133336: EMPTY
133337: ST_TO_ADDR
// to_repair := [ ] ;
133338: LD_ADDR_VAR 0 32
133342: PUSH
133343: EMPTY
133344: ST_TO_ADDR
// if not group or not path then
133345: LD_VAR 0 4
133349: NOT
133350: PUSH
133351: LD_VAR 0 5
133355: NOT
133356: OR
133357: IFFALSE 133361
// exit ;
133359: GO 137906
// side := GetSide ( group [ 1 ] ) ;
133361: LD_ADDR_VAR 0 35
133365: PUSH
133366: LD_VAR 0 4
133370: PUSH
133371: LD_INT 1
133373: ARRAY
133374: PPUSH
133375: CALL_OW 255
133379: ST_TO_ADDR
// if flags then
133380: LD_VAR 0 6
133384: IFFALSE 133528
// begin f_ignore_area := flags [ 1 ] ;
133386: LD_ADDR_VAR 0 17
133390: PUSH
133391: LD_VAR 0 6
133395: PUSH
133396: LD_INT 1
133398: ARRAY
133399: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
133400: LD_ADDR_VAR 0 18
133404: PUSH
133405: LD_VAR 0 6
133409: PUSH
133410: LD_INT 2
133412: ARRAY
133413: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
133414: LD_ADDR_VAR 0 19
133418: PUSH
133419: LD_VAR 0 6
133423: PUSH
133424: LD_INT 3
133426: ARRAY
133427: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
133428: LD_ADDR_VAR 0 20
133432: PUSH
133433: LD_VAR 0 6
133437: PUSH
133438: LD_INT 4
133440: ARRAY
133441: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
133442: LD_ADDR_VAR 0 21
133446: PUSH
133447: LD_VAR 0 6
133451: PUSH
133452: LD_INT 5
133454: ARRAY
133455: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
133456: LD_ADDR_VAR 0 22
133460: PUSH
133461: LD_VAR 0 6
133465: PUSH
133466: LD_INT 6
133468: ARRAY
133469: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
133470: LD_ADDR_VAR 0 23
133474: PUSH
133475: LD_VAR 0 6
133479: PUSH
133480: LD_INT 7
133482: ARRAY
133483: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
133484: LD_ADDR_VAR 0 24
133488: PUSH
133489: LD_VAR 0 6
133493: PUSH
133494: LD_INT 8
133496: ARRAY
133497: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
133498: LD_ADDR_VAR 0 25
133502: PUSH
133503: LD_VAR 0 6
133507: PUSH
133508: LD_INT 9
133510: ARRAY
133511: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
133512: LD_ADDR_VAR 0 26
133516: PUSH
133517: LD_VAR 0 6
133521: PUSH
133522: LD_INT 10
133524: ARRAY
133525: ST_TO_ADDR
// end else
133526: GO 133608
// begin f_ignore_area := false ;
133528: LD_ADDR_VAR 0 17
133532: PUSH
133533: LD_INT 0
133535: ST_TO_ADDR
// f_capture := false ;
133536: LD_ADDR_VAR 0 18
133540: PUSH
133541: LD_INT 0
133543: ST_TO_ADDR
// f_ignore_civ := false ;
133544: LD_ADDR_VAR 0 19
133548: PUSH
133549: LD_INT 0
133551: ST_TO_ADDR
// f_murder := false ;
133552: LD_ADDR_VAR 0 20
133556: PUSH
133557: LD_INT 0
133559: ST_TO_ADDR
// f_mines := false ;
133560: LD_ADDR_VAR 0 21
133564: PUSH
133565: LD_INT 0
133567: ST_TO_ADDR
// f_repair := false ;
133568: LD_ADDR_VAR 0 22
133572: PUSH
133573: LD_INT 0
133575: ST_TO_ADDR
// f_heal := false ;
133576: LD_ADDR_VAR 0 23
133580: PUSH
133581: LD_INT 0
133583: ST_TO_ADDR
// f_spacetime := false ;
133584: LD_ADDR_VAR 0 24
133588: PUSH
133589: LD_INT 0
133591: ST_TO_ADDR
// f_attack_depot := false ;
133592: LD_ADDR_VAR 0 25
133596: PUSH
133597: LD_INT 0
133599: ST_TO_ADDR
// f_crawl := false ;
133600: LD_ADDR_VAR 0 26
133604: PUSH
133605: LD_INT 0
133607: ST_TO_ADDR
// end ; if f_heal then
133608: LD_VAR 0 23
133612: IFFALSE 133639
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
133614: LD_ADDR_VAR 0 31
133618: PUSH
133619: LD_VAR 0 4
133623: PPUSH
133624: LD_INT 25
133626: PUSH
133627: LD_INT 4
133629: PUSH
133630: EMPTY
133631: LIST
133632: LIST
133633: PPUSH
133634: CALL_OW 72
133638: ST_TO_ADDR
// if f_repair then
133639: LD_VAR 0 22
133643: IFFALSE 133670
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
133645: LD_ADDR_VAR 0 33
133649: PUSH
133650: LD_VAR 0 4
133654: PPUSH
133655: LD_INT 25
133657: PUSH
133658: LD_INT 3
133660: PUSH
133661: EMPTY
133662: LIST
133663: LIST
133664: PPUSH
133665: CALL_OW 72
133669: ST_TO_ADDR
// units_path := [ ] ;
133670: LD_ADDR_VAR 0 16
133674: PUSH
133675: EMPTY
133676: ST_TO_ADDR
// for i = 1 to group do
133677: LD_ADDR_VAR 0 7
133681: PUSH
133682: DOUBLE
133683: LD_INT 1
133685: DEC
133686: ST_TO_ADDR
133687: LD_VAR 0 4
133691: PUSH
133692: FOR_TO
133693: IFFALSE 133722
// units_path := Replace ( units_path , i , path ) ;
133695: LD_ADDR_VAR 0 16
133699: PUSH
133700: LD_VAR 0 16
133704: PPUSH
133705: LD_VAR 0 7
133709: PPUSH
133710: LD_VAR 0 5
133714: PPUSH
133715: CALL_OW 1
133719: ST_TO_ADDR
133720: GO 133692
133722: POP
133723: POP
// repeat for i = group downto 1 do
133724: LD_ADDR_VAR 0 7
133728: PUSH
133729: DOUBLE
133730: LD_VAR 0 4
133734: INC
133735: ST_TO_ADDR
133736: LD_INT 1
133738: PUSH
133739: FOR_DOWNTO
133740: IFFALSE 137862
// begin wait ( 5 ) ;
133742: LD_INT 5
133744: PPUSH
133745: CALL_OW 67
// tmp := [ ] ;
133749: LD_ADDR_VAR 0 14
133753: PUSH
133754: EMPTY
133755: ST_TO_ADDR
// attacking := false ;
133756: LD_ADDR_VAR 0 29
133760: PUSH
133761: LD_INT 0
133763: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
133764: LD_VAR 0 4
133768: PUSH
133769: LD_VAR 0 7
133773: ARRAY
133774: PPUSH
133775: CALL_OW 301
133779: PUSH
133780: LD_VAR 0 4
133784: PUSH
133785: LD_VAR 0 7
133789: ARRAY
133790: NOT
133791: OR
133792: IFFALSE 133901
// begin if GetType ( group [ i ] ) = unit_human then
133794: LD_VAR 0 4
133798: PUSH
133799: LD_VAR 0 7
133803: ARRAY
133804: PPUSH
133805: CALL_OW 247
133809: PUSH
133810: LD_INT 1
133812: EQUAL
133813: IFFALSE 133859
// begin to_heal := to_heal diff group [ i ] ;
133815: LD_ADDR_VAR 0 30
133819: PUSH
133820: LD_VAR 0 30
133824: PUSH
133825: LD_VAR 0 4
133829: PUSH
133830: LD_VAR 0 7
133834: ARRAY
133835: DIFF
133836: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133837: LD_ADDR_VAR 0 31
133841: PUSH
133842: LD_VAR 0 31
133846: PUSH
133847: LD_VAR 0 4
133851: PUSH
133852: LD_VAR 0 7
133856: ARRAY
133857: DIFF
133858: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133859: LD_ADDR_VAR 0 4
133863: PUSH
133864: LD_VAR 0 4
133868: PPUSH
133869: LD_VAR 0 7
133873: PPUSH
133874: CALL_OW 3
133878: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133879: LD_ADDR_VAR 0 16
133883: PUSH
133884: LD_VAR 0 16
133888: PPUSH
133889: LD_VAR 0 7
133893: PPUSH
133894: CALL_OW 3
133898: ST_TO_ADDR
// continue ;
133899: GO 133739
// end ; if f_repair then
133901: LD_VAR 0 22
133905: IFFALSE 134394
// begin if GetType ( group [ i ] ) = unit_vehicle then
133907: LD_VAR 0 4
133911: PUSH
133912: LD_VAR 0 7
133916: ARRAY
133917: PPUSH
133918: CALL_OW 247
133922: PUSH
133923: LD_INT 2
133925: EQUAL
133926: IFFALSE 134116
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133928: LD_VAR 0 4
133932: PUSH
133933: LD_VAR 0 7
133937: ARRAY
133938: PPUSH
133939: CALL_OW 256
133943: PUSH
133944: LD_INT 700
133946: LESS
133947: PUSH
133948: LD_VAR 0 4
133952: PUSH
133953: LD_VAR 0 7
133957: ARRAY
133958: PUSH
133959: LD_VAR 0 32
133963: IN
133964: NOT
133965: AND
133966: IFFALSE 133990
// to_repair := to_repair union group [ i ] ;
133968: LD_ADDR_VAR 0 32
133972: PUSH
133973: LD_VAR 0 32
133977: PUSH
133978: LD_VAR 0 4
133982: PUSH
133983: LD_VAR 0 7
133987: ARRAY
133988: UNION
133989: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133990: LD_VAR 0 4
133994: PUSH
133995: LD_VAR 0 7
133999: ARRAY
134000: PPUSH
134001: CALL_OW 256
134005: PUSH
134006: LD_INT 1000
134008: EQUAL
134009: PUSH
134010: LD_VAR 0 4
134014: PUSH
134015: LD_VAR 0 7
134019: ARRAY
134020: PUSH
134021: LD_VAR 0 32
134025: IN
134026: AND
134027: IFFALSE 134051
// to_repair := to_repair diff group [ i ] ;
134029: LD_ADDR_VAR 0 32
134033: PUSH
134034: LD_VAR 0 32
134038: PUSH
134039: LD_VAR 0 4
134043: PUSH
134044: LD_VAR 0 7
134048: ARRAY
134049: DIFF
134050: ST_TO_ADDR
// if group [ i ] in to_repair then
134051: LD_VAR 0 4
134055: PUSH
134056: LD_VAR 0 7
134060: ARRAY
134061: PUSH
134062: LD_VAR 0 32
134066: IN
134067: IFFALSE 134114
// begin if not IsInArea ( group [ i ] , f_repair ) then
134069: LD_VAR 0 4
134073: PUSH
134074: LD_VAR 0 7
134078: ARRAY
134079: PPUSH
134080: LD_VAR 0 22
134084: PPUSH
134085: CALL_OW 308
134089: NOT
134090: IFFALSE 134112
// ComMoveToArea ( group [ i ] , f_repair ) ;
134092: LD_VAR 0 4
134096: PUSH
134097: LD_VAR 0 7
134101: ARRAY
134102: PPUSH
134103: LD_VAR 0 22
134107: PPUSH
134108: CALL_OW 113
// continue ;
134112: GO 133739
// end ; end else
134114: GO 134394
// if group [ i ] in repairs then
134116: LD_VAR 0 4
134120: PUSH
134121: LD_VAR 0 7
134125: ARRAY
134126: PUSH
134127: LD_VAR 0 33
134131: IN
134132: IFFALSE 134394
// begin if IsInUnit ( group [ i ] ) then
134134: LD_VAR 0 4
134138: PUSH
134139: LD_VAR 0 7
134143: ARRAY
134144: PPUSH
134145: CALL_OW 310
134149: IFFALSE 134217
// begin z := IsInUnit ( group [ i ] ) ;
134151: LD_ADDR_VAR 0 13
134155: PUSH
134156: LD_VAR 0 4
134160: PUSH
134161: LD_VAR 0 7
134165: ARRAY
134166: PPUSH
134167: CALL_OW 310
134171: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
134172: LD_VAR 0 13
134176: PUSH
134177: LD_VAR 0 32
134181: IN
134182: PUSH
134183: LD_VAR 0 13
134187: PPUSH
134188: LD_VAR 0 22
134192: PPUSH
134193: CALL_OW 308
134197: AND
134198: IFFALSE 134215
// ComExitVehicle ( group [ i ] ) ;
134200: LD_VAR 0 4
134204: PUSH
134205: LD_VAR 0 7
134209: ARRAY
134210: PPUSH
134211: CALL_OW 121
// end else
134215: GO 134394
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
134217: LD_ADDR_VAR 0 13
134221: PUSH
134222: LD_VAR 0 4
134226: PPUSH
134227: LD_INT 95
134229: PUSH
134230: LD_VAR 0 22
134234: PUSH
134235: EMPTY
134236: LIST
134237: LIST
134238: PUSH
134239: LD_INT 58
134241: PUSH
134242: EMPTY
134243: LIST
134244: PUSH
134245: EMPTY
134246: LIST
134247: LIST
134248: PPUSH
134249: CALL_OW 72
134253: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
134254: LD_VAR 0 4
134258: PUSH
134259: LD_VAR 0 7
134263: ARRAY
134264: PPUSH
134265: CALL_OW 314
134269: NOT
134270: IFFALSE 134392
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
134272: LD_ADDR_VAR 0 10
134276: PUSH
134277: LD_VAR 0 13
134281: PPUSH
134282: LD_VAR 0 4
134286: PUSH
134287: LD_VAR 0 7
134291: ARRAY
134292: PPUSH
134293: CALL_OW 74
134297: ST_TO_ADDR
// if not x then
134298: LD_VAR 0 10
134302: NOT
134303: IFFALSE 134307
// continue ;
134305: GO 133739
// if GetLives ( x ) < 1000 then
134307: LD_VAR 0 10
134311: PPUSH
134312: CALL_OW 256
134316: PUSH
134317: LD_INT 1000
134319: LESS
134320: IFFALSE 134344
// ComRepairVehicle ( group [ i ] , x ) else
134322: LD_VAR 0 4
134326: PUSH
134327: LD_VAR 0 7
134331: ARRAY
134332: PPUSH
134333: LD_VAR 0 10
134337: PPUSH
134338: CALL_OW 129
134342: GO 134392
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
134344: LD_VAR 0 23
134348: PUSH
134349: LD_VAR 0 4
134353: PUSH
134354: LD_VAR 0 7
134358: ARRAY
134359: PPUSH
134360: CALL_OW 256
134364: PUSH
134365: LD_INT 1000
134367: LESS
134368: AND
134369: NOT
134370: IFFALSE 134392
// ComEnterUnit ( group [ i ] , x ) ;
134372: LD_VAR 0 4
134376: PUSH
134377: LD_VAR 0 7
134381: ARRAY
134382: PPUSH
134383: LD_VAR 0 10
134387: PPUSH
134388: CALL_OW 120
// end ; continue ;
134392: GO 133739
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
134394: LD_VAR 0 23
134398: PUSH
134399: LD_VAR 0 4
134403: PUSH
134404: LD_VAR 0 7
134408: ARRAY
134409: PPUSH
134410: CALL_OW 247
134414: PUSH
134415: LD_INT 1
134417: EQUAL
134418: AND
134419: IFFALSE 134897
// begin if group [ i ] in healers then
134421: LD_VAR 0 4
134425: PUSH
134426: LD_VAR 0 7
134430: ARRAY
134431: PUSH
134432: LD_VAR 0 31
134436: IN
134437: IFFALSE 134710
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
134439: LD_VAR 0 4
134443: PUSH
134444: LD_VAR 0 7
134448: ARRAY
134449: PPUSH
134450: LD_VAR 0 23
134454: PPUSH
134455: CALL_OW 308
134459: NOT
134460: PUSH
134461: LD_VAR 0 4
134465: PUSH
134466: LD_VAR 0 7
134470: ARRAY
134471: PPUSH
134472: CALL_OW 314
134476: NOT
134477: AND
134478: IFFALSE 134502
// ComMoveToArea ( group [ i ] , f_heal ) else
134480: LD_VAR 0 4
134484: PUSH
134485: LD_VAR 0 7
134489: ARRAY
134490: PPUSH
134491: LD_VAR 0 23
134495: PPUSH
134496: CALL_OW 113
134500: GO 134708
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
134502: LD_VAR 0 4
134506: PUSH
134507: LD_VAR 0 7
134511: ARRAY
134512: PPUSH
134513: CALL 104789 0 1
134517: PPUSH
134518: CALL_OW 256
134522: PUSH
134523: LD_INT 1000
134525: EQUAL
134526: IFFALSE 134545
// ComStop ( group [ i ] ) else
134528: LD_VAR 0 4
134532: PUSH
134533: LD_VAR 0 7
134537: ARRAY
134538: PPUSH
134539: CALL_OW 141
134543: GO 134708
// if not HasTask ( group [ i ] ) and to_heal then
134545: LD_VAR 0 4
134549: PUSH
134550: LD_VAR 0 7
134554: ARRAY
134555: PPUSH
134556: CALL_OW 314
134560: NOT
134561: PUSH
134562: LD_VAR 0 30
134566: AND
134567: IFFALSE 134708
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
134569: LD_ADDR_VAR 0 13
134573: PUSH
134574: LD_VAR 0 30
134578: PPUSH
134579: LD_INT 3
134581: PUSH
134582: LD_INT 54
134584: PUSH
134585: EMPTY
134586: LIST
134587: PUSH
134588: EMPTY
134589: LIST
134590: LIST
134591: PPUSH
134592: CALL_OW 72
134596: PPUSH
134597: LD_VAR 0 4
134601: PUSH
134602: LD_VAR 0 7
134606: ARRAY
134607: PPUSH
134608: CALL_OW 74
134612: ST_TO_ADDR
// if z then
134613: LD_VAR 0 13
134617: IFFALSE 134708
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
134619: LD_INT 91
134621: PUSH
134622: LD_VAR 0 13
134626: PUSH
134627: LD_INT 10
134629: PUSH
134630: EMPTY
134631: LIST
134632: LIST
134633: LIST
134634: PUSH
134635: LD_INT 81
134637: PUSH
134638: LD_VAR 0 13
134642: PPUSH
134643: CALL_OW 255
134647: PUSH
134648: EMPTY
134649: LIST
134650: LIST
134651: PUSH
134652: EMPTY
134653: LIST
134654: LIST
134655: PPUSH
134656: CALL_OW 69
134660: PUSH
134661: LD_INT 0
134663: EQUAL
134664: IFFALSE 134688
// ComHeal ( group [ i ] , z ) else
134666: LD_VAR 0 4
134670: PUSH
134671: LD_VAR 0 7
134675: ARRAY
134676: PPUSH
134677: LD_VAR 0 13
134681: PPUSH
134682: CALL_OW 128
134686: GO 134708
// ComMoveToArea ( group [ i ] , f_heal ) ;
134688: LD_VAR 0 4
134692: PUSH
134693: LD_VAR 0 7
134697: ARRAY
134698: PPUSH
134699: LD_VAR 0 23
134703: PPUSH
134704: CALL_OW 113
// end ; continue ;
134708: GO 133739
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
134710: LD_VAR 0 4
134714: PUSH
134715: LD_VAR 0 7
134719: ARRAY
134720: PPUSH
134721: CALL_OW 256
134725: PUSH
134726: LD_INT 700
134728: LESS
134729: PUSH
134730: LD_VAR 0 4
134734: PUSH
134735: LD_VAR 0 7
134739: ARRAY
134740: PUSH
134741: LD_VAR 0 30
134745: IN
134746: NOT
134747: AND
134748: IFFALSE 134772
// to_heal := to_heal union group [ i ] ;
134750: LD_ADDR_VAR 0 30
134754: PUSH
134755: LD_VAR 0 30
134759: PUSH
134760: LD_VAR 0 4
134764: PUSH
134765: LD_VAR 0 7
134769: ARRAY
134770: UNION
134771: ST_TO_ADDR
// if group [ i ] in to_heal then
134772: LD_VAR 0 4
134776: PUSH
134777: LD_VAR 0 7
134781: ARRAY
134782: PUSH
134783: LD_VAR 0 30
134787: IN
134788: IFFALSE 134897
// begin if GetLives ( group [ i ] ) = 1000 then
134790: LD_VAR 0 4
134794: PUSH
134795: LD_VAR 0 7
134799: ARRAY
134800: PPUSH
134801: CALL_OW 256
134805: PUSH
134806: LD_INT 1000
134808: EQUAL
134809: IFFALSE 134835
// to_heal := to_heal diff group [ i ] else
134811: LD_ADDR_VAR 0 30
134815: PUSH
134816: LD_VAR 0 30
134820: PUSH
134821: LD_VAR 0 4
134825: PUSH
134826: LD_VAR 0 7
134830: ARRAY
134831: DIFF
134832: ST_TO_ADDR
134833: GO 134897
// begin if not IsInArea ( group [ i ] , to_heal ) then
134835: LD_VAR 0 4
134839: PUSH
134840: LD_VAR 0 7
134844: ARRAY
134845: PPUSH
134846: LD_VAR 0 30
134850: PPUSH
134851: CALL_OW 308
134855: NOT
134856: IFFALSE 134880
// ComMoveToArea ( group [ i ] , f_heal ) else
134858: LD_VAR 0 4
134862: PUSH
134863: LD_VAR 0 7
134867: ARRAY
134868: PPUSH
134869: LD_VAR 0 23
134873: PPUSH
134874: CALL_OW 113
134878: GO 134895
// ComHold ( group [ i ] ) ;
134880: LD_VAR 0 4
134884: PUSH
134885: LD_VAR 0 7
134889: ARRAY
134890: PPUSH
134891: CALL_OW 140
// continue ;
134895: GO 133739
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134897: LD_VAR 0 4
134901: PUSH
134902: LD_VAR 0 7
134906: ARRAY
134907: PPUSH
134908: LD_INT 10
134910: PPUSH
134911: CALL 102571 0 2
134915: NOT
134916: PUSH
134917: LD_VAR 0 16
134921: PUSH
134922: LD_VAR 0 7
134926: ARRAY
134927: PUSH
134928: EMPTY
134929: EQUAL
134930: NOT
134931: AND
134932: IFFALSE 135198
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134934: LD_VAR 0 4
134938: PUSH
134939: LD_VAR 0 7
134943: ARRAY
134944: PPUSH
134945: CALL_OW 262
134949: PUSH
134950: LD_INT 1
134952: PUSH
134953: LD_INT 2
134955: PUSH
134956: EMPTY
134957: LIST
134958: LIST
134959: IN
134960: IFFALSE 135001
// if GetFuel ( group [ i ] ) < 10 then
134962: LD_VAR 0 4
134966: PUSH
134967: LD_VAR 0 7
134971: ARRAY
134972: PPUSH
134973: CALL_OW 261
134977: PUSH
134978: LD_INT 10
134980: LESS
134981: IFFALSE 135001
// SetFuel ( group [ i ] , 12 ) ;
134983: LD_VAR 0 4
134987: PUSH
134988: LD_VAR 0 7
134992: ARRAY
134993: PPUSH
134994: LD_INT 12
134996: PPUSH
134997: CALL_OW 240
// if units_path [ i ] then
135001: LD_VAR 0 16
135005: PUSH
135006: LD_VAR 0 7
135010: ARRAY
135011: IFFALSE 135196
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
135013: LD_VAR 0 4
135017: PUSH
135018: LD_VAR 0 7
135022: ARRAY
135023: PPUSH
135024: LD_VAR 0 16
135028: PUSH
135029: LD_VAR 0 7
135033: ARRAY
135034: PUSH
135035: LD_INT 1
135037: ARRAY
135038: PUSH
135039: LD_INT 1
135041: ARRAY
135042: PPUSH
135043: LD_VAR 0 16
135047: PUSH
135048: LD_VAR 0 7
135052: ARRAY
135053: PUSH
135054: LD_INT 1
135056: ARRAY
135057: PUSH
135058: LD_INT 2
135060: ARRAY
135061: PPUSH
135062: CALL_OW 297
135066: PUSH
135067: LD_INT 6
135069: GREATER
135070: IFFALSE 135145
// begin if not HasTask ( group [ i ] ) then
135072: LD_VAR 0 4
135076: PUSH
135077: LD_VAR 0 7
135081: ARRAY
135082: PPUSH
135083: CALL_OW 314
135087: NOT
135088: IFFALSE 135143
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
135090: LD_VAR 0 4
135094: PUSH
135095: LD_VAR 0 7
135099: ARRAY
135100: PPUSH
135101: LD_VAR 0 16
135105: PUSH
135106: LD_VAR 0 7
135110: ARRAY
135111: PUSH
135112: LD_INT 1
135114: ARRAY
135115: PUSH
135116: LD_INT 1
135118: ARRAY
135119: PPUSH
135120: LD_VAR 0 16
135124: PUSH
135125: LD_VAR 0 7
135129: ARRAY
135130: PUSH
135131: LD_INT 1
135133: ARRAY
135134: PUSH
135135: LD_INT 2
135137: ARRAY
135138: PPUSH
135139: CALL_OW 114
// end else
135143: GO 135196
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
135145: LD_ADDR_VAR 0 15
135149: PUSH
135150: LD_VAR 0 16
135154: PUSH
135155: LD_VAR 0 7
135159: ARRAY
135160: PPUSH
135161: LD_INT 1
135163: PPUSH
135164: CALL_OW 3
135168: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
135169: LD_ADDR_VAR 0 16
135173: PUSH
135174: LD_VAR 0 16
135178: PPUSH
135179: LD_VAR 0 7
135183: PPUSH
135184: LD_VAR 0 15
135188: PPUSH
135189: CALL_OW 1
135193: ST_TO_ADDR
// continue ;
135194: GO 133739
// end ; end ; end else
135196: GO 137860
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
135198: LD_ADDR_VAR 0 14
135202: PUSH
135203: LD_INT 81
135205: PUSH
135206: LD_VAR 0 4
135210: PUSH
135211: LD_VAR 0 7
135215: ARRAY
135216: PPUSH
135217: CALL_OW 255
135221: PUSH
135222: EMPTY
135223: LIST
135224: LIST
135225: PPUSH
135226: CALL_OW 69
135230: ST_TO_ADDR
// if not tmp then
135231: LD_VAR 0 14
135235: NOT
135236: IFFALSE 135240
// continue ;
135238: GO 133739
// if f_ignore_area then
135240: LD_VAR 0 17
135244: IFFALSE 135332
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
135246: LD_ADDR_VAR 0 15
135250: PUSH
135251: LD_VAR 0 14
135255: PPUSH
135256: LD_INT 3
135258: PUSH
135259: LD_INT 92
135261: PUSH
135262: LD_VAR 0 17
135266: PUSH
135267: LD_INT 1
135269: ARRAY
135270: PUSH
135271: LD_VAR 0 17
135275: PUSH
135276: LD_INT 2
135278: ARRAY
135279: PUSH
135280: LD_VAR 0 17
135284: PUSH
135285: LD_INT 3
135287: ARRAY
135288: PUSH
135289: EMPTY
135290: LIST
135291: LIST
135292: LIST
135293: LIST
135294: PUSH
135295: EMPTY
135296: LIST
135297: LIST
135298: PPUSH
135299: CALL_OW 72
135303: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135304: LD_VAR 0 14
135308: PUSH
135309: LD_VAR 0 15
135313: DIFF
135314: IFFALSE 135332
// tmp := tmp diff tmp2 ;
135316: LD_ADDR_VAR 0 14
135320: PUSH
135321: LD_VAR 0 14
135325: PUSH
135326: LD_VAR 0 15
135330: DIFF
135331: ST_TO_ADDR
// end ; if not f_murder then
135332: LD_VAR 0 20
135336: NOT
135337: IFFALSE 135395
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
135339: LD_ADDR_VAR 0 15
135343: PUSH
135344: LD_VAR 0 14
135348: PPUSH
135349: LD_INT 3
135351: PUSH
135352: LD_INT 50
135354: PUSH
135355: EMPTY
135356: LIST
135357: PUSH
135358: EMPTY
135359: LIST
135360: LIST
135361: PPUSH
135362: CALL_OW 72
135366: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135367: LD_VAR 0 14
135371: PUSH
135372: LD_VAR 0 15
135376: DIFF
135377: IFFALSE 135395
// tmp := tmp diff tmp2 ;
135379: LD_ADDR_VAR 0 14
135383: PUSH
135384: LD_VAR 0 14
135388: PUSH
135389: LD_VAR 0 15
135393: DIFF
135394: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
135395: LD_ADDR_VAR 0 14
135399: PUSH
135400: LD_VAR 0 4
135404: PUSH
135405: LD_VAR 0 7
135409: ARRAY
135410: PPUSH
135411: LD_VAR 0 14
135415: PPUSH
135416: LD_INT 1
135418: PPUSH
135419: LD_INT 1
135421: PPUSH
135422: CALL 75115 0 4
135426: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
135427: LD_VAR 0 4
135431: PUSH
135432: LD_VAR 0 7
135436: ARRAY
135437: PPUSH
135438: CALL_OW 257
135442: PUSH
135443: LD_INT 1
135445: EQUAL
135446: IFFALSE 135894
// begin if WantPlant ( group [ i ] ) then
135448: LD_VAR 0 4
135452: PUSH
135453: LD_VAR 0 7
135457: ARRAY
135458: PPUSH
135459: CALL 74616 0 1
135463: IFFALSE 135467
// continue ;
135465: GO 133739
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
135467: LD_VAR 0 18
135471: PUSH
135472: LD_VAR 0 4
135476: PUSH
135477: LD_VAR 0 7
135481: ARRAY
135482: PPUSH
135483: CALL_OW 310
135487: NOT
135488: AND
135489: PUSH
135490: LD_VAR 0 14
135494: PUSH
135495: LD_INT 1
135497: ARRAY
135498: PUSH
135499: LD_VAR 0 14
135503: PPUSH
135504: LD_INT 21
135506: PUSH
135507: LD_INT 2
135509: PUSH
135510: EMPTY
135511: LIST
135512: LIST
135513: PUSH
135514: LD_INT 58
135516: PUSH
135517: EMPTY
135518: LIST
135519: PUSH
135520: EMPTY
135521: LIST
135522: LIST
135523: PPUSH
135524: CALL_OW 72
135528: IN
135529: AND
135530: IFFALSE 135566
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
135532: LD_VAR 0 4
135536: PUSH
135537: LD_VAR 0 7
135541: ARRAY
135542: PPUSH
135543: LD_VAR 0 14
135547: PUSH
135548: LD_INT 1
135550: ARRAY
135551: PPUSH
135552: CALL_OW 120
// attacking := true ;
135556: LD_ADDR_VAR 0 29
135560: PUSH
135561: LD_INT 1
135563: ST_TO_ADDR
// continue ;
135564: GO 133739
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
135566: LD_VAR 0 26
135570: PUSH
135571: LD_VAR 0 4
135575: PUSH
135576: LD_VAR 0 7
135580: ARRAY
135581: PPUSH
135582: CALL_OW 257
135586: PUSH
135587: LD_INT 1
135589: EQUAL
135590: AND
135591: PUSH
135592: LD_VAR 0 4
135596: PUSH
135597: LD_VAR 0 7
135601: ARRAY
135602: PPUSH
135603: CALL_OW 256
135607: PUSH
135608: LD_INT 800
135610: LESS
135611: AND
135612: PUSH
135613: LD_VAR 0 4
135617: PUSH
135618: LD_VAR 0 7
135622: ARRAY
135623: PPUSH
135624: CALL_OW 318
135628: NOT
135629: AND
135630: IFFALSE 135647
// ComCrawl ( group [ i ] ) ;
135632: LD_VAR 0 4
135636: PUSH
135637: LD_VAR 0 7
135641: ARRAY
135642: PPUSH
135643: CALL_OW 137
// if f_mines then
135647: LD_VAR 0 21
135651: IFFALSE 135894
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
135653: LD_VAR 0 14
135657: PUSH
135658: LD_INT 1
135660: ARRAY
135661: PPUSH
135662: CALL_OW 247
135666: PUSH
135667: LD_INT 3
135669: EQUAL
135670: PUSH
135671: LD_VAR 0 14
135675: PUSH
135676: LD_INT 1
135678: ARRAY
135679: PUSH
135680: LD_VAR 0 27
135684: IN
135685: NOT
135686: AND
135687: IFFALSE 135894
// begin x := GetX ( tmp [ 1 ] ) ;
135689: LD_ADDR_VAR 0 10
135693: PUSH
135694: LD_VAR 0 14
135698: PUSH
135699: LD_INT 1
135701: ARRAY
135702: PPUSH
135703: CALL_OW 250
135707: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
135708: LD_ADDR_VAR 0 11
135712: PUSH
135713: LD_VAR 0 14
135717: PUSH
135718: LD_INT 1
135720: ARRAY
135721: PPUSH
135722: CALL_OW 251
135726: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
135727: LD_ADDR_VAR 0 12
135731: PUSH
135732: LD_VAR 0 4
135736: PUSH
135737: LD_VAR 0 7
135741: ARRAY
135742: PPUSH
135743: CALL 102656 0 1
135747: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
135748: LD_VAR 0 4
135752: PUSH
135753: LD_VAR 0 7
135757: ARRAY
135758: PPUSH
135759: LD_VAR 0 10
135763: PPUSH
135764: LD_VAR 0 11
135768: PPUSH
135769: LD_VAR 0 14
135773: PUSH
135774: LD_INT 1
135776: ARRAY
135777: PPUSH
135778: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
135782: LD_VAR 0 4
135786: PUSH
135787: LD_VAR 0 7
135791: ARRAY
135792: PPUSH
135793: LD_VAR 0 10
135797: PPUSH
135798: LD_VAR 0 12
135802: PPUSH
135803: LD_INT 7
135805: PPUSH
135806: CALL_OW 272
135810: PPUSH
135811: LD_VAR 0 11
135815: PPUSH
135816: LD_VAR 0 12
135820: PPUSH
135821: LD_INT 7
135823: PPUSH
135824: CALL_OW 273
135828: PPUSH
135829: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135833: LD_VAR 0 4
135837: PUSH
135838: LD_VAR 0 7
135842: ARRAY
135843: PPUSH
135844: LD_INT 71
135846: PPUSH
135847: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135851: LD_ADDR_VAR 0 27
135855: PUSH
135856: LD_VAR 0 27
135860: PPUSH
135861: LD_VAR 0 27
135865: PUSH
135866: LD_INT 1
135868: PLUS
135869: PPUSH
135870: LD_VAR 0 14
135874: PUSH
135875: LD_INT 1
135877: ARRAY
135878: PPUSH
135879: CALL_OW 1
135883: ST_TO_ADDR
// attacking := true ;
135884: LD_ADDR_VAR 0 29
135888: PUSH
135889: LD_INT 1
135891: ST_TO_ADDR
// continue ;
135892: GO 133739
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135894: LD_VAR 0 4
135898: PUSH
135899: LD_VAR 0 7
135903: ARRAY
135904: PPUSH
135905: CALL_OW 257
135909: PUSH
135910: LD_INT 17
135912: EQUAL
135913: PUSH
135914: LD_VAR 0 4
135918: PUSH
135919: LD_VAR 0 7
135923: ARRAY
135924: PPUSH
135925: CALL_OW 110
135929: PUSH
135930: LD_INT 71
135932: EQUAL
135933: NOT
135934: AND
135935: IFFALSE 136081
// begin attacking := false ;
135937: LD_ADDR_VAR 0 29
135941: PUSH
135942: LD_INT 0
135944: ST_TO_ADDR
// k := 5 ;
135945: LD_ADDR_VAR 0 9
135949: PUSH
135950: LD_INT 5
135952: ST_TO_ADDR
// if tmp < k then
135953: LD_VAR 0 14
135957: PUSH
135958: LD_VAR 0 9
135962: LESS
135963: IFFALSE 135975
// k := tmp ;
135965: LD_ADDR_VAR 0 9
135969: PUSH
135970: LD_VAR 0 14
135974: ST_TO_ADDR
// for j = 1 to k do
135975: LD_ADDR_VAR 0 8
135979: PUSH
135980: DOUBLE
135981: LD_INT 1
135983: DEC
135984: ST_TO_ADDR
135985: LD_VAR 0 9
135989: PUSH
135990: FOR_TO
135991: IFFALSE 136079
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135993: LD_VAR 0 14
135997: PUSH
135998: LD_VAR 0 8
136002: ARRAY
136003: PUSH
136004: LD_VAR 0 14
136008: PPUSH
136009: LD_INT 58
136011: PUSH
136012: EMPTY
136013: LIST
136014: PPUSH
136015: CALL_OW 72
136019: IN
136020: NOT
136021: IFFALSE 136077
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136023: LD_VAR 0 4
136027: PUSH
136028: LD_VAR 0 7
136032: ARRAY
136033: PPUSH
136034: LD_VAR 0 14
136038: PUSH
136039: LD_VAR 0 8
136043: ARRAY
136044: PPUSH
136045: CALL_OW 115
// attacking := true ;
136049: LD_ADDR_VAR 0 29
136053: PUSH
136054: LD_INT 1
136056: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
136057: LD_VAR 0 4
136061: PUSH
136062: LD_VAR 0 7
136066: ARRAY
136067: PPUSH
136068: LD_INT 71
136070: PPUSH
136071: CALL_OW 109
// continue ;
136075: GO 135990
// end ; end ;
136077: GO 135990
136079: POP
136080: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
136081: LD_VAR 0 4
136085: PUSH
136086: LD_VAR 0 7
136090: ARRAY
136091: PPUSH
136092: CALL_OW 257
136096: PUSH
136097: LD_INT 8
136099: EQUAL
136100: PUSH
136101: LD_VAR 0 4
136105: PUSH
136106: LD_VAR 0 7
136110: ARRAY
136111: PPUSH
136112: CALL_OW 264
136116: PUSH
136117: LD_INT 28
136119: PUSH
136120: LD_INT 45
136122: PUSH
136123: LD_INT 7
136125: PUSH
136126: LD_INT 47
136128: PUSH
136129: EMPTY
136130: LIST
136131: LIST
136132: LIST
136133: LIST
136134: IN
136135: OR
136136: IFFALSE 136392
// begin attacking := false ;
136138: LD_ADDR_VAR 0 29
136142: PUSH
136143: LD_INT 0
136145: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
136146: LD_VAR 0 14
136150: PUSH
136151: LD_INT 1
136153: ARRAY
136154: PPUSH
136155: CALL_OW 266
136159: PUSH
136160: LD_INT 32
136162: PUSH
136163: LD_INT 31
136165: PUSH
136166: LD_INT 33
136168: PUSH
136169: LD_INT 4
136171: PUSH
136172: LD_INT 5
136174: PUSH
136175: EMPTY
136176: LIST
136177: LIST
136178: LIST
136179: LIST
136180: LIST
136181: IN
136182: IFFALSE 136368
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
136184: LD_ADDR_VAR 0 9
136188: PUSH
136189: LD_VAR 0 14
136193: PUSH
136194: LD_INT 1
136196: ARRAY
136197: PPUSH
136198: CALL_OW 266
136202: PPUSH
136203: LD_VAR 0 14
136207: PUSH
136208: LD_INT 1
136210: ARRAY
136211: PPUSH
136212: CALL_OW 250
136216: PPUSH
136217: LD_VAR 0 14
136221: PUSH
136222: LD_INT 1
136224: ARRAY
136225: PPUSH
136226: CALL_OW 251
136230: PPUSH
136231: LD_VAR 0 14
136235: PUSH
136236: LD_INT 1
136238: ARRAY
136239: PPUSH
136240: CALL_OW 254
136244: PPUSH
136245: LD_VAR 0 14
136249: PUSH
136250: LD_INT 1
136252: ARRAY
136253: PPUSH
136254: CALL_OW 248
136258: PPUSH
136259: LD_INT 0
136261: PPUSH
136262: CALL 84026 0 6
136266: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
136267: LD_ADDR_VAR 0 8
136271: PUSH
136272: LD_VAR 0 4
136276: PUSH
136277: LD_VAR 0 7
136281: ARRAY
136282: PPUSH
136283: LD_VAR 0 9
136287: PPUSH
136288: CALL 102769 0 2
136292: ST_TO_ADDR
// if j then
136293: LD_VAR 0 8
136297: IFFALSE 136366
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
136299: LD_VAR 0 8
136303: PUSH
136304: LD_INT 1
136306: ARRAY
136307: PPUSH
136308: LD_VAR 0 8
136312: PUSH
136313: LD_INT 2
136315: ARRAY
136316: PPUSH
136317: CALL_OW 488
136321: IFFALSE 136366
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
136323: LD_VAR 0 4
136327: PUSH
136328: LD_VAR 0 7
136332: ARRAY
136333: PPUSH
136334: LD_VAR 0 8
136338: PUSH
136339: LD_INT 1
136341: ARRAY
136342: PPUSH
136343: LD_VAR 0 8
136347: PUSH
136348: LD_INT 2
136350: ARRAY
136351: PPUSH
136352: CALL_OW 116
// attacking := true ;
136356: LD_ADDR_VAR 0 29
136360: PUSH
136361: LD_INT 1
136363: ST_TO_ADDR
// continue ;
136364: GO 133739
// end ; end else
136366: GO 136392
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136368: LD_VAR 0 4
136372: PUSH
136373: LD_VAR 0 7
136377: ARRAY
136378: PPUSH
136379: LD_VAR 0 14
136383: PUSH
136384: LD_INT 1
136386: ARRAY
136387: PPUSH
136388: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
136392: LD_VAR 0 4
136396: PUSH
136397: LD_VAR 0 7
136401: ARRAY
136402: PPUSH
136403: CALL_OW 265
136407: PUSH
136408: LD_INT 11
136410: EQUAL
136411: IFFALSE 136689
// begin k := 10 ;
136413: LD_ADDR_VAR 0 9
136417: PUSH
136418: LD_INT 10
136420: ST_TO_ADDR
// x := 0 ;
136421: LD_ADDR_VAR 0 10
136425: PUSH
136426: LD_INT 0
136428: ST_TO_ADDR
// if tmp < k then
136429: LD_VAR 0 14
136433: PUSH
136434: LD_VAR 0 9
136438: LESS
136439: IFFALSE 136451
// k := tmp ;
136441: LD_ADDR_VAR 0 9
136445: PUSH
136446: LD_VAR 0 14
136450: ST_TO_ADDR
// for j = k downto 1 do
136451: LD_ADDR_VAR 0 8
136455: PUSH
136456: DOUBLE
136457: LD_VAR 0 9
136461: INC
136462: ST_TO_ADDR
136463: LD_INT 1
136465: PUSH
136466: FOR_DOWNTO
136467: IFFALSE 136542
// begin if GetType ( tmp [ j ] ) = unit_human then
136469: LD_VAR 0 14
136473: PUSH
136474: LD_VAR 0 8
136478: ARRAY
136479: PPUSH
136480: CALL_OW 247
136484: PUSH
136485: LD_INT 1
136487: EQUAL
136488: IFFALSE 136540
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
136490: LD_VAR 0 4
136494: PUSH
136495: LD_VAR 0 7
136499: ARRAY
136500: PPUSH
136501: LD_VAR 0 14
136505: PUSH
136506: LD_VAR 0 8
136510: ARRAY
136511: PPUSH
136512: CALL 103023 0 2
// x := tmp [ j ] ;
136516: LD_ADDR_VAR 0 10
136520: PUSH
136521: LD_VAR 0 14
136525: PUSH
136526: LD_VAR 0 8
136530: ARRAY
136531: ST_TO_ADDR
// attacking := true ;
136532: LD_ADDR_VAR 0 29
136536: PUSH
136537: LD_INT 1
136539: ST_TO_ADDR
// end ; end ;
136540: GO 136466
136542: POP
136543: POP
// if not x then
136544: LD_VAR 0 10
136548: NOT
136549: IFFALSE 136689
// begin attacking := true ;
136551: LD_ADDR_VAR 0 29
136555: PUSH
136556: LD_INT 1
136558: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
136559: LD_VAR 0 4
136563: PUSH
136564: LD_VAR 0 7
136568: ARRAY
136569: PPUSH
136570: CALL_OW 250
136574: PPUSH
136575: LD_VAR 0 4
136579: PUSH
136580: LD_VAR 0 7
136584: ARRAY
136585: PPUSH
136586: CALL_OW 251
136590: PPUSH
136591: CALL_OW 546
136595: PUSH
136596: LD_INT 2
136598: ARRAY
136599: PUSH
136600: LD_VAR 0 14
136604: PUSH
136605: LD_INT 1
136607: ARRAY
136608: PPUSH
136609: CALL_OW 250
136613: PPUSH
136614: LD_VAR 0 14
136618: PUSH
136619: LD_INT 1
136621: ARRAY
136622: PPUSH
136623: CALL_OW 251
136627: PPUSH
136628: CALL_OW 546
136632: PUSH
136633: LD_INT 2
136635: ARRAY
136636: EQUAL
136637: IFFALSE 136665
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
136639: LD_VAR 0 4
136643: PUSH
136644: LD_VAR 0 7
136648: ARRAY
136649: PPUSH
136650: LD_VAR 0 14
136654: PUSH
136655: LD_INT 1
136657: ARRAY
136658: PPUSH
136659: CALL 103023 0 2
136663: GO 136689
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136665: LD_VAR 0 4
136669: PUSH
136670: LD_VAR 0 7
136674: ARRAY
136675: PPUSH
136676: LD_VAR 0 14
136680: PUSH
136681: LD_INT 1
136683: ARRAY
136684: PPUSH
136685: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
136689: LD_VAR 0 4
136693: PUSH
136694: LD_VAR 0 7
136698: ARRAY
136699: PPUSH
136700: CALL_OW 264
136704: PUSH
136705: LD_INT 29
136707: EQUAL
136708: IFFALSE 137074
// begin if WantsToAttack ( group [ i ] ) in bombed then
136710: LD_VAR 0 4
136714: PUSH
136715: LD_VAR 0 7
136719: ARRAY
136720: PPUSH
136721: CALL_OW 319
136725: PUSH
136726: LD_VAR 0 28
136730: IN
136731: IFFALSE 136735
// continue ;
136733: GO 133739
// k := 8 ;
136735: LD_ADDR_VAR 0 9
136739: PUSH
136740: LD_INT 8
136742: ST_TO_ADDR
// x := 0 ;
136743: LD_ADDR_VAR 0 10
136747: PUSH
136748: LD_INT 0
136750: ST_TO_ADDR
// if tmp < k then
136751: LD_VAR 0 14
136755: PUSH
136756: LD_VAR 0 9
136760: LESS
136761: IFFALSE 136773
// k := tmp ;
136763: LD_ADDR_VAR 0 9
136767: PUSH
136768: LD_VAR 0 14
136772: ST_TO_ADDR
// for j = 1 to k do
136773: LD_ADDR_VAR 0 8
136777: PUSH
136778: DOUBLE
136779: LD_INT 1
136781: DEC
136782: ST_TO_ADDR
136783: LD_VAR 0 9
136787: PUSH
136788: FOR_TO
136789: IFFALSE 136921
// begin if GetType ( tmp [ j ] ) = unit_building then
136791: LD_VAR 0 14
136795: PUSH
136796: LD_VAR 0 8
136800: ARRAY
136801: PPUSH
136802: CALL_OW 247
136806: PUSH
136807: LD_INT 3
136809: EQUAL
136810: IFFALSE 136919
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
136812: LD_VAR 0 14
136816: PUSH
136817: LD_VAR 0 8
136821: ARRAY
136822: PUSH
136823: LD_VAR 0 28
136827: IN
136828: NOT
136829: PUSH
136830: LD_VAR 0 14
136834: PUSH
136835: LD_VAR 0 8
136839: ARRAY
136840: PPUSH
136841: CALL_OW 313
136845: AND
136846: IFFALSE 136919
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136848: LD_VAR 0 4
136852: PUSH
136853: LD_VAR 0 7
136857: ARRAY
136858: PPUSH
136859: LD_VAR 0 14
136863: PUSH
136864: LD_VAR 0 8
136868: ARRAY
136869: PPUSH
136870: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136874: LD_ADDR_VAR 0 28
136878: PUSH
136879: LD_VAR 0 28
136883: PPUSH
136884: LD_VAR 0 28
136888: PUSH
136889: LD_INT 1
136891: PLUS
136892: PPUSH
136893: LD_VAR 0 14
136897: PUSH
136898: LD_VAR 0 8
136902: ARRAY
136903: PPUSH
136904: CALL_OW 1
136908: ST_TO_ADDR
// attacking := true ;
136909: LD_ADDR_VAR 0 29
136913: PUSH
136914: LD_INT 1
136916: ST_TO_ADDR
// break ;
136917: GO 136921
// end ; end ;
136919: GO 136788
136921: POP
136922: POP
// if not attacking and f_attack_depot then
136923: LD_VAR 0 29
136927: NOT
136928: PUSH
136929: LD_VAR 0 25
136933: AND
136934: IFFALSE 137029
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136936: LD_ADDR_VAR 0 13
136940: PUSH
136941: LD_VAR 0 14
136945: PPUSH
136946: LD_INT 2
136948: PUSH
136949: LD_INT 30
136951: PUSH
136952: LD_INT 0
136954: PUSH
136955: EMPTY
136956: LIST
136957: LIST
136958: PUSH
136959: LD_INT 30
136961: PUSH
136962: LD_INT 1
136964: PUSH
136965: EMPTY
136966: LIST
136967: LIST
136968: PUSH
136969: EMPTY
136970: LIST
136971: LIST
136972: LIST
136973: PPUSH
136974: CALL_OW 72
136978: ST_TO_ADDR
// if z then
136979: LD_VAR 0 13
136983: IFFALSE 137029
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136985: LD_VAR 0 4
136989: PUSH
136990: LD_VAR 0 7
136994: ARRAY
136995: PPUSH
136996: LD_VAR 0 13
137000: PPUSH
137001: LD_VAR 0 4
137005: PUSH
137006: LD_VAR 0 7
137010: ARRAY
137011: PPUSH
137012: CALL_OW 74
137016: PPUSH
137017: CALL_OW 115
// attacking := true ;
137021: LD_ADDR_VAR 0 29
137025: PUSH
137026: LD_INT 1
137028: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
137029: LD_VAR 0 4
137033: PUSH
137034: LD_VAR 0 7
137038: ARRAY
137039: PPUSH
137040: CALL_OW 256
137044: PUSH
137045: LD_INT 500
137047: LESS
137048: IFFALSE 137074
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137050: LD_VAR 0 4
137054: PUSH
137055: LD_VAR 0 7
137059: ARRAY
137060: PPUSH
137061: LD_VAR 0 14
137065: PUSH
137066: LD_INT 1
137068: ARRAY
137069: PPUSH
137070: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
137074: LD_VAR 0 4
137078: PUSH
137079: LD_VAR 0 7
137083: ARRAY
137084: PPUSH
137085: CALL_OW 264
137089: PUSH
137090: LD_INT 49
137092: EQUAL
137093: IFFALSE 137214
// begin if not HasTask ( group [ i ] ) then
137095: LD_VAR 0 4
137099: PUSH
137100: LD_VAR 0 7
137104: ARRAY
137105: PPUSH
137106: CALL_OW 314
137110: NOT
137111: IFFALSE 137214
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
137113: LD_ADDR_VAR 0 9
137117: PUSH
137118: LD_INT 81
137120: PUSH
137121: LD_VAR 0 4
137125: PUSH
137126: LD_VAR 0 7
137130: ARRAY
137131: PPUSH
137132: CALL_OW 255
137136: PUSH
137137: EMPTY
137138: LIST
137139: LIST
137140: PPUSH
137141: CALL_OW 69
137145: PPUSH
137146: LD_VAR 0 4
137150: PUSH
137151: LD_VAR 0 7
137155: ARRAY
137156: PPUSH
137157: CALL_OW 74
137161: ST_TO_ADDR
// if k then
137162: LD_VAR 0 9
137166: IFFALSE 137214
// if GetDistUnits ( group [ i ] , k ) > 10 then
137168: LD_VAR 0 4
137172: PUSH
137173: LD_VAR 0 7
137177: ARRAY
137178: PPUSH
137179: LD_VAR 0 9
137183: PPUSH
137184: CALL_OW 296
137188: PUSH
137189: LD_INT 10
137191: GREATER
137192: IFFALSE 137214
// ComMoveUnit ( group [ i ] , k ) ;
137194: LD_VAR 0 4
137198: PUSH
137199: LD_VAR 0 7
137203: ARRAY
137204: PPUSH
137205: LD_VAR 0 9
137209: PPUSH
137210: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
137214: LD_VAR 0 4
137218: PUSH
137219: LD_VAR 0 7
137223: ARRAY
137224: PPUSH
137225: CALL_OW 256
137229: PUSH
137230: LD_INT 250
137232: LESS
137233: PUSH
137234: LD_VAR 0 4
137238: PUSH
137239: LD_VAR 0 7
137243: ARRAY
137244: PUSH
137245: LD_INT 21
137247: PUSH
137248: LD_INT 2
137250: PUSH
137251: EMPTY
137252: LIST
137253: LIST
137254: PUSH
137255: LD_INT 23
137257: PUSH
137258: LD_INT 2
137260: PUSH
137261: EMPTY
137262: LIST
137263: LIST
137264: PUSH
137265: EMPTY
137266: LIST
137267: LIST
137268: PPUSH
137269: CALL_OW 69
137273: IN
137274: AND
137275: IFFALSE 137400
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
137277: LD_ADDR_VAR 0 9
137281: PUSH
137282: LD_OWVAR 3
137286: PUSH
137287: LD_VAR 0 4
137291: PUSH
137292: LD_VAR 0 7
137296: ARRAY
137297: DIFF
137298: PPUSH
137299: LD_VAR 0 4
137303: PUSH
137304: LD_VAR 0 7
137308: ARRAY
137309: PPUSH
137310: CALL_OW 74
137314: ST_TO_ADDR
// if not k then
137315: LD_VAR 0 9
137319: NOT
137320: IFFALSE 137324
// continue ;
137322: GO 133739
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
137324: LD_VAR 0 9
137328: PUSH
137329: LD_INT 81
137331: PUSH
137332: LD_VAR 0 4
137336: PUSH
137337: LD_VAR 0 7
137341: ARRAY
137342: PPUSH
137343: CALL_OW 255
137347: PUSH
137348: EMPTY
137349: LIST
137350: LIST
137351: PPUSH
137352: CALL_OW 69
137356: IN
137357: PUSH
137358: LD_VAR 0 9
137362: PPUSH
137363: LD_VAR 0 4
137367: PUSH
137368: LD_VAR 0 7
137372: ARRAY
137373: PPUSH
137374: CALL_OW 296
137378: PUSH
137379: LD_INT 5
137381: LESS
137382: AND
137383: IFFALSE 137400
// ComAutodestruct ( group [ i ] ) ;
137385: LD_VAR 0 4
137389: PUSH
137390: LD_VAR 0 7
137394: ARRAY
137395: PPUSH
137396: CALL 102921 0 1
// end ; if f_attack_depot then
137400: LD_VAR 0 25
137404: IFFALSE 137516
// begin k := 6 ;
137406: LD_ADDR_VAR 0 9
137410: PUSH
137411: LD_INT 6
137413: ST_TO_ADDR
// if tmp < k then
137414: LD_VAR 0 14
137418: PUSH
137419: LD_VAR 0 9
137423: LESS
137424: IFFALSE 137436
// k := tmp ;
137426: LD_ADDR_VAR 0 9
137430: PUSH
137431: LD_VAR 0 14
137435: ST_TO_ADDR
// for j = 1 to k do
137436: LD_ADDR_VAR 0 8
137440: PUSH
137441: DOUBLE
137442: LD_INT 1
137444: DEC
137445: ST_TO_ADDR
137446: LD_VAR 0 9
137450: PUSH
137451: FOR_TO
137452: IFFALSE 137514
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
137454: LD_VAR 0 8
137458: PPUSH
137459: CALL_OW 266
137463: PUSH
137464: LD_INT 0
137466: PUSH
137467: LD_INT 1
137469: PUSH
137470: EMPTY
137471: LIST
137472: LIST
137473: IN
137474: IFFALSE 137512
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137476: LD_VAR 0 4
137480: PUSH
137481: LD_VAR 0 7
137485: ARRAY
137486: PPUSH
137487: LD_VAR 0 14
137491: PUSH
137492: LD_VAR 0 8
137496: ARRAY
137497: PPUSH
137498: CALL_OW 115
// attacking := true ;
137502: LD_ADDR_VAR 0 29
137506: PUSH
137507: LD_INT 1
137509: ST_TO_ADDR
// break ;
137510: GO 137514
// end ;
137512: GO 137451
137514: POP
137515: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
137516: LD_VAR 0 4
137520: PUSH
137521: LD_VAR 0 7
137525: ARRAY
137526: PPUSH
137527: CALL_OW 302
137531: PUSH
137532: LD_VAR 0 29
137536: NOT
137537: AND
137538: IFFALSE 137860
// begin if GetTag ( group [ i ] ) = 71 then
137540: LD_VAR 0 4
137544: PUSH
137545: LD_VAR 0 7
137549: ARRAY
137550: PPUSH
137551: CALL_OW 110
137555: PUSH
137556: LD_INT 71
137558: EQUAL
137559: IFFALSE 137600
// begin if HasTask ( group [ i ] ) then
137561: LD_VAR 0 4
137565: PUSH
137566: LD_VAR 0 7
137570: ARRAY
137571: PPUSH
137572: CALL_OW 314
137576: IFFALSE 137582
// continue else
137578: GO 133739
137580: GO 137600
// SetTag ( group [ i ] , 0 ) ;
137582: LD_VAR 0 4
137586: PUSH
137587: LD_VAR 0 7
137591: ARRAY
137592: PPUSH
137593: LD_INT 0
137595: PPUSH
137596: CALL_OW 109
// end ; k := 8 ;
137600: LD_ADDR_VAR 0 9
137604: PUSH
137605: LD_INT 8
137607: ST_TO_ADDR
// x := 0 ;
137608: LD_ADDR_VAR 0 10
137612: PUSH
137613: LD_INT 0
137615: ST_TO_ADDR
// if tmp < k then
137616: LD_VAR 0 14
137620: PUSH
137621: LD_VAR 0 9
137625: LESS
137626: IFFALSE 137638
// k := tmp ;
137628: LD_ADDR_VAR 0 9
137632: PUSH
137633: LD_VAR 0 14
137637: ST_TO_ADDR
// for j = 1 to k do
137638: LD_ADDR_VAR 0 8
137642: PUSH
137643: DOUBLE
137644: LD_INT 1
137646: DEC
137647: ST_TO_ADDR
137648: LD_VAR 0 9
137652: PUSH
137653: FOR_TO
137654: IFFALSE 137752
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
137656: LD_VAR 0 14
137660: PUSH
137661: LD_VAR 0 8
137665: ARRAY
137666: PPUSH
137667: CALL_OW 247
137671: PUSH
137672: LD_INT 1
137674: EQUAL
137675: PUSH
137676: LD_VAR 0 14
137680: PUSH
137681: LD_VAR 0 8
137685: ARRAY
137686: PPUSH
137687: CALL_OW 256
137691: PUSH
137692: LD_INT 250
137694: LESS
137695: PUSH
137696: LD_VAR 0 20
137700: AND
137701: PUSH
137702: LD_VAR 0 20
137706: NOT
137707: PUSH
137708: LD_VAR 0 14
137712: PUSH
137713: LD_VAR 0 8
137717: ARRAY
137718: PPUSH
137719: CALL_OW 256
137723: PUSH
137724: LD_INT 250
137726: GREATEREQUAL
137727: AND
137728: OR
137729: AND
137730: IFFALSE 137750
// begin x := tmp [ j ] ;
137732: LD_ADDR_VAR 0 10
137736: PUSH
137737: LD_VAR 0 14
137741: PUSH
137742: LD_VAR 0 8
137746: ARRAY
137747: ST_TO_ADDR
// break ;
137748: GO 137752
// end ;
137750: GO 137653
137752: POP
137753: POP
// if x then
137754: LD_VAR 0 10
137758: IFFALSE 137782
// ComAttackUnit ( group [ i ] , x ) else
137760: LD_VAR 0 4
137764: PUSH
137765: LD_VAR 0 7
137769: ARRAY
137770: PPUSH
137771: LD_VAR 0 10
137775: PPUSH
137776: CALL_OW 115
137780: GO 137806
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137782: LD_VAR 0 4
137786: PUSH
137787: LD_VAR 0 7
137791: ARRAY
137792: PPUSH
137793: LD_VAR 0 14
137797: PUSH
137798: LD_INT 1
137800: ARRAY
137801: PPUSH
137802: CALL_OW 115
// if not HasTask ( group [ i ] ) then
137806: LD_VAR 0 4
137810: PUSH
137811: LD_VAR 0 7
137815: ARRAY
137816: PPUSH
137817: CALL_OW 314
137821: NOT
137822: IFFALSE 137860
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
137824: LD_VAR 0 4
137828: PUSH
137829: LD_VAR 0 7
137833: ARRAY
137834: PPUSH
137835: LD_VAR 0 14
137839: PPUSH
137840: LD_VAR 0 4
137844: PUSH
137845: LD_VAR 0 7
137849: ARRAY
137850: PPUSH
137851: CALL_OW 74
137855: PPUSH
137856: CALL_OW 115
// end ; end ; end ;
137860: GO 133739
137862: POP
137863: POP
// wait ( 0 0$2 ) ;
137864: LD_INT 70
137866: PPUSH
137867: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137871: LD_VAR 0 4
137875: NOT
137876: PUSH
137877: LD_VAR 0 4
137881: PUSH
137882: EMPTY
137883: EQUAL
137884: OR
137885: PUSH
137886: LD_INT 81
137888: PUSH
137889: LD_VAR 0 35
137893: PUSH
137894: EMPTY
137895: LIST
137896: LIST
137897: PPUSH
137898: CALL_OW 69
137902: NOT
137903: OR
137904: IFFALSE 133724
// end ;
137906: LD_VAR 0 2
137910: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137911: LD_INT 0
137913: PPUSH
137914: PPUSH
137915: PPUSH
137916: PPUSH
137917: PPUSH
137918: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137919: LD_VAR 0 1
137923: NOT
137924: PUSH
137925: LD_EXP 102
137929: PUSH
137930: LD_VAR 0 1
137934: ARRAY
137935: NOT
137936: OR
137937: PUSH
137938: LD_VAR 0 2
137942: NOT
137943: OR
137944: IFFALSE 137948
// exit ;
137946: GO 138502
// side := mc_sides [ base ] ;
137948: LD_ADDR_VAR 0 6
137952: PUSH
137953: LD_EXP 128
137957: PUSH
137958: LD_VAR 0 1
137962: ARRAY
137963: ST_TO_ADDR
// if not side then
137964: LD_VAR 0 6
137968: NOT
137969: IFFALSE 137973
// exit ;
137971: GO 138502
// for i in solds do
137973: LD_ADDR_VAR 0 7
137977: PUSH
137978: LD_VAR 0 2
137982: PUSH
137983: FOR_IN
137984: IFFALSE 138045
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137986: LD_VAR 0 7
137990: PPUSH
137991: CALL_OW 310
137995: PPUSH
137996: CALL_OW 266
138000: PUSH
138001: LD_INT 32
138003: PUSH
138004: LD_INT 31
138006: PUSH
138007: EMPTY
138008: LIST
138009: LIST
138010: IN
138011: IFFALSE 138031
// solds := solds diff i else
138013: LD_ADDR_VAR 0 2
138017: PUSH
138018: LD_VAR 0 2
138022: PUSH
138023: LD_VAR 0 7
138027: DIFF
138028: ST_TO_ADDR
138029: GO 138043
// SetTag ( i , 18 ) ;
138031: LD_VAR 0 7
138035: PPUSH
138036: LD_INT 18
138038: PPUSH
138039: CALL_OW 109
138043: GO 137983
138045: POP
138046: POP
// if not solds then
138047: LD_VAR 0 2
138051: NOT
138052: IFFALSE 138056
// exit ;
138054: GO 138502
// repeat wait ( 0 0$2 ) ;
138056: LD_INT 70
138058: PPUSH
138059: CALL_OW 67
// enemy := mc_scan [ base ] ;
138063: LD_ADDR_VAR 0 4
138067: PUSH
138068: LD_EXP 125
138072: PUSH
138073: LD_VAR 0 1
138077: ARRAY
138078: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138079: LD_EXP 102
138083: PUSH
138084: LD_VAR 0 1
138088: ARRAY
138089: NOT
138090: PUSH
138091: LD_EXP 102
138095: PUSH
138096: LD_VAR 0 1
138100: ARRAY
138101: PUSH
138102: EMPTY
138103: EQUAL
138104: OR
138105: IFFALSE 138142
// begin for i in solds do
138107: LD_ADDR_VAR 0 7
138111: PUSH
138112: LD_VAR 0 2
138116: PUSH
138117: FOR_IN
138118: IFFALSE 138131
// ComStop ( i ) ;
138120: LD_VAR 0 7
138124: PPUSH
138125: CALL_OW 141
138129: GO 138117
138131: POP
138132: POP
// solds := [ ] ;
138133: LD_ADDR_VAR 0 2
138137: PUSH
138138: EMPTY
138139: ST_TO_ADDR
// exit ;
138140: GO 138502
// end ; for i in solds do
138142: LD_ADDR_VAR 0 7
138146: PUSH
138147: LD_VAR 0 2
138151: PUSH
138152: FOR_IN
138153: IFFALSE 138474
// begin if IsInUnit ( i ) then
138155: LD_VAR 0 7
138159: PPUSH
138160: CALL_OW 310
138164: IFFALSE 138175
// ComExitBuilding ( i ) ;
138166: LD_VAR 0 7
138170: PPUSH
138171: CALL_OW 122
// if GetLives ( i ) > 500 then
138175: LD_VAR 0 7
138179: PPUSH
138180: CALL_OW 256
138184: PUSH
138185: LD_INT 500
138187: GREATER
138188: IFFALSE 138241
// begin e := NearestUnitToUnit ( enemy , i ) ;
138190: LD_ADDR_VAR 0 5
138194: PUSH
138195: LD_VAR 0 4
138199: PPUSH
138200: LD_VAR 0 7
138204: PPUSH
138205: CALL_OW 74
138209: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
138210: LD_VAR 0 7
138214: PPUSH
138215: LD_VAR 0 5
138219: PPUSH
138220: CALL_OW 250
138224: PPUSH
138225: LD_VAR 0 5
138229: PPUSH
138230: CALL_OW 251
138234: PPUSH
138235: CALL_OW 114
// end else
138239: GO 138472
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
138241: LD_VAR 0 7
138245: PPUSH
138246: LD_EXP 102
138250: PUSH
138251: LD_VAR 0 1
138255: ARRAY
138256: PPUSH
138257: LD_INT 2
138259: PUSH
138260: LD_INT 30
138262: PUSH
138263: LD_INT 0
138265: PUSH
138266: EMPTY
138267: LIST
138268: LIST
138269: PUSH
138270: LD_INT 30
138272: PUSH
138273: LD_INT 1
138275: PUSH
138276: EMPTY
138277: LIST
138278: LIST
138279: PUSH
138280: LD_INT 30
138282: PUSH
138283: LD_INT 6
138285: PUSH
138286: EMPTY
138287: LIST
138288: LIST
138289: PUSH
138290: EMPTY
138291: LIST
138292: LIST
138293: LIST
138294: LIST
138295: PPUSH
138296: CALL_OW 72
138300: PPUSH
138301: LD_VAR 0 7
138305: PPUSH
138306: CALL_OW 74
138310: PPUSH
138311: CALL_OW 296
138315: PUSH
138316: LD_INT 10
138318: GREATER
138319: IFFALSE 138472
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
138321: LD_ADDR_VAR 0 8
138325: PUSH
138326: LD_EXP 102
138330: PUSH
138331: LD_VAR 0 1
138335: ARRAY
138336: PPUSH
138337: LD_INT 2
138339: PUSH
138340: LD_INT 30
138342: PUSH
138343: LD_INT 0
138345: PUSH
138346: EMPTY
138347: LIST
138348: LIST
138349: PUSH
138350: LD_INT 30
138352: PUSH
138353: LD_INT 1
138355: PUSH
138356: EMPTY
138357: LIST
138358: LIST
138359: PUSH
138360: LD_INT 30
138362: PUSH
138363: LD_INT 6
138365: PUSH
138366: EMPTY
138367: LIST
138368: LIST
138369: PUSH
138370: EMPTY
138371: LIST
138372: LIST
138373: LIST
138374: LIST
138375: PPUSH
138376: CALL_OW 72
138380: PPUSH
138381: LD_VAR 0 7
138385: PPUSH
138386: CALL_OW 74
138390: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
138391: LD_VAR 0 7
138395: PPUSH
138396: LD_VAR 0 8
138400: PPUSH
138401: CALL_OW 250
138405: PPUSH
138406: LD_INT 3
138408: PPUSH
138409: LD_INT 5
138411: PPUSH
138412: CALL_OW 272
138416: PPUSH
138417: LD_VAR 0 8
138421: PPUSH
138422: CALL_OW 251
138426: PPUSH
138427: LD_INT 3
138429: PPUSH
138430: LD_INT 5
138432: PPUSH
138433: CALL_OW 273
138437: PPUSH
138438: CALL_OW 111
// SetTag ( i , 0 ) ;
138442: LD_VAR 0 7
138446: PPUSH
138447: LD_INT 0
138449: PPUSH
138450: CALL_OW 109
// solds := solds diff i ;
138454: LD_ADDR_VAR 0 2
138458: PUSH
138459: LD_VAR 0 2
138463: PUSH
138464: LD_VAR 0 7
138468: DIFF
138469: ST_TO_ADDR
// continue ;
138470: GO 138152
// end ; end ;
138472: GO 138152
138474: POP
138475: POP
// until not solds or not enemy ;
138476: LD_VAR 0 2
138480: NOT
138481: PUSH
138482: LD_VAR 0 4
138486: NOT
138487: OR
138488: IFFALSE 138056
// MC_Reset ( base , 18 ) ;
138490: LD_VAR 0 1
138494: PPUSH
138495: LD_INT 18
138497: PPUSH
138498: CALL 43179 0 2
// end ;
138502: LD_VAR 0 3
138506: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
138507: LD_INT 0
138509: PPUSH
138510: PPUSH
138511: PPUSH
138512: PPUSH
138513: PPUSH
138514: PPUSH
138515: PPUSH
138516: PPUSH
138517: PPUSH
138518: PPUSH
138519: PPUSH
138520: PPUSH
138521: PPUSH
138522: PPUSH
138523: PPUSH
138524: PPUSH
138525: PPUSH
138526: PPUSH
138527: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
138528: LD_ADDR_VAR 0 12
138532: PUSH
138533: LD_EXP 102
138537: PUSH
138538: LD_VAR 0 1
138542: ARRAY
138543: PPUSH
138544: LD_INT 25
138546: PUSH
138547: LD_INT 3
138549: PUSH
138550: EMPTY
138551: LIST
138552: LIST
138553: PPUSH
138554: CALL_OW 72
138558: ST_TO_ADDR
// if mc_remote_driver [ base ] then
138559: LD_EXP 142
138563: PUSH
138564: LD_VAR 0 1
138568: ARRAY
138569: IFFALSE 138593
// mechs := mechs diff mc_remote_driver [ base ] ;
138571: LD_ADDR_VAR 0 12
138575: PUSH
138576: LD_VAR 0 12
138580: PUSH
138581: LD_EXP 142
138585: PUSH
138586: LD_VAR 0 1
138590: ARRAY
138591: DIFF
138592: ST_TO_ADDR
// for i in mechs do
138593: LD_ADDR_VAR 0 4
138597: PUSH
138598: LD_VAR 0 12
138602: PUSH
138603: FOR_IN
138604: IFFALSE 138639
// if GetTag ( i ) > 0 then
138606: LD_VAR 0 4
138610: PPUSH
138611: CALL_OW 110
138615: PUSH
138616: LD_INT 0
138618: GREATER
138619: IFFALSE 138637
// mechs := mechs diff i ;
138621: LD_ADDR_VAR 0 12
138625: PUSH
138626: LD_VAR 0 12
138630: PUSH
138631: LD_VAR 0 4
138635: DIFF
138636: ST_TO_ADDR
138637: GO 138603
138639: POP
138640: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138641: LD_ADDR_VAR 0 8
138645: PUSH
138646: LD_EXP 102
138650: PUSH
138651: LD_VAR 0 1
138655: ARRAY
138656: PPUSH
138657: LD_INT 2
138659: PUSH
138660: LD_INT 25
138662: PUSH
138663: LD_INT 1
138665: PUSH
138666: EMPTY
138667: LIST
138668: LIST
138669: PUSH
138670: LD_INT 25
138672: PUSH
138673: LD_INT 5
138675: PUSH
138676: EMPTY
138677: LIST
138678: LIST
138679: PUSH
138680: LD_INT 25
138682: PUSH
138683: LD_INT 8
138685: PUSH
138686: EMPTY
138687: LIST
138688: LIST
138689: PUSH
138690: LD_INT 25
138692: PUSH
138693: LD_INT 9
138695: PUSH
138696: EMPTY
138697: LIST
138698: LIST
138699: PUSH
138700: EMPTY
138701: LIST
138702: LIST
138703: LIST
138704: LIST
138705: LIST
138706: PPUSH
138707: CALL_OW 72
138711: ST_TO_ADDR
// if not defenders and not solds then
138712: LD_VAR 0 2
138716: NOT
138717: PUSH
138718: LD_VAR 0 8
138722: NOT
138723: AND
138724: IFFALSE 138728
// exit ;
138726: GO 140498
// depot_under_attack := false ;
138728: LD_ADDR_VAR 0 16
138732: PUSH
138733: LD_INT 0
138735: ST_TO_ADDR
// sold_defenders := [ ] ;
138736: LD_ADDR_VAR 0 17
138740: PUSH
138741: EMPTY
138742: ST_TO_ADDR
// if mechs then
138743: LD_VAR 0 12
138747: IFFALSE 138900
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
138749: LD_ADDR_VAR 0 4
138753: PUSH
138754: LD_VAR 0 2
138758: PPUSH
138759: LD_INT 21
138761: PUSH
138762: LD_INT 2
138764: PUSH
138765: EMPTY
138766: LIST
138767: LIST
138768: PPUSH
138769: CALL_OW 72
138773: PUSH
138774: FOR_IN
138775: IFFALSE 138898
// begin if GetTag ( i ) <> 20 then
138777: LD_VAR 0 4
138781: PPUSH
138782: CALL_OW 110
138786: PUSH
138787: LD_INT 20
138789: NONEQUAL
138790: IFFALSE 138804
// SetTag ( i , 20 ) ;
138792: LD_VAR 0 4
138796: PPUSH
138797: LD_INT 20
138799: PPUSH
138800: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
138804: LD_VAR 0 4
138808: PPUSH
138809: CALL_OW 263
138813: PUSH
138814: LD_INT 1
138816: EQUAL
138817: PUSH
138818: LD_VAR 0 4
138822: PPUSH
138823: CALL_OW 311
138827: NOT
138828: AND
138829: IFFALSE 138896
// begin un := mechs [ 1 ] ;
138831: LD_ADDR_VAR 0 10
138835: PUSH
138836: LD_VAR 0 12
138840: PUSH
138841: LD_INT 1
138843: ARRAY
138844: ST_TO_ADDR
// ComExit ( un ) ;
138845: LD_VAR 0 10
138849: PPUSH
138850: CALL 107807 0 1
// AddComEnterUnit ( un , i ) ;
138854: LD_VAR 0 10
138858: PPUSH
138859: LD_VAR 0 4
138863: PPUSH
138864: CALL_OW 180
// SetTag ( un , 19 ) ;
138868: LD_VAR 0 10
138872: PPUSH
138873: LD_INT 19
138875: PPUSH
138876: CALL_OW 109
// mechs := mechs diff un ;
138880: LD_ADDR_VAR 0 12
138884: PUSH
138885: LD_VAR 0 12
138889: PUSH
138890: LD_VAR 0 10
138894: DIFF
138895: ST_TO_ADDR
// end ; end ;
138896: GO 138774
138898: POP
138899: POP
// if solds then
138900: LD_VAR 0 8
138904: IFFALSE 138963
// for i in solds do
138906: LD_ADDR_VAR 0 4
138910: PUSH
138911: LD_VAR 0 8
138915: PUSH
138916: FOR_IN
138917: IFFALSE 138961
// if not GetTag ( i ) then
138919: LD_VAR 0 4
138923: PPUSH
138924: CALL_OW 110
138928: NOT
138929: IFFALSE 138959
// begin defenders := defenders union i ;
138931: LD_ADDR_VAR 0 2
138935: PUSH
138936: LD_VAR 0 2
138940: PUSH
138941: LD_VAR 0 4
138945: UNION
138946: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138947: LD_VAR 0 4
138951: PPUSH
138952: LD_INT 18
138954: PPUSH
138955: CALL_OW 109
// end ;
138959: GO 138916
138961: POP
138962: POP
// repeat wait ( 0 0$2 ) ;
138963: LD_INT 70
138965: PPUSH
138966: CALL_OW 67
// enemy := mc_scan [ base ] ;
138970: LD_ADDR_VAR 0 21
138974: PUSH
138975: LD_EXP 125
138979: PUSH
138980: LD_VAR 0 1
138984: ARRAY
138985: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138986: LD_EXP 102
138990: PUSH
138991: LD_VAR 0 1
138995: ARRAY
138996: NOT
138997: PUSH
138998: LD_EXP 102
139002: PUSH
139003: LD_VAR 0 1
139007: ARRAY
139008: PUSH
139009: EMPTY
139010: EQUAL
139011: OR
139012: IFFALSE 139049
// begin for i in defenders do
139014: LD_ADDR_VAR 0 4
139018: PUSH
139019: LD_VAR 0 2
139023: PUSH
139024: FOR_IN
139025: IFFALSE 139038
// ComStop ( i ) ;
139027: LD_VAR 0 4
139031: PPUSH
139032: CALL_OW 141
139036: GO 139024
139038: POP
139039: POP
// defenders := [ ] ;
139040: LD_ADDR_VAR 0 2
139044: PUSH
139045: EMPTY
139046: ST_TO_ADDR
// exit ;
139047: GO 140498
// end ; for i in defenders do
139049: LD_ADDR_VAR 0 4
139053: PUSH
139054: LD_VAR 0 2
139058: PUSH
139059: FOR_IN
139060: IFFALSE 139958
// begin e := NearestUnitToUnit ( enemy , i ) ;
139062: LD_ADDR_VAR 0 13
139066: PUSH
139067: LD_VAR 0 21
139071: PPUSH
139072: LD_VAR 0 4
139076: PPUSH
139077: CALL_OW 74
139081: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
139082: LD_ADDR_VAR 0 7
139086: PUSH
139087: LD_EXP 102
139091: PUSH
139092: LD_VAR 0 1
139096: ARRAY
139097: PPUSH
139098: LD_INT 2
139100: PUSH
139101: LD_INT 30
139103: PUSH
139104: LD_INT 0
139106: PUSH
139107: EMPTY
139108: LIST
139109: LIST
139110: PUSH
139111: LD_INT 30
139113: PUSH
139114: LD_INT 1
139116: PUSH
139117: EMPTY
139118: LIST
139119: LIST
139120: PUSH
139121: EMPTY
139122: LIST
139123: LIST
139124: LIST
139125: PPUSH
139126: CALL_OW 72
139130: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
139131: LD_ADDR_VAR 0 16
139135: PUSH
139136: LD_VAR 0 7
139140: NOT
139141: PUSH
139142: LD_VAR 0 7
139146: PPUSH
139147: LD_INT 3
139149: PUSH
139150: LD_INT 24
139152: PUSH
139153: LD_INT 600
139155: PUSH
139156: EMPTY
139157: LIST
139158: LIST
139159: PUSH
139160: EMPTY
139161: LIST
139162: LIST
139163: PPUSH
139164: CALL_OW 72
139168: OR
139169: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
139170: LD_VAR 0 4
139174: PPUSH
139175: CALL_OW 247
139179: PUSH
139180: LD_INT 2
139182: DOUBLE
139183: EQUAL
139184: IFTRUE 139188
139186: GO 139584
139188: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
139189: LD_VAR 0 4
139193: PPUSH
139194: CALL_OW 256
139198: PUSH
139199: LD_INT 1000
139201: EQUAL
139202: PUSH
139203: LD_VAR 0 4
139207: PPUSH
139208: LD_VAR 0 13
139212: PPUSH
139213: CALL_OW 296
139217: PUSH
139218: LD_INT 40
139220: LESS
139221: PUSH
139222: LD_VAR 0 13
139226: PPUSH
139227: LD_EXP 127
139231: PUSH
139232: LD_VAR 0 1
139236: ARRAY
139237: PPUSH
139238: CALL_OW 308
139242: OR
139243: AND
139244: IFFALSE 139366
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
139246: LD_VAR 0 4
139250: PPUSH
139251: CALL_OW 262
139255: PUSH
139256: LD_INT 1
139258: EQUAL
139259: PUSH
139260: LD_VAR 0 4
139264: PPUSH
139265: CALL_OW 261
139269: PUSH
139270: LD_INT 30
139272: LESS
139273: AND
139274: PUSH
139275: LD_VAR 0 7
139279: AND
139280: IFFALSE 139350
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
139282: LD_VAR 0 4
139286: PPUSH
139287: LD_VAR 0 7
139291: PPUSH
139292: LD_VAR 0 4
139296: PPUSH
139297: CALL_OW 74
139301: PPUSH
139302: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
139306: LD_VAR 0 4
139310: PPUSH
139311: LD_VAR 0 7
139315: PPUSH
139316: LD_VAR 0 4
139320: PPUSH
139321: CALL_OW 74
139325: PPUSH
139326: CALL_OW 296
139330: PUSH
139331: LD_INT 6
139333: LESS
139334: IFFALSE 139348
// SetFuel ( i , 100 ) ;
139336: LD_VAR 0 4
139340: PPUSH
139341: LD_INT 100
139343: PPUSH
139344: CALL_OW 240
// end else
139348: GO 139364
// ComAttackUnit ( i , e ) ;
139350: LD_VAR 0 4
139354: PPUSH
139355: LD_VAR 0 13
139359: PPUSH
139360: CALL_OW 115
// end else
139364: GO 139467
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
139366: LD_VAR 0 13
139370: PPUSH
139371: LD_EXP 127
139375: PUSH
139376: LD_VAR 0 1
139380: ARRAY
139381: PPUSH
139382: CALL_OW 308
139386: NOT
139387: PUSH
139388: LD_VAR 0 4
139392: PPUSH
139393: LD_VAR 0 13
139397: PPUSH
139398: CALL_OW 296
139402: PUSH
139403: LD_INT 40
139405: GREATEREQUAL
139406: AND
139407: PUSH
139408: LD_VAR 0 4
139412: PPUSH
139413: CALL_OW 256
139417: PUSH
139418: LD_INT 650
139420: LESSEQUAL
139421: OR
139422: PUSH
139423: LD_VAR 0 4
139427: PPUSH
139428: LD_EXP 126
139432: PUSH
139433: LD_VAR 0 1
139437: ARRAY
139438: PPUSH
139439: CALL_OW 308
139443: NOT
139444: AND
139445: IFFALSE 139467
// ComMoveToArea ( i , mc_parking [ base ] ) ;
139447: LD_VAR 0 4
139451: PPUSH
139452: LD_EXP 126
139456: PUSH
139457: LD_VAR 0 1
139461: ARRAY
139462: PPUSH
139463: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
139467: LD_VAR 0 4
139471: PPUSH
139472: CALL_OW 256
139476: PUSH
139477: LD_INT 1000
139479: LESS
139480: PUSH
139481: LD_VAR 0 4
139485: PPUSH
139486: CALL_OW 263
139490: PUSH
139491: LD_INT 1
139493: EQUAL
139494: AND
139495: PUSH
139496: LD_VAR 0 4
139500: PPUSH
139501: CALL_OW 311
139505: AND
139506: PUSH
139507: LD_VAR 0 4
139511: PPUSH
139512: LD_EXP 126
139516: PUSH
139517: LD_VAR 0 1
139521: ARRAY
139522: PPUSH
139523: CALL_OW 308
139527: AND
139528: IFFALSE 139582
// begin mech := IsDrivenBy ( i ) ;
139530: LD_ADDR_VAR 0 9
139534: PUSH
139535: LD_VAR 0 4
139539: PPUSH
139540: CALL_OW 311
139544: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
139545: LD_VAR 0 9
139549: PPUSH
139550: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
139554: LD_VAR 0 9
139558: PPUSH
139559: LD_VAR 0 4
139563: PPUSH
139564: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
139568: LD_VAR 0 9
139572: PPUSH
139573: LD_VAR 0 4
139577: PPUSH
139578: CALL_OW 180
// end ; end ; unit_human :
139582: GO 139929
139584: LD_INT 1
139586: DOUBLE
139587: EQUAL
139588: IFTRUE 139592
139590: GO 139928
139592: POP
// begin b := IsInUnit ( i ) ;
139593: LD_ADDR_VAR 0 18
139597: PUSH
139598: LD_VAR 0 4
139602: PPUSH
139603: CALL_OW 310
139607: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
139608: LD_ADDR_VAR 0 19
139612: PUSH
139613: LD_VAR 0 18
139617: NOT
139618: PUSH
139619: LD_VAR 0 18
139623: PPUSH
139624: CALL_OW 266
139628: PUSH
139629: LD_INT 32
139631: PUSH
139632: LD_INT 31
139634: PUSH
139635: EMPTY
139636: LIST
139637: LIST
139638: IN
139639: OR
139640: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
139641: LD_VAR 0 18
139645: PPUSH
139646: CALL_OW 266
139650: PUSH
139651: LD_INT 5
139653: EQUAL
139654: PUSH
139655: LD_VAR 0 4
139659: PPUSH
139660: CALL_OW 257
139664: PUSH
139665: LD_INT 1
139667: PUSH
139668: LD_INT 2
139670: PUSH
139671: LD_INT 3
139673: PUSH
139674: LD_INT 4
139676: PUSH
139677: EMPTY
139678: LIST
139679: LIST
139680: LIST
139681: LIST
139682: IN
139683: AND
139684: IFFALSE 139721
// begin class := AllowSpecClass ( i ) ;
139686: LD_ADDR_VAR 0 20
139690: PUSH
139691: LD_VAR 0 4
139695: PPUSH
139696: CALL 71504 0 1
139700: ST_TO_ADDR
// if class then
139701: LD_VAR 0 20
139705: IFFALSE 139721
// ComChangeProfession ( i , class ) ;
139707: LD_VAR 0 4
139711: PPUSH
139712: LD_VAR 0 20
139716: PPUSH
139717: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
139721: LD_VAR 0 16
139725: PUSH
139726: LD_VAR 0 2
139730: PPUSH
139731: LD_INT 21
139733: PUSH
139734: LD_INT 2
139736: PUSH
139737: EMPTY
139738: LIST
139739: LIST
139740: PPUSH
139741: CALL_OW 72
139745: PUSH
139746: LD_INT 1
139748: LESSEQUAL
139749: OR
139750: PUSH
139751: LD_VAR 0 19
139755: AND
139756: PUSH
139757: LD_VAR 0 4
139761: PUSH
139762: LD_VAR 0 17
139766: IN
139767: NOT
139768: AND
139769: IFFALSE 139862
// begin if b then
139771: LD_VAR 0 18
139775: IFFALSE 139824
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
139777: LD_VAR 0 18
139781: PPUSH
139782: LD_VAR 0 21
139786: PPUSH
139787: LD_VAR 0 18
139791: PPUSH
139792: CALL_OW 74
139796: PPUSH
139797: CALL_OW 296
139801: PUSH
139802: LD_INT 10
139804: LESS
139805: PUSH
139806: LD_VAR 0 18
139810: PPUSH
139811: CALL_OW 461
139815: PUSH
139816: LD_INT 7
139818: NONEQUAL
139819: AND
139820: IFFALSE 139824
// continue ;
139822: GO 139059
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
139824: LD_ADDR_VAR 0 17
139828: PUSH
139829: LD_VAR 0 17
139833: PPUSH
139834: LD_VAR 0 17
139838: PUSH
139839: LD_INT 1
139841: PLUS
139842: PPUSH
139843: LD_VAR 0 4
139847: PPUSH
139848: CALL_OW 1
139852: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139853: LD_VAR 0 4
139857: PPUSH
139858: CALL_OW 122
// end ; if sold_defenders then
139862: LD_VAR 0 17
139866: IFFALSE 139926
// if i in sold_defenders then
139868: LD_VAR 0 4
139872: PUSH
139873: LD_VAR 0 17
139877: IN
139878: IFFALSE 139926
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139880: LD_VAR 0 4
139884: PPUSH
139885: CALL_OW 314
139889: NOT
139890: PUSH
139891: LD_VAR 0 4
139895: PPUSH
139896: LD_VAR 0 13
139900: PPUSH
139901: CALL_OW 296
139905: PUSH
139906: LD_INT 30
139908: LESS
139909: AND
139910: IFFALSE 139926
// ComAttackUnit ( i , e ) ;
139912: LD_VAR 0 4
139916: PPUSH
139917: LD_VAR 0 13
139921: PPUSH
139922: CALL_OW 115
// end ; end ; end ;
139926: GO 139929
139928: POP
// if IsDead ( i ) then
139929: LD_VAR 0 4
139933: PPUSH
139934: CALL_OW 301
139938: IFFALSE 139956
// defenders := defenders diff i ;
139940: LD_ADDR_VAR 0 2
139944: PUSH
139945: LD_VAR 0 2
139949: PUSH
139950: LD_VAR 0 4
139954: DIFF
139955: ST_TO_ADDR
// end ;
139956: GO 139059
139958: POP
139959: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139960: LD_VAR 0 21
139964: NOT
139965: PUSH
139966: LD_VAR 0 2
139970: NOT
139971: OR
139972: PUSH
139973: LD_EXP 102
139977: PUSH
139978: LD_VAR 0 1
139982: ARRAY
139983: NOT
139984: OR
139985: IFFALSE 138963
// MC_Reset ( base , 18 ) ;
139987: LD_VAR 0 1
139991: PPUSH
139992: LD_INT 18
139994: PPUSH
139995: CALL 43179 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139999: LD_ADDR_VAR 0 2
140003: PUSH
140004: LD_VAR 0 2
140008: PUSH
140009: LD_VAR 0 2
140013: PPUSH
140014: LD_INT 2
140016: PUSH
140017: LD_INT 25
140019: PUSH
140020: LD_INT 1
140022: PUSH
140023: EMPTY
140024: LIST
140025: LIST
140026: PUSH
140027: LD_INT 25
140029: PUSH
140030: LD_INT 5
140032: PUSH
140033: EMPTY
140034: LIST
140035: LIST
140036: PUSH
140037: LD_INT 25
140039: PUSH
140040: LD_INT 8
140042: PUSH
140043: EMPTY
140044: LIST
140045: LIST
140046: PUSH
140047: LD_INT 25
140049: PUSH
140050: LD_INT 9
140052: PUSH
140053: EMPTY
140054: LIST
140055: LIST
140056: PUSH
140057: EMPTY
140058: LIST
140059: LIST
140060: LIST
140061: LIST
140062: LIST
140063: PPUSH
140064: CALL_OW 72
140068: DIFF
140069: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
140070: LD_VAR 0 21
140074: NOT
140075: PUSH
140076: LD_VAR 0 2
140080: PPUSH
140081: LD_INT 21
140083: PUSH
140084: LD_INT 2
140086: PUSH
140087: EMPTY
140088: LIST
140089: LIST
140090: PPUSH
140091: CALL_OW 72
140095: AND
140096: IFFALSE 140434
// begin tmp := FilterByTag ( defenders , 19 ) ;
140098: LD_ADDR_VAR 0 11
140102: PUSH
140103: LD_VAR 0 2
140107: PPUSH
140108: LD_INT 19
140110: PPUSH
140111: CALL 104978 0 2
140115: ST_TO_ADDR
// if tmp then
140116: LD_VAR 0 11
140120: IFFALSE 140190
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
140122: LD_ADDR_VAR 0 11
140126: PUSH
140127: LD_VAR 0 11
140131: PPUSH
140132: LD_INT 25
140134: PUSH
140135: LD_INT 3
140137: PUSH
140138: EMPTY
140139: LIST
140140: LIST
140141: PPUSH
140142: CALL_OW 72
140146: ST_TO_ADDR
// if tmp then
140147: LD_VAR 0 11
140151: IFFALSE 140190
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
140153: LD_ADDR_EXP 114
140157: PUSH
140158: LD_EXP 114
140162: PPUSH
140163: LD_VAR 0 1
140167: PPUSH
140168: LD_EXP 114
140172: PUSH
140173: LD_VAR 0 1
140177: ARRAY
140178: PUSH
140179: LD_VAR 0 11
140183: UNION
140184: PPUSH
140185: CALL_OW 1
140189: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
140190: LD_VAR 0 1
140194: PPUSH
140195: LD_INT 19
140197: PPUSH
140198: CALL 43179 0 2
// repeat wait ( 0 0$1 ) ;
140202: LD_INT 35
140204: PPUSH
140205: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140209: LD_EXP 102
140213: PUSH
140214: LD_VAR 0 1
140218: ARRAY
140219: NOT
140220: PUSH
140221: LD_EXP 102
140225: PUSH
140226: LD_VAR 0 1
140230: ARRAY
140231: PUSH
140232: EMPTY
140233: EQUAL
140234: OR
140235: IFFALSE 140272
// begin for i in defenders do
140237: LD_ADDR_VAR 0 4
140241: PUSH
140242: LD_VAR 0 2
140246: PUSH
140247: FOR_IN
140248: IFFALSE 140261
// ComStop ( i ) ;
140250: LD_VAR 0 4
140254: PPUSH
140255: CALL_OW 141
140259: GO 140247
140261: POP
140262: POP
// defenders := [ ] ;
140263: LD_ADDR_VAR 0 2
140267: PUSH
140268: EMPTY
140269: ST_TO_ADDR
// exit ;
140270: GO 140498
// end ; for i in defenders do
140272: LD_ADDR_VAR 0 4
140276: PUSH
140277: LD_VAR 0 2
140281: PUSH
140282: FOR_IN
140283: IFFALSE 140372
// begin if not IsInArea ( i , mc_parking [ base ] ) then
140285: LD_VAR 0 4
140289: PPUSH
140290: LD_EXP 126
140294: PUSH
140295: LD_VAR 0 1
140299: ARRAY
140300: PPUSH
140301: CALL_OW 308
140305: NOT
140306: IFFALSE 140330
// ComMoveToArea ( i , mc_parking [ base ] ) else
140308: LD_VAR 0 4
140312: PPUSH
140313: LD_EXP 126
140317: PUSH
140318: LD_VAR 0 1
140322: ARRAY
140323: PPUSH
140324: CALL_OW 113
140328: GO 140370
// if GetControl ( i ) = control_manual then
140330: LD_VAR 0 4
140334: PPUSH
140335: CALL_OW 263
140339: PUSH
140340: LD_INT 1
140342: EQUAL
140343: IFFALSE 140370
// if IsDrivenBy ( i ) then
140345: LD_VAR 0 4
140349: PPUSH
140350: CALL_OW 311
140354: IFFALSE 140370
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
140356: LD_VAR 0 4
140360: PPUSH
140361: CALL_OW 311
140365: PPUSH
140366: CALL_OW 121
// end ;
140370: GO 140282
140372: POP
140373: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
140374: LD_VAR 0 2
140378: PPUSH
140379: LD_INT 95
140381: PUSH
140382: LD_EXP 126
140386: PUSH
140387: LD_VAR 0 1
140391: ARRAY
140392: PUSH
140393: EMPTY
140394: LIST
140395: LIST
140396: PPUSH
140397: CALL_OW 72
140401: PUSH
140402: LD_VAR 0 2
140406: EQUAL
140407: PUSH
140408: LD_EXP 125
140412: PUSH
140413: LD_VAR 0 1
140417: ARRAY
140418: OR
140419: PUSH
140420: LD_EXP 102
140424: PUSH
140425: LD_VAR 0 1
140429: ARRAY
140430: NOT
140431: OR
140432: IFFALSE 140202
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
140434: LD_ADDR_EXP 124
140438: PUSH
140439: LD_EXP 124
140443: PPUSH
140444: LD_VAR 0 1
140448: PPUSH
140449: LD_VAR 0 2
140453: PPUSH
140454: LD_INT 21
140456: PUSH
140457: LD_INT 2
140459: PUSH
140460: EMPTY
140461: LIST
140462: LIST
140463: PPUSH
140464: CALL_OW 72
140468: PPUSH
140469: CALL_OW 1
140473: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
140474: LD_VAR 0 1
140478: PPUSH
140479: LD_INT 19
140481: PPUSH
140482: CALL 43179 0 2
// MC_Reset ( base , 20 ) ;
140486: LD_VAR 0 1
140490: PPUSH
140491: LD_INT 20
140493: PPUSH
140494: CALL 43179 0 2
// end ; end_of_file
140498: LD_VAR 0 3
140502: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
140503: LD_VAR 0 1
140507: PUSH
140508: LD_INT 200
140510: DOUBLE
140511: GREATEREQUAL
140512: IFFALSE 140520
140514: LD_INT 299
140516: DOUBLE
140517: LESSEQUAL
140518: IFTRUE 140522
140520: GO 140554
140522: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
140523: LD_VAR 0 1
140527: PPUSH
140528: LD_VAR 0 2
140532: PPUSH
140533: LD_VAR 0 3
140537: PPUSH
140538: LD_VAR 0 4
140542: PPUSH
140543: LD_VAR 0 5
140547: PPUSH
140548: CALL 128684 0 5
140552: GO 140631
140554: LD_INT 300
140556: DOUBLE
140557: GREATEREQUAL
140558: IFFALSE 140566
140560: LD_INT 399
140562: DOUBLE
140563: LESSEQUAL
140564: IFTRUE 140568
140566: GO 140630
140568: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
140569: LD_VAR 0 1
140573: PPUSH
140574: LD_VAR 0 2
140578: PPUSH
140579: LD_VAR 0 3
140583: PPUSH
140584: LD_VAR 0 4
140588: PPUSH
140589: LD_VAR 0 5
140593: PPUSH
140594: LD_VAR 0 6
140598: PPUSH
140599: LD_VAR 0 7
140603: PPUSH
140604: LD_VAR 0 8
140608: PPUSH
140609: LD_VAR 0 9
140613: PPUSH
140614: LD_VAR 0 10
140618: PPUSH
140619: LD_VAR 0 11
140623: PPUSH
140624: CALL 125009 0 11
140628: GO 140631
140630: POP
// end ;
140631: PPOPN 11
140633: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
140634: LD_VAR 0 1
140638: PPUSH
140639: LD_VAR 0 2
140643: PPUSH
140644: LD_VAR 0 3
140648: PPUSH
140649: LD_VAR 0 4
140653: PPUSH
140654: LD_VAR 0 5
140658: PPUSH
140659: CALL 128420 0 5
// end ; end_of_file
140663: PPOPN 5
140665: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
140666: LD_VAR 0 1
140670: PPUSH
140671: LD_VAR 0 2
140675: PPUSH
140676: LD_VAR 0 3
140680: PPUSH
140681: LD_VAR 0 4
140685: PPUSH
140686: LD_VAR 0 5
140690: PPUSH
140691: LD_VAR 0 6
140695: PPUSH
140696: CALL 112661 0 6
// end ;
140700: PPOPN 6
140702: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
140703: LD_INT 0
140705: PPUSH
// begin if not units then
140706: LD_VAR 0 1
140710: NOT
140711: IFFALSE 140715
// exit ;
140713: GO 140715
// end ;
140715: PPOPN 7
140717: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
140718: CALL 112548 0 0
// end ;
140722: PPOPN 1
140724: END
