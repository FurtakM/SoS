// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35419 0 0
// InitNature ;
  19: CALL 35287 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10934 0 0
// PrepareRussian ;
  40: CALL 6977 0 0
// PrepareLegion ;
  44: CALL 4166 0 0
// PreparePowell ;
  48: CALL 2899 0 0
// PrepareAmerican ;
  52: CALL 1671 0 0
// Action ;
  56: CALL 14970 0 0
// MC_Start ( ) ;
  60: CALL 37584 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 121
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 122
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 60329 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 60422 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 59772 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 59587 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 60329 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 60422 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 59587 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 59772 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 60202 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 14
 894: PUSH
 895: LD_INT 15
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 59269 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 60329 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 60422 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 126
 959: PUSH
 960: LD_EXP 126
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_INT 88
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PPUSH
1083: CALL 59587 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 10
1092: PUSH
1093: LD_INT 12
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: PPUSH
1100: CALL 60329 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1104: LD_INT 4
1106: PPUSH
1107: LD_INT 9
1109: PUSH
1110: EMPTY
1111: LIST
1112: PPUSH
1113: CALL 60422 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1117: LD_INT 4
1119: PPUSH
1120: LD_INT 26
1122: PUSH
1123: LD_INT 74
1125: PUSH
1126: LD_INT 107
1128: PUSH
1129: LD_INT 0
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 32
1140: PUSH
1141: LD_INT 77
1143: PUSH
1144: LD_INT 101
1146: PUSH
1147: LD_INT 4
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: LD_INT 32
1158: PUSH
1159: LD_INT 69
1161: PUSH
1162: LD_INT 86
1164: PUSH
1165: LD_INT 4
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: PUSH
1174: LD_INT 27
1176: PUSH
1177: LD_INT 77
1179: PUSH
1180: LD_INT 110
1182: PUSH
1183: LD_INT 3
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: LIST
1190: LIST
1191: PUSH
1192: LD_INT 27
1194: PUSH
1195: LD_INT 42
1197: PUSH
1198: LD_INT 79
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: PUSH
1210: LD_INT 29
1212: PUSH
1213: LD_INT 86
1215: PUSH
1216: LD_INT 105
1218: PUSH
1219: LD_INT 2
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: PUSH
1228: LD_INT 30
1230: PUSH
1231: LD_INT 40
1233: PUSH
1234: LD_INT 75
1236: PUSH
1237: LD_INT 1
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_INT 32
1248: PUSH
1249: LD_INT 80
1251: PUSH
1252: LD_INT 106
1254: PUSH
1255: LD_INT 4
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: PUSH
1264: LD_INT 32
1266: PUSH
1267: LD_INT 75
1269: PUSH
1270: LD_INT 114
1272: PUSH
1273: LD_INT 5
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: PUSH
1282: LD_INT 4
1284: PUSH
1285: LD_INT 39
1287: PUSH
1288: LD_INT 61
1290: PUSH
1291: LD_INT 3
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PPUSH
1312: CALL 59479 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1316: LD_INT 4
1318: PPUSH
1319: LD_INT 5
1321: PUSH
1322: LD_INT 6
1324: PUSH
1325: LD_INT 7
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: PPUSH
1333: CALL 60740 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1337: LD_INT 4
1339: PPUSH
1340: LD_INT 40
1342: PUSH
1343: LD_INT 75
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: LIST
1353: PUSH
1354: LD_INT 86
1356: PUSH
1357: LD_INT 105
1359: PUSH
1360: LD_INT 0
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: PPUSH
1372: CALL 59911 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1376: LD_INT 4
1378: PPUSH
1379: LD_INT 2
1381: PPUSH
1382: CALL 60202 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1386: LD_INT 4
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL 60202 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1396: LD_INT 4
1398: PPUSH
1399: LD_INT 54
1401: PPUSH
1402: LD_INT 85
1404: PPUSH
1405: LD_INT 2
1407: PPUSH
1408: LD_INT 19
1410: PUSH
1411: LD_INT 16
1413: PUSH
1414: LD_INT 17
1416: PUSH
1417: LD_INT 18
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: PPUSH
1426: CALL 60534 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 3
1435: PUSH
1436: LD_INT 1
1438: PUSH
1439: LD_INT 1
1441: PUSH
1442: LD_INT 5
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: PUSH
1451: LD_INT 4
1453: PUSH
1454: LD_INT 1
1456: PUSH
1457: LD_INT 1
1459: PUSH
1460: LD_INT 6
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 1
1477: PUSH
1478: LD_INT 7
1480: PUSH
1481: EMPTY
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: PUSH
1487: LD_INT 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 1
1495: PUSH
1496: LD_INT 6
1498: PUSH
1499: EMPTY
1500: LIST
1501: LIST
1502: LIST
1503: LIST
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: LIST
1509: LIST
1510: PPUSH
1511: CALL 59587 0 2
// MC_SetTame ( 4 , powellApe ) ;
1515: LD_INT 4
1517: PPUSH
1518: LD_INT 13
1520: PPUSH
1521: CALL 60153 0 2
// end ;
1525: LD_VAR 0 1
1529: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1530: LD_EXP 36
1534: PUSH
1535: LD_EXP 17
1539: PUSH
1540: LD_INT 2
1542: GREATEREQUAL
1543: AND
1544: IFFALSE 1556
1546: GO 1548
1548: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1549: LD_STRING ACH_POWELL
1551: PPUSH
1552: CALL_OW 543
1556: END
// every 0 0$1 trigger debug do var i , tmp ;
1557: LD_EXP 1
1561: IFFALSE 1668
1563: GO 1565
1565: DISABLE
1566: LD_INT 0
1568: PPUSH
1569: PPUSH
// begin enable ;
1570: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1571: LD_ADDR_VAR 0 2
1575: PUSH
1576: LD_INT 22
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 3
1588: PUSH
1589: LD_INT 21
1591: PUSH
1592: LD_INT 3
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: PUSH
1603: LD_INT 3
1605: PUSH
1606: LD_INT 24
1608: PUSH
1609: LD_INT 999
1611: PUSH
1612: EMPTY
1613: LIST
1614: LIST
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PPUSH
1625: CALL_OW 69
1629: ST_TO_ADDR
// if not tmp then
1630: LD_VAR 0 2
1634: NOT
1635: IFFALSE 1639
// exit ;
1637: GO 1668
// for i in tmp do
1639: LD_ADDR_VAR 0 1
1643: PUSH
1644: LD_VAR 0 2
1648: PUSH
1649: FOR_IN
1650: IFFALSE 1666
// SetLives ( i , 1000 ) ;
1652: LD_VAR 0 1
1656: PPUSH
1657: LD_INT 1000
1659: PPUSH
1660: CALL_OW 234
1664: GO 1649
1666: POP
1667: POP
// end ; end_of_file
1668: PPOPN 2
1670: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1671: LD_INT 0
1673: PPUSH
// uc_side := 1 ;
1674: LD_ADDR_OWVAR 20
1678: PUSH
1679: LD_INT 1
1681: ST_TO_ADDR
// uc_nation := 1 ;
1682: LD_ADDR_OWVAR 21
1686: PUSH
1687: LD_INT 1
1689: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1690: LD_ADDR_EXP 39
1694: PUSH
1695: LD_STRING JMM
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 14_
1706: PPUSH
1707: CALL 66023 0 3
1711: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1712: LD_EXP 4
1716: NOT
1717: PUSH
1718: LD_EXP 4
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PUSH
1727: LD_INT 1
1729: ARRAY
1730: NOT
1731: OR
1732: IFFALSE 1755
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1734: LD_INT 5
1736: PPUSH
1737: LD_INT 3
1739: PPUSH
1740: LD_INT 1
1742: PPUSH
1743: LD_INT 9
1745: PPUSH
1746: LD_INT 100
1748: PPUSH
1749: CALL 71038 0 5
1753: GO 1814
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1755: LD_EXP 4
1759: PUSH
1760: LD_INT 1
1762: ARRAY
1763: PUSH
1764: LD_INT 1
1766: ARRAY
1767: PPUSH
1768: LD_EXP 4
1772: PUSH
1773: LD_INT 2
1775: ARRAY
1776: PUSH
1777: LD_INT 1
1779: ARRAY
1780: PPUSH
1781: LD_EXP 4
1785: PUSH
1786: LD_INT 3
1788: ARRAY
1789: PUSH
1790: LD_INT 1
1792: ARRAY
1793: PPUSH
1794: LD_EXP 4
1798: PUSH
1799: LD_INT 4
1801: ARRAY
1802: PUSH
1803: LD_INT 1
1805: ARRAY
1806: PPUSH
1807: LD_INT 30
1809: PPUSH
1810: CALL 71038 0 5
// JMMNewVeh := CreateVehicle ;
1814: LD_ADDR_EXP 56
1818: PUSH
1819: CALL_OW 45
1823: ST_TO_ADDR
// if not JMMNewVeh then
1824: LD_EXP 56
1828: NOT
1829: IFFALSE 1860
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1831: LD_INT 5
1833: PPUSH
1834: LD_INT 3
1836: PPUSH
1837: LD_INT 1
1839: PPUSH
1840: LD_INT 9
1842: PPUSH
1843: LD_INT 100
1845: PPUSH
1846: CALL 71038 0 5
// JMMNewVeh := CreateVehicle ;
1850: LD_ADDR_EXP 56
1854: PUSH
1855: CALL_OW 45
1859: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1860: LD_EXP 56
1864: PPUSH
1865: LD_INT 4
1867: PPUSH
1868: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1872: LD_EXP 56
1876: PPUSH
1877: LD_INT 79
1879: PPUSH
1880: LD_INT 91
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1890: LD_EXP 39
1894: PPUSH
1895: LD_EXP 56
1899: PPUSH
1900: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1904: LD_EXP 6
1908: PUSH
1909: LD_EXP 2
1913: NOT
1914: AND
1915: IFFALSE 2173
// begin if not JMMGirlVeh then
1917: LD_EXP 5
1921: NOT
1922: IFFALSE 1945
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1924: LD_INT 3
1926: PPUSH
1927: LD_INT 3
1929: PPUSH
1930: LD_INT 1
1932: PPUSH
1933: LD_INT 9
1935: PPUSH
1936: LD_INT 100
1938: PPUSH
1939: CALL 71038 0 5
1943: GO 2004
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1945: LD_EXP 5
1949: PUSH
1950: LD_INT 1
1952: ARRAY
1953: PUSH
1954: LD_INT 1
1956: ARRAY
1957: PPUSH
1958: LD_EXP 5
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_EXP 5
1975: PUSH
1976: LD_INT 3
1978: ARRAY
1979: PUSH
1980: LD_INT 1
1982: ARRAY
1983: PPUSH
1984: LD_EXP 5
1988: PUSH
1989: LD_INT 4
1991: ARRAY
1992: PUSH
1993: LD_INT 1
1995: ARRAY
1996: PPUSH
1997: LD_INT 30
1999: PPUSH
2000: CALL 71038 0 5
// GirlNewVeh := CreateVehicle ;
2004: LD_ADDR_EXP 57
2008: PUSH
2009: CALL_OW 45
2013: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2014: LD_EXP 57
2018: PPUSH
2019: LD_INT 4
2021: PPUSH
2022: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2026: LD_EXP 57
2030: PPUSH
2031: LD_INT 82
2033: PPUSH
2034: LD_INT 96
2036: PPUSH
2037: LD_INT 0
2039: PPUSH
2040: CALL_OW 48
// if JMMGirl = 1 then
2044: LD_EXP 7
2048: PUSH
2049: LD_INT 1
2051: EQUAL
2052: IFFALSE 2087
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2054: LD_ADDR_EXP 40
2058: PUSH
2059: LD_STRING Joan
2061: PPUSH
2062: LD_INT 1
2064: PPUSH
2065: LD_STRING 14_
2067: PPUSH
2068: CALL 66023 0 3
2072: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2073: LD_EXP 40
2077: PPUSH
2078: LD_EXP 57
2082: PPUSH
2083: CALL_OW 52
// end ; if JMMGirl = 2 then
2087: LD_EXP 7
2091: PUSH
2092: LD_INT 2
2094: EQUAL
2095: IFFALSE 2130
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2097: LD_ADDR_EXP 42
2101: PUSH
2102: LD_STRING Lisa
2104: PPUSH
2105: LD_INT 1
2107: PPUSH
2108: LD_STRING 14_
2110: PPUSH
2111: CALL 66023 0 3
2115: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2116: LD_EXP 42
2120: PPUSH
2121: LD_EXP 57
2125: PPUSH
2126: CALL_OW 52
// end ; if JMMGirl = 3 then
2130: LD_EXP 7
2134: PUSH
2135: LD_INT 3
2137: EQUAL
2138: IFFALSE 2173
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2140: LD_ADDR_EXP 54
2144: PUSH
2145: LD_STRING Connie
2147: PPUSH
2148: LD_INT 1
2150: PPUSH
2151: LD_STRING 14_
2153: PPUSH
2154: CALL 66023 0 3
2158: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2159: LD_EXP 54
2163: PPUSH
2164: LD_EXP 57
2168: PPUSH
2169: CALL_OW 52
// end ; end ; end ;
2173: LD_VAR 0 1
2177: RET
// export function PrepareStevensSquad ; var tmp ; begin
2178: LD_INT 0
2180: PPUSH
2181: PPUSH
// uc_side := 1 ;
2182: LD_ADDR_OWVAR 20
2186: PUSH
2187: LD_INT 1
2189: ST_TO_ADDR
// uc_nation := 1 ;
2190: LD_ADDR_OWVAR 21
2194: PUSH
2195: LD_INT 1
2197: ST_TO_ADDR
// tmp := [ ] ;
2198: LD_ADDR_VAR 0 2
2202: PUSH
2203: EMPTY
2204: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2205: LD_ADDR_EXP 41
2209: PUSH
2210: LD_STRING Stevens
2212: PPUSH
2213: LD_EXP 1
2217: NOT
2218: PPUSH
2219: LD_STRING 13f_
2221: PPUSH
2222: CALL 66023 0 3
2226: ST_TO_ADDR
// if not Stevens then
2227: LD_EXP 41
2231: NOT
2232: IFFALSE 2288
// begin hc_name = Baker Smith ;
2234: LD_ADDR_OWVAR 26
2238: PUSH
2239: LD_STRING Baker Smith
2241: ST_TO_ADDR
// hc_gallery =  ;
2242: LD_ADDR_OWVAR 33
2246: PUSH
2247: LD_STRING 
2249: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2250: LD_INT 1
2252: PPUSH
2253: LD_INT 10
2255: PPUSH
2256: CALL_OW 384
// Baker = CreateHuman ;
2260: LD_ADDR_EXP 55
2264: PUSH
2265: CALL_OW 44
2269: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 55
2284: ADD
2285: ST_TO_ADDR
// end else
2286: GO 2304
// tmp := tmp ^ Stevens ;
2288: LD_ADDR_VAR 0 2
2292: PUSH
2293: LD_VAR 0 2
2297: PUSH
2298: LD_EXP 41
2302: ADD
2303: ST_TO_ADDR
// if not Lisa then
2304: LD_EXP 42
2308: NOT
2309: IFFALSE 2355
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2311: LD_ADDR_EXP 42
2315: PUSH
2316: LD_STRING Lisa
2318: PPUSH
2319: LD_EXP 1
2323: NOT
2324: PPUSH
2325: LD_STRING 13f_
2327: PPUSH
2328: CALL 66023 0 3
2332: ST_TO_ADDR
// if Lisa then
2333: LD_EXP 42
2337: IFFALSE 2355
// tmp := tmp ^ Lisa ;
2339: LD_ADDR_VAR 0 2
2343: PUSH
2344: LD_VAR 0 2
2348: PUSH
2349: LD_EXP 42
2353: ADD
2354: ST_TO_ADDR
// end ; if not Donaldson then
2355: LD_EXP 43
2359: NOT
2360: IFFALSE 2406
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2362: LD_ADDR_EXP 43
2366: PUSH
2367: LD_STRING Donaldson
2369: PPUSH
2370: LD_EXP 1
2374: NOT
2375: PPUSH
2376: LD_STRING 13f_
2378: PPUSH
2379: CALL 66023 0 3
2383: ST_TO_ADDR
// if Donaldson then
2384: LD_EXP 43
2388: IFFALSE 2406
// tmp := tmp ^ Donaldson ;
2390: LD_ADDR_VAR 0 2
2394: PUSH
2395: LD_VAR 0 2
2399: PUSH
2400: LD_EXP 43
2404: ADD
2405: ST_TO_ADDR
// end ; if not Bobby then
2406: LD_EXP 44
2410: NOT
2411: IFFALSE 2457
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2413: LD_ADDR_EXP 44
2417: PUSH
2418: LD_STRING Bobby
2420: PPUSH
2421: LD_EXP 1
2425: NOT
2426: PPUSH
2427: LD_STRING 13f_
2429: PPUSH
2430: CALL 66023 0 3
2434: ST_TO_ADDR
// if Bobby then
2435: LD_EXP 44
2439: IFFALSE 2457
// tmp := tmp ^ Bobby ;
2441: LD_ADDR_VAR 0 2
2445: PUSH
2446: LD_VAR 0 2
2450: PUSH
2451: LD_EXP 44
2455: ADD
2456: ST_TO_ADDR
// end ; if not Cyrus then
2457: LD_EXP 45
2461: NOT
2462: IFFALSE 2508
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2464: LD_ADDR_EXP 45
2468: PUSH
2469: LD_STRING Cyrus
2471: PPUSH
2472: LD_EXP 1
2476: NOT
2477: PPUSH
2478: LD_STRING 13f_
2480: PPUSH
2481: CALL 66023 0 3
2485: ST_TO_ADDR
// if Cyrus then
2486: LD_EXP 45
2490: IFFALSE 2508
// tmp := tmp ^ Cyrus ;
2492: LD_ADDR_VAR 0 2
2496: PUSH
2497: LD_VAR 0 2
2501: PUSH
2502: LD_EXP 45
2506: ADD
2507: ST_TO_ADDR
// end ; if not Brown then
2508: LD_EXP 47
2512: NOT
2513: IFFALSE 2559
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2515: LD_ADDR_EXP 47
2519: PUSH
2520: LD_STRING Brown
2522: PPUSH
2523: LD_EXP 1
2527: NOT
2528: PPUSH
2529: LD_STRING 13f_
2531: PPUSH
2532: CALL 66023 0 3
2536: ST_TO_ADDR
// if Brown then
2537: LD_EXP 47
2541: IFFALSE 2559
// tmp := tmp ^ Brown ;
2543: LD_ADDR_VAR 0 2
2547: PUSH
2548: LD_VAR 0 2
2552: PUSH
2553: LD_EXP 47
2557: ADD
2558: ST_TO_ADDR
// end ; if not Gladstone then
2559: LD_EXP 48
2563: NOT
2564: IFFALSE 2610
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2566: LD_ADDR_EXP 48
2570: PUSH
2571: LD_STRING Gladstone
2573: PPUSH
2574: LD_EXP 1
2578: NOT
2579: PPUSH
2580: LD_STRING 13f_
2582: PPUSH
2583: CALL 66023 0 3
2587: ST_TO_ADDR
// if Gladstone then
2588: LD_EXP 48
2592: IFFALSE 2610
// tmp := tmp ^ Gladstone ;
2594: LD_ADDR_VAR 0 2
2598: PUSH
2599: LD_VAR 0 2
2603: PUSH
2604: LD_EXP 48
2608: ADD
2609: ST_TO_ADDR
// end ; if not Houten then
2610: LD_EXP 49
2614: NOT
2615: IFFALSE 2661
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2617: LD_ADDR_EXP 49
2621: PUSH
2622: LD_STRING Houten
2624: PPUSH
2625: LD_EXP 1
2629: NOT
2630: PPUSH
2631: LD_STRING 13f_
2633: PPUSH
2634: CALL 66023 0 3
2638: ST_TO_ADDR
// if Houten then
2639: LD_EXP 49
2643: IFFALSE 2661
// tmp := tmp ^ Houten ;
2645: LD_ADDR_VAR 0 2
2649: PUSH
2650: LD_VAR 0 2
2654: PUSH
2655: LD_EXP 49
2659: ADD
2660: ST_TO_ADDR
// end ; if not Cornel then
2661: LD_EXP 50
2665: NOT
2666: IFFALSE 2712
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2668: LD_ADDR_EXP 50
2672: PUSH
2673: LD_STRING Cornell
2675: PPUSH
2676: LD_EXP 1
2680: NOT
2681: PPUSH
2682: LD_STRING 13f_
2684: PPUSH
2685: CALL 66023 0 3
2689: ST_TO_ADDR
// if Cornel then
2690: LD_EXP 50
2694: IFFALSE 2712
// tmp := tmp ^ Cornel ;
2696: LD_ADDR_VAR 0 2
2700: PUSH
2701: LD_VAR 0 2
2705: PUSH
2706: LD_EXP 50
2710: ADD
2711: ST_TO_ADDR
// end ; if not Gary then
2712: LD_EXP 51
2716: NOT
2717: IFFALSE 2763
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2719: LD_ADDR_EXP 51
2723: PUSH
2724: LD_STRING Gary
2726: PPUSH
2727: LD_EXP 1
2731: NOT
2732: PPUSH
2733: LD_STRING 13f_
2735: PPUSH
2736: CALL 66023 0 3
2740: ST_TO_ADDR
// if Gary then
2741: LD_EXP 51
2745: IFFALSE 2763
// tmp := tmp ^ Gary ;
2747: LD_ADDR_VAR 0 2
2751: PUSH
2752: LD_VAR 0 2
2756: PUSH
2757: LD_EXP 51
2761: ADD
2762: ST_TO_ADDR
// end ; if not Frank then
2763: LD_EXP 52
2767: NOT
2768: IFFALSE 2814
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2770: LD_ADDR_EXP 52
2774: PUSH
2775: LD_STRING Frank
2777: PPUSH
2778: LD_EXP 1
2782: NOT
2783: PPUSH
2784: LD_STRING 13f_
2786: PPUSH
2787: CALL 66023 0 3
2791: ST_TO_ADDR
// if Frank then
2792: LD_EXP 52
2796: IFFALSE 2814
// tmp := tmp ^ Frank ;
2798: LD_ADDR_VAR 0 2
2802: PUSH
2803: LD_VAR 0 2
2807: PUSH
2808: LD_EXP 52
2812: ADD
2813: ST_TO_ADDR
// end ; if not Kikuchi then
2814: LD_EXP 53
2818: NOT
2819: IFFALSE 2865
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2821: LD_ADDR_EXP 53
2825: PUSH
2826: LD_STRING Kikuchi
2828: PPUSH
2829: LD_EXP 1
2833: NOT
2834: PPUSH
2835: LD_STRING 13f_
2837: PPUSH
2838: CALL 66023 0 3
2842: ST_TO_ADDR
// if Kikuchi then
2843: LD_EXP 53
2847: IFFALSE 2865
// tmp := tmp ^ Kikuchi ;
2849: LD_ADDR_VAR 0 2
2853: PUSH
2854: LD_VAR 0 2
2858: PUSH
2859: LD_EXP 53
2863: ADD
2864: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2865: LD_ADDR_VAR 0 2
2869: PUSH
2870: LD_VAR 0 2
2874: PUSH
2875: LD_STRING 13_other_survivors
2877: PPUSH
2878: CALL_OW 31
2882: UNION
2883: ST_TO_ADDR
// result := tmp ;
2884: LD_ADDR_VAR 0 1
2888: PUSH
2889: LD_VAR 0 2
2893: ST_TO_ADDR
// end ; end_of_file
2894: LD_VAR 0 1
2898: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2899: LD_INT 0
2901: PPUSH
2902: PPUSH
2903: PPUSH
2904: PPUSH
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
// uc_side := 4 ;
2911: LD_ADDR_OWVAR 20
2915: PUSH
2916: LD_INT 4
2918: ST_TO_ADDR
// uc_nation := 1 ;
2919: LD_ADDR_OWVAR 21
2923: PUSH
2924: LD_INT 1
2926: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2927: LD_INT 387
2929: PPUSH
2930: CALL_OW 274
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 3500
2940: PUSH
2941: LD_INT 3000
2943: PUSH
2944: LD_INT 2500
2946: PUSH
2947: LD_INT 2000
2949: PUSH
2950: EMPTY
2951: LIST
2952: LIST
2953: LIST
2954: LIST
2955: PUSH
2956: LD_OWVAR 67
2960: ARRAY
2961: PPUSH
2962: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2966: LD_INT 387
2968: PPUSH
2969: CALL_OW 274
2973: PPUSH
2974: LD_INT 2
2976: PPUSH
2977: LD_INT 400
2979: PPUSH
2980: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2984: LD_INT 387
2986: PPUSH
2987: CALL_OW 274
2991: PPUSH
2992: LD_INT 3
2994: PPUSH
2995: LD_INT 10
2997: PPUSH
2998: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3002: LD_ADDR_EXP 58
3006: PUSH
3007: LD_STRING Powell
3009: PPUSH
3010: CALL_OW 25
3014: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3015: LD_EXP 58
3019: PPUSH
3020: LD_INT 57
3022: PPUSH
3023: LD_INT 94
3025: PPUSH
3026: LD_INT 0
3028: PPUSH
3029: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3033: LD_EXP 58
3037: PPUSH
3038: LD_INT 58
3040: PPUSH
3041: LD_INT 94
3043: PPUSH
3044: CALL_OW 118
// vip := [ ] ;
3048: LD_ADDR_EXP 59
3052: PUSH
3053: EMPTY
3054: ST_TO_ADDR
// tmp := [ ] ;
3055: LD_ADDR_VAR 0 6
3059: PUSH
3060: EMPTY
3061: ST_TO_ADDR
// if JMMGirl <> 2 then
3062: LD_EXP 7
3066: PUSH
3067: LD_INT 2
3069: NONEQUAL
3070: IFFALSE 3094
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3072: LD_ADDR_EXP 42
3076: PUSH
3077: LD_STRING Lisa
3079: PPUSH
3080: LD_EXP 1
3084: NOT
3085: PPUSH
3086: LD_STRING 13s_
3088: PPUSH
3089: CALL 66023 0 3
3093: ST_TO_ADDR
// if Lisa then
3094: LD_EXP 42
3098: IFFALSE 3116
// tmp := tmp ^ Lisa ;
3100: LD_ADDR_VAR 0 6
3104: PUSH
3105: LD_VAR 0 6
3109: PUSH
3110: LD_EXP 42
3114: ADD
3115: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3116: LD_ADDR_EXP 43
3120: PUSH
3121: LD_STRING Donaldson
3123: PPUSH
3124: LD_EXP 1
3128: NOT
3129: PPUSH
3130: LD_STRING 13s_
3132: PPUSH
3133: CALL 66023 0 3
3137: ST_TO_ADDR
// if Donaldson then
3138: LD_EXP 43
3142: IFFALSE 3160
// tmp := tmp ^ Donaldson ;
3144: LD_ADDR_VAR 0 6
3148: PUSH
3149: LD_VAR 0 6
3153: PUSH
3154: LD_EXP 43
3158: ADD
3159: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3160: LD_ADDR_EXP 44
3164: PUSH
3165: LD_STRING Bobby
3167: PPUSH
3168: LD_EXP 1
3172: NOT
3173: PPUSH
3174: LD_STRING 13s_
3176: PPUSH
3177: CALL 66023 0 3
3181: ST_TO_ADDR
// if Bobby then
3182: LD_EXP 44
3186: IFFALSE 3204
// tmp := tmp ^ Bobby ;
3188: LD_ADDR_VAR 0 6
3192: PUSH
3193: LD_VAR 0 6
3197: PUSH
3198: LD_EXP 44
3202: ADD
3203: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3204: LD_ADDR_EXP 45
3208: PUSH
3209: LD_STRING Cyrus
3211: PPUSH
3212: LD_EXP 1
3216: NOT
3217: PPUSH
3218: LD_STRING 13s_
3220: PPUSH
3221: CALL 66023 0 3
3225: ST_TO_ADDR
// if Cyrus then
3226: LD_EXP 45
3230: IFFALSE 3248
// tmp := tmp ^ Cyrus ;
3232: LD_ADDR_VAR 0 6
3236: PUSH
3237: LD_VAR 0 6
3241: PUSH
3242: LD_EXP 45
3246: ADD
3247: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3248: LD_ADDR_EXP 46
3252: PUSH
3253: LD_STRING Denis
3255: PPUSH
3256: LD_EXP 1
3260: NOT
3261: PPUSH
3262: LD_STRING 13s_
3264: PPUSH
3265: CALL 66023 0 3
3269: ST_TO_ADDR
// if not Denis then
3270: LD_EXP 46
3274: NOT
3275: IFFALSE 3299
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3277: LD_ADDR_EXP 46
3281: PUSH
3282: LD_STRING Denis
3284: PPUSH
3285: LD_EXP 1
3289: NOT
3290: PPUSH
3291: LD_STRING 13f_
3293: PPUSH
3294: CALL 66023 0 3
3298: ST_TO_ADDR
// if Denis then
3299: LD_EXP 46
3303: IFFALSE 3321
// tmp := tmp ^ Denis ;
3305: LD_ADDR_VAR 0 6
3309: PUSH
3310: LD_VAR 0 6
3314: PUSH
3315: LD_EXP 46
3319: ADD
3320: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3321: LD_ADDR_EXP 47
3325: PUSH
3326: LD_STRING Brown
3328: PPUSH
3329: LD_EXP 1
3333: NOT
3334: PPUSH
3335: LD_STRING 13s_
3337: PPUSH
3338: CALL 66023 0 3
3342: ST_TO_ADDR
// if Brown then
3343: LD_EXP 47
3347: IFFALSE 3365
// tmp := tmp ^ Brown ;
3349: LD_ADDR_VAR 0 6
3353: PUSH
3354: LD_VAR 0 6
3358: PUSH
3359: LD_EXP 47
3363: ADD
3364: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3365: LD_ADDR_EXP 48
3369: PUSH
3370: LD_STRING Gladstone
3372: PPUSH
3373: LD_EXP 1
3377: NOT
3378: PPUSH
3379: LD_STRING 13s_
3381: PPUSH
3382: CALL 66023 0 3
3386: ST_TO_ADDR
// if Gladstone then
3387: LD_EXP 48
3391: IFFALSE 3409
// tmp := tmp ^ Gladstone ;
3393: LD_ADDR_VAR 0 6
3397: PUSH
3398: LD_VAR 0 6
3402: PUSH
3403: LD_EXP 48
3407: ADD
3408: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3409: LD_ADDR_EXP 49
3413: PUSH
3414: LD_STRING Houten
3416: PPUSH
3417: LD_EXP 1
3421: NOT
3422: PPUSH
3423: LD_STRING 13s_
3425: PPUSH
3426: CALL 66023 0 3
3430: ST_TO_ADDR
// if Houten then
3431: LD_EXP 49
3435: IFFALSE 3453
// tmp := tmp ^ Houten ;
3437: LD_ADDR_VAR 0 6
3441: PUSH
3442: LD_VAR 0 6
3446: PUSH
3447: LD_EXP 49
3451: ADD
3452: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3453: LD_ADDR_EXP 50
3457: PUSH
3458: LD_STRING Cornel
3460: PPUSH
3461: LD_EXP 1
3465: NOT
3466: PPUSH
3467: LD_STRING 13s_
3469: PPUSH
3470: CALL 66023 0 3
3474: ST_TO_ADDR
// if Cornel then
3475: LD_EXP 50
3479: IFFALSE 3497
// tmp := tmp ^ Cornel ;
3481: LD_ADDR_VAR 0 6
3485: PUSH
3486: LD_VAR 0 6
3490: PUSH
3491: LD_EXP 50
3495: ADD
3496: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3497: LD_ADDR_EXP 51
3501: PUSH
3502: LD_STRING Gary
3504: PPUSH
3505: LD_EXP 1
3509: NOT
3510: PPUSH
3511: LD_STRING 13s_
3513: PPUSH
3514: CALL 66023 0 3
3518: ST_TO_ADDR
// if Gary then
3519: LD_EXP 51
3523: IFFALSE 3541
// tmp := tmp ^ Gary ;
3525: LD_ADDR_VAR 0 6
3529: PUSH
3530: LD_VAR 0 6
3534: PUSH
3535: LD_EXP 51
3539: ADD
3540: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3541: LD_ADDR_EXP 52
3545: PUSH
3546: LD_STRING Frank
3548: PPUSH
3549: LD_EXP 1
3553: NOT
3554: PPUSH
3555: LD_STRING 13s_
3557: PPUSH
3558: CALL 66023 0 3
3562: ST_TO_ADDR
// if Frank then
3563: LD_EXP 52
3567: IFFALSE 3585
// tmp := tmp ^ Frank ;
3569: LD_ADDR_VAR 0 6
3573: PUSH
3574: LD_VAR 0 6
3578: PUSH
3579: LD_EXP 52
3583: ADD
3584: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3585: LD_ADDR_EXP 53
3589: PUSH
3590: LD_STRING Kikuchi
3592: PPUSH
3593: LD_EXP 1
3597: NOT
3598: PPUSH
3599: LD_STRING 13s_
3601: PPUSH
3602: CALL 66023 0 3
3606: ST_TO_ADDR
// if Kikuchi then
3607: LD_EXP 53
3611: IFFALSE 3629
// tmp := tmp ^ Kikuchi ;
3613: LD_ADDR_VAR 0 6
3617: PUSH
3618: LD_VAR 0 6
3622: PUSH
3623: LD_EXP 53
3627: ADD
3628: ST_TO_ADDR
// vip := tmp ;
3629: LD_ADDR_EXP 59
3633: PUSH
3634: LD_VAR 0 6
3638: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3639: LD_ADDR_VAR 0 6
3643: PUSH
3644: LD_VAR 0 6
3648: PUSH
3649: LD_STRING 13s_others
3651: PPUSH
3652: CALL_OW 31
3656: UNION
3657: ST_TO_ADDR
// if tmp < 22 then
3658: LD_VAR 0 6
3662: PUSH
3663: LD_INT 22
3665: LESS
3666: IFFALSE 3733
// for i = 1 to 22 - tmp do
3668: LD_ADDR_VAR 0 2
3672: PUSH
3673: DOUBLE
3674: LD_INT 1
3676: DEC
3677: ST_TO_ADDR
3678: LD_INT 22
3680: PUSH
3681: LD_VAR 0 6
3685: MINUS
3686: PUSH
3687: FOR_TO
3688: IFFALSE 3731
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3690: LD_INT 1
3692: PPUSH
3693: LD_VAR 0 2
3697: PUSH
3698: LD_INT 4
3700: MOD
3701: PUSH
3702: LD_INT 1
3704: PLUS
3705: PPUSH
3706: LD_INT 4
3708: PPUSH
3709: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3713: LD_ADDR_VAR 0 6
3717: PUSH
3718: LD_VAR 0 6
3722: PUSH
3723: CALL_OW 44
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3687
3731: POP
3732: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3733: LD_ADDR_VAR 0 7
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 4
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: LD_INT 30
3750: PUSH
3751: LD_INT 0
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PPUSH
3762: CALL_OW 69
3766: PUSH
3767: LD_INT 1
3769: ARRAY
3770: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3771: LD_ADDR_VAR 0 8
3775: PUSH
3776: LD_INT 22
3778: PUSH
3779: LD_INT 4
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PUSH
3786: LD_INT 30
3788: PUSH
3789: LD_INT 6
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PPUSH
3800: CALL_OW 69
3804: PUSH
3805: LD_INT 1
3807: ARRAY
3808: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3809: LD_ADDR_VAR 0 9
3813: PUSH
3814: LD_INT 22
3816: PUSH
3817: LD_INT 4
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 30
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PPUSH
3838: CALL_OW 69
3842: PUSH
3843: LD_INT 1
3845: ARRAY
3846: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3847: LD_ADDR_VAR 0 10
3851: PUSH
3852: LD_INT 22
3854: PUSH
3855: LD_INT 4
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: PUSH
3862: LD_INT 30
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PPUSH
3876: CALL_OW 69
3880: PUSH
3881: LD_INT 1
3883: ARRAY
3884: ST_TO_ADDR
// for i in tmp do
3885: LD_ADDR_VAR 0 2
3889: PUSH
3890: LD_VAR 0 6
3894: PUSH
3895: FOR_IN
3896: IFFALSE 4022
// begin cl := GetClass ( i ) ;
3898: LD_ADDR_VAR 0 5
3902: PUSH
3903: LD_VAR 0 2
3907: PPUSH
3908: CALL_OW 257
3912: ST_TO_ADDR
// if cl > 4 then
3913: LD_VAR 0 5
3917: PUSH
3918: LD_INT 4
3920: GREATER
3921: IFFALSE 3931
// cl := 1 ;
3923: LD_ADDR_VAR 0 5
3927: PUSH
3928: LD_INT 1
3930: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3931: LD_ADDR_VAR 0 3
3935: PUSH
3936: LD_VAR 0 9
3940: PUSH
3941: LD_VAR 0 7
3945: PUSH
3946: LD_VAR 0 10
3950: PUSH
3951: LD_VAR 0 8
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: LIST
3960: LIST
3961: PUSH
3962: LD_VAR 0 5
3966: ARRAY
3967: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
3968: LD_VAR 0 3
3972: PPUSH
3973: CALL_OW 313
3977: PUSH
3978: LD_INT 6
3980: LESS
3981: IFFALSE 3999
// PlaceHumanInUnit ( i , b ) else
3983: LD_VAR 0 2
3987: PPUSH
3988: LD_VAR 0 3
3992: PPUSH
3993: CALL_OW 52
3997: GO 4020
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
3999: LD_VAR 0 2
4003: PPUSH
4004: LD_INT 61
4006: PPUSH
4007: LD_INT 89
4009: PPUSH
4010: LD_INT 8
4012: PPUSH
4013: LD_INT 0
4015: PPUSH
4016: CALL_OW 50
// end ;
4020: GO 3895
4022: POP
4023: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4024: LD_INT 2
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: LD_INT 1
4032: PPUSH
4033: LD_INT 12
4035: PPUSH
4036: LD_INT 100
4038: PPUSH
4039: CALL 71038 0 5
// veh := CreateVehicle ;
4043: LD_ADDR_VAR 0 4
4047: PUSH
4048: CALL_OW 45
4052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4053: LD_VAR 0 4
4057: PPUSH
4058: LD_INT 4
4060: PPUSH
4061: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4065: LD_VAR 0 4
4069: PPUSH
4070: LD_INT 49
4072: PPUSH
4073: LD_INT 88
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4083: LD_VAR 0 4
4087: PPUSH
4088: LD_INT 1
4090: PPUSH
4091: LD_INT 100
4093: PPUSH
4094: CALL_OW 290
// uc_side := 0 ;
4098: LD_ADDR_OWVAR 20
4102: PUSH
4103: LD_INT 0
4105: ST_TO_ADDR
// uc_nation := 0 ;
4106: LD_ADDR_OWVAR 21
4110: PUSH
4111: LD_INT 0
4113: ST_TO_ADDR
// for i := 1 to 3 do
4114: LD_ADDR_VAR 0 2
4118: PUSH
4119: DOUBLE
4120: LD_INT 1
4122: DEC
4123: ST_TO_ADDR
4124: LD_INT 3
4126: PUSH
4127: FOR_TO
4128: IFFALSE 4159
// begin InitHc ;
4130: CALL_OW 19
// hc_class := class_apeman ;
4134: LD_ADDR_OWVAR 28
4138: PUSH
4139: LD_INT 12
4141: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4142: CALL_OW 44
4146: PPUSH
4147: LD_INT 13
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 49
// end ;
4157: GO 4127
4159: POP
4160: POP
// end ; end_of_file
4161: LD_VAR 0 1
4165: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4166: LD_INT 0
4168: PPUSH
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
// side := 8 ;
4173: LD_ADDR_VAR 0 3
4177: PUSH
4178: LD_INT 8
4180: ST_TO_ADDR
// uc_side := side ;
4181: LD_ADDR_OWVAR 20
4185: PUSH
4186: LD_VAR 0 3
4190: ST_TO_ADDR
// uc_nation := 2 ;
4191: LD_ADDR_OWVAR 21
4195: PUSH
4196: LD_INT 2
4198: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4199: LD_ADDR_VAR 0 2
4203: PUSH
4204: LD_INT 22
4206: PUSH
4207: LD_VAR 0 3
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: LD_INT 21
4218: PUSH
4219: LD_INT 3
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: PPUSH
4230: CALL_OW 69
4234: PUSH
4235: FOR_IN
4236: IFFALSE 4252
// SetBLevel ( i , 10 ) ;
4238: LD_VAR 0 2
4242: PPUSH
4243: LD_INT 10
4245: PPUSH
4246: CALL_OW 241
4250: GO 4235
4252: POP
4253: POP
// if KurtStatus then
4254: LD_EXP 3
4258: IFFALSE 4281
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4260: LD_ADDR_EXP 60
4264: PUSH
4265: LD_STRING Kurt
4267: PPUSH
4268: LD_INT 0
4270: PPUSH
4271: LD_STRING 
4273: PPUSH
4274: CALL 66023 0 3
4278: ST_TO_ADDR
4279: GO 4303
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4281: LD_ADDR_EXP 60
4285: PUSH
4286: LD_STRING AltKurt
4288: PPUSH
4289: LD_EXP 1
4293: NOT
4294: PPUSH
4295: LD_STRING 
4297: PPUSH
4298: CALL 66023 0 3
4302: ST_TO_ADDR
// if not Kurt then
4303: LD_EXP 60
4307: NOT
4308: IFFALSE 4334
// begin InitHc ;
4310: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 10
4319: PPUSH
4320: CALL_OW 381
// Kurt := CreateHuman ;
4324: LD_ADDR_EXP 60
4328: PUSH
4329: CALL_OW 44
4333: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4334: LD_EXP 60
4338: PPUSH
4339: LD_INT 324
4341: PPUSH
4342: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4346: LD_ADDR_EXP 61
4350: PUSH
4351: LD_STRING Kozlov
4353: PPUSH
4354: LD_INT 0
4356: PPUSH
4357: LD_STRING 
4359: PPUSH
4360: CALL 66023 0 3
4364: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4365: LD_EXP 61
4369: PPUSH
4370: LD_INT 22
4372: PUSH
4373: LD_INT 8
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: LD_INT 23
4382: PUSH
4383: LD_INT 3
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PUSH
4390: LD_INT 30
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: PPUSH
4405: CALL_OW 69
4409: PUSH
4410: LD_INT 1
4412: ARRAY
4413: PPUSH
4414: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4418: LD_EXP 61
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 10
4428: PPUSH
4429: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: LD_INT 10
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_OWVAR 67
4661: ARRAY
4662: PPUSH
4663: LD_INT 3000
4665: PUSH
4666: LD_INT 500
4668: PUSH
4669: LD_INT 150
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: LIST
4676: PPUSH
4677: LD_INT 16
4679: PUSH
4680: LD_INT 6
4682: PUSH
4683: LD_INT 6
4685: PUSH
4686: LD_INT 8
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: LIST
4693: LIST
4694: PPUSH
4695: CALL 74482 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4699: LD_ADDR_EXP 97
4703: PUSH
4704: LD_EXP 97
4708: PPUSH
4709: LD_INT 3
4711: PPUSH
4712: LD_INT 22
4714: PUSH
4715: LD_VAR 0 3
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: PUSH
4724: LD_INT 23
4726: PUSH
4727: LD_INT 2
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 3
4736: PUSH
4737: LD_INT 21
4739: PUSH
4740: LD_INT 2
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: LIST
4755: PPUSH
4756: CALL_OW 69
4760: PUSH
4761: LD_EXP 60
4765: DIFF
4766: PPUSH
4767: CALL_OW 1
4771: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 7
4777: PPUSH
4778: CALL_OW 383
// Friend := CreateHuman ;
4782: LD_ADDR_EXP 62
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4792: LD_INT 14
4794: PPUSH
4795: LD_INT 3
4797: PPUSH
4798: LD_INT 1
4800: PPUSH
4801: LD_INT 29
4803: PPUSH
4804: LD_INT 100
4806: PPUSH
4807: CALL 71038 0 5
// powellBomb := CreateVehicle ;
4811: LD_ADDR_EXP 63
4815: PUSH
4816: CALL_OW 45
4820: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4821: LD_EXP 63
4825: PPUSH
4826: LD_INT 90
4828: PPUSH
4829: LD_INT 51
4831: PPUSH
4832: LD_INT 0
4834: PPUSH
4835: CALL_OW 48
// end ;
4839: LD_VAR 0 1
4843: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4844: LD_INT 0
4846: PPUSH
4847: PPUSH
4848: PPUSH
// if IsLive ( kozlov_fac ) then
4849: LD_INT 332
4851: PPUSH
4852: CALL_OW 300
4856: IFFALSE 4860
// exit ;
4858: GO 5427
// ComExitBuilding ( Kozlov ) ;
4860: LD_EXP 61
4864: PPUSH
4865: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4869: LD_EXP 61
4873: PPUSH
4874: CALL_OW 257
4878: PUSH
4879: LD_INT 2
4881: NONEQUAL
4882: IFFALSE 4917
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4884: LD_EXP 61
4888: PPUSH
4889: LD_INT 324
4891: PPUSH
4892: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4896: LD_EXP 61
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4917: LD_EXP 61
4921: PPUSH
4922: LD_INT 2
4924: PPUSH
4925: LD_INT 93
4927: PPUSH
4928: LD_INT 32
4930: PPUSH
4931: LD_INT 3
4933: PPUSH
4934: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4938: LD_INT 35
4940: PPUSH
4941: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4945: LD_INT 22
4947: PUSH
4948: LD_INT 8
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 30
4957: PUSH
4958: LD_INT 3
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PUSH
4965: LD_INT 23
4967: PUSH
4968: LD_INT 3
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 57
4977: PUSH
4978: EMPTY
4979: LIST
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: PPUSH
4987: CALL_OW 69
4991: IFFALSE 4938
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4993: LD_ADDR_VAR 0 2
4997: PUSH
4998: LD_INT 22
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 30
5010: PUSH
5011: LD_INT 3
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: LD_INT 23
5020: PUSH
5021: LD_INT 3
5023: PUSH
5024: EMPTY
5025: LIST
5026: LIST
5027: PUSH
5028: LD_INT 57
5030: PUSH
5031: EMPTY
5032: LIST
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5049: LD_INT 22
5051: PUSH
5052: LD_INT 8
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: LD_INT 23
5061: PUSH
5062: LD_INT 3
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 30
5071: PUSH
5072: LD_INT 21
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: LIST
5083: PPUSH
5084: CALL_OW 69
5088: NOT
5089: IFFALSE 5167
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5091: LD_EXP 61
5095: PPUSH
5096: LD_INT 21
5098: PPUSH
5099: LD_INT 97
5101: PPUSH
5102: LD_INT 36
5104: PPUSH
5105: LD_INT 5
5107: PPUSH
5108: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5112: LD_INT 35
5114: PPUSH
5115: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5119: LD_INT 22
5121: PUSH
5122: LD_INT 8
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: LD_INT 23
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PUSH
5139: LD_INT 30
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 57
5151: PUSH
5152: EMPTY
5153: LIST
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: IFFALSE 5112
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 18
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: PPUSH
5202: CALL_OW 69
5206: NOT
5207: IFFALSE 5285
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5209: LD_EXP 61
5213: PPUSH
5214: LD_INT 18
5216: PPUSH
5217: LD_INT 89
5219: PPUSH
5220: LD_INT 32
5222: PPUSH
5223: LD_INT 1
5225: PPUSH
5226: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5230: LD_INT 35
5232: PPUSH
5233: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5237: LD_INT 22
5239: PUSH
5240: LD_INT 8
5242: PUSH
5243: EMPTY
5244: LIST
5245: LIST
5246: PUSH
5247: LD_INT 23
5249: PUSH
5250: LD_INT 3
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 30
5259: PUSH
5260: LD_INT 18
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: LD_INT 57
5269: PUSH
5270: EMPTY
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: PPUSH
5279: CALL_OW 69
5283: IFFALSE 5230
// end ; lab := kozlov_lab ;
5285: LD_ADDR_VAR 0 3
5289: PUSH
5290: LD_INT 336
5292: ST_TO_ADDR
// if not lab then
5293: LD_VAR 0 3
5297: NOT
5298: IFFALSE 5302
// exit ;
5300: GO 5427
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5302: LD_EXP 61
5306: PPUSH
5307: LD_VAR 0 3
5311: PUSH
5312: LD_INT 1
5314: ARRAY
5315: PPUSH
5316: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5320: LD_EXP 61
5324: PPUSH
5325: LD_INT 4
5327: PPUSH
5328: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5332: LD_VAR 0 3
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 25
5343: PPUSH
5344: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5348: LD_INT 35
5350: PPUSH
5351: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5355: LD_INT 25
5357: PPUSH
5358: LD_INT 8
5360: PPUSH
5361: CALL_OW 321
5365: PUSH
5366: LD_INT 2
5368: EQUAL
5369: IFFALSE 5348
// ComExitBuilding ( Kozlov ) ;
5371: LD_EXP 61
5375: PPUSH
5376: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5380: LD_EXP 61
5384: PPUSH
5385: LD_VAR 0 2
5389: PPUSH
5390: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5394: LD_EXP 61
5398: PPUSH
5399: LD_INT 3
5401: PPUSH
5402: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5406: LD_VAR 0 2
5410: PPUSH
5411: LD_INT 23
5413: PPUSH
5414: LD_INT 3
5416: PPUSH
5417: LD_INT 1
5419: PPUSH
5420: LD_INT 48
5422: PPUSH
5423: CALL_OW 125
// end ;
5427: LD_VAR 0 1
5431: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5432: LD_EXP 22
5436: NOT
5437: PUSH
5438: LD_EXP 15
5442: PUSH
5443: LD_INT 6
5445: GREATEREQUAL
5446: AND
5447: IFFALSE 5528
5449: GO 5451
5451: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5452: LD_INT 3
5454: PPUSH
5455: LD_INT 3
5457: PPUSH
5458: CALL 59772 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 14
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: LD_INT 28
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 14
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 28
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL 59635 0 2
// end ;
5528: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5529: LD_EXP 22
5533: NOT
5534: PUSH
5535: LD_EXP 15
5539: PUSH
5540: LD_INT 6
5542: GREATEREQUAL
5543: AND
5544: PUSH
5545: LD_INT 3
5547: PPUSH
5548: LD_INT 1
5550: PPUSH
5551: CALL 61053 0 2
5555: NOT
5556: AND
5557: IFFALSE 6413
5559: GO 5561
5561: DISABLE
5562: LD_INT 0
5564: PPUSH
5565: PPUSH
5566: PPUSH
// begin enable ;
5567: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5568: LD_INT 22
5570: PUSH
5571: LD_INT 8
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 23
5580: PUSH
5581: LD_INT 2
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: LD_INT 30
5590: PUSH
5591: LD_INT 3
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: PPUSH
5603: CALL_OW 69
5607: NOT
5608: IFFALSE 5612
// exit ;
5610: GO 6413
// if Prob ( 40 ) then
5612: LD_INT 40
5614: PPUSH
5615: CALL_OW 13
5619: IFFALSE 5746
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 14
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 28
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 14
5644: PUSH
5645: LD_INT 1
5647: PUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 28
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 26
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: PPUSH
5740: CALL 59635 0 2
// end else
5744: GO 5953
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5746: LD_INT 3
5748: PPUSH
5749: LD_INT 14
5751: PUSH
5752: LD_INT 1
5754: PUSH
5755: LD_INT 2
5757: PUSH
5758: LD_INT 27
5760: PUSH
5761: LD_INT 26
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: LD_INT 28
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PUSH
5776: LD_OWVAR 67
5780: ARRAY
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 14
5790: PUSH
5791: LD_INT 1
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 27
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 26
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_OWVAR 67
5819: ARRAY
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: PUSH
5827: LD_INT 14
5829: PUSH
5830: LD_INT 1
5832: PUSH
5833: LD_INT 2
5835: PUSH
5836: LD_INT 26
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 29
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: LD_OWVAR 67
5858: ARRAY
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 13
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: LD_INT 2
5874: PUSH
5875: LD_INT 26
5877: PUSH
5878: LD_INT 29
5880: PUSH
5881: LD_INT 29
5883: PUSH
5884: LD_INT 29
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: PUSH
5893: LD_OWVAR 67
5897: ARRAY
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 13
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 2
5913: PUSH
5914: LD_INT 29
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 14
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 2
5931: PUSH
5932: LD_INT 26
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: LIST
5945: LIST
5946: LIST
5947: LIST
5948: PPUSH
5949: CALL 59635 0 2
// end ; repeat wait ( 0 0$1 ) ;
5953: LD_INT 35
5955: PPUSH
5956: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5960: LD_INT 3
5962: PPUSH
5963: LD_INT 1
5965: PPUSH
5966: CALL 61053 0 2
5970: PUSH
5971: LD_INT 6
5973: GREATEREQUAL
5974: IFFALSE 5953
// wait ( 0 0$30 ) ;
5976: LD_INT 1050
5978: PPUSH
5979: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5983: LD_ADDR_VAR 0 2
5987: PUSH
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 1
5993: PPUSH
5994: CALL 61053 0 2
5998: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5999: LD_ADDR_EXP 116
6003: PUSH
6004: LD_EXP 116
6008: PPUSH
6009: LD_INT 3
6011: PPUSH
6012: LD_EXP 116
6016: PUSH
6017: LD_INT 3
6019: ARRAY
6020: PUSH
6021: LD_VAR 0 2
6025: DIFF
6026: PPUSH
6027: CALL_OW 1
6031: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_INT 0
6039: PPUSH
6040: LD_INT 2
6042: PPUSH
6043: CALL_OW 12
6047: ST_TO_ADDR
// if target then
6048: LD_VAR 0 3
6052: IFFALSE 6180
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6054: LD_ADDR_VAR 0 2
6058: PUSH
6059: LD_VAR 0 2
6063: PPUSH
6064: LD_INT 24
6066: PUSH
6067: LD_INT 250
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PPUSH
6074: CALL_OW 72
6078: ST_TO_ADDR
// for i in tmp do
6079: LD_ADDR_VAR 0 1
6083: PUSH
6084: LD_VAR 0 2
6088: PUSH
6089: FOR_IN
6090: IFFALSE 6130
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6092: LD_VAR 0 1
6096: PPUSH
6097: LD_INT 89
6099: PPUSH
6100: LD_INT 71
6102: PPUSH
6103: CALL_OW 297
6107: PUSH
6108: LD_INT 9
6110: GREATER
6111: IFFALSE 6128
// ComMoveXY ( i , 89 , 71 ) ;
6113: LD_VAR 0 1
6117: PPUSH
6118: LD_INT 89
6120: PPUSH
6121: LD_INT 71
6123: PPUSH
6124: CALL_OW 111
6128: GO 6089
6130: POP
6131: POP
// wait ( 0 0$1 ) ;
6132: LD_INT 35
6134: PPUSH
6135: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6139: LD_VAR 0 2
6143: PPUSH
6144: LD_INT 92
6146: PUSH
6147: LD_INT 89
6149: PUSH
6150: LD_INT 71
6152: PUSH
6153: LD_INT 9
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: PPUSH
6162: CALL_OW 72
6166: PUSH
6167: LD_VAR 0 2
6171: PUSH
6172: LD_INT 1
6174: MINUS
6175: GREATEREQUAL
6176: IFFALSE 6054
// end else
6178: GO 6304
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6180: LD_ADDR_VAR 0 2
6184: PUSH
6185: LD_VAR 0 2
6189: PPUSH
6190: LD_INT 24
6192: PUSH
6193: LD_INT 250
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL_OW 72
6204: ST_TO_ADDR
// for i in tmp do
6205: LD_ADDR_VAR 0 1
6209: PUSH
6210: LD_VAR 0 2
6214: PUSH
6215: FOR_IN
6216: IFFALSE 6256
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6218: LD_VAR 0 1
6222: PPUSH
6223: LD_INT 125
6225: PPUSH
6226: LD_INT 129
6228: PPUSH
6229: CALL_OW 297
6233: PUSH
6234: LD_INT 9
6236: GREATER
6237: IFFALSE 6254
// ComMoveXY ( i , 125 , 129 ) ;
6239: LD_VAR 0 1
6243: PPUSH
6244: LD_INT 125
6246: PPUSH
6247: LD_INT 129
6249: PPUSH
6250: CALL_OW 111
6254: GO 6215
6256: POP
6257: POP
// wait ( 0 0$1 ) ;
6258: LD_INT 35
6260: PPUSH
6261: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6265: LD_VAR 0 2
6269: PPUSH
6270: LD_INT 92
6272: PUSH
6273: LD_INT 125
6275: PUSH
6276: LD_INT 129
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: PPUSH
6288: CALL_OW 72
6292: PUSH
6293: LD_VAR 0 2
6297: PUSH
6298: LD_INT 1
6300: MINUS
6301: GREATEREQUAL
6302: IFFALSE 6180
// end ; repeat wait ( 0 0$1 ) ;
6304: LD_INT 35
6306: PPUSH
6307: CALL_OW 67
// for i in tmp do
6311: LD_ADDR_VAR 0 1
6315: PUSH
6316: LD_VAR 0 2
6320: PUSH
6321: FOR_IN
6322: IFFALSE 6404
// begin if GetLives ( i ) > 251 then
6324: LD_VAR 0 1
6328: PPUSH
6329: CALL_OW 256
6333: PUSH
6334: LD_INT 251
6336: GREATER
6337: IFFALSE 6375
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6339: LD_VAR 0 1
6343: PPUSH
6344: LD_INT 81
6346: PUSH
6347: LD_INT 8
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PPUSH
6354: CALL_OW 69
6358: PPUSH
6359: LD_VAR 0 1
6363: PPUSH
6364: CALL_OW 74
6368: PPUSH
6369: CALL_OW 115
6373: GO 6402
// if IsDead ( i ) then
6375: LD_VAR 0 1
6379: PPUSH
6380: CALL_OW 301
6384: IFFALSE 6402
// tmp := tmp diff i ;
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: LD_VAR 0 2
6395: PUSH
6396: LD_VAR 0 1
6400: DIFF
6401: ST_TO_ADDR
// end ;
6402: GO 6321
6404: POP
6405: POP
// until not tmp ;
6406: LD_VAR 0 2
6410: NOT
6411: IFFALSE 6304
// end ;
6413: PPOPN 3
6415: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6416: LD_EXP 22
6420: NOT
6421: PUSH
6422: LD_EXP 15
6426: PUSH
6427: LD_INT 6
6429: GREATEREQUAL
6430: AND
6431: PUSH
6432: LD_OWVAR 67
6436: PUSH
6437: LD_INT 1
6439: GREATER
6440: AND
6441: IFFALSE 6974
6443: GO 6445
6445: DISABLE
6446: LD_INT 0
6448: PPUSH
6449: PPUSH
6450: PPUSH
// begin enable ;
6451: ENABLE
// tmp := [ ] ;
6452: LD_ADDR_VAR 0 3
6456: PUSH
6457: EMPTY
6458: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6459: LD_ADDR_VAR 0 1
6463: PUSH
6464: DOUBLE
6465: LD_INT 1
6467: DEC
6468: ST_TO_ADDR
6469: LD_INT 4
6471: PUSH
6472: LD_INT 6
6474: PUSH
6475: LD_INT 7
6477: PUSH
6478: LD_INT 8
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PUSH
6487: LD_OWVAR 67
6491: ARRAY
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6654
// begin uc_side := 8 ;
6496: LD_ADDR_OWVAR 20
6500: PUSH
6501: LD_INT 8
6503: ST_TO_ADDR
// uc_nation := 2 ;
6504: LD_ADDR_OWVAR 21
6508: PUSH
6509: LD_INT 2
6511: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6512: LD_INT 13
6514: PUSH
6515: LD_INT 14
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 1
6524: PPUSH
6525: LD_INT 2
6527: PPUSH
6528: CALL_OW 12
6532: ARRAY
6533: PPUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 5
6539: PPUSH
6540: LD_INT 27
6542: PUSH
6543: LD_INT 28
6545: PUSH
6546: LD_INT 26
6548: PUSH
6549: LD_INT 25
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: LIST
6556: LIST
6557: PUSH
6558: LD_INT 1
6560: PPUSH
6561: LD_INT 4
6563: PPUSH
6564: CALL_OW 12
6568: ARRAY
6569: PPUSH
6570: LD_INT 88
6572: PPUSH
6573: CALL 71038 0 5
// un := CreateVehicle ;
6577: LD_ADDR_VAR 0 2
6581: PUSH
6582: CALL_OW 45
6586: ST_TO_ADDR
// tmp := tmp ^ un ;
6587: LD_ADDR_VAR 0 3
6591: PUSH
6592: LD_VAR 0 3
6596: PUSH
6597: LD_VAR 0 2
6601: ADD
6602: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6603: LD_VAR 0 2
6607: PPUSH
6608: LD_INT 3
6610: PPUSH
6611: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6615: LD_VAR 0 2
6619: PPUSH
6620: LD_INT 30
6622: PPUSH
6623: LD_INT 0
6625: PPUSH
6626: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6630: LD_VAR 0 2
6634: PPUSH
6635: LD_INT 16
6637: PPUSH
6638: LD_INT 11
6640: PPUSH
6641: CALL_OW 111
// wait ( 0 0$2 ) ;
6645: LD_INT 70
6647: PPUSH
6648: CALL_OW 67
// end ;
6652: GO 6493
6654: POP
6655: POP
// for i = 1 to Difficulty do
6656: LD_ADDR_VAR 0 1
6660: PUSH
6661: DOUBLE
6662: LD_INT 1
6664: DEC
6665: ST_TO_ADDR
6666: LD_OWVAR 67
6670: PUSH
6671: FOR_TO
6672: IFFALSE 6801
// begin uc_side := 8 ;
6674: LD_ADDR_OWVAR 20
6678: PUSH
6679: LD_INT 8
6681: ST_TO_ADDR
// uc_nation := 2 ;
6682: LD_ADDR_OWVAR 21
6686: PUSH
6687: LD_INT 2
6689: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6690: LD_INT 0
6692: PPUSH
6693: LD_INT 8
6695: PPUSH
6696: LD_INT 8
6698: PUSH
6699: LD_INT 8
6701: PUSH
6702: LD_INT 9
6704: PUSH
6705: LD_INT 10
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: PUSH
6714: LD_OWVAR 67
6718: ARRAY
6719: PPUSH
6720: CALL_OW 380
// un := CreateHuman ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: CALL_OW 44
6733: ST_TO_ADDR
// tmp := tmp ^ un ;
6734: LD_ADDR_VAR 0 3
6738: PUSH
6739: LD_VAR 0 3
6743: PUSH
6744: LD_VAR 0 2
6748: ADD
6749: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6750: LD_VAR 0 2
6754: PPUSH
6755: LD_INT 3
6757: PPUSH
6758: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 30
6769: PPUSH
6770: LD_INT 0
6772: PPUSH
6773: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6777: LD_VAR 0 2
6781: PPUSH
6782: LD_INT 16
6784: PPUSH
6785: LD_INT 11
6787: PPUSH
6788: CALL_OW 111
// wait ( 0 0$2 ) ;
6792: LD_INT 70
6794: PPUSH
6795: CALL_OW 67
// end ;
6799: GO 6671
6801: POP
6802: POP
// repeat wait ( 0 0$1 ) ;
6803: LD_INT 35
6805: PPUSH
6806: CALL_OW 67
// if legionDestroyed then
6810: LD_EXP 22
6814: IFFALSE 6818
// exit ;
6816: GO 6974
// for i in tmp do
6818: LD_ADDR_VAR 0 1
6822: PUSH
6823: LD_VAR 0 3
6827: PUSH
6828: FOR_IN
6829: IFFALSE 6965
// begin if GetLives ( i ) > 250 then
6831: LD_VAR 0 1
6835: PPUSH
6836: CALL_OW 256
6840: PUSH
6841: LD_INT 250
6843: GREATER
6844: IFFALSE 6936
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6846: LD_INT 81
6848: PUSH
6849: LD_INT 8
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 91
6858: PUSH
6859: LD_VAR 0 1
6863: PUSH
6864: LD_INT 10
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: LIST
6871: PUSH
6872: EMPTY
6873: LIST
6874: LIST
6875: PPUSH
6876: CALL_OW 69
6880: NOT
6881: IFFALSE 6900
// ComAgressiveMove ( i , 67 , 110 ) else
6883: LD_VAR 0 1
6887: PPUSH
6888: LD_INT 67
6890: PPUSH
6891: LD_INT 110
6893: PPUSH
6894: CALL_OW 114
6898: GO 6934
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6900: LD_VAR 0 1
6904: PPUSH
6905: LD_INT 81
6907: PUSH
6908: LD_INT 8
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: PPUSH
6920: LD_VAR 0 1
6924: PPUSH
6925: CALL_OW 74
6929: PPUSH
6930: CALL_OW 115
// end else
6934: GO 6963
// if IsDead ( i ) then
6936: LD_VAR 0 1
6940: PPUSH
6941: CALL_OW 301
6945: IFFALSE 6963
// tmp := tmp diff i ;
6947: LD_ADDR_VAR 0 3
6951: PUSH
6952: LD_VAR 0 3
6956: PUSH
6957: LD_VAR 0 1
6961: DIFF
6962: ST_TO_ADDR
// end ;
6963: GO 6828
6965: POP
6966: POP
// until not tmp ;
6967: LD_VAR 0 3
6971: NOT
6972: IFFALSE 6803
// end ; end_of_file
6974: PPOPN 3
6976: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6977: LD_INT 0
6979: PPUSH
6980: PPUSH
6981: PPUSH
6982: PPUSH
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
// side := 3 ;
6988: LD_ADDR_VAR 0 6
6992: PUSH
6993: LD_INT 3
6995: ST_TO_ADDR
// uc_side := side ;
6996: LD_ADDR_OWVAR 20
7000: PUSH
7001: LD_VAR 0 6
7005: ST_TO_ADDR
// uc_nation := 3 ;
7006: LD_ADDR_OWVAR 21
7010: PUSH
7011: LD_INT 3
7013: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7014: LD_ADDR_VAR 0 2
7018: PUSH
7019: LD_INT 22
7021: PUSH
7022: LD_VAR 0 6
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 21
7033: PUSH
7034: LD_INT 3
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: FOR_IN
7051: IFFALSE 7067
// SetBLevel ( i , 10 ) ;
7053: LD_VAR 0 2
7057: PPUSH
7058: LD_INT 10
7060: PPUSH
7061: CALL_OW 241
7065: GO 7050
7067: POP
7068: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7069: LD_ADDR_VAR 0 9
7073: PUSH
7074: LD_INT 22
7076: PUSH
7077: LD_VAR 0 6
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: LD_INT 30
7088: PUSH
7089: LD_INT 34
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PPUSH
7100: CALL_OW 69
7104: ST_TO_ADDR
// if teleport then
7105: LD_VAR 0 9
7109: IFFALSE 7130
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7111: LD_VAR 0 9
7115: PUSH
7116: LD_INT 1
7118: ARRAY
7119: PPUSH
7120: LD_INT 123
7122: PPUSH
7123: LD_INT 122
7125: PPUSH
7126: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7130: LD_ADDR_EXP 64
7134: PUSH
7135: LD_STRING Platonov
7137: PPUSH
7138: CALL_OW 25
7142: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7143: LD_ADDR_EXP 65
7147: PUSH
7148: LD_STRING Kovalyuk
7150: PPUSH
7151: CALL_OW 25
7155: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7156: LD_ADDR_EXP 67
7160: PUSH
7161: LD_STRING Yakotich
7163: PPUSH
7164: LD_EXP 1
7168: NOT
7169: PPUSH
7170: LD_STRING 09_
7172: PPUSH
7173: CALL 66023 0 3
7177: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7178: LD_ADDR_EXP 66
7182: PUSH
7183: LD_STRING Bystrov
7185: PPUSH
7186: CALL_OW 25
7190: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7191: LD_ADDR_EXP 68
7195: PUSH
7196: LD_STRING Gleb
7198: PPUSH
7199: CALL_OW 25
7203: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7204: LD_STRING 03_Cornel
7206: PPUSH
7207: CALL_OW 28
7211: IFFALSE 7259
// begin Bierezov := NewCharacter ( Mikhail ) ;
7213: LD_ADDR_EXP 69
7217: PUSH
7218: LD_STRING Mikhail
7220: PPUSH
7221: CALL_OW 25
7225: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 197
7233: PPUSH
7234: LD_INT 111
7236: PPUSH
7237: LD_INT 9
7239: PPUSH
7240: LD_INT 0
7242: PPUSH
7243: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7247: LD_EXP 69
7251: PPUSH
7252: LD_INT 3
7254: PPUSH
7255: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7259: LD_EXP 64
7263: PPUSH
7264: LD_INT 126
7266: PPUSH
7267: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7271: LD_EXP 65
7275: PPUSH
7276: LD_INT 134
7278: PPUSH
7279: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7283: LD_EXP 67
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7304: LD_EXP 66
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7325: LD_EXP 68
7329: PPUSH
7330: LD_INT 197
7332: PPUSH
7333: LD_INT 111
7335: PPUSH
7336: LD_INT 9
7338: PPUSH
7339: LD_INT 0
7341: PPUSH
7342: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7346: LD_ADDR_VAR 0 5
7350: PUSH
7351: LD_INT 126
7353: PPUSH
7354: LD_INT 4
7356: PPUSH
7357: LD_STRING zhukov
7359: PPUSH
7360: LD_INT 9
7362: PUSH
7363: LD_INT 10
7365: PUSH
7366: LD_INT 10
7368: PUSH
7369: LD_INT 10
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 74482 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 97
7483: PUSH
7484: LD_EXP 97
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 103472 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 103472 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 103533 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 103533 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8310
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: LD_INT 7
8190: PUSH
8191: EMPTY
8192: LIST
8193: LIST
8194: LIST
8195: LIST
8196: PUSH
8197: LD_OWVAR 67
8201: ARRAY
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8306
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8206: LD_INT 22
8208: PUSH
8209: LD_INT 24
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: PUSH
8216: LD_VAR 0 3
8220: PUSH
8221: LD_INT 2
8223: MOD
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ARRAY
8229: PPUSH
8230: LD_INT 1
8232: PUSH
8233: LD_INT 3
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 2
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 3
8254: PPUSH
8255: LD_INT 43
8257: PUSH
8258: LD_INT 44
8260: PUSH
8261: LD_INT 45
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 1
8271: PPUSH
8272: LD_INT 3
8274: PPUSH
8275: CALL_OW 12
8279: ARRAY
8280: PPUSH
8281: LD_INT 80
8283: PPUSH
8284: CALL 71038 0 5
// result := result union CreateVehicle ;
8288: LD_ADDR_VAR 0 2
8292: PUSH
8293: LD_VAR 0 2
8297: PUSH
8298: CALL_OW 45
8302: UNION
8303: ST_TO_ADDR
// end ;
8304: GO 8203
8306: POP
8307: POP
// end ; 2 :
8308: GO 9285
8310: LD_INT 2
8312: DOUBLE
8313: EQUAL
8314: IFTRUE 8318
8316: GO 8482
8318: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8319: LD_ADDR_VAR 0 3
8323: PUSH
8324: DOUBLE
8325: LD_INT 1
8327: DEC
8328: ST_TO_ADDR
8329: LD_INT 5
8331: PUSH
8332: LD_INT 6
8334: PUSH
8335: LD_INT 7
8337: PUSH
8338: LD_INT 8
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: PUSH
8347: LD_OWVAR 67
8351: ARRAY
8352: PUSH
8353: FOR_TO
8354: IFFALSE 8478
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser ] [ i mod 7 + 1 ] , 80 ) ;
8356: LD_INT 22
8358: PUSH
8359: LD_INT 24
8361: PUSH
8362: LD_INT 24
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: LIST
8369: PUSH
8370: LD_VAR 0 3
8374: PUSH
8375: LD_INT 3
8377: MOD
8378: PUSH
8379: LD_INT 1
8381: PLUS
8382: ARRAY
8383: PPUSH
8384: LD_INT 1
8386: PUSH
8387: LD_INT 3
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: PUSH
8394: LD_INT 1
8396: PPUSH
8397: LD_INT 2
8399: PPUSH
8400: CALL_OW 12
8404: ARRAY
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: LD_INT 43
8411: PUSH
8412: LD_INT 44
8414: PUSH
8415: LD_INT 45
8417: PUSH
8418: LD_INT 44
8420: PUSH
8421: LD_INT 46
8423: PUSH
8424: LD_INT 46
8426: PUSH
8427: LD_INT 49
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: LIST
8434: LIST
8435: LIST
8436: LIST
8437: LIST
8438: PUSH
8439: LD_VAR 0 3
8443: PUSH
8444: LD_INT 7
8446: MOD
8447: PUSH
8448: LD_INT 1
8450: PLUS
8451: ARRAY
8452: PPUSH
8453: LD_INT 80
8455: PPUSH
8456: CALL 71038 0 5
// result := result union CreateVehicle ;
8460: LD_ADDR_VAR 0 2
8464: PUSH
8465: LD_VAR 0 2
8469: PUSH
8470: CALL_OW 45
8474: UNION
8475: ST_TO_ADDR
// end ;
8476: GO 8353
8478: POP
8479: POP
// end ; 3 :
8480: GO 9285
8482: LD_INT 3
8484: DOUBLE
8485: EQUAL
8486: IFTRUE 8490
8488: GO 8654
8490: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8491: LD_ADDR_VAR 0 3
8495: PUSH
8496: DOUBLE
8497: LD_INT 1
8499: DEC
8500: ST_TO_ADDR
8501: LD_INT 6
8503: PUSH
8504: LD_INT 7
8506: PUSH
8507: LD_INT 8
8509: PUSH
8510: LD_INT 9
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: LIST
8517: LIST
8518: PUSH
8519: LD_OWVAR 67
8523: ARRAY
8524: PUSH
8525: FOR_TO
8526: IFFALSE 8650
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser ] [ i mod 7 + 1 ] , 80 ) ;
8528: LD_INT 22
8530: PUSH
8531: LD_INT 24
8533: PUSH
8534: LD_INT 24
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: PUSH
8542: LD_VAR 0 3
8546: PUSH
8547: LD_INT 3
8549: MOD
8550: PUSH
8551: LD_INT 1
8553: PLUS
8554: ARRAY
8555: PPUSH
8556: LD_INT 1
8558: PUSH
8559: LD_INT 3
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PUSH
8566: LD_INT 1
8568: PPUSH
8569: LD_INT 2
8571: PPUSH
8572: CALL_OW 12
8576: ARRAY
8577: PPUSH
8578: LD_INT 3
8580: PPUSH
8581: LD_INT 43
8583: PUSH
8584: LD_INT 47
8586: PUSH
8587: LD_INT 45
8589: PUSH
8590: LD_INT 45
8592: PUSH
8593: LD_INT 46
8595: PUSH
8596: LD_INT 46
8598: PUSH
8599: LD_INT 49
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: PUSH
8611: LD_VAR 0 3
8615: PUSH
8616: LD_INT 7
8618: MOD
8619: PUSH
8620: LD_INT 1
8622: PLUS
8623: ARRAY
8624: PPUSH
8625: LD_INT 80
8627: PPUSH
8628: CALL 71038 0 5
// result := result union CreateVehicle ;
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: LD_VAR 0 2
8641: PUSH
8642: CALL_OW 45
8646: UNION
8647: ST_TO_ADDR
// end ;
8648: GO 8525
8650: POP
8651: POP
// end ; 4 :
8652: GO 9285
8654: LD_INT 4
8656: DOUBLE
8657: EQUAL
8658: IFTRUE 8662
8660: GO 9284
8662: POP
// begin uc_nation := 3 ;
8663: LD_ADDR_OWVAR 21
8667: PUSH
8668: LD_INT 3
8670: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8671: LD_ADDR_VAR 0 3
8675: PUSH
8676: DOUBLE
8677: LD_INT 1
8679: DEC
8680: ST_TO_ADDR
8681: LD_INT 6
8683: PUSH
8684: LD_INT 8
8686: PUSH
8687: LD_INT 9
8689: PUSH
8690: LD_INT 10
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: LIST
8698: PUSH
8699: LD_OWVAR 67
8703: ARRAY
8704: PUSH
8705: FOR_TO
8706: IFFALSE 8830
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser ] [ i mod 7 + 1 ] , 80 ) ;
8708: LD_INT 22
8710: PUSH
8711: LD_INT 24
8713: PUSH
8714: LD_INT 24
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_VAR 0 3
8726: PUSH
8727: LD_INT 3
8729: MOD
8730: PUSH
8731: LD_INT 1
8733: PLUS
8734: ARRAY
8735: PPUSH
8736: LD_INT 1
8738: PUSH
8739: LD_INT 3
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: PUSH
8746: LD_INT 1
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: CALL_OW 12
8756: ARRAY
8757: PPUSH
8758: LD_INT 3
8760: PPUSH
8761: LD_INT 45
8763: PUSH
8764: LD_INT 47
8766: PUSH
8767: LD_INT 47
8769: PUSH
8770: LD_INT 45
8772: PUSH
8773: LD_INT 46
8775: PUSH
8776: LD_INT 46
8778: PUSH
8779: LD_INT 49
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: LIST
8789: LIST
8790: PUSH
8791: LD_VAR 0 3
8795: PUSH
8796: LD_INT 7
8798: MOD
8799: PUSH
8800: LD_INT 1
8802: PLUS
8803: ARRAY
8804: PPUSH
8805: LD_INT 80
8807: PPUSH
8808: CALL 71038 0 5
// result := result union CreateVehicle ;
8812: LD_ADDR_VAR 0 2
8816: PUSH
8817: LD_VAR 0 2
8821: PUSH
8822: CALL_OW 45
8826: UNION
8827: ST_TO_ADDR
// end ;
8828: GO 8705
8830: POP
8831: POP
// if not KappaStatus then
8832: LD_EXP 2
8836: NOT
8837: IFFALSE 9072
// begin uc_nation := 1 ;
8839: LD_ADDR_OWVAR 21
8843: PUSH
8844: LD_INT 1
8846: ST_TO_ADDR
// for i = 1 to 3 do
8847: LD_ADDR_VAR 0 3
8851: PUSH
8852: DOUBLE
8853: LD_INT 1
8855: DEC
8856: ST_TO_ADDR
8857: LD_INT 3
8859: PUSH
8860: FOR_TO
8861: IFFALSE 8997
// begin j := rand ( 0 , 1 ) ;
8863: LD_ADDR_VAR 0 4
8867: PUSH
8868: LD_INT 0
8870: PPUSH
8871: LD_INT 1
8873: PPUSH
8874: CALL_OW 12
8878: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8879: LD_INT 3
8881: PUSH
8882: LD_INT 5
8884: PUSH
8885: LD_INT 5
8887: PUSH
8888: LD_INT 4
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: LIST
8895: LIST
8896: PUSH
8897: LD_VAR 0 4
8901: PUSH
8902: LD_INT 1
8904: PPUSH
8905: LD_INT 3
8907: PPUSH
8908: CALL_OW 12
8912: PLUS
8913: ARRAY
8914: PPUSH
8915: LD_INT 1
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 1
8927: PPUSH
8928: LD_INT 2
8930: PPUSH
8931: CALL_OW 12
8935: ARRAY
8936: PPUSH
8937: LD_INT 3
8939: PPUSH
8940: LD_INT 9
8942: PUSH
8943: LD_INT 7
8945: PUSH
8946: LD_INT 6
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: LIST
8953: PUSH
8954: LD_VAR 0 4
8958: PUSH
8959: LD_INT 1
8961: PPUSH
8962: LD_INT 2
8964: PPUSH
8965: CALL_OW 12
8969: PLUS
8970: ARRAY
8971: PPUSH
8972: LD_INT 85
8974: PPUSH
8975: CALL 71038 0 5
// result := result union CreateVehicle ;
8979: LD_ADDR_VAR 0 2
8983: PUSH
8984: LD_VAR 0 2
8988: PUSH
8989: CALL_OW 45
8993: UNION
8994: ST_TO_ADDR
// end ;
8995: GO 8860
8997: POP
8998: POP
// if vsevolodFirstAttack then
8999: LD_EXP 24
9003: IFFALSE 9070
// begin vsevolodFirstAttack := false ;
9005: LD_ADDR_EXP 24
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9013: LD_INT 5
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: LD_INT 6
9024: PPUSH
9025: LD_INT 100
9027: PPUSH
9028: CALL 71038 0 5
// sewiVeh := CreateVehicle ;
9032: LD_ADDR_EXP 71
9036: PUSH
9037: CALL_OW 45
9041: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9042: LD_EXP 71
9046: PPUSH
9047: LD_INT 1
9049: PPUSH
9050: CALL_OW 242
// result := result union sewiVeh ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: LD_EXP 71
9068: UNION
9069: ST_TO_ADDR
// end ; end else
9070: GO 9282
// if vsevolodFirstAttack then
9072: LD_EXP 24
9076: IFFALSE 9282
// begin vsevolodFirstAttack := false ;
9078: LD_ADDR_EXP 24
9082: PUSH
9083: LD_INT 0
9085: ST_TO_ADDR
// uc_nation := 3 ;
9086: LD_ADDR_OWVAR 21
9090: PUSH
9091: LD_INT 3
9093: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9094: LD_ADDR_VAR 0 3
9098: PUSH
9099: DOUBLE
9100: LD_INT 1
9102: DEC
9103: ST_TO_ADDR
9104: LD_INT 2
9106: PUSH
9107: LD_OWVAR 67
9111: PLUS
9112: PUSH
9113: FOR_TO
9114: IFFALSE 9222
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9116: LD_INT 22
9118: PUSH
9119: LD_INT 24
9121: PUSH
9122: LD_INT 24
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 1
9146: PUSH
9147: LD_INT 3
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: LD_INT 1
9156: PPUSH
9157: LD_INT 2
9159: PPUSH
9160: CALL_OW 12
9164: ARRAY
9165: PPUSH
9166: LD_INT 1
9168: PPUSH
9169: LD_INT 45
9171: PUSH
9172: LD_INT 47
9174: PUSH
9175: LD_INT 47
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: LIST
9182: PUSH
9183: LD_VAR 0 3
9187: PUSH
9188: LD_INT 3
9190: MOD
9191: PUSH
9192: LD_INT 1
9194: PLUS
9195: ARRAY
9196: PPUSH
9197: LD_INT 80
9199: PPUSH
9200: CALL 71038 0 5
// result := result union CreateVehicle ;
9204: LD_ADDR_VAR 0 2
9208: PUSH
9209: LD_VAR 0 2
9213: PUSH
9214: CALL_OW 45
9218: UNION
9219: ST_TO_ADDR
// end ;
9220: GO 9113
9222: POP
9223: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9224: LD_INT 24
9226: PPUSH
9227: LD_INT 3
9229: PPUSH
9230: LD_INT 1
9232: PPUSH
9233: LD_INT 47
9235: PPUSH
9236: LD_INT 100
9238: PPUSH
9239: CALL 71038 0 5
// sewiVeh := CreateVehicle ;
9243: LD_ADDR_EXP 71
9247: PUSH
9248: CALL_OW 45
9252: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9253: LD_EXP 71
9257: PPUSH
9258: LD_INT 6
9260: NEG
9261: PPUSH
9262: CALL_OW 242
// result := result union sewiVeh ;
9266: LD_ADDR_VAR 0 2
9270: PUSH
9271: LD_VAR 0 2
9275: PUSH
9276: LD_EXP 71
9280: UNION
9281: ST_TO_ADDR
// end ; end ; end ;
9282: GO 9285
9284: POP
// end ;
9285: LD_VAR 0 2
9289: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9290: LD_EXP 16
9294: IFFALSE 9940
9296: GO 9298
9298: DISABLE
9299: LD_INT 0
9301: PPUSH
9302: PPUSH
9303: PPUSH
9304: PPUSH
9305: PPUSH
9306: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9307: LD_ADDR_VAR 0 4
9311: PUSH
9312: LD_INT 11
9314: PUSH
9315: LD_INT 12
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9322: LD_ADDR_VAR 0 3
9326: PUSH
9327: LD_INT 11550
9329: PUSH
9330: LD_INT 10150
9332: PUSH
9333: LD_INT 9800
9335: PUSH
9336: LD_INT 9450
9338: PUSH
9339: EMPTY
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: PUSH
9345: LD_OWVAR 67
9349: ARRAY
9350: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9351: LD_ADDR_VAR 0 6
9355: PUSH
9356: LD_INT 70
9358: PUSH
9359: LD_INT 118
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: LD_INT 78
9368: PUSH
9369: LD_INT 31
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: ST_TO_ADDR
// repeat if missionStage = 2 then
9380: LD_EXP 15
9384: PUSH
9385: LD_INT 2
9387: EQUAL
9388: IFFALSE 9399
// wait ( 1 1$30 ) else
9390: LD_INT 3150
9392: PPUSH
9393: CALL_OW 67
9397: GO 9408
// wait ( time ) ;
9399: LD_VAR 0 3
9403: PPUSH
9404: CALL_OW 67
// if missionStage = 6 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 6
9415: EQUAL
9416: IFFALSE 9444
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9418: LD_INT 51
9420: PPUSH
9421: LD_INT 6
9423: PPUSH
9424: LD_INT 2
9426: PPUSH
9427: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9431: LD_INT 57
9433: PPUSH
9434: LD_INT 6
9436: PPUSH
9437: LD_INT 2
9439: PPUSH
9440: CALL_OW 322
// end ; if missionStage = 8 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 8
9451: EQUAL
9452: IFFALSE 9480
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9454: LD_INT 52
9456: PPUSH
9457: LD_INT 6
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9467: LD_INT 58
9469: PPUSH
9470: LD_INT 6
9472: PPUSH
9473: LD_INT 2
9475: PPUSH
9476: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 10
9487: EQUAL
9488: PUSH
9489: LD_OWVAR 67
9493: PUSH
9494: LD_INT 1
9496: GREATER
9497: AND
9498: IFFALSE 9526
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9500: LD_INT 53
9502: PPUSH
9503: LD_INT 6
9505: PPUSH
9506: LD_INT 2
9508: PPUSH
9509: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9513: LD_INT 59
9515: PPUSH
9516: LD_INT 6
9518: PPUSH
9519: LD_INT 2
9521: PPUSH
9522: CALL_OW 322
// end ; if activeAttacks then
9526: LD_EXP 16
9530: IFFALSE 9934
// begin if missionStage = 2 then
9532: LD_EXP 15
9536: PUSH
9537: LD_INT 2
9539: EQUAL
9540: IFFALSE 9550
// strength := 1 ;
9542: LD_ADDR_VAR 0 5
9546: PUSH
9547: LD_INT 1
9549: ST_TO_ADDR
// if missionStage > 2 then
9550: LD_EXP 15
9554: PUSH
9555: LD_INT 2
9557: GREATER
9558: IFFALSE 9568
// strength := 2 ;
9560: LD_ADDR_VAR 0 5
9564: PUSH
9565: LD_INT 2
9567: ST_TO_ADDR
// if missionStage > 6 then
9568: LD_EXP 15
9572: PUSH
9573: LD_INT 6
9575: GREATER
9576: IFFALSE 9586
// strength := 3 ;
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_INT 3
9585: ST_TO_ADDR
// if missionStage > 10 then
9586: LD_EXP 15
9590: PUSH
9591: LD_INT 10
9593: GREATER
9594: IFFALSE 9604
// strength := 4 ;
9596: LD_ADDR_VAR 0 5
9600: PUSH
9601: LD_INT 4
9603: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9604: LD_ADDR_VAR 0 2
9608: PUSH
9609: LD_VAR 0 5
9613: PPUSH
9614: CALL 8127 0 1
9618: ST_TO_ADDR
// for i in tmp do
9619: LD_ADDR_VAR 0 1
9623: PUSH
9624: LD_VAR 0 2
9628: PUSH
9629: FOR_IN
9630: IFFALSE 9813
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9632: LD_VAR 0 1
9636: PPUSH
9637: LD_VAR 0 4
9641: PUSH
9642: LD_INT 1
9644: PPUSH
9645: LD_INT 2
9647: PPUSH
9648: CALL_OW 12
9652: ARRAY
9653: PPUSH
9654: LD_INT 0
9656: PPUSH
9657: CALL_OW 49
// if i = sewiVeh then
9661: LD_VAR 0 1
9665: PUSH
9666: LD_EXP 71
9670: EQUAL
9671: IFFALSE 9708
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9673: LD_ADDR_EXP 70
9677: PUSH
9678: LD_STRING Vsevolod
9680: PPUSH
9681: LD_INT 0
9683: PPUSH
9684: LD_STRING 
9686: PPUSH
9687: CALL 66023 0 3
9691: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9692: LD_EXP 70
9696: PPUSH
9697: LD_VAR 0 1
9701: PPUSH
9702: CALL_OW 52
// end else
9706: GO 9789
// if GetControl ( i ) = control_manual then
9708: LD_VAR 0 1
9712: PPUSH
9713: CALL_OW 263
9717: PUSH
9718: LD_INT 1
9720: EQUAL
9721: IFFALSE 9789
// begin uc_side := 6 ;
9723: LD_ADDR_OWVAR 20
9727: PUSH
9728: LD_INT 6
9730: ST_TO_ADDR
// uc_nation := 3 ;
9731: LD_ADDR_OWVAR 21
9735: PUSH
9736: LD_INT 3
9738: ST_TO_ADDR
// hc_gallery :=  ;
9739: LD_ADDR_OWVAR 33
9743: PUSH
9744: LD_STRING 
9746: ST_TO_ADDR
// hc_name :=  ;
9747: LD_ADDR_OWVAR 26
9751: PUSH
9752: LD_STRING 
9754: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9755: LD_INT 0
9757: PPUSH
9758: LD_INT 3
9760: PPUSH
9761: LD_INT 10
9763: PPUSH
9764: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9768: CALL_OW 44
9772: PPUSH
9773: LD_VAR 0 1
9777: PPUSH
9778: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9782: LD_INT 10
9784: PPUSH
9785: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: LD_INT 111
9796: PPUSH
9797: LD_INT 197
9799: PPUSH
9800: CALL_OW 111
// wait ( 0 0$2 ) ;
9804: LD_INT 70
9806: PPUSH
9807: CALL_OW 67
// end ;
9811: GO 9629
9813: POP
9814: POP
// repeat wait ( 0 0$1 ) ;
9815: LD_INT 35
9817: PPUSH
9818: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
9822: LD_ADDR_VAR 0 1
9826: PUSH
9827: LD_VAR 0 2
9831: PPUSH
9832: LD_INT 50
9834: PUSH
9835: EMPTY
9836: LIST
9837: PPUSH
9838: CALL_OW 72
9842: PUSH
9843: FOR_IN
9844: IFFALSE 9914
// AgressiveMove ( i , [ [ 112 , 187 ] , [ 114 , 164 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
9846: LD_VAR 0 1
9850: PPUSH
9851: LD_INT 112
9853: PUSH
9854: LD_INT 187
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: PUSH
9861: LD_INT 114
9863: PUSH
9864: LD_INT 164
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 105
9873: PUSH
9874: LD_INT 149
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: LD_INT 85
9883: PUSH
9884: LD_INT 131
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: PUSH
9891: LD_INT 64
9893: PUSH
9894: LD_INT 105
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL 106076 0 2
9912: GO 9843
9914: POP
9915: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
9916: LD_VAR 0 2
9920: PPUSH
9921: LD_INT 50
9923: PUSH
9924: EMPTY
9925: LIST
9926: PPUSH
9927: CALL_OW 72
9931: NOT
9932: IFFALSE 9815
// end ; until russianDestroyed ;
9934: LD_EXP 21
9938: IFFALSE 9380
// end ;
9940: PPOPN 6
9942: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9943: LD_EXP 21
9947: NOT
9948: PUSH
9949: LD_EXP 15
9953: PUSH
9954: LD_INT 6
9956: GREATEREQUAL
9957: AND
9958: PUSH
9959: LD_INT 2
9961: PPUSH
9962: LD_INT 1
9964: PPUSH
9965: CALL 61053 0 2
9969: NOT
9970: AND
9971: IFFALSE 10931
9973: GO 9975
9975: DISABLE
9976: LD_INT 0
9978: PPUSH
9979: PPUSH
9980: PPUSH
9981: PPUSH
// begin enable ;
9982: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9983: LD_INT 22
9985: PUSH
9986: LD_INT 3
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 30
9995: PUSH
9996: LD_INT 3
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PPUSH
10007: CALL_OW 69
10011: NOT
10012: IFFALSE 10016
// exit ;
10014: GO 10931
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10016: LD_ADDR_VAR 0 4
10020: PUSH
10021: LD_INT 22
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 30
10033: PUSH
10034: LD_INT 34
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PPUSH
10045: CALL_OW 69
10049: ST_TO_ADDR
// if Prob ( 40 ) then
10050: LD_INT 40
10052: PPUSH
10053: CALL_OW 13
10057: IFFALSE 10184
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10059: LD_INT 2
10061: PPUSH
10062: LD_INT 22
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 49
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: PUSH
10080: LD_INT 22
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 3
10088: PUSH
10089: LD_INT 49
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_INT 22
10100: PUSH
10101: LD_INT 3
10103: PUSH
10104: LD_INT 3
10106: PUSH
10107: LD_INT 49
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: PUSH
10116: LD_INT 24
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 3
10124: PUSH
10125: LD_INT 46
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: PUSH
10134: LD_INT 24
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 3
10142: PUSH
10143: LD_INT 46
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 24
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 3
10160: PUSH
10161: LD_INT 46
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: PPUSH
10178: CALL 59635 0 2
// end else
10182: GO 10307
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10184: LD_INT 2
10186: PPUSH
10187: LD_INT 24
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 47
10198: PUSH
10199: EMPTY
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 24
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 47
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 24
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: LD_INT 3
10231: PUSH
10232: LD_INT 47
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: LIST
10239: LIST
10240: PUSH
10241: LD_INT 24
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 3
10249: PUSH
10250: LD_INT 46
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: PUSH
10259: LD_INT 24
10261: PUSH
10262: LD_INT 3
10264: PUSH
10265: LD_INT 3
10267: PUSH
10268: LD_INT 46
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 24
10279: PUSH
10280: LD_INT 3
10282: PUSH
10283: LD_INT 3
10285: PUSH
10286: LD_INT 46
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: PPUSH
10303: CALL 59635 0 2
// end ; if Difficulty > 1 then
10307: LD_OWVAR 67
10311: PUSH
10312: LD_INT 1
10314: GREATER
10315: IFFALSE 10345
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10317: LD_INT 2
10319: PPUSH
10320: LD_INT 24
10322: PUSH
10323: LD_INT 3
10325: PUSH
10326: LD_INT 3
10328: PUSH
10329: LD_INT 47
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: PUSH
10338: EMPTY
10339: LIST
10340: PPUSH
10341: CALL 59635 0 2
// repeat wait ( 0 0$1 ) ;
10345: LD_INT 35
10347: PPUSH
10348: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10352: LD_INT 2
10354: PPUSH
10355: LD_INT 1
10357: PPUSH
10358: CALL 61053 0 2
10362: PUSH
10363: LD_INT 6
10365: PUSH
10366: LD_INT 7
10368: PUSH
10369: LD_INT 7
10371: PUSH
10372: LD_INT 7
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_OWVAR 67
10385: ARRAY
10386: GREATEREQUAL
10387: IFFALSE 10345
// wait ( 0 0$30 ) ;
10389: LD_INT 1050
10391: PPUSH
10392: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10396: LD_ADDR_VAR 0 2
10400: PUSH
10401: LD_INT 2
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 61053 0 2
10411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10412: LD_ADDR_EXP 116
10416: PUSH
10417: LD_EXP 116
10421: PPUSH
10422: LD_INT 2
10424: PPUSH
10425: LD_EXP 116
10429: PUSH
10430: LD_INT 2
10432: ARRAY
10433: PUSH
10434: LD_VAR 0 2
10438: DIFF
10439: PPUSH
10440: CALL_OW 1
10444: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10445: LD_ADDR_VAR 0 3
10449: PUSH
10450: LD_INT 0
10452: PPUSH
10453: LD_INT 1
10455: PPUSH
10456: CALL_OW 12
10460: ST_TO_ADDR
// if target then
10461: LD_VAR 0 3
10465: IFFALSE 10593
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10467: LD_ADDR_VAR 0 2
10471: PUSH
10472: LD_VAR 0 2
10476: PPUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 250
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// for i in tmp do
10492: LD_ADDR_VAR 0 1
10496: PUSH
10497: LD_VAR 0 2
10501: PUSH
10502: FOR_IN
10503: IFFALSE 10543
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 139
10512: PPUSH
10513: LD_INT 89
10515: PPUSH
10516: CALL_OW 297
10520: PUSH
10521: LD_INT 9
10523: GREATER
10524: IFFALSE 10541
// ComMoveXY ( i , 139 , 89 ) ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 139
10533: PPUSH
10534: LD_INT 89
10536: PPUSH
10537: CALL_OW 111
10541: GO 10502
10543: POP
10544: POP
// wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_INT 92
10559: PUSH
10560: LD_INT 139
10562: PUSH
10563: LD_INT 89
10565: PUSH
10566: LD_INT 9
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 1
10587: MINUS
10588: GREATEREQUAL
10589: IFFALSE 10467
// end else
10591: GO 10735
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: PPUSH
10607: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10611: LD_ADDR_VAR 0 2
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 24
10623: PUSH
10624: LD_INT 250
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: ST_TO_ADDR
// for i in tmp do
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_VAR 0 2
10645: PUSH
10646: FOR_IN
10647: IFFALSE 10687
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 124
10656: PPUSH
10657: LD_INT 139
10659: PPUSH
10660: CALL_OW 297
10664: PUSH
10665: LD_INT 9
10667: GREATER
10668: IFFALSE 10685
// ComMoveXY ( i , 124 , 139 ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_INT 124
10677: PPUSH
10678: LD_INT 139
10680: PPUSH
10681: CALL_OW 111
10685: GO 10646
10687: POP
10688: POP
// wait ( 0 0$1 ) ;
10689: LD_INT 35
10691: PPUSH
10692: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10696: LD_VAR 0 2
10700: PPUSH
10701: LD_INT 92
10703: PUSH
10704: LD_INT 124
10706: PUSH
10707: LD_INT 139
10709: PUSH
10710: LD_INT 9
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: PPUSH
10719: CALL_OW 72
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: LD_INT 1
10731: MINUS
10732: GREATEREQUAL
10733: IFFALSE 10611
// end ; repeat wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// for i in tmp do
10742: LD_ADDR_VAR 0 1
10746: PUSH
10747: LD_VAR 0 2
10751: PUSH
10752: FOR_IN
10753: IFFALSE 10922
// begin if GetLives ( i ) > 251 then
10755: LD_VAR 0 1
10759: PPUSH
10760: CALL_OW 256
10764: PUSH
10765: LD_INT 251
10767: GREATER
10768: IFFALSE 10893
// begin if GetWeapon ( i ) = ru_time_lapser then
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 264
10779: PUSH
10780: LD_INT 49
10782: EQUAL
10783: IFFALSE 10839
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_INT 2
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PUSH
10803: LD_INT 22
10805: PUSH
10806: LD_INT 8
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PPUSH
10823: LD_VAR 0 1
10827: PPUSH
10828: CALL_OW 74
10832: PPUSH
10833: CALL_OW 112
10837: GO 10891
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 2
10846: PUSH
10847: LD_INT 22
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 8
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: PPUSH
10872: CALL_OW 69
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 74
10886: PPUSH
10887: CALL_OW 115
// end else
10891: GO 10920
// if IsDead ( i ) then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 301
10902: IFFALSE 10920
// tmp := tmp diff i ;
10904: LD_ADDR_VAR 0 2
10908: PUSH
10909: LD_VAR 0 2
10913: PUSH
10914: LD_VAR 0 1
10918: DIFF
10919: ST_TO_ADDR
// end ;
10920: GO 10752
10922: POP
10923: POP
// until not tmp ;
10924: LD_VAR 0 2
10928: NOT
10929: IFFALSE 10735
// end ; end_of_file
10931: PPOPN 4
10933: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
10939: PPUSH
10940: PPUSH
10941: PPUSH
// side := 7 ;
10942: LD_ADDR_VAR 0 5
10946: PUSH
10947: LD_INT 7
10949: ST_TO_ADDR
// uc_side := side ;
10950: LD_ADDR_OWVAR 20
10954: PUSH
10955: LD_VAR 0 5
10959: ST_TO_ADDR
// uc_nation := 1 ;
10960: LD_ADDR_OWVAR 21
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10968: LD_ADDR_VAR 0 2
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: FOR_IN
11005: IFFALSE 11021
// SetBLevel ( i , 10 ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 10
11014: PPUSH
11015: CALL_OW 241
11019: GO 11004
11021: POP
11022: POP
// base := GetBase ( al_depot ) ;
11023: LD_ADDR_VAR 0 4
11027: PUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 274
11035: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11036: LD_ADDR_VAR 0 6
11040: PUSH
11041: LD_INT 22
11043: PUSH
11044: LD_VAR 0 5
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PUSH
11053: LD_INT 30
11055: PUSH
11056: LD_INT 34
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 69
11071: ST_TO_ADDR
// if teleport then
11072: LD_VAR 0 6
11076: IFFALSE 11097
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11078: LD_VAR 0 6
11082: PUSH
11083: LD_INT 1
11085: ARRAY
11086: PPUSH
11087: LD_INT 262
11089: PPUSH
11090: LD_INT 119
11092: PPUSH
11093: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11097: LD_VAR 0 4
11101: PPUSH
11102: LD_INT 1
11104: PPUSH
11105: LD_INT 19500
11107: PPUSH
11108: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11112: LD_VAR 0 4
11116: PPUSH
11117: LD_INT 2
11119: PPUSH
11120: LD_INT 200
11122: PPUSH
11123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11127: LD_VAR 0 4
11131: PPUSH
11132: LD_INT 3
11134: PPUSH
11135: LD_INT 650
11137: PPUSH
11138: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11142: LD_ADDR_EXP 74
11146: PUSH
11147: LD_STRING Roth
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11155: LD_ADDR_EXP 75
11159: PUSH
11160: LD_STRING Simms
11162: PPUSH
11163: LD_EXP 1
11167: NOT
11168: PPUSH
11169: LD_STRING 10c_
11171: PPUSH
11172: CALL 66023 0 3
11176: ST_TO_ADDR
// if not Simms then
11177: LD_EXP 75
11181: NOT
11182: IFFALSE 11212
// begin uc_nation := 1 ;
11184: LD_ADDR_OWVAR 21
11188: PUSH
11189: LD_INT 1
11191: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11192: LD_INT 2
11194: PPUSH
11195: LD_INT 10
11197: PPUSH
11198: CALL_OW 384
// Simms := CreateHuman ;
11202: LD_ADDR_EXP 75
11206: PUSH
11207: CALL_OW 44
11211: ST_TO_ADDR
// end ; uc_nation := 3 ;
11212: LD_ADDR_OWVAR 21
11216: PUSH
11217: LD_INT 3
11219: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11220: LD_ADDR_EXP 76
11224: PUSH
11225: LD_STRING Kirilenkova
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11233: LD_ADDR_EXP 90
11237: PUSH
11238: LD_STRING Oblukov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11246: LD_ADDR_EXP 77
11250: PUSH
11251: LD_STRING Dolgov
11253: PPUSH
11254: CALL_OW 25
11258: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11259: LD_ADDR_EXP 78
11263: PUSH
11264: LD_STRING Petrosyan
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11272: LD_ADDR_EXP 89
11276: PUSH
11277: LD_STRING Scholtze
11279: PPUSH
11280: CALL_OW 25
11284: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11285: LD_ADDR_EXP 88
11289: PUSH
11290: LD_STRING Kapitsova
11292: PPUSH
11293: CALL_OW 25
11297: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11298: LD_ADDR_EXP 79
11302: PUSH
11303: LD_STRING Petrovova
11305: PPUSH
11306: CALL_OW 25
11310: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11311: LD_ADDR_EXP 80
11315: PUSH
11316: LD_STRING Kuzmov
11318: PPUSH
11319: CALL_OW 25
11323: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11324: LD_ADDR_EXP 87
11328: PUSH
11329: LD_STRING Karamazov
11331: PPUSH
11332: CALL_OW 25
11336: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11337: LD_STRING 13_Lipshchin_1
11339: PPUSH
11340: LD_INT 0
11342: PPUSH
11343: CALL_OW 30
11347: IFFALSE 11362
// Lipshchin := NewCharacter ( Lipshchin ) ;
11349: LD_ADDR_EXP 81
11353: PUSH
11354: LD_STRING Lipshchin
11356: PPUSH
11357: CALL_OW 25
11361: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11362: LD_STRING 13_Titov_1
11364: PPUSH
11365: LD_INT 0
11367: PPUSH
11368: CALL_OW 30
11372: IFFALSE 11387
// Titov := NewCharacter ( Titov ) ;
11374: LD_ADDR_EXP 83
11378: PUSH
11379: LD_STRING Titov
11381: PPUSH
11382: CALL_OW 25
11386: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11387: LD_STRING 13_Gnyevko_1
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 30
11397: IFFALSE 11412
// Gnyevko := NewCharacter ( Gnyevko ) ;
11399: LD_ADDR_EXP 82
11403: PUSH
11404: LD_STRING Gnyevko
11406: PPUSH
11407: CALL_OW 25
11411: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11412: LD_STRING 13_Xavier_1
11414: PPUSH
11415: LD_INT 0
11417: PPUSH
11418: CALL_OW 30
11422: IFFALSE 11437
// Xavier := NewCharacter ( Xavier2 ) ;
11424: LD_ADDR_EXP 84
11428: PUSH
11429: LD_STRING Xavier2
11431: PPUSH
11432: CALL_OW 25
11436: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11437: LD_STRING 13_Belkov_1
11439: PPUSH
11440: LD_INT 0
11442: PPUSH
11443: CALL_OW 30
11447: IFFALSE 11462
// Belkov := NewCharacter ( Belkov ) ;
11449: LD_ADDR_EXP 85
11453: PUSH
11454: LD_STRING Belkov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// if not BurlakStatus then
11462: LD_EXP 9
11466: NOT
11467: IFFALSE 11482
// Burlak = NewCharacter ( Burlak ) ;
11469: LD_ADDR_EXP 86
11473: PUSH
11474: LD_STRING Burlak
11476: PPUSH
11477: CALL_OW 25
11481: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11482: LD_ADDR_VAR 0 3
11486: PUSH
11487: LD_EXP 74
11491: PUSH
11492: LD_EXP 76
11496: PUSH
11497: LD_EXP 90
11501: PUSH
11502: LD_EXP 77
11506: PUSH
11507: LD_EXP 78
11511: PUSH
11512: LD_EXP 89
11516: PUSH
11517: LD_EXP 88
11521: PUSH
11522: LD_EXP 79
11526: PUSH
11527: LD_EXP 80
11531: PUSH
11532: LD_EXP 87
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// if Simms then
11549: LD_EXP 75
11553: IFFALSE 11571
// tmp := tmp ^ Simms ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_VAR 0 3
11564: PUSH
11565: LD_EXP 75
11569: ADD
11570: ST_TO_ADDR
// if Titov then
11571: LD_EXP 83
11575: IFFALSE 11593
// tmp := tmp ^ Titov ;
11577: LD_ADDR_VAR 0 3
11581: PUSH
11582: LD_VAR 0 3
11586: PUSH
11587: LD_EXP 83
11591: ADD
11592: ST_TO_ADDR
// if Lipshchin then
11593: LD_EXP 81
11597: IFFALSE 11615
// tmp := tmp ^ Lipshchin ;
11599: LD_ADDR_VAR 0 3
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_EXP 81
11613: ADD
11614: ST_TO_ADDR
// if Gnyevko then
11615: LD_EXP 82
11619: IFFALSE 11637
// tmp := tmp ^ Gnyevko ;
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: LD_VAR 0 3
11630: PUSH
11631: LD_EXP 82
11635: ADD
11636: ST_TO_ADDR
// if Xavier then
11637: LD_EXP 84
11641: IFFALSE 11659
// tmp := tmp ^ Xavier ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: LD_EXP 84
11657: ADD
11658: ST_TO_ADDR
// if Belkov then
11659: LD_EXP 85
11663: IFFALSE 11681
// tmp := tmp ^ Belkov ;
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_VAR 0 3
11674: PUSH
11675: LD_EXP 85
11679: ADD
11680: ST_TO_ADDR
// if Burlak then
11681: LD_EXP 86
11685: IFFALSE 11703
// tmp := tmp ^ Burlak ;
11687: LD_ADDR_VAR 0 3
11691: PUSH
11692: LD_VAR 0 3
11696: PUSH
11697: LD_EXP 86
11701: ADD
11702: ST_TO_ADDR
// for i = 1 to 11 do
11703: LD_ADDR_VAR 0 2
11707: PUSH
11708: DOUBLE
11709: LD_INT 1
11711: DEC
11712: ST_TO_ADDR
11713: LD_INT 11
11715: PUSH
11716: FOR_TO
11717: IFFALSE 11783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11719: LD_ADDR_OWVAR 21
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 1
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 2
11753: PUSH
11754: LD_INT 2
11756: DIV
11757: PPUSH
11758: LD_INT 10
11760: PPUSH
11761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11765: LD_ADDR_VAR 0 3
11769: PUSH
11770: LD_VAR 0 3
11774: PUSH
11775: CALL_OW 44
11779: ADD
11780: ST_TO_ADDR
// end ;
11781: GO 11716
11783: POP
11784: POP
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11821
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_INT 260
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: LD_INT 8
11811: PPUSH
11812: LD_INT 0
11814: PPUSH
11815: CALL_OW 50
11819: GO 11795
11821: POP
11822: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11823: LD_ADDR_EXP 97
11827: PUSH
11828: LD_EXP 97
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: LD_INT 22
11838: PUSH
11839: LD_VAR 0 5
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 21
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 69
11873: PUSH
11874: LD_EXP 74
11878: PUSH
11879: LD_EXP 75
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: DIFF
11888: PPUSH
11889: CALL_OW 1
11893: ST_TO_ADDR
// uc_side := 0 ;
11894: LD_ADDR_OWVAR 20
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// uc_nation := 0 ;
11902: LD_ADDR_OWVAR 21
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// for i = 1 to 5 do
11910: LD_ADDR_VAR 0 2
11914: PUSH
11915: DOUBLE
11916: LD_INT 1
11918: DEC
11919: ST_TO_ADDR
11920: LD_INT 5
11922: PUSH
11923: FOR_TO
11924: IFFALSE 11961
// begin InitHc ;
11926: CALL_OW 19
// hc_class := class_apeman ;
11930: LD_ADDR_OWVAR 28
11934: PUSH
11935: LD_INT 12
11937: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11938: CALL_OW 44
11942: PPUSH
11943: LD_INT 299
11945: PPUSH
11946: LD_INT 229
11948: PPUSH
11949: LD_INT 10
11951: PPUSH
11952: LD_INT 0
11954: PPUSH
11955: CALL_OW 50
// end ;
11959: GO 11923
11961: POP
11962: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11963: LD_EXP 74
11967: PPUSH
11968: LD_INT 259
11970: PPUSH
11971: LD_INT 235
11973: PPUSH
11974: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11978: LD_EXP 74
11982: PPUSH
11983: LD_INT 262
11985: PPUSH
11986: LD_INT 235
11988: PPUSH
11989: CALL_OW 178
// if Simms then
11993: LD_EXP 75
11997: IFFALSE 12028
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11999: LD_EXP 75
12003: PPUSH
12004: LD_INT 262
12006: PPUSH
12007: LD_INT 235
12009: PPUSH
12010: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12014: LD_EXP 75
12018: PPUSH
12019: LD_EXP 74
12023: PPUSH
12024: CALL_OW 179
// end ; end ;
12028: LD_VAR 0 1
12032: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12033: LD_EXP 31
12037: PUSH
12038: LD_EXP 23
12042: NOT
12043: AND
12044: IFFALSE 12220
12046: GO 12048
12048: DISABLE
12049: LD_INT 0
12051: PPUSH
12052: PPUSH
12053: PPUSH
// begin enable ;
12054: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 81
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 2
12072: PUSH
12073: LD_INT 32
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 30
12085: PUSH
12086: LD_INT 30
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 28
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 49
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 34
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 34
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 69
12150: ST_TO_ADDR
// if not tmp then
12151: LD_VAR 0 2
12155: NOT
12156: IFFALSE 12160
// exit ;
12158: GO 12220
// target := tmp [ rand ( 1 , tmp ) ] ;
12160: LD_ADDR_VAR 0 3
12164: PUSH
12165: LD_VAR 0 2
12169: PUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_VAR 0 2
12177: PPUSH
12178: CALL_OW 12
12182: ARRAY
12183: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12184: LD_VAR 0 3
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 1
12196: EQUAL
12197: IFFALSE 12208
// CenterNowOnUnits ( target ) ;
12199: LD_VAR 0 3
12203: PPUSH
12204: CALL_OW 87
// SetLives ( target , 0 ) ;
12208: LD_VAR 0 3
12212: PPUSH
12213: LD_INT 0
12215: PPUSH
12216: CALL_OW 234
// end ;
12220: PPOPN 3
12222: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12223: LD_EXP 23
12227: NOT
12228: PUSH
12229: LD_EXP 31
12233: AND
12234: IFFALSE 12760
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin uc_side := 7 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 7
12251: ST_TO_ADDR
// uc_nation := 1 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 125
12267: PUSH
12268: LD_INT 163
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 185
12277: PUSH
12278: LD_INT 168
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 111
12287: PUSH
12288: LD_INT 97
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: PPUSH
12300: CALL 103577 0 1
12304: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12305: LD_ADDR_EXP 91
12309: PUSH
12310: EMPTY
12311: ST_TO_ADDR
// for i = 1 to Difficulty do
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: DOUBLE
12318: LD_INT 1
12320: DEC
12321: ST_TO_ADDR
12322: LD_OWVAR 67
12326: PUSH
12327: FOR_TO
12328: IFFALSE 12486
// begin InitHc ;
12330: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12334: LD_INT 0
12336: PPUSH
12337: LD_INT 8
12339: PPUSH
12340: CALL_OW 381
// un := CreateHuman ;
12344: LD_ADDR_VAR 0 2
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 258
12361: PPUSH
12362: LD_INT 267
12364: PPUSH
12365: LD_INT 4
12367: PPUSH
12368: LD_INT 0
12370: PPUSH
12371: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12375: LD_ADDR_EXP 91
12379: PUSH
12380: LD_EXP 91
12384: PUSH
12385: LD_VAR 0 2
12389: UNION
12390: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12391: LD_VAR 0 2
12395: PPUSH
12396: LD_VAR 0 3
12400: PUSH
12401: LD_VAR 0 1
12405: ARRAY
12406: PUSH
12407: LD_INT 1
12409: ARRAY
12410: PPUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_VAR 0 1
12420: ARRAY
12421: PUSH
12422: LD_INT 2
12424: ARRAY
12425: PPUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ARRAY
12451: PUSH
12452: LD_INT 1
12454: ARRAY
12455: PPUSH
12456: LD_VAR 0 3
12460: PUSH
12461: LD_VAR 0 1
12465: ARRAY
12466: PUSH
12467: LD_INT 2
12469: ARRAY
12470: PPUSH
12471: CALL_OW 171
// AddComInvisible ( un ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL_OW 212
// end ;
12484: GO 12327
12486: POP
12487: POP
// repeat wait ( 0 0$20 ) ;
12488: LD_INT 700
12490: PPUSH
12491: CALL_OW 67
// for i in allianceSpecialForce do
12495: LD_ADDR_VAR 0 1
12499: PUSH
12500: LD_EXP 91
12504: PUSH
12505: FOR_IN
12506: IFFALSE 12745
// begin if IsInvisible ( i ) then
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 571
12517: IFFALSE 12714
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 50
12536: PUSH
12537: EMPTY
12538: LIST
12539: PUSH
12540: LD_INT 56
12542: PUSH
12543: EMPTY
12544: LIST
12545: PUSH
12546: LD_INT 91
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 30
12559: PUSH
12560: LD_INT 35
12562: PUSH
12563: LD_INT 40
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: LIST
12570: LIST
12571: PUSH
12572: LD_OWVAR 67
12576: ARRAY
12577: PUSH
12578: EMPTY
12579: LIST
12580: LIST
12581: LIST
12582: PUSH
12583: LD_INT 2
12585: PUSH
12586: LD_INT 25
12588: PUSH
12589: LD_INT 1
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: LD_INT 25
12598: PUSH
12599: LD_INT 2
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PUSH
12606: LD_INT 25
12608: PUSH
12609: LD_INT 3
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PUSH
12616: LD_INT 25
12618: PUSH
12619: LD_INT 4
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 25
12628: PUSH
12629: LD_INT 5
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 25
12638: PUSH
12639: LD_INT 8
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: LIST
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 69
12666: ST_TO_ADDR
// if not tmp then
12667: LD_VAR 0 3
12671: NOT
12672: IFFALSE 12676
// continue ;
12674: GO 12505
// if Prob ( 30 * Difficulty ) then
12676: LD_INT 30
12678: PUSH
12679: LD_OWVAR 67
12683: MUL
12684: PPUSH
12685: CALL_OW 13
12689: IFFALSE 12714
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12691: LD_VAR 0 3
12695: PUSH
12696: LD_INT 1
12698: PPUSH
12699: LD_VAR 0 3
12703: PPUSH
12704: CALL_OW 12
12708: ARRAY
12709: PPUSH
12710: CALL 31583 0 1
// end ; if IsDead ( i ) then
12714: LD_VAR 0 1
12718: PPUSH
12719: CALL_OW 301
12723: IFFALSE 12743
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12725: LD_ADDR_EXP 91
12729: PUSH
12730: LD_EXP 91
12734: PUSH
12735: LD_VAR 0 1
12739: DIFF
12740: ST_TO_ADDR
// continue ;
12741: GO 12505
// end ; end ;
12743: GO 12505
12745: POP
12746: POP
// until allianceDestroyed or not allianceSpecialForce ;
12747: LD_EXP 23
12751: PUSH
12752: LD_EXP 91
12756: NOT
12757: OR
12758: IFFALSE 12488
// end ;
12760: PPOPN 3
12762: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12763: LD_EXP 23
12767: NOT
12768: PUSH
12769: LD_EXP 31
12773: AND
12774: IFFALSE 13745
12776: GO 12778
12778: DISABLE
12779: LD_INT 0
12781: PPUSH
12782: PPUSH
12783: PPUSH
12784: PPUSH
// begin enable ;
12785: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12786: LD_INT 22
12788: PUSH
12789: LD_INT 7
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 30
12798: PUSH
12799: LD_INT 3
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PPUSH
12810: CALL_OW 69
12814: NOT
12815: IFFALSE 12819
// exit ;
12817: GO 13745
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 4
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_INT 7
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 30
12836: PUSH
12837: LD_INT 34
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: ST_TO_ADDR
// if Prob ( 40 ) then
12853: LD_INT 40
12855: PPUSH
12856: CALL_OW 13
12860: IFFALSE 12987
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12862: LD_INT 1
12864: PPUSH
12865: LD_INT 5
12867: PUSH
12868: LD_INT 3
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: LD_INT 6
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: PUSH
12883: LD_INT 5
12885: PUSH
12886: LD_INT 3
12888: PUSH
12889: LD_INT 2
12891: PUSH
12892: LD_INT 6
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: PUSH
12901: LD_INT 5
12903: PUSH
12904: LD_INT 3
12906: PUSH
12907: LD_INT 2
12909: PUSH
12910: LD_INT 6
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: PUSH
12919: LD_INT 24
12921: PUSH
12922: LD_INT 3
12924: PUSH
12925: LD_INT 3
12927: PUSH
12928: LD_INT 45
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: PUSH
12937: LD_INT 24
12939: PUSH
12940: LD_INT 3
12942: PUSH
12943: LD_INT 3
12945: PUSH
12946: LD_INT 47
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 24
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: LD_INT 3
12963: PUSH
12964: LD_INT 45
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PUSH
12973: EMPTY
12974: LIST
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: PPUSH
12981: CALL 59635 0 2
// end else
12985: GO 13110
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12987: LD_INT 1
12989: PPUSH
12990: LD_INT 24
12992: PUSH
12993: LD_INT 3
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: LD_INT 47
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PUSH
13008: LD_INT 24
13010: PUSH
13011: LD_INT 3
13013: PUSH
13014: LD_INT 3
13016: PUSH
13017: LD_INT 47
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: PUSH
13026: LD_INT 5
13028: PUSH
13029: LD_INT 3
13031: PUSH
13032: LD_INT 2
13034: PUSH
13035: LD_INT 9
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 5
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 2
13052: PUSH
13053: LD_INT 9
13055: PUSH
13056: EMPTY
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 24
13064: PUSH
13065: LD_INT 1
13067: PUSH
13068: LD_INT 3
13070: PUSH
13071: LD_INT 45
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: PUSH
13080: LD_INT 24
13082: PUSH
13083: LD_INT 1
13085: PUSH
13086: LD_INT 3
13088: PUSH
13089: LD_INT 45
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL 59635 0 2
// end ; if Difficulty > 1 then
13110: LD_OWVAR 67
13114: PUSH
13115: LD_INT 1
13117: GREATER
13118: IFFALSE 13148
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13120: LD_INT 1
13122: PPUSH
13123: LD_INT 24
13125: PUSH
13126: LD_INT 3
13128: PUSH
13129: LD_INT 3
13131: PUSH
13132: LD_INT 47
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: PUSH
13141: EMPTY
13142: LIST
13143: PPUSH
13144: CALL 59635 0 2
// repeat wait ( 0 0$1 ) ;
13148: LD_INT 35
13150: PPUSH
13151: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13155: LD_INT 1
13157: PPUSH
13158: LD_INT 1
13160: PPUSH
13161: CALL 61053 0 2
13165: PUSH
13166: LD_INT 6
13168: PUSH
13169: LD_INT 7
13171: PUSH
13172: LD_INT 7
13174: PUSH
13175: LD_INT 7
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: PUSH
13184: LD_OWVAR 67
13188: ARRAY
13189: GREATEREQUAL
13190: IFFALSE 13148
// wait ( 0 0$40 ) ;
13192: LD_INT 1400
13194: PPUSH
13195: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 1
13206: PPUSH
13207: LD_INT 1
13209: PPUSH
13210: CALL 61053 0 2
13214: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13215: LD_ADDR_EXP 116
13219: PUSH
13220: LD_EXP 116
13224: PPUSH
13225: LD_INT 1
13227: PPUSH
13228: LD_EXP 116
13232: PUSH
13233: LD_INT 1
13235: ARRAY
13236: PUSH
13237: LD_VAR 0 2
13241: DIFF
13242: PPUSH
13243: CALL_OW 1
13247: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13248: LD_ADDR_VAR 0 3
13252: PUSH
13253: LD_INT 0
13255: PPUSH
13256: LD_INT 1
13258: PPUSH
13259: CALL_OW 12
13263: ST_TO_ADDR
// if target then
13264: LD_VAR 0 3
13268: IFFALSE 13434
// begin for i in tmp do
13270: LD_ADDR_VAR 0 1
13274: PUSH
13275: LD_VAR 0 2
13279: PUSH
13280: FOR_IN
13281: IFFALSE 13306
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_INT 179
13290: PPUSH
13291: LD_INT 209
13293: PPUSH
13294: LD_INT 8
13296: PPUSH
13297: LD_INT 1
13299: PPUSH
13300: CALL_OW 483
13304: GO 13280
13306: POP
13307: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13308: LD_ADDR_VAR 0 2
13312: PUSH
13313: LD_VAR 0 2
13317: PPUSH
13318: LD_INT 24
13320: PUSH
13321: LD_INT 250
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PPUSH
13328: CALL_OW 72
13332: ST_TO_ADDR
// for i in tmp do
13333: LD_ADDR_VAR 0 1
13337: PUSH
13338: LD_VAR 0 2
13342: PUSH
13343: FOR_IN
13344: IFFALSE 13384
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13346: LD_VAR 0 1
13350: PPUSH
13351: LD_INT 179
13353: PPUSH
13354: LD_INT 209
13356: PPUSH
13357: CALL_OW 297
13361: PUSH
13362: LD_INT 9
13364: GREATER
13365: IFFALSE 13382
// ComMoveXY ( i , 179 , 209 ) ;
13367: LD_VAR 0 1
13371: PPUSH
13372: LD_INT 179
13374: PPUSH
13375: LD_INT 209
13377: PPUSH
13378: CALL_OW 111
13382: GO 13343
13384: POP
13385: POP
// wait ( 0 0$1 ) ;
13386: LD_INT 35
13388: PPUSH
13389: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13393: LD_VAR 0 2
13397: PPUSH
13398: LD_INT 92
13400: PUSH
13401: LD_INT 179
13403: PUSH
13404: LD_INT 209
13406: PUSH
13407: LD_INT 9
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: LIST
13414: LIST
13415: PPUSH
13416: CALL_OW 72
13420: PUSH
13421: LD_VAR 0 2
13425: PUSH
13426: LD_INT 1
13428: MINUS
13429: GREATEREQUAL
13430: IFFALSE 13308
// end else
13432: GO 13596
// begin for i in tmp do
13434: LD_ADDR_VAR 0 1
13438: PUSH
13439: LD_VAR 0 2
13443: PUSH
13444: FOR_IN
13445: IFFALSE 13470
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13447: LD_VAR 0 1
13451: PPUSH
13452: LD_INT 285
13454: PPUSH
13455: LD_INT 163
13457: PPUSH
13458: LD_INT 8
13460: PPUSH
13461: LD_INT 1
13463: PPUSH
13464: CALL_OW 483
13468: GO 13444
13470: POP
13471: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13472: LD_ADDR_VAR 0 2
13476: PUSH
13477: LD_VAR 0 2
13481: PPUSH
13482: LD_INT 24
13484: PUSH
13485: LD_INT 250
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: PPUSH
13492: CALL_OW 72
13496: ST_TO_ADDR
// for i in tmp do
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: FOR_IN
13508: IFFALSE 13548
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13510: LD_VAR 0 1
13514: PPUSH
13515: LD_INT 285
13517: PPUSH
13518: LD_INT 163
13520: PPUSH
13521: CALL_OW 297
13525: PUSH
13526: LD_INT 9
13528: GREATER
13529: IFFALSE 13546
// ComMoveXY ( i , 285 , 163 ) ;
13531: LD_VAR 0 1
13535: PPUSH
13536: LD_INT 285
13538: PPUSH
13539: LD_INT 163
13541: PPUSH
13542: CALL_OW 111
13546: GO 13507
13548: POP
13549: POP
// wait ( 0 0$1 ) ;
13550: LD_INT 35
13552: PPUSH
13553: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13557: LD_VAR 0 2
13561: PPUSH
13562: LD_INT 92
13564: PUSH
13565: LD_INT 285
13567: PUSH
13568: LD_INT 163
13570: PUSH
13571: LD_INT 9
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: PPUSH
13580: CALL_OW 72
13584: PUSH
13585: LD_VAR 0 2
13589: PUSH
13590: LD_INT 1
13592: MINUS
13593: GREATEREQUAL
13594: IFFALSE 13472
// end ; repeat wait ( 0 0$1 ) ;
13596: LD_INT 35
13598: PPUSH
13599: CALL_OW 67
// for i in tmp do
13603: LD_ADDR_VAR 0 1
13607: PUSH
13608: LD_VAR 0 2
13612: PUSH
13613: FOR_IN
13614: IFFALSE 13736
// if GetLives ( i ) > 251 then
13616: LD_VAR 0 1
13620: PPUSH
13621: CALL_OW 256
13625: PUSH
13626: LD_INT 251
13628: GREATER
13629: IFFALSE 13718
// begin if GetWeapon ( i ) = ru_time_lapser then
13631: LD_VAR 0 1
13635: PPUSH
13636: CALL_OW 264
13640: PUSH
13641: LD_INT 49
13643: EQUAL
13644: IFFALSE 13682
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 81
13653: PUSH
13654: LD_INT 7
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PPUSH
13661: CALL_OW 69
13665: PPUSH
13666: LD_VAR 0 1
13670: PPUSH
13671: CALL_OW 74
13675: PPUSH
13676: CALL_OW 112
13680: GO 13716
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 81
13689: PUSH
13690: LD_INT 7
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PPUSH
13697: CALL_OW 69
13701: PPUSH
13702: LD_VAR 0 1
13706: PPUSH
13707: CALL_OW 74
13711: PPUSH
13712: CALL_OW 115
// end else
13716: GO 13734
// tmp := tmp diff i ;
13718: LD_ADDR_VAR 0 2
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: LD_VAR 0 1
13732: DIFF
13733: ST_TO_ADDR
13734: GO 13613
13736: POP
13737: POP
// until not tmp ;
13738: LD_VAR 0 2
13742: NOT
13743: IFFALSE 13596
// end ; end_of_file
13745: PPOPN 4
13747: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13748: LD_INT 0
13750: PPUSH
13751: PPUSH
13752: PPUSH
13753: PPUSH
// missionStage := 13 ;
13754: LD_ADDR_EXP 15
13758: PUSH
13759: LD_INT 13
13761: ST_TO_ADDR
// uc_side := 2 ;
13762: LD_ADDR_OWVAR 20
13766: PUSH
13767: LD_INT 2
13769: ST_TO_ADDR
// uc_nation := 2 ;
13770: LD_ADDR_OWVAR 21
13774: PUSH
13775: LD_INT 2
13777: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13778: LD_ADDR_EXP 92
13782: PUSH
13783: LD_STRING Omar
13785: PPUSH
13786: CALL_OW 25
13790: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13791: LD_EXP 92
13795: PPUSH
13796: LD_INT 4
13798: PPUSH
13799: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13803: LD_EXP 92
13807: PPUSH
13808: LD_INT 242
13810: PPUSH
13811: LD_INT 75
13813: PPUSH
13814: LD_INT 0
13816: PPUSH
13817: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13821: LD_ADDR_EXP 93
13825: PUSH
13826: LD_STRING Heike
13828: PPUSH
13829: CALL_OW 25
13833: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13834: LD_INT 14
13836: PPUSH
13837: LD_INT 3
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: LD_INT 27
13845: PPUSH
13846: LD_INT 100
13848: PPUSH
13849: CALL 71038 0 5
// veh := CreateVehicle ;
13853: LD_ADDR_VAR 0 3
13857: PUSH
13858: CALL_OW 45
13862: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
13863: LD_VAR 0 3
13867: PPUSH
13868: LD_INT 2
13870: NEG
13871: PPUSH
13872: CALL_OW 242
// SetDir ( veh , 4 ) ;
13876: LD_VAR 0 3
13880: PPUSH
13881: LD_INT 4
13883: PPUSH
13884: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13888: LD_VAR 0 3
13892: PPUSH
13893: LD_INT 241
13895: PPUSH
13896: LD_INT 72
13898: PPUSH
13899: LD_INT 0
13901: PPUSH
13902: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13906: LD_EXP 93
13910: PPUSH
13911: LD_VAR 0 3
13915: PPUSH
13916: CALL_OW 52
// if KhatamStatus then
13920: LD_EXP 8
13924: IFFALSE 13987
// begin Khatam := NewCharacter ( Khatam ) ;
13926: LD_ADDR_EXP 94
13930: PUSH
13931: LD_STRING Khatam
13933: PPUSH
13934: CALL_OW 25
13938: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13939: LD_EXP 94
13943: PPUSH
13944: LD_INT 245
13946: PPUSH
13947: LD_INT 78
13949: PPUSH
13950: LD_INT 3
13952: PPUSH
13953: LD_INT 0
13955: PPUSH
13956: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13960: LD_EXP 94
13964: PPUSH
13965: LD_INT 4
13967: PPUSH
13968: LD_INT 10
13970: PPUSH
13971: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
13975: LD_EXP 94
13979: PPUSH
13980: LD_INT 4
13982: PPUSH
13983: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
13987: LD_ADDR_VAR 0 2
13991: PUSH
13992: DOUBLE
13993: LD_INT 1
13995: DEC
13996: ST_TO_ADDR
13997: LD_INT 2
13999: PUSH
14000: LD_INT 2
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: LD_INT 3
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: PUSH
14015: LD_OWVAR 67
14019: ARRAY
14020: PUSH
14021: FOR_TO
14022: IFFALSE 14088
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14024: LD_INT 0
14026: PPUSH
14027: LD_INT 6
14029: PUSH
14030: LD_OWVAR 67
14034: PLUS
14035: PPUSH
14036: CALL_OW 384
// un := CreateHuman ;
14040: LD_ADDR_VAR 0 4
14044: PUSH
14045: CALL_OW 44
14049: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14050: LD_VAR 0 4
14054: PPUSH
14055: LD_INT 28
14057: PUSH
14058: LD_INT 29
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PUSH
14065: LD_VAR 0 2
14069: PUSH
14070: LD_INT 2
14072: MOD
14073: PUSH
14074: LD_INT 1
14076: PLUS
14077: ARRAY
14078: PPUSH
14079: LD_INT 0
14081: PPUSH
14082: CALL_OW 49
// end ;
14086: GO 14021
14088: POP
14089: POP
// for i = 1 to 6 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 6
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14149
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 6
14111: PUSH
14112: LD_OWVAR 67
14116: PLUS
14117: PPUSH
14118: CALL_OW 381
// un := CreateHuman ;
14122: LD_ADDR_VAR 0 4
14126: PUSH
14127: CALL_OW 44
14131: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
14132: LD_VAR 0 4
14136: PPUSH
14137: LD_INT 32
14139: PPUSH
14140: LD_INT 0
14142: PPUSH
14143: CALL_OW 49
// end ;
14147: GO 14103
14149: POP
14150: POP
// for i = 1 to 3 do
14151: LD_ADDR_VAR 0 2
14155: PUSH
14156: DOUBLE
14157: LD_INT 1
14159: DEC
14160: ST_TO_ADDR
14161: LD_INT 3
14163: PUSH
14164: FOR_TO
14165: IFFALSE 14213
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
14167: LD_INT 0
14169: PPUSH
14170: LD_INT 8
14172: PPUSH
14173: LD_INT 6
14175: PUSH
14176: LD_OWVAR 67
14180: PLUS
14181: PPUSH
14182: CALL_OW 380
// un := CreateHuman ;
14186: LD_ADDR_VAR 0 4
14190: PUSH
14191: CALL_OW 44
14195: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
14196: LD_VAR 0 4
14200: PPUSH
14201: LD_INT 32
14203: PPUSH
14204: LD_INT 0
14206: PPUSH
14207: CALL_OW 49
// end ;
14211: GO 14164
14213: POP
14214: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
14215: LD_ADDR_VAR 0 2
14219: PUSH
14220: DOUBLE
14221: LD_INT 1
14223: DEC
14224: ST_TO_ADDR
14225: LD_INT 2
14227: PUSH
14228: LD_INT 3
14230: PUSH
14231: LD_INT 4
14233: PUSH
14234: LD_INT 4
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: PUSH
14243: LD_OWVAR 67
14247: ARRAY
14248: PUSH
14249: FOR_TO
14250: IFFALSE 14340
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14252: LD_INT 14
14254: PPUSH
14255: LD_INT 2
14257: PPUSH
14258: LD_INT 1
14260: PPUSH
14261: LD_INT 28
14263: PPUSH
14264: LD_INT 80
14266: PPUSH
14267: CALL 71038 0 5
// veh := CreateVehicle ;
14271: LD_ADDR_VAR 0 3
14275: PUSH
14276: CALL_OW 45
14280: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14281: LD_VAR 0 3
14285: PPUSH
14286: LD_INT 3
14288: PPUSH
14289: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14293: LD_VAR 0 3
14297: PPUSH
14298: LD_INT 29
14300: PPUSH
14301: LD_INT 0
14303: PPUSH
14304: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
14308: LD_INT 0
14310: PPUSH
14311: LD_INT 6
14313: PUSH
14314: LD_OWVAR 67
14318: PLUS
14319: PPUSH
14320: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14324: CALL_OW 44
14328: PPUSH
14329: LD_VAR 0 3
14333: PPUSH
14334: CALL_OW 52
// end ;
14338: GO 14249
14340: POP
14341: POP
// for i = 1 to 5 + Difficulty do
14342: LD_ADDR_VAR 0 2
14346: PUSH
14347: DOUBLE
14348: LD_INT 1
14350: DEC
14351: ST_TO_ADDR
14352: LD_INT 5
14354: PUSH
14355: LD_OWVAR 67
14359: PLUS
14360: PUSH
14361: FOR_TO
14362: IFFALSE 14489
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14364: LD_INT 14
14366: PPUSH
14367: LD_INT 1
14369: PPUSH
14370: LD_INT 3
14372: PPUSH
14373: CALL_OW 12
14377: PPUSH
14378: LD_INT 1
14380: PPUSH
14381: LD_INT 28
14383: PUSH
14384: LD_INT 26
14386: PUSH
14387: LD_INT 27
14389: PUSH
14390: LD_INT 25
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: PUSH
14399: LD_VAR 0 2
14403: PUSH
14404: LD_INT 4
14406: MOD
14407: PUSH
14408: LD_INT 1
14410: PLUS
14411: ARRAY
14412: PPUSH
14413: LD_INT 80
14415: PPUSH
14416: CALL 71038 0 5
// veh := CreateVehicle ;
14420: LD_ADDR_VAR 0 3
14424: PUSH
14425: CALL_OW 45
14429: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14430: LD_VAR 0 3
14434: PPUSH
14435: LD_INT 4
14437: PPUSH
14438: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14442: LD_VAR 0 3
14446: PPUSH
14447: LD_INT 28
14449: PPUSH
14450: LD_INT 0
14452: PPUSH
14453: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
14457: LD_INT 0
14459: PPUSH
14460: LD_INT 6
14462: PUSH
14463: LD_OWVAR 67
14467: PLUS
14468: PPUSH
14469: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14473: CALL_OW 44
14477: PPUSH
14478: LD_VAR 0 3
14482: PPUSH
14483: CALL_OW 52
// end ;
14487: GO 14361
14489: POP
14490: POP
// for i = 1 to Difficulty do
14491: LD_ADDR_VAR 0 2
14495: PUSH
14496: DOUBLE
14497: LD_INT 1
14499: DEC
14500: ST_TO_ADDR
14501: LD_OWVAR 67
14505: PUSH
14506: FOR_TO
14507: IFFALSE 14567
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14509: LD_INT 14
14511: PPUSH
14512: LD_INT 3
14514: PPUSH
14515: LD_INT 5
14517: PPUSH
14518: LD_INT 29
14520: PPUSH
14521: LD_INT 80
14523: PPUSH
14524: CALL 71038 0 5
// veh := CreateVehicle ;
14528: LD_ADDR_VAR 0 3
14532: PUSH
14533: CALL_OW 45
14537: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14538: LD_VAR 0 3
14542: PPUSH
14543: LD_INT 4
14545: PPUSH
14546: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14550: LD_VAR 0 3
14554: PPUSH
14555: LD_INT 28
14557: PPUSH
14558: LD_INT 0
14560: PPUSH
14561: CALL_OW 49
// end ;
14565: GO 14506
14567: POP
14568: POP
// end ;
14569: LD_VAR 0 1
14573: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
14574: LD_INT 22
14576: PUSH
14577: LD_INT 2
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: PPUSH
14584: CALL_OW 69
14588: IFFALSE 14967
14590: GO 14592
14592: DISABLE
14593: LD_INT 0
14595: PPUSH
14596: PPUSH
14597: PPUSH
14598: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14599: LD_ADDR_VAR 0 3
14603: PUSH
14604: LD_INT 22
14606: PUSH
14607: LD_INT 2
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: LD_INT 25
14616: PUSH
14617: LD_INT 4
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PPUSH
14628: CALL_OW 69
14632: PUSH
14633: LD_EXP 94
14637: DIFF
14638: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14639: LD_ADDR_VAR 0 2
14643: PUSH
14644: LD_INT 22
14646: PUSH
14647: LD_INT 2
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PPUSH
14654: CALL_OW 69
14658: PUSH
14659: LD_EXP 94
14663: PUSH
14664: LD_VAR 0 3
14668: UNION
14669: DIFF
14670: ST_TO_ADDR
// if Khatam then
14671: LD_EXP 94
14675: IFFALSE 14692
// ComMoveXY ( Khatam , 211 , 92 ) ;
14677: LD_EXP 94
14681: PPUSH
14682: LD_INT 211
14684: PPUSH
14685: LD_INT 92
14687: PPUSH
14688: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14692: LD_INT 197
14694: PPUSH
14695: LD_INT 80
14697: PPUSH
14698: LD_INT 2
14700: PPUSH
14701: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14705: LD_INT 213
14707: PPUSH
14708: LD_INT 90
14710: PPUSH
14711: LD_INT 2
14713: PPUSH
14714: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14718: LD_INT 215
14720: PPUSH
14721: LD_INT 129
14723: PPUSH
14724: LD_INT 2
14726: PPUSH
14727: CALL_OW 441
// if sci then
14731: LD_VAR 0 3
14735: IFFALSE 14756
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14737: LD_VAR 0 3
14741: PUSH
14742: LD_INT 1
14744: ARRAY
14745: PPUSH
14746: LD_INT 197
14748: PPUSH
14749: LD_INT 80
14751: PPUSH
14752: CALL_OW 158
// if sci > 1 then
14756: LD_VAR 0 3
14760: PUSH
14761: LD_INT 1
14763: GREATER
14764: IFFALSE 14785
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14766: LD_VAR 0 3
14770: PUSH
14771: LD_INT 2
14773: ARRAY
14774: PPUSH
14775: LD_INT 213
14777: PPUSH
14778: LD_INT 90
14780: PPUSH
14781: CALL_OW 158
// if sci > 2 then
14785: LD_VAR 0 3
14789: PUSH
14790: LD_INT 2
14792: GREATER
14793: IFFALSE 14814
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14795: LD_VAR 0 3
14799: PUSH
14800: LD_INT 3
14802: ARRAY
14803: PPUSH
14804: LD_INT 215
14806: PPUSH
14807: LD_INT 129
14809: PPUSH
14810: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
14814: LD_VAR 0 2
14818: PPUSH
14819: LD_INT 195
14821: PPUSH
14822: LD_INT 102
14824: PPUSH
14825: CALL_OW 114
// wait ( 0 0$5 ) ;
14829: LD_INT 175
14831: PPUSH
14832: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
14836: LD_INT 70
14838: PPUSH
14839: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_enemy , 2 ] ] ) ;
14843: LD_ADDR_VAR 0 4
14847: PUSH
14848: LD_INT 92
14850: PUSH
14851: LD_INT 195
14853: PUSH
14854: LD_INT 102
14856: PUSH
14857: LD_INT 36
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: PUSH
14866: LD_INT 81
14868: PUSH
14869: LD_INT 2
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: PPUSH
14880: CALL_OW 69
14884: ST_TO_ADDR
// for i in tmp do
14885: LD_ADDR_VAR 0 1
14889: PUSH
14890: LD_VAR 0 2
14894: PUSH
14895: FOR_IN
14896: IFFALSE 14947
// if enemy then
14898: LD_VAR 0 4
14902: IFFALSE 14930
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
14904: LD_VAR 0 1
14908: PPUSH
14909: LD_VAR 0 4
14913: PPUSH
14914: LD_VAR 0 1
14918: PPUSH
14919: CALL_OW 74
14923: PPUSH
14924: CALL_OW 115
14928: GO 14945
// ComAgressiveMove ( i , 195 , 102 ) ;
14930: LD_VAR 0 1
14934: PPUSH
14935: LD_INT 195
14937: PPUSH
14938: LD_INT 102
14940: PPUSH
14941: CALL_OW 114
14945: GO 14895
14947: POP
14948: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
14949: LD_VAR 0 2
14953: PPUSH
14954: LD_INT 50
14956: PUSH
14957: EMPTY
14958: LIST
14959: PPUSH
14960: CALL_OW 72
14964: NOT
14965: IFFALSE 14836
// end ; end_of_file
14967: PPOPN 4
14969: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14970: LD_INT 0
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
14977: PPUSH
14978: PPUSH
14979: PPUSH
14980: PPUSH
// Video ( true ) ;
14981: LD_INT 1
14983: PPUSH
14984: CALL 103444 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14988: LD_ADDR_VAR 0 5
14992: PUSH
14993: LD_INT 7
14995: PPUSH
14996: LD_INT 0
14998: PPUSH
14999: CALL_OW 517
15003: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15004: LD_ADDR_VAR 0 2
15008: PUSH
15009: DOUBLE
15010: LD_INT 1
15012: DEC
15013: ST_TO_ADDR
15014: LD_VAR 0 5
15018: PUSH
15019: LD_INT 1
15021: ARRAY
15022: PUSH
15023: FOR_TO
15024: IFFALSE 15069
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15026: LD_VAR 0 5
15030: PUSH
15031: LD_INT 1
15033: ARRAY
15034: PUSH
15035: LD_VAR 0 2
15039: ARRAY
15040: PPUSH
15041: LD_VAR 0 5
15045: PUSH
15046: LD_INT 2
15048: ARRAY
15049: PUSH
15050: LD_VAR 0 2
15054: ARRAY
15055: PPUSH
15056: LD_INT 1
15058: PPUSH
15059: LD_INT 15
15061: NEG
15062: PPUSH
15063: CALL 103358 0 4
15067: GO 15023
15069: POP
15070: POP
// CenterNowOnUnits ( Powell ) ;
15071: LD_EXP 58
15075: PPUSH
15076: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_EXP 56
15089: PUSH
15090: EMPTY
15091: LIST
15092: ST_TO_ADDR
// if GirlNewVeh then
15093: LD_EXP 57
15097: IFFALSE 15115
// tmp := tmp ^ GirlNewVeh ;
15099: LD_ADDR_VAR 0 5
15103: PUSH
15104: LD_VAR 0 5
15108: PUSH
15109: LD_EXP 57
15113: ADD
15114: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15115: LD_VAR 0 5
15119: PPUSH
15120: LD_INT 60
15122: PPUSH
15123: LD_INT 109
15125: PPUSH
15126: CALL_OW 111
// if KappaStatus then
15130: LD_EXP 2
15134: IFFALSE 15186
// begin Say ( JMM , D1nT-JMM-1 ) ;
15136: LD_EXP 39
15140: PPUSH
15141: LD_STRING D1nT-JMM-1
15143: PPUSH
15144: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15148: LD_EXP 58
15152: PPUSH
15153: LD_STRING D1T-Pow-1
15155: PPUSH
15156: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15160: LD_EXP 39
15164: PPUSH
15165: LD_STRING D1T-JMM-2
15167: PPUSH
15168: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15172: LD_EXP 58
15176: PPUSH
15177: LD_STRING D1T-Pow-2
15179: PPUSH
15180: CALL_OW 88
// end else
15184: GO 15392
// if JMMGirlStatus then
15186: LD_EXP 6
15190: IFFALSE 15335
// begin Say ( JMM , D1T-JMM-1 ) ;
15192: LD_EXP 39
15196: PPUSH
15197: LD_STRING D1T-JMM-1
15199: PPUSH
15200: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15204: LD_EXP 58
15208: PPUSH
15209: LD_STRING D1T-Pow-1
15211: PPUSH
15212: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15216: LD_EXP 39
15220: PPUSH
15221: LD_STRING D1T-JMM-3
15223: PPUSH
15224: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15228: LD_EXP 58
15232: PPUSH
15233: LD_STRING D1T-Pow-3
15235: PPUSH
15236: CALL_OW 88
// if JMMGirl then
15240: LD_EXP 7
15244: IFFALSE 15333
// begin case JMMGirl of 1 :
15246: LD_EXP 7
15250: PUSH
15251: LD_INT 1
15253: DOUBLE
15254: EQUAL
15255: IFTRUE 15259
15257: GO 15274
15259: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15260: LD_EXP 40
15264: PPUSH
15265: LD_STRING D1T-Joan-3
15267: PPUSH
15268: CALL_OW 88
15272: GO 15321
15274: LD_INT 2
15276: DOUBLE
15277: EQUAL
15278: IFTRUE 15282
15280: GO 15297
15282: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15283: LD_EXP 42
15287: PPUSH
15288: LD_STRING D1T-Lisa-3
15290: PPUSH
15291: CALL_OW 88
15295: GO 15321
15297: LD_INT 3
15299: DOUBLE
15300: EQUAL
15301: IFTRUE 15305
15303: GO 15320
15305: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15306: LD_EXP 54
15310: PPUSH
15311: LD_STRING D1T-Con-3
15313: PPUSH
15314: CALL_OW 88
15318: GO 15321
15320: POP
// Say ( Powell , D1T-Pow-4 ) ;
15321: LD_EXP 58
15325: PPUSH
15326: LD_STRING D1T-Pow-4
15328: PPUSH
15329: CALL_OW 88
// end ; end else
15333: GO 15392
// if not FastEnd then
15335: LD_EXP 11
15339: NOT
15340: IFFALSE 15368
// begin Say ( JMM , D1T-JMM-4 ) ;
15342: LD_EXP 39
15346: PPUSH
15347: LD_STRING D1T-JMM-4
15349: PPUSH
15350: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15354: LD_EXP 58
15358: PPUSH
15359: LD_STRING D1T-Pow-5
15361: PPUSH
15362: CALL_OW 88
// end else
15366: GO 15392
// begin Say ( JMM , D1nT-JMM-1 ) ;
15368: LD_EXP 39
15372: PPUSH
15373: LD_STRING D1nT-JMM-1
15375: PPUSH
15376: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15380: LD_EXP 58
15384: PPUSH
15385: LD_STRING D1nT-Pow-1
15387: PPUSH
15388: CALL_OW 88
// end ; repeat wait ( 3 ) ;
15392: LD_INT 3
15394: PPUSH
15395: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15399: LD_EXP 56
15403: PPUSH
15404: CALL_OW 314
15408: NOT
15409: IFFALSE 15392
// ComExitVehicle ( JMM ) ;
15411: LD_EXP 39
15415: PPUSH
15416: CALL_OW 121
// repeat wait ( 3 ) ;
15420: LD_INT 3
15422: PPUSH
15423: CALL_OW 67
// until not IsInUnit ( JMM ) ;
15427: LD_EXP 39
15431: PPUSH
15432: CALL_OW 310
15436: NOT
15437: IFFALSE 15420
// ComMoveXY ( JMM , 60 , 94 ) ;
15439: LD_EXP 39
15443: PPUSH
15444: LD_INT 60
15446: PPUSH
15447: LD_INT 94
15449: PPUSH
15450: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15454: LD_EXP 39
15458: PPUSH
15459: LD_EXP 58
15463: PPUSH
15464: CALL_OW 179
// if Joan then
15468: LD_EXP 40
15472: IFFALSE 15526
// begin ComExitVehicle ( Joan ) ;
15474: LD_EXP 40
15478: PPUSH
15479: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15483: LD_EXP 40
15487: PPUSH
15488: LD_INT 35
15490: PPUSH
15491: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15495: LD_EXP 40
15499: PPUSH
15500: LD_INT 65
15502: PPUSH
15503: LD_INT 104
15505: PPUSH
15506: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15510: LD_EXP 40
15514: PPUSH
15515: LD_EXP 39
15519: PPUSH
15520: CALL_OW 179
// end else
15524: GO 15660
// if Lisa and JMMGirl = 2 then
15526: LD_EXP 42
15530: PUSH
15531: LD_EXP 7
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: AND
15540: IFFALSE 15594
// begin ComExitVehicle ( Lisa ) ;
15542: LD_EXP 42
15546: PPUSH
15547: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15551: LD_EXP 42
15555: PPUSH
15556: LD_INT 35
15558: PPUSH
15559: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15563: LD_EXP 42
15567: PPUSH
15568: LD_INT 65
15570: PPUSH
15571: LD_INT 104
15573: PPUSH
15574: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15578: LD_EXP 42
15582: PPUSH
15583: LD_EXP 39
15587: PPUSH
15588: CALL_OW 179
// end else
15592: GO 15660
// if Connie and JMMGirl = 3 then
15594: LD_EXP 54
15598: PUSH
15599: LD_EXP 7
15603: PUSH
15604: LD_INT 3
15606: EQUAL
15607: AND
15608: IFFALSE 15660
// begin ComExitVehicle ( Connie ) ;
15610: LD_EXP 54
15614: PPUSH
15615: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15619: LD_EXP 54
15623: PPUSH
15624: LD_INT 35
15626: PPUSH
15627: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15631: LD_EXP 54
15635: PPUSH
15636: LD_INT 65
15638: PPUSH
15639: LD_INT 104
15641: PPUSH
15642: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15646: LD_EXP 54
15650: PPUSH
15651: LD_EXP 39
15655: PPUSH
15656: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15660: LD_INT 35
15662: PPUSH
15663: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
15667: LD_EXP 39
15671: PPUSH
15672: LD_EXP 58
15676: PPUSH
15677: CALL_OW 296
15681: PUSH
15682: LD_INT 8
15684: LESS
15685: IFFALSE 15660
// wait ( 0 0$0.5 ) ;
15687: LD_INT 18
15689: PPUSH
15690: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15694: LD_EXP 39
15698: PPUSH
15699: LD_STRING D1-JMM-1
15701: PPUSH
15702: CALL_OW 88
// async ;
15706: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15707: LD_EXP 58
15711: PPUSH
15712: LD_STRING D1-Pow-1
15714: PPUSH
15715: CALL_OW 88
// if not dialogue_skipped then
15719: LD_OWVAR 59
15723: NOT
15724: IFFALSE 15733
// wait ( 0 0$2 ) ;
15726: LD_INT 70
15728: PPUSH
15729: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15733: LD_INT 170
15735: PPUSH
15736: LD_INT 99
15738: PPUSH
15739: LD_INT 1
15741: PPUSH
15742: LD_INT 6
15744: NEG
15745: PPUSH
15746: CALL 103358 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15750: LD_INT 174
15752: PPUSH
15753: LD_INT 115
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: LD_INT 6
15761: NEG
15762: PPUSH
15763: CALL 103358 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15767: LD_INT 169
15769: PPUSH
15770: LD_INT 71
15772: PPUSH
15773: LD_INT 1
15775: PPUSH
15776: LD_INT 6
15778: NEG
15779: PPUSH
15780: CALL 103358 0 4
// if not dialogue_skipped then
15784: LD_OWVAR 59
15788: NOT
15789: IFFALSE 15808
// begin CenterOnXY ( 170 , 99 ) ;
15791: LD_INT 170
15793: PPUSH
15794: LD_INT 99
15796: PPUSH
15797: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15801: LD_INT 80
15803: PPUSH
15804: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15808: LD_INT 75
15810: PPUSH
15811: LD_INT 53
15813: PPUSH
15814: LD_INT 1
15816: PPUSH
15817: LD_INT 9
15819: NEG
15820: PPUSH
15821: CALL 103358 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15825: LD_INT 54
15827: PPUSH
15828: LD_INT 42
15830: PPUSH
15831: LD_INT 1
15833: PPUSH
15834: LD_INT 9
15836: NEG
15837: PPUSH
15838: CALL 103358 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15842: LD_INT 62
15844: PPUSH
15845: LD_INT 51
15847: PPUSH
15848: LD_INT 1
15850: PPUSH
15851: LD_INT 9
15853: NEG
15854: PPUSH
15855: CALL 103358 0 4
// if not dialogue_skipped then
15859: LD_OWVAR 59
15863: NOT
15864: IFFALSE 15883
// begin CenterOnXY ( 75 , 53 ) ;
15866: LD_INT 75
15868: PPUSH
15869: LD_INT 53
15871: PPUSH
15872: CALL_OW 84
// wait ( 0 0$4 ) ;
15876: LD_INT 140
15878: PPUSH
15879: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15883: LD_EXP 58
15887: PPUSH
15888: CALL_OW 87
// if not dialogue_skipped then
15892: LD_OWVAR 59
15896: NOT
15897: IFFALSE 15906
// wait ( 0 0$2 ) ;
15899: LD_INT 70
15901: PPUSH
15902: CALL_OW 67
// sync ;
15906: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15907: LD_EXP 39
15911: PPUSH
15912: LD_STRING D1-JMM-2
15914: PPUSH
15915: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15919: LD_EXP 58
15923: PPUSH
15924: LD_STRING D1-Pow-2
15926: PPUSH
15927: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15931: LD_EXP 39
15935: PPUSH
15936: LD_STRING D1-JMM-3
15938: PPUSH
15939: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15943: LD_EXP 58
15947: PPUSH
15948: LD_STRING D1-Pow-3
15950: PPUSH
15951: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15955: LD_EXP 39
15959: PPUSH
15960: LD_STRING D1-JMM-4
15962: PPUSH
15963: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15967: LD_EXP 58
15971: PPUSH
15972: LD_STRING D1-Pow-4
15974: PPUSH
15975: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15979: LD_EXP 39
15983: PPUSH
15984: LD_STRING D1-JMM-5
15986: PPUSH
15987: CALL_OW 88
// async ;
15991: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15992: LD_EXP 58
15996: PPUSH
15997: LD_STRING D1-Pow-5
15999: PPUSH
16000: CALL_OW 88
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16018
// wait ( 0 0$3.6 ) ;
16011: LD_INT 126
16013: PPUSH
16014: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16018: LD_INT 134
16020: PPUSH
16021: LD_INT 210
16023: PPUSH
16024: LD_INT 1
16026: PPUSH
16027: LD_INT 11
16029: NEG
16030: PPUSH
16031: CALL 103358 0 4
// if not dialogue_skipped then
16035: LD_OWVAR 59
16039: NOT
16040: IFFALSE 16059
// begin CenterOnXY ( 134 , 210 ) ;
16042: LD_INT 134
16044: PPUSH
16045: LD_INT 210
16047: PPUSH
16048: CALL_OW 84
// wait ( 0 0$2 ) ;
16052: LD_INT 70
16054: PPUSH
16055: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16059: LD_INT 101
16061: PPUSH
16062: LD_INT 159
16064: PPUSH
16065: LD_INT 1
16067: PPUSH
16068: LD_INT 10
16070: NEG
16071: PPUSH
16072: CALL 103358 0 4
// if not dialogue_skipped then
16076: LD_OWVAR 59
16080: NOT
16081: IFFALSE 16100
// begin CenterOnXY ( 101 , 159 ) ;
16083: LD_INT 101
16085: PPUSH
16086: LD_INT 159
16088: PPUSH
16089: CALL_OW 84
// wait ( 0 0$2 ) ;
16093: LD_INT 70
16095: PPUSH
16096: CALL_OW 67
// end ; sync ;
16100: SYNC
// CenterNowOnUnits ( Powell ) ;
16101: LD_EXP 58
16105: PPUSH
16106: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16110: LD_ADDR_VAR 0 6
16114: PUSH
16115: LD_INT 1
16117: PUSH
16118: LD_INT 2
16120: PUSH
16121: LD_INT 3
16123: PUSH
16124: LD_INT 4
16126: PUSH
16127: LD_INT 5
16129: PUSH
16130: LD_INT 6
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: LIST
16137: LIST
16138: LIST
16139: LIST
16140: ST_TO_ADDR
// if not dialogue_skipped then
16141: LD_OWVAR 59
16145: NOT
16146: IFFALSE 16315
// begin game_speed := 4 ;
16148: LD_ADDR_OWVAR 65
16152: PUSH
16153: LD_INT 4
16155: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16156: LD_INT 210
16158: PPUSH
16159: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
16163: LD_ADDR_VAR 0 7
16167: PUSH
16168: LD_STRING Q1
16170: PPUSH
16171: LD_VAR 0 6
16175: PPUSH
16176: CALL_OW 98
16180: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
16181: LD_ADDR_VAR 0 7
16185: PUSH
16186: LD_STRING Q1
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL_OW 98
16198: ST_TO_ADDR
// options := options diff dec ;
16199: LD_ADDR_VAR 0 6
16203: PUSH
16204: LD_VAR 0 6
16208: PUSH
16209: LD_VAR 0 7
16213: DIFF
16214: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16215: LD_VAR 0 7
16219: PPUSH
16220: LD_VAR 0 6
16224: PPUSH
16225: CALL 17831 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16229: LD_VAR 0 7
16233: PUSH
16234: LD_INT 5
16236: PUSH
16237: LD_INT 6
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: IN
16244: PUSH
16245: LD_VAR 0 6
16249: PUSH
16250: LD_INT 2
16252: EQUAL
16253: OR
16254: IFFALSE 16181
// if not ( dec in [ 5 , 6 ] ) then
16256: LD_VAR 0 7
16260: PUSH
16261: LD_INT 5
16263: PUSH
16264: LD_INT 6
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: IN
16271: NOT
16272: IFFALSE 16315
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16274: LD_ADDR_VAR 0 7
16278: PUSH
16279: LD_STRING Q1a
16281: PPUSH
16282: LD_INT 1
16284: PUSH
16285: LD_INT 2
16287: PUSH
16288: EMPTY
16289: LIST
16290: LIST
16291: PPUSH
16292: CALL_OW 98
16296: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16297: LD_VAR 0 7
16301: PUSH
16302: LD_INT 4
16304: PLUS
16305: PPUSH
16306: LD_VAR 0 6
16310: PPUSH
16311: CALL 17831 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16315: LD_INT 81
16317: PPUSH
16318: LD_INT 127
16320: PPUSH
16321: CALL_OW 84
// amount := 8 ;
16325: LD_ADDR_VAR 0 8
16329: PUSH
16330: LD_INT 8
16332: ST_TO_ADDR
// macmilan_squad := [ ] ;
16333: LD_ADDR_VAR 0 9
16337: PUSH
16338: EMPTY
16339: ST_TO_ADDR
// if vip < amount then
16340: LD_EXP 59
16344: PUSH
16345: LD_VAR 0 8
16349: LESS
16350: IFFALSE 16394
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_EXP 59
16361: PUSH
16362: LD_INT 22
16364: PUSH
16365: LD_INT 4
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 21
16374: PUSH
16375: LD_INT 1
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PPUSH
16386: CALL_OW 69
16390: UNION
16391: ST_TO_ADDR
16392: GO 16404
// tmp := vip ;
16394: LD_ADDR_VAR 0 5
16398: PUSH
16399: LD_EXP 59
16403: ST_TO_ADDR
// tmp := tmp diff Powell ;
16404: LD_ADDR_VAR 0 5
16408: PUSH
16409: LD_VAR 0 5
16413: PUSH
16414: LD_EXP 58
16418: DIFF
16419: ST_TO_ADDR
// if tmp < amount then
16420: LD_VAR 0 5
16424: PUSH
16425: LD_VAR 0 8
16429: LESS
16430: IFFALSE 16442
// amount := tmp ;
16432: LD_ADDR_VAR 0 8
16436: PUSH
16437: LD_VAR 0 5
16441: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16442: LD_VAR 0 5
16446: PUSH
16447: LD_INT 1
16449: ARRAY
16450: PPUSH
16451: CALL_OW 257
16455: PUSH
16456: LD_INT 2
16458: NONEQUAL
16459: IFFALSE 16557
// begin if IsInUnit ( tmp [ 1 ] ) then
16461: LD_VAR 0 5
16465: PUSH
16466: LD_INT 1
16468: ARRAY
16469: PPUSH
16470: CALL_OW 310
16474: IFFALSE 16489
// ComExitBuilding ( tmp [ 1 ] ) ;
16476: LD_VAR 0 5
16480: PUSH
16481: LD_INT 1
16483: ARRAY
16484: PPUSH
16485: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
16489: LD_INT 387
16491: PPUSH
16492: CALL_OW 313
16496: PUSH
16497: LD_INT 6
16499: EQUAL
16500: IFFALSE 16525
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
16502: LD_INT 387
16504: PPUSH
16505: CALL_OW 313
16509: PUSH
16510: LD_INT 1
16512: ARRAY
16513: PPUSH
16514: CALL_OW 122
// wait ( 3 ) ;
16518: LD_INT 3
16520: PPUSH
16521: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16525: LD_VAR 0 5
16529: PUSH
16530: LD_INT 1
16532: ARRAY
16533: PPUSH
16534: LD_INT 387
16536: PPUSH
16537: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16541: LD_VAR 0 5
16545: PUSH
16546: LD_INT 1
16548: ARRAY
16549: PPUSH
16550: LD_INT 2
16552: PPUSH
16553: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16557: LD_EXP 39
16561: PPUSH
16562: LD_INT 82
16564: PPUSH
16565: LD_INT 129
16567: PPUSH
16568: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16572: LD_EXP 39
16576: PPUSH
16577: LD_EXP 58
16581: PPUSH
16582: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16586: LD_INT 22
16588: PUSH
16589: LD_INT 1
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: PPUSH
16596: CALL_OW 69
16600: PUSH
16601: LD_EXP 39
16605: DIFF
16606: PPUSH
16607: LD_INT 84
16609: PPUSH
16610: LD_INT 128
16612: PPUSH
16613: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16617: LD_INT 22
16619: PUSH
16620: LD_INT 1
16622: PUSH
16623: EMPTY
16624: LIST
16625: LIST
16626: PPUSH
16627: CALL_OW 69
16631: PUSH
16632: LD_EXP 39
16636: DIFF
16637: PPUSH
16638: LD_EXP 39
16642: PPUSH
16643: CALL_OW 179
// for i = 1 to amount do
16647: LD_ADDR_VAR 0 2
16651: PUSH
16652: DOUBLE
16653: LD_INT 1
16655: DEC
16656: ST_TO_ADDR
16657: LD_VAR 0 8
16661: PUSH
16662: FOR_TO
16663: IFFALSE 16831
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16665: LD_ADDR_VAR 0 9
16669: PUSH
16670: LD_VAR 0 9
16674: PUSH
16675: LD_VAR 0 5
16679: PUSH
16680: LD_VAR 0 2
16684: ARRAY
16685: ADD
16686: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16687: LD_VAR 0 5
16691: PUSH
16692: LD_VAR 0 2
16696: ARRAY
16697: PPUSH
16698: CALL_OW 310
16702: IFFALSE 16719
// AddComExitBuilding ( tmp [ i ] ) ;
16704: LD_VAR 0 5
16708: PUSH
16709: LD_VAR 0 2
16713: ARRAY
16714: PPUSH
16715: CALL_OW 182
// if i = 2 and JMMNewVeh then
16719: LD_VAR 0 2
16723: PUSH
16724: LD_INT 2
16726: EQUAL
16727: PUSH
16728: LD_EXP 56
16732: AND
16733: IFFALSE 16791
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16735: LD_VAR 0 5
16739: PUSH
16740: LD_VAR 0 2
16744: ARRAY
16745: PPUSH
16746: LD_EXP 56
16750: PPUSH
16751: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16755: LD_VAR 0 5
16759: PUSH
16760: LD_VAR 0 2
16764: ARRAY
16765: PPUSH
16766: LD_INT 86
16768: PPUSH
16769: LD_INT 133
16771: PPUSH
16772: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16776: LD_VAR 0 5
16780: PUSH
16781: LD_VAR 0 2
16785: ARRAY
16786: PPUSH
16787: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16791: LD_VAR 0 5
16795: PUSH
16796: LD_VAR 0 2
16800: ARRAY
16801: PPUSH
16802: LD_INT 8
16804: PPUSH
16805: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16809: LD_VAR 0 5
16813: PUSH
16814: LD_VAR 0 2
16818: ARRAY
16819: PPUSH
16820: LD_EXP 39
16824: PPUSH
16825: CALL_OW 179
// end ;
16829: GO 16662
16831: POP
16832: POP
// if GirlNewVeh then
16833: LD_EXP 57
16837: IFFALSE 16851
// SetSide ( GirlNewVeh , 4 ) ;
16839: LD_EXP 57
16843: PPUSH
16844: LD_INT 4
16846: PPUSH
16847: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16851: LD_INT 35
16853: PPUSH
16854: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16858: LD_VAR 0 9
16862: PPUSH
16863: LD_INT 95
16865: PUSH
16866: LD_INT 9
16868: PUSH
16869: EMPTY
16870: LIST
16871: LIST
16872: PPUSH
16873: CALL_OW 72
16877: PUSH
16878: LD_INT 0
16880: EQUAL
16881: PUSH
16882: LD_EXP 39
16886: PPUSH
16887: LD_INT 9
16889: PPUSH
16890: CALL_OW 308
16894: NOT
16895: AND
16896: IFFALSE 16851
// wait ( 0 0$2 ) ;
16898: LD_INT 70
16900: PPUSH
16901: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16905: LD_VAR 0 9
16909: PPUSH
16910: LD_INT 1
16912: PPUSH
16913: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16917: LD_INT 21
16919: PUSH
16920: LD_INT 2
16922: PUSH
16923: EMPTY
16924: LIST
16925: LIST
16926: PUSH
16927: LD_INT 92
16929: PUSH
16930: LD_INT 83
16932: PUSH
16933: LD_INT 130
16935: PUSH
16936: LD_INT 10
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PPUSH
16949: CALL_OW 69
16953: PPUSH
16954: LD_INT 1
16956: PPUSH
16957: CALL_OW 235
// tick := 0 ;
16961: LD_ADDR_OWVAR 1
16965: PUSH
16966: LD_INT 0
16968: ST_TO_ADDR
// Video ( false ) ;
16969: LD_INT 0
16971: PPUSH
16972: CALL 103444 0 1
// ChangeMissionObjectives ( M1 ) ;
16976: LD_STRING M1
16978: PPUSH
16979: CALL_OW 337
// SaveForQuickRestart ;
16983: CALL_OW 22
// missionStart := true ;
16987: LD_ADDR_EXP 13
16991: PUSH
16992: LD_INT 1
16994: ST_TO_ADDR
// missionStage := 2 ;
16995: LD_ADDR_EXP 15
16999: PUSH
17000: LD_INT 2
17002: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17003: LD_INT 35
17005: PPUSH
17006: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17010: LD_ADDR_VAR 0 5
17014: PUSH
17015: LD_INT 22
17017: PUSH
17018: LD_INT 4
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: LD_INT 21
17027: PUSH
17028: LD_INT 1
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: PUSH
17044: LD_EXP 58
17048: DIFF
17049: ST_TO_ADDR
// if not tmp then
17050: LD_VAR 0 5
17054: NOT
17055: IFFALSE 17070
// tmp := [ Powell ] ;
17057: LD_ADDR_VAR 0 5
17061: PUSH
17062: LD_EXP 58
17066: PUSH
17067: EMPTY
17068: LIST
17069: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17070: LD_ADDR_EXP 97
17074: PUSH
17075: LD_EXP 97
17079: PPUSH
17080: LD_INT 4
17082: PPUSH
17083: LD_INT 22
17085: PUSH
17086: LD_INT 4
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: PUSH
17093: LD_INT 23
17095: PUSH
17096: LD_INT 1
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: PUSH
17103: LD_INT 3
17105: PUSH
17106: LD_INT 21
17108: PUSH
17109: LD_INT 2
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: LIST
17124: PPUSH
17125: CALL_OW 69
17129: PUSH
17130: LD_EXP 58
17134: DIFF
17135: PPUSH
17136: CALL_OW 1
17140: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17141: LD_ADDR_VAR 0 4
17145: PUSH
17146: LD_INT 22
17148: PUSH
17149: LD_INT 4
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 34
17158: PUSH
17159: LD_INT 12
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PPUSH
17170: CALL_OW 69
17174: PUSH
17175: LD_INT 1
17177: ARRAY
17178: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17179: LD_VAR 0 5
17183: PUSH
17184: LD_INT 1
17186: ARRAY
17187: PPUSH
17188: CALL_OW 310
17192: IFFALSE 17207
// ComExitBuilding ( tmp [ 1 ] ) ;
17194: LD_VAR 0 5
17198: PUSH
17199: LD_INT 1
17201: ARRAY
17202: PPUSH
17203: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17207: LD_VAR 0 5
17211: PUSH
17212: LD_INT 1
17214: ARRAY
17215: PPUSH
17216: LD_VAR 0 4
17220: PPUSH
17221: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17225: LD_VAR 0 5
17229: PUSH
17230: LD_INT 1
17232: ARRAY
17233: PPUSH
17234: LD_INT 80
17236: PPUSH
17237: LD_INT 136
17239: PPUSH
17240: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17244: LD_VAR 0 5
17248: PUSH
17249: LD_INT 1
17251: ARRAY
17252: PPUSH
17253: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17257: LD_VAR 0 5
17261: PUSH
17262: LD_INT 1
17264: ARRAY
17265: PPUSH
17266: LD_INT 59
17268: PPUSH
17269: LD_INT 112
17271: PPUSH
17272: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17276: LD_VAR 0 5
17280: PUSH
17281: LD_INT 1
17283: ARRAY
17284: PPUSH
17285: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17289: LD_EXP 40
17293: PUSH
17294: LD_EXP 40
17298: PPUSH
17299: CALL_OW 255
17303: PUSH
17304: LD_INT 1
17306: EQUAL
17307: AND
17308: IFFALSE 17334
// begin Say ( Joan , D3W-Joan-1 ) ;
17310: LD_EXP 40
17314: PPUSH
17315: LD_STRING D3W-Joan-1
17317: PPUSH
17318: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17322: LD_EXP 39
17326: PPUSH
17327: LD_STRING D3W-JMM-1
17329: PPUSH
17330: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17334: LD_EXP 42
17338: PUSH
17339: LD_EXP 42
17343: PPUSH
17344: CALL_OW 255
17348: PUSH
17349: LD_INT 1
17351: EQUAL
17352: AND
17353: PUSH
17354: LD_EXP 42
17358: PUSH
17359: LD_EXP 59
17363: IN
17364: NOT
17365: AND
17366: IFFALSE 17392
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17368: LD_EXP 42
17372: PPUSH
17373: LD_STRING D3W-Lisa-1
17375: PPUSH
17376: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17380: LD_EXP 39
17384: PPUSH
17385: LD_STRING D3W-JMM-1
17387: PPUSH
17388: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17392: LD_EXP 54
17396: PUSH
17397: LD_EXP 54
17401: PPUSH
17402: CALL_OW 255
17406: PUSH
17407: LD_INT 1
17409: EQUAL
17410: AND
17411: IFFALSE 17437
// begin Say ( Connie , D3W-Con-1 ) ;
17413: LD_EXP 54
17417: PPUSH
17418: LD_STRING D3W-Con-1
17420: PPUSH
17421: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17425: LD_EXP 39
17429: PPUSH
17430: LD_STRING D3W-JMM-1
17432: PPUSH
17433: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17437: LD_EXP 42
17441: PUSH
17442: LD_EXP 59
17446: IN
17447: PUSH
17448: LD_EXP 42
17452: PPUSH
17453: CALL_OW 255
17457: PUSH
17458: LD_INT 1
17460: EQUAL
17461: AND
17462: IFFALSE 17478
// Say ( Lisa , D3nW-Lisa-1 ) else
17464: LD_EXP 42
17468: PPUSH
17469: LD_STRING D3nW-Lisa-1
17471: PPUSH
17472: CALL_OW 88
17476: GO 17722
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17478: LD_EXP 45
17482: PUSH
17483: LD_EXP 59
17487: IN
17488: PUSH
17489: LD_EXP 45
17493: PPUSH
17494: CALL_OW 255
17498: PUSH
17499: LD_INT 1
17501: EQUAL
17502: AND
17503: IFFALSE 17519
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17505: LD_EXP 45
17509: PPUSH
17510: LD_STRING D3nW-Cyrus-1
17512: PPUSH
17513: CALL_OW 88
17517: GO 17722
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17519: LD_EXP 44
17523: PUSH
17524: LD_EXP 59
17528: IN
17529: PUSH
17530: LD_EXP 44
17534: PPUSH
17535: CALL_OW 255
17539: PUSH
17540: LD_INT 1
17542: EQUAL
17543: AND
17544: IFFALSE 17560
// Say ( Bobby , D3nW-Bobby-1 ) else
17546: LD_EXP 44
17550: PPUSH
17551: LD_STRING D3nW-Bobby-1
17553: PPUSH
17554: CALL_OW 88
17558: GO 17722
// if Gary in vip and GetSide ( Gary ) = 1 then
17560: LD_EXP 51
17564: PUSH
17565: LD_EXP 59
17569: IN
17570: PUSH
17571: LD_EXP 51
17575: PPUSH
17576: CALL_OW 255
17580: PUSH
17581: LD_INT 1
17583: EQUAL
17584: AND
17585: IFFALSE 17601
// Say ( Gary , D3nW-Gary-1 ) else
17587: LD_EXP 51
17591: PPUSH
17592: LD_STRING D3nW-Gary-1
17594: PPUSH
17595: CALL_OW 88
17599: GO 17722
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17601: LD_EXP 43
17605: PUSH
17606: LD_EXP 59
17610: IN
17611: PUSH
17612: LD_EXP 43
17616: PPUSH
17617: CALL_OW 255
17621: PUSH
17622: LD_INT 1
17624: EQUAL
17625: AND
17626: IFFALSE 17642
// Say ( Donaldson , D3nW-Don-1 ) else
17628: LD_EXP 43
17632: PPUSH
17633: LD_STRING D3nW-Don-1
17635: PPUSH
17636: CALL_OW 88
17640: GO 17722
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17642: LD_EXP 50
17646: PUSH
17647: LD_EXP 59
17651: IN
17652: PUSH
17653: LD_EXP 50
17657: PPUSH
17658: CALL_OW 255
17662: PUSH
17663: LD_INT 1
17665: EQUAL
17666: AND
17667: IFFALSE 17683
// Say ( Cornel , D3nW-Corn-1 ) else
17669: LD_EXP 50
17673: PPUSH
17674: LD_STRING D3nW-Corn-1
17676: PPUSH
17677: CALL_OW 88
17681: GO 17722
// if Frank in vip and GetSide ( Frank ) = 1 then
17683: LD_EXP 52
17687: PUSH
17688: LD_EXP 59
17692: IN
17693: PUSH
17694: LD_EXP 52
17698: PPUSH
17699: CALL_OW 255
17703: PUSH
17704: LD_INT 1
17706: EQUAL
17707: AND
17708: IFFALSE 17722
// Say ( Frank , D3nW-Frank-1 ) ;
17710: LD_EXP 52
17714: PPUSH
17715: LD_STRING D3nW-Frank-1
17717: PPUSH
17718: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17722: LD_EXP 59
17726: PPUSH
17727: LD_INT 22
17729: PUSH
17730: LD_INT 1
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: PPUSH
17737: CALL_OW 72
17741: IFFALSE 17767
// begin Say ( JMM , D3nW-JMM-1 ) ;
17743: LD_EXP 39
17747: PPUSH
17748: LD_STRING D3nW-JMM-1
17750: PPUSH
17751: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17755: LD_EXP 39
17759: PPUSH
17760: LD_STRING D3nW-JMM-1a
17762: PPUSH
17763: CALL_OW 88
// end ; t := 0 0$00 ;
17767: LD_ADDR_VAR 0 3
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17775: LD_INT 35
17777: PPUSH
17778: CALL_OW 67
// t := t + 0 0$1 ;
17782: LD_ADDR_VAR 0 3
17786: PUSH
17787: LD_VAR 0 3
17791: PUSH
17792: LD_INT 35
17794: PLUS
17795: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17796: LD_INT 59
17798: PPUSH
17799: LD_INT 112
17801: PPUSH
17802: CALL_OW 428
17806: PUSH
17807: LD_VAR 0 3
17811: PUSH
17812: LD_INT 2100
17814: GREATER
17815: OR
17816: IFFALSE 17775
// activeAttacks := true ;
17818: LD_ADDR_EXP 16
17822: PUSH
17823: LD_INT 1
17825: ST_TO_ADDR
// end ;
17826: LD_VAR 0 1
17830: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17831: LD_INT 0
17833: PPUSH
// case question of 1 :
17834: LD_VAR 0 1
17838: PUSH
17839: LD_INT 1
17841: DOUBLE
17842: EQUAL
17843: IFTRUE 17847
17845: GO 17898
17847: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17848: LD_EXP 39
17852: PPUSH
17853: LD_STRING D2Mot-JMM-1
17855: PPUSH
17856: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17860: LD_EXP 58
17864: PPUSH
17865: LD_STRING D2Mot-Pow-1
17867: PPUSH
17868: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Mot-JMM-2
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Mot-Pow-2
17891: PPUSH
17892: CALL_OW 88
// end ; 2 :
17896: GO 18249
17898: LD_INT 2
17900: DOUBLE
17901: EQUAL
17902: IFTRUE 17906
17904: GO 17982
17906: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17907: LD_EXP 39
17911: PPUSH
17912: LD_STRING D2Rus-JMM-1
17914: PPUSH
17915: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-1
17926: PPUSH
17927: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Rus-JMM-2
17938: PPUSH
17939: CALL_OW 88
// if not ( 3 in list_of_q ) then
17943: LD_INT 3
17945: PUSH
17946: LD_VAR 0 2
17950: IN
17951: NOT
17952: IFFALSE 17968
// Say ( Powell , D2Rus-Pow-2 ) else
17954: LD_EXP 58
17958: PPUSH
17959: LD_STRING D2Rus-Pow-2
17961: PPUSH
17962: CALL_OW 88
17966: GO 17980
// Say ( Powell , D2Rus-Pow-2a ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Rus-Pow-2a
17975: PPUSH
17976: CALL_OW 88
// end ; 3 :
17980: GO 18249
17982: LD_INT 3
17984: DOUBLE
17985: EQUAL
17986: IFTRUE 17990
17988: GO 18075
17990: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17991: LD_EXP 39
17995: PPUSH
17996: LD_STRING D2Leg-JMM-1
17998: PPUSH
17999: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18003: LD_EXP 58
18007: PPUSH
18008: LD_STRING D2Leg-Pow-1
18010: PPUSH
18011: CALL_OW 88
// if 2 in list_of_q then
18015: LD_INT 2
18017: PUSH
18018: LD_VAR 0 2
18022: IN
18023: IFFALSE 18049
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18025: LD_EXP 39
18029: PPUSH
18030: LD_STRING D2Leg-JMM-2
18032: PPUSH
18033: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18037: LD_EXP 58
18041: PPUSH
18042: LD_STRING D2Leg-Pow-2
18044: PPUSH
18045: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Leg-JMM-3
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Leg-Pow-3
18068: PPUSH
18069: CALL_OW 88
// end ; 4 :
18073: GO 18249
18075: LD_INT 4
18077: DOUBLE
18078: EQUAL
18079: IFTRUE 18083
18081: GO 18158
18083: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18084: LD_EXP 39
18088: PPUSH
18089: LD_STRING D2Ar-JMM-1
18091: PPUSH
18092: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18096: LD_EXP 58
18100: PPUSH
18101: LD_STRING D2Ar-Pow-1
18103: PPUSH
18104: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18108: LD_EXP 39
18112: PPUSH
18113: LD_STRING D2Ar-JMM-2
18115: PPUSH
18116: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18120: LD_EXP 58
18124: PPUSH
18125: LD_STRING D2Ar-Pow-2
18127: PPUSH
18128: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Ar-JMM-3
18139: PPUSH
18140: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18144: LD_EXP 58
18148: PPUSH
18149: LD_STRING D2Ar-Pow-3
18151: PPUSH
18152: CALL_OW 88
// end ; 5 :
18156: GO 18249
18158: LD_INT 5
18160: DOUBLE
18161: EQUAL
18162: IFTRUE 18166
18164: GO 18181
18166: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18167: LD_EXP 39
18171: PPUSH
18172: LD_STRING D2Conf-JMM-1
18174: PPUSH
18175: CALL_OW 88
18179: GO 18249
18181: LD_INT 6
18183: DOUBLE
18184: EQUAL
18185: IFTRUE 18189
18187: GO 18248
18189: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18190: LD_EXP 39
18194: PPUSH
18195: LD_STRING D2Com-JMM-1
18197: PPUSH
18198: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18202: LD_EXP 58
18206: PPUSH
18207: LD_STRING D2Com-Pow-1
18209: PPUSH
18210: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18214: LD_EXP 39
18218: PPUSH
18219: LD_STRING D2Com-JMM-2
18221: PPUSH
18222: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18226: LD_EXP 58
18230: PPUSH
18231: LD_STRING D2Com-Pow-2
18233: PPUSH
18234: CALL_OW 88
// powellAngerQuery := true ;
18238: LD_ADDR_EXP 36
18242: PUSH
18243: LD_INT 1
18245: ST_TO_ADDR
// end ; end ;
18246: GO 18249
18248: POP
// end ;
18249: LD_VAR 0 3
18253: RET
// every 0 0$5 trigger missionStart do var tmp ;
18254: LD_EXP 13
18258: IFFALSE 18541
18260: GO 18262
18262: DISABLE
18263: LD_INT 0
18265: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18266: LD_INT 35
18268: PPUSH
18269: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18273: LD_INT 14
18275: PPUSH
18276: LD_INT 22
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: PPUSH
18286: CALL_OW 70
18290: PUSH
18291: LD_EXP 15
18295: PUSH
18296: LD_INT 2
18298: PUSH
18299: LD_INT 3
18301: PUSH
18302: LD_INT 4
18304: PUSH
18305: LD_INT 5
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: LIST
18312: LIST
18313: IN
18314: AND
18315: IFFALSE 18531
// begin powellAnger := powellAnger + 1 ;
18317: LD_ADDR_EXP 17
18321: PUSH
18322: LD_EXP 17
18326: PUSH
18327: LD_INT 1
18329: PLUS
18330: ST_TO_ADDR
// Video ( true ) ;
18331: LD_INT 1
18333: PPUSH
18334: CALL 103444 0 1
// CenterNowOnUnits ( tmp ) ;
18338: LD_VAR 0 1
18342: PPUSH
18343: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18347: LD_INT 14
18349: PPUSH
18350: LD_INT 22
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PPUSH
18360: CALL_OW 70
18364: PPUSH
18365: LD_INT 86
18367: PPUSH
18368: LD_INT 133
18370: PPUSH
18371: CALL_OW 111
// async ;
18375: ASYNC
// case powellAnger of 1 :
18376: LD_EXP 17
18380: PUSH
18381: LD_INT 1
18383: DOUBLE
18384: EQUAL
18385: IFTRUE 18389
18387: GO 18404
18389: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18390: LD_EXP 58
18394: PPUSH
18395: LD_STRING DBack1-Pow-1
18397: PPUSH
18398: CALL_OW 88
18402: GO 18451
18404: LD_INT 2
18406: DOUBLE
18407: EQUAL
18408: IFTRUE 18412
18410: GO 18427
18412: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18413: LD_EXP 58
18417: PPUSH
18418: LD_STRING DBack2-Pow-1
18420: PPUSH
18421: CALL_OW 88
18425: GO 18451
18427: LD_INT 3
18429: DOUBLE
18430: EQUAL
18431: IFTRUE 18435
18433: GO 18450
18435: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18436: LD_EXP 58
18440: PPUSH
18441: LD_STRING DBack3-Pow-1
18443: PPUSH
18444: CALL_OW 88
18448: GO 18451
18450: POP
// sync ;
18451: SYNC
// repeat wait ( 0 0$1 ) ;
18452: LD_INT 35
18454: PPUSH
18455: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18459: LD_INT 14
18461: PPUSH
18462: LD_INT 22
18464: PUSH
18465: LD_INT 1
18467: PUSH
18468: EMPTY
18469: LIST
18470: LIST
18471: PPUSH
18472: CALL_OW 70
18476: PPUSH
18477: LD_INT 86
18479: PPUSH
18480: LD_INT 133
18482: PPUSH
18483: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18487: LD_INT 14
18489: PPUSH
18490: LD_INT 22
18492: PUSH
18493: LD_INT 1
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: PPUSH
18500: CALL_OW 70
18504: NOT
18505: IFFALSE 18452
// if powellAnger >= 3 then
18507: LD_EXP 17
18511: PUSH
18512: LD_INT 3
18514: GREATEREQUAL
18515: IFFALSE 18524
// YouLost ( Dismissed ) ;
18517: LD_STRING Dismissed
18519: PPUSH
18520: CALL_OW 104
// Video ( false ) ;
18524: LD_INT 0
18526: PPUSH
18527: CALL 103444 0 1
// end ; until missionStage > 5 ;
18531: LD_EXP 15
18535: PUSH
18536: LD_INT 5
18538: GREATER
18539: IFFALSE 18266
// end ;
18541: PPOPN 1
18543: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
18544: LD_EXP 13
18548: PUSH
18549: LD_INT 22
18551: PUSH
18552: LD_INT 4
18554: PUSH
18555: EMPTY
18556: LIST
18557: LIST
18558: PUSH
18559: LD_INT 21
18561: PUSH
18562: LD_INT 2
18564: PUSH
18565: EMPTY
18566: LIST
18567: LIST
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PPUSH
18573: CALL_OW 69
18577: PUSH
18578: LD_INT 4
18580: GREATEREQUAL
18581: AND
18582: PUSH
18583: LD_EXP 15
18587: PUSH
18588: LD_INT 2
18590: EQUAL
18591: AND
18592: IFFALSE 20702
18594: GO 18596
18596: DISABLE
18597: LD_INT 0
18599: PPUSH
18600: PPUSH
18601: PPUSH
18602: PPUSH
18603: PPUSH
18604: PPUSH
18605: PPUSH
18606: PPUSH
18607: PPUSH
18608: PPUSH
// begin missionStage := 3 ;
18609: LD_ADDR_EXP 15
18613: PUSH
18614: LD_INT 3
18616: ST_TO_ADDR
// retreat := false ;
18617: LD_ADDR_VAR 0 4
18621: PUSH
18622: LD_INT 0
18624: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18625: LD_ADDR_VAR 0 5
18629: PUSH
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 30
18642: PUSH
18643: LD_INT 4
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PPUSH
18654: CALL_OW 69
18658: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18659: LD_ADDR_VAR 0 6
18663: PUSH
18664: LD_INT 22
18666: PUSH
18667: LD_INT 4
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: PUSH
18674: LD_INT 30
18676: PUSH
18677: LD_INT 5
18679: PUSH
18680: EMPTY
18681: LIST
18682: LIST
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: PPUSH
18688: CALL_OW 69
18692: ST_TO_ADDR
// if not bar then
18693: LD_VAR 0 6
18697: NOT
18698: IFFALSE 18751
// begin repeat wait ( 0 0$1 ) ;
18700: LD_INT 35
18702: PPUSH
18703: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18707: LD_INT 22
18709: PUSH
18710: LD_INT 4
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: PUSH
18717: LD_INT 3
18719: PUSH
18720: LD_INT 57
18722: PUSH
18723: EMPTY
18724: LIST
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: PUSH
18730: LD_INT 30
18732: PUSH
18733: LD_INT 5
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: LIST
18744: PPUSH
18745: CALL_OW 69
18749: IFFALSE 18700
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18751: LD_ADDR_VAR 0 6
18755: PUSH
18756: LD_INT 22
18758: PUSH
18759: LD_INT 4
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: PUSH
18766: LD_INT 30
18768: PUSH
18769: LD_INT 5
18771: PUSH
18772: EMPTY
18773: LIST
18774: LIST
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PPUSH
18780: CALL_OW 69
18784: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18785: LD_INT 35
18787: PPUSH
18788: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18792: LD_EXP 116
18796: PUSH
18797: LD_INT 4
18799: ARRAY
18800: PUSH
18801: LD_INT 4
18803: GREATEREQUAL
18804: IFFALSE 18785
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18806: LD_ADDR_VAR 0 2
18810: PUSH
18811: LD_INT 22
18813: PUSH
18814: LD_INT 4
18816: PUSH
18817: EMPTY
18818: LIST
18819: LIST
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 25
18826: PUSH
18827: LD_INT 1
18829: PUSH
18830: EMPTY
18831: LIST
18832: LIST
18833: PUSH
18834: LD_INT 25
18836: PUSH
18837: LD_INT 2
18839: PUSH
18840: EMPTY
18841: LIST
18842: LIST
18843: PUSH
18844: LD_INT 25
18846: PUSH
18847: LD_INT 3
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: PUSH
18854: LD_INT 25
18856: PUSH
18857: LD_INT 4
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PUSH
18864: LD_INT 25
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 69
18890: PUSH
18891: LD_EXP 58
18895: PUSH
18896: LD_EXP 59
18900: ADD
18901: DIFF
18902: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18903: LD_ADDR_VAR 0 3
18907: PUSH
18908: LD_VAR 0 2
18912: PPUSH
18913: LD_INT 26
18915: PUSH
18916: LD_INT 1
18918: PUSH
18919: EMPTY
18920: LIST
18921: LIST
18922: PPUSH
18923: CALL_OW 72
18927: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18928: LD_ADDR_VAR 0 2
18932: PUSH
18933: LD_VAR 0 2
18937: PUSH
18938: LD_VAR 0 3
18942: DIFF
18943: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
18944: LD_ADDR_VAR 0 2
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 3
18956: PPUSH
18957: CALL 101981 0 2
18961: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
18962: LD_ADDR_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: PPUSH
18972: LD_INT 3
18974: PPUSH
18975: CALL 101981 0 2
18979: ST_TO_ADDR
// for i = 1 to 4 do
18980: LD_ADDR_VAR 0 1
18984: PUSH
18985: DOUBLE
18986: LD_INT 1
18988: DEC
18989: ST_TO_ADDR
18990: LD_INT 4
18992: PUSH
18993: FOR_TO
18994: IFFALSE 19160
// begin if tmp2 then
18996: LD_VAR 0 3
19000: IFFALSE 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19002: LD_ADDR_EXP 18
19006: PUSH
19007: LD_EXP 18
19011: PPUSH
19012: LD_INT 1
19014: PPUSH
19015: LD_EXP 18
19019: PUSH
19020: LD_INT 1
19022: ARRAY
19023: PUSH
19024: LD_VAR 0 3
19028: PUSH
19029: LD_VAR 0 3
19033: ARRAY
19034: ADD
19035: PPUSH
19036: CALL_OW 1
19040: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19041: LD_VAR 0 3
19045: PUSH
19046: LD_VAR 0 3
19050: ARRAY
19051: PPUSH
19052: LD_INT 1
19054: PPUSH
19055: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19059: LD_ADDR_VAR 0 3
19063: PUSH
19064: LD_VAR 0 3
19068: PPUSH
19069: LD_VAR 0 3
19073: PPUSH
19074: CALL_OW 3
19078: ST_TO_ADDR
// end else
19079: GO 19158
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19081: LD_ADDR_EXP 18
19085: PUSH
19086: LD_EXP 18
19090: PPUSH
19091: LD_INT 1
19093: PPUSH
19094: LD_EXP 18
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PUSH
19103: LD_VAR 0 2
19107: PUSH
19108: LD_VAR 0 2
19112: ARRAY
19113: ADD
19114: PPUSH
19115: CALL_OW 1
19119: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19120: LD_VAR 0 2
19124: PUSH
19125: LD_VAR 0 2
19129: ARRAY
19130: PPUSH
19131: LD_INT 1
19133: PPUSH
19134: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19138: LD_ADDR_VAR 0 2
19142: PUSH
19143: LD_VAR 0 2
19147: PPUSH
19148: LD_VAR 0 2
19152: PPUSH
19153: CALL_OW 3
19157: ST_TO_ADDR
// end ; end ;
19158: GO 18993
19160: POP
19161: POP
// if tmp2 then
19162: LD_VAR 0 3
19166: IFFALSE 19184
// tmp := tmp union tmp2 ;
19168: LD_ADDR_VAR 0 2
19172: PUSH
19173: LD_VAR 0 2
19177: PUSH
19178: LD_VAR 0 3
19182: UNION
19183: ST_TO_ADDR
// for i := 1 to 4 do
19184: LD_ADDR_VAR 0 1
19188: PUSH
19189: DOUBLE
19190: LD_INT 1
19192: DEC
19193: ST_TO_ADDR
19194: LD_INT 4
19196: PUSH
19197: FOR_TO
19198: IFFALSE 19247
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19200: LD_ADDR_EXP 18
19204: PUSH
19205: LD_EXP 18
19209: PPUSH
19210: LD_INT 2
19212: PPUSH
19213: LD_EXP 18
19217: PUSH
19218: LD_INT 2
19220: ARRAY
19221: PUSH
19222: LD_VAR 0 2
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_VAR 0 1
19236: MINUS
19237: ARRAY
19238: ADD
19239: PPUSH
19240: CALL_OW 1
19244: ST_TO_ADDR
19245: GO 19197
19247: POP
19248: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19249: LD_ADDR_EXP 97
19253: PUSH
19254: LD_EXP 97
19258: PPUSH
19259: LD_INT 4
19261: PPUSH
19262: LD_EXP 97
19266: PUSH
19267: LD_INT 4
19269: ARRAY
19270: PUSH
19271: LD_EXP 18
19275: PUSH
19276: LD_INT 1
19278: ARRAY
19279: DIFF
19280: PPUSH
19281: CALL_OW 1
19285: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19286: LD_VAR 0 5
19290: PUSH
19291: LD_INT 1
19293: ARRAY
19294: PPUSH
19295: CALL_OW 313
19299: IFFALSE 19354
// begin for i in UnitsInside ( arm [ 1 ] ) do
19301: LD_ADDR_VAR 0 1
19305: PUSH
19306: LD_VAR 0 5
19310: PUSH
19311: LD_INT 1
19313: ARRAY
19314: PPUSH
19315: CALL_OW 313
19319: PUSH
19320: FOR_IN
19321: IFFALSE 19352
// begin ComExitBuilding ( i ) ;
19323: LD_VAR 0 1
19327: PPUSH
19328: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19332: LD_VAR 0 1
19336: PPUSH
19337: LD_VAR 0 6
19341: PUSH
19342: LD_INT 1
19344: ARRAY
19345: PPUSH
19346: CALL_OW 180
// end ;
19350: GO 19320
19352: POP
19353: POP
// end ; wait ( 0 0$3 ) ;
19354: LD_INT 105
19356: PPUSH
19357: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19361: LD_ADDR_VAR 0 1
19365: PUSH
19366: LD_EXP 18
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: PUSH
19375: FOR_IN
19376: IFFALSE 19483
// begin if IsInUnit ( i ) then
19378: LD_VAR 0 1
19382: PPUSH
19383: CALL_OW 310
19387: IFFALSE 19398
// ComExitBuilding ( i ) ;
19389: LD_VAR 0 1
19393: PPUSH
19394: CALL_OW 122
// if GetClass ( i ) <> 1 then
19398: LD_VAR 0 1
19402: PPUSH
19403: CALL_OW 257
19407: PUSH
19408: LD_INT 1
19410: NONEQUAL
19411: IFFALSE 19452
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19413: LD_VAR 0 1
19417: PPUSH
19418: LD_VAR 0 5
19422: PUSH
19423: LD_INT 1
19425: ARRAY
19426: PPUSH
19427: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19431: LD_VAR 0 1
19435: PPUSH
19436: LD_INT 1
19438: PPUSH
19439: CALL_OW 183
// AddComExitBuilding ( i ) ;
19443: LD_VAR 0 1
19447: PPUSH
19448: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19452: LD_VAR 0 1
19456: PPUSH
19457: LD_INT 60
19459: PPUSH
19460: LD_INT 94
19462: PPUSH
19463: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19467: LD_VAR 0 1
19471: PPUSH
19472: LD_EXP 58
19476: PPUSH
19477: CALL_OW 179
// end ;
19481: GO 19375
19483: POP
19484: POP
// wait ( 0 0$10 ) ;
19485: LD_INT 350
19487: PPUSH
19488: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19492: LD_EXP 58
19496: PPUSH
19497: LD_STRING D4-Pow-1
19499: PPUSH
19500: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19504: LD_ADDR_VAR 0 2
19508: PUSH
19509: LD_EXP 18
19513: PUSH
19514: LD_INT 1
19516: ARRAY
19517: PPUSH
19518: LD_INT 26
19520: PUSH
19521: LD_INT 1
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PPUSH
19528: CALL_OW 72
19532: ST_TO_ADDR
// if tmp then
19533: LD_VAR 0 2
19537: IFFALSE 19555
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19539: LD_VAR 0 2
19543: PUSH
19544: LD_INT 1
19546: ARRAY
19547: PPUSH
19548: LD_STRING D4-Sol1-1
19550: PPUSH
19551: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19555: LD_EXP 58
19559: PPUSH
19560: LD_STRING D4-Pow-2
19562: PPUSH
19563: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19567: LD_ADDR_VAR 0 1
19571: PUSH
19572: DOUBLE
19573: LD_INT 1
19575: DEC
19576: ST_TO_ADDR
19577: LD_EXP 18
19581: PUSH
19582: LD_INT 1
19584: ARRAY
19585: PUSH
19586: FOR_TO
19587: IFFALSE 19680
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19589: LD_EXP 18
19593: PUSH
19594: LD_INT 1
19596: ARRAY
19597: PUSH
19598: LD_VAR 0 1
19602: ARRAY
19603: PPUSH
19604: LD_EXP 116
19608: PUSH
19609: LD_INT 4
19611: ARRAY
19612: PUSH
19613: LD_INT 1
19615: ARRAY
19616: PPUSH
19617: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19621: LD_ADDR_EXP 116
19625: PUSH
19626: LD_EXP 116
19630: PPUSH
19631: LD_INT 4
19633: PPUSH
19634: LD_EXP 116
19638: PUSH
19639: LD_INT 4
19641: ARRAY
19642: PPUSH
19643: LD_INT 1
19645: PPUSH
19646: CALL_OW 3
19650: PPUSH
19651: CALL_OW 1
19655: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19656: LD_INT 8
19658: PPUSH
19659: LD_EXP 18
19663: PUSH
19664: LD_INT 1
19666: ARRAY
19667: PUSH
19668: LD_VAR 0 1
19672: ARRAY
19673: PPUSH
19674: CALL_OW 471
// end ;
19678: GO 19586
19680: POP
19681: POP
// repeat wait ( 0 0$1 ) ;
19682: LD_INT 35
19684: PPUSH
19685: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19689: LD_EXP 18
19693: PUSH
19694: LD_INT 1
19696: ARRAY
19697: PPUSH
19698: LD_INT 55
19700: PUSH
19701: EMPTY
19702: LIST
19703: PPUSH
19704: CALL_OW 72
19708: PUSH
19709: LD_INT 4
19711: GREATEREQUAL
19712: IFFALSE 19682
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19714: LD_EXP 18
19718: PUSH
19719: LD_INT 1
19721: ARRAY
19722: PPUSH
19723: LD_INT 69
19725: PPUSH
19726: LD_INT 94
19728: PPUSH
19729: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19733: LD_EXP 18
19737: PUSH
19738: LD_INT 1
19740: ARRAY
19741: PPUSH
19742: LD_INT 82
19744: PPUSH
19745: LD_INT 83
19747: PPUSH
19748: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19752: LD_EXP 18
19756: PUSH
19757: LD_INT 1
19759: ARRAY
19760: PPUSH
19761: LD_INT 77
19763: PPUSH
19764: LD_INT 69
19766: PPUSH
19767: CALL_OW 174
// repeat wait ( 3 ) ;
19771: LD_INT 3
19773: PPUSH
19774: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19778: LD_ADDR_VAR 0 1
19782: PUSH
19783: LD_EXP 18
19787: PUSH
19788: LD_INT 1
19790: ARRAY
19791: PUSH
19792: FOR_IN
19793: IFFALSE 19929
// begin if GetLives ( i ) < 990 then
19795: LD_VAR 0 1
19799: PPUSH
19800: CALL_OW 256
19804: PUSH
19805: LD_INT 990
19807: LESS
19808: IFFALSE 19822
// SetLives ( i , 1000 ) ;
19810: LD_VAR 0 1
19814: PPUSH
19815: LD_INT 1000
19817: PPUSH
19818: CALL_OW 234
// if not IsInUnit ( i ) then
19822: LD_VAR 0 1
19826: PPUSH
19827: CALL_OW 310
19831: NOT
19832: IFFALSE 19927
// begin if not HasTask ( i ) then
19834: LD_VAR 0 1
19838: PPUSH
19839: CALL_OW 314
19843: NOT
19844: IFFALSE 19861
// ComMoveXY ( i , 64 , 93 ) ;
19846: LD_VAR 0 1
19850: PPUSH
19851: LD_INT 64
19853: PPUSH
19854: LD_INT 93
19856: PPUSH
19857: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19861: LD_VAR 0 4
19865: NOT
19866: PUSH
19867: LD_VAR 0 1
19871: PPUSH
19872: CALL_OW 258
19876: PUSH
19877: LD_INT 1
19879: EQUAL
19880: AND
19881: IFFALSE 19927
// begin retreat := true ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_INT 1
19890: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19891: LD_VAR 0 1
19895: PPUSH
19896: LD_INT 2
19898: PPUSH
19899: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19903: LD_VAR 0 1
19907: PPUSH
19908: LD_STRING D4a-Sol1-1
19910: PPUSH
19911: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19915: LD_EXP 58
19919: PPUSH
19920: LD_STRING D4a-Pow-1
19922: PPUSH
19923: CALL_OW 88
// end ; end ; end ;
19927: GO 19792
19929: POP
19930: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19931: LD_EXP 18
19935: PUSH
19936: LD_INT 1
19938: ARRAY
19939: PPUSH
19940: LD_INT 95
19942: PUSH
19943: LD_INT 9
19945: PUSH
19946: EMPTY
19947: LIST
19948: LIST
19949: PUSH
19950: LD_INT 3
19952: PUSH
19953: LD_INT 55
19955: PUSH
19956: EMPTY
19957: LIST
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PPUSH
19967: CALL_OW 72
19971: PUSH
19972: LD_INT 4
19974: GREATEREQUAL
19975: IFFALSE 19771
// for i in powellSquadAttack [ 1 ] do
19977: LD_ADDR_VAR 0 1
19981: PUSH
19982: LD_EXP 18
19986: PUSH
19987: LD_INT 1
19989: ARRAY
19990: PUSH
19991: FOR_IN
19992: IFFALSE 20128
// begin if GetTag ( i ) = 2 then
19994: LD_VAR 0 1
19998: PPUSH
19999: CALL_OW 110
20003: PUSH
20004: LD_INT 2
20006: EQUAL
20007: IFFALSE 20069
// begin ComMoveXY ( i , 60 , 94 ) ;
20009: LD_VAR 0 1
20013: PPUSH
20014: LD_INT 60
20016: PPUSH
20017: LD_INT 94
20019: PPUSH
20020: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20024: LD_VAR 0 1
20028: PPUSH
20029: LD_EXP 58
20033: PPUSH
20034: CALL_OW 179
// wait ( 0 0$3 ) ;
20038: LD_INT 105
20040: PPUSH
20041: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_STRING D4a-Sol1-2
20052: PPUSH
20053: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20057: LD_EXP 58
20061: PPUSH
20062: LD_STRING D4a-Pow-2
20064: PPUSH
20065: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20069: LD_VAR 0 1
20073: PPUSH
20074: LD_INT 0
20076: PPUSH
20077: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20081: LD_ADDR_EXP 97
20085: PUSH
20086: LD_EXP 97
20090: PPUSH
20091: LD_INT 4
20093: PPUSH
20094: LD_EXP 97
20098: PUSH
20099: LD_INT 4
20101: ARRAY
20102: PUSH
20103: LD_VAR 0 1
20107: UNION
20108: PPUSH
20109: CALL_OW 1
20113: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20114: LD_INT 8
20116: PPUSH
20117: LD_VAR 0 1
20121: PPUSH
20122: CALL_OW 472
// end ;
20126: GO 19991
20128: POP
20129: POP
// wait ( 2 2$00 ) ;
20130: LD_INT 4200
20132: PPUSH
20133: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20137: LD_ADDR_VAR 0 9
20141: PUSH
20142: LD_INT 22
20144: PUSH
20145: LD_INT 4
20147: PUSH
20148: EMPTY
20149: LIST
20150: LIST
20151: PUSH
20152: LD_INT 30
20154: PUSH
20155: LD_INT 32
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: PUSH
20162: LD_INT 58
20164: PUSH
20165: EMPTY
20166: LIST
20167: PUSH
20168: EMPTY
20169: LIST
20170: LIST
20171: LIST
20172: PPUSH
20173: CALL_OW 69
20177: ST_TO_ADDR
// if tmp then
20178: LD_VAR 0 2
20182: IFFALSE 20422
// begin for i := 1 to tmp do
20184: LD_ADDR_VAR 0 1
20188: PUSH
20189: DOUBLE
20190: LD_INT 1
20192: DEC
20193: ST_TO_ADDR
20194: LD_VAR 0 2
20198: PUSH
20199: FOR_TO
20200: IFFALSE 20413
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
20202: LD_ADDR_EXP 97
20206: PUSH
20207: LD_EXP 97
20211: PPUSH
20212: LD_INT 4
20214: PPUSH
20215: LD_EXP 97
20219: PUSH
20220: LD_INT 4
20222: ARRAY
20223: PUSH
20224: LD_VAR 0 2
20228: PUSH
20229: LD_VAR 0 1
20233: ARRAY
20234: DIFF
20235: PPUSH
20236: CALL_OW 1
20240: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
20241: LD_ADDR_VAR 0 10
20245: PUSH
20246: LD_VAR 0 2
20250: PUSH
20251: LD_VAR 0 1
20255: ARRAY
20256: PPUSH
20257: CALL_OW 310
20261: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
20262: LD_VAR 0 10
20266: PUSH
20267: LD_VAR 0 10
20271: PPUSH
20272: CALL_OW 266
20276: PUSH
20277: LD_INT 32
20279: EQUAL
20280: AND
20281: IFFALSE 20285
// continue ;
20283: GO 20199
// if t then
20285: LD_VAR 0 10
20289: IFFALSE 20306
// ComExitBuilding ( tmp [ i ] ) ;
20291: LD_VAR 0 2
20295: PUSH
20296: LD_VAR 0 1
20300: ARRAY
20301: PPUSH
20302: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 5
20321: PUSH
20322: LD_INT 1
20324: ARRAY
20325: PPUSH
20326: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20330: LD_VAR 0 2
20334: PUSH
20335: LD_VAR 0 1
20339: ARRAY
20340: PPUSH
20341: LD_INT 1
20343: PPUSH
20344: CALL_OW 183
// if emptyTowers then
20348: LD_VAR 0 9
20352: IFFALSE 20411
// begin AddComExitBuilding ( tmp [ i ] ) ;
20354: LD_VAR 0 2
20358: PUSH
20359: LD_VAR 0 1
20363: ARRAY
20364: PPUSH
20365: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
20369: LD_VAR 0 2
20373: PUSH
20374: LD_VAR 0 1
20378: ARRAY
20379: PPUSH
20380: LD_VAR 0 9
20384: PUSH
20385: LD_INT 1
20387: ARRAY
20388: PPUSH
20389: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
20393: LD_ADDR_VAR 0 9
20397: PUSH
20398: LD_VAR 0 9
20402: PPUSH
20403: LD_INT 1
20405: PPUSH
20406: CALL_OW 3
20410: ST_TO_ADDR
// end ; end ;
20411: GO 20199
20413: POP
20414: POP
// wait ( 0 0$30 ) ;
20415: LD_INT 1050
20417: PPUSH
20418: CALL_OW 67
// end ; uc_side := 6 ;
20422: LD_ADDR_OWVAR 20
20426: PUSH
20427: LD_INT 6
20429: ST_TO_ADDR
// uc_nation := 3 ;
20430: LD_ADDR_OWVAR 21
20434: PUSH
20435: LD_INT 3
20437: ST_TO_ADDR
// ru := [ ] ;
20438: LD_ADDR_VAR 0 7
20442: PUSH
20443: EMPTY
20444: ST_TO_ADDR
// for i = 1 to 5 do
20445: LD_ADDR_VAR 0 1
20449: PUSH
20450: DOUBLE
20451: LD_INT 1
20453: DEC
20454: ST_TO_ADDR
20455: LD_INT 5
20457: PUSH
20458: FOR_TO
20459: IFFALSE 20560
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20461: LD_INT 22
20463: PPUSH
20464: LD_INT 1
20466: PPUSH
20467: LD_INT 3
20469: PPUSH
20470: LD_INT 43
20472: PUSH
20473: LD_INT 44
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 1
20482: PPUSH
20483: LD_INT 2
20485: PPUSH
20486: CALL_OW 12
20490: ARRAY
20491: PPUSH
20492: LD_INT 89
20494: PPUSH
20495: CALL 71038 0 5
// un := CreateVehicle ;
20499: LD_ADDR_VAR 0 8
20503: PUSH
20504: CALL_OW 45
20508: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20509: LD_VAR 0 8
20513: PPUSH
20514: LD_INT 4
20516: PPUSH
20517: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20521: LD_VAR 0 8
20525: PPUSH
20526: LD_INT 136
20528: PPUSH
20529: LD_INT 90
20531: PPUSH
20532: LD_INT 8
20534: PPUSH
20535: LD_INT 0
20537: PPUSH
20538: CALL_OW 50
// ru := ru ^ un ;
20542: LD_ADDR_VAR 0 7
20546: PUSH
20547: LD_VAR 0 7
20551: PUSH
20552: LD_VAR 0 8
20556: ADD
20557: ST_TO_ADDR
// end ;
20558: GO 20458
20560: POP
20561: POP
// if ru then
20562: LD_VAR 0 7
20566: IFFALSE 20583
// ComAgressiveMove ( ru , 57 , 94 ) ;
20568: LD_VAR 0 7
20572: PPUSH
20573: LD_INT 57
20575: PPUSH
20576: LD_INT 94
20578: PPUSH
20579: CALL_OW 114
// wait ( 4 4$00 ) ;
20583: LD_INT 8400
20585: PPUSH
20586: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20590: LD_INT 4
20592: PPUSH
20593: LD_INT 3
20595: PUSH
20596: LD_INT 1
20598: PUSH
20599: LD_INT 1
20601: PUSH
20602: LD_INT 5
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: PUSH
20611: LD_INT 4
20613: PUSH
20614: LD_INT 1
20616: PUSH
20617: LD_INT 1
20619: PUSH
20620: LD_INT 6
20622: PUSH
20623: EMPTY
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 4
20631: PUSH
20632: LD_INT 1
20634: PUSH
20635: LD_INT 1
20637: PUSH
20638: LD_INT 7
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: PUSH
20647: LD_INT 3
20649: PUSH
20650: LD_INT 1
20652: PUSH
20653: LD_INT 1
20655: PUSH
20656: LD_INT 7
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: PUSH
20665: LD_INT 3
20667: PUSH
20668: LD_INT 1
20670: PUSH
20671: LD_INT 1
20673: PUSH
20674: LD_INT 5
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: LIST
20681: LIST
20682: PUSH
20683: EMPTY
20684: LIST
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: PPUSH
20690: CALL 59587 0 2
// missionStage := 4 ;
20694: LD_ADDR_EXP 15
20698: PUSH
20699: LD_INT 4
20701: ST_TO_ADDR
// end ;
20702: PPOPN 10
20704: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20705: LD_EXP 15
20709: PUSH
20710: LD_INT 4
20712: EQUAL
20713: PUSH
20714: LD_INT 22
20716: PUSH
20717: LD_INT 4
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: PUSH
20724: LD_INT 21
20726: PUSH
20727: LD_INT 2
20729: PUSH
20730: EMPTY
20731: LIST
20732: LIST
20733: PUSH
20734: EMPTY
20735: LIST
20736: LIST
20737: PPUSH
20738: CALL_OW 69
20742: PUSH
20743: LD_INT 5
20745: GREATEREQUAL
20746: AND
20747: IFFALSE 24945
20749: GO 20751
20751: DISABLE
20752: LD_INT 0
20754: PPUSH
20755: PPUSH
20756: PPUSH
20757: PPUSH
20758: PPUSH
20759: PPUSH
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
20764: PPUSH
20765: PPUSH
20766: PPUSH
// begin wait ( 0 0$10 ) ;
20767: LD_INT 350
20769: PPUSH
20770: CALL_OW 67
// missionStage := 5 ;
20774: LD_ADDR_EXP 15
20778: PUSH
20779: LD_INT 5
20781: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20782: LD_ADDR_VAR 0 10
20786: PUSH
20787: LD_INT 22
20789: PUSH
20790: LD_INT 4
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: PUSH
20797: LD_INT 2
20799: PUSH
20800: LD_INT 30
20802: PUSH
20803: LD_INT 4
20805: PUSH
20806: EMPTY
20807: LIST
20808: LIST
20809: PUSH
20810: LD_INT 30
20812: PUSH
20813: LD_INT 5
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: LIST
20824: PUSH
20825: EMPTY
20826: LIST
20827: LIST
20828: PPUSH
20829: CALL_OW 69
20833: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20834: LD_ADDR_VAR 0 6
20838: PUSH
20839: LD_INT 22
20841: PUSH
20842: LD_INT 4
20844: PUSH
20845: EMPTY
20846: LIST
20847: LIST
20848: PUSH
20849: LD_INT 21
20851: PUSH
20852: LD_INT 1
20854: PUSH
20855: EMPTY
20856: LIST
20857: LIST
20858: PUSH
20859: LD_INT 3
20861: PUSH
20862: LD_INT 25
20864: PUSH
20865: LD_INT 16
20867: PUSH
20868: EMPTY
20869: LIST
20870: LIST
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: PUSH
20876: LD_INT 3
20878: PUSH
20879: LD_INT 25
20881: PUSH
20882: LD_INT 12
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: PUSH
20889: EMPTY
20890: LIST
20891: LIST
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: PPUSH
20899: CALL_OW 69
20903: PUSH
20904: LD_EXP 58
20908: DIFF
20909: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20910: LD_ADDR_VAR 0 9
20914: PUSH
20915: LD_INT 22
20917: PUSH
20918: LD_INT 4
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: PUSH
20925: LD_INT 30
20927: PUSH
20928: LD_INT 3
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: PPUSH
20939: CALL_OW 69
20943: PUSH
20944: LD_INT 1
20946: ARRAY
20947: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
20948: LD_INT 350
20950: PPUSH
20951: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
20955: LD_EXP 116
20959: PUSH
20960: LD_INT 4
20962: ARRAY
20963: PUSH
20964: LD_INT 5
20966: LESS
20967: PUSH
20968: LD_VAR 0 9
20972: PPUSH
20973: CALL_OW 461
20977: PUSH
20978: LD_INT 2
20980: EQUAL
20981: AND
20982: IFFALSE 21012
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20984: LD_INT 4
20986: PPUSH
20987: LD_INT 3
20989: PUSH
20990: LD_INT 1
20992: PUSH
20993: LD_INT 1
20995: PUSH
20996: LD_INT 5
20998: PUSH
20999: EMPTY
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: PUSH
21005: EMPTY
21006: LIST
21007: PPUSH
21008: CALL 59635 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
21012: LD_EXP 116
21016: PUSH
21017: LD_INT 4
21019: ARRAY
21020: PUSH
21021: LD_INT 5
21023: GREATEREQUAL
21024: PUSH
21025: LD_EXP 116
21029: PUSH
21030: LD_INT 4
21032: ARRAY
21033: PPUSH
21034: LD_INT 58
21036: PUSH
21037: EMPTY
21038: LIST
21039: PPUSH
21040: CALL_OW 72
21044: PUSH
21045: LD_INT 5
21047: GREATEREQUAL
21048: AND
21049: IFFALSE 20948
// powellAllowRetreat := false ;
21051: LD_ADDR_EXP 19
21055: PUSH
21056: LD_INT 0
21058: ST_TO_ADDR
// activeAttacks := false ;
21059: LD_ADDR_EXP 16
21063: PUSH
21064: LD_INT 0
21066: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21067: LD_INT 35
21069: PPUSH
21070: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
21074: LD_INT 22
21076: PUSH
21077: LD_INT 6
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: PPUSH
21084: CALL_OW 69
21088: PUSH
21089: LD_INT 0
21091: EQUAL
21092: IFFALSE 21067
// tmp := mc_vehicles [ 4 ] ;
21094: LD_ADDR_VAR 0 3
21098: PUSH
21099: LD_EXP 116
21103: PUSH
21104: LD_INT 4
21106: ARRAY
21107: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
21108: LD_ADDR_VAR 0 1
21112: PUSH
21113: DOUBLE
21114: LD_INT 1
21116: DEC
21117: ST_TO_ADDR
21118: LD_EXP 18
21122: PUSH
21123: FOR_TO
21124: IFFALSE 21385
// begin for j in powellSquadAttack [ i ] do
21126: LD_ADDR_VAR 0 2
21130: PUSH
21131: LD_EXP 18
21135: PUSH
21136: LD_VAR 0 1
21140: ARRAY
21141: PUSH
21142: FOR_IN
21143: IFFALSE 21381
// begin forces := forces diff j ;
21145: LD_ADDR_VAR 0 6
21149: PUSH
21150: LD_VAR 0 6
21154: PUSH
21155: LD_VAR 0 2
21159: DIFF
21160: ST_TO_ADDR
// SetTag ( j , 1 ) ;
21161: LD_VAR 0 2
21165: PPUSH
21166: LD_INT 1
21168: PPUSH
21169: CALL_OW 109
// wait ( 0 0$2 ) ;
21173: LD_INT 70
21175: PPUSH
21176: CALL_OW 67
// if IsInUnit ( j ) then
21180: LD_VAR 0 2
21184: PPUSH
21185: CALL_OW 310
21189: IFFALSE 21200
// ComExitBuilding ( j ) ;
21191: LD_VAR 0 2
21195: PPUSH
21196: CALL_OW 122
// if GetClass ( j ) <> 1 then
21200: LD_VAR 0 2
21204: PPUSH
21205: CALL_OW 257
21209: PUSH
21210: LD_INT 1
21212: NONEQUAL
21213: IFFALSE 21293
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
21215: LD_VAR 0 10
21219: PUSH
21220: LD_INT 1
21222: ARRAY
21223: PPUSH
21224: CALL_OW 313
21228: PUSH
21229: LD_INT 5
21231: GREATEREQUAL
21232: IFFALSE 21254
// AddComEnterUnit ( j , arm [ 2 ] ) else
21234: LD_VAR 0 2
21238: PPUSH
21239: LD_VAR 0 10
21243: PUSH
21244: LD_INT 2
21246: ARRAY
21247: PPUSH
21248: CALL_OW 180
21252: GO 21272
// AddComEnterUnit ( j , arm [ 1 ] ) ;
21254: LD_VAR 0 2
21258: PPUSH
21259: LD_VAR 0 10
21263: PUSH
21264: LD_INT 1
21266: ARRAY
21267: PPUSH
21268: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
21272: LD_VAR 0 2
21276: PPUSH
21277: LD_INT 1
21279: PPUSH
21280: CALL_OW 183
// AddComExitBuilding ( j ) ;
21284: LD_VAR 0 2
21288: PPUSH
21289: CALL_OW 182
// end ; if i = 2 then
21293: LD_VAR 0 1
21297: PUSH
21298: LD_INT 2
21300: EQUAL
21301: IFFALSE 21318
// AddComMoveXY ( j , 61 , 93 ) ;
21303: LD_VAR 0 2
21307: PPUSH
21308: LD_INT 61
21310: PPUSH
21311: LD_INT 93
21313: PPUSH
21314: CALL_OW 171
// if i = 1 then
21318: LD_VAR 0 1
21322: PUSH
21323: LD_INT 1
21325: EQUAL
21326: IFFALSE 21379
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21328: LD_VAR 0 2
21332: PPUSH
21333: LD_VAR 0 3
21337: PUSH
21338: LD_INT 1
21340: ARRAY
21341: PPUSH
21342: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21346: LD_ADDR_VAR 0 3
21350: PUSH
21351: LD_VAR 0 3
21355: PPUSH
21356: LD_INT 1
21358: PPUSH
21359: CALL_OW 3
21363: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21364: LD_VAR 0 2
21368: PPUSH
21369: LD_INT 69
21371: PPUSH
21372: LD_INT 94
21374: PPUSH
21375: CALL_OW 171
// end ; end ;
21379: GO 21142
21381: POP
21382: POP
// end ;
21383: GO 21123
21385: POP
21386: POP
// wait ( 0 0$30 ) ;
21387: LD_INT 1050
21389: PPUSH
21390: CALL_OW 67
// MC_Kill ( 4 ) ;
21394: LD_INT 4
21396: PPUSH
21397: CALL 35661 0 1
// tmp := UnitsInside ( fac ) ;
21401: LD_ADDR_VAR 0 3
21405: PUSH
21406: LD_VAR 0 9
21410: PPUSH
21411: CALL_OW 313
21415: ST_TO_ADDR
// if tmp then
21416: LD_VAR 0 3
21420: IFFALSE 21541
// for i in tmp do
21422: LD_ADDR_VAR 0 1
21426: PUSH
21427: LD_VAR 0 3
21431: PUSH
21432: FOR_IN
21433: IFFALSE 21539
// begin ComExitBuilding ( i ) ;
21435: LD_VAR 0 1
21439: PPUSH
21440: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21444: LD_VAR 0 10
21448: PUSH
21449: LD_INT 2
21451: ARRAY
21452: PPUSH
21453: CALL_OW 313
21457: PUSH
21458: LD_INT 6
21460: LESS
21461: IFFALSE 21483
// AddComEnterUnit ( i , arm [ 2 ] ) else
21463: LD_VAR 0 1
21467: PPUSH
21468: LD_VAR 0 10
21472: PUSH
21473: LD_INT 2
21475: ARRAY
21476: PPUSH
21477: CALL_OW 180
21481: GO 21537
// if UnitsInside ( arm [ 1 ] ) < 6 then
21483: LD_VAR 0 10
21487: PUSH
21488: LD_INT 1
21490: ARRAY
21491: PPUSH
21492: CALL_OW 313
21496: PUSH
21497: LD_INT 6
21499: LESS
21500: IFFALSE 21522
// AddComEnterUnit ( i , arm [ 1 ] ) else
21502: LD_VAR 0 1
21506: PPUSH
21507: LD_VAR 0 10
21511: PUSH
21512: LD_INT 1
21514: ARRAY
21515: PPUSH
21516: CALL_OW 180
21520: GO 21537
// AddComMoveXY ( i , 37 , 68 ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_INT 37
21529: PPUSH
21530: LD_INT 68
21532: PPUSH
21533: CALL_OW 171
// end ;
21537: GO 21432
21539: POP
21540: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21541: LD_ADDR_VAR 0 11
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_INT 26
21553: PUSH
21554: LD_INT 1
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: PPUSH
21561: CALL_OW 72
21565: PUSH
21566: LD_EXP 59
21570: DIFF
21571: ST_TO_ADDR
// if not speaker then
21572: LD_VAR 0 11
21576: NOT
21577: IFFALSE 21604
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21579: LD_ADDR_VAR 0 11
21583: PUSH
21584: LD_VAR 0 6
21588: PPUSH
21589: LD_INT 26
21591: PUSH
21592: LD_INT 1
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PPUSH
21599: CALL_OW 72
21603: ST_TO_ADDR
// if speaker then
21604: LD_VAR 0 11
21608: IFFALSE 21624
// speaker := speaker [ 1 ] ;
21610: LD_ADDR_VAR 0 11
21614: PUSH
21615: LD_VAR 0 11
21619: PUSH
21620: LD_INT 1
21622: ARRAY
21623: ST_TO_ADDR
// Video ( true ) ;
21624: LD_INT 1
21626: PPUSH
21627: CALL 103444 0 1
// CenterNowOnUnits ( Powell ) ;
21631: LD_EXP 58
21635: PPUSH
21636: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: LD_VAR 0 6
21649: PPUSH
21650: LD_INT 3
21652: PUSH
21653: LD_INT 25
21655: PUSH
21656: LD_INT 1
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: PUSH
21663: EMPTY
21664: LIST
21665: LIST
21666: PPUSH
21667: CALL_OW 72
21671: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21672: LD_ADDR_VAR 0 12
21676: PUSH
21677: LD_INT 22
21679: PUSH
21680: LD_INT 4
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: PUSH
21687: LD_INT 30
21689: PUSH
21690: LD_INT 32
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: LD_INT 58
21699: PUSH
21700: EMPTY
21701: LIST
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: PPUSH
21708: CALL_OW 69
21712: ST_TO_ADDR
// for i = 1 to 6 do
21713: LD_ADDR_VAR 0 1
21717: PUSH
21718: DOUBLE
21719: LD_INT 1
21721: DEC
21722: ST_TO_ADDR
21723: LD_INT 6
21725: PUSH
21726: FOR_TO
21727: IFFALSE 21868
// begin if IsInUnit ( tmp [ i ] ) then
21729: LD_VAR 0 3
21733: PUSH
21734: LD_VAR 0 1
21738: ARRAY
21739: PPUSH
21740: CALL_OW 310
21744: IFFALSE 21761
// ComExitBuilding ( tmp [ i ] ) ;
21746: LD_VAR 0 3
21750: PUSH
21751: LD_VAR 0 1
21755: ARRAY
21756: PPUSH
21757: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21761: LD_VAR 0 3
21765: PUSH
21766: LD_VAR 0 1
21770: ARRAY
21771: PPUSH
21772: LD_VAR 0 10
21776: PUSH
21777: LD_INT 1
21779: ARRAY
21780: PPUSH
21781: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21785: LD_VAR 0 3
21789: PUSH
21790: LD_VAR 0 1
21794: ARRAY
21795: PPUSH
21796: LD_INT 1
21798: PPUSH
21799: CALL_OW 183
// if emp_towers then
21803: LD_VAR 0 12
21807: IFFALSE 21866
// begin AddComExitBuilding ( tmp [ i ] ) ;
21809: LD_VAR 0 3
21813: PUSH
21814: LD_VAR 0 1
21818: ARRAY
21819: PPUSH
21820: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21824: LD_VAR 0 3
21828: PUSH
21829: LD_VAR 0 1
21833: ARRAY
21834: PPUSH
21835: LD_VAR 0 12
21839: PUSH
21840: LD_INT 1
21842: ARRAY
21843: PPUSH
21844: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21848: LD_ADDR_VAR 0 12
21852: PUSH
21853: LD_VAR 0 12
21857: PPUSH
21858: LD_INT 1
21860: PPUSH
21861: CALL_OW 3
21865: ST_TO_ADDR
// end ; end ;
21866: GO 21726
21868: POP
21869: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_EXP 18
21879: PUSH
21880: LD_INT 1
21882: ARRAY
21883: PUSH
21884: LD_EXP 18
21888: PUSH
21889: LD_INT 2
21891: ARRAY
21892: ADD
21893: PPUSH
21894: LD_INT 26
21896: PUSH
21897: LD_INT 1
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: PPUSH
21904: CALL_OW 72
21908: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21909: LD_ADDR_VAR 0 1
21913: PUSH
21914: LD_EXP 18
21918: PUSH
21919: LD_INT 2
21921: ARRAY
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21942
// ComTurnUnit ( i , Powell ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_EXP 58
21935: PPUSH
21936: CALL_OW 119
21940: GO 21923
21942: POP
21943: POP
// Say ( Powell , D5-Pow-1 ) ;
21944: LD_EXP 58
21948: PPUSH
21949: LD_STRING D5-Pow-1
21951: PPUSH
21952: CALL_OW 88
// if tmp then
21956: LD_VAR 0 3
21960: IFFALSE 21978
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21962: LD_VAR 0 3
21966: PUSH
21967: LD_INT 1
21969: ARRAY
21970: PPUSH
21971: LD_STRING D5-Sol2-1
21973: PPUSH
21974: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21978: LD_EXP 58
21982: PPUSH
21983: LD_STRING D5-Pow-2
21985: PPUSH
21986: CALL_OW 88
// if tmp > 1 then
21990: LD_VAR 0 3
21994: PUSH
21995: LD_INT 1
21997: GREATER
21998: IFFALSE 22016
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
22000: LD_VAR 0 3
22004: PUSH
22005: LD_INT 2
22007: ARRAY
22008: PPUSH
22009: LD_STRING D5-Sol2-2
22011: PPUSH
22012: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
22016: LD_EXP 58
22020: PPUSH
22021: LD_STRING D5-Pow-3
22023: PPUSH
22024: CALL_OW 88
// wait ( 0 0$1 ) ;
22028: LD_INT 35
22030: PPUSH
22031: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
22035: LD_ADDR_VAR 0 3
22039: PUSH
22040: LD_EXP 18
22044: PUSH
22045: LD_INT 1
22047: ARRAY
22048: PUSH
22049: LD_EXP 18
22053: PUSH
22054: LD_INT 2
22056: ARRAY
22057: UNION
22058: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
22059: LD_VAR 0 3
22063: PPUSH
22064: LD_INT 80
22066: PPUSH
22067: LD_INT 67
22069: PPUSH
22070: CALL_OW 114
// wait ( 0 0$2 ) ;
22074: LD_INT 70
22076: PPUSH
22077: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
22081: LD_INT 79
22083: PPUSH
22084: LD_INT 72
22086: PPUSH
22087: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
22091: LD_INT 70
22093: PPUSH
22094: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
22098: LD_VAR 0 3
22102: PPUSH
22103: LD_INT 3
22105: PUSH
22106: LD_INT 24
22108: PUSH
22109: LD_INT 1000
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PPUSH
22120: CALL_OW 72
22124: IFFALSE 22091
// Say ( Powell , D5a-Pow-1 ) ;
22126: LD_EXP 58
22130: PPUSH
22131: LD_STRING D5a-Pow-1
22133: PPUSH
22134: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
22138: LD_EXP 58
22142: PPUSH
22143: LD_STRING D5a-Pow-1a
22145: PPUSH
22146: CALL_OW 88
// wait ( 0 0$0.7 ) ;
22150: LD_INT 24
22152: PPUSH
22153: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
22157: LD_EXP 58
22161: PPUSH
22162: LD_STRING D5a-Pow-1b
22164: PPUSH
22165: CALL_OW 88
// wait ( 0 0$0.3 ) ;
22169: LD_INT 10
22171: PPUSH
22172: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
22176: LD_EXP 58
22180: PPUSH
22181: LD_STRING D5a-Pow-1c
22183: PPUSH
22184: CALL_OW 88
// wait ( 0 0$0.5 ) ;
22188: LD_INT 18
22190: PPUSH
22191: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
22195: LD_EXP 58
22199: PPUSH
22200: LD_STRING D5a-Pow-1d
22202: PPUSH
22203: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
22207: LD_INT 35
22209: PPUSH
22210: CALL_OW 67
// if not HasTask ( tmp ) then
22214: LD_VAR 0 3
22218: PPUSH
22219: CALL_OW 314
22223: NOT
22224: IFFALSE 22241
// ComAgressiveMove ( tmp , 80 , 67 ) ;
22226: LD_VAR 0 3
22230: PPUSH
22231: LD_INT 80
22233: PPUSH
22234: LD_INT 67
22236: PPUSH
22237: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
22241: LD_VAR 0 3
22245: PPUSH
22246: LD_INT 24
22248: PUSH
22249: LD_INT 1
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 72
22260: NOT
22261: IFFALSE 22207
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
22263: LD_ADDR_VAR 0 3
22267: PUSH
22268: LD_INT 22
22270: PUSH
22271: LD_INT 4
22273: PUSH
22274: EMPTY
22275: LIST
22276: LIST
22277: PUSH
22278: LD_INT 92
22280: PUSH
22281: LD_INT 60
22283: PUSH
22284: LD_INT 93
22286: PUSH
22287: LD_INT 10
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: LIST
22294: LIST
22295: PUSH
22296: LD_INT 3
22298: PUSH
22299: LD_INT 54
22301: PUSH
22302: EMPTY
22303: LIST
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: LIST
22313: PPUSH
22314: CALL_OW 69
22318: PUSH
22319: LD_EXP 58
22323: DIFF
22324: ST_TO_ADDR
// if tmp then
22325: LD_VAR 0 3
22329: IFFALSE 22363
// for i in tmp do
22331: LD_ADDR_VAR 0 1
22335: PUSH
22336: LD_VAR 0 3
22340: PUSH
22341: FOR_IN
22342: IFFALSE 22361
// ComMoveXY ( i , 36 , 67 ) ;
22344: LD_VAR 0 1
22348: PPUSH
22349: LD_INT 36
22351: PPUSH
22352: LD_INT 67
22354: PPUSH
22355: CALL_OW 111
22359: GO 22341
22361: POP
22362: POP
// wait ( 0 0$3 ) ;
22363: LD_INT 105
22365: PPUSH
22366: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22370: LD_VAR 0 11
22374: PPUSH
22375: LD_STRING D6-Sol3-1
22377: PPUSH
22378: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22382: LD_EXP 58
22386: PPUSH
22387: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22391: LD_EXP 58
22395: PPUSH
22396: LD_STRING D6-Pow-1
22398: PPUSH
22399: CALL_OW 88
// tmp := [ ] ;
22403: LD_ADDR_VAR 0 3
22407: PUSH
22408: EMPTY
22409: ST_TO_ADDR
// for i = 1 to 2 do
22410: LD_ADDR_VAR 0 1
22414: PUSH
22415: DOUBLE
22416: LD_INT 1
22418: DEC
22419: ST_TO_ADDR
22420: LD_INT 2
22422: PUSH
22423: FOR_TO
22424: IFFALSE 22538
// begin uc_side := 8 ;
22426: LD_ADDR_OWVAR 20
22430: PUSH
22431: LD_INT 8
22433: ST_TO_ADDR
// uc_nation := 2 ;
22434: LD_ADDR_OWVAR 21
22438: PUSH
22439: LD_INT 2
22441: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22442: LD_INT 14
22444: PPUSH
22445: LD_INT 3
22447: PPUSH
22448: LD_INT 2
22450: PPUSH
22451: LD_INT 29
22453: PPUSH
22454: LD_INT 100
22456: PPUSH
22457: CALL 71038 0 5
// veh := CreateVehicle ;
22461: LD_ADDR_VAR 0 13
22465: PUSH
22466: CALL_OW 45
22470: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22471: LD_VAR 0 13
22475: PPUSH
22476: LD_INT 4
22478: PPUSH
22479: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
22483: LD_VAR 0 13
22487: PPUSH
22488: LD_INT 99
22490: PPUSH
22491: LD_INT 83
22493: PPUSH
22494: LD_INT 3
22496: PPUSH
22497: LD_INT 0
22499: PPUSH
22500: CALL_OW 50
// wait ( 3 ) ;
22504: LD_INT 3
22506: PPUSH
22507: CALL_OW 67
// Connect ( veh ) ;
22511: LD_VAR 0 13
22515: PPUSH
22516: CALL 74129 0 1
// tmp := tmp ^ veh ;
22520: LD_ADDR_VAR 0 3
22524: PUSH
22525: LD_VAR 0 3
22529: PUSH
22530: LD_VAR 0 13
22534: ADD
22535: ST_TO_ADDR
// end ;
22536: GO 22423
22538: POP
22539: POP
// wait ( 0 0$1 ) ;
22540: LD_INT 35
22542: PPUSH
22543: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22547: LD_INT 99
22549: PPUSH
22550: LD_INT 83
22552: PPUSH
22553: LD_INT 1
22555: PPUSH
22556: LD_INT 10
22558: PPUSH
22559: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22563: LD_INT 99
22565: PPUSH
22566: LD_INT 83
22568: PPUSH
22569: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22573: LD_VAR 0 11
22577: PPUSH
22578: LD_STRING D6-Sol3-2
22580: PPUSH
22581: CALL_OW 88
// async ;
22585: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22586: LD_EXP 58
22590: PPUSH
22591: LD_STRING D6-Pow-2
22593: PPUSH
22594: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22598: LD_VAR 0 3
22602: PUSH
22603: LD_INT 1
22605: ARRAY
22606: PPUSH
22607: LD_VAR 0 9
22611: PPUSH
22612: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22616: LD_VAR 0 3
22620: PUSH
22621: LD_INT 2
22623: ARRAY
22624: PPUSH
22625: LD_INT 22
22627: PUSH
22628: LD_INT 4
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: PUSH
22635: LD_INT 21
22637: PUSH
22638: LD_INT 3
22640: PUSH
22641: EMPTY
22642: LIST
22643: LIST
22644: PUSH
22645: EMPTY
22646: LIST
22647: LIST
22648: PPUSH
22649: CALL_OW 69
22653: PPUSH
22654: LD_VAR 0 3
22658: PUSH
22659: LD_INT 2
22661: ARRAY
22662: PPUSH
22663: CALL_OW 74
22667: PPUSH
22668: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22672: LD_EXP 58
22676: PPUSH
22677: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22681: LD_INT 99
22683: PPUSH
22684: LD_INT 83
22686: PPUSH
22687: LD_INT 1
22689: PPUSH
22690: CALL_OW 331
// repeat wait ( 4 ) ;
22694: LD_INT 4
22696: PPUSH
22697: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22701: LD_VAR 0 3
22705: PUSH
22706: LD_INT 1
22708: ARRAY
22709: PPUSH
22710: CALL_OW 256
22714: PUSH
22715: LD_INT 1000
22717: LESS
22718: IFFALSE 22736
// SetLives ( tmp [ 1 ] , 1000 ) ;
22720: LD_VAR 0 3
22724: PUSH
22725: LD_INT 1
22727: ARRAY
22728: PPUSH
22729: LD_INT 1000
22731: PPUSH
22732: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22736: LD_INT 22
22738: PUSH
22739: LD_INT 4
22741: PUSH
22742: EMPTY
22743: LIST
22744: LIST
22745: PUSH
22746: LD_INT 30
22748: PUSH
22749: LD_INT 3
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PPUSH
22760: CALL_OW 69
22764: PUSH
22765: LD_INT 0
22767: EQUAL
22768: IFFALSE 22694
// skirmish := false ;
22770: LD_ADDR_EXP 95
22774: PUSH
22775: LD_INT 0
22777: ST_TO_ADDR
// sync ;
22778: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22779: LD_EXP 58
22783: PPUSH
22784: LD_STRING D6a-Pow-1
22786: PPUSH
22787: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
22791: LD_VAR 0 11
22795: PPUSH
22796: LD_STRING D6a-Sol3-1
22798: PPUSH
22799: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22803: LD_EXP 58
22807: PPUSH
22808: LD_STRING D6a-Pow-2
22810: PPUSH
22811: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
22815: LD_VAR 0 11
22819: PPUSH
22820: LD_STRING D6a-Sol3-2
22822: PPUSH
22823: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22827: LD_EXP 58
22831: PPUSH
22832: LD_STRING D6a-Pow-3
22834: PPUSH
22835: CALL_OW 88
// powellCenterCameraMode := true ;
22839: LD_ADDR_EXP 20
22843: PUSH
22844: LD_INT 1
22846: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22847: LD_ADDR_VAR 0 1
22851: PUSH
22852: LD_INT 22
22854: PUSH
22855: LD_INT 8
22857: PUSH
22858: EMPTY
22859: LIST
22860: LIST
22861: PUSH
22862: LD_INT 25
22864: PUSH
22865: LD_INT 2
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: PPUSH
22876: CALL_OW 69
22880: PUSH
22881: FOR_IN
22882: IFFALSE 22937
// begin SetTag ( i , 1 ) ;
22884: LD_VAR 0 1
22888: PPUSH
22889: LD_INT 1
22891: PPUSH
22892: CALL_OW 109
// ComExitBuilding ( i ) ;
22896: LD_VAR 0 1
22900: PPUSH
22901: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22905: LD_VAR 0 1
22909: PPUSH
22910: LD_INT 35
22912: PPUSH
22913: LD_INT 6
22915: PPUSH
22916: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22920: LD_VAR 0 1
22924: PPUSH
22925: LD_INT 53
22927: PPUSH
22928: LD_INT 4
22930: PPUSH
22931: CALL_OW 171
// end ;
22935: GO 22881
22937: POP
22938: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22939: LD_ADDR_VAR 0 3
22943: PUSH
22944: LD_INT 22
22946: PUSH
22947: LD_INT 4
22949: PUSH
22950: EMPTY
22951: LIST
22952: LIST
22953: PUSH
22954: LD_INT 21
22956: PUSH
22957: LD_INT 2
22959: PUSH
22960: EMPTY
22961: LIST
22962: LIST
22963: PUSH
22964: LD_INT 3
22966: PUSH
22967: LD_INT 34
22969: PUSH
22970: LD_INT 12
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: PPUSH
22986: CALL_OW 69
22990: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_VAR 0 3
23000: PPUSH
23001: LD_EXP 58
23005: PPUSH
23006: CALL_OW 74
23010: PPUSH
23011: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
23015: LD_EXP 58
23019: PPUSH
23020: LD_INT 100
23022: PPUSH
23023: LD_INT 88
23025: PPUSH
23026: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
23030: LD_EXP 58
23034: PPUSH
23035: LD_INT 100
23037: PPUSH
23038: LD_INT 75
23040: PPUSH
23041: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
23045: LD_EXP 58
23049: PPUSH
23050: LD_INT 88
23052: PPUSH
23053: LD_INT 53
23055: PPUSH
23056: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
23060: LD_INT 8
23062: PPUSH
23063: LD_EXP 58
23067: PPUSH
23068: CALL_OW 471
// repeat wait ( 3 ) ;
23072: LD_INT 3
23074: PPUSH
23075: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
23079: LD_INT 22
23081: PUSH
23082: LD_INT 4
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 92
23091: PUSH
23092: LD_INT 100
23094: PUSH
23095: LD_INT 75
23097: PUSH
23098: LD_INT 6
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PPUSH
23111: CALL_OW 69
23115: IFFALSE 23072
// async ;
23117: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
23118: LD_EXP 58
23122: PPUSH
23123: LD_STRING D6b-Pow-1
23125: PPUSH
23126: CALL_OW 88
// repeat wait ( 3 ) ;
23130: LD_INT 3
23132: PPUSH
23133: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
23137: LD_EXP 58
23141: PPUSH
23142: CALL_OW 310
23146: PPUSH
23147: CALL_OW 256
23151: PUSH
23152: LD_INT 1000
23154: LESS
23155: IFFALSE 23174
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
23157: LD_EXP 58
23161: PPUSH
23162: CALL_OW 310
23166: PPUSH
23167: LD_INT 1000
23169: PPUSH
23170: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
23174: LD_EXP 58
23178: PPUSH
23179: CALL_OW 256
23183: PUSH
23184: LD_INT 1000
23186: LESS
23187: IFFALSE 23201
// SetLives ( Powell , 1000 ) ;
23189: LD_EXP 58
23193: PPUSH
23194: LD_INT 1000
23196: PPUSH
23197: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
23201: LD_EXP 58
23205: PPUSH
23206: LD_EXP 63
23210: PPUSH
23211: CALL_OW 296
23215: PUSH
23216: LD_INT 5
23218: LESS
23219: PUSH
23220: LD_EXP 58
23224: PPUSH
23225: CALL_OW 310
23229: PPUSH
23230: LD_EXP 63
23234: PPUSH
23235: CALL_OW 296
23239: PUSH
23240: LD_INT 5
23242: LESS
23243: OR
23244: IFFALSE 23263
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
23246: LD_EXP 58
23250: PPUSH
23251: CALL_OW 310
23255: PPUSH
23256: LD_INT 100
23258: PPUSH
23259: CALL_OW 234
// until not IsInUnit ( Powell ) ;
23263: LD_EXP 58
23267: PPUSH
23268: CALL_OW 310
23272: NOT
23273: IFFALSE 23130
// DoNotAttack ( 8 , powellBomb ) ;
23275: LD_INT 8
23277: PPUSH
23278: LD_EXP 63
23282: PPUSH
23283: CALL_OW 471
// game_speed := 4 ;
23287: LD_ADDR_OWVAR 65
23291: PUSH
23292: LD_INT 4
23294: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
23295: LD_EXP 58
23299: PPUSH
23300: LD_STRING D6b-Pow-1a
23302: PPUSH
23303: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
23307: LD_EXP 58
23311: PPUSH
23312: LD_EXP 63
23316: PPUSH
23317: CALL_OW 180
// sync ;
23321: SYNC
// repeat wait ( 0 0$1 ) ;
23322: LD_INT 35
23324: PPUSH
23325: CALL_OW 67
// until IsInUnit ( Powell ) ;
23329: LD_EXP 58
23333: PPUSH
23334: CALL_OW 310
23338: IFFALSE 23322
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23340: LD_INT 8
23342: PPUSH
23343: LD_EXP 58
23347: PPUSH
23348: CALL_OW 310
23352: PPUSH
23353: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23357: LD_EXP 58
23361: PPUSH
23362: LD_INT 91
23364: PPUSH
23365: LD_INT 44
23367: PPUSH
23368: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23372: LD_EXP 58
23376: PPUSH
23377: LD_INT 96
23379: PPUSH
23380: LD_INT 44
23382: PPUSH
23383: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23387: LD_EXP 58
23391: PPUSH
23392: LD_INT 96
23394: PPUSH
23395: LD_INT 41
23397: PPUSH
23398: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23402: LD_EXP 58
23406: PPUSH
23407: LD_INT 92
23409: PPUSH
23410: LD_INT 39
23412: PPUSH
23413: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23417: LD_EXP 58
23421: PPUSH
23422: LD_INT 88
23424: PPUSH
23425: LD_INT 41
23427: PPUSH
23428: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23432: LD_EXP 58
23436: PPUSH
23437: LD_INT 91
23439: PPUSH
23440: LD_INT 44
23442: PPUSH
23443: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23447: LD_EXP 58
23451: PPUSH
23452: LD_INT 96
23454: PPUSH
23455: LD_INT 44
23457: PPUSH
23458: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23462: LD_EXP 58
23466: PPUSH
23467: LD_INT 96
23469: PPUSH
23470: LD_INT 41
23472: PPUSH
23473: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23477: LD_EXP 58
23481: PPUSH
23482: LD_INT 92
23484: PPUSH
23485: LD_INT 39
23487: PPUSH
23488: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23492: LD_EXP 58
23496: PPUSH
23497: LD_INT 88
23499: PPUSH
23500: LD_INT 41
23502: PPUSH
23503: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23507: LD_EXP 58
23511: PPUSH
23512: LD_INT 91
23514: PPUSH
23515: LD_INT 44
23517: PPUSH
23518: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23522: LD_EXP 58
23526: PPUSH
23527: LD_INT 93
23529: PPUSH
23530: LD_INT 39
23532: PPUSH
23533: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23537: LD_EXP 58
23541: PPUSH
23542: LD_INT 93
23544: PPUSH
23545: LD_INT 36
23547: PPUSH
23548: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23552: LD_INT 122
23554: PPUSH
23555: CALL_OW 67
// game_speed := 4 ;
23559: LD_ADDR_OWVAR 65
23563: PUSH
23564: LD_INT 4
23566: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23567: LD_EXP 58
23571: PPUSH
23572: LD_STRING D6b-Pow-1b
23574: PPUSH
23575: CALL_OW 88
// tmp := [ ] ;
23579: LD_ADDR_VAR 0 3
23583: PUSH
23584: EMPTY
23585: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23586: LD_ADDR_VAR 0 5
23590: PUSH
23591: LD_INT 78
23593: PUSH
23594: LD_INT 47
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 106
23603: PUSH
23604: LD_INT 53
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23615: LD_ADDR_VAR 0 1
23619: PUSH
23620: LD_INT 22
23622: PUSH
23623: LD_INT 8
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: PUSH
23630: LD_INT 21
23632: PUSH
23633: LD_INT 3
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: PUSH
23640: LD_INT 92
23642: PUSH
23643: LD_INT 90
23645: PUSH
23646: LD_INT 52
23648: PUSH
23649: LD_INT 12
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: LIST
23662: PPUSH
23663: CALL_OW 69
23667: PUSH
23668: FOR_IN
23669: IFFALSE 23694
// tmp := tmp ^ UnitsInside ( i ) ;
23671: LD_ADDR_VAR 0 3
23675: PUSH
23676: LD_VAR 0 3
23680: PUSH
23681: LD_VAR 0 1
23685: PPUSH
23686: CALL_OW 313
23690: ADD
23691: ST_TO_ADDR
23692: GO 23668
23694: POP
23695: POP
// for i in tmp do
23696: LD_ADDR_VAR 0 1
23700: PUSH
23701: LD_VAR 0 3
23705: PUSH
23706: FOR_IN
23707: IFFALSE 23869
// begin dist := 9999 ;
23709: LD_ADDR_VAR 0 8
23713: PUSH
23714: LD_INT 9999
23716: ST_TO_ADDR
// _xy := [ ] ;
23717: LD_ADDR_VAR 0 7
23721: PUSH
23722: EMPTY
23723: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23724: LD_VAR 0 1
23728: PPUSH
23729: LD_INT 1
23731: PPUSH
23732: CALL_OW 109
// ComExitBuilding ( i ) ;
23736: LD_VAR 0 1
23740: PPUSH
23741: CALL_OW 122
// for j in xy do
23745: LD_ADDR_VAR 0 2
23749: PUSH
23750: LD_VAR 0 5
23754: PUSH
23755: FOR_IN
23756: IFFALSE 23838
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23758: LD_VAR 0 1
23762: PPUSH
23763: LD_VAR 0 2
23767: PUSH
23768: LD_INT 1
23770: ARRAY
23771: PPUSH
23772: LD_VAR 0 2
23776: PUSH
23777: LD_INT 2
23779: ARRAY
23780: PPUSH
23781: CALL_OW 297
23785: PUSH
23786: LD_VAR 0 8
23790: LESS
23791: IFFALSE 23836
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23793: LD_ADDR_VAR 0 8
23797: PUSH
23798: LD_VAR 0 1
23802: PPUSH
23803: LD_VAR 0 2
23807: PUSH
23808: LD_INT 1
23810: ARRAY
23811: PPUSH
23812: LD_VAR 0 2
23816: PUSH
23817: LD_INT 2
23819: ARRAY
23820: PPUSH
23821: CALL_OW 297
23825: ST_TO_ADDR
// _xy := j ;
23826: LD_ADDR_VAR 0 7
23830: PUSH
23831: LD_VAR 0 2
23835: ST_TO_ADDR
// end ;
23836: GO 23755
23838: POP
23839: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23840: LD_VAR 0 1
23844: PPUSH
23845: LD_VAR 0 7
23849: PUSH
23850: LD_INT 1
23852: ARRAY
23853: PPUSH
23854: LD_VAR 0 7
23858: PUSH
23859: LD_INT 2
23861: ARRAY
23862: PPUSH
23863: CALL_OW 171
// end ;
23867: GO 23706
23869: POP
23870: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23871: LD_ADDR_VAR 0 4
23875: PUSH
23876: LD_VAR 0 3
23880: PPUSH
23881: LD_INT 26
23883: PUSH
23884: LD_INT 1
23886: PUSH
23887: EMPTY
23888: LIST
23889: LIST
23890: PUSH
23891: LD_INT 25
23893: PUSH
23894: LD_INT 1
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PPUSH
23905: CALL_OW 72
23909: ST_TO_ADDR
// if tmp2 < 2 then
23910: LD_VAR 0 4
23914: PUSH
23915: LD_INT 2
23917: LESS
23918: IFFALSE 23987
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23920: LD_ADDR_VAR 0 4
23924: PUSH
23925: LD_INT 22
23927: PUSH
23928: LD_INT 8
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 26
23937: PUSH
23938: LD_INT 1
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: LD_INT 3
23947: PUSH
23948: LD_INT 25
23950: PUSH
23951: LD_INT 15
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: EMPTY
23959: LIST
23960: LIST
23961: PUSH
23962: EMPTY
23963: LIST
23964: LIST
23965: LIST
23966: PPUSH
23967: CALL_OW 69
23971: PUSH
23972: LD_EXP 60
23976: PUSH
23977: LD_EXP 61
23981: PUSH
23982: EMPTY
23983: LIST
23984: LIST
23985: DIFF
23986: ST_TO_ADDR
// if tmp2 then
23987: LD_VAR 0 4
23991: IFFALSE 24009
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23993: LD_VAR 0 4
23997: PUSH
23998: LD_INT 1
24000: ARRAY
24001: PPUSH
24002: LD_STRING D6b-ArSol1-1
24004: PPUSH
24005: CALL_OW 88
// async ;
24009: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
24010: LD_EXP 58
24014: PPUSH
24015: LD_STRING D6b-Pow-2
24017: PPUSH
24018: CALL_OW 88
// wait ( 0 0$1 ) ;
24022: LD_INT 35
24024: PPUSH
24025: CALL_OW 67
// if tmp2 > 1 then
24029: LD_VAR 0 4
24033: PUSH
24034: LD_INT 1
24036: GREATER
24037: IFFALSE 24055
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
24039: LD_VAR 0 4
24043: PUSH
24044: LD_INT 2
24046: ARRAY
24047: PPUSH
24048: LD_STRING D6b-ArSol2-1
24050: PPUSH
24051: CALL_OW 88
// sync ;
24055: SYNC
// repeat wait ( 5 ) ;
24056: LD_INT 5
24058: PPUSH
24059: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
24063: LD_INT 93
24065: PPUSH
24066: LD_INT 36
24068: PPUSH
24069: CALL_OW 428
24073: PPUSH
24074: CALL_OW 255
24078: PUSH
24079: LD_INT 4
24081: EQUAL
24082: IFFALSE 24056
// DialogueOn ;
24084: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
24088: LD_INT 10
24090: PPUSH
24091: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
24095: LD_EXP 58
24099: PPUSH
24100: LD_STRING D6b-Pow-2a
24102: PPUSH
24103: CALL_OW 88
// DialogueOff ;
24107: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
24111: LD_EXP 58
24115: PPUSH
24116: CALL_OW 310
24120: PPUSH
24121: LD_INT 332
24123: PPUSH
24124: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
24128: LD_INT 93
24130: PPUSH
24131: LD_INT 35
24133: PPUSH
24134: LD_INT 1
24136: PPUSH
24137: LD_INT 6
24139: NEG
24140: PPUSH
24141: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
24145: LD_INT 35
24147: PPUSH
24148: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
24152: LD_INT 332
24154: PPUSH
24155: CALL_OW 256
24159: PUSH
24160: LD_INT 1000
24162: LESS
24163: PUSH
24164: LD_INT 332
24166: PPUSH
24167: CALL_OW 300
24171: AND
24172: IFFALSE 24184
// SetLives ( kozlov_fac , 0 ) ;
24174: LD_INT 332
24176: PPUSH
24177: LD_INT 0
24179: PPUSH
24180: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
24184: LD_INT 332
24186: PPUSH
24187: CALL_OW 301
24191: PUSH
24192: LD_EXP 58
24196: PPUSH
24197: CALL_OW 301
24201: OR
24202: IFFALSE 24145
// game_speed := 4 ;
24204: LD_ADDR_OWVAR 65
24208: PUSH
24209: LD_INT 4
24211: ST_TO_ADDR
// powellCenterCameraMode := false ;
24212: LD_ADDR_EXP 20
24216: PUSH
24217: LD_INT 0
24219: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24220: LD_ADDR_VAR 0 1
24224: PUSH
24225: LD_VAR 0 3
24229: PUSH
24230: LD_INT 22
24232: PUSH
24233: LD_INT 8
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PUSH
24240: LD_INT 25
24242: PUSH
24243: LD_INT 2
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PPUSH
24254: CALL_OW 69
24258: UNION
24259: PUSH
24260: FOR_IN
24261: IFFALSE 24277
// SetTag ( i , 0 ) ;
24263: LD_VAR 0 1
24267: PPUSH
24268: LD_INT 0
24270: PPUSH
24271: CALL_OW 109
24275: GO 24260
24277: POP
24278: POP
// wait ( 0 0$3 ) ;
24279: LD_INT 105
24281: PPUSH
24282: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
24286: LD_INT 93
24288: PPUSH
24289: LD_INT 35
24291: PPUSH
24292: LD_INT 1
24294: PPUSH
24295: CALL_OW 331
// DialogueOn ;
24299: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
24303: LD_VAR 0 11
24307: PPUSH
24308: LD_STRING D6c-Sol3-1
24310: PPUSH
24311: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24315: LD_INT 10
24317: PPUSH
24318: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24322: LD_EXP 39
24326: PPUSH
24327: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24331: LD_EXP 39
24335: PPUSH
24336: LD_STRING D6c-JMM-1
24338: PPUSH
24339: CALL_OW 88
// if Cyrus then
24343: LD_EXP 45
24347: IFFALSE 24361
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24349: LD_EXP 45
24353: PPUSH
24354: LD_STRING D6c-Cyrus-1
24356: PPUSH
24357: CALL_OW 88
// if Bobby then
24361: LD_EXP 44
24365: IFFALSE 24379
// Say ( Bobby , D6c-Bobby-1 ) ;
24367: LD_EXP 44
24371: PPUSH
24372: LD_STRING D6c-Bobby-1
24374: PPUSH
24375: CALL_OW 88
// if Cornel then
24379: LD_EXP 50
24383: IFFALSE 24397
// Say ( Cornel , D6c-Corn-1 ) ;
24385: LD_EXP 50
24389: PPUSH
24390: LD_STRING D6c-Corn-1
24392: PPUSH
24393: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff ( speaker union JMM union vip ) ;
24397: LD_ADDR_VAR 0 4
24401: PUSH
24402: LD_INT 2
24404: PUSH
24405: LD_INT 22
24407: PUSH
24408: LD_INT 1
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: PUSH
24415: LD_INT 22
24417: PUSH
24418: LD_INT 4
24420: PUSH
24421: EMPTY
24422: LIST
24423: LIST
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: LIST
24429: PUSH
24430: LD_INT 26
24432: PUSH
24433: LD_INT 1
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: PUSH
24440: LD_INT 3
24442: PUSH
24443: LD_INT 25
24445: PUSH
24446: LD_INT 16
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: LD_INT 25
24455: PUSH
24456: LD_INT 12
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: LIST
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: LIST
24472: PPUSH
24473: CALL_OW 69
24477: PUSH
24478: LD_VAR 0 11
24482: PUSH
24483: LD_EXP 39
24487: UNION
24488: PUSH
24489: LD_EXP 59
24493: UNION
24494: DIFF
24495: ST_TO_ADDR
// if tmp2 then
24496: LD_VAR 0 4
24500: IFFALSE 24518
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24502: LD_VAR 0 4
24506: PUSH
24507: LD_INT 1
24509: ARRAY
24510: PPUSH
24511: LD_STRING D6c-Sol1-1
24513: PPUSH
24514: CALL_OW 88
// if Lisa then
24518: LD_EXP 42
24522: IFFALSE 24536
// Say ( Lisa , D6c-Lisa-1 ) ;
24524: LD_EXP 42
24528: PPUSH
24529: LD_STRING D6c-Lisa-1
24531: PPUSH
24532: CALL_OW 88
// if Gary then
24536: LD_EXP 51
24540: IFFALSE 24554
// Say ( Gary , D6c-Gary-1 ) ;
24542: LD_EXP 51
24546: PPUSH
24547: LD_STRING D6c-Gary-1
24549: PPUSH
24550: CALL_OW 88
// if Donaldson then
24554: LD_EXP 43
24558: IFFALSE 24572
// Say ( Donaldson , D6c-Don-1 ) ;
24560: LD_EXP 43
24564: PPUSH
24565: LD_STRING D6c-Don-1
24567: PPUSH
24568: CALL_OW 88
// if tmp2 > 1 then
24572: LD_VAR 0 4
24576: PUSH
24577: LD_INT 1
24579: GREATER
24580: IFFALSE 24598
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24582: LD_VAR 0 4
24586: PUSH
24587: LD_INT 2
24589: ARRAY
24590: PPUSH
24591: LD_STRING D6c-Sol2-1
24593: PPUSH
24594: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
24598: LD_EXP 39
24602: PPUSH
24603: CALL_OW 87
// Say ( speaker , D6c-Sol3-2 ) ;
24607: LD_VAR 0 11
24611: PPUSH
24612: LD_STRING D6c-Sol3-2
24614: PPUSH
24615: CALL_OW 88
// dwait ( 0 0$2 ) ;
24619: LD_INT 70
24621: PPUSH
24622: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24626: LD_EXP 39
24630: PPUSH
24631: LD_STRING D6c-JMM-2
24633: PPUSH
24634: CALL_OW 88
// DialogueOff ;
24638: CALL_OW 7
// Video ( false ) ;
24642: LD_INT 0
24644: PPUSH
24645: CALL 103444 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24649: LD_INT 22
24651: PUSH
24652: LD_INT 4
24654: PUSH
24655: EMPTY
24656: LIST
24657: LIST
24658: PPUSH
24659: CALL_OW 69
24663: PPUSH
24664: LD_INT 1
24666: PPUSH
24667: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24671: LD_INT 4
24673: PPUSH
24674: LD_INT 4
24676: PPUSH
24677: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24681: LD_ADDR_VAR 0 1
24685: PUSH
24686: LD_INT 4
24688: PPUSH
24689: LD_INT 1
24691: PPUSH
24692: LD_INT 2
24694: PPUSH
24695: CALL 66086 0 3
24699: PUSH
24700: FOR_IN
24701: IFFALSE 24738
// if GetTech ( i , 1 ) <> state_researched then
24703: LD_VAR 0 1
24707: PPUSH
24708: LD_INT 1
24710: PPUSH
24711: CALL_OW 321
24715: PUSH
24716: LD_INT 2
24718: NONEQUAL
24719: IFFALSE 24736
// SetTech ( i , 1 , state_researched ) ;
24721: LD_VAR 0 1
24725: PPUSH
24726: LD_INT 1
24728: PPUSH
24729: LD_INT 2
24731: PPUSH
24732: CALL_OW 322
24736: GO 24700
24738: POP
24739: POP
// missionStage := 6 ;
24740: LD_ADDR_EXP 15
24744: PUSH
24745: LD_INT 6
24747: ST_TO_ADDR
// activeAttacks := true ;
24748: LD_ADDR_EXP 16
24752: PUSH
24753: LD_INT 1
24755: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24756: LD_STRING M2
24758: PPUSH
24759: CALL_OW 337
// SaveForQuickRestart ;
24763: CALL_OW 22
// wait ( 0 0$40 ) ;
24767: LD_INT 1400
24769: PPUSH
24770: CALL_OW 67
// DialogueOn ;
24774: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24778: LD_EXP 62
24782: PPUSH
24783: LD_STRING D7-Friend-1
24785: PPUSH
24786: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24790: LD_EXP 39
24794: PPUSH
24795: LD_STRING D7-JMM-1
24797: PPUSH
24798: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24802: LD_EXP 62
24806: PPUSH
24807: LD_STRING D7-Friend-2
24809: PPUSH
24810: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24814: LD_EXP 39
24818: PPUSH
24819: LD_STRING D7-JMM-2
24821: PPUSH
24822: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24826: LD_EXP 62
24830: PPUSH
24831: LD_STRING D7-Friend-3
24833: PPUSH
24834: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24838: LD_EXP 39
24842: PPUSH
24843: LD_STRING D7-JMM-3
24845: PPUSH
24846: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24850: LD_EXP 62
24854: PPUSH
24855: LD_STRING D7-Friend-4
24857: PPUSH
24858: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24862: LD_EXP 39
24866: PPUSH
24867: LD_STRING D7-JMM-4
24869: PPUSH
24870: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24874: LD_EXP 62
24878: PPUSH
24879: LD_STRING D7-Friend-5
24881: PPUSH
24882: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24886: LD_EXP 39
24890: PPUSH
24891: LD_STRING D7-JMM-5
24893: PPUSH
24894: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24898: LD_EXP 62
24902: PPUSH
24903: LD_STRING D7-Friend-6
24905: PPUSH
24906: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24910: LD_EXP 39
24914: PPUSH
24915: LD_STRING D7-JMM-6
24917: PPUSH
24918: CALL_OW 88
// DialogueOff ;
24922: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24926: LD_STRING Mlegion
24928: PPUSH
24929: CALL_OW 337
// skirmish := true ;
24933: LD_ADDR_EXP 95
24937: PUSH
24938: LD_INT 1
24940: ST_TO_ADDR
// RebuildKozlovFactory ;
24941: CALL 4844 0 0
// end ;
24945: PPOPN 13
24947: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24948: LD_EXP 20
24952: PUSH
24953: LD_EXP 58
24957: PPUSH
24958: CALL_OW 300
24962: AND
24963: IFFALSE 25005
24965: GO 24967
24967: DISABLE
// begin enable ;
24968: ENABLE
// if IsInUnit ( Powell ) then
24969: LD_EXP 58
24973: PPUSH
24974: CALL_OW 310
24978: IFFALSE 24996
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24980: LD_EXP 58
24984: PPUSH
24985: CALL_OW 310
24989: PPUSH
24990: CALL_OW 85
24994: GO 25005
// CenterOnUnits ( Powell ) ;
24996: LD_EXP 58
25000: PPUSH
25001: CALL_OW 85
// end ;
25005: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
25006: LD_INT 22
25008: PUSH
25009: LD_INT 8
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: PUSH
25016: LD_INT 34
25018: PUSH
25019: LD_INT 48
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PPUSH
25030: CALL_OW 69
25034: IFFALSE 25308
25036: GO 25038
25038: DISABLE
25039: LD_INT 0
25041: PPUSH
25042: PPUSH
// begin if missionStage < 9 then
25043: LD_EXP 15
25047: PUSH
25048: LD_INT 9
25050: LESS
25051: IFFALSE 25061
// missionStage := 9 ;
25053: LD_ADDR_EXP 15
25057: PUSH
25058: LD_INT 9
25060: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
25061: LD_ADDR_VAR 0 1
25065: PUSH
25066: LD_INT 22
25068: PUSH
25069: LD_INT 8
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: LD_INT 34
25078: PUSH
25079: LD_INT 48
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: EMPTY
25087: LIST
25088: LIST
25089: PPUSH
25090: CALL_OW 69
25094: PUSH
25095: LD_INT 1
25097: ARRAY
25098: ST_TO_ADDR
// wait ( 0 0$05 ) ;
25099: LD_INT 175
25101: PPUSH
25102: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
25106: LD_EXP 12
25110: PUSH
25111: LD_EXP 3
25115: PUSH
25116: LD_INT 0
25118: PUSH
25119: LD_INT 2
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: IN
25126: OR
25127: IFFALSE 25150
// target := [ 68 , 108 , 1 ] else
25129: LD_ADDR_VAR 0 2
25133: PUSH
25134: LD_INT 68
25136: PUSH
25137: LD_INT 108
25139: PUSH
25140: LD_INT 1
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: LIST
25147: ST_TO_ADDR
25148: GO 25169
// target := [ 181 , 88 , 2 ] ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_INT 181
25157: PUSH
25158: LD_INT 88
25160: PUSH
25161: LD_INT 2
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: LIST
25168: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
25169: LD_VAR 0 1
25173: PPUSH
25174: LD_VAR 0 2
25178: PUSH
25179: LD_INT 1
25181: ARRAY
25182: PPUSH
25183: LD_VAR 0 2
25187: PUSH
25188: LD_INT 2
25190: ARRAY
25191: PPUSH
25192: CALL_OW 176
// if target [ 3 ] = 1 then
25196: LD_VAR 0 2
25200: PUSH
25201: LD_INT 3
25203: ARRAY
25204: PUSH
25205: LD_INT 1
25207: EQUAL
25208: IFFALSE 25224
// SayRadio ( Kurt , D12-Kurt-1 ) else
25210: LD_EXP 60
25214: PPUSH
25215: LD_STRING D12-Kurt-1
25217: PPUSH
25218: CALL_OW 94
25222: GO 25248
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
25224: LD_EXP 60
25228: PPUSH
25229: LD_STRING D12a-Kurt-1
25231: PPUSH
25232: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
25236: LD_EXP 74
25240: PPUSH
25241: LD_STRING D12a-Roth-1
25243: PPUSH
25244: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
25248: LD_INT 350
25250: PPUSH
25251: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25255: LD_VAR 0 1
25259: PPUSH
25260: LD_INT 22
25262: PUSH
25263: LD_INT 8
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 23
25272: PUSH
25273: LD_INT 2
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 3
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: EMPTY
25291: LIST
25292: LIST
25293: LIST
25294: PPUSH
25295: CALL_OW 69
25299: PUSH
25300: LD_INT 1
25302: ARRAY
25303: PPUSH
25304: CALL_OW 228
// end ;
25308: PPOPN 2
25310: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
25311: LD_EXP 60
25315: PPUSH
25316: CALL_OW 256
25320: PUSH
25321: LD_INT 999
25323: LESS
25324: PUSH
25325: LD_INT 22
25327: PUSH
25328: LD_INT 8
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 21
25337: PUSH
25338: LD_INT 1
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_INT 23
25347: PUSH
25348: LD_INT 2
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: LIST
25359: PPUSH
25360: CALL_OW 69
25364: PUSH
25365: LD_INT 9
25367: PUSH
25368: LD_INT 8
25370: PUSH
25371: LD_INT 7
25373: PUSH
25374: LD_INT 6
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: LESSEQUAL
25389: OR
25390: PUSH
25391: LD_INT 22
25393: PUSH
25394: LD_INT 8
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 34
25403: PUSH
25404: LD_INT 48
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: PPUSH
25415: CALL_OW 69
25419: NOT
25420: AND
25421: PUSH
25422: LD_EXP 60
25426: PPUSH
25427: CALL_OW 302
25431: AND
25432: PUSH
25433: LD_INT 5
25435: PPUSH
25436: LD_INT 22
25438: PUSH
25439: LD_INT 1
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PPUSH
25446: CALL_OW 70
25450: AND
25451: IFFALSE 26164
25453: GO 25455
25455: DISABLE
25456: LD_INT 0
25458: PPUSH
25459: PPUSH
25460: PPUSH
// begin legionDestroyed := true ;
25461: LD_ADDR_EXP 22
25465: PUSH
25466: LD_INT 1
25468: ST_TO_ADDR
// DialogueOn ;
25469: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25473: LD_EXP 39
25477: PPUSH
25478: LD_STRING D13-JMM-1
25480: PPUSH
25481: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25485: LD_EXP 60
25489: PPUSH
25490: LD_STRING D13-Kurt-1
25492: PPUSH
25493: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25497: LD_EXP 39
25501: PPUSH
25502: LD_STRING D13-JMM-2
25504: PPUSH
25505: CALL_OW 88
// if FakeInfo then
25509: LD_EXP 12
25513: IFFALSE 25533
// begin Say ( Kurt , D13-Kurt-2 ) ;
25515: LD_EXP 60
25519: PPUSH
25520: LD_STRING D13-Kurt-2
25522: PPUSH
25523: CALL_OW 88
// DialogueOff ;
25527: CALL_OW 7
// exit ;
25531: GO 26164
// end ; if not KurtStatus then
25533: LD_EXP 3
25537: NOT
25538: IFFALSE 25554
// Say ( Kurt , D13-Kurt-2b ) else
25540: LD_EXP 60
25544: PPUSH
25545: LD_STRING D13-Kurt-2b
25547: PPUSH
25548: CALL_OW 88
25552: GO 25566
// Say ( Kurt , D13-Kurt-2a ) ;
25554: LD_EXP 60
25558: PPUSH
25559: LD_STRING D13-Kurt-2a
25561: PPUSH
25562: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25566: LD_EXP 39
25570: PPUSH
25571: LD_STRING D13-JMM-3
25573: PPUSH
25574: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25578: LD_EXP 60
25582: PPUSH
25583: LD_STRING D13-Kurt-3
25585: PPUSH
25586: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25590: LD_EXP 39
25594: PPUSH
25595: LD_STRING D13-JMM-4
25597: PPUSH
25598: CALL_OW 88
// DialogueOff ;
25602: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25606: LD_STRING MlegionOut
25608: PPUSH
25609: CALL_OW 337
// MC_Kill ( 3 ) ;
25613: LD_INT 3
25615: PPUSH
25616: CALL 35661 0 1
// KillUnit ( Kozlov ) ;
25620: LD_EXP 61
25624: PPUSH
25625: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25629: LD_ADDR_VAR 0 1
25633: PUSH
25634: LD_INT 22
25636: PUSH
25637: LD_INT 8
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 23
25646: PUSH
25647: LD_INT 3
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 3
25656: PUSH
25657: LD_INT 21
25659: PUSH
25660: LD_INT 33
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: LIST
25675: PPUSH
25676: CALL_OW 69
25680: PUSH
25681: FOR_IN
25682: IFFALSE 25695
// KillUnit ( i ) ;
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 66
25693: GO 25681
25695: POP
25696: POP
// ChangeSideFog ( 8 , 1 ) ;
25697: LD_INT 8
25699: PPUSH
25700: LD_INT 1
25702: PPUSH
25703: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25707: LD_ADDR_VAR 0 2
25711: PUSH
25712: LD_INT 22
25714: PUSH
25715: LD_INT 8
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 21
25724: PUSH
25725: LD_INT 1
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PPUSH
25736: CALL_OW 69
25740: PUSH
25741: LD_EXP 61
25745: PUSH
25746: LD_EXP 60
25750: PUSH
25751: EMPTY
25752: LIST
25753: LIST
25754: DIFF
25755: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25756: LD_VAR 0 2
25760: PUSH
25761: LD_INT 6
25763: PUSH
25764: LD_INT 5
25766: PUSH
25767: LD_INT 4
25769: PUSH
25770: LD_INT 3
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: LIST
25777: LIST
25778: PUSH
25779: LD_OWVAR 67
25783: ARRAY
25784: GREATEREQUAL
25785: IFFALSE 25963
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25787: LD_ADDR_VAR 0 3
25791: PUSH
25792: LD_INT 6
25794: PUSH
25795: LD_INT 5
25797: PUSH
25798: LD_INT 4
25800: PUSH
25801: LD_INT 3
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: LIST
25808: LIST
25809: PUSH
25810: LD_OWVAR 67
25814: ARRAY
25815: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25816: LD_ADDR_VAR 0 1
25820: PUSH
25821: DOUBLE
25822: LD_VAR 0 2
25826: PUSH
25827: LD_VAR 0 3
25831: PUSH
25832: LD_INT 1
25834: PLUS
25835: MINUS
25836: INC
25837: ST_TO_ADDR
25838: LD_INT 1
25840: PUSH
25841: FOR_DOWNTO
25842: IFFALSE 25959
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25844: LD_ADDR_EXP 38
25848: PUSH
25849: LD_EXP 38
25853: PUSH
25854: LD_VAR 0 2
25858: PUSH
25859: LD_VAR 0 1
25863: ARRAY
25864: ADD
25865: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25866: LD_VAR 0 2
25870: PUSH
25871: LD_VAR 0 1
25875: ARRAY
25876: PPUSH
25877: CALL_OW 310
25881: IFFALSE 25898
// ComExitBuilding ( tmp [ i ] ) ;
25883: LD_VAR 0 2
25887: PUSH
25888: LD_VAR 0 1
25892: ARRAY
25893: PPUSH
25894: CALL_OW 122
// if IsInUnit ( i ) then
25898: LD_VAR 0 1
25902: PPUSH
25903: CALL_OW 310
25907: IFFALSE 25924
// ComExitVehicle ( tmp [ i ] ) ;
25909: LD_VAR 0 2
25913: PUSH
25914: LD_VAR 0 1
25918: ARRAY
25919: PPUSH
25920: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25924: LD_VAR 0 2
25928: PUSH
25929: LD_VAR 0 1
25933: ARRAY
25934: PPUSH
25935: LD_INT 34
25937: PUSH
25938: LD_INT 0
25940: PPUSH
25941: LD_INT 6
25943: PPUSH
25944: CALL_OW 12
25948: PLUS
25949: PPUSH
25950: LD_INT 1
25952: PPUSH
25953: CALL_OW 171
// end ;
25957: GO 25841
25959: POP
25960: POP
// end else
25961: GO 25973
// x := tmp ;
25963: LD_ADDR_VAR 0 3
25967: PUSH
25968: LD_VAR 0 2
25972: ST_TO_ADDR
// for i := tmp downto tmp - x do
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: DOUBLE
25979: LD_VAR 0 2
25983: INC
25984: ST_TO_ADDR
25985: LD_VAR 0 2
25989: PUSH
25990: LD_VAR 0 3
25994: MINUS
25995: PUSH
25996: FOR_DOWNTO
25997: IFFALSE 26051
// begin if IsInUnit ( tmp [ i ] ) then
25999: LD_VAR 0 2
26003: PUSH
26004: LD_VAR 0 1
26008: ARRAY
26009: PPUSH
26010: CALL_OW 310
26014: IFFALSE 26031
// ComExitVehicle ( tmp [ i ] ) ;
26016: LD_VAR 0 2
26020: PUSH
26021: LD_VAR 0 1
26025: ARRAY
26026: PPUSH
26027: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
26031: LD_VAR 0 2
26035: PUSH
26036: LD_VAR 0 1
26040: ARRAY
26041: PPUSH
26042: LD_INT 1
26044: PPUSH
26045: CALL_OW 235
// end ;
26049: GO 25996
26051: POP
26052: POP
// SetSide ( Kurt , 1 ) ;
26053: LD_EXP 60
26057: PPUSH
26058: LD_INT 1
26060: PPUSH
26061: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
26065: LD_INT 22
26067: PUSH
26068: LD_INT 8
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 21
26077: PUSH
26078: LD_INT 3
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: PPUSH
26089: CALL_OW 69
26093: PPUSH
26094: LD_INT 1
26096: PPUSH
26097: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
26101: LD_INT 8
26103: PPUSH
26104: LD_INT 1
26106: PPUSH
26107: LD_INT 1
26109: PPUSH
26110: LD_INT 1
26112: PPUSH
26113: CALL_OW 80
// wait ( 1 1$20 ) ;
26117: LD_INT 2800
26119: PPUSH
26120: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
26124: LD_EXP 62
26128: PPUSH
26129: LD_INT 37
26131: PPUSH
26132: LD_INT 1
26134: PPUSH
26135: LD_INT 0
26137: PPUSH
26138: CALL_OW 48
// wait ( 0 0$1 ) ;
26142: LD_INT 35
26144: PPUSH
26145: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
26149: LD_EXP 62
26153: PPUSH
26154: LD_INT 60
26156: PPUSH
26157: LD_INT 95
26159: PPUSH
26160: CALL_OW 111
// end ;
26164: PPOPN 3
26166: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
26167: LD_EXP 22
26171: NOT
26172: PUSH
26173: LD_INT 22
26175: PUSH
26176: LD_INT 8
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 21
26185: PUSH
26186: LD_INT 1
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL_OW 69
26201: PUSH
26202: LD_INT 0
26204: EQUAL
26205: AND
26206: IFFALSE 26226
26208: GO 26210
26210: DISABLE
// begin legionDestroyed := true ;
26211: LD_ADDR_EXP 22
26215: PUSH
26216: LD_INT 1
26218: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
26219: LD_STRING MlegionOut
26221: PPUSH
26222: CALL_OW 337
// end ;
26226: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
26227: LD_EXP 38
26231: IFFALSE 26306
26233: GO 26235
26235: DISABLE
26236: LD_INT 0
26238: PPUSH
// begin enable ;
26239: ENABLE
// for i in legionEscapeUnits do
26240: LD_ADDR_VAR 0 1
26244: PUSH
26245: LD_EXP 38
26249: PUSH
26250: FOR_IN
26251: IFFALSE 26304
// begin if IsInArea ( i , legionEscapeArea ) then
26253: LD_VAR 0 1
26257: PPUSH
26258: LD_INT 31
26260: PPUSH
26261: CALL_OW 308
26265: IFFALSE 26278
// RemoveUnit ( i ) else
26267: LD_VAR 0 1
26271: PPUSH
26272: CALL_OW 64
26276: GO 26302
// if not HasTask ( i ) then
26278: LD_VAR 0 1
26282: PPUSH
26283: CALL_OW 314
26287: NOT
26288: IFFALSE 26302
// ComMoveToArea ( i , legionEscapeArea ) ;
26290: LD_VAR 0 1
26294: PPUSH
26295: LD_INT 31
26297: PPUSH
26298: CALL_OW 113
// end ;
26302: GO 26250
26304: POP
26305: POP
// end ;
26306: PPOPN 1
26308: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
26309: LD_INT 1
26311: PPUSH
26312: LD_EXP 62
26316: PPUSH
26317: CALL_OW 292
26321: IFFALSE 26619
26323: GO 26325
26325: DISABLE
26326: LD_INT 0
26328: PPUSH
// begin wait ( 0 0$2 ) ;
26329: LD_INT 70
26331: PPUSH
26332: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26336: LD_EXP 62
26340: PPUSH
26341: CALL_OW 87
// DialogueOn ;
26345: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26349: LD_EXP 39
26353: PPUSH
26354: LD_STRING D14-JMM-1
26356: PPUSH
26357: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26361: LD_EXP 62
26365: PPUSH
26366: LD_STRING D14-Friend-1
26368: PPUSH
26369: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26373: LD_EXP 39
26377: PPUSH
26378: LD_STRING D14-JMM-2
26380: PPUSH
26381: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26385: LD_EXP 62
26389: PPUSH
26390: LD_STRING D14-Friend-2
26392: PPUSH
26393: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26397: LD_EXP 39
26401: PPUSH
26402: LD_STRING D14-JMM-3
26404: PPUSH
26405: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26409: LD_EXP 62
26413: PPUSH
26414: LD_STRING D14-Friend-3
26416: PPUSH
26417: CALL_OW 88
// DialogueOff ;
26421: CALL_OW 7
// dec = Query ( Q14 ) ;
26425: LD_ADDR_VAR 0 1
26429: PUSH
26430: LD_STRING Q14
26432: PPUSH
26433: CALL_OW 97
26437: ST_TO_ADDR
// if dec = 1 then
26438: LD_VAR 0 1
26442: PUSH
26443: LD_INT 1
26445: EQUAL
26446: IFFALSE 26480
// begin DialogueOn ;
26448: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26452: LD_EXP 39
26456: PPUSH
26457: LD_STRING D14a-JMM-1
26459: PPUSH
26460: CALL_OW 88
// DialogueOff ;
26464: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26468: LD_EXP 62
26472: PPUSH
26473: LD_INT 1
26475: PPUSH
26476: CALL_OW 235
// end ; if dec = 2 then
26480: LD_VAR 0 1
26484: PUSH
26485: LD_INT 2
26487: EQUAL
26488: IFFALSE 26541
// begin DialogueOn ;
26490: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26494: LD_EXP 39
26498: PPUSH
26499: LD_STRING D14b-JMM-1
26501: PPUSH
26502: CALL_OW 88
// DialogueOff ;
26506: CALL_OW 7
// wait ( 0 0$1 ) ;
26510: LD_INT 35
26512: PPUSH
26513: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26517: LD_EXP 62
26521: PPUSH
26522: LD_INT 9
26524: PPUSH
26525: LD_INT 2
26527: PPUSH
26528: CALL_OW 111
// AddComHold ( Friend ) ;
26532: LD_EXP 62
26536: PPUSH
26537: CALL_OW 200
// end ; if dec = 3 then
26541: LD_VAR 0 1
26545: PUSH
26546: LD_INT 3
26548: EQUAL
26549: IFFALSE 26619
// begin DialogueOn ;
26551: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26555: LD_EXP 39
26559: PPUSH
26560: LD_STRING D14c-JMM-1
26562: PPUSH
26563: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26567: LD_EXP 62
26571: PPUSH
26572: LD_STRING D14c-Friend-1
26574: PPUSH
26575: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26579: LD_EXP 39
26583: PPUSH
26584: LD_STRING D14c-JMM-2
26586: PPUSH
26587: CALL_OW 88
// DialogueOff ;
26591: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26595: LD_EXP 62
26599: PPUSH
26600: LD_INT 9
26602: PPUSH
26603: LD_INT 2
26605: PPUSH
26606: CALL_OW 111
// AddComHold ( Friend ) ;
26610: LD_EXP 62
26614: PPUSH
26615: CALL_OW 200
// end ; end ;
26619: PPOPN 1
26621: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26622: LD_INT 9
26624: PPUSH
26625: LD_INT 2
26627: PPUSH
26628: CALL_OW 428
26632: PUSH
26633: LD_EXP 62
26637: EQUAL
26638: PUSH
26639: LD_EXP 62
26643: PPUSH
26644: CALL_OW 255
26648: PUSH
26649: LD_INT 8
26651: EQUAL
26652: AND
26653: IFFALSE 26667
26655: GO 26657
26657: DISABLE
// RemoveUnit ( Friend ) ;
26658: LD_EXP 62
26662: PPUSH
26663: CALL_OW 64
26667: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26668: LD_EXP 14
26672: PUSH
26673: LD_INT 31500
26675: GREATEREQUAL
26676: PUSH
26677: LD_EXP 7
26681: AND
26682: PUSH
26683: LD_EXP 2
26687: AND
26688: IFFALSE 27118
26690: GO 26692
26692: DISABLE
26693: LD_INT 0
26695: PPUSH
26696: PPUSH
26697: PPUSH
// begin missionStage := 7 ;
26698: LD_ADDR_EXP 15
26702: PUSH
26703: LD_INT 7
26705: ST_TO_ADDR
// uc_side = 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation = 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i = 1 to 5 do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: DOUBLE
26728: LD_INT 1
26730: DEC
26731: ST_TO_ADDR
26732: LD_INT 5
26734: PUSH
26735: FOR_TO
26736: IFFALSE 26832
// begin vc_engine = 3 ;
26738: LD_ADDR_OWVAR 39
26742: PUSH
26743: LD_INT 3
26745: ST_TO_ADDR
// vc_control = 3 ;
26746: LD_ADDR_OWVAR 38
26750: PUSH
26751: LD_INT 3
26753: ST_TO_ADDR
// vc_chassis = 3 ;
26754: LD_ADDR_OWVAR 37
26758: PUSH
26759: LD_INT 3
26761: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26762: LD_ADDR_OWVAR 40
26766: PUSH
26767: LD_INT 5
26769: PUSH
26770: LD_INT 9
26772: PUSH
26773: LD_INT 7
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: PUSH
26781: LD_INT 1
26783: PPUSH
26784: LD_INT 3
26786: PPUSH
26787: CALL_OW 12
26791: ARRAY
26792: ST_TO_ADDR
// veh = CreateVehicle ;
26793: LD_ADDR_VAR 0 2
26797: PUSH
26798: CALL_OW 45
26802: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26803: LD_VAR 0 2
26807: PPUSH
26808: LD_INT 1
26810: PPUSH
26811: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26815: LD_VAR 0 2
26819: PPUSH
26820: LD_INT 19
26822: PPUSH
26823: LD_INT 0
26825: PPUSH
26826: CALL_OW 49
// end ;
26830: GO 26735
26832: POP
26833: POP
// vc_engine = 3 ;
26834: LD_ADDR_OWVAR 39
26838: PUSH
26839: LD_INT 3
26841: ST_TO_ADDR
// vc_control = 1 ;
26842: LD_ADDR_OWVAR 38
26846: PUSH
26847: LD_INT 1
26849: ST_TO_ADDR
// vc_chassis = 3 ;
26850: LD_ADDR_OWVAR 37
26854: PUSH
26855: LD_INT 3
26857: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26858: LD_ADDR_OWVAR 40
26862: PUSH
26863: LD_INT 5
26865: PUSH
26866: LD_INT 9
26868: PUSH
26869: LD_INT 7
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: PPUSH
26880: LD_INT 3
26882: PPUSH
26883: CALL_OW 12
26887: ARRAY
26888: ST_TO_ADDR
// vehG = CreateVehicle ;
26889: LD_ADDR_VAR 0 3
26893: PUSH
26894: CALL_OW 45
26898: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26899: LD_VAR 0 3
26903: PPUSH
26904: LD_INT 1
26906: PPUSH
26907: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26911: LD_VAR 0 3
26915: PPUSH
26916: LD_INT 19
26918: PPUSH
26919: LD_INT 0
26921: PPUSH
26922: CALL_OW 49
// if JMMGirl = 1 then
26926: LD_EXP 7
26930: PUSH
26931: LD_INT 1
26933: EQUAL
26934: IFFALSE 26990
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26936: LD_ADDR_EXP 40
26940: PUSH
26941: LD_STRING Joan
26943: PPUSH
26944: LD_INT 1
26946: PPUSH
26947: LD_STRING 14_
26949: PPUSH
26950: CALL 66023 0 3
26954: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26955: LD_EXP 40
26959: PPUSH
26960: LD_VAR 0 3
26964: PPUSH
26965: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26969: LD_VAR 0 3
26973: PPUSH
26974: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26978: LD_EXP 40
26982: PPUSH
26983: LD_STRING D10BW-Joan-1
26985: PPUSH
26986: CALL_OW 94
// end ; if JMMGirl = 2 then
26990: LD_EXP 7
26994: PUSH
26995: LD_INT 2
26997: EQUAL
26998: IFFALSE 27054
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
27000: LD_ADDR_EXP 42
27004: PUSH
27005: LD_STRING Lisa
27007: PPUSH
27008: LD_INT 1
27010: PPUSH
27011: LD_STRING 14_
27013: PPUSH
27014: CALL 66023 0 3
27018: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
27019: LD_EXP 42
27023: PPUSH
27024: LD_VAR 0 3
27028: PPUSH
27029: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
27033: LD_VAR 0 3
27037: PPUSH
27038: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
27042: LD_EXP 42
27046: PPUSH
27047: LD_STRING D10BW-Lisa-1
27049: PPUSH
27050: CALL_OW 94
// end ; if JMMGirl = 3 then
27054: LD_EXP 7
27058: PUSH
27059: LD_INT 3
27061: EQUAL
27062: IFFALSE 27118
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
27064: LD_ADDR_EXP 54
27068: PUSH
27069: LD_STRING Connie
27071: PPUSH
27072: LD_INT 1
27074: PPUSH
27075: LD_STRING 14_
27077: PPUSH
27078: CALL 66023 0 3
27082: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
27083: LD_EXP 54
27087: PPUSH
27088: LD_VAR 0 3
27092: PPUSH
27093: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
27097: LD_VAR 0 3
27101: PPUSH
27102: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
27106: LD_EXP 54
27110: PPUSH
27111: LD_STRING D10BW-Con-1
27113: PPUSH
27114: CALL_OW 94
// end ; end ;
27118: PPOPN 3
27120: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
27121: LD_EXP 14
27125: PUSH
27126: LD_INT 94500
27128: GREATEREQUAL
27129: IFFALSE 27541
27131: GO 27133
27133: DISABLE
27134: LD_INT 0
27136: PPUSH
27137: PPUSH
27138: PPUSH
// begin tmp := PrepareStevensSquad ;
27139: LD_ADDR_VAR 0 3
27143: PUSH
27144: CALL 2178 0 0
27148: ST_TO_ADDR
// if not tmp then
27149: LD_VAR 0 3
27153: NOT
27154: IFFALSE 27158
// exit ;
27156: GO 27541
// uc_side := 1 ;
27158: LD_ADDR_OWVAR 20
27162: PUSH
27163: LD_INT 1
27165: ST_TO_ADDR
// uc_nation := 1 ;
27166: LD_ADDR_OWVAR 21
27170: PUSH
27171: LD_INT 1
27173: ST_TO_ADDR
// for i in tmp do
27174: LD_ADDR_VAR 0 1
27178: PUSH
27179: LD_VAR 0 3
27183: PUSH
27184: FOR_IN
27185: IFFALSE 27282
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
27187: LD_INT 3
27189: PPUSH
27190: LD_INT 3
27192: PPUSH
27193: LD_INT 1
27195: PPUSH
27196: LD_INT 5
27198: PUSH
27199: LD_INT 9
27201: PUSH
27202: LD_INT 7
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: PPUSH
27213: LD_INT 3
27215: PPUSH
27216: CALL_OW 12
27220: ARRAY
27221: PPUSH
27222: LD_INT 40
27224: PPUSH
27225: CALL 71038 0 5
// veh := CreateVehicle ;
27229: LD_ADDR_VAR 0 2
27233: PUSH
27234: CALL_OW 45
27238: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27239: LD_VAR 0 2
27243: PPUSH
27244: LD_INT 1
27246: PPUSH
27247: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27251: LD_VAR 0 2
27255: PPUSH
27256: LD_INT 19
27258: PPUSH
27259: LD_INT 0
27261: PPUSH
27262: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
27266: LD_VAR 0 1
27270: PPUSH
27271: LD_VAR 0 2
27275: PPUSH
27276: CALL_OW 52
// end ;
27280: GO 27184
27282: POP
27283: POP
// missionStage := 8 ;
27284: LD_ADDR_EXP 15
27288: PUSH
27289: LD_INT 8
27291: ST_TO_ADDR
// DialogueOn ;
27292: CALL_OW 6
// if Stevens then
27296: LD_EXP 41
27300: IFFALSE 27414
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
27302: LD_EXP 41
27306: PPUSH
27307: CALL_OW 310
27311: PPUSH
27312: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
27316: LD_EXP 41
27320: PPUSH
27321: LD_STRING D8-Huck-1
27323: PPUSH
27324: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27328: LD_EXP 39
27332: PPUSH
27333: LD_STRING D8-JMM-1
27335: PPUSH
27336: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27340: LD_EXP 41
27344: PPUSH
27345: LD_STRING D8-Huck-2
27347: PPUSH
27348: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27352: LD_EXP 39
27356: PPUSH
27357: LD_STRING D8-JMM-2
27359: PPUSH
27360: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27364: LD_EXP 41
27368: PPUSH
27369: LD_STRING D8-Huck-3
27371: PPUSH
27372: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27376: LD_EXP 39
27380: PPUSH
27381: LD_STRING D8-JMM-3
27383: PPUSH
27384: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27388: LD_EXP 41
27392: PPUSH
27393: LD_STRING D8-Huck-4
27395: PPUSH
27396: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27400: LD_EXP 39
27404: PPUSH
27405: LD_STRING D8-JMM-4
27407: PPUSH
27408: CALL_OW 88
// end else
27412: GO 27524
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27414: LD_EXP 55
27418: PPUSH
27419: CALL_OW 310
27423: PPUSH
27424: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27428: LD_EXP 55
27432: PPUSH
27433: LD_STRING D8-Huck-1
27435: PPUSH
27436: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27440: LD_EXP 39
27444: PPUSH
27445: LD_STRING D8-JMM-1a
27447: PPUSH
27448: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27452: LD_EXP 55
27456: PPUSH
27457: LD_STRING D8-Huck-2
27459: PPUSH
27460: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27464: LD_EXP 39
27468: PPUSH
27469: LD_STRING D8-JMM-2
27471: PPUSH
27472: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27476: LD_EXP 55
27480: PPUSH
27481: LD_STRING D8-Huck-3
27483: PPUSH
27484: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27488: LD_EXP 39
27492: PPUSH
27493: LD_STRING D8-JMM-3
27495: PPUSH
27496: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27500: LD_EXP 55
27504: PPUSH
27505: LD_STRING D8-Huck-4
27507: PPUSH
27508: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27512: LD_EXP 39
27516: PPUSH
27517: LD_STRING D8-JMM-4
27519: PPUSH
27520: CALL_OW 88
// end ; DialogueOff ;
27524: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27528: LD_INT 25
27530: PPUSH
27531: LD_INT 1
27533: PPUSH
27534: LD_INT 1
27536: PPUSH
27537: CALL_OW 322
// end ;
27541: PPOPN 3
27543: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27544: LD_INT 1
27546: PPUSH
27547: LD_EXP 71
27551: PPUSH
27552: CALL_OW 292
27556: IFFALSE 27807
27558: GO 27560
27560: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27561: LD_EXP 71
27565: PPUSH
27566: CALL_OW 87
// DialogueOn ;
27570: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27574: LD_EXP 39
27578: PPUSH
27579: LD_STRING D10nB-JMM-1
27581: PPUSH
27582: CALL_OW 88
// if BurlakStatus = 1 then
27586: LD_EXP 9
27590: PUSH
27591: LD_INT 1
27593: EQUAL
27594: IFFALSE 27608
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27596: LD_EXP 70
27600: PPUSH
27601: LD_STRING D10nB-Vse-1a
27603: PPUSH
27604: CALL_OW 94
// end ; if BurlakStatus = 0 then
27608: LD_EXP 9
27612: PUSH
27613: LD_INT 0
27615: EQUAL
27616: IFFALSE 27630
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27618: LD_EXP 70
27622: PPUSH
27623: LD_STRING D10nB-Vse-1
27625: PPUSH
27626: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27630: LD_EXP 39
27634: PPUSH
27635: LD_STRING D10nB-JMM-2
27637: PPUSH
27638: CALL_OW 88
// if KappaStatus then
27642: LD_EXP 2
27646: IFFALSE 27660
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27648: LD_EXP 70
27652: PPUSH
27653: LD_STRING D10nB-Vse-5a
27655: PPUSH
27656: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27660: LD_EXP 2
27664: NOT
27665: PUSH
27666: LD_EXP 6
27670: PUSH
27671: LD_INT 0
27673: EQUAL
27674: AND
27675: IFFALSE 27803
// begin if JMMGirl = 1 then
27677: LD_EXP 7
27681: PUSH
27682: LD_INT 1
27684: EQUAL
27685: IFFALSE 27735
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27687: LD_EXP 70
27691: PPUSH
27692: LD_STRING D10nB-Vse-2
27694: PPUSH
27695: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27699: LD_EXP 39
27703: PPUSH
27704: LD_STRING D10nB-JMM-3
27706: PPUSH
27707: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27711: LD_EXP 70
27715: PPUSH
27716: LD_STRING D10nB-Vse-3
27718: PPUSH
27719: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27723: LD_EXP 39
27727: PPUSH
27728: LD_STRING D10nB-JMM-4
27730: PPUSH
27731: CALL_OW 88
// end ; if JMMGirl = 2 then
27735: LD_EXP 7
27739: PUSH
27740: LD_INT 2
27742: EQUAL
27743: IFFALSE 27769
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27745: LD_EXP 70
27749: PPUSH
27750: LD_STRING D10nB-Vse-4
27752: PPUSH
27753: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27757: LD_EXP 39
27761: PPUSH
27762: LD_STRING D10nB-JMM-5
27764: PPUSH
27765: CALL_OW 88
// end ; if JMMGirl = 3 then
27769: LD_EXP 7
27773: PUSH
27774: LD_INT 3
27776: EQUAL
27777: IFFALSE 27803
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27779: LD_EXP 70
27783: PPUSH
27784: LD_STRING D10nB-Vse-5
27786: PPUSH
27787: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27791: LD_EXP 39
27795: PPUSH
27796: LD_STRING D10nB-JMM-6
27798: PPUSH
27799: CALL_OW 88
// end ; end ; DialogueOff ;
27803: CALL_OW 7
// end ;
27807: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27808: LD_EXP 14
27812: PUSH
27813: LD_INT 115500
27815: GREATEREQUAL
27816: IFFALSE 28192
27818: GO 27820
27820: DISABLE
27821: LD_INT 0
27823: PPUSH
// begin missionStage := 10 ;
27824: LD_ADDR_EXP 15
27828: PUSH
27829: LD_INT 10
27831: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27832: LD_ADDR_VAR 0 1
27836: PUSH
27837: LD_INT 22
27839: PUSH
27840: LD_INT 1
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: LD_INT 23
27849: PUSH
27850: LD_INT 1
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PUSH
27857: LD_INT 26
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 3
27869: PUSH
27870: LD_INT 25
27872: PUSH
27873: LD_INT 12
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 3
27886: PUSH
27887: LD_INT 25
27889: PUSH
27890: LD_INT 16
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: PPUSH
27908: CALL_OW 69
27912: PUSH
27913: LD_EXP 39
27917: PUSH
27918: LD_EXP 60
27922: PUSH
27923: LD_EXP 41
27927: PUSH
27928: LD_EXP 55
27932: PUSH
27933: LD_EXP 42
27937: PUSH
27938: LD_EXP 43
27942: PUSH
27943: LD_EXP 44
27947: PUSH
27948: LD_EXP 45
27952: PUSH
27953: LD_EXP 46
27957: PUSH
27958: LD_EXP 47
27962: PUSH
27963: LD_EXP 48
27967: PUSH
27968: LD_EXP 49
27972: PUSH
27973: LD_EXP 50
27977: PUSH
27978: LD_EXP 51
27982: PUSH
27983: LD_EXP 52
27987: PUSH
27988: LD_EXP 53
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: DIFF
28011: ST_TO_ADDR
// if not tmp and Brown then
28012: LD_VAR 0 1
28016: NOT
28017: PUSH
28018: LD_EXP 47
28022: AND
28023: IFFALSE 28038
// tmp := [ Brown ] ;
28025: LD_ADDR_VAR 0 1
28029: PUSH
28030: LD_EXP 47
28034: PUSH
28035: EMPTY
28036: LIST
28037: ST_TO_ADDR
// DialogueOn ;
28038: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
28042: LD_VAR 0 1
28046: PUSH
28047: LD_INT 1
28049: ARRAY
28050: PPUSH
28051: LD_STRING D11-Sol1-1
28053: PPUSH
28054: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
28058: LD_EXP 64
28062: PPUSH
28063: LD_STRING D11-Pla-1
28065: PPUSH
28066: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
28070: LD_EXP 65
28074: PPUSH
28075: LD_STRING D11-Kov-1
28077: PPUSH
28078: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
28082: LD_EXP 64
28086: PPUSH
28087: LD_STRING D11-Pla-2
28089: PPUSH
28090: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
28094: LD_VAR 0 1
28098: PUSH
28099: LD_INT 1
28101: ARRAY
28102: PPUSH
28103: LD_STRING D11-Sol1-2
28105: PPUSH
28106: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
28110: LD_EXP 39
28114: PPUSH
28115: LD_STRING D11-JMM-2
28117: PPUSH
28118: CALL_OW 88
// DialogueOff ;
28122: CALL_OW 7
// allowBehemothConstruct := true ;
28126: LD_ADDR_EXP 25
28130: PUSH
28131: LD_INT 1
28133: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
28134: LD_STRING M4
28136: PPUSH
28137: CALL_OW 337
// BuildBehemoths ;
28141: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
28145: LD_INT 31500
28147: PPUSH
28148: CALL_OW 67
// if behemothDestroyedBeforeFinish then
28152: LD_EXP 27
28156: IFFALSE 28160
// break ;
28158: GO 28192
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
28160: LD_INT 267
28162: PPUSH
28163: CALL_OW 274
28167: PPUSH
28168: LD_INT 1
28170: PPUSH
28171: CALL_OW 275
28175: PUSH
28176: LD_INT 1000
28178: GREATEREQUAL
28179: IFFALSE 28185
// BuildBehemoths ;
28181: CALL 7693 0 0
// until not behemothBuilders ;
28185: LD_EXP 73
28189: NOT
28190: IFFALSE 28145
// end ;
28192: PPOPN 1
28194: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
28195: LD_EXP 73
28199: NOT
28200: PUSH
28201: LD_EXP 28
28205: NOT
28206: AND
28207: PUSH
28208: LD_EXP 25
28212: AND
28213: IFFALSE 28233
28215: GO 28217
28217: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
28218: LD_STRING M4a
28220: PPUSH
28221: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
28225: LD_ADDR_EXP 27
28229: PUSH
28230: LD_INT 1
28232: ST_TO_ADDR
// end ;
28233: END
// every 0 0$1 trigger behemothDone do
28234: LD_EXP 28
28238: IFFALSE 28250
28240: GO 28242
28242: DISABLE
// ChangeMissionObjectives ( M4b ) ;
28243: LD_STRING M4b
28245: PPUSH
28246: CALL_OW 337
28250: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
28251: LD_EXP 29
28255: NOT
28256: IFFALSE 28452
28258: GO 28260
28260: DISABLE
28261: LD_INT 0
28263: PPUSH
28264: PPUSH
// begin enable ;
28265: ENABLE
// tmp := GetBehemoths ( 3 ) ;
28266: LD_ADDR_VAR 0 1
28270: PUSH
28271: LD_INT 3
28273: PPUSH
28274: CALL 103533 0 1
28278: ST_TO_ADDR
// if not tmp and not behemothDone then
28279: LD_VAR 0 1
28283: NOT
28284: PUSH
28285: LD_EXP 28
28289: NOT
28290: AND
28291: IFFALSE 28327
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
28293: LD_ADDR_VAR 0 1
28297: PUSH
28298: LD_INT 22
28300: PUSH
28301: LD_INT 3
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: PUSH
28308: LD_INT 30
28310: PUSH
28311: LD_INT 37
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PPUSH
28322: CALL_OW 69
28326: ST_TO_ADDR
// if not tmp then
28327: LD_VAR 0 1
28331: NOT
28332: IFFALSE 28336
// exit ;
28334: GO 28452
// for i in tmp do
28336: LD_ADDR_VAR 0 2
28340: PUSH
28341: LD_VAR 0 1
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28450
// if See ( 1 , i ) then
28349: LD_INT 1
28351: PPUSH
28352: LD_VAR 0 2
28356: PPUSH
28357: CALL_OW 292
28361: IFFALSE 28448
// begin if GetType ( i ) = unit_building then
28363: LD_VAR 0 2
28367: PPUSH
28368: CALL_OW 247
28372: PUSH
28373: LD_INT 3
28375: EQUAL
28376: IFFALSE 28414
// begin CenterNowOnUnits ( i ) ;
28378: LD_VAR 0 2
28382: PPUSH
28383: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28387: LD_EXP 39
28391: PPUSH
28392: LD_STRING D17a-JMM-1
28394: PPUSH
28395: CALL_OW 88
// seeBehemoth := true ;
28399: LD_ADDR_EXP 29
28403: PUSH
28404: LD_INT 1
28406: ST_TO_ADDR
// disable ;
28407: DISABLE
// exit ;
28408: POP
28409: POP
28410: GO 28452
// end else
28412: GO 28448
// begin CenterNowOnUnits ( i ) ;
28414: LD_VAR 0 2
28418: PPUSH
28419: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28423: LD_EXP 39
28427: PPUSH
28428: LD_STRING D17b-JMM-1
28430: PPUSH
28431: CALL_OW 88
// seeBehemoth := true ;
28435: LD_ADDR_EXP 29
28439: PUSH
28440: LD_INT 1
28442: ST_TO_ADDR
// disable ;
28443: DISABLE
// exit ;
28444: POP
28445: POP
28446: GO 28452
// end ; end ;
28448: GO 28346
28450: POP
28451: POP
// end ;
28452: PPOPN 2
28454: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28455: LD_EXP 14
28459: PUSH
28460: LD_INT 123200
28462: GREATEREQUAL
28463: IFFALSE 29639
28465: GO 28467
28467: DISABLE
28468: LD_INT 0
28470: PPUSH
28471: PPUSH
28472: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28473: LD_INT 2
28475: PPUSH
28476: LD_INT 23
28478: PUSH
28479: LD_INT 3
28481: PUSH
28482: LD_INT 3
28484: PUSH
28485: LD_INT 48
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: PUSH
28494: EMPTY
28495: LIST
28496: PPUSH
28497: CALL 59635 0 2
// repeat wait ( 0 0$1 ) ;
28501: LD_INT 35
28503: PPUSH
28504: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28508: LD_INT 22
28510: PUSH
28511: LD_INT 3
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 34
28520: PUSH
28521: LD_INT 48
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PPUSH
28532: CALL_OW 69
28536: IFFALSE 28501
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28538: LD_ADDR_VAR 0 1
28542: PUSH
28543: LD_INT 22
28545: PUSH
28546: LD_INT 3
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 34
28555: PUSH
28556: LD_INT 48
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PPUSH
28567: CALL_OW 69
28571: PUSH
28572: LD_INT 1
28574: ARRAY
28575: ST_TO_ADDR
// missionStage := 12 ;
28576: LD_ADDR_EXP 15
28580: PUSH
28581: LD_INT 12
28583: ST_TO_ADDR
// platonovHasBomb := true ;
28584: LD_ADDR_EXP 30
28588: PUSH
28589: LD_INT 1
28591: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28592: LD_VAR 0 1
28596: PPUSH
28597: LD_INT 181
28599: PPUSH
28600: LD_INT 86
28602: PPUSH
28603: CALL_OW 171
// AddComHold ( bomb ) ;
28607: LD_VAR 0 1
28611: PPUSH
28612: CALL_OW 200
// wait ( 0 0$10 ) ;
28616: LD_INT 350
28618: PPUSH
28619: CALL_OW 67
// DialogueOn ;
28623: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28627: LD_EXP 64
28631: PPUSH
28632: LD_STRING D15-Pla-1
28634: PPUSH
28635: CALL_OW 94
// dec = Query ( Q15a ) ;
28639: LD_ADDR_VAR 0 2
28643: PUSH
28644: LD_STRING Q15a
28646: PPUSH
28647: CALL_OW 97
28651: ST_TO_ADDR
// if dec = 1 then
28652: LD_VAR 0 2
28656: PUSH
28657: LD_INT 1
28659: EQUAL
28660: IFFALSE 28683
// begin Say ( JMM , D15a-JMM-1 ) ;
28662: LD_EXP 39
28666: PPUSH
28667: LD_STRING D15a-JMM-1
28669: PPUSH
28670: CALL_OW 88
// YouLost ( Surrender ) ;
28674: LD_STRING Surrender
28676: PPUSH
28677: CALL_OW 104
// exit ;
28681: GO 29639
// end ; if dec = 2 then
28683: LD_VAR 0 2
28687: PUSH
28688: LD_INT 2
28690: EQUAL
28691: IFFALSE 28760
// begin Say ( JMM , D15b-JMM-1 ) ;
28693: LD_EXP 39
28697: PPUSH
28698: LD_STRING D15b-JMM-1
28700: PPUSH
28701: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28705: LD_EXP 64
28709: PPUSH
28710: LD_STRING D15b-Pla-1
28712: PPUSH
28713: CALL_OW 94
// DialogueOff ;
28717: CALL_OW 7
// wait ( 3 3$00 ) ;
28721: LD_INT 6300
28723: PPUSH
28724: CALL_OW 67
// DialogueOn ;
28728: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28732: LD_EXP 39
28736: PPUSH
28737: LD_STRING D15d-JMM-1a
28739: PPUSH
28740: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28744: LD_EXP 64
28748: PPUSH
28749: LD_STRING D15d-Pla-1
28751: PPUSH
28752: CALL_OW 94
// DialogueOff ;
28756: CALL_OW 7
// end ; if dec = 3 then
28760: LD_VAR 0 2
28764: PUSH
28765: LD_INT 3
28767: EQUAL
28768: IFFALSE 28822
// begin Say ( JMM , D15c-JMM-1 ) ;
28770: LD_EXP 39
28774: PPUSH
28775: LD_STRING D15c-JMM-1
28777: PPUSH
28778: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28782: LD_EXP 64
28786: PPUSH
28787: LD_STRING D15c-Pla-1
28789: PPUSH
28790: CALL_OW 94
// DialogueOff ;
28794: CALL_OW 7
// wait ( 0 0$15 ) ;
28798: LD_INT 525
28800: PPUSH
28801: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28805: LD_VAR 0 1
28809: PPUSH
28810: LD_INT 60
28812: PPUSH
28813: LD_INT 95
28815: PPUSH
28816: CALL_OW 116
// exit ;
28820: GO 29639
// end ; if dec = 4 then
28822: LD_VAR 0 2
28826: PUSH
28827: LD_INT 4
28829: EQUAL
28830: IFFALSE 28860
// begin Say ( JMM , D15d-JMM-1 ) ;
28832: LD_EXP 39
28836: PPUSH
28837: LD_STRING D15d-JMM-1
28839: PPUSH
28840: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28844: LD_EXP 64
28848: PPUSH
28849: LD_STRING D15d-Pla-1
28851: PPUSH
28852: CALL_OW 94
// DialogueOff ;
28856: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28860: LD_EXP 62
28864: PPUSH
28865: CALL_OW 302
28869: PUSH
28870: LD_EXP 62
28874: PPUSH
28875: CALL_OW 255
28879: PUSH
28880: LD_INT 1
28882: EQUAL
28883: AND
28884: PUSH
28885: LD_INT 22
28887: PUSH
28888: LD_INT 1
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 34
28897: PUSH
28898: LD_INT 8
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PPUSH
28909: CALL_OW 69
28913: NOT
28914: AND
28915: IFFALSE 29540
// begin SetSide ( Friend , 8 ) ;
28917: LD_EXP 62
28921: PPUSH
28922: LD_INT 8
28924: PPUSH
28925: CALL_OW 235
// if IsInUnit ( Friend ) then
28929: LD_EXP 62
28933: PPUSH
28934: CALL_OW 310
28938: IFFALSE 28949
// ComExitBuilding ( Friend ) ;
28940: LD_EXP 62
28944: PPUSH
28945: CALL_OW 122
// if IsDriver ( Friend ) then
28949: LD_EXP 62
28953: PPUSH
28954: CALL 101081 0 1
28958: IFFALSE 28969
// ComExitVehicle ( Friend ) ;
28960: LD_EXP 62
28964: PPUSH
28965: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28969: LD_EXP 62
28973: PPUSH
28974: LD_INT 9
28976: PPUSH
28977: LD_INT 2
28979: PPUSH
28980: CALL_OW 171
// wait ( 0 0$05 ) ;
28984: LD_INT 175
28986: PPUSH
28987: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28991: LD_EXP 62
28995: PPUSH
28996: CALL_OW 87
// DialogueOn ;
29000: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
29004: LD_EXP 39
29008: PPUSH
29009: LD_STRING D16-JMM-1
29011: PPUSH
29012: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
29016: LD_EXP 62
29020: PPUSH
29021: LD_STRING D16-Friend-1
29023: PPUSH
29024: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
29028: LD_EXP 39
29032: PPUSH
29033: LD_STRING D16-JMM-2
29035: PPUSH
29036: CALL_OW 88
// DialogueOff ;
29040: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29044: LD_EXP 62
29048: PPUSH
29049: LD_INT 1
29051: PPUSH
29052: CALL_OW 235
// ComHold ( Friend ) ;
29056: LD_EXP 62
29060: PPUSH
29061: CALL_OW 140
// wait ( 0 0$20 ) ;
29065: LD_INT 700
29067: PPUSH
29068: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
29072: LD_EXP 62
29076: PPUSH
29077: LD_INT 9
29079: PPUSH
29080: LD_INT 2
29082: PPUSH
29083: CALL_OW 297
29087: PUSH
29088: LD_INT 30
29090: LESS
29091: IFFALSE 29160
// begin SetSide ( Friend , 8 ) ;
29093: LD_EXP 62
29097: PPUSH
29098: LD_INT 8
29100: PPUSH
29101: CALL_OW 235
// if IsInUnit ( Friend ) then
29105: LD_EXP 62
29109: PPUSH
29110: CALL_OW 310
29114: IFFALSE 29125
// ComExitBuilding ( Friend ) ;
29116: LD_EXP 62
29120: PPUSH
29121: CALL_OW 122
// if IsDriver ( Friend ) then
29125: LD_EXP 62
29129: PPUSH
29130: CALL 101081 0 1
29134: IFFALSE 29145
// ComExitVehicle ( Friend ) ;
29136: LD_EXP 62
29140: PPUSH
29141: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
29145: LD_EXP 62
29149: PPUSH
29150: LD_INT 9
29152: PPUSH
29153: LD_INT 2
29155: PPUSH
29156: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
29160: LD_INT 1050
29162: PPUSH
29163: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29167: LD_INT 22
29169: PUSH
29170: LD_INT 1
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 34
29179: PUSH
29180: LD_INT 8
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: PPUSH
29191: CALL_OW 69
29195: NOT
29196: IFFALSE 29518
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29198: LD_ADDR_VAR 0 3
29202: PUSH
29203: LD_INT 22
29205: PUSH
29206: LD_INT 1
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 26
29215: PUSH
29216: LD_INT 1
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 3
29225: PUSH
29226: LD_INT 25
29228: PUSH
29229: LD_INT 12
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 25
29238: PUSH
29239: LD_INT 16
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: LIST
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: LIST
29255: PPUSH
29256: CALL_OW 69
29260: PUSH
29261: LD_EXP 39
29265: PUSH
29266: LD_EXP 41
29270: PUSH
29271: LD_EXP 55
29275: PUSH
29276: LD_EXP 42
29280: PUSH
29281: LD_EXP 43
29285: PUSH
29286: LD_EXP 44
29290: PUSH
29291: LD_EXP 45
29295: PUSH
29296: LD_EXP 46
29300: PUSH
29301: LD_EXP 47
29305: PUSH
29306: LD_EXP 48
29310: PUSH
29311: LD_EXP 49
29315: PUSH
29316: LD_EXP 50
29320: PUSH
29321: LD_EXP 51
29325: PUSH
29326: LD_EXP 52
29330: PUSH
29331: LD_EXP 53
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: LIST
29346: LIST
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: DIFF
29353: ST_TO_ADDR
// DialogueOn ;
29354: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29358: LD_EXP 64
29362: PPUSH
29363: LD_STRING D16a-Pla-1
29365: PPUSH
29366: CALL_OW 94
// if Stevens then
29370: LD_EXP 41
29374: IFFALSE 29390
// Say ( Stevens , D16a-Huck-1 ) else
29376: LD_EXP 41
29380: PPUSH
29381: LD_STRING D16a-Huck-1
29383: PPUSH
29384: CALL_OW 88
29388: GO 29432
// if Baker then
29390: LD_EXP 55
29394: IFFALSE 29410
// Say ( Baker , D16a-Huck-1 ) else
29396: LD_EXP 55
29400: PPUSH
29401: LD_STRING D16a-Huck-1
29403: PPUSH
29404: CALL_OW 88
29408: GO 29432
// if tmp then
29410: LD_VAR 0 3
29414: IFFALSE 29432
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29416: LD_VAR 0 3
29420: PUSH
29421: LD_INT 1
29423: ARRAY
29424: PPUSH
29425: LD_STRING D16a-Sol1-1
29427: PPUSH
29428: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29432: LD_EXP 62
29436: PPUSH
29437: CALL_OW 255
29441: PUSH
29442: LD_INT 8
29444: EQUAL
29445: IFFALSE 29461
// Say ( JMM , D16a-JMM-1 ) else
29447: LD_EXP 39
29451: PPUSH
29452: LD_STRING D16a-JMM-1
29454: PPUSH
29455: CALL_OW 88
29459: GO 29497
// begin Say ( JMM , D16a-JMM-1a ) ;
29461: LD_EXP 39
29465: PPUSH
29466: LD_STRING D16a-JMM-1a
29468: PPUSH
29469: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29473: LD_EXP 62
29477: PPUSH
29478: LD_STRING D16a-Friend-1
29480: PPUSH
29481: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29485: LD_EXP 62
29489: PPUSH
29490: LD_INT 3
29492: PPUSH
29493: CALL_OW 235
// end ; DialogueOff ;
29497: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29501: LD_VAR 0 1
29505: PPUSH
29506: LD_INT 60
29508: PPUSH
29509: LD_INT 95
29511: PPUSH
29512: CALL_OW 116
// end else
29516: GO 29538
// begin DialogueOn ;
29518: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29522: LD_EXP 64
29526: PPUSH
29527: LD_STRING D16c-Pla-
29529: PPUSH
29530: CALL_OW 94
// DialogueOff ;
29534: CALL_OW 7
// end ; end else
29538: GO 29639
// begin wait ( 3 3$00 ) ;
29540: LD_INT 6300
29542: PPUSH
29543: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29547: LD_INT 22
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 34
29559: PUSH
29560: LD_INT 8
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PPUSH
29571: CALL_OW 69
29575: NOT
29576: IFFALSE 29619
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29578: LD_EXP 64
29582: PPUSH
29583: LD_STRING D16b-Pla-1
29585: PPUSH
29586: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29590: LD_EXP 39
29594: PPUSH
29595: LD_STRING D16b-JMM-
29597: PPUSH
29598: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29602: LD_VAR 0 1
29606: PPUSH
29607: LD_INT 60
29609: PPUSH
29610: LD_INT 95
29612: PPUSH
29613: CALL_OW 116
// end else
29617: GO 29639
// begin DialogueOn ;
29619: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29623: LD_EXP 64
29627: PPUSH
29628: LD_STRING D16c-Pla-
29630: PPUSH
29631: CALL_OW 94
// DialogueOff ;
29635: CALL_OW 7
// end ; end ; end ;
29639: PPOPN 3
29641: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29642: LD_EXP 14
29646: PUSH
29647: LD_INT 126000
29649: GREATEREQUAL
29650: PUSH
29651: LD_EXP 23
29655: NOT
29656: AND
29657: PUSH
29658: LD_EXP 74
29662: PPUSH
29663: CALL_OW 302
29667: AND
29668: IFFALSE 30026
29670: GO 29672
29672: DISABLE
29673: LD_INT 0
29675: PPUSH
// begin missionStage = 11 ;
29676: LD_ADDR_EXP 15
29680: PUSH
29681: LD_INT 11
29683: ST_TO_ADDR
// DialogueOn ;
29684: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29688: LD_EXP 74
29692: PPUSH
29693: LD_STRING D9-Roth-1
29695: PPUSH
29696: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29700: LD_EXP 39
29704: PPUSH
29705: LD_STRING D9-JMM-1
29707: PPUSH
29708: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29712: LD_EXP 74
29716: PPUSH
29717: LD_STRING D9-Roth-2
29719: PPUSH
29720: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29724: LD_EXP 74
29728: PPUSH
29729: LD_STRING D9-Roth-2a
29731: PPUSH
29732: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29736: LD_EXP 64
29740: PPUSH
29741: LD_STRING D9-Pla-2
29743: PPUSH
29744: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29748: LD_EXP 74
29752: PPUSH
29753: LD_STRING D9-Roth-3
29755: PPUSH
29756: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29760: LD_EXP 64
29764: PPUSH
29765: LD_STRING D9-Pla-3
29767: PPUSH
29768: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29772: LD_EXP 74
29776: PPUSH
29777: LD_STRING D9-Roth-4
29779: PPUSH
29780: CALL_OW 94
// dec = Query ( Q9 ) ;
29784: LD_ADDR_VAR 0 1
29788: PUSH
29789: LD_STRING Q9
29791: PPUSH
29792: CALL_OW 97
29796: ST_TO_ADDR
// if dec = 1 then
29797: LD_VAR 0 1
29801: PUSH
29802: LD_INT 1
29804: EQUAL
29805: IFFALSE 29819
// SayRadio ( Roth , D9a-Roth-1 ) ;
29807: LD_EXP 74
29811: PPUSH
29812: LD_STRING D9a-Roth-1
29814: PPUSH
29815: CALL_OW 94
// if dec = 2 then
29819: LD_VAR 0 1
29823: PUSH
29824: LD_INT 2
29826: EQUAL
29827: IFFALSE 29853
// begin Say ( JMM , D9b-JMM-1 ) ;
29829: LD_EXP 39
29833: PPUSH
29834: LD_STRING D9b-JMM-1
29836: PPUSH
29837: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29841: LD_EXP 74
29845: PPUSH
29846: LD_STRING D9b-Roth-1
29848: PPUSH
29849: CALL_OW 94
// end ; if dec = 3 then
29853: LD_VAR 0 1
29857: PUSH
29858: LD_INT 3
29860: EQUAL
29861: IFFALSE 29923
// begin Say ( JMM , D9c-JMM-1 ) ;
29863: LD_EXP 39
29867: PPUSH
29868: LD_STRING D9c-JMM-1
29870: PPUSH
29871: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29875: LD_EXP 74
29879: PPUSH
29880: LD_STRING D9c-Roth-1
29882: PPUSH
29883: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29887: LD_EXP 39
29891: PPUSH
29892: LD_STRING D9c-JMM-2
29894: PPUSH
29895: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29899: LD_EXP 74
29903: PPUSH
29904: LD_STRING D9c-Roth-2
29906: PPUSH
29907: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29911: LD_EXP 39
29915: PPUSH
29916: LD_STRING D9c-JMM-3
29918: PPUSH
29919: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29923: LD_EXP 74
29927: PPUSH
29928: LD_STRING D9c-Roth-3
29930: PPUSH
29931: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29935: LD_EXP 74
29939: PPUSH
29940: LD_STRING D9cont-Roth-1
29942: PPUSH
29943: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29947: LD_EXP 39
29951: PPUSH
29952: LD_STRING D9cont-JMM-1
29954: PPUSH
29955: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29959: LD_EXP 74
29963: PPUSH
29964: LD_STRING D9cont-Roth-2
29966: PPUSH
29967: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29971: LD_EXP 39
29975: PPUSH
29976: LD_STRING D9cont-JMM-2
29978: PPUSH
29979: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29983: LD_EXP 74
29987: PPUSH
29988: LD_STRING D9cont-Roth-3
29990: PPUSH
29991: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29995: LD_EXP 39
29999: PPUSH
30000: LD_STRING D9cont-JMM-3
30002: PPUSH
30003: CALL_OW 88
// DialogueOff ;
30007: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
30011: LD_STRING M3
30013: PPUSH
30014: CALL_OW 337
// allianceActive := true ;
30018: LD_ADDR_EXP 31
30022: PUSH
30023: LD_INT 1
30025: ST_TO_ADDR
// end ;
30026: PPOPN 1
30028: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
30029: LD_INT 1
30031: PPUSH
30032: LD_INT 126
30034: PPUSH
30035: CALL_OW 292
30039: PUSH
30040: LD_EXP 64
30044: PPUSH
30045: CALL_OW 310
30049: AND
30050: IFFALSE 30130
30052: GO 30054
30054: DISABLE
30055: LD_INT 0
30057: PPUSH
// begin ComExitBuilding ( Platonov ) ;
30058: LD_EXP 64
30062: PPUSH
30063: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
30067: LD_ADDR_VAR 0 1
30071: PUSH
30072: LD_INT 4
30074: PPUSH
30075: LD_INT 22
30077: PUSH
30078: LD_INT 1
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PPUSH
30085: CALL_OW 70
30089: PPUSH
30090: LD_EXP 64
30094: PPUSH
30095: CALL_OW 74
30099: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
30100: LD_EXP 64
30104: PPUSH
30105: LD_VAR 0 1
30109: PUSH
30110: LD_INT 1
30112: ARRAY
30113: PPUSH
30114: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
30118: LD_EXP 64
30122: PPUSH
30123: LD_STRING D18-Pla-1
30125: PPUSH
30126: CALL_OW 88
// end ;
30130: PPOPN 1
30132: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
30133: LD_EXP 64
30137: PPUSH
30138: CALL_OW 301
30142: PUSH
30143: LD_EXP 67
30147: PPUSH
30148: CALL_OW 301
30152: AND
30153: PUSH
30154: LD_INT 22
30156: PUSH
30157: LD_INT 3
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 21
30166: PUSH
30167: LD_INT 1
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 50
30176: PUSH
30177: EMPTY
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: LIST
30184: PPUSH
30185: CALL_OW 69
30189: PUSH
30190: LD_INT 7
30192: PUSH
30193: LD_INT 8
30195: PUSH
30196: LD_INT 9
30198: PUSH
30199: LD_INT 10
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: PUSH
30208: LD_OWVAR 67
30212: ARRAY
30213: LESS
30214: AND
30215: IFFALSE 30972
30217: GO 30219
30219: DISABLE
30220: LD_INT 0
30222: PPUSH
30223: PPUSH
30224: PPUSH
30225: PPUSH
// begin MC_Kill ( 2 ) ;
30226: LD_INT 2
30228: PPUSH
30229: CALL 35661 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
30233: LD_INT 1
30235: PPUSH
30236: LD_INT 3
30238: PPUSH
30239: LD_INT 1
30241: PPUSH
30242: LD_INT 1
30244: PPUSH
30245: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
30249: LD_ADDR_VAR 0 2
30253: PUSH
30254: LD_INT 22
30256: PUSH
30257: LD_INT 3
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 21
30266: PUSH
30267: LD_INT 1
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 50
30276: PUSH
30277: EMPTY
30278: LIST
30279: PUSH
30280: LD_INT 26
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: PPUSH
30296: CALL_OW 69
30300: ST_TO_ADDR
// if not tmp then
30301: LD_VAR 0 2
30305: NOT
30306: IFFALSE 30362
// begin uc_side = 3 ;
30308: LD_ADDR_OWVAR 20
30312: PUSH
30313: LD_INT 3
30315: ST_TO_ADDR
// uc_nation = 3 ;
30316: LD_ADDR_OWVAR 21
30320: PUSH
30321: LD_INT 3
30323: ST_TO_ADDR
// hc_name =  ;
30324: LD_ADDR_OWVAR 26
30328: PUSH
30329: LD_STRING 
30331: ST_TO_ADDR
// hc_gallery =  ;
30332: LD_ADDR_OWVAR 33
30336: PUSH
30337: LD_STRING 
30339: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30340: LD_INT 1
30342: PPUSH
30343: LD_INT 10
30345: PPUSH
30346: CALL_OW 381
// tmp = CreateHuman ;
30350: LD_ADDR_VAR 0 2
30354: PUSH
30355: CALL_OW 44
30359: ST_TO_ADDR
// end else
30360: GO 30376
// tmp := tmp [ 1 ] ;
30362: LD_ADDR_VAR 0 2
30366: PUSH
30367: LD_VAR 0 2
30371: PUSH
30372: LD_INT 1
30374: ARRAY
30375: ST_TO_ADDR
// DialogueOn ;
30376: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30380: LD_VAR 0 2
30384: PPUSH
30385: LD_STRING DSurrenderRussians-RSol1-1a
30387: PPUSH
30388: CALL_OW 94
// DialogueOff ;
30392: CALL_OW 7
// russianDestroyed := true ;
30396: LD_ADDR_EXP 21
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30404: LD_INT 22
30406: PUSH
30407: LD_INT 3
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 21
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PPUSH
30428: CALL_OW 69
30432: PPUSH
30433: CALL_OW 122
// wait ( 0 0$1 ) ;
30437: LD_INT 35
30439: PPUSH
30440: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30444: LD_INT 22
30446: PUSH
30447: LD_INT 3
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 21
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PPUSH
30468: CALL_OW 69
30472: PPUSH
30473: LD_INT 25
30475: PPUSH
30476: CALL_OW 173
// wait ( 0 0$15 ) ;
30480: LD_INT 525
30482: PPUSH
30483: CALL_OW 67
// PrepareOmarInvasion ;
30487: CALL 13748 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30491: LD_ADDR_VAR 0 2
30495: PUSH
30496: LD_EXP 92
30500: PPUSH
30501: CALL_OW 250
30505: PUSH
30506: LD_EXP 92
30510: PPUSH
30511: CALL_OW 251
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30520: LD_VAR 0 2
30524: PUSH
30525: LD_INT 1
30527: ARRAY
30528: PPUSH
30529: LD_VAR 0 2
30533: PUSH
30534: LD_INT 2
30536: ARRAY
30537: PPUSH
30538: LD_INT 1
30540: PPUSH
30541: LD_INT 8
30543: NEG
30544: PPUSH
30545: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30549: LD_EXP 92
30553: PPUSH
30554: CALL_OW 87
// DialogueOn ;
30558: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30562: LD_EXP 39
30566: PPUSH
30567: LD_STRING D19-JMM-1
30569: PPUSH
30570: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30574: LD_ADDR_VAR 0 3
30578: PUSH
30579: LD_INT 22
30581: PUSH
30582: LD_INT 1
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 26
30591: PUSH
30592: LD_INT 1
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: PUSH
30602: LD_INT 25
30604: PUSH
30605: LD_INT 1
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 25
30614: PUSH
30615: LD_INT 2
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 25
30624: PUSH
30625: LD_INT 3
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PUSH
30632: LD_INT 25
30634: PUSH
30635: LD_INT 4
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 25
30644: PUSH
30645: LD_INT 5
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 25
30654: PUSH
30655: LD_INT 8
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: LIST
30675: PPUSH
30676: CALL_OW 69
30680: PUSH
30681: LD_EXP 39
30685: PUSH
30686: LD_EXP 40
30690: PUSH
30691: LD_EXP 41
30695: PUSH
30696: LD_EXP 42
30700: PUSH
30701: LD_EXP 43
30705: PUSH
30706: LD_EXP 44
30710: PUSH
30711: LD_EXP 45
30715: PUSH
30716: LD_EXP 46
30720: PUSH
30721: LD_EXP 47
30725: PUSH
30726: LD_EXP 48
30730: PUSH
30731: LD_EXP 49
30735: PUSH
30736: LD_EXP 50
30740: PUSH
30741: LD_EXP 51
30745: PUSH
30746: LD_EXP 52
30750: PUSH
30751: LD_EXP 53
30755: PUSH
30756: LD_EXP 54
30760: PUSH
30761: LD_EXP 55
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: LIST
30775: LIST
30776: LIST
30777: LIST
30778: LIST
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: DIFF
30785: ST_TO_ADDR
// if tmp2 then
30786: LD_VAR 0 3
30790: IFFALSE 30808
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30792: LD_VAR 0 3
30796: PUSH
30797: LD_INT 1
30799: ARRAY
30800: PPUSH
30801: LD_STRING D19-Sol1-1
30803: PPUSH
30804: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30808: LD_EXP 39
30812: PPUSH
30813: LD_STRING D19-JMM-2
30815: PPUSH
30816: CALL_OW 88
// DialogueOff ;
30820: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30824: LD_VAR 0 2
30828: PUSH
30829: LD_INT 1
30831: ARRAY
30832: PPUSH
30833: LD_VAR 0 2
30837: PUSH
30838: LD_INT 2
30840: ARRAY
30841: PPUSH
30842: LD_INT 1
30844: PPUSH
30845: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30849: LD_STRING M5
30851: PPUSH
30852: CALL_OW 337
// omarOnMotherLode := false ;
30856: LD_ADDR_VAR 0 4
30860: PUSH
30861: LD_INT 0
30863: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30864: LD_INT 35
30866: PPUSH
30867: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30871: LD_EXP 92
30875: PPUSH
30876: LD_INT 215
30878: PPUSH
30879: LD_INT 100
30881: PPUSH
30882: CALL_OW 297
30886: PUSH
30887: LD_INT 10
30889: LESS
30890: PUSH
30891: LD_VAR 0 4
30895: NOT
30896: AND
30897: IFFALSE 30931
// begin omarOnMotherLode := true ;
30899: LD_ADDR_VAR 0 4
30903: PUSH
30904: LD_INT 1
30906: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30907: LD_EXP 39
30911: PPUSH
30912: LD_STRING D19b-JMM-1
30914: PPUSH
30915: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30919: LD_EXP 92
30923: PPUSH
30924: LD_STRING DOmarContam-Omar-1
30926: PPUSH
30927: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30931: LD_EXP 92
30935: PPUSH
30936: CALL_OW 301
30940: IFFALSE 30864
// Say ( JMM , D19a-JMM-1 ) ;
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING D19a-JMM-1
30949: PPUSH
30950: CALL_OW 88
// if Heike then
30954: LD_EXP 93
30958: IFFALSE 30972
// Say ( Heike , D19a-Hke-1 ) ;
30960: LD_EXP 93
30964: PPUSH
30965: LD_STRING D19a-Hke-1
30967: PPUSH
30968: CALL_OW 88
// end ;
30972: PPOPN 4
30974: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30975: LD_INT 22
30977: PUSH
30978: LD_INT 3
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 21
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PPUSH
30999: CALL_OW 69
31003: PUSH
31004: LD_EXP 21
31008: AND
31009: IFFALSE 31077
31011: GO 31013
31013: DISABLE
31014: LD_INT 0
31016: PPUSH
31017: PPUSH
// begin enable ;
31018: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
31019: LD_ADDR_VAR 0 2
31023: PUSH
31024: LD_INT 25
31026: PPUSH
31027: LD_INT 22
31029: PUSH
31030: LD_INT 3
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PPUSH
31037: CALL_OW 70
31041: ST_TO_ADDR
// if not tmp then
31042: LD_VAR 0 2
31046: NOT
31047: IFFALSE 31051
// exit ;
31049: GO 31077
// for i in tmp do
31051: LD_ADDR_VAR 0 1
31055: PUSH
31056: LD_VAR 0 2
31060: PUSH
31061: FOR_IN
31062: IFFALSE 31075
// RemoveUnit ( i ) ;
31064: LD_VAR 0 1
31068: PPUSH
31069: CALL_OW 64
31073: GO 31061
31075: POP
31076: POP
// end ;
31077: PPOPN 2
31079: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
31080: LD_INT 22
31082: PUSH
31083: LD_INT 7
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 21
31092: PUSH
31093: LD_INT 1
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PPUSH
31104: CALL_OW 69
31108: PUSH
31109: LD_INT 6
31111: LESS
31112: IFFALSE 31580
31114: GO 31116
31116: DISABLE
31117: LD_INT 0
31119: PPUSH
31120: PPUSH
// begin MC_Kill ( 1 ) ;
31121: LD_INT 1
31123: PPUSH
31124: CALL 35661 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
31128: LD_INT 7
31130: PPUSH
31131: LD_INT 1
31133: PPUSH
31134: LD_INT 1
31136: PPUSH
31137: LD_INT 1
31139: PPUSH
31140: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
31144: LD_ADDR_VAR 0 1
31148: PUSH
31149: LD_INT 22
31151: PUSH
31152: LD_INT 7
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 26
31161: PUSH
31162: LD_INT 1
31164: PUSH
31165: EMPTY
31166: LIST
31167: LIST
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PPUSH
31173: CALL_OW 69
31177: PUSH
31178: LD_EXP 74
31182: DIFF
31183: ST_TO_ADDR
// if tmp then
31184: LD_VAR 0 1
31188: IFFALSE 31206
// tmp := tmp [ 1 ] else
31190: LD_ADDR_VAR 0 1
31194: PUSH
31195: LD_VAR 0 1
31199: PUSH
31200: LD_INT 1
31202: ARRAY
31203: ST_TO_ADDR
31204: GO 31242
// begin uc_side := 7 ;
31206: LD_ADDR_OWVAR 20
31210: PUSH
31211: LD_INT 7
31213: ST_TO_ADDR
// uc_nation := 1 ;
31214: LD_ADDR_OWVAR 21
31218: PUSH
31219: LD_INT 1
31221: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
31222: LD_INT 1
31224: PPUSH
31225: LD_INT 8
31227: PPUSH
31228: CALL_OW 384
// tmp := CreateHuman ;
31232: LD_ADDR_VAR 0 1
31236: PUSH
31237: CALL_OW 44
31241: ST_TO_ADDR
// end ; DialogueOn ;
31242: CALL_OW 6
// if IsOK ( Roth ) then
31246: LD_EXP 74
31250: PPUSH
31251: CALL_OW 302
31255: IFFALSE 31269
// Say ( JMM , DAb-JMM-1 ) ;
31257: LD_EXP 39
31261: PPUSH
31262: LD_STRING DAb-JMM-1
31264: PPUSH
31265: CALL_OW 88
// if IsOK ( Roth ) then
31269: LD_EXP 74
31273: PPUSH
31274: CALL_OW 302
31278: IFFALSE 31302
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
31280: LD_EXP 74
31284: PPUSH
31285: LD_STRING DSurrenderAlliance-Roth-1
31287: PPUSH
31288: CALL_OW 88
// RothCaptured := true ;
31292: LD_ADDR_EXP 33
31296: PUSH
31297: LD_INT 1
31299: ST_TO_ADDR
// end else
31300: GO 31314
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
31302: LD_VAR 0 1
31306: PPUSH
31307: LD_STRING DSurrenderAlliance-Sci1-1
31309: PPUSH
31310: CALL_OW 88
// DialogueOff ;
31314: CALL_OW 7
// allianceDestroyed := true ;
31318: LD_ADDR_EXP 23
31322: PUSH
31323: LD_INT 1
31325: ST_TO_ADDR
// if capturedUnit = 0 then
31326: LD_EXP 34
31330: PUSH
31331: LD_INT 0
31333: EQUAL
31334: IFFALSE 31343
// SetAchievement ( ACH_ALLIANCE ) ;
31336: LD_STRING ACH_ALLIANCE
31338: PPUSH
31339: CALL_OW 543
// if trueAmericans then
31343: LD_EXP 35
31347: IFFALSE 31423
// begin if trueAmericans = 1 then
31349: LD_EXP 35
31353: PUSH
31354: LD_INT 1
31356: EQUAL
31357: IFFALSE 31373
// Say ( JMM , DAb-JMM-1a ) else
31359: LD_EXP 39
31363: PPUSH
31364: LD_STRING DAb-JMM-1a
31366: PPUSH
31367: CALL_OW 88
31371: GO 31385
// Say ( JMM , DAb-JMM-1b ) ;
31373: LD_EXP 39
31377: PPUSH
31378: LD_STRING DAb-JMM-1b
31380: PPUSH
31381: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31385: LD_EXP 35
31389: PPUSH
31390: CALL_OW 87
// for i in trueAmericans do
31394: LD_ADDR_VAR 0 2
31398: PUSH
31399: LD_EXP 35
31403: PUSH
31404: FOR_IN
31405: IFFALSE 31421
// SetSide ( i , 1 ) ;
31407: LD_VAR 0 2
31411: PPUSH
31412: LD_INT 1
31414: PPUSH
31415: CALL_OW 235
31419: GO 31404
31421: POP
31422: POP
// end ; repeat wait ( 0 0$1 ) ;
31423: LD_INT 35
31425: PPUSH
31426: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31430: LD_ADDR_VAR 0 2
31434: PUSH
31435: LD_INT 22
31437: PUSH
31438: LD_INT 7
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 21
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PPUSH
31459: CALL_OW 69
31463: PUSH
31464: FOR_IN
31465: IFFALSE 31547
// begin if IsInUnit ( i ) then
31467: LD_VAR 0 2
31471: PPUSH
31472: CALL_OW 310
31476: IFFALSE 31487
// ComExitBuilding ( i ) ;
31478: LD_VAR 0 2
31482: PPUSH
31483: CALL_OW 122
// if IsDriver ( i ) then
31487: LD_VAR 0 2
31491: PPUSH
31492: CALL 101081 0 1
31496: IFFALSE 31507
// ComExitVehicle ( i ) ;
31498: LD_VAR 0 2
31502: PPUSH
31503: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31507: LD_VAR 0 2
31511: PPUSH
31512: LD_INT 26
31514: PPUSH
31515: CALL_OW 308
31519: NOT
31520: IFFALSE 31536
// AddComMoveToArea ( i , allianceEscapeArea ) else
31522: LD_VAR 0 2
31526: PPUSH
31527: LD_INT 26
31529: PPUSH
31530: CALL_OW 173
31534: GO 31545
// RemoveUnit ( i ) ;
31536: LD_VAR 0 2
31540: PPUSH
31541: CALL_OW 64
// end ;
31545: GO 31464
31547: POP
31548: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31549: LD_INT 22
31551: PUSH
31552: LD_INT 7
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 21
31561: PUSH
31562: LD_INT 1
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PPUSH
31573: CALL_OW 69
31577: NOT
31578: IFFALSE 31423
// end ;
31580: PPOPN 2
31582: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31583: LD_INT 0
31585: PPUSH
31586: PPUSH
// if not unit then
31587: LD_VAR 0 1
31591: NOT
31592: IFFALSE 31596
// exit ;
31594: GO 33094
// DoNotAttack ( 7 , unit ) ;
31596: LD_INT 7
31598: PPUSH
31599: LD_VAR 0 1
31603: PPUSH
31604: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_INT 260
31615: PPUSH
31616: LD_INT 235
31618: PPUSH
31619: LD_INT 3
31621: PPUSH
31622: LD_INT 1
31624: PPUSH
31625: CALL_OW 483
// SetSide ( unit , 4 ) ;
31629: LD_VAR 0 1
31633: PPUSH
31634: LD_INT 4
31636: PPUSH
31637: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31641: LD_ADDR_EXP 34
31645: PUSH
31646: LD_EXP 34
31650: PUSH
31651: LD_INT 1
31653: PLUS
31654: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31655: LD_INT 70
31657: PPUSH
31658: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31662: LD_INT 260
31664: PPUSH
31665: LD_INT 235
31667: PPUSH
31668: LD_INT 1
31670: PPUSH
31671: LD_INT 8
31673: NEG
31674: PPUSH
31675: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31679: LD_VAR 0 1
31683: PPUSH
31684: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31688: LD_VAR 0 1
31692: PPUSH
31693: LD_EXP 74
31697: PPUSH
31698: CALL_OW 119
// DialogueOn ;
31702: CALL_OW 6
// case unit of JMM :
31706: LD_VAR 0 1
31710: PUSH
31711: LD_EXP 39
31715: DOUBLE
31716: EQUAL
31717: IFTRUE 31721
31719: GO 31736
31721: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31722: LD_EXP 39
31726: PPUSH
31727: LD_STRING DA1-JMM-1
31729: PPUSH
31730: CALL_OW 91
31734: GO 32178
31736: LD_EXP 40
31740: DOUBLE
31741: EQUAL
31742: IFTRUE 31746
31744: GO 31761
31746: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31747: LD_EXP 40
31751: PPUSH
31752: LD_STRING DA1-Joan-1
31754: PPUSH
31755: CALL_OW 91
31759: GO 32178
31761: LD_EXP 42
31765: DOUBLE
31766: EQUAL
31767: IFTRUE 31771
31769: GO 31786
31771: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31772: LD_EXP 42
31776: PPUSH
31777: LD_STRING DA1-Lisa-1
31779: PPUSH
31780: CALL_OW 91
31784: GO 32178
31786: LD_EXP 43
31790: DOUBLE
31791: EQUAL
31792: IFTRUE 31796
31794: GO 31811
31796: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31797: LD_EXP 43
31801: PPUSH
31802: LD_STRING DA1-Don-1
31804: PPUSH
31805: CALL_OW 91
31809: GO 32178
31811: LD_EXP 50
31815: DOUBLE
31816: EQUAL
31817: IFTRUE 31821
31819: GO 31836
31821: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31822: LD_EXP 50
31826: PPUSH
31827: LD_STRING DA1-Corn-1
31829: PPUSH
31830: CALL_OW 91
31834: GO 32178
31836: LD_EXP 46
31840: DOUBLE
31841: EQUAL
31842: IFTRUE 31846
31844: GO 31861
31846: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31847: LD_EXP 46
31851: PPUSH
31852: LD_STRING DA1-Den-1
31854: PPUSH
31855: CALL_OW 91
31859: GO 32178
31861: LD_EXP 44
31865: DOUBLE
31866: EQUAL
31867: IFTRUE 31871
31869: GO 31886
31871: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31872: LD_EXP 44
31876: PPUSH
31877: LD_STRING DA1-Bobby-1
31879: PPUSH
31880: CALL_OW 91
31884: GO 32178
31886: LD_EXP 48
31890: DOUBLE
31891: EQUAL
31892: IFTRUE 31896
31894: GO 31911
31896: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31897: LD_EXP 48
31901: PPUSH
31902: LD_STRING DA1-Glad-1
31904: PPUSH
31905: CALL_OW 91
31909: GO 32178
31911: LD_EXP 45
31915: DOUBLE
31916: EQUAL
31917: IFTRUE 31921
31919: GO 31936
31921: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31922: LD_EXP 45
31926: PPUSH
31927: LD_STRING DA1-Cyrus-1
31929: PPUSH
31930: CALL_OW 91
31934: GO 32178
31936: LD_EXP 41
31940: DOUBLE
31941: EQUAL
31942: IFTRUE 31946
31944: GO 31961
31946: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31947: LD_EXP 41
31951: PPUSH
31952: LD_STRING DA1-Huck-1
31954: PPUSH
31955: CALL_OW 91
31959: GO 32178
31961: LD_EXP 55
31965: DOUBLE
31966: EQUAL
31967: IFTRUE 31971
31969: GO 31986
31971: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31972: LD_EXP 55
31976: PPUSH
31977: LD_STRING DA1-Huck-1
31979: PPUSH
31980: CALL_OW 91
31984: GO 32178
31986: LD_EXP 47
31990: DOUBLE
31991: EQUAL
31992: IFTRUE 31996
31994: GO 32011
31996: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31997: LD_EXP 47
32001: PPUSH
32002: LD_STRING DA1-Brown-1
32004: PPUSH
32005: CALL_OW 91
32009: GO 32178
32011: LD_EXP 51
32015: DOUBLE
32016: EQUAL
32017: IFTRUE 32021
32019: GO 32036
32021: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
32022: LD_EXP 51
32026: PPUSH
32027: LD_STRING DA1-Gary-1
32029: PPUSH
32030: CALL_OW 91
32034: GO 32178
32036: LD_EXP 54
32040: DOUBLE
32041: EQUAL
32042: IFTRUE 32046
32044: GO 32061
32046: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
32047: LD_EXP 54
32051: PPUSH
32052: LD_STRING DA1-Con-1
32054: PPUSH
32055: CALL_OW 91
32059: GO 32178
32061: LD_EXP 60
32065: DOUBLE
32066: EQUAL
32067: IFTRUE 32071
32069: GO 32086
32071: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
32072: LD_EXP 60
32076: PPUSH
32077: LD_STRING DA1-Kurt-1
32079: PPUSH
32080: CALL_OW 91
32084: GO 32178
32086: LD_EXP 53
32090: DOUBLE
32091: EQUAL
32092: IFTRUE 32096
32094: GO 32111
32096: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
32097: LD_EXP 53
32101: PPUSH
32102: LD_STRING DA1-Yam-1
32104: PPUSH
32105: CALL_OW 91
32109: GO 32178
32111: LD_EXP 52
32115: DOUBLE
32116: EQUAL
32117: IFTRUE 32121
32119: GO 32136
32121: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
32122: LD_EXP 52
32126: PPUSH
32127: LD_STRING DA1-Frank-1
32129: PPUSH
32130: CALL_OW 91
32134: GO 32178
32136: POP
// begin if GetSex ( unit ) = sex_male then
32137: LD_VAR 0 1
32141: PPUSH
32142: CALL_OW 258
32146: PUSH
32147: LD_INT 1
32149: EQUAL
32150: IFFALSE 32166
// ForceSay ( unit , DA1-Sol1-1 ) else
32152: LD_VAR 0 1
32156: PPUSH
32157: LD_STRING DA1-Sol1-1
32159: PPUSH
32160: CALL_OW 91
32164: GO 32178
// ForceSay ( unit , DA1-FSol1-1 ) ;
32166: LD_VAR 0 1
32170: PPUSH
32171: LD_STRING DA1-FSol1-1
32173: PPUSH
32174: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
32178: LD_EXP 74
32182: PPUSH
32183: LD_STRING DA-Roth-1
32185: PPUSH
32186: CALL_OW 88
// if capturedUnit = 1 then
32190: LD_EXP 34
32194: PUSH
32195: LD_INT 1
32197: EQUAL
32198: IFFALSE 32226
// begin Say ( Simms , DA-Sim-1 ) ;
32200: LD_EXP 75
32204: PPUSH
32205: LD_STRING DA-Sim-1
32207: PPUSH
32208: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
32212: LD_EXP 74
32216: PPUSH
32217: LD_STRING DA-Roth-2
32219: PPUSH
32220: CALL_OW 88
// end else
32224: GO 32238
// Say ( Simms , DA-Sim-2 ) ;
32226: LD_EXP 75
32230: PPUSH
32231: LD_STRING DA-Sim-2
32233: PPUSH
32234: CALL_OW 88
// case unit of JMM :
32238: LD_VAR 0 1
32242: PUSH
32243: LD_EXP 39
32247: DOUBLE
32248: EQUAL
32249: IFTRUE 32253
32251: GO 32268
32253: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
32254: LD_EXP 39
32258: PPUSH
32259: LD_STRING DA1-JMM-1a
32261: PPUSH
32262: CALL_OW 91
32266: GO 32775
32268: LD_EXP 40
32272: DOUBLE
32273: EQUAL
32274: IFTRUE 32278
32276: GO 32293
32278: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
32279: LD_EXP 40
32283: PPUSH
32284: LD_STRING DA1-Joan-1a
32286: PPUSH
32287: CALL_OW 91
32291: GO 32775
32293: LD_EXP 42
32297: DOUBLE
32298: EQUAL
32299: IFTRUE 32303
32301: GO 32318
32303: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
32304: LD_EXP 42
32308: PPUSH
32309: LD_STRING DA1-Lisa-1a
32311: PPUSH
32312: CALL_OW 91
32316: GO 32775
32318: LD_EXP 43
32322: DOUBLE
32323: EQUAL
32324: IFTRUE 32328
32326: GO 32343
32328: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32329: LD_EXP 43
32333: PPUSH
32334: LD_STRING DA1-Don-1a
32336: PPUSH
32337: CALL_OW 91
32341: GO 32775
32343: LD_EXP 50
32347: DOUBLE
32348: EQUAL
32349: IFTRUE 32353
32351: GO 32368
32353: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32354: LD_EXP 50
32358: PPUSH
32359: LD_STRING DA1-Corn-1a
32361: PPUSH
32362: CALL_OW 91
32366: GO 32775
32368: LD_EXP 46
32372: DOUBLE
32373: EQUAL
32374: IFTRUE 32378
32376: GO 32393
32378: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32379: LD_EXP 46
32383: PPUSH
32384: LD_STRING DA1-Den-1a
32386: PPUSH
32387: CALL_OW 91
32391: GO 32775
32393: LD_EXP 44
32397: DOUBLE
32398: EQUAL
32399: IFTRUE 32403
32401: GO 32418
32403: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32404: LD_EXP 44
32408: PPUSH
32409: LD_STRING DA1-Bobby-1a
32411: PPUSH
32412: CALL_OW 91
32416: GO 32775
32418: LD_EXP 48
32422: DOUBLE
32423: EQUAL
32424: IFTRUE 32428
32426: GO 32443
32428: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32429: LD_EXP 48
32433: PPUSH
32434: LD_STRING DA1-Glad-1a
32436: PPUSH
32437: CALL_OW 91
32441: GO 32775
32443: LD_EXP 45
32447: DOUBLE
32448: EQUAL
32449: IFTRUE 32453
32451: GO 32468
32453: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32454: LD_EXP 45
32458: PPUSH
32459: LD_STRING DA1-Cyrus-1a
32461: PPUSH
32462: CALL_OW 91
32466: GO 32775
32468: LD_EXP 41
32472: DOUBLE
32473: EQUAL
32474: IFTRUE 32478
32476: GO 32493
32478: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32479: LD_EXP 41
32483: PPUSH
32484: LD_STRING DA1-Huck-1a
32486: PPUSH
32487: CALL_OW 91
32491: GO 32775
32493: LD_EXP 55
32497: DOUBLE
32498: EQUAL
32499: IFTRUE 32503
32501: GO 32518
32503: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32504: LD_EXP 55
32508: PPUSH
32509: LD_STRING DA1-Huck-1a
32511: PPUSH
32512: CALL_OW 91
32516: GO 32775
32518: LD_EXP 47
32522: DOUBLE
32523: EQUAL
32524: IFTRUE 32528
32526: GO 32543
32528: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32529: LD_EXP 47
32533: PPUSH
32534: LD_STRING DA1-Brown-1a
32536: PPUSH
32537: CALL_OW 91
32541: GO 32775
32543: LD_EXP 51
32547: DOUBLE
32548: EQUAL
32549: IFTRUE 32553
32551: GO 32568
32553: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32554: LD_EXP 51
32558: PPUSH
32559: LD_STRING DA1-Gary-1a
32561: PPUSH
32562: CALL_OW 91
32566: GO 32775
32568: LD_EXP 54
32572: DOUBLE
32573: EQUAL
32574: IFTRUE 32578
32576: GO 32593
32578: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32579: LD_EXP 54
32583: PPUSH
32584: LD_STRING DA1-Con-1a
32586: PPUSH
32587: CALL_OW 91
32591: GO 32775
32593: LD_EXP 60
32597: DOUBLE
32598: EQUAL
32599: IFTRUE 32603
32601: GO 32618
32603: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32604: LD_EXP 60
32608: PPUSH
32609: LD_STRING DA1-Kurt-1a
32611: PPUSH
32612: CALL_OW 91
32616: GO 32775
32618: LD_EXP 53
32622: DOUBLE
32623: EQUAL
32624: IFTRUE 32628
32626: GO 32643
32628: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32629: LD_EXP 53
32633: PPUSH
32634: LD_STRING DA1-Yam-1a
32636: PPUSH
32637: CALL_OW 91
32641: GO 32775
32643: LD_EXP 52
32647: DOUBLE
32648: EQUAL
32649: IFTRUE 32653
32651: GO 32668
32653: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32654: LD_EXP 52
32658: PPUSH
32659: LD_STRING DA1-Frank-1a
32661: PPUSH
32662: CALL_OW 91
32666: GO 32775
32668: POP
// begin join := rand ( 0 , 1 ) ;
32669: LD_ADDR_VAR 0 3
32673: PUSH
32674: LD_INT 0
32676: PPUSH
32677: LD_INT 1
32679: PPUSH
32680: CALL_OW 12
32684: ST_TO_ADDR
// if join then
32685: LD_VAR 0 3
32689: IFFALSE 32734
// begin if GetSex ( unit ) = sex_male then
32691: LD_VAR 0 1
32695: PPUSH
32696: CALL_OW 258
32700: PUSH
32701: LD_INT 1
32703: EQUAL
32704: IFFALSE 32720
// ForceSay ( unit , DA1-Sol1-1b ) else
32706: LD_VAR 0 1
32710: PPUSH
32711: LD_STRING DA1-Sol1-1b
32713: PPUSH
32714: CALL_OW 91
32718: GO 32732
// ForceSay ( unit , DA1-FSol1-1b ) ;
32720: LD_VAR 0 1
32724: PPUSH
32725: LD_STRING DA1-FSol1-1b
32727: PPUSH
32728: CALL_OW 91
// end else
32732: GO 32775
// begin if GetSex ( unit ) = sex_male then
32734: LD_VAR 0 1
32738: PPUSH
32739: CALL_OW 258
32743: PUSH
32744: LD_INT 1
32746: EQUAL
32747: IFFALSE 32763
// ForceSay ( unit , DA1-Sol1-1a ) else
32749: LD_VAR 0 1
32753: PPUSH
32754: LD_STRING DA1-Sol1-1a
32756: PPUSH
32757: CALL_OW 91
32761: GO 32775
// ForceSay ( unit , DA1-FSol1-1a ) ;
32763: LD_VAR 0 1
32767: PPUSH
32768: LD_STRING DA1-FSol1-1a
32770: PPUSH
32771: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32775: LD_VAR 0 1
32779: PUSH
32780: LD_EXP 39
32784: EQUAL
32785: IFFALSE 32796
// begin YouLost ( JMMCaptured ) ;
32787: LD_STRING JMMCaptured
32789: PPUSH
32790: CALL_OW 104
// exit ;
32794: GO 33094
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32796: LD_VAR 0 1
32800: PUSH
32801: LD_EXP 43
32805: PUSH
32806: LD_EXP 46
32810: PUSH
32811: LD_EXP 44
32815: PUSH
32816: LD_EXP 41
32820: PUSH
32821: LD_EXP 55
32825: PUSH
32826: LD_EXP 47
32830: PUSH
32831: LD_EXP 53
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: LIST
32844: IN
32845: PUSH
32846: LD_VAR 0 3
32850: OR
32851: IFFALSE 32950
// begin Say ( Roth , DA-Roth-3 ) ;
32853: LD_EXP 74
32857: PPUSH
32858: LD_STRING DA-Roth-3
32860: PPUSH
32861: CALL_OW 88
// SetSide ( unit , 7 ) ;
32865: LD_VAR 0 1
32869: PPUSH
32870: LD_INT 7
32872: PPUSH
32873: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32877: LD_ADDR_EXP 97
32881: PUSH
32882: LD_EXP 97
32886: PPUSH
32887: LD_INT 1
32889: PPUSH
32890: LD_EXP 97
32894: PUSH
32895: LD_INT 1
32897: ARRAY
32898: PUSH
32899: LD_VAR 0 1
32903: ADD
32904: PPUSH
32905: CALL_OW 1
32909: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32910: LD_INT 260
32912: PPUSH
32913: LD_INT 235
32915: PPUSH
32916: LD_INT 1
32918: PPUSH
32919: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32923: LD_VAR 0 1
32927: PPUSH
32928: LD_INT 1000
32930: PPUSH
32931: CALL_OW 234
// DialogueOff ;
32935: CALL_OW 7
// ComFree ( unit ) ;
32939: LD_VAR 0 1
32943: PPUSH
32944: CALL_OW 139
// end else
32948: GO 33031
// begin Say ( Roth , DA-Roth-3a ) ;
32950: LD_EXP 74
32954: PPUSH
32955: LD_STRING DA-Roth-3a
32957: PPUSH
32958: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32962: LD_ADDR_EXP 35
32966: PUSH
32967: LD_EXP 35
32971: PUSH
32972: LD_VAR 0 1
32976: ADD
32977: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32978: LD_INT 260
32980: PPUSH
32981: LD_INT 235
32983: PPUSH
32984: LD_INT 1
32986: PPUSH
32987: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32991: LD_VAR 0 1
32995: PPUSH
32996: LD_INT 1000
32998: PPUSH
32999: CALL_OW 234
// DialogueOff ;
33003: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
33007: LD_VAR 0 1
33011: PPUSH
33012: LD_INT 272
33014: PPUSH
33015: LD_INT 254
33017: PPUSH
33018: CALL_OW 111
// AddComHold ( unit ) ;
33022: LD_VAR 0 1
33026: PPUSH
33027: CALL_OW 200
// end ; if capturedUnit = 1 then
33031: LD_EXP 34
33035: PUSH
33036: LD_INT 1
33038: EQUAL
33039: IFFALSE 33094
// begin DialogueOn ;
33041: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
33045: LD_EXP 39
33049: PPUSH
33050: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
33054: LD_EXP 39
33058: PPUSH
33059: LD_STRING DAa-JMM-1
33061: PPUSH
33062: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
33066: LD_EXP 39
33070: PPUSH
33071: LD_STRING DAa-JMM-1a
33073: PPUSH
33074: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
33078: LD_EXP 39
33082: PPUSH
33083: LD_STRING DAa-JMM-1b
33085: PPUSH
33086: CALL_OW 88
// DialogueOff ;
33090: CALL_OW 7
// end ; end ;
33094: LD_VAR 0 2
33098: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
33099: LD_EXP 15
33103: PUSH
33104: LD_INT 13
33106: GREATEREQUAL
33107: PUSH
33108: LD_INT 22
33110: PUSH
33111: LD_INT 2
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 21
33120: PUSH
33121: LD_INT 1
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PPUSH
33132: CALL_OW 69
33136: PUSH
33137: LD_INT 0
33139: EQUAL
33140: AND
33141: PUSH
33142: LD_INT 22
33144: PUSH
33145: LD_INT 2
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 33
33154: PUSH
33155: LD_INT 5
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 21
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 50
33174: PUSH
33175: EMPTY
33176: LIST
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: PPUSH
33184: CALL_OW 69
33188: PUSH
33189: LD_INT 0
33191: EQUAL
33192: AND
33193: PUSH
33194: LD_EXP 21
33198: AND
33199: PUSH
33200: LD_EXP 22
33204: AND
33205: PUSH
33206: LD_EXP 23
33210: AND
33211: IFFALSE 33860
33213: GO 33215
33215: DISABLE
33216: LD_INT 0
33218: PPUSH
33219: PPUSH
33220: PPUSH
// begin m1 := false ;
33221: LD_ADDR_VAR 0 1
33225: PUSH
33226: LD_INT 0
33228: ST_TO_ADDR
// m2 := false ;
33229: LD_ADDR_VAR 0 2
33233: PUSH
33234: LD_INT 0
33236: ST_TO_ADDR
// m3 := false ;
33237: LD_ADDR_VAR 0 3
33241: PUSH
33242: LD_INT 0
33244: ST_TO_ADDR
// if not bombExploded then
33245: LD_EXP 37
33249: NOT
33250: IFFALSE 33259
// SetAchievement ( ACH_SIBROCKET ) ;
33252: LD_STRING ACH_SIBROCKET
33254: PPUSH
33255: CALL_OW 543
// if tick <= 120 120$00 then
33259: LD_OWVAR 1
33263: PUSH
33264: LD_INT 252000
33266: LESSEQUAL
33267: IFFALSE 33283
// begin wait ( 3 ) ;
33269: LD_INT 3
33271: PPUSH
33272: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
33276: LD_STRING ACH_ASPEED_15
33278: PPUSH
33279: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
33283: LD_EXP 39
33287: PPUSH
33288: CALL_OW 87
// music_class := 5 ;
33292: LD_ADDR_OWVAR 72
33296: PUSH
33297: LD_INT 5
33299: ST_TO_ADDR
// music_nat := 5 ;
33300: LD_ADDR_OWVAR 71
33304: PUSH
33305: LD_INT 5
33307: ST_TO_ADDR
// DialogueOn ;
33308: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33312: LD_EXP 39
33316: PPUSH
33317: LD_STRING D20-JMM-1
33319: PPUSH
33320: CALL_OW 88
// if IsOK ( Joan ) then
33324: LD_EXP 40
33328: PPUSH
33329: CALL_OW 302
33333: IFFALSE 33347
// Say ( Joan , D20-Joan-1 ) ;
33335: LD_EXP 40
33339: PPUSH
33340: LD_STRING D20-Joan-1
33342: PPUSH
33343: CALL_OW 88
// if IsOk ( Lisa ) then
33347: LD_EXP 42
33351: PPUSH
33352: CALL_OW 302
33356: IFFALSE 33370
// Say ( Lisa , D20-Lisa-1 ) ;
33358: LD_EXP 42
33362: PPUSH
33363: LD_STRING D20-Lisa-1
33365: PPUSH
33366: CALL_OW 88
// if IsOk ( Donaldson ) then
33370: LD_EXP 43
33374: PPUSH
33375: CALL_OW 302
33379: IFFALSE 33393
// Say ( Donaldson , D20-Don-1 ) ;
33381: LD_EXP 43
33385: PPUSH
33386: LD_STRING D20-Don-1
33388: PPUSH
33389: CALL_OW 88
// if IsOK ( Cornel ) then
33393: LD_EXP 50
33397: PPUSH
33398: CALL_OW 302
33402: IFFALSE 33416
// Say ( Cornel , D20-Corn-1 ) ;
33404: LD_EXP 50
33408: PPUSH
33409: LD_STRING D20-Corn-1
33411: PPUSH
33412: CALL_OW 88
// if IsOk ( Denis ) then
33416: LD_EXP 46
33420: PPUSH
33421: CALL_OW 302
33425: IFFALSE 33439
// Say ( Denis , D20-Den-1 ) ;
33427: LD_EXP 46
33431: PPUSH
33432: LD_STRING D20-Den-1
33434: PPUSH
33435: CALL_OW 88
// if IsOk ( Bobby ) then
33439: LD_EXP 44
33443: PPUSH
33444: CALL_OW 302
33448: IFFALSE 33462
// Say ( Bobby , D20-Bobby-1 ) ;
33450: LD_EXP 44
33454: PPUSH
33455: LD_STRING D20-Bobby-1
33457: PPUSH
33458: CALL_OW 88
// if IsOk ( Gladstone ) then
33462: LD_EXP 48
33466: PPUSH
33467: CALL_OW 302
33471: IFFALSE 33485
// Say ( Gladstone , D20-Glad-1 ) ;
33473: LD_EXP 48
33477: PPUSH
33478: LD_STRING D20-Glad-1
33480: PPUSH
33481: CALL_OW 88
// if IsOk ( Cyrus ) then
33485: LD_EXP 45
33489: PPUSH
33490: CALL_OW 302
33494: IFFALSE 33508
// Say ( Cyrus , D20-Cyrus-1 ) ;
33496: LD_EXP 45
33500: PPUSH
33501: LD_STRING D20-Cyrus-1
33503: PPUSH
33504: CALL_OW 88
// if IsOk ( Stevens ) then
33508: LD_EXP 41
33512: PPUSH
33513: CALL_OW 302
33517: IFFALSE 33531
// Say ( Stevens , D20-Huck-1 ) ;
33519: LD_EXP 41
33523: PPUSH
33524: LD_STRING D20-Huck-1
33526: PPUSH
33527: CALL_OW 88
// if IsOk ( Brown ) then
33531: LD_EXP 47
33535: PPUSH
33536: CALL_OW 302
33540: IFFALSE 33554
// Say ( Brown , D20-Brown-1 ) ;
33542: LD_EXP 47
33546: PPUSH
33547: LD_STRING D20-Brown-1
33549: PPUSH
33550: CALL_OW 88
// if IsOk ( Gary ) then
33554: LD_EXP 51
33558: PPUSH
33559: CALL_OW 302
33563: IFFALSE 33577
// Say ( Gary , D20-Gary-1 ) ;
33565: LD_EXP 51
33569: PPUSH
33570: LD_STRING D20-Gary-1
33572: PPUSH
33573: CALL_OW 88
// if IsOk ( Connie ) then
33577: LD_EXP 54
33581: PPUSH
33582: CALL_OW 302
33586: IFFALSE 33600
// Say ( Connie , D20-Con-1 ) ;
33588: LD_EXP 54
33592: PPUSH
33593: LD_STRING D20-Con-1
33595: PPUSH
33596: CALL_OW 88
// if IsOk ( Kurt ) then
33600: LD_EXP 60
33604: PPUSH
33605: CALL_OW 302
33609: IFFALSE 33623
// Say ( Kurt , D20-Kurt-1 ) ;
33611: LD_EXP 60
33615: PPUSH
33616: LD_STRING D20-Kurt-1
33618: PPUSH
33619: CALL_OW 88
// if IsOk ( Kikuchi ) then
33623: LD_EXP 53
33627: PPUSH
33628: CALL_OW 302
33632: IFFALSE 33646
// Say ( Kikuchi , D20-Yam-1 ) ;
33634: LD_EXP 53
33638: PPUSH
33639: LD_STRING D20-Yam-1
33641: PPUSH
33642: CALL_OW 88
// if IsOk ( Frank ) then
33646: LD_EXP 52
33650: PPUSH
33651: CALL_OW 302
33655: IFFALSE 33669
// Say ( Frank , D20-Frank-1 ) ;
33657: LD_EXP 52
33661: PPUSH
33662: LD_STRING D20-Frank-1
33664: PPUSH
33665: CALL_OW 88
// DialogueOff ;
33669: CALL_OW 7
// if RothCaptured then
33673: LD_EXP 33
33677: IFFALSE 33699
// begin m1 := true ;
33679: LD_ADDR_VAR 0 1
33683: PUSH
33684: LD_INT 1
33686: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33687: LD_STRING Roth
33689: PPUSH
33690: LD_INT 1
33692: PPUSH
33693: CALL_OW 101
// end else
33697: GO 33710
// AddMedal ( Roth , - 1 ) ;
33699: LD_STRING Roth
33701: PPUSH
33702: LD_INT 1
33704: NEG
33705: PPUSH
33706: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33710: LD_EXP 25
33714: NOT
33715: PUSH
33716: LD_EXP 27
33720: OR
33721: IFFALSE 33743
// begin m2 := true ;
33723: LD_ADDR_VAR 0 2
33727: PUSH
33728: LD_INT 1
33730: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33731: LD_STRING Project
33733: PPUSH
33734: LD_INT 1
33736: PPUSH
33737: CALL_OW 101
// end else
33741: GO 33754
// AddMedal ( Project , - 1 ) ;
33743: LD_STRING Project
33745: PPUSH
33746: LD_INT 1
33748: NEG
33749: PPUSH
33750: CALL_OW 101
// if lostCounter = 0 then
33754: LD_EXP 32
33758: PUSH
33759: LD_INT 0
33761: EQUAL
33762: IFFALSE 33784
// begin m3 := true ;
33764: LD_ADDR_VAR 0 3
33768: PUSH
33769: LD_INT 1
33771: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33772: LD_STRING NoLosses
33774: PPUSH
33775: LD_INT 1
33777: PPUSH
33778: CALL_OW 101
// end else
33782: GO 33795
// AddMedal ( NoLosses , - 1 ) ;
33784: LD_STRING NoLosses
33786: PPUSH
33787: LD_INT 1
33789: NEG
33790: PPUSH
33791: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33795: LD_VAR 0 1
33799: PUSH
33800: LD_VAR 0 2
33804: AND
33805: PUSH
33806: LD_VAR 0 3
33810: AND
33811: PUSH
33812: LD_OWVAR 67
33816: PUSH
33817: LD_INT 3
33819: GREATEREQUAL
33820: AND
33821: IFFALSE 33833
// SetAchievementEX ( ACH_AMER , 15 ) ;
33823: LD_STRING ACH_AMER
33825: PPUSH
33826: LD_INT 15
33828: PPUSH
33829: CALL_OW 564
// GiveMedals ( MAIN ) ;
33833: LD_STRING MAIN
33835: PPUSH
33836: CALL_OW 102
// music_class := 4 ;
33840: LD_ADDR_OWVAR 72
33844: PUSH
33845: LD_INT 4
33847: ST_TO_ADDR
// music_nat := 1 ;
33848: LD_ADDR_OWVAR 71
33852: PUSH
33853: LD_INT 1
33855: ST_TO_ADDR
// YouWin ;
33856: CALL_OW 103
// end ; end_of_file
33860: PPOPN 3
33862: END
// export function CustomEvent ( event ) ; begin
33863: LD_INT 0
33865: PPUSH
// end ;
33866: LD_VAR 0 2
33870: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33871: LD_VAR 0 1
33875: PUSH
33876: LD_INT 1
33878: EQUAL
33879: PUSH
33880: LD_VAR 0 2
33884: PUSH
33885: LD_INT 4
33887: EQUAL
33888: AND
33889: PUSH
33890: LD_EXP 58
33894: PPUSH
33895: CALL_OW 300
33899: AND
33900: IFFALSE 33916
// begin wait ( 0 0$2 ) ;
33902: LD_INT 70
33904: PPUSH
33905: CALL_OW 67
// YouLost ( Dismissed ) ;
33909: LD_STRING Dismissed
33911: PPUSH
33912: CALL_OW 104
// end ; end ;
33916: PPOPN 2
33918: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33919: LD_VAR 0 2
33923: PPUSH
33924: LD_VAR 0 3
33928: PPUSH
33929: LD_INT 18
33931: PPUSH
33932: CALL_OW 309
33936: IFFALSE 33945
// YouLost ( Motherlode3 ) ;
33938: LD_STRING Motherlode3
33940: PPUSH
33941: CALL_OW 104
// end ;
33945: PPOPN 3
33947: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33948: LD_EXP 27
33952: NOT
33953: IFFALSE 33963
// behemothDone := true ;
33955: LD_ADDR_EXP 28
33959: PUSH
33960: LD_INT 1
33962: ST_TO_ADDR
// end ;
33963: PPOPN 1
33965: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33966: LD_VAR 0 1
33970: PPUSH
33971: CALL_OW 255
33975: PUSH
33976: LD_INT 1
33978: EQUAL
33979: IFFALSE 33989
// bombExploded := true ;
33981: LD_ADDR_EXP 37
33985: PUSH
33986: LD_INT 1
33988: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL_OW 255
33998: PUSH
33999: LD_INT 1
34001: EQUAL
34002: PUSH
34003: LD_EXP 30
34007: AND
34008: PUSH
34009: LD_INT 22
34011: PUSH
34012: LD_INT 3
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 34
34021: PUSH
34022: LD_INT 48
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PPUSH
34033: CALL_OW 69
34037: AND
34038: PUSH
34039: LD_INT 22
34041: PUSH
34042: LD_INT 1
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 34
34051: PUSH
34052: LD_INT 8
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PPUSH
34063: CALL_OW 69
34067: NOT
34068: AND
34069: IFFALSE 34121
// begin wait ( 0 0$5 ) ;
34071: LD_INT 175
34073: PPUSH
34074: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
34078: LD_INT 22
34080: PUSH
34081: LD_INT 3
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 34
34090: PUSH
34091: LD_INT 48
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PPUSH
34102: CALL_OW 69
34106: PUSH
34107: LD_INT 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 60
34113: PPUSH
34114: LD_INT 95
34116: PPUSH
34117: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
34121: LD_VAR 0 2
34125: PPUSH
34126: LD_VAR 0 3
34130: PPUSH
34131: LD_INT 18
34133: PPUSH
34134: CALL_OW 309
34138: IFFALSE 34185
// begin if GetSide ( unit ) = 1 then
34140: LD_VAR 0 1
34144: PPUSH
34145: CALL_OW 255
34149: PUSH
34150: LD_INT 1
34152: EQUAL
34153: IFFALSE 34171
// begin wait ( 0 0$6 ) ;
34155: LD_INT 210
34157: PPUSH
34158: CALL_OW 67
// YouLost ( Motherlode2 ) ;
34162: LD_STRING Motherlode2
34164: PPUSH
34165: CALL_OW 104
// end else
34169: GO 34185
// begin wait ( 0 0$6 ) ;
34171: LD_INT 210
34173: PPUSH
34174: CALL_OW 67
// YouLost ( Motherlode1 ) ;
34178: LD_STRING Motherlode1
34180: PPUSH
34181: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
34185: LD_VAR 0 1
34189: PPUSH
34190: CALL_OW 255
34194: PUSH
34195: LD_INT 3
34197: EQUAL
34198: IFFALSE 34219
// begin wait ( 0 0$5 ) ;
34200: LD_INT 175
34202: PPUSH
34203: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
34207: LD_EXP 64
34211: PPUSH
34212: LD_STRING D18-Pla-1
34214: PPUSH
34215: CALL_OW 94
// end ; end ;
34219: PPOPN 3
34221: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
34222: LD_VAR 0 1
34226: PPUSH
34227: CALL 122930 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
34231: LD_VAR 0 1
34235: PUSH
34236: LD_INT 22
34238: PUSH
34239: LD_INT 1
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 21
34248: PUSH
34249: LD_INT 1
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 23
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: LIST
34270: PPUSH
34271: CALL_OW 69
34275: IN
34276: IFFALSE 34292
// lostCounter := lostCounter + 1 ;
34278: LD_ADDR_EXP 32
34282: PUSH
34283: LD_EXP 32
34287: PUSH
34288: LD_INT 1
34290: PLUS
34291: ST_TO_ADDR
// if un in behemothBuilders then
34292: LD_VAR 0 1
34296: PUSH
34297: LD_EXP 73
34301: IN
34302: IFFALSE 34322
// begin behemothBuilders := behemothBuilders diff un ;
34304: LD_ADDR_EXP 73
34308: PUSH
34309: LD_EXP 73
34313: PUSH
34314: LD_VAR 0 1
34318: DIFF
34319: ST_TO_ADDR
// exit ;
34320: GO 34352
// end ; if un = JMM then
34322: LD_VAR 0 1
34326: PUSH
34327: LD_EXP 39
34331: EQUAL
34332: IFFALSE 34343
// begin YouLost ( JMM ) ;
34334: LD_STRING JMM
34336: PPUSH
34337: CALL_OW 104
// exit ;
34341: GO 34352
// end ; MCE_UnitDestroyed ( un ) ;
34343: LD_VAR 0 1
34347: PPUSH
34348: CALL 63039 0 1
// end ;
34352: PPOPN 1
34354: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34355: LD_VAR 0 1
34359: PPUSH
34360: LD_VAR 0 2
34364: PPUSH
34365: CALL 65371 0 2
// end ;
34369: PPOPN 2
34371: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34372: LD_VAR 0 1
34376: PPUSH
34377: CALL 64439 0 1
// end ;
34381: PPOPN 1
34383: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34384: LD_VAR 0 1
34388: PUSH
34389: LD_INT 22
34391: PUSH
34392: LD_INT 8
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 30
34401: PUSH
34402: LD_INT 2
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 23
34411: PUSH
34412: LD_INT 3
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: LIST
34423: PPUSH
34424: CALL_OW 69
34428: IN
34429: IFFALSE 34456
// begin ComUpgrade ( building ) ;
34431: LD_VAR 0 1
34435: PPUSH
34436: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34440: LD_EXP 61
34444: PPUSH
34445: LD_VAR 0 1
34449: PPUSH
34450: CALL 74021 0 2
// exit ;
34454: GO 34465
// end ; MCE_BuildingComplete ( building ) ;
34456: LD_VAR 0 1
34460: PPUSH
34461: CALL 64680 0 1
// end ;
34465: PPOPN 1
34467: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34468: LD_VAR 0 1
34472: PPUSH
34473: LD_VAR 0 2
34477: PPUSH
34478: CALL 62735 0 2
// end ;
34482: PPOPN 2
34484: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34485: LD_VAR 0 1
34489: PPUSH
34490: LD_VAR 0 2
34494: PPUSH
34495: LD_VAR 0 3
34499: PPUSH
34500: LD_VAR 0 4
34504: PPUSH
34505: LD_VAR 0 5
34509: PPUSH
34510: CALL 62355 0 5
// end ;
34514: PPOPN 5
34516: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
34517: LD_VAR 0 1
34521: PPUSH
34522: LD_VAR 0 2
34526: PPUSH
34527: CALL 123050 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
34531: LD_VAR 0 1
34535: PPUSH
34536: LD_VAR 0 2
34540: PPUSH
34541: CALL 61946 0 2
// end ;
34545: PPOPN 2
34547: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34548: LD_VAR 0 1
34552: PPUSH
34553: LD_VAR 0 2
34557: PPUSH
34558: LD_VAR 0 3
34562: PPUSH
34563: LD_VAR 0 4
34567: PPUSH
34568: CALL 61784 0 4
// end ;
34572: PPOPN 4
34574: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34575: LD_VAR 0 1
34579: PPUSH
34580: LD_VAR 0 2
34584: PPUSH
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL 61559 0 3
// end ;
34594: PPOPN 3
34596: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34597: LD_VAR 0 1
34601: PPUSH
34602: LD_VAR 0 2
34606: PPUSH
34607: CALL 61444 0 2
// end ;
34611: PPOPN 2
34613: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34614: LD_VAR 0 1
34618: PPUSH
34619: LD_VAR 0 2
34623: PPUSH
34624: CALL 65666 0 2
// end ;
34628: PPOPN 2
34630: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34631: LD_VAR 0 1
34635: PPUSH
34636: CALL_OW 255
34640: PUSH
34641: LD_INT 4
34643: EQUAL
34644: PUSH
34645: LD_VAR 0 1
34649: PUSH
34650: LD_EXP 18
34654: PUSH
34655: LD_INT 1
34657: ARRAY
34658: IN
34659: AND
34660: PUSH
34661: LD_EXP 19
34665: AND
34666: IFFALSE 34685
// begin ComMoveXY ( driver , 61 , 93 ) ;
34668: LD_VAR 0 1
34672: PPUSH
34673: LD_INT 61
34675: PPUSH
34676: LD_INT 93
34678: PPUSH
34679: CALL_OW 111
// exit ;
34683: GO 34709
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34685: LD_VAR 0 1
34689: PPUSH
34690: LD_VAR 0 2
34694: PPUSH
34695: LD_VAR 0 3
34699: PPUSH
34700: LD_VAR 0 4
34704: PPUSH
34705: CALL 65882 0 4
// end ;
34709: PPOPN 4
34711: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34712: LD_VAR 0 1
34716: PPUSH
34717: LD_VAR 0 2
34721: PPUSH
34722: CALL 61253 0 2
// end ;
34726: PPOPN 2
34728: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34729: LD_VAR 0 1
34733: PPUSH
34734: CALL 123034 0 1
// end ; end_of_file
34738: PPOPN 1
34740: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34741: LD_EXP 15
34745: PUSH
34746: LD_INT 2
34748: EQUAL
34749: IFFALSE 35232
34751: GO 34753
34753: DISABLE
34754: LD_INT 0
34756: PPUSH
// begin time := 0 0$40 ;
34757: LD_ADDR_VAR 0 1
34761: PUSH
34762: LD_INT 1400
34764: ST_TO_ADDR
// repeat wait ( time ) ;
34765: LD_VAR 0 1
34769: PPUSH
34770: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34774: LD_INT 1
34776: PPUSH
34777: LD_INT 5
34779: PPUSH
34780: CALL_OW 12
34784: PPUSH
34785: LD_INT 106
34787: PPUSH
34788: LD_INT 150
34790: PPUSH
34791: LD_INT 19
34793: PPUSH
34794: LD_INT 1
34796: PPUSH
34797: CALL_OW 56
// time := time + 0 0$9 ;
34801: LD_ADDR_VAR 0 1
34805: PUSH
34806: LD_VAR 0 1
34810: PUSH
34811: LD_INT 315
34813: PLUS
34814: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34815: LD_INT 455
34817: PPUSH
34818: LD_INT 840
34820: PPUSH
34821: CALL_OW 12
34825: PPUSH
34826: CALL_OW 67
// if Prob ( 50 ) then
34830: LD_INT 50
34832: PPUSH
34833: CALL_OW 13
34837: IFFALSE 34866
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34839: LD_INT 1
34841: PPUSH
34842: LD_INT 5
34844: PPUSH
34845: CALL_OW 12
34849: PPUSH
34850: LD_INT 62
34852: PPUSH
34853: LD_INT 108
34855: PPUSH
34856: LD_INT 10
34858: PPUSH
34859: LD_INT 1
34861: PPUSH
34862: CALL_OW 56
// until missionStage > 4 ;
34866: LD_EXP 15
34870: PUSH
34871: LD_INT 4
34873: GREATER
34874: IFFALSE 34765
// repeat wait ( 0 0$1 ) ;
34876: LD_INT 35
34878: PPUSH
34879: CALL_OW 67
// until missionStage = 6 ;
34883: LD_EXP 15
34887: PUSH
34888: LD_INT 6
34890: EQUAL
34891: IFFALSE 34876
// time := 0 0$50 ;
34893: LD_ADDR_VAR 0 1
34897: PUSH
34898: LD_INT 1750
34900: ST_TO_ADDR
// repeat wait ( time ) ;
34901: LD_VAR 0 1
34905: PPUSH
34906: CALL_OW 67
// if Prob ( 50 ) then
34910: LD_INT 50
34912: PPUSH
34913: CALL_OW 13
34917: IFFALSE 34946
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34919: LD_INT 1
34921: PPUSH
34922: LD_INT 5
34924: PPUSH
34925: CALL_OW 12
34929: PPUSH
34930: LD_INT 106
34932: PPUSH
34933: LD_INT 89
34935: PPUSH
34936: LD_INT 45
34938: PPUSH
34939: LD_INT 1
34941: PPUSH
34942: CALL_OW 56
// time := time + 0 0$2 ;
34946: LD_ADDR_VAR 0 1
34950: PUSH
34951: LD_VAR 0 1
34955: PUSH
34956: LD_INT 70
34958: PLUS
34959: ST_TO_ADDR
// if Prob ( 30 ) then
34960: LD_INT 30
34962: PPUSH
34963: CALL_OW 13
34967: IFFALSE 35013
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34969: LD_INT 385
34971: PPUSH
34972: LD_INT 945
34974: PPUSH
34975: CALL_OW 12
34979: PPUSH
34980: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34984: LD_INT 1
34986: PPUSH
34987: LD_INT 5
34989: PPUSH
34990: CALL_OW 12
34994: PPUSH
34995: LD_INT 21
34997: PPUSH
34998: LD_INT 26
35000: PPUSH
35001: LD_INT 12
35003: PPUSH
35004: LD_INT 1
35006: PPUSH
35007: CALL_OW 56
// end else
35011: GO 35049
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
35013: LD_INT 700
35015: PPUSH
35016: LD_INT 1225
35018: PPUSH
35019: CALL_OW 12
35023: PPUSH
35024: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
35028: LD_INT 1
35030: PPUSH
35031: LD_INT 5
35033: PPUSH
35034: CALL_OW 12
35038: PPUSH
35039: LD_INT 16
35041: PPUSH
35042: LD_INT 1
35044: PPUSH
35045: CALL_OW 55
// end ; if Prob ( 50 ) then
35049: LD_INT 50
35051: PPUSH
35052: CALL_OW 13
35056: IFFALSE 35102
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
35058: LD_INT 700
35060: PPUSH
35061: LD_INT 1050
35063: PPUSH
35064: CALL_OW 12
35068: PPUSH
35069: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
35073: LD_INT 1
35075: PPUSH
35076: LD_INT 5
35078: PPUSH
35079: CALL_OW 12
35083: PPUSH
35084: LD_INT 181
35086: PPUSH
35087: LD_INT 218
35089: PPUSH
35090: LD_INT 16
35092: PPUSH
35093: LD_INT 1
35095: PPUSH
35096: CALL_OW 56
// end else
35100: GO 35138
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
35102: LD_INT 350
35104: PPUSH
35105: LD_INT 525
35107: PPUSH
35108: CALL_OW 12
35112: PPUSH
35113: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
35117: LD_INT 1
35119: PPUSH
35120: LD_INT 5
35122: PPUSH
35123: CALL_OW 12
35127: PPUSH
35128: LD_INT 15
35130: PPUSH
35131: LD_INT 1
35133: PPUSH
35134: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
35138: LD_INT 45
35140: PUSH
35141: LD_INT 32
35143: PUSH
35144: LD_INT 25
35146: PUSH
35147: LD_INT 22
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: PUSH
35156: LD_OWVAR 67
35160: ARRAY
35161: PPUSH
35162: CALL_OW 13
35166: IFFALSE 35210
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
35168: LD_INT 175
35170: PPUSH
35171: LD_INT 315
35173: PPUSH
35174: CALL_OW 12
35178: PPUSH
35179: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
35183: LD_INT 1
35185: PPUSH
35186: LD_INT 5
35188: PPUSH
35189: CALL_OW 12
35193: PPUSH
35194: LD_INT 103
35196: PPUSH
35197: LD_INT 140
35199: PPUSH
35200: LD_INT 20
35202: PPUSH
35203: LD_INT 1
35205: PPUSH
35206: CALL_OW 56
// end ; if time > 1 1$20 then
35210: LD_VAR 0 1
35214: PUSH
35215: LD_INT 2800
35217: GREATER
35218: IFFALSE 35228
// time := 0 0$30 ;
35220: LD_ADDR_VAR 0 1
35224: PUSH
35225: LD_INT 1050
35227: ST_TO_ADDR
// until false ;
35228: LD_INT 0
35230: IFFALSE 34901
// end ; end_of_file
35232: PPOPN 1
35234: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
35235: LD_EXP 13
35239: PUSH
35240: LD_EXP 15
35244: PUSH
35245: LD_INT 6
35247: GREATEREQUAL
35248: AND
35249: IFFALSE 35286
35251: GO 35253
35253: DISABLE
// begin enable ;
35254: ENABLE
// missionTime := missionTime + 0 0$1 ;
35255: LD_ADDR_EXP 14
35259: PUSH
35260: LD_EXP 14
35264: PUSH
35265: LD_INT 35
35267: PLUS
35268: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
35269: LD_ADDR_OWVAR 47
35273: PUSH
35274: LD_STRING #Am15-1
35276: PUSH
35277: LD_EXP 14
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: ST_TO_ADDR
// end ; end_of_file
35286: END
// export function InitNature ; begin
35287: LD_INT 0
35289: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
35290: LD_INT 3
35292: PPUSH
35293: LD_INT 3
35295: PPUSH
35296: LD_INT 2
35298: PPUSH
35299: LD_INT 1
35301: PPUSH
35302: LD_INT 1
35304: PPUSH
35305: LD_INT 0
35307: PPUSH
35308: LD_INT 0
35310: PPUSH
35311: LD_INT 20
35313: PPUSH
35314: LD_INT 0
35316: PPUSH
35317: CALL 100154 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
35321: LD_INT 2
35323: PPUSH
35324: LD_INT 1
35326: PPUSH
35327: LD_INT 1
35329: PPUSH
35330: LD_INT 1
35332: PPUSH
35333: LD_INT 1
35335: PPUSH
35336: LD_INT 0
35338: PPUSH
35339: LD_INT 0
35341: PPUSH
35342: LD_INT 21
35344: PPUSH
35345: LD_INT 0
35347: PPUSH
35348: CALL 100154 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35352: LD_INT 4
35354: PPUSH
35355: LD_INT 1
35357: PPUSH
35358: LD_INT 2
35360: PPUSH
35361: LD_INT 4
35363: PPUSH
35364: LD_INT 2
35366: PPUSH
35367: LD_INT 1
35369: PPUSH
35370: LD_INT 0
35372: PPUSH
35373: LD_INT 22
35375: PPUSH
35376: LD_INT 0
35378: PPUSH
35379: CALL 100154 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35383: LD_INT 0
35385: PPUSH
35386: LD_INT 0
35388: PPUSH
35389: LD_INT 0
35391: PPUSH
35392: LD_INT 0
35394: PPUSH
35395: LD_INT 0
35397: PPUSH
35398: LD_INT 0
35400: PPUSH
35401: LD_INT 9
35403: PPUSH
35404: LD_INT 0
35406: PPUSH
35407: LD_INT 23
35409: PPUSH
35410: CALL 100154 0 9
// end ; end_of_file
35414: LD_VAR 0 1
35418: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35419: LD_INT 0
35421: PPUSH
35422: PPUSH
// skirmish := false ;
35423: LD_ADDR_EXP 95
35427: PUSH
35428: LD_INT 0
35430: ST_TO_ADDR
// debug_mc := false ;
35431: LD_ADDR_EXP 96
35435: PUSH
35436: LD_INT 0
35438: ST_TO_ADDR
// mc_bases := [ ] ;
35439: LD_ADDR_EXP 97
35443: PUSH
35444: EMPTY
35445: ST_TO_ADDR
// mc_sides := [ ] ;
35446: LD_ADDR_EXP 123
35450: PUSH
35451: EMPTY
35452: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35453: LD_ADDR_EXP 98
35457: PUSH
35458: EMPTY
35459: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35460: LD_ADDR_EXP 99
35464: PUSH
35465: EMPTY
35466: ST_TO_ADDR
// mc_need_heal := [ ] ;
35467: LD_ADDR_EXP 100
35471: PUSH
35472: EMPTY
35473: ST_TO_ADDR
// mc_healers := [ ] ;
35474: LD_ADDR_EXP 101
35478: PUSH
35479: EMPTY
35480: ST_TO_ADDR
// mc_build_list := [ ] ;
35481: LD_ADDR_EXP 102
35485: PUSH
35486: EMPTY
35487: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35488: LD_ADDR_EXP 129
35492: PUSH
35493: EMPTY
35494: ST_TO_ADDR
// mc_builders := [ ] ;
35495: LD_ADDR_EXP 103
35499: PUSH
35500: EMPTY
35501: ST_TO_ADDR
// mc_construct_list := [ ] ;
35502: LD_ADDR_EXP 104
35506: PUSH
35507: EMPTY
35508: ST_TO_ADDR
// mc_turret_list := [ ] ;
35509: LD_ADDR_EXP 105
35513: PUSH
35514: EMPTY
35515: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35516: LD_ADDR_EXP 106
35520: PUSH
35521: EMPTY
35522: ST_TO_ADDR
// mc_miners := [ ] ;
35523: LD_ADDR_EXP 111
35527: PUSH
35528: EMPTY
35529: ST_TO_ADDR
// mc_mines := [ ] ;
35530: LD_ADDR_EXP 110
35534: PUSH
35535: EMPTY
35536: ST_TO_ADDR
// mc_minefields := [ ] ;
35537: LD_ADDR_EXP 112
35541: PUSH
35542: EMPTY
35543: ST_TO_ADDR
// mc_crates := [ ] ;
35544: LD_ADDR_EXP 113
35548: PUSH
35549: EMPTY
35550: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35551: LD_ADDR_EXP 114
35555: PUSH
35556: EMPTY
35557: ST_TO_ADDR
// mc_crates_area := [ ] ;
35558: LD_ADDR_EXP 115
35562: PUSH
35563: EMPTY
35564: ST_TO_ADDR
// mc_vehicles := [ ] ;
35565: LD_ADDR_EXP 116
35569: PUSH
35570: EMPTY
35571: ST_TO_ADDR
// mc_attack := [ ] ;
35572: LD_ADDR_EXP 117
35576: PUSH
35577: EMPTY
35578: ST_TO_ADDR
// mc_produce := [ ] ;
35579: LD_ADDR_EXP 118
35583: PUSH
35584: EMPTY
35585: ST_TO_ADDR
// mc_defender := [ ] ;
35586: LD_ADDR_EXP 119
35590: PUSH
35591: EMPTY
35592: ST_TO_ADDR
// mc_parking := [ ] ;
35593: LD_ADDR_EXP 121
35597: PUSH
35598: EMPTY
35599: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35600: LD_ADDR_EXP 107
35604: PUSH
35605: EMPTY
35606: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35607: LD_ADDR_EXP 109
35611: PUSH
35612: EMPTY
35613: ST_TO_ADDR
// mc_scan := [ ] ;
35614: LD_ADDR_EXP 120
35618: PUSH
35619: EMPTY
35620: ST_TO_ADDR
// mc_scan_area := [ ] ;
35621: LD_ADDR_EXP 122
35625: PUSH
35626: EMPTY
35627: ST_TO_ADDR
// mc_tech := [ ] ;
35628: LD_ADDR_EXP 124
35632: PUSH
35633: EMPTY
35634: ST_TO_ADDR
// mc_class := [ ] ;
35635: LD_ADDR_EXP 138
35639: PUSH
35640: EMPTY
35641: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35642: LD_ADDR_EXP 139
35646: PUSH
35647: EMPTY
35648: ST_TO_ADDR
// mc_is_defending := [ ] ;
35649: LD_ADDR_EXP 140
35653: PUSH
35654: EMPTY
35655: ST_TO_ADDR
// end ;
35656: LD_VAR 0 1
35660: RET
// export function MC_Kill ( base ) ; begin
35661: LD_INT 0
35663: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35664: LD_ADDR_EXP 97
35668: PUSH
35669: LD_EXP 97
35673: PPUSH
35674: LD_VAR 0 1
35678: PPUSH
35679: EMPTY
35680: PPUSH
35681: CALL_OW 1
35685: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35686: LD_ADDR_EXP 98
35690: PUSH
35691: LD_EXP 98
35695: PPUSH
35696: LD_VAR 0 1
35700: PPUSH
35701: EMPTY
35702: PPUSH
35703: CALL_OW 1
35707: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35708: LD_ADDR_EXP 99
35712: PUSH
35713: LD_EXP 99
35717: PPUSH
35718: LD_VAR 0 1
35722: PPUSH
35723: EMPTY
35724: PPUSH
35725: CALL_OW 1
35729: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35730: LD_ADDR_EXP 100
35734: PUSH
35735: LD_EXP 100
35739: PPUSH
35740: LD_VAR 0 1
35744: PPUSH
35745: EMPTY
35746: PPUSH
35747: CALL_OW 1
35751: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35752: LD_ADDR_EXP 101
35756: PUSH
35757: LD_EXP 101
35761: PPUSH
35762: LD_VAR 0 1
35766: PPUSH
35767: EMPTY
35768: PPUSH
35769: CALL_OW 1
35773: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35774: LD_ADDR_EXP 102
35778: PUSH
35779: LD_EXP 102
35783: PPUSH
35784: LD_VAR 0 1
35788: PPUSH
35789: EMPTY
35790: PPUSH
35791: CALL_OW 1
35795: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35796: LD_ADDR_EXP 103
35800: PUSH
35801: LD_EXP 103
35805: PPUSH
35806: LD_VAR 0 1
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35818: LD_ADDR_EXP 104
35822: PUSH
35823: LD_EXP 104
35827: PPUSH
35828: LD_VAR 0 1
35832: PPUSH
35833: EMPTY
35834: PPUSH
35835: CALL_OW 1
35839: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35840: LD_ADDR_EXP 105
35844: PUSH
35845: LD_EXP 105
35849: PPUSH
35850: LD_VAR 0 1
35854: PPUSH
35855: EMPTY
35856: PPUSH
35857: CALL_OW 1
35861: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35862: LD_ADDR_EXP 106
35866: PUSH
35867: LD_EXP 106
35871: PPUSH
35872: LD_VAR 0 1
35876: PPUSH
35877: EMPTY
35878: PPUSH
35879: CALL_OW 1
35883: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35884: LD_ADDR_EXP 107
35888: PUSH
35889: LD_EXP 107
35893: PPUSH
35894: LD_VAR 0 1
35898: PPUSH
35899: EMPTY
35900: PPUSH
35901: CALL_OW 1
35905: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35906: LD_ADDR_EXP 108
35910: PUSH
35911: LD_EXP 108
35915: PPUSH
35916: LD_VAR 0 1
35920: PPUSH
35921: LD_INT 0
35923: PPUSH
35924: CALL_OW 1
35928: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35929: LD_ADDR_EXP 109
35933: PUSH
35934: LD_EXP 109
35938: PPUSH
35939: LD_VAR 0 1
35943: PPUSH
35944: EMPTY
35945: PPUSH
35946: CALL_OW 1
35950: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35951: LD_ADDR_EXP 110
35955: PUSH
35956: LD_EXP 110
35960: PPUSH
35961: LD_VAR 0 1
35965: PPUSH
35966: EMPTY
35967: PPUSH
35968: CALL_OW 1
35972: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35973: LD_ADDR_EXP 111
35977: PUSH
35978: LD_EXP 111
35982: PPUSH
35983: LD_VAR 0 1
35987: PPUSH
35988: EMPTY
35989: PPUSH
35990: CALL_OW 1
35994: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35995: LD_ADDR_EXP 112
35999: PUSH
36000: LD_EXP 112
36004: PPUSH
36005: LD_VAR 0 1
36009: PPUSH
36010: EMPTY
36011: PPUSH
36012: CALL_OW 1
36016: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36017: LD_ADDR_EXP 113
36021: PUSH
36022: LD_EXP 113
36026: PPUSH
36027: LD_VAR 0 1
36031: PPUSH
36032: EMPTY
36033: PPUSH
36034: CALL_OW 1
36038: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36039: LD_ADDR_EXP 114
36043: PUSH
36044: LD_EXP 114
36048: PPUSH
36049: LD_VAR 0 1
36053: PPUSH
36054: EMPTY
36055: PPUSH
36056: CALL_OW 1
36060: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36061: LD_ADDR_EXP 115
36065: PUSH
36066: LD_EXP 115
36070: PPUSH
36071: LD_VAR 0 1
36075: PPUSH
36076: EMPTY
36077: PPUSH
36078: CALL_OW 1
36082: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36083: LD_ADDR_EXP 116
36087: PUSH
36088: LD_EXP 116
36092: PPUSH
36093: LD_VAR 0 1
36097: PPUSH
36098: EMPTY
36099: PPUSH
36100: CALL_OW 1
36104: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36105: LD_ADDR_EXP 117
36109: PUSH
36110: LD_EXP 117
36114: PPUSH
36115: LD_VAR 0 1
36119: PPUSH
36120: EMPTY
36121: PPUSH
36122: CALL_OW 1
36126: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36127: LD_ADDR_EXP 118
36131: PUSH
36132: LD_EXP 118
36136: PPUSH
36137: LD_VAR 0 1
36141: PPUSH
36142: EMPTY
36143: PPUSH
36144: CALL_OW 1
36148: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36149: LD_ADDR_EXP 119
36153: PUSH
36154: LD_EXP 119
36158: PPUSH
36159: LD_VAR 0 1
36163: PPUSH
36164: EMPTY
36165: PPUSH
36166: CALL_OW 1
36170: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36171: LD_ADDR_EXP 120
36175: PUSH
36176: LD_EXP 120
36180: PPUSH
36181: LD_VAR 0 1
36185: PPUSH
36186: EMPTY
36187: PPUSH
36188: CALL_OW 1
36192: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36193: LD_ADDR_EXP 121
36197: PUSH
36198: LD_EXP 121
36202: PPUSH
36203: LD_VAR 0 1
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL_OW 1
36214: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36215: LD_ADDR_EXP 122
36219: PUSH
36220: LD_EXP 122
36224: PPUSH
36225: LD_VAR 0 1
36229: PPUSH
36230: EMPTY
36231: PPUSH
36232: CALL_OW 1
36236: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36237: LD_ADDR_EXP 124
36241: PUSH
36242: LD_EXP 124
36246: PPUSH
36247: LD_VAR 0 1
36251: PPUSH
36252: EMPTY
36253: PPUSH
36254: CALL_OW 1
36258: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36259: LD_ADDR_EXP 126
36263: PUSH
36264: LD_EXP 126
36268: PPUSH
36269: LD_VAR 0 1
36273: PPUSH
36274: EMPTY
36275: PPUSH
36276: CALL_OW 1
36280: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36281: LD_ADDR_EXP 127
36285: PUSH
36286: LD_EXP 127
36290: PPUSH
36291: LD_VAR 0 1
36295: PPUSH
36296: EMPTY
36297: PPUSH
36298: CALL_OW 1
36302: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36303: LD_ADDR_EXP 128
36307: PUSH
36308: LD_EXP 128
36312: PPUSH
36313: LD_VAR 0 1
36317: PPUSH
36318: EMPTY
36319: PPUSH
36320: CALL_OW 1
36324: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36325: LD_ADDR_EXP 129
36329: PUSH
36330: LD_EXP 129
36334: PPUSH
36335: LD_VAR 0 1
36339: PPUSH
36340: EMPTY
36341: PPUSH
36342: CALL_OW 1
36346: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36347: LD_ADDR_EXP 130
36351: PUSH
36352: LD_EXP 130
36356: PPUSH
36357: LD_VAR 0 1
36361: PPUSH
36362: EMPTY
36363: PPUSH
36364: CALL_OW 1
36368: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36369: LD_ADDR_EXP 131
36373: PUSH
36374: LD_EXP 131
36378: PPUSH
36379: LD_VAR 0 1
36383: PPUSH
36384: EMPTY
36385: PPUSH
36386: CALL_OW 1
36390: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36391: LD_ADDR_EXP 132
36395: PUSH
36396: LD_EXP 132
36400: PPUSH
36401: LD_VAR 0 1
36405: PPUSH
36406: EMPTY
36407: PPUSH
36408: CALL_OW 1
36412: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36413: LD_ADDR_EXP 133
36417: PUSH
36418: LD_EXP 133
36422: PPUSH
36423: LD_VAR 0 1
36427: PPUSH
36428: EMPTY
36429: PPUSH
36430: CALL_OW 1
36434: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36435: LD_ADDR_EXP 134
36439: PUSH
36440: LD_EXP 134
36444: PPUSH
36445: LD_VAR 0 1
36449: PPUSH
36450: EMPTY
36451: PPUSH
36452: CALL_OW 1
36456: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36457: LD_ADDR_EXP 135
36461: PUSH
36462: LD_EXP 135
36466: PPUSH
36467: LD_VAR 0 1
36471: PPUSH
36472: EMPTY
36473: PPUSH
36474: CALL_OW 1
36478: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36479: LD_ADDR_EXP 136
36483: PUSH
36484: LD_EXP 136
36488: PPUSH
36489: LD_VAR 0 1
36493: PPUSH
36494: EMPTY
36495: PPUSH
36496: CALL_OW 1
36500: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36501: LD_ADDR_EXP 137
36505: PUSH
36506: LD_EXP 137
36510: PPUSH
36511: LD_VAR 0 1
36515: PPUSH
36516: EMPTY
36517: PPUSH
36518: CALL_OW 1
36522: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36523: LD_ADDR_EXP 138
36527: PUSH
36528: LD_EXP 138
36532: PPUSH
36533: LD_VAR 0 1
36537: PPUSH
36538: EMPTY
36539: PPUSH
36540: CALL_OW 1
36544: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36545: LD_ADDR_EXP 139
36549: PUSH
36550: LD_EXP 139
36554: PPUSH
36555: LD_VAR 0 1
36559: PPUSH
36560: LD_INT 0
36562: PPUSH
36563: CALL_OW 1
36567: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36568: LD_ADDR_EXP 140
36572: PUSH
36573: LD_EXP 140
36577: PPUSH
36578: LD_VAR 0 1
36582: PPUSH
36583: LD_INT 0
36585: PPUSH
36586: CALL_OW 1
36590: ST_TO_ADDR
// end ;
36591: LD_VAR 0 2
36595: RET
// export function MC_Add ( side , units ) ; var base ; begin
36596: LD_INT 0
36598: PPUSH
36599: PPUSH
// base := mc_bases + 1 ;
36600: LD_ADDR_VAR 0 4
36604: PUSH
36605: LD_EXP 97
36609: PUSH
36610: LD_INT 1
36612: PLUS
36613: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36614: LD_ADDR_EXP 123
36618: PUSH
36619: LD_EXP 123
36623: PPUSH
36624: LD_VAR 0 4
36628: PPUSH
36629: LD_VAR 0 1
36633: PPUSH
36634: CALL_OW 1
36638: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36639: LD_ADDR_EXP 97
36643: PUSH
36644: LD_EXP 97
36648: PPUSH
36649: LD_VAR 0 4
36653: PPUSH
36654: LD_VAR 0 2
36658: PPUSH
36659: CALL_OW 1
36663: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36664: LD_ADDR_EXP 98
36668: PUSH
36669: LD_EXP 98
36673: PPUSH
36674: LD_VAR 0 4
36678: PPUSH
36679: EMPTY
36680: PPUSH
36681: CALL_OW 1
36685: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36686: LD_ADDR_EXP 99
36690: PUSH
36691: LD_EXP 99
36695: PPUSH
36696: LD_VAR 0 4
36700: PPUSH
36701: EMPTY
36702: PPUSH
36703: CALL_OW 1
36707: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36708: LD_ADDR_EXP 100
36712: PUSH
36713: LD_EXP 100
36717: PPUSH
36718: LD_VAR 0 4
36722: PPUSH
36723: EMPTY
36724: PPUSH
36725: CALL_OW 1
36729: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36730: LD_ADDR_EXP 101
36734: PUSH
36735: LD_EXP 101
36739: PPUSH
36740: LD_VAR 0 4
36744: PPUSH
36745: EMPTY
36746: PPUSH
36747: CALL_OW 1
36751: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36752: LD_ADDR_EXP 102
36756: PUSH
36757: LD_EXP 102
36761: PPUSH
36762: LD_VAR 0 4
36766: PPUSH
36767: EMPTY
36768: PPUSH
36769: CALL_OW 1
36773: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36774: LD_ADDR_EXP 103
36778: PUSH
36779: LD_EXP 103
36783: PPUSH
36784: LD_VAR 0 4
36788: PPUSH
36789: EMPTY
36790: PPUSH
36791: CALL_OW 1
36795: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36796: LD_ADDR_EXP 104
36800: PUSH
36801: LD_EXP 104
36805: PPUSH
36806: LD_VAR 0 4
36810: PPUSH
36811: EMPTY
36812: PPUSH
36813: CALL_OW 1
36817: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36818: LD_ADDR_EXP 105
36822: PUSH
36823: LD_EXP 105
36827: PPUSH
36828: LD_VAR 0 4
36832: PPUSH
36833: EMPTY
36834: PPUSH
36835: CALL_OW 1
36839: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36840: LD_ADDR_EXP 106
36844: PUSH
36845: LD_EXP 106
36849: PPUSH
36850: LD_VAR 0 4
36854: PPUSH
36855: EMPTY
36856: PPUSH
36857: CALL_OW 1
36861: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36862: LD_ADDR_EXP 107
36866: PUSH
36867: LD_EXP 107
36871: PPUSH
36872: LD_VAR 0 4
36876: PPUSH
36877: EMPTY
36878: PPUSH
36879: CALL_OW 1
36883: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36884: LD_ADDR_EXP 108
36888: PUSH
36889: LD_EXP 108
36893: PPUSH
36894: LD_VAR 0 4
36898: PPUSH
36899: LD_INT 0
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36907: LD_ADDR_EXP 109
36911: PUSH
36912: LD_EXP 109
36916: PPUSH
36917: LD_VAR 0 4
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36929: LD_ADDR_EXP 110
36933: PUSH
36934: LD_EXP 110
36938: PPUSH
36939: LD_VAR 0 4
36943: PPUSH
36944: EMPTY
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36951: LD_ADDR_EXP 111
36955: PUSH
36956: LD_EXP 111
36960: PPUSH
36961: LD_VAR 0 4
36965: PPUSH
36966: EMPTY
36967: PPUSH
36968: CALL_OW 1
36972: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36973: LD_ADDR_EXP 112
36977: PUSH
36978: LD_EXP 112
36982: PPUSH
36983: LD_VAR 0 4
36987: PPUSH
36988: EMPTY
36989: PPUSH
36990: CALL_OW 1
36994: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36995: LD_ADDR_EXP 113
36999: PUSH
37000: LD_EXP 113
37004: PPUSH
37005: LD_VAR 0 4
37009: PPUSH
37010: EMPTY
37011: PPUSH
37012: CALL_OW 1
37016: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37017: LD_ADDR_EXP 114
37021: PUSH
37022: LD_EXP 114
37026: PPUSH
37027: LD_VAR 0 4
37031: PPUSH
37032: EMPTY
37033: PPUSH
37034: CALL_OW 1
37038: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37039: LD_ADDR_EXP 115
37043: PUSH
37044: LD_EXP 115
37048: PPUSH
37049: LD_VAR 0 4
37053: PPUSH
37054: EMPTY
37055: PPUSH
37056: CALL_OW 1
37060: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37061: LD_ADDR_EXP 116
37065: PUSH
37066: LD_EXP 116
37070: PPUSH
37071: LD_VAR 0 4
37075: PPUSH
37076: EMPTY
37077: PPUSH
37078: CALL_OW 1
37082: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37083: LD_ADDR_EXP 117
37087: PUSH
37088: LD_EXP 117
37092: PPUSH
37093: LD_VAR 0 4
37097: PPUSH
37098: EMPTY
37099: PPUSH
37100: CALL_OW 1
37104: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37105: LD_ADDR_EXP 118
37109: PUSH
37110: LD_EXP 118
37114: PPUSH
37115: LD_VAR 0 4
37119: PPUSH
37120: EMPTY
37121: PPUSH
37122: CALL_OW 1
37126: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37127: LD_ADDR_EXP 119
37131: PUSH
37132: LD_EXP 119
37136: PPUSH
37137: LD_VAR 0 4
37141: PPUSH
37142: EMPTY
37143: PPUSH
37144: CALL_OW 1
37148: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37149: LD_ADDR_EXP 120
37153: PUSH
37154: LD_EXP 120
37158: PPUSH
37159: LD_VAR 0 4
37163: PPUSH
37164: EMPTY
37165: PPUSH
37166: CALL_OW 1
37170: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37171: LD_ADDR_EXP 121
37175: PUSH
37176: LD_EXP 121
37180: PPUSH
37181: LD_VAR 0 4
37185: PPUSH
37186: EMPTY
37187: PPUSH
37188: CALL_OW 1
37192: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37193: LD_ADDR_EXP 122
37197: PUSH
37198: LD_EXP 122
37202: PPUSH
37203: LD_VAR 0 4
37207: PPUSH
37208: EMPTY
37209: PPUSH
37210: CALL_OW 1
37214: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37215: LD_ADDR_EXP 124
37219: PUSH
37220: LD_EXP 124
37224: PPUSH
37225: LD_VAR 0 4
37229: PPUSH
37230: EMPTY
37231: PPUSH
37232: CALL_OW 1
37236: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37237: LD_ADDR_EXP 126
37241: PUSH
37242: LD_EXP 126
37246: PPUSH
37247: LD_VAR 0 4
37251: PPUSH
37252: EMPTY
37253: PPUSH
37254: CALL_OW 1
37258: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37259: LD_ADDR_EXP 127
37263: PUSH
37264: LD_EXP 127
37268: PPUSH
37269: LD_VAR 0 4
37273: PPUSH
37274: EMPTY
37275: PPUSH
37276: CALL_OW 1
37280: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37281: LD_ADDR_EXP 128
37285: PUSH
37286: LD_EXP 128
37290: PPUSH
37291: LD_VAR 0 4
37295: PPUSH
37296: EMPTY
37297: PPUSH
37298: CALL_OW 1
37302: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37303: LD_ADDR_EXP 129
37307: PUSH
37308: LD_EXP 129
37312: PPUSH
37313: LD_VAR 0 4
37317: PPUSH
37318: EMPTY
37319: PPUSH
37320: CALL_OW 1
37324: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37325: LD_ADDR_EXP 130
37329: PUSH
37330: LD_EXP 130
37334: PPUSH
37335: LD_VAR 0 4
37339: PPUSH
37340: EMPTY
37341: PPUSH
37342: CALL_OW 1
37346: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37347: LD_ADDR_EXP 131
37351: PUSH
37352: LD_EXP 131
37356: PPUSH
37357: LD_VAR 0 4
37361: PPUSH
37362: EMPTY
37363: PPUSH
37364: CALL_OW 1
37368: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37369: LD_ADDR_EXP 132
37373: PUSH
37374: LD_EXP 132
37378: PPUSH
37379: LD_VAR 0 4
37383: PPUSH
37384: EMPTY
37385: PPUSH
37386: CALL_OW 1
37390: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37391: LD_ADDR_EXP 133
37395: PUSH
37396: LD_EXP 133
37400: PPUSH
37401: LD_VAR 0 4
37405: PPUSH
37406: EMPTY
37407: PPUSH
37408: CALL_OW 1
37412: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37413: LD_ADDR_EXP 134
37417: PUSH
37418: LD_EXP 134
37422: PPUSH
37423: LD_VAR 0 4
37427: PPUSH
37428: EMPTY
37429: PPUSH
37430: CALL_OW 1
37434: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37435: LD_ADDR_EXP 135
37439: PUSH
37440: LD_EXP 135
37444: PPUSH
37445: LD_VAR 0 4
37449: PPUSH
37450: EMPTY
37451: PPUSH
37452: CALL_OW 1
37456: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37457: LD_ADDR_EXP 136
37461: PUSH
37462: LD_EXP 136
37466: PPUSH
37467: LD_VAR 0 4
37471: PPUSH
37472: EMPTY
37473: PPUSH
37474: CALL_OW 1
37478: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37479: LD_ADDR_EXP 137
37483: PUSH
37484: LD_EXP 137
37488: PPUSH
37489: LD_VAR 0 4
37493: PPUSH
37494: EMPTY
37495: PPUSH
37496: CALL_OW 1
37500: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37501: LD_ADDR_EXP 138
37505: PUSH
37506: LD_EXP 138
37510: PPUSH
37511: LD_VAR 0 4
37515: PPUSH
37516: EMPTY
37517: PPUSH
37518: CALL_OW 1
37522: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37523: LD_ADDR_EXP 139
37527: PUSH
37528: LD_EXP 139
37532: PPUSH
37533: LD_VAR 0 4
37537: PPUSH
37538: LD_INT 0
37540: PPUSH
37541: CALL_OW 1
37545: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37546: LD_ADDR_EXP 140
37550: PUSH
37551: LD_EXP 140
37555: PPUSH
37556: LD_VAR 0 4
37560: PPUSH
37561: LD_INT 0
37563: PPUSH
37564: CALL_OW 1
37568: ST_TO_ADDR
// result := base ;
37569: LD_ADDR_VAR 0 3
37573: PUSH
37574: LD_VAR 0 4
37578: ST_TO_ADDR
// end ;
37579: LD_VAR 0 3
37583: RET
// export function MC_Start ( ) ; var i ; begin
37584: LD_INT 0
37586: PPUSH
37587: PPUSH
// for i = 1 to mc_bases do
37588: LD_ADDR_VAR 0 2
37592: PUSH
37593: DOUBLE
37594: LD_INT 1
37596: DEC
37597: ST_TO_ADDR
37598: LD_EXP 97
37602: PUSH
37603: FOR_TO
37604: IFFALSE 38704
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37606: LD_ADDR_EXP 97
37610: PUSH
37611: LD_EXP 97
37615: PPUSH
37616: LD_VAR 0 2
37620: PPUSH
37621: LD_EXP 97
37625: PUSH
37626: LD_VAR 0 2
37630: ARRAY
37631: PUSH
37632: LD_INT 0
37634: DIFF
37635: PPUSH
37636: CALL_OW 1
37640: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37641: LD_ADDR_EXP 98
37645: PUSH
37646: LD_EXP 98
37650: PPUSH
37651: LD_VAR 0 2
37655: PPUSH
37656: EMPTY
37657: PPUSH
37658: CALL_OW 1
37662: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37663: LD_ADDR_EXP 99
37667: PUSH
37668: LD_EXP 99
37672: PPUSH
37673: LD_VAR 0 2
37677: PPUSH
37678: EMPTY
37679: PPUSH
37680: CALL_OW 1
37684: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37685: LD_ADDR_EXP 100
37689: PUSH
37690: LD_EXP 100
37694: PPUSH
37695: LD_VAR 0 2
37699: PPUSH
37700: EMPTY
37701: PPUSH
37702: CALL_OW 1
37706: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37707: LD_ADDR_EXP 101
37711: PUSH
37712: LD_EXP 101
37716: PPUSH
37717: LD_VAR 0 2
37721: PPUSH
37722: EMPTY
37723: PUSH
37724: EMPTY
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PPUSH
37730: CALL_OW 1
37734: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37735: LD_ADDR_EXP 102
37739: PUSH
37740: LD_EXP 102
37744: PPUSH
37745: LD_VAR 0 2
37749: PPUSH
37750: EMPTY
37751: PPUSH
37752: CALL_OW 1
37756: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37757: LD_ADDR_EXP 129
37761: PUSH
37762: LD_EXP 129
37766: PPUSH
37767: LD_VAR 0 2
37771: PPUSH
37772: EMPTY
37773: PPUSH
37774: CALL_OW 1
37778: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37779: LD_ADDR_EXP 103
37783: PUSH
37784: LD_EXP 103
37788: PPUSH
37789: LD_VAR 0 2
37793: PPUSH
37794: EMPTY
37795: PPUSH
37796: CALL_OW 1
37800: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37801: LD_ADDR_EXP 104
37805: PUSH
37806: LD_EXP 104
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: EMPTY
37817: PPUSH
37818: CALL_OW 1
37822: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37823: LD_ADDR_EXP 105
37827: PUSH
37828: LD_EXP 105
37832: PPUSH
37833: LD_VAR 0 2
37837: PPUSH
37838: LD_EXP 97
37842: PUSH
37843: LD_VAR 0 2
37847: ARRAY
37848: PPUSH
37849: LD_INT 2
37851: PUSH
37852: LD_INT 30
37854: PUSH
37855: LD_INT 32
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 30
37864: PUSH
37865: LD_INT 33
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: LIST
37876: PPUSH
37877: CALL_OW 72
37881: PPUSH
37882: CALL_OW 1
37886: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37887: LD_ADDR_EXP 106
37891: PUSH
37892: LD_EXP 106
37896: PPUSH
37897: LD_VAR 0 2
37901: PPUSH
37902: LD_EXP 97
37906: PUSH
37907: LD_VAR 0 2
37911: ARRAY
37912: PPUSH
37913: LD_INT 2
37915: PUSH
37916: LD_INT 30
37918: PUSH
37919: LD_INT 32
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 30
37928: PUSH
37929: LD_INT 31
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 58
37943: PUSH
37944: EMPTY
37945: LIST
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PPUSH
37951: CALL_OW 72
37955: PPUSH
37956: CALL_OW 1
37960: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37961: LD_ADDR_EXP 107
37965: PUSH
37966: LD_EXP 107
37970: PPUSH
37971: LD_VAR 0 2
37975: PPUSH
37976: EMPTY
37977: PPUSH
37978: CALL_OW 1
37982: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37983: LD_ADDR_EXP 111
37987: PUSH
37988: LD_EXP 111
37992: PPUSH
37993: LD_VAR 0 2
37997: PPUSH
37998: EMPTY
37999: PPUSH
38000: CALL_OW 1
38004: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
38005: LD_ADDR_EXP 110
38009: PUSH
38010: LD_EXP 110
38014: PPUSH
38015: LD_VAR 0 2
38019: PPUSH
38020: EMPTY
38021: PPUSH
38022: CALL_OW 1
38026: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
38027: LD_ADDR_EXP 112
38031: PUSH
38032: LD_EXP 112
38036: PPUSH
38037: LD_VAR 0 2
38041: PPUSH
38042: EMPTY
38043: PPUSH
38044: CALL_OW 1
38048: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
38049: LD_ADDR_EXP 113
38053: PUSH
38054: LD_EXP 113
38058: PPUSH
38059: LD_VAR 0 2
38063: PPUSH
38064: EMPTY
38065: PPUSH
38066: CALL_OW 1
38070: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
38071: LD_ADDR_EXP 114
38075: PUSH
38076: LD_EXP 114
38080: PPUSH
38081: LD_VAR 0 2
38085: PPUSH
38086: EMPTY
38087: PPUSH
38088: CALL_OW 1
38092: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
38093: LD_ADDR_EXP 115
38097: PUSH
38098: LD_EXP 115
38102: PPUSH
38103: LD_VAR 0 2
38107: PPUSH
38108: EMPTY
38109: PPUSH
38110: CALL_OW 1
38114: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
38115: LD_ADDR_EXP 116
38119: PUSH
38120: LD_EXP 116
38124: PPUSH
38125: LD_VAR 0 2
38129: PPUSH
38130: EMPTY
38131: PPUSH
38132: CALL_OW 1
38136: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38137: LD_ADDR_EXP 117
38141: PUSH
38142: LD_EXP 117
38146: PPUSH
38147: LD_VAR 0 2
38151: PPUSH
38152: EMPTY
38153: PPUSH
38154: CALL_OW 1
38158: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
38159: LD_ADDR_EXP 118
38163: PUSH
38164: LD_EXP 118
38168: PPUSH
38169: LD_VAR 0 2
38173: PPUSH
38174: EMPTY
38175: PPUSH
38176: CALL_OW 1
38180: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38181: LD_ADDR_EXP 119
38185: PUSH
38186: LD_EXP 119
38190: PPUSH
38191: LD_VAR 0 2
38195: PPUSH
38196: EMPTY
38197: PPUSH
38198: CALL_OW 1
38202: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38203: LD_ADDR_EXP 108
38207: PUSH
38208: LD_EXP 108
38212: PPUSH
38213: LD_VAR 0 2
38217: PPUSH
38218: LD_INT 0
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38226: LD_ADDR_EXP 121
38230: PUSH
38231: LD_EXP 121
38235: PPUSH
38236: LD_VAR 0 2
38240: PPUSH
38241: LD_INT 0
38243: PPUSH
38244: CALL_OW 1
38248: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38249: LD_ADDR_EXP 109
38253: PUSH
38254: LD_EXP 109
38258: PPUSH
38259: LD_VAR 0 2
38263: PPUSH
38264: EMPTY
38265: PPUSH
38266: CALL_OW 1
38270: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38271: LD_ADDR_EXP 120
38275: PUSH
38276: LD_EXP 120
38280: PPUSH
38281: LD_VAR 0 2
38285: PPUSH
38286: LD_INT 0
38288: PPUSH
38289: CALL_OW 1
38293: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38294: LD_ADDR_EXP 122
38298: PUSH
38299: LD_EXP 122
38303: PPUSH
38304: LD_VAR 0 2
38308: PPUSH
38309: EMPTY
38310: PPUSH
38311: CALL_OW 1
38315: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38316: LD_ADDR_EXP 125
38320: PUSH
38321: LD_EXP 125
38325: PPUSH
38326: LD_VAR 0 2
38330: PPUSH
38331: LD_INT 0
38333: PPUSH
38334: CALL_OW 1
38338: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38339: LD_ADDR_EXP 126
38343: PUSH
38344: LD_EXP 126
38348: PPUSH
38349: LD_VAR 0 2
38353: PPUSH
38354: EMPTY
38355: PPUSH
38356: CALL_OW 1
38360: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38361: LD_ADDR_EXP 127
38365: PUSH
38366: LD_EXP 127
38370: PPUSH
38371: LD_VAR 0 2
38375: PPUSH
38376: EMPTY
38377: PPUSH
38378: CALL_OW 1
38382: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38383: LD_ADDR_EXP 128
38387: PUSH
38388: LD_EXP 128
38392: PPUSH
38393: LD_VAR 0 2
38397: PPUSH
38398: EMPTY
38399: PPUSH
38400: CALL_OW 1
38404: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38405: LD_ADDR_EXP 130
38409: PUSH
38410: LD_EXP 130
38414: PPUSH
38415: LD_VAR 0 2
38419: PPUSH
38420: LD_EXP 97
38424: PUSH
38425: LD_VAR 0 2
38429: ARRAY
38430: PPUSH
38431: LD_INT 2
38433: PUSH
38434: LD_INT 30
38436: PUSH
38437: LD_INT 6
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 30
38446: PUSH
38447: LD_INT 7
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 30
38456: PUSH
38457: LD_INT 8
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: PPUSH
38470: CALL_OW 72
38474: PPUSH
38475: CALL_OW 1
38479: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38480: LD_ADDR_EXP 131
38484: PUSH
38485: LD_EXP 131
38489: PPUSH
38490: LD_VAR 0 2
38494: PPUSH
38495: EMPTY
38496: PPUSH
38497: CALL_OW 1
38501: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38502: LD_ADDR_EXP 132
38506: PUSH
38507: LD_EXP 132
38511: PPUSH
38512: LD_VAR 0 2
38516: PPUSH
38517: EMPTY
38518: PPUSH
38519: CALL_OW 1
38523: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38524: LD_ADDR_EXP 133
38528: PUSH
38529: LD_EXP 133
38533: PPUSH
38534: LD_VAR 0 2
38538: PPUSH
38539: EMPTY
38540: PPUSH
38541: CALL_OW 1
38545: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38546: LD_ADDR_EXP 134
38550: PUSH
38551: LD_EXP 134
38555: PPUSH
38556: LD_VAR 0 2
38560: PPUSH
38561: EMPTY
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38568: LD_ADDR_EXP 135
38572: PUSH
38573: LD_EXP 135
38577: PPUSH
38578: LD_VAR 0 2
38582: PPUSH
38583: EMPTY
38584: PPUSH
38585: CALL_OW 1
38589: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38590: LD_ADDR_EXP 136
38594: PUSH
38595: LD_EXP 136
38599: PPUSH
38600: LD_VAR 0 2
38604: PPUSH
38605: EMPTY
38606: PPUSH
38607: CALL_OW 1
38611: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38612: LD_ADDR_EXP 137
38616: PUSH
38617: LD_EXP 137
38621: PPUSH
38622: LD_VAR 0 2
38626: PPUSH
38627: EMPTY
38628: PPUSH
38629: CALL_OW 1
38633: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38634: LD_ADDR_EXP 138
38638: PUSH
38639: LD_EXP 138
38643: PPUSH
38644: LD_VAR 0 2
38648: PPUSH
38649: EMPTY
38650: PPUSH
38651: CALL_OW 1
38655: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38656: LD_ADDR_EXP 139
38660: PUSH
38661: LD_EXP 139
38665: PPUSH
38666: LD_VAR 0 2
38670: PPUSH
38671: LD_INT 0
38673: PPUSH
38674: CALL_OW 1
38678: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38679: LD_ADDR_EXP 140
38683: PUSH
38684: LD_EXP 140
38688: PPUSH
38689: LD_VAR 0 2
38693: PPUSH
38694: LD_INT 0
38696: PPUSH
38697: CALL_OW 1
38701: ST_TO_ADDR
// end ;
38702: GO 37603
38704: POP
38705: POP
// MC_InitSides ( ) ;
38706: CALL 38992 0 0
// MC_InitResearch ( ) ;
38710: CALL 38731 0 0
// CustomInitMacro ( ) ;
38714: CALL 467 0 0
// skirmish := true ;
38718: LD_ADDR_EXP 95
38722: PUSH
38723: LD_INT 1
38725: ST_TO_ADDR
// end ;
38726: LD_VAR 0 1
38730: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38731: LD_INT 0
38733: PPUSH
38734: PPUSH
38735: PPUSH
38736: PPUSH
38737: PPUSH
38738: PPUSH
// if not mc_bases then
38739: LD_EXP 97
38743: NOT
38744: IFFALSE 38748
// exit ;
38746: GO 38987
// for i = 1 to 8 do
38748: LD_ADDR_VAR 0 2
38752: PUSH
38753: DOUBLE
38754: LD_INT 1
38756: DEC
38757: ST_TO_ADDR
38758: LD_INT 8
38760: PUSH
38761: FOR_TO
38762: IFFALSE 38788
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38764: LD_ADDR_EXP 124
38768: PUSH
38769: LD_EXP 124
38773: PPUSH
38774: LD_VAR 0 2
38778: PPUSH
38779: EMPTY
38780: PPUSH
38781: CALL_OW 1
38785: ST_TO_ADDR
38786: GO 38761
38788: POP
38789: POP
// tmp := [ ] ;
38790: LD_ADDR_VAR 0 5
38794: PUSH
38795: EMPTY
38796: ST_TO_ADDR
// for i = 1 to mc_sides do
38797: LD_ADDR_VAR 0 2
38801: PUSH
38802: DOUBLE
38803: LD_INT 1
38805: DEC
38806: ST_TO_ADDR
38807: LD_EXP 123
38811: PUSH
38812: FOR_TO
38813: IFFALSE 38871
// if not mc_sides [ i ] in tmp then
38815: LD_EXP 123
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_VAR 0 5
38830: IN
38831: NOT
38832: IFFALSE 38869
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38834: LD_ADDR_VAR 0 5
38838: PUSH
38839: LD_VAR 0 5
38843: PPUSH
38844: LD_VAR 0 5
38848: PUSH
38849: LD_INT 1
38851: PLUS
38852: PPUSH
38853: LD_EXP 123
38857: PUSH
38858: LD_VAR 0 2
38862: ARRAY
38863: PPUSH
38864: CALL_OW 2
38868: ST_TO_ADDR
38869: GO 38812
38871: POP
38872: POP
// if not tmp then
38873: LD_VAR 0 5
38877: NOT
38878: IFFALSE 38882
// exit ;
38880: GO 38987
// for j in tmp do
38882: LD_ADDR_VAR 0 3
38886: PUSH
38887: LD_VAR 0 5
38891: PUSH
38892: FOR_IN
38893: IFFALSE 38985
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38895: LD_ADDR_VAR 0 6
38899: PUSH
38900: LD_INT 22
38902: PUSH
38903: LD_VAR 0 3
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PPUSH
38912: CALL_OW 69
38916: ST_TO_ADDR
// if not un then
38917: LD_VAR 0 6
38921: NOT
38922: IFFALSE 38926
// continue ;
38924: GO 38892
// nation := GetNation ( un [ 1 ] ) ;
38926: LD_ADDR_VAR 0 4
38930: PUSH
38931: LD_VAR 0 6
38935: PUSH
38936: LD_INT 1
38938: ARRAY
38939: PPUSH
38940: CALL_OW 248
38944: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38945: LD_ADDR_EXP 124
38949: PUSH
38950: LD_EXP 124
38954: PPUSH
38955: LD_VAR 0 3
38959: PPUSH
38960: LD_VAR 0 3
38964: PPUSH
38965: LD_VAR 0 4
38969: PPUSH
38970: LD_INT 1
38972: PPUSH
38973: CALL 66086 0 3
38977: PPUSH
38978: CALL_OW 1
38982: ST_TO_ADDR
// end ;
38983: GO 38892
38985: POP
38986: POP
// end ;
38987: LD_VAR 0 1
38991: RET
// export function MC_InitSides ( ) ; var i ; begin
38992: LD_INT 0
38994: PPUSH
38995: PPUSH
// if not mc_bases then
38996: LD_EXP 97
39000: NOT
39001: IFFALSE 39005
// exit ;
39003: GO 39079
// for i = 1 to mc_bases do
39005: LD_ADDR_VAR 0 2
39009: PUSH
39010: DOUBLE
39011: LD_INT 1
39013: DEC
39014: ST_TO_ADDR
39015: LD_EXP 97
39019: PUSH
39020: FOR_TO
39021: IFFALSE 39077
// if mc_bases [ i ] then
39023: LD_EXP 97
39027: PUSH
39028: LD_VAR 0 2
39032: ARRAY
39033: IFFALSE 39075
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
39035: LD_ADDR_EXP 123
39039: PUSH
39040: LD_EXP 123
39044: PPUSH
39045: LD_VAR 0 2
39049: PPUSH
39050: LD_EXP 97
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: PUSH
39061: LD_INT 1
39063: ARRAY
39064: PPUSH
39065: CALL_OW 255
39069: PPUSH
39070: CALL_OW 1
39074: ST_TO_ADDR
39075: GO 39020
39077: POP
39078: POP
// end ;
39079: LD_VAR 0 1
39083: RET
// every 0 0$03 trigger skirmish do
39084: LD_EXP 95
39088: IFFALSE 39242
39090: GO 39092
39092: DISABLE
// begin enable ;
39093: ENABLE
// MC_CheckBuildings ( ) ;
39094: CALL 43740 0 0
// MC_CheckPeopleLife ( ) ;
39098: CALL 43901 0 0
// RaiseSailEvent ( 100 ) ;
39102: LD_INT 100
39104: PPUSH
39105: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
39109: LD_INT 103
39111: PPUSH
39112: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
39116: LD_INT 104
39118: PPUSH
39119: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
39123: LD_INT 105
39125: PPUSH
39126: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
39130: LD_INT 106
39132: PPUSH
39133: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
39137: LD_INT 107
39139: PPUSH
39140: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
39144: LD_INT 108
39146: PPUSH
39147: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
39151: LD_INT 109
39153: PPUSH
39154: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
39158: LD_INT 110
39160: PPUSH
39161: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
39165: LD_INT 111
39167: PPUSH
39168: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39172: LD_INT 112
39174: PPUSH
39175: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39179: LD_INT 113
39181: PPUSH
39182: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39186: LD_INT 120
39188: PPUSH
39189: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39193: LD_INT 121
39195: PPUSH
39196: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39200: LD_INT 122
39202: PPUSH
39203: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39207: LD_INT 123
39209: PPUSH
39210: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39214: LD_INT 124
39216: PPUSH
39217: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39221: LD_INT 125
39223: PPUSH
39224: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39228: LD_INT 126
39230: PPUSH
39231: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39235: LD_INT 200
39237: PPUSH
39238: CALL_OW 427
// end ;
39242: END
// on SailEvent ( event ) do begin if event < 100 then
39243: LD_VAR 0 1
39247: PUSH
39248: LD_INT 100
39250: LESS
39251: IFFALSE 39262
// CustomEvent ( event ) ;
39253: LD_VAR 0 1
39257: PPUSH
39258: CALL 33863 0 1
// if event = 100 then
39262: LD_VAR 0 1
39266: PUSH
39267: LD_INT 100
39269: EQUAL
39270: IFFALSE 39276
// MC_ClassManager ( ) ;
39272: CALL 39668 0 0
// if event = 101 then
39276: LD_VAR 0 1
39280: PUSH
39281: LD_INT 101
39283: EQUAL
39284: IFFALSE 39290
// MC_RepairBuildings ( ) ;
39286: CALL 44486 0 0
// if event = 102 then
39290: LD_VAR 0 1
39294: PUSH
39295: LD_INT 102
39297: EQUAL
39298: IFFALSE 39304
// MC_Heal ( ) ;
39300: CALL 45389 0 0
// if event = 103 then
39304: LD_VAR 0 1
39308: PUSH
39309: LD_INT 103
39311: EQUAL
39312: IFFALSE 39318
// MC_Build ( ) ;
39314: CALL 45811 0 0
// if event = 104 then
39318: LD_VAR 0 1
39322: PUSH
39323: LD_INT 104
39325: EQUAL
39326: IFFALSE 39332
// MC_TurretWeapon ( ) ;
39328: CALL 47452 0 0
// if event = 105 then
39332: LD_VAR 0 1
39336: PUSH
39337: LD_INT 105
39339: EQUAL
39340: IFFALSE 39346
// MC_BuildUpgrade ( ) ;
39342: CALL 47003 0 0
// if event = 106 then
39346: LD_VAR 0 1
39350: PUSH
39351: LD_INT 106
39353: EQUAL
39354: IFFALSE 39360
// MC_PlantMines ( ) ;
39356: CALL 47882 0 0
// if event = 107 then
39360: LD_VAR 0 1
39364: PUSH
39365: LD_INT 107
39367: EQUAL
39368: IFFALSE 39374
// MC_CollectCrates ( ) ;
39370: CALL 48673 0 0
// if event = 108 then
39374: LD_VAR 0 1
39378: PUSH
39379: LD_INT 108
39381: EQUAL
39382: IFFALSE 39388
// MC_LinkRemoteControl ( ) ;
39384: CALL 50523 0 0
// if event = 109 then
39388: LD_VAR 0 1
39392: PUSH
39393: LD_INT 109
39395: EQUAL
39396: IFFALSE 39402
// MC_ProduceVehicle ( ) ;
39398: CALL 50704 0 0
// if event = 110 then
39402: LD_VAR 0 1
39406: PUSH
39407: LD_INT 110
39409: EQUAL
39410: IFFALSE 39416
// MC_SendAttack ( ) ;
39412: CALL 51170 0 0
// if event = 111 then
39416: LD_VAR 0 1
39420: PUSH
39421: LD_INT 111
39423: EQUAL
39424: IFFALSE 39430
// MC_Defend ( ) ;
39426: CALL 51278 0 0
// if event = 112 then
39430: LD_VAR 0 1
39434: PUSH
39435: LD_INT 112
39437: EQUAL
39438: IFFALSE 39444
// MC_Research ( ) ;
39440: CALL 52158 0 0
// if event = 113 then
39444: LD_VAR 0 1
39448: PUSH
39449: LD_INT 113
39451: EQUAL
39452: IFFALSE 39458
// MC_MinesTrigger ( ) ;
39454: CALL 53272 0 0
// if event = 120 then
39458: LD_VAR 0 1
39462: PUSH
39463: LD_INT 120
39465: EQUAL
39466: IFFALSE 39472
// MC_RepairVehicle ( ) ;
39468: CALL 53371 0 0
// if event = 121 then
39472: LD_VAR 0 1
39476: PUSH
39477: LD_INT 121
39479: EQUAL
39480: IFFALSE 39486
// MC_TameApe ( ) ;
39482: CALL 54112 0 0
// if event = 122 then
39486: LD_VAR 0 1
39490: PUSH
39491: LD_INT 122
39493: EQUAL
39494: IFFALSE 39500
// MC_ChangeApeClass ( ) ;
39496: CALL 54941 0 0
// if event = 123 then
39500: LD_VAR 0 1
39504: PUSH
39505: LD_INT 123
39507: EQUAL
39508: IFFALSE 39514
// MC_Bazooka ( ) ;
39510: CALL 55591 0 0
// if event = 124 then
39514: LD_VAR 0 1
39518: PUSH
39519: LD_INT 124
39521: EQUAL
39522: IFFALSE 39528
// MC_TeleportExit ( ) ;
39524: CALL 55789 0 0
// if event = 125 then
39528: LD_VAR 0 1
39532: PUSH
39533: LD_INT 125
39535: EQUAL
39536: IFFALSE 39542
// MC_Deposits ( ) ;
39538: CALL 56436 0 0
// if event = 126 then
39542: LD_VAR 0 1
39546: PUSH
39547: LD_INT 126
39549: EQUAL
39550: IFFALSE 39556
// MC_RemoteDriver ( ) ;
39552: CALL 57061 0 0
// if event = 200 then
39556: LD_VAR 0 1
39560: PUSH
39561: LD_INT 200
39563: EQUAL
39564: IFFALSE 39570
// MC_Idle ( ) ;
39566: CALL 59010 0 0
// end ;
39570: PPOPN 1
39572: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39573: LD_INT 0
39575: PPUSH
39576: PPUSH
// if not mc_bases [ base ] or not tag then
39577: LD_EXP 97
39581: PUSH
39582: LD_VAR 0 1
39586: ARRAY
39587: NOT
39588: PUSH
39589: LD_VAR 0 2
39593: NOT
39594: OR
39595: IFFALSE 39599
// exit ;
39597: GO 39663
// for i in mc_bases [ base ] union mc_ape [ base ] do
39599: LD_ADDR_VAR 0 4
39603: PUSH
39604: LD_EXP 97
39608: PUSH
39609: LD_VAR 0 1
39613: ARRAY
39614: PUSH
39615: LD_EXP 126
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: UNION
39626: PUSH
39627: FOR_IN
39628: IFFALSE 39661
// if GetTag ( i ) = tag then
39630: LD_VAR 0 4
39634: PPUSH
39635: CALL_OW 110
39639: PUSH
39640: LD_VAR 0 2
39644: EQUAL
39645: IFFALSE 39659
// SetTag ( i , 0 ) ;
39647: LD_VAR 0 4
39651: PPUSH
39652: LD_INT 0
39654: PPUSH
39655: CALL_OW 109
39659: GO 39627
39661: POP
39662: POP
// end ;
39663: LD_VAR 0 3
39667: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39668: LD_INT 0
39670: PPUSH
39671: PPUSH
39672: PPUSH
39673: PPUSH
39674: PPUSH
39675: PPUSH
39676: PPUSH
39677: PPUSH
// if not mc_bases then
39678: LD_EXP 97
39682: NOT
39683: IFFALSE 39687
// exit ;
39685: GO 40145
// for i = 1 to mc_bases do
39687: LD_ADDR_VAR 0 2
39691: PUSH
39692: DOUBLE
39693: LD_INT 1
39695: DEC
39696: ST_TO_ADDR
39697: LD_EXP 97
39701: PUSH
39702: FOR_TO
39703: IFFALSE 40143
// begin tmp := MC_ClassCheckReq ( i ) ;
39705: LD_ADDR_VAR 0 4
39709: PUSH
39710: LD_VAR 0 2
39714: PPUSH
39715: CALL 40150 0 1
39719: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39720: LD_ADDR_EXP 138
39724: PUSH
39725: LD_EXP 138
39729: PPUSH
39730: LD_VAR 0 2
39734: PPUSH
39735: LD_VAR 0 4
39739: PPUSH
39740: CALL_OW 1
39744: ST_TO_ADDR
// if not tmp then
39745: LD_VAR 0 4
39749: NOT
39750: IFFALSE 39754
// continue ;
39752: GO 39702
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39754: LD_ADDR_VAR 0 6
39758: PUSH
39759: LD_EXP 97
39763: PUSH
39764: LD_VAR 0 2
39768: ARRAY
39769: PPUSH
39770: LD_INT 2
39772: PUSH
39773: LD_INT 30
39775: PUSH
39776: LD_INT 4
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PUSH
39783: LD_INT 30
39785: PUSH
39786: LD_INT 5
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: LIST
39797: PPUSH
39798: CALL_OW 72
39802: PUSH
39803: LD_EXP 97
39807: PUSH
39808: LD_VAR 0 2
39812: ARRAY
39813: PPUSH
39814: LD_INT 2
39816: PUSH
39817: LD_INT 30
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 30
39829: PUSH
39830: LD_INT 1
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: LIST
39841: PPUSH
39842: CALL_OW 72
39846: PUSH
39847: LD_EXP 97
39851: PUSH
39852: LD_VAR 0 2
39856: ARRAY
39857: PPUSH
39858: LD_INT 30
39860: PUSH
39861: LD_INT 3
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 72
39872: PUSH
39873: LD_EXP 97
39877: PUSH
39878: LD_VAR 0 2
39882: ARRAY
39883: PPUSH
39884: LD_INT 2
39886: PUSH
39887: LD_INT 30
39889: PUSH
39890: LD_INT 6
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 30
39899: PUSH
39900: LD_INT 7
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 30
39909: PUSH
39910: LD_INT 8
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: PPUSH
39923: CALL_OW 72
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: ST_TO_ADDR
// for j = 1 to 4 do
39934: LD_ADDR_VAR 0 3
39938: PUSH
39939: DOUBLE
39940: LD_INT 1
39942: DEC
39943: ST_TO_ADDR
39944: LD_INT 4
39946: PUSH
39947: FOR_TO
39948: IFFALSE 40139
// begin if not tmp [ j ] then
39950: LD_VAR 0 4
39954: PUSH
39955: LD_VAR 0 3
39959: ARRAY
39960: NOT
39961: IFFALSE 39965
// continue ;
39963: GO 39947
// for p in tmp [ j ] do
39965: LD_ADDR_VAR 0 5
39969: PUSH
39970: LD_VAR 0 4
39974: PUSH
39975: LD_VAR 0 3
39979: ARRAY
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40135
// begin if not b [ j ] then
39984: LD_VAR 0 6
39988: PUSH
39989: LD_VAR 0 3
39993: ARRAY
39994: NOT
39995: IFFALSE 39999
// break ;
39997: GO 40135
// e := 0 ;
39999: LD_ADDR_VAR 0 7
40003: PUSH
40004: LD_INT 0
40006: ST_TO_ADDR
// for k in b [ j ] do
40007: LD_ADDR_VAR 0 8
40011: PUSH
40012: LD_VAR 0 6
40016: PUSH
40017: LD_VAR 0 3
40021: ARRAY
40022: PUSH
40023: FOR_IN
40024: IFFALSE 40051
// if IsNotFull ( k ) then
40026: LD_VAR 0 8
40030: PPUSH
40031: CALL 68239 0 1
40035: IFFALSE 40049
// begin e := k ;
40037: LD_ADDR_VAR 0 7
40041: PUSH
40042: LD_VAR 0 8
40046: ST_TO_ADDR
// break ;
40047: GO 40051
// end ;
40049: GO 40023
40051: POP
40052: POP
// if e and not UnitGoingToBuilding ( p , e ) then
40053: LD_VAR 0 7
40057: PUSH
40058: LD_VAR 0 5
40062: PPUSH
40063: LD_VAR 0 7
40067: PPUSH
40068: CALL 102118 0 2
40072: NOT
40073: AND
40074: IFFALSE 40133
// begin if IsInUnit ( p ) then
40076: LD_VAR 0 5
40080: PPUSH
40081: CALL_OW 310
40085: IFFALSE 40096
// ComExitBuilding ( p ) ;
40087: LD_VAR 0 5
40091: PPUSH
40092: CALL_OW 122
// ComEnterUnit ( p , e ) ;
40096: LD_VAR 0 5
40100: PPUSH
40101: LD_VAR 0 7
40105: PPUSH
40106: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
40110: LD_VAR 0 5
40114: PPUSH
40115: LD_VAR 0 3
40119: PPUSH
40120: CALL_OW 183
// AddComExitBuilding ( p ) ;
40124: LD_VAR 0 5
40128: PPUSH
40129: CALL_OW 182
// end ; end ;
40133: GO 39981
40135: POP
40136: POP
// end ;
40137: GO 39947
40139: POP
40140: POP
// end ;
40141: GO 39702
40143: POP
40144: POP
// end ;
40145: LD_VAR 0 1
40149: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
40150: LD_INT 0
40152: PPUSH
40153: PPUSH
40154: PPUSH
40155: PPUSH
40156: PPUSH
40157: PPUSH
40158: PPUSH
40159: PPUSH
40160: PPUSH
40161: PPUSH
40162: PPUSH
40163: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40164: LD_VAR 0 1
40168: NOT
40169: PUSH
40170: LD_EXP 97
40174: PUSH
40175: LD_VAR 0 1
40179: ARRAY
40180: NOT
40181: OR
40182: PUSH
40183: LD_EXP 97
40187: PUSH
40188: LD_VAR 0 1
40192: ARRAY
40193: PPUSH
40194: LD_INT 2
40196: PUSH
40197: LD_INT 30
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 30
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: LIST
40221: PPUSH
40222: CALL_OW 72
40226: NOT
40227: OR
40228: IFFALSE 40232
// exit ;
40230: GO 43735
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40232: LD_ADDR_VAR 0 4
40236: PUSH
40237: LD_EXP 97
40241: PUSH
40242: LD_VAR 0 1
40246: ARRAY
40247: PPUSH
40248: LD_INT 2
40250: PUSH
40251: LD_INT 25
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 25
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 25
40273: PUSH
40274: LD_INT 3
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 25
40283: PUSH
40284: LD_INT 4
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 25
40293: PUSH
40294: LD_INT 5
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 25
40303: PUSH
40304: LD_INT 8
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 25
40313: PUSH
40314: LD_INT 9
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: PPUSH
40331: CALL_OW 72
40335: ST_TO_ADDR
// if not tmp then
40336: LD_VAR 0 4
40340: NOT
40341: IFFALSE 40345
// exit ;
40343: GO 43735
// for i in tmp do
40345: LD_ADDR_VAR 0 3
40349: PUSH
40350: LD_VAR 0 4
40354: PUSH
40355: FOR_IN
40356: IFFALSE 40387
// if GetTag ( i ) then
40358: LD_VAR 0 3
40362: PPUSH
40363: CALL_OW 110
40367: IFFALSE 40385
// tmp := tmp diff i ;
40369: LD_ADDR_VAR 0 4
40373: PUSH
40374: LD_VAR 0 4
40378: PUSH
40379: LD_VAR 0 3
40383: DIFF
40384: ST_TO_ADDR
40385: GO 40355
40387: POP
40388: POP
// if not tmp then
40389: LD_VAR 0 4
40393: NOT
40394: IFFALSE 40398
// exit ;
40396: GO 43735
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40398: LD_ADDR_VAR 0 5
40402: PUSH
40403: LD_EXP 97
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: PPUSH
40414: LD_INT 2
40416: PUSH
40417: LD_INT 25
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 25
40429: PUSH
40430: LD_INT 5
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 25
40439: PUSH
40440: LD_INT 8
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 25
40449: PUSH
40450: LD_INT 9
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: PPUSH
40464: CALL_OW 72
40468: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40469: LD_ADDR_VAR 0 6
40473: PUSH
40474: LD_EXP 97
40478: PUSH
40479: LD_VAR 0 1
40483: ARRAY
40484: PPUSH
40485: LD_INT 25
40487: PUSH
40488: LD_INT 2
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PPUSH
40495: CALL_OW 72
40499: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40500: LD_ADDR_VAR 0 7
40504: PUSH
40505: LD_EXP 97
40509: PUSH
40510: LD_VAR 0 1
40514: ARRAY
40515: PPUSH
40516: LD_INT 25
40518: PUSH
40519: LD_INT 3
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PPUSH
40526: CALL_OW 72
40530: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40531: LD_ADDR_VAR 0 8
40535: PUSH
40536: LD_EXP 97
40540: PUSH
40541: LD_VAR 0 1
40545: ARRAY
40546: PPUSH
40547: LD_INT 25
40549: PUSH
40550: LD_INT 4
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 24
40559: PUSH
40560: LD_INT 251
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PPUSH
40571: CALL_OW 72
40575: ST_TO_ADDR
// if mc_is_defending [ base ] then
40576: LD_EXP 140
40580: PUSH
40581: LD_VAR 0 1
40585: ARRAY
40586: IFFALSE 41047
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40588: LD_ADDR_EXP 139
40592: PUSH
40593: LD_EXP 139
40597: PPUSH
40598: LD_VAR 0 1
40602: PPUSH
40603: LD_INT 4
40605: PPUSH
40606: CALL_OW 1
40610: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40611: LD_ADDR_VAR 0 12
40615: PUSH
40616: LD_EXP 97
40620: PUSH
40621: LD_VAR 0 1
40625: ARRAY
40626: PPUSH
40627: LD_INT 2
40629: PUSH
40630: LD_INT 30
40632: PUSH
40633: LD_INT 4
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 30
40642: PUSH
40643: LD_INT 5
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: LIST
40654: PPUSH
40655: CALL_OW 72
40659: ST_TO_ADDR
// if not b then
40660: LD_VAR 0 12
40664: NOT
40665: IFFALSE 40669
// exit ;
40667: GO 43735
// p := [ ] ;
40669: LD_ADDR_VAR 0 11
40673: PUSH
40674: EMPTY
40675: ST_TO_ADDR
// if sci >= 2 then
40676: LD_VAR 0 8
40680: PUSH
40681: LD_INT 2
40683: GREATEREQUAL
40684: IFFALSE 40715
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40686: LD_ADDR_VAR 0 8
40690: PUSH
40691: LD_VAR 0 8
40695: PUSH
40696: LD_INT 1
40698: ARRAY
40699: PUSH
40700: LD_VAR 0 8
40704: PUSH
40705: LD_INT 2
40707: ARRAY
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: ST_TO_ADDR
40713: GO 40776
// if sci = 1 then
40715: LD_VAR 0 8
40719: PUSH
40720: LD_INT 1
40722: EQUAL
40723: IFFALSE 40744
// sci := [ sci [ 1 ] ] else
40725: LD_ADDR_VAR 0 8
40729: PUSH
40730: LD_VAR 0 8
40734: PUSH
40735: LD_INT 1
40737: ARRAY
40738: PUSH
40739: EMPTY
40740: LIST
40741: ST_TO_ADDR
40742: GO 40776
// if sci = 0 then
40744: LD_VAR 0 8
40748: PUSH
40749: LD_INT 0
40751: EQUAL
40752: IFFALSE 40776
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40754: LD_ADDR_VAR 0 11
40758: PUSH
40759: LD_VAR 0 4
40763: PPUSH
40764: LD_INT 4
40766: PPUSH
40767: CALL 101981 0 2
40771: PUSH
40772: LD_INT 1
40774: ARRAY
40775: ST_TO_ADDR
// if eng > 4 then
40776: LD_VAR 0 6
40780: PUSH
40781: LD_INT 4
40783: GREATER
40784: IFFALSE 40830
// for i = eng downto 4 do
40786: LD_ADDR_VAR 0 3
40790: PUSH
40791: DOUBLE
40792: LD_VAR 0 6
40796: INC
40797: ST_TO_ADDR
40798: LD_INT 4
40800: PUSH
40801: FOR_DOWNTO
40802: IFFALSE 40828
// eng := eng diff eng [ i ] ;
40804: LD_ADDR_VAR 0 6
40808: PUSH
40809: LD_VAR 0 6
40813: PUSH
40814: LD_VAR 0 6
40818: PUSH
40819: LD_VAR 0 3
40823: ARRAY
40824: DIFF
40825: ST_TO_ADDR
40826: GO 40801
40828: POP
40829: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40830: LD_ADDR_VAR 0 4
40834: PUSH
40835: LD_VAR 0 4
40839: PUSH
40840: LD_VAR 0 5
40844: PUSH
40845: LD_VAR 0 6
40849: UNION
40850: PUSH
40851: LD_VAR 0 7
40855: UNION
40856: PUSH
40857: LD_VAR 0 8
40861: UNION
40862: DIFF
40863: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40864: LD_ADDR_VAR 0 13
40868: PUSH
40869: LD_EXP 97
40873: PUSH
40874: LD_VAR 0 1
40878: ARRAY
40879: PPUSH
40880: LD_INT 2
40882: PUSH
40883: LD_INT 30
40885: PUSH
40886: LD_INT 32
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 30
40895: PUSH
40896: LD_INT 31
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: LIST
40907: PPUSH
40908: CALL_OW 72
40912: PUSH
40913: LD_EXP 97
40917: PUSH
40918: LD_VAR 0 1
40922: ARRAY
40923: PPUSH
40924: LD_INT 2
40926: PUSH
40927: LD_INT 30
40929: PUSH
40930: LD_INT 4
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 30
40939: PUSH
40940: LD_INT 5
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: LIST
40951: PPUSH
40952: CALL_OW 72
40956: PUSH
40957: LD_INT 6
40959: MUL
40960: PLUS
40961: ST_TO_ADDR
// if bcount < tmp then
40962: LD_VAR 0 13
40966: PUSH
40967: LD_VAR 0 4
40971: LESS
40972: IFFALSE 41018
// for i = tmp downto bcount do
40974: LD_ADDR_VAR 0 3
40978: PUSH
40979: DOUBLE
40980: LD_VAR 0 4
40984: INC
40985: ST_TO_ADDR
40986: LD_VAR 0 13
40990: PUSH
40991: FOR_DOWNTO
40992: IFFALSE 41016
// tmp := Delete ( tmp , tmp ) ;
40994: LD_ADDR_VAR 0 4
40998: PUSH
40999: LD_VAR 0 4
41003: PPUSH
41004: LD_VAR 0 4
41008: PPUSH
41009: CALL_OW 3
41013: ST_TO_ADDR
41014: GO 40991
41016: POP
41017: POP
// result := [ tmp , 0 , 0 , p ] ;
41018: LD_ADDR_VAR 0 2
41022: PUSH
41023: LD_VAR 0 4
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: LD_VAR 0 11
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: ST_TO_ADDR
// exit ;
41045: GO 43735
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41047: LD_EXP 97
41051: PUSH
41052: LD_VAR 0 1
41056: ARRAY
41057: PPUSH
41058: LD_INT 2
41060: PUSH
41061: LD_INT 30
41063: PUSH
41064: LD_INT 6
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 30
41073: PUSH
41074: LD_INT 7
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 30
41083: PUSH
41084: LD_INT 8
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: PPUSH
41097: CALL_OW 72
41101: NOT
41102: PUSH
41103: LD_EXP 97
41107: PUSH
41108: LD_VAR 0 1
41112: ARRAY
41113: PPUSH
41114: LD_INT 30
41116: PUSH
41117: LD_INT 3
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PPUSH
41124: CALL_OW 72
41128: NOT
41129: AND
41130: IFFALSE 41202
// begin if eng = tmp then
41132: LD_VAR 0 6
41136: PUSH
41137: LD_VAR 0 4
41141: EQUAL
41142: IFFALSE 41146
// exit ;
41144: GO 43735
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
41146: LD_ADDR_EXP 139
41150: PUSH
41151: LD_EXP 139
41155: PPUSH
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 1
41163: PPUSH
41164: CALL_OW 1
41168: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41169: LD_ADDR_VAR 0 2
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_VAR 0 4
41181: PUSH
41182: LD_VAR 0 6
41186: DIFF
41187: PUSH
41188: LD_INT 0
41190: PUSH
41191: LD_INT 0
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: ST_TO_ADDR
// exit ;
41200: GO 43735
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41202: LD_EXP 124
41206: PUSH
41207: LD_EXP 123
41211: PUSH
41212: LD_VAR 0 1
41216: ARRAY
41217: ARRAY
41218: PUSH
41219: LD_EXP 97
41223: PUSH
41224: LD_VAR 0 1
41228: ARRAY
41229: PPUSH
41230: LD_INT 2
41232: PUSH
41233: LD_INT 30
41235: PUSH
41236: LD_INT 6
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 30
41245: PUSH
41246: LD_INT 7
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 30
41255: PUSH
41256: LD_INT 8
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL_OW 72
41273: AND
41274: PUSH
41275: LD_EXP 97
41279: PUSH
41280: LD_VAR 0 1
41284: ARRAY
41285: PPUSH
41286: LD_INT 30
41288: PUSH
41289: LD_INT 3
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PPUSH
41296: CALL_OW 72
41300: NOT
41301: AND
41302: IFFALSE 41516
// begin if sci >= 6 then
41304: LD_VAR 0 8
41308: PUSH
41309: LD_INT 6
41311: GREATEREQUAL
41312: IFFALSE 41316
// exit ;
41314: GO 43735
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41316: LD_ADDR_EXP 139
41320: PUSH
41321: LD_EXP 139
41325: PPUSH
41326: LD_VAR 0 1
41330: PPUSH
41331: LD_INT 2
41333: PPUSH
41334: CALL_OW 1
41338: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41339: LD_ADDR_VAR 0 9
41343: PUSH
41344: LD_VAR 0 4
41348: PUSH
41349: LD_VAR 0 8
41353: DIFF
41354: PPUSH
41355: LD_INT 4
41357: PPUSH
41358: CALL 101981 0 2
41362: ST_TO_ADDR
// p := [ ] ;
41363: LD_ADDR_VAR 0 11
41367: PUSH
41368: EMPTY
41369: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41370: LD_VAR 0 8
41374: PUSH
41375: LD_INT 6
41377: LESS
41378: PUSH
41379: LD_VAR 0 9
41383: PUSH
41384: LD_INT 6
41386: GREATER
41387: AND
41388: IFFALSE 41469
// begin for i = 1 to 6 - sci do
41390: LD_ADDR_VAR 0 3
41394: PUSH
41395: DOUBLE
41396: LD_INT 1
41398: DEC
41399: ST_TO_ADDR
41400: LD_INT 6
41402: PUSH
41403: LD_VAR 0 8
41407: MINUS
41408: PUSH
41409: FOR_TO
41410: IFFALSE 41465
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41412: LD_ADDR_VAR 0 11
41416: PUSH
41417: LD_VAR 0 11
41421: PPUSH
41422: LD_VAR 0 11
41426: PUSH
41427: LD_INT 1
41429: PLUS
41430: PPUSH
41431: LD_VAR 0 9
41435: PUSH
41436: LD_INT 1
41438: ARRAY
41439: PPUSH
41440: CALL_OW 2
41444: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41445: LD_ADDR_VAR 0 9
41449: PUSH
41450: LD_VAR 0 9
41454: PPUSH
41455: LD_INT 1
41457: PPUSH
41458: CALL_OW 3
41462: ST_TO_ADDR
// end ;
41463: GO 41409
41465: POP
41466: POP
// end else
41467: GO 41489
// if sort then
41469: LD_VAR 0 9
41473: IFFALSE 41489
// p := sort [ 1 ] ;
41475: LD_ADDR_VAR 0 11
41479: PUSH
41480: LD_VAR 0 9
41484: PUSH
41485: LD_INT 1
41487: ARRAY
41488: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41489: LD_ADDR_VAR 0 2
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: LD_INT 0
41502: PUSH
41503: LD_VAR 0 11
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: ST_TO_ADDR
// exit ;
41514: GO 43735
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41516: LD_EXP 124
41520: PUSH
41521: LD_EXP 123
41525: PUSH
41526: LD_VAR 0 1
41530: ARRAY
41531: ARRAY
41532: PUSH
41533: LD_EXP 97
41537: PUSH
41538: LD_VAR 0 1
41542: ARRAY
41543: PPUSH
41544: LD_INT 2
41546: PUSH
41547: LD_INT 30
41549: PUSH
41550: LD_INT 6
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 30
41559: PUSH
41560: LD_INT 7
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 30
41569: PUSH
41570: LD_INT 8
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: PPUSH
41583: CALL_OW 72
41587: AND
41588: PUSH
41589: LD_EXP 97
41593: PUSH
41594: LD_VAR 0 1
41598: ARRAY
41599: PPUSH
41600: LD_INT 30
41602: PUSH
41603: LD_INT 3
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PPUSH
41610: CALL_OW 72
41614: AND
41615: IFFALSE 42349
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41617: LD_ADDR_EXP 139
41621: PUSH
41622: LD_EXP 139
41626: PPUSH
41627: LD_VAR 0 1
41631: PPUSH
41632: LD_INT 3
41634: PPUSH
41635: CALL_OW 1
41639: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41640: LD_ADDR_VAR 0 2
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: LD_INT 0
41650: PUSH
41651: LD_INT 0
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: LIST
41661: LIST
41662: ST_TO_ADDR
// if not eng then
41663: LD_VAR 0 6
41667: NOT
41668: IFFALSE 41731
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41670: LD_ADDR_VAR 0 11
41674: PUSH
41675: LD_VAR 0 4
41679: PPUSH
41680: LD_INT 2
41682: PPUSH
41683: CALL 101981 0 2
41687: PUSH
41688: LD_INT 1
41690: ARRAY
41691: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41692: LD_ADDR_VAR 0 2
41696: PUSH
41697: LD_VAR 0 2
41701: PPUSH
41702: LD_INT 2
41704: PPUSH
41705: LD_VAR 0 11
41709: PPUSH
41710: CALL_OW 1
41714: ST_TO_ADDR
// tmp := tmp diff p ;
41715: LD_ADDR_VAR 0 4
41719: PUSH
41720: LD_VAR 0 4
41724: PUSH
41725: LD_VAR 0 11
41729: DIFF
41730: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41731: LD_VAR 0 4
41735: PUSH
41736: LD_VAR 0 8
41740: PUSH
41741: LD_INT 6
41743: LESS
41744: AND
41745: IFFALSE 41933
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41747: LD_ADDR_VAR 0 9
41751: PUSH
41752: LD_VAR 0 4
41756: PUSH
41757: LD_VAR 0 8
41761: PUSH
41762: LD_VAR 0 7
41766: UNION
41767: DIFF
41768: PPUSH
41769: LD_INT 4
41771: PPUSH
41772: CALL 101981 0 2
41776: ST_TO_ADDR
// p := [ ] ;
41777: LD_ADDR_VAR 0 11
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// if sort then
41784: LD_VAR 0 9
41788: IFFALSE 41904
// for i = 1 to 6 - sci do
41790: LD_ADDR_VAR 0 3
41794: PUSH
41795: DOUBLE
41796: LD_INT 1
41798: DEC
41799: ST_TO_ADDR
41800: LD_INT 6
41802: PUSH
41803: LD_VAR 0 8
41807: MINUS
41808: PUSH
41809: FOR_TO
41810: IFFALSE 41902
// begin if i = sort then
41812: LD_VAR 0 3
41816: PUSH
41817: LD_VAR 0 9
41821: EQUAL
41822: IFFALSE 41826
// break ;
41824: GO 41902
// if GetClass ( i ) = 4 then
41826: LD_VAR 0 3
41830: PPUSH
41831: CALL_OW 257
41835: PUSH
41836: LD_INT 4
41838: EQUAL
41839: IFFALSE 41843
// continue ;
41841: GO 41809
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41843: LD_ADDR_VAR 0 11
41847: PUSH
41848: LD_VAR 0 11
41852: PPUSH
41853: LD_VAR 0 11
41857: PUSH
41858: LD_INT 1
41860: PLUS
41861: PPUSH
41862: LD_VAR 0 9
41866: PUSH
41867: LD_VAR 0 3
41871: ARRAY
41872: PPUSH
41873: CALL_OW 2
41877: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41878: LD_ADDR_VAR 0 4
41882: PUSH
41883: LD_VAR 0 4
41887: PUSH
41888: LD_VAR 0 9
41892: PUSH
41893: LD_VAR 0 3
41897: ARRAY
41898: DIFF
41899: ST_TO_ADDR
// end ;
41900: GO 41809
41902: POP
41903: POP
// if p then
41904: LD_VAR 0 11
41908: IFFALSE 41933
// result := Replace ( result , 4 , p ) ;
41910: LD_ADDR_VAR 0 2
41914: PUSH
41915: LD_VAR 0 2
41919: PPUSH
41920: LD_INT 4
41922: PPUSH
41923: LD_VAR 0 11
41927: PPUSH
41928: CALL_OW 1
41932: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41933: LD_VAR 0 4
41937: PUSH
41938: LD_VAR 0 7
41942: PUSH
41943: LD_INT 6
41945: LESS
41946: AND
41947: IFFALSE 42135
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41949: LD_ADDR_VAR 0 9
41953: PUSH
41954: LD_VAR 0 4
41958: PUSH
41959: LD_VAR 0 8
41963: PUSH
41964: LD_VAR 0 7
41968: UNION
41969: DIFF
41970: PPUSH
41971: LD_INT 3
41973: PPUSH
41974: CALL 101981 0 2
41978: ST_TO_ADDR
// p := [ ] ;
41979: LD_ADDR_VAR 0 11
41983: PUSH
41984: EMPTY
41985: ST_TO_ADDR
// if sort then
41986: LD_VAR 0 9
41990: IFFALSE 42106
// for i = 1 to 6 - mech do
41992: LD_ADDR_VAR 0 3
41996: PUSH
41997: DOUBLE
41998: LD_INT 1
42000: DEC
42001: ST_TO_ADDR
42002: LD_INT 6
42004: PUSH
42005: LD_VAR 0 7
42009: MINUS
42010: PUSH
42011: FOR_TO
42012: IFFALSE 42104
// begin if i = sort then
42014: LD_VAR 0 3
42018: PUSH
42019: LD_VAR 0 9
42023: EQUAL
42024: IFFALSE 42028
// break ;
42026: GO 42104
// if GetClass ( i ) = 3 then
42028: LD_VAR 0 3
42032: PPUSH
42033: CALL_OW 257
42037: PUSH
42038: LD_INT 3
42040: EQUAL
42041: IFFALSE 42045
// continue ;
42043: GO 42011
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42045: LD_ADDR_VAR 0 11
42049: PUSH
42050: LD_VAR 0 11
42054: PPUSH
42055: LD_VAR 0 11
42059: PUSH
42060: LD_INT 1
42062: PLUS
42063: PPUSH
42064: LD_VAR 0 9
42068: PUSH
42069: LD_VAR 0 3
42073: ARRAY
42074: PPUSH
42075: CALL_OW 2
42079: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42080: LD_ADDR_VAR 0 4
42084: PUSH
42085: LD_VAR 0 4
42089: PUSH
42090: LD_VAR 0 9
42094: PUSH
42095: LD_VAR 0 3
42099: ARRAY
42100: DIFF
42101: ST_TO_ADDR
// end ;
42102: GO 42011
42104: POP
42105: POP
// if p then
42106: LD_VAR 0 11
42110: IFFALSE 42135
// result := Replace ( result , 3 , p ) ;
42112: LD_ADDR_VAR 0 2
42116: PUSH
42117: LD_VAR 0 2
42121: PPUSH
42122: LD_INT 3
42124: PPUSH
42125: LD_VAR 0 11
42129: PPUSH
42130: CALL_OW 1
42134: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
42135: LD_VAR 0 4
42139: PUSH
42140: LD_INT 6
42142: GREATER
42143: PUSH
42144: LD_VAR 0 6
42148: PUSH
42149: LD_INT 6
42151: LESS
42152: AND
42153: IFFALSE 42347
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42155: LD_ADDR_VAR 0 9
42159: PUSH
42160: LD_VAR 0 4
42164: PUSH
42165: LD_VAR 0 8
42169: PUSH
42170: LD_VAR 0 7
42174: UNION
42175: PUSH
42176: LD_VAR 0 6
42180: UNION
42181: DIFF
42182: PPUSH
42183: LD_INT 2
42185: PPUSH
42186: CALL 101981 0 2
42190: ST_TO_ADDR
// p := [ ] ;
42191: LD_ADDR_VAR 0 11
42195: PUSH
42196: EMPTY
42197: ST_TO_ADDR
// if sort then
42198: LD_VAR 0 9
42202: IFFALSE 42318
// for i = 1 to 6 - eng do
42204: LD_ADDR_VAR 0 3
42208: PUSH
42209: DOUBLE
42210: LD_INT 1
42212: DEC
42213: ST_TO_ADDR
42214: LD_INT 6
42216: PUSH
42217: LD_VAR 0 6
42221: MINUS
42222: PUSH
42223: FOR_TO
42224: IFFALSE 42316
// begin if i = sort then
42226: LD_VAR 0 3
42230: PUSH
42231: LD_VAR 0 9
42235: EQUAL
42236: IFFALSE 42240
// break ;
42238: GO 42316
// if GetClass ( i ) = 2 then
42240: LD_VAR 0 3
42244: PPUSH
42245: CALL_OW 257
42249: PUSH
42250: LD_INT 2
42252: EQUAL
42253: IFFALSE 42257
// continue ;
42255: GO 42223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42257: LD_ADDR_VAR 0 11
42261: PUSH
42262: LD_VAR 0 11
42266: PPUSH
42267: LD_VAR 0 11
42271: PUSH
42272: LD_INT 1
42274: PLUS
42275: PPUSH
42276: LD_VAR 0 9
42280: PUSH
42281: LD_VAR 0 3
42285: ARRAY
42286: PPUSH
42287: CALL_OW 2
42291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42292: LD_ADDR_VAR 0 4
42296: PUSH
42297: LD_VAR 0 4
42301: PUSH
42302: LD_VAR 0 9
42306: PUSH
42307: LD_VAR 0 3
42311: ARRAY
42312: DIFF
42313: ST_TO_ADDR
// end ;
42314: GO 42223
42316: POP
42317: POP
// if p then
42318: LD_VAR 0 11
42322: IFFALSE 42347
// result := Replace ( result , 2 , p ) ;
42324: LD_ADDR_VAR 0 2
42328: PUSH
42329: LD_VAR 0 2
42333: PPUSH
42334: LD_INT 2
42336: PPUSH
42337: LD_VAR 0 11
42341: PPUSH
42342: CALL_OW 1
42346: ST_TO_ADDR
// end ; exit ;
42347: GO 43735
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42349: LD_EXP 124
42353: PUSH
42354: LD_EXP 123
42358: PUSH
42359: LD_VAR 0 1
42363: ARRAY
42364: ARRAY
42365: NOT
42366: PUSH
42367: LD_EXP 97
42371: PUSH
42372: LD_VAR 0 1
42376: ARRAY
42377: PPUSH
42378: LD_INT 30
42380: PUSH
42381: LD_INT 3
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PPUSH
42388: CALL_OW 72
42392: AND
42393: PUSH
42394: LD_EXP 102
42398: PUSH
42399: LD_VAR 0 1
42403: ARRAY
42404: AND
42405: IFFALSE 43013
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42407: LD_ADDR_EXP 139
42411: PUSH
42412: LD_EXP 139
42416: PPUSH
42417: LD_VAR 0 1
42421: PPUSH
42422: LD_INT 5
42424: PPUSH
42425: CALL_OW 1
42429: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42430: LD_ADDR_VAR 0 2
42434: PUSH
42435: LD_INT 0
42437: PUSH
42438: LD_INT 0
42440: PUSH
42441: LD_INT 0
42443: PUSH
42444: LD_INT 0
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// if sci > 1 then
42453: LD_VAR 0 8
42457: PUSH
42458: LD_INT 1
42460: GREATER
42461: IFFALSE 42489
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42463: LD_ADDR_VAR 0 4
42467: PUSH
42468: LD_VAR 0 4
42472: PUSH
42473: LD_VAR 0 8
42477: PUSH
42478: LD_VAR 0 8
42482: PUSH
42483: LD_INT 1
42485: ARRAY
42486: DIFF
42487: DIFF
42488: ST_TO_ADDR
// if tmp and not sci then
42489: LD_VAR 0 4
42493: PUSH
42494: LD_VAR 0 8
42498: NOT
42499: AND
42500: IFFALSE 42569
// begin sort := SortBySkill ( tmp , 4 ) ;
42502: LD_ADDR_VAR 0 9
42506: PUSH
42507: LD_VAR 0 4
42511: PPUSH
42512: LD_INT 4
42514: PPUSH
42515: CALL 101981 0 2
42519: ST_TO_ADDR
// if sort then
42520: LD_VAR 0 9
42524: IFFALSE 42540
// p := sort [ 1 ] ;
42526: LD_ADDR_VAR 0 11
42530: PUSH
42531: LD_VAR 0 9
42535: PUSH
42536: LD_INT 1
42538: ARRAY
42539: ST_TO_ADDR
// if p then
42540: LD_VAR 0 11
42544: IFFALSE 42569
// result := Replace ( result , 4 , p ) ;
42546: LD_ADDR_VAR 0 2
42550: PUSH
42551: LD_VAR 0 2
42555: PPUSH
42556: LD_INT 4
42558: PPUSH
42559: LD_VAR 0 11
42563: PPUSH
42564: CALL_OW 1
42568: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42569: LD_ADDR_VAR 0 4
42573: PUSH
42574: LD_VAR 0 4
42578: PUSH
42579: LD_VAR 0 7
42583: DIFF
42584: ST_TO_ADDR
// if tmp and mech < 6 then
42585: LD_VAR 0 4
42589: PUSH
42590: LD_VAR 0 7
42594: PUSH
42595: LD_INT 6
42597: LESS
42598: AND
42599: IFFALSE 42787
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42601: LD_ADDR_VAR 0 9
42605: PUSH
42606: LD_VAR 0 4
42610: PUSH
42611: LD_VAR 0 8
42615: PUSH
42616: LD_VAR 0 7
42620: UNION
42621: DIFF
42622: PPUSH
42623: LD_INT 3
42625: PPUSH
42626: CALL 101981 0 2
42630: ST_TO_ADDR
// p := [ ] ;
42631: LD_ADDR_VAR 0 11
42635: PUSH
42636: EMPTY
42637: ST_TO_ADDR
// if sort then
42638: LD_VAR 0 9
42642: IFFALSE 42758
// for i = 1 to 6 - mech do
42644: LD_ADDR_VAR 0 3
42648: PUSH
42649: DOUBLE
42650: LD_INT 1
42652: DEC
42653: ST_TO_ADDR
42654: LD_INT 6
42656: PUSH
42657: LD_VAR 0 7
42661: MINUS
42662: PUSH
42663: FOR_TO
42664: IFFALSE 42756
// begin if i = sort then
42666: LD_VAR 0 3
42670: PUSH
42671: LD_VAR 0 9
42675: EQUAL
42676: IFFALSE 42680
// break ;
42678: GO 42756
// if GetClass ( i ) = 3 then
42680: LD_VAR 0 3
42684: PPUSH
42685: CALL_OW 257
42689: PUSH
42690: LD_INT 3
42692: EQUAL
42693: IFFALSE 42697
// continue ;
42695: GO 42663
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42697: LD_ADDR_VAR 0 11
42701: PUSH
42702: LD_VAR 0 11
42706: PPUSH
42707: LD_VAR 0 11
42711: PUSH
42712: LD_INT 1
42714: PLUS
42715: PPUSH
42716: LD_VAR 0 9
42720: PUSH
42721: LD_VAR 0 3
42725: ARRAY
42726: PPUSH
42727: CALL_OW 2
42731: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42732: LD_ADDR_VAR 0 4
42736: PUSH
42737: LD_VAR 0 4
42741: PUSH
42742: LD_VAR 0 9
42746: PUSH
42747: LD_VAR 0 3
42751: ARRAY
42752: DIFF
42753: ST_TO_ADDR
// end ;
42754: GO 42663
42756: POP
42757: POP
// if p then
42758: LD_VAR 0 11
42762: IFFALSE 42787
// result := Replace ( result , 3 , p ) ;
42764: LD_ADDR_VAR 0 2
42768: PUSH
42769: LD_VAR 0 2
42773: PPUSH
42774: LD_INT 3
42776: PPUSH
42777: LD_VAR 0 11
42781: PPUSH
42782: CALL_OW 1
42786: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42787: LD_ADDR_VAR 0 4
42791: PUSH
42792: LD_VAR 0 4
42796: PUSH
42797: LD_VAR 0 6
42801: DIFF
42802: ST_TO_ADDR
// if tmp and eng < 6 then
42803: LD_VAR 0 4
42807: PUSH
42808: LD_VAR 0 6
42812: PUSH
42813: LD_INT 6
42815: LESS
42816: AND
42817: IFFALSE 43011
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42819: LD_ADDR_VAR 0 9
42823: PUSH
42824: LD_VAR 0 4
42828: PUSH
42829: LD_VAR 0 8
42833: PUSH
42834: LD_VAR 0 7
42838: UNION
42839: PUSH
42840: LD_VAR 0 6
42844: UNION
42845: DIFF
42846: PPUSH
42847: LD_INT 2
42849: PPUSH
42850: CALL 101981 0 2
42854: ST_TO_ADDR
// p := [ ] ;
42855: LD_ADDR_VAR 0 11
42859: PUSH
42860: EMPTY
42861: ST_TO_ADDR
// if sort then
42862: LD_VAR 0 9
42866: IFFALSE 42982
// for i = 1 to 6 - eng do
42868: LD_ADDR_VAR 0 3
42872: PUSH
42873: DOUBLE
42874: LD_INT 1
42876: DEC
42877: ST_TO_ADDR
42878: LD_INT 6
42880: PUSH
42881: LD_VAR 0 6
42885: MINUS
42886: PUSH
42887: FOR_TO
42888: IFFALSE 42980
// begin if i = sort then
42890: LD_VAR 0 3
42894: PUSH
42895: LD_VAR 0 9
42899: EQUAL
42900: IFFALSE 42904
// break ;
42902: GO 42980
// if GetClass ( i ) = 2 then
42904: LD_VAR 0 3
42908: PPUSH
42909: CALL_OW 257
42913: PUSH
42914: LD_INT 2
42916: EQUAL
42917: IFFALSE 42921
// continue ;
42919: GO 42887
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42921: LD_ADDR_VAR 0 11
42925: PUSH
42926: LD_VAR 0 11
42930: PPUSH
42931: LD_VAR 0 11
42935: PUSH
42936: LD_INT 1
42938: PLUS
42939: PPUSH
42940: LD_VAR 0 9
42944: PUSH
42945: LD_VAR 0 3
42949: ARRAY
42950: PPUSH
42951: CALL_OW 2
42955: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42956: LD_ADDR_VAR 0 4
42960: PUSH
42961: LD_VAR 0 4
42965: PUSH
42966: LD_VAR 0 9
42970: PUSH
42971: LD_VAR 0 3
42975: ARRAY
42976: DIFF
42977: ST_TO_ADDR
// end ;
42978: GO 42887
42980: POP
42981: POP
// if p then
42982: LD_VAR 0 11
42986: IFFALSE 43011
// result := Replace ( result , 2 , p ) ;
42988: LD_ADDR_VAR 0 2
42992: PUSH
42993: LD_VAR 0 2
42997: PPUSH
42998: LD_INT 2
43000: PPUSH
43001: LD_VAR 0 11
43005: PPUSH
43006: CALL_OW 1
43010: ST_TO_ADDR
// end ; exit ;
43011: GO 43735
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
43013: LD_EXP 124
43017: PUSH
43018: LD_EXP 123
43022: PUSH
43023: LD_VAR 0 1
43027: ARRAY
43028: ARRAY
43029: NOT
43030: PUSH
43031: LD_EXP 97
43035: PUSH
43036: LD_VAR 0 1
43040: ARRAY
43041: PPUSH
43042: LD_INT 30
43044: PUSH
43045: LD_INT 3
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PPUSH
43052: CALL_OW 72
43056: AND
43057: PUSH
43058: LD_EXP 102
43062: PUSH
43063: LD_VAR 0 1
43067: ARRAY
43068: NOT
43069: AND
43070: IFFALSE 43735
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
43072: LD_ADDR_EXP 139
43076: PUSH
43077: LD_EXP 139
43081: PPUSH
43082: LD_VAR 0 1
43086: PPUSH
43087: LD_INT 6
43089: PPUSH
43090: CALL_OW 1
43094: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43095: LD_ADDR_VAR 0 2
43099: PUSH
43100: LD_INT 0
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: LD_INT 0
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: LIST
43116: LIST
43117: ST_TO_ADDR
// if sci >= 1 then
43118: LD_VAR 0 8
43122: PUSH
43123: LD_INT 1
43125: GREATEREQUAL
43126: IFFALSE 43148
// tmp := tmp diff sci [ 1 ] ;
43128: LD_ADDR_VAR 0 4
43132: PUSH
43133: LD_VAR 0 4
43137: PUSH
43138: LD_VAR 0 8
43142: PUSH
43143: LD_INT 1
43145: ARRAY
43146: DIFF
43147: ST_TO_ADDR
// if tmp and not sci then
43148: LD_VAR 0 4
43152: PUSH
43153: LD_VAR 0 8
43157: NOT
43158: AND
43159: IFFALSE 43228
// begin sort := SortBySkill ( tmp , 4 ) ;
43161: LD_ADDR_VAR 0 9
43165: PUSH
43166: LD_VAR 0 4
43170: PPUSH
43171: LD_INT 4
43173: PPUSH
43174: CALL 101981 0 2
43178: ST_TO_ADDR
// if sort then
43179: LD_VAR 0 9
43183: IFFALSE 43199
// p := sort [ 1 ] ;
43185: LD_ADDR_VAR 0 11
43189: PUSH
43190: LD_VAR 0 9
43194: PUSH
43195: LD_INT 1
43197: ARRAY
43198: ST_TO_ADDR
// if p then
43199: LD_VAR 0 11
43203: IFFALSE 43228
// result := Replace ( result , 4 , p ) ;
43205: LD_ADDR_VAR 0 2
43209: PUSH
43210: LD_VAR 0 2
43214: PPUSH
43215: LD_INT 4
43217: PPUSH
43218: LD_VAR 0 11
43222: PPUSH
43223: CALL_OW 1
43227: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43228: LD_ADDR_VAR 0 4
43232: PUSH
43233: LD_VAR 0 4
43237: PUSH
43238: LD_VAR 0 7
43242: DIFF
43243: ST_TO_ADDR
// if tmp and mech < 6 then
43244: LD_VAR 0 4
43248: PUSH
43249: LD_VAR 0 7
43253: PUSH
43254: LD_INT 6
43256: LESS
43257: AND
43258: IFFALSE 43440
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43260: LD_ADDR_VAR 0 9
43264: PUSH
43265: LD_VAR 0 4
43269: PUSH
43270: LD_VAR 0 7
43274: DIFF
43275: PPUSH
43276: LD_INT 3
43278: PPUSH
43279: CALL 101981 0 2
43283: ST_TO_ADDR
// p := [ ] ;
43284: LD_ADDR_VAR 0 11
43288: PUSH
43289: EMPTY
43290: ST_TO_ADDR
// if sort then
43291: LD_VAR 0 9
43295: IFFALSE 43411
// for i = 1 to 6 - mech do
43297: LD_ADDR_VAR 0 3
43301: PUSH
43302: DOUBLE
43303: LD_INT 1
43305: DEC
43306: ST_TO_ADDR
43307: LD_INT 6
43309: PUSH
43310: LD_VAR 0 7
43314: MINUS
43315: PUSH
43316: FOR_TO
43317: IFFALSE 43409
// begin if i = sort then
43319: LD_VAR 0 3
43323: PUSH
43324: LD_VAR 0 9
43328: EQUAL
43329: IFFALSE 43333
// break ;
43331: GO 43409
// if GetClass ( i ) = 3 then
43333: LD_VAR 0 3
43337: PPUSH
43338: CALL_OW 257
43342: PUSH
43343: LD_INT 3
43345: EQUAL
43346: IFFALSE 43350
// continue ;
43348: GO 43316
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43350: LD_ADDR_VAR 0 11
43354: PUSH
43355: LD_VAR 0 11
43359: PPUSH
43360: LD_VAR 0 11
43364: PUSH
43365: LD_INT 1
43367: PLUS
43368: PPUSH
43369: LD_VAR 0 9
43373: PUSH
43374: LD_VAR 0 3
43378: ARRAY
43379: PPUSH
43380: CALL_OW 2
43384: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43385: LD_ADDR_VAR 0 4
43389: PUSH
43390: LD_VAR 0 4
43394: PUSH
43395: LD_VAR 0 9
43399: PUSH
43400: LD_VAR 0 3
43404: ARRAY
43405: DIFF
43406: ST_TO_ADDR
// end ;
43407: GO 43316
43409: POP
43410: POP
// if p then
43411: LD_VAR 0 11
43415: IFFALSE 43440
// result := Replace ( result , 3 , p ) ;
43417: LD_ADDR_VAR 0 2
43421: PUSH
43422: LD_VAR 0 2
43426: PPUSH
43427: LD_INT 3
43429: PPUSH
43430: LD_VAR 0 11
43434: PPUSH
43435: CALL_OW 1
43439: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43440: LD_ADDR_VAR 0 4
43444: PUSH
43445: LD_VAR 0 4
43449: PUSH
43450: LD_VAR 0 6
43454: DIFF
43455: ST_TO_ADDR
// if tmp and eng < 4 then
43456: LD_VAR 0 4
43460: PUSH
43461: LD_VAR 0 6
43465: PUSH
43466: LD_INT 4
43468: LESS
43469: AND
43470: IFFALSE 43660
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43472: LD_ADDR_VAR 0 9
43476: PUSH
43477: LD_VAR 0 4
43481: PUSH
43482: LD_VAR 0 7
43486: PUSH
43487: LD_VAR 0 6
43491: UNION
43492: DIFF
43493: PPUSH
43494: LD_INT 2
43496: PPUSH
43497: CALL 101981 0 2
43501: ST_TO_ADDR
// p := [ ] ;
43502: LD_ADDR_VAR 0 11
43506: PUSH
43507: EMPTY
43508: ST_TO_ADDR
// if sort then
43509: LD_VAR 0 9
43513: IFFALSE 43629
// for i = 1 to 4 - eng do
43515: LD_ADDR_VAR 0 3
43519: PUSH
43520: DOUBLE
43521: LD_INT 1
43523: DEC
43524: ST_TO_ADDR
43525: LD_INT 4
43527: PUSH
43528: LD_VAR 0 6
43532: MINUS
43533: PUSH
43534: FOR_TO
43535: IFFALSE 43627
// begin if i = sort then
43537: LD_VAR 0 3
43541: PUSH
43542: LD_VAR 0 9
43546: EQUAL
43547: IFFALSE 43551
// break ;
43549: GO 43627
// if GetClass ( i ) = 2 then
43551: LD_VAR 0 3
43555: PPUSH
43556: CALL_OW 257
43560: PUSH
43561: LD_INT 2
43563: EQUAL
43564: IFFALSE 43568
// continue ;
43566: GO 43534
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43568: LD_ADDR_VAR 0 11
43572: PUSH
43573: LD_VAR 0 11
43577: PPUSH
43578: LD_VAR 0 11
43582: PUSH
43583: LD_INT 1
43585: PLUS
43586: PPUSH
43587: LD_VAR 0 9
43591: PUSH
43592: LD_VAR 0 3
43596: ARRAY
43597: PPUSH
43598: CALL_OW 2
43602: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43603: LD_ADDR_VAR 0 4
43607: PUSH
43608: LD_VAR 0 4
43612: PUSH
43613: LD_VAR 0 9
43617: PUSH
43618: LD_VAR 0 3
43622: ARRAY
43623: DIFF
43624: ST_TO_ADDR
// end ;
43625: GO 43534
43627: POP
43628: POP
// if p then
43629: LD_VAR 0 11
43633: IFFALSE 43658
// result := Replace ( result , 2 , p ) ;
43635: LD_ADDR_VAR 0 2
43639: PUSH
43640: LD_VAR 0 2
43644: PPUSH
43645: LD_INT 2
43647: PPUSH
43648: LD_VAR 0 11
43652: PPUSH
43653: CALL_OW 1
43657: ST_TO_ADDR
// end else
43658: GO 43704
// for i = eng downto 5 do
43660: LD_ADDR_VAR 0 3
43664: PUSH
43665: DOUBLE
43666: LD_VAR 0 6
43670: INC
43671: ST_TO_ADDR
43672: LD_INT 5
43674: PUSH
43675: FOR_DOWNTO
43676: IFFALSE 43702
// tmp := tmp union eng [ i ] ;
43678: LD_ADDR_VAR 0 4
43682: PUSH
43683: LD_VAR 0 4
43687: PUSH
43688: LD_VAR 0 6
43692: PUSH
43693: LD_VAR 0 3
43697: ARRAY
43698: UNION
43699: ST_TO_ADDR
43700: GO 43675
43702: POP
43703: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43704: LD_ADDR_VAR 0 2
43708: PUSH
43709: LD_VAR 0 2
43713: PPUSH
43714: LD_INT 1
43716: PPUSH
43717: LD_VAR 0 4
43721: PUSH
43722: LD_VAR 0 5
43726: DIFF
43727: PPUSH
43728: CALL_OW 1
43732: ST_TO_ADDR
// exit ;
43733: GO 43735
// end ; end ;
43735: LD_VAR 0 2
43739: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43740: LD_INT 0
43742: PPUSH
43743: PPUSH
43744: PPUSH
// if not mc_bases then
43745: LD_EXP 97
43749: NOT
43750: IFFALSE 43754
// exit ;
43752: GO 43896
// for i = 1 to mc_bases do
43754: LD_ADDR_VAR 0 2
43758: PUSH
43759: DOUBLE
43760: LD_INT 1
43762: DEC
43763: ST_TO_ADDR
43764: LD_EXP 97
43768: PUSH
43769: FOR_TO
43770: IFFALSE 43887
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43772: LD_ADDR_VAR 0 3
43776: PUSH
43777: LD_EXP 97
43781: PUSH
43782: LD_VAR 0 2
43786: ARRAY
43787: PPUSH
43788: LD_INT 21
43790: PUSH
43791: LD_INT 3
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: PUSH
43801: LD_INT 2
43803: PUSH
43804: LD_INT 30
43806: PUSH
43807: LD_INT 29
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 30
43816: PUSH
43817: LD_INT 30
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: LIST
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 3
43835: PUSH
43836: LD_INT 24
43838: PUSH
43839: LD_INT 1000
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: LIST
43854: PPUSH
43855: CALL_OW 72
43859: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43860: LD_ADDR_EXP 98
43864: PUSH
43865: LD_EXP 98
43869: PPUSH
43870: LD_VAR 0 2
43874: PPUSH
43875: LD_VAR 0 3
43879: PPUSH
43880: CALL_OW 1
43884: ST_TO_ADDR
// end ;
43885: GO 43769
43887: POP
43888: POP
// RaiseSailEvent ( 101 ) ;
43889: LD_INT 101
43891: PPUSH
43892: CALL_OW 427
// end ;
43896: LD_VAR 0 1
43900: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43901: LD_INT 0
43903: PPUSH
43904: PPUSH
43905: PPUSH
43906: PPUSH
43907: PPUSH
43908: PPUSH
43909: PPUSH
// if not mc_bases then
43910: LD_EXP 97
43914: NOT
43915: IFFALSE 43919
// exit ;
43917: GO 44481
// for i = 1 to mc_bases do
43919: LD_ADDR_VAR 0 2
43923: PUSH
43924: DOUBLE
43925: LD_INT 1
43927: DEC
43928: ST_TO_ADDR
43929: LD_EXP 97
43933: PUSH
43934: FOR_TO
43935: IFFALSE 44472
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43937: LD_ADDR_VAR 0 5
43941: PUSH
43942: LD_EXP 97
43946: PUSH
43947: LD_VAR 0 2
43951: ARRAY
43952: PUSH
43953: LD_EXP 126
43957: PUSH
43958: LD_VAR 0 2
43962: ARRAY
43963: UNION
43964: PPUSH
43965: LD_INT 21
43967: PUSH
43968: LD_INT 1
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 1
43977: PUSH
43978: LD_INT 3
43980: PUSH
43981: LD_INT 54
43983: PUSH
43984: EMPTY
43985: LIST
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 3
43993: PUSH
43994: LD_INT 24
43996: PUSH
43997: LD_INT 1000
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: LIST
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PPUSH
44017: CALL_OW 72
44021: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
44022: LD_ADDR_VAR 0 6
44026: PUSH
44027: LD_EXP 97
44031: PUSH
44032: LD_VAR 0 2
44036: ARRAY
44037: PPUSH
44038: LD_INT 21
44040: PUSH
44041: LD_INT 1
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 1
44050: PUSH
44051: LD_INT 3
44053: PUSH
44054: LD_INT 54
44056: PUSH
44057: EMPTY
44058: LIST
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 3
44066: PUSH
44067: LD_INT 24
44069: PUSH
44070: LD_INT 250
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: LIST
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PPUSH
44090: CALL_OW 72
44094: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
44095: LD_ADDR_VAR 0 7
44099: PUSH
44100: LD_VAR 0 5
44104: PUSH
44105: LD_VAR 0 6
44109: DIFF
44110: ST_TO_ADDR
// if not need_heal_1 then
44111: LD_VAR 0 6
44115: NOT
44116: IFFALSE 44149
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
44118: LD_ADDR_EXP 100
44122: PUSH
44123: LD_EXP 100
44127: PPUSH
44128: LD_VAR 0 2
44132: PUSH
44133: LD_INT 1
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PPUSH
44140: EMPTY
44141: PPUSH
44142: CALL 71160 0 3
44146: ST_TO_ADDR
44147: GO 44219
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
44149: LD_ADDR_EXP 100
44153: PUSH
44154: LD_EXP 100
44158: PPUSH
44159: LD_VAR 0 2
44163: PUSH
44164: LD_INT 1
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PPUSH
44171: LD_EXP 100
44175: PUSH
44176: LD_VAR 0 2
44180: ARRAY
44181: PUSH
44182: LD_INT 1
44184: ARRAY
44185: PPUSH
44186: LD_INT 3
44188: PUSH
44189: LD_INT 24
44191: PUSH
44192: LD_INT 1000
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PPUSH
44203: CALL_OW 72
44207: PUSH
44208: LD_VAR 0 6
44212: UNION
44213: PPUSH
44214: CALL 71160 0 3
44218: ST_TO_ADDR
// if not need_heal_2 then
44219: LD_VAR 0 7
44223: NOT
44224: IFFALSE 44257
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44226: LD_ADDR_EXP 100
44230: PUSH
44231: LD_EXP 100
44235: PPUSH
44236: LD_VAR 0 2
44240: PUSH
44241: LD_INT 2
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PPUSH
44248: EMPTY
44249: PPUSH
44250: CALL 71160 0 3
44254: ST_TO_ADDR
44255: GO 44289
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44257: LD_ADDR_EXP 100
44261: PUSH
44262: LD_EXP 100
44266: PPUSH
44267: LD_VAR 0 2
44271: PUSH
44272: LD_INT 2
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PPUSH
44279: LD_VAR 0 7
44283: PPUSH
44284: CALL 71160 0 3
44288: ST_TO_ADDR
// if need_heal_2 then
44289: LD_VAR 0 7
44293: IFFALSE 44454
// for j in need_heal_2 do
44295: LD_ADDR_VAR 0 3
44299: PUSH
44300: LD_VAR 0 7
44304: PUSH
44305: FOR_IN
44306: IFFALSE 44452
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44308: LD_ADDR_VAR 0 5
44312: PUSH
44313: LD_EXP 97
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PPUSH
44324: LD_INT 2
44326: PUSH
44327: LD_INT 30
44329: PUSH
44330: LD_INT 6
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 30
44339: PUSH
44340: LD_INT 7
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 30
44349: PUSH
44350: LD_INT 8
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 30
44359: PUSH
44360: LD_INT 0
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 30
44369: PUSH
44370: LD_INT 1
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: PPUSH
44385: CALL_OW 72
44389: ST_TO_ADDR
// if tmp then
44390: LD_VAR 0 5
44394: IFFALSE 44450
// begin k := NearestUnitToUnit ( tmp , j ) ;
44396: LD_ADDR_VAR 0 4
44400: PUSH
44401: LD_VAR 0 5
44405: PPUSH
44406: LD_VAR 0 3
44410: PPUSH
44411: CALL_OW 74
44415: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44416: LD_VAR 0 3
44420: PPUSH
44421: LD_VAR 0 4
44425: PPUSH
44426: CALL_OW 296
44430: PUSH
44431: LD_INT 5
44433: GREATER
44434: IFFALSE 44450
// ComMoveToNearbyEntrance ( j , k ) ;
44436: LD_VAR 0 3
44440: PPUSH
44441: LD_VAR 0 4
44445: PPUSH
44446: CALL 104349 0 2
// end ; end ;
44450: GO 44305
44452: POP
44453: POP
// if not need_heal_1 and not need_heal_2 then
44454: LD_VAR 0 6
44458: NOT
44459: PUSH
44460: LD_VAR 0 7
44464: NOT
44465: AND
44466: IFFALSE 44470
// continue ;
44468: GO 43934
// end ;
44470: GO 43934
44472: POP
44473: POP
// RaiseSailEvent ( 102 ) ;
44474: LD_INT 102
44476: PPUSH
44477: CALL_OW 427
// end ;
44481: LD_VAR 0 1
44485: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44486: LD_INT 0
44488: PPUSH
44489: PPUSH
44490: PPUSH
44491: PPUSH
44492: PPUSH
44493: PPUSH
44494: PPUSH
44495: PPUSH
// if not mc_bases then
44496: LD_EXP 97
44500: NOT
44501: IFFALSE 44505
// exit ;
44503: GO 45384
// for i = 1 to mc_bases do
44505: LD_ADDR_VAR 0 2
44509: PUSH
44510: DOUBLE
44511: LD_INT 1
44513: DEC
44514: ST_TO_ADDR
44515: LD_EXP 97
44519: PUSH
44520: FOR_TO
44521: IFFALSE 45382
// begin if not mc_building_need_repair [ i ] then
44523: LD_EXP 98
44527: PUSH
44528: LD_VAR 0 2
44532: ARRAY
44533: NOT
44534: IFFALSE 44719
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44536: LD_ADDR_VAR 0 6
44540: PUSH
44541: LD_EXP 116
44545: PUSH
44546: LD_VAR 0 2
44550: ARRAY
44551: PPUSH
44552: LD_INT 3
44554: PUSH
44555: LD_INT 24
44557: PUSH
44558: LD_INT 1000
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 2
44571: PUSH
44572: LD_INT 34
44574: PUSH
44575: LD_INT 13
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 34
44584: PUSH
44585: LD_INT 52
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 34
44594: PUSH
44595: LD_INT 88
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PPUSH
44612: CALL_OW 72
44616: ST_TO_ADDR
// if cranes then
44617: LD_VAR 0 6
44621: IFFALSE 44683
// for j in cranes do
44623: LD_ADDR_VAR 0 3
44627: PUSH
44628: LD_VAR 0 6
44632: PUSH
44633: FOR_IN
44634: IFFALSE 44681
// if not IsInArea ( j , mc_parking [ i ] ) then
44636: LD_VAR 0 3
44640: PPUSH
44641: LD_EXP 121
44645: PUSH
44646: LD_VAR 0 2
44650: ARRAY
44651: PPUSH
44652: CALL_OW 308
44656: NOT
44657: IFFALSE 44679
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44659: LD_VAR 0 3
44663: PPUSH
44664: LD_EXP 121
44668: PUSH
44669: LD_VAR 0 2
44673: ARRAY
44674: PPUSH
44675: CALL_OW 113
44679: GO 44633
44681: POP
44682: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44683: LD_ADDR_EXP 99
44687: PUSH
44688: LD_EXP 99
44692: PPUSH
44693: LD_VAR 0 2
44697: PPUSH
44698: EMPTY
44699: PPUSH
44700: CALL_OW 1
44704: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44705: LD_VAR 0 2
44709: PPUSH
44710: LD_INT 101
44712: PPUSH
44713: CALL 39573 0 2
// continue ;
44717: GO 44520
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44719: LD_ADDR_EXP 103
44723: PUSH
44724: LD_EXP 103
44728: PPUSH
44729: LD_VAR 0 2
44733: PPUSH
44734: EMPTY
44735: PPUSH
44736: CALL_OW 1
44740: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44741: LD_VAR 0 2
44745: PPUSH
44746: LD_INT 103
44748: PPUSH
44749: CALL 39573 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44753: LD_ADDR_VAR 0 5
44757: PUSH
44758: LD_EXP 97
44762: PUSH
44763: LD_VAR 0 2
44767: ARRAY
44768: PUSH
44769: LD_EXP 126
44773: PUSH
44774: LD_VAR 0 2
44778: ARRAY
44779: UNION
44780: PPUSH
44781: LD_INT 2
44783: PUSH
44784: LD_INT 25
44786: PUSH
44787: LD_INT 2
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 25
44796: PUSH
44797: LD_INT 16
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: LIST
44808: PUSH
44809: EMPTY
44810: LIST
44811: PPUSH
44812: CALL_OW 72
44816: ST_TO_ADDR
// if mc_need_heal [ i ] then
44817: LD_EXP 100
44821: PUSH
44822: LD_VAR 0 2
44826: ARRAY
44827: IFFALSE 44871
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44829: LD_ADDR_VAR 0 5
44833: PUSH
44834: LD_VAR 0 5
44838: PUSH
44839: LD_EXP 100
44843: PUSH
44844: LD_VAR 0 2
44848: ARRAY
44849: PUSH
44850: LD_INT 1
44852: ARRAY
44853: PUSH
44854: LD_EXP 100
44858: PUSH
44859: LD_VAR 0 2
44863: ARRAY
44864: PUSH
44865: LD_INT 2
44867: ARRAY
44868: UNION
44869: DIFF
44870: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44871: LD_ADDR_VAR 0 6
44875: PUSH
44876: LD_EXP 116
44880: PUSH
44881: LD_VAR 0 2
44885: ARRAY
44886: PPUSH
44887: LD_INT 2
44889: PUSH
44890: LD_INT 34
44892: PUSH
44893: LD_INT 13
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 34
44902: PUSH
44903: LD_INT 52
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 34
44912: PUSH
44913: LD_INT 88
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: PPUSH
44926: CALL_OW 72
44930: ST_TO_ADDR
// if cranes then
44931: LD_VAR 0 6
44935: IFFALSE 45071
// begin for j in cranes do
44937: LD_ADDR_VAR 0 3
44941: PUSH
44942: LD_VAR 0 6
44946: PUSH
44947: FOR_IN
44948: IFFALSE 45069
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44950: LD_VAR 0 3
44954: PPUSH
44955: CALL_OW 256
44959: PUSH
44960: LD_INT 1000
44962: EQUAL
44963: PUSH
44964: LD_VAR 0 3
44968: PPUSH
44969: CALL_OW 314
44973: NOT
44974: AND
44975: IFFALSE 45009
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44977: LD_VAR 0 3
44981: PPUSH
44982: LD_EXP 98
44986: PUSH
44987: LD_VAR 0 2
44991: ARRAY
44992: PPUSH
44993: LD_VAR 0 3
44997: PPUSH
44998: CALL_OW 74
45002: PPUSH
45003: CALL_OW 130
45007: GO 45067
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
45009: LD_VAR 0 3
45013: PPUSH
45014: CALL_OW 256
45018: PUSH
45019: LD_INT 500
45021: LESS
45022: PUSH
45023: LD_VAR 0 3
45027: PPUSH
45028: LD_EXP 121
45032: PUSH
45033: LD_VAR 0 2
45037: ARRAY
45038: PPUSH
45039: CALL_OW 308
45043: NOT
45044: AND
45045: IFFALSE 45067
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45047: LD_VAR 0 3
45051: PPUSH
45052: LD_EXP 121
45056: PUSH
45057: LD_VAR 0 2
45061: ARRAY
45062: PPUSH
45063: CALL_OW 113
// end ;
45067: GO 44947
45069: POP
45070: POP
// end ; if tmp > 3 then
45071: LD_VAR 0 5
45075: PUSH
45076: LD_INT 3
45078: GREATER
45079: IFFALSE 45099
// tmp := ShrinkArray ( tmp , 4 ) ;
45081: LD_ADDR_VAR 0 5
45085: PUSH
45086: LD_VAR 0 5
45090: PPUSH
45091: LD_INT 4
45093: PPUSH
45094: CALL 103787 0 2
45098: ST_TO_ADDR
// if not tmp then
45099: LD_VAR 0 5
45103: NOT
45104: IFFALSE 45108
// continue ;
45106: GO 44520
// for j in tmp do
45108: LD_ADDR_VAR 0 3
45112: PUSH
45113: LD_VAR 0 5
45117: PUSH
45118: FOR_IN
45119: IFFALSE 45378
// begin if IsInUnit ( j ) then
45121: LD_VAR 0 3
45125: PPUSH
45126: CALL_OW 310
45130: IFFALSE 45141
// ComExitBuilding ( j ) ;
45132: LD_VAR 0 3
45136: PPUSH
45137: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
45141: LD_VAR 0 3
45145: PUSH
45146: LD_EXP 99
45150: PUSH
45151: LD_VAR 0 2
45155: ARRAY
45156: IN
45157: NOT
45158: IFFALSE 45216
// begin SetTag ( j , 101 ) ;
45160: LD_VAR 0 3
45164: PPUSH
45165: LD_INT 101
45167: PPUSH
45168: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45172: LD_ADDR_EXP 99
45176: PUSH
45177: LD_EXP 99
45181: PPUSH
45182: LD_VAR 0 2
45186: PUSH
45187: LD_EXP 99
45191: PUSH
45192: LD_VAR 0 2
45196: ARRAY
45197: PUSH
45198: LD_INT 1
45200: PLUS
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PPUSH
45206: LD_VAR 0 3
45210: PPUSH
45211: CALL 71160 0 3
45215: ST_TO_ADDR
// end ; wait ( 1 ) ;
45216: LD_INT 1
45218: PPUSH
45219: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45223: LD_ADDR_VAR 0 7
45227: PUSH
45228: LD_EXP 98
45232: PUSH
45233: LD_VAR 0 2
45237: ARRAY
45238: ST_TO_ADDR
// if mc_scan [ i ] then
45239: LD_EXP 120
45243: PUSH
45244: LD_VAR 0 2
45248: ARRAY
45249: IFFALSE 45311
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45251: LD_ADDR_VAR 0 7
45255: PUSH
45256: LD_EXP 98
45260: PUSH
45261: LD_VAR 0 2
45265: ARRAY
45266: PPUSH
45267: LD_INT 3
45269: PUSH
45270: LD_INT 30
45272: PUSH
45273: LD_INT 32
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 30
45282: PUSH
45283: LD_INT 33
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 30
45292: PUSH
45293: LD_INT 31
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: PPUSH
45306: CALL_OW 72
45310: ST_TO_ADDR
// if not to_repair_tmp then
45311: LD_VAR 0 7
45315: NOT
45316: IFFALSE 45320
// continue ;
45318: GO 45118
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45320: LD_ADDR_VAR 0 8
45324: PUSH
45325: LD_VAR 0 7
45329: PPUSH
45330: LD_VAR 0 3
45334: PPUSH
45335: CALL_OW 74
45339: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45340: LD_VAR 0 8
45344: PPUSH
45345: LD_INT 16
45347: PPUSH
45348: CALL 73757 0 2
45352: PUSH
45353: LD_INT 4
45355: ARRAY
45356: PUSH
45357: LD_INT 10
45359: LESS
45360: IFFALSE 45376
// ComRepairBuilding ( j , to_repair ) ;
45362: LD_VAR 0 3
45366: PPUSH
45367: LD_VAR 0 8
45371: PPUSH
45372: CALL_OW 130
// end ;
45376: GO 45118
45378: POP
45379: POP
// end ;
45380: GO 44520
45382: POP
45383: POP
// end ;
45384: LD_VAR 0 1
45388: RET
// export function MC_Heal ; var i , j , tmp ; begin
45389: LD_INT 0
45391: PPUSH
45392: PPUSH
45393: PPUSH
45394: PPUSH
// if not mc_bases then
45395: LD_EXP 97
45399: NOT
45400: IFFALSE 45404
// exit ;
45402: GO 45806
// for i = 1 to mc_bases do
45404: LD_ADDR_VAR 0 2
45408: PUSH
45409: DOUBLE
45410: LD_INT 1
45412: DEC
45413: ST_TO_ADDR
45414: LD_EXP 97
45418: PUSH
45419: FOR_TO
45420: IFFALSE 45804
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45422: LD_EXP 100
45426: PUSH
45427: LD_VAR 0 2
45431: ARRAY
45432: PUSH
45433: LD_INT 1
45435: ARRAY
45436: NOT
45437: PUSH
45438: LD_EXP 100
45442: PUSH
45443: LD_VAR 0 2
45447: ARRAY
45448: PUSH
45449: LD_INT 2
45451: ARRAY
45452: NOT
45453: AND
45454: IFFALSE 45492
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45456: LD_ADDR_EXP 101
45460: PUSH
45461: LD_EXP 101
45465: PPUSH
45466: LD_VAR 0 2
45470: PPUSH
45471: EMPTY
45472: PPUSH
45473: CALL_OW 1
45477: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45478: LD_VAR 0 2
45482: PPUSH
45483: LD_INT 102
45485: PPUSH
45486: CALL 39573 0 2
// continue ;
45490: GO 45419
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45492: LD_ADDR_VAR 0 4
45496: PUSH
45497: LD_EXP 97
45501: PUSH
45502: LD_VAR 0 2
45506: ARRAY
45507: PPUSH
45508: LD_INT 25
45510: PUSH
45511: LD_INT 4
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PPUSH
45518: CALL_OW 72
45522: ST_TO_ADDR
// if not tmp then
45523: LD_VAR 0 4
45527: NOT
45528: IFFALSE 45532
// continue ;
45530: GO 45419
// if mc_taming [ i ] then
45532: LD_EXP 128
45536: PUSH
45537: LD_VAR 0 2
45541: ARRAY
45542: IFFALSE 45566
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45544: LD_ADDR_EXP 128
45548: PUSH
45549: LD_EXP 128
45553: PPUSH
45554: LD_VAR 0 2
45558: PPUSH
45559: EMPTY
45560: PPUSH
45561: CALL_OW 1
45565: ST_TO_ADDR
// for j in tmp do
45566: LD_ADDR_VAR 0 3
45570: PUSH
45571: LD_VAR 0 4
45575: PUSH
45576: FOR_IN
45577: IFFALSE 45800
// begin if IsInUnit ( j ) then
45579: LD_VAR 0 3
45583: PPUSH
45584: CALL_OW 310
45588: IFFALSE 45599
// ComExitBuilding ( j ) ;
45590: LD_VAR 0 3
45594: PPUSH
45595: CALL_OW 122
// if not j in mc_healers [ i ] then
45599: LD_VAR 0 3
45603: PUSH
45604: LD_EXP 101
45608: PUSH
45609: LD_VAR 0 2
45613: ARRAY
45614: IN
45615: NOT
45616: IFFALSE 45662
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45618: LD_ADDR_EXP 101
45622: PUSH
45623: LD_EXP 101
45627: PPUSH
45628: LD_VAR 0 2
45632: PUSH
45633: LD_EXP 101
45637: PUSH
45638: LD_VAR 0 2
45642: ARRAY
45643: PUSH
45644: LD_INT 1
45646: PLUS
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PPUSH
45652: LD_VAR 0 3
45656: PPUSH
45657: CALL 71160 0 3
45661: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45662: LD_VAR 0 3
45666: PPUSH
45667: CALL_OW 110
45671: PUSH
45672: LD_INT 102
45674: NONEQUAL
45675: IFFALSE 45689
// SetTag ( j , 102 ) ;
45677: LD_VAR 0 3
45681: PPUSH
45682: LD_INT 102
45684: PPUSH
45685: CALL_OW 109
// Wait ( 3 ) ;
45689: LD_INT 3
45691: PPUSH
45692: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45696: LD_EXP 100
45700: PUSH
45701: LD_VAR 0 2
45705: ARRAY
45706: PUSH
45707: LD_INT 1
45709: ARRAY
45710: IFFALSE 45742
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45712: LD_VAR 0 3
45716: PPUSH
45717: LD_EXP 100
45721: PUSH
45722: LD_VAR 0 2
45726: ARRAY
45727: PUSH
45728: LD_INT 1
45730: ARRAY
45731: PUSH
45732: LD_INT 1
45734: ARRAY
45735: PPUSH
45736: CALL_OW 128
45740: GO 45798
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45742: LD_VAR 0 3
45746: PPUSH
45747: CALL_OW 314
45751: NOT
45752: PUSH
45753: LD_EXP 100
45757: PUSH
45758: LD_VAR 0 2
45762: ARRAY
45763: PUSH
45764: LD_INT 2
45766: ARRAY
45767: AND
45768: IFFALSE 45798
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45770: LD_VAR 0 3
45774: PPUSH
45775: LD_EXP 100
45779: PUSH
45780: LD_VAR 0 2
45784: ARRAY
45785: PUSH
45786: LD_INT 2
45788: ARRAY
45789: PUSH
45790: LD_INT 1
45792: ARRAY
45793: PPUSH
45794: CALL_OW 128
// end ;
45798: GO 45576
45800: POP
45801: POP
// end ;
45802: GO 45419
45804: POP
45805: POP
// end ;
45806: LD_VAR 0 1
45810: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45811: LD_INT 0
45813: PPUSH
45814: PPUSH
45815: PPUSH
45816: PPUSH
45817: PPUSH
// if not mc_bases then
45818: LD_EXP 97
45822: NOT
45823: IFFALSE 45827
// exit ;
45825: GO 46998
// for i = 1 to mc_bases do
45827: LD_ADDR_VAR 0 2
45831: PUSH
45832: DOUBLE
45833: LD_INT 1
45835: DEC
45836: ST_TO_ADDR
45837: LD_EXP 97
45841: PUSH
45842: FOR_TO
45843: IFFALSE 46996
// begin if mc_scan [ i ] then
45845: LD_EXP 120
45849: PUSH
45850: LD_VAR 0 2
45854: ARRAY
45855: IFFALSE 45859
// continue ;
45857: GO 45842
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45859: LD_EXP 102
45863: PUSH
45864: LD_VAR 0 2
45868: ARRAY
45869: NOT
45870: PUSH
45871: LD_EXP 104
45875: PUSH
45876: LD_VAR 0 2
45880: ARRAY
45881: NOT
45882: AND
45883: PUSH
45884: LD_EXP 103
45888: PUSH
45889: LD_VAR 0 2
45893: ARRAY
45894: AND
45895: IFFALSE 45933
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45897: LD_ADDR_EXP 103
45901: PUSH
45902: LD_EXP 103
45906: PPUSH
45907: LD_VAR 0 2
45911: PPUSH
45912: EMPTY
45913: PPUSH
45914: CALL_OW 1
45918: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45919: LD_VAR 0 2
45923: PPUSH
45924: LD_INT 103
45926: PPUSH
45927: CALL 39573 0 2
// continue ;
45931: GO 45842
// end ; if mc_construct_list [ i ] then
45933: LD_EXP 104
45937: PUSH
45938: LD_VAR 0 2
45942: ARRAY
45943: IFFALSE 46163
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45945: LD_ADDR_VAR 0 4
45949: PUSH
45950: LD_EXP 97
45954: PUSH
45955: LD_VAR 0 2
45959: ARRAY
45960: PPUSH
45961: LD_INT 25
45963: PUSH
45964: LD_INT 2
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PPUSH
45971: CALL_OW 72
45975: PUSH
45976: LD_EXP 99
45980: PUSH
45981: LD_VAR 0 2
45985: ARRAY
45986: DIFF
45987: ST_TO_ADDR
// if not tmp then
45988: LD_VAR 0 4
45992: NOT
45993: IFFALSE 45997
// continue ;
45995: GO 45842
// for j in tmp do
45997: LD_ADDR_VAR 0 3
46001: PUSH
46002: LD_VAR 0 4
46006: PUSH
46007: FOR_IN
46008: IFFALSE 46159
// begin if not mc_builders [ i ] then
46010: LD_EXP 103
46014: PUSH
46015: LD_VAR 0 2
46019: ARRAY
46020: NOT
46021: IFFALSE 46079
// begin SetTag ( j , 103 ) ;
46023: LD_VAR 0 3
46027: PPUSH
46028: LD_INT 103
46030: PPUSH
46031: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46035: LD_ADDR_EXP 103
46039: PUSH
46040: LD_EXP 103
46044: PPUSH
46045: LD_VAR 0 2
46049: PUSH
46050: LD_EXP 103
46054: PUSH
46055: LD_VAR 0 2
46059: ARRAY
46060: PUSH
46061: LD_INT 1
46063: PLUS
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PPUSH
46069: LD_VAR 0 3
46073: PPUSH
46074: CALL 71160 0 3
46078: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46079: LD_VAR 0 3
46083: PPUSH
46084: CALL_OW 310
46088: IFFALSE 46099
// ComExitBuilding ( j ) ;
46090: LD_VAR 0 3
46094: PPUSH
46095: CALL_OW 122
// wait ( 3 ) ;
46099: LD_INT 3
46101: PPUSH
46102: CALL_OW 67
// if not mc_construct_list [ i ] then
46106: LD_EXP 104
46110: PUSH
46111: LD_VAR 0 2
46115: ARRAY
46116: NOT
46117: IFFALSE 46121
// break ;
46119: GO 46159
// if not HasTask ( j ) then
46121: LD_VAR 0 3
46125: PPUSH
46126: CALL_OW 314
46130: NOT
46131: IFFALSE 46157
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
46133: LD_VAR 0 3
46137: PPUSH
46138: LD_EXP 104
46142: PUSH
46143: LD_VAR 0 2
46147: ARRAY
46148: PUSH
46149: LD_INT 1
46151: ARRAY
46152: PPUSH
46153: CALL 74021 0 2
// end ;
46157: GO 46007
46159: POP
46160: POP
// end else
46161: GO 46994
// if mc_build_list [ i ] then
46163: LD_EXP 102
46167: PUSH
46168: LD_VAR 0 2
46172: ARRAY
46173: IFFALSE 46994
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46175: LD_ADDR_VAR 0 5
46179: PUSH
46180: LD_EXP 97
46184: PUSH
46185: LD_VAR 0 2
46189: ARRAY
46190: PPUSH
46191: LD_INT 2
46193: PUSH
46194: LD_INT 30
46196: PUSH
46197: LD_INT 0
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: PUSH
46204: LD_INT 30
46206: PUSH
46207: LD_INT 1
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: LIST
46218: PPUSH
46219: CALL_OW 72
46223: ST_TO_ADDR
// if depot then
46224: LD_VAR 0 5
46228: IFFALSE 46246
// depot := depot [ 1 ] else
46230: LD_ADDR_VAR 0 5
46234: PUSH
46235: LD_VAR 0 5
46239: PUSH
46240: LD_INT 1
46242: ARRAY
46243: ST_TO_ADDR
46244: GO 46254
// depot := 0 ;
46246: LD_ADDR_VAR 0 5
46250: PUSH
46251: LD_INT 0
46253: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46254: LD_EXP 102
46258: PUSH
46259: LD_VAR 0 2
46263: ARRAY
46264: PUSH
46265: LD_INT 1
46267: ARRAY
46268: PUSH
46269: LD_INT 1
46271: ARRAY
46272: PPUSH
46273: CALL 73845 0 1
46277: PUSH
46278: LD_EXP 97
46282: PUSH
46283: LD_VAR 0 2
46287: ARRAY
46288: PPUSH
46289: LD_INT 2
46291: PUSH
46292: LD_INT 30
46294: PUSH
46295: LD_INT 2
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: PUSH
46302: LD_INT 30
46304: PUSH
46305: LD_INT 3
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: LIST
46316: PPUSH
46317: CALL_OW 72
46321: NOT
46322: AND
46323: IFFALSE 46428
// begin for j = 1 to mc_build_list [ i ] do
46325: LD_ADDR_VAR 0 3
46329: PUSH
46330: DOUBLE
46331: LD_INT 1
46333: DEC
46334: ST_TO_ADDR
46335: LD_EXP 102
46339: PUSH
46340: LD_VAR 0 2
46344: ARRAY
46345: PUSH
46346: FOR_TO
46347: IFFALSE 46426
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46349: LD_EXP 102
46353: PUSH
46354: LD_VAR 0 2
46358: ARRAY
46359: PUSH
46360: LD_VAR 0 3
46364: ARRAY
46365: PUSH
46366: LD_INT 1
46368: ARRAY
46369: PUSH
46370: LD_INT 2
46372: EQUAL
46373: IFFALSE 46424
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46375: LD_ADDR_EXP 102
46379: PUSH
46380: LD_EXP 102
46384: PPUSH
46385: LD_VAR 0 2
46389: PPUSH
46390: LD_EXP 102
46394: PUSH
46395: LD_VAR 0 2
46399: ARRAY
46400: PPUSH
46401: LD_VAR 0 3
46405: PPUSH
46406: LD_INT 1
46408: PPUSH
46409: LD_INT 0
46411: PPUSH
46412: CALL 70578 0 4
46416: PPUSH
46417: CALL_OW 1
46421: ST_TO_ADDR
// break ;
46422: GO 46426
// end ;
46424: GO 46346
46426: POP
46427: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46428: LD_EXP 102
46432: PUSH
46433: LD_VAR 0 2
46437: ARRAY
46438: PUSH
46439: LD_INT 1
46441: ARRAY
46442: PUSH
46443: LD_INT 1
46445: ARRAY
46446: PUSH
46447: LD_INT 0
46449: EQUAL
46450: PUSH
46451: LD_VAR 0 5
46455: PUSH
46456: LD_VAR 0 5
46460: PPUSH
46461: LD_EXP 102
46465: PUSH
46466: LD_VAR 0 2
46470: ARRAY
46471: PUSH
46472: LD_INT 1
46474: ARRAY
46475: PUSH
46476: LD_INT 1
46478: ARRAY
46479: PPUSH
46480: LD_EXP 102
46484: PUSH
46485: LD_VAR 0 2
46489: ARRAY
46490: PUSH
46491: LD_INT 1
46493: ARRAY
46494: PUSH
46495: LD_INT 2
46497: ARRAY
46498: PPUSH
46499: LD_EXP 102
46503: PUSH
46504: LD_VAR 0 2
46508: ARRAY
46509: PUSH
46510: LD_INT 1
46512: ARRAY
46513: PUSH
46514: LD_INT 3
46516: ARRAY
46517: PPUSH
46518: LD_EXP 102
46522: PUSH
46523: LD_VAR 0 2
46527: ARRAY
46528: PUSH
46529: LD_INT 1
46531: ARRAY
46532: PUSH
46533: LD_INT 4
46535: ARRAY
46536: PPUSH
46537: CALL 79257 0 5
46541: AND
46542: OR
46543: IFFALSE 46824
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46545: LD_ADDR_VAR 0 4
46549: PUSH
46550: LD_EXP 97
46554: PUSH
46555: LD_VAR 0 2
46559: ARRAY
46560: PPUSH
46561: LD_INT 25
46563: PUSH
46564: LD_INT 2
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PPUSH
46571: CALL_OW 72
46575: PUSH
46576: LD_EXP 99
46580: PUSH
46581: LD_VAR 0 2
46585: ARRAY
46586: DIFF
46587: ST_TO_ADDR
// if not tmp then
46588: LD_VAR 0 4
46592: NOT
46593: IFFALSE 46597
// continue ;
46595: GO 45842
// for j in tmp do
46597: LD_ADDR_VAR 0 3
46601: PUSH
46602: LD_VAR 0 4
46606: PUSH
46607: FOR_IN
46608: IFFALSE 46820
// begin if not mc_builders [ i ] then
46610: LD_EXP 103
46614: PUSH
46615: LD_VAR 0 2
46619: ARRAY
46620: NOT
46621: IFFALSE 46679
// begin SetTag ( j , 103 ) ;
46623: LD_VAR 0 3
46627: PPUSH
46628: LD_INT 103
46630: PPUSH
46631: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46635: LD_ADDR_EXP 103
46639: PUSH
46640: LD_EXP 103
46644: PPUSH
46645: LD_VAR 0 2
46649: PUSH
46650: LD_EXP 103
46654: PUSH
46655: LD_VAR 0 2
46659: ARRAY
46660: PUSH
46661: LD_INT 1
46663: PLUS
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PPUSH
46669: LD_VAR 0 3
46673: PPUSH
46674: CALL 71160 0 3
46678: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46679: LD_VAR 0 3
46683: PPUSH
46684: CALL_OW 310
46688: IFFALSE 46699
// ComExitBuilding ( j ) ;
46690: LD_VAR 0 3
46694: PPUSH
46695: CALL_OW 122
// wait ( 3 ) ;
46699: LD_INT 3
46701: PPUSH
46702: CALL_OW 67
// if not mc_build_list [ i ] then
46706: LD_EXP 102
46710: PUSH
46711: LD_VAR 0 2
46715: ARRAY
46716: NOT
46717: IFFALSE 46721
// break ;
46719: GO 46820
// if not HasTask ( j ) then
46721: LD_VAR 0 3
46725: PPUSH
46726: CALL_OW 314
46730: NOT
46731: IFFALSE 46818
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46733: LD_VAR 0 3
46737: PPUSH
46738: LD_EXP 102
46742: PUSH
46743: LD_VAR 0 2
46747: ARRAY
46748: PUSH
46749: LD_INT 1
46751: ARRAY
46752: PUSH
46753: LD_INT 1
46755: ARRAY
46756: PPUSH
46757: LD_EXP 102
46761: PUSH
46762: LD_VAR 0 2
46766: ARRAY
46767: PUSH
46768: LD_INT 1
46770: ARRAY
46771: PUSH
46772: LD_INT 2
46774: ARRAY
46775: PPUSH
46776: LD_EXP 102
46780: PUSH
46781: LD_VAR 0 2
46785: ARRAY
46786: PUSH
46787: LD_INT 1
46789: ARRAY
46790: PUSH
46791: LD_INT 3
46793: ARRAY
46794: PPUSH
46795: LD_EXP 102
46799: PUSH
46800: LD_VAR 0 2
46804: ARRAY
46805: PUSH
46806: LD_INT 1
46808: ARRAY
46809: PUSH
46810: LD_INT 4
46812: ARRAY
46813: PPUSH
46814: CALL_OW 145
// end ;
46818: GO 46607
46820: POP
46821: POP
// end else
46822: GO 46994
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46824: LD_EXP 97
46828: PUSH
46829: LD_VAR 0 2
46833: ARRAY
46834: PPUSH
46835: LD_EXP 102
46839: PUSH
46840: LD_VAR 0 2
46844: ARRAY
46845: PUSH
46846: LD_INT 1
46848: ARRAY
46849: PUSH
46850: LD_INT 1
46852: ARRAY
46853: PPUSH
46854: LD_EXP 102
46858: PUSH
46859: LD_VAR 0 2
46863: ARRAY
46864: PUSH
46865: LD_INT 1
46867: ARRAY
46868: PUSH
46869: LD_INT 2
46871: ARRAY
46872: PPUSH
46873: LD_EXP 102
46877: PUSH
46878: LD_VAR 0 2
46882: ARRAY
46883: PUSH
46884: LD_INT 1
46886: ARRAY
46887: PUSH
46888: LD_INT 3
46890: ARRAY
46891: PPUSH
46892: LD_EXP 102
46896: PUSH
46897: LD_VAR 0 2
46901: ARRAY
46902: PUSH
46903: LD_INT 1
46905: ARRAY
46906: PUSH
46907: LD_INT 4
46909: ARRAY
46910: PPUSH
46911: LD_EXP 97
46915: PUSH
46916: LD_VAR 0 2
46920: ARRAY
46921: PPUSH
46922: LD_INT 21
46924: PUSH
46925: LD_INT 3
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: PPUSH
46932: CALL_OW 72
46936: PPUSH
46937: EMPTY
46938: PPUSH
46939: CALL 78011 0 7
46943: NOT
46944: IFFALSE 46994
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46946: LD_ADDR_EXP 102
46950: PUSH
46951: LD_EXP 102
46955: PPUSH
46956: LD_VAR 0 2
46960: PPUSH
46961: LD_EXP 102
46965: PUSH
46966: LD_VAR 0 2
46970: ARRAY
46971: PPUSH
46972: LD_INT 1
46974: PPUSH
46975: LD_INT 1
46977: NEG
46978: PPUSH
46979: LD_INT 0
46981: PPUSH
46982: CALL 70578 0 4
46986: PPUSH
46987: CALL_OW 1
46991: ST_TO_ADDR
// continue ;
46992: GO 45842
// end ; end ; end ;
46994: GO 45842
46996: POP
46997: POP
// end ;
46998: LD_VAR 0 1
47002: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
47003: LD_INT 0
47005: PPUSH
47006: PPUSH
47007: PPUSH
47008: PPUSH
47009: PPUSH
47010: PPUSH
// if not mc_bases then
47011: LD_EXP 97
47015: NOT
47016: IFFALSE 47020
// exit ;
47018: GO 47447
// for i = 1 to mc_bases do
47020: LD_ADDR_VAR 0 2
47024: PUSH
47025: DOUBLE
47026: LD_INT 1
47028: DEC
47029: ST_TO_ADDR
47030: LD_EXP 97
47034: PUSH
47035: FOR_TO
47036: IFFALSE 47445
// begin tmp := mc_build_upgrade [ i ] ;
47038: LD_ADDR_VAR 0 4
47042: PUSH
47043: LD_EXP 129
47047: PUSH
47048: LD_VAR 0 2
47052: ARRAY
47053: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
47054: LD_ADDR_VAR 0 6
47058: PUSH
47059: LD_EXP 130
47063: PUSH
47064: LD_VAR 0 2
47068: ARRAY
47069: PPUSH
47070: LD_INT 2
47072: PUSH
47073: LD_INT 30
47075: PUSH
47076: LD_INT 6
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: LD_INT 30
47085: PUSH
47086: LD_INT 7
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: LIST
47097: PPUSH
47098: CALL_OW 72
47102: ST_TO_ADDR
// if not tmp and not lab then
47103: LD_VAR 0 4
47107: NOT
47108: PUSH
47109: LD_VAR 0 6
47113: NOT
47114: AND
47115: IFFALSE 47119
// continue ;
47117: GO 47035
// if tmp then
47119: LD_VAR 0 4
47123: IFFALSE 47243
// for j in tmp do
47125: LD_ADDR_VAR 0 3
47129: PUSH
47130: LD_VAR 0 4
47134: PUSH
47135: FOR_IN
47136: IFFALSE 47241
// begin if UpgradeCost ( j ) then
47138: LD_VAR 0 3
47142: PPUSH
47143: CALL 77671 0 1
47147: IFFALSE 47239
// begin ComUpgrade ( j ) ;
47149: LD_VAR 0 3
47153: PPUSH
47154: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
47158: LD_ADDR_EXP 129
47162: PUSH
47163: LD_EXP 129
47167: PPUSH
47168: LD_VAR 0 2
47172: PPUSH
47173: LD_EXP 129
47177: PUSH
47178: LD_VAR 0 2
47182: ARRAY
47183: PUSH
47184: LD_VAR 0 3
47188: DIFF
47189: PPUSH
47190: CALL_OW 1
47194: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47195: LD_ADDR_EXP 104
47199: PUSH
47200: LD_EXP 104
47204: PPUSH
47205: LD_VAR 0 2
47209: PUSH
47210: LD_EXP 104
47214: PUSH
47215: LD_VAR 0 2
47219: ARRAY
47220: PUSH
47221: LD_INT 1
47223: PLUS
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PPUSH
47229: LD_VAR 0 3
47233: PPUSH
47234: CALL 71160 0 3
47238: ST_TO_ADDR
// end ; end ;
47239: GO 47135
47241: POP
47242: POP
// if not lab or not mc_lab_upgrade [ i ] then
47243: LD_VAR 0 6
47247: NOT
47248: PUSH
47249: LD_EXP 131
47253: PUSH
47254: LD_VAR 0 2
47258: ARRAY
47259: NOT
47260: OR
47261: IFFALSE 47265
// continue ;
47263: GO 47035
// for j in lab do
47265: LD_ADDR_VAR 0 3
47269: PUSH
47270: LD_VAR 0 6
47274: PUSH
47275: FOR_IN
47276: IFFALSE 47441
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47278: LD_VAR 0 3
47282: PPUSH
47283: CALL_OW 266
47287: PUSH
47288: LD_INT 6
47290: PUSH
47291: LD_INT 7
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: IN
47298: PUSH
47299: LD_VAR 0 3
47303: PPUSH
47304: CALL_OW 461
47308: PUSH
47309: LD_INT 1
47311: NONEQUAL
47312: AND
47313: IFFALSE 47439
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47315: LD_VAR 0 3
47319: PPUSH
47320: LD_EXP 131
47324: PUSH
47325: LD_VAR 0 2
47329: ARRAY
47330: PUSH
47331: LD_INT 1
47333: ARRAY
47334: PPUSH
47335: CALL 77876 0 2
47339: IFFALSE 47439
// begin ComCancel ( j ) ;
47341: LD_VAR 0 3
47345: PPUSH
47346: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47350: LD_VAR 0 3
47354: PPUSH
47355: LD_EXP 131
47359: PUSH
47360: LD_VAR 0 2
47364: ARRAY
47365: PUSH
47366: LD_INT 1
47368: ARRAY
47369: PPUSH
47370: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47374: LD_VAR 0 3
47378: PUSH
47379: LD_EXP 104
47383: PUSH
47384: LD_VAR 0 2
47388: ARRAY
47389: IN
47390: NOT
47391: IFFALSE 47437
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47393: LD_ADDR_EXP 104
47397: PUSH
47398: LD_EXP 104
47402: PPUSH
47403: LD_VAR 0 2
47407: PUSH
47408: LD_EXP 104
47412: PUSH
47413: LD_VAR 0 2
47417: ARRAY
47418: PUSH
47419: LD_INT 1
47421: PLUS
47422: PUSH
47423: EMPTY
47424: LIST
47425: LIST
47426: PPUSH
47427: LD_VAR 0 3
47431: PPUSH
47432: CALL 71160 0 3
47436: ST_TO_ADDR
// break ;
47437: GO 47441
// end ; end ; end ;
47439: GO 47275
47441: POP
47442: POP
// end ;
47443: GO 47035
47445: POP
47446: POP
// end ;
47447: LD_VAR 0 1
47451: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47452: LD_INT 0
47454: PPUSH
47455: PPUSH
47456: PPUSH
47457: PPUSH
47458: PPUSH
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
// if not mc_bases then
47463: LD_EXP 97
47467: NOT
47468: IFFALSE 47472
// exit ;
47470: GO 47877
// for i = 1 to mc_bases do
47472: LD_ADDR_VAR 0 2
47476: PUSH
47477: DOUBLE
47478: LD_INT 1
47480: DEC
47481: ST_TO_ADDR
47482: LD_EXP 97
47486: PUSH
47487: FOR_TO
47488: IFFALSE 47875
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47490: LD_EXP 105
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: NOT
47501: PUSH
47502: LD_EXP 97
47506: PUSH
47507: LD_VAR 0 2
47511: ARRAY
47512: PPUSH
47513: LD_INT 30
47515: PUSH
47516: LD_INT 3
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PPUSH
47523: CALL_OW 72
47527: NOT
47528: OR
47529: IFFALSE 47533
// continue ;
47531: GO 47487
// busy := false ;
47533: LD_ADDR_VAR 0 8
47537: PUSH
47538: LD_INT 0
47540: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47541: LD_ADDR_VAR 0 4
47545: PUSH
47546: LD_EXP 97
47550: PUSH
47551: LD_VAR 0 2
47555: ARRAY
47556: PPUSH
47557: LD_INT 30
47559: PUSH
47560: LD_INT 3
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PPUSH
47567: CALL_OW 72
47571: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47572: LD_ADDR_VAR 0 6
47576: PUSH
47577: LD_EXP 105
47581: PUSH
47582: LD_VAR 0 2
47586: ARRAY
47587: PPUSH
47588: LD_INT 2
47590: PUSH
47591: LD_INT 30
47593: PUSH
47594: LD_INT 32
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 30
47603: PUSH
47604: LD_INT 33
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: LIST
47615: PPUSH
47616: CALL_OW 72
47620: ST_TO_ADDR
// if not t then
47621: LD_VAR 0 6
47625: NOT
47626: IFFALSE 47630
// continue ;
47628: GO 47487
// for j in tmp do
47630: LD_ADDR_VAR 0 3
47634: PUSH
47635: LD_VAR 0 4
47639: PUSH
47640: FOR_IN
47641: IFFALSE 47671
// if not BuildingStatus ( j ) = bs_idle then
47643: LD_VAR 0 3
47647: PPUSH
47648: CALL_OW 461
47652: PUSH
47653: LD_INT 2
47655: EQUAL
47656: NOT
47657: IFFALSE 47669
// begin busy := true ;
47659: LD_ADDR_VAR 0 8
47663: PUSH
47664: LD_INT 1
47666: ST_TO_ADDR
// break ;
47667: GO 47671
// end ;
47669: GO 47640
47671: POP
47672: POP
// if busy then
47673: LD_VAR 0 8
47677: IFFALSE 47681
// continue ;
47679: GO 47487
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47681: LD_ADDR_VAR 0 7
47685: PUSH
47686: LD_VAR 0 6
47690: PPUSH
47691: LD_INT 35
47693: PUSH
47694: LD_INT 0
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: PPUSH
47701: CALL_OW 72
47705: ST_TO_ADDR
// if tw then
47706: LD_VAR 0 7
47710: IFFALSE 47787
// begin tw := tw [ 1 ] ;
47712: LD_ADDR_VAR 0 7
47716: PUSH
47717: LD_VAR 0 7
47721: PUSH
47722: LD_INT 1
47724: ARRAY
47725: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47726: LD_ADDR_VAR 0 9
47730: PUSH
47731: LD_VAR 0 7
47735: PPUSH
47736: LD_EXP 122
47740: PUSH
47741: LD_VAR 0 2
47745: ARRAY
47746: PPUSH
47747: CALL 76168 0 2
47751: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47752: LD_EXP 136
47756: PUSH
47757: LD_VAR 0 2
47761: ARRAY
47762: IFFALSE 47785
// if not weapon in mc_allowed_tower_weapons [ i ] then
47764: LD_VAR 0 9
47768: PUSH
47769: LD_EXP 136
47773: PUSH
47774: LD_VAR 0 2
47778: ARRAY
47779: IN
47780: NOT
47781: IFFALSE 47785
// continue ;
47783: GO 47487
// end else
47785: GO 47850
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47787: LD_ADDR_VAR 0 5
47791: PUSH
47792: LD_EXP 105
47796: PUSH
47797: LD_VAR 0 2
47801: ARRAY
47802: PPUSH
47803: LD_VAR 0 4
47807: PPUSH
47808: CALL 103020 0 2
47812: ST_TO_ADDR
// if not tmp2 then
47813: LD_VAR 0 5
47817: NOT
47818: IFFALSE 47822
// continue ;
47820: GO 47487
// tw := tmp2 [ 1 ] ;
47822: LD_ADDR_VAR 0 7
47826: PUSH
47827: LD_VAR 0 5
47831: PUSH
47832: LD_INT 1
47834: ARRAY
47835: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47836: LD_ADDR_VAR 0 9
47840: PUSH
47841: LD_VAR 0 5
47845: PUSH
47846: LD_INT 2
47848: ARRAY
47849: ST_TO_ADDR
// end ; if not weapon then
47850: LD_VAR 0 9
47854: NOT
47855: IFFALSE 47859
// continue ;
47857: GO 47487
// ComPlaceWeapon ( tw , weapon ) ;
47859: LD_VAR 0 7
47863: PPUSH
47864: LD_VAR 0 9
47868: PPUSH
47869: CALL_OW 148
// end ;
47873: GO 47487
47875: POP
47876: POP
// end ;
47877: LD_VAR 0 1
47881: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47882: LD_INT 0
47884: PPUSH
47885: PPUSH
47886: PPUSH
47887: PPUSH
47888: PPUSH
47889: PPUSH
47890: PPUSH
// if not mc_bases then
47891: LD_EXP 97
47895: NOT
47896: IFFALSE 47900
// exit ;
47898: GO 48668
// for i = 1 to mc_bases do
47900: LD_ADDR_VAR 0 2
47904: PUSH
47905: DOUBLE
47906: LD_INT 1
47908: DEC
47909: ST_TO_ADDR
47910: LD_EXP 97
47914: PUSH
47915: FOR_TO
47916: IFFALSE 48666
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47918: LD_EXP 110
47922: PUSH
47923: LD_VAR 0 2
47927: ARRAY
47928: NOT
47929: PUSH
47930: LD_EXP 110
47934: PUSH
47935: LD_VAR 0 2
47939: ARRAY
47940: PUSH
47941: LD_EXP 111
47945: PUSH
47946: LD_VAR 0 2
47950: ARRAY
47951: EQUAL
47952: OR
47953: PUSH
47954: LD_EXP 120
47958: PUSH
47959: LD_VAR 0 2
47963: ARRAY
47964: OR
47965: IFFALSE 47969
// continue ;
47967: GO 47915
// if mc_miners [ i ] then
47969: LD_EXP 111
47973: PUSH
47974: LD_VAR 0 2
47978: ARRAY
47979: IFFALSE 48353
// begin for j = mc_miners [ i ] downto 1 do
47981: LD_ADDR_VAR 0 3
47985: PUSH
47986: DOUBLE
47987: LD_EXP 111
47991: PUSH
47992: LD_VAR 0 2
47996: ARRAY
47997: INC
47998: ST_TO_ADDR
47999: LD_INT 1
48001: PUSH
48002: FOR_DOWNTO
48003: IFFALSE 48351
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
48005: LD_EXP 111
48009: PUSH
48010: LD_VAR 0 2
48014: ARRAY
48015: PUSH
48016: LD_VAR 0 3
48020: ARRAY
48021: PPUSH
48022: CALL_OW 301
48026: PUSH
48027: LD_EXP 111
48031: PUSH
48032: LD_VAR 0 2
48036: ARRAY
48037: PUSH
48038: LD_VAR 0 3
48042: ARRAY
48043: PPUSH
48044: CALL_OW 257
48048: PUSH
48049: LD_INT 1
48051: NONEQUAL
48052: OR
48053: IFFALSE 48116
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
48055: LD_ADDR_VAR 0 5
48059: PUSH
48060: LD_EXP 111
48064: PUSH
48065: LD_VAR 0 2
48069: ARRAY
48070: PUSH
48071: LD_EXP 111
48075: PUSH
48076: LD_VAR 0 2
48080: ARRAY
48081: PUSH
48082: LD_VAR 0 3
48086: ARRAY
48087: DIFF
48088: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
48089: LD_ADDR_EXP 111
48093: PUSH
48094: LD_EXP 111
48098: PPUSH
48099: LD_VAR 0 2
48103: PPUSH
48104: LD_VAR 0 5
48108: PPUSH
48109: CALL_OW 1
48113: ST_TO_ADDR
// continue ;
48114: GO 48002
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
48116: LD_EXP 111
48120: PUSH
48121: LD_VAR 0 2
48125: ARRAY
48126: PUSH
48127: LD_VAR 0 3
48131: ARRAY
48132: PPUSH
48133: CALL_OW 257
48137: PUSH
48138: LD_INT 1
48140: EQUAL
48141: PUSH
48142: LD_EXP 111
48146: PUSH
48147: LD_VAR 0 2
48151: ARRAY
48152: PUSH
48153: LD_VAR 0 3
48157: ARRAY
48158: PPUSH
48159: CALL_OW 459
48163: NOT
48164: AND
48165: PUSH
48166: LD_EXP 111
48170: PUSH
48171: LD_VAR 0 2
48175: ARRAY
48176: PUSH
48177: LD_VAR 0 3
48181: ARRAY
48182: PPUSH
48183: CALL_OW 314
48187: NOT
48188: AND
48189: IFFALSE 48349
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48191: LD_EXP 111
48195: PUSH
48196: LD_VAR 0 2
48200: ARRAY
48201: PUSH
48202: LD_VAR 0 3
48206: ARRAY
48207: PPUSH
48208: CALL_OW 310
48212: IFFALSE 48235
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48214: LD_EXP 111
48218: PUSH
48219: LD_VAR 0 2
48223: ARRAY
48224: PUSH
48225: LD_VAR 0 3
48229: ARRAY
48230: PPUSH
48231: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48235: LD_EXP 111
48239: PUSH
48240: LD_VAR 0 2
48244: ARRAY
48245: PUSH
48246: LD_VAR 0 3
48250: ARRAY
48251: PPUSH
48252: CALL_OW 314
48256: NOT
48257: IFFALSE 48349
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48259: LD_ADDR_VAR 0 7
48263: PUSH
48264: LD_INT 1
48266: PPUSH
48267: LD_EXP 110
48271: PUSH
48272: LD_VAR 0 2
48276: ARRAY
48277: PPUSH
48278: CALL_OW 12
48282: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48283: LD_EXP 111
48287: PUSH
48288: LD_VAR 0 2
48292: ARRAY
48293: PUSH
48294: LD_VAR 0 3
48298: ARRAY
48299: PPUSH
48300: LD_EXP 110
48304: PUSH
48305: LD_VAR 0 2
48309: ARRAY
48310: PUSH
48311: LD_VAR 0 7
48315: ARRAY
48316: PUSH
48317: LD_INT 1
48319: ARRAY
48320: PPUSH
48321: LD_EXP 110
48325: PUSH
48326: LD_VAR 0 2
48330: ARRAY
48331: PUSH
48332: LD_VAR 0 7
48336: ARRAY
48337: PUSH
48338: LD_INT 2
48340: ARRAY
48341: PPUSH
48342: LD_INT 0
48344: PPUSH
48345: CALL_OW 193
// end ; end ; end ;
48349: GO 48002
48351: POP
48352: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48353: LD_ADDR_VAR 0 5
48357: PUSH
48358: LD_EXP 97
48362: PUSH
48363: LD_VAR 0 2
48367: ARRAY
48368: PPUSH
48369: LD_INT 2
48371: PUSH
48372: LD_INT 30
48374: PUSH
48375: LD_INT 4
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: PUSH
48382: LD_INT 30
48384: PUSH
48385: LD_INT 5
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: PUSH
48392: LD_INT 30
48394: PUSH
48395: LD_INT 32
48397: PUSH
48398: EMPTY
48399: LIST
48400: LIST
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: PPUSH
48408: CALL_OW 72
48412: ST_TO_ADDR
// if not tmp then
48413: LD_VAR 0 5
48417: NOT
48418: IFFALSE 48422
// continue ;
48420: GO 47915
// list := [ ] ;
48422: LD_ADDR_VAR 0 6
48426: PUSH
48427: EMPTY
48428: ST_TO_ADDR
// for j in tmp do
48429: LD_ADDR_VAR 0 3
48433: PUSH
48434: LD_VAR 0 5
48438: PUSH
48439: FOR_IN
48440: IFFALSE 48509
// begin for k in UnitsInside ( j ) do
48442: LD_ADDR_VAR 0 4
48446: PUSH
48447: LD_VAR 0 3
48451: PPUSH
48452: CALL_OW 313
48456: PUSH
48457: FOR_IN
48458: IFFALSE 48505
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48460: LD_VAR 0 4
48464: PPUSH
48465: CALL_OW 257
48469: PUSH
48470: LD_INT 1
48472: EQUAL
48473: PUSH
48474: LD_VAR 0 4
48478: PPUSH
48479: CALL_OW 459
48483: NOT
48484: AND
48485: IFFALSE 48503
// list := list ^ k ;
48487: LD_ADDR_VAR 0 6
48491: PUSH
48492: LD_VAR 0 6
48496: PUSH
48497: LD_VAR 0 4
48501: ADD
48502: ST_TO_ADDR
48503: GO 48457
48505: POP
48506: POP
// end ;
48507: GO 48439
48509: POP
48510: POP
// list := list diff mc_miners [ i ] ;
48511: LD_ADDR_VAR 0 6
48515: PUSH
48516: LD_VAR 0 6
48520: PUSH
48521: LD_EXP 111
48525: PUSH
48526: LD_VAR 0 2
48530: ARRAY
48531: DIFF
48532: ST_TO_ADDR
// if not list then
48533: LD_VAR 0 6
48537: NOT
48538: IFFALSE 48542
// continue ;
48540: GO 47915
// k := mc_mines [ i ] - mc_miners [ i ] ;
48542: LD_ADDR_VAR 0 4
48546: PUSH
48547: LD_EXP 110
48551: PUSH
48552: LD_VAR 0 2
48556: ARRAY
48557: PUSH
48558: LD_EXP 111
48562: PUSH
48563: LD_VAR 0 2
48567: ARRAY
48568: MINUS
48569: ST_TO_ADDR
// if k > list then
48570: LD_VAR 0 4
48574: PUSH
48575: LD_VAR 0 6
48579: GREATER
48580: IFFALSE 48592
// k := list ;
48582: LD_ADDR_VAR 0 4
48586: PUSH
48587: LD_VAR 0 6
48591: ST_TO_ADDR
// for j = 1 to k do
48592: LD_ADDR_VAR 0 3
48596: PUSH
48597: DOUBLE
48598: LD_INT 1
48600: DEC
48601: ST_TO_ADDR
48602: LD_VAR 0 4
48606: PUSH
48607: FOR_TO
48608: IFFALSE 48662
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48610: LD_ADDR_EXP 111
48614: PUSH
48615: LD_EXP 111
48619: PPUSH
48620: LD_VAR 0 2
48624: PUSH
48625: LD_EXP 111
48629: PUSH
48630: LD_VAR 0 2
48634: ARRAY
48635: PUSH
48636: LD_INT 1
48638: PLUS
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PPUSH
48644: LD_VAR 0 6
48648: PUSH
48649: LD_VAR 0 3
48653: ARRAY
48654: PPUSH
48655: CALL 71160 0 3
48659: ST_TO_ADDR
48660: GO 48607
48662: POP
48663: POP
// end ;
48664: GO 47915
48666: POP
48667: POP
// end ;
48668: LD_VAR 0 1
48672: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48673: LD_INT 0
48675: PPUSH
48676: PPUSH
48677: PPUSH
48678: PPUSH
48679: PPUSH
48680: PPUSH
48681: PPUSH
48682: PPUSH
48683: PPUSH
48684: PPUSH
48685: PPUSH
// if not mc_bases then
48686: LD_EXP 97
48690: NOT
48691: IFFALSE 48695
// exit ;
48693: GO 50518
// for i = 1 to mc_bases do
48695: LD_ADDR_VAR 0 2
48699: PUSH
48700: DOUBLE
48701: LD_INT 1
48703: DEC
48704: ST_TO_ADDR
48705: LD_EXP 97
48709: PUSH
48710: FOR_TO
48711: IFFALSE 50516
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48713: LD_EXP 97
48717: PUSH
48718: LD_VAR 0 2
48722: ARRAY
48723: NOT
48724: PUSH
48725: LD_EXP 104
48729: PUSH
48730: LD_VAR 0 2
48734: ARRAY
48735: OR
48736: IFFALSE 48740
// continue ;
48738: GO 48710
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48740: LD_EXP 113
48744: PUSH
48745: LD_VAR 0 2
48749: ARRAY
48750: NOT
48751: PUSH
48752: LD_EXP 114
48756: PUSH
48757: LD_VAR 0 2
48761: ARRAY
48762: AND
48763: IFFALSE 48801
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48765: LD_ADDR_EXP 114
48769: PUSH
48770: LD_EXP 114
48774: PPUSH
48775: LD_VAR 0 2
48779: PPUSH
48780: EMPTY
48781: PPUSH
48782: CALL_OW 1
48786: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48787: LD_VAR 0 2
48791: PPUSH
48792: LD_INT 107
48794: PPUSH
48795: CALL 39573 0 2
// continue ;
48799: GO 48710
// end ; target := [ ] ;
48801: LD_ADDR_VAR 0 7
48805: PUSH
48806: EMPTY
48807: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48808: LD_ADDR_VAR 0 6
48812: PUSH
48813: LD_EXP 97
48817: PUSH
48818: LD_VAR 0 2
48822: ARRAY
48823: PUSH
48824: LD_INT 1
48826: ARRAY
48827: PPUSH
48828: CALL_OW 255
48832: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48833: LD_ADDR_VAR 0 9
48837: PUSH
48838: LD_EXP 97
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: PPUSH
48849: LD_INT 2
48851: PUSH
48852: LD_INT 30
48854: PUSH
48855: LD_INT 0
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 30
48864: PUSH
48865: LD_INT 1
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: LIST
48876: PPUSH
48877: CALL_OW 72
48881: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48882: LD_ADDR_VAR 0 3
48886: PUSH
48887: DOUBLE
48888: LD_EXP 113
48892: PUSH
48893: LD_VAR 0 2
48897: ARRAY
48898: INC
48899: ST_TO_ADDR
48900: LD_INT 1
48902: PUSH
48903: FOR_DOWNTO
48904: IFFALSE 49149
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48906: LD_EXP 113
48910: PUSH
48911: LD_VAR 0 2
48915: ARRAY
48916: PUSH
48917: LD_VAR 0 3
48921: ARRAY
48922: PUSH
48923: LD_INT 2
48925: ARRAY
48926: PPUSH
48927: LD_EXP 113
48931: PUSH
48932: LD_VAR 0 2
48936: ARRAY
48937: PUSH
48938: LD_VAR 0 3
48942: ARRAY
48943: PUSH
48944: LD_INT 3
48946: ARRAY
48947: PPUSH
48948: CALL_OW 488
48952: PUSH
48953: LD_EXP 113
48957: PUSH
48958: LD_VAR 0 2
48962: ARRAY
48963: PUSH
48964: LD_VAR 0 3
48968: ARRAY
48969: PUSH
48970: LD_INT 2
48972: ARRAY
48973: PPUSH
48974: LD_EXP 113
48978: PUSH
48979: LD_VAR 0 2
48983: ARRAY
48984: PUSH
48985: LD_VAR 0 3
48989: ARRAY
48990: PUSH
48991: LD_INT 3
48993: ARRAY
48994: PPUSH
48995: CALL_OW 284
48999: PUSH
49000: LD_INT 0
49002: EQUAL
49003: AND
49004: IFFALSE 49059
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
49006: LD_ADDR_VAR 0 5
49010: PUSH
49011: LD_EXP 113
49015: PUSH
49016: LD_VAR 0 2
49020: ARRAY
49021: PPUSH
49022: LD_VAR 0 3
49026: PPUSH
49027: CALL_OW 3
49031: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
49032: LD_ADDR_EXP 113
49036: PUSH
49037: LD_EXP 113
49041: PPUSH
49042: LD_VAR 0 2
49046: PPUSH
49047: LD_VAR 0 5
49051: PPUSH
49052: CALL_OW 1
49056: ST_TO_ADDR
// continue ;
49057: GO 48903
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
49059: LD_VAR 0 6
49063: PPUSH
49064: LD_EXP 113
49068: PUSH
49069: LD_VAR 0 2
49073: ARRAY
49074: PUSH
49075: LD_VAR 0 3
49079: ARRAY
49080: PUSH
49081: LD_INT 2
49083: ARRAY
49084: PPUSH
49085: LD_EXP 113
49089: PUSH
49090: LD_VAR 0 2
49094: ARRAY
49095: PUSH
49096: LD_VAR 0 3
49100: ARRAY
49101: PUSH
49102: LD_INT 3
49104: ARRAY
49105: PPUSH
49106: LD_INT 30
49108: PPUSH
49109: CALL 72056 0 4
49113: PUSH
49114: LD_INT 4
49116: ARRAY
49117: PUSH
49118: LD_INT 0
49120: EQUAL
49121: IFFALSE 49147
// begin target := mc_crates [ i ] [ j ] ;
49123: LD_ADDR_VAR 0 7
49127: PUSH
49128: LD_EXP 113
49132: PUSH
49133: LD_VAR 0 2
49137: ARRAY
49138: PUSH
49139: LD_VAR 0 3
49143: ARRAY
49144: ST_TO_ADDR
// break ;
49145: GO 49149
// end ; end ;
49147: GO 48903
49149: POP
49150: POP
// if not target then
49151: LD_VAR 0 7
49155: NOT
49156: IFFALSE 49160
// continue ;
49158: GO 48710
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
49160: LD_ADDR_VAR 0 8
49164: PUSH
49165: LD_EXP 116
49169: PUSH
49170: LD_VAR 0 2
49174: ARRAY
49175: PPUSH
49176: LD_INT 2
49178: PUSH
49179: LD_INT 3
49181: PUSH
49182: LD_INT 58
49184: PUSH
49185: EMPTY
49186: LIST
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: PUSH
49192: LD_INT 61
49194: PUSH
49195: EMPTY
49196: LIST
49197: PUSH
49198: LD_INT 33
49200: PUSH
49201: LD_INT 5
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 33
49210: PUSH
49211: LD_INT 3
49213: PUSH
49214: EMPTY
49215: LIST
49216: LIST
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: PUSH
49225: LD_INT 2
49227: PUSH
49228: LD_INT 34
49230: PUSH
49231: LD_INT 32
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: PUSH
49238: LD_INT 34
49240: PUSH
49241: LD_INT 51
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: PUSH
49248: LD_INT 34
49250: PUSH
49251: LD_INT 12
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: PPUSH
49268: CALL_OW 72
49272: ST_TO_ADDR
// if not cargo then
49273: LD_VAR 0 8
49277: NOT
49278: IFFALSE 49984
// begin if mc_crates_collector [ i ] < 5 then
49280: LD_EXP 114
49284: PUSH
49285: LD_VAR 0 2
49289: ARRAY
49290: PUSH
49291: LD_INT 5
49293: LESS
49294: IFFALSE 49660
// begin if mc_ape [ i ] then
49296: LD_EXP 126
49300: PUSH
49301: LD_VAR 0 2
49305: ARRAY
49306: IFFALSE 49353
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49308: LD_ADDR_VAR 0 5
49312: PUSH
49313: LD_EXP 126
49317: PUSH
49318: LD_VAR 0 2
49322: ARRAY
49323: PPUSH
49324: LD_INT 25
49326: PUSH
49327: LD_INT 16
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: PUSH
49334: LD_INT 24
49336: PUSH
49337: LD_INT 750
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PPUSH
49348: CALL_OW 72
49352: ST_TO_ADDR
// if not tmp then
49353: LD_VAR 0 5
49357: NOT
49358: IFFALSE 49405
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49360: LD_ADDR_VAR 0 5
49364: PUSH
49365: LD_EXP 97
49369: PUSH
49370: LD_VAR 0 2
49374: ARRAY
49375: PPUSH
49376: LD_INT 25
49378: PUSH
49379: LD_INT 2
49381: PUSH
49382: EMPTY
49383: LIST
49384: LIST
49385: PUSH
49386: LD_INT 24
49388: PUSH
49389: LD_INT 750
49391: PUSH
49392: EMPTY
49393: LIST
49394: LIST
49395: PUSH
49396: EMPTY
49397: LIST
49398: LIST
49399: PPUSH
49400: CALL_OW 72
49404: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49405: LD_EXP 126
49409: PUSH
49410: LD_VAR 0 2
49414: ARRAY
49415: PUSH
49416: LD_EXP 97
49420: PUSH
49421: LD_VAR 0 2
49425: ARRAY
49426: PPUSH
49427: LD_INT 25
49429: PUSH
49430: LD_INT 2
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: PUSH
49437: LD_INT 24
49439: PUSH
49440: LD_INT 750
49442: PUSH
49443: EMPTY
49444: LIST
49445: LIST
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: PPUSH
49451: CALL_OW 72
49455: AND
49456: PUSH
49457: LD_VAR 0 5
49461: PUSH
49462: LD_INT 5
49464: LESS
49465: AND
49466: IFFALSE 49548
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49468: LD_ADDR_VAR 0 3
49472: PUSH
49473: LD_EXP 97
49477: PUSH
49478: LD_VAR 0 2
49482: ARRAY
49483: PPUSH
49484: LD_INT 25
49486: PUSH
49487: LD_INT 2
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: LD_INT 24
49496: PUSH
49497: LD_INT 750
49499: PUSH
49500: EMPTY
49501: LIST
49502: LIST
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PPUSH
49508: CALL_OW 72
49512: PUSH
49513: FOR_IN
49514: IFFALSE 49546
// begin tmp := tmp union j ;
49516: LD_ADDR_VAR 0 5
49520: PUSH
49521: LD_VAR 0 5
49525: PUSH
49526: LD_VAR 0 3
49530: UNION
49531: ST_TO_ADDR
// if tmp >= 5 then
49532: LD_VAR 0 5
49536: PUSH
49537: LD_INT 5
49539: GREATEREQUAL
49540: IFFALSE 49544
// break ;
49542: GO 49546
// end ;
49544: GO 49513
49546: POP
49547: POP
// end ; if not tmp then
49548: LD_VAR 0 5
49552: NOT
49553: IFFALSE 49557
// continue ;
49555: GO 48710
// for j in tmp do
49557: LD_ADDR_VAR 0 3
49561: PUSH
49562: LD_VAR 0 5
49566: PUSH
49567: FOR_IN
49568: IFFALSE 49658
// if not GetTag ( j ) then
49570: LD_VAR 0 3
49574: PPUSH
49575: CALL_OW 110
49579: NOT
49580: IFFALSE 49656
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49582: LD_ADDR_EXP 114
49586: PUSH
49587: LD_EXP 114
49591: PPUSH
49592: LD_VAR 0 2
49596: PUSH
49597: LD_EXP 114
49601: PUSH
49602: LD_VAR 0 2
49606: ARRAY
49607: PUSH
49608: LD_INT 1
49610: PLUS
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: PPUSH
49616: LD_VAR 0 3
49620: PPUSH
49621: CALL 71160 0 3
49625: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49626: LD_VAR 0 3
49630: PPUSH
49631: LD_INT 107
49633: PPUSH
49634: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49638: LD_EXP 114
49642: PUSH
49643: LD_VAR 0 2
49647: ARRAY
49648: PUSH
49649: LD_INT 5
49651: GREATEREQUAL
49652: IFFALSE 49656
// break ;
49654: GO 49658
// end ;
49656: GO 49567
49658: POP
49659: POP
// end ; if mc_crates_collector [ i ] and target then
49660: LD_EXP 114
49664: PUSH
49665: LD_VAR 0 2
49669: ARRAY
49670: PUSH
49671: LD_VAR 0 7
49675: AND
49676: IFFALSE 49982
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49678: LD_EXP 114
49682: PUSH
49683: LD_VAR 0 2
49687: ARRAY
49688: PUSH
49689: LD_VAR 0 7
49693: PUSH
49694: LD_INT 1
49696: ARRAY
49697: LESS
49698: IFFALSE 49718
// tmp := mc_crates_collector [ i ] else
49700: LD_ADDR_VAR 0 5
49704: PUSH
49705: LD_EXP 114
49709: PUSH
49710: LD_VAR 0 2
49714: ARRAY
49715: ST_TO_ADDR
49716: GO 49732
// tmp := target [ 1 ] ;
49718: LD_ADDR_VAR 0 5
49722: PUSH
49723: LD_VAR 0 7
49727: PUSH
49728: LD_INT 1
49730: ARRAY
49731: ST_TO_ADDR
// k := 0 ;
49732: LD_ADDR_VAR 0 4
49736: PUSH
49737: LD_INT 0
49739: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49740: LD_ADDR_VAR 0 3
49744: PUSH
49745: LD_EXP 114
49749: PUSH
49750: LD_VAR 0 2
49754: ARRAY
49755: PUSH
49756: FOR_IN
49757: IFFALSE 49980
// begin k := k + 1 ;
49759: LD_ADDR_VAR 0 4
49763: PUSH
49764: LD_VAR 0 4
49768: PUSH
49769: LD_INT 1
49771: PLUS
49772: ST_TO_ADDR
// if k > tmp then
49773: LD_VAR 0 4
49777: PUSH
49778: LD_VAR 0 5
49782: GREATER
49783: IFFALSE 49787
// break ;
49785: GO 49980
// if not GetClass ( j ) in [ 2 , 16 ] then
49787: LD_VAR 0 3
49791: PPUSH
49792: CALL_OW 257
49796: PUSH
49797: LD_INT 2
49799: PUSH
49800: LD_INT 16
49802: PUSH
49803: EMPTY
49804: LIST
49805: LIST
49806: IN
49807: NOT
49808: IFFALSE 49861
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49810: LD_ADDR_EXP 114
49814: PUSH
49815: LD_EXP 114
49819: PPUSH
49820: LD_VAR 0 2
49824: PPUSH
49825: LD_EXP 114
49829: PUSH
49830: LD_VAR 0 2
49834: ARRAY
49835: PUSH
49836: LD_VAR 0 3
49840: DIFF
49841: PPUSH
49842: CALL_OW 1
49846: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49847: LD_VAR 0 3
49851: PPUSH
49852: LD_INT 0
49854: PPUSH
49855: CALL_OW 109
// continue ;
49859: GO 49756
// end ; if IsInUnit ( j ) then
49861: LD_VAR 0 3
49865: PPUSH
49866: CALL_OW 310
49870: IFFALSE 49881
// ComExitBuilding ( j ) ;
49872: LD_VAR 0 3
49876: PPUSH
49877: CALL_OW 122
// wait ( 3 ) ;
49881: LD_INT 3
49883: PPUSH
49884: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49888: LD_VAR 0 3
49892: PPUSH
49893: CALL_OW 314
49897: PUSH
49898: LD_VAR 0 6
49902: PPUSH
49903: LD_VAR 0 7
49907: PUSH
49908: LD_INT 2
49910: ARRAY
49911: PPUSH
49912: LD_VAR 0 7
49916: PUSH
49917: LD_INT 3
49919: ARRAY
49920: PPUSH
49921: LD_INT 30
49923: PPUSH
49924: CALL 72056 0 4
49928: PUSH
49929: LD_INT 4
49931: ARRAY
49932: AND
49933: IFFALSE 49951
// ComStandNearbyBuilding ( j , depot ) else
49935: LD_VAR 0 3
49939: PPUSH
49940: LD_VAR 0 9
49944: PPUSH
49945: CALL 67587 0 2
49949: GO 49978
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49951: LD_VAR 0 3
49955: PPUSH
49956: LD_VAR 0 7
49960: PUSH
49961: LD_INT 2
49963: ARRAY
49964: PPUSH
49965: LD_VAR 0 7
49969: PUSH
49970: LD_INT 3
49972: ARRAY
49973: PPUSH
49974: CALL_OW 117
// end ;
49978: GO 49756
49980: POP
49981: POP
// end ; end else
49982: GO 50514
// begin for j in cargo do
49984: LD_ADDR_VAR 0 3
49988: PUSH
49989: LD_VAR 0 8
49993: PUSH
49994: FOR_IN
49995: IFFALSE 50512
// begin if GetTag ( j ) <> 0 then
49997: LD_VAR 0 3
50001: PPUSH
50002: CALL_OW 110
50006: PUSH
50007: LD_INT 0
50009: NONEQUAL
50010: IFFALSE 50014
// continue ;
50012: GO 49994
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
50014: LD_VAR 0 3
50018: PPUSH
50019: CALL_OW 256
50023: PUSH
50024: LD_INT 1000
50026: LESS
50027: PUSH
50028: LD_VAR 0 3
50032: PPUSH
50033: LD_EXP 121
50037: PUSH
50038: LD_VAR 0 2
50042: ARRAY
50043: PPUSH
50044: CALL_OW 308
50048: NOT
50049: AND
50050: IFFALSE 50072
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50052: LD_VAR 0 3
50056: PPUSH
50057: LD_EXP 121
50061: PUSH
50062: LD_VAR 0 2
50066: ARRAY
50067: PPUSH
50068: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
50072: LD_VAR 0 3
50076: PPUSH
50077: CALL_OW 256
50081: PUSH
50082: LD_INT 1000
50084: LESS
50085: PUSH
50086: LD_VAR 0 3
50090: PPUSH
50091: LD_EXP 121
50095: PUSH
50096: LD_VAR 0 2
50100: ARRAY
50101: PPUSH
50102: CALL_OW 308
50106: AND
50107: IFFALSE 50111
// continue ;
50109: GO 49994
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
50111: LD_VAR 0 3
50115: PPUSH
50116: CALL_OW 262
50120: PUSH
50121: LD_INT 2
50123: EQUAL
50124: PUSH
50125: LD_VAR 0 3
50129: PPUSH
50130: CALL_OW 261
50134: PUSH
50135: LD_INT 15
50137: LESS
50138: AND
50139: IFFALSE 50143
// continue ;
50141: GO 49994
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
50143: LD_VAR 0 3
50147: PPUSH
50148: CALL_OW 262
50152: PUSH
50153: LD_INT 1
50155: EQUAL
50156: PUSH
50157: LD_VAR 0 3
50161: PPUSH
50162: CALL_OW 261
50166: PUSH
50167: LD_INT 10
50169: LESS
50170: AND
50171: IFFALSE 50451
// begin if not depot then
50173: LD_VAR 0 9
50177: NOT
50178: IFFALSE 50182
// continue ;
50180: GO 49994
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50182: LD_VAR 0 3
50186: PPUSH
50187: LD_VAR 0 9
50191: PPUSH
50192: LD_VAR 0 3
50196: PPUSH
50197: CALL_OW 74
50201: PPUSH
50202: CALL_OW 296
50206: PUSH
50207: LD_INT 6
50209: LESS
50210: IFFALSE 50226
// SetFuel ( j , 100 ) else
50212: LD_VAR 0 3
50216: PPUSH
50217: LD_INT 100
50219: PPUSH
50220: CALL_OW 240
50224: GO 50451
// if GetFuel ( j ) = 0 then
50226: LD_VAR 0 3
50230: PPUSH
50231: CALL_OW 261
50235: PUSH
50236: LD_INT 0
50238: EQUAL
50239: IFFALSE 50451
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50241: LD_ADDR_EXP 116
50245: PUSH
50246: LD_EXP 116
50250: PPUSH
50251: LD_VAR 0 2
50255: PPUSH
50256: LD_EXP 116
50260: PUSH
50261: LD_VAR 0 2
50265: ARRAY
50266: PUSH
50267: LD_VAR 0 3
50271: DIFF
50272: PPUSH
50273: CALL_OW 1
50277: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50278: LD_VAR 0 3
50282: PPUSH
50283: CALL_OW 263
50287: PUSH
50288: LD_INT 1
50290: EQUAL
50291: IFFALSE 50307
// ComExitVehicle ( IsInUnit ( j ) ) ;
50293: LD_VAR 0 3
50297: PPUSH
50298: CALL_OW 310
50302: PPUSH
50303: CALL_OW 121
// if GetControl ( j ) = control_remote then
50307: LD_VAR 0 3
50311: PPUSH
50312: CALL_OW 263
50316: PUSH
50317: LD_INT 2
50319: EQUAL
50320: IFFALSE 50331
// ComUnlink ( j ) ;
50322: LD_VAR 0 3
50326: PPUSH
50327: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50331: LD_ADDR_VAR 0 10
50335: PUSH
50336: LD_VAR 0 2
50340: PPUSH
50341: LD_INT 3
50343: PPUSH
50344: CALL 60090 0 2
50348: ST_TO_ADDR
// if fac then
50349: LD_VAR 0 10
50353: IFFALSE 50449
// begin for k in fac do
50355: LD_ADDR_VAR 0 4
50359: PUSH
50360: LD_VAR 0 10
50364: PUSH
50365: FOR_IN
50366: IFFALSE 50447
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50368: LD_ADDR_VAR 0 11
50372: PUSH
50373: LD_VAR 0 10
50377: PPUSH
50378: LD_VAR 0 3
50382: PPUSH
50383: CALL_OW 265
50387: PPUSH
50388: LD_VAR 0 3
50392: PPUSH
50393: CALL_OW 262
50397: PPUSH
50398: LD_VAR 0 3
50402: PPUSH
50403: CALL_OW 263
50407: PPUSH
50408: LD_VAR 0 3
50412: PPUSH
50413: CALL_OW 264
50417: PPUSH
50418: CALL 68658 0 5
50422: ST_TO_ADDR
// if components then
50423: LD_VAR 0 11
50427: IFFALSE 50445
// begin MC_InsertProduceList ( i , components ) ;
50429: LD_VAR 0 2
50433: PPUSH
50434: LD_VAR 0 11
50438: PPUSH
50439: CALL 59635 0 2
// break ;
50443: GO 50447
// end ; end ;
50445: GO 50365
50447: POP
50448: POP
// end ; continue ;
50449: GO 49994
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50451: LD_VAR 0 3
50455: PPUSH
50456: LD_INT 1
50458: PPUSH
50459: CALL_OW 289
50463: PUSH
50464: LD_INT 100
50466: LESS
50467: PUSH
50468: LD_VAR 0 3
50472: PPUSH
50473: CALL_OW 314
50477: NOT
50478: AND
50479: IFFALSE 50508
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50481: LD_VAR 0 3
50485: PPUSH
50486: LD_VAR 0 7
50490: PUSH
50491: LD_INT 2
50493: ARRAY
50494: PPUSH
50495: LD_VAR 0 7
50499: PUSH
50500: LD_INT 3
50502: ARRAY
50503: PPUSH
50504: CALL_OW 117
// break ;
50508: GO 50512
// end ;
50510: GO 49994
50512: POP
50513: POP
// end ; end ;
50514: GO 48710
50516: POP
50517: POP
// end ;
50518: LD_VAR 0 1
50522: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50523: LD_INT 0
50525: PPUSH
50526: PPUSH
50527: PPUSH
50528: PPUSH
// if not mc_bases then
50529: LD_EXP 97
50533: NOT
50534: IFFALSE 50538
// exit ;
50536: GO 50699
// for i = 1 to mc_bases do
50538: LD_ADDR_VAR 0 2
50542: PUSH
50543: DOUBLE
50544: LD_INT 1
50546: DEC
50547: ST_TO_ADDR
50548: LD_EXP 97
50552: PUSH
50553: FOR_TO
50554: IFFALSE 50697
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50556: LD_ADDR_VAR 0 4
50560: PUSH
50561: LD_EXP 116
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: PUSH
50572: LD_EXP 119
50576: PUSH
50577: LD_VAR 0 2
50581: ARRAY
50582: UNION
50583: PPUSH
50584: LD_INT 33
50586: PUSH
50587: LD_INT 2
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: PPUSH
50594: CALL_OW 72
50598: ST_TO_ADDR
// if tmp then
50599: LD_VAR 0 4
50603: IFFALSE 50695
// for j in tmp do
50605: LD_ADDR_VAR 0 3
50609: PUSH
50610: LD_VAR 0 4
50614: PUSH
50615: FOR_IN
50616: IFFALSE 50693
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50618: LD_VAR 0 3
50622: PPUSH
50623: CALL_OW 312
50627: NOT
50628: PUSH
50629: LD_VAR 0 3
50633: PPUSH
50634: CALL_OW 256
50638: PUSH
50639: LD_INT 250
50641: GREATEREQUAL
50642: AND
50643: IFFALSE 50656
// Connect ( j ) else
50645: LD_VAR 0 3
50649: PPUSH
50650: CALL 74129 0 1
50654: GO 50691
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50656: LD_VAR 0 3
50660: PPUSH
50661: CALL_OW 256
50665: PUSH
50666: LD_INT 250
50668: LESS
50669: PUSH
50670: LD_VAR 0 3
50674: PPUSH
50675: CALL_OW 312
50679: AND
50680: IFFALSE 50691
// ComUnlink ( j ) ;
50682: LD_VAR 0 3
50686: PPUSH
50687: CALL_OW 136
50691: GO 50615
50693: POP
50694: POP
// end ;
50695: GO 50553
50697: POP
50698: POP
// end ;
50699: LD_VAR 0 1
50703: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50704: LD_INT 0
50706: PPUSH
50707: PPUSH
50708: PPUSH
50709: PPUSH
50710: PPUSH
// if not mc_bases then
50711: LD_EXP 97
50715: NOT
50716: IFFALSE 50720
// exit ;
50718: GO 51165
// for i = 1 to mc_bases do
50720: LD_ADDR_VAR 0 2
50724: PUSH
50725: DOUBLE
50726: LD_INT 1
50728: DEC
50729: ST_TO_ADDR
50730: LD_EXP 97
50734: PUSH
50735: FOR_TO
50736: IFFALSE 51163
// begin if not mc_produce [ i ] then
50738: LD_EXP 118
50742: PUSH
50743: LD_VAR 0 2
50747: ARRAY
50748: NOT
50749: IFFALSE 50753
// continue ;
50751: GO 50735
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50753: LD_ADDR_VAR 0 5
50757: PUSH
50758: LD_EXP 97
50762: PUSH
50763: LD_VAR 0 2
50767: ARRAY
50768: PPUSH
50769: LD_INT 30
50771: PUSH
50772: LD_INT 3
50774: PUSH
50775: EMPTY
50776: LIST
50777: LIST
50778: PPUSH
50779: CALL_OW 72
50783: ST_TO_ADDR
// if not fac then
50784: LD_VAR 0 5
50788: NOT
50789: IFFALSE 50793
// continue ;
50791: GO 50735
// for j in fac do
50793: LD_ADDR_VAR 0 3
50797: PUSH
50798: LD_VAR 0 5
50802: PUSH
50803: FOR_IN
50804: IFFALSE 51159
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50806: LD_VAR 0 3
50810: PPUSH
50811: CALL_OW 461
50815: PUSH
50816: LD_INT 2
50818: NONEQUAL
50819: PUSH
50820: LD_VAR 0 3
50824: PPUSH
50825: LD_INT 15
50827: PPUSH
50828: CALL 73757 0 2
50832: PUSH
50833: LD_INT 4
50835: ARRAY
50836: OR
50837: IFFALSE 50841
// continue ;
50839: GO 50803
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50841: LD_VAR 0 3
50845: PPUSH
50846: LD_EXP 118
50850: PUSH
50851: LD_VAR 0 2
50855: ARRAY
50856: PUSH
50857: LD_INT 1
50859: ARRAY
50860: PUSH
50861: LD_INT 1
50863: ARRAY
50864: PPUSH
50865: LD_EXP 118
50869: PUSH
50870: LD_VAR 0 2
50874: ARRAY
50875: PUSH
50876: LD_INT 1
50878: ARRAY
50879: PUSH
50880: LD_INT 2
50882: ARRAY
50883: PPUSH
50884: LD_EXP 118
50888: PUSH
50889: LD_VAR 0 2
50893: ARRAY
50894: PUSH
50895: LD_INT 1
50897: ARRAY
50898: PUSH
50899: LD_INT 3
50901: ARRAY
50902: PPUSH
50903: LD_EXP 118
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: PUSH
50914: LD_INT 1
50916: ARRAY
50917: PUSH
50918: LD_INT 4
50920: ARRAY
50921: PPUSH
50922: CALL_OW 448
50926: PUSH
50927: LD_VAR 0 3
50931: PPUSH
50932: LD_EXP 118
50936: PUSH
50937: LD_VAR 0 2
50941: ARRAY
50942: PUSH
50943: LD_INT 1
50945: ARRAY
50946: PUSH
50947: LD_INT 1
50949: ARRAY
50950: PUSH
50951: LD_EXP 118
50955: PUSH
50956: LD_VAR 0 2
50960: ARRAY
50961: PUSH
50962: LD_INT 1
50964: ARRAY
50965: PUSH
50966: LD_INT 2
50968: ARRAY
50969: PUSH
50970: LD_EXP 118
50974: PUSH
50975: LD_VAR 0 2
50979: ARRAY
50980: PUSH
50981: LD_INT 1
50983: ARRAY
50984: PUSH
50985: LD_INT 3
50987: ARRAY
50988: PUSH
50989: LD_EXP 118
50993: PUSH
50994: LD_VAR 0 2
50998: ARRAY
50999: PUSH
51000: LD_INT 1
51002: ARRAY
51003: PUSH
51004: LD_INT 4
51006: ARRAY
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: PPUSH
51014: CALL 77524 0 2
51018: AND
51019: IFFALSE 51157
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
51021: LD_VAR 0 3
51025: PPUSH
51026: LD_EXP 118
51030: PUSH
51031: LD_VAR 0 2
51035: ARRAY
51036: PUSH
51037: LD_INT 1
51039: ARRAY
51040: PUSH
51041: LD_INT 1
51043: ARRAY
51044: PPUSH
51045: LD_EXP 118
51049: PUSH
51050: LD_VAR 0 2
51054: ARRAY
51055: PUSH
51056: LD_INT 1
51058: ARRAY
51059: PUSH
51060: LD_INT 2
51062: ARRAY
51063: PPUSH
51064: LD_EXP 118
51068: PUSH
51069: LD_VAR 0 2
51073: ARRAY
51074: PUSH
51075: LD_INT 1
51077: ARRAY
51078: PUSH
51079: LD_INT 3
51081: ARRAY
51082: PPUSH
51083: LD_EXP 118
51087: PUSH
51088: LD_VAR 0 2
51092: ARRAY
51093: PUSH
51094: LD_INT 1
51096: ARRAY
51097: PUSH
51098: LD_INT 4
51100: ARRAY
51101: PPUSH
51102: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
51106: LD_ADDR_VAR 0 4
51110: PUSH
51111: LD_EXP 118
51115: PUSH
51116: LD_VAR 0 2
51120: ARRAY
51121: PPUSH
51122: LD_INT 1
51124: PPUSH
51125: CALL_OW 3
51129: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51130: LD_ADDR_EXP 118
51134: PUSH
51135: LD_EXP 118
51139: PPUSH
51140: LD_VAR 0 2
51144: PPUSH
51145: LD_VAR 0 4
51149: PPUSH
51150: CALL_OW 1
51154: ST_TO_ADDR
// break ;
51155: GO 51159
// end ; end ;
51157: GO 50803
51159: POP
51160: POP
// end ;
51161: GO 50735
51163: POP
51164: POP
// end ;
51165: LD_VAR 0 1
51169: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51170: LD_INT 0
51172: PPUSH
51173: PPUSH
51174: PPUSH
// if not mc_bases then
51175: LD_EXP 97
51179: NOT
51180: IFFALSE 51184
// exit ;
51182: GO 51273
// for i = 1 to mc_bases do
51184: LD_ADDR_VAR 0 2
51188: PUSH
51189: DOUBLE
51190: LD_INT 1
51192: DEC
51193: ST_TO_ADDR
51194: LD_EXP 97
51198: PUSH
51199: FOR_TO
51200: IFFALSE 51271
// begin if mc_attack [ i ] then
51202: LD_EXP 117
51206: PUSH
51207: LD_VAR 0 2
51211: ARRAY
51212: IFFALSE 51269
// begin tmp := mc_attack [ i ] [ 1 ] ;
51214: LD_ADDR_VAR 0 3
51218: PUSH
51219: LD_EXP 117
51223: PUSH
51224: LD_VAR 0 2
51228: ARRAY
51229: PUSH
51230: LD_INT 1
51232: ARRAY
51233: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51234: LD_ADDR_EXP 117
51238: PUSH
51239: LD_EXP 117
51243: PPUSH
51244: LD_VAR 0 2
51248: PPUSH
51249: EMPTY
51250: PPUSH
51251: CALL_OW 1
51255: ST_TO_ADDR
// Attack ( tmp ) ;
51256: LD_VAR 0 3
51260: PPUSH
51261: CALL 127219 0 1
// exit ;
51265: POP
51266: POP
51267: GO 51273
// end ; end ;
51269: GO 51199
51271: POP
51272: POP
// end ;
51273: LD_VAR 0 1
51277: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51278: LD_INT 0
51280: PPUSH
51281: PPUSH
51282: PPUSH
51283: PPUSH
51284: PPUSH
51285: PPUSH
51286: PPUSH
// if not mc_bases then
51287: LD_EXP 97
51291: NOT
51292: IFFALSE 51296
// exit ;
51294: GO 52153
// for i = 1 to mc_bases do
51296: LD_ADDR_VAR 0 2
51300: PUSH
51301: DOUBLE
51302: LD_INT 1
51304: DEC
51305: ST_TO_ADDR
51306: LD_EXP 97
51310: PUSH
51311: FOR_TO
51312: IFFALSE 52151
// begin if not mc_bases [ i ] then
51314: LD_EXP 97
51318: PUSH
51319: LD_VAR 0 2
51323: ARRAY
51324: NOT
51325: IFFALSE 51329
// continue ;
51327: GO 51311
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51329: LD_ADDR_VAR 0 7
51333: PUSH
51334: LD_EXP 97
51338: PUSH
51339: LD_VAR 0 2
51343: ARRAY
51344: PUSH
51345: LD_INT 1
51347: ARRAY
51348: PPUSH
51349: CALL 67809 0 1
51353: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51354: LD_ADDR_EXP 120
51358: PUSH
51359: LD_EXP 120
51363: PPUSH
51364: LD_VAR 0 2
51368: PPUSH
51369: LD_EXP 97
51373: PUSH
51374: LD_VAR 0 2
51378: ARRAY
51379: PUSH
51380: LD_INT 1
51382: ARRAY
51383: PPUSH
51384: CALL_OW 255
51388: PPUSH
51389: LD_EXP 122
51393: PUSH
51394: LD_VAR 0 2
51398: ARRAY
51399: PPUSH
51400: CALL 67774 0 2
51404: PPUSH
51405: CALL_OW 1
51409: ST_TO_ADDR
// if not mc_scan [ i ] then
51410: LD_EXP 120
51414: PUSH
51415: LD_VAR 0 2
51419: ARRAY
51420: NOT
51421: IFFALSE 51599
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51423: LD_ADDR_EXP 140
51427: PUSH
51428: LD_EXP 140
51432: PPUSH
51433: LD_VAR 0 2
51437: PPUSH
51438: LD_INT 0
51440: PPUSH
51441: CALL_OW 1
51445: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51446: LD_ADDR_VAR 0 4
51450: PUSH
51451: LD_EXP 97
51455: PUSH
51456: LD_VAR 0 2
51460: ARRAY
51461: PPUSH
51462: LD_INT 2
51464: PUSH
51465: LD_INT 25
51467: PUSH
51468: LD_INT 5
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: PUSH
51475: LD_INT 25
51477: PUSH
51478: LD_INT 8
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: PUSH
51485: LD_INT 25
51487: PUSH
51488: LD_INT 9
51490: PUSH
51491: EMPTY
51492: LIST
51493: LIST
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: PPUSH
51501: CALL_OW 72
51505: ST_TO_ADDR
// if not tmp then
51506: LD_VAR 0 4
51510: NOT
51511: IFFALSE 51515
// continue ;
51513: GO 51311
// for j in tmp do
51515: LD_ADDR_VAR 0 3
51519: PUSH
51520: LD_VAR 0 4
51524: PUSH
51525: FOR_IN
51526: IFFALSE 51597
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51528: LD_VAR 0 3
51532: PPUSH
51533: CALL_OW 310
51537: PPUSH
51538: CALL_OW 266
51542: PUSH
51543: LD_INT 5
51545: EQUAL
51546: PUSH
51547: LD_VAR 0 3
51551: PPUSH
51552: CALL_OW 257
51556: PUSH
51557: LD_INT 1
51559: EQUAL
51560: AND
51561: PUSH
51562: LD_VAR 0 3
51566: PPUSH
51567: CALL_OW 459
51571: NOT
51572: AND
51573: PUSH
51574: LD_VAR 0 7
51578: AND
51579: IFFALSE 51595
// ComChangeProfession ( j , class ) ;
51581: LD_VAR 0 3
51585: PPUSH
51586: LD_VAR 0 7
51590: PPUSH
51591: CALL_OW 123
51595: GO 51525
51597: POP
51598: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51599: LD_EXP 120
51603: PUSH
51604: LD_VAR 0 2
51608: ARRAY
51609: PUSH
51610: LD_EXP 140
51614: PUSH
51615: LD_VAR 0 2
51619: ARRAY
51620: NOT
51621: AND
51622: PUSH
51623: LD_EXP 119
51627: PUSH
51628: LD_VAR 0 2
51632: ARRAY
51633: NOT
51634: AND
51635: PUSH
51636: LD_EXP 97
51640: PUSH
51641: LD_VAR 0 2
51645: ARRAY
51646: PPUSH
51647: LD_INT 50
51649: PUSH
51650: EMPTY
51651: LIST
51652: PUSH
51653: LD_INT 2
51655: PUSH
51656: LD_INT 30
51658: PUSH
51659: LD_INT 32
51661: PUSH
51662: EMPTY
51663: LIST
51664: LIST
51665: PUSH
51666: LD_INT 30
51668: PUSH
51669: LD_INT 33
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PUSH
51676: LD_INT 30
51678: PUSH
51679: LD_INT 4
51681: PUSH
51682: EMPTY
51683: LIST
51684: LIST
51685: PUSH
51686: LD_INT 30
51688: PUSH
51689: LD_INT 5
51691: PUSH
51692: EMPTY
51693: LIST
51694: LIST
51695: PUSH
51696: EMPTY
51697: LIST
51698: LIST
51699: LIST
51700: LIST
51701: LIST
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PPUSH
51707: CALL_OW 72
51711: PUSH
51712: LD_INT 4
51714: LESS
51715: PUSH
51716: LD_EXP 97
51720: PUSH
51721: LD_VAR 0 2
51725: ARRAY
51726: PPUSH
51727: LD_INT 3
51729: PUSH
51730: LD_INT 24
51732: PUSH
51733: LD_INT 1000
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: PUSH
51740: EMPTY
51741: LIST
51742: LIST
51743: PUSH
51744: LD_INT 2
51746: PUSH
51747: LD_INT 30
51749: PUSH
51750: LD_INT 0
51752: PUSH
51753: EMPTY
51754: LIST
51755: LIST
51756: PUSH
51757: LD_INT 30
51759: PUSH
51760: LD_INT 1
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: PUSH
51767: EMPTY
51768: LIST
51769: LIST
51770: LIST
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PPUSH
51776: CALL_OW 72
51780: OR
51781: AND
51782: IFFALSE 52033
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51784: LD_ADDR_EXP 140
51788: PUSH
51789: LD_EXP 140
51793: PPUSH
51794: LD_VAR 0 2
51798: PPUSH
51799: LD_INT 1
51801: PPUSH
51802: CALL_OW 1
51806: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51807: LD_ADDR_VAR 0 4
51811: PUSH
51812: LD_EXP 97
51816: PUSH
51817: LD_VAR 0 2
51821: ARRAY
51822: PPUSH
51823: LD_INT 2
51825: PUSH
51826: LD_INT 25
51828: PUSH
51829: LD_INT 1
51831: PUSH
51832: EMPTY
51833: LIST
51834: LIST
51835: PUSH
51836: LD_INT 25
51838: PUSH
51839: LD_INT 5
51841: PUSH
51842: EMPTY
51843: LIST
51844: LIST
51845: PUSH
51846: LD_INT 25
51848: PUSH
51849: LD_INT 8
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: PUSH
51856: LD_INT 25
51858: PUSH
51859: LD_INT 9
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: PUSH
51866: EMPTY
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: PPUSH
51873: CALL_OW 72
51877: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51878: LD_ADDR_VAR 0 4
51882: PUSH
51883: LD_VAR 0 4
51887: PUSH
51888: LD_VAR 0 4
51892: PPUSH
51893: LD_INT 18
51895: PPUSH
51896: CALL 101046 0 2
51900: DIFF
51901: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51902: LD_VAR 0 4
51906: NOT
51907: PUSH
51908: LD_EXP 97
51912: PUSH
51913: LD_VAR 0 2
51917: ARRAY
51918: PPUSH
51919: LD_INT 2
51921: PUSH
51922: LD_INT 30
51924: PUSH
51925: LD_INT 4
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: PUSH
51932: LD_INT 30
51934: PUSH
51935: LD_INT 5
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: LIST
51946: PPUSH
51947: CALL_OW 72
51951: NOT
51952: AND
51953: IFFALSE 52015
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51955: LD_ADDR_VAR 0 4
51959: PUSH
51960: LD_EXP 97
51964: PUSH
51965: LD_VAR 0 2
51969: ARRAY
51970: PPUSH
51971: LD_INT 2
51973: PUSH
51974: LD_INT 25
51976: PUSH
51977: LD_INT 2
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: PUSH
51984: LD_INT 25
51986: PUSH
51987: LD_INT 3
51989: PUSH
51990: EMPTY
51991: LIST
51992: LIST
51993: PUSH
51994: LD_INT 25
51996: PUSH
51997: LD_INT 4
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: LIST
52008: LIST
52009: PPUSH
52010: CALL_OW 72
52014: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
52015: LD_VAR 0 2
52019: PPUSH
52020: LD_VAR 0 4
52024: PPUSH
52025: CALL 131928 0 2
// exit ;
52029: POP
52030: POP
52031: GO 52153
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
52033: LD_EXP 120
52037: PUSH
52038: LD_VAR 0 2
52042: ARRAY
52043: PUSH
52044: LD_EXP 140
52048: PUSH
52049: LD_VAR 0 2
52053: ARRAY
52054: NOT
52055: AND
52056: PUSH
52057: LD_EXP 119
52061: PUSH
52062: LD_VAR 0 2
52066: ARRAY
52067: AND
52068: IFFALSE 52149
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
52070: LD_ADDR_EXP 140
52074: PUSH
52075: LD_EXP 140
52079: PPUSH
52080: LD_VAR 0 2
52084: PPUSH
52085: LD_INT 1
52087: PPUSH
52088: CALL_OW 1
52092: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
52093: LD_ADDR_VAR 0 4
52097: PUSH
52098: LD_EXP 119
52102: PUSH
52103: LD_VAR 0 2
52107: ARRAY
52108: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52109: LD_ADDR_EXP 119
52113: PUSH
52114: LD_EXP 119
52118: PPUSH
52119: LD_VAR 0 2
52123: PPUSH
52124: EMPTY
52125: PPUSH
52126: CALL_OW 1
52130: ST_TO_ADDR
// Defend ( i , tmp ) ;
52131: LD_VAR 0 2
52135: PPUSH
52136: LD_VAR 0 4
52140: PPUSH
52141: CALL 132524 0 2
// exit ;
52145: POP
52146: POP
52147: GO 52153
// end ; end ;
52149: GO 51311
52151: POP
52152: POP
// end ;
52153: LD_VAR 0 1
52157: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
52158: LD_INT 0
52160: PPUSH
52161: PPUSH
52162: PPUSH
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
52169: PPUSH
52170: PPUSH
// if not mc_bases then
52171: LD_EXP 97
52175: NOT
52176: IFFALSE 52180
// exit ;
52178: GO 53267
// for i = 1 to mc_bases do
52180: LD_ADDR_VAR 0 2
52184: PUSH
52185: DOUBLE
52186: LD_INT 1
52188: DEC
52189: ST_TO_ADDR
52190: LD_EXP 97
52194: PUSH
52195: FOR_TO
52196: IFFALSE 53265
// begin tmp := mc_lab [ i ] ;
52198: LD_ADDR_VAR 0 6
52202: PUSH
52203: LD_EXP 130
52207: PUSH
52208: LD_VAR 0 2
52212: ARRAY
52213: ST_TO_ADDR
// if not tmp then
52214: LD_VAR 0 6
52218: NOT
52219: IFFALSE 52223
// continue ;
52221: GO 52195
// idle_lab := 0 ;
52223: LD_ADDR_VAR 0 11
52227: PUSH
52228: LD_INT 0
52230: ST_TO_ADDR
// for j in tmp do
52231: LD_ADDR_VAR 0 3
52235: PUSH
52236: LD_VAR 0 6
52240: PUSH
52241: FOR_IN
52242: IFFALSE 53261
// begin researching := false ;
52244: LD_ADDR_VAR 0 10
52248: PUSH
52249: LD_INT 0
52251: ST_TO_ADDR
// side := GetSide ( j ) ;
52252: LD_ADDR_VAR 0 4
52256: PUSH
52257: LD_VAR 0 3
52261: PPUSH
52262: CALL_OW 255
52266: ST_TO_ADDR
// if not mc_tech [ side ] then
52267: LD_EXP 124
52271: PUSH
52272: LD_VAR 0 4
52276: ARRAY
52277: NOT
52278: IFFALSE 52282
// continue ;
52280: GO 52241
// if BuildingStatus ( j ) = bs_idle then
52282: LD_VAR 0 3
52286: PPUSH
52287: CALL_OW 461
52291: PUSH
52292: LD_INT 2
52294: EQUAL
52295: IFFALSE 52483
// begin if idle_lab and UnitsInside ( j ) < 6 then
52297: LD_VAR 0 11
52301: PUSH
52302: LD_VAR 0 3
52306: PPUSH
52307: CALL_OW 313
52311: PUSH
52312: LD_INT 6
52314: LESS
52315: AND
52316: IFFALSE 52387
// begin tmp2 := UnitsInside ( idle_lab ) ;
52318: LD_ADDR_VAR 0 9
52322: PUSH
52323: LD_VAR 0 11
52327: PPUSH
52328: CALL_OW 313
52332: ST_TO_ADDR
// if tmp2 then
52333: LD_VAR 0 9
52337: IFFALSE 52379
// for x in tmp2 do
52339: LD_ADDR_VAR 0 7
52343: PUSH
52344: LD_VAR 0 9
52348: PUSH
52349: FOR_IN
52350: IFFALSE 52377
// begin ComExitBuilding ( x ) ;
52352: LD_VAR 0 7
52356: PPUSH
52357: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52361: LD_VAR 0 7
52365: PPUSH
52366: LD_VAR 0 3
52370: PPUSH
52371: CALL_OW 180
// end ;
52375: GO 52349
52377: POP
52378: POP
// idle_lab := 0 ;
52379: LD_ADDR_VAR 0 11
52383: PUSH
52384: LD_INT 0
52386: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52387: LD_ADDR_VAR 0 5
52391: PUSH
52392: LD_EXP 124
52396: PUSH
52397: LD_VAR 0 4
52401: ARRAY
52402: PUSH
52403: FOR_IN
52404: IFFALSE 52464
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52406: LD_VAR 0 3
52410: PPUSH
52411: LD_VAR 0 5
52415: PPUSH
52416: CALL_OW 430
52420: PUSH
52421: LD_VAR 0 4
52425: PPUSH
52426: LD_VAR 0 5
52430: PPUSH
52431: CALL 66879 0 2
52435: AND
52436: IFFALSE 52462
// begin researching := true ;
52438: LD_ADDR_VAR 0 10
52442: PUSH
52443: LD_INT 1
52445: ST_TO_ADDR
// ComResearch ( j , t ) ;
52446: LD_VAR 0 3
52450: PPUSH
52451: LD_VAR 0 5
52455: PPUSH
52456: CALL_OW 124
// break ;
52460: GO 52464
// end ;
52462: GO 52403
52464: POP
52465: POP
// if not researching then
52466: LD_VAR 0 10
52470: NOT
52471: IFFALSE 52483
// idle_lab := j ;
52473: LD_ADDR_VAR 0 11
52477: PUSH
52478: LD_VAR 0 3
52482: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52483: LD_VAR 0 3
52487: PPUSH
52488: CALL_OW 461
52492: PUSH
52493: LD_INT 10
52495: EQUAL
52496: IFFALSE 53084
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52498: LD_EXP 126
52502: PUSH
52503: LD_VAR 0 2
52507: ARRAY
52508: NOT
52509: PUSH
52510: LD_EXP 127
52514: PUSH
52515: LD_VAR 0 2
52519: ARRAY
52520: NOT
52521: AND
52522: PUSH
52523: LD_EXP 124
52527: PUSH
52528: LD_VAR 0 4
52532: ARRAY
52533: PUSH
52534: LD_INT 1
52536: GREATER
52537: AND
52538: IFFALSE 52669
// begin ComCancel ( j ) ;
52540: LD_VAR 0 3
52544: PPUSH
52545: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52549: LD_ADDR_EXP 124
52553: PUSH
52554: LD_EXP 124
52558: PPUSH
52559: LD_VAR 0 4
52563: PPUSH
52564: LD_EXP 124
52568: PUSH
52569: LD_VAR 0 4
52573: ARRAY
52574: PPUSH
52575: LD_EXP 124
52579: PUSH
52580: LD_VAR 0 4
52584: ARRAY
52585: PUSH
52586: LD_INT 1
52588: MINUS
52589: PPUSH
52590: LD_EXP 124
52594: PUSH
52595: LD_VAR 0 4
52599: ARRAY
52600: PPUSH
52601: LD_INT 0
52603: PPUSH
52604: CALL 70578 0 4
52608: PPUSH
52609: CALL_OW 1
52613: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52614: LD_ADDR_EXP 124
52618: PUSH
52619: LD_EXP 124
52623: PPUSH
52624: LD_VAR 0 4
52628: PPUSH
52629: LD_EXP 124
52633: PUSH
52634: LD_VAR 0 4
52638: ARRAY
52639: PPUSH
52640: LD_EXP 124
52644: PUSH
52645: LD_VAR 0 4
52649: ARRAY
52650: PPUSH
52651: LD_INT 1
52653: PPUSH
52654: LD_INT 0
52656: PPUSH
52657: CALL 70578 0 4
52661: PPUSH
52662: CALL_OW 1
52666: ST_TO_ADDR
// continue ;
52667: GO 52241
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52669: LD_EXP 126
52673: PUSH
52674: LD_VAR 0 2
52678: ARRAY
52679: PUSH
52680: LD_EXP 127
52684: PUSH
52685: LD_VAR 0 2
52689: ARRAY
52690: NOT
52691: AND
52692: IFFALSE 52819
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52694: LD_ADDR_EXP 127
52698: PUSH
52699: LD_EXP 127
52703: PPUSH
52704: LD_VAR 0 2
52708: PUSH
52709: LD_EXP 127
52713: PUSH
52714: LD_VAR 0 2
52718: ARRAY
52719: PUSH
52720: LD_INT 1
52722: PLUS
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PPUSH
52728: LD_EXP 126
52732: PUSH
52733: LD_VAR 0 2
52737: ARRAY
52738: PUSH
52739: LD_INT 1
52741: ARRAY
52742: PPUSH
52743: CALL 71160 0 3
52747: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52748: LD_EXP 126
52752: PUSH
52753: LD_VAR 0 2
52757: ARRAY
52758: PUSH
52759: LD_INT 1
52761: ARRAY
52762: PPUSH
52763: LD_INT 112
52765: PPUSH
52766: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52770: LD_ADDR_VAR 0 9
52774: PUSH
52775: LD_EXP 126
52779: PUSH
52780: LD_VAR 0 2
52784: ARRAY
52785: PPUSH
52786: LD_INT 1
52788: PPUSH
52789: CALL_OW 3
52793: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52794: LD_ADDR_EXP 126
52798: PUSH
52799: LD_EXP 126
52803: PPUSH
52804: LD_VAR 0 2
52808: PPUSH
52809: LD_VAR 0 9
52813: PPUSH
52814: CALL_OW 1
52818: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52819: LD_EXP 126
52823: PUSH
52824: LD_VAR 0 2
52828: ARRAY
52829: PUSH
52830: LD_EXP 127
52834: PUSH
52835: LD_VAR 0 2
52839: ARRAY
52840: AND
52841: PUSH
52842: LD_EXP 127
52846: PUSH
52847: LD_VAR 0 2
52851: ARRAY
52852: PUSH
52853: LD_INT 1
52855: ARRAY
52856: PPUSH
52857: CALL_OW 310
52861: NOT
52862: AND
52863: PUSH
52864: LD_VAR 0 3
52868: PPUSH
52869: CALL_OW 313
52873: PUSH
52874: LD_INT 6
52876: EQUAL
52877: AND
52878: IFFALSE 52934
// begin tmp2 := UnitsInside ( j ) ;
52880: LD_ADDR_VAR 0 9
52884: PUSH
52885: LD_VAR 0 3
52889: PPUSH
52890: CALL_OW 313
52894: ST_TO_ADDR
// if tmp2 = 6 then
52895: LD_VAR 0 9
52899: PUSH
52900: LD_INT 6
52902: EQUAL
52903: IFFALSE 52934
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52905: LD_VAR 0 9
52909: PUSH
52910: LD_INT 1
52912: ARRAY
52913: PPUSH
52914: LD_INT 112
52916: PPUSH
52917: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52921: LD_VAR 0 9
52925: PUSH
52926: LD_INT 1
52928: ARRAY
52929: PPUSH
52930: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52934: LD_EXP 127
52938: PUSH
52939: LD_VAR 0 2
52943: ARRAY
52944: PUSH
52945: LD_EXP 127
52949: PUSH
52950: LD_VAR 0 2
52954: ARRAY
52955: PUSH
52956: LD_INT 1
52958: ARRAY
52959: PPUSH
52960: CALL_OW 314
52964: NOT
52965: AND
52966: PUSH
52967: LD_EXP 127
52971: PUSH
52972: LD_VAR 0 2
52976: ARRAY
52977: PUSH
52978: LD_INT 1
52980: ARRAY
52981: PPUSH
52982: CALL_OW 310
52986: NOT
52987: AND
52988: IFFALSE 53014
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52990: LD_EXP 127
52994: PUSH
52995: LD_VAR 0 2
52999: ARRAY
53000: PUSH
53001: LD_INT 1
53003: ARRAY
53004: PPUSH
53005: LD_VAR 0 3
53009: PPUSH
53010: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
53014: LD_EXP 127
53018: PUSH
53019: LD_VAR 0 2
53023: ARRAY
53024: PUSH
53025: LD_INT 1
53027: ARRAY
53028: PPUSH
53029: CALL_OW 310
53033: PUSH
53034: LD_EXP 127
53038: PUSH
53039: LD_VAR 0 2
53043: ARRAY
53044: PUSH
53045: LD_INT 1
53047: ARRAY
53048: PPUSH
53049: CALL_OW 310
53053: PPUSH
53054: CALL_OW 461
53058: PUSH
53059: LD_INT 3
53061: NONEQUAL
53062: AND
53063: IFFALSE 53084
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
53065: LD_EXP 127
53069: PUSH
53070: LD_VAR 0 2
53074: ARRAY
53075: PUSH
53076: LD_INT 1
53078: ARRAY
53079: PPUSH
53080: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
53084: LD_VAR 0 3
53088: PPUSH
53089: CALL_OW 461
53093: PUSH
53094: LD_INT 6
53096: EQUAL
53097: PUSH
53098: LD_VAR 0 6
53102: PUSH
53103: LD_INT 1
53105: GREATER
53106: AND
53107: IFFALSE 53259
// begin sci := [ ] ;
53109: LD_ADDR_VAR 0 8
53113: PUSH
53114: EMPTY
53115: ST_TO_ADDR
// for x in ( tmp diff j ) do
53116: LD_ADDR_VAR 0 7
53120: PUSH
53121: LD_VAR 0 6
53125: PUSH
53126: LD_VAR 0 3
53130: DIFF
53131: PUSH
53132: FOR_IN
53133: IFFALSE 53185
// begin if sci = 6 then
53135: LD_VAR 0 8
53139: PUSH
53140: LD_INT 6
53142: EQUAL
53143: IFFALSE 53147
// break ;
53145: GO 53185
// if BuildingStatus ( x ) = bs_idle then
53147: LD_VAR 0 7
53151: PPUSH
53152: CALL_OW 461
53156: PUSH
53157: LD_INT 2
53159: EQUAL
53160: IFFALSE 53183
// sci := sci ^ UnitsInside ( x ) ;
53162: LD_ADDR_VAR 0 8
53166: PUSH
53167: LD_VAR 0 8
53171: PUSH
53172: LD_VAR 0 7
53176: PPUSH
53177: CALL_OW 313
53181: ADD
53182: ST_TO_ADDR
// end ;
53183: GO 53132
53185: POP
53186: POP
// if not sci then
53187: LD_VAR 0 8
53191: NOT
53192: IFFALSE 53196
// continue ;
53194: GO 52241
// for x in sci do
53196: LD_ADDR_VAR 0 7
53200: PUSH
53201: LD_VAR 0 8
53205: PUSH
53206: FOR_IN
53207: IFFALSE 53257
// if IsInUnit ( x ) and not HasTask ( x ) then
53209: LD_VAR 0 7
53213: PPUSH
53214: CALL_OW 310
53218: PUSH
53219: LD_VAR 0 7
53223: PPUSH
53224: CALL_OW 314
53228: NOT
53229: AND
53230: IFFALSE 53255
// begin ComExitBuilding ( x ) ;
53232: LD_VAR 0 7
53236: PPUSH
53237: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53241: LD_VAR 0 7
53245: PPUSH
53246: LD_VAR 0 3
53250: PPUSH
53251: CALL_OW 180
// end ;
53255: GO 53206
53257: POP
53258: POP
// end ; end ;
53259: GO 52241
53261: POP
53262: POP
// end ;
53263: GO 52195
53265: POP
53266: POP
// end ;
53267: LD_VAR 0 1
53271: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53272: LD_INT 0
53274: PPUSH
53275: PPUSH
// if not mc_bases then
53276: LD_EXP 97
53280: NOT
53281: IFFALSE 53285
// exit ;
53283: GO 53366
// for i = 1 to mc_bases do
53285: LD_ADDR_VAR 0 2
53289: PUSH
53290: DOUBLE
53291: LD_INT 1
53293: DEC
53294: ST_TO_ADDR
53295: LD_EXP 97
53299: PUSH
53300: FOR_TO
53301: IFFALSE 53364
// if mc_mines [ i ] and mc_miners [ i ] then
53303: LD_EXP 110
53307: PUSH
53308: LD_VAR 0 2
53312: ARRAY
53313: PUSH
53314: LD_EXP 111
53318: PUSH
53319: LD_VAR 0 2
53323: ARRAY
53324: AND
53325: IFFALSE 53362
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53327: LD_EXP 111
53331: PUSH
53332: LD_VAR 0 2
53336: ARRAY
53337: PUSH
53338: LD_INT 1
53340: ARRAY
53341: PPUSH
53342: CALL_OW 255
53346: PPUSH
53347: LD_EXP 110
53351: PUSH
53352: LD_VAR 0 2
53356: ARRAY
53357: PPUSH
53358: CALL 67962 0 2
53362: GO 53300
53364: POP
53365: POP
// end ;
53366: LD_VAR 0 1
53370: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53371: LD_INT 0
53373: PPUSH
53374: PPUSH
53375: PPUSH
53376: PPUSH
53377: PPUSH
53378: PPUSH
53379: PPUSH
53380: PPUSH
// if not mc_bases or not mc_parking then
53381: LD_EXP 97
53385: NOT
53386: PUSH
53387: LD_EXP 121
53391: NOT
53392: OR
53393: IFFALSE 53397
// exit ;
53395: GO 54107
// for i = 1 to mc_bases do
53397: LD_ADDR_VAR 0 2
53401: PUSH
53402: DOUBLE
53403: LD_INT 1
53405: DEC
53406: ST_TO_ADDR
53407: LD_EXP 97
53411: PUSH
53412: FOR_TO
53413: IFFALSE 54105
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53415: LD_EXP 97
53419: PUSH
53420: LD_VAR 0 2
53424: ARRAY
53425: NOT
53426: PUSH
53427: LD_EXP 121
53431: PUSH
53432: LD_VAR 0 2
53436: ARRAY
53437: NOT
53438: OR
53439: IFFALSE 53443
// continue ;
53441: GO 53412
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53443: LD_ADDR_VAR 0 5
53447: PUSH
53448: LD_EXP 97
53452: PUSH
53453: LD_VAR 0 2
53457: ARRAY
53458: PUSH
53459: LD_INT 1
53461: ARRAY
53462: PPUSH
53463: CALL_OW 255
53467: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53468: LD_ADDR_VAR 0 6
53472: PUSH
53473: LD_EXP 97
53477: PUSH
53478: LD_VAR 0 2
53482: ARRAY
53483: PPUSH
53484: LD_INT 30
53486: PUSH
53487: LD_INT 3
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PPUSH
53494: CALL_OW 72
53498: ST_TO_ADDR
// if not fac then
53499: LD_VAR 0 6
53503: NOT
53504: IFFALSE 53555
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53506: LD_ADDR_VAR 0 6
53510: PUSH
53511: LD_EXP 97
53515: PUSH
53516: LD_VAR 0 2
53520: ARRAY
53521: PPUSH
53522: LD_INT 2
53524: PUSH
53525: LD_INT 30
53527: PUSH
53528: LD_INT 0
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: PUSH
53535: LD_INT 30
53537: PUSH
53538: LD_INT 1
53540: PUSH
53541: EMPTY
53542: LIST
53543: LIST
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: LIST
53549: PPUSH
53550: CALL_OW 72
53554: ST_TO_ADDR
// if not fac then
53555: LD_VAR 0 6
53559: NOT
53560: IFFALSE 53564
// continue ;
53562: GO 53412
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53564: LD_ADDR_VAR 0 7
53568: PUSH
53569: LD_EXP 121
53573: PUSH
53574: LD_VAR 0 2
53578: ARRAY
53579: PPUSH
53580: LD_INT 22
53582: PUSH
53583: LD_VAR 0 5
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PUSH
53592: LD_INT 21
53594: PUSH
53595: LD_INT 2
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: LD_INT 3
53604: PUSH
53605: LD_INT 24
53607: PUSH
53608: LD_INT 1000
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PUSH
53615: EMPTY
53616: LIST
53617: LIST
53618: PUSH
53619: EMPTY
53620: LIST
53621: LIST
53622: LIST
53623: PPUSH
53624: CALL_OW 70
53628: ST_TO_ADDR
// for j in fac do
53629: LD_ADDR_VAR 0 3
53633: PUSH
53634: LD_VAR 0 6
53638: PUSH
53639: FOR_IN
53640: IFFALSE 53721
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53642: LD_ADDR_VAR 0 7
53646: PUSH
53647: LD_VAR 0 7
53651: PUSH
53652: LD_INT 22
53654: PUSH
53655: LD_VAR 0 5
53659: PUSH
53660: EMPTY
53661: LIST
53662: LIST
53663: PUSH
53664: LD_INT 91
53666: PUSH
53667: LD_VAR 0 3
53671: PUSH
53672: LD_INT 15
53674: PUSH
53675: EMPTY
53676: LIST
53677: LIST
53678: LIST
53679: PUSH
53680: LD_INT 21
53682: PUSH
53683: LD_INT 2
53685: PUSH
53686: EMPTY
53687: LIST
53688: LIST
53689: PUSH
53690: LD_INT 3
53692: PUSH
53693: LD_INT 24
53695: PUSH
53696: LD_INT 1000
53698: PUSH
53699: EMPTY
53700: LIST
53701: LIST
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PUSH
53707: EMPTY
53708: LIST
53709: LIST
53710: LIST
53711: LIST
53712: PPUSH
53713: CALL_OW 69
53717: UNION
53718: ST_TO_ADDR
53719: GO 53639
53721: POP
53722: POP
// if not vehs then
53723: LD_VAR 0 7
53727: NOT
53728: IFFALSE 53754
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53730: LD_ADDR_EXP 109
53734: PUSH
53735: LD_EXP 109
53739: PPUSH
53740: LD_VAR 0 2
53744: PPUSH
53745: EMPTY
53746: PPUSH
53747: CALL_OW 1
53751: ST_TO_ADDR
// continue ;
53752: GO 53412
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53754: LD_ADDR_VAR 0 8
53758: PUSH
53759: LD_EXP 97
53763: PUSH
53764: LD_VAR 0 2
53768: ARRAY
53769: PPUSH
53770: LD_INT 30
53772: PUSH
53773: LD_INT 3
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PPUSH
53780: CALL_OW 72
53784: ST_TO_ADDR
// if tmp then
53785: LD_VAR 0 8
53789: IFFALSE 53892
// begin for j in tmp do
53791: LD_ADDR_VAR 0 3
53795: PUSH
53796: LD_VAR 0 8
53800: PUSH
53801: FOR_IN
53802: IFFALSE 53890
// for k in UnitsInside ( j ) do
53804: LD_ADDR_VAR 0 4
53808: PUSH
53809: LD_VAR 0 3
53813: PPUSH
53814: CALL_OW 313
53818: PUSH
53819: FOR_IN
53820: IFFALSE 53886
// if k then
53822: LD_VAR 0 4
53826: IFFALSE 53884
// if not k in mc_repair_vehicle [ i ] then
53828: LD_VAR 0 4
53832: PUSH
53833: LD_EXP 109
53837: PUSH
53838: LD_VAR 0 2
53842: ARRAY
53843: IN
53844: NOT
53845: IFFALSE 53884
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53847: LD_ADDR_EXP 109
53851: PUSH
53852: LD_EXP 109
53856: PPUSH
53857: LD_VAR 0 2
53861: PPUSH
53862: LD_EXP 109
53866: PUSH
53867: LD_VAR 0 2
53871: ARRAY
53872: PUSH
53873: LD_VAR 0 4
53877: UNION
53878: PPUSH
53879: CALL_OW 1
53883: ST_TO_ADDR
53884: GO 53819
53886: POP
53887: POP
53888: GO 53801
53890: POP
53891: POP
// end ; if not mc_repair_vehicle [ i ] then
53892: LD_EXP 109
53896: PUSH
53897: LD_VAR 0 2
53901: ARRAY
53902: NOT
53903: IFFALSE 53907
// continue ;
53905: GO 53412
// for j in mc_repair_vehicle [ i ] do
53907: LD_ADDR_VAR 0 3
53911: PUSH
53912: LD_EXP 109
53916: PUSH
53917: LD_VAR 0 2
53921: ARRAY
53922: PUSH
53923: FOR_IN
53924: IFFALSE 54101
// begin if GetClass ( j ) <> 3 then
53926: LD_VAR 0 3
53930: PPUSH
53931: CALL_OW 257
53935: PUSH
53936: LD_INT 3
53938: NONEQUAL
53939: IFFALSE 53980
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53941: LD_ADDR_EXP 109
53945: PUSH
53946: LD_EXP 109
53950: PPUSH
53951: LD_VAR 0 2
53955: PPUSH
53956: LD_EXP 109
53960: PUSH
53961: LD_VAR 0 2
53965: ARRAY
53966: PUSH
53967: LD_VAR 0 3
53971: DIFF
53972: PPUSH
53973: CALL_OW 1
53977: ST_TO_ADDR
// continue ;
53978: GO 53923
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53980: LD_VAR 0 3
53984: PPUSH
53985: CALL_OW 311
53989: NOT
53990: PUSH
53991: LD_VAR 0 3
53995: PUSH
53996: LD_EXP 100
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: PUSH
54007: LD_INT 1
54009: ARRAY
54010: IN
54011: NOT
54012: AND
54013: PUSH
54014: LD_VAR 0 3
54018: PUSH
54019: LD_EXP 100
54023: PUSH
54024: LD_VAR 0 2
54028: ARRAY
54029: PUSH
54030: LD_INT 2
54032: ARRAY
54033: IN
54034: NOT
54035: AND
54036: IFFALSE 54099
// begin if IsInUnit ( j ) then
54038: LD_VAR 0 3
54042: PPUSH
54043: CALL_OW 310
54047: IFFALSE 54060
// ComExitBuilding ( j ) else
54049: LD_VAR 0 3
54053: PPUSH
54054: CALL_OW 122
54058: GO 54099
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
54060: LD_VAR 0 3
54064: PPUSH
54065: LD_VAR 0 7
54069: PUSH
54070: LD_INT 1
54072: ARRAY
54073: PPUSH
54074: CALL 105537 0 2
54078: NOT
54079: IFFALSE 54099
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
54081: LD_VAR 0 3
54085: PPUSH
54086: LD_VAR 0 7
54090: PUSH
54091: LD_INT 1
54093: ARRAY
54094: PPUSH
54095: CALL_OW 129
// end ; end ;
54099: GO 53923
54101: POP
54102: POP
// end ;
54103: GO 53412
54105: POP
54106: POP
// end ;
54107: LD_VAR 0 1
54111: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
54112: LD_INT 0
54114: PPUSH
54115: PPUSH
54116: PPUSH
54117: PPUSH
54118: PPUSH
54119: PPUSH
54120: PPUSH
54121: PPUSH
54122: PPUSH
54123: PPUSH
54124: PPUSH
// if not mc_bases then
54125: LD_EXP 97
54129: NOT
54130: IFFALSE 54134
// exit ;
54132: GO 54936
// for i = 1 to mc_bases do
54134: LD_ADDR_VAR 0 2
54138: PUSH
54139: DOUBLE
54140: LD_INT 1
54142: DEC
54143: ST_TO_ADDR
54144: LD_EXP 97
54148: PUSH
54149: FOR_TO
54150: IFFALSE 54934
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
54152: LD_EXP 125
54156: PUSH
54157: LD_VAR 0 2
54161: ARRAY
54162: NOT
54163: PUSH
54164: LD_EXP 100
54168: PUSH
54169: LD_VAR 0 2
54173: ARRAY
54174: PUSH
54175: LD_INT 1
54177: ARRAY
54178: OR
54179: PUSH
54180: LD_EXP 100
54184: PUSH
54185: LD_VAR 0 2
54189: ARRAY
54190: PUSH
54191: LD_INT 2
54193: ARRAY
54194: OR
54195: PUSH
54196: LD_EXP 123
54200: PUSH
54201: LD_VAR 0 2
54205: ARRAY
54206: PPUSH
54207: LD_INT 1
54209: PPUSH
54210: CALL_OW 325
54214: NOT
54215: OR
54216: PUSH
54217: LD_EXP 120
54221: PUSH
54222: LD_VAR 0 2
54226: ARRAY
54227: OR
54228: IFFALSE 54232
// continue ;
54230: GO 54149
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54232: LD_ADDR_VAR 0 8
54236: PUSH
54237: LD_EXP 97
54241: PUSH
54242: LD_VAR 0 2
54246: ARRAY
54247: PPUSH
54248: LD_INT 25
54250: PUSH
54251: LD_INT 4
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PUSH
54258: LD_INT 50
54260: PUSH
54261: EMPTY
54262: LIST
54263: PUSH
54264: LD_INT 3
54266: PUSH
54267: LD_INT 60
54269: PUSH
54270: EMPTY
54271: LIST
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: LIST
54281: PPUSH
54282: CALL_OW 72
54286: PUSH
54287: LD_EXP 101
54291: PUSH
54292: LD_VAR 0 2
54296: ARRAY
54297: DIFF
54298: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54299: LD_ADDR_VAR 0 9
54303: PUSH
54304: LD_EXP 97
54308: PUSH
54309: LD_VAR 0 2
54313: ARRAY
54314: PPUSH
54315: LD_INT 2
54317: PUSH
54318: LD_INT 30
54320: PUSH
54321: LD_INT 0
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: PUSH
54328: LD_INT 30
54330: PUSH
54331: LD_INT 1
54333: PUSH
54334: EMPTY
54335: LIST
54336: LIST
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: LIST
54342: PPUSH
54343: CALL_OW 72
54347: ST_TO_ADDR
// if not tmp or not dep then
54348: LD_VAR 0 8
54352: NOT
54353: PUSH
54354: LD_VAR 0 9
54358: NOT
54359: OR
54360: IFFALSE 54364
// continue ;
54362: GO 54149
// side := GetSide ( tmp [ 1 ] ) ;
54364: LD_ADDR_VAR 0 11
54368: PUSH
54369: LD_VAR 0 8
54373: PUSH
54374: LD_INT 1
54376: ARRAY
54377: PPUSH
54378: CALL_OW 255
54382: ST_TO_ADDR
// dep := dep [ 1 ] ;
54383: LD_ADDR_VAR 0 9
54387: PUSH
54388: LD_VAR 0 9
54392: PUSH
54393: LD_INT 1
54395: ARRAY
54396: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54397: LD_ADDR_VAR 0 7
54401: PUSH
54402: LD_EXP 125
54406: PUSH
54407: LD_VAR 0 2
54411: ARRAY
54412: PPUSH
54413: LD_INT 22
54415: PUSH
54416: LD_INT 0
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PUSH
54423: LD_INT 25
54425: PUSH
54426: LD_INT 12
54428: PUSH
54429: EMPTY
54430: LIST
54431: LIST
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: PPUSH
54437: CALL_OW 70
54441: PUSH
54442: LD_INT 22
54444: PUSH
54445: LD_INT 0
54447: PUSH
54448: EMPTY
54449: LIST
54450: LIST
54451: PUSH
54452: LD_INT 25
54454: PUSH
54455: LD_INT 12
54457: PUSH
54458: EMPTY
54459: LIST
54460: LIST
54461: PUSH
54462: LD_INT 91
54464: PUSH
54465: LD_VAR 0 9
54469: PUSH
54470: LD_INT 20
54472: PUSH
54473: EMPTY
54474: LIST
54475: LIST
54476: LIST
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: LIST
54482: PPUSH
54483: CALL_OW 69
54487: UNION
54488: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54489: LD_ADDR_VAR 0 10
54493: PUSH
54494: LD_EXP 125
54498: PUSH
54499: LD_VAR 0 2
54503: ARRAY
54504: PPUSH
54505: LD_INT 81
54507: PUSH
54508: LD_VAR 0 11
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: PPUSH
54517: CALL_OW 70
54521: ST_TO_ADDR
// if not apes or danger_at_area then
54522: LD_VAR 0 7
54526: NOT
54527: PUSH
54528: LD_VAR 0 10
54532: OR
54533: IFFALSE 54583
// begin if mc_taming [ i ] then
54535: LD_EXP 128
54539: PUSH
54540: LD_VAR 0 2
54544: ARRAY
54545: IFFALSE 54581
// begin MC_Reset ( i , 121 ) ;
54547: LD_VAR 0 2
54551: PPUSH
54552: LD_INT 121
54554: PPUSH
54555: CALL 39573 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54559: LD_ADDR_EXP 128
54563: PUSH
54564: LD_EXP 128
54568: PPUSH
54569: LD_VAR 0 2
54573: PPUSH
54574: EMPTY
54575: PPUSH
54576: CALL_OW 1
54580: ST_TO_ADDR
// end ; continue ;
54581: GO 54149
// end ; for j in tmp do
54583: LD_ADDR_VAR 0 3
54587: PUSH
54588: LD_VAR 0 8
54592: PUSH
54593: FOR_IN
54594: IFFALSE 54930
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54596: LD_VAR 0 3
54600: PUSH
54601: LD_EXP 128
54605: PUSH
54606: LD_VAR 0 2
54610: ARRAY
54611: IN
54612: NOT
54613: PUSH
54614: LD_EXP 128
54618: PUSH
54619: LD_VAR 0 2
54623: ARRAY
54624: PUSH
54625: LD_INT 3
54627: LESS
54628: AND
54629: IFFALSE 54687
// begin SetTag ( j , 121 ) ;
54631: LD_VAR 0 3
54635: PPUSH
54636: LD_INT 121
54638: PPUSH
54639: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54643: LD_ADDR_EXP 128
54647: PUSH
54648: LD_EXP 128
54652: PPUSH
54653: LD_VAR 0 2
54657: PUSH
54658: LD_EXP 128
54662: PUSH
54663: LD_VAR 0 2
54667: ARRAY
54668: PUSH
54669: LD_INT 1
54671: PLUS
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PPUSH
54677: LD_VAR 0 3
54681: PPUSH
54682: CALL 71160 0 3
54686: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54687: LD_VAR 0 3
54691: PUSH
54692: LD_EXP 128
54696: PUSH
54697: LD_VAR 0 2
54701: ARRAY
54702: IN
54703: IFFALSE 54928
// begin if GetClass ( j ) <> 4 then
54705: LD_VAR 0 3
54709: PPUSH
54710: CALL_OW 257
54714: PUSH
54715: LD_INT 4
54717: NONEQUAL
54718: IFFALSE 54771
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54720: LD_ADDR_EXP 128
54724: PUSH
54725: LD_EXP 128
54729: PPUSH
54730: LD_VAR 0 2
54734: PPUSH
54735: LD_EXP 128
54739: PUSH
54740: LD_VAR 0 2
54744: ARRAY
54745: PUSH
54746: LD_VAR 0 3
54750: DIFF
54751: PPUSH
54752: CALL_OW 1
54756: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54757: LD_VAR 0 3
54761: PPUSH
54762: LD_INT 0
54764: PPUSH
54765: CALL_OW 109
// continue ;
54769: GO 54593
// end ; if IsInUnit ( j ) then
54771: LD_VAR 0 3
54775: PPUSH
54776: CALL_OW 310
54780: IFFALSE 54791
// ComExitBuilding ( j ) ;
54782: LD_VAR 0 3
54786: PPUSH
54787: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54791: LD_ADDR_VAR 0 6
54795: PUSH
54796: LD_VAR 0 7
54800: PPUSH
54801: LD_VAR 0 3
54805: PPUSH
54806: CALL_OW 74
54810: ST_TO_ADDR
// if not ape then
54811: LD_VAR 0 6
54815: NOT
54816: IFFALSE 54820
// break ;
54818: GO 54930
// x := GetX ( ape ) ;
54820: LD_ADDR_VAR 0 4
54824: PUSH
54825: LD_VAR 0 6
54829: PPUSH
54830: CALL_OW 250
54834: ST_TO_ADDR
// y := GetY ( ape ) ;
54835: LD_ADDR_VAR 0 5
54839: PUSH
54840: LD_VAR 0 6
54844: PPUSH
54845: CALL_OW 251
54849: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54850: LD_VAR 0 4
54854: PPUSH
54855: LD_VAR 0 5
54859: PPUSH
54860: CALL_OW 488
54864: NOT
54865: PUSH
54866: LD_VAR 0 11
54870: PPUSH
54871: LD_VAR 0 4
54875: PPUSH
54876: LD_VAR 0 5
54880: PPUSH
54881: LD_INT 20
54883: PPUSH
54884: CALL 72056 0 4
54888: PUSH
54889: LD_INT 4
54891: ARRAY
54892: OR
54893: IFFALSE 54897
// break ;
54895: GO 54930
// if not HasTask ( j ) then
54897: LD_VAR 0 3
54901: PPUSH
54902: CALL_OW 314
54906: NOT
54907: IFFALSE 54928
// ComTameXY ( j , x , y ) ;
54909: LD_VAR 0 3
54913: PPUSH
54914: LD_VAR 0 4
54918: PPUSH
54919: LD_VAR 0 5
54923: PPUSH
54924: CALL_OW 131
// end ; end ;
54928: GO 54593
54930: POP
54931: POP
// end ;
54932: GO 54149
54934: POP
54935: POP
// end ;
54936: LD_VAR 0 1
54940: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54941: LD_INT 0
54943: PPUSH
54944: PPUSH
54945: PPUSH
54946: PPUSH
54947: PPUSH
54948: PPUSH
54949: PPUSH
54950: PPUSH
// if not mc_bases then
54951: LD_EXP 97
54955: NOT
54956: IFFALSE 54960
// exit ;
54958: GO 55586
// for i = 1 to mc_bases do
54960: LD_ADDR_VAR 0 2
54964: PUSH
54965: DOUBLE
54966: LD_INT 1
54968: DEC
54969: ST_TO_ADDR
54970: LD_EXP 97
54974: PUSH
54975: FOR_TO
54976: IFFALSE 55584
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54978: LD_EXP 126
54982: PUSH
54983: LD_VAR 0 2
54987: ARRAY
54988: NOT
54989: PUSH
54990: LD_EXP 126
54994: PUSH
54995: LD_VAR 0 2
54999: ARRAY
55000: PPUSH
55001: LD_INT 25
55003: PUSH
55004: LD_INT 12
55006: PUSH
55007: EMPTY
55008: LIST
55009: LIST
55010: PPUSH
55011: CALL_OW 72
55015: NOT
55016: OR
55017: IFFALSE 55021
// continue ;
55019: GO 54975
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
55021: LD_ADDR_VAR 0 5
55025: PUSH
55026: LD_EXP 126
55030: PUSH
55031: LD_VAR 0 2
55035: ARRAY
55036: PUSH
55037: LD_INT 1
55039: ARRAY
55040: PPUSH
55041: CALL_OW 255
55045: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
55046: LD_VAR 0 5
55050: PPUSH
55051: LD_INT 2
55053: PPUSH
55054: CALL_OW 325
55058: IFFALSE 55311
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55060: LD_ADDR_VAR 0 4
55064: PUSH
55065: LD_EXP 126
55069: PUSH
55070: LD_VAR 0 2
55074: ARRAY
55075: PPUSH
55076: LD_INT 25
55078: PUSH
55079: LD_INT 16
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: PPUSH
55086: CALL_OW 72
55090: ST_TO_ADDR
// if tmp < 6 then
55091: LD_VAR 0 4
55095: PUSH
55096: LD_INT 6
55098: LESS
55099: IFFALSE 55311
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55101: LD_ADDR_VAR 0 6
55105: PUSH
55106: LD_EXP 97
55110: PUSH
55111: LD_VAR 0 2
55115: ARRAY
55116: PPUSH
55117: LD_INT 2
55119: PUSH
55120: LD_INT 30
55122: PUSH
55123: LD_INT 0
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: PUSH
55130: LD_INT 30
55132: PUSH
55133: LD_INT 1
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: PPUSH
55145: CALL_OW 72
55149: ST_TO_ADDR
// if depot then
55150: LD_VAR 0 6
55154: IFFALSE 55311
// begin selected := 0 ;
55156: LD_ADDR_VAR 0 7
55160: PUSH
55161: LD_INT 0
55163: ST_TO_ADDR
// for j in depot do
55164: LD_ADDR_VAR 0 3
55168: PUSH
55169: LD_VAR 0 6
55173: PUSH
55174: FOR_IN
55175: IFFALSE 55206
// begin if UnitsInside ( j ) < 6 then
55177: LD_VAR 0 3
55181: PPUSH
55182: CALL_OW 313
55186: PUSH
55187: LD_INT 6
55189: LESS
55190: IFFALSE 55204
// begin selected := j ;
55192: LD_ADDR_VAR 0 7
55196: PUSH
55197: LD_VAR 0 3
55201: ST_TO_ADDR
// break ;
55202: GO 55206
// end ; end ;
55204: GO 55174
55206: POP
55207: POP
// if selected then
55208: LD_VAR 0 7
55212: IFFALSE 55311
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55214: LD_ADDR_VAR 0 3
55218: PUSH
55219: LD_EXP 126
55223: PUSH
55224: LD_VAR 0 2
55228: ARRAY
55229: PPUSH
55230: LD_INT 25
55232: PUSH
55233: LD_INT 12
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: PPUSH
55240: CALL_OW 72
55244: PUSH
55245: FOR_IN
55246: IFFALSE 55309
// if not HasTask ( j ) then
55248: LD_VAR 0 3
55252: PPUSH
55253: CALL_OW 314
55257: NOT
55258: IFFALSE 55307
// begin if not IsInUnit ( j ) then
55260: LD_VAR 0 3
55264: PPUSH
55265: CALL_OW 310
55269: NOT
55270: IFFALSE 55286
// ComEnterUnit ( j , selected ) ;
55272: LD_VAR 0 3
55276: PPUSH
55277: LD_VAR 0 7
55281: PPUSH
55282: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55286: LD_VAR 0 3
55290: PPUSH
55291: LD_INT 16
55293: PPUSH
55294: CALL_OW 183
// AddComExitBuilding ( j ) ;
55298: LD_VAR 0 3
55302: PPUSH
55303: CALL_OW 182
// end ;
55307: GO 55245
55309: POP
55310: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55311: LD_VAR 0 5
55315: PPUSH
55316: LD_INT 11
55318: PPUSH
55319: CALL_OW 325
55323: IFFALSE 55582
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55325: LD_ADDR_VAR 0 4
55329: PUSH
55330: LD_EXP 126
55334: PUSH
55335: LD_VAR 0 2
55339: ARRAY
55340: PPUSH
55341: LD_INT 25
55343: PUSH
55344: LD_INT 16
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: PPUSH
55351: CALL_OW 72
55355: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55356: LD_VAR 0 4
55360: PUSH
55361: LD_INT 6
55363: GREATEREQUAL
55364: PUSH
55365: LD_VAR 0 5
55369: PPUSH
55370: LD_INT 2
55372: PPUSH
55373: CALL_OW 325
55377: NOT
55378: OR
55379: IFFALSE 55582
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55381: LD_ADDR_VAR 0 8
55385: PUSH
55386: LD_EXP 97
55390: PUSH
55391: LD_VAR 0 2
55395: ARRAY
55396: PPUSH
55397: LD_INT 2
55399: PUSH
55400: LD_INT 30
55402: PUSH
55403: LD_INT 4
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PUSH
55410: LD_INT 30
55412: PUSH
55413: LD_INT 5
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: EMPTY
55421: LIST
55422: LIST
55423: LIST
55424: PPUSH
55425: CALL_OW 72
55429: ST_TO_ADDR
// if barracks then
55430: LD_VAR 0 8
55434: IFFALSE 55582
// begin selected := 0 ;
55436: LD_ADDR_VAR 0 7
55440: PUSH
55441: LD_INT 0
55443: ST_TO_ADDR
// for j in barracks do
55444: LD_ADDR_VAR 0 3
55448: PUSH
55449: LD_VAR 0 8
55453: PUSH
55454: FOR_IN
55455: IFFALSE 55486
// begin if UnitsInside ( j ) < 6 then
55457: LD_VAR 0 3
55461: PPUSH
55462: CALL_OW 313
55466: PUSH
55467: LD_INT 6
55469: LESS
55470: IFFALSE 55484
// begin selected := j ;
55472: LD_ADDR_VAR 0 7
55476: PUSH
55477: LD_VAR 0 3
55481: ST_TO_ADDR
// break ;
55482: GO 55486
// end ; end ;
55484: GO 55454
55486: POP
55487: POP
// if selected then
55488: LD_VAR 0 7
55492: IFFALSE 55582
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55494: LD_ADDR_VAR 0 3
55498: PUSH
55499: LD_EXP 126
55503: PUSH
55504: LD_VAR 0 2
55508: ARRAY
55509: PPUSH
55510: LD_INT 25
55512: PUSH
55513: LD_INT 12
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: PPUSH
55520: CALL_OW 72
55524: PUSH
55525: FOR_IN
55526: IFFALSE 55580
// if not IsInUnit ( j ) and not HasTask ( j ) then
55528: LD_VAR 0 3
55532: PPUSH
55533: CALL_OW 310
55537: NOT
55538: PUSH
55539: LD_VAR 0 3
55543: PPUSH
55544: CALL_OW 314
55548: NOT
55549: AND
55550: IFFALSE 55578
// begin ComEnterUnit ( j , selected ) ;
55552: LD_VAR 0 3
55556: PPUSH
55557: LD_VAR 0 7
55561: PPUSH
55562: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55566: LD_VAR 0 3
55570: PPUSH
55571: LD_INT 15
55573: PPUSH
55574: CALL_OW 183
// end ;
55578: GO 55525
55580: POP
55581: POP
// end ; end ; end ; end ; end ;
55582: GO 54975
55584: POP
55585: POP
// end ;
55586: LD_VAR 0 1
55590: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55591: LD_INT 0
55593: PPUSH
55594: PPUSH
55595: PPUSH
55596: PPUSH
// if not mc_bases then
55597: LD_EXP 97
55601: NOT
55602: IFFALSE 55606
// exit ;
55604: GO 55784
// for i = 1 to mc_bases do
55606: LD_ADDR_VAR 0 2
55610: PUSH
55611: DOUBLE
55612: LD_INT 1
55614: DEC
55615: ST_TO_ADDR
55616: LD_EXP 97
55620: PUSH
55621: FOR_TO
55622: IFFALSE 55782
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55624: LD_ADDR_VAR 0 4
55628: PUSH
55629: LD_EXP 97
55633: PUSH
55634: LD_VAR 0 2
55638: ARRAY
55639: PPUSH
55640: LD_INT 25
55642: PUSH
55643: LD_INT 9
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: PPUSH
55650: CALL_OW 72
55654: ST_TO_ADDR
// if not tmp then
55655: LD_VAR 0 4
55659: NOT
55660: IFFALSE 55664
// continue ;
55662: GO 55621
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55664: LD_EXP 123
55668: PUSH
55669: LD_VAR 0 2
55673: ARRAY
55674: PPUSH
55675: LD_INT 29
55677: PPUSH
55678: CALL_OW 325
55682: NOT
55683: PUSH
55684: LD_EXP 123
55688: PUSH
55689: LD_VAR 0 2
55693: ARRAY
55694: PPUSH
55695: LD_INT 28
55697: PPUSH
55698: CALL_OW 325
55702: NOT
55703: AND
55704: IFFALSE 55708
// continue ;
55706: GO 55621
// for j in tmp do
55708: LD_ADDR_VAR 0 3
55712: PUSH
55713: LD_VAR 0 4
55717: PUSH
55718: FOR_IN
55719: IFFALSE 55778
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55721: LD_VAR 0 3
55725: PUSH
55726: LD_EXP 100
55730: PUSH
55731: LD_VAR 0 2
55735: ARRAY
55736: PUSH
55737: LD_INT 1
55739: ARRAY
55740: IN
55741: NOT
55742: PUSH
55743: LD_VAR 0 3
55747: PUSH
55748: LD_EXP 100
55752: PUSH
55753: LD_VAR 0 2
55757: ARRAY
55758: PUSH
55759: LD_INT 2
55761: ARRAY
55762: IN
55763: NOT
55764: AND
55765: IFFALSE 55776
// ComSpaceTimeShoot ( j ) ;
55767: LD_VAR 0 3
55771: PPUSH
55772: CALL 66970 0 1
55776: GO 55718
55778: POP
55779: POP
// end ;
55780: GO 55621
55782: POP
55783: POP
// end ;
55784: LD_VAR 0 1
55788: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55789: LD_INT 0
55791: PPUSH
55792: PPUSH
55793: PPUSH
55794: PPUSH
55795: PPUSH
55796: PPUSH
55797: PPUSH
55798: PPUSH
55799: PPUSH
// if not mc_bases then
55800: LD_EXP 97
55804: NOT
55805: IFFALSE 55809
// exit ;
55807: GO 56431
// for i = 1 to mc_bases do
55809: LD_ADDR_VAR 0 2
55813: PUSH
55814: DOUBLE
55815: LD_INT 1
55817: DEC
55818: ST_TO_ADDR
55819: LD_EXP 97
55823: PUSH
55824: FOR_TO
55825: IFFALSE 56429
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55827: LD_EXP 132
55831: PUSH
55832: LD_VAR 0 2
55836: ARRAY
55837: NOT
55838: PUSH
55839: LD_INT 38
55841: PPUSH
55842: LD_EXP 123
55846: PUSH
55847: LD_VAR 0 2
55851: ARRAY
55852: PPUSH
55853: CALL_OW 321
55857: PUSH
55858: LD_INT 2
55860: NONEQUAL
55861: OR
55862: IFFALSE 55866
// continue ;
55864: GO 55824
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55866: LD_ADDR_VAR 0 8
55870: PUSH
55871: LD_EXP 97
55875: PUSH
55876: LD_VAR 0 2
55880: ARRAY
55881: PPUSH
55882: LD_INT 30
55884: PUSH
55885: LD_INT 34
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PPUSH
55892: CALL_OW 72
55896: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55897: LD_ADDR_VAR 0 9
55901: PUSH
55902: LD_EXP 97
55906: PUSH
55907: LD_VAR 0 2
55911: ARRAY
55912: PPUSH
55913: LD_INT 25
55915: PUSH
55916: LD_INT 4
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: PPUSH
55923: CALL_OW 72
55927: PPUSH
55928: LD_INT 0
55930: PPUSH
55931: CALL 101046 0 2
55935: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55936: LD_VAR 0 9
55940: NOT
55941: PUSH
55942: LD_VAR 0 8
55946: NOT
55947: OR
55948: PUSH
55949: LD_EXP 97
55953: PUSH
55954: LD_VAR 0 2
55958: ARRAY
55959: PPUSH
55960: LD_INT 124
55962: PPUSH
55963: CALL 101046 0 2
55967: OR
55968: IFFALSE 55972
// continue ;
55970: GO 55824
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55972: LD_EXP 133
55976: PUSH
55977: LD_VAR 0 2
55981: ARRAY
55982: PUSH
55983: LD_EXP 132
55987: PUSH
55988: LD_VAR 0 2
55992: ARRAY
55993: LESS
55994: PUSH
55995: LD_EXP 133
55999: PUSH
56000: LD_VAR 0 2
56004: ARRAY
56005: PUSH
56006: LD_VAR 0 8
56010: LESS
56011: AND
56012: IFFALSE 56427
// begin tmp := sci [ 1 ] ;
56014: LD_ADDR_VAR 0 7
56018: PUSH
56019: LD_VAR 0 9
56023: PUSH
56024: LD_INT 1
56026: ARRAY
56027: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
56028: LD_VAR 0 7
56032: PPUSH
56033: LD_INT 124
56035: PPUSH
56036: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
56040: LD_ADDR_VAR 0 3
56044: PUSH
56045: DOUBLE
56046: LD_EXP 132
56050: PUSH
56051: LD_VAR 0 2
56055: ARRAY
56056: INC
56057: ST_TO_ADDR
56058: LD_EXP 132
56062: PUSH
56063: LD_VAR 0 2
56067: ARRAY
56068: PUSH
56069: FOR_DOWNTO
56070: IFFALSE 56413
// begin if IsInUnit ( tmp ) then
56072: LD_VAR 0 7
56076: PPUSH
56077: CALL_OW 310
56081: IFFALSE 56092
// ComExitBuilding ( tmp ) ;
56083: LD_VAR 0 7
56087: PPUSH
56088: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
56092: LD_INT 35
56094: PPUSH
56095: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
56099: LD_VAR 0 7
56103: PPUSH
56104: CALL_OW 310
56108: NOT
56109: PUSH
56110: LD_VAR 0 7
56114: PPUSH
56115: CALL_OW 314
56119: NOT
56120: AND
56121: IFFALSE 56092
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
56123: LD_ADDR_VAR 0 6
56127: PUSH
56128: LD_VAR 0 7
56132: PPUSH
56133: CALL_OW 250
56137: PUSH
56138: LD_VAR 0 7
56142: PPUSH
56143: CALL_OW 251
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
56152: LD_INT 35
56154: PPUSH
56155: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
56159: LD_ADDR_VAR 0 4
56163: PUSH
56164: LD_EXP 132
56168: PUSH
56169: LD_VAR 0 2
56173: ARRAY
56174: PUSH
56175: LD_VAR 0 3
56179: ARRAY
56180: PUSH
56181: LD_INT 1
56183: ARRAY
56184: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56185: LD_ADDR_VAR 0 5
56189: PUSH
56190: LD_EXP 132
56194: PUSH
56195: LD_VAR 0 2
56199: ARRAY
56200: PUSH
56201: LD_VAR 0 3
56205: ARRAY
56206: PUSH
56207: LD_INT 2
56209: ARRAY
56210: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56211: LD_VAR 0 7
56215: PPUSH
56216: LD_INT 10
56218: PPUSH
56219: CALL 73757 0 2
56223: PUSH
56224: LD_INT 4
56226: ARRAY
56227: IFFALSE 56265
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56229: LD_VAR 0 7
56233: PPUSH
56234: LD_VAR 0 6
56238: PUSH
56239: LD_INT 1
56241: ARRAY
56242: PPUSH
56243: LD_VAR 0 6
56247: PUSH
56248: LD_INT 2
56250: ARRAY
56251: PPUSH
56252: CALL_OW 111
// wait ( 0 0$10 ) ;
56256: LD_INT 350
56258: PPUSH
56259: CALL_OW 67
// end else
56263: GO 56291
// begin ComMoveXY ( tmp , x , y ) ;
56265: LD_VAR 0 7
56269: PPUSH
56270: LD_VAR 0 4
56274: PPUSH
56275: LD_VAR 0 5
56279: PPUSH
56280: CALL_OW 111
// wait ( 0 0$3 ) ;
56284: LD_INT 105
56286: PPUSH
56287: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56291: LD_VAR 0 7
56295: PPUSH
56296: LD_VAR 0 4
56300: PPUSH
56301: LD_VAR 0 5
56305: PPUSH
56306: CALL_OW 307
56310: IFFALSE 56152
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56312: LD_VAR 0 7
56316: PPUSH
56317: LD_VAR 0 4
56321: PPUSH
56322: LD_VAR 0 5
56326: PPUSH
56327: LD_VAR 0 8
56331: PUSH
56332: LD_VAR 0 3
56336: ARRAY
56337: PPUSH
56338: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56342: LD_INT 35
56344: PPUSH
56345: CALL_OW 67
// until not HasTask ( tmp ) ;
56349: LD_VAR 0 7
56353: PPUSH
56354: CALL_OW 314
56358: NOT
56359: IFFALSE 56342
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56361: LD_ADDR_EXP 133
56365: PUSH
56366: LD_EXP 133
56370: PPUSH
56371: LD_VAR 0 2
56375: PUSH
56376: LD_EXP 133
56380: PUSH
56381: LD_VAR 0 2
56385: ARRAY
56386: PUSH
56387: LD_INT 1
56389: PLUS
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PPUSH
56395: LD_VAR 0 8
56399: PUSH
56400: LD_VAR 0 3
56404: ARRAY
56405: PPUSH
56406: CALL 71160 0 3
56410: ST_TO_ADDR
// end ;
56411: GO 56069
56413: POP
56414: POP
// MC_Reset ( i , 124 ) ;
56415: LD_VAR 0 2
56419: PPUSH
56420: LD_INT 124
56422: PPUSH
56423: CALL 39573 0 2
// end ; end ;
56427: GO 55824
56429: POP
56430: POP
// end ;
56431: LD_VAR 0 1
56435: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56436: LD_INT 0
56438: PPUSH
56439: PPUSH
56440: PPUSH
// if not mc_bases then
56441: LD_EXP 97
56445: NOT
56446: IFFALSE 56450
// exit ;
56448: GO 57056
// for i = 1 to mc_bases do
56450: LD_ADDR_VAR 0 2
56454: PUSH
56455: DOUBLE
56456: LD_INT 1
56458: DEC
56459: ST_TO_ADDR
56460: LD_EXP 97
56464: PUSH
56465: FOR_TO
56466: IFFALSE 57054
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56468: LD_ADDR_VAR 0 3
56472: PUSH
56473: LD_EXP 97
56477: PUSH
56478: LD_VAR 0 2
56482: ARRAY
56483: PPUSH
56484: LD_INT 25
56486: PUSH
56487: LD_INT 4
56489: PUSH
56490: EMPTY
56491: LIST
56492: LIST
56493: PPUSH
56494: CALL_OW 72
56498: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56499: LD_VAR 0 3
56503: NOT
56504: PUSH
56505: LD_EXP 134
56509: PUSH
56510: LD_VAR 0 2
56514: ARRAY
56515: NOT
56516: OR
56517: PUSH
56518: LD_EXP 97
56522: PUSH
56523: LD_VAR 0 2
56527: ARRAY
56528: PPUSH
56529: LD_INT 2
56531: PUSH
56532: LD_INT 30
56534: PUSH
56535: LD_INT 0
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: LD_INT 30
56544: PUSH
56545: LD_INT 1
56547: PUSH
56548: EMPTY
56549: LIST
56550: LIST
56551: PUSH
56552: EMPTY
56553: LIST
56554: LIST
56555: LIST
56556: PPUSH
56557: CALL_OW 72
56561: NOT
56562: OR
56563: IFFALSE 56613
// begin if mc_deposits_finder [ i ] then
56565: LD_EXP 135
56569: PUSH
56570: LD_VAR 0 2
56574: ARRAY
56575: IFFALSE 56611
// begin MC_Reset ( i , 125 ) ;
56577: LD_VAR 0 2
56581: PPUSH
56582: LD_INT 125
56584: PPUSH
56585: CALL 39573 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56589: LD_ADDR_EXP 135
56593: PUSH
56594: LD_EXP 135
56598: PPUSH
56599: LD_VAR 0 2
56603: PPUSH
56604: EMPTY
56605: PPUSH
56606: CALL_OW 1
56610: ST_TO_ADDR
// end ; continue ;
56611: GO 56465
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56613: LD_EXP 134
56617: PUSH
56618: LD_VAR 0 2
56622: ARRAY
56623: PUSH
56624: LD_INT 1
56626: ARRAY
56627: PUSH
56628: LD_INT 3
56630: ARRAY
56631: PUSH
56632: LD_INT 1
56634: EQUAL
56635: PUSH
56636: LD_INT 20
56638: PPUSH
56639: LD_EXP 123
56643: PUSH
56644: LD_VAR 0 2
56648: ARRAY
56649: PPUSH
56650: CALL_OW 321
56654: PUSH
56655: LD_INT 2
56657: NONEQUAL
56658: AND
56659: IFFALSE 56709
// begin if mc_deposits_finder [ i ] then
56661: LD_EXP 135
56665: PUSH
56666: LD_VAR 0 2
56670: ARRAY
56671: IFFALSE 56707
// begin MC_Reset ( i , 125 ) ;
56673: LD_VAR 0 2
56677: PPUSH
56678: LD_INT 125
56680: PPUSH
56681: CALL 39573 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56685: LD_ADDR_EXP 135
56689: PUSH
56690: LD_EXP 135
56694: PPUSH
56695: LD_VAR 0 2
56699: PPUSH
56700: EMPTY
56701: PPUSH
56702: CALL_OW 1
56706: ST_TO_ADDR
// end ; continue ;
56707: GO 56465
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56709: LD_EXP 134
56713: PUSH
56714: LD_VAR 0 2
56718: ARRAY
56719: PUSH
56720: LD_INT 1
56722: ARRAY
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PPUSH
56728: LD_EXP 134
56732: PUSH
56733: LD_VAR 0 2
56737: ARRAY
56738: PUSH
56739: LD_INT 1
56741: ARRAY
56742: PUSH
56743: LD_INT 2
56745: ARRAY
56746: PPUSH
56747: LD_EXP 123
56751: PUSH
56752: LD_VAR 0 2
56756: ARRAY
56757: PPUSH
56758: CALL_OW 440
56762: IFFALSE 56805
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56764: LD_ADDR_EXP 134
56768: PUSH
56769: LD_EXP 134
56773: PPUSH
56774: LD_VAR 0 2
56778: PPUSH
56779: LD_EXP 134
56783: PUSH
56784: LD_VAR 0 2
56788: ARRAY
56789: PPUSH
56790: LD_INT 1
56792: PPUSH
56793: CALL_OW 3
56797: PPUSH
56798: CALL_OW 1
56802: ST_TO_ADDR
56803: GO 57052
// begin if not mc_deposits_finder [ i ] then
56805: LD_EXP 135
56809: PUSH
56810: LD_VAR 0 2
56814: ARRAY
56815: NOT
56816: IFFALSE 56868
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56818: LD_ADDR_EXP 135
56822: PUSH
56823: LD_EXP 135
56827: PPUSH
56828: LD_VAR 0 2
56832: PPUSH
56833: LD_VAR 0 3
56837: PUSH
56838: LD_INT 1
56840: ARRAY
56841: PUSH
56842: EMPTY
56843: LIST
56844: PPUSH
56845: CALL_OW 1
56849: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56850: LD_VAR 0 3
56854: PUSH
56855: LD_INT 1
56857: ARRAY
56858: PPUSH
56859: LD_INT 125
56861: PPUSH
56862: CALL_OW 109
// end else
56866: GO 57052
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56868: LD_EXP 135
56872: PUSH
56873: LD_VAR 0 2
56877: ARRAY
56878: PUSH
56879: LD_INT 1
56881: ARRAY
56882: PPUSH
56883: CALL_OW 310
56887: IFFALSE 56910
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56889: LD_EXP 135
56893: PUSH
56894: LD_VAR 0 2
56898: ARRAY
56899: PUSH
56900: LD_INT 1
56902: ARRAY
56903: PPUSH
56904: CALL_OW 122
56908: GO 57052
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56910: LD_EXP 135
56914: PUSH
56915: LD_VAR 0 2
56919: ARRAY
56920: PUSH
56921: LD_INT 1
56923: ARRAY
56924: PPUSH
56925: CALL_OW 314
56929: NOT
56930: PUSH
56931: LD_EXP 135
56935: PUSH
56936: LD_VAR 0 2
56940: ARRAY
56941: PUSH
56942: LD_INT 1
56944: ARRAY
56945: PPUSH
56946: LD_EXP 134
56950: PUSH
56951: LD_VAR 0 2
56955: ARRAY
56956: PUSH
56957: LD_INT 1
56959: ARRAY
56960: PUSH
56961: LD_INT 1
56963: ARRAY
56964: PPUSH
56965: LD_EXP 134
56969: PUSH
56970: LD_VAR 0 2
56974: ARRAY
56975: PUSH
56976: LD_INT 1
56978: ARRAY
56979: PUSH
56980: LD_INT 2
56982: ARRAY
56983: PPUSH
56984: CALL_OW 297
56988: PUSH
56989: LD_INT 6
56991: GREATER
56992: AND
56993: IFFALSE 57052
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56995: LD_EXP 135
56999: PUSH
57000: LD_VAR 0 2
57004: ARRAY
57005: PUSH
57006: LD_INT 1
57008: ARRAY
57009: PPUSH
57010: LD_EXP 134
57014: PUSH
57015: LD_VAR 0 2
57019: ARRAY
57020: PUSH
57021: LD_INT 1
57023: ARRAY
57024: PUSH
57025: LD_INT 1
57027: ARRAY
57028: PPUSH
57029: LD_EXP 134
57033: PUSH
57034: LD_VAR 0 2
57038: ARRAY
57039: PUSH
57040: LD_INT 1
57042: ARRAY
57043: PUSH
57044: LD_INT 2
57046: ARRAY
57047: PPUSH
57048: CALL_OW 111
// end ; end ; end ;
57052: GO 56465
57054: POP
57055: POP
// end ;
57056: LD_VAR 0 1
57060: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
57061: LD_INT 0
57063: PPUSH
57064: PPUSH
57065: PPUSH
57066: PPUSH
57067: PPUSH
57068: PPUSH
57069: PPUSH
57070: PPUSH
57071: PPUSH
57072: PPUSH
57073: PPUSH
// if not mc_bases then
57074: LD_EXP 97
57078: NOT
57079: IFFALSE 57083
// exit ;
57081: GO 58023
// for i = 1 to mc_bases do
57083: LD_ADDR_VAR 0 2
57087: PUSH
57088: DOUBLE
57089: LD_INT 1
57091: DEC
57092: ST_TO_ADDR
57093: LD_EXP 97
57097: PUSH
57098: FOR_TO
57099: IFFALSE 58021
// begin if not mc_bases [ i ] or mc_scan [ i ] then
57101: LD_EXP 97
57105: PUSH
57106: LD_VAR 0 2
57110: ARRAY
57111: NOT
57112: PUSH
57113: LD_EXP 120
57117: PUSH
57118: LD_VAR 0 2
57122: ARRAY
57123: OR
57124: IFFALSE 57128
// continue ;
57126: GO 57098
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
57128: LD_ADDR_VAR 0 7
57132: PUSH
57133: LD_EXP 97
57137: PUSH
57138: LD_VAR 0 2
57142: ARRAY
57143: PUSH
57144: LD_INT 1
57146: ARRAY
57147: PPUSH
57148: CALL_OW 248
57152: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
57153: LD_VAR 0 7
57157: PUSH
57158: LD_INT 3
57160: EQUAL
57161: PUSH
57162: LD_EXP 116
57166: PUSH
57167: LD_VAR 0 2
57171: ARRAY
57172: PUSH
57173: LD_EXP 119
57177: PUSH
57178: LD_VAR 0 2
57182: ARRAY
57183: UNION
57184: PPUSH
57185: LD_INT 33
57187: PUSH
57188: LD_INT 2
57190: PUSH
57191: EMPTY
57192: LIST
57193: LIST
57194: PPUSH
57195: CALL_OW 72
57199: NOT
57200: OR
57201: IFFALSE 57205
// continue ;
57203: GO 57098
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57205: LD_ADDR_VAR 0 9
57209: PUSH
57210: LD_EXP 97
57214: PUSH
57215: LD_VAR 0 2
57219: ARRAY
57220: PPUSH
57221: LD_INT 30
57223: PUSH
57224: LD_INT 36
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: PPUSH
57231: CALL_OW 72
57235: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57236: LD_ADDR_VAR 0 10
57240: PUSH
57241: LD_EXP 116
57245: PUSH
57246: LD_VAR 0 2
57250: ARRAY
57251: PPUSH
57252: LD_INT 34
57254: PUSH
57255: LD_INT 31
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: PPUSH
57262: CALL_OW 72
57266: ST_TO_ADDR
// if not cts and not mcts then
57267: LD_VAR 0 9
57271: NOT
57272: PUSH
57273: LD_VAR 0 10
57277: NOT
57278: AND
57279: IFFALSE 57283
// continue ;
57281: GO 57098
// x := cts ;
57283: LD_ADDR_VAR 0 11
57287: PUSH
57288: LD_VAR 0 9
57292: ST_TO_ADDR
// if not x then
57293: LD_VAR 0 11
57297: NOT
57298: IFFALSE 57310
// x := mcts ;
57300: LD_ADDR_VAR 0 11
57304: PUSH
57305: LD_VAR 0 10
57309: ST_TO_ADDR
// if not x then
57310: LD_VAR 0 11
57314: NOT
57315: IFFALSE 57319
// continue ;
57317: GO 57098
// if mc_remote_driver [ i ] then
57319: LD_EXP 137
57323: PUSH
57324: LD_VAR 0 2
57328: ARRAY
57329: IFFALSE 57716
// for j in mc_remote_driver [ i ] do
57331: LD_ADDR_VAR 0 3
57335: PUSH
57336: LD_EXP 137
57340: PUSH
57341: LD_VAR 0 2
57345: ARRAY
57346: PUSH
57347: FOR_IN
57348: IFFALSE 57714
// begin if GetClass ( j ) <> 3 then
57350: LD_VAR 0 3
57354: PPUSH
57355: CALL_OW 257
57359: PUSH
57360: LD_INT 3
57362: NONEQUAL
57363: IFFALSE 57416
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57365: LD_ADDR_EXP 137
57369: PUSH
57370: LD_EXP 137
57374: PPUSH
57375: LD_VAR 0 2
57379: PPUSH
57380: LD_EXP 137
57384: PUSH
57385: LD_VAR 0 2
57389: ARRAY
57390: PUSH
57391: LD_VAR 0 3
57395: DIFF
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57402: LD_VAR 0 3
57406: PPUSH
57407: LD_INT 0
57409: PPUSH
57410: CALL_OW 109
// continue ;
57414: GO 57347
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57416: LD_EXP 116
57420: PUSH
57421: LD_VAR 0 2
57425: ARRAY
57426: PPUSH
57427: LD_INT 34
57429: PUSH
57430: LD_INT 31
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: LD_INT 58
57439: PUSH
57440: EMPTY
57441: LIST
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PPUSH
57447: CALL_OW 72
57451: PUSH
57452: LD_VAR 0 3
57456: PPUSH
57457: CALL 101081 0 1
57461: NOT
57462: AND
57463: IFFALSE 57534
// begin if IsInUnit ( j ) then
57465: LD_VAR 0 3
57469: PPUSH
57470: CALL_OW 310
57474: IFFALSE 57485
// ComExitBuilding ( j ) ;
57476: LD_VAR 0 3
57480: PPUSH
57481: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57485: LD_VAR 0 3
57489: PPUSH
57490: LD_EXP 116
57494: PUSH
57495: LD_VAR 0 2
57499: ARRAY
57500: PPUSH
57501: LD_INT 34
57503: PUSH
57504: LD_INT 31
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PUSH
57511: LD_INT 58
57513: PUSH
57514: EMPTY
57515: LIST
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: PPUSH
57521: CALL_OW 72
57525: PUSH
57526: LD_INT 1
57528: ARRAY
57529: PPUSH
57530: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57534: LD_VAR 0 3
57538: PPUSH
57539: CALL_OW 310
57543: NOT
57544: PUSH
57545: LD_VAR 0 3
57549: PPUSH
57550: CALL_OW 310
57554: PPUSH
57555: CALL_OW 266
57559: PUSH
57560: LD_INT 36
57562: NONEQUAL
57563: PUSH
57564: LD_VAR 0 3
57568: PPUSH
57569: CALL 101081 0 1
57573: NOT
57574: AND
57575: OR
57576: IFFALSE 57712
// begin if IsInUnit ( j ) then
57578: LD_VAR 0 3
57582: PPUSH
57583: CALL_OW 310
57587: IFFALSE 57598
// ComExitBuilding ( j ) ;
57589: LD_VAR 0 3
57593: PPUSH
57594: CALL_OW 122
// ct := 0 ;
57598: LD_ADDR_VAR 0 8
57602: PUSH
57603: LD_INT 0
57605: ST_TO_ADDR
// for k in x do
57606: LD_ADDR_VAR 0 4
57610: PUSH
57611: LD_VAR 0 11
57615: PUSH
57616: FOR_IN
57617: IFFALSE 57690
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57619: LD_VAR 0 4
57623: PPUSH
57624: CALL_OW 264
57628: PUSH
57629: LD_INT 31
57631: EQUAL
57632: PUSH
57633: LD_VAR 0 4
57637: PPUSH
57638: CALL_OW 311
57642: NOT
57643: AND
57644: PUSH
57645: LD_VAR 0 4
57649: PPUSH
57650: CALL_OW 266
57654: PUSH
57655: LD_INT 36
57657: EQUAL
57658: PUSH
57659: LD_VAR 0 4
57663: PPUSH
57664: CALL_OW 313
57668: PUSH
57669: LD_INT 3
57671: LESS
57672: AND
57673: OR
57674: IFFALSE 57688
// begin ct := k ;
57676: LD_ADDR_VAR 0 8
57680: PUSH
57681: LD_VAR 0 4
57685: ST_TO_ADDR
// break ;
57686: GO 57690
// end ;
57688: GO 57616
57690: POP
57691: POP
// if ct then
57692: LD_VAR 0 8
57696: IFFALSE 57712
// ComEnterUnit ( j , ct ) ;
57698: LD_VAR 0 3
57702: PPUSH
57703: LD_VAR 0 8
57707: PPUSH
57708: CALL_OW 120
// end ; end ;
57712: GO 57347
57714: POP
57715: POP
// places := 0 ;
57716: LD_ADDR_VAR 0 5
57720: PUSH
57721: LD_INT 0
57723: ST_TO_ADDR
// for j = 1 to x do
57724: LD_ADDR_VAR 0 3
57728: PUSH
57729: DOUBLE
57730: LD_INT 1
57732: DEC
57733: ST_TO_ADDR
57734: LD_VAR 0 11
57738: PUSH
57739: FOR_TO
57740: IFFALSE 57816
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57742: LD_VAR 0 11
57746: PUSH
57747: LD_VAR 0 3
57751: ARRAY
57752: PPUSH
57753: CALL_OW 264
57757: PUSH
57758: LD_INT 31
57760: EQUAL
57761: IFFALSE 57779
// places := places + 1 else
57763: LD_ADDR_VAR 0 5
57767: PUSH
57768: LD_VAR 0 5
57772: PUSH
57773: LD_INT 1
57775: PLUS
57776: ST_TO_ADDR
57777: GO 57814
// if GetBType ( x [ j ] ) = b_control_tower then
57779: LD_VAR 0 11
57783: PUSH
57784: LD_VAR 0 3
57788: ARRAY
57789: PPUSH
57790: CALL_OW 266
57794: PUSH
57795: LD_INT 36
57797: EQUAL
57798: IFFALSE 57814
// places := places + 3 ;
57800: LD_ADDR_VAR 0 5
57804: PUSH
57805: LD_VAR 0 5
57809: PUSH
57810: LD_INT 3
57812: PLUS
57813: ST_TO_ADDR
57814: GO 57739
57816: POP
57817: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57818: LD_VAR 0 5
57822: PUSH
57823: LD_INT 0
57825: EQUAL
57826: PUSH
57827: LD_VAR 0 5
57831: PUSH
57832: LD_EXP 137
57836: PUSH
57837: LD_VAR 0 2
57841: ARRAY
57842: LESSEQUAL
57843: OR
57844: IFFALSE 57848
// continue ;
57846: GO 57098
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57848: LD_ADDR_VAR 0 6
57852: PUSH
57853: LD_EXP 97
57857: PUSH
57858: LD_VAR 0 2
57862: ARRAY
57863: PPUSH
57864: LD_INT 25
57866: PUSH
57867: LD_INT 3
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PPUSH
57874: CALL_OW 72
57878: PUSH
57879: LD_EXP 137
57883: PUSH
57884: LD_VAR 0 2
57888: ARRAY
57889: DIFF
57890: PPUSH
57891: LD_INT 3
57893: PPUSH
57894: CALL 101981 0 2
57898: ST_TO_ADDR
// for j in tmp do
57899: LD_ADDR_VAR 0 3
57903: PUSH
57904: LD_VAR 0 6
57908: PUSH
57909: FOR_IN
57910: IFFALSE 57945
// if GetTag ( j ) > 0 then
57912: LD_VAR 0 3
57916: PPUSH
57917: CALL_OW 110
57921: PUSH
57922: LD_INT 0
57924: GREATER
57925: IFFALSE 57943
// tmp := tmp diff j ;
57927: LD_ADDR_VAR 0 6
57931: PUSH
57932: LD_VAR 0 6
57936: PUSH
57937: LD_VAR 0 3
57941: DIFF
57942: ST_TO_ADDR
57943: GO 57909
57945: POP
57946: POP
// if not tmp then
57947: LD_VAR 0 6
57951: NOT
57952: IFFALSE 57956
// continue ;
57954: GO 57098
// if places then
57956: LD_VAR 0 5
57960: IFFALSE 58019
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57962: LD_ADDR_EXP 137
57966: PUSH
57967: LD_EXP 137
57971: PPUSH
57972: LD_VAR 0 2
57976: PPUSH
57977: LD_EXP 137
57981: PUSH
57982: LD_VAR 0 2
57986: ARRAY
57987: PUSH
57988: LD_VAR 0 6
57992: PUSH
57993: LD_INT 1
57995: ARRAY
57996: UNION
57997: PPUSH
57998: CALL_OW 1
58002: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
58003: LD_VAR 0 6
58007: PUSH
58008: LD_INT 1
58010: ARRAY
58011: PPUSH
58012: LD_INT 126
58014: PPUSH
58015: CALL_OW 109
// end ; end ;
58019: GO 57098
58021: POP
58022: POP
// end ;
58023: LD_VAR 0 1
58027: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
58028: LD_INT 0
58030: PPUSH
58031: PPUSH
58032: PPUSH
58033: PPUSH
58034: PPUSH
58035: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
58036: LD_VAR 0 1
58040: NOT
58041: PUSH
58042: LD_VAR 0 2
58046: NOT
58047: OR
58048: PUSH
58049: LD_VAR 0 3
58053: NOT
58054: OR
58055: PUSH
58056: LD_VAR 0 4
58060: PUSH
58061: LD_INT 1
58063: PUSH
58064: LD_INT 2
58066: PUSH
58067: LD_INT 3
58069: PUSH
58070: LD_INT 4
58072: PUSH
58073: LD_INT 5
58075: PUSH
58076: LD_INT 8
58078: PUSH
58079: LD_INT 9
58081: PUSH
58082: LD_INT 15
58084: PUSH
58085: LD_INT 16
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: LIST
58092: LIST
58093: LIST
58094: LIST
58095: LIST
58096: LIST
58097: LIST
58098: IN
58099: NOT
58100: OR
58101: IFFALSE 58105
// exit ;
58103: GO 59005
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
58105: LD_ADDR_VAR 0 2
58109: PUSH
58110: LD_VAR 0 2
58114: PPUSH
58115: LD_INT 21
58117: PUSH
58118: LD_INT 3
58120: PUSH
58121: EMPTY
58122: LIST
58123: LIST
58124: PUSH
58125: LD_INT 24
58127: PUSH
58128: LD_INT 250
58130: PUSH
58131: EMPTY
58132: LIST
58133: LIST
58134: PUSH
58135: EMPTY
58136: LIST
58137: LIST
58138: PPUSH
58139: CALL_OW 72
58143: ST_TO_ADDR
// case class of 1 , 15 :
58144: LD_VAR 0 4
58148: PUSH
58149: LD_INT 1
58151: DOUBLE
58152: EQUAL
58153: IFTRUE 58163
58155: LD_INT 15
58157: DOUBLE
58158: EQUAL
58159: IFTRUE 58163
58161: GO 58248
58163: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58164: LD_ADDR_VAR 0 8
58168: PUSH
58169: LD_VAR 0 2
58173: PPUSH
58174: LD_INT 2
58176: PUSH
58177: LD_INT 30
58179: PUSH
58180: LD_INT 32
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: PUSH
58187: LD_INT 30
58189: PUSH
58190: LD_INT 31
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: PUSH
58197: EMPTY
58198: LIST
58199: LIST
58200: LIST
58201: PPUSH
58202: CALL_OW 72
58206: PUSH
58207: LD_VAR 0 2
58211: PPUSH
58212: LD_INT 2
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 4
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: LD_INT 5
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: LIST
58239: PPUSH
58240: CALL_OW 72
58244: ADD
58245: ST_TO_ADDR
58246: GO 58494
58248: LD_INT 2
58250: DOUBLE
58251: EQUAL
58252: IFTRUE 58262
58254: LD_INT 16
58256: DOUBLE
58257: EQUAL
58258: IFTRUE 58262
58260: GO 58308
58262: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58263: LD_ADDR_VAR 0 8
58267: PUSH
58268: LD_VAR 0 2
58272: PPUSH
58273: LD_INT 2
58275: PUSH
58276: LD_INT 30
58278: PUSH
58279: LD_INT 0
58281: PUSH
58282: EMPTY
58283: LIST
58284: LIST
58285: PUSH
58286: LD_INT 30
58288: PUSH
58289: LD_INT 1
58291: PUSH
58292: EMPTY
58293: LIST
58294: LIST
58295: PUSH
58296: EMPTY
58297: LIST
58298: LIST
58299: LIST
58300: PPUSH
58301: CALL_OW 72
58305: ST_TO_ADDR
58306: GO 58494
58308: LD_INT 3
58310: DOUBLE
58311: EQUAL
58312: IFTRUE 58316
58314: GO 58362
58316: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58317: LD_ADDR_VAR 0 8
58321: PUSH
58322: LD_VAR 0 2
58326: PPUSH
58327: LD_INT 2
58329: PUSH
58330: LD_INT 30
58332: PUSH
58333: LD_INT 2
58335: PUSH
58336: EMPTY
58337: LIST
58338: LIST
58339: PUSH
58340: LD_INT 30
58342: PUSH
58343: LD_INT 3
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: LIST
58354: PPUSH
58355: CALL_OW 72
58359: ST_TO_ADDR
58360: GO 58494
58362: LD_INT 4
58364: DOUBLE
58365: EQUAL
58366: IFTRUE 58370
58368: GO 58427
58370: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58371: LD_ADDR_VAR 0 8
58375: PUSH
58376: LD_VAR 0 2
58380: PPUSH
58381: LD_INT 2
58383: PUSH
58384: LD_INT 30
58386: PUSH
58387: LD_INT 6
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: PUSH
58394: LD_INT 30
58396: PUSH
58397: LD_INT 7
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 30
58406: PUSH
58407: LD_INT 8
58409: PUSH
58410: EMPTY
58411: LIST
58412: LIST
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: LIST
58418: LIST
58419: PPUSH
58420: CALL_OW 72
58424: ST_TO_ADDR
58425: GO 58494
58427: LD_INT 5
58429: DOUBLE
58430: EQUAL
58431: IFTRUE 58447
58433: LD_INT 8
58435: DOUBLE
58436: EQUAL
58437: IFTRUE 58447
58439: LD_INT 9
58441: DOUBLE
58442: EQUAL
58443: IFTRUE 58447
58445: GO 58493
58447: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58448: LD_ADDR_VAR 0 8
58452: PUSH
58453: LD_VAR 0 2
58457: PPUSH
58458: LD_INT 2
58460: PUSH
58461: LD_INT 30
58463: PUSH
58464: LD_INT 4
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: PUSH
58471: LD_INT 30
58473: PUSH
58474: LD_INT 5
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: LIST
58485: PPUSH
58486: CALL_OW 72
58490: ST_TO_ADDR
58491: GO 58494
58493: POP
// if not tmp then
58494: LD_VAR 0 8
58498: NOT
58499: IFFALSE 58503
// exit ;
58501: GO 59005
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58503: LD_VAR 0 4
58507: PUSH
58508: LD_INT 1
58510: PUSH
58511: LD_INT 15
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: IN
58518: PUSH
58519: LD_EXP 106
58523: PUSH
58524: LD_VAR 0 1
58528: ARRAY
58529: AND
58530: IFFALSE 58686
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58532: LD_ADDR_VAR 0 9
58536: PUSH
58537: LD_EXP 106
58541: PUSH
58542: LD_VAR 0 1
58546: ARRAY
58547: PUSH
58548: LD_INT 1
58550: ARRAY
58551: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58552: LD_VAR 0 9
58556: PUSH
58557: LD_EXP 107
58561: PUSH
58562: LD_VAR 0 1
58566: ARRAY
58567: IN
58568: NOT
58569: IFFALSE 58684
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58571: LD_ADDR_EXP 107
58575: PUSH
58576: LD_EXP 107
58580: PPUSH
58581: LD_VAR 0 1
58585: PUSH
58586: LD_EXP 107
58590: PUSH
58591: LD_VAR 0 1
58595: ARRAY
58596: PUSH
58597: LD_INT 1
58599: PLUS
58600: PUSH
58601: EMPTY
58602: LIST
58603: LIST
58604: PPUSH
58605: LD_VAR 0 9
58609: PPUSH
58610: CALL 71160 0 3
58614: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58615: LD_ADDR_EXP 106
58619: PUSH
58620: LD_EXP 106
58624: PPUSH
58625: LD_VAR 0 1
58629: PPUSH
58630: LD_EXP 106
58634: PUSH
58635: LD_VAR 0 1
58639: ARRAY
58640: PUSH
58641: LD_VAR 0 9
58645: DIFF
58646: PPUSH
58647: CALL_OW 1
58651: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58652: LD_VAR 0 3
58656: PPUSH
58657: LD_EXP 107
58661: PUSH
58662: LD_VAR 0 1
58666: ARRAY
58667: PUSH
58668: LD_EXP 107
58672: PUSH
58673: LD_VAR 0 1
58677: ARRAY
58678: ARRAY
58679: PPUSH
58680: CALL_OW 120
// end ; exit ;
58684: GO 59005
// end ; if tmp > 1 then
58686: LD_VAR 0 8
58690: PUSH
58691: LD_INT 1
58693: GREATER
58694: IFFALSE 58798
// for i = 2 to tmp do
58696: LD_ADDR_VAR 0 6
58700: PUSH
58701: DOUBLE
58702: LD_INT 2
58704: DEC
58705: ST_TO_ADDR
58706: LD_VAR 0 8
58710: PUSH
58711: FOR_TO
58712: IFFALSE 58796
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58714: LD_VAR 0 8
58718: PUSH
58719: LD_VAR 0 6
58723: ARRAY
58724: PPUSH
58725: CALL_OW 461
58729: PUSH
58730: LD_INT 6
58732: EQUAL
58733: IFFALSE 58794
// begin x := tmp [ i ] ;
58735: LD_ADDR_VAR 0 9
58739: PUSH
58740: LD_VAR 0 8
58744: PUSH
58745: LD_VAR 0 6
58749: ARRAY
58750: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58751: LD_ADDR_VAR 0 8
58755: PUSH
58756: LD_VAR 0 8
58760: PPUSH
58761: LD_VAR 0 6
58765: PPUSH
58766: CALL_OW 3
58770: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58771: LD_ADDR_VAR 0 8
58775: PUSH
58776: LD_VAR 0 8
58780: PPUSH
58781: LD_INT 1
58783: PPUSH
58784: LD_VAR 0 9
58788: PPUSH
58789: CALL_OW 2
58793: ST_TO_ADDR
// end ;
58794: GO 58711
58796: POP
58797: POP
// for i in tmp do
58798: LD_ADDR_VAR 0 6
58802: PUSH
58803: LD_VAR 0 8
58807: PUSH
58808: FOR_IN
58809: IFFALSE 58878
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58811: LD_VAR 0 6
58815: PPUSH
58816: CALL_OW 313
58820: PUSH
58821: LD_INT 6
58823: LESS
58824: PUSH
58825: LD_VAR 0 6
58829: PPUSH
58830: CALL_OW 266
58834: PUSH
58835: LD_INT 31
58837: PUSH
58838: LD_INT 32
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: IN
58845: NOT
58846: AND
58847: PUSH
58848: LD_VAR 0 6
58852: PPUSH
58853: CALL_OW 313
58857: PUSH
58858: LD_INT 0
58860: EQUAL
58861: OR
58862: IFFALSE 58876
// begin j := i ;
58864: LD_ADDR_VAR 0 7
58868: PUSH
58869: LD_VAR 0 6
58873: ST_TO_ADDR
// break ;
58874: GO 58878
// end ; end ;
58876: GO 58808
58878: POP
58879: POP
// if j then
58880: LD_VAR 0 7
58884: IFFALSE 58902
// ComEnterUnit ( unit , j ) else
58886: LD_VAR 0 3
58890: PPUSH
58891: LD_VAR 0 7
58895: PPUSH
58896: CALL_OW 120
58900: GO 59005
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58902: LD_ADDR_VAR 0 10
58906: PUSH
58907: LD_VAR 0 2
58911: PPUSH
58912: LD_INT 2
58914: PUSH
58915: LD_INT 30
58917: PUSH
58918: LD_INT 0
58920: PUSH
58921: EMPTY
58922: LIST
58923: LIST
58924: PUSH
58925: LD_INT 30
58927: PUSH
58928: LD_INT 1
58930: PUSH
58931: EMPTY
58932: LIST
58933: LIST
58934: PUSH
58935: EMPTY
58936: LIST
58937: LIST
58938: LIST
58939: PPUSH
58940: CALL_OW 72
58944: ST_TO_ADDR
// if depot then
58945: LD_VAR 0 10
58949: IFFALSE 59005
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58951: LD_ADDR_VAR 0 10
58955: PUSH
58956: LD_VAR 0 10
58960: PPUSH
58961: LD_VAR 0 3
58965: PPUSH
58966: CALL_OW 74
58970: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58971: LD_VAR 0 3
58975: PPUSH
58976: LD_VAR 0 10
58980: PPUSH
58981: CALL_OW 296
58985: PUSH
58986: LD_INT 10
58988: GREATER
58989: IFFALSE 59005
// ComStandNearbyBuilding ( unit , depot ) ;
58991: LD_VAR 0 3
58995: PPUSH
58996: LD_VAR 0 10
59000: PPUSH
59001: CALL 67587 0 2
// end ; end ; end ;
59005: LD_VAR 0 5
59009: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
59010: LD_INT 0
59012: PPUSH
59013: PPUSH
59014: PPUSH
59015: PPUSH
// if not mc_bases then
59016: LD_EXP 97
59020: NOT
59021: IFFALSE 59025
// exit ;
59023: GO 59264
// for i = 1 to mc_bases do
59025: LD_ADDR_VAR 0 2
59029: PUSH
59030: DOUBLE
59031: LD_INT 1
59033: DEC
59034: ST_TO_ADDR
59035: LD_EXP 97
59039: PUSH
59040: FOR_TO
59041: IFFALSE 59262
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
59043: LD_ADDR_VAR 0 4
59047: PUSH
59048: LD_EXP 97
59052: PUSH
59053: LD_VAR 0 2
59057: ARRAY
59058: PPUSH
59059: LD_INT 21
59061: PUSH
59062: LD_INT 1
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: PPUSH
59069: CALL_OW 72
59073: PUSH
59074: LD_EXP 126
59078: PUSH
59079: LD_VAR 0 2
59083: ARRAY
59084: UNION
59085: ST_TO_ADDR
// if not tmp then
59086: LD_VAR 0 4
59090: NOT
59091: IFFALSE 59095
// continue ;
59093: GO 59040
// for j in tmp do
59095: LD_ADDR_VAR 0 3
59099: PUSH
59100: LD_VAR 0 4
59104: PUSH
59105: FOR_IN
59106: IFFALSE 59258
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
59108: LD_VAR 0 3
59112: PPUSH
59113: CALL_OW 110
59117: NOT
59118: PUSH
59119: LD_VAR 0 3
59123: PPUSH
59124: CALL_OW 314
59128: NOT
59129: AND
59130: PUSH
59131: LD_VAR 0 3
59135: PPUSH
59136: CALL_OW 311
59140: NOT
59141: AND
59142: PUSH
59143: LD_VAR 0 3
59147: PPUSH
59148: CALL_OW 310
59152: NOT
59153: AND
59154: PUSH
59155: LD_VAR 0 3
59159: PUSH
59160: LD_EXP 100
59164: PUSH
59165: LD_VAR 0 2
59169: ARRAY
59170: PUSH
59171: LD_INT 1
59173: ARRAY
59174: IN
59175: NOT
59176: AND
59177: PUSH
59178: LD_VAR 0 3
59182: PUSH
59183: LD_EXP 100
59187: PUSH
59188: LD_VAR 0 2
59192: ARRAY
59193: PUSH
59194: LD_INT 2
59196: ARRAY
59197: IN
59198: NOT
59199: AND
59200: PUSH
59201: LD_VAR 0 3
59205: PUSH
59206: LD_EXP 109
59210: PUSH
59211: LD_VAR 0 2
59215: ARRAY
59216: IN
59217: NOT
59218: AND
59219: IFFALSE 59256
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59221: LD_VAR 0 2
59225: PPUSH
59226: LD_EXP 97
59230: PUSH
59231: LD_VAR 0 2
59235: ARRAY
59236: PPUSH
59237: LD_VAR 0 3
59241: PPUSH
59242: LD_VAR 0 3
59246: PPUSH
59247: CALL_OW 257
59251: PPUSH
59252: CALL 58028 0 4
// end ;
59256: GO 59105
59258: POP
59259: POP
// end ;
59260: GO 59040
59262: POP
59263: POP
// end ;
59264: LD_VAR 0 1
59268: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59269: LD_INT 0
59271: PPUSH
59272: PPUSH
59273: PPUSH
59274: PPUSH
59275: PPUSH
59276: PPUSH
// if not mc_bases [ base ] then
59277: LD_EXP 97
59281: PUSH
59282: LD_VAR 0 1
59286: ARRAY
59287: NOT
59288: IFFALSE 59292
// exit ;
59290: GO 59474
// tmp := [ ] ;
59292: LD_ADDR_VAR 0 6
59296: PUSH
59297: EMPTY
59298: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59299: LD_ADDR_VAR 0 7
59303: PUSH
59304: LD_VAR 0 3
59308: PPUSH
59309: LD_INT 0
59311: PPUSH
59312: CALL_OW 517
59316: ST_TO_ADDR
// if not list then
59317: LD_VAR 0 7
59321: NOT
59322: IFFALSE 59326
// exit ;
59324: GO 59474
// for i = 1 to amount do
59326: LD_ADDR_VAR 0 5
59330: PUSH
59331: DOUBLE
59332: LD_INT 1
59334: DEC
59335: ST_TO_ADDR
59336: LD_VAR 0 2
59340: PUSH
59341: FOR_TO
59342: IFFALSE 59422
// begin x := rand ( 1 , list [ 1 ] ) ;
59344: LD_ADDR_VAR 0 8
59348: PUSH
59349: LD_INT 1
59351: PPUSH
59352: LD_VAR 0 7
59356: PUSH
59357: LD_INT 1
59359: ARRAY
59360: PPUSH
59361: CALL_OW 12
59365: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59366: LD_ADDR_VAR 0 6
59370: PUSH
59371: LD_VAR 0 6
59375: PPUSH
59376: LD_VAR 0 5
59380: PPUSH
59381: LD_VAR 0 7
59385: PUSH
59386: LD_INT 1
59388: ARRAY
59389: PUSH
59390: LD_VAR 0 8
59394: ARRAY
59395: PUSH
59396: LD_VAR 0 7
59400: PUSH
59401: LD_INT 2
59403: ARRAY
59404: PUSH
59405: LD_VAR 0 8
59409: ARRAY
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: PPUSH
59415: CALL_OW 1
59419: ST_TO_ADDR
// end ;
59420: GO 59341
59422: POP
59423: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59424: LD_ADDR_EXP 110
59428: PUSH
59429: LD_EXP 110
59433: PPUSH
59434: LD_VAR 0 1
59438: PPUSH
59439: LD_VAR 0 6
59443: PPUSH
59444: CALL_OW 1
59448: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59449: LD_ADDR_EXP 112
59453: PUSH
59454: LD_EXP 112
59458: PPUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_VAR 0 3
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// end ;
59474: LD_VAR 0 4
59478: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59479: LD_INT 0
59481: PPUSH
// if not mc_bases [ base ] then
59482: LD_EXP 97
59486: PUSH
59487: LD_VAR 0 1
59491: ARRAY
59492: NOT
59493: IFFALSE 59497
// exit ;
59495: GO 59522
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59497: LD_ADDR_EXP 102
59501: PUSH
59502: LD_EXP 102
59506: PPUSH
59507: LD_VAR 0 1
59511: PPUSH
59512: LD_VAR 0 2
59516: PPUSH
59517: CALL_OW 1
59521: ST_TO_ADDR
// end ;
59522: LD_VAR 0 3
59526: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59527: LD_INT 0
59529: PPUSH
// if not mc_bases [ base ] then
59530: LD_EXP 97
59534: PUSH
59535: LD_VAR 0 1
59539: ARRAY
59540: NOT
59541: IFFALSE 59545
// exit ;
59543: GO 59582
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59545: LD_ADDR_EXP 102
59549: PUSH
59550: LD_EXP 102
59554: PPUSH
59555: LD_VAR 0 1
59559: PPUSH
59560: LD_EXP 102
59564: PUSH
59565: LD_VAR 0 1
59569: ARRAY
59570: PUSH
59571: LD_VAR 0 2
59575: UNION
59576: PPUSH
59577: CALL_OW 1
59581: ST_TO_ADDR
// end ;
59582: LD_VAR 0 3
59586: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59587: LD_INT 0
59589: PPUSH
// if not mc_bases [ base ] then
59590: LD_EXP 97
59594: PUSH
59595: LD_VAR 0 1
59599: ARRAY
59600: NOT
59601: IFFALSE 59605
// exit ;
59603: GO 59630
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59605: LD_ADDR_EXP 118
59609: PUSH
59610: LD_EXP 118
59614: PPUSH
59615: LD_VAR 0 1
59619: PPUSH
59620: LD_VAR 0 2
59624: PPUSH
59625: CALL_OW 1
59629: ST_TO_ADDR
// end ;
59630: LD_VAR 0 3
59634: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59635: LD_INT 0
59637: PPUSH
// if not mc_bases [ base ] then
59638: LD_EXP 97
59642: PUSH
59643: LD_VAR 0 1
59647: ARRAY
59648: NOT
59649: IFFALSE 59653
// exit ;
59651: GO 59690
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59653: LD_ADDR_EXP 118
59657: PUSH
59658: LD_EXP 118
59662: PPUSH
59663: LD_VAR 0 1
59667: PPUSH
59668: LD_EXP 118
59672: PUSH
59673: LD_VAR 0 1
59677: ARRAY
59678: PUSH
59679: LD_VAR 0 2
59683: ADD
59684: PPUSH
59685: CALL_OW 1
59689: ST_TO_ADDR
// end ;
59690: LD_VAR 0 3
59694: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59695: LD_INT 0
59697: PPUSH
// if not mc_bases [ base ] then
59698: LD_EXP 97
59702: PUSH
59703: LD_VAR 0 1
59707: ARRAY
59708: NOT
59709: IFFALSE 59713
// exit ;
59711: GO 59767
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59713: LD_ADDR_EXP 119
59717: PUSH
59718: LD_EXP 119
59722: PPUSH
59723: LD_VAR 0 1
59727: PPUSH
59728: LD_VAR 0 2
59732: PPUSH
59733: CALL_OW 1
59737: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59738: LD_ADDR_EXP 108
59742: PUSH
59743: LD_EXP 108
59747: PPUSH
59748: LD_VAR 0 1
59752: PPUSH
59753: LD_VAR 0 2
59757: PUSH
59758: LD_INT 0
59760: PLUS
59761: PPUSH
59762: CALL_OW 1
59766: ST_TO_ADDR
// end ;
59767: LD_VAR 0 3
59771: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59772: LD_INT 0
59774: PPUSH
// if not mc_bases [ base ] then
59775: LD_EXP 97
59779: PUSH
59780: LD_VAR 0 1
59784: ARRAY
59785: NOT
59786: IFFALSE 59790
// exit ;
59788: GO 59815
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59790: LD_ADDR_EXP 108
59794: PUSH
59795: LD_EXP 108
59799: PPUSH
59800: LD_VAR 0 1
59804: PPUSH
59805: LD_VAR 0 2
59809: PPUSH
59810: CALL_OW 1
59814: ST_TO_ADDR
// end ;
59815: LD_VAR 0 3
59819: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59820: LD_INT 0
59822: PPUSH
59823: PPUSH
59824: PPUSH
59825: PPUSH
// if not mc_bases [ base ] then
59826: LD_EXP 97
59830: PUSH
59831: LD_VAR 0 1
59835: ARRAY
59836: NOT
59837: IFFALSE 59841
// exit ;
59839: GO 59906
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59841: LD_ADDR_EXP 117
59845: PUSH
59846: LD_EXP 117
59850: PPUSH
59851: LD_VAR 0 1
59855: PUSH
59856: LD_EXP 117
59860: PUSH
59861: LD_VAR 0 1
59865: ARRAY
59866: PUSH
59867: LD_INT 1
59869: PLUS
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PPUSH
59875: LD_VAR 0 1
59879: PUSH
59880: LD_VAR 0 2
59884: PUSH
59885: LD_VAR 0 3
59889: PUSH
59890: LD_VAR 0 4
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: LIST
59899: LIST
59900: PPUSH
59901: CALL 71160 0 3
59905: ST_TO_ADDR
// end ;
59906: LD_VAR 0 5
59910: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59911: LD_INT 0
59913: PPUSH
// if not mc_bases [ base ] then
59914: LD_EXP 97
59918: PUSH
59919: LD_VAR 0 1
59923: ARRAY
59924: NOT
59925: IFFALSE 59929
// exit ;
59927: GO 59954
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59929: LD_ADDR_EXP 134
59933: PUSH
59934: LD_EXP 134
59938: PPUSH
59939: LD_VAR 0 1
59943: PPUSH
59944: LD_VAR 0 2
59948: PPUSH
59949: CALL_OW 1
59953: ST_TO_ADDR
// end ;
59954: LD_VAR 0 3
59958: RET
// export function MC_GetMinesField ( base ) ; begin
59959: LD_INT 0
59961: PPUSH
// result := mc_mines [ base ] ;
59962: LD_ADDR_VAR 0 2
59966: PUSH
59967: LD_EXP 110
59971: PUSH
59972: LD_VAR 0 1
59976: ARRAY
59977: ST_TO_ADDR
// end ;
59978: LD_VAR 0 2
59982: RET
// export function MC_GetProduceList ( base ) ; begin
59983: LD_INT 0
59985: PPUSH
// result := mc_produce [ base ] ;
59986: LD_ADDR_VAR 0 2
59990: PUSH
59991: LD_EXP 118
59995: PUSH
59996: LD_VAR 0 1
60000: ARRAY
60001: ST_TO_ADDR
// end ;
60002: LD_VAR 0 2
60006: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
60007: LD_INT 0
60009: PPUSH
60010: PPUSH
// if not mc_bases then
60011: LD_EXP 97
60015: NOT
60016: IFFALSE 60020
// exit ;
60018: GO 60085
// if mc_bases [ base ] then
60020: LD_EXP 97
60024: PUSH
60025: LD_VAR 0 1
60029: ARRAY
60030: IFFALSE 60085
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60032: LD_ADDR_VAR 0 3
60036: PUSH
60037: LD_EXP 97
60041: PUSH
60042: LD_VAR 0 1
60046: ARRAY
60047: PPUSH
60048: LD_INT 30
60050: PUSH
60051: LD_VAR 0 2
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PPUSH
60060: CALL_OW 72
60064: ST_TO_ADDR
// if result then
60065: LD_VAR 0 3
60069: IFFALSE 60085
// result := result [ 1 ] ;
60071: LD_ADDR_VAR 0 3
60075: PUSH
60076: LD_VAR 0 3
60080: PUSH
60081: LD_INT 1
60083: ARRAY
60084: ST_TO_ADDR
// end ; end ;
60085: LD_VAR 0 3
60089: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
60090: LD_INT 0
60092: PPUSH
60093: PPUSH
// if not mc_bases then
60094: LD_EXP 97
60098: NOT
60099: IFFALSE 60103
// exit ;
60101: GO 60148
// if mc_bases [ base ] then
60103: LD_EXP 97
60107: PUSH
60108: LD_VAR 0 1
60112: ARRAY
60113: IFFALSE 60148
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60115: LD_ADDR_VAR 0 3
60119: PUSH
60120: LD_EXP 97
60124: PUSH
60125: LD_VAR 0 1
60129: ARRAY
60130: PPUSH
60131: LD_INT 30
60133: PUSH
60134: LD_VAR 0 2
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: PPUSH
60143: CALL_OW 72
60147: ST_TO_ADDR
// end ;
60148: LD_VAR 0 3
60152: RET
// export function MC_SetTame ( base , area ) ; begin
60153: LD_INT 0
60155: PPUSH
// if not mc_bases or not base then
60156: LD_EXP 97
60160: NOT
60161: PUSH
60162: LD_VAR 0 1
60166: NOT
60167: OR
60168: IFFALSE 60172
// exit ;
60170: GO 60197
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60172: LD_ADDR_EXP 125
60176: PUSH
60177: LD_EXP 125
60181: PPUSH
60182: LD_VAR 0 1
60186: PPUSH
60187: LD_VAR 0 2
60191: PPUSH
60192: CALL_OW 1
60196: ST_TO_ADDR
// end ;
60197: LD_VAR 0 3
60201: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60202: LD_INT 0
60204: PPUSH
60205: PPUSH
// if not mc_bases or not base then
60206: LD_EXP 97
60210: NOT
60211: PUSH
60212: LD_VAR 0 1
60216: NOT
60217: OR
60218: IFFALSE 60222
// exit ;
60220: GO 60324
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60222: LD_ADDR_VAR 0 4
60226: PUSH
60227: LD_EXP 97
60231: PUSH
60232: LD_VAR 0 1
60236: ARRAY
60237: PPUSH
60238: LD_INT 30
60240: PUSH
60241: LD_VAR 0 2
60245: PUSH
60246: EMPTY
60247: LIST
60248: LIST
60249: PPUSH
60250: CALL_OW 72
60254: ST_TO_ADDR
// if not tmp then
60255: LD_VAR 0 4
60259: NOT
60260: IFFALSE 60264
// exit ;
60262: GO 60324
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60264: LD_ADDR_EXP 129
60268: PUSH
60269: LD_EXP 129
60273: PPUSH
60274: LD_VAR 0 1
60278: PPUSH
60279: LD_EXP 129
60283: PUSH
60284: LD_VAR 0 1
60288: ARRAY
60289: PPUSH
60290: LD_EXP 129
60294: PUSH
60295: LD_VAR 0 1
60299: ARRAY
60300: PUSH
60301: LD_INT 1
60303: PLUS
60304: PPUSH
60305: LD_VAR 0 4
60309: PUSH
60310: LD_INT 1
60312: ARRAY
60313: PPUSH
60314: CALL_OW 2
60318: PPUSH
60319: CALL_OW 1
60323: ST_TO_ADDR
// end ;
60324: LD_VAR 0 3
60328: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60329: LD_INT 0
60331: PPUSH
60332: PPUSH
// if not mc_bases or not base or not kinds then
60333: LD_EXP 97
60337: NOT
60338: PUSH
60339: LD_VAR 0 1
60343: NOT
60344: OR
60345: PUSH
60346: LD_VAR 0 2
60350: NOT
60351: OR
60352: IFFALSE 60356
// exit ;
60354: GO 60417
// for i in kinds do
60356: LD_ADDR_VAR 0 4
60360: PUSH
60361: LD_VAR 0 2
60365: PUSH
60366: FOR_IN
60367: IFFALSE 60415
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60369: LD_ADDR_EXP 131
60373: PUSH
60374: LD_EXP 131
60378: PPUSH
60379: LD_VAR 0 1
60383: PUSH
60384: LD_EXP 131
60388: PUSH
60389: LD_VAR 0 1
60393: ARRAY
60394: PUSH
60395: LD_INT 1
60397: PLUS
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: PPUSH
60403: LD_VAR 0 4
60407: PPUSH
60408: CALL 71160 0 3
60412: ST_TO_ADDR
60413: GO 60366
60415: POP
60416: POP
// end ;
60417: LD_VAR 0 3
60421: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60422: LD_INT 0
60424: PPUSH
// if not mc_bases or not base or not areas then
60425: LD_EXP 97
60429: NOT
60430: PUSH
60431: LD_VAR 0 1
60435: NOT
60436: OR
60437: PUSH
60438: LD_VAR 0 2
60442: NOT
60443: OR
60444: IFFALSE 60448
// exit ;
60446: GO 60473
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60448: LD_ADDR_EXP 115
60452: PUSH
60453: LD_EXP 115
60457: PPUSH
60458: LD_VAR 0 1
60462: PPUSH
60463: LD_VAR 0 2
60467: PPUSH
60468: CALL_OW 1
60472: ST_TO_ADDR
// end ;
60473: LD_VAR 0 3
60477: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60478: LD_INT 0
60480: PPUSH
// if not mc_bases or not base or not teleports_exit then
60481: LD_EXP 97
60485: NOT
60486: PUSH
60487: LD_VAR 0 1
60491: NOT
60492: OR
60493: PUSH
60494: LD_VAR 0 2
60498: NOT
60499: OR
60500: IFFALSE 60504
// exit ;
60502: GO 60529
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60504: LD_ADDR_EXP 132
60508: PUSH
60509: LD_EXP 132
60513: PPUSH
60514: LD_VAR 0 1
60518: PPUSH
60519: LD_VAR 0 2
60523: PPUSH
60524: CALL_OW 1
60528: ST_TO_ADDR
// end ;
60529: LD_VAR 0 3
60533: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
60538: PPUSH
// if not mc_bases or not base or not ext_list then
60539: LD_EXP 97
60543: NOT
60544: PUSH
60545: LD_VAR 0 1
60549: NOT
60550: OR
60551: PUSH
60552: LD_VAR 0 5
60556: NOT
60557: OR
60558: IFFALSE 60562
// exit ;
60560: GO 60735
// tmp := GetFacExtXYD ( x , y , d ) ;
60562: LD_ADDR_VAR 0 8
60566: PUSH
60567: LD_VAR 0 2
60571: PPUSH
60572: LD_VAR 0 3
60576: PPUSH
60577: LD_VAR 0 4
60581: PPUSH
60582: CALL 101111 0 3
60586: ST_TO_ADDR
// if not tmp then
60587: LD_VAR 0 8
60591: NOT
60592: IFFALSE 60596
// exit ;
60594: GO 60735
// for i in tmp do
60596: LD_ADDR_VAR 0 7
60600: PUSH
60601: LD_VAR 0 8
60605: PUSH
60606: FOR_IN
60607: IFFALSE 60733
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60609: LD_ADDR_EXP 102
60613: PUSH
60614: LD_EXP 102
60618: PPUSH
60619: LD_VAR 0 1
60623: PPUSH
60624: LD_EXP 102
60628: PUSH
60629: LD_VAR 0 1
60633: ARRAY
60634: PPUSH
60635: LD_EXP 102
60639: PUSH
60640: LD_VAR 0 1
60644: ARRAY
60645: PUSH
60646: LD_INT 1
60648: PLUS
60649: PPUSH
60650: LD_VAR 0 5
60654: PUSH
60655: LD_INT 1
60657: ARRAY
60658: PUSH
60659: LD_VAR 0 7
60663: PUSH
60664: LD_INT 1
60666: ARRAY
60667: PUSH
60668: LD_VAR 0 7
60672: PUSH
60673: LD_INT 2
60675: ARRAY
60676: PUSH
60677: LD_VAR 0 7
60681: PUSH
60682: LD_INT 3
60684: ARRAY
60685: PUSH
60686: EMPTY
60687: LIST
60688: LIST
60689: LIST
60690: LIST
60691: PPUSH
60692: CALL_OW 2
60696: PPUSH
60697: CALL_OW 1
60701: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60702: LD_ADDR_VAR 0 5
60706: PUSH
60707: LD_VAR 0 5
60711: PPUSH
60712: LD_INT 1
60714: PPUSH
60715: CALL_OW 3
60719: ST_TO_ADDR
// if not ext_list then
60720: LD_VAR 0 5
60724: NOT
60725: IFFALSE 60731
// exit ;
60727: POP
60728: POP
60729: GO 60735
// end ;
60731: GO 60606
60733: POP
60734: POP
// end ;
60735: LD_VAR 0 6
60739: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60740: LD_INT 0
60742: PPUSH
// if not mc_bases or not base or not weapon_list then
60743: LD_EXP 97
60747: NOT
60748: PUSH
60749: LD_VAR 0 1
60753: NOT
60754: OR
60755: PUSH
60756: LD_VAR 0 2
60760: NOT
60761: OR
60762: IFFALSE 60766
// exit ;
60764: GO 60791
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60766: LD_ADDR_EXP 136
60770: PUSH
60771: LD_EXP 136
60775: PPUSH
60776: LD_VAR 0 1
60780: PPUSH
60781: LD_VAR 0 2
60785: PPUSH
60786: CALL_OW 1
60790: ST_TO_ADDR
// end ;
60791: LD_VAR 0 3
60795: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60796: LD_INT 0
60798: PPUSH
// if not mc_bases or not base or not tech_list then
60799: LD_EXP 97
60803: NOT
60804: PUSH
60805: LD_VAR 0 1
60809: NOT
60810: OR
60811: PUSH
60812: LD_VAR 0 2
60816: NOT
60817: OR
60818: IFFALSE 60822
// exit ;
60820: GO 60847
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60822: LD_ADDR_EXP 124
60826: PUSH
60827: LD_EXP 124
60831: PPUSH
60832: LD_VAR 0 1
60836: PPUSH
60837: LD_VAR 0 2
60841: PPUSH
60842: CALL_OW 1
60846: ST_TO_ADDR
// end ;
60847: LD_VAR 0 3
60851: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60852: LD_INT 0
60854: PPUSH
// if not mc_bases or not parking_area or not base then
60855: LD_EXP 97
60859: NOT
60860: PUSH
60861: LD_VAR 0 2
60865: NOT
60866: OR
60867: PUSH
60868: LD_VAR 0 1
60872: NOT
60873: OR
60874: IFFALSE 60878
// exit ;
60876: GO 60903
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60878: LD_ADDR_EXP 121
60882: PUSH
60883: LD_EXP 121
60887: PPUSH
60888: LD_VAR 0 1
60892: PPUSH
60893: LD_VAR 0 2
60897: PPUSH
60898: CALL_OW 1
60902: ST_TO_ADDR
// end ;
60903: LD_VAR 0 3
60907: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60908: LD_INT 0
60910: PPUSH
// if not mc_bases or not base or not scan_area then
60911: LD_EXP 97
60915: NOT
60916: PUSH
60917: LD_VAR 0 1
60921: NOT
60922: OR
60923: PUSH
60924: LD_VAR 0 2
60928: NOT
60929: OR
60930: IFFALSE 60934
// exit ;
60932: GO 60959
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60934: LD_ADDR_EXP 122
60938: PUSH
60939: LD_EXP 122
60943: PPUSH
60944: LD_VAR 0 1
60948: PPUSH
60949: LD_VAR 0 2
60953: PPUSH
60954: CALL_OW 1
60958: ST_TO_ADDR
// end ;
60959: LD_VAR 0 3
60963: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60964: LD_INT 0
60966: PPUSH
60967: PPUSH
// if not mc_bases or not base then
60968: LD_EXP 97
60972: NOT
60973: PUSH
60974: LD_VAR 0 1
60978: NOT
60979: OR
60980: IFFALSE 60984
// exit ;
60982: GO 61048
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60984: LD_ADDR_VAR 0 3
60988: PUSH
60989: LD_INT 1
60991: PUSH
60992: LD_INT 2
60994: PUSH
60995: LD_INT 3
60997: PUSH
60998: LD_INT 4
61000: PUSH
61001: LD_INT 11
61003: PUSH
61004: EMPTY
61005: LIST
61006: LIST
61007: LIST
61008: LIST
61009: LIST
61010: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
61011: LD_ADDR_EXP 124
61015: PUSH
61016: LD_EXP 124
61020: PPUSH
61021: LD_VAR 0 1
61025: PPUSH
61026: LD_EXP 124
61030: PUSH
61031: LD_VAR 0 1
61035: ARRAY
61036: PUSH
61037: LD_VAR 0 3
61041: DIFF
61042: PPUSH
61043: CALL_OW 1
61047: ST_TO_ADDR
// end ;
61048: LD_VAR 0 2
61052: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
61053: LD_INT 0
61055: PPUSH
// result := mc_vehicles [ base ] ;
61056: LD_ADDR_VAR 0 3
61060: PUSH
61061: LD_EXP 116
61065: PUSH
61066: LD_VAR 0 1
61070: ARRAY
61071: ST_TO_ADDR
// if onlyCombat then
61072: LD_VAR 0 2
61076: IFFALSE 61248
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
61078: LD_ADDR_VAR 0 3
61082: PUSH
61083: LD_VAR 0 3
61087: PUSH
61088: LD_VAR 0 3
61092: PPUSH
61093: LD_INT 2
61095: PUSH
61096: LD_INT 34
61098: PUSH
61099: LD_INT 12
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 34
61108: PUSH
61109: LD_INT 51
61111: PUSH
61112: EMPTY
61113: LIST
61114: LIST
61115: PUSH
61116: LD_INT 34
61118: PUSH
61119: LD_INT 89
61121: PUSH
61122: EMPTY
61123: LIST
61124: LIST
61125: PUSH
61126: LD_INT 34
61128: PUSH
61129: LD_INT 32
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 34
61138: PUSH
61139: LD_INT 13
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 34
61148: PUSH
61149: LD_INT 52
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: LD_INT 34
61158: PUSH
61159: LD_INT 88
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PUSH
61166: LD_INT 34
61168: PUSH
61169: LD_INT 14
61171: PUSH
61172: EMPTY
61173: LIST
61174: LIST
61175: PUSH
61176: LD_INT 34
61178: PUSH
61179: LD_INT 53
61181: PUSH
61182: EMPTY
61183: LIST
61184: LIST
61185: PUSH
61186: LD_INT 34
61188: PUSH
61189: LD_INT 98
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PUSH
61196: LD_INT 34
61198: PUSH
61199: LD_INT 31
61201: PUSH
61202: EMPTY
61203: LIST
61204: LIST
61205: PUSH
61206: LD_INT 34
61208: PUSH
61209: LD_INT 48
61211: PUSH
61212: EMPTY
61213: LIST
61214: LIST
61215: PUSH
61216: LD_INT 34
61218: PUSH
61219: LD_INT 8
61221: PUSH
61222: EMPTY
61223: LIST
61224: LIST
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: PPUSH
61242: CALL_OW 72
61246: DIFF
61247: ST_TO_ADDR
// end ; end_of_file
61248: LD_VAR 0 3
61252: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61253: LD_INT 0
61255: PPUSH
61256: PPUSH
61257: PPUSH
// if not mc_bases or not skirmish then
61258: LD_EXP 97
61262: NOT
61263: PUSH
61264: LD_EXP 95
61268: NOT
61269: OR
61270: IFFALSE 61274
// exit ;
61272: GO 61439
// for i = 1 to mc_bases do
61274: LD_ADDR_VAR 0 4
61278: PUSH
61279: DOUBLE
61280: LD_INT 1
61282: DEC
61283: ST_TO_ADDR
61284: LD_EXP 97
61288: PUSH
61289: FOR_TO
61290: IFFALSE 61437
// begin if sci in mc_bases [ i ] then
61292: LD_VAR 0 2
61296: PUSH
61297: LD_EXP 97
61301: PUSH
61302: LD_VAR 0 4
61306: ARRAY
61307: IN
61308: IFFALSE 61435
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61310: LD_ADDR_EXP 126
61314: PUSH
61315: LD_EXP 126
61319: PPUSH
61320: LD_VAR 0 4
61324: PUSH
61325: LD_EXP 126
61329: PUSH
61330: LD_VAR 0 4
61334: ARRAY
61335: PUSH
61336: LD_INT 1
61338: PLUS
61339: PUSH
61340: EMPTY
61341: LIST
61342: LIST
61343: PPUSH
61344: LD_VAR 0 1
61348: PPUSH
61349: CALL 71160 0 3
61353: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61354: LD_ADDR_VAR 0 5
61358: PUSH
61359: LD_EXP 97
61363: PUSH
61364: LD_VAR 0 4
61368: ARRAY
61369: PPUSH
61370: LD_INT 2
61372: PUSH
61373: LD_INT 30
61375: PUSH
61376: LD_INT 0
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PUSH
61383: LD_INT 30
61385: PUSH
61386: LD_INT 1
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: LIST
61397: PPUSH
61398: CALL_OW 72
61402: PPUSH
61403: LD_VAR 0 1
61407: PPUSH
61408: CALL_OW 74
61412: ST_TO_ADDR
// if tmp then
61413: LD_VAR 0 5
61417: IFFALSE 61433
// ComStandNearbyBuilding ( ape , tmp ) ;
61419: LD_VAR 0 1
61423: PPUSH
61424: LD_VAR 0 5
61428: PPUSH
61429: CALL 67587 0 2
// break ;
61433: GO 61437
// end ; end ;
61435: GO 61289
61437: POP
61438: POP
// end ;
61439: LD_VAR 0 3
61443: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61444: LD_INT 0
61446: PPUSH
61447: PPUSH
61448: PPUSH
// if not mc_bases or not skirmish then
61449: LD_EXP 97
61453: NOT
61454: PUSH
61455: LD_EXP 95
61459: NOT
61460: OR
61461: IFFALSE 61465
// exit ;
61463: GO 61554
// for i = 1 to mc_bases do
61465: LD_ADDR_VAR 0 4
61469: PUSH
61470: DOUBLE
61471: LD_INT 1
61473: DEC
61474: ST_TO_ADDR
61475: LD_EXP 97
61479: PUSH
61480: FOR_TO
61481: IFFALSE 61552
// begin if building in mc_busy_turret_list [ i ] then
61483: LD_VAR 0 1
61487: PUSH
61488: LD_EXP 107
61492: PUSH
61493: LD_VAR 0 4
61497: ARRAY
61498: IN
61499: IFFALSE 61550
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61501: LD_ADDR_VAR 0 5
61505: PUSH
61506: LD_EXP 107
61510: PUSH
61511: LD_VAR 0 4
61515: ARRAY
61516: PUSH
61517: LD_VAR 0 1
61521: DIFF
61522: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61523: LD_ADDR_EXP 107
61527: PUSH
61528: LD_EXP 107
61532: PPUSH
61533: LD_VAR 0 4
61537: PPUSH
61538: LD_VAR 0 5
61542: PPUSH
61543: CALL_OW 1
61547: ST_TO_ADDR
// break ;
61548: GO 61552
// end ; end ;
61550: GO 61480
61552: POP
61553: POP
// end ;
61554: LD_VAR 0 3
61558: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61559: LD_INT 0
61561: PPUSH
61562: PPUSH
61563: PPUSH
// if not mc_bases or not skirmish then
61564: LD_EXP 97
61568: NOT
61569: PUSH
61570: LD_EXP 95
61574: NOT
61575: OR
61576: IFFALSE 61580
// exit ;
61578: GO 61779
// for i = 1 to mc_bases do
61580: LD_ADDR_VAR 0 5
61584: PUSH
61585: DOUBLE
61586: LD_INT 1
61588: DEC
61589: ST_TO_ADDR
61590: LD_EXP 97
61594: PUSH
61595: FOR_TO
61596: IFFALSE 61777
// if building in mc_bases [ i ] then
61598: LD_VAR 0 1
61602: PUSH
61603: LD_EXP 97
61607: PUSH
61608: LD_VAR 0 5
61612: ARRAY
61613: IN
61614: IFFALSE 61775
// begin tmp := mc_bases [ i ] diff building ;
61616: LD_ADDR_VAR 0 6
61620: PUSH
61621: LD_EXP 97
61625: PUSH
61626: LD_VAR 0 5
61630: ARRAY
61631: PUSH
61632: LD_VAR 0 1
61636: DIFF
61637: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61638: LD_ADDR_EXP 97
61642: PUSH
61643: LD_EXP 97
61647: PPUSH
61648: LD_VAR 0 5
61652: PPUSH
61653: LD_VAR 0 6
61657: PPUSH
61658: CALL_OW 1
61662: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61663: LD_VAR 0 1
61667: PUSH
61668: LD_EXP 105
61672: PUSH
61673: LD_VAR 0 5
61677: ARRAY
61678: IN
61679: IFFALSE 61718
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61681: LD_ADDR_EXP 105
61685: PUSH
61686: LD_EXP 105
61690: PPUSH
61691: LD_VAR 0 5
61695: PPUSH
61696: LD_EXP 105
61700: PUSH
61701: LD_VAR 0 5
61705: ARRAY
61706: PUSH
61707: LD_VAR 0 1
61711: DIFF
61712: PPUSH
61713: CALL_OW 1
61717: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61718: LD_VAR 0 1
61722: PUSH
61723: LD_EXP 106
61727: PUSH
61728: LD_VAR 0 5
61732: ARRAY
61733: IN
61734: IFFALSE 61773
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61736: LD_ADDR_EXP 106
61740: PUSH
61741: LD_EXP 106
61745: PPUSH
61746: LD_VAR 0 5
61750: PPUSH
61751: LD_EXP 106
61755: PUSH
61756: LD_VAR 0 5
61760: ARRAY
61761: PUSH
61762: LD_VAR 0 1
61766: DIFF
61767: PPUSH
61768: CALL_OW 1
61772: ST_TO_ADDR
// break ;
61773: GO 61777
// end ;
61775: GO 61595
61777: POP
61778: POP
// end ;
61779: LD_VAR 0 4
61783: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61784: LD_INT 0
61786: PPUSH
61787: PPUSH
61788: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61789: LD_EXP 97
61793: NOT
61794: PUSH
61795: LD_EXP 95
61799: NOT
61800: OR
61801: PUSH
61802: LD_VAR 0 3
61806: PUSH
61807: LD_EXP 123
61811: IN
61812: NOT
61813: OR
61814: IFFALSE 61818
// exit ;
61816: GO 61941
// for i = 1 to mc_vehicles do
61818: LD_ADDR_VAR 0 6
61822: PUSH
61823: DOUBLE
61824: LD_INT 1
61826: DEC
61827: ST_TO_ADDR
61828: LD_EXP 116
61832: PUSH
61833: FOR_TO
61834: IFFALSE 61939
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61836: LD_VAR 0 2
61840: PUSH
61841: LD_EXP 116
61845: PUSH
61846: LD_VAR 0 6
61850: ARRAY
61851: IN
61852: PUSH
61853: LD_VAR 0 1
61857: PUSH
61858: LD_EXP 116
61862: PUSH
61863: LD_VAR 0 6
61867: ARRAY
61868: IN
61869: OR
61870: IFFALSE 61937
// begin tmp := mc_vehicles [ i ] diff old ;
61872: LD_ADDR_VAR 0 7
61876: PUSH
61877: LD_EXP 116
61881: PUSH
61882: LD_VAR 0 6
61886: ARRAY
61887: PUSH
61888: LD_VAR 0 2
61892: DIFF
61893: ST_TO_ADDR
// tmp := tmp diff new ;
61894: LD_ADDR_VAR 0 7
61898: PUSH
61899: LD_VAR 0 7
61903: PUSH
61904: LD_VAR 0 1
61908: DIFF
61909: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61910: LD_ADDR_EXP 116
61914: PUSH
61915: LD_EXP 116
61919: PPUSH
61920: LD_VAR 0 6
61924: PPUSH
61925: LD_VAR 0 7
61929: PPUSH
61930: CALL_OW 1
61934: ST_TO_ADDR
// break ;
61935: GO 61939
// end ;
61937: GO 61833
61939: POP
61940: POP
// end ;
61941: LD_VAR 0 5
61945: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61946: LD_INT 0
61948: PPUSH
61949: PPUSH
61950: PPUSH
61951: PPUSH
// if not mc_bases or not skirmish then
61952: LD_EXP 97
61956: NOT
61957: PUSH
61958: LD_EXP 95
61962: NOT
61963: OR
61964: IFFALSE 61968
// exit ;
61966: GO 62350
// side := GetSide ( vehicle ) ;
61968: LD_ADDR_VAR 0 5
61972: PUSH
61973: LD_VAR 0 1
61977: PPUSH
61978: CALL_OW 255
61982: ST_TO_ADDR
// for i = 1 to mc_bases do
61983: LD_ADDR_VAR 0 4
61987: PUSH
61988: DOUBLE
61989: LD_INT 1
61991: DEC
61992: ST_TO_ADDR
61993: LD_EXP 97
61997: PUSH
61998: FOR_TO
61999: IFFALSE 62348
// begin if factory in mc_bases [ i ] then
62001: LD_VAR 0 2
62005: PUSH
62006: LD_EXP 97
62010: PUSH
62011: LD_VAR 0 4
62015: ARRAY
62016: IN
62017: IFFALSE 62346
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
62019: LD_EXP 119
62023: PUSH
62024: LD_VAR 0 4
62028: ARRAY
62029: PUSH
62030: LD_EXP 108
62034: PUSH
62035: LD_VAR 0 4
62039: ARRAY
62040: LESS
62041: PUSH
62042: LD_VAR 0 1
62046: PPUSH
62047: CALL_OW 264
62051: PUSH
62052: LD_INT 31
62054: PUSH
62055: LD_INT 32
62057: PUSH
62058: LD_INT 51
62060: PUSH
62061: LD_INT 89
62063: PUSH
62064: LD_INT 12
62066: PUSH
62067: LD_INT 30
62069: PUSH
62070: LD_INT 98
62072: PUSH
62073: LD_INT 11
62075: PUSH
62076: LD_INT 53
62078: PUSH
62079: LD_INT 14
62081: PUSH
62082: LD_INT 91
62084: PUSH
62085: LD_INT 29
62087: PUSH
62088: LD_INT 99
62090: PUSH
62091: LD_INT 13
62093: PUSH
62094: LD_INT 52
62096: PUSH
62097: LD_INT 88
62099: PUSH
62100: LD_INT 48
62102: PUSH
62103: LD_INT 8
62105: PUSH
62106: EMPTY
62107: LIST
62108: LIST
62109: LIST
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: LIST
62116: LIST
62117: LIST
62118: LIST
62119: LIST
62120: LIST
62121: LIST
62122: LIST
62123: LIST
62124: LIST
62125: IN
62126: NOT
62127: AND
62128: IFFALSE 62176
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
62130: LD_ADDR_EXP 119
62134: PUSH
62135: LD_EXP 119
62139: PPUSH
62140: LD_VAR 0 4
62144: PUSH
62145: LD_EXP 119
62149: PUSH
62150: LD_VAR 0 4
62154: ARRAY
62155: PUSH
62156: LD_INT 1
62158: PLUS
62159: PUSH
62160: EMPTY
62161: LIST
62162: LIST
62163: PPUSH
62164: LD_VAR 0 1
62168: PPUSH
62169: CALL 71160 0 3
62173: ST_TO_ADDR
62174: GO 62220
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62176: LD_ADDR_EXP 116
62180: PUSH
62181: LD_EXP 116
62185: PPUSH
62186: LD_VAR 0 4
62190: PUSH
62191: LD_EXP 116
62195: PUSH
62196: LD_VAR 0 4
62200: ARRAY
62201: PUSH
62202: LD_INT 1
62204: PLUS
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PPUSH
62210: LD_VAR 0 1
62214: PPUSH
62215: CALL 71160 0 3
62219: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62220: LD_VAR 0 1
62224: PPUSH
62225: CALL_OW 263
62229: PUSH
62230: LD_INT 2
62232: EQUAL
62233: IFFALSE 62262
// begin repeat wait ( 0 0$3 ) ;
62235: LD_INT 105
62237: PPUSH
62238: CALL_OW 67
// Connect ( vehicle ) ;
62242: LD_VAR 0 1
62246: PPUSH
62247: CALL 74129 0 1
// until IsControledBy ( vehicle ) ;
62251: LD_VAR 0 1
62255: PPUSH
62256: CALL_OW 312
62260: IFFALSE 62235
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62262: LD_VAR 0 1
62266: PPUSH
62267: LD_EXP 121
62271: PUSH
62272: LD_VAR 0 4
62276: ARRAY
62277: PPUSH
62278: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62282: LD_VAR 0 1
62286: PPUSH
62287: CALL_OW 263
62291: PUSH
62292: LD_INT 1
62294: NONEQUAL
62295: IFFALSE 62299
// break ;
62297: GO 62348
// repeat wait ( 0 0$1 ) ;
62299: LD_INT 35
62301: PPUSH
62302: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62306: LD_VAR 0 1
62310: PPUSH
62311: LD_EXP 121
62315: PUSH
62316: LD_VAR 0 4
62320: ARRAY
62321: PPUSH
62322: CALL_OW 308
62326: IFFALSE 62299
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62328: LD_VAR 0 1
62332: PPUSH
62333: CALL_OW 311
62337: PPUSH
62338: CALL_OW 121
// exit ;
62342: POP
62343: POP
62344: GO 62350
// end ; end ;
62346: GO 61998
62348: POP
62349: POP
// end ;
62350: LD_VAR 0 3
62354: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62355: LD_INT 0
62357: PPUSH
62358: PPUSH
62359: PPUSH
62360: PPUSH
// if not mc_bases or not skirmish then
62361: LD_EXP 97
62365: NOT
62366: PUSH
62367: LD_EXP 95
62371: NOT
62372: OR
62373: IFFALSE 62377
// exit ;
62375: GO 62730
// repeat wait ( 0 0$1 ) ;
62377: LD_INT 35
62379: PPUSH
62380: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62384: LD_VAR 0 2
62388: PPUSH
62389: LD_VAR 0 3
62393: PPUSH
62394: CALL_OW 284
62398: IFFALSE 62377
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62400: LD_VAR 0 2
62404: PPUSH
62405: LD_VAR 0 3
62409: PPUSH
62410: CALL_OW 283
62414: PUSH
62415: LD_INT 4
62417: EQUAL
62418: IFFALSE 62422
// exit ;
62420: GO 62730
// for i = 1 to mc_bases do
62422: LD_ADDR_VAR 0 7
62426: PUSH
62427: DOUBLE
62428: LD_INT 1
62430: DEC
62431: ST_TO_ADDR
62432: LD_EXP 97
62436: PUSH
62437: FOR_TO
62438: IFFALSE 62728
// begin if mc_crates_area [ i ] then
62440: LD_EXP 115
62444: PUSH
62445: LD_VAR 0 7
62449: ARRAY
62450: IFFALSE 62561
// for j in mc_crates_area [ i ] do
62452: LD_ADDR_VAR 0 8
62456: PUSH
62457: LD_EXP 115
62461: PUSH
62462: LD_VAR 0 7
62466: ARRAY
62467: PUSH
62468: FOR_IN
62469: IFFALSE 62559
// if InArea ( x , y , j ) then
62471: LD_VAR 0 2
62475: PPUSH
62476: LD_VAR 0 3
62480: PPUSH
62481: LD_VAR 0 8
62485: PPUSH
62486: CALL_OW 309
62490: IFFALSE 62557
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62492: LD_ADDR_EXP 113
62496: PUSH
62497: LD_EXP 113
62501: PPUSH
62502: LD_VAR 0 7
62506: PUSH
62507: LD_EXP 113
62511: PUSH
62512: LD_VAR 0 7
62516: ARRAY
62517: PUSH
62518: LD_INT 1
62520: PLUS
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PPUSH
62526: LD_VAR 0 4
62530: PUSH
62531: LD_VAR 0 2
62535: PUSH
62536: LD_VAR 0 3
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: LIST
62545: PPUSH
62546: CALL 71160 0 3
62550: ST_TO_ADDR
// exit ;
62551: POP
62552: POP
62553: POP
62554: POP
62555: GO 62730
// end ;
62557: GO 62468
62559: POP
62560: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62561: LD_ADDR_VAR 0 9
62565: PUSH
62566: LD_EXP 97
62570: PUSH
62571: LD_VAR 0 7
62575: ARRAY
62576: PPUSH
62577: LD_INT 2
62579: PUSH
62580: LD_INT 30
62582: PUSH
62583: LD_INT 0
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: PUSH
62590: LD_INT 30
62592: PUSH
62593: LD_INT 1
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: LIST
62604: PPUSH
62605: CALL_OW 72
62609: ST_TO_ADDR
// if not depot then
62610: LD_VAR 0 9
62614: NOT
62615: IFFALSE 62619
// continue ;
62617: GO 62437
// for j in depot do
62619: LD_ADDR_VAR 0 8
62623: PUSH
62624: LD_VAR 0 9
62628: PUSH
62629: FOR_IN
62630: IFFALSE 62724
// if GetDistUnitXY ( j , x , y ) < 30 then
62632: LD_VAR 0 8
62636: PPUSH
62637: LD_VAR 0 2
62641: PPUSH
62642: LD_VAR 0 3
62646: PPUSH
62647: CALL_OW 297
62651: PUSH
62652: LD_INT 30
62654: LESS
62655: IFFALSE 62722
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62657: LD_ADDR_EXP 113
62661: PUSH
62662: LD_EXP 113
62666: PPUSH
62667: LD_VAR 0 7
62671: PUSH
62672: LD_EXP 113
62676: PUSH
62677: LD_VAR 0 7
62681: ARRAY
62682: PUSH
62683: LD_INT 1
62685: PLUS
62686: PUSH
62687: EMPTY
62688: LIST
62689: LIST
62690: PPUSH
62691: LD_VAR 0 4
62695: PUSH
62696: LD_VAR 0 2
62700: PUSH
62701: LD_VAR 0 3
62705: PUSH
62706: EMPTY
62707: LIST
62708: LIST
62709: LIST
62710: PPUSH
62711: CALL 71160 0 3
62715: ST_TO_ADDR
// exit ;
62716: POP
62717: POP
62718: POP
62719: POP
62720: GO 62730
// end ;
62722: GO 62629
62724: POP
62725: POP
// end ;
62726: GO 62437
62728: POP
62729: POP
// end ;
62730: LD_VAR 0 6
62734: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62735: LD_INT 0
62737: PPUSH
62738: PPUSH
62739: PPUSH
62740: PPUSH
// if not mc_bases or not skirmish then
62741: LD_EXP 97
62745: NOT
62746: PUSH
62747: LD_EXP 95
62751: NOT
62752: OR
62753: IFFALSE 62757
// exit ;
62755: GO 63034
// side := GetSide ( lab ) ;
62757: LD_ADDR_VAR 0 4
62761: PUSH
62762: LD_VAR 0 2
62766: PPUSH
62767: CALL_OW 255
62771: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62772: LD_VAR 0 4
62776: PUSH
62777: LD_EXP 123
62781: IN
62782: NOT
62783: PUSH
62784: LD_EXP 124
62788: NOT
62789: OR
62790: PUSH
62791: LD_EXP 97
62795: NOT
62796: OR
62797: IFFALSE 62801
// exit ;
62799: GO 63034
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62801: LD_ADDR_EXP 124
62805: PUSH
62806: LD_EXP 124
62810: PPUSH
62811: LD_VAR 0 4
62815: PPUSH
62816: LD_EXP 124
62820: PUSH
62821: LD_VAR 0 4
62825: ARRAY
62826: PUSH
62827: LD_VAR 0 1
62831: DIFF
62832: PPUSH
62833: CALL_OW 1
62837: ST_TO_ADDR
// for i = 1 to mc_bases do
62838: LD_ADDR_VAR 0 5
62842: PUSH
62843: DOUBLE
62844: LD_INT 1
62846: DEC
62847: ST_TO_ADDR
62848: LD_EXP 97
62852: PUSH
62853: FOR_TO
62854: IFFALSE 63032
// begin if lab in mc_bases [ i ] then
62856: LD_VAR 0 2
62860: PUSH
62861: LD_EXP 97
62865: PUSH
62866: LD_VAR 0 5
62870: ARRAY
62871: IN
62872: IFFALSE 63030
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62874: LD_VAR 0 1
62878: PUSH
62879: LD_INT 11
62881: PUSH
62882: LD_INT 4
62884: PUSH
62885: LD_INT 3
62887: PUSH
62888: LD_INT 2
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: IN
62897: PUSH
62898: LD_EXP 127
62902: PUSH
62903: LD_VAR 0 5
62907: ARRAY
62908: AND
62909: IFFALSE 63030
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62911: LD_ADDR_VAR 0 6
62915: PUSH
62916: LD_EXP 127
62920: PUSH
62921: LD_VAR 0 5
62925: ARRAY
62926: PUSH
62927: LD_INT 1
62929: ARRAY
62930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62931: LD_ADDR_EXP 127
62935: PUSH
62936: LD_EXP 127
62940: PPUSH
62941: LD_VAR 0 5
62945: PPUSH
62946: EMPTY
62947: PPUSH
62948: CALL_OW 1
62952: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62953: LD_VAR 0 6
62957: PPUSH
62958: LD_INT 0
62960: PPUSH
62961: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62965: LD_VAR 0 6
62969: PPUSH
62970: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62974: LD_ADDR_EXP 126
62978: PUSH
62979: LD_EXP 126
62983: PPUSH
62984: LD_VAR 0 5
62988: PPUSH
62989: LD_EXP 126
62993: PUSH
62994: LD_VAR 0 5
62998: ARRAY
62999: PPUSH
63000: LD_INT 1
63002: PPUSH
63003: LD_VAR 0 6
63007: PPUSH
63008: CALL_OW 2
63012: PPUSH
63013: CALL_OW 1
63017: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
63018: LD_VAR 0 5
63022: PPUSH
63023: LD_INT 112
63025: PPUSH
63026: CALL 39573 0 2
// end ; end ; end ;
63030: GO 62853
63032: POP
63033: POP
// end ;
63034: LD_VAR 0 3
63038: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
63039: LD_INT 0
63041: PPUSH
63042: PPUSH
63043: PPUSH
63044: PPUSH
63045: PPUSH
63046: PPUSH
63047: PPUSH
63048: PPUSH
// if not mc_bases or not skirmish then
63049: LD_EXP 97
63053: NOT
63054: PUSH
63055: LD_EXP 95
63059: NOT
63060: OR
63061: IFFALSE 63065
// exit ;
63063: GO 64434
// for i = 1 to mc_bases do
63065: LD_ADDR_VAR 0 3
63069: PUSH
63070: DOUBLE
63071: LD_INT 1
63073: DEC
63074: ST_TO_ADDR
63075: LD_EXP 97
63079: PUSH
63080: FOR_TO
63081: IFFALSE 64432
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
63083: LD_VAR 0 1
63087: PUSH
63088: LD_EXP 97
63092: PUSH
63093: LD_VAR 0 3
63097: ARRAY
63098: IN
63099: PUSH
63100: LD_VAR 0 1
63104: PUSH
63105: LD_EXP 104
63109: PUSH
63110: LD_VAR 0 3
63114: ARRAY
63115: IN
63116: OR
63117: PUSH
63118: LD_VAR 0 1
63122: PUSH
63123: LD_EXP 119
63127: PUSH
63128: LD_VAR 0 3
63132: ARRAY
63133: IN
63134: OR
63135: PUSH
63136: LD_VAR 0 1
63140: PUSH
63141: LD_EXP 116
63145: PUSH
63146: LD_VAR 0 3
63150: ARRAY
63151: IN
63152: OR
63153: PUSH
63154: LD_VAR 0 1
63158: PUSH
63159: LD_EXP 126
63163: PUSH
63164: LD_VAR 0 3
63168: ARRAY
63169: IN
63170: OR
63171: PUSH
63172: LD_VAR 0 1
63176: PUSH
63177: LD_EXP 127
63181: PUSH
63182: LD_VAR 0 3
63186: ARRAY
63187: IN
63188: OR
63189: IFFALSE 64430
// begin if un in mc_ape [ i ] then
63191: LD_VAR 0 1
63195: PUSH
63196: LD_EXP 126
63200: PUSH
63201: LD_VAR 0 3
63205: ARRAY
63206: IN
63207: IFFALSE 63246
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63209: LD_ADDR_EXP 126
63213: PUSH
63214: LD_EXP 126
63218: PPUSH
63219: LD_VAR 0 3
63223: PPUSH
63224: LD_EXP 126
63228: PUSH
63229: LD_VAR 0 3
63233: ARRAY
63234: PUSH
63235: LD_VAR 0 1
63239: DIFF
63240: PPUSH
63241: CALL_OW 1
63245: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63246: LD_VAR 0 1
63250: PUSH
63251: LD_EXP 127
63255: PUSH
63256: LD_VAR 0 3
63260: ARRAY
63261: IN
63262: IFFALSE 63286
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63264: LD_ADDR_EXP 127
63268: PUSH
63269: LD_EXP 127
63273: PPUSH
63274: LD_VAR 0 3
63278: PPUSH
63279: EMPTY
63280: PPUSH
63281: CALL_OW 1
63285: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63286: LD_VAR 0 1
63290: PPUSH
63291: CALL_OW 247
63295: PUSH
63296: LD_INT 2
63298: EQUAL
63299: PUSH
63300: LD_VAR 0 1
63304: PPUSH
63305: CALL_OW 110
63309: PUSH
63310: LD_INT 20
63312: EQUAL
63313: PUSH
63314: LD_VAR 0 1
63318: PUSH
63319: LD_EXP 119
63323: PUSH
63324: LD_VAR 0 3
63328: ARRAY
63329: IN
63330: OR
63331: PUSH
63332: LD_VAR 0 1
63336: PPUSH
63337: CALL_OW 264
63341: PUSH
63342: LD_INT 12
63344: PUSH
63345: LD_INT 51
63347: PUSH
63348: LD_INT 89
63350: PUSH
63351: LD_INT 32
63353: PUSH
63354: LD_INT 13
63356: PUSH
63357: LD_INT 52
63359: PUSH
63360: LD_INT 31
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: IN
63372: OR
63373: AND
63374: IFFALSE 63682
// begin if un in mc_defender [ i ] then
63376: LD_VAR 0 1
63380: PUSH
63381: LD_EXP 119
63385: PUSH
63386: LD_VAR 0 3
63390: ARRAY
63391: IN
63392: IFFALSE 63431
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63394: LD_ADDR_EXP 119
63398: PUSH
63399: LD_EXP 119
63403: PPUSH
63404: LD_VAR 0 3
63408: PPUSH
63409: LD_EXP 119
63413: PUSH
63414: LD_VAR 0 3
63418: ARRAY
63419: PUSH
63420: LD_VAR 0 1
63424: DIFF
63425: PPUSH
63426: CALL_OW 1
63430: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63431: LD_ADDR_VAR 0 8
63435: PUSH
63436: LD_VAR 0 3
63440: PPUSH
63441: LD_INT 3
63443: PPUSH
63444: CALL 60090 0 2
63448: ST_TO_ADDR
// if fac then
63449: LD_VAR 0 8
63453: IFFALSE 63682
// begin for j in fac do
63455: LD_ADDR_VAR 0 4
63459: PUSH
63460: LD_VAR 0 8
63464: PUSH
63465: FOR_IN
63466: IFFALSE 63680
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63468: LD_ADDR_VAR 0 9
63472: PUSH
63473: LD_VAR 0 8
63477: PPUSH
63478: LD_VAR 0 1
63482: PPUSH
63483: CALL_OW 265
63487: PPUSH
63488: LD_VAR 0 1
63492: PPUSH
63493: CALL_OW 262
63497: PPUSH
63498: LD_VAR 0 1
63502: PPUSH
63503: CALL_OW 263
63507: PPUSH
63508: LD_VAR 0 1
63512: PPUSH
63513: CALL_OW 264
63517: PPUSH
63518: CALL 68658 0 5
63522: ST_TO_ADDR
// if components then
63523: LD_VAR 0 9
63527: IFFALSE 63678
// begin if GetWeapon ( un ) = ar_control_tower then
63529: LD_VAR 0 1
63533: PPUSH
63534: CALL_OW 264
63538: PUSH
63539: LD_INT 31
63541: EQUAL
63542: IFFALSE 63659
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63544: LD_VAR 0 1
63548: PPUSH
63549: CALL_OW 311
63553: PPUSH
63554: LD_INT 0
63556: PPUSH
63557: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63561: LD_ADDR_EXP 137
63565: PUSH
63566: LD_EXP 137
63570: PPUSH
63571: LD_VAR 0 3
63575: PPUSH
63576: LD_EXP 137
63580: PUSH
63581: LD_VAR 0 3
63585: ARRAY
63586: PUSH
63587: LD_VAR 0 1
63591: PPUSH
63592: CALL_OW 311
63596: DIFF
63597: PPUSH
63598: CALL_OW 1
63602: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63603: LD_ADDR_VAR 0 7
63607: PUSH
63608: LD_EXP 118
63612: PUSH
63613: LD_VAR 0 3
63617: ARRAY
63618: PPUSH
63619: LD_INT 1
63621: PPUSH
63622: LD_VAR 0 9
63626: PPUSH
63627: CALL_OW 2
63631: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63632: LD_ADDR_EXP 118
63636: PUSH
63637: LD_EXP 118
63641: PPUSH
63642: LD_VAR 0 3
63646: PPUSH
63647: LD_VAR 0 7
63651: PPUSH
63652: CALL_OW 1
63656: ST_TO_ADDR
// end else
63657: GO 63676
// MC_InsertProduceList ( i , [ components ] ) ;
63659: LD_VAR 0 3
63663: PPUSH
63664: LD_VAR 0 9
63668: PUSH
63669: EMPTY
63670: LIST
63671: PPUSH
63672: CALL 59635 0 2
// break ;
63676: GO 63680
// end ; end ;
63678: GO 63465
63680: POP
63681: POP
// end ; end ; if GetType ( un ) = unit_building then
63682: LD_VAR 0 1
63686: PPUSH
63687: CALL_OW 247
63691: PUSH
63692: LD_INT 3
63694: EQUAL
63695: IFFALSE 64098
// begin btype := GetBType ( un ) ;
63697: LD_ADDR_VAR 0 5
63701: PUSH
63702: LD_VAR 0 1
63706: PPUSH
63707: CALL_OW 266
63711: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63712: LD_VAR 0 5
63716: PUSH
63717: LD_INT 29
63719: PUSH
63720: LD_INT 30
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: IN
63727: IFFALSE 63800
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63729: LD_VAR 0 1
63733: PPUSH
63734: CALL_OW 250
63738: PPUSH
63739: LD_VAR 0 1
63743: PPUSH
63744: CALL_OW 251
63748: PPUSH
63749: LD_VAR 0 1
63753: PPUSH
63754: CALL_OW 255
63758: PPUSH
63759: CALL_OW 440
63763: NOT
63764: IFFALSE 63800
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63766: LD_VAR 0 1
63770: PPUSH
63771: CALL_OW 250
63775: PPUSH
63776: LD_VAR 0 1
63780: PPUSH
63781: CALL_OW 251
63785: PPUSH
63786: LD_VAR 0 1
63790: PPUSH
63791: CALL_OW 255
63795: PPUSH
63796: CALL_OW 441
// end ; if btype = b_warehouse then
63800: LD_VAR 0 5
63804: PUSH
63805: LD_INT 1
63807: EQUAL
63808: IFFALSE 63826
// begin btype := b_depot ;
63810: LD_ADDR_VAR 0 5
63814: PUSH
63815: LD_INT 0
63817: ST_TO_ADDR
// pos := 1 ;
63818: LD_ADDR_VAR 0 6
63822: PUSH
63823: LD_INT 1
63825: ST_TO_ADDR
// end ; if btype = b_factory then
63826: LD_VAR 0 5
63830: PUSH
63831: LD_INT 3
63833: EQUAL
63834: IFFALSE 63852
// begin btype := b_workshop ;
63836: LD_ADDR_VAR 0 5
63840: PUSH
63841: LD_INT 2
63843: ST_TO_ADDR
// pos := 1 ;
63844: LD_ADDR_VAR 0 6
63848: PUSH
63849: LD_INT 1
63851: ST_TO_ADDR
// end ; if btype = b_barracks then
63852: LD_VAR 0 5
63856: PUSH
63857: LD_INT 5
63859: EQUAL
63860: IFFALSE 63870
// btype := b_armoury ;
63862: LD_ADDR_VAR 0 5
63866: PUSH
63867: LD_INT 4
63869: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63870: LD_VAR 0 5
63874: PUSH
63875: LD_INT 7
63877: PUSH
63878: LD_INT 8
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: IN
63885: IFFALSE 63895
// btype := b_lab ;
63887: LD_ADDR_VAR 0 5
63891: PUSH
63892: LD_INT 6
63894: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63895: LD_ADDR_EXP 102
63899: PUSH
63900: LD_EXP 102
63904: PPUSH
63905: LD_VAR 0 3
63909: PUSH
63910: LD_EXP 102
63914: PUSH
63915: LD_VAR 0 3
63919: ARRAY
63920: PUSH
63921: LD_INT 1
63923: PLUS
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PPUSH
63929: LD_VAR 0 5
63933: PUSH
63934: LD_VAR 0 1
63938: PPUSH
63939: CALL_OW 250
63943: PUSH
63944: LD_VAR 0 1
63948: PPUSH
63949: CALL_OW 251
63953: PUSH
63954: LD_VAR 0 1
63958: PPUSH
63959: CALL_OW 254
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: PPUSH
63970: CALL 71160 0 3
63974: ST_TO_ADDR
// if pos = 1 then
63975: LD_VAR 0 6
63979: PUSH
63980: LD_INT 1
63982: EQUAL
63983: IFFALSE 64098
// begin tmp := mc_build_list [ i ] ;
63985: LD_ADDR_VAR 0 7
63989: PUSH
63990: LD_EXP 102
63994: PUSH
63995: LD_VAR 0 3
63999: ARRAY
64000: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64001: LD_VAR 0 7
64005: PPUSH
64006: LD_INT 2
64008: PUSH
64009: LD_INT 30
64011: PUSH
64012: LD_INT 0
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: LD_INT 30
64021: PUSH
64022: LD_INT 1
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: LIST
64033: PPUSH
64034: CALL_OW 72
64038: IFFALSE 64048
// pos := 2 ;
64040: LD_ADDR_VAR 0 6
64044: PUSH
64045: LD_INT 2
64047: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
64048: LD_ADDR_VAR 0 7
64052: PUSH
64053: LD_VAR 0 7
64057: PPUSH
64058: LD_VAR 0 6
64062: PPUSH
64063: LD_VAR 0 7
64067: PPUSH
64068: CALL 71486 0 3
64072: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
64073: LD_ADDR_EXP 102
64077: PUSH
64078: LD_EXP 102
64082: PPUSH
64083: LD_VAR 0 3
64087: PPUSH
64088: LD_VAR 0 7
64092: PPUSH
64093: CALL_OW 1
64097: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
64098: LD_VAR 0 1
64102: PUSH
64103: LD_EXP 97
64107: PUSH
64108: LD_VAR 0 3
64112: ARRAY
64113: IN
64114: IFFALSE 64153
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
64116: LD_ADDR_EXP 97
64120: PUSH
64121: LD_EXP 97
64125: PPUSH
64126: LD_VAR 0 3
64130: PPUSH
64131: LD_EXP 97
64135: PUSH
64136: LD_VAR 0 3
64140: ARRAY
64141: PUSH
64142: LD_VAR 0 1
64146: DIFF
64147: PPUSH
64148: CALL_OW 1
64152: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64153: LD_VAR 0 1
64157: PUSH
64158: LD_EXP 104
64162: PUSH
64163: LD_VAR 0 3
64167: ARRAY
64168: IN
64169: IFFALSE 64208
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64171: LD_ADDR_EXP 104
64175: PUSH
64176: LD_EXP 104
64180: PPUSH
64181: LD_VAR 0 3
64185: PPUSH
64186: LD_EXP 104
64190: PUSH
64191: LD_VAR 0 3
64195: ARRAY
64196: PUSH
64197: LD_VAR 0 1
64201: DIFF
64202: PPUSH
64203: CALL_OW 1
64207: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64208: LD_VAR 0 1
64212: PUSH
64213: LD_EXP 116
64217: PUSH
64218: LD_VAR 0 3
64222: ARRAY
64223: IN
64224: IFFALSE 64263
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64226: LD_ADDR_EXP 116
64230: PUSH
64231: LD_EXP 116
64235: PPUSH
64236: LD_VAR 0 3
64240: PPUSH
64241: LD_EXP 116
64245: PUSH
64246: LD_VAR 0 3
64250: ARRAY
64251: PUSH
64252: LD_VAR 0 1
64256: DIFF
64257: PPUSH
64258: CALL_OW 1
64262: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64263: LD_VAR 0 1
64267: PUSH
64268: LD_EXP 119
64272: PUSH
64273: LD_VAR 0 3
64277: ARRAY
64278: IN
64279: IFFALSE 64318
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64281: LD_ADDR_EXP 119
64285: PUSH
64286: LD_EXP 119
64290: PPUSH
64291: LD_VAR 0 3
64295: PPUSH
64296: LD_EXP 119
64300: PUSH
64301: LD_VAR 0 3
64305: ARRAY
64306: PUSH
64307: LD_VAR 0 1
64311: DIFF
64312: PPUSH
64313: CALL_OW 1
64317: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64318: LD_VAR 0 1
64322: PUSH
64323: LD_EXP 106
64327: PUSH
64328: LD_VAR 0 3
64332: ARRAY
64333: IN
64334: IFFALSE 64373
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64336: LD_ADDR_EXP 106
64340: PUSH
64341: LD_EXP 106
64345: PPUSH
64346: LD_VAR 0 3
64350: PPUSH
64351: LD_EXP 106
64355: PUSH
64356: LD_VAR 0 3
64360: ARRAY
64361: PUSH
64362: LD_VAR 0 1
64366: DIFF
64367: PPUSH
64368: CALL_OW 1
64372: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64373: LD_VAR 0 1
64377: PUSH
64378: LD_EXP 105
64382: PUSH
64383: LD_VAR 0 3
64387: ARRAY
64388: IN
64389: IFFALSE 64428
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64391: LD_ADDR_EXP 105
64395: PUSH
64396: LD_EXP 105
64400: PPUSH
64401: LD_VAR 0 3
64405: PPUSH
64406: LD_EXP 105
64410: PUSH
64411: LD_VAR 0 3
64415: ARRAY
64416: PUSH
64417: LD_VAR 0 1
64421: DIFF
64422: PPUSH
64423: CALL_OW 1
64427: ST_TO_ADDR
// end ; break ;
64428: GO 64432
// end ;
64430: GO 63080
64432: POP
64433: POP
// end ;
64434: LD_VAR 0 2
64438: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64439: LD_INT 0
64441: PPUSH
64442: PPUSH
64443: PPUSH
// if not mc_bases or not skirmish then
64444: LD_EXP 97
64448: NOT
64449: PUSH
64450: LD_EXP 95
64454: NOT
64455: OR
64456: IFFALSE 64460
// exit ;
64458: GO 64675
// for i = 1 to mc_bases do
64460: LD_ADDR_VAR 0 3
64464: PUSH
64465: DOUBLE
64466: LD_INT 1
64468: DEC
64469: ST_TO_ADDR
64470: LD_EXP 97
64474: PUSH
64475: FOR_TO
64476: IFFALSE 64673
// begin if building in mc_construct_list [ i ] then
64478: LD_VAR 0 1
64482: PUSH
64483: LD_EXP 104
64487: PUSH
64488: LD_VAR 0 3
64492: ARRAY
64493: IN
64494: IFFALSE 64671
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64496: LD_ADDR_EXP 104
64500: PUSH
64501: LD_EXP 104
64505: PPUSH
64506: LD_VAR 0 3
64510: PPUSH
64511: LD_EXP 104
64515: PUSH
64516: LD_VAR 0 3
64520: ARRAY
64521: PUSH
64522: LD_VAR 0 1
64526: DIFF
64527: PPUSH
64528: CALL_OW 1
64532: ST_TO_ADDR
// if building in mc_lab [ i ] then
64533: LD_VAR 0 1
64537: PUSH
64538: LD_EXP 130
64542: PUSH
64543: LD_VAR 0 3
64547: ARRAY
64548: IN
64549: IFFALSE 64604
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64551: LD_ADDR_EXP 131
64555: PUSH
64556: LD_EXP 131
64560: PPUSH
64561: LD_VAR 0 3
64565: PPUSH
64566: LD_EXP 131
64570: PUSH
64571: LD_VAR 0 3
64575: ARRAY
64576: PPUSH
64577: LD_INT 1
64579: PPUSH
64580: LD_EXP 131
64584: PUSH
64585: LD_VAR 0 3
64589: ARRAY
64590: PPUSH
64591: LD_INT 0
64593: PPUSH
64594: CALL 70578 0 4
64598: PPUSH
64599: CALL_OW 1
64603: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64604: LD_VAR 0 1
64608: PUSH
64609: LD_EXP 97
64613: PUSH
64614: LD_VAR 0 3
64618: ARRAY
64619: IN
64620: NOT
64621: IFFALSE 64667
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64623: LD_ADDR_EXP 97
64627: PUSH
64628: LD_EXP 97
64632: PPUSH
64633: LD_VAR 0 3
64637: PUSH
64638: LD_EXP 97
64642: PUSH
64643: LD_VAR 0 3
64647: ARRAY
64648: PUSH
64649: LD_INT 1
64651: PLUS
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: PPUSH
64657: LD_VAR 0 1
64661: PPUSH
64662: CALL 71160 0 3
64666: ST_TO_ADDR
// exit ;
64667: POP
64668: POP
64669: GO 64675
// end ; end ;
64671: GO 64475
64673: POP
64674: POP
// end ;
64675: LD_VAR 0 2
64679: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64680: LD_INT 0
64682: PPUSH
64683: PPUSH
64684: PPUSH
64685: PPUSH
64686: PPUSH
64687: PPUSH
64688: PPUSH
// if not mc_bases or not skirmish then
64689: LD_EXP 97
64693: NOT
64694: PUSH
64695: LD_EXP 95
64699: NOT
64700: OR
64701: IFFALSE 64705
// exit ;
64703: GO 65366
// for i = 1 to mc_bases do
64705: LD_ADDR_VAR 0 3
64709: PUSH
64710: DOUBLE
64711: LD_INT 1
64713: DEC
64714: ST_TO_ADDR
64715: LD_EXP 97
64719: PUSH
64720: FOR_TO
64721: IFFALSE 65364
// begin if building in mc_construct_list [ i ] then
64723: LD_VAR 0 1
64727: PUSH
64728: LD_EXP 104
64732: PUSH
64733: LD_VAR 0 3
64737: ARRAY
64738: IN
64739: IFFALSE 65362
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64741: LD_ADDR_EXP 104
64745: PUSH
64746: LD_EXP 104
64750: PPUSH
64751: LD_VAR 0 3
64755: PPUSH
64756: LD_EXP 104
64760: PUSH
64761: LD_VAR 0 3
64765: ARRAY
64766: PUSH
64767: LD_VAR 0 1
64771: DIFF
64772: PPUSH
64773: CALL_OW 1
64777: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64778: LD_ADDR_EXP 97
64782: PUSH
64783: LD_EXP 97
64787: PPUSH
64788: LD_VAR 0 3
64792: PUSH
64793: LD_EXP 97
64797: PUSH
64798: LD_VAR 0 3
64802: ARRAY
64803: PUSH
64804: LD_INT 1
64806: PLUS
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PPUSH
64812: LD_VAR 0 1
64816: PPUSH
64817: CALL 71160 0 3
64821: ST_TO_ADDR
// btype := GetBType ( building ) ;
64822: LD_ADDR_VAR 0 5
64826: PUSH
64827: LD_VAR 0 1
64831: PPUSH
64832: CALL_OW 266
64836: ST_TO_ADDR
// side := GetSide ( building ) ;
64837: LD_ADDR_VAR 0 8
64841: PUSH
64842: LD_VAR 0 1
64846: PPUSH
64847: CALL_OW 255
64851: ST_TO_ADDR
// if btype = b_lab then
64852: LD_VAR 0 5
64856: PUSH
64857: LD_INT 6
64859: EQUAL
64860: IFFALSE 64910
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64862: LD_ADDR_EXP 130
64866: PUSH
64867: LD_EXP 130
64871: PPUSH
64872: LD_VAR 0 3
64876: PUSH
64877: LD_EXP 130
64881: PUSH
64882: LD_VAR 0 3
64886: ARRAY
64887: PUSH
64888: LD_INT 1
64890: PLUS
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PPUSH
64896: LD_VAR 0 1
64900: PPUSH
64901: CALL 71160 0 3
64905: ST_TO_ADDR
// exit ;
64906: POP
64907: POP
64908: GO 65366
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64910: LD_VAR 0 5
64914: PUSH
64915: LD_INT 0
64917: PUSH
64918: LD_INT 2
64920: PUSH
64921: LD_INT 4
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: LIST
64928: IN
64929: IFFALSE 65053
// begin if btype = b_armoury then
64931: LD_VAR 0 5
64935: PUSH
64936: LD_INT 4
64938: EQUAL
64939: IFFALSE 64949
// btype := b_barracks ;
64941: LD_ADDR_VAR 0 5
64945: PUSH
64946: LD_INT 5
64948: ST_TO_ADDR
// if btype = b_depot then
64949: LD_VAR 0 5
64953: PUSH
64954: LD_INT 0
64956: EQUAL
64957: IFFALSE 64967
// btype := b_warehouse ;
64959: LD_ADDR_VAR 0 5
64963: PUSH
64964: LD_INT 1
64966: ST_TO_ADDR
// if btype = b_workshop then
64967: LD_VAR 0 5
64971: PUSH
64972: LD_INT 2
64974: EQUAL
64975: IFFALSE 64985
// btype := b_factory ;
64977: LD_ADDR_VAR 0 5
64981: PUSH
64982: LD_INT 3
64984: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64985: LD_VAR 0 5
64989: PPUSH
64990: LD_VAR 0 8
64994: PPUSH
64995: CALL_OW 323
64999: PUSH
65000: LD_INT 1
65002: EQUAL
65003: IFFALSE 65049
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
65005: LD_ADDR_EXP 129
65009: PUSH
65010: LD_EXP 129
65014: PPUSH
65015: LD_VAR 0 3
65019: PUSH
65020: LD_EXP 129
65024: PUSH
65025: LD_VAR 0 3
65029: ARRAY
65030: PUSH
65031: LD_INT 1
65033: PLUS
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PPUSH
65039: LD_VAR 0 1
65043: PPUSH
65044: CALL 71160 0 3
65048: ST_TO_ADDR
// exit ;
65049: POP
65050: POP
65051: GO 65366
// end ; if btype in [ b_bunker , b_turret ] then
65053: LD_VAR 0 5
65057: PUSH
65058: LD_INT 32
65060: PUSH
65061: LD_INT 33
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: IN
65068: IFFALSE 65358
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
65070: LD_ADDR_EXP 105
65074: PUSH
65075: LD_EXP 105
65079: PPUSH
65080: LD_VAR 0 3
65084: PUSH
65085: LD_EXP 105
65089: PUSH
65090: LD_VAR 0 3
65094: ARRAY
65095: PUSH
65096: LD_INT 1
65098: PLUS
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PPUSH
65104: LD_VAR 0 1
65108: PPUSH
65109: CALL 71160 0 3
65113: ST_TO_ADDR
// if btype = b_bunker then
65114: LD_VAR 0 5
65118: PUSH
65119: LD_INT 32
65121: EQUAL
65122: IFFALSE 65358
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65124: LD_ADDR_EXP 106
65128: PUSH
65129: LD_EXP 106
65133: PPUSH
65134: LD_VAR 0 3
65138: PUSH
65139: LD_EXP 106
65143: PUSH
65144: LD_VAR 0 3
65148: ARRAY
65149: PUSH
65150: LD_INT 1
65152: PLUS
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PPUSH
65158: LD_VAR 0 1
65162: PPUSH
65163: CALL 71160 0 3
65167: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65168: LD_ADDR_VAR 0 6
65172: PUSH
65173: LD_EXP 97
65177: PUSH
65178: LD_VAR 0 3
65182: ARRAY
65183: PPUSH
65184: LD_INT 25
65186: PUSH
65187: LD_INT 1
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: LD_INT 3
65196: PUSH
65197: LD_INT 54
65199: PUSH
65200: EMPTY
65201: LIST
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: EMPTY
65208: LIST
65209: LIST
65210: PPUSH
65211: CALL_OW 72
65215: ST_TO_ADDR
// if tmp then
65216: LD_VAR 0 6
65220: IFFALSE 65226
// exit ;
65222: POP
65223: POP
65224: GO 65366
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65226: LD_ADDR_VAR 0 6
65230: PUSH
65231: LD_EXP 97
65235: PUSH
65236: LD_VAR 0 3
65240: ARRAY
65241: PPUSH
65242: LD_INT 2
65244: PUSH
65245: LD_INT 30
65247: PUSH
65248: LD_INT 4
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: LD_INT 30
65257: PUSH
65258: LD_INT 5
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: LIST
65269: PPUSH
65270: CALL_OW 72
65274: ST_TO_ADDR
// if not tmp then
65275: LD_VAR 0 6
65279: NOT
65280: IFFALSE 65286
// exit ;
65282: POP
65283: POP
65284: GO 65366
// for j in tmp do
65286: LD_ADDR_VAR 0 4
65290: PUSH
65291: LD_VAR 0 6
65295: PUSH
65296: FOR_IN
65297: IFFALSE 65356
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65299: LD_ADDR_VAR 0 7
65303: PUSH
65304: LD_VAR 0 4
65308: PPUSH
65309: CALL_OW 313
65313: PPUSH
65314: LD_INT 25
65316: PUSH
65317: LD_INT 1
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PPUSH
65324: CALL_OW 72
65328: ST_TO_ADDR
// if units then
65329: LD_VAR 0 7
65333: IFFALSE 65354
// begin ComExitBuilding ( units [ 1 ] ) ;
65335: LD_VAR 0 7
65339: PUSH
65340: LD_INT 1
65342: ARRAY
65343: PPUSH
65344: CALL_OW 122
// exit ;
65348: POP
65349: POP
65350: POP
65351: POP
65352: GO 65366
// end ; end ;
65354: GO 65296
65356: POP
65357: POP
// end ; end ; exit ;
65358: POP
65359: POP
65360: GO 65366
// end ; end ;
65362: GO 64720
65364: POP
65365: POP
// end ;
65366: LD_VAR 0 2
65370: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65371: LD_INT 0
65373: PPUSH
65374: PPUSH
65375: PPUSH
65376: PPUSH
65377: PPUSH
65378: PPUSH
65379: PPUSH
// if not mc_bases or not skirmish then
65380: LD_EXP 97
65384: NOT
65385: PUSH
65386: LD_EXP 95
65390: NOT
65391: OR
65392: IFFALSE 65396
// exit ;
65394: GO 65661
// btype := GetBType ( building ) ;
65396: LD_ADDR_VAR 0 6
65400: PUSH
65401: LD_VAR 0 1
65405: PPUSH
65406: CALL_OW 266
65410: ST_TO_ADDR
// x := GetX ( building ) ;
65411: LD_ADDR_VAR 0 7
65415: PUSH
65416: LD_VAR 0 1
65420: PPUSH
65421: CALL_OW 250
65425: ST_TO_ADDR
// y := GetY ( building ) ;
65426: LD_ADDR_VAR 0 8
65430: PUSH
65431: LD_VAR 0 1
65435: PPUSH
65436: CALL_OW 251
65440: ST_TO_ADDR
// d := GetDir ( building ) ;
65441: LD_ADDR_VAR 0 9
65445: PUSH
65446: LD_VAR 0 1
65450: PPUSH
65451: CALL_OW 254
65455: ST_TO_ADDR
// for i = 1 to mc_bases do
65456: LD_ADDR_VAR 0 4
65460: PUSH
65461: DOUBLE
65462: LD_INT 1
65464: DEC
65465: ST_TO_ADDR
65466: LD_EXP 97
65470: PUSH
65471: FOR_TO
65472: IFFALSE 65659
// begin if not mc_build_list [ i ] then
65474: LD_EXP 102
65478: PUSH
65479: LD_VAR 0 4
65483: ARRAY
65484: NOT
65485: IFFALSE 65489
// continue ;
65487: GO 65471
// for j := 1 to mc_build_list [ i ] do
65489: LD_ADDR_VAR 0 5
65493: PUSH
65494: DOUBLE
65495: LD_INT 1
65497: DEC
65498: ST_TO_ADDR
65499: LD_EXP 102
65503: PUSH
65504: LD_VAR 0 4
65508: ARRAY
65509: PUSH
65510: FOR_TO
65511: IFFALSE 65655
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65513: LD_VAR 0 6
65517: PUSH
65518: LD_VAR 0 7
65522: PUSH
65523: LD_VAR 0 8
65527: PUSH
65528: LD_VAR 0 9
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: PPUSH
65539: LD_EXP 102
65543: PUSH
65544: LD_VAR 0 4
65548: ARRAY
65549: PUSH
65550: LD_VAR 0 5
65554: ARRAY
65555: PPUSH
65556: CALL 77340 0 2
65560: IFFALSE 65653
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65562: LD_ADDR_EXP 102
65566: PUSH
65567: LD_EXP 102
65571: PPUSH
65572: LD_VAR 0 4
65576: PPUSH
65577: LD_EXP 102
65581: PUSH
65582: LD_VAR 0 4
65586: ARRAY
65587: PPUSH
65588: LD_VAR 0 5
65592: PPUSH
65593: CALL_OW 3
65597: PPUSH
65598: CALL_OW 1
65602: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65603: LD_ADDR_EXP 104
65607: PUSH
65608: LD_EXP 104
65612: PPUSH
65613: LD_VAR 0 4
65617: PUSH
65618: LD_EXP 104
65622: PUSH
65623: LD_VAR 0 4
65627: ARRAY
65628: PUSH
65629: LD_INT 1
65631: PLUS
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PPUSH
65637: LD_VAR 0 1
65641: PPUSH
65642: CALL 71160 0 3
65646: ST_TO_ADDR
// exit ;
65647: POP
65648: POP
65649: POP
65650: POP
65651: GO 65661
// end ;
65653: GO 65510
65655: POP
65656: POP
// end ;
65657: GO 65471
65659: POP
65660: POP
// end ;
65661: LD_VAR 0 3
65665: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65666: LD_INT 0
65668: PPUSH
65669: PPUSH
65670: PPUSH
// if not mc_bases or not skirmish then
65671: LD_EXP 97
65675: NOT
65676: PUSH
65677: LD_EXP 95
65681: NOT
65682: OR
65683: IFFALSE 65687
// exit ;
65685: GO 65877
// for i = 1 to mc_bases do
65687: LD_ADDR_VAR 0 4
65691: PUSH
65692: DOUBLE
65693: LD_INT 1
65695: DEC
65696: ST_TO_ADDR
65697: LD_EXP 97
65701: PUSH
65702: FOR_TO
65703: IFFALSE 65790
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65705: LD_VAR 0 1
65709: PUSH
65710: LD_EXP 105
65714: PUSH
65715: LD_VAR 0 4
65719: ARRAY
65720: IN
65721: PUSH
65722: LD_VAR 0 1
65726: PUSH
65727: LD_EXP 106
65731: PUSH
65732: LD_VAR 0 4
65736: ARRAY
65737: IN
65738: NOT
65739: AND
65740: IFFALSE 65788
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65742: LD_ADDR_EXP 106
65746: PUSH
65747: LD_EXP 106
65751: PPUSH
65752: LD_VAR 0 4
65756: PUSH
65757: LD_EXP 106
65761: PUSH
65762: LD_VAR 0 4
65766: ARRAY
65767: PUSH
65768: LD_INT 1
65770: PLUS
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PPUSH
65776: LD_VAR 0 1
65780: PPUSH
65781: CALL 71160 0 3
65785: ST_TO_ADDR
// break ;
65786: GO 65790
// end ; end ;
65788: GO 65702
65790: POP
65791: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65792: LD_VAR 0 1
65796: PPUSH
65797: CALL_OW 257
65801: PUSH
65802: LD_EXP 123
65806: IN
65807: PUSH
65808: LD_VAR 0 1
65812: PPUSH
65813: CALL_OW 266
65817: PUSH
65818: LD_INT 5
65820: EQUAL
65821: AND
65822: PUSH
65823: LD_VAR 0 2
65827: PPUSH
65828: CALL_OW 110
65832: PUSH
65833: LD_INT 18
65835: NONEQUAL
65836: AND
65837: IFFALSE 65877
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65839: LD_VAR 0 2
65843: PPUSH
65844: CALL_OW 257
65848: PUSH
65849: LD_INT 5
65851: PUSH
65852: LD_INT 8
65854: PUSH
65855: LD_INT 9
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: LIST
65862: IN
65863: IFFALSE 65877
// SetClass ( unit , 1 ) ;
65865: LD_VAR 0 2
65869: PPUSH
65870: LD_INT 1
65872: PPUSH
65873: CALL_OW 336
// end ;
65877: LD_VAR 0 3
65881: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65882: LD_INT 0
65884: PPUSH
65885: PPUSH
// if not mc_bases or not skirmish then
65886: LD_EXP 97
65890: NOT
65891: PUSH
65892: LD_EXP 95
65896: NOT
65897: OR
65898: IFFALSE 65902
// exit ;
65900: GO 66018
// if GetLives ( abandoned_vehicle ) > 250 then
65902: LD_VAR 0 2
65906: PPUSH
65907: CALL_OW 256
65911: PUSH
65912: LD_INT 250
65914: GREATER
65915: IFFALSE 65919
// exit ;
65917: GO 66018
// for i = 1 to mc_bases do
65919: LD_ADDR_VAR 0 6
65923: PUSH
65924: DOUBLE
65925: LD_INT 1
65927: DEC
65928: ST_TO_ADDR
65929: LD_EXP 97
65933: PUSH
65934: FOR_TO
65935: IFFALSE 66016
// begin if driver in mc_bases [ i ] then
65937: LD_VAR 0 1
65941: PUSH
65942: LD_EXP 97
65946: PUSH
65947: LD_VAR 0 6
65951: ARRAY
65952: IN
65953: IFFALSE 66014
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65955: LD_VAR 0 1
65959: PPUSH
65960: LD_EXP 97
65964: PUSH
65965: LD_VAR 0 6
65969: ARRAY
65970: PPUSH
65971: LD_INT 2
65973: PUSH
65974: LD_INT 30
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 30
65986: PUSH
65987: LD_INT 1
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: LIST
65998: PPUSH
65999: CALL_OW 72
66003: PUSH
66004: LD_INT 1
66006: ARRAY
66007: PPUSH
66008: CALL 104349 0 2
// break ;
66012: GO 66016
// end ; end ;
66014: GO 65934
66016: POP
66017: POP
// end ; end_of_file
66018: LD_VAR 0 5
66022: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
66023: LD_INT 0
66025: PPUSH
66026: PPUSH
// if exist_mode then
66027: LD_VAR 0 2
66031: IFFALSE 66056
// unit := CreateCharacter ( prefix & ident ) else
66033: LD_ADDR_VAR 0 5
66037: PUSH
66038: LD_VAR 0 3
66042: PUSH
66043: LD_VAR 0 1
66047: STR
66048: PPUSH
66049: CALL_OW 34
66053: ST_TO_ADDR
66054: GO 66071
// unit := NewCharacter ( ident ) ;
66056: LD_ADDR_VAR 0 5
66060: PUSH
66061: LD_VAR 0 1
66065: PPUSH
66066: CALL_OW 25
66070: ST_TO_ADDR
// result := unit ;
66071: LD_ADDR_VAR 0 4
66075: PUSH
66076: LD_VAR 0 5
66080: ST_TO_ADDR
// end ;
66081: LD_VAR 0 4
66085: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
66086: LD_INT 0
66088: PPUSH
66089: PPUSH
// if not side or not nation then
66090: LD_VAR 0 1
66094: NOT
66095: PUSH
66096: LD_VAR 0 2
66100: NOT
66101: OR
66102: IFFALSE 66106
// exit ;
66104: GO 66874
// case nation of nation_american :
66106: LD_VAR 0 2
66110: PUSH
66111: LD_INT 1
66113: DOUBLE
66114: EQUAL
66115: IFTRUE 66119
66117: GO 66333
66119: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
66120: LD_ADDR_VAR 0 4
66124: PUSH
66125: LD_INT 35
66127: PUSH
66128: LD_INT 45
66130: PUSH
66131: LD_INT 46
66133: PUSH
66134: LD_INT 47
66136: PUSH
66137: LD_INT 82
66139: PUSH
66140: LD_INT 83
66142: PUSH
66143: LD_INT 84
66145: PUSH
66146: LD_INT 85
66148: PUSH
66149: LD_INT 86
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: LD_INT 2
66157: PUSH
66158: LD_INT 6
66160: PUSH
66161: LD_INT 15
66163: PUSH
66164: LD_INT 16
66166: PUSH
66167: LD_INT 7
66169: PUSH
66170: LD_INT 12
66172: PUSH
66173: LD_INT 13
66175: PUSH
66176: LD_INT 10
66178: PUSH
66179: LD_INT 14
66181: PUSH
66182: LD_INT 20
66184: PUSH
66185: LD_INT 21
66187: PUSH
66188: LD_INT 22
66190: PUSH
66191: LD_INT 25
66193: PUSH
66194: LD_INT 32
66196: PUSH
66197: LD_INT 27
66199: PUSH
66200: LD_INT 36
66202: PUSH
66203: LD_INT 69
66205: PUSH
66206: LD_INT 39
66208: PUSH
66209: LD_INT 34
66211: PUSH
66212: LD_INT 40
66214: PUSH
66215: LD_INT 48
66217: PUSH
66218: LD_INT 49
66220: PUSH
66221: LD_INT 50
66223: PUSH
66224: LD_INT 51
66226: PUSH
66227: LD_INT 52
66229: PUSH
66230: LD_INT 53
66232: PUSH
66233: LD_INT 54
66235: PUSH
66236: LD_INT 55
66238: PUSH
66239: LD_INT 56
66241: PUSH
66242: LD_INT 57
66244: PUSH
66245: LD_INT 58
66247: PUSH
66248: LD_INT 59
66250: PUSH
66251: LD_INT 60
66253: PUSH
66254: LD_INT 61
66256: PUSH
66257: LD_INT 62
66259: PUSH
66260: LD_INT 80
66262: PUSH
66263: LD_INT 82
66265: PUSH
66266: LD_INT 83
66268: PUSH
66269: LD_INT 84
66271: PUSH
66272: LD_INT 85
66274: PUSH
66275: LD_INT 86
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: LIST
66329: LIST
66330: ST_TO_ADDR
66331: GO 66798
66333: LD_INT 2
66335: DOUBLE
66336: EQUAL
66337: IFTRUE 66341
66339: GO 66567
66341: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66342: LD_ADDR_VAR 0 4
66346: PUSH
66347: LD_INT 35
66349: PUSH
66350: LD_INT 45
66352: PUSH
66353: LD_INT 46
66355: PUSH
66356: LD_INT 47
66358: PUSH
66359: LD_INT 82
66361: PUSH
66362: LD_INT 83
66364: PUSH
66365: LD_INT 84
66367: PUSH
66368: LD_INT 85
66370: PUSH
66371: LD_INT 87
66373: PUSH
66374: LD_INT 70
66376: PUSH
66377: LD_INT 1
66379: PUSH
66380: LD_INT 11
66382: PUSH
66383: LD_INT 3
66385: PUSH
66386: LD_INT 4
66388: PUSH
66389: LD_INT 5
66391: PUSH
66392: LD_INT 6
66394: PUSH
66395: LD_INT 15
66397: PUSH
66398: LD_INT 18
66400: PUSH
66401: LD_INT 7
66403: PUSH
66404: LD_INT 17
66406: PUSH
66407: LD_INT 8
66409: PUSH
66410: LD_INT 20
66412: PUSH
66413: LD_INT 21
66415: PUSH
66416: LD_INT 22
66418: PUSH
66419: LD_INT 72
66421: PUSH
66422: LD_INT 26
66424: PUSH
66425: LD_INT 69
66427: PUSH
66428: LD_INT 39
66430: PUSH
66431: LD_INT 40
66433: PUSH
66434: LD_INT 41
66436: PUSH
66437: LD_INT 42
66439: PUSH
66440: LD_INT 43
66442: PUSH
66443: LD_INT 48
66445: PUSH
66446: LD_INT 49
66448: PUSH
66449: LD_INT 50
66451: PUSH
66452: LD_INT 51
66454: PUSH
66455: LD_INT 52
66457: PUSH
66458: LD_INT 53
66460: PUSH
66461: LD_INT 54
66463: PUSH
66464: LD_INT 55
66466: PUSH
66467: LD_INT 56
66469: PUSH
66470: LD_INT 60
66472: PUSH
66473: LD_INT 61
66475: PUSH
66476: LD_INT 62
66478: PUSH
66479: LD_INT 66
66481: PUSH
66482: LD_INT 67
66484: PUSH
66485: LD_INT 68
66487: PUSH
66488: LD_INT 81
66490: PUSH
66491: LD_INT 82
66493: PUSH
66494: LD_INT 83
66496: PUSH
66497: LD_INT 84
66499: PUSH
66500: LD_INT 85
66502: PUSH
66503: LD_INT 87
66505: PUSH
66506: LD_INT 88
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: ST_TO_ADDR
66565: GO 66798
66567: LD_INT 3
66569: DOUBLE
66570: EQUAL
66571: IFTRUE 66575
66573: GO 66797
66575: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66576: LD_ADDR_VAR 0 4
66580: PUSH
66581: LD_INT 46
66583: PUSH
66584: LD_INT 47
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: LD_INT 2
66592: PUSH
66593: LD_INT 82
66595: PUSH
66596: LD_INT 83
66598: PUSH
66599: LD_INT 84
66601: PUSH
66602: LD_INT 85
66604: PUSH
66605: LD_INT 86
66607: PUSH
66608: LD_INT 11
66610: PUSH
66611: LD_INT 9
66613: PUSH
66614: LD_INT 20
66616: PUSH
66617: LD_INT 19
66619: PUSH
66620: LD_INT 21
66622: PUSH
66623: LD_INT 24
66625: PUSH
66626: LD_INT 22
66628: PUSH
66629: LD_INT 25
66631: PUSH
66632: LD_INT 28
66634: PUSH
66635: LD_INT 29
66637: PUSH
66638: LD_INT 30
66640: PUSH
66641: LD_INT 31
66643: PUSH
66644: LD_INT 37
66646: PUSH
66647: LD_INT 38
66649: PUSH
66650: LD_INT 32
66652: PUSH
66653: LD_INT 27
66655: PUSH
66656: LD_INT 33
66658: PUSH
66659: LD_INT 69
66661: PUSH
66662: LD_INT 39
66664: PUSH
66665: LD_INT 34
66667: PUSH
66668: LD_INT 40
66670: PUSH
66671: LD_INT 71
66673: PUSH
66674: LD_INT 23
66676: PUSH
66677: LD_INT 44
66679: PUSH
66680: LD_INT 48
66682: PUSH
66683: LD_INT 49
66685: PUSH
66686: LD_INT 50
66688: PUSH
66689: LD_INT 51
66691: PUSH
66692: LD_INT 52
66694: PUSH
66695: LD_INT 53
66697: PUSH
66698: LD_INT 54
66700: PUSH
66701: LD_INT 55
66703: PUSH
66704: LD_INT 56
66706: PUSH
66707: LD_INT 57
66709: PUSH
66710: LD_INT 58
66712: PUSH
66713: LD_INT 59
66715: PUSH
66716: LD_INT 63
66718: PUSH
66719: LD_INT 64
66721: PUSH
66722: LD_INT 65
66724: PUSH
66725: LD_INT 82
66727: PUSH
66728: LD_INT 83
66730: PUSH
66731: LD_INT 84
66733: PUSH
66734: LD_INT 85
66736: PUSH
66737: LD_INT 86
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: ST_TO_ADDR
66795: GO 66798
66797: POP
// if state > - 1 and state < 3 then
66798: LD_VAR 0 3
66802: PUSH
66803: LD_INT 1
66805: NEG
66806: GREATER
66807: PUSH
66808: LD_VAR 0 3
66812: PUSH
66813: LD_INT 3
66815: LESS
66816: AND
66817: IFFALSE 66874
// for i in result do
66819: LD_ADDR_VAR 0 5
66823: PUSH
66824: LD_VAR 0 4
66828: PUSH
66829: FOR_IN
66830: IFFALSE 66872
// if GetTech ( i , side ) <> state then
66832: LD_VAR 0 5
66836: PPUSH
66837: LD_VAR 0 1
66841: PPUSH
66842: CALL_OW 321
66846: PUSH
66847: LD_VAR 0 3
66851: NONEQUAL
66852: IFFALSE 66870
// result := result diff i ;
66854: LD_ADDR_VAR 0 4
66858: PUSH
66859: LD_VAR 0 4
66863: PUSH
66864: LD_VAR 0 5
66868: DIFF
66869: ST_TO_ADDR
66870: GO 66829
66872: POP
66873: POP
// end ;
66874: LD_VAR 0 4
66878: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66879: LD_INT 0
66881: PPUSH
66882: PPUSH
66883: PPUSH
// result := true ;
66884: LD_ADDR_VAR 0 3
66888: PUSH
66889: LD_INT 1
66891: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66892: LD_ADDR_VAR 0 5
66896: PUSH
66897: LD_VAR 0 2
66901: PPUSH
66902: CALL_OW 480
66906: ST_TO_ADDR
// if not tmp then
66907: LD_VAR 0 5
66911: NOT
66912: IFFALSE 66916
// exit ;
66914: GO 66965
// for i in tmp do
66916: LD_ADDR_VAR 0 4
66920: PUSH
66921: LD_VAR 0 5
66925: PUSH
66926: FOR_IN
66927: IFFALSE 66963
// if GetTech ( i , side ) <> state_researched then
66929: LD_VAR 0 4
66933: PPUSH
66934: LD_VAR 0 1
66938: PPUSH
66939: CALL_OW 321
66943: PUSH
66944: LD_INT 2
66946: NONEQUAL
66947: IFFALSE 66961
// begin result := false ;
66949: LD_ADDR_VAR 0 3
66953: PUSH
66954: LD_INT 0
66956: ST_TO_ADDR
// exit ;
66957: POP
66958: POP
66959: GO 66965
// end ;
66961: GO 66926
66963: POP
66964: POP
// end ;
66965: LD_VAR 0 3
66969: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66970: LD_INT 0
66972: PPUSH
66973: PPUSH
66974: PPUSH
66975: PPUSH
66976: PPUSH
66977: PPUSH
66978: PPUSH
66979: PPUSH
66980: PPUSH
66981: PPUSH
66982: PPUSH
66983: PPUSH
66984: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66985: LD_VAR 0 1
66989: NOT
66990: PUSH
66991: LD_VAR 0 1
66995: PPUSH
66996: CALL_OW 257
67000: PUSH
67001: LD_INT 9
67003: NONEQUAL
67004: OR
67005: IFFALSE 67009
// exit ;
67007: GO 67582
// side := GetSide ( unit ) ;
67009: LD_ADDR_VAR 0 9
67013: PUSH
67014: LD_VAR 0 1
67018: PPUSH
67019: CALL_OW 255
67023: ST_TO_ADDR
// tech_space := tech_spacanom ;
67024: LD_ADDR_VAR 0 12
67028: PUSH
67029: LD_INT 29
67031: ST_TO_ADDR
// tech_time := tech_taurad ;
67032: LD_ADDR_VAR 0 13
67036: PUSH
67037: LD_INT 28
67039: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
67040: LD_ADDR_VAR 0 11
67044: PUSH
67045: LD_VAR 0 1
67049: PPUSH
67050: CALL_OW 310
67054: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
67055: LD_VAR 0 11
67059: PPUSH
67060: CALL_OW 247
67064: PUSH
67065: LD_INT 2
67067: EQUAL
67068: IFFALSE 67072
// exit ;
67070: GO 67582
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67072: LD_ADDR_VAR 0 8
67076: PUSH
67077: LD_INT 81
67079: PUSH
67080: LD_VAR 0 9
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 3
67091: PUSH
67092: LD_INT 21
67094: PUSH
67095: LD_INT 3
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PPUSH
67110: CALL_OW 69
67114: ST_TO_ADDR
// if not tmp then
67115: LD_VAR 0 8
67119: NOT
67120: IFFALSE 67124
// exit ;
67122: GO 67582
// if in_unit then
67124: LD_VAR 0 11
67128: IFFALSE 67152
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
67130: LD_ADDR_VAR 0 10
67134: PUSH
67135: LD_VAR 0 8
67139: PPUSH
67140: LD_VAR 0 11
67144: PPUSH
67145: CALL_OW 74
67149: ST_TO_ADDR
67150: GO 67172
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67152: LD_ADDR_VAR 0 10
67156: PUSH
67157: LD_VAR 0 8
67161: PPUSH
67162: LD_VAR 0 1
67166: PPUSH
67167: CALL_OW 74
67171: ST_TO_ADDR
// if not enemy then
67172: LD_VAR 0 10
67176: NOT
67177: IFFALSE 67181
// exit ;
67179: GO 67582
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67181: LD_VAR 0 11
67185: PUSH
67186: LD_VAR 0 11
67190: PPUSH
67191: LD_VAR 0 10
67195: PPUSH
67196: CALL_OW 296
67200: PUSH
67201: LD_INT 13
67203: GREATER
67204: AND
67205: PUSH
67206: LD_VAR 0 1
67210: PPUSH
67211: LD_VAR 0 10
67215: PPUSH
67216: CALL_OW 296
67220: PUSH
67221: LD_INT 12
67223: GREATER
67224: OR
67225: IFFALSE 67229
// exit ;
67227: GO 67582
// missile := [ 1 ] ;
67229: LD_ADDR_VAR 0 14
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: EMPTY
67238: LIST
67239: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67240: LD_VAR 0 9
67244: PPUSH
67245: LD_VAR 0 12
67249: PPUSH
67250: CALL_OW 325
67254: IFFALSE 67283
// missile := Replace ( missile , missile + 1 , 2 ) ;
67256: LD_ADDR_VAR 0 14
67260: PUSH
67261: LD_VAR 0 14
67265: PPUSH
67266: LD_VAR 0 14
67270: PUSH
67271: LD_INT 1
67273: PLUS
67274: PPUSH
67275: LD_INT 2
67277: PPUSH
67278: CALL_OW 1
67282: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67283: LD_VAR 0 9
67287: PPUSH
67288: LD_VAR 0 13
67292: PPUSH
67293: CALL_OW 325
67297: PUSH
67298: LD_VAR 0 10
67302: PPUSH
67303: CALL_OW 255
67307: PPUSH
67308: LD_VAR 0 13
67312: PPUSH
67313: CALL_OW 325
67317: NOT
67318: AND
67319: IFFALSE 67348
// missile := Replace ( missile , missile + 1 , 3 ) ;
67321: LD_ADDR_VAR 0 14
67325: PUSH
67326: LD_VAR 0 14
67330: PPUSH
67331: LD_VAR 0 14
67335: PUSH
67336: LD_INT 1
67338: PLUS
67339: PPUSH
67340: LD_INT 3
67342: PPUSH
67343: CALL_OW 1
67347: ST_TO_ADDR
// if missile < 2 then
67348: LD_VAR 0 14
67352: PUSH
67353: LD_INT 2
67355: LESS
67356: IFFALSE 67360
// exit ;
67358: GO 67582
// x := GetX ( enemy ) ;
67360: LD_ADDR_VAR 0 4
67364: PUSH
67365: LD_VAR 0 10
67369: PPUSH
67370: CALL_OW 250
67374: ST_TO_ADDR
// y := GetY ( enemy ) ;
67375: LD_ADDR_VAR 0 5
67379: PUSH
67380: LD_VAR 0 10
67384: PPUSH
67385: CALL_OW 251
67389: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67390: LD_ADDR_VAR 0 6
67394: PUSH
67395: LD_VAR 0 4
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PPUSH
67404: LD_INT 1
67406: PPUSH
67407: CALL_OW 12
67411: PLUS
67412: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67413: LD_ADDR_VAR 0 7
67417: PUSH
67418: LD_VAR 0 5
67422: PUSH
67423: LD_INT 1
67425: NEG
67426: PPUSH
67427: LD_INT 1
67429: PPUSH
67430: CALL_OW 12
67434: PLUS
67435: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67436: LD_VAR 0 6
67440: PPUSH
67441: LD_VAR 0 7
67445: PPUSH
67446: CALL_OW 488
67450: NOT
67451: IFFALSE 67473
// begin _x := x ;
67453: LD_ADDR_VAR 0 6
67457: PUSH
67458: LD_VAR 0 4
67462: ST_TO_ADDR
// _y := y ;
67463: LD_ADDR_VAR 0 7
67467: PUSH
67468: LD_VAR 0 5
67472: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67473: LD_ADDR_VAR 0 3
67477: PUSH
67478: LD_INT 1
67480: PPUSH
67481: LD_VAR 0 14
67485: PPUSH
67486: CALL_OW 12
67490: ST_TO_ADDR
// case i of 1 :
67491: LD_VAR 0 3
67495: PUSH
67496: LD_INT 1
67498: DOUBLE
67499: EQUAL
67500: IFTRUE 67504
67502: GO 67521
67504: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67505: LD_VAR 0 1
67509: PPUSH
67510: LD_VAR 0 10
67514: PPUSH
67515: CALL_OW 115
67519: GO 67582
67521: LD_INT 2
67523: DOUBLE
67524: EQUAL
67525: IFTRUE 67529
67527: GO 67551
67529: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67530: LD_VAR 0 1
67534: PPUSH
67535: LD_VAR 0 6
67539: PPUSH
67540: LD_VAR 0 7
67544: PPUSH
67545: CALL_OW 153
67549: GO 67582
67551: LD_INT 3
67553: DOUBLE
67554: EQUAL
67555: IFTRUE 67559
67557: GO 67581
67559: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67560: LD_VAR 0 1
67564: PPUSH
67565: LD_VAR 0 6
67569: PPUSH
67570: LD_VAR 0 7
67574: PPUSH
67575: CALL_OW 154
67579: GO 67582
67581: POP
// end ;
67582: LD_VAR 0 2
67586: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67587: LD_INT 0
67589: PPUSH
67590: PPUSH
67591: PPUSH
67592: PPUSH
67593: PPUSH
67594: PPUSH
// if not unit or not building then
67595: LD_VAR 0 1
67599: NOT
67600: PUSH
67601: LD_VAR 0 2
67605: NOT
67606: OR
67607: IFFALSE 67611
// exit ;
67609: GO 67769
// x := GetX ( building ) ;
67611: LD_ADDR_VAR 0 5
67615: PUSH
67616: LD_VAR 0 2
67620: PPUSH
67621: CALL_OW 250
67625: ST_TO_ADDR
// y := GetY ( building ) ;
67626: LD_ADDR_VAR 0 6
67630: PUSH
67631: LD_VAR 0 2
67635: PPUSH
67636: CALL_OW 251
67640: ST_TO_ADDR
// for i = 0 to 5 do
67641: LD_ADDR_VAR 0 4
67645: PUSH
67646: DOUBLE
67647: LD_INT 0
67649: DEC
67650: ST_TO_ADDR
67651: LD_INT 5
67653: PUSH
67654: FOR_TO
67655: IFFALSE 67767
// begin _x := ShiftX ( x , i , 3 ) ;
67657: LD_ADDR_VAR 0 7
67661: PUSH
67662: LD_VAR 0 5
67666: PPUSH
67667: LD_VAR 0 4
67671: PPUSH
67672: LD_INT 3
67674: PPUSH
67675: CALL_OW 272
67679: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67680: LD_ADDR_VAR 0 8
67684: PUSH
67685: LD_VAR 0 6
67689: PPUSH
67690: LD_VAR 0 4
67694: PPUSH
67695: LD_INT 3
67697: PPUSH
67698: CALL_OW 273
67702: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67703: LD_VAR 0 7
67707: PPUSH
67708: LD_VAR 0 8
67712: PPUSH
67713: CALL_OW 488
67717: NOT
67718: IFFALSE 67722
// continue ;
67720: GO 67654
// if HexInfo ( _x , _y ) = 0 then
67722: LD_VAR 0 7
67726: PPUSH
67727: LD_VAR 0 8
67731: PPUSH
67732: CALL_OW 428
67736: PUSH
67737: LD_INT 0
67739: EQUAL
67740: IFFALSE 67765
// begin ComMoveXY ( unit , _x , _y ) ;
67742: LD_VAR 0 1
67746: PPUSH
67747: LD_VAR 0 7
67751: PPUSH
67752: LD_VAR 0 8
67756: PPUSH
67757: CALL_OW 111
// exit ;
67761: POP
67762: POP
67763: GO 67769
// end ; end ;
67765: GO 67654
67767: POP
67768: POP
// end ;
67769: LD_VAR 0 3
67773: RET
// export function ScanBase ( side , base_area ) ; begin
67774: LD_INT 0
67776: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67777: LD_ADDR_VAR 0 3
67781: PUSH
67782: LD_VAR 0 2
67786: PPUSH
67787: LD_INT 81
67789: PUSH
67790: LD_VAR 0 1
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PPUSH
67799: CALL_OW 70
67803: ST_TO_ADDR
// end ;
67804: LD_VAR 0 3
67808: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67809: LD_INT 0
67811: PPUSH
67812: PPUSH
67813: PPUSH
67814: PPUSH
// result := false ;
67815: LD_ADDR_VAR 0 2
67819: PUSH
67820: LD_INT 0
67822: ST_TO_ADDR
// side := GetSide ( unit ) ;
67823: LD_ADDR_VAR 0 3
67827: PUSH
67828: LD_VAR 0 1
67832: PPUSH
67833: CALL_OW 255
67837: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67838: LD_ADDR_VAR 0 4
67842: PUSH
67843: LD_VAR 0 1
67847: PPUSH
67848: CALL_OW 248
67852: ST_TO_ADDR
// case nat of 1 :
67853: LD_VAR 0 4
67857: PUSH
67858: LD_INT 1
67860: DOUBLE
67861: EQUAL
67862: IFTRUE 67866
67864: GO 67877
67866: POP
// tech := tech_lassight ; 2 :
67867: LD_ADDR_VAR 0 5
67871: PUSH
67872: LD_INT 12
67874: ST_TO_ADDR
67875: GO 67916
67877: LD_INT 2
67879: DOUBLE
67880: EQUAL
67881: IFTRUE 67885
67883: GO 67896
67885: POP
// tech := tech_mortar ; 3 :
67886: LD_ADDR_VAR 0 5
67890: PUSH
67891: LD_INT 41
67893: ST_TO_ADDR
67894: GO 67916
67896: LD_INT 3
67898: DOUBLE
67899: EQUAL
67900: IFTRUE 67904
67902: GO 67915
67904: POP
// tech := tech_bazooka ; end ;
67905: LD_ADDR_VAR 0 5
67909: PUSH
67910: LD_INT 44
67912: ST_TO_ADDR
67913: GO 67916
67915: POP
// if Researched ( side , tech ) then
67916: LD_VAR 0 3
67920: PPUSH
67921: LD_VAR 0 5
67925: PPUSH
67926: CALL_OW 325
67930: IFFALSE 67957
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67932: LD_ADDR_VAR 0 2
67936: PUSH
67937: LD_INT 5
67939: PUSH
67940: LD_INT 8
67942: PUSH
67943: LD_INT 9
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: LIST
67950: PUSH
67951: LD_VAR 0 4
67955: ARRAY
67956: ST_TO_ADDR
// end ;
67957: LD_VAR 0 2
67961: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67962: LD_INT 0
67964: PPUSH
67965: PPUSH
67966: PPUSH
// if not mines then
67967: LD_VAR 0 2
67971: NOT
67972: IFFALSE 67976
// exit ;
67974: GO 68120
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67976: LD_ADDR_VAR 0 5
67980: PUSH
67981: LD_INT 81
67983: PUSH
67984: LD_VAR 0 1
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 3
67995: PUSH
67996: LD_INT 21
67998: PUSH
67999: LD_INT 3
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PPUSH
68014: CALL_OW 69
68018: ST_TO_ADDR
// for i in mines do
68019: LD_ADDR_VAR 0 4
68023: PUSH
68024: LD_VAR 0 2
68028: PUSH
68029: FOR_IN
68030: IFFALSE 68118
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68032: LD_VAR 0 4
68036: PUSH
68037: LD_INT 1
68039: ARRAY
68040: PPUSH
68041: LD_VAR 0 4
68045: PUSH
68046: LD_INT 2
68048: ARRAY
68049: PPUSH
68050: CALL_OW 458
68054: NOT
68055: IFFALSE 68059
// continue ;
68057: GO 68029
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68059: LD_VAR 0 4
68063: PUSH
68064: LD_INT 1
68066: ARRAY
68067: PPUSH
68068: LD_VAR 0 4
68072: PUSH
68073: LD_INT 2
68075: ARRAY
68076: PPUSH
68077: CALL_OW 428
68081: PUSH
68082: LD_VAR 0 5
68086: IN
68087: IFFALSE 68116
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68089: LD_VAR 0 4
68093: PUSH
68094: LD_INT 1
68096: ARRAY
68097: PPUSH
68098: LD_VAR 0 4
68102: PUSH
68103: LD_INT 2
68105: ARRAY
68106: PPUSH
68107: LD_VAR 0 1
68111: PPUSH
68112: CALL_OW 456
// end ;
68116: GO 68029
68118: POP
68119: POP
// end ;
68120: LD_VAR 0 3
68124: RET
// export function Count ( array ) ; var i ; begin
68125: LD_INT 0
68127: PPUSH
68128: PPUSH
// result := 0 ;
68129: LD_ADDR_VAR 0 2
68133: PUSH
68134: LD_INT 0
68136: ST_TO_ADDR
// for i in array do
68137: LD_ADDR_VAR 0 3
68141: PUSH
68142: LD_VAR 0 1
68146: PUSH
68147: FOR_IN
68148: IFFALSE 68172
// if i then
68150: LD_VAR 0 3
68154: IFFALSE 68170
// result := result + 1 ;
68156: LD_ADDR_VAR 0 2
68160: PUSH
68161: LD_VAR 0 2
68165: PUSH
68166: LD_INT 1
68168: PLUS
68169: ST_TO_ADDR
68170: GO 68147
68172: POP
68173: POP
// end ;
68174: LD_VAR 0 2
68178: RET
// export function IsEmpty ( building ) ; begin
68179: LD_INT 0
68181: PPUSH
// if not building then
68182: LD_VAR 0 1
68186: NOT
68187: IFFALSE 68191
// exit ;
68189: GO 68234
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68191: LD_ADDR_VAR 0 2
68195: PUSH
68196: LD_VAR 0 1
68200: PUSH
68201: LD_INT 22
68203: PUSH
68204: LD_VAR 0 1
68208: PPUSH
68209: CALL_OW 255
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 58
68220: PUSH
68221: EMPTY
68222: LIST
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PPUSH
68228: CALL_OW 69
68232: IN
68233: ST_TO_ADDR
// end ;
68234: LD_VAR 0 2
68238: RET
// export function IsNotFull ( building ) ; var places ; begin
68239: LD_INT 0
68241: PPUSH
68242: PPUSH
// if not building then
68243: LD_VAR 0 1
68247: NOT
68248: IFFALSE 68252
// exit ;
68250: GO 68423
// result := false ;
68252: LD_ADDR_VAR 0 2
68256: PUSH
68257: LD_INT 0
68259: ST_TO_ADDR
// places := 0 ;
68260: LD_ADDR_VAR 0 3
68264: PUSH
68265: LD_INT 0
68267: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
68268: LD_VAR 0 1
68272: PPUSH
68273: CALL_OW 266
68277: PUSH
68278: LD_INT 0
68280: DOUBLE
68281: EQUAL
68282: IFTRUE 68340
68284: LD_INT 1
68286: DOUBLE
68287: EQUAL
68288: IFTRUE 68340
68290: LD_INT 6
68292: DOUBLE
68293: EQUAL
68294: IFTRUE 68340
68296: LD_INT 7
68298: DOUBLE
68299: EQUAL
68300: IFTRUE 68340
68302: LD_INT 8
68304: DOUBLE
68305: EQUAL
68306: IFTRUE 68340
68308: LD_INT 4
68310: DOUBLE
68311: EQUAL
68312: IFTRUE 68340
68314: LD_INT 5
68316: DOUBLE
68317: EQUAL
68318: IFTRUE 68340
68320: LD_INT 2
68322: DOUBLE
68323: EQUAL
68324: IFTRUE 68340
68326: LD_INT 3
68328: DOUBLE
68329: EQUAL
68330: IFTRUE 68340
68332: LD_INT 35
68334: DOUBLE
68335: EQUAL
68336: IFTRUE 68340
68338: GO 68351
68340: POP
// places := 6 ; b_bunker , b_breastwork :
68341: LD_ADDR_VAR 0 3
68345: PUSH
68346: LD_INT 6
68348: ST_TO_ADDR
68349: GO 68396
68351: LD_INT 32
68353: DOUBLE
68354: EQUAL
68355: IFTRUE 68365
68357: LD_INT 31
68359: DOUBLE
68360: EQUAL
68361: IFTRUE 68365
68363: GO 68376
68365: POP
// places := 1 ; b_control_tower :
68366: LD_ADDR_VAR 0 3
68370: PUSH
68371: LD_INT 1
68373: ST_TO_ADDR
68374: GO 68396
68376: LD_INT 36
68378: DOUBLE
68379: EQUAL
68380: IFTRUE 68384
68382: GO 68395
68384: POP
// places := 3 ; end ;
68385: LD_ADDR_VAR 0 3
68389: PUSH
68390: LD_INT 3
68392: ST_TO_ADDR
68393: GO 68396
68395: POP
// if places then
68396: LD_VAR 0 3
68400: IFFALSE 68423
// result := UnitsInside ( building ) < places ;
68402: LD_ADDR_VAR 0 2
68406: PUSH
68407: LD_VAR 0 1
68411: PPUSH
68412: CALL_OW 313
68416: PUSH
68417: LD_VAR 0 3
68421: LESS
68422: ST_TO_ADDR
// end ;
68423: LD_VAR 0 2
68427: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68428: LD_INT 0
68430: PPUSH
68431: PPUSH
68432: PPUSH
68433: PPUSH
// tmp := [ ] ;
68434: LD_ADDR_VAR 0 3
68438: PUSH
68439: EMPTY
68440: ST_TO_ADDR
// list := [ ] ;
68441: LD_ADDR_VAR 0 5
68445: PUSH
68446: EMPTY
68447: ST_TO_ADDR
// for i = 16 to 25 do
68448: LD_ADDR_VAR 0 4
68452: PUSH
68453: DOUBLE
68454: LD_INT 16
68456: DEC
68457: ST_TO_ADDR
68458: LD_INT 25
68460: PUSH
68461: FOR_TO
68462: IFFALSE 68535
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68464: LD_ADDR_VAR 0 3
68468: PUSH
68469: LD_VAR 0 3
68473: PUSH
68474: LD_INT 22
68476: PUSH
68477: LD_VAR 0 1
68481: PPUSH
68482: CALL_OW 255
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 91
68493: PUSH
68494: LD_VAR 0 1
68498: PUSH
68499: LD_INT 6
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 30
68509: PUSH
68510: LD_VAR 0 4
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: LIST
68523: PUSH
68524: EMPTY
68525: LIST
68526: PPUSH
68527: CALL_OW 69
68531: ADD
68532: ST_TO_ADDR
68533: GO 68461
68535: POP
68536: POP
// for i = 1 to tmp do
68537: LD_ADDR_VAR 0 4
68541: PUSH
68542: DOUBLE
68543: LD_INT 1
68545: DEC
68546: ST_TO_ADDR
68547: LD_VAR 0 3
68551: PUSH
68552: FOR_TO
68553: IFFALSE 68641
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68555: LD_ADDR_VAR 0 5
68559: PUSH
68560: LD_VAR 0 5
68564: PUSH
68565: LD_VAR 0 3
68569: PUSH
68570: LD_VAR 0 4
68574: ARRAY
68575: PPUSH
68576: CALL_OW 266
68580: PUSH
68581: LD_VAR 0 3
68585: PUSH
68586: LD_VAR 0 4
68590: ARRAY
68591: PPUSH
68592: CALL_OW 250
68596: PUSH
68597: LD_VAR 0 3
68601: PUSH
68602: LD_VAR 0 4
68606: ARRAY
68607: PPUSH
68608: CALL_OW 251
68612: PUSH
68613: LD_VAR 0 3
68617: PUSH
68618: LD_VAR 0 4
68622: ARRAY
68623: PPUSH
68624: CALL_OW 254
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: PUSH
68635: EMPTY
68636: LIST
68637: ADD
68638: ST_TO_ADDR
68639: GO 68552
68641: POP
68642: POP
// result := list ;
68643: LD_ADDR_VAR 0 2
68647: PUSH
68648: LD_VAR 0 5
68652: ST_TO_ADDR
// end ;
68653: LD_VAR 0 2
68657: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68658: LD_INT 0
68660: PPUSH
68661: PPUSH
68662: PPUSH
68663: PPUSH
68664: PPUSH
68665: PPUSH
68666: PPUSH
// if not factory then
68667: LD_VAR 0 1
68671: NOT
68672: IFFALSE 68676
// exit ;
68674: GO 69269
// if control = control_apeman then
68676: LD_VAR 0 4
68680: PUSH
68681: LD_INT 5
68683: EQUAL
68684: IFFALSE 68793
// begin tmp := UnitsInside ( factory ) ;
68686: LD_ADDR_VAR 0 8
68690: PUSH
68691: LD_VAR 0 1
68695: PPUSH
68696: CALL_OW 313
68700: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68701: LD_VAR 0 8
68705: PPUSH
68706: LD_INT 25
68708: PUSH
68709: LD_INT 12
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PPUSH
68716: CALL_OW 72
68720: NOT
68721: IFFALSE 68731
// control := control_manual ;
68723: LD_ADDR_VAR 0 4
68727: PUSH
68728: LD_INT 1
68730: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68731: LD_ADDR_VAR 0 8
68735: PUSH
68736: LD_VAR 0 1
68740: PPUSH
68741: CALL 68428 0 1
68745: ST_TO_ADDR
// if tmp then
68746: LD_VAR 0 8
68750: IFFALSE 68793
// begin for i in tmp do
68752: LD_ADDR_VAR 0 7
68756: PUSH
68757: LD_VAR 0 8
68761: PUSH
68762: FOR_IN
68763: IFFALSE 68791
// if i [ 1 ] = b_ext_radio then
68765: LD_VAR 0 7
68769: PUSH
68770: LD_INT 1
68772: ARRAY
68773: PUSH
68774: LD_INT 22
68776: EQUAL
68777: IFFALSE 68789
// begin control := control_remote ;
68779: LD_ADDR_VAR 0 4
68783: PUSH
68784: LD_INT 2
68786: ST_TO_ADDR
// break ;
68787: GO 68791
// end ;
68789: GO 68762
68791: POP
68792: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68793: LD_VAR 0 1
68797: PPUSH
68798: LD_VAR 0 2
68802: PPUSH
68803: LD_VAR 0 3
68807: PPUSH
68808: LD_VAR 0 4
68812: PPUSH
68813: LD_VAR 0 5
68817: PPUSH
68818: CALL_OW 448
68822: IFFALSE 68857
// begin result := [ chassis , engine , control , weapon ] ;
68824: LD_ADDR_VAR 0 6
68828: PUSH
68829: LD_VAR 0 2
68833: PUSH
68834: LD_VAR 0 3
68838: PUSH
68839: LD_VAR 0 4
68843: PUSH
68844: LD_VAR 0 5
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: ST_TO_ADDR
// exit ;
68855: GO 69269
// end ; _chassis := AvailableChassisList ( factory ) ;
68857: LD_ADDR_VAR 0 9
68861: PUSH
68862: LD_VAR 0 1
68866: PPUSH
68867: CALL_OW 475
68871: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68872: LD_ADDR_VAR 0 11
68876: PUSH
68877: LD_VAR 0 1
68881: PPUSH
68882: CALL_OW 476
68886: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68887: LD_ADDR_VAR 0 12
68891: PUSH
68892: LD_VAR 0 1
68896: PPUSH
68897: CALL_OW 477
68901: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68902: LD_ADDR_VAR 0 10
68906: PUSH
68907: LD_VAR 0 1
68911: PPUSH
68912: CALL_OW 478
68916: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68917: LD_VAR 0 9
68921: NOT
68922: PUSH
68923: LD_VAR 0 11
68927: NOT
68928: OR
68929: PUSH
68930: LD_VAR 0 12
68934: NOT
68935: OR
68936: PUSH
68937: LD_VAR 0 10
68941: NOT
68942: OR
68943: IFFALSE 68978
// begin result := [ chassis , engine , control , weapon ] ;
68945: LD_ADDR_VAR 0 6
68949: PUSH
68950: LD_VAR 0 2
68954: PUSH
68955: LD_VAR 0 3
68959: PUSH
68960: LD_VAR 0 4
68964: PUSH
68965: LD_VAR 0 5
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: ST_TO_ADDR
// exit ;
68976: GO 69269
// end ; if not chassis in _chassis then
68978: LD_VAR 0 2
68982: PUSH
68983: LD_VAR 0 9
68987: IN
68988: NOT
68989: IFFALSE 69015
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68991: LD_ADDR_VAR 0 2
68995: PUSH
68996: LD_VAR 0 9
69000: PUSH
69001: LD_INT 1
69003: PPUSH
69004: LD_VAR 0 9
69008: PPUSH
69009: CALL_OW 12
69013: ARRAY
69014: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69015: LD_VAR 0 2
69019: PPUSH
69020: LD_VAR 0 3
69024: PPUSH
69025: CALL 69274 0 2
69029: NOT
69030: IFFALSE 69089
// repeat engine := _engine [ 1 ] ;
69032: LD_ADDR_VAR 0 3
69036: PUSH
69037: LD_VAR 0 11
69041: PUSH
69042: LD_INT 1
69044: ARRAY
69045: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69046: LD_ADDR_VAR 0 11
69050: PUSH
69051: LD_VAR 0 11
69055: PPUSH
69056: LD_INT 1
69058: PPUSH
69059: CALL_OW 3
69063: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69064: LD_VAR 0 2
69068: PPUSH
69069: LD_VAR 0 3
69073: PPUSH
69074: CALL 69274 0 2
69078: PUSH
69079: LD_VAR 0 11
69083: PUSH
69084: EMPTY
69085: EQUAL
69086: OR
69087: IFFALSE 69032
// if not control in _control then
69089: LD_VAR 0 4
69093: PUSH
69094: LD_VAR 0 12
69098: IN
69099: NOT
69100: IFFALSE 69126
// control := _control [ rand ( 1 , _control ) ] ;
69102: LD_ADDR_VAR 0 4
69106: PUSH
69107: LD_VAR 0 12
69111: PUSH
69112: LD_INT 1
69114: PPUSH
69115: LD_VAR 0 12
69119: PPUSH
69120: CALL_OW 12
69124: ARRAY
69125: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69126: LD_VAR 0 2
69130: PPUSH
69131: LD_VAR 0 5
69135: PPUSH
69136: CALL 69494 0 2
69140: NOT
69141: IFFALSE 69200
// repeat weapon := _weapon [ 1 ] ;
69143: LD_ADDR_VAR 0 5
69147: PUSH
69148: LD_VAR 0 10
69152: PUSH
69153: LD_INT 1
69155: ARRAY
69156: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69157: LD_ADDR_VAR 0 10
69161: PUSH
69162: LD_VAR 0 10
69166: PPUSH
69167: LD_INT 1
69169: PPUSH
69170: CALL_OW 3
69174: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69175: LD_VAR 0 2
69179: PPUSH
69180: LD_VAR 0 5
69184: PPUSH
69185: CALL 69494 0 2
69189: PUSH
69190: LD_VAR 0 10
69194: PUSH
69195: EMPTY
69196: EQUAL
69197: OR
69198: IFFALSE 69143
// result := [ ] ;
69200: LD_ADDR_VAR 0 6
69204: PUSH
69205: EMPTY
69206: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69207: LD_VAR 0 1
69211: PPUSH
69212: LD_VAR 0 2
69216: PPUSH
69217: LD_VAR 0 3
69221: PPUSH
69222: LD_VAR 0 4
69226: PPUSH
69227: LD_VAR 0 5
69231: PPUSH
69232: CALL_OW 448
69236: IFFALSE 69269
// result := [ chassis , engine , control , weapon ] ;
69238: LD_ADDR_VAR 0 6
69242: PUSH
69243: LD_VAR 0 2
69247: PUSH
69248: LD_VAR 0 3
69252: PUSH
69253: LD_VAR 0 4
69257: PUSH
69258: LD_VAR 0 5
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: ST_TO_ADDR
// end ;
69269: LD_VAR 0 6
69273: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69274: LD_INT 0
69276: PPUSH
// if not chassis or not engine then
69277: LD_VAR 0 1
69281: NOT
69282: PUSH
69283: LD_VAR 0 2
69287: NOT
69288: OR
69289: IFFALSE 69293
// exit ;
69291: GO 69489
// case engine of engine_solar :
69293: LD_VAR 0 2
69297: PUSH
69298: LD_INT 2
69300: DOUBLE
69301: EQUAL
69302: IFTRUE 69306
69304: GO 69344
69306: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69307: LD_ADDR_VAR 0 3
69311: PUSH
69312: LD_INT 11
69314: PUSH
69315: LD_INT 12
69317: PUSH
69318: LD_INT 13
69320: PUSH
69321: LD_INT 14
69323: PUSH
69324: LD_INT 1
69326: PUSH
69327: LD_INT 2
69329: PUSH
69330: LD_INT 3
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: ST_TO_ADDR
69342: GO 69473
69344: LD_INT 1
69346: DOUBLE
69347: EQUAL
69348: IFTRUE 69352
69350: GO 69414
69352: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69353: LD_ADDR_VAR 0 3
69357: PUSH
69358: LD_INT 11
69360: PUSH
69361: LD_INT 12
69363: PUSH
69364: LD_INT 13
69366: PUSH
69367: LD_INT 14
69369: PUSH
69370: LD_INT 1
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: LD_INT 3
69378: PUSH
69379: LD_INT 4
69381: PUSH
69382: LD_INT 5
69384: PUSH
69385: LD_INT 21
69387: PUSH
69388: LD_INT 23
69390: PUSH
69391: LD_INT 22
69393: PUSH
69394: LD_INT 24
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: ST_TO_ADDR
69412: GO 69473
69414: LD_INT 3
69416: DOUBLE
69417: EQUAL
69418: IFTRUE 69422
69420: GO 69472
69422: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69423: LD_ADDR_VAR 0 3
69427: PUSH
69428: LD_INT 13
69430: PUSH
69431: LD_INT 14
69433: PUSH
69434: LD_INT 2
69436: PUSH
69437: LD_INT 3
69439: PUSH
69440: LD_INT 4
69442: PUSH
69443: LD_INT 5
69445: PUSH
69446: LD_INT 21
69448: PUSH
69449: LD_INT 22
69451: PUSH
69452: LD_INT 23
69454: PUSH
69455: LD_INT 24
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: ST_TO_ADDR
69470: GO 69473
69472: POP
// result := ( chassis in result ) ;
69473: LD_ADDR_VAR 0 3
69477: PUSH
69478: LD_VAR 0 1
69482: PUSH
69483: LD_VAR 0 3
69487: IN
69488: ST_TO_ADDR
// end ;
69489: LD_VAR 0 3
69493: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69494: LD_INT 0
69496: PPUSH
// if not chassis or not weapon then
69497: LD_VAR 0 1
69501: NOT
69502: PUSH
69503: LD_VAR 0 2
69507: NOT
69508: OR
69509: IFFALSE 69513
// exit ;
69511: GO 70573
// case weapon of us_machine_gun :
69513: LD_VAR 0 2
69517: PUSH
69518: LD_INT 2
69520: DOUBLE
69521: EQUAL
69522: IFTRUE 69526
69524: GO 69556
69526: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69527: LD_ADDR_VAR 0 3
69531: PUSH
69532: LD_INT 1
69534: PUSH
69535: LD_INT 2
69537: PUSH
69538: LD_INT 3
69540: PUSH
69541: LD_INT 4
69543: PUSH
69544: LD_INT 5
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: ST_TO_ADDR
69554: GO 70557
69556: LD_INT 3
69558: DOUBLE
69559: EQUAL
69560: IFTRUE 69564
69562: GO 69594
69564: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69565: LD_ADDR_VAR 0 3
69569: PUSH
69570: LD_INT 1
69572: PUSH
69573: LD_INT 2
69575: PUSH
69576: LD_INT 3
69578: PUSH
69579: LD_INT 4
69581: PUSH
69582: LD_INT 5
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: ST_TO_ADDR
69592: GO 70557
69594: LD_INT 11
69596: DOUBLE
69597: EQUAL
69598: IFTRUE 69602
69600: GO 69632
69602: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69603: LD_ADDR_VAR 0 3
69607: PUSH
69608: LD_INT 1
69610: PUSH
69611: LD_INT 2
69613: PUSH
69614: LD_INT 3
69616: PUSH
69617: LD_INT 4
69619: PUSH
69620: LD_INT 5
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: ST_TO_ADDR
69630: GO 70557
69632: LD_INT 4
69634: DOUBLE
69635: EQUAL
69636: IFTRUE 69640
69638: GO 69666
69640: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69641: LD_ADDR_VAR 0 3
69645: PUSH
69646: LD_INT 2
69648: PUSH
69649: LD_INT 3
69651: PUSH
69652: LD_INT 4
69654: PUSH
69655: LD_INT 5
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: LIST
69662: LIST
69663: ST_TO_ADDR
69664: GO 70557
69666: LD_INT 5
69668: DOUBLE
69669: EQUAL
69670: IFTRUE 69674
69672: GO 69700
69674: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69675: LD_ADDR_VAR 0 3
69679: PUSH
69680: LD_INT 2
69682: PUSH
69683: LD_INT 3
69685: PUSH
69686: LD_INT 4
69688: PUSH
69689: LD_INT 5
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: ST_TO_ADDR
69698: GO 70557
69700: LD_INT 9
69702: DOUBLE
69703: EQUAL
69704: IFTRUE 69708
69706: GO 69734
69708: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69709: LD_ADDR_VAR 0 3
69713: PUSH
69714: LD_INT 2
69716: PUSH
69717: LD_INT 3
69719: PUSH
69720: LD_INT 4
69722: PUSH
69723: LD_INT 5
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: ST_TO_ADDR
69732: GO 70557
69734: LD_INT 7
69736: DOUBLE
69737: EQUAL
69738: IFTRUE 69742
69740: GO 69768
69742: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69743: LD_ADDR_VAR 0 3
69747: PUSH
69748: LD_INT 2
69750: PUSH
69751: LD_INT 3
69753: PUSH
69754: LD_INT 4
69756: PUSH
69757: LD_INT 5
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: ST_TO_ADDR
69766: GO 70557
69768: LD_INT 12
69770: DOUBLE
69771: EQUAL
69772: IFTRUE 69776
69774: GO 69802
69776: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69777: LD_ADDR_VAR 0 3
69781: PUSH
69782: LD_INT 2
69784: PUSH
69785: LD_INT 3
69787: PUSH
69788: LD_INT 4
69790: PUSH
69791: LD_INT 5
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: ST_TO_ADDR
69800: GO 70557
69802: LD_INT 13
69804: DOUBLE
69805: EQUAL
69806: IFTRUE 69810
69808: GO 69836
69810: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69811: LD_ADDR_VAR 0 3
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 3
69821: PUSH
69822: LD_INT 4
69824: PUSH
69825: LD_INT 5
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: ST_TO_ADDR
69834: GO 70557
69836: LD_INT 14
69838: DOUBLE
69839: EQUAL
69840: IFTRUE 69844
69842: GO 69862
69844: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69845: LD_ADDR_VAR 0 3
69849: PUSH
69850: LD_INT 4
69852: PUSH
69853: LD_INT 5
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: ST_TO_ADDR
69860: GO 70557
69862: LD_INT 6
69864: DOUBLE
69865: EQUAL
69866: IFTRUE 69870
69868: GO 69888
69870: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69871: LD_ADDR_VAR 0 3
69875: PUSH
69876: LD_INT 4
69878: PUSH
69879: LD_INT 5
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: ST_TO_ADDR
69886: GO 70557
69888: LD_INT 10
69890: DOUBLE
69891: EQUAL
69892: IFTRUE 69896
69894: GO 69914
69896: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69897: LD_ADDR_VAR 0 3
69901: PUSH
69902: LD_INT 4
69904: PUSH
69905: LD_INT 5
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: ST_TO_ADDR
69912: GO 70557
69914: LD_INT 22
69916: DOUBLE
69917: EQUAL
69918: IFTRUE 69922
69920: GO 69948
69922: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69923: LD_ADDR_VAR 0 3
69927: PUSH
69928: LD_INT 11
69930: PUSH
69931: LD_INT 12
69933: PUSH
69934: LD_INT 13
69936: PUSH
69937: LD_INT 14
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: ST_TO_ADDR
69946: GO 70557
69948: LD_INT 23
69950: DOUBLE
69951: EQUAL
69952: IFTRUE 69956
69954: GO 69982
69956: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69957: LD_ADDR_VAR 0 3
69961: PUSH
69962: LD_INT 11
69964: PUSH
69965: LD_INT 12
69967: PUSH
69968: LD_INT 13
69970: PUSH
69971: LD_INT 14
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: ST_TO_ADDR
69980: GO 70557
69982: LD_INT 24
69984: DOUBLE
69985: EQUAL
69986: IFTRUE 69990
69988: GO 70016
69990: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69991: LD_ADDR_VAR 0 3
69995: PUSH
69996: LD_INT 11
69998: PUSH
69999: LD_INT 12
70001: PUSH
70002: LD_INT 13
70004: PUSH
70005: LD_INT 14
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: ST_TO_ADDR
70014: GO 70557
70016: LD_INT 30
70018: DOUBLE
70019: EQUAL
70020: IFTRUE 70024
70022: GO 70050
70024: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70025: LD_ADDR_VAR 0 3
70029: PUSH
70030: LD_INT 11
70032: PUSH
70033: LD_INT 12
70035: PUSH
70036: LD_INT 13
70038: PUSH
70039: LD_INT 14
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: ST_TO_ADDR
70048: GO 70557
70050: LD_INT 25
70052: DOUBLE
70053: EQUAL
70054: IFTRUE 70058
70056: GO 70076
70058: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70059: LD_ADDR_VAR 0 3
70063: PUSH
70064: LD_INT 13
70066: PUSH
70067: LD_INT 14
70069: PUSH
70070: EMPTY
70071: LIST
70072: LIST
70073: ST_TO_ADDR
70074: GO 70557
70076: LD_INT 27
70078: DOUBLE
70079: EQUAL
70080: IFTRUE 70084
70082: GO 70102
70084: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
70085: LD_ADDR_VAR 0 3
70089: PUSH
70090: LD_INT 13
70092: PUSH
70093: LD_INT 14
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: ST_TO_ADDR
70100: GO 70557
70102: LD_INT 92
70104: DOUBLE
70105: EQUAL
70106: IFTRUE 70110
70108: GO 70136
70110: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70111: LD_ADDR_VAR 0 3
70115: PUSH
70116: LD_INT 11
70118: PUSH
70119: LD_INT 12
70121: PUSH
70122: LD_INT 13
70124: PUSH
70125: LD_INT 14
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: ST_TO_ADDR
70134: GO 70557
70136: LD_INT 28
70138: DOUBLE
70139: EQUAL
70140: IFTRUE 70144
70142: GO 70162
70144: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70145: LD_ADDR_VAR 0 3
70149: PUSH
70150: LD_INT 13
70152: PUSH
70153: LD_INT 14
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: ST_TO_ADDR
70160: GO 70557
70162: LD_INT 29
70164: DOUBLE
70165: EQUAL
70166: IFTRUE 70170
70168: GO 70188
70170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70171: LD_ADDR_VAR 0 3
70175: PUSH
70176: LD_INT 13
70178: PUSH
70179: LD_INT 14
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: ST_TO_ADDR
70186: GO 70557
70188: LD_INT 31
70190: DOUBLE
70191: EQUAL
70192: IFTRUE 70196
70194: GO 70214
70196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70197: LD_ADDR_VAR 0 3
70201: PUSH
70202: LD_INT 13
70204: PUSH
70205: LD_INT 14
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: ST_TO_ADDR
70212: GO 70557
70214: LD_INT 26
70216: DOUBLE
70217: EQUAL
70218: IFTRUE 70222
70220: GO 70240
70222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70223: LD_ADDR_VAR 0 3
70227: PUSH
70228: LD_INT 13
70230: PUSH
70231: LD_INT 14
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: ST_TO_ADDR
70238: GO 70557
70240: LD_INT 42
70242: DOUBLE
70243: EQUAL
70244: IFTRUE 70248
70246: GO 70274
70248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70249: LD_ADDR_VAR 0 3
70253: PUSH
70254: LD_INT 21
70256: PUSH
70257: LD_INT 22
70259: PUSH
70260: LD_INT 23
70262: PUSH
70263: LD_INT 24
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: ST_TO_ADDR
70272: GO 70557
70274: LD_INT 43
70276: DOUBLE
70277: EQUAL
70278: IFTRUE 70282
70280: GO 70308
70282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70283: LD_ADDR_VAR 0 3
70287: PUSH
70288: LD_INT 21
70290: PUSH
70291: LD_INT 22
70293: PUSH
70294: LD_INT 23
70296: PUSH
70297: LD_INT 24
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: ST_TO_ADDR
70306: GO 70557
70308: LD_INT 44
70310: DOUBLE
70311: EQUAL
70312: IFTRUE 70316
70314: GO 70342
70316: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70317: LD_ADDR_VAR 0 3
70321: PUSH
70322: LD_INT 21
70324: PUSH
70325: LD_INT 22
70327: PUSH
70328: LD_INT 23
70330: PUSH
70331: LD_INT 24
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: ST_TO_ADDR
70340: GO 70557
70342: LD_INT 45
70344: DOUBLE
70345: EQUAL
70346: IFTRUE 70350
70348: GO 70376
70350: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70351: LD_ADDR_VAR 0 3
70355: PUSH
70356: LD_INT 21
70358: PUSH
70359: LD_INT 22
70361: PUSH
70362: LD_INT 23
70364: PUSH
70365: LD_INT 24
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: LIST
70372: LIST
70373: ST_TO_ADDR
70374: GO 70557
70376: LD_INT 49
70378: DOUBLE
70379: EQUAL
70380: IFTRUE 70384
70382: GO 70410
70384: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70385: LD_ADDR_VAR 0 3
70389: PUSH
70390: LD_INT 21
70392: PUSH
70393: LD_INT 22
70395: PUSH
70396: LD_INT 23
70398: PUSH
70399: LD_INT 24
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: ST_TO_ADDR
70408: GO 70557
70410: LD_INT 51
70412: DOUBLE
70413: EQUAL
70414: IFTRUE 70418
70416: GO 70444
70418: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70419: LD_ADDR_VAR 0 3
70423: PUSH
70424: LD_INT 21
70426: PUSH
70427: LD_INT 22
70429: PUSH
70430: LD_INT 23
70432: PUSH
70433: LD_INT 24
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: ST_TO_ADDR
70442: GO 70557
70444: LD_INT 52
70446: DOUBLE
70447: EQUAL
70448: IFTRUE 70452
70450: GO 70478
70452: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70453: LD_ADDR_VAR 0 3
70457: PUSH
70458: LD_INT 21
70460: PUSH
70461: LD_INT 22
70463: PUSH
70464: LD_INT 23
70466: PUSH
70467: LD_INT 24
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: ST_TO_ADDR
70476: GO 70557
70478: LD_INT 53
70480: DOUBLE
70481: EQUAL
70482: IFTRUE 70486
70484: GO 70504
70486: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70487: LD_ADDR_VAR 0 3
70491: PUSH
70492: LD_INT 23
70494: PUSH
70495: LD_INT 24
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: ST_TO_ADDR
70502: GO 70557
70504: LD_INT 46
70506: DOUBLE
70507: EQUAL
70508: IFTRUE 70512
70510: GO 70530
70512: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70513: LD_ADDR_VAR 0 3
70517: PUSH
70518: LD_INT 23
70520: PUSH
70521: LD_INT 24
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: ST_TO_ADDR
70528: GO 70557
70530: LD_INT 47
70532: DOUBLE
70533: EQUAL
70534: IFTRUE 70538
70536: GO 70556
70538: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70539: LD_ADDR_VAR 0 3
70543: PUSH
70544: LD_INT 23
70546: PUSH
70547: LD_INT 24
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: ST_TO_ADDR
70554: GO 70557
70556: POP
// result := ( chassis in result ) ;
70557: LD_ADDR_VAR 0 3
70561: PUSH
70562: LD_VAR 0 1
70566: PUSH
70567: LD_VAR 0 3
70571: IN
70572: ST_TO_ADDR
// end ;
70573: LD_VAR 0 3
70577: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70578: LD_INT 0
70580: PPUSH
70581: PPUSH
70582: PPUSH
70583: PPUSH
70584: PPUSH
70585: PPUSH
70586: PPUSH
// result := array ;
70587: LD_ADDR_VAR 0 5
70591: PUSH
70592: LD_VAR 0 1
70596: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70597: LD_VAR 0 1
70601: NOT
70602: PUSH
70603: LD_VAR 0 2
70607: NOT
70608: OR
70609: PUSH
70610: LD_VAR 0 3
70614: NOT
70615: OR
70616: PUSH
70617: LD_VAR 0 2
70621: PUSH
70622: LD_VAR 0 1
70626: GREATER
70627: OR
70628: PUSH
70629: LD_VAR 0 3
70633: PUSH
70634: LD_VAR 0 1
70638: GREATER
70639: OR
70640: IFFALSE 70644
// exit ;
70642: GO 70940
// if direction then
70644: LD_VAR 0 4
70648: IFFALSE 70712
// begin d := 1 ;
70650: LD_ADDR_VAR 0 9
70654: PUSH
70655: LD_INT 1
70657: ST_TO_ADDR
// if i_from > i_to then
70658: LD_VAR 0 2
70662: PUSH
70663: LD_VAR 0 3
70667: GREATER
70668: IFFALSE 70694
// length := ( array - i_from ) + i_to else
70670: LD_ADDR_VAR 0 11
70674: PUSH
70675: LD_VAR 0 1
70679: PUSH
70680: LD_VAR 0 2
70684: MINUS
70685: PUSH
70686: LD_VAR 0 3
70690: PLUS
70691: ST_TO_ADDR
70692: GO 70710
// length := i_to - i_from ;
70694: LD_ADDR_VAR 0 11
70698: PUSH
70699: LD_VAR 0 3
70703: PUSH
70704: LD_VAR 0 2
70708: MINUS
70709: ST_TO_ADDR
// end else
70710: GO 70773
// begin d := - 1 ;
70712: LD_ADDR_VAR 0 9
70716: PUSH
70717: LD_INT 1
70719: NEG
70720: ST_TO_ADDR
// if i_from > i_to then
70721: LD_VAR 0 2
70725: PUSH
70726: LD_VAR 0 3
70730: GREATER
70731: IFFALSE 70751
// length := i_from - i_to else
70733: LD_ADDR_VAR 0 11
70737: PUSH
70738: LD_VAR 0 2
70742: PUSH
70743: LD_VAR 0 3
70747: MINUS
70748: ST_TO_ADDR
70749: GO 70773
// length := ( array - i_to ) + i_from ;
70751: LD_ADDR_VAR 0 11
70755: PUSH
70756: LD_VAR 0 1
70760: PUSH
70761: LD_VAR 0 3
70765: MINUS
70766: PUSH
70767: LD_VAR 0 2
70771: PLUS
70772: ST_TO_ADDR
// end ; if not length then
70773: LD_VAR 0 11
70777: NOT
70778: IFFALSE 70782
// exit ;
70780: GO 70940
// tmp := array ;
70782: LD_ADDR_VAR 0 10
70786: PUSH
70787: LD_VAR 0 1
70791: ST_TO_ADDR
// for i = 1 to length do
70792: LD_ADDR_VAR 0 6
70796: PUSH
70797: DOUBLE
70798: LD_INT 1
70800: DEC
70801: ST_TO_ADDR
70802: LD_VAR 0 11
70806: PUSH
70807: FOR_TO
70808: IFFALSE 70928
// begin for j = 1 to array do
70810: LD_ADDR_VAR 0 7
70814: PUSH
70815: DOUBLE
70816: LD_INT 1
70818: DEC
70819: ST_TO_ADDR
70820: LD_VAR 0 1
70824: PUSH
70825: FOR_TO
70826: IFFALSE 70914
// begin k := j + d ;
70828: LD_ADDR_VAR 0 8
70832: PUSH
70833: LD_VAR 0 7
70837: PUSH
70838: LD_VAR 0 9
70842: PLUS
70843: ST_TO_ADDR
// if k > array then
70844: LD_VAR 0 8
70848: PUSH
70849: LD_VAR 0 1
70853: GREATER
70854: IFFALSE 70864
// k := 1 ;
70856: LD_ADDR_VAR 0 8
70860: PUSH
70861: LD_INT 1
70863: ST_TO_ADDR
// if not k then
70864: LD_VAR 0 8
70868: NOT
70869: IFFALSE 70881
// k := array ;
70871: LD_ADDR_VAR 0 8
70875: PUSH
70876: LD_VAR 0 1
70880: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70881: LD_ADDR_VAR 0 10
70885: PUSH
70886: LD_VAR 0 10
70890: PPUSH
70891: LD_VAR 0 8
70895: PPUSH
70896: LD_VAR 0 1
70900: PUSH
70901: LD_VAR 0 7
70905: ARRAY
70906: PPUSH
70907: CALL_OW 1
70911: ST_TO_ADDR
// end ;
70912: GO 70825
70914: POP
70915: POP
// array := tmp ;
70916: LD_ADDR_VAR 0 1
70920: PUSH
70921: LD_VAR 0 10
70925: ST_TO_ADDR
// end ;
70926: GO 70807
70928: POP
70929: POP
// result := array ;
70930: LD_ADDR_VAR 0 5
70934: PUSH
70935: LD_VAR 0 1
70939: ST_TO_ADDR
// end ;
70940: LD_VAR 0 5
70944: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70945: LD_INT 0
70947: PPUSH
70948: PPUSH
// result := 0 ;
70949: LD_ADDR_VAR 0 3
70953: PUSH
70954: LD_INT 0
70956: ST_TO_ADDR
// if not array or not value in array then
70957: LD_VAR 0 1
70961: NOT
70962: PUSH
70963: LD_VAR 0 2
70967: PUSH
70968: LD_VAR 0 1
70972: IN
70973: NOT
70974: OR
70975: IFFALSE 70979
// exit ;
70977: GO 71033
// for i = 1 to array do
70979: LD_ADDR_VAR 0 4
70983: PUSH
70984: DOUBLE
70985: LD_INT 1
70987: DEC
70988: ST_TO_ADDR
70989: LD_VAR 0 1
70993: PUSH
70994: FOR_TO
70995: IFFALSE 71031
// if value = array [ i ] then
70997: LD_VAR 0 2
71001: PUSH
71002: LD_VAR 0 1
71006: PUSH
71007: LD_VAR 0 4
71011: ARRAY
71012: EQUAL
71013: IFFALSE 71029
// begin result := i ;
71015: LD_ADDR_VAR 0 3
71019: PUSH
71020: LD_VAR 0 4
71024: ST_TO_ADDR
// exit ;
71025: POP
71026: POP
71027: GO 71033
// end ;
71029: GO 70994
71031: POP
71032: POP
// end ;
71033: LD_VAR 0 3
71037: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71038: LD_INT 0
71040: PPUSH
// vc_chassis := chassis ;
71041: LD_ADDR_OWVAR 37
71045: PUSH
71046: LD_VAR 0 1
71050: ST_TO_ADDR
// vc_engine := engine ;
71051: LD_ADDR_OWVAR 39
71055: PUSH
71056: LD_VAR 0 2
71060: ST_TO_ADDR
// vc_control := control ;
71061: LD_ADDR_OWVAR 38
71065: PUSH
71066: LD_VAR 0 3
71070: ST_TO_ADDR
// vc_weapon := weapon ;
71071: LD_ADDR_OWVAR 40
71075: PUSH
71076: LD_VAR 0 4
71080: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71081: LD_ADDR_OWVAR 41
71085: PUSH
71086: LD_VAR 0 5
71090: ST_TO_ADDR
// end ;
71091: LD_VAR 0 6
71095: RET
// export function WantPlant ( unit ) ; var task ; begin
71096: LD_INT 0
71098: PPUSH
71099: PPUSH
// result := false ;
71100: LD_ADDR_VAR 0 2
71104: PUSH
71105: LD_INT 0
71107: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71108: LD_ADDR_VAR 0 3
71112: PUSH
71113: LD_VAR 0 1
71117: PPUSH
71118: CALL_OW 437
71122: ST_TO_ADDR
// if task then
71123: LD_VAR 0 3
71127: IFFALSE 71155
// if task [ 1 ] [ 1 ] = p then
71129: LD_VAR 0 3
71133: PUSH
71134: LD_INT 1
71136: ARRAY
71137: PUSH
71138: LD_INT 1
71140: ARRAY
71141: PUSH
71142: LD_STRING p
71144: EQUAL
71145: IFFALSE 71155
// result := true ;
71147: LD_ADDR_VAR 0 2
71151: PUSH
71152: LD_INT 1
71154: ST_TO_ADDR
// end ;
71155: LD_VAR 0 2
71159: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71160: LD_INT 0
71162: PPUSH
71163: PPUSH
71164: PPUSH
71165: PPUSH
// if pos < 1 then
71166: LD_VAR 0 2
71170: PUSH
71171: LD_INT 1
71173: LESS
71174: IFFALSE 71178
// exit ;
71176: GO 71481
// if pos = 1 then
71178: LD_VAR 0 2
71182: PUSH
71183: LD_INT 1
71185: EQUAL
71186: IFFALSE 71219
// result := Replace ( arr , pos [ 1 ] , value ) else
71188: LD_ADDR_VAR 0 4
71192: PUSH
71193: LD_VAR 0 1
71197: PPUSH
71198: LD_VAR 0 2
71202: PUSH
71203: LD_INT 1
71205: ARRAY
71206: PPUSH
71207: LD_VAR 0 3
71211: PPUSH
71212: CALL_OW 1
71216: ST_TO_ADDR
71217: GO 71481
// begin tmp := arr ;
71219: LD_ADDR_VAR 0 6
71223: PUSH
71224: LD_VAR 0 1
71228: ST_TO_ADDR
// s_arr := [ tmp ] ;
71229: LD_ADDR_VAR 0 7
71233: PUSH
71234: LD_VAR 0 6
71238: PUSH
71239: EMPTY
71240: LIST
71241: ST_TO_ADDR
// for i = 1 to pos - 1 do
71242: LD_ADDR_VAR 0 5
71246: PUSH
71247: DOUBLE
71248: LD_INT 1
71250: DEC
71251: ST_TO_ADDR
71252: LD_VAR 0 2
71256: PUSH
71257: LD_INT 1
71259: MINUS
71260: PUSH
71261: FOR_TO
71262: IFFALSE 71307
// begin tmp := tmp [ pos [ i ] ] ;
71264: LD_ADDR_VAR 0 6
71268: PUSH
71269: LD_VAR 0 6
71273: PUSH
71274: LD_VAR 0 2
71278: PUSH
71279: LD_VAR 0 5
71283: ARRAY
71284: ARRAY
71285: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71286: LD_ADDR_VAR 0 7
71290: PUSH
71291: LD_VAR 0 7
71295: PUSH
71296: LD_VAR 0 6
71300: PUSH
71301: EMPTY
71302: LIST
71303: ADD
71304: ST_TO_ADDR
// end ;
71305: GO 71261
71307: POP
71308: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71309: LD_ADDR_VAR 0 6
71313: PUSH
71314: LD_VAR 0 6
71318: PPUSH
71319: LD_VAR 0 2
71323: PUSH
71324: LD_VAR 0 2
71328: ARRAY
71329: PPUSH
71330: LD_VAR 0 3
71334: PPUSH
71335: CALL_OW 1
71339: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71340: LD_ADDR_VAR 0 7
71344: PUSH
71345: LD_VAR 0 7
71349: PPUSH
71350: LD_VAR 0 7
71354: PPUSH
71355: LD_VAR 0 6
71359: PPUSH
71360: CALL_OW 1
71364: ST_TO_ADDR
// for i = s_arr downto 2 do
71365: LD_ADDR_VAR 0 5
71369: PUSH
71370: DOUBLE
71371: LD_VAR 0 7
71375: INC
71376: ST_TO_ADDR
71377: LD_INT 2
71379: PUSH
71380: FOR_DOWNTO
71381: IFFALSE 71465
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71383: LD_ADDR_VAR 0 6
71387: PUSH
71388: LD_VAR 0 7
71392: PUSH
71393: LD_VAR 0 5
71397: PUSH
71398: LD_INT 1
71400: MINUS
71401: ARRAY
71402: PPUSH
71403: LD_VAR 0 2
71407: PUSH
71408: LD_VAR 0 5
71412: PUSH
71413: LD_INT 1
71415: MINUS
71416: ARRAY
71417: PPUSH
71418: LD_VAR 0 7
71422: PUSH
71423: LD_VAR 0 5
71427: ARRAY
71428: PPUSH
71429: CALL_OW 1
71433: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71434: LD_ADDR_VAR 0 7
71438: PUSH
71439: LD_VAR 0 7
71443: PPUSH
71444: LD_VAR 0 5
71448: PUSH
71449: LD_INT 1
71451: MINUS
71452: PPUSH
71453: LD_VAR 0 6
71457: PPUSH
71458: CALL_OW 1
71462: ST_TO_ADDR
// end ;
71463: GO 71380
71465: POP
71466: POP
// result := s_arr [ 1 ] ;
71467: LD_ADDR_VAR 0 4
71471: PUSH
71472: LD_VAR 0 7
71476: PUSH
71477: LD_INT 1
71479: ARRAY
71480: ST_TO_ADDR
// end ; end ;
71481: LD_VAR 0 4
71485: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71486: LD_INT 0
71488: PPUSH
71489: PPUSH
// if not list then
71490: LD_VAR 0 1
71494: NOT
71495: IFFALSE 71499
// exit ;
71497: GO 71590
// i := list [ pos1 ] ;
71499: LD_ADDR_VAR 0 5
71503: PUSH
71504: LD_VAR 0 1
71508: PUSH
71509: LD_VAR 0 2
71513: ARRAY
71514: ST_TO_ADDR
// if not i then
71515: LD_VAR 0 5
71519: NOT
71520: IFFALSE 71524
// exit ;
71522: GO 71590
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71524: LD_ADDR_VAR 0 1
71528: PUSH
71529: LD_VAR 0 1
71533: PPUSH
71534: LD_VAR 0 2
71538: PPUSH
71539: LD_VAR 0 1
71543: PUSH
71544: LD_VAR 0 3
71548: ARRAY
71549: PPUSH
71550: CALL_OW 1
71554: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71555: LD_ADDR_VAR 0 1
71559: PUSH
71560: LD_VAR 0 1
71564: PPUSH
71565: LD_VAR 0 3
71569: PPUSH
71570: LD_VAR 0 5
71574: PPUSH
71575: CALL_OW 1
71579: ST_TO_ADDR
// result := list ;
71580: LD_ADDR_VAR 0 4
71584: PUSH
71585: LD_VAR 0 1
71589: ST_TO_ADDR
// end ;
71590: LD_VAR 0 4
71594: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71595: LD_INT 0
71597: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71598: LD_ADDR_VAR 0 5
71602: PUSH
71603: LD_VAR 0 1
71607: PPUSH
71608: CALL_OW 250
71612: PPUSH
71613: LD_VAR 0 1
71617: PPUSH
71618: CALL_OW 251
71622: PPUSH
71623: LD_VAR 0 2
71627: PPUSH
71628: LD_VAR 0 3
71632: PPUSH
71633: LD_VAR 0 4
71637: PPUSH
71638: CALL 71648 0 5
71642: ST_TO_ADDR
// end ;
71643: LD_VAR 0 5
71647: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71648: LD_INT 0
71650: PPUSH
71651: PPUSH
71652: PPUSH
71653: PPUSH
// if not list then
71654: LD_VAR 0 3
71658: NOT
71659: IFFALSE 71663
// exit ;
71661: GO 72051
// result := [ ] ;
71663: LD_ADDR_VAR 0 6
71667: PUSH
71668: EMPTY
71669: ST_TO_ADDR
// for i in list do
71670: LD_ADDR_VAR 0 7
71674: PUSH
71675: LD_VAR 0 3
71679: PUSH
71680: FOR_IN
71681: IFFALSE 71883
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71683: LD_ADDR_VAR 0 9
71687: PUSH
71688: LD_VAR 0 7
71692: PPUSH
71693: LD_VAR 0 1
71697: PPUSH
71698: LD_VAR 0 2
71702: PPUSH
71703: CALL_OW 297
71707: ST_TO_ADDR
// if not result then
71708: LD_VAR 0 6
71712: NOT
71713: IFFALSE 71739
// result := [ [ i , tmp ] ] else
71715: LD_ADDR_VAR 0 6
71719: PUSH
71720: LD_VAR 0 7
71724: PUSH
71725: LD_VAR 0 9
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: EMPTY
71735: LIST
71736: ST_TO_ADDR
71737: GO 71881
// begin if result [ result ] [ 2 ] < tmp then
71739: LD_VAR 0 6
71743: PUSH
71744: LD_VAR 0 6
71748: ARRAY
71749: PUSH
71750: LD_INT 2
71752: ARRAY
71753: PUSH
71754: LD_VAR 0 9
71758: LESS
71759: IFFALSE 71801
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71761: LD_ADDR_VAR 0 6
71765: PUSH
71766: LD_VAR 0 6
71770: PPUSH
71771: LD_VAR 0 6
71775: PUSH
71776: LD_INT 1
71778: PLUS
71779: PPUSH
71780: LD_VAR 0 7
71784: PUSH
71785: LD_VAR 0 9
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PPUSH
71794: CALL_OW 2
71798: ST_TO_ADDR
71799: GO 71881
// for j = 1 to result do
71801: LD_ADDR_VAR 0 8
71805: PUSH
71806: DOUBLE
71807: LD_INT 1
71809: DEC
71810: ST_TO_ADDR
71811: LD_VAR 0 6
71815: PUSH
71816: FOR_TO
71817: IFFALSE 71879
// begin if tmp < result [ j ] [ 2 ] then
71819: LD_VAR 0 9
71823: PUSH
71824: LD_VAR 0 6
71828: PUSH
71829: LD_VAR 0 8
71833: ARRAY
71834: PUSH
71835: LD_INT 2
71837: ARRAY
71838: LESS
71839: IFFALSE 71877
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71841: LD_ADDR_VAR 0 6
71845: PUSH
71846: LD_VAR 0 6
71850: PPUSH
71851: LD_VAR 0 8
71855: PPUSH
71856: LD_VAR 0 7
71860: PUSH
71861: LD_VAR 0 9
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PPUSH
71870: CALL_OW 2
71874: ST_TO_ADDR
// break ;
71875: GO 71879
// end ; end ;
71877: GO 71816
71879: POP
71880: POP
// end ; end ;
71881: GO 71680
71883: POP
71884: POP
// if result and not asc then
71885: LD_VAR 0 6
71889: PUSH
71890: LD_VAR 0 4
71894: NOT
71895: AND
71896: IFFALSE 71971
// begin tmp := result ;
71898: LD_ADDR_VAR 0 9
71902: PUSH
71903: LD_VAR 0 6
71907: ST_TO_ADDR
// for i = tmp downto 1 do
71908: LD_ADDR_VAR 0 7
71912: PUSH
71913: DOUBLE
71914: LD_VAR 0 9
71918: INC
71919: ST_TO_ADDR
71920: LD_INT 1
71922: PUSH
71923: FOR_DOWNTO
71924: IFFALSE 71969
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71926: LD_ADDR_VAR 0 6
71930: PUSH
71931: LD_VAR 0 6
71935: PPUSH
71936: LD_VAR 0 9
71940: PUSH
71941: LD_VAR 0 7
71945: MINUS
71946: PUSH
71947: LD_INT 1
71949: PLUS
71950: PPUSH
71951: LD_VAR 0 9
71955: PUSH
71956: LD_VAR 0 7
71960: ARRAY
71961: PPUSH
71962: CALL_OW 1
71966: ST_TO_ADDR
71967: GO 71923
71969: POP
71970: POP
// end ; tmp := [ ] ;
71971: LD_ADDR_VAR 0 9
71975: PUSH
71976: EMPTY
71977: ST_TO_ADDR
// if mode then
71978: LD_VAR 0 5
71982: IFFALSE 72051
// begin for i = 1 to result do
71984: LD_ADDR_VAR 0 7
71988: PUSH
71989: DOUBLE
71990: LD_INT 1
71992: DEC
71993: ST_TO_ADDR
71994: LD_VAR 0 6
71998: PUSH
71999: FOR_TO
72000: IFFALSE 72039
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72002: LD_ADDR_VAR 0 9
72006: PUSH
72007: LD_VAR 0 9
72011: PPUSH
72012: LD_VAR 0 7
72016: PPUSH
72017: LD_VAR 0 6
72021: PUSH
72022: LD_VAR 0 7
72026: ARRAY
72027: PUSH
72028: LD_INT 1
72030: ARRAY
72031: PPUSH
72032: CALL_OW 1
72036: ST_TO_ADDR
72037: GO 71999
72039: POP
72040: POP
// result := tmp ;
72041: LD_ADDR_VAR 0 6
72045: PUSH
72046: LD_VAR 0 9
72050: ST_TO_ADDR
// end ; end ;
72051: LD_VAR 0 6
72055: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72056: LD_INT 0
72058: PPUSH
72059: PPUSH
72060: PPUSH
72061: PPUSH
72062: PPUSH
72063: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72064: LD_ADDR_VAR 0 5
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: LD_INT 0
72074: PUSH
72075: LD_INT 0
72077: PUSH
72078: EMPTY
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: ST_TO_ADDR
// if not x or not y then
72086: LD_VAR 0 2
72090: NOT
72091: PUSH
72092: LD_VAR 0 3
72096: NOT
72097: OR
72098: IFFALSE 72102
// exit ;
72100: GO 73752
// if not range then
72102: LD_VAR 0 4
72106: NOT
72107: IFFALSE 72117
// range := 10 ;
72109: LD_ADDR_VAR 0 4
72113: PUSH
72114: LD_INT 10
72116: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72117: LD_ADDR_VAR 0 8
72121: PUSH
72122: LD_INT 81
72124: PUSH
72125: LD_VAR 0 1
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 92
72136: PUSH
72137: LD_VAR 0 2
72141: PUSH
72142: LD_VAR 0 3
72146: PUSH
72147: LD_VAR 0 4
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 3
72160: PUSH
72161: LD_INT 21
72163: PUSH
72164: LD_INT 3
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: PPUSH
72180: CALL_OW 69
72184: ST_TO_ADDR
// if not tmp then
72185: LD_VAR 0 8
72189: NOT
72190: IFFALSE 72194
// exit ;
72192: GO 73752
// for i in tmp do
72194: LD_ADDR_VAR 0 6
72198: PUSH
72199: LD_VAR 0 8
72203: PUSH
72204: FOR_IN
72205: IFFALSE 73727
// begin points := [ 0 , 0 , 0 ] ;
72207: LD_ADDR_VAR 0 9
72211: PUSH
72212: LD_INT 0
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: LIST
72225: ST_TO_ADDR
// bpoints := 1 ;
72226: LD_ADDR_VAR 0 10
72230: PUSH
72231: LD_INT 1
72233: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72234: LD_VAR 0 6
72238: PPUSH
72239: CALL_OW 247
72243: PUSH
72244: LD_INT 1
72246: DOUBLE
72247: EQUAL
72248: IFTRUE 72252
72250: GO 72830
72252: POP
// begin if GetClass ( i ) = 1 then
72253: LD_VAR 0 6
72257: PPUSH
72258: CALL_OW 257
72262: PUSH
72263: LD_INT 1
72265: EQUAL
72266: IFFALSE 72287
// points := [ 10 , 5 , 3 ] ;
72268: LD_ADDR_VAR 0 9
72272: PUSH
72273: LD_INT 10
72275: PUSH
72276: LD_INT 5
72278: PUSH
72279: LD_INT 3
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: LIST
72286: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72287: LD_VAR 0 6
72291: PPUSH
72292: CALL_OW 257
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 3
72302: PUSH
72303: LD_INT 4
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: IN
72311: IFFALSE 72332
// points := [ 3 , 2 , 1 ] ;
72313: LD_ADDR_VAR 0 9
72317: PUSH
72318: LD_INT 3
72320: PUSH
72321: LD_INT 2
72323: PUSH
72324: LD_INT 1
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: LIST
72331: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72332: LD_VAR 0 6
72336: PPUSH
72337: CALL_OW 257
72341: PUSH
72342: LD_INT 5
72344: EQUAL
72345: IFFALSE 72366
// points := [ 130 , 5 , 2 ] ;
72347: LD_ADDR_VAR 0 9
72351: PUSH
72352: LD_INT 130
72354: PUSH
72355: LD_INT 5
72357: PUSH
72358: LD_INT 2
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: LIST
72365: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72366: LD_VAR 0 6
72370: PPUSH
72371: CALL_OW 257
72375: PUSH
72376: LD_INT 8
72378: EQUAL
72379: IFFALSE 72400
// points := [ 35 , 35 , 30 ] ;
72381: LD_ADDR_VAR 0 9
72385: PUSH
72386: LD_INT 35
72388: PUSH
72389: LD_INT 35
72391: PUSH
72392: LD_INT 30
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: LIST
72399: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72400: LD_VAR 0 6
72404: PPUSH
72405: CALL_OW 257
72409: PUSH
72410: LD_INT 9
72412: EQUAL
72413: IFFALSE 72434
// points := [ 20 , 55 , 40 ] ;
72415: LD_ADDR_VAR 0 9
72419: PUSH
72420: LD_INT 20
72422: PUSH
72423: LD_INT 55
72425: PUSH
72426: LD_INT 40
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: LIST
72433: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72434: LD_VAR 0 6
72438: PPUSH
72439: CALL_OW 257
72443: PUSH
72444: LD_INT 12
72446: PUSH
72447: LD_INT 16
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: IN
72454: IFFALSE 72475
// points := [ 5 , 3 , 2 ] ;
72456: LD_ADDR_VAR 0 9
72460: PUSH
72461: LD_INT 5
72463: PUSH
72464: LD_INT 3
72466: PUSH
72467: LD_INT 2
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: LIST
72474: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72475: LD_VAR 0 6
72479: PPUSH
72480: CALL_OW 257
72484: PUSH
72485: LD_INT 17
72487: EQUAL
72488: IFFALSE 72509
// points := [ 100 , 50 , 75 ] ;
72490: LD_ADDR_VAR 0 9
72494: PUSH
72495: LD_INT 100
72497: PUSH
72498: LD_INT 50
72500: PUSH
72501: LD_INT 75
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: LIST
72508: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72509: LD_VAR 0 6
72513: PPUSH
72514: CALL_OW 257
72518: PUSH
72519: LD_INT 15
72521: EQUAL
72522: IFFALSE 72543
// points := [ 10 , 5 , 3 ] ;
72524: LD_ADDR_VAR 0 9
72528: PUSH
72529: LD_INT 10
72531: PUSH
72532: LD_INT 5
72534: PUSH
72535: LD_INT 3
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: LIST
72542: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72543: LD_VAR 0 6
72547: PPUSH
72548: CALL_OW 257
72552: PUSH
72553: LD_INT 14
72555: EQUAL
72556: IFFALSE 72577
// points := [ 10 , 0 , 0 ] ;
72558: LD_ADDR_VAR 0 9
72562: PUSH
72563: LD_INT 10
72565: PUSH
72566: LD_INT 0
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: LIST
72576: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72577: LD_VAR 0 6
72581: PPUSH
72582: CALL_OW 257
72586: PUSH
72587: LD_INT 11
72589: EQUAL
72590: IFFALSE 72611
// points := [ 30 , 10 , 5 ] ;
72592: LD_ADDR_VAR 0 9
72596: PUSH
72597: LD_INT 30
72599: PUSH
72600: LD_INT 10
72602: PUSH
72603: LD_INT 5
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: LIST
72610: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72611: LD_VAR 0 1
72615: PPUSH
72616: LD_INT 5
72618: PPUSH
72619: CALL_OW 321
72623: PUSH
72624: LD_INT 2
72626: EQUAL
72627: IFFALSE 72644
// bpoints := bpoints * 1.8 ;
72629: LD_ADDR_VAR 0 10
72633: PUSH
72634: LD_VAR 0 10
72638: PUSH
72639: LD_REAL  1.80000000000000E+0000
72642: MUL
72643: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72644: LD_VAR 0 6
72648: PPUSH
72649: CALL_OW 257
72653: PUSH
72654: LD_INT 1
72656: PUSH
72657: LD_INT 2
72659: PUSH
72660: LD_INT 3
72662: PUSH
72663: LD_INT 4
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: IN
72672: PUSH
72673: LD_VAR 0 1
72677: PPUSH
72678: LD_INT 51
72680: PPUSH
72681: CALL_OW 321
72685: PUSH
72686: LD_INT 2
72688: EQUAL
72689: AND
72690: IFFALSE 72707
// bpoints := bpoints * 1.2 ;
72692: LD_ADDR_VAR 0 10
72696: PUSH
72697: LD_VAR 0 10
72701: PUSH
72702: LD_REAL  1.20000000000000E+0000
72705: MUL
72706: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72707: LD_VAR 0 6
72711: PPUSH
72712: CALL_OW 257
72716: PUSH
72717: LD_INT 5
72719: PUSH
72720: LD_INT 7
72722: PUSH
72723: LD_INT 9
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: LIST
72730: IN
72731: PUSH
72732: LD_VAR 0 1
72736: PPUSH
72737: LD_INT 52
72739: PPUSH
72740: CALL_OW 321
72744: PUSH
72745: LD_INT 2
72747: EQUAL
72748: AND
72749: IFFALSE 72766
// bpoints := bpoints * 1.5 ;
72751: LD_ADDR_VAR 0 10
72755: PUSH
72756: LD_VAR 0 10
72760: PUSH
72761: LD_REAL  1.50000000000000E+0000
72764: MUL
72765: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72766: LD_VAR 0 1
72770: PPUSH
72771: LD_INT 66
72773: PPUSH
72774: CALL_OW 321
72778: PUSH
72779: LD_INT 2
72781: EQUAL
72782: IFFALSE 72799
// bpoints := bpoints * 1.1 ;
72784: LD_ADDR_VAR 0 10
72788: PUSH
72789: LD_VAR 0 10
72793: PUSH
72794: LD_REAL  1.10000000000000E+0000
72797: MUL
72798: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72799: LD_ADDR_VAR 0 10
72803: PUSH
72804: LD_VAR 0 10
72808: PUSH
72809: LD_VAR 0 6
72813: PPUSH
72814: LD_INT 1
72816: PPUSH
72817: CALL_OW 259
72821: PUSH
72822: LD_REAL  1.15000000000000E+0000
72825: MUL
72826: MUL
72827: ST_TO_ADDR
// end ; unit_vehicle :
72828: GO 73656
72830: LD_INT 2
72832: DOUBLE
72833: EQUAL
72834: IFTRUE 72838
72836: GO 73644
72838: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72839: LD_VAR 0 6
72843: PPUSH
72844: CALL_OW 264
72848: PUSH
72849: LD_INT 2
72851: PUSH
72852: LD_INT 42
72854: PUSH
72855: LD_INT 24
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: LIST
72862: IN
72863: IFFALSE 72884
// points := [ 25 , 5 , 3 ] ;
72865: LD_ADDR_VAR 0 9
72869: PUSH
72870: LD_INT 25
72872: PUSH
72873: LD_INT 5
72875: PUSH
72876: LD_INT 3
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72884: LD_VAR 0 6
72888: PPUSH
72889: CALL_OW 264
72893: PUSH
72894: LD_INT 4
72896: PUSH
72897: LD_INT 43
72899: PUSH
72900: LD_INT 25
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: LIST
72907: IN
72908: IFFALSE 72929
// points := [ 40 , 15 , 5 ] ;
72910: LD_ADDR_VAR 0 9
72914: PUSH
72915: LD_INT 40
72917: PUSH
72918: LD_INT 15
72920: PUSH
72921: LD_INT 5
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: LIST
72928: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72929: LD_VAR 0 6
72933: PPUSH
72934: CALL_OW 264
72938: PUSH
72939: LD_INT 3
72941: PUSH
72942: LD_INT 23
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: IN
72949: IFFALSE 72970
// points := [ 7 , 25 , 8 ] ;
72951: LD_ADDR_VAR 0 9
72955: PUSH
72956: LD_INT 7
72958: PUSH
72959: LD_INT 25
72961: PUSH
72962: LD_INT 8
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: LIST
72969: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72970: LD_VAR 0 6
72974: PPUSH
72975: CALL_OW 264
72979: PUSH
72980: LD_INT 5
72982: PUSH
72983: LD_INT 27
72985: PUSH
72986: LD_INT 44
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: LIST
72993: IN
72994: IFFALSE 73015
// points := [ 14 , 50 , 16 ] ;
72996: LD_ADDR_VAR 0 9
73000: PUSH
73001: LD_INT 14
73003: PUSH
73004: LD_INT 50
73006: PUSH
73007: LD_INT 16
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: LIST
73014: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73015: LD_VAR 0 6
73019: PPUSH
73020: CALL_OW 264
73024: PUSH
73025: LD_INT 6
73027: PUSH
73028: LD_INT 46
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: IN
73035: IFFALSE 73056
// points := [ 32 , 120 , 70 ] ;
73037: LD_ADDR_VAR 0 9
73041: PUSH
73042: LD_INT 32
73044: PUSH
73045: LD_INT 120
73047: PUSH
73048: LD_INT 70
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: LIST
73055: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
73056: LD_VAR 0 6
73060: PPUSH
73061: CALL_OW 264
73065: PUSH
73066: LD_INT 7
73068: PUSH
73069: LD_INT 28
73071: PUSH
73072: LD_INT 45
73074: PUSH
73075: LD_INT 92
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: IN
73084: IFFALSE 73105
// points := [ 35 , 20 , 45 ] ;
73086: LD_ADDR_VAR 0 9
73090: PUSH
73091: LD_INT 35
73093: PUSH
73094: LD_INT 20
73096: PUSH
73097: LD_INT 45
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: LIST
73104: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73105: LD_VAR 0 6
73109: PPUSH
73110: CALL_OW 264
73114: PUSH
73115: LD_INT 47
73117: PUSH
73118: EMPTY
73119: LIST
73120: IN
73121: IFFALSE 73142
// points := [ 67 , 45 , 75 ] ;
73123: LD_ADDR_VAR 0 9
73127: PUSH
73128: LD_INT 67
73130: PUSH
73131: LD_INT 45
73133: PUSH
73134: LD_INT 75
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73142: LD_VAR 0 6
73146: PPUSH
73147: CALL_OW 264
73151: PUSH
73152: LD_INT 26
73154: PUSH
73155: EMPTY
73156: LIST
73157: IN
73158: IFFALSE 73179
// points := [ 120 , 30 , 80 ] ;
73160: LD_ADDR_VAR 0 9
73164: PUSH
73165: LD_INT 120
73167: PUSH
73168: LD_INT 30
73170: PUSH
73171: LD_INT 80
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: LIST
73178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73179: LD_VAR 0 6
73183: PPUSH
73184: CALL_OW 264
73188: PUSH
73189: LD_INT 22
73191: PUSH
73192: EMPTY
73193: LIST
73194: IN
73195: IFFALSE 73216
// points := [ 40 , 1 , 1 ] ;
73197: LD_ADDR_VAR 0 9
73201: PUSH
73202: LD_INT 40
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 1
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: LIST
73215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73216: LD_VAR 0 6
73220: PPUSH
73221: CALL_OW 264
73225: PUSH
73226: LD_INT 29
73228: PUSH
73229: EMPTY
73230: LIST
73231: IN
73232: IFFALSE 73253
// points := [ 70 , 200 , 400 ] ;
73234: LD_ADDR_VAR 0 9
73238: PUSH
73239: LD_INT 70
73241: PUSH
73242: LD_INT 200
73244: PUSH
73245: LD_INT 400
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: LIST
73252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73253: LD_VAR 0 6
73257: PPUSH
73258: CALL_OW 264
73262: PUSH
73263: LD_INT 14
73265: PUSH
73266: LD_INT 53
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: IN
73273: IFFALSE 73294
// points := [ 40 , 10 , 20 ] ;
73275: LD_ADDR_VAR 0 9
73279: PUSH
73280: LD_INT 40
73282: PUSH
73283: LD_INT 10
73285: PUSH
73286: LD_INT 20
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: LIST
73293: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73294: LD_VAR 0 6
73298: PPUSH
73299: CALL_OW 264
73303: PUSH
73304: LD_INT 9
73306: PUSH
73307: EMPTY
73308: LIST
73309: IN
73310: IFFALSE 73331
// points := [ 5 , 70 , 20 ] ;
73312: LD_ADDR_VAR 0 9
73316: PUSH
73317: LD_INT 5
73319: PUSH
73320: LD_INT 70
73322: PUSH
73323: LD_INT 20
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: LIST
73330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73331: LD_VAR 0 6
73335: PPUSH
73336: CALL_OW 264
73340: PUSH
73341: LD_INT 10
73343: PUSH
73344: EMPTY
73345: LIST
73346: IN
73347: IFFALSE 73368
// points := [ 35 , 110 , 70 ] ;
73349: LD_ADDR_VAR 0 9
73353: PUSH
73354: LD_INT 35
73356: PUSH
73357: LD_INT 110
73359: PUSH
73360: LD_INT 70
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: LIST
73367: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73368: LD_VAR 0 6
73372: PPUSH
73373: CALL_OW 265
73377: PUSH
73378: LD_INT 25
73380: EQUAL
73381: IFFALSE 73402
// points := [ 80 , 65 , 100 ] ;
73383: LD_ADDR_VAR 0 9
73387: PUSH
73388: LD_INT 80
73390: PUSH
73391: LD_INT 65
73393: PUSH
73394: LD_INT 100
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: LIST
73401: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73402: LD_VAR 0 6
73406: PPUSH
73407: CALL_OW 263
73411: PUSH
73412: LD_INT 1
73414: EQUAL
73415: IFFALSE 73450
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73417: LD_ADDR_VAR 0 10
73421: PUSH
73422: LD_VAR 0 10
73426: PUSH
73427: LD_VAR 0 6
73431: PPUSH
73432: CALL_OW 311
73436: PPUSH
73437: LD_INT 3
73439: PPUSH
73440: CALL_OW 259
73444: PUSH
73445: LD_INT 4
73447: MUL
73448: MUL
73449: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73450: LD_VAR 0 6
73454: PPUSH
73455: CALL_OW 263
73459: PUSH
73460: LD_INT 2
73462: EQUAL
73463: IFFALSE 73514
// begin j := IsControledBy ( i ) ;
73465: LD_ADDR_VAR 0 7
73469: PUSH
73470: LD_VAR 0 6
73474: PPUSH
73475: CALL_OW 312
73479: ST_TO_ADDR
// if j then
73480: LD_VAR 0 7
73484: IFFALSE 73514
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73486: LD_ADDR_VAR 0 10
73490: PUSH
73491: LD_VAR 0 10
73495: PUSH
73496: LD_VAR 0 7
73500: PPUSH
73501: LD_INT 3
73503: PPUSH
73504: CALL_OW 259
73508: PUSH
73509: LD_INT 3
73511: MUL
73512: MUL
73513: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73514: LD_VAR 0 6
73518: PPUSH
73519: CALL_OW 264
73523: PUSH
73524: LD_INT 5
73526: PUSH
73527: LD_INT 6
73529: PUSH
73530: LD_INT 46
73532: PUSH
73533: LD_INT 44
73535: PUSH
73536: LD_INT 47
73538: PUSH
73539: LD_INT 45
73541: PUSH
73542: LD_INT 28
73544: PUSH
73545: LD_INT 7
73547: PUSH
73548: LD_INT 27
73550: PUSH
73551: LD_INT 29
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: IN
73566: PUSH
73567: LD_VAR 0 1
73571: PPUSH
73572: LD_INT 52
73574: PPUSH
73575: CALL_OW 321
73579: PUSH
73580: LD_INT 2
73582: EQUAL
73583: AND
73584: IFFALSE 73601
// bpoints := bpoints * 1.2 ;
73586: LD_ADDR_VAR 0 10
73590: PUSH
73591: LD_VAR 0 10
73595: PUSH
73596: LD_REAL  1.20000000000000E+0000
73599: MUL
73600: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73601: LD_VAR 0 6
73605: PPUSH
73606: CALL_OW 264
73610: PUSH
73611: LD_INT 6
73613: PUSH
73614: LD_INT 46
73616: PUSH
73617: LD_INT 47
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: LIST
73624: IN
73625: IFFALSE 73642
// bpoints := bpoints * 1.2 ;
73627: LD_ADDR_VAR 0 10
73631: PUSH
73632: LD_VAR 0 10
73636: PUSH
73637: LD_REAL  1.20000000000000E+0000
73640: MUL
73641: ST_TO_ADDR
// end ; unit_building :
73642: GO 73656
73644: LD_INT 3
73646: DOUBLE
73647: EQUAL
73648: IFTRUE 73652
73650: GO 73655
73652: POP
// ; end ;
73653: GO 73656
73655: POP
// for j = 1 to 3 do
73656: LD_ADDR_VAR 0 7
73660: PUSH
73661: DOUBLE
73662: LD_INT 1
73664: DEC
73665: ST_TO_ADDR
73666: LD_INT 3
73668: PUSH
73669: FOR_TO
73670: IFFALSE 73723
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73672: LD_ADDR_VAR 0 5
73676: PUSH
73677: LD_VAR 0 5
73681: PPUSH
73682: LD_VAR 0 7
73686: PPUSH
73687: LD_VAR 0 5
73691: PUSH
73692: LD_VAR 0 7
73696: ARRAY
73697: PUSH
73698: LD_VAR 0 9
73702: PUSH
73703: LD_VAR 0 7
73707: ARRAY
73708: PUSH
73709: LD_VAR 0 10
73713: MUL
73714: PLUS
73715: PPUSH
73716: CALL_OW 1
73720: ST_TO_ADDR
73721: GO 73669
73723: POP
73724: POP
// end ;
73725: GO 72204
73727: POP
73728: POP
// result := Replace ( result , 4 , tmp ) ;
73729: LD_ADDR_VAR 0 5
73733: PUSH
73734: LD_VAR 0 5
73738: PPUSH
73739: LD_INT 4
73741: PPUSH
73742: LD_VAR 0 8
73746: PPUSH
73747: CALL_OW 1
73751: ST_TO_ADDR
// end ;
73752: LD_VAR 0 5
73756: RET
// export function DangerAtRange ( unit , range ) ; begin
73757: LD_INT 0
73759: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73760: LD_ADDR_VAR 0 3
73764: PUSH
73765: LD_VAR 0 1
73769: PPUSH
73770: CALL_OW 255
73774: PPUSH
73775: LD_VAR 0 1
73779: PPUSH
73780: CALL_OW 250
73784: PPUSH
73785: LD_VAR 0 1
73789: PPUSH
73790: CALL_OW 251
73794: PPUSH
73795: LD_VAR 0 2
73799: PPUSH
73800: CALL 72056 0 4
73804: ST_TO_ADDR
// end ;
73805: LD_VAR 0 3
73809: RET
// export function DangerInArea ( side , area ) ; begin
73810: LD_INT 0
73812: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73813: LD_ADDR_VAR 0 3
73817: PUSH
73818: LD_VAR 0 2
73822: PPUSH
73823: LD_INT 81
73825: PUSH
73826: LD_VAR 0 1
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PPUSH
73835: CALL_OW 70
73839: ST_TO_ADDR
// end ;
73840: LD_VAR 0 3
73844: RET
// export function IsExtension ( b ) ; begin
73845: LD_INT 0
73847: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73848: LD_ADDR_VAR 0 2
73852: PUSH
73853: LD_VAR 0 1
73857: PUSH
73858: LD_INT 23
73860: PUSH
73861: LD_INT 20
73863: PUSH
73864: LD_INT 22
73866: PUSH
73867: LD_INT 17
73869: PUSH
73870: LD_INT 24
73872: PUSH
73873: LD_INT 21
73875: PUSH
73876: LD_INT 19
73878: PUSH
73879: LD_INT 16
73881: PUSH
73882: LD_INT 25
73884: PUSH
73885: LD_INT 18
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: IN
73900: ST_TO_ADDR
// end ;
73901: LD_VAR 0 2
73905: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73906: LD_INT 0
73908: PPUSH
73909: PPUSH
73910: PPUSH
// result := [ ] ;
73911: LD_ADDR_VAR 0 4
73915: PUSH
73916: EMPTY
73917: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73918: LD_ADDR_VAR 0 5
73922: PUSH
73923: LD_VAR 0 2
73927: PPUSH
73928: LD_INT 21
73930: PUSH
73931: LD_INT 3
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PPUSH
73938: CALL_OW 70
73942: ST_TO_ADDR
// if not tmp then
73943: LD_VAR 0 5
73947: NOT
73948: IFFALSE 73952
// exit ;
73950: GO 74016
// if checkLink then
73952: LD_VAR 0 3
73956: IFFALSE 74006
// begin for i in tmp do
73958: LD_ADDR_VAR 0 6
73962: PUSH
73963: LD_VAR 0 5
73967: PUSH
73968: FOR_IN
73969: IFFALSE 74004
// if GetBase ( i ) <> base then
73971: LD_VAR 0 6
73975: PPUSH
73976: CALL_OW 274
73980: PUSH
73981: LD_VAR 0 1
73985: NONEQUAL
73986: IFFALSE 74002
// ComLinkToBase ( base , i ) ;
73988: LD_VAR 0 1
73992: PPUSH
73993: LD_VAR 0 6
73997: PPUSH
73998: CALL_OW 169
74002: GO 73968
74004: POP
74005: POP
// end ; result := tmp ;
74006: LD_ADDR_VAR 0 4
74010: PUSH
74011: LD_VAR 0 5
74015: ST_TO_ADDR
// end ;
74016: LD_VAR 0 4
74020: RET
// export function ComComplete ( units , b ) ; var i ; begin
74021: LD_INT 0
74023: PPUSH
74024: PPUSH
// if not units then
74025: LD_VAR 0 1
74029: NOT
74030: IFFALSE 74034
// exit ;
74032: GO 74124
// for i in units do
74034: LD_ADDR_VAR 0 4
74038: PUSH
74039: LD_VAR 0 1
74043: PUSH
74044: FOR_IN
74045: IFFALSE 74122
// if BuildingStatus ( b ) = bs_build then
74047: LD_VAR 0 2
74051: PPUSH
74052: CALL_OW 461
74056: PUSH
74057: LD_INT 1
74059: EQUAL
74060: IFFALSE 74120
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74062: LD_VAR 0 4
74066: PPUSH
74067: LD_STRING h
74069: PUSH
74070: LD_VAR 0 2
74074: PPUSH
74075: CALL_OW 250
74079: PUSH
74080: LD_VAR 0 2
74084: PPUSH
74085: CALL_OW 251
74089: PUSH
74090: LD_VAR 0 2
74094: PUSH
74095: LD_INT 0
74097: PUSH
74098: LD_INT 0
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: LIST
74108: LIST
74109: LIST
74110: LIST
74111: LIST
74112: PUSH
74113: EMPTY
74114: LIST
74115: PPUSH
74116: CALL_OW 446
74120: GO 74044
74122: POP
74123: POP
// end ;
74124: LD_VAR 0 3
74128: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74129: LD_INT 0
74131: PPUSH
74132: PPUSH
74133: PPUSH
74134: PPUSH
74135: PPUSH
74136: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
74137: LD_VAR 0 1
74141: NOT
74142: PUSH
74143: LD_VAR 0 1
74147: PPUSH
74148: CALL_OW 263
74152: PUSH
74153: LD_INT 2
74155: NONEQUAL
74156: OR
74157: IFFALSE 74161
// exit ;
74159: GO 74477
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74161: LD_ADDR_VAR 0 6
74165: PUSH
74166: LD_INT 22
74168: PUSH
74169: LD_VAR 0 1
74173: PPUSH
74174: CALL_OW 255
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 2
74185: PUSH
74186: LD_INT 30
74188: PUSH
74189: LD_INT 36
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 34
74198: PUSH
74199: LD_INT 31
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: LIST
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: PPUSH
74215: CALL_OW 69
74219: ST_TO_ADDR
// if not tmp then
74220: LD_VAR 0 6
74224: NOT
74225: IFFALSE 74229
// exit ;
74227: GO 74477
// result := [ ] ;
74229: LD_ADDR_VAR 0 2
74233: PUSH
74234: EMPTY
74235: ST_TO_ADDR
// for i in tmp do
74236: LD_ADDR_VAR 0 3
74240: PUSH
74241: LD_VAR 0 6
74245: PUSH
74246: FOR_IN
74247: IFFALSE 74318
// begin t := UnitsInside ( i ) ;
74249: LD_ADDR_VAR 0 4
74253: PUSH
74254: LD_VAR 0 3
74258: PPUSH
74259: CALL_OW 313
74263: ST_TO_ADDR
// if t then
74264: LD_VAR 0 4
74268: IFFALSE 74316
// for j in t do
74270: LD_ADDR_VAR 0 7
74274: PUSH
74275: LD_VAR 0 4
74279: PUSH
74280: FOR_IN
74281: IFFALSE 74314
// result := Replace ( result , result + 1 , j ) ;
74283: LD_ADDR_VAR 0 2
74287: PUSH
74288: LD_VAR 0 2
74292: PPUSH
74293: LD_VAR 0 2
74297: PUSH
74298: LD_INT 1
74300: PLUS
74301: PPUSH
74302: LD_VAR 0 7
74306: PPUSH
74307: CALL_OW 1
74311: ST_TO_ADDR
74312: GO 74280
74314: POP
74315: POP
// end ;
74316: GO 74246
74318: POP
74319: POP
// if not result then
74320: LD_VAR 0 2
74324: NOT
74325: IFFALSE 74329
// exit ;
74327: GO 74477
// mech := result [ 1 ] ;
74329: LD_ADDR_VAR 0 5
74333: PUSH
74334: LD_VAR 0 2
74338: PUSH
74339: LD_INT 1
74341: ARRAY
74342: ST_TO_ADDR
// if result > 1 then
74343: LD_VAR 0 2
74347: PUSH
74348: LD_INT 1
74350: GREATER
74351: IFFALSE 74463
// begin for i = 2 to result do
74353: LD_ADDR_VAR 0 3
74357: PUSH
74358: DOUBLE
74359: LD_INT 2
74361: DEC
74362: ST_TO_ADDR
74363: LD_VAR 0 2
74367: PUSH
74368: FOR_TO
74369: IFFALSE 74461
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74371: LD_ADDR_VAR 0 4
74375: PUSH
74376: LD_VAR 0 2
74380: PUSH
74381: LD_VAR 0 3
74385: ARRAY
74386: PPUSH
74387: LD_INT 3
74389: PPUSH
74390: CALL_OW 259
74394: PUSH
74395: LD_VAR 0 2
74399: PUSH
74400: LD_VAR 0 3
74404: ARRAY
74405: PPUSH
74406: CALL_OW 432
74410: MINUS
74411: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74412: LD_VAR 0 4
74416: PUSH
74417: LD_VAR 0 5
74421: PPUSH
74422: LD_INT 3
74424: PPUSH
74425: CALL_OW 259
74429: PUSH
74430: LD_VAR 0 5
74434: PPUSH
74435: CALL_OW 432
74439: MINUS
74440: GREATEREQUAL
74441: IFFALSE 74459
// mech := result [ i ] ;
74443: LD_ADDR_VAR 0 5
74447: PUSH
74448: LD_VAR 0 2
74452: PUSH
74453: LD_VAR 0 3
74457: ARRAY
74458: ST_TO_ADDR
// end ;
74459: GO 74368
74461: POP
74462: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74463: LD_VAR 0 1
74467: PPUSH
74468: LD_VAR 0 5
74472: PPUSH
74473: CALL_OW 135
// end ;
74477: LD_VAR 0 2
74481: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74482: LD_INT 0
74484: PPUSH
74485: PPUSH
74486: PPUSH
74487: PPUSH
74488: PPUSH
74489: PPUSH
74490: PPUSH
74491: PPUSH
74492: PPUSH
74493: PPUSH
74494: PPUSH
74495: PPUSH
74496: PPUSH
// result := [ ] ;
74497: LD_ADDR_VAR 0 7
74501: PUSH
74502: EMPTY
74503: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74504: LD_VAR 0 1
74508: PPUSH
74509: CALL_OW 266
74513: PUSH
74514: LD_INT 0
74516: PUSH
74517: LD_INT 1
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: IN
74524: NOT
74525: IFFALSE 74529
// exit ;
74527: GO 76163
// if name then
74529: LD_VAR 0 3
74533: IFFALSE 74549
// SetBName ( base_dep , name ) ;
74535: LD_VAR 0 1
74539: PPUSH
74540: LD_VAR 0 3
74544: PPUSH
74545: CALL_OW 500
// base := GetBase ( base_dep ) ;
74549: LD_ADDR_VAR 0 15
74553: PUSH
74554: LD_VAR 0 1
74558: PPUSH
74559: CALL_OW 274
74563: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74564: LD_ADDR_VAR 0 16
74568: PUSH
74569: LD_VAR 0 1
74573: PPUSH
74574: CALL_OW 255
74578: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74579: LD_ADDR_VAR 0 17
74583: PUSH
74584: LD_VAR 0 1
74588: PPUSH
74589: CALL_OW 248
74593: ST_TO_ADDR
// if sources then
74594: LD_VAR 0 5
74598: IFFALSE 74645
// for i = 1 to 3 do
74600: LD_ADDR_VAR 0 8
74604: PUSH
74605: DOUBLE
74606: LD_INT 1
74608: DEC
74609: ST_TO_ADDR
74610: LD_INT 3
74612: PUSH
74613: FOR_TO
74614: IFFALSE 74643
// AddResourceType ( base , i , sources [ i ] ) ;
74616: LD_VAR 0 15
74620: PPUSH
74621: LD_VAR 0 8
74625: PPUSH
74626: LD_VAR 0 5
74630: PUSH
74631: LD_VAR 0 8
74635: ARRAY
74636: PPUSH
74637: CALL_OW 276
74641: GO 74613
74643: POP
74644: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74645: LD_ADDR_VAR 0 18
74649: PUSH
74650: LD_VAR 0 15
74654: PPUSH
74655: LD_VAR 0 2
74659: PPUSH
74660: LD_INT 1
74662: PPUSH
74663: CALL 73906 0 3
74667: ST_TO_ADDR
// InitHc ;
74668: CALL_OW 19
// InitUc ;
74672: CALL_OW 18
// uc_side := side ;
74676: LD_ADDR_OWVAR 20
74680: PUSH
74681: LD_VAR 0 16
74685: ST_TO_ADDR
// uc_nation := nation ;
74686: LD_ADDR_OWVAR 21
74690: PUSH
74691: LD_VAR 0 17
74695: ST_TO_ADDR
// if buildings then
74696: LD_VAR 0 18
74700: IFFALSE 76022
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74702: LD_ADDR_VAR 0 19
74706: PUSH
74707: LD_VAR 0 18
74711: PPUSH
74712: LD_INT 2
74714: PUSH
74715: LD_INT 30
74717: PUSH
74718: LD_INT 29
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 30
74727: PUSH
74728: LD_INT 30
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: LIST
74739: PPUSH
74740: CALL_OW 72
74744: ST_TO_ADDR
// if tmp then
74745: LD_VAR 0 19
74749: IFFALSE 74797
// for i in tmp do
74751: LD_ADDR_VAR 0 8
74755: PUSH
74756: LD_VAR 0 19
74760: PUSH
74761: FOR_IN
74762: IFFALSE 74795
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74764: LD_VAR 0 8
74768: PPUSH
74769: CALL_OW 250
74773: PPUSH
74774: LD_VAR 0 8
74778: PPUSH
74779: CALL_OW 251
74783: PPUSH
74784: LD_VAR 0 16
74788: PPUSH
74789: CALL_OW 441
74793: GO 74761
74795: POP
74796: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74797: LD_VAR 0 18
74801: PPUSH
74802: LD_INT 2
74804: PUSH
74805: LD_INT 30
74807: PUSH
74808: LD_INT 32
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 30
74817: PUSH
74818: LD_INT 33
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: LIST
74829: PPUSH
74830: CALL_OW 72
74834: IFFALSE 74922
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74836: LD_ADDR_VAR 0 8
74840: PUSH
74841: LD_VAR 0 18
74845: PPUSH
74846: LD_INT 2
74848: PUSH
74849: LD_INT 30
74851: PUSH
74852: LD_INT 32
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 30
74861: PUSH
74862: LD_INT 33
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: LIST
74873: PPUSH
74874: CALL_OW 72
74878: PUSH
74879: FOR_IN
74880: IFFALSE 74920
// begin if not GetBWeapon ( i ) then
74882: LD_VAR 0 8
74886: PPUSH
74887: CALL_OW 269
74891: NOT
74892: IFFALSE 74918
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74894: LD_VAR 0 8
74898: PPUSH
74899: LD_VAR 0 8
74903: PPUSH
74904: LD_VAR 0 2
74908: PPUSH
74909: CALL 76168 0 2
74913: PPUSH
74914: CALL_OW 431
// end ;
74918: GO 74879
74920: POP
74921: POP
// end ; for i = 1 to personel do
74922: LD_ADDR_VAR 0 8
74926: PUSH
74927: DOUBLE
74928: LD_INT 1
74930: DEC
74931: ST_TO_ADDR
74932: LD_VAR 0 6
74936: PUSH
74937: FOR_TO
74938: IFFALSE 76002
// begin if i > 4 then
74940: LD_VAR 0 8
74944: PUSH
74945: LD_INT 4
74947: GREATER
74948: IFFALSE 74952
// break ;
74950: GO 76002
// case i of 1 :
74952: LD_VAR 0 8
74956: PUSH
74957: LD_INT 1
74959: DOUBLE
74960: EQUAL
74961: IFTRUE 74965
74963: GO 75045
74965: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74966: LD_ADDR_VAR 0 12
74970: PUSH
74971: LD_VAR 0 18
74975: PPUSH
74976: LD_INT 22
74978: PUSH
74979: LD_VAR 0 16
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 58
74990: PUSH
74991: EMPTY
74992: LIST
74993: PUSH
74994: LD_INT 2
74996: PUSH
74997: LD_INT 30
74999: PUSH
75000: LD_INT 32
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 30
75009: PUSH
75010: LD_INT 4
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 30
75019: PUSH
75020: LD_INT 5
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: LIST
75037: PPUSH
75038: CALL_OW 72
75042: ST_TO_ADDR
75043: GO 75267
75045: LD_INT 2
75047: DOUBLE
75048: EQUAL
75049: IFTRUE 75053
75051: GO 75115
75053: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75054: LD_ADDR_VAR 0 12
75058: PUSH
75059: LD_VAR 0 18
75063: PPUSH
75064: LD_INT 22
75066: PUSH
75067: LD_VAR 0 16
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 2
75078: PUSH
75079: LD_INT 30
75081: PUSH
75082: LD_INT 0
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 30
75091: PUSH
75092: LD_INT 1
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: LIST
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PPUSH
75108: CALL_OW 72
75112: ST_TO_ADDR
75113: GO 75267
75115: LD_INT 3
75117: DOUBLE
75118: EQUAL
75119: IFTRUE 75123
75121: GO 75185
75123: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75124: LD_ADDR_VAR 0 12
75128: PUSH
75129: LD_VAR 0 18
75133: PPUSH
75134: LD_INT 22
75136: PUSH
75137: LD_VAR 0 16
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 2
75148: PUSH
75149: LD_INT 30
75151: PUSH
75152: LD_INT 2
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 30
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PPUSH
75178: CALL_OW 72
75182: ST_TO_ADDR
75183: GO 75267
75185: LD_INT 4
75187: DOUBLE
75188: EQUAL
75189: IFTRUE 75193
75191: GO 75266
75193: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75194: LD_ADDR_VAR 0 12
75198: PUSH
75199: LD_VAR 0 18
75203: PPUSH
75204: LD_INT 22
75206: PUSH
75207: LD_VAR 0 16
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 2
75218: PUSH
75219: LD_INT 30
75221: PUSH
75222: LD_INT 6
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 30
75231: PUSH
75232: LD_INT 7
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 30
75241: PUSH
75242: LD_INT 8
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: LIST
75253: LIST
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PPUSH
75259: CALL_OW 72
75263: ST_TO_ADDR
75264: GO 75267
75266: POP
// if i = 1 then
75267: LD_VAR 0 8
75271: PUSH
75272: LD_INT 1
75274: EQUAL
75275: IFFALSE 75386
// begin tmp := [ ] ;
75277: LD_ADDR_VAR 0 19
75281: PUSH
75282: EMPTY
75283: ST_TO_ADDR
// for j in f do
75284: LD_ADDR_VAR 0 9
75288: PUSH
75289: LD_VAR 0 12
75293: PUSH
75294: FOR_IN
75295: IFFALSE 75368
// if GetBType ( j ) = b_bunker then
75297: LD_VAR 0 9
75301: PPUSH
75302: CALL_OW 266
75306: PUSH
75307: LD_INT 32
75309: EQUAL
75310: IFFALSE 75337
// tmp := Insert ( tmp , 1 , j ) else
75312: LD_ADDR_VAR 0 19
75316: PUSH
75317: LD_VAR 0 19
75321: PPUSH
75322: LD_INT 1
75324: PPUSH
75325: LD_VAR 0 9
75329: PPUSH
75330: CALL_OW 2
75334: ST_TO_ADDR
75335: GO 75366
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75337: LD_ADDR_VAR 0 19
75341: PUSH
75342: LD_VAR 0 19
75346: PPUSH
75347: LD_VAR 0 19
75351: PUSH
75352: LD_INT 1
75354: PLUS
75355: PPUSH
75356: LD_VAR 0 9
75360: PPUSH
75361: CALL_OW 2
75365: ST_TO_ADDR
75366: GO 75294
75368: POP
75369: POP
// if tmp then
75370: LD_VAR 0 19
75374: IFFALSE 75386
// f := tmp ;
75376: LD_ADDR_VAR 0 12
75380: PUSH
75381: LD_VAR 0 19
75385: ST_TO_ADDR
// end ; x := personel [ i ] ;
75386: LD_ADDR_VAR 0 13
75390: PUSH
75391: LD_VAR 0 6
75395: PUSH
75396: LD_VAR 0 8
75400: ARRAY
75401: ST_TO_ADDR
// if x = - 1 then
75402: LD_VAR 0 13
75406: PUSH
75407: LD_INT 1
75409: NEG
75410: EQUAL
75411: IFFALSE 75620
// begin for j in f do
75413: LD_ADDR_VAR 0 9
75417: PUSH
75418: LD_VAR 0 12
75422: PUSH
75423: FOR_IN
75424: IFFALSE 75616
// repeat InitHc ;
75426: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75430: LD_VAR 0 9
75434: PPUSH
75435: CALL_OW 266
75439: PUSH
75440: LD_INT 5
75442: EQUAL
75443: IFFALSE 75513
// begin if UnitsInside ( j ) < 3 then
75445: LD_VAR 0 9
75449: PPUSH
75450: CALL_OW 313
75454: PUSH
75455: LD_INT 3
75457: LESS
75458: IFFALSE 75494
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75460: LD_INT 0
75462: PPUSH
75463: LD_INT 5
75465: PUSH
75466: LD_INT 8
75468: PUSH
75469: LD_INT 9
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: LIST
75476: PUSH
75477: LD_VAR 0 17
75481: ARRAY
75482: PPUSH
75483: LD_VAR 0 4
75487: PPUSH
75488: CALL_OW 380
75492: GO 75511
// PrepareHuman ( false , i , skill ) ;
75494: LD_INT 0
75496: PPUSH
75497: LD_VAR 0 8
75501: PPUSH
75502: LD_VAR 0 4
75506: PPUSH
75507: CALL_OW 380
// end else
75511: GO 75530
// PrepareHuman ( false , i , skill ) ;
75513: LD_INT 0
75515: PPUSH
75516: LD_VAR 0 8
75520: PPUSH
75521: LD_VAR 0 4
75525: PPUSH
75526: CALL_OW 380
// un := CreateHuman ;
75530: LD_ADDR_VAR 0 14
75534: PUSH
75535: CALL_OW 44
75539: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75540: LD_ADDR_VAR 0 7
75544: PUSH
75545: LD_VAR 0 7
75549: PPUSH
75550: LD_INT 1
75552: PPUSH
75553: LD_VAR 0 14
75557: PPUSH
75558: CALL_OW 2
75562: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75563: LD_VAR 0 14
75567: PPUSH
75568: LD_VAR 0 9
75572: PPUSH
75573: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75577: LD_VAR 0 9
75581: PPUSH
75582: CALL_OW 313
75586: PUSH
75587: LD_INT 6
75589: EQUAL
75590: PUSH
75591: LD_VAR 0 9
75595: PPUSH
75596: CALL_OW 266
75600: PUSH
75601: LD_INT 32
75603: PUSH
75604: LD_INT 31
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: IN
75611: OR
75612: IFFALSE 75426
75614: GO 75423
75616: POP
75617: POP
// end else
75618: GO 76000
// for j = 1 to x do
75620: LD_ADDR_VAR 0 9
75624: PUSH
75625: DOUBLE
75626: LD_INT 1
75628: DEC
75629: ST_TO_ADDR
75630: LD_VAR 0 13
75634: PUSH
75635: FOR_TO
75636: IFFALSE 75998
// begin InitHc ;
75638: CALL_OW 19
// if not f then
75642: LD_VAR 0 12
75646: NOT
75647: IFFALSE 75736
// begin PrepareHuman ( false , i , skill ) ;
75649: LD_INT 0
75651: PPUSH
75652: LD_VAR 0 8
75656: PPUSH
75657: LD_VAR 0 4
75661: PPUSH
75662: CALL_OW 380
// un := CreateHuman ;
75666: LD_ADDR_VAR 0 14
75670: PUSH
75671: CALL_OW 44
75675: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75676: LD_ADDR_VAR 0 7
75680: PUSH
75681: LD_VAR 0 7
75685: PPUSH
75686: LD_INT 1
75688: PPUSH
75689: LD_VAR 0 14
75693: PPUSH
75694: CALL_OW 2
75698: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75699: LD_VAR 0 14
75703: PPUSH
75704: LD_VAR 0 1
75708: PPUSH
75709: CALL_OW 250
75713: PPUSH
75714: LD_VAR 0 1
75718: PPUSH
75719: CALL_OW 251
75723: PPUSH
75724: LD_INT 10
75726: PPUSH
75727: LD_INT 0
75729: PPUSH
75730: CALL_OW 50
// continue ;
75734: GO 75635
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75736: LD_VAR 0 12
75740: PUSH
75741: LD_INT 1
75743: ARRAY
75744: PPUSH
75745: CALL_OW 313
75749: PUSH
75750: LD_VAR 0 12
75754: PUSH
75755: LD_INT 1
75757: ARRAY
75758: PPUSH
75759: CALL_OW 266
75763: PUSH
75764: LD_INT 32
75766: PUSH
75767: LD_INT 31
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: IN
75774: AND
75775: PUSH
75776: LD_VAR 0 12
75780: PUSH
75781: LD_INT 1
75783: ARRAY
75784: PPUSH
75785: CALL_OW 313
75789: PUSH
75790: LD_INT 6
75792: EQUAL
75793: OR
75794: IFFALSE 75814
// f := Delete ( f , 1 ) ;
75796: LD_ADDR_VAR 0 12
75800: PUSH
75801: LD_VAR 0 12
75805: PPUSH
75806: LD_INT 1
75808: PPUSH
75809: CALL_OW 3
75813: ST_TO_ADDR
// if not f then
75814: LD_VAR 0 12
75818: NOT
75819: IFFALSE 75837
// begin x := x + 2 ;
75821: LD_ADDR_VAR 0 13
75825: PUSH
75826: LD_VAR 0 13
75830: PUSH
75831: LD_INT 2
75833: PLUS
75834: ST_TO_ADDR
// continue ;
75835: GO 75635
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75837: LD_VAR 0 12
75841: PUSH
75842: LD_INT 1
75844: ARRAY
75845: PPUSH
75846: CALL_OW 266
75850: PUSH
75851: LD_INT 5
75853: EQUAL
75854: IFFALSE 75928
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75856: LD_VAR 0 12
75860: PUSH
75861: LD_INT 1
75863: ARRAY
75864: PPUSH
75865: CALL_OW 313
75869: PUSH
75870: LD_INT 3
75872: LESS
75873: IFFALSE 75909
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75875: LD_INT 0
75877: PPUSH
75878: LD_INT 5
75880: PUSH
75881: LD_INT 8
75883: PUSH
75884: LD_INT 9
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: LIST
75891: PUSH
75892: LD_VAR 0 17
75896: ARRAY
75897: PPUSH
75898: LD_VAR 0 4
75902: PPUSH
75903: CALL_OW 380
75907: GO 75926
// PrepareHuman ( false , i , skill ) ;
75909: LD_INT 0
75911: PPUSH
75912: LD_VAR 0 8
75916: PPUSH
75917: LD_VAR 0 4
75921: PPUSH
75922: CALL_OW 380
// end else
75926: GO 75945
// PrepareHuman ( false , i , skill ) ;
75928: LD_INT 0
75930: PPUSH
75931: LD_VAR 0 8
75935: PPUSH
75936: LD_VAR 0 4
75940: PPUSH
75941: CALL_OW 380
// un := CreateHuman ;
75945: LD_ADDR_VAR 0 14
75949: PUSH
75950: CALL_OW 44
75954: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75955: LD_ADDR_VAR 0 7
75959: PUSH
75960: LD_VAR 0 7
75964: PPUSH
75965: LD_INT 1
75967: PPUSH
75968: LD_VAR 0 14
75972: PPUSH
75973: CALL_OW 2
75977: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75978: LD_VAR 0 14
75982: PPUSH
75983: LD_VAR 0 12
75987: PUSH
75988: LD_INT 1
75990: ARRAY
75991: PPUSH
75992: CALL_OW 52
// end ;
75996: GO 75635
75998: POP
75999: POP
// end ;
76000: GO 74937
76002: POP
76003: POP
// result := result ^ buildings ;
76004: LD_ADDR_VAR 0 7
76008: PUSH
76009: LD_VAR 0 7
76013: PUSH
76014: LD_VAR 0 18
76018: ADD
76019: ST_TO_ADDR
// end else
76020: GO 76163
// begin for i = 1 to personel do
76022: LD_ADDR_VAR 0 8
76026: PUSH
76027: DOUBLE
76028: LD_INT 1
76030: DEC
76031: ST_TO_ADDR
76032: LD_VAR 0 6
76036: PUSH
76037: FOR_TO
76038: IFFALSE 76161
// begin if i > 4 then
76040: LD_VAR 0 8
76044: PUSH
76045: LD_INT 4
76047: GREATER
76048: IFFALSE 76052
// break ;
76050: GO 76161
// x := personel [ i ] ;
76052: LD_ADDR_VAR 0 13
76056: PUSH
76057: LD_VAR 0 6
76061: PUSH
76062: LD_VAR 0 8
76066: ARRAY
76067: ST_TO_ADDR
// if x = - 1 then
76068: LD_VAR 0 13
76072: PUSH
76073: LD_INT 1
76075: NEG
76076: EQUAL
76077: IFFALSE 76081
// continue ;
76079: GO 76037
// PrepareHuman ( false , i , skill ) ;
76081: LD_INT 0
76083: PPUSH
76084: LD_VAR 0 8
76088: PPUSH
76089: LD_VAR 0 4
76093: PPUSH
76094: CALL_OW 380
// un := CreateHuman ;
76098: LD_ADDR_VAR 0 14
76102: PUSH
76103: CALL_OW 44
76107: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76108: LD_VAR 0 14
76112: PPUSH
76113: LD_VAR 0 1
76117: PPUSH
76118: CALL_OW 250
76122: PPUSH
76123: LD_VAR 0 1
76127: PPUSH
76128: CALL_OW 251
76132: PPUSH
76133: LD_INT 10
76135: PPUSH
76136: LD_INT 0
76138: PPUSH
76139: CALL_OW 50
// result := result ^ un ;
76143: LD_ADDR_VAR 0 7
76147: PUSH
76148: LD_VAR 0 7
76152: PUSH
76153: LD_VAR 0 14
76157: ADD
76158: ST_TO_ADDR
// end ;
76159: GO 76037
76161: POP
76162: POP
// end ; end ;
76163: LD_VAR 0 7
76167: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76168: LD_INT 0
76170: PPUSH
76171: PPUSH
76172: PPUSH
76173: PPUSH
76174: PPUSH
76175: PPUSH
76176: PPUSH
76177: PPUSH
76178: PPUSH
76179: PPUSH
76180: PPUSH
76181: PPUSH
76182: PPUSH
76183: PPUSH
76184: PPUSH
76185: PPUSH
// result := false ;
76186: LD_ADDR_VAR 0 3
76190: PUSH
76191: LD_INT 0
76193: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76194: LD_VAR 0 1
76198: NOT
76199: PUSH
76200: LD_VAR 0 1
76204: PPUSH
76205: CALL_OW 266
76209: PUSH
76210: LD_INT 32
76212: PUSH
76213: LD_INT 33
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: IN
76220: NOT
76221: OR
76222: IFFALSE 76226
// exit ;
76224: GO 77335
// nat := GetNation ( tower ) ;
76226: LD_ADDR_VAR 0 12
76230: PUSH
76231: LD_VAR 0 1
76235: PPUSH
76236: CALL_OW 248
76240: ST_TO_ADDR
// side := GetSide ( tower ) ;
76241: LD_ADDR_VAR 0 16
76245: PUSH
76246: LD_VAR 0 1
76250: PPUSH
76251: CALL_OW 255
76255: ST_TO_ADDR
// x := GetX ( tower ) ;
76256: LD_ADDR_VAR 0 10
76260: PUSH
76261: LD_VAR 0 1
76265: PPUSH
76266: CALL_OW 250
76270: ST_TO_ADDR
// y := GetY ( tower ) ;
76271: LD_ADDR_VAR 0 11
76275: PUSH
76276: LD_VAR 0 1
76280: PPUSH
76281: CALL_OW 251
76285: ST_TO_ADDR
// if not x or not y then
76286: LD_VAR 0 10
76290: NOT
76291: PUSH
76292: LD_VAR 0 11
76296: NOT
76297: OR
76298: IFFALSE 76302
// exit ;
76300: GO 77335
// weapon := 0 ;
76302: LD_ADDR_VAR 0 18
76306: PUSH
76307: LD_INT 0
76309: ST_TO_ADDR
// fac_list := [ ] ;
76310: LD_ADDR_VAR 0 17
76314: PUSH
76315: EMPTY
76316: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76317: LD_ADDR_VAR 0 6
76321: PUSH
76322: LD_VAR 0 1
76326: PPUSH
76327: CALL_OW 274
76331: PPUSH
76332: LD_VAR 0 2
76336: PPUSH
76337: LD_INT 0
76339: PPUSH
76340: CALL 73906 0 3
76344: PPUSH
76345: LD_INT 30
76347: PUSH
76348: LD_INT 3
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PPUSH
76355: CALL_OW 72
76359: ST_TO_ADDR
// if not factories then
76360: LD_VAR 0 6
76364: NOT
76365: IFFALSE 76369
// exit ;
76367: GO 77335
// for i in factories do
76369: LD_ADDR_VAR 0 8
76373: PUSH
76374: LD_VAR 0 6
76378: PUSH
76379: FOR_IN
76380: IFFALSE 76405
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76382: LD_ADDR_VAR 0 17
76386: PUSH
76387: LD_VAR 0 17
76391: PUSH
76392: LD_VAR 0 8
76396: PPUSH
76397: CALL_OW 478
76401: UNION
76402: ST_TO_ADDR
76403: GO 76379
76405: POP
76406: POP
// if not fac_list then
76407: LD_VAR 0 17
76411: NOT
76412: IFFALSE 76416
// exit ;
76414: GO 77335
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76416: LD_ADDR_VAR 0 5
76420: PUSH
76421: LD_INT 4
76423: PUSH
76424: LD_INT 5
76426: PUSH
76427: LD_INT 9
76429: PUSH
76430: LD_INT 10
76432: PUSH
76433: LD_INT 6
76435: PUSH
76436: LD_INT 7
76438: PUSH
76439: LD_INT 11
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 27
76453: PUSH
76454: LD_INT 28
76456: PUSH
76457: LD_INT 26
76459: PUSH
76460: LD_INT 30
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: PUSH
76469: LD_INT 43
76471: PUSH
76472: LD_INT 44
76474: PUSH
76475: LD_INT 46
76477: PUSH
76478: LD_INT 45
76480: PUSH
76481: LD_INT 47
76483: PUSH
76484: LD_INT 49
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: LIST
76499: PUSH
76500: LD_VAR 0 12
76504: ARRAY
76505: ST_TO_ADDR
// list := list isect fac_list ;
76506: LD_ADDR_VAR 0 5
76510: PUSH
76511: LD_VAR 0 5
76515: PUSH
76516: LD_VAR 0 17
76520: ISECT
76521: ST_TO_ADDR
// if not list then
76522: LD_VAR 0 5
76526: NOT
76527: IFFALSE 76531
// exit ;
76529: GO 77335
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76531: LD_VAR 0 12
76535: PUSH
76536: LD_INT 3
76538: EQUAL
76539: PUSH
76540: LD_INT 49
76542: PUSH
76543: LD_VAR 0 5
76547: IN
76548: AND
76549: PUSH
76550: LD_INT 31
76552: PPUSH
76553: LD_VAR 0 16
76557: PPUSH
76558: CALL_OW 321
76562: PUSH
76563: LD_INT 2
76565: EQUAL
76566: AND
76567: IFFALSE 76627
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76569: LD_INT 22
76571: PUSH
76572: LD_VAR 0 16
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 35
76583: PUSH
76584: LD_INT 49
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 91
76593: PUSH
76594: LD_VAR 0 1
76598: PUSH
76599: LD_INT 10
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: LIST
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: LIST
76611: PPUSH
76612: CALL_OW 69
76616: NOT
76617: IFFALSE 76627
// weapon := ru_time_lapser ;
76619: LD_ADDR_VAR 0 18
76623: PUSH
76624: LD_INT 49
76626: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76627: LD_VAR 0 12
76631: PUSH
76632: LD_INT 1
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: IN
76642: PUSH
76643: LD_INT 11
76645: PUSH
76646: LD_VAR 0 5
76650: IN
76651: PUSH
76652: LD_INT 30
76654: PUSH
76655: LD_VAR 0 5
76659: IN
76660: OR
76661: AND
76662: PUSH
76663: LD_INT 6
76665: PPUSH
76666: LD_VAR 0 16
76670: PPUSH
76671: CALL_OW 321
76675: PUSH
76676: LD_INT 2
76678: EQUAL
76679: AND
76680: IFFALSE 76845
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76682: LD_INT 22
76684: PUSH
76685: LD_VAR 0 16
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 2
76696: PUSH
76697: LD_INT 35
76699: PUSH
76700: LD_INT 11
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 35
76709: PUSH
76710: LD_INT 30
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 91
76724: PUSH
76725: LD_VAR 0 1
76729: PUSH
76730: LD_INT 18
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: LIST
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: LIST
76742: PPUSH
76743: CALL_OW 69
76747: NOT
76748: PUSH
76749: LD_INT 22
76751: PUSH
76752: LD_VAR 0 16
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 2
76763: PUSH
76764: LD_INT 30
76766: PUSH
76767: LD_INT 32
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 30
76776: PUSH
76777: LD_INT 33
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: PUSH
76789: LD_INT 91
76791: PUSH
76792: LD_VAR 0 1
76796: PUSH
76797: LD_INT 12
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: LIST
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: LIST
76809: PUSH
76810: EMPTY
76811: LIST
76812: PPUSH
76813: CALL_OW 69
76817: PUSH
76818: LD_INT 2
76820: GREATER
76821: AND
76822: IFFALSE 76845
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76824: LD_ADDR_VAR 0 18
76828: PUSH
76829: LD_INT 11
76831: PUSH
76832: LD_INT 30
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_VAR 0 12
76843: ARRAY
76844: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76845: LD_VAR 0 18
76849: NOT
76850: PUSH
76851: LD_INT 40
76853: PPUSH
76854: LD_VAR 0 16
76858: PPUSH
76859: CALL_OW 321
76863: PUSH
76864: LD_INT 2
76866: EQUAL
76867: AND
76868: PUSH
76869: LD_INT 7
76871: PUSH
76872: LD_VAR 0 5
76876: IN
76877: PUSH
76878: LD_INT 28
76880: PUSH
76881: LD_VAR 0 5
76885: IN
76886: OR
76887: PUSH
76888: LD_INT 45
76890: PUSH
76891: LD_VAR 0 5
76895: IN
76896: OR
76897: AND
76898: IFFALSE 77152
// begin hex := GetHexInfo ( x , y ) ;
76900: LD_ADDR_VAR 0 4
76904: PUSH
76905: LD_VAR 0 10
76909: PPUSH
76910: LD_VAR 0 11
76914: PPUSH
76915: CALL_OW 546
76919: ST_TO_ADDR
// if hex [ 1 ] then
76920: LD_VAR 0 4
76924: PUSH
76925: LD_INT 1
76927: ARRAY
76928: IFFALSE 76932
// exit ;
76930: GO 77335
// height := hex [ 2 ] ;
76932: LD_ADDR_VAR 0 15
76936: PUSH
76937: LD_VAR 0 4
76941: PUSH
76942: LD_INT 2
76944: ARRAY
76945: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76946: LD_ADDR_VAR 0 14
76950: PUSH
76951: LD_INT 0
76953: PUSH
76954: LD_INT 2
76956: PUSH
76957: LD_INT 3
76959: PUSH
76960: LD_INT 5
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: LIST
76967: LIST
76968: ST_TO_ADDR
// for i in tmp do
76969: LD_ADDR_VAR 0 8
76973: PUSH
76974: LD_VAR 0 14
76978: PUSH
76979: FOR_IN
76980: IFFALSE 77150
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76982: LD_ADDR_VAR 0 9
76986: PUSH
76987: LD_VAR 0 10
76991: PPUSH
76992: LD_VAR 0 8
76996: PPUSH
76997: LD_INT 5
76999: PPUSH
77000: CALL_OW 272
77004: PUSH
77005: LD_VAR 0 11
77009: PPUSH
77010: LD_VAR 0 8
77014: PPUSH
77015: LD_INT 5
77017: PPUSH
77018: CALL_OW 273
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77027: LD_VAR 0 9
77031: PUSH
77032: LD_INT 1
77034: ARRAY
77035: PPUSH
77036: LD_VAR 0 9
77040: PUSH
77041: LD_INT 2
77043: ARRAY
77044: PPUSH
77045: CALL_OW 488
77049: IFFALSE 77148
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77051: LD_ADDR_VAR 0 4
77055: PUSH
77056: LD_VAR 0 9
77060: PUSH
77061: LD_INT 1
77063: ARRAY
77064: PPUSH
77065: LD_VAR 0 9
77069: PUSH
77070: LD_INT 2
77072: ARRAY
77073: PPUSH
77074: CALL_OW 546
77078: ST_TO_ADDR
// if hex [ 1 ] then
77079: LD_VAR 0 4
77083: PUSH
77084: LD_INT 1
77086: ARRAY
77087: IFFALSE 77091
// continue ;
77089: GO 76979
// h := hex [ 2 ] ;
77091: LD_ADDR_VAR 0 13
77095: PUSH
77096: LD_VAR 0 4
77100: PUSH
77101: LD_INT 2
77103: ARRAY
77104: ST_TO_ADDR
// if h + 7 < height then
77105: LD_VAR 0 13
77109: PUSH
77110: LD_INT 7
77112: PLUS
77113: PUSH
77114: LD_VAR 0 15
77118: LESS
77119: IFFALSE 77148
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77121: LD_ADDR_VAR 0 18
77125: PUSH
77126: LD_INT 7
77128: PUSH
77129: LD_INT 28
77131: PUSH
77132: LD_INT 45
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: LIST
77139: PUSH
77140: LD_VAR 0 12
77144: ARRAY
77145: ST_TO_ADDR
// break ;
77146: GO 77150
// end ; end ; end ;
77148: GO 76979
77150: POP
77151: POP
// end ; if not weapon then
77152: LD_VAR 0 18
77156: NOT
77157: IFFALSE 77217
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77159: LD_ADDR_VAR 0 5
77163: PUSH
77164: LD_VAR 0 5
77168: PUSH
77169: LD_INT 11
77171: PUSH
77172: LD_INT 30
77174: PUSH
77175: LD_INT 49
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: LIST
77182: DIFF
77183: ST_TO_ADDR
// if not list then
77184: LD_VAR 0 5
77188: NOT
77189: IFFALSE 77193
// exit ;
77191: GO 77335
// weapon := list [ rand ( 1 , list ) ] ;
77193: LD_ADDR_VAR 0 18
77197: PUSH
77198: LD_VAR 0 5
77202: PUSH
77203: LD_INT 1
77205: PPUSH
77206: LD_VAR 0 5
77210: PPUSH
77211: CALL_OW 12
77215: ARRAY
77216: ST_TO_ADDR
// end ; if weapon then
77217: LD_VAR 0 18
77221: IFFALSE 77335
// begin tmp := CostOfWeapon ( weapon ) ;
77223: LD_ADDR_VAR 0 14
77227: PUSH
77228: LD_VAR 0 18
77232: PPUSH
77233: CALL_OW 451
77237: ST_TO_ADDR
// j := GetBase ( tower ) ;
77238: LD_ADDR_VAR 0 9
77242: PUSH
77243: LD_VAR 0 1
77247: PPUSH
77248: CALL_OW 274
77252: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77253: LD_VAR 0 9
77257: PPUSH
77258: LD_INT 1
77260: PPUSH
77261: CALL_OW 275
77265: PUSH
77266: LD_VAR 0 14
77270: PUSH
77271: LD_INT 1
77273: ARRAY
77274: GREATEREQUAL
77275: PUSH
77276: LD_VAR 0 9
77280: PPUSH
77281: LD_INT 2
77283: PPUSH
77284: CALL_OW 275
77288: PUSH
77289: LD_VAR 0 14
77293: PUSH
77294: LD_INT 2
77296: ARRAY
77297: GREATEREQUAL
77298: AND
77299: PUSH
77300: LD_VAR 0 9
77304: PPUSH
77305: LD_INT 3
77307: PPUSH
77308: CALL_OW 275
77312: PUSH
77313: LD_VAR 0 14
77317: PUSH
77318: LD_INT 3
77320: ARRAY
77321: GREATEREQUAL
77322: AND
77323: IFFALSE 77335
// result := weapon ;
77325: LD_ADDR_VAR 0 3
77329: PUSH
77330: LD_VAR 0 18
77334: ST_TO_ADDR
// end ; end ;
77335: LD_VAR 0 3
77339: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77340: LD_INT 0
77342: PPUSH
77343: PPUSH
// result := true ;
77344: LD_ADDR_VAR 0 3
77348: PUSH
77349: LD_INT 1
77351: ST_TO_ADDR
// if array1 = array2 then
77352: LD_VAR 0 1
77356: PUSH
77357: LD_VAR 0 2
77361: EQUAL
77362: IFFALSE 77422
// begin for i = 1 to array1 do
77364: LD_ADDR_VAR 0 4
77368: PUSH
77369: DOUBLE
77370: LD_INT 1
77372: DEC
77373: ST_TO_ADDR
77374: LD_VAR 0 1
77378: PUSH
77379: FOR_TO
77380: IFFALSE 77418
// if array1 [ i ] <> array2 [ i ] then
77382: LD_VAR 0 1
77386: PUSH
77387: LD_VAR 0 4
77391: ARRAY
77392: PUSH
77393: LD_VAR 0 2
77397: PUSH
77398: LD_VAR 0 4
77402: ARRAY
77403: NONEQUAL
77404: IFFALSE 77416
// begin result := false ;
77406: LD_ADDR_VAR 0 3
77410: PUSH
77411: LD_INT 0
77413: ST_TO_ADDR
// break ;
77414: GO 77418
// end ;
77416: GO 77379
77418: POP
77419: POP
// end else
77420: GO 77430
// result := false ;
77422: LD_ADDR_VAR 0 3
77426: PUSH
77427: LD_INT 0
77429: ST_TO_ADDR
// end ;
77430: LD_VAR 0 3
77434: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77435: LD_INT 0
77437: PPUSH
77438: PPUSH
// if not array1 or not array2 then
77439: LD_VAR 0 1
77443: NOT
77444: PUSH
77445: LD_VAR 0 2
77449: NOT
77450: OR
77451: IFFALSE 77455
// exit ;
77453: GO 77519
// result := true ;
77455: LD_ADDR_VAR 0 3
77459: PUSH
77460: LD_INT 1
77462: ST_TO_ADDR
// for i = 1 to array1 do
77463: LD_ADDR_VAR 0 4
77467: PUSH
77468: DOUBLE
77469: LD_INT 1
77471: DEC
77472: ST_TO_ADDR
77473: LD_VAR 0 1
77477: PUSH
77478: FOR_TO
77479: IFFALSE 77517
// if array1 [ i ] <> array2 [ i ] then
77481: LD_VAR 0 1
77485: PUSH
77486: LD_VAR 0 4
77490: ARRAY
77491: PUSH
77492: LD_VAR 0 2
77496: PUSH
77497: LD_VAR 0 4
77501: ARRAY
77502: NONEQUAL
77503: IFFALSE 77515
// begin result := false ;
77505: LD_ADDR_VAR 0 3
77509: PUSH
77510: LD_INT 0
77512: ST_TO_ADDR
// break ;
77513: GO 77517
// end ;
77515: GO 77478
77517: POP
77518: POP
// end ;
77519: LD_VAR 0 3
77523: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77524: LD_INT 0
77526: PPUSH
77527: PPUSH
77528: PPUSH
// pom := GetBase ( fac ) ;
77529: LD_ADDR_VAR 0 5
77533: PUSH
77534: LD_VAR 0 1
77538: PPUSH
77539: CALL_OW 274
77543: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77544: LD_ADDR_VAR 0 4
77548: PUSH
77549: LD_VAR 0 2
77553: PUSH
77554: LD_INT 1
77556: ARRAY
77557: PPUSH
77558: LD_VAR 0 2
77562: PUSH
77563: LD_INT 2
77565: ARRAY
77566: PPUSH
77567: LD_VAR 0 2
77571: PUSH
77572: LD_INT 3
77574: ARRAY
77575: PPUSH
77576: LD_VAR 0 2
77580: PUSH
77581: LD_INT 4
77583: ARRAY
77584: PPUSH
77585: CALL_OW 449
77589: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77590: LD_ADDR_VAR 0 3
77594: PUSH
77595: LD_VAR 0 5
77599: PPUSH
77600: LD_INT 1
77602: PPUSH
77603: CALL_OW 275
77607: PUSH
77608: LD_VAR 0 4
77612: PUSH
77613: LD_INT 1
77615: ARRAY
77616: GREATEREQUAL
77617: PUSH
77618: LD_VAR 0 5
77622: PPUSH
77623: LD_INT 2
77625: PPUSH
77626: CALL_OW 275
77630: PUSH
77631: LD_VAR 0 4
77635: PUSH
77636: LD_INT 2
77638: ARRAY
77639: GREATEREQUAL
77640: AND
77641: PUSH
77642: LD_VAR 0 5
77646: PPUSH
77647: LD_INT 3
77649: PPUSH
77650: CALL_OW 275
77654: PUSH
77655: LD_VAR 0 4
77659: PUSH
77660: LD_INT 3
77662: ARRAY
77663: GREATEREQUAL
77664: AND
77665: ST_TO_ADDR
// end ;
77666: LD_VAR 0 3
77670: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77671: LD_INT 0
77673: PPUSH
77674: PPUSH
77675: PPUSH
77676: PPUSH
// pom := GetBase ( building ) ;
77677: LD_ADDR_VAR 0 3
77681: PUSH
77682: LD_VAR 0 1
77686: PPUSH
77687: CALL_OW 274
77691: ST_TO_ADDR
// if not pom then
77692: LD_VAR 0 3
77696: NOT
77697: IFFALSE 77701
// exit ;
77699: GO 77871
// btype := GetBType ( building ) ;
77701: LD_ADDR_VAR 0 5
77705: PUSH
77706: LD_VAR 0 1
77710: PPUSH
77711: CALL_OW 266
77715: ST_TO_ADDR
// if btype = b_armoury then
77716: LD_VAR 0 5
77720: PUSH
77721: LD_INT 4
77723: EQUAL
77724: IFFALSE 77734
// btype := b_barracks ;
77726: LD_ADDR_VAR 0 5
77730: PUSH
77731: LD_INT 5
77733: ST_TO_ADDR
// if btype = b_depot then
77734: LD_VAR 0 5
77738: PUSH
77739: LD_INT 0
77741: EQUAL
77742: IFFALSE 77752
// btype := b_warehouse ;
77744: LD_ADDR_VAR 0 5
77748: PUSH
77749: LD_INT 1
77751: ST_TO_ADDR
// if btype = b_workshop then
77752: LD_VAR 0 5
77756: PUSH
77757: LD_INT 2
77759: EQUAL
77760: IFFALSE 77770
// btype := b_factory ;
77762: LD_ADDR_VAR 0 5
77766: PUSH
77767: LD_INT 3
77769: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77770: LD_ADDR_VAR 0 4
77774: PUSH
77775: LD_VAR 0 5
77779: PPUSH
77780: LD_VAR 0 1
77784: PPUSH
77785: CALL_OW 248
77789: PPUSH
77790: CALL_OW 450
77794: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77795: LD_ADDR_VAR 0 2
77799: PUSH
77800: LD_VAR 0 3
77804: PPUSH
77805: LD_INT 1
77807: PPUSH
77808: CALL_OW 275
77812: PUSH
77813: LD_VAR 0 4
77817: PUSH
77818: LD_INT 1
77820: ARRAY
77821: GREATEREQUAL
77822: PUSH
77823: LD_VAR 0 3
77827: PPUSH
77828: LD_INT 2
77830: PPUSH
77831: CALL_OW 275
77835: PUSH
77836: LD_VAR 0 4
77840: PUSH
77841: LD_INT 2
77843: ARRAY
77844: GREATEREQUAL
77845: AND
77846: PUSH
77847: LD_VAR 0 3
77851: PPUSH
77852: LD_INT 3
77854: PPUSH
77855: CALL_OW 275
77859: PUSH
77860: LD_VAR 0 4
77864: PUSH
77865: LD_INT 3
77867: ARRAY
77868: GREATEREQUAL
77869: AND
77870: ST_TO_ADDR
// end ;
77871: LD_VAR 0 2
77875: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77876: LD_INT 0
77878: PPUSH
77879: PPUSH
77880: PPUSH
// pom := GetBase ( building ) ;
77881: LD_ADDR_VAR 0 4
77885: PUSH
77886: LD_VAR 0 1
77890: PPUSH
77891: CALL_OW 274
77895: ST_TO_ADDR
// if not pom then
77896: LD_VAR 0 4
77900: NOT
77901: IFFALSE 77905
// exit ;
77903: GO 78006
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77905: LD_ADDR_VAR 0 5
77909: PUSH
77910: LD_VAR 0 2
77914: PPUSH
77915: LD_VAR 0 1
77919: PPUSH
77920: CALL_OW 248
77924: PPUSH
77925: CALL_OW 450
77929: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77930: LD_ADDR_VAR 0 3
77934: PUSH
77935: LD_VAR 0 4
77939: PPUSH
77940: LD_INT 1
77942: PPUSH
77943: CALL_OW 275
77947: PUSH
77948: LD_VAR 0 5
77952: PUSH
77953: LD_INT 1
77955: ARRAY
77956: GREATEREQUAL
77957: PUSH
77958: LD_VAR 0 4
77962: PPUSH
77963: LD_INT 2
77965: PPUSH
77966: CALL_OW 275
77970: PUSH
77971: LD_VAR 0 5
77975: PUSH
77976: LD_INT 2
77978: ARRAY
77979: GREATEREQUAL
77980: AND
77981: PUSH
77982: LD_VAR 0 4
77986: PPUSH
77987: LD_INT 3
77989: PPUSH
77990: CALL_OW 275
77994: PUSH
77995: LD_VAR 0 5
77999: PUSH
78000: LD_INT 3
78002: ARRAY
78003: GREATEREQUAL
78004: AND
78005: ST_TO_ADDR
// end ;
78006: LD_VAR 0 3
78010: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
78011: LD_INT 0
78013: PPUSH
78014: PPUSH
78015: PPUSH
78016: PPUSH
78017: PPUSH
78018: PPUSH
78019: PPUSH
78020: PPUSH
78021: PPUSH
78022: PPUSH
78023: PPUSH
// result := false ;
78024: LD_ADDR_VAR 0 8
78028: PUSH
78029: LD_INT 0
78031: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
78032: LD_VAR 0 5
78036: NOT
78037: PUSH
78038: LD_VAR 0 1
78042: NOT
78043: OR
78044: PUSH
78045: LD_VAR 0 2
78049: NOT
78050: OR
78051: PUSH
78052: LD_VAR 0 3
78056: NOT
78057: OR
78058: IFFALSE 78062
// exit ;
78060: GO 78876
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
78062: LD_ADDR_VAR 0 14
78066: PUSH
78067: LD_VAR 0 1
78071: PPUSH
78072: LD_VAR 0 2
78076: PPUSH
78077: LD_VAR 0 3
78081: PPUSH
78082: LD_VAR 0 4
78086: PPUSH
78087: LD_VAR 0 5
78091: PUSH
78092: LD_INT 1
78094: ARRAY
78095: PPUSH
78096: CALL_OW 248
78100: PPUSH
78101: LD_INT 0
78103: PPUSH
78104: CALL 80109 0 6
78108: ST_TO_ADDR
// if not hexes then
78109: LD_VAR 0 14
78113: NOT
78114: IFFALSE 78118
// exit ;
78116: GO 78876
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78118: LD_ADDR_VAR 0 17
78122: PUSH
78123: LD_VAR 0 5
78127: PPUSH
78128: LD_INT 22
78130: PUSH
78131: LD_VAR 0 13
78135: PPUSH
78136: CALL_OW 255
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 2
78147: PUSH
78148: LD_INT 30
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 30
78160: PUSH
78161: LD_INT 1
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: LIST
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PPUSH
78177: CALL_OW 72
78181: ST_TO_ADDR
// for i = 1 to hexes do
78182: LD_ADDR_VAR 0 9
78186: PUSH
78187: DOUBLE
78188: LD_INT 1
78190: DEC
78191: ST_TO_ADDR
78192: LD_VAR 0 14
78196: PUSH
78197: FOR_TO
78198: IFFALSE 78874
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78200: LD_ADDR_VAR 0 13
78204: PUSH
78205: LD_VAR 0 14
78209: PUSH
78210: LD_VAR 0 9
78214: ARRAY
78215: PUSH
78216: LD_INT 1
78218: ARRAY
78219: PPUSH
78220: LD_VAR 0 14
78224: PUSH
78225: LD_VAR 0 9
78229: ARRAY
78230: PUSH
78231: LD_INT 2
78233: ARRAY
78234: PPUSH
78235: CALL_OW 428
78239: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78240: LD_VAR 0 14
78244: PUSH
78245: LD_VAR 0 9
78249: ARRAY
78250: PUSH
78251: LD_INT 1
78253: ARRAY
78254: PPUSH
78255: LD_VAR 0 14
78259: PUSH
78260: LD_VAR 0 9
78264: ARRAY
78265: PUSH
78266: LD_INT 2
78268: ARRAY
78269: PPUSH
78270: CALL_OW 351
78274: PUSH
78275: LD_VAR 0 14
78279: PUSH
78280: LD_VAR 0 9
78284: ARRAY
78285: PUSH
78286: LD_INT 1
78288: ARRAY
78289: PPUSH
78290: LD_VAR 0 14
78294: PUSH
78295: LD_VAR 0 9
78299: ARRAY
78300: PUSH
78301: LD_INT 2
78303: ARRAY
78304: PPUSH
78305: CALL_OW 488
78309: NOT
78310: OR
78311: PUSH
78312: LD_VAR 0 13
78316: PPUSH
78317: CALL_OW 247
78321: PUSH
78322: LD_INT 3
78324: EQUAL
78325: OR
78326: IFFALSE 78332
// exit ;
78328: POP
78329: POP
78330: GO 78876
// if not tmp then
78332: LD_VAR 0 13
78336: NOT
78337: IFFALSE 78341
// continue ;
78339: GO 78197
// result := true ;
78341: LD_ADDR_VAR 0 8
78345: PUSH
78346: LD_INT 1
78348: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78349: LD_VAR 0 6
78353: PUSH
78354: LD_VAR 0 13
78358: PPUSH
78359: CALL_OW 247
78363: PUSH
78364: LD_INT 2
78366: EQUAL
78367: AND
78368: PUSH
78369: LD_VAR 0 13
78373: PPUSH
78374: CALL_OW 263
78378: PUSH
78379: LD_INT 1
78381: EQUAL
78382: AND
78383: IFFALSE 78547
// begin if IsDrivenBy ( tmp ) then
78385: LD_VAR 0 13
78389: PPUSH
78390: CALL_OW 311
78394: IFFALSE 78398
// continue ;
78396: GO 78197
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78398: LD_VAR 0 6
78402: PPUSH
78403: LD_INT 3
78405: PUSH
78406: LD_INT 60
78408: PUSH
78409: EMPTY
78410: LIST
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 3
78418: PUSH
78419: LD_INT 55
78421: PUSH
78422: EMPTY
78423: LIST
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PPUSH
78433: CALL_OW 72
78437: IFFALSE 78545
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78439: LD_ADDR_VAR 0 18
78443: PUSH
78444: LD_VAR 0 6
78448: PPUSH
78449: LD_INT 3
78451: PUSH
78452: LD_INT 60
78454: PUSH
78455: EMPTY
78456: LIST
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 3
78464: PUSH
78465: LD_INT 55
78467: PUSH
78468: EMPTY
78469: LIST
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PPUSH
78479: CALL_OW 72
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: ST_TO_ADDR
// if IsInUnit ( driver ) then
78488: LD_VAR 0 18
78492: PPUSH
78493: CALL_OW 310
78497: IFFALSE 78508
// ComExit ( driver ) ;
78499: LD_VAR 0 18
78503: PPUSH
78504: CALL 103870 0 1
// AddComEnterUnit ( driver , tmp ) ;
78508: LD_VAR 0 18
78512: PPUSH
78513: LD_VAR 0 13
78517: PPUSH
78518: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78522: LD_VAR 0 18
78526: PPUSH
78527: LD_VAR 0 7
78531: PPUSH
78532: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78536: LD_VAR 0 18
78540: PPUSH
78541: CALL_OW 181
// end ; continue ;
78545: GO 78197
// end ; if not cleaners or not tmp in cleaners then
78547: LD_VAR 0 6
78551: NOT
78552: PUSH
78553: LD_VAR 0 13
78557: PUSH
78558: LD_VAR 0 6
78562: IN
78563: NOT
78564: OR
78565: IFFALSE 78872
// begin if dep then
78567: LD_VAR 0 17
78571: IFFALSE 78707
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78573: LD_ADDR_VAR 0 16
78577: PUSH
78578: LD_VAR 0 17
78582: PUSH
78583: LD_INT 1
78585: ARRAY
78586: PPUSH
78587: CALL_OW 250
78591: PPUSH
78592: LD_VAR 0 17
78596: PUSH
78597: LD_INT 1
78599: ARRAY
78600: PPUSH
78601: CALL_OW 254
78605: PPUSH
78606: LD_INT 5
78608: PPUSH
78609: CALL_OW 272
78613: PUSH
78614: LD_VAR 0 17
78618: PUSH
78619: LD_INT 1
78621: ARRAY
78622: PPUSH
78623: CALL_OW 251
78627: PPUSH
78628: LD_VAR 0 17
78632: PUSH
78633: LD_INT 1
78635: ARRAY
78636: PPUSH
78637: CALL_OW 254
78641: PPUSH
78642: LD_INT 5
78644: PPUSH
78645: CALL_OW 273
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78654: LD_VAR 0 16
78658: PUSH
78659: LD_INT 1
78661: ARRAY
78662: PPUSH
78663: LD_VAR 0 16
78667: PUSH
78668: LD_INT 2
78670: ARRAY
78671: PPUSH
78672: CALL_OW 488
78676: IFFALSE 78707
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78678: LD_VAR 0 13
78682: PPUSH
78683: LD_VAR 0 16
78687: PUSH
78688: LD_INT 1
78690: ARRAY
78691: PPUSH
78692: LD_VAR 0 16
78696: PUSH
78697: LD_INT 2
78699: ARRAY
78700: PPUSH
78701: CALL_OW 111
// continue ;
78705: GO 78197
// end ; end ; r := GetDir ( tmp ) ;
78707: LD_ADDR_VAR 0 15
78711: PUSH
78712: LD_VAR 0 13
78716: PPUSH
78717: CALL_OW 254
78721: ST_TO_ADDR
// if r = 5 then
78722: LD_VAR 0 15
78726: PUSH
78727: LD_INT 5
78729: EQUAL
78730: IFFALSE 78740
// r := 0 ;
78732: LD_ADDR_VAR 0 15
78736: PUSH
78737: LD_INT 0
78739: ST_TO_ADDR
// for j = r to 5 do
78740: LD_ADDR_VAR 0 10
78744: PUSH
78745: DOUBLE
78746: LD_VAR 0 15
78750: DEC
78751: ST_TO_ADDR
78752: LD_INT 5
78754: PUSH
78755: FOR_TO
78756: IFFALSE 78870
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78758: LD_ADDR_VAR 0 11
78762: PUSH
78763: LD_VAR 0 13
78767: PPUSH
78768: CALL_OW 250
78772: PPUSH
78773: LD_VAR 0 10
78777: PPUSH
78778: LD_INT 2
78780: PPUSH
78781: CALL_OW 272
78785: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78786: LD_ADDR_VAR 0 12
78790: PUSH
78791: LD_VAR 0 13
78795: PPUSH
78796: CALL_OW 251
78800: PPUSH
78801: LD_VAR 0 10
78805: PPUSH
78806: LD_INT 2
78808: PPUSH
78809: CALL_OW 273
78813: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78814: LD_VAR 0 11
78818: PPUSH
78819: LD_VAR 0 12
78823: PPUSH
78824: CALL_OW 488
78828: PUSH
78829: LD_VAR 0 11
78833: PPUSH
78834: LD_VAR 0 12
78838: PPUSH
78839: CALL_OW 428
78843: NOT
78844: AND
78845: IFFALSE 78868
// begin ComMoveXY ( tmp , _x , _y ) ;
78847: LD_VAR 0 13
78851: PPUSH
78852: LD_VAR 0 11
78856: PPUSH
78857: LD_VAR 0 12
78861: PPUSH
78862: CALL_OW 111
// break ;
78866: GO 78870
// end ; end ;
78868: GO 78755
78870: POP
78871: POP
// end ; end ;
78872: GO 78197
78874: POP
78875: POP
// end ;
78876: LD_VAR 0 8
78880: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78881: LD_INT 0
78883: PPUSH
// result := true ;
78884: LD_ADDR_VAR 0 3
78888: PUSH
78889: LD_INT 1
78891: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78892: LD_VAR 0 2
78896: PUSH
78897: LD_INT 24
78899: DOUBLE
78900: EQUAL
78901: IFTRUE 78911
78903: LD_INT 33
78905: DOUBLE
78906: EQUAL
78907: IFTRUE 78911
78909: GO 78936
78911: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78912: LD_ADDR_VAR 0 3
78916: PUSH
78917: LD_INT 32
78919: PPUSH
78920: LD_VAR 0 1
78924: PPUSH
78925: CALL_OW 321
78929: PUSH
78930: LD_INT 2
78932: EQUAL
78933: ST_TO_ADDR
78934: GO 79252
78936: LD_INT 20
78938: DOUBLE
78939: EQUAL
78940: IFTRUE 78944
78942: GO 78969
78944: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78945: LD_ADDR_VAR 0 3
78949: PUSH
78950: LD_INT 6
78952: PPUSH
78953: LD_VAR 0 1
78957: PPUSH
78958: CALL_OW 321
78962: PUSH
78963: LD_INT 2
78965: EQUAL
78966: ST_TO_ADDR
78967: GO 79252
78969: LD_INT 22
78971: DOUBLE
78972: EQUAL
78973: IFTRUE 78983
78975: LD_INT 36
78977: DOUBLE
78978: EQUAL
78979: IFTRUE 78983
78981: GO 79008
78983: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78984: LD_ADDR_VAR 0 3
78988: PUSH
78989: LD_INT 15
78991: PPUSH
78992: LD_VAR 0 1
78996: PPUSH
78997: CALL_OW 321
79001: PUSH
79002: LD_INT 2
79004: EQUAL
79005: ST_TO_ADDR
79006: GO 79252
79008: LD_INT 30
79010: DOUBLE
79011: EQUAL
79012: IFTRUE 79016
79014: GO 79041
79016: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
79017: LD_ADDR_VAR 0 3
79021: PUSH
79022: LD_INT 20
79024: PPUSH
79025: LD_VAR 0 1
79029: PPUSH
79030: CALL_OW 321
79034: PUSH
79035: LD_INT 2
79037: EQUAL
79038: ST_TO_ADDR
79039: GO 79252
79041: LD_INT 28
79043: DOUBLE
79044: EQUAL
79045: IFTRUE 79055
79047: LD_INT 21
79049: DOUBLE
79050: EQUAL
79051: IFTRUE 79055
79053: GO 79080
79055: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
79056: LD_ADDR_VAR 0 3
79060: PUSH
79061: LD_INT 21
79063: PPUSH
79064: LD_VAR 0 1
79068: PPUSH
79069: CALL_OW 321
79073: PUSH
79074: LD_INT 2
79076: EQUAL
79077: ST_TO_ADDR
79078: GO 79252
79080: LD_INT 16
79082: DOUBLE
79083: EQUAL
79084: IFTRUE 79088
79086: GO 79113
79088: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
79089: LD_ADDR_VAR 0 3
79093: PUSH
79094: LD_INT 84
79096: PPUSH
79097: LD_VAR 0 1
79101: PPUSH
79102: CALL_OW 321
79106: PUSH
79107: LD_INT 2
79109: EQUAL
79110: ST_TO_ADDR
79111: GO 79252
79113: LD_INT 19
79115: DOUBLE
79116: EQUAL
79117: IFTRUE 79127
79119: LD_INT 23
79121: DOUBLE
79122: EQUAL
79123: IFTRUE 79127
79125: GO 79152
79127: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
79128: LD_ADDR_VAR 0 3
79132: PUSH
79133: LD_INT 83
79135: PPUSH
79136: LD_VAR 0 1
79140: PPUSH
79141: CALL_OW 321
79145: PUSH
79146: LD_INT 2
79148: EQUAL
79149: ST_TO_ADDR
79150: GO 79252
79152: LD_INT 17
79154: DOUBLE
79155: EQUAL
79156: IFTRUE 79160
79158: GO 79185
79160: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
79161: LD_ADDR_VAR 0 3
79165: PUSH
79166: LD_INT 39
79168: PPUSH
79169: LD_VAR 0 1
79173: PPUSH
79174: CALL_OW 321
79178: PUSH
79179: LD_INT 2
79181: EQUAL
79182: ST_TO_ADDR
79183: GO 79252
79185: LD_INT 18
79187: DOUBLE
79188: EQUAL
79189: IFTRUE 79193
79191: GO 79218
79193: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
79194: LD_ADDR_VAR 0 3
79198: PUSH
79199: LD_INT 40
79201: PPUSH
79202: LD_VAR 0 1
79206: PPUSH
79207: CALL_OW 321
79211: PUSH
79212: LD_INT 2
79214: EQUAL
79215: ST_TO_ADDR
79216: GO 79252
79218: LD_INT 27
79220: DOUBLE
79221: EQUAL
79222: IFTRUE 79226
79224: GO 79251
79226: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
79227: LD_ADDR_VAR 0 3
79231: PUSH
79232: LD_INT 35
79234: PPUSH
79235: LD_VAR 0 1
79239: PPUSH
79240: CALL_OW 321
79244: PUSH
79245: LD_INT 2
79247: EQUAL
79248: ST_TO_ADDR
79249: GO 79252
79251: POP
// end ;
79252: LD_VAR 0 3
79256: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
79257: LD_INT 0
79259: PPUSH
79260: PPUSH
79261: PPUSH
79262: PPUSH
79263: PPUSH
79264: PPUSH
79265: PPUSH
79266: PPUSH
79267: PPUSH
79268: PPUSH
79269: PPUSH
// result := false ;
79270: LD_ADDR_VAR 0 6
79274: PUSH
79275: LD_INT 0
79277: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79278: LD_VAR 0 1
79282: NOT
79283: PUSH
79284: LD_VAR 0 1
79288: PPUSH
79289: CALL_OW 266
79293: PUSH
79294: LD_INT 0
79296: PUSH
79297: LD_INT 1
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: IN
79304: NOT
79305: OR
79306: PUSH
79307: LD_VAR 0 2
79311: NOT
79312: OR
79313: PUSH
79314: LD_VAR 0 5
79318: PUSH
79319: LD_INT 0
79321: PUSH
79322: LD_INT 1
79324: PUSH
79325: LD_INT 2
79327: PUSH
79328: LD_INT 3
79330: PUSH
79331: LD_INT 4
79333: PUSH
79334: LD_INT 5
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: IN
79345: NOT
79346: OR
79347: PUSH
79348: LD_VAR 0 3
79352: PPUSH
79353: LD_VAR 0 4
79357: PPUSH
79358: CALL_OW 488
79362: NOT
79363: OR
79364: IFFALSE 79368
// exit ;
79366: GO 80104
// side := GetSide ( depot ) ;
79368: LD_ADDR_VAR 0 9
79372: PUSH
79373: LD_VAR 0 1
79377: PPUSH
79378: CALL_OW 255
79382: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79383: LD_VAR 0 9
79387: PPUSH
79388: LD_VAR 0 2
79392: PPUSH
79393: CALL 78881 0 2
79397: NOT
79398: IFFALSE 79402
// exit ;
79400: GO 80104
// pom := GetBase ( depot ) ;
79402: LD_ADDR_VAR 0 10
79406: PUSH
79407: LD_VAR 0 1
79411: PPUSH
79412: CALL_OW 274
79416: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79417: LD_ADDR_VAR 0 11
79421: PUSH
79422: LD_VAR 0 2
79426: PPUSH
79427: LD_VAR 0 1
79431: PPUSH
79432: CALL_OW 248
79436: PPUSH
79437: CALL_OW 450
79441: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79442: LD_VAR 0 10
79446: PPUSH
79447: LD_INT 1
79449: PPUSH
79450: CALL_OW 275
79454: PUSH
79455: LD_VAR 0 11
79459: PUSH
79460: LD_INT 1
79462: ARRAY
79463: GREATEREQUAL
79464: PUSH
79465: LD_VAR 0 10
79469: PPUSH
79470: LD_INT 2
79472: PPUSH
79473: CALL_OW 275
79477: PUSH
79478: LD_VAR 0 11
79482: PUSH
79483: LD_INT 2
79485: ARRAY
79486: GREATEREQUAL
79487: AND
79488: PUSH
79489: LD_VAR 0 10
79493: PPUSH
79494: LD_INT 3
79496: PPUSH
79497: CALL_OW 275
79501: PUSH
79502: LD_VAR 0 11
79506: PUSH
79507: LD_INT 3
79509: ARRAY
79510: GREATEREQUAL
79511: AND
79512: NOT
79513: IFFALSE 79517
// exit ;
79515: GO 80104
// if GetBType ( depot ) = b_depot then
79517: LD_VAR 0 1
79521: PPUSH
79522: CALL_OW 266
79526: PUSH
79527: LD_INT 0
79529: EQUAL
79530: IFFALSE 79542
// dist := 28 else
79532: LD_ADDR_VAR 0 14
79536: PUSH
79537: LD_INT 28
79539: ST_TO_ADDR
79540: GO 79550
// dist := 36 ;
79542: LD_ADDR_VAR 0 14
79546: PUSH
79547: LD_INT 36
79549: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79550: LD_VAR 0 1
79554: PPUSH
79555: LD_VAR 0 3
79559: PPUSH
79560: LD_VAR 0 4
79564: PPUSH
79565: CALL_OW 297
79569: PUSH
79570: LD_VAR 0 14
79574: GREATER
79575: IFFALSE 79579
// exit ;
79577: GO 80104
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79579: LD_ADDR_VAR 0 12
79583: PUSH
79584: LD_VAR 0 2
79588: PPUSH
79589: LD_VAR 0 3
79593: PPUSH
79594: LD_VAR 0 4
79598: PPUSH
79599: LD_VAR 0 5
79603: PPUSH
79604: LD_VAR 0 1
79608: PPUSH
79609: CALL_OW 248
79613: PPUSH
79614: LD_INT 0
79616: PPUSH
79617: CALL 80109 0 6
79621: ST_TO_ADDR
// if not hexes then
79622: LD_VAR 0 12
79626: NOT
79627: IFFALSE 79631
// exit ;
79629: GO 80104
// hex := GetHexInfo ( x , y ) ;
79631: LD_ADDR_VAR 0 15
79635: PUSH
79636: LD_VAR 0 3
79640: PPUSH
79641: LD_VAR 0 4
79645: PPUSH
79646: CALL_OW 546
79650: ST_TO_ADDR
// if hex [ 1 ] then
79651: LD_VAR 0 15
79655: PUSH
79656: LD_INT 1
79658: ARRAY
79659: IFFALSE 79663
// exit ;
79661: GO 80104
// height := hex [ 2 ] ;
79663: LD_ADDR_VAR 0 13
79667: PUSH
79668: LD_VAR 0 15
79672: PUSH
79673: LD_INT 2
79675: ARRAY
79676: ST_TO_ADDR
// for i = 1 to hexes do
79677: LD_ADDR_VAR 0 7
79681: PUSH
79682: DOUBLE
79683: LD_INT 1
79685: DEC
79686: ST_TO_ADDR
79687: LD_VAR 0 12
79691: PUSH
79692: FOR_TO
79693: IFFALSE 80023
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79695: LD_VAR 0 12
79699: PUSH
79700: LD_VAR 0 7
79704: ARRAY
79705: PUSH
79706: LD_INT 1
79708: ARRAY
79709: PPUSH
79710: LD_VAR 0 12
79714: PUSH
79715: LD_VAR 0 7
79719: ARRAY
79720: PUSH
79721: LD_INT 2
79723: ARRAY
79724: PPUSH
79725: CALL_OW 488
79729: NOT
79730: PUSH
79731: LD_VAR 0 12
79735: PUSH
79736: LD_VAR 0 7
79740: ARRAY
79741: PUSH
79742: LD_INT 1
79744: ARRAY
79745: PPUSH
79746: LD_VAR 0 12
79750: PUSH
79751: LD_VAR 0 7
79755: ARRAY
79756: PUSH
79757: LD_INT 2
79759: ARRAY
79760: PPUSH
79761: CALL_OW 428
79765: PUSH
79766: LD_INT 0
79768: GREATER
79769: OR
79770: PUSH
79771: LD_VAR 0 12
79775: PUSH
79776: LD_VAR 0 7
79780: ARRAY
79781: PUSH
79782: LD_INT 1
79784: ARRAY
79785: PPUSH
79786: LD_VAR 0 12
79790: PUSH
79791: LD_VAR 0 7
79795: ARRAY
79796: PUSH
79797: LD_INT 2
79799: ARRAY
79800: PPUSH
79801: CALL_OW 351
79805: OR
79806: IFFALSE 79812
// exit ;
79808: POP
79809: POP
79810: GO 80104
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79812: LD_ADDR_VAR 0 8
79816: PUSH
79817: LD_VAR 0 12
79821: PUSH
79822: LD_VAR 0 7
79826: ARRAY
79827: PUSH
79828: LD_INT 1
79830: ARRAY
79831: PPUSH
79832: LD_VAR 0 12
79836: PUSH
79837: LD_VAR 0 7
79841: ARRAY
79842: PUSH
79843: LD_INT 2
79845: ARRAY
79846: PPUSH
79847: CALL_OW 546
79851: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79852: LD_VAR 0 8
79856: PUSH
79857: LD_INT 1
79859: ARRAY
79860: PUSH
79861: LD_VAR 0 8
79865: PUSH
79866: LD_INT 2
79868: ARRAY
79869: PUSH
79870: LD_VAR 0 13
79874: PUSH
79875: LD_INT 2
79877: PLUS
79878: GREATER
79879: OR
79880: PUSH
79881: LD_VAR 0 8
79885: PUSH
79886: LD_INT 2
79888: ARRAY
79889: PUSH
79890: LD_VAR 0 13
79894: PUSH
79895: LD_INT 2
79897: MINUS
79898: LESS
79899: OR
79900: PUSH
79901: LD_VAR 0 8
79905: PUSH
79906: LD_INT 3
79908: ARRAY
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: LD_INT 8
79915: PUSH
79916: LD_INT 9
79918: PUSH
79919: LD_INT 10
79921: PUSH
79922: LD_INT 11
79924: PUSH
79925: LD_INT 12
79927: PUSH
79928: LD_INT 13
79930: PUSH
79931: LD_INT 16
79933: PUSH
79934: LD_INT 17
79936: PUSH
79937: LD_INT 18
79939: PUSH
79940: LD_INT 19
79942: PUSH
79943: LD_INT 20
79945: PUSH
79946: LD_INT 21
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: LIST
79962: LIST
79963: IN
79964: NOT
79965: OR
79966: PUSH
79967: LD_VAR 0 8
79971: PUSH
79972: LD_INT 5
79974: ARRAY
79975: NOT
79976: OR
79977: PUSH
79978: LD_VAR 0 8
79982: PUSH
79983: LD_INT 6
79985: ARRAY
79986: PUSH
79987: LD_INT 1
79989: PUSH
79990: LD_INT 2
79992: PUSH
79993: LD_INT 7
79995: PUSH
79996: LD_INT 9
79998: PUSH
79999: LD_INT 10
80001: PUSH
80002: LD_INT 11
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: IN
80013: NOT
80014: OR
80015: IFFALSE 80021
// exit ;
80017: POP
80018: POP
80019: GO 80104
// end ;
80021: GO 79692
80023: POP
80024: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80025: LD_VAR 0 9
80029: PPUSH
80030: LD_VAR 0 3
80034: PPUSH
80035: LD_VAR 0 4
80039: PPUSH
80040: LD_INT 20
80042: PPUSH
80043: CALL 72056 0 4
80047: PUSH
80048: LD_INT 4
80050: ARRAY
80051: IFFALSE 80055
// exit ;
80053: GO 80104
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80055: LD_VAR 0 2
80059: PUSH
80060: LD_INT 29
80062: PUSH
80063: LD_INT 30
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: IN
80070: PUSH
80071: LD_VAR 0 3
80075: PPUSH
80076: LD_VAR 0 4
80080: PPUSH
80081: LD_VAR 0 9
80085: PPUSH
80086: CALL_OW 440
80090: NOT
80091: AND
80092: IFFALSE 80096
// exit ;
80094: GO 80104
// result := true ;
80096: LD_ADDR_VAR 0 6
80100: PUSH
80101: LD_INT 1
80103: ST_TO_ADDR
// end ;
80104: LD_VAR 0 6
80108: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
80109: LD_INT 0
80111: PPUSH
80112: PPUSH
80113: PPUSH
80114: PPUSH
80115: PPUSH
80116: PPUSH
80117: PPUSH
80118: PPUSH
80119: PPUSH
80120: PPUSH
80121: PPUSH
80122: PPUSH
80123: PPUSH
80124: PPUSH
80125: PPUSH
80126: PPUSH
80127: PPUSH
80128: PPUSH
80129: PPUSH
80130: PPUSH
80131: PPUSH
80132: PPUSH
80133: PPUSH
80134: PPUSH
80135: PPUSH
80136: PPUSH
80137: PPUSH
80138: PPUSH
80139: PPUSH
80140: PPUSH
80141: PPUSH
80142: PPUSH
80143: PPUSH
80144: PPUSH
80145: PPUSH
80146: PPUSH
80147: PPUSH
80148: PPUSH
80149: PPUSH
80150: PPUSH
80151: PPUSH
80152: PPUSH
80153: PPUSH
80154: PPUSH
80155: PPUSH
80156: PPUSH
80157: PPUSH
80158: PPUSH
80159: PPUSH
80160: PPUSH
80161: PPUSH
80162: PPUSH
80163: PPUSH
80164: PPUSH
80165: PPUSH
80166: PPUSH
80167: PPUSH
80168: PPUSH
// result = [ ] ;
80169: LD_ADDR_VAR 0 7
80173: PUSH
80174: EMPTY
80175: ST_TO_ADDR
// temp_list = [ ] ;
80176: LD_ADDR_VAR 0 9
80180: PUSH
80181: EMPTY
80182: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80183: LD_VAR 0 4
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 1
80193: PUSH
80194: LD_INT 2
80196: PUSH
80197: LD_INT 3
80199: PUSH
80200: LD_INT 4
80202: PUSH
80203: LD_INT 5
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: IN
80214: NOT
80215: PUSH
80216: LD_VAR 0 1
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: IN
80231: PUSH
80232: LD_VAR 0 5
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 2
80242: PUSH
80243: LD_INT 3
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: LIST
80250: IN
80251: NOT
80252: AND
80253: OR
80254: IFFALSE 80258
// exit ;
80256: GO 98649
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80258: LD_VAR 0 1
80262: PUSH
80263: LD_INT 6
80265: PUSH
80266: LD_INT 7
80268: PUSH
80269: LD_INT 8
80271: PUSH
80272: LD_INT 13
80274: PUSH
80275: LD_INT 12
80277: PUSH
80278: LD_INT 15
80280: PUSH
80281: LD_INT 11
80283: PUSH
80284: LD_INT 14
80286: PUSH
80287: LD_INT 10
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: IN
80301: IFFALSE 80311
// btype = b_lab ;
80303: LD_ADDR_VAR 0 1
80307: PUSH
80308: LD_INT 6
80310: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80311: LD_VAR 0 6
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: LD_INT 1
80321: PUSH
80322: LD_INT 2
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: LIST
80329: IN
80330: NOT
80331: PUSH
80332: LD_VAR 0 1
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: LD_INT 1
80342: PUSH
80343: LD_INT 2
80345: PUSH
80346: LD_INT 3
80348: PUSH
80349: LD_INT 6
80351: PUSH
80352: LD_INT 36
80354: PUSH
80355: LD_INT 4
80357: PUSH
80358: LD_INT 5
80360: PUSH
80361: LD_INT 31
80363: PUSH
80364: LD_INT 32
80366: PUSH
80367: LD_INT 33
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: IN
80383: NOT
80384: PUSH
80385: LD_VAR 0 6
80389: PUSH
80390: LD_INT 1
80392: EQUAL
80393: AND
80394: OR
80395: PUSH
80396: LD_VAR 0 1
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: LD_INT 3
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: IN
80411: NOT
80412: PUSH
80413: LD_VAR 0 6
80417: PUSH
80418: LD_INT 2
80420: EQUAL
80421: AND
80422: OR
80423: IFFALSE 80433
// mode = 0 ;
80425: LD_ADDR_VAR 0 6
80429: PUSH
80430: LD_INT 0
80432: ST_TO_ADDR
// case mode of 0 :
80433: LD_VAR 0 6
80437: PUSH
80438: LD_INT 0
80440: DOUBLE
80441: EQUAL
80442: IFTRUE 80446
80444: GO 91899
80446: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80447: LD_ADDR_VAR 0 11
80451: PUSH
80452: LD_INT 0
80454: PUSH
80455: LD_INT 0
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 0
80464: PUSH
80465: LD_INT 1
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: PUSH
80476: LD_INT 0
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: LD_INT 1
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 0
80495: PUSH
80496: LD_INT 1
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 1
80505: NEG
80506: PUSH
80507: LD_INT 0
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 1
80516: NEG
80517: PUSH
80518: LD_INT 1
80520: NEG
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: LD_INT 2
80532: NEG
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 0
80540: PUSH
80541: LD_INT 2
80543: NEG
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 1
80551: PUSH
80552: LD_INT 1
80554: NEG
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 1
80562: PUSH
80563: LD_INT 2
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 0
80572: PUSH
80573: LD_INT 2
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 1
80582: NEG
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: LD_INT 3
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 0
80603: PUSH
80604: LD_INT 3
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: PUSH
80611: LD_INT 1
80613: NEG
80614: PUSH
80615: LD_INT 2
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80640: LD_ADDR_VAR 0 12
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 0
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 1
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 1
80678: PUSH
80679: LD_INT 1
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 1
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 1
80698: NEG
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 1
80709: NEG
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 1
80721: PUSH
80722: LD_INT 1
80724: NEG
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 2
80732: PUSH
80733: LD_INT 0
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 2
80742: PUSH
80743: LD_INT 1
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: LD_INT 1
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 2
80763: NEG
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 2
80774: NEG
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 2
80786: NEG
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 3
80797: NEG
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 3
80808: NEG
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80836: LD_ADDR_VAR 0 13
80840: PUSH
80841: LD_INT 0
80843: PUSH
80844: LD_INT 0
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 0
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: LD_INT 1
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: LD_INT 0
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 1
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: NEG
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 2
80929: PUSH
80930: LD_INT 1
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 2
80939: PUSH
80940: LD_INT 2
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 1
80949: PUSH
80950: LD_INT 2
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: NEG
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 2
80983: NEG
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 3
80995: NEG
80996: PUSH
80997: LD_INT 2
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 3
81007: NEG
81008: PUSH
81009: LD_INT 3
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81035: LD_ADDR_VAR 0 14
81039: PUSH
81040: LD_INT 0
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 0
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 1
81063: PUSH
81064: LD_INT 0
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 1
81073: PUSH
81074: LD_INT 1
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: LD_INT 1
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: NEG
81094: PUSH
81095: LD_INT 0
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 1
81104: NEG
81105: PUSH
81106: LD_INT 1
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 1
81116: NEG
81117: PUSH
81118: LD_INT 2
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 0
81128: PUSH
81129: LD_INT 2
81131: NEG
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 1
81139: PUSH
81140: LD_INT 1
81142: NEG
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 1
81150: PUSH
81151: LD_INT 2
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: PUSH
81158: LD_INT 0
81160: PUSH
81161: LD_INT 2
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 1
81170: NEG
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 1
81181: NEG
81182: PUSH
81183: LD_INT 3
81185: NEG
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 0
81193: PUSH
81194: LD_INT 3
81196: NEG
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 1
81204: PUSH
81205: LD_INT 2
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81231: LD_ADDR_VAR 0 15
81235: PUSH
81236: LD_INT 0
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 0
81248: PUSH
81249: LD_INT 1
81251: NEG
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 1
81259: PUSH
81260: LD_INT 0
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 1
81269: PUSH
81270: LD_INT 1
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 0
81279: PUSH
81280: LD_INT 1
81282: PUSH
81283: EMPTY
81284: LIST
81285: LIST
81286: PUSH
81287: LD_INT 1
81289: NEG
81290: PUSH
81291: LD_INT 0
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 1
81300: NEG
81301: PUSH
81302: LD_INT 1
81304: NEG
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 1
81312: PUSH
81313: LD_INT 1
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 2
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: LD_INT 1
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: LD_INT 1
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 2
81354: NEG
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: PUSH
81363: LD_INT 2
81365: NEG
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 2
81377: PUSH
81378: LD_INT 1
81380: NEG
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 3
81388: PUSH
81389: LD_INT 0
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 3
81398: PUSH
81399: LD_INT 1
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81424: LD_ADDR_VAR 0 16
81428: PUSH
81429: LD_INT 0
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 0
81441: PUSH
81442: LD_INT 1
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: LD_INT 0
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 1
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 0
81472: PUSH
81473: LD_INT 1
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 1
81482: NEG
81483: PUSH
81484: LD_INT 0
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 1
81497: NEG
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: LD_INT 2
81509: NEG
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 2
81517: PUSH
81518: LD_INT 1
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: PUSH
81528: LD_INT 2
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: PUSH
81538: LD_INT 2
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 2
81547: NEG
81548: PUSH
81549: LD_INT 1
81551: NEG
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 2
81559: NEG
81560: PUSH
81561: LD_INT 2
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 3
81571: PUSH
81572: LD_INT 2
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 3
81581: PUSH
81582: LD_INT 3
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 2
81591: PUSH
81592: LD_INT 3
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81617: LD_ADDR_VAR 0 17
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: LD_INT 0
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: LD_INT 1
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 1
81698: NEG
81699: PUSH
81700: LD_INT 2
81702: NEG
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 2
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 2
81732: PUSH
81733: LD_INT 0
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: LD_INT 1
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: PUSH
81763: LD_INT 2
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: LD_INT 2
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: LD_INT 1
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 2
81793: NEG
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 2
81804: NEG
81805: PUSH
81806: LD_INT 1
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 2
81816: NEG
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81847: LD_ADDR_VAR 0 18
81851: PUSH
81852: LD_INT 0
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 0
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: EMPTY
81870: LIST
81871: LIST
81872: PUSH
81873: LD_INT 1
81875: PUSH
81876: LD_INT 0
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 1
81885: PUSH
81886: LD_INT 1
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 0
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 1
81905: NEG
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 1
81928: NEG
81929: PUSH
81930: LD_INT 2
81932: NEG
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 0
81940: PUSH
81941: LD_INT 2
81943: NEG
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 2
81962: PUSH
81963: LD_INT 0
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 2
81972: PUSH
81973: LD_INT 1
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 2
81982: PUSH
81983: LD_INT 2
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 1
81992: PUSH
81993: LD_INT 2
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: LD_INT 0
82002: PUSH
82003: LD_INT 2
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: LD_INT 1
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 2
82023: NEG
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 2
82034: NEG
82035: PUSH
82036: LD_INT 1
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 2
82046: NEG
82047: PUSH
82048: LD_INT 2
82050: NEG
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82077: LD_ADDR_VAR 0 19
82081: PUSH
82082: LD_INT 0
82084: PUSH
82085: LD_INT 0
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: PUSH
82106: LD_INT 0
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 1
82115: PUSH
82116: LD_INT 1
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 0
82125: PUSH
82126: LD_INT 1
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: LD_INT 0
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 1
82146: NEG
82147: PUSH
82148: LD_INT 1
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 1
82158: NEG
82159: PUSH
82160: LD_INT 2
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 2
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: LD_INT 1
82184: NEG
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 2
82192: PUSH
82193: LD_INT 0
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 2
82202: PUSH
82203: LD_INT 1
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 2
82212: PUSH
82213: LD_INT 2
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: PUSH
82223: LD_INT 2
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: LD_INT 1
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 2
82253: NEG
82254: PUSH
82255: LD_INT 0
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 2
82264: NEG
82265: PUSH
82266: LD_INT 1
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 2
82276: NEG
82277: PUSH
82278: LD_INT 2
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82307: LD_ADDR_VAR 0 20
82311: PUSH
82312: LD_INT 0
82314: PUSH
82315: LD_INT 0
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 0
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 1
82335: PUSH
82336: LD_INT 0
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 1
82345: PUSH
82346: LD_INT 1
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 0
82355: PUSH
82356: LD_INT 1
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 1
82365: NEG
82366: PUSH
82367: LD_INT 0
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: LD_INT 1
82380: NEG
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 1
82388: NEG
82389: PUSH
82390: LD_INT 2
82392: NEG
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: LD_INT 2
82403: NEG
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 1
82411: PUSH
82412: LD_INT 1
82414: NEG
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 2
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 2
82432: PUSH
82433: LD_INT 1
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: LD_INT 2
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: LD_INT 2
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 2
82483: NEG
82484: PUSH
82485: LD_INT 0
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 2
82494: NEG
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 2
82506: NEG
82507: PUSH
82508: LD_INT 2
82510: NEG
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82537: LD_ADDR_VAR 0 21
82541: PUSH
82542: LD_INT 0
82544: PUSH
82545: LD_INT 0
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 0
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: PUSH
82566: LD_INT 0
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: LD_INT 1
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: NEG
82619: PUSH
82620: LD_INT 2
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 0
82630: PUSH
82631: LD_INT 2
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: PUSH
82642: LD_INT 1
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 2
82652: PUSH
82653: LD_INT 0
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 2
82662: PUSH
82663: LD_INT 1
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 2
82672: PUSH
82673: LD_INT 2
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 1
82682: PUSH
82683: LD_INT 2
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 2
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 1
82702: NEG
82703: PUSH
82704: LD_INT 1
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: NEG
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 2
82724: NEG
82725: PUSH
82726: LD_INT 1
82728: NEG
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 2
82736: NEG
82737: PUSH
82738: LD_INT 2
82740: NEG
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82767: LD_ADDR_VAR 0 22
82771: PUSH
82772: LD_INT 0
82774: PUSH
82775: LD_INT 0
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 0
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: LD_INT 0
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 1
82805: PUSH
82806: LD_INT 1
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 0
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: NEG
82826: PUSH
82827: LD_INT 0
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: LD_INT 1
82840: NEG
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 1
82848: NEG
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 0
82860: PUSH
82861: LD_INT 2
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 2
82892: PUSH
82893: LD_INT 1
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: LD_INT 2
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 1
82912: PUSH
82913: LD_INT 2
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 0
82922: PUSH
82923: LD_INT 2
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 1
82932: NEG
82933: PUSH
82934: LD_INT 1
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 2
82943: NEG
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 2
82954: NEG
82955: PUSH
82956: LD_INT 1
82958: NEG
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 2
82966: NEG
82967: PUSH
82968: LD_INT 2
82970: NEG
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82997: LD_ADDR_VAR 0 23
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: LD_INT 0
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: LD_INT 1
83017: NEG
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: LD_INT 0
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 1
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: LD_INT 1
83070: NEG
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 0
83090: PUSH
83091: LD_INT 2
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 1
83101: PUSH
83102: LD_INT 1
83104: NEG
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 2
83112: PUSH
83113: LD_INT 0
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 2
83122: PUSH
83123: LD_INT 1
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 2
83132: PUSH
83133: LD_INT 2
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: PUSH
83143: LD_INT 2
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 0
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: LD_INT 1
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 2
83173: NEG
83174: PUSH
83175: LD_INT 0
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 2
83184: NEG
83185: PUSH
83186: LD_INT 1
83188: NEG
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 2
83196: NEG
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: NEG
83209: PUSH
83210: LD_INT 3
83212: NEG
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 1
83220: NEG
83221: PUSH
83222: LD_INT 3
83224: NEG
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 1
83232: PUSH
83233: LD_INT 2
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 2
83243: PUSH
83244: LD_INT 1
83246: NEG
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83277: LD_ADDR_VAR 0 24
83281: PUSH
83282: LD_INT 0
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: LD_INT 1
83297: NEG
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 1
83305: PUSH
83306: LD_INT 0
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 1
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: LD_INT 1
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: LD_INT 0
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 1
83346: NEG
83347: PUSH
83348: LD_INT 1
83350: NEG
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 1
83358: NEG
83359: PUSH
83360: LD_INT 2
83362: NEG
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: LD_INT 2
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 1
83381: PUSH
83382: LD_INT 1
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 2
83392: PUSH
83393: LD_INT 0
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 2
83402: PUSH
83403: LD_INT 1
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 2
83412: PUSH
83413: LD_INT 2
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 1
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 0
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 1
83442: NEG
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 2
83453: NEG
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 2
83476: NEG
83477: PUSH
83478: LD_INT 2
83480: NEG
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 2
83499: PUSH
83500: LD_INT 1
83502: NEG
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 3
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 3
83520: PUSH
83521: LD_INT 2
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83553: LD_ADDR_VAR 0 25
83557: PUSH
83558: LD_INT 0
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 0
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: PUSH
83592: LD_INT 1
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 0
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 1
83611: NEG
83612: PUSH
83613: LD_INT 0
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: NEG
83635: PUSH
83636: LD_INT 2
83638: NEG
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 0
83646: PUSH
83647: LD_INT 2
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 1
83657: PUSH
83658: LD_INT 1
83660: NEG
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 2
83668: PUSH
83669: LD_INT 0
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 2
83678: PUSH
83679: LD_INT 1
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 2
83688: PUSH
83689: LD_INT 2
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 1
83698: PUSH
83699: LD_INT 2
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: LD_INT 2
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 1
83718: NEG
83719: PUSH
83720: LD_INT 1
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 2
83729: NEG
83730: PUSH
83731: LD_INT 0
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 2
83740: NEG
83741: PUSH
83742: LD_INT 1
83744: NEG
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 2
83752: NEG
83753: PUSH
83754: LD_INT 2
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 3
83764: PUSH
83765: LD_INT 1
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 3
83774: PUSH
83775: LD_INT 2
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: LD_INT 3
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 1
83794: PUSH
83795: LD_INT 3
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83827: LD_ADDR_VAR 0 26
83831: PUSH
83832: LD_INT 0
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: PUSH
83842: LD_INT 0
83844: PUSH
83845: LD_INT 1
83847: NEG
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 1
83855: PUSH
83856: LD_INT 0
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 1
83865: PUSH
83866: LD_INT 1
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: LD_INT 1
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: LD_INT 0
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 1
83896: NEG
83897: PUSH
83898: LD_INT 1
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 1
83908: NEG
83909: PUSH
83910: LD_INT 2
83912: NEG
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 0
83920: PUSH
83921: LD_INT 2
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 1
83931: PUSH
83932: LD_INT 1
83934: NEG
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: PUSH
83940: LD_INT 2
83942: PUSH
83943: LD_INT 0
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 2
83952: PUSH
83953: LD_INT 1
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 2
83962: PUSH
83963: LD_INT 2
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 1
83972: PUSH
83973: LD_INT 2
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 0
83982: PUSH
83983: LD_INT 2
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 1
83992: NEG
83993: PUSH
83994: LD_INT 1
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 2
84003: NEG
84004: PUSH
84005: LD_INT 0
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 2
84014: NEG
84015: PUSH
84016: LD_INT 1
84018: NEG
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 2
84026: NEG
84027: PUSH
84028: LD_INT 2
84030: NEG
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 2
84038: PUSH
84039: LD_INT 3
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 1
84048: PUSH
84049: LD_INT 3
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 1
84058: NEG
84059: PUSH
84060: LD_INT 2
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: LD_INT 1
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84103: LD_ADDR_VAR 0 27
84107: PUSH
84108: LD_INT 0
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 0
84120: PUSH
84121: LD_INT 1
84123: NEG
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: PUSH
84132: LD_INT 0
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 1
84141: PUSH
84142: LD_INT 1
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 0
84151: PUSH
84152: LD_INT 1
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: NEG
84162: PUSH
84163: LD_INT 0
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 1
84172: NEG
84173: PUSH
84174: LD_INT 1
84176: NEG
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: NEG
84185: PUSH
84186: LD_INT 2
84188: NEG
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 0
84196: PUSH
84197: LD_INT 2
84199: NEG
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: LD_INT 1
84210: NEG
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 2
84218: PUSH
84219: LD_INT 0
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 2
84228: PUSH
84229: LD_INT 1
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 2
84238: PUSH
84239: LD_INT 2
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: PUSH
84246: LD_INT 1
84248: PUSH
84249: LD_INT 2
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 0
84258: PUSH
84259: LD_INT 2
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 1
84268: NEG
84269: PUSH
84270: LD_INT 1
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 2
84279: NEG
84280: PUSH
84281: LD_INT 0
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 2
84290: NEG
84291: PUSH
84292: LD_INT 1
84294: NEG
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: PUSH
84300: LD_INT 2
84302: NEG
84303: PUSH
84304: LD_INT 2
84306: NEG
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: NEG
84315: PUSH
84316: LD_INT 2
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PUSH
84323: LD_INT 2
84325: NEG
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: EMPTY
84331: LIST
84332: LIST
84333: PUSH
84334: LD_INT 3
84336: NEG
84337: PUSH
84338: LD_INT 1
84340: NEG
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: PUSH
84346: LD_INT 3
84348: NEG
84349: PUSH
84350: LD_INT 2
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84383: LD_ADDR_VAR 0 28
84387: PUSH
84388: LD_INT 0
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 0
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 1
84411: PUSH
84412: LD_INT 0
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 1
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 0
84431: PUSH
84432: LD_INT 1
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 1
84441: NEG
84442: PUSH
84443: LD_INT 0
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: LD_INT 1
84452: NEG
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 1
84464: NEG
84465: PUSH
84466: LD_INT 2
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 0
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: LD_INT 1
84490: NEG
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 2
84498: PUSH
84499: LD_INT 0
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 2
84508: PUSH
84509: LD_INT 1
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 2
84518: PUSH
84519: LD_INT 2
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 1
84528: PUSH
84529: LD_INT 2
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 0
84538: PUSH
84539: LD_INT 2
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: NEG
84549: PUSH
84550: LD_INT 1
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 2
84559: NEG
84560: PUSH
84561: LD_INT 0
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 2
84570: NEG
84571: PUSH
84572: LD_INT 1
84574: NEG
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 2
84582: NEG
84583: PUSH
84584: LD_INT 2
84586: NEG
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 2
84594: NEG
84595: PUSH
84596: LD_INT 3
84598: NEG
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PUSH
84604: LD_INT 1
84606: NEG
84607: PUSH
84608: LD_INT 3
84610: NEG
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 3
84618: NEG
84619: PUSH
84620: LD_INT 1
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 3
84630: NEG
84631: PUSH
84632: LD_INT 2
84634: NEG
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84665: LD_ADDR_VAR 0 29
84669: PUSH
84670: LD_INT 0
84672: PUSH
84673: LD_INT 0
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: LD_INT 1
84685: NEG
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: LD_INT 0
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 1
84703: PUSH
84704: LD_INT 1
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 0
84713: PUSH
84714: LD_INT 1
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 1
84723: NEG
84724: PUSH
84725: LD_INT 0
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: LD_INT 1
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 1
84746: NEG
84747: PUSH
84748: LD_INT 2
84750: NEG
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 0
84758: PUSH
84759: LD_INT 2
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 1
84769: PUSH
84770: LD_INT 1
84772: NEG
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 2
84780: PUSH
84781: LD_INT 0
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 2
84790: PUSH
84791: LD_INT 1
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 1
84800: PUSH
84801: LD_INT 2
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: LD_INT 2
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 1
84820: NEG
84821: PUSH
84822: LD_INT 1
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PUSH
84829: LD_INT 2
84831: NEG
84832: PUSH
84833: LD_INT 1
84835: NEG
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: LD_INT 2
84843: NEG
84844: PUSH
84845: LD_INT 2
84847: NEG
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: PUSH
84853: LD_INT 2
84855: NEG
84856: PUSH
84857: LD_INT 3
84859: NEG
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 2
84867: PUSH
84868: LD_INT 1
84870: NEG
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: PUSH
84876: LD_INT 3
84878: PUSH
84879: LD_INT 1
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 1
84888: PUSH
84889: LD_INT 3
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 1
84898: NEG
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 3
84909: NEG
84910: PUSH
84911: LD_INT 2
84913: NEG
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84944: LD_ADDR_VAR 0 30
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: LD_INT 0
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: LD_INT 0
84961: PUSH
84962: LD_INT 1
84964: NEG
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: LD_INT 0
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: LD_INT 1
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 1
85002: NEG
85003: PUSH
85004: LD_INT 0
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 1
85013: NEG
85014: PUSH
85015: LD_INT 1
85017: NEG
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PUSH
85023: LD_INT 1
85025: NEG
85026: PUSH
85027: LD_INT 2
85029: NEG
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 0
85037: PUSH
85038: LD_INT 2
85040: NEG
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: LD_INT 1
85051: NEG
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: PUSH
85060: LD_INT 0
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 2
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: LD_INT 2
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: PUSH
85097: LD_INT 1
85099: NEG
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: PUSH
85108: LD_INT 2
85110: NEG
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 2
85121: NEG
85122: PUSH
85123: LD_INT 1
85125: NEG
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: LD_INT 3
85137: NEG
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PUSH
85143: LD_INT 1
85145: PUSH
85146: LD_INT 2
85148: NEG
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PUSH
85154: LD_INT 3
85156: PUSH
85157: LD_INT 2
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 2
85166: PUSH
85167: LD_INT 3
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 2
85176: NEG
85177: PUSH
85178: LD_INT 1
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 3
85187: NEG
85188: PUSH
85189: LD_INT 1
85191: NEG
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85222: LD_ADDR_VAR 0 31
85226: PUSH
85227: LD_INT 0
85229: PUSH
85230: LD_INT 0
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: LD_INT 1
85242: NEG
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 1
85250: PUSH
85251: LD_INT 0
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: LD_INT 1
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 0
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 1
85280: NEG
85281: PUSH
85282: LD_INT 0
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 1
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: LD_INT 2
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 1
85315: PUSH
85316: LD_INT 1
85318: NEG
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: PUSH
85324: LD_INT 2
85326: PUSH
85327: LD_INT 0
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: PUSH
85337: LD_INT 1
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: LD_INT 2
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: PUSH
85357: LD_INT 2
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 2
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 2
85387: NEG
85388: PUSH
85389: LD_INT 1
85391: NEG
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 2
85399: NEG
85400: PUSH
85401: LD_INT 2
85403: NEG
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 2
85411: NEG
85412: PUSH
85413: LD_INT 3
85415: NEG
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 2
85423: PUSH
85424: LD_INT 1
85426: NEG
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 3
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: LD_INT 3
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: NEG
85455: PUSH
85456: LD_INT 2
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 3
85465: NEG
85466: PUSH
85467: LD_INT 2
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85500: LD_ADDR_VAR 0 32
85504: PUSH
85505: LD_INT 0
85507: PUSH
85508: LD_INT 0
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: LD_INT 0
85517: PUSH
85518: LD_INT 1
85520: NEG
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 1
85528: PUSH
85529: LD_INT 0
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: LD_INT 1
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 0
85548: PUSH
85549: LD_INT 1
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 1
85558: NEG
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 1
85569: NEG
85570: PUSH
85571: LD_INT 1
85573: NEG
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 1
85581: NEG
85582: PUSH
85583: LD_INT 2
85585: NEG
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 0
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 1
85604: PUSH
85605: LD_INT 1
85607: NEG
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 2
85625: PUSH
85626: LD_INT 2
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: LD_INT 2
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: LD_INT 2
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 2
85666: NEG
85667: PUSH
85668: LD_INT 0
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: LD_INT 1
85681: NEG
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 1
85689: NEG
85690: PUSH
85691: LD_INT 3
85693: NEG
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 1
85701: PUSH
85702: LD_INT 2
85704: NEG
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 3
85712: PUSH
85713: LD_INT 2
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 2
85722: PUSH
85723: LD_INT 3
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: LD_INT 1
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 3
85743: NEG
85744: PUSH
85745: LD_INT 1
85747: NEG
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85778: LD_ADDR_VAR 0 33
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: LD_INT 0
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: LD_INT 1
85798: NEG
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: LD_INT 0
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 1
85816: PUSH
85817: LD_INT 1
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: LD_INT 0
85826: PUSH
85827: LD_INT 1
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 1
85836: NEG
85837: PUSH
85838: LD_INT 0
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 1
85847: NEG
85848: PUSH
85849: LD_INT 1
85851: NEG
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: LD_INT 2
85863: NEG
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 1
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 2
85882: PUSH
85883: LD_INT 0
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 2
85892: PUSH
85893: LD_INT 1
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 2
85944: NEG
85945: PUSH
85946: LD_INT 1
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: NEG
85957: PUSH
85958: LD_INT 2
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 2
85968: NEG
85969: PUSH
85970: LD_INT 3
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 2
85980: PUSH
85981: LD_INT 1
85983: NEG
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 3
85991: PUSH
85992: LD_INT 1
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: LD_INT 3
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 1
86011: NEG
86012: PUSH
86013: LD_INT 2
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 3
86022: NEG
86023: PUSH
86024: LD_INT 2
86026: NEG
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86057: LD_ADDR_VAR 0 34
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: LD_INT 0
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 0
86074: PUSH
86075: LD_INT 1
86077: NEG
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: PUSH
86086: LD_INT 0
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: LD_INT 1
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: LD_INT 0
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 1
86126: NEG
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 1
86138: NEG
86139: PUSH
86140: LD_INT 2
86142: NEG
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 0
86150: PUSH
86151: LD_INT 2
86153: NEG
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 1
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: LD_INT 1
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 2
86182: PUSH
86183: LD_INT 2
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 1
86192: PUSH
86193: LD_INT 2
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 2
86213: NEG
86214: PUSH
86215: LD_INT 0
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 2
86224: NEG
86225: PUSH
86226: LD_INT 1
86228: NEG
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 2
86236: NEG
86237: PUSH
86238: LD_INT 2
86240: NEG
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 1
86248: NEG
86249: PUSH
86250: LD_INT 3
86252: NEG
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 1
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 3
86271: PUSH
86272: LD_INT 2
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 2
86281: PUSH
86282: LD_INT 3
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 2
86291: NEG
86292: PUSH
86293: LD_INT 1
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 3
86302: NEG
86303: PUSH
86304: LD_INT 1
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86337: LD_ADDR_VAR 0 35
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 0
86354: PUSH
86355: LD_INT 1
86357: NEG
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 1
86365: PUSH
86366: LD_INT 0
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 1
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 1
86395: NEG
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 1
86406: NEG
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 2
86418: PUSH
86419: LD_INT 1
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 2
86428: NEG
86429: PUSH
86430: LD_INT 1
86432: NEG
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86449: LD_ADDR_VAR 0 36
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 0
86466: PUSH
86467: LD_INT 1
86469: NEG
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: PUSH
86478: LD_INT 0
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 1
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 0
86497: PUSH
86498: LD_INT 1
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 1
86507: NEG
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 1
86518: NEG
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: NEG
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 1
86542: PUSH
86543: LD_INT 2
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86561: LD_ADDR_VAR 0 37
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: LD_INT 0
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: LD_INT 0
86578: PUSH
86579: LD_INT 1
86581: NEG
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 1
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: LD_INT 1
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: LD_INT 1
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 1
86619: NEG
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 1
86630: NEG
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 1
86642: PUSH
86643: LD_INT 1
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 1
86653: NEG
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86673: LD_ADDR_VAR 0 38
86677: PUSH
86678: LD_INT 0
86680: PUSH
86681: LD_INT 0
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 0
86690: PUSH
86691: LD_INT 1
86693: NEG
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 1
86701: PUSH
86702: LD_INT 0
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: LD_INT 1
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: LD_INT 1
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: NEG
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 2
86754: PUSH
86755: LD_INT 1
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 2
86764: NEG
86765: PUSH
86766: LD_INT 1
86768: NEG
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86785: LD_ADDR_VAR 0 39
86789: PUSH
86790: LD_INT 0
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 0
86802: PUSH
86803: LD_INT 1
86805: NEG
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 1
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 1
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: LD_INT 1
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 1
86843: NEG
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 1
86854: NEG
86855: PUSH
86856: LD_INT 1
86858: NEG
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: PUSH
86868: LD_INT 2
86870: NEG
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 1
86878: PUSH
86879: LD_INT 2
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86897: LD_ADDR_VAR 0 40
86901: PUSH
86902: LD_INT 0
86904: PUSH
86905: LD_INT 0
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 0
86914: PUSH
86915: LD_INT 1
86917: NEG
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 1
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 1
86935: PUSH
86936: LD_INT 1
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 0
86945: PUSH
86946: LD_INT 1
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 1
86955: NEG
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 1
86966: NEG
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 1
86978: PUSH
86979: LD_INT 1
86981: NEG
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 1
86989: NEG
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87009: LD_ADDR_VAR 0 41
87013: PUSH
87014: LD_INT 0
87016: PUSH
87017: LD_INT 0
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 0
87026: PUSH
87027: LD_INT 1
87029: NEG
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 1
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: PUSH
87048: LD_INT 1
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 0
87057: PUSH
87058: LD_INT 1
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 1
87067: NEG
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 1
87078: NEG
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 1
87090: NEG
87091: PUSH
87092: LD_INT 2
87094: NEG
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 1
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 2
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 2
87123: PUSH
87124: LD_INT 1
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 2
87133: PUSH
87134: LD_INT 2
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 1
87143: PUSH
87144: LD_INT 2
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: LD_INT 0
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: PUSH
87173: LD_INT 2
87175: NEG
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 2
87187: NEG
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 2
87199: NEG
87200: PUSH
87201: LD_INT 3
87203: NEG
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 2
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 3
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 3
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 3
87242: PUSH
87243: LD_INT 2
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 3
87252: PUSH
87253: LD_INT 3
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 2
87262: PUSH
87263: LD_INT 3
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 2
87272: NEG
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 3
87283: NEG
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 3
87294: NEG
87295: PUSH
87296: LD_INT 1
87298: NEG
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 3
87306: NEG
87307: PUSH
87308: LD_INT 2
87310: NEG
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 3
87318: NEG
87319: PUSH
87320: LD_INT 3
87322: NEG
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87359: LD_ADDR_VAR 0 42
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: LD_INT 0
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: LD_INT 1
87379: NEG
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 1
87387: PUSH
87388: LD_INT 0
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 1
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: NEG
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 1
87428: NEG
87429: PUSH
87430: LD_INT 1
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 1
87440: NEG
87441: PUSH
87442: LD_INT 2
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: LD_INT 2
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 2
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: LD_INT 2
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 2
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 0
87504: PUSH
87505: LD_INT 2
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: NEG
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 2
87525: NEG
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 2
87537: NEG
87538: PUSH
87539: LD_INT 2
87541: NEG
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 2
87549: NEG
87550: PUSH
87551: LD_INT 3
87553: NEG
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: NEG
87562: PUSH
87563: LD_INT 3
87565: NEG
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 0
87573: PUSH
87574: LD_INT 3
87576: NEG
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: LD_INT 2
87587: NEG
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 3
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 3
87605: PUSH
87606: LD_INT 3
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 2
87615: PUSH
87616: LD_INT 3
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: PUSH
87626: LD_INT 3
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: LD_INT 3
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: NEG
87646: PUSH
87647: LD_INT 2
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 3
87656: NEG
87657: PUSH
87658: LD_INT 2
87660: NEG
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 3
87668: NEG
87669: PUSH
87670: LD_INT 3
87672: NEG
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: EMPTY
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87709: LD_ADDR_VAR 0 43
87713: PUSH
87714: LD_INT 0
87716: PUSH
87717: LD_INT 0
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: LD_INT 1
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: LD_INT 0
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 1
87747: PUSH
87748: LD_INT 1
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: LD_INT 1
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 1
87767: NEG
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 1
87778: NEG
87779: PUSH
87780: LD_INT 1
87782: NEG
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 1
87790: NEG
87791: PUSH
87792: LD_INT 2
87794: NEG
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 0
87802: PUSH
87803: LD_INT 2
87805: NEG
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: PUSH
87814: LD_INT 1
87816: NEG
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 2
87824: PUSH
87825: LD_INT 0
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 2
87834: PUSH
87835: LD_INT 1
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: PUSH
87842: LD_INT 1
87844: PUSH
87845: LD_INT 2
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 2
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 1
87864: NEG
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 2
87875: NEG
87876: PUSH
87877: LD_INT 0
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 2
87886: NEG
87887: PUSH
87888: LD_INT 1
87890: NEG
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 1
87898: NEG
87899: PUSH
87900: LD_INT 3
87902: NEG
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: LD_INT 3
87913: NEG
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: LD_INT 2
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 2
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 3
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 3
87953: PUSH
87954: LD_INT 1
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: LD_INT 3
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 0
87973: PUSH
87974: LD_INT 3
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 1
87983: NEG
87984: PUSH
87985: LD_INT 2
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 2
87994: NEG
87995: PUSH
87996: LD_INT 1
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 3
88005: NEG
88006: PUSH
88007: LD_INT 0
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: LD_INT 3
88016: NEG
88017: PUSH
88018: LD_INT 1
88020: NEG
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88057: LD_ADDR_VAR 0 44
88061: PUSH
88062: LD_INT 0
88064: PUSH
88065: LD_INT 0
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: LD_INT 1
88077: NEG
88078: PUSH
88079: EMPTY
88080: LIST
88081: LIST
88082: PUSH
88083: LD_INT 1
88085: PUSH
88086: LD_INT 0
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 1
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: LD_INT 1
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: LD_INT 0
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 1
88126: NEG
88127: PUSH
88128: LD_INT 1
88130: NEG
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 1
88138: NEG
88139: PUSH
88140: LD_INT 2
88142: NEG
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 1
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 2
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 2
88171: PUSH
88172: LD_INT 1
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 2
88181: PUSH
88182: LD_INT 2
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 1
88191: PUSH
88192: LD_INT 2
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: NEG
88202: PUSH
88203: LD_INT 1
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: LD_INT 0
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 2
88235: NEG
88236: PUSH
88237: LD_INT 2
88239: NEG
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 2
88247: NEG
88248: PUSH
88249: LD_INT 3
88251: NEG
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 2
88259: PUSH
88260: LD_INT 1
88262: NEG
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 3
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 3
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 3
88290: PUSH
88291: LD_INT 2
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 3
88300: PUSH
88301: LD_INT 3
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 2
88310: PUSH
88311: LD_INT 3
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 2
88320: NEG
88321: PUSH
88322: LD_INT 1
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 3
88331: NEG
88332: PUSH
88333: LD_INT 0
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 3
88342: NEG
88343: PUSH
88344: LD_INT 1
88346: NEG
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 3
88354: NEG
88355: PUSH
88356: LD_INT 2
88358: NEG
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 3
88366: NEG
88367: PUSH
88368: LD_INT 3
88370: NEG
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88407: LD_ADDR_VAR 0 45
88411: PUSH
88412: LD_INT 0
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: PUSH
88422: LD_INT 0
88424: PUSH
88425: LD_INT 1
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 1
88435: PUSH
88436: LD_INT 0
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 1
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 0
88455: PUSH
88456: LD_INT 1
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: NEG
88466: PUSH
88467: LD_INT 0
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: LD_INT 1
88480: NEG
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: LD_INT 2
88492: NEG
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 0
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 1
88511: PUSH
88512: LD_INT 1
88514: NEG
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 2
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 2
88532: PUSH
88533: LD_INT 2
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: LD_INT 2
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 0
88552: PUSH
88553: LD_INT 2
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 1
88562: NEG
88563: PUSH
88564: LD_INT 1
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 2
88573: NEG
88574: PUSH
88575: LD_INT 1
88577: NEG
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: PUSH
88583: LD_INT 2
88585: NEG
88586: PUSH
88587: LD_INT 2
88589: NEG
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 2
88597: NEG
88598: PUSH
88599: LD_INT 3
88601: NEG
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: NEG
88610: PUSH
88611: LD_INT 3
88613: NEG
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 0
88621: PUSH
88622: LD_INT 3
88624: NEG
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: LD_INT 2
88635: NEG
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 3
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 3
88653: PUSH
88654: LD_INT 3
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 2
88663: PUSH
88664: LD_INT 3
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 1
88673: PUSH
88674: LD_INT 3
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: LD_INT 3
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 1
88693: NEG
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 3
88704: NEG
88705: PUSH
88706: LD_INT 2
88708: NEG
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 3
88716: NEG
88717: PUSH
88718: LD_INT 3
88720: NEG
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88757: LD_ADDR_VAR 0 46
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: LD_INT 1
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: LD_INT 1
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: LD_INT 1
88830: NEG
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 1
88838: NEG
88839: PUSH
88840: LD_INT 2
88842: NEG
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: LD_INT 2
88853: NEG
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 1
88861: PUSH
88862: LD_INT 1
88864: NEG
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: LD_INT 1
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 2
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 0
88902: PUSH
88903: LD_INT 2
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 1
88912: NEG
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 2
88923: NEG
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 2
88934: NEG
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: LD_INT 3
88950: NEG
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 0
88958: PUSH
88959: LD_INT 3
88961: NEG
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 1
88969: PUSH
88970: LD_INT 2
88972: NEG
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: PUSH
88978: LD_INT 2
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 3
88991: PUSH
88992: LD_INT 0
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 3
89001: PUSH
89002: LD_INT 1
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 1
89011: PUSH
89012: LD_INT 3
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 3
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 2
89042: NEG
89043: PUSH
89044: LD_INT 1
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 3
89053: NEG
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: PUSH
89062: LD_INT 3
89064: NEG
89065: PUSH
89066: LD_INT 1
89068: NEG
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89105: LD_ADDR_VAR 0 47
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 1
89125: NEG
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: LD_INT 0
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: LD_INT 1
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: LD_INT 1
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: LD_INT 0
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: NEG
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 1
89186: NEG
89187: PUSH
89188: LD_INT 2
89190: NEG
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: LD_INT 2
89201: NEG
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 2
89220: NEG
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 2
89232: NEG
89233: PUSH
89234: LD_INT 2
89236: NEG
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89256: LD_ADDR_VAR 0 48
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: LD_INT 0
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 0
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: LD_INT 2
89341: NEG
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: LD_INT 2
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 1
89360: PUSH
89361: LD_INT 1
89363: NEG
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 2
89371: PUSH
89372: LD_INT 0
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 2
89381: PUSH
89382: LD_INT 1
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89403: LD_ADDR_VAR 0 49
89407: PUSH
89408: LD_INT 0
89410: PUSH
89411: LD_INT 0
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 0
89420: PUSH
89421: LD_INT 1
89423: NEG
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 1
89431: PUSH
89432: LD_INT 0
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 1
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 0
89451: PUSH
89452: LD_INT 1
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 1
89461: NEG
89462: PUSH
89463: LD_INT 0
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 1
89472: NEG
89473: PUSH
89474: LD_INT 1
89476: NEG
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: LD_INT 1
89487: NEG
89488: PUSH
89489: EMPTY
89490: LIST
89491: LIST
89492: PUSH
89493: LD_INT 2
89495: PUSH
89496: LD_INT 0
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PUSH
89503: LD_INT 2
89505: PUSH
89506: LD_INT 1
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: LD_INT 2
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: PUSH
89523: LD_INT 1
89525: PUSH
89526: LD_INT 2
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89547: LD_ADDR_VAR 0 50
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: LD_INT 0
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 1
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: LD_INT 1
89620: NEG
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 2
89628: PUSH
89629: LD_INT 1
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 2
89638: PUSH
89639: LD_INT 2
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: PUSH
89649: LD_INT 2
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 0
89658: PUSH
89659: LD_INT 2
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 1
89668: NEG
89669: PUSH
89670: LD_INT 1
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89691: LD_ADDR_VAR 0 51
89695: PUSH
89696: LD_INT 0
89698: PUSH
89699: LD_INT 0
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 0
89708: PUSH
89709: LD_INT 1
89711: NEG
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 1
89719: PUSH
89720: LD_INT 0
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PUSH
89727: LD_INT 1
89729: PUSH
89730: LD_INT 1
89732: PUSH
89733: EMPTY
89734: LIST
89735: LIST
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: LD_INT 1
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 1
89749: NEG
89750: PUSH
89751: LD_INT 0
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 1
89760: NEG
89761: PUSH
89762: LD_INT 1
89764: NEG
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 1
89772: PUSH
89773: LD_INT 2
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 0
89782: PUSH
89783: LD_INT 2
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 1
89792: NEG
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 2
89803: NEG
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 2
89814: NEG
89815: PUSH
89816: LD_INT 1
89818: NEG
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89838: LD_ADDR_VAR 0 52
89842: PUSH
89843: LD_INT 0
89845: PUSH
89846: LD_INT 0
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: LD_INT 1
89858: NEG
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 1
89866: PUSH
89867: LD_INT 0
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 1
89876: PUSH
89877: LD_INT 1
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: LD_INT 1
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: LD_INT 0
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: LD_INT 1
89907: NEG
89908: PUSH
89909: LD_INT 1
89911: NEG
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 1
89919: NEG
89920: PUSH
89921: LD_INT 2
89923: NEG
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 1
89931: NEG
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 2
89942: NEG
89943: PUSH
89944: LD_INT 0
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 2
89953: NEG
89954: PUSH
89955: LD_INT 1
89957: NEG
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 2
89965: NEG
89966: PUSH
89967: LD_INT 2
89969: NEG
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: EMPTY
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89989: LD_ADDR_VAR 0 53
89993: PUSH
89994: LD_INT 0
89996: PUSH
89997: LD_INT 0
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 0
90006: PUSH
90007: LD_INT 1
90009: NEG
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 1
90017: PUSH
90018: LD_INT 0
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 1
90027: PUSH
90028: LD_INT 1
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 0
90037: PUSH
90038: LD_INT 1
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: LD_INT 0
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: PUSH
90060: LD_INT 1
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 1
90070: NEG
90071: PUSH
90072: LD_INT 2
90074: NEG
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 0
90082: PUSH
90083: LD_INT 2
90085: NEG
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 2
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 2
90114: PUSH
90115: LD_INT 1
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 2
90124: PUSH
90125: LD_INT 2
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 1
90134: PUSH
90135: LD_INT 2
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 0
90144: PUSH
90145: LD_INT 2
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 1
90154: NEG
90155: PUSH
90156: LD_INT 1
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 2
90165: NEG
90166: PUSH
90167: LD_INT 0
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 2
90176: NEG
90177: PUSH
90178: LD_INT 1
90180: NEG
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 2
90188: NEG
90189: PUSH
90190: LD_INT 2
90192: NEG
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90219: LD_ADDR_VAR 0 54
90223: PUSH
90224: LD_INT 0
90226: PUSH
90227: LD_INT 0
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 0
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: PUSH
90248: LD_INT 0
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 1
90257: PUSH
90258: LD_INT 1
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 0
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: LD_INT 0
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PUSH
90286: LD_INT 1
90288: NEG
90289: PUSH
90290: LD_INT 1
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 1
90300: NEG
90301: PUSH
90302: LD_INT 2
90304: NEG
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 0
90312: PUSH
90313: LD_INT 2
90315: NEG
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 2
90334: PUSH
90335: LD_INT 0
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 2
90344: PUSH
90345: LD_INT 1
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 2
90354: PUSH
90355: LD_INT 2
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 1
90364: PUSH
90365: LD_INT 2
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 0
90374: PUSH
90375: LD_INT 2
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 1
90384: NEG
90385: PUSH
90386: LD_INT 1
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 2
90395: NEG
90396: PUSH
90397: LD_INT 0
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: PUSH
90404: LD_INT 2
90406: NEG
90407: PUSH
90408: LD_INT 1
90410: NEG
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 2
90418: NEG
90419: PUSH
90420: LD_INT 2
90422: NEG
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90449: LD_ADDR_VAR 0 55
90453: PUSH
90454: LD_INT 0
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 0
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: LD_INT 1
90477: PUSH
90478: LD_INT 0
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: LD_INT 1
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 0
90497: PUSH
90498: LD_INT 1
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: LD_INT 0
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: LD_INT 1
90522: NEG
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: PUSH
90528: LD_INT 1
90530: NEG
90531: PUSH
90532: LD_INT 2
90534: NEG
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 0
90542: PUSH
90543: LD_INT 2
90545: NEG
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 1
90553: PUSH
90554: LD_INT 1
90556: NEG
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 2
90564: PUSH
90565: LD_INT 0
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: LD_INT 2
90574: PUSH
90575: LD_INT 1
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: PUSH
90582: LD_INT 2
90584: PUSH
90585: LD_INT 2
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 1
90594: PUSH
90595: LD_INT 2
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PUSH
90602: LD_INT 0
90604: PUSH
90605: LD_INT 2
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 1
90614: NEG
90615: PUSH
90616: LD_INT 1
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 2
90625: NEG
90626: PUSH
90627: LD_INT 0
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 2
90636: NEG
90637: PUSH
90638: LD_INT 1
90640: NEG
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 2
90648: NEG
90649: PUSH
90650: LD_INT 2
90652: NEG
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90679: LD_ADDR_VAR 0 56
90683: PUSH
90684: LD_INT 0
90686: PUSH
90687: LD_INT 0
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 0
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: PUSH
90708: LD_INT 0
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 1
90717: PUSH
90718: LD_INT 1
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: LD_INT 0
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: LD_INT 0
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: LD_INT 1
90752: NEG
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 1
90760: NEG
90761: PUSH
90762: LD_INT 2
90764: NEG
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 0
90772: PUSH
90773: LD_INT 2
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 2
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 2
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 2
90814: PUSH
90815: LD_INT 2
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: PUSH
90822: LD_INT 1
90824: PUSH
90825: LD_INT 2
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: PUSH
90832: LD_INT 0
90834: PUSH
90835: LD_INT 2
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 1
90844: NEG
90845: PUSH
90846: LD_INT 1
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 2
90855: NEG
90856: PUSH
90857: LD_INT 0
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 2
90866: NEG
90867: PUSH
90868: LD_INT 1
90870: NEG
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: LD_INT 2
90878: NEG
90879: PUSH
90880: LD_INT 2
90882: NEG
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90909: LD_ADDR_VAR 0 57
90913: PUSH
90914: LD_INT 0
90916: PUSH
90917: LD_INT 0
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: LD_INT 1
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: PUSH
90938: LD_INT 0
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 1
90947: PUSH
90948: LD_INT 1
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: LD_INT 1
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 1
90967: NEG
90968: PUSH
90969: LD_INT 0
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 1
90978: NEG
90979: PUSH
90980: LD_INT 1
90982: NEG
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 1
90990: NEG
90991: PUSH
90992: LD_INT 2
90994: NEG
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: LD_INT 0
91002: PUSH
91003: LD_INT 2
91005: NEG
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 1
91013: PUSH
91014: LD_INT 1
91016: NEG
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 2
91024: PUSH
91025: LD_INT 0
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 2
91034: PUSH
91035: LD_INT 1
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 2
91044: PUSH
91045: LD_INT 2
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: LD_INT 2
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: LD_INT 0
91064: PUSH
91065: LD_INT 2
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 1
91074: NEG
91075: PUSH
91076: LD_INT 1
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 2
91085: NEG
91086: PUSH
91087: LD_INT 0
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 2
91096: NEG
91097: PUSH
91098: LD_INT 1
91100: NEG
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 2
91108: NEG
91109: PUSH
91110: LD_INT 2
91112: NEG
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91139: LD_ADDR_VAR 0 58
91143: PUSH
91144: LD_INT 0
91146: PUSH
91147: LD_INT 0
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: LD_INT 1
91159: NEG
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 1
91167: PUSH
91168: LD_INT 0
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 1
91177: PUSH
91178: LD_INT 1
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 0
91187: PUSH
91188: LD_INT 1
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 1
91197: NEG
91198: PUSH
91199: LD_INT 0
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 1
91208: NEG
91209: PUSH
91210: LD_INT 1
91212: NEG
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: PUSH
91218: LD_INT 1
91220: NEG
91221: PUSH
91222: LD_INT 2
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 0
91232: PUSH
91233: LD_INT 2
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: LD_INT 1
91246: NEG
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 2
91254: PUSH
91255: LD_INT 0
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: LD_INT 1
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 2
91274: PUSH
91275: LD_INT 2
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 1
91284: PUSH
91285: LD_INT 2
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: LD_INT 2
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 2
91315: NEG
91316: PUSH
91317: LD_INT 0
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 2
91326: NEG
91327: PUSH
91328: LD_INT 1
91330: NEG
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 2
91338: NEG
91339: PUSH
91340: LD_INT 2
91342: NEG
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91369: LD_ADDR_VAR 0 59
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: LD_INT 0
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 0
91386: PUSH
91387: LD_INT 1
91389: NEG
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 1
91397: PUSH
91398: LD_INT 0
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: LD_INT 1
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 0
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 1
91427: NEG
91428: PUSH
91429: LD_INT 0
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 1
91438: NEG
91439: PUSH
91440: LD_INT 1
91442: NEG
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91457: LD_ADDR_VAR 0 60
91461: PUSH
91462: LD_INT 0
91464: PUSH
91465: LD_INT 0
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 1
91485: PUSH
91486: LD_INT 0
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: LD_INT 1
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 0
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91545: LD_ADDR_VAR 0 61
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: LD_INT 0
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 0
91562: PUSH
91563: LD_INT 1
91565: NEG
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 1
91573: PUSH
91574: LD_INT 0
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 1
91583: PUSH
91584: LD_INT 1
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 0
91593: PUSH
91594: LD_INT 1
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 1
91603: NEG
91604: PUSH
91605: LD_INT 0
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 1
91614: NEG
91615: PUSH
91616: LD_INT 1
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91633: LD_ADDR_VAR 0 62
91637: PUSH
91638: LD_INT 0
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 0
91650: PUSH
91651: LD_INT 1
91653: NEG
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 1
91661: PUSH
91662: LD_INT 0
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 1
91671: PUSH
91672: LD_INT 1
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 0
91681: PUSH
91682: LD_INT 1
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: LD_INT 1
91691: NEG
91692: PUSH
91693: LD_INT 0
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 1
91702: NEG
91703: PUSH
91704: LD_INT 1
91706: NEG
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91721: LD_ADDR_VAR 0 63
91725: PUSH
91726: LD_INT 0
91728: PUSH
91729: LD_INT 0
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 0
91738: PUSH
91739: LD_INT 1
91741: NEG
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: LD_INT 0
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 1
91759: PUSH
91760: LD_INT 1
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 1
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: LD_INT 0
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: NEG
91791: PUSH
91792: LD_INT 1
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91809: LD_ADDR_VAR 0 64
91813: PUSH
91814: LD_INT 0
91816: PUSH
91817: LD_INT 0
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 0
91826: PUSH
91827: LD_INT 1
91829: NEG
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: PUSH
91835: LD_INT 1
91837: PUSH
91838: LD_INT 0
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 1
91847: PUSH
91848: LD_INT 1
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: LD_INT 1
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 1
91867: NEG
91868: PUSH
91869: LD_INT 0
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 1
91878: NEG
91879: PUSH
91880: LD_INT 1
91882: NEG
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: ST_TO_ADDR
// end ; 1 :
91897: GO 97794
91899: LD_INT 1
91901: DOUBLE
91902: EQUAL
91903: IFTRUE 91907
91905: GO 94530
91907: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91908: LD_ADDR_VAR 0 11
91912: PUSH
91913: LD_INT 1
91915: NEG
91916: PUSH
91917: LD_INT 3
91919: NEG
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 0
91927: PUSH
91928: LD_INT 3
91930: NEG
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 1
91938: PUSH
91939: LD_INT 2
91941: NEG
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: LIST
91951: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91952: LD_ADDR_VAR 0 12
91956: PUSH
91957: LD_INT 2
91959: PUSH
91960: LD_INT 1
91962: NEG
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: PUSH
91968: LD_INT 3
91970: PUSH
91971: LD_INT 0
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: PUSH
91978: LD_INT 3
91980: PUSH
91981: LD_INT 1
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: LIST
91992: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91993: LD_ADDR_VAR 0 13
91997: PUSH
91998: LD_INT 3
92000: PUSH
92001: LD_INT 2
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 3
92010: PUSH
92011: LD_INT 3
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 2
92020: PUSH
92021: LD_INT 3
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: LIST
92032: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92033: LD_ADDR_VAR 0 14
92037: PUSH
92038: LD_INT 1
92040: PUSH
92041: LD_INT 3
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 0
92050: PUSH
92051: LD_INT 3
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 1
92060: NEG
92061: PUSH
92062: LD_INT 2
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: LIST
92073: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92074: LD_ADDR_VAR 0 15
92078: PUSH
92079: LD_INT 2
92081: NEG
92082: PUSH
92083: LD_INT 1
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 3
92092: NEG
92093: PUSH
92094: LD_INT 0
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 3
92103: NEG
92104: PUSH
92105: LD_INT 1
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: LIST
92117: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92118: LD_ADDR_VAR 0 16
92122: PUSH
92123: LD_INT 2
92125: NEG
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 3
92137: NEG
92138: PUSH
92139: LD_INT 2
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 3
92149: NEG
92150: PUSH
92151: LD_INT 3
92153: NEG
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: LIST
92163: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92164: LD_ADDR_VAR 0 17
92168: PUSH
92169: LD_INT 1
92171: NEG
92172: PUSH
92173: LD_INT 3
92175: NEG
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: LD_INT 3
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 1
92194: PUSH
92195: LD_INT 2
92197: NEG
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: LIST
92207: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92208: LD_ADDR_VAR 0 18
92212: PUSH
92213: LD_INT 2
92215: PUSH
92216: LD_INT 1
92218: NEG
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 3
92226: PUSH
92227: LD_INT 0
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 3
92236: PUSH
92237: LD_INT 1
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: LIST
92248: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92249: LD_ADDR_VAR 0 19
92253: PUSH
92254: LD_INT 3
92256: PUSH
92257: LD_INT 2
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 3
92266: PUSH
92267: LD_INT 3
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 2
92276: PUSH
92277: LD_INT 3
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: LIST
92288: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92289: LD_ADDR_VAR 0 20
92293: PUSH
92294: LD_INT 1
92296: PUSH
92297: LD_INT 3
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 0
92306: PUSH
92307: LD_INT 3
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 1
92316: NEG
92317: PUSH
92318: LD_INT 2
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: LIST
92329: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92330: LD_ADDR_VAR 0 21
92334: PUSH
92335: LD_INT 2
92337: NEG
92338: PUSH
92339: LD_INT 1
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 3
92348: NEG
92349: PUSH
92350: LD_INT 0
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 3
92359: NEG
92360: PUSH
92361: LD_INT 1
92363: NEG
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: LIST
92373: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92374: LD_ADDR_VAR 0 22
92378: PUSH
92379: LD_INT 2
92381: NEG
92382: PUSH
92383: LD_INT 3
92385: NEG
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 3
92393: NEG
92394: PUSH
92395: LD_INT 2
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: LD_INT 3
92409: NEG
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: LIST
92419: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92420: LD_ADDR_VAR 0 23
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: LD_INT 3
92430: NEG
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 1
92438: NEG
92439: PUSH
92440: LD_INT 4
92442: NEG
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 1
92450: PUSH
92451: LD_INT 3
92453: NEG
92454: PUSH
92455: EMPTY
92456: LIST
92457: LIST
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: LIST
92463: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92464: LD_ADDR_VAR 0 24
92468: PUSH
92469: LD_INT 3
92471: PUSH
92472: LD_INT 0
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: PUSH
92479: LD_INT 3
92481: PUSH
92482: LD_INT 1
92484: NEG
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: LD_INT 4
92492: PUSH
92493: LD_INT 1
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: LIST
92504: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92505: LD_ADDR_VAR 0 25
92509: PUSH
92510: LD_INT 3
92512: PUSH
92513: LD_INT 3
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 4
92522: PUSH
92523: LD_INT 3
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 3
92532: PUSH
92533: LD_INT 4
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: LIST
92544: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92545: LD_ADDR_VAR 0 26
92549: PUSH
92550: LD_INT 0
92552: PUSH
92553: LD_INT 3
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 1
92562: PUSH
92563: LD_INT 4
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 1
92572: NEG
92573: PUSH
92574: LD_INT 3
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: LIST
92585: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92586: LD_ADDR_VAR 0 27
92590: PUSH
92591: LD_INT 3
92593: NEG
92594: PUSH
92595: LD_INT 0
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: PUSH
92602: LD_INT 3
92604: NEG
92605: PUSH
92606: LD_INT 1
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 4
92615: NEG
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: LIST
92629: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92630: LD_ADDR_VAR 0 28
92634: PUSH
92635: LD_INT 3
92637: NEG
92638: PUSH
92639: LD_INT 3
92641: NEG
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 3
92649: NEG
92650: PUSH
92651: LD_INT 4
92653: NEG
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 4
92661: NEG
92662: PUSH
92663: LD_INT 3
92665: NEG
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: LIST
92675: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92676: LD_ADDR_VAR 0 29
92680: PUSH
92681: LD_INT 1
92683: NEG
92684: PUSH
92685: LD_INT 3
92687: NEG
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 0
92695: PUSH
92696: LD_INT 3
92698: NEG
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: LD_INT 2
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 1
92717: NEG
92718: PUSH
92719: LD_INT 4
92721: NEG
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 0
92729: PUSH
92730: LD_INT 4
92732: NEG
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 1
92740: PUSH
92741: LD_INT 3
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 1
92751: NEG
92752: PUSH
92753: LD_INT 5
92755: NEG
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 0
92763: PUSH
92764: LD_INT 5
92766: NEG
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: LD_INT 1
92774: PUSH
92775: LD_INT 4
92777: NEG
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 1
92785: NEG
92786: PUSH
92787: LD_INT 6
92789: NEG
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 0
92797: PUSH
92798: LD_INT 6
92800: NEG
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 1
92808: PUSH
92809: LD_INT 5
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92831: LD_ADDR_VAR 0 30
92835: PUSH
92836: LD_INT 2
92838: PUSH
92839: LD_INT 1
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 3
92849: PUSH
92850: LD_INT 0
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 3
92859: PUSH
92860: LD_INT 1
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 3
92869: PUSH
92870: LD_INT 1
92872: NEG
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 4
92880: PUSH
92881: LD_INT 0
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 4
92890: PUSH
92891: LD_INT 1
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 4
92900: PUSH
92901: LD_INT 1
92903: NEG
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 5
92911: PUSH
92912: LD_INT 0
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 5
92921: PUSH
92922: LD_INT 1
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 5
92931: PUSH
92932: LD_INT 1
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 6
92942: PUSH
92943: LD_INT 0
92945: PUSH
92946: EMPTY
92947: LIST
92948: LIST
92949: PUSH
92950: LD_INT 6
92952: PUSH
92953: LD_INT 1
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92974: LD_ADDR_VAR 0 31
92978: PUSH
92979: LD_INT 3
92981: PUSH
92982: LD_INT 2
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 3
92991: PUSH
92992: LD_INT 3
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 2
93001: PUSH
93002: LD_INT 3
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PUSH
93009: LD_INT 4
93011: PUSH
93012: LD_INT 3
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 4
93021: PUSH
93022: LD_INT 4
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 3
93031: PUSH
93032: LD_INT 4
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 5
93041: PUSH
93042: LD_INT 4
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 5
93051: PUSH
93052: LD_INT 5
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 4
93061: PUSH
93062: LD_INT 5
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 6
93071: PUSH
93072: LD_INT 5
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 6
93081: PUSH
93082: LD_INT 6
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 5
93091: PUSH
93092: LD_INT 6
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93113: LD_ADDR_VAR 0 32
93117: PUSH
93118: LD_INT 1
93120: PUSH
93121: LD_INT 3
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: PUSH
93128: LD_INT 0
93130: PUSH
93131: LD_INT 3
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 1
93140: NEG
93141: PUSH
93142: LD_INT 2
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 1
93151: PUSH
93152: LD_INT 4
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: LD_INT 0
93161: PUSH
93162: LD_INT 4
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: PUSH
93169: LD_INT 1
93171: NEG
93172: PUSH
93173: LD_INT 3
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 1
93182: PUSH
93183: LD_INT 5
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 0
93192: PUSH
93193: LD_INT 5
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 1
93202: NEG
93203: PUSH
93204: LD_INT 4
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 1
93213: PUSH
93214: LD_INT 6
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: LD_INT 0
93223: PUSH
93224: LD_INT 6
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: PUSH
93231: LD_INT 1
93233: NEG
93234: PUSH
93235: LD_INT 5
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93256: LD_ADDR_VAR 0 33
93260: PUSH
93261: LD_INT 2
93263: NEG
93264: PUSH
93265: LD_INT 1
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 3
93274: NEG
93275: PUSH
93276: LD_INT 0
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 3
93285: NEG
93286: PUSH
93287: LD_INT 1
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 3
93297: NEG
93298: PUSH
93299: LD_INT 1
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 4
93308: NEG
93309: PUSH
93310: LD_INT 0
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 4
93319: NEG
93320: PUSH
93321: LD_INT 1
93323: NEG
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 4
93331: NEG
93332: PUSH
93333: LD_INT 1
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 5
93342: NEG
93343: PUSH
93344: LD_INT 0
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 5
93353: NEG
93354: PUSH
93355: LD_INT 1
93357: NEG
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 5
93365: NEG
93366: PUSH
93367: LD_INT 1
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 6
93376: NEG
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 6
93387: NEG
93388: PUSH
93389: LD_INT 1
93391: NEG
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93411: LD_ADDR_VAR 0 34
93415: PUSH
93416: LD_INT 2
93418: NEG
93419: PUSH
93420: LD_INT 3
93422: NEG
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: LD_INT 3
93430: NEG
93431: PUSH
93432: LD_INT 2
93434: NEG
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 3
93442: NEG
93443: PUSH
93444: LD_INT 3
93446: NEG
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 3
93454: NEG
93455: PUSH
93456: LD_INT 4
93458: NEG
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 4
93466: NEG
93467: PUSH
93468: LD_INT 3
93470: NEG
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 4
93478: NEG
93479: PUSH
93480: LD_INT 4
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 4
93490: NEG
93491: PUSH
93492: LD_INT 5
93494: NEG
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 5
93502: NEG
93503: PUSH
93504: LD_INT 4
93506: NEG
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 5
93514: NEG
93515: PUSH
93516: LD_INT 5
93518: NEG
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 5
93526: NEG
93527: PUSH
93528: LD_INT 6
93530: NEG
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 6
93538: NEG
93539: PUSH
93540: LD_INT 5
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 6
93550: NEG
93551: PUSH
93552: LD_INT 6
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93574: LD_ADDR_VAR 0 41
93578: PUSH
93579: LD_INT 0
93581: PUSH
93582: LD_INT 2
93584: NEG
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: LD_INT 1
93592: NEG
93593: PUSH
93594: LD_INT 3
93596: NEG
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: LD_INT 2
93607: NEG
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: LIST
93617: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93618: LD_ADDR_VAR 0 42
93622: PUSH
93623: LD_INT 2
93625: PUSH
93626: LD_INT 0
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 2
93635: PUSH
93636: LD_INT 1
93638: NEG
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 3
93646: PUSH
93647: LD_INT 1
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: LIST
93658: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93659: LD_ADDR_VAR 0 43
93663: PUSH
93664: LD_INT 2
93666: PUSH
93667: LD_INT 2
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 3
93676: PUSH
93677: LD_INT 2
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 2
93686: PUSH
93687: LD_INT 3
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: LIST
93698: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93699: LD_ADDR_VAR 0 44
93703: PUSH
93704: LD_INT 0
93706: PUSH
93707: LD_INT 2
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 1
93716: PUSH
93717: LD_INT 3
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 1
93726: NEG
93727: PUSH
93728: LD_INT 2
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: LIST
93739: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93740: LD_ADDR_VAR 0 45
93744: PUSH
93745: LD_INT 2
93747: NEG
93748: PUSH
93749: LD_INT 0
93751: PUSH
93752: EMPTY
93753: LIST
93754: LIST
93755: PUSH
93756: LD_INT 2
93758: NEG
93759: PUSH
93760: LD_INT 1
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: PUSH
93767: LD_INT 3
93769: NEG
93770: PUSH
93771: LD_INT 1
93773: NEG
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: LIST
93783: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93784: LD_ADDR_VAR 0 46
93788: PUSH
93789: LD_INT 2
93791: NEG
93792: PUSH
93793: LD_INT 2
93795: NEG
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 2
93803: NEG
93804: PUSH
93805: LD_INT 3
93807: NEG
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: LD_INT 3
93815: NEG
93816: PUSH
93817: LD_INT 2
93819: NEG
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: LIST
93829: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93830: LD_ADDR_VAR 0 47
93834: PUSH
93835: LD_INT 2
93837: NEG
93838: PUSH
93839: LD_INT 3
93841: NEG
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 1
93849: NEG
93850: PUSH
93851: LD_INT 3
93853: NEG
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93863: LD_ADDR_VAR 0 48
93867: PUSH
93868: LD_INT 1
93870: PUSH
93871: LD_INT 2
93873: NEG
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 2
93881: PUSH
93882: LD_INT 1
93884: NEG
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93894: LD_ADDR_VAR 0 49
93898: PUSH
93899: LD_INT 3
93901: PUSH
93902: LD_INT 1
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 3
93911: PUSH
93912: LD_INT 2
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93923: LD_ADDR_VAR 0 50
93927: PUSH
93928: LD_INT 2
93930: PUSH
93931: LD_INT 3
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 1
93940: PUSH
93941: LD_INT 3
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93952: LD_ADDR_VAR 0 51
93956: PUSH
93957: LD_INT 1
93959: NEG
93960: PUSH
93961: LD_INT 2
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 2
93970: NEG
93971: PUSH
93972: LD_INT 1
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93983: LD_ADDR_VAR 0 52
93987: PUSH
93988: LD_INT 3
93990: NEG
93991: PUSH
93992: LD_INT 1
93994: NEG
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 3
94002: NEG
94003: PUSH
94004: LD_INT 2
94006: NEG
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94016: LD_ADDR_VAR 0 53
94020: PUSH
94021: LD_INT 1
94023: NEG
94024: PUSH
94025: LD_INT 3
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 0
94035: PUSH
94036: LD_INT 3
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 1
94046: PUSH
94047: LD_INT 2
94049: NEG
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: LIST
94059: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94060: LD_ADDR_VAR 0 54
94064: PUSH
94065: LD_INT 2
94067: PUSH
94068: LD_INT 1
94070: NEG
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 3
94078: PUSH
94079: LD_INT 0
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: LD_INT 3
94088: PUSH
94089: LD_INT 1
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: LIST
94100: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94101: LD_ADDR_VAR 0 55
94105: PUSH
94106: LD_INT 3
94108: PUSH
94109: LD_INT 2
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 3
94118: PUSH
94119: LD_INT 3
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 2
94128: PUSH
94129: LD_INT 3
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: LIST
94140: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94141: LD_ADDR_VAR 0 56
94145: PUSH
94146: LD_INT 1
94148: PUSH
94149: LD_INT 3
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 0
94158: PUSH
94159: LD_INT 3
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: PUSH
94166: LD_INT 1
94168: NEG
94169: PUSH
94170: LD_INT 2
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: LIST
94181: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94182: LD_ADDR_VAR 0 57
94186: PUSH
94187: LD_INT 2
94189: NEG
94190: PUSH
94191: LD_INT 1
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 3
94200: NEG
94201: PUSH
94202: LD_INT 0
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 3
94211: NEG
94212: PUSH
94213: LD_INT 1
94215: NEG
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: LIST
94225: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94226: LD_ADDR_VAR 0 58
94230: PUSH
94231: LD_INT 2
94233: NEG
94234: PUSH
94235: LD_INT 3
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 3
94245: NEG
94246: PUSH
94247: LD_INT 2
94249: NEG
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: NEG
94258: PUSH
94259: LD_INT 3
94261: NEG
94262: PUSH
94263: EMPTY
94264: LIST
94265: LIST
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: LIST
94271: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94272: LD_ADDR_VAR 0 59
94276: PUSH
94277: LD_INT 1
94279: NEG
94280: PUSH
94281: LD_INT 2
94283: NEG
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 0
94291: PUSH
94292: LD_INT 2
94294: NEG
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 1
94302: PUSH
94303: LD_INT 1
94305: NEG
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: LIST
94315: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94316: LD_ADDR_VAR 0 60
94320: PUSH
94321: LD_INT 1
94323: PUSH
94324: LD_INT 1
94326: NEG
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 2
94334: PUSH
94335: LD_INT 0
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 2
94344: PUSH
94345: LD_INT 1
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: LIST
94356: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94357: LD_ADDR_VAR 0 61
94361: PUSH
94362: LD_INT 2
94364: PUSH
94365: LD_INT 1
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 2
94374: PUSH
94375: LD_INT 2
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 1
94384: PUSH
94385: LD_INT 2
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: LIST
94396: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94397: LD_ADDR_VAR 0 62
94401: PUSH
94402: LD_INT 1
94404: PUSH
94405: LD_INT 2
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 0
94414: PUSH
94415: LD_INT 2
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 1
94424: NEG
94425: PUSH
94426: LD_INT 1
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: LIST
94437: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94438: LD_ADDR_VAR 0 63
94442: PUSH
94443: LD_INT 1
94445: NEG
94446: PUSH
94447: LD_INT 1
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 2
94456: NEG
94457: PUSH
94458: LD_INT 0
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 2
94467: NEG
94468: PUSH
94469: LD_INT 1
94471: NEG
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: LIST
94481: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94482: LD_ADDR_VAR 0 64
94486: PUSH
94487: LD_INT 1
94489: NEG
94490: PUSH
94491: LD_INT 2
94493: NEG
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 2
94501: NEG
94502: PUSH
94503: LD_INT 1
94505: NEG
94506: PUSH
94507: EMPTY
94508: LIST
94509: LIST
94510: PUSH
94511: LD_INT 2
94513: NEG
94514: PUSH
94515: LD_INT 2
94517: NEG
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: LIST
94527: ST_TO_ADDR
// end ; 2 :
94528: GO 97794
94530: LD_INT 2
94532: DOUBLE
94533: EQUAL
94534: IFTRUE 94538
94536: GO 97793
94538: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94539: LD_ADDR_VAR 0 29
94543: PUSH
94544: LD_INT 4
94546: PUSH
94547: LD_INT 0
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: LD_INT 4
94556: PUSH
94557: LD_INT 1
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 5
94567: PUSH
94568: LD_INT 0
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: LD_INT 5
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 4
94587: PUSH
94588: LD_INT 1
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: PUSH
94595: LD_INT 3
94597: PUSH
94598: LD_INT 0
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 3
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 3
94618: PUSH
94619: LD_INT 2
94621: NEG
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 5
94629: PUSH
94630: LD_INT 2
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 3
94639: PUSH
94640: LD_INT 3
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 3
94649: PUSH
94650: LD_INT 2
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: PUSH
94657: LD_INT 4
94659: PUSH
94660: LD_INT 3
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 4
94669: PUSH
94670: LD_INT 4
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 3
94679: PUSH
94680: LD_INT 4
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 2
94689: PUSH
94690: LD_INT 3
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 2
94699: PUSH
94700: LD_INT 2
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: PUSH
94707: LD_INT 4
94709: PUSH
94710: LD_INT 2
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: PUSH
94717: LD_INT 2
94719: PUSH
94720: LD_INT 4
94722: PUSH
94723: EMPTY
94724: LIST
94725: LIST
94726: PUSH
94727: LD_INT 0
94729: PUSH
94730: LD_INT 4
94732: PUSH
94733: EMPTY
94734: LIST
94735: LIST
94736: PUSH
94737: LD_INT 0
94739: PUSH
94740: LD_INT 3
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 1
94749: PUSH
94750: LD_INT 4
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: LD_INT 1
94759: PUSH
94760: LD_INT 5
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 0
94769: PUSH
94770: LD_INT 5
94772: PUSH
94773: EMPTY
94774: LIST
94775: LIST
94776: PUSH
94777: LD_INT 1
94779: NEG
94780: PUSH
94781: LD_INT 4
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 1
94790: NEG
94791: PUSH
94792: LD_INT 3
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: PUSH
94799: LD_INT 2
94801: PUSH
94802: LD_INT 5
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 2
94811: NEG
94812: PUSH
94813: LD_INT 3
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 3
94822: NEG
94823: PUSH
94824: LD_INT 0
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 3
94833: NEG
94834: PUSH
94835: LD_INT 1
94837: NEG
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 2
94845: NEG
94846: PUSH
94847: LD_INT 0
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 2
94856: NEG
94857: PUSH
94858: LD_INT 1
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 3
94867: NEG
94868: PUSH
94869: LD_INT 1
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 4
94878: NEG
94879: PUSH
94880: LD_INT 0
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 4
94889: NEG
94890: PUSH
94891: LD_INT 1
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 4
94901: NEG
94902: PUSH
94903: LD_INT 2
94905: NEG
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 2
94913: NEG
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 4
94924: NEG
94925: PUSH
94926: LD_INT 4
94928: NEG
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 4
94936: NEG
94937: PUSH
94938: LD_INT 5
94940: NEG
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 3
94948: NEG
94949: PUSH
94950: LD_INT 4
94952: NEG
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: LD_INT 3
94960: NEG
94961: PUSH
94962: LD_INT 3
94964: NEG
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 4
94972: NEG
94973: PUSH
94974: LD_INT 3
94976: NEG
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: LD_INT 4
94988: NEG
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 5
94996: NEG
94997: PUSH
94998: LD_INT 5
95000: NEG
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 3
95008: NEG
95009: PUSH
95010: LD_INT 5
95012: NEG
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 5
95020: NEG
95021: PUSH
95022: LD_INT 3
95024: NEG
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95077: LD_ADDR_VAR 0 30
95081: PUSH
95082: LD_INT 4
95084: PUSH
95085: LD_INT 4
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 4
95094: PUSH
95095: LD_INT 3
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 5
95104: PUSH
95105: LD_INT 4
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 5
95114: PUSH
95115: LD_INT 5
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 4
95124: PUSH
95125: LD_INT 5
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 3
95134: PUSH
95135: LD_INT 4
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 3
95144: PUSH
95145: LD_INT 3
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: LD_INT 5
95154: PUSH
95155: LD_INT 3
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 3
95164: PUSH
95165: LD_INT 5
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 0
95174: PUSH
95175: LD_INT 3
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 0
95184: PUSH
95185: LD_INT 2
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 1
95194: PUSH
95195: LD_INT 3
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 1
95204: PUSH
95205: LD_INT 4
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 0
95214: PUSH
95215: LD_INT 4
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 1
95224: NEG
95225: PUSH
95226: LD_INT 3
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 1
95235: NEG
95236: PUSH
95237: LD_INT 2
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 2
95246: PUSH
95247: LD_INT 4
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: LD_INT 2
95256: NEG
95257: PUSH
95258: LD_INT 2
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 4
95267: NEG
95268: PUSH
95269: LD_INT 0
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: PUSH
95276: LD_INT 4
95278: NEG
95279: PUSH
95280: LD_INT 1
95282: NEG
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 3
95290: NEG
95291: PUSH
95292: LD_INT 0
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 3
95301: NEG
95302: PUSH
95303: LD_INT 1
95305: PUSH
95306: EMPTY
95307: LIST
95308: LIST
95309: PUSH
95310: LD_INT 4
95312: NEG
95313: PUSH
95314: LD_INT 1
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: PUSH
95321: LD_INT 5
95323: NEG
95324: PUSH
95325: LD_INT 0
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 5
95334: NEG
95335: PUSH
95336: LD_INT 1
95338: NEG
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 5
95346: NEG
95347: PUSH
95348: LD_INT 2
95350: NEG
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 3
95358: NEG
95359: PUSH
95360: LD_INT 2
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 3
95369: NEG
95370: PUSH
95371: LD_INT 3
95373: NEG
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 3
95381: NEG
95382: PUSH
95383: LD_INT 4
95385: NEG
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 2
95393: NEG
95394: PUSH
95395: LD_INT 3
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 2
95405: NEG
95406: PUSH
95407: LD_INT 2
95409: NEG
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 3
95417: NEG
95418: PUSH
95419: LD_INT 2
95421: NEG
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 4
95429: NEG
95430: PUSH
95431: LD_INT 3
95433: NEG
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 4
95441: NEG
95442: PUSH
95443: LD_INT 4
95445: NEG
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 2
95453: NEG
95454: PUSH
95455: LD_INT 4
95457: NEG
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: PUSH
95463: LD_INT 4
95465: NEG
95466: PUSH
95467: LD_INT 2
95469: NEG
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: PUSH
95475: LD_INT 0
95477: PUSH
95478: LD_INT 4
95480: NEG
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 0
95488: PUSH
95489: LD_INT 5
95491: NEG
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 1
95499: PUSH
95500: LD_INT 4
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 1
95510: PUSH
95511: LD_INT 3
95513: NEG
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 0
95521: PUSH
95522: LD_INT 3
95524: NEG
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: PUSH
95530: LD_INT 1
95532: NEG
95533: PUSH
95534: LD_INT 4
95536: NEG
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 1
95544: NEG
95545: PUSH
95546: LD_INT 5
95548: NEG
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 2
95556: PUSH
95557: LD_INT 3
95559: NEG
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 2
95567: NEG
95568: PUSH
95569: LD_INT 5
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95624: LD_ADDR_VAR 0 31
95628: PUSH
95629: LD_INT 0
95631: PUSH
95632: LD_INT 4
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 1
95651: PUSH
95652: LD_INT 4
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: LD_INT 5
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: LD_INT 5
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 1
95681: NEG
95682: PUSH
95683: LD_INT 4
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: LD_INT 1
95692: NEG
95693: PUSH
95694: LD_INT 3
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 2
95703: PUSH
95704: LD_INT 5
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 2
95713: NEG
95714: PUSH
95715: LD_INT 3
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 3
95724: NEG
95725: PUSH
95726: LD_INT 0
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 3
95735: NEG
95736: PUSH
95737: LD_INT 1
95739: NEG
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 2
95747: NEG
95748: PUSH
95749: LD_INT 0
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 2
95758: NEG
95759: PUSH
95760: LD_INT 1
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 3
95769: NEG
95770: PUSH
95771: LD_INT 1
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 4
95780: NEG
95781: PUSH
95782: LD_INT 0
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: PUSH
95789: LD_INT 4
95791: NEG
95792: PUSH
95793: LD_INT 1
95795: NEG
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: LD_INT 4
95803: NEG
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 2
95815: NEG
95816: PUSH
95817: LD_INT 2
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: LD_INT 4
95826: NEG
95827: PUSH
95828: LD_INT 4
95830: NEG
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 4
95838: NEG
95839: PUSH
95840: LD_INT 5
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 3
95850: NEG
95851: PUSH
95852: LD_INT 4
95854: NEG
95855: PUSH
95856: EMPTY
95857: LIST
95858: LIST
95859: PUSH
95860: LD_INT 3
95862: NEG
95863: PUSH
95864: LD_INT 3
95866: NEG
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 4
95874: NEG
95875: PUSH
95876: LD_INT 3
95878: NEG
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: PUSH
95884: LD_INT 5
95886: NEG
95887: PUSH
95888: LD_INT 4
95890: NEG
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 5
95898: NEG
95899: PUSH
95900: LD_INT 5
95902: NEG
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: PUSH
95908: LD_INT 3
95910: NEG
95911: PUSH
95912: LD_INT 5
95914: NEG
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: LD_INT 5
95922: NEG
95923: PUSH
95924: LD_INT 3
95926: NEG
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: PUSH
95932: LD_INT 0
95934: PUSH
95935: LD_INT 3
95937: NEG
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 0
95945: PUSH
95946: LD_INT 4
95948: NEG
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 1
95956: PUSH
95957: LD_INT 3
95959: NEG
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 1
95967: PUSH
95968: LD_INT 2
95970: NEG
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 0
95978: PUSH
95979: LD_INT 2
95981: NEG
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 1
95989: NEG
95990: PUSH
95991: LD_INT 3
95993: NEG
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 1
96001: NEG
96002: PUSH
96003: LD_INT 4
96005: NEG
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 2
96013: PUSH
96014: LD_INT 2
96016: NEG
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 2
96024: NEG
96025: PUSH
96026: LD_INT 4
96028: NEG
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: LD_INT 4
96036: PUSH
96037: LD_INT 0
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: PUSH
96044: LD_INT 4
96046: PUSH
96047: LD_INT 1
96049: NEG
96050: PUSH
96051: EMPTY
96052: LIST
96053: LIST
96054: PUSH
96055: LD_INT 5
96057: PUSH
96058: LD_INT 0
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 5
96067: PUSH
96068: LD_INT 1
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 4
96077: PUSH
96078: LD_INT 1
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 3
96087: PUSH
96088: LD_INT 0
96090: PUSH
96091: EMPTY
96092: LIST
96093: LIST
96094: PUSH
96095: LD_INT 3
96097: PUSH
96098: LD_INT 1
96100: NEG
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 3
96108: PUSH
96109: LD_INT 2
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 5
96119: PUSH
96120: LD_INT 2
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96174: LD_ADDR_VAR 0 32
96178: PUSH
96179: LD_INT 4
96181: NEG
96182: PUSH
96183: LD_INT 0
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 4
96192: NEG
96193: PUSH
96194: LD_INT 1
96196: NEG
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PUSH
96202: LD_INT 3
96204: NEG
96205: PUSH
96206: LD_INT 0
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 3
96215: NEG
96216: PUSH
96217: LD_INT 1
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 4
96226: NEG
96227: PUSH
96228: LD_INT 1
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PUSH
96235: LD_INT 5
96237: NEG
96238: PUSH
96239: LD_INT 0
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 5
96248: NEG
96249: PUSH
96250: LD_INT 1
96252: NEG
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 5
96260: NEG
96261: PUSH
96262: LD_INT 2
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 3
96272: NEG
96273: PUSH
96274: LD_INT 2
96276: PUSH
96277: EMPTY
96278: LIST
96279: LIST
96280: PUSH
96281: LD_INT 3
96283: NEG
96284: PUSH
96285: LD_INT 3
96287: NEG
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 3
96295: NEG
96296: PUSH
96297: LD_INT 4
96299: NEG
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 2
96307: NEG
96308: PUSH
96309: LD_INT 3
96311: NEG
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: PUSH
96317: LD_INT 2
96319: NEG
96320: PUSH
96321: LD_INT 2
96323: NEG
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: PUSH
96329: LD_INT 3
96331: NEG
96332: PUSH
96333: LD_INT 2
96335: NEG
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 4
96343: NEG
96344: PUSH
96345: LD_INT 3
96347: NEG
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 4
96355: NEG
96356: PUSH
96357: LD_INT 4
96359: NEG
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: PUSH
96365: LD_INT 2
96367: NEG
96368: PUSH
96369: LD_INT 4
96371: NEG
96372: PUSH
96373: EMPTY
96374: LIST
96375: LIST
96376: PUSH
96377: LD_INT 4
96379: NEG
96380: PUSH
96381: LD_INT 2
96383: NEG
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: LD_INT 0
96391: PUSH
96392: LD_INT 4
96394: NEG
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: LD_INT 0
96402: PUSH
96403: LD_INT 5
96405: NEG
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 1
96413: PUSH
96414: LD_INT 4
96416: NEG
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_INT 1
96424: PUSH
96425: LD_INT 3
96427: NEG
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 0
96435: PUSH
96436: LD_INT 3
96438: NEG
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 1
96446: NEG
96447: PUSH
96448: LD_INT 4
96450: NEG
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 1
96458: NEG
96459: PUSH
96460: LD_INT 5
96462: NEG
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 2
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 2
96481: NEG
96482: PUSH
96483: LD_INT 5
96485: NEG
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 3
96493: PUSH
96494: LD_INT 0
96496: PUSH
96497: EMPTY
96498: LIST
96499: LIST
96500: PUSH
96501: LD_INT 3
96503: PUSH
96504: LD_INT 1
96506: NEG
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: PUSH
96512: LD_INT 4
96514: PUSH
96515: LD_INT 0
96517: PUSH
96518: EMPTY
96519: LIST
96520: LIST
96521: PUSH
96522: LD_INT 4
96524: PUSH
96525: LD_INT 1
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: PUSH
96532: LD_INT 3
96534: PUSH
96535: LD_INT 1
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: PUSH
96542: LD_INT 2
96544: PUSH
96545: LD_INT 0
96547: PUSH
96548: EMPTY
96549: LIST
96550: LIST
96551: PUSH
96552: LD_INT 2
96554: PUSH
96555: LD_INT 1
96557: NEG
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 2
96565: PUSH
96566: LD_INT 2
96568: NEG
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 4
96576: PUSH
96577: LD_INT 2
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 4
96586: PUSH
96587: LD_INT 4
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 4
96596: PUSH
96597: LD_INT 3
96599: PUSH
96600: EMPTY
96601: LIST
96602: LIST
96603: PUSH
96604: LD_INT 5
96606: PUSH
96607: LD_INT 4
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 5
96616: PUSH
96617: LD_INT 5
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 4
96626: PUSH
96627: LD_INT 5
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 3
96636: PUSH
96637: LD_INT 4
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 3
96646: PUSH
96647: LD_INT 3
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 5
96656: PUSH
96657: LD_INT 3
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: PUSH
96664: LD_INT 3
96666: PUSH
96667: LD_INT 5
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96721: LD_ADDR_VAR 0 33
96725: PUSH
96726: LD_INT 4
96728: NEG
96729: PUSH
96730: LD_INT 4
96732: NEG
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: PUSH
96738: LD_INT 4
96740: NEG
96741: PUSH
96742: LD_INT 5
96744: NEG
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 3
96752: NEG
96753: PUSH
96754: LD_INT 4
96756: NEG
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: PUSH
96762: LD_INT 3
96764: NEG
96765: PUSH
96766: LD_INT 3
96768: NEG
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 4
96776: NEG
96777: PUSH
96778: LD_INT 3
96780: NEG
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 5
96788: NEG
96789: PUSH
96790: LD_INT 4
96792: NEG
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 5
96800: NEG
96801: PUSH
96802: LD_INT 5
96804: NEG
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: PUSH
96810: LD_INT 3
96812: NEG
96813: PUSH
96814: LD_INT 5
96816: NEG
96817: PUSH
96818: EMPTY
96819: LIST
96820: LIST
96821: PUSH
96822: LD_INT 5
96824: NEG
96825: PUSH
96826: LD_INT 3
96828: NEG
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 0
96836: PUSH
96837: LD_INT 3
96839: NEG
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: LD_INT 0
96847: PUSH
96848: LD_INT 4
96850: NEG
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 1
96858: PUSH
96859: LD_INT 3
96861: NEG
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PUSH
96867: LD_INT 1
96869: PUSH
96870: LD_INT 2
96872: NEG
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 0
96880: PUSH
96881: LD_INT 2
96883: NEG
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 1
96891: NEG
96892: PUSH
96893: LD_INT 3
96895: NEG
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 1
96903: NEG
96904: PUSH
96905: LD_INT 4
96907: NEG
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 2
96915: PUSH
96916: LD_INT 2
96918: NEG
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 2
96926: NEG
96927: PUSH
96928: LD_INT 4
96930: NEG
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 4
96938: PUSH
96939: LD_INT 0
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: PUSH
96946: LD_INT 4
96948: PUSH
96949: LD_INT 1
96951: NEG
96952: PUSH
96953: EMPTY
96954: LIST
96955: LIST
96956: PUSH
96957: LD_INT 5
96959: PUSH
96960: LD_INT 0
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 5
96969: PUSH
96970: LD_INT 1
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PUSH
96977: LD_INT 4
96979: PUSH
96980: LD_INT 1
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: PUSH
96987: LD_INT 3
96989: PUSH
96990: LD_INT 0
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 3
96999: PUSH
97000: LD_INT 1
97002: NEG
97003: PUSH
97004: EMPTY
97005: LIST
97006: LIST
97007: PUSH
97008: LD_INT 3
97010: PUSH
97011: LD_INT 2
97013: NEG
97014: PUSH
97015: EMPTY
97016: LIST
97017: LIST
97018: PUSH
97019: LD_INT 5
97021: PUSH
97022: LD_INT 2
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: PUSH
97029: LD_INT 3
97031: PUSH
97032: LD_INT 3
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: PUSH
97039: LD_INT 3
97041: PUSH
97042: LD_INT 2
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: LD_INT 4
97051: PUSH
97052: LD_INT 3
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: LD_INT 4
97061: PUSH
97062: LD_INT 4
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 3
97071: PUSH
97072: LD_INT 4
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 2
97081: PUSH
97082: LD_INT 3
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: LD_INT 2
97091: PUSH
97092: LD_INT 2
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 4
97101: PUSH
97102: LD_INT 2
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PUSH
97109: LD_INT 2
97111: PUSH
97112: LD_INT 4
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 0
97121: PUSH
97122: LD_INT 4
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 0
97131: PUSH
97132: LD_INT 3
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 1
97141: PUSH
97142: LD_INT 4
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: LD_INT 1
97151: PUSH
97152: LD_INT 5
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 0
97161: PUSH
97162: LD_INT 5
97164: PUSH
97165: EMPTY
97166: LIST
97167: LIST
97168: PUSH
97169: LD_INT 1
97171: NEG
97172: PUSH
97173: LD_INT 4
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PUSH
97180: LD_INT 1
97182: NEG
97183: PUSH
97184: LD_INT 3
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: PUSH
97191: LD_INT 2
97193: PUSH
97194: LD_INT 5
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: PUSH
97201: LD_INT 2
97203: NEG
97204: PUSH
97205: LD_INT 3
97207: PUSH
97208: EMPTY
97209: LIST
97210: LIST
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: LIST
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97259: LD_ADDR_VAR 0 34
97263: PUSH
97264: LD_INT 0
97266: PUSH
97267: LD_INT 4
97269: NEG
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 0
97277: PUSH
97278: LD_INT 5
97280: NEG
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 1
97288: PUSH
97289: LD_INT 4
97291: NEG
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 1
97299: PUSH
97300: LD_INT 3
97302: NEG
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_INT 0
97310: PUSH
97311: LD_INT 3
97313: NEG
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 1
97321: NEG
97322: PUSH
97323: LD_INT 4
97325: NEG
97326: PUSH
97327: EMPTY
97328: LIST
97329: LIST
97330: PUSH
97331: LD_INT 1
97333: NEG
97334: PUSH
97335: LD_INT 5
97337: NEG
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PUSH
97343: LD_INT 2
97345: PUSH
97346: LD_INT 3
97348: NEG
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: LD_INT 2
97356: NEG
97357: PUSH
97358: LD_INT 5
97360: NEG
97361: PUSH
97362: EMPTY
97363: LIST
97364: LIST
97365: PUSH
97366: LD_INT 3
97368: PUSH
97369: LD_INT 0
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: LD_INT 3
97378: PUSH
97379: LD_INT 1
97381: NEG
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: LD_INT 4
97389: PUSH
97390: LD_INT 0
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 4
97399: PUSH
97400: LD_INT 1
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 3
97409: PUSH
97410: LD_INT 1
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 2
97419: PUSH
97420: LD_INT 0
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 2
97429: PUSH
97430: LD_INT 1
97432: NEG
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 2
97440: PUSH
97441: LD_INT 2
97443: NEG
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: PUSH
97449: LD_INT 4
97451: PUSH
97452: LD_INT 2
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 4
97461: PUSH
97462: LD_INT 4
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 4
97471: PUSH
97472: LD_INT 3
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: LD_INT 5
97481: PUSH
97482: LD_INT 4
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: LD_INT 5
97491: PUSH
97492: LD_INT 5
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: PUSH
97499: LD_INT 4
97501: PUSH
97502: LD_INT 5
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 3
97511: PUSH
97512: LD_INT 4
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 3
97521: PUSH
97522: LD_INT 3
97524: PUSH
97525: EMPTY
97526: LIST
97527: LIST
97528: PUSH
97529: LD_INT 5
97531: PUSH
97532: LD_INT 3
97534: PUSH
97535: EMPTY
97536: LIST
97537: LIST
97538: PUSH
97539: LD_INT 3
97541: PUSH
97542: LD_INT 5
97544: PUSH
97545: EMPTY
97546: LIST
97547: LIST
97548: PUSH
97549: LD_INT 0
97551: PUSH
97552: LD_INT 3
97554: PUSH
97555: EMPTY
97556: LIST
97557: LIST
97558: PUSH
97559: LD_INT 0
97561: PUSH
97562: LD_INT 2
97564: PUSH
97565: EMPTY
97566: LIST
97567: LIST
97568: PUSH
97569: LD_INT 1
97571: PUSH
97572: LD_INT 3
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: LD_INT 1
97581: PUSH
97582: LD_INT 4
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: LD_INT 0
97591: PUSH
97592: LD_INT 4
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 1
97601: NEG
97602: PUSH
97603: LD_INT 3
97605: PUSH
97606: EMPTY
97607: LIST
97608: LIST
97609: PUSH
97610: LD_INT 1
97612: NEG
97613: PUSH
97614: LD_INT 2
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PUSH
97621: LD_INT 2
97623: PUSH
97624: LD_INT 4
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: PUSH
97631: LD_INT 2
97633: NEG
97634: PUSH
97635: LD_INT 2
97637: PUSH
97638: EMPTY
97639: LIST
97640: LIST
97641: PUSH
97642: LD_INT 4
97644: NEG
97645: PUSH
97646: LD_INT 0
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: LD_INT 4
97655: NEG
97656: PUSH
97657: LD_INT 1
97659: NEG
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PUSH
97665: LD_INT 3
97667: NEG
97668: PUSH
97669: LD_INT 0
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 3
97678: NEG
97679: PUSH
97680: LD_INT 1
97682: PUSH
97683: EMPTY
97684: LIST
97685: LIST
97686: PUSH
97687: LD_INT 4
97689: NEG
97690: PUSH
97691: LD_INT 1
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: PUSH
97698: LD_INT 5
97700: NEG
97701: PUSH
97702: LD_INT 0
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: PUSH
97709: LD_INT 5
97711: NEG
97712: PUSH
97713: LD_INT 1
97715: NEG
97716: PUSH
97717: EMPTY
97718: LIST
97719: LIST
97720: PUSH
97721: LD_INT 5
97723: NEG
97724: PUSH
97725: LD_INT 2
97727: NEG
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: LD_INT 3
97735: NEG
97736: PUSH
97737: LD_INT 2
97739: PUSH
97740: EMPTY
97741: LIST
97742: LIST
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: ST_TO_ADDR
// end ; end ;
97791: GO 97794
97793: POP
// case btype of b_depot , b_warehouse :
97794: LD_VAR 0 1
97798: PUSH
97799: LD_INT 0
97801: DOUBLE
97802: EQUAL
97803: IFTRUE 97813
97805: LD_INT 1
97807: DOUBLE
97808: EQUAL
97809: IFTRUE 97813
97811: GO 98014
97813: POP
// case nation of nation_american :
97814: LD_VAR 0 5
97818: PUSH
97819: LD_INT 1
97821: DOUBLE
97822: EQUAL
97823: IFTRUE 97827
97825: GO 97883
97827: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97828: LD_ADDR_VAR 0 9
97832: PUSH
97833: LD_VAR 0 11
97837: PUSH
97838: LD_VAR 0 12
97842: PUSH
97843: LD_VAR 0 13
97847: PUSH
97848: LD_VAR 0 14
97852: PUSH
97853: LD_VAR 0 15
97857: PUSH
97858: LD_VAR 0 16
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: PUSH
97871: LD_VAR 0 4
97875: PUSH
97876: LD_INT 1
97878: PLUS
97879: ARRAY
97880: ST_TO_ADDR
97881: GO 98012
97883: LD_INT 2
97885: DOUBLE
97886: EQUAL
97887: IFTRUE 97891
97889: GO 97947
97891: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97892: LD_ADDR_VAR 0 9
97896: PUSH
97897: LD_VAR 0 17
97901: PUSH
97902: LD_VAR 0 18
97906: PUSH
97907: LD_VAR 0 19
97911: PUSH
97912: LD_VAR 0 20
97916: PUSH
97917: LD_VAR 0 21
97921: PUSH
97922: LD_VAR 0 22
97926: PUSH
97927: EMPTY
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: PUSH
97935: LD_VAR 0 4
97939: PUSH
97940: LD_INT 1
97942: PLUS
97943: ARRAY
97944: ST_TO_ADDR
97945: GO 98012
97947: LD_INT 3
97949: DOUBLE
97950: EQUAL
97951: IFTRUE 97955
97953: GO 98011
97955: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97956: LD_ADDR_VAR 0 9
97960: PUSH
97961: LD_VAR 0 23
97965: PUSH
97966: LD_VAR 0 24
97970: PUSH
97971: LD_VAR 0 25
97975: PUSH
97976: LD_VAR 0 26
97980: PUSH
97981: LD_VAR 0 27
97985: PUSH
97986: LD_VAR 0 28
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: LIST
97998: PUSH
97999: LD_VAR 0 4
98003: PUSH
98004: LD_INT 1
98006: PLUS
98007: ARRAY
98008: ST_TO_ADDR
98009: GO 98012
98011: POP
98012: GO 98567
98014: LD_INT 2
98016: DOUBLE
98017: EQUAL
98018: IFTRUE 98028
98020: LD_INT 3
98022: DOUBLE
98023: EQUAL
98024: IFTRUE 98028
98026: GO 98084
98028: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98029: LD_ADDR_VAR 0 9
98033: PUSH
98034: LD_VAR 0 29
98038: PUSH
98039: LD_VAR 0 30
98043: PUSH
98044: LD_VAR 0 31
98048: PUSH
98049: LD_VAR 0 32
98053: PUSH
98054: LD_VAR 0 33
98058: PUSH
98059: LD_VAR 0 34
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: PUSH
98072: LD_VAR 0 4
98076: PUSH
98077: LD_INT 1
98079: PLUS
98080: ARRAY
98081: ST_TO_ADDR
98082: GO 98567
98084: LD_INT 16
98086: DOUBLE
98087: EQUAL
98088: IFTRUE 98146
98090: LD_INT 17
98092: DOUBLE
98093: EQUAL
98094: IFTRUE 98146
98096: LD_INT 18
98098: DOUBLE
98099: EQUAL
98100: IFTRUE 98146
98102: LD_INT 19
98104: DOUBLE
98105: EQUAL
98106: IFTRUE 98146
98108: LD_INT 22
98110: DOUBLE
98111: EQUAL
98112: IFTRUE 98146
98114: LD_INT 20
98116: DOUBLE
98117: EQUAL
98118: IFTRUE 98146
98120: LD_INT 21
98122: DOUBLE
98123: EQUAL
98124: IFTRUE 98146
98126: LD_INT 23
98128: DOUBLE
98129: EQUAL
98130: IFTRUE 98146
98132: LD_INT 24
98134: DOUBLE
98135: EQUAL
98136: IFTRUE 98146
98138: LD_INT 25
98140: DOUBLE
98141: EQUAL
98142: IFTRUE 98146
98144: GO 98202
98146: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98147: LD_ADDR_VAR 0 9
98151: PUSH
98152: LD_VAR 0 35
98156: PUSH
98157: LD_VAR 0 36
98161: PUSH
98162: LD_VAR 0 37
98166: PUSH
98167: LD_VAR 0 38
98171: PUSH
98172: LD_VAR 0 39
98176: PUSH
98177: LD_VAR 0 40
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: PUSH
98190: LD_VAR 0 4
98194: PUSH
98195: LD_INT 1
98197: PLUS
98198: ARRAY
98199: ST_TO_ADDR
98200: GO 98567
98202: LD_INT 6
98204: DOUBLE
98205: EQUAL
98206: IFTRUE 98258
98208: LD_INT 7
98210: DOUBLE
98211: EQUAL
98212: IFTRUE 98258
98214: LD_INT 8
98216: DOUBLE
98217: EQUAL
98218: IFTRUE 98258
98220: LD_INT 13
98222: DOUBLE
98223: EQUAL
98224: IFTRUE 98258
98226: LD_INT 12
98228: DOUBLE
98229: EQUAL
98230: IFTRUE 98258
98232: LD_INT 15
98234: DOUBLE
98235: EQUAL
98236: IFTRUE 98258
98238: LD_INT 11
98240: DOUBLE
98241: EQUAL
98242: IFTRUE 98258
98244: LD_INT 14
98246: DOUBLE
98247: EQUAL
98248: IFTRUE 98258
98250: LD_INT 10
98252: DOUBLE
98253: EQUAL
98254: IFTRUE 98258
98256: GO 98314
98258: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
98259: LD_ADDR_VAR 0 9
98263: PUSH
98264: LD_VAR 0 41
98268: PUSH
98269: LD_VAR 0 42
98273: PUSH
98274: LD_VAR 0 43
98278: PUSH
98279: LD_VAR 0 44
98283: PUSH
98284: LD_VAR 0 45
98288: PUSH
98289: LD_VAR 0 46
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: PUSH
98302: LD_VAR 0 4
98306: PUSH
98307: LD_INT 1
98309: PLUS
98310: ARRAY
98311: ST_TO_ADDR
98312: GO 98567
98314: LD_INT 36
98316: DOUBLE
98317: EQUAL
98318: IFTRUE 98322
98320: GO 98378
98322: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98323: LD_ADDR_VAR 0 9
98327: PUSH
98328: LD_VAR 0 47
98332: PUSH
98333: LD_VAR 0 48
98337: PUSH
98338: LD_VAR 0 49
98342: PUSH
98343: LD_VAR 0 50
98347: PUSH
98348: LD_VAR 0 51
98352: PUSH
98353: LD_VAR 0 52
98357: PUSH
98358: EMPTY
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: PUSH
98366: LD_VAR 0 4
98370: PUSH
98371: LD_INT 1
98373: PLUS
98374: ARRAY
98375: ST_TO_ADDR
98376: GO 98567
98378: LD_INT 4
98380: DOUBLE
98381: EQUAL
98382: IFTRUE 98404
98384: LD_INT 5
98386: DOUBLE
98387: EQUAL
98388: IFTRUE 98404
98390: LD_INT 34
98392: DOUBLE
98393: EQUAL
98394: IFTRUE 98404
98396: LD_INT 37
98398: DOUBLE
98399: EQUAL
98400: IFTRUE 98404
98402: GO 98460
98404: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98405: LD_ADDR_VAR 0 9
98409: PUSH
98410: LD_VAR 0 53
98414: PUSH
98415: LD_VAR 0 54
98419: PUSH
98420: LD_VAR 0 55
98424: PUSH
98425: LD_VAR 0 56
98429: PUSH
98430: LD_VAR 0 57
98434: PUSH
98435: LD_VAR 0 58
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: PUSH
98448: LD_VAR 0 4
98452: PUSH
98453: LD_INT 1
98455: PLUS
98456: ARRAY
98457: ST_TO_ADDR
98458: GO 98567
98460: LD_INT 31
98462: DOUBLE
98463: EQUAL
98464: IFTRUE 98510
98466: LD_INT 32
98468: DOUBLE
98469: EQUAL
98470: IFTRUE 98510
98472: LD_INT 33
98474: DOUBLE
98475: EQUAL
98476: IFTRUE 98510
98478: LD_INT 27
98480: DOUBLE
98481: EQUAL
98482: IFTRUE 98510
98484: LD_INT 26
98486: DOUBLE
98487: EQUAL
98488: IFTRUE 98510
98490: LD_INT 28
98492: DOUBLE
98493: EQUAL
98494: IFTRUE 98510
98496: LD_INT 29
98498: DOUBLE
98499: EQUAL
98500: IFTRUE 98510
98502: LD_INT 30
98504: DOUBLE
98505: EQUAL
98506: IFTRUE 98510
98508: GO 98566
98510: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98511: LD_ADDR_VAR 0 9
98515: PUSH
98516: LD_VAR 0 59
98520: PUSH
98521: LD_VAR 0 60
98525: PUSH
98526: LD_VAR 0 61
98530: PUSH
98531: LD_VAR 0 62
98535: PUSH
98536: LD_VAR 0 63
98540: PUSH
98541: LD_VAR 0 64
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: PUSH
98554: LD_VAR 0 4
98558: PUSH
98559: LD_INT 1
98561: PLUS
98562: ARRAY
98563: ST_TO_ADDR
98564: GO 98567
98566: POP
// temp_list2 = [ ] ;
98567: LD_ADDR_VAR 0 10
98571: PUSH
98572: EMPTY
98573: ST_TO_ADDR
// for i in temp_list do
98574: LD_ADDR_VAR 0 8
98578: PUSH
98579: LD_VAR 0 9
98583: PUSH
98584: FOR_IN
98585: IFFALSE 98637
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98587: LD_ADDR_VAR 0 10
98591: PUSH
98592: LD_VAR 0 10
98596: PUSH
98597: LD_VAR 0 8
98601: PUSH
98602: LD_INT 1
98604: ARRAY
98605: PUSH
98606: LD_VAR 0 2
98610: PLUS
98611: PUSH
98612: LD_VAR 0 8
98616: PUSH
98617: LD_INT 2
98619: ARRAY
98620: PUSH
98621: LD_VAR 0 3
98625: PLUS
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: EMPTY
98632: LIST
98633: ADD
98634: ST_TO_ADDR
98635: GO 98584
98637: POP
98638: POP
// result = temp_list2 ;
98639: LD_ADDR_VAR 0 7
98643: PUSH
98644: LD_VAR 0 10
98648: ST_TO_ADDR
// end ;
98649: LD_VAR 0 7
98653: RET
// export function EnemyInRange ( unit , dist ) ; begin
98654: LD_INT 0
98656: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98657: LD_ADDR_VAR 0 3
98661: PUSH
98662: LD_VAR 0 1
98666: PPUSH
98667: CALL_OW 255
98671: PPUSH
98672: LD_VAR 0 1
98676: PPUSH
98677: CALL_OW 250
98681: PPUSH
98682: LD_VAR 0 1
98686: PPUSH
98687: CALL_OW 251
98691: PPUSH
98692: LD_VAR 0 2
98696: PPUSH
98697: CALL 72056 0 4
98701: PUSH
98702: LD_INT 4
98704: ARRAY
98705: ST_TO_ADDR
// end ;
98706: LD_VAR 0 3
98710: RET
// export function PlayerSeeMe ( unit ) ; begin
98711: LD_INT 0
98713: PPUSH
// result := See ( your_side , unit ) ;
98714: LD_ADDR_VAR 0 2
98718: PUSH
98719: LD_OWVAR 2
98723: PPUSH
98724: LD_VAR 0 1
98728: PPUSH
98729: CALL_OW 292
98733: ST_TO_ADDR
// end ;
98734: LD_VAR 0 2
98738: RET
// export function ReverseDir ( unit ) ; begin
98739: LD_INT 0
98741: PPUSH
// if not unit then
98742: LD_VAR 0 1
98746: NOT
98747: IFFALSE 98751
// exit ;
98749: GO 98774
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98751: LD_ADDR_VAR 0 2
98755: PUSH
98756: LD_VAR 0 1
98760: PPUSH
98761: CALL_OW 254
98765: PUSH
98766: LD_INT 3
98768: PLUS
98769: PUSH
98770: LD_INT 6
98772: MOD
98773: ST_TO_ADDR
// end ;
98774: LD_VAR 0 2
98778: RET
// export function ReverseArray ( array ) ; var i ; begin
98779: LD_INT 0
98781: PPUSH
98782: PPUSH
// if not array then
98783: LD_VAR 0 1
98787: NOT
98788: IFFALSE 98792
// exit ;
98790: GO 98847
// result := [ ] ;
98792: LD_ADDR_VAR 0 2
98796: PUSH
98797: EMPTY
98798: ST_TO_ADDR
// for i := array downto 1 do
98799: LD_ADDR_VAR 0 3
98803: PUSH
98804: DOUBLE
98805: LD_VAR 0 1
98809: INC
98810: ST_TO_ADDR
98811: LD_INT 1
98813: PUSH
98814: FOR_DOWNTO
98815: IFFALSE 98845
// result := Join ( result , array [ i ] ) ;
98817: LD_ADDR_VAR 0 2
98821: PUSH
98822: LD_VAR 0 2
98826: PPUSH
98827: LD_VAR 0 1
98831: PUSH
98832: LD_VAR 0 3
98836: ARRAY
98837: PPUSH
98838: CALL 103472 0 2
98842: ST_TO_ADDR
98843: GO 98814
98845: POP
98846: POP
// end ;
98847: LD_VAR 0 2
98851: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
98852: LD_INT 0
98854: PPUSH
98855: PPUSH
98856: PPUSH
98857: PPUSH
98858: PPUSH
98859: PPUSH
// if not unit or not hexes then
98860: LD_VAR 0 1
98864: NOT
98865: PUSH
98866: LD_VAR 0 2
98870: NOT
98871: OR
98872: IFFALSE 98876
// exit ;
98874: GO 98999
// dist := 9999 ;
98876: LD_ADDR_VAR 0 5
98880: PUSH
98881: LD_INT 9999
98883: ST_TO_ADDR
// for i = 1 to hexes do
98884: LD_ADDR_VAR 0 4
98888: PUSH
98889: DOUBLE
98890: LD_INT 1
98892: DEC
98893: ST_TO_ADDR
98894: LD_VAR 0 2
98898: PUSH
98899: FOR_TO
98900: IFFALSE 98987
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98902: LD_ADDR_VAR 0 6
98906: PUSH
98907: LD_VAR 0 1
98911: PPUSH
98912: LD_VAR 0 2
98916: PUSH
98917: LD_VAR 0 4
98921: ARRAY
98922: PUSH
98923: LD_INT 1
98925: ARRAY
98926: PPUSH
98927: LD_VAR 0 2
98931: PUSH
98932: LD_VAR 0 4
98936: ARRAY
98937: PUSH
98938: LD_INT 2
98940: ARRAY
98941: PPUSH
98942: CALL_OW 297
98946: ST_TO_ADDR
// if tdist < dist then
98947: LD_VAR 0 6
98951: PUSH
98952: LD_VAR 0 5
98956: LESS
98957: IFFALSE 98985
// begin hex := hexes [ i ] ;
98959: LD_ADDR_VAR 0 8
98963: PUSH
98964: LD_VAR 0 2
98968: PUSH
98969: LD_VAR 0 4
98973: ARRAY
98974: ST_TO_ADDR
// dist := tdist ;
98975: LD_ADDR_VAR 0 5
98979: PUSH
98980: LD_VAR 0 6
98984: ST_TO_ADDR
// end ; end ;
98985: GO 98899
98987: POP
98988: POP
// result := hex ;
98989: LD_ADDR_VAR 0 3
98993: PUSH
98994: LD_VAR 0 8
98998: ST_TO_ADDR
// end ;
98999: LD_VAR 0 3
99003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99004: LD_INT 0
99006: PPUSH
99007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99008: LD_VAR 0 1
99012: NOT
99013: PUSH
99014: LD_VAR 0 1
99018: PUSH
99019: LD_INT 21
99021: PUSH
99022: LD_INT 2
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: PUSH
99029: LD_INT 23
99031: PUSH
99032: LD_INT 2
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PPUSH
99043: CALL_OW 69
99047: IN
99048: NOT
99049: OR
99050: IFFALSE 99054
// exit ;
99052: GO 99101
// for i = 1 to 3 do
99054: LD_ADDR_VAR 0 3
99058: PUSH
99059: DOUBLE
99060: LD_INT 1
99062: DEC
99063: ST_TO_ADDR
99064: LD_INT 3
99066: PUSH
99067: FOR_TO
99068: IFFALSE 99099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99070: LD_VAR 0 1
99074: PPUSH
99075: CALL_OW 250
99079: PPUSH
99080: LD_VAR 0 1
99084: PPUSH
99085: CALL_OW 251
99089: PPUSH
99090: LD_INT 1
99092: PPUSH
99093: CALL_OW 453
99097: GO 99067
99099: POP
99100: POP
// end ;
99101: LD_VAR 0 2
99105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99106: LD_INT 0
99108: PPUSH
99109: PPUSH
99110: PPUSH
99111: PPUSH
99112: PPUSH
99113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99114: LD_VAR 0 1
99118: NOT
99119: PUSH
99120: LD_VAR 0 2
99124: NOT
99125: OR
99126: PUSH
99127: LD_VAR 0 1
99131: PPUSH
99132: CALL_OW 314
99136: OR
99137: IFFALSE 99141
// exit ;
99139: GO 99582
// x := GetX ( enemy_unit ) ;
99141: LD_ADDR_VAR 0 7
99145: PUSH
99146: LD_VAR 0 2
99150: PPUSH
99151: CALL_OW 250
99155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99156: LD_ADDR_VAR 0 8
99160: PUSH
99161: LD_VAR 0 2
99165: PPUSH
99166: CALL_OW 251
99170: ST_TO_ADDR
// if not x or not y then
99171: LD_VAR 0 7
99175: NOT
99176: PUSH
99177: LD_VAR 0 8
99181: NOT
99182: OR
99183: IFFALSE 99187
// exit ;
99185: GO 99582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99187: LD_ADDR_VAR 0 6
99191: PUSH
99192: LD_VAR 0 7
99196: PPUSH
99197: LD_INT 0
99199: PPUSH
99200: LD_INT 4
99202: PPUSH
99203: CALL_OW 272
99207: PUSH
99208: LD_VAR 0 8
99212: PPUSH
99213: LD_INT 0
99215: PPUSH
99216: LD_INT 4
99218: PPUSH
99219: CALL_OW 273
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: PUSH
99228: LD_VAR 0 7
99232: PPUSH
99233: LD_INT 1
99235: PPUSH
99236: LD_INT 4
99238: PPUSH
99239: CALL_OW 272
99243: PUSH
99244: LD_VAR 0 8
99248: PPUSH
99249: LD_INT 1
99251: PPUSH
99252: LD_INT 4
99254: PPUSH
99255: CALL_OW 273
99259: PUSH
99260: EMPTY
99261: LIST
99262: LIST
99263: PUSH
99264: LD_VAR 0 7
99268: PPUSH
99269: LD_INT 2
99271: PPUSH
99272: LD_INT 4
99274: PPUSH
99275: CALL_OW 272
99279: PUSH
99280: LD_VAR 0 8
99284: PPUSH
99285: LD_INT 2
99287: PPUSH
99288: LD_INT 4
99290: PPUSH
99291: CALL_OW 273
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: PUSH
99300: LD_VAR 0 7
99304: PPUSH
99305: LD_INT 3
99307: PPUSH
99308: LD_INT 4
99310: PPUSH
99311: CALL_OW 272
99315: PUSH
99316: LD_VAR 0 8
99320: PPUSH
99321: LD_INT 3
99323: PPUSH
99324: LD_INT 4
99326: PPUSH
99327: CALL_OW 273
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PUSH
99336: LD_VAR 0 7
99340: PPUSH
99341: LD_INT 4
99343: PPUSH
99344: LD_INT 4
99346: PPUSH
99347: CALL_OW 272
99351: PUSH
99352: LD_VAR 0 8
99356: PPUSH
99357: LD_INT 4
99359: PPUSH
99360: LD_INT 4
99362: PPUSH
99363: CALL_OW 273
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PUSH
99372: LD_VAR 0 7
99376: PPUSH
99377: LD_INT 5
99379: PPUSH
99380: LD_INT 4
99382: PPUSH
99383: CALL_OW 272
99387: PUSH
99388: LD_VAR 0 8
99392: PPUSH
99393: LD_INT 5
99395: PPUSH
99396: LD_INT 4
99398: PPUSH
99399: CALL_OW 273
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PUSH
99408: EMPTY
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: ST_TO_ADDR
// for i = tmp downto 1 do
99416: LD_ADDR_VAR 0 4
99420: PUSH
99421: DOUBLE
99422: LD_VAR 0 6
99426: INC
99427: ST_TO_ADDR
99428: LD_INT 1
99430: PUSH
99431: FOR_DOWNTO
99432: IFFALSE 99533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99434: LD_VAR 0 6
99438: PUSH
99439: LD_VAR 0 4
99443: ARRAY
99444: PUSH
99445: LD_INT 1
99447: ARRAY
99448: PPUSH
99449: LD_VAR 0 6
99453: PUSH
99454: LD_VAR 0 4
99458: ARRAY
99459: PUSH
99460: LD_INT 2
99462: ARRAY
99463: PPUSH
99464: CALL_OW 488
99468: NOT
99469: PUSH
99470: LD_VAR 0 6
99474: PUSH
99475: LD_VAR 0 4
99479: ARRAY
99480: PUSH
99481: LD_INT 1
99483: ARRAY
99484: PPUSH
99485: LD_VAR 0 6
99489: PUSH
99490: LD_VAR 0 4
99494: ARRAY
99495: PUSH
99496: LD_INT 2
99498: ARRAY
99499: PPUSH
99500: CALL_OW 428
99504: PUSH
99505: LD_INT 0
99507: NONEQUAL
99508: OR
99509: IFFALSE 99531
// tmp := Delete ( tmp , i ) ;
99511: LD_ADDR_VAR 0 6
99515: PUSH
99516: LD_VAR 0 6
99520: PPUSH
99521: LD_VAR 0 4
99525: PPUSH
99526: CALL_OW 3
99530: ST_TO_ADDR
99531: GO 99431
99533: POP
99534: POP
// j := GetClosestHex ( unit , tmp ) ;
99535: LD_ADDR_VAR 0 5
99539: PUSH
99540: LD_VAR 0 1
99544: PPUSH
99545: LD_VAR 0 6
99549: PPUSH
99550: CALL 98852 0 2
99554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99555: LD_VAR 0 1
99559: PPUSH
99560: LD_VAR 0 5
99564: PUSH
99565: LD_INT 1
99567: ARRAY
99568: PPUSH
99569: LD_VAR 0 5
99573: PUSH
99574: LD_INT 2
99576: ARRAY
99577: PPUSH
99578: CALL_OW 111
// end ;
99582: LD_VAR 0 3
99586: RET
// export function PrepareApemanSoldier ( ) ; begin
99587: LD_INT 0
99589: PPUSH
// uc_nation := 0 ;
99590: LD_ADDR_OWVAR 21
99594: PUSH
99595: LD_INT 0
99597: ST_TO_ADDR
// hc_sex := sex_male ;
99598: LD_ADDR_OWVAR 27
99602: PUSH
99603: LD_INT 1
99605: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
99606: LD_ADDR_OWVAR 28
99610: PUSH
99611: LD_INT 15
99613: ST_TO_ADDR
// hc_gallery :=  ;
99614: LD_ADDR_OWVAR 33
99618: PUSH
99619: LD_STRING 
99621: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99622: LD_ADDR_OWVAR 31
99626: PUSH
99627: LD_INT 0
99629: PPUSH
99630: LD_INT 3
99632: PPUSH
99633: CALL_OW 12
99637: PUSH
99638: LD_INT 0
99640: PPUSH
99641: LD_INT 3
99643: PPUSH
99644: CALL_OW 12
99648: PUSH
99649: LD_INT 0
99651: PUSH
99652: LD_INT 0
99654: PUSH
99655: EMPTY
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: ST_TO_ADDR
// end ;
99661: LD_VAR 0 1
99665: RET
// export function PrepareApemanEngineer ( ) ; begin
99666: LD_INT 0
99668: PPUSH
// uc_nation := 0 ;
99669: LD_ADDR_OWVAR 21
99673: PUSH
99674: LD_INT 0
99676: ST_TO_ADDR
// hc_sex := sex_male ;
99677: LD_ADDR_OWVAR 27
99681: PUSH
99682: LD_INT 1
99684: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
99685: LD_ADDR_OWVAR 28
99689: PUSH
99690: LD_INT 16
99692: ST_TO_ADDR
// hc_gallery :=  ;
99693: LD_ADDR_OWVAR 33
99697: PUSH
99698: LD_STRING 
99700: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99701: LD_ADDR_OWVAR 31
99705: PUSH
99706: LD_INT 0
99708: PPUSH
99709: LD_INT 3
99711: PPUSH
99712: CALL_OW 12
99716: PUSH
99717: LD_INT 0
99719: PPUSH
99720: LD_INT 3
99722: PPUSH
99723: CALL_OW 12
99727: PUSH
99728: LD_INT 0
99730: PUSH
99731: LD_INT 0
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: ST_TO_ADDR
// end ;
99740: LD_VAR 0 1
99744: RET
// export function PrepareApeman ( agressivity ) ; begin
99745: LD_INT 0
99747: PPUSH
// uc_side := 0 ;
99748: LD_ADDR_OWVAR 20
99752: PUSH
99753: LD_INT 0
99755: ST_TO_ADDR
// uc_nation := 0 ;
99756: LD_ADDR_OWVAR 21
99760: PUSH
99761: LD_INT 0
99763: ST_TO_ADDR
// hc_sex := sex_male ;
99764: LD_ADDR_OWVAR 27
99768: PUSH
99769: LD_INT 1
99771: ST_TO_ADDR
// hc_class := class_apeman ;
99772: LD_ADDR_OWVAR 28
99776: PUSH
99777: LD_INT 12
99779: ST_TO_ADDR
// hc_gallery :=  ;
99780: LD_ADDR_OWVAR 33
99784: PUSH
99785: LD_STRING 
99787: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99788: LD_ADDR_OWVAR 35
99792: PUSH
99793: LD_VAR 0 1
99797: NEG
99798: PPUSH
99799: LD_VAR 0 1
99803: PPUSH
99804: CALL_OW 12
99808: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99809: LD_ADDR_OWVAR 31
99813: PUSH
99814: LD_INT 0
99816: PPUSH
99817: LD_INT 3
99819: PPUSH
99820: CALL_OW 12
99824: PUSH
99825: LD_INT 0
99827: PPUSH
99828: LD_INT 3
99830: PPUSH
99831: CALL_OW 12
99835: PUSH
99836: LD_INT 0
99838: PUSH
99839: LD_INT 0
99841: PUSH
99842: EMPTY
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: ST_TO_ADDR
// end ;
99848: LD_VAR 0 2
99852: RET
// export function PrepareTiger ( agressivity ) ; begin
99853: LD_INT 0
99855: PPUSH
// uc_side := 0 ;
99856: LD_ADDR_OWVAR 20
99860: PUSH
99861: LD_INT 0
99863: ST_TO_ADDR
// uc_nation := 0 ;
99864: LD_ADDR_OWVAR 21
99868: PUSH
99869: LD_INT 0
99871: ST_TO_ADDR
// hc_class := class_tiger ;
99872: LD_ADDR_OWVAR 28
99876: PUSH
99877: LD_INT 14
99879: ST_TO_ADDR
// hc_gallery :=  ;
99880: LD_ADDR_OWVAR 33
99884: PUSH
99885: LD_STRING 
99887: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99888: LD_ADDR_OWVAR 35
99892: PUSH
99893: LD_VAR 0 1
99897: NEG
99898: PPUSH
99899: LD_VAR 0 1
99903: PPUSH
99904: CALL_OW 12
99908: ST_TO_ADDR
// end ;
99909: LD_VAR 0 2
99913: RET
// export function PrepareEnchidna ( ) ; begin
99914: LD_INT 0
99916: PPUSH
// uc_side := 0 ;
99917: LD_ADDR_OWVAR 20
99921: PUSH
99922: LD_INT 0
99924: ST_TO_ADDR
// uc_nation := 0 ;
99925: LD_ADDR_OWVAR 21
99929: PUSH
99930: LD_INT 0
99932: ST_TO_ADDR
// hc_class := class_baggie ;
99933: LD_ADDR_OWVAR 28
99937: PUSH
99938: LD_INT 13
99940: ST_TO_ADDR
// hc_gallery :=  ;
99941: LD_ADDR_OWVAR 33
99945: PUSH
99946: LD_STRING 
99948: ST_TO_ADDR
// end ;
99949: LD_VAR 0 1
99953: RET
// export function PrepareFrog ( ) ; begin
99954: LD_INT 0
99956: PPUSH
// uc_side := 0 ;
99957: LD_ADDR_OWVAR 20
99961: PUSH
99962: LD_INT 0
99964: ST_TO_ADDR
// uc_nation := 0 ;
99965: LD_ADDR_OWVAR 21
99969: PUSH
99970: LD_INT 0
99972: ST_TO_ADDR
// hc_class := class_frog ;
99973: LD_ADDR_OWVAR 28
99977: PUSH
99978: LD_INT 19
99980: ST_TO_ADDR
// hc_gallery :=  ;
99981: LD_ADDR_OWVAR 33
99985: PUSH
99986: LD_STRING 
99988: ST_TO_ADDR
// end ;
99989: LD_VAR 0 1
99993: RET
// export function PrepareFish ( ) ; begin
99994: LD_INT 0
99996: PPUSH
// uc_side := 0 ;
99997: LD_ADDR_OWVAR 20
100001: PUSH
100002: LD_INT 0
100004: ST_TO_ADDR
// uc_nation := 0 ;
100005: LD_ADDR_OWVAR 21
100009: PUSH
100010: LD_INT 0
100012: ST_TO_ADDR
// hc_class := class_fish ;
100013: LD_ADDR_OWVAR 28
100017: PUSH
100018: LD_INT 20
100020: ST_TO_ADDR
// hc_gallery :=  ;
100021: LD_ADDR_OWVAR 33
100025: PUSH
100026: LD_STRING 
100028: ST_TO_ADDR
// end ;
100029: LD_VAR 0 1
100033: RET
// export function PrepareBird ( ) ; begin
100034: LD_INT 0
100036: PPUSH
// uc_side := 0 ;
100037: LD_ADDR_OWVAR 20
100041: PUSH
100042: LD_INT 0
100044: ST_TO_ADDR
// uc_nation := 0 ;
100045: LD_ADDR_OWVAR 21
100049: PUSH
100050: LD_INT 0
100052: ST_TO_ADDR
// hc_class := class_phororhacos ;
100053: LD_ADDR_OWVAR 28
100057: PUSH
100058: LD_INT 18
100060: ST_TO_ADDR
// hc_gallery :=  ;
100061: LD_ADDR_OWVAR 33
100065: PUSH
100066: LD_STRING 
100068: ST_TO_ADDR
// end ;
100069: LD_VAR 0 1
100073: RET
// export function PrepareHorse ( ) ; begin
100074: LD_INT 0
100076: PPUSH
// uc_side := 0 ;
100077: LD_ADDR_OWVAR 20
100081: PUSH
100082: LD_INT 0
100084: ST_TO_ADDR
// uc_nation := 0 ;
100085: LD_ADDR_OWVAR 21
100089: PUSH
100090: LD_INT 0
100092: ST_TO_ADDR
// hc_class := class_horse ;
100093: LD_ADDR_OWVAR 28
100097: PUSH
100098: LD_INT 21
100100: ST_TO_ADDR
// hc_gallery :=  ;
100101: LD_ADDR_OWVAR 33
100105: PUSH
100106: LD_STRING 
100108: ST_TO_ADDR
// end ;
100109: LD_VAR 0 1
100113: RET
// export function PrepareMastodont ( ) ; begin
100114: LD_INT 0
100116: PPUSH
// uc_side := 0 ;
100117: LD_ADDR_OWVAR 20
100121: PUSH
100122: LD_INT 0
100124: ST_TO_ADDR
// uc_nation := 0 ;
100125: LD_ADDR_OWVAR 21
100129: PUSH
100130: LD_INT 0
100132: ST_TO_ADDR
// vc_chassis := class_mastodont ;
100133: LD_ADDR_OWVAR 37
100137: PUSH
100138: LD_INT 31
100140: ST_TO_ADDR
// vc_control := control_rider ;
100141: LD_ADDR_OWVAR 38
100145: PUSH
100146: LD_INT 4
100148: ST_TO_ADDR
// end ;
100149: LD_VAR 0 1
100153: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
100154: LD_INT 0
100156: PPUSH
100157: PPUSH
100158: PPUSH
// uc_side = 0 ;
100159: LD_ADDR_OWVAR 20
100163: PUSH
100164: LD_INT 0
100166: ST_TO_ADDR
// uc_nation = 0 ;
100167: LD_ADDR_OWVAR 21
100171: PUSH
100172: LD_INT 0
100174: ST_TO_ADDR
// InitHc_All ( ) ;
100175: CALL_OW 584
// InitVc ;
100179: CALL_OW 20
// if mastodonts then
100183: LD_VAR 0 6
100187: IFFALSE 100254
// for i = 1 to mastodonts do
100189: LD_ADDR_VAR 0 11
100193: PUSH
100194: DOUBLE
100195: LD_INT 1
100197: DEC
100198: ST_TO_ADDR
100199: LD_VAR 0 6
100203: PUSH
100204: FOR_TO
100205: IFFALSE 100252
// begin vc_chassis := 31 ;
100207: LD_ADDR_OWVAR 37
100211: PUSH
100212: LD_INT 31
100214: ST_TO_ADDR
// vc_control := control_rider ;
100215: LD_ADDR_OWVAR 38
100219: PUSH
100220: LD_INT 4
100222: ST_TO_ADDR
// animal := CreateVehicle ;
100223: LD_ADDR_VAR 0 12
100227: PUSH
100228: CALL_OW 45
100232: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100233: LD_VAR 0 12
100237: PPUSH
100238: LD_VAR 0 8
100242: PPUSH
100243: LD_INT 0
100245: PPUSH
100246: CALL 102389 0 3
// end ;
100250: GO 100204
100252: POP
100253: POP
// if horses then
100254: LD_VAR 0 5
100258: IFFALSE 100325
// for i = 1 to horses do
100260: LD_ADDR_VAR 0 11
100264: PUSH
100265: DOUBLE
100266: LD_INT 1
100268: DEC
100269: ST_TO_ADDR
100270: LD_VAR 0 5
100274: PUSH
100275: FOR_TO
100276: IFFALSE 100323
// begin hc_class := 21 ;
100278: LD_ADDR_OWVAR 28
100282: PUSH
100283: LD_INT 21
100285: ST_TO_ADDR
// hc_gallery :=  ;
100286: LD_ADDR_OWVAR 33
100290: PUSH
100291: LD_STRING 
100293: ST_TO_ADDR
// animal := CreateHuman ;
100294: LD_ADDR_VAR 0 12
100298: PUSH
100299: CALL_OW 44
100303: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100304: LD_VAR 0 12
100308: PPUSH
100309: LD_VAR 0 8
100313: PPUSH
100314: LD_INT 0
100316: PPUSH
100317: CALL 102389 0 3
// end ;
100321: GO 100275
100323: POP
100324: POP
// if birds then
100325: LD_VAR 0 1
100329: IFFALSE 100396
// for i = 1 to birds do
100331: LD_ADDR_VAR 0 11
100335: PUSH
100336: DOUBLE
100337: LD_INT 1
100339: DEC
100340: ST_TO_ADDR
100341: LD_VAR 0 1
100345: PUSH
100346: FOR_TO
100347: IFFALSE 100394
// begin hc_class = 18 ;
100349: LD_ADDR_OWVAR 28
100353: PUSH
100354: LD_INT 18
100356: ST_TO_ADDR
// hc_gallery =  ;
100357: LD_ADDR_OWVAR 33
100361: PUSH
100362: LD_STRING 
100364: ST_TO_ADDR
// animal := CreateHuman ;
100365: LD_ADDR_VAR 0 12
100369: PUSH
100370: CALL_OW 44
100374: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100375: LD_VAR 0 12
100379: PPUSH
100380: LD_VAR 0 8
100384: PPUSH
100385: LD_INT 0
100387: PPUSH
100388: CALL 102389 0 3
// end ;
100392: GO 100346
100394: POP
100395: POP
// if tigers then
100396: LD_VAR 0 2
100400: IFFALSE 100484
// for i = 1 to tigers do
100402: LD_ADDR_VAR 0 11
100406: PUSH
100407: DOUBLE
100408: LD_INT 1
100410: DEC
100411: ST_TO_ADDR
100412: LD_VAR 0 2
100416: PUSH
100417: FOR_TO
100418: IFFALSE 100482
// begin hc_class = class_tiger ;
100420: LD_ADDR_OWVAR 28
100424: PUSH
100425: LD_INT 14
100427: ST_TO_ADDR
// hc_gallery =  ;
100428: LD_ADDR_OWVAR 33
100432: PUSH
100433: LD_STRING 
100435: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100436: LD_ADDR_OWVAR 35
100440: PUSH
100441: LD_INT 7
100443: NEG
100444: PPUSH
100445: LD_INT 7
100447: PPUSH
100448: CALL_OW 12
100452: ST_TO_ADDR
// animal := CreateHuman ;
100453: LD_ADDR_VAR 0 12
100457: PUSH
100458: CALL_OW 44
100462: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100463: LD_VAR 0 12
100467: PPUSH
100468: LD_VAR 0 8
100472: PPUSH
100473: LD_INT 0
100475: PPUSH
100476: CALL 102389 0 3
// end ;
100480: GO 100417
100482: POP
100483: POP
// if apemans then
100484: LD_VAR 0 3
100488: IFFALSE 100611
// for i = 1 to apemans do
100490: LD_ADDR_VAR 0 11
100494: PUSH
100495: DOUBLE
100496: LD_INT 1
100498: DEC
100499: ST_TO_ADDR
100500: LD_VAR 0 3
100504: PUSH
100505: FOR_TO
100506: IFFALSE 100609
// begin hc_class = class_apeman ;
100508: LD_ADDR_OWVAR 28
100512: PUSH
100513: LD_INT 12
100515: ST_TO_ADDR
// hc_gallery =  ;
100516: LD_ADDR_OWVAR 33
100520: PUSH
100521: LD_STRING 
100523: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
100524: LD_ADDR_OWVAR 35
100528: PUSH
100529: LD_INT 2
100531: NEG
100532: PPUSH
100533: LD_INT 2
100535: PPUSH
100536: CALL_OW 12
100540: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100541: LD_ADDR_OWVAR 31
100545: PUSH
100546: LD_INT 1
100548: PPUSH
100549: LD_INT 3
100551: PPUSH
100552: CALL_OW 12
100556: PUSH
100557: LD_INT 1
100559: PPUSH
100560: LD_INT 3
100562: PPUSH
100563: CALL_OW 12
100567: PUSH
100568: LD_INT 0
100570: PUSH
100571: LD_INT 0
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: LIST
100578: LIST
100579: ST_TO_ADDR
// animal := CreateHuman ;
100580: LD_ADDR_VAR 0 12
100584: PUSH
100585: CALL_OW 44
100589: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100590: LD_VAR 0 12
100594: PPUSH
100595: LD_VAR 0 8
100599: PPUSH
100600: LD_INT 0
100602: PPUSH
100603: CALL 102389 0 3
// end ;
100607: GO 100505
100609: POP
100610: POP
// if enchidnas then
100611: LD_VAR 0 4
100615: IFFALSE 100682
// for i = 1 to enchidnas do
100617: LD_ADDR_VAR 0 11
100621: PUSH
100622: DOUBLE
100623: LD_INT 1
100625: DEC
100626: ST_TO_ADDR
100627: LD_VAR 0 4
100631: PUSH
100632: FOR_TO
100633: IFFALSE 100680
// begin hc_class = 13 ;
100635: LD_ADDR_OWVAR 28
100639: PUSH
100640: LD_INT 13
100642: ST_TO_ADDR
// hc_gallery =  ;
100643: LD_ADDR_OWVAR 33
100647: PUSH
100648: LD_STRING 
100650: ST_TO_ADDR
// animal := CreateHuman ;
100651: LD_ADDR_VAR 0 12
100655: PUSH
100656: CALL_OW 44
100660: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100661: LD_VAR 0 12
100665: PPUSH
100666: LD_VAR 0 8
100670: PPUSH
100671: LD_INT 0
100673: PPUSH
100674: CALL 102389 0 3
// end ;
100678: GO 100632
100680: POP
100681: POP
// if fishes then
100682: LD_VAR 0 7
100686: IFFALSE 100753
// for i = 1 to fishes do
100688: LD_ADDR_VAR 0 11
100692: PUSH
100693: DOUBLE
100694: LD_INT 1
100696: DEC
100697: ST_TO_ADDR
100698: LD_VAR 0 7
100702: PUSH
100703: FOR_TO
100704: IFFALSE 100751
// begin hc_class = 20 ;
100706: LD_ADDR_OWVAR 28
100710: PUSH
100711: LD_INT 20
100713: ST_TO_ADDR
// hc_gallery =  ;
100714: LD_ADDR_OWVAR 33
100718: PUSH
100719: LD_STRING 
100721: ST_TO_ADDR
// animal := CreateHuman ;
100722: LD_ADDR_VAR 0 12
100726: PUSH
100727: CALL_OW 44
100731: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100732: LD_VAR 0 12
100736: PPUSH
100737: LD_VAR 0 9
100741: PPUSH
100742: LD_INT 0
100744: PPUSH
100745: CALL 102389 0 3
// end ;
100749: GO 100703
100751: POP
100752: POP
// end ;
100753: LD_VAR 0 10
100757: RET
// export function WantHeal ( sci , unit ) ; begin
100758: LD_INT 0
100760: PPUSH
// if GetTaskList ( sci ) > 0 then
100761: LD_VAR 0 1
100765: PPUSH
100766: CALL_OW 437
100770: PUSH
100771: LD_INT 0
100773: GREATER
100774: IFFALSE 100844
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100776: LD_VAR 0 1
100780: PPUSH
100781: CALL_OW 437
100785: PUSH
100786: LD_INT 1
100788: ARRAY
100789: PUSH
100790: LD_INT 1
100792: ARRAY
100793: PUSH
100794: LD_STRING l
100796: EQUAL
100797: PUSH
100798: LD_VAR 0 1
100802: PPUSH
100803: CALL_OW 437
100807: PUSH
100808: LD_INT 1
100810: ARRAY
100811: PUSH
100812: LD_INT 4
100814: ARRAY
100815: PUSH
100816: LD_VAR 0 2
100820: EQUAL
100821: AND
100822: IFFALSE 100834
// result := true else
100824: LD_ADDR_VAR 0 3
100828: PUSH
100829: LD_INT 1
100831: ST_TO_ADDR
100832: GO 100842
// result := false ;
100834: LD_ADDR_VAR 0 3
100838: PUSH
100839: LD_INT 0
100841: ST_TO_ADDR
// end else
100842: GO 100852
// result := false ;
100844: LD_ADDR_VAR 0 3
100848: PUSH
100849: LD_INT 0
100851: ST_TO_ADDR
// end ;
100852: LD_VAR 0 3
100856: RET
// export function HealTarget ( sci ) ; begin
100857: LD_INT 0
100859: PPUSH
// if not sci then
100860: LD_VAR 0 1
100864: NOT
100865: IFFALSE 100869
// exit ;
100867: GO 100934
// result := 0 ;
100869: LD_ADDR_VAR 0 2
100873: PUSH
100874: LD_INT 0
100876: ST_TO_ADDR
// if GetTaskList ( sci ) then
100877: LD_VAR 0 1
100881: PPUSH
100882: CALL_OW 437
100886: IFFALSE 100934
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100888: LD_VAR 0 1
100892: PPUSH
100893: CALL_OW 437
100897: PUSH
100898: LD_INT 1
100900: ARRAY
100901: PUSH
100902: LD_INT 1
100904: ARRAY
100905: PUSH
100906: LD_STRING l
100908: EQUAL
100909: IFFALSE 100934
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100911: LD_ADDR_VAR 0 2
100915: PUSH
100916: LD_VAR 0 1
100920: PPUSH
100921: CALL_OW 437
100925: PUSH
100926: LD_INT 1
100928: ARRAY
100929: PUSH
100930: LD_INT 4
100932: ARRAY
100933: ST_TO_ADDR
// end ;
100934: LD_VAR 0 2
100938: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100939: LD_INT 0
100941: PPUSH
100942: PPUSH
100943: PPUSH
100944: PPUSH
// if not base_units then
100945: LD_VAR 0 1
100949: NOT
100950: IFFALSE 100954
// exit ;
100952: GO 101041
// result := false ;
100954: LD_ADDR_VAR 0 2
100958: PUSH
100959: LD_INT 0
100961: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100962: LD_ADDR_VAR 0 5
100966: PUSH
100967: LD_VAR 0 1
100971: PPUSH
100972: LD_INT 21
100974: PUSH
100975: LD_INT 3
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PPUSH
100982: CALL_OW 72
100986: ST_TO_ADDR
// if not tmp then
100987: LD_VAR 0 5
100991: NOT
100992: IFFALSE 100996
// exit ;
100994: GO 101041
// for i in tmp do
100996: LD_ADDR_VAR 0 3
101000: PUSH
101001: LD_VAR 0 5
101005: PUSH
101006: FOR_IN
101007: IFFALSE 101039
// begin result := EnemyInRange ( i , 22 ) ;
101009: LD_ADDR_VAR 0 2
101013: PUSH
101014: LD_VAR 0 3
101018: PPUSH
101019: LD_INT 22
101021: PPUSH
101022: CALL 98654 0 2
101026: ST_TO_ADDR
// if result then
101027: LD_VAR 0 2
101031: IFFALSE 101037
// exit ;
101033: POP
101034: POP
101035: GO 101041
// end ;
101037: GO 101006
101039: POP
101040: POP
// end ;
101041: LD_VAR 0 2
101045: RET
// export function FilterByTag ( units , tag ) ; begin
101046: LD_INT 0
101048: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
101049: LD_ADDR_VAR 0 3
101053: PUSH
101054: LD_VAR 0 1
101058: PPUSH
101059: LD_INT 120
101061: PUSH
101062: LD_VAR 0 2
101066: PUSH
101067: EMPTY
101068: LIST
101069: LIST
101070: PPUSH
101071: CALL_OW 72
101075: ST_TO_ADDR
// end ;
101076: LD_VAR 0 3
101080: RET
// export function IsDriver ( un ) ; begin
101081: LD_INT 0
101083: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
101084: LD_ADDR_VAR 0 2
101088: PUSH
101089: LD_VAR 0 1
101093: PUSH
101094: LD_INT 55
101096: PUSH
101097: EMPTY
101098: LIST
101099: PPUSH
101100: CALL_OW 69
101104: IN
101105: ST_TO_ADDR
// end ;
101106: LD_VAR 0 2
101110: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
101111: LD_INT 0
101113: PPUSH
101114: PPUSH
// list := [ ] ;
101115: LD_ADDR_VAR 0 5
101119: PUSH
101120: EMPTY
101121: ST_TO_ADDR
// case d of 0 :
101122: LD_VAR 0 3
101126: PUSH
101127: LD_INT 0
101129: DOUBLE
101130: EQUAL
101131: IFTRUE 101135
101133: GO 101268
101135: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
101136: LD_ADDR_VAR 0 5
101140: PUSH
101141: LD_VAR 0 1
101145: PUSH
101146: LD_INT 4
101148: MINUS
101149: PUSH
101150: LD_VAR 0 2
101154: PUSH
101155: LD_INT 4
101157: MINUS
101158: PUSH
101159: LD_INT 2
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: LIST
101166: PUSH
101167: LD_VAR 0 1
101171: PUSH
101172: LD_INT 3
101174: MINUS
101175: PUSH
101176: LD_VAR 0 2
101180: PUSH
101181: LD_INT 1
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: LIST
101188: PUSH
101189: LD_VAR 0 1
101193: PUSH
101194: LD_INT 4
101196: PLUS
101197: PUSH
101198: LD_VAR 0 2
101202: PUSH
101203: LD_INT 4
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: LIST
101210: PUSH
101211: LD_VAR 0 1
101215: PUSH
101216: LD_INT 3
101218: PLUS
101219: PUSH
101220: LD_VAR 0 2
101224: PUSH
101225: LD_INT 3
101227: PLUS
101228: PUSH
101229: LD_INT 5
101231: PUSH
101232: EMPTY
101233: LIST
101234: LIST
101235: LIST
101236: PUSH
101237: LD_VAR 0 1
101241: PUSH
101242: LD_VAR 0 2
101246: PUSH
101247: LD_INT 4
101249: PLUS
101250: PUSH
101251: LD_INT 0
101253: PUSH
101254: EMPTY
101255: LIST
101256: LIST
101257: LIST
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: LIST
101263: LIST
101264: LIST
101265: ST_TO_ADDR
// end ; 1 :
101266: GO 101966
101268: LD_INT 1
101270: DOUBLE
101271: EQUAL
101272: IFTRUE 101276
101274: GO 101409
101276: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
101277: LD_ADDR_VAR 0 5
101281: PUSH
101282: LD_VAR 0 1
101286: PUSH
101287: LD_VAR 0 2
101291: PUSH
101292: LD_INT 4
101294: MINUS
101295: PUSH
101296: LD_INT 3
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: LIST
101303: PUSH
101304: LD_VAR 0 1
101308: PUSH
101309: LD_INT 3
101311: MINUS
101312: PUSH
101313: LD_VAR 0 2
101317: PUSH
101318: LD_INT 3
101320: MINUS
101321: PUSH
101322: LD_INT 2
101324: PUSH
101325: EMPTY
101326: LIST
101327: LIST
101328: LIST
101329: PUSH
101330: LD_VAR 0 1
101334: PUSH
101335: LD_INT 4
101337: MINUS
101338: PUSH
101339: LD_VAR 0 2
101343: PUSH
101344: LD_INT 1
101346: PUSH
101347: EMPTY
101348: LIST
101349: LIST
101350: LIST
101351: PUSH
101352: LD_VAR 0 1
101356: PUSH
101357: LD_VAR 0 2
101361: PUSH
101362: LD_INT 3
101364: PLUS
101365: PUSH
101366: LD_INT 0
101368: PUSH
101369: EMPTY
101370: LIST
101371: LIST
101372: LIST
101373: PUSH
101374: LD_VAR 0 1
101378: PUSH
101379: LD_INT 4
101381: PLUS
101382: PUSH
101383: LD_VAR 0 2
101387: PUSH
101388: LD_INT 4
101390: PLUS
101391: PUSH
101392: LD_INT 5
101394: PUSH
101395: EMPTY
101396: LIST
101397: LIST
101398: LIST
101399: PUSH
101400: EMPTY
101401: LIST
101402: LIST
101403: LIST
101404: LIST
101405: LIST
101406: ST_TO_ADDR
// end ; 2 :
101407: GO 101966
101409: LD_INT 2
101411: DOUBLE
101412: EQUAL
101413: IFTRUE 101417
101415: GO 101546
101417: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
101418: LD_ADDR_VAR 0 5
101422: PUSH
101423: LD_VAR 0 1
101427: PUSH
101428: LD_VAR 0 2
101432: PUSH
101433: LD_INT 3
101435: MINUS
101436: PUSH
101437: LD_INT 3
101439: PUSH
101440: EMPTY
101441: LIST
101442: LIST
101443: LIST
101444: PUSH
101445: LD_VAR 0 1
101449: PUSH
101450: LD_INT 4
101452: PLUS
101453: PUSH
101454: LD_VAR 0 2
101458: PUSH
101459: LD_INT 4
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: LIST
101466: PUSH
101467: LD_VAR 0 1
101471: PUSH
101472: LD_VAR 0 2
101476: PUSH
101477: LD_INT 4
101479: PLUS
101480: PUSH
101481: LD_INT 0
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: LIST
101488: PUSH
101489: LD_VAR 0 1
101493: PUSH
101494: LD_INT 3
101496: MINUS
101497: PUSH
101498: LD_VAR 0 2
101502: PUSH
101503: LD_INT 1
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: LIST
101510: PUSH
101511: LD_VAR 0 1
101515: PUSH
101516: LD_INT 4
101518: MINUS
101519: PUSH
101520: LD_VAR 0 2
101524: PUSH
101525: LD_INT 4
101527: MINUS
101528: PUSH
101529: LD_INT 2
101531: PUSH
101532: EMPTY
101533: LIST
101534: LIST
101535: LIST
101536: PUSH
101537: EMPTY
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: ST_TO_ADDR
// end ; 3 :
101544: GO 101966
101546: LD_INT 3
101548: DOUBLE
101549: EQUAL
101550: IFTRUE 101554
101552: GO 101687
101554: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
101555: LD_ADDR_VAR 0 5
101559: PUSH
101560: LD_VAR 0 1
101564: PUSH
101565: LD_INT 3
101567: PLUS
101568: PUSH
101569: LD_VAR 0 2
101573: PUSH
101574: LD_INT 4
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: LIST
101581: PUSH
101582: LD_VAR 0 1
101586: PUSH
101587: LD_INT 4
101589: PLUS
101590: PUSH
101591: LD_VAR 0 2
101595: PUSH
101596: LD_INT 4
101598: PLUS
101599: PUSH
101600: LD_INT 5
101602: PUSH
101603: EMPTY
101604: LIST
101605: LIST
101606: LIST
101607: PUSH
101608: LD_VAR 0 1
101612: PUSH
101613: LD_INT 4
101615: MINUS
101616: PUSH
101617: LD_VAR 0 2
101621: PUSH
101622: LD_INT 1
101624: PUSH
101625: EMPTY
101626: LIST
101627: LIST
101628: LIST
101629: PUSH
101630: LD_VAR 0 1
101634: PUSH
101635: LD_VAR 0 2
101639: PUSH
101640: LD_INT 4
101642: MINUS
101643: PUSH
101644: LD_INT 3
101646: PUSH
101647: EMPTY
101648: LIST
101649: LIST
101650: LIST
101651: PUSH
101652: LD_VAR 0 1
101656: PUSH
101657: LD_INT 3
101659: MINUS
101660: PUSH
101661: LD_VAR 0 2
101665: PUSH
101666: LD_INT 3
101668: MINUS
101669: PUSH
101670: LD_INT 2
101672: PUSH
101673: EMPTY
101674: LIST
101675: LIST
101676: LIST
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: LIST
101682: LIST
101683: LIST
101684: ST_TO_ADDR
// end ; 4 :
101685: GO 101966
101687: LD_INT 4
101689: DOUBLE
101690: EQUAL
101691: IFTRUE 101695
101693: GO 101828
101695: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
101696: LD_ADDR_VAR 0 5
101700: PUSH
101701: LD_VAR 0 1
101705: PUSH
101706: LD_VAR 0 2
101710: PUSH
101711: LD_INT 4
101713: PLUS
101714: PUSH
101715: LD_INT 0
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: LIST
101722: PUSH
101723: LD_VAR 0 1
101727: PUSH
101728: LD_INT 3
101730: PLUS
101731: PUSH
101732: LD_VAR 0 2
101736: PUSH
101737: LD_INT 3
101739: PLUS
101740: PUSH
101741: LD_INT 5
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: LIST
101748: PUSH
101749: LD_VAR 0 1
101753: PUSH
101754: LD_INT 4
101756: PLUS
101757: PUSH
101758: LD_VAR 0 2
101762: PUSH
101763: LD_INT 4
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: LIST
101770: PUSH
101771: LD_VAR 0 1
101775: PUSH
101776: LD_VAR 0 2
101780: PUSH
101781: LD_INT 3
101783: MINUS
101784: PUSH
101785: LD_INT 3
101787: PUSH
101788: EMPTY
101789: LIST
101790: LIST
101791: LIST
101792: PUSH
101793: LD_VAR 0 1
101797: PUSH
101798: LD_INT 4
101800: MINUS
101801: PUSH
101802: LD_VAR 0 2
101806: PUSH
101807: LD_INT 4
101809: MINUS
101810: PUSH
101811: LD_INT 2
101813: PUSH
101814: EMPTY
101815: LIST
101816: LIST
101817: LIST
101818: PUSH
101819: EMPTY
101820: LIST
101821: LIST
101822: LIST
101823: LIST
101824: LIST
101825: ST_TO_ADDR
// end ; 5 :
101826: GO 101966
101828: LD_INT 5
101830: DOUBLE
101831: EQUAL
101832: IFTRUE 101836
101834: GO 101965
101836: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
101837: LD_ADDR_VAR 0 5
101841: PUSH
101842: LD_VAR 0 1
101846: PUSH
101847: LD_INT 4
101849: MINUS
101850: PUSH
101851: LD_VAR 0 2
101855: PUSH
101856: LD_INT 1
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: LIST
101863: PUSH
101864: LD_VAR 0 1
101868: PUSH
101869: LD_VAR 0 2
101873: PUSH
101874: LD_INT 4
101876: MINUS
101877: PUSH
101878: LD_INT 3
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: LIST
101885: PUSH
101886: LD_VAR 0 1
101890: PUSH
101891: LD_INT 4
101893: PLUS
101894: PUSH
101895: LD_VAR 0 2
101899: PUSH
101900: LD_INT 4
101902: PLUS
101903: PUSH
101904: LD_INT 5
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: LIST
101911: PUSH
101912: LD_VAR 0 1
101916: PUSH
101917: LD_INT 3
101919: PLUS
101920: PUSH
101921: LD_VAR 0 2
101925: PUSH
101926: LD_INT 4
101928: PUSH
101929: EMPTY
101930: LIST
101931: LIST
101932: LIST
101933: PUSH
101934: LD_VAR 0 1
101938: PUSH
101939: LD_VAR 0 2
101943: PUSH
101944: LD_INT 3
101946: PLUS
101947: PUSH
101948: LD_INT 0
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: LIST
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: LIST
101960: LIST
101961: LIST
101962: ST_TO_ADDR
// end ; end ;
101963: GO 101966
101965: POP
// result := list ;
101966: LD_ADDR_VAR 0 4
101970: PUSH
101971: LD_VAR 0 5
101975: ST_TO_ADDR
// end ;
101976: LD_VAR 0 4
101980: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101981: LD_INT 0
101983: PPUSH
101984: PPUSH
101985: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101986: LD_VAR 0 1
101990: NOT
101991: PUSH
101992: LD_VAR 0 2
101996: PUSH
101997: LD_INT 1
101999: PUSH
102000: LD_INT 2
102002: PUSH
102003: LD_INT 3
102005: PUSH
102006: LD_INT 4
102008: PUSH
102009: EMPTY
102010: LIST
102011: LIST
102012: LIST
102013: LIST
102014: IN
102015: NOT
102016: OR
102017: IFFALSE 102021
// exit ;
102019: GO 102113
// tmp := [ ] ;
102021: LD_ADDR_VAR 0 5
102025: PUSH
102026: EMPTY
102027: ST_TO_ADDR
// for i in units do
102028: LD_ADDR_VAR 0 4
102032: PUSH
102033: LD_VAR 0 1
102037: PUSH
102038: FOR_IN
102039: IFFALSE 102082
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
102041: LD_ADDR_VAR 0 5
102045: PUSH
102046: LD_VAR 0 5
102050: PPUSH
102051: LD_VAR 0 5
102055: PUSH
102056: LD_INT 1
102058: PLUS
102059: PPUSH
102060: LD_VAR 0 4
102064: PPUSH
102065: LD_VAR 0 2
102069: PPUSH
102070: CALL_OW 259
102074: PPUSH
102075: CALL_OW 2
102079: ST_TO_ADDR
102080: GO 102038
102082: POP
102083: POP
// if not tmp then
102084: LD_VAR 0 5
102088: NOT
102089: IFFALSE 102093
// exit ;
102091: GO 102113
// result := SortListByListDesc ( units , tmp ) ;
102093: LD_ADDR_VAR 0 3
102097: PUSH
102098: LD_VAR 0 1
102102: PPUSH
102103: LD_VAR 0 5
102107: PPUSH
102108: CALL_OW 77
102112: ST_TO_ADDR
// end ;
102113: LD_VAR 0 3
102117: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
102118: LD_INT 0
102120: PPUSH
102121: PPUSH
102122: PPUSH
// result := false ;
102123: LD_ADDR_VAR 0 3
102127: PUSH
102128: LD_INT 0
102130: ST_TO_ADDR
// x := GetX ( building ) ;
102131: LD_ADDR_VAR 0 4
102135: PUSH
102136: LD_VAR 0 2
102140: PPUSH
102141: CALL_OW 250
102145: ST_TO_ADDR
// y := GetY ( building ) ;
102146: LD_ADDR_VAR 0 5
102150: PUSH
102151: LD_VAR 0 2
102155: PPUSH
102156: CALL_OW 251
102160: ST_TO_ADDR
// if not building or not x or not y then
102161: LD_VAR 0 2
102165: NOT
102166: PUSH
102167: LD_VAR 0 4
102171: NOT
102172: OR
102173: PUSH
102174: LD_VAR 0 5
102178: NOT
102179: OR
102180: IFFALSE 102184
// exit ;
102182: GO 102276
// if GetTaskList ( unit ) then
102184: LD_VAR 0 1
102188: PPUSH
102189: CALL_OW 437
102193: IFFALSE 102276
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102195: LD_STRING e
102197: PUSH
102198: LD_VAR 0 1
102202: PPUSH
102203: CALL_OW 437
102207: PUSH
102208: LD_INT 1
102210: ARRAY
102211: PUSH
102212: LD_INT 1
102214: ARRAY
102215: EQUAL
102216: PUSH
102217: LD_VAR 0 4
102221: PUSH
102222: LD_VAR 0 1
102226: PPUSH
102227: CALL_OW 437
102231: PUSH
102232: LD_INT 1
102234: ARRAY
102235: PUSH
102236: LD_INT 2
102238: ARRAY
102239: EQUAL
102240: AND
102241: PUSH
102242: LD_VAR 0 5
102246: PUSH
102247: LD_VAR 0 1
102251: PPUSH
102252: CALL_OW 437
102256: PUSH
102257: LD_INT 1
102259: ARRAY
102260: PUSH
102261: LD_INT 3
102263: ARRAY
102264: EQUAL
102265: AND
102266: IFFALSE 102276
// result := true end ;
102268: LD_ADDR_VAR 0 3
102272: PUSH
102273: LD_INT 1
102275: ST_TO_ADDR
// end ;
102276: LD_VAR 0 3
102280: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
102281: LD_INT 0
102283: PPUSH
// result := false ;
102284: LD_ADDR_VAR 0 4
102288: PUSH
102289: LD_INT 0
102291: ST_TO_ADDR
// if GetTaskList ( unit ) then
102292: LD_VAR 0 1
102296: PPUSH
102297: CALL_OW 437
102301: IFFALSE 102384
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102303: LD_STRING M
102305: PUSH
102306: LD_VAR 0 1
102310: PPUSH
102311: CALL_OW 437
102315: PUSH
102316: LD_INT 1
102318: ARRAY
102319: PUSH
102320: LD_INT 1
102322: ARRAY
102323: EQUAL
102324: PUSH
102325: LD_VAR 0 2
102329: PUSH
102330: LD_VAR 0 1
102334: PPUSH
102335: CALL_OW 437
102339: PUSH
102340: LD_INT 1
102342: ARRAY
102343: PUSH
102344: LD_INT 2
102346: ARRAY
102347: EQUAL
102348: AND
102349: PUSH
102350: LD_VAR 0 3
102354: PUSH
102355: LD_VAR 0 1
102359: PPUSH
102360: CALL_OW 437
102364: PUSH
102365: LD_INT 1
102367: ARRAY
102368: PUSH
102369: LD_INT 3
102371: ARRAY
102372: EQUAL
102373: AND
102374: IFFALSE 102384
// result := true ;
102376: LD_ADDR_VAR 0 4
102380: PUSH
102381: LD_INT 1
102383: ST_TO_ADDR
// end ; end ;
102384: LD_VAR 0 4
102388: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102389: LD_INT 0
102391: PPUSH
102392: PPUSH
102393: PPUSH
102394: PPUSH
// if not unit or not area then
102395: LD_VAR 0 1
102399: NOT
102400: PUSH
102401: LD_VAR 0 2
102405: NOT
102406: OR
102407: IFFALSE 102411
// exit ;
102409: GO 102575
// tmp := AreaToList ( area , i ) ;
102411: LD_ADDR_VAR 0 6
102415: PUSH
102416: LD_VAR 0 2
102420: PPUSH
102421: LD_VAR 0 5
102425: PPUSH
102426: CALL_OW 517
102430: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102431: LD_ADDR_VAR 0 5
102435: PUSH
102436: DOUBLE
102437: LD_INT 1
102439: DEC
102440: ST_TO_ADDR
102441: LD_VAR 0 6
102445: PUSH
102446: LD_INT 1
102448: ARRAY
102449: PUSH
102450: FOR_TO
102451: IFFALSE 102573
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102453: LD_ADDR_VAR 0 7
102457: PUSH
102458: LD_VAR 0 6
102462: PUSH
102463: LD_INT 1
102465: ARRAY
102466: PUSH
102467: LD_VAR 0 5
102471: ARRAY
102472: PUSH
102473: LD_VAR 0 6
102477: PUSH
102478: LD_INT 2
102480: ARRAY
102481: PUSH
102482: LD_VAR 0 5
102486: ARRAY
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102492: LD_VAR 0 7
102496: PUSH
102497: LD_INT 1
102499: ARRAY
102500: PPUSH
102501: LD_VAR 0 7
102505: PUSH
102506: LD_INT 2
102508: ARRAY
102509: PPUSH
102510: CALL_OW 428
102514: PUSH
102515: LD_INT 0
102517: EQUAL
102518: IFFALSE 102571
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
102520: LD_VAR 0 1
102524: PPUSH
102525: LD_VAR 0 7
102529: PUSH
102530: LD_INT 1
102532: ARRAY
102533: PPUSH
102534: LD_VAR 0 7
102538: PUSH
102539: LD_INT 2
102541: ARRAY
102542: PPUSH
102543: LD_VAR 0 3
102547: PPUSH
102548: CALL_OW 48
// result := IsPlaced ( unit ) ;
102552: LD_ADDR_VAR 0 4
102556: PUSH
102557: LD_VAR 0 1
102561: PPUSH
102562: CALL_OW 305
102566: ST_TO_ADDR
// exit ;
102567: POP
102568: POP
102569: GO 102575
// end ; end ;
102571: GO 102450
102573: POP
102574: POP
// end ;
102575: LD_VAR 0 4
102579: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
102580: LD_INT 0
102582: PPUSH
102583: PPUSH
102584: PPUSH
// if not side or side > 8 then
102585: LD_VAR 0 1
102589: NOT
102590: PUSH
102591: LD_VAR 0 1
102595: PUSH
102596: LD_INT 8
102598: GREATER
102599: OR
102600: IFFALSE 102604
// exit ;
102602: GO 102791
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
102604: LD_ADDR_VAR 0 4
102608: PUSH
102609: LD_INT 22
102611: PUSH
102612: LD_VAR 0 1
102616: PUSH
102617: EMPTY
102618: LIST
102619: LIST
102620: PUSH
102621: LD_INT 21
102623: PUSH
102624: LD_INT 3
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: PPUSH
102635: CALL_OW 69
102639: ST_TO_ADDR
// if not tmp then
102640: LD_VAR 0 4
102644: NOT
102645: IFFALSE 102649
// exit ;
102647: GO 102791
// enable_addtolog := true ;
102649: LD_ADDR_OWVAR 81
102653: PUSH
102654: LD_INT 1
102656: ST_TO_ADDR
// AddToLog ( [ ) ;
102657: LD_STRING [
102659: PPUSH
102660: CALL_OW 561
// for i in tmp do
102664: LD_ADDR_VAR 0 3
102668: PUSH
102669: LD_VAR 0 4
102673: PUSH
102674: FOR_IN
102675: IFFALSE 102782
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
102677: LD_STRING [
102679: PUSH
102680: LD_VAR 0 3
102684: PPUSH
102685: CALL_OW 266
102689: STR
102690: PUSH
102691: LD_STRING , 
102693: STR
102694: PUSH
102695: LD_VAR 0 3
102699: PPUSH
102700: CALL_OW 250
102704: STR
102705: PUSH
102706: LD_STRING , 
102708: STR
102709: PUSH
102710: LD_VAR 0 3
102714: PPUSH
102715: CALL_OW 251
102719: STR
102720: PUSH
102721: LD_STRING , 
102723: STR
102724: PUSH
102725: LD_VAR 0 3
102729: PPUSH
102730: CALL_OW 254
102734: STR
102735: PUSH
102736: LD_STRING , 
102738: STR
102739: PUSH
102740: LD_VAR 0 3
102744: PPUSH
102745: LD_INT 1
102747: PPUSH
102748: CALL_OW 268
102752: STR
102753: PUSH
102754: LD_STRING , 
102756: STR
102757: PUSH
102758: LD_VAR 0 3
102762: PPUSH
102763: LD_INT 2
102765: PPUSH
102766: CALL_OW 268
102770: STR
102771: PUSH
102772: LD_STRING ],
102774: STR
102775: PPUSH
102776: CALL_OW 561
// end ;
102780: GO 102674
102782: POP
102783: POP
// AddToLog ( ]; ) ;
102784: LD_STRING ];
102786: PPUSH
102787: CALL_OW 561
// end ;
102791: LD_VAR 0 2
102795: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
102796: LD_INT 0
102798: PPUSH
102799: PPUSH
102800: PPUSH
102801: PPUSH
102802: PPUSH
// if not area or not rate or not max then
102803: LD_VAR 0 1
102807: NOT
102808: PUSH
102809: LD_VAR 0 2
102813: NOT
102814: OR
102815: PUSH
102816: LD_VAR 0 4
102820: NOT
102821: OR
102822: IFFALSE 102826
// exit ;
102824: GO 103015
// while 1 do
102826: LD_INT 1
102828: IFFALSE 103015
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
102830: LD_ADDR_VAR 0 9
102834: PUSH
102835: LD_VAR 0 1
102839: PPUSH
102840: LD_INT 1
102842: PPUSH
102843: CALL_OW 287
102847: PUSH
102848: LD_INT 10
102850: MUL
102851: ST_TO_ADDR
// r := rate / 10 ;
102852: LD_ADDR_VAR 0 7
102856: PUSH
102857: LD_VAR 0 2
102861: PUSH
102862: LD_INT 10
102864: DIVREAL
102865: ST_TO_ADDR
// time := 1 1$00 ;
102866: LD_ADDR_VAR 0 8
102870: PUSH
102871: LD_INT 2100
102873: ST_TO_ADDR
// if amount < min then
102874: LD_VAR 0 9
102878: PUSH
102879: LD_VAR 0 3
102883: LESS
102884: IFFALSE 102902
// r := r * 2 else
102886: LD_ADDR_VAR 0 7
102890: PUSH
102891: LD_VAR 0 7
102895: PUSH
102896: LD_INT 2
102898: MUL
102899: ST_TO_ADDR
102900: GO 102928
// if amount > max then
102902: LD_VAR 0 9
102906: PUSH
102907: LD_VAR 0 4
102911: GREATER
102912: IFFALSE 102928
// r := r / 2 ;
102914: LD_ADDR_VAR 0 7
102918: PUSH
102919: LD_VAR 0 7
102923: PUSH
102924: LD_INT 2
102926: DIVREAL
102927: ST_TO_ADDR
// time := time / r ;
102928: LD_ADDR_VAR 0 8
102932: PUSH
102933: LD_VAR 0 8
102937: PUSH
102938: LD_VAR 0 7
102942: DIVREAL
102943: ST_TO_ADDR
// if time < 0 then
102944: LD_VAR 0 8
102948: PUSH
102949: LD_INT 0
102951: LESS
102952: IFFALSE 102969
// time := time * - 1 ;
102954: LD_ADDR_VAR 0 8
102958: PUSH
102959: LD_VAR 0 8
102963: PUSH
102964: LD_INT 1
102966: NEG
102967: MUL
102968: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
102969: LD_VAR 0 8
102973: PUSH
102974: LD_INT 35
102976: PPUSH
102977: LD_INT 875
102979: PPUSH
102980: CALL_OW 12
102984: PLUS
102985: PPUSH
102986: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102990: LD_INT 1
102992: PPUSH
102993: LD_INT 5
102995: PPUSH
102996: CALL_OW 12
103000: PPUSH
103001: LD_VAR 0 1
103005: PPUSH
103006: LD_INT 1
103008: PPUSH
103009: CALL_OW 55
// end ;
103013: GO 102826
// end ;
103015: LD_VAR 0 5
103019: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
103020: LD_INT 0
103022: PPUSH
103023: PPUSH
103024: PPUSH
103025: PPUSH
103026: PPUSH
103027: PPUSH
103028: PPUSH
103029: PPUSH
// if not turrets or not factories then
103030: LD_VAR 0 1
103034: NOT
103035: PUSH
103036: LD_VAR 0 2
103040: NOT
103041: OR
103042: IFFALSE 103046
// exit ;
103044: GO 103353
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
103046: LD_ADDR_VAR 0 10
103050: PUSH
103051: LD_INT 5
103053: PUSH
103054: LD_INT 6
103056: PUSH
103057: EMPTY
103058: LIST
103059: LIST
103060: PUSH
103061: LD_INT 2
103063: PUSH
103064: LD_INT 4
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PUSH
103071: LD_INT 3
103073: PUSH
103074: LD_INT 5
103076: PUSH
103077: EMPTY
103078: LIST
103079: LIST
103080: PUSH
103081: EMPTY
103082: LIST
103083: LIST
103084: LIST
103085: PUSH
103086: LD_INT 24
103088: PUSH
103089: LD_INT 25
103091: PUSH
103092: EMPTY
103093: LIST
103094: LIST
103095: PUSH
103096: LD_INT 23
103098: PUSH
103099: LD_INT 27
103101: PUSH
103102: EMPTY
103103: LIST
103104: LIST
103105: PUSH
103106: EMPTY
103107: LIST
103108: LIST
103109: PUSH
103110: LD_INT 42
103112: PUSH
103113: LD_INT 43
103115: PUSH
103116: EMPTY
103117: LIST
103118: LIST
103119: PUSH
103120: LD_INT 44
103122: PUSH
103123: LD_INT 46
103125: PUSH
103126: EMPTY
103127: LIST
103128: LIST
103129: PUSH
103130: LD_INT 45
103132: PUSH
103133: LD_INT 47
103135: PUSH
103136: EMPTY
103137: LIST
103138: LIST
103139: PUSH
103140: EMPTY
103141: LIST
103142: LIST
103143: LIST
103144: PUSH
103145: EMPTY
103146: LIST
103147: LIST
103148: LIST
103149: ST_TO_ADDR
// result := [ ] ;
103150: LD_ADDR_VAR 0 3
103154: PUSH
103155: EMPTY
103156: ST_TO_ADDR
// for i in turrets do
103157: LD_ADDR_VAR 0 4
103161: PUSH
103162: LD_VAR 0 1
103166: PUSH
103167: FOR_IN
103168: IFFALSE 103351
// begin nat := GetNation ( i ) ;
103170: LD_ADDR_VAR 0 7
103174: PUSH
103175: LD_VAR 0 4
103179: PPUSH
103180: CALL_OW 248
103184: ST_TO_ADDR
// weapon := 0 ;
103185: LD_ADDR_VAR 0 8
103189: PUSH
103190: LD_INT 0
103192: ST_TO_ADDR
// if not nat then
103193: LD_VAR 0 7
103197: NOT
103198: IFFALSE 103202
// continue ;
103200: GO 103167
// for j in list [ nat ] do
103202: LD_ADDR_VAR 0 5
103206: PUSH
103207: LD_VAR 0 10
103211: PUSH
103212: LD_VAR 0 7
103216: ARRAY
103217: PUSH
103218: FOR_IN
103219: IFFALSE 103260
// if GetBWeapon ( i ) = j [ 1 ] then
103221: LD_VAR 0 4
103225: PPUSH
103226: CALL_OW 269
103230: PUSH
103231: LD_VAR 0 5
103235: PUSH
103236: LD_INT 1
103238: ARRAY
103239: EQUAL
103240: IFFALSE 103258
// begin weapon := j [ 2 ] ;
103242: LD_ADDR_VAR 0 8
103246: PUSH
103247: LD_VAR 0 5
103251: PUSH
103252: LD_INT 2
103254: ARRAY
103255: ST_TO_ADDR
// break ;
103256: GO 103260
// end ;
103258: GO 103218
103260: POP
103261: POP
// if not weapon then
103262: LD_VAR 0 8
103266: NOT
103267: IFFALSE 103271
// continue ;
103269: GO 103167
// for k in factories do
103271: LD_ADDR_VAR 0 6
103275: PUSH
103276: LD_VAR 0 2
103280: PUSH
103281: FOR_IN
103282: IFFALSE 103347
// begin weapons := AvailableWeaponList ( k ) ;
103284: LD_ADDR_VAR 0 9
103288: PUSH
103289: LD_VAR 0 6
103293: PPUSH
103294: CALL_OW 478
103298: ST_TO_ADDR
// if not weapons then
103299: LD_VAR 0 9
103303: NOT
103304: IFFALSE 103308
// continue ;
103306: GO 103281
// if weapon in weapons then
103308: LD_VAR 0 8
103312: PUSH
103313: LD_VAR 0 9
103317: IN
103318: IFFALSE 103345
// begin result := [ i , weapon ] ;
103320: LD_ADDR_VAR 0 3
103324: PUSH
103325: LD_VAR 0 4
103329: PUSH
103330: LD_VAR 0 8
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: ST_TO_ADDR
// exit ;
103339: POP
103340: POP
103341: POP
103342: POP
103343: GO 103353
// end ; end ;
103345: GO 103281
103347: POP
103348: POP
// end ;
103349: GO 103167
103351: POP
103352: POP
// end ;
103353: LD_VAR 0 3
103357: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
103358: LD_INT 0
103360: PPUSH
// if not side or side > 8 then
103361: LD_VAR 0 3
103365: NOT
103366: PUSH
103367: LD_VAR 0 3
103371: PUSH
103372: LD_INT 8
103374: GREATER
103375: OR
103376: IFFALSE 103380
// exit ;
103378: GO 103439
// if not range then
103380: LD_VAR 0 4
103384: NOT
103385: IFFALSE 103396
// range := - 12 ;
103387: LD_ADDR_VAR 0 4
103391: PUSH
103392: LD_INT 12
103394: NEG
103395: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103396: LD_VAR 0 1
103400: PPUSH
103401: LD_VAR 0 2
103405: PPUSH
103406: LD_VAR 0 3
103410: PPUSH
103411: LD_VAR 0 4
103415: PPUSH
103416: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103420: LD_VAR 0 1
103424: PPUSH
103425: LD_VAR 0 2
103429: PPUSH
103430: LD_VAR 0 3
103434: PPUSH
103435: CALL_OW 331
// end ;
103439: LD_VAR 0 5
103443: RET
// export function Video ( mode ) ; begin
103444: LD_INT 0
103446: PPUSH
// ingame_video = mode ;
103447: LD_ADDR_OWVAR 52
103451: PUSH
103452: LD_VAR 0 1
103456: ST_TO_ADDR
// interface_hidden = mode ;
103457: LD_ADDR_OWVAR 54
103461: PUSH
103462: LD_VAR 0 1
103466: ST_TO_ADDR
// end ;
103467: LD_VAR 0 2
103471: RET
// export function Join ( array , element ) ; begin
103472: LD_INT 0
103474: PPUSH
// result := Replace ( array , array + 1 , element ) ;
103475: LD_ADDR_VAR 0 3
103479: PUSH
103480: LD_VAR 0 1
103484: PPUSH
103485: LD_VAR 0 1
103489: PUSH
103490: LD_INT 1
103492: PLUS
103493: PPUSH
103494: LD_VAR 0 2
103498: PPUSH
103499: CALL_OW 1
103503: ST_TO_ADDR
// end ;
103504: LD_VAR 0 3
103508: RET
// export function JoinUnion ( array , element ) ; begin
103509: LD_INT 0
103511: PPUSH
// result := array union element ;
103512: LD_ADDR_VAR 0 3
103516: PUSH
103517: LD_VAR 0 1
103521: PUSH
103522: LD_VAR 0 2
103526: UNION
103527: ST_TO_ADDR
// end ;
103528: LD_VAR 0 3
103532: RET
// export function GetBehemoths ( side ) ; begin
103533: LD_INT 0
103535: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
103536: LD_ADDR_VAR 0 2
103540: PUSH
103541: LD_INT 22
103543: PUSH
103544: LD_VAR 0 1
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: PUSH
103553: LD_INT 31
103555: PUSH
103556: LD_INT 25
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: PPUSH
103567: CALL_OW 69
103571: ST_TO_ADDR
// end ;
103572: LD_VAR 0 2
103576: RET
// export function Shuffle ( array ) ; var i , index ; begin
103577: LD_INT 0
103579: PPUSH
103580: PPUSH
103581: PPUSH
// result := [ ] ;
103582: LD_ADDR_VAR 0 2
103586: PUSH
103587: EMPTY
103588: ST_TO_ADDR
// if not array then
103589: LD_VAR 0 1
103593: NOT
103594: IFFALSE 103598
// exit ;
103596: GO 103697
// Randomize ;
103598: CALL_OW 10
// for i = array downto 1 do
103602: LD_ADDR_VAR 0 3
103606: PUSH
103607: DOUBLE
103608: LD_VAR 0 1
103612: INC
103613: ST_TO_ADDR
103614: LD_INT 1
103616: PUSH
103617: FOR_DOWNTO
103618: IFFALSE 103695
// begin index := rand ( 1 , array ) ;
103620: LD_ADDR_VAR 0 4
103624: PUSH
103625: LD_INT 1
103627: PPUSH
103628: LD_VAR 0 1
103632: PPUSH
103633: CALL_OW 12
103637: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
103638: LD_ADDR_VAR 0 2
103642: PUSH
103643: LD_VAR 0 2
103647: PPUSH
103648: LD_VAR 0 2
103652: PUSH
103653: LD_INT 1
103655: PLUS
103656: PPUSH
103657: LD_VAR 0 1
103661: PUSH
103662: LD_VAR 0 4
103666: ARRAY
103667: PPUSH
103668: CALL_OW 2
103672: ST_TO_ADDR
// array := Delete ( array , index ) ;
103673: LD_ADDR_VAR 0 1
103677: PUSH
103678: LD_VAR 0 1
103682: PPUSH
103683: LD_VAR 0 4
103687: PPUSH
103688: CALL_OW 3
103692: ST_TO_ADDR
// end ;
103693: GO 103617
103695: POP
103696: POP
// end ;
103697: LD_VAR 0 2
103701: RET
// export function GetBaseMaterials ( base ) ; begin
103702: LD_INT 0
103704: PPUSH
// result := [ 0 , 0 , 0 ] ;
103705: LD_ADDR_VAR 0 2
103709: PUSH
103710: LD_INT 0
103712: PUSH
103713: LD_INT 0
103715: PUSH
103716: LD_INT 0
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: LIST
103723: ST_TO_ADDR
// if not base then
103724: LD_VAR 0 1
103728: NOT
103729: IFFALSE 103733
// exit ;
103731: GO 103782
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
103733: LD_ADDR_VAR 0 2
103737: PUSH
103738: LD_VAR 0 1
103742: PPUSH
103743: LD_INT 1
103745: PPUSH
103746: CALL_OW 275
103750: PUSH
103751: LD_VAR 0 1
103755: PPUSH
103756: LD_INT 2
103758: PPUSH
103759: CALL_OW 275
103763: PUSH
103764: LD_VAR 0 1
103768: PPUSH
103769: LD_INT 3
103771: PPUSH
103772: CALL_OW 275
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: LIST
103781: ST_TO_ADDR
// end ;
103782: LD_VAR 0 2
103786: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
103787: LD_INT 0
103789: PPUSH
103790: PPUSH
// result := array ;
103791: LD_ADDR_VAR 0 3
103795: PUSH
103796: LD_VAR 0 1
103800: ST_TO_ADDR
// if size >= result then
103801: LD_VAR 0 2
103805: PUSH
103806: LD_VAR 0 3
103810: GREATEREQUAL
103811: IFFALSE 103815
// exit ;
103813: GO 103865
// if size then
103815: LD_VAR 0 2
103819: IFFALSE 103865
// for i := array downto size do
103821: LD_ADDR_VAR 0 4
103825: PUSH
103826: DOUBLE
103827: LD_VAR 0 1
103831: INC
103832: ST_TO_ADDR
103833: LD_VAR 0 2
103837: PUSH
103838: FOR_DOWNTO
103839: IFFALSE 103863
// result := Delete ( result , result ) ;
103841: LD_ADDR_VAR 0 3
103845: PUSH
103846: LD_VAR 0 3
103850: PPUSH
103851: LD_VAR 0 3
103855: PPUSH
103856: CALL_OW 3
103860: ST_TO_ADDR
103861: GO 103838
103863: POP
103864: POP
// end ;
103865: LD_VAR 0 3
103869: RET
// export function ComExit ( unit ) ; var tmp ; begin
103870: LD_INT 0
103872: PPUSH
103873: PPUSH
// if not IsInUnit ( unit ) then
103874: LD_VAR 0 1
103878: PPUSH
103879: CALL_OW 310
103883: NOT
103884: IFFALSE 103888
// exit ;
103886: GO 103948
// tmp := IsInUnit ( unit ) ;
103888: LD_ADDR_VAR 0 3
103892: PUSH
103893: LD_VAR 0 1
103897: PPUSH
103898: CALL_OW 310
103902: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103903: LD_VAR 0 3
103907: PPUSH
103908: CALL_OW 247
103912: PUSH
103913: LD_INT 2
103915: EQUAL
103916: IFFALSE 103929
// ComExitVehicle ( unit ) else
103918: LD_VAR 0 1
103922: PPUSH
103923: CALL_OW 121
103927: GO 103938
// ComExitBuilding ( unit ) ;
103929: LD_VAR 0 1
103933: PPUSH
103934: CALL_OW 122
// result := tmp ;
103938: LD_ADDR_VAR 0 2
103942: PUSH
103943: LD_VAR 0 3
103947: ST_TO_ADDR
// end ;
103948: LD_VAR 0 2
103952: RET
// export function ComExitAll ( units ) ; var i ; begin
103953: LD_INT 0
103955: PPUSH
103956: PPUSH
// if not units then
103957: LD_VAR 0 1
103961: NOT
103962: IFFALSE 103966
// exit ;
103964: GO 103992
// for i in units do
103966: LD_ADDR_VAR 0 3
103970: PUSH
103971: LD_VAR 0 1
103975: PUSH
103976: FOR_IN
103977: IFFALSE 103990
// ComExit ( i ) ;
103979: LD_VAR 0 3
103983: PPUSH
103984: CALL 103870 0 1
103988: GO 103976
103990: POP
103991: POP
// end ;
103992: LD_VAR 0 2
103996: RET
// export function ResetHc ; begin
103997: LD_INT 0
103999: PPUSH
// InitHc ;
104000: CALL_OW 19
// hc_importance := 0 ;
104004: LD_ADDR_OWVAR 32
104008: PUSH
104009: LD_INT 0
104011: ST_TO_ADDR
// end ;
104012: LD_VAR 0 1
104016: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
104017: LD_INT 0
104019: PPUSH
104020: PPUSH
104021: PPUSH
// _x := ( x1 + x2 ) div 2 ;
104022: LD_ADDR_VAR 0 6
104026: PUSH
104027: LD_VAR 0 1
104031: PUSH
104032: LD_VAR 0 3
104036: PLUS
104037: PUSH
104038: LD_INT 2
104040: DIV
104041: ST_TO_ADDR
// if _x < 0 then
104042: LD_VAR 0 6
104046: PUSH
104047: LD_INT 0
104049: LESS
104050: IFFALSE 104067
// _x := _x * - 1 ;
104052: LD_ADDR_VAR 0 6
104056: PUSH
104057: LD_VAR 0 6
104061: PUSH
104062: LD_INT 1
104064: NEG
104065: MUL
104066: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
104067: LD_ADDR_VAR 0 7
104071: PUSH
104072: LD_VAR 0 2
104076: PUSH
104077: LD_VAR 0 4
104081: PLUS
104082: PUSH
104083: LD_INT 2
104085: DIV
104086: ST_TO_ADDR
// if _y < 0 then
104087: LD_VAR 0 7
104091: PUSH
104092: LD_INT 0
104094: LESS
104095: IFFALSE 104112
// _y := _y * - 1 ;
104097: LD_ADDR_VAR 0 7
104101: PUSH
104102: LD_VAR 0 7
104106: PUSH
104107: LD_INT 1
104109: NEG
104110: MUL
104111: ST_TO_ADDR
// result := [ _x , _y ] ;
104112: LD_ADDR_VAR 0 5
104116: PUSH
104117: LD_VAR 0 6
104121: PUSH
104122: LD_VAR 0 7
104126: PUSH
104127: EMPTY
104128: LIST
104129: LIST
104130: ST_TO_ADDR
// end ;
104131: LD_VAR 0 5
104135: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
104136: LD_INT 0
104138: PPUSH
104139: PPUSH
104140: PPUSH
104141: PPUSH
// task := GetTaskList ( unit ) ;
104142: LD_ADDR_VAR 0 7
104146: PUSH
104147: LD_VAR 0 1
104151: PPUSH
104152: CALL_OW 437
104156: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
104157: LD_VAR 0 7
104161: NOT
104162: PUSH
104163: LD_VAR 0 1
104167: PPUSH
104168: LD_VAR 0 2
104172: PPUSH
104173: CALL_OW 308
104177: NOT
104178: AND
104179: IFFALSE 104183
// exit ;
104181: GO 104301
// if IsInArea ( unit , area ) then
104183: LD_VAR 0 1
104187: PPUSH
104188: LD_VAR 0 2
104192: PPUSH
104193: CALL_OW 308
104197: IFFALSE 104215
// begin ComMoveToArea ( unit , goAway ) ;
104199: LD_VAR 0 1
104203: PPUSH
104204: LD_VAR 0 3
104208: PPUSH
104209: CALL_OW 113
// exit ;
104213: GO 104301
// end ; if task [ 1 ] [ 1 ] <> M then
104215: LD_VAR 0 7
104219: PUSH
104220: LD_INT 1
104222: ARRAY
104223: PUSH
104224: LD_INT 1
104226: ARRAY
104227: PUSH
104228: LD_STRING M
104230: NONEQUAL
104231: IFFALSE 104235
// exit ;
104233: GO 104301
// x := task [ 1 ] [ 2 ] ;
104235: LD_ADDR_VAR 0 5
104239: PUSH
104240: LD_VAR 0 7
104244: PUSH
104245: LD_INT 1
104247: ARRAY
104248: PUSH
104249: LD_INT 2
104251: ARRAY
104252: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
104253: LD_ADDR_VAR 0 6
104257: PUSH
104258: LD_VAR 0 7
104262: PUSH
104263: LD_INT 1
104265: ARRAY
104266: PUSH
104267: LD_INT 3
104269: ARRAY
104270: ST_TO_ADDR
// if InArea ( x , y , area ) then
104271: LD_VAR 0 5
104275: PPUSH
104276: LD_VAR 0 6
104280: PPUSH
104281: LD_VAR 0 2
104285: PPUSH
104286: CALL_OW 309
104290: IFFALSE 104301
// ComStop ( unit ) ;
104292: LD_VAR 0 1
104296: PPUSH
104297: CALL_OW 141
// end ;
104301: LD_VAR 0 4
104305: RET
// export function Abs ( value ) ; begin
104306: LD_INT 0
104308: PPUSH
// result := value ;
104309: LD_ADDR_VAR 0 2
104313: PUSH
104314: LD_VAR 0 1
104318: ST_TO_ADDR
// if value < 0 then
104319: LD_VAR 0 1
104323: PUSH
104324: LD_INT 0
104326: LESS
104327: IFFALSE 104344
// result := value * - 1 ;
104329: LD_ADDR_VAR 0 2
104333: PUSH
104334: LD_VAR 0 1
104338: PUSH
104339: LD_INT 1
104341: NEG
104342: MUL
104343: ST_TO_ADDR
// end ;
104344: LD_VAR 0 2
104348: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
104349: LD_INT 0
104351: PPUSH
104352: PPUSH
104353: PPUSH
104354: PPUSH
104355: PPUSH
104356: PPUSH
104357: PPUSH
104358: PPUSH
// if not unit or not building then
104359: LD_VAR 0 1
104363: NOT
104364: PUSH
104365: LD_VAR 0 2
104369: NOT
104370: OR
104371: IFFALSE 104375
// exit ;
104373: GO 104601
// x := GetX ( building ) ;
104375: LD_ADDR_VAR 0 4
104379: PUSH
104380: LD_VAR 0 2
104384: PPUSH
104385: CALL_OW 250
104389: ST_TO_ADDR
// y := GetY ( building ) ;
104390: LD_ADDR_VAR 0 6
104394: PUSH
104395: LD_VAR 0 2
104399: PPUSH
104400: CALL_OW 251
104404: ST_TO_ADDR
// d := GetDir ( building ) ;
104405: LD_ADDR_VAR 0 8
104409: PUSH
104410: LD_VAR 0 2
104414: PPUSH
104415: CALL_OW 254
104419: ST_TO_ADDR
// r := 4 ;
104420: LD_ADDR_VAR 0 9
104424: PUSH
104425: LD_INT 4
104427: ST_TO_ADDR
// for i := 1 to 5 do
104428: LD_ADDR_VAR 0 10
104432: PUSH
104433: DOUBLE
104434: LD_INT 1
104436: DEC
104437: ST_TO_ADDR
104438: LD_INT 5
104440: PUSH
104441: FOR_TO
104442: IFFALSE 104599
// begin _x := ShiftX ( x , d , r + i ) ;
104444: LD_ADDR_VAR 0 5
104448: PUSH
104449: LD_VAR 0 4
104453: PPUSH
104454: LD_VAR 0 8
104458: PPUSH
104459: LD_VAR 0 9
104463: PUSH
104464: LD_VAR 0 10
104468: PLUS
104469: PPUSH
104470: CALL_OW 272
104474: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
104475: LD_ADDR_VAR 0 7
104479: PUSH
104480: LD_VAR 0 6
104484: PPUSH
104485: LD_VAR 0 8
104489: PPUSH
104490: LD_VAR 0 9
104494: PUSH
104495: LD_VAR 0 10
104499: PLUS
104500: PPUSH
104501: CALL_OW 273
104505: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
104506: LD_VAR 0 5
104510: PPUSH
104511: LD_VAR 0 7
104515: PPUSH
104516: CALL_OW 488
104520: PUSH
104521: LD_VAR 0 5
104525: PPUSH
104526: LD_VAR 0 7
104530: PPUSH
104531: CALL_OW 428
104535: PPUSH
104536: CALL_OW 247
104540: PUSH
104541: LD_INT 3
104543: PUSH
104544: LD_INT 2
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: IN
104551: NOT
104552: AND
104553: IFFALSE 104597
// begin ComMoveXY ( unit , _x , _y ) ;
104555: LD_VAR 0 1
104559: PPUSH
104560: LD_VAR 0 5
104564: PPUSH
104565: LD_VAR 0 7
104569: PPUSH
104570: CALL_OW 111
// result := [ _x , _y ] ;
104574: LD_ADDR_VAR 0 3
104578: PUSH
104579: LD_VAR 0 5
104583: PUSH
104584: LD_VAR 0 7
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: ST_TO_ADDR
// exit ;
104593: POP
104594: POP
104595: GO 104601
// end ; end ;
104597: GO 104441
104599: POP
104600: POP
// end ;
104601: LD_VAR 0 3
104605: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
104606: LD_INT 0
104608: PPUSH
104609: PPUSH
104610: PPUSH
// result := 0 ;
104611: LD_ADDR_VAR 0 3
104615: PUSH
104616: LD_INT 0
104618: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
104619: LD_VAR 0 1
104623: PUSH
104624: LD_INT 0
104626: LESS
104627: PUSH
104628: LD_VAR 0 1
104632: PUSH
104633: LD_INT 8
104635: GREATER
104636: OR
104637: PUSH
104638: LD_VAR 0 2
104642: PUSH
104643: LD_INT 0
104645: LESS
104646: OR
104647: PUSH
104648: LD_VAR 0 2
104652: PUSH
104653: LD_INT 8
104655: GREATER
104656: OR
104657: IFFALSE 104661
// exit ;
104659: GO 104736
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
104661: LD_ADDR_VAR 0 4
104665: PUSH
104666: LD_INT 22
104668: PUSH
104669: LD_VAR 0 2
104673: PUSH
104674: EMPTY
104675: LIST
104676: LIST
104677: PPUSH
104678: CALL_OW 69
104682: PUSH
104683: FOR_IN
104684: IFFALSE 104734
// begin un := UnitShoot ( i ) ;
104686: LD_ADDR_VAR 0 5
104690: PUSH
104691: LD_VAR 0 4
104695: PPUSH
104696: CALL_OW 504
104700: ST_TO_ADDR
// if GetSide ( un ) = side1 then
104701: LD_VAR 0 5
104705: PPUSH
104706: CALL_OW 255
104710: PUSH
104711: LD_VAR 0 1
104715: EQUAL
104716: IFFALSE 104732
// begin result := un ;
104718: LD_ADDR_VAR 0 3
104722: PUSH
104723: LD_VAR 0 5
104727: ST_TO_ADDR
// exit ;
104728: POP
104729: POP
104730: GO 104736
// end ; end ;
104732: GO 104683
104734: POP
104735: POP
// end ;
104736: LD_VAR 0 3
104740: RET
// export function GetCargoBay ( units ) ; begin
104741: LD_INT 0
104743: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
104744: LD_ADDR_VAR 0 2
104748: PUSH
104749: LD_VAR 0 1
104753: PPUSH
104754: LD_INT 2
104756: PUSH
104757: LD_INT 34
104759: PUSH
104760: LD_INT 12
104762: PUSH
104763: EMPTY
104764: LIST
104765: LIST
104766: PUSH
104767: LD_INT 34
104769: PUSH
104770: LD_INT 51
104772: PUSH
104773: EMPTY
104774: LIST
104775: LIST
104776: PUSH
104777: LD_INT 34
104779: PUSH
104780: LD_INT 32
104782: PUSH
104783: EMPTY
104784: LIST
104785: LIST
104786: PUSH
104787: LD_INT 34
104789: PUSH
104790: LD_INT 89
104792: PUSH
104793: EMPTY
104794: LIST
104795: LIST
104796: PUSH
104797: EMPTY
104798: LIST
104799: LIST
104800: LIST
104801: LIST
104802: LIST
104803: PPUSH
104804: CALL_OW 72
104808: ST_TO_ADDR
// end ;
104809: LD_VAR 0 2
104813: RET
// export function Negate ( value ) ; begin
104814: LD_INT 0
104816: PPUSH
// result := not value ;
104817: LD_ADDR_VAR 0 2
104821: PUSH
104822: LD_VAR 0 1
104826: NOT
104827: ST_TO_ADDR
// end ;
104828: LD_VAR 0 2
104832: RET
// export function Inc ( value ) ; begin
104833: LD_INT 0
104835: PPUSH
// result := value + 1 ;
104836: LD_ADDR_VAR 0 2
104840: PUSH
104841: LD_VAR 0 1
104845: PUSH
104846: LD_INT 1
104848: PLUS
104849: ST_TO_ADDR
// end ;
104850: LD_VAR 0 2
104854: RET
// export function Dec ( value ) ; begin
104855: LD_INT 0
104857: PPUSH
// result := value - 1 ;
104858: LD_ADDR_VAR 0 2
104862: PUSH
104863: LD_VAR 0 1
104867: PUSH
104868: LD_INT 1
104870: MINUS
104871: ST_TO_ADDR
// end ;
104872: LD_VAR 0 2
104876: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
104877: LD_INT 0
104879: PPUSH
104880: PPUSH
104881: PPUSH
104882: PPUSH
104883: PPUSH
104884: PPUSH
104885: PPUSH
104886: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
104887: LD_VAR 0 1
104891: PPUSH
104892: LD_VAR 0 2
104896: PPUSH
104897: CALL_OW 488
104901: NOT
104902: PUSH
104903: LD_VAR 0 3
104907: PPUSH
104908: LD_VAR 0 4
104912: PPUSH
104913: CALL_OW 488
104917: NOT
104918: OR
104919: IFFALSE 104932
// begin result := - 1 ;
104921: LD_ADDR_VAR 0 5
104925: PUSH
104926: LD_INT 1
104928: NEG
104929: ST_TO_ADDR
// exit ;
104930: GO 105167
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
104932: LD_ADDR_VAR 0 12
104936: PUSH
104937: LD_VAR 0 1
104941: PPUSH
104942: LD_VAR 0 2
104946: PPUSH
104947: LD_VAR 0 3
104951: PPUSH
104952: LD_VAR 0 4
104956: PPUSH
104957: CALL 104017 0 4
104961: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
104962: LD_ADDR_VAR 0 11
104966: PUSH
104967: LD_VAR 0 1
104971: PPUSH
104972: LD_VAR 0 2
104976: PPUSH
104977: LD_VAR 0 12
104981: PUSH
104982: LD_INT 1
104984: ARRAY
104985: PPUSH
104986: LD_VAR 0 12
104990: PUSH
104991: LD_INT 2
104993: ARRAY
104994: PPUSH
104995: CALL_OW 298
104999: ST_TO_ADDR
// distance := 9999 ;
105000: LD_ADDR_VAR 0 10
105004: PUSH
105005: LD_INT 9999
105007: ST_TO_ADDR
// for i := 0 to 5 do
105008: LD_ADDR_VAR 0 6
105012: PUSH
105013: DOUBLE
105014: LD_INT 0
105016: DEC
105017: ST_TO_ADDR
105018: LD_INT 5
105020: PUSH
105021: FOR_TO
105022: IFFALSE 105165
// begin _x := ShiftX ( x1 , i , centerDist ) ;
105024: LD_ADDR_VAR 0 7
105028: PUSH
105029: LD_VAR 0 1
105033: PPUSH
105034: LD_VAR 0 6
105038: PPUSH
105039: LD_VAR 0 11
105043: PPUSH
105044: CALL_OW 272
105048: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
105049: LD_ADDR_VAR 0 8
105053: PUSH
105054: LD_VAR 0 2
105058: PPUSH
105059: LD_VAR 0 6
105063: PPUSH
105064: LD_VAR 0 11
105068: PPUSH
105069: CALL_OW 273
105073: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105074: LD_VAR 0 7
105078: PPUSH
105079: LD_VAR 0 8
105083: PPUSH
105084: CALL_OW 488
105088: NOT
105089: IFFALSE 105093
// continue ;
105091: GO 105021
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
105093: LD_ADDR_VAR 0 9
105097: PUSH
105098: LD_VAR 0 12
105102: PUSH
105103: LD_INT 1
105105: ARRAY
105106: PPUSH
105107: LD_VAR 0 12
105111: PUSH
105112: LD_INT 2
105114: ARRAY
105115: PPUSH
105116: LD_VAR 0 7
105120: PPUSH
105121: LD_VAR 0 8
105125: PPUSH
105126: CALL_OW 298
105130: ST_TO_ADDR
// if tmp < distance then
105131: LD_VAR 0 9
105135: PUSH
105136: LD_VAR 0 10
105140: LESS
105141: IFFALSE 105163
// begin result := i ;
105143: LD_ADDR_VAR 0 5
105147: PUSH
105148: LD_VAR 0 6
105152: ST_TO_ADDR
// distance := tmp ;
105153: LD_ADDR_VAR 0 10
105157: PUSH
105158: LD_VAR 0 9
105162: ST_TO_ADDR
// end ; end ;
105163: GO 105021
105165: POP
105166: POP
// end ;
105167: LD_VAR 0 5
105171: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
105172: LD_INT 0
105174: PPUSH
105175: PPUSH
// if not driver or not IsInUnit ( driver ) then
105176: LD_VAR 0 1
105180: NOT
105181: PUSH
105182: LD_VAR 0 1
105186: PPUSH
105187: CALL_OW 310
105191: NOT
105192: OR
105193: IFFALSE 105197
// exit ;
105195: GO 105287
// vehicle := IsInUnit ( driver ) ;
105197: LD_ADDR_VAR 0 3
105201: PUSH
105202: LD_VAR 0 1
105206: PPUSH
105207: CALL_OW 310
105211: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
105212: LD_VAR 0 1
105216: PPUSH
105217: LD_STRING \
105219: PUSH
105220: LD_INT 0
105222: PUSH
105223: LD_INT 0
105225: PUSH
105226: LD_INT 0
105228: PUSH
105229: LD_INT 0
105231: PUSH
105232: LD_INT 0
105234: PUSH
105235: LD_INT 0
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: LIST
105242: LIST
105243: LIST
105244: LIST
105245: LIST
105246: PUSH
105247: LD_STRING E
105249: PUSH
105250: LD_INT 0
105252: PUSH
105253: LD_INT 0
105255: PUSH
105256: LD_VAR 0 3
105260: PUSH
105261: LD_INT 0
105263: PUSH
105264: LD_INT 0
105266: PUSH
105267: LD_INT 0
105269: PUSH
105270: EMPTY
105271: LIST
105272: LIST
105273: LIST
105274: LIST
105275: LIST
105276: LIST
105277: LIST
105278: PUSH
105279: EMPTY
105280: LIST
105281: LIST
105282: PPUSH
105283: CALL_OW 446
// end ;
105287: LD_VAR 0 2
105291: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
105292: LD_INT 0
105294: PPUSH
105295: PPUSH
// if not driver or not IsInUnit ( driver ) then
105296: LD_VAR 0 1
105300: NOT
105301: PUSH
105302: LD_VAR 0 1
105306: PPUSH
105307: CALL_OW 310
105311: NOT
105312: OR
105313: IFFALSE 105317
// exit ;
105315: GO 105407
// vehicle := IsInUnit ( driver ) ;
105317: LD_ADDR_VAR 0 3
105321: PUSH
105322: LD_VAR 0 1
105326: PPUSH
105327: CALL_OW 310
105331: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
105332: LD_VAR 0 1
105336: PPUSH
105337: LD_STRING \
105339: PUSH
105340: LD_INT 0
105342: PUSH
105343: LD_INT 0
105345: PUSH
105346: LD_INT 0
105348: PUSH
105349: LD_INT 0
105351: PUSH
105352: LD_INT 0
105354: PUSH
105355: LD_INT 0
105357: PUSH
105358: EMPTY
105359: LIST
105360: LIST
105361: LIST
105362: LIST
105363: LIST
105364: LIST
105365: LIST
105366: PUSH
105367: LD_STRING E
105369: PUSH
105370: LD_INT 0
105372: PUSH
105373: LD_INT 0
105375: PUSH
105376: LD_VAR 0 3
105380: PUSH
105381: LD_INT 0
105383: PUSH
105384: LD_INT 0
105386: PUSH
105387: LD_INT 0
105389: PUSH
105390: EMPTY
105391: LIST
105392: LIST
105393: LIST
105394: LIST
105395: LIST
105396: LIST
105397: LIST
105398: PUSH
105399: EMPTY
105400: LIST
105401: LIST
105402: PPUSH
105403: CALL_OW 447
// end ;
105407: LD_VAR 0 2
105411: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
105412: LD_INT 0
105414: PPUSH
105415: PPUSH
105416: PPUSH
// tmp := [ ] ;
105417: LD_ADDR_VAR 0 5
105421: PUSH
105422: EMPTY
105423: ST_TO_ADDR
// for i in units do
105424: LD_ADDR_VAR 0 4
105428: PUSH
105429: LD_VAR 0 1
105433: PUSH
105434: FOR_IN
105435: IFFALSE 105473
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
105437: LD_ADDR_VAR 0 5
105441: PUSH
105442: LD_VAR 0 5
105446: PPUSH
105447: LD_VAR 0 5
105451: PUSH
105452: LD_INT 1
105454: PLUS
105455: PPUSH
105456: LD_VAR 0 4
105460: PPUSH
105461: CALL_OW 256
105465: PPUSH
105466: CALL_OW 2
105470: ST_TO_ADDR
105471: GO 105434
105473: POP
105474: POP
// if not tmp then
105475: LD_VAR 0 5
105479: NOT
105480: IFFALSE 105484
// exit ;
105482: GO 105532
// if asc then
105484: LD_VAR 0 2
105488: IFFALSE 105512
// result := SortListByListAsc ( units , tmp ) else
105490: LD_ADDR_VAR 0 3
105494: PUSH
105495: LD_VAR 0 1
105499: PPUSH
105500: LD_VAR 0 5
105504: PPUSH
105505: CALL_OW 76
105509: ST_TO_ADDR
105510: GO 105532
// result := SortListByListDesc ( units , tmp ) ;
105512: LD_ADDR_VAR 0 3
105516: PUSH
105517: LD_VAR 0 1
105521: PPUSH
105522: LD_VAR 0 5
105526: PPUSH
105527: CALL_OW 77
105531: ST_TO_ADDR
// end ;
105532: LD_VAR 0 3
105536: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
105537: LD_INT 0
105539: PPUSH
105540: PPUSH
// task := GetTaskList ( mech ) ;
105541: LD_ADDR_VAR 0 4
105545: PUSH
105546: LD_VAR 0 1
105550: PPUSH
105551: CALL_OW 437
105555: ST_TO_ADDR
// if not task then
105556: LD_VAR 0 4
105560: NOT
105561: IFFALSE 105565
// exit ;
105563: GO 105607
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
105565: LD_ADDR_VAR 0 3
105569: PUSH
105570: LD_VAR 0 4
105574: PUSH
105575: LD_INT 1
105577: ARRAY
105578: PUSH
105579: LD_INT 1
105581: ARRAY
105582: PUSH
105583: LD_STRING r
105585: EQUAL
105586: PUSH
105587: LD_VAR 0 4
105591: PUSH
105592: LD_INT 1
105594: ARRAY
105595: PUSH
105596: LD_INT 4
105598: ARRAY
105599: PUSH
105600: LD_VAR 0 2
105604: EQUAL
105605: AND
105606: ST_TO_ADDR
// end ;
105607: LD_VAR 0 3
105611: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
105612: LD_INT 0
105614: PPUSH
// SetDir ( unit , d ) ;
105615: LD_VAR 0 1
105619: PPUSH
105620: LD_VAR 0 4
105624: PPUSH
105625: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
105629: LD_VAR 0 1
105633: PPUSH
105634: LD_VAR 0 2
105638: PPUSH
105639: LD_VAR 0 3
105643: PPUSH
105644: LD_VAR 0 5
105648: PPUSH
105649: CALL_OW 48
// end ;
105653: LD_VAR 0 6
105657: RET
// export function ToNaturalNumber ( number ) ; begin
105658: LD_INT 0
105660: PPUSH
// result := number div 1 ;
105661: LD_ADDR_VAR 0 2
105665: PUSH
105666: LD_VAR 0 1
105670: PUSH
105671: LD_INT 1
105673: DIV
105674: ST_TO_ADDR
// if number < 0 then
105675: LD_VAR 0 1
105679: PUSH
105680: LD_INT 0
105682: LESS
105683: IFFALSE 105693
// result := 0 ;
105685: LD_ADDR_VAR 0 2
105689: PUSH
105690: LD_INT 0
105692: ST_TO_ADDR
// end ;
105693: LD_VAR 0 2
105697: RET
// export function SortByClass ( units , class ) ; var un ; begin
105698: LD_INT 0
105700: PPUSH
105701: PPUSH
// if not units or not class then
105702: LD_VAR 0 1
105706: NOT
105707: PUSH
105708: LD_VAR 0 2
105712: NOT
105713: OR
105714: IFFALSE 105718
// exit ;
105716: GO 105813
// result := [ ] ;
105718: LD_ADDR_VAR 0 3
105722: PUSH
105723: EMPTY
105724: ST_TO_ADDR
// for un in units do
105725: LD_ADDR_VAR 0 4
105729: PUSH
105730: LD_VAR 0 1
105734: PUSH
105735: FOR_IN
105736: IFFALSE 105811
// if GetClass ( un ) = class then
105738: LD_VAR 0 4
105742: PPUSH
105743: CALL_OW 257
105747: PUSH
105748: LD_VAR 0 2
105752: EQUAL
105753: IFFALSE 105780
// result := Insert ( result , 1 , un ) else
105755: LD_ADDR_VAR 0 3
105759: PUSH
105760: LD_VAR 0 3
105764: PPUSH
105765: LD_INT 1
105767: PPUSH
105768: LD_VAR 0 4
105772: PPUSH
105773: CALL_OW 2
105777: ST_TO_ADDR
105778: GO 105809
// result := Replace ( result , result + 1 , un ) ;
105780: LD_ADDR_VAR 0 3
105784: PUSH
105785: LD_VAR 0 3
105789: PPUSH
105790: LD_VAR 0 3
105794: PUSH
105795: LD_INT 1
105797: PLUS
105798: PPUSH
105799: LD_VAR 0 4
105803: PPUSH
105804: CALL_OW 1
105808: ST_TO_ADDR
105809: GO 105735
105811: POP
105812: POP
// end ;
105813: LD_VAR 0 3
105817: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
105818: LD_INT 0
105820: PPUSH
105821: PPUSH
105822: PPUSH
105823: PPUSH
105824: PPUSH
105825: PPUSH
105826: PPUSH
// result := [ ] ;
105827: LD_ADDR_VAR 0 4
105831: PUSH
105832: EMPTY
105833: ST_TO_ADDR
// if x - r < 0 then
105834: LD_VAR 0 1
105838: PUSH
105839: LD_VAR 0 3
105843: MINUS
105844: PUSH
105845: LD_INT 0
105847: LESS
105848: IFFALSE 105860
// min_x := 0 else
105850: LD_ADDR_VAR 0 8
105854: PUSH
105855: LD_INT 0
105857: ST_TO_ADDR
105858: GO 105876
// min_x := x - r ;
105860: LD_ADDR_VAR 0 8
105864: PUSH
105865: LD_VAR 0 1
105869: PUSH
105870: LD_VAR 0 3
105874: MINUS
105875: ST_TO_ADDR
// if y - r < 0 then
105876: LD_VAR 0 2
105880: PUSH
105881: LD_VAR 0 3
105885: MINUS
105886: PUSH
105887: LD_INT 0
105889: LESS
105890: IFFALSE 105902
// min_y := 0 else
105892: LD_ADDR_VAR 0 7
105896: PUSH
105897: LD_INT 0
105899: ST_TO_ADDR
105900: GO 105918
// min_y := y - r ;
105902: LD_ADDR_VAR 0 7
105906: PUSH
105907: LD_VAR 0 2
105911: PUSH
105912: LD_VAR 0 3
105916: MINUS
105917: ST_TO_ADDR
// max_x := x + r ;
105918: LD_ADDR_VAR 0 9
105922: PUSH
105923: LD_VAR 0 1
105927: PUSH
105928: LD_VAR 0 3
105932: PLUS
105933: ST_TO_ADDR
// max_y := y + r ;
105934: LD_ADDR_VAR 0 10
105938: PUSH
105939: LD_VAR 0 2
105943: PUSH
105944: LD_VAR 0 3
105948: PLUS
105949: ST_TO_ADDR
// for _x = min_x to max_x do
105950: LD_ADDR_VAR 0 5
105954: PUSH
105955: DOUBLE
105956: LD_VAR 0 8
105960: DEC
105961: ST_TO_ADDR
105962: LD_VAR 0 9
105966: PUSH
105967: FOR_TO
105968: IFFALSE 106069
// for _y = min_y to max_y do
105970: LD_ADDR_VAR 0 6
105974: PUSH
105975: DOUBLE
105976: LD_VAR 0 7
105980: DEC
105981: ST_TO_ADDR
105982: LD_VAR 0 10
105986: PUSH
105987: FOR_TO
105988: IFFALSE 106065
// begin if not ValidHex ( _x , _y ) then
105990: LD_VAR 0 5
105994: PPUSH
105995: LD_VAR 0 6
105999: PPUSH
106000: CALL_OW 488
106004: NOT
106005: IFFALSE 106009
// continue ;
106007: GO 105987
// if GetResourceTypeXY ( _x , _y ) then
106009: LD_VAR 0 5
106013: PPUSH
106014: LD_VAR 0 6
106018: PPUSH
106019: CALL_OW 283
106023: IFFALSE 106063
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
106025: LD_ADDR_VAR 0 4
106029: PUSH
106030: LD_VAR 0 4
106034: PPUSH
106035: LD_VAR 0 4
106039: PUSH
106040: LD_INT 1
106042: PLUS
106043: PPUSH
106044: LD_VAR 0 5
106048: PUSH
106049: LD_VAR 0 6
106053: PUSH
106054: EMPTY
106055: LIST
106056: LIST
106057: PPUSH
106058: CALL_OW 1
106062: ST_TO_ADDR
// end ;
106063: GO 105987
106065: POP
106066: POP
106067: GO 105967
106069: POP
106070: POP
// end ;
106071: LD_VAR 0 4
106075: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
106076: LD_INT 0
106078: PPUSH
106079: PPUSH
106080: PPUSH
106081: PPUSH
106082: PPUSH
106083: PPUSH
106084: PPUSH
106085: PPUSH
// if not units then
106086: LD_VAR 0 1
106090: NOT
106091: IFFALSE 106095
// exit ;
106093: GO 106619
// result := UnitFilter ( units , [ f_ok ] ) ;
106095: LD_ADDR_VAR 0 3
106099: PUSH
106100: LD_VAR 0 1
106104: PPUSH
106105: LD_INT 50
106107: PUSH
106108: EMPTY
106109: LIST
106110: PPUSH
106111: CALL_OW 72
106115: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
106116: LD_ADDR_VAR 0 8
106120: PUSH
106121: LD_VAR 0 1
106125: PUSH
106126: LD_INT 1
106128: ARRAY
106129: PPUSH
106130: CALL_OW 255
106134: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
106135: LD_ADDR_VAR 0 10
106139: PUSH
106140: LD_INT 29
106142: PUSH
106143: LD_INT 91
106145: PUSH
106146: LD_INT 49
106148: PUSH
106149: EMPTY
106150: LIST
106151: LIST
106152: LIST
106153: ST_TO_ADDR
// if not result then
106154: LD_VAR 0 3
106158: NOT
106159: IFFALSE 106163
// exit ;
106161: GO 106619
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
106163: LD_ADDR_VAR 0 5
106167: PUSH
106168: LD_INT 81
106170: PUSH
106171: LD_VAR 0 8
106175: PUSH
106176: EMPTY
106177: LIST
106178: LIST
106179: PPUSH
106180: CALL_OW 69
106184: ST_TO_ADDR
// for i in result do
106185: LD_ADDR_VAR 0 4
106189: PUSH
106190: LD_VAR 0 3
106194: PUSH
106195: FOR_IN
106196: IFFALSE 106617
// begin tag := GetTag ( i ) + 1 ;
106198: LD_ADDR_VAR 0 9
106202: PUSH
106203: LD_VAR 0 4
106207: PPUSH
106208: CALL_OW 110
106212: PUSH
106213: LD_INT 1
106215: PLUS
106216: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
106217: LD_ADDR_VAR 0 7
106221: PUSH
106222: LD_VAR 0 4
106226: PPUSH
106227: CALL_OW 250
106231: PPUSH
106232: LD_VAR 0 4
106236: PPUSH
106237: CALL_OW 251
106241: PPUSH
106242: LD_INT 6
106244: PPUSH
106245: CALL 105818 0 3
106249: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
106250: LD_VAR 0 4
106254: PPUSH
106255: CALL_OW 247
106259: PUSH
106260: LD_INT 2
106262: EQUAL
106263: PUSH
106264: LD_VAR 0 7
106268: AND
106269: PUSH
106270: LD_VAR 0 4
106274: PPUSH
106275: CALL_OW 264
106279: PUSH
106280: LD_VAR 0 10
106284: IN
106285: NOT
106286: AND
106287: IFFALSE 106326
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
106289: LD_VAR 0 4
106293: PPUSH
106294: LD_VAR 0 7
106298: PUSH
106299: LD_INT 1
106301: ARRAY
106302: PUSH
106303: LD_INT 1
106305: ARRAY
106306: PPUSH
106307: LD_VAR 0 7
106311: PUSH
106312: LD_INT 1
106314: ARRAY
106315: PUSH
106316: LD_INT 2
106318: ARRAY
106319: PPUSH
106320: CALL_OW 116
106324: GO 106615
// if path > tag then
106326: LD_VAR 0 2
106330: PUSH
106331: LD_VAR 0 9
106335: GREATER
106336: IFFALSE 106544
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
106338: LD_ADDR_VAR 0 6
106342: PUSH
106343: LD_VAR 0 5
106347: PPUSH
106348: LD_INT 91
106350: PUSH
106351: LD_VAR 0 4
106355: PUSH
106356: LD_INT 8
106358: PUSH
106359: EMPTY
106360: LIST
106361: LIST
106362: LIST
106363: PPUSH
106364: CALL_OW 72
106368: ST_TO_ADDR
// if nearEnemy then
106369: LD_VAR 0 6
106373: IFFALSE 106442
// begin if GetWeapon ( i ) = ru_time_lapser then
106375: LD_VAR 0 4
106379: PPUSH
106380: CALL_OW 264
106384: PUSH
106385: LD_INT 49
106387: EQUAL
106388: IFFALSE 106416
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
106390: LD_VAR 0 4
106394: PPUSH
106395: LD_VAR 0 6
106399: PPUSH
106400: LD_VAR 0 4
106404: PPUSH
106405: CALL_OW 74
106409: PPUSH
106410: CALL_OW 112
106414: GO 106440
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
106416: LD_VAR 0 4
106420: PPUSH
106421: LD_VAR 0 6
106425: PPUSH
106426: LD_VAR 0 4
106430: PPUSH
106431: CALL_OW 74
106435: PPUSH
106436: CALL_OW 115
// end else
106440: GO 106542
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
106442: LD_VAR 0 4
106446: PPUSH
106447: LD_VAR 0 2
106451: PUSH
106452: LD_VAR 0 9
106456: ARRAY
106457: PUSH
106458: LD_INT 1
106460: ARRAY
106461: PPUSH
106462: LD_VAR 0 2
106466: PUSH
106467: LD_VAR 0 9
106471: ARRAY
106472: PUSH
106473: LD_INT 2
106475: ARRAY
106476: PPUSH
106477: CALL_OW 297
106481: PUSH
106482: LD_INT 6
106484: GREATER
106485: IFFALSE 106528
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
106487: LD_VAR 0 4
106491: PPUSH
106492: LD_VAR 0 2
106496: PUSH
106497: LD_VAR 0 9
106501: ARRAY
106502: PUSH
106503: LD_INT 1
106505: ARRAY
106506: PPUSH
106507: LD_VAR 0 2
106511: PUSH
106512: LD_VAR 0 9
106516: ARRAY
106517: PUSH
106518: LD_INT 2
106520: ARRAY
106521: PPUSH
106522: CALL_OW 114
106526: GO 106542
// SetTag ( i , tag ) ;
106528: LD_VAR 0 4
106532: PPUSH
106533: LD_VAR 0 9
106537: PPUSH
106538: CALL_OW 109
// end else
106542: GO 106615
// if enemy then
106544: LD_VAR 0 5
106548: IFFALSE 106615
// begin if GetWeapon ( i ) = ru_time_lapser then
106550: LD_VAR 0 4
106554: PPUSH
106555: CALL_OW 264
106559: PUSH
106560: LD_INT 49
106562: EQUAL
106563: IFFALSE 106591
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106565: LD_VAR 0 4
106569: PPUSH
106570: LD_VAR 0 5
106574: PPUSH
106575: LD_VAR 0 4
106579: PPUSH
106580: CALL_OW 74
106584: PPUSH
106585: CALL_OW 112
106589: GO 106615
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
106591: LD_VAR 0 4
106595: PPUSH
106596: LD_VAR 0 5
106600: PPUSH
106601: LD_VAR 0 4
106605: PPUSH
106606: CALL_OW 74
106610: PPUSH
106611: CALL_OW 115
// end ; end ;
106615: GO 106195
106617: POP
106618: POP
// end ;
106619: LD_VAR 0 3
106623: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
106624: LD_INT 0
106626: PPUSH
106627: PPUSH
106628: PPUSH
// if not unit or IsInUnit ( unit ) then
106629: LD_VAR 0 1
106633: NOT
106634: PUSH
106635: LD_VAR 0 1
106639: PPUSH
106640: CALL_OW 310
106644: OR
106645: IFFALSE 106649
// exit ;
106647: GO 106740
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
106649: LD_ADDR_VAR 0 4
106653: PUSH
106654: LD_VAR 0 1
106658: PPUSH
106659: CALL_OW 250
106663: PPUSH
106664: LD_VAR 0 2
106668: PPUSH
106669: LD_INT 1
106671: PPUSH
106672: CALL_OW 272
106676: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
106677: LD_ADDR_VAR 0 5
106681: PUSH
106682: LD_VAR 0 1
106686: PPUSH
106687: CALL_OW 251
106691: PPUSH
106692: LD_VAR 0 2
106696: PPUSH
106697: LD_INT 1
106699: PPUSH
106700: CALL_OW 273
106704: ST_TO_ADDR
// if ValidHex ( x , y ) then
106705: LD_VAR 0 4
106709: PPUSH
106710: LD_VAR 0 5
106714: PPUSH
106715: CALL_OW 488
106719: IFFALSE 106740
// ComTurnXY ( unit , x , y ) ;
106721: LD_VAR 0 1
106725: PPUSH
106726: LD_VAR 0 4
106730: PPUSH
106731: LD_VAR 0 5
106735: PPUSH
106736: CALL_OW 118
// end ;
106740: LD_VAR 0 3
106744: RET
// export function SeeUnits ( side , units ) ; var i ; begin
106745: LD_INT 0
106747: PPUSH
106748: PPUSH
// result := false ;
106749: LD_ADDR_VAR 0 3
106753: PUSH
106754: LD_INT 0
106756: ST_TO_ADDR
// if not units then
106757: LD_VAR 0 2
106761: NOT
106762: IFFALSE 106766
// exit ;
106764: GO 106811
// for i in units do
106766: LD_ADDR_VAR 0 4
106770: PUSH
106771: LD_VAR 0 2
106775: PUSH
106776: FOR_IN
106777: IFFALSE 106809
// if See ( side , i ) then
106779: LD_VAR 0 1
106783: PPUSH
106784: LD_VAR 0 4
106788: PPUSH
106789: CALL_OW 292
106793: IFFALSE 106807
// begin result := true ;
106795: LD_ADDR_VAR 0 3
106799: PUSH
106800: LD_INT 1
106802: ST_TO_ADDR
// exit ;
106803: POP
106804: POP
106805: GO 106811
// end ;
106807: GO 106776
106809: POP
106810: POP
// end ;
106811: LD_VAR 0 3
106815: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
106816: LD_INT 0
106818: PPUSH
106819: PPUSH
106820: PPUSH
106821: PPUSH
// if not unit or not points then
106822: LD_VAR 0 1
106826: NOT
106827: PUSH
106828: LD_VAR 0 2
106832: NOT
106833: OR
106834: IFFALSE 106838
// exit ;
106836: GO 106928
// dist := 99999 ;
106838: LD_ADDR_VAR 0 5
106842: PUSH
106843: LD_INT 99999
106845: ST_TO_ADDR
// for i in points do
106846: LD_ADDR_VAR 0 4
106850: PUSH
106851: LD_VAR 0 2
106855: PUSH
106856: FOR_IN
106857: IFFALSE 106926
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
106859: LD_ADDR_VAR 0 6
106863: PUSH
106864: LD_VAR 0 1
106868: PPUSH
106869: LD_VAR 0 4
106873: PUSH
106874: LD_INT 1
106876: ARRAY
106877: PPUSH
106878: LD_VAR 0 4
106882: PUSH
106883: LD_INT 2
106885: ARRAY
106886: PPUSH
106887: CALL_OW 297
106891: ST_TO_ADDR
// if tmpDist < dist then
106892: LD_VAR 0 6
106896: PUSH
106897: LD_VAR 0 5
106901: LESS
106902: IFFALSE 106924
// begin result := i ;
106904: LD_ADDR_VAR 0 3
106908: PUSH
106909: LD_VAR 0 4
106913: ST_TO_ADDR
// dist := tmpDist ;
106914: LD_ADDR_VAR 0 5
106918: PUSH
106919: LD_VAR 0 6
106923: ST_TO_ADDR
// end ; end ;
106924: GO 106856
106926: POP
106927: POP
// end ;
106928: LD_VAR 0 3
106932: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
106933: LD_INT 0
106935: PPUSH
// uc_side := side ;
106936: LD_ADDR_OWVAR 20
106940: PUSH
106941: LD_VAR 0 1
106945: ST_TO_ADDR
// uc_nation := 3 ;
106946: LD_ADDR_OWVAR 21
106950: PUSH
106951: LD_INT 3
106953: ST_TO_ADDR
// vc_chassis := 25 ;
106954: LD_ADDR_OWVAR 37
106958: PUSH
106959: LD_INT 25
106961: ST_TO_ADDR
// vc_engine := engine_siberite ;
106962: LD_ADDR_OWVAR 39
106966: PUSH
106967: LD_INT 3
106969: ST_TO_ADDR
// vc_control := control_computer ;
106970: LD_ADDR_OWVAR 38
106974: PUSH
106975: LD_INT 3
106977: ST_TO_ADDR
// vc_weapon := 59 ;
106978: LD_ADDR_OWVAR 40
106982: PUSH
106983: LD_INT 59
106985: ST_TO_ADDR
// result := CreateVehicle ;
106986: LD_ADDR_VAR 0 5
106990: PUSH
106991: CALL_OW 45
106995: ST_TO_ADDR
// SetDir ( result , d ) ;
106996: LD_VAR 0 5
107000: PPUSH
107001: LD_VAR 0 4
107005: PPUSH
107006: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
107010: LD_VAR 0 5
107014: PPUSH
107015: LD_VAR 0 2
107019: PPUSH
107020: LD_VAR 0 3
107024: PPUSH
107025: LD_INT 0
107027: PPUSH
107028: CALL_OW 48
// end ;
107032: LD_VAR 0 5
107036: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
107037: LD_INT 0
107039: PPUSH
107040: PPUSH
107041: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
107042: LD_ADDR_VAR 0 2
107046: PUSH
107047: LD_INT 0
107049: PUSH
107050: LD_INT 0
107052: PUSH
107053: LD_INT 0
107055: PUSH
107056: LD_INT 0
107058: PUSH
107059: EMPTY
107060: LIST
107061: LIST
107062: LIST
107063: LIST
107064: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
107065: LD_VAR 0 1
107069: NOT
107070: PUSH
107071: LD_VAR 0 1
107075: PPUSH
107076: CALL_OW 264
107080: PUSH
107081: LD_INT 12
107083: PUSH
107084: LD_INT 51
107086: PUSH
107087: LD_INT 32
107089: PUSH
107090: LD_INT 89
107092: PUSH
107093: EMPTY
107094: LIST
107095: LIST
107096: LIST
107097: LIST
107098: IN
107099: NOT
107100: OR
107101: IFFALSE 107105
// exit ;
107103: GO 107203
// for i := 1 to 3 do
107105: LD_ADDR_VAR 0 3
107109: PUSH
107110: DOUBLE
107111: LD_INT 1
107113: DEC
107114: ST_TO_ADDR
107115: LD_INT 3
107117: PUSH
107118: FOR_TO
107119: IFFALSE 107201
// begin tmp := GetCargo ( cargo , i ) ;
107121: LD_ADDR_VAR 0 4
107125: PUSH
107126: LD_VAR 0 1
107130: PPUSH
107131: LD_VAR 0 3
107135: PPUSH
107136: CALL_OW 289
107140: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
107141: LD_ADDR_VAR 0 2
107145: PUSH
107146: LD_VAR 0 2
107150: PPUSH
107151: LD_VAR 0 3
107155: PPUSH
107156: LD_VAR 0 4
107160: PPUSH
107161: CALL_OW 1
107165: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
107166: LD_ADDR_VAR 0 2
107170: PUSH
107171: LD_VAR 0 2
107175: PPUSH
107176: LD_INT 4
107178: PPUSH
107179: LD_VAR 0 2
107183: PUSH
107184: LD_INT 4
107186: ARRAY
107187: PUSH
107188: LD_VAR 0 4
107192: PLUS
107193: PPUSH
107194: CALL_OW 1
107198: ST_TO_ADDR
// end ;
107199: GO 107118
107201: POP
107202: POP
// end ;
107203: LD_VAR 0 2
107207: RET
// export function Length ( array ) ; begin
107208: LD_INT 0
107210: PPUSH
// result := array + 0 ;
107211: LD_ADDR_VAR 0 2
107215: PUSH
107216: LD_VAR 0 1
107220: PUSH
107221: LD_INT 0
107223: PLUS
107224: ST_TO_ADDR
// end ;
107225: LD_VAR 0 2
107229: RET
// export function PrepareArray ( array ) ; begin
107230: LD_INT 0
107232: PPUSH
// result := array diff 0 ;
107233: LD_ADDR_VAR 0 2
107237: PUSH
107238: LD_VAR 0 1
107242: PUSH
107243: LD_INT 0
107245: DIFF
107246: ST_TO_ADDR
// if not result [ 1 ] then
107247: LD_VAR 0 2
107251: PUSH
107252: LD_INT 1
107254: ARRAY
107255: NOT
107256: IFFALSE 107276
// result := Delete ( result , 1 ) ;
107258: LD_ADDR_VAR 0 2
107262: PUSH
107263: LD_VAR 0 2
107267: PPUSH
107268: LD_INT 1
107270: PPUSH
107271: CALL_OW 3
107275: ST_TO_ADDR
// end ; end_of_file end_of_file
107276: LD_VAR 0 2
107280: RET
// every 0 0$1 do
107281: GO 107283
107283: DISABLE
// begin enable ;
107284: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
107285: LD_STRING updateTimer(
107287: PUSH
107288: LD_OWVAR 1
107292: STR
107293: PUSH
107294: LD_STRING );
107296: STR
107297: PPUSH
107298: CALL_OW 559
// end ;
107302: END
// export function SOS_MapStart ( ) ; begin
107303: LD_INT 0
107305: PPUSH
// if streamModeActive then
107306: LD_EXP 141
107310: IFFALSE 107319
// DefineStreamItems ( true ) ;
107312: LD_INT 1
107314: PPUSH
107315: CALL 108973 0 1
// UpdateFactoryWaypoints ( ) ;
107319: CALL 121834 0 0
// UpdateWarehouseGatheringPoints ( ) ;
107323: CALL 122091 0 0
// end ;
107327: LD_VAR 0 1
107331: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107332: LD_INT 0
107334: PPUSH
// if p2 = 100 then
107335: LD_VAR 0 2
107339: PUSH
107340: LD_INT 100
107342: EQUAL
107343: IFFALSE 108346
// begin if not StreamModeActive then
107345: LD_EXP 141
107349: NOT
107350: IFFALSE 107360
// StreamModeActive := true ;
107352: LD_ADDR_EXP 141
107356: PUSH
107357: LD_INT 1
107359: ST_TO_ADDR
// if p3 = 0 then
107360: LD_VAR 0 3
107364: PUSH
107365: LD_INT 0
107367: EQUAL
107368: IFFALSE 107374
// InitStreamMode ;
107370: CALL 108509 0 0
// if p3 = 1 then
107374: LD_VAR 0 3
107378: PUSH
107379: LD_INT 1
107381: EQUAL
107382: IFFALSE 107392
// sRocket := true ;
107384: LD_ADDR_EXP 146
107388: PUSH
107389: LD_INT 1
107391: ST_TO_ADDR
// if p3 = 2 then
107392: LD_VAR 0 3
107396: PUSH
107397: LD_INT 2
107399: EQUAL
107400: IFFALSE 107410
// sSpeed := true ;
107402: LD_ADDR_EXP 145
107406: PUSH
107407: LD_INT 1
107409: ST_TO_ADDR
// if p3 = 3 then
107410: LD_VAR 0 3
107414: PUSH
107415: LD_INT 3
107417: EQUAL
107418: IFFALSE 107428
// sEngine := true ;
107420: LD_ADDR_EXP 147
107424: PUSH
107425: LD_INT 1
107427: ST_TO_ADDR
// if p3 = 4 then
107428: LD_VAR 0 3
107432: PUSH
107433: LD_INT 4
107435: EQUAL
107436: IFFALSE 107446
// sSpec := true ;
107438: LD_ADDR_EXP 144
107442: PUSH
107443: LD_INT 1
107445: ST_TO_ADDR
// if p3 = 5 then
107446: LD_VAR 0 3
107450: PUSH
107451: LD_INT 5
107453: EQUAL
107454: IFFALSE 107464
// sLevel := true ;
107456: LD_ADDR_EXP 148
107460: PUSH
107461: LD_INT 1
107463: ST_TO_ADDR
// if p3 = 6 then
107464: LD_VAR 0 3
107468: PUSH
107469: LD_INT 6
107471: EQUAL
107472: IFFALSE 107482
// sArmoury := true ;
107474: LD_ADDR_EXP 149
107478: PUSH
107479: LD_INT 1
107481: ST_TO_ADDR
// if p3 = 7 then
107482: LD_VAR 0 3
107486: PUSH
107487: LD_INT 7
107489: EQUAL
107490: IFFALSE 107500
// sRadar := true ;
107492: LD_ADDR_EXP 150
107496: PUSH
107497: LD_INT 1
107499: ST_TO_ADDR
// if p3 = 8 then
107500: LD_VAR 0 3
107504: PUSH
107505: LD_INT 8
107507: EQUAL
107508: IFFALSE 107518
// sBunker := true ;
107510: LD_ADDR_EXP 151
107514: PUSH
107515: LD_INT 1
107517: ST_TO_ADDR
// if p3 = 9 then
107518: LD_VAR 0 3
107522: PUSH
107523: LD_INT 9
107525: EQUAL
107526: IFFALSE 107536
// sHack := true ;
107528: LD_ADDR_EXP 152
107532: PUSH
107533: LD_INT 1
107535: ST_TO_ADDR
// if p3 = 10 then
107536: LD_VAR 0 3
107540: PUSH
107541: LD_INT 10
107543: EQUAL
107544: IFFALSE 107554
// sFire := true ;
107546: LD_ADDR_EXP 153
107550: PUSH
107551: LD_INT 1
107553: ST_TO_ADDR
// if p3 = 11 then
107554: LD_VAR 0 3
107558: PUSH
107559: LD_INT 11
107561: EQUAL
107562: IFFALSE 107572
// sRefresh := true ;
107564: LD_ADDR_EXP 154
107568: PUSH
107569: LD_INT 1
107571: ST_TO_ADDR
// if p3 = 12 then
107572: LD_VAR 0 3
107576: PUSH
107577: LD_INT 12
107579: EQUAL
107580: IFFALSE 107590
// sExp := true ;
107582: LD_ADDR_EXP 155
107586: PUSH
107587: LD_INT 1
107589: ST_TO_ADDR
// if p3 = 13 then
107590: LD_VAR 0 3
107594: PUSH
107595: LD_INT 13
107597: EQUAL
107598: IFFALSE 107608
// sDepot := true ;
107600: LD_ADDR_EXP 156
107604: PUSH
107605: LD_INT 1
107607: ST_TO_ADDR
// if p3 = 14 then
107608: LD_VAR 0 3
107612: PUSH
107613: LD_INT 14
107615: EQUAL
107616: IFFALSE 107626
// sFlag := true ;
107618: LD_ADDR_EXP 157
107622: PUSH
107623: LD_INT 1
107625: ST_TO_ADDR
// if p3 = 15 then
107626: LD_VAR 0 3
107630: PUSH
107631: LD_INT 15
107633: EQUAL
107634: IFFALSE 107644
// sKamikadze := true ;
107636: LD_ADDR_EXP 165
107640: PUSH
107641: LD_INT 1
107643: ST_TO_ADDR
// if p3 = 16 then
107644: LD_VAR 0 3
107648: PUSH
107649: LD_INT 16
107651: EQUAL
107652: IFFALSE 107662
// sTroll := true ;
107654: LD_ADDR_EXP 166
107658: PUSH
107659: LD_INT 1
107661: ST_TO_ADDR
// if p3 = 17 then
107662: LD_VAR 0 3
107666: PUSH
107667: LD_INT 17
107669: EQUAL
107670: IFFALSE 107680
// sSlow := true ;
107672: LD_ADDR_EXP 167
107676: PUSH
107677: LD_INT 1
107679: ST_TO_ADDR
// if p3 = 18 then
107680: LD_VAR 0 3
107684: PUSH
107685: LD_INT 18
107687: EQUAL
107688: IFFALSE 107698
// sLack := true ;
107690: LD_ADDR_EXP 168
107694: PUSH
107695: LD_INT 1
107697: ST_TO_ADDR
// if p3 = 19 then
107698: LD_VAR 0 3
107702: PUSH
107703: LD_INT 19
107705: EQUAL
107706: IFFALSE 107716
// sTank := true ;
107708: LD_ADDR_EXP 170
107712: PUSH
107713: LD_INT 1
107715: ST_TO_ADDR
// if p3 = 20 then
107716: LD_VAR 0 3
107720: PUSH
107721: LD_INT 20
107723: EQUAL
107724: IFFALSE 107734
// sRemote := true ;
107726: LD_ADDR_EXP 171
107730: PUSH
107731: LD_INT 1
107733: ST_TO_ADDR
// if p3 = 21 then
107734: LD_VAR 0 3
107738: PUSH
107739: LD_INT 21
107741: EQUAL
107742: IFFALSE 107752
// sPowell := true ;
107744: LD_ADDR_EXP 172
107748: PUSH
107749: LD_INT 1
107751: ST_TO_ADDR
// if p3 = 22 then
107752: LD_VAR 0 3
107756: PUSH
107757: LD_INT 22
107759: EQUAL
107760: IFFALSE 107770
// sTeleport := true ;
107762: LD_ADDR_EXP 175
107766: PUSH
107767: LD_INT 1
107769: ST_TO_ADDR
// if p3 = 23 then
107770: LD_VAR 0 3
107774: PUSH
107775: LD_INT 23
107777: EQUAL
107778: IFFALSE 107788
// sOilTower := true ;
107780: LD_ADDR_EXP 177
107784: PUSH
107785: LD_INT 1
107787: ST_TO_ADDR
// if p3 = 24 then
107788: LD_VAR 0 3
107792: PUSH
107793: LD_INT 24
107795: EQUAL
107796: IFFALSE 107806
// sShovel := true ;
107798: LD_ADDR_EXP 178
107802: PUSH
107803: LD_INT 1
107805: ST_TO_ADDR
// if p3 = 25 then
107806: LD_VAR 0 3
107810: PUSH
107811: LD_INT 25
107813: EQUAL
107814: IFFALSE 107824
// sSheik := true ;
107816: LD_ADDR_EXP 179
107820: PUSH
107821: LD_INT 1
107823: ST_TO_ADDR
// if p3 = 26 then
107824: LD_VAR 0 3
107828: PUSH
107829: LD_INT 26
107831: EQUAL
107832: IFFALSE 107842
// sEarthquake := true ;
107834: LD_ADDR_EXP 181
107838: PUSH
107839: LD_INT 1
107841: ST_TO_ADDR
// if p3 = 27 then
107842: LD_VAR 0 3
107846: PUSH
107847: LD_INT 27
107849: EQUAL
107850: IFFALSE 107860
// sAI := true ;
107852: LD_ADDR_EXP 182
107856: PUSH
107857: LD_INT 1
107859: ST_TO_ADDR
// if p3 = 28 then
107860: LD_VAR 0 3
107864: PUSH
107865: LD_INT 28
107867: EQUAL
107868: IFFALSE 107878
// sCargo := true ;
107870: LD_ADDR_EXP 185
107874: PUSH
107875: LD_INT 1
107877: ST_TO_ADDR
// if p3 = 29 then
107878: LD_VAR 0 3
107882: PUSH
107883: LD_INT 29
107885: EQUAL
107886: IFFALSE 107896
// sDLaser := true ;
107888: LD_ADDR_EXP 186
107892: PUSH
107893: LD_INT 1
107895: ST_TO_ADDR
// if p3 = 30 then
107896: LD_VAR 0 3
107900: PUSH
107901: LD_INT 30
107903: EQUAL
107904: IFFALSE 107914
// sExchange := true ;
107906: LD_ADDR_EXP 187
107910: PUSH
107911: LD_INT 1
107913: ST_TO_ADDR
// if p3 = 31 then
107914: LD_VAR 0 3
107918: PUSH
107919: LD_INT 31
107921: EQUAL
107922: IFFALSE 107932
// sFac := true ;
107924: LD_ADDR_EXP 188
107928: PUSH
107929: LD_INT 1
107931: ST_TO_ADDR
// if p3 = 32 then
107932: LD_VAR 0 3
107936: PUSH
107937: LD_INT 32
107939: EQUAL
107940: IFFALSE 107950
// sPower := true ;
107942: LD_ADDR_EXP 189
107946: PUSH
107947: LD_INT 1
107949: ST_TO_ADDR
// if p3 = 33 then
107950: LD_VAR 0 3
107954: PUSH
107955: LD_INT 33
107957: EQUAL
107958: IFFALSE 107968
// sRandom := true ;
107960: LD_ADDR_EXP 190
107964: PUSH
107965: LD_INT 1
107967: ST_TO_ADDR
// if p3 = 34 then
107968: LD_VAR 0 3
107972: PUSH
107973: LD_INT 34
107975: EQUAL
107976: IFFALSE 107986
// sShield := true ;
107978: LD_ADDR_EXP 191
107982: PUSH
107983: LD_INT 1
107985: ST_TO_ADDR
// if p3 = 35 then
107986: LD_VAR 0 3
107990: PUSH
107991: LD_INT 35
107993: EQUAL
107994: IFFALSE 108004
// sTime := true ;
107996: LD_ADDR_EXP 192
108000: PUSH
108001: LD_INT 1
108003: ST_TO_ADDR
// if p3 = 36 then
108004: LD_VAR 0 3
108008: PUSH
108009: LD_INT 36
108011: EQUAL
108012: IFFALSE 108022
// sTools := true ;
108014: LD_ADDR_EXP 193
108018: PUSH
108019: LD_INT 1
108021: ST_TO_ADDR
// if p3 = 101 then
108022: LD_VAR 0 3
108026: PUSH
108027: LD_INT 101
108029: EQUAL
108030: IFFALSE 108040
// sSold := true ;
108032: LD_ADDR_EXP 158
108036: PUSH
108037: LD_INT 1
108039: ST_TO_ADDR
// if p3 = 102 then
108040: LD_VAR 0 3
108044: PUSH
108045: LD_INT 102
108047: EQUAL
108048: IFFALSE 108058
// sDiff := true ;
108050: LD_ADDR_EXP 159
108054: PUSH
108055: LD_INT 1
108057: ST_TO_ADDR
// if p3 = 103 then
108058: LD_VAR 0 3
108062: PUSH
108063: LD_INT 103
108065: EQUAL
108066: IFFALSE 108076
// sFog := true ;
108068: LD_ADDR_EXP 162
108072: PUSH
108073: LD_INT 1
108075: ST_TO_ADDR
// if p3 = 104 then
108076: LD_VAR 0 3
108080: PUSH
108081: LD_INT 104
108083: EQUAL
108084: IFFALSE 108094
// sReset := true ;
108086: LD_ADDR_EXP 163
108090: PUSH
108091: LD_INT 1
108093: ST_TO_ADDR
// if p3 = 105 then
108094: LD_VAR 0 3
108098: PUSH
108099: LD_INT 105
108101: EQUAL
108102: IFFALSE 108112
// sSun := true ;
108104: LD_ADDR_EXP 164
108108: PUSH
108109: LD_INT 1
108111: ST_TO_ADDR
// if p3 = 106 then
108112: LD_VAR 0 3
108116: PUSH
108117: LD_INT 106
108119: EQUAL
108120: IFFALSE 108130
// sTiger := true ;
108122: LD_ADDR_EXP 160
108126: PUSH
108127: LD_INT 1
108129: ST_TO_ADDR
// if p3 = 107 then
108130: LD_VAR 0 3
108134: PUSH
108135: LD_INT 107
108137: EQUAL
108138: IFFALSE 108148
// sBomb := true ;
108140: LD_ADDR_EXP 161
108144: PUSH
108145: LD_INT 1
108147: ST_TO_ADDR
// if p3 = 108 then
108148: LD_VAR 0 3
108152: PUSH
108153: LD_INT 108
108155: EQUAL
108156: IFFALSE 108166
// sWound := true ;
108158: LD_ADDR_EXP 169
108162: PUSH
108163: LD_INT 1
108165: ST_TO_ADDR
// if p3 = 109 then
108166: LD_VAR 0 3
108170: PUSH
108171: LD_INT 109
108173: EQUAL
108174: IFFALSE 108184
// sBetray := true ;
108176: LD_ADDR_EXP 173
108180: PUSH
108181: LD_INT 1
108183: ST_TO_ADDR
// if p3 = 110 then
108184: LD_VAR 0 3
108188: PUSH
108189: LD_INT 110
108191: EQUAL
108192: IFFALSE 108202
// sContamin := true ;
108194: LD_ADDR_EXP 174
108198: PUSH
108199: LD_INT 1
108201: ST_TO_ADDR
// if p3 = 111 then
108202: LD_VAR 0 3
108206: PUSH
108207: LD_INT 111
108209: EQUAL
108210: IFFALSE 108220
// sOil := true ;
108212: LD_ADDR_EXP 176
108216: PUSH
108217: LD_INT 1
108219: ST_TO_ADDR
// if p3 = 112 then
108220: LD_VAR 0 3
108224: PUSH
108225: LD_INT 112
108227: EQUAL
108228: IFFALSE 108238
// sStu := true ;
108230: LD_ADDR_EXP 180
108234: PUSH
108235: LD_INT 1
108237: ST_TO_ADDR
// if p3 = 113 then
108238: LD_VAR 0 3
108242: PUSH
108243: LD_INT 113
108245: EQUAL
108246: IFFALSE 108256
// sBazooka := true ;
108248: LD_ADDR_EXP 183
108252: PUSH
108253: LD_INT 1
108255: ST_TO_ADDR
// if p3 = 114 then
108256: LD_VAR 0 3
108260: PUSH
108261: LD_INT 114
108263: EQUAL
108264: IFFALSE 108274
// sMortar := true ;
108266: LD_ADDR_EXP 184
108270: PUSH
108271: LD_INT 1
108273: ST_TO_ADDR
// if p3 = 115 then
108274: LD_VAR 0 3
108278: PUSH
108279: LD_INT 115
108281: EQUAL
108282: IFFALSE 108292
// sRanger := true ;
108284: LD_ADDR_EXP 194
108288: PUSH
108289: LD_INT 1
108291: ST_TO_ADDR
// if p3 = 116 then
108292: LD_VAR 0 3
108296: PUSH
108297: LD_INT 116
108299: EQUAL
108300: IFFALSE 108310
// sComputer := true ;
108302: LD_ADDR_EXP 195
108306: PUSH
108307: LD_INT 1
108309: ST_TO_ADDR
// if p3 = 117 then
108310: LD_VAR 0 3
108314: PUSH
108315: LD_INT 117
108317: EQUAL
108318: IFFALSE 108328
// s30 := true ;
108320: LD_ADDR_EXP 196
108324: PUSH
108325: LD_INT 1
108327: ST_TO_ADDR
// if p3 = 118 then
108328: LD_VAR 0 3
108332: PUSH
108333: LD_INT 118
108335: EQUAL
108336: IFFALSE 108346
// s60 := true ;
108338: LD_ADDR_EXP 197
108342: PUSH
108343: LD_INT 1
108345: ST_TO_ADDR
// end ; if p2 = 101 then
108346: LD_VAR 0 2
108350: PUSH
108351: LD_INT 101
108353: EQUAL
108354: IFFALSE 108482
// begin case p3 of 1 :
108356: LD_VAR 0 3
108360: PUSH
108361: LD_INT 1
108363: DOUBLE
108364: EQUAL
108365: IFTRUE 108369
108367: GO 108376
108369: POP
// hHackUnlimitedResources ; 2 :
108370: CALL 120580 0 0
108374: GO 108482
108376: LD_INT 2
108378: DOUBLE
108379: EQUAL
108380: IFTRUE 108384
108382: GO 108391
108384: POP
// hHackSetLevel10 ; 3 :
108385: CALL 120713 0 0
108389: GO 108482
108391: LD_INT 3
108393: DOUBLE
108394: EQUAL
108395: IFTRUE 108399
108397: GO 108406
108399: POP
// hHackSetLevel10YourUnits ; 4 :
108400: CALL 120798 0 0
108404: GO 108482
108406: LD_INT 4
108408: DOUBLE
108409: EQUAL
108410: IFTRUE 108414
108412: GO 108421
108414: POP
// hHackInvincible ; 5 :
108415: CALL 121246 0 0
108419: GO 108482
108421: LD_INT 5
108423: DOUBLE
108424: EQUAL
108425: IFTRUE 108429
108427: GO 108436
108429: POP
// hHackInvisible ; 6 :
108430: CALL 121357 0 0
108434: GO 108482
108436: LD_INT 6
108438: DOUBLE
108439: EQUAL
108440: IFTRUE 108444
108442: GO 108451
108444: POP
// hHackChangeYourSide ; 7 :
108445: CALL 121414 0 0
108449: GO 108482
108451: LD_INT 7
108453: DOUBLE
108454: EQUAL
108455: IFTRUE 108459
108457: GO 108466
108459: POP
// hHackChangeUnitSide ; 8 :
108460: CALL 121456 0 0
108464: GO 108482
108466: LD_INT 8
108468: DOUBLE
108469: EQUAL
108470: IFTRUE 108474
108472: GO 108481
108474: POP
// hHackFog ; end ;
108475: CALL 121557 0 0
108479: GO 108482
108481: POP
// end ; end ;
108482: LD_VAR 0 7
108486: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
108487: GO 108489
108489: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108490: LD_STRING initStreamRollete();
108492: PPUSH
108493: CALL_OW 559
// InitStreamMode ;
108497: CALL 108509 0 0
// DefineStreamItems ( false ) ;
108501: LD_INT 0
108503: PPUSH
108504: CALL 108973 0 1
// end ;
108508: END
// function InitStreamMode ; begin
108509: LD_INT 0
108511: PPUSH
// streamModeActive := false ;
108512: LD_ADDR_EXP 141
108516: PUSH
108517: LD_INT 0
108519: ST_TO_ADDR
// normalCounter := 36 ;
108520: LD_ADDR_EXP 142
108524: PUSH
108525: LD_INT 36
108527: ST_TO_ADDR
// hardcoreCounter := 18 ;
108528: LD_ADDR_EXP 143
108532: PUSH
108533: LD_INT 18
108535: ST_TO_ADDR
// sRocket := false ;
108536: LD_ADDR_EXP 146
108540: PUSH
108541: LD_INT 0
108543: ST_TO_ADDR
// sSpeed := false ;
108544: LD_ADDR_EXP 145
108548: PUSH
108549: LD_INT 0
108551: ST_TO_ADDR
// sEngine := false ;
108552: LD_ADDR_EXP 147
108556: PUSH
108557: LD_INT 0
108559: ST_TO_ADDR
// sSpec := false ;
108560: LD_ADDR_EXP 144
108564: PUSH
108565: LD_INT 0
108567: ST_TO_ADDR
// sLevel := false ;
108568: LD_ADDR_EXP 148
108572: PUSH
108573: LD_INT 0
108575: ST_TO_ADDR
// sArmoury := false ;
108576: LD_ADDR_EXP 149
108580: PUSH
108581: LD_INT 0
108583: ST_TO_ADDR
// sRadar := false ;
108584: LD_ADDR_EXP 150
108588: PUSH
108589: LD_INT 0
108591: ST_TO_ADDR
// sBunker := false ;
108592: LD_ADDR_EXP 151
108596: PUSH
108597: LD_INT 0
108599: ST_TO_ADDR
// sHack := false ;
108600: LD_ADDR_EXP 152
108604: PUSH
108605: LD_INT 0
108607: ST_TO_ADDR
// sFire := false ;
108608: LD_ADDR_EXP 153
108612: PUSH
108613: LD_INT 0
108615: ST_TO_ADDR
// sRefresh := false ;
108616: LD_ADDR_EXP 154
108620: PUSH
108621: LD_INT 0
108623: ST_TO_ADDR
// sExp := false ;
108624: LD_ADDR_EXP 155
108628: PUSH
108629: LD_INT 0
108631: ST_TO_ADDR
// sDepot := false ;
108632: LD_ADDR_EXP 156
108636: PUSH
108637: LD_INT 0
108639: ST_TO_ADDR
// sFlag := false ;
108640: LD_ADDR_EXP 157
108644: PUSH
108645: LD_INT 0
108647: ST_TO_ADDR
// sKamikadze := false ;
108648: LD_ADDR_EXP 165
108652: PUSH
108653: LD_INT 0
108655: ST_TO_ADDR
// sTroll := false ;
108656: LD_ADDR_EXP 166
108660: PUSH
108661: LD_INT 0
108663: ST_TO_ADDR
// sSlow := false ;
108664: LD_ADDR_EXP 167
108668: PUSH
108669: LD_INT 0
108671: ST_TO_ADDR
// sLack := false ;
108672: LD_ADDR_EXP 168
108676: PUSH
108677: LD_INT 0
108679: ST_TO_ADDR
// sTank := false ;
108680: LD_ADDR_EXP 170
108684: PUSH
108685: LD_INT 0
108687: ST_TO_ADDR
// sRemote := false ;
108688: LD_ADDR_EXP 171
108692: PUSH
108693: LD_INT 0
108695: ST_TO_ADDR
// sPowell := false ;
108696: LD_ADDR_EXP 172
108700: PUSH
108701: LD_INT 0
108703: ST_TO_ADDR
// sTeleport := false ;
108704: LD_ADDR_EXP 175
108708: PUSH
108709: LD_INT 0
108711: ST_TO_ADDR
// sOilTower := false ;
108712: LD_ADDR_EXP 177
108716: PUSH
108717: LD_INT 0
108719: ST_TO_ADDR
// sShovel := false ;
108720: LD_ADDR_EXP 178
108724: PUSH
108725: LD_INT 0
108727: ST_TO_ADDR
// sSheik := false ;
108728: LD_ADDR_EXP 179
108732: PUSH
108733: LD_INT 0
108735: ST_TO_ADDR
// sEarthquake := false ;
108736: LD_ADDR_EXP 181
108740: PUSH
108741: LD_INT 0
108743: ST_TO_ADDR
// sAI := false ;
108744: LD_ADDR_EXP 182
108748: PUSH
108749: LD_INT 0
108751: ST_TO_ADDR
// sCargo := false ;
108752: LD_ADDR_EXP 185
108756: PUSH
108757: LD_INT 0
108759: ST_TO_ADDR
// sDLaser := false ;
108760: LD_ADDR_EXP 186
108764: PUSH
108765: LD_INT 0
108767: ST_TO_ADDR
// sExchange := false ;
108768: LD_ADDR_EXP 187
108772: PUSH
108773: LD_INT 0
108775: ST_TO_ADDR
// sFac := false ;
108776: LD_ADDR_EXP 188
108780: PUSH
108781: LD_INT 0
108783: ST_TO_ADDR
// sPower := false ;
108784: LD_ADDR_EXP 189
108788: PUSH
108789: LD_INT 0
108791: ST_TO_ADDR
// sRandom := false ;
108792: LD_ADDR_EXP 190
108796: PUSH
108797: LD_INT 0
108799: ST_TO_ADDR
// sShield := false ;
108800: LD_ADDR_EXP 191
108804: PUSH
108805: LD_INT 0
108807: ST_TO_ADDR
// sTime := false ;
108808: LD_ADDR_EXP 192
108812: PUSH
108813: LD_INT 0
108815: ST_TO_ADDR
// sTools := false ;
108816: LD_ADDR_EXP 193
108820: PUSH
108821: LD_INT 0
108823: ST_TO_ADDR
// sSold := false ;
108824: LD_ADDR_EXP 158
108828: PUSH
108829: LD_INT 0
108831: ST_TO_ADDR
// sDiff := false ;
108832: LD_ADDR_EXP 159
108836: PUSH
108837: LD_INT 0
108839: ST_TO_ADDR
// sFog := false ;
108840: LD_ADDR_EXP 162
108844: PUSH
108845: LD_INT 0
108847: ST_TO_ADDR
// sReset := false ;
108848: LD_ADDR_EXP 163
108852: PUSH
108853: LD_INT 0
108855: ST_TO_ADDR
// sSun := false ;
108856: LD_ADDR_EXP 164
108860: PUSH
108861: LD_INT 0
108863: ST_TO_ADDR
// sTiger := false ;
108864: LD_ADDR_EXP 160
108868: PUSH
108869: LD_INT 0
108871: ST_TO_ADDR
// sBomb := false ;
108872: LD_ADDR_EXP 161
108876: PUSH
108877: LD_INT 0
108879: ST_TO_ADDR
// sWound := false ;
108880: LD_ADDR_EXP 169
108884: PUSH
108885: LD_INT 0
108887: ST_TO_ADDR
// sBetray := false ;
108888: LD_ADDR_EXP 173
108892: PUSH
108893: LD_INT 0
108895: ST_TO_ADDR
// sContamin := false ;
108896: LD_ADDR_EXP 174
108900: PUSH
108901: LD_INT 0
108903: ST_TO_ADDR
// sOil := false ;
108904: LD_ADDR_EXP 176
108908: PUSH
108909: LD_INT 0
108911: ST_TO_ADDR
// sStu := false ;
108912: LD_ADDR_EXP 180
108916: PUSH
108917: LD_INT 0
108919: ST_TO_ADDR
// sBazooka := false ;
108920: LD_ADDR_EXP 183
108924: PUSH
108925: LD_INT 0
108927: ST_TO_ADDR
// sMortar := false ;
108928: LD_ADDR_EXP 184
108932: PUSH
108933: LD_INT 0
108935: ST_TO_ADDR
// sRanger := false ;
108936: LD_ADDR_EXP 194
108940: PUSH
108941: LD_INT 0
108943: ST_TO_ADDR
// sComputer := false ;
108944: LD_ADDR_EXP 195
108948: PUSH
108949: LD_INT 0
108951: ST_TO_ADDR
// s30 := false ;
108952: LD_ADDR_EXP 196
108956: PUSH
108957: LD_INT 0
108959: ST_TO_ADDR
// s60 := false ;
108960: LD_ADDR_EXP 197
108964: PUSH
108965: LD_INT 0
108967: ST_TO_ADDR
// end ;
108968: LD_VAR 0 1
108972: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
108973: LD_INT 0
108975: PPUSH
108976: PPUSH
108977: PPUSH
108978: PPUSH
108979: PPUSH
108980: PPUSH
108981: PPUSH
// result := [ ] ;
108982: LD_ADDR_VAR 0 2
108986: PUSH
108987: EMPTY
108988: ST_TO_ADDR
// if campaign_id = 1 then
108989: LD_OWVAR 69
108993: PUSH
108994: LD_INT 1
108996: EQUAL
108997: IFFALSE 112163
// begin case mission_number of 1 :
108999: LD_OWVAR 70
109003: PUSH
109004: LD_INT 1
109006: DOUBLE
109007: EQUAL
109008: IFTRUE 109012
109010: GO 109088
109012: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
109013: LD_ADDR_VAR 0 2
109017: PUSH
109018: LD_INT 2
109020: PUSH
109021: LD_INT 4
109023: PUSH
109024: LD_INT 11
109026: PUSH
109027: LD_INT 12
109029: PUSH
109030: LD_INT 15
109032: PUSH
109033: LD_INT 16
109035: PUSH
109036: LD_INT 22
109038: PUSH
109039: LD_INT 23
109041: PUSH
109042: LD_INT 26
109044: PUSH
109045: EMPTY
109046: LIST
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: PUSH
109056: LD_INT 101
109058: PUSH
109059: LD_INT 102
109061: PUSH
109062: LD_INT 106
109064: PUSH
109065: LD_INT 116
109067: PUSH
109068: LD_INT 117
109070: PUSH
109071: LD_INT 118
109073: PUSH
109074: EMPTY
109075: LIST
109076: LIST
109077: LIST
109078: LIST
109079: LIST
109080: LIST
109081: PUSH
109082: EMPTY
109083: LIST
109084: LIST
109085: ST_TO_ADDR
109086: GO 112161
109088: LD_INT 2
109090: DOUBLE
109091: EQUAL
109092: IFTRUE 109096
109094: GO 109180
109096: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
109097: LD_ADDR_VAR 0 2
109101: PUSH
109102: LD_INT 2
109104: PUSH
109105: LD_INT 4
109107: PUSH
109108: LD_INT 11
109110: PUSH
109111: LD_INT 12
109113: PUSH
109114: LD_INT 15
109116: PUSH
109117: LD_INT 16
109119: PUSH
109120: LD_INT 22
109122: PUSH
109123: LD_INT 23
109125: PUSH
109126: LD_INT 26
109128: PUSH
109129: EMPTY
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: LIST
109135: LIST
109136: LIST
109137: LIST
109138: LIST
109139: PUSH
109140: LD_INT 101
109142: PUSH
109143: LD_INT 102
109145: PUSH
109146: LD_INT 105
109148: PUSH
109149: LD_INT 106
109151: PUSH
109152: LD_INT 108
109154: PUSH
109155: LD_INT 116
109157: PUSH
109158: LD_INT 117
109160: PUSH
109161: LD_INT 118
109163: PUSH
109164: EMPTY
109165: LIST
109166: LIST
109167: LIST
109168: LIST
109169: LIST
109170: LIST
109171: LIST
109172: LIST
109173: PUSH
109174: EMPTY
109175: LIST
109176: LIST
109177: ST_TO_ADDR
109178: GO 112161
109180: LD_INT 3
109182: DOUBLE
109183: EQUAL
109184: IFTRUE 109188
109186: GO 109276
109188: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
109189: LD_ADDR_VAR 0 2
109193: PUSH
109194: LD_INT 2
109196: PUSH
109197: LD_INT 4
109199: PUSH
109200: LD_INT 5
109202: PUSH
109203: LD_INT 11
109205: PUSH
109206: LD_INT 12
109208: PUSH
109209: LD_INT 15
109211: PUSH
109212: LD_INT 16
109214: PUSH
109215: LD_INT 22
109217: PUSH
109218: LD_INT 26
109220: PUSH
109221: LD_INT 36
109223: PUSH
109224: EMPTY
109225: LIST
109226: LIST
109227: LIST
109228: LIST
109229: LIST
109230: LIST
109231: LIST
109232: LIST
109233: LIST
109234: LIST
109235: PUSH
109236: LD_INT 101
109238: PUSH
109239: LD_INT 102
109241: PUSH
109242: LD_INT 105
109244: PUSH
109245: LD_INT 106
109247: PUSH
109248: LD_INT 108
109250: PUSH
109251: LD_INT 116
109253: PUSH
109254: LD_INT 117
109256: PUSH
109257: LD_INT 118
109259: PUSH
109260: EMPTY
109261: LIST
109262: LIST
109263: LIST
109264: LIST
109265: LIST
109266: LIST
109267: LIST
109268: LIST
109269: PUSH
109270: EMPTY
109271: LIST
109272: LIST
109273: ST_TO_ADDR
109274: GO 112161
109276: LD_INT 4
109278: DOUBLE
109279: EQUAL
109280: IFTRUE 109284
109282: GO 109380
109284: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
109285: LD_ADDR_VAR 0 2
109289: PUSH
109290: LD_INT 2
109292: PUSH
109293: LD_INT 4
109295: PUSH
109296: LD_INT 5
109298: PUSH
109299: LD_INT 8
109301: PUSH
109302: LD_INT 11
109304: PUSH
109305: LD_INT 12
109307: PUSH
109308: LD_INT 15
109310: PUSH
109311: LD_INT 16
109313: PUSH
109314: LD_INT 22
109316: PUSH
109317: LD_INT 23
109319: PUSH
109320: LD_INT 26
109322: PUSH
109323: LD_INT 36
109325: PUSH
109326: EMPTY
109327: LIST
109328: LIST
109329: LIST
109330: LIST
109331: LIST
109332: LIST
109333: LIST
109334: LIST
109335: LIST
109336: LIST
109337: LIST
109338: LIST
109339: PUSH
109340: LD_INT 101
109342: PUSH
109343: LD_INT 102
109345: PUSH
109346: LD_INT 105
109348: PUSH
109349: LD_INT 106
109351: PUSH
109352: LD_INT 108
109354: PUSH
109355: LD_INT 116
109357: PUSH
109358: LD_INT 117
109360: PUSH
109361: LD_INT 118
109363: PUSH
109364: EMPTY
109365: LIST
109366: LIST
109367: LIST
109368: LIST
109369: LIST
109370: LIST
109371: LIST
109372: LIST
109373: PUSH
109374: EMPTY
109375: LIST
109376: LIST
109377: ST_TO_ADDR
109378: GO 112161
109380: LD_INT 5
109382: DOUBLE
109383: EQUAL
109384: IFTRUE 109388
109386: GO 109500
109388: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
109389: LD_ADDR_VAR 0 2
109393: PUSH
109394: LD_INT 2
109396: PUSH
109397: LD_INT 4
109399: PUSH
109400: LD_INT 5
109402: PUSH
109403: LD_INT 6
109405: PUSH
109406: LD_INT 8
109408: PUSH
109409: LD_INT 11
109411: PUSH
109412: LD_INT 12
109414: PUSH
109415: LD_INT 15
109417: PUSH
109418: LD_INT 16
109420: PUSH
109421: LD_INT 22
109423: PUSH
109424: LD_INT 23
109426: PUSH
109427: LD_INT 25
109429: PUSH
109430: LD_INT 26
109432: PUSH
109433: LD_INT 36
109435: PUSH
109436: EMPTY
109437: LIST
109438: LIST
109439: LIST
109440: LIST
109441: LIST
109442: LIST
109443: LIST
109444: LIST
109445: LIST
109446: LIST
109447: LIST
109448: LIST
109449: LIST
109450: LIST
109451: PUSH
109452: LD_INT 101
109454: PUSH
109455: LD_INT 102
109457: PUSH
109458: LD_INT 105
109460: PUSH
109461: LD_INT 106
109463: PUSH
109464: LD_INT 108
109466: PUSH
109467: LD_INT 109
109469: PUSH
109470: LD_INT 112
109472: PUSH
109473: LD_INT 116
109475: PUSH
109476: LD_INT 117
109478: PUSH
109479: LD_INT 118
109481: PUSH
109482: EMPTY
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: LIST
109492: LIST
109493: PUSH
109494: EMPTY
109495: LIST
109496: LIST
109497: ST_TO_ADDR
109498: GO 112161
109500: LD_INT 6
109502: DOUBLE
109503: EQUAL
109504: IFTRUE 109508
109506: GO 109640
109508: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
109509: LD_ADDR_VAR 0 2
109513: PUSH
109514: LD_INT 2
109516: PUSH
109517: LD_INT 4
109519: PUSH
109520: LD_INT 5
109522: PUSH
109523: LD_INT 6
109525: PUSH
109526: LD_INT 8
109528: PUSH
109529: LD_INT 11
109531: PUSH
109532: LD_INT 12
109534: PUSH
109535: LD_INT 15
109537: PUSH
109538: LD_INT 16
109540: PUSH
109541: LD_INT 20
109543: PUSH
109544: LD_INT 21
109546: PUSH
109547: LD_INT 22
109549: PUSH
109550: LD_INT 23
109552: PUSH
109553: LD_INT 25
109555: PUSH
109556: LD_INT 26
109558: PUSH
109559: LD_INT 30
109561: PUSH
109562: LD_INT 31
109564: PUSH
109565: LD_INT 32
109567: PUSH
109568: LD_INT 36
109570: PUSH
109571: EMPTY
109572: LIST
109573: LIST
109574: LIST
109575: LIST
109576: LIST
109577: LIST
109578: LIST
109579: LIST
109580: LIST
109581: LIST
109582: LIST
109583: LIST
109584: LIST
109585: LIST
109586: LIST
109587: LIST
109588: LIST
109589: LIST
109590: LIST
109591: PUSH
109592: LD_INT 101
109594: PUSH
109595: LD_INT 102
109597: PUSH
109598: LD_INT 105
109600: PUSH
109601: LD_INT 106
109603: PUSH
109604: LD_INT 108
109606: PUSH
109607: LD_INT 109
109609: PUSH
109610: LD_INT 112
109612: PUSH
109613: LD_INT 116
109615: PUSH
109616: LD_INT 117
109618: PUSH
109619: LD_INT 118
109621: PUSH
109622: EMPTY
109623: LIST
109624: LIST
109625: LIST
109626: LIST
109627: LIST
109628: LIST
109629: LIST
109630: LIST
109631: LIST
109632: LIST
109633: PUSH
109634: EMPTY
109635: LIST
109636: LIST
109637: ST_TO_ADDR
109638: GO 112161
109640: LD_INT 7
109642: DOUBLE
109643: EQUAL
109644: IFTRUE 109648
109646: GO 109760
109648: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
109649: LD_ADDR_VAR 0 2
109653: PUSH
109654: LD_INT 2
109656: PUSH
109657: LD_INT 4
109659: PUSH
109660: LD_INT 5
109662: PUSH
109663: LD_INT 7
109665: PUSH
109666: LD_INT 11
109668: PUSH
109669: LD_INT 12
109671: PUSH
109672: LD_INT 15
109674: PUSH
109675: LD_INT 16
109677: PUSH
109678: LD_INT 20
109680: PUSH
109681: LD_INT 21
109683: PUSH
109684: LD_INT 22
109686: PUSH
109687: LD_INT 23
109689: PUSH
109690: LD_INT 25
109692: PUSH
109693: LD_INT 26
109695: PUSH
109696: EMPTY
109697: LIST
109698: LIST
109699: LIST
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: LIST
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: PUSH
109712: LD_INT 101
109714: PUSH
109715: LD_INT 102
109717: PUSH
109718: LD_INT 103
109720: PUSH
109721: LD_INT 105
109723: PUSH
109724: LD_INT 106
109726: PUSH
109727: LD_INT 108
109729: PUSH
109730: LD_INT 112
109732: PUSH
109733: LD_INT 116
109735: PUSH
109736: LD_INT 117
109738: PUSH
109739: LD_INT 118
109741: PUSH
109742: EMPTY
109743: LIST
109744: LIST
109745: LIST
109746: LIST
109747: LIST
109748: LIST
109749: LIST
109750: LIST
109751: LIST
109752: LIST
109753: PUSH
109754: EMPTY
109755: LIST
109756: LIST
109757: ST_TO_ADDR
109758: GO 112161
109760: LD_INT 8
109762: DOUBLE
109763: EQUAL
109764: IFTRUE 109768
109766: GO 109908
109768: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
109769: LD_ADDR_VAR 0 2
109773: PUSH
109774: LD_INT 2
109776: PUSH
109777: LD_INT 4
109779: PUSH
109780: LD_INT 5
109782: PUSH
109783: LD_INT 6
109785: PUSH
109786: LD_INT 7
109788: PUSH
109789: LD_INT 8
109791: PUSH
109792: LD_INT 11
109794: PUSH
109795: LD_INT 12
109797: PUSH
109798: LD_INT 15
109800: PUSH
109801: LD_INT 16
109803: PUSH
109804: LD_INT 20
109806: PUSH
109807: LD_INT 21
109809: PUSH
109810: LD_INT 22
109812: PUSH
109813: LD_INT 23
109815: PUSH
109816: LD_INT 25
109818: PUSH
109819: LD_INT 26
109821: PUSH
109822: LD_INT 30
109824: PUSH
109825: LD_INT 31
109827: PUSH
109828: LD_INT 32
109830: PUSH
109831: LD_INT 36
109833: PUSH
109834: EMPTY
109835: LIST
109836: LIST
109837: LIST
109838: LIST
109839: LIST
109840: LIST
109841: LIST
109842: LIST
109843: LIST
109844: LIST
109845: LIST
109846: LIST
109847: LIST
109848: LIST
109849: LIST
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: PUSH
109856: LD_INT 101
109858: PUSH
109859: LD_INT 102
109861: PUSH
109862: LD_INT 103
109864: PUSH
109865: LD_INT 105
109867: PUSH
109868: LD_INT 106
109870: PUSH
109871: LD_INT 108
109873: PUSH
109874: LD_INT 109
109876: PUSH
109877: LD_INT 112
109879: PUSH
109880: LD_INT 116
109882: PUSH
109883: LD_INT 117
109885: PUSH
109886: LD_INT 118
109888: PUSH
109889: EMPTY
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: LIST
109898: LIST
109899: LIST
109900: LIST
109901: PUSH
109902: EMPTY
109903: LIST
109904: LIST
109905: ST_TO_ADDR
109906: GO 112161
109908: LD_INT 9
109910: DOUBLE
109911: EQUAL
109912: IFTRUE 109916
109914: GO 110064
109916: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
109917: LD_ADDR_VAR 0 2
109921: PUSH
109922: LD_INT 2
109924: PUSH
109925: LD_INT 4
109927: PUSH
109928: LD_INT 5
109930: PUSH
109931: LD_INT 6
109933: PUSH
109934: LD_INT 7
109936: PUSH
109937: LD_INT 8
109939: PUSH
109940: LD_INT 11
109942: PUSH
109943: LD_INT 12
109945: PUSH
109946: LD_INT 15
109948: PUSH
109949: LD_INT 16
109951: PUSH
109952: LD_INT 20
109954: PUSH
109955: LD_INT 21
109957: PUSH
109958: LD_INT 22
109960: PUSH
109961: LD_INT 23
109963: PUSH
109964: LD_INT 25
109966: PUSH
109967: LD_INT 26
109969: PUSH
109970: LD_INT 28
109972: PUSH
109973: LD_INT 30
109975: PUSH
109976: LD_INT 31
109978: PUSH
109979: LD_INT 32
109981: PUSH
109982: LD_INT 36
109984: PUSH
109985: EMPTY
109986: LIST
109987: LIST
109988: LIST
109989: LIST
109990: LIST
109991: LIST
109992: LIST
109993: LIST
109994: LIST
109995: LIST
109996: LIST
109997: LIST
109998: LIST
109999: LIST
110000: LIST
110001: LIST
110002: LIST
110003: LIST
110004: LIST
110005: LIST
110006: LIST
110007: PUSH
110008: LD_INT 101
110010: PUSH
110011: LD_INT 102
110013: PUSH
110014: LD_INT 103
110016: PUSH
110017: LD_INT 105
110019: PUSH
110020: LD_INT 106
110022: PUSH
110023: LD_INT 108
110025: PUSH
110026: LD_INT 109
110028: PUSH
110029: LD_INT 112
110031: PUSH
110032: LD_INT 114
110034: PUSH
110035: LD_INT 116
110037: PUSH
110038: LD_INT 117
110040: PUSH
110041: LD_INT 118
110043: PUSH
110044: EMPTY
110045: LIST
110046: LIST
110047: LIST
110048: LIST
110049: LIST
110050: LIST
110051: LIST
110052: LIST
110053: LIST
110054: LIST
110055: LIST
110056: LIST
110057: PUSH
110058: EMPTY
110059: LIST
110060: LIST
110061: ST_TO_ADDR
110062: GO 112161
110064: LD_INT 10
110066: DOUBLE
110067: EQUAL
110068: IFTRUE 110072
110070: GO 110268
110072: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
110073: LD_ADDR_VAR 0 2
110077: PUSH
110078: LD_INT 2
110080: PUSH
110081: LD_INT 4
110083: PUSH
110084: LD_INT 5
110086: PUSH
110087: LD_INT 6
110089: PUSH
110090: LD_INT 7
110092: PUSH
110093: LD_INT 8
110095: PUSH
110096: LD_INT 9
110098: PUSH
110099: LD_INT 10
110101: PUSH
110102: LD_INT 11
110104: PUSH
110105: LD_INT 12
110107: PUSH
110108: LD_INT 13
110110: PUSH
110111: LD_INT 14
110113: PUSH
110114: LD_INT 15
110116: PUSH
110117: LD_INT 16
110119: PUSH
110120: LD_INT 17
110122: PUSH
110123: LD_INT 18
110125: PUSH
110126: LD_INT 19
110128: PUSH
110129: LD_INT 20
110131: PUSH
110132: LD_INT 21
110134: PUSH
110135: LD_INT 22
110137: PUSH
110138: LD_INT 23
110140: PUSH
110141: LD_INT 24
110143: PUSH
110144: LD_INT 25
110146: PUSH
110147: LD_INT 26
110149: PUSH
110150: LD_INT 28
110152: PUSH
110153: LD_INT 30
110155: PUSH
110156: LD_INT 31
110158: PUSH
110159: LD_INT 32
110161: PUSH
110162: LD_INT 36
110164: PUSH
110165: EMPTY
110166: LIST
110167: LIST
110168: LIST
110169: LIST
110170: LIST
110171: LIST
110172: LIST
110173: LIST
110174: LIST
110175: LIST
110176: LIST
110177: LIST
110178: LIST
110179: LIST
110180: LIST
110181: LIST
110182: LIST
110183: LIST
110184: LIST
110185: LIST
110186: LIST
110187: LIST
110188: LIST
110189: LIST
110190: LIST
110191: LIST
110192: LIST
110193: LIST
110194: LIST
110195: PUSH
110196: LD_INT 101
110198: PUSH
110199: LD_INT 102
110201: PUSH
110202: LD_INT 103
110204: PUSH
110205: LD_INT 104
110207: PUSH
110208: LD_INT 105
110210: PUSH
110211: LD_INT 106
110213: PUSH
110214: LD_INT 107
110216: PUSH
110217: LD_INT 108
110219: PUSH
110220: LD_INT 109
110222: PUSH
110223: LD_INT 110
110225: PUSH
110226: LD_INT 111
110228: PUSH
110229: LD_INT 112
110231: PUSH
110232: LD_INT 114
110234: PUSH
110235: LD_INT 116
110237: PUSH
110238: LD_INT 117
110240: PUSH
110241: LD_INT 118
110243: PUSH
110244: EMPTY
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: LIST
110254: LIST
110255: LIST
110256: LIST
110257: LIST
110258: LIST
110259: LIST
110260: LIST
110261: PUSH
110262: EMPTY
110263: LIST
110264: LIST
110265: ST_TO_ADDR
110266: GO 112161
110268: LD_INT 11
110270: DOUBLE
110271: EQUAL
110272: IFTRUE 110276
110274: GO 110480
110276: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
110277: LD_ADDR_VAR 0 2
110281: PUSH
110282: LD_INT 2
110284: PUSH
110285: LD_INT 3
110287: PUSH
110288: LD_INT 4
110290: PUSH
110291: LD_INT 5
110293: PUSH
110294: LD_INT 6
110296: PUSH
110297: LD_INT 7
110299: PUSH
110300: LD_INT 8
110302: PUSH
110303: LD_INT 9
110305: PUSH
110306: LD_INT 10
110308: PUSH
110309: LD_INT 11
110311: PUSH
110312: LD_INT 12
110314: PUSH
110315: LD_INT 13
110317: PUSH
110318: LD_INT 14
110320: PUSH
110321: LD_INT 15
110323: PUSH
110324: LD_INT 16
110326: PUSH
110327: LD_INT 17
110329: PUSH
110330: LD_INT 18
110332: PUSH
110333: LD_INT 19
110335: PUSH
110336: LD_INT 20
110338: PUSH
110339: LD_INT 21
110341: PUSH
110342: LD_INT 22
110344: PUSH
110345: LD_INT 23
110347: PUSH
110348: LD_INT 24
110350: PUSH
110351: LD_INT 25
110353: PUSH
110354: LD_INT 26
110356: PUSH
110357: LD_INT 28
110359: PUSH
110360: LD_INT 30
110362: PUSH
110363: LD_INT 31
110365: PUSH
110366: LD_INT 32
110368: PUSH
110369: LD_INT 34
110371: PUSH
110372: LD_INT 36
110374: PUSH
110375: EMPTY
110376: LIST
110377: LIST
110378: LIST
110379: LIST
110380: LIST
110381: LIST
110382: LIST
110383: LIST
110384: LIST
110385: LIST
110386: LIST
110387: LIST
110388: LIST
110389: LIST
110390: LIST
110391: LIST
110392: LIST
110393: LIST
110394: LIST
110395: LIST
110396: LIST
110397: LIST
110398: LIST
110399: LIST
110400: LIST
110401: LIST
110402: LIST
110403: LIST
110404: LIST
110405: LIST
110406: LIST
110407: PUSH
110408: LD_INT 101
110410: PUSH
110411: LD_INT 102
110413: PUSH
110414: LD_INT 103
110416: PUSH
110417: LD_INT 104
110419: PUSH
110420: LD_INT 105
110422: PUSH
110423: LD_INT 106
110425: PUSH
110426: LD_INT 107
110428: PUSH
110429: LD_INT 108
110431: PUSH
110432: LD_INT 109
110434: PUSH
110435: LD_INT 110
110437: PUSH
110438: LD_INT 111
110440: PUSH
110441: LD_INT 112
110443: PUSH
110444: LD_INT 114
110446: PUSH
110447: LD_INT 116
110449: PUSH
110450: LD_INT 117
110452: PUSH
110453: LD_INT 118
110455: PUSH
110456: EMPTY
110457: LIST
110458: LIST
110459: LIST
110460: LIST
110461: LIST
110462: LIST
110463: LIST
110464: LIST
110465: LIST
110466: LIST
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: PUSH
110474: EMPTY
110475: LIST
110476: LIST
110477: ST_TO_ADDR
110478: GO 112161
110480: LD_INT 12
110482: DOUBLE
110483: EQUAL
110484: IFTRUE 110488
110486: GO 110708
110488: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
110489: LD_ADDR_VAR 0 2
110493: PUSH
110494: LD_INT 1
110496: PUSH
110497: LD_INT 2
110499: PUSH
110500: LD_INT 3
110502: PUSH
110503: LD_INT 4
110505: PUSH
110506: LD_INT 5
110508: PUSH
110509: LD_INT 6
110511: PUSH
110512: LD_INT 7
110514: PUSH
110515: LD_INT 8
110517: PUSH
110518: LD_INT 9
110520: PUSH
110521: LD_INT 10
110523: PUSH
110524: LD_INT 11
110526: PUSH
110527: LD_INT 12
110529: PUSH
110530: LD_INT 13
110532: PUSH
110533: LD_INT 14
110535: PUSH
110536: LD_INT 15
110538: PUSH
110539: LD_INT 16
110541: PUSH
110542: LD_INT 17
110544: PUSH
110545: LD_INT 18
110547: PUSH
110548: LD_INT 19
110550: PUSH
110551: LD_INT 20
110553: PUSH
110554: LD_INT 21
110556: PUSH
110557: LD_INT 22
110559: PUSH
110560: LD_INT 23
110562: PUSH
110563: LD_INT 24
110565: PUSH
110566: LD_INT 25
110568: PUSH
110569: LD_INT 26
110571: PUSH
110572: LD_INT 27
110574: PUSH
110575: LD_INT 28
110577: PUSH
110578: LD_INT 30
110580: PUSH
110581: LD_INT 31
110583: PUSH
110584: LD_INT 32
110586: PUSH
110587: LD_INT 33
110589: PUSH
110590: LD_INT 34
110592: PUSH
110593: LD_INT 36
110595: PUSH
110596: EMPTY
110597: LIST
110598: LIST
110599: LIST
110600: LIST
110601: LIST
110602: LIST
110603: LIST
110604: LIST
110605: LIST
110606: LIST
110607: LIST
110608: LIST
110609: LIST
110610: LIST
110611: LIST
110612: LIST
110613: LIST
110614: LIST
110615: LIST
110616: LIST
110617: LIST
110618: LIST
110619: LIST
110620: LIST
110621: LIST
110622: LIST
110623: LIST
110624: LIST
110625: LIST
110626: LIST
110627: LIST
110628: LIST
110629: LIST
110630: LIST
110631: PUSH
110632: LD_INT 101
110634: PUSH
110635: LD_INT 102
110637: PUSH
110638: LD_INT 103
110640: PUSH
110641: LD_INT 104
110643: PUSH
110644: LD_INT 105
110646: PUSH
110647: LD_INT 106
110649: PUSH
110650: LD_INT 107
110652: PUSH
110653: LD_INT 108
110655: PUSH
110656: LD_INT 109
110658: PUSH
110659: LD_INT 110
110661: PUSH
110662: LD_INT 111
110664: PUSH
110665: LD_INT 112
110667: PUSH
110668: LD_INT 113
110670: PUSH
110671: LD_INT 114
110673: PUSH
110674: LD_INT 116
110676: PUSH
110677: LD_INT 117
110679: PUSH
110680: LD_INT 118
110682: PUSH
110683: EMPTY
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: LIST
110692: LIST
110693: LIST
110694: LIST
110695: LIST
110696: LIST
110697: LIST
110698: LIST
110699: LIST
110700: LIST
110701: PUSH
110702: EMPTY
110703: LIST
110704: LIST
110705: ST_TO_ADDR
110706: GO 112161
110708: LD_INT 13
110710: DOUBLE
110711: EQUAL
110712: IFTRUE 110716
110714: GO 110924
110716: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
110717: LD_ADDR_VAR 0 2
110721: PUSH
110722: LD_INT 1
110724: PUSH
110725: LD_INT 2
110727: PUSH
110728: LD_INT 3
110730: PUSH
110731: LD_INT 4
110733: PUSH
110734: LD_INT 5
110736: PUSH
110737: LD_INT 8
110739: PUSH
110740: LD_INT 9
110742: PUSH
110743: LD_INT 10
110745: PUSH
110746: LD_INT 11
110748: PUSH
110749: LD_INT 12
110751: PUSH
110752: LD_INT 14
110754: PUSH
110755: LD_INT 15
110757: PUSH
110758: LD_INT 16
110760: PUSH
110761: LD_INT 17
110763: PUSH
110764: LD_INT 18
110766: PUSH
110767: LD_INT 19
110769: PUSH
110770: LD_INT 20
110772: PUSH
110773: LD_INT 21
110775: PUSH
110776: LD_INT 22
110778: PUSH
110779: LD_INT 23
110781: PUSH
110782: LD_INT 24
110784: PUSH
110785: LD_INT 25
110787: PUSH
110788: LD_INT 26
110790: PUSH
110791: LD_INT 27
110793: PUSH
110794: LD_INT 28
110796: PUSH
110797: LD_INT 30
110799: PUSH
110800: LD_INT 31
110802: PUSH
110803: LD_INT 32
110805: PUSH
110806: LD_INT 33
110808: PUSH
110809: LD_INT 34
110811: PUSH
110812: LD_INT 36
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: LIST
110819: LIST
110820: LIST
110821: LIST
110822: LIST
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: LIST
110831: LIST
110832: LIST
110833: LIST
110834: LIST
110835: LIST
110836: LIST
110837: LIST
110838: LIST
110839: LIST
110840: LIST
110841: LIST
110842: LIST
110843: LIST
110844: LIST
110845: LIST
110846: LIST
110847: PUSH
110848: LD_INT 101
110850: PUSH
110851: LD_INT 102
110853: PUSH
110854: LD_INT 103
110856: PUSH
110857: LD_INT 104
110859: PUSH
110860: LD_INT 105
110862: PUSH
110863: LD_INT 106
110865: PUSH
110866: LD_INT 107
110868: PUSH
110869: LD_INT 108
110871: PUSH
110872: LD_INT 109
110874: PUSH
110875: LD_INT 110
110877: PUSH
110878: LD_INT 111
110880: PUSH
110881: LD_INT 112
110883: PUSH
110884: LD_INT 113
110886: PUSH
110887: LD_INT 114
110889: PUSH
110890: LD_INT 116
110892: PUSH
110893: LD_INT 117
110895: PUSH
110896: LD_INT 118
110898: PUSH
110899: EMPTY
110900: LIST
110901: LIST
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: PUSH
110918: EMPTY
110919: LIST
110920: LIST
110921: ST_TO_ADDR
110922: GO 112161
110924: LD_INT 14
110926: DOUBLE
110927: EQUAL
110928: IFTRUE 110932
110930: GO 111156
110932: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
110933: LD_ADDR_VAR 0 2
110937: PUSH
110938: LD_INT 1
110940: PUSH
110941: LD_INT 2
110943: PUSH
110944: LD_INT 3
110946: PUSH
110947: LD_INT 4
110949: PUSH
110950: LD_INT 5
110952: PUSH
110953: LD_INT 6
110955: PUSH
110956: LD_INT 7
110958: PUSH
110959: LD_INT 8
110961: PUSH
110962: LD_INT 9
110964: PUSH
110965: LD_INT 10
110967: PUSH
110968: LD_INT 11
110970: PUSH
110971: LD_INT 12
110973: PUSH
110974: LD_INT 13
110976: PUSH
110977: LD_INT 14
110979: PUSH
110980: LD_INT 15
110982: PUSH
110983: LD_INT 16
110985: PUSH
110986: LD_INT 17
110988: PUSH
110989: LD_INT 18
110991: PUSH
110992: LD_INT 19
110994: PUSH
110995: LD_INT 20
110997: PUSH
110998: LD_INT 21
111000: PUSH
111001: LD_INT 22
111003: PUSH
111004: LD_INT 23
111006: PUSH
111007: LD_INT 24
111009: PUSH
111010: LD_INT 25
111012: PUSH
111013: LD_INT 26
111015: PUSH
111016: LD_INT 27
111018: PUSH
111019: LD_INT 28
111021: PUSH
111022: LD_INT 29
111024: PUSH
111025: LD_INT 30
111027: PUSH
111028: LD_INT 31
111030: PUSH
111031: LD_INT 32
111033: PUSH
111034: LD_INT 33
111036: PUSH
111037: LD_INT 34
111039: PUSH
111040: LD_INT 36
111042: PUSH
111043: EMPTY
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: LIST
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: LIST
111062: LIST
111063: LIST
111064: LIST
111065: LIST
111066: LIST
111067: LIST
111068: LIST
111069: LIST
111070: LIST
111071: LIST
111072: LIST
111073: LIST
111074: LIST
111075: LIST
111076: LIST
111077: LIST
111078: LIST
111079: PUSH
111080: LD_INT 101
111082: PUSH
111083: LD_INT 102
111085: PUSH
111086: LD_INT 103
111088: PUSH
111089: LD_INT 104
111091: PUSH
111092: LD_INT 105
111094: PUSH
111095: LD_INT 106
111097: PUSH
111098: LD_INT 107
111100: PUSH
111101: LD_INT 108
111103: PUSH
111104: LD_INT 109
111106: PUSH
111107: LD_INT 110
111109: PUSH
111110: LD_INT 111
111112: PUSH
111113: LD_INT 112
111115: PUSH
111116: LD_INT 113
111118: PUSH
111119: LD_INT 114
111121: PUSH
111122: LD_INT 116
111124: PUSH
111125: LD_INT 117
111127: PUSH
111128: LD_INT 118
111130: PUSH
111131: EMPTY
111132: LIST
111133: LIST
111134: LIST
111135: LIST
111136: LIST
111137: LIST
111138: LIST
111139: LIST
111140: LIST
111141: LIST
111142: LIST
111143: LIST
111144: LIST
111145: LIST
111146: LIST
111147: LIST
111148: LIST
111149: PUSH
111150: EMPTY
111151: LIST
111152: LIST
111153: ST_TO_ADDR
111154: GO 112161
111156: LD_INT 15
111158: DOUBLE
111159: EQUAL
111160: IFTRUE 111164
111162: GO 111388
111164: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
111165: LD_ADDR_VAR 0 2
111169: PUSH
111170: LD_INT 1
111172: PUSH
111173: LD_INT 2
111175: PUSH
111176: LD_INT 3
111178: PUSH
111179: LD_INT 4
111181: PUSH
111182: LD_INT 5
111184: PUSH
111185: LD_INT 6
111187: PUSH
111188: LD_INT 7
111190: PUSH
111191: LD_INT 8
111193: PUSH
111194: LD_INT 9
111196: PUSH
111197: LD_INT 10
111199: PUSH
111200: LD_INT 11
111202: PUSH
111203: LD_INT 12
111205: PUSH
111206: LD_INT 13
111208: PUSH
111209: LD_INT 14
111211: PUSH
111212: LD_INT 15
111214: PUSH
111215: LD_INT 16
111217: PUSH
111218: LD_INT 17
111220: PUSH
111221: LD_INT 18
111223: PUSH
111224: LD_INT 19
111226: PUSH
111227: LD_INT 20
111229: PUSH
111230: LD_INT 21
111232: PUSH
111233: LD_INT 22
111235: PUSH
111236: LD_INT 23
111238: PUSH
111239: LD_INT 24
111241: PUSH
111242: LD_INT 25
111244: PUSH
111245: LD_INT 26
111247: PUSH
111248: LD_INT 27
111250: PUSH
111251: LD_INT 28
111253: PUSH
111254: LD_INT 29
111256: PUSH
111257: LD_INT 30
111259: PUSH
111260: LD_INT 31
111262: PUSH
111263: LD_INT 32
111265: PUSH
111266: LD_INT 33
111268: PUSH
111269: LD_INT 34
111271: PUSH
111272: LD_INT 36
111274: PUSH
111275: EMPTY
111276: LIST
111277: LIST
111278: LIST
111279: LIST
111280: LIST
111281: LIST
111282: LIST
111283: LIST
111284: LIST
111285: LIST
111286: LIST
111287: LIST
111288: LIST
111289: LIST
111290: LIST
111291: LIST
111292: LIST
111293: LIST
111294: LIST
111295: LIST
111296: LIST
111297: LIST
111298: LIST
111299: LIST
111300: LIST
111301: LIST
111302: LIST
111303: LIST
111304: LIST
111305: LIST
111306: LIST
111307: LIST
111308: LIST
111309: LIST
111310: LIST
111311: PUSH
111312: LD_INT 101
111314: PUSH
111315: LD_INT 102
111317: PUSH
111318: LD_INT 103
111320: PUSH
111321: LD_INT 104
111323: PUSH
111324: LD_INT 105
111326: PUSH
111327: LD_INT 106
111329: PUSH
111330: LD_INT 107
111332: PUSH
111333: LD_INT 108
111335: PUSH
111336: LD_INT 109
111338: PUSH
111339: LD_INT 110
111341: PUSH
111342: LD_INT 111
111344: PUSH
111345: LD_INT 112
111347: PUSH
111348: LD_INT 113
111350: PUSH
111351: LD_INT 114
111353: PUSH
111354: LD_INT 116
111356: PUSH
111357: LD_INT 117
111359: PUSH
111360: LD_INT 118
111362: PUSH
111363: EMPTY
111364: LIST
111365: LIST
111366: LIST
111367: LIST
111368: LIST
111369: LIST
111370: LIST
111371: LIST
111372: LIST
111373: LIST
111374: LIST
111375: LIST
111376: LIST
111377: LIST
111378: LIST
111379: LIST
111380: LIST
111381: PUSH
111382: EMPTY
111383: LIST
111384: LIST
111385: ST_TO_ADDR
111386: GO 112161
111388: LD_INT 16
111390: DOUBLE
111391: EQUAL
111392: IFTRUE 111396
111394: GO 111532
111396: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
111397: LD_ADDR_VAR 0 2
111401: PUSH
111402: LD_INT 2
111404: PUSH
111405: LD_INT 4
111407: PUSH
111408: LD_INT 5
111410: PUSH
111411: LD_INT 7
111413: PUSH
111414: LD_INT 11
111416: PUSH
111417: LD_INT 12
111419: PUSH
111420: LD_INT 15
111422: PUSH
111423: LD_INT 16
111425: PUSH
111426: LD_INT 20
111428: PUSH
111429: LD_INT 21
111431: PUSH
111432: LD_INT 22
111434: PUSH
111435: LD_INT 23
111437: PUSH
111438: LD_INT 25
111440: PUSH
111441: LD_INT 26
111443: PUSH
111444: LD_INT 30
111446: PUSH
111447: LD_INT 31
111449: PUSH
111450: LD_INT 32
111452: PUSH
111453: LD_INT 33
111455: PUSH
111456: LD_INT 34
111458: PUSH
111459: EMPTY
111460: LIST
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: LIST
111476: LIST
111477: LIST
111478: LIST
111479: PUSH
111480: LD_INT 101
111482: PUSH
111483: LD_INT 102
111485: PUSH
111486: LD_INT 103
111488: PUSH
111489: LD_INT 106
111491: PUSH
111492: LD_INT 108
111494: PUSH
111495: LD_INT 112
111497: PUSH
111498: LD_INT 113
111500: PUSH
111501: LD_INT 114
111503: PUSH
111504: LD_INT 116
111506: PUSH
111507: LD_INT 117
111509: PUSH
111510: LD_INT 118
111512: PUSH
111513: EMPTY
111514: LIST
111515: LIST
111516: LIST
111517: LIST
111518: LIST
111519: LIST
111520: LIST
111521: LIST
111522: LIST
111523: LIST
111524: LIST
111525: PUSH
111526: EMPTY
111527: LIST
111528: LIST
111529: ST_TO_ADDR
111530: GO 112161
111532: LD_INT 17
111534: DOUBLE
111535: EQUAL
111536: IFTRUE 111540
111538: GO 111764
111540: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
111541: LD_ADDR_VAR 0 2
111545: PUSH
111546: LD_INT 1
111548: PUSH
111549: LD_INT 2
111551: PUSH
111552: LD_INT 3
111554: PUSH
111555: LD_INT 4
111557: PUSH
111558: LD_INT 5
111560: PUSH
111561: LD_INT 6
111563: PUSH
111564: LD_INT 7
111566: PUSH
111567: LD_INT 8
111569: PUSH
111570: LD_INT 9
111572: PUSH
111573: LD_INT 10
111575: PUSH
111576: LD_INT 11
111578: PUSH
111579: LD_INT 12
111581: PUSH
111582: LD_INT 13
111584: PUSH
111585: LD_INT 14
111587: PUSH
111588: LD_INT 15
111590: PUSH
111591: LD_INT 16
111593: PUSH
111594: LD_INT 17
111596: PUSH
111597: LD_INT 18
111599: PUSH
111600: LD_INT 19
111602: PUSH
111603: LD_INT 20
111605: PUSH
111606: LD_INT 21
111608: PUSH
111609: LD_INT 22
111611: PUSH
111612: LD_INT 23
111614: PUSH
111615: LD_INT 24
111617: PUSH
111618: LD_INT 25
111620: PUSH
111621: LD_INT 26
111623: PUSH
111624: LD_INT 27
111626: PUSH
111627: LD_INT 28
111629: PUSH
111630: LD_INT 29
111632: PUSH
111633: LD_INT 30
111635: PUSH
111636: LD_INT 31
111638: PUSH
111639: LD_INT 32
111641: PUSH
111642: LD_INT 33
111644: PUSH
111645: LD_INT 34
111647: PUSH
111648: LD_INT 36
111650: PUSH
111651: EMPTY
111652: LIST
111653: LIST
111654: LIST
111655: LIST
111656: LIST
111657: LIST
111658: LIST
111659: LIST
111660: LIST
111661: LIST
111662: LIST
111663: LIST
111664: LIST
111665: LIST
111666: LIST
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: LIST
111682: LIST
111683: LIST
111684: LIST
111685: LIST
111686: LIST
111687: PUSH
111688: LD_INT 101
111690: PUSH
111691: LD_INT 102
111693: PUSH
111694: LD_INT 103
111696: PUSH
111697: LD_INT 104
111699: PUSH
111700: LD_INT 105
111702: PUSH
111703: LD_INT 106
111705: PUSH
111706: LD_INT 107
111708: PUSH
111709: LD_INT 108
111711: PUSH
111712: LD_INT 109
111714: PUSH
111715: LD_INT 110
111717: PUSH
111718: LD_INT 111
111720: PUSH
111721: LD_INT 112
111723: PUSH
111724: LD_INT 113
111726: PUSH
111727: LD_INT 114
111729: PUSH
111730: LD_INT 116
111732: PUSH
111733: LD_INT 117
111735: PUSH
111736: LD_INT 118
111738: PUSH
111739: EMPTY
111740: LIST
111741: LIST
111742: LIST
111743: LIST
111744: LIST
111745: LIST
111746: LIST
111747: LIST
111748: LIST
111749: LIST
111750: LIST
111751: LIST
111752: LIST
111753: LIST
111754: LIST
111755: LIST
111756: LIST
111757: PUSH
111758: EMPTY
111759: LIST
111760: LIST
111761: ST_TO_ADDR
111762: GO 112161
111764: LD_INT 18
111766: DOUBLE
111767: EQUAL
111768: IFTRUE 111772
111770: GO 111920
111772: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
111773: LD_ADDR_VAR 0 2
111777: PUSH
111778: LD_INT 2
111780: PUSH
111781: LD_INT 4
111783: PUSH
111784: LD_INT 5
111786: PUSH
111787: LD_INT 7
111789: PUSH
111790: LD_INT 11
111792: PUSH
111793: LD_INT 12
111795: PUSH
111796: LD_INT 15
111798: PUSH
111799: LD_INT 16
111801: PUSH
111802: LD_INT 20
111804: PUSH
111805: LD_INT 21
111807: PUSH
111808: LD_INT 22
111810: PUSH
111811: LD_INT 23
111813: PUSH
111814: LD_INT 25
111816: PUSH
111817: LD_INT 26
111819: PUSH
111820: LD_INT 30
111822: PUSH
111823: LD_INT 31
111825: PUSH
111826: LD_INT 32
111828: PUSH
111829: LD_INT 33
111831: PUSH
111832: LD_INT 34
111834: PUSH
111835: LD_INT 35
111837: PUSH
111838: LD_INT 36
111840: PUSH
111841: EMPTY
111842: LIST
111843: LIST
111844: LIST
111845: LIST
111846: LIST
111847: LIST
111848: LIST
111849: LIST
111850: LIST
111851: LIST
111852: LIST
111853: LIST
111854: LIST
111855: LIST
111856: LIST
111857: LIST
111858: LIST
111859: LIST
111860: LIST
111861: LIST
111862: LIST
111863: PUSH
111864: LD_INT 101
111866: PUSH
111867: LD_INT 102
111869: PUSH
111870: LD_INT 103
111872: PUSH
111873: LD_INT 106
111875: PUSH
111876: LD_INT 108
111878: PUSH
111879: LD_INT 112
111881: PUSH
111882: LD_INT 113
111884: PUSH
111885: LD_INT 114
111887: PUSH
111888: LD_INT 115
111890: PUSH
111891: LD_INT 116
111893: PUSH
111894: LD_INT 117
111896: PUSH
111897: LD_INT 118
111899: PUSH
111900: EMPTY
111901: LIST
111902: LIST
111903: LIST
111904: LIST
111905: LIST
111906: LIST
111907: LIST
111908: LIST
111909: LIST
111910: LIST
111911: LIST
111912: LIST
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: ST_TO_ADDR
111918: GO 112161
111920: LD_INT 19
111922: DOUBLE
111923: EQUAL
111924: IFTRUE 111928
111926: GO 112160
111928: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
111929: LD_ADDR_VAR 0 2
111933: PUSH
111934: LD_INT 1
111936: PUSH
111937: LD_INT 2
111939: PUSH
111940: LD_INT 3
111942: PUSH
111943: LD_INT 4
111945: PUSH
111946: LD_INT 5
111948: PUSH
111949: LD_INT 6
111951: PUSH
111952: LD_INT 7
111954: PUSH
111955: LD_INT 8
111957: PUSH
111958: LD_INT 9
111960: PUSH
111961: LD_INT 10
111963: PUSH
111964: LD_INT 11
111966: PUSH
111967: LD_INT 12
111969: PUSH
111970: LD_INT 13
111972: PUSH
111973: LD_INT 14
111975: PUSH
111976: LD_INT 15
111978: PUSH
111979: LD_INT 16
111981: PUSH
111982: LD_INT 17
111984: PUSH
111985: LD_INT 18
111987: PUSH
111988: LD_INT 19
111990: PUSH
111991: LD_INT 20
111993: PUSH
111994: LD_INT 21
111996: PUSH
111997: LD_INT 22
111999: PUSH
112000: LD_INT 23
112002: PUSH
112003: LD_INT 24
112005: PUSH
112006: LD_INT 25
112008: PUSH
112009: LD_INT 26
112011: PUSH
112012: LD_INT 27
112014: PUSH
112015: LD_INT 28
112017: PUSH
112018: LD_INT 29
112020: PUSH
112021: LD_INT 30
112023: PUSH
112024: LD_INT 31
112026: PUSH
112027: LD_INT 32
112029: PUSH
112030: LD_INT 33
112032: PUSH
112033: LD_INT 34
112035: PUSH
112036: LD_INT 35
112038: PUSH
112039: LD_INT 36
112041: PUSH
112042: EMPTY
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: LIST
112058: LIST
112059: LIST
112060: LIST
112061: LIST
112062: LIST
112063: LIST
112064: LIST
112065: LIST
112066: LIST
112067: LIST
112068: LIST
112069: LIST
112070: LIST
112071: LIST
112072: LIST
112073: LIST
112074: LIST
112075: LIST
112076: LIST
112077: LIST
112078: LIST
112079: PUSH
112080: LD_INT 101
112082: PUSH
112083: LD_INT 102
112085: PUSH
112086: LD_INT 103
112088: PUSH
112089: LD_INT 104
112091: PUSH
112092: LD_INT 105
112094: PUSH
112095: LD_INT 106
112097: PUSH
112098: LD_INT 107
112100: PUSH
112101: LD_INT 108
112103: PUSH
112104: LD_INT 109
112106: PUSH
112107: LD_INT 110
112109: PUSH
112110: LD_INT 111
112112: PUSH
112113: LD_INT 112
112115: PUSH
112116: LD_INT 113
112118: PUSH
112119: LD_INT 114
112121: PUSH
112122: LD_INT 115
112124: PUSH
112125: LD_INT 116
112127: PUSH
112128: LD_INT 117
112130: PUSH
112131: LD_INT 118
112133: PUSH
112134: EMPTY
112135: LIST
112136: LIST
112137: LIST
112138: LIST
112139: LIST
112140: LIST
112141: LIST
112142: LIST
112143: LIST
112144: LIST
112145: LIST
112146: LIST
112147: LIST
112148: LIST
112149: LIST
112150: LIST
112151: LIST
112152: LIST
112153: PUSH
112154: EMPTY
112155: LIST
112156: LIST
112157: ST_TO_ADDR
112158: GO 112161
112160: POP
// end else
112161: GO 112392
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
112163: LD_ADDR_VAR 0 2
112167: PUSH
112168: LD_INT 1
112170: PUSH
112171: LD_INT 2
112173: PUSH
112174: LD_INT 3
112176: PUSH
112177: LD_INT 4
112179: PUSH
112180: LD_INT 5
112182: PUSH
112183: LD_INT 6
112185: PUSH
112186: LD_INT 7
112188: PUSH
112189: LD_INT 8
112191: PUSH
112192: LD_INT 9
112194: PUSH
112195: LD_INT 10
112197: PUSH
112198: LD_INT 11
112200: PUSH
112201: LD_INT 12
112203: PUSH
112204: LD_INT 13
112206: PUSH
112207: LD_INT 14
112209: PUSH
112210: LD_INT 15
112212: PUSH
112213: LD_INT 16
112215: PUSH
112216: LD_INT 17
112218: PUSH
112219: LD_INT 18
112221: PUSH
112222: LD_INT 19
112224: PUSH
112225: LD_INT 20
112227: PUSH
112228: LD_INT 21
112230: PUSH
112231: LD_INT 22
112233: PUSH
112234: LD_INT 23
112236: PUSH
112237: LD_INT 24
112239: PUSH
112240: LD_INT 25
112242: PUSH
112243: LD_INT 26
112245: PUSH
112246: LD_INT 27
112248: PUSH
112249: LD_INT 28
112251: PUSH
112252: LD_INT 29
112254: PUSH
112255: LD_INT 30
112257: PUSH
112258: LD_INT 31
112260: PUSH
112261: LD_INT 32
112263: PUSH
112264: LD_INT 33
112266: PUSH
112267: LD_INT 34
112269: PUSH
112270: LD_INT 35
112272: PUSH
112273: LD_INT 36
112275: PUSH
112276: EMPTY
112277: LIST
112278: LIST
112279: LIST
112280: LIST
112281: LIST
112282: LIST
112283: LIST
112284: LIST
112285: LIST
112286: LIST
112287: LIST
112288: LIST
112289: LIST
112290: LIST
112291: LIST
112292: LIST
112293: LIST
112294: LIST
112295: LIST
112296: LIST
112297: LIST
112298: LIST
112299: LIST
112300: LIST
112301: LIST
112302: LIST
112303: LIST
112304: LIST
112305: LIST
112306: LIST
112307: LIST
112308: LIST
112309: LIST
112310: LIST
112311: LIST
112312: LIST
112313: PUSH
112314: LD_INT 101
112316: PUSH
112317: LD_INT 102
112319: PUSH
112320: LD_INT 103
112322: PUSH
112323: LD_INT 104
112325: PUSH
112326: LD_INT 105
112328: PUSH
112329: LD_INT 106
112331: PUSH
112332: LD_INT 107
112334: PUSH
112335: LD_INT 108
112337: PUSH
112338: LD_INT 109
112340: PUSH
112341: LD_INT 110
112343: PUSH
112344: LD_INT 111
112346: PUSH
112347: LD_INT 112
112349: PUSH
112350: LD_INT 113
112352: PUSH
112353: LD_INT 114
112355: PUSH
112356: LD_INT 115
112358: PUSH
112359: LD_INT 116
112361: PUSH
112362: LD_INT 117
112364: PUSH
112365: LD_INT 118
112367: PUSH
112368: EMPTY
112369: LIST
112370: LIST
112371: LIST
112372: LIST
112373: LIST
112374: LIST
112375: LIST
112376: LIST
112377: LIST
112378: LIST
112379: LIST
112380: LIST
112381: LIST
112382: LIST
112383: LIST
112384: LIST
112385: LIST
112386: LIST
112387: PUSH
112388: EMPTY
112389: LIST
112390: LIST
112391: ST_TO_ADDR
// if result then
112392: LD_VAR 0 2
112396: IFFALSE 113182
// begin normal :=  ;
112398: LD_ADDR_VAR 0 5
112402: PUSH
112403: LD_STRING 
112405: ST_TO_ADDR
// hardcore :=  ;
112406: LD_ADDR_VAR 0 6
112410: PUSH
112411: LD_STRING 
112413: ST_TO_ADDR
// active :=  ;
112414: LD_ADDR_VAR 0 7
112418: PUSH
112419: LD_STRING 
112421: ST_TO_ADDR
// for i = 1 to normalCounter do
112422: LD_ADDR_VAR 0 8
112426: PUSH
112427: DOUBLE
112428: LD_INT 1
112430: DEC
112431: ST_TO_ADDR
112432: LD_EXP 142
112436: PUSH
112437: FOR_TO
112438: IFFALSE 112539
// begin tmp := 0 ;
112440: LD_ADDR_VAR 0 3
112444: PUSH
112445: LD_STRING 0
112447: ST_TO_ADDR
// if result [ 1 ] then
112448: LD_VAR 0 2
112452: PUSH
112453: LD_INT 1
112455: ARRAY
112456: IFFALSE 112521
// if result [ 1 ] [ 1 ] = i then
112458: LD_VAR 0 2
112462: PUSH
112463: LD_INT 1
112465: ARRAY
112466: PUSH
112467: LD_INT 1
112469: ARRAY
112470: PUSH
112471: LD_VAR 0 8
112475: EQUAL
112476: IFFALSE 112521
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
112478: LD_ADDR_VAR 0 2
112482: PUSH
112483: LD_VAR 0 2
112487: PPUSH
112488: LD_INT 1
112490: PPUSH
112491: LD_VAR 0 2
112495: PUSH
112496: LD_INT 1
112498: ARRAY
112499: PPUSH
112500: LD_INT 1
112502: PPUSH
112503: CALL_OW 3
112507: PPUSH
112508: CALL_OW 1
112512: ST_TO_ADDR
// tmp := 1 ;
112513: LD_ADDR_VAR 0 3
112517: PUSH
112518: LD_STRING 1
112520: ST_TO_ADDR
// end ; normal := normal & tmp ;
112521: LD_ADDR_VAR 0 5
112525: PUSH
112526: LD_VAR 0 5
112530: PUSH
112531: LD_VAR 0 3
112535: STR
112536: ST_TO_ADDR
// end ;
112537: GO 112437
112539: POP
112540: POP
// for i = 1 to hardcoreCounter do
112541: LD_ADDR_VAR 0 8
112545: PUSH
112546: DOUBLE
112547: LD_INT 1
112549: DEC
112550: ST_TO_ADDR
112551: LD_EXP 143
112555: PUSH
112556: FOR_TO
112557: IFFALSE 112662
// begin tmp := 0 ;
112559: LD_ADDR_VAR 0 3
112563: PUSH
112564: LD_STRING 0
112566: ST_TO_ADDR
// if result [ 2 ] then
112567: LD_VAR 0 2
112571: PUSH
112572: LD_INT 2
112574: ARRAY
112575: IFFALSE 112644
// if result [ 2 ] [ 1 ] = 100 + i then
112577: LD_VAR 0 2
112581: PUSH
112582: LD_INT 2
112584: ARRAY
112585: PUSH
112586: LD_INT 1
112588: ARRAY
112589: PUSH
112590: LD_INT 100
112592: PUSH
112593: LD_VAR 0 8
112597: PLUS
112598: EQUAL
112599: IFFALSE 112644
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
112601: LD_ADDR_VAR 0 2
112605: PUSH
112606: LD_VAR 0 2
112610: PPUSH
112611: LD_INT 2
112613: PPUSH
112614: LD_VAR 0 2
112618: PUSH
112619: LD_INT 2
112621: ARRAY
112622: PPUSH
112623: LD_INT 1
112625: PPUSH
112626: CALL_OW 3
112630: PPUSH
112631: CALL_OW 1
112635: ST_TO_ADDR
// tmp := 1 ;
112636: LD_ADDR_VAR 0 3
112640: PUSH
112641: LD_STRING 1
112643: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
112644: LD_ADDR_VAR 0 6
112648: PUSH
112649: LD_VAR 0 6
112653: PUSH
112654: LD_VAR 0 3
112658: STR
112659: ST_TO_ADDR
// end ;
112660: GO 112556
112662: POP
112663: POP
// if isGameLoad then
112664: LD_VAR 0 1
112668: IFFALSE 113143
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
112670: LD_ADDR_VAR 0 4
112674: PUSH
112675: LD_EXP 146
112679: PUSH
112680: LD_EXP 145
112684: PUSH
112685: LD_EXP 147
112689: PUSH
112690: LD_EXP 144
112694: PUSH
112695: LD_EXP 148
112699: PUSH
112700: LD_EXP 149
112704: PUSH
112705: LD_EXP 150
112709: PUSH
112710: LD_EXP 151
112714: PUSH
112715: LD_EXP 152
112719: PUSH
112720: LD_EXP 153
112724: PUSH
112725: LD_EXP 154
112729: PUSH
112730: LD_EXP 155
112734: PUSH
112735: LD_EXP 156
112739: PUSH
112740: LD_EXP 157
112744: PUSH
112745: LD_EXP 165
112749: PUSH
112750: LD_EXP 166
112754: PUSH
112755: LD_EXP 167
112759: PUSH
112760: LD_EXP 168
112764: PUSH
112765: LD_EXP 170
112769: PUSH
112770: LD_EXP 171
112774: PUSH
112775: LD_EXP 172
112779: PUSH
112780: LD_EXP 175
112784: PUSH
112785: LD_EXP 177
112789: PUSH
112790: LD_EXP 178
112794: PUSH
112795: LD_EXP 179
112799: PUSH
112800: LD_EXP 181
112804: PUSH
112805: LD_EXP 182
112809: PUSH
112810: LD_EXP 185
112814: PUSH
112815: LD_EXP 186
112819: PUSH
112820: LD_EXP 187
112824: PUSH
112825: LD_EXP 188
112829: PUSH
112830: LD_EXP 189
112834: PUSH
112835: LD_EXP 190
112839: PUSH
112840: LD_EXP 191
112844: PUSH
112845: LD_EXP 192
112849: PUSH
112850: LD_EXP 193
112854: PUSH
112855: LD_EXP 158
112859: PUSH
112860: LD_EXP 159
112864: PUSH
112865: LD_EXP 162
112869: PUSH
112870: LD_EXP 163
112874: PUSH
112875: LD_EXP 164
112879: PUSH
112880: LD_EXP 160
112884: PUSH
112885: LD_EXP 161
112889: PUSH
112890: LD_EXP 169
112894: PUSH
112895: LD_EXP 173
112899: PUSH
112900: LD_EXP 174
112904: PUSH
112905: LD_EXP 176
112909: PUSH
112910: LD_EXP 180
112914: PUSH
112915: LD_EXP 183
112919: PUSH
112920: LD_EXP 184
112924: PUSH
112925: LD_EXP 194
112929: PUSH
112930: LD_EXP 195
112934: PUSH
112935: LD_EXP 196
112939: PUSH
112940: LD_EXP 197
112944: PUSH
112945: EMPTY
112946: LIST
112947: LIST
112948: LIST
112949: LIST
112950: LIST
112951: LIST
112952: LIST
112953: LIST
112954: LIST
112955: LIST
112956: LIST
112957: LIST
112958: LIST
112959: LIST
112960: LIST
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: LIST
112969: LIST
112970: LIST
112971: LIST
112972: LIST
112973: LIST
112974: LIST
112975: LIST
112976: LIST
112977: LIST
112978: LIST
112979: LIST
112980: LIST
112981: LIST
112982: LIST
112983: LIST
112984: LIST
112985: LIST
112986: LIST
112987: LIST
112988: LIST
112989: LIST
112990: LIST
112991: LIST
112992: LIST
112993: LIST
112994: LIST
112995: LIST
112996: LIST
112997: LIST
112998: LIST
112999: LIST
113000: ST_TO_ADDR
// tmp :=  ;
113001: LD_ADDR_VAR 0 3
113005: PUSH
113006: LD_STRING 
113008: ST_TO_ADDR
// for i = 1 to normalCounter do
113009: LD_ADDR_VAR 0 8
113013: PUSH
113014: DOUBLE
113015: LD_INT 1
113017: DEC
113018: ST_TO_ADDR
113019: LD_EXP 142
113023: PUSH
113024: FOR_TO
113025: IFFALSE 113061
// begin if flags [ i ] then
113027: LD_VAR 0 4
113031: PUSH
113032: LD_VAR 0 8
113036: ARRAY
113037: IFFALSE 113059
// tmp := tmp & i & ; ;
113039: LD_ADDR_VAR 0 3
113043: PUSH
113044: LD_VAR 0 3
113048: PUSH
113049: LD_VAR 0 8
113053: STR
113054: PUSH
113055: LD_STRING ;
113057: STR
113058: ST_TO_ADDR
// end ;
113059: GO 113024
113061: POP
113062: POP
// for i = 1 to hardcoreCounter do
113063: LD_ADDR_VAR 0 8
113067: PUSH
113068: DOUBLE
113069: LD_INT 1
113071: DEC
113072: ST_TO_ADDR
113073: LD_EXP 143
113077: PUSH
113078: FOR_TO
113079: IFFALSE 113125
// begin if flags [ normalCounter + i ] then
113081: LD_VAR 0 4
113085: PUSH
113086: LD_EXP 142
113090: PUSH
113091: LD_VAR 0 8
113095: PLUS
113096: ARRAY
113097: IFFALSE 113123
// tmp := tmp & ( 100 + i ) & ; ;
113099: LD_ADDR_VAR 0 3
113103: PUSH
113104: LD_VAR 0 3
113108: PUSH
113109: LD_INT 100
113111: PUSH
113112: LD_VAR 0 8
113116: PLUS
113117: STR
113118: PUSH
113119: LD_STRING ;
113121: STR
113122: ST_TO_ADDR
// end ;
113123: GO 113078
113125: POP
113126: POP
// if tmp then
113127: LD_VAR 0 3
113131: IFFALSE 113143
// active := tmp ;
113133: LD_ADDR_VAR 0 7
113137: PUSH
113138: LD_VAR 0 3
113142: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
113143: LD_STRING getStreamItemsFromMission("
113145: PUSH
113146: LD_VAR 0 5
113150: STR
113151: PUSH
113152: LD_STRING ","
113154: STR
113155: PUSH
113156: LD_VAR 0 6
113160: STR
113161: PUSH
113162: LD_STRING ","
113164: STR
113165: PUSH
113166: LD_VAR 0 7
113170: STR
113171: PUSH
113172: LD_STRING ")
113174: STR
113175: PPUSH
113176: CALL_OW 559
// end else
113180: GO 113189
// ToLua ( getStreamItemsFromMission("","","") ) ;
113182: LD_STRING getStreamItemsFromMission("","","")
113184: PPUSH
113185: CALL_OW 559
// end ;
113189: LD_VAR 0 2
113193: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
113194: LD_EXP 141
113198: PUSH
113199: LD_EXP 146
113203: AND
113204: IFFALSE 113328
113206: GO 113208
113208: DISABLE
113209: LD_INT 0
113211: PPUSH
113212: PPUSH
// begin enable ;
113213: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
113214: LD_ADDR_VAR 0 2
113218: PUSH
113219: LD_INT 22
113221: PUSH
113222: LD_OWVAR 2
113226: PUSH
113227: EMPTY
113228: LIST
113229: LIST
113230: PUSH
113231: LD_INT 2
113233: PUSH
113234: LD_INT 34
113236: PUSH
113237: LD_INT 7
113239: PUSH
113240: EMPTY
113241: LIST
113242: LIST
113243: PUSH
113244: LD_INT 34
113246: PUSH
113247: LD_INT 45
113249: PUSH
113250: EMPTY
113251: LIST
113252: LIST
113253: PUSH
113254: LD_INT 34
113256: PUSH
113257: LD_INT 28
113259: PUSH
113260: EMPTY
113261: LIST
113262: LIST
113263: PUSH
113264: LD_INT 34
113266: PUSH
113267: LD_INT 47
113269: PUSH
113270: EMPTY
113271: LIST
113272: LIST
113273: PUSH
113274: EMPTY
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: PUSH
113281: EMPTY
113282: LIST
113283: LIST
113284: PPUSH
113285: CALL_OW 69
113289: ST_TO_ADDR
// if not tmp then
113290: LD_VAR 0 2
113294: NOT
113295: IFFALSE 113299
// exit ;
113297: GO 113328
// for i in tmp do
113299: LD_ADDR_VAR 0 1
113303: PUSH
113304: LD_VAR 0 2
113308: PUSH
113309: FOR_IN
113310: IFFALSE 113326
// begin SetLives ( i , 0 ) ;
113312: LD_VAR 0 1
113316: PPUSH
113317: LD_INT 0
113319: PPUSH
113320: CALL_OW 234
// end ;
113324: GO 113309
113326: POP
113327: POP
// end ;
113328: PPOPN 2
113330: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
113331: LD_EXP 141
113335: PUSH
113336: LD_EXP 147
113340: AND
113341: IFFALSE 113425
113343: GO 113345
113345: DISABLE
113346: LD_INT 0
113348: PPUSH
113349: PPUSH
// begin enable ;
113350: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
113351: LD_ADDR_VAR 0 2
113355: PUSH
113356: LD_INT 22
113358: PUSH
113359: LD_OWVAR 2
113363: PUSH
113364: EMPTY
113365: LIST
113366: LIST
113367: PUSH
113368: LD_INT 32
113370: PUSH
113371: LD_INT 3
113373: PUSH
113374: EMPTY
113375: LIST
113376: LIST
113377: PUSH
113378: EMPTY
113379: LIST
113380: LIST
113381: PPUSH
113382: CALL_OW 69
113386: ST_TO_ADDR
// if not tmp then
113387: LD_VAR 0 2
113391: NOT
113392: IFFALSE 113396
// exit ;
113394: GO 113425
// for i in tmp do
113396: LD_ADDR_VAR 0 1
113400: PUSH
113401: LD_VAR 0 2
113405: PUSH
113406: FOR_IN
113407: IFFALSE 113423
// begin SetLives ( i , 0 ) ;
113409: LD_VAR 0 1
113413: PPUSH
113414: LD_INT 0
113416: PPUSH
113417: CALL_OW 234
// end ;
113421: GO 113406
113423: POP
113424: POP
// end ;
113425: PPOPN 2
113427: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113428: LD_EXP 141
113432: PUSH
113433: LD_EXP 144
113437: AND
113438: IFFALSE 113531
113440: GO 113442
113442: DISABLE
113443: LD_INT 0
113445: PPUSH
// begin enable ;
113446: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113447: LD_ADDR_VAR 0 1
113451: PUSH
113452: LD_INT 22
113454: PUSH
113455: LD_OWVAR 2
113459: PUSH
113460: EMPTY
113461: LIST
113462: LIST
113463: PUSH
113464: LD_INT 2
113466: PUSH
113467: LD_INT 25
113469: PUSH
113470: LD_INT 5
113472: PUSH
113473: EMPTY
113474: LIST
113475: LIST
113476: PUSH
113477: LD_INT 25
113479: PUSH
113480: LD_INT 9
113482: PUSH
113483: EMPTY
113484: LIST
113485: LIST
113486: PUSH
113487: LD_INT 25
113489: PUSH
113490: LD_INT 8
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: PUSH
113497: EMPTY
113498: LIST
113499: LIST
113500: LIST
113501: LIST
113502: PUSH
113503: EMPTY
113504: LIST
113505: LIST
113506: PPUSH
113507: CALL_OW 69
113511: PUSH
113512: FOR_IN
113513: IFFALSE 113529
// begin SetClass ( i , 1 ) ;
113515: LD_VAR 0 1
113519: PPUSH
113520: LD_INT 1
113522: PPUSH
113523: CALL_OW 336
// end ;
113527: GO 113512
113529: POP
113530: POP
// end ;
113531: PPOPN 1
113533: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113534: LD_EXP 141
113538: PUSH
113539: LD_EXP 145
113543: AND
113544: PUSH
113545: LD_OWVAR 65
113549: PUSH
113550: LD_INT 7
113552: LESS
113553: AND
113554: IFFALSE 113568
113556: GO 113558
113558: DISABLE
// begin enable ;
113559: ENABLE
// game_speed := 7 ;
113560: LD_ADDR_OWVAR 65
113564: PUSH
113565: LD_INT 7
113567: ST_TO_ADDR
// end ;
113568: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113569: LD_EXP 141
113573: PUSH
113574: LD_EXP 148
113578: AND
113579: IFFALSE 113781
113581: GO 113583
113583: DISABLE
113584: LD_INT 0
113586: PPUSH
113587: PPUSH
113588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113589: LD_ADDR_VAR 0 3
113593: PUSH
113594: LD_INT 81
113596: PUSH
113597: LD_OWVAR 2
113601: PUSH
113602: EMPTY
113603: LIST
113604: LIST
113605: PUSH
113606: LD_INT 21
113608: PUSH
113609: LD_INT 1
113611: PUSH
113612: EMPTY
113613: LIST
113614: LIST
113615: PUSH
113616: EMPTY
113617: LIST
113618: LIST
113619: PPUSH
113620: CALL_OW 69
113624: ST_TO_ADDR
// if not tmp then
113625: LD_VAR 0 3
113629: NOT
113630: IFFALSE 113634
// exit ;
113632: GO 113781
// if tmp > 5 then
113634: LD_VAR 0 3
113638: PUSH
113639: LD_INT 5
113641: GREATER
113642: IFFALSE 113654
// k := 5 else
113644: LD_ADDR_VAR 0 2
113648: PUSH
113649: LD_INT 5
113651: ST_TO_ADDR
113652: GO 113664
// k := tmp ;
113654: LD_ADDR_VAR 0 2
113658: PUSH
113659: LD_VAR 0 3
113663: ST_TO_ADDR
// for i := 1 to k do
113664: LD_ADDR_VAR 0 1
113668: PUSH
113669: DOUBLE
113670: LD_INT 1
113672: DEC
113673: ST_TO_ADDR
113674: LD_VAR 0 2
113678: PUSH
113679: FOR_TO
113680: IFFALSE 113779
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113682: LD_VAR 0 3
113686: PUSH
113687: LD_VAR 0 1
113691: ARRAY
113692: PPUSH
113693: LD_VAR 0 1
113697: PUSH
113698: LD_INT 4
113700: MOD
113701: PUSH
113702: LD_INT 1
113704: PLUS
113705: PPUSH
113706: CALL_OW 259
113710: PUSH
113711: LD_INT 10
113713: LESS
113714: IFFALSE 113777
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113716: LD_VAR 0 3
113720: PUSH
113721: LD_VAR 0 1
113725: ARRAY
113726: PPUSH
113727: LD_VAR 0 1
113731: PUSH
113732: LD_INT 4
113734: MOD
113735: PUSH
113736: LD_INT 1
113738: PLUS
113739: PPUSH
113740: LD_VAR 0 3
113744: PUSH
113745: LD_VAR 0 1
113749: ARRAY
113750: PPUSH
113751: LD_VAR 0 1
113755: PUSH
113756: LD_INT 4
113758: MOD
113759: PUSH
113760: LD_INT 1
113762: PLUS
113763: PPUSH
113764: CALL_OW 259
113768: PUSH
113769: LD_INT 1
113771: PLUS
113772: PPUSH
113773: CALL_OW 237
113777: GO 113679
113779: POP
113780: POP
// end ;
113781: PPOPN 3
113783: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113784: LD_EXP 141
113788: PUSH
113789: LD_EXP 149
113793: AND
113794: IFFALSE 113814
113796: GO 113798
113798: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113799: LD_INT 4
113801: PPUSH
113802: LD_OWVAR 2
113806: PPUSH
113807: LD_INT 0
113809: PPUSH
113810: CALL_OW 324
113814: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113815: LD_EXP 141
113819: PUSH
113820: LD_EXP 178
113824: AND
113825: IFFALSE 113845
113827: GO 113829
113829: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113830: LD_INT 19
113832: PPUSH
113833: LD_OWVAR 2
113837: PPUSH
113838: LD_INT 0
113840: PPUSH
113841: CALL_OW 324
113845: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113846: LD_EXP 141
113850: PUSH
113851: LD_EXP 150
113855: AND
113856: IFFALSE 113958
113858: GO 113860
113860: DISABLE
113861: LD_INT 0
113863: PPUSH
113864: PPUSH
// begin enable ;
113865: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113866: LD_ADDR_VAR 0 2
113870: PUSH
113871: LD_INT 22
113873: PUSH
113874: LD_OWVAR 2
113878: PUSH
113879: EMPTY
113880: LIST
113881: LIST
113882: PUSH
113883: LD_INT 2
113885: PUSH
113886: LD_INT 34
113888: PUSH
113889: LD_INT 11
113891: PUSH
113892: EMPTY
113893: LIST
113894: LIST
113895: PUSH
113896: LD_INT 34
113898: PUSH
113899: LD_INT 30
113901: PUSH
113902: EMPTY
113903: LIST
113904: LIST
113905: PUSH
113906: EMPTY
113907: LIST
113908: LIST
113909: LIST
113910: PUSH
113911: EMPTY
113912: LIST
113913: LIST
113914: PPUSH
113915: CALL_OW 69
113919: ST_TO_ADDR
// if not tmp then
113920: LD_VAR 0 2
113924: NOT
113925: IFFALSE 113929
// exit ;
113927: GO 113958
// for i in tmp do
113929: LD_ADDR_VAR 0 1
113933: PUSH
113934: LD_VAR 0 2
113938: PUSH
113939: FOR_IN
113940: IFFALSE 113956
// begin SetLives ( i , 0 ) ;
113942: LD_VAR 0 1
113946: PPUSH
113947: LD_INT 0
113949: PPUSH
113950: CALL_OW 234
// end ;
113954: GO 113939
113956: POP
113957: POP
// end ;
113958: PPOPN 2
113960: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113961: LD_EXP 141
113965: PUSH
113966: LD_EXP 151
113970: AND
113971: IFFALSE 113991
113973: GO 113975
113975: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113976: LD_INT 32
113978: PPUSH
113979: LD_OWVAR 2
113983: PPUSH
113984: LD_INT 0
113986: PPUSH
113987: CALL_OW 324
113991: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113992: LD_EXP 141
113996: PUSH
113997: LD_EXP 152
114001: AND
114002: IFFALSE 114183
114004: GO 114006
114006: DISABLE
114007: LD_INT 0
114009: PPUSH
114010: PPUSH
114011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
114012: LD_ADDR_VAR 0 2
114016: PUSH
114017: LD_INT 22
114019: PUSH
114020: LD_OWVAR 2
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: PUSH
114029: LD_INT 33
114031: PUSH
114032: LD_INT 3
114034: PUSH
114035: EMPTY
114036: LIST
114037: LIST
114038: PUSH
114039: EMPTY
114040: LIST
114041: LIST
114042: PPUSH
114043: CALL_OW 69
114047: ST_TO_ADDR
// if not tmp then
114048: LD_VAR 0 2
114052: NOT
114053: IFFALSE 114057
// exit ;
114055: GO 114183
// side := 0 ;
114057: LD_ADDR_VAR 0 3
114061: PUSH
114062: LD_INT 0
114064: ST_TO_ADDR
// for i := 1 to 8 do
114065: LD_ADDR_VAR 0 1
114069: PUSH
114070: DOUBLE
114071: LD_INT 1
114073: DEC
114074: ST_TO_ADDR
114075: LD_INT 8
114077: PUSH
114078: FOR_TO
114079: IFFALSE 114127
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
114081: LD_OWVAR 2
114085: PUSH
114086: LD_VAR 0 1
114090: NONEQUAL
114091: PUSH
114092: LD_OWVAR 2
114096: PPUSH
114097: LD_VAR 0 1
114101: PPUSH
114102: CALL_OW 81
114106: PUSH
114107: LD_INT 2
114109: EQUAL
114110: AND
114111: IFFALSE 114125
// begin side := i ;
114113: LD_ADDR_VAR 0 3
114117: PUSH
114118: LD_VAR 0 1
114122: ST_TO_ADDR
// break ;
114123: GO 114127
// end ;
114125: GO 114078
114127: POP
114128: POP
// if not side then
114129: LD_VAR 0 3
114133: NOT
114134: IFFALSE 114138
// exit ;
114136: GO 114183
// for i := 1 to tmp do
114138: LD_ADDR_VAR 0 1
114142: PUSH
114143: DOUBLE
114144: LD_INT 1
114146: DEC
114147: ST_TO_ADDR
114148: LD_VAR 0 2
114152: PUSH
114153: FOR_TO
114154: IFFALSE 114181
// if Prob ( 60 ) then
114156: LD_INT 60
114158: PPUSH
114159: CALL_OW 13
114163: IFFALSE 114179
// SetSide ( i , side ) ;
114165: LD_VAR 0 1
114169: PPUSH
114170: LD_VAR 0 3
114174: PPUSH
114175: CALL_OW 235
114179: GO 114153
114181: POP
114182: POP
// end ;
114183: PPOPN 3
114185: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
114186: LD_EXP 141
114190: PUSH
114191: LD_EXP 154
114195: AND
114196: IFFALSE 114315
114198: GO 114200
114200: DISABLE
114201: LD_INT 0
114203: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
114204: LD_ADDR_VAR 0 1
114208: PUSH
114209: LD_INT 22
114211: PUSH
114212: LD_OWVAR 2
114216: PUSH
114217: EMPTY
114218: LIST
114219: LIST
114220: PUSH
114221: LD_INT 21
114223: PUSH
114224: LD_INT 1
114226: PUSH
114227: EMPTY
114228: LIST
114229: LIST
114230: PUSH
114231: LD_INT 3
114233: PUSH
114234: LD_INT 23
114236: PUSH
114237: LD_INT 0
114239: PUSH
114240: EMPTY
114241: LIST
114242: LIST
114243: PUSH
114244: EMPTY
114245: LIST
114246: LIST
114247: PUSH
114248: EMPTY
114249: LIST
114250: LIST
114251: LIST
114252: PPUSH
114253: CALL_OW 69
114257: PUSH
114258: FOR_IN
114259: IFFALSE 114313
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
114261: LD_VAR 0 1
114265: PPUSH
114266: CALL_OW 257
114270: PUSH
114271: LD_INT 1
114273: PUSH
114274: LD_INT 2
114276: PUSH
114277: LD_INT 3
114279: PUSH
114280: LD_INT 4
114282: PUSH
114283: EMPTY
114284: LIST
114285: LIST
114286: LIST
114287: LIST
114288: IN
114289: IFFALSE 114311
// SetClass ( un , rand ( 1 , 4 ) ) ;
114291: LD_VAR 0 1
114295: PPUSH
114296: LD_INT 1
114298: PPUSH
114299: LD_INT 4
114301: PPUSH
114302: CALL_OW 12
114306: PPUSH
114307: CALL_OW 336
114311: GO 114258
114313: POP
114314: POP
// end ;
114315: PPOPN 1
114317: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
114318: LD_EXP 141
114322: PUSH
114323: LD_EXP 153
114327: AND
114328: IFFALSE 114407
114330: GO 114332
114332: DISABLE
114333: LD_INT 0
114335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114336: LD_ADDR_VAR 0 1
114340: PUSH
114341: LD_INT 22
114343: PUSH
114344: LD_OWVAR 2
114348: PUSH
114349: EMPTY
114350: LIST
114351: LIST
114352: PUSH
114353: LD_INT 21
114355: PUSH
114356: LD_INT 3
114358: PUSH
114359: EMPTY
114360: LIST
114361: LIST
114362: PUSH
114363: EMPTY
114364: LIST
114365: LIST
114366: PPUSH
114367: CALL_OW 69
114371: ST_TO_ADDR
// if not tmp then
114372: LD_VAR 0 1
114376: NOT
114377: IFFALSE 114381
// exit ;
114379: GO 114407
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114381: LD_VAR 0 1
114385: PUSH
114386: LD_INT 1
114388: PPUSH
114389: LD_VAR 0 1
114393: PPUSH
114394: CALL_OW 12
114398: ARRAY
114399: PPUSH
114400: LD_INT 100
114402: PPUSH
114403: CALL_OW 234
// end ;
114407: PPOPN 1
114409: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114410: LD_EXP 141
114414: PUSH
114415: LD_EXP 155
114419: AND
114420: IFFALSE 114518
114422: GO 114424
114424: DISABLE
114425: LD_INT 0
114427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114428: LD_ADDR_VAR 0 1
114432: PUSH
114433: LD_INT 22
114435: PUSH
114436: LD_OWVAR 2
114440: PUSH
114441: EMPTY
114442: LIST
114443: LIST
114444: PUSH
114445: LD_INT 21
114447: PUSH
114448: LD_INT 1
114450: PUSH
114451: EMPTY
114452: LIST
114453: LIST
114454: PUSH
114455: EMPTY
114456: LIST
114457: LIST
114458: PPUSH
114459: CALL_OW 69
114463: ST_TO_ADDR
// if not tmp then
114464: LD_VAR 0 1
114468: NOT
114469: IFFALSE 114473
// exit ;
114471: GO 114518
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114473: LD_VAR 0 1
114477: PUSH
114478: LD_INT 1
114480: PPUSH
114481: LD_VAR 0 1
114485: PPUSH
114486: CALL_OW 12
114490: ARRAY
114491: PPUSH
114492: LD_INT 1
114494: PPUSH
114495: LD_INT 4
114497: PPUSH
114498: CALL_OW 12
114502: PPUSH
114503: LD_INT 3000
114505: PPUSH
114506: LD_INT 9000
114508: PPUSH
114509: CALL_OW 12
114513: PPUSH
114514: CALL_OW 492
// end ;
114518: PPOPN 1
114520: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114521: LD_EXP 141
114525: PUSH
114526: LD_EXP 156
114530: AND
114531: IFFALSE 114551
114533: GO 114535
114535: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114536: LD_INT 1
114538: PPUSH
114539: LD_OWVAR 2
114543: PPUSH
114544: LD_INT 0
114546: PPUSH
114547: CALL_OW 324
114551: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114552: LD_EXP 141
114556: PUSH
114557: LD_EXP 157
114561: AND
114562: IFFALSE 114645
114564: GO 114566
114566: DISABLE
114567: LD_INT 0
114569: PPUSH
114570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114571: LD_ADDR_VAR 0 2
114575: PUSH
114576: LD_INT 22
114578: PUSH
114579: LD_OWVAR 2
114583: PUSH
114584: EMPTY
114585: LIST
114586: LIST
114587: PUSH
114588: LD_INT 21
114590: PUSH
114591: LD_INT 3
114593: PUSH
114594: EMPTY
114595: LIST
114596: LIST
114597: PUSH
114598: EMPTY
114599: LIST
114600: LIST
114601: PPUSH
114602: CALL_OW 69
114606: ST_TO_ADDR
// if not tmp then
114607: LD_VAR 0 2
114611: NOT
114612: IFFALSE 114616
// exit ;
114614: GO 114645
// for i in tmp do
114616: LD_ADDR_VAR 0 1
114620: PUSH
114621: LD_VAR 0 2
114625: PUSH
114626: FOR_IN
114627: IFFALSE 114643
// SetBLevel ( i , 10 ) ;
114629: LD_VAR 0 1
114633: PPUSH
114634: LD_INT 10
114636: PPUSH
114637: CALL_OW 241
114641: GO 114626
114643: POP
114644: POP
// end ;
114645: PPOPN 2
114647: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114648: LD_EXP 141
114652: PUSH
114653: LD_EXP 158
114657: AND
114658: IFFALSE 114769
114660: GO 114662
114662: DISABLE
114663: LD_INT 0
114665: PPUSH
114666: PPUSH
114667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114668: LD_ADDR_VAR 0 3
114672: PUSH
114673: LD_INT 22
114675: PUSH
114676: LD_OWVAR 2
114680: PUSH
114681: EMPTY
114682: LIST
114683: LIST
114684: PUSH
114685: LD_INT 25
114687: PUSH
114688: LD_INT 1
114690: PUSH
114691: EMPTY
114692: LIST
114693: LIST
114694: PUSH
114695: EMPTY
114696: LIST
114697: LIST
114698: PPUSH
114699: CALL_OW 69
114703: ST_TO_ADDR
// if not tmp then
114704: LD_VAR 0 3
114708: NOT
114709: IFFALSE 114713
// exit ;
114711: GO 114769
// un := tmp [ rand ( 1 , tmp ) ] ;
114713: LD_ADDR_VAR 0 2
114717: PUSH
114718: LD_VAR 0 3
114722: PUSH
114723: LD_INT 1
114725: PPUSH
114726: LD_VAR 0 3
114730: PPUSH
114731: CALL_OW 12
114735: ARRAY
114736: ST_TO_ADDR
// if Crawls ( un ) then
114737: LD_VAR 0 2
114741: PPUSH
114742: CALL_OW 318
114746: IFFALSE 114757
// ComWalk ( un ) ;
114748: LD_VAR 0 2
114752: PPUSH
114753: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114757: LD_VAR 0 2
114761: PPUSH
114762: LD_INT 5
114764: PPUSH
114765: CALL_OW 336
// end ;
114769: PPOPN 3
114771: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
114772: LD_EXP 141
114776: PUSH
114777: LD_EXP 159
114781: AND
114782: PUSH
114783: LD_OWVAR 67
114787: PUSH
114788: LD_INT 4
114790: LESS
114791: AND
114792: IFFALSE 114811
114794: GO 114796
114796: DISABLE
// begin Difficulty := Difficulty + 1 ;
114797: LD_ADDR_OWVAR 67
114801: PUSH
114802: LD_OWVAR 67
114806: PUSH
114807: LD_INT 1
114809: PLUS
114810: ST_TO_ADDR
// end ;
114811: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114812: LD_EXP 141
114816: PUSH
114817: LD_EXP 160
114821: AND
114822: IFFALSE 114925
114824: GO 114826
114826: DISABLE
114827: LD_INT 0
114829: PPUSH
// begin for i := 1 to 5 do
114830: LD_ADDR_VAR 0 1
114834: PUSH
114835: DOUBLE
114836: LD_INT 1
114838: DEC
114839: ST_TO_ADDR
114840: LD_INT 5
114842: PUSH
114843: FOR_TO
114844: IFFALSE 114923
// begin uc_nation := nation_nature ;
114846: LD_ADDR_OWVAR 21
114850: PUSH
114851: LD_INT 0
114853: ST_TO_ADDR
// uc_side := 0 ;
114854: LD_ADDR_OWVAR 20
114858: PUSH
114859: LD_INT 0
114861: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114862: LD_ADDR_OWVAR 29
114866: PUSH
114867: LD_INT 12
114869: PUSH
114870: LD_INT 12
114872: PUSH
114873: EMPTY
114874: LIST
114875: LIST
114876: ST_TO_ADDR
// hc_agressivity := 20 ;
114877: LD_ADDR_OWVAR 35
114881: PUSH
114882: LD_INT 20
114884: ST_TO_ADDR
// hc_class := class_tiger ;
114885: LD_ADDR_OWVAR 28
114889: PUSH
114890: LD_INT 14
114892: ST_TO_ADDR
// hc_gallery :=  ;
114893: LD_ADDR_OWVAR 33
114897: PUSH
114898: LD_STRING 
114900: ST_TO_ADDR
// hc_name :=  ;
114901: LD_ADDR_OWVAR 26
114905: PUSH
114906: LD_STRING 
114908: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114909: CALL_OW 44
114913: PPUSH
114914: LD_INT 0
114916: PPUSH
114917: CALL_OW 51
// end ;
114921: GO 114843
114923: POP
114924: POP
// end ;
114925: PPOPN 1
114927: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114928: LD_EXP 141
114932: PUSH
114933: LD_EXP 161
114937: AND
114938: IFFALSE 114947
114940: GO 114942
114942: DISABLE
// StreamSibBomb ;
114943: CALL 114948 0 0
114947: END
// export function StreamSibBomb ; var i , x , y ; begin
114948: LD_INT 0
114950: PPUSH
114951: PPUSH
114952: PPUSH
114953: PPUSH
// result := false ;
114954: LD_ADDR_VAR 0 1
114958: PUSH
114959: LD_INT 0
114961: ST_TO_ADDR
// for i := 1 to 16 do
114962: LD_ADDR_VAR 0 2
114966: PUSH
114967: DOUBLE
114968: LD_INT 1
114970: DEC
114971: ST_TO_ADDR
114972: LD_INT 16
114974: PUSH
114975: FOR_TO
114976: IFFALSE 115175
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114978: LD_ADDR_VAR 0 3
114982: PUSH
114983: LD_INT 10
114985: PUSH
114986: LD_INT 20
114988: PUSH
114989: LD_INT 30
114991: PUSH
114992: LD_INT 40
114994: PUSH
114995: LD_INT 50
114997: PUSH
114998: LD_INT 60
115000: PUSH
115001: LD_INT 70
115003: PUSH
115004: LD_INT 80
115006: PUSH
115007: LD_INT 90
115009: PUSH
115010: LD_INT 100
115012: PUSH
115013: LD_INT 110
115015: PUSH
115016: LD_INT 120
115018: PUSH
115019: LD_INT 130
115021: PUSH
115022: LD_INT 140
115024: PUSH
115025: LD_INT 150
115027: PUSH
115028: EMPTY
115029: LIST
115030: LIST
115031: LIST
115032: LIST
115033: LIST
115034: LIST
115035: LIST
115036: LIST
115037: LIST
115038: LIST
115039: LIST
115040: LIST
115041: LIST
115042: LIST
115043: LIST
115044: PUSH
115045: LD_INT 1
115047: PPUSH
115048: LD_INT 15
115050: PPUSH
115051: CALL_OW 12
115055: ARRAY
115056: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
115057: LD_ADDR_VAR 0 4
115061: PUSH
115062: LD_INT 10
115064: PUSH
115065: LD_INT 20
115067: PUSH
115068: LD_INT 30
115070: PUSH
115071: LD_INT 40
115073: PUSH
115074: LD_INT 50
115076: PUSH
115077: LD_INT 60
115079: PUSH
115080: LD_INT 70
115082: PUSH
115083: LD_INT 80
115085: PUSH
115086: LD_INT 90
115088: PUSH
115089: LD_INT 100
115091: PUSH
115092: LD_INT 110
115094: PUSH
115095: LD_INT 120
115097: PUSH
115098: LD_INT 130
115100: PUSH
115101: LD_INT 140
115103: PUSH
115104: LD_INT 150
115106: PUSH
115107: EMPTY
115108: LIST
115109: LIST
115110: LIST
115111: LIST
115112: LIST
115113: LIST
115114: LIST
115115: LIST
115116: LIST
115117: LIST
115118: LIST
115119: LIST
115120: LIST
115121: LIST
115122: LIST
115123: PUSH
115124: LD_INT 1
115126: PPUSH
115127: LD_INT 15
115129: PPUSH
115130: CALL_OW 12
115134: ARRAY
115135: ST_TO_ADDR
// if ValidHex ( x , y ) then
115136: LD_VAR 0 3
115140: PPUSH
115141: LD_VAR 0 4
115145: PPUSH
115146: CALL_OW 488
115150: IFFALSE 115173
// begin result := [ x , y ] ;
115152: LD_ADDR_VAR 0 1
115156: PUSH
115157: LD_VAR 0 3
115161: PUSH
115162: LD_VAR 0 4
115166: PUSH
115167: EMPTY
115168: LIST
115169: LIST
115170: ST_TO_ADDR
// break ;
115171: GO 115175
// end ; end ;
115173: GO 114975
115175: POP
115176: POP
// if result then
115177: LD_VAR 0 1
115181: IFFALSE 115241
// begin ToLua ( playSibBomb() ) ;
115183: LD_STRING playSibBomb()
115185: PPUSH
115186: CALL_OW 559
// wait ( 0 0$14 ) ;
115190: LD_INT 490
115192: PPUSH
115193: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
115197: LD_VAR 0 1
115201: PUSH
115202: LD_INT 1
115204: ARRAY
115205: PPUSH
115206: LD_VAR 0 1
115210: PUSH
115211: LD_INT 2
115213: ARRAY
115214: PPUSH
115215: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
115219: LD_VAR 0 1
115223: PUSH
115224: LD_INT 1
115226: ARRAY
115227: PPUSH
115228: LD_VAR 0 1
115232: PUSH
115233: LD_INT 2
115235: ARRAY
115236: PPUSH
115237: CALL_OW 429
// end ; end ;
115241: LD_VAR 0 1
115245: RET
// every 0 0$1 trigger StreamModeActive and sReset do
115246: LD_EXP 141
115250: PUSH
115251: LD_EXP 163
115255: AND
115256: IFFALSE 115268
115258: GO 115260
115260: DISABLE
// YouLost (  ) ;
115261: LD_STRING 
115263: PPUSH
115264: CALL_OW 104
115268: END
// every 0 0$1 trigger StreamModeActive and sFog do
115269: LD_EXP 141
115273: PUSH
115274: LD_EXP 162
115278: AND
115279: IFFALSE 115293
115281: GO 115283
115283: DISABLE
// FogOff ( your_side ) ;
115284: LD_OWVAR 2
115288: PPUSH
115289: CALL_OW 344
115293: END
// every 0 0$1 trigger StreamModeActive and sSun do
115294: LD_EXP 141
115298: PUSH
115299: LD_EXP 164
115303: AND
115304: IFFALSE 115332
115306: GO 115308
115308: DISABLE
// begin solar_recharge_percent := 0 ;
115309: LD_ADDR_OWVAR 79
115313: PUSH
115314: LD_INT 0
115316: ST_TO_ADDR
// wait ( 5 5$00 ) ;
115317: LD_INT 10500
115319: PPUSH
115320: CALL_OW 67
// solar_recharge_percent := 100 ;
115324: LD_ADDR_OWVAR 79
115328: PUSH
115329: LD_INT 100
115331: ST_TO_ADDR
// end ;
115332: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
115333: LD_EXP 141
115337: PUSH
115338: LD_EXP 165
115342: AND
115343: IFFALSE 115582
115345: GO 115347
115347: DISABLE
115348: LD_INT 0
115350: PPUSH
115351: PPUSH
115352: PPUSH
// begin tmp := [ ] ;
115353: LD_ADDR_VAR 0 3
115357: PUSH
115358: EMPTY
115359: ST_TO_ADDR
// for i := 1 to 6 do
115360: LD_ADDR_VAR 0 1
115364: PUSH
115365: DOUBLE
115366: LD_INT 1
115368: DEC
115369: ST_TO_ADDR
115370: LD_INT 6
115372: PUSH
115373: FOR_TO
115374: IFFALSE 115479
// begin uc_nation := nation_nature ;
115376: LD_ADDR_OWVAR 21
115380: PUSH
115381: LD_INT 0
115383: ST_TO_ADDR
// uc_side := 0 ;
115384: LD_ADDR_OWVAR 20
115388: PUSH
115389: LD_INT 0
115391: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115392: LD_ADDR_OWVAR 29
115396: PUSH
115397: LD_INT 12
115399: PUSH
115400: LD_INT 12
115402: PUSH
115403: EMPTY
115404: LIST
115405: LIST
115406: ST_TO_ADDR
// hc_agressivity := 20 ;
115407: LD_ADDR_OWVAR 35
115411: PUSH
115412: LD_INT 20
115414: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115415: LD_ADDR_OWVAR 28
115419: PUSH
115420: LD_INT 17
115422: ST_TO_ADDR
// hc_gallery :=  ;
115423: LD_ADDR_OWVAR 33
115427: PUSH
115428: LD_STRING 
115430: ST_TO_ADDR
// hc_name :=  ;
115431: LD_ADDR_OWVAR 26
115435: PUSH
115436: LD_STRING 
115438: ST_TO_ADDR
// un := CreateHuman ;
115439: LD_ADDR_VAR 0 2
115443: PUSH
115444: CALL_OW 44
115448: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115449: LD_VAR 0 2
115453: PPUSH
115454: LD_INT 1
115456: PPUSH
115457: CALL_OW 51
// tmp := tmp ^ un ;
115461: LD_ADDR_VAR 0 3
115465: PUSH
115466: LD_VAR 0 3
115470: PUSH
115471: LD_VAR 0 2
115475: ADD
115476: ST_TO_ADDR
// end ;
115477: GO 115373
115479: POP
115480: POP
// repeat wait ( 0 0$1 ) ;
115481: LD_INT 35
115483: PPUSH
115484: CALL_OW 67
// for un in tmp do
115488: LD_ADDR_VAR 0 2
115492: PUSH
115493: LD_VAR 0 3
115497: PUSH
115498: FOR_IN
115499: IFFALSE 115573
// begin if IsDead ( un ) then
115501: LD_VAR 0 2
115505: PPUSH
115506: CALL_OW 301
115510: IFFALSE 115530
// begin tmp := tmp diff un ;
115512: LD_ADDR_VAR 0 3
115516: PUSH
115517: LD_VAR 0 3
115521: PUSH
115522: LD_VAR 0 2
115526: DIFF
115527: ST_TO_ADDR
// continue ;
115528: GO 115498
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115530: LD_VAR 0 2
115534: PPUSH
115535: LD_INT 3
115537: PUSH
115538: LD_INT 22
115540: PUSH
115541: LD_INT 0
115543: PUSH
115544: EMPTY
115545: LIST
115546: LIST
115547: PUSH
115548: EMPTY
115549: LIST
115550: LIST
115551: PPUSH
115552: CALL_OW 69
115556: PPUSH
115557: LD_VAR 0 2
115561: PPUSH
115562: CALL_OW 74
115566: PPUSH
115567: CALL_OW 115
// end ;
115571: GO 115498
115573: POP
115574: POP
// until not tmp ;
115575: LD_VAR 0 3
115579: NOT
115580: IFFALSE 115481
// end ;
115582: PPOPN 3
115584: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115585: LD_EXP 141
115589: PUSH
115590: LD_EXP 166
115594: AND
115595: IFFALSE 115649
115597: GO 115599
115599: DISABLE
// begin ToLua ( displayTroll(); ) ;
115600: LD_STRING displayTroll();
115602: PPUSH
115603: CALL_OW 559
// wait ( 3 3$00 ) ;
115607: LD_INT 6300
115609: PPUSH
115610: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115614: LD_STRING hideTroll();
115616: PPUSH
115617: CALL_OW 559
// wait ( 1 1$00 ) ;
115621: LD_INT 2100
115623: PPUSH
115624: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115628: LD_STRING displayTroll();
115630: PPUSH
115631: CALL_OW 559
// wait ( 1 1$00 ) ;
115635: LD_INT 2100
115637: PPUSH
115638: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115642: LD_STRING hideTroll();
115644: PPUSH
115645: CALL_OW 559
// end ;
115649: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115650: LD_EXP 141
115654: PUSH
115655: LD_EXP 167
115659: AND
115660: IFFALSE 115723
115662: GO 115664
115664: DISABLE
115665: LD_INT 0
115667: PPUSH
// begin p := 0 ;
115668: LD_ADDR_VAR 0 1
115672: PUSH
115673: LD_INT 0
115675: ST_TO_ADDR
// repeat game_speed := 1 ;
115676: LD_ADDR_OWVAR 65
115680: PUSH
115681: LD_INT 1
115683: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115684: LD_INT 35
115686: PPUSH
115687: CALL_OW 67
// p := p + 1 ;
115691: LD_ADDR_VAR 0 1
115695: PUSH
115696: LD_VAR 0 1
115700: PUSH
115701: LD_INT 1
115703: PLUS
115704: ST_TO_ADDR
// until p >= 60 ;
115705: LD_VAR 0 1
115709: PUSH
115710: LD_INT 60
115712: GREATEREQUAL
115713: IFFALSE 115676
// game_speed := 4 ;
115715: LD_ADDR_OWVAR 65
115719: PUSH
115720: LD_INT 4
115722: ST_TO_ADDR
// end ;
115723: PPOPN 1
115725: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115726: LD_EXP 141
115730: PUSH
115731: LD_EXP 168
115735: AND
115736: IFFALSE 115882
115738: GO 115740
115740: DISABLE
115741: LD_INT 0
115743: PPUSH
115744: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115745: LD_ADDR_VAR 0 1
115749: PUSH
115750: LD_INT 22
115752: PUSH
115753: LD_OWVAR 2
115757: PUSH
115758: EMPTY
115759: LIST
115760: LIST
115761: PUSH
115762: LD_INT 2
115764: PUSH
115765: LD_INT 30
115767: PUSH
115768: LD_INT 0
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: PUSH
115775: LD_INT 30
115777: PUSH
115778: LD_INT 1
115780: PUSH
115781: EMPTY
115782: LIST
115783: LIST
115784: PUSH
115785: EMPTY
115786: LIST
115787: LIST
115788: LIST
115789: PUSH
115790: EMPTY
115791: LIST
115792: LIST
115793: PPUSH
115794: CALL_OW 69
115798: ST_TO_ADDR
// if not depot then
115799: LD_VAR 0 1
115803: NOT
115804: IFFALSE 115808
// exit ;
115806: GO 115882
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115808: LD_ADDR_VAR 0 2
115812: PUSH
115813: LD_VAR 0 1
115817: PUSH
115818: LD_INT 1
115820: PPUSH
115821: LD_VAR 0 1
115825: PPUSH
115826: CALL_OW 12
115830: ARRAY
115831: PPUSH
115832: CALL_OW 274
115836: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115837: LD_VAR 0 2
115841: PPUSH
115842: LD_INT 1
115844: PPUSH
115845: LD_INT 0
115847: PPUSH
115848: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115852: LD_VAR 0 2
115856: PPUSH
115857: LD_INT 2
115859: PPUSH
115860: LD_INT 0
115862: PPUSH
115863: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115867: LD_VAR 0 2
115871: PPUSH
115872: LD_INT 3
115874: PPUSH
115875: LD_INT 0
115877: PPUSH
115878: CALL_OW 277
// end ;
115882: PPOPN 2
115884: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115885: LD_EXP 141
115889: PUSH
115890: LD_EXP 169
115894: AND
115895: IFFALSE 115992
115897: GO 115899
115899: DISABLE
115900: LD_INT 0
115902: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115903: LD_ADDR_VAR 0 1
115907: PUSH
115908: LD_INT 22
115910: PUSH
115911: LD_OWVAR 2
115915: PUSH
115916: EMPTY
115917: LIST
115918: LIST
115919: PUSH
115920: LD_INT 21
115922: PUSH
115923: LD_INT 1
115925: PUSH
115926: EMPTY
115927: LIST
115928: LIST
115929: PUSH
115930: LD_INT 3
115932: PUSH
115933: LD_INT 23
115935: PUSH
115936: LD_INT 0
115938: PUSH
115939: EMPTY
115940: LIST
115941: LIST
115942: PUSH
115943: EMPTY
115944: LIST
115945: LIST
115946: PUSH
115947: EMPTY
115948: LIST
115949: LIST
115950: LIST
115951: PPUSH
115952: CALL_OW 69
115956: ST_TO_ADDR
// if not tmp then
115957: LD_VAR 0 1
115961: NOT
115962: IFFALSE 115966
// exit ;
115964: GO 115992
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115966: LD_VAR 0 1
115970: PUSH
115971: LD_INT 1
115973: PPUSH
115974: LD_VAR 0 1
115978: PPUSH
115979: CALL_OW 12
115983: ARRAY
115984: PPUSH
115985: LD_INT 200
115987: PPUSH
115988: CALL_OW 234
// end ;
115992: PPOPN 1
115994: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115995: LD_EXP 141
115999: PUSH
116000: LD_EXP 170
116004: AND
116005: IFFALSE 116084
116007: GO 116009
116009: DISABLE
116010: LD_INT 0
116012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
116013: LD_ADDR_VAR 0 1
116017: PUSH
116018: LD_INT 22
116020: PUSH
116021: LD_OWVAR 2
116025: PUSH
116026: EMPTY
116027: LIST
116028: LIST
116029: PUSH
116030: LD_INT 21
116032: PUSH
116033: LD_INT 2
116035: PUSH
116036: EMPTY
116037: LIST
116038: LIST
116039: PUSH
116040: EMPTY
116041: LIST
116042: LIST
116043: PPUSH
116044: CALL_OW 69
116048: ST_TO_ADDR
// if not tmp then
116049: LD_VAR 0 1
116053: NOT
116054: IFFALSE 116058
// exit ;
116056: GO 116084
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
116058: LD_VAR 0 1
116062: PUSH
116063: LD_INT 1
116065: PPUSH
116066: LD_VAR 0 1
116070: PPUSH
116071: CALL_OW 12
116075: ARRAY
116076: PPUSH
116077: LD_INT 60
116079: PPUSH
116080: CALL_OW 234
// end ;
116084: PPOPN 1
116086: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
116087: LD_EXP 141
116091: PUSH
116092: LD_EXP 171
116096: AND
116097: IFFALSE 116196
116099: GO 116101
116101: DISABLE
116102: LD_INT 0
116104: PPUSH
116105: PPUSH
// begin enable ;
116106: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
116107: LD_ADDR_VAR 0 1
116111: PUSH
116112: LD_INT 22
116114: PUSH
116115: LD_OWVAR 2
116119: PUSH
116120: EMPTY
116121: LIST
116122: LIST
116123: PUSH
116124: LD_INT 61
116126: PUSH
116127: EMPTY
116128: LIST
116129: PUSH
116130: LD_INT 33
116132: PUSH
116133: LD_INT 2
116135: PUSH
116136: EMPTY
116137: LIST
116138: LIST
116139: PUSH
116140: EMPTY
116141: LIST
116142: LIST
116143: LIST
116144: PPUSH
116145: CALL_OW 69
116149: ST_TO_ADDR
// if not tmp then
116150: LD_VAR 0 1
116154: NOT
116155: IFFALSE 116159
// exit ;
116157: GO 116196
// for i in tmp do
116159: LD_ADDR_VAR 0 2
116163: PUSH
116164: LD_VAR 0 1
116168: PUSH
116169: FOR_IN
116170: IFFALSE 116194
// if IsControledBy ( i ) then
116172: LD_VAR 0 2
116176: PPUSH
116177: CALL_OW 312
116181: IFFALSE 116192
// ComUnlink ( i ) ;
116183: LD_VAR 0 2
116187: PPUSH
116188: CALL_OW 136
116192: GO 116169
116194: POP
116195: POP
// end ;
116196: PPOPN 2
116198: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
116199: LD_EXP 141
116203: PUSH
116204: LD_EXP 172
116208: AND
116209: IFFALSE 116349
116211: GO 116213
116213: DISABLE
116214: LD_INT 0
116216: PPUSH
116217: PPUSH
// begin ToLua ( displayPowell(); ) ;
116218: LD_STRING displayPowell();
116220: PPUSH
116221: CALL_OW 559
// uc_side := 0 ;
116225: LD_ADDR_OWVAR 20
116229: PUSH
116230: LD_INT 0
116232: ST_TO_ADDR
// uc_nation := 2 ;
116233: LD_ADDR_OWVAR 21
116237: PUSH
116238: LD_INT 2
116240: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
116241: LD_ADDR_OWVAR 37
116245: PUSH
116246: LD_INT 14
116248: ST_TO_ADDR
// vc_engine := engine_siberite ;
116249: LD_ADDR_OWVAR 39
116253: PUSH
116254: LD_INT 3
116256: ST_TO_ADDR
// vc_control := control_apeman ;
116257: LD_ADDR_OWVAR 38
116261: PUSH
116262: LD_INT 5
116264: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
116265: LD_ADDR_OWVAR 40
116269: PUSH
116270: LD_INT 29
116272: ST_TO_ADDR
// un := CreateVehicle ;
116273: LD_ADDR_VAR 0 2
116277: PUSH
116278: CALL_OW 45
116282: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116283: LD_VAR 0 2
116287: PPUSH
116288: LD_INT 1
116290: PPUSH
116291: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116295: LD_INT 35
116297: PPUSH
116298: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116302: LD_VAR 0 2
116306: PPUSH
116307: LD_INT 22
116309: PUSH
116310: LD_OWVAR 2
116314: PUSH
116315: EMPTY
116316: LIST
116317: LIST
116318: PPUSH
116319: CALL_OW 69
116323: PPUSH
116324: LD_VAR 0 2
116328: PPUSH
116329: CALL_OW 74
116333: PPUSH
116334: CALL_OW 115
// until IsDead ( un ) ;
116338: LD_VAR 0 2
116342: PPUSH
116343: CALL_OW 301
116347: IFFALSE 116295
// end ;
116349: PPOPN 2
116351: END
// every 0 0$1 trigger StreamModeActive and sStu do
116352: LD_EXP 141
116356: PUSH
116357: LD_EXP 180
116361: AND
116362: IFFALSE 116378
116364: GO 116366
116366: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116367: LD_STRING displayStucuk();
116369: PPUSH
116370: CALL_OW 559
// ResetFog ;
116374: CALL_OW 335
// end ;
116378: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116379: LD_EXP 141
116383: PUSH
116384: LD_EXP 173
116388: AND
116389: IFFALSE 116530
116391: GO 116393
116393: DISABLE
116394: LD_INT 0
116396: PPUSH
116397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116398: LD_ADDR_VAR 0 2
116402: PUSH
116403: LD_INT 22
116405: PUSH
116406: LD_OWVAR 2
116410: PUSH
116411: EMPTY
116412: LIST
116413: LIST
116414: PUSH
116415: LD_INT 21
116417: PUSH
116418: LD_INT 1
116420: PUSH
116421: EMPTY
116422: LIST
116423: LIST
116424: PUSH
116425: EMPTY
116426: LIST
116427: LIST
116428: PPUSH
116429: CALL_OW 69
116433: ST_TO_ADDR
// if not tmp then
116434: LD_VAR 0 2
116438: NOT
116439: IFFALSE 116443
// exit ;
116441: GO 116530
// un := tmp [ rand ( 1 , tmp ) ] ;
116443: LD_ADDR_VAR 0 1
116447: PUSH
116448: LD_VAR 0 2
116452: PUSH
116453: LD_INT 1
116455: PPUSH
116456: LD_VAR 0 2
116460: PPUSH
116461: CALL_OW 12
116465: ARRAY
116466: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116467: LD_VAR 0 1
116471: PPUSH
116472: LD_INT 0
116474: PPUSH
116475: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116479: LD_VAR 0 1
116483: PPUSH
116484: LD_OWVAR 3
116488: PUSH
116489: LD_VAR 0 1
116493: DIFF
116494: PPUSH
116495: LD_VAR 0 1
116499: PPUSH
116500: CALL_OW 74
116504: PPUSH
116505: CALL_OW 115
// wait ( 0 0$20 ) ;
116509: LD_INT 700
116511: PPUSH
116512: CALL_OW 67
// SetSide ( un , your_side ) ;
116516: LD_VAR 0 1
116520: PPUSH
116521: LD_OWVAR 2
116525: PPUSH
116526: CALL_OW 235
// end ;
116530: PPOPN 2
116532: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116533: LD_EXP 141
116537: PUSH
116538: LD_EXP 174
116542: AND
116543: IFFALSE 116649
116545: GO 116547
116547: DISABLE
116548: LD_INT 0
116550: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116551: LD_ADDR_VAR 0 1
116555: PUSH
116556: LD_INT 22
116558: PUSH
116559: LD_OWVAR 2
116563: PUSH
116564: EMPTY
116565: LIST
116566: LIST
116567: PUSH
116568: LD_INT 2
116570: PUSH
116571: LD_INT 30
116573: PUSH
116574: LD_INT 0
116576: PUSH
116577: EMPTY
116578: LIST
116579: LIST
116580: PUSH
116581: LD_INT 30
116583: PUSH
116584: LD_INT 1
116586: PUSH
116587: EMPTY
116588: LIST
116589: LIST
116590: PUSH
116591: EMPTY
116592: LIST
116593: LIST
116594: LIST
116595: PUSH
116596: EMPTY
116597: LIST
116598: LIST
116599: PPUSH
116600: CALL_OW 69
116604: ST_TO_ADDR
// if not depot then
116605: LD_VAR 0 1
116609: NOT
116610: IFFALSE 116614
// exit ;
116612: GO 116649
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116614: LD_VAR 0 1
116618: PUSH
116619: LD_INT 1
116621: ARRAY
116622: PPUSH
116623: CALL_OW 250
116627: PPUSH
116628: LD_VAR 0 1
116632: PUSH
116633: LD_INT 1
116635: ARRAY
116636: PPUSH
116637: CALL_OW 251
116641: PPUSH
116642: LD_INT 70
116644: PPUSH
116645: CALL_OW 495
// end ;
116649: PPOPN 1
116651: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116652: LD_EXP 141
116656: PUSH
116657: LD_EXP 175
116661: AND
116662: IFFALSE 116873
116664: GO 116666
116666: DISABLE
116667: LD_INT 0
116669: PPUSH
116670: PPUSH
116671: PPUSH
116672: PPUSH
116673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116674: LD_ADDR_VAR 0 5
116678: PUSH
116679: LD_INT 22
116681: PUSH
116682: LD_OWVAR 2
116686: PUSH
116687: EMPTY
116688: LIST
116689: LIST
116690: PUSH
116691: LD_INT 21
116693: PUSH
116694: LD_INT 1
116696: PUSH
116697: EMPTY
116698: LIST
116699: LIST
116700: PUSH
116701: EMPTY
116702: LIST
116703: LIST
116704: PPUSH
116705: CALL_OW 69
116709: ST_TO_ADDR
// if not tmp then
116710: LD_VAR 0 5
116714: NOT
116715: IFFALSE 116719
// exit ;
116717: GO 116873
// for i in tmp do
116719: LD_ADDR_VAR 0 1
116723: PUSH
116724: LD_VAR 0 5
116728: PUSH
116729: FOR_IN
116730: IFFALSE 116871
// begin d := rand ( 0 , 5 ) ;
116732: LD_ADDR_VAR 0 4
116736: PUSH
116737: LD_INT 0
116739: PPUSH
116740: LD_INT 5
116742: PPUSH
116743: CALL_OW 12
116747: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116748: LD_ADDR_VAR 0 2
116752: PUSH
116753: LD_VAR 0 1
116757: PPUSH
116758: CALL_OW 250
116762: PPUSH
116763: LD_VAR 0 4
116767: PPUSH
116768: LD_INT 3
116770: PPUSH
116771: LD_INT 12
116773: PPUSH
116774: CALL_OW 12
116778: PPUSH
116779: CALL_OW 272
116783: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116784: LD_ADDR_VAR 0 3
116788: PUSH
116789: LD_VAR 0 1
116793: PPUSH
116794: CALL_OW 251
116798: PPUSH
116799: LD_VAR 0 4
116803: PPUSH
116804: LD_INT 3
116806: PPUSH
116807: LD_INT 12
116809: PPUSH
116810: CALL_OW 12
116814: PPUSH
116815: CALL_OW 273
116819: ST_TO_ADDR
// if ValidHex ( x , y ) then
116820: LD_VAR 0 2
116824: PPUSH
116825: LD_VAR 0 3
116829: PPUSH
116830: CALL_OW 488
116834: IFFALSE 116869
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116836: LD_VAR 0 1
116840: PPUSH
116841: LD_VAR 0 2
116845: PPUSH
116846: LD_VAR 0 3
116850: PPUSH
116851: LD_INT 3
116853: PPUSH
116854: LD_INT 6
116856: PPUSH
116857: CALL_OW 12
116861: PPUSH
116862: LD_INT 1
116864: PPUSH
116865: CALL_OW 483
// end ;
116869: GO 116729
116871: POP
116872: POP
// end ;
116873: PPOPN 5
116875: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116876: LD_EXP 141
116880: PUSH
116881: LD_EXP 176
116885: AND
116886: IFFALSE 116980
116888: GO 116890
116890: DISABLE
116891: LD_INT 0
116893: PPUSH
116894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116895: LD_ADDR_VAR 0 2
116899: PUSH
116900: LD_INT 22
116902: PUSH
116903: LD_OWVAR 2
116907: PUSH
116908: EMPTY
116909: LIST
116910: LIST
116911: PUSH
116912: LD_INT 32
116914: PUSH
116915: LD_INT 1
116917: PUSH
116918: EMPTY
116919: LIST
116920: LIST
116921: PUSH
116922: LD_INT 21
116924: PUSH
116925: LD_INT 2
116927: PUSH
116928: EMPTY
116929: LIST
116930: LIST
116931: PUSH
116932: EMPTY
116933: LIST
116934: LIST
116935: LIST
116936: PPUSH
116937: CALL_OW 69
116941: ST_TO_ADDR
// if not tmp then
116942: LD_VAR 0 2
116946: NOT
116947: IFFALSE 116951
// exit ;
116949: GO 116980
// for i in tmp do
116951: LD_ADDR_VAR 0 1
116955: PUSH
116956: LD_VAR 0 2
116960: PUSH
116961: FOR_IN
116962: IFFALSE 116978
// SetFuel ( i , 0 ) ;
116964: LD_VAR 0 1
116968: PPUSH
116969: LD_INT 0
116971: PPUSH
116972: CALL_OW 240
116976: GO 116961
116978: POP
116979: POP
// end ;
116980: PPOPN 2
116982: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116983: LD_EXP 141
116987: PUSH
116988: LD_EXP 177
116992: AND
116993: IFFALSE 117059
116995: GO 116997
116997: DISABLE
116998: LD_INT 0
117000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
117001: LD_ADDR_VAR 0 1
117005: PUSH
117006: LD_INT 22
117008: PUSH
117009: LD_OWVAR 2
117013: PUSH
117014: EMPTY
117015: LIST
117016: LIST
117017: PUSH
117018: LD_INT 30
117020: PUSH
117021: LD_INT 29
117023: PUSH
117024: EMPTY
117025: LIST
117026: LIST
117027: PUSH
117028: EMPTY
117029: LIST
117030: LIST
117031: PPUSH
117032: CALL_OW 69
117036: ST_TO_ADDR
// if not tmp then
117037: LD_VAR 0 1
117041: NOT
117042: IFFALSE 117046
// exit ;
117044: GO 117059
// DestroyUnit ( tmp [ 1 ] ) ;
117046: LD_VAR 0 1
117050: PUSH
117051: LD_INT 1
117053: ARRAY
117054: PPUSH
117055: CALL_OW 65
// end ;
117059: PPOPN 1
117061: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
117062: LD_EXP 141
117066: PUSH
117067: LD_EXP 179
117071: AND
117072: IFFALSE 117201
117074: GO 117076
117076: DISABLE
117077: LD_INT 0
117079: PPUSH
// begin uc_side := 0 ;
117080: LD_ADDR_OWVAR 20
117084: PUSH
117085: LD_INT 0
117087: ST_TO_ADDR
// uc_nation := nation_arabian ;
117088: LD_ADDR_OWVAR 21
117092: PUSH
117093: LD_INT 2
117095: ST_TO_ADDR
// hc_gallery :=  ;
117096: LD_ADDR_OWVAR 33
117100: PUSH
117101: LD_STRING 
117103: ST_TO_ADDR
// hc_name :=  ;
117104: LD_ADDR_OWVAR 26
117108: PUSH
117109: LD_STRING 
117111: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
117112: LD_INT 1
117114: PPUSH
117115: LD_INT 11
117117: PPUSH
117118: LD_INT 10
117120: PPUSH
117121: CALL_OW 380
// un := CreateHuman ;
117125: LD_ADDR_VAR 0 1
117129: PUSH
117130: CALL_OW 44
117134: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117135: LD_VAR 0 1
117139: PPUSH
117140: LD_INT 1
117142: PPUSH
117143: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117147: LD_INT 35
117149: PPUSH
117150: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117154: LD_VAR 0 1
117158: PPUSH
117159: LD_INT 22
117161: PUSH
117162: LD_OWVAR 2
117166: PUSH
117167: EMPTY
117168: LIST
117169: LIST
117170: PPUSH
117171: CALL_OW 69
117175: PPUSH
117176: LD_VAR 0 1
117180: PPUSH
117181: CALL_OW 74
117185: PPUSH
117186: CALL_OW 115
// until IsDead ( un ) ;
117190: LD_VAR 0 1
117194: PPUSH
117195: CALL_OW 301
117199: IFFALSE 117147
// end ;
117201: PPOPN 1
117203: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
117204: LD_EXP 141
117208: PUSH
117209: LD_EXP 181
117213: AND
117214: IFFALSE 117226
117216: GO 117218
117218: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
117219: LD_STRING earthquake(getX(game), 0, 32)
117221: PPUSH
117222: CALL_OW 559
117226: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
117227: LD_EXP 141
117231: PUSH
117232: LD_EXP 182
117236: AND
117237: IFFALSE 117328
117239: GO 117241
117241: DISABLE
117242: LD_INT 0
117244: PPUSH
// begin enable ;
117245: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
117246: LD_ADDR_VAR 0 1
117250: PUSH
117251: LD_INT 22
117253: PUSH
117254: LD_OWVAR 2
117258: PUSH
117259: EMPTY
117260: LIST
117261: LIST
117262: PUSH
117263: LD_INT 21
117265: PUSH
117266: LD_INT 2
117268: PUSH
117269: EMPTY
117270: LIST
117271: LIST
117272: PUSH
117273: LD_INT 33
117275: PUSH
117276: LD_INT 3
117278: PUSH
117279: EMPTY
117280: LIST
117281: LIST
117282: PUSH
117283: EMPTY
117284: LIST
117285: LIST
117286: LIST
117287: PPUSH
117288: CALL_OW 69
117292: ST_TO_ADDR
// if not tmp then
117293: LD_VAR 0 1
117297: NOT
117298: IFFALSE 117302
// exit ;
117300: GO 117328
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117302: LD_VAR 0 1
117306: PUSH
117307: LD_INT 1
117309: PPUSH
117310: LD_VAR 0 1
117314: PPUSH
117315: CALL_OW 12
117319: ARRAY
117320: PPUSH
117321: LD_INT 1
117323: PPUSH
117324: CALL_OW 234
// end ;
117328: PPOPN 1
117330: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
117331: LD_EXP 141
117335: PUSH
117336: LD_EXP 183
117340: AND
117341: IFFALSE 117482
117343: GO 117345
117345: DISABLE
117346: LD_INT 0
117348: PPUSH
117349: PPUSH
117350: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117351: LD_ADDR_VAR 0 3
117355: PUSH
117356: LD_INT 22
117358: PUSH
117359: LD_OWVAR 2
117363: PUSH
117364: EMPTY
117365: LIST
117366: LIST
117367: PUSH
117368: LD_INT 25
117370: PUSH
117371: LD_INT 1
117373: PUSH
117374: EMPTY
117375: LIST
117376: LIST
117377: PUSH
117378: EMPTY
117379: LIST
117380: LIST
117381: PPUSH
117382: CALL_OW 69
117386: ST_TO_ADDR
// if not tmp then
117387: LD_VAR 0 3
117391: NOT
117392: IFFALSE 117396
// exit ;
117394: GO 117482
// un := tmp [ rand ( 1 , tmp ) ] ;
117396: LD_ADDR_VAR 0 2
117400: PUSH
117401: LD_VAR 0 3
117405: PUSH
117406: LD_INT 1
117408: PPUSH
117409: LD_VAR 0 3
117413: PPUSH
117414: CALL_OW 12
117418: ARRAY
117419: ST_TO_ADDR
// if Crawls ( un ) then
117420: LD_VAR 0 2
117424: PPUSH
117425: CALL_OW 318
117429: IFFALSE 117440
// ComWalk ( un ) ;
117431: LD_VAR 0 2
117435: PPUSH
117436: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117440: LD_VAR 0 2
117444: PPUSH
117445: LD_INT 9
117447: PPUSH
117448: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117452: LD_INT 28
117454: PPUSH
117455: LD_OWVAR 2
117459: PPUSH
117460: LD_INT 2
117462: PPUSH
117463: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117467: LD_INT 29
117469: PPUSH
117470: LD_OWVAR 2
117474: PPUSH
117475: LD_INT 2
117477: PPUSH
117478: CALL_OW 322
// end ;
117482: PPOPN 3
117484: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117485: LD_EXP 141
117489: PUSH
117490: LD_EXP 184
117494: AND
117495: IFFALSE 117606
117497: GO 117499
117499: DISABLE
117500: LD_INT 0
117502: PPUSH
117503: PPUSH
117504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117505: LD_ADDR_VAR 0 3
117509: PUSH
117510: LD_INT 22
117512: PUSH
117513: LD_OWVAR 2
117517: PUSH
117518: EMPTY
117519: LIST
117520: LIST
117521: PUSH
117522: LD_INT 25
117524: PUSH
117525: LD_INT 1
117527: PUSH
117528: EMPTY
117529: LIST
117530: LIST
117531: PUSH
117532: EMPTY
117533: LIST
117534: LIST
117535: PPUSH
117536: CALL_OW 69
117540: ST_TO_ADDR
// if not tmp then
117541: LD_VAR 0 3
117545: NOT
117546: IFFALSE 117550
// exit ;
117548: GO 117606
// un := tmp [ rand ( 1 , tmp ) ] ;
117550: LD_ADDR_VAR 0 2
117554: PUSH
117555: LD_VAR 0 3
117559: PUSH
117560: LD_INT 1
117562: PPUSH
117563: LD_VAR 0 3
117567: PPUSH
117568: CALL_OW 12
117572: ARRAY
117573: ST_TO_ADDR
// if Crawls ( un ) then
117574: LD_VAR 0 2
117578: PPUSH
117579: CALL_OW 318
117583: IFFALSE 117594
// ComWalk ( un ) ;
117585: LD_VAR 0 2
117589: PPUSH
117590: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117594: LD_VAR 0 2
117598: PPUSH
117599: LD_INT 8
117601: PPUSH
117602: CALL_OW 336
// end ;
117606: PPOPN 3
117608: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117609: LD_EXP 141
117613: PUSH
117614: LD_EXP 185
117618: AND
117619: IFFALSE 117763
117621: GO 117623
117623: DISABLE
117624: LD_INT 0
117626: PPUSH
117627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117628: LD_ADDR_VAR 0 2
117632: PUSH
117633: LD_INT 22
117635: PUSH
117636: LD_OWVAR 2
117640: PUSH
117641: EMPTY
117642: LIST
117643: LIST
117644: PUSH
117645: LD_INT 21
117647: PUSH
117648: LD_INT 2
117650: PUSH
117651: EMPTY
117652: LIST
117653: LIST
117654: PUSH
117655: LD_INT 2
117657: PUSH
117658: LD_INT 34
117660: PUSH
117661: LD_INT 12
117663: PUSH
117664: EMPTY
117665: LIST
117666: LIST
117667: PUSH
117668: LD_INT 34
117670: PUSH
117671: LD_INT 51
117673: PUSH
117674: EMPTY
117675: LIST
117676: LIST
117677: PUSH
117678: LD_INT 34
117680: PUSH
117681: LD_INT 32
117683: PUSH
117684: EMPTY
117685: LIST
117686: LIST
117687: PUSH
117688: EMPTY
117689: LIST
117690: LIST
117691: LIST
117692: LIST
117693: PUSH
117694: EMPTY
117695: LIST
117696: LIST
117697: LIST
117698: PPUSH
117699: CALL_OW 69
117703: ST_TO_ADDR
// if not tmp then
117704: LD_VAR 0 2
117708: NOT
117709: IFFALSE 117713
// exit ;
117711: GO 117763
// for i in tmp do
117713: LD_ADDR_VAR 0 1
117717: PUSH
117718: LD_VAR 0 2
117722: PUSH
117723: FOR_IN
117724: IFFALSE 117761
// if GetCargo ( i , mat_artifact ) = 0 then
117726: LD_VAR 0 1
117730: PPUSH
117731: LD_INT 4
117733: PPUSH
117734: CALL_OW 289
117738: PUSH
117739: LD_INT 0
117741: EQUAL
117742: IFFALSE 117759
// SetCargo ( i , mat_siberit , 100 ) ;
117744: LD_VAR 0 1
117748: PPUSH
117749: LD_INT 3
117751: PPUSH
117752: LD_INT 100
117754: PPUSH
117755: CALL_OW 290
117759: GO 117723
117761: POP
117762: POP
// end ;
117763: PPOPN 2
117765: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117766: LD_EXP 141
117770: PUSH
117771: LD_EXP 186
117775: AND
117776: IFFALSE 117959
117778: GO 117780
117780: DISABLE
117781: LD_INT 0
117783: PPUSH
117784: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117785: LD_ADDR_VAR 0 2
117789: PUSH
117790: LD_INT 22
117792: PUSH
117793: LD_OWVAR 2
117797: PUSH
117798: EMPTY
117799: LIST
117800: LIST
117801: PPUSH
117802: CALL_OW 69
117806: ST_TO_ADDR
// if not tmp then
117807: LD_VAR 0 2
117811: NOT
117812: IFFALSE 117816
// exit ;
117814: GO 117959
// for i := 1 to 2 do
117816: LD_ADDR_VAR 0 1
117820: PUSH
117821: DOUBLE
117822: LD_INT 1
117824: DEC
117825: ST_TO_ADDR
117826: LD_INT 2
117828: PUSH
117829: FOR_TO
117830: IFFALSE 117957
// begin uc_side := your_side ;
117832: LD_ADDR_OWVAR 20
117836: PUSH
117837: LD_OWVAR 2
117841: ST_TO_ADDR
// uc_nation := nation_american ;
117842: LD_ADDR_OWVAR 21
117846: PUSH
117847: LD_INT 1
117849: ST_TO_ADDR
// vc_chassis := us_morphling ;
117850: LD_ADDR_OWVAR 37
117854: PUSH
117855: LD_INT 5
117857: ST_TO_ADDR
// vc_engine := engine_siberite ;
117858: LD_ADDR_OWVAR 39
117862: PUSH
117863: LD_INT 3
117865: ST_TO_ADDR
// vc_control := control_computer ;
117866: LD_ADDR_OWVAR 38
117870: PUSH
117871: LD_INT 3
117873: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117874: LD_ADDR_OWVAR 40
117878: PUSH
117879: LD_INT 10
117881: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
117882: LD_VAR 0 2
117886: PUSH
117887: LD_INT 1
117889: ARRAY
117890: PPUSH
117891: CALL_OW 310
117895: NOT
117896: IFFALSE 117943
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
117898: CALL_OW 45
117902: PPUSH
117903: LD_VAR 0 2
117907: PUSH
117908: LD_INT 1
117910: ARRAY
117911: PPUSH
117912: CALL_OW 250
117916: PPUSH
117917: LD_VAR 0 2
117921: PUSH
117922: LD_INT 1
117924: ARRAY
117925: PPUSH
117926: CALL_OW 251
117930: PPUSH
117931: LD_INT 12
117933: PPUSH
117934: LD_INT 1
117936: PPUSH
117937: CALL_OW 50
117941: GO 117955
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
117943: CALL_OW 45
117947: PPUSH
117948: LD_INT 1
117950: PPUSH
117951: CALL_OW 51
// end ;
117955: GO 117829
117957: POP
117958: POP
// end ;
117959: PPOPN 2
117961: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117962: LD_EXP 141
117966: PUSH
117967: LD_EXP 187
117971: AND
117972: IFFALSE 118194
117974: GO 117976
117976: DISABLE
117977: LD_INT 0
117979: PPUSH
117980: PPUSH
117981: PPUSH
117982: PPUSH
117983: PPUSH
117984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117985: LD_ADDR_VAR 0 6
117989: PUSH
117990: LD_INT 22
117992: PUSH
117993: LD_OWVAR 2
117997: PUSH
117998: EMPTY
117999: LIST
118000: LIST
118001: PUSH
118002: LD_INT 21
118004: PUSH
118005: LD_INT 1
118007: PUSH
118008: EMPTY
118009: LIST
118010: LIST
118011: PUSH
118012: LD_INT 3
118014: PUSH
118015: LD_INT 23
118017: PUSH
118018: LD_INT 0
118020: PUSH
118021: EMPTY
118022: LIST
118023: LIST
118024: PUSH
118025: EMPTY
118026: LIST
118027: LIST
118028: PUSH
118029: EMPTY
118030: LIST
118031: LIST
118032: LIST
118033: PPUSH
118034: CALL_OW 69
118038: ST_TO_ADDR
// if not tmp then
118039: LD_VAR 0 6
118043: NOT
118044: IFFALSE 118048
// exit ;
118046: GO 118194
// s1 := rand ( 1 , 4 ) ;
118048: LD_ADDR_VAR 0 2
118052: PUSH
118053: LD_INT 1
118055: PPUSH
118056: LD_INT 4
118058: PPUSH
118059: CALL_OW 12
118063: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
118064: LD_ADDR_VAR 0 4
118068: PUSH
118069: LD_VAR 0 6
118073: PUSH
118074: LD_INT 1
118076: ARRAY
118077: PPUSH
118078: LD_VAR 0 2
118082: PPUSH
118083: CALL_OW 259
118087: ST_TO_ADDR
// if s1 = 1 then
118088: LD_VAR 0 2
118092: PUSH
118093: LD_INT 1
118095: EQUAL
118096: IFFALSE 118116
// s2 := rand ( 2 , 4 ) else
118098: LD_ADDR_VAR 0 3
118102: PUSH
118103: LD_INT 2
118105: PPUSH
118106: LD_INT 4
118108: PPUSH
118109: CALL_OW 12
118113: ST_TO_ADDR
118114: GO 118124
// s2 := 1 ;
118116: LD_ADDR_VAR 0 3
118120: PUSH
118121: LD_INT 1
118123: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
118124: LD_ADDR_VAR 0 5
118128: PUSH
118129: LD_VAR 0 6
118133: PUSH
118134: LD_INT 1
118136: ARRAY
118137: PPUSH
118138: LD_VAR 0 3
118142: PPUSH
118143: CALL_OW 259
118147: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
118148: LD_VAR 0 6
118152: PUSH
118153: LD_INT 1
118155: ARRAY
118156: PPUSH
118157: LD_VAR 0 2
118161: PPUSH
118162: LD_VAR 0 5
118166: PPUSH
118167: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
118171: LD_VAR 0 6
118175: PUSH
118176: LD_INT 1
118178: ARRAY
118179: PPUSH
118180: LD_VAR 0 3
118184: PPUSH
118185: LD_VAR 0 4
118189: PPUSH
118190: CALL_OW 237
// end ;
118194: PPOPN 6
118196: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
118197: LD_EXP 141
118201: PUSH
118202: LD_EXP 188
118206: AND
118207: IFFALSE 118286
118209: GO 118211
118211: DISABLE
118212: LD_INT 0
118214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
118215: LD_ADDR_VAR 0 1
118219: PUSH
118220: LD_INT 22
118222: PUSH
118223: LD_OWVAR 2
118227: PUSH
118228: EMPTY
118229: LIST
118230: LIST
118231: PUSH
118232: LD_INT 30
118234: PUSH
118235: LD_INT 3
118237: PUSH
118238: EMPTY
118239: LIST
118240: LIST
118241: PUSH
118242: EMPTY
118243: LIST
118244: LIST
118245: PPUSH
118246: CALL_OW 69
118250: ST_TO_ADDR
// if not tmp then
118251: LD_VAR 0 1
118255: NOT
118256: IFFALSE 118260
// exit ;
118258: GO 118286
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118260: LD_VAR 0 1
118264: PUSH
118265: LD_INT 1
118267: PPUSH
118268: LD_VAR 0 1
118272: PPUSH
118273: CALL_OW 12
118277: ARRAY
118278: PPUSH
118279: LD_INT 1
118281: PPUSH
118282: CALL_OW 234
// end ;
118286: PPOPN 1
118288: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
118289: LD_EXP 141
118293: PUSH
118294: LD_EXP 189
118298: AND
118299: IFFALSE 118411
118301: GO 118303
118303: DISABLE
118304: LD_INT 0
118306: PPUSH
118307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
118308: LD_ADDR_VAR 0 2
118312: PUSH
118313: LD_INT 22
118315: PUSH
118316: LD_OWVAR 2
118320: PUSH
118321: EMPTY
118322: LIST
118323: LIST
118324: PUSH
118325: LD_INT 2
118327: PUSH
118328: LD_INT 30
118330: PUSH
118331: LD_INT 27
118333: PUSH
118334: EMPTY
118335: LIST
118336: LIST
118337: PUSH
118338: LD_INT 30
118340: PUSH
118341: LD_INT 26
118343: PUSH
118344: EMPTY
118345: LIST
118346: LIST
118347: PUSH
118348: LD_INT 30
118350: PUSH
118351: LD_INT 28
118353: PUSH
118354: EMPTY
118355: LIST
118356: LIST
118357: PUSH
118358: EMPTY
118359: LIST
118360: LIST
118361: LIST
118362: LIST
118363: PUSH
118364: EMPTY
118365: LIST
118366: LIST
118367: PPUSH
118368: CALL_OW 69
118372: ST_TO_ADDR
// if not tmp then
118373: LD_VAR 0 2
118377: NOT
118378: IFFALSE 118382
// exit ;
118380: GO 118411
// for i in tmp do
118382: LD_ADDR_VAR 0 1
118386: PUSH
118387: LD_VAR 0 2
118391: PUSH
118392: FOR_IN
118393: IFFALSE 118409
// SetLives ( i , 1 ) ;
118395: LD_VAR 0 1
118399: PPUSH
118400: LD_INT 1
118402: PPUSH
118403: CALL_OW 234
118407: GO 118392
118409: POP
118410: POP
// end ;
118411: PPOPN 2
118413: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118414: LD_EXP 141
118418: PUSH
118419: LD_EXP 190
118423: AND
118424: IFFALSE 118711
118426: GO 118428
118428: DISABLE
118429: LD_INT 0
118431: PPUSH
118432: PPUSH
118433: PPUSH
// begin i := rand ( 1 , 7 ) ;
118434: LD_ADDR_VAR 0 1
118438: PUSH
118439: LD_INT 1
118441: PPUSH
118442: LD_INT 7
118444: PPUSH
118445: CALL_OW 12
118449: ST_TO_ADDR
// case i of 1 :
118450: LD_VAR 0 1
118454: PUSH
118455: LD_INT 1
118457: DOUBLE
118458: EQUAL
118459: IFTRUE 118463
118461: GO 118473
118463: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118464: LD_STRING earthquake(getX(game), 0, 32)
118466: PPUSH
118467: CALL_OW 559
118471: GO 118711
118473: LD_INT 2
118475: DOUBLE
118476: EQUAL
118477: IFTRUE 118481
118479: GO 118495
118481: POP
// begin ToLua ( displayStucuk(); ) ;
118482: LD_STRING displayStucuk();
118484: PPUSH
118485: CALL_OW 559
// ResetFog ;
118489: CALL_OW 335
// end ; 3 :
118493: GO 118711
118495: LD_INT 3
118497: DOUBLE
118498: EQUAL
118499: IFTRUE 118503
118501: GO 118607
118503: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118504: LD_ADDR_VAR 0 2
118508: PUSH
118509: LD_INT 22
118511: PUSH
118512: LD_OWVAR 2
118516: PUSH
118517: EMPTY
118518: LIST
118519: LIST
118520: PUSH
118521: LD_INT 25
118523: PUSH
118524: LD_INT 1
118526: PUSH
118527: EMPTY
118528: LIST
118529: LIST
118530: PUSH
118531: EMPTY
118532: LIST
118533: LIST
118534: PPUSH
118535: CALL_OW 69
118539: ST_TO_ADDR
// if not tmp then
118540: LD_VAR 0 2
118544: NOT
118545: IFFALSE 118549
// exit ;
118547: GO 118711
// un := tmp [ rand ( 1 , tmp ) ] ;
118549: LD_ADDR_VAR 0 3
118553: PUSH
118554: LD_VAR 0 2
118558: PUSH
118559: LD_INT 1
118561: PPUSH
118562: LD_VAR 0 2
118566: PPUSH
118567: CALL_OW 12
118571: ARRAY
118572: ST_TO_ADDR
// if Crawls ( un ) then
118573: LD_VAR 0 3
118577: PPUSH
118578: CALL_OW 318
118582: IFFALSE 118593
// ComWalk ( un ) ;
118584: LD_VAR 0 3
118588: PPUSH
118589: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118593: LD_VAR 0 3
118597: PPUSH
118598: LD_INT 8
118600: PPUSH
118601: CALL_OW 336
// end ; 4 :
118605: GO 118711
118607: LD_INT 4
118609: DOUBLE
118610: EQUAL
118611: IFTRUE 118615
118613: GO 118689
118615: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118616: LD_ADDR_VAR 0 2
118620: PUSH
118621: LD_INT 22
118623: PUSH
118624: LD_OWVAR 2
118628: PUSH
118629: EMPTY
118630: LIST
118631: LIST
118632: PUSH
118633: LD_INT 30
118635: PUSH
118636: LD_INT 29
118638: PUSH
118639: EMPTY
118640: LIST
118641: LIST
118642: PUSH
118643: EMPTY
118644: LIST
118645: LIST
118646: PPUSH
118647: CALL_OW 69
118651: ST_TO_ADDR
// if not tmp then
118652: LD_VAR 0 2
118656: NOT
118657: IFFALSE 118661
// exit ;
118659: GO 118711
// CenterNowOnUnits ( tmp [ 1 ] ) ;
118661: LD_VAR 0 2
118665: PUSH
118666: LD_INT 1
118668: ARRAY
118669: PPUSH
118670: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
118674: LD_VAR 0 2
118678: PUSH
118679: LD_INT 1
118681: ARRAY
118682: PPUSH
118683: CALL_OW 65
// end ; 5 .. 7 :
118687: GO 118711
118689: LD_INT 5
118691: DOUBLE
118692: GREATEREQUAL
118693: IFFALSE 118701
118695: LD_INT 7
118697: DOUBLE
118698: LESSEQUAL
118699: IFTRUE 118703
118701: GO 118710
118703: POP
// StreamSibBomb ; end ;
118704: CALL 114948 0 0
118708: GO 118711
118710: POP
// end ;
118711: PPOPN 3
118713: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118714: LD_EXP 141
118718: PUSH
118719: LD_EXP 191
118723: AND
118724: IFFALSE 118880
118726: GO 118728
118728: DISABLE
118729: LD_INT 0
118731: PPUSH
118732: PPUSH
118733: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118734: LD_ADDR_VAR 0 2
118738: PUSH
118739: LD_INT 81
118741: PUSH
118742: LD_OWVAR 2
118746: PUSH
118747: EMPTY
118748: LIST
118749: LIST
118750: PUSH
118751: LD_INT 2
118753: PUSH
118754: LD_INT 21
118756: PUSH
118757: LD_INT 1
118759: PUSH
118760: EMPTY
118761: LIST
118762: LIST
118763: PUSH
118764: LD_INT 21
118766: PUSH
118767: LD_INT 2
118769: PUSH
118770: EMPTY
118771: LIST
118772: LIST
118773: PUSH
118774: EMPTY
118775: LIST
118776: LIST
118777: LIST
118778: PUSH
118779: EMPTY
118780: LIST
118781: LIST
118782: PPUSH
118783: CALL_OW 69
118787: ST_TO_ADDR
// if not tmp then
118788: LD_VAR 0 2
118792: NOT
118793: IFFALSE 118797
// exit ;
118795: GO 118880
// p := 0 ;
118797: LD_ADDR_VAR 0 3
118801: PUSH
118802: LD_INT 0
118804: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118805: LD_INT 35
118807: PPUSH
118808: CALL_OW 67
// p := p + 1 ;
118812: LD_ADDR_VAR 0 3
118816: PUSH
118817: LD_VAR 0 3
118821: PUSH
118822: LD_INT 1
118824: PLUS
118825: ST_TO_ADDR
// for i in tmp do
118826: LD_ADDR_VAR 0 1
118830: PUSH
118831: LD_VAR 0 2
118835: PUSH
118836: FOR_IN
118837: IFFALSE 118868
// if GetLives ( i ) < 1000 then
118839: LD_VAR 0 1
118843: PPUSH
118844: CALL_OW 256
118848: PUSH
118849: LD_INT 1000
118851: LESS
118852: IFFALSE 118866
// SetLives ( i , 1000 ) ;
118854: LD_VAR 0 1
118858: PPUSH
118859: LD_INT 1000
118861: PPUSH
118862: CALL_OW 234
118866: GO 118836
118868: POP
118869: POP
// until p > 20 ;
118870: LD_VAR 0 3
118874: PUSH
118875: LD_INT 20
118877: GREATER
118878: IFFALSE 118805
// end ;
118880: PPOPN 3
118882: END
// every 0 0$1 trigger StreamModeActive and sTime do
118883: LD_EXP 141
118887: PUSH
118888: LD_EXP 192
118892: AND
118893: IFFALSE 118928
118895: GO 118897
118897: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118898: LD_INT 28
118900: PPUSH
118901: LD_OWVAR 2
118905: PPUSH
118906: LD_INT 2
118908: PPUSH
118909: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118913: LD_INT 30
118915: PPUSH
118916: LD_OWVAR 2
118920: PPUSH
118921: LD_INT 2
118923: PPUSH
118924: CALL_OW 322
// end ;
118928: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118929: LD_EXP 141
118933: PUSH
118934: LD_EXP 193
118938: AND
118939: IFFALSE 119060
118941: GO 118943
118943: DISABLE
118944: LD_INT 0
118946: PPUSH
118947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118948: LD_ADDR_VAR 0 2
118952: PUSH
118953: LD_INT 22
118955: PUSH
118956: LD_OWVAR 2
118960: PUSH
118961: EMPTY
118962: LIST
118963: LIST
118964: PUSH
118965: LD_INT 21
118967: PUSH
118968: LD_INT 1
118970: PUSH
118971: EMPTY
118972: LIST
118973: LIST
118974: PUSH
118975: LD_INT 3
118977: PUSH
118978: LD_INT 23
118980: PUSH
118981: LD_INT 0
118983: PUSH
118984: EMPTY
118985: LIST
118986: LIST
118987: PUSH
118988: EMPTY
118989: LIST
118990: LIST
118991: PUSH
118992: EMPTY
118993: LIST
118994: LIST
118995: LIST
118996: PPUSH
118997: CALL_OW 69
119001: ST_TO_ADDR
// if not tmp then
119002: LD_VAR 0 2
119006: NOT
119007: IFFALSE 119011
// exit ;
119009: GO 119060
// for i in tmp do
119011: LD_ADDR_VAR 0 1
119015: PUSH
119016: LD_VAR 0 2
119020: PUSH
119021: FOR_IN
119022: IFFALSE 119058
// begin if Crawls ( i ) then
119024: LD_VAR 0 1
119028: PPUSH
119029: CALL_OW 318
119033: IFFALSE 119044
// ComWalk ( i ) ;
119035: LD_VAR 0 1
119039: PPUSH
119040: CALL_OW 138
// SetClass ( i , 2 ) ;
119044: LD_VAR 0 1
119048: PPUSH
119049: LD_INT 2
119051: PPUSH
119052: CALL_OW 336
// end ;
119056: GO 119021
119058: POP
119059: POP
// end ;
119060: PPOPN 2
119062: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
119063: LD_EXP 141
119067: PUSH
119068: LD_EXP 194
119072: AND
119073: IFFALSE 119361
119075: GO 119077
119077: DISABLE
119078: LD_INT 0
119080: PPUSH
119081: PPUSH
119082: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
119083: LD_OWVAR 2
119087: PPUSH
119088: LD_INT 9
119090: PPUSH
119091: LD_INT 1
119093: PPUSH
119094: LD_INT 1
119096: PPUSH
119097: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
119101: LD_INT 9
119103: PPUSH
119104: LD_OWVAR 2
119108: PPUSH
119109: CALL_OW 343
// uc_side := 9 ;
119113: LD_ADDR_OWVAR 20
119117: PUSH
119118: LD_INT 9
119120: ST_TO_ADDR
// uc_nation := 2 ;
119121: LD_ADDR_OWVAR 21
119125: PUSH
119126: LD_INT 2
119128: ST_TO_ADDR
// hc_name := Dark Warrior ;
119129: LD_ADDR_OWVAR 26
119133: PUSH
119134: LD_STRING Dark Warrior
119136: ST_TO_ADDR
// hc_gallery :=  ;
119137: LD_ADDR_OWVAR 33
119141: PUSH
119142: LD_STRING 
119144: ST_TO_ADDR
// hc_noskilllimit := true ;
119145: LD_ADDR_OWVAR 76
119149: PUSH
119150: LD_INT 1
119152: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
119153: LD_ADDR_OWVAR 31
119157: PUSH
119158: LD_INT 30
119160: PUSH
119161: LD_INT 30
119163: PUSH
119164: LD_INT 30
119166: PUSH
119167: LD_INT 30
119169: PUSH
119170: EMPTY
119171: LIST
119172: LIST
119173: LIST
119174: LIST
119175: ST_TO_ADDR
// un := CreateHuman ;
119176: LD_ADDR_VAR 0 3
119180: PUSH
119181: CALL_OW 44
119185: ST_TO_ADDR
// hc_noskilllimit := false ;
119186: LD_ADDR_OWVAR 76
119190: PUSH
119191: LD_INT 0
119193: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119194: LD_VAR 0 3
119198: PPUSH
119199: LD_INT 1
119201: PPUSH
119202: CALL_OW 51
// ToLua ( playRanger() ) ;
119206: LD_STRING playRanger()
119208: PPUSH
119209: CALL_OW 559
// p := 0 ;
119213: LD_ADDR_VAR 0 2
119217: PUSH
119218: LD_INT 0
119220: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
119221: LD_INT 35
119223: PPUSH
119224: CALL_OW 67
// p := p + 1 ;
119228: LD_ADDR_VAR 0 2
119232: PUSH
119233: LD_VAR 0 2
119237: PUSH
119238: LD_INT 1
119240: PLUS
119241: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
119242: LD_VAR 0 3
119246: PPUSH
119247: CALL_OW 256
119251: PUSH
119252: LD_INT 1000
119254: LESS
119255: IFFALSE 119269
// SetLives ( un , 1000 ) ;
119257: LD_VAR 0 3
119261: PPUSH
119262: LD_INT 1000
119264: PPUSH
119265: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
119269: LD_VAR 0 3
119273: PPUSH
119274: LD_INT 81
119276: PUSH
119277: LD_OWVAR 2
119281: PUSH
119282: EMPTY
119283: LIST
119284: LIST
119285: PUSH
119286: LD_INT 91
119288: PUSH
119289: LD_VAR 0 3
119293: PUSH
119294: LD_INT 30
119296: PUSH
119297: EMPTY
119298: LIST
119299: LIST
119300: LIST
119301: PUSH
119302: EMPTY
119303: LIST
119304: LIST
119305: PPUSH
119306: CALL_OW 69
119310: PPUSH
119311: LD_VAR 0 3
119315: PPUSH
119316: CALL_OW 74
119320: PPUSH
119321: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
119325: LD_VAR 0 2
119329: PUSH
119330: LD_INT 80
119332: GREATER
119333: PUSH
119334: LD_VAR 0 3
119338: PPUSH
119339: CALL_OW 301
119343: OR
119344: IFFALSE 119221
// if un then
119346: LD_VAR 0 3
119350: IFFALSE 119361
// RemoveUnit ( un ) ;
119352: LD_VAR 0 3
119356: PPUSH
119357: CALL_OW 64
// end ;
119361: PPOPN 3
119363: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
119364: LD_EXP 195
119368: IFFALSE 119484
119370: GO 119372
119372: DISABLE
119373: LD_INT 0
119375: PPUSH
119376: PPUSH
119377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119378: LD_ADDR_VAR 0 2
119382: PUSH
119383: LD_INT 81
119385: PUSH
119386: LD_OWVAR 2
119390: PUSH
119391: EMPTY
119392: LIST
119393: LIST
119394: PUSH
119395: LD_INT 21
119397: PUSH
119398: LD_INT 1
119400: PUSH
119401: EMPTY
119402: LIST
119403: LIST
119404: PUSH
119405: EMPTY
119406: LIST
119407: LIST
119408: PPUSH
119409: CALL_OW 69
119413: ST_TO_ADDR
// ToLua ( playComputer() ) ;
119414: LD_STRING playComputer()
119416: PPUSH
119417: CALL_OW 559
// if not tmp then
119421: LD_VAR 0 2
119425: NOT
119426: IFFALSE 119430
// exit ;
119428: GO 119484
// for i in tmp do
119430: LD_ADDR_VAR 0 1
119434: PUSH
119435: LD_VAR 0 2
119439: PUSH
119440: FOR_IN
119441: IFFALSE 119482
// for j := 1 to 4 do
119443: LD_ADDR_VAR 0 3
119447: PUSH
119448: DOUBLE
119449: LD_INT 1
119451: DEC
119452: ST_TO_ADDR
119453: LD_INT 4
119455: PUSH
119456: FOR_TO
119457: IFFALSE 119478
// SetSkill ( i , j , 10 ) ;
119459: LD_VAR 0 1
119463: PPUSH
119464: LD_VAR 0 3
119468: PPUSH
119469: LD_INT 10
119471: PPUSH
119472: CALL_OW 237
119476: GO 119456
119478: POP
119479: POP
119480: GO 119440
119482: POP
119483: POP
// end ;
119484: PPOPN 3
119486: END
// every 0 0$1 trigger s30 do var i , tmp ;
119487: LD_EXP 196
119491: IFFALSE 119560
119493: GO 119495
119495: DISABLE
119496: LD_INT 0
119498: PPUSH
119499: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119500: LD_ADDR_VAR 0 2
119504: PUSH
119505: LD_INT 22
119507: PUSH
119508: LD_OWVAR 2
119512: PUSH
119513: EMPTY
119514: LIST
119515: LIST
119516: PPUSH
119517: CALL_OW 69
119521: ST_TO_ADDR
// if not tmp then
119522: LD_VAR 0 2
119526: NOT
119527: IFFALSE 119531
// exit ;
119529: GO 119560
// for i in tmp do
119531: LD_ADDR_VAR 0 1
119535: PUSH
119536: LD_VAR 0 2
119540: PUSH
119541: FOR_IN
119542: IFFALSE 119558
// SetLives ( i , 300 ) ;
119544: LD_VAR 0 1
119548: PPUSH
119549: LD_INT 300
119551: PPUSH
119552: CALL_OW 234
119556: GO 119541
119558: POP
119559: POP
// end ;
119560: PPOPN 2
119562: END
// every 0 0$1 trigger s60 do var i , tmp ;
119563: LD_EXP 197
119567: IFFALSE 119636
119569: GO 119571
119571: DISABLE
119572: LD_INT 0
119574: PPUSH
119575: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119576: LD_ADDR_VAR 0 2
119580: PUSH
119581: LD_INT 22
119583: PUSH
119584: LD_OWVAR 2
119588: PUSH
119589: EMPTY
119590: LIST
119591: LIST
119592: PPUSH
119593: CALL_OW 69
119597: ST_TO_ADDR
// if not tmp then
119598: LD_VAR 0 2
119602: NOT
119603: IFFALSE 119607
// exit ;
119605: GO 119636
// for i in tmp do
119607: LD_ADDR_VAR 0 1
119611: PUSH
119612: LD_VAR 0 2
119616: PUSH
119617: FOR_IN
119618: IFFALSE 119634
// SetLives ( i , 600 ) ;
119620: LD_VAR 0 1
119624: PPUSH
119625: LD_INT 600
119627: PPUSH
119628: CALL_OW 234
119632: GO 119617
119634: POP
119635: POP
// end ;
119636: PPOPN 2
119638: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
119639: LD_INT 0
119641: PPUSH
// case cmd of 301 :
119642: LD_VAR 0 1
119646: PUSH
119647: LD_INT 301
119649: DOUBLE
119650: EQUAL
119651: IFTRUE 119655
119653: GO 119687
119655: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
119656: LD_VAR 0 6
119660: PPUSH
119661: LD_VAR 0 7
119665: PPUSH
119666: LD_VAR 0 8
119670: PPUSH
119671: LD_VAR 0 4
119675: PPUSH
119676: LD_VAR 0 5
119680: PPUSH
119681: CALL 120888 0 5
119685: GO 119808
119687: LD_INT 302
119689: DOUBLE
119690: EQUAL
119691: IFTRUE 119695
119693: GO 119732
119695: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
119696: LD_VAR 0 6
119700: PPUSH
119701: LD_VAR 0 7
119705: PPUSH
119706: LD_VAR 0 8
119710: PPUSH
119711: LD_VAR 0 9
119715: PPUSH
119716: LD_VAR 0 4
119720: PPUSH
119721: LD_VAR 0 5
119725: PPUSH
119726: CALL 120979 0 6
119730: GO 119808
119732: LD_INT 303
119734: DOUBLE
119735: EQUAL
119736: IFTRUE 119740
119738: GO 119777
119740: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
119741: LD_VAR 0 6
119745: PPUSH
119746: LD_VAR 0 7
119750: PPUSH
119751: LD_VAR 0 8
119755: PPUSH
119756: LD_VAR 0 9
119760: PPUSH
119761: LD_VAR 0 4
119765: PPUSH
119766: LD_VAR 0 5
119770: PPUSH
119771: CALL 119813 0 6
119775: GO 119808
119777: LD_INT 304
119779: DOUBLE
119780: EQUAL
119781: IFTRUE 119785
119783: GO 119807
119785: POP
// hHackTeleport ( unit , x , y ) ; end ;
119786: LD_VAR 0 2
119790: PPUSH
119791: LD_VAR 0 4
119795: PPUSH
119796: LD_VAR 0 5
119800: PPUSH
119801: CALL 121572 0 3
119805: GO 119808
119807: POP
// end ;
119808: LD_VAR 0 12
119812: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
119813: LD_INT 0
119815: PPUSH
119816: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
119817: LD_VAR 0 1
119821: PUSH
119822: LD_INT 1
119824: LESS
119825: PUSH
119826: LD_VAR 0 1
119830: PUSH
119831: LD_INT 3
119833: GREATER
119834: OR
119835: PUSH
119836: LD_VAR 0 5
119840: PPUSH
119841: LD_VAR 0 6
119845: PPUSH
119846: CALL_OW 428
119850: OR
119851: IFFALSE 119855
// exit ;
119853: GO 120575
// uc_side := your_side ;
119855: LD_ADDR_OWVAR 20
119859: PUSH
119860: LD_OWVAR 2
119864: ST_TO_ADDR
// uc_nation := nation ;
119865: LD_ADDR_OWVAR 21
119869: PUSH
119870: LD_VAR 0 1
119874: ST_TO_ADDR
// bc_level = 1 ;
119875: LD_ADDR_OWVAR 43
119879: PUSH
119880: LD_INT 1
119882: ST_TO_ADDR
// case btype of 1 :
119883: LD_VAR 0 2
119887: PUSH
119888: LD_INT 1
119890: DOUBLE
119891: EQUAL
119892: IFTRUE 119896
119894: GO 119907
119896: POP
// bc_type := b_depot ; 2 :
119897: LD_ADDR_OWVAR 42
119901: PUSH
119902: LD_INT 0
119904: ST_TO_ADDR
119905: GO 120519
119907: LD_INT 2
119909: DOUBLE
119910: EQUAL
119911: IFTRUE 119915
119913: GO 119926
119915: POP
// bc_type := b_warehouse ; 3 :
119916: LD_ADDR_OWVAR 42
119920: PUSH
119921: LD_INT 1
119923: ST_TO_ADDR
119924: GO 120519
119926: LD_INT 3
119928: DOUBLE
119929: EQUAL
119930: IFTRUE 119934
119932: GO 119945
119934: POP
// bc_type := b_lab ; 4 .. 9 :
119935: LD_ADDR_OWVAR 42
119939: PUSH
119940: LD_INT 6
119942: ST_TO_ADDR
119943: GO 120519
119945: LD_INT 4
119947: DOUBLE
119948: GREATEREQUAL
119949: IFFALSE 119957
119951: LD_INT 9
119953: DOUBLE
119954: LESSEQUAL
119955: IFTRUE 119959
119957: GO 120011
119959: POP
// begin bc_type := b_lab_half ;
119960: LD_ADDR_OWVAR 42
119964: PUSH
119965: LD_INT 7
119967: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
119968: LD_ADDR_OWVAR 44
119972: PUSH
119973: LD_INT 10
119975: PUSH
119976: LD_INT 11
119978: PUSH
119979: LD_INT 12
119981: PUSH
119982: LD_INT 15
119984: PUSH
119985: LD_INT 14
119987: PUSH
119988: LD_INT 13
119990: PUSH
119991: EMPTY
119992: LIST
119993: LIST
119994: LIST
119995: LIST
119996: LIST
119997: LIST
119998: PUSH
119999: LD_VAR 0 2
120003: PUSH
120004: LD_INT 3
120006: MINUS
120007: ARRAY
120008: ST_TO_ADDR
// end ; 10 .. 13 :
120009: GO 120519
120011: LD_INT 10
120013: DOUBLE
120014: GREATEREQUAL
120015: IFFALSE 120023
120017: LD_INT 13
120019: DOUBLE
120020: LESSEQUAL
120021: IFTRUE 120025
120023: GO 120102
120025: POP
// begin bc_type := b_lab_full ;
120026: LD_ADDR_OWVAR 42
120030: PUSH
120031: LD_INT 8
120033: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
120034: LD_ADDR_OWVAR 44
120038: PUSH
120039: LD_INT 10
120041: PUSH
120042: LD_INT 12
120044: PUSH
120045: LD_INT 14
120047: PUSH
120048: LD_INT 13
120050: PUSH
120051: EMPTY
120052: LIST
120053: LIST
120054: LIST
120055: LIST
120056: PUSH
120057: LD_VAR 0 2
120061: PUSH
120062: LD_INT 9
120064: MINUS
120065: ARRAY
120066: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
120067: LD_ADDR_OWVAR 45
120071: PUSH
120072: LD_INT 11
120074: PUSH
120075: LD_INT 15
120077: PUSH
120078: LD_INT 12
120080: PUSH
120081: LD_INT 15
120083: PUSH
120084: EMPTY
120085: LIST
120086: LIST
120087: LIST
120088: LIST
120089: PUSH
120090: LD_VAR 0 2
120094: PUSH
120095: LD_INT 9
120097: MINUS
120098: ARRAY
120099: ST_TO_ADDR
// end ; 14 :
120100: GO 120519
120102: LD_INT 14
120104: DOUBLE
120105: EQUAL
120106: IFTRUE 120110
120108: GO 120121
120110: POP
// bc_type := b_workshop ; 15 :
120111: LD_ADDR_OWVAR 42
120115: PUSH
120116: LD_INT 2
120118: ST_TO_ADDR
120119: GO 120519
120121: LD_INT 15
120123: DOUBLE
120124: EQUAL
120125: IFTRUE 120129
120127: GO 120140
120129: POP
// bc_type := b_factory ; 16 :
120130: LD_ADDR_OWVAR 42
120134: PUSH
120135: LD_INT 3
120137: ST_TO_ADDR
120138: GO 120519
120140: LD_INT 16
120142: DOUBLE
120143: EQUAL
120144: IFTRUE 120148
120146: GO 120159
120148: POP
// bc_type := b_ext_gun ; 17 :
120149: LD_ADDR_OWVAR 42
120153: PUSH
120154: LD_INT 17
120156: ST_TO_ADDR
120157: GO 120519
120159: LD_INT 17
120161: DOUBLE
120162: EQUAL
120163: IFTRUE 120167
120165: GO 120195
120167: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
120168: LD_ADDR_OWVAR 42
120172: PUSH
120173: LD_INT 19
120175: PUSH
120176: LD_INT 23
120178: PUSH
120179: LD_INT 19
120181: PUSH
120182: EMPTY
120183: LIST
120184: LIST
120185: LIST
120186: PUSH
120187: LD_VAR 0 1
120191: ARRAY
120192: ST_TO_ADDR
120193: GO 120519
120195: LD_INT 18
120197: DOUBLE
120198: EQUAL
120199: IFTRUE 120203
120201: GO 120214
120203: POP
// bc_type := b_ext_radar ; 19 :
120204: LD_ADDR_OWVAR 42
120208: PUSH
120209: LD_INT 20
120211: ST_TO_ADDR
120212: GO 120519
120214: LD_INT 19
120216: DOUBLE
120217: EQUAL
120218: IFTRUE 120222
120220: GO 120233
120222: POP
// bc_type := b_ext_radio ; 20 :
120223: LD_ADDR_OWVAR 42
120227: PUSH
120228: LD_INT 22
120230: ST_TO_ADDR
120231: GO 120519
120233: LD_INT 20
120235: DOUBLE
120236: EQUAL
120237: IFTRUE 120241
120239: GO 120252
120241: POP
// bc_type := b_ext_siberium ; 21 :
120242: LD_ADDR_OWVAR 42
120246: PUSH
120247: LD_INT 21
120249: ST_TO_ADDR
120250: GO 120519
120252: LD_INT 21
120254: DOUBLE
120255: EQUAL
120256: IFTRUE 120260
120258: GO 120271
120260: POP
// bc_type := b_ext_computer ; 22 :
120261: LD_ADDR_OWVAR 42
120265: PUSH
120266: LD_INT 24
120268: ST_TO_ADDR
120269: GO 120519
120271: LD_INT 22
120273: DOUBLE
120274: EQUAL
120275: IFTRUE 120279
120277: GO 120290
120279: POP
// bc_type := b_ext_track ; 23 :
120280: LD_ADDR_OWVAR 42
120284: PUSH
120285: LD_INT 16
120287: ST_TO_ADDR
120288: GO 120519
120290: LD_INT 23
120292: DOUBLE
120293: EQUAL
120294: IFTRUE 120298
120296: GO 120309
120298: POP
// bc_type := b_ext_laser ; 24 :
120299: LD_ADDR_OWVAR 42
120303: PUSH
120304: LD_INT 25
120306: ST_TO_ADDR
120307: GO 120519
120309: LD_INT 24
120311: DOUBLE
120312: EQUAL
120313: IFTRUE 120317
120315: GO 120328
120317: POP
// bc_type := b_control_tower ; 25 :
120318: LD_ADDR_OWVAR 42
120322: PUSH
120323: LD_INT 36
120325: ST_TO_ADDR
120326: GO 120519
120328: LD_INT 25
120330: DOUBLE
120331: EQUAL
120332: IFTRUE 120336
120334: GO 120347
120336: POP
// bc_type := b_breastwork ; 26 :
120337: LD_ADDR_OWVAR 42
120341: PUSH
120342: LD_INT 31
120344: ST_TO_ADDR
120345: GO 120519
120347: LD_INT 26
120349: DOUBLE
120350: EQUAL
120351: IFTRUE 120355
120353: GO 120366
120355: POP
// bc_type := b_bunker ; 27 :
120356: LD_ADDR_OWVAR 42
120360: PUSH
120361: LD_INT 32
120363: ST_TO_ADDR
120364: GO 120519
120366: LD_INT 27
120368: DOUBLE
120369: EQUAL
120370: IFTRUE 120374
120372: GO 120385
120374: POP
// bc_type := b_turret ; 28 :
120375: LD_ADDR_OWVAR 42
120379: PUSH
120380: LD_INT 33
120382: ST_TO_ADDR
120383: GO 120519
120385: LD_INT 28
120387: DOUBLE
120388: EQUAL
120389: IFTRUE 120393
120391: GO 120404
120393: POP
// bc_type := b_armoury ; 29 :
120394: LD_ADDR_OWVAR 42
120398: PUSH
120399: LD_INT 4
120401: ST_TO_ADDR
120402: GO 120519
120404: LD_INT 29
120406: DOUBLE
120407: EQUAL
120408: IFTRUE 120412
120410: GO 120423
120412: POP
// bc_type := b_barracks ; 30 :
120413: LD_ADDR_OWVAR 42
120417: PUSH
120418: LD_INT 5
120420: ST_TO_ADDR
120421: GO 120519
120423: LD_INT 30
120425: DOUBLE
120426: EQUAL
120427: IFTRUE 120431
120429: GO 120442
120431: POP
// bc_type := b_solar_power ; 31 :
120432: LD_ADDR_OWVAR 42
120436: PUSH
120437: LD_INT 27
120439: ST_TO_ADDR
120440: GO 120519
120442: LD_INT 31
120444: DOUBLE
120445: EQUAL
120446: IFTRUE 120450
120448: GO 120461
120450: POP
// bc_type := b_oil_power ; 32 :
120451: LD_ADDR_OWVAR 42
120455: PUSH
120456: LD_INT 26
120458: ST_TO_ADDR
120459: GO 120519
120461: LD_INT 32
120463: DOUBLE
120464: EQUAL
120465: IFTRUE 120469
120467: GO 120480
120469: POP
// bc_type := b_siberite_power ; 33 :
120470: LD_ADDR_OWVAR 42
120474: PUSH
120475: LD_INT 28
120477: ST_TO_ADDR
120478: GO 120519
120480: LD_INT 33
120482: DOUBLE
120483: EQUAL
120484: IFTRUE 120488
120486: GO 120499
120488: POP
// bc_type := b_oil_mine ; 34 :
120489: LD_ADDR_OWVAR 42
120493: PUSH
120494: LD_INT 29
120496: ST_TO_ADDR
120497: GO 120519
120499: LD_INT 34
120501: DOUBLE
120502: EQUAL
120503: IFTRUE 120507
120505: GO 120518
120507: POP
// bc_type := b_siberite_mine ; end ;
120508: LD_ADDR_OWVAR 42
120512: PUSH
120513: LD_INT 30
120515: ST_TO_ADDR
120516: GO 120519
120518: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
120519: LD_ADDR_VAR 0 8
120523: PUSH
120524: LD_VAR 0 5
120528: PPUSH
120529: LD_VAR 0 6
120533: PPUSH
120534: LD_VAR 0 3
120538: PPUSH
120539: CALL_OW 47
120543: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
120544: LD_OWVAR 42
120548: PUSH
120549: LD_INT 32
120551: PUSH
120552: LD_INT 33
120554: PUSH
120555: EMPTY
120556: LIST
120557: LIST
120558: IN
120559: IFFALSE 120575
// PlaceWeaponTurret ( b , weapon ) ;
120561: LD_VAR 0 8
120565: PPUSH
120566: LD_VAR 0 4
120570: PPUSH
120571: CALL_OW 431
// end ;
120575: LD_VAR 0 7
120579: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
120580: LD_INT 0
120582: PPUSH
120583: PPUSH
120584: PPUSH
120585: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120586: LD_ADDR_VAR 0 4
120590: PUSH
120591: LD_INT 22
120593: PUSH
120594: LD_OWVAR 2
120598: PUSH
120599: EMPTY
120600: LIST
120601: LIST
120602: PUSH
120603: LD_INT 2
120605: PUSH
120606: LD_INT 30
120608: PUSH
120609: LD_INT 0
120611: PUSH
120612: EMPTY
120613: LIST
120614: LIST
120615: PUSH
120616: LD_INT 30
120618: PUSH
120619: LD_INT 1
120621: PUSH
120622: EMPTY
120623: LIST
120624: LIST
120625: PUSH
120626: EMPTY
120627: LIST
120628: LIST
120629: LIST
120630: PUSH
120631: EMPTY
120632: LIST
120633: LIST
120634: PPUSH
120635: CALL_OW 69
120639: ST_TO_ADDR
// if not tmp then
120640: LD_VAR 0 4
120644: NOT
120645: IFFALSE 120649
// exit ;
120647: GO 120708
// for i in tmp do
120649: LD_ADDR_VAR 0 2
120653: PUSH
120654: LD_VAR 0 4
120658: PUSH
120659: FOR_IN
120660: IFFALSE 120706
// for j = 1 to 3 do
120662: LD_ADDR_VAR 0 3
120666: PUSH
120667: DOUBLE
120668: LD_INT 1
120670: DEC
120671: ST_TO_ADDR
120672: LD_INT 3
120674: PUSH
120675: FOR_TO
120676: IFFALSE 120702
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
120678: LD_VAR 0 2
120682: PPUSH
120683: CALL_OW 274
120687: PPUSH
120688: LD_VAR 0 3
120692: PPUSH
120693: LD_INT 99999
120695: PPUSH
120696: CALL_OW 277
120700: GO 120675
120702: POP
120703: POP
120704: GO 120659
120706: POP
120707: POP
// end ;
120708: LD_VAR 0 1
120712: RET
// export function hHackSetLevel10 ; var i , j ; begin
120713: LD_INT 0
120715: PPUSH
120716: PPUSH
120717: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
120718: LD_ADDR_VAR 0 2
120722: PUSH
120723: LD_INT 21
120725: PUSH
120726: LD_INT 1
120728: PUSH
120729: EMPTY
120730: LIST
120731: LIST
120732: PPUSH
120733: CALL_OW 69
120737: PUSH
120738: FOR_IN
120739: IFFALSE 120791
// if IsSelected ( i ) then
120741: LD_VAR 0 2
120745: PPUSH
120746: CALL_OW 306
120750: IFFALSE 120789
// begin for j := 1 to 4 do
120752: LD_ADDR_VAR 0 3
120756: PUSH
120757: DOUBLE
120758: LD_INT 1
120760: DEC
120761: ST_TO_ADDR
120762: LD_INT 4
120764: PUSH
120765: FOR_TO
120766: IFFALSE 120787
// SetSkill ( i , j , 10 ) ;
120768: LD_VAR 0 2
120772: PPUSH
120773: LD_VAR 0 3
120777: PPUSH
120778: LD_INT 10
120780: PPUSH
120781: CALL_OW 237
120785: GO 120765
120787: POP
120788: POP
// end ;
120789: GO 120738
120791: POP
120792: POP
// end ;
120793: LD_VAR 0 1
120797: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
120798: LD_INT 0
120800: PPUSH
120801: PPUSH
120802: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
120803: LD_ADDR_VAR 0 2
120807: PUSH
120808: LD_INT 22
120810: PUSH
120811: LD_OWVAR 2
120815: PUSH
120816: EMPTY
120817: LIST
120818: LIST
120819: PUSH
120820: LD_INT 21
120822: PUSH
120823: LD_INT 1
120825: PUSH
120826: EMPTY
120827: LIST
120828: LIST
120829: PUSH
120830: EMPTY
120831: LIST
120832: LIST
120833: PPUSH
120834: CALL_OW 69
120838: PUSH
120839: FOR_IN
120840: IFFALSE 120881
// begin for j := 1 to 4 do
120842: LD_ADDR_VAR 0 3
120846: PUSH
120847: DOUBLE
120848: LD_INT 1
120850: DEC
120851: ST_TO_ADDR
120852: LD_INT 4
120854: PUSH
120855: FOR_TO
120856: IFFALSE 120877
// SetSkill ( i , j , 10 ) ;
120858: LD_VAR 0 2
120862: PPUSH
120863: LD_VAR 0 3
120867: PPUSH
120868: LD_INT 10
120870: PPUSH
120871: CALL_OW 237
120875: GO 120855
120877: POP
120878: POP
// end ;
120879: GO 120839
120881: POP
120882: POP
// end ;
120883: LD_VAR 0 1
120887: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
120888: LD_INT 0
120890: PPUSH
// uc_side := your_side ;
120891: LD_ADDR_OWVAR 20
120895: PUSH
120896: LD_OWVAR 2
120900: ST_TO_ADDR
// uc_nation := nation ;
120901: LD_ADDR_OWVAR 21
120905: PUSH
120906: LD_VAR 0 1
120910: ST_TO_ADDR
// InitHc ;
120911: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
120915: LD_INT 0
120917: PPUSH
120918: LD_VAR 0 2
120922: PPUSH
120923: LD_VAR 0 3
120927: PPUSH
120928: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
120932: LD_VAR 0 4
120936: PPUSH
120937: LD_VAR 0 5
120941: PPUSH
120942: CALL_OW 428
120946: PUSH
120947: LD_INT 0
120949: EQUAL
120950: IFFALSE 120974
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
120952: CALL_OW 44
120956: PPUSH
120957: LD_VAR 0 4
120961: PPUSH
120962: LD_VAR 0 5
120966: PPUSH
120967: LD_INT 1
120969: PPUSH
120970: CALL_OW 48
// end ;
120974: LD_VAR 0 6
120978: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
120979: LD_INT 0
120981: PPUSH
120982: PPUSH
// uc_side := your_side ;
120983: LD_ADDR_OWVAR 20
120987: PUSH
120988: LD_OWVAR 2
120992: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
120993: LD_VAR 0 1
120997: PUSH
120998: LD_INT 1
121000: PUSH
121001: LD_INT 2
121003: PUSH
121004: LD_INT 3
121006: PUSH
121007: LD_INT 4
121009: PUSH
121010: LD_INT 5
121012: PUSH
121013: EMPTY
121014: LIST
121015: LIST
121016: LIST
121017: LIST
121018: LIST
121019: IN
121020: IFFALSE 121032
// uc_nation := nation_american else
121022: LD_ADDR_OWVAR 21
121026: PUSH
121027: LD_INT 1
121029: ST_TO_ADDR
121030: GO 121075
// if chassis in [ 11 , 12 , 13 , 14 ] then
121032: LD_VAR 0 1
121036: PUSH
121037: LD_INT 11
121039: PUSH
121040: LD_INT 12
121042: PUSH
121043: LD_INT 13
121045: PUSH
121046: LD_INT 14
121048: PUSH
121049: EMPTY
121050: LIST
121051: LIST
121052: LIST
121053: LIST
121054: IN
121055: IFFALSE 121067
// uc_nation := nation_arabian else
121057: LD_ADDR_OWVAR 21
121061: PUSH
121062: LD_INT 2
121064: ST_TO_ADDR
121065: GO 121075
// uc_nation := nation_russian ;
121067: LD_ADDR_OWVAR 21
121071: PUSH
121072: LD_INT 3
121074: ST_TO_ADDR
// vc_chassis := chassis ;
121075: LD_ADDR_OWVAR 37
121079: PUSH
121080: LD_VAR 0 1
121084: ST_TO_ADDR
// vc_engine := engine ;
121085: LD_ADDR_OWVAR 39
121089: PUSH
121090: LD_VAR 0 2
121094: ST_TO_ADDR
// vc_control := control ;
121095: LD_ADDR_OWVAR 38
121099: PUSH
121100: LD_VAR 0 3
121104: ST_TO_ADDR
// vc_weapon := weapon ;
121105: LD_ADDR_OWVAR 40
121109: PUSH
121110: LD_VAR 0 4
121114: ST_TO_ADDR
// un := CreateVehicle ;
121115: LD_ADDR_VAR 0 8
121119: PUSH
121120: CALL_OW 45
121124: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
121125: LD_VAR 0 8
121129: PPUSH
121130: LD_INT 0
121132: PPUSH
121133: LD_INT 5
121135: PPUSH
121136: CALL_OW 12
121140: PPUSH
121141: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
121145: LD_VAR 0 8
121149: PPUSH
121150: LD_VAR 0 5
121154: PPUSH
121155: LD_VAR 0 6
121159: PPUSH
121160: LD_INT 1
121162: PPUSH
121163: CALL_OW 48
// end ;
121167: LD_VAR 0 7
121171: RET
// export hInvincible ; every 1 do
121172: GO 121174
121174: DISABLE
// hInvincible := [ ] ;
121175: LD_ADDR_EXP 198
121179: PUSH
121180: EMPTY
121181: ST_TO_ADDR
121182: END
// every 10 do var i ;
121183: GO 121185
121185: DISABLE
121186: LD_INT 0
121188: PPUSH
// begin enable ;
121189: ENABLE
// if not hInvincible then
121190: LD_EXP 198
121194: NOT
121195: IFFALSE 121199
// exit ;
121197: GO 121243
// for i in hInvincible do
121199: LD_ADDR_VAR 0 1
121203: PUSH
121204: LD_EXP 198
121208: PUSH
121209: FOR_IN
121210: IFFALSE 121241
// if GetLives ( i ) < 1000 then
121212: LD_VAR 0 1
121216: PPUSH
121217: CALL_OW 256
121221: PUSH
121222: LD_INT 1000
121224: LESS
121225: IFFALSE 121239
// SetLives ( i , 1000 ) ;
121227: LD_VAR 0 1
121231: PPUSH
121232: LD_INT 1000
121234: PPUSH
121235: CALL_OW 234
121239: GO 121209
121241: POP
121242: POP
// end ;
121243: PPOPN 1
121245: END
// export function hHackInvincible ; var i ; begin
121246: LD_INT 0
121248: PPUSH
121249: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
121250: LD_ADDR_VAR 0 2
121254: PUSH
121255: LD_INT 2
121257: PUSH
121258: LD_INT 21
121260: PUSH
121261: LD_INT 1
121263: PUSH
121264: EMPTY
121265: LIST
121266: LIST
121267: PUSH
121268: LD_INT 21
121270: PUSH
121271: LD_INT 2
121273: PUSH
121274: EMPTY
121275: LIST
121276: LIST
121277: PUSH
121278: EMPTY
121279: LIST
121280: LIST
121281: LIST
121282: PPUSH
121283: CALL_OW 69
121287: PUSH
121288: FOR_IN
121289: IFFALSE 121350
// if IsSelected ( i ) then
121291: LD_VAR 0 2
121295: PPUSH
121296: CALL_OW 306
121300: IFFALSE 121348
// begin if i in hInvincible then
121302: LD_VAR 0 2
121306: PUSH
121307: LD_EXP 198
121311: IN
121312: IFFALSE 121332
// hInvincible := hInvincible diff i else
121314: LD_ADDR_EXP 198
121318: PUSH
121319: LD_EXP 198
121323: PUSH
121324: LD_VAR 0 2
121328: DIFF
121329: ST_TO_ADDR
121330: GO 121348
// hInvincible := hInvincible union i ;
121332: LD_ADDR_EXP 198
121336: PUSH
121337: LD_EXP 198
121341: PUSH
121342: LD_VAR 0 2
121346: UNION
121347: ST_TO_ADDR
// end ;
121348: GO 121288
121350: POP
121351: POP
// end ;
121352: LD_VAR 0 1
121356: RET
// export function hHackInvisible ; var i , j ; begin
121357: LD_INT 0
121359: PPUSH
121360: PPUSH
121361: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
121362: LD_ADDR_VAR 0 2
121366: PUSH
121367: LD_INT 21
121369: PUSH
121370: LD_INT 1
121372: PUSH
121373: EMPTY
121374: LIST
121375: LIST
121376: PPUSH
121377: CALL_OW 69
121381: PUSH
121382: FOR_IN
121383: IFFALSE 121407
// if IsSelected ( i ) then
121385: LD_VAR 0 2
121389: PPUSH
121390: CALL_OW 306
121394: IFFALSE 121405
// ComForceInvisible ( i ) ;
121396: LD_VAR 0 2
121400: PPUSH
121401: CALL_OW 496
121405: GO 121382
121407: POP
121408: POP
// end ;
121409: LD_VAR 0 1
121413: RET
// export function hHackChangeYourSide ; begin
121414: LD_INT 0
121416: PPUSH
// if your_side = 8 then
121417: LD_OWVAR 2
121421: PUSH
121422: LD_INT 8
121424: EQUAL
121425: IFFALSE 121437
// your_side := 0 else
121427: LD_ADDR_OWVAR 2
121431: PUSH
121432: LD_INT 0
121434: ST_TO_ADDR
121435: GO 121451
// your_side := your_side + 1 ;
121437: LD_ADDR_OWVAR 2
121441: PUSH
121442: LD_OWVAR 2
121446: PUSH
121447: LD_INT 1
121449: PLUS
121450: ST_TO_ADDR
// end ;
121451: LD_VAR 0 1
121455: RET
// export function hHackChangeUnitSide ; var i , j ; begin
121456: LD_INT 0
121458: PPUSH
121459: PPUSH
121460: PPUSH
// for i in all_units do
121461: LD_ADDR_VAR 0 2
121465: PUSH
121466: LD_OWVAR 3
121470: PUSH
121471: FOR_IN
121472: IFFALSE 121550
// if IsSelected ( i ) then
121474: LD_VAR 0 2
121478: PPUSH
121479: CALL_OW 306
121483: IFFALSE 121548
// begin j := GetSide ( i ) ;
121485: LD_ADDR_VAR 0 3
121489: PUSH
121490: LD_VAR 0 2
121494: PPUSH
121495: CALL_OW 255
121499: ST_TO_ADDR
// if j = 8 then
121500: LD_VAR 0 3
121504: PUSH
121505: LD_INT 8
121507: EQUAL
121508: IFFALSE 121520
// j := 0 else
121510: LD_ADDR_VAR 0 3
121514: PUSH
121515: LD_INT 0
121517: ST_TO_ADDR
121518: GO 121534
// j := j + 1 ;
121520: LD_ADDR_VAR 0 3
121524: PUSH
121525: LD_VAR 0 3
121529: PUSH
121530: LD_INT 1
121532: PLUS
121533: ST_TO_ADDR
// SetSide ( i , j ) ;
121534: LD_VAR 0 2
121538: PPUSH
121539: LD_VAR 0 3
121543: PPUSH
121544: CALL_OW 235
// end ;
121548: GO 121471
121550: POP
121551: POP
// end ;
121552: LD_VAR 0 1
121556: RET
// export function hHackFog ; begin
121557: LD_INT 0
121559: PPUSH
// FogOff ( true ) ;
121560: LD_INT 1
121562: PPUSH
121563: CALL_OW 344
// end ;
121567: LD_VAR 0 1
121571: RET
// export function hHackTeleport ( unit , x , y ) ; begin
121572: LD_INT 0
121574: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
121575: LD_VAR 0 1
121579: PPUSH
121580: LD_VAR 0 2
121584: PPUSH
121585: LD_VAR 0 3
121589: PPUSH
121590: LD_INT 1
121592: PPUSH
121593: LD_INT 1
121595: PPUSH
121596: CALL_OW 483
// CenterOnXY ( x , y ) ;
121600: LD_VAR 0 2
121604: PPUSH
121605: LD_VAR 0 3
121609: PPUSH
121610: CALL_OW 84
// end ;
121614: LD_VAR 0 4
121618: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
121619: LD_INT 0
121621: PPUSH
121622: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
121623: LD_VAR 0 1
121627: NOT
121628: PUSH
121629: LD_VAR 0 2
121633: PPUSH
121634: LD_VAR 0 3
121638: PPUSH
121639: CALL_OW 488
121643: NOT
121644: OR
121645: PUSH
121646: LD_VAR 0 1
121650: PPUSH
121651: CALL_OW 266
121655: PUSH
121656: LD_INT 3
121658: NONEQUAL
121659: PUSH
121660: LD_VAR 0 1
121664: PPUSH
121665: CALL_OW 247
121669: PUSH
121670: LD_INT 1
121672: EQUAL
121673: NOT
121674: AND
121675: OR
121676: IFFALSE 121680
// exit ;
121678: GO 121829
// if GetType ( factory ) = unit_human then
121680: LD_VAR 0 1
121684: PPUSH
121685: CALL_OW 247
121689: PUSH
121690: LD_INT 1
121692: EQUAL
121693: IFFALSE 121710
// factory := IsInUnit ( factory ) ;
121695: LD_ADDR_VAR 0 1
121699: PUSH
121700: LD_VAR 0 1
121704: PPUSH
121705: CALL_OW 310
121709: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
121710: LD_VAR 0 1
121714: PPUSH
121715: CALL_OW 266
121719: PUSH
121720: LD_INT 3
121722: NONEQUAL
121723: IFFALSE 121727
// exit ;
121725: GO 121829
// if HexInfo ( x , y ) = factory then
121727: LD_VAR 0 2
121731: PPUSH
121732: LD_VAR 0 3
121736: PPUSH
121737: CALL_OW 428
121741: PUSH
121742: LD_VAR 0 1
121746: EQUAL
121747: IFFALSE 121774
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
121749: LD_ADDR_EXP 199
121753: PUSH
121754: LD_EXP 199
121758: PPUSH
121759: LD_VAR 0 1
121763: PPUSH
121764: LD_INT 0
121766: PPUSH
121767: CALL_OW 1
121771: ST_TO_ADDR
121772: GO 121825
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
121774: LD_ADDR_EXP 199
121778: PUSH
121779: LD_EXP 199
121783: PPUSH
121784: LD_VAR 0 1
121788: PPUSH
121789: LD_VAR 0 1
121793: PPUSH
121794: CALL_OW 255
121798: PUSH
121799: LD_VAR 0 1
121803: PUSH
121804: LD_VAR 0 2
121808: PUSH
121809: LD_VAR 0 3
121813: PUSH
121814: EMPTY
121815: LIST
121816: LIST
121817: LIST
121818: LIST
121819: PPUSH
121820: CALL_OW 1
121824: ST_TO_ADDR
// UpdateFactoryWaypoints ;
121825: CALL 121834 0 0
// end ;
121829: LD_VAR 0 4
121833: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
121834: LD_INT 0
121836: PPUSH
121837: PPUSH
121838: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
121839: LD_STRING resetFactoryWaypoint();
121841: PPUSH
121842: CALL_OW 559
// if factoryWaypoints then
121846: LD_EXP 199
121850: IFFALSE 121976
// begin list := PrepareArray ( factoryWaypoints ) ;
121852: LD_ADDR_VAR 0 3
121856: PUSH
121857: LD_EXP 199
121861: PPUSH
121862: CALL 107230 0 1
121866: ST_TO_ADDR
// for i := 1 to list do
121867: LD_ADDR_VAR 0 2
121871: PUSH
121872: DOUBLE
121873: LD_INT 1
121875: DEC
121876: ST_TO_ADDR
121877: LD_VAR 0 3
121881: PUSH
121882: FOR_TO
121883: IFFALSE 121974
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
121885: LD_STRING setFactoryWaypointXY(
121887: PUSH
121888: LD_VAR 0 3
121892: PUSH
121893: LD_VAR 0 2
121897: ARRAY
121898: PUSH
121899: LD_INT 1
121901: ARRAY
121902: STR
121903: PUSH
121904: LD_STRING ,
121906: STR
121907: PUSH
121908: LD_VAR 0 3
121912: PUSH
121913: LD_VAR 0 2
121917: ARRAY
121918: PUSH
121919: LD_INT 2
121921: ARRAY
121922: STR
121923: PUSH
121924: LD_STRING ,
121926: STR
121927: PUSH
121928: LD_VAR 0 3
121932: PUSH
121933: LD_VAR 0 2
121937: ARRAY
121938: PUSH
121939: LD_INT 3
121941: ARRAY
121942: STR
121943: PUSH
121944: LD_STRING ,
121946: STR
121947: PUSH
121948: LD_VAR 0 3
121952: PUSH
121953: LD_VAR 0 2
121957: ARRAY
121958: PUSH
121959: LD_INT 4
121961: ARRAY
121962: STR
121963: PUSH
121964: LD_STRING )
121966: STR
121967: PPUSH
121968: CALL_OW 559
121972: GO 121882
121974: POP
121975: POP
// end ; end ;
121976: LD_VAR 0 1
121980: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
121981: LD_INT 0
121983: PPUSH
// if HexInfo ( x , y ) = warehouse then
121984: LD_VAR 0 2
121988: PPUSH
121989: LD_VAR 0 3
121993: PPUSH
121994: CALL_OW 428
121998: PUSH
121999: LD_VAR 0 1
122003: EQUAL
122004: IFFALSE 122031
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
122006: LD_ADDR_EXP 200
122010: PUSH
122011: LD_EXP 200
122015: PPUSH
122016: LD_VAR 0 1
122020: PPUSH
122021: LD_INT 0
122023: PPUSH
122024: CALL_OW 1
122028: ST_TO_ADDR
122029: GO 122082
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
122031: LD_ADDR_EXP 200
122035: PUSH
122036: LD_EXP 200
122040: PPUSH
122041: LD_VAR 0 1
122045: PPUSH
122046: LD_VAR 0 1
122050: PPUSH
122051: CALL_OW 255
122055: PUSH
122056: LD_VAR 0 1
122060: PUSH
122061: LD_VAR 0 2
122065: PUSH
122066: LD_VAR 0 3
122070: PUSH
122071: EMPTY
122072: LIST
122073: LIST
122074: LIST
122075: LIST
122076: PPUSH
122077: CALL_OW 1
122081: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
122082: CALL 122091 0 0
// end ;
122086: LD_VAR 0 4
122090: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
122091: LD_INT 0
122093: PPUSH
122094: PPUSH
122095: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
122096: LD_STRING resetWarehouseGatheringPoints();
122098: PPUSH
122099: CALL_OW 559
// if warehouseGatheringPoints then
122103: LD_EXP 200
122107: IFFALSE 122233
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
122109: LD_ADDR_VAR 0 3
122113: PUSH
122114: LD_EXP 200
122118: PPUSH
122119: CALL 107230 0 1
122123: ST_TO_ADDR
// for i := 1 to list do
122124: LD_ADDR_VAR 0 2
122128: PUSH
122129: DOUBLE
122130: LD_INT 1
122132: DEC
122133: ST_TO_ADDR
122134: LD_VAR 0 3
122138: PUSH
122139: FOR_TO
122140: IFFALSE 122231
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
122142: LD_STRING setWarehouseGatheringPointXY(
122144: PUSH
122145: LD_VAR 0 3
122149: PUSH
122150: LD_VAR 0 2
122154: ARRAY
122155: PUSH
122156: LD_INT 1
122158: ARRAY
122159: STR
122160: PUSH
122161: LD_STRING ,
122163: STR
122164: PUSH
122165: LD_VAR 0 3
122169: PUSH
122170: LD_VAR 0 2
122174: ARRAY
122175: PUSH
122176: LD_INT 2
122178: ARRAY
122179: STR
122180: PUSH
122181: LD_STRING ,
122183: STR
122184: PUSH
122185: LD_VAR 0 3
122189: PUSH
122190: LD_VAR 0 2
122194: ARRAY
122195: PUSH
122196: LD_INT 3
122198: ARRAY
122199: STR
122200: PUSH
122201: LD_STRING ,
122203: STR
122204: PUSH
122205: LD_VAR 0 3
122209: PUSH
122210: LD_VAR 0 2
122214: ARRAY
122215: PUSH
122216: LD_INT 4
122218: ARRAY
122219: STR
122220: PUSH
122221: LD_STRING )
122223: STR
122224: PPUSH
122225: CALL_OW 559
122229: GO 122139
122231: POP
122232: POP
// end ; end ;
122233: LD_VAR 0 1
122237: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
122238: LD_EXP 200
122242: IFFALSE 122927
122244: GO 122246
122246: DISABLE
122247: LD_INT 0
122249: PPUSH
122250: PPUSH
122251: PPUSH
122252: PPUSH
122253: PPUSH
122254: PPUSH
122255: PPUSH
122256: PPUSH
122257: PPUSH
// begin enable ;
122258: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
122259: LD_ADDR_VAR 0 3
122263: PUSH
122264: LD_EXP 200
122268: PPUSH
122269: CALL 107230 0 1
122273: ST_TO_ADDR
// if not list then
122274: LD_VAR 0 3
122278: NOT
122279: IFFALSE 122283
// exit ;
122281: GO 122927
// for i := 1 to list do
122283: LD_ADDR_VAR 0 1
122287: PUSH
122288: DOUBLE
122289: LD_INT 1
122291: DEC
122292: ST_TO_ADDR
122293: LD_VAR 0 3
122297: PUSH
122298: FOR_TO
122299: IFFALSE 122925
// begin depot := list [ i ] [ 2 ] ;
122301: LD_ADDR_VAR 0 8
122305: PUSH
122306: LD_VAR 0 3
122310: PUSH
122311: LD_VAR 0 1
122315: ARRAY
122316: PUSH
122317: LD_INT 2
122319: ARRAY
122320: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
122321: LD_ADDR_VAR 0 5
122325: PUSH
122326: LD_VAR 0 3
122330: PUSH
122331: LD_VAR 0 1
122335: ARRAY
122336: PUSH
122337: LD_INT 1
122339: ARRAY
122340: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
122341: LD_VAR 0 8
122345: PPUSH
122346: CALL_OW 301
122350: PUSH
122351: LD_VAR 0 5
122355: PUSH
122356: LD_VAR 0 8
122360: PPUSH
122361: CALL_OW 255
122365: NONEQUAL
122366: OR
122367: IFFALSE 122396
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
122369: LD_ADDR_EXP 200
122373: PUSH
122374: LD_EXP 200
122378: PPUSH
122379: LD_VAR 0 8
122383: PPUSH
122384: LD_INT 0
122386: PPUSH
122387: CALL_OW 1
122391: ST_TO_ADDR
// exit ;
122392: POP
122393: POP
122394: GO 122927
// end ; x := list [ i ] [ 3 ] ;
122396: LD_ADDR_VAR 0 6
122400: PUSH
122401: LD_VAR 0 3
122405: PUSH
122406: LD_VAR 0 1
122410: ARRAY
122411: PUSH
122412: LD_INT 3
122414: ARRAY
122415: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
122416: LD_ADDR_VAR 0 7
122420: PUSH
122421: LD_VAR 0 3
122425: PUSH
122426: LD_VAR 0 1
122430: ARRAY
122431: PUSH
122432: LD_INT 4
122434: ARRAY
122435: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
122436: LD_ADDR_VAR 0 9
122440: PUSH
122441: LD_VAR 0 6
122445: PPUSH
122446: LD_VAR 0 7
122450: PPUSH
122451: LD_INT 16
122453: PPUSH
122454: CALL 105818 0 3
122458: ST_TO_ADDR
// if not cratesNearbyPoint then
122459: LD_VAR 0 9
122463: NOT
122464: IFFALSE 122470
// exit ;
122466: POP
122467: POP
122468: GO 122927
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
122470: LD_ADDR_VAR 0 4
122474: PUSH
122475: LD_INT 22
122477: PUSH
122478: LD_VAR 0 5
122482: PUSH
122483: EMPTY
122484: LIST
122485: LIST
122486: PUSH
122487: LD_INT 3
122489: PUSH
122490: LD_INT 60
122492: PUSH
122493: EMPTY
122494: LIST
122495: PUSH
122496: EMPTY
122497: LIST
122498: LIST
122499: PUSH
122500: LD_INT 91
122502: PUSH
122503: LD_VAR 0 8
122507: PUSH
122508: LD_INT 6
122510: PUSH
122511: EMPTY
122512: LIST
122513: LIST
122514: LIST
122515: PUSH
122516: LD_INT 2
122518: PUSH
122519: LD_INT 25
122521: PUSH
122522: LD_INT 2
122524: PUSH
122525: EMPTY
122526: LIST
122527: LIST
122528: PUSH
122529: LD_INT 25
122531: PUSH
122532: LD_INT 16
122534: PUSH
122535: EMPTY
122536: LIST
122537: LIST
122538: PUSH
122539: EMPTY
122540: LIST
122541: LIST
122542: LIST
122543: PUSH
122544: EMPTY
122545: LIST
122546: LIST
122547: LIST
122548: LIST
122549: PPUSH
122550: CALL_OW 69
122554: PUSH
122555: LD_VAR 0 8
122559: PPUSH
122560: CALL_OW 313
122564: PPUSH
122565: LD_INT 3
122567: PUSH
122568: LD_INT 60
122570: PUSH
122571: EMPTY
122572: LIST
122573: PUSH
122574: EMPTY
122575: LIST
122576: LIST
122577: PUSH
122578: LD_INT 2
122580: PUSH
122581: LD_INT 25
122583: PUSH
122584: LD_INT 2
122586: PUSH
122587: EMPTY
122588: LIST
122589: LIST
122590: PUSH
122591: LD_INT 25
122593: PUSH
122594: LD_INT 16
122596: PUSH
122597: EMPTY
122598: LIST
122599: LIST
122600: PUSH
122601: EMPTY
122602: LIST
122603: LIST
122604: LIST
122605: PUSH
122606: EMPTY
122607: LIST
122608: LIST
122609: PPUSH
122610: CALL_OW 72
122614: UNION
122615: ST_TO_ADDR
// if tmp then
122616: LD_VAR 0 4
122620: IFFALSE 122700
// begin tmp := ShrinkArray ( tmp , 3 ) ;
122622: LD_ADDR_VAR 0 4
122626: PUSH
122627: LD_VAR 0 4
122631: PPUSH
122632: LD_INT 3
122634: PPUSH
122635: CALL 103787 0 2
122639: ST_TO_ADDR
// for j in tmp do
122640: LD_ADDR_VAR 0 2
122644: PUSH
122645: LD_VAR 0 4
122649: PUSH
122650: FOR_IN
122651: IFFALSE 122694
// begin if IsInUnit ( j ) then
122653: LD_VAR 0 2
122657: PPUSH
122658: CALL_OW 310
122662: IFFALSE 122673
// ComExit ( j ) ;
122664: LD_VAR 0 2
122668: PPUSH
122669: CALL 103870 0 1
// AddComCollect ( j , x , y ) ;
122673: LD_VAR 0 2
122677: PPUSH
122678: LD_VAR 0 6
122682: PPUSH
122683: LD_VAR 0 7
122687: PPUSH
122688: CALL_OW 177
// end ;
122692: GO 122650
122694: POP
122695: POP
// exit ;
122696: POP
122697: POP
122698: GO 122927
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
122700: LD_ADDR_VAR 0 4
122704: PUSH
122705: LD_INT 22
122707: PUSH
122708: LD_VAR 0 5
122712: PUSH
122713: EMPTY
122714: LIST
122715: LIST
122716: PUSH
122717: LD_INT 91
122719: PUSH
122720: LD_VAR 0 8
122724: PUSH
122725: LD_INT 8
122727: PUSH
122728: EMPTY
122729: LIST
122730: LIST
122731: LIST
122732: PUSH
122733: LD_INT 2
122735: PUSH
122736: LD_INT 34
122738: PUSH
122739: LD_INT 12
122741: PUSH
122742: EMPTY
122743: LIST
122744: LIST
122745: PUSH
122746: LD_INT 34
122748: PUSH
122749: LD_INT 51
122751: PUSH
122752: EMPTY
122753: LIST
122754: LIST
122755: PUSH
122756: LD_INT 34
122758: PUSH
122759: LD_INT 32
122761: PUSH
122762: EMPTY
122763: LIST
122764: LIST
122765: PUSH
122766: LD_INT 34
122768: PUSH
122769: LD_INT 89
122771: PUSH
122772: EMPTY
122773: LIST
122774: LIST
122775: PUSH
122776: EMPTY
122777: LIST
122778: LIST
122779: LIST
122780: LIST
122781: LIST
122782: PUSH
122783: EMPTY
122784: LIST
122785: LIST
122786: LIST
122787: PPUSH
122788: CALL_OW 69
122792: ST_TO_ADDR
// if tmp then
122793: LD_VAR 0 4
122797: IFFALSE 122923
// begin for j in tmp do
122799: LD_ADDR_VAR 0 2
122803: PUSH
122804: LD_VAR 0 4
122808: PUSH
122809: FOR_IN
122810: IFFALSE 122921
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
122812: LD_VAR 0 2
122816: PPUSH
122817: CALL_OW 262
122821: PUSH
122822: LD_INT 3
122824: EQUAL
122825: PUSH
122826: LD_VAR 0 2
122830: PPUSH
122831: CALL_OW 261
122835: PUSH
122836: LD_INT 20
122838: GREATER
122839: OR
122840: PUSH
122841: LD_VAR 0 2
122845: PPUSH
122846: CALL_OW 314
122850: NOT
122851: AND
122852: PUSH
122853: LD_VAR 0 2
122857: PPUSH
122858: CALL_OW 263
122862: PUSH
122863: LD_INT 1
122865: NONEQUAL
122866: PUSH
122867: LD_VAR 0 2
122871: PPUSH
122872: CALL_OW 311
122876: OR
122877: AND
122878: IFFALSE 122919
// begin ComCollect ( j , x , y ) ;
122880: LD_VAR 0 2
122884: PPUSH
122885: LD_VAR 0 6
122889: PPUSH
122890: LD_VAR 0 7
122894: PPUSH
122895: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
122899: LD_VAR 0 2
122903: PPUSH
122904: LD_VAR 0 8
122908: PPUSH
122909: CALL_OW 172
// exit ;
122913: POP
122914: POP
122915: POP
122916: POP
122917: GO 122927
// end ;
122919: GO 122809
122921: POP
122922: POP
// end ; end ;
122923: GO 122298
122925: POP
122926: POP
// end ; end_of_file
122927: PPOPN 9
122929: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
122930: LD_INT 0
122932: PPUSH
122933: PPUSH
122934: PPUSH
122935: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
122936: LD_VAR 0 1
122940: PPUSH
122941: CALL_OW 264
122945: PUSH
122946: LD_INT 91
122948: EQUAL
122949: IFFALSE 123021
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
122951: LD_INT 68
122953: PPUSH
122954: LD_VAR 0 1
122958: PPUSH
122959: CALL_OW 255
122963: PPUSH
122964: CALL_OW 321
122968: PUSH
122969: LD_INT 2
122971: EQUAL
122972: IFFALSE 122984
// eff := 70 else
122974: LD_ADDR_VAR 0 4
122978: PUSH
122979: LD_INT 70
122981: ST_TO_ADDR
122982: GO 122992
// eff := 30 ;
122984: LD_ADDR_VAR 0 4
122988: PUSH
122989: LD_INT 30
122991: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
122992: LD_VAR 0 1
122996: PPUSH
122997: CALL_OW 250
123001: PPUSH
123002: LD_VAR 0 1
123006: PPUSH
123007: CALL_OW 251
123011: PPUSH
123012: LD_VAR 0 4
123016: PPUSH
123017: CALL_OW 495
// end ; end ;
123021: LD_VAR 0 2
123025: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
123026: LD_INT 0
123028: PPUSH
// end ;
123029: LD_VAR 0 4
123033: RET
// export function SOS_Command ( cmd ) ; begin
123034: LD_INT 0
123036: PPUSH
// end ;
123037: LD_VAR 0 2
123041: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
123042: LD_INT 0
123044: PPUSH
// end ;
123045: LD_VAR 0 6
123049: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
123050: LD_INT 0
123052: PPUSH
123053: PPUSH
// if not vehicle or not factory then
123054: LD_VAR 0 1
123058: NOT
123059: PUSH
123060: LD_VAR 0 2
123064: NOT
123065: OR
123066: IFFALSE 123070
// exit ;
123068: GO 123301
// if factoryWaypoints >= factory then
123070: LD_EXP 199
123074: PUSH
123075: LD_VAR 0 2
123079: GREATEREQUAL
123080: IFFALSE 123301
// if factoryWaypoints [ factory ] then
123082: LD_EXP 199
123086: PUSH
123087: LD_VAR 0 2
123091: ARRAY
123092: IFFALSE 123301
// begin if GetControl ( vehicle ) = control_manual then
123094: LD_VAR 0 1
123098: PPUSH
123099: CALL_OW 263
123103: PUSH
123104: LD_INT 1
123106: EQUAL
123107: IFFALSE 123188
// begin driver := IsDrivenBy ( vehicle ) ;
123109: LD_ADDR_VAR 0 4
123113: PUSH
123114: LD_VAR 0 1
123118: PPUSH
123119: CALL_OW 311
123123: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
123124: LD_VAR 0 4
123128: PPUSH
123129: LD_EXP 199
123133: PUSH
123134: LD_VAR 0 2
123138: ARRAY
123139: PUSH
123140: LD_INT 3
123142: ARRAY
123143: PPUSH
123144: LD_EXP 199
123148: PUSH
123149: LD_VAR 0 2
123153: ARRAY
123154: PUSH
123155: LD_INT 4
123157: ARRAY
123158: PPUSH
123159: CALL_OW 171
// AddComExitVehicle ( driver ) ;
123163: LD_VAR 0 4
123167: PPUSH
123168: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
123172: LD_VAR 0 4
123176: PPUSH
123177: LD_VAR 0 2
123181: PPUSH
123182: CALL_OW 180
// end else
123186: GO 123301
// if GetControl ( vehicle ) = control_remote then
123188: LD_VAR 0 1
123192: PPUSH
123193: CALL_OW 263
123197: PUSH
123198: LD_INT 2
123200: EQUAL
123201: IFFALSE 123262
// begin wait ( 0 0$2 ) ;
123203: LD_INT 70
123205: PPUSH
123206: CALL_OW 67
// if Connect ( vehicle ) then
123210: LD_VAR 0 1
123214: PPUSH
123215: CALL 74129 0 1
123219: IFFALSE 123260
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
123221: LD_VAR 0 1
123225: PPUSH
123226: LD_EXP 199
123230: PUSH
123231: LD_VAR 0 2
123235: ARRAY
123236: PUSH
123237: LD_INT 3
123239: ARRAY
123240: PPUSH
123241: LD_EXP 199
123245: PUSH
123246: LD_VAR 0 2
123250: ARRAY
123251: PUSH
123252: LD_INT 4
123254: ARRAY
123255: PPUSH
123256: CALL_OW 171
// end else
123260: GO 123301
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
123262: LD_VAR 0 1
123266: PPUSH
123267: LD_EXP 199
123271: PUSH
123272: LD_VAR 0 2
123276: ARRAY
123277: PUSH
123278: LD_INT 3
123280: ARRAY
123281: PPUSH
123282: LD_EXP 199
123286: PUSH
123287: LD_VAR 0 2
123291: ARRAY
123292: PUSH
123293: LD_INT 4
123295: ARRAY
123296: PPUSH
123297: CALL_OW 171
// end ; end ;
123301: LD_VAR 0 3
123305: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
123306: LD_INT 0
123308: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
123309: LD_VAR 0 1
123313: PUSH
123314: LD_INT 250
123316: EQUAL
123317: PUSH
123318: LD_VAR 0 2
123322: PPUSH
123323: CALL_OW 264
123327: PUSH
123328: LD_INT 81
123330: EQUAL
123331: AND
123332: IFFALSE 123353
// MinerPlaceMine ( unit , x , y ) ;
123334: LD_VAR 0 2
123338: PPUSH
123339: LD_VAR 0 4
123343: PPUSH
123344: LD_VAR 0 5
123348: PPUSH
123349: CALL 125738 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
123353: LD_VAR 0 1
123357: PUSH
123358: LD_INT 251
123360: EQUAL
123361: PUSH
123362: LD_VAR 0 2
123366: PPUSH
123367: CALL_OW 264
123371: PUSH
123372: LD_INT 81
123374: EQUAL
123375: AND
123376: IFFALSE 123397
// MinerDetonateMine ( unit , x , y ) ;
123378: LD_VAR 0 2
123382: PPUSH
123383: LD_VAR 0 4
123387: PPUSH
123388: LD_VAR 0 5
123392: PPUSH
123393: CALL 126013 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
123397: LD_VAR 0 1
123401: PUSH
123402: LD_INT 252
123404: EQUAL
123405: PUSH
123406: LD_VAR 0 2
123410: PPUSH
123411: CALL_OW 264
123415: PUSH
123416: LD_INT 81
123418: EQUAL
123419: AND
123420: IFFALSE 123441
// MinerCreateMinefield ( unit , x , y ) ;
123422: LD_VAR 0 2
123426: PPUSH
123427: LD_VAR 0 4
123431: PPUSH
123432: LD_VAR 0 5
123436: PPUSH
123437: CALL 126430 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
123441: LD_VAR 0 1
123445: PUSH
123446: LD_INT 253
123448: EQUAL
123449: PUSH
123450: LD_VAR 0 2
123454: PPUSH
123455: CALL_OW 257
123459: PUSH
123460: LD_INT 5
123462: EQUAL
123463: AND
123464: IFFALSE 123485
// ComBinocular ( unit , x , y ) ;
123466: LD_VAR 0 2
123470: PPUSH
123471: LD_VAR 0 4
123475: PPUSH
123476: LD_VAR 0 5
123480: PPUSH
123481: CALL 126799 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
123485: LD_VAR 0 1
123489: PUSH
123490: LD_INT 254
123492: EQUAL
123493: PUSH
123494: LD_VAR 0 2
123498: PPUSH
123499: CALL_OW 264
123503: PUSH
123504: LD_INT 99
123506: EQUAL
123507: AND
123508: PUSH
123509: LD_VAR 0 3
123513: PPUSH
123514: CALL_OW 263
123518: PUSH
123519: LD_INT 3
123521: EQUAL
123522: AND
123523: IFFALSE 123539
// HackDestroyVehicle ( unit , selectedUnit ) ;
123525: LD_VAR 0 2
123529: PPUSH
123530: LD_VAR 0 3
123534: PPUSH
123535: CALL 125102 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
123539: LD_VAR 0 1
123543: PUSH
123544: LD_INT 255
123546: EQUAL
123547: PUSH
123548: LD_VAR 0 2
123552: PPUSH
123553: CALL_OW 264
123557: PUSH
123558: LD_INT 14
123560: PUSH
123561: LD_INT 53
123563: PUSH
123564: EMPTY
123565: LIST
123566: LIST
123567: IN
123568: AND
123569: PUSH
123570: LD_VAR 0 4
123574: PPUSH
123575: LD_VAR 0 5
123579: PPUSH
123580: CALL_OW 488
123584: AND
123585: IFFALSE 123609
// CutTreeXYR ( unit , x , y , 12 ) ;
123587: LD_VAR 0 2
123591: PPUSH
123592: LD_VAR 0 4
123596: PPUSH
123597: LD_VAR 0 5
123601: PPUSH
123602: LD_INT 12
123604: PPUSH
123605: CALL 123672 0 4
// if cmd = 256 then
123609: LD_VAR 0 1
123613: PUSH
123614: LD_INT 256
123616: EQUAL
123617: IFFALSE 123638
// SetFactoryWaypoint ( unit , x , y ) ;
123619: LD_VAR 0 2
123623: PPUSH
123624: LD_VAR 0 4
123628: PPUSH
123629: LD_VAR 0 5
123633: PPUSH
123634: CALL 121619 0 3
// if cmd = 257 then
123638: LD_VAR 0 1
123642: PUSH
123643: LD_INT 257
123645: EQUAL
123646: IFFALSE 123667
// SetWarehouseGatheringPoint ( unit , x , y ) ;
123648: LD_VAR 0 2
123652: PPUSH
123653: LD_VAR 0 4
123657: PPUSH
123658: LD_VAR 0 5
123662: PPUSH
123663: CALL 121981 0 3
// end ;
123667: LD_VAR 0 6
123671: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
123672: LD_INT 0
123674: PPUSH
123675: PPUSH
123676: PPUSH
123677: PPUSH
123678: PPUSH
123679: PPUSH
123680: PPUSH
123681: PPUSH
123682: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
123683: LD_VAR 0 1
123687: NOT
123688: PUSH
123689: LD_VAR 0 2
123693: PPUSH
123694: LD_VAR 0 3
123698: PPUSH
123699: CALL_OW 488
123703: NOT
123704: OR
123705: PUSH
123706: LD_VAR 0 4
123710: NOT
123711: OR
123712: IFFALSE 123716
// exit ;
123714: GO 124056
// list := [ ] ;
123716: LD_ADDR_VAR 0 13
123720: PUSH
123721: EMPTY
123722: ST_TO_ADDR
// if x - r < 0 then
123723: LD_VAR 0 2
123727: PUSH
123728: LD_VAR 0 4
123732: MINUS
123733: PUSH
123734: LD_INT 0
123736: LESS
123737: IFFALSE 123749
// min_x := 0 else
123739: LD_ADDR_VAR 0 7
123743: PUSH
123744: LD_INT 0
123746: ST_TO_ADDR
123747: GO 123765
// min_x := x - r ;
123749: LD_ADDR_VAR 0 7
123753: PUSH
123754: LD_VAR 0 2
123758: PUSH
123759: LD_VAR 0 4
123763: MINUS
123764: ST_TO_ADDR
// if y - r < 0 then
123765: LD_VAR 0 3
123769: PUSH
123770: LD_VAR 0 4
123774: MINUS
123775: PUSH
123776: LD_INT 0
123778: LESS
123779: IFFALSE 123791
// min_y := 0 else
123781: LD_ADDR_VAR 0 8
123785: PUSH
123786: LD_INT 0
123788: ST_TO_ADDR
123789: GO 123807
// min_y := y - r ;
123791: LD_ADDR_VAR 0 8
123795: PUSH
123796: LD_VAR 0 3
123800: PUSH
123801: LD_VAR 0 4
123805: MINUS
123806: ST_TO_ADDR
// max_x := x + r ;
123807: LD_ADDR_VAR 0 9
123811: PUSH
123812: LD_VAR 0 2
123816: PUSH
123817: LD_VAR 0 4
123821: PLUS
123822: ST_TO_ADDR
// max_y := y + r ;
123823: LD_ADDR_VAR 0 10
123827: PUSH
123828: LD_VAR 0 3
123832: PUSH
123833: LD_VAR 0 4
123837: PLUS
123838: ST_TO_ADDR
// for _x = min_x to max_x do
123839: LD_ADDR_VAR 0 11
123843: PUSH
123844: DOUBLE
123845: LD_VAR 0 7
123849: DEC
123850: ST_TO_ADDR
123851: LD_VAR 0 9
123855: PUSH
123856: FOR_TO
123857: IFFALSE 123974
// for _y = min_y to max_y do
123859: LD_ADDR_VAR 0 12
123863: PUSH
123864: DOUBLE
123865: LD_VAR 0 8
123869: DEC
123870: ST_TO_ADDR
123871: LD_VAR 0 10
123875: PUSH
123876: FOR_TO
123877: IFFALSE 123970
// begin if not ValidHex ( _x , _y ) then
123879: LD_VAR 0 11
123883: PPUSH
123884: LD_VAR 0 12
123888: PPUSH
123889: CALL_OW 488
123893: NOT
123894: IFFALSE 123898
// continue ;
123896: GO 123876
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
123898: LD_VAR 0 11
123902: PPUSH
123903: LD_VAR 0 12
123907: PPUSH
123908: CALL_OW 351
123912: PUSH
123913: LD_VAR 0 11
123917: PPUSH
123918: LD_VAR 0 12
123922: PPUSH
123923: CALL_OW 554
123927: AND
123928: IFFALSE 123968
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
123930: LD_ADDR_VAR 0 13
123934: PUSH
123935: LD_VAR 0 13
123939: PPUSH
123940: LD_VAR 0 13
123944: PUSH
123945: LD_INT 1
123947: PLUS
123948: PPUSH
123949: LD_VAR 0 11
123953: PUSH
123954: LD_VAR 0 12
123958: PUSH
123959: EMPTY
123960: LIST
123961: LIST
123962: PPUSH
123963: CALL_OW 2
123967: ST_TO_ADDR
// end ;
123968: GO 123876
123970: POP
123971: POP
123972: GO 123856
123974: POP
123975: POP
// if not list then
123976: LD_VAR 0 13
123980: NOT
123981: IFFALSE 123985
// exit ;
123983: GO 124056
// for i in list do
123985: LD_ADDR_VAR 0 6
123989: PUSH
123990: LD_VAR 0 13
123994: PUSH
123995: FOR_IN
123996: IFFALSE 124054
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
123998: LD_VAR 0 1
124002: PPUSH
124003: LD_STRING M
124005: PUSH
124006: LD_VAR 0 6
124010: PUSH
124011: LD_INT 1
124013: ARRAY
124014: PUSH
124015: LD_VAR 0 6
124019: PUSH
124020: LD_INT 2
124022: ARRAY
124023: PUSH
124024: LD_INT 0
124026: PUSH
124027: LD_INT 0
124029: PUSH
124030: LD_INT 0
124032: PUSH
124033: LD_INT 0
124035: PUSH
124036: EMPTY
124037: LIST
124038: LIST
124039: LIST
124040: LIST
124041: LIST
124042: LIST
124043: LIST
124044: PUSH
124045: EMPTY
124046: LIST
124047: PPUSH
124048: CALL_OW 447
124052: GO 123995
124054: POP
124055: POP
// end ;
124056: LD_VAR 0 5
124060: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
124061: LD_EXP 202
124065: NOT
124066: IFFALSE 124116
124068: GO 124070
124070: DISABLE
// begin initHack := true ;
124071: LD_ADDR_EXP 202
124075: PUSH
124076: LD_INT 1
124078: ST_TO_ADDR
// hackTanks := [ ] ;
124079: LD_ADDR_EXP 203
124083: PUSH
124084: EMPTY
124085: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
124086: LD_ADDR_EXP 204
124090: PUSH
124091: EMPTY
124092: ST_TO_ADDR
// hackLimit := 3 ;
124093: LD_ADDR_EXP 205
124097: PUSH
124098: LD_INT 3
124100: ST_TO_ADDR
// hackDist := 12 ;
124101: LD_ADDR_EXP 206
124105: PUSH
124106: LD_INT 12
124108: ST_TO_ADDR
// hackCounter := [ ] ;
124109: LD_ADDR_EXP 207
124113: PUSH
124114: EMPTY
124115: ST_TO_ADDR
// end ;
124116: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
124117: LD_EXP 202
124121: PUSH
124122: LD_INT 34
124124: PUSH
124125: LD_INT 99
124127: PUSH
124128: EMPTY
124129: LIST
124130: LIST
124131: PPUSH
124132: CALL_OW 69
124136: AND
124137: IFFALSE 124390
124139: GO 124141
124141: DISABLE
124142: LD_INT 0
124144: PPUSH
124145: PPUSH
// begin enable ;
124146: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
124147: LD_ADDR_VAR 0 1
124151: PUSH
124152: LD_INT 34
124154: PUSH
124155: LD_INT 99
124157: PUSH
124158: EMPTY
124159: LIST
124160: LIST
124161: PPUSH
124162: CALL_OW 69
124166: PUSH
124167: FOR_IN
124168: IFFALSE 124388
// begin if not i in hackTanks then
124170: LD_VAR 0 1
124174: PUSH
124175: LD_EXP 203
124179: IN
124180: NOT
124181: IFFALSE 124264
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
124183: LD_ADDR_EXP 203
124187: PUSH
124188: LD_EXP 203
124192: PPUSH
124193: LD_EXP 203
124197: PUSH
124198: LD_INT 1
124200: PLUS
124201: PPUSH
124202: LD_VAR 0 1
124206: PPUSH
124207: CALL_OW 1
124211: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
124212: LD_ADDR_EXP 204
124216: PUSH
124217: LD_EXP 204
124221: PPUSH
124222: LD_EXP 204
124226: PUSH
124227: LD_INT 1
124229: PLUS
124230: PPUSH
124231: EMPTY
124232: PPUSH
124233: CALL_OW 1
124237: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
124238: LD_ADDR_EXP 207
124242: PUSH
124243: LD_EXP 207
124247: PPUSH
124248: LD_EXP 207
124252: PUSH
124253: LD_INT 1
124255: PLUS
124256: PPUSH
124257: EMPTY
124258: PPUSH
124259: CALL_OW 1
124263: ST_TO_ADDR
// end ; if not IsOk ( i ) then
124264: LD_VAR 0 1
124268: PPUSH
124269: CALL_OW 302
124273: NOT
124274: IFFALSE 124287
// begin HackUnlinkAll ( i ) ;
124276: LD_VAR 0 1
124280: PPUSH
124281: CALL 124393 0 1
// continue ;
124285: GO 124167
// end ; HackCheckCapturedStatus ( i ) ;
124287: LD_VAR 0 1
124291: PPUSH
124292: CALL 124836 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
124296: LD_ADDR_VAR 0 2
124300: PUSH
124301: LD_INT 81
124303: PUSH
124304: LD_VAR 0 1
124308: PPUSH
124309: CALL_OW 255
124313: PUSH
124314: EMPTY
124315: LIST
124316: LIST
124317: PUSH
124318: LD_INT 33
124320: PUSH
124321: LD_INT 3
124323: PUSH
124324: EMPTY
124325: LIST
124326: LIST
124327: PUSH
124328: LD_INT 91
124330: PUSH
124331: LD_VAR 0 1
124335: PUSH
124336: LD_EXP 206
124340: PUSH
124341: EMPTY
124342: LIST
124343: LIST
124344: LIST
124345: PUSH
124346: LD_INT 50
124348: PUSH
124349: EMPTY
124350: LIST
124351: PUSH
124352: EMPTY
124353: LIST
124354: LIST
124355: LIST
124356: LIST
124357: PPUSH
124358: CALL_OW 69
124362: ST_TO_ADDR
// if not tmp then
124363: LD_VAR 0 2
124367: NOT
124368: IFFALSE 124372
// continue ;
124370: GO 124167
// HackLink ( i , tmp ) ;
124372: LD_VAR 0 1
124376: PPUSH
124377: LD_VAR 0 2
124381: PPUSH
124382: CALL 124529 0 2
// end ;
124386: GO 124167
124388: POP
124389: POP
// end ;
124390: PPOPN 2
124392: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
124393: LD_INT 0
124395: PPUSH
124396: PPUSH
124397: PPUSH
// if not hack in hackTanks then
124398: LD_VAR 0 1
124402: PUSH
124403: LD_EXP 203
124407: IN
124408: NOT
124409: IFFALSE 124413
// exit ;
124411: GO 124524
// index := GetElementIndex ( hackTanks , hack ) ;
124413: LD_ADDR_VAR 0 4
124417: PUSH
124418: LD_EXP 203
124422: PPUSH
124423: LD_VAR 0 1
124427: PPUSH
124428: CALL 70945 0 2
124432: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
124433: LD_EXP 204
124437: PUSH
124438: LD_VAR 0 4
124442: ARRAY
124443: IFFALSE 124524
// begin for i in hackTanksCaptured [ index ] do
124445: LD_ADDR_VAR 0 3
124449: PUSH
124450: LD_EXP 204
124454: PUSH
124455: LD_VAR 0 4
124459: ARRAY
124460: PUSH
124461: FOR_IN
124462: IFFALSE 124488
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
124464: LD_VAR 0 3
124468: PUSH
124469: LD_INT 1
124471: ARRAY
124472: PPUSH
124473: LD_VAR 0 3
124477: PUSH
124478: LD_INT 2
124480: ARRAY
124481: PPUSH
124482: CALL_OW 235
124486: GO 124461
124488: POP
124489: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
124490: LD_ADDR_EXP 204
124494: PUSH
124495: LD_EXP 204
124499: PPUSH
124500: LD_VAR 0 4
124504: PPUSH
124505: EMPTY
124506: PPUSH
124507: CALL_OW 1
124511: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
124512: LD_VAR 0 1
124516: PPUSH
124517: LD_INT 0
124519: PPUSH
124520: CALL_OW 505
// end ; end ;
124524: LD_VAR 0 2
124528: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
124529: LD_INT 0
124531: PPUSH
124532: PPUSH
124533: PPUSH
// if not hack in hackTanks or not vehicles then
124534: LD_VAR 0 1
124538: PUSH
124539: LD_EXP 203
124543: IN
124544: NOT
124545: PUSH
124546: LD_VAR 0 2
124550: NOT
124551: OR
124552: IFFALSE 124556
// exit ;
124554: GO 124831
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
124556: LD_ADDR_VAR 0 2
124560: PUSH
124561: LD_VAR 0 1
124565: PPUSH
124566: LD_VAR 0 2
124570: PPUSH
124571: LD_INT 1
124573: PPUSH
124574: LD_INT 1
124576: PPUSH
124577: CALL 71595 0 4
124581: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
124582: LD_ADDR_VAR 0 5
124586: PUSH
124587: LD_EXP 203
124591: PPUSH
124592: LD_VAR 0 1
124596: PPUSH
124597: CALL 70945 0 2
124601: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
124602: LD_EXP 204
124606: PUSH
124607: LD_VAR 0 5
124611: ARRAY
124612: PUSH
124613: LD_EXP 205
124617: LESS
124618: IFFALSE 124807
// begin for i := 1 to vehicles do
124620: LD_ADDR_VAR 0 4
124624: PUSH
124625: DOUBLE
124626: LD_INT 1
124628: DEC
124629: ST_TO_ADDR
124630: LD_VAR 0 2
124634: PUSH
124635: FOR_TO
124636: IFFALSE 124805
// begin if hackTanksCaptured [ index ] = hackLimit then
124638: LD_EXP 204
124642: PUSH
124643: LD_VAR 0 5
124647: ARRAY
124648: PUSH
124649: LD_EXP 205
124653: EQUAL
124654: IFFALSE 124658
// break ;
124656: GO 124805
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
124658: LD_ADDR_EXP 207
124662: PUSH
124663: LD_EXP 207
124667: PPUSH
124668: LD_VAR 0 5
124672: PPUSH
124673: LD_EXP 207
124677: PUSH
124678: LD_VAR 0 5
124682: ARRAY
124683: PUSH
124684: LD_INT 1
124686: PLUS
124687: PPUSH
124688: CALL_OW 1
124692: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
124693: LD_ADDR_EXP 204
124697: PUSH
124698: LD_EXP 204
124702: PPUSH
124703: LD_VAR 0 5
124707: PUSH
124708: LD_EXP 204
124712: PUSH
124713: LD_VAR 0 5
124717: ARRAY
124718: PUSH
124719: LD_INT 1
124721: PLUS
124722: PUSH
124723: EMPTY
124724: LIST
124725: LIST
124726: PPUSH
124727: LD_VAR 0 2
124731: PUSH
124732: LD_VAR 0 4
124736: ARRAY
124737: PUSH
124738: LD_VAR 0 2
124742: PUSH
124743: LD_VAR 0 4
124747: ARRAY
124748: PPUSH
124749: CALL_OW 255
124753: PUSH
124754: EMPTY
124755: LIST
124756: LIST
124757: PPUSH
124758: CALL 71160 0 3
124762: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
124763: LD_VAR 0 2
124767: PUSH
124768: LD_VAR 0 4
124772: ARRAY
124773: PPUSH
124774: LD_VAR 0 1
124778: PPUSH
124779: CALL_OW 255
124783: PPUSH
124784: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
124788: LD_VAR 0 2
124792: PUSH
124793: LD_VAR 0 4
124797: ARRAY
124798: PPUSH
124799: CALL_OW 141
// end ;
124803: GO 124635
124805: POP
124806: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
124807: LD_VAR 0 1
124811: PPUSH
124812: LD_EXP 204
124816: PUSH
124817: LD_VAR 0 5
124821: ARRAY
124822: PUSH
124823: LD_INT 0
124825: PLUS
124826: PPUSH
124827: CALL_OW 505
// end ;
124831: LD_VAR 0 3
124835: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
124836: LD_INT 0
124838: PPUSH
124839: PPUSH
124840: PPUSH
124841: PPUSH
// if not hack in hackTanks then
124842: LD_VAR 0 1
124846: PUSH
124847: LD_EXP 203
124851: IN
124852: NOT
124853: IFFALSE 124857
// exit ;
124855: GO 125097
// index := GetElementIndex ( hackTanks , hack ) ;
124857: LD_ADDR_VAR 0 4
124861: PUSH
124862: LD_EXP 203
124866: PPUSH
124867: LD_VAR 0 1
124871: PPUSH
124872: CALL 70945 0 2
124876: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
124877: LD_ADDR_VAR 0 3
124881: PUSH
124882: DOUBLE
124883: LD_EXP 204
124887: PUSH
124888: LD_VAR 0 4
124892: ARRAY
124893: INC
124894: ST_TO_ADDR
124895: LD_INT 1
124897: PUSH
124898: FOR_DOWNTO
124899: IFFALSE 125071
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
124901: LD_ADDR_VAR 0 5
124905: PUSH
124906: LD_EXP 204
124910: PUSH
124911: LD_VAR 0 4
124915: ARRAY
124916: PUSH
124917: LD_VAR 0 3
124921: ARRAY
124922: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
124923: LD_VAR 0 5
124927: PUSH
124928: LD_INT 1
124930: ARRAY
124931: PPUSH
124932: CALL_OW 302
124936: NOT
124937: PUSH
124938: LD_VAR 0 5
124942: PUSH
124943: LD_INT 1
124945: ARRAY
124946: PPUSH
124947: CALL_OW 255
124951: PUSH
124952: LD_VAR 0 1
124956: PPUSH
124957: CALL_OW 255
124961: NONEQUAL
124962: OR
124963: IFFALSE 125069
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
124965: LD_VAR 0 5
124969: PUSH
124970: LD_INT 1
124972: ARRAY
124973: PPUSH
124974: CALL_OW 305
124978: PUSH
124979: LD_VAR 0 5
124983: PUSH
124984: LD_INT 1
124986: ARRAY
124987: PPUSH
124988: CALL_OW 255
124992: PUSH
124993: LD_VAR 0 1
124997: PPUSH
124998: CALL_OW 255
125002: EQUAL
125003: AND
125004: IFFALSE 125028
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
125006: LD_VAR 0 5
125010: PUSH
125011: LD_INT 1
125013: ARRAY
125014: PPUSH
125015: LD_VAR 0 5
125019: PUSH
125020: LD_INT 2
125022: ARRAY
125023: PPUSH
125024: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
125028: LD_ADDR_EXP 204
125032: PUSH
125033: LD_EXP 204
125037: PPUSH
125038: LD_VAR 0 4
125042: PPUSH
125043: LD_EXP 204
125047: PUSH
125048: LD_VAR 0 4
125052: ARRAY
125053: PPUSH
125054: LD_VAR 0 3
125058: PPUSH
125059: CALL_OW 3
125063: PPUSH
125064: CALL_OW 1
125068: ST_TO_ADDR
// end ; end ;
125069: GO 124898
125071: POP
125072: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
125073: LD_VAR 0 1
125077: PPUSH
125078: LD_EXP 204
125082: PUSH
125083: LD_VAR 0 4
125087: ARRAY
125088: PUSH
125089: LD_INT 0
125091: PLUS
125092: PPUSH
125093: CALL_OW 505
// end ;
125097: LD_VAR 0 2
125101: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
125102: LD_INT 0
125104: PPUSH
125105: PPUSH
125106: PPUSH
125107: PPUSH
// if not hack in hackTanks then
125108: LD_VAR 0 1
125112: PUSH
125113: LD_EXP 203
125117: IN
125118: NOT
125119: IFFALSE 125123
// exit ;
125121: GO 125208
// index := GetElementIndex ( hackTanks , hack ) ;
125123: LD_ADDR_VAR 0 5
125127: PUSH
125128: LD_EXP 203
125132: PPUSH
125133: LD_VAR 0 1
125137: PPUSH
125138: CALL 70945 0 2
125142: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
125143: LD_ADDR_VAR 0 4
125147: PUSH
125148: DOUBLE
125149: LD_INT 1
125151: DEC
125152: ST_TO_ADDR
125153: LD_EXP 204
125157: PUSH
125158: LD_VAR 0 5
125162: ARRAY
125163: PUSH
125164: FOR_TO
125165: IFFALSE 125206
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
125167: LD_EXP 204
125171: PUSH
125172: LD_VAR 0 5
125176: ARRAY
125177: PUSH
125178: LD_VAR 0 4
125182: ARRAY
125183: PUSH
125184: LD_INT 1
125186: ARRAY
125187: PUSH
125188: LD_VAR 0 2
125192: EQUAL
125193: IFFALSE 125204
// KillUnit ( vehicle ) ;
125195: LD_VAR 0 2
125199: PPUSH
125200: CALL_OW 66
125204: GO 125164
125206: POP
125207: POP
// end ;
125208: LD_VAR 0 3
125212: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
125213: LD_EXP 208
125217: NOT
125218: IFFALSE 125253
125220: GO 125222
125222: DISABLE
// begin initMiner := true ;
125223: LD_ADDR_EXP 208
125227: PUSH
125228: LD_INT 1
125230: ST_TO_ADDR
// minersList := [ ] ;
125231: LD_ADDR_EXP 209
125235: PUSH
125236: EMPTY
125237: ST_TO_ADDR
// minerMinesList := [ ] ;
125238: LD_ADDR_EXP 210
125242: PUSH
125243: EMPTY
125244: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
125245: LD_ADDR_EXP 211
125249: PUSH
125250: LD_INT 5
125252: ST_TO_ADDR
// end ;
125253: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
125254: LD_EXP 208
125258: PUSH
125259: LD_INT 34
125261: PUSH
125262: LD_INT 81
125264: PUSH
125265: EMPTY
125266: LIST
125267: LIST
125268: PPUSH
125269: CALL_OW 69
125273: AND
125274: IFFALSE 125735
125276: GO 125278
125278: DISABLE
125279: LD_INT 0
125281: PPUSH
125282: PPUSH
125283: PPUSH
125284: PPUSH
// begin enable ;
125285: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
125286: LD_ADDR_VAR 0 1
125290: PUSH
125291: LD_INT 34
125293: PUSH
125294: LD_INT 81
125296: PUSH
125297: EMPTY
125298: LIST
125299: LIST
125300: PPUSH
125301: CALL_OW 69
125305: PUSH
125306: FOR_IN
125307: IFFALSE 125379
// begin if not i in minersList then
125309: LD_VAR 0 1
125313: PUSH
125314: LD_EXP 209
125318: IN
125319: NOT
125320: IFFALSE 125377
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
125322: LD_ADDR_EXP 209
125326: PUSH
125327: LD_EXP 209
125331: PPUSH
125332: LD_EXP 209
125336: PUSH
125337: LD_INT 1
125339: PLUS
125340: PPUSH
125341: LD_VAR 0 1
125345: PPUSH
125346: CALL_OW 1
125350: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
125351: LD_ADDR_EXP 210
125355: PUSH
125356: LD_EXP 210
125360: PPUSH
125361: LD_EXP 210
125365: PUSH
125366: LD_INT 1
125368: PLUS
125369: PPUSH
125370: EMPTY
125371: PPUSH
125372: CALL_OW 1
125376: ST_TO_ADDR
// end end ;
125377: GO 125306
125379: POP
125380: POP
// for i := minerMinesList downto 1 do
125381: LD_ADDR_VAR 0 1
125385: PUSH
125386: DOUBLE
125387: LD_EXP 210
125391: INC
125392: ST_TO_ADDR
125393: LD_INT 1
125395: PUSH
125396: FOR_DOWNTO
125397: IFFALSE 125733
// begin if IsLive ( minersList [ i ] ) then
125399: LD_EXP 209
125403: PUSH
125404: LD_VAR 0 1
125408: ARRAY
125409: PPUSH
125410: CALL_OW 300
125414: IFFALSE 125442
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
125416: LD_EXP 209
125420: PUSH
125421: LD_VAR 0 1
125425: ARRAY
125426: PPUSH
125427: LD_EXP 210
125431: PUSH
125432: LD_VAR 0 1
125436: ARRAY
125437: PPUSH
125438: CALL_OW 505
// if not minerMinesList [ i ] then
125442: LD_EXP 210
125446: PUSH
125447: LD_VAR 0 1
125451: ARRAY
125452: NOT
125453: IFFALSE 125457
// continue ;
125455: GO 125396
// for j := minerMinesList [ i ] downto 1 do
125457: LD_ADDR_VAR 0 2
125461: PUSH
125462: DOUBLE
125463: LD_EXP 210
125467: PUSH
125468: LD_VAR 0 1
125472: ARRAY
125473: INC
125474: ST_TO_ADDR
125475: LD_INT 1
125477: PUSH
125478: FOR_DOWNTO
125479: IFFALSE 125729
// begin side := GetSide ( minersList [ i ] ) ;
125481: LD_ADDR_VAR 0 3
125485: PUSH
125486: LD_EXP 209
125490: PUSH
125491: LD_VAR 0 1
125495: ARRAY
125496: PPUSH
125497: CALL_OW 255
125501: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
125502: LD_ADDR_VAR 0 4
125506: PUSH
125507: LD_EXP 210
125511: PUSH
125512: LD_VAR 0 1
125516: ARRAY
125517: PUSH
125518: LD_VAR 0 2
125522: ARRAY
125523: PUSH
125524: LD_INT 1
125526: ARRAY
125527: PPUSH
125528: LD_EXP 210
125532: PUSH
125533: LD_VAR 0 1
125537: ARRAY
125538: PUSH
125539: LD_VAR 0 2
125543: ARRAY
125544: PUSH
125545: LD_INT 2
125547: ARRAY
125548: PPUSH
125549: CALL_OW 428
125553: ST_TO_ADDR
// if not tmp then
125554: LD_VAR 0 4
125558: NOT
125559: IFFALSE 125563
// continue ;
125561: GO 125478
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
125563: LD_VAR 0 4
125567: PUSH
125568: LD_INT 81
125570: PUSH
125571: LD_VAR 0 3
125575: PUSH
125576: EMPTY
125577: LIST
125578: LIST
125579: PPUSH
125580: CALL_OW 69
125584: IN
125585: PUSH
125586: LD_EXP 210
125590: PUSH
125591: LD_VAR 0 1
125595: ARRAY
125596: PUSH
125597: LD_VAR 0 2
125601: ARRAY
125602: PUSH
125603: LD_INT 1
125605: ARRAY
125606: PPUSH
125607: LD_EXP 210
125611: PUSH
125612: LD_VAR 0 1
125616: ARRAY
125617: PUSH
125618: LD_VAR 0 2
125622: ARRAY
125623: PUSH
125624: LD_INT 2
125626: ARRAY
125627: PPUSH
125628: CALL_OW 458
125632: AND
125633: IFFALSE 125727
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
125635: LD_EXP 210
125639: PUSH
125640: LD_VAR 0 1
125644: ARRAY
125645: PUSH
125646: LD_VAR 0 2
125650: ARRAY
125651: PUSH
125652: LD_INT 1
125654: ARRAY
125655: PPUSH
125656: LD_EXP 210
125660: PUSH
125661: LD_VAR 0 1
125665: ARRAY
125666: PUSH
125667: LD_VAR 0 2
125671: ARRAY
125672: PUSH
125673: LD_INT 2
125675: ARRAY
125676: PPUSH
125677: LD_VAR 0 3
125681: PPUSH
125682: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
125686: LD_ADDR_EXP 210
125690: PUSH
125691: LD_EXP 210
125695: PPUSH
125696: LD_VAR 0 1
125700: PPUSH
125701: LD_EXP 210
125705: PUSH
125706: LD_VAR 0 1
125710: ARRAY
125711: PPUSH
125712: LD_VAR 0 2
125716: PPUSH
125717: CALL_OW 3
125721: PPUSH
125722: CALL_OW 1
125726: ST_TO_ADDR
// end ; end ;
125727: GO 125478
125729: POP
125730: POP
// end ;
125731: GO 125396
125733: POP
125734: POP
// end ;
125735: PPOPN 4
125737: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
125738: LD_INT 0
125740: PPUSH
125741: PPUSH
// result := false ;
125742: LD_ADDR_VAR 0 4
125746: PUSH
125747: LD_INT 0
125749: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
125750: LD_VAR 0 1
125754: PPUSH
125755: CALL_OW 264
125759: PUSH
125760: LD_INT 81
125762: EQUAL
125763: NOT
125764: IFFALSE 125768
// exit ;
125766: GO 126008
// index := GetElementIndex ( minersList , unit ) ;
125768: LD_ADDR_VAR 0 5
125772: PUSH
125773: LD_EXP 209
125777: PPUSH
125778: LD_VAR 0 1
125782: PPUSH
125783: CALL 70945 0 2
125787: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
125788: LD_EXP 210
125792: PUSH
125793: LD_VAR 0 5
125797: ARRAY
125798: PUSH
125799: LD_EXP 211
125803: GREATEREQUAL
125804: IFFALSE 125808
// exit ;
125806: GO 126008
// ComMoveXY ( unit , x , y ) ;
125808: LD_VAR 0 1
125812: PPUSH
125813: LD_VAR 0 2
125817: PPUSH
125818: LD_VAR 0 3
125822: PPUSH
125823: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
125827: LD_INT 35
125829: PPUSH
125830: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
125834: LD_VAR 0 1
125838: PPUSH
125839: LD_VAR 0 2
125843: PPUSH
125844: LD_VAR 0 3
125848: PPUSH
125849: CALL 102281 0 3
125853: NOT
125854: PUSH
125855: LD_VAR 0 1
125859: PPUSH
125860: CALL_OW 314
125864: AND
125865: IFFALSE 125869
// exit ;
125867: GO 126008
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
125869: LD_VAR 0 2
125873: PPUSH
125874: LD_VAR 0 3
125878: PPUSH
125879: CALL_OW 428
125883: PUSH
125884: LD_VAR 0 1
125888: EQUAL
125889: PUSH
125890: LD_VAR 0 1
125894: PPUSH
125895: CALL_OW 314
125899: NOT
125900: AND
125901: IFFALSE 125827
// PlaySoundXY ( x , y , PlantMine ) ;
125903: LD_VAR 0 2
125907: PPUSH
125908: LD_VAR 0 3
125912: PPUSH
125913: LD_STRING PlantMine
125915: PPUSH
125916: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
125920: LD_VAR 0 2
125924: PPUSH
125925: LD_VAR 0 3
125929: PPUSH
125930: LD_VAR 0 1
125934: PPUSH
125935: CALL_OW 255
125939: PPUSH
125940: LD_INT 0
125942: PPUSH
125943: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
125947: LD_ADDR_EXP 210
125951: PUSH
125952: LD_EXP 210
125956: PPUSH
125957: LD_VAR 0 5
125961: PUSH
125962: LD_EXP 210
125966: PUSH
125967: LD_VAR 0 5
125971: ARRAY
125972: PUSH
125973: LD_INT 1
125975: PLUS
125976: PUSH
125977: EMPTY
125978: LIST
125979: LIST
125980: PPUSH
125981: LD_VAR 0 2
125985: PUSH
125986: LD_VAR 0 3
125990: PUSH
125991: EMPTY
125992: LIST
125993: LIST
125994: PPUSH
125995: CALL 71160 0 3
125999: ST_TO_ADDR
// result := true ;
126000: LD_ADDR_VAR 0 4
126004: PUSH
126005: LD_INT 1
126007: ST_TO_ADDR
// end ;
126008: LD_VAR 0 4
126012: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
126013: LD_INT 0
126015: PPUSH
126016: PPUSH
126017: PPUSH
// if not unit in minersList then
126018: LD_VAR 0 1
126022: PUSH
126023: LD_EXP 209
126027: IN
126028: NOT
126029: IFFALSE 126033
// exit ;
126031: GO 126425
// index := GetElementIndex ( minersList , unit ) ;
126033: LD_ADDR_VAR 0 6
126037: PUSH
126038: LD_EXP 209
126042: PPUSH
126043: LD_VAR 0 1
126047: PPUSH
126048: CALL 70945 0 2
126052: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
126053: LD_ADDR_VAR 0 5
126057: PUSH
126058: DOUBLE
126059: LD_EXP 210
126063: PUSH
126064: LD_VAR 0 6
126068: ARRAY
126069: INC
126070: ST_TO_ADDR
126071: LD_INT 1
126073: PUSH
126074: FOR_DOWNTO
126075: IFFALSE 126236
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
126077: LD_EXP 210
126081: PUSH
126082: LD_VAR 0 6
126086: ARRAY
126087: PUSH
126088: LD_VAR 0 5
126092: ARRAY
126093: PUSH
126094: LD_INT 1
126096: ARRAY
126097: PUSH
126098: LD_VAR 0 2
126102: EQUAL
126103: PUSH
126104: LD_EXP 210
126108: PUSH
126109: LD_VAR 0 6
126113: ARRAY
126114: PUSH
126115: LD_VAR 0 5
126119: ARRAY
126120: PUSH
126121: LD_INT 2
126123: ARRAY
126124: PUSH
126125: LD_VAR 0 3
126129: EQUAL
126130: AND
126131: IFFALSE 126234
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
126133: LD_EXP 210
126137: PUSH
126138: LD_VAR 0 6
126142: ARRAY
126143: PUSH
126144: LD_VAR 0 5
126148: ARRAY
126149: PUSH
126150: LD_INT 1
126152: ARRAY
126153: PPUSH
126154: LD_EXP 210
126158: PUSH
126159: LD_VAR 0 6
126163: ARRAY
126164: PUSH
126165: LD_VAR 0 5
126169: ARRAY
126170: PUSH
126171: LD_INT 2
126173: ARRAY
126174: PPUSH
126175: LD_VAR 0 1
126179: PPUSH
126180: CALL_OW 255
126184: PPUSH
126185: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
126189: LD_ADDR_EXP 210
126193: PUSH
126194: LD_EXP 210
126198: PPUSH
126199: LD_VAR 0 6
126203: PPUSH
126204: LD_EXP 210
126208: PUSH
126209: LD_VAR 0 6
126213: ARRAY
126214: PPUSH
126215: LD_VAR 0 5
126219: PPUSH
126220: CALL_OW 3
126224: PPUSH
126225: CALL_OW 1
126229: ST_TO_ADDR
// exit ;
126230: POP
126231: POP
126232: GO 126425
// end ; end ;
126234: GO 126074
126236: POP
126237: POP
// for i := minerMinesList [ index ] downto 1 do
126238: LD_ADDR_VAR 0 5
126242: PUSH
126243: DOUBLE
126244: LD_EXP 210
126248: PUSH
126249: LD_VAR 0 6
126253: ARRAY
126254: INC
126255: ST_TO_ADDR
126256: LD_INT 1
126258: PUSH
126259: FOR_DOWNTO
126260: IFFALSE 126423
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
126262: LD_EXP 210
126266: PUSH
126267: LD_VAR 0 6
126271: ARRAY
126272: PUSH
126273: LD_VAR 0 5
126277: ARRAY
126278: PUSH
126279: LD_INT 1
126281: ARRAY
126282: PPUSH
126283: LD_EXP 210
126287: PUSH
126288: LD_VAR 0 6
126292: ARRAY
126293: PUSH
126294: LD_VAR 0 5
126298: ARRAY
126299: PUSH
126300: LD_INT 2
126302: ARRAY
126303: PPUSH
126304: LD_VAR 0 2
126308: PPUSH
126309: LD_VAR 0 3
126313: PPUSH
126314: CALL_OW 298
126318: PUSH
126319: LD_INT 6
126321: LESS
126322: IFFALSE 126421
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
126324: LD_EXP 210
126328: PUSH
126329: LD_VAR 0 6
126333: ARRAY
126334: PUSH
126335: LD_VAR 0 5
126339: ARRAY
126340: PUSH
126341: LD_INT 1
126343: ARRAY
126344: PPUSH
126345: LD_EXP 210
126349: PUSH
126350: LD_VAR 0 6
126354: ARRAY
126355: PUSH
126356: LD_VAR 0 5
126360: ARRAY
126361: PUSH
126362: LD_INT 2
126364: ARRAY
126365: PPUSH
126366: LD_VAR 0 1
126370: PPUSH
126371: CALL_OW 255
126375: PPUSH
126376: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
126380: LD_ADDR_EXP 210
126384: PUSH
126385: LD_EXP 210
126389: PPUSH
126390: LD_VAR 0 6
126394: PPUSH
126395: LD_EXP 210
126399: PUSH
126400: LD_VAR 0 6
126404: ARRAY
126405: PPUSH
126406: LD_VAR 0 5
126410: PPUSH
126411: CALL_OW 3
126415: PPUSH
126416: CALL_OW 1
126420: ST_TO_ADDR
// end ; end ;
126421: GO 126259
126423: POP
126424: POP
// end ;
126425: LD_VAR 0 4
126429: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
126430: LD_INT 0
126432: PPUSH
126433: PPUSH
126434: PPUSH
126435: PPUSH
126436: PPUSH
126437: PPUSH
126438: PPUSH
126439: PPUSH
126440: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
126441: LD_VAR 0 1
126445: PPUSH
126446: CALL_OW 264
126450: PUSH
126451: LD_INT 81
126453: EQUAL
126454: NOT
126455: PUSH
126456: LD_VAR 0 1
126460: PUSH
126461: LD_EXP 209
126465: IN
126466: NOT
126467: OR
126468: IFFALSE 126472
// exit ;
126470: GO 126794
// index := GetElementIndex ( minersList , unit ) ;
126472: LD_ADDR_VAR 0 6
126476: PUSH
126477: LD_EXP 209
126481: PPUSH
126482: LD_VAR 0 1
126486: PPUSH
126487: CALL 70945 0 2
126491: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
126492: LD_ADDR_VAR 0 8
126496: PUSH
126497: LD_EXP 211
126501: PUSH
126502: LD_EXP 210
126506: PUSH
126507: LD_VAR 0 6
126511: ARRAY
126512: MINUS
126513: ST_TO_ADDR
// if not minesFreeAmount then
126514: LD_VAR 0 8
126518: NOT
126519: IFFALSE 126523
// exit ;
126521: GO 126794
// tmp := [ ] ;
126523: LD_ADDR_VAR 0 7
126527: PUSH
126528: EMPTY
126529: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
126530: LD_ADDR_VAR 0 5
126534: PUSH
126535: DOUBLE
126536: LD_INT 1
126538: DEC
126539: ST_TO_ADDR
126540: LD_VAR 0 8
126544: PUSH
126545: FOR_TO
126546: IFFALSE 126741
// begin _d := rand ( 0 , 5 ) ;
126548: LD_ADDR_VAR 0 11
126552: PUSH
126553: LD_INT 0
126555: PPUSH
126556: LD_INT 5
126558: PPUSH
126559: CALL_OW 12
126563: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
126564: LD_ADDR_VAR 0 12
126568: PUSH
126569: LD_INT 2
126571: PPUSH
126572: LD_INT 6
126574: PPUSH
126575: CALL_OW 12
126579: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
126580: LD_ADDR_VAR 0 9
126584: PUSH
126585: LD_VAR 0 2
126589: PPUSH
126590: LD_VAR 0 11
126594: PPUSH
126595: LD_VAR 0 12
126599: PPUSH
126600: CALL_OW 272
126604: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
126605: LD_ADDR_VAR 0 10
126609: PUSH
126610: LD_VAR 0 3
126614: PPUSH
126615: LD_VAR 0 11
126619: PPUSH
126620: LD_VAR 0 12
126624: PPUSH
126625: CALL_OW 273
126629: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
126630: LD_VAR 0 9
126634: PPUSH
126635: LD_VAR 0 10
126639: PPUSH
126640: CALL_OW 488
126644: PUSH
126645: LD_VAR 0 9
126649: PUSH
126650: LD_VAR 0 10
126654: PUSH
126655: EMPTY
126656: LIST
126657: LIST
126658: PUSH
126659: LD_VAR 0 7
126663: IN
126664: NOT
126665: AND
126666: PUSH
126667: LD_VAR 0 9
126671: PPUSH
126672: LD_VAR 0 10
126676: PPUSH
126677: CALL_OW 458
126681: NOT
126682: AND
126683: IFFALSE 126725
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
126685: LD_ADDR_VAR 0 7
126689: PUSH
126690: LD_VAR 0 7
126694: PPUSH
126695: LD_VAR 0 7
126699: PUSH
126700: LD_INT 1
126702: PLUS
126703: PPUSH
126704: LD_VAR 0 9
126708: PUSH
126709: LD_VAR 0 10
126713: PUSH
126714: EMPTY
126715: LIST
126716: LIST
126717: PPUSH
126718: CALL_OW 1
126722: ST_TO_ADDR
126723: GO 126739
// i := i - 1 ;
126725: LD_ADDR_VAR 0 5
126729: PUSH
126730: LD_VAR 0 5
126734: PUSH
126735: LD_INT 1
126737: MINUS
126738: ST_TO_ADDR
// end ;
126739: GO 126545
126741: POP
126742: POP
// for i in tmp do
126743: LD_ADDR_VAR 0 5
126747: PUSH
126748: LD_VAR 0 7
126752: PUSH
126753: FOR_IN
126754: IFFALSE 126792
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
126756: LD_VAR 0 1
126760: PPUSH
126761: LD_VAR 0 5
126765: PUSH
126766: LD_INT 1
126768: ARRAY
126769: PPUSH
126770: LD_VAR 0 5
126774: PUSH
126775: LD_INT 2
126777: ARRAY
126778: PPUSH
126779: CALL 125738 0 3
126783: NOT
126784: IFFALSE 126790
// exit ;
126786: POP
126787: POP
126788: GO 126794
126790: GO 126753
126792: POP
126793: POP
// end ;
126794: LD_VAR 0 4
126798: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
126799: LD_INT 0
126801: PPUSH
126802: PPUSH
126803: PPUSH
126804: PPUSH
126805: PPUSH
126806: PPUSH
126807: PPUSH
// if not GetClass ( unit ) = class_sniper then
126808: LD_VAR 0 1
126812: PPUSH
126813: CALL_OW 257
126817: PUSH
126818: LD_INT 5
126820: EQUAL
126821: NOT
126822: IFFALSE 126826
// exit ;
126824: GO 127214
// dist := 8 ;
126826: LD_ADDR_VAR 0 5
126830: PUSH
126831: LD_INT 8
126833: ST_TO_ADDR
// viewRange := 12 ;
126834: LD_ADDR_VAR 0 7
126838: PUSH
126839: LD_INT 12
126841: ST_TO_ADDR
// side := GetSide ( unit ) ;
126842: LD_ADDR_VAR 0 6
126846: PUSH
126847: LD_VAR 0 1
126851: PPUSH
126852: CALL_OW 255
126856: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
126857: LD_INT 61
126859: PPUSH
126860: LD_VAR 0 6
126864: PPUSH
126865: CALL_OW 321
126869: PUSH
126870: LD_INT 2
126872: EQUAL
126873: IFFALSE 126883
// viewRange := 16 ;
126875: LD_ADDR_VAR 0 7
126879: PUSH
126880: LD_INT 16
126882: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
126883: LD_VAR 0 1
126887: PPUSH
126888: LD_VAR 0 2
126892: PPUSH
126893: LD_VAR 0 3
126897: PPUSH
126898: CALL_OW 297
126902: PUSH
126903: LD_VAR 0 5
126907: GREATER
126908: IFFALSE 126987
// begin ComMoveXY ( unit , x , y ) ;
126910: LD_VAR 0 1
126914: PPUSH
126915: LD_VAR 0 2
126919: PPUSH
126920: LD_VAR 0 3
126924: PPUSH
126925: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
126929: LD_INT 35
126931: PPUSH
126932: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
126936: LD_VAR 0 1
126940: PPUSH
126941: LD_VAR 0 2
126945: PPUSH
126946: LD_VAR 0 3
126950: PPUSH
126951: CALL 102281 0 3
126955: NOT
126956: IFFALSE 126960
// exit ;
126958: GO 127214
// until GetDistUnitXY ( unit , x , y ) < dist ;
126960: LD_VAR 0 1
126964: PPUSH
126965: LD_VAR 0 2
126969: PPUSH
126970: LD_VAR 0 3
126974: PPUSH
126975: CALL_OW 297
126979: PUSH
126980: LD_VAR 0 5
126984: LESS
126985: IFFALSE 126929
// end ; ComTurnXY ( unit , x , y ) ;
126987: LD_VAR 0 1
126991: PPUSH
126992: LD_VAR 0 2
126996: PPUSH
126997: LD_VAR 0 3
127001: PPUSH
127002: CALL_OW 118
// wait ( 5 ) ;
127006: LD_INT 5
127008: PPUSH
127009: CALL_OW 67
// _d := GetDir ( unit ) ;
127013: LD_ADDR_VAR 0 10
127017: PUSH
127018: LD_VAR 0 1
127022: PPUSH
127023: CALL_OW 254
127027: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
127028: LD_ADDR_VAR 0 8
127032: PUSH
127033: LD_VAR 0 1
127037: PPUSH
127038: CALL_OW 250
127042: PPUSH
127043: LD_VAR 0 10
127047: PPUSH
127048: LD_VAR 0 5
127052: PPUSH
127053: CALL_OW 272
127057: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
127058: LD_ADDR_VAR 0 9
127062: PUSH
127063: LD_VAR 0 1
127067: PPUSH
127068: CALL_OW 251
127072: PPUSH
127073: LD_VAR 0 10
127077: PPUSH
127078: LD_VAR 0 5
127082: PPUSH
127083: CALL_OW 273
127087: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
127088: LD_VAR 0 8
127092: PPUSH
127093: LD_VAR 0 9
127097: PPUSH
127098: CALL_OW 488
127102: NOT
127103: IFFALSE 127107
// exit ;
127105: GO 127214
// ComAnimCustom ( unit , 1 ) ;
127107: LD_VAR 0 1
127111: PPUSH
127112: LD_INT 1
127114: PPUSH
127115: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
127119: LD_VAR 0 8
127123: PPUSH
127124: LD_VAR 0 9
127128: PPUSH
127129: LD_VAR 0 6
127133: PPUSH
127134: LD_VAR 0 7
127138: PPUSH
127139: CALL_OW 330
// repeat wait ( 1 ) ;
127143: LD_INT 1
127145: PPUSH
127146: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
127150: LD_VAR 0 1
127154: PPUSH
127155: CALL_OW 316
127159: PUSH
127160: LD_VAR 0 1
127164: PPUSH
127165: CALL_OW 314
127169: OR
127170: PUSH
127171: LD_VAR 0 1
127175: PPUSH
127176: CALL_OW 302
127180: NOT
127181: OR
127182: PUSH
127183: LD_VAR 0 1
127187: PPUSH
127188: CALL_OW 301
127192: OR
127193: IFFALSE 127143
// RemoveSeeing ( _x , _y , side ) ;
127195: LD_VAR 0 8
127199: PPUSH
127200: LD_VAR 0 9
127204: PPUSH
127205: LD_VAR 0 6
127209: PPUSH
127210: CALL_OW 331
// end ; end_of_file
127214: LD_VAR 0 4
127218: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
127219: LD_INT 0
127221: PPUSH
127222: PPUSH
127223: PPUSH
127224: PPUSH
127225: PPUSH
127226: PPUSH
127227: PPUSH
127228: PPUSH
127229: PPUSH
127230: PPUSH
127231: PPUSH
127232: PPUSH
127233: PPUSH
127234: PPUSH
127235: PPUSH
127236: PPUSH
127237: PPUSH
127238: PPUSH
127239: PPUSH
127240: PPUSH
127241: PPUSH
127242: PPUSH
127243: PPUSH
127244: PPUSH
127245: PPUSH
127246: PPUSH
127247: PPUSH
127248: PPUSH
127249: PPUSH
127250: PPUSH
127251: PPUSH
127252: PPUSH
127253: PPUSH
127254: PPUSH
// if not list then
127255: LD_VAR 0 1
127259: NOT
127260: IFFALSE 127264
// exit ;
127262: GO 131923
// base := list [ 1 ] ;
127264: LD_ADDR_VAR 0 3
127268: PUSH
127269: LD_VAR 0 1
127273: PUSH
127274: LD_INT 1
127276: ARRAY
127277: ST_TO_ADDR
// group := list [ 2 ] ;
127278: LD_ADDR_VAR 0 4
127282: PUSH
127283: LD_VAR 0 1
127287: PUSH
127288: LD_INT 2
127290: ARRAY
127291: ST_TO_ADDR
// path := list [ 3 ] ;
127292: LD_ADDR_VAR 0 5
127296: PUSH
127297: LD_VAR 0 1
127301: PUSH
127302: LD_INT 3
127304: ARRAY
127305: ST_TO_ADDR
// flags := list [ 4 ] ;
127306: LD_ADDR_VAR 0 6
127310: PUSH
127311: LD_VAR 0 1
127315: PUSH
127316: LD_INT 4
127318: ARRAY
127319: ST_TO_ADDR
// mined := [ ] ;
127320: LD_ADDR_VAR 0 27
127324: PUSH
127325: EMPTY
127326: ST_TO_ADDR
// bombed := [ ] ;
127327: LD_ADDR_VAR 0 28
127331: PUSH
127332: EMPTY
127333: ST_TO_ADDR
// healers := [ ] ;
127334: LD_ADDR_VAR 0 31
127338: PUSH
127339: EMPTY
127340: ST_TO_ADDR
// to_heal := [ ] ;
127341: LD_ADDR_VAR 0 30
127345: PUSH
127346: EMPTY
127347: ST_TO_ADDR
// repairs := [ ] ;
127348: LD_ADDR_VAR 0 33
127352: PUSH
127353: EMPTY
127354: ST_TO_ADDR
// to_repair := [ ] ;
127355: LD_ADDR_VAR 0 32
127359: PUSH
127360: EMPTY
127361: ST_TO_ADDR
// if not group or not path then
127362: LD_VAR 0 4
127366: NOT
127367: PUSH
127368: LD_VAR 0 5
127372: NOT
127373: OR
127374: IFFALSE 127378
// exit ;
127376: GO 131923
// side := GetSide ( group [ 1 ] ) ;
127378: LD_ADDR_VAR 0 35
127382: PUSH
127383: LD_VAR 0 4
127387: PUSH
127388: LD_INT 1
127390: ARRAY
127391: PPUSH
127392: CALL_OW 255
127396: ST_TO_ADDR
// if flags then
127397: LD_VAR 0 6
127401: IFFALSE 127545
// begin f_ignore_area := flags [ 1 ] ;
127403: LD_ADDR_VAR 0 17
127407: PUSH
127408: LD_VAR 0 6
127412: PUSH
127413: LD_INT 1
127415: ARRAY
127416: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
127417: LD_ADDR_VAR 0 18
127421: PUSH
127422: LD_VAR 0 6
127426: PUSH
127427: LD_INT 2
127429: ARRAY
127430: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
127431: LD_ADDR_VAR 0 19
127435: PUSH
127436: LD_VAR 0 6
127440: PUSH
127441: LD_INT 3
127443: ARRAY
127444: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
127445: LD_ADDR_VAR 0 20
127449: PUSH
127450: LD_VAR 0 6
127454: PUSH
127455: LD_INT 4
127457: ARRAY
127458: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
127459: LD_ADDR_VAR 0 21
127463: PUSH
127464: LD_VAR 0 6
127468: PUSH
127469: LD_INT 5
127471: ARRAY
127472: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
127473: LD_ADDR_VAR 0 22
127477: PUSH
127478: LD_VAR 0 6
127482: PUSH
127483: LD_INT 6
127485: ARRAY
127486: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
127487: LD_ADDR_VAR 0 23
127491: PUSH
127492: LD_VAR 0 6
127496: PUSH
127497: LD_INT 7
127499: ARRAY
127500: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
127501: LD_ADDR_VAR 0 24
127505: PUSH
127506: LD_VAR 0 6
127510: PUSH
127511: LD_INT 8
127513: ARRAY
127514: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
127515: LD_ADDR_VAR 0 25
127519: PUSH
127520: LD_VAR 0 6
127524: PUSH
127525: LD_INT 9
127527: ARRAY
127528: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
127529: LD_ADDR_VAR 0 26
127533: PUSH
127534: LD_VAR 0 6
127538: PUSH
127539: LD_INT 10
127541: ARRAY
127542: ST_TO_ADDR
// end else
127543: GO 127625
// begin f_ignore_area := false ;
127545: LD_ADDR_VAR 0 17
127549: PUSH
127550: LD_INT 0
127552: ST_TO_ADDR
// f_capture := false ;
127553: LD_ADDR_VAR 0 18
127557: PUSH
127558: LD_INT 0
127560: ST_TO_ADDR
// f_ignore_civ := false ;
127561: LD_ADDR_VAR 0 19
127565: PUSH
127566: LD_INT 0
127568: ST_TO_ADDR
// f_murder := false ;
127569: LD_ADDR_VAR 0 20
127573: PUSH
127574: LD_INT 0
127576: ST_TO_ADDR
// f_mines := false ;
127577: LD_ADDR_VAR 0 21
127581: PUSH
127582: LD_INT 0
127584: ST_TO_ADDR
// f_repair := false ;
127585: LD_ADDR_VAR 0 22
127589: PUSH
127590: LD_INT 0
127592: ST_TO_ADDR
// f_heal := false ;
127593: LD_ADDR_VAR 0 23
127597: PUSH
127598: LD_INT 0
127600: ST_TO_ADDR
// f_spacetime := false ;
127601: LD_ADDR_VAR 0 24
127605: PUSH
127606: LD_INT 0
127608: ST_TO_ADDR
// f_attack_depot := false ;
127609: LD_ADDR_VAR 0 25
127613: PUSH
127614: LD_INT 0
127616: ST_TO_ADDR
// f_crawl := false ;
127617: LD_ADDR_VAR 0 26
127621: PUSH
127622: LD_INT 0
127624: ST_TO_ADDR
// end ; if f_heal then
127625: LD_VAR 0 23
127629: IFFALSE 127656
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
127631: LD_ADDR_VAR 0 31
127635: PUSH
127636: LD_VAR 0 4
127640: PPUSH
127641: LD_INT 25
127643: PUSH
127644: LD_INT 4
127646: PUSH
127647: EMPTY
127648: LIST
127649: LIST
127650: PPUSH
127651: CALL_OW 72
127655: ST_TO_ADDR
// if f_repair then
127656: LD_VAR 0 22
127660: IFFALSE 127687
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
127662: LD_ADDR_VAR 0 33
127666: PUSH
127667: LD_VAR 0 4
127671: PPUSH
127672: LD_INT 25
127674: PUSH
127675: LD_INT 3
127677: PUSH
127678: EMPTY
127679: LIST
127680: LIST
127681: PPUSH
127682: CALL_OW 72
127686: ST_TO_ADDR
// units_path := [ ] ;
127687: LD_ADDR_VAR 0 16
127691: PUSH
127692: EMPTY
127693: ST_TO_ADDR
// for i = 1 to group do
127694: LD_ADDR_VAR 0 7
127698: PUSH
127699: DOUBLE
127700: LD_INT 1
127702: DEC
127703: ST_TO_ADDR
127704: LD_VAR 0 4
127708: PUSH
127709: FOR_TO
127710: IFFALSE 127739
// units_path := Replace ( units_path , i , path ) ;
127712: LD_ADDR_VAR 0 16
127716: PUSH
127717: LD_VAR 0 16
127721: PPUSH
127722: LD_VAR 0 7
127726: PPUSH
127727: LD_VAR 0 5
127731: PPUSH
127732: CALL_OW 1
127736: ST_TO_ADDR
127737: GO 127709
127739: POP
127740: POP
// repeat for i = group downto 1 do
127741: LD_ADDR_VAR 0 7
127745: PUSH
127746: DOUBLE
127747: LD_VAR 0 4
127751: INC
127752: ST_TO_ADDR
127753: LD_INT 1
127755: PUSH
127756: FOR_DOWNTO
127757: IFFALSE 131879
// begin wait ( 5 ) ;
127759: LD_INT 5
127761: PPUSH
127762: CALL_OW 67
// tmp := [ ] ;
127766: LD_ADDR_VAR 0 14
127770: PUSH
127771: EMPTY
127772: ST_TO_ADDR
// attacking := false ;
127773: LD_ADDR_VAR 0 29
127777: PUSH
127778: LD_INT 0
127780: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
127781: LD_VAR 0 4
127785: PUSH
127786: LD_VAR 0 7
127790: ARRAY
127791: PPUSH
127792: CALL_OW 301
127796: PUSH
127797: LD_VAR 0 4
127801: PUSH
127802: LD_VAR 0 7
127806: ARRAY
127807: NOT
127808: OR
127809: IFFALSE 127918
// begin if GetType ( group [ i ] ) = unit_human then
127811: LD_VAR 0 4
127815: PUSH
127816: LD_VAR 0 7
127820: ARRAY
127821: PPUSH
127822: CALL_OW 247
127826: PUSH
127827: LD_INT 1
127829: EQUAL
127830: IFFALSE 127876
// begin to_heal := to_heal diff group [ i ] ;
127832: LD_ADDR_VAR 0 30
127836: PUSH
127837: LD_VAR 0 30
127841: PUSH
127842: LD_VAR 0 4
127846: PUSH
127847: LD_VAR 0 7
127851: ARRAY
127852: DIFF
127853: ST_TO_ADDR
// healers := healers diff group [ i ] ;
127854: LD_ADDR_VAR 0 31
127858: PUSH
127859: LD_VAR 0 31
127863: PUSH
127864: LD_VAR 0 4
127868: PUSH
127869: LD_VAR 0 7
127873: ARRAY
127874: DIFF
127875: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
127876: LD_ADDR_VAR 0 4
127880: PUSH
127881: LD_VAR 0 4
127885: PPUSH
127886: LD_VAR 0 7
127890: PPUSH
127891: CALL_OW 3
127895: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
127896: LD_ADDR_VAR 0 16
127900: PUSH
127901: LD_VAR 0 16
127905: PPUSH
127906: LD_VAR 0 7
127910: PPUSH
127911: CALL_OW 3
127915: ST_TO_ADDR
// continue ;
127916: GO 127756
// end ; if f_repair then
127918: LD_VAR 0 22
127922: IFFALSE 128411
// begin if GetType ( group [ i ] ) = unit_vehicle then
127924: LD_VAR 0 4
127928: PUSH
127929: LD_VAR 0 7
127933: ARRAY
127934: PPUSH
127935: CALL_OW 247
127939: PUSH
127940: LD_INT 2
127942: EQUAL
127943: IFFALSE 128133
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
127945: LD_VAR 0 4
127949: PUSH
127950: LD_VAR 0 7
127954: ARRAY
127955: PPUSH
127956: CALL_OW 256
127960: PUSH
127961: LD_INT 700
127963: LESS
127964: PUSH
127965: LD_VAR 0 4
127969: PUSH
127970: LD_VAR 0 7
127974: ARRAY
127975: PUSH
127976: LD_VAR 0 32
127980: IN
127981: NOT
127982: AND
127983: IFFALSE 128007
// to_repair := to_repair union group [ i ] ;
127985: LD_ADDR_VAR 0 32
127989: PUSH
127990: LD_VAR 0 32
127994: PUSH
127995: LD_VAR 0 4
127999: PUSH
128000: LD_VAR 0 7
128004: ARRAY
128005: UNION
128006: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
128007: LD_VAR 0 4
128011: PUSH
128012: LD_VAR 0 7
128016: ARRAY
128017: PPUSH
128018: CALL_OW 256
128022: PUSH
128023: LD_INT 1000
128025: EQUAL
128026: PUSH
128027: LD_VAR 0 4
128031: PUSH
128032: LD_VAR 0 7
128036: ARRAY
128037: PUSH
128038: LD_VAR 0 32
128042: IN
128043: AND
128044: IFFALSE 128068
// to_repair := to_repair diff group [ i ] ;
128046: LD_ADDR_VAR 0 32
128050: PUSH
128051: LD_VAR 0 32
128055: PUSH
128056: LD_VAR 0 4
128060: PUSH
128061: LD_VAR 0 7
128065: ARRAY
128066: DIFF
128067: ST_TO_ADDR
// if group [ i ] in to_repair then
128068: LD_VAR 0 4
128072: PUSH
128073: LD_VAR 0 7
128077: ARRAY
128078: PUSH
128079: LD_VAR 0 32
128083: IN
128084: IFFALSE 128131
// begin if not IsInArea ( group [ i ] , f_repair ) then
128086: LD_VAR 0 4
128090: PUSH
128091: LD_VAR 0 7
128095: ARRAY
128096: PPUSH
128097: LD_VAR 0 22
128101: PPUSH
128102: CALL_OW 308
128106: NOT
128107: IFFALSE 128129
// ComMoveToArea ( group [ i ] , f_repair ) ;
128109: LD_VAR 0 4
128113: PUSH
128114: LD_VAR 0 7
128118: ARRAY
128119: PPUSH
128120: LD_VAR 0 22
128124: PPUSH
128125: CALL_OW 113
// continue ;
128129: GO 127756
// end ; end else
128131: GO 128411
// if group [ i ] in repairs then
128133: LD_VAR 0 4
128137: PUSH
128138: LD_VAR 0 7
128142: ARRAY
128143: PUSH
128144: LD_VAR 0 33
128148: IN
128149: IFFALSE 128411
// begin if IsInUnit ( group [ i ] ) then
128151: LD_VAR 0 4
128155: PUSH
128156: LD_VAR 0 7
128160: ARRAY
128161: PPUSH
128162: CALL_OW 310
128166: IFFALSE 128234
// begin z := IsInUnit ( group [ i ] ) ;
128168: LD_ADDR_VAR 0 13
128172: PUSH
128173: LD_VAR 0 4
128177: PUSH
128178: LD_VAR 0 7
128182: ARRAY
128183: PPUSH
128184: CALL_OW 310
128188: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
128189: LD_VAR 0 13
128193: PUSH
128194: LD_VAR 0 32
128198: IN
128199: PUSH
128200: LD_VAR 0 13
128204: PPUSH
128205: LD_VAR 0 22
128209: PPUSH
128210: CALL_OW 308
128214: AND
128215: IFFALSE 128232
// ComExitVehicle ( group [ i ] ) ;
128217: LD_VAR 0 4
128221: PUSH
128222: LD_VAR 0 7
128226: ARRAY
128227: PPUSH
128228: CALL_OW 121
// end else
128232: GO 128411
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
128234: LD_ADDR_VAR 0 13
128238: PUSH
128239: LD_VAR 0 4
128243: PPUSH
128244: LD_INT 95
128246: PUSH
128247: LD_VAR 0 22
128251: PUSH
128252: EMPTY
128253: LIST
128254: LIST
128255: PUSH
128256: LD_INT 58
128258: PUSH
128259: EMPTY
128260: LIST
128261: PUSH
128262: EMPTY
128263: LIST
128264: LIST
128265: PPUSH
128266: CALL_OW 72
128270: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
128271: LD_VAR 0 4
128275: PUSH
128276: LD_VAR 0 7
128280: ARRAY
128281: PPUSH
128282: CALL_OW 314
128286: NOT
128287: IFFALSE 128409
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
128289: LD_ADDR_VAR 0 10
128293: PUSH
128294: LD_VAR 0 13
128298: PPUSH
128299: LD_VAR 0 4
128303: PUSH
128304: LD_VAR 0 7
128308: ARRAY
128309: PPUSH
128310: CALL_OW 74
128314: ST_TO_ADDR
// if not x then
128315: LD_VAR 0 10
128319: NOT
128320: IFFALSE 128324
// continue ;
128322: GO 127756
// if GetLives ( x ) < 1000 then
128324: LD_VAR 0 10
128328: PPUSH
128329: CALL_OW 256
128333: PUSH
128334: LD_INT 1000
128336: LESS
128337: IFFALSE 128361
// ComRepairVehicle ( group [ i ] , x ) else
128339: LD_VAR 0 4
128343: PUSH
128344: LD_VAR 0 7
128348: ARRAY
128349: PPUSH
128350: LD_VAR 0 10
128354: PPUSH
128355: CALL_OW 129
128359: GO 128409
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
128361: LD_VAR 0 23
128365: PUSH
128366: LD_VAR 0 4
128370: PUSH
128371: LD_VAR 0 7
128375: ARRAY
128376: PPUSH
128377: CALL_OW 256
128381: PUSH
128382: LD_INT 1000
128384: LESS
128385: AND
128386: NOT
128387: IFFALSE 128409
// ComEnterUnit ( group [ i ] , x ) ;
128389: LD_VAR 0 4
128393: PUSH
128394: LD_VAR 0 7
128398: ARRAY
128399: PPUSH
128400: LD_VAR 0 10
128404: PPUSH
128405: CALL_OW 120
// end ; continue ;
128409: GO 127756
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
128411: LD_VAR 0 23
128415: PUSH
128416: LD_VAR 0 4
128420: PUSH
128421: LD_VAR 0 7
128425: ARRAY
128426: PPUSH
128427: CALL_OW 247
128431: PUSH
128432: LD_INT 1
128434: EQUAL
128435: AND
128436: IFFALSE 128914
// begin if group [ i ] in healers then
128438: LD_VAR 0 4
128442: PUSH
128443: LD_VAR 0 7
128447: ARRAY
128448: PUSH
128449: LD_VAR 0 31
128453: IN
128454: IFFALSE 128727
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
128456: LD_VAR 0 4
128460: PUSH
128461: LD_VAR 0 7
128465: ARRAY
128466: PPUSH
128467: LD_VAR 0 23
128471: PPUSH
128472: CALL_OW 308
128476: NOT
128477: PUSH
128478: LD_VAR 0 4
128482: PUSH
128483: LD_VAR 0 7
128487: ARRAY
128488: PPUSH
128489: CALL_OW 314
128493: NOT
128494: AND
128495: IFFALSE 128519
// ComMoveToArea ( group [ i ] , f_heal ) else
128497: LD_VAR 0 4
128501: PUSH
128502: LD_VAR 0 7
128506: ARRAY
128507: PPUSH
128508: LD_VAR 0 23
128512: PPUSH
128513: CALL_OW 113
128517: GO 128725
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
128519: LD_VAR 0 4
128523: PUSH
128524: LD_VAR 0 7
128528: ARRAY
128529: PPUSH
128530: CALL 100857 0 1
128534: PPUSH
128535: CALL_OW 256
128539: PUSH
128540: LD_INT 1000
128542: EQUAL
128543: IFFALSE 128562
// ComStop ( group [ i ] ) else
128545: LD_VAR 0 4
128549: PUSH
128550: LD_VAR 0 7
128554: ARRAY
128555: PPUSH
128556: CALL_OW 141
128560: GO 128725
// if not HasTask ( group [ i ] ) and to_heal then
128562: LD_VAR 0 4
128566: PUSH
128567: LD_VAR 0 7
128571: ARRAY
128572: PPUSH
128573: CALL_OW 314
128577: NOT
128578: PUSH
128579: LD_VAR 0 30
128583: AND
128584: IFFALSE 128725
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
128586: LD_ADDR_VAR 0 13
128590: PUSH
128591: LD_VAR 0 30
128595: PPUSH
128596: LD_INT 3
128598: PUSH
128599: LD_INT 54
128601: PUSH
128602: EMPTY
128603: LIST
128604: PUSH
128605: EMPTY
128606: LIST
128607: LIST
128608: PPUSH
128609: CALL_OW 72
128613: PPUSH
128614: LD_VAR 0 4
128618: PUSH
128619: LD_VAR 0 7
128623: ARRAY
128624: PPUSH
128625: CALL_OW 74
128629: ST_TO_ADDR
// if z then
128630: LD_VAR 0 13
128634: IFFALSE 128725
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
128636: LD_INT 91
128638: PUSH
128639: LD_VAR 0 13
128643: PUSH
128644: LD_INT 10
128646: PUSH
128647: EMPTY
128648: LIST
128649: LIST
128650: LIST
128651: PUSH
128652: LD_INT 81
128654: PUSH
128655: LD_VAR 0 13
128659: PPUSH
128660: CALL_OW 255
128664: PUSH
128665: EMPTY
128666: LIST
128667: LIST
128668: PUSH
128669: EMPTY
128670: LIST
128671: LIST
128672: PPUSH
128673: CALL_OW 69
128677: PUSH
128678: LD_INT 0
128680: EQUAL
128681: IFFALSE 128705
// ComHeal ( group [ i ] , z ) else
128683: LD_VAR 0 4
128687: PUSH
128688: LD_VAR 0 7
128692: ARRAY
128693: PPUSH
128694: LD_VAR 0 13
128698: PPUSH
128699: CALL_OW 128
128703: GO 128725
// ComMoveToArea ( group [ i ] , f_heal ) ;
128705: LD_VAR 0 4
128709: PUSH
128710: LD_VAR 0 7
128714: ARRAY
128715: PPUSH
128716: LD_VAR 0 23
128720: PPUSH
128721: CALL_OW 113
// end ; continue ;
128725: GO 127756
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
128727: LD_VAR 0 4
128731: PUSH
128732: LD_VAR 0 7
128736: ARRAY
128737: PPUSH
128738: CALL_OW 256
128742: PUSH
128743: LD_INT 700
128745: LESS
128746: PUSH
128747: LD_VAR 0 4
128751: PUSH
128752: LD_VAR 0 7
128756: ARRAY
128757: PUSH
128758: LD_VAR 0 30
128762: IN
128763: NOT
128764: AND
128765: IFFALSE 128789
// to_heal := to_heal union group [ i ] ;
128767: LD_ADDR_VAR 0 30
128771: PUSH
128772: LD_VAR 0 30
128776: PUSH
128777: LD_VAR 0 4
128781: PUSH
128782: LD_VAR 0 7
128786: ARRAY
128787: UNION
128788: ST_TO_ADDR
// if group [ i ] in to_heal then
128789: LD_VAR 0 4
128793: PUSH
128794: LD_VAR 0 7
128798: ARRAY
128799: PUSH
128800: LD_VAR 0 30
128804: IN
128805: IFFALSE 128914
// begin if GetLives ( group [ i ] ) = 1000 then
128807: LD_VAR 0 4
128811: PUSH
128812: LD_VAR 0 7
128816: ARRAY
128817: PPUSH
128818: CALL_OW 256
128822: PUSH
128823: LD_INT 1000
128825: EQUAL
128826: IFFALSE 128852
// to_heal := to_heal diff group [ i ] else
128828: LD_ADDR_VAR 0 30
128832: PUSH
128833: LD_VAR 0 30
128837: PUSH
128838: LD_VAR 0 4
128842: PUSH
128843: LD_VAR 0 7
128847: ARRAY
128848: DIFF
128849: ST_TO_ADDR
128850: GO 128914
// begin if not IsInArea ( group [ i ] , to_heal ) then
128852: LD_VAR 0 4
128856: PUSH
128857: LD_VAR 0 7
128861: ARRAY
128862: PPUSH
128863: LD_VAR 0 30
128867: PPUSH
128868: CALL_OW 308
128872: NOT
128873: IFFALSE 128897
// ComMoveToArea ( group [ i ] , f_heal ) else
128875: LD_VAR 0 4
128879: PUSH
128880: LD_VAR 0 7
128884: ARRAY
128885: PPUSH
128886: LD_VAR 0 23
128890: PPUSH
128891: CALL_OW 113
128895: GO 128912
// ComHold ( group [ i ] ) ;
128897: LD_VAR 0 4
128901: PUSH
128902: LD_VAR 0 7
128906: ARRAY
128907: PPUSH
128908: CALL_OW 140
// continue ;
128912: GO 127756
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
128914: LD_VAR 0 4
128918: PUSH
128919: LD_VAR 0 7
128923: ARRAY
128924: PPUSH
128925: LD_INT 10
128927: PPUSH
128928: CALL 98654 0 2
128932: NOT
128933: PUSH
128934: LD_VAR 0 16
128938: PUSH
128939: LD_VAR 0 7
128943: ARRAY
128944: PUSH
128945: EMPTY
128946: EQUAL
128947: NOT
128948: AND
128949: IFFALSE 129215
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
128951: LD_VAR 0 4
128955: PUSH
128956: LD_VAR 0 7
128960: ARRAY
128961: PPUSH
128962: CALL_OW 262
128966: PUSH
128967: LD_INT 1
128969: PUSH
128970: LD_INT 2
128972: PUSH
128973: EMPTY
128974: LIST
128975: LIST
128976: IN
128977: IFFALSE 129018
// if GetFuel ( group [ i ] ) < 10 then
128979: LD_VAR 0 4
128983: PUSH
128984: LD_VAR 0 7
128988: ARRAY
128989: PPUSH
128990: CALL_OW 261
128994: PUSH
128995: LD_INT 10
128997: LESS
128998: IFFALSE 129018
// SetFuel ( group [ i ] , 12 ) ;
129000: LD_VAR 0 4
129004: PUSH
129005: LD_VAR 0 7
129009: ARRAY
129010: PPUSH
129011: LD_INT 12
129013: PPUSH
129014: CALL_OW 240
// if units_path [ i ] then
129018: LD_VAR 0 16
129022: PUSH
129023: LD_VAR 0 7
129027: ARRAY
129028: IFFALSE 129213
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
129030: LD_VAR 0 4
129034: PUSH
129035: LD_VAR 0 7
129039: ARRAY
129040: PPUSH
129041: LD_VAR 0 16
129045: PUSH
129046: LD_VAR 0 7
129050: ARRAY
129051: PUSH
129052: LD_INT 1
129054: ARRAY
129055: PUSH
129056: LD_INT 1
129058: ARRAY
129059: PPUSH
129060: LD_VAR 0 16
129064: PUSH
129065: LD_VAR 0 7
129069: ARRAY
129070: PUSH
129071: LD_INT 1
129073: ARRAY
129074: PUSH
129075: LD_INT 2
129077: ARRAY
129078: PPUSH
129079: CALL_OW 297
129083: PUSH
129084: LD_INT 6
129086: GREATER
129087: IFFALSE 129162
// begin if not HasTask ( group [ i ] ) then
129089: LD_VAR 0 4
129093: PUSH
129094: LD_VAR 0 7
129098: ARRAY
129099: PPUSH
129100: CALL_OW 314
129104: NOT
129105: IFFALSE 129160
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
129107: LD_VAR 0 4
129111: PUSH
129112: LD_VAR 0 7
129116: ARRAY
129117: PPUSH
129118: LD_VAR 0 16
129122: PUSH
129123: LD_VAR 0 7
129127: ARRAY
129128: PUSH
129129: LD_INT 1
129131: ARRAY
129132: PUSH
129133: LD_INT 1
129135: ARRAY
129136: PPUSH
129137: LD_VAR 0 16
129141: PUSH
129142: LD_VAR 0 7
129146: ARRAY
129147: PUSH
129148: LD_INT 1
129150: ARRAY
129151: PUSH
129152: LD_INT 2
129154: ARRAY
129155: PPUSH
129156: CALL_OW 114
// end else
129160: GO 129213
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
129162: LD_ADDR_VAR 0 15
129166: PUSH
129167: LD_VAR 0 16
129171: PUSH
129172: LD_VAR 0 7
129176: ARRAY
129177: PPUSH
129178: LD_INT 1
129180: PPUSH
129181: CALL_OW 3
129185: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
129186: LD_ADDR_VAR 0 16
129190: PUSH
129191: LD_VAR 0 16
129195: PPUSH
129196: LD_VAR 0 7
129200: PPUSH
129201: LD_VAR 0 15
129205: PPUSH
129206: CALL_OW 1
129210: ST_TO_ADDR
// continue ;
129211: GO 127756
// end ; end ; end else
129213: GO 131877
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
129215: LD_ADDR_VAR 0 14
129219: PUSH
129220: LD_INT 81
129222: PUSH
129223: LD_VAR 0 4
129227: PUSH
129228: LD_VAR 0 7
129232: ARRAY
129233: PPUSH
129234: CALL_OW 255
129238: PUSH
129239: EMPTY
129240: LIST
129241: LIST
129242: PPUSH
129243: CALL_OW 69
129247: ST_TO_ADDR
// if not tmp then
129248: LD_VAR 0 14
129252: NOT
129253: IFFALSE 129257
// continue ;
129255: GO 127756
// if f_ignore_area then
129257: LD_VAR 0 17
129261: IFFALSE 129349
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
129263: LD_ADDR_VAR 0 15
129267: PUSH
129268: LD_VAR 0 14
129272: PPUSH
129273: LD_INT 3
129275: PUSH
129276: LD_INT 92
129278: PUSH
129279: LD_VAR 0 17
129283: PUSH
129284: LD_INT 1
129286: ARRAY
129287: PUSH
129288: LD_VAR 0 17
129292: PUSH
129293: LD_INT 2
129295: ARRAY
129296: PUSH
129297: LD_VAR 0 17
129301: PUSH
129302: LD_INT 3
129304: ARRAY
129305: PUSH
129306: EMPTY
129307: LIST
129308: LIST
129309: LIST
129310: LIST
129311: PUSH
129312: EMPTY
129313: LIST
129314: LIST
129315: PPUSH
129316: CALL_OW 72
129320: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
129321: LD_VAR 0 14
129325: PUSH
129326: LD_VAR 0 15
129330: DIFF
129331: IFFALSE 129349
// tmp := tmp diff tmp2 ;
129333: LD_ADDR_VAR 0 14
129337: PUSH
129338: LD_VAR 0 14
129342: PUSH
129343: LD_VAR 0 15
129347: DIFF
129348: ST_TO_ADDR
// end ; if not f_murder then
129349: LD_VAR 0 20
129353: NOT
129354: IFFALSE 129412
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
129356: LD_ADDR_VAR 0 15
129360: PUSH
129361: LD_VAR 0 14
129365: PPUSH
129366: LD_INT 3
129368: PUSH
129369: LD_INT 50
129371: PUSH
129372: EMPTY
129373: LIST
129374: PUSH
129375: EMPTY
129376: LIST
129377: LIST
129378: PPUSH
129379: CALL_OW 72
129383: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
129384: LD_VAR 0 14
129388: PUSH
129389: LD_VAR 0 15
129393: DIFF
129394: IFFALSE 129412
// tmp := tmp diff tmp2 ;
129396: LD_ADDR_VAR 0 14
129400: PUSH
129401: LD_VAR 0 14
129405: PUSH
129406: LD_VAR 0 15
129410: DIFF
129411: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
129412: LD_ADDR_VAR 0 14
129416: PUSH
129417: LD_VAR 0 4
129421: PUSH
129422: LD_VAR 0 7
129426: ARRAY
129427: PPUSH
129428: LD_VAR 0 14
129432: PPUSH
129433: LD_INT 1
129435: PPUSH
129436: LD_INT 1
129438: PPUSH
129439: CALL 71595 0 4
129443: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
129444: LD_VAR 0 4
129448: PUSH
129449: LD_VAR 0 7
129453: ARRAY
129454: PPUSH
129455: CALL_OW 257
129459: PUSH
129460: LD_INT 1
129462: EQUAL
129463: IFFALSE 129911
// begin if WantPlant ( group [ i ] ) then
129465: LD_VAR 0 4
129469: PUSH
129470: LD_VAR 0 7
129474: ARRAY
129475: PPUSH
129476: CALL 71096 0 1
129480: IFFALSE 129484
// continue ;
129482: GO 127756
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
129484: LD_VAR 0 18
129488: PUSH
129489: LD_VAR 0 4
129493: PUSH
129494: LD_VAR 0 7
129498: ARRAY
129499: PPUSH
129500: CALL_OW 310
129504: NOT
129505: AND
129506: PUSH
129507: LD_VAR 0 14
129511: PUSH
129512: LD_INT 1
129514: ARRAY
129515: PUSH
129516: LD_VAR 0 14
129520: PPUSH
129521: LD_INT 21
129523: PUSH
129524: LD_INT 2
129526: PUSH
129527: EMPTY
129528: LIST
129529: LIST
129530: PUSH
129531: LD_INT 58
129533: PUSH
129534: EMPTY
129535: LIST
129536: PUSH
129537: EMPTY
129538: LIST
129539: LIST
129540: PPUSH
129541: CALL_OW 72
129545: IN
129546: AND
129547: IFFALSE 129583
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
129549: LD_VAR 0 4
129553: PUSH
129554: LD_VAR 0 7
129558: ARRAY
129559: PPUSH
129560: LD_VAR 0 14
129564: PUSH
129565: LD_INT 1
129567: ARRAY
129568: PPUSH
129569: CALL_OW 120
// attacking := true ;
129573: LD_ADDR_VAR 0 29
129577: PUSH
129578: LD_INT 1
129580: ST_TO_ADDR
// continue ;
129581: GO 127756
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
129583: LD_VAR 0 26
129587: PUSH
129588: LD_VAR 0 4
129592: PUSH
129593: LD_VAR 0 7
129597: ARRAY
129598: PPUSH
129599: CALL_OW 257
129603: PUSH
129604: LD_INT 1
129606: EQUAL
129607: AND
129608: PUSH
129609: LD_VAR 0 4
129613: PUSH
129614: LD_VAR 0 7
129618: ARRAY
129619: PPUSH
129620: CALL_OW 256
129624: PUSH
129625: LD_INT 800
129627: LESS
129628: AND
129629: PUSH
129630: LD_VAR 0 4
129634: PUSH
129635: LD_VAR 0 7
129639: ARRAY
129640: PPUSH
129641: CALL_OW 318
129645: NOT
129646: AND
129647: IFFALSE 129664
// ComCrawl ( group [ i ] ) ;
129649: LD_VAR 0 4
129653: PUSH
129654: LD_VAR 0 7
129658: ARRAY
129659: PPUSH
129660: CALL_OW 137
// if f_mines then
129664: LD_VAR 0 21
129668: IFFALSE 129911
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
129670: LD_VAR 0 14
129674: PUSH
129675: LD_INT 1
129677: ARRAY
129678: PPUSH
129679: CALL_OW 247
129683: PUSH
129684: LD_INT 3
129686: EQUAL
129687: PUSH
129688: LD_VAR 0 14
129692: PUSH
129693: LD_INT 1
129695: ARRAY
129696: PUSH
129697: LD_VAR 0 27
129701: IN
129702: NOT
129703: AND
129704: IFFALSE 129911
// begin x := GetX ( tmp [ 1 ] ) ;
129706: LD_ADDR_VAR 0 10
129710: PUSH
129711: LD_VAR 0 14
129715: PUSH
129716: LD_INT 1
129718: ARRAY
129719: PPUSH
129720: CALL_OW 250
129724: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
129725: LD_ADDR_VAR 0 11
129729: PUSH
129730: LD_VAR 0 14
129734: PUSH
129735: LD_INT 1
129737: ARRAY
129738: PPUSH
129739: CALL_OW 251
129743: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
129744: LD_ADDR_VAR 0 12
129748: PUSH
129749: LD_VAR 0 4
129753: PUSH
129754: LD_VAR 0 7
129758: ARRAY
129759: PPUSH
129760: CALL 98739 0 1
129764: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
129765: LD_VAR 0 4
129769: PUSH
129770: LD_VAR 0 7
129774: ARRAY
129775: PPUSH
129776: LD_VAR 0 10
129780: PPUSH
129781: LD_VAR 0 11
129785: PPUSH
129786: LD_VAR 0 14
129790: PUSH
129791: LD_INT 1
129793: ARRAY
129794: PPUSH
129795: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
129799: LD_VAR 0 4
129803: PUSH
129804: LD_VAR 0 7
129808: ARRAY
129809: PPUSH
129810: LD_VAR 0 10
129814: PPUSH
129815: LD_VAR 0 12
129819: PPUSH
129820: LD_INT 7
129822: PPUSH
129823: CALL_OW 272
129827: PPUSH
129828: LD_VAR 0 11
129832: PPUSH
129833: LD_VAR 0 12
129837: PPUSH
129838: LD_INT 7
129840: PPUSH
129841: CALL_OW 273
129845: PPUSH
129846: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
129850: LD_VAR 0 4
129854: PUSH
129855: LD_VAR 0 7
129859: ARRAY
129860: PPUSH
129861: LD_INT 71
129863: PPUSH
129864: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
129868: LD_ADDR_VAR 0 27
129872: PUSH
129873: LD_VAR 0 27
129877: PPUSH
129878: LD_VAR 0 27
129882: PUSH
129883: LD_INT 1
129885: PLUS
129886: PPUSH
129887: LD_VAR 0 14
129891: PUSH
129892: LD_INT 1
129894: ARRAY
129895: PPUSH
129896: CALL_OW 1
129900: ST_TO_ADDR
// attacking := true ;
129901: LD_ADDR_VAR 0 29
129905: PUSH
129906: LD_INT 1
129908: ST_TO_ADDR
// continue ;
129909: GO 127756
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
129911: LD_VAR 0 4
129915: PUSH
129916: LD_VAR 0 7
129920: ARRAY
129921: PPUSH
129922: CALL_OW 257
129926: PUSH
129927: LD_INT 17
129929: EQUAL
129930: PUSH
129931: LD_VAR 0 4
129935: PUSH
129936: LD_VAR 0 7
129940: ARRAY
129941: PPUSH
129942: CALL_OW 110
129946: PUSH
129947: LD_INT 71
129949: EQUAL
129950: NOT
129951: AND
129952: IFFALSE 130098
// begin attacking := false ;
129954: LD_ADDR_VAR 0 29
129958: PUSH
129959: LD_INT 0
129961: ST_TO_ADDR
// k := 5 ;
129962: LD_ADDR_VAR 0 9
129966: PUSH
129967: LD_INT 5
129969: ST_TO_ADDR
// if tmp < k then
129970: LD_VAR 0 14
129974: PUSH
129975: LD_VAR 0 9
129979: LESS
129980: IFFALSE 129992
// k := tmp ;
129982: LD_ADDR_VAR 0 9
129986: PUSH
129987: LD_VAR 0 14
129991: ST_TO_ADDR
// for j = 1 to k do
129992: LD_ADDR_VAR 0 8
129996: PUSH
129997: DOUBLE
129998: LD_INT 1
130000: DEC
130001: ST_TO_ADDR
130002: LD_VAR 0 9
130006: PUSH
130007: FOR_TO
130008: IFFALSE 130096
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
130010: LD_VAR 0 14
130014: PUSH
130015: LD_VAR 0 8
130019: ARRAY
130020: PUSH
130021: LD_VAR 0 14
130025: PPUSH
130026: LD_INT 58
130028: PUSH
130029: EMPTY
130030: LIST
130031: PPUSH
130032: CALL_OW 72
130036: IN
130037: NOT
130038: IFFALSE 130094
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
130040: LD_VAR 0 4
130044: PUSH
130045: LD_VAR 0 7
130049: ARRAY
130050: PPUSH
130051: LD_VAR 0 14
130055: PUSH
130056: LD_VAR 0 8
130060: ARRAY
130061: PPUSH
130062: CALL_OW 115
// attacking := true ;
130066: LD_ADDR_VAR 0 29
130070: PUSH
130071: LD_INT 1
130073: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
130074: LD_VAR 0 4
130078: PUSH
130079: LD_VAR 0 7
130083: ARRAY
130084: PPUSH
130085: LD_INT 71
130087: PPUSH
130088: CALL_OW 109
// continue ;
130092: GO 130007
// end ; end ;
130094: GO 130007
130096: POP
130097: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
130098: LD_VAR 0 4
130102: PUSH
130103: LD_VAR 0 7
130107: ARRAY
130108: PPUSH
130109: CALL_OW 257
130113: PUSH
130114: LD_INT 8
130116: EQUAL
130117: PUSH
130118: LD_VAR 0 4
130122: PUSH
130123: LD_VAR 0 7
130127: ARRAY
130128: PPUSH
130129: CALL_OW 264
130133: PUSH
130134: LD_INT 28
130136: PUSH
130137: LD_INT 45
130139: PUSH
130140: LD_INT 7
130142: PUSH
130143: LD_INT 47
130145: PUSH
130146: EMPTY
130147: LIST
130148: LIST
130149: LIST
130150: LIST
130151: IN
130152: OR
130153: IFFALSE 130409
// begin attacking := false ;
130155: LD_ADDR_VAR 0 29
130159: PUSH
130160: LD_INT 0
130162: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
130163: LD_VAR 0 14
130167: PUSH
130168: LD_INT 1
130170: ARRAY
130171: PPUSH
130172: CALL_OW 266
130176: PUSH
130177: LD_INT 32
130179: PUSH
130180: LD_INT 31
130182: PUSH
130183: LD_INT 33
130185: PUSH
130186: LD_INT 4
130188: PUSH
130189: LD_INT 5
130191: PUSH
130192: EMPTY
130193: LIST
130194: LIST
130195: LIST
130196: LIST
130197: LIST
130198: IN
130199: IFFALSE 130385
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
130201: LD_ADDR_VAR 0 9
130205: PUSH
130206: LD_VAR 0 14
130210: PUSH
130211: LD_INT 1
130213: ARRAY
130214: PPUSH
130215: CALL_OW 266
130219: PPUSH
130220: LD_VAR 0 14
130224: PUSH
130225: LD_INT 1
130227: ARRAY
130228: PPUSH
130229: CALL_OW 250
130233: PPUSH
130234: LD_VAR 0 14
130238: PUSH
130239: LD_INT 1
130241: ARRAY
130242: PPUSH
130243: CALL_OW 251
130247: PPUSH
130248: LD_VAR 0 14
130252: PUSH
130253: LD_INT 1
130255: ARRAY
130256: PPUSH
130257: CALL_OW 254
130261: PPUSH
130262: LD_VAR 0 14
130266: PUSH
130267: LD_INT 1
130269: ARRAY
130270: PPUSH
130271: CALL_OW 248
130275: PPUSH
130276: LD_INT 0
130278: PPUSH
130279: CALL 80109 0 6
130283: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
130284: LD_ADDR_VAR 0 8
130288: PUSH
130289: LD_VAR 0 4
130293: PUSH
130294: LD_VAR 0 7
130298: ARRAY
130299: PPUSH
130300: LD_VAR 0 9
130304: PPUSH
130305: CALL 98852 0 2
130309: ST_TO_ADDR
// if j then
130310: LD_VAR 0 8
130314: IFFALSE 130383
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
130316: LD_VAR 0 8
130320: PUSH
130321: LD_INT 1
130323: ARRAY
130324: PPUSH
130325: LD_VAR 0 8
130329: PUSH
130330: LD_INT 2
130332: ARRAY
130333: PPUSH
130334: CALL_OW 488
130338: IFFALSE 130383
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
130340: LD_VAR 0 4
130344: PUSH
130345: LD_VAR 0 7
130349: ARRAY
130350: PPUSH
130351: LD_VAR 0 8
130355: PUSH
130356: LD_INT 1
130358: ARRAY
130359: PPUSH
130360: LD_VAR 0 8
130364: PUSH
130365: LD_INT 2
130367: ARRAY
130368: PPUSH
130369: CALL_OW 116
// attacking := true ;
130373: LD_ADDR_VAR 0 29
130377: PUSH
130378: LD_INT 1
130380: ST_TO_ADDR
// continue ;
130381: GO 127756
// end ; end else
130383: GO 130409
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130385: LD_VAR 0 4
130389: PUSH
130390: LD_VAR 0 7
130394: ARRAY
130395: PPUSH
130396: LD_VAR 0 14
130400: PUSH
130401: LD_INT 1
130403: ARRAY
130404: PPUSH
130405: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
130409: LD_VAR 0 4
130413: PUSH
130414: LD_VAR 0 7
130418: ARRAY
130419: PPUSH
130420: CALL_OW 265
130424: PUSH
130425: LD_INT 11
130427: EQUAL
130428: IFFALSE 130706
// begin k := 10 ;
130430: LD_ADDR_VAR 0 9
130434: PUSH
130435: LD_INT 10
130437: ST_TO_ADDR
// x := 0 ;
130438: LD_ADDR_VAR 0 10
130442: PUSH
130443: LD_INT 0
130445: ST_TO_ADDR
// if tmp < k then
130446: LD_VAR 0 14
130450: PUSH
130451: LD_VAR 0 9
130455: LESS
130456: IFFALSE 130468
// k := tmp ;
130458: LD_ADDR_VAR 0 9
130462: PUSH
130463: LD_VAR 0 14
130467: ST_TO_ADDR
// for j = k downto 1 do
130468: LD_ADDR_VAR 0 8
130472: PUSH
130473: DOUBLE
130474: LD_VAR 0 9
130478: INC
130479: ST_TO_ADDR
130480: LD_INT 1
130482: PUSH
130483: FOR_DOWNTO
130484: IFFALSE 130559
// begin if GetType ( tmp [ j ] ) = unit_human then
130486: LD_VAR 0 14
130490: PUSH
130491: LD_VAR 0 8
130495: ARRAY
130496: PPUSH
130497: CALL_OW 247
130501: PUSH
130502: LD_INT 1
130504: EQUAL
130505: IFFALSE 130557
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
130507: LD_VAR 0 4
130511: PUSH
130512: LD_VAR 0 7
130516: ARRAY
130517: PPUSH
130518: LD_VAR 0 14
130522: PUSH
130523: LD_VAR 0 8
130527: ARRAY
130528: PPUSH
130529: CALL 99106 0 2
// x := tmp [ j ] ;
130533: LD_ADDR_VAR 0 10
130537: PUSH
130538: LD_VAR 0 14
130542: PUSH
130543: LD_VAR 0 8
130547: ARRAY
130548: ST_TO_ADDR
// attacking := true ;
130549: LD_ADDR_VAR 0 29
130553: PUSH
130554: LD_INT 1
130556: ST_TO_ADDR
// end ; end ;
130557: GO 130483
130559: POP
130560: POP
// if not x then
130561: LD_VAR 0 10
130565: NOT
130566: IFFALSE 130706
// begin attacking := true ;
130568: LD_ADDR_VAR 0 29
130572: PUSH
130573: LD_INT 1
130575: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
130576: LD_VAR 0 4
130580: PUSH
130581: LD_VAR 0 7
130585: ARRAY
130586: PPUSH
130587: CALL_OW 250
130591: PPUSH
130592: LD_VAR 0 4
130596: PUSH
130597: LD_VAR 0 7
130601: ARRAY
130602: PPUSH
130603: CALL_OW 251
130607: PPUSH
130608: CALL_OW 546
130612: PUSH
130613: LD_INT 2
130615: ARRAY
130616: PUSH
130617: LD_VAR 0 14
130621: PUSH
130622: LD_INT 1
130624: ARRAY
130625: PPUSH
130626: CALL_OW 250
130630: PPUSH
130631: LD_VAR 0 14
130635: PUSH
130636: LD_INT 1
130638: ARRAY
130639: PPUSH
130640: CALL_OW 251
130644: PPUSH
130645: CALL_OW 546
130649: PUSH
130650: LD_INT 2
130652: ARRAY
130653: EQUAL
130654: IFFALSE 130682
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
130656: LD_VAR 0 4
130660: PUSH
130661: LD_VAR 0 7
130665: ARRAY
130666: PPUSH
130667: LD_VAR 0 14
130671: PUSH
130672: LD_INT 1
130674: ARRAY
130675: PPUSH
130676: CALL 99106 0 2
130680: GO 130706
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130682: LD_VAR 0 4
130686: PUSH
130687: LD_VAR 0 7
130691: ARRAY
130692: PPUSH
130693: LD_VAR 0 14
130697: PUSH
130698: LD_INT 1
130700: ARRAY
130701: PPUSH
130702: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
130706: LD_VAR 0 4
130710: PUSH
130711: LD_VAR 0 7
130715: ARRAY
130716: PPUSH
130717: CALL_OW 264
130721: PUSH
130722: LD_INT 29
130724: EQUAL
130725: IFFALSE 131091
// begin if WantsToAttack ( group [ i ] ) in bombed then
130727: LD_VAR 0 4
130731: PUSH
130732: LD_VAR 0 7
130736: ARRAY
130737: PPUSH
130738: CALL_OW 319
130742: PUSH
130743: LD_VAR 0 28
130747: IN
130748: IFFALSE 130752
// continue ;
130750: GO 127756
// k := 8 ;
130752: LD_ADDR_VAR 0 9
130756: PUSH
130757: LD_INT 8
130759: ST_TO_ADDR
// x := 0 ;
130760: LD_ADDR_VAR 0 10
130764: PUSH
130765: LD_INT 0
130767: ST_TO_ADDR
// if tmp < k then
130768: LD_VAR 0 14
130772: PUSH
130773: LD_VAR 0 9
130777: LESS
130778: IFFALSE 130790
// k := tmp ;
130780: LD_ADDR_VAR 0 9
130784: PUSH
130785: LD_VAR 0 14
130789: ST_TO_ADDR
// for j = 1 to k do
130790: LD_ADDR_VAR 0 8
130794: PUSH
130795: DOUBLE
130796: LD_INT 1
130798: DEC
130799: ST_TO_ADDR
130800: LD_VAR 0 9
130804: PUSH
130805: FOR_TO
130806: IFFALSE 130938
// begin if GetType ( tmp [ j ] ) = unit_building then
130808: LD_VAR 0 14
130812: PUSH
130813: LD_VAR 0 8
130817: ARRAY
130818: PPUSH
130819: CALL_OW 247
130823: PUSH
130824: LD_INT 3
130826: EQUAL
130827: IFFALSE 130936
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
130829: LD_VAR 0 14
130833: PUSH
130834: LD_VAR 0 8
130838: ARRAY
130839: PUSH
130840: LD_VAR 0 28
130844: IN
130845: NOT
130846: PUSH
130847: LD_VAR 0 14
130851: PUSH
130852: LD_VAR 0 8
130856: ARRAY
130857: PPUSH
130858: CALL_OW 313
130862: AND
130863: IFFALSE 130936
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
130865: LD_VAR 0 4
130869: PUSH
130870: LD_VAR 0 7
130874: ARRAY
130875: PPUSH
130876: LD_VAR 0 14
130880: PUSH
130881: LD_VAR 0 8
130885: ARRAY
130886: PPUSH
130887: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
130891: LD_ADDR_VAR 0 28
130895: PUSH
130896: LD_VAR 0 28
130900: PPUSH
130901: LD_VAR 0 28
130905: PUSH
130906: LD_INT 1
130908: PLUS
130909: PPUSH
130910: LD_VAR 0 14
130914: PUSH
130915: LD_VAR 0 8
130919: ARRAY
130920: PPUSH
130921: CALL_OW 1
130925: ST_TO_ADDR
// attacking := true ;
130926: LD_ADDR_VAR 0 29
130930: PUSH
130931: LD_INT 1
130933: ST_TO_ADDR
// break ;
130934: GO 130938
// end ; end ;
130936: GO 130805
130938: POP
130939: POP
// if not attacking and f_attack_depot then
130940: LD_VAR 0 29
130944: NOT
130945: PUSH
130946: LD_VAR 0 25
130950: AND
130951: IFFALSE 131046
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
130953: LD_ADDR_VAR 0 13
130957: PUSH
130958: LD_VAR 0 14
130962: PPUSH
130963: LD_INT 2
130965: PUSH
130966: LD_INT 30
130968: PUSH
130969: LD_INT 0
130971: PUSH
130972: EMPTY
130973: LIST
130974: LIST
130975: PUSH
130976: LD_INT 30
130978: PUSH
130979: LD_INT 1
130981: PUSH
130982: EMPTY
130983: LIST
130984: LIST
130985: PUSH
130986: EMPTY
130987: LIST
130988: LIST
130989: LIST
130990: PPUSH
130991: CALL_OW 72
130995: ST_TO_ADDR
// if z then
130996: LD_VAR 0 13
131000: IFFALSE 131046
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
131002: LD_VAR 0 4
131006: PUSH
131007: LD_VAR 0 7
131011: ARRAY
131012: PPUSH
131013: LD_VAR 0 13
131017: PPUSH
131018: LD_VAR 0 4
131022: PUSH
131023: LD_VAR 0 7
131027: ARRAY
131028: PPUSH
131029: CALL_OW 74
131033: PPUSH
131034: CALL_OW 115
// attacking := true ;
131038: LD_ADDR_VAR 0 29
131042: PUSH
131043: LD_INT 1
131045: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
131046: LD_VAR 0 4
131050: PUSH
131051: LD_VAR 0 7
131055: ARRAY
131056: PPUSH
131057: CALL_OW 256
131061: PUSH
131062: LD_INT 500
131064: LESS
131065: IFFALSE 131091
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131067: LD_VAR 0 4
131071: PUSH
131072: LD_VAR 0 7
131076: ARRAY
131077: PPUSH
131078: LD_VAR 0 14
131082: PUSH
131083: LD_INT 1
131085: ARRAY
131086: PPUSH
131087: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
131091: LD_VAR 0 4
131095: PUSH
131096: LD_VAR 0 7
131100: ARRAY
131101: PPUSH
131102: CALL_OW 264
131106: PUSH
131107: LD_INT 49
131109: EQUAL
131110: IFFALSE 131231
// begin if not HasTask ( group [ i ] ) then
131112: LD_VAR 0 4
131116: PUSH
131117: LD_VAR 0 7
131121: ARRAY
131122: PPUSH
131123: CALL_OW 314
131127: NOT
131128: IFFALSE 131231
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
131130: LD_ADDR_VAR 0 9
131134: PUSH
131135: LD_INT 81
131137: PUSH
131138: LD_VAR 0 4
131142: PUSH
131143: LD_VAR 0 7
131147: ARRAY
131148: PPUSH
131149: CALL_OW 255
131153: PUSH
131154: EMPTY
131155: LIST
131156: LIST
131157: PPUSH
131158: CALL_OW 69
131162: PPUSH
131163: LD_VAR 0 4
131167: PUSH
131168: LD_VAR 0 7
131172: ARRAY
131173: PPUSH
131174: CALL_OW 74
131178: ST_TO_ADDR
// if k then
131179: LD_VAR 0 9
131183: IFFALSE 131231
// if GetDistUnits ( group [ i ] , k ) > 10 then
131185: LD_VAR 0 4
131189: PUSH
131190: LD_VAR 0 7
131194: ARRAY
131195: PPUSH
131196: LD_VAR 0 9
131200: PPUSH
131201: CALL_OW 296
131205: PUSH
131206: LD_INT 10
131208: GREATER
131209: IFFALSE 131231
// ComMoveUnit ( group [ i ] , k ) ;
131211: LD_VAR 0 4
131215: PUSH
131216: LD_VAR 0 7
131220: ARRAY
131221: PPUSH
131222: LD_VAR 0 9
131226: PPUSH
131227: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
131231: LD_VAR 0 4
131235: PUSH
131236: LD_VAR 0 7
131240: ARRAY
131241: PPUSH
131242: CALL_OW 256
131246: PUSH
131247: LD_INT 250
131249: LESS
131250: PUSH
131251: LD_VAR 0 4
131255: PUSH
131256: LD_VAR 0 7
131260: ARRAY
131261: PUSH
131262: LD_INT 21
131264: PUSH
131265: LD_INT 2
131267: PUSH
131268: EMPTY
131269: LIST
131270: LIST
131271: PUSH
131272: LD_INT 23
131274: PUSH
131275: LD_INT 2
131277: PUSH
131278: EMPTY
131279: LIST
131280: LIST
131281: PUSH
131282: EMPTY
131283: LIST
131284: LIST
131285: PPUSH
131286: CALL_OW 69
131290: IN
131291: AND
131292: IFFALSE 131417
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
131294: LD_ADDR_VAR 0 9
131298: PUSH
131299: LD_OWVAR 3
131303: PUSH
131304: LD_VAR 0 4
131308: PUSH
131309: LD_VAR 0 7
131313: ARRAY
131314: DIFF
131315: PPUSH
131316: LD_VAR 0 4
131320: PUSH
131321: LD_VAR 0 7
131325: ARRAY
131326: PPUSH
131327: CALL_OW 74
131331: ST_TO_ADDR
// if not k then
131332: LD_VAR 0 9
131336: NOT
131337: IFFALSE 131341
// continue ;
131339: GO 127756
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
131341: LD_VAR 0 9
131345: PUSH
131346: LD_INT 81
131348: PUSH
131349: LD_VAR 0 4
131353: PUSH
131354: LD_VAR 0 7
131358: ARRAY
131359: PPUSH
131360: CALL_OW 255
131364: PUSH
131365: EMPTY
131366: LIST
131367: LIST
131368: PPUSH
131369: CALL_OW 69
131373: IN
131374: PUSH
131375: LD_VAR 0 9
131379: PPUSH
131380: LD_VAR 0 4
131384: PUSH
131385: LD_VAR 0 7
131389: ARRAY
131390: PPUSH
131391: CALL_OW 296
131395: PUSH
131396: LD_INT 5
131398: LESS
131399: AND
131400: IFFALSE 131417
// ComAutodestruct ( group [ i ] ) ;
131402: LD_VAR 0 4
131406: PUSH
131407: LD_VAR 0 7
131411: ARRAY
131412: PPUSH
131413: CALL 99004 0 1
// end ; if f_attack_depot then
131417: LD_VAR 0 25
131421: IFFALSE 131533
// begin k := 6 ;
131423: LD_ADDR_VAR 0 9
131427: PUSH
131428: LD_INT 6
131430: ST_TO_ADDR
// if tmp < k then
131431: LD_VAR 0 14
131435: PUSH
131436: LD_VAR 0 9
131440: LESS
131441: IFFALSE 131453
// k := tmp ;
131443: LD_ADDR_VAR 0 9
131447: PUSH
131448: LD_VAR 0 14
131452: ST_TO_ADDR
// for j = 1 to k do
131453: LD_ADDR_VAR 0 8
131457: PUSH
131458: DOUBLE
131459: LD_INT 1
131461: DEC
131462: ST_TO_ADDR
131463: LD_VAR 0 9
131467: PUSH
131468: FOR_TO
131469: IFFALSE 131531
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
131471: LD_VAR 0 8
131475: PPUSH
131476: CALL_OW 266
131480: PUSH
131481: LD_INT 0
131483: PUSH
131484: LD_INT 1
131486: PUSH
131487: EMPTY
131488: LIST
131489: LIST
131490: IN
131491: IFFALSE 131529
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131493: LD_VAR 0 4
131497: PUSH
131498: LD_VAR 0 7
131502: ARRAY
131503: PPUSH
131504: LD_VAR 0 14
131508: PUSH
131509: LD_VAR 0 8
131513: ARRAY
131514: PPUSH
131515: CALL_OW 115
// attacking := true ;
131519: LD_ADDR_VAR 0 29
131523: PUSH
131524: LD_INT 1
131526: ST_TO_ADDR
// break ;
131527: GO 131531
// end ;
131529: GO 131468
131531: POP
131532: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
131533: LD_VAR 0 4
131537: PUSH
131538: LD_VAR 0 7
131542: ARRAY
131543: PPUSH
131544: CALL_OW 302
131548: PUSH
131549: LD_VAR 0 29
131553: NOT
131554: AND
131555: IFFALSE 131877
// begin if GetTag ( group [ i ] ) = 71 then
131557: LD_VAR 0 4
131561: PUSH
131562: LD_VAR 0 7
131566: ARRAY
131567: PPUSH
131568: CALL_OW 110
131572: PUSH
131573: LD_INT 71
131575: EQUAL
131576: IFFALSE 131617
// begin if HasTask ( group [ i ] ) then
131578: LD_VAR 0 4
131582: PUSH
131583: LD_VAR 0 7
131587: ARRAY
131588: PPUSH
131589: CALL_OW 314
131593: IFFALSE 131599
// continue else
131595: GO 127756
131597: GO 131617
// SetTag ( group [ i ] , 0 ) ;
131599: LD_VAR 0 4
131603: PUSH
131604: LD_VAR 0 7
131608: ARRAY
131609: PPUSH
131610: LD_INT 0
131612: PPUSH
131613: CALL_OW 109
// end ; k := 8 ;
131617: LD_ADDR_VAR 0 9
131621: PUSH
131622: LD_INT 8
131624: ST_TO_ADDR
// x := 0 ;
131625: LD_ADDR_VAR 0 10
131629: PUSH
131630: LD_INT 0
131632: ST_TO_ADDR
// if tmp < k then
131633: LD_VAR 0 14
131637: PUSH
131638: LD_VAR 0 9
131642: LESS
131643: IFFALSE 131655
// k := tmp ;
131645: LD_ADDR_VAR 0 9
131649: PUSH
131650: LD_VAR 0 14
131654: ST_TO_ADDR
// for j = 1 to k do
131655: LD_ADDR_VAR 0 8
131659: PUSH
131660: DOUBLE
131661: LD_INT 1
131663: DEC
131664: ST_TO_ADDR
131665: LD_VAR 0 9
131669: PUSH
131670: FOR_TO
131671: IFFALSE 131769
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
131673: LD_VAR 0 14
131677: PUSH
131678: LD_VAR 0 8
131682: ARRAY
131683: PPUSH
131684: CALL_OW 247
131688: PUSH
131689: LD_INT 1
131691: EQUAL
131692: PUSH
131693: LD_VAR 0 14
131697: PUSH
131698: LD_VAR 0 8
131702: ARRAY
131703: PPUSH
131704: CALL_OW 256
131708: PUSH
131709: LD_INT 250
131711: LESS
131712: PUSH
131713: LD_VAR 0 20
131717: AND
131718: PUSH
131719: LD_VAR 0 20
131723: NOT
131724: PUSH
131725: LD_VAR 0 14
131729: PUSH
131730: LD_VAR 0 8
131734: ARRAY
131735: PPUSH
131736: CALL_OW 256
131740: PUSH
131741: LD_INT 250
131743: GREATEREQUAL
131744: AND
131745: OR
131746: AND
131747: IFFALSE 131767
// begin x := tmp [ j ] ;
131749: LD_ADDR_VAR 0 10
131753: PUSH
131754: LD_VAR 0 14
131758: PUSH
131759: LD_VAR 0 8
131763: ARRAY
131764: ST_TO_ADDR
// break ;
131765: GO 131769
// end ;
131767: GO 131670
131769: POP
131770: POP
// if x then
131771: LD_VAR 0 10
131775: IFFALSE 131799
// ComAttackUnit ( group [ i ] , x ) else
131777: LD_VAR 0 4
131781: PUSH
131782: LD_VAR 0 7
131786: ARRAY
131787: PPUSH
131788: LD_VAR 0 10
131792: PPUSH
131793: CALL_OW 115
131797: GO 131823
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131799: LD_VAR 0 4
131803: PUSH
131804: LD_VAR 0 7
131808: ARRAY
131809: PPUSH
131810: LD_VAR 0 14
131814: PUSH
131815: LD_INT 1
131817: ARRAY
131818: PPUSH
131819: CALL_OW 115
// if not HasTask ( group [ i ] ) then
131823: LD_VAR 0 4
131827: PUSH
131828: LD_VAR 0 7
131832: ARRAY
131833: PPUSH
131834: CALL_OW 314
131838: NOT
131839: IFFALSE 131877
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
131841: LD_VAR 0 4
131845: PUSH
131846: LD_VAR 0 7
131850: ARRAY
131851: PPUSH
131852: LD_VAR 0 14
131856: PPUSH
131857: LD_VAR 0 4
131861: PUSH
131862: LD_VAR 0 7
131866: ARRAY
131867: PPUSH
131868: CALL_OW 74
131872: PPUSH
131873: CALL_OW 115
// end ; end ; end ;
131877: GO 127756
131879: POP
131880: POP
// wait ( 0 0$2 ) ;
131881: LD_INT 70
131883: PPUSH
131884: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
131888: LD_VAR 0 4
131892: NOT
131893: PUSH
131894: LD_VAR 0 4
131898: PUSH
131899: EMPTY
131900: EQUAL
131901: OR
131902: PUSH
131903: LD_INT 81
131905: PUSH
131906: LD_VAR 0 35
131910: PUSH
131911: EMPTY
131912: LIST
131913: LIST
131914: PPUSH
131915: CALL_OW 69
131919: NOT
131920: OR
131921: IFFALSE 127741
// end ;
131923: LD_VAR 0 2
131927: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
131928: LD_INT 0
131930: PPUSH
131931: PPUSH
131932: PPUSH
131933: PPUSH
131934: PPUSH
131935: PPUSH
// if not base or not mc_bases [ base ] or not solds then
131936: LD_VAR 0 1
131940: NOT
131941: PUSH
131942: LD_EXP 97
131946: PUSH
131947: LD_VAR 0 1
131951: ARRAY
131952: NOT
131953: OR
131954: PUSH
131955: LD_VAR 0 2
131959: NOT
131960: OR
131961: IFFALSE 131965
// exit ;
131963: GO 132519
// side := mc_sides [ base ] ;
131965: LD_ADDR_VAR 0 6
131969: PUSH
131970: LD_EXP 123
131974: PUSH
131975: LD_VAR 0 1
131979: ARRAY
131980: ST_TO_ADDR
// if not side then
131981: LD_VAR 0 6
131985: NOT
131986: IFFALSE 131990
// exit ;
131988: GO 132519
// for i in solds do
131990: LD_ADDR_VAR 0 7
131994: PUSH
131995: LD_VAR 0 2
131999: PUSH
132000: FOR_IN
132001: IFFALSE 132062
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
132003: LD_VAR 0 7
132007: PPUSH
132008: CALL_OW 310
132012: PPUSH
132013: CALL_OW 266
132017: PUSH
132018: LD_INT 32
132020: PUSH
132021: LD_INT 31
132023: PUSH
132024: EMPTY
132025: LIST
132026: LIST
132027: IN
132028: IFFALSE 132048
// solds := solds diff i else
132030: LD_ADDR_VAR 0 2
132034: PUSH
132035: LD_VAR 0 2
132039: PUSH
132040: LD_VAR 0 7
132044: DIFF
132045: ST_TO_ADDR
132046: GO 132060
// SetTag ( i , 18 ) ;
132048: LD_VAR 0 7
132052: PPUSH
132053: LD_INT 18
132055: PPUSH
132056: CALL_OW 109
132060: GO 132000
132062: POP
132063: POP
// if not solds then
132064: LD_VAR 0 2
132068: NOT
132069: IFFALSE 132073
// exit ;
132071: GO 132519
// repeat wait ( 0 0$2 ) ;
132073: LD_INT 70
132075: PPUSH
132076: CALL_OW 67
// enemy := mc_scan [ base ] ;
132080: LD_ADDR_VAR 0 4
132084: PUSH
132085: LD_EXP 120
132089: PUSH
132090: LD_VAR 0 1
132094: ARRAY
132095: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
132096: LD_EXP 97
132100: PUSH
132101: LD_VAR 0 1
132105: ARRAY
132106: NOT
132107: PUSH
132108: LD_EXP 97
132112: PUSH
132113: LD_VAR 0 1
132117: ARRAY
132118: PUSH
132119: EMPTY
132120: EQUAL
132121: OR
132122: IFFALSE 132159
// begin for i in solds do
132124: LD_ADDR_VAR 0 7
132128: PUSH
132129: LD_VAR 0 2
132133: PUSH
132134: FOR_IN
132135: IFFALSE 132148
// ComStop ( i ) ;
132137: LD_VAR 0 7
132141: PPUSH
132142: CALL_OW 141
132146: GO 132134
132148: POP
132149: POP
// solds := [ ] ;
132150: LD_ADDR_VAR 0 2
132154: PUSH
132155: EMPTY
132156: ST_TO_ADDR
// exit ;
132157: GO 132519
// end ; for i in solds do
132159: LD_ADDR_VAR 0 7
132163: PUSH
132164: LD_VAR 0 2
132168: PUSH
132169: FOR_IN
132170: IFFALSE 132491
// begin if IsInUnit ( i ) then
132172: LD_VAR 0 7
132176: PPUSH
132177: CALL_OW 310
132181: IFFALSE 132192
// ComExitBuilding ( i ) ;
132183: LD_VAR 0 7
132187: PPUSH
132188: CALL_OW 122
// if GetLives ( i ) > 500 then
132192: LD_VAR 0 7
132196: PPUSH
132197: CALL_OW 256
132201: PUSH
132202: LD_INT 500
132204: GREATER
132205: IFFALSE 132258
// begin e := NearestUnitToUnit ( enemy , i ) ;
132207: LD_ADDR_VAR 0 5
132211: PUSH
132212: LD_VAR 0 4
132216: PPUSH
132217: LD_VAR 0 7
132221: PPUSH
132222: CALL_OW 74
132226: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
132227: LD_VAR 0 7
132231: PPUSH
132232: LD_VAR 0 5
132236: PPUSH
132237: CALL_OW 250
132241: PPUSH
132242: LD_VAR 0 5
132246: PPUSH
132247: CALL_OW 251
132251: PPUSH
132252: CALL_OW 114
// end else
132256: GO 132489
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
132258: LD_VAR 0 7
132262: PPUSH
132263: LD_EXP 97
132267: PUSH
132268: LD_VAR 0 1
132272: ARRAY
132273: PPUSH
132274: LD_INT 2
132276: PUSH
132277: LD_INT 30
132279: PUSH
132280: LD_INT 0
132282: PUSH
132283: EMPTY
132284: LIST
132285: LIST
132286: PUSH
132287: LD_INT 30
132289: PUSH
132290: LD_INT 1
132292: PUSH
132293: EMPTY
132294: LIST
132295: LIST
132296: PUSH
132297: LD_INT 30
132299: PUSH
132300: LD_INT 6
132302: PUSH
132303: EMPTY
132304: LIST
132305: LIST
132306: PUSH
132307: EMPTY
132308: LIST
132309: LIST
132310: LIST
132311: LIST
132312: PPUSH
132313: CALL_OW 72
132317: PPUSH
132318: LD_VAR 0 7
132322: PPUSH
132323: CALL_OW 74
132327: PPUSH
132328: CALL_OW 296
132332: PUSH
132333: LD_INT 10
132335: GREATER
132336: IFFALSE 132489
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
132338: LD_ADDR_VAR 0 8
132342: PUSH
132343: LD_EXP 97
132347: PUSH
132348: LD_VAR 0 1
132352: ARRAY
132353: PPUSH
132354: LD_INT 2
132356: PUSH
132357: LD_INT 30
132359: PUSH
132360: LD_INT 0
132362: PUSH
132363: EMPTY
132364: LIST
132365: LIST
132366: PUSH
132367: LD_INT 30
132369: PUSH
132370: LD_INT 1
132372: PUSH
132373: EMPTY
132374: LIST
132375: LIST
132376: PUSH
132377: LD_INT 30
132379: PUSH
132380: LD_INT 6
132382: PUSH
132383: EMPTY
132384: LIST
132385: LIST
132386: PUSH
132387: EMPTY
132388: LIST
132389: LIST
132390: LIST
132391: LIST
132392: PPUSH
132393: CALL_OW 72
132397: PPUSH
132398: LD_VAR 0 7
132402: PPUSH
132403: CALL_OW 74
132407: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
132408: LD_VAR 0 7
132412: PPUSH
132413: LD_VAR 0 8
132417: PPUSH
132418: CALL_OW 250
132422: PPUSH
132423: LD_INT 3
132425: PPUSH
132426: LD_INT 5
132428: PPUSH
132429: CALL_OW 272
132433: PPUSH
132434: LD_VAR 0 8
132438: PPUSH
132439: CALL_OW 251
132443: PPUSH
132444: LD_INT 3
132446: PPUSH
132447: LD_INT 5
132449: PPUSH
132450: CALL_OW 273
132454: PPUSH
132455: CALL_OW 111
// SetTag ( i , 0 ) ;
132459: LD_VAR 0 7
132463: PPUSH
132464: LD_INT 0
132466: PPUSH
132467: CALL_OW 109
// solds := solds diff i ;
132471: LD_ADDR_VAR 0 2
132475: PUSH
132476: LD_VAR 0 2
132480: PUSH
132481: LD_VAR 0 7
132485: DIFF
132486: ST_TO_ADDR
// continue ;
132487: GO 132169
// end ; end ;
132489: GO 132169
132491: POP
132492: POP
// until not solds or not enemy ;
132493: LD_VAR 0 2
132497: NOT
132498: PUSH
132499: LD_VAR 0 4
132503: NOT
132504: OR
132505: IFFALSE 132073
// MC_Reset ( base , 18 ) ;
132507: LD_VAR 0 1
132511: PPUSH
132512: LD_INT 18
132514: PPUSH
132515: CALL 39573 0 2
// end ;
132519: LD_VAR 0 3
132523: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
132524: LD_INT 0
132526: PPUSH
132527: PPUSH
132528: PPUSH
132529: PPUSH
132530: PPUSH
132531: PPUSH
132532: PPUSH
132533: PPUSH
132534: PPUSH
132535: PPUSH
132536: PPUSH
132537: PPUSH
132538: PPUSH
132539: PPUSH
132540: PPUSH
132541: PPUSH
132542: PPUSH
132543: PPUSH
132544: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
132545: LD_ADDR_VAR 0 12
132549: PUSH
132550: LD_EXP 97
132554: PUSH
132555: LD_VAR 0 1
132559: ARRAY
132560: PPUSH
132561: LD_INT 25
132563: PUSH
132564: LD_INT 3
132566: PUSH
132567: EMPTY
132568: LIST
132569: LIST
132570: PPUSH
132571: CALL_OW 72
132575: ST_TO_ADDR
// if mc_remote_driver [ base ] then
132576: LD_EXP 137
132580: PUSH
132581: LD_VAR 0 1
132585: ARRAY
132586: IFFALSE 132610
// mechs := mechs diff mc_remote_driver [ base ] ;
132588: LD_ADDR_VAR 0 12
132592: PUSH
132593: LD_VAR 0 12
132597: PUSH
132598: LD_EXP 137
132602: PUSH
132603: LD_VAR 0 1
132607: ARRAY
132608: DIFF
132609: ST_TO_ADDR
// for i in mechs do
132610: LD_ADDR_VAR 0 4
132614: PUSH
132615: LD_VAR 0 12
132619: PUSH
132620: FOR_IN
132621: IFFALSE 132656
// if GetTag ( i ) > 0 then
132623: LD_VAR 0 4
132627: PPUSH
132628: CALL_OW 110
132632: PUSH
132633: LD_INT 0
132635: GREATER
132636: IFFALSE 132654
// mechs := mechs diff i ;
132638: LD_ADDR_VAR 0 12
132642: PUSH
132643: LD_VAR 0 12
132647: PUSH
132648: LD_VAR 0 4
132652: DIFF
132653: ST_TO_ADDR
132654: GO 132620
132656: POP
132657: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
132658: LD_ADDR_VAR 0 8
132662: PUSH
132663: LD_EXP 97
132667: PUSH
132668: LD_VAR 0 1
132672: ARRAY
132673: PPUSH
132674: LD_INT 2
132676: PUSH
132677: LD_INT 25
132679: PUSH
132680: LD_INT 1
132682: PUSH
132683: EMPTY
132684: LIST
132685: LIST
132686: PUSH
132687: LD_INT 25
132689: PUSH
132690: LD_INT 5
132692: PUSH
132693: EMPTY
132694: LIST
132695: LIST
132696: PUSH
132697: LD_INT 25
132699: PUSH
132700: LD_INT 8
132702: PUSH
132703: EMPTY
132704: LIST
132705: LIST
132706: PUSH
132707: LD_INT 25
132709: PUSH
132710: LD_INT 9
132712: PUSH
132713: EMPTY
132714: LIST
132715: LIST
132716: PUSH
132717: EMPTY
132718: LIST
132719: LIST
132720: LIST
132721: LIST
132722: LIST
132723: PPUSH
132724: CALL_OW 72
132728: ST_TO_ADDR
// if not defenders and not solds then
132729: LD_VAR 0 2
132733: NOT
132734: PUSH
132735: LD_VAR 0 8
132739: NOT
132740: AND
132741: IFFALSE 132745
// exit ;
132743: GO 134515
// depot_under_attack := false ;
132745: LD_ADDR_VAR 0 16
132749: PUSH
132750: LD_INT 0
132752: ST_TO_ADDR
// sold_defenders := [ ] ;
132753: LD_ADDR_VAR 0 17
132757: PUSH
132758: EMPTY
132759: ST_TO_ADDR
// if mechs then
132760: LD_VAR 0 12
132764: IFFALSE 132917
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
132766: LD_ADDR_VAR 0 4
132770: PUSH
132771: LD_VAR 0 2
132775: PPUSH
132776: LD_INT 21
132778: PUSH
132779: LD_INT 2
132781: PUSH
132782: EMPTY
132783: LIST
132784: LIST
132785: PPUSH
132786: CALL_OW 72
132790: PUSH
132791: FOR_IN
132792: IFFALSE 132915
// begin if GetTag ( i ) <> 20 then
132794: LD_VAR 0 4
132798: PPUSH
132799: CALL_OW 110
132803: PUSH
132804: LD_INT 20
132806: NONEQUAL
132807: IFFALSE 132821
// SetTag ( i , 20 ) ;
132809: LD_VAR 0 4
132813: PPUSH
132814: LD_INT 20
132816: PPUSH
132817: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
132821: LD_VAR 0 4
132825: PPUSH
132826: CALL_OW 263
132830: PUSH
132831: LD_INT 1
132833: EQUAL
132834: PUSH
132835: LD_VAR 0 4
132839: PPUSH
132840: CALL_OW 311
132844: NOT
132845: AND
132846: IFFALSE 132913
// begin un := mechs [ 1 ] ;
132848: LD_ADDR_VAR 0 10
132852: PUSH
132853: LD_VAR 0 12
132857: PUSH
132858: LD_INT 1
132860: ARRAY
132861: ST_TO_ADDR
// ComExit ( un ) ;
132862: LD_VAR 0 10
132866: PPUSH
132867: CALL 103870 0 1
// AddComEnterUnit ( un , i ) ;
132871: LD_VAR 0 10
132875: PPUSH
132876: LD_VAR 0 4
132880: PPUSH
132881: CALL_OW 180
// SetTag ( un , 19 ) ;
132885: LD_VAR 0 10
132889: PPUSH
132890: LD_INT 19
132892: PPUSH
132893: CALL_OW 109
// mechs := mechs diff un ;
132897: LD_ADDR_VAR 0 12
132901: PUSH
132902: LD_VAR 0 12
132906: PUSH
132907: LD_VAR 0 10
132911: DIFF
132912: ST_TO_ADDR
// end ; end ;
132913: GO 132791
132915: POP
132916: POP
// if solds then
132917: LD_VAR 0 8
132921: IFFALSE 132980
// for i in solds do
132923: LD_ADDR_VAR 0 4
132927: PUSH
132928: LD_VAR 0 8
132932: PUSH
132933: FOR_IN
132934: IFFALSE 132978
// if not GetTag ( i ) then
132936: LD_VAR 0 4
132940: PPUSH
132941: CALL_OW 110
132945: NOT
132946: IFFALSE 132976
// begin defenders := defenders union i ;
132948: LD_ADDR_VAR 0 2
132952: PUSH
132953: LD_VAR 0 2
132957: PUSH
132958: LD_VAR 0 4
132962: UNION
132963: ST_TO_ADDR
// SetTag ( i , 18 ) ;
132964: LD_VAR 0 4
132968: PPUSH
132969: LD_INT 18
132971: PPUSH
132972: CALL_OW 109
// end ;
132976: GO 132933
132978: POP
132979: POP
// repeat wait ( 0 0$2 ) ;
132980: LD_INT 70
132982: PPUSH
132983: CALL_OW 67
// enemy := mc_scan [ base ] ;
132987: LD_ADDR_VAR 0 21
132991: PUSH
132992: LD_EXP 120
132996: PUSH
132997: LD_VAR 0 1
133001: ARRAY
133002: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133003: LD_EXP 97
133007: PUSH
133008: LD_VAR 0 1
133012: ARRAY
133013: NOT
133014: PUSH
133015: LD_EXP 97
133019: PUSH
133020: LD_VAR 0 1
133024: ARRAY
133025: PUSH
133026: EMPTY
133027: EQUAL
133028: OR
133029: IFFALSE 133066
// begin for i in defenders do
133031: LD_ADDR_VAR 0 4
133035: PUSH
133036: LD_VAR 0 2
133040: PUSH
133041: FOR_IN
133042: IFFALSE 133055
// ComStop ( i ) ;
133044: LD_VAR 0 4
133048: PPUSH
133049: CALL_OW 141
133053: GO 133041
133055: POP
133056: POP
// defenders := [ ] ;
133057: LD_ADDR_VAR 0 2
133061: PUSH
133062: EMPTY
133063: ST_TO_ADDR
// exit ;
133064: GO 134515
// end ; for i in defenders do
133066: LD_ADDR_VAR 0 4
133070: PUSH
133071: LD_VAR 0 2
133075: PUSH
133076: FOR_IN
133077: IFFALSE 133975
// begin e := NearestUnitToUnit ( enemy , i ) ;
133079: LD_ADDR_VAR 0 13
133083: PUSH
133084: LD_VAR 0 21
133088: PPUSH
133089: LD_VAR 0 4
133093: PPUSH
133094: CALL_OW 74
133098: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
133099: LD_ADDR_VAR 0 7
133103: PUSH
133104: LD_EXP 97
133108: PUSH
133109: LD_VAR 0 1
133113: ARRAY
133114: PPUSH
133115: LD_INT 2
133117: PUSH
133118: LD_INT 30
133120: PUSH
133121: LD_INT 0
133123: PUSH
133124: EMPTY
133125: LIST
133126: LIST
133127: PUSH
133128: LD_INT 30
133130: PUSH
133131: LD_INT 1
133133: PUSH
133134: EMPTY
133135: LIST
133136: LIST
133137: PUSH
133138: EMPTY
133139: LIST
133140: LIST
133141: LIST
133142: PPUSH
133143: CALL_OW 72
133147: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
133148: LD_ADDR_VAR 0 16
133152: PUSH
133153: LD_VAR 0 7
133157: NOT
133158: PUSH
133159: LD_VAR 0 7
133163: PPUSH
133164: LD_INT 3
133166: PUSH
133167: LD_INT 24
133169: PUSH
133170: LD_INT 600
133172: PUSH
133173: EMPTY
133174: LIST
133175: LIST
133176: PUSH
133177: EMPTY
133178: LIST
133179: LIST
133180: PPUSH
133181: CALL_OW 72
133185: OR
133186: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
133187: LD_VAR 0 4
133191: PPUSH
133192: CALL_OW 247
133196: PUSH
133197: LD_INT 2
133199: DOUBLE
133200: EQUAL
133201: IFTRUE 133205
133203: GO 133601
133205: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
133206: LD_VAR 0 4
133210: PPUSH
133211: CALL_OW 256
133215: PUSH
133216: LD_INT 1000
133218: EQUAL
133219: PUSH
133220: LD_VAR 0 4
133224: PPUSH
133225: LD_VAR 0 13
133229: PPUSH
133230: CALL_OW 296
133234: PUSH
133235: LD_INT 40
133237: LESS
133238: PUSH
133239: LD_VAR 0 13
133243: PPUSH
133244: LD_EXP 122
133248: PUSH
133249: LD_VAR 0 1
133253: ARRAY
133254: PPUSH
133255: CALL_OW 308
133259: OR
133260: AND
133261: IFFALSE 133383
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
133263: LD_VAR 0 4
133267: PPUSH
133268: CALL_OW 262
133272: PUSH
133273: LD_INT 1
133275: EQUAL
133276: PUSH
133277: LD_VAR 0 4
133281: PPUSH
133282: CALL_OW 261
133286: PUSH
133287: LD_INT 30
133289: LESS
133290: AND
133291: PUSH
133292: LD_VAR 0 7
133296: AND
133297: IFFALSE 133367
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
133299: LD_VAR 0 4
133303: PPUSH
133304: LD_VAR 0 7
133308: PPUSH
133309: LD_VAR 0 4
133313: PPUSH
133314: CALL_OW 74
133318: PPUSH
133319: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
133323: LD_VAR 0 4
133327: PPUSH
133328: LD_VAR 0 7
133332: PPUSH
133333: LD_VAR 0 4
133337: PPUSH
133338: CALL_OW 74
133342: PPUSH
133343: CALL_OW 296
133347: PUSH
133348: LD_INT 6
133350: LESS
133351: IFFALSE 133365
// SetFuel ( i , 100 ) ;
133353: LD_VAR 0 4
133357: PPUSH
133358: LD_INT 100
133360: PPUSH
133361: CALL_OW 240
// end else
133365: GO 133381
// ComAttackUnit ( i , e ) ;
133367: LD_VAR 0 4
133371: PPUSH
133372: LD_VAR 0 13
133376: PPUSH
133377: CALL_OW 115
// end else
133381: GO 133484
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
133383: LD_VAR 0 13
133387: PPUSH
133388: LD_EXP 122
133392: PUSH
133393: LD_VAR 0 1
133397: ARRAY
133398: PPUSH
133399: CALL_OW 308
133403: NOT
133404: PUSH
133405: LD_VAR 0 4
133409: PPUSH
133410: LD_VAR 0 13
133414: PPUSH
133415: CALL_OW 296
133419: PUSH
133420: LD_INT 40
133422: GREATEREQUAL
133423: AND
133424: PUSH
133425: LD_VAR 0 4
133429: PPUSH
133430: CALL_OW 256
133434: PUSH
133435: LD_INT 650
133437: LESSEQUAL
133438: OR
133439: PUSH
133440: LD_VAR 0 4
133444: PPUSH
133445: LD_EXP 121
133449: PUSH
133450: LD_VAR 0 1
133454: ARRAY
133455: PPUSH
133456: CALL_OW 308
133460: NOT
133461: AND
133462: IFFALSE 133484
// ComMoveToArea ( i , mc_parking [ base ] ) ;
133464: LD_VAR 0 4
133468: PPUSH
133469: LD_EXP 121
133473: PUSH
133474: LD_VAR 0 1
133478: ARRAY
133479: PPUSH
133480: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
133484: LD_VAR 0 4
133488: PPUSH
133489: CALL_OW 256
133493: PUSH
133494: LD_INT 1000
133496: LESS
133497: PUSH
133498: LD_VAR 0 4
133502: PPUSH
133503: CALL_OW 263
133507: PUSH
133508: LD_INT 1
133510: EQUAL
133511: AND
133512: PUSH
133513: LD_VAR 0 4
133517: PPUSH
133518: CALL_OW 311
133522: AND
133523: PUSH
133524: LD_VAR 0 4
133528: PPUSH
133529: LD_EXP 121
133533: PUSH
133534: LD_VAR 0 1
133538: ARRAY
133539: PPUSH
133540: CALL_OW 308
133544: AND
133545: IFFALSE 133599
// begin mech := IsDrivenBy ( i ) ;
133547: LD_ADDR_VAR 0 9
133551: PUSH
133552: LD_VAR 0 4
133556: PPUSH
133557: CALL_OW 311
133561: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
133562: LD_VAR 0 9
133566: PPUSH
133567: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
133571: LD_VAR 0 9
133575: PPUSH
133576: LD_VAR 0 4
133580: PPUSH
133581: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
133585: LD_VAR 0 9
133589: PPUSH
133590: LD_VAR 0 4
133594: PPUSH
133595: CALL_OW 180
// end ; end ; unit_human :
133599: GO 133946
133601: LD_INT 1
133603: DOUBLE
133604: EQUAL
133605: IFTRUE 133609
133607: GO 133945
133609: POP
// begin b := IsInUnit ( i ) ;
133610: LD_ADDR_VAR 0 18
133614: PUSH
133615: LD_VAR 0 4
133619: PPUSH
133620: CALL_OW 310
133624: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
133625: LD_ADDR_VAR 0 19
133629: PUSH
133630: LD_VAR 0 18
133634: NOT
133635: PUSH
133636: LD_VAR 0 18
133640: PPUSH
133641: CALL_OW 266
133645: PUSH
133646: LD_INT 32
133648: PUSH
133649: LD_INT 31
133651: PUSH
133652: EMPTY
133653: LIST
133654: LIST
133655: IN
133656: OR
133657: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
133658: LD_VAR 0 18
133662: PPUSH
133663: CALL_OW 266
133667: PUSH
133668: LD_INT 5
133670: EQUAL
133671: PUSH
133672: LD_VAR 0 4
133676: PPUSH
133677: CALL_OW 257
133681: PUSH
133682: LD_INT 1
133684: PUSH
133685: LD_INT 2
133687: PUSH
133688: LD_INT 3
133690: PUSH
133691: LD_INT 4
133693: PUSH
133694: EMPTY
133695: LIST
133696: LIST
133697: LIST
133698: LIST
133699: IN
133700: AND
133701: IFFALSE 133738
// begin class := AllowSpecClass ( i ) ;
133703: LD_ADDR_VAR 0 20
133707: PUSH
133708: LD_VAR 0 4
133712: PPUSH
133713: CALL 67809 0 1
133717: ST_TO_ADDR
// if class then
133718: LD_VAR 0 20
133722: IFFALSE 133738
// ComChangeProfession ( i , class ) ;
133724: LD_VAR 0 4
133728: PPUSH
133729: LD_VAR 0 20
133733: PPUSH
133734: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
133738: LD_VAR 0 16
133742: PUSH
133743: LD_VAR 0 2
133747: PPUSH
133748: LD_INT 21
133750: PUSH
133751: LD_INT 2
133753: PUSH
133754: EMPTY
133755: LIST
133756: LIST
133757: PPUSH
133758: CALL_OW 72
133762: PUSH
133763: LD_INT 1
133765: LESSEQUAL
133766: OR
133767: PUSH
133768: LD_VAR 0 19
133772: AND
133773: PUSH
133774: LD_VAR 0 4
133778: PUSH
133779: LD_VAR 0 17
133783: IN
133784: NOT
133785: AND
133786: IFFALSE 133879
// begin if b then
133788: LD_VAR 0 18
133792: IFFALSE 133841
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
133794: LD_VAR 0 18
133798: PPUSH
133799: LD_VAR 0 21
133803: PPUSH
133804: LD_VAR 0 18
133808: PPUSH
133809: CALL_OW 74
133813: PPUSH
133814: CALL_OW 296
133818: PUSH
133819: LD_INT 10
133821: LESS
133822: PUSH
133823: LD_VAR 0 18
133827: PPUSH
133828: CALL_OW 461
133832: PUSH
133833: LD_INT 7
133835: NONEQUAL
133836: AND
133837: IFFALSE 133841
// continue ;
133839: GO 133076
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
133841: LD_ADDR_VAR 0 17
133845: PUSH
133846: LD_VAR 0 17
133850: PPUSH
133851: LD_VAR 0 17
133855: PUSH
133856: LD_INT 1
133858: PLUS
133859: PPUSH
133860: LD_VAR 0 4
133864: PPUSH
133865: CALL_OW 1
133869: ST_TO_ADDR
// ComExitBuilding ( i ) ;
133870: LD_VAR 0 4
133874: PPUSH
133875: CALL_OW 122
// end ; if sold_defenders then
133879: LD_VAR 0 17
133883: IFFALSE 133943
// if i in sold_defenders then
133885: LD_VAR 0 4
133889: PUSH
133890: LD_VAR 0 17
133894: IN
133895: IFFALSE 133943
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
133897: LD_VAR 0 4
133901: PPUSH
133902: CALL_OW 314
133906: NOT
133907: PUSH
133908: LD_VAR 0 4
133912: PPUSH
133913: LD_VAR 0 13
133917: PPUSH
133918: CALL_OW 296
133922: PUSH
133923: LD_INT 30
133925: LESS
133926: AND
133927: IFFALSE 133943
// ComAttackUnit ( i , e ) ;
133929: LD_VAR 0 4
133933: PPUSH
133934: LD_VAR 0 13
133938: PPUSH
133939: CALL_OW 115
// end ; end ; end ;
133943: GO 133946
133945: POP
// if IsDead ( i ) then
133946: LD_VAR 0 4
133950: PPUSH
133951: CALL_OW 301
133955: IFFALSE 133973
// defenders := defenders diff i ;
133957: LD_ADDR_VAR 0 2
133961: PUSH
133962: LD_VAR 0 2
133966: PUSH
133967: LD_VAR 0 4
133971: DIFF
133972: ST_TO_ADDR
// end ;
133973: GO 133076
133975: POP
133976: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
133977: LD_VAR 0 21
133981: NOT
133982: PUSH
133983: LD_VAR 0 2
133987: NOT
133988: OR
133989: PUSH
133990: LD_EXP 97
133994: PUSH
133995: LD_VAR 0 1
133999: ARRAY
134000: NOT
134001: OR
134002: IFFALSE 132980
// MC_Reset ( base , 18 ) ;
134004: LD_VAR 0 1
134008: PPUSH
134009: LD_INT 18
134011: PPUSH
134012: CALL 39573 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134016: LD_ADDR_VAR 0 2
134020: PUSH
134021: LD_VAR 0 2
134025: PUSH
134026: LD_VAR 0 2
134030: PPUSH
134031: LD_INT 2
134033: PUSH
134034: LD_INT 25
134036: PUSH
134037: LD_INT 1
134039: PUSH
134040: EMPTY
134041: LIST
134042: LIST
134043: PUSH
134044: LD_INT 25
134046: PUSH
134047: LD_INT 5
134049: PUSH
134050: EMPTY
134051: LIST
134052: LIST
134053: PUSH
134054: LD_INT 25
134056: PUSH
134057: LD_INT 8
134059: PUSH
134060: EMPTY
134061: LIST
134062: LIST
134063: PUSH
134064: LD_INT 25
134066: PUSH
134067: LD_INT 9
134069: PUSH
134070: EMPTY
134071: LIST
134072: LIST
134073: PUSH
134074: EMPTY
134075: LIST
134076: LIST
134077: LIST
134078: LIST
134079: LIST
134080: PPUSH
134081: CALL_OW 72
134085: DIFF
134086: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
134087: LD_VAR 0 21
134091: NOT
134092: PUSH
134093: LD_VAR 0 2
134097: PPUSH
134098: LD_INT 21
134100: PUSH
134101: LD_INT 2
134103: PUSH
134104: EMPTY
134105: LIST
134106: LIST
134107: PPUSH
134108: CALL_OW 72
134112: AND
134113: IFFALSE 134451
// begin tmp := FilterByTag ( defenders , 19 ) ;
134115: LD_ADDR_VAR 0 11
134119: PUSH
134120: LD_VAR 0 2
134124: PPUSH
134125: LD_INT 19
134127: PPUSH
134128: CALL 101046 0 2
134132: ST_TO_ADDR
// if tmp then
134133: LD_VAR 0 11
134137: IFFALSE 134207
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
134139: LD_ADDR_VAR 0 11
134143: PUSH
134144: LD_VAR 0 11
134148: PPUSH
134149: LD_INT 25
134151: PUSH
134152: LD_INT 3
134154: PUSH
134155: EMPTY
134156: LIST
134157: LIST
134158: PPUSH
134159: CALL_OW 72
134163: ST_TO_ADDR
// if tmp then
134164: LD_VAR 0 11
134168: IFFALSE 134207
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
134170: LD_ADDR_EXP 109
134174: PUSH
134175: LD_EXP 109
134179: PPUSH
134180: LD_VAR 0 1
134184: PPUSH
134185: LD_EXP 109
134189: PUSH
134190: LD_VAR 0 1
134194: ARRAY
134195: PUSH
134196: LD_VAR 0 11
134200: UNION
134201: PPUSH
134202: CALL_OW 1
134206: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
134207: LD_VAR 0 1
134211: PPUSH
134212: LD_INT 19
134214: PPUSH
134215: CALL 39573 0 2
// repeat wait ( 0 0$1 ) ;
134219: LD_INT 35
134221: PPUSH
134222: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134226: LD_EXP 97
134230: PUSH
134231: LD_VAR 0 1
134235: ARRAY
134236: NOT
134237: PUSH
134238: LD_EXP 97
134242: PUSH
134243: LD_VAR 0 1
134247: ARRAY
134248: PUSH
134249: EMPTY
134250: EQUAL
134251: OR
134252: IFFALSE 134289
// begin for i in defenders do
134254: LD_ADDR_VAR 0 4
134258: PUSH
134259: LD_VAR 0 2
134263: PUSH
134264: FOR_IN
134265: IFFALSE 134278
// ComStop ( i ) ;
134267: LD_VAR 0 4
134271: PPUSH
134272: CALL_OW 141
134276: GO 134264
134278: POP
134279: POP
// defenders := [ ] ;
134280: LD_ADDR_VAR 0 2
134284: PUSH
134285: EMPTY
134286: ST_TO_ADDR
// exit ;
134287: GO 134515
// end ; for i in defenders do
134289: LD_ADDR_VAR 0 4
134293: PUSH
134294: LD_VAR 0 2
134298: PUSH
134299: FOR_IN
134300: IFFALSE 134389
// begin if not IsInArea ( i , mc_parking [ base ] ) then
134302: LD_VAR 0 4
134306: PPUSH
134307: LD_EXP 121
134311: PUSH
134312: LD_VAR 0 1
134316: ARRAY
134317: PPUSH
134318: CALL_OW 308
134322: NOT
134323: IFFALSE 134347
// ComMoveToArea ( i , mc_parking [ base ] ) else
134325: LD_VAR 0 4
134329: PPUSH
134330: LD_EXP 121
134334: PUSH
134335: LD_VAR 0 1
134339: ARRAY
134340: PPUSH
134341: CALL_OW 113
134345: GO 134387
// if GetControl ( i ) = control_manual then
134347: LD_VAR 0 4
134351: PPUSH
134352: CALL_OW 263
134356: PUSH
134357: LD_INT 1
134359: EQUAL
134360: IFFALSE 134387
// if IsDrivenBy ( i ) then
134362: LD_VAR 0 4
134366: PPUSH
134367: CALL_OW 311
134371: IFFALSE 134387
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
134373: LD_VAR 0 4
134377: PPUSH
134378: CALL_OW 311
134382: PPUSH
134383: CALL_OW 121
// end ;
134387: GO 134299
134389: POP
134390: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
134391: LD_VAR 0 2
134395: PPUSH
134396: LD_INT 95
134398: PUSH
134399: LD_EXP 121
134403: PUSH
134404: LD_VAR 0 1
134408: ARRAY
134409: PUSH
134410: EMPTY
134411: LIST
134412: LIST
134413: PPUSH
134414: CALL_OW 72
134418: PUSH
134419: LD_VAR 0 2
134423: EQUAL
134424: PUSH
134425: LD_EXP 120
134429: PUSH
134430: LD_VAR 0 1
134434: ARRAY
134435: OR
134436: PUSH
134437: LD_EXP 97
134441: PUSH
134442: LD_VAR 0 1
134446: ARRAY
134447: NOT
134448: OR
134449: IFFALSE 134219
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
134451: LD_ADDR_EXP 119
134455: PUSH
134456: LD_EXP 119
134460: PPUSH
134461: LD_VAR 0 1
134465: PPUSH
134466: LD_VAR 0 2
134470: PPUSH
134471: LD_INT 21
134473: PUSH
134474: LD_INT 2
134476: PUSH
134477: EMPTY
134478: LIST
134479: LIST
134480: PPUSH
134481: CALL_OW 72
134485: PPUSH
134486: CALL_OW 1
134490: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
134491: LD_VAR 0 1
134495: PPUSH
134496: LD_INT 19
134498: PPUSH
134499: CALL 39573 0 2
// MC_Reset ( base , 20 ) ;
134503: LD_VAR 0 1
134507: PPUSH
134508: LD_INT 20
134510: PPUSH
134511: CALL 39573 0 2
// end ; end_of_file
134515: LD_VAR 0 3
134519: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
134520: LD_VAR 0 1
134524: PUSH
134525: LD_INT 200
134527: DOUBLE
134528: GREATEREQUAL
134529: IFFALSE 134537
134531: LD_INT 299
134533: DOUBLE
134534: LESSEQUAL
134535: IFTRUE 134539
134537: GO 134571
134539: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
134540: LD_VAR 0 1
134544: PPUSH
134545: LD_VAR 0 2
134549: PPUSH
134550: LD_VAR 0 3
134554: PPUSH
134555: LD_VAR 0 4
134559: PPUSH
134560: LD_VAR 0 5
134564: PPUSH
134565: CALL 123306 0 5
134569: GO 134648
134571: LD_INT 300
134573: DOUBLE
134574: GREATEREQUAL
134575: IFFALSE 134583
134577: LD_INT 399
134579: DOUBLE
134580: LESSEQUAL
134581: IFTRUE 134585
134583: GO 134647
134585: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
134586: LD_VAR 0 1
134590: PPUSH
134591: LD_VAR 0 2
134595: PPUSH
134596: LD_VAR 0 3
134600: PPUSH
134601: LD_VAR 0 4
134605: PPUSH
134606: LD_VAR 0 5
134610: PPUSH
134611: LD_VAR 0 6
134615: PPUSH
134616: LD_VAR 0 7
134620: PPUSH
134621: LD_VAR 0 8
134625: PPUSH
134626: LD_VAR 0 9
134630: PPUSH
134631: LD_VAR 0 10
134635: PPUSH
134636: LD_VAR 0 11
134640: PPUSH
134641: CALL 119639 0 11
134645: GO 134648
134647: POP
// end ;
134648: PPOPN 11
134650: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
134651: LD_VAR 0 1
134655: PPUSH
134656: LD_VAR 0 2
134660: PPUSH
134661: LD_VAR 0 3
134665: PPUSH
134666: LD_VAR 0 4
134670: PPUSH
134671: LD_VAR 0 5
134675: PPUSH
134676: CALL 123042 0 5
// end ; end_of_file
134680: PPOPN 5
134682: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
134683: LD_VAR 0 1
134687: PPUSH
134688: LD_VAR 0 2
134692: PPUSH
134693: LD_VAR 0 3
134697: PPUSH
134698: LD_VAR 0 4
134702: PPUSH
134703: LD_VAR 0 5
134707: PPUSH
134708: LD_VAR 0 6
134712: PPUSH
134713: CALL 107332 0 6
// end ;
134717: PPOPN 6
134719: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
134720: LD_INT 0
134722: PPUSH
// begin if not units then
134723: LD_VAR 0 1
134727: NOT
134728: IFFALSE 134732
// exit ;
134730: GO 134732
// end ;
134732: PPOPN 7
134734: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
134735: CALL 107303 0 0
// end ;
134739: PPOPN 1
134741: END
