// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35091 0 0
// InitMacro ;
  19: CALL 35259 0 0
// InitNature ;
  23: CALL 34959 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11169 0 0
// PrepareRussian ;
  44: CALL 7025 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15071 0 0
// MC_Start ( ) ;
  64: CALL 37424 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60173 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60266 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59616 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59431 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60173 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60266 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59431 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59616 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 60046 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 59113 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60173 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60266 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 145
 963: PUSH
 964: LD_EXP 145
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59431 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60173 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60266 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59323 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60584 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59755 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 60046 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 60046 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60378 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59431 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 59997 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65885 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70749 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70749 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70749 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70749 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70749 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65885 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65885 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65885 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65885 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65885 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65885 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65885 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65885 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65885 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65885 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65885 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65885 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65885 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65885 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65885 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65885 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65885 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65885 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65885 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65885 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65885 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65885 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65885 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65885 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65885 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65885 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65885 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65885 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70749 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65885 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65885 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65885 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74195 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 116
4751: PUSH
4752: LD_EXP 116
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70749 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59616 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59479 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60897 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59479 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59479 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60897 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60897 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 135
6051: PUSH
6052: LD_EXP 135
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 135
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7022
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70749 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// if legionDestroyed then
6858: LD_EXP 22
6862: IFFALSE 6866
// exit ;
6864: GO 7022
// for i in tmp do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: LD_VAR 0 3
6875: PUSH
6876: FOR_IN
6877: IFFALSE 7013
// begin if GetLives ( i ) > 250 then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 256
6888: PUSH
6889: LD_INT 250
6891: GREATER
6892: IFFALSE 6984
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6894: LD_INT 81
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 91
6906: PUSH
6907: LD_VAR 0 1
6911: PUSH
6912: LD_INT 10
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PPUSH
6924: CALL_OW 69
6928: NOT
6929: IFFALSE 6948
// ComAgressiveMove ( i , 67 , 110 ) else
6931: LD_VAR 0 1
6935: PPUSH
6936: LD_INT 67
6938: PPUSH
6939: LD_INT 110
6941: PPUSH
6942: CALL_OW 114
6946: GO 6982
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6948: LD_VAR 0 1
6952: PPUSH
6953: LD_INT 81
6955: PUSH
6956: LD_INT 8
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PPUSH
6963: CALL_OW 69
6967: PPUSH
6968: LD_VAR 0 1
6972: PPUSH
6973: CALL_OW 74
6977: PPUSH
6978: CALL_OW 115
// end else
6982: GO 7011
// if IsDead ( i ) then
6984: LD_VAR 0 1
6988: PPUSH
6989: CALL_OW 301
6993: IFFALSE 7011
// tmp := tmp diff i ;
6995: LD_ADDR_VAR 0 3
6999: PUSH
7000: LD_VAR 0 3
7004: PUSH
7005: LD_VAR 0 1
7009: DIFF
7010: ST_TO_ADDR
// end ;
7011: GO 6876
7013: POP
7014: POP
// until not tmp ;
7015: LD_VAR 0 3
7019: NOT
7020: IFFALSE 6851
// end ; end_of_file
7022: PPOPN 3
7024: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7025: LD_INT 0
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
7035: PPUSH
// side := 3 ;
7036: LD_ADDR_VAR 0 6
7040: PUSH
7041: LD_INT 3
7043: ST_TO_ADDR
// uc_side := side ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_VAR 0 6
7053: ST_TO_ADDR
// uc_nation := 3 ;
7054: LD_ADDR_OWVAR 21
7058: PUSH
7059: LD_INT 3
7061: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7062: LD_ADDR_VAR 0 2
7066: PUSH
7067: LD_INT 22
7069: PUSH
7070: LD_VAR 0 6
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PUSH
7079: LD_INT 21
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PPUSH
7093: CALL_OW 69
7097: PUSH
7098: FOR_IN
7099: IFFALSE 7115
// SetBLevel ( i , 10 ) ;
7101: LD_VAR 0 2
7105: PPUSH
7106: LD_INT 10
7108: PPUSH
7109: CALL_OW 241
7113: GO 7098
7115: POP
7116: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7117: LD_ADDR_VAR 0 9
7121: PUSH
7122: LD_INT 22
7124: PUSH
7125: LD_VAR 0 6
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 30
7136: PUSH
7137: LD_INT 34
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: ST_TO_ADDR
// if teleport then
7153: LD_VAR 0 9
7157: IFFALSE 7178
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7159: LD_VAR 0 9
7163: PUSH
7164: LD_INT 1
7166: ARRAY
7167: PPUSH
7168: LD_INT 123
7170: PPUSH
7171: LD_INT 122
7173: PPUSH
7174: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7178: LD_ADDR_EXP 64
7182: PUSH
7183: LD_STRING Platonov
7185: PPUSH
7186: CALL_OW 25
7190: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7191: LD_ADDR_EXP 65
7195: PUSH
7196: LD_STRING Kovalyuk
7198: PPUSH
7199: CALL_OW 25
7203: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7204: LD_ADDR_EXP 67
7208: PUSH
7209: LD_STRING Yakotich
7211: PPUSH
7212: LD_EXP 1
7216: NOT
7217: PPUSH
7218: LD_STRING 09_
7220: PPUSH
7221: CALL 65885 0 3
7225: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7226: LD_ADDR_EXP 66
7230: PUSH
7231: LD_STRING Bystrov
7233: PPUSH
7234: CALL_OW 25
7238: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7239: LD_ADDR_EXP 68
7243: PUSH
7244: LD_STRING Gleb
7246: PPUSH
7247: CALL_OW 25
7251: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7252: LD_STRING 03_Cornel
7254: PPUSH
7255: CALL_OW 28
7259: IFFALSE 7307
// begin Bierezov := NewCharacter ( Mikhail ) ;
7261: LD_ADDR_EXP 69
7265: PUSH
7266: LD_STRING Mikhail
7268: PPUSH
7269: CALL_OW 25
7273: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7274: LD_EXP 69
7278: PPUSH
7279: LD_INT 197
7281: PPUSH
7282: LD_INT 111
7284: PPUSH
7285: LD_INT 9
7287: PPUSH
7288: LD_INT 0
7290: PPUSH
7291: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7295: LD_EXP 69
7299: PPUSH
7300: LD_INT 3
7302: PPUSH
7303: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7307: LD_EXP 64
7311: PPUSH
7312: LD_INT 126
7314: PPUSH
7315: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7319: LD_EXP 65
7323: PPUSH
7324: LD_INT 134
7326: PPUSH
7327: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7331: LD_EXP 67
7335: PPUSH
7336: LD_INT 197
7338: PPUSH
7339: LD_INT 111
7341: PPUSH
7342: LD_INT 9
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7352: LD_EXP 66
7356: PPUSH
7357: LD_INT 197
7359: PPUSH
7360: LD_INT 111
7362: PPUSH
7363: LD_INT 9
7365: PPUSH
7366: LD_INT 0
7368: PPUSH
7369: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7373: LD_EXP 68
7377: PPUSH
7378: LD_INT 197
7380: PPUSH
7381: LD_INT 111
7383: PPUSH
7384: LD_INT 9
7386: PPUSH
7387: LD_INT 0
7389: PPUSH
7390: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7394: LD_ADDR_VAR 0 5
7398: PUSH
7399: LD_INT 126
7401: PPUSH
7402: LD_INT 4
7404: PPUSH
7405: LD_STRING zhukov
7407: PPUSH
7408: LD_INT 9
7410: PUSH
7411: LD_INT 10
7413: PUSH
7414: LD_INT 10
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: LD_INT 90000
7434: PUSH
7435: LD_INT 1000
7437: PUSH
7438: LD_INT 300
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PPUSH
7446: LD_INT 18
7448: PUSH
7449: LD_INT 8
7451: PUSH
7452: LD_INT 13
7454: PUSH
7455: LD_INT 8
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL 74195 0 6
7468: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7469: LD_ADDR_VAR 0 4
7473: PUSH
7474: LD_INT 267
7476: PPUSH
7477: CALL_OW 274
7481: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 5000
7492: PPUSH
7493: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7497: LD_VAR 0 4
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: LD_INT 200
7507: PPUSH
7508: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7512: LD_VAR 0 4
7516: PPUSH
7517: LD_INT 3
7519: PPUSH
7520: LD_INT 200
7522: PPUSH
7523: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7527: LD_ADDR_EXP 116
7531: PUSH
7532: LD_EXP 116
7536: PPUSH
7537: LD_INT 2
7539: PPUSH
7540: LD_VAR 0 5
7544: PUSH
7545: LD_INT 22
7547: PUSH
7548: LD_VAR 0 6
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 3
7559: PUSH
7560: LD_INT 21
7562: PUSH
7563: LD_INT 2
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PPUSH
7578: CALL_OW 69
7582: UNION
7583: PUSH
7584: LD_EXP 64
7588: DIFF
7589: PPUSH
7590: CALL_OW 1
7594: ST_TO_ADDR
// behemoths := [ ] ;
7595: LD_ADDR_EXP 72
7599: PUSH
7600: EMPTY
7601: ST_TO_ADDR
// behemothBuilders := [ ] ;
7602: LD_ADDR_EXP 73
7606: PUSH
7607: EMPTY
7608: ST_TO_ADDR
// if Kovalyuk then
7609: LD_EXP 65
7613: IFFALSE 7635
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7615: LD_ADDR_EXP 73
7619: PUSH
7620: LD_EXP 73
7624: PPUSH
7625: LD_EXP 65
7629: PPUSH
7630: CALL 102622 0 2
7634: ST_TO_ADDR
// j := 3 ;
7635: LD_ADDR_VAR 0 3
7639: PUSH
7640: LD_INT 3
7642: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7643: LD_ADDR_VAR 0 2
7647: PUSH
7648: LD_INT 22
7650: PUSH
7651: LD_INT 3
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 3
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: PUSH
7677: LD_EXP 65
7681: DIFF
7682: PUSH
7683: FOR_IN
7684: IFFALSE 7734
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7686: LD_ADDR_EXP 73
7690: PUSH
7691: LD_EXP 73
7695: PPUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: CALL 102622 0 2
7705: ST_TO_ADDR
// j := j - 1 ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: MINUS
7719: ST_TO_ADDR
// if j = 0 then
7720: LD_VAR 0 3
7724: PUSH
7725: LD_INT 0
7727: EQUAL
7728: IFFALSE 7732
// break ;
7730: GO 7734
// end ;
7732: GO 7683
7734: POP
7735: POP
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7741: LD_INT 0
7743: PPUSH
7744: PPUSH
7745: PPUSH
7746: PPUSH
7747: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7748: LD_ADDR_VAR 0 4
7752: PUSH
7753: LD_INT 209
7755: PUSH
7756: LD_INT 149
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 219
7765: PUSH
7766: LD_INT 154
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: LD_INT 223
7775: PUSH
7776: LD_INT 149
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: LD_INT 232
7785: PUSH
7786: LD_INT 155
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: ST_TO_ADDR
// if not behemothBuilders then
7799: LD_EXP 73
7803: NOT
7804: IFFALSE 7808
// exit ;
7806: GO 7912
// j := 1 ;
7808: LD_ADDR_VAR 0 3
7812: PUSH
7813: LD_INT 1
7815: ST_TO_ADDR
// for i in behemothBuilders do
7816: LD_ADDR_VAR 0 2
7820: PUSH
7821: LD_EXP 73
7825: PUSH
7826: FOR_IN
7827: IFFALSE 7910
// begin if IsInUnit ( i ) then
7829: LD_VAR 0 2
7833: PPUSH
7834: CALL_OW 310
7838: IFFALSE 7849
// ComExitBuilding ( i ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7849: LD_VAR 0 2
7853: PPUSH
7854: LD_INT 37
7856: PPUSH
7857: LD_VAR 0 4
7861: PUSH
7862: LD_VAR 0 3
7866: ARRAY
7867: PUSH
7868: LD_INT 1
7870: ARRAY
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_VAR 0 3
7881: ARRAY
7882: PUSH
7883: LD_INT 2
7885: ARRAY
7886: PPUSH
7887: LD_INT 0
7889: PPUSH
7890: CALL_OW 230
// j := j + 1 ;
7894: LD_ADDR_VAR 0 3
7898: PUSH
7899: LD_VAR 0 3
7903: PUSH
7904: LD_INT 1
7906: PLUS
7907: ST_TO_ADDR
// end ;
7908: GO 7826
7910: POP
7911: POP
// end ;
7912: LD_VAR 0 1
7916: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7917: LD_INT 24
7919: PPUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 37
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 70
7934: IFFALSE 7947
7936: GO 7938
7938: DISABLE
// behemothUnderConstruct := true ;
7939: LD_ADDR_EXP 26
7943: PUSH
7944: LD_INT 1
7946: ST_TO_ADDR
7947: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7948: LD_INT 3
7950: PPUSH
7951: CALL 102683 0 1
7955: PUSH
7956: LD_INT 22
7958: PUSH
7959: LD_INT 3
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PUSH
7966: LD_INT 30
7968: PUSH
7969: LD_INT 37
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PPUSH
7980: CALL_OW 69
7984: NOT
7985: AND
7986: IFFALSE 8172
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: PPUSH
8004: CALL 102683 0 1
8008: ST_TO_ADDR
// for i in tmp do
8009: LD_ADDR_VAR 0 1
8013: PUSH
8014: LD_VAR 0 2
8018: PUSH
8019: FOR_IN
8020: IFFALSE 8170
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8022: LD_VAR 0 1
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL_OW 308
8034: PUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: CALL_OW 110
8044: PUSH
8045: LD_INT 2
8047: EQUAL
8048: NOT
8049: AND
8050: IFFALSE 8064
// SetTag ( i , 2 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 2
8059: PPUSH
8060: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8064: LD_INT 81
8066: PUSH
8067: LD_INT 3
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 91
8076: PUSH
8077: LD_VAR 0 1
8081: PUSH
8082: LD_INT 12
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: LIST
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PPUSH
8094: CALL_OW 69
8098: NOT
8099: PUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 110
8109: PUSH
8110: LD_INT 2
8112: EQUAL
8113: NOT
8114: AND
8115: IFFALSE 8134
// ComAgressiveMove ( i , 64 , 93 ) else
8117: LD_VAR 0 1
8121: PPUSH
8122: LD_INT 64
8124: PPUSH
8125: LD_INT 93
8127: PPUSH
8128: CALL_OW 114
8132: GO 8168
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8134: LD_VAR 0 1
8138: PPUSH
8139: LD_INT 81
8141: PUSH
8142: LD_INT 3
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 69
8153: PPUSH
8154: LD_VAR 0 1
8158: PPUSH
8159: CALL_OW 74
8163: PPUSH
8164: CALL_OW 115
// end ;
8168: GO 8019
8170: POP
8171: POP
// end ;
8172: PPOPN 2
8174: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8175: LD_INT 0
8177: PPUSH
8178: PPUSH
8179: PPUSH
// result := [ ] ;
8180: LD_ADDR_VAR 0 2
8184: PUSH
8185: EMPTY
8186: ST_TO_ADDR
// uc_side := 6 ;
8187: LD_ADDR_OWVAR 20
8191: PUSH
8192: LD_INT 6
8194: ST_TO_ADDR
// uc_nation := 3 ;
8195: LD_ADDR_OWVAR 21
8199: PUSH
8200: LD_INT 3
8202: ST_TO_ADDR
// case strength of 1 :
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: DOUBLE
8211: EQUAL
8212: IFTRUE 8216
8214: GO 8358
8216: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8217: LD_ADDR_VAR 0 3
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_INT 4
8229: PUSH
8230: LD_INT 5
8232: PUSH
8233: LD_INT 6
8235: PUSH
8236: LD_INT 7
8238: PUSH
8239: EMPTY
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: PUSH
8245: LD_OWVAR 67
8249: ARRAY
8250: PUSH
8251: FOR_TO
8252: IFFALSE 8354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8254: LD_INT 22
8256: PUSH
8257: LD_INT 24
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: LD_VAR 0 3
8268: PUSH
8269: LD_INT 2
8271: MOD
8272: PUSH
8273: LD_INT 1
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: LD_INT 1
8280: PUSH
8281: LD_INT 3
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: LD_INT 2
8293: PPUSH
8294: CALL_OW 12
8298: ARRAY
8299: PPUSH
8300: LD_INT 3
8302: PPUSH
8303: LD_INT 43
8305: PUSH
8306: LD_INT 44
8308: PUSH
8309: LD_INT 45
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_INT 3
8322: PPUSH
8323: CALL_OW 12
8327: ARRAY
8328: PPUSH
8329: LD_INT 80
8331: PPUSH
8332: CALL 70749 0 5
// result := result union CreateVehicle ;
8336: LD_ADDR_VAR 0 2
8340: PUSH
8341: LD_VAR 0 2
8345: PUSH
8346: CALL_OW 45
8350: UNION
8351: ST_TO_ADDR
// end ;
8352: GO 8251
8354: POP
8355: POP
// end ; 2 :
8356: GO 9321
8358: LD_INT 2
8360: DOUBLE
8361: EQUAL
8362: IFTRUE 8366
8364: GO 8526
8366: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: DOUBLE
8373: LD_INT 1
8375: DEC
8376: ST_TO_ADDR
8377: LD_INT 5
8379: PUSH
8380: LD_INT 6
8382: PUSH
8383: LD_INT 7
8385: PUSH
8386: LD_INT 8
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: LD_OWVAR 67
8399: ARRAY
8400: PUSH
8401: FOR_TO
8402: IFFALSE 8522
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8404: LD_INT 22
8406: PUSH
8407: LD_INT 24
8409: PUSH
8410: LD_INT 24
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: LIST
8417: PUSH
8418: LD_VAR 0 3
8422: PUSH
8423: LD_INT 3
8425: MOD
8426: PUSH
8427: LD_INT 1
8429: PLUS
8430: ARRAY
8431: PPUSH
8432: LD_INT 1
8434: PUSH
8435: LD_INT 3
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: LD_INT 1
8444: PPUSH
8445: LD_INT 2
8447: PPUSH
8448: CALL_OW 12
8452: ARRAY
8453: PPUSH
8454: LD_INT 3
8456: PPUSH
8457: LD_INT 43
8459: PUSH
8460: LD_INT 44
8462: PUSH
8463: LD_INT 45
8465: PUSH
8466: LD_INT 44
8468: PUSH
8469: LD_INT 46
8471: PUSH
8472: LD_INT 46
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PUSH
8483: LD_VAR 0 3
8487: PUSH
8488: LD_INT 6
8490: MOD
8491: PUSH
8492: LD_INT 1
8494: PLUS
8495: ARRAY
8496: PPUSH
8497: LD_INT 80
8499: PPUSH
8500: CALL 70749 0 5
// result := result union CreateVehicle ;
8504: LD_ADDR_VAR 0 2
8508: PUSH
8509: LD_VAR 0 2
8513: PUSH
8514: CALL_OW 45
8518: UNION
8519: ST_TO_ADDR
// end ;
8520: GO 8401
8522: POP
8523: POP
// end ; 3 :
8524: GO 9321
8526: LD_INT 3
8528: DOUBLE
8529: EQUAL
8530: IFTRUE 8534
8532: GO 8694
8534: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 5
8547: PUSH
8548: LD_INT 7
8550: PUSH
8551: LD_INT 8
8553: PUSH
8554: LD_INT 9
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: PUSH
8563: LD_OWVAR 67
8567: ARRAY
8568: PUSH
8569: FOR_TO
8570: IFFALSE 8690
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8572: LD_INT 22
8574: PUSH
8575: LD_INT 24
8577: PUSH
8578: LD_INT 24
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 3
8593: MOD
8594: PUSH
8595: LD_INT 1
8597: PLUS
8598: ARRAY
8599: PPUSH
8600: LD_INT 1
8602: PUSH
8603: LD_INT 3
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 2
8615: PPUSH
8616: CALL_OW 12
8620: ARRAY
8621: PPUSH
8622: LD_INT 3
8624: PPUSH
8625: LD_INT 43
8627: PUSH
8628: LD_INT 47
8630: PUSH
8631: LD_INT 45
8633: PUSH
8634: LD_INT 45
8636: PUSH
8637: LD_INT 46
8639: PUSH
8640: LD_INT 46
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: PUSH
8651: LD_VAR 0 3
8655: PUSH
8656: LD_INT 6
8658: MOD
8659: PUSH
8660: LD_INT 1
8662: PLUS
8663: ARRAY
8664: PPUSH
8665: LD_INT 80
8667: PPUSH
8668: CALL 70749 0 5
// result := result union CreateVehicle ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_VAR 0 2
8681: PUSH
8682: CALL_OW 45
8686: UNION
8687: ST_TO_ADDR
// end ;
8688: GO 8569
8690: POP
8691: POP
// end ; 4 :
8692: GO 9321
8694: LD_INT 4
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 9320
8702: POP
// begin uc_nation := 3 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 3
8710: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8711: LD_ADDR_VAR 0 3
8715: PUSH
8716: DOUBLE
8717: LD_INT 1
8719: DEC
8720: ST_TO_ADDR
8721: LD_INT 6
8723: PUSH
8724: LD_INT 8
8726: PUSH
8727: LD_INT 9
8729: PUSH
8730: LD_INT 10
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: LD_OWVAR 67
8743: ARRAY
8744: PUSH
8745: FOR_TO
8746: IFFALSE 8866
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8748: LD_INT 22
8750: PUSH
8751: LD_INT 24
8753: PUSH
8754: LD_INT 24
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: LIST
8761: PUSH
8762: LD_VAR 0 3
8766: PUSH
8767: LD_INT 3
8769: MOD
8770: PUSH
8771: LD_INT 1
8773: PLUS
8774: ARRAY
8775: PPUSH
8776: LD_INT 1
8778: PUSH
8779: LD_INT 3
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: PUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 2
8791: PPUSH
8792: CALL_OW 12
8796: ARRAY
8797: PPUSH
8798: LD_INT 3
8800: PPUSH
8801: LD_INT 45
8803: PUSH
8804: LD_INT 47
8806: PUSH
8807: LD_INT 47
8809: PUSH
8810: LD_INT 45
8812: PUSH
8813: LD_INT 46
8815: PUSH
8816: LD_INT 46
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_VAR 0 3
8831: PUSH
8832: LD_INT 6
8834: MOD
8835: PUSH
8836: LD_INT 1
8838: PLUS
8839: ARRAY
8840: PPUSH
8841: LD_INT 80
8843: PPUSH
8844: CALL 70749 0 5
// result := result union CreateVehicle ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_VAR 0 2
8857: PUSH
8858: CALL_OW 45
8862: UNION
8863: ST_TO_ADDR
// end ;
8864: GO 8745
8866: POP
8867: POP
// if not KappaStatus then
8868: LD_EXP 2
8872: NOT
8873: IFFALSE 9108
// begin uc_nation := 1 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// for i = 1 to 3 do
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_INT 3
8895: PUSH
8896: FOR_TO
8897: IFFALSE 9033
// begin j := rand ( 0 , 1 ) ;
8899: LD_ADDR_VAR 0 4
8903: PUSH
8904: LD_INT 0
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 12
8914: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8915: LD_INT 3
8917: PUSH
8918: LD_INT 5
8920: PUSH
8921: LD_INT 5
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: CALL_OW 12
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_INT 9
8978: PUSH
8979: LD_INT 7
8981: PUSH
8982: LD_INT 6
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PUSH
8990: LD_VAR 0 4
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: PLUS
9006: ARRAY
9007: PPUSH
9008: LD_INT 85
9010: PPUSH
9011: CALL 70749 0 5
// result := result union CreateVehicle ;
9015: LD_ADDR_VAR 0 2
9019: PUSH
9020: LD_VAR 0 2
9024: PUSH
9025: CALL_OW 45
9029: UNION
9030: ST_TO_ADDR
// end ;
9031: GO 8896
9033: POP
9034: POP
// if vsevolodFirstAttack then
9035: LD_EXP 24
9039: IFFALSE 9106
// begin vsevolodFirstAttack := false ;
9041: LD_ADDR_EXP 24
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9049: LD_INT 5
9051: PPUSH
9052: LD_INT 3
9054: PPUSH
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 6
9060: PPUSH
9061: LD_INT 100
9063: PPUSH
9064: CALL 70749 0 5
// sewiVeh := CreateVehicle ;
9068: LD_ADDR_EXP 71
9072: PUSH
9073: CALL_OW 45
9077: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9078: LD_EXP 71
9082: PPUSH
9083: LD_INT 1
9085: PPUSH
9086: CALL_OW 242
// result := result union sewiVeh ;
9090: LD_ADDR_VAR 0 2
9094: PUSH
9095: LD_VAR 0 2
9099: PUSH
9100: LD_EXP 71
9104: UNION
9105: ST_TO_ADDR
// end ; end else
9106: GO 9318
// if vsevolodFirstAttack then
9108: LD_EXP 24
9112: IFFALSE 9318
// begin vsevolodFirstAttack := false ;
9114: LD_ADDR_EXP 24
9118: PUSH
9119: LD_INT 0
9121: ST_TO_ADDR
// uc_nation := 3 ;
9122: LD_ADDR_OWVAR 21
9126: PUSH
9127: LD_INT 3
9129: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9130: LD_ADDR_VAR 0 3
9134: PUSH
9135: DOUBLE
9136: LD_INT 1
9138: DEC
9139: ST_TO_ADDR
9140: LD_INT 2
9142: PUSH
9143: LD_OWVAR 67
9147: PLUS
9148: PUSH
9149: FOR_TO
9150: IFFALSE 9258
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9152: LD_INT 22
9154: PUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 24
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: PUSH
9166: LD_VAR 0 3
9170: PUSH
9171: LD_INT 3
9173: MOD
9174: PUSH
9175: LD_INT 1
9177: PLUS
9178: ARRAY
9179: PPUSH
9180: LD_INT 1
9182: PUSH
9183: LD_INT 3
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: LD_INT 1
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 12
9200: ARRAY
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 45
9207: PUSH
9208: LD_INT 47
9210: PUSH
9211: LD_INT 47
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: LIST
9218: PUSH
9219: LD_VAR 0 3
9223: PUSH
9224: LD_INT 3
9226: MOD
9227: PUSH
9228: LD_INT 1
9230: PLUS
9231: ARRAY
9232: PPUSH
9233: LD_INT 80
9235: PPUSH
9236: CALL 70749 0 5
// result := result union CreateVehicle ;
9240: LD_ADDR_VAR 0 2
9244: PUSH
9245: LD_VAR 0 2
9249: PUSH
9250: CALL_OW 45
9254: UNION
9255: ST_TO_ADDR
// end ;
9256: GO 9149
9258: POP
9259: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9260: LD_INT 24
9262: PPUSH
9263: LD_INT 3
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: LD_INT 47
9271: PPUSH
9272: LD_INT 100
9274: PPUSH
9275: CALL 70749 0 5
// sewiVeh := CreateVehicle ;
9279: LD_ADDR_EXP 71
9283: PUSH
9284: CALL_OW 45
9288: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9289: LD_EXP 71
9293: PPUSH
9294: LD_INT 6
9296: NEG
9297: PPUSH
9298: CALL_OW 242
// result := result union sewiVeh ;
9302: LD_ADDR_VAR 0 2
9306: PUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_EXP 71
9316: UNION
9317: ST_TO_ADDR
// end ; end ; end ;
9318: GO 9321
9320: POP
// end ;
9321: LD_VAR 0 2
9325: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9326: LD_EXP 16
9330: IFFALSE 10175
9332: GO 9334
9334: DISABLE
9335: LD_INT 0
9337: PPUSH
9338: PPUSH
9339: PPUSH
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9343: LD_ADDR_VAR 0 4
9347: PUSH
9348: LD_INT 11
9350: PUSH
9351: LD_INT 12
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_INT 11550
9365: PUSH
9366: LD_INT 10150
9368: PUSH
9369: LD_INT 9800
9371: PUSH
9372: LD_INT 9450
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: PUSH
9381: LD_OWVAR 67
9385: ARRAY
9386: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9387: LD_ADDR_VAR 0 6
9391: PUSH
9392: LD_INT 70
9394: PUSH
9395: LD_INT 118
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 78
9404: PUSH
9405: LD_INT 31
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// repeat if missionStage = 2 then
9416: LD_EXP 15
9420: PUSH
9421: LD_INT 2
9423: EQUAL
9424: IFFALSE 9435
// wait ( 1 1$30 ) else
9426: LD_INT 3150
9428: PPUSH
9429: CALL_OW 67
9433: GO 9444
// wait ( time ) ;
9435: LD_VAR 0 3
9439: PPUSH
9440: CALL_OW 67
// if missionStage = 6 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 6
9451: EQUAL
9452: IFFALSE 9480
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9454: LD_INT 51
9456: PPUSH
9457: LD_INT 6
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9467: LD_INT 57
9469: PPUSH
9470: LD_INT 6
9472: PPUSH
9473: LD_INT 2
9475: PPUSH
9476: CALL_OW 322
// end ; if missionStage = 8 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 8
9487: EQUAL
9488: IFFALSE 9516
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9490: LD_INT 52
9492: PPUSH
9493: LD_INT 6
9495: PPUSH
9496: LD_INT 2
9498: PPUSH
9499: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9503: LD_INT 58
9505: PPUSH
9506: LD_INT 6
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9516: LD_EXP 15
9520: PUSH
9521: LD_INT 10
9523: EQUAL
9524: PUSH
9525: LD_OWVAR 67
9529: PUSH
9530: LD_INT 1
9532: GREATER
9533: AND
9534: IFFALSE 9562
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9536: LD_INT 53
9538: PPUSH
9539: LD_INT 6
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9549: LD_INT 59
9551: PPUSH
9552: LD_INT 6
9554: PPUSH
9555: LD_INT 2
9557: PPUSH
9558: CALL_OW 322
// end ; if activeAttacks then
9562: LD_EXP 16
9566: IFFALSE 10169
// begin if missionStage = 2 then
9568: LD_EXP 15
9572: PUSH
9573: LD_INT 2
9575: EQUAL
9576: IFFALSE 9586
// strength := 1 ;
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_INT 1
9585: ST_TO_ADDR
// if missionStage > 2 then
9586: LD_EXP 15
9590: PUSH
9591: LD_INT 2
9593: GREATER
9594: IFFALSE 9604
// strength := 2 ;
9596: LD_ADDR_VAR 0 5
9600: PUSH
9601: LD_INT 2
9603: ST_TO_ADDR
// if missionStage > 6 then
9604: LD_EXP 15
9608: PUSH
9609: LD_INT 6
9611: GREATER
9612: IFFALSE 9622
// strength := 3 ;
9614: LD_ADDR_VAR 0 5
9618: PUSH
9619: LD_INT 3
9621: ST_TO_ADDR
// if missionStage > 10 then
9622: LD_EXP 15
9626: PUSH
9627: LD_INT 10
9629: GREATER
9630: IFFALSE 9640
// strength := 4 ;
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: LD_INT 4
9639: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9640: LD_ADDR_VAR 0 2
9644: PUSH
9645: LD_VAR 0 5
9649: PPUSH
9650: CALL 8175 0 1
9654: ST_TO_ADDR
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9849
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9668: LD_VAR 0 1
9672: PPUSH
9673: LD_VAR 0 4
9677: PUSH
9678: LD_INT 1
9680: PPUSH
9681: LD_INT 2
9683: PPUSH
9684: CALL_OW 12
9688: ARRAY
9689: PPUSH
9690: LD_INT 0
9692: PPUSH
9693: CALL_OW 49
// if i = sewiVeh then
9697: LD_VAR 0 1
9701: PUSH
9702: LD_EXP 71
9706: EQUAL
9707: IFFALSE 9744
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9709: LD_ADDR_EXP 70
9713: PUSH
9714: LD_STRING Vsevolod
9716: PPUSH
9717: LD_INT 0
9719: PPUSH
9720: LD_STRING 
9722: PPUSH
9723: CALL 65885 0 3
9727: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9728: LD_EXP 70
9732: PPUSH
9733: LD_VAR 0 1
9737: PPUSH
9738: CALL_OW 52
// end else
9742: GO 9825
// if GetControl ( i ) = control_manual then
9744: LD_VAR 0 1
9748: PPUSH
9749: CALL_OW 263
9753: PUSH
9754: LD_INT 1
9756: EQUAL
9757: IFFALSE 9825
// begin uc_side := 6 ;
9759: LD_ADDR_OWVAR 20
9763: PUSH
9764: LD_INT 6
9766: ST_TO_ADDR
// uc_nation := 3 ;
9767: LD_ADDR_OWVAR 21
9771: PUSH
9772: LD_INT 3
9774: ST_TO_ADDR
// hc_gallery :=  ;
9775: LD_ADDR_OWVAR 33
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// hc_name :=  ;
9783: LD_ADDR_OWVAR 26
9787: PUSH
9788: LD_STRING 
9790: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9791: LD_INT 0
9793: PPUSH
9794: LD_INT 3
9796: PPUSH
9797: LD_INT 10
9799: PPUSH
9800: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9804: CALL_OW 44
9808: PPUSH
9809: LD_VAR 0 1
9813: PPUSH
9814: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9818: LD_INT 10
9820: PPUSH
9821: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_INT 111
9832: PPUSH
9833: LD_INT 197
9835: PPUSH
9836: CALL_OW 111
// wait ( 0 0$2 ) ;
9840: LD_INT 70
9842: PPUSH
9843: CALL_OW 67
// end ;
9847: GO 9665
9849: POP
9850: POP
// repeat wait ( 0 0$1 ) ;
9851: LD_INT 35
9853: PPUSH
9854: CALL_OW 67
// for i in tmp do
9858: LD_ADDR_VAR 0 1
9862: PUSH
9863: LD_VAR 0 2
9867: PUSH
9868: FOR_IN
9869: IFFALSE 10150
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9871: LD_INT 81
9873: PUSH
9874: LD_INT 6
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: LD_INT 91
9883: PUSH
9884: LD_VAR 0 1
9888: PUSH
9889: LD_INT 12
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL_OW 69
9905: IFFALSE 9963
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PUSH
9922: LD_INT 91
9924: PUSH
9925: LD_VAR 0 1
9929: PUSH
9930: LD_INT 12
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 69
9946: PPUSH
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL_OW 74
9956: PPUSH
9957: CALL_OW 115
9961: GO 10148
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9963: LD_INT 9
9965: PPUSH
9966: LD_INT 81
9968: PUSH
9969: LD_INT 6
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PPUSH
9976: CALL_OW 70
9980: IFFALSE 10114
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ARRAY
9995: PUSH
9996: LD_INT 1
9998: ARRAY
9999: PPUSH
10000: LD_VAR 0 6
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PUSH
10009: LD_INT 2
10011: ARRAY
10012: PPUSH
10013: CALL_OW 297
10017: PUSH
10018: LD_INT 10
10020: GREATER
10021: PUSH
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_INT 9
10029: PPUSH
10030: CALL_OW 308
10034: NOT
10035: AND
10036: IFFALSE 10075
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10038: LD_VAR 0 1
10042: PPUSH
10043: LD_VAR 0 6
10047: PUSH
10048: LD_INT 1
10050: ARRAY
10051: PUSH
10052: LD_INT 1
10054: ARRAY
10055: PPUSH
10056: LD_VAR 0 6
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PUSH
10065: LD_INT 2
10067: ARRAY
10068: PPUSH
10069: CALL_OW 114
10073: GO 10112
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10075: LD_VAR 0 1
10079: PPUSH
10080: LD_INT 9
10082: PPUSH
10083: LD_INT 81
10085: PUSH
10086: LD_INT 6
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PPUSH
10093: CALL_OW 70
10097: PPUSH
10098: LD_VAR 0 1
10102: PPUSH
10103: CALL_OW 74
10107: PPUSH
10108: CALL_OW 115
// end else
10112: GO 10148
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: LD_INT 81
10121: PUSH
10122: LD_INT 6
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PPUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: CALL_OW 74
10143: PPUSH
10144: CALL_OW 115
// end ;
10148: GO 9868
10150: POP
10151: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10152: LD_INT 22
10154: PUSH
10155: LD_INT 6
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: NOT
10167: IFFALSE 9851
// end ; until russianDestroyed ;
10169: LD_EXP 21
10173: IFFALSE 9416
// end ;
10175: PPOPN 6
10177: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10178: LD_EXP 21
10182: NOT
10183: PUSH
10184: LD_EXP 15
10188: PUSH
10189: LD_INT 6
10191: GREATEREQUAL
10192: AND
10193: PUSH
10194: LD_INT 2
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: CALL 60897 0 2
10204: NOT
10205: AND
10206: IFFALSE 11166
10208: GO 10210
10210: DISABLE
10211: LD_INT 0
10213: PPUSH
10214: PPUSH
10215: PPUSH
10216: PPUSH
// begin enable ;
10217: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10218: LD_INT 22
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 30
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: NOT
10247: IFFALSE 10251
// exit ;
10249: GO 11166
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10251: LD_ADDR_VAR 0 4
10255: PUSH
10256: LD_INT 22
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: LD_INT 30
10268: PUSH
10269: LD_INT 34
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PPUSH
10280: CALL_OW 69
10284: ST_TO_ADDR
// if Prob ( 40 ) then
10285: LD_INT 40
10287: PPUSH
10288: CALL_OW 13
10292: IFFALSE 10419
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10294: LD_INT 2
10296: PPUSH
10297: LD_INT 22
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 49
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 22
10317: PUSH
10318: LD_INT 3
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 49
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_INT 3
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 49
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 24
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 46
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PUSH
10369: LD_INT 24
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 46
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 24
10389: PUSH
10390: LD_INT 3
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 46
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL 59479 0 2
// end else
10417: GO 10542
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10419: LD_INT 2
10421: PPUSH
10422: LD_INT 24
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 3
10430: PUSH
10431: LD_INT 47
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 24
10442: PUSH
10443: LD_INT 3
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 47
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: PUSH
10458: LD_INT 24
10460: PUSH
10461: LD_INT 3
10463: PUSH
10464: LD_INT 3
10466: PUSH
10467: LD_INT 47
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: PUSH
10476: LD_INT 24
10478: PUSH
10479: LD_INT 3
10481: PUSH
10482: LD_INT 3
10484: PUSH
10485: LD_INT 46
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 24
10496: PUSH
10497: LD_INT 3
10499: PUSH
10500: LD_INT 3
10502: PUSH
10503: LD_INT 46
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 24
10514: PUSH
10515: LD_INT 3
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: LD_INT 46
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL 59479 0 2
// end ; if Difficulty > 1 then
10542: LD_OWVAR 67
10546: PUSH
10547: LD_INT 1
10549: GREATER
10550: IFFALSE 10580
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10552: LD_INT 2
10554: PPUSH
10555: LD_INT 24
10557: PUSH
10558: LD_INT 3
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: LD_INT 47
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: PPUSH
10576: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
10580: LD_INT 35
10582: PPUSH
10583: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10587: LD_INT 2
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL 60897 0 2
10597: PUSH
10598: LD_INT 6
10600: PUSH
10601: LD_INT 7
10603: PUSH
10604: LD_INT 7
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_OWVAR 67
10620: ARRAY
10621: GREATEREQUAL
10622: IFFALSE 10580
// wait ( 0 0$30 ) ;
10624: LD_INT 1050
10626: PPUSH
10627: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: LD_INT 2
10638: PPUSH
10639: LD_INT 1
10641: PPUSH
10642: CALL 60897 0 2
10646: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10647: LD_ADDR_EXP 135
10651: PUSH
10652: LD_EXP 135
10656: PPUSH
10657: LD_INT 2
10659: PPUSH
10660: LD_EXP 135
10664: PUSH
10665: LD_INT 2
10667: ARRAY
10668: PUSH
10669: LD_VAR 0 2
10673: DIFF
10674: PPUSH
10675: CALL_OW 1
10679: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: LD_INT 0
10687: PPUSH
10688: LD_INT 1
10690: PPUSH
10691: CALL_OW 12
10695: ST_TO_ADDR
// if target then
10696: LD_VAR 0 3
10700: IFFALSE 10828
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10702: LD_ADDR_VAR 0 2
10706: PUSH
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_INT 24
10714: PUSH
10715: LD_INT 250
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PPUSH
10722: CALL_OW 72
10726: ST_TO_ADDR
// for i in tmp do
10727: LD_ADDR_VAR 0 1
10731: PUSH
10732: LD_VAR 0 2
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10778
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_INT 139
10747: PPUSH
10748: LD_INT 89
10750: PPUSH
10751: CALL_OW 297
10755: PUSH
10756: LD_INT 9
10758: GREATER
10759: IFFALSE 10776
// ComMoveXY ( i , 139 , 89 ) ;
10761: LD_VAR 0 1
10765: PPUSH
10766: LD_INT 139
10768: PPUSH
10769: LD_INT 89
10771: PPUSH
10772: CALL_OW 111
10776: GO 10737
10778: POP
10779: POP
// wait ( 0 0$1 ) ;
10780: LD_INT 35
10782: PPUSH
10783: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10787: LD_VAR 0 2
10791: PPUSH
10792: LD_INT 92
10794: PUSH
10795: LD_INT 139
10797: PUSH
10798: LD_INT 89
10800: PUSH
10801: LD_INT 9
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PPUSH
10810: CALL_OW 72
10814: PUSH
10815: LD_VAR 0 2
10819: PUSH
10820: LD_INT 1
10822: MINUS
10823: GREATEREQUAL
10824: IFFALSE 10702
// end else
10826: GO 10970
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_VAR 0 4
10837: PUSH
10838: LD_INT 1
10840: ARRAY
10841: PPUSH
10842: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_VAR 0 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 250
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 72
10870: ST_TO_ADDR
// for i in tmp do
10871: LD_ADDR_VAR 0 1
10875: PUSH
10876: LD_VAR 0 2
10880: PUSH
10881: FOR_IN
10882: IFFALSE 10922
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10884: LD_VAR 0 1
10888: PPUSH
10889: LD_INT 124
10891: PPUSH
10892: LD_INT 139
10894: PPUSH
10895: CALL_OW 297
10899: PUSH
10900: LD_INT 9
10902: GREATER
10903: IFFALSE 10920
// ComMoveXY ( i , 124 , 139 ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: LD_INT 124
10912: PPUSH
10913: LD_INT 139
10915: PPUSH
10916: CALL_OW 111
10920: GO 10881
10922: POP
10923: POP
// wait ( 0 0$1 ) ;
10924: LD_INT 35
10926: PPUSH
10927: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10931: LD_VAR 0 2
10935: PPUSH
10936: LD_INT 92
10938: PUSH
10939: LD_INT 124
10941: PUSH
10942: LD_INT 139
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: PPUSH
10954: CALL_OW 72
10958: PUSH
10959: LD_VAR 0 2
10963: PUSH
10964: LD_INT 1
10966: MINUS
10967: GREATEREQUAL
10968: IFFALSE 10846
// end ; repeat wait ( 0 0$1 ) ;
10970: LD_INT 35
10972: PPUSH
10973: CALL_OW 67
// for i in tmp do
10977: LD_ADDR_VAR 0 1
10981: PUSH
10982: LD_VAR 0 2
10986: PUSH
10987: FOR_IN
10988: IFFALSE 11157
// begin if GetLives ( i ) > 251 then
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 256
10999: PUSH
11000: LD_INT 251
11002: GREATER
11003: IFFALSE 11128
// begin if GetWeapon ( i ) = ru_time_lapser then
11005: LD_VAR 0 1
11009: PPUSH
11010: CALL_OW 264
11014: PUSH
11015: LD_INT 49
11017: EQUAL
11018: IFFALSE 11074
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11020: LD_VAR 0 1
11024: PPUSH
11025: LD_INT 2
11027: PUSH
11028: LD_INT 22
11030: PUSH
11031: LD_INT 1
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 8
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: PPUSH
11058: LD_VAR 0 1
11062: PPUSH
11063: CALL_OW 74
11067: PPUSH
11068: CALL_OW 112
11072: GO 11126
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11074: LD_VAR 0 1
11078: PPUSH
11079: LD_INT 2
11081: PUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 1
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 8
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: PPUSH
11107: CALL_OW 69
11111: PPUSH
11112: LD_VAR 0 1
11116: PPUSH
11117: CALL_OW 74
11121: PPUSH
11122: CALL_OW 115
// end else
11126: GO 11155
// if IsDead ( i ) then
11128: LD_VAR 0 1
11132: PPUSH
11133: CALL_OW 301
11137: IFFALSE 11155
// tmp := tmp diff i ;
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_VAR 0 2
11148: PUSH
11149: LD_VAR 0 1
11153: DIFF
11154: ST_TO_ADDR
// end ;
11155: GO 10987
11157: POP
11158: POP
// until not tmp ;
11159: LD_VAR 0 2
11163: NOT
11164: IFFALSE 10970
// end ; end_of_file
11166: PPOPN 4
11168: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11169: LD_INT 0
11171: PPUSH
11172: PPUSH
11173: PPUSH
11174: PPUSH
11175: PPUSH
11176: PPUSH
// side := 7 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 7
11184: ST_TO_ADDR
// uc_side := side ;
11185: LD_ADDR_OWVAR 20
11189: PUSH
11190: LD_VAR 0 5
11194: ST_TO_ADDR
// uc_nation := 1 ;
11195: LD_ADDR_OWVAR 21
11199: PUSH
11200: LD_INT 1
11202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11203: LD_ADDR_VAR 0 2
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_VAR 0 5
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 21
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PPUSH
11234: CALL_OW 69
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11256
// SetBLevel ( i , 10 ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: LD_INT 10
11249: PPUSH
11250: CALL_OW 241
11254: GO 11239
11256: POP
11257: POP
// base := GetBase ( al_depot ) ;
11258: LD_ADDR_VAR 0 4
11262: PUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 274
11270: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11271: LD_ADDR_VAR 0 6
11275: PUSH
11276: LD_INT 22
11278: PUSH
11279: LD_VAR 0 5
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 30
11290: PUSH
11291: LD_INT 34
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PPUSH
11302: CALL_OW 69
11306: ST_TO_ADDR
// if teleport then
11307: LD_VAR 0 6
11311: IFFALSE 11332
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11313: LD_VAR 0 6
11317: PUSH
11318: LD_INT 1
11320: ARRAY
11321: PPUSH
11322: LD_INT 262
11324: PPUSH
11325: LD_INT 119
11327: PPUSH
11328: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11332: LD_VAR 0 4
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: LD_INT 19500
11342: PPUSH
11343: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11347: LD_VAR 0 4
11351: PPUSH
11352: LD_INT 2
11354: PPUSH
11355: LD_INT 200
11357: PPUSH
11358: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11362: LD_VAR 0 4
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 650
11372: PPUSH
11373: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11377: LD_ADDR_EXP 74
11381: PUSH
11382: LD_STRING Roth
11384: PPUSH
11385: CALL_OW 25
11389: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11390: LD_ADDR_EXP 75
11394: PUSH
11395: LD_STRING Simms
11397: PPUSH
11398: LD_EXP 1
11402: NOT
11403: PPUSH
11404: LD_STRING 10c_
11406: PPUSH
11407: CALL 65885 0 3
11411: ST_TO_ADDR
// if not Simms then
11412: LD_EXP 75
11416: NOT
11417: IFFALSE 11447
// begin uc_nation := 1 ;
11419: LD_ADDR_OWVAR 21
11423: PUSH
11424: LD_INT 1
11426: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11427: LD_INT 2
11429: PPUSH
11430: LD_INT 10
11432: PPUSH
11433: CALL_OW 384
// Simms := CreateHuman ;
11437: LD_ADDR_EXP 75
11441: PUSH
11442: CALL_OW 44
11446: ST_TO_ADDR
// end ; uc_nation := 3 ;
11447: LD_ADDR_OWVAR 21
11451: PUSH
11452: LD_INT 3
11454: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11455: LD_ADDR_EXP 76
11459: PUSH
11460: LD_STRING Kirilenkova
11462: PPUSH
11463: CALL_OW 25
11467: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11468: LD_ADDR_EXP 90
11472: PUSH
11473: LD_STRING Oblukov
11475: PPUSH
11476: CALL_OW 25
11480: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11481: LD_ADDR_EXP 77
11485: PUSH
11486: LD_STRING Dolgov
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11494: LD_ADDR_EXP 78
11498: PUSH
11499: LD_STRING Petrosyan
11501: PPUSH
11502: CALL_OW 25
11506: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11507: LD_ADDR_EXP 89
11511: PUSH
11512: LD_STRING Scholtze
11514: PPUSH
11515: CALL_OW 25
11519: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11520: LD_ADDR_EXP 88
11524: PUSH
11525: LD_STRING Kapitsova
11527: PPUSH
11528: CALL_OW 25
11532: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11533: LD_ADDR_EXP 79
11537: PUSH
11538: LD_STRING Petrovova
11540: PPUSH
11541: CALL_OW 25
11545: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11546: LD_ADDR_EXP 80
11550: PUSH
11551: LD_STRING Kuzmov
11553: PPUSH
11554: CALL_OW 25
11558: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11559: LD_ADDR_EXP 87
11563: PUSH
11564: LD_STRING Karamazov
11566: PPUSH
11567: CALL_OW 25
11571: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11572: LD_STRING 13_Lipshchin_1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 30
11582: IFFALSE 11597
// Lipshchin := NewCharacter ( Lipshchin ) ;
11584: LD_ADDR_EXP 81
11588: PUSH
11589: LD_STRING Lipshchin
11591: PPUSH
11592: CALL_OW 25
11596: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11597: LD_STRING 13_Titov_1
11599: PPUSH
11600: LD_INT 0
11602: PPUSH
11603: CALL_OW 30
11607: IFFALSE 11622
// Titov := NewCharacter ( Titov ) ;
11609: LD_ADDR_EXP 83
11613: PUSH
11614: LD_STRING Titov
11616: PPUSH
11617: CALL_OW 25
11621: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11622: LD_STRING 13_Gnyevko_1
11624: PPUSH
11625: LD_INT 0
11627: PPUSH
11628: CALL_OW 30
11632: IFFALSE 11647
// Gnyevko := NewCharacter ( Gnyevko ) ;
11634: LD_ADDR_EXP 82
11638: PUSH
11639: LD_STRING Gnyevko
11641: PPUSH
11642: CALL_OW 25
11646: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11647: LD_STRING 13_Xavier_1
11649: PPUSH
11650: LD_INT 0
11652: PPUSH
11653: CALL_OW 30
11657: IFFALSE 11672
// Xavier := NewCharacter ( Xavier2 ) ;
11659: LD_ADDR_EXP 84
11663: PUSH
11664: LD_STRING Xavier2
11666: PPUSH
11667: CALL_OW 25
11671: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11672: LD_STRING 13_Belkov_1
11674: PPUSH
11675: LD_INT 0
11677: PPUSH
11678: CALL_OW 30
11682: IFFALSE 11697
// Belkov := NewCharacter ( Belkov ) ;
11684: LD_ADDR_EXP 85
11688: PUSH
11689: LD_STRING Belkov
11691: PPUSH
11692: CALL_OW 25
11696: ST_TO_ADDR
// if not BurlakStatus then
11697: LD_EXP 9
11701: NOT
11702: IFFALSE 11717
// Burlak = NewCharacter ( Burlak ) ;
11704: LD_ADDR_EXP 86
11708: PUSH
11709: LD_STRING Burlak
11711: PPUSH
11712: CALL_OW 25
11716: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11717: LD_ADDR_VAR 0 3
11721: PUSH
11722: LD_EXP 74
11726: PUSH
11727: LD_EXP 76
11731: PUSH
11732: LD_EXP 90
11736: PUSH
11737: LD_EXP 77
11741: PUSH
11742: LD_EXP 78
11746: PUSH
11747: LD_EXP 89
11751: PUSH
11752: LD_EXP 88
11756: PUSH
11757: LD_EXP 79
11761: PUSH
11762: LD_EXP 80
11766: PUSH
11767: LD_EXP 87
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: ST_TO_ADDR
// if Simms then
11784: LD_EXP 75
11788: IFFALSE 11806
// tmp := tmp ^ Simms ;
11790: LD_ADDR_VAR 0 3
11794: PUSH
11795: LD_VAR 0 3
11799: PUSH
11800: LD_EXP 75
11804: ADD
11805: ST_TO_ADDR
// if Titov then
11806: LD_EXP 83
11810: IFFALSE 11828
// tmp := tmp ^ Titov ;
11812: LD_ADDR_VAR 0 3
11816: PUSH
11817: LD_VAR 0 3
11821: PUSH
11822: LD_EXP 83
11826: ADD
11827: ST_TO_ADDR
// if Lipshchin then
11828: LD_EXP 81
11832: IFFALSE 11850
// tmp := tmp ^ Lipshchin ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_VAR 0 3
11843: PUSH
11844: LD_EXP 81
11848: ADD
11849: ST_TO_ADDR
// if Gnyevko then
11850: LD_EXP 82
11854: IFFALSE 11872
// tmp := tmp ^ Gnyevko ;
11856: LD_ADDR_VAR 0 3
11860: PUSH
11861: LD_VAR 0 3
11865: PUSH
11866: LD_EXP 82
11870: ADD
11871: ST_TO_ADDR
// if Xavier then
11872: LD_EXP 84
11876: IFFALSE 11894
// tmp := tmp ^ Xavier ;
11878: LD_ADDR_VAR 0 3
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: LD_EXP 84
11892: ADD
11893: ST_TO_ADDR
// if Belkov then
11894: LD_EXP 85
11898: IFFALSE 11916
// tmp := tmp ^ Belkov ;
11900: LD_ADDR_VAR 0 3
11904: PUSH
11905: LD_VAR 0 3
11909: PUSH
11910: LD_EXP 85
11914: ADD
11915: ST_TO_ADDR
// if Burlak then
11916: LD_EXP 86
11920: IFFALSE 11938
// tmp := tmp ^ Burlak ;
11922: LD_ADDR_VAR 0 3
11926: PUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_EXP 86
11936: ADD
11937: ST_TO_ADDR
// for i = 1 to 11 do
11938: LD_ADDR_VAR 0 2
11942: PUSH
11943: DOUBLE
11944: LD_INT 1
11946: DEC
11947: ST_TO_ADDR
11948: LD_INT 11
11950: PUSH
11951: FOR_TO
11952: IFFALSE 12018
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11954: LD_ADDR_OWVAR 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: LD_INT 3
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 1
11971: PPUSH
11972: LD_INT 2
11974: PPUSH
11975: CALL_OW 12
11979: ARRAY
11980: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11981: LD_INT 0
11983: PPUSH
11984: LD_VAR 0 2
11988: PUSH
11989: LD_INT 2
11991: DIV
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12000: LD_ADDR_VAR 0 3
12004: PUSH
12005: LD_VAR 0 3
12009: PUSH
12010: CALL_OW 44
12014: ADD
12015: ST_TO_ADDR
// end ;
12016: GO 11951
12018: POP
12019: POP
// for i in tmp do
12020: LD_ADDR_VAR 0 2
12024: PUSH
12025: LD_VAR 0 3
12029: PUSH
12030: FOR_IN
12031: IFFALSE 12056
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12033: LD_VAR 0 2
12037: PPUSH
12038: LD_INT 260
12040: PPUSH
12041: LD_INT 235
12043: PPUSH
12044: LD_INT 8
12046: PPUSH
12047: LD_INT 0
12049: PPUSH
12050: CALL_OW 50
12054: GO 12030
12056: POP
12057: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12058: LD_ADDR_EXP 116
12062: PUSH
12063: LD_EXP 116
12067: PPUSH
12068: LD_INT 1
12070: PPUSH
12071: LD_INT 22
12073: PUSH
12074: LD_VAR 0 5
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 3
12085: PUSH
12086: LD_INT 21
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PPUSH
12104: CALL_OW 69
12108: PUSH
12109: LD_EXP 74
12113: PUSH
12114: LD_EXP 75
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: DIFF
12123: PPUSH
12124: CALL_OW 1
12128: ST_TO_ADDR
// uc_side := 0 ;
12129: LD_ADDR_OWVAR 20
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// uc_nation := 0 ;
12137: LD_ADDR_OWVAR 21
12141: PUSH
12142: LD_INT 0
12144: ST_TO_ADDR
// for i = 1 to 5 do
12145: LD_ADDR_VAR 0 2
12149: PUSH
12150: DOUBLE
12151: LD_INT 1
12153: DEC
12154: ST_TO_ADDR
12155: LD_INT 5
12157: PUSH
12158: FOR_TO
12159: IFFALSE 12196
// begin InitHc ;
12161: CALL_OW 19
// hc_class := class_apeman ;
12165: LD_ADDR_OWVAR 28
12169: PUSH
12170: LD_INT 12
12172: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12173: CALL_OW 44
12177: PPUSH
12178: LD_INT 299
12180: PPUSH
12181: LD_INT 229
12183: PPUSH
12184: LD_INT 10
12186: PPUSH
12187: LD_INT 0
12189: PPUSH
12190: CALL_OW 50
// end ;
12194: GO 12158
12196: POP
12197: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12198: LD_EXP 74
12202: PPUSH
12203: LD_INT 259
12205: PPUSH
12206: LD_INT 235
12208: PPUSH
12209: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12213: LD_EXP 74
12217: PPUSH
12218: LD_INT 262
12220: PPUSH
12221: LD_INT 235
12223: PPUSH
12224: CALL_OW 178
// if Simms then
12228: LD_EXP 75
12232: IFFALSE 12263
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12234: LD_EXP 75
12238: PPUSH
12239: LD_INT 262
12241: PPUSH
12242: LD_INT 235
12244: PPUSH
12245: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12249: LD_EXP 75
12253: PPUSH
12254: LD_EXP 74
12258: PPUSH
12259: CALL_OW 179
// end ; end ;
12263: LD_VAR 0 1
12267: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12268: LD_EXP 31
12272: PUSH
12273: LD_EXP 23
12277: NOT
12278: AND
12279: IFFALSE 12455
12281: GO 12283
12283: DISABLE
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
12288: PPUSH
// begin enable ;
12289: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12290: LD_ADDR_VAR 0 2
12294: PUSH
12295: LD_INT 81
12297: PUSH
12298: LD_INT 7
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 2
12307: PUSH
12308: LD_INT 32
12310: PUSH
12311: LD_INT 3
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 30
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 30
12330: PUSH
12331: LD_INT 28
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 34
12340: PUSH
12341: LD_INT 49
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 34
12350: PUSH
12351: LD_INT 10
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 34
12360: PUSH
12361: LD_INT 8
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: ST_TO_ADDR
// if not tmp then
12386: LD_VAR 0 2
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12455
// target := tmp [ rand ( 1 , tmp ) ] ;
12395: LD_ADDR_VAR 0 3
12399: PUSH
12400: LD_VAR 0 2
12404: PUSH
12405: LD_INT 1
12407: PPUSH
12408: LD_VAR 0 2
12412: PPUSH
12413: CALL_OW 12
12417: ARRAY
12418: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12419: LD_VAR 0 3
12423: PPUSH
12424: CALL_OW 255
12428: PUSH
12429: LD_INT 1
12431: EQUAL
12432: IFFALSE 12443
// CenterNowOnUnits ( target ) ;
12434: LD_VAR 0 3
12438: PPUSH
12439: CALL_OW 87
// SetLives ( target , 0 ) ;
12443: LD_VAR 0 3
12447: PPUSH
12448: LD_INT 0
12450: PPUSH
12451: CALL_OW 234
// end ;
12455: PPOPN 3
12457: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12458: LD_EXP 23
12462: NOT
12463: PUSH
12464: LD_EXP 31
12468: AND
12469: IFFALSE 12995
12471: GO 12473
12473: DISABLE
12474: LD_INT 0
12476: PPUSH
12477: PPUSH
12478: PPUSH
// begin uc_side := 7 ;
12479: LD_ADDR_OWVAR 20
12483: PUSH
12484: LD_INT 7
12486: ST_TO_ADDR
// uc_nation := 1 ;
12487: LD_ADDR_OWVAR 21
12491: PUSH
12492: LD_INT 1
12494: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12495: LD_ADDR_VAR 0 3
12499: PUSH
12500: LD_INT 125
12502: PUSH
12503: LD_INT 163
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: LD_INT 185
12512: PUSH
12513: LD_INT 168
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 111
12522: PUSH
12523: LD_INT 97
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL 102727 0 1
12539: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12540: LD_ADDR_EXP 91
12544: PUSH
12545: EMPTY
12546: ST_TO_ADDR
// for i = 1 to Difficulty do
12547: LD_ADDR_VAR 0 1
12551: PUSH
12552: DOUBLE
12553: LD_INT 1
12555: DEC
12556: ST_TO_ADDR
12557: LD_OWVAR 67
12561: PUSH
12562: FOR_TO
12563: IFFALSE 12721
// begin InitHc ;
12565: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12569: LD_INT 0
12571: PPUSH
12572: LD_INT 8
12574: PPUSH
12575: CALL_OW 381
// un := CreateHuman ;
12579: LD_ADDR_VAR 0 2
12583: PUSH
12584: CALL_OW 44
12588: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12589: LD_VAR 0 2
12593: PPUSH
12594: LD_INT 258
12596: PPUSH
12597: LD_INT 267
12599: PPUSH
12600: LD_INT 4
12602: PPUSH
12603: LD_INT 0
12605: PPUSH
12606: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12610: LD_ADDR_EXP 91
12614: PUSH
12615: LD_EXP 91
12619: PUSH
12620: LD_VAR 0 2
12624: UNION
12625: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PUSH
12636: LD_VAR 0 1
12640: ARRAY
12641: PUSH
12642: LD_INT 1
12644: ARRAY
12645: PPUSH
12646: LD_VAR 0 3
12650: PUSH
12651: LD_VAR 0 1
12655: ARRAY
12656: PUSH
12657: LD_INT 2
12659: ARRAY
12660: PPUSH
12661: LD_INT 4
12663: PPUSH
12664: LD_INT 1
12666: PPUSH
12667: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12671: LD_VAR 0 2
12675: PPUSH
12676: LD_VAR 0 3
12680: PUSH
12681: LD_VAR 0 1
12685: ARRAY
12686: PUSH
12687: LD_INT 1
12689: ARRAY
12690: PPUSH
12691: LD_VAR 0 3
12695: PUSH
12696: LD_VAR 0 1
12700: ARRAY
12701: PUSH
12702: LD_INT 2
12704: ARRAY
12705: PPUSH
12706: CALL_OW 171
// AddComInvisible ( un ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: CALL_OW 212
// end ;
12719: GO 12562
12721: POP
12722: POP
// repeat wait ( 0 0$20 ) ;
12723: LD_INT 700
12725: PPUSH
12726: CALL_OW 67
// for i in allianceSpecialForce do
12730: LD_ADDR_VAR 0 1
12734: PUSH
12735: LD_EXP 91
12739: PUSH
12740: FOR_IN
12741: IFFALSE 12980
// begin if IsInvisible ( i ) then
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 571
12752: IFFALSE 12949
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12754: LD_ADDR_VAR 0 3
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_INT 1
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PUSH
12769: LD_INT 50
12771: PUSH
12772: EMPTY
12773: LIST
12774: PUSH
12775: LD_INT 56
12777: PUSH
12778: EMPTY
12779: LIST
12780: PUSH
12781: LD_INT 91
12783: PUSH
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 25
12791: PUSH
12792: LD_INT 30
12794: PUSH
12795: LD_INT 35
12797: PUSH
12798: LD_INT 40
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: PUSH
12807: LD_OWVAR 67
12811: ARRAY
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 2
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 1
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 25
12833: PUSH
12834: LD_INT 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 25
12843: PUSH
12844: LD_INT 3
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 25
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 25
12863: PUSH
12864: LD_INT 5
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 25
12873: PUSH
12874: LD_INT 8
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PPUSH
12897: CALL_OW 69
12901: ST_TO_ADDR
// if not tmp then
12902: LD_VAR 0 3
12906: NOT
12907: IFFALSE 12911
// continue ;
12909: GO 12740
// if Prob ( 30 * Difficulty ) then
12911: LD_INT 30
12913: PUSH
12914: LD_OWVAR 67
12918: MUL
12919: PPUSH
12920: CALL_OW 13
12924: IFFALSE 12949
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12926: LD_VAR 0 3
12930: PUSH
12931: LD_INT 1
12933: PPUSH
12934: LD_VAR 0 3
12938: PPUSH
12939: CALL_OW 12
12943: ARRAY
12944: PPUSH
12945: CALL 31278 0 1
// end ; if IsDead ( i ) then
12949: LD_VAR 0 1
12953: PPUSH
12954: CALL_OW 301
12958: IFFALSE 12978
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12960: LD_ADDR_EXP 91
12964: PUSH
12965: LD_EXP 91
12969: PUSH
12970: LD_VAR 0 1
12974: DIFF
12975: ST_TO_ADDR
// continue ;
12976: GO 12740
// end ; end ;
12978: GO 12740
12980: POP
12981: POP
// until allianceDestroyed or not allianceSpecialForce ;
12982: LD_EXP 23
12986: PUSH
12987: LD_EXP 91
12991: NOT
12992: OR
12993: IFFALSE 12723
// end ;
12995: PPOPN 3
12997: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12998: LD_EXP 23
13002: NOT
13003: PUSH
13004: LD_EXP 31
13008: AND
13009: IFFALSE 13980
13011: GO 13013
13013: DISABLE
13014: LD_INT 0
13016: PPUSH
13017: PPUSH
13018: PPUSH
13019: PPUSH
// begin enable ;
13020: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13021: LD_INT 22
13023: PUSH
13024: LD_INT 7
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PUSH
13031: LD_INT 30
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 69
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13980
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13054: LD_ADDR_VAR 0 4
13058: PUSH
13059: LD_INT 22
13061: PUSH
13062: LD_INT 7
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 34
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PPUSH
13083: CALL_OW 69
13087: ST_TO_ADDR
// if Prob ( 40 ) then
13088: LD_INT 40
13090: PPUSH
13091: CALL_OW 13
13095: IFFALSE 13222
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13097: LD_INT 1
13099: PPUSH
13100: LD_INT 5
13102: PUSH
13103: LD_INT 3
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: LD_INT 6
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 3
13123: PUSH
13124: LD_INT 2
13126: PUSH
13127: LD_INT 6
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 5
13138: PUSH
13139: LD_INT 3
13141: PUSH
13142: LD_INT 2
13144: PUSH
13145: LD_INT 6
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: PUSH
13154: LD_INT 24
13156: PUSH
13157: LD_INT 3
13159: PUSH
13160: LD_INT 3
13162: PUSH
13163: LD_INT 45
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 24
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: LD_INT 3
13180: PUSH
13181: LD_INT 47
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: LD_INT 24
13192: PUSH
13193: LD_INT 3
13195: PUSH
13196: LD_INT 3
13198: PUSH
13199: LD_INT 45
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: PPUSH
13216: CALL 59479 0 2
// end else
13220: GO 13345
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13222: LD_INT 1
13224: PPUSH
13225: LD_INT 24
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 3
13233: PUSH
13234: LD_INT 47
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 24
13245: PUSH
13246: LD_INT 3
13248: PUSH
13249: LD_INT 3
13251: PUSH
13252: LD_INT 47
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: PUSH
13261: LD_INT 5
13263: PUSH
13264: LD_INT 3
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: LD_INT 3
13284: PUSH
13285: LD_INT 2
13287: PUSH
13288: LD_INT 9
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: LD_INT 1
13302: PUSH
13303: LD_INT 3
13305: PUSH
13306: LD_INT 45
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: LD_INT 24
13317: PUSH
13318: LD_INT 1
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: LD_INT 45
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL 59479 0 2
// end ; if Difficulty > 1 then
13345: LD_OWVAR 67
13349: PUSH
13350: LD_INT 1
13352: GREATER
13353: IFFALSE 13383
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13355: LD_INT 1
13357: PPUSH
13358: LD_INT 24
13360: PUSH
13361: LD_INT 3
13363: PUSH
13364: LD_INT 3
13366: PUSH
13367: LD_INT 47
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: PUSH
13376: EMPTY
13377: LIST
13378: PPUSH
13379: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
13383: LD_INT 35
13385: PPUSH
13386: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13390: LD_INT 1
13392: PPUSH
13393: LD_INT 1
13395: PPUSH
13396: CALL 60897 0 2
13400: PUSH
13401: LD_INT 6
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: LD_INT 7
13409: PUSH
13410: LD_INT 7
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: PUSH
13419: LD_OWVAR 67
13423: ARRAY
13424: GREATEREQUAL
13425: IFFALSE 13383
// wait ( 0 0$40 ) ;
13427: LD_INT 1400
13429: PPUSH
13430: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_INT 1
13444: PPUSH
13445: CALL 60897 0 2
13449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13450: LD_ADDR_EXP 135
13454: PUSH
13455: LD_EXP 135
13459: PPUSH
13460: LD_INT 1
13462: PPUSH
13463: LD_EXP 135
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: PUSH
13472: LD_VAR 0 2
13476: DIFF
13477: PPUSH
13478: CALL_OW 1
13482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13483: LD_ADDR_VAR 0 3
13487: PUSH
13488: LD_INT 0
13490: PPUSH
13491: LD_INT 1
13493: PPUSH
13494: CALL_OW 12
13498: ST_TO_ADDR
// if target then
13499: LD_VAR 0 3
13503: IFFALSE 13669
// begin for i in tmp do
13505: LD_ADDR_VAR 0 1
13509: PUSH
13510: LD_VAR 0 2
13514: PUSH
13515: FOR_IN
13516: IFFALSE 13541
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13518: LD_VAR 0 1
13522: PPUSH
13523: LD_INT 179
13525: PPUSH
13526: LD_INT 209
13528: PPUSH
13529: LD_INT 8
13531: PPUSH
13532: LD_INT 1
13534: PPUSH
13535: CALL_OW 483
13539: GO 13515
13541: POP
13542: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13543: LD_ADDR_VAR 0 2
13547: PUSH
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 24
13555: PUSH
13556: LD_INT 250
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PPUSH
13563: CALL_OW 72
13567: ST_TO_ADDR
// for i in tmp do
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13619
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13581: LD_VAR 0 1
13585: PPUSH
13586: LD_INT 179
13588: PPUSH
13589: LD_INT 209
13591: PPUSH
13592: CALL_OW 297
13596: PUSH
13597: LD_INT 9
13599: GREATER
13600: IFFALSE 13617
// ComMoveXY ( i , 179 , 209 ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 179
13609: PPUSH
13610: LD_INT 209
13612: PPUSH
13613: CALL_OW 111
13617: GO 13578
13619: POP
13620: POP
// wait ( 0 0$1 ) ;
13621: LD_INT 35
13623: PPUSH
13624: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: LD_INT 92
13635: PUSH
13636: LD_INT 179
13638: PUSH
13639: LD_INT 209
13641: PUSH
13642: LD_INT 9
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PPUSH
13651: CALL_OW 72
13655: PUSH
13656: LD_VAR 0 2
13660: PUSH
13661: LD_INT 1
13663: MINUS
13664: GREATEREQUAL
13665: IFFALSE 13543
// end else
13667: GO 13831
// begin for i in tmp do
13669: LD_ADDR_VAR 0 1
13673: PUSH
13674: LD_VAR 0 2
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13705
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 285
13689: PPUSH
13690: LD_INT 163
13692: PPUSH
13693: LD_INT 8
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: CALL_OW 483
13703: GO 13679
13705: POP
13706: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 24
13719: PUSH
13720: LD_INT 250
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 72
13731: ST_TO_ADDR
// for i in tmp do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_VAR 0 2
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13783
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13745: LD_VAR 0 1
13749: PPUSH
13750: LD_INT 285
13752: PPUSH
13753: LD_INT 163
13755: PPUSH
13756: CALL_OW 297
13760: PUSH
13761: LD_INT 9
13763: GREATER
13764: IFFALSE 13781
// ComMoveXY ( i , 285 , 163 ) ;
13766: LD_VAR 0 1
13770: PPUSH
13771: LD_INT 285
13773: PPUSH
13774: LD_INT 163
13776: PPUSH
13777: CALL_OW 111
13781: GO 13742
13783: POP
13784: POP
// wait ( 0 0$1 ) ;
13785: LD_INT 35
13787: PPUSH
13788: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13792: LD_VAR 0 2
13796: PPUSH
13797: LD_INT 92
13799: PUSH
13800: LD_INT 285
13802: PUSH
13803: LD_INT 163
13805: PUSH
13806: LD_INT 9
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 72
13819: PUSH
13820: LD_VAR 0 2
13824: PUSH
13825: LD_INT 1
13827: MINUS
13828: GREATEREQUAL
13829: IFFALSE 13707
// end ; repeat wait ( 0 0$1 ) ;
13831: LD_INT 35
13833: PPUSH
13834: CALL_OW 67
// for i in tmp do
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_VAR 0 2
13847: PUSH
13848: FOR_IN
13849: IFFALSE 13971
// if GetLives ( i ) > 251 then
13851: LD_VAR 0 1
13855: PPUSH
13856: CALL_OW 256
13860: PUSH
13861: LD_INT 251
13863: GREATER
13864: IFFALSE 13953
// begin if GetWeapon ( i ) = ru_time_lapser then
13866: LD_VAR 0 1
13870: PPUSH
13871: CALL_OW 264
13875: PUSH
13876: LD_INT 49
13878: EQUAL
13879: IFFALSE 13917
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13881: LD_VAR 0 1
13885: PPUSH
13886: LD_INT 81
13888: PUSH
13889: LD_INT 7
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PPUSH
13896: CALL_OW 69
13900: PPUSH
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 74
13910: PPUSH
13911: CALL_OW 112
13915: GO 13951
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13917: LD_VAR 0 1
13921: PPUSH
13922: LD_INT 81
13924: PUSH
13925: LD_INT 7
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PPUSH
13932: CALL_OW 69
13936: PPUSH
13937: LD_VAR 0 1
13941: PPUSH
13942: CALL_OW 74
13946: PPUSH
13947: CALL_OW 115
// end else
13951: GO 13969
// tmp := tmp diff i ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_VAR 0 2
13962: PUSH
13963: LD_VAR 0 1
13967: DIFF
13968: ST_TO_ADDR
13969: GO 13848
13971: POP
13972: POP
// until not tmp ;
13973: LD_VAR 0 2
13977: NOT
13978: IFFALSE 13831
// end ; end_of_file
13980: PPOPN 4
13982: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13983: LD_INT 0
13985: PPUSH
13986: PPUSH
13987: PPUSH
13988: PPUSH
// missionStage := 13 ;
13989: LD_ADDR_EXP 15
13993: PUSH
13994: LD_INT 13
13996: ST_TO_ADDR
// uc_side := 2 ;
13997: LD_ADDR_OWVAR 20
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// uc_nation := 2 ;
14005: LD_ADDR_OWVAR 21
14009: PUSH
14010: LD_INT 2
14012: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14013: LD_ADDR_EXP 92
14017: PUSH
14018: LD_STRING Omar
14020: PPUSH
14021: CALL_OW 25
14025: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14026: LD_EXP 92
14030: PPUSH
14031: LD_INT 4
14033: PPUSH
14034: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14038: LD_EXP 92
14042: PPUSH
14043: LD_INT 242
14045: PPUSH
14046: LD_INT 75
14048: PPUSH
14049: LD_INT 0
14051: PPUSH
14052: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14056: LD_ADDR_EXP 93
14060: PUSH
14061: LD_STRING Heike
14063: PPUSH
14064: CALL_OW 25
14068: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14069: LD_INT 14
14071: PPUSH
14072: LD_INT 3
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 27
14080: PPUSH
14081: LD_INT 100
14083: PPUSH
14084: CALL 70749 0 5
// veh := CreateVehicle ;
14088: LD_ADDR_VAR 0 3
14092: PUSH
14093: CALL_OW 45
14097: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14098: LD_VAR 0 3
14102: PPUSH
14103: LD_INT 1
14105: PPUSH
14106: CALL_OW 242
// SetDir ( veh , 4 ) ;
14110: LD_VAR 0 3
14114: PPUSH
14115: LD_INT 4
14117: PPUSH
14118: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14122: LD_VAR 0 3
14126: PPUSH
14127: LD_INT 241
14129: PPUSH
14130: LD_INT 72
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14140: LD_EXP 93
14144: PPUSH
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 52
// if KhatamStatus then
14154: LD_EXP 8
14158: IFFALSE 14209
// begin Khatam := NewCharacter ( Khatam ) ;
14160: LD_ADDR_EXP 94
14164: PUSH
14165: LD_STRING Khatam
14167: PPUSH
14168: CALL_OW 25
14172: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14173: LD_EXP 94
14177: PPUSH
14178: LD_INT 245
14180: PPUSH
14181: LD_INT 78
14183: PPUSH
14184: LD_INT 3
14186: PPUSH
14187: LD_INT 0
14189: PPUSH
14190: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14194: LD_EXP 94
14198: PPUSH
14199: LD_INT 4
14201: PPUSH
14202: LD_INT 10
14204: PPUSH
14205: CALL_OW 237
// end ; for i = 1 to Difficulty do
14209: LD_ADDR_VAR 0 2
14213: PUSH
14214: DOUBLE
14215: LD_INT 1
14217: DEC
14218: ST_TO_ADDR
14219: LD_OWVAR 67
14223: PUSH
14224: FOR_TO
14225: IFFALSE 14291
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14227: LD_INT 0
14229: PPUSH
14230: LD_INT 7
14232: PUSH
14233: LD_OWVAR 67
14237: PLUS
14238: PPUSH
14239: CALL_OW 384
// un := CreateHuman ;
14243: LD_ADDR_VAR 0 4
14247: PUSH
14248: CALL_OW 44
14252: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14253: LD_VAR 0 4
14257: PPUSH
14258: LD_INT 28
14260: PUSH
14261: LD_INT 29
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_VAR 0 2
14272: PUSH
14273: LD_INT 2
14275: MOD
14276: PUSH
14277: LD_INT 1
14279: PLUS
14280: ARRAY
14281: PPUSH
14282: LD_INT 0
14284: PPUSH
14285: CALL_OW 49
// end ;
14289: GO 14224
14291: POP
14292: POP
// for i = 1 to 6 do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_INT 6
14305: PUSH
14306: FOR_TO
14307: IFFALSE 14352
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14309: LD_INT 0
14311: PPUSH
14312: LD_INT 7
14314: PUSH
14315: LD_OWVAR 67
14319: PLUS
14320: PPUSH
14321: CALL_OW 381
// un := CreateHuman ;
14325: LD_ADDR_VAR 0 4
14329: PUSH
14330: CALL_OW 44
14334: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14335: LD_VAR 0 4
14339: PPUSH
14340: LD_INT 28
14342: PPUSH
14343: LD_INT 0
14345: PPUSH
14346: CALL_OW 49
// end ;
14350: GO 14306
14352: POP
14353: POP
// for i = 1 to 3 do
14354: LD_ADDR_VAR 0 2
14358: PUSH
14359: DOUBLE
14360: LD_INT 1
14362: DEC
14363: ST_TO_ADDR
14364: LD_INT 3
14366: PUSH
14367: FOR_TO
14368: IFFALSE 14416
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 8
14375: PPUSH
14376: LD_INT 7
14378: PUSH
14379: LD_OWVAR 67
14383: PLUS
14384: PPUSH
14385: CALL_OW 380
// un := CreateHuman ;
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: CALL_OW 44
14398: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14399: LD_VAR 0 4
14403: PPUSH
14404: LD_INT 28
14406: PPUSH
14407: LD_INT 0
14409: PPUSH
14410: CALL_OW 49
// end ;
14414: GO 14367
14416: POP
14417: POP
// for i = 1 to 3 do
14418: LD_ADDR_VAR 0 2
14422: PUSH
14423: DOUBLE
14424: LD_INT 1
14426: DEC
14427: ST_TO_ADDR
14428: LD_INT 3
14430: PUSH
14431: FOR_TO
14432: IFFALSE 14522
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14434: LD_INT 14
14436: PPUSH
14437: LD_INT 2
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PPUSH
14446: LD_INT 80
14448: PPUSH
14449: CALL 70749 0 5
// veh := CreateVehicle ;
14453: LD_ADDR_VAR 0 3
14457: PUSH
14458: CALL_OW 45
14462: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14463: LD_VAR 0 3
14467: PPUSH
14468: LD_INT 3
14470: PPUSH
14471: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14475: LD_VAR 0 3
14479: PPUSH
14480: LD_INT 29
14482: PPUSH
14483: LD_INT 0
14485: PPUSH
14486: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14490: LD_INT 0
14492: PPUSH
14493: LD_INT 7
14495: PUSH
14496: LD_OWVAR 67
14500: PLUS
14501: PPUSH
14502: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14506: CALL_OW 44
14510: PPUSH
14511: LD_VAR 0 3
14515: PPUSH
14516: CALL_OW 52
// end ;
14520: GO 14431
14522: POP
14523: POP
// for i = 1 to 5 + Difficulty do
14524: LD_ADDR_VAR 0 2
14528: PUSH
14529: DOUBLE
14530: LD_INT 1
14532: DEC
14533: ST_TO_ADDR
14534: LD_INT 5
14536: PUSH
14537: LD_OWVAR 67
14541: PLUS
14542: PUSH
14543: FOR_TO
14544: IFFALSE 14671
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14546: LD_INT 14
14548: PPUSH
14549: LD_INT 1
14551: PPUSH
14552: LD_INT 3
14554: PPUSH
14555: CALL_OW 12
14559: PPUSH
14560: LD_INT 1
14562: PPUSH
14563: LD_INT 28
14565: PUSH
14566: LD_INT 26
14568: PUSH
14569: LD_INT 27
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: PUSH
14581: LD_VAR 0 2
14585: PUSH
14586: LD_INT 4
14588: MOD
14589: PUSH
14590: LD_INT 1
14592: PLUS
14593: ARRAY
14594: PPUSH
14595: LD_INT 80
14597: PPUSH
14598: CALL 70749 0 5
// veh := CreateVehicle ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: CALL_OW 45
14611: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14612: LD_VAR 0 3
14616: PPUSH
14617: LD_INT 4
14619: PPUSH
14620: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14624: LD_VAR 0 3
14628: PPUSH
14629: LD_INT 28
14631: PPUSH
14632: LD_INT 0
14634: PPUSH
14635: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14639: LD_INT 0
14641: PPUSH
14642: LD_INT 7
14644: PUSH
14645: LD_OWVAR 67
14649: PLUS
14650: PPUSH
14651: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14655: CALL_OW 44
14659: PPUSH
14660: LD_VAR 0 3
14664: PPUSH
14665: CALL_OW 52
// end ;
14669: GO 14543
14671: POP
14672: POP
// for i = 1 to 3 do
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: DOUBLE
14679: LD_INT 1
14681: DEC
14682: ST_TO_ADDR
14683: LD_INT 3
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14747
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14689: LD_INT 14
14691: PPUSH
14692: LD_INT 3
14694: PPUSH
14695: LD_INT 5
14697: PPUSH
14698: LD_INT 29
14700: PPUSH
14701: LD_INT 80
14703: PPUSH
14704: CALL 70749 0 5
// veh := CreateVehicle ;
14708: LD_ADDR_VAR 0 3
14712: PUSH
14713: CALL_OW 45
14717: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_INT 4
14725: PPUSH
14726: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14730: LD_VAR 0 3
14734: PPUSH
14735: LD_INT 28
14737: PPUSH
14738: LD_INT 0
14740: PPUSH
14741: CALL_OW 49
// end ;
14745: GO 14686
14747: POP
14748: POP
// end ;
14749: LD_VAR 0 1
14753: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14754: LD_INT 22
14756: PUSH
14757: LD_INT 2
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PPUSH
14764: CALL_OW 69
14768: IFFALSE 15068
14770: GO 14772
14772: DISABLE
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
14777: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14778: LD_ADDR_VAR 0 3
14782: PUSH
14783: LD_INT 22
14785: PUSH
14786: LD_INT 2
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 25
14795: PUSH
14796: LD_INT 4
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 69
14811: PUSH
14812: LD_EXP 94
14816: DIFF
14817: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14818: LD_ADDR_VAR 0 2
14822: PUSH
14823: LD_INT 22
14825: PUSH
14826: LD_INT 2
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PPUSH
14833: CALL_OW 69
14837: PUSH
14838: LD_EXP 94
14842: PUSH
14843: LD_VAR 0 3
14847: UNION
14848: DIFF
14849: ST_TO_ADDR
// if Khatam then
14850: LD_EXP 94
14854: IFFALSE 14871
// ComMoveXY ( Khatam , 211 , 92 ) ;
14856: LD_EXP 94
14860: PPUSH
14861: LD_INT 211
14863: PPUSH
14864: LD_INT 92
14866: PPUSH
14867: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14871: LD_INT 197
14873: PPUSH
14874: LD_INT 80
14876: PPUSH
14877: LD_INT 2
14879: PPUSH
14880: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14884: LD_INT 213
14886: PPUSH
14887: LD_INT 90
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14897: LD_INT 215
14899: PPUSH
14900: LD_INT 129
14902: PPUSH
14903: LD_INT 2
14905: PPUSH
14906: CALL_OW 441
// if sci then
14910: LD_VAR 0 3
14914: IFFALSE 14935
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14916: LD_VAR 0 3
14920: PUSH
14921: LD_INT 1
14923: ARRAY
14924: PPUSH
14925: LD_INT 197
14927: PPUSH
14928: LD_INT 80
14930: PPUSH
14931: CALL_OW 158
// if sci > 1 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: GREATER
14943: IFFALSE 14964
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: PPUSH
14954: LD_INT 213
14956: PPUSH
14957: LD_INT 90
14959: PPUSH
14960: CALL_OW 158
// if sci > 2 then
14964: LD_VAR 0 3
14968: PUSH
14969: LD_INT 2
14971: GREATER
14972: IFFALSE 14993
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14974: LD_VAR 0 3
14978: PUSH
14979: LD_INT 3
14981: ARRAY
14982: PPUSH
14983: LD_INT 215
14985: PPUSH
14986: LD_INT 129
14988: PPUSH
14989: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14993: LD_INT 35
14995: PPUSH
14996: CALL_OW 67
// for i in tmp do
15000: LD_ADDR_VAR 0 1
15004: PUSH
15005: LD_VAR 0 2
15009: PUSH
15010: FOR_IN
15011: IFFALSE 15049
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15013: LD_VAR 0 1
15017: PPUSH
15018: LD_INT 81
15020: PUSH
15021: LD_INT 2
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PPUSH
15033: LD_VAR 0 1
15037: PPUSH
15038: CALL_OW 74
15042: PPUSH
15043: CALL_OW 115
15047: GO 15010
15049: POP
15050: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15051: LD_INT 22
15053: PUSH
15054: LD_INT 2
15056: PUSH
15057: EMPTY
15058: LIST
15059: LIST
15060: PPUSH
15061: CALL_OW 69
15065: NOT
15066: IFFALSE 14993
// end ; end_of_file
15068: PPOPN 3
15070: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15071: LD_INT 0
15073: PPUSH
15074: PPUSH
15075: PPUSH
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
15080: PPUSH
15081: PPUSH
// Video ( true ) ;
15082: LD_INT 1
15084: PPUSH
15085: CALL 102594 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15089: LD_ADDR_VAR 0 5
15093: PUSH
15094: LD_INT 7
15096: PPUSH
15097: LD_INT 0
15099: PPUSH
15100: CALL_OW 517
15104: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15105: LD_ADDR_VAR 0 2
15109: PUSH
15110: DOUBLE
15111: LD_INT 1
15113: DEC
15114: ST_TO_ADDR
15115: LD_VAR 0 5
15119: PUSH
15120: LD_INT 1
15122: ARRAY
15123: PUSH
15124: FOR_TO
15125: IFFALSE 15170
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15127: LD_VAR 0 5
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 2
15140: ARRAY
15141: PPUSH
15142: LD_VAR 0 5
15146: PUSH
15147: LD_INT 2
15149: ARRAY
15150: PUSH
15151: LD_VAR 0 2
15155: ARRAY
15156: PPUSH
15157: LD_INT 1
15159: PPUSH
15160: LD_INT 15
15162: NEG
15163: PPUSH
15164: CALL 102508 0 4
15168: GO 15124
15170: POP
15171: POP
// CenterNowOnUnits ( Powell ) ;
15172: LD_EXP 58
15176: PPUSH
15177: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15181: LD_ADDR_VAR 0 5
15185: PUSH
15186: LD_EXP 56
15190: PUSH
15191: EMPTY
15192: LIST
15193: ST_TO_ADDR
// if GirlNewVeh then
15194: LD_EXP 57
15198: IFFALSE 15216
// tmp := tmp ^ GirlNewVeh ;
15200: LD_ADDR_VAR 0 5
15204: PUSH
15205: LD_VAR 0 5
15209: PUSH
15210: LD_EXP 57
15214: ADD
15215: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15216: LD_VAR 0 5
15220: PPUSH
15221: LD_INT 60
15223: PPUSH
15224: LD_INT 109
15226: PPUSH
15227: CALL_OW 111
// if KappaStatus then
15231: LD_EXP 2
15235: IFFALSE 15287
// begin Say ( JMM , D1nT-JMM-1 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1nT-JMM-1
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-1
15256: PPUSH
15257: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15261: LD_EXP 39
15265: PPUSH
15266: LD_STRING D1T-JMM-2
15268: PPUSH
15269: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15273: LD_EXP 58
15277: PPUSH
15278: LD_STRING D1T-Pow-2
15280: PPUSH
15281: CALL_OW 88
// end else
15285: GO 15493
// if JMMGirlStatus then
15287: LD_EXP 6
15291: IFFALSE 15436
// begin Say ( JMM , D1T-JMM-1 ) ;
15293: LD_EXP 39
15297: PPUSH
15298: LD_STRING D1T-JMM-1
15300: PPUSH
15301: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15305: LD_EXP 58
15309: PPUSH
15310: LD_STRING D1T-Pow-1
15312: PPUSH
15313: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15317: LD_EXP 39
15321: PPUSH
15322: LD_STRING D1T-JMM-3
15324: PPUSH
15325: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15329: LD_EXP 58
15333: PPUSH
15334: LD_STRING D1T-Pow-3
15336: PPUSH
15337: CALL_OW 88
// if JMMGirl then
15341: LD_EXP 7
15345: IFFALSE 15434
// begin case JMMGirl of 1 :
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 1
15354: DOUBLE
15355: EQUAL
15356: IFTRUE 15360
15358: GO 15375
15360: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15361: LD_EXP 40
15365: PPUSH
15366: LD_STRING D1T-Joan-3
15368: PPUSH
15369: CALL_OW 88
15373: GO 15422
15375: LD_INT 2
15377: DOUBLE
15378: EQUAL
15379: IFTRUE 15383
15381: GO 15398
15383: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15384: LD_EXP 42
15388: PPUSH
15389: LD_STRING D1T-Lisa-3
15391: PPUSH
15392: CALL_OW 88
15396: GO 15422
15398: LD_INT 3
15400: DOUBLE
15401: EQUAL
15402: IFTRUE 15406
15404: GO 15421
15406: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15407: LD_EXP 54
15411: PPUSH
15412: LD_STRING D1T-Con-3
15414: PPUSH
15415: CALL_OW 88
15419: GO 15422
15421: POP
// Say ( Powell , D1T-Pow-4 ) ;
15422: LD_EXP 58
15426: PPUSH
15427: LD_STRING D1T-Pow-4
15429: PPUSH
15430: CALL_OW 88
// end ; end else
15434: GO 15493
// if not FastEnd then
15436: LD_EXP 11
15440: NOT
15441: IFFALSE 15469
// begin Say ( JMM , D1T-JMM-4 ) ;
15443: LD_EXP 39
15447: PPUSH
15448: LD_STRING D1T-JMM-4
15450: PPUSH
15451: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15455: LD_EXP 58
15459: PPUSH
15460: LD_STRING D1T-Pow-5
15462: PPUSH
15463: CALL_OW 88
// end else
15467: GO 15493
// begin Say ( JMM , D1nT-JMM-1 ) ;
15469: LD_EXP 39
15473: PPUSH
15474: LD_STRING D1nT-JMM-1
15476: PPUSH
15477: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15481: LD_EXP 58
15485: PPUSH
15486: LD_STRING D1nT-Pow-1
15488: PPUSH
15489: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15493: LD_INT 35
15495: PPUSH
15496: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15500: LD_EXP 56
15504: PPUSH
15505: CALL_OW 314
15509: NOT
15510: IFFALSE 15493
// ComExitVehicle ( JMM ) ;
15512: LD_EXP 39
15516: PPUSH
15517: CALL_OW 121
// wait ( 3 ) ;
15521: LD_INT 3
15523: PPUSH
15524: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15528: LD_EXP 39
15532: PPUSH
15533: LD_INT 60
15535: PPUSH
15536: LD_INT 94
15538: PPUSH
15539: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15543: LD_EXP 39
15547: PPUSH
15548: LD_EXP 58
15552: PPUSH
15553: CALL_OW 179
// if Joan then
15557: LD_EXP 40
15561: IFFALSE 15615
// begin ComExitVehicle ( Joan ) ;
15563: LD_EXP 40
15567: PPUSH
15568: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15572: LD_EXP 40
15576: PPUSH
15577: LD_INT 35
15579: PPUSH
15580: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15584: LD_EXP 40
15588: PPUSH
15589: LD_INT 65
15591: PPUSH
15592: LD_INT 104
15594: PPUSH
15595: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15599: LD_EXP 40
15603: PPUSH
15604: LD_EXP 39
15608: PPUSH
15609: CALL_OW 179
// end else
15613: GO 15749
// if Lisa and JMMGirl = 2 then
15615: LD_EXP 42
15619: PUSH
15620: LD_EXP 7
15624: PUSH
15625: LD_INT 2
15627: EQUAL
15628: AND
15629: IFFALSE 15683
// begin ComExitVehicle ( Lisa ) ;
15631: LD_EXP 42
15635: PPUSH
15636: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15640: LD_EXP 42
15644: PPUSH
15645: LD_INT 35
15647: PPUSH
15648: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15652: LD_EXP 42
15656: PPUSH
15657: LD_INT 65
15659: PPUSH
15660: LD_INT 104
15662: PPUSH
15663: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15667: LD_EXP 42
15671: PPUSH
15672: LD_EXP 39
15676: PPUSH
15677: CALL_OW 179
// end else
15681: GO 15749
// if Connie and JMMGirl = 3 then
15683: LD_EXP 54
15687: PUSH
15688: LD_EXP 7
15692: PUSH
15693: LD_INT 3
15695: EQUAL
15696: AND
15697: IFFALSE 15749
// begin ComExitVehicle ( Connie ) ;
15699: LD_EXP 54
15703: PPUSH
15704: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15708: LD_EXP 54
15712: PPUSH
15713: LD_INT 35
15715: PPUSH
15716: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15720: LD_EXP 54
15724: PPUSH
15725: LD_INT 65
15727: PPUSH
15728: LD_INT 104
15730: PPUSH
15731: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15735: LD_EXP 54
15739: PPUSH
15740: LD_EXP 39
15744: PPUSH
15745: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15749: LD_INT 35
15751: PPUSH
15752: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15756: LD_EXP 39
15760: PPUSH
15761: LD_EXP 58
15765: PPUSH
15766: CALL_OW 296
15770: PUSH
15771: LD_INT 6
15773: LESS
15774: IFFALSE 15749
// wait ( 0 0$0.5 ) ;
15776: LD_INT 18
15778: PPUSH
15779: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15783: LD_EXP 39
15787: PPUSH
15788: LD_STRING D1-JMM-1
15790: PPUSH
15791: CALL_OW 88
// async ;
15795: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15796: LD_EXP 58
15800: PPUSH
15801: LD_STRING D1-Pow-1
15803: PPUSH
15804: CALL_OW 88
// if not dialogue_skipped then
15808: LD_OWVAR 59
15812: NOT
15813: IFFALSE 15822
// wait ( 0 0$2 ) ;
15815: LD_INT 70
15817: PPUSH
15818: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15822: LD_INT 170
15824: PPUSH
15825: LD_INT 99
15827: PPUSH
15828: LD_INT 1
15830: PPUSH
15831: LD_INT 6
15833: NEG
15834: PPUSH
15835: CALL 102508 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15839: LD_INT 174
15841: PPUSH
15842: LD_INT 115
15844: PPUSH
15845: LD_INT 1
15847: PPUSH
15848: LD_INT 6
15850: NEG
15851: PPUSH
15852: CALL 102508 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15856: LD_INT 169
15858: PPUSH
15859: LD_INT 71
15861: PPUSH
15862: LD_INT 1
15864: PPUSH
15865: LD_INT 6
15867: NEG
15868: PPUSH
15869: CALL 102508 0 4
// if not dialogue_skipped then
15873: LD_OWVAR 59
15877: NOT
15878: IFFALSE 15897
// begin CenterOnXY ( 170 , 99 ) ;
15880: LD_INT 170
15882: PPUSH
15883: LD_INT 99
15885: PPUSH
15886: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15890: LD_INT 80
15892: PPUSH
15893: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15897: LD_INT 75
15899: PPUSH
15900: LD_INT 53
15902: PPUSH
15903: LD_INT 1
15905: PPUSH
15906: LD_INT 9
15908: NEG
15909: PPUSH
15910: CALL 102508 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15914: LD_INT 54
15916: PPUSH
15917: LD_INT 42
15919: PPUSH
15920: LD_INT 1
15922: PPUSH
15923: LD_INT 9
15925: NEG
15926: PPUSH
15927: CALL 102508 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15931: LD_INT 62
15933: PPUSH
15934: LD_INT 51
15936: PPUSH
15937: LD_INT 1
15939: PPUSH
15940: LD_INT 9
15942: NEG
15943: PPUSH
15944: CALL 102508 0 4
// if not dialogue_skipped then
15948: LD_OWVAR 59
15952: NOT
15953: IFFALSE 15972
// begin CenterOnXY ( 75 , 53 ) ;
15955: LD_INT 75
15957: PPUSH
15958: LD_INT 53
15960: PPUSH
15961: CALL_OW 84
// wait ( 0 0$4 ) ;
15965: LD_INT 140
15967: PPUSH
15968: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15972: LD_EXP 58
15976: PPUSH
15977: CALL_OW 87
// if not dialogue_skipped then
15981: LD_OWVAR 59
15985: NOT
15986: IFFALSE 15995
// wait ( 0 0$2 ) ;
15988: LD_INT 70
15990: PPUSH
15991: CALL_OW 67
// sync ;
15995: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15996: LD_EXP 39
16000: PPUSH
16001: LD_STRING D1-JMM-2
16003: PPUSH
16004: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16008: LD_EXP 58
16012: PPUSH
16013: LD_STRING D1-Pow-2
16015: PPUSH
16016: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16020: LD_EXP 39
16024: PPUSH
16025: LD_STRING D1-JMM-3
16027: PPUSH
16028: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16032: LD_EXP 58
16036: PPUSH
16037: LD_STRING D1-Pow-3
16039: PPUSH
16040: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16044: LD_EXP 39
16048: PPUSH
16049: LD_STRING D1-JMM-4
16051: PPUSH
16052: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16056: LD_EXP 58
16060: PPUSH
16061: LD_STRING D1-Pow-4
16063: PPUSH
16064: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16068: LD_EXP 39
16072: PPUSH
16073: LD_STRING D1-JMM-5
16075: PPUSH
16076: CALL_OW 88
// async ;
16080: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16081: LD_EXP 58
16085: PPUSH
16086: LD_STRING D1-Pow-5
16088: PPUSH
16089: CALL_OW 88
// if not dialogue_skipped then
16093: LD_OWVAR 59
16097: NOT
16098: IFFALSE 16107
// wait ( 0 0$3.6 ) ;
16100: LD_INT 126
16102: PPUSH
16103: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16107: LD_INT 134
16109: PPUSH
16110: LD_INT 210
16112: PPUSH
16113: LD_INT 1
16115: PPUSH
16116: LD_INT 11
16118: NEG
16119: PPUSH
16120: CALL 102508 0 4
// if not dialogue_skipped then
16124: LD_OWVAR 59
16128: NOT
16129: IFFALSE 16148
// begin CenterOnXY ( 134 , 210 ) ;
16131: LD_INT 134
16133: PPUSH
16134: LD_INT 210
16136: PPUSH
16137: CALL_OW 84
// wait ( 0 0$2 ) ;
16141: LD_INT 70
16143: PPUSH
16144: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16148: LD_INT 101
16150: PPUSH
16151: LD_INT 159
16153: PPUSH
16154: LD_INT 1
16156: PPUSH
16157: LD_INT 10
16159: NEG
16160: PPUSH
16161: CALL 102508 0 4
// if not dialogue_skipped then
16165: LD_OWVAR 59
16169: NOT
16170: IFFALSE 16189
// begin CenterOnXY ( 101 , 159 ) ;
16172: LD_INT 101
16174: PPUSH
16175: LD_INT 159
16177: PPUSH
16178: CALL_OW 84
// wait ( 0 0$2 ) ;
16182: LD_INT 70
16184: PPUSH
16185: CALL_OW 67
// end ; sync ;
16189: SYNC
// CenterNowOnUnits ( Powell ) ;
16190: LD_EXP 58
16194: PPUSH
16195: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16199: LD_ADDR_VAR 0 6
16203: PUSH
16204: LD_INT 1
16206: PUSH
16207: LD_INT 2
16209: PUSH
16210: LD_INT 3
16212: PUSH
16213: LD_INT 4
16215: PUSH
16216: LD_INT 5
16218: PUSH
16219: LD_INT 6
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if not dialogue_skipped then
16230: LD_OWVAR 59
16234: NOT
16235: IFFALSE 16404
// begin game_speed := 4 ;
16237: LD_ADDR_OWVAR 65
16241: PUSH
16242: LD_INT 4
16244: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16245: LD_INT 210
16247: PPUSH
16248: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16252: LD_ADDR_VAR 0 7
16256: PUSH
16257: LD_STRING Q1
16259: PPUSH
16260: LD_VAR 0 6
16264: PPUSH
16265: CALL_OW 98
16269: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16270: LD_ADDR_VAR 0 7
16274: PUSH
16275: LD_STRING Q1
16277: PPUSH
16278: LD_VAR 0 6
16282: PPUSH
16283: CALL_OW 98
16287: ST_TO_ADDR
// options = options diff dec ;
16288: LD_ADDR_VAR 0 6
16292: PUSH
16293: LD_VAR 0 6
16297: PUSH
16298: LD_VAR 0 7
16302: DIFF
16303: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16304: LD_VAR 0 7
16308: PPUSH
16309: LD_VAR 0 6
16313: PPUSH
16314: CALL 17876 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16318: LD_VAR 0 7
16322: PUSH
16323: LD_INT 5
16325: PUSH
16326: LD_INT 6
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: IN
16333: PUSH
16334: LD_VAR 0 6
16338: PUSH
16339: LD_INT 2
16341: EQUAL
16342: OR
16343: IFFALSE 16270
// if not ( dec in [ 5 , 6 ] ) then
16345: LD_VAR 0 7
16349: PUSH
16350: LD_INT 5
16352: PUSH
16353: LD_INT 6
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: IN
16360: NOT
16361: IFFALSE 16404
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16363: LD_ADDR_VAR 0 7
16367: PUSH
16368: LD_STRING Q1a
16370: PPUSH
16371: LD_INT 1
16373: PUSH
16374: LD_INT 2
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PPUSH
16381: CALL_OW 98
16385: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16386: LD_VAR 0 7
16390: PUSH
16391: LD_INT 4
16393: PLUS
16394: PPUSH
16395: LD_VAR 0 6
16399: PPUSH
16400: CALL 17876 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16404: LD_INT 81
16406: PPUSH
16407: LD_INT 127
16409: PPUSH
16410: CALL_OW 84
// amount := 5 ;
16414: LD_ADDR_VAR 0 8
16418: PUSH
16419: LD_INT 5
16421: ST_TO_ADDR
// macmilan_squad := [ ] ;
16422: LD_ADDR_VAR 0 9
16426: PUSH
16427: EMPTY
16428: ST_TO_ADDR
// if vip < amount then
16429: LD_EXP 59
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16483
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16441: LD_ADDR_VAR 0 5
16445: PUSH
16446: LD_EXP 59
16450: PUSH
16451: LD_INT 22
16453: PUSH
16454: LD_INT 4
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PUSH
16461: LD_INT 21
16463: PUSH
16464: LD_INT 1
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: PPUSH
16475: CALL_OW 69
16479: UNION
16480: ST_TO_ADDR
16481: GO 16493
// tmp := vip ;
16483: LD_ADDR_VAR 0 5
16487: PUSH
16488: LD_EXP 59
16492: ST_TO_ADDR
// tmp := tmp diff Powell ;
16493: LD_ADDR_VAR 0 5
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_EXP 58
16507: DIFF
16508: ST_TO_ADDR
// if tmp < amount then
16509: LD_VAR 0 5
16513: PUSH
16514: LD_VAR 0 8
16518: LESS
16519: IFFALSE 16531
// amount := tmp ;
16521: LD_ADDR_VAR 0 8
16525: PUSH
16526: LD_VAR 0 5
16530: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16531: LD_VAR 0 5
16535: PUSH
16536: LD_INT 1
16538: ARRAY
16539: PPUSH
16540: CALL_OW 257
16544: PUSH
16545: LD_INT 2
16547: NONEQUAL
16548: IFFALSE 16610
// begin if IsInUnit ( tmp [ 1 ] ) then
16550: LD_VAR 0 5
16554: PUSH
16555: LD_INT 1
16557: ARRAY
16558: PPUSH
16559: CALL_OW 310
16563: IFFALSE 16578
// ComExitBuilding ( tmp [ 1 ] ) ;
16565: LD_VAR 0 5
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_INT 387
16589: PPUSH
16590: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16594: LD_VAR 0 5
16598: PUSH
16599: LD_INT 1
16601: ARRAY
16602: PPUSH
16603: LD_INT 2
16605: PPUSH
16606: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16610: LD_EXP 39
16614: PPUSH
16615: LD_INT 82
16617: PPUSH
16618: LD_INT 129
16620: PPUSH
16621: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16625: LD_EXP 39
16629: PPUSH
16630: LD_EXP 58
16634: PPUSH
16635: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16639: LD_INT 22
16641: PUSH
16642: LD_INT 1
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PPUSH
16649: CALL_OW 69
16653: PUSH
16654: LD_EXP 39
16658: DIFF
16659: PPUSH
16660: LD_INT 84
16662: PPUSH
16663: LD_INT 128
16665: PPUSH
16666: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16670: LD_INT 22
16672: PUSH
16673: LD_INT 1
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL_OW 69
16684: PUSH
16685: LD_EXP 39
16689: DIFF
16690: PPUSH
16691: LD_EXP 39
16695: PPUSH
16696: CALL_OW 179
// for i = 1 to amount do
16700: LD_ADDR_VAR 0 2
16704: PUSH
16705: DOUBLE
16706: LD_INT 1
16708: DEC
16709: ST_TO_ADDR
16710: LD_VAR 0 8
16714: PUSH
16715: FOR_TO
16716: IFFALSE 16884
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16718: LD_ADDR_VAR 0 9
16722: PUSH
16723: LD_VAR 0 9
16727: PUSH
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: ADD
16739: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16740: LD_VAR 0 5
16744: PUSH
16745: LD_VAR 0 2
16749: ARRAY
16750: PPUSH
16751: CALL_OW 310
16755: IFFALSE 16772
// AddComExitBuilding ( tmp [ i ] ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: CALL_OW 182
// if i = 2 and JMMNewVeh then
16772: LD_VAR 0 2
16776: PUSH
16777: LD_INT 2
16779: EQUAL
16780: PUSH
16781: LD_EXP 56
16785: AND
16786: IFFALSE 16844
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16788: LD_VAR 0 5
16792: PUSH
16793: LD_VAR 0 2
16797: ARRAY
16798: PPUSH
16799: LD_EXP 56
16803: PPUSH
16804: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16808: LD_VAR 0 5
16812: PUSH
16813: LD_VAR 0 2
16817: ARRAY
16818: PPUSH
16819: LD_INT 86
16821: PPUSH
16822: LD_INT 133
16824: PPUSH
16825: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16829: LD_VAR 0 5
16833: PUSH
16834: LD_VAR 0 2
16838: ARRAY
16839: PPUSH
16840: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16844: LD_VAR 0 5
16848: PUSH
16849: LD_VAR 0 2
16853: ARRAY
16854: PPUSH
16855: LD_INT 8
16857: PPUSH
16858: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16862: LD_VAR 0 5
16866: PUSH
16867: LD_VAR 0 2
16871: ARRAY
16872: PPUSH
16873: LD_EXP 39
16877: PPUSH
16878: CALL_OW 179
// end ;
16882: GO 16715
16884: POP
16885: POP
// if GirlNewVeh then
16886: LD_EXP 57
16890: IFFALSE 16904
// SetSide ( GirlNewVeh , 4 ) ;
16892: LD_EXP 57
16896: PPUSH
16897: LD_INT 4
16899: PPUSH
16900: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16904: LD_INT 35
16906: PPUSH
16907: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16911: LD_VAR 0 9
16915: PPUSH
16916: LD_INT 95
16918: PUSH
16919: LD_INT 9
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL_OW 72
16930: PUSH
16931: LD_INT 0
16933: EQUAL
16934: PUSH
16935: LD_EXP 39
16939: PPUSH
16940: LD_INT 9
16942: PPUSH
16943: CALL_OW 308
16947: NOT
16948: AND
16949: IFFALSE 16904
// wait ( 0 0$2 ) ;
16951: LD_INT 70
16953: PPUSH
16954: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16958: LD_VAR 0 9
16962: PPUSH
16963: LD_INT 1
16965: PPUSH
16966: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16970: LD_INT 21
16972: PUSH
16973: LD_INT 2
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: LD_INT 92
16982: PUSH
16983: LD_INT 83
16985: PUSH
16986: LD_INT 130
16988: PUSH
16989: LD_INT 10
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PPUSH
17002: CALL_OW 69
17006: PPUSH
17007: LD_INT 1
17009: PPUSH
17010: CALL_OW 235
// Video ( false ) ;
17014: LD_INT 0
17016: PPUSH
17017: CALL 102594 0 1
// ChangeMissionObjectives ( M1 ) ;
17021: LD_STRING M1
17023: PPUSH
17024: CALL_OW 337
// SaveForQuickRestart ;
17028: CALL_OW 22
// missionStart := true ;
17032: LD_ADDR_EXP 13
17036: PUSH
17037: LD_INT 1
17039: ST_TO_ADDR
// missionStage := 2 ;
17040: LD_ADDR_EXP 15
17044: PUSH
17045: LD_INT 2
17047: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17048: LD_INT 105
17050: PPUSH
17051: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17055: LD_ADDR_VAR 0 5
17059: PUSH
17060: LD_INT 22
17062: PUSH
17063: LD_INT 4
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: PUSH
17070: LD_INT 21
17072: PUSH
17073: LD_INT 1
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PPUSH
17084: CALL_OW 69
17088: PUSH
17089: LD_EXP 58
17093: DIFF
17094: ST_TO_ADDR
// if not tmp then
17095: LD_VAR 0 5
17099: NOT
17100: IFFALSE 17115
// tmp := [ Powell ] ;
17102: LD_ADDR_VAR 0 5
17106: PUSH
17107: LD_EXP 58
17111: PUSH
17112: EMPTY
17113: LIST
17114: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17115: LD_ADDR_EXP 116
17119: PUSH
17120: LD_EXP 116
17124: PPUSH
17125: LD_INT 4
17127: PPUSH
17128: LD_INT 22
17130: PUSH
17131: LD_INT 4
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PUSH
17138: LD_INT 23
17140: PUSH
17141: LD_INT 1
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 21
17153: PUSH
17154: LD_INT 2
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PPUSH
17170: CALL_OW 69
17174: PUSH
17175: LD_EXP 58
17179: DIFF
17180: PPUSH
17181: CALL_OW 1
17185: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17186: LD_ADDR_VAR 0 4
17190: PUSH
17191: LD_INT 22
17193: PUSH
17194: LD_INT 4
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 34
17203: PUSH
17204: LD_INT 12
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: PUSH
17220: LD_INT 1
17222: ARRAY
17223: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17224: LD_VAR 0 5
17228: PUSH
17229: LD_INT 1
17231: ARRAY
17232: PPUSH
17233: CALL_OW 310
17237: IFFALSE 17252
// ComExitBuilding ( tmp [ 1 ] ) ;
17239: LD_VAR 0 5
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17252: LD_VAR 0 5
17256: PUSH
17257: LD_INT 1
17259: ARRAY
17260: PPUSH
17261: LD_VAR 0 4
17265: PPUSH
17266: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17270: LD_VAR 0 5
17274: PUSH
17275: LD_INT 1
17277: ARRAY
17278: PPUSH
17279: LD_INT 80
17281: PPUSH
17282: LD_INT 136
17284: PPUSH
17285: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17289: LD_VAR 0 5
17293: PUSH
17294: LD_INT 1
17296: ARRAY
17297: PPUSH
17298: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17302: LD_VAR 0 5
17306: PUSH
17307: LD_INT 1
17309: ARRAY
17310: PPUSH
17311: LD_INT 59
17313: PPUSH
17314: LD_INT 112
17316: PPUSH
17317: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17321: LD_VAR 0 5
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17334: LD_EXP 40
17338: PUSH
17339: LD_EXP 40
17343: PPUSH
17344: CALL_OW 255
17348: PUSH
17349: LD_INT 1
17351: EQUAL
17352: AND
17353: IFFALSE 17379
// begin Say ( Joan , D3W-Joan-1 ) ;
17355: LD_EXP 40
17359: PPUSH
17360: LD_STRING D3W-Joan-1
17362: PPUSH
17363: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17367: LD_EXP 39
17371: PPUSH
17372: LD_STRING D3W-JMM-1
17374: PPUSH
17375: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17379: LD_EXP 42
17383: PUSH
17384: LD_EXP 42
17388: PPUSH
17389: CALL_OW 255
17393: PUSH
17394: LD_INT 1
17396: EQUAL
17397: AND
17398: PUSH
17399: LD_EXP 42
17403: PUSH
17404: LD_EXP 59
17408: IN
17409: NOT
17410: AND
17411: IFFALSE 17437
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17413: LD_EXP 42
17417: PPUSH
17418: LD_STRING D3W-Lisa-1
17420: PPUSH
17421: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17425: LD_EXP 39
17429: PPUSH
17430: LD_STRING D3W-JMM-1
17432: PPUSH
17433: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17437: LD_EXP 54
17441: PUSH
17442: LD_EXP 54
17446: PPUSH
17447: CALL_OW 255
17451: PUSH
17452: LD_INT 1
17454: EQUAL
17455: AND
17456: IFFALSE 17482
// begin Say ( Connie , D3W-Con-1 ) ;
17458: LD_EXP 54
17462: PPUSH
17463: LD_STRING D3W-Con-1
17465: PPUSH
17466: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17470: LD_EXP 39
17474: PPUSH
17475: LD_STRING D3W-JMM-1
17477: PPUSH
17478: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17482: LD_EXP 42
17486: PUSH
17487: LD_EXP 59
17491: IN
17492: PUSH
17493: LD_EXP 42
17497: PPUSH
17498: CALL_OW 255
17502: PUSH
17503: LD_INT 1
17505: EQUAL
17506: AND
17507: IFFALSE 17523
// Say ( Lisa , D3nW-Lisa-1 ) else
17509: LD_EXP 42
17513: PPUSH
17514: LD_STRING D3nW-Lisa-1
17516: PPUSH
17517: CALL_OW 88
17521: GO 17767
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17523: LD_EXP 45
17527: PUSH
17528: LD_EXP 59
17532: IN
17533: PUSH
17534: LD_EXP 45
17538: PPUSH
17539: CALL_OW 255
17543: PUSH
17544: LD_INT 1
17546: EQUAL
17547: AND
17548: IFFALSE 17564
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17550: LD_EXP 45
17554: PPUSH
17555: LD_STRING D3nW-Cyrus-1
17557: PPUSH
17558: CALL_OW 88
17562: GO 17767
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17564: LD_EXP 44
17568: PUSH
17569: LD_EXP 59
17573: IN
17574: PUSH
17575: LD_EXP 44
17579: PPUSH
17580: CALL_OW 255
17584: PUSH
17585: LD_INT 1
17587: EQUAL
17588: AND
17589: IFFALSE 17605
// Say ( Bobby , D3nW-Bobby-1 ) else
17591: LD_EXP 44
17595: PPUSH
17596: LD_STRING D3nW-Bobby-1
17598: PPUSH
17599: CALL_OW 88
17603: GO 17767
// if Gary in vip and GetSide ( Gary ) = 1 then
17605: LD_EXP 51
17609: PUSH
17610: LD_EXP 59
17614: IN
17615: PUSH
17616: LD_EXP 51
17620: PPUSH
17621: CALL_OW 255
17625: PUSH
17626: LD_INT 1
17628: EQUAL
17629: AND
17630: IFFALSE 17646
// Say ( Gary , D3nW-Gary-1 ) else
17632: LD_EXP 51
17636: PPUSH
17637: LD_STRING D3nW-Gary-1
17639: PPUSH
17640: CALL_OW 88
17644: GO 17767
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17646: LD_EXP 43
17650: PUSH
17651: LD_EXP 59
17655: IN
17656: PUSH
17657: LD_EXP 43
17661: PPUSH
17662: CALL_OW 255
17666: PUSH
17667: LD_INT 1
17669: EQUAL
17670: AND
17671: IFFALSE 17687
// Say ( Donaldson , D3nW-Don-1 ) else
17673: LD_EXP 43
17677: PPUSH
17678: LD_STRING D3nW-Don-1
17680: PPUSH
17681: CALL_OW 88
17685: GO 17767
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17687: LD_EXP 50
17691: PUSH
17692: LD_EXP 59
17696: IN
17697: PUSH
17698: LD_EXP 50
17702: PPUSH
17703: CALL_OW 255
17707: PUSH
17708: LD_INT 1
17710: EQUAL
17711: AND
17712: IFFALSE 17728
// Say ( Cornel , D3nW-Corn-1 ) else
17714: LD_EXP 50
17718: PPUSH
17719: LD_STRING D3nW-Corn-1
17721: PPUSH
17722: CALL_OW 88
17726: GO 17767
// if Frank in vip and GetSide ( Frank ) = 1 then
17728: LD_EXP 52
17732: PUSH
17733: LD_EXP 59
17737: IN
17738: PUSH
17739: LD_EXP 52
17743: PPUSH
17744: CALL_OW 255
17748: PUSH
17749: LD_INT 1
17751: EQUAL
17752: AND
17753: IFFALSE 17767
// Say ( Frank , D3nW-Frank-1 ) ;
17755: LD_EXP 52
17759: PPUSH
17760: LD_STRING D3nW-Frank-1
17762: PPUSH
17763: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17767: LD_EXP 59
17771: PPUSH
17772: LD_INT 22
17774: PUSH
17775: LD_INT 1
17777: PUSH
17778: EMPTY
17779: LIST
17780: LIST
17781: PPUSH
17782: CALL_OW 72
17786: IFFALSE 17812
// begin Say ( JMM , D3nW-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D3nW-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17800: LD_EXP 39
17804: PPUSH
17805: LD_STRING D3nW-JMM-1a
17807: PPUSH
17808: CALL_OW 88
// end ; t := 0 0$00 ;
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: LD_INT 0
17819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17820: LD_INT 35
17822: PPUSH
17823: CALL_OW 67
// t := t + 0 0$1 ;
17827: LD_ADDR_VAR 0 3
17831: PUSH
17832: LD_VAR 0 3
17836: PUSH
17837: LD_INT 35
17839: PLUS
17840: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17841: LD_INT 59
17843: PPUSH
17844: LD_INT 112
17846: PPUSH
17847: CALL_OW 428
17851: PUSH
17852: LD_VAR 0 3
17856: PUSH
17857: LD_INT 2100
17859: GREATER
17860: OR
17861: IFFALSE 17820
// activeAttacks := true ;
17863: LD_ADDR_EXP 16
17867: PUSH
17868: LD_INT 1
17870: ST_TO_ADDR
// end ;
17871: LD_VAR 0 1
17875: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17876: LD_INT 0
17878: PPUSH
// case question of 1 :
17879: LD_VAR 0 1
17883: PUSH
17884: LD_INT 1
17886: DOUBLE
17887: EQUAL
17888: IFTRUE 17892
17890: GO 17943
17892: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17893: LD_EXP 39
17897: PPUSH
17898: LD_STRING D2Mot-JMM-1
17900: PPUSH
17901: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17905: LD_EXP 58
17909: PPUSH
17910: LD_STRING D2Mot-Pow-1
17912: PPUSH
17913: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17917: LD_EXP 39
17921: PPUSH
17922: LD_STRING D2Mot-JMM-2
17924: PPUSH
17925: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17929: LD_EXP 58
17933: PPUSH
17934: LD_STRING D2Mot-Pow-2
17936: PPUSH
17937: CALL_OW 88
// end ; 2 :
17941: GO 18294
17943: LD_INT 2
17945: DOUBLE
17946: EQUAL
17947: IFTRUE 17951
17949: GO 18027
17951: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17952: LD_EXP 39
17956: PPUSH
17957: LD_STRING D2Rus-JMM-1
17959: PPUSH
17960: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17964: LD_EXP 58
17968: PPUSH
17969: LD_STRING D2Rus-Pow-1
17971: PPUSH
17972: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17976: LD_EXP 39
17980: PPUSH
17981: LD_STRING D2Rus-JMM-2
17983: PPUSH
17984: CALL_OW 88
// if not ( 3 in list_of_q ) then
17988: LD_INT 3
17990: PUSH
17991: LD_VAR 0 2
17995: IN
17996: NOT
17997: IFFALSE 18013
// Say ( Powell , D2Rus-Pow-2 ) else
17999: LD_EXP 58
18003: PPUSH
18004: LD_STRING D2Rus-Pow-2
18006: PPUSH
18007: CALL_OW 88
18011: GO 18025
// Say ( Powell , D2Rus-Pow-2a ) ;
18013: LD_EXP 58
18017: PPUSH
18018: LD_STRING D2Rus-Pow-2a
18020: PPUSH
18021: CALL_OW 88
// end ; 3 :
18025: GO 18294
18027: LD_INT 3
18029: DOUBLE
18030: EQUAL
18031: IFTRUE 18035
18033: GO 18120
18035: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18036: LD_EXP 39
18040: PPUSH
18041: LD_STRING D2Leg-JMM-1
18043: PPUSH
18044: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18048: LD_EXP 58
18052: PPUSH
18053: LD_STRING D2Leg-Pow-1
18055: PPUSH
18056: CALL_OW 88
// if 2 in list_of_q then
18060: LD_INT 2
18062: PUSH
18063: LD_VAR 0 2
18067: IN
18068: IFFALSE 18094
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18070: LD_EXP 39
18074: PPUSH
18075: LD_STRING D2Leg-JMM-2
18077: PPUSH
18078: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18082: LD_EXP 58
18086: PPUSH
18087: LD_STRING D2Leg-Pow-2
18089: PPUSH
18090: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18094: LD_EXP 39
18098: PPUSH
18099: LD_STRING D2Leg-JMM-3
18101: PPUSH
18102: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18106: LD_EXP 58
18110: PPUSH
18111: LD_STRING D2Leg-Pow-3
18113: PPUSH
18114: CALL_OW 88
// end ; 4 :
18118: GO 18294
18120: LD_INT 4
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18203
18128: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18129: LD_EXP 39
18133: PPUSH
18134: LD_STRING D2Ar-JMM-1
18136: PPUSH
18137: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18141: LD_EXP 58
18145: PPUSH
18146: LD_STRING D2Ar-Pow-1
18148: PPUSH
18149: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18153: LD_EXP 39
18157: PPUSH
18158: LD_STRING D2Ar-JMM-2
18160: PPUSH
18161: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18165: LD_EXP 58
18169: PPUSH
18170: LD_STRING D2Ar-Pow-2
18172: PPUSH
18173: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18177: LD_EXP 39
18181: PPUSH
18182: LD_STRING D2Ar-JMM-3
18184: PPUSH
18185: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18189: LD_EXP 58
18193: PPUSH
18194: LD_STRING D2Ar-Pow-3
18196: PPUSH
18197: CALL_OW 88
// end ; 5 :
18201: GO 18294
18203: LD_INT 5
18205: DOUBLE
18206: EQUAL
18207: IFTRUE 18211
18209: GO 18226
18211: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18212: LD_EXP 39
18216: PPUSH
18217: LD_STRING D2Conf-JMM-1
18219: PPUSH
18220: CALL_OW 88
18224: GO 18294
18226: LD_INT 6
18228: DOUBLE
18229: EQUAL
18230: IFTRUE 18234
18232: GO 18293
18234: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18235: LD_EXP 39
18239: PPUSH
18240: LD_STRING D2Com-JMM-1
18242: PPUSH
18243: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18247: LD_EXP 58
18251: PPUSH
18252: LD_STRING D2Com-Pow-1
18254: PPUSH
18255: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18259: LD_EXP 39
18263: PPUSH
18264: LD_STRING D2Com-JMM-2
18266: PPUSH
18267: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18271: LD_EXP 58
18275: PPUSH
18276: LD_STRING D2Com-Pow-2
18278: PPUSH
18279: CALL_OW 88
// powellAngerQuery := true ;
18283: LD_ADDR_EXP 36
18287: PUSH
18288: LD_INT 1
18290: ST_TO_ADDR
// end ; end ;
18291: GO 18294
18293: POP
// end ;
18294: LD_VAR 0 3
18298: RET
// every 0 0$5 trigger missionStart do var tmp ;
18299: LD_EXP 13
18303: IFFALSE 18586
18305: GO 18307
18307: DISABLE
18308: LD_INT 0
18310: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18311: LD_INT 35
18313: PPUSH
18314: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18318: LD_INT 14
18320: PPUSH
18321: LD_INT 22
18323: PUSH
18324: LD_INT 1
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PPUSH
18331: CALL_OW 70
18335: PUSH
18336: LD_EXP 15
18340: PUSH
18341: LD_INT 2
18343: PUSH
18344: LD_INT 3
18346: PUSH
18347: LD_INT 4
18349: PUSH
18350: LD_INT 5
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: IN
18359: AND
18360: IFFALSE 18576
// begin powellAnger := powellAnger + 1 ;
18362: LD_ADDR_EXP 17
18366: PUSH
18367: LD_EXP 17
18371: PUSH
18372: LD_INT 1
18374: PLUS
18375: ST_TO_ADDR
// Video ( true ) ;
18376: LD_INT 1
18378: PPUSH
18379: CALL 102594 0 1
// CenterNowOnUnits ( tmp ) ;
18383: LD_VAR 0 1
18387: PPUSH
18388: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18392: LD_INT 14
18394: PPUSH
18395: LD_INT 22
18397: PUSH
18398: LD_INT 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PPUSH
18405: CALL_OW 70
18409: PPUSH
18410: LD_INT 86
18412: PPUSH
18413: LD_INT 133
18415: PPUSH
18416: CALL_OW 111
// async ;
18420: ASYNC
// case powellAnger of 1 :
18421: LD_EXP 17
18425: PUSH
18426: LD_INT 1
18428: DOUBLE
18429: EQUAL
18430: IFTRUE 18434
18432: GO 18449
18434: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18435: LD_EXP 58
18439: PPUSH
18440: LD_STRING DBack1-Pow-1
18442: PPUSH
18443: CALL_OW 88
18447: GO 18496
18449: LD_INT 2
18451: DOUBLE
18452: EQUAL
18453: IFTRUE 18457
18455: GO 18472
18457: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18458: LD_EXP 58
18462: PPUSH
18463: LD_STRING DBack2-Pow-1
18465: PPUSH
18466: CALL_OW 88
18470: GO 18496
18472: LD_INT 3
18474: DOUBLE
18475: EQUAL
18476: IFTRUE 18480
18478: GO 18495
18480: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18481: LD_EXP 58
18485: PPUSH
18486: LD_STRING DBack3-Pow-1
18488: PPUSH
18489: CALL_OW 88
18493: GO 18496
18495: POP
// sync ;
18496: SYNC
// repeat wait ( 0 0$1 ) ;
18497: LD_INT 35
18499: PPUSH
18500: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18504: LD_INT 14
18506: PPUSH
18507: LD_INT 22
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PPUSH
18517: CALL_OW 70
18521: PPUSH
18522: LD_INT 86
18524: PPUSH
18525: LD_INT 133
18527: PPUSH
18528: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18532: LD_INT 14
18534: PPUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 1
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 70
18549: NOT
18550: IFFALSE 18497
// if powellAnger >= 3 then
18552: LD_EXP 17
18556: PUSH
18557: LD_INT 3
18559: GREATEREQUAL
18560: IFFALSE 18569
// YouLost ( Dismissed ) ;
18562: LD_STRING Dismissed
18564: PPUSH
18565: CALL_OW 104
// Video ( false ) ;
18569: LD_INT 0
18571: PPUSH
18572: CALL 102594 0 1
// end ; until missionStage > 5 ;
18576: LD_EXP 15
18580: PUSH
18581: LD_INT 5
18583: GREATER
18584: IFFALSE 18311
// end ;
18586: PPOPN 1
18588: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18589: LD_EXP 13
18593: PUSH
18594: LD_INT 22
18596: PUSH
18597: LD_INT 4
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 21
18606: PUSH
18607: LD_INT 2
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PPUSH
18618: CALL_OW 69
18622: PUSH
18623: LD_INT 4
18625: GREATEREQUAL
18626: AND
18627: PUSH
18628: LD_EXP 15
18632: PUSH
18633: LD_INT 2
18635: EQUAL
18636: AND
18637: IFFALSE 20460
18639: GO 18641
18641: DISABLE
18642: LD_INT 0
18644: PPUSH
18645: PPUSH
18646: PPUSH
18647: PPUSH
18648: PPUSH
18649: PPUSH
18650: PPUSH
18651: PPUSH
// begin missionStage := 3 ;
18652: LD_ADDR_EXP 15
18656: PUSH
18657: LD_INT 3
18659: ST_TO_ADDR
// retreat := false ;
18660: LD_ADDR_VAR 0 4
18664: PUSH
18665: LD_INT 0
18667: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18668: LD_ADDR_VAR 0 5
18672: PUSH
18673: LD_INT 22
18675: PUSH
18676: LD_INT 4
18678: PUSH
18679: EMPTY
18680: LIST
18681: LIST
18682: PUSH
18683: LD_INT 30
18685: PUSH
18686: LD_INT 4
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PPUSH
18697: CALL_OW 69
18701: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18702: LD_ADDR_VAR 0 6
18706: PUSH
18707: LD_INT 22
18709: PUSH
18710: LD_INT 4
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: PUSH
18717: LD_INT 30
18719: PUSH
18720: LD_INT 5
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 69
18735: ST_TO_ADDR
// if not bar then
18736: LD_VAR 0 6
18740: NOT
18741: IFFALSE 18794
// begin repeat wait ( 0 0$1 ) ;
18743: LD_INT 35
18745: PPUSH
18746: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18750: LD_INT 22
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 3
18762: PUSH
18763: LD_INT 57
18765: PUSH
18766: EMPTY
18767: LIST
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: PUSH
18773: LD_INT 30
18775: PUSH
18776: LD_INT 5
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: LIST
18787: PPUSH
18788: CALL_OW 69
18792: IFFALSE 18743
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18794: LD_ADDR_VAR 0 6
18798: PUSH
18799: LD_INT 22
18801: PUSH
18802: LD_INT 4
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 30
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: PPUSH
18823: CALL_OW 69
18827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18828: LD_INT 35
18830: PPUSH
18831: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18835: LD_EXP 135
18839: PUSH
18840: LD_INT 4
18842: ARRAY
18843: PUSH
18844: LD_INT 4
18846: GREATEREQUAL
18847: IFFALSE 18828
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18849: LD_ADDR_VAR 0 2
18853: PUSH
18854: LD_INT 22
18856: PUSH
18857: LD_INT 4
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PUSH
18864: LD_INT 2
18866: PUSH
18867: LD_INT 25
18869: PUSH
18870: LD_INT 1
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PUSH
18877: LD_INT 25
18879: PUSH
18880: LD_INT 2
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: LD_INT 25
18889: PUSH
18890: LD_INT 3
18892: PUSH
18893: EMPTY
18894: LIST
18895: LIST
18896: PUSH
18897: LD_INT 25
18899: PUSH
18900: LD_INT 4
18902: PUSH
18903: EMPTY
18904: LIST
18905: LIST
18906: PUSH
18907: LD_INT 25
18909: PUSH
18910: LD_INT 5
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL_OW 69
18933: PUSH
18934: LD_EXP 58
18938: PUSH
18939: LD_EXP 59
18943: ADD
18944: DIFF
18945: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18946: LD_ADDR_VAR 0 3
18950: PUSH
18951: LD_VAR 0 2
18955: PPUSH
18956: LD_INT 26
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: PPUSH
18966: CALL_OW 72
18970: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18971: LD_ADDR_VAR 0 2
18975: PUSH
18976: LD_VAR 0 2
18980: PUSH
18981: LD_VAR 0 3
18985: DIFF
18986: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18987: LD_ADDR_VAR 0 2
18991: PUSH
18992: LD_VAR 0 2
18996: PPUSH
18997: LD_INT 1
18999: PPUSH
19000: CALL 101128 0 2
19004: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
19005: LD_ADDR_VAR 0 3
19009: PUSH
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL 101128 0 2
19022: ST_TO_ADDR
// for i = 1 to 4 do
19023: LD_ADDR_VAR 0 1
19027: PUSH
19028: DOUBLE
19029: LD_INT 1
19031: DEC
19032: ST_TO_ADDR
19033: LD_INT 4
19035: PUSH
19036: FOR_TO
19037: IFFALSE 19203
// begin if tmp2 then
19039: LD_VAR 0 3
19043: IFFALSE 19124
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19045: LD_ADDR_EXP 18
19049: PUSH
19050: LD_EXP 18
19054: PPUSH
19055: LD_INT 1
19057: PPUSH
19058: LD_EXP 18
19062: PUSH
19063: LD_INT 1
19065: ARRAY
19066: PUSH
19067: LD_VAR 0 3
19071: PUSH
19072: LD_VAR 0 3
19076: ARRAY
19077: ADD
19078: PPUSH
19079: CALL_OW 1
19083: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19084: LD_VAR 0 3
19088: PUSH
19089: LD_VAR 0 3
19093: ARRAY
19094: PPUSH
19095: LD_INT 1
19097: PPUSH
19098: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 3
19111: PPUSH
19112: LD_VAR 0 3
19116: PPUSH
19117: CALL_OW 3
19121: ST_TO_ADDR
// end else
19122: GO 19201
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19124: LD_ADDR_EXP 18
19128: PUSH
19129: LD_EXP 18
19133: PPUSH
19134: LD_INT 1
19136: PPUSH
19137: LD_EXP 18
19141: PUSH
19142: LD_INT 1
19144: ARRAY
19145: PUSH
19146: LD_VAR 0 2
19150: PUSH
19151: LD_VAR 0 2
19155: ARRAY
19156: ADD
19157: PPUSH
19158: CALL_OW 1
19162: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19163: LD_VAR 0 2
19167: PUSH
19168: LD_VAR 0 2
19172: ARRAY
19173: PPUSH
19174: LD_INT 1
19176: PPUSH
19177: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19181: LD_ADDR_VAR 0 2
19185: PUSH
19186: LD_VAR 0 2
19190: PPUSH
19191: LD_VAR 0 2
19195: PPUSH
19196: CALL_OW 3
19200: ST_TO_ADDR
// end ; end ;
19201: GO 19036
19203: POP
19204: POP
// if tmp2 then
19205: LD_VAR 0 3
19209: IFFALSE 19227
// tmp := tmp union tmp2 ;
19211: LD_ADDR_VAR 0 2
19215: PUSH
19216: LD_VAR 0 2
19220: PUSH
19221: LD_VAR 0 3
19225: UNION
19226: ST_TO_ADDR
// for i = 1 to 4 do
19227: LD_ADDR_VAR 0 1
19231: PUSH
19232: DOUBLE
19233: LD_INT 1
19235: DEC
19236: ST_TO_ADDR
19237: LD_INT 4
19239: PUSH
19240: FOR_TO
19241: IFFALSE 19290
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19243: LD_ADDR_EXP 18
19247: PUSH
19248: LD_EXP 18
19252: PPUSH
19253: LD_INT 2
19255: PPUSH
19256: LD_EXP 18
19260: PUSH
19261: LD_INT 2
19263: ARRAY
19264: PUSH
19265: LD_VAR 0 2
19269: PUSH
19270: LD_VAR 0 2
19274: PUSH
19275: LD_VAR 0 1
19279: MINUS
19280: ARRAY
19281: ADD
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
19288: GO 19240
19290: POP
19291: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19292: LD_ADDR_EXP 116
19296: PUSH
19297: LD_EXP 116
19301: PPUSH
19302: LD_INT 4
19304: PPUSH
19305: LD_EXP 116
19309: PUSH
19310: LD_INT 4
19312: ARRAY
19313: PUSH
19314: LD_EXP 18
19318: PUSH
19319: LD_INT 1
19321: ARRAY
19322: DIFF
19323: PPUSH
19324: CALL_OW 1
19328: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19329: LD_VAR 0 5
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PPUSH
19338: CALL_OW 313
19342: IFFALSE 19397
// begin for i in UnitsInside ( arm [ 1 ] ) do
19344: LD_ADDR_VAR 0 1
19348: PUSH
19349: LD_VAR 0 5
19353: PUSH
19354: LD_INT 1
19356: ARRAY
19357: PPUSH
19358: CALL_OW 313
19362: PUSH
19363: FOR_IN
19364: IFFALSE 19395
// begin ComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_VAR 0 6
19384: PUSH
19385: LD_INT 1
19387: ARRAY
19388: PPUSH
19389: CALL_OW 180
// end ;
19393: GO 19363
19395: POP
19396: POP
// end ; wait ( 0 0$3 ) ;
19397: LD_INT 105
19399: PPUSH
19400: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19404: LD_ADDR_VAR 0 1
19408: PUSH
19409: LD_EXP 18
19413: PUSH
19414: LD_INT 1
19416: ARRAY
19417: PUSH
19418: FOR_IN
19419: IFFALSE 19526
// begin if IsInUnit ( i ) then
19421: LD_VAR 0 1
19425: PPUSH
19426: CALL_OW 310
19430: IFFALSE 19441
// ComExitBuilding ( i ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: CALL_OW 122
// if GetClass ( i ) <> 1 then
19441: LD_VAR 0 1
19445: PPUSH
19446: CALL_OW 257
19450: PUSH
19451: LD_INT 1
19453: NONEQUAL
19454: IFFALSE 19495
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19456: LD_VAR 0 1
19460: PPUSH
19461: LD_VAR 0 5
19465: PUSH
19466: LD_INT 1
19468: ARRAY
19469: PPUSH
19470: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 1
19481: PPUSH
19482: CALL_OW 183
// AddComExitBuilding ( i ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19495: LD_VAR 0 1
19499: PPUSH
19500: LD_INT 60
19502: PPUSH
19503: LD_INT 94
19505: PPUSH
19506: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_EXP 58
19519: PPUSH
19520: CALL_OW 179
// end ;
19524: GO 19418
19526: POP
19527: POP
// wait ( 0 0$15 ) ;
19528: LD_INT 525
19530: PPUSH
19531: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19535: LD_EXP 58
19539: PPUSH
19540: LD_STRING D4-Pow-1
19542: PPUSH
19543: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19547: LD_ADDR_VAR 0 2
19551: PUSH
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PPUSH
19561: LD_INT 26
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PPUSH
19571: CALL_OW 72
19575: ST_TO_ADDR
// if tmp then
19576: LD_VAR 0 2
19580: IFFALSE 19598
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19582: LD_VAR 0 2
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: LD_STRING D4-Sol1-1
19593: PPUSH
19594: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19598: LD_EXP 58
19602: PPUSH
19603: LD_STRING D4-Pow-2
19605: PPUSH
19606: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19610: LD_ADDR_VAR 0 1
19614: PUSH
19615: DOUBLE
19616: LD_INT 1
19618: DEC
19619: ST_TO_ADDR
19620: LD_EXP 18
19624: PUSH
19625: LD_INT 1
19627: ARRAY
19628: PUSH
19629: FOR_TO
19630: IFFALSE 19723
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19632: LD_EXP 18
19636: PUSH
19637: LD_INT 1
19639: ARRAY
19640: PUSH
19641: LD_VAR 0 1
19645: ARRAY
19646: PPUSH
19647: LD_EXP 135
19651: PUSH
19652: LD_INT 4
19654: ARRAY
19655: PUSH
19656: LD_INT 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19664: LD_ADDR_EXP 135
19668: PUSH
19669: LD_EXP 135
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 135
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PPUSH
19686: LD_INT 1
19688: PPUSH
19689: CALL_OW 3
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19699: LD_INT 8
19701: PPUSH
19702: LD_EXP 18
19706: PUSH
19707: LD_INT 1
19709: ARRAY
19710: PUSH
19711: LD_VAR 0 1
19715: ARRAY
19716: PPUSH
19717: CALL_OW 471
// end ;
19721: GO 19629
19723: POP
19724: POP
// repeat wait ( 0 0$1 ) ;
19725: LD_INT 35
19727: PPUSH
19728: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19732: LD_EXP 18
19736: PUSH
19737: LD_INT 1
19739: ARRAY
19740: PPUSH
19741: LD_INT 55
19743: PUSH
19744: EMPTY
19745: LIST
19746: PPUSH
19747: CALL_OW 72
19751: PUSH
19752: LD_INT 4
19754: GREATEREQUAL
19755: IFFALSE 19725
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19757: LD_EXP 18
19761: PUSH
19762: LD_INT 1
19764: ARRAY
19765: PPUSH
19766: LD_INT 69
19768: PPUSH
19769: LD_INT 94
19771: PPUSH
19772: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19776: LD_EXP 18
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_INT 82
19787: PPUSH
19788: LD_INT 83
19790: PPUSH
19791: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PPUSH
19804: LD_INT 77
19806: PPUSH
19807: LD_INT 69
19809: PPUSH
19810: CALL_OW 174
// repeat wait ( 3 ) ;
19814: LD_INT 3
19816: PPUSH
19817: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19821: LD_ADDR_VAR 0 1
19825: PUSH
19826: LD_EXP 18
19830: PUSH
19831: LD_INT 1
19833: ARRAY
19834: PUSH
19835: FOR_IN
19836: IFFALSE 19972
// begin if GetLives ( i ) < 990 then
19838: LD_VAR 0 1
19842: PPUSH
19843: CALL_OW 256
19847: PUSH
19848: LD_INT 990
19850: LESS
19851: IFFALSE 19865
// SetLives ( i , 1000 ) ;
19853: LD_VAR 0 1
19857: PPUSH
19858: LD_INT 1000
19860: PPUSH
19861: CALL_OW 234
// if not IsInUnit ( i ) then
19865: LD_VAR 0 1
19869: PPUSH
19870: CALL_OW 310
19874: NOT
19875: IFFALSE 19970
// begin if not HasTask ( i ) then
19877: LD_VAR 0 1
19881: PPUSH
19882: CALL_OW 314
19886: NOT
19887: IFFALSE 19904
// ComMoveXY ( i , 64 , 93 ) ;
19889: LD_VAR 0 1
19893: PPUSH
19894: LD_INT 64
19896: PPUSH
19897: LD_INT 93
19899: PPUSH
19900: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19904: LD_VAR 0 4
19908: NOT
19909: PUSH
19910: LD_VAR 0 1
19914: PPUSH
19915: CALL_OW 258
19919: PUSH
19920: LD_INT 1
19922: EQUAL
19923: AND
19924: IFFALSE 19970
// begin retreat := true ;
19926: LD_ADDR_VAR 0 4
19930: PUSH
19931: LD_INT 1
19933: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19934: LD_VAR 0 1
19938: PPUSH
19939: LD_INT 2
19941: PPUSH
19942: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19946: LD_VAR 0 1
19950: PPUSH
19951: LD_STRING D4a-Sol1-1
19953: PPUSH
19954: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19958: LD_EXP 58
19962: PPUSH
19963: LD_STRING D4a-Pow-1
19965: PPUSH
19966: CALL_OW 88
// end ; end ; end ;
19970: GO 19835
19972: POP
19973: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19974: LD_EXP 18
19978: PUSH
19979: LD_INT 1
19981: ARRAY
19982: PPUSH
19983: LD_INT 95
19985: PUSH
19986: LD_INT 9
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PUSH
19993: LD_INT 3
19995: PUSH
19996: LD_INT 55
19998: PUSH
19999: EMPTY
20000: LIST
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: PUSH
20015: LD_INT 4
20017: GREATEREQUAL
20018: IFFALSE 19814
// for i in powellSquadAttack [ 1 ] do
20020: LD_ADDR_VAR 0 1
20024: PUSH
20025: LD_EXP 18
20029: PUSH
20030: LD_INT 1
20032: ARRAY
20033: PUSH
20034: FOR_IN
20035: IFFALSE 20171
// begin if GetTag ( i ) = 2 then
20037: LD_VAR 0 1
20041: PPUSH
20042: CALL_OW 110
20046: PUSH
20047: LD_INT 2
20049: EQUAL
20050: IFFALSE 20112
// begin ComMoveXY ( i , 60 , 94 ) ;
20052: LD_VAR 0 1
20056: PPUSH
20057: LD_INT 60
20059: PPUSH
20060: LD_INT 94
20062: PPUSH
20063: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20067: LD_VAR 0 1
20071: PPUSH
20072: LD_EXP 58
20076: PPUSH
20077: CALL_OW 179
// wait ( 0 0$3 ) ;
20081: LD_INT 105
20083: PPUSH
20084: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20088: LD_VAR 0 1
20092: PPUSH
20093: LD_STRING D4a-Sol1-2
20095: PPUSH
20096: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20100: LD_EXP 58
20104: PPUSH
20105: LD_STRING D4a-Pow-2
20107: PPUSH
20108: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20112: LD_VAR 0 1
20116: PPUSH
20117: LD_INT 0
20119: PPUSH
20120: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20124: LD_ADDR_EXP 116
20128: PUSH
20129: LD_EXP 116
20133: PPUSH
20134: LD_INT 4
20136: PPUSH
20137: LD_EXP 116
20141: PUSH
20142: LD_INT 4
20144: ARRAY
20145: PUSH
20146: LD_VAR 0 1
20150: UNION
20151: PPUSH
20152: CALL_OW 1
20156: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20157: LD_INT 8
20159: PPUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: CALL_OW 472
// end ;
20169: GO 20034
20171: POP
20172: POP
// wait ( 4 4$00 ) ;
20173: LD_INT 8400
20175: PPUSH
20176: CALL_OW 67
// uc_side := 6 ;
20180: LD_ADDR_OWVAR 20
20184: PUSH
20185: LD_INT 6
20187: ST_TO_ADDR
// uc_nation := 3 ;
20188: LD_ADDR_OWVAR 21
20192: PUSH
20193: LD_INT 3
20195: ST_TO_ADDR
// ru := [ ] ;
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: EMPTY
20202: ST_TO_ADDR
// for i = 1 to 4 do
20203: LD_ADDR_VAR 0 1
20207: PUSH
20208: DOUBLE
20209: LD_INT 1
20211: DEC
20212: ST_TO_ADDR
20213: LD_INT 4
20215: PUSH
20216: FOR_TO
20217: IFFALSE 20318
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20219: LD_INT 22
20221: PPUSH
20222: LD_INT 1
20224: PPUSH
20225: LD_INT 3
20227: PPUSH
20228: LD_INT 43
20230: PUSH
20231: LD_INT 44
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PUSH
20238: LD_INT 1
20240: PPUSH
20241: LD_INT 2
20243: PPUSH
20244: CALL_OW 12
20248: ARRAY
20249: PPUSH
20250: LD_INT 89
20252: PPUSH
20253: CALL 70749 0 5
// un := CreateVehicle ;
20257: LD_ADDR_VAR 0 8
20261: PUSH
20262: CALL_OW 45
20266: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20267: LD_VAR 0 8
20271: PPUSH
20272: LD_INT 4
20274: PPUSH
20275: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20279: LD_VAR 0 8
20283: PPUSH
20284: LD_INT 136
20286: PPUSH
20287: LD_INT 90
20289: PPUSH
20290: LD_INT 8
20292: PPUSH
20293: LD_INT 0
20295: PPUSH
20296: CALL_OW 50
// ru := ru ^ un ;
20300: LD_ADDR_VAR 0 7
20304: PUSH
20305: LD_VAR 0 7
20309: PUSH
20310: LD_VAR 0 8
20314: ADD
20315: ST_TO_ADDR
// end ;
20316: GO 20216
20318: POP
20319: POP
// if ru then
20320: LD_VAR 0 7
20324: IFFALSE 20341
// ComAgressiveMove ( ru , 80 , 92 ) ;
20326: LD_VAR 0 7
20330: PPUSH
20331: LD_INT 80
20333: PPUSH
20334: LD_INT 92
20336: PPUSH
20337: CALL_OW 114
// wait ( 8 8$00 ) ;
20341: LD_INT 16800
20343: PPUSH
20344: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20348: LD_INT 4
20350: PPUSH
20351: LD_INT 3
20353: PUSH
20354: LD_INT 1
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: LD_INT 5
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 4
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: LD_INT 1
20377: PUSH
20378: LD_INT 6
20380: PUSH
20381: EMPTY
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 4
20389: PUSH
20390: LD_INT 1
20392: PUSH
20393: LD_INT 1
20395: PUSH
20396: LD_INT 7
20398: PUSH
20399: EMPTY
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: PUSH
20405: LD_INT 3
20407: PUSH
20408: LD_INT 1
20410: PUSH
20411: LD_INT 1
20413: PUSH
20414: LD_INT 7
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 3
20425: PUSH
20426: LD_INT 1
20428: PUSH
20429: LD_INT 1
20431: PUSH
20432: LD_INT 5
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PPUSH
20448: CALL 59431 0 2
// missionStage := 4 ;
20452: LD_ADDR_EXP 15
20456: PUSH
20457: LD_INT 4
20459: ST_TO_ADDR
// end ;
20460: PPOPN 8
20462: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20463: LD_EXP 15
20467: PUSH
20468: LD_INT 4
20470: EQUAL
20471: PUSH
20472: LD_INT 22
20474: PUSH
20475: LD_INT 4
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: LD_INT 21
20484: PUSH
20485: LD_INT 2
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PPUSH
20496: CALL_OW 69
20500: PUSH
20501: LD_INT 5
20503: GREATEREQUAL
20504: AND
20505: IFFALSE 24626
20507: GO 20509
20509: DISABLE
20510: LD_INT 0
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
20517: PPUSH
20518: PPUSH
20519: PPUSH
20520: PPUSH
20521: PPUSH
20522: PPUSH
20523: PPUSH
20524: PPUSH
// begin missionStage := 5 ;
20525: LD_ADDR_EXP 15
20529: PUSH
20530: LD_INT 5
20532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20533: LD_ADDR_VAR 0 10
20537: PUSH
20538: LD_INT 22
20540: PUSH
20541: LD_INT 4
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 4
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: PUSH
20561: LD_INT 30
20563: PUSH
20564: LD_INT 5
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PPUSH
20580: CALL_OW 69
20584: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20585: LD_ADDR_VAR 0 6
20589: PUSH
20590: LD_INT 22
20592: PUSH
20593: LD_INT 4
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: PUSH
20600: LD_INT 21
20602: PUSH
20603: LD_INT 1
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 3
20612: PUSH
20613: LD_INT 25
20615: PUSH
20616: LD_INT 16
20618: PUSH
20619: EMPTY
20620: LIST
20621: LIST
20622: PUSH
20623: EMPTY
20624: LIST
20625: LIST
20626: PUSH
20627: LD_INT 3
20629: PUSH
20630: LD_INT 25
20632: PUSH
20633: LD_INT 12
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: PPUSH
20650: CALL_OW 69
20654: PUSH
20655: LD_EXP 58
20659: DIFF
20660: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20661: LD_ADDR_VAR 0 9
20665: PUSH
20666: LD_INT 22
20668: PUSH
20669: LD_INT 4
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: PUSH
20676: LD_INT 30
20678: PUSH
20679: LD_INT 3
20681: PUSH
20682: EMPTY
20683: LIST
20684: LIST
20685: PUSH
20686: EMPTY
20687: LIST
20688: LIST
20689: PPUSH
20690: CALL_OW 69
20694: PUSH
20695: LD_INT 1
20697: ARRAY
20698: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20699: LD_INT 35
20701: PPUSH
20702: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20706: LD_EXP 135
20710: PUSH
20711: LD_INT 4
20713: ARRAY
20714: PUSH
20715: LD_INT 5
20717: GREATEREQUAL
20718: PUSH
20719: LD_EXP 135
20723: PUSH
20724: LD_INT 4
20726: ARRAY
20727: PPUSH
20728: LD_INT 58
20730: PUSH
20731: EMPTY
20732: LIST
20733: PPUSH
20734: CALL_OW 72
20738: PUSH
20739: LD_INT 5
20741: GREATEREQUAL
20742: AND
20743: IFFALSE 20699
// powellAllowRetreat := false ;
20745: LD_ADDR_EXP 19
20749: PUSH
20750: LD_INT 0
20752: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20753: LD_INT 700
20755: PPUSH
20756: CALL_OW 67
// activeAttacks := false ;
20760: LD_ADDR_EXP 16
20764: PUSH
20765: LD_INT 0
20767: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20768: LD_INT 35
20770: PPUSH
20771: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20775: LD_INT 22
20777: PUSH
20778: LD_INT 6
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: PPUSH
20785: CALL_OW 69
20789: PUSH
20790: LD_INT 0
20792: EQUAL
20793: IFFALSE 20768
// tmp := mc_vehicles [ 4 ] ;
20795: LD_ADDR_VAR 0 3
20799: PUSH
20800: LD_EXP 135
20804: PUSH
20805: LD_INT 4
20807: ARRAY
20808: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20809: LD_ADDR_VAR 0 1
20813: PUSH
20814: DOUBLE
20815: LD_INT 1
20817: DEC
20818: ST_TO_ADDR
20819: LD_EXP 18
20823: PUSH
20824: FOR_TO
20825: IFFALSE 21086
// begin for j in powellSquadAttack [ i ] do
20827: LD_ADDR_VAR 0 2
20831: PUSH
20832: LD_EXP 18
20836: PUSH
20837: LD_VAR 0 1
20841: ARRAY
20842: PUSH
20843: FOR_IN
20844: IFFALSE 21082
// begin forces := forces diff j ;
20846: LD_ADDR_VAR 0 6
20850: PUSH
20851: LD_VAR 0 6
20855: PUSH
20856: LD_VAR 0 2
20860: DIFF
20861: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20862: LD_VAR 0 2
20866: PPUSH
20867: LD_INT 1
20869: PPUSH
20870: CALL_OW 109
// wait ( 0 0$2 ) ;
20874: LD_INT 70
20876: PPUSH
20877: CALL_OW 67
// if IsInUnit ( j ) then
20881: LD_VAR 0 2
20885: PPUSH
20886: CALL_OW 310
20890: IFFALSE 20901
// ComExitBuilding ( j ) ;
20892: LD_VAR 0 2
20896: PPUSH
20897: CALL_OW 122
// if GetClass ( j ) <> 1 then
20901: LD_VAR 0 2
20905: PPUSH
20906: CALL_OW 257
20910: PUSH
20911: LD_INT 1
20913: NONEQUAL
20914: IFFALSE 20994
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20916: LD_VAR 0 10
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PPUSH
20925: CALL_OW 313
20929: PUSH
20930: LD_INT 5
20932: GREATEREQUAL
20933: IFFALSE 20955
// AddComEnterUnit ( j , arm [ 2 ] ) else
20935: LD_VAR 0 2
20939: PPUSH
20940: LD_VAR 0 10
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: PPUSH
20949: CALL_OW 180
20953: GO 20973
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20955: LD_VAR 0 2
20959: PPUSH
20960: LD_VAR 0 10
20964: PUSH
20965: LD_INT 1
20967: ARRAY
20968: PPUSH
20969: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20973: LD_VAR 0 2
20977: PPUSH
20978: LD_INT 1
20980: PPUSH
20981: CALL_OW 183
// AddComExitBuilding ( j ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: CALL_OW 182
// end ; if i = 2 then
20994: LD_VAR 0 1
20998: PUSH
20999: LD_INT 2
21001: EQUAL
21002: IFFALSE 21019
// AddComMoveXY ( j , 61 , 93 ) ;
21004: LD_VAR 0 2
21008: PPUSH
21009: LD_INT 61
21011: PPUSH
21012: LD_INT 93
21014: PPUSH
21015: CALL_OW 171
// if i = 1 then
21019: LD_VAR 0 1
21023: PUSH
21024: LD_INT 1
21026: EQUAL
21027: IFFALSE 21080
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21029: LD_VAR 0 2
21033: PPUSH
21034: LD_VAR 0 3
21038: PUSH
21039: LD_INT 1
21041: ARRAY
21042: PPUSH
21043: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21047: LD_ADDR_VAR 0 3
21051: PUSH
21052: LD_VAR 0 3
21056: PPUSH
21057: LD_INT 1
21059: PPUSH
21060: CALL_OW 3
21064: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21065: LD_VAR 0 2
21069: PPUSH
21070: LD_INT 69
21072: PPUSH
21073: LD_INT 94
21075: PPUSH
21076: CALL_OW 171
// end ; end ;
21080: GO 20843
21082: POP
21083: POP
// end ;
21084: GO 20824
21086: POP
21087: POP
// wait ( 0 0$55 ) ;
21088: LD_INT 1925
21090: PPUSH
21091: CALL_OW 67
// MC_Kill ( 4 ) ;
21095: LD_INT 4
21097: PPUSH
21098: CALL 35501 0 1
// tmp := UnitsInside ( fac ) ;
21102: LD_ADDR_VAR 0 3
21106: PUSH
21107: LD_VAR 0 9
21111: PPUSH
21112: CALL_OW 313
21116: ST_TO_ADDR
// if tmp then
21117: LD_VAR 0 3
21121: IFFALSE 21242
// for i in tmp do
21123: LD_ADDR_VAR 0 1
21127: PUSH
21128: LD_VAR 0 3
21132: PUSH
21133: FOR_IN
21134: IFFALSE 21240
// begin ComExitBuilding ( i ) ;
21136: LD_VAR 0 1
21140: PPUSH
21141: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21145: LD_VAR 0 10
21149: PUSH
21150: LD_INT 2
21152: ARRAY
21153: PPUSH
21154: CALL_OW 313
21158: PUSH
21159: LD_INT 6
21161: LESS
21162: IFFALSE 21184
// AddComEnterUnit ( i , arm [ 2 ] ) else
21164: LD_VAR 0 1
21168: PPUSH
21169: LD_VAR 0 10
21173: PUSH
21174: LD_INT 2
21176: ARRAY
21177: PPUSH
21178: CALL_OW 180
21182: GO 21238
// if UnitsInside ( arm [ 1 ] ) < 6 then
21184: LD_VAR 0 10
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PPUSH
21193: CALL_OW 313
21197: PUSH
21198: LD_INT 6
21200: LESS
21201: IFFALSE 21223
// AddComEnterUnit ( i , arm [ 1 ] ) else
21203: LD_VAR 0 1
21207: PPUSH
21208: LD_VAR 0 10
21212: PUSH
21213: LD_INT 1
21215: ARRAY
21216: PPUSH
21217: CALL_OW 180
21221: GO 21238
// AddComMoveXY ( i , 37 , 68 ) ;
21223: LD_VAR 0 1
21227: PPUSH
21228: LD_INT 37
21230: PPUSH
21231: LD_INT 68
21233: PPUSH
21234: CALL_OW 171
// end ;
21238: GO 21133
21240: POP
21241: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21242: LD_ADDR_VAR 0 11
21246: PUSH
21247: LD_VAR 0 6
21251: PPUSH
21252: LD_INT 26
21254: PUSH
21255: LD_INT 1
21257: PUSH
21258: EMPTY
21259: LIST
21260: LIST
21261: PPUSH
21262: CALL_OW 72
21266: PUSH
21267: LD_EXP 59
21271: DIFF
21272: ST_TO_ADDR
// if not speaker then
21273: LD_VAR 0 11
21277: NOT
21278: IFFALSE 21305
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21280: LD_ADDR_VAR 0 11
21284: PUSH
21285: LD_VAR 0 6
21289: PPUSH
21290: LD_INT 26
21292: PUSH
21293: LD_INT 1
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: PPUSH
21300: CALL_OW 72
21304: ST_TO_ADDR
// if speaker then
21305: LD_VAR 0 11
21309: IFFALSE 21325
// speaker := speaker [ 1 ] ;
21311: LD_ADDR_VAR 0 11
21315: PUSH
21316: LD_VAR 0 11
21320: PUSH
21321: LD_INT 1
21323: ARRAY
21324: ST_TO_ADDR
// Video ( true ) ;
21325: LD_INT 1
21327: PPUSH
21328: CALL 102594 0 1
// CenterNowOnUnits ( Powell ) ;
21332: LD_EXP 58
21336: PPUSH
21337: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_VAR 0 6
21350: PPUSH
21351: LD_INT 3
21353: PUSH
21354: LD_INT 25
21356: PUSH
21357: LD_INT 1
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 72
21372: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21373: LD_ADDR_VAR 0 12
21377: PUSH
21378: LD_INT 22
21380: PUSH
21381: LD_INT 4
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: PUSH
21388: LD_INT 30
21390: PUSH
21391: LD_INT 32
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: PUSH
21398: LD_INT 58
21400: PUSH
21401: EMPTY
21402: LIST
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: LIST
21408: PPUSH
21409: CALL_OW 69
21413: ST_TO_ADDR
// for i = 1 to 6 do
21414: LD_ADDR_VAR 0 1
21418: PUSH
21419: DOUBLE
21420: LD_INT 1
21422: DEC
21423: ST_TO_ADDR
21424: LD_INT 6
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21569
// begin if IsInUnit ( tmp [ i ] ) then
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 310
21445: IFFALSE 21462
// ComExitBuilding ( tmp [ i ] ) ;
21447: LD_VAR 0 3
21451: PUSH
21452: LD_VAR 0 1
21456: ARRAY
21457: PPUSH
21458: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21462: LD_VAR 0 3
21466: PUSH
21467: LD_VAR 0 1
21471: ARRAY
21472: PPUSH
21473: LD_VAR 0 10
21477: PUSH
21478: LD_INT 1
21480: ARRAY
21481: PPUSH
21482: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21486: LD_VAR 0 3
21490: PUSH
21491: LD_VAR 0 1
21495: ARRAY
21496: PPUSH
21497: LD_INT 1
21499: PPUSH
21500: CALL_OW 183
// if emp_towers then
21504: LD_VAR 0 12
21508: IFFALSE 21567
// begin AddComExitBuilding ( tmp [ i ] ) ;
21510: LD_VAR 0 3
21514: PUSH
21515: LD_VAR 0 1
21519: ARRAY
21520: PPUSH
21521: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21525: LD_VAR 0 3
21529: PUSH
21530: LD_VAR 0 1
21534: ARRAY
21535: PPUSH
21536: LD_VAR 0 12
21540: PUSH
21541: LD_INT 1
21543: ARRAY
21544: PPUSH
21545: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21549: LD_ADDR_VAR 0 12
21553: PUSH
21554: LD_VAR 0 12
21558: PPUSH
21559: LD_INT 1
21561: PPUSH
21562: CALL_OW 3
21566: ST_TO_ADDR
// end ; end ;
21567: GO 21427
21569: POP
21570: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21571: LD_ADDR_VAR 0 3
21575: PUSH
21576: LD_EXP 18
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PUSH
21585: LD_EXP 18
21589: PUSH
21590: LD_INT 2
21592: ARRAY
21593: ADD
21594: PPUSH
21595: LD_INT 26
21597: PUSH
21598: LD_INT 1
21600: PUSH
21601: EMPTY
21602: LIST
21603: LIST
21604: PPUSH
21605: CALL_OW 72
21609: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21610: LD_ADDR_VAR 0 1
21614: PUSH
21615: LD_EXP 18
21619: PUSH
21620: LD_INT 2
21622: ARRAY
21623: PUSH
21624: FOR_IN
21625: IFFALSE 21643
// ComTurnUnit ( i , Powell ) ;
21627: LD_VAR 0 1
21631: PPUSH
21632: LD_EXP 58
21636: PPUSH
21637: CALL_OW 119
21641: GO 21624
21643: POP
21644: POP
// Say ( Powell , D5-Pow-1 ) ;
21645: LD_EXP 58
21649: PPUSH
21650: LD_STRING D5-Pow-1
21652: PPUSH
21653: CALL_OW 88
// if tmp then
21657: LD_VAR 0 3
21661: IFFALSE 21679
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 1
21670: ARRAY
21671: PPUSH
21672: LD_STRING D5-Sol2-1
21674: PPUSH
21675: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21679: LD_EXP 58
21683: PPUSH
21684: LD_STRING D5-Pow-2
21686: PPUSH
21687: CALL_OW 88
// if tmp > 1 then
21691: LD_VAR 0 3
21695: PUSH
21696: LD_INT 1
21698: GREATER
21699: IFFALSE 21717
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21701: LD_VAR 0 3
21705: PUSH
21706: LD_INT 2
21708: ARRAY
21709: PPUSH
21710: LD_STRING D5-Sol2-2
21712: PPUSH
21713: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21717: LD_EXP 58
21721: PPUSH
21722: LD_STRING D5-Pow-3
21724: PPUSH
21725: CALL_OW 88
// wait ( 0 0$1 ) ;
21729: LD_INT 35
21731: PPUSH
21732: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21736: LD_ADDR_VAR 0 3
21740: PUSH
21741: LD_EXP 18
21745: PUSH
21746: LD_INT 1
21748: ARRAY
21749: PUSH
21750: LD_EXP 18
21754: PUSH
21755: LD_INT 2
21757: ARRAY
21758: UNION
21759: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21760: LD_VAR 0 3
21764: PPUSH
21765: LD_INT 80
21767: PPUSH
21768: LD_INT 67
21770: PPUSH
21771: CALL_OW 114
// wait ( 0 0$2 ) ;
21775: LD_INT 70
21777: PPUSH
21778: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21782: LD_INT 79
21784: PPUSH
21785: LD_INT 72
21787: PPUSH
21788: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21792: LD_INT 35
21794: PPUSH
21795: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21799: LD_VAR 0 3
21803: PPUSH
21804: LD_INT 3
21806: PUSH
21807: LD_INT 24
21809: PUSH
21810: LD_INT 1000
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PPUSH
21821: CALL_OW 72
21825: IFFALSE 21792
// Say ( Powell , D5a-Pow-1 ) ;
21827: LD_EXP 58
21831: PPUSH
21832: LD_STRING D5a-Pow-1
21834: PPUSH
21835: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21839: LD_EXP 58
21843: PPUSH
21844: LD_STRING D5a-Pow-1a
21846: PPUSH
21847: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21851: LD_INT 10
21853: PPUSH
21854: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21858: LD_EXP 58
21862: PPUSH
21863: LD_STRING D5a-Pow-1b
21865: PPUSH
21866: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21870: LD_EXP 58
21874: PPUSH
21875: LD_STRING D5a-Pow-1c
21877: PPUSH
21878: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21882: LD_EXP 58
21886: PPUSH
21887: LD_STRING D5a-Pow-1d
21889: PPUSH
21890: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21894: LD_INT 35
21896: PPUSH
21897: CALL_OW 67
// if not HasTask ( tmp ) then
21901: LD_VAR 0 3
21905: PPUSH
21906: CALL_OW 314
21910: NOT
21911: IFFALSE 21928
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21913: LD_VAR 0 3
21917: PPUSH
21918: LD_INT 80
21920: PPUSH
21921: LD_INT 67
21923: PPUSH
21924: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21928: LD_VAR 0 3
21932: PPUSH
21933: LD_INT 24
21935: PUSH
21936: LD_INT 1
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: PPUSH
21943: CALL_OW 72
21947: NOT
21948: IFFALSE 21894
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21950: LD_ADDR_VAR 0 3
21954: PUSH
21955: LD_INT 22
21957: PUSH
21958: LD_INT 4
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: LD_INT 92
21967: PUSH
21968: LD_INT 60
21970: PUSH
21971: LD_INT 93
21973: PUSH
21974: LD_INT 10
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 3
21985: PUSH
21986: LD_INT 54
21988: PUSH
21989: EMPTY
21990: LIST
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: PPUSH
22001: CALL_OW 69
22005: PUSH
22006: LD_EXP 58
22010: DIFF
22011: ST_TO_ADDR
// if tmp then
22012: LD_VAR 0 3
22016: IFFALSE 22050
// for i in tmp do
22018: LD_ADDR_VAR 0 1
22022: PUSH
22023: LD_VAR 0 3
22027: PUSH
22028: FOR_IN
22029: IFFALSE 22048
// ComMoveXY ( i , 36 , 67 ) ;
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_INT 36
22038: PPUSH
22039: LD_INT 67
22041: PPUSH
22042: CALL_OW 111
22046: GO 22028
22048: POP
22049: POP
// wait ( 0 0$3 ) ;
22050: LD_INT 105
22052: PPUSH
22053: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22057: LD_VAR 0 11
22061: PPUSH
22062: LD_STRING D6-Sol3-1
22064: PPUSH
22065: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22069: LD_EXP 58
22073: PPUSH
22074: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22078: LD_EXP 58
22082: PPUSH
22083: LD_STRING D6-Pow-1
22085: PPUSH
22086: CALL_OW 88
// tmp := [ ] ;
22090: LD_ADDR_VAR 0 3
22094: PUSH
22095: EMPTY
22096: ST_TO_ADDR
// for i = 1 to 2 do
22097: LD_ADDR_VAR 0 1
22101: PUSH
22102: DOUBLE
22103: LD_INT 1
22105: DEC
22106: ST_TO_ADDR
22107: LD_INT 2
22109: PUSH
22110: FOR_TO
22111: IFFALSE 22225
// begin uc_side := 8 ;
22113: LD_ADDR_OWVAR 20
22117: PUSH
22118: LD_INT 8
22120: ST_TO_ADDR
// uc_nation := 2 ;
22121: LD_ADDR_OWVAR 21
22125: PUSH
22126: LD_INT 2
22128: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22129: LD_INT 14
22131: PPUSH
22132: LD_INT 3
22134: PPUSH
22135: LD_INT 2
22137: PPUSH
22138: LD_INT 29
22140: PPUSH
22141: LD_INT 100
22143: PPUSH
22144: CALL 70749 0 5
// veh := CreateVehicle ;
22148: LD_ADDR_VAR 0 13
22152: PUSH
22153: CALL_OW 45
22157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22158: LD_VAR 0 13
22162: PPUSH
22163: LD_INT 4
22165: PPUSH
22166: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22170: LD_VAR 0 13
22174: PPUSH
22175: LD_INT 99
22177: PPUSH
22178: LD_INT 83
22180: PPUSH
22181: LD_INT 6
22183: PPUSH
22184: LD_INT 0
22186: PPUSH
22187: CALL_OW 50
// wait ( 3 ) ;
22191: LD_INT 3
22193: PPUSH
22194: CALL_OW 67
// Connect ( veh ) ;
22198: LD_VAR 0 13
22202: PPUSH
22203: CALL 73842 0 1
// tmp := tmp ^ veh ;
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_VAR 0 3
22216: PUSH
22217: LD_VAR 0 13
22221: ADD
22222: ST_TO_ADDR
// end ;
22223: GO 22110
22225: POP
22226: POP
// wait ( 0 0$1 ) ;
22227: LD_INT 35
22229: PPUSH
22230: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22234: LD_INT 99
22236: PPUSH
22237: LD_INT 83
22239: PPUSH
22240: LD_INT 1
22242: PPUSH
22243: LD_INT 10
22245: PPUSH
22246: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22250: LD_INT 99
22252: PPUSH
22253: LD_INT 83
22255: PPUSH
22256: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22260: LD_VAR 0 11
22264: PPUSH
22265: LD_STRING D6-Sol3-2
22267: PPUSH
22268: CALL_OW 88
// async ;
22272: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22273: LD_EXP 58
22277: PPUSH
22278: LD_STRING D6-Pow-2
22280: PPUSH
22281: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22285: LD_VAR 0 3
22289: PUSH
22290: LD_INT 1
22292: ARRAY
22293: PPUSH
22294: LD_VAR 0 9
22298: PPUSH
22299: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22303: LD_VAR 0 3
22307: PUSH
22308: LD_INT 2
22310: ARRAY
22311: PPUSH
22312: LD_INT 22
22314: PUSH
22315: LD_INT 4
22317: PUSH
22318: EMPTY
22319: LIST
22320: LIST
22321: PUSH
22322: LD_INT 21
22324: PUSH
22325: LD_INT 3
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: PPUSH
22336: CALL_OW 69
22340: PPUSH
22341: LD_VAR 0 3
22345: PUSH
22346: LD_INT 2
22348: ARRAY
22349: PPUSH
22350: CALL_OW 74
22354: PPUSH
22355: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22359: LD_EXP 58
22363: PPUSH
22364: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22368: LD_INT 99
22370: PPUSH
22371: LD_INT 83
22373: PPUSH
22374: LD_INT 1
22376: PPUSH
22377: CALL_OW 331
// repeat wait ( 4 ) ;
22381: LD_INT 4
22383: PPUSH
22384: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22388: LD_VAR 0 3
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PPUSH
22397: CALL_OW 256
22401: PUSH
22402: LD_INT 1000
22404: LESS
22405: IFFALSE 22423
// SetLives ( tmp [ 1 ] , 1000 ) ;
22407: LD_VAR 0 3
22411: PUSH
22412: LD_INT 1
22414: ARRAY
22415: PPUSH
22416: LD_INT 1000
22418: PPUSH
22419: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22423: LD_INT 22
22425: PUSH
22426: LD_INT 4
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: PUSH
22433: LD_INT 30
22435: PUSH
22436: LD_INT 3
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PPUSH
22447: CALL_OW 69
22451: PUSH
22452: LD_INT 0
22454: EQUAL
22455: IFFALSE 22381
// skirmish := false ;
22457: LD_ADDR_EXP 114
22461: PUSH
22462: LD_INT 0
22464: ST_TO_ADDR
// sync ;
22465: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22466: LD_EXP 58
22470: PPUSH
22471: LD_STRING D6a-Pow-1
22473: PPUSH
22474: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22478: LD_VAR 0 11
22482: PPUSH
22483: LD_STRING D6a-Sol3-1
22485: PPUSH
22486: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22490: LD_EXP 58
22494: PPUSH
22495: LD_STRING D6a-Pow-2
22497: PPUSH
22498: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22502: LD_VAR 0 11
22506: PPUSH
22507: LD_STRING D6a-Sol3-2
22509: PPUSH
22510: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22514: LD_EXP 58
22518: PPUSH
22519: LD_STRING D6a-Pow-3
22521: PPUSH
22522: CALL_OW 88
// powellCenterCameraMode := true ;
22526: LD_ADDR_EXP 20
22530: PUSH
22531: LD_INT 1
22533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22534: LD_ADDR_VAR 0 1
22538: PUSH
22539: LD_INT 22
22541: PUSH
22542: LD_INT 8
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: PUSH
22549: LD_INT 25
22551: PUSH
22552: LD_INT 2
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 69
22567: PUSH
22568: FOR_IN
22569: IFFALSE 22624
// begin SetTag ( i , 1 ) ;
22571: LD_VAR 0 1
22575: PPUSH
22576: LD_INT 1
22578: PPUSH
22579: CALL_OW 109
// ComExitBuilding ( i ) ;
22583: LD_VAR 0 1
22587: PPUSH
22588: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22592: LD_VAR 0 1
22596: PPUSH
22597: LD_INT 35
22599: PPUSH
22600: LD_INT 6
22602: PPUSH
22603: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: LD_INT 4
22617: PPUSH
22618: CALL_OW 171
// end ;
22622: GO 22568
22624: POP
22625: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22626: LD_ADDR_VAR 0 3
22630: PUSH
22631: LD_INT 22
22633: PUSH
22634: LD_INT 4
22636: PUSH
22637: EMPTY
22638: LIST
22639: LIST
22640: PUSH
22641: LD_INT 21
22643: PUSH
22644: LD_INT 2
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: LD_INT 3
22653: PUSH
22654: LD_INT 34
22656: PUSH
22657: LD_INT 12
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: LIST
22672: PPUSH
22673: CALL_OW 69
22677: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22678: LD_EXP 58
22682: PPUSH
22683: LD_VAR 0 3
22687: PPUSH
22688: LD_EXP 58
22692: PPUSH
22693: CALL_OW 74
22697: PPUSH
22698: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22702: LD_EXP 58
22706: PPUSH
22707: LD_INT 100
22709: PPUSH
22710: LD_INT 88
22712: PPUSH
22713: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_INT 100
22724: PPUSH
22725: LD_INT 75
22727: PPUSH
22728: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22732: LD_EXP 58
22736: PPUSH
22737: LD_INT 88
22739: PPUSH
22740: LD_INT 53
22742: PPUSH
22743: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22747: LD_INT 8
22749: PPUSH
22750: LD_EXP 58
22754: PPUSH
22755: CALL_OW 471
// repeat wait ( 3 ) ;
22759: LD_INT 3
22761: PPUSH
22762: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22766: LD_INT 22
22768: PUSH
22769: LD_INT 4
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 92
22778: PUSH
22779: LD_INT 100
22781: PUSH
22782: LD_INT 75
22784: PUSH
22785: LD_INT 6
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 69
22802: IFFALSE 22759
// async ;
22804: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: LD_STRING D6b-Pow-1
22812: PPUSH
22813: CALL_OW 88
// repeat wait ( 3 ) ;
22817: LD_INT 3
22819: PPUSH
22820: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22824: LD_EXP 58
22828: PPUSH
22829: CALL_OW 310
22833: PPUSH
22834: CALL_OW 256
22838: PUSH
22839: LD_INT 1000
22841: LESS
22842: IFFALSE 22861
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22844: LD_EXP 58
22848: PPUSH
22849: CALL_OW 310
22853: PPUSH
22854: LD_INT 1000
22856: PPUSH
22857: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22861: LD_EXP 58
22865: PPUSH
22866: CALL_OW 256
22870: PUSH
22871: LD_INT 1000
22873: LESS
22874: IFFALSE 22888
// SetLives ( Powell , 1000 ) ;
22876: LD_EXP 58
22880: PPUSH
22881: LD_INT 1000
22883: PPUSH
22884: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22888: LD_EXP 58
22892: PPUSH
22893: LD_EXP 63
22897: PPUSH
22898: CALL_OW 296
22902: PUSH
22903: LD_INT 5
22905: LESS
22906: PUSH
22907: LD_EXP 58
22911: PPUSH
22912: CALL_OW 310
22916: PPUSH
22917: LD_EXP 63
22921: PPUSH
22922: CALL_OW 296
22926: PUSH
22927: LD_INT 5
22929: LESS
22930: OR
22931: IFFALSE 22950
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22933: LD_EXP 58
22937: PPUSH
22938: CALL_OW 310
22942: PPUSH
22943: LD_INT 100
22945: PPUSH
22946: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22950: LD_EXP 58
22954: PPUSH
22955: CALL_OW 310
22959: NOT
22960: IFFALSE 22817
// DoNotAttack ( 8 , powellBomb ) ;
22962: LD_INT 8
22964: PPUSH
22965: LD_EXP 63
22969: PPUSH
22970: CALL_OW 471
// game_speed := 4 ;
22974: LD_ADDR_OWVAR 65
22978: PUSH
22979: LD_INT 4
22981: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22982: LD_EXP 58
22986: PPUSH
22987: LD_STRING D6b-Pow-1a
22989: PPUSH
22990: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22994: LD_EXP 58
22998: PPUSH
22999: LD_EXP 63
23003: PPUSH
23004: CALL_OW 180
// sync ;
23008: SYNC
// repeat wait ( 0 0$1 ) ;
23009: LD_INT 35
23011: PPUSH
23012: CALL_OW 67
// until IsInUnit ( Powell ) ;
23016: LD_EXP 58
23020: PPUSH
23021: CALL_OW 310
23025: IFFALSE 23009
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23027: LD_INT 8
23029: PPUSH
23030: LD_EXP 58
23034: PPUSH
23035: CALL_OW 310
23039: PPUSH
23040: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23044: LD_EXP 58
23048: PPUSH
23049: LD_INT 91
23051: PPUSH
23052: LD_INT 44
23054: PPUSH
23055: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23059: LD_EXP 58
23063: PPUSH
23064: LD_INT 96
23066: PPUSH
23067: LD_INT 44
23069: PPUSH
23070: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23074: LD_EXP 58
23078: PPUSH
23079: LD_INT 96
23081: PPUSH
23082: LD_INT 41
23084: PPUSH
23085: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23089: LD_EXP 58
23093: PPUSH
23094: LD_INT 92
23096: PPUSH
23097: LD_INT 39
23099: PPUSH
23100: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23104: LD_EXP 58
23108: PPUSH
23109: LD_INT 88
23111: PPUSH
23112: LD_INT 41
23114: PPUSH
23115: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23119: LD_EXP 58
23123: PPUSH
23124: LD_INT 91
23126: PPUSH
23127: LD_INT 44
23129: PPUSH
23130: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23134: LD_EXP 58
23138: PPUSH
23139: LD_INT 96
23141: PPUSH
23142: LD_INT 44
23144: PPUSH
23145: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23149: LD_EXP 58
23153: PPUSH
23154: LD_INT 96
23156: PPUSH
23157: LD_INT 41
23159: PPUSH
23160: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23164: LD_EXP 58
23168: PPUSH
23169: LD_INT 92
23171: PPUSH
23172: LD_INT 39
23174: PPUSH
23175: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23179: LD_EXP 58
23183: PPUSH
23184: LD_INT 88
23186: PPUSH
23187: LD_INT 41
23189: PPUSH
23190: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23194: LD_EXP 58
23198: PPUSH
23199: LD_INT 91
23201: PPUSH
23202: LD_INT 44
23204: PPUSH
23205: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23209: LD_EXP 58
23213: PPUSH
23214: LD_INT 93
23216: PPUSH
23217: LD_INT 39
23219: PPUSH
23220: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23224: LD_EXP 58
23228: PPUSH
23229: LD_INT 93
23231: PPUSH
23232: LD_INT 36
23234: PPUSH
23235: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23239: LD_INT 122
23241: PPUSH
23242: CALL_OW 67
// game_speed := 4 ;
23246: LD_ADDR_OWVAR 65
23250: PUSH
23251: LD_INT 4
23253: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23254: LD_EXP 58
23258: PPUSH
23259: LD_STRING D6b-Pow-1b
23261: PPUSH
23262: CALL_OW 88
// tmp := [ ] ;
23266: LD_ADDR_VAR 0 3
23270: PUSH
23271: EMPTY
23272: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23273: LD_ADDR_VAR 0 5
23277: PUSH
23278: LD_INT 78
23280: PUSH
23281: LD_INT 47
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 106
23290: PUSH
23291: LD_INT 53
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23302: LD_ADDR_VAR 0 1
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 8
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 21
23319: PUSH
23320: LD_INT 3
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PUSH
23327: LD_INT 92
23329: PUSH
23330: LD_INT 90
23332: PUSH
23333: LD_INT 52
23335: PUSH
23336: LD_INT 12
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: LIST
23349: PPUSH
23350: CALL_OW 69
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23381
// tmp := tmp ^ UnitsInside ( i ) ;
23358: LD_ADDR_VAR 0 3
23362: PUSH
23363: LD_VAR 0 3
23367: PUSH
23368: LD_VAR 0 1
23372: PPUSH
23373: CALL_OW 313
23377: ADD
23378: ST_TO_ADDR
23379: GO 23355
23381: POP
23382: POP
// for i in tmp do
23383: LD_ADDR_VAR 0 1
23387: PUSH
23388: LD_VAR 0 3
23392: PUSH
23393: FOR_IN
23394: IFFALSE 23556
// begin dist := 9999 ;
23396: LD_ADDR_VAR 0 8
23400: PUSH
23401: LD_INT 9999
23403: ST_TO_ADDR
// _xy := [ ] ;
23404: LD_ADDR_VAR 0 7
23408: PUSH
23409: EMPTY
23410: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23411: LD_VAR 0 1
23415: PPUSH
23416: LD_INT 1
23418: PPUSH
23419: CALL_OW 109
// ComExitBuilding ( i ) ;
23423: LD_VAR 0 1
23427: PPUSH
23428: CALL_OW 122
// for j in xy do
23432: LD_ADDR_VAR 0 2
23436: PUSH
23437: LD_VAR 0 5
23441: PUSH
23442: FOR_IN
23443: IFFALSE 23525
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23445: LD_VAR 0 1
23449: PPUSH
23450: LD_VAR 0 2
23454: PUSH
23455: LD_INT 1
23457: ARRAY
23458: PPUSH
23459: LD_VAR 0 2
23463: PUSH
23464: LD_INT 2
23466: ARRAY
23467: PPUSH
23468: CALL_OW 297
23472: PUSH
23473: LD_VAR 0 8
23477: LESS
23478: IFFALSE 23523
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23480: LD_ADDR_VAR 0 8
23484: PUSH
23485: LD_VAR 0 1
23489: PPUSH
23490: LD_VAR 0 2
23494: PUSH
23495: LD_INT 1
23497: ARRAY
23498: PPUSH
23499: LD_VAR 0 2
23503: PUSH
23504: LD_INT 2
23506: ARRAY
23507: PPUSH
23508: CALL_OW 297
23512: ST_TO_ADDR
// _xy := j ;
23513: LD_ADDR_VAR 0 7
23517: PUSH
23518: LD_VAR 0 2
23522: ST_TO_ADDR
// end ;
23523: GO 23442
23525: POP
23526: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23527: LD_VAR 0 1
23531: PPUSH
23532: LD_VAR 0 7
23536: PUSH
23537: LD_INT 1
23539: ARRAY
23540: PPUSH
23541: LD_VAR 0 7
23545: PUSH
23546: LD_INT 2
23548: ARRAY
23549: PPUSH
23550: CALL_OW 171
// end ;
23554: GO 23393
23556: POP
23557: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23558: LD_ADDR_VAR 0 4
23562: PUSH
23563: LD_VAR 0 3
23567: PPUSH
23568: LD_INT 26
23570: PUSH
23571: LD_INT 1
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 1
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PPUSH
23592: CALL_OW 72
23596: ST_TO_ADDR
// if tmp2 < 2 then
23597: LD_VAR 0 4
23601: PUSH
23602: LD_INT 2
23604: LESS
23605: IFFALSE 23674
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23607: LD_ADDR_VAR 0 4
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 8
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 26
23624: PUSH
23625: LD_INT 1
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 3
23634: PUSH
23635: LD_INT 25
23637: PUSH
23638: LD_INT 15
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: LIST
23653: PPUSH
23654: CALL_OW 69
23658: PUSH
23659: LD_EXP 60
23663: PUSH
23664: LD_EXP 61
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: DIFF
23673: ST_TO_ADDR
// if tmp2 then
23674: LD_VAR 0 4
23678: IFFALSE 23696
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23680: LD_VAR 0 4
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PPUSH
23689: LD_STRING D6b-ArSol1-1
23691: PPUSH
23692: CALL_OW 88
// async ;
23696: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23697: LD_EXP 58
23701: PPUSH
23702: LD_STRING D6b-Pow-2
23704: PPUSH
23705: CALL_OW 88
// wait ( 0 0$1 ) ;
23709: LD_INT 35
23711: PPUSH
23712: CALL_OW 67
// if tmp2 > 1 then
23716: LD_VAR 0 4
23720: PUSH
23721: LD_INT 1
23723: GREATER
23724: IFFALSE 23742
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23726: LD_VAR 0 4
23730: PUSH
23731: LD_INT 2
23733: ARRAY
23734: PPUSH
23735: LD_STRING D6b-ArSol2-1
23737: PPUSH
23738: CALL_OW 88
// sync ;
23742: SYNC
// repeat wait ( 5 ) ;
23743: LD_INT 5
23745: PPUSH
23746: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23750: LD_INT 93
23752: PPUSH
23753: LD_INT 36
23755: PPUSH
23756: CALL_OW 428
23760: PPUSH
23761: CALL_OW 255
23765: PUSH
23766: LD_INT 4
23768: EQUAL
23769: IFFALSE 23743
// DialogueOn ;
23771: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23775: LD_INT 10
23777: PPUSH
23778: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23782: LD_EXP 58
23786: PPUSH
23787: LD_STRING D6b-Pow-2a
23789: PPUSH
23790: CALL_OW 88
// DialogueOff ;
23794: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23798: LD_EXP 58
23802: PPUSH
23803: CALL_OW 310
23807: PPUSH
23808: LD_INT 332
23810: PPUSH
23811: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23815: LD_INT 93
23817: PPUSH
23818: LD_INT 35
23820: PPUSH
23821: LD_INT 1
23823: PPUSH
23824: LD_INT 6
23826: NEG
23827: PPUSH
23828: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23832: LD_INT 35
23834: PPUSH
23835: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23839: LD_INT 332
23841: PPUSH
23842: CALL_OW 256
23846: PUSH
23847: LD_INT 1000
23849: LESS
23850: PUSH
23851: LD_INT 332
23853: PPUSH
23854: CALL_OW 300
23858: AND
23859: IFFALSE 23871
// SetLives ( kozlov_fac , 0 ) ;
23861: LD_INT 332
23863: PPUSH
23864: LD_INT 0
23866: PPUSH
23867: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23871: LD_INT 332
23873: PPUSH
23874: CALL_OW 301
23878: PUSH
23879: LD_EXP 58
23883: PPUSH
23884: CALL_OW 301
23888: OR
23889: IFFALSE 23832
// game_speed := 4 ;
23891: LD_ADDR_OWVAR 65
23895: PUSH
23896: LD_INT 4
23898: ST_TO_ADDR
// powellCenterCameraMode := false ;
23899: LD_ADDR_EXP 20
23903: PUSH
23904: LD_INT 0
23906: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23907: LD_ADDR_VAR 0 1
23911: PUSH
23912: LD_VAR 0 3
23916: PUSH
23917: LD_INT 22
23919: PUSH
23920: LD_INT 8
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 25
23929: PUSH
23930: LD_INT 2
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PPUSH
23941: CALL_OW 69
23945: UNION
23946: PUSH
23947: FOR_IN
23948: IFFALSE 23964
// SetTag ( i , 0 ) ;
23950: LD_VAR 0 1
23954: PPUSH
23955: LD_INT 0
23957: PPUSH
23958: CALL_OW 109
23962: GO 23947
23964: POP
23965: POP
// wait ( 0 0$3 ) ;
23966: LD_INT 105
23968: PPUSH
23969: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23973: LD_INT 93
23975: PPUSH
23976: LD_INT 35
23978: PPUSH
23979: LD_INT 1
23981: PPUSH
23982: CALL_OW 331
// DialogueOn ;
23986: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23990: LD_VAR 0 11
23994: PPUSH
23995: LD_STRING D6c-Sol3-1
23997: PPUSH
23998: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24002: LD_INT 10
24004: PPUSH
24005: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24009: LD_EXP 39
24013: PPUSH
24014: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24018: LD_EXP 39
24022: PPUSH
24023: LD_STRING D6c-JMM-1
24025: PPUSH
24026: CALL_OW 88
// if Cyrus then
24030: LD_EXP 45
24034: IFFALSE 24048
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24036: LD_EXP 45
24040: PPUSH
24041: LD_STRING D6c-Cyrus-1
24043: PPUSH
24044: CALL_OW 88
// if Bobby then
24048: LD_EXP 44
24052: IFFALSE 24066
// Say ( Bobby , D6c-Bobby-1 ) ;
24054: LD_EXP 44
24058: PPUSH
24059: LD_STRING D6c-Bobby-1
24061: PPUSH
24062: CALL_OW 88
// if Cornel then
24066: LD_EXP 50
24070: IFFALSE 24084
// Say ( Cornel , D6c-Corn-1 ) ;
24072: LD_EXP 50
24076: PPUSH
24077: LD_STRING D6c-Corn-1
24079: PPUSH
24080: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24084: LD_ADDR_VAR 0 4
24088: PUSH
24089: LD_INT 2
24091: PUSH
24092: LD_INT 22
24094: PUSH
24095: LD_INT 1
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 22
24104: PUSH
24105: LD_INT 4
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: LIST
24116: PUSH
24117: LD_INT 26
24119: PUSH
24120: LD_INT 1
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 3
24129: PUSH
24130: LD_INT 25
24132: PUSH
24133: LD_INT 16
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 25
24142: PUSH
24143: LD_INT 12
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: LIST
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: PPUSH
24160: CALL_OW 69
24164: PUSH
24165: LD_VAR 0 11
24169: PUSH
24170: LD_EXP 39
24174: UNION
24175: PUSH
24176: LD_EXP 59
24180: UNION
24181: PUSH
24182: EMPTY
24183: LIST
24184: DIFF
24185: ST_TO_ADDR
// if tmp2 then
24186: LD_VAR 0 4
24190: IFFALSE 24208
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24192: LD_VAR 0 4
24196: PUSH
24197: LD_INT 1
24199: ARRAY
24200: PPUSH
24201: LD_STRING D6c-Sol1-1
24203: PPUSH
24204: CALL_OW 88
// if Lisa then
24208: LD_EXP 42
24212: IFFALSE 24226
// Say ( Lisa , D6c-Lisa-1 ) ;
24214: LD_EXP 42
24218: PPUSH
24219: LD_STRING D6c-Lisa-1
24221: PPUSH
24222: CALL_OW 88
// if Gary then
24226: LD_EXP 51
24230: IFFALSE 24244
// Say ( Gary , D6c-Gary-1 ) ;
24232: LD_EXP 51
24236: PPUSH
24237: LD_STRING D6c-Gary-1
24239: PPUSH
24240: CALL_OW 88
// if Donaldson then
24244: LD_EXP 43
24248: IFFALSE 24262
// Say ( Donaldson , D6c-Don-1 ) ;
24250: LD_EXP 43
24254: PPUSH
24255: LD_STRING D6c-Don-1
24257: PPUSH
24258: CALL_OW 88
// if tmp2 > 1 then
24262: LD_VAR 0 4
24266: PUSH
24267: LD_INT 1
24269: GREATER
24270: IFFALSE 24288
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24272: LD_VAR 0 4
24276: PUSH
24277: LD_INT 2
24279: ARRAY
24280: PPUSH
24281: LD_STRING D6c-Sol2-1
24283: PPUSH
24284: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24288: LD_VAR 0 11
24292: PPUSH
24293: LD_STRING D6c-Sol3-2
24295: PPUSH
24296: CALL_OW 88
// dwait ( 0 0$1 ) ;
24300: LD_INT 35
24302: PPUSH
24303: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24307: LD_EXP 39
24311: PPUSH
24312: LD_STRING D6c-JMM-2
24314: PPUSH
24315: CALL_OW 88
// DialogueOff ;
24319: CALL_OW 7
// Video ( false ) ;
24323: LD_INT 0
24325: PPUSH
24326: CALL 102594 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24330: LD_INT 22
24332: PUSH
24333: LD_INT 4
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PPUSH
24340: CALL_OW 69
24344: PPUSH
24345: LD_INT 1
24347: PPUSH
24348: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24352: LD_INT 4
24354: PPUSH
24355: LD_INT 4
24357: PPUSH
24358: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24362: LD_ADDR_VAR 0 1
24366: PUSH
24367: LD_INT 4
24369: PPUSH
24370: LD_INT 1
24372: PPUSH
24373: LD_INT 2
24375: PPUSH
24376: CALL 65948 0 3
24380: PUSH
24381: FOR_IN
24382: IFFALSE 24419
// if GetTech ( i , 1 ) <> state_researched then
24384: LD_VAR 0 1
24388: PPUSH
24389: LD_INT 1
24391: PPUSH
24392: CALL_OW 321
24396: PUSH
24397: LD_INT 2
24399: NONEQUAL
24400: IFFALSE 24417
// SetTech ( i , 1 , state_researched ) ;
24402: LD_VAR 0 1
24406: PPUSH
24407: LD_INT 1
24409: PPUSH
24410: LD_INT 2
24412: PPUSH
24413: CALL_OW 322
24417: GO 24381
24419: POP
24420: POP
// missionStage := 6 ;
24421: LD_ADDR_EXP 15
24425: PUSH
24426: LD_INT 6
24428: ST_TO_ADDR
// activeAttacks := true ;
24429: LD_ADDR_EXP 16
24433: PUSH
24434: LD_INT 1
24436: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24437: LD_STRING M2
24439: PPUSH
24440: CALL_OW 337
// SaveForQuickRestart ;
24444: CALL_OW 22
// wait ( 0 0$40 ) ;
24448: LD_INT 1400
24450: PPUSH
24451: CALL_OW 67
// DialogueOn ;
24455: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24459: LD_EXP 62
24463: PPUSH
24464: LD_STRING D7-Friend-1
24466: PPUSH
24467: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24471: LD_EXP 39
24475: PPUSH
24476: LD_STRING D7-JMM-1
24478: PPUSH
24479: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24483: LD_EXP 62
24487: PPUSH
24488: LD_STRING D7-Friend-2
24490: PPUSH
24491: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24495: LD_EXP 39
24499: PPUSH
24500: LD_STRING D7-JMM-2
24502: PPUSH
24503: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24507: LD_EXP 62
24511: PPUSH
24512: LD_STRING D7-Friend-3
24514: PPUSH
24515: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24519: LD_EXP 39
24523: PPUSH
24524: LD_STRING D7-JMM-3
24526: PPUSH
24527: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24531: LD_EXP 62
24535: PPUSH
24536: LD_STRING D7-Friend-4
24538: PPUSH
24539: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24543: LD_EXP 39
24547: PPUSH
24548: LD_STRING D7-JMM-4
24550: PPUSH
24551: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24555: LD_EXP 62
24559: PPUSH
24560: LD_STRING D7-Friend-5
24562: PPUSH
24563: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24567: LD_EXP 39
24571: PPUSH
24572: LD_STRING D7-JMM-5
24574: PPUSH
24575: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24579: LD_EXP 62
24583: PPUSH
24584: LD_STRING D7-Friend-6
24586: PPUSH
24587: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24591: LD_EXP 39
24595: PPUSH
24596: LD_STRING D7-JMM-6
24598: PPUSH
24599: CALL_OW 88
// DialogueOff ;
24603: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24607: LD_STRING Mlegion
24609: PPUSH
24610: CALL_OW 337
// skirmish := true ;
24614: LD_ADDR_EXP 114
24618: PUSH
24619: LD_INT 1
24621: ST_TO_ADDR
// RebuildKozlovFactory ;
24622: CALL 4892 0 0
// end ;
24626: PPOPN 13
24628: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24629: LD_EXP 20
24633: PUSH
24634: LD_EXP 58
24638: PPUSH
24639: CALL_OW 300
24643: AND
24644: IFFALSE 24686
24646: GO 24648
24648: DISABLE
// begin enable ;
24649: ENABLE
// if IsInUnit ( Powell ) then
24650: LD_EXP 58
24654: PPUSH
24655: CALL_OW 310
24659: IFFALSE 24677
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24661: LD_EXP 58
24665: PPUSH
24666: CALL_OW 310
24670: PPUSH
24671: CALL_OW 85
24675: GO 24686
// CenterOnUnits ( Powell ) ;
24677: LD_EXP 58
24681: PPUSH
24682: CALL_OW 85
// end ;
24686: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24687: LD_INT 22
24689: PUSH
24690: LD_INT 8
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 34
24699: PUSH
24700: LD_INT 48
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: PPUSH
24711: CALL_OW 69
24715: IFFALSE 24989
24717: GO 24719
24719: DISABLE
24720: LD_INT 0
24722: PPUSH
24723: PPUSH
// begin if missionStage < 9 then
24724: LD_EXP 15
24728: PUSH
24729: LD_INT 9
24731: LESS
24732: IFFALSE 24742
// missionStage := 9 ;
24734: LD_ADDR_EXP 15
24738: PUSH
24739: LD_INT 9
24741: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24742: LD_ADDR_VAR 0 1
24746: PUSH
24747: LD_INT 22
24749: PUSH
24750: LD_INT 8
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 34
24759: PUSH
24760: LD_INT 48
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PPUSH
24771: CALL_OW 69
24775: PUSH
24776: LD_INT 1
24778: ARRAY
24779: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24780: LD_INT 175
24782: PPUSH
24783: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24787: LD_EXP 12
24791: PUSH
24792: LD_EXP 3
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: LD_INT 2
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: IN
24807: OR
24808: IFFALSE 24831
// target := [ 68 , 108 , 1 ] else
24810: LD_ADDR_VAR 0 2
24814: PUSH
24815: LD_INT 68
24817: PUSH
24818: LD_INT 108
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: LIST
24828: ST_TO_ADDR
24829: GO 24850
// target := [ 181 , 88 , 2 ] ;
24831: LD_ADDR_VAR 0 2
24835: PUSH
24836: LD_INT 181
24838: PUSH
24839: LD_INT 88
24841: PUSH
24842: LD_INT 2
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: LIST
24849: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24850: LD_VAR 0 1
24854: PPUSH
24855: LD_VAR 0 2
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 2
24871: ARRAY
24872: PPUSH
24873: CALL_OW 176
// if target [ 3 ] = 1 then
24877: LD_VAR 0 2
24881: PUSH
24882: LD_INT 3
24884: ARRAY
24885: PUSH
24886: LD_INT 1
24888: EQUAL
24889: IFFALSE 24905
// SayRadio ( Kurt , D12-Kurt-1 ) else
24891: LD_EXP 60
24895: PPUSH
24896: LD_STRING D12-Kurt-1
24898: PPUSH
24899: CALL_OW 94
24903: GO 24929
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24905: LD_EXP 60
24909: PPUSH
24910: LD_STRING D12a-Kurt-1
24912: PPUSH
24913: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24917: LD_EXP 74
24921: PPUSH
24922: LD_STRING D12a-Roth-1
24924: PPUSH
24925: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24929: LD_INT 350
24931: PPUSH
24932: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24936: LD_VAR 0 1
24940: PPUSH
24941: LD_INT 22
24943: PUSH
24944: LD_INT 8
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PUSH
24951: LD_INT 23
24953: PUSH
24954: LD_INT 2
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: LD_INT 30
24963: PUSH
24964: LD_INT 3
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: LIST
24975: PPUSH
24976: CALL_OW 69
24980: PUSH
24981: LD_INT 1
24983: ARRAY
24984: PPUSH
24985: CALL_OW 228
// end ;
24989: PPOPN 2
24991: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24992: LD_EXP 60
24996: PPUSH
24997: CALL_OW 256
25001: PUSH
25002: LD_INT 999
25004: LESS
25005: PUSH
25006: LD_INT 22
25008: PUSH
25009: LD_INT 8
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: PUSH
25016: LD_INT 21
25018: PUSH
25019: LD_INT 1
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 23
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 9
25048: PUSH
25049: LD_INT 8
25051: PUSH
25052: LD_INT 7
25054: PUSH
25055: LD_INT 6
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: PUSH
25064: LD_OWVAR 67
25068: ARRAY
25069: LESSEQUAL
25070: OR
25071: PUSH
25072: LD_INT 22
25074: PUSH
25075: LD_INT 8
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 34
25084: PUSH
25085: LD_INT 48
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PPUSH
25096: CALL_OW 69
25100: NOT
25101: AND
25102: PUSH
25103: LD_EXP 60
25107: PPUSH
25108: CALL_OW 302
25112: AND
25113: PUSH
25114: LD_INT 5
25116: PPUSH
25117: LD_INT 22
25119: PUSH
25120: LD_INT 1
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PPUSH
25127: CALL_OW 70
25131: AND
25132: IFFALSE 25845
25134: GO 25136
25136: DISABLE
25137: LD_INT 0
25139: PPUSH
25140: PPUSH
25141: PPUSH
// begin legionDestroyed := true ;
25142: LD_ADDR_EXP 22
25146: PUSH
25147: LD_INT 1
25149: ST_TO_ADDR
// DialogueOn ;
25150: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25154: LD_EXP 39
25158: PPUSH
25159: LD_STRING D13-JMM-1
25161: PPUSH
25162: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25166: LD_EXP 60
25170: PPUSH
25171: LD_STRING D13-Kurt-1
25173: PPUSH
25174: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25178: LD_EXP 39
25182: PPUSH
25183: LD_STRING D13-JMM-2
25185: PPUSH
25186: CALL_OW 88
// if FakeInfo then
25190: LD_EXP 12
25194: IFFALSE 25214
// begin Say ( Kurt , D13-Kurt-2 ) ;
25196: LD_EXP 60
25200: PPUSH
25201: LD_STRING D13-Kurt-2
25203: PPUSH
25204: CALL_OW 88
// DialogueOff ;
25208: CALL_OW 7
// exit ;
25212: GO 25845
// end ; if not KurtStatus then
25214: LD_EXP 3
25218: NOT
25219: IFFALSE 25235
// Say ( Kurt , D13-Kurt-2b ) else
25221: LD_EXP 60
25225: PPUSH
25226: LD_STRING D13-Kurt-2b
25228: PPUSH
25229: CALL_OW 88
25233: GO 25247
// Say ( Kurt , D13-Kurt-2a ) ;
25235: LD_EXP 60
25239: PPUSH
25240: LD_STRING D13-Kurt-2a
25242: PPUSH
25243: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25247: LD_EXP 39
25251: PPUSH
25252: LD_STRING D13-JMM-3
25254: PPUSH
25255: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25259: LD_EXP 60
25263: PPUSH
25264: LD_STRING D13-Kurt-3
25266: PPUSH
25267: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25271: LD_EXP 39
25275: PPUSH
25276: LD_STRING D13-JMM-4
25278: PPUSH
25279: CALL_OW 88
// DialogueOff ;
25283: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25287: LD_STRING MlegionOut
25289: PPUSH
25290: CALL_OW 337
// MC_Kill ( 3 ) ;
25294: LD_INT 3
25296: PPUSH
25297: CALL 35501 0 1
// KillUnit ( Kozlov ) ;
25301: LD_EXP 61
25305: PPUSH
25306: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25310: LD_ADDR_VAR 0 1
25314: PUSH
25315: LD_INT 22
25317: PUSH
25318: LD_INT 8
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: PUSH
25325: LD_INT 23
25327: PUSH
25328: LD_INT 3
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 3
25337: PUSH
25338: LD_INT 21
25340: PUSH
25341: LD_INT 33
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: PPUSH
25357: CALL_OW 69
25361: PUSH
25362: FOR_IN
25363: IFFALSE 25376
// KillUnit ( i ) ;
25365: LD_VAR 0 1
25369: PPUSH
25370: CALL_OW 66
25374: GO 25362
25376: POP
25377: POP
// ChangeSideFog ( 8 , 1 ) ;
25378: LD_INT 8
25380: PPUSH
25381: LD_INT 1
25383: PPUSH
25384: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25388: LD_ADDR_VAR 0 2
25392: PUSH
25393: LD_INT 22
25395: PUSH
25396: LD_INT 8
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 21
25405: PUSH
25406: LD_INT 1
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PPUSH
25417: CALL_OW 69
25421: PUSH
25422: LD_EXP 61
25426: PUSH
25427: LD_EXP 60
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: DIFF
25436: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25437: LD_VAR 0 2
25441: PUSH
25442: LD_INT 6
25444: PUSH
25445: LD_INT 5
25447: PUSH
25448: LD_INT 4
25450: PUSH
25451: LD_INT 3
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: PUSH
25460: LD_OWVAR 67
25464: ARRAY
25465: GREATEREQUAL
25466: IFFALSE 25644
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25468: LD_ADDR_VAR 0 3
25472: PUSH
25473: LD_INT 6
25475: PUSH
25476: LD_INT 5
25478: PUSH
25479: LD_INT 4
25481: PUSH
25482: LD_INT 3
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: PUSH
25491: LD_OWVAR 67
25495: ARRAY
25496: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25497: LD_ADDR_VAR 0 1
25501: PUSH
25502: DOUBLE
25503: LD_VAR 0 2
25507: PUSH
25508: LD_VAR 0 3
25512: PUSH
25513: LD_INT 1
25515: PLUS
25516: MINUS
25517: INC
25518: ST_TO_ADDR
25519: LD_INT 1
25521: PUSH
25522: FOR_DOWNTO
25523: IFFALSE 25640
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25525: LD_ADDR_EXP 38
25529: PUSH
25530: LD_EXP 38
25534: PUSH
25535: LD_VAR 0 2
25539: PUSH
25540: LD_VAR 0 1
25544: ARRAY
25545: ADD
25546: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitBuilding ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 122
// if IsInUnit ( i ) then
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL_OW 310
25588: IFFALSE 25605
// ComExitVehicle ( tmp [ i ] ) ;
25590: LD_VAR 0 2
25594: PUSH
25595: LD_VAR 0 1
25599: ARRAY
25600: PPUSH
25601: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25605: LD_VAR 0 2
25609: PUSH
25610: LD_VAR 0 1
25614: ARRAY
25615: PPUSH
25616: LD_INT 34
25618: PUSH
25619: LD_INT 0
25621: PPUSH
25622: LD_INT 6
25624: PPUSH
25625: CALL_OW 12
25629: PLUS
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 171
// end ;
25638: GO 25522
25640: POP
25641: POP
// end else
25642: GO 25654
// x := tmp ;
25644: LD_ADDR_VAR 0 3
25648: PUSH
25649: LD_VAR 0 2
25653: ST_TO_ADDR
// for i := tmp downto tmp - x do
25654: LD_ADDR_VAR 0 1
25658: PUSH
25659: DOUBLE
25660: LD_VAR 0 2
25664: INC
25665: ST_TO_ADDR
25666: LD_VAR 0 2
25670: PUSH
25671: LD_VAR 0 3
25675: MINUS
25676: PUSH
25677: FOR_DOWNTO
25678: IFFALSE 25732
// begin if IsInUnit ( tmp [ i ] ) then
25680: LD_VAR 0 2
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: CALL_OW 310
25695: IFFALSE 25712
// ComExitVehicle ( tmp [ i ] ) ;
25697: LD_VAR 0 2
25701: PUSH
25702: LD_VAR 0 1
25706: ARRAY
25707: PPUSH
25708: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25712: LD_VAR 0 2
25716: PUSH
25717: LD_VAR 0 1
25721: ARRAY
25722: PPUSH
25723: LD_INT 1
25725: PPUSH
25726: CALL_OW 235
// end ;
25730: GO 25677
25732: POP
25733: POP
// SetSide ( Kurt , 1 ) ;
25734: LD_EXP 60
25738: PPUSH
25739: LD_INT 1
25741: PPUSH
25742: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 3
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PPUSH
25775: LD_INT 1
25777: PPUSH
25778: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25782: LD_INT 8
25784: PPUSH
25785: LD_INT 1
25787: PPUSH
25788: LD_INT 1
25790: PPUSH
25791: LD_INT 1
25793: PPUSH
25794: CALL_OW 80
// wait ( 1 1$20 ) ;
25798: LD_INT 2800
25800: PPUSH
25801: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25805: LD_EXP 62
25809: PPUSH
25810: LD_INT 37
25812: PPUSH
25813: LD_INT 1
25815: PPUSH
25816: LD_INT 0
25818: PPUSH
25819: CALL_OW 48
// wait ( 0 0$1 ) ;
25823: LD_INT 35
25825: PPUSH
25826: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25830: LD_EXP 62
25834: PPUSH
25835: LD_INT 60
25837: PPUSH
25838: LD_INT 95
25840: PPUSH
25841: CALL_OW 111
// end ;
25845: PPOPN 3
25847: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25848: LD_EXP 22
25852: NOT
25853: PUSH
25854: LD_INT 22
25856: PUSH
25857: LD_INT 8
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 21
25866: PUSH
25867: LD_INT 1
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 69
25882: PUSH
25883: LD_INT 0
25885: EQUAL
25886: AND
25887: IFFALSE 25907
25889: GO 25891
25891: DISABLE
// begin legionDestroyed := true ;
25892: LD_ADDR_EXP 22
25896: PUSH
25897: LD_INT 1
25899: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25900: LD_STRING MlegionOut
25902: PPUSH
25903: CALL_OW 337
// end ;
25907: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25908: LD_EXP 38
25912: IFFALSE 25987
25914: GO 25916
25916: DISABLE
25917: LD_INT 0
25919: PPUSH
// begin enable ;
25920: ENABLE
// for i in legionEscapeUnits do
25921: LD_ADDR_VAR 0 1
25925: PUSH
25926: LD_EXP 38
25930: PUSH
25931: FOR_IN
25932: IFFALSE 25985
// begin if IsInArea ( i , legionEscapeArea ) then
25934: LD_VAR 0 1
25938: PPUSH
25939: LD_INT 31
25941: PPUSH
25942: CALL_OW 308
25946: IFFALSE 25959
// RemoveUnit ( i ) else
25948: LD_VAR 0 1
25952: PPUSH
25953: CALL_OW 64
25957: GO 25983
// if not HasTask ( i ) then
25959: LD_VAR 0 1
25963: PPUSH
25964: CALL_OW 314
25968: NOT
25969: IFFALSE 25983
// ComMoveToArea ( i , legionEscapeArea ) ;
25971: LD_VAR 0 1
25975: PPUSH
25976: LD_INT 31
25978: PPUSH
25979: CALL_OW 113
// end ;
25983: GO 25931
25985: POP
25986: POP
// end ;
25987: PPOPN 1
25989: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25990: LD_INT 1
25992: PPUSH
25993: LD_EXP 62
25997: PPUSH
25998: CALL_OW 292
26002: IFFALSE 26300
26004: GO 26006
26006: DISABLE
26007: LD_INT 0
26009: PPUSH
// begin wait ( 0 0$2 ) ;
26010: LD_INT 70
26012: PPUSH
26013: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26017: LD_EXP 62
26021: PPUSH
26022: CALL_OW 87
// DialogueOn ;
26026: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26030: LD_EXP 39
26034: PPUSH
26035: LD_STRING D14-JMM-1
26037: PPUSH
26038: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26042: LD_EXP 62
26046: PPUSH
26047: LD_STRING D14-Friend-1
26049: PPUSH
26050: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26054: LD_EXP 39
26058: PPUSH
26059: LD_STRING D14-JMM-2
26061: PPUSH
26062: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26066: LD_EXP 62
26070: PPUSH
26071: LD_STRING D14-Friend-2
26073: PPUSH
26074: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26078: LD_EXP 39
26082: PPUSH
26083: LD_STRING D14-JMM-3
26085: PPUSH
26086: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_STRING D14-Friend-3
26097: PPUSH
26098: CALL_OW 88
// DialogueOff ;
26102: CALL_OW 7
// dec = Query ( Q14 ) ;
26106: LD_ADDR_VAR 0 1
26110: PUSH
26111: LD_STRING Q14
26113: PPUSH
26114: CALL_OW 97
26118: ST_TO_ADDR
// if dec = 1 then
26119: LD_VAR 0 1
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26161
// begin DialogueOn ;
26129: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26133: LD_EXP 39
26137: PPUSH
26138: LD_STRING D14a-JMM-1
26140: PPUSH
26141: CALL_OW 88
// DialogueOff ;
26145: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26149: LD_EXP 62
26153: PPUSH
26154: LD_INT 1
26156: PPUSH
26157: CALL_OW 235
// end ; if dec = 2 then
26161: LD_VAR 0 1
26165: PUSH
26166: LD_INT 2
26168: EQUAL
26169: IFFALSE 26222
// begin DialogueOn ;
26171: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26175: LD_EXP 39
26179: PPUSH
26180: LD_STRING D14b-JMM-1
26182: PPUSH
26183: CALL_OW 88
// DialogueOff ;
26187: CALL_OW 7
// wait ( 0 0$1 ) ;
26191: LD_INT 35
26193: PPUSH
26194: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26198: LD_EXP 62
26202: PPUSH
26203: LD_INT 9
26205: PPUSH
26206: LD_INT 2
26208: PPUSH
26209: CALL_OW 111
// AddComHold ( Friend ) ;
26213: LD_EXP 62
26217: PPUSH
26218: CALL_OW 200
// end ; if dec = 3 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 3
26229: EQUAL
26230: IFFALSE 26300
// begin DialogueOn ;
26232: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26236: LD_EXP 39
26240: PPUSH
26241: LD_STRING D14c-JMM-1
26243: PPUSH
26244: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26248: LD_EXP 62
26252: PPUSH
26253: LD_STRING D14c-Friend-1
26255: PPUSH
26256: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26260: LD_EXP 39
26264: PPUSH
26265: LD_STRING D14c-JMM-2
26267: PPUSH
26268: CALL_OW 88
// DialogueOff ;
26272: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26276: LD_EXP 62
26280: PPUSH
26281: LD_INT 9
26283: PPUSH
26284: LD_INT 2
26286: PPUSH
26287: CALL_OW 111
// AddComHold ( Friend ) ;
26291: LD_EXP 62
26295: PPUSH
26296: CALL_OW 200
// end ; end ;
26300: PPOPN 1
26302: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26303: LD_INT 9
26305: PPUSH
26306: LD_INT 2
26308: PPUSH
26309: CALL_OW 428
26313: PUSH
26314: LD_EXP 62
26318: EQUAL
26319: PUSH
26320: LD_EXP 62
26324: PPUSH
26325: CALL_OW 255
26329: PUSH
26330: LD_INT 8
26332: EQUAL
26333: AND
26334: IFFALSE 26348
26336: GO 26338
26338: DISABLE
// RemoveUnit ( Friend ) ;
26339: LD_EXP 62
26343: PPUSH
26344: CALL_OW 64
26348: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26349: LD_EXP 14
26353: PUSH
26354: LD_INT 31500
26356: GREATEREQUAL
26357: PUSH
26358: LD_EXP 7
26362: AND
26363: PUSH
26364: LD_EXP 2
26368: AND
26369: IFFALSE 26799
26371: GO 26373
26373: DISABLE
26374: LD_INT 0
26376: PPUSH
26377: PPUSH
26378: PPUSH
// begin missionStage := 7 ;
26379: LD_ADDR_EXP 15
26383: PUSH
26384: LD_INT 7
26386: ST_TO_ADDR
// uc_side = 1 ;
26387: LD_ADDR_OWVAR 20
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// uc_nation = 1 ;
26395: LD_ADDR_OWVAR 21
26399: PUSH
26400: LD_INT 1
26402: ST_TO_ADDR
// for i = 1 to 5 do
26403: LD_ADDR_VAR 0 1
26407: PUSH
26408: DOUBLE
26409: LD_INT 1
26411: DEC
26412: ST_TO_ADDR
26413: LD_INT 5
26415: PUSH
26416: FOR_TO
26417: IFFALSE 26513
// begin vc_engine = 3 ;
26419: LD_ADDR_OWVAR 39
26423: PUSH
26424: LD_INT 3
26426: ST_TO_ADDR
// vc_control = 3 ;
26427: LD_ADDR_OWVAR 38
26431: PUSH
26432: LD_INT 3
26434: ST_TO_ADDR
// vc_chassis = 3 ;
26435: LD_ADDR_OWVAR 37
26439: PUSH
26440: LD_INT 3
26442: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26443: LD_ADDR_OWVAR 40
26447: PUSH
26448: LD_INT 5
26450: PUSH
26451: LD_INT 9
26453: PUSH
26454: LD_INT 7
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PPUSH
26465: LD_INT 3
26467: PPUSH
26468: CALL_OW 12
26472: ARRAY
26473: ST_TO_ADDR
// veh = CreateVehicle ;
26474: LD_ADDR_VAR 0 2
26478: PUSH
26479: CALL_OW 45
26483: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26484: LD_VAR 0 2
26488: PPUSH
26489: LD_INT 1
26491: PPUSH
26492: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26496: LD_VAR 0 2
26500: PPUSH
26501: LD_INT 19
26503: PPUSH
26504: LD_INT 0
26506: PPUSH
26507: CALL_OW 49
// end ;
26511: GO 26416
26513: POP
26514: POP
// vc_engine = 3 ;
26515: LD_ADDR_OWVAR 39
26519: PUSH
26520: LD_INT 3
26522: ST_TO_ADDR
// vc_control = 1 ;
26523: LD_ADDR_OWVAR 38
26527: PUSH
26528: LD_INT 1
26530: ST_TO_ADDR
// vc_chassis = 3 ;
26531: LD_ADDR_OWVAR 37
26535: PUSH
26536: LD_INT 3
26538: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26539: LD_ADDR_OWVAR 40
26543: PUSH
26544: LD_INT 5
26546: PUSH
26547: LD_INT 9
26549: PUSH
26550: LD_INT 7
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PPUSH
26561: LD_INT 3
26563: PPUSH
26564: CALL_OW 12
26568: ARRAY
26569: ST_TO_ADDR
// vehG = CreateVehicle ;
26570: LD_ADDR_VAR 0 3
26574: PUSH
26575: CALL_OW 45
26579: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26580: LD_VAR 0 3
26584: PPUSH
26585: LD_INT 1
26587: PPUSH
26588: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26592: LD_VAR 0 3
26596: PPUSH
26597: LD_INT 19
26599: PPUSH
26600: LD_INT 0
26602: PPUSH
26603: CALL_OW 49
// if JMMGirl = 1 then
26607: LD_EXP 7
26611: PUSH
26612: LD_INT 1
26614: EQUAL
26615: IFFALSE 26671
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26617: LD_ADDR_EXP 40
26621: PUSH
26622: LD_STRING Joan
26624: PPUSH
26625: LD_INT 1
26627: PPUSH
26628: LD_STRING 14_
26630: PPUSH
26631: CALL 65885 0 3
26635: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26636: LD_EXP 40
26640: PPUSH
26641: LD_VAR 0 3
26645: PPUSH
26646: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26650: LD_VAR 0 3
26654: PPUSH
26655: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26659: LD_EXP 40
26663: PPUSH
26664: LD_STRING D10BW-Joan-1
26666: PPUSH
26667: CALL_OW 94
// end ; if JMMGirl = 2 then
26671: LD_EXP 7
26675: PUSH
26676: LD_INT 2
26678: EQUAL
26679: IFFALSE 26735
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26681: LD_ADDR_EXP 42
26685: PUSH
26686: LD_STRING Lisa
26688: PPUSH
26689: LD_INT 1
26691: PPUSH
26692: LD_STRING 14_
26694: PPUSH
26695: CALL 65885 0 3
26699: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26700: LD_EXP 42
26704: PPUSH
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26714: LD_VAR 0 3
26718: PPUSH
26719: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26723: LD_EXP 42
26727: PPUSH
26728: LD_STRING D10BW-Lisa-1
26730: PPUSH
26731: CALL_OW 94
// end ; if JMMGirl = 3 then
26735: LD_EXP 7
26739: PUSH
26740: LD_INT 3
26742: EQUAL
26743: IFFALSE 26799
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26745: LD_ADDR_EXP 54
26749: PUSH
26750: LD_STRING Connie
26752: PPUSH
26753: LD_INT 1
26755: PPUSH
26756: LD_STRING 14_
26758: PPUSH
26759: CALL 65885 0 3
26763: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26764: LD_EXP 54
26768: PPUSH
26769: LD_VAR 0 3
26773: PPUSH
26774: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26787: LD_EXP 54
26791: PPUSH
26792: LD_STRING D10BW-Con-1
26794: PPUSH
26795: CALL_OW 94
// end ; end ;
26799: PPOPN 3
26801: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26802: LD_EXP 14
26806: PUSH
26807: LD_INT 94500
26809: GREATEREQUAL
26810: IFFALSE 27222
26812: GO 26814
26814: DISABLE
26815: LD_INT 0
26817: PPUSH
26818: PPUSH
26819: PPUSH
// begin tmp := PrepareStevensSquad ;
26820: LD_ADDR_VAR 0 3
26824: PUSH
26825: CALL 2226 0 0
26829: ST_TO_ADDR
// if not tmp then
26830: LD_VAR 0 3
26834: NOT
26835: IFFALSE 26839
// exit ;
26837: GO 27222
// uc_side := 1 ;
26839: LD_ADDR_OWVAR 20
26843: PUSH
26844: LD_INT 1
26846: ST_TO_ADDR
// uc_nation := 1 ;
26847: LD_ADDR_OWVAR 21
26851: PUSH
26852: LD_INT 1
26854: ST_TO_ADDR
// for i in tmp do
26855: LD_ADDR_VAR 0 1
26859: PUSH
26860: LD_VAR 0 3
26864: PUSH
26865: FOR_IN
26866: IFFALSE 26963
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26868: LD_INT 3
26870: PPUSH
26871: LD_INT 3
26873: PPUSH
26874: LD_INT 1
26876: PPUSH
26877: LD_INT 5
26879: PUSH
26880: LD_INT 9
26882: PUSH
26883: LD_INT 7
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 1
26893: PPUSH
26894: LD_INT 3
26896: PPUSH
26897: CALL_OW 12
26901: ARRAY
26902: PPUSH
26903: LD_INT 40
26905: PPUSH
26906: CALL 70749 0 5
// veh := CreateVehicle ;
26910: LD_ADDR_VAR 0 2
26914: PUSH
26915: CALL_OW 45
26919: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_INT 1
26927: PPUSH
26928: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26932: LD_VAR 0 2
26936: PPUSH
26937: LD_INT 19
26939: PPUSH
26940: LD_INT 0
26942: PPUSH
26943: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26947: LD_VAR 0 1
26951: PPUSH
26952: LD_VAR 0 2
26956: PPUSH
26957: CALL_OW 52
// end ;
26961: GO 26865
26963: POP
26964: POP
// missionStage := 8 ;
26965: LD_ADDR_EXP 15
26969: PUSH
26970: LD_INT 8
26972: ST_TO_ADDR
// DialogueOn ;
26973: CALL_OW 6
// if Stevens then
26977: LD_EXP 41
26981: IFFALSE 27095
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26983: LD_EXP 41
26987: PPUSH
26988: CALL_OW 310
26992: PPUSH
26993: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26997: LD_EXP 41
27001: PPUSH
27002: LD_STRING D8-Huck-1
27004: PPUSH
27005: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27009: LD_EXP 39
27013: PPUSH
27014: LD_STRING D8-JMM-1
27016: PPUSH
27017: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27021: LD_EXP 41
27025: PPUSH
27026: LD_STRING D8-Huck-2
27028: PPUSH
27029: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27033: LD_EXP 39
27037: PPUSH
27038: LD_STRING D8-JMM-2
27040: PPUSH
27041: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27045: LD_EXP 41
27049: PPUSH
27050: LD_STRING D8-Huck-3
27052: PPUSH
27053: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27057: LD_EXP 39
27061: PPUSH
27062: LD_STRING D8-JMM-3
27064: PPUSH
27065: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27069: LD_EXP 41
27073: PPUSH
27074: LD_STRING D8-Huck-4
27076: PPUSH
27077: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27081: LD_EXP 39
27085: PPUSH
27086: LD_STRING D8-JMM-4
27088: PPUSH
27089: CALL_OW 88
// end else
27093: GO 27205
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27095: LD_EXP 55
27099: PPUSH
27100: CALL_OW 310
27104: PPUSH
27105: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27109: LD_EXP 55
27113: PPUSH
27114: LD_STRING D8-Huck-1
27116: PPUSH
27117: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27121: LD_EXP 39
27125: PPUSH
27126: LD_STRING D8-JMM-1a
27128: PPUSH
27129: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27133: LD_EXP 55
27137: PPUSH
27138: LD_STRING D8-Huck-2
27140: PPUSH
27141: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27145: LD_EXP 39
27149: PPUSH
27150: LD_STRING D8-JMM-2
27152: PPUSH
27153: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27157: LD_EXP 55
27161: PPUSH
27162: LD_STRING D8-Huck-3
27164: PPUSH
27165: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27169: LD_EXP 39
27173: PPUSH
27174: LD_STRING D8-JMM-3
27176: PPUSH
27177: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27181: LD_EXP 55
27185: PPUSH
27186: LD_STRING D8-Huck-4
27188: PPUSH
27189: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27193: LD_EXP 39
27197: PPUSH
27198: LD_STRING D8-JMM-4
27200: PPUSH
27201: CALL_OW 88
// end ; DialogueOff ;
27205: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27209: LD_INT 25
27211: PPUSH
27212: LD_INT 1
27214: PPUSH
27215: LD_INT 1
27217: PPUSH
27218: CALL_OW 322
// end ;
27222: PPOPN 3
27224: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27225: LD_INT 1
27227: PPUSH
27228: LD_EXP 71
27232: PPUSH
27233: CALL_OW 292
27237: IFFALSE 27488
27239: GO 27241
27241: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27242: LD_EXP 71
27246: PPUSH
27247: CALL_OW 87
// DialogueOn ;
27251: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27255: LD_EXP 39
27259: PPUSH
27260: LD_STRING D10nB-JMM-1
27262: PPUSH
27263: CALL_OW 88
// if BurlakStatus = 1 then
27267: LD_EXP 9
27271: PUSH
27272: LD_INT 1
27274: EQUAL
27275: IFFALSE 27289
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27277: LD_EXP 70
27281: PPUSH
27282: LD_STRING D10nB-Vse-1a
27284: PPUSH
27285: CALL_OW 94
// end ; if BurlakStatus = 0 then
27289: LD_EXP 9
27293: PUSH
27294: LD_INT 0
27296: EQUAL
27297: IFFALSE 27311
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27299: LD_EXP 70
27303: PPUSH
27304: LD_STRING D10nB-Vse-1
27306: PPUSH
27307: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27311: LD_EXP 39
27315: PPUSH
27316: LD_STRING D10nB-JMM-2
27318: PPUSH
27319: CALL_OW 88
// if KappaStatus then
27323: LD_EXP 2
27327: IFFALSE 27341
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27329: LD_EXP 70
27333: PPUSH
27334: LD_STRING D10nB-Vse-5a
27336: PPUSH
27337: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27341: LD_EXP 2
27345: NOT
27346: PUSH
27347: LD_EXP 6
27351: PUSH
27352: LD_INT 0
27354: EQUAL
27355: AND
27356: IFFALSE 27484
// begin if JMMGirl = 1 then
27358: LD_EXP 7
27362: PUSH
27363: LD_INT 1
27365: EQUAL
27366: IFFALSE 27416
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27368: LD_EXP 70
27372: PPUSH
27373: LD_STRING D10nB-Vse-2
27375: PPUSH
27376: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27380: LD_EXP 39
27384: PPUSH
27385: LD_STRING D10nB-JMM-3
27387: PPUSH
27388: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27392: LD_EXP 70
27396: PPUSH
27397: LD_STRING D10nB-Vse-3
27399: PPUSH
27400: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27404: LD_EXP 39
27408: PPUSH
27409: LD_STRING D10nB-JMM-4
27411: PPUSH
27412: CALL_OW 88
// end ; if JMMGirl = 2 then
27416: LD_EXP 7
27420: PUSH
27421: LD_INT 2
27423: EQUAL
27424: IFFALSE 27450
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27426: LD_EXP 70
27430: PPUSH
27431: LD_STRING D10nB-Vse-4
27433: PPUSH
27434: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27438: LD_EXP 39
27442: PPUSH
27443: LD_STRING D10nB-JMM-5
27445: PPUSH
27446: CALL_OW 88
// end ; if JMMGirl = 3 then
27450: LD_EXP 7
27454: PUSH
27455: LD_INT 3
27457: EQUAL
27458: IFFALSE 27484
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27460: LD_EXP 70
27464: PPUSH
27465: LD_STRING D10nB-Vse-5
27467: PPUSH
27468: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27472: LD_EXP 39
27476: PPUSH
27477: LD_STRING D10nB-JMM-6
27479: PPUSH
27480: CALL_OW 88
// end ; end ; DialogueOff ;
27484: CALL_OW 7
// end ;
27488: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27489: LD_EXP 14
27493: PUSH
27494: LD_INT 115500
27496: GREATEREQUAL
27497: IFFALSE 27873
27499: GO 27501
27501: DISABLE
27502: LD_INT 0
27504: PPUSH
// begin missionStage := 10 ;
27505: LD_ADDR_EXP 15
27509: PUSH
27510: LD_INT 10
27512: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27513: LD_ADDR_VAR 0 1
27517: PUSH
27518: LD_INT 22
27520: PUSH
27521: LD_INT 1
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 23
27530: PUSH
27531: LD_INT 1
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 26
27540: PUSH
27541: LD_INT 1
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 3
27550: PUSH
27551: LD_INT 25
27553: PUSH
27554: LD_INT 12
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 3
27567: PUSH
27568: LD_INT 25
27570: PUSH
27571: LD_INT 16
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: PPUSH
27589: CALL_OW 69
27593: PUSH
27594: LD_EXP 39
27598: PUSH
27599: LD_EXP 60
27603: PUSH
27604: LD_EXP 41
27608: PUSH
27609: LD_EXP 55
27613: PUSH
27614: LD_EXP 42
27618: PUSH
27619: LD_EXP 43
27623: PUSH
27624: LD_EXP 44
27628: PUSH
27629: LD_EXP 45
27633: PUSH
27634: LD_EXP 46
27638: PUSH
27639: LD_EXP 47
27643: PUSH
27644: LD_EXP 48
27648: PUSH
27649: LD_EXP 49
27653: PUSH
27654: LD_EXP 50
27658: PUSH
27659: LD_EXP 51
27663: PUSH
27664: LD_EXP 52
27668: PUSH
27669: LD_EXP 53
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: DIFF
27692: ST_TO_ADDR
// if not tmp and Brown then
27693: LD_VAR 0 1
27697: NOT
27698: PUSH
27699: LD_EXP 47
27703: AND
27704: IFFALSE 27719
// tmp := [ Brown ] ;
27706: LD_ADDR_VAR 0 1
27710: PUSH
27711: LD_EXP 47
27715: PUSH
27716: EMPTY
27717: LIST
27718: ST_TO_ADDR
// DialogueOn ;
27719: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27723: LD_VAR 0 1
27727: PUSH
27728: LD_INT 1
27730: ARRAY
27731: PPUSH
27732: LD_STRING D11-Sol1-1
27734: PPUSH
27735: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27739: LD_EXP 64
27743: PPUSH
27744: LD_STRING D11-Pla-1
27746: PPUSH
27747: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27751: LD_EXP 65
27755: PPUSH
27756: LD_STRING D11-Kov-1
27758: PPUSH
27759: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27763: LD_EXP 64
27767: PPUSH
27768: LD_STRING D11-Pla-2
27770: PPUSH
27771: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27775: LD_VAR 0 1
27779: PUSH
27780: LD_INT 1
27782: ARRAY
27783: PPUSH
27784: LD_STRING D11-Sol1-2
27786: PPUSH
27787: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27791: LD_EXP 39
27795: PPUSH
27796: LD_STRING D11-JMM-2
27798: PPUSH
27799: CALL_OW 88
// DialogueOff ;
27803: CALL_OW 7
// allowBehemothConstruct := true ;
27807: LD_ADDR_EXP 25
27811: PUSH
27812: LD_INT 1
27814: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27815: LD_STRING M4
27817: PPUSH
27818: CALL_OW 337
// BuildBehemoths ;
27822: CALL 7741 0 0
// repeat wait ( 15 15$00 ) ;
27826: LD_INT 31500
27828: PPUSH
27829: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27833: LD_EXP 27
27837: IFFALSE 27841
// break ;
27839: GO 27873
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27841: LD_INT 267
27843: PPUSH
27844: CALL_OW 274
27848: PPUSH
27849: LD_INT 1
27851: PPUSH
27852: CALL_OW 275
27856: PUSH
27857: LD_INT 1000
27859: GREATEREQUAL
27860: IFFALSE 27866
// BuildBehemoths ;
27862: CALL 7741 0 0
// until not behemothBuilders ;
27866: LD_EXP 73
27870: NOT
27871: IFFALSE 27826
// end ;
27873: PPOPN 1
27875: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27876: LD_EXP 73
27880: NOT
27881: PUSH
27882: LD_EXP 28
27886: NOT
27887: AND
27888: PUSH
27889: LD_EXP 25
27893: AND
27894: IFFALSE 27914
27896: GO 27898
27898: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27899: LD_STRING M4a
27901: PPUSH
27902: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27906: LD_ADDR_EXP 27
27910: PUSH
27911: LD_INT 1
27913: ST_TO_ADDR
// end ;
27914: END
// every 0 0$1 trigger behemothDone do
27915: LD_EXP 28
27919: IFFALSE 27931
27921: GO 27923
27923: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27924: LD_STRING M4b
27926: PPUSH
27927: CALL_OW 337
27931: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27932: LD_EXP 29
27936: NOT
27937: IFFALSE 28133
27939: GO 27941
27941: DISABLE
27942: LD_INT 0
27944: PPUSH
27945: PPUSH
// begin enable ;
27946: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27947: LD_ADDR_VAR 0 1
27951: PUSH
27952: LD_INT 3
27954: PPUSH
27955: CALL 102683 0 1
27959: ST_TO_ADDR
// if not tmp and not behemothDone then
27960: LD_VAR 0 1
27964: NOT
27965: PUSH
27966: LD_EXP 28
27970: NOT
27971: AND
27972: IFFALSE 28008
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27974: LD_ADDR_VAR 0 1
27978: PUSH
27979: LD_INT 22
27981: PUSH
27982: LD_INT 3
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 30
27991: PUSH
27992: LD_INT 37
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PPUSH
28003: CALL_OW 69
28007: ST_TO_ADDR
// if not tmp then
28008: LD_VAR 0 1
28012: NOT
28013: IFFALSE 28017
// exit ;
28015: GO 28133
// for i in tmp do
28017: LD_ADDR_VAR 0 2
28021: PUSH
28022: LD_VAR 0 1
28026: PUSH
28027: FOR_IN
28028: IFFALSE 28131
// if See ( 1 , i ) then
28030: LD_INT 1
28032: PPUSH
28033: LD_VAR 0 2
28037: PPUSH
28038: CALL_OW 292
28042: IFFALSE 28129
// begin if GetType ( i ) = unit_building then
28044: LD_VAR 0 2
28048: PPUSH
28049: CALL_OW 247
28053: PUSH
28054: LD_INT 3
28056: EQUAL
28057: IFFALSE 28095
// begin CenterNowOnUnits ( i ) ;
28059: LD_VAR 0 2
28063: PPUSH
28064: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28068: LD_EXP 39
28072: PPUSH
28073: LD_STRING D17a-JMM-1
28075: PPUSH
28076: CALL_OW 88
// seeBehemoth := true ;
28080: LD_ADDR_EXP 29
28084: PUSH
28085: LD_INT 1
28087: ST_TO_ADDR
// disable ;
28088: DISABLE
// exit ;
28089: POP
28090: POP
28091: GO 28133
// end else
28093: GO 28129
// begin CenterNowOnUnits ( i ) ;
28095: LD_VAR 0 2
28099: PPUSH
28100: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28104: LD_EXP 39
28108: PPUSH
28109: LD_STRING D17b-JMM-1
28111: PPUSH
28112: CALL_OW 88
// seeBehemoth := true ;
28116: LD_ADDR_EXP 29
28120: PUSH
28121: LD_INT 1
28123: ST_TO_ADDR
// disable ;
28124: DISABLE
// exit ;
28125: POP
28126: POP
28127: GO 28133
// end ; end ;
28129: GO 28027
28131: POP
28132: POP
// end ;
28133: PPOPN 2
28135: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28136: LD_EXP 14
28140: PUSH
28141: LD_INT 123200
28143: GREATEREQUAL
28144: IFFALSE 29320
28146: GO 28148
28148: DISABLE
28149: LD_INT 0
28151: PPUSH
28152: PPUSH
28153: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28154: LD_INT 2
28156: PPUSH
28157: LD_INT 23
28159: PUSH
28160: LD_INT 3
28162: PUSH
28163: LD_INT 3
28165: PUSH
28166: LD_INT 48
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: PUSH
28175: EMPTY
28176: LIST
28177: PPUSH
28178: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
28182: LD_INT 35
28184: PPUSH
28185: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28189: LD_INT 22
28191: PUSH
28192: LD_INT 3
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 48
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: IFFALSE 28182
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28219: LD_ADDR_VAR 0 1
28223: PUSH
28224: LD_INT 22
28226: PUSH
28227: LD_INT 3
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 34
28236: PUSH
28237: LD_INT 48
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PPUSH
28248: CALL_OW 69
28252: PUSH
28253: LD_INT 1
28255: ARRAY
28256: ST_TO_ADDR
// missionStage := 12 ;
28257: LD_ADDR_EXP 15
28261: PUSH
28262: LD_INT 12
28264: ST_TO_ADDR
// platonovHasBomb := true ;
28265: LD_ADDR_EXP 30
28269: PUSH
28270: LD_INT 1
28272: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28273: LD_VAR 0 1
28277: PPUSH
28278: LD_INT 181
28280: PPUSH
28281: LD_INT 86
28283: PPUSH
28284: CALL_OW 171
// AddComHold ( bomb ) ;
28288: LD_VAR 0 1
28292: PPUSH
28293: CALL_OW 200
// wait ( 0 0$10 ) ;
28297: LD_INT 350
28299: PPUSH
28300: CALL_OW 67
// DialogueOn ;
28304: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28308: LD_EXP 64
28312: PPUSH
28313: LD_STRING D15-Pla-1
28315: PPUSH
28316: CALL_OW 94
// dec = Query ( Q15a ) ;
28320: LD_ADDR_VAR 0 2
28324: PUSH
28325: LD_STRING Q15a
28327: PPUSH
28328: CALL_OW 97
28332: ST_TO_ADDR
// if dec = 1 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 1
28340: EQUAL
28341: IFFALSE 28364
// begin Say ( JMM , D15a-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15a-JMM-1
28350: PPUSH
28351: CALL_OW 88
// YouLost ( Surrender ) ;
28355: LD_STRING Surrender
28357: PPUSH
28358: CALL_OW 104
// exit ;
28362: GO 29320
// end ; if dec = 2 then
28364: LD_VAR 0 2
28368: PUSH
28369: LD_INT 2
28371: EQUAL
28372: IFFALSE 28441
// begin Say ( JMM , D15b-JMM-1 ) ;
28374: LD_EXP 39
28378: PPUSH
28379: LD_STRING D15b-JMM-1
28381: PPUSH
28382: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28386: LD_EXP 64
28390: PPUSH
28391: LD_STRING D15b-Pla-1
28393: PPUSH
28394: CALL_OW 94
// DialogueOff ;
28398: CALL_OW 7
// wait ( 3 3$00 ) ;
28402: LD_INT 6300
28404: PPUSH
28405: CALL_OW 67
// DialogueOn ;
28409: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28413: LD_EXP 39
28417: PPUSH
28418: LD_STRING D15d-JMM-1a
28420: PPUSH
28421: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28425: LD_EXP 64
28429: PPUSH
28430: LD_STRING D15d-Pla-1
28432: PPUSH
28433: CALL_OW 94
// DialogueOff ;
28437: CALL_OW 7
// end ; if dec = 3 then
28441: LD_VAR 0 2
28445: PUSH
28446: LD_INT 3
28448: EQUAL
28449: IFFALSE 28503
// begin Say ( JMM , D15c-JMM-1 ) ;
28451: LD_EXP 39
28455: PPUSH
28456: LD_STRING D15c-JMM-1
28458: PPUSH
28459: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28463: LD_EXP 64
28467: PPUSH
28468: LD_STRING D15c-Pla-1
28470: PPUSH
28471: CALL_OW 94
// DialogueOff ;
28475: CALL_OW 7
// wait ( 0 0$15 ) ;
28479: LD_INT 525
28481: PPUSH
28482: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28486: LD_VAR 0 1
28490: PPUSH
28491: LD_INT 60
28493: PPUSH
28494: LD_INT 95
28496: PPUSH
28497: CALL_OW 116
// exit ;
28501: GO 29320
// end ; if dec = 4 then
28503: LD_VAR 0 2
28507: PUSH
28508: LD_INT 4
28510: EQUAL
28511: IFFALSE 28541
// begin Say ( JMM , D15d-JMM-1 ) ;
28513: LD_EXP 39
28517: PPUSH
28518: LD_STRING D15d-JMM-1
28520: PPUSH
28521: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28525: LD_EXP 64
28529: PPUSH
28530: LD_STRING D15d-Pla-1
28532: PPUSH
28533: CALL_OW 94
// DialogueOff ;
28537: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28541: LD_EXP 62
28545: PPUSH
28546: CALL_OW 302
28550: PUSH
28551: LD_EXP 62
28555: PPUSH
28556: CALL_OW 255
28560: PUSH
28561: LD_INT 1
28563: EQUAL
28564: AND
28565: PUSH
28566: LD_INT 22
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 34
28578: PUSH
28579: LD_INT 8
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PPUSH
28590: CALL_OW 69
28594: NOT
28595: AND
28596: IFFALSE 29221
// begin SetSide ( Friend , 8 ) ;
28598: LD_EXP 62
28602: PPUSH
28603: LD_INT 8
28605: PPUSH
28606: CALL_OW 235
// if IsInUnit ( Friend ) then
28610: LD_EXP 62
28614: PPUSH
28615: CALL_OW 310
28619: IFFALSE 28630
// ComExitBuilding ( Friend ) ;
28621: LD_EXP 62
28625: PPUSH
28626: CALL_OW 122
// if IsDriver ( Friend ) then
28630: LD_EXP 62
28634: PPUSH
28635: CALL 100228 0 1
28639: IFFALSE 28650
// ComExitVehicle ( Friend ) ;
28641: LD_EXP 62
28645: PPUSH
28646: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28650: LD_EXP 62
28654: PPUSH
28655: LD_INT 9
28657: PPUSH
28658: LD_INT 2
28660: PPUSH
28661: CALL_OW 171
// wait ( 0 0$05 ) ;
28665: LD_INT 175
28667: PPUSH
28668: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28672: LD_EXP 62
28676: PPUSH
28677: CALL_OW 87
// DialogueOn ;
28681: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28685: LD_EXP 39
28689: PPUSH
28690: LD_STRING D16-JMM-1
28692: PPUSH
28693: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28697: LD_EXP 62
28701: PPUSH
28702: LD_STRING D16-Friend-1
28704: PPUSH
28705: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28709: LD_EXP 39
28713: PPUSH
28714: LD_STRING D16-JMM-2
28716: PPUSH
28717: CALL_OW 88
// DialogueOff ;
28721: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28725: LD_EXP 62
28729: PPUSH
28730: LD_INT 1
28732: PPUSH
28733: CALL_OW 235
// ComHold ( Friend ) ;
28737: LD_EXP 62
28741: PPUSH
28742: CALL_OW 140
// wait ( 0 0$20 ) ;
28746: LD_INT 700
28748: PPUSH
28749: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28753: LD_EXP 62
28757: PPUSH
28758: LD_INT 9
28760: PPUSH
28761: LD_INT 2
28763: PPUSH
28764: CALL_OW 297
28768: PUSH
28769: LD_INT 30
28771: LESS
28772: IFFALSE 28841
// begin SetSide ( Friend , 8 ) ;
28774: LD_EXP 62
28778: PPUSH
28779: LD_INT 8
28781: PPUSH
28782: CALL_OW 235
// if IsInUnit ( Friend ) then
28786: LD_EXP 62
28790: PPUSH
28791: CALL_OW 310
28795: IFFALSE 28806
// ComExitBuilding ( Friend ) ;
28797: LD_EXP 62
28801: PPUSH
28802: CALL_OW 122
// if IsDriver ( Friend ) then
28806: LD_EXP 62
28810: PPUSH
28811: CALL 100228 0 1
28815: IFFALSE 28826
// ComExitVehicle ( Friend ) ;
28817: LD_EXP 62
28821: PPUSH
28822: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28826: LD_EXP 62
28830: PPUSH
28831: LD_INT 9
28833: PPUSH
28834: LD_INT 2
28836: PPUSH
28837: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28841: LD_INT 1050
28843: PPUSH
28844: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28848: LD_INT 22
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: PUSH
28858: LD_INT 34
28860: PUSH
28861: LD_INT 8
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PPUSH
28872: CALL_OW 69
28876: NOT
28877: IFFALSE 29199
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28879: LD_ADDR_VAR 0 3
28883: PUSH
28884: LD_INT 22
28886: PUSH
28887: LD_INT 1
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 26
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 3
28906: PUSH
28907: LD_INT 25
28909: PUSH
28910: LD_INT 12
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 25
28919: PUSH
28920: LD_INT 16
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: LIST
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 69
28941: PUSH
28942: LD_EXP 39
28946: PUSH
28947: LD_EXP 41
28951: PUSH
28952: LD_EXP 55
28956: PUSH
28957: LD_EXP 42
28961: PUSH
28962: LD_EXP 43
28966: PUSH
28967: LD_EXP 44
28971: PUSH
28972: LD_EXP 45
28976: PUSH
28977: LD_EXP 46
28981: PUSH
28982: LD_EXP 47
28986: PUSH
28987: LD_EXP 48
28991: PUSH
28992: LD_EXP 49
28996: PUSH
28997: LD_EXP 50
29001: PUSH
29002: LD_EXP 51
29006: PUSH
29007: LD_EXP 52
29011: PUSH
29012: LD_EXP 53
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: DIFF
29034: ST_TO_ADDR
// DialogueOn ;
29035: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29039: LD_EXP 64
29043: PPUSH
29044: LD_STRING D16a-Pla-1
29046: PPUSH
29047: CALL_OW 94
// if Stevens then
29051: LD_EXP 41
29055: IFFALSE 29071
// Say ( Stevens , D16a-Huck-1 ) else
29057: LD_EXP 41
29061: PPUSH
29062: LD_STRING D16a-Huck-1
29064: PPUSH
29065: CALL_OW 88
29069: GO 29113
// if Baker then
29071: LD_EXP 55
29075: IFFALSE 29091
// Say ( Baker , D16a-Huck-1 ) else
29077: LD_EXP 55
29081: PPUSH
29082: LD_STRING D16a-Huck-1
29084: PPUSH
29085: CALL_OW 88
29089: GO 29113
// if tmp then
29091: LD_VAR 0 3
29095: IFFALSE 29113
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29097: LD_VAR 0 3
29101: PUSH
29102: LD_INT 1
29104: ARRAY
29105: PPUSH
29106: LD_STRING D16a-Sol1-1
29108: PPUSH
29109: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29113: LD_EXP 62
29117: PPUSH
29118: CALL_OW 255
29122: PUSH
29123: LD_INT 8
29125: EQUAL
29126: IFFALSE 29142
// Say ( JMM , D16a-JMM-1 ) else
29128: LD_EXP 39
29132: PPUSH
29133: LD_STRING D16a-JMM-1
29135: PPUSH
29136: CALL_OW 88
29140: GO 29178
// begin Say ( JMM , D16a-JMM-1a ) ;
29142: LD_EXP 39
29146: PPUSH
29147: LD_STRING D16a-JMM-1a
29149: PPUSH
29150: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29154: LD_EXP 62
29158: PPUSH
29159: LD_STRING D16a-Friend-1
29161: PPUSH
29162: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29166: LD_EXP 62
29170: PPUSH
29171: LD_INT 3
29173: PPUSH
29174: CALL_OW 235
// end ; DialogueOff ;
29178: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29182: LD_VAR 0 1
29186: PPUSH
29187: LD_INT 60
29189: PPUSH
29190: LD_INT 95
29192: PPUSH
29193: CALL_OW 116
// end else
29197: GO 29219
// begin DialogueOn ;
29199: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29203: LD_EXP 64
29207: PPUSH
29208: LD_STRING D16c-Pla-
29210: PPUSH
29211: CALL_OW 94
// DialogueOff ;
29215: CALL_OW 7
// end ; end else
29219: GO 29320
// begin wait ( 3 3$00 ) ;
29221: LD_INT 6300
29223: PPUSH
29224: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29228: LD_INT 22
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 34
29240: PUSH
29241: LD_INT 8
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 69
29256: NOT
29257: IFFALSE 29300
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29259: LD_EXP 64
29263: PPUSH
29264: LD_STRING D16b-Pla-1
29266: PPUSH
29267: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29271: LD_EXP 39
29275: PPUSH
29276: LD_STRING D16b-JMM-
29278: PPUSH
29279: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: LD_INT 60
29290: PPUSH
29291: LD_INT 95
29293: PPUSH
29294: CALL_OW 116
// end else
29298: GO 29320
// begin DialogueOn ;
29300: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29304: LD_EXP 64
29308: PPUSH
29309: LD_STRING D16c-Pla-
29311: PPUSH
29312: CALL_OW 94
// DialogueOff ;
29316: CALL_OW 7
// end ; end ; end ;
29320: PPOPN 3
29322: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29323: LD_EXP 14
29327: PUSH
29328: LD_INT 126000
29330: GREATEREQUAL
29331: PUSH
29332: LD_EXP 23
29336: NOT
29337: AND
29338: PUSH
29339: LD_EXP 74
29343: PPUSH
29344: CALL_OW 302
29348: AND
29349: IFFALSE 29707
29351: GO 29353
29353: DISABLE
29354: LD_INT 0
29356: PPUSH
// begin missionStage = 11 ;
29357: LD_ADDR_EXP 15
29361: PUSH
29362: LD_INT 11
29364: ST_TO_ADDR
// DialogueOn ;
29365: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29369: LD_EXP 74
29373: PPUSH
29374: LD_STRING D9-Roth-1
29376: PPUSH
29377: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29381: LD_EXP 39
29385: PPUSH
29386: LD_STRING D9-JMM-1
29388: PPUSH
29389: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29393: LD_EXP 74
29397: PPUSH
29398: LD_STRING D9-Roth-2
29400: PPUSH
29401: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29405: LD_EXP 74
29409: PPUSH
29410: LD_STRING D9-Roth-2a
29412: PPUSH
29413: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29417: LD_EXP 64
29421: PPUSH
29422: LD_STRING D9-Pla-2
29424: PPUSH
29425: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29429: LD_EXP 74
29433: PPUSH
29434: LD_STRING D9-Roth-3
29436: PPUSH
29437: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29441: LD_EXP 64
29445: PPUSH
29446: LD_STRING D9-Pla-3
29448: PPUSH
29449: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29453: LD_EXP 74
29457: PPUSH
29458: LD_STRING D9-Roth-4
29460: PPUSH
29461: CALL_OW 94
// dec = Query ( Q9 ) ;
29465: LD_ADDR_VAR 0 1
29469: PUSH
29470: LD_STRING Q9
29472: PPUSH
29473: CALL_OW 97
29477: ST_TO_ADDR
// if dec = 1 then
29478: LD_VAR 0 1
29482: PUSH
29483: LD_INT 1
29485: EQUAL
29486: IFFALSE 29500
// SayRadio ( Roth , D9a-Roth-1 ) ;
29488: LD_EXP 74
29492: PPUSH
29493: LD_STRING D9a-Roth-1
29495: PPUSH
29496: CALL_OW 94
// if dec = 2 then
29500: LD_VAR 0 1
29504: PUSH
29505: LD_INT 2
29507: EQUAL
29508: IFFALSE 29534
// begin Say ( JMM , D9b-JMM-1 ) ;
29510: LD_EXP 39
29514: PPUSH
29515: LD_STRING D9b-JMM-1
29517: PPUSH
29518: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29522: LD_EXP 74
29526: PPUSH
29527: LD_STRING D9b-Roth-1
29529: PPUSH
29530: CALL_OW 94
// end ; if dec = 3 then
29534: LD_VAR 0 1
29538: PUSH
29539: LD_INT 3
29541: EQUAL
29542: IFFALSE 29604
// begin Say ( JMM , D9c-JMM-1 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9c-JMM-1
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9c-Roth-1
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9c-JMM-2
29575: PPUSH
29576: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29580: LD_EXP 74
29584: PPUSH
29585: LD_STRING D9c-Roth-2
29587: PPUSH
29588: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29592: LD_EXP 39
29596: PPUSH
29597: LD_STRING D9c-JMM-3
29599: PPUSH
29600: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29604: LD_EXP 74
29608: PPUSH
29609: LD_STRING D9c-Roth-3
29611: PPUSH
29612: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29616: LD_EXP 74
29620: PPUSH
29621: LD_STRING D9cont-Roth-1
29623: PPUSH
29624: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29628: LD_EXP 39
29632: PPUSH
29633: LD_STRING D9cont-JMM-1
29635: PPUSH
29636: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29640: LD_EXP 74
29644: PPUSH
29645: LD_STRING D9cont-Roth-2
29647: PPUSH
29648: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29652: LD_EXP 39
29656: PPUSH
29657: LD_STRING D9cont-JMM-2
29659: PPUSH
29660: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29664: LD_EXP 74
29668: PPUSH
29669: LD_STRING D9cont-Roth-3
29671: PPUSH
29672: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29676: LD_EXP 39
29680: PPUSH
29681: LD_STRING D9cont-JMM-3
29683: PPUSH
29684: CALL_OW 88
// DialogueOff ;
29688: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29692: LD_STRING M3
29694: PPUSH
29695: CALL_OW 337
// allianceActive := true ;
29699: LD_ADDR_EXP 31
29703: PUSH
29704: LD_INT 1
29706: ST_TO_ADDR
// end ;
29707: PPOPN 1
29709: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29710: LD_INT 1
29712: PPUSH
29713: LD_INT 126
29715: PPUSH
29716: CALL_OW 292
29720: PUSH
29721: LD_EXP 64
29725: PPUSH
29726: CALL_OW 310
29730: AND
29731: IFFALSE 29811
29733: GO 29735
29735: DISABLE
29736: LD_INT 0
29738: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29739: LD_EXP 64
29743: PPUSH
29744: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29748: LD_ADDR_VAR 0 1
29752: PUSH
29753: LD_INT 4
29755: PPUSH
29756: LD_INT 22
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PPUSH
29766: CALL_OW 70
29770: PPUSH
29771: LD_EXP 64
29775: PPUSH
29776: CALL_OW 74
29780: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29781: LD_EXP 64
29785: PPUSH
29786: LD_VAR 0 1
29790: PUSH
29791: LD_INT 1
29793: ARRAY
29794: PPUSH
29795: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29799: LD_EXP 64
29803: PPUSH
29804: LD_STRING D18-Pla-1
29806: PPUSH
29807: CALL_OW 88
// end ;
29811: PPOPN 1
29813: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29814: LD_EXP 64
29818: PPUSH
29819: CALL_OW 301
29823: PUSH
29824: LD_EXP 67
29828: PPUSH
29829: CALL_OW 301
29833: AND
29834: PUSH
29835: LD_INT 22
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 21
29847: PUSH
29848: LD_INT 1
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 50
29857: PUSH
29858: EMPTY
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: LIST
29865: PPUSH
29866: CALL_OW 69
29870: PUSH
29871: LD_INT 7
29873: PUSH
29874: LD_INT 8
29876: PUSH
29877: LD_INT 9
29879: PUSH
29880: LD_INT 10
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: PUSH
29889: LD_OWVAR 67
29893: ARRAY
29894: LESS
29895: AND
29896: IFFALSE 30667
29898: GO 29900
29900: DISABLE
29901: LD_INT 0
29903: PPUSH
29904: PPUSH
29905: PPUSH
29906: PPUSH
// begin MC_Kill ( 2 ) ;
29907: LD_INT 2
29909: PPUSH
29910: CALL 35501 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 3
29919: PPUSH
29920: LD_INT 1
29922: PPUSH
29923: LD_INT 1
29925: PPUSH
29926: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29930: LD_ADDR_VAR 0 1
29934: PUSH
29935: LD_INT 22
29937: PUSH
29938: LD_INT 3
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 21
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 24
29957: PUSH
29958: LD_INT 900
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: LIST
29969: PPUSH
29970: CALL_OW 69
29974: PUSH
29975: FOR_IN
29976: IFFALSE 30007
// if GetSex ( i ) = sex_male then
29978: LD_VAR 0 1
29982: PPUSH
29983: CALL_OW 258
29987: PUSH
29988: LD_INT 1
29990: EQUAL
29991: IFFALSE 30005
// begin tmp = i ;
29993: LD_ADDR_VAR 0 2
29997: PUSH
29998: LD_VAR 0 1
30002: ST_TO_ADDR
// break ;
30003: GO 30007
// end ;
30005: GO 29975
30007: POP
30008: POP
// if tmp = 0 then
30009: LD_VAR 0 2
30013: PUSH
30014: LD_INT 0
30016: EQUAL
30017: IFFALSE 30071
// begin uc_side = 3 ;
30019: LD_ADDR_OWVAR 20
30023: PUSH
30024: LD_INT 3
30026: ST_TO_ADDR
// uc_nation = 3 ;
30027: LD_ADDR_OWVAR 21
30031: PUSH
30032: LD_INT 3
30034: ST_TO_ADDR
// hc_name =  ;
30035: LD_ADDR_OWVAR 26
30039: PUSH
30040: LD_STRING 
30042: ST_TO_ADDR
// hc_gallery =  ;
30043: LD_ADDR_OWVAR 33
30047: PUSH
30048: LD_STRING 
30050: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30051: LD_INT 1
30053: PPUSH
30054: LD_INT 10
30056: PPUSH
30057: CALL_OW 381
// tmp = CreateHuman ;
30061: LD_ADDR_VAR 0 2
30065: PUSH
30066: CALL_OW 44
30070: ST_TO_ADDR
// end ; DialogueOn ;
30071: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30075: LD_VAR 0 2
30079: PPUSH
30080: LD_STRING DSurrenderRussians-RSol1-1a
30082: PPUSH
30083: CALL_OW 94
// DialogueOff ;
30087: CALL_OW 7
// russianDestroyed := true ;
30091: LD_ADDR_EXP 21
30095: PUSH
30096: LD_INT 1
30098: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30099: LD_INT 22
30101: PUSH
30102: LD_INT 3
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 21
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PPUSH
30123: CALL_OW 69
30127: PPUSH
30128: CALL_OW 122
// wait ( 0 0$1 ) ;
30132: LD_INT 35
30134: PPUSH
30135: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30139: LD_INT 22
30141: PUSH
30142: LD_INT 3
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 21
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PPUSH
30163: CALL_OW 69
30167: PPUSH
30168: LD_INT 25
30170: PPUSH
30171: CALL_OW 173
// wait ( 0 0$10 ) ;
30175: LD_INT 350
30177: PPUSH
30178: CALL_OW 67
// PrepareOmarInvasion ;
30182: CALL 13983 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30186: LD_ADDR_VAR 0 2
30190: PUSH
30191: LD_EXP 92
30195: PPUSH
30196: CALL_OW 250
30200: PUSH
30201: LD_EXP 92
30205: PPUSH
30206: CALL_OW 251
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30215: LD_VAR 0 2
30219: PUSH
30220: LD_INT 1
30222: ARRAY
30223: PPUSH
30224: LD_VAR 0 2
30228: PUSH
30229: LD_INT 2
30231: ARRAY
30232: PPUSH
30233: LD_INT 1
30235: PPUSH
30236: LD_INT 8
30238: NEG
30239: PPUSH
30240: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30244: LD_EXP 92
30248: PPUSH
30249: CALL_OW 87
// DialogueOn ;
30253: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30257: LD_EXP 39
30261: PPUSH
30262: LD_STRING D19-JMM-1
30264: PPUSH
30265: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30269: LD_ADDR_VAR 0 3
30273: PUSH
30274: LD_INT 22
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 26
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 2
30296: PUSH
30297: LD_INT 25
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 25
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 25
30319: PUSH
30320: LD_INT 3
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 25
30329: PUSH
30330: LD_INT 4
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 25
30339: PUSH
30340: LD_INT 5
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 25
30349: PUSH
30350: LD_INT 8
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: LIST
30370: PPUSH
30371: CALL_OW 69
30375: PUSH
30376: LD_EXP 39
30380: PUSH
30381: LD_EXP 40
30385: PUSH
30386: LD_EXP 41
30390: PUSH
30391: LD_EXP 42
30395: PUSH
30396: LD_EXP 43
30400: PUSH
30401: LD_EXP 44
30405: PUSH
30406: LD_EXP 45
30410: PUSH
30411: LD_EXP 46
30415: PUSH
30416: LD_EXP 47
30420: PUSH
30421: LD_EXP 48
30425: PUSH
30426: LD_EXP 49
30430: PUSH
30431: LD_EXP 50
30435: PUSH
30436: LD_EXP 51
30440: PUSH
30441: LD_EXP 52
30445: PUSH
30446: LD_EXP 53
30450: PUSH
30451: LD_EXP 54
30455: PUSH
30456: LD_EXP 55
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: DIFF
30480: ST_TO_ADDR
// if tmp2 then
30481: LD_VAR 0 3
30485: IFFALSE 30503
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30487: LD_VAR 0 3
30491: PUSH
30492: LD_INT 1
30494: ARRAY
30495: PPUSH
30496: LD_STRING D19-Sol1-1
30498: PPUSH
30499: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30503: LD_EXP 39
30507: PPUSH
30508: LD_STRING D19-JMM-2
30510: PPUSH
30511: CALL_OW 88
// DialogueOff ;
30515: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30519: LD_VAR 0 2
30523: PUSH
30524: LD_INT 1
30526: ARRAY
30527: PPUSH
30528: LD_VAR 0 2
30532: PUSH
30533: LD_INT 2
30535: ARRAY
30536: PPUSH
30537: LD_INT 1
30539: PPUSH
30540: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30544: LD_STRING M5
30546: PPUSH
30547: CALL_OW 337
// omarOnMotherLode := false ;
30551: LD_ADDR_VAR 0 4
30555: PUSH
30556: LD_INT 0
30558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30559: LD_INT 35
30561: PPUSH
30562: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30566: LD_EXP 92
30570: PPUSH
30571: LD_INT 215
30573: PPUSH
30574: LD_INT 100
30576: PPUSH
30577: CALL_OW 297
30581: PUSH
30582: LD_INT 10
30584: LESS
30585: PUSH
30586: LD_VAR 0 4
30590: NOT
30591: AND
30592: IFFALSE 30626
// begin omarOnMotherLode := true ;
30594: LD_ADDR_VAR 0 4
30598: PUSH
30599: LD_INT 1
30601: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30602: LD_EXP 39
30606: PPUSH
30607: LD_STRING D19b-JMM-1
30609: PPUSH
30610: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30614: LD_EXP 92
30618: PPUSH
30619: LD_STRING DOmarContam-Omar-1
30621: PPUSH
30622: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30626: LD_EXP 92
30630: PPUSH
30631: CALL_OW 301
30635: IFFALSE 30559
// Say ( JMM , D19a-JMM-1 ) ;
30637: LD_EXP 39
30641: PPUSH
30642: LD_STRING D19a-JMM-1
30644: PPUSH
30645: CALL_OW 88
// if Heike then
30649: LD_EXP 93
30653: IFFALSE 30667
// Say ( Heike , D19a-Hke-1 ) ;
30655: LD_EXP 93
30659: PPUSH
30660: LD_STRING D19a-Hke-1
30662: PPUSH
30663: CALL_OW 88
// end ;
30667: PPOPN 4
30669: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30670: LD_INT 22
30672: PUSH
30673: LD_INT 3
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 21
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PPUSH
30694: CALL_OW 69
30698: PUSH
30699: LD_EXP 21
30703: AND
30704: IFFALSE 30772
30706: GO 30708
30708: DISABLE
30709: LD_INT 0
30711: PPUSH
30712: PPUSH
// begin enable ;
30713: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: LD_INT 25
30721: PPUSH
30722: LD_INT 22
30724: PUSH
30725: LD_INT 3
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PPUSH
30732: CALL_OW 70
30736: ST_TO_ADDR
// if not tmp then
30737: LD_VAR 0 2
30741: NOT
30742: IFFALSE 30746
// exit ;
30744: GO 30772
// for i in tmp do
30746: LD_ADDR_VAR 0 1
30750: PUSH
30751: LD_VAR 0 2
30755: PUSH
30756: FOR_IN
30757: IFFALSE 30770
// RemoveUnit ( i ) ;
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 64
30768: GO 30756
30770: POP
30771: POP
// end ;
30772: PPOPN 2
30774: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30775: LD_INT 22
30777: PUSH
30778: LD_INT 7
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 21
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PPUSH
30799: CALL_OW 69
30803: PUSH
30804: LD_INT 6
30806: LESS
30807: IFFALSE 31275
30809: GO 30811
30811: DISABLE
30812: LD_INT 0
30814: PPUSH
30815: PPUSH
// begin MC_Kill ( 1 ) ;
30816: LD_INT 1
30818: PPUSH
30819: CALL 35501 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30823: LD_INT 7
30825: PPUSH
30826: LD_INT 1
30828: PPUSH
30829: LD_INT 1
30831: PPUSH
30832: LD_INT 1
30834: PPUSH
30835: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30839: LD_ADDR_VAR 0 1
30843: PUSH
30844: LD_INT 22
30846: PUSH
30847: LD_INT 7
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 26
30856: PUSH
30857: LD_INT 1
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PPUSH
30868: CALL_OW 69
30872: PUSH
30873: LD_EXP 74
30877: DIFF
30878: ST_TO_ADDR
// if tmp then
30879: LD_VAR 0 1
30883: IFFALSE 30901
// tmp := tmp [ 1 ] else
30885: LD_ADDR_VAR 0 1
30889: PUSH
30890: LD_VAR 0 1
30894: PUSH
30895: LD_INT 1
30897: ARRAY
30898: ST_TO_ADDR
30899: GO 30937
// begin uc_side := 7 ;
30901: LD_ADDR_OWVAR 20
30905: PUSH
30906: LD_INT 7
30908: ST_TO_ADDR
// uc_nation := 1 ;
30909: LD_ADDR_OWVAR 21
30913: PUSH
30914: LD_INT 1
30916: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30917: LD_INT 1
30919: PPUSH
30920: LD_INT 8
30922: PPUSH
30923: CALL_OW 384
// tmp := CreateHuman ;
30927: LD_ADDR_VAR 0 1
30931: PUSH
30932: CALL_OW 44
30936: ST_TO_ADDR
// end ; DialogueOn ;
30937: CALL_OW 6
// if IsOK ( Roth ) then
30941: LD_EXP 74
30945: PPUSH
30946: CALL_OW 302
30950: IFFALSE 30964
// Say ( JMM , DAb-JMM-1 ) ;
30952: LD_EXP 39
30956: PPUSH
30957: LD_STRING DAb-JMM-1
30959: PPUSH
30960: CALL_OW 88
// if IsOK ( Roth ) then
30964: LD_EXP 74
30968: PPUSH
30969: CALL_OW 302
30973: IFFALSE 30997
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30975: LD_EXP 74
30979: PPUSH
30980: LD_STRING DSurrenderAlliance-Roth-1
30982: PPUSH
30983: CALL_OW 88
// RothCaptured := true ;
30987: LD_ADDR_EXP 33
30991: PUSH
30992: LD_INT 1
30994: ST_TO_ADDR
// end else
30995: GO 31009
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30997: LD_VAR 0 1
31001: PPUSH
31002: LD_STRING DSurrenderAlliance-Sci1-1
31004: PPUSH
31005: CALL_OW 88
// DialogueOff ;
31009: CALL_OW 7
// allianceDestroyed := true ;
31013: LD_ADDR_EXP 23
31017: PUSH
31018: LD_INT 1
31020: ST_TO_ADDR
// if capturedUnit = 0 then
31021: LD_EXP 34
31025: PUSH
31026: LD_INT 0
31028: EQUAL
31029: IFFALSE 31038
// SetAchievement ( ACH_ALLIANCE ) ;
31031: LD_STRING ACH_ALLIANCE
31033: PPUSH
31034: CALL_OW 543
// if trueAmericans then
31038: LD_EXP 35
31042: IFFALSE 31118
// begin if trueAmericans = 1 then
31044: LD_EXP 35
31048: PUSH
31049: LD_INT 1
31051: EQUAL
31052: IFFALSE 31068
// Say ( JMM , DAb-JMM-1a ) else
31054: LD_EXP 39
31058: PPUSH
31059: LD_STRING DAb-JMM-1a
31061: PPUSH
31062: CALL_OW 88
31066: GO 31080
// Say ( JMM , DAb-JMM-1b ) ;
31068: LD_EXP 39
31072: PPUSH
31073: LD_STRING DAb-JMM-1b
31075: PPUSH
31076: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31080: LD_EXP 35
31084: PPUSH
31085: CALL_OW 87
// for i in trueAmericans do
31089: LD_ADDR_VAR 0 2
31093: PUSH
31094: LD_EXP 35
31098: PUSH
31099: FOR_IN
31100: IFFALSE 31116
// SetSide ( i , 1 ) ;
31102: LD_VAR 0 2
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: CALL_OW 235
31114: GO 31099
31116: POP
31117: POP
// end ; repeat wait ( 0 0$1 ) ;
31118: LD_INT 35
31120: PPUSH
31121: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31125: LD_ADDR_VAR 0 2
31129: PUSH
31130: LD_INT 22
31132: PUSH
31133: LD_INT 7
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 21
31142: PUSH
31143: LD_INT 1
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PPUSH
31154: CALL_OW 69
31158: PUSH
31159: FOR_IN
31160: IFFALSE 31242
// begin if IsInUnit ( i ) then
31162: LD_VAR 0 2
31166: PPUSH
31167: CALL_OW 310
31171: IFFALSE 31182
// ComExitBuilding ( i ) ;
31173: LD_VAR 0 2
31177: PPUSH
31178: CALL_OW 122
// if IsDriver ( i ) then
31182: LD_VAR 0 2
31186: PPUSH
31187: CALL 100228 0 1
31191: IFFALSE 31202
// ComExitVehicle ( i ) ;
31193: LD_VAR 0 2
31197: PPUSH
31198: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31202: LD_VAR 0 2
31206: PPUSH
31207: LD_INT 26
31209: PPUSH
31210: CALL_OW 308
31214: NOT
31215: IFFALSE 31231
// AddComMoveToArea ( i , allianceEscapeArea ) else
31217: LD_VAR 0 2
31221: PPUSH
31222: LD_INT 26
31224: PPUSH
31225: CALL_OW 173
31229: GO 31240
// RemoveUnit ( i ) ;
31231: LD_VAR 0 2
31235: PPUSH
31236: CALL_OW 64
// end ;
31240: GO 31159
31242: POP
31243: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31244: LD_INT 22
31246: PUSH
31247: LD_INT 7
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 21
31256: PUSH
31257: LD_INT 1
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PPUSH
31268: CALL_OW 69
31272: NOT
31273: IFFALSE 31118
// end ;
31275: PPOPN 2
31277: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
// if not unit then
31282: LD_VAR 0 1
31286: NOT
31287: IFFALSE 31291
// exit ;
31289: GO 32789
// DoNotAttack ( 7 , unit ) ;
31291: LD_INT 7
31293: PPUSH
31294: LD_VAR 0 1
31298: PPUSH
31299: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31303: LD_VAR 0 1
31307: PPUSH
31308: LD_INT 260
31310: PPUSH
31311: LD_INT 235
31313: PPUSH
31314: LD_INT 3
31316: PPUSH
31317: LD_INT 1
31319: PPUSH
31320: CALL_OW 483
// SetSide ( unit , 4 ) ;
31324: LD_VAR 0 1
31328: PPUSH
31329: LD_INT 4
31331: PPUSH
31332: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31336: LD_ADDR_EXP 34
31340: PUSH
31341: LD_EXP 34
31345: PUSH
31346: LD_INT 1
31348: PLUS
31349: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31350: LD_INT 70
31352: PPUSH
31353: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31357: LD_INT 260
31359: PPUSH
31360: LD_INT 235
31362: PPUSH
31363: LD_INT 1
31365: PPUSH
31366: LD_INT 8
31368: NEG
31369: PPUSH
31370: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31374: LD_VAR 0 1
31378: PPUSH
31379: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31383: LD_VAR 0 1
31387: PPUSH
31388: LD_EXP 74
31392: PPUSH
31393: CALL_OW 119
// DialogueOn ;
31397: CALL_OW 6
// case unit of JMM :
31401: LD_VAR 0 1
31405: PUSH
31406: LD_EXP 39
31410: DOUBLE
31411: EQUAL
31412: IFTRUE 31416
31414: GO 31431
31416: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31417: LD_EXP 39
31421: PPUSH
31422: LD_STRING DA1-JMM-1
31424: PPUSH
31425: CALL_OW 91
31429: GO 31873
31431: LD_EXP 40
31435: DOUBLE
31436: EQUAL
31437: IFTRUE 31441
31439: GO 31456
31441: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31442: LD_EXP 40
31446: PPUSH
31447: LD_STRING DA1-Joan-1
31449: PPUSH
31450: CALL_OW 91
31454: GO 31873
31456: LD_EXP 42
31460: DOUBLE
31461: EQUAL
31462: IFTRUE 31466
31464: GO 31481
31466: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31467: LD_EXP 42
31471: PPUSH
31472: LD_STRING DA1-Lisa-1
31474: PPUSH
31475: CALL_OW 91
31479: GO 31873
31481: LD_EXP 43
31485: DOUBLE
31486: EQUAL
31487: IFTRUE 31491
31489: GO 31506
31491: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31492: LD_EXP 43
31496: PPUSH
31497: LD_STRING DA1-Don-1
31499: PPUSH
31500: CALL_OW 91
31504: GO 31873
31506: LD_EXP 50
31510: DOUBLE
31511: EQUAL
31512: IFTRUE 31516
31514: GO 31531
31516: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31517: LD_EXP 50
31521: PPUSH
31522: LD_STRING DA1-Corn-1
31524: PPUSH
31525: CALL_OW 91
31529: GO 31873
31531: LD_EXP 46
31535: DOUBLE
31536: EQUAL
31537: IFTRUE 31541
31539: GO 31556
31541: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31542: LD_EXP 46
31546: PPUSH
31547: LD_STRING DA1-Den-1
31549: PPUSH
31550: CALL_OW 91
31554: GO 31873
31556: LD_EXP 44
31560: DOUBLE
31561: EQUAL
31562: IFTRUE 31566
31564: GO 31581
31566: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31567: LD_EXP 44
31571: PPUSH
31572: LD_STRING DA1-Bobby-1
31574: PPUSH
31575: CALL_OW 91
31579: GO 31873
31581: LD_EXP 48
31585: DOUBLE
31586: EQUAL
31587: IFTRUE 31591
31589: GO 31606
31591: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31592: LD_EXP 48
31596: PPUSH
31597: LD_STRING DA1-Glad-1
31599: PPUSH
31600: CALL_OW 91
31604: GO 31873
31606: LD_EXP 45
31610: DOUBLE
31611: EQUAL
31612: IFTRUE 31616
31614: GO 31631
31616: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31617: LD_EXP 45
31621: PPUSH
31622: LD_STRING DA1-Cyrus-1
31624: PPUSH
31625: CALL_OW 91
31629: GO 31873
31631: LD_EXP 41
31635: DOUBLE
31636: EQUAL
31637: IFTRUE 31641
31639: GO 31656
31641: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31642: LD_EXP 41
31646: PPUSH
31647: LD_STRING DA1-Huck-1
31649: PPUSH
31650: CALL_OW 91
31654: GO 31873
31656: LD_EXP 55
31660: DOUBLE
31661: EQUAL
31662: IFTRUE 31666
31664: GO 31681
31666: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31667: LD_EXP 55
31671: PPUSH
31672: LD_STRING DA1-Huck-1
31674: PPUSH
31675: CALL_OW 91
31679: GO 31873
31681: LD_EXP 47
31685: DOUBLE
31686: EQUAL
31687: IFTRUE 31691
31689: GO 31706
31691: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31692: LD_EXP 47
31696: PPUSH
31697: LD_STRING DA1-Brown-1
31699: PPUSH
31700: CALL_OW 91
31704: GO 31873
31706: LD_EXP 51
31710: DOUBLE
31711: EQUAL
31712: IFTRUE 31716
31714: GO 31731
31716: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31717: LD_EXP 51
31721: PPUSH
31722: LD_STRING DA1-Gary-1
31724: PPUSH
31725: CALL_OW 91
31729: GO 31873
31731: LD_EXP 54
31735: DOUBLE
31736: EQUAL
31737: IFTRUE 31741
31739: GO 31756
31741: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31742: LD_EXP 54
31746: PPUSH
31747: LD_STRING DA1-Con-1
31749: PPUSH
31750: CALL_OW 91
31754: GO 31873
31756: LD_EXP 60
31760: DOUBLE
31761: EQUAL
31762: IFTRUE 31766
31764: GO 31781
31766: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31767: LD_EXP 60
31771: PPUSH
31772: LD_STRING DA1-Kurt-1
31774: PPUSH
31775: CALL_OW 91
31779: GO 31873
31781: LD_EXP 53
31785: DOUBLE
31786: EQUAL
31787: IFTRUE 31791
31789: GO 31806
31791: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31792: LD_EXP 53
31796: PPUSH
31797: LD_STRING DA1-Yam-1
31799: PPUSH
31800: CALL_OW 91
31804: GO 31873
31806: LD_EXP 52
31810: DOUBLE
31811: EQUAL
31812: IFTRUE 31816
31814: GO 31831
31816: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31817: LD_EXP 52
31821: PPUSH
31822: LD_STRING DA1-Frank-1
31824: PPUSH
31825: CALL_OW 91
31829: GO 31873
31831: POP
// begin if GetSex ( unit ) = sex_male then
31832: LD_VAR 0 1
31836: PPUSH
31837: CALL_OW 258
31841: PUSH
31842: LD_INT 1
31844: EQUAL
31845: IFFALSE 31861
// ForceSay ( unit , DA1-Sol1-1 ) else
31847: LD_VAR 0 1
31851: PPUSH
31852: LD_STRING DA1-Sol1-1
31854: PPUSH
31855: CALL_OW 91
31859: GO 31873
// ForceSay ( unit , DA1-FSol1-1 ) ;
31861: LD_VAR 0 1
31865: PPUSH
31866: LD_STRING DA1-FSol1-1
31868: PPUSH
31869: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31873: LD_EXP 74
31877: PPUSH
31878: LD_STRING DA-Roth-1
31880: PPUSH
31881: CALL_OW 88
// if capturedUnit = 1 then
31885: LD_EXP 34
31889: PUSH
31890: LD_INT 1
31892: EQUAL
31893: IFFALSE 31921
// begin Say ( Simms , DA-Sim-1 ) ;
31895: LD_EXP 75
31899: PPUSH
31900: LD_STRING DA-Sim-1
31902: PPUSH
31903: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31907: LD_EXP 74
31911: PPUSH
31912: LD_STRING DA-Roth-2
31914: PPUSH
31915: CALL_OW 88
// end else
31919: GO 31933
// Say ( Simms , DA-Sim-2 ) ;
31921: LD_EXP 75
31925: PPUSH
31926: LD_STRING DA-Sim-2
31928: PPUSH
31929: CALL_OW 88
// case unit of JMM :
31933: LD_VAR 0 1
31937: PUSH
31938: LD_EXP 39
31942: DOUBLE
31943: EQUAL
31944: IFTRUE 31948
31946: GO 31963
31948: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31949: LD_EXP 39
31953: PPUSH
31954: LD_STRING DA1-JMM-1a
31956: PPUSH
31957: CALL_OW 91
31961: GO 32470
31963: LD_EXP 40
31967: DOUBLE
31968: EQUAL
31969: IFTRUE 31973
31971: GO 31988
31973: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31974: LD_EXP 40
31978: PPUSH
31979: LD_STRING DA1-Joan-1a
31981: PPUSH
31982: CALL_OW 91
31986: GO 32470
31988: LD_EXP 42
31992: DOUBLE
31993: EQUAL
31994: IFTRUE 31998
31996: GO 32013
31998: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31999: LD_EXP 42
32003: PPUSH
32004: LD_STRING DA1-Lisa-1a
32006: PPUSH
32007: CALL_OW 91
32011: GO 32470
32013: LD_EXP 43
32017: DOUBLE
32018: EQUAL
32019: IFTRUE 32023
32021: GO 32038
32023: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32024: LD_EXP 43
32028: PPUSH
32029: LD_STRING DA1-Don-1a
32031: PPUSH
32032: CALL_OW 91
32036: GO 32470
32038: LD_EXP 50
32042: DOUBLE
32043: EQUAL
32044: IFTRUE 32048
32046: GO 32063
32048: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32049: LD_EXP 50
32053: PPUSH
32054: LD_STRING DA1-Corn-1a
32056: PPUSH
32057: CALL_OW 91
32061: GO 32470
32063: LD_EXP 46
32067: DOUBLE
32068: EQUAL
32069: IFTRUE 32073
32071: GO 32088
32073: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32074: LD_EXP 46
32078: PPUSH
32079: LD_STRING DA1-Den-1a
32081: PPUSH
32082: CALL_OW 91
32086: GO 32470
32088: LD_EXP 44
32092: DOUBLE
32093: EQUAL
32094: IFTRUE 32098
32096: GO 32113
32098: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32099: LD_EXP 44
32103: PPUSH
32104: LD_STRING DA1-Bobby-1a
32106: PPUSH
32107: CALL_OW 91
32111: GO 32470
32113: LD_EXP 48
32117: DOUBLE
32118: EQUAL
32119: IFTRUE 32123
32121: GO 32138
32123: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32124: LD_EXP 48
32128: PPUSH
32129: LD_STRING DA1-Glad-1a
32131: PPUSH
32132: CALL_OW 91
32136: GO 32470
32138: LD_EXP 45
32142: DOUBLE
32143: EQUAL
32144: IFTRUE 32148
32146: GO 32163
32148: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32149: LD_EXP 45
32153: PPUSH
32154: LD_STRING DA1-Cyrus-1a
32156: PPUSH
32157: CALL_OW 91
32161: GO 32470
32163: LD_EXP 41
32167: DOUBLE
32168: EQUAL
32169: IFTRUE 32173
32171: GO 32188
32173: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32174: LD_EXP 41
32178: PPUSH
32179: LD_STRING DA1-Huck-1a
32181: PPUSH
32182: CALL_OW 91
32186: GO 32470
32188: LD_EXP 55
32192: DOUBLE
32193: EQUAL
32194: IFTRUE 32198
32196: GO 32213
32198: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32199: LD_EXP 55
32203: PPUSH
32204: LD_STRING DA1-Huck-1a
32206: PPUSH
32207: CALL_OW 91
32211: GO 32470
32213: LD_EXP 47
32217: DOUBLE
32218: EQUAL
32219: IFTRUE 32223
32221: GO 32238
32223: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32224: LD_EXP 47
32228: PPUSH
32229: LD_STRING DA1-Brown-1a
32231: PPUSH
32232: CALL_OW 91
32236: GO 32470
32238: LD_EXP 51
32242: DOUBLE
32243: EQUAL
32244: IFTRUE 32248
32246: GO 32263
32248: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32249: LD_EXP 51
32253: PPUSH
32254: LD_STRING DA1-Gary-1a
32256: PPUSH
32257: CALL_OW 91
32261: GO 32470
32263: LD_EXP 54
32267: DOUBLE
32268: EQUAL
32269: IFTRUE 32273
32271: GO 32288
32273: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32274: LD_EXP 54
32278: PPUSH
32279: LD_STRING DA1-Con-1a
32281: PPUSH
32282: CALL_OW 91
32286: GO 32470
32288: LD_EXP 60
32292: DOUBLE
32293: EQUAL
32294: IFTRUE 32298
32296: GO 32313
32298: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32299: LD_EXP 60
32303: PPUSH
32304: LD_STRING DA1-Kurt-1a
32306: PPUSH
32307: CALL_OW 91
32311: GO 32470
32313: LD_EXP 53
32317: DOUBLE
32318: EQUAL
32319: IFTRUE 32323
32321: GO 32338
32323: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32324: LD_EXP 53
32328: PPUSH
32329: LD_STRING DA1-Yam-1a
32331: PPUSH
32332: CALL_OW 91
32336: GO 32470
32338: LD_EXP 52
32342: DOUBLE
32343: EQUAL
32344: IFTRUE 32348
32346: GO 32363
32348: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32349: LD_EXP 52
32353: PPUSH
32354: LD_STRING DA1-Frank-1a
32356: PPUSH
32357: CALL_OW 91
32361: GO 32470
32363: POP
// begin join := rand ( 0 , 1 ) ;
32364: LD_ADDR_VAR 0 3
32368: PUSH
32369: LD_INT 0
32371: PPUSH
32372: LD_INT 1
32374: PPUSH
32375: CALL_OW 12
32379: ST_TO_ADDR
// if join then
32380: LD_VAR 0 3
32384: IFFALSE 32429
// begin if GetSex ( unit ) = sex_male then
32386: LD_VAR 0 1
32390: PPUSH
32391: CALL_OW 258
32395: PUSH
32396: LD_INT 1
32398: EQUAL
32399: IFFALSE 32415
// ForceSay ( unit , DA1-Sol1-1b ) else
32401: LD_VAR 0 1
32405: PPUSH
32406: LD_STRING DA1-Sol1-1b
32408: PPUSH
32409: CALL_OW 91
32413: GO 32427
// ForceSay ( unit , DA1-FSol1-1b ) ;
32415: LD_VAR 0 1
32419: PPUSH
32420: LD_STRING DA1-FSol1-1b
32422: PPUSH
32423: CALL_OW 91
// end else
32427: GO 32470
// begin if GetSex ( unit ) = sex_male then
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 258
32438: PUSH
32439: LD_INT 1
32441: EQUAL
32442: IFFALSE 32458
// ForceSay ( unit , DA1-Sol1-1a ) else
32444: LD_VAR 0 1
32448: PPUSH
32449: LD_STRING DA1-Sol1-1a
32451: PPUSH
32452: CALL_OW 91
32456: GO 32470
// ForceSay ( unit , DA1-FSol1-1a ) ;
32458: LD_VAR 0 1
32462: PPUSH
32463: LD_STRING DA1-FSol1-1a
32465: PPUSH
32466: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32470: LD_VAR 0 1
32474: PUSH
32475: LD_EXP 39
32479: EQUAL
32480: IFFALSE 32491
// begin YouLost ( JMMCaptured ) ;
32482: LD_STRING JMMCaptured
32484: PPUSH
32485: CALL_OW 104
// exit ;
32489: GO 32789
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32491: LD_VAR 0 1
32495: PUSH
32496: LD_EXP 43
32500: PUSH
32501: LD_EXP 46
32505: PUSH
32506: LD_EXP 44
32510: PUSH
32511: LD_EXP 41
32515: PUSH
32516: LD_EXP 55
32520: PUSH
32521: LD_EXP 47
32525: PUSH
32526: LD_EXP 53
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: IN
32540: PUSH
32541: LD_VAR 0 3
32545: OR
32546: IFFALSE 32645
// begin Say ( Roth , DA-Roth-3 ) ;
32548: LD_EXP 74
32552: PPUSH
32553: LD_STRING DA-Roth-3
32555: PPUSH
32556: CALL_OW 88
// SetSide ( unit , 7 ) ;
32560: LD_VAR 0 1
32564: PPUSH
32565: LD_INT 7
32567: PPUSH
32568: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32572: LD_ADDR_EXP 116
32576: PUSH
32577: LD_EXP 116
32581: PPUSH
32582: LD_INT 1
32584: PPUSH
32585: LD_EXP 116
32589: PUSH
32590: LD_INT 1
32592: ARRAY
32593: PUSH
32594: LD_VAR 0 1
32598: ADD
32599: PPUSH
32600: CALL_OW 1
32604: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32605: LD_INT 260
32607: PPUSH
32608: LD_INT 235
32610: PPUSH
32611: LD_INT 1
32613: PPUSH
32614: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32618: LD_VAR 0 1
32622: PPUSH
32623: LD_INT 1000
32625: PPUSH
32626: CALL_OW 234
// DialogueOff ;
32630: CALL_OW 7
// ComFree ( unit ) ;
32634: LD_VAR 0 1
32638: PPUSH
32639: CALL_OW 139
// end else
32643: GO 32726
// begin Say ( Roth , DA-Roth-3a ) ;
32645: LD_EXP 74
32649: PPUSH
32650: LD_STRING DA-Roth-3a
32652: PPUSH
32653: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32657: LD_ADDR_EXP 35
32661: PUSH
32662: LD_EXP 35
32666: PUSH
32667: LD_VAR 0 1
32671: ADD
32672: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32673: LD_INT 260
32675: PPUSH
32676: LD_INT 235
32678: PPUSH
32679: LD_INT 1
32681: PPUSH
32682: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32686: LD_VAR 0 1
32690: PPUSH
32691: LD_INT 1000
32693: PPUSH
32694: CALL_OW 234
// DialogueOff ;
32698: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32702: LD_VAR 0 1
32706: PPUSH
32707: LD_INT 272
32709: PPUSH
32710: LD_INT 254
32712: PPUSH
32713: CALL_OW 111
// AddComHold ( unit ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 200
// end ; if capturedUnit = 1 then
32726: LD_EXP 34
32730: PUSH
32731: LD_INT 1
32733: EQUAL
32734: IFFALSE 32789
// begin DialogueOn ;
32736: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32740: LD_EXP 39
32744: PPUSH
32745: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32749: LD_EXP 39
32753: PPUSH
32754: LD_STRING DAa-JMM-1
32756: PPUSH
32757: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32761: LD_EXP 39
32765: PPUSH
32766: LD_STRING DAa-JMM-1a
32768: PPUSH
32769: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32773: LD_EXP 39
32777: PPUSH
32778: LD_STRING DAa-JMM-1b
32780: PPUSH
32781: CALL_OW 88
// DialogueOff ;
32785: CALL_OW 7
// end ; end ;
32789: LD_VAR 0 2
32793: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32794: LD_EXP 15
32798: PUSH
32799: LD_INT 13
32801: GREATEREQUAL
32802: PUSH
32803: LD_INT 22
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 21
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PPUSH
32827: CALL_OW 69
32831: PUSH
32832: LD_INT 0
32834: EQUAL
32835: AND
32836: PUSH
32837: LD_INT 22
32839: PUSH
32840: LD_INT 2
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 33
32849: PUSH
32850: LD_INT 5
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 21
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 50
32869: PUSH
32870: EMPTY
32871: LIST
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: PPUSH
32879: CALL_OW 69
32883: PUSH
32884: LD_INT 0
32886: EQUAL
32887: AND
32888: PUSH
32889: LD_EXP 21
32893: AND
32894: PUSH
32895: LD_EXP 22
32899: AND
32900: PUSH
32901: LD_EXP 23
32905: AND
32906: IFFALSE 33555
32908: GO 32910
32910: DISABLE
32911: LD_INT 0
32913: PPUSH
32914: PPUSH
32915: PPUSH
// begin m1 := false ;
32916: LD_ADDR_VAR 0 1
32920: PUSH
32921: LD_INT 0
32923: ST_TO_ADDR
// m2 := false ;
32924: LD_ADDR_VAR 0 2
32928: PUSH
32929: LD_INT 0
32931: ST_TO_ADDR
// m3 := false ;
32932: LD_ADDR_VAR 0 3
32936: PUSH
32937: LD_INT 0
32939: ST_TO_ADDR
// if not bombExploded then
32940: LD_EXP 37
32944: NOT
32945: IFFALSE 32954
// SetAchievement ( ACH_SIBROCKET ) ;
32947: LD_STRING ACH_SIBROCKET
32949: PPUSH
32950: CALL_OW 543
// if tick <= 120 120$00 then
32954: LD_OWVAR 1
32958: PUSH
32959: LD_INT 252000
32961: LESSEQUAL
32962: IFFALSE 32978
// begin wait ( 3 ) ;
32964: LD_INT 3
32966: PPUSH
32967: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32971: LD_STRING ACH_ASPEED_15
32973: PPUSH
32974: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32978: LD_EXP 39
32982: PPUSH
32983: CALL_OW 87
// music_class := 5 ;
32987: LD_ADDR_OWVAR 72
32991: PUSH
32992: LD_INT 5
32994: ST_TO_ADDR
// music_nat := 5 ;
32995: LD_ADDR_OWVAR 71
32999: PUSH
33000: LD_INT 5
33002: ST_TO_ADDR
// DialogueOn ;
33003: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33007: LD_EXP 39
33011: PPUSH
33012: LD_STRING D20-JMM-1
33014: PPUSH
33015: CALL_OW 88
// if IsOK ( Joan ) then
33019: LD_EXP 40
33023: PPUSH
33024: CALL_OW 302
33028: IFFALSE 33042
// Say ( Joan , D20-Joan-1 ) ;
33030: LD_EXP 40
33034: PPUSH
33035: LD_STRING D20-Joan-1
33037: PPUSH
33038: CALL_OW 88
// if IsOk ( Lisa ) then
33042: LD_EXP 42
33046: PPUSH
33047: CALL_OW 302
33051: IFFALSE 33065
// Say ( Lisa , D20-Lisa-1 ) ;
33053: LD_EXP 42
33057: PPUSH
33058: LD_STRING D20-Lisa-1
33060: PPUSH
33061: CALL_OW 88
// if IsOk ( Donaldson ) then
33065: LD_EXP 43
33069: PPUSH
33070: CALL_OW 302
33074: IFFALSE 33088
// Say ( Donaldson , D20-Don-1 ) ;
33076: LD_EXP 43
33080: PPUSH
33081: LD_STRING D20-Don-1
33083: PPUSH
33084: CALL_OW 88
// if IsOK ( Cornel ) then
33088: LD_EXP 50
33092: PPUSH
33093: CALL_OW 302
33097: IFFALSE 33111
// Say ( Cornel , D20-Corn-1 ) ;
33099: LD_EXP 50
33103: PPUSH
33104: LD_STRING D20-Corn-1
33106: PPUSH
33107: CALL_OW 88
// if IsOk ( Denis ) then
33111: LD_EXP 46
33115: PPUSH
33116: CALL_OW 302
33120: IFFALSE 33134
// Say ( Denis , D20-Den-1 ) ;
33122: LD_EXP 46
33126: PPUSH
33127: LD_STRING D20-Den-1
33129: PPUSH
33130: CALL_OW 88
// if IsOk ( Bobby ) then
33134: LD_EXP 44
33138: PPUSH
33139: CALL_OW 302
33143: IFFALSE 33157
// Say ( Bobby , D20-Bobby-1 ) ;
33145: LD_EXP 44
33149: PPUSH
33150: LD_STRING D20-Bobby-1
33152: PPUSH
33153: CALL_OW 88
// if IsOk ( Gladstone ) then
33157: LD_EXP 48
33161: PPUSH
33162: CALL_OW 302
33166: IFFALSE 33180
// Say ( Gladstone , D20-Glad-1 ) ;
33168: LD_EXP 48
33172: PPUSH
33173: LD_STRING D20-Glad-1
33175: PPUSH
33176: CALL_OW 88
// if IsOk ( Cyrus ) then
33180: LD_EXP 45
33184: PPUSH
33185: CALL_OW 302
33189: IFFALSE 33203
// Say ( Cyrus , D20-Cyrus-1 ) ;
33191: LD_EXP 45
33195: PPUSH
33196: LD_STRING D20-Cyrus-1
33198: PPUSH
33199: CALL_OW 88
// if IsOk ( Stevens ) then
33203: LD_EXP 41
33207: PPUSH
33208: CALL_OW 302
33212: IFFALSE 33226
// Say ( Stevens , D20-Huck-1 ) ;
33214: LD_EXP 41
33218: PPUSH
33219: LD_STRING D20-Huck-1
33221: PPUSH
33222: CALL_OW 88
// if IsOk ( Brown ) then
33226: LD_EXP 47
33230: PPUSH
33231: CALL_OW 302
33235: IFFALSE 33249
// Say ( Brown , D20-Brown-1 ) ;
33237: LD_EXP 47
33241: PPUSH
33242: LD_STRING D20-Brown-1
33244: PPUSH
33245: CALL_OW 88
// if IsOk ( Gary ) then
33249: LD_EXP 51
33253: PPUSH
33254: CALL_OW 302
33258: IFFALSE 33272
// Say ( Gary , D20-Gary-1 ) ;
33260: LD_EXP 51
33264: PPUSH
33265: LD_STRING D20-Gary-1
33267: PPUSH
33268: CALL_OW 88
// if IsOk ( Connie ) then
33272: LD_EXP 54
33276: PPUSH
33277: CALL_OW 302
33281: IFFALSE 33295
// Say ( Connie , D20-Con-1 ) ;
33283: LD_EXP 54
33287: PPUSH
33288: LD_STRING D20-Con-1
33290: PPUSH
33291: CALL_OW 88
// if IsOk ( Kurt ) then
33295: LD_EXP 60
33299: PPUSH
33300: CALL_OW 302
33304: IFFALSE 33318
// Say ( Kurt , D20-Kurt-1 ) ;
33306: LD_EXP 60
33310: PPUSH
33311: LD_STRING D20-Kurt-1
33313: PPUSH
33314: CALL_OW 88
// if IsOk ( Kikuchi ) then
33318: LD_EXP 53
33322: PPUSH
33323: CALL_OW 302
33327: IFFALSE 33341
// Say ( Kikuchi , D20-Yam-1 ) ;
33329: LD_EXP 53
33333: PPUSH
33334: LD_STRING D20-Yam-1
33336: PPUSH
33337: CALL_OW 88
// if IsOk ( Frank ) then
33341: LD_EXP 52
33345: PPUSH
33346: CALL_OW 302
33350: IFFALSE 33364
// Say ( Frank , D20-Frank-1 ) ;
33352: LD_EXP 52
33356: PPUSH
33357: LD_STRING D20-Frank-1
33359: PPUSH
33360: CALL_OW 88
// DialogueOff ;
33364: CALL_OW 7
// if RothCaptured then
33368: LD_EXP 33
33372: IFFALSE 33394
// begin m1 := true ;
33374: LD_ADDR_VAR 0 1
33378: PUSH
33379: LD_INT 1
33381: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33382: LD_STRING Roth
33384: PPUSH
33385: LD_INT 1
33387: PPUSH
33388: CALL_OW 101
// end else
33392: GO 33405
// AddMedal ( Roth , - 1 ) ;
33394: LD_STRING Roth
33396: PPUSH
33397: LD_INT 1
33399: NEG
33400: PPUSH
33401: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33405: LD_EXP 25
33409: NOT
33410: PUSH
33411: LD_EXP 27
33415: OR
33416: IFFALSE 33438
// begin m2 := true ;
33418: LD_ADDR_VAR 0 2
33422: PUSH
33423: LD_INT 1
33425: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33426: LD_STRING Project
33428: PPUSH
33429: LD_INT 1
33431: PPUSH
33432: CALL_OW 101
// end else
33436: GO 33449
// AddMedal ( Project , - 1 ) ;
33438: LD_STRING Project
33440: PPUSH
33441: LD_INT 1
33443: NEG
33444: PPUSH
33445: CALL_OW 101
// if lostCounter = 0 then
33449: LD_EXP 32
33453: PUSH
33454: LD_INT 0
33456: EQUAL
33457: IFFALSE 33479
// begin m3 := true ;
33459: LD_ADDR_VAR 0 3
33463: PUSH
33464: LD_INT 1
33466: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33467: LD_STRING NoLosses
33469: PPUSH
33470: LD_INT 1
33472: PPUSH
33473: CALL_OW 101
// end else
33477: GO 33490
// AddMedal ( NoLosses , - 1 ) ;
33479: LD_STRING NoLosses
33481: PPUSH
33482: LD_INT 1
33484: NEG
33485: PPUSH
33486: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33490: LD_VAR 0 1
33494: PUSH
33495: LD_VAR 0 2
33499: AND
33500: PUSH
33501: LD_VAR 0 3
33505: AND
33506: PUSH
33507: LD_OWVAR 67
33511: PUSH
33512: LD_INT 3
33514: GREATEREQUAL
33515: AND
33516: IFFALSE 33528
// SetAchievementEX ( ACH_AMER , 15 ) ;
33518: LD_STRING ACH_AMER
33520: PPUSH
33521: LD_INT 15
33523: PPUSH
33524: CALL_OW 564
// GiveMedals ( MAIN ) ;
33528: LD_STRING MAIN
33530: PPUSH
33531: CALL_OW 102
// music_class := 4 ;
33535: LD_ADDR_OWVAR 72
33539: PUSH
33540: LD_INT 4
33542: ST_TO_ADDR
// music_nat := 1 ;
33543: LD_ADDR_OWVAR 71
33547: PUSH
33548: LD_INT 1
33550: ST_TO_ADDR
// YouWin ;
33551: CALL_OW 103
// end ; end_of_file
33555: PPOPN 3
33557: END
// export function CustomEvent ( event ) ; begin
33558: LD_INT 0
33560: PPUSH
// end ;
33561: LD_VAR 0 2
33565: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33566: LD_VAR 0 1
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: PUSH
33575: LD_VAR 0 2
33579: PUSH
33580: LD_INT 4
33582: EQUAL
33583: AND
33584: PUSH
33585: LD_EXP 58
33589: PPUSH
33590: CALL_OW 300
33594: AND
33595: IFFALSE 33611
// begin wait ( 0 0$2 ) ;
33597: LD_INT 70
33599: PPUSH
33600: CALL_OW 67
// YouLost ( Dismissed ) ;
33604: LD_STRING Dismissed
33606: PPUSH
33607: CALL_OW 104
// end ; end ;
33611: PPOPN 2
33613: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33614: LD_VAR 0 2
33618: PPUSH
33619: LD_VAR 0 3
33623: PPUSH
33624: LD_INT 18
33626: PPUSH
33627: CALL_OW 309
33631: IFFALSE 33640
// YouLost ( Motherlode3 ) ;
33633: LD_STRING Motherlode3
33635: PPUSH
33636: CALL_OW 104
// end ;
33640: PPOPN 3
33642: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33643: LD_EXP 27
33647: NOT
33648: IFFALSE 33658
// behemothDone := true ;
33650: LD_ADDR_EXP 28
33654: PUSH
33655: LD_INT 1
33657: ST_TO_ADDR
// end ;
33658: PPOPN 1
33660: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33661: LD_VAR 0 1
33665: PPUSH
33666: CALL_OW 255
33670: PUSH
33671: LD_INT 1
33673: EQUAL
33674: IFFALSE 33684
// bombExploded := true ;
33676: LD_ADDR_EXP 37
33680: PUSH
33681: LD_INT 1
33683: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33684: LD_VAR 0 1
33688: PPUSH
33689: CALL_OW 255
33693: PUSH
33694: LD_INT 1
33696: EQUAL
33697: PUSH
33698: LD_EXP 30
33702: AND
33703: PUSH
33704: LD_INT 22
33706: PUSH
33707: LD_INT 3
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 34
33716: PUSH
33717: LD_INT 48
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PPUSH
33728: CALL_OW 69
33732: AND
33733: PUSH
33734: LD_INT 22
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 34
33746: PUSH
33747: LD_INT 8
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PPUSH
33758: CALL_OW 69
33762: NOT
33763: AND
33764: IFFALSE 33816
// begin wait ( 0 0$5 ) ;
33766: LD_INT 175
33768: PPUSH
33769: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33773: LD_INT 22
33775: PUSH
33776: LD_INT 3
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 34
33785: PUSH
33786: LD_INT 48
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PPUSH
33797: CALL_OW 69
33801: PUSH
33802: LD_INT 1
33804: ARRAY
33805: PPUSH
33806: LD_INT 60
33808: PPUSH
33809: LD_INT 95
33811: PPUSH
33812: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33816: LD_VAR 0 2
33820: PPUSH
33821: LD_VAR 0 3
33825: PPUSH
33826: LD_INT 18
33828: PPUSH
33829: CALL_OW 309
33833: IFFALSE 33880
// begin if GetSide ( unit ) = 1 then
33835: LD_VAR 0 1
33839: PPUSH
33840: CALL_OW 255
33844: PUSH
33845: LD_INT 1
33847: EQUAL
33848: IFFALSE 33866
// begin wait ( 0 0$6 ) ;
33850: LD_INT 210
33852: PPUSH
33853: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33857: LD_STRING Motherlode2
33859: PPUSH
33860: CALL_OW 104
// end else
33864: GO 33880
// begin wait ( 0 0$6 ) ;
33866: LD_INT 210
33868: PPUSH
33869: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33873: LD_STRING Motherlode1
33875: PPUSH
33876: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33880: LD_VAR 0 1
33884: PPUSH
33885: CALL_OW 255
33889: PUSH
33890: LD_INT 3
33892: EQUAL
33893: IFFALSE 33914
// begin wait ( 0 0$5 ) ;
33895: LD_INT 175
33897: PPUSH
33898: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33902: LD_EXP 64
33906: PPUSH
33907: LD_STRING D18-Pla-1
33909: PPUSH
33910: CALL_OW 94
// end ; end ;
33914: PPOPN 3
33916: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33917: LD_VAR 0 1
33921: PUSH
33922: LD_INT 22
33924: PUSH
33925: LD_INT 1
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 21
33934: PUSH
33935: LD_INT 1
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 23
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: LIST
33956: PPUSH
33957: CALL_OW 69
33961: IN
33962: IFFALSE 33978
// lostCounter := lostCounter + 1 ;
33964: LD_ADDR_EXP 32
33968: PUSH
33969: LD_EXP 32
33973: PUSH
33974: LD_INT 1
33976: PLUS
33977: ST_TO_ADDR
// if un in behemothBuilders then
33978: LD_VAR 0 1
33982: PUSH
33983: LD_EXP 73
33987: IN
33988: IFFALSE 34008
// begin behemothBuilders := behemothBuilders diff un ;
33990: LD_ADDR_EXP 73
33994: PUSH
33995: LD_EXP 73
33999: PUSH
34000: LD_VAR 0 1
34004: DIFF
34005: ST_TO_ADDR
// exit ;
34006: GO 34038
// end ; if un = JMM then
34008: LD_VAR 0 1
34012: PUSH
34013: LD_EXP 39
34017: EQUAL
34018: IFFALSE 34029
// begin YouLost ( JMM ) ;
34020: LD_STRING JMM
34022: PPUSH
34023: CALL_OW 104
// exit ;
34027: GO 34038
// end ; MCE_UnitDestroyed ( un ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: CALL 62899 0 1
// end ;
34038: PPOPN 1
34040: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34041: LD_VAR 0 1
34045: PPUSH
34046: LD_VAR 0 2
34050: PPUSH
34051: CALL 65233 0 2
// end ;
34055: PPOPN 2
34057: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34058: LD_VAR 0 1
34062: PPUSH
34063: CALL 64301 0 1
// end ;
34067: PPOPN 1
34069: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34070: LD_VAR 0 1
34074: PUSH
34075: LD_INT 22
34077: PUSH
34078: LD_INT 8
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 30
34087: PUSH
34088: LD_INT 2
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 23
34097: PUSH
34098: LD_INT 3
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: LIST
34109: PPUSH
34110: CALL_OW 69
34114: IN
34115: IFFALSE 34142
// begin ComUpgrade ( building ) ;
34117: LD_VAR 0 1
34121: PPUSH
34122: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34126: LD_EXP 61
34130: PPUSH
34131: LD_VAR 0 1
34135: PPUSH
34136: CALL 73734 0 2
// exit ;
34140: GO 34151
// end ; MCE_BuildingComplete ( building ) ;
34142: LD_VAR 0 1
34146: PPUSH
34147: CALL 64542 0 1
// end ;
34151: PPOPN 1
34153: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34154: LD_VAR 0 1
34158: PPUSH
34159: LD_VAR 0 2
34163: PPUSH
34164: CALL 62595 0 2
// end ;
34168: PPOPN 2
34170: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34171: LD_VAR 0 1
34175: PPUSH
34176: LD_VAR 0 2
34180: PPUSH
34181: LD_VAR 0 3
34185: PPUSH
34186: LD_VAR 0 4
34190: PPUSH
34191: LD_VAR 0 5
34195: PPUSH
34196: CALL 62215 0 5
// end ;
34200: PPOPN 5
34202: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34203: LD_VAR 0 1
34207: PPUSH
34208: LD_VAR 0 2
34212: PPUSH
34213: CALL 61796 0 2
// end ;
34217: PPOPN 2
34219: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34220: LD_VAR 0 1
34224: PPUSH
34225: LD_VAR 0 2
34229: PPUSH
34230: LD_VAR 0 3
34234: PPUSH
34235: LD_VAR 0 4
34239: PPUSH
34240: CALL 61634 0 4
// end ;
34244: PPOPN 4
34246: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34247: LD_VAR 0 1
34251: PPUSH
34252: LD_VAR 0 2
34256: PPUSH
34257: LD_VAR 0 3
34261: PPUSH
34262: CALL 61409 0 3
// end ;
34266: PPOPN 3
34268: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34269: LD_VAR 0 1
34273: PPUSH
34274: LD_VAR 0 2
34278: PPUSH
34279: CALL 61294 0 2
// end ;
34283: PPOPN 2
34285: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34286: LD_VAR 0 1
34290: PPUSH
34291: LD_VAR 0 2
34295: PPUSH
34296: CALL 65528 0 2
// end ;
34300: PPOPN 2
34302: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34303: LD_VAR 0 1
34307: PPUSH
34308: CALL_OW 255
34312: PUSH
34313: LD_INT 4
34315: EQUAL
34316: PUSH
34317: LD_VAR 0 1
34321: PUSH
34322: LD_EXP 18
34326: PUSH
34327: LD_INT 1
34329: ARRAY
34330: IN
34331: AND
34332: PUSH
34333: LD_EXP 19
34337: AND
34338: IFFALSE 34357
// begin ComMoveXY ( driver , 61 , 93 ) ;
34340: LD_VAR 0 1
34344: PPUSH
34345: LD_INT 61
34347: PPUSH
34348: LD_INT 93
34350: PPUSH
34351: CALL_OW 111
// exit ;
34355: GO 34381
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34357: LD_VAR 0 1
34361: PPUSH
34362: LD_VAR 0 2
34366: PPUSH
34367: LD_VAR 0 3
34371: PPUSH
34372: LD_VAR 0 4
34376: PPUSH
34377: CALL 65744 0 4
// end ;
34381: PPOPN 4
34383: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34384: LD_VAR 0 1
34388: PPUSH
34389: LD_VAR 0 2
34393: PPUSH
34394: CALL 61103 0 2
// end ;
34398: PPOPN 2
34400: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34401: LD_VAR 0 1
34405: PPUSH
34406: CALL 119331 0 1
// end ; end_of_file
34410: PPOPN 1
34412: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 2
34420: EQUAL
34421: IFFALSE 34904
34423: GO 34425
34425: DISABLE
34426: LD_INT 0
34428: PPUSH
// begin time := 0 0$40 ;
34429: LD_ADDR_VAR 0 1
34433: PUSH
34434: LD_INT 1400
34436: ST_TO_ADDR
// repeat wait ( time ) ;
34437: LD_VAR 0 1
34441: PPUSH
34442: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34446: LD_INT 1
34448: PPUSH
34449: LD_INT 5
34451: PPUSH
34452: CALL_OW 12
34456: PPUSH
34457: LD_INT 106
34459: PPUSH
34460: LD_INT 150
34462: PPUSH
34463: LD_INT 19
34465: PPUSH
34466: LD_INT 1
34468: PPUSH
34469: CALL_OW 56
// time := time + 0 0$9 ;
34473: LD_ADDR_VAR 0 1
34477: PUSH
34478: LD_VAR 0 1
34482: PUSH
34483: LD_INT 315
34485: PLUS
34486: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34487: LD_INT 455
34489: PPUSH
34490: LD_INT 840
34492: PPUSH
34493: CALL_OW 12
34497: PPUSH
34498: CALL_OW 67
// if Prob ( 50 ) then
34502: LD_INT 50
34504: PPUSH
34505: CALL_OW 13
34509: IFFALSE 34538
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34511: LD_INT 1
34513: PPUSH
34514: LD_INT 5
34516: PPUSH
34517: CALL_OW 12
34521: PPUSH
34522: LD_INT 62
34524: PPUSH
34525: LD_INT 108
34527: PPUSH
34528: LD_INT 10
34530: PPUSH
34531: LD_INT 1
34533: PPUSH
34534: CALL_OW 56
// until missionStage > 4 ;
34538: LD_EXP 15
34542: PUSH
34543: LD_INT 4
34545: GREATER
34546: IFFALSE 34437
// repeat wait ( 0 0$1 ) ;
34548: LD_INT 35
34550: PPUSH
34551: CALL_OW 67
// until missionStage = 6 ;
34555: LD_EXP 15
34559: PUSH
34560: LD_INT 6
34562: EQUAL
34563: IFFALSE 34548
// time := 0 0$50 ;
34565: LD_ADDR_VAR 0 1
34569: PUSH
34570: LD_INT 1750
34572: ST_TO_ADDR
// repeat wait ( time ) ;
34573: LD_VAR 0 1
34577: PPUSH
34578: CALL_OW 67
// if Prob ( 50 ) then
34582: LD_INT 50
34584: PPUSH
34585: CALL_OW 13
34589: IFFALSE 34618
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34591: LD_INT 1
34593: PPUSH
34594: LD_INT 5
34596: PPUSH
34597: CALL_OW 12
34601: PPUSH
34602: LD_INT 106
34604: PPUSH
34605: LD_INT 89
34607: PPUSH
34608: LD_INT 45
34610: PPUSH
34611: LD_INT 1
34613: PPUSH
34614: CALL_OW 56
// time := time + 0 0$2 ;
34618: LD_ADDR_VAR 0 1
34622: PUSH
34623: LD_VAR 0 1
34627: PUSH
34628: LD_INT 70
34630: PLUS
34631: ST_TO_ADDR
// if Prob ( 30 ) then
34632: LD_INT 30
34634: PPUSH
34635: CALL_OW 13
34639: IFFALSE 34685
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34641: LD_INT 385
34643: PPUSH
34644: LD_INT 945
34646: PPUSH
34647: CALL_OW 12
34651: PPUSH
34652: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34656: LD_INT 1
34658: PPUSH
34659: LD_INT 5
34661: PPUSH
34662: CALL_OW 12
34666: PPUSH
34667: LD_INT 21
34669: PPUSH
34670: LD_INT 26
34672: PPUSH
34673: LD_INT 12
34675: PPUSH
34676: LD_INT 1
34678: PPUSH
34679: CALL_OW 56
// end else
34683: GO 34721
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34685: LD_INT 700
34687: PPUSH
34688: LD_INT 1225
34690: PPUSH
34691: CALL_OW 12
34695: PPUSH
34696: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34700: LD_INT 1
34702: PPUSH
34703: LD_INT 5
34705: PPUSH
34706: CALL_OW 12
34710: PPUSH
34711: LD_INT 16
34713: PPUSH
34714: LD_INT 1
34716: PPUSH
34717: CALL_OW 55
// end ; if Prob ( 50 ) then
34721: LD_INT 50
34723: PPUSH
34724: CALL_OW 13
34728: IFFALSE 34774
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34730: LD_INT 700
34732: PPUSH
34733: LD_INT 1050
34735: PPUSH
34736: CALL_OW 12
34740: PPUSH
34741: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34745: LD_INT 1
34747: PPUSH
34748: LD_INT 5
34750: PPUSH
34751: CALL_OW 12
34755: PPUSH
34756: LD_INT 181
34758: PPUSH
34759: LD_INT 218
34761: PPUSH
34762: LD_INT 16
34764: PPUSH
34765: LD_INT 1
34767: PPUSH
34768: CALL_OW 56
// end else
34772: GO 34810
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34774: LD_INT 350
34776: PPUSH
34777: LD_INT 525
34779: PPUSH
34780: CALL_OW 12
34784: PPUSH
34785: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34789: LD_INT 1
34791: PPUSH
34792: LD_INT 5
34794: PPUSH
34795: CALL_OW 12
34799: PPUSH
34800: LD_INT 15
34802: PPUSH
34803: LD_INT 1
34805: PPUSH
34806: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34810: LD_INT 45
34812: PUSH
34813: LD_INT 32
34815: PUSH
34816: LD_INT 25
34818: PUSH
34819: LD_INT 22
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: PUSH
34828: LD_OWVAR 67
34832: ARRAY
34833: PPUSH
34834: CALL_OW 13
34838: IFFALSE 34882
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34840: LD_INT 175
34842: PPUSH
34843: LD_INT 315
34845: PPUSH
34846: CALL_OW 12
34850: PPUSH
34851: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34855: LD_INT 1
34857: PPUSH
34858: LD_INT 5
34860: PPUSH
34861: CALL_OW 12
34865: PPUSH
34866: LD_INT 103
34868: PPUSH
34869: LD_INT 140
34871: PPUSH
34872: LD_INT 20
34874: PPUSH
34875: LD_INT 1
34877: PPUSH
34878: CALL_OW 56
// end ; if time > 1 1$20 then
34882: LD_VAR 0 1
34886: PUSH
34887: LD_INT 2800
34889: GREATER
34890: IFFALSE 34900
// time := 0 0$30 ;
34892: LD_ADDR_VAR 0 1
34896: PUSH
34897: LD_INT 1050
34899: ST_TO_ADDR
// until false ;
34900: LD_INT 0
34902: IFFALSE 34573
// end ; end_of_file
34904: PPOPN 1
34906: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34907: LD_EXP 13
34911: PUSH
34912: LD_EXP 15
34916: PUSH
34917: LD_INT 6
34919: GREATEREQUAL
34920: AND
34921: IFFALSE 34958
34923: GO 34925
34925: DISABLE
// begin enable ;
34926: ENABLE
// missionTime := missionTime + 0 0$1 ;
34927: LD_ADDR_EXP 14
34931: PUSH
34932: LD_EXP 14
34936: PUSH
34937: LD_INT 35
34939: PLUS
34940: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34941: LD_ADDR_OWVAR 47
34945: PUSH
34946: LD_STRING #Am15-1
34948: PUSH
34949: LD_EXP 14
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: ST_TO_ADDR
// end ; end_of_file
34958: END
// export function InitNature ; begin
34959: LD_INT 0
34961: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34962: LD_INT 3
34964: PPUSH
34965: LD_INT 3
34967: PPUSH
34968: LD_INT 2
34970: PPUSH
34971: LD_INT 1
34973: PPUSH
34974: LD_INT 1
34976: PPUSH
34977: LD_INT 0
34979: PPUSH
34980: LD_INT 0
34982: PPUSH
34983: LD_INT 20
34985: PPUSH
34986: LD_INT 0
34988: PPUSH
34989: CALL 99248 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34993: LD_INT 2
34995: PPUSH
34996: LD_INT 1
34998: PPUSH
34999: LD_INT 1
35001: PPUSH
35002: LD_INT 1
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: LD_INT 0
35010: PPUSH
35011: LD_INT 0
35013: PPUSH
35014: LD_INT 21
35016: PPUSH
35017: LD_INT 0
35019: PPUSH
35020: CALL 99248 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35024: LD_INT 4
35026: PPUSH
35027: LD_INT 1
35029: PPUSH
35030: LD_INT 2
35032: PPUSH
35033: LD_INT 4
35035: PPUSH
35036: LD_INT 2
35038: PPUSH
35039: LD_INT 1
35041: PPUSH
35042: LD_INT 0
35044: PPUSH
35045: LD_INT 22
35047: PPUSH
35048: LD_INT 0
35050: PPUSH
35051: CALL 99248 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35055: LD_INT 0
35057: PPUSH
35058: LD_INT 0
35060: PPUSH
35061: LD_INT 0
35063: PPUSH
35064: LD_INT 0
35066: PPUSH
35067: LD_INT 0
35069: PPUSH
35070: LD_INT 0
35072: PPUSH
35073: LD_INT 9
35075: PPUSH
35076: LD_INT 0
35078: PPUSH
35079: LD_INT 23
35081: PPUSH
35082: CALL 99248 0 9
// end ; end_of_file
35086: LD_VAR 0 1
35090: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
35091: LD_INT 0
35093: PPUSH
// ar_miner := 81 ;
35094: LD_ADDR_EXP 102
35098: PUSH
35099: LD_INT 81
35101: ST_TO_ADDR
// ar_crane := 88 ;
35102: LD_ADDR_EXP 101
35106: PUSH
35107: LD_INT 88
35109: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35110: LD_ADDR_EXP 96
35114: PUSH
35115: LD_INT 89
35117: ST_TO_ADDR
// us_hack := 99 ;
35118: LD_ADDR_EXP 97
35122: PUSH
35123: LD_INT 99
35125: ST_TO_ADDR
// us_artillery := 97 ;
35126: LD_ADDR_EXP 98
35130: PUSH
35131: LD_INT 97
35133: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35134: LD_ADDR_EXP 99
35138: PUSH
35139: LD_INT 91
35141: ST_TO_ADDR
// ar_mortar := 92 ;
35142: LD_ADDR_EXP 100
35146: PUSH
35147: LD_INT 92
35149: ST_TO_ADDR
// ru_radar := 98 ;
35150: LD_ADDR_EXP 95
35154: PUSH
35155: LD_INT 98
35157: ST_TO_ADDR
// tech_Artillery := 80 ;
35158: LD_ADDR_EXP 103
35162: PUSH
35163: LD_INT 80
35165: ST_TO_ADDR
// tech_RadMat := 81 ;
35166: LD_ADDR_EXP 104
35170: PUSH
35171: LD_INT 81
35173: ST_TO_ADDR
// tech_BasicTools := 82 ;
35174: LD_ADDR_EXP 105
35178: PUSH
35179: LD_INT 82
35181: ST_TO_ADDR
// tech_Cargo := 83 ;
35182: LD_ADDR_EXP 106
35186: PUSH
35187: LD_INT 83
35189: ST_TO_ADDR
// tech_Track := 84 ;
35190: LD_ADDR_EXP 107
35194: PUSH
35195: LD_INT 84
35197: ST_TO_ADDR
// tech_Crane := 85 ;
35198: LD_ADDR_EXP 108
35202: PUSH
35203: LD_INT 85
35205: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35206: LD_ADDR_EXP 109
35210: PUSH
35211: LD_INT 86
35213: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35214: LD_ADDR_EXP 110
35218: PUSH
35219: LD_INT 87
35221: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35222: LD_ADDR_EXP 111
35226: PUSH
35227: LD_INT 88
35229: ST_TO_ADDR
// class_mastodont := 31 ;
35230: LD_ADDR_EXP 112
35234: PUSH
35235: LD_INT 31
35237: ST_TO_ADDR
// class_horse := 21 ;
35238: LD_ADDR_EXP 113
35242: PUSH
35243: LD_INT 21
35245: ST_TO_ADDR
// end ;
35246: LD_VAR 0 1
35250: RET
// every 1 do
35251: GO 35253
35253: DISABLE
// InitGlobalVariables ; end_of_file
35254: CALL 35091 0 0
35258: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35259: LD_INT 0
35261: PPUSH
35262: PPUSH
// skirmish := false ;
35263: LD_ADDR_EXP 114
35267: PUSH
35268: LD_INT 0
35270: ST_TO_ADDR
// debug_mc := false ;
35271: LD_ADDR_EXP 115
35275: PUSH
35276: LD_INT 0
35278: ST_TO_ADDR
// mc_bases := [ ] ;
35279: LD_ADDR_EXP 116
35283: PUSH
35284: EMPTY
35285: ST_TO_ADDR
// mc_sides := [ ] ;
35286: LD_ADDR_EXP 142
35290: PUSH
35291: EMPTY
35292: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35293: LD_ADDR_EXP 117
35297: PUSH
35298: EMPTY
35299: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35300: LD_ADDR_EXP 118
35304: PUSH
35305: EMPTY
35306: ST_TO_ADDR
// mc_need_heal := [ ] ;
35307: LD_ADDR_EXP 119
35311: PUSH
35312: EMPTY
35313: ST_TO_ADDR
// mc_healers := [ ] ;
35314: LD_ADDR_EXP 120
35318: PUSH
35319: EMPTY
35320: ST_TO_ADDR
// mc_build_list := [ ] ;
35321: LD_ADDR_EXP 121
35325: PUSH
35326: EMPTY
35327: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35328: LD_ADDR_EXP 148
35332: PUSH
35333: EMPTY
35334: ST_TO_ADDR
// mc_builders := [ ] ;
35335: LD_ADDR_EXP 122
35339: PUSH
35340: EMPTY
35341: ST_TO_ADDR
// mc_construct_list := [ ] ;
35342: LD_ADDR_EXP 123
35346: PUSH
35347: EMPTY
35348: ST_TO_ADDR
// mc_turret_list := [ ] ;
35349: LD_ADDR_EXP 124
35353: PUSH
35354: EMPTY
35355: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35356: LD_ADDR_EXP 125
35360: PUSH
35361: EMPTY
35362: ST_TO_ADDR
// mc_miners := [ ] ;
35363: LD_ADDR_EXP 130
35367: PUSH
35368: EMPTY
35369: ST_TO_ADDR
// mc_mines := [ ] ;
35370: LD_ADDR_EXP 129
35374: PUSH
35375: EMPTY
35376: ST_TO_ADDR
// mc_minefields := [ ] ;
35377: LD_ADDR_EXP 131
35381: PUSH
35382: EMPTY
35383: ST_TO_ADDR
// mc_crates := [ ] ;
35384: LD_ADDR_EXP 132
35388: PUSH
35389: EMPTY
35390: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35391: LD_ADDR_EXP 133
35395: PUSH
35396: EMPTY
35397: ST_TO_ADDR
// mc_crates_area := [ ] ;
35398: LD_ADDR_EXP 134
35402: PUSH
35403: EMPTY
35404: ST_TO_ADDR
// mc_vehicles := [ ] ;
35405: LD_ADDR_EXP 135
35409: PUSH
35410: EMPTY
35411: ST_TO_ADDR
// mc_attack := [ ] ;
35412: LD_ADDR_EXP 136
35416: PUSH
35417: EMPTY
35418: ST_TO_ADDR
// mc_produce := [ ] ;
35419: LD_ADDR_EXP 137
35423: PUSH
35424: EMPTY
35425: ST_TO_ADDR
// mc_defender := [ ] ;
35426: LD_ADDR_EXP 138
35430: PUSH
35431: EMPTY
35432: ST_TO_ADDR
// mc_parking := [ ] ;
35433: LD_ADDR_EXP 140
35437: PUSH
35438: EMPTY
35439: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35440: LD_ADDR_EXP 126
35444: PUSH
35445: EMPTY
35446: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35447: LD_ADDR_EXP 128
35451: PUSH
35452: EMPTY
35453: ST_TO_ADDR
// mc_scan := [ ] ;
35454: LD_ADDR_EXP 139
35458: PUSH
35459: EMPTY
35460: ST_TO_ADDR
// mc_scan_area := [ ] ;
35461: LD_ADDR_EXP 141
35465: PUSH
35466: EMPTY
35467: ST_TO_ADDR
// mc_tech := [ ] ;
35468: LD_ADDR_EXP 143
35472: PUSH
35473: EMPTY
35474: ST_TO_ADDR
// mc_class := [ ] ;
35475: LD_ADDR_EXP 157
35479: PUSH
35480: EMPTY
35481: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35482: LD_ADDR_EXP 158
35486: PUSH
35487: EMPTY
35488: ST_TO_ADDR
// mc_is_defending := [ ] ;
35489: LD_ADDR_EXP 159
35493: PUSH
35494: EMPTY
35495: ST_TO_ADDR
// end ;
35496: LD_VAR 0 1
35500: RET
// export function MC_Kill ( base ) ; begin
35501: LD_INT 0
35503: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35504: LD_ADDR_EXP 116
35508: PUSH
35509: LD_EXP 116
35513: PPUSH
35514: LD_VAR 0 1
35518: PPUSH
35519: EMPTY
35520: PPUSH
35521: CALL_OW 1
35525: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35526: LD_ADDR_EXP 117
35530: PUSH
35531: LD_EXP 117
35535: PPUSH
35536: LD_VAR 0 1
35540: PPUSH
35541: EMPTY
35542: PPUSH
35543: CALL_OW 1
35547: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35548: LD_ADDR_EXP 118
35552: PUSH
35553: LD_EXP 118
35557: PPUSH
35558: LD_VAR 0 1
35562: PPUSH
35563: EMPTY
35564: PPUSH
35565: CALL_OW 1
35569: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35570: LD_ADDR_EXP 119
35574: PUSH
35575: LD_EXP 119
35579: PPUSH
35580: LD_VAR 0 1
35584: PPUSH
35585: EMPTY
35586: PPUSH
35587: CALL_OW 1
35591: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35592: LD_ADDR_EXP 120
35596: PUSH
35597: LD_EXP 120
35601: PPUSH
35602: LD_VAR 0 1
35606: PPUSH
35607: EMPTY
35608: PPUSH
35609: CALL_OW 1
35613: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35614: LD_ADDR_EXP 121
35618: PUSH
35619: LD_EXP 121
35623: PPUSH
35624: LD_VAR 0 1
35628: PPUSH
35629: EMPTY
35630: PPUSH
35631: CALL_OW 1
35635: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35636: LD_ADDR_EXP 122
35640: PUSH
35641: LD_EXP 122
35645: PPUSH
35646: LD_VAR 0 1
35650: PPUSH
35651: EMPTY
35652: PPUSH
35653: CALL_OW 1
35657: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35658: LD_ADDR_EXP 123
35662: PUSH
35663: LD_EXP 123
35667: PPUSH
35668: LD_VAR 0 1
35672: PPUSH
35673: EMPTY
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35680: LD_ADDR_EXP 124
35684: PUSH
35685: LD_EXP 124
35689: PPUSH
35690: LD_VAR 0 1
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35702: LD_ADDR_EXP 125
35706: PUSH
35707: LD_EXP 125
35711: PPUSH
35712: LD_VAR 0 1
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35724: LD_ADDR_EXP 126
35728: PUSH
35729: LD_EXP 126
35733: PPUSH
35734: LD_VAR 0 1
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35746: LD_ADDR_EXP 127
35750: PUSH
35751: LD_EXP 127
35755: PPUSH
35756: LD_VAR 0 1
35760: PPUSH
35761: LD_INT 0
35763: PPUSH
35764: CALL_OW 1
35768: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35769: LD_ADDR_EXP 128
35773: PUSH
35774: LD_EXP 128
35778: PPUSH
35779: LD_VAR 0 1
35783: PPUSH
35784: EMPTY
35785: PPUSH
35786: CALL_OW 1
35790: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35791: LD_ADDR_EXP 129
35795: PUSH
35796: LD_EXP 129
35800: PPUSH
35801: LD_VAR 0 1
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35813: LD_ADDR_EXP 130
35817: PUSH
35818: LD_EXP 130
35822: PPUSH
35823: LD_VAR 0 1
35827: PPUSH
35828: EMPTY
35829: PPUSH
35830: CALL_OW 1
35834: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35835: LD_ADDR_EXP 131
35839: PUSH
35840: LD_EXP 131
35844: PPUSH
35845: LD_VAR 0 1
35849: PPUSH
35850: EMPTY
35851: PPUSH
35852: CALL_OW 1
35856: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35857: LD_ADDR_EXP 132
35861: PUSH
35862: LD_EXP 132
35866: PPUSH
35867: LD_VAR 0 1
35871: PPUSH
35872: EMPTY
35873: PPUSH
35874: CALL_OW 1
35878: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35879: LD_ADDR_EXP 133
35883: PUSH
35884: LD_EXP 133
35888: PPUSH
35889: LD_VAR 0 1
35893: PPUSH
35894: EMPTY
35895: PPUSH
35896: CALL_OW 1
35900: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35901: LD_ADDR_EXP 134
35905: PUSH
35906: LD_EXP 134
35910: PPUSH
35911: LD_VAR 0 1
35915: PPUSH
35916: EMPTY
35917: PPUSH
35918: CALL_OW 1
35922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35923: LD_ADDR_EXP 135
35927: PUSH
35928: LD_EXP 135
35932: PPUSH
35933: LD_VAR 0 1
35937: PPUSH
35938: EMPTY
35939: PPUSH
35940: CALL_OW 1
35944: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35945: LD_ADDR_EXP 136
35949: PUSH
35950: LD_EXP 136
35954: PPUSH
35955: LD_VAR 0 1
35959: PPUSH
35960: EMPTY
35961: PPUSH
35962: CALL_OW 1
35966: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35967: LD_ADDR_EXP 137
35971: PUSH
35972: LD_EXP 137
35976: PPUSH
35977: LD_VAR 0 1
35981: PPUSH
35982: EMPTY
35983: PPUSH
35984: CALL_OW 1
35988: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35989: LD_ADDR_EXP 138
35993: PUSH
35994: LD_EXP 138
35998: PPUSH
35999: LD_VAR 0 1
36003: PPUSH
36004: EMPTY
36005: PPUSH
36006: CALL_OW 1
36010: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36011: LD_ADDR_EXP 139
36015: PUSH
36016: LD_EXP 139
36020: PPUSH
36021: LD_VAR 0 1
36025: PPUSH
36026: EMPTY
36027: PPUSH
36028: CALL_OW 1
36032: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36033: LD_ADDR_EXP 140
36037: PUSH
36038: LD_EXP 140
36042: PPUSH
36043: LD_VAR 0 1
36047: PPUSH
36048: EMPTY
36049: PPUSH
36050: CALL_OW 1
36054: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36055: LD_ADDR_EXP 141
36059: PUSH
36060: LD_EXP 141
36064: PPUSH
36065: LD_VAR 0 1
36069: PPUSH
36070: EMPTY
36071: PPUSH
36072: CALL_OW 1
36076: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36077: LD_ADDR_EXP 143
36081: PUSH
36082: LD_EXP 143
36086: PPUSH
36087: LD_VAR 0 1
36091: PPUSH
36092: EMPTY
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36099: LD_ADDR_EXP 145
36103: PUSH
36104: LD_EXP 145
36108: PPUSH
36109: LD_VAR 0 1
36113: PPUSH
36114: EMPTY
36115: PPUSH
36116: CALL_OW 1
36120: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36121: LD_ADDR_EXP 146
36125: PUSH
36126: LD_EXP 146
36130: PPUSH
36131: LD_VAR 0 1
36135: PPUSH
36136: EMPTY
36137: PPUSH
36138: CALL_OW 1
36142: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36143: LD_ADDR_EXP 147
36147: PUSH
36148: LD_EXP 147
36152: PPUSH
36153: LD_VAR 0 1
36157: PPUSH
36158: EMPTY
36159: PPUSH
36160: CALL_OW 1
36164: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36165: LD_ADDR_EXP 148
36169: PUSH
36170: LD_EXP 148
36174: PPUSH
36175: LD_VAR 0 1
36179: PPUSH
36180: EMPTY
36181: PPUSH
36182: CALL_OW 1
36186: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36187: LD_ADDR_EXP 149
36191: PUSH
36192: LD_EXP 149
36196: PPUSH
36197: LD_VAR 0 1
36201: PPUSH
36202: EMPTY
36203: PPUSH
36204: CALL_OW 1
36208: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36209: LD_ADDR_EXP 150
36213: PUSH
36214: LD_EXP 150
36218: PPUSH
36219: LD_VAR 0 1
36223: PPUSH
36224: EMPTY
36225: PPUSH
36226: CALL_OW 1
36230: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36231: LD_ADDR_EXP 151
36235: PUSH
36236: LD_EXP 151
36240: PPUSH
36241: LD_VAR 0 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL_OW 1
36252: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36253: LD_ADDR_EXP 152
36257: PUSH
36258: LD_EXP 152
36262: PPUSH
36263: LD_VAR 0 1
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL_OW 1
36274: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36275: LD_ADDR_EXP 153
36279: PUSH
36280: LD_EXP 153
36284: PPUSH
36285: LD_VAR 0 1
36289: PPUSH
36290: EMPTY
36291: PPUSH
36292: CALL_OW 1
36296: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36297: LD_ADDR_EXP 154
36301: PUSH
36302: LD_EXP 154
36306: PPUSH
36307: LD_VAR 0 1
36311: PPUSH
36312: EMPTY
36313: PPUSH
36314: CALL_OW 1
36318: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36319: LD_ADDR_EXP 155
36323: PUSH
36324: LD_EXP 155
36328: PPUSH
36329: LD_VAR 0 1
36333: PPUSH
36334: EMPTY
36335: PPUSH
36336: CALL_OW 1
36340: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36341: LD_ADDR_EXP 156
36345: PUSH
36346: LD_EXP 156
36350: PPUSH
36351: LD_VAR 0 1
36355: PPUSH
36356: EMPTY
36357: PPUSH
36358: CALL_OW 1
36362: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36363: LD_ADDR_EXP 157
36367: PUSH
36368: LD_EXP 157
36372: PPUSH
36373: LD_VAR 0 1
36377: PPUSH
36378: EMPTY
36379: PPUSH
36380: CALL_OW 1
36384: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36385: LD_ADDR_EXP 158
36389: PUSH
36390: LD_EXP 158
36394: PPUSH
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_INT 0
36402: PPUSH
36403: CALL_OW 1
36407: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36408: LD_ADDR_EXP 159
36412: PUSH
36413: LD_EXP 159
36417: PPUSH
36418: LD_VAR 0 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL_OW 1
36430: ST_TO_ADDR
// end ;
36431: LD_VAR 0 2
36435: RET
// export function MC_Add ( side , units ) ; var base ; begin
36436: LD_INT 0
36438: PPUSH
36439: PPUSH
// base := mc_bases + 1 ;
36440: LD_ADDR_VAR 0 4
36444: PUSH
36445: LD_EXP 116
36449: PUSH
36450: LD_INT 1
36452: PLUS
36453: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36454: LD_ADDR_EXP 142
36458: PUSH
36459: LD_EXP 142
36463: PPUSH
36464: LD_VAR 0 4
36468: PPUSH
36469: LD_VAR 0 1
36473: PPUSH
36474: CALL_OW 1
36478: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36479: LD_ADDR_EXP 116
36483: PUSH
36484: LD_EXP 116
36488: PPUSH
36489: LD_VAR 0 4
36493: PPUSH
36494: LD_VAR 0 2
36498: PPUSH
36499: CALL_OW 1
36503: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36504: LD_ADDR_EXP 117
36508: PUSH
36509: LD_EXP 117
36513: PPUSH
36514: LD_VAR 0 4
36518: PPUSH
36519: EMPTY
36520: PPUSH
36521: CALL_OW 1
36525: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36526: LD_ADDR_EXP 118
36530: PUSH
36531: LD_EXP 118
36535: PPUSH
36536: LD_VAR 0 4
36540: PPUSH
36541: EMPTY
36542: PPUSH
36543: CALL_OW 1
36547: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36548: LD_ADDR_EXP 119
36552: PUSH
36553: LD_EXP 119
36557: PPUSH
36558: LD_VAR 0 4
36562: PPUSH
36563: EMPTY
36564: PPUSH
36565: CALL_OW 1
36569: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36570: LD_ADDR_EXP 120
36574: PUSH
36575: LD_EXP 120
36579: PPUSH
36580: LD_VAR 0 4
36584: PPUSH
36585: EMPTY
36586: PPUSH
36587: CALL_OW 1
36591: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36592: LD_ADDR_EXP 121
36596: PUSH
36597: LD_EXP 121
36601: PPUSH
36602: LD_VAR 0 4
36606: PPUSH
36607: EMPTY
36608: PPUSH
36609: CALL_OW 1
36613: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36614: LD_ADDR_EXP 122
36618: PUSH
36619: LD_EXP 122
36623: PPUSH
36624: LD_VAR 0 4
36628: PPUSH
36629: EMPTY
36630: PPUSH
36631: CALL_OW 1
36635: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36636: LD_ADDR_EXP 123
36640: PUSH
36641: LD_EXP 123
36645: PPUSH
36646: LD_VAR 0 4
36650: PPUSH
36651: EMPTY
36652: PPUSH
36653: CALL_OW 1
36657: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36658: LD_ADDR_EXP 124
36662: PUSH
36663: LD_EXP 124
36667: PPUSH
36668: LD_VAR 0 4
36672: PPUSH
36673: EMPTY
36674: PPUSH
36675: CALL_OW 1
36679: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36680: LD_ADDR_EXP 125
36684: PUSH
36685: LD_EXP 125
36689: PPUSH
36690: LD_VAR 0 4
36694: PPUSH
36695: EMPTY
36696: PPUSH
36697: CALL_OW 1
36701: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36702: LD_ADDR_EXP 126
36706: PUSH
36707: LD_EXP 126
36711: PPUSH
36712: LD_VAR 0 4
36716: PPUSH
36717: EMPTY
36718: PPUSH
36719: CALL_OW 1
36723: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36724: LD_ADDR_EXP 127
36728: PUSH
36729: LD_EXP 127
36733: PPUSH
36734: LD_VAR 0 4
36738: PPUSH
36739: LD_INT 0
36741: PPUSH
36742: CALL_OW 1
36746: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36747: LD_ADDR_EXP 128
36751: PUSH
36752: LD_EXP 128
36756: PPUSH
36757: LD_VAR 0 4
36761: PPUSH
36762: EMPTY
36763: PPUSH
36764: CALL_OW 1
36768: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36769: LD_ADDR_EXP 129
36773: PUSH
36774: LD_EXP 129
36778: PPUSH
36779: LD_VAR 0 4
36783: PPUSH
36784: EMPTY
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36791: LD_ADDR_EXP 130
36795: PUSH
36796: LD_EXP 130
36800: PPUSH
36801: LD_VAR 0 4
36805: PPUSH
36806: EMPTY
36807: PPUSH
36808: CALL_OW 1
36812: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36813: LD_ADDR_EXP 131
36817: PUSH
36818: LD_EXP 131
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: EMPTY
36829: PPUSH
36830: CALL_OW 1
36834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36835: LD_ADDR_EXP 132
36839: PUSH
36840: LD_EXP 132
36844: PPUSH
36845: LD_VAR 0 4
36849: PPUSH
36850: EMPTY
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36857: LD_ADDR_EXP 133
36861: PUSH
36862: LD_EXP 133
36866: PPUSH
36867: LD_VAR 0 4
36871: PPUSH
36872: EMPTY
36873: PPUSH
36874: CALL_OW 1
36878: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36879: LD_ADDR_EXP 134
36883: PUSH
36884: LD_EXP 134
36888: PPUSH
36889: LD_VAR 0 4
36893: PPUSH
36894: EMPTY
36895: PPUSH
36896: CALL_OW 1
36900: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36901: LD_ADDR_EXP 135
36905: PUSH
36906: LD_EXP 135
36910: PPUSH
36911: LD_VAR 0 4
36915: PPUSH
36916: EMPTY
36917: PPUSH
36918: CALL_OW 1
36922: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36923: LD_ADDR_EXP 136
36927: PUSH
36928: LD_EXP 136
36932: PPUSH
36933: LD_VAR 0 4
36937: PPUSH
36938: EMPTY
36939: PPUSH
36940: CALL_OW 1
36944: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36945: LD_ADDR_EXP 137
36949: PUSH
36950: LD_EXP 137
36954: PPUSH
36955: LD_VAR 0 4
36959: PPUSH
36960: EMPTY
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36967: LD_ADDR_EXP 138
36971: PUSH
36972: LD_EXP 138
36976: PPUSH
36977: LD_VAR 0 4
36981: PPUSH
36982: EMPTY
36983: PPUSH
36984: CALL_OW 1
36988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36989: LD_ADDR_EXP 139
36993: PUSH
36994: LD_EXP 139
36998: PPUSH
36999: LD_VAR 0 4
37003: PPUSH
37004: EMPTY
37005: PPUSH
37006: CALL_OW 1
37010: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37011: LD_ADDR_EXP 140
37015: PUSH
37016: LD_EXP 140
37020: PPUSH
37021: LD_VAR 0 4
37025: PPUSH
37026: EMPTY
37027: PPUSH
37028: CALL_OW 1
37032: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37033: LD_ADDR_EXP 141
37037: PUSH
37038: LD_EXP 141
37042: PPUSH
37043: LD_VAR 0 4
37047: PPUSH
37048: EMPTY
37049: PPUSH
37050: CALL_OW 1
37054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37055: LD_ADDR_EXP 143
37059: PUSH
37060: LD_EXP 143
37064: PPUSH
37065: LD_VAR 0 4
37069: PPUSH
37070: EMPTY
37071: PPUSH
37072: CALL_OW 1
37076: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37077: LD_ADDR_EXP 145
37081: PUSH
37082: LD_EXP 145
37086: PPUSH
37087: LD_VAR 0 4
37091: PPUSH
37092: EMPTY
37093: PPUSH
37094: CALL_OW 1
37098: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37099: LD_ADDR_EXP 146
37103: PUSH
37104: LD_EXP 146
37108: PPUSH
37109: LD_VAR 0 4
37113: PPUSH
37114: EMPTY
37115: PPUSH
37116: CALL_OW 1
37120: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37121: LD_ADDR_EXP 147
37125: PUSH
37126: LD_EXP 147
37130: PPUSH
37131: LD_VAR 0 4
37135: PPUSH
37136: EMPTY
37137: PPUSH
37138: CALL_OW 1
37142: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37143: LD_ADDR_EXP 148
37147: PUSH
37148: LD_EXP 148
37152: PPUSH
37153: LD_VAR 0 4
37157: PPUSH
37158: EMPTY
37159: PPUSH
37160: CALL_OW 1
37164: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37165: LD_ADDR_EXP 149
37169: PUSH
37170: LD_EXP 149
37174: PPUSH
37175: LD_VAR 0 4
37179: PPUSH
37180: EMPTY
37181: PPUSH
37182: CALL_OW 1
37186: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37187: LD_ADDR_EXP 150
37191: PUSH
37192: LD_EXP 150
37196: PPUSH
37197: LD_VAR 0 4
37201: PPUSH
37202: EMPTY
37203: PPUSH
37204: CALL_OW 1
37208: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37209: LD_ADDR_EXP 151
37213: PUSH
37214: LD_EXP 151
37218: PPUSH
37219: LD_VAR 0 4
37223: PPUSH
37224: EMPTY
37225: PPUSH
37226: CALL_OW 1
37230: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37231: LD_ADDR_EXP 152
37235: PUSH
37236: LD_EXP 152
37240: PPUSH
37241: LD_VAR 0 4
37245: PPUSH
37246: EMPTY
37247: PPUSH
37248: CALL_OW 1
37252: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37253: LD_ADDR_EXP 153
37257: PUSH
37258: LD_EXP 153
37262: PPUSH
37263: LD_VAR 0 4
37267: PPUSH
37268: EMPTY
37269: PPUSH
37270: CALL_OW 1
37274: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37275: LD_ADDR_EXP 154
37279: PUSH
37280: LD_EXP 154
37284: PPUSH
37285: LD_VAR 0 4
37289: PPUSH
37290: EMPTY
37291: PPUSH
37292: CALL_OW 1
37296: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37297: LD_ADDR_EXP 155
37301: PUSH
37302: LD_EXP 155
37306: PPUSH
37307: LD_VAR 0 4
37311: PPUSH
37312: EMPTY
37313: PPUSH
37314: CALL_OW 1
37318: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37319: LD_ADDR_EXP 156
37323: PUSH
37324: LD_EXP 156
37328: PPUSH
37329: LD_VAR 0 4
37333: PPUSH
37334: EMPTY
37335: PPUSH
37336: CALL_OW 1
37340: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37341: LD_ADDR_EXP 157
37345: PUSH
37346: LD_EXP 157
37350: PPUSH
37351: LD_VAR 0 4
37355: PPUSH
37356: EMPTY
37357: PPUSH
37358: CALL_OW 1
37362: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37363: LD_ADDR_EXP 158
37367: PUSH
37368: LD_EXP 158
37372: PPUSH
37373: LD_VAR 0 4
37377: PPUSH
37378: LD_INT 0
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37386: LD_ADDR_EXP 159
37390: PUSH
37391: LD_EXP 159
37395: PPUSH
37396: LD_VAR 0 4
37400: PPUSH
37401: LD_INT 0
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// result := base ;
37409: LD_ADDR_VAR 0 3
37413: PUSH
37414: LD_VAR 0 4
37418: ST_TO_ADDR
// end ;
37419: LD_VAR 0 3
37423: RET
// export function MC_Start ( ) ; var i ; begin
37424: LD_INT 0
37426: PPUSH
37427: PPUSH
// for i = 1 to mc_bases do
37428: LD_ADDR_VAR 0 2
37432: PUSH
37433: DOUBLE
37434: LD_INT 1
37436: DEC
37437: ST_TO_ADDR
37438: LD_EXP 116
37442: PUSH
37443: FOR_TO
37444: IFFALSE 38544
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37446: LD_ADDR_EXP 116
37450: PUSH
37451: LD_EXP 116
37455: PPUSH
37456: LD_VAR 0 2
37460: PPUSH
37461: LD_EXP 116
37465: PUSH
37466: LD_VAR 0 2
37470: ARRAY
37471: PUSH
37472: LD_INT 0
37474: DIFF
37475: PPUSH
37476: CALL_OW 1
37480: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37481: LD_ADDR_EXP 117
37485: PUSH
37486: LD_EXP 117
37490: PPUSH
37491: LD_VAR 0 2
37495: PPUSH
37496: EMPTY
37497: PPUSH
37498: CALL_OW 1
37502: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37503: LD_ADDR_EXP 118
37507: PUSH
37508: LD_EXP 118
37512: PPUSH
37513: LD_VAR 0 2
37517: PPUSH
37518: EMPTY
37519: PPUSH
37520: CALL_OW 1
37524: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37525: LD_ADDR_EXP 119
37529: PUSH
37530: LD_EXP 119
37534: PPUSH
37535: LD_VAR 0 2
37539: PPUSH
37540: EMPTY
37541: PPUSH
37542: CALL_OW 1
37546: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37547: LD_ADDR_EXP 120
37551: PUSH
37552: LD_EXP 120
37556: PPUSH
37557: LD_VAR 0 2
37561: PPUSH
37562: EMPTY
37563: PUSH
37564: EMPTY
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PPUSH
37570: CALL_OW 1
37574: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37575: LD_ADDR_EXP 121
37579: PUSH
37580: LD_EXP 121
37584: PPUSH
37585: LD_VAR 0 2
37589: PPUSH
37590: EMPTY
37591: PPUSH
37592: CALL_OW 1
37596: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37597: LD_ADDR_EXP 148
37601: PUSH
37602: LD_EXP 148
37606: PPUSH
37607: LD_VAR 0 2
37611: PPUSH
37612: EMPTY
37613: PPUSH
37614: CALL_OW 1
37618: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37619: LD_ADDR_EXP 122
37623: PUSH
37624: LD_EXP 122
37628: PPUSH
37629: LD_VAR 0 2
37633: PPUSH
37634: EMPTY
37635: PPUSH
37636: CALL_OW 1
37640: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37641: LD_ADDR_EXP 123
37645: PUSH
37646: LD_EXP 123
37650: PPUSH
37651: LD_VAR 0 2
37655: PPUSH
37656: EMPTY
37657: PPUSH
37658: CALL_OW 1
37662: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37663: LD_ADDR_EXP 124
37667: PUSH
37668: LD_EXP 124
37672: PPUSH
37673: LD_VAR 0 2
37677: PPUSH
37678: LD_EXP 116
37682: PUSH
37683: LD_VAR 0 2
37687: ARRAY
37688: PPUSH
37689: LD_INT 2
37691: PUSH
37692: LD_INT 30
37694: PUSH
37695: LD_INT 32
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 30
37704: PUSH
37705: LD_INT 33
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: LIST
37716: PPUSH
37717: CALL_OW 72
37721: PPUSH
37722: CALL_OW 1
37726: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37727: LD_ADDR_EXP 125
37731: PUSH
37732: LD_EXP 125
37736: PPUSH
37737: LD_VAR 0 2
37741: PPUSH
37742: LD_EXP 116
37746: PUSH
37747: LD_VAR 0 2
37751: ARRAY
37752: PPUSH
37753: LD_INT 2
37755: PUSH
37756: LD_INT 30
37758: PUSH
37759: LD_INT 32
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 30
37768: PUSH
37769: LD_INT 31
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 58
37783: PUSH
37784: EMPTY
37785: LIST
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PPUSH
37791: CALL_OW 72
37795: PPUSH
37796: CALL_OW 1
37800: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37801: LD_ADDR_EXP 126
37805: PUSH
37806: LD_EXP 126
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: EMPTY
37817: PPUSH
37818: CALL_OW 1
37822: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37823: LD_ADDR_EXP 130
37827: PUSH
37828: LD_EXP 130
37832: PPUSH
37833: LD_VAR 0 2
37837: PPUSH
37838: EMPTY
37839: PPUSH
37840: CALL_OW 1
37844: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37845: LD_ADDR_EXP 129
37849: PUSH
37850: LD_EXP 129
37854: PPUSH
37855: LD_VAR 0 2
37859: PPUSH
37860: EMPTY
37861: PPUSH
37862: CALL_OW 1
37866: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37867: LD_ADDR_EXP 131
37871: PUSH
37872: LD_EXP 131
37876: PPUSH
37877: LD_VAR 0 2
37881: PPUSH
37882: EMPTY
37883: PPUSH
37884: CALL_OW 1
37888: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37889: LD_ADDR_EXP 132
37893: PUSH
37894: LD_EXP 132
37898: PPUSH
37899: LD_VAR 0 2
37903: PPUSH
37904: EMPTY
37905: PPUSH
37906: CALL_OW 1
37910: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37911: LD_ADDR_EXP 133
37915: PUSH
37916: LD_EXP 133
37920: PPUSH
37921: LD_VAR 0 2
37925: PPUSH
37926: EMPTY
37927: PPUSH
37928: CALL_OW 1
37932: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37933: LD_ADDR_EXP 134
37937: PUSH
37938: LD_EXP 134
37942: PPUSH
37943: LD_VAR 0 2
37947: PPUSH
37948: EMPTY
37949: PPUSH
37950: CALL_OW 1
37954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37955: LD_ADDR_EXP 135
37959: PUSH
37960: LD_EXP 135
37964: PPUSH
37965: LD_VAR 0 2
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL_OW 1
37976: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37977: LD_ADDR_EXP 136
37981: PUSH
37982: LD_EXP 136
37986: PPUSH
37987: LD_VAR 0 2
37991: PPUSH
37992: EMPTY
37993: PPUSH
37994: CALL_OW 1
37998: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37999: LD_ADDR_EXP 137
38003: PUSH
38004: LD_EXP 137
38008: PPUSH
38009: LD_VAR 0 2
38013: PPUSH
38014: EMPTY
38015: PPUSH
38016: CALL_OW 1
38020: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38021: LD_ADDR_EXP 138
38025: PUSH
38026: LD_EXP 138
38030: PPUSH
38031: LD_VAR 0 2
38035: PPUSH
38036: EMPTY
38037: PPUSH
38038: CALL_OW 1
38042: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38043: LD_ADDR_EXP 127
38047: PUSH
38048: LD_EXP 127
38052: PPUSH
38053: LD_VAR 0 2
38057: PPUSH
38058: LD_INT 0
38060: PPUSH
38061: CALL_OW 1
38065: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38066: LD_ADDR_EXP 140
38070: PUSH
38071: LD_EXP 140
38075: PPUSH
38076: LD_VAR 0 2
38080: PPUSH
38081: LD_INT 0
38083: PPUSH
38084: CALL_OW 1
38088: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38089: LD_ADDR_EXP 128
38093: PUSH
38094: LD_EXP 128
38098: PPUSH
38099: LD_VAR 0 2
38103: PPUSH
38104: EMPTY
38105: PPUSH
38106: CALL_OW 1
38110: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38111: LD_ADDR_EXP 139
38115: PUSH
38116: LD_EXP 139
38120: PPUSH
38121: LD_VAR 0 2
38125: PPUSH
38126: LD_INT 0
38128: PPUSH
38129: CALL_OW 1
38133: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38134: LD_ADDR_EXP 141
38138: PUSH
38139: LD_EXP 141
38143: PPUSH
38144: LD_VAR 0 2
38148: PPUSH
38149: EMPTY
38150: PPUSH
38151: CALL_OW 1
38155: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38156: LD_ADDR_EXP 144
38160: PUSH
38161: LD_EXP 144
38165: PPUSH
38166: LD_VAR 0 2
38170: PPUSH
38171: LD_INT 0
38173: PPUSH
38174: CALL_OW 1
38178: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38179: LD_ADDR_EXP 145
38183: PUSH
38184: LD_EXP 145
38188: PPUSH
38189: LD_VAR 0 2
38193: PPUSH
38194: EMPTY
38195: PPUSH
38196: CALL_OW 1
38200: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38201: LD_ADDR_EXP 146
38205: PUSH
38206: LD_EXP 146
38210: PPUSH
38211: LD_VAR 0 2
38215: PPUSH
38216: EMPTY
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38223: LD_ADDR_EXP 147
38227: PUSH
38228: LD_EXP 147
38232: PPUSH
38233: LD_VAR 0 2
38237: PPUSH
38238: EMPTY
38239: PPUSH
38240: CALL_OW 1
38244: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38245: LD_ADDR_EXP 149
38249: PUSH
38250: LD_EXP 149
38254: PPUSH
38255: LD_VAR 0 2
38259: PPUSH
38260: LD_EXP 116
38264: PUSH
38265: LD_VAR 0 2
38269: ARRAY
38270: PPUSH
38271: LD_INT 2
38273: PUSH
38274: LD_INT 30
38276: PUSH
38277: LD_INT 6
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 30
38286: PUSH
38287: LD_INT 7
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 30
38296: PUSH
38297: LD_INT 8
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: PPUSH
38310: CALL_OW 72
38314: PPUSH
38315: CALL_OW 1
38319: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38320: LD_ADDR_EXP 150
38324: PUSH
38325: LD_EXP 150
38329: PPUSH
38330: LD_VAR 0 2
38334: PPUSH
38335: EMPTY
38336: PPUSH
38337: CALL_OW 1
38341: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38342: LD_ADDR_EXP 151
38346: PUSH
38347: LD_EXP 151
38351: PPUSH
38352: LD_VAR 0 2
38356: PPUSH
38357: EMPTY
38358: PPUSH
38359: CALL_OW 1
38363: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38364: LD_ADDR_EXP 152
38368: PUSH
38369: LD_EXP 152
38373: PPUSH
38374: LD_VAR 0 2
38378: PPUSH
38379: EMPTY
38380: PPUSH
38381: CALL_OW 1
38385: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38386: LD_ADDR_EXP 153
38390: PUSH
38391: LD_EXP 153
38395: PPUSH
38396: LD_VAR 0 2
38400: PPUSH
38401: EMPTY
38402: PPUSH
38403: CALL_OW 1
38407: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38408: LD_ADDR_EXP 154
38412: PUSH
38413: LD_EXP 154
38417: PPUSH
38418: LD_VAR 0 2
38422: PPUSH
38423: EMPTY
38424: PPUSH
38425: CALL_OW 1
38429: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38430: LD_ADDR_EXP 155
38434: PUSH
38435: LD_EXP 155
38439: PPUSH
38440: LD_VAR 0 2
38444: PPUSH
38445: EMPTY
38446: PPUSH
38447: CALL_OW 1
38451: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38452: LD_ADDR_EXP 156
38456: PUSH
38457: LD_EXP 156
38461: PPUSH
38462: LD_VAR 0 2
38466: PPUSH
38467: EMPTY
38468: PPUSH
38469: CALL_OW 1
38473: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38474: LD_ADDR_EXP 157
38478: PUSH
38479: LD_EXP 157
38483: PPUSH
38484: LD_VAR 0 2
38488: PPUSH
38489: EMPTY
38490: PPUSH
38491: CALL_OW 1
38495: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38496: LD_ADDR_EXP 158
38500: PUSH
38501: LD_EXP 158
38505: PPUSH
38506: LD_VAR 0 2
38510: PPUSH
38511: LD_INT 0
38513: PPUSH
38514: CALL_OW 1
38518: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38519: LD_ADDR_EXP 159
38523: PUSH
38524: LD_EXP 159
38528: PPUSH
38529: LD_VAR 0 2
38533: PPUSH
38534: LD_INT 0
38536: PPUSH
38537: CALL_OW 1
38541: ST_TO_ADDR
// end ;
38542: GO 37443
38544: POP
38545: POP
// MC_InitSides ( ) ;
38546: CALL 38832 0 0
// MC_InitResearch ( ) ;
38550: CALL 38571 0 0
// CustomInitMacro ( ) ;
38554: CALL 471 0 0
// skirmish := true ;
38558: LD_ADDR_EXP 114
38562: PUSH
38563: LD_INT 1
38565: ST_TO_ADDR
// end ;
38566: LD_VAR 0 1
38570: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38571: LD_INT 0
38573: PPUSH
38574: PPUSH
38575: PPUSH
38576: PPUSH
38577: PPUSH
38578: PPUSH
// if not mc_bases then
38579: LD_EXP 116
38583: NOT
38584: IFFALSE 38588
// exit ;
38586: GO 38827
// for i = 1 to 8 do
38588: LD_ADDR_VAR 0 2
38592: PUSH
38593: DOUBLE
38594: LD_INT 1
38596: DEC
38597: ST_TO_ADDR
38598: LD_INT 8
38600: PUSH
38601: FOR_TO
38602: IFFALSE 38628
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38604: LD_ADDR_EXP 143
38608: PUSH
38609: LD_EXP 143
38613: PPUSH
38614: LD_VAR 0 2
38618: PPUSH
38619: EMPTY
38620: PPUSH
38621: CALL_OW 1
38625: ST_TO_ADDR
38626: GO 38601
38628: POP
38629: POP
// tmp := [ ] ;
38630: LD_ADDR_VAR 0 5
38634: PUSH
38635: EMPTY
38636: ST_TO_ADDR
// for i = 1 to mc_sides do
38637: LD_ADDR_VAR 0 2
38641: PUSH
38642: DOUBLE
38643: LD_INT 1
38645: DEC
38646: ST_TO_ADDR
38647: LD_EXP 142
38651: PUSH
38652: FOR_TO
38653: IFFALSE 38711
// if not mc_sides [ i ] in tmp then
38655: LD_EXP 142
38659: PUSH
38660: LD_VAR 0 2
38664: ARRAY
38665: PUSH
38666: LD_VAR 0 5
38670: IN
38671: NOT
38672: IFFALSE 38709
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38674: LD_ADDR_VAR 0 5
38678: PUSH
38679: LD_VAR 0 5
38683: PPUSH
38684: LD_VAR 0 5
38688: PUSH
38689: LD_INT 1
38691: PLUS
38692: PPUSH
38693: LD_EXP 142
38697: PUSH
38698: LD_VAR 0 2
38702: ARRAY
38703: PPUSH
38704: CALL_OW 2
38708: ST_TO_ADDR
38709: GO 38652
38711: POP
38712: POP
// if not tmp then
38713: LD_VAR 0 5
38717: NOT
38718: IFFALSE 38722
// exit ;
38720: GO 38827
// for j in tmp do
38722: LD_ADDR_VAR 0 3
38726: PUSH
38727: LD_VAR 0 5
38731: PUSH
38732: FOR_IN
38733: IFFALSE 38825
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38735: LD_ADDR_VAR 0 6
38739: PUSH
38740: LD_INT 22
38742: PUSH
38743: LD_VAR 0 3
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PPUSH
38752: CALL_OW 69
38756: ST_TO_ADDR
// if not un then
38757: LD_VAR 0 6
38761: NOT
38762: IFFALSE 38766
// continue ;
38764: GO 38732
// nation := GetNation ( un [ 1 ] ) ;
38766: LD_ADDR_VAR 0 4
38770: PUSH
38771: LD_VAR 0 6
38775: PUSH
38776: LD_INT 1
38778: ARRAY
38779: PPUSH
38780: CALL_OW 248
38784: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38785: LD_ADDR_EXP 143
38789: PUSH
38790: LD_EXP 143
38794: PPUSH
38795: LD_VAR 0 3
38799: PPUSH
38800: LD_VAR 0 3
38804: PPUSH
38805: LD_VAR 0 4
38809: PPUSH
38810: LD_INT 1
38812: PPUSH
38813: CALL 65948 0 3
38817: PPUSH
38818: CALL_OW 1
38822: ST_TO_ADDR
// end ;
38823: GO 38732
38825: POP
38826: POP
// end ;
38827: LD_VAR 0 1
38831: RET
// export function MC_InitSides ( ) ; var i ; begin
38832: LD_INT 0
38834: PPUSH
38835: PPUSH
// if not mc_bases then
38836: LD_EXP 116
38840: NOT
38841: IFFALSE 38845
// exit ;
38843: GO 38919
// for i = 1 to mc_bases do
38845: LD_ADDR_VAR 0 2
38849: PUSH
38850: DOUBLE
38851: LD_INT 1
38853: DEC
38854: ST_TO_ADDR
38855: LD_EXP 116
38859: PUSH
38860: FOR_TO
38861: IFFALSE 38917
// if mc_bases [ i ] then
38863: LD_EXP 116
38867: PUSH
38868: LD_VAR 0 2
38872: ARRAY
38873: IFFALSE 38915
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38875: LD_ADDR_EXP 142
38879: PUSH
38880: LD_EXP 142
38884: PPUSH
38885: LD_VAR 0 2
38889: PPUSH
38890: LD_EXP 116
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: PPUSH
38905: CALL_OW 255
38909: PPUSH
38910: CALL_OW 1
38914: ST_TO_ADDR
38915: GO 38860
38917: POP
38918: POP
// end ;
38919: LD_VAR 0 1
38923: RET
// every 0 0$03 trigger skirmish do
38924: LD_EXP 114
38928: IFFALSE 39082
38930: GO 38932
38932: DISABLE
// begin enable ;
38933: ENABLE
// MC_CheckBuildings ( ) ;
38934: CALL 43580 0 0
// MC_CheckPeopleLife ( ) ;
38938: CALL 43741 0 0
// RaiseSailEvent ( 100 ) ;
38942: LD_INT 100
38944: PPUSH
38945: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38949: LD_INT 103
38951: PPUSH
38952: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38956: LD_INT 104
38958: PPUSH
38959: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38963: LD_INT 105
38965: PPUSH
38966: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38970: LD_INT 106
38972: PPUSH
38973: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38977: LD_INT 107
38979: PPUSH
38980: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38984: LD_INT 108
38986: PPUSH
38987: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38991: LD_INT 109
38993: PPUSH
38994: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38998: LD_INT 110
39000: PPUSH
39001: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
39005: LD_INT 111
39007: PPUSH
39008: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39012: LD_INT 112
39014: PPUSH
39015: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39019: LD_INT 113
39021: PPUSH
39022: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39026: LD_INT 120
39028: PPUSH
39029: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39033: LD_INT 121
39035: PPUSH
39036: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39040: LD_INT 122
39042: PPUSH
39043: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39047: LD_INT 123
39049: PPUSH
39050: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39054: LD_INT 124
39056: PPUSH
39057: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39061: LD_INT 125
39063: PPUSH
39064: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39068: LD_INT 126
39070: PPUSH
39071: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39075: LD_INT 200
39077: PPUSH
39078: CALL_OW 427
// end ;
39082: END
// on SailEvent ( event ) do begin if event < 100 then
39083: LD_VAR 0 1
39087: PUSH
39088: LD_INT 100
39090: LESS
39091: IFFALSE 39102
// CustomEvent ( event ) ;
39093: LD_VAR 0 1
39097: PPUSH
39098: CALL 33558 0 1
// if event = 100 then
39102: LD_VAR 0 1
39106: PUSH
39107: LD_INT 100
39109: EQUAL
39110: IFFALSE 39116
// MC_ClassManager ( ) ;
39112: CALL 39508 0 0
// if event = 101 then
39116: LD_VAR 0 1
39120: PUSH
39121: LD_INT 101
39123: EQUAL
39124: IFFALSE 39130
// MC_RepairBuildings ( ) ;
39126: CALL 44326 0 0
// if event = 102 then
39130: LD_VAR 0 1
39134: PUSH
39135: LD_INT 102
39137: EQUAL
39138: IFFALSE 39144
// MC_Heal ( ) ;
39140: CALL 45233 0 0
// if event = 103 then
39144: LD_VAR 0 1
39148: PUSH
39149: LD_INT 103
39151: EQUAL
39152: IFFALSE 39158
// MC_Build ( ) ;
39154: CALL 45655 0 0
// if event = 104 then
39158: LD_VAR 0 1
39162: PUSH
39163: LD_INT 104
39165: EQUAL
39166: IFFALSE 39172
// MC_TurretWeapon ( ) ;
39168: CALL 47296 0 0
// if event = 105 then
39172: LD_VAR 0 1
39176: PUSH
39177: LD_INT 105
39179: EQUAL
39180: IFFALSE 39186
// MC_BuildUpgrade ( ) ;
39182: CALL 46847 0 0
// if event = 106 then
39186: LD_VAR 0 1
39190: PUSH
39191: LD_INT 106
39193: EQUAL
39194: IFFALSE 39200
// MC_PlantMines ( ) ;
39196: CALL 47726 0 0
// if event = 107 then
39200: LD_VAR 0 1
39204: PUSH
39205: LD_INT 107
39207: EQUAL
39208: IFFALSE 39214
// MC_CollectCrates ( ) ;
39210: CALL 48517 0 0
// if event = 108 then
39214: LD_VAR 0 1
39218: PUSH
39219: LD_INT 108
39221: EQUAL
39222: IFFALSE 39228
// MC_LinkRemoteControl ( ) ;
39224: CALL 50367 0 0
// if event = 109 then
39228: LD_VAR 0 1
39232: PUSH
39233: LD_INT 109
39235: EQUAL
39236: IFFALSE 39242
// MC_ProduceVehicle ( ) ;
39238: CALL 50548 0 0
// if event = 110 then
39242: LD_VAR 0 1
39246: PUSH
39247: LD_INT 110
39249: EQUAL
39250: IFFALSE 39256
// MC_SendAttack ( ) ;
39252: CALL 51014 0 0
// if event = 111 then
39256: LD_VAR 0 1
39260: PUSH
39261: LD_INT 111
39263: EQUAL
39264: IFFALSE 39270
// MC_Defend ( ) ;
39266: CALL 51122 0 0
// if event = 112 then
39270: LD_VAR 0 1
39274: PUSH
39275: LD_INT 112
39277: EQUAL
39278: IFFALSE 39284
// MC_Research ( ) ;
39280: CALL 52002 0 0
// if event = 113 then
39284: LD_VAR 0 1
39288: PUSH
39289: LD_INT 113
39291: EQUAL
39292: IFFALSE 39298
// MC_MinesTrigger ( ) ;
39294: CALL 53116 0 0
// if event = 120 then
39298: LD_VAR 0 1
39302: PUSH
39303: LD_INT 120
39305: EQUAL
39306: IFFALSE 39312
// MC_RepairVehicle ( ) ;
39308: CALL 53215 0 0
// if event = 121 then
39312: LD_VAR 0 1
39316: PUSH
39317: LD_INT 121
39319: EQUAL
39320: IFFALSE 39326
// MC_TameApe ( ) ;
39322: CALL 53956 0 0
// if event = 122 then
39326: LD_VAR 0 1
39330: PUSH
39331: LD_INT 122
39333: EQUAL
39334: IFFALSE 39340
// MC_ChangeApeClass ( ) ;
39336: CALL 54785 0 0
// if event = 123 then
39340: LD_VAR 0 1
39344: PUSH
39345: LD_INT 123
39347: EQUAL
39348: IFFALSE 39354
// MC_Bazooka ( ) ;
39350: CALL 55435 0 0
// if event = 124 then
39354: LD_VAR 0 1
39358: PUSH
39359: LD_INT 124
39361: EQUAL
39362: IFFALSE 39368
// MC_TeleportExit ( ) ;
39364: CALL 55633 0 0
// if event = 125 then
39368: LD_VAR 0 1
39372: PUSH
39373: LD_INT 125
39375: EQUAL
39376: IFFALSE 39382
// MC_Deposits ( ) ;
39378: CALL 56280 0 0
// if event = 126 then
39382: LD_VAR 0 1
39386: PUSH
39387: LD_INT 126
39389: EQUAL
39390: IFFALSE 39396
// MC_RemoteDriver ( ) ;
39392: CALL 56905 0 0
// if event = 200 then
39396: LD_VAR 0 1
39400: PUSH
39401: LD_INT 200
39403: EQUAL
39404: IFFALSE 39410
// MC_Idle ( ) ;
39406: CALL 58854 0 0
// end ;
39410: PPOPN 1
39412: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39413: LD_INT 0
39415: PPUSH
39416: PPUSH
// if not mc_bases [ base ] or not tag then
39417: LD_EXP 116
39421: PUSH
39422: LD_VAR 0 1
39426: ARRAY
39427: NOT
39428: PUSH
39429: LD_VAR 0 2
39433: NOT
39434: OR
39435: IFFALSE 39439
// exit ;
39437: GO 39503
// for i in mc_bases [ base ] union mc_ape [ base ] do
39439: LD_ADDR_VAR 0 4
39443: PUSH
39444: LD_EXP 116
39448: PUSH
39449: LD_VAR 0 1
39453: ARRAY
39454: PUSH
39455: LD_EXP 145
39459: PUSH
39460: LD_VAR 0 1
39464: ARRAY
39465: UNION
39466: PUSH
39467: FOR_IN
39468: IFFALSE 39501
// if GetTag ( i ) = tag then
39470: LD_VAR 0 4
39474: PPUSH
39475: CALL_OW 110
39479: PUSH
39480: LD_VAR 0 2
39484: EQUAL
39485: IFFALSE 39499
// SetTag ( i , 0 ) ;
39487: LD_VAR 0 4
39491: PPUSH
39492: LD_INT 0
39494: PPUSH
39495: CALL_OW 109
39499: GO 39467
39501: POP
39502: POP
// end ;
39503: LD_VAR 0 3
39507: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39508: LD_INT 0
39510: PPUSH
39511: PPUSH
39512: PPUSH
39513: PPUSH
39514: PPUSH
39515: PPUSH
39516: PPUSH
39517: PPUSH
// if not mc_bases then
39518: LD_EXP 116
39522: NOT
39523: IFFALSE 39527
// exit ;
39525: GO 39985
// for i = 1 to mc_bases do
39527: LD_ADDR_VAR 0 2
39531: PUSH
39532: DOUBLE
39533: LD_INT 1
39535: DEC
39536: ST_TO_ADDR
39537: LD_EXP 116
39541: PUSH
39542: FOR_TO
39543: IFFALSE 39983
// begin tmp := MC_ClassCheckReq ( i ) ;
39545: LD_ADDR_VAR 0 4
39549: PUSH
39550: LD_VAR 0 2
39554: PPUSH
39555: CALL 39990 0 1
39559: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39560: LD_ADDR_EXP 157
39564: PUSH
39565: LD_EXP 157
39569: PPUSH
39570: LD_VAR 0 2
39574: PPUSH
39575: LD_VAR 0 4
39579: PPUSH
39580: CALL_OW 1
39584: ST_TO_ADDR
// if not tmp then
39585: LD_VAR 0 4
39589: NOT
39590: IFFALSE 39594
// continue ;
39592: GO 39542
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39594: LD_ADDR_VAR 0 6
39598: PUSH
39599: LD_EXP 116
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: PPUSH
39610: LD_INT 2
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 4
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 30
39625: PUSH
39626: LD_INT 5
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: LIST
39637: PPUSH
39638: CALL_OW 72
39642: PUSH
39643: LD_EXP 116
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PPUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 30
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: LIST
39681: PPUSH
39682: CALL_OW 72
39686: PUSH
39687: LD_EXP 116
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: PPUSH
39698: LD_INT 30
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PPUSH
39708: CALL_OW 72
39712: PUSH
39713: LD_EXP 116
39717: PUSH
39718: LD_VAR 0 2
39722: ARRAY
39723: PPUSH
39724: LD_INT 2
39726: PUSH
39727: LD_INT 30
39729: PUSH
39730: LD_INT 6
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 30
39739: PUSH
39740: LD_INT 7
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 30
39749: PUSH
39750: LD_INT 8
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: LIST
39761: LIST
39762: PPUSH
39763: CALL_OW 72
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: ST_TO_ADDR
// for j = 1 to 4 do
39774: LD_ADDR_VAR 0 3
39778: PUSH
39779: DOUBLE
39780: LD_INT 1
39782: DEC
39783: ST_TO_ADDR
39784: LD_INT 4
39786: PUSH
39787: FOR_TO
39788: IFFALSE 39979
// begin if not tmp [ j ] then
39790: LD_VAR 0 4
39794: PUSH
39795: LD_VAR 0 3
39799: ARRAY
39800: NOT
39801: IFFALSE 39805
// continue ;
39803: GO 39787
// for p in tmp [ j ] do
39805: LD_ADDR_VAR 0 5
39809: PUSH
39810: LD_VAR 0 4
39814: PUSH
39815: LD_VAR 0 3
39819: ARRAY
39820: PUSH
39821: FOR_IN
39822: IFFALSE 39975
// begin if not b [ j ] then
39824: LD_VAR 0 6
39828: PUSH
39829: LD_VAR 0 3
39833: ARRAY
39834: NOT
39835: IFFALSE 39839
// break ;
39837: GO 39975
// e := 0 ;
39839: LD_ADDR_VAR 0 7
39843: PUSH
39844: LD_INT 0
39846: ST_TO_ADDR
// for k in b [ j ] do
39847: LD_ADDR_VAR 0 8
39851: PUSH
39852: LD_VAR 0 6
39856: PUSH
39857: LD_VAR 0 3
39861: ARRAY
39862: PUSH
39863: FOR_IN
39864: IFFALSE 39891
// if IsNotFull ( k ) then
39866: LD_VAR 0 8
39870: PPUSH
39871: CALL 68101 0 1
39875: IFFALSE 39889
// begin e := k ;
39877: LD_ADDR_VAR 0 7
39881: PUSH
39882: LD_VAR 0 8
39886: ST_TO_ADDR
// break ;
39887: GO 39891
// end ;
39889: GO 39863
39891: POP
39892: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39893: LD_VAR 0 7
39897: PUSH
39898: LD_VAR 0 5
39902: PPUSH
39903: LD_VAR 0 7
39907: PPUSH
39908: CALL 101265 0 2
39912: NOT
39913: AND
39914: IFFALSE 39973
// begin if IsInUnit ( p ) then
39916: LD_VAR 0 5
39920: PPUSH
39921: CALL_OW 310
39925: IFFALSE 39936
// ComExitBuilding ( p ) ;
39927: LD_VAR 0 5
39931: PPUSH
39932: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39936: LD_VAR 0 5
39940: PPUSH
39941: LD_VAR 0 7
39945: PPUSH
39946: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39950: LD_VAR 0 5
39954: PPUSH
39955: LD_VAR 0 3
39959: PPUSH
39960: CALL_OW 183
// AddComExitBuilding ( p ) ;
39964: LD_VAR 0 5
39968: PPUSH
39969: CALL_OW 182
// end ; end ;
39973: GO 39821
39975: POP
39976: POP
// end ;
39977: GO 39787
39979: POP
39980: POP
// end ;
39981: GO 39542
39983: POP
39984: POP
// end ;
39985: LD_VAR 0 1
39989: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39990: LD_INT 0
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
39997: PPUSH
39998: PPUSH
39999: PPUSH
40000: PPUSH
40001: PPUSH
40002: PPUSH
40003: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40004: LD_VAR 0 1
40008: NOT
40009: PUSH
40010: LD_EXP 116
40014: PUSH
40015: LD_VAR 0 1
40019: ARRAY
40020: NOT
40021: OR
40022: PUSH
40023: LD_EXP 116
40027: PUSH
40028: LD_VAR 0 1
40032: ARRAY
40033: PPUSH
40034: LD_INT 2
40036: PUSH
40037: LD_INT 30
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 30
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: LIST
40061: PPUSH
40062: CALL_OW 72
40066: NOT
40067: OR
40068: IFFALSE 40072
// exit ;
40070: GO 43575
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40072: LD_ADDR_VAR 0 4
40076: PUSH
40077: LD_EXP 116
40081: PUSH
40082: LD_VAR 0 1
40086: ARRAY
40087: PPUSH
40088: LD_INT 2
40090: PUSH
40091: LD_INT 25
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 25
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 25
40113: PUSH
40114: LD_INT 3
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 25
40123: PUSH
40124: LD_INT 4
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 25
40133: PUSH
40134: LD_INT 5
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 8
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 25
40153: PUSH
40154: LD_INT 9
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: PPUSH
40171: CALL_OW 72
40175: ST_TO_ADDR
// if not tmp then
40176: LD_VAR 0 4
40180: NOT
40181: IFFALSE 40185
// exit ;
40183: GO 43575
// for i in tmp do
40185: LD_ADDR_VAR 0 3
40189: PUSH
40190: LD_VAR 0 4
40194: PUSH
40195: FOR_IN
40196: IFFALSE 40227
// if GetTag ( i ) then
40198: LD_VAR 0 3
40202: PPUSH
40203: CALL_OW 110
40207: IFFALSE 40225
// tmp := tmp diff i ;
40209: LD_ADDR_VAR 0 4
40213: PUSH
40214: LD_VAR 0 4
40218: PUSH
40219: LD_VAR 0 3
40223: DIFF
40224: ST_TO_ADDR
40225: GO 40195
40227: POP
40228: POP
// if not tmp then
40229: LD_VAR 0 4
40233: NOT
40234: IFFALSE 40238
// exit ;
40236: GO 43575
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40238: LD_ADDR_VAR 0 5
40242: PUSH
40243: LD_EXP 116
40247: PUSH
40248: LD_VAR 0 1
40252: ARRAY
40253: PPUSH
40254: LD_INT 2
40256: PUSH
40257: LD_INT 25
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 25
40269: PUSH
40270: LD_INT 5
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 25
40279: PUSH
40280: LD_INT 8
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 25
40289: PUSH
40290: LD_INT 9
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: PPUSH
40304: CALL_OW 72
40308: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40309: LD_ADDR_VAR 0 6
40313: PUSH
40314: LD_EXP 116
40318: PUSH
40319: LD_VAR 0 1
40323: ARRAY
40324: PPUSH
40325: LD_INT 25
40327: PUSH
40328: LD_INT 2
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PPUSH
40335: CALL_OW 72
40339: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40340: LD_ADDR_VAR 0 7
40344: PUSH
40345: LD_EXP 116
40349: PUSH
40350: LD_VAR 0 1
40354: ARRAY
40355: PPUSH
40356: LD_INT 25
40358: PUSH
40359: LD_INT 3
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PPUSH
40366: CALL_OW 72
40370: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40371: LD_ADDR_VAR 0 8
40375: PUSH
40376: LD_EXP 116
40380: PUSH
40381: LD_VAR 0 1
40385: ARRAY
40386: PPUSH
40387: LD_INT 25
40389: PUSH
40390: LD_INT 4
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 24
40399: PUSH
40400: LD_INT 251
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: ST_TO_ADDR
// if mc_is_defending [ base ] then
40416: LD_EXP 159
40420: PUSH
40421: LD_VAR 0 1
40425: ARRAY
40426: IFFALSE 40887
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40428: LD_ADDR_EXP 158
40432: PUSH
40433: LD_EXP 158
40437: PPUSH
40438: LD_VAR 0 1
40442: PPUSH
40443: LD_INT 4
40445: PPUSH
40446: CALL_OW 1
40450: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40451: LD_ADDR_VAR 0 12
40455: PUSH
40456: LD_EXP 116
40460: PUSH
40461: LD_VAR 0 1
40465: ARRAY
40466: PPUSH
40467: LD_INT 2
40469: PUSH
40470: LD_INT 30
40472: PUSH
40473: LD_INT 4
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 30
40482: PUSH
40483: LD_INT 5
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: LIST
40494: PPUSH
40495: CALL_OW 72
40499: ST_TO_ADDR
// if not b then
40500: LD_VAR 0 12
40504: NOT
40505: IFFALSE 40509
// exit ;
40507: GO 43575
// p := [ ] ;
40509: LD_ADDR_VAR 0 11
40513: PUSH
40514: EMPTY
40515: ST_TO_ADDR
// if sci >= 2 then
40516: LD_VAR 0 8
40520: PUSH
40521: LD_INT 2
40523: GREATEREQUAL
40524: IFFALSE 40555
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40526: LD_ADDR_VAR 0 8
40530: PUSH
40531: LD_VAR 0 8
40535: PUSH
40536: LD_INT 1
40538: ARRAY
40539: PUSH
40540: LD_VAR 0 8
40544: PUSH
40545: LD_INT 2
40547: ARRAY
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: ST_TO_ADDR
40553: GO 40616
// if sci = 1 then
40555: LD_VAR 0 8
40559: PUSH
40560: LD_INT 1
40562: EQUAL
40563: IFFALSE 40584
// sci := [ sci [ 1 ] ] else
40565: LD_ADDR_VAR 0 8
40569: PUSH
40570: LD_VAR 0 8
40574: PUSH
40575: LD_INT 1
40577: ARRAY
40578: PUSH
40579: EMPTY
40580: LIST
40581: ST_TO_ADDR
40582: GO 40616
// if sci = 0 then
40584: LD_VAR 0 8
40588: PUSH
40589: LD_INT 0
40591: EQUAL
40592: IFFALSE 40616
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40594: LD_ADDR_VAR 0 11
40598: PUSH
40599: LD_VAR 0 4
40603: PPUSH
40604: LD_INT 4
40606: PPUSH
40607: CALL 101128 0 2
40611: PUSH
40612: LD_INT 1
40614: ARRAY
40615: ST_TO_ADDR
// if eng > 4 then
40616: LD_VAR 0 6
40620: PUSH
40621: LD_INT 4
40623: GREATER
40624: IFFALSE 40670
// for i = eng downto 4 do
40626: LD_ADDR_VAR 0 3
40630: PUSH
40631: DOUBLE
40632: LD_VAR 0 6
40636: INC
40637: ST_TO_ADDR
40638: LD_INT 4
40640: PUSH
40641: FOR_DOWNTO
40642: IFFALSE 40668
// eng := eng diff eng [ i ] ;
40644: LD_ADDR_VAR 0 6
40648: PUSH
40649: LD_VAR 0 6
40653: PUSH
40654: LD_VAR 0 6
40658: PUSH
40659: LD_VAR 0 3
40663: ARRAY
40664: DIFF
40665: ST_TO_ADDR
40666: GO 40641
40668: POP
40669: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40670: LD_ADDR_VAR 0 4
40674: PUSH
40675: LD_VAR 0 4
40679: PUSH
40680: LD_VAR 0 5
40684: PUSH
40685: LD_VAR 0 6
40689: UNION
40690: PUSH
40691: LD_VAR 0 7
40695: UNION
40696: PUSH
40697: LD_VAR 0 8
40701: UNION
40702: DIFF
40703: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40704: LD_ADDR_VAR 0 13
40708: PUSH
40709: LD_EXP 116
40713: PUSH
40714: LD_VAR 0 1
40718: ARRAY
40719: PPUSH
40720: LD_INT 2
40722: PUSH
40723: LD_INT 30
40725: PUSH
40726: LD_INT 32
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: LD_INT 30
40735: PUSH
40736: LD_INT 31
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: LIST
40747: PPUSH
40748: CALL_OW 72
40752: PUSH
40753: LD_EXP 116
40757: PUSH
40758: LD_VAR 0 1
40762: ARRAY
40763: PPUSH
40764: LD_INT 2
40766: PUSH
40767: LD_INT 30
40769: PUSH
40770: LD_INT 4
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 30
40779: PUSH
40780: LD_INT 5
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: LIST
40791: PPUSH
40792: CALL_OW 72
40796: PUSH
40797: LD_INT 6
40799: MUL
40800: PLUS
40801: ST_TO_ADDR
// if bcount < tmp then
40802: LD_VAR 0 13
40806: PUSH
40807: LD_VAR 0 4
40811: LESS
40812: IFFALSE 40858
// for i = tmp downto bcount do
40814: LD_ADDR_VAR 0 3
40818: PUSH
40819: DOUBLE
40820: LD_VAR 0 4
40824: INC
40825: ST_TO_ADDR
40826: LD_VAR 0 13
40830: PUSH
40831: FOR_DOWNTO
40832: IFFALSE 40856
// tmp := Delete ( tmp , tmp ) ;
40834: LD_ADDR_VAR 0 4
40838: PUSH
40839: LD_VAR 0 4
40843: PPUSH
40844: LD_VAR 0 4
40848: PPUSH
40849: CALL_OW 3
40853: ST_TO_ADDR
40854: GO 40831
40856: POP
40857: POP
// result := [ tmp , 0 , 0 , p ] ;
40858: LD_ADDR_VAR 0 2
40862: PUSH
40863: LD_VAR 0 4
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: LD_VAR 0 11
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: ST_TO_ADDR
// exit ;
40885: GO 43575
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40887: LD_EXP 116
40891: PUSH
40892: LD_VAR 0 1
40896: ARRAY
40897: PPUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 30
40903: PUSH
40904: LD_INT 6
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 30
40913: PUSH
40914: LD_INT 7
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 30
40923: PUSH
40924: LD_INT 8
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: PPUSH
40937: CALL_OW 72
40941: NOT
40942: PUSH
40943: LD_EXP 116
40947: PUSH
40948: LD_VAR 0 1
40952: ARRAY
40953: PPUSH
40954: LD_INT 30
40956: PUSH
40957: LD_INT 3
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PPUSH
40964: CALL_OW 72
40968: NOT
40969: AND
40970: IFFALSE 41042
// begin if eng = tmp then
40972: LD_VAR 0 6
40976: PUSH
40977: LD_VAR 0 4
40981: EQUAL
40982: IFFALSE 40986
// exit ;
40984: GO 43575
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40986: LD_ADDR_EXP 158
40990: PUSH
40991: LD_EXP 158
40995: PPUSH
40996: LD_VAR 0 1
41000: PPUSH
41001: LD_INT 1
41003: PPUSH
41004: CALL_OW 1
41008: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41009: LD_ADDR_VAR 0 2
41013: PUSH
41014: LD_INT 0
41016: PUSH
41017: LD_VAR 0 4
41021: PUSH
41022: LD_VAR 0 6
41026: DIFF
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: ST_TO_ADDR
// exit ;
41040: GO 43575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41042: LD_EXP 143
41046: PUSH
41047: LD_EXP 142
41051: PUSH
41052: LD_VAR 0 1
41056: ARRAY
41057: ARRAY
41058: PUSH
41059: LD_EXP 116
41063: PUSH
41064: LD_VAR 0 1
41068: ARRAY
41069: PPUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 30
41075: PUSH
41076: LD_INT 6
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 30
41085: PUSH
41086: LD_INT 7
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 30
41095: PUSH
41096: LD_INT 8
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: PPUSH
41109: CALL_OW 72
41113: AND
41114: PUSH
41115: LD_EXP 116
41119: PUSH
41120: LD_VAR 0 1
41124: ARRAY
41125: PPUSH
41126: LD_INT 30
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PPUSH
41136: CALL_OW 72
41140: NOT
41141: AND
41142: IFFALSE 41356
// begin if sci >= 6 then
41144: LD_VAR 0 8
41148: PUSH
41149: LD_INT 6
41151: GREATEREQUAL
41152: IFFALSE 41156
// exit ;
41154: GO 43575
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41156: LD_ADDR_EXP 158
41160: PUSH
41161: LD_EXP 158
41165: PPUSH
41166: LD_VAR 0 1
41170: PPUSH
41171: LD_INT 2
41173: PPUSH
41174: CALL_OW 1
41178: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41179: LD_ADDR_VAR 0 9
41183: PUSH
41184: LD_VAR 0 4
41188: PUSH
41189: LD_VAR 0 8
41193: DIFF
41194: PPUSH
41195: LD_INT 4
41197: PPUSH
41198: CALL 101128 0 2
41202: ST_TO_ADDR
// p := [ ] ;
41203: LD_ADDR_VAR 0 11
41207: PUSH
41208: EMPTY
41209: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41210: LD_VAR 0 8
41214: PUSH
41215: LD_INT 6
41217: LESS
41218: PUSH
41219: LD_VAR 0 9
41223: PUSH
41224: LD_INT 6
41226: GREATER
41227: AND
41228: IFFALSE 41309
// begin for i = 1 to 6 - sci do
41230: LD_ADDR_VAR 0 3
41234: PUSH
41235: DOUBLE
41236: LD_INT 1
41238: DEC
41239: ST_TO_ADDR
41240: LD_INT 6
41242: PUSH
41243: LD_VAR 0 8
41247: MINUS
41248: PUSH
41249: FOR_TO
41250: IFFALSE 41305
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41252: LD_ADDR_VAR 0 11
41256: PUSH
41257: LD_VAR 0 11
41261: PPUSH
41262: LD_VAR 0 11
41266: PUSH
41267: LD_INT 1
41269: PLUS
41270: PPUSH
41271: LD_VAR 0 9
41275: PUSH
41276: LD_INT 1
41278: ARRAY
41279: PPUSH
41280: CALL_OW 2
41284: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41285: LD_ADDR_VAR 0 9
41289: PUSH
41290: LD_VAR 0 9
41294: PPUSH
41295: LD_INT 1
41297: PPUSH
41298: CALL_OW 3
41302: ST_TO_ADDR
// end ;
41303: GO 41249
41305: POP
41306: POP
// end else
41307: GO 41329
// if sort then
41309: LD_VAR 0 9
41313: IFFALSE 41329
// p := sort [ 1 ] ;
41315: LD_ADDR_VAR 0 11
41319: PUSH
41320: LD_VAR 0 9
41324: PUSH
41325: LD_INT 1
41327: ARRAY
41328: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41329: LD_ADDR_VAR 0 2
41333: PUSH
41334: LD_INT 0
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_VAR 0 11
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: LIST
41352: LIST
41353: ST_TO_ADDR
// exit ;
41354: GO 43575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41356: LD_EXP 143
41360: PUSH
41361: LD_EXP 142
41365: PUSH
41366: LD_VAR 0 1
41370: ARRAY
41371: ARRAY
41372: PUSH
41373: LD_EXP 116
41377: PUSH
41378: LD_VAR 0 1
41382: ARRAY
41383: PPUSH
41384: LD_INT 2
41386: PUSH
41387: LD_INT 30
41389: PUSH
41390: LD_INT 6
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 7
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 8
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: PPUSH
41423: CALL_OW 72
41427: AND
41428: PUSH
41429: LD_EXP 116
41433: PUSH
41434: LD_VAR 0 1
41438: ARRAY
41439: PPUSH
41440: LD_INT 30
41442: PUSH
41443: LD_INT 3
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PPUSH
41450: CALL_OW 72
41454: AND
41455: IFFALSE 42189
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41457: LD_ADDR_EXP 158
41461: PUSH
41462: LD_EXP 158
41466: PPUSH
41467: LD_VAR 0 1
41471: PPUSH
41472: LD_INT 3
41474: PPUSH
41475: CALL_OW 1
41479: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41480: LD_ADDR_VAR 0 2
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: LD_INT 0
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// if not eng then
41503: LD_VAR 0 6
41507: NOT
41508: IFFALSE 41571
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41510: LD_ADDR_VAR 0 11
41514: PUSH
41515: LD_VAR 0 4
41519: PPUSH
41520: LD_INT 2
41522: PPUSH
41523: CALL 101128 0 2
41527: PUSH
41528: LD_INT 1
41530: ARRAY
41531: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41532: LD_ADDR_VAR 0 2
41536: PUSH
41537: LD_VAR 0 2
41541: PPUSH
41542: LD_INT 2
41544: PPUSH
41545: LD_VAR 0 11
41549: PPUSH
41550: CALL_OW 1
41554: ST_TO_ADDR
// tmp := tmp diff p ;
41555: LD_ADDR_VAR 0 4
41559: PUSH
41560: LD_VAR 0 4
41564: PUSH
41565: LD_VAR 0 11
41569: DIFF
41570: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41571: LD_VAR 0 4
41575: PUSH
41576: LD_VAR 0 8
41580: PUSH
41581: LD_INT 6
41583: LESS
41584: AND
41585: IFFALSE 41773
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41587: LD_ADDR_VAR 0 9
41591: PUSH
41592: LD_VAR 0 4
41596: PUSH
41597: LD_VAR 0 8
41601: PUSH
41602: LD_VAR 0 7
41606: UNION
41607: DIFF
41608: PPUSH
41609: LD_INT 4
41611: PPUSH
41612: CALL 101128 0 2
41616: ST_TO_ADDR
// p := [ ] ;
41617: LD_ADDR_VAR 0 11
41621: PUSH
41622: EMPTY
41623: ST_TO_ADDR
// if sort then
41624: LD_VAR 0 9
41628: IFFALSE 41744
// for i = 1 to 6 - sci do
41630: LD_ADDR_VAR 0 3
41634: PUSH
41635: DOUBLE
41636: LD_INT 1
41638: DEC
41639: ST_TO_ADDR
41640: LD_INT 6
41642: PUSH
41643: LD_VAR 0 8
41647: MINUS
41648: PUSH
41649: FOR_TO
41650: IFFALSE 41742
// begin if i = sort then
41652: LD_VAR 0 3
41656: PUSH
41657: LD_VAR 0 9
41661: EQUAL
41662: IFFALSE 41666
// break ;
41664: GO 41742
// if GetClass ( i ) = 4 then
41666: LD_VAR 0 3
41670: PPUSH
41671: CALL_OW 257
41675: PUSH
41676: LD_INT 4
41678: EQUAL
41679: IFFALSE 41683
// continue ;
41681: GO 41649
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41683: LD_ADDR_VAR 0 11
41687: PUSH
41688: LD_VAR 0 11
41692: PPUSH
41693: LD_VAR 0 11
41697: PUSH
41698: LD_INT 1
41700: PLUS
41701: PPUSH
41702: LD_VAR 0 9
41706: PUSH
41707: LD_VAR 0 3
41711: ARRAY
41712: PPUSH
41713: CALL_OW 2
41717: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41718: LD_ADDR_VAR 0 4
41722: PUSH
41723: LD_VAR 0 4
41727: PUSH
41728: LD_VAR 0 9
41732: PUSH
41733: LD_VAR 0 3
41737: ARRAY
41738: DIFF
41739: ST_TO_ADDR
// end ;
41740: GO 41649
41742: POP
41743: POP
// if p then
41744: LD_VAR 0 11
41748: IFFALSE 41773
// result := Replace ( result , 4 , p ) ;
41750: LD_ADDR_VAR 0 2
41754: PUSH
41755: LD_VAR 0 2
41759: PPUSH
41760: LD_INT 4
41762: PPUSH
41763: LD_VAR 0 11
41767: PPUSH
41768: CALL_OW 1
41772: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41773: LD_VAR 0 4
41777: PUSH
41778: LD_VAR 0 7
41782: PUSH
41783: LD_INT 6
41785: LESS
41786: AND
41787: IFFALSE 41975
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41789: LD_ADDR_VAR 0 9
41793: PUSH
41794: LD_VAR 0 4
41798: PUSH
41799: LD_VAR 0 8
41803: PUSH
41804: LD_VAR 0 7
41808: UNION
41809: DIFF
41810: PPUSH
41811: LD_INT 3
41813: PPUSH
41814: CALL 101128 0 2
41818: ST_TO_ADDR
// p := [ ] ;
41819: LD_ADDR_VAR 0 11
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// if sort then
41826: LD_VAR 0 9
41830: IFFALSE 41946
// for i = 1 to 6 - mech do
41832: LD_ADDR_VAR 0 3
41836: PUSH
41837: DOUBLE
41838: LD_INT 1
41840: DEC
41841: ST_TO_ADDR
41842: LD_INT 6
41844: PUSH
41845: LD_VAR 0 7
41849: MINUS
41850: PUSH
41851: FOR_TO
41852: IFFALSE 41944
// begin if i = sort then
41854: LD_VAR 0 3
41858: PUSH
41859: LD_VAR 0 9
41863: EQUAL
41864: IFFALSE 41868
// break ;
41866: GO 41944
// if GetClass ( i ) = 3 then
41868: LD_VAR 0 3
41872: PPUSH
41873: CALL_OW 257
41877: PUSH
41878: LD_INT 3
41880: EQUAL
41881: IFFALSE 41885
// continue ;
41883: GO 41851
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41885: LD_ADDR_VAR 0 11
41889: PUSH
41890: LD_VAR 0 11
41894: PPUSH
41895: LD_VAR 0 11
41899: PUSH
41900: LD_INT 1
41902: PLUS
41903: PPUSH
41904: LD_VAR 0 9
41908: PUSH
41909: LD_VAR 0 3
41913: ARRAY
41914: PPUSH
41915: CALL_OW 2
41919: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41920: LD_ADDR_VAR 0 4
41924: PUSH
41925: LD_VAR 0 4
41929: PUSH
41930: LD_VAR 0 9
41934: PUSH
41935: LD_VAR 0 3
41939: ARRAY
41940: DIFF
41941: ST_TO_ADDR
// end ;
41942: GO 41851
41944: POP
41945: POP
// if p then
41946: LD_VAR 0 11
41950: IFFALSE 41975
// result := Replace ( result , 3 , p ) ;
41952: LD_ADDR_VAR 0 2
41956: PUSH
41957: LD_VAR 0 2
41961: PPUSH
41962: LD_INT 3
41964: PPUSH
41965: LD_VAR 0 11
41969: PPUSH
41970: CALL_OW 1
41974: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41975: LD_VAR 0 4
41979: PUSH
41980: LD_INT 6
41982: GREATER
41983: PUSH
41984: LD_VAR 0 6
41988: PUSH
41989: LD_INT 6
41991: LESS
41992: AND
41993: IFFALSE 42187
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41995: LD_ADDR_VAR 0 9
41999: PUSH
42000: LD_VAR 0 4
42004: PUSH
42005: LD_VAR 0 8
42009: PUSH
42010: LD_VAR 0 7
42014: UNION
42015: PUSH
42016: LD_VAR 0 6
42020: UNION
42021: DIFF
42022: PPUSH
42023: LD_INT 2
42025: PPUSH
42026: CALL 101128 0 2
42030: ST_TO_ADDR
// p := [ ] ;
42031: LD_ADDR_VAR 0 11
42035: PUSH
42036: EMPTY
42037: ST_TO_ADDR
// if sort then
42038: LD_VAR 0 9
42042: IFFALSE 42158
// for i = 1 to 6 - eng do
42044: LD_ADDR_VAR 0 3
42048: PUSH
42049: DOUBLE
42050: LD_INT 1
42052: DEC
42053: ST_TO_ADDR
42054: LD_INT 6
42056: PUSH
42057: LD_VAR 0 6
42061: MINUS
42062: PUSH
42063: FOR_TO
42064: IFFALSE 42156
// begin if i = sort then
42066: LD_VAR 0 3
42070: PUSH
42071: LD_VAR 0 9
42075: EQUAL
42076: IFFALSE 42080
// break ;
42078: GO 42156
// if GetClass ( i ) = 2 then
42080: LD_VAR 0 3
42084: PPUSH
42085: CALL_OW 257
42089: PUSH
42090: LD_INT 2
42092: EQUAL
42093: IFFALSE 42097
// continue ;
42095: GO 42063
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42097: LD_ADDR_VAR 0 11
42101: PUSH
42102: LD_VAR 0 11
42106: PPUSH
42107: LD_VAR 0 11
42111: PUSH
42112: LD_INT 1
42114: PLUS
42115: PPUSH
42116: LD_VAR 0 9
42120: PUSH
42121: LD_VAR 0 3
42125: ARRAY
42126: PPUSH
42127: CALL_OW 2
42131: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42132: LD_ADDR_VAR 0 4
42136: PUSH
42137: LD_VAR 0 4
42141: PUSH
42142: LD_VAR 0 9
42146: PUSH
42147: LD_VAR 0 3
42151: ARRAY
42152: DIFF
42153: ST_TO_ADDR
// end ;
42154: GO 42063
42156: POP
42157: POP
// if p then
42158: LD_VAR 0 11
42162: IFFALSE 42187
// result := Replace ( result , 2 , p ) ;
42164: LD_ADDR_VAR 0 2
42168: PUSH
42169: LD_VAR 0 2
42173: PPUSH
42174: LD_INT 2
42176: PPUSH
42177: LD_VAR 0 11
42181: PPUSH
42182: CALL_OW 1
42186: ST_TO_ADDR
// end ; exit ;
42187: GO 43575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42189: LD_EXP 143
42193: PUSH
42194: LD_EXP 142
42198: PUSH
42199: LD_VAR 0 1
42203: ARRAY
42204: ARRAY
42205: NOT
42206: PUSH
42207: LD_EXP 116
42211: PUSH
42212: LD_VAR 0 1
42216: ARRAY
42217: PPUSH
42218: LD_INT 30
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PPUSH
42228: CALL_OW 72
42232: AND
42233: PUSH
42234: LD_EXP 121
42238: PUSH
42239: LD_VAR 0 1
42243: ARRAY
42244: AND
42245: IFFALSE 42853
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42247: LD_ADDR_EXP 158
42251: PUSH
42252: LD_EXP 158
42256: PPUSH
42257: LD_VAR 0 1
42261: PPUSH
42262: LD_INT 5
42264: PPUSH
42265: CALL_OW 1
42269: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42270: LD_ADDR_VAR 0 2
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: LD_INT 0
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: LD_INT 0
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: ST_TO_ADDR
// if sci > 1 then
42293: LD_VAR 0 8
42297: PUSH
42298: LD_INT 1
42300: GREATER
42301: IFFALSE 42329
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42303: LD_ADDR_VAR 0 4
42307: PUSH
42308: LD_VAR 0 4
42312: PUSH
42313: LD_VAR 0 8
42317: PUSH
42318: LD_VAR 0 8
42322: PUSH
42323: LD_INT 1
42325: ARRAY
42326: DIFF
42327: DIFF
42328: ST_TO_ADDR
// if tmp and not sci then
42329: LD_VAR 0 4
42333: PUSH
42334: LD_VAR 0 8
42338: NOT
42339: AND
42340: IFFALSE 42409
// begin sort := SortBySkill ( tmp , 4 ) ;
42342: LD_ADDR_VAR 0 9
42346: PUSH
42347: LD_VAR 0 4
42351: PPUSH
42352: LD_INT 4
42354: PPUSH
42355: CALL 101128 0 2
42359: ST_TO_ADDR
// if sort then
42360: LD_VAR 0 9
42364: IFFALSE 42380
// p := sort [ 1 ] ;
42366: LD_ADDR_VAR 0 11
42370: PUSH
42371: LD_VAR 0 9
42375: PUSH
42376: LD_INT 1
42378: ARRAY
42379: ST_TO_ADDR
// if p then
42380: LD_VAR 0 11
42384: IFFALSE 42409
// result := Replace ( result , 4 , p ) ;
42386: LD_ADDR_VAR 0 2
42390: PUSH
42391: LD_VAR 0 2
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: LD_VAR 0 11
42403: PPUSH
42404: CALL_OW 1
42408: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42409: LD_ADDR_VAR 0 4
42413: PUSH
42414: LD_VAR 0 4
42418: PUSH
42419: LD_VAR 0 7
42423: DIFF
42424: ST_TO_ADDR
// if tmp and mech < 6 then
42425: LD_VAR 0 4
42429: PUSH
42430: LD_VAR 0 7
42434: PUSH
42435: LD_INT 6
42437: LESS
42438: AND
42439: IFFALSE 42627
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42441: LD_ADDR_VAR 0 9
42445: PUSH
42446: LD_VAR 0 4
42450: PUSH
42451: LD_VAR 0 8
42455: PUSH
42456: LD_VAR 0 7
42460: UNION
42461: DIFF
42462: PPUSH
42463: LD_INT 3
42465: PPUSH
42466: CALL 101128 0 2
42470: ST_TO_ADDR
// p := [ ] ;
42471: LD_ADDR_VAR 0 11
42475: PUSH
42476: EMPTY
42477: ST_TO_ADDR
// if sort then
42478: LD_VAR 0 9
42482: IFFALSE 42598
// for i = 1 to 6 - mech do
42484: LD_ADDR_VAR 0 3
42488: PUSH
42489: DOUBLE
42490: LD_INT 1
42492: DEC
42493: ST_TO_ADDR
42494: LD_INT 6
42496: PUSH
42497: LD_VAR 0 7
42501: MINUS
42502: PUSH
42503: FOR_TO
42504: IFFALSE 42596
// begin if i = sort then
42506: LD_VAR 0 3
42510: PUSH
42511: LD_VAR 0 9
42515: EQUAL
42516: IFFALSE 42520
// break ;
42518: GO 42596
// if GetClass ( i ) = 3 then
42520: LD_VAR 0 3
42524: PPUSH
42525: CALL_OW 257
42529: PUSH
42530: LD_INT 3
42532: EQUAL
42533: IFFALSE 42537
// continue ;
42535: GO 42503
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42537: LD_ADDR_VAR 0 11
42541: PUSH
42542: LD_VAR 0 11
42546: PPUSH
42547: LD_VAR 0 11
42551: PUSH
42552: LD_INT 1
42554: PLUS
42555: PPUSH
42556: LD_VAR 0 9
42560: PUSH
42561: LD_VAR 0 3
42565: ARRAY
42566: PPUSH
42567: CALL_OW 2
42571: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42572: LD_ADDR_VAR 0 4
42576: PUSH
42577: LD_VAR 0 4
42581: PUSH
42582: LD_VAR 0 9
42586: PUSH
42587: LD_VAR 0 3
42591: ARRAY
42592: DIFF
42593: ST_TO_ADDR
// end ;
42594: GO 42503
42596: POP
42597: POP
// if p then
42598: LD_VAR 0 11
42602: IFFALSE 42627
// result := Replace ( result , 3 , p ) ;
42604: LD_ADDR_VAR 0 2
42608: PUSH
42609: LD_VAR 0 2
42613: PPUSH
42614: LD_INT 3
42616: PPUSH
42617: LD_VAR 0 11
42621: PPUSH
42622: CALL_OW 1
42626: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42627: LD_ADDR_VAR 0 4
42631: PUSH
42632: LD_VAR 0 4
42636: PUSH
42637: LD_VAR 0 6
42641: DIFF
42642: ST_TO_ADDR
// if tmp and eng < 6 then
42643: LD_VAR 0 4
42647: PUSH
42648: LD_VAR 0 6
42652: PUSH
42653: LD_INT 6
42655: LESS
42656: AND
42657: IFFALSE 42851
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42659: LD_ADDR_VAR 0 9
42663: PUSH
42664: LD_VAR 0 4
42668: PUSH
42669: LD_VAR 0 8
42673: PUSH
42674: LD_VAR 0 7
42678: UNION
42679: PUSH
42680: LD_VAR 0 6
42684: UNION
42685: DIFF
42686: PPUSH
42687: LD_INT 2
42689: PPUSH
42690: CALL 101128 0 2
42694: ST_TO_ADDR
// p := [ ] ;
42695: LD_ADDR_VAR 0 11
42699: PUSH
42700: EMPTY
42701: ST_TO_ADDR
// if sort then
42702: LD_VAR 0 9
42706: IFFALSE 42822
// for i = 1 to 6 - eng do
42708: LD_ADDR_VAR 0 3
42712: PUSH
42713: DOUBLE
42714: LD_INT 1
42716: DEC
42717: ST_TO_ADDR
42718: LD_INT 6
42720: PUSH
42721: LD_VAR 0 6
42725: MINUS
42726: PUSH
42727: FOR_TO
42728: IFFALSE 42820
// begin if i = sort then
42730: LD_VAR 0 3
42734: PUSH
42735: LD_VAR 0 9
42739: EQUAL
42740: IFFALSE 42744
// break ;
42742: GO 42820
// if GetClass ( i ) = 2 then
42744: LD_VAR 0 3
42748: PPUSH
42749: CALL_OW 257
42753: PUSH
42754: LD_INT 2
42756: EQUAL
42757: IFFALSE 42761
// continue ;
42759: GO 42727
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42761: LD_ADDR_VAR 0 11
42765: PUSH
42766: LD_VAR 0 11
42770: PPUSH
42771: LD_VAR 0 11
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: PPUSH
42780: LD_VAR 0 9
42784: PUSH
42785: LD_VAR 0 3
42789: ARRAY
42790: PPUSH
42791: CALL_OW 2
42795: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42796: LD_ADDR_VAR 0 4
42800: PUSH
42801: LD_VAR 0 4
42805: PUSH
42806: LD_VAR 0 9
42810: PUSH
42811: LD_VAR 0 3
42815: ARRAY
42816: DIFF
42817: ST_TO_ADDR
// end ;
42818: GO 42727
42820: POP
42821: POP
// if p then
42822: LD_VAR 0 11
42826: IFFALSE 42851
// result := Replace ( result , 2 , p ) ;
42828: LD_ADDR_VAR 0 2
42832: PUSH
42833: LD_VAR 0 2
42837: PPUSH
42838: LD_INT 2
42840: PPUSH
42841: LD_VAR 0 11
42845: PPUSH
42846: CALL_OW 1
42850: ST_TO_ADDR
// end ; exit ;
42851: GO 43575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42853: LD_EXP 143
42857: PUSH
42858: LD_EXP 142
42862: PUSH
42863: LD_VAR 0 1
42867: ARRAY
42868: ARRAY
42869: NOT
42870: PUSH
42871: LD_EXP 116
42875: PUSH
42876: LD_VAR 0 1
42880: ARRAY
42881: PPUSH
42882: LD_INT 30
42884: PUSH
42885: LD_INT 3
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: PPUSH
42892: CALL_OW 72
42896: AND
42897: PUSH
42898: LD_EXP 121
42902: PUSH
42903: LD_VAR 0 1
42907: ARRAY
42908: NOT
42909: AND
42910: IFFALSE 43575
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42912: LD_ADDR_EXP 158
42916: PUSH
42917: LD_EXP 158
42921: PPUSH
42922: LD_VAR 0 1
42926: PPUSH
42927: LD_INT 6
42929: PPUSH
42930: CALL_OW 1
42934: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42935: LD_ADDR_VAR 0 2
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 0
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: ST_TO_ADDR
// if sci >= 1 then
42958: LD_VAR 0 8
42962: PUSH
42963: LD_INT 1
42965: GREATEREQUAL
42966: IFFALSE 42988
// tmp := tmp diff sci [ 1 ] ;
42968: LD_ADDR_VAR 0 4
42972: PUSH
42973: LD_VAR 0 4
42977: PUSH
42978: LD_VAR 0 8
42982: PUSH
42983: LD_INT 1
42985: ARRAY
42986: DIFF
42987: ST_TO_ADDR
// if tmp and not sci then
42988: LD_VAR 0 4
42992: PUSH
42993: LD_VAR 0 8
42997: NOT
42998: AND
42999: IFFALSE 43068
// begin sort := SortBySkill ( tmp , 4 ) ;
43001: LD_ADDR_VAR 0 9
43005: PUSH
43006: LD_VAR 0 4
43010: PPUSH
43011: LD_INT 4
43013: PPUSH
43014: CALL 101128 0 2
43018: ST_TO_ADDR
// if sort then
43019: LD_VAR 0 9
43023: IFFALSE 43039
// p := sort [ 1 ] ;
43025: LD_ADDR_VAR 0 11
43029: PUSH
43030: LD_VAR 0 9
43034: PUSH
43035: LD_INT 1
43037: ARRAY
43038: ST_TO_ADDR
// if p then
43039: LD_VAR 0 11
43043: IFFALSE 43068
// result := Replace ( result , 4 , p ) ;
43045: LD_ADDR_VAR 0 2
43049: PUSH
43050: LD_VAR 0 2
43054: PPUSH
43055: LD_INT 4
43057: PPUSH
43058: LD_VAR 0 11
43062: PPUSH
43063: CALL_OW 1
43067: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43068: LD_ADDR_VAR 0 4
43072: PUSH
43073: LD_VAR 0 4
43077: PUSH
43078: LD_VAR 0 7
43082: DIFF
43083: ST_TO_ADDR
// if tmp and mech < 6 then
43084: LD_VAR 0 4
43088: PUSH
43089: LD_VAR 0 7
43093: PUSH
43094: LD_INT 6
43096: LESS
43097: AND
43098: IFFALSE 43280
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43100: LD_ADDR_VAR 0 9
43104: PUSH
43105: LD_VAR 0 4
43109: PUSH
43110: LD_VAR 0 7
43114: DIFF
43115: PPUSH
43116: LD_INT 3
43118: PPUSH
43119: CALL 101128 0 2
43123: ST_TO_ADDR
// p := [ ] ;
43124: LD_ADDR_VAR 0 11
43128: PUSH
43129: EMPTY
43130: ST_TO_ADDR
// if sort then
43131: LD_VAR 0 9
43135: IFFALSE 43251
// for i = 1 to 6 - mech do
43137: LD_ADDR_VAR 0 3
43141: PUSH
43142: DOUBLE
43143: LD_INT 1
43145: DEC
43146: ST_TO_ADDR
43147: LD_INT 6
43149: PUSH
43150: LD_VAR 0 7
43154: MINUS
43155: PUSH
43156: FOR_TO
43157: IFFALSE 43249
// begin if i = sort then
43159: LD_VAR 0 3
43163: PUSH
43164: LD_VAR 0 9
43168: EQUAL
43169: IFFALSE 43173
// break ;
43171: GO 43249
// if GetClass ( i ) = 3 then
43173: LD_VAR 0 3
43177: PPUSH
43178: CALL_OW 257
43182: PUSH
43183: LD_INT 3
43185: EQUAL
43186: IFFALSE 43190
// continue ;
43188: GO 43156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43190: LD_ADDR_VAR 0 11
43194: PUSH
43195: LD_VAR 0 11
43199: PPUSH
43200: LD_VAR 0 11
43204: PUSH
43205: LD_INT 1
43207: PLUS
43208: PPUSH
43209: LD_VAR 0 9
43213: PUSH
43214: LD_VAR 0 3
43218: ARRAY
43219: PPUSH
43220: CALL_OW 2
43224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43225: LD_ADDR_VAR 0 4
43229: PUSH
43230: LD_VAR 0 4
43234: PUSH
43235: LD_VAR 0 9
43239: PUSH
43240: LD_VAR 0 3
43244: ARRAY
43245: DIFF
43246: ST_TO_ADDR
// end ;
43247: GO 43156
43249: POP
43250: POP
// if p then
43251: LD_VAR 0 11
43255: IFFALSE 43280
// result := Replace ( result , 3 , p ) ;
43257: LD_ADDR_VAR 0 2
43261: PUSH
43262: LD_VAR 0 2
43266: PPUSH
43267: LD_INT 3
43269: PPUSH
43270: LD_VAR 0 11
43274: PPUSH
43275: CALL_OW 1
43279: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43280: LD_ADDR_VAR 0 4
43284: PUSH
43285: LD_VAR 0 4
43289: PUSH
43290: LD_VAR 0 6
43294: DIFF
43295: ST_TO_ADDR
// if tmp and eng < 4 then
43296: LD_VAR 0 4
43300: PUSH
43301: LD_VAR 0 6
43305: PUSH
43306: LD_INT 4
43308: LESS
43309: AND
43310: IFFALSE 43500
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43312: LD_ADDR_VAR 0 9
43316: PUSH
43317: LD_VAR 0 4
43321: PUSH
43322: LD_VAR 0 7
43326: PUSH
43327: LD_VAR 0 6
43331: UNION
43332: DIFF
43333: PPUSH
43334: LD_INT 2
43336: PPUSH
43337: CALL 101128 0 2
43341: ST_TO_ADDR
// p := [ ] ;
43342: LD_ADDR_VAR 0 11
43346: PUSH
43347: EMPTY
43348: ST_TO_ADDR
// if sort then
43349: LD_VAR 0 9
43353: IFFALSE 43469
// for i = 1 to 4 - eng do
43355: LD_ADDR_VAR 0 3
43359: PUSH
43360: DOUBLE
43361: LD_INT 1
43363: DEC
43364: ST_TO_ADDR
43365: LD_INT 4
43367: PUSH
43368: LD_VAR 0 6
43372: MINUS
43373: PUSH
43374: FOR_TO
43375: IFFALSE 43467
// begin if i = sort then
43377: LD_VAR 0 3
43381: PUSH
43382: LD_VAR 0 9
43386: EQUAL
43387: IFFALSE 43391
// break ;
43389: GO 43467
// if GetClass ( i ) = 2 then
43391: LD_VAR 0 3
43395: PPUSH
43396: CALL_OW 257
43400: PUSH
43401: LD_INT 2
43403: EQUAL
43404: IFFALSE 43408
// continue ;
43406: GO 43374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43408: LD_ADDR_VAR 0 11
43412: PUSH
43413: LD_VAR 0 11
43417: PPUSH
43418: LD_VAR 0 11
43422: PUSH
43423: LD_INT 1
43425: PLUS
43426: PPUSH
43427: LD_VAR 0 9
43431: PUSH
43432: LD_VAR 0 3
43436: ARRAY
43437: PPUSH
43438: CALL_OW 2
43442: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43443: LD_ADDR_VAR 0 4
43447: PUSH
43448: LD_VAR 0 4
43452: PUSH
43453: LD_VAR 0 9
43457: PUSH
43458: LD_VAR 0 3
43462: ARRAY
43463: DIFF
43464: ST_TO_ADDR
// end ;
43465: GO 43374
43467: POP
43468: POP
// if p then
43469: LD_VAR 0 11
43473: IFFALSE 43498
// result := Replace ( result , 2 , p ) ;
43475: LD_ADDR_VAR 0 2
43479: PUSH
43480: LD_VAR 0 2
43484: PPUSH
43485: LD_INT 2
43487: PPUSH
43488: LD_VAR 0 11
43492: PPUSH
43493: CALL_OW 1
43497: ST_TO_ADDR
// end else
43498: GO 43544
// for i = eng downto 5 do
43500: LD_ADDR_VAR 0 3
43504: PUSH
43505: DOUBLE
43506: LD_VAR 0 6
43510: INC
43511: ST_TO_ADDR
43512: LD_INT 5
43514: PUSH
43515: FOR_DOWNTO
43516: IFFALSE 43542
// tmp := tmp union eng [ i ] ;
43518: LD_ADDR_VAR 0 4
43522: PUSH
43523: LD_VAR 0 4
43527: PUSH
43528: LD_VAR 0 6
43532: PUSH
43533: LD_VAR 0 3
43537: ARRAY
43538: UNION
43539: ST_TO_ADDR
43540: GO 43515
43542: POP
43543: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43544: LD_ADDR_VAR 0 2
43548: PUSH
43549: LD_VAR 0 2
43553: PPUSH
43554: LD_INT 1
43556: PPUSH
43557: LD_VAR 0 4
43561: PUSH
43562: LD_VAR 0 5
43566: DIFF
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// exit ;
43573: GO 43575
// end ; end ;
43575: LD_VAR 0 2
43579: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43580: LD_INT 0
43582: PPUSH
43583: PPUSH
43584: PPUSH
// if not mc_bases then
43585: LD_EXP 116
43589: NOT
43590: IFFALSE 43594
// exit ;
43592: GO 43736
// for i = 1 to mc_bases do
43594: LD_ADDR_VAR 0 2
43598: PUSH
43599: DOUBLE
43600: LD_INT 1
43602: DEC
43603: ST_TO_ADDR
43604: LD_EXP 116
43608: PUSH
43609: FOR_TO
43610: IFFALSE 43727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43612: LD_ADDR_VAR 0 3
43616: PUSH
43617: LD_EXP 116
43621: PUSH
43622: LD_VAR 0 2
43626: ARRAY
43627: PPUSH
43628: LD_INT 21
43630: PUSH
43631: LD_INT 3
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 3
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: LD_INT 30
43646: PUSH
43647: LD_INT 29
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 30
43656: PUSH
43657: LD_INT 30
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 24
43678: PUSH
43679: LD_INT 1000
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: LIST
43694: PPUSH
43695: CALL_OW 72
43699: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43700: LD_ADDR_EXP 117
43704: PUSH
43705: LD_EXP 117
43709: PPUSH
43710: LD_VAR 0 2
43714: PPUSH
43715: LD_VAR 0 3
43719: PPUSH
43720: CALL_OW 1
43724: ST_TO_ADDR
// end ;
43725: GO 43609
43727: POP
43728: POP
// RaiseSailEvent ( 101 ) ;
43729: LD_INT 101
43731: PPUSH
43732: CALL_OW 427
// end ;
43736: LD_VAR 0 1
43740: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43741: LD_INT 0
43743: PPUSH
43744: PPUSH
43745: PPUSH
43746: PPUSH
43747: PPUSH
43748: PPUSH
43749: PPUSH
// if not mc_bases then
43750: LD_EXP 116
43754: NOT
43755: IFFALSE 43759
// exit ;
43757: GO 44321
// for i = 1 to mc_bases do
43759: LD_ADDR_VAR 0 2
43763: PUSH
43764: DOUBLE
43765: LD_INT 1
43767: DEC
43768: ST_TO_ADDR
43769: LD_EXP 116
43773: PUSH
43774: FOR_TO
43775: IFFALSE 44312
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43777: LD_ADDR_VAR 0 5
43781: PUSH
43782: LD_EXP 116
43786: PUSH
43787: LD_VAR 0 2
43791: ARRAY
43792: PUSH
43793: LD_EXP 145
43797: PUSH
43798: LD_VAR 0 2
43802: ARRAY
43803: UNION
43804: PPUSH
43805: LD_INT 21
43807: PUSH
43808: LD_INT 1
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 1
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: LD_INT 54
43823: PUSH
43824: EMPTY
43825: LIST
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 3
43833: PUSH
43834: LD_INT 24
43836: PUSH
43837: LD_INT 1000
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: LIST
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PPUSH
43857: CALL_OW 72
43861: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43862: LD_ADDR_VAR 0 6
43866: PUSH
43867: LD_EXP 116
43871: PUSH
43872: LD_VAR 0 2
43876: ARRAY
43877: PPUSH
43878: LD_INT 21
43880: PUSH
43881: LD_INT 1
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 1
43890: PUSH
43891: LD_INT 3
43893: PUSH
43894: LD_INT 54
43896: PUSH
43897: EMPTY
43898: LIST
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 3
43906: PUSH
43907: LD_INT 24
43909: PUSH
43910: LD_INT 250
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: LIST
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PPUSH
43930: CALL_OW 72
43934: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43935: LD_ADDR_VAR 0 7
43939: PUSH
43940: LD_VAR 0 5
43944: PUSH
43945: LD_VAR 0 6
43949: DIFF
43950: ST_TO_ADDR
// if not need_heal_1 then
43951: LD_VAR 0 6
43955: NOT
43956: IFFALSE 43989
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43958: LD_ADDR_EXP 119
43962: PUSH
43963: LD_EXP 119
43967: PPUSH
43968: LD_VAR 0 2
43972: PUSH
43973: LD_INT 1
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PPUSH
43980: EMPTY
43981: PPUSH
43982: CALL 70871 0 3
43986: ST_TO_ADDR
43987: GO 44059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43989: LD_ADDR_EXP 119
43993: PUSH
43994: LD_EXP 119
43998: PPUSH
43999: LD_VAR 0 2
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PPUSH
44011: LD_EXP 119
44015: PUSH
44016: LD_VAR 0 2
44020: ARRAY
44021: PUSH
44022: LD_INT 1
44024: ARRAY
44025: PPUSH
44026: LD_INT 3
44028: PUSH
44029: LD_INT 24
44031: PUSH
44032: LD_INT 1000
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PPUSH
44043: CALL_OW 72
44047: PUSH
44048: LD_VAR 0 6
44052: UNION
44053: PPUSH
44054: CALL 70871 0 3
44058: ST_TO_ADDR
// if not need_heal_2 then
44059: LD_VAR 0 7
44063: NOT
44064: IFFALSE 44097
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44066: LD_ADDR_EXP 119
44070: PUSH
44071: LD_EXP 119
44075: PPUSH
44076: LD_VAR 0 2
44080: PUSH
44081: LD_INT 2
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PPUSH
44088: EMPTY
44089: PPUSH
44090: CALL 70871 0 3
44094: ST_TO_ADDR
44095: GO 44129
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44097: LD_ADDR_EXP 119
44101: PUSH
44102: LD_EXP 119
44106: PPUSH
44107: LD_VAR 0 2
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PPUSH
44119: LD_VAR 0 7
44123: PPUSH
44124: CALL 70871 0 3
44128: ST_TO_ADDR
// if need_heal_2 then
44129: LD_VAR 0 7
44133: IFFALSE 44294
// for j in need_heal_2 do
44135: LD_ADDR_VAR 0 3
44139: PUSH
44140: LD_VAR 0 7
44144: PUSH
44145: FOR_IN
44146: IFFALSE 44292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44148: LD_ADDR_VAR 0 5
44152: PUSH
44153: LD_EXP 116
44157: PUSH
44158: LD_VAR 0 2
44162: ARRAY
44163: PPUSH
44164: LD_INT 2
44166: PUSH
44167: LD_INT 30
44169: PUSH
44170: LD_INT 6
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 30
44179: PUSH
44180: LD_INT 7
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 30
44189: PUSH
44190: LD_INT 8
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 30
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 30
44209: PUSH
44210: LD_INT 1
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: LIST
44224: PPUSH
44225: CALL_OW 72
44229: ST_TO_ADDR
// if tmp then
44230: LD_VAR 0 5
44234: IFFALSE 44290
// begin k := NearestUnitToUnit ( tmp , j ) ;
44236: LD_ADDR_VAR 0 4
44240: PUSH
44241: LD_VAR 0 5
44245: PPUSH
44246: LD_VAR 0 3
44250: PPUSH
44251: CALL_OW 74
44255: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44256: LD_VAR 0 3
44260: PPUSH
44261: LD_VAR 0 4
44265: PPUSH
44266: CALL_OW 296
44270: PUSH
44271: LD_INT 5
44273: GREATER
44274: IFFALSE 44290
// ComMoveToNearbyEntrance ( j , k ) ;
44276: LD_VAR 0 3
44280: PPUSH
44281: LD_VAR 0 4
44285: PPUSH
44286: CALL 103489 0 2
// end ; end ;
44290: GO 44145
44292: POP
44293: POP
// if not need_heal_1 and not need_heal_2 then
44294: LD_VAR 0 6
44298: NOT
44299: PUSH
44300: LD_VAR 0 7
44304: NOT
44305: AND
44306: IFFALSE 44310
// continue ;
44308: GO 43774
// end ;
44310: GO 43774
44312: POP
44313: POP
// RaiseSailEvent ( 102 ) ;
44314: LD_INT 102
44316: PPUSH
44317: CALL_OW 427
// end ;
44321: LD_VAR 0 1
44325: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44326: LD_INT 0
44328: PPUSH
44329: PPUSH
44330: PPUSH
44331: PPUSH
44332: PPUSH
44333: PPUSH
44334: PPUSH
44335: PPUSH
// if not mc_bases then
44336: LD_EXP 116
44340: NOT
44341: IFFALSE 44345
// exit ;
44343: GO 45228
// for i = 1 to mc_bases do
44345: LD_ADDR_VAR 0 2
44349: PUSH
44350: DOUBLE
44351: LD_INT 1
44353: DEC
44354: ST_TO_ADDR
44355: LD_EXP 116
44359: PUSH
44360: FOR_TO
44361: IFFALSE 45226
// begin if not mc_building_need_repair [ i ] then
44363: LD_EXP 117
44367: PUSH
44368: LD_VAR 0 2
44372: ARRAY
44373: NOT
44374: IFFALSE 44561
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44376: LD_ADDR_VAR 0 6
44380: PUSH
44381: LD_EXP 135
44385: PUSH
44386: LD_VAR 0 2
44390: ARRAY
44391: PPUSH
44392: LD_INT 3
44394: PUSH
44395: LD_INT 24
44397: PUSH
44398: LD_INT 1000
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 2
44411: PUSH
44412: LD_INT 34
44414: PUSH
44415: LD_INT 13
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 34
44424: PUSH
44425: LD_INT 52
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 34
44434: PUSH
44435: LD_EXP 101
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PPUSH
44454: CALL_OW 72
44458: ST_TO_ADDR
// if cranes then
44459: LD_VAR 0 6
44463: IFFALSE 44525
// for j in cranes do
44465: LD_ADDR_VAR 0 3
44469: PUSH
44470: LD_VAR 0 6
44474: PUSH
44475: FOR_IN
44476: IFFALSE 44523
// if not IsInArea ( j , mc_parking [ i ] ) then
44478: LD_VAR 0 3
44482: PPUSH
44483: LD_EXP 140
44487: PUSH
44488: LD_VAR 0 2
44492: ARRAY
44493: PPUSH
44494: CALL_OW 308
44498: NOT
44499: IFFALSE 44521
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44501: LD_VAR 0 3
44505: PPUSH
44506: LD_EXP 140
44510: PUSH
44511: LD_VAR 0 2
44515: ARRAY
44516: PPUSH
44517: CALL_OW 113
44521: GO 44475
44523: POP
44524: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44525: LD_ADDR_EXP 118
44529: PUSH
44530: LD_EXP 118
44534: PPUSH
44535: LD_VAR 0 2
44539: PPUSH
44540: EMPTY
44541: PPUSH
44542: CALL_OW 1
44546: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44547: LD_VAR 0 2
44551: PPUSH
44552: LD_INT 101
44554: PPUSH
44555: CALL 39413 0 2
// continue ;
44559: GO 44360
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44561: LD_ADDR_EXP 122
44565: PUSH
44566: LD_EXP 122
44570: PPUSH
44571: LD_VAR 0 2
44575: PPUSH
44576: EMPTY
44577: PPUSH
44578: CALL_OW 1
44582: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44583: LD_VAR 0 2
44587: PPUSH
44588: LD_INT 103
44590: PPUSH
44591: CALL 39413 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44595: LD_ADDR_VAR 0 5
44599: PUSH
44600: LD_EXP 116
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PUSH
44611: LD_EXP 145
44615: PUSH
44616: LD_VAR 0 2
44620: ARRAY
44621: UNION
44622: PPUSH
44623: LD_INT 2
44625: PUSH
44626: LD_INT 25
44628: PUSH
44629: LD_INT 2
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 25
44638: PUSH
44639: LD_INT 16
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: LIST
44650: PUSH
44651: EMPTY
44652: LIST
44653: PPUSH
44654: CALL_OW 72
44658: ST_TO_ADDR
// if mc_need_heal [ i ] then
44659: LD_EXP 119
44663: PUSH
44664: LD_VAR 0 2
44668: ARRAY
44669: IFFALSE 44713
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44671: LD_ADDR_VAR 0 5
44675: PUSH
44676: LD_VAR 0 5
44680: PUSH
44681: LD_EXP 119
44685: PUSH
44686: LD_VAR 0 2
44690: ARRAY
44691: PUSH
44692: LD_INT 1
44694: ARRAY
44695: PUSH
44696: LD_EXP 119
44700: PUSH
44701: LD_VAR 0 2
44705: ARRAY
44706: PUSH
44707: LD_INT 2
44709: ARRAY
44710: UNION
44711: DIFF
44712: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44713: LD_ADDR_VAR 0 6
44717: PUSH
44718: LD_EXP 135
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PPUSH
44729: LD_INT 2
44731: PUSH
44732: LD_INT 34
44734: PUSH
44735: LD_INT 13
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 34
44744: PUSH
44745: LD_INT 52
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 34
44754: PUSH
44755: LD_EXP 101
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: PPUSH
44770: CALL_OW 72
44774: ST_TO_ADDR
// if cranes then
44775: LD_VAR 0 6
44779: IFFALSE 44915
// begin for j in cranes do
44781: LD_ADDR_VAR 0 3
44785: PUSH
44786: LD_VAR 0 6
44790: PUSH
44791: FOR_IN
44792: IFFALSE 44913
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44794: LD_VAR 0 3
44798: PPUSH
44799: CALL_OW 256
44803: PUSH
44804: LD_INT 1000
44806: EQUAL
44807: PUSH
44808: LD_VAR 0 3
44812: PPUSH
44813: CALL_OW 314
44817: NOT
44818: AND
44819: IFFALSE 44853
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44821: LD_VAR 0 3
44825: PPUSH
44826: LD_EXP 117
44830: PUSH
44831: LD_VAR 0 2
44835: ARRAY
44836: PPUSH
44837: LD_VAR 0 3
44841: PPUSH
44842: CALL_OW 74
44846: PPUSH
44847: CALL_OW 130
44851: GO 44911
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44853: LD_VAR 0 3
44857: PPUSH
44858: CALL_OW 256
44862: PUSH
44863: LD_INT 500
44865: LESS
44866: PUSH
44867: LD_VAR 0 3
44871: PPUSH
44872: LD_EXP 140
44876: PUSH
44877: LD_VAR 0 2
44881: ARRAY
44882: PPUSH
44883: CALL_OW 308
44887: NOT
44888: AND
44889: IFFALSE 44911
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44891: LD_VAR 0 3
44895: PPUSH
44896: LD_EXP 140
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: PPUSH
44907: CALL_OW 113
// end ;
44911: GO 44791
44913: POP
44914: POP
// end ; if tmp > 3 then
44915: LD_VAR 0 5
44919: PUSH
44920: LD_INT 3
44922: GREATER
44923: IFFALSE 44943
// tmp := ShrinkArray ( tmp , 4 ) ;
44925: LD_ADDR_VAR 0 5
44929: PUSH
44930: LD_VAR 0 5
44934: PPUSH
44935: LD_INT 4
44937: PPUSH
44938: CALL 102937 0 2
44942: ST_TO_ADDR
// if not tmp then
44943: LD_VAR 0 5
44947: NOT
44948: IFFALSE 44952
// continue ;
44950: GO 44360
// for j in tmp do
44952: LD_ADDR_VAR 0 3
44956: PUSH
44957: LD_VAR 0 5
44961: PUSH
44962: FOR_IN
44963: IFFALSE 45222
// begin if IsInUnit ( j ) then
44965: LD_VAR 0 3
44969: PPUSH
44970: CALL_OW 310
44974: IFFALSE 44985
// ComExitBuilding ( j ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44985: LD_VAR 0 3
44989: PUSH
44990: LD_EXP 118
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: IN
45001: NOT
45002: IFFALSE 45060
// begin SetTag ( j , 101 ) ;
45004: LD_VAR 0 3
45008: PPUSH
45009: LD_INT 101
45011: PPUSH
45012: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45016: LD_ADDR_EXP 118
45020: PUSH
45021: LD_EXP 118
45025: PPUSH
45026: LD_VAR 0 2
45030: PUSH
45031: LD_EXP 118
45035: PUSH
45036: LD_VAR 0 2
45040: ARRAY
45041: PUSH
45042: LD_INT 1
45044: PLUS
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PPUSH
45050: LD_VAR 0 3
45054: PPUSH
45055: CALL 70871 0 3
45059: ST_TO_ADDR
// end ; wait ( 1 ) ;
45060: LD_INT 1
45062: PPUSH
45063: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45067: LD_ADDR_VAR 0 7
45071: PUSH
45072: LD_EXP 117
45076: PUSH
45077: LD_VAR 0 2
45081: ARRAY
45082: ST_TO_ADDR
// if mc_scan [ i ] then
45083: LD_EXP 139
45087: PUSH
45088: LD_VAR 0 2
45092: ARRAY
45093: IFFALSE 45155
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45095: LD_ADDR_VAR 0 7
45099: PUSH
45100: LD_EXP 117
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: PPUSH
45111: LD_INT 3
45113: PUSH
45114: LD_INT 30
45116: PUSH
45117: LD_INT 32
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 30
45126: PUSH
45127: LD_INT 33
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 30
45136: PUSH
45137: LD_INT 31
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: ST_TO_ADDR
// if not to_repair_tmp then
45155: LD_VAR 0 7
45159: NOT
45160: IFFALSE 45164
// continue ;
45162: GO 44962
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45164: LD_ADDR_VAR 0 8
45168: PUSH
45169: LD_VAR 0 7
45173: PPUSH
45174: LD_VAR 0 3
45178: PPUSH
45179: CALL_OW 74
45183: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45184: LD_VAR 0 8
45188: PPUSH
45189: LD_INT 16
45191: PPUSH
45192: CALL 73470 0 2
45196: PUSH
45197: LD_INT 4
45199: ARRAY
45200: PUSH
45201: LD_INT 10
45203: LESS
45204: IFFALSE 45220
// ComRepairBuilding ( j , to_repair ) ;
45206: LD_VAR 0 3
45210: PPUSH
45211: LD_VAR 0 8
45215: PPUSH
45216: CALL_OW 130
// end ;
45220: GO 44962
45222: POP
45223: POP
// end ;
45224: GO 44360
45226: POP
45227: POP
// end ;
45228: LD_VAR 0 1
45232: RET
// export function MC_Heal ; var i , j , tmp ; begin
45233: LD_INT 0
45235: PPUSH
45236: PPUSH
45237: PPUSH
45238: PPUSH
// if not mc_bases then
45239: LD_EXP 116
45243: NOT
45244: IFFALSE 45248
// exit ;
45246: GO 45650
// for i = 1 to mc_bases do
45248: LD_ADDR_VAR 0 2
45252: PUSH
45253: DOUBLE
45254: LD_INT 1
45256: DEC
45257: ST_TO_ADDR
45258: LD_EXP 116
45262: PUSH
45263: FOR_TO
45264: IFFALSE 45648
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45266: LD_EXP 119
45270: PUSH
45271: LD_VAR 0 2
45275: ARRAY
45276: PUSH
45277: LD_INT 1
45279: ARRAY
45280: NOT
45281: PUSH
45282: LD_EXP 119
45286: PUSH
45287: LD_VAR 0 2
45291: ARRAY
45292: PUSH
45293: LD_INT 2
45295: ARRAY
45296: NOT
45297: AND
45298: IFFALSE 45336
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45300: LD_ADDR_EXP 120
45304: PUSH
45305: LD_EXP 120
45309: PPUSH
45310: LD_VAR 0 2
45314: PPUSH
45315: EMPTY
45316: PPUSH
45317: CALL_OW 1
45321: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45322: LD_VAR 0 2
45326: PPUSH
45327: LD_INT 102
45329: PPUSH
45330: CALL 39413 0 2
// continue ;
45334: GO 45263
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45336: LD_ADDR_VAR 0 4
45340: PUSH
45341: LD_EXP 116
45345: PUSH
45346: LD_VAR 0 2
45350: ARRAY
45351: PPUSH
45352: LD_INT 25
45354: PUSH
45355: LD_INT 4
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PPUSH
45362: CALL_OW 72
45366: ST_TO_ADDR
// if not tmp then
45367: LD_VAR 0 4
45371: NOT
45372: IFFALSE 45376
// continue ;
45374: GO 45263
// if mc_taming [ i ] then
45376: LD_EXP 147
45380: PUSH
45381: LD_VAR 0 2
45385: ARRAY
45386: IFFALSE 45410
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45388: LD_ADDR_EXP 147
45392: PUSH
45393: LD_EXP 147
45397: PPUSH
45398: LD_VAR 0 2
45402: PPUSH
45403: EMPTY
45404: PPUSH
45405: CALL_OW 1
45409: ST_TO_ADDR
// for j in tmp do
45410: LD_ADDR_VAR 0 3
45414: PUSH
45415: LD_VAR 0 4
45419: PUSH
45420: FOR_IN
45421: IFFALSE 45644
// begin if IsInUnit ( j ) then
45423: LD_VAR 0 3
45427: PPUSH
45428: CALL_OW 310
45432: IFFALSE 45443
// ComExitBuilding ( j ) ;
45434: LD_VAR 0 3
45438: PPUSH
45439: CALL_OW 122
// if not j in mc_healers [ i ] then
45443: LD_VAR 0 3
45447: PUSH
45448: LD_EXP 120
45452: PUSH
45453: LD_VAR 0 2
45457: ARRAY
45458: IN
45459: NOT
45460: IFFALSE 45506
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45462: LD_ADDR_EXP 120
45466: PUSH
45467: LD_EXP 120
45471: PPUSH
45472: LD_VAR 0 2
45476: PUSH
45477: LD_EXP 120
45481: PUSH
45482: LD_VAR 0 2
45486: ARRAY
45487: PUSH
45488: LD_INT 1
45490: PLUS
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PPUSH
45496: LD_VAR 0 3
45500: PPUSH
45501: CALL 70871 0 3
45505: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45506: LD_VAR 0 3
45510: PPUSH
45511: CALL_OW 110
45515: PUSH
45516: LD_INT 102
45518: NONEQUAL
45519: IFFALSE 45533
// SetTag ( j , 102 ) ;
45521: LD_VAR 0 3
45525: PPUSH
45526: LD_INT 102
45528: PPUSH
45529: CALL_OW 109
// Wait ( 3 ) ;
45533: LD_INT 3
45535: PPUSH
45536: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45540: LD_EXP 119
45544: PUSH
45545: LD_VAR 0 2
45549: ARRAY
45550: PUSH
45551: LD_INT 1
45553: ARRAY
45554: IFFALSE 45586
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45556: LD_VAR 0 3
45560: PPUSH
45561: LD_EXP 119
45565: PUSH
45566: LD_VAR 0 2
45570: ARRAY
45571: PUSH
45572: LD_INT 1
45574: ARRAY
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: PPUSH
45580: CALL_OW 128
45584: GO 45642
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45586: LD_VAR 0 3
45590: PPUSH
45591: CALL_OW 314
45595: NOT
45596: PUSH
45597: LD_EXP 119
45601: PUSH
45602: LD_VAR 0 2
45606: ARRAY
45607: PUSH
45608: LD_INT 2
45610: ARRAY
45611: AND
45612: IFFALSE 45642
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45614: LD_VAR 0 3
45618: PPUSH
45619: LD_EXP 119
45623: PUSH
45624: LD_VAR 0 2
45628: ARRAY
45629: PUSH
45630: LD_INT 2
45632: ARRAY
45633: PUSH
45634: LD_INT 1
45636: ARRAY
45637: PPUSH
45638: CALL_OW 128
// end ;
45642: GO 45420
45644: POP
45645: POP
// end ;
45646: GO 45263
45648: POP
45649: POP
// end ;
45650: LD_VAR 0 1
45654: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45655: LD_INT 0
45657: PPUSH
45658: PPUSH
45659: PPUSH
45660: PPUSH
45661: PPUSH
// if not mc_bases then
45662: LD_EXP 116
45666: NOT
45667: IFFALSE 45671
// exit ;
45669: GO 46842
// for i = 1 to mc_bases do
45671: LD_ADDR_VAR 0 2
45675: PUSH
45676: DOUBLE
45677: LD_INT 1
45679: DEC
45680: ST_TO_ADDR
45681: LD_EXP 116
45685: PUSH
45686: FOR_TO
45687: IFFALSE 46840
// begin if mc_scan [ i ] then
45689: LD_EXP 139
45693: PUSH
45694: LD_VAR 0 2
45698: ARRAY
45699: IFFALSE 45703
// continue ;
45701: GO 45686
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45703: LD_EXP 121
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: NOT
45714: PUSH
45715: LD_EXP 123
45719: PUSH
45720: LD_VAR 0 2
45724: ARRAY
45725: NOT
45726: AND
45727: PUSH
45728: LD_EXP 122
45732: PUSH
45733: LD_VAR 0 2
45737: ARRAY
45738: AND
45739: IFFALSE 45777
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45741: LD_ADDR_EXP 122
45745: PUSH
45746: LD_EXP 122
45750: PPUSH
45751: LD_VAR 0 2
45755: PPUSH
45756: EMPTY
45757: PPUSH
45758: CALL_OW 1
45762: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45763: LD_VAR 0 2
45767: PPUSH
45768: LD_INT 103
45770: PPUSH
45771: CALL 39413 0 2
// continue ;
45775: GO 45686
// end ; if mc_construct_list [ i ] then
45777: LD_EXP 123
45781: PUSH
45782: LD_VAR 0 2
45786: ARRAY
45787: IFFALSE 46007
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45789: LD_ADDR_VAR 0 4
45793: PUSH
45794: LD_EXP 116
45798: PUSH
45799: LD_VAR 0 2
45803: ARRAY
45804: PPUSH
45805: LD_INT 25
45807: PUSH
45808: LD_INT 2
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PPUSH
45815: CALL_OW 72
45819: PUSH
45820: LD_EXP 118
45824: PUSH
45825: LD_VAR 0 2
45829: ARRAY
45830: DIFF
45831: ST_TO_ADDR
// if not tmp then
45832: LD_VAR 0 4
45836: NOT
45837: IFFALSE 45841
// continue ;
45839: GO 45686
// for j in tmp do
45841: LD_ADDR_VAR 0 3
45845: PUSH
45846: LD_VAR 0 4
45850: PUSH
45851: FOR_IN
45852: IFFALSE 46003
// begin if not mc_builders [ i ] then
45854: LD_EXP 122
45858: PUSH
45859: LD_VAR 0 2
45863: ARRAY
45864: NOT
45865: IFFALSE 45923
// begin SetTag ( j , 103 ) ;
45867: LD_VAR 0 3
45871: PPUSH
45872: LD_INT 103
45874: PPUSH
45875: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45879: LD_ADDR_EXP 122
45883: PUSH
45884: LD_EXP 122
45888: PPUSH
45889: LD_VAR 0 2
45893: PUSH
45894: LD_EXP 122
45898: PUSH
45899: LD_VAR 0 2
45903: ARRAY
45904: PUSH
45905: LD_INT 1
45907: PLUS
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PPUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL 70871 0 3
45922: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45923: LD_VAR 0 3
45927: PPUSH
45928: CALL_OW 310
45932: IFFALSE 45943
// ComExitBuilding ( j ) ;
45934: LD_VAR 0 3
45938: PPUSH
45939: CALL_OW 122
// wait ( 3 ) ;
45943: LD_INT 3
45945: PPUSH
45946: CALL_OW 67
// if not mc_construct_list [ i ] then
45950: LD_EXP 123
45954: PUSH
45955: LD_VAR 0 2
45959: ARRAY
45960: NOT
45961: IFFALSE 45965
// break ;
45963: GO 46003
// if not HasTask ( j ) then
45965: LD_VAR 0 3
45969: PPUSH
45970: CALL_OW 314
45974: NOT
45975: IFFALSE 46001
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45977: LD_VAR 0 3
45981: PPUSH
45982: LD_EXP 123
45986: PUSH
45987: LD_VAR 0 2
45991: ARRAY
45992: PUSH
45993: LD_INT 1
45995: ARRAY
45996: PPUSH
45997: CALL 73734 0 2
// end ;
46001: GO 45851
46003: POP
46004: POP
// end else
46005: GO 46838
// if mc_build_list [ i ] then
46007: LD_EXP 121
46011: PUSH
46012: LD_VAR 0 2
46016: ARRAY
46017: IFFALSE 46838
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46019: LD_ADDR_VAR 0 5
46023: PUSH
46024: LD_EXP 116
46028: PUSH
46029: LD_VAR 0 2
46033: ARRAY
46034: PPUSH
46035: LD_INT 2
46037: PUSH
46038: LD_INT 30
46040: PUSH
46041: LD_INT 0
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 30
46050: PUSH
46051: LD_INT 1
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: LIST
46062: PPUSH
46063: CALL_OW 72
46067: ST_TO_ADDR
// if depot then
46068: LD_VAR 0 5
46072: IFFALSE 46090
// depot := depot [ 1 ] else
46074: LD_ADDR_VAR 0 5
46078: PUSH
46079: LD_VAR 0 5
46083: PUSH
46084: LD_INT 1
46086: ARRAY
46087: ST_TO_ADDR
46088: GO 46098
// depot := 0 ;
46090: LD_ADDR_VAR 0 5
46094: PUSH
46095: LD_INT 0
46097: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46098: LD_EXP 121
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PUSH
46109: LD_INT 1
46111: ARRAY
46112: PUSH
46113: LD_INT 1
46115: ARRAY
46116: PPUSH
46117: CALL 73558 0 1
46121: PUSH
46122: LD_EXP 116
46126: PUSH
46127: LD_VAR 0 2
46131: ARRAY
46132: PPUSH
46133: LD_INT 2
46135: PUSH
46136: LD_INT 30
46138: PUSH
46139: LD_INT 2
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 30
46148: PUSH
46149: LD_INT 3
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: LIST
46160: PPUSH
46161: CALL_OW 72
46165: NOT
46166: AND
46167: IFFALSE 46272
// begin for j = 1 to mc_build_list [ i ] do
46169: LD_ADDR_VAR 0 3
46173: PUSH
46174: DOUBLE
46175: LD_INT 1
46177: DEC
46178: ST_TO_ADDR
46179: LD_EXP 121
46183: PUSH
46184: LD_VAR 0 2
46188: ARRAY
46189: PUSH
46190: FOR_TO
46191: IFFALSE 46270
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46193: LD_EXP 121
46197: PUSH
46198: LD_VAR 0 2
46202: ARRAY
46203: PUSH
46204: LD_VAR 0 3
46208: ARRAY
46209: PUSH
46210: LD_INT 1
46212: ARRAY
46213: PUSH
46214: LD_INT 2
46216: EQUAL
46217: IFFALSE 46268
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46219: LD_ADDR_EXP 121
46223: PUSH
46224: LD_EXP 121
46228: PPUSH
46229: LD_VAR 0 2
46233: PPUSH
46234: LD_EXP 121
46238: PUSH
46239: LD_VAR 0 2
46243: ARRAY
46244: PPUSH
46245: LD_VAR 0 3
46249: PPUSH
46250: LD_INT 1
46252: PPUSH
46253: LD_INT 0
46255: PPUSH
46256: CALL 70289 0 4
46260: PPUSH
46261: CALL_OW 1
46265: ST_TO_ADDR
// break ;
46266: GO 46270
// end ;
46268: GO 46190
46270: POP
46271: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46272: LD_EXP 121
46276: PUSH
46277: LD_VAR 0 2
46281: ARRAY
46282: PUSH
46283: LD_INT 1
46285: ARRAY
46286: PUSH
46287: LD_INT 1
46289: ARRAY
46290: PUSH
46291: LD_INT 0
46293: EQUAL
46294: PUSH
46295: LD_VAR 0 5
46299: PUSH
46300: LD_VAR 0 5
46304: PPUSH
46305: LD_EXP 121
46309: PUSH
46310: LD_VAR 0 2
46314: ARRAY
46315: PUSH
46316: LD_INT 1
46318: ARRAY
46319: PUSH
46320: LD_INT 1
46322: ARRAY
46323: PPUSH
46324: LD_EXP 121
46328: PUSH
46329: LD_VAR 0 2
46333: ARRAY
46334: PUSH
46335: LD_INT 1
46337: ARRAY
46338: PUSH
46339: LD_INT 2
46341: ARRAY
46342: PPUSH
46343: LD_EXP 121
46347: PUSH
46348: LD_VAR 0 2
46352: ARRAY
46353: PUSH
46354: LD_INT 1
46356: ARRAY
46357: PUSH
46358: LD_INT 3
46360: ARRAY
46361: PPUSH
46362: LD_EXP 121
46366: PUSH
46367: LD_VAR 0 2
46371: ARRAY
46372: PUSH
46373: LD_INT 1
46375: ARRAY
46376: PUSH
46377: LD_INT 4
46379: ARRAY
46380: PPUSH
46381: CALL 78974 0 5
46385: AND
46386: OR
46387: IFFALSE 46668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46389: LD_ADDR_VAR 0 4
46393: PUSH
46394: LD_EXP 116
46398: PUSH
46399: LD_VAR 0 2
46403: ARRAY
46404: PPUSH
46405: LD_INT 25
46407: PUSH
46408: LD_INT 2
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PPUSH
46415: CALL_OW 72
46419: PUSH
46420: LD_EXP 118
46424: PUSH
46425: LD_VAR 0 2
46429: ARRAY
46430: DIFF
46431: ST_TO_ADDR
// if not tmp then
46432: LD_VAR 0 4
46436: NOT
46437: IFFALSE 46441
// continue ;
46439: GO 45686
// for j in tmp do
46441: LD_ADDR_VAR 0 3
46445: PUSH
46446: LD_VAR 0 4
46450: PUSH
46451: FOR_IN
46452: IFFALSE 46664
// begin if not mc_builders [ i ] then
46454: LD_EXP 122
46458: PUSH
46459: LD_VAR 0 2
46463: ARRAY
46464: NOT
46465: IFFALSE 46523
// begin SetTag ( j , 103 ) ;
46467: LD_VAR 0 3
46471: PPUSH
46472: LD_INT 103
46474: PPUSH
46475: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46479: LD_ADDR_EXP 122
46483: PUSH
46484: LD_EXP 122
46488: PPUSH
46489: LD_VAR 0 2
46493: PUSH
46494: LD_EXP 122
46498: PUSH
46499: LD_VAR 0 2
46503: ARRAY
46504: PUSH
46505: LD_INT 1
46507: PLUS
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PPUSH
46513: LD_VAR 0 3
46517: PPUSH
46518: CALL 70871 0 3
46522: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46523: LD_VAR 0 3
46527: PPUSH
46528: CALL_OW 310
46532: IFFALSE 46543
// ComExitBuilding ( j ) ;
46534: LD_VAR 0 3
46538: PPUSH
46539: CALL_OW 122
// wait ( 3 ) ;
46543: LD_INT 3
46545: PPUSH
46546: CALL_OW 67
// if not mc_build_list [ i ] then
46550: LD_EXP 121
46554: PUSH
46555: LD_VAR 0 2
46559: ARRAY
46560: NOT
46561: IFFALSE 46565
// break ;
46563: GO 46664
// if not HasTask ( j ) then
46565: LD_VAR 0 3
46569: PPUSH
46570: CALL_OW 314
46574: NOT
46575: IFFALSE 46662
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46577: LD_VAR 0 3
46581: PPUSH
46582: LD_EXP 121
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_INT 1
46595: ARRAY
46596: PUSH
46597: LD_INT 1
46599: ARRAY
46600: PPUSH
46601: LD_EXP 121
46605: PUSH
46606: LD_VAR 0 2
46610: ARRAY
46611: PUSH
46612: LD_INT 1
46614: ARRAY
46615: PUSH
46616: LD_INT 2
46618: ARRAY
46619: PPUSH
46620: LD_EXP 121
46624: PUSH
46625: LD_VAR 0 2
46629: ARRAY
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: PPUSH
46639: LD_EXP 121
46643: PUSH
46644: LD_VAR 0 2
46648: ARRAY
46649: PUSH
46650: LD_INT 1
46652: ARRAY
46653: PUSH
46654: LD_INT 4
46656: ARRAY
46657: PPUSH
46658: CALL_OW 145
// end ;
46662: GO 46451
46664: POP
46665: POP
// end else
46666: GO 46838
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46668: LD_EXP 116
46672: PUSH
46673: LD_VAR 0 2
46677: ARRAY
46678: PPUSH
46679: LD_EXP 121
46683: PUSH
46684: LD_VAR 0 2
46688: ARRAY
46689: PUSH
46690: LD_INT 1
46692: ARRAY
46693: PUSH
46694: LD_INT 1
46696: ARRAY
46697: PPUSH
46698: LD_EXP 121
46702: PUSH
46703: LD_VAR 0 2
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: ARRAY
46712: PUSH
46713: LD_INT 2
46715: ARRAY
46716: PPUSH
46717: LD_EXP 121
46721: PUSH
46722: LD_VAR 0 2
46726: ARRAY
46727: PUSH
46728: LD_INT 1
46730: ARRAY
46731: PUSH
46732: LD_INT 3
46734: ARRAY
46735: PPUSH
46736: LD_EXP 121
46740: PUSH
46741: LD_VAR 0 2
46745: ARRAY
46746: PUSH
46747: LD_INT 1
46749: ARRAY
46750: PUSH
46751: LD_INT 4
46753: ARRAY
46754: PPUSH
46755: LD_EXP 116
46759: PUSH
46760: LD_VAR 0 2
46764: ARRAY
46765: PPUSH
46766: LD_INT 21
46768: PUSH
46769: LD_INT 3
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PPUSH
46776: CALL_OW 72
46780: PPUSH
46781: EMPTY
46782: PPUSH
46783: CALL 77724 0 7
46787: NOT
46788: IFFALSE 46838
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46790: LD_ADDR_EXP 121
46794: PUSH
46795: LD_EXP 121
46799: PPUSH
46800: LD_VAR 0 2
46804: PPUSH
46805: LD_EXP 121
46809: PUSH
46810: LD_VAR 0 2
46814: ARRAY
46815: PPUSH
46816: LD_INT 1
46818: PPUSH
46819: LD_INT 1
46821: NEG
46822: PPUSH
46823: LD_INT 0
46825: PPUSH
46826: CALL 70289 0 4
46830: PPUSH
46831: CALL_OW 1
46835: ST_TO_ADDR
// continue ;
46836: GO 45686
// end ; end ; end ;
46838: GO 45686
46840: POP
46841: POP
// end ;
46842: LD_VAR 0 1
46846: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46847: LD_INT 0
46849: PPUSH
46850: PPUSH
46851: PPUSH
46852: PPUSH
46853: PPUSH
46854: PPUSH
// if not mc_bases then
46855: LD_EXP 116
46859: NOT
46860: IFFALSE 46864
// exit ;
46862: GO 47291
// for i = 1 to mc_bases do
46864: LD_ADDR_VAR 0 2
46868: PUSH
46869: DOUBLE
46870: LD_INT 1
46872: DEC
46873: ST_TO_ADDR
46874: LD_EXP 116
46878: PUSH
46879: FOR_TO
46880: IFFALSE 47289
// begin tmp := mc_build_upgrade [ i ] ;
46882: LD_ADDR_VAR 0 4
46886: PUSH
46887: LD_EXP 148
46891: PUSH
46892: LD_VAR 0 2
46896: ARRAY
46897: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46898: LD_ADDR_VAR 0 6
46902: PUSH
46903: LD_EXP 149
46907: PUSH
46908: LD_VAR 0 2
46912: ARRAY
46913: PPUSH
46914: LD_INT 2
46916: PUSH
46917: LD_INT 30
46919: PUSH
46920: LD_INT 6
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 30
46929: PUSH
46930: LD_INT 7
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: LIST
46941: PPUSH
46942: CALL_OW 72
46946: ST_TO_ADDR
// if not tmp and not lab then
46947: LD_VAR 0 4
46951: NOT
46952: PUSH
46953: LD_VAR 0 6
46957: NOT
46958: AND
46959: IFFALSE 46963
// continue ;
46961: GO 46879
// if tmp then
46963: LD_VAR 0 4
46967: IFFALSE 47087
// for j in tmp do
46969: LD_ADDR_VAR 0 3
46973: PUSH
46974: LD_VAR 0 4
46978: PUSH
46979: FOR_IN
46980: IFFALSE 47085
// begin if UpgradeCost ( j ) then
46982: LD_VAR 0 3
46986: PPUSH
46987: CALL 77384 0 1
46991: IFFALSE 47083
// begin ComUpgrade ( j ) ;
46993: LD_VAR 0 3
46997: PPUSH
46998: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
47002: LD_ADDR_EXP 148
47006: PUSH
47007: LD_EXP 148
47011: PPUSH
47012: LD_VAR 0 2
47016: PPUSH
47017: LD_EXP 148
47021: PUSH
47022: LD_VAR 0 2
47026: ARRAY
47027: PUSH
47028: LD_VAR 0 3
47032: DIFF
47033: PPUSH
47034: CALL_OW 1
47038: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47039: LD_ADDR_EXP 123
47043: PUSH
47044: LD_EXP 123
47048: PPUSH
47049: LD_VAR 0 2
47053: PUSH
47054: LD_EXP 123
47058: PUSH
47059: LD_VAR 0 2
47063: ARRAY
47064: PUSH
47065: LD_INT 1
47067: PLUS
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PPUSH
47073: LD_VAR 0 3
47077: PPUSH
47078: CALL 70871 0 3
47082: ST_TO_ADDR
// end ; end ;
47083: GO 46979
47085: POP
47086: POP
// if not lab or not mc_lab_upgrade [ i ] then
47087: LD_VAR 0 6
47091: NOT
47092: PUSH
47093: LD_EXP 150
47097: PUSH
47098: LD_VAR 0 2
47102: ARRAY
47103: NOT
47104: OR
47105: IFFALSE 47109
// continue ;
47107: GO 46879
// for j in lab do
47109: LD_ADDR_VAR 0 3
47113: PUSH
47114: LD_VAR 0 6
47118: PUSH
47119: FOR_IN
47120: IFFALSE 47285
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47122: LD_VAR 0 3
47126: PPUSH
47127: CALL_OW 266
47131: PUSH
47132: LD_INT 6
47134: PUSH
47135: LD_INT 7
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: IN
47142: PUSH
47143: LD_VAR 0 3
47147: PPUSH
47148: CALL_OW 461
47152: PUSH
47153: LD_INT 1
47155: NONEQUAL
47156: AND
47157: IFFALSE 47283
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47159: LD_VAR 0 3
47163: PPUSH
47164: LD_EXP 150
47168: PUSH
47169: LD_VAR 0 2
47173: ARRAY
47174: PUSH
47175: LD_INT 1
47177: ARRAY
47178: PPUSH
47179: CALL 77589 0 2
47183: IFFALSE 47283
// begin ComCancel ( j ) ;
47185: LD_VAR 0 3
47189: PPUSH
47190: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47194: LD_VAR 0 3
47198: PPUSH
47199: LD_EXP 150
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: PUSH
47210: LD_INT 1
47212: ARRAY
47213: PPUSH
47214: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47218: LD_VAR 0 3
47222: PUSH
47223: LD_EXP 123
47227: PUSH
47228: LD_VAR 0 2
47232: ARRAY
47233: IN
47234: NOT
47235: IFFALSE 47281
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47237: LD_ADDR_EXP 123
47241: PUSH
47242: LD_EXP 123
47246: PPUSH
47247: LD_VAR 0 2
47251: PUSH
47252: LD_EXP 123
47256: PUSH
47257: LD_VAR 0 2
47261: ARRAY
47262: PUSH
47263: LD_INT 1
47265: PLUS
47266: PUSH
47267: EMPTY
47268: LIST
47269: LIST
47270: PPUSH
47271: LD_VAR 0 3
47275: PPUSH
47276: CALL 70871 0 3
47280: ST_TO_ADDR
// break ;
47281: GO 47285
// end ; end ; end ;
47283: GO 47119
47285: POP
47286: POP
// end ;
47287: GO 46879
47289: POP
47290: POP
// end ;
47291: LD_VAR 0 1
47295: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47296: LD_INT 0
47298: PPUSH
47299: PPUSH
47300: PPUSH
47301: PPUSH
47302: PPUSH
47303: PPUSH
47304: PPUSH
47305: PPUSH
47306: PPUSH
// if not mc_bases then
47307: LD_EXP 116
47311: NOT
47312: IFFALSE 47316
// exit ;
47314: GO 47721
// for i = 1 to mc_bases do
47316: LD_ADDR_VAR 0 2
47320: PUSH
47321: DOUBLE
47322: LD_INT 1
47324: DEC
47325: ST_TO_ADDR
47326: LD_EXP 116
47330: PUSH
47331: FOR_TO
47332: IFFALSE 47719
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47334: LD_EXP 124
47338: PUSH
47339: LD_VAR 0 2
47343: ARRAY
47344: NOT
47345: PUSH
47346: LD_EXP 116
47350: PUSH
47351: LD_VAR 0 2
47355: ARRAY
47356: PPUSH
47357: LD_INT 30
47359: PUSH
47360: LD_INT 3
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PPUSH
47367: CALL_OW 72
47371: NOT
47372: OR
47373: IFFALSE 47377
// continue ;
47375: GO 47331
// busy := false ;
47377: LD_ADDR_VAR 0 8
47381: PUSH
47382: LD_INT 0
47384: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47385: LD_ADDR_VAR 0 4
47389: PUSH
47390: LD_EXP 116
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PPUSH
47401: LD_INT 30
47403: PUSH
47404: LD_INT 3
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PPUSH
47411: CALL_OW 72
47415: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47416: LD_ADDR_VAR 0 6
47420: PUSH
47421: LD_EXP 124
47425: PUSH
47426: LD_VAR 0 2
47430: ARRAY
47431: PPUSH
47432: LD_INT 2
47434: PUSH
47435: LD_INT 30
47437: PUSH
47438: LD_INT 32
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: PUSH
47445: LD_INT 30
47447: PUSH
47448: LD_INT 33
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: EMPTY
47456: LIST
47457: LIST
47458: LIST
47459: PPUSH
47460: CALL_OW 72
47464: ST_TO_ADDR
// if not t then
47465: LD_VAR 0 6
47469: NOT
47470: IFFALSE 47474
// continue ;
47472: GO 47331
// for j in tmp do
47474: LD_ADDR_VAR 0 3
47478: PUSH
47479: LD_VAR 0 4
47483: PUSH
47484: FOR_IN
47485: IFFALSE 47515
// if not BuildingStatus ( j ) = bs_idle then
47487: LD_VAR 0 3
47491: PPUSH
47492: CALL_OW 461
47496: PUSH
47497: LD_INT 2
47499: EQUAL
47500: NOT
47501: IFFALSE 47513
// begin busy := true ;
47503: LD_ADDR_VAR 0 8
47507: PUSH
47508: LD_INT 1
47510: ST_TO_ADDR
// break ;
47511: GO 47515
// end ;
47513: GO 47484
47515: POP
47516: POP
// if busy then
47517: LD_VAR 0 8
47521: IFFALSE 47525
// continue ;
47523: GO 47331
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47525: LD_ADDR_VAR 0 7
47529: PUSH
47530: LD_VAR 0 6
47534: PPUSH
47535: LD_INT 35
47537: PUSH
47538: LD_INT 0
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PPUSH
47545: CALL_OW 72
47549: ST_TO_ADDR
// if tw then
47550: LD_VAR 0 7
47554: IFFALSE 47631
// begin tw := tw [ 1 ] ;
47556: LD_ADDR_VAR 0 7
47560: PUSH
47561: LD_VAR 0 7
47565: PUSH
47566: LD_INT 1
47568: ARRAY
47569: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47570: LD_ADDR_VAR 0 9
47574: PUSH
47575: LD_VAR 0 7
47579: PPUSH
47580: LD_EXP 141
47584: PUSH
47585: LD_VAR 0 2
47589: ARRAY
47590: PPUSH
47591: CALL 75881 0 2
47595: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47596: LD_EXP 155
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: IFFALSE 47629
// if not weapon in mc_allowed_tower_weapons [ i ] then
47608: LD_VAR 0 9
47612: PUSH
47613: LD_EXP 155
47617: PUSH
47618: LD_VAR 0 2
47622: ARRAY
47623: IN
47624: NOT
47625: IFFALSE 47629
// continue ;
47627: GO 47331
// end else
47629: GO 47694
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47631: LD_ADDR_VAR 0 5
47635: PUSH
47636: LD_EXP 124
47640: PUSH
47641: LD_VAR 0 2
47645: ARRAY
47646: PPUSH
47647: LD_VAR 0 4
47651: PPUSH
47652: CALL 102170 0 2
47656: ST_TO_ADDR
// if not tmp2 then
47657: LD_VAR 0 5
47661: NOT
47662: IFFALSE 47666
// continue ;
47664: GO 47331
// tw := tmp2 [ 1 ] ;
47666: LD_ADDR_VAR 0 7
47670: PUSH
47671: LD_VAR 0 5
47675: PUSH
47676: LD_INT 1
47678: ARRAY
47679: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47680: LD_ADDR_VAR 0 9
47684: PUSH
47685: LD_VAR 0 5
47689: PUSH
47690: LD_INT 2
47692: ARRAY
47693: ST_TO_ADDR
// end ; if not weapon then
47694: LD_VAR 0 9
47698: NOT
47699: IFFALSE 47703
// continue ;
47701: GO 47331
// ComPlaceWeapon ( tw , weapon ) ;
47703: LD_VAR 0 7
47707: PPUSH
47708: LD_VAR 0 9
47712: PPUSH
47713: CALL_OW 148
// end ;
47717: GO 47331
47719: POP
47720: POP
// end ;
47721: LD_VAR 0 1
47725: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47726: LD_INT 0
47728: PPUSH
47729: PPUSH
47730: PPUSH
47731: PPUSH
47732: PPUSH
47733: PPUSH
47734: PPUSH
// if not mc_bases then
47735: LD_EXP 116
47739: NOT
47740: IFFALSE 47744
// exit ;
47742: GO 48512
// for i = 1 to mc_bases do
47744: LD_ADDR_VAR 0 2
47748: PUSH
47749: DOUBLE
47750: LD_INT 1
47752: DEC
47753: ST_TO_ADDR
47754: LD_EXP 116
47758: PUSH
47759: FOR_TO
47760: IFFALSE 48510
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47762: LD_EXP 129
47766: PUSH
47767: LD_VAR 0 2
47771: ARRAY
47772: NOT
47773: PUSH
47774: LD_EXP 129
47778: PUSH
47779: LD_VAR 0 2
47783: ARRAY
47784: PUSH
47785: LD_EXP 130
47789: PUSH
47790: LD_VAR 0 2
47794: ARRAY
47795: EQUAL
47796: OR
47797: PUSH
47798: LD_EXP 139
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: OR
47809: IFFALSE 47813
// continue ;
47811: GO 47759
// if mc_miners [ i ] then
47813: LD_EXP 130
47817: PUSH
47818: LD_VAR 0 2
47822: ARRAY
47823: IFFALSE 48197
// begin for j = mc_miners [ i ] downto 1 do
47825: LD_ADDR_VAR 0 3
47829: PUSH
47830: DOUBLE
47831: LD_EXP 130
47835: PUSH
47836: LD_VAR 0 2
47840: ARRAY
47841: INC
47842: ST_TO_ADDR
47843: LD_INT 1
47845: PUSH
47846: FOR_DOWNTO
47847: IFFALSE 48195
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47849: LD_EXP 130
47853: PUSH
47854: LD_VAR 0 2
47858: ARRAY
47859: PUSH
47860: LD_VAR 0 3
47864: ARRAY
47865: PPUSH
47866: CALL_OW 301
47870: PUSH
47871: LD_EXP 130
47875: PUSH
47876: LD_VAR 0 2
47880: ARRAY
47881: PUSH
47882: LD_VAR 0 3
47886: ARRAY
47887: PPUSH
47888: CALL_OW 257
47892: PUSH
47893: LD_INT 1
47895: NONEQUAL
47896: OR
47897: IFFALSE 47960
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47899: LD_ADDR_VAR 0 5
47903: PUSH
47904: LD_EXP 130
47908: PUSH
47909: LD_VAR 0 2
47913: ARRAY
47914: PUSH
47915: LD_EXP 130
47919: PUSH
47920: LD_VAR 0 2
47924: ARRAY
47925: PUSH
47926: LD_VAR 0 3
47930: ARRAY
47931: DIFF
47932: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47933: LD_ADDR_EXP 130
47937: PUSH
47938: LD_EXP 130
47942: PPUSH
47943: LD_VAR 0 2
47947: PPUSH
47948: LD_VAR 0 5
47952: PPUSH
47953: CALL_OW 1
47957: ST_TO_ADDR
// continue ;
47958: GO 47846
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47960: LD_EXP 130
47964: PUSH
47965: LD_VAR 0 2
47969: ARRAY
47970: PUSH
47971: LD_VAR 0 3
47975: ARRAY
47976: PPUSH
47977: CALL_OW 257
47981: PUSH
47982: LD_INT 1
47984: EQUAL
47985: PUSH
47986: LD_EXP 130
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: PUSH
47997: LD_VAR 0 3
48001: ARRAY
48002: PPUSH
48003: CALL_OW 459
48007: NOT
48008: AND
48009: PUSH
48010: LD_EXP 130
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PUSH
48021: LD_VAR 0 3
48025: ARRAY
48026: PPUSH
48027: CALL_OW 314
48031: NOT
48032: AND
48033: IFFALSE 48193
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48035: LD_EXP 130
48039: PUSH
48040: LD_VAR 0 2
48044: ARRAY
48045: PUSH
48046: LD_VAR 0 3
48050: ARRAY
48051: PPUSH
48052: CALL_OW 310
48056: IFFALSE 48079
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48058: LD_EXP 130
48062: PUSH
48063: LD_VAR 0 2
48067: ARRAY
48068: PUSH
48069: LD_VAR 0 3
48073: ARRAY
48074: PPUSH
48075: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48079: LD_EXP 130
48083: PUSH
48084: LD_VAR 0 2
48088: ARRAY
48089: PUSH
48090: LD_VAR 0 3
48094: ARRAY
48095: PPUSH
48096: CALL_OW 314
48100: NOT
48101: IFFALSE 48193
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48103: LD_ADDR_VAR 0 7
48107: PUSH
48108: LD_INT 1
48110: PPUSH
48111: LD_EXP 129
48115: PUSH
48116: LD_VAR 0 2
48120: ARRAY
48121: PPUSH
48122: CALL_OW 12
48126: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48127: LD_EXP 130
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: PUSH
48138: LD_VAR 0 3
48142: ARRAY
48143: PPUSH
48144: LD_EXP 129
48148: PUSH
48149: LD_VAR 0 2
48153: ARRAY
48154: PUSH
48155: LD_VAR 0 7
48159: ARRAY
48160: PUSH
48161: LD_INT 1
48163: ARRAY
48164: PPUSH
48165: LD_EXP 129
48169: PUSH
48170: LD_VAR 0 2
48174: ARRAY
48175: PUSH
48176: LD_VAR 0 7
48180: ARRAY
48181: PUSH
48182: LD_INT 2
48184: ARRAY
48185: PPUSH
48186: LD_INT 0
48188: PPUSH
48189: CALL_OW 193
// end ; end ; end ;
48193: GO 47846
48195: POP
48196: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48197: LD_ADDR_VAR 0 5
48201: PUSH
48202: LD_EXP 116
48206: PUSH
48207: LD_VAR 0 2
48211: ARRAY
48212: PPUSH
48213: LD_INT 2
48215: PUSH
48216: LD_INT 30
48218: PUSH
48219: LD_INT 4
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_INT 30
48228: PUSH
48229: LD_INT 5
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 30
48238: PUSH
48239: LD_INT 32
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: PPUSH
48252: CALL_OW 72
48256: ST_TO_ADDR
// if not tmp then
48257: LD_VAR 0 5
48261: NOT
48262: IFFALSE 48266
// continue ;
48264: GO 47759
// list := [ ] ;
48266: LD_ADDR_VAR 0 6
48270: PUSH
48271: EMPTY
48272: ST_TO_ADDR
// for j in tmp do
48273: LD_ADDR_VAR 0 3
48277: PUSH
48278: LD_VAR 0 5
48282: PUSH
48283: FOR_IN
48284: IFFALSE 48353
// begin for k in UnitsInside ( j ) do
48286: LD_ADDR_VAR 0 4
48290: PUSH
48291: LD_VAR 0 3
48295: PPUSH
48296: CALL_OW 313
48300: PUSH
48301: FOR_IN
48302: IFFALSE 48349
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48304: LD_VAR 0 4
48308: PPUSH
48309: CALL_OW 257
48313: PUSH
48314: LD_INT 1
48316: EQUAL
48317: PUSH
48318: LD_VAR 0 4
48322: PPUSH
48323: CALL_OW 459
48327: NOT
48328: AND
48329: IFFALSE 48347
// list := list ^ k ;
48331: LD_ADDR_VAR 0 6
48335: PUSH
48336: LD_VAR 0 6
48340: PUSH
48341: LD_VAR 0 4
48345: ADD
48346: ST_TO_ADDR
48347: GO 48301
48349: POP
48350: POP
// end ;
48351: GO 48283
48353: POP
48354: POP
// list := list diff mc_miners [ i ] ;
48355: LD_ADDR_VAR 0 6
48359: PUSH
48360: LD_VAR 0 6
48364: PUSH
48365: LD_EXP 130
48369: PUSH
48370: LD_VAR 0 2
48374: ARRAY
48375: DIFF
48376: ST_TO_ADDR
// if not list then
48377: LD_VAR 0 6
48381: NOT
48382: IFFALSE 48386
// continue ;
48384: GO 47759
// k := mc_mines [ i ] - mc_miners [ i ] ;
48386: LD_ADDR_VAR 0 4
48390: PUSH
48391: LD_EXP 129
48395: PUSH
48396: LD_VAR 0 2
48400: ARRAY
48401: PUSH
48402: LD_EXP 130
48406: PUSH
48407: LD_VAR 0 2
48411: ARRAY
48412: MINUS
48413: ST_TO_ADDR
// if k > list then
48414: LD_VAR 0 4
48418: PUSH
48419: LD_VAR 0 6
48423: GREATER
48424: IFFALSE 48436
// k := list ;
48426: LD_ADDR_VAR 0 4
48430: PUSH
48431: LD_VAR 0 6
48435: ST_TO_ADDR
// for j = 1 to k do
48436: LD_ADDR_VAR 0 3
48440: PUSH
48441: DOUBLE
48442: LD_INT 1
48444: DEC
48445: ST_TO_ADDR
48446: LD_VAR 0 4
48450: PUSH
48451: FOR_TO
48452: IFFALSE 48506
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48454: LD_ADDR_EXP 130
48458: PUSH
48459: LD_EXP 130
48463: PPUSH
48464: LD_VAR 0 2
48468: PUSH
48469: LD_EXP 130
48473: PUSH
48474: LD_VAR 0 2
48478: ARRAY
48479: PUSH
48480: LD_INT 1
48482: PLUS
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PPUSH
48488: LD_VAR 0 6
48492: PUSH
48493: LD_VAR 0 3
48497: ARRAY
48498: PPUSH
48499: CALL 70871 0 3
48503: ST_TO_ADDR
48504: GO 48451
48506: POP
48507: POP
// end ;
48508: GO 47759
48510: POP
48511: POP
// end ;
48512: LD_VAR 0 1
48516: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48517: LD_INT 0
48519: PPUSH
48520: PPUSH
48521: PPUSH
48522: PPUSH
48523: PPUSH
48524: PPUSH
48525: PPUSH
48526: PPUSH
48527: PPUSH
48528: PPUSH
48529: PPUSH
// if not mc_bases then
48530: LD_EXP 116
48534: NOT
48535: IFFALSE 48539
// exit ;
48537: GO 50362
// for i = 1 to mc_bases do
48539: LD_ADDR_VAR 0 2
48543: PUSH
48544: DOUBLE
48545: LD_INT 1
48547: DEC
48548: ST_TO_ADDR
48549: LD_EXP 116
48553: PUSH
48554: FOR_TO
48555: IFFALSE 50360
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48557: LD_EXP 116
48561: PUSH
48562: LD_VAR 0 2
48566: ARRAY
48567: NOT
48568: PUSH
48569: LD_EXP 123
48573: PUSH
48574: LD_VAR 0 2
48578: ARRAY
48579: OR
48580: IFFALSE 48584
// continue ;
48582: GO 48554
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48584: LD_EXP 132
48588: PUSH
48589: LD_VAR 0 2
48593: ARRAY
48594: NOT
48595: PUSH
48596: LD_EXP 133
48600: PUSH
48601: LD_VAR 0 2
48605: ARRAY
48606: AND
48607: IFFALSE 48645
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48609: LD_ADDR_EXP 133
48613: PUSH
48614: LD_EXP 133
48618: PPUSH
48619: LD_VAR 0 2
48623: PPUSH
48624: EMPTY
48625: PPUSH
48626: CALL_OW 1
48630: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48631: LD_VAR 0 2
48635: PPUSH
48636: LD_INT 107
48638: PPUSH
48639: CALL 39413 0 2
// continue ;
48643: GO 48554
// end ; target := [ ] ;
48645: LD_ADDR_VAR 0 7
48649: PUSH
48650: EMPTY
48651: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48652: LD_ADDR_VAR 0 6
48656: PUSH
48657: LD_EXP 116
48661: PUSH
48662: LD_VAR 0 2
48666: ARRAY
48667: PUSH
48668: LD_INT 1
48670: ARRAY
48671: PPUSH
48672: CALL_OW 255
48676: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48677: LD_ADDR_VAR 0 9
48681: PUSH
48682: LD_EXP 116
48686: PUSH
48687: LD_VAR 0 2
48691: ARRAY
48692: PPUSH
48693: LD_INT 2
48695: PUSH
48696: LD_INT 30
48698: PUSH
48699: LD_INT 0
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: PUSH
48706: LD_INT 30
48708: PUSH
48709: LD_INT 1
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: LIST
48720: PPUSH
48721: CALL_OW 72
48725: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48726: LD_ADDR_VAR 0 3
48730: PUSH
48731: DOUBLE
48732: LD_EXP 132
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: INC
48743: ST_TO_ADDR
48744: LD_INT 1
48746: PUSH
48747: FOR_DOWNTO
48748: IFFALSE 48993
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48750: LD_EXP 132
48754: PUSH
48755: LD_VAR 0 2
48759: ARRAY
48760: PUSH
48761: LD_VAR 0 3
48765: ARRAY
48766: PUSH
48767: LD_INT 2
48769: ARRAY
48770: PPUSH
48771: LD_EXP 132
48775: PUSH
48776: LD_VAR 0 2
48780: ARRAY
48781: PUSH
48782: LD_VAR 0 3
48786: ARRAY
48787: PUSH
48788: LD_INT 3
48790: ARRAY
48791: PPUSH
48792: CALL_OW 488
48796: PUSH
48797: LD_EXP 132
48801: PUSH
48802: LD_VAR 0 2
48806: ARRAY
48807: PUSH
48808: LD_VAR 0 3
48812: ARRAY
48813: PUSH
48814: LD_INT 2
48816: ARRAY
48817: PPUSH
48818: LD_EXP 132
48822: PUSH
48823: LD_VAR 0 2
48827: ARRAY
48828: PUSH
48829: LD_VAR 0 3
48833: ARRAY
48834: PUSH
48835: LD_INT 3
48837: ARRAY
48838: PPUSH
48839: CALL_OW 284
48843: PUSH
48844: LD_INT 0
48846: EQUAL
48847: AND
48848: IFFALSE 48903
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48850: LD_ADDR_VAR 0 5
48854: PUSH
48855: LD_EXP 132
48859: PUSH
48860: LD_VAR 0 2
48864: ARRAY
48865: PPUSH
48866: LD_VAR 0 3
48870: PPUSH
48871: CALL_OW 3
48875: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48876: LD_ADDR_EXP 132
48880: PUSH
48881: LD_EXP 132
48885: PPUSH
48886: LD_VAR 0 2
48890: PPUSH
48891: LD_VAR 0 5
48895: PPUSH
48896: CALL_OW 1
48900: ST_TO_ADDR
// continue ;
48901: GO 48747
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48903: LD_VAR 0 6
48907: PPUSH
48908: LD_EXP 132
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: PUSH
48919: LD_VAR 0 3
48923: ARRAY
48924: PUSH
48925: LD_INT 2
48927: ARRAY
48928: PPUSH
48929: LD_EXP 132
48933: PUSH
48934: LD_VAR 0 2
48938: ARRAY
48939: PUSH
48940: LD_VAR 0 3
48944: ARRAY
48945: PUSH
48946: LD_INT 3
48948: ARRAY
48949: PPUSH
48950: LD_INT 30
48952: PPUSH
48953: CALL 71767 0 4
48957: PUSH
48958: LD_INT 4
48960: ARRAY
48961: PUSH
48962: LD_INT 0
48964: EQUAL
48965: IFFALSE 48991
// begin target := mc_crates [ i ] [ j ] ;
48967: LD_ADDR_VAR 0 7
48971: PUSH
48972: LD_EXP 132
48976: PUSH
48977: LD_VAR 0 2
48981: ARRAY
48982: PUSH
48983: LD_VAR 0 3
48987: ARRAY
48988: ST_TO_ADDR
// break ;
48989: GO 48993
// end ; end ;
48991: GO 48747
48993: POP
48994: POP
// if not target then
48995: LD_VAR 0 7
48999: NOT
49000: IFFALSE 49004
// continue ;
49002: GO 48554
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
49004: LD_ADDR_VAR 0 8
49008: PUSH
49009: LD_EXP 135
49013: PUSH
49014: LD_VAR 0 2
49018: ARRAY
49019: PPUSH
49020: LD_INT 2
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 58
49028: PUSH
49029: EMPTY
49030: LIST
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 61
49038: PUSH
49039: EMPTY
49040: LIST
49041: PUSH
49042: LD_INT 33
49044: PUSH
49045: LD_INT 5
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PUSH
49052: LD_INT 33
49054: PUSH
49055: LD_INT 3
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 2
49071: PUSH
49072: LD_INT 34
49074: PUSH
49075: LD_INT 32
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: PUSH
49082: LD_INT 34
49084: PUSH
49085: LD_INT 51
49087: PUSH
49088: EMPTY
49089: LIST
49090: LIST
49091: PUSH
49092: LD_INT 34
49094: PUSH
49095: LD_INT 12
49097: PUSH
49098: EMPTY
49099: LIST
49100: LIST
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PPUSH
49112: CALL_OW 72
49116: ST_TO_ADDR
// if not cargo then
49117: LD_VAR 0 8
49121: NOT
49122: IFFALSE 49828
// begin if mc_crates_collector [ i ] < 5 then
49124: LD_EXP 133
49128: PUSH
49129: LD_VAR 0 2
49133: ARRAY
49134: PUSH
49135: LD_INT 5
49137: LESS
49138: IFFALSE 49504
// begin if mc_ape [ i ] then
49140: LD_EXP 145
49144: PUSH
49145: LD_VAR 0 2
49149: ARRAY
49150: IFFALSE 49197
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49152: LD_ADDR_VAR 0 5
49156: PUSH
49157: LD_EXP 145
49161: PUSH
49162: LD_VAR 0 2
49166: ARRAY
49167: PPUSH
49168: LD_INT 25
49170: PUSH
49171: LD_INT 16
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PUSH
49178: LD_INT 24
49180: PUSH
49181: LD_INT 750
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: PPUSH
49192: CALL_OW 72
49196: ST_TO_ADDR
// if not tmp then
49197: LD_VAR 0 5
49201: NOT
49202: IFFALSE 49249
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49204: LD_ADDR_VAR 0 5
49208: PUSH
49209: LD_EXP 116
49213: PUSH
49214: LD_VAR 0 2
49218: ARRAY
49219: PPUSH
49220: LD_INT 25
49222: PUSH
49223: LD_INT 2
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PUSH
49230: LD_INT 24
49232: PUSH
49233: LD_INT 750
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PPUSH
49244: CALL_OW 72
49248: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49249: LD_EXP 145
49253: PUSH
49254: LD_VAR 0 2
49258: ARRAY
49259: PUSH
49260: LD_EXP 116
49264: PUSH
49265: LD_VAR 0 2
49269: ARRAY
49270: PPUSH
49271: LD_INT 25
49273: PUSH
49274: LD_INT 2
49276: PUSH
49277: EMPTY
49278: LIST
49279: LIST
49280: PUSH
49281: LD_INT 24
49283: PUSH
49284: LD_INT 750
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: EMPTY
49292: LIST
49293: LIST
49294: PPUSH
49295: CALL_OW 72
49299: AND
49300: PUSH
49301: LD_VAR 0 5
49305: PUSH
49306: LD_INT 5
49308: LESS
49309: AND
49310: IFFALSE 49392
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49312: LD_ADDR_VAR 0 3
49316: PUSH
49317: LD_EXP 116
49321: PUSH
49322: LD_VAR 0 2
49326: ARRAY
49327: PPUSH
49328: LD_INT 25
49330: PUSH
49331: LD_INT 2
49333: PUSH
49334: EMPTY
49335: LIST
49336: LIST
49337: PUSH
49338: LD_INT 24
49340: PUSH
49341: LD_INT 750
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PUSH
49348: EMPTY
49349: LIST
49350: LIST
49351: PPUSH
49352: CALL_OW 72
49356: PUSH
49357: FOR_IN
49358: IFFALSE 49390
// begin tmp := tmp union j ;
49360: LD_ADDR_VAR 0 5
49364: PUSH
49365: LD_VAR 0 5
49369: PUSH
49370: LD_VAR 0 3
49374: UNION
49375: ST_TO_ADDR
// if tmp >= 5 then
49376: LD_VAR 0 5
49380: PUSH
49381: LD_INT 5
49383: GREATEREQUAL
49384: IFFALSE 49388
// break ;
49386: GO 49390
// end ;
49388: GO 49357
49390: POP
49391: POP
// end ; if not tmp then
49392: LD_VAR 0 5
49396: NOT
49397: IFFALSE 49401
// continue ;
49399: GO 48554
// for j in tmp do
49401: LD_ADDR_VAR 0 3
49405: PUSH
49406: LD_VAR 0 5
49410: PUSH
49411: FOR_IN
49412: IFFALSE 49502
// if not GetTag ( j ) then
49414: LD_VAR 0 3
49418: PPUSH
49419: CALL_OW 110
49423: NOT
49424: IFFALSE 49500
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49426: LD_ADDR_EXP 133
49430: PUSH
49431: LD_EXP 133
49435: PPUSH
49436: LD_VAR 0 2
49440: PUSH
49441: LD_EXP 133
49445: PUSH
49446: LD_VAR 0 2
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: PLUS
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PPUSH
49460: LD_VAR 0 3
49464: PPUSH
49465: CALL 70871 0 3
49469: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49470: LD_VAR 0 3
49474: PPUSH
49475: LD_INT 107
49477: PPUSH
49478: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49482: LD_EXP 133
49486: PUSH
49487: LD_VAR 0 2
49491: ARRAY
49492: PUSH
49493: LD_INT 5
49495: GREATEREQUAL
49496: IFFALSE 49500
// break ;
49498: GO 49502
// end ;
49500: GO 49411
49502: POP
49503: POP
// end ; if mc_crates_collector [ i ] and target then
49504: LD_EXP 133
49508: PUSH
49509: LD_VAR 0 2
49513: ARRAY
49514: PUSH
49515: LD_VAR 0 7
49519: AND
49520: IFFALSE 49826
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49522: LD_EXP 133
49526: PUSH
49527: LD_VAR 0 2
49531: ARRAY
49532: PUSH
49533: LD_VAR 0 7
49537: PUSH
49538: LD_INT 1
49540: ARRAY
49541: LESS
49542: IFFALSE 49562
// tmp := mc_crates_collector [ i ] else
49544: LD_ADDR_VAR 0 5
49548: PUSH
49549: LD_EXP 133
49553: PUSH
49554: LD_VAR 0 2
49558: ARRAY
49559: ST_TO_ADDR
49560: GO 49576
// tmp := target [ 1 ] ;
49562: LD_ADDR_VAR 0 5
49566: PUSH
49567: LD_VAR 0 7
49571: PUSH
49572: LD_INT 1
49574: ARRAY
49575: ST_TO_ADDR
// k := 0 ;
49576: LD_ADDR_VAR 0 4
49580: PUSH
49581: LD_INT 0
49583: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49584: LD_ADDR_VAR 0 3
49588: PUSH
49589: LD_EXP 133
49593: PUSH
49594: LD_VAR 0 2
49598: ARRAY
49599: PUSH
49600: FOR_IN
49601: IFFALSE 49824
// begin k := k + 1 ;
49603: LD_ADDR_VAR 0 4
49607: PUSH
49608: LD_VAR 0 4
49612: PUSH
49613: LD_INT 1
49615: PLUS
49616: ST_TO_ADDR
// if k > tmp then
49617: LD_VAR 0 4
49621: PUSH
49622: LD_VAR 0 5
49626: GREATER
49627: IFFALSE 49631
// break ;
49629: GO 49824
// if not GetClass ( j ) in [ 2 , 16 ] then
49631: LD_VAR 0 3
49635: PPUSH
49636: CALL_OW 257
49640: PUSH
49641: LD_INT 2
49643: PUSH
49644: LD_INT 16
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: IN
49651: NOT
49652: IFFALSE 49705
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49654: LD_ADDR_EXP 133
49658: PUSH
49659: LD_EXP 133
49663: PPUSH
49664: LD_VAR 0 2
49668: PPUSH
49669: LD_EXP 133
49673: PUSH
49674: LD_VAR 0 2
49678: ARRAY
49679: PUSH
49680: LD_VAR 0 3
49684: DIFF
49685: PPUSH
49686: CALL_OW 1
49690: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49691: LD_VAR 0 3
49695: PPUSH
49696: LD_INT 0
49698: PPUSH
49699: CALL_OW 109
// continue ;
49703: GO 49600
// end ; if IsInUnit ( j ) then
49705: LD_VAR 0 3
49709: PPUSH
49710: CALL_OW 310
49714: IFFALSE 49725
// ComExitBuilding ( j ) ;
49716: LD_VAR 0 3
49720: PPUSH
49721: CALL_OW 122
// wait ( 3 ) ;
49725: LD_INT 3
49727: PPUSH
49728: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49732: LD_VAR 0 3
49736: PPUSH
49737: CALL_OW 314
49741: PUSH
49742: LD_VAR 0 6
49746: PPUSH
49747: LD_VAR 0 7
49751: PUSH
49752: LD_INT 2
49754: ARRAY
49755: PPUSH
49756: LD_VAR 0 7
49760: PUSH
49761: LD_INT 3
49763: ARRAY
49764: PPUSH
49765: LD_INT 30
49767: PPUSH
49768: CALL 71767 0 4
49772: PUSH
49773: LD_INT 4
49775: ARRAY
49776: AND
49777: IFFALSE 49795
// ComStandNearbyBuilding ( j , depot ) else
49779: LD_VAR 0 3
49783: PPUSH
49784: LD_VAR 0 9
49788: PPUSH
49789: CALL 67449 0 2
49793: GO 49822
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49795: LD_VAR 0 3
49799: PPUSH
49800: LD_VAR 0 7
49804: PUSH
49805: LD_INT 2
49807: ARRAY
49808: PPUSH
49809: LD_VAR 0 7
49813: PUSH
49814: LD_INT 3
49816: ARRAY
49817: PPUSH
49818: CALL_OW 117
// end ;
49822: GO 49600
49824: POP
49825: POP
// end ; end else
49826: GO 50358
// begin for j in cargo do
49828: LD_ADDR_VAR 0 3
49832: PUSH
49833: LD_VAR 0 8
49837: PUSH
49838: FOR_IN
49839: IFFALSE 50356
// begin if GetTag ( j ) <> 0 then
49841: LD_VAR 0 3
49845: PPUSH
49846: CALL_OW 110
49850: PUSH
49851: LD_INT 0
49853: NONEQUAL
49854: IFFALSE 49858
// continue ;
49856: GO 49838
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL_OW 256
49867: PUSH
49868: LD_INT 1000
49870: LESS
49871: PUSH
49872: LD_VAR 0 3
49876: PPUSH
49877: LD_EXP 140
49881: PUSH
49882: LD_VAR 0 2
49886: ARRAY
49887: PPUSH
49888: CALL_OW 308
49892: NOT
49893: AND
49894: IFFALSE 49916
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49896: LD_VAR 0 3
49900: PPUSH
49901: LD_EXP 140
49905: PUSH
49906: LD_VAR 0 2
49910: ARRAY
49911: PPUSH
49912: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49916: LD_VAR 0 3
49920: PPUSH
49921: CALL_OW 256
49925: PUSH
49926: LD_INT 1000
49928: LESS
49929: PUSH
49930: LD_VAR 0 3
49934: PPUSH
49935: LD_EXP 140
49939: PUSH
49940: LD_VAR 0 2
49944: ARRAY
49945: PPUSH
49946: CALL_OW 308
49950: AND
49951: IFFALSE 49955
// continue ;
49953: GO 49838
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49955: LD_VAR 0 3
49959: PPUSH
49960: CALL_OW 262
49964: PUSH
49965: LD_INT 2
49967: EQUAL
49968: PUSH
49969: LD_VAR 0 3
49973: PPUSH
49974: CALL_OW 261
49978: PUSH
49979: LD_INT 15
49981: LESS
49982: AND
49983: IFFALSE 49987
// continue ;
49985: GO 49838
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49987: LD_VAR 0 3
49991: PPUSH
49992: CALL_OW 262
49996: PUSH
49997: LD_INT 1
49999: EQUAL
50000: PUSH
50001: LD_VAR 0 3
50005: PPUSH
50006: CALL_OW 261
50010: PUSH
50011: LD_INT 10
50013: LESS
50014: AND
50015: IFFALSE 50295
// begin if not depot then
50017: LD_VAR 0 9
50021: NOT
50022: IFFALSE 50026
// continue ;
50024: GO 49838
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50026: LD_VAR 0 3
50030: PPUSH
50031: LD_VAR 0 9
50035: PPUSH
50036: LD_VAR 0 3
50040: PPUSH
50041: CALL_OW 74
50045: PPUSH
50046: CALL_OW 296
50050: PUSH
50051: LD_INT 6
50053: LESS
50054: IFFALSE 50070
// SetFuel ( j , 100 ) else
50056: LD_VAR 0 3
50060: PPUSH
50061: LD_INT 100
50063: PPUSH
50064: CALL_OW 240
50068: GO 50295
// if GetFuel ( j ) = 0 then
50070: LD_VAR 0 3
50074: PPUSH
50075: CALL_OW 261
50079: PUSH
50080: LD_INT 0
50082: EQUAL
50083: IFFALSE 50295
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50085: LD_ADDR_EXP 135
50089: PUSH
50090: LD_EXP 135
50094: PPUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: LD_EXP 135
50104: PUSH
50105: LD_VAR 0 2
50109: ARRAY
50110: PUSH
50111: LD_VAR 0 3
50115: DIFF
50116: PPUSH
50117: CALL_OW 1
50121: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50122: LD_VAR 0 3
50126: PPUSH
50127: CALL_OW 263
50131: PUSH
50132: LD_INT 1
50134: EQUAL
50135: IFFALSE 50151
// ComExitVehicle ( IsInUnit ( j ) ) ;
50137: LD_VAR 0 3
50141: PPUSH
50142: CALL_OW 310
50146: PPUSH
50147: CALL_OW 121
// if GetControl ( j ) = control_remote then
50151: LD_VAR 0 3
50155: PPUSH
50156: CALL_OW 263
50160: PUSH
50161: LD_INT 2
50163: EQUAL
50164: IFFALSE 50175
// ComUnlink ( j ) ;
50166: LD_VAR 0 3
50170: PPUSH
50171: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50175: LD_ADDR_VAR 0 10
50179: PUSH
50180: LD_VAR 0 2
50184: PPUSH
50185: LD_INT 3
50187: PPUSH
50188: CALL 59934 0 2
50192: ST_TO_ADDR
// if fac then
50193: LD_VAR 0 10
50197: IFFALSE 50293
// begin for k in fac do
50199: LD_ADDR_VAR 0 4
50203: PUSH
50204: LD_VAR 0 10
50208: PUSH
50209: FOR_IN
50210: IFFALSE 50291
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50212: LD_ADDR_VAR 0 11
50216: PUSH
50217: LD_VAR 0 10
50221: PPUSH
50222: LD_VAR 0 3
50226: PPUSH
50227: CALL_OW 265
50231: PPUSH
50232: LD_VAR 0 3
50236: PPUSH
50237: CALL_OW 262
50241: PPUSH
50242: LD_VAR 0 3
50246: PPUSH
50247: CALL_OW 263
50251: PPUSH
50252: LD_VAR 0 3
50256: PPUSH
50257: CALL_OW 264
50261: PPUSH
50262: CALL 68367 0 5
50266: ST_TO_ADDR
// if components then
50267: LD_VAR 0 11
50271: IFFALSE 50289
// begin MC_InsertProduceList ( i , components ) ;
50273: LD_VAR 0 2
50277: PPUSH
50278: LD_VAR 0 11
50282: PPUSH
50283: CALL 59479 0 2
// break ;
50287: GO 50291
// end ; end ;
50289: GO 50209
50291: POP
50292: POP
// end ; continue ;
50293: GO 49838
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50295: LD_VAR 0 3
50299: PPUSH
50300: LD_INT 1
50302: PPUSH
50303: CALL_OW 289
50307: PUSH
50308: LD_INT 100
50310: LESS
50311: PUSH
50312: LD_VAR 0 3
50316: PPUSH
50317: CALL_OW 314
50321: NOT
50322: AND
50323: IFFALSE 50352
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50325: LD_VAR 0 3
50329: PPUSH
50330: LD_VAR 0 7
50334: PUSH
50335: LD_INT 2
50337: ARRAY
50338: PPUSH
50339: LD_VAR 0 7
50343: PUSH
50344: LD_INT 3
50346: ARRAY
50347: PPUSH
50348: CALL_OW 117
// break ;
50352: GO 50356
// end ;
50354: GO 49838
50356: POP
50357: POP
// end ; end ;
50358: GO 48554
50360: POP
50361: POP
// end ;
50362: LD_VAR 0 1
50366: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50367: LD_INT 0
50369: PPUSH
50370: PPUSH
50371: PPUSH
50372: PPUSH
// if not mc_bases then
50373: LD_EXP 116
50377: NOT
50378: IFFALSE 50382
// exit ;
50380: GO 50543
// for i = 1 to mc_bases do
50382: LD_ADDR_VAR 0 2
50386: PUSH
50387: DOUBLE
50388: LD_INT 1
50390: DEC
50391: ST_TO_ADDR
50392: LD_EXP 116
50396: PUSH
50397: FOR_TO
50398: IFFALSE 50541
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50400: LD_ADDR_VAR 0 4
50404: PUSH
50405: LD_EXP 135
50409: PUSH
50410: LD_VAR 0 2
50414: ARRAY
50415: PUSH
50416: LD_EXP 138
50420: PUSH
50421: LD_VAR 0 2
50425: ARRAY
50426: UNION
50427: PPUSH
50428: LD_INT 33
50430: PUSH
50431: LD_INT 2
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PPUSH
50438: CALL_OW 72
50442: ST_TO_ADDR
// if tmp then
50443: LD_VAR 0 4
50447: IFFALSE 50539
// for j in tmp do
50449: LD_ADDR_VAR 0 3
50453: PUSH
50454: LD_VAR 0 4
50458: PUSH
50459: FOR_IN
50460: IFFALSE 50537
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50462: LD_VAR 0 3
50466: PPUSH
50467: CALL_OW 312
50471: NOT
50472: PUSH
50473: LD_VAR 0 3
50477: PPUSH
50478: CALL_OW 256
50482: PUSH
50483: LD_INT 250
50485: GREATEREQUAL
50486: AND
50487: IFFALSE 50500
// Connect ( j ) else
50489: LD_VAR 0 3
50493: PPUSH
50494: CALL 73842 0 1
50498: GO 50535
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50500: LD_VAR 0 3
50504: PPUSH
50505: CALL_OW 256
50509: PUSH
50510: LD_INT 250
50512: LESS
50513: PUSH
50514: LD_VAR 0 3
50518: PPUSH
50519: CALL_OW 312
50523: AND
50524: IFFALSE 50535
// ComUnlink ( j ) ;
50526: LD_VAR 0 3
50530: PPUSH
50531: CALL_OW 136
50535: GO 50459
50537: POP
50538: POP
// end ;
50539: GO 50397
50541: POP
50542: POP
// end ;
50543: LD_VAR 0 1
50547: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50548: LD_INT 0
50550: PPUSH
50551: PPUSH
50552: PPUSH
50553: PPUSH
50554: PPUSH
// if not mc_bases then
50555: LD_EXP 116
50559: NOT
50560: IFFALSE 50564
// exit ;
50562: GO 51009
// for i = 1 to mc_bases do
50564: LD_ADDR_VAR 0 2
50568: PUSH
50569: DOUBLE
50570: LD_INT 1
50572: DEC
50573: ST_TO_ADDR
50574: LD_EXP 116
50578: PUSH
50579: FOR_TO
50580: IFFALSE 51007
// begin if not mc_produce [ i ] then
50582: LD_EXP 137
50586: PUSH
50587: LD_VAR 0 2
50591: ARRAY
50592: NOT
50593: IFFALSE 50597
// continue ;
50595: GO 50579
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50597: LD_ADDR_VAR 0 5
50601: PUSH
50602: LD_EXP 116
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PPUSH
50613: LD_INT 30
50615: PUSH
50616: LD_INT 3
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: CALL_OW 72
50627: ST_TO_ADDR
// if not fac then
50628: LD_VAR 0 5
50632: NOT
50633: IFFALSE 50637
// continue ;
50635: GO 50579
// for j in fac do
50637: LD_ADDR_VAR 0 3
50641: PUSH
50642: LD_VAR 0 5
50646: PUSH
50647: FOR_IN
50648: IFFALSE 51003
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50650: LD_VAR 0 3
50654: PPUSH
50655: CALL_OW 461
50659: PUSH
50660: LD_INT 2
50662: NONEQUAL
50663: PUSH
50664: LD_VAR 0 3
50668: PPUSH
50669: LD_INT 15
50671: PPUSH
50672: CALL 73470 0 2
50676: PUSH
50677: LD_INT 4
50679: ARRAY
50680: OR
50681: IFFALSE 50685
// continue ;
50683: GO 50647
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50685: LD_VAR 0 3
50689: PPUSH
50690: LD_EXP 137
50694: PUSH
50695: LD_VAR 0 2
50699: ARRAY
50700: PUSH
50701: LD_INT 1
50703: ARRAY
50704: PUSH
50705: LD_INT 1
50707: ARRAY
50708: PPUSH
50709: LD_EXP 137
50713: PUSH
50714: LD_VAR 0 2
50718: ARRAY
50719: PUSH
50720: LD_INT 1
50722: ARRAY
50723: PUSH
50724: LD_INT 2
50726: ARRAY
50727: PPUSH
50728: LD_EXP 137
50732: PUSH
50733: LD_VAR 0 2
50737: ARRAY
50738: PUSH
50739: LD_INT 1
50741: ARRAY
50742: PUSH
50743: LD_INT 3
50745: ARRAY
50746: PPUSH
50747: LD_EXP 137
50751: PUSH
50752: LD_VAR 0 2
50756: ARRAY
50757: PUSH
50758: LD_INT 1
50760: ARRAY
50761: PUSH
50762: LD_INT 4
50764: ARRAY
50765: PPUSH
50766: CALL_OW 448
50770: PUSH
50771: LD_VAR 0 3
50775: PPUSH
50776: LD_EXP 137
50780: PUSH
50781: LD_VAR 0 2
50785: ARRAY
50786: PUSH
50787: LD_INT 1
50789: ARRAY
50790: PUSH
50791: LD_INT 1
50793: ARRAY
50794: PUSH
50795: LD_EXP 137
50799: PUSH
50800: LD_VAR 0 2
50804: ARRAY
50805: PUSH
50806: LD_INT 1
50808: ARRAY
50809: PUSH
50810: LD_INT 2
50812: ARRAY
50813: PUSH
50814: LD_EXP 137
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: PUSH
50825: LD_INT 1
50827: ARRAY
50828: PUSH
50829: LD_INT 3
50831: ARRAY
50832: PUSH
50833: LD_EXP 137
50837: PUSH
50838: LD_VAR 0 2
50842: ARRAY
50843: PUSH
50844: LD_INT 1
50846: ARRAY
50847: PUSH
50848: LD_INT 4
50850: ARRAY
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: LIST
50856: LIST
50857: PPUSH
50858: CALL 77237 0 2
50862: AND
50863: IFFALSE 51001
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50865: LD_VAR 0 3
50869: PPUSH
50870: LD_EXP 137
50874: PUSH
50875: LD_VAR 0 2
50879: ARRAY
50880: PUSH
50881: LD_INT 1
50883: ARRAY
50884: PUSH
50885: LD_INT 1
50887: ARRAY
50888: PPUSH
50889: LD_EXP 137
50893: PUSH
50894: LD_VAR 0 2
50898: ARRAY
50899: PUSH
50900: LD_INT 1
50902: ARRAY
50903: PUSH
50904: LD_INT 2
50906: ARRAY
50907: PPUSH
50908: LD_EXP 137
50912: PUSH
50913: LD_VAR 0 2
50917: ARRAY
50918: PUSH
50919: LD_INT 1
50921: ARRAY
50922: PUSH
50923: LD_INT 3
50925: ARRAY
50926: PPUSH
50927: LD_EXP 137
50931: PUSH
50932: LD_VAR 0 2
50936: ARRAY
50937: PUSH
50938: LD_INT 1
50940: ARRAY
50941: PUSH
50942: LD_INT 4
50944: ARRAY
50945: PPUSH
50946: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50950: LD_ADDR_VAR 0 4
50954: PUSH
50955: LD_EXP 137
50959: PUSH
50960: LD_VAR 0 2
50964: ARRAY
50965: PPUSH
50966: LD_INT 1
50968: PPUSH
50969: CALL_OW 3
50973: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50974: LD_ADDR_EXP 137
50978: PUSH
50979: LD_EXP 137
50983: PPUSH
50984: LD_VAR 0 2
50988: PPUSH
50989: LD_VAR 0 4
50993: PPUSH
50994: CALL_OW 1
50998: ST_TO_ADDR
// break ;
50999: GO 51003
// end ; end ;
51001: GO 50647
51003: POP
51004: POP
// end ;
51005: GO 50579
51007: POP
51008: POP
// end ;
51009: LD_VAR 0 1
51013: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51014: LD_INT 0
51016: PPUSH
51017: PPUSH
51018: PPUSH
// if not mc_bases then
51019: LD_EXP 116
51023: NOT
51024: IFFALSE 51028
// exit ;
51026: GO 51117
// for i = 1 to mc_bases do
51028: LD_ADDR_VAR 0 2
51032: PUSH
51033: DOUBLE
51034: LD_INT 1
51036: DEC
51037: ST_TO_ADDR
51038: LD_EXP 116
51042: PUSH
51043: FOR_TO
51044: IFFALSE 51115
// begin if mc_attack [ i ] then
51046: LD_EXP 136
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: IFFALSE 51113
// begin tmp := mc_attack [ i ] [ 1 ] ;
51058: LD_ADDR_VAR 0 3
51062: PUSH
51063: LD_EXP 136
51067: PUSH
51068: LD_VAR 0 2
51072: ARRAY
51073: PUSH
51074: LD_INT 1
51076: ARRAY
51077: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51078: LD_ADDR_EXP 136
51082: PUSH
51083: LD_EXP 136
51087: PPUSH
51088: LD_VAR 0 2
51092: PPUSH
51093: EMPTY
51094: PPUSH
51095: CALL_OW 1
51099: ST_TO_ADDR
// Attack ( tmp ) ;
51100: LD_VAR 0 3
51104: PPUSH
51105: CALL 123230 0 1
// exit ;
51109: POP
51110: POP
51111: GO 51117
// end ; end ;
51113: GO 51043
51115: POP
51116: POP
// end ;
51117: LD_VAR 0 1
51121: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51122: LD_INT 0
51124: PPUSH
51125: PPUSH
51126: PPUSH
51127: PPUSH
51128: PPUSH
51129: PPUSH
51130: PPUSH
// if not mc_bases then
51131: LD_EXP 116
51135: NOT
51136: IFFALSE 51140
// exit ;
51138: GO 51997
// for i = 1 to mc_bases do
51140: LD_ADDR_VAR 0 2
51144: PUSH
51145: DOUBLE
51146: LD_INT 1
51148: DEC
51149: ST_TO_ADDR
51150: LD_EXP 116
51154: PUSH
51155: FOR_TO
51156: IFFALSE 51995
// begin if not mc_bases [ i ] then
51158: LD_EXP 116
51162: PUSH
51163: LD_VAR 0 2
51167: ARRAY
51168: NOT
51169: IFFALSE 51173
// continue ;
51171: GO 51155
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51173: LD_ADDR_VAR 0 7
51177: PUSH
51178: LD_EXP 116
51182: PUSH
51183: LD_VAR 0 2
51187: ARRAY
51188: PUSH
51189: LD_INT 1
51191: ARRAY
51192: PPUSH
51193: CALL 67671 0 1
51197: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51198: LD_ADDR_EXP 139
51202: PUSH
51203: LD_EXP 139
51207: PPUSH
51208: LD_VAR 0 2
51212: PPUSH
51213: LD_EXP 116
51217: PUSH
51218: LD_VAR 0 2
51222: ARRAY
51223: PUSH
51224: LD_INT 1
51226: ARRAY
51227: PPUSH
51228: CALL_OW 255
51232: PPUSH
51233: LD_EXP 141
51237: PUSH
51238: LD_VAR 0 2
51242: ARRAY
51243: PPUSH
51244: CALL 67636 0 2
51248: PPUSH
51249: CALL_OW 1
51253: ST_TO_ADDR
// if not mc_scan [ i ] then
51254: LD_EXP 139
51258: PUSH
51259: LD_VAR 0 2
51263: ARRAY
51264: NOT
51265: IFFALSE 51443
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51267: LD_ADDR_EXP 159
51271: PUSH
51272: LD_EXP 159
51276: PPUSH
51277: LD_VAR 0 2
51281: PPUSH
51282: LD_INT 0
51284: PPUSH
51285: CALL_OW 1
51289: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51290: LD_ADDR_VAR 0 4
51294: PUSH
51295: LD_EXP 116
51299: PUSH
51300: LD_VAR 0 2
51304: ARRAY
51305: PPUSH
51306: LD_INT 2
51308: PUSH
51309: LD_INT 25
51311: PUSH
51312: LD_INT 5
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: PUSH
51319: LD_INT 25
51321: PUSH
51322: LD_INT 8
51324: PUSH
51325: EMPTY
51326: LIST
51327: LIST
51328: PUSH
51329: LD_INT 25
51331: PUSH
51332: LD_INT 9
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: PUSH
51339: EMPTY
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: PPUSH
51345: CALL_OW 72
51349: ST_TO_ADDR
// if not tmp then
51350: LD_VAR 0 4
51354: NOT
51355: IFFALSE 51359
// continue ;
51357: GO 51155
// for j in tmp do
51359: LD_ADDR_VAR 0 3
51363: PUSH
51364: LD_VAR 0 4
51368: PUSH
51369: FOR_IN
51370: IFFALSE 51441
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51372: LD_VAR 0 3
51376: PPUSH
51377: CALL_OW 310
51381: PPUSH
51382: CALL_OW 266
51386: PUSH
51387: LD_INT 5
51389: EQUAL
51390: PUSH
51391: LD_VAR 0 3
51395: PPUSH
51396: CALL_OW 257
51400: PUSH
51401: LD_INT 1
51403: EQUAL
51404: AND
51405: PUSH
51406: LD_VAR 0 3
51410: PPUSH
51411: CALL_OW 459
51415: NOT
51416: AND
51417: PUSH
51418: LD_VAR 0 7
51422: AND
51423: IFFALSE 51439
// ComChangeProfession ( j , class ) ;
51425: LD_VAR 0 3
51429: PPUSH
51430: LD_VAR 0 7
51434: PPUSH
51435: CALL_OW 123
51439: GO 51369
51441: POP
51442: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51443: LD_EXP 139
51447: PUSH
51448: LD_VAR 0 2
51452: ARRAY
51453: PUSH
51454: LD_EXP 159
51458: PUSH
51459: LD_VAR 0 2
51463: ARRAY
51464: NOT
51465: AND
51466: PUSH
51467: LD_EXP 138
51471: PUSH
51472: LD_VAR 0 2
51476: ARRAY
51477: NOT
51478: AND
51479: PUSH
51480: LD_EXP 116
51484: PUSH
51485: LD_VAR 0 2
51489: ARRAY
51490: PPUSH
51491: LD_INT 50
51493: PUSH
51494: EMPTY
51495: LIST
51496: PUSH
51497: LD_INT 2
51499: PUSH
51500: LD_INT 30
51502: PUSH
51503: LD_INT 32
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: PUSH
51510: LD_INT 30
51512: PUSH
51513: LD_INT 33
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: PUSH
51520: LD_INT 30
51522: PUSH
51523: LD_INT 4
51525: PUSH
51526: EMPTY
51527: LIST
51528: LIST
51529: PUSH
51530: LD_INT 30
51532: PUSH
51533: LD_INT 5
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PPUSH
51551: CALL_OW 72
51555: PUSH
51556: LD_INT 4
51558: LESS
51559: PUSH
51560: LD_EXP 116
51564: PUSH
51565: LD_VAR 0 2
51569: ARRAY
51570: PPUSH
51571: LD_INT 3
51573: PUSH
51574: LD_INT 24
51576: PUSH
51577: LD_INT 1000
51579: PUSH
51580: EMPTY
51581: LIST
51582: LIST
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: LD_INT 2
51590: PUSH
51591: LD_INT 30
51593: PUSH
51594: LD_INT 0
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PUSH
51601: LD_INT 30
51603: PUSH
51604: LD_INT 1
51606: PUSH
51607: EMPTY
51608: LIST
51609: LIST
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: LIST
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: PPUSH
51620: CALL_OW 72
51624: OR
51625: AND
51626: IFFALSE 51877
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51628: LD_ADDR_EXP 159
51632: PUSH
51633: LD_EXP 159
51637: PPUSH
51638: LD_VAR 0 2
51642: PPUSH
51643: LD_INT 1
51645: PPUSH
51646: CALL_OW 1
51650: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51651: LD_ADDR_VAR 0 4
51655: PUSH
51656: LD_EXP 116
51660: PUSH
51661: LD_VAR 0 2
51665: ARRAY
51666: PPUSH
51667: LD_INT 2
51669: PUSH
51670: LD_INT 25
51672: PUSH
51673: LD_INT 1
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: LD_INT 25
51682: PUSH
51683: LD_INT 5
51685: PUSH
51686: EMPTY
51687: LIST
51688: LIST
51689: PUSH
51690: LD_INT 25
51692: PUSH
51693: LD_INT 8
51695: PUSH
51696: EMPTY
51697: LIST
51698: LIST
51699: PUSH
51700: LD_INT 25
51702: PUSH
51703: LD_INT 9
51705: PUSH
51706: EMPTY
51707: LIST
51708: LIST
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: LIST
51714: LIST
51715: LIST
51716: PPUSH
51717: CALL_OW 72
51721: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51722: LD_ADDR_VAR 0 4
51726: PUSH
51727: LD_VAR 0 4
51731: PUSH
51732: LD_VAR 0 4
51736: PPUSH
51737: LD_INT 18
51739: PPUSH
51740: CALL 100140 0 2
51744: DIFF
51745: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51746: LD_VAR 0 4
51750: NOT
51751: PUSH
51752: LD_EXP 116
51756: PUSH
51757: LD_VAR 0 2
51761: ARRAY
51762: PPUSH
51763: LD_INT 2
51765: PUSH
51766: LD_INT 30
51768: PUSH
51769: LD_INT 4
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PUSH
51776: LD_INT 30
51778: PUSH
51779: LD_INT 5
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: LIST
51790: PPUSH
51791: CALL_OW 72
51795: NOT
51796: AND
51797: IFFALSE 51859
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51799: LD_ADDR_VAR 0 4
51803: PUSH
51804: LD_EXP 116
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PPUSH
51815: LD_INT 2
51817: PUSH
51818: LD_INT 25
51820: PUSH
51821: LD_INT 2
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: PUSH
51828: LD_INT 25
51830: PUSH
51831: LD_INT 3
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PUSH
51838: LD_INT 25
51840: PUSH
51841: LD_INT 4
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PUSH
51848: EMPTY
51849: LIST
51850: LIST
51851: LIST
51852: LIST
51853: PPUSH
51854: CALL_OW 72
51858: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51859: LD_VAR 0 2
51863: PPUSH
51864: LD_VAR 0 4
51868: PPUSH
51869: CALL 127939 0 2
// exit ;
51873: POP
51874: POP
51875: GO 51997
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51877: LD_EXP 139
51881: PUSH
51882: LD_VAR 0 2
51886: ARRAY
51887: PUSH
51888: LD_EXP 159
51892: PUSH
51893: LD_VAR 0 2
51897: ARRAY
51898: NOT
51899: AND
51900: PUSH
51901: LD_EXP 138
51905: PUSH
51906: LD_VAR 0 2
51910: ARRAY
51911: AND
51912: IFFALSE 51993
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51914: LD_ADDR_EXP 159
51918: PUSH
51919: LD_EXP 159
51923: PPUSH
51924: LD_VAR 0 2
51928: PPUSH
51929: LD_INT 1
51931: PPUSH
51932: CALL_OW 1
51936: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51937: LD_ADDR_VAR 0 4
51941: PUSH
51942: LD_EXP 138
51946: PUSH
51947: LD_VAR 0 2
51951: ARRAY
51952: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51953: LD_ADDR_EXP 138
51957: PUSH
51958: LD_EXP 138
51962: PPUSH
51963: LD_VAR 0 2
51967: PPUSH
51968: EMPTY
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// Defend ( i , tmp ) ;
51975: LD_VAR 0 2
51979: PPUSH
51980: LD_VAR 0 4
51984: PPUSH
51985: CALL 128535 0 2
// exit ;
51989: POP
51990: POP
51991: GO 51997
// end ; end ;
51993: GO 51155
51995: POP
51996: POP
// end ;
51997: LD_VAR 0 1
52001: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
52002: LD_INT 0
52004: PPUSH
52005: PPUSH
52006: PPUSH
52007: PPUSH
52008: PPUSH
52009: PPUSH
52010: PPUSH
52011: PPUSH
52012: PPUSH
52013: PPUSH
52014: PPUSH
// if not mc_bases then
52015: LD_EXP 116
52019: NOT
52020: IFFALSE 52024
// exit ;
52022: GO 53111
// for i = 1 to mc_bases do
52024: LD_ADDR_VAR 0 2
52028: PUSH
52029: DOUBLE
52030: LD_INT 1
52032: DEC
52033: ST_TO_ADDR
52034: LD_EXP 116
52038: PUSH
52039: FOR_TO
52040: IFFALSE 53109
// begin tmp := mc_lab [ i ] ;
52042: LD_ADDR_VAR 0 6
52046: PUSH
52047: LD_EXP 149
52051: PUSH
52052: LD_VAR 0 2
52056: ARRAY
52057: ST_TO_ADDR
// if not tmp then
52058: LD_VAR 0 6
52062: NOT
52063: IFFALSE 52067
// continue ;
52065: GO 52039
// idle_lab := 0 ;
52067: LD_ADDR_VAR 0 11
52071: PUSH
52072: LD_INT 0
52074: ST_TO_ADDR
// for j in tmp do
52075: LD_ADDR_VAR 0 3
52079: PUSH
52080: LD_VAR 0 6
52084: PUSH
52085: FOR_IN
52086: IFFALSE 53105
// begin researching := false ;
52088: LD_ADDR_VAR 0 10
52092: PUSH
52093: LD_INT 0
52095: ST_TO_ADDR
// side := GetSide ( j ) ;
52096: LD_ADDR_VAR 0 4
52100: PUSH
52101: LD_VAR 0 3
52105: PPUSH
52106: CALL_OW 255
52110: ST_TO_ADDR
// if not mc_tech [ side ] then
52111: LD_EXP 143
52115: PUSH
52116: LD_VAR 0 4
52120: ARRAY
52121: NOT
52122: IFFALSE 52126
// continue ;
52124: GO 52085
// if BuildingStatus ( j ) = bs_idle then
52126: LD_VAR 0 3
52130: PPUSH
52131: CALL_OW 461
52135: PUSH
52136: LD_INT 2
52138: EQUAL
52139: IFFALSE 52327
// begin if idle_lab and UnitsInside ( j ) < 6 then
52141: LD_VAR 0 11
52145: PUSH
52146: LD_VAR 0 3
52150: PPUSH
52151: CALL_OW 313
52155: PUSH
52156: LD_INT 6
52158: LESS
52159: AND
52160: IFFALSE 52231
// begin tmp2 := UnitsInside ( idle_lab ) ;
52162: LD_ADDR_VAR 0 9
52166: PUSH
52167: LD_VAR 0 11
52171: PPUSH
52172: CALL_OW 313
52176: ST_TO_ADDR
// if tmp2 then
52177: LD_VAR 0 9
52181: IFFALSE 52223
// for x in tmp2 do
52183: LD_ADDR_VAR 0 7
52187: PUSH
52188: LD_VAR 0 9
52192: PUSH
52193: FOR_IN
52194: IFFALSE 52221
// begin ComExitBuilding ( x ) ;
52196: LD_VAR 0 7
52200: PPUSH
52201: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52205: LD_VAR 0 7
52209: PPUSH
52210: LD_VAR 0 3
52214: PPUSH
52215: CALL_OW 180
// end ;
52219: GO 52193
52221: POP
52222: POP
// idle_lab := 0 ;
52223: LD_ADDR_VAR 0 11
52227: PUSH
52228: LD_INT 0
52230: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52231: LD_ADDR_VAR 0 5
52235: PUSH
52236: LD_EXP 143
52240: PUSH
52241: LD_VAR 0 4
52245: ARRAY
52246: PUSH
52247: FOR_IN
52248: IFFALSE 52308
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52250: LD_VAR 0 3
52254: PPUSH
52255: LD_VAR 0 5
52259: PPUSH
52260: CALL_OW 430
52264: PUSH
52265: LD_VAR 0 4
52269: PPUSH
52270: LD_VAR 0 5
52274: PPUSH
52275: CALL 66741 0 2
52279: AND
52280: IFFALSE 52306
// begin researching := true ;
52282: LD_ADDR_VAR 0 10
52286: PUSH
52287: LD_INT 1
52289: ST_TO_ADDR
// ComResearch ( j , t ) ;
52290: LD_VAR 0 3
52294: PPUSH
52295: LD_VAR 0 5
52299: PPUSH
52300: CALL_OW 124
// break ;
52304: GO 52308
// end ;
52306: GO 52247
52308: POP
52309: POP
// if not researching then
52310: LD_VAR 0 10
52314: NOT
52315: IFFALSE 52327
// idle_lab := j ;
52317: LD_ADDR_VAR 0 11
52321: PUSH
52322: LD_VAR 0 3
52326: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52327: LD_VAR 0 3
52331: PPUSH
52332: CALL_OW 461
52336: PUSH
52337: LD_INT 10
52339: EQUAL
52340: IFFALSE 52928
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52342: LD_EXP 145
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: NOT
52353: PUSH
52354: LD_EXP 146
52358: PUSH
52359: LD_VAR 0 2
52363: ARRAY
52364: NOT
52365: AND
52366: PUSH
52367: LD_EXP 143
52371: PUSH
52372: LD_VAR 0 4
52376: ARRAY
52377: PUSH
52378: LD_INT 1
52380: GREATER
52381: AND
52382: IFFALSE 52513
// begin ComCancel ( j ) ;
52384: LD_VAR 0 3
52388: PPUSH
52389: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52393: LD_ADDR_EXP 143
52397: PUSH
52398: LD_EXP 143
52402: PPUSH
52403: LD_VAR 0 4
52407: PPUSH
52408: LD_EXP 143
52412: PUSH
52413: LD_VAR 0 4
52417: ARRAY
52418: PPUSH
52419: LD_EXP 143
52423: PUSH
52424: LD_VAR 0 4
52428: ARRAY
52429: PUSH
52430: LD_INT 1
52432: MINUS
52433: PPUSH
52434: LD_EXP 143
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PPUSH
52445: LD_INT 0
52447: PPUSH
52448: CALL 70289 0 4
52452: PPUSH
52453: CALL_OW 1
52457: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52458: LD_ADDR_EXP 143
52462: PUSH
52463: LD_EXP 143
52467: PPUSH
52468: LD_VAR 0 4
52472: PPUSH
52473: LD_EXP 143
52477: PUSH
52478: LD_VAR 0 4
52482: ARRAY
52483: PPUSH
52484: LD_EXP 143
52488: PUSH
52489: LD_VAR 0 4
52493: ARRAY
52494: PPUSH
52495: LD_INT 1
52497: PPUSH
52498: LD_INT 0
52500: PPUSH
52501: CALL 70289 0 4
52505: PPUSH
52506: CALL_OW 1
52510: ST_TO_ADDR
// continue ;
52511: GO 52085
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52513: LD_EXP 145
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: PUSH
52524: LD_EXP 146
52528: PUSH
52529: LD_VAR 0 2
52533: ARRAY
52534: NOT
52535: AND
52536: IFFALSE 52663
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52538: LD_ADDR_EXP 146
52542: PUSH
52543: LD_EXP 146
52547: PPUSH
52548: LD_VAR 0 2
52552: PUSH
52553: LD_EXP 146
52557: PUSH
52558: LD_VAR 0 2
52562: ARRAY
52563: PUSH
52564: LD_INT 1
52566: PLUS
52567: PUSH
52568: EMPTY
52569: LIST
52570: LIST
52571: PPUSH
52572: LD_EXP 145
52576: PUSH
52577: LD_VAR 0 2
52581: ARRAY
52582: PUSH
52583: LD_INT 1
52585: ARRAY
52586: PPUSH
52587: CALL 70871 0 3
52591: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52592: LD_EXP 145
52596: PUSH
52597: LD_VAR 0 2
52601: ARRAY
52602: PUSH
52603: LD_INT 1
52605: ARRAY
52606: PPUSH
52607: LD_INT 112
52609: PPUSH
52610: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52614: LD_ADDR_VAR 0 9
52618: PUSH
52619: LD_EXP 145
52623: PUSH
52624: LD_VAR 0 2
52628: ARRAY
52629: PPUSH
52630: LD_INT 1
52632: PPUSH
52633: CALL_OW 3
52637: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52638: LD_ADDR_EXP 145
52642: PUSH
52643: LD_EXP 145
52647: PPUSH
52648: LD_VAR 0 2
52652: PPUSH
52653: LD_VAR 0 9
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52663: LD_EXP 145
52667: PUSH
52668: LD_VAR 0 2
52672: ARRAY
52673: PUSH
52674: LD_EXP 146
52678: PUSH
52679: LD_VAR 0 2
52683: ARRAY
52684: AND
52685: PUSH
52686: LD_EXP 146
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 1
52699: ARRAY
52700: PPUSH
52701: CALL_OW 310
52705: NOT
52706: AND
52707: PUSH
52708: LD_VAR 0 3
52712: PPUSH
52713: CALL_OW 313
52717: PUSH
52718: LD_INT 6
52720: EQUAL
52721: AND
52722: IFFALSE 52778
// begin tmp2 := UnitsInside ( j ) ;
52724: LD_ADDR_VAR 0 9
52728: PUSH
52729: LD_VAR 0 3
52733: PPUSH
52734: CALL_OW 313
52738: ST_TO_ADDR
// if tmp2 = 6 then
52739: LD_VAR 0 9
52743: PUSH
52744: LD_INT 6
52746: EQUAL
52747: IFFALSE 52778
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52749: LD_VAR 0 9
52753: PUSH
52754: LD_INT 1
52756: ARRAY
52757: PPUSH
52758: LD_INT 112
52760: PPUSH
52761: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52765: LD_VAR 0 9
52769: PUSH
52770: LD_INT 1
52772: ARRAY
52773: PPUSH
52774: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52778: LD_EXP 146
52782: PUSH
52783: LD_VAR 0 2
52787: ARRAY
52788: PUSH
52789: LD_EXP 146
52793: PUSH
52794: LD_VAR 0 2
52798: ARRAY
52799: PUSH
52800: LD_INT 1
52802: ARRAY
52803: PPUSH
52804: CALL_OW 314
52808: NOT
52809: AND
52810: PUSH
52811: LD_EXP 146
52815: PUSH
52816: LD_VAR 0 2
52820: ARRAY
52821: PUSH
52822: LD_INT 1
52824: ARRAY
52825: PPUSH
52826: CALL_OW 310
52830: NOT
52831: AND
52832: IFFALSE 52858
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52834: LD_EXP 146
52838: PUSH
52839: LD_VAR 0 2
52843: ARRAY
52844: PUSH
52845: LD_INT 1
52847: ARRAY
52848: PPUSH
52849: LD_VAR 0 3
52853: PPUSH
52854: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52858: LD_EXP 146
52862: PUSH
52863: LD_VAR 0 2
52867: ARRAY
52868: PUSH
52869: LD_INT 1
52871: ARRAY
52872: PPUSH
52873: CALL_OW 310
52877: PUSH
52878: LD_EXP 146
52882: PUSH
52883: LD_VAR 0 2
52887: ARRAY
52888: PUSH
52889: LD_INT 1
52891: ARRAY
52892: PPUSH
52893: CALL_OW 310
52897: PPUSH
52898: CALL_OW 461
52902: PUSH
52903: LD_INT 3
52905: NONEQUAL
52906: AND
52907: IFFALSE 52928
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52909: LD_EXP 146
52913: PUSH
52914: LD_VAR 0 2
52918: ARRAY
52919: PUSH
52920: LD_INT 1
52922: ARRAY
52923: PPUSH
52924: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52928: LD_VAR 0 3
52932: PPUSH
52933: CALL_OW 461
52937: PUSH
52938: LD_INT 6
52940: EQUAL
52941: PUSH
52942: LD_VAR 0 6
52946: PUSH
52947: LD_INT 1
52949: GREATER
52950: AND
52951: IFFALSE 53103
// begin sci := [ ] ;
52953: LD_ADDR_VAR 0 8
52957: PUSH
52958: EMPTY
52959: ST_TO_ADDR
// for x in ( tmp diff j ) do
52960: LD_ADDR_VAR 0 7
52964: PUSH
52965: LD_VAR 0 6
52969: PUSH
52970: LD_VAR 0 3
52974: DIFF
52975: PUSH
52976: FOR_IN
52977: IFFALSE 53029
// begin if sci = 6 then
52979: LD_VAR 0 8
52983: PUSH
52984: LD_INT 6
52986: EQUAL
52987: IFFALSE 52991
// break ;
52989: GO 53029
// if BuildingStatus ( x ) = bs_idle then
52991: LD_VAR 0 7
52995: PPUSH
52996: CALL_OW 461
53000: PUSH
53001: LD_INT 2
53003: EQUAL
53004: IFFALSE 53027
// sci := sci ^ UnitsInside ( x ) ;
53006: LD_ADDR_VAR 0 8
53010: PUSH
53011: LD_VAR 0 8
53015: PUSH
53016: LD_VAR 0 7
53020: PPUSH
53021: CALL_OW 313
53025: ADD
53026: ST_TO_ADDR
// end ;
53027: GO 52976
53029: POP
53030: POP
// if not sci then
53031: LD_VAR 0 8
53035: NOT
53036: IFFALSE 53040
// continue ;
53038: GO 52085
// for x in sci do
53040: LD_ADDR_VAR 0 7
53044: PUSH
53045: LD_VAR 0 8
53049: PUSH
53050: FOR_IN
53051: IFFALSE 53101
// if IsInUnit ( x ) and not HasTask ( x ) then
53053: LD_VAR 0 7
53057: PPUSH
53058: CALL_OW 310
53062: PUSH
53063: LD_VAR 0 7
53067: PPUSH
53068: CALL_OW 314
53072: NOT
53073: AND
53074: IFFALSE 53099
// begin ComExitBuilding ( x ) ;
53076: LD_VAR 0 7
53080: PPUSH
53081: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53085: LD_VAR 0 7
53089: PPUSH
53090: LD_VAR 0 3
53094: PPUSH
53095: CALL_OW 180
// end ;
53099: GO 53050
53101: POP
53102: POP
// end ; end ;
53103: GO 52085
53105: POP
53106: POP
// end ;
53107: GO 52039
53109: POP
53110: POP
// end ;
53111: LD_VAR 0 1
53115: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
// if not mc_bases then
53120: LD_EXP 116
53124: NOT
53125: IFFALSE 53129
// exit ;
53127: GO 53210
// for i = 1 to mc_bases do
53129: LD_ADDR_VAR 0 2
53133: PUSH
53134: DOUBLE
53135: LD_INT 1
53137: DEC
53138: ST_TO_ADDR
53139: LD_EXP 116
53143: PUSH
53144: FOR_TO
53145: IFFALSE 53208
// if mc_mines [ i ] and mc_miners [ i ] then
53147: LD_EXP 129
53151: PUSH
53152: LD_VAR 0 2
53156: ARRAY
53157: PUSH
53158: LD_EXP 130
53162: PUSH
53163: LD_VAR 0 2
53167: ARRAY
53168: AND
53169: IFFALSE 53206
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53171: LD_EXP 130
53175: PUSH
53176: LD_VAR 0 2
53180: ARRAY
53181: PUSH
53182: LD_INT 1
53184: ARRAY
53185: PPUSH
53186: CALL_OW 255
53190: PPUSH
53191: LD_EXP 129
53195: PUSH
53196: LD_VAR 0 2
53200: ARRAY
53201: PPUSH
53202: CALL 67824 0 2
53206: GO 53144
53208: POP
53209: POP
// end ;
53210: LD_VAR 0 1
53214: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53215: LD_INT 0
53217: PPUSH
53218: PPUSH
53219: PPUSH
53220: PPUSH
53221: PPUSH
53222: PPUSH
53223: PPUSH
53224: PPUSH
// if not mc_bases or not mc_parking then
53225: LD_EXP 116
53229: NOT
53230: PUSH
53231: LD_EXP 140
53235: NOT
53236: OR
53237: IFFALSE 53241
// exit ;
53239: GO 53951
// for i = 1 to mc_bases do
53241: LD_ADDR_VAR 0 2
53245: PUSH
53246: DOUBLE
53247: LD_INT 1
53249: DEC
53250: ST_TO_ADDR
53251: LD_EXP 116
53255: PUSH
53256: FOR_TO
53257: IFFALSE 53949
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53259: LD_EXP 116
53263: PUSH
53264: LD_VAR 0 2
53268: ARRAY
53269: NOT
53270: PUSH
53271: LD_EXP 140
53275: PUSH
53276: LD_VAR 0 2
53280: ARRAY
53281: NOT
53282: OR
53283: IFFALSE 53287
// continue ;
53285: GO 53256
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53287: LD_ADDR_VAR 0 5
53291: PUSH
53292: LD_EXP 116
53296: PUSH
53297: LD_VAR 0 2
53301: ARRAY
53302: PUSH
53303: LD_INT 1
53305: ARRAY
53306: PPUSH
53307: CALL_OW 255
53311: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53312: LD_ADDR_VAR 0 6
53316: PUSH
53317: LD_EXP 116
53321: PUSH
53322: LD_VAR 0 2
53326: ARRAY
53327: PPUSH
53328: LD_INT 30
53330: PUSH
53331: LD_INT 3
53333: PUSH
53334: EMPTY
53335: LIST
53336: LIST
53337: PPUSH
53338: CALL_OW 72
53342: ST_TO_ADDR
// if not fac then
53343: LD_VAR 0 6
53347: NOT
53348: IFFALSE 53399
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53350: LD_ADDR_VAR 0 6
53354: PUSH
53355: LD_EXP 116
53359: PUSH
53360: LD_VAR 0 2
53364: ARRAY
53365: PPUSH
53366: LD_INT 2
53368: PUSH
53369: LD_INT 30
53371: PUSH
53372: LD_INT 0
53374: PUSH
53375: EMPTY
53376: LIST
53377: LIST
53378: PUSH
53379: LD_INT 30
53381: PUSH
53382: LD_INT 1
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: LIST
53393: PPUSH
53394: CALL_OW 72
53398: ST_TO_ADDR
// if not fac then
53399: LD_VAR 0 6
53403: NOT
53404: IFFALSE 53408
// continue ;
53406: GO 53256
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53408: LD_ADDR_VAR 0 7
53412: PUSH
53413: LD_EXP 140
53417: PUSH
53418: LD_VAR 0 2
53422: ARRAY
53423: PPUSH
53424: LD_INT 22
53426: PUSH
53427: LD_VAR 0 5
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: LD_INT 21
53438: PUSH
53439: LD_INT 2
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PUSH
53446: LD_INT 3
53448: PUSH
53449: LD_INT 24
53451: PUSH
53452: LD_INT 1000
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: LIST
53467: PPUSH
53468: CALL_OW 70
53472: ST_TO_ADDR
// for j in fac do
53473: LD_ADDR_VAR 0 3
53477: PUSH
53478: LD_VAR 0 6
53482: PUSH
53483: FOR_IN
53484: IFFALSE 53565
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53486: LD_ADDR_VAR 0 7
53490: PUSH
53491: LD_VAR 0 7
53495: PUSH
53496: LD_INT 22
53498: PUSH
53499: LD_VAR 0 5
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: PUSH
53508: LD_INT 91
53510: PUSH
53511: LD_VAR 0 3
53515: PUSH
53516: LD_INT 15
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: LIST
53523: PUSH
53524: LD_INT 21
53526: PUSH
53527: LD_INT 2
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PUSH
53534: LD_INT 3
53536: PUSH
53537: LD_INT 24
53539: PUSH
53540: LD_INT 1000
53542: PUSH
53543: EMPTY
53544: LIST
53545: LIST
53546: PUSH
53547: EMPTY
53548: LIST
53549: LIST
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: LIST
53555: LIST
53556: PPUSH
53557: CALL_OW 69
53561: UNION
53562: ST_TO_ADDR
53563: GO 53483
53565: POP
53566: POP
// if not vehs then
53567: LD_VAR 0 7
53571: NOT
53572: IFFALSE 53598
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53574: LD_ADDR_EXP 128
53578: PUSH
53579: LD_EXP 128
53583: PPUSH
53584: LD_VAR 0 2
53588: PPUSH
53589: EMPTY
53590: PPUSH
53591: CALL_OW 1
53595: ST_TO_ADDR
// continue ;
53596: GO 53256
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53598: LD_ADDR_VAR 0 8
53602: PUSH
53603: LD_EXP 116
53607: PUSH
53608: LD_VAR 0 2
53612: ARRAY
53613: PPUSH
53614: LD_INT 30
53616: PUSH
53617: LD_INT 3
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PPUSH
53624: CALL_OW 72
53628: ST_TO_ADDR
// if tmp then
53629: LD_VAR 0 8
53633: IFFALSE 53736
// begin for j in tmp do
53635: LD_ADDR_VAR 0 3
53639: PUSH
53640: LD_VAR 0 8
53644: PUSH
53645: FOR_IN
53646: IFFALSE 53734
// for k in UnitsInside ( j ) do
53648: LD_ADDR_VAR 0 4
53652: PUSH
53653: LD_VAR 0 3
53657: PPUSH
53658: CALL_OW 313
53662: PUSH
53663: FOR_IN
53664: IFFALSE 53730
// if k then
53666: LD_VAR 0 4
53670: IFFALSE 53728
// if not k in mc_repair_vehicle [ i ] then
53672: LD_VAR 0 4
53676: PUSH
53677: LD_EXP 128
53681: PUSH
53682: LD_VAR 0 2
53686: ARRAY
53687: IN
53688: NOT
53689: IFFALSE 53728
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53691: LD_ADDR_EXP 128
53695: PUSH
53696: LD_EXP 128
53700: PPUSH
53701: LD_VAR 0 2
53705: PPUSH
53706: LD_EXP 128
53710: PUSH
53711: LD_VAR 0 2
53715: ARRAY
53716: PUSH
53717: LD_VAR 0 4
53721: UNION
53722: PPUSH
53723: CALL_OW 1
53727: ST_TO_ADDR
53728: GO 53663
53730: POP
53731: POP
53732: GO 53645
53734: POP
53735: POP
// end ; if not mc_repair_vehicle [ i ] then
53736: LD_EXP 128
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: NOT
53747: IFFALSE 53751
// continue ;
53749: GO 53256
// for j in mc_repair_vehicle [ i ] do
53751: LD_ADDR_VAR 0 3
53755: PUSH
53756: LD_EXP 128
53760: PUSH
53761: LD_VAR 0 2
53765: ARRAY
53766: PUSH
53767: FOR_IN
53768: IFFALSE 53945
// begin if GetClass ( j ) <> 3 then
53770: LD_VAR 0 3
53774: PPUSH
53775: CALL_OW 257
53779: PUSH
53780: LD_INT 3
53782: NONEQUAL
53783: IFFALSE 53824
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53785: LD_ADDR_EXP 128
53789: PUSH
53790: LD_EXP 128
53794: PPUSH
53795: LD_VAR 0 2
53799: PPUSH
53800: LD_EXP 128
53804: PUSH
53805: LD_VAR 0 2
53809: ARRAY
53810: PUSH
53811: LD_VAR 0 3
53815: DIFF
53816: PPUSH
53817: CALL_OW 1
53821: ST_TO_ADDR
// continue ;
53822: GO 53767
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53824: LD_VAR 0 3
53828: PPUSH
53829: CALL_OW 311
53833: NOT
53834: PUSH
53835: LD_VAR 0 3
53839: PUSH
53840: LD_EXP 119
53844: PUSH
53845: LD_VAR 0 2
53849: ARRAY
53850: PUSH
53851: LD_INT 1
53853: ARRAY
53854: IN
53855: NOT
53856: AND
53857: PUSH
53858: LD_VAR 0 3
53862: PUSH
53863: LD_EXP 119
53867: PUSH
53868: LD_VAR 0 2
53872: ARRAY
53873: PUSH
53874: LD_INT 2
53876: ARRAY
53877: IN
53878: NOT
53879: AND
53880: IFFALSE 53943
// begin if IsInUnit ( j ) then
53882: LD_VAR 0 3
53886: PPUSH
53887: CALL_OW 310
53891: IFFALSE 53904
// ComExitBuilding ( j ) else
53893: LD_VAR 0 3
53897: PPUSH
53898: CALL_OW 122
53902: GO 53943
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53904: LD_VAR 0 3
53908: PPUSH
53909: LD_VAR 0 7
53913: PUSH
53914: LD_INT 1
53916: ARRAY
53917: PPUSH
53918: CALL 104478 0 2
53922: NOT
53923: IFFALSE 53943
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53925: LD_VAR 0 3
53929: PPUSH
53930: LD_VAR 0 7
53934: PUSH
53935: LD_INT 1
53937: ARRAY
53938: PPUSH
53939: CALL_OW 129
// end ; end ;
53943: GO 53767
53945: POP
53946: POP
// end ;
53947: GO 53256
53949: POP
53950: POP
// end ;
53951: LD_VAR 0 1
53955: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53956: LD_INT 0
53958: PPUSH
53959: PPUSH
53960: PPUSH
53961: PPUSH
53962: PPUSH
53963: PPUSH
53964: PPUSH
53965: PPUSH
53966: PPUSH
53967: PPUSH
53968: PPUSH
// if not mc_bases then
53969: LD_EXP 116
53973: NOT
53974: IFFALSE 53978
// exit ;
53976: GO 54780
// for i = 1 to mc_bases do
53978: LD_ADDR_VAR 0 2
53982: PUSH
53983: DOUBLE
53984: LD_INT 1
53986: DEC
53987: ST_TO_ADDR
53988: LD_EXP 116
53992: PUSH
53993: FOR_TO
53994: IFFALSE 54778
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53996: LD_EXP 144
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: NOT
54007: PUSH
54008: LD_EXP 119
54012: PUSH
54013: LD_VAR 0 2
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: ARRAY
54022: OR
54023: PUSH
54024: LD_EXP 119
54028: PUSH
54029: LD_VAR 0 2
54033: ARRAY
54034: PUSH
54035: LD_INT 2
54037: ARRAY
54038: OR
54039: PUSH
54040: LD_EXP 142
54044: PUSH
54045: LD_VAR 0 2
54049: ARRAY
54050: PPUSH
54051: LD_INT 1
54053: PPUSH
54054: CALL_OW 325
54058: NOT
54059: OR
54060: PUSH
54061: LD_EXP 139
54065: PUSH
54066: LD_VAR 0 2
54070: ARRAY
54071: OR
54072: IFFALSE 54076
// continue ;
54074: GO 53993
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54076: LD_ADDR_VAR 0 8
54080: PUSH
54081: LD_EXP 116
54085: PUSH
54086: LD_VAR 0 2
54090: ARRAY
54091: PPUSH
54092: LD_INT 25
54094: PUSH
54095: LD_INT 4
54097: PUSH
54098: EMPTY
54099: LIST
54100: LIST
54101: PUSH
54102: LD_INT 50
54104: PUSH
54105: EMPTY
54106: LIST
54107: PUSH
54108: LD_INT 3
54110: PUSH
54111: LD_INT 60
54113: PUSH
54114: EMPTY
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PPUSH
54126: CALL_OW 72
54130: PUSH
54131: LD_EXP 120
54135: PUSH
54136: LD_VAR 0 2
54140: ARRAY
54141: DIFF
54142: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54143: LD_ADDR_VAR 0 9
54147: PUSH
54148: LD_EXP 116
54152: PUSH
54153: LD_VAR 0 2
54157: ARRAY
54158: PPUSH
54159: LD_INT 2
54161: PUSH
54162: LD_INT 30
54164: PUSH
54165: LD_INT 0
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: PUSH
54172: LD_INT 30
54174: PUSH
54175: LD_INT 1
54177: PUSH
54178: EMPTY
54179: LIST
54180: LIST
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: LIST
54186: PPUSH
54187: CALL_OW 72
54191: ST_TO_ADDR
// if not tmp or not dep then
54192: LD_VAR 0 8
54196: NOT
54197: PUSH
54198: LD_VAR 0 9
54202: NOT
54203: OR
54204: IFFALSE 54208
// continue ;
54206: GO 53993
// side := GetSide ( tmp [ 1 ] ) ;
54208: LD_ADDR_VAR 0 11
54212: PUSH
54213: LD_VAR 0 8
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PPUSH
54222: CALL_OW 255
54226: ST_TO_ADDR
// dep := dep [ 1 ] ;
54227: LD_ADDR_VAR 0 9
54231: PUSH
54232: LD_VAR 0 9
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54241: LD_ADDR_VAR 0 7
54245: PUSH
54246: LD_EXP 144
54250: PUSH
54251: LD_VAR 0 2
54255: ARRAY
54256: PPUSH
54257: LD_INT 22
54259: PUSH
54260: LD_INT 0
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: PUSH
54267: LD_INT 25
54269: PUSH
54270: LD_INT 12
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: PPUSH
54281: CALL_OW 70
54285: PUSH
54286: LD_INT 22
54288: PUSH
54289: LD_INT 0
54291: PUSH
54292: EMPTY
54293: LIST
54294: LIST
54295: PUSH
54296: LD_INT 25
54298: PUSH
54299: LD_INT 12
54301: PUSH
54302: EMPTY
54303: LIST
54304: LIST
54305: PUSH
54306: LD_INT 91
54308: PUSH
54309: LD_VAR 0 9
54313: PUSH
54314: LD_INT 20
54316: PUSH
54317: EMPTY
54318: LIST
54319: LIST
54320: LIST
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: LIST
54326: PPUSH
54327: CALL_OW 69
54331: UNION
54332: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54333: LD_ADDR_VAR 0 10
54337: PUSH
54338: LD_EXP 144
54342: PUSH
54343: LD_VAR 0 2
54347: ARRAY
54348: PPUSH
54349: LD_INT 81
54351: PUSH
54352: LD_VAR 0 11
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: PPUSH
54361: CALL_OW 70
54365: ST_TO_ADDR
// if not apes or danger_at_area then
54366: LD_VAR 0 7
54370: NOT
54371: PUSH
54372: LD_VAR 0 10
54376: OR
54377: IFFALSE 54427
// begin if mc_taming [ i ] then
54379: LD_EXP 147
54383: PUSH
54384: LD_VAR 0 2
54388: ARRAY
54389: IFFALSE 54425
// begin MC_Reset ( i , 121 ) ;
54391: LD_VAR 0 2
54395: PPUSH
54396: LD_INT 121
54398: PPUSH
54399: CALL 39413 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54403: LD_ADDR_EXP 147
54407: PUSH
54408: LD_EXP 147
54412: PPUSH
54413: LD_VAR 0 2
54417: PPUSH
54418: EMPTY
54419: PPUSH
54420: CALL_OW 1
54424: ST_TO_ADDR
// end ; continue ;
54425: GO 53993
// end ; for j in tmp do
54427: LD_ADDR_VAR 0 3
54431: PUSH
54432: LD_VAR 0 8
54436: PUSH
54437: FOR_IN
54438: IFFALSE 54774
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54440: LD_VAR 0 3
54444: PUSH
54445: LD_EXP 147
54449: PUSH
54450: LD_VAR 0 2
54454: ARRAY
54455: IN
54456: NOT
54457: PUSH
54458: LD_EXP 147
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: PUSH
54469: LD_INT 3
54471: LESS
54472: AND
54473: IFFALSE 54531
// begin SetTag ( j , 121 ) ;
54475: LD_VAR 0 3
54479: PPUSH
54480: LD_INT 121
54482: PPUSH
54483: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54487: LD_ADDR_EXP 147
54491: PUSH
54492: LD_EXP 147
54496: PPUSH
54497: LD_VAR 0 2
54501: PUSH
54502: LD_EXP 147
54506: PUSH
54507: LD_VAR 0 2
54511: ARRAY
54512: PUSH
54513: LD_INT 1
54515: PLUS
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PPUSH
54521: LD_VAR 0 3
54525: PPUSH
54526: CALL 70871 0 3
54530: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54531: LD_VAR 0 3
54535: PUSH
54536: LD_EXP 147
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: IN
54547: IFFALSE 54772
// begin if GetClass ( j ) <> 4 then
54549: LD_VAR 0 3
54553: PPUSH
54554: CALL_OW 257
54558: PUSH
54559: LD_INT 4
54561: NONEQUAL
54562: IFFALSE 54615
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54564: LD_ADDR_EXP 147
54568: PUSH
54569: LD_EXP 147
54573: PPUSH
54574: LD_VAR 0 2
54578: PPUSH
54579: LD_EXP 147
54583: PUSH
54584: LD_VAR 0 2
54588: ARRAY
54589: PUSH
54590: LD_VAR 0 3
54594: DIFF
54595: PPUSH
54596: CALL_OW 1
54600: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54601: LD_VAR 0 3
54605: PPUSH
54606: LD_INT 0
54608: PPUSH
54609: CALL_OW 109
// continue ;
54613: GO 54437
// end ; if IsInUnit ( j ) then
54615: LD_VAR 0 3
54619: PPUSH
54620: CALL_OW 310
54624: IFFALSE 54635
// ComExitBuilding ( j ) ;
54626: LD_VAR 0 3
54630: PPUSH
54631: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54635: LD_ADDR_VAR 0 6
54639: PUSH
54640: LD_VAR 0 7
54644: PPUSH
54645: LD_VAR 0 3
54649: PPUSH
54650: CALL_OW 74
54654: ST_TO_ADDR
// if not ape then
54655: LD_VAR 0 6
54659: NOT
54660: IFFALSE 54664
// break ;
54662: GO 54774
// x := GetX ( ape ) ;
54664: LD_ADDR_VAR 0 4
54668: PUSH
54669: LD_VAR 0 6
54673: PPUSH
54674: CALL_OW 250
54678: ST_TO_ADDR
// y := GetY ( ape ) ;
54679: LD_ADDR_VAR 0 5
54683: PUSH
54684: LD_VAR 0 6
54688: PPUSH
54689: CALL_OW 251
54693: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54694: LD_VAR 0 4
54698: PPUSH
54699: LD_VAR 0 5
54703: PPUSH
54704: CALL_OW 488
54708: NOT
54709: PUSH
54710: LD_VAR 0 11
54714: PPUSH
54715: LD_VAR 0 4
54719: PPUSH
54720: LD_VAR 0 5
54724: PPUSH
54725: LD_INT 20
54727: PPUSH
54728: CALL 71767 0 4
54732: PUSH
54733: LD_INT 4
54735: ARRAY
54736: OR
54737: IFFALSE 54741
// break ;
54739: GO 54774
// if not HasTask ( j ) then
54741: LD_VAR 0 3
54745: PPUSH
54746: CALL_OW 314
54750: NOT
54751: IFFALSE 54772
// ComTameXY ( j , x , y ) ;
54753: LD_VAR 0 3
54757: PPUSH
54758: LD_VAR 0 4
54762: PPUSH
54763: LD_VAR 0 5
54767: PPUSH
54768: CALL_OW 131
// end ; end ;
54772: GO 54437
54774: POP
54775: POP
// end ;
54776: GO 53993
54778: POP
54779: POP
// end ;
54780: LD_VAR 0 1
54784: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54785: LD_INT 0
54787: PPUSH
54788: PPUSH
54789: PPUSH
54790: PPUSH
54791: PPUSH
54792: PPUSH
54793: PPUSH
54794: PPUSH
// if not mc_bases then
54795: LD_EXP 116
54799: NOT
54800: IFFALSE 54804
// exit ;
54802: GO 55430
// for i = 1 to mc_bases do
54804: LD_ADDR_VAR 0 2
54808: PUSH
54809: DOUBLE
54810: LD_INT 1
54812: DEC
54813: ST_TO_ADDR
54814: LD_EXP 116
54818: PUSH
54819: FOR_TO
54820: IFFALSE 55428
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54822: LD_EXP 145
54826: PUSH
54827: LD_VAR 0 2
54831: ARRAY
54832: NOT
54833: PUSH
54834: LD_EXP 145
54838: PUSH
54839: LD_VAR 0 2
54843: ARRAY
54844: PPUSH
54845: LD_INT 25
54847: PUSH
54848: LD_INT 12
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PPUSH
54855: CALL_OW 72
54859: NOT
54860: OR
54861: IFFALSE 54865
// continue ;
54863: GO 54819
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54865: LD_ADDR_VAR 0 5
54869: PUSH
54870: LD_EXP 145
54874: PUSH
54875: LD_VAR 0 2
54879: ARRAY
54880: PUSH
54881: LD_INT 1
54883: ARRAY
54884: PPUSH
54885: CALL_OW 255
54889: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54890: LD_VAR 0 5
54894: PPUSH
54895: LD_INT 2
54897: PPUSH
54898: CALL_OW 325
54902: IFFALSE 55155
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54904: LD_ADDR_VAR 0 4
54908: PUSH
54909: LD_EXP 145
54913: PUSH
54914: LD_VAR 0 2
54918: ARRAY
54919: PPUSH
54920: LD_INT 25
54922: PUSH
54923: LD_INT 16
54925: PUSH
54926: EMPTY
54927: LIST
54928: LIST
54929: PPUSH
54930: CALL_OW 72
54934: ST_TO_ADDR
// if tmp < 6 then
54935: LD_VAR 0 4
54939: PUSH
54940: LD_INT 6
54942: LESS
54943: IFFALSE 55155
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54945: LD_ADDR_VAR 0 6
54949: PUSH
54950: LD_EXP 116
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PPUSH
54961: LD_INT 2
54963: PUSH
54964: LD_INT 30
54966: PUSH
54967: LD_INT 0
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: PUSH
54974: LD_INT 30
54976: PUSH
54977: LD_INT 1
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: PPUSH
54989: CALL_OW 72
54993: ST_TO_ADDR
// if depot then
54994: LD_VAR 0 6
54998: IFFALSE 55155
// begin selected := 0 ;
55000: LD_ADDR_VAR 0 7
55004: PUSH
55005: LD_INT 0
55007: ST_TO_ADDR
// for j in depot do
55008: LD_ADDR_VAR 0 3
55012: PUSH
55013: LD_VAR 0 6
55017: PUSH
55018: FOR_IN
55019: IFFALSE 55050
// begin if UnitsInside ( j ) < 6 then
55021: LD_VAR 0 3
55025: PPUSH
55026: CALL_OW 313
55030: PUSH
55031: LD_INT 6
55033: LESS
55034: IFFALSE 55048
// begin selected := j ;
55036: LD_ADDR_VAR 0 7
55040: PUSH
55041: LD_VAR 0 3
55045: ST_TO_ADDR
// break ;
55046: GO 55050
// end ; end ;
55048: GO 55018
55050: POP
55051: POP
// if selected then
55052: LD_VAR 0 7
55056: IFFALSE 55155
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55058: LD_ADDR_VAR 0 3
55062: PUSH
55063: LD_EXP 145
55067: PUSH
55068: LD_VAR 0 2
55072: ARRAY
55073: PPUSH
55074: LD_INT 25
55076: PUSH
55077: LD_INT 12
55079: PUSH
55080: EMPTY
55081: LIST
55082: LIST
55083: PPUSH
55084: CALL_OW 72
55088: PUSH
55089: FOR_IN
55090: IFFALSE 55153
// if not HasTask ( j ) then
55092: LD_VAR 0 3
55096: PPUSH
55097: CALL_OW 314
55101: NOT
55102: IFFALSE 55151
// begin if not IsInUnit ( j ) then
55104: LD_VAR 0 3
55108: PPUSH
55109: CALL_OW 310
55113: NOT
55114: IFFALSE 55130
// ComEnterUnit ( j , selected ) ;
55116: LD_VAR 0 3
55120: PPUSH
55121: LD_VAR 0 7
55125: PPUSH
55126: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55130: LD_VAR 0 3
55134: PPUSH
55135: LD_INT 16
55137: PPUSH
55138: CALL_OW 183
// AddComExitBuilding ( j ) ;
55142: LD_VAR 0 3
55146: PPUSH
55147: CALL_OW 182
// end ;
55151: GO 55089
55153: POP
55154: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55155: LD_VAR 0 5
55159: PPUSH
55160: LD_INT 11
55162: PPUSH
55163: CALL_OW 325
55167: IFFALSE 55426
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55169: LD_ADDR_VAR 0 4
55173: PUSH
55174: LD_EXP 145
55178: PUSH
55179: LD_VAR 0 2
55183: ARRAY
55184: PPUSH
55185: LD_INT 25
55187: PUSH
55188: LD_INT 16
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: PPUSH
55195: CALL_OW 72
55199: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55200: LD_VAR 0 4
55204: PUSH
55205: LD_INT 6
55207: GREATEREQUAL
55208: PUSH
55209: LD_VAR 0 5
55213: PPUSH
55214: LD_INT 2
55216: PPUSH
55217: CALL_OW 325
55221: NOT
55222: OR
55223: IFFALSE 55426
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55225: LD_ADDR_VAR 0 8
55229: PUSH
55230: LD_EXP 116
55234: PUSH
55235: LD_VAR 0 2
55239: ARRAY
55240: PPUSH
55241: LD_INT 2
55243: PUSH
55244: LD_INT 30
55246: PUSH
55247: LD_INT 4
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: PUSH
55254: LD_INT 30
55256: PUSH
55257: LD_INT 5
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: LIST
55268: PPUSH
55269: CALL_OW 72
55273: ST_TO_ADDR
// if barracks then
55274: LD_VAR 0 8
55278: IFFALSE 55426
// begin selected := 0 ;
55280: LD_ADDR_VAR 0 7
55284: PUSH
55285: LD_INT 0
55287: ST_TO_ADDR
// for j in barracks do
55288: LD_ADDR_VAR 0 3
55292: PUSH
55293: LD_VAR 0 8
55297: PUSH
55298: FOR_IN
55299: IFFALSE 55330
// begin if UnitsInside ( j ) < 6 then
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 313
55310: PUSH
55311: LD_INT 6
55313: LESS
55314: IFFALSE 55328
// begin selected := j ;
55316: LD_ADDR_VAR 0 7
55320: PUSH
55321: LD_VAR 0 3
55325: ST_TO_ADDR
// break ;
55326: GO 55330
// end ; end ;
55328: GO 55298
55330: POP
55331: POP
// if selected then
55332: LD_VAR 0 7
55336: IFFALSE 55426
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55338: LD_ADDR_VAR 0 3
55342: PUSH
55343: LD_EXP 145
55347: PUSH
55348: LD_VAR 0 2
55352: ARRAY
55353: PPUSH
55354: LD_INT 25
55356: PUSH
55357: LD_INT 12
55359: PUSH
55360: EMPTY
55361: LIST
55362: LIST
55363: PPUSH
55364: CALL_OW 72
55368: PUSH
55369: FOR_IN
55370: IFFALSE 55424
// if not IsInUnit ( j ) and not HasTask ( j ) then
55372: LD_VAR 0 3
55376: PPUSH
55377: CALL_OW 310
55381: NOT
55382: PUSH
55383: LD_VAR 0 3
55387: PPUSH
55388: CALL_OW 314
55392: NOT
55393: AND
55394: IFFALSE 55422
// begin ComEnterUnit ( j , selected ) ;
55396: LD_VAR 0 3
55400: PPUSH
55401: LD_VAR 0 7
55405: PPUSH
55406: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55410: LD_VAR 0 3
55414: PPUSH
55415: LD_INT 15
55417: PPUSH
55418: CALL_OW 183
// end ;
55422: GO 55369
55424: POP
55425: POP
// end ; end ; end ; end ; end ;
55426: GO 54819
55428: POP
55429: POP
// end ;
55430: LD_VAR 0 1
55434: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55435: LD_INT 0
55437: PPUSH
55438: PPUSH
55439: PPUSH
55440: PPUSH
// if not mc_bases then
55441: LD_EXP 116
55445: NOT
55446: IFFALSE 55450
// exit ;
55448: GO 55628
// for i = 1 to mc_bases do
55450: LD_ADDR_VAR 0 2
55454: PUSH
55455: DOUBLE
55456: LD_INT 1
55458: DEC
55459: ST_TO_ADDR
55460: LD_EXP 116
55464: PUSH
55465: FOR_TO
55466: IFFALSE 55626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55468: LD_ADDR_VAR 0 4
55472: PUSH
55473: LD_EXP 116
55477: PUSH
55478: LD_VAR 0 2
55482: ARRAY
55483: PPUSH
55484: LD_INT 25
55486: PUSH
55487: LD_INT 9
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PPUSH
55494: CALL_OW 72
55498: ST_TO_ADDR
// if not tmp then
55499: LD_VAR 0 4
55503: NOT
55504: IFFALSE 55508
// continue ;
55506: GO 55465
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55508: LD_EXP 142
55512: PUSH
55513: LD_VAR 0 2
55517: ARRAY
55518: PPUSH
55519: LD_INT 29
55521: PPUSH
55522: CALL_OW 325
55526: NOT
55527: PUSH
55528: LD_EXP 142
55532: PUSH
55533: LD_VAR 0 2
55537: ARRAY
55538: PPUSH
55539: LD_INT 28
55541: PPUSH
55542: CALL_OW 325
55546: NOT
55547: AND
55548: IFFALSE 55552
// continue ;
55550: GO 55465
// for j in tmp do
55552: LD_ADDR_VAR 0 3
55556: PUSH
55557: LD_VAR 0 4
55561: PUSH
55562: FOR_IN
55563: IFFALSE 55622
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55565: LD_VAR 0 3
55569: PUSH
55570: LD_EXP 119
55574: PUSH
55575: LD_VAR 0 2
55579: ARRAY
55580: PUSH
55581: LD_INT 1
55583: ARRAY
55584: IN
55585: NOT
55586: PUSH
55587: LD_VAR 0 3
55591: PUSH
55592: LD_EXP 119
55596: PUSH
55597: LD_VAR 0 2
55601: ARRAY
55602: PUSH
55603: LD_INT 2
55605: ARRAY
55606: IN
55607: NOT
55608: AND
55609: IFFALSE 55620
// ComSpaceTimeShoot ( j ) ;
55611: LD_VAR 0 3
55615: PPUSH
55616: CALL 66832 0 1
55620: GO 55562
55622: POP
55623: POP
// end ;
55624: GO 55465
55626: POP
55627: POP
// end ;
55628: LD_VAR 0 1
55632: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55633: LD_INT 0
55635: PPUSH
55636: PPUSH
55637: PPUSH
55638: PPUSH
55639: PPUSH
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
// if not mc_bases then
55644: LD_EXP 116
55648: NOT
55649: IFFALSE 55653
// exit ;
55651: GO 56275
// for i = 1 to mc_bases do
55653: LD_ADDR_VAR 0 2
55657: PUSH
55658: DOUBLE
55659: LD_INT 1
55661: DEC
55662: ST_TO_ADDR
55663: LD_EXP 116
55667: PUSH
55668: FOR_TO
55669: IFFALSE 56273
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55671: LD_EXP 151
55675: PUSH
55676: LD_VAR 0 2
55680: ARRAY
55681: NOT
55682: PUSH
55683: LD_INT 38
55685: PPUSH
55686: LD_EXP 142
55690: PUSH
55691: LD_VAR 0 2
55695: ARRAY
55696: PPUSH
55697: CALL_OW 321
55701: PUSH
55702: LD_INT 2
55704: NONEQUAL
55705: OR
55706: IFFALSE 55710
// continue ;
55708: GO 55668
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55710: LD_ADDR_VAR 0 8
55714: PUSH
55715: LD_EXP 116
55719: PUSH
55720: LD_VAR 0 2
55724: ARRAY
55725: PPUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 34
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PPUSH
55736: CALL_OW 72
55740: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55741: LD_ADDR_VAR 0 9
55745: PUSH
55746: LD_EXP 116
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 25
55759: PUSH
55760: LD_INT 4
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PPUSH
55767: CALL_OW 72
55771: PPUSH
55772: LD_INT 0
55774: PPUSH
55775: CALL 100140 0 2
55779: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55780: LD_VAR 0 9
55784: NOT
55785: PUSH
55786: LD_VAR 0 8
55790: NOT
55791: OR
55792: PUSH
55793: LD_EXP 116
55797: PUSH
55798: LD_VAR 0 2
55802: ARRAY
55803: PPUSH
55804: LD_INT 124
55806: PPUSH
55807: CALL 100140 0 2
55811: OR
55812: IFFALSE 55816
// continue ;
55814: GO 55668
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55816: LD_EXP 152
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: PUSH
55827: LD_EXP 151
55831: PUSH
55832: LD_VAR 0 2
55836: ARRAY
55837: LESS
55838: PUSH
55839: LD_EXP 152
55843: PUSH
55844: LD_VAR 0 2
55848: ARRAY
55849: PUSH
55850: LD_VAR 0 8
55854: LESS
55855: AND
55856: IFFALSE 56271
// begin tmp := sci [ 1 ] ;
55858: LD_ADDR_VAR 0 7
55862: PUSH
55863: LD_VAR 0 9
55867: PUSH
55868: LD_INT 1
55870: ARRAY
55871: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55872: LD_VAR 0 7
55876: PPUSH
55877: LD_INT 124
55879: PPUSH
55880: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: DOUBLE
55890: LD_EXP 151
55894: PUSH
55895: LD_VAR 0 2
55899: ARRAY
55900: INC
55901: ST_TO_ADDR
55902: LD_EXP 151
55906: PUSH
55907: LD_VAR 0 2
55911: ARRAY
55912: PUSH
55913: FOR_DOWNTO
55914: IFFALSE 56257
// begin if IsInUnit ( tmp ) then
55916: LD_VAR 0 7
55920: PPUSH
55921: CALL_OW 310
55925: IFFALSE 55936
// ComExitBuilding ( tmp ) ;
55927: LD_VAR 0 7
55931: PPUSH
55932: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55936: LD_INT 35
55938: PPUSH
55939: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55943: LD_VAR 0 7
55947: PPUSH
55948: CALL_OW 310
55952: NOT
55953: PUSH
55954: LD_VAR 0 7
55958: PPUSH
55959: CALL_OW 314
55963: NOT
55964: AND
55965: IFFALSE 55936
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55967: LD_ADDR_VAR 0 6
55971: PUSH
55972: LD_VAR 0 7
55976: PPUSH
55977: CALL_OW 250
55981: PUSH
55982: LD_VAR 0 7
55986: PPUSH
55987: CALL_OW 251
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55996: LD_INT 35
55998: PPUSH
55999: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
56003: LD_ADDR_VAR 0 4
56007: PUSH
56008: LD_EXP 151
56012: PUSH
56013: LD_VAR 0 2
56017: ARRAY
56018: PUSH
56019: LD_VAR 0 3
56023: ARRAY
56024: PUSH
56025: LD_INT 1
56027: ARRAY
56028: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56029: LD_ADDR_VAR 0 5
56033: PUSH
56034: LD_EXP 151
56038: PUSH
56039: LD_VAR 0 2
56043: ARRAY
56044: PUSH
56045: LD_VAR 0 3
56049: ARRAY
56050: PUSH
56051: LD_INT 2
56053: ARRAY
56054: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56055: LD_VAR 0 7
56059: PPUSH
56060: LD_INT 10
56062: PPUSH
56063: CALL 73470 0 2
56067: PUSH
56068: LD_INT 4
56070: ARRAY
56071: IFFALSE 56109
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56073: LD_VAR 0 7
56077: PPUSH
56078: LD_VAR 0 6
56082: PUSH
56083: LD_INT 1
56085: ARRAY
56086: PPUSH
56087: LD_VAR 0 6
56091: PUSH
56092: LD_INT 2
56094: ARRAY
56095: PPUSH
56096: CALL_OW 111
// wait ( 0 0$10 ) ;
56100: LD_INT 350
56102: PPUSH
56103: CALL_OW 67
// end else
56107: GO 56135
// begin ComMoveXY ( tmp , x , y ) ;
56109: LD_VAR 0 7
56113: PPUSH
56114: LD_VAR 0 4
56118: PPUSH
56119: LD_VAR 0 5
56123: PPUSH
56124: CALL_OW 111
// wait ( 0 0$3 ) ;
56128: LD_INT 105
56130: PPUSH
56131: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56135: LD_VAR 0 7
56139: PPUSH
56140: LD_VAR 0 4
56144: PPUSH
56145: LD_VAR 0 5
56149: PPUSH
56150: CALL_OW 307
56154: IFFALSE 55996
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56156: LD_VAR 0 7
56160: PPUSH
56161: LD_VAR 0 4
56165: PPUSH
56166: LD_VAR 0 5
56170: PPUSH
56171: LD_VAR 0 8
56175: PUSH
56176: LD_VAR 0 3
56180: ARRAY
56181: PPUSH
56182: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56186: LD_INT 35
56188: PPUSH
56189: CALL_OW 67
// until not HasTask ( tmp ) ;
56193: LD_VAR 0 7
56197: PPUSH
56198: CALL_OW 314
56202: NOT
56203: IFFALSE 56186
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56205: LD_ADDR_EXP 152
56209: PUSH
56210: LD_EXP 152
56214: PPUSH
56215: LD_VAR 0 2
56219: PUSH
56220: LD_EXP 152
56224: PUSH
56225: LD_VAR 0 2
56229: ARRAY
56230: PUSH
56231: LD_INT 1
56233: PLUS
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PPUSH
56239: LD_VAR 0 8
56243: PUSH
56244: LD_VAR 0 3
56248: ARRAY
56249: PPUSH
56250: CALL 70871 0 3
56254: ST_TO_ADDR
// end ;
56255: GO 55913
56257: POP
56258: POP
// MC_Reset ( i , 124 ) ;
56259: LD_VAR 0 2
56263: PPUSH
56264: LD_INT 124
56266: PPUSH
56267: CALL 39413 0 2
// end ; end ;
56271: GO 55668
56273: POP
56274: POP
// end ;
56275: LD_VAR 0 1
56279: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56280: LD_INT 0
56282: PPUSH
56283: PPUSH
56284: PPUSH
// if not mc_bases then
56285: LD_EXP 116
56289: NOT
56290: IFFALSE 56294
// exit ;
56292: GO 56900
// for i = 1 to mc_bases do
56294: LD_ADDR_VAR 0 2
56298: PUSH
56299: DOUBLE
56300: LD_INT 1
56302: DEC
56303: ST_TO_ADDR
56304: LD_EXP 116
56308: PUSH
56309: FOR_TO
56310: IFFALSE 56898
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56312: LD_ADDR_VAR 0 3
56316: PUSH
56317: LD_EXP 116
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: PPUSH
56328: LD_INT 25
56330: PUSH
56331: LD_INT 4
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PPUSH
56338: CALL_OW 72
56342: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56343: LD_VAR 0 3
56347: NOT
56348: PUSH
56349: LD_EXP 153
56353: PUSH
56354: LD_VAR 0 2
56358: ARRAY
56359: NOT
56360: OR
56361: PUSH
56362: LD_EXP 116
56366: PUSH
56367: LD_VAR 0 2
56371: ARRAY
56372: PPUSH
56373: LD_INT 2
56375: PUSH
56376: LD_INT 30
56378: PUSH
56379: LD_INT 0
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PUSH
56386: LD_INT 30
56388: PUSH
56389: LD_INT 1
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: EMPTY
56397: LIST
56398: LIST
56399: LIST
56400: PPUSH
56401: CALL_OW 72
56405: NOT
56406: OR
56407: IFFALSE 56457
// begin if mc_deposits_finder [ i ] then
56409: LD_EXP 154
56413: PUSH
56414: LD_VAR 0 2
56418: ARRAY
56419: IFFALSE 56455
// begin MC_Reset ( i , 125 ) ;
56421: LD_VAR 0 2
56425: PPUSH
56426: LD_INT 125
56428: PPUSH
56429: CALL 39413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56433: LD_ADDR_EXP 154
56437: PUSH
56438: LD_EXP 154
56442: PPUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: EMPTY
56449: PPUSH
56450: CALL_OW 1
56454: ST_TO_ADDR
// end ; continue ;
56455: GO 56309
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56457: LD_EXP 153
56461: PUSH
56462: LD_VAR 0 2
56466: ARRAY
56467: PUSH
56468: LD_INT 1
56470: ARRAY
56471: PUSH
56472: LD_INT 3
56474: ARRAY
56475: PUSH
56476: LD_INT 1
56478: EQUAL
56479: PUSH
56480: LD_INT 20
56482: PPUSH
56483: LD_EXP 142
56487: PUSH
56488: LD_VAR 0 2
56492: ARRAY
56493: PPUSH
56494: CALL_OW 321
56498: PUSH
56499: LD_INT 2
56501: NONEQUAL
56502: AND
56503: IFFALSE 56553
// begin if mc_deposits_finder [ i ] then
56505: LD_EXP 154
56509: PUSH
56510: LD_VAR 0 2
56514: ARRAY
56515: IFFALSE 56551
// begin MC_Reset ( i , 125 ) ;
56517: LD_VAR 0 2
56521: PPUSH
56522: LD_INT 125
56524: PPUSH
56525: CALL 39413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56529: LD_ADDR_EXP 154
56533: PUSH
56534: LD_EXP 154
56538: PPUSH
56539: LD_VAR 0 2
56543: PPUSH
56544: EMPTY
56545: PPUSH
56546: CALL_OW 1
56550: ST_TO_ADDR
// end ; continue ;
56551: GO 56309
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56553: LD_EXP 153
56557: PUSH
56558: LD_VAR 0 2
56562: ARRAY
56563: PUSH
56564: LD_INT 1
56566: ARRAY
56567: PUSH
56568: LD_INT 1
56570: ARRAY
56571: PPUSH
56572: LD_EXP 153
56576: PUSH
56577: LD_VAR 0 2
56581: ARRAY
56582: PUSH
56583: LD_INT 1
56585: ARRAY
56586: PUSH
56587: LD_INT 2
56589: ARRAY
56590: PPUSH
56591: LD_EXP 142
56595: PUSH
56596: LD_VAR 0 2
56600: ARRAY
56601: PPUSH
56602: CALL_OW 440
56606: IFFALSE 56649
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56608: LD_ADDR_EXP 153
56612: PUSH
56613: LD_EXP 153
56617: PPUSH
56618: LD_VAR 0 2
56622: PPUSH
56623: LD_EXP 153
56627: PUSH
56628: LD_VAR 0 2
56632: ARRAY
56633: PPUSH
56634: LD_INT 1
56636: PPUSH
56637: CALL_OW 3
56641: PPUSH
56642: CALL_OW 1
56646: ST_TO_ADDR
56647: GO 56896
// begin if not mc_deposits_finder [ i ] then
56649: LD_EXP 154
56653: PUSH
56654: LD_VAR 0 2
56658: ARRAY
56659: NOT
56660: IFFALSE 56712
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56662: LD_ADDR_EXP 154
56666: PUSH
56667: LD_EXP 154
56671: PPUSH
56672: LD_VAR 0 2
56676: PPUSH
56677: LD_VAR 0 3
56681: PUSH
56682: LD_INT 1
56684: ARRAY
56685: PUSH
56686: EMPTY
56687: LIST
56688: PPUSH
56689: CALL_OW 1
56693: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56694: LD_VAR 0 3
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PPUSH
56703: LD_INT 125
56705: PPUSH
56706: CALL_OW 109
// end else
56710: GO 56896
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56712: LD_EXP 154
56716: PUSH
56717: LD_VAR 0 2
56721: ARRAY
56722: PUSH
56723: LD_INT 1
56725: ARRAY
56726: PPUSH
56727: CALL_OW 310
56731: IFFALSE 56754
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56733: LD_EXP 154
56737: PUSH
56738: LD_VAR 0 2
56742: ARRAY
56743: PUSH
56744: LD_INT 1
56746: ARRAY
56747: PPUSH
56748: CALL_OW 122
56752: GO 56896
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56754: LD_EXP 154
56758: PUSH
56759: LD_VAR 0 2
56763: ARRAY
56764: PUSH
56765: LD_INT 1
56767: ARRAY
56768: PPUSH
56769: CALL_OW 314
56773: NOT
56774: PUSH
56775: LD_EXP 154
56779: PUSH
56780: LD_VAR 0 2
56784: ARRAY
56785: PUSH
56786: LD_INT 1
56788: ARRAY
56789: PPUSH
56790: LD_EXP 153
56794: PUSH
56795: LD_VAR 0 2
56799: ARRAY
56800: PUSH
56801: LD_INT 1
56803: ARRAY
56804: PUSH
56805: LD_INT 1
56807: ARRAY
56808: PPUSH
56809: LD_EXP 153
56813: PUSH
56814: LD_VAR 0 2
56818: ARRAY
56819: PUSH
56820: LD_INT 1
56822: ARRAY
56823: PUSH
56824: LD_INT 2
56826: ARRAY
56827: PPUSH
56828: CALL_OW 297
56832: PUSH
56833: LD_INT 6
56835: GREATER
56836: AND
56837: IFFALSE 56896
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56839: LD_EXP 154
56843: PUSH
56844: LD_VAR 0 2
56848: ARRAY
56849: PUSH
56850: LD_INT 1
56852: ARRAY
56853: PPUSH
56854: LD_EXP 153
56858: PUSH
56859: LD_VAR 0 2
56863: ARRAY
56864: PUSH
56865: LD_INT 1
56867: ARRAY
56868: PUSH
56869: LD_INT 1
56871: ARRAY
56872: PPUSH
56873: LD_EXP 153
56877: PUSH
56878: LD_VAR 0 2
56882: ARRAY
56883: PUSH
56884: LD_INT 1
56886: ARRAY
56887: PUSH
56888: LD_INT 2
56890: ARRAY
56891: PPUSH
56892: CALL_OW 111
// end ; end ; end ;
56896: GO 56309
56898: POP
56899: POP
// end ;
56900: LD_VAR 0 1
56904: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56905: LD_INT 0
56907: PPUSH
56908: PPUSH
56909: PPUSH
56910: PPUSH
56911: PPUSH
56912: PPUSH
56913: PPUSH
56914: PPUSH
56915: PPUSH
56916: PPUSH
56917: PPUSH
// if not mc_bases then
56918: LD_EXP 116
56922: NOT
56923: IFFALSE 56927
// exit ;
56925: GO 57867
// for i = 1 to mc_bases do
56927: LD_ADDR_VAR 0 2
56931: PUSH
56932: DOUBLE
56933: LD_INT 1
56935: DEC
56936: ST_TO_ADDR
56937: LD_EXP 116
56941: PUSH
56942: FOR_TO
56943: IFFALSE 57865
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56945: LD_EXP 116
56949: PUSH
56950: LD_VAR 0 2
56954: ARRAY
56955: NOT
56956: PUSH
56957: LD_EXP 139
56961: PUSH
56962: LD_VAR 0 2
56966: ARRAY
56967: OR
56968: IFFALSE 56972
// continue ;
56970: GO 56942
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56972: LD_ADDR_VAR 0 7
56976: PUSH
56977: LD_EXP 116
56981: PUSH
56982: LD_VAR 0 2
56986: ARRAY
56987: PUSH
56988: LD_INT 1
56990: ARRAY
56991: PPUSH
56992: CALL_OW 248
56996: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56997: LD_VAR 0 7
57001: PUSH
57002: LD_INT 3
57004: EQUAL
57005: PUSH
57006: LD_EXP 135
57010: PUSH
57011: LD_VAR 0 2
57015: ARRAY
57016: PUSH
57017: LD_EXP 138
57021: PUSH
57022: LD_VAR 0 2
57026: ARRAY
57027: UNION
57028: PPUSH
57029: LD_INT 33
57031: PUSH
57032: LD_INT 2
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: PPUSH
57039: CALL_OW 72
57043: NOT
57044: OR
57045: IFFALSE 57049
// continue ;
57047: GO 56942
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57049: LD_ADDR_VAR 0 9
57053: PUSH
57054: LD_EXP 116
57058: PUSH
57059: LD_VAR 0 2
57063: ARRAY
57064: PPUSH
57065: LD_INT 30
57067: PUSH
57068: LD_INT 36
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: PPUSH
57075: CALL_OW 72
57079: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57080: LD_ADDR_VAR 0 10
57084: PUSH
57085: LD_EXP 135
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: PPUSH
57096: LD_INT 34
57098: PUSH
57099: LD_INT 31
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PPUSH
57106: CALL_OW 72
57110: ST_TO_ADDR
// if not cts and not mcts then
57111: LD_VAR 0 9
57115: NOT
57116: PUSH
57117: LD_VAR 0 10
57121: NOT
57122: AND
57123: IFFALSE 57127
// continue ;
57125: GO 56942
// x := cts ;
57127: LD_ADDR_VAR 0 11
57131: PUSH
57132: LD_VAR 0 9
57136: ST_TO_ADDR
// if not x then
57137: LD_VAR 0 11
57141: NOT
57142: IFFALSE 57154
// x := mcts ;
57144: LD_ADDR_VAR 0 11
57148: PUSH
57149: LD_VAR 0 10
57153: ST_TO_ADDR
// if not x then
57154: LD_VAR 0 11
57158: NOT
57159: IFFALSE 57163
// continue ;
57161: GO 56942
// if mc_remote_driver [ i ] then
57163: LD_EXP 156
57167: PUSH
57168: LD_VAR 0 2
57172: ARRAY
57173: IFFALSE 57560
// for j in mc_remote_driver [ i ] do
57175: LD_ADDR_VAR 0 3
57179: PUSH
57180: LD_EXP 156
57184: PUSH
57185: LD_VAR 0 2
57189: ARRAY
57190: PUSH
57191: FOR_IN
57192: IFFALSE 57558
// begin if GetClass ( j ) <> 3 then
57194: LD_VAR 0 3
57198: PPUSH
57199: CALL_OW 257
57203: PUSH
57204: LD_INT 3
57206: NONEQUAL
57207: IFFALSE 57260
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57209: LD_ADDR_EXP 156
57213: PUSH
57214: LD_EXP 156
57218: PPUSH
57219: LD_VAR 0 2
57223: PPUSH
57224: LD_EXP 156
57228: PUSH
57229: LD_VAR 0 2
57233: ARRAY
57234: PUSH
57235: LD_VAR 0 3
57239: DIFF
57240: PPUSH
57241: CALL_OW 1
57245: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57246: LD_VAR 0 3
57250: PPUSH
57251: LD_INT 0
57253: PPUSH
57254: CALL_OW 109
// continue ;
57258: GO 57191
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57260: LD_EXP 135
57264: PUSH
57265: LD_VAR 0 2
57269: ARRAY
57270: PPUSH
57271: LD_INT 34
57273: PUSH
57274: LD_INT 31
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: PUSH
57281: LD_INT 58
57283: PUSH
57284: EMPTY
57285: LIST
57286: PUSH
57287: EMPTY
57288: LIST
57289: LIST
57290: PPUSH
57291: CALL_OW 72
57295: PUSH
57296: LD_VAR 0 3
57300: PPUSH
57301: CALL 100228 0 1
57305: NOT
57306: AND
57307: IFFALSE 57378
// begin if IsInUnit ( j ) then
57309: LD_VAR 0 3
57313: PPUSH
57314: CALL_OW 310
57318: IFFALSE 57329
// ComExitBuilding ( j ) ;
57320: LD_VAR 0 3
57324: PPUSH
57325: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57329: LD_VAR 0 3
57333: PPUSH
57334: LD_EXP 135
57338: PUSH
57339: LD_VAR 0 2
57343: ARRAY
57344: PPUSH
57345: LD_INT 34
57347: PUSH
57348: LD_INT 31
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: PUSH
57355: LD_INT 58
57357: PUSH
57358: EMPTY
57359: LIST
57360: PUSH
57361: EMPTY
57362: LIST
57363: LIST
57364: PPUSH
57365: CALL_OW 72
57369: PUSH
57370: LD_INT 1
57372: ARRAY
57373: PPUSH
57374: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57378: LD_VAR 0 3
57382: PPUSH
57383: CALL_OW 310
57387: NOT
57388: PUSH
57389: LD_VAR 0 3
57393: PPUSH
57394: CALL_OW 310
57398: PPUSH
57399: CALL_OW 266
57403: PUSH
57404: LD_INT 36
57406: NONEQUAL
57407: PUSH
57408: LD_VAR 0 3
57412: PPUSH
57413: CALL 100228 0 1
57417: NOT
57418: AND
57419: OR
57420: IFFALSE 57556
// begin if IsInUnit ( j ) then
57422: LD_VAR 0 3
57426: PPUSH
57427: CALL_OW 310
57431: IFFALSE 57442
// ComExitBuilding ( j ) ;
57433: LD_VAR 0 3
57437: PPUSH
57438: CALL_OW 122
// ct := 0 ;
57442: LD_ADDR_VAR 0 8
57446: PUSH
57447: LD_INT 0
57449: ST_TO_ADDR
// for k in x do
57450: LD_ADDR_VAR 0 4
57454: PUSH
57455: LD_VAR 0 11
57459: PUSH
57460: FOR_IN
57461: IFFALSE 57534
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57463: LD_VAR 0 4
57467: PPUSH
57468: CALL_OW 264
57472: PUSH
57473: LD_INT 31
57475: EQUAL
57476: PUSH
57477: LD_VAR 0 4
57481: PPUSH
57482: CALL_OW 311
57486: NOT
57487: AND
57488: PUSH
57489: LD_VAR 0 4
57493: PPUSH
57494: CALL_OW 266
57498: PUSH
57499: LD_INT 36
57501: EQUAL
57502: PUSH
57503: LD_VAR 0 4
57507: PPUSH
57508: CALL_OW 313
57512: PUSH
57513: LD_INT 3
57515: LESS
57516: AND
57517: OR
57518: IFFALSE 57532
// begin ct := k ;
57520: LD_ADDR_VAR 0 8
57524: PUSH
57525: LD_VAR 0 4
57529: ST_TO_ADDR
// break ;
57530: GO 57534
// end ;
57532: GO 57460
57534: POP
57535: POP
// if ct then
57536: LD_VAR 0 8
57540: IFFALSE 57556
// ComEnterUnit ( j , ct ) ;
57542: LD_VAR 0 3
57546: PPUSH
57547: LD_VAR 0 8
57551: PPUSH
57552: CALL_OW 120
// end ; end ;
57556: GO 57191
57558: POP
57559: POP
// places := 0 ;
57560: LD_ADDR_VAR 0 5
57564: PUSH
57565: LD_INT 0
57567: ST_TO_ADDR
// for j = 1 to x do
57568: LD_ADDR_VAR 0 3
57572: PUSH
57573: DOUBLE
57574: LD_INT 1
57576: DEC
57577: ST_TO_ADDR
57578: LD_VAR 0 11
57582: PUSH
57583: FOR_TO
57584: IFFALSE 57660
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57586: LD_VAR 0 11
57590: PUSH
57591: LD_VAR 0 3
57595: ARRAY
57596: PPUSH
57597: CALL_OW 264
57601: PUSH
57602: LD_INT 31
57604: EQUAL
57605: IFFALSE 57623
// places := places + 1 else
57607: LD_ADDR_VAR 0 5
57611: PUSH
57612: LD_VAR 0 5
57616: PUSH
57617: LD_INT 1
57619: PLUS
57620: ST_TO_ADDR
57621: GO 57658
// if GetBType ( x [ j ] ) = b_control_tower then
57623: LD_VAR 0 11
57627: PUSH
57628: LD_VAR 0 3
57632: ARRAY
57633: PPUSH
57634: CALL_OW 266
57638: PUSH
57639: LD_INT 36
57641: EQUAL
57642: IFFALSE 57658
// places := places + 3 ;
57644: LD_ADDR_VAR 0 5
57648: PUSH
57649: LD_VAR 0 5
57653: PUSH
57654: LD_INT 3
57656: PLUS
57657: ST_TO_ADDR
57658: GO 57583
57660: POP
57661: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57662: LD_VAR 0 5
57666: PUSH
57667: LD_INT 0
57669: EQUAL
57670: PUSH
57671: LD_VAR 0 5
57675: PUSH
57676: LD_EXP 156
57680: PUSH
57681: LD_VAR 0 2
57685: ARRAY
57686: LESSEQUAL
57687: OR
57688: IFFALSE 57692
// continue ;
57690: GO 56942
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57692: LD_ADDR_VAR 0 6
57696: PUSH
57697: LD_EXP 116
57701: PUSH
57702: LD_VAR 0 2
57706: ARRAY
57707: PPUSH
57708: LD_INT 25
57710: PUSH
57711: LD_INT 3
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PPUSH
57718: CALL_OW 72
57722: PUSH
57723: LD_EXP 156
57727: PUSH
57728: LD_VAR 0 2
57732: ARRAY
57733: DIFF
57734: PPUSH
57735: LD_INT 3
57737: PPUSH
57738: CALL 101128 0 2
57742: ST_TO_ADDR
// for j in tmp do
57743: LD_ADDR_VAR 0 3
57747: PUSH
57748: LD_VAR 0 6
57752: PUSH
57753: FOR_IN
57754: IFFALSE 57789
// if GetTag ( j ) > 0 then
57756: LD_VAR 0 3
57760: PPUSH
57761: CALL_OW 110
57765: PUSH
57766: LD_INT 0
57768: GREATER
57769: IFFALSE 57787
// tmp := tmp diff j ;
57771: LD_ADDR_VAR 0 6
57775: PUSH
57776: LD_VAR 0 6
57780: PUSH
57781: LD_VAR 0 3
57785: DIFF
57786: ST_TO_ADDR
57787: GO 57753
57789: POP
57790: POP
// if not tmp then
57791: LD_VAR 0 6
57795: NOT
57796: IFFALSE 57800
// continue ;
57798: GO 56942
// if places then
57800: LD_VAR 0 5
57804: IFFALSE 57863
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57806: LD_ADDR_EXP 156
57810: PUSH
57811: LD_EXP 156
57815: PPUSH
57816: LD_VAR 0 2
57820: PPUSH
57821: LD_EXP 156
57825: PUSH
57826: LD_VAR 0 2
57830: ARRAY
57831: PUSH
57832: LD_VAR 0 6
57836: PUSH
57837: LD_INT 1
57839: ARRAY
57840: UNION
57841: PPUSH
57842: CALL_OW 1
57846: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57847: LD_VAR 0 6
57851: PUSH
57852: LD_INT 1
57854: ARRAY
57855: PPUSH
57856: LD_INT 126
57858: PPUSH
57859: CALL_OW 109
// end ; end ;
57863: GO 56942
57865: POP
57866: POP
// end ;
57867: LD_VAR 0 1
57871: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57872: LD_INT 0
57874: PPUSH
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
57879: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57880: LD_VAR 0 1
57884: NOT
57885: PUSH
57886: LD_VAR 0 2
57890: NOT
57891: OR
57892: PUSH
57893: LD_VAR 0 3
57897: NOT
57898: OR
57899: PUSH
57900: LD_VAR 0 4
57904: PUSH
57905: LD_INT 1
57907: PUSH
57908: LD_INT 2
57910: PUSH
57911: LD_INT 3
57913: PUSH
57914: LD_INT 4
57916: PUSH
57917: LD_INT 5
57919: PUSH
57920: LD_INT 8
57922: PUSH
57923: LD_INT 9
57925: PUSH
57926: LD_INT 15
57928: PUSH
57929: LD_INT 16
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: LIST
57936: LIST
57937: LIST
57938: LIST
57939: LIST
57940: LIST
57941: LIST
57942: IN
57943: NOT
57944: OR
57945: IFFALSE 57949
// exit ;
57947: GO 58849
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57949: LD_ADDR_VAR 0 2
57953: PUSH
57954: LD_VAR 0 2
57958: PPUSH
57959: LD_INT 21
57961: PUSH
57962: LD_INT 3
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: LD_INT 24
57971: PUSH
57972: LD_INT 250
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: PPUSH
57983: CALL_OW 72
57987: ST_TO_ADDR
// case class of 1 , 15 :
57988: LD_VAR 0 4
57992: PUSH
57993: LD_INT 1
57995: DOUBLE
57996: EQUAL
57997: IFTRUE 58007
57999: LD_INT 15
58001: DOUBLE
58002: EQUAL
58003: IFTRUE 58007
58005: GO 58092
58007: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58008: LD_ADDR_VAR 0 8
58012: PUSH
58013: LD_VAR 0 2
58017: PPUSH
58018: LD_INT 2
58020: PUSH
58021: LD_INT 30
58023: PUSH
58024: LD_INT 32
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PUSH
58031: LD_INT 30
58033: PUSH
58034: LD_INT 31
58036: PUSH
58037: EMPTY
58038: LIST
58039: LIST
58040: PUSH
58041: EMPTY
58042: LIST
58043: LIST
58044: LIST
58045: PPUSH
58046: CALL_OW 72
58050: PUSH
58051: LD_VAR 0 2
58055: PPUSH
58056: LD_INT 2
58058: PUSH
58059: LD_INT 30
58061: PUSH
58062: LD_INT 4
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: PUSH
58069: LD_INT 30
58071: PUSH
58072: LD_INT 5
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: PPUSH
58084: CALL_OW 72
58088: ADD
58089: ST_TO_ADDR
58090: GO 58338
58092: LD_INT 2
58094: DOUBLE
58095: EQUAL
58096: IFTRUE 58106
58098: LD_INT 16
58100: DOUBLE
58101: EQUAL
58102: IFTRUE 58106
58104: GO 58152
58106: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58107: LD_ADDR_VAR 0 8
58111: PUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: LD_INT 2
58119: PUSH
58120: LD_INT 30
58122: PUSH
58123: LD_INT 0
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: PUSH
58130: LD_INT 30
58132: PUSH
58133: LD_INT 1
58135: PUSH
58136: EMPTY
58137: LIST
58138: LIST
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: LIST
58144: PPUSH
58145: CALL_OW 72
58149: ST_TO_ADDR
58150: GO 58338
58152: LD_INT 3
58154: DOUBLE
58155: EQUAL
58156: IFTRUE 58160
58158: GO 58206
58160: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58161: LD_ADDR_VAR 0 8
58165: PUSH
58166: LD_VAR 0 2
58170: PPUSH
58171: LD_INT 2
58173: PUSH
58174: LD_INT 30
58176: PUSH
58177: LD_INT 2
58179: PUSH
58180: EMPTY
58181: LIST
58182: LIST
58183: PUSH
58184: LD_INT 30
58186: PUSH
58187: LD_INT 3
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: PUSH
58194: EMPTY
58195: LIST
58196: LIST
58197: LIST
58198: PPUSH
58199: CALL_OW 72
58203: ST_TO_ADDR
58204: GO 58338
58206: LD_INT 4
58208: DOUBLE
58209: EQUAL
58210: IFTRUE 58214
58212: GO 58271
58214: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58215: LD_ADDR_VAR 0 8
58219: PUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: LD_INT 2
58227: PUSH
58228: LD_INT 30
58230: PUSH
58231: LD_INT 6
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: PUSH
58238: LD_INT 30
58240: PUSH
58241: LD_INT 7
58243: PUSH
58244: EMPTY
58245: LIST
58246: LIST
58247: PUSH
58248: LD_INT 30
58250: PUSH
58251: LD_INT 8
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: PUSH
58258: EMPTY
58259: LIST
58260: LIST
58261: LIST
58262: LIST
58263: PPUSH
58264: CALL_OW 72
58268: ST_TO_ADDR
58269: GO 58338
58271: LD_INT 5
58273: DOUBLE
58274: EQUAL
58275: IFTRUE 58291
58277: LD_INT 8
58279: DOUBLE
58280: EQUAL
58281: IFTRUE 58291
58283: LD_INT 9
58285: DOUBLE
58286: EQUAL
58287: IFTRUE 58291
58289: GO 58337
58291: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58292: LD_ADDR_VAR 0 8
58296: PUSH
58297: LD_VAR 0 2
58301: PPUSH
58302: LD_INT 2
58304: PUSH
58305: LD_INT 30
58307: PUSH
58308: LD_INT 4
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: LD_INT 30
58317: PUSH
58318: LD_INT 5
58320: PUSH
58321: EMPTY
58322: LIST
58323: LIST
58324: PUSH
58325: EMPTY
58326: LIST
58327: LIST
58328: LIST
58329: PPUSH
58330: CALL_OW 72
58334: ST_TO_ADDR
58335: GO 58338
58337: POP
// if not tmp then
58338: LD_VAR 0 8
58342: NOT
58343: IFFALSE 58347
// exit ;
58345: GO 58849
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58347: LD_VAR 0 4
58351: PUSH
58352: LD_INT 1
58354: PUSH
58355: LD_INT 15
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: IN
58362: PUSH
58363: LD_EXP 125
58367: PUSH
58368: LD_VAR 0 1
58372: ARRAY
58373: AND
58374: IFFALSE 58530
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58376: LD_ADDR_VAR 0 9
58380: PUSH
58381: LD_EXP 125
58385: PUSH
58386: LD_VAR 0 1
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58396: LD_VAR 0 9
58400: PUSH
58401: LD_EXP 126
58405: PUSH
58406: LD_VAR 0 1
58410: ARRAY
58411: IN
58412: NOT
58413: IFFALSE 58528
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58415: LD_ADDR_EXP 126
58419: PUSH
58420: LD_EXP 126
58424: PPUSH
58425: LD_VAR 0 1
58429: PUSH
58430: LD_EXP 126
58434: PUSH
58435: LD_VAR 0 1
58439: ARRAY
58440: PUSH
58441: LD_INT 1
58443: PLUS
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: PPUSH
58449: LD_VAR 0 9
58453: PPUSH
58454: CALL 70871 0 3
58458: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58459: LD_ADDR_EXP 125
58463: PUSH
58464: LD_EXP 125
58468: PPUSH
58469: LD_VAR 0 1
58473: PPUSH
58474: LD_EXP 125
58478: PUSH
58479: LD_VAR 0 1
58483: ARRAY
58484: PUSH
58485: LD_VAR 0 9
58489: DIFF
58490: PPUSH
58491: CALL_OW 1
58495: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58496: LD_VAR 0 3
58500: PPUSH
58501: LD_EXP 126
58505: PUSH
58506: LD_VAR 0 1
58510: ARRAY
58511: PUSH
58512: LD_EXP 126
58516: PUSH
58517: LD_VAR 0 1
58521: ARRAY
58522: ARRAY
58523: PPUSH
58524: CALL_OW 120
// end ; exit ;
58528: GO 58849
// end ; if tmp > 1 then
58530: LD_VAR 0 8
58534: PUSH
58535: LD_INT 1
58537: GREATER
58538: IFFALSE 58642
// for i = 2 to tmp do
58540: LD_ADDR_VAR 0 6
58544: PUSH
58545: DOUBLE
58546: LD_INT 2
58548: DEC
58549: ST_TO_ADDR
58550: LD_VAR 0 8
58554: PUSH
58555: FOR_TO
58556: IFFALSE 58640
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58558: LD_VAR 0 8
58562: PUSH
58563: LD_VAR 0 6
58567: ARRAY
58568: PPUSH
58569: CALL_OW 461
58573: PUSH
58574: LD_INT 6
58576: EQUAL
58577: IFFALSE 58638
// begin x := tmp [ i ] ;
58579: LD_ADDR_VAR 0 9
58583: PUSH
58584: LD_VAR 0 8
58588: PUSH
58589: LD_VAR 0 6
58593: ARRAY
58594: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58595: LD_ADDR_VAR 0 8
58599: PUSH
58600: LD_VAR 0 8
58604: PPUSH
58605: LD_VAR 0 6
58609: PPUSH
58610: CALL_OW 3
58614: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58615: LD_ADDR_VAR 0 8
58619: PUSH
58620: LD_VAR 0 8
58624: PPUSH
58625: LD_INT 1
58627: PPUSH
58628: LD_VAR 0 9
58632: PPUSH
58633: CALL_OW 2
58637: ST_TO_ADDR
// end ;
58638: GO 58555
58640: POP
58641: POP
// for i in tmp do
58642: LD_ADDR_VAR 0 6
58646: PUSH
58647: LD_VAR 0 8
58651: PUSH
58652: FOR_IN
58653: IFFALSE 58722
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58655: LD_VAR 0 6
58659: PPUSH
58660: CALL_OW 313
58664: PUSH
58665: LD_INT 6
58667: LESS
58668: PUSH
58669: LD_VAR 0 6
58673: PPUSH
58674: CALL_OW 266
58678: PUSH
58679: LD_INT 31
58681: PUSH
58682: LD_INT 32
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: IN
58689: NOT
58690: AND
58691: PUSH
58692: LD_VAR 0 6
58696: PPUSH
58697: CALL_OW 313
58701: PUSH
58702: LD_INT 0
58704: EQUAL
58705: OR
58706: IFFALSE 58720
// begin j := i ;
58708: LD_ADDR_VAR 0 7
58712: PUSH
58713: LD_VAR 0 6
58717: ST_TO_ADDR
// break ;
58718: GO 58722
// end ; end ;
58720: GO 58652
58722: POP
58723: POP
// if j then
58724: LD_VAR 0 7
58728: IFFALSE 58746
// ComEnterUnit ( unit , j ) else
58730: LD_VAR 0 3
58734: PPUSH
58735: LD_VAR 0 7
58739: PPUSH
58740: CALL_OW 120
58744: GO 58849
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58746: LD_ADDR_VAR 0 10
58750: PUSH
58751: LD_VAR 0 2
58755: PPUSH
58756: LD_INT 2
58758: PUSH
58759: LD_INT 30
58761: PUSH
58762: LD_INT 0
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: PUSH
58769: LD_INT 30
58771: PUSH
58772: LD_INT 1
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: LIST
58783: PPUSH
58784: CALL_OW 72
58788: ST_TO_ADDR
// if depot then
58789: LD_VAR 0 10
58793: IFFALSE 58849
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58795: LD_ADDR_VAR 0 10
58799: PUSH
58800: LD_VAR 0 10
58804: PPUSH
58805: LD_VAR 0 3
58809: PPUSH
58810: CALL_OW 74
58814: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58815: LD_VAR 0 3
58819: PPUSH
58820: LD_VAR 0 10
58824: PPUSH
58825: CALL_OW 296
58829: PUSH
58830: LD_INT 10
58832: GREATER
58833: IFFALSE 58849
// ComStandNearbyBuilding ( unit , depot ) ;
58835: LD_VAR 0 3
58839: PPUSH
58840: LD_VAR 0 10
58844: PPUSH
58845: CALL 67449 0 2
// end ; end ; end ;
58849: LD_VAR 0 5
58853: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58854: LD_INT 0
58856: PPUSH
58857: PPUSH
58858: PPUSH
58859: PPUSH
// if not mc_bases then
58860: LD_EXP 116
58864: NOT
58865: IFFALSE 58869
// exit ;
58867: GO 59108
// for i = 1 to mc_bases do
58869: LD_ADDR_VAR 0 2
58873: PUSH
58874: DOUBLE
58875: LD_INT 1
58877: DEC
58878: ST_TO_ADDR
58879: LD_EXP 116
58883: PUSH
58884: FOR_TO
58885: IFFALSE 59106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58887: LD_ADDR_VAR 0 4
58891: PUSH
58892: LD_EXP 116
58896: PUSH
58897: LD_VAR 0 2
58901: ARRAY
58902: PPUSH
58903: LD_INT 21
58905: PUSH
58906: LD_INT 1
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: PPUSH
58913: CALL_OW 72
58917: PUSH
58918: LD_EXP 145
58922: PUSH
58923: LD_VAR 0 2
58927: ARRAY
58928: UNION
58929: ST_TO_ADDR
// if not tmp then
58930: LD_VAR 0 4
58934: NOT
58935: IFFALSE 58939
// continue ;
58937: GO 58884
// for j in tmp do
58939: LD_ADDR_VAR 0 3
58943: PUSH
58944: LD_VAR 0 4
58948: PUSH
58949: FOR_IN
58950: IFFALSE 59102
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58952: LD_VAR 0 3
58956: PPUSH
58957: CALL_OW 110
58961: NOT
58962: PUSH
58963: LD_VAR 0 3
58967: PPUSH
58968: CALL_OW 314
58972: NOT
58973: AND
58974: PUSH
58975: LD_VAR 0 3
58979: PPUSH
58980: CALL_OW 311
58984: NOT
58985: AND
58986: PUSH
58987: LD_VAR 0 3
58991: PPUSH
58992: CALL_OW 310
58996: NOT
58997: AND
58998: PUSH
58999: LD_VAR 0 3
59003: PUSH
59004: LD_EXP 119
59008: PUSH
59009: LD_VAR 0 2
59013: ARRAY
59014: PUSH
59015: LD_INT 1
59017: ARRAY
59018: IN
59019: NOT
59020: AND
59021: PUSH
59022: LD_VAR 0 3
59026: PUSH
59027: LD_EXP 119
59031: PUSH
59032: LD_VAR 0 2
59036: ARRAY
59037: PUSH
59038: LD_INT 2
59040: ARRAY
59041: IN
59042: NOT
59043: AND
59044: PUSH
59045: LD_VAR 0 3
59049: PUSH
59050: LD_EXP 128
59054: PUSH
59055: LD_VAR 0 2
59059: ARRAY
59060: IN
59061: NOT
59062: AND
59063: IFFALSE 59100
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59065: LD_VAR 0 2
59069: PPUSH
59070: LD_EXP 116
59074: PUSH
59075: LD_VAR 0 2
59079: ARRAY
59080: PPUSH
59081: LD_VAR 0 3
59085: PPUSH
59086: LD_VAR 0 3
59090: PPUSH
59091: CALL_OW 257
59095: PPUSH
59096: CALL 57872 0 4
// end ;
59100: GO 58949
59102: POP
59103: POP
// end ;
59104: GO 58884
59106: POP
59107: POP
// end ;
59108: LD_VAR 0 1
59112: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59113: LD_INT 0
59115: PPUSH
59116: PPUSH
59117: PPUSH
59118: PPUSH
59119: PPUSH
59120: PPUSH
// if not mc_bases [ base ] then
59121: LD_EXP 116
59125: PUSH
59126: LD_VAR 0 1
59130: ARRAY
59131: NOT
59132: IFFALSE 59136
// exit ;
59134: GO 59318
// tmp := [ ] ;
59136: LD_ADDR_VAR 0 6
59140: PUSH
59141: EMPTY
59142: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59143: LD_ADDR_VAR 0 7
59147: PUSH
59148: LD_VAR 0 3
59152: PPUSH
59153: LD_INT 0
59155: PPUSH
59156: CALL_OW 517
59160: ST_TO_ADDR
// if not list then
59161: LD_VAR 0 7
59165: NOT
59166: IFFALSE 59170
// exit ;
59168: GO 59318
// for i = 1 to amount do
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: DOUBLE
59176: LD_INT 1
59178: DEC
59179: ST_TO_ADDR
59180: LD_VAR 0 2
59184: PUSH
59185: FOR_TO
59186: IFFALSE 59266
// begin x := rand ( 1 , list [ 1 ] ) ;
59188: LD_ADDR_VAR 0 8
59192: PUSH
59193: LD_INT 1
59195: PPUSH
59196: LD_VAR 0 7
59200: PUSH
59201: LD_INT 1
59203: ARRAY
59204: PPUSH
59205: CALL_OW 12
59209: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59210: LD_ADDR_VAR 0 6
59214: PUSH
59215: LD_VAR 0 6
59219: PPUSH
59220: LD_VAR 0 5
59224: PPUSH
59225: LD_VAR 0 7
59229: PUSH
59230: LD_INT 1
59232: ARRAY
59233: PUSH
59234: LD_VAR 0 8
59238: ARRAY
59239: PUSH
59240: LD_VAR 0 7
59244: PUSH
59245: LD_INT 2
59247: ARRAY
59248: PUSH
59249: LD_VAR 0 8
59253: ARRAY
59254: PUSH
59255: EMPTY
59256: LIST
59257: LIST
59258: PPUSH
59259: CALL_OW 1
59263: ST_TO_ADDR
// end ;
59264: GO 59185
59266: POP
59267: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59268: LD_ADDR_EXP 129
59272: PUSH
59273: LD_EXP 129
59277: PPUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: LD_VAR 0 6
59287: PPUSH
59288: CALL_OW 1
59292: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59293: LD_ADDR_EXP 131
59297: PUSH
59298: LD_EXP 131
59302: PPUSH
59303: LD_VAR 0 1
59307: PPUSH
59308: LD_VAR 0 3
59312: PPUSH
59313: CALL_OW 1
59317: ST_TO_ADDR
// end ;
59318: LD_VAR 0 4
59322: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59323: LD_INT 0
59325: PPUSH
// if not mc_bases [ base ] then
59326: LD_EXP 116
59330: PUSH
59331: LD_VAR 0 1
59335: ARRAY
59336: NOT
59337: IFFALSE 59341
// exit ;
59339: GO 59366
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59341: LD_ADDR_EXP 121
59345: PUSH
59346: LD_EXP 121
59350: PPUSH
59351: LD_VAR 0 1
59355: PPUSH
59356: LD_VAR 0 2
59360: PPUSH
59361: CALL_OW 1
59365: ST_TO_ADDR
// end ;
59366: LD_VAR 0 3
59370: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59371: LD_INT 0
59373: PPUSH
// if not mc_bases [ base ] then
59374: LD_EXP 116
59378: PUSH
59379: LD_VAR 0 1
59383: ARRAY
59384: NOT
59385: IFFALSE 59389
// exit ;
59387: GO 59426
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59389: LD_ADDR_EXP 121
59393: PUSH
59394: LD_EXP 121
59398: PPUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: LD_EXP 121
59408: PUSH
59409: LD_VAR 0 1
59413: ARRAY
59414: PUSH
59415: LD_VAR 0 2
59419: UNION
59420: PPUSH
59421: CALL_OW 1
59425: ST_TO_ADDR
// end ;
59426: LD_VAR 0 3
59430: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59431: LD_INT 0
59433: PPUSH
// if not mc_bases [ base ] then
59434: LD_EXP 116
59438: PUSH
59439: LD_VAR 0 1
59443: ARRAY
59444: NOT
59445: IFFALSE 59449
// exit ;
59447: GO 59474
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59449: LD_ADDR_EXP 137
59453: PUSH
59454: LD_EXP 137
59458: PPUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_VAR 0 2
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// end ;
59474: LD_VAR 0 3
59478: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59479: LD_INT 0
59481: PPUSH
// if not mc_bases [ base ] then
59482: LD_EXP 116
59486: PUSH
59487: LD_VAR 0 1
59491: ARRAY
59492: NOT
59493: IFFALSE 59497
// exit ;
59495: GO 59534
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59497: LD_ADDR_EXP 137
59501: PUSH
59502: LD_EXP 137
59506: PPUSH
59507: LD_VAR 0 1
59511: PPUSH
59512: LD_EXP 137
59516: PUSH
59517: LD_VAR 0 1
59521: ARRAY
59522: PUSH
59523: LD_VAR 0 2
59527: ADD
59528: PPUSH
59529: CALL_OW 1
59533: ST_TO_ADDR
// end ;
59534: LD_VAR 0 3
59538: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59539: LD_INT 0
59541: PPUSH
// if not mc_bases [ base ] then
59542: LD_EXP 116
59546: PUSH
59547: LD_VAR 0 1
59551: ARRAY
59552: NOT
59553: IFFALSE 59557
// exit ;
59555: GO 59611
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59557: LD_ADDR_EXP 138
59561: PUSH
59562: LD_EXP 138
59566: PPUSH
59567: LD_VAR 0 1
59571: PPUSH
59572: LD_VAR 0 2
59576: PPUSH
59577: CALL_OW 1
59581: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59582: LD_ADDR_EXP 127
59586: PUSH
59587: LD_EXP 127
59591: PPUSH
59592: LD_VAR 0 1
59596: PPUSH
59597: LD_VAR 0 2
59601: PUSH
59602: LD_INT 0
59604: PLUS
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// end ;
59611: LD_VAR 0 3
59615: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59616: LD_INT 0
59618: PPUSH
// if not mc_bases [ base ] then
59619: LD_EXP 116
59623: PUSH
59624: LD_VAR 0 1
59628: ARRAY
59629: NOT
59630: IFFALSE 59634
// exit ;
59632: GO 59659
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59634: LD_ADDR_EXP 127
59638: PUSH
59639: LD_EXP 127
59643: PPUSH
59644: LD_VAR 0 1
59648: PPUSH
59649: LD_VAR 0 2
59653: PPUSH
59654: CALL_OW 1
59658: ST_TO_ADDR
// end ;
59659: LD_VAR 0 3
59663: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59664: LD_INT 0
59666: PPUSH
59667: PPUSH
59668: PPUSH
59669: PPUSH
// if not mc_bases [ base ] then
59670: LD_EXP 116
59674: PUSH
59675: LD_VAR 0 1
59679: ARRAY
59680: NOT
59681: IFFALSE 59685
// exit ;
59683: GO 59750
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59685: LD_ADDR_EXP 136
59689: PUSH
59690: LD_EXP 136
59694: PPUSH
59695: LD_VAR 0 1
59699: PUSH
59700: LD_EXP 136
59704: PUSH
59705: LD_VAR 0 1
59709: ARRAY
59710: PUSH
59711: LD_INT 1
59713: PLUS
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PPUSH
59719: LD_VAR 0 1
59723: PUSH
59724: LD_VAR 0 2
59728: PUSH
59729: LD_VAR 0 3
59733: PUSH
59734: LD_VAR 0 4
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: LIST
59743: LIST
59744: PPUSH
59745: CALL 70871 0 3
59749: ST_TO_ADDR
// end ;
59750: LD_VAR 0 5
59754: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59755: LD_INT 0
59757: PPUSH
// if not mc_bases [ base ] then
59758: LD_EXP 116
59762: PUSH
59763: LD_VAR 0 1
59767: ARRAY
59768: NOT
59769: IFFALSE 59773
// exit ;
59771: GO 59798
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59773: LD_ADDR_EXP 153
59777: PUSH
59778: LD_EXP 153
59782: PPUSH
59783: LD_VAR 0 1
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: CALL_OW 1
59797: ST_TO_ADDR
// end ;
59798: LD_VAR 0 3
59802: RET
// export function MC_GetMinesField ( base ) ; begin
59803: LD_INT 0
59805: PPUSH
// result := mc_mines [ base ] ;
59806: LD_ADDR_VAR 0 2
59810: PUSH
59811: LD_EXP 129
59815: PUSH
59816: LD_VAR 0 1
59820: ARRAY
59821: ST_TO_ADDR
// end ;
59822: LD_VAR 0 2
59826: RET
// export function MC_GetProduceList ( base ) ; begin
59827: LD_INT 0
59829: PPUSH
// result := mc_produce [ base ] ;
59830: LD_ADDR_VAR 0 2
59834: PUSH
59835: LD_EXP 137
59839: PUSH
59840: LD_VAR 0 1
59844: ARRAY
59845: ST_TO_ADDR
// end ;
59846: LD_VAR 0 2
59850: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59851: LD_INT 0
59853: PPUSH
59854: PPUSH
// if not mc_bases then
59855: LD_EXP 116
59859: NOT
59860: IFFALSE 59864
// exit ;
59862: GO 59929
// if mc_bases [ base ] then
59864: LD_EXP 116
59868: PUSH
59869: LD_VAR 0 1
59873: ARRAY
59874: IFFALSE 59929
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59876: LD_ADDR_VAR 0 3
59880: PUSH
59881: LD_EXP 116
59885: PUSH
59886: LD_VAR 0 1
59890: ARRAY
59891: PPUSH
59892: LD_INT 30
59894: PUSH
59895: LD_VAR 0 2
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PPUSH
59904: CALL_OW 72
59908: ST_TO_ADDR
// if result then
59909: LD_VAR 0 3
59913: IFFALSE 59929
// result := result [ 1 ] ;
59915: LD_ADDR_VAR 0 3
59919: PUSH
59920: LD_VAR 0 3
59924: PUSH
59925: LD_INT 1
59927: ARRAY
59928: ST_TO_ADDR
// end ; end ;
59929: LD_VAR 0 3
59933: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59934: LD_INT 0
59936: PPUSH
59937: PPUSH
// if not mc_bases then
59938: LD_EXP 116
59942: NOT
59943: IFFALSE 59947
// exit ;
59945: GO 59992
// if mc_bases [ base ] then
59947: LD_EXP 116
59951: PUSH
59952: LD_VAR 0 1
59956: ARRAY
59957: IFFALSE 59992
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59959: LD_ADDR_VAR 0 3
59963: PUSH
59964: LD_EXP 116
59968: PUSH
59969: LD_VAR 0 1
59973: ARRAY
59974: PPUSH
59975: LD_INT 30
59977: PUSH
59978: LD_VAR 0 2
59982: PUSH
59983: EMPTY
59984: LIST
59985: LIST
59986: PPUSH
59987: CALL_OW 72
59991: ST_TO_ADDR
// end ;
59992: LD_VAR 0 3
59996: RET
// export function MC_SetTame ( base , area ) ; begin
59997: LD_INT 0
59999: PPUSH
// if not mc_bases or not base then
60000: LD_EXP 116
60004: NOT
60005: PUSH
60006: LD_VAR 0 1
60010: NOT
60011: OR
60012: IFFALSE 60016
// exit ;
60014: GO 60041
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60016: LD_ADDR_EXP 144
60020: PUSH
60021: LD_EXP 144
60025: PPUSH
60026: LD_VAR 0 1
60030: PPUSH
60031: LD_VAR 0 2
60035: PPUSH
60036: CALL_OW 1
60040: ST_TO_ADDR
// end ;
60041: LD_VAR 0 3
60045: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60046: LD_INT 0
60048: PPUSH
60049: PPUSH
// if not mc_bases or not base then
60050: LD_EXP 116
60054: NOT
60055: PUSH
60056: LD_VAR 0 1
60060: NOT
60061: OR
60062: IFFALSE 60066
// exit ;
60064: GO 60168
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60066: LD_ADDR_VAR 0 4
60070: PUSH
60071: LD_EXP 116
60075: PUSH
60076: LD_VAR 0 1
60080: ARRAY
60081: PPUSH
60082: LD_INT 30
60084: PUSH
60085: LD_VAR 0 2
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PPUSH
60094: CALL_OW 72
60098: ST_TO_ADDR
// if not tmp then
60099: LD_VAR 0 4
60103: NOT
60104: IFFALSE 60108
// exit ;
60106: GO 60168
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60108: LD_ADDR_EXP 148
60112: PUSH
60113: LD_EXP 148
60117: PPUSH
60118: LD_VAR 0 1
60122: PPUSH
60123: LD_EXP 148
60127: PUSH
60128: LD_VAR 0 1
60132: ARRAY
60133: PPUSH
60134: LD_EXP 148
60138: PUSH
60139: LD_VAR 0 1
60143: ARRAY
60144: PUSH
60145: LD_INT 1
60147: PLUS
60148: PPUSH
60149: LD_VAR 0 4
60153: PUSH
60154: LD_INT 1
60156: ARRAY
60157: PPUSH
60158: CALL_OW 2
60162: PPUSH
60163: CALL_OW 1
60167: ST_TO_ADDR
// end ;
60168: LD_VAR 0 3
60172: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60173: LD_INT 0
60175: PPUSH
60176: PPUSH
// if not mc_bases or not base or not kinds then
60177: LD_EXP 116
60181: NOT
60182: PUSH
60183: LD_VAR 0 1
60187: NOT
60188: OR
60189: PUSH
60190: LD_VAR 0 2
60194: NOT
60195: OR
60196: IFFALSE 60200
// exit ;
60198: GO 60261
// for i in kinds do
60200: LD_ADDR_VAR 0 4
60204: PUSH
60205: LD_VAR 0 2
60209: PUSH
60210: FOR_IN
60211: IFFALSE 60259
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60213: LD_ADDR_EXP 150
60217: PUSH
60218: LD_EXP 150
60222: PPUSH
60223: LD_VAR 0 1
60227: PUSH
60228: LD_EXP 150
60232: PUSH
60233: LD_VAR 0 1
60237: ARRAY
60238: PUSH
60239: LD_INT 1
60241: PLUS
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PPUSH
60247: LD_VAR 0 4
60251: PPUSH
60252: CALL 70871 0 3
60256: ST_TO_ADDR
60257: GO 60210
60259: POP
60260: POP
// end ;
60261: LD_VAR 0 3
60265: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60266: LD_INT 0
60268: PPUSH
// if not mc_bases or not base or not areas then
60269: LD_EXP 116
60273: NOT
60274: PUSH
60275: LD_VAR 0 1
60279: NOT
60280: OR
60281: PUSH
60282: LD_VAR 0 2
60286: NOT
60287: OR
60288: IFFALSE 60292
// exit ;
60290: GO 60317
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60292: LD_ADDR_EXP 134
60296: PUSH
60297: LD_EXP 134
60301: PPUSH
60302: LD_VAR 0 1
60306: PPUSH
60307: LD_VAR 0 2
60311: PPUSH
60312: CALL_OW 1
60316: ST_TO_ADDR
// end ;
60317: LD_VAR 0 3
60321: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60322: LD_INT 0
60324: PPUSH
// if not mc_bases or not base or not teleports_exit then
60325: LD_EXP 116
60329: NOT
60330: PUSH
60331: LD_VAR 0 1
60335: NOT
60336: OR
60337: PUSH
60338: LD_VAR 0 2
60342: NOT
60343: OR
60344: IFFALSE 60348
// exit ;
60346: GO 60373
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60348: LD_ADDR_EXP 151
60352: PUSH
60353: LD_EXP 151
60357: PPUSH
60358: LD_VAR 0 1
60362: PPUSH
60363: LD_VAR 0 2
60367: PPUSH
60368: CALL_OW 1
60372: ST_TO_ADDR
// end ;
60373: LD_VAR 0 3
60377: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60378: LD_INT 0
60380: PPUSH
60381: PPUSH
60382: PPUSH
// if not mc_bases or not base or not ext_list then
60383: LD_EXP 116
60387: NOT
60388: PUSH
60389: LD_VAR 0 1
60393: NOT
60394: OR
60395: PUSH
60396: LD_VAR 0 5
60400: NOT
60401: OR
60402: IFFALSE 60406
// exit ;
60404: GO 60579
// tmp := GetFacExtXYD ( x , y , d ) ;
60406: LD_ADDR_VAR 0 8
60410: PUSH
60411: LD_VAR 0 2
60415: PPUSH
60416: LD_VAR 0 3
60420: PPUSH
60421: LD_VAR 0 4
60425: PPUSH
60426: CALL 100258 0 3
60430: ST_TO_ADDR
// if not tmp then
60431: LD_VAR 0 8
60435: NOT
60436: IFFALSE 60440
// exit ;
60438: GO 60579
// for i in tmp do
60440: LD_ADDR_VAR 0 7
60444: PUSH
60445: LD_VAR 0 8
60449: PUSH
60450: FOR_IN
60451: IFFALSE 60577
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60453: LD_ADDR_EXP 121
60457: PUSH
60458: LD_EXP 121
60462: PPUSH
60463: LD_VAR 0 1
60467: PPUSH
60468: LD_EXP 121
60472: PUSH
60473: LD_VAR 0 1
60477: ARRAY
60478: PPUSH
60479: LD_EXP 121
60483: PUSH
60484: LD_VAR 0 1
60488: ARRAY
60489: PUSH
60490: LD_INT 1
60492: PLUS
60493: PPUSH
60494: LD_VAR 0 5
60498: PUSH
60499: LD_INT 1
60501: ARRAY
60502: PUSH
60503: LD_VAR 0 7
60507: PUSH
60508: LD_INT 1
60510: ARRAY
60511: PUSH
60512: LD_VAR 0 7
60516: PUSH
60517: LD_INT 2
60519: ARRAY
60520: PUSH
60521: LD_VAR 0 7
60525: PUSH
60526: LD_INT 3
60528: ARRAY
60529: PUSH
60530: EMPTY
60531: LIST
60532: LIST
60533: LIST
60534: LIST
60535: PPUSH
60536: CALL_OW 2
60540: PPUSH
60541: CALL_OW 1
60545: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60546: LD_ADDR_VAR 0 5
60550: PUSH
60551: LD_VAR 0 5
60555: PPUSH
60556: LD_INT 1
60558: PPUSH
60559: CALL_OW 3
60563: ST_TO_ADDR
// if not ext_list then
60564: LD_VAR 0 5
60568: NOT
60569: IFFALSE 60575
// exit ;
60571: POP
60572: POP
60573: GO 60579
// end ;
60575: GO 60450
60577: POP
60578: POP
// end ;
60579: LD_VAR 0 6
60583: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60584: LD_INT 0
60586: PPUSH
// if not mc_bases or not base or not weapon_list then
60587: LD_EXP 116
60591: NOT
60592: PUSH
60593: LD_VAR 0 1
60597: NOT
60598: OR
60599: PUSH
60600: LD_VAR 0 2
60604: NOT
60605: OR
60606: IFFALSE 60610
// exit ;
60608: GO 60635
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60610: LD_ADDR_EXP 155
60614: PUSH
60615: LD_EXP 155
60619: PPUSH
60620: LD_VAR 0 1
60624: PPUSH
60625: LD_VAR 0 2
60629: PPUSH
60630: CALL_OW 1
60634: ST_TO_ADDR
// end ;
60635: LD_VAR 0 3
60639: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60640: LD_INT 0
60642: PPUSH
// if not mc_bases or not base or not tech_list then
60643: LD_EXP 116
60647: NOT
60648: PUSH
60649: LD_VAR 0 1
60653: NOT
60654: OR
60655: PUSH
60656: LD_VAR 0 2
60660: NOT
60661: OR
60662: IFFALSE 60666
// exit ;
60664: GO 60691
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60666: LD_ADDR_EXP 143
60670: PUSH
60671: LD_EXP 143
60675: PPUSH
60676: LD_VAR 0 1
60680: PPUSH
60681: LD_VAR 0 2
60685: PPUSH
60686: CALL_OW 1
60690: ST_TO_ADDR
// end ;
60691: LD_VAR 0 3
60695: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60696: LD_INT 0
60698: PPUSH
// if not mc_bases or not parking_area or not base then
60699: LD_EXP 116
60703: NOT
60704: PUSH
60705: LD_VAR 0 2
60709: NOT
60710: OR
60711: PUSH
60712: LD_VAR 0 1
60716: NOT
60717: OR
60718: IFFALSE 60722
// exit ;
60720: GO 60747
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60722: LD_ADDR_EXP 140
60726: PUSH
60727: LD_EXP 140
60731: PPUSH
60732: LD_VAR 0 1
60736: PPUSH
60737: LD_VAR 0 2
60741: PPUSH
60742: CALL_OW 1
60746: ST_TO_ADDR
// end ;
60747: LD_VAR 0 3
60751: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60752: LD_INT 0
60754: PPUSH
// if not mc_bases or not base or not scan_area then
60755: LD_EXP 116
60759: NOT
60760: PUSH
60761: LD_VAR 0 1
60765: NOT
60766: OR
60767: PUSH
60768: LD_VAR 0 2
60772: NOT
60773: OR
60774: IFFALSE 60778
// exit ;
60776: GO 60803
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60778: LD_ADDR_EXP 141
60782: PUSH
60783: LD_EXP 141
60787: PPUSH
60788: LD_VAR 0 1
60792: PPUSH
60793: LD_VAR 0 2
60797: PPUSH
60798: CALL_OW 1
60802: ST_TO_ADDR
// end ;
60803: LD_VAR 0 3
60807: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60808: LD_INT 0
60810: PPUSH
60811: PPUSH
// if not mc_bases or not base then
60812: LD_EXP 116
60816: NOT
60817: PUSH
60818: LD_VAR 0 1
60822: NOT
60823: OR
60824: IFFALSE 60828
// exit ;
60826: GO 60892
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60828: LD_ADDR_VAR 0 3
60832: PUSH
60833: LD_INT 1
60835: PUSH
60836: LD_INT 2
60838: PUSH
60839: LD_INT 3
60841: PUSH
60842: LD_INT 4
60844: PUSH
60845: LD_INT 11
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: LIST
60852: LIST
60853: LIST
60854: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60855: LD_ADDR_EXP 143
60859: PUSH
60860: LD_EXP 143
60864: PPUSH
60865: LD_VAR 0 1
60869: PPUSH
60870: LD_EXP 143
60874: PUSH
60875: LD_VAR 0 1
60879: ARRAY
60880: PUSH
60881: LD_VAR 0 3
60885: DIFF
60886: PPUSH
60887: CALL_OW 1
60891: ST_TO_ADDR
// end ;
60892: LD_VAR 0 2
60896: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60897: LD_INT 0
60899: PPUSH
// result := mc_vehicles [ base ] ;
60900: LD_ADDR_VAR 0 3
60904: PUSH
60905: LD_EXP 135
60909: PUSH
60910: LD_VAR 0 1
60914: ARRAY
60915: ST_TO_ADDR
// if onlyCombat then
60916: LD_VAR 0 2
60920: IFFALSE 61098
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60922: LD_ADDR_VAR 0 3
60926: PUSH
60927: LD_VAR 0 3
60931: PUSH
60932: LD_VAR 0 3
60936: PPUSH
60937: LD_INT 2
60939: PUSH
60940: LD_INT 34
60942: PUSH
60943: LD_INT 12
60945: PUSH
60946: EMPTY
60947: LIST
60948: LIST
60949: PUSH
60950: LD_INT 34
60952: PUSH
60953: LD_INT 51
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PUSH
60960: LD_INT 34
60962: PUSH
60963: LD_EXP 96
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 34
60974: PUSH
60975: LD_INT 32
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: LD_INT 34
60984: PUSH
60985: LD_INT 13
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: PUSH
60992: LD_INT 34
60994: PUSH
60995: LD_INT 52
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: LD_INT 34
61004: PUSH
61005: LD_EXP 101
61009: PUSH
61010: EMPTY
61011: LIST
61012: LIST
61013: PUSH
61014: LD_INT 34
61016: PUSH
61017: LD_INT 14
61019: PUSH
61020: EMPTY
61021: LIST
61022: LIST
61023: PUSH
61024: LD_INT 34
61026: PUSH
61027: LD_INT 53
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PUSH
61034: LD_INT 34
61036: PUSH
61037: LD_EXP 95
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: LD_INT 34
61048: PUSH
61049: LD_INT 31
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: PUSH
61056: LD_INT 34
61058: PUSH
61059: LD_INT 48
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: PUSH
61066: LD_INT 34
61068: PUSH
61069: LD_INT 8
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: LIST
61080: LIST
61081: LIST
61082: LIST
61083: LIST
61084: LIST
61085: LIST
61086: LIST
61087: LIST
61088: LIST
61089: LIST
61090: LIST
61091: PPUSH
61092: CALL_OW 72
61096: DIFF
61097: ST_TO_ADDR
// end ; end_of_file
61098: LD_VAR 0 3
61102: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61103: LD_INT 0
61105: PPUSH
61106: PPUSH
61107: PPUSH
// if not mc_bases or not skirmish then
61108: LD_EXP 116
61112: NOT
61113: PUSH
61114: LD_EXP 114
61118: NOT
61119: OR
61120: IFFALSE 61124
// exit ;
61122: GO 61289
// for i = 1 to mc_bases do
61124: LD_ADDR_VAR 0 4
61128: PUSH
61129: DOUBLE
61130: LD_INT 1
61132: DEC
61133: ST_TO_ADDR
61134: LD_EXP 116
61138: PUSH
61139: FOR_TO
61140: IFFALSE 61287
// begin if sci in mc_bases [ i ] then
61142: LD_VAR 0 2
61146: PUSH
61147: LD_EXP 116
61151: PUSH
61152: LD_VAR 0 4
61156: ARRAY
61157: IN
61158: IFFALSE 61285
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61160: LD_ADDR_EXP 145
61164: PUSH
61165: LD_EXP 145
61169: PPUSH
61170: LD_VAR 0 4
61174: PUSH
61175: LD_EXP 145
61179: PUSH
61180: LD_VAR 0 4
61184: ARRAY
61185: PUSH
61186: LD_INT 1
61188: PLUS
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PPUSH
61194: LD_VAR 0 1
61198: PPUSH
61199: CALL 70871 0 3
61203: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61204: LD_ADDR_VAR 0 5
61208: PUSH
61209: LD_EXP 116
61213: PUSH
61214: LD_VAR 0 4
61218: ARRAY
61219: PPUSH
61220: LD_INT 2
61222: PUSH
61223: LD_INT 30
61225: PUSH
61226: LD_INT 0
61228: PUSH
61229: EMPTY
61230: LIST
61231: LIST
61232: PUSH
61233: LD_INT 30
61235: PUSH
61236: LD_INT 1
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: LIST
61247: PPUSH
61248: CALL_OW 72
61252: PPUSH
61253: LD_VAR 0 1
61257: PPUSH
61258: CALL_OW 74
61262: ST_TO_ADDR
// if tmp then
61263: LD_VAR 0 5
61267: IFFALSE 61283
// ComStandNearbyBuilding ( ape , tmp ) ;
61269: LD_VAR 0 1
61273: PPUSH
61274: LD_VAR 0 5
61278: PPUSH
61279: CALL 67449 0 2
// break ;
61283: GO 61287
// end ; end ;
61285: GO 61139
61287: POP
61288: POP
// end ;
61289: LD_VAR 0 3
61293: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61294: LD_INT 0
61296: PPUSH
61297: PPUSH
61298: PPUSH
// if not mc_bases or not skirmish then
61299: LD_EXP 116
61303: NOT
61304: PUSH
61305: LD_EXP 114
61309: NOT
61310: OR
61311: IFFALSE 61315
// exit ;
61313: GO 61404
// for i = 1 to mc_bases do
61315: LD_ADDR_VAR 0 4
61319: PUSH
61320: DOUBLE
61321: LD_INT 1
61323: DEC
61324: ST_TO_ADDR
61325: LD_EXP 116
61329: PUSH
61330: FOR_TO
61331: IFFALSE 61402
// begin if building in mc_busy_turret_list [ i ] then
61333: LD_VAR 0 1
61337: PUSH
61338: LD_EXP 126
61342: PUSH
61343: LD_VAR 0 4
61347: ARRAY
61348: IN
61349: IFFALSE 61400
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61351: LD_ADDR_VAR 0 5
61355: PUSH
61356: LD_EXP 126
61360: PUSH
61361: LD_VAR 0 4
61365: ARRAY
61366: PUSH
61367: LD_VAR 0 1
61371: DIFF
61372: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61373: LD_ADDR_EXP 126
61377: PUSH
61378: LD_EXP 126
61382: PPUSH
61383: LD_VAR 0 4
61387: PPUSH
61388: LD_VAR 0 5
61392: PPUSH
61393: CALL_OW 1
61397: ST_TO_ADDR
// break ;
61398: GO 61402
// end ; end ;
61400: GO 61330
61402: POP
61403: POP
// end ;
61404: LD_VAR 0 3
61408: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61409: LD_INT 0
61411: PPUSH
61412: PPUSH
61413: PPUSH
// if not mc_bases or not skirmish then
61414: LD_EXP 116
61418: NOT
61419: PUSH
61420: LD_EXP 114
61424: NOT
61425: OR
61426: IFFALSE 61430
// exit ;
61428: GO 61629
// for i = 1 to mc_bases do
61430: LD_ADDR_VAR 0 5
61434: PUSH
61435: DOUBLE
61436: LD_INT 1
61438: DEC
61439: ST_TO_ADDR
61440: LD_EXP 116
61444: PUSH
61445: FOR_TO
61446: IFFALSE 61627
// if building in mc_bases [ i ] then
61448: LD_VAR 0 1
61452: PUSH
61453: LD_EXP 116
61457: PUSH
61458: LD_VAR 0 5
61462: ARRAY
61463: IN
61464: IFFALSE 61625
// begin tmp := mc_bases [ i ] diff building ;
61466: LD_ADDR_VAR 0 6
61470: PUSH
61471: LD_EXP 116
61475: PUSH
61476: LD_VAR 0 5
61480: ARRAY
61481: PUSH
61482: LD_VAR 0 1
61486: DIFF
61487: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61488: LD_ADDR_EXP 116
61492: PUSH
61493: LD_EXP 116
61497: PPUSH
61498: LD_VAR 0 5
61502: PPUSH
61503: LD_VAR 0 6
61507: PPUSH
61508: CALL_OW 1
61512: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61513: LD_VAR 0 1
61517: PUSH
61518: LD_EXP 124
61522: PUSH
61523: LD_VAR 0 5
61527: ARRAY
61528: IN
61529: IFFALSE 61568
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61531: LD_ADDR_EXP 124
61535: PUSH
61536: LD_EXP 124
61540: PPUSH
61541: LD_VAR 0 5
61545: PPUSH
61546: LD_EXP 124
61550: PUSH
61551: LD_VAR 0 5
61555: ARRAY
61556: PUSH
61557: LD_VAR 0 1
61561: DIFF
61562: PPUSH
61563: CALL_OW 1
61567: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61568: LD_VAR 0 1
61572: PUSH
61573: LD_EXP 125
61577: PUSH
61578: LD_VAR 0 5
61582: ARRAY
61583: IN
61584: IFFALSE 61623
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61586: LD_ADDR_EXP 125
61590: PUSH
61591: LD_EXP 125
61595: PPUSH
61596: LD_VAR 0 5
61600: PPUSH
61601: LD_EXP 125
61605: PUSH
61606: LD_VAR 0 5
61610: ARRAY
61611: PUSH
61612: LD_VAR 0 1
61616: DIFF
61617: PPUSH
61618: CALL_OW 1
61622: ST_TO_ADDR
// break ;
61623: GO 61627
// end ;
61625: GO 61445
61627: POP
61628: POP
// end ;
61629: LD_VAR 0 4
61633: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61634: LD_INT 0
61636: PPUSH
61637: PPUSH
61638: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61639: LD_EXP 116
61643: NOT
61644: PUSH
61645: LD_EXP 114
61649: NOT
61650: OR
61651: PUSH
61652: LD_VAR 0 3
61656: PUSH
61657: LD_EXP 142
61661: IN
61662: NOT
61663: OR
61664: IFFALSE 61668
// exit ;
61666: GO 61791
// for i = 1 to mc_vehicles do
61668: LD_ADDR_VAR 0 6
61672: PUSH
61673: DOUBLE
61674: LD_INT 1
61676: DEC
61677: ST_TO_ADDR
61678: LD_EXP 135
61682: PUSH
61683: FOR_TO
61684: IFFALSE 61789
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61686: LD_VAR 0 2
61690: PUSH
61691: LD_EXP 135
61695: PUSH
61696: LD_VAR 0 6
61700: ARRAY
61701: IN
61702: PUSH
61703: LD_VAR 0 1
61707: PUSH
61708: LD_EXP 135
61712: PUSH
61713: LD_VAR 0 6
61717: ARRAY
61718: IN
61719: OR
61720: IFFALSE 61787
// begin tmp := mc_vehicles [ i ] diff old ;
61722: LD_ADDR_VAR 0 7
61726: PUSH
61727: LD_EXP 135
61731: PUSH
61732: LD_VAR 0 6
61736: ARRAY
61737: PUSH
61738: LD_VAR 0 2
61742: DIFF
61743: ST_TO_ADDR
// tmp := tmp diff new ;
61744: LD_ADDR_VAR 0 7
61748: PUSH
61749: LD_VAR 0 7
61753: PUSH
61754: LD_VAR 0 1
61758: DIFF
61759: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61760: LD_ADDR_EXP 135
61764: PUSH
61765: LD_EXP 135
61769: PPUSH
61770: LD_VAR 0 6
61774: PPUSH
61775: LD_VAR 0 7
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// break ;
61785: GO 61789
// end ;
61787: GO 61683
61789: POP
61790: POP
// end ;
61791: LD_VAR 0 5
61795: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61796: LD_INT 0
61798: PPUSH
61799: PPUSH
61800: PPUSH
61801: PPUSH
// if not mc_bases or not skirmish then
61802: LD_EXP 116
61806: NOT
61807: PUSH
61808: LD_EXP 114
61812: NOT
61813: OR
61814: IFFALSE 61818
// exit ;
61816: GO 62210
// side := GetSide ( vehicle ) ;
61818: LD_ADDR_VAR 0 5
61822: PUSH
61823: LD_VAR 0 1
61827: PPUSH
61828: CALL_OW 255
61832: ST_TO_ADDR
// for i = 1 to mc_bases do
61833: LD_ADDR_VAR 0 4
61837: PUSH
61838: DOUBLE
61839: LD_INT 1
61841: DEC
61842: ST_TO_ADDR
61843: LD_EXP 116
61847: PUSH
61848: FOR_TO
61849: IFFALSE 62208
// begin if factory in mc_bases [ i ] then
61851: LD_VAR 0 2
61855: PUSH
61856: LD_EXP 116
61860: PUSH
61861: LD_VAR 0 4
61865: ARRAY
61866: IN
61867: IFFALSE 62206
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61869: LD_EXP 138
61873: PUSH
61874: LD_VAR 0 4
61878: ARRAY
61879: PUSH
61880: LD_EXP 127
61884: PUSH
61885: LD_VAR 0 4
61889: ARRAY
61890: LESS
61891: PUSH
61892: LD_VAR 0 1
61896: PPUSH
61897: CALL_OW 264
61901: PUSH
61902: LD_INT 31
61904: PUSH
61905: LD_INT 32
61907: PUSH
61908: LD_INT 51
61910: PUSH
61911: LD_EXP 96
61915: PUSH
61916: LD_INT 12
61918: PUSH
61919: LD_INT 30
61921: PUSH
61922: LD_EXP 95
61926: PUSH
61927: LD_INT 11
61929: PUSH
61930: LD_INT 53
61932: PUSH
61933: LD_INT 14
61935: PUSH
61936: LD_EXP 99
61940: PUSH
61941: LD_INT 29
61943: PUSH
61944: LD_EXP 97
61948: PUSH
61949: LD_INT 13
61951: PUSH
61952: LD_INT 52
61954: PUSH
61955: LD_EXP 101
61959: PUSH
61960: LD_INT 48
61962: PUSH
61963: LD_INT 8
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: IN
61986: NOT
61987: AND
61988: IFFALSE 62036
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61990: LD_ADDR_EXP 138
61994: PUSH
61995: LD_EXP 138
61999: PPUSH
62000: LD_VAR 0 4
62004: PUSH
62005: LD_EXP 138
62009: PUSH
62010: LD_VAR 0 4
62014: ARRAY
62015: PUSH
62016: LD_INT 1
62018: PLUS
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PPUSH
62024: LD_VAR 0 1
62028: PPUSH
62029: CALL 70871 0 3
62033: ST_TO_ADDR
62034: GO 62080
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62036: LD_ADDR_EXP 135
62040: PUSH
62041: LD_EXP 135
62045: PPUSH
62046: LD_VAR 0 4
62050: PUSH
62051: LD_EXP 135
62055: PUSH
62056: LD_VAR 0 4
62060: ARRAY
62061: PUSH
62062: LD_INT 1
62064: PLUS
62065: PUSH
62066: EMPTY
62067: LIST
62068: LIST
62069: PPUSH
62070: LD_VAR 0 1
62074: PPUSH
62075: CALL 70871 0 3
62079: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62080: LD_VAR 0 1
62084: PPUSH
62085: CALL_OW 263
62089: PUSH
62090: LD_INT 2
62092: EQUAL
62093: IFFALSE 62122
// begin repeat wait ( 0 0$3 ) ;
62095: LD_INT 105
62097: PPUSH
62098: CALL_OW 67
// Connect ( vehicle ) ;
62102: LD_VAR 0 1
62106: PPUSH
62107: CALL 73842 0 1
// until IsControledBy ( vehicle ) ;
62111: LD_VAR 0 1
62115: PPUSH
62116: CALL_OW 312
62120: IFFALSE 62095
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62122: LD_VAR 0 1
62126: PPUSH
62127: LD_EXP 140
62131: PUSH
62132: LD_VAR 0 4
62136: ARRAY
62137: PPUSH
62138: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 263
62151: PUSH
62152: LD_INT 1
62154: NONEQUAL
62155: IFFALSE 62159
// break ;
62157: GO 62208
// repeat wait ( 0 0$1 ) ;
62159: LD_INT 35
62161: PPUSH
62162: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62166: LD_VAR 0 1
62170: PPUSH
62171: LD_EXP 140
62175: PUSH
62176: LD_VAR 0 4
62180: ARRAY
62181: PPUSH
62182: CALL_OW 308
62186: IFFALSE 62159
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62188: LD_VAR 0 1
62192: PPUSH
62193: CALL_OW 311
62197: PPUSH
62198: CALL_OW 121
// exit ;
62202: POP
62203: POP
62204: GO 62210
// end ; end ;
62206: GO 61848
62208: POP
62209: POP
// end ;
62210: LD_VAR 0 3
62214: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62215: LD_INT 0
62217: PPUSH
62218: PPUSH
62219: PPUSH
62220: PPUSH
// if not mc_bases or not skirmish then
62221: LD_EXP 116
62225: NOT
62226: PUSH
62227: LD_EXP 114
62231: NOT
62232: OR
62233: IFFALSE 62237
// exit ;
62235: GO 62590
// repeat wait ( 0 0$1 ) ;
62237: LD_INT 35
62239: PPUSH
62240: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62244: LD_VAR 0 2
62248: PPUSH
62249: LD_VAR 0 3
62253: PPUSH
62254: CALL_OW 284
62258: IFFALSE 62237
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62260: LD_VAR 0 2
62264: PPUSH
62265: LD_VAR 0 3
62269: PPUSH
62270: CALL_OW 283
62274: PUSH
62275: LD_INT 4
62277: EQUAL
62278: IFFALSE 62282
// exit ;
62280: GO 62590
// for i = 1 to mc_bases do
62282: LD_ADDR_VAR 0 7
62286: PUSH
62287: DOUBLE
62288: LD_INT 1
62290: DEC
62291: ST_TO_ADDR
62292: LD_EXP 116
62296: PUSH
62297: FOR_TO
62298: IFFALSE 62588
// begin if mc_crates_area [ i ] then
62300: LD_EXP 134
62304: PUSH
62305: LD_VAR 0 7
62309: ARRAY
62310: IFFALSE 62421
// for j in mc_crates_area [ i ] do
62312: LD_ADDR_VAR 0 8
62316: PUSH
62317: LD_EXP 134
62321: PUSH
62322: LD_VAR 0 7
62326: ARRAY
62327: PUSH
62328: FOR_IN
62329: IFFALSE 62419
// if InArea ( x , y , j ) then
62331: LD_VAR 0 2
62335: PPUSH
62336: LD_VAR 0 3
62340: PPUSH
62341: LD_VAR 0 8
62345: PPUSH
62346: CALL_OW 309
62350: IFFALSE 62417
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62352: LD_ADDR_EXP 132
62356: PUSH
62357: LD_EXP 132
62361: PPUSH
62362: LD_VAR 0 7
62366: PUSH
62367: LD_EXP 132
62371: PUSH
62372: LD_VAR 0 7
62376: ARRAY
62377: PUSH
62378: LD_INT 1
62380: PLUS
62381: PUSH
62382: EMPTY
62383: LIST
62384: LIST
62385: PPUSH
62386: LD_VAR 0 4
62390: PUSH
62391: LD_VAR 0 2
62395: PUSH
62396: LD_VAR 0 3
62400: PUSH
62401: EMPTY
62402: LIST
62403: LIST
62404: LIST
62405: PPUSH
62406: CALL 70871 0 3
62410: ST_TO_ADDR
// exit ;
62411: POP
62412: POP
62413: POP
62414: POP
62415: GO 62590
// end ;
62417: GO 62328
62419: POP
62420: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62421: LD_ADDR_VAR 0 9
62425: PUSH
62426: LD_EXP 116
62430: PUSH
62431: LD_VAR 0 7
62435: ARRAY
62436: PPUSH
62437: LD_INT 2
62439: PUSH
62440: LD_INT 30
62442: PUSH
62443: LD_INT 0
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: LD_INT 30
62452: PUSH
62453: LD_INT 1
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: LIST
62464: PPUSH
62465: CALL_OW 72
62469: ST_TO_ADDR
// if not depot then
62470: LD_VAR 0 9
62474: NOT
62475: IFFALSE 62479
// continue ;
62477: GO 62297
// for j in depot do
62479: LD_ADDR_VAR 0 8
62483: PUSH
62484: LD_VAR 0 9
62488: PUSH
62489: FOR_IN
62490: IFFALSE 62584
// if GetDistUnitXY ( j , x , y ) < 30 then
62492: LD_VAR 0 8
62496: PPUSH
62497: LD_VAR 0 2
62501: PPUSH
62502: LD_VAR 0 3
62506: PPUSH
62507: CALL_OW 297
62511: PUSH
62512: LD_INT 30
62514: LESS
62515: IFFALSE 62582
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62517: LD_ADDR_EXP 132
62521: PUSH
62522: LD_EXP 132
62526: PPUSH
62527: LD_VAR 0 7
62531: PUSH
62532: LD_EXP 132
62536: PUSH
62537: LD_VAR 0 7
62541: ARRAY
62542: PUSH
62543: LD_INT 1
62545: PLUS
62546: PUSH
62547: EMPTY
62548: LIST
62549: LIST
62550: PPUSH
62551: LD_VAR 0 4
62555: PUSH
62556: LD_VAR 0 2
62560: PUSH
62561: LD_VAR 0 3
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: LIST
62570: PPUSH
62571: CALL 70871 0 3
62575: ST_TO_ADDR
// exit ;
62576: POP
62577: POP
62578: POP
62579: POP
62580: GO 62590
// end ;
62582: GO 62489
62584: POP
62585: POP
// end ;
62586: GO 62297
62588: POP
62589: POP
// end ;
62590: LD_VAR 0 6
62594: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62595: LD_INT 0
62597: PPUSH
62598: PPUSH
62599: PPUSH
62600: PPUSH
// if not mc_bases or not skirmish then
62601: LD_EXP 116
62605: NOT
62606: PUSH
62607: LD_EXP 114
62611: NOT
62612: OR
62613: IFFALSE 62617
// exit ;
62615: GO 62894
// side := GetSide ( lab ) ;
62617: LD_ADDR_VAR 0 4
62621: PUSH
62622: LD_VAR 0 2
62626: PPUSH
62627: CALL_OW 255
62631: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62632: LD_VAR 0 4
62636: PUSH
62637: LD_EXP 142
62641: IN
62642: NOT
62643: PUSH
62644: LD_EXP 143
62648: NOT
62649: OR
62650: PUSH
62651: LD_EXP 116
62655: NOT
62656: OR
62657: IFFALSE 62661
// exit ;
62659: GO 62894
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62661: LD_ADDR_EXP 143
62665: PUSH
62666: LD_EXP 143
62670: PPUSH
62671: LD_VAR 0 4
62675: PPUSH
62676: LD_EXP 143
62680: PUSH
62681: LD_VAR 0 4
62685: ARRAY
62686: PUSH
62687: LD_VAR 0 1
62691: DIFF
62692: PPUSH
62693: CALL_OW 1
62697: ST_TO_ADDR
// for i = 1 to mc_bases do
62698: LD_ADDR_VAR 0 5
62702: PUSH
62703: DOUBLE
62704: LD_INT 1
62706: DEC
62707: ST_TO_ADDR
62708: LD_EXP 116
62712: PUSH
62713: FOR_TO
62714: IFFALSE 62892
// begin if lab in mc_bases [ i ] then
62716: LD_VAR 0 2
62720: PUSH
62721: LD_EXP 116
62725: PUSH
62726: LD_VAR 0 5
62730: ARRAY
62731: IN
62732: IFFALSE 62890
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62734: LD_VAR 0 1
62738: PUSH
62739: LD_INT 11
62741: PUSH
62742: LD_INT 4
62744: PUSH
62745: LD_INT 3
62747: PUSH
62748: LD_INT 2
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: LIST
62755: LIST
62756: IN
62757: PUSH
62758: LD_EXP 146
62762: PUSH
62763: LD_VAR 0 5
62767: ARRAY
62768: AND
62769: IFFALSE 62890
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62771: LD_ADDR_VAR 0 6
62775: PUSH
62776: LD_EXP 146
62780: PUSH
62781: LD_VAR 0 5
62785: ARRAY
62786: PUSH
62787: LD_INT 1
62789: ARRAY
62790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62791: LD_ADDR_EXP 146
62795: PUSH
62796: LD_EXP 146
62800: PPUSH
62801: LD_VAR 0 5
62805: PPUSH
62806: EMPTY
62807: PPUSH
62808: CALL_OW 1
62812: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62813: LD_VAR 0 6
62817: PPUSH
62818: LD_INT 0
62820: PPUSH
62821: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62825: LD_VAR 0 6
62829: PPUSH
62830: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62834: LD_ADDR_EXP 145
62838: PUSH
62839: LD_EXP 145
62843: PPUSH
62844: LD_VAR 0 5
62848: PPUSH
62849: LD_EXP 145
62853: PUSH
62854: LD_VAR 0 5
62858: ARRAY
62859: PPUSH
62860: LD_INT 1
62862: PPUSH
62863: LD_VAR 0 6
62867: PPUSH
62868: CALL_OW 2
62872: PPUSH
62873: CALL_OW 1
62877: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62878: LD_VAR 0 5
62882: PPUSH
62883: LD_INT 112
62885: PPUSH
62886: CALL 39413 0 2
// end ; end ; end ;
62890: GO 62713
62892: POP
62893: POP
// end ;
62894: LD_VAR 0 3
62898: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62899: LD_INT 0
62901: PPUSH
62902: PPUSH
62903: PPUSH
62904: PPUSH
62905: PPUSH
62906: PPUSH
62907: PPUSH
62908: PPUSH
// if not mc_bases or not skirmish then
62909: LD_EXP 116
62913: NOT
62914: PUSH
62915: LD_EXP 114
62919: NOT
62920: OR
62921: IFFALSE 62925
// exit ;
62923: GO 64296
// for i = 1 to mc_bases do
62925: LD_ADDR_VAR 0 3
62929: PUSH
62930: DOUBLE
62931: LD_INT 1
62933: DEC
62934: ST_TO_ADDR
62935: LD_EXP 116
62939: PUSH
62940: FOR_TO
62941: IFFALSE 64294
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62943: LD_VAR 0 1
62947: PUSH
62948: LD_EXP 116
62952: PUSH
62953: LD_VAR 0 3
62957: ARRAY
62958: IN
62959: PUSH
62960: LD_VAR 0 1
62964: PUSH
62965: LD_EXP 123
62969: PUSH
62970: LD_VAR 0 3
62974: ARRAY
62975: IN
62976: OR
62977: PUSH
62978: LD_VAR 0 1
62982: PUSH
62983: LD_EXP 138
62987: PUSH
62988: LD_VAR 0 3
62992: ARRAY
62993: IN
62994: OR
62995: PUSH
62996: LD_VAR 0 1
63000: PUSH
63001: LD_EXP 135
63005: PUSH
63006: LD_VAR 0 3
63010: ARRAY
63011: IN
63012: OR
63013: PUSH
63014: LD_VAR 0 1
63018: PUSH
63019: LD_EXP 145
63023: PUSH
63024: LD_VAR 0 3
63028: ARRAY
63029: IN
63030: OR
63031: PUSH
63032: LD_VAR 0 1
63036: PUSH
63037: LD_EXP 146
63041: PUSH
63042: LD_VAR 0 3
63046: ARRAY
63047: IN
63048: OR
63049: IFFALSE 64292
// begin if un in mc_ape [ i ] then
63051: LD_VAR 0 1
63055: PUSH
63056: LD_EXP 145
63060: PUSH
63061: LD_VAR 0 3
63065: ARRAY
63066: IN
63067: IFFALSE 63106
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63069: LD_ADDR_EXP 145
63073: PUSH
63074: LD_EXP 145
63078: PPUSH
63079: LD_VAR 0 3
63083: PPUSH
63084: LD_EXP 145
63088: PUSH
63089: LD_VAR 0 3
63093: ARRAY
63094: PUSH
63095: LD_VAR 0 1
63099: DIFF
63100: PPUSH
63101: CALL_OW 1
63105: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63106: LD_VAR 0 1
63110: PUSH
63111: LD_EXP 146
63115: PUSH
63116: LD_VAR 0 3
63120: ARRAY
63121: IN
63122: IFFALSE 63146
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63124: LD_ADDR_EXP 146
63128: PUSH
63129: LD_EXP 146
63133: PPUSH
63134: LD_VAR 0 3
63138: PPUSH
63139: EMPTY
63140: PPUSH
63141: CALL_OW 1
63145: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63146: LD_VAR 0 1
63150: PPUSH
63151: CALL_OW 247
63155: PUSH
63156: LD_INT 2
63158: EQUAL
63159: PUSH
63160: LD_VAR 0 1
63164: PPUSH
63165: CALL_OW 110
63169: PUSH
63170: LD_INT 20
63172: EQUAL
63173: PUSH
63174: LD_VAR 0 1
63178: PUSH
63179: LD_EXP 138
63183: PUSH
63184: LD_VAR 0 3
63188: ARRAY
63189: IN
63190: OR
63191: PUSH
63192: LD_VAR 0 1
63196: PPUSH
63197: CALL_OW 264
63201: PUSH
63202: LD_INT 12
63204: PUSH
63205: LD_INT 51
63207: PUSH
63208: LD_EXP 96
63212: PUSH
63213: LD_INT 32
63215: PUSH
63216: LD_INT 13
63218: PUSH
63219: LD_INT 52
63221: PUSH
63222: LD_INT 31
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: IN
63234: OR
63235: AND
63236: IFFALSE 63544
// begin if un in mc_defender [ i ] then
63238: LD_VAR 0 1
63242: PUSH
63243: LD_EXP 138
63247: PUSH
63248: LD_VAR 0 3
63252: ARRAY
63253: IN
63254: IFFALSE 63293
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63256: LD_ADDR_EXP 138
63260: PUSH
63261: LD_EXP 138
63265: PPUSH
63266: LD_VAR 0 3
63270: PPUSH
63271: LD_EXP 138
63275: PUSH
63276: LD_VAR 0 3
63280: ARRAY
63281: PUSH
63282: LD_VAR 0 1
63286: DIFF
63287: PPUSH
63288: CALL_OW 1
63292: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63293: LD_ADDR_VAR 0 8
63297: PUSH
63298: LD_VAR 0 3
63302: PPUSH
63303: LD_INT 3
63305: PPUSH
63306: CALL 59934 0 2
63310: ST_TO_ADDR
// if fac then
63311: LD_VAR 0 8
63315: IFFALSE 63544
// begin for j in fac do
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: LD_VAR 0 8
63326: PUSH
63327: FOR_IN
63328: IFFALSE 63542
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63330: LD_ADDR_VAR 0 9
63334: PUSH
63335: LD_VAR 0 8
63339: PPUSH
63340: LD_VAR 0 1
63344: PPUSH
63345: CALL_OW 265
63349: PPUSH
63350: LD_VAR 0 1
63354: PPUSH
63355: CALL_OW 262
63359: PPUSH
63360: LD_VAR 0 1
63364: PPUSH
63365: CALL_OW 263
63369: PPUSH
63370: LD_VAR 0 1
63374: PPUSH
63375: CALL_OW 264
63379: PPUSH
63380: CALL 68367 0 5
63384: ST_TO_ADDR
// if components then
63385: LD_VAR 0 9
63389: IFFALSE 63540
// begin if GetWeapon ( un ) = ar_control_tower then
63391: LD_VAR 0 1
63395: PPUSH
63396: CALL_OW 264
63400: PUSH
63401: LD_INT 31
63403: EQUAL
63404: IFFALSE 63521
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63406: LD_VAR 0 1
63410: PPUSH
63411: CALL_OW 311
63415: PPUSH
63416: LD_INT 0
63418: PPUSH
63419: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63423: LD_ADDR_EXP 156
63427: PUSH
63428: LD_EXP 156
63432: PPUSH
63433: LD_VAR 0 3
63437: PPUSH
63438: LD_EXP 156
63442: PUSH
63443: LD_VAR 0 3
63447: ARRAY
63448: PUSH
63449: LD_VAR 0 1
63453: PPUSH
63454: CALL_OW 311
63458: DIFF
63459: PPUSH
63460: CALL_OW 1
63464: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63465: LD_ADDR_VAR 0 7
63469: PUSH
63470: LD_EXP 137
63474: PUSH
63475: LD_VAR 0 3
63479: ARRAY
63480: PPUSH
63481: LD_INT 1
63483: PPUSH
63484: LD_VAR 0 9
63488: PPUSH
63489: CALL_OW 2
63493: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63494: LD_ADDR_EXP 137
63498: PUSH
63499: LD_EXP 137
63503: PPUSH
63504: LD_VAR 0 3
63508: PPUSH
63509: LD_VAR 0 7
63513: PPUSH
63514: CALL_OW 1
63518: ST_TO_ADDR
// end else
63519: GO 63538
// MC_InsertProduceList ( i , [ components ] ) ;
63521: LD_VAR 0 3
63525: PPUSH
63526: LD_VAR 0 9
63530: PUSH
63531: EMPTY
63532: LIST
63533: PPUSH
63534: CALL 59479 0 2
// break ;
63538: GO 63542
// end ; end ;
63540: GO 63327
63542: POP
63543: POP
// end ; end ; if GetType ( un ) = unit_building then
63544: LD_VAR 0 1
63548: PPUSH
63549: CALL_OW 247
63553: PUSH
63554: LD_INT 3
63556: EQUAL
63557: IFFALSE 63960
// begin btype := GetBType ( un ) ;
63559: LD_ADDR_VAR 0 5
63563: PUSH
63564: LD_VAR 0 1
63568: PPUSH
63569: CALL_OW 266
63573: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63574: LD_VAR 0 5
63578: PUSH
63579: LD_INT 29
63581: PUSH
63582: LD_INT 30
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: IN
63589: IFFALSE 63662
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63591: LD_VAR 0 1
63595: PPUSH
63596: CALL_OW 250
63600: PPUSH
63601: LD_VAR 0 1
63605: PPUSH
63606: CALL_OW 251
63610: PPUSH
63611: LD_VAR 0 1
63615: PPUSH
63616: CALL_OW 255
63620: PPUSH
63621: CALL_OW 440
63625: NOT
63626: IFFALSE 63662
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63628: LD_VAR 0 1
63632: PPUSH
63633: CALL_OW 250
63637: PPUSH
63638: LD_VAR 0 1
63642: PPUSH
63643: CALL_OW 251
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL_OW 255
63657: PPUSH
63658: CALL_OW 441
// end ; if btype = b_warehouse then
63662: LD_VAR 0 5
63666: PUSH
63667: LD_INT 1
63669: EQUAL
63670: IFFALSE 63688
// begin btype := b_depot ;
63672: LD_ADDR_VAR 0 5
63676: PUSH
63677: LD_INT 0
63679: ST_TO_ADDR
// pos := 1 ;
63680: LD_ADDR_VAR 0 6
63684: PUSH
63685: LD_INT 1
63687: ST_TO_ADDR
// end ; if btype = b_factory then
63688: LD_VAR 0 5
63692: PUSH
63693: LD_INT 3
63695: EQUAL
63696: IFFALSE 63714
// begin btype := b_workshop ;
63698: LD_ADDR_VAR 0 5
63702: PUSH
63703: LD_INT 2
63705: ST_TO_ADDR
// pos := 1 ;
63706: LD_ADDR_VAR 0 6
63710: PUSH
63711: LD_INT 1
63713: ST_TO_ADDR
// end ; if btype = b_barracks then
63714: LD_VAR 0 5
63718: PUSH
63719: LD_INT 5
63721: EQUAL
63722: IFFALSE 63732
// btype := b_armoury ;
63724: LD_ADDR_VAR 0 5
63728: PUSH
63729: LD_INT 4
63731: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63732: LD_VAR 0 5
63736: PUSH
63737: LD_INT 7
63739: PUSH
63740: LD_INT 8
63742: PUSH
63743: EMPTY
63744: LIST
63745: LIST
63746: IN
63747: IFFALSE 63757
// btype := b_lab ;
63749: LD_ADDR_VAR 0 5
63753: PUSH
63754: LD_INT 6
63756: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63757: LD_ADDR_EXP 121
63761: PUSH
63762: LD_EXP 121
63766: PPUSH
63767: LD_VAR 0 3
63771: PUSH
63772: LD_EXP 121
63776: PUSH
63777: LD_VAR 0 3
63781: ARRAY
63782: PUSH
63783: LD_INT 1
63785: PLUS
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PPUSH
63791: LD_VAR 0 5
63795: PUSH
63796: LD_VAR 0 1
63800: PPUSH
63801: CALL_OW 250
63805: PUSH
63806: LD_VAR 0 1
63810: PPUSH
63811: CALL_OW 251
63815: PUSH
63816: LD_VAR 0 1
63820: PPUSH
63821: CALL_OW 254
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: PPUSH
63832: CALL 70871 0 3
63836: ST_TO_ADDR
// if pos = 1 then
63837: LD_VAR 0 6
63841: PUSH
63842: LD_INT 1
63844: EQUAL
63845: IFFALSE 63960
// begin tmp := mc_build_list [ i ] ;
63847: LD_ADDR_VAR 0 7
63851: PUSH
63852: LD_EXP 121
63856: PUSH
63857: LD_VAR 0 3
63861: ARRAY
63862: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63863: LD_VAR 0 7
63867: PPUSH
63868: LD_INT 2
63870: PUSH
63871: LD_INT 30
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 30
63883: PUSH
63884: LD_INT 1
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: LIST
63895: PPUSH
63896: CALL_OW 72
63900: IFFALSE 63910
// pos := 2 ;
63902: LD_ADDR_VAR 0 6
63906: PUSH
63907: LD_INT 2
63909: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63910: LD_ADDR_VAR 0 7
63914: PUSH
63915: LD_VAR 0 7
63919: PPUSH
63920: LD_VAR 0 6
63924: PPUSH
63925: LD_VAR 0 7
63929: PPUSH
63930: CALL 71197 0 3
63934: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63935: LD_ADDR_EXP 121
63939: PUSH
63940: LD_EXP 121
63944: PPUSH
63945: LD_VAR 0 3
63949: PPUSH
63950: LD_VAR 0 7
63954: PPUSH
63955: CALL_OW 1
63959: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63960: LD_VAR 0 1
63964: PUSH
63965: LD_EXP 116
63969: PUSH
63970: LD_VAR 0 3
63974: ARRAY
63975: IN
63976: IFFALSE 64015
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63978: LD_ADDR_EXP 116
63982: PUSH
63983: LD_EXP 116
63987: PPUSH
63988: LD_VAR 0 3
63992: PPUSH
63993: LD_EXP 116
63997: PUSH
63998: LD_VAR 0 3
64002: ARRAY
64003: PUSH
64004: LD_VAR 0 1
64008: DIFF
64009: PPUSH
64010: CALL_OW 1
64014: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64015: LD_VAR 0 1
64019: PUSH
64020: LD_EXP 123
64024: PUSH
64025: LD_VAR 0 3
64029: ARRAY
64030: IN
64031: IFFALSE 64070
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64033: LD_ADDR_EXP 123
64037: PUSH
64038: LD_EXP 123
64042: PPUSH
64043: LD_VAR 0 3
64047: PPUSH
64048: LD_EXP 123
64052: PUSH
64053: LD_VAR 0 3
64057: ARRAY
64058: PUSH
64059: LD_VAR 0 1
64063: DIFF
64064: PPUSH
64065: CALL_OW 1
64069: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64070: LD_VAR 0 1
64074: PUSH
64075: LD_EXP 135
64079: PUSH
64080: LD_VAR 0 3
64084: ARRAY
64085: IN
64086: IFFALSE 64125
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64088: LD_ADDR_EXP 135
64092: PUSH
64093: LD_EXP 135
64097: PPUSH
64098: LD_VAR 0 3
64102: PPUSH
64103: LD_EXP 135
64107: PUSH
64108: LD_VAR 0 3
64112: ARRAY
64113: PUSH
64114: LD_VAR 0 1
64118: DIFF
64119: PPUSH
64120: CALL_OW 1
64124: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64125: LD_VAR 0 1
64129: PUSH
64130: LD_EXP 138
64134: PUSH
64135: LD_VAR 0 3
64139: ARRAY
64140: IN
64141: IFFALSE 64180
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64143: LD_ADDR_EXP 138
64147: PUSH
64148: LD_EXP 138
64152: PPUSH
64153: LD_VAR 0 3
64157: PPUSH
64158: LD_EXP 138
64162: PUSH
64163: LD_VAR 0 3
64167: ARRAY
64168: PUSH
64169: LD_VAR 0 1
64173: DIFF
64174: PPUSH
64175: CALL_OW 1
64179: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64180: LD_VAR 0 1
64184: PUSH
64185: LD_EXP 125
64189: PUSH
64190: LD_VAR 0 3
64194: ARRAY
64195: IN
64196: IFFALSE 64235
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64198: LD_ADDR_EXP 125
64202: PUSH
64203: LD_EXP 125
64207: PPUSH
64208: LD_VAR 0 3
64212: PPUSH
64213: LD_EXP 125
64217: PUSH
64218: LD_VAR 0 3
64222: ARRAY
64223: PUSH
64224: LD_VAR 0 1
64228: DIFF
64229: PPUSH
64230: CALL_OW 1
64234: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64235: LD_VAR 0 1
64239: PUSH
64240: LD_EXP 124
64244: PUSH
64245: LD_VAR 0 3
64249: ARRAY
64250: IN
64251: IFFALSE 64290
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64253: LD_ADDR_EXP 124
64257: PUSH
64258: LD_EXP 124
64262: PPUSH
64263: LD_VAR 0 3
64267: PPUSH
64268: LD_EXP 124
64272: PUSH
64273: LD_VAR 0 3
64277: ARRAY
64278: PUSH
64279: LD_VAR 0 1
64283: DIFF
64284: PPUSH
64285: CALL_OW 1
64289: ST_TO_ADDR
// end ; break ;
64290: GO 64294
// end ;
64292: GO 62940
64294: POP
64295: POP
// end ;
64296: LD_VAR 0 2
64300: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64301: LD_INT 0
64303: PPUSH
64304: PPUSH
64305: PPUSH
// if not mc_bases or not skirmish then
64306: LD_EXP 116
64310: NOT
64311: PUSH
64312: LD_EXP 114
64316: NOT
64317: OR
64318: IFFALSE 64322
// exit ;
64320: GO 64537
// for i = 1 to mc_bases do
64322: LD_ADDR_VAR 0 3
64326: PUSH
64327: DOUBLE
64328: LD_INT 1
64330: DEC
64331: ST_TO_ADDR
64332: LD_EXP 116
64336: PUSH
64337: FOR_TO
64338: IFFALSE 64535
// begin if building in mc_construct_list [ i ] then
64340: LD_VAR 0 1
64344: PUSH
64345: LD_EXP 123
64349: PUSH
64350: LD_VAR 0 3
64354: ARRAY
64355: IN
64356: IFFALSE 64533
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64358: LD_ADDR_EXP 123
64362: PUSH
64363: LD_EXP 123
64367: PPUSH
64368: LD_VAR 0 3
64372: PPUSH
64373: LD_EXP 123
64377: PUSH
64378: LD_VAR 0 3
64382: ARRAY
64383: PUSH
64384: LD_VAR 0 1
64388: DIFF
64389: PPUSH
64390: CALL_OW 1
64394: ST_TO_ADDR
// if building in mc_lab [ i ] then
64395: LD_VAR 0 1
64399: PUSH
64400: LD_EXP 149
64404: PUSH
64405: LD_VAR 0 3
64409: ARRAY
64410: IN
64411: IFFALSE 64466
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64413: LD_ADDR_EXP 150
64417: PUSH
64418: LD_EXP 150
64422: PPUSH
64423: LD_VAR 0 3
64427: PPUSH
64428: LD_EXP 150
64432: PUSH
64433: LD_VAR 0 3
64437: ARRAY
64438: PPUSH
64439: LD_INT 1
64441: PPUSH
64442: LD_EXP 150
64446: PUSH
64447: LD_VAR 0 3
64451: ARRAY
64452: PPUSH
64453: LD_INT 0
64455: PPUSH
64456: CALL 70289 0 4
64460: PPUSH
64461: CALL_OW 1
64465: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64466: LD_VAR 0 1
64470: PUSH
64471: LD_EXP 116
64475: PUSH
64476: LD_VAR 0 3
64480: ARRAY
64481: IN
64482: NOT
64483: IFFALSE 64529
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64485: LD_ADDR_EXP 116
64489: PUSH
64490: LD_EXP 116
64494: PPUSH
64495: LD_VAR 0 3
64499: PUSH
64500: LD_EXP 116
64504: PUSH
64505: LD_VAR 0 3
64509: ARRAY
64510: PUSH
64511: LD_INT 1
64513: PLUS
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PPUSH
64519: LD_VAR 0 1
64523: PPUSH
64524: CALL 70871 0 3
64528: ST_TO_ADDR
// exit ;
64529: POP
64530: POP
64531: GO 64537
// end ; end ;
64533: GO 64337
64535: POP
64536: POP
// end ;
64537: LD_VAR 0 2
64541: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64542: LD_INT 0
64544: PPUSH
64545: PPUSH
64546: PPUSH
64547: PPUSH
64548: PPUSH
64549: PPUSH
64550: PPUSH
// if not mc_bases or not skirmish then
64551: LD_EXP 116
64555: NOT
64556: PUSH
64557: LD_EXP 114
64561: NOT
64562: OR
64563: IFFALSE 64567
// exit ;
64565: GO 65228
// for i = 1 to mc_bases do
64567: LD_ADDR_VAR 0 3
64571: PUSH
64572: DOUBLE
64573: LD_INT 1
64575: DEC
64576: ST_TO_ADDR
64577: LD_EXP 116
64581: PUSH
64582: FOR_TO
64583: IFFALSE 65226
// begin if building in mc_construct_list [ i ] then
64585: LD_VAR 0 1
64589: PUSH
64590: LD_EXP 123
64594: PUSH
64595: LD_VAR 0 3
64599: ARRAY
64600: IN
64601: IFFALSE 65224
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64603: LD_ADDR_EXP 123
64607: PUSH
64608: LD_EXP 123
64612: PPUSH
64613: LD_VAR 0 3
64617: PPUSH
64618: LD_EXP 123
64622: PUSH
64623: LD_VAR 0 3
64627: ARRAY
64628: PUSH
64629: LD_VAR 0 1
64633: DIFF
64634: PPUSH
64635: CALL_OW 1
64639: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64640: LD_ADDR_EXP 116
64644: PUSH
64645: LD_EXP 116
64649: PPUSH
64650: LD_VAR 0 3
64654: PUSH
64655: LD_EXP 116
64659: PUSH
64660: LD_VAR 0 3
64664: ARRAY
64665: PUSH
64666: LD_INT 1
64668: PLUS
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PPUSH
64674: LD_VAR 0 1
64678: PPUSH
64679: CALL 70871 0 3
64683: ST_TO_ADDR
// btype := GetBType ( building ) ;
64684: LD_ADDR_VAR 0 5
64688: PUSH
64689: LD_VAR 0 1
64693: PPUSH
64694: CALL_OW 266
64698: ST_TO_ADDR
// side := GetSide ( building ) ;
64699: LD_ADDR_VAR 0 8
64703: PUSH
64704: LD_VAR 0 1
64708: PPUSH
64709: CALL_OW 255
64713: ST_TO_ADDR
// if btype = b_lab then
64714: LD_VAR 0 5
64718: PUSH
64719: LD_INT 6
64721: EQUAL
64722: IFFALSE 64772
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64724: LD_ADDR_EXP 149
64728: PUSH
64729: LD_EXP 149
64733: PPUSH
64734: LD_VAR 0 3
64738: PUSH
64739: LD_EXP 149
64743: PUSH
64744: LD_VAR 0 3
64748: ARRAY
64749: PUSH
64750: LD_INT 1
64752: PLUS
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PPUSH
64758: LD_VAR 0 1
64762: PPUSH
64763: CALL 70871 0 3
64767: ST_TO_ADDR
// exit ;
64768: POP
64769: POP
64770: GO 65228
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64772: LD_VAR 0 5
64776: PUSH
64777: LD_INT 0
64779: PUSH
64780: LD_INT 2
64782: PUSH
64783: LD_INT 4
64785: PUSH
64786: EMPTY
64787: LIST
64788: LIST
64789: LIST
64790: IN
64791: IFFALSE 64915
// begin if btype = b_armoury then
64793: LD_VAR 0 5
64797: PUSH
64798: LD_INT 4
64800: EQUAL
64801: IFFALSE 64811
// btype := b_barracks ;
64803: LD_ADDR_VAR 0 5
64807: PUSH
64808: LD_INT 5
64810: ST_TO_ADDR
// if btype = b_depot then
64811: LD_VAR 0 5
64815: PUSH
64816: LD_INT 0
64818: EQUAL
64819: IFFALSE 64829
// btype := b_warehouse ;
64821: LD_ADDR_VAR 0 5
64825: PUSH
64826: LD_INT 1
64828: ST_TO_ADDR
// if btype = b_workshop then
64829: LD_VAR 0 5
64833: PUSH
64834: LD_INT 2
64836: EQUAL
64837: IFFALSE 64847
// btype := b_factory ;
64839: LD_ADDR_VAR 0 5
64843: PUSH
64844: LD_INT 3
64846: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64847: LD_VAR 0 5
64851: PPUSH
64852: LD_VAR 0 8
64856: PPUSH
64857: CALL_OW 323
64861: PUSH
64862: LD_INT 1
64864: EQUAL
64865: IFFALSE 64911
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64867: LD_ADDR_EXP 148
64871: PUSH
64872: LD_EXP 148
64876: PPUSH
64877: LD_VAR 0 3
64881: PUSH
64882: LD_EXP 148
64886: PUSH
64887: LD_VAR 0 3
64891: ARRAY
64892: PUSH
64893: LD_INT 1
64895: PLUS
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PPUSH
64901: LD_VAR 0 1
64905: PPUSH
64906: CALL 70871 0 3
64910: ST_TO_ADDR
// exit ;
64911: POP
64912: POP
64913: GO 65228
// end ; if btype in [ b_bunker , b_turret ] then
64915: LD_VAR 0 5
64919: PUSH
64920: LD_INT 32
64922: PUSH
64923: LD_INT 33
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: IN
64930: IFFALSE 65220
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64932: LD_ADDR_EXP 124
64936: PUSH
64937: LD_EXP 124
64941: PPUSH
64942: LD_VAR 0 3
64946: PUSH
64947: LD_EXP 124
64951: PUSH
64952: LD_VAR 0 3
64956: ARRAY
64957: PUSH
64958: LD_INT 1
64960: PLUS
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PPUSH
64966: LD_VAR 0 1
64970: PPUSH
64971: CALL 70871 0 3
64975: ST_TO_ADDR
// if btype = b_bunker then
64976: LD_VAR 0 5
64980: PUSH
64981: LD_INT 32
64983: EQUAL
64984: IFFALSE 65220
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64986: LD_ADDR_EXP 125
64990: PUSH
64991: LD_EXP 125
64995: PPUSH
64996: LD_VAR 0 3
65000: PUSH
65001: LD_EXP 125
65005: PUSH
65006: LD_VAR 0 3
65010: ARRAY
65011: PUSH
65012: LD_INT 1
65014: PLUS
65015: PUSH
65016: EMPTY
65017: LIST
65018: LIST
65019: PPUSH
65020: LD_VAR 0 1
65024: PPUSH
65025: CALL 70871 0 3
65029: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65030: LD_ADDR_VAR 0 6
65034: PUSH
65035: LD_EXP 116
65039: PUSH
65040: LD_VAR 0 3
65044: ARRAY
65045: PPUSH
65046: LD_INT 25
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 3
65058: PUSH
65059: LD_INT 54
65061: PUSH
65062: EMPTY
65063: LIST
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PPUSH
65073: CALL_OW 72
65077: ST_TO_ADDR
// if tmp then
65078: LD_VAR 0 6
65082: IFFALSE 65088
// exit ;
65084: POP
65085: POP
65086: GO 65228
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65088: LD_ADDR_VAR 0 6
65092: PUSH
65093: LD_EXP 116
65097: PUSH
65098: LD_VAR 0 3
65102: ARRAY
65103: PPUSH
65104: LD_INT 2
65106: PUSH
65107: LD_INT 30
65109: PUSH
65110: LD_INT 4
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 30
65119: PUSH
65120: LD_INT 5
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: LIST
65131: PPUSH
65132: CALL_OW 72
65136: ST_TO_ADDR
// if not tmp then
65137: LD_VAR 0 6
65141: NOT
65142: IFFALSE 65148
// exit ;
65144: POP
65145: POP
65146: GO 65228
// for j in tmp do
65148: LD_ADDR_VAR 0 4
65152: PUSH
65153: LD_VAR 0 6
65157: PUSH
65158: FOR_IN
65159: IFFALSE 65218
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65161: LD_ADDR_VAR 0 7
65165: PUSH
65166: LD_VAR 0 4
65170: PPUSH
65171: CALL_OW 313
65175: PPUSH
65176: LD_INT 25
65178: PUSH
65179: LD_INT 1
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PPUSH
65186: CALL_OW 72
65190: ST_TO_ADDR
// if units then
65191: LD_VAR 0 7
65195: IFFALSE 65216
// begin ComExitBuilding ( units [ 1 ] ) ;
65197: LD_VAR 0 7
65201: PUSH
65202: LD_INT 1
65204: ARRAY
65205: PPUSH
65206: CALL_OW 122
// exit ;
65210: POP
65211: POP
65212: POP
65213: POP
65214: GO 65228
// end ; end ;
65216: GO 65158
65218: POP
65219: POP
// end ; end ; exit ;
65220: POP
65221: POP
65222: GO 65228
// end ; end ;
65224: GO 64582
65226: POP
65227: POP
// end ;
65228: LD_VAR 0 2
65232: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65233: LD_INT 0
65235: PPUSH
65236: PPUSH
65237: PPUSH
65238: PPUSH
65239: PPUSH
65240: PPUSH
65241: PPUSH
// if not mc_bases or not skirmish then
65242: LD_EXP 116
65246: NOT
65247: PUSH
65248: LD_EXP 114
65252: NOT
65253: OR
65254: IFFALSE 65258
// exit ;
65256: GO 65523
// btype := GetBType ( building ) ;
65258: LD_ADDR_VAR 0 6
65262: PUSH
65263: LD_VAR 0 1
65267: PPUSH
65268: CALL_OW 266
65272: ST_TO_ADDR
// x := GetX ( building ) ;
65273: LD_ADDR_VAR 0 7
65277: PUSH
65278: LD_VAR 0 1
65282: PPUSH
65283: CALL_OW 250
65287: ST_TO_ADDR
// y := GetY ( building ) ;
65288: LD_ADDR_VAR 0 8
65292: PUSH
65293: LD_VAR 0 1
65297: PPUSH
65298: CALL_OW 251
65302: ST_TO_ADDR
// d := GetDir ( building ) ;
65303: LD_ADDR_VAR 0 9
65307: PUSH
65308: LD_VAR 0 1
65312: PPUSH
65313: CALL_OW 254
65317: ST_TO_ADDR
// for i = 1 to mc_bases do
65318: LD_ADDR_VAR 0 4
65322: PUSH
65323: DOUBLE
65324: LD_INT 1
65326: DEC
65327: ST_TO_ADDR
65328: LD_EXP 116
65332: PUSH
65333: FOR_TO
65334: IFFALSE 65521
// begin if not mc_build_list [ i ] then
65336: LD_EXP 121
65340: PUSH
65341: LD_VAR 0 4
65345: ARRAY
65346: NOT
65347: IFFALSE 65351
// continue ;
65349: GO 65333
// for j := 1 to mc_build_list [ i ] do
65351: LD_ADDR_VAR 0 5
65355: PUSH
65356: DOUBLE
65357: LD_INT 1
65359: DEC
65360: ST_TO_ADDR
65361: LD_EXP 121
65365: PUSH
65366: LD_VAR 0 4
65370: ARRAY
65371: PUSH
65372: FOR_TO
65373: IFFALSE 65517
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65375: LD_VAR 0 6
65379: PUSH
65380: LD_VAR 0 7
65384: PUSH
65385: LD_VAR 0 8
65389: PUSH
65390: LD_VAR 0 9
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: PPUSH
65401: LD_EXP 121
65405: PUSH
65406: LD_VAR 0 4
65410: ARRAY
65411: PUSH
65412: LD_VAR 0 5
65416: ARRAY
65417: PPUSH
65418: CALL 77053 0 2
65422: IFFALSE 65515
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65424: LD_ADDR_EXP 121
65428: PUSH
65429: LD_EXP 121
65433: PPUSH
65434: LD_VAR 0 4
65438: PPUSH
65439: LD_EXP 121
65443: PUSH
65444: LD_VAR 0 4
65448: ARRAY
65449: PPUSH
65450: LD_VAR 0 5
65454: PPUSH
65455: CALL_OW 3
65459: PPUSH
65460: CALL_OW 1
65464: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65465: LD_ADDR_EXP 123
65469: PUSH
65470: LD_EXP 123
65474: PPUSH
65475: LD_VAR 0 4
65479: PUSH
65480: LD_EXP 123
65484: PUSH
65485: LD_VAR 0 4
65489: ARRAY
65490: PUSH
65491: LD_INT 1
65493: PLUS
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PPUSH
65499: LD_VAR 0 1
65503: PPUSH
65504: CALL 70871 0 3
65508: ST_TO_ADDR
// exit ;
65509: POP
65510: POP
65511: POP
65512: POP
65513: GO 65523
// end ;
65515: GO 65372
65517: POP
65518: POP
// end ;
65519: GO 65333
65521: POP
65522: POP
// end ;
65523: LD_VAR 0 3
65527: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65528: LD_INT 0
65530: PPUSH
65531: PPUSH
65532: PPUSH
// if not mc_bases or not skirmish then
65533: LD_EXP 116
65537: NOT
65538: PUSH
65539: LD_EXP 114
65543: NOT
65544: OR
65545: IFFALSE 65549
// exit ;
65547: GO 65739
// for i = 1 to mc_bases do
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: DOUBLE
65555: LD_INT 1
65557: DEC
65558: ST_TO_ADDR
65559: LD_EXP 116
65563: PUSH
65564: FOR_TO
65565: IFFALSE 65652
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65567: LD_VAR 0 1
65571: PUSH
65572: LD_EXP 124
65576: PUSH
65577: LD_VAR 0 4
65581: ARRAY
65582: IN
65583: PUSH
65584: LD_VAR 0 1
65588: PUSH
65589: LD_EXP 125
65593: PUSH
65594: LD_VAR 0 4
65598: ARRAY
65599: IN
65600: NOT
65601: AND
65602: IFFALSE 65650
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65604: LD_ADDR_EXP 125
65608: PUSH
65609: LD_EXP 125
65613: PPUSH
65614: LD_VAR 0 4
65618: PUSH
65619: LD_EXP 125
65623: PUSH
65624: LD_VAR 0 4
65628: ARRAY
65629: PUSH
65630: LD_INT 1
65632: PLUS
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PPUSH
65638: LD_VAR 0 1
65642: PPUSH
65643: CALL 70871 0 3
65647: ST_TO_ADDR
// break ;
65648: GO 65652
// end ; end ;
65650: GO 65564
65652: POP
65653: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65654: LD_VAR 0 1
65658: PPUSH
65659: CALL_OW 257
65663: PUSH
65664: LD_EXP 142
65668: IN
65669: PUSH
65670: LD_VAR 0 1
65674: PPUSH
65675: CALL_OW 266
65679: PUSH
65680: LD_INT 5
65682: EQUAL
65683: AND
65684: PUSH
65685: LD_VAR 0 2
65689: PPUSH
65690: CALL_OW 110
65694: PUSH
65695: LD_INT 18
65697: NONEQUAL
65698: AND
65699: IFFALSE 65739
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65701: LD_VAR 0 2
65705: PPUSH
65706: CALL_OW 257
65710: PUSH
65711: LD_INT 5
65713: PUSH
65714: LD_INT 8
65716: PUSH
65717: LD_INT 9
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: LIST
65724: IN
65725: IFFALSE 65739
// SetClass ( unit , 1 ) ;
65727: LD_VAR 0 2
65731: PPUSH
65732: LD_INT 1
65734: PPUSH
65735: CALL_OW 336
// end ;
65739: LD_VAR 0 3
65743: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65744: LD_INT 0
65746: PPUSH
65747: PPUSH
// if not mc_bases or not skirmish then
65748: LD_EXP 116
65752: NOT
65753: PUSH
65754: LD_EXP 114
65758: NOT
65759: OR
65760: IFFALSE 65764
// exit ;
65762: GO 65880
// if GetLives ( abandoned_vehicle ) > 250 then
65764: LD_VAR 0 2
65768: PPUSH
65769: CALL_OW 256
65773: PUSH
65774: LD_INT 250
65776: GREATER
65777: IFFALSE 65781
// exit ;
65779: GO 65880
// for i = 1 to mc_bases do
65781: LD_ADDR_VAR 0 6
65785: PUSH
65786: DOUBLE
65787: LD_INT 1
65789: DEC
65790: ST_TO_ADDR
65791: LD_EXP 116
65795: PUSH
65796: FOR_TO
65797: IFFALSE 65878
// begin if driver in mc_bases [ i ] then
65799: LD_VAR 0 1
65803: PUSH
65804: LD_EXP 116
65808: PUSH
65809: LD_VAR 0 6
65813: ARRAY
65814: IN
65815: IFFALSE 65876
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65817: LD_VAR 0 1
65821: PPUSH
65822: LD_EXP 116
65826: PUSH
65827: LD_VAR 0 6
65831: ARRAY
65832: PPUSH
65833: LD_INT 2
65835: PUSH
65836: LD_INT 30
65838: PUSH
65839: LD_INT 0
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 30
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: LIST
65860: PPUSH
65861: CALL_OW 72
65865: PUSH
65866: LD_INT 1
65868: ARRAY
65869: PPUSH
65870: CALL 103489 0 2
// break ;
65874: GO 65878
// end ; end ;
65876: GO 65796
65878: POP
65879: POP
// end ; end_of_file
65880: LD_VAR 0 5
65884: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65885: LD_INT 0
65887: PPUSH
65888: PPUSH
// if exist_mode then
65889: LD_VAR 0 2
65893: IFFALSE 65918
// unit := CreateCharacter ( prefix & ident ) else
65895: LD_ADDR_VAR 0 5
65899: PUSH
65900: LD_VAR 0 3
65904: PUSH
65905: LD_VAR 0 1
65909: STR
65910: PPUSH
65911: CALL_OW 34
65915: ST_TO_ADDR
65916: GO 65933
// unit := NewCharacter ( ident ) ;
65918: LD_ADDR_VAR 0 5
65922: PUSH
65923: LD_VAR 0 1
65927: PPUSH
65928: CALL_OW 25
65932: ST_TO_ADDR
// result := unit ;
65933: LD_ADDR_VAR 0 4
65937: PUSH
65938: LD_VAR 0 5
65942: ST_TO_ADDR
// end ;
65943: LD_VAR 0 4
65947: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65948: LD_INT 0
65950: PPUSH
65951: PPUSH
// if not side or not nation then
65952: LD_VAR 0 1
65956: NOT
65957: PUSH
65958: LD_VAR 0 2
65962: NOT
65963: OR
65964: IFFALSE 65968
// exit ;
65966: GO 66736
// case nation of nation_american :
65968: LD_VAR 0 2
65972: PUSH
65973: LD_INT 1
65975: DOUBLE
65976: EQUAL
65977: IFTRUE 65981
65979: GO 66195
65981: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65982: LD_ADDR_VAR 0 4
65986: PUSH
65987: LD_INT 35
65989: PUSH
65990: LD_INT 45
65992: PUSH
65993: LD_INT 46
65995: PUSH
65996: LD_INT 47
65998: PUSH
65999: LD_INT 82
66001: PUSH
66002: LD_INT 83
66004: PUSH
66005: LD_INT 84
66007: PUSH
66008: LD_INT 85
66010: PUSH
66011: LD_INT 86
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: LD_INT 2
66019: PUSH
66020: LD_INT 6
66022: PUSH
66023: LD_INT 15
66025: PUSH
66026: LD_INT 16
66028: PUSH
66029: LD_INT 7
66031: PUSH
66032: LD_INT 12
66034: PUSH
66035: LD_INT 13
66037: PUSH
66038: LD_INT 10
66040: PUSH
66041: LD_INT 14
66043: PUSH
66044: LD_INT 20
66046: PUSH
66047: LD_INT 21
66049: PUSH
66050: LD_INT 22
66052: PUSH
66053: LD_INT 25
66055: PUSH
66056: LD_INT 32
66058: PUSH
66059: LD_INT 27
66061: PUSH
66062: LD_INT 36
66064: PUSH
66065: LD_INT 69
66067: PUSH
66068: LD_INT 39
66070: PUSH
66071: LD_INT 34
66073: PUSH
66074: LD_INT 40
66076: PUSH
66077: LD_INT 48
66079: PUSH
66080: LD_INT 49
66082: PUSH
66083: LD_INT 50
66085: PUSH
66086: LD_INT 51
66088: PUSH
66089: LD_INT 52
66091: PUSH
66092: LD_INT 53
66094: PUSH
66095: LD_INT 54
66097: PUSH
66098: LD_INT 55
66100: PUSH
66101: LD_INT 56
66103: PUSH
66104: LD_INT 57
66106: PUSH
66107: LD_INT 58
66109: PUSH
66110: LD_INT 59
66112: PUSH
66113: LD_INT 60
66115: PUSH
66116: LD_INT 61
66118: PUSH
66119: LD_INT 62
66121: PUSH
66122: LD_INT 80
66124: PUSH
66125: LD_INT 82
66127: PUSH
66128: LD_INT 83
66130: PUSH
66131: LD_INT 84
66133: PUSH
66134: LD_INT 85
66136: PUSH
66137: LD_INT 86
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: ST_TO_ADDR
66193: GO 66660
66195: LD_INT 2
66197: DOUBLE
66198: EQUAL
66199: IFTRUE 66203
66201: GO 66429
66203: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66204: LD_ADDR_VAR 0 4
66208: PUSH
66209: LD_INT 35
66211: PUSH
66212: LD_INT 45
66214: PUSH
66215: LD_INT 46
66217: PUSH
66218: LD_INT 47
66220: PUSH
66221: LD_INT 82
66223: PUSH
66224: LD_INT 83
66226: PUSH
66227: LD_INT 84
66229: PUSH
66230: LD_INT 85
66232: PUSH
66233: LD_INT 87
66235: PUSH
66236: LD_INT 70
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: LD_INT 11
66244: PUSH
66245: LD_INT 3
66247: PUSH
66248: LD_INT 4
66250: PUSH
66251: LD_INT 5
66253: PUSH
66254: LD_INT 6
66256: PUSH
66257: LD_INT 15
66259: PUSH
66260: LD_INT 18
66262: PUSH
66263: LD_INT 7
66265: PUSH
66266: LD_INT 17
66268: PUSH
66269: LD_INT 8
66271: PUSH
66272: LD_INT 20
66274: PUSH
66275: LD_INT 21
66277: PUSH
66278: LD_INT 22
66280: PUSH
66281: LD_INT 72
66283: PUSH
66284: LD_INT 26
66286: PUSH
66287: LD_INT 69
66289: PUSH
66290: LD_INT 39
66292: PUSH
66293: LD_INT 40
66295: PUSH
66296: LD_INT 41
66298: PUSH
66299: LD_INT 42
66301: PUSH
66302: LD_INT 43
66304: PUSH
66305: LD_INT 48
66307: PUSH
66308: LD_INT 49
66310: PUSH
66311: LD_INT 50
66313: PUSH
66314: LD_INT 51
66316: PUSH
66317: LD_INT 52
66319: PUSH
66320: LD_INT 53
66322: PUSH
66323: LD_INT 54
66325: PUSH
66326: LD_INT 55
66328: PUSH
66329: LD_INT 56
66331: PUSH
66332: LD_INT 60
66334: PUSH
66335: LD_INT 61
66337: PUSH
66338: LD_INT 62
66340: PUSH
66341: LD_INT 66
66343: PUSH
66344: LD_INT 67
66346: PUSH
66347: LD_INT 68
66349: PUSH
66350: LD_INT 81
66352: PUSH
66353: LD_INT 82
66355: PUSH
66356: LD_INT 83
66358: PUSH
66359: LD_INT 84
66361: PUSH
66362: LD_INT 85
66364: PUSH
66365: LD_INT 87
66367: PUSH
66368: LD_INT 88
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: ST_TO_ADDR
66427: GO 66660
66429: LD_INT 3
66431: DOUBLE
66432: EQUAL
66433: IFTRUE 66437
66435: GO 66659
66437: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66438: LD_ADDR_VAR 0 4
66442: PUSH
66443: LD_INT 46
66445: PUSH
66446: LD_INT 47
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: LD_INT 2
66454: PUSH
66455: LD_INT 82
66457: PUSH
66458: LD_INT 83
66460: PUSH
66461: LD_INT 84
66463: PUSH
66464: LD_INT 85
66466: PUSH
66467: LD_INT 86
66469: PUSH
66470: LD_INT 11
66472: PUSH
66473: LD_INT 9
66475: PUSH
66476: LD_INT 20
66478: PUSH
66479: LD_INT 19
66481: PUSH
66482: LD_INT 21
66484: PUSH
66485: LD_INT 24
66487: PUSH
66488: LD_INT 22
66490: PUSH
66491: LD_INT 25
66493: PUSH
66494: LD_INT 28
66496: PUSH
66497: LD_INT 29
66499: PUSH
66500: LD_INT 30
66502: PUSH
66503: LD_INT 31
66505: PUSH
66506: LD_INT 37
66508: PUSH
66509: LD_INT 38
66511: PUSH
66512: LD_INT 32
66514: PUSH
66515: LD_INT 27
66517: PUSH
66518: LD_INT 33
66520: PUSH
66521: LD_INT 69
66523: PUSH
66524: LD_INT 39
66526: PUSH
66527: LD_INT 34
66529: PUSH
66530: LD_INT 40
66532: PUSH
66533: LD_INT 71
66535: PUSH
66536: LD_INT 23
66538: PUSH
66539: LD_INT 44
66541: PUSH
66542: LD_INT 48
66544: PUSH
66545: LD_INT 49
66547: PUSH
66548: LD_INT 50
66550: PUSH
66551: LD_INT 51
66553: PUSH
66554: LD_INT 52
66556: PUSH
66557: LD_INT 53
66559: PUSH
66560: LD_INT 54
66562: PUSH
66563: LD_INT 55
66565: PUSH
66566: LD_INT 56
66568: PUSH
66569: LD_INT 57
66571: PUSH
66572: LD_INT 58
66574: PUSH
66575: LD_INT 59
66577: PUSH
66578: LD_INT 63
66580: PUSH
66581: LD_INT 64
66583: PUSH
66584: LD_INT 65
66586: PUSH
66587: LD_INT 82
66589: PUSH
66590: LD_INT 83
66592: PUSH
66593: LD_INT 84
66595: PUSH
66596: LD_INT 85
66598: PUSH
66599: LD_INT 86
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: LIST
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: ST_TO_ADDR
66657: GO 66660
66659: POP
// if state > - 1 and state < 3 then
66660: LD_VAR 0 3
66664: PUSH
66665: LD_INT 1
66667: NEG
66668: GREATER
66669: PUSH
66670: LD_VAR 0 3
66674: PUSH
66675: LD_INT 3
66677: LESS
66678: AND
66679: IFFALSE 66736
// for i in result do
66681: LD_ADDR_VAR 0 5
66685: PUSH
66686: LD_VAR 0 4
66690: PUSH
66691: FOR_IN
66692: IFFALSE 66734
// if GetTech ( i , side ) <> state then
66694: LD_VAR 0 5
66698: PPUSH
66699: LD_VAR 0 1
66703: PPUSH
66704: CALL_OW 321
66708: PUSH
66709: LD_VAR 0 3
66713: NONEQUAL
66714: IFFALSE 66732
// result := result diff i ;
66716: LD_ADDR_VAR 0 4
66720: PUSH
66721: LD_VAR 0 4
66725: PUSH
66726: LD_VAR 0 5
66730: DIFF
66731: ST_TO_ADDR
66732: GO 66691
66734: POP
66735: POP
// end ;
66736: LD_VAR 0 4
66740: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66741: LD_INT 0
66743: PPUSH
66744: PPUSH
66745: PPUSH
// result := true ;
66746: LD_ADDR_VAR 0 3
66750: PUSH
66751: LD_INT 1
66753: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66754: LD_ADDR_VAR 0 5
66758: PUSH
66759: LD_VAR 0 2
66763: PPUSH
66764: CALL_OW 480
66768: ST_TO_ADDR
// if not tmp then
66769: LD_VAR 0 5
66773: NOT
66774: IFFALSE 66778
// exit ;
66776: GO 66827
// for i in tmp do
66778: LD_ADDR_VAR 0 4
66782: PUSH
66783: LD_VAR 0 5
66787: PUSH
66788: FOR_IN
66789: IFFALSE 66825
// if GetTech ( i , side ) <> state_researched then
66791: LD_VAR 0 4
66795: PPUSH
66796: LD_VAR 0 1
66800: PPUSH
66801: CALL_OW 321
66805: PUSH
66806: LD_INT 2
66808: NONEQUAL
66809: IFFALSE 66823
// begin result := false ;
66811: LD_ADDR_VAR 0 3
66815: PUSH
66816: LD_INT 0
66818: ST_TO_ADDR
// exit ;
66819: POP
66820: POP
66821: GO 66827
// end ;
66823: GO 66788
66825: POP
66826: POP
// end ;
66827: LD_VAR 0 3
66831: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66832: LD_INT 0
66834: PPUSH
66835: PPUSH
66836: PPUSH
66837: PPUSH
66838: PPUSH
66839: PPUSH
66840: PPUSH
66841: PPUSH
66842: PPUSH
66843: PPUSH
66844: PPUSH
66845: PPUSH
66846: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66847: LD_VAR 0 1
66851: NOT
66852: PUSH
66853: LD_VAR 0 1
66857: PPUSH
66858: CALL_OW 257
66862: PUSH
66863: LD_INT 9
66865: NONEQUAL
66866: OR
66867: IFFALSE 66871
// exit ;
66869: GO 67444
// side := GetSide ( unit ) ;
66871: LD_ADDR_VAR 0 9
66875: PUSH
66876: LD_VAR 0 1
66880: PPUSH
66881: CALL_OW 255
66885: ST_TO_ADDR
// tech_space := tech_spacanom ;
66886: LD_ADDR_VAR 0 12
66890: PUSH
66891: LD_INT 29
66893: ST_TO_ADDR
// tech_time := tech_taurad ;
66894: LD_ADDR_VAR 0 13
66898: PUSH
66899: LD_INT 28
66901: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66902: LD_ADDR_VAR 0 11
66906: PUSH
66907: LD_VAR 0 1
66911: PPUSH
66912: CALL_OW 310
66916: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66917: LD_VAR 0 11
66921: PPUSH
66922: CALL_OW 247
66926: PUSH
66927: LD_INT 2
66929: EQUAL
66930: IFFALSE 66934
// exit ;
66932: GO 67444
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66934: LD_ADDR_VAR 0 8
66938: PUSH
66939: LD_INT 81
66941: PUSH
66942: LD_VAR 0 9
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 3
66953: PUSH
66954: LD_INT 21
66956: PUSH
66957: LD_INT 3
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PPUSH
66972: CALL_OW 69
66976: ST_TO_ADDR
// if not tmp then
66977: LD_VAR 0 8
66981: NOT
66982: IFFALSE 66986
// exit ;
66984: GO 67444
// if in_unit then
66986: LD_VAR 0 11
66990: IFFALSE 67014
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66992: LD_ADDR_VAR 0 10
66996: PUSH
66997: LD_VAR 0 8
67001: PPUSH
67002: LD_VAR 0 11
67006: PPUSH
67007: CALL_OW 74
67011: ST_TO_ADDR
67012: GO 67034
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67014: LD_ADDR_VAR 0 10
67018: PUSH
67019: LD_VAR 0 8
67023: PPUSH
67024: LD_VAR 0 1
67028: PPUSH
67029: CALL_OW 74
67033: ST_TO_ADDR
// if not enemy then
67034: LD_VAR 0 10
67038: NOT
67039: IFFALSE 67043
// exit ;
67041: GO 67444
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67043: LD_VAR 0 11
67047: PUSH
67048: LD_VAR 0 11
67052: PPUSH
67053: LD_VAR 0 10
67057: PPUSH
67058: CALL_OW 296
67062: PUSH
67063: LD_INT 13
67065: GREATER
67066: AND
67067: PUSH
67068: LD_VAR 0 1
67072: PPUSH
67073: LD_VAR 0 10
67077: PPUSH
67078: CALL_OW 296
67082: PUSH
67083: LD_INT 12
67085: GREATER
67086: OR
67087: IFFALSE 67091
// exit ;
67089: GO 67444
// missile := [ 1 ] ;
67091: LD_ADDR_VAR 0 14
67095: PUSH
67096: LD_INT 1
67098: PUSH
67099: EMPTY
67100: LIST
67101: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67102: LD_VAR 0 9
67106: PPUSH
67107: LD_VAR 0 12
67111: PPUSH
67112: CALL_OW 325
67116: IFFALSE 67145
// missile := Insert ( missile , missile + 1 , 2 ) ;
67118: LD_ADDR_VAR 0 14
67122: PUSH
67123: LD_VAR 0 14
67127: PPUSH
67128: LD_VAR 0 14
67132: PUSH
67133: LD_INT 1
67135: PLUS
67136: PPUSH
67137: LD_INT 2
67139: PPUSH
67140: CALL_OW 2
67144: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67145: LD_VAR 0 9
67149: PPUSH
67150: LD_VAR 0 13
67154: PPUSH
67155: CALL_OW 325
67159: PUSH
67160: LD_VAR 0 10
67164: PPUSH
67165: CALL_OW 255
67169: PPUSH
67170: LD_VAR 0 13
67174: PPUSH
67175: CALL_OW 325
67179: NOT
67180: AND
67181: IFFALSE 67210
// missile := Insert ( missile , missile + 1 , 3 ) ;
67183: LD_ADDR_VAR 0 14
67187: PUSH
67188: LD_VAR 0 14
67192: PPUSH
67193: LD_VAR 0 14
67197: PUSH
67198: LD_INT 1
67200: PLUS
67201: PPUSH
67202: LD_INT 3
67204: PPUSH
67205: CALL_OW 2
67209: ST_TO_ADDR
// if missile < 2 then
67210: LD_VAR 0 14
67214: PUSH
67215: LD_INT 2
67217: LESS
67218: IFFALSE 67222
// exit ;
67220: GO 67444
// x := GetX ( enemy ) ;
67222: LD_ADDR_VAR 0 4
67226: PUSH
67227: LD_VAR 0 10
67231: PPUSH
67232: CALL_OW 250
67236: ST_TO_ADDR
// y := GetY ( enemy ) ;
67237: LD_ADDR_VAR 0 5
67241: PUSH
67242: LD_VAR 0 10
67246: PPUSH
67247: CALL_OW 251
67251: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67252: LD_ADDR_VAR 0 6
67256: PUSH
67257: LD_VAR 0 4
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PPUSH
67266: LD_INT 1
67268: PPUSH
67269: CALL_OW 12
67273: PLUS
67274: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67275: LD_ADDR_VAR 0 7
67279: PUSH
67280: LD_VAR 0 5
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PPUSH
67289: LD_INT 1
67291: PPUSH
67292: CALL_OW 12
67296: PLUS
67297: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67298: LD_VAR 0 6
67302: PPUSH
67303: LD_VAR 0 7
67307: PPUSH
67308: CALL_OW 488
67312: NOT
67313: IFFALSE 67335
// begin _x := x ;
67315: LD_ADDR_VAR 0 6
67319: PUSH
67320: LD_VAR 0 4
67324: ST_TO_ADDR
// _y := y ;
67325: LD_ADDR_VAR 0 7
67329: PUSH
67330: LD_VAR 0 5
67334: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67335: LD_ADDR_VAR 0 3
67339: PUSH
67340: LD_INT 1
67342: PPUSH
67343: LD_VAR 0 14
67347: PPUSH
67348: CALL_OW 12
67352: ST_TO_ADDR
// case i of 1 :
67353: LD_VAR 0 3
67357: PUSH
67358: LD_INT 1
67360: DOUBLE
67361: EQUAL
67362: IFTRUE 67366
67364: GO 67383
67366: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67367: LD_VAR 0 1
67371: PPUSH
67372: LD_VAR 0 10
67376: PPUSH
67377: CALL_OW 115
67381: GO 67444
67383: LD_INT 2
67385: DOUBLE
67386: EQUAL
67387: IFTRUE 67391
67389: GO 67413
67391: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67392: LD_VAR 0 1
67396: PPUSH
67397: LD_VAR 0 6
67401: PPUSH
67402: LD_VAR 0 7
67406: PPUSH
67407: CALL_OW 153
67411: GO 67444
67413: LD_INT 3
67415: DOUBLE
67416: EQUAL
67417: IFTRUE 67421
67419: GO 67443
67421: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67422: LD_VAR 0 1
67426: PPUSH
67427: LD_VAR 0 6
67431: PPUSH
67432: LD_VAR 0 7
67436: PPUSH
67437: CALL_OW 154
67441: GO 67444
67443: POP
// end ;
67444: LD_VAR 0 2
67448: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67449: LD_INT 0
67451: PPUSH
67452: PPUSH
67453: PPUSH
67454: PPUSH
67455: PPUSH
67456: PPUSH
// if not unit or not building then
67457: LD_VAR 0 1
67461: NOT
67462: PUSH
67463: LD_VAR 0 2
67467: NOT
67468: OR
67469: IFFALSE 67473
// exit ;
67471: GO 67631
// x := GetX ( building ) ;
67473: LD_ADDR_VAR 0 5
67477: PUSH
67478: LD_VAR 0 2
67482: PPUSH
67483: CALL_OW 250
67487: ST_TO_ADDR
// y := GetY ( building ) ;
67488: LD_ADDR_VAR 0 6
67492: PUSH
67493: LD_VAR 0 2
67497: PPUSH
67498: CALL_OW 251
67502: ST_TO_ADDR
// for i = 0 to 5 do
67503: LD_ADDR_VAR 0 4
67507: PUSH
67508: DOUBLE
67509: LD_INT 0
67511: DEC
67512: ST_TO_ADDR
67513: LD_INT 5
67515: PUSH
67516: FOR_TO
67517: IFFALSE 67629
// begin _x := ShiftX ( x , i , 3 ) ;
67519: LD_ADDR_VAR 0 7
67523: PUSH
67524: LD_VAR 0 5
67528: PPUSH
67529: LD_VAR 0 4
67533: PPUSH
67534: LD_INT 3
67536: PPUSH
67537: CALL_OW 272
67541: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67542: LD_ADDR_VAR 0 8
67546: PUSH
67547: LD_VAR 0 6
67551: PPUSH
67552: LD_VAR 0 4
67556: PPUSH
67557: LD_INT 3
67559: PPUSH
67560: CALL_OW 273
67564: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67565: LD_VAR 0 7
67569: PPUSH
67570: LD_VAR 0 8
67574: PPUSH
67575: CALL_OW 488
67579: NOT
67580: IFFALSE 67584
// continue ;
67582: GO 67516
// if HexInfo ( _x , _y ) = 0 then
67584: LD_VAR 0 7
67588: PPUSH
67589: LD_VAR 0 8
67593: PPUSH
67594: CALL_OW 428
67598: PUSH
67599: LD_INT 0
67601: EQUAL
67602: IFFALSE 67627
// begin ComMoveXY ( unit , _x , _y ) ;
67604: LD_VAR 0 1
67608: PPUSH
67609: LD_VAR 0 7
67613: PPUSH
67614: LD_VAR 0 8
67618: PPUSH
67619: CALL_OW 111
// exit ;
67623: POP
67624: POP
67625: GO 67631
// end ; end ;
67627: GO 67516
67629: POP
67630: POP
// end ;
67631: LD_VAR 0 3
67635: RET
// export function ScanBase ( side , base_area ) ; begin
67636: LD_INT 0
67638: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67639: LD_ADDR_VAR 0 3
67643: PUSH
67644: LD_VAR 0 2
67648: PPUSH
67649: LD_INT 81
67651: PUSH
67652: LD_VAR 0 1
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PPUSH
67661: CALL_OW 70
67665: ST_TO_ADDR
// end ;
67666: LD_VAR 0 3
67670: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67671: LD_INT 0
67673: PPUSH
67674: PPUSH
67675: PPUSH
67676: PPUSH
// result := false ;
67677: LD_ADDR_VAR 0 2
67681: PUSH
67682: LD_INT 0
67684: ST_TO_ADDR
// side := GetSide ( unit ) ;
67685: LD_ADDR_VAR 0 3
67689: PUSH
67690: LD_VAR 0 1
67694: PPUSH
67695: CALL_OW 255
67699: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67700: LD_ADDR_VAR 0 4
67704: PUSH
67705: LD_VAR 0 1
67709: PPUSH
67710: CALL_OW 248
67714: ST_TO_ADDR
// case nat of 1 :
67715: LD_VAR 0 4
67719: PUSH
67720: LD_INT 1
67722: DOUBLE
67723: EQUAL
67724: IFTRUE 67728
67726: GO 67739
67728: POP
// tech := tech_lassight ; 2 :
67729: LD_ADDR_VAR 0 5
67733: PUSH
67734: LD_INT 12
67736: ST_TO_ADDR
67737: GO 67778
67739: LD_INT 2
67741: DOUBLE
67742: EQUAL
67743: IFTRUE 67747
67745: GO 67758
67747: POP
// tech := tech_mortar ; 3 :
67748: LD_ADDR_VAR 0 5
67752: PUSH
67753: LD_INT 41
67755: ST_TO_ADDR
67756: GO 67778
67758: LD_INT 3
67760: DOUBLE
67761: EQUAL
67762: IFTRUE 67766
67764: GO 67777
67766: POP
// tech := tech_bazooka ; end ;
67767: LD_ADDR_VAR 0 5
67771: PUSH
67772: LD_INT 44
67774: ST_TO_ADDR
67775: GO 67778
67777: POP
// if Researched ( side , tech ) then
67778: LD_VAR 0 3
67782: PPUSH
67783: LD_VAR 0 5
67787: PPUSH
67788: CALL_OW 325
67792: IFFALSE 67819
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67794: LD_ADDR_VAR 0 2
67798: PUSH
67799: LD_INT 5
67801: PUSH
67802: LD_INT 8
67804: PUSH
67805: LD_INT 9
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: LIST
67812: PUSH
67813: LD_VAR 0 4
67817: ARRAY
67818: ST_TO_ADDR
// end ;
67819: LD_VAR 0 2
67823: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67824: LD_INT 0
67826: PPUSH
67827: PPUSH
67828: PPUSH
// if not mines then
67829: LD_VAR 0 2
67833: NOT
67834: IFFALSE 67838
// exit ;
67836: GO 67982
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67838: LD_ADDR_VAR 0 5
67842: PUSH
67843: LD_INT 81
67845: PUSH
67846: LD_VAR 0 1
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 3
67857: PUSH
67858: LD_INT 21
67860: PUSH
67861: LD_INT 3
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: CALL_OW 69
67880: ST_TO_ADDR
// for i in mines do
67881: LD_ADDR_VAR 0 4
67885: PUSH
67886: LD_VAR 0 2
67890: PUSH
67891: FOR_IN
67892: IFFALSE 67980
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67894: LD_VAR 0 4
67898: PUSH
67899: LD_INT 1
67901: ARRAY
67902: PPUSH
67903: LD_VAR 0 4
67907: PUSH
67908: LD_INT 2
67910: ARRAY
67911: PPUSH
67912: CALL_OW 458
67916: NOT
67917: IFFALSE 67921
// continue ;
67919: GO 67891
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67921: LD_VAR 0 4
67925: PUSH
67926: LD_INT 1
67928: ARRAY
67929: PPUSH
67930: LD_VAR 0 4
67934: PUSH
67935: LD_INT 2
67937: ARRAY
67938: PPUSH
67939: CALL_OW 428
67943: PUSH
67944: LD_VAR 0 5
67948: IN
67949: IFFALSE 67978
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67951: LD_VAR 0 4
67955: PUSH
67956: LD_INT 1
67958: ARRAY
67959: PPUSH
67960: LD_VAR 0 4
67964: PUSH
67965: LD_INT 2
67967: ARRAY
67968: PPUSH
67969: LD_VAR 0 1
67973: PPUSH
67974: CALL_OW 456
// end ;
67978: GO 67891
67980: POP
67981: POP
// end ;
67982: LD_VAR 0 3
67986: RET
// export function Count ( array ) ; var i ; begin
67987: LD_INT 0
67989: PPUSH
67990: PPUSH
// result := 0 ;
67991: LD_ADDR_VAR 0 2
67995: PUSH
67996: LD_INT 0
67998: ST_TO_ADDR
// for i in array do
67999: LD_ADDR_VAR 0 3
68003: PUSH
68004: LD_VAR 0 1
68008: PUSH
68009: FOR_IN
68010: IFFALSE 68034
// if i then
68012: LD_VAR 0 3
68016: IFFALSE 68032
// result := result + 1 ;
68018: LD_ADDR_VAR 0 2
68022: PUSH
68023: LD_VAR 0 2
68027: PUSH
68028: LD_INT 1
68030: PLUS
68031: ST_TO_ADDR
68032: GO 68009
68034: POP
68035: POP
// end ;
68036: LD_VAR 0 2
68040: RET
// export function IsEmpty ( building ) ; begin
68041: LD_INT 0
68043: PPUSH
// if not building then
68044: LD_VAR 0 1
68048: NOT
68049: IFFALSE 68053
// exit ;
68051: GO 68096
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68053: LD_ADDR_VAR 0 2
68057: PUSH
68058: LD_VAR 0 1
68062: PUSH
68063: LD_INT 22
68065: PUSH
68066: LD_VAR 0 1
68070: PPUSH
68071: CALL_OW 255
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 58
68082: PUSH
68083: EMPTY
68084: LIST
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PPUSH
68090: CALL_OW 69
68094: IN
68095: ST_TO_ADDR
// end ;
68096: LD_VAR 0 2
68100: RET
// export function IsNotFull ( building ) ; begin
68101: LD_INT 0
68103: PPUSH
// if not building then
68104: LD_VAR 0 1
68108: NOT
68109: IFFALSE 68113
// exit ;
68111: GO 68132
// result := UnitsInside ( building ) < 6 ;
68113: LD_ADDR_VAR 0 2
68117: PUSH
68118: LD_VAR 0 1
68122: PPUSH
68123: CALL_OW 313
68127: PUSH
68128: LD_INT 6
68130: LESS
68131: ST_TO_ADDR
// end ;
68132: LD_VAR 0 2
68136: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68137: LD_INT 0
68139: PPUSH
68140: PPUSH
68141: PPUSH
68142: PPUSH
// tmp := [ ] ;
68143: LD_ADDR_VAR 0 3
68147: PUSH
68148: EMPTY
68149: ST_TO_ADDR
// list := [ ] ;
68150: LD_ADDR_VAR 0 5
68154: PUSH
68155: EMPTY
68156: ST_TO_ADDR
// for i = 16 to 25 do
68157: LD_ADDR_VAR 0 4
68161: PUSH
68162: DOUBLE
68163: LD_INT 16
68165: DEC
68166: ST_TO_ADDR
68167: LD_INT 25
68169: PUSH
68170: FOR_TO
68171: IFFALSE 68244
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68173: LD_ADDR_VAR 0 3
68177: PUSH
68178: LD_VAR 0 3
68182: PUSH
68183: LD_INT 22
68185: PUSH
68186: LD_VAR 0 1
68190: PPUSH
68191: CALL_OW 255
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 91
68202: PUSH
68203: LD_VAR 0 1
68207: PUSH
68208: LD_INT 6
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 30
68218: PUSH
68219: LD_VAR 0 4
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: LIST
68232: PUSH
68233: EMPTY
68234: LIST
68235: PPUSH
68236: CALL_OW 69
68240: ADD
68241: ST_TO_ADDR
68242: GO 68170
68244: POP
68245: POP
// for i = 1 to tmp do
68246: LD_ADDR_VAR 0 4
68250: PUSH
68251: DOUBLE
68252: LD_INT 1
68254: DEC
68255: ST_TO_ADDR
68256: LD_VAR 0 3
68260: PUSH
68261: FOR_TO
68262: IFFALSE 68350
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68264: LD_ADDR_VAR 0 5
68268: PUSH
68269: LD_VAR 0 5
68273: PUSH
68274: LD_VAR 0 3
68278: PUSH
68279: LD_VAR 0 4
68283: ARRAY
68284: PPUSH
68285: CALL_OW 266
68289: PUSH
68290: LD_VAR 0 3
68294: PUSH
68295: LD_VAR 0 4
68299: ARRAY
68300: PPUSH
68301: CALL_OW 250
68305: PUSH
68306: LD_VAR 0 3
68310: PUSH
68311: LD_VAR 0 4
68315: ARRAY
68316: PPUSH
68317: CALL_OW 251
68321: PUSH
68322: LD_VAR 0 3
68326: PUSH
68327: LD_VAR 0 4
68331: ARRAY
68332: PPUSH
68333: CALL_OW 254
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: PUSH
68344: EMPTY
68345: LIST
68346: ADD
68347: ST_TO_ADDR
68348: GO 68261
68350: POP
68351: POP
// result := list ;
68352: LD_ADDR_VAR 0 2
68356: PUSH
68357: LD_VAR 0 5
68361: ST_TO_ADDR
// end ;
68362: LD_VAR 0 2
68366: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68367: LD_INT 0
68369: PPUSH
68370: PPUSH
68371: PPUSH
68372: PPUSH
68373: PPUSH
68374: PPUSH
68375: PPUSH
// if not factory then
68376: LD_VAR 0 1
68380: NOT
68381: IFFALSE 68385
// exit ;
68383: GO 68978
// if control = control_apeman then
68385: LD_VAR 0 4
68389: PUSH
68390: LD_INT 5
68392: EQUAL
68393: IFFALSE 68502
// begin tmp := UnitsInside ( factory ) ;
68395: LD_ADDR_VAR 0 8
68399: PUSH
68400: LD_VAR 0 1
68404: PPUSH
68405: CALL_OW 313
68409: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68410: LD_VAR 0 8
68414: PPUSH
68415: LD_INT 25
68417: PUSH
68418: LD_INT 12
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PPUSH
68425: CALL_OW 72
68429: NOT
68430: IFFALSE 68440
// control := control_manual ;
68432: LD_ADDR_VAR 0 4
68436: PUSH
68437: LD_INT 1
68439: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68440: LD_ADDR_VAR 0 8
68444: PUSH
68445: LD_VAR 0 1
68449: PPUSH
68450: CALL 68137 0 1
68454: ST_TO_ADDR
// if tmp then
68455: LD_VAR 0 8
68459: IFFALSE 68502
// begin for i in tmp do
68461: LD_ADDR_VAR 0 7
68465: PUSH
68466: LD_VAR 0 8
68470: PUSH
68471: FOR_IN
68472: IFFALSE 68500
// if i [ 1 ] = b_ext_radio then
68474: LD_VAR 0 7
68478: PUSH
68479: LD_INT 1
68481: ARRAY
68482: PUSH
68483: LD_INT 22
68485: EQUAL
68486: IFFALSE 68498
// begin control := control_remote ;
68488: LD_ADDR_VAR 0 4
68492: PUSH
68493: LD_INT 2
68495: ST_TO_ADDR
// break ;
68496: GO 68500
// end ;
68498: GO 68471
68500: POP
68501: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68502: LD_VAR 0 1
68506: PPUSH
68507: LD_VAR 0 2
68511: PPUSH
68512: LD_VAR 0 3
68516: PPUSH
68517: LD_VAR 0 4
68521: PPUSH
68522: LD_VAR 0 5
68526: PPUSH
68527: CALL_OW 448
68531: IFFALSE 68566
// begin result := [ chassis , engine , control , weapon ] ;
68533: LD_ADDR_VAR 0 6
68537: PUSH
68538: LD_VAR 0 2
68542: PUSH
68543: LD_VAR 0 3
68547: PUSH
68548: LD_VAR 0 4
68552: PUSH
68553: LD_VAR 0 5
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: ST_TO_ADDR
// exit ;
68564: GO 68978
// end ; _chassis := AvailableChassisList ( factory ) ;
68566: LD_ADDR_VAR 0 9
68570: PUSH
68571: LD_VAR 0 1
68575: PPUSH
68576: CALL_OW 475
68580: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68581: LD_ADDR_VAR 0 11
68585: PUSH
68586: LD_VAR 0 1
68590: PPUSH
68591: CALL_OW 476
68595: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68596: LD_ADDR_VAR 0 12
68600: PUSH
68601: LD_VAR 0 1
68605: PPUSH
68606: CALL_OW 477
68610: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68611: LD_ADDR_VAR 0 10
68615: PUSH
68616: LD_VAR 0 1
68620: PPUSH
68621: CALL_OW 478
68625: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68626: LD_VAR 0 9
68630: NOT
68631: PUSH
68632: LD_VAR 0 11
68636: NOT
68637: OR
68638: PUSH
68639: LD_VAR 0 12
68643: NOT
68644: OR
68645: PUSH
68646: LD_VAR 0 10
68650: NOT
68651: OR
68652: IFFALSE 68687
// begin result := [ chassis , engine , control , weapon ] ;
68654: LD_ADDR_VAR 0 6
68658: PUSH
68659: LD_VAR 0 2
68663: PUSH
68664: LD_VAR 0 3
68668: PUSH
68669: LD_VAR 0 4
68673: PUSH
68674: LD_VAR 0 5
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: ST_TO_ADDR
// exit ;
68685: GO 68978
// end ; if not chassis in _chassis then
68687: LD_VAR 0 2
68691: PUSH
68692: LD_VAR 0 9
68696: IN
68697: NOT
68698: IFFALSE 68724
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68700: LD_ADDR_VAR 0 2
68704: PUSH
68705: LD_VAR 0 9
68709: PUSH
68710: LD_INT 1
68712: PPUSH
68713: LD_VAR 0 9
68717: PPUSH
68718: CALL_OW 12
68722: ARRAY
68723: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68724: LD_VAR 0 2
68728: PPUSH
68729: LD_VAR 0 3
68733: PPUSH
68734: CALL 68983 0 2
68738: NOT
68739: IFFALSE 68798
// repeat engine := _engine [ 1 ] ;
68741: LD_ADDR_VAR 0 3
68745: PUSH
68746: LD_VAR 0 11
68750: PUSH
68751: LD_INT 1
68753: ARRAY
68754: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68755: LD_ADDR_VAR 0 11
68759: PUSH
68760: LD_VAR 0 11
68764: PPUSH
68765: LD_INT 1
68767: PPUSH
68768: CALL_OW 3
68772: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68773: LD_VAR 0 2
68777: PPUSH
68778: LD_VAR 0 3
68782: PPUSH
68783: CALL 68983 0 2
68787: PUSH
68788: LD_VAR 0 11
68792: PUSH
68793: EMPTY
68794: EQUAL
68795: OR
68796: IFFALSE 68741
// if not control in _control then
68798: LD_VAR 0 4
68802: PUSH
68803: LD_VAR 0 12
68807: IN
68808: NOT
68809: IFFALSE 68835
// control := _control [ rand ( 1 , _control ) ] ;
68811: LD_ADDR_VAR 0 4
68815: PUSH
68816: LD_VAR 0 12
68820: PUSH
68821: LD_INT 1
68823: PPUSH
68824: LD_VAR 0 12
68828: PPUSH
68829: CALL_OW 12
68833: ARRAY
68834: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68835: LD_VAR 0 2
68839: PPUSH
68840: LD_VAR 0 5
68844: PPUSH
68845: CALL 69203 0 2
68849: NOT
68850: IFFALSE 68909
// repeat weapon := _weapon [ 1 ] ;
68852: LD_ADDR_VAR 0 5
68856: PUSH
68857: LD_VAR 0 10
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68866: LD_ADDR_VAR 0 10
68870: PUSH
68871: LD_VAR 0 10
68875: PPUSH
68876: LD_INT 1
68878: PPUSH
68879: CALL_OW 3
68883: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68884: LD_VAR 0 2
68888: PPUSH
68889: LD_VAR 0 5
68893: PPUSH
68894: CALL 69203 0 2
68898: PUSH
68899: LD_VAR 0 10
68903: PUSH
68904: EMPTY
68905: EQUAL
68906: OR
68907: IFFALSE 68852
// result := [ ] ;
68909: LD_ADDR_VAR 0 6
68913: PUSH
68914: EMPTY
68915: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68916: LD_VAR 0 1
68920: PPUSH
68921: LD_VAR 0 2
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: LD_VAR 0 4
68935: PPUSH
68936: LD_VAR 0 5
68940: PPUSH
68941: CALL_OW 448
68945: IFFALSE 68978
// result := [ chassis , engine , control , weapon ] ;
68947: LD_ADDR_VAR 0 6
68951: PUSH
68952: LD_VAR 0 2
68956: PUSH
68957: LD_VAR 0 3
68961: PUSH
68962: LD_VAR 0 4
68966: PUSH
68967: LD_VAR 0 5
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: ST_TO_ADDR
// end ;
68978: LD_VAR 0 6
68982: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68983: LD_INT 0
68985: PPUSH
// if not chassis or not engine then
68986: LD_VAR 0 1
68990: NOT
68991: PUSH
68992: LD_VAR 0 2
68996: NOT
68997: OR
68998: IFFALSE 69002
// exit ;
69000: GO 69198
// case engine of engine_solar :
69002: LD_VAR 0 2
69006: PUSH
69007: LD_INT 2
69009: DOUBLE
69010: EQUAL
69011: IFTRUE 69015
69013: GO 69053
69015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_INT 11
69023: PUSH
69024: LD_INT 12
69026: PUSH
69027: LD_INT 13
69029: PUSH
69030: LD_INT 14
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: ST_TO_ADDR
69051: GO 69182
69053: LD_INT 1
69055: DOUBLE
69056: EQUAL
69057: IFTRUE 69061
69059: GO 69123
69061: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69062: LD_ADDR_VAR 0 3
69066: PUSH
69067: LD_INT 11
69069: PUSH
69070: LD_INT 12
69072: PUSH
69073: LD_INT 13
69075: PUSH
69076: LD_INT 14
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: LD_INT 2
69084: PUSH
69085: LD_INT 3
69087: PUSH
69088: LD_INT 4
69090: PUSH
69091: LD_INT 5
69093: PUSH
69094: LD_INT 21
69096: PUSH
69097: LD_INT 23
69099: PUSH
69100: LD_INT 22
69102: PUSH
69103: LD_INT 24
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: ST_TO_ADDR
69121: GO 69182
69123: LD_INT 3
69125: DOUBLE
69126: EQUAL
69127: IFTRUE 69131
69129: GO 69181
69131: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69132: LD_ADDR_VAR 0 3
69136: PUSH
69137: LD_INT 13
69139: PUSH
69140: LD_INT 14
69142: PUSH
69143: LD_INT 2
69145: PUSH
69146: LD_INT 3
69148: PUSH
69149: LD_INT 4
69151: PUSH
69152: LD_INT 5
69154: PUSH
69155: LD_INT 21
69157: PUSH
69158: LD_INT 22
69160: PUSH
69161: LD_INT 23
69163: PUSH
69164: LD_INT 24
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: ST_TO_ADDR
69179: GO 69182
69181: POP
// result := ( chassis in result ) ;
69182: LD_ADDR_VAR 0 3
69186: PUSH
69187: LD_VAR 0 1
69191: PUSH
69192: LD_VAR 0 3
69196: IN
69197: ST_TO_ADDR
// end ;
69198: LD_VAR 0 3
69202: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69203: LD_INT 0
69205: PPUSH
// if not chassis or not weapon then
69206: LD_VAR 0 1
69210: NOT
69211: PUSH
69212: LD_VAR 0 2
69216: NOT
69217: OR
69218: IFFALSE 69222
// exit ;
69220: GO 70284
// case weapon of us_machine_gun :
69222: LD_VAR 0 2
69226: PUSH
69227: LD_INT 2
69229: DOUBLE
69230: EQUAL
69231: IFTRUE 69235
69233: GO 69265
69235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69236: LD_ADDR_VAR 0 3
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: LD_INT 2
69246: PUSH
69247: LD_INT 3
69249: PUSH
69250: LD_INT 4
69252: PUSH
69253: LD_INT 5
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: ST_TO_ADDR
69263: GO 70268
69265: LD_INT 3
69267: DOUBLE
69268: EQUAL
69269: IFTRUE 69273
69271: GO 69303
69273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69274: LD_ADDR_VAR 0 3
69278: PUSH
69279: LD_INT 1
69281: PUSH
69282: LD_INT 2
69284: PUSH
69285: LD_INT 3
69287: PUSH
69288: LD_INT 4
69290: PUSH
69291: LD_INT 5
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: ST_TO_ADDR
69301: GO 70268
69303: LD_INT 11
69305: DOUBLE
69306: EQUAL
69307: IFTRUE 69311
69309: GO 69341
69311: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: LD_INT 3
69325: PUSH
69326: LD_INT 4
69328: PUSH
69329: LD_INT 5
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
69339: GO 70268
69341: LD_INT 4
69343: DOUBLE
69344: EQUAL
69345: IFTRUE 69349
69347: GO 69375
69349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69350: LD_ADDR_VAR 0 3
69354: PUSH
69355: LD_INT 2
69357: PUSH
69358: LD_INT 3
69360: PUSH
69361: LD_INT 4
69363: PUSH
69364: LD_INT 5
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
69373: GO 70268
69375: LD_INT 5
69377: DOUBLE
69378: EQUAL
69379: IFTRUE 69383
69381: GO 69409
69383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69384: LD_ADDR_VAR 0 3
69388: PUSH
69389: LD_INT 2
69391: PUSH
69392: LD_INT 3
69394: PUSH
69395: LD_INT 4
69397: PUSH
69398: LD_INT 5
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: ST_TO_ADDR
69407: GO 70268
69409: LD_INT 9
69411: DOUBLE
69412: EQUAL
69413: IFTRUE 69417
69415: GO 69443
69417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69418: LD_ADDR_VAR 0 3
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 3
69428: PUSH
69429: LD_INT 4
69431: PUSH
69432: LD_INT 5
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: ST_TO_ADDR
69441: GO 70268
69443: LD_INT 7
69445: DOUBLE
69446: EQUAL
69447: IFTRUE 69451
69449: GO 69477
69451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69452: LD_ADDR_VAR 0 3
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: LD_INT 3
69462: PUSH
69463: LD_INT 4
69465: PUSH
69466: LD_INT 5
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: ST_TO_ADDR
69475: GO 70268
69477: LD_INT 12
69479: DOUBLE
69480: EQUAL
69481: IFTRUE 69485
69483: GO 69511
69485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69486: LD_ADDR_VAR 0 3
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 3
69496: PUSH
69497: LD_INT 4
69499: PUSH
69500: LD_INT 5
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: ST_TO_ADDR
69509: GO 70268
69511: LD_INT 13
69513: DOUBLE
69514: EQUAL
69515: IFTRUE 69519
69517: GO 69545
69519: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69520: LD_ADDR_VAR 0 3
69524: PUSH
69525: LD_INT 2
69527: PUSH
69528: LD_INT 3
69530: PUSH
69531: LD_INT 4
69533: PUSH
69534: LD_INT 5
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: ST_TO_ADDR
69543: GO 70268
69545: LD_INT 14
69547: DOUBLE
69548: EQUAL
69549: IFTRUE 69553
69551: GO 69571
69553: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69554: LD_ADDR_VAR 0 3
69558: PUSH
69559: LD_INT 4
69561: PUSH
69562: LD_INT 5
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: ST_TO_ADDR
69569: GO 70268
69571: LD_INT 6
69573: DOUBLE
69574: EQUAL
69575: IFTRUE 69579
69577: GO 69597
69579: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69580: LD_ADDR_VAR 0 3
69584: PUSH
69585: LD_INT 4
69587: PUSH
69588: LD_INT 5
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: ST_TO_ADDR
69595: GO 70268
69597: LD_INT 10
69599: DOUBLE
69600: EQUAL
69601: IFTRUE 69605
69603: GO 69623
69605: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69606: LD_ADDR_VAR 0 3
69610: PUSH
69611: LD_INT 4
69613: PUSH
69614: LD_INT 5
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: ST_TO_ADDR
69621: GO 70268
69623: LD_INT 22
69625: DOUBLE
69626: EQUAL
69627: IFTRUE 69631
69629: GO 69657
69631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69632: LD_ADDR_VAR 0 3
69636: PUSH
69637: LD_INT 11
69639: PUSH
69640: LD_INT 12
69642: PUSH
69643: LD_INT 13
69645: PUSH
69646: LD_INT 14
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: ST_TO_ADDR
69655: GO 70268
69657: LD_INT 23
69659: DOUBLE
69660: EQUAL
69661: IFTRUE 69665
69663: GO 69691
69665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69666: LD_ADDR_VAR 0 3
69670: PUSH
69671: LD_INT 11
69673: PUSH
69674: LD_INT 12
69676: PUSH
69677: LD_INT 13
69679: PUSH
69680: LD_INT 14
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: ST_TO_ADDR
69689: GO 70268
69691: LD_INT 24
69693: DOUBLE
69694: EQUAL
69695: IFTRUE 69699
69697: GO 69725
69699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69700: LD_ADDR_VAR 0 3
69704: PUSH
69705: LD_INT 11
69707: PUSH
69708: LD_INT 12
69710: PUSH
69711: LD_INT 13
69713: PUSH
69714: LD_INT 14
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: ST_TO_ADDR
69723: GO 70268
69725: LD_INT 30
69727: DOUBLE
69728: EQUAL
69729: IFTRUE 69733
69731: GO 69759
69733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69734: LD_ADDR_VAR 0 3
69738: PUSH
69739: LD_INT 11
69741: PUSH
69742: LD_INT 12
69744: PUSH
69745: LD_INT 13
69747: PUSH
69748: LD_INT 14
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: ST_TO_ADDR
69757: GO 70268
69759: LD_INT 25
69761: DOUBLE
69762: EQUAL
69763: IFTRUE 69767
69765: GO 69785
69767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69768: LD_ADDR_VAR 0 3
69772: PUSH
69773: LD_INT 13
69775: PUSH
69776: LD_INT 14
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: ST_TO_ADDR
69783: GO 70268
69785: LD_INT 27
69787: DOUBLE
69788: EQUAL
69789: IFTRUE 69793
69791: GO 69811
69793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69794: LD_ADDR_VAR 0 3
69798: PUSH
69799: LD_INT 13
69801: PUSH
69802: LD_INT 14
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: ST_TO_ADDR
69809: GO 70268
69811: LD_EXP 100
69815: DOUBLE
69816: EQUAL
69817: IFTRUE 69821
69819: GO 69847
69821: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69822: LD_ADDR_VAR 0 3
69826: PUSH
69827: LD_INT 11
69829: PUSH
69830: LD_INT 12
69832: PUSH
69833: LD_INT 13
69835: PUSH
69836: LD_INT 14
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: ST_TO_ADDR
69845: GO 70268
69847: LD_INT 28
69849: DOUBLE
69850: EQUAL
69851: IFTRUE 69855
69853: GO 69873
69855: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69856: LD_ADDR_VAR 0 3
69860: PUSH
69861: LD_INT 13
69863: PUSH
69864: LD_INT 14
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: ST_TO_ADDR
69871: GO 70268
69873: LD_INT 29
69875: DOUBLE
69876: EQUAL
69877: IFTRUE 69881
69879: GO 69899
69881: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69882: LD_ADDR_VAR 0 3
69886: PUSH
69887: LD_INT 13
69889: PUSH
69890: LD_INT 14
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: ST_TO_ADDR
69897: GO 70268
69899: LD_INT 31
69901: DOUBLE
69902: EQUAL
69903: IFTRUE 69907
69905: GO 69925
69907: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69908: LD_ADDR_VAR 0 3
69912: PUSH
69913: LD_INT 13
69915: PUSH
69916: LD_INT 14
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: ST_TO_ADDR
69923: GO 70268
69925: LD_INT 26
69927: DOUBLE
69928: EQUAL
69929: IFTRUE 69933
69931: GO 69951
69933: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69934: LD_ADDR_VAR 0 3
69938: PUSH
69939: LD_INT 13
69941: PUSH
69942: LD_INT 14
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: ST_TO_ADDR
69949: GO 70268
69951: LD_INT 42
69953: DOUBLE
69954: EQUAL
69955: IFTRUE 69959
69957: GO 69985
69959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69960: LD_ADDR_VAR 0 3
69964: PUSH
69965: LD_INT 21
69967: PUSH
69968: LD_INT 22
69970: PUSH
69971: LD_INT 23
69973: PUSH
69974: LD_INT 24
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: ST_TO_ADDR
69983: GO 70268
69985: LD_INT 43
69987: DOUBLE
69988: EQUAL
69989: IFTRUE 69993
69991: GO 70019
69993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69994: LD_ADDR_VAR 0 3
69998: PUSH
69999: LD_INT 21
70001: PUSH
70002: LD_INT 22
70004: PUSH
70005: LD_INT 23
70007: PUSH
70008: LD_INT 24
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: ST_TO_ADDR
70017: GO 70268
70019: LD_INT 44
70021: DOUBLE
70022: EQUAL
70023: IFTRUE 70027
70025: GO 70053
70027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70028: LD_ADDR_VAR 0 3
70032: PUSH
70033: LD_INT 21
70035: PUSH
70036: LD_INT 22
70038: PUSH
70039: LD_INT 23
70041: PUSH
70042: LD_INT 24
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: ST_TO_ADDR
70051: GO 70268
70053: LD_INT 45
70055: DOUBLE
70056: EQUAL
70057: IFTRUE 70061
70059: GO 70087
70061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70062: LD_ADDR_VAR 0 3
70066: PUSH
70067: LD_INT 21
70069: PUSH
70070: LD_INT 22
70072: PUSH
70073: LD_INT 23
70075: PUSH
70076: LD_INT 24
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: ST_TO_ADDR
70085: GO 70268
70087: LD_INT 49
70089: DOUBLE
70090: EQUAL
70091: IFTRUE 70095
70093: GO 70121
70095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70096: LD_ADDR_VAR 0 3
70100: PUSH
70101: LD_INT 21
70103: PUSH
70104: LD_INT 22
70106: PUSH
70107: LD_INT 23
70109: PUSH
70110: LD_INT 24
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: ST_TO_ADDR
70119: GO 70268
70121: LD_INT 51
70123: DOUBLE
70124: EQUAL
70125: IFTRUE 70129
70127: GO 70155
70129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70130: LD_ADDR_VAR 0 3
70134: PUSH
70135: LD_INT 21
70137: PUSH
70138: LD_INT 22
70140: PUSH
70141: LD_INT 23
70143: PUSH
70144: LD_INT 24
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: ST_TO_ADDR
70153: GO 70268
70155: LD_INT 52
70157: DOUBLE
70158: EQUAL
70159: IFTRUE 70163
70161: GO 70189
70163: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70164: LD_ADDR_VAR 0 3
70168: PUSH
70169: LD_INT 21
70171: PUSH
70172: LD_INT 22
70174: PUSH
70175: LD_INT 23
70177: PUSH
70178: LD_INT 24
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: ST_TO_ADDR
70187: GO 70268
70189: LD_INT 53
70191: DOUBLE
70192: EQUAL
70193: IFTRUE 70197
70195: GO 70215
70197: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70198: LD_ADDR_VAR 0 3
70202: PUSH
70203: LD_INT 23
70205: PUSH
70206: LD_INT 24
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: ST_TO_ADDR
70213: GO 70268
70215: LD_INT 46
70217: DOUBLE
70218: EQUAL
70219: IFTRUE 70223
70221: GO 70241
70223: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70224: LD_ADDR_VAR 0 3
70228: PUSH
70229: LD_INT 23
70231: PUSH
70232: LD_INT 24
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: ST_TO_ADDR
70239: GO 70268
70241: LD_INT 47
70243: DOUBLE
70244: EQUAL
70245: IFTRUE 70249
70247: GO 70267
70249: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70250: LD_ADDR_VAR 0 3
70254: PUSH
70255: LD_INT 23
70257: PUSH
70258: LD_INT 24
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: ST_TO_ADDR
70265: GO 70268
70267: POP
// result := ( chassis in result ) ;
70268: LD_ADDR_VAR 0 3
70272: PUSH
70273: LD_VAR 0 1
70277: PUSH
70278: LD_VAR 0 3
70282: IN
70283: ST_TO_ADDR
// end ;
70284: LD_VAR 0 3
70288: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70289: LD_INT 0
70291: PPUSH
70292: PPUSH
70293: PPUSH
70294: PPUSH
70295: PPUSH
70296: PPUSH
70297: PPUSH
// result := array ;
70298: LD_ADDR_VAR 0 5
70302: PUSH
70303: LD_VAR 0 1
70307: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70308: LD_VAR 0 1
70312: NOT
70313: PUSH
70314: LD_VAR 0 2
70318: NOT
70319: OR
70320: PUSH
70321: LD_VAR 0 3
70325: NOT
70326: OR
70327: PUSH
70328: LD_VAR 0 2
70332: PUSH
70333: LD_VAR 0 1
70337: GREATER
70338: OR
70339: PUSH
70340: LD_VAR 0 3
70344: PUSH
70345: LD_VAR 0 1
70349: GREATER
70350: OR
70351: IFFALSE 70355
// exit ;
70353: GO 70651
// if direction then
70355: LD_VAR 0 4
70359: IFFALSE 70423
// begin d := 1 ;
70361: LD_ADDR_VAR 0 9
70365: PUSH
70366: LD_INT 1
70368: ST_TO_ADDR
// if i_from > i_to then
70369: LD_VAR 0 2
70373: PUSH
70374: LD_VAR 0 3
70378: GREATER
70379: IFFALSE 70405
// length := ( array - i_from ) + i_to else
70381: LD_ADDR_VAR 0 11
70385: PUSH
70386: LD_VAR 0 1
70390: PUSH
70391: LD_VAR 0 2
70395: MINUS
70396: PUSH
70397: LD_VAR 0 3
70401: PLUS
70402: ST_TO_ADDR
70403: GO 70421
// length := i_to - i_from ;
70405: LD_ADDR_VAR 0 11
70409: PUSH
70410: LD_VAR 0 3
70414: PUSH
70415: LD_VAR 0 2
70419: MINUS
70420: ST_TO_ADDR
// end else
70421: GO 70484
// begin d := - 1 ;
70423: LD_ADDR_VAR 0 9
70427: PUSH
70428: LD_INT 1
70430: NEG
70431: ST_TO_ADDR
// if i_from > i_to then
70432: LD_VAR 0 2
70436: PUSH
70437: LD_VAR 0 3
70441: GREATER
70442: IFFALSE 70462
// length := i_from - i_to else
70444: LD_ADDR_VAR 0 11
70448: PUSH
70449: LD_VAR 0 2
70453: PUSH
70454: LD_VAR 0 3
70458: MINUS
70459: ST_TO_ADDR
70460: GO 70484
// length := ( array - i_to ) + i_from ;
70462: LD_ADDR_VAR 0 11
70466: PUSH
70467: LD_VAR 0 1
70471: PUSH
70472: LD_VAR 0 3
70476: MINUS
70477: PUSH
70478: LD_VAR 0 2
70482: PLUS
70483: ST_TO_ADDR
// end ; if not length then
70484: LD_VAR 0 11
70488: NOT
70489: IFFALSE 70493
// exit ;
70491: GO 70651
// tmp := array ;
70493: LD_ADDR_VAR 0 10
70497: PUSH
70498: LD_VAR 0 1
70502: ST_TO_ADDR
// for i = 1 to length do
70503: LD_ADDR_VAR 0 6
70507: PUSH
70508: DOUBLE
70509: LD_INT 1
70511: DEC
70512: ST_TO_ADDR
70513: LD_VAR 0 11
70517: PUSH
70518: FOR_TO
70519: IFFALSE 70639
// begin for j = 1 to array do
70521: LD_ADDR_VAR 0 7
70525: PUSH
70526: DOUBLE
70527: LD_INT 1
70529: DEC
70530: ST_TO_ADDR
70531: LD_VAR 0 1
70535: PUSH
70536: FOR_TO
70537: IFFALSE 70625
// begin k := j + d ;
70539: LD_ADDR_VAR 0 8
70543: PUSH
70544: LD_VAR 0 7
70548: PUSH
70549: LD_VAR 0 9
70553: PLUS
70554: ST_TO_ADDR
// if k > array then
70555: LD_VAR 0 8
70559: PUSH
70560: LD_VAR 0 1
70564: GREATER
70565: IFFALSE 70575
// k := 1 ;
70567: LD_ADDR_VAR 0 8
70571: PUSH
70572: LD_INT 1
70574: ST_TO_ADDR
// if not k then
70575: LD_VAR 0 8
70579: NOT
70580: IFFALSE 70592
// k := array ;
70582: LD_ADDR_VAR 0 8
70586: PUSH
70587: LD_VAR 0 1
70591: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70592: LD_ADDR_VAR 0 10
70596: PUSH
70597: LD_VAR 0 10
70601: PPUSH
70602: LD_VAR 0 8
70606: PPUSH
70607: LD_VAR 0 1
70611: PUSH
70612: LD_VAR 0 7
70616: ARRAY
70617: PPUSH
70618: CALL_OW 1
70622: ST_TO_ADDR
// end ;
70623: GO 70536
70625: POP
70626: POP
// array := tmp ;
70627: LD_ADDR_VAR 0 1
70631: PUSH
70632: LD_VAR 0 10
70636: ST_TO_ADDR
// end ;
70637: GO 70518
70639: POP
70640: POP
// result := array ;
70641: LD_ADDR_VAR 0 5
70645: PUSH
70646: LD_VAR 0 1
70650: ST_TO_ADDR
// end ;
70651: LD_VAR 0 5
70655: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70656: LD_INT 0
70658: PPUSH
70659: PPUSH
// result := 0 ;
70660: LD_ADDR_VAR 0 3
70664: PUSH
70665: LD_INT 0
70667: ST_TO_ADDR
// if not array or not value in array then
70668: LD_VAR 0 1
70672: NOT
70673: PUSH
70674: LD_VAR 0 2
70678: PUSH
70679: LD_VAR 0 1
70683: IN
70684: NOT
70685: OR
70686: IFFALSE 70690
// exit ;
70688: GO 70744
// for i = 1 to array do
70690: LD_ADDR_VAR 0 4
70694: PUSH
70695: DOUBLE
70696: LD_INT 1
70698: DEC
70699: ST_TO_ADDR
70700: LD_VAR 0 1
70704: PUSH
70705: FOR_TO
70706: IFFALSE 70742
// if value = array [ i ] then
70708: LD_VAR 0 2
70712: PUSH
70713: LD_VAR 0 1
70717: PUSH
70718: LD_VAR 0 4
70722: ARRAY
70723: EQUAL
70724: IFFALSE 70740
// begin result := i ;
70726: LD_ADDR_VAR 0 3
70730: PUSH
70731: LD_VAR 0 4
70735: ST_TO_ADDR
// exit ;
70736: POP
70737: POP
70738: GO 70744
// end ;
70740: GO 70705
70742: POP
70743: POP
// end ;
70744: LD_VAR 0 3
70748: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70749: LD_INT 0
70751: PPUSH
// vc_chassis := chassis ;
70752: LD_ADDR_OWVAR 37
70756: PUSH
70757: LD_VAR 0 1
70761: ST_TO_ADDR
// vc_engine := engine ;
70762: LD_ADDR_OWVAR 39
70766: PUSH
70767: LD_VAR 0 2
70771: ST_TO_ADDR
// vc_control := control ;
70772: LD_ADDR_OWVAR 38
70776: PUSH
70777: LD_VAR 0 3
70781: ST_TO_ADDR
// vc_weapon := weapon ;
70782: LD_ADDR_OWVAR 40
70786: PUSH
70787: LD_VAR 0 4
70791: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70792: LD_ADDR_OWVAR 41
70796: PUSH
70797: LD_VAR 0 5
70801: ST_TO_ADDR
// end ;
70802: LD_VAR 0 6
70806: RET
// export function WantPlant ( unit ) ; var task ; begin
70807: LD_INT 0
70809: PPUSH
70810: PPUSH
// result := false ;
70811: LD_ADDR_VAR 0 2
70815: PUSH
70816: LD_INT 0
70818: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70819: LD_ADDR_VAR 0 3
70823: PUSH
70824: LD_VAR 0 1
70828: PPUSH
70829: CALL_OW 437
70833: ST_TO_ADDR
// if task then
70834: LD_VAR 0 3
70838: IFFALSE 70866
// if task [ 1 ] [ 1 ] = p then
70840: LD_VAR 0 3
70844: PUSH
70845: LD_INT 1
70847: ARRAY
70848: PUSH
70849: LD_INT 1
70851: ARRAY
70852: PUSH
70853: LD_STRING p
70855: EQUAL
70856: IFFALSE 70866
// result := true ;
70858: LD_ADDR_VAR 0 2
70862: PUSH
70863: LD_INT 1
70865: ST_TO_ADDR
// end ;
70866: LD_VAR 0 2
70870: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70871: LD_INT 0
70873: PPUSH
70874: PPUSH
70875: PPUSH
70876: PPUSH
// if pos < 1 then
70877: LD_VAR 0 2
70881: PUSH
70882: LD_INT 1
70884: LESS
70885: IFFALSE 70889
// exit ;
70887: GO 71192
// if pos = 1 then
70889: LD_VAR 0 2
70893: PUSH
70894: LD_INT 1
70896: EQUAL
70897: IFFALSE 70930
// result := Replace ( arr , pos [ 1 ] , value ) else
70899: LD_ADDR_VAR 0 4
70903: PUSH
70904: LD_VAR 0 1
70908: PPUSH
70909: LD_VAR 0 2
70913: PUSH
70914: LD_INT 1
70916: ARRAY
70917: PPUSH
70918: LD_VAR 0 3
70922: PPUSH
70923: CALL_OW 1
70927: ST_TO_ADDR
70928: GO 71192
// begin tmp := arr ;
70930: LD_ADDR_VAR 0 6
70934: PUSH
70935: LD_VAR 0 1
70939: ST_TO_ADDR
// s_arr := [ tmp ] ;
70940: LD_ADDR_VAR 0 7
70944: PUSH
70945: LD_VAR 0 6
70949: PUSH
70950: EMPTY
70951: LIST
70952: ST_TO_ADDR
// for i = 1 to pos - 1 do
70953: LD_ADDR_VAR 0 5
70957: PUSH
70958: DOUBLE
70959: LD_INT 1
70961: DEC
70962: ST_TO_ADDR
70963: LD_VAR 0 2
70967: PUSH
70968: LD_INT 1
70970: MINUS
70971: PUSH
70972: FOR_TO
70973: IFFALSE 71018
// begin tmp := tmp [ pos [ i ] ] ;
70975: LD_ADDR_VAR 0 6
70979: PUSH
70980: LD_VAR 0 6
70984: PUSH
70985: LD_VAR 0 2
70989: PUSH
70990: LD_VAR 0 5
70994: ARRAY
70995: ARRAY
70996: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70997: LD_ADDR_VAR 0 7
71001: PUSH
71002: LD_VAR 0 7
71006: PUSH
71007: LD_VAR 0 6
71011: PUSH
71012: EMPTY
71013: LIST
71014: ADD
71015: ST_TO_ADDR
// end ;
71016: GO 70972
71018: POP
71019: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71020: LD_ADDR_VAR 0 6
71024: PUSH
71025: LD_VAR 0 6
71029: PPUSH
71030: LD_VAR 0 2
71034: PUSH
71035: LD_VAR 0 2
71039: ARRAY
71040: PPUSH
71041: LD_VAR 0 3
71045: PPUSH
71046: CALL_OW 1
71050: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71051: LD_ADDR_VAR 0 7
71055: PUSH
71056: LD_VAR 0 7
71060: PPUSH
71061: LD_VAR 0 7
71065: PPUSH
71066: LD_VAR 0 6
71070: PPUSH
71071: CALL_OW 1
71075: ST_TO_ADDR
// for i = s_arr downto 2 do
71076: LD_ADDR_VAR 0 5
71080: PUSH
71081: DOUBLE
71082: LD_VAR 0 7
71086: INC
71087: ST_TO_ADDR
71088: LD_INT 2
71090: PUSH
71091: FOR_DOWNTO
71092: IFFALSE 71176
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71094: LD_ADDR_VAR 0 6
71098: PUSH
71099: LD_VAR 0 7
71103: PUSH
71104: LD_VAR 0 5
71108: PUSH
71109: LD_INT 1
71111: MINUS
71112: ARRAY
71113: PPUSH
71114: LD_VAR 0 2
71118: PUSH
71119: LD_VAR 0 5
71123: PUSH
71124: LD_INT 1
71126: MINUS
71127: ARRAY
71128: PPUSH
71129: LD_VAR 0 7
71133: PUSH
71134: LD_VAR 0 5
71138: ARRAY
71139: PPUSH
71140: CALL_OW 1
71144: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71145: LD_ADDR_VAR 0 7
71149: PUSH
71150: LD_VAR 0 7
71154: PPUSH
71155: LD_VAR 0 5
71159: PUSH
71160: LD_INT 1
71162: MINUS
71163: PPUSH
71164: LD_VAR 0 6
71168: PPUSH
71169: CALL_OW 1
71173: ST_TO_ADDR
// end ;
71174: GO 71091
71176: POP
71177: POP
// result := s_arr [ 1 ] ;
71178: LD_ADDR_VAR 0 4
71182: PUSH
71183: LD_VAR 0 7
71187: PUSH
71188: LD_INT 1
71190: ARRAY
71191: ST_TO_ADDR
// end ; end ;
71192: LD_VAR 0 4
71196: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71197: LD_INT 0
71199: PPUSH
71200: PPUSH
// if not list then
71201: LD_VAR 0 1
71205: NOT
71206: IFFALSE 71210
// exit ;
71208: GO 71301
// i := list [ pos1 ] ;
71210: LD_ADDR_VAR 0 5
71214: PUSH
71215: LD_VAR 0 1
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: ST_TO_ADDR
// if not i then
71226: LD_VAR 0 5
71230: NOT
71231: IFFALSE 71235
// exit ;
71233: GO 71301
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71235: LD_ADDR_VAR 0 1
71239: PUSH
71240: LD_VAR 0 1
71244: PPUSH
71245: LD_VAR 0 2
71249: PPUSH
71250: LD_VAR 0 1
71254: PUSH
71255: LD_VAR 0 3
71259: ARRAY
71260: PPUSH
71261: CALL_OW 1
71265: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71266: LD_ADDR_VAR 0 1
71270: PUSH
71271: LD_VAR 0 1
71275: PPUSH
71276: LD_VAR 0 3
71280: PPUSH
71281: LD_VAR 0 5
71285: PPUSH
71286: CALL_OW 1
71290: ST_TO_ADDR
// result := list ;
71291: LD_ADDR_VAR 0 4
71295: PUSH
71296: LD_VAR 0 1
71300: ST_TO_ADDR
// end ;
71301: LD_VAR 0 4
71305: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71306: LD_INT 0
71308: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71309: LD_ADDR_VAR 0 5
71313: PUSH
71314: LD_VAR 0 1
71318: PPUSH
71319: CALL_OW 250
71323: PPUSH
71324: LD_VAR 0 1
71328: PPUSH
71329: CALL_OW 251
71333: PPUSH
71334: LD_VAR 0 2
71338: PPUSH
71339: LD_VAR 0 3
71343: PPUSH
71344: LD_VAR 0 4
71348: PPUSH
71349: CALL 71359 0 5
71353: ST_TO_ADDR
// end ;
71354: LD_VAR 0 5
71358: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71359: LD_INT 0
71361: PPUSH
71362: PPUSH
71363: PPUSH
71364: PPUSH
// if not list then
71365: LD_VAR 0 3
71369: NOT
71370: IFFALSE 71374
// exit ;
71372: GO 71762
// result := [ ] ;
71374: LD_ADDR_VAR 0 6
71378: PUSH
71379: EMPTY
71380: ST_TO_ADDR
// for i in list do
71381: LD_ADDR_VAR 0 7
71385: PUSH
71386: LD_VAR 0 3
71390: PUSH
71391: FOR_IN
71392: IFFALSE 71594
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71394: LD_ADDR_VAR 0 9
71398: PUSH
71399: LD_VAR 0 7
71403: PPUSH
71404: LD_VAR 0 1
71408: PPUSH
71409: LD_VAR 0 2
71413: PPUSH
71414: CALL_OW 297
71418: ST_TO_ADDR
// if not result then
71419: LD_VAR 0 6
71423: NOT
71424: IFFALSE 71450
// result := [ [ i , tmp ] ] else
71426: LD_ADDR_VAR 0 6
71430: PUSH
71431: LD_VAR 0 7
71435: PUSH
71436: LD_VAR 0 9
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: EMPTY
71446: LIST
71447: ST_TO_ADDR
71448: GO 71592
// begin if result [ result ] [ 2 ] < tmp then
71450: LD_VAR 0 6
71454: PUSH
71455: LD_VAR 0 6
71459: ARRAY
71460: PUSH
71461: LD_INT 2
71463: ARRAY
71464: PUSH
71465: LD_VAR 0 9
71469: LESS
71470: IFFALSE 71512
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71472: LD_ADDR_VAR 0 6
71476: PUSH
71477: LD_VAR 0 6
71481: PPUSH
71482: LD_VAR 0 6
71486: PUSH
71487: LD_INT 1
71489: PLUS
71490: PPUSH
71491: LD_VAR 0 7
71495: PUSH
71496: LD_VAR 0 9
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PPUSH
71505: CALL_OW 2
71509: ST_TO_ADDR
71510: GO 71592
// for j = 1 to result do
71512: LD_ADDR_VAR 0 8
71516: PUSH
71517: DOUBLE
71518: LD_INT 1
71520: DEC
71521: ST_TO_ADDR
71522: LD_VAR 0 6
71526: PUSH
71527: FOR_TO
71528: IFFALSE 71590
// begin if tmp < result [ j ] [ 2 ] then
71530: LD_VAR 0 9
71534: PUSH
71535: LD_VAR 0 6
71539: PUSH
71540: LD_VAR 0 8
71544: ARRAY
71545: PUSH
71546: LD_INT 2
71548: ARRAY
71549: LESS
71550: IFFALSE 71588
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71552: LD_ADDR_VAR 0 6
71556: PUSH
71557: LD_VAR 0 6
71561: PPUSH
71562: LD_VAR 0 8
71566: PPUSH
71567: LD_VAR 0 7
71571: PUSH
71572: LD_VAR 0 9
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PPUSH
71581: CALL_OW 2
71585: ST_TO_ADDR
// break ;
71586: GO 71590
// end ; end ;
71588: GO 71527
71590: POP
71591: POP
// end ; end ;
71592: GO 71391
71594: POP
71595: POP
// if result and not asc then
71596: LD_VAR 0 6
71600: PUSH
71601: LD_VAR 0 4
71605: NOT
71606: AND
71607: IFFALSE 71682
// begin tmp := result ;
71609: LD_ADDR_VAR 0 9
71613: PUSH
71614: LD_VAR 0 6
71618: ST_TO_ADDR
// for i = tmp downto 1 do
71619: LD_ADDR_VAR 0 7
71623: PUSH
71624: DOUBLE
71625: LD_VAR 0 9
71629: INC
71630: ST_TO_ADDR
71631: LD_INT 1
71633: PUSH
71634: FOR_DOWNTO
71635: IFFALSE 71680
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71637: LD_ADDR_VAR 0 6
71641: PUSH
71642: LD_VAR 0 6
71646: PPUSH
71647: LD_VAR 0 9
71651: PUSH
71652: LD_VAR 0 7
71656: MINUS
71657: PUSH
71658: LD_INT 1
71660: PLUS
71661: PPUSH
71662: LD_VAR 0 9
71666: PUSH
71667: LD_VAR 0 7
71671: ARRAY
71672: PPUSH
71673: CALL_OW 1
71677: ST_TO_ADDR
71678: GO 71634
71680: POP
71681: POP
// end ; tmp := [ ] ;
71682: LD_ADDR_VAR 0 9
71686: PUSH
71687: EMPTY
71688: ST_TO_ADDR
// if mode then
71689: LD_VAR 0 5
71693: IFFALSE 71762
// begin for i = 1 to result do
71695: LD_ADDR_VAR 0 7
71699: PUSH
71700: DOUBLE
71701: LD_INT 1
71703: DEC
71704: ST_TO_ADDR
71705: LD_VAR 0 6
71709: PUSH
71710: FOR_TO
71711: IFFALSE 71750
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71713: LD_ADDR_VAR 0 9
71717: PUSH
71718: LD_VAR 0 9
71722: PPUSH
71723: LD_VAR 0 7
71727: PPUSH
71728: LD_VAR 0 6
71732: PUSH
71733: LD_VAR 0 7
71737: ARRAY
71738: PUSH
71739: LD_INT 1
71741: ARRAY
71742: PPUSH
71743: CALL_OW 1
71747: ST_TO_ADDR
71748: GO 71710
71750: POP
71751: POP
// result := tmp ;
71752: LD_ADDR_VAR 0 6
71756: PUSH
71757: LD_VAR 0 9
71761: ST_TO_ADDR
// end ; end ;
71762: LD_VAR 0 6
71766: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71767: LD_INT 0
71769: PPUSH
71770: PPUSH
71771: PPUSH
71772: PPUSH
71773: PPUSH
71774: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71775: LD_ADDR_VAR 0 5
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: EMPTY
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: ST_TO_ADDR
// if not x or not y then
71797: LD_VAR 0 2
71801: NOT
71802: PUSH
71803: LD_VAR 0 3
71807: NOT
71808: OR
71809: IFFALSE 71813
// exit ;
71811: GO 73465
// if not range then
71813: LD_VAR 0 4
71817: NOT
71818: IFFALSE 71828
// range := 10 ;
71820: LD_ADDR_VAR 0 4
71824: PUSH
71825: LD_INT 10
71827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71828: LD_ADDR_VAR 0 8
71832: PUSH
71833: LD_INT 81
71835: PUSH
71836: LD_VAR 0 1
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 92
71847: PUSH
71848: LD_VAR 0 2
71852: PUSH
71853: LD_VAR 0 3
71857: PUSH
71858: LD_VAR 0 4
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 3
71871: PUSH
71872: LD_INT 21
71874: PUSH
71875: LD_INT 3
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: LIST
71890: PPUSH
71891: CALL_OW 69
71895: ST_TO_ADDR
// if not tmp then
71896: LD_VAR 0 8
71900: NOT
71901: IFFALSE 71905
// exit ;
71903: GO 73465
// for i in tmp do
71905: LD_ADDR_VAR 0 6
71909: PUSH
71910: LD_VAR 0 8
71914: PUSH
71915: FOR_IN
71916: IFFALSE 73440
// begin points := [ 0 , 0 , 0 ] ;
71918: LD_ADDR_VAR 0 9
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 0
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: LIST
71936: ST_TO_ADDR
// bpoints := 1 ;
71937: LD_ADDR_VAR 0 10
71941: PUSH
71942: LD_INT 1
71944: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71945: LD_VAR 0 6
71949: PPUSH
71950: CALL_OW 247
71954: PUSH
71955: LD_INT 1
71957: DOUBLE
71958: EQUAL
71959: IFTRUE 71963
71961: GO 72541
71963: POP
// begin if GetClass ( i ) = 1 then
71964: LD_VAR 0 6
71968: PPUSH
71969: CALL_OW 257
71973: PUSH
71974: LD_INT 1
71976: EQUAL
71977: IFFALSE 71998
// points := [ 10 , 5 , 3 ] ;
71979: LD_ADDR_VAR 0 9
71983: PUSH
71984: LD_INT 10
71986: PUSH
71987: LD_INT 5
71989: PUSH
71990: LD_INT 3
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: LIST
71997: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71998: LD_VAR 0 6
72002: PPUSH
72003: CALL_OW 257
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 3
72013: PUSH
72014: LD_INT 4
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: LIST
72021: IN
72022: IFFALSE 72043
// points := [ 3 , 2 , 1 ] ;
72024: LD_ADDR_VAR 0 9
72028: PUSH
72029: LD_INT 3
72031: PUSH
72032: LD_INT 2
72034: PUSH
72035: LD_INT 1
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: LIST
72042: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72043: LD_VAR 0 6
72047: PPUSH
72048: CALL_OW 257
72052: PUSH
72053: LD_INT 5
72055: EQUAL
72056: IFFALSE 72077
// points := [ 130 , 5 , 2 ] ;
72058: LD_ADDR_VAR 0 9
72062: PUSH
72063: LD_INT 130
72065: PUSH
72066: LD_INT 5
72068: PUSH
72069: LD_INT 2
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: LIST
72076: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72077: LD_VAR 0 6
72081: PPUSH
72082: CALL_OW 257
72086: PUSH
72087: LD_INT 8
72089: EQUAL
72090: IFFALSE 72111
// points := [ 35 , 35 , 30 ] ;
72092: LD_ADDR_VAR 0 9
72096: PUSH
72097: LD_INT 35
72099: PUSH
72100: LD_INT 35
72102: PUSH
72103: LD_INT 30
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72111: LD_VAR 0 6
72115: PPUSH
72116: CALL_OW 257
72120: PUSH
72121: LD_INT 9
72123: EQUAL
72124: IFFALSE 72145
// points := [ 20 , 55 , 40 ] ;
72126: LD_ADDR_VAR 0 9
72130: PUSH
72131: LD_INT 20
72133: PUSH
72134: LD_INT 55
72136: PUSH
72137: LD_INT 40
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: LIST
72144: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72145: LD_VAR 0 6
72149: PPUSH
72150: CALL_OW 257
72154: PUSH
72155: LD_INT 12
72157: PUSH
72158: LD_INT 16
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: IN
72165: IFFALSE 72186
// points := [ 5 , 3 , 2 ] ;
72167: LD_ADDR_VAR 0 9
72171: PUSH
72172: LD_INT 5
72174: PUSH
72175: LD_INT 3
72177: PUSH
72178: LD_INT 2
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: LIST
72185: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72186: LD_VAR 0 6
72190: PPUSH
72191: CALL_OW 257
72195: PUSH
72196: LD_INT 17
72198: EQUAL
72199: IFFALSE 72220
// points := [ 100 , 50 , 75 ] ;
72201: LD_ADDR_VAR 0 9
72205: PUSH
72206: LD_INT 100
72208: PUSH
72209: LD_INT 50
72211: PUSH
72212: LD_INT 75
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: LIST
72219: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72220: LD_VAR 0 6
72224: PPUSH
72225: CALL_OW 257
72229: PUSH
72230: LD_INT 15
72232: EQUAL
72233: IFFALSE 72254
// points := [ 10 , 5 , 3 ] ;
72235: LD_ADDR_VAR 0 9
72239: PUSH
72240: LD_INT 10
72242: PUSH
72243: LD_INT 5
72245: PUSH
72246: LD_INT 3
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: LIST
72253: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72254: LD_VAR 0 6
72258: PPUSH
72259: CALL_OW 257
72263: PUSH
72264: LD_INT 14
72266: EQUAL
72267: IFFALSE 72288
// points := [ 10 , 0 , 0 ] ;
72269: LD_ADDR_VAR 0 9
72273: PUSH
72274: LD_INT 10
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: LIST
72287: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72288: LD_VAR 0 6
72292: PPUSH
72293: CALL_OW 257
72297: PUSH
72298: LD_INT 11
72300: EQUAL
72301: IFFALSE 72322
// points := [ 30 , 10 , 5 ] ;
72303: LD_ADDR_VAR 0 9
72307: PUSH
72308: LD_INT 30
72310: PUSH
72311: LD_INT 10
72313: PUSH
72314: LD_INT 5
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: LIST
72321: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72322: LD_VAR 0 1
72326: PPUSH
72327: LD_INT 5
72329: PPUSH
72330: CALL_OW 321
72334: PUSH
72335: LD_INT 2
72337: EQUAL
72338: IFFALSE 72355
// bpoints := bpoints * 1.8 ;
72340: LD_ADDR_VAR 0 10
72344: PUSH
72345: LD_VAR 0 10
72349: PUSH
72350: LD_REAL  1.80000000000000E+0000
72353: MUL
72354: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72355: LD_VAR 0 6
72359: PPUSH
72360: CALL_OW 257
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: LD_INT 3
72373: PUSH
72374: LD_INT 4
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: IN
72383: PUSH
72384: LD_VAR 0 1
72388: PPUSH
72389: LD_INT 51
72391: PPUSH
72392: CALL_OW 321
72396: PUSH
72397: LD_INT 2
72399: EQUAL
72400: AND
72401: IFFALSE 72418
// bpoints := bpoints * 1.2 ;
72403: LD_ADDR_VAR 0 10
72407: PUSH
72408: LD_VAR 0 10
72412: PUSH
72413: LD_REAL  1.20000000000000E+0000
72416: MUL
72417: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72418: LD_VAR 0 6
72422: PPUSH
72423: CALL_OW 257
72427: PUSH
72428: LD_INT 5
72430: PUSH
72431: LD_INT 7
72433: PUSH
72434: LD_INT 9
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: IN
72442: PUSH
72443: LD_VAR 0 1
72447: PPUSH
72448: LD_INT 52
72450: PPUSH
72451: CALL_OW 321
72455: PUSH
72456: LD_INT 2
72458: EQUAL
72459: AND
72460: IFFALSE 72477
// bpoints := bpoints * 1.5 ;
72462: LD_ADDR_VAR 0 10
72466: PUSH
72467: LD_VAR 0 10
72471: PUSH
72472: LD_REAL  1.50000000000000E+0000
72475: MUL
72476: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72477: LD_VAR 0 1
72481: PPUSH
72482: LD_INT 66
72484: PPUSH
72485: CALL_OW 321
72489: PUSH
72490: LD_INT 2
72492: EQUAL
72493: IFFALSE 72510
// bpoints := bpoints * 1.1 ;
72495: LD_ADDR_VAR 0 10
72499: PUSH
72500: LD_VAR 0 10
72504: PUSH
72505: LD_REAL  1.10000000000000E+0000
72508: MUL
72509: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72510: LD_ADDR_VAR 0 10
72514: PUSH
72515: LD_VAR 0 10
72519: PUSH
72520: LD_VAR 0 6
72524: PPUSH
72525: LD_INT 1
72527: PPUSH
72528: CALL_OW 259
72532: PUSH
72533: LD_REAL  1.15000000000000E+0000
72536: MUL
72537: MUL
72538: ST_TO_ADDR
// end ; unit_vehicle :
72539: GO 73369
72541: LD_INT 2
72543: DOUBLE
72544: EQUAL
72545: IFTRUE 72549
72547: GO 73357
72549: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72550: LD_VAR 0 6
72554: PPUSH
72555: CALL_OW 264
72559: PUSH
72560: LD_INT 2
72562: PUSH
72563: LD_INT 42
72565: PUSH
72566: LD_INT 24
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: LIST
72573: IN
72574: IFFALSE 72595
// points := [ 25 , 5 , 3 ] ;
72576: LD_ADDR_VAR 0 9
72580: PUSH
72581: LD_INT 25
72583: PUSH
72584: LD_INT 5
72586: PUSH
72587: LD_INT 3
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: LIST
72594: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72595: LD_VAR 0 6
72599: PPUSH
72600: CALL_OW 264
72604: PUSH
72605: LD_INT 4
72607: PUSH
72608: LD_INT 43
72610: PUSH
72611: LD_INT 25
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: LIST
72618: IN
72619: IFFALSE 72640
// points := [ 40 , 15 , 5 ] ;
72621: LD_ADDR_VAR 0 9
72625: PUSH
72626: LD_INT 40
72628: PUSH
72629: LD_INT 15
72631: PUSH
72632: LD_INT 5
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: LIST
72639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72640: LD_VAR 0 6
72644: PPUSH
72645: CALL_OW 264
72649: PUSH
72650: LD_INT 3
72652: PUSH
72653: LD_INT 23
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: IN
72660: IFFALSE 72681
// points := [ 7 , 25 , 8 ] ;
72662: LD_ADDR_VAR 0 9
72666: PUSH
72667: LD_INT 7
72669: PUSH
72670: LD_INT 25
72672: PUSH
72673: LD_INT 8
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: LIST
72680: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72681: LD_VAR 0 6
72685: PPUSH
72686: CALL_OW 264
72690: PUSH
72691: LD_INT 5
72693: PUSH
72694: LD_INT 27
72696: PUSH
72697: LD_INT 44
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: LIST
72704: IN
72705: IFFALSE 72726
// points := [ 14 , 50 , 16 ] ;
72707: LD_ADDR_VAR 0 9
72711: PUSH
72712: LD_INT 14
72714: PUSH
72715: LD_INT 50
72717: PUSH
72718: LD_INT 16
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: LIST
72725: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72726: LD_VAR 0 6
72730: PPUSH
72731: CALL_OW 264
72735: PUSH
72736: LD_INT 6
72738: PUSH
72739: LD_INT 46
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: IN
72746: IFFALSE 72767
// points := [ 32 , 120 , 70 ] ;
72748: LD_ADDR_VAR 0 9
72752: PUSH
72753: LD_INT 32
72755: PUSH
72756: LD_INT 120
72758: PUSH
72759: LD_INT 70
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: LIST
72766: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72767: LD_VAR 0 6
72771: PPUSH
72772: CALL_OW 264
72776: PUSH
72777: LD_INT 7
72779: PUSH
72780: LD_INT 28
72782: PUSH
72783: LD_INT 45
72785: PUSH
72786: LD_EXP 100
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: IN
72797: IFFALSE 72818
// points := [ 35 , 20 , 45 ] ;
72799: LD_ADDR_VAR 0 9
72803: PUSH
72804: LD_INT 35
72806: PUSH
72807: LD_INT 20
72809: PUSH
72810: LD_INT 45
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72818: LD_VAR 0 6
72822: PPUSH
72823: CALL_OW 264
72827: PUSH
72828: LD_INT 47
72830: PUSH
72831: EMPTY
72832: LIST
72833: IN
72834: IFFALSE 72855
// points := [ 67 , 45 , 75 ] ;
72836: LD_ADDR_VAR 0 9
72840: PUSH
72841: LD_INT 67
72843: PUSH
72844: LD_INT 45
72846: PUSH
72847: LD_INT 75
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: LIST
72854: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72855: LD_VAR 0 6
72859: PPUSH
72860: CALL_OW 264
72864: PUSH
72865: LD_INT 26
72867: PUSH
72868: EMPTY
72869: LIST
72870: IN
72871: IFFALSE 72892
// points := [ 120 , 30 , 80 ] ;
72873: LD_ADDR_VAR 0 9
72877: PUSH
72878: LD_INT 120
72880: PUSH
72881: LD_INT 30
72883: PUSH
72884: LD_INT 80
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: LIST
72891: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72892: LD_VAR 0 6
72896: PPUSH
72897: CALL_OW 264
72901: PUSH
72902: LD_INT 22
72904: PUSH
72905: EMPTY
72906: LIST
72907: IN
72908: IFFALSE 72929
// points := [ 40 , 1 , 1 ] ;
72910: LD_ADDR_VAR 0 9
72914: PUSH
72915: LD_INT 40
72917: PUSH
72918: LD_INT 1
72920: PUSH
72921: LD_INT 1
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: LIST
72928: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72929: LD_VAR 0 6
72933: PPUSH
72934: CALL_OW 264
72938: PUSH
72939: LD_INT 29
72941: PUSH
72942: EMPTY
72943: LIST
72944: IN
72945: IFFALSE 72966
// points := [ 70 , 200 , 400 ] ;
72947: LD_ADDR_VAR 0 9
72951: PUSH
72952: LD_INT 70
72954: PUSH
72955: LD_INT 200
72957: PUSH
72958: LD_INT 400
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: LIST
72965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72966: LD_VAR 0 6
72970: PPUSH
72971: CALL_OW 264
72975: PUSH
72976: LD_INT 14
72978: PUSH
72979: LD_INT 53
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: IN
72986: IFFALSE 73007
// points := [ 40 , 10 , 20 ] ;
72988: LD_ADDR_VAR 0 9
72992: PUSH
72993: LD_INT 40
72995: PUSH
72996: LD_INT 10
72998: PUSH
72999: LD_INT 20
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: LIST
73006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73007: LD_VAR 0 6
73011: PPUSH
73012: CALL_OW 264
73016: PUSH
73017: LD_INT 9
73019: PUSH
73020: EMPTY
73021: LIST
73022: IN
73023: IFFALSE 73044
// points := [ 5 , 70 , 20 ] ;
73025: LD_ADDR_VAR 0 9
73029: PUSH
73030: LD_INT 5
73032: PUSH
73033: LD_INT 70
73035: PUSH
73036: LD_INT 20
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: LIST
73043: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73044: LD_VAR 0 6
73048: PPUSH
73049: CALL_OW 264
73053: PUSH
73054: LD_INT 10
73056: PUSH
73057: EMPTY
73058: LIST
73059: IN
73060: IFFALSE 73081
// points := [ 35 , 110 , 70 ] ;
73062: LD_ADDR_VAR 0 9
73066: PUSH
73067: LD_INT 35
73069: PUSH
73070: LD_INT 110
73072: PUSH
73073: LD_INT 70
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73081: LD_VAR 0 6
73085: PPUSH
73086: CALL_OW 265
73090: PUSH
73091: LD_INT 25
73093: EQUAL
73094: IFFALSE 73115
// points := [ 80 , 65 , 100 ] ;
73096: LD_ADDR_VAR 0 9
73100: PUSH
73101: LD_INT 80
73103: PUSH
73104: LD_INT 65
73106: PUSH
73107: LD_INT 100
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: LIST
73114: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73115: LD_VAR 0 6
73119: PPUSH
73120: CALL_OW 263
73124: PUSH
73125: LD_INT 1
73127: EQUAL
73128: IFFALSE 73163
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73130: LD_ADDR_VAR 0 10
73134: PUSH
73135: LD_VAR 0 10
73139: PUSH
73140: LD_VAR 0 6
73144: PPUSH
73145: CALL_OW 311
73149: PPUSH
73150: LD_INT 3
73152: PPUSH
73153: CALL_OW 259
73157: PUSH
73158: LD_INT 4
73160: MUL
73161: MUL
73162: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73163: LD_VAR 0 6
73167: PPUSH
73168: CALL_OW 263
73172: PUSH
73173: LD_INT 2
73175: EQUAL
73176: IFFALSE 73227
// begin j := IsControledBy ( i ) ;
73178: LD_ADDR_VAR 0 7
73182: PUSH
73183: LD_VAR 0 6
73187: PPUSH
73188: CALL_OW 312
73192: ST_TO_ADDR
// if j then
73193: LD_VAR 0 7
73197: IFFALSE 73227
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73199: LD_ADDR_VAR 0 10
73203: PUSH
73204: LD_VAR 0 10
73208: PUSH
73209: LD_VAR 0 7
73213: PPUSH
73214: LD_INT 3
73216: PPUSH
73217: CALL_OW 259
73221: PUSH
73222: LD_INT 3
73224: MUL
73225: MUL
73226: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73227: LD_VAR 0 6
73231: PPUSH
73232: CALL_OW 264
73236: PUSH
73237: LD_INT 5
73239: PUSH
73240: LD_INT 6
73242: PUSH
73243: LD_INT 46
73245: PUSH
73246: LD_INT 44
73248: PUSH
73249: LD_INT 47
73251: PUSH
73252: LD_INT 45
73254: PUSH
73255: LD_INT 28
73257: PUSH
73258: LD_INT 7
73260: PUSH
73261: LD_INT 27
73263: PUSH
73264: LD_INT 29
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: IN
73279: PUSH
73280: LD_VAR 0 1
73284: PPUSH
73285: LD_INT 52
73287: PPUSH
73288: CALL_OW 321
73292: PUSH
73293: LD_INT 2
73295: EQUAL
73296: AND
73297: IFFALSE 73314
// bpoints := bpoints * 1.2 ;
73299: LD_ADDR_VAR 0 10
73303: PUSH
73304: LD_VAR 0 10
73308: PUSH
73309: LD_REAL  1.20000000000000E+0000
73312: MUL
73313: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73314: LD_VAR 0 6
73318: PPUSH
73319: CALL_OW 264
73323: PUSH
73324: LD_INT 6
73326: PUSH
73327: LD_INT 46
73329: PUSH
73330: LD_INT 47
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: LIST
73337: IN
73338: IFFALSE 73355
// bpoints := bpoints * 1.2 ;
73340: LD_ADDR_VAR 0 10
73344: PUSH
73345: LD_VAR 0 10
73349: PUSH
73350: LD_REAL  1.20000000000000E+0000
73353: MUL
73354: ST_TO_ADDR
// end ; unit_building :
73355: GO 73369
73357: LD_INT 3
73359: DOUBLE
73360: EQUAL
73361: IFTRUE 73365
73363: GO 73368
73365: POP
// ; end ;
73366: GO 73369
73368: POP
// for j = 1 to 3 do
73369: LD_ADDR_VAR 0 7
73373: PUSH
73374: DOUBLE
73375: LD_INT 1
73377: DEC
73378: ST_TO_ADDR
73379: LD_INT 3
73381: PUSH
73382: FOR_TO
73383: IFFALSE 73436
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73385: LD_ADDR_VAR 0 5
73389: PUSH
73390: LD_VAR 0 5
73394: PPUSH
73395: LD_VAR 0 7
73399: PPUSH
73400: LD_VAR 0 5
73404: PUSH
73405: LD_VAR 0 7
73409: ARRAY
73410: PUSH
73411: LD_VAR 0 9
73415: PUSH
73416: LD_VAR 0 7
73420: ARRAY
73421: PUSH
73422: LD_VAR 0 10
73426: MUL
73427: PLUS
73428: PPUSH
73429: CALL_OW 1
73433: ST_TO_ADDR
73434: GO 73382
73436: POP
73437: POP
// end ;
73438: GO 71915
73440: POP
73441: POP
// result := Replace ( result , 4 , tmp ) ;
73442: LD_ADDR_VAR 0 5
73446: PUSH
73447: LD_VAR 0 5
73451: PPUSH
73452: LD_INT 4
73454: PPUSH
73455: LD_VAR 0 8
73459: PPUSH
73460: CALL_OW 1
73464: ST_TO_ADDR
// end ;
73465: LD_VAR 0 5
73469: RET
// export function DangerAtRange ( unit , range ) ; begin
73470: LD_INT 0
73472: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73473: LD_ADDR_VAR 0 3
73477: PUSH
73478: LD_VAR 0 1
73482: PPUSH
73483: CALL_OW 255
73487: PPUSH
73488: LD_VAR 0 1
73492: PPUSH
73493: CALL_OW 250
73497: PPUSH
73498: LD_VAR 0 1
73502: PPUSH
73503: CALL_OW 251
73507: PPUSH
73508: LD_VAR 0 2
73512: PPUSH
73513: CALL 71767 0 4
73517: ST_TO_ADDR
// end ;
73518: LD_VAR 0 3
73522: RET
// export function DangerInArea ( side , area ) ; begin
73523: LD_INT 0
73525: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73526: LD_ADDR_VAR 0 3
73530: PUSH
73531: LD_VAR 0 2
73535: PPUSH
73536: LD_INT 81
73538: PUSH
73539: LD_VAR 0 1
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PPUSH
73548: CALL_OW 70
73552: ST_TO_ADDR
// end ;
73553: LD_VAR 0 3
73557: RET
// export function IsExtension ( b ) ; begin
73558: LD_INT 0
73560: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73561: LD_ADDR_VAR 0 2
73565: PUSH
73566: LD_VAR 0 1
73570: PUSH
73571: LD_INT 23
73573: PUSH
73574: LD_INT 20
73576: PUSH
73577: LD_INT 22
73579: PUSH
73580: LD_INT 17
73582: PUSH
73583: LD_INT 24
73585: PUSH
73586: LD_INT 21
73588: PUSH
73589: LD_INT 19
73591: PUSH
73592: LD_INT 16
73594: PUSH
73595: LD_INT 25
73597: PUSH
73598: LD_INT 18
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: IN
73613: ST_TO_ADDR
// end ;
73614: LD_VAR 0 2
73618: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73619: LD_INT 0
73621: PPUSH
73622: PPUSH
73623: PPUSH
// result := [ ] ;
73624: LD_ADDR_VAR 0 4
73628: PUSH
73629: EMPTY
73630: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73631: LD_ADDR_VAR 0 5
73635: PUSH
73636: LD_VAR 0 2
73640: PPUSH
73641: LD_INT 21
73643: PUSH
73644: LD_INT 3
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PPUSH
73651: CALL_OW 70
73655: ST_TO_ADDR
// if not tmp then
73656: LD_VAR 0 5
73660: NOT
73661: IFFALSE 73665
// exit ;
73663: GO 73729
// if checkLink then
73665: LD_VAR 0 3
73669: IFFALSE 73719
// begin for i in tmp do
73671: LD_ADDR_VAR 0 6
73675: PUSH
73676: LD_VAR 0 5
73680: PUSH
73681: FOR_IN
73682: IFFALSE 73717
// if GetBase ( i ) <> base then
73684: LD_VAR 0 6
73688: PPUSH
73689: CALL_OW 274
73693: PUSH
73694: LD_VAR 0 1
73698: NONEQUAL
73699: IFFALSE 73715
// ComLinkToBase ( base , i ) ;
73701: LD_VAR 0 1
73705: PPUSH
73706: LD_VAR 0 6
73710: PPUSH
73711: CALL_OW 169
73715: GO 73681
73717: POP
73718: POP
// end ; result := tmp ;
73719: LD_ADDR_VAR 0 4
73723: PUSH
73724: LD_VAR 0 5
73728: ST_TO_ADDR
// end ;
73729: LD_VAR 0 4
73733: RET
// export function ComComplete ( units , b ) ; var i ; begin
73734: LD_INT 0
73736: PPUSH
73737: PPUSH
// if not units then
73738: LD_VAR 0 1
73742: NOT
73743: IFFALSE 73747
// exit ;
73745: GO 73837
// for i in units do
73747: LD_ADDR_VAR 0 4
73751: PUSH
73752: LD_VAR 0 1
73756: PUSH
73757: FOR_IN
73758: IFFALSE 73835
// if BuildingStatus ( b ) = bs_build then
73760: LD_VAR 0 2
73764: PPUSH
73765: CALL_OW 461
73769: PUSH
73770: LD_INT 1
73772: EQUAL
73773: IFFALSE 73833
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73775: LD_VAR 0 4
73779: PPUSH
73780: LD_STRING h
73782: PUSH
73783: LD_VAR 0 2
73787: PPUSH
73788: CALL_OW 250
73792: PUSH
73793: LD_VAR 0 2
73797: PPUSH
73798: CALL_OW 251
73802: PUSH
73803: LD_VAR 0 2
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: LD_INT 0
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: PUSH
73826: EMPTY
73827: LIST
73828: PPUSH
73829: CALL_OW 446
73833: GO 73757
73835: POP
73836: POP
// end ;
73837: LD_VAR 0 3
73841: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73842: LD_INT 0
73844: PPUSH
73845: PPUSH
73846: PPUSH
73847: PPUSH
73848: PPUSH
73849: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73850: LD_VAR 0 1
73854: NOT
73855: PUSH
73856: LD_VAR 0 1
73860: PPUSH
73861: CALL_OW 263
73865: PUSH
73866: LD_INT 2
73868: NONEQUAL
73869: OR
73870: IFFALSE 73874
// exit ;
73872: GO 74190
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73874: LD_ADDR_VAR 0 6
73878: PUSH
73879: LD_INT 22
73881: PUSH
73882: LD_VAR 0 1
73886: PPUSH
73887: CALL_OW 255
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 2
73898: PUSH
73899: LD_INT 30
73901: PUSH
73902: LD_INT 36
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 34
73911: PUSH
73912: LD_INT 31
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: LIST
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PPUSH
73928: CALL_OW 69
73932: ST_TO_ADDR
// if not tmp then
73933: LD_VAR 0 6
73937: NOT
73938: IFFALSE 73942
// exit ;
73940: GO 74190
// result := [ ] ;
73942: LD_ADDR_VAR 0 2
73946: PUSH
73947: EMPTY
73948: ST_TO_ADDR
// for i in tmp do
73949: LD_ADDR_VAR 0 3
73953: PUSH
73954: LD_VAR 0 6
73958: PUSH
73959: FOR_IN
73960: IFFALSE 74031
// begin t := UnitsInside ( i ) ;
73962: LD_ADDR_VAR 0 4
73966: PUSH
73967: LD_VAR 0 3
73971: PPUSH
73972: CALL_OW 313
73976: ST_TO_ADDR
// if t then
73977: LD_VAR 0 4
73981: IFFALSE 74029
// for j in t do
73983: LD_ADDR_VAR 0 7
73987: PUSH
73988: LD_VAR 0 4
73992: PUSH
73993: FOR_IN
73994: IFFALSE 74027
// result := Replace ( result , result + 1 , j ) ;
73996: LD_ADDR_VAR 0 2
74000: PUSH
74001: LD_VAR 0 2
74005: PPUSH
74006: LD_VAR 0 2
74010: PUSH
74011: LD_INT 1
74013: PLUS
74014: PPUSH
74015: LD_VAR 0 7
74019: PPUSH
74020: CALL_OW 1
74024: ST_TO_ADDR
74025: GO 73993
74027: POP
74028: POP
// end ;
74029: GO 73959
74031: POP
74032: POP
// if not result then
74033: LD_VAR 0 2
74037: NOT
74038: IFFALSE 74042
// exit ;
74040: GO 74190
// mech := result [ 1 ] ;
74042: LD_ADDR_VAR 0 5
74046: PUSH
74047: LD_VAR 0 2
74051: PUSH
74052: LD_INT 1
74054: ARRAY
74055: ST_TO_ADDR
// if result > 1 then
74056: LD_VAR 0 2
74060: PUSH
74061: LD_INT 1
74063: GREATER
74064: IFFALSE 74176
// begin for i = 2 to result do
74066: LD_ADDR_VAR 0 3
74070: PUSH
74071: DOUBLE
74072: LD_INT 2
74074: DEC
74075: ST_TO_ADDR
74076: LD_VAR 0 2
74080: PUSH
74081: FOR_TO
74082: IFFALSE 74174
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74084: LD_ADDR_VAR 0 4
74088: PUSH
74089: LD_VAR 0 2
74093: PUSH
74094: LD_VAR 0 3
74098: ARRAY
74099: PPUSH
74100: LD_INT 3
74102: PPUSH
74103: CALL_OW 259
74107: PUSH
74108: LD_VAR 0 2
74112: PUSH
74113: LD_VAR 0 3
74117: ARRAY
74118: PPUSH
74119: CALL_OW 432
74123: MINUS
74124: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74125: LD_VAR 0 4
74129: PUSH
74130: LD_VAR 0 5
74134: PPUSH
74135: LD_INT 3
74137: PPUSH
74138: CALL_OW 259
74142: PUSH
74143: LD_VAR 0 5
74147: PPUSH
74148: CALL_OW 432
74152: MINUS
74153: GREATEREQUAL
74154: IFFALSE 74172
// mech := result [ i ] ;
74156: LD_ADDR_VAR 0 5
74160: PUSH
74161: LD_VAR 0 2
74165: PUSH
74166: LD_VAR 0 3
74170: ARRAY
74171: ST_TO_ADDR
// end ;
74172: GO 74081
74174: POP
74175: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74176: LD_VAR 0 1
74180: PPUSH
74181: LD_VAR 0 5
74185: PPUSH
74186: CALL_OW 135
// end ;
74190: LD_VAR 0 2
74194: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74195: LD_INT 0
74197: PPUSH
74198: PPUSH
74199: PPUSH
74200: PPUSH
74201: PPUSH
74202: PPUSH
74203: PPUSH
74204: PPUSH
74205: PPUSH
74206: PPUSH
74207: PPUSH
74208: PPUSH
74209: PPUSH
// result := [ ] ;
74210: LD_ADDR_VAR 0 7
74214: PUSH
74215: EMPTY
74216: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74217: LD_VAR 0 1
74221: PPUSH
74222: CALL_OW 266
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: LD_INT 1
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: IN
74237: NOT
74238: IFFALSE 74242
// exit ;
74240: GO 75876
// if name then
74242: LD_VAR 0 3
74246: IFFALSE 74262
// SetBName ( base_dep , name ) ;
74248: LD_VAR 0 1
74252: PPUSH
74253: LD_VAR 0 3
74257: PPUSH
74258: CALL_OW 500
// base := GetBase ( base_dep ) ;
74262: LD_ADDR_VAR 0 15
74266: PUSH
74267: LD_VAR 0 1
74271: PPUSH
74272: CALL_OW 274
74276: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74277: LD_ADDR_VAR 0 16
74281: PUSH
74282: LD_VAR 0 1
74286: PPUSH
74287: CALL_OW 255
74291: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74292: LD_ADDR_VAR 0 17
74296: PUSH
74297: LD_VAR 0 1
74301: PPUSH
74302: CALL_OW 248
74306: ST_TO_ADDR
// if sources then
74307: LD_VAR 0 5
74311: IFFALSE 74358
// for i = 1 to 3 do
74313: LD_ADDR_VAR 0 8
74317: PUSH
74318: DOUBLE
74319: LD_INT 1
74321: DEC
74322: ST_TO_ADDR
74323: LD_INT 3
74325: PUSH
74326: FOR_TO
74327: IFFALSE 74356
// AddResourceType ( base , i , sources [ i ] ) ;
74329: LD_VAR 0 15
74333: PPUSH
74334: LD_VAR 0 8
74338: PPUSH
74339: LD_VAR 0 5
74343: PUSH
74344: LD_VAR 0 8
74348: ARRAY
74349: PPUSH
74350: CALL_OW 276
74354: GO 74326
74356: POP
74357: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74358: LD_ADDR_VAR 0 18
74362: PUSH
74363: LD_VAR 0 15
74367: PPUSH
74368: LD_VAR 0 2
74372: PPUSH
74373: LD_INT 1
74375: PPUSH
74376: CALL 73619 0 3
74380: ST_TO_ADDR
// InitHc ;
74381: CALL_OW 19
// InitUc ;
74385: CALL_OW 18
// uc_side := side ;
74389: LD_ADDR_OWVAR 20
74393: PUSH
74394: LD_VAR 0 16
74398: ST_TO_ADDR
// uc_nation := nation ;
74399: LD_ADDR_OWVAR 21
74403: PUSH
74404: LD_VAR 0 17
74408: ST_TO_ADDR
// if buildings then
74409: LD_VAR 0 18
74413: IFFALSE 75735
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74415: LD_ADDR_VAR 0 19
74419: PUSH
74420: LD_VAR 0 18
74424: PPUSH
74425: LD_INT 2
74427: PUSH
74428: LD_INT 30
74430: PUSH
74431: LD_INT 29
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 30
74440: PUSH
74441: LD_INT 30
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: LIST
74452: PPUSH
74453: CALL_OW 72
74457: ST_TO_ADDR
// if tmp then
74458: LD_VAR 0 19
74462: IFFALSE 74510
// for i in tmp do
74464: LD_ADDR_VAR 0 8
74468: PUSH
74469: LD_VAR 0 19
74473: PUSH
74474: FOR_IN
74475: IFFALSE 74508
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74477: LD_VAR 0 8
74481: PPUSH
74482: CALL_OW 250
74486: PPUSH
74487: LD_VAR 0 8
74491: PPUSH
74492: CALL_OW 251
74496: PPUSH
74497: LD_VAR 0 16
74501: PPUSH
74502: CALL_OW 441
74506: GO 74474
74508: POP
74509: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74510: LD_VAR 0 18
74514: PPUSH
74515: LD_INT 2
74517: PUSH
74518: LD_INT 30
74520: PUSH
74521: LD_INT 32
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 30
74530: PUSH
74531: LD_INT 33
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: LIST
74542: PPUSH
74543: CALL_OW 72
74547: IFFALSE 74635
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74549: LD_ADDR_VAR 0 8
74553: PUSH
74554: LD_VAR 0 18
74558: PPUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 30
74564: PUSH
74565: LD_INT 32
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 30
74574: PUSH
74575: LD_INT 33
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: LIST
74586: PPUSH
74587: CALL_OW 72
74591: PUSH
74592: FOR_IN
74593: IFFALSE 74633
// begin if not GetBWeapon ( i ) then
74595: LD_VAR 0 8
74599: PPUSH
74600: CALL_OW 269
74604: NOT
74605: IFFALSE 74631
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74607: LD_VAR 0 8
74611: PPUSH
74612: LD_VAR 0 8
74616: PPUSH
74617: LD_VAR 0 2
74621: PPUSH
74622: CALL 75881 0 2
74626: PPUSH
74627: CALL_OW 431
// end ;
74631: GO 74592
74633: POP
74634: POP
// end ; for i = 1 to personel do
74635: LD_ADDR_VAR 0 8
74639: PUSH
74640: DOUBLE
74641: LD_INT 1
74643: DEC
74644: ST_TO_ADDR
74645: LD_VAR 0 6
74649: PUSH
74650: FOR_TO
74651: IFFALSE 75715
// begin if i > 4 then
74653: LD_VAR 0 8
74657: PUSH
74658: LD_INT 4
74660: GREATER
74661: IFFALSE 74665
// break ;
74663: GO 75715
// case i of 1 :
74665: LD_VAR 0 8
74669: PUSH
74670: LD_INT 1
74672: DOUBLE
74673: EQUAL
74674: IFTRUE 74678
74676: GO 74758
74678: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74679: LD_ADDR_VAR 0 12
74683: PUSH
74684: LD_VAR 0 18
74688: PPUSH
74689: LD_INT 22
74691: PUSH
74692: LD_VAR 0 16
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 58
74703: PUSH
74704: EMPTY
74705: LIST
74706: PUSH
74707: LD_INT 2
74709: PUSH
74710: LD_INT 30
74712: PUSH
74713: LD_INT 32
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 30
74722: PUSH
74723: LD_INT 4
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 30
74732: PUSH
74733: LD_INT 5
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: LIST
74750: PPUSH
74751: CALL_OW 72
74755: ST_TO_ADDR
74756: GO 74980
74758: LD_INT 2
74760: DOUBLE
74761: EQUAL
74762: IFTRUE 74766
74764: GO 74828
74766: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74767: LD_ADDR_VAR 0 12
74771: PUSH
74772: LD_VAR 0 18
74776: PPUSH
74777: LD_INT 22
74779: PUSH
74780: LD_VAR 0 16
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 2
74791: PUSH
74792: LD_INT 30
74794: PUSH
74795: LD_INT 0
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 30
74804: PUSH
74805: LD_INT 1
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: LIST
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PPUSH
74821: CALL_OW 72
74825: ST_TO_ADDR
74826: GO 74980
74828: LD_INT 3
74830: DOUBLE
74831: EQUAL
74832: IFTRUE 74836
74834: GO 74898
74836: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74837: LD_ADDR_VAR 0 12
74841: PUSH
74842: LD_VAR 0 18
74846: PPUSH
74847: LD_INT 22
74849: PUSH
74850: LD_VAR 0 16
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 2
74861: PUSH
74862: LD_INT 30
74864: PUSH
74865: LD_INT 2
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 30
74874: PUSH
74875: LD_INT 3
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PPUSH
74891: CALL_OW 72
74895: ST_TO_ADDR
74896: GO 74980
74898: LD_INT 4
74900: DOUBLE
74901: EQUAL
74902: IFTRUE 74906
74904: GO 74979
74906: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74907: LD_ADDR_VAR 0 12
74911: PUSH
74912: LD_VAR 0 18
74916: PPUSH
74917: LD_INT 22
74919: PUSH
74920: LD_VAR 0 16
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: PUSH
74932: LD_INT 30
74934: PUSH
74935: LD_INT 6
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: LD_INT 30
74944: PUSH
74945: LD_INT 7
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 30
74954: PUSH
74955: LD_INT 8
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PPUSH
74972: CALL_OW 72
74976: ST_TO_ADDR
74977: GO 74980
74979: POP
// if i = 1 then
74980: LD_VAR 0 8
74984: PUSH
74985: LD_INT 1
74987: EQUAL
74988: IFFALSE 75099
// begin tmp := [ ] ;
74990: LD_ADDR_VAR 0 19
74994: PUSH
74995: EMPTY
74996: ST_TO_ADDR
// for j in f do
74997: LD_ADDR_VAR 0 9
75001: PUSH
75002: LD_VAR 0 12
75006: PUSH
75007: FOR_IN
75008: IFFALSE 75081
// if GetBType ( j ) = b_bunker then
75010: LD_VAR 0 9
75014: PPUSH
75015: CALL_OW 266
75019: PUSH
75020: LD_INT 32
75022: EQUAL
75023: IFFALSE 75050
// tmp := Insert ( tmp , 1 , j ) else
75025: LD_ADDR_VAR 0 19
75029: PUSH
75030: LD_VAR 0 19
75034: PPUSH
75035: LD_INT 1
75037: PPUSH
75038: LD_VAR 0 9
75042: PPUSH
75043: CALL_OW 2
75047: ST_TO_ADDR
75048: GO 75079
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75050: LD_ADDR_VAR 0 19
75054: PUSH
75055: LD_VAR 0 19
75059: PPUSH
75060: LD_VAR 0 19
75064: PUSH
75065: LD_INT 1
75067: PLUS
75068: PPUSH
75069: LD_VAR 0 9
75073: PPUSH
75074: CALL_OW 2
75078: ST_TO_ADDR
75079: GO 75007
75081: POP
75082: POP
// if tmp then
75083: LD_VAR 0 19
75087: IFFALSE 75099
// f := tmp ;
75089: LD_ADDR_VAR 0 12
75093: PUSH
75094: LD_VAR 0 19
75098: ST_TO_ADDR
// end ; x := personel [ i ] ;
75099: LD_ADDR_VAR 0 13
75103: PUSH
75104: LD_VAR 0 6
75108: PUSH
75109: LD_VAR 0 8
75113: ARRAY
75114: ST_TO_ADDR
// if x = - 1 then
75115: LD_VAR 0 13
75119: PUSH
75120: LD_INT 1
75122: NEG
75123: EQUAL
75124: IFFALSE 75333
// begin for j in f do
75126: LD_ADDR_VAR 0 9
75130: PUSH
75131: LD_VAR 0 12
75135: PUSH
75136: FOR_IN
75137: IFFALSE 75329
// repeat InitHc ;
75139: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75143: LD_VAR 0 9
75147: PPUSH
75148: CALL_OW 266
75152: PUSH
75153: LD_INT 5
75155: EQUAL
75156: IFFALSE 75226
// begin if UnitsInside ( j ) < 3 then
75158: LD_VAR 0 9
75162: PPUSH
75163: CALL_OW 313
75167: PUSH
75168: LD_INT 3
75170: LESS
75171: IFFALSE 75207
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75173: LD_INT 0
75175: PPUSH
75176: LD_INT 5
75178: PUSH
75179: LD_INT 8
75181: PUSH
75182: LD_INT 9
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: LIST
75189: PUSH
75190: LD_VAR 0 17
75194: ARRAY
75195: PPUSH
75196: LD_VAR 0 4
75200: PPUSH
75201: CALL_OW 380
75205: GO 75224
// PrepareHuman ( false , i , skill ) ;
75207: LD_INT 0
75209: PPUSH
75210: LD_VAR 0 8
75214: PPUSH
75215: LD_VAR 0 4
75219: PPUSH
75220: CALL_OW 380
// end else
75224: GO 75243
// PrepareHuman ( false , i , skill ) ;
75226: LD_INT 0
75228: PPUSH
75229: LD_VAR 0 8
75233: PPUSH
75234: LD_VAR 0 4
75238: PPUSH
75239: CALL_OW 380
// un := CreateHuman ;
75243: LD_ADDR_VAR 0 14
75247: PUSH
75248: CALL_OW 44
75252: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75253: LD_ADDR_VAR 0 7
75257: PUSH
75258: LD_VAR 0 7
75262: PPUSH
75263: LD_INT 1
75265: PPUSH
75266: LD_VAR 0 14
75270: PPUSH
75271: CALL_OW 2
75275: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75276: LD_VAR 0 14
75280: PPUSH
75281: LD_VAR 0 9
75285: PPUSH
75286: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75290: LD_VAR 0 9
75294: PPUSH
75295: CALL_OW 313
75299: PUSH
75300: LD_INT 6
75302: EQUAL
75303: PUSH
75304: LD_VAR 0 9
75308: PPUSH
75309: CALL_OW 266
75313: PUSH
75314: LD_INT 32
75316: PUSH
75317: LD_INT 31
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: IN
75324: OR
75325: IFFALSE 75139
75327: GO 75136
75329: POP
75330: POP
// end else
75331: GO 75713
// for j = 1 to x do
75333: LD_ADDR_VAR 0 9
75337: PUSH
75338: DOUBLE
75339: LD_INT 1
75341: DEC
75342: ST_TO_ADDR
75343: LD_VAR 0 13
75347: PUSH
75348: FOR_TO
75349: IFFALSE 75711
// begin InitHc ;
75351: CALL_OW 19
// if not f then
75355: LD_VAR 0 12
75359: NOT
75360: IFFALSE 75449
// begin PrepareHuman ( false , i , skill ) ;
75362: LD_INT 0
75364: PPUSH
75365: LD_VAR 0 8
75369: PPUSH
75370: LD_VAR 0 4
75374: PPUSH
75375: CALL_OW 380
// un := CreateHuman ;
75379: LD_ADDR_VAR 0 14
75383: PUSH
75384: CALL_OW 44
75388: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75389: LD_ADDR_VAR 0 7
75393: PUSH
75394: LD_VAR 0 7
75398: PPUSH
75399: LD_INT 1
75401: PPUSH
75402: LD_VAR 0 14
75406: PPUSH
75407: CALL_OW 2
75411: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75412: LD_VAR 0 14
75416: PPUSH
75417: LD_VAR 0 1
75421: PPUSH
75422: CALL_OW 250
75426: PPUSH
75427: LD_VAR 0 1
75431: PPUSH
75432: CALL_OW 251
75436: PPUSH
75437: LD_INT 10
75439: PPUSH
75440: LD_INT 0
75442: PPUSH
75443: CALL_OW 50
// continue ;
75447: GO 75348
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75449: LD_VAR 0 12
75453: PUSH
75454: LD_INT 1
75456: ARRAY
75457: PPUSH
75458: CALL_OW 313
75462: PUSH
75463: LD_VAR 0 12
75467: PUSH
75468: LD_INT 1
75470: ARRAY
75471: PPUSH
75472: CALL_OW 266
75476: PUSH
75477: LD_INT 32
75479: PUSH
75480: LD_INT 31
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: IN
75487: AND
75488: PUSH
75489: LD_VAR 0 12
75493: PUSH
75494: LD_INT 1
75496: ARRAY
75497: PPUSH
75498: CALL_OW 313
75502: PUSH
75503: LD_INT 6
75505: EQUAL
75506: OR
75507: IFFALSE 75527
// f := Delete ( f , 1 ) ;
75509: LD_ADDR_VAR 0 12
75513: PUSH
75514: LD_VAR 0 12
75518: PPUSH
75519: LD_INT 1
75521: PPUSH
75522: CALL_OW 3
75526: ST_TO_ADDR
// if not f then
75527: LD_VAR 0 12
75531: NOT
75532: IFFALSE 75550
// begin x := x + 2 ;
75534: LD_ADDR_VAR 0 13
75538: PUSH
75539: LD_VAR 0 13
75543: PUSH
75544: LD_INT 2
75546: PLUS
75547: ST_TO_ADDR
// continue ;
75548: GO 75348
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75550: LD_VAR 0 12
75554: PUSH
75555: LD_INT 1
75557: ARRAY
75558: PPUSH
75559: CALL_OW 266
75563: PUSH
75564: LD_INT 5
75566: EQUAL
75567: IFFALSE 75641
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75569: LD_VAR 0 12
75573: PUSH
75574: LD_INT 1
75576: ARRAY
75577: PPUSH
75578: CALL_OW 313
75582: PUSH
75583: LD_INT 3
75585: LESS
75586: IFFALSE 75622
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75588: LD_INT 0
75590: PPUSH
75591: LD_INT 5
75593: PUSH
75594: LD_INT 8
75596: PUSH
75597: LD_INT 9
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: LIST
75604: PUSH
75605: LD_VAR 0 17
75609: ARRAY
75610: PPUSH
75611: LD_VAR 0 4
75615: PPUSH
75616: CALL_OW 380
75620: GO 75639
// PrepareHuman ( false , i , skill ) ;
75622: LD_INT 0
75624: PPUSH
75625: LD_VAR 0 8
75629: PPUSH
75630: LD_VAR 0 4
75634: PPUSH
75635: CALL_OW 380
// end else
75639: GO 75658
// PrepareHuman ( false , i , skill ) ;
75641: LD_INT 0
75643: PPUSH
75644: LD_VAR 0 8
75648: PPUSH
75649: LD_VAR 0 4
75653: PPUSH
75654: CALL_OW 380
// un := CreateHuman ;
75658: LD_ADDR_VAR 0 14
75662: PUSH
75663: CALL_OW 44
75667: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75668: LD_ADDR_VAR 0 7
75672: PUSH
75673: LD_VAR 0 7
75677: PPUSH
75678: LD_INT 1
75680: PPUSH
75681: LD_VAR 0 14
75685: PPUSH
75686: CALL_OW 2
75690: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75691: LD_VAR 0 14
75695: PPUSH
75696: LD_VAR 0 12
75700: PUSH
75701: LD_INT 1
75703: ARRAY
75704: PPUSH
75705: CALL_OW 52
// end ;
75709: GO 75348
75711: POP
75712: POP
// end ;
75713: GO 74650
75715: POP
75716: POP
// result := result ^ buildings ;
75717: LD_ADDR_VAR 0 7
75721: PUSH
75722: LD_VAR 0 7
75726: PUSH
75727: LD_VAR 0 18
75731: ADD
75732: ST_TO_ADDR
// end else
75733: GO 75876
// begin for i = 1 to personel do
75735: LD_ADDR_VAR 0 8
75739: PUSH
75740: DOUBLE
75741: LD_INT 1
75743: DEC
75744: ST_TO_ADDR
75745: LD_VAR 0 6
75749: PUSH
75750: FOR_TO
75751: IFFALSE 75874
// begin if i > 4 then
75753: LD_VAR 0 8
75757: PUSH
75758: LD_INT 4
75760: GREATER
75761: IFFALSE 75765
// break ;
75763: GO 75874
// x := personel [ i ] ;
75765: LD_ADDR_VAR 0 13
75769: PUSH
75770: LD_VAR 0 6
75774: PUSH
75775: LD_VAR 0 8
75779: ARRAY
75780: ST_TO_ADDR
// if x = - 1 then
75781: LD_VAR 0 13
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: EQUAL
75790: IFFALSE 75794
// continue ;
75792: GO 75750
// PrepareHuman ( false , i , skill ) ;
75794: LD_INT 0
75796: PPUSH
75797: LD_VAR 0 8
75801: PPUSH
75802: LD_VAR 0 4
75806: PPUSH
75807: CALL_OW 380
// un := CreateHuman ;
75811: LD_ADDR_VAR 0 14
75815: PUSH
75816: CALL_OW 44
75820: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75821: LD_VAR 0 14
75825: PPUSH
75826: LD_VAR 0 1
75830: PPUSH
75831: CALL_OW 250
75835: PPUSH
75836: LD_VAR 0 1
75840: PPUSH
75841: CALL_OW 251
75845: PPUSH
75846: LD_INT 10
75848: PPUSH
75849: LD_INT 0
75851: PPUSH
75852: CALL_OW 50
// result := result ^ un ;
75856: LD_ADDR_VAR 0 7
75860: PUSH
75861: LD_VAR 0 7
75865: PUSH
75866: LD_VAR 0 14
75870: ADD
75871: ST_TO_ADDR
// end ;
75872: GO 75750
75874: POP
75875: POP
// end ; end ;
75876: LD_VAR 0 7
75880: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75881: LD_INT 0
75883: PPUSH
75884: PPUSH
75885: PPUSH
75886: PPUSH
75887: PPUSH
75888: PPUSH
75889: PPUSH
75890: PPUSH
75891: PPUSH
75892: PPUSH
75893: PPUSH
75894: PPUSH
75895: PPUSH
75896: PPUSH
75897: PPUSH
75898: PPUSH
// result := false ;
75899: LD_ADDR_VAR 0 3
75903: PUSH
75904: LD_INT 0
75906: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75907: LD_VAR 0 1
75911: NOT
75912: PUSH
75913: LD_VAR 0 1
75917: PPUSH
75918: CALL_OW 266
75922: PUSH
75923: LD_INT 32
75925: PUSH
75926: LD_INT 33
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: IN
75933: NOT
75934: OR
75935: IFFALSE 75939
// exit ;
75937: GO 77048
// nat := GetNation ( tower ) ;
75939: LD_ADDR_VAR 0 12
75943: PUSH
75944: LD_VAR 0 1
75948: PPUSH
75949: CALL_OW 248
75953: ST_TO_ADDR
// side := GetSide ( tower ) ;
75954: LD_ADDR_VAR 0 16
75958: PUSH
75959: LD_VAR 0 1
75963: PPUSH
75964: CALL_OW 255
75968: ST_TO_ADDR
// x := GetX ( tower ) ;
75969: LD_ADDR_VAR 0 10
75973: PUSH
75974: LD_VAR 0 1
75978: PPUSH
75979: CALL_OW 250
75983: ST_TO_ADDR
// y := GetY ( tower ) ;
75984: LD_ADDR_VAR 0 11
75988: PUSH
75989: LD_VAR 0 1
75993: PPUSH
75994: CALL_OW 251
75998: ST_TO_ADDR
// if not x or not y then
75999: LD_VAR 0 10
76003: NOT
76004: PUSH
76005: LD_VAR 0 11
76009: NOT
76010: OR
76011: IFFALSE 76015
// exit ;
76013: GO 77048
// weapon := 0 ;
76015: LD_ADDR_VAR 0 18
76019: PUSH
76020: LD_INT 0
76022: ST_TO_ADDR
// fac_list := [ ] ;
76023: LD_ADDR_VAR 0 17
76027: PUSH
76028: EMPTY
76029: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76030: LD_ADDR_VAR 0 6
76034: PUSH
76035: LD_VAR 0 1
76039: PPUSH
76040: CALL_OW 274
76044: PPUSH
76045: LD_VAR 0 2
76049: PPUSH
76050: LD_INT 0
76052: PPUSH
76053: CALL 73619 0 3
76057: PPUSH
76058: LD_INT 30
76060: PUSH
76061: LD_INT 3
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PPUSH
76068: CALL_OW 72
76072: ST_TO_ADDR
// if not factories then
76073: LD_VAR 0 6
76077: NOT
76078: IFFALSE 76082
// exit ;
76080: GO 77048
// for i in factories do
76082: LD_ADDR_VAR 0 8
76086: PUSH
76087: LD_VAR 0 6
76091: PUSH
76092: FOR_IN
76093: IFFALSE 76118
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76095: LD_ADDR_VAR 0 17
76099: PUSH
76100: LD_VAR 0 17
76104: PUSH
76105: LD_VAR 0 8
76109: PPUSH
76110: CALL_OW 478
76114: UNION
76115: ST_TO_ADDR
76116: GO 76092
76118: POP
76119: POP
// if not fac_list then
76120: LD_VAR 0 17
76124: NOT
76125: IFFALSE 76129
// exit ;
76127: GO 77048
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76129: LD_ADDR_VAR 0 5
76133: PUSH
76134: LD_INT 4
76136: PUSH
76137: LD_INT 5
76139: PUSH
76140: LD_INT 9
76142: PUSH
76143: LD_INT 10
76145: PUSH
76146: LD_INT 6
76148: PUSH
76149: LD_INT 7
76151: PUSH
76152: LD_INT 11
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 27
76166: PUSH
76167: LD_INT 28
76169: PUSH
76170: LD_INT 26
76172: PUSH
76173: LD_INT 30
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 43
76184: PUSH
76185: LD_INT 44
76187: PUSH
76188: LD_INT 46
76190: PUSH
76191: LD_INT 45
76193: PUSH
76194: LD_INT 47
76196: PUSH
76197: LD_INT 49
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: PUSH
76213: LD_VAR 0 12
76217: ARRAY
76218: ST_TO_ADDR
// list := list isect fac_list ;
76219: LD_ADDR_VAR 0 5
76223: PUSH
76224: LD_VAR 0 5
76228: PUSH
76229: LD_VAR 0 17
76233: ISECT
76234: ST_TO_ADDR
// if not list then
76235: LD_VAR 0 5
76239: NOT
76240: IFFALSE 76244
// exit ;
76242: GO 77048
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76244: LD_VAR 0 12
76248: PUSH
76249: LD_INT 3
76251: EQUAL
76252: PUSH
76253: LD_INT 49
76255: PUSH
76256: LD_VAR 0 5
76260: IN
76261: AND
76262: PUSH
76263: LD_INT 31
76265: PPUSH
76266: LD_VAR 0 16
76270: PPUSH
76271: CALL_OW 321
76275: PUSH
76276: LD_INT 2
76278: EQUAL
76279: AND
76280: IFFALSE 76340
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76282: LD_INT 22
76284: PUSH
76285: LD_VAR 0 16
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 35
76296: PUSH
76297: LD_INT 49
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 91
76306: PUSH
76307: LD_VAR 0 1
76311: PUSH
76312: LD_INT 10
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: LIST
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: LIST
76324: PPUSH
76325: CALL_OW 69
76329: NOT
76330: IFFALSE 76340
// weapon := ru_time_lapser ;
76332: LD_ADDR_VAR 0 18
76336: PUSH
76337: LD_INT 49
76339: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76340: LD_VAR 0 12
76344: PUSH
76345: LD_INT 1
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: IN
76355: PUSH
76356: LD_INT 11
76358: PUSH
76359: LD_VAR 0 5
76363: IN
76364: PUSH
76365: LD_INT 30
76367: PUSH
76368: LD_VAR 0 5
76372: IN
76373: OR
76374: AND
76375: PUSH
76376: LD_INT 6
76378: PPUSH
76379: LD_VAR 0 16
76383: PPUSH
76384: CALL_OW 321
76388: PUSH
76389: LD_INT 2
76391: EQUAL
76392: AND
76393: IFFALSE 76558
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76395: LD_INT 22
76397: PUSH
76398: LD_VAR 0 16
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 2
76409: PUSH
76410: LD_INT 35
76412: PUSH
76413: LD_INT 11
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 35
76422: PUSH
76423: LD_INT 30
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 91
76437: PUSH
76438: LD_VAR 0 1
76442: PUSH
76443: LD_INT 18
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: LIST
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: LIST
76455: PPUSH
76456: CALL_OW 69
76460: NOT
76461: PUSH
76462: LD_INT 22
76464: PUSH
76465: LD_VAR 0 16
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 2
76476: PUSH
76477: LD_INT 30
76479: PUSH
76480: LD_INT 32
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 30
76489: PUSH
76490: LD_INT 33
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 91
76504: PUSH
76505: LD_VAR 0 1
76509: PUSH
76510: LD_INT 12
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: LIST
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: LIST
76522: PUSH
76523: EMPTY
76524: LIST
76525: PPUSH
76526: CALL_OW 69
76530: PUSH
76531: LD_INT 2
76533: GREATER
76534: AND
76535: IFFALSE 76558
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76537: LD_ADDR_VAR 0 18
76541: PUSH
76542: LD_INT 11
76544: PUSH
76545: LD_INT 30
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_VAR 0 12
76556: ARRAY
76557: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76558: LD_VAR 0 18
76562: NOT
76563: PUSH
76564: LD_INT 40
76566: PPUSH
76567: LD_VAR 0 16
76571: PPUSH
76572: CALL_OW 321
76576: PUSH
76577: LD_INT 2
76579: EQUAL
76580: AND
76581: PUSH
76582: LD_INT 7
76584: PUSH
76585: LD_VAR 0 5
76589: IN
76590: PUSH
76591: LD_INT 28
76593: PUSH
76594: LD_VAR 0 5
76598: IN
76599: OR
76600: PUSH
76601: LD_INT 45
76603: PUSH
76604: LD_VAR 0 5
76608: IN
76609: OR
76610: AND
76611: IFFALSE 76865
// begin hex := GetHexInfo ( x , y ) ;
76613: LD_ADDR_VAR 0 4
76617: PUSH
76618: LD_VAR 0 10
76622: PPUSH
76623: LD_VAR 0 11
76627: PPUSH
76628: CALL_OW 546
76632: ST_TO_ADDR
// if hex [ 1 ] then
76633: LD_VAR 0 4
76637: PUSH
76638: LD_INT 1
76640: ARRAY
76641: IFFALSE 76645
// exit ;
76643: GO 77048
// height := hex [ 2 ] ;
76645: LD_ADDR_VAR 0 15
76649: PUSH
76650: LD_VAR 0 4
76654: PUSH
76655: LD_INT 2
76657: ARRAY
76658: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76659: LD_ADDR_VAR 0 14
76663: PUSH
76664: LD_INT 0
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: LD_INT 5
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: ST_TO_ADDR
// for i in tmp do
76682: LD_ADDR_VAR 0 8
76686: PUSH
76687: LD_VAR 0 14
76691: PUSH
76692: FOR_IN
76693: IFFALSE 76863
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76695: LD_ADDR_VAR 0 9
76699: PUSH
76700: LD_VAR 0 10
76704: PPUSH
76705: LD_VAR 0 8
76709: PPUSH
76710: LD_INT 5
76712: PPUSH
76713: CALL_OW 272
76717: PUSH
76718: LD_VAR 0 11
76722: PPUSH
76723: LD_VAR 0 8
76727: PPUSH
76728: LD_INT 5
76730: PPUSH
76731: CALL_OW 273
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76740: LD_VAR 0 9
76744: PUSH
76745: LD_INT 1
76747: ARRAY
76748: PPUSH
76749: LD_VAR 0 9
76753: PUSH
76754: LD_INT 2
76756: ARRAY
76757: PPUSH
76758: CALL_OW 488
76762: IFFALSE 76861
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76764: LD_ADDR_VAR 0 4
76768: PUSH
76769: LD_VAR 0 9
76773: PUSH
76774: LD_INT 1
76776: ARRAY
76777: PPUSH
76778: LD_VAR 0 9
76782: PUSH
76783: LD_INT 2
76785: ARRAY
76786: PPUSH
76787: CALL_OW 546
76791: ST_TO_ADDR
// if hex [ 1 ] then
76792: LD_VAR 0 4
76796: PUSH
76797: LD_INT 1
76799: ARRAY
76800: IFFALSE 76804
// continue ;
76802: GO 76692
// h := hex [ 2 ] ;
76804: LD_ADDR_VAR 0 13
76808: PUSH
76809: LD_VAR 0 4
76813: PUSH
76814: LD_INT 2
76816: ARRAY
76817: ST_TO_ADDR
// if h + 7 < height then
76818: LD_VAR 0 13
76822: PUSH
76823: LD_INT 7
76825: PLUS
76826: PUSH
76827: LD_VAR 0 15
76831: LESS
76832: IFFALSE 76861
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76834: LD_ADDR_VAR 0 18
76838: PUSH
76839: LD_INT 7
76841: PUSH
76842: LD_INT 28
76844: PUSH
76845: LD_INT 45
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: PUSH
76853: LD_VAR 0 12
76857: ARRAY
76858: ST_TO_ADDR
// break ;
76859: GO 76863
// end ; end ; end ;
76861: GO 76692
76863: POP
76864: POP
// end ; if not weapon then
76865: LD_VAR 0 18
76869: NOT
76870: IFFALSE 76930
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76872: LD_ADDR_VAR 0 5
76876: PUSH
76877: LD_VAR 0 5
76881: PUSH
76882: LD_INT 11
76884: PUSH
76885: LD_INT 30
76887: PUSH
76888: LD_INT 49
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: LIST
76895: DIFF
76896: ST_TO_ADDR
// if not list then
76897: LD_VAR 0 5
76901: NOT
76902: IFFALSE 76906
// exit ;
76904: GO 77048
// weapon := list [ rand ( 1 , list ) ] ;
76906: LD_ADDR_VAR 0 18
76910: PUSH
76911: LD_VAR 0 5
76915: PUSH
76916: LD_INT 1
76918: PPUSH
76919: LD_VAR 0 5
76923: PPUSH
76924: CALL_OW 12
76928: ARRAY
76929: ST_TO_ADDR
// end ; if weapon then
76930: LD_VAR 0 18
76934: IFFALSE 77048
// begin tmp := CostOfWeapon ( weapon ) ;
76936: LD_ADDR_VAR 0 14
76940: PUSH
76941: LD_VAR 0 18
76945: PPUSH
76946: CALL_OW 451
76950: ST_TO_ADDR
// j := GetBase ( tower ) ;
76951: LD_ADDR_VAR 0 9
76955: PUSH
76956: LD_VAR 0 1
76960: PPUSH
76961: CALL_OW 274
76965: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76966: LD_VAR 0 9
76970: PPUSH
76971: LD_INT 1
76973: PPUSH
76974: CALL_OW 275
76978: PUSH
76979: LD_VAR 0 14
76983: PUSH
76984: LD_INT 1
76986: ARRAY
76987: GREATEREQUAL
76988: PUSH
76989: LD_VAR 0 9
76993: PPUSH
76994: LD_INT 2
76996: PPUSH
76997: CALL_OW 275
77001: PUSH
77002: LD_VAR 0 14
77006: PUSH
77007: LD_INT 2
77009: ARRAY
77010: GREATEREQUAL
77011: AND
77012: PUSH
77013: LD_VAR 0 9
77017: PPUSH
77018: LD_INT 3
77020: PPUSH
77021: CALL_OW 275
77025: PUSH
77026: LD_VAR 0 14
77030: PUSH
77031: LD_INT 3
77033: ARRAY
77034: GREATEREQUAL
77035: AND
77036: IFFALSE 77048
// result := weapon ;
77038: LD_ADDR_VAR 0 3
77042: PUSH
77043: LD_VAR 0 18
77047: ST_TO_ADDR
// end ; end ;
77048: LD_VAR 0 3
77052: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77053: LD_INT 0
77055: PPUSH
77056: PPUSH
// result := true ;
77057: LD_ADDR_VAR 0 3
77061: PUSH
77062: LD_INT 1
77064: ST_TO_ADDR
// if array1 = array2 then
77065: LD_VAR 0 1
77069: PUSH
77070: LD_VAR 0 2
77074: EQUAL
77075: IFFALSE 77135
// begin for i = 1 to array1 do
77077: LD_ADDR_VAR 0 4
77081: PUSH
77082: DOUBLE
77083: LD_INT 1
77085: DEC
77086: ST_TO_ADDR
77087: LD_VAR 0 1
77091: PUSH
77092: FOR_TO
77093: IFFALSE 77131
// if array1 [ i ] <> array2 [ i ] then
77095: LD_VAR 0 1
77099: PUSH
77100: LD_VAR 0 4
77104: ARRAY
77105: PUSH
77106: LD_VAR 0 2
77110: PUSH
77111: LD_VAR 0 4
77115: ARRAY
77116: NONEQUAL
77117: IFFALSE 77129
// begin result := false ;
77119: LD_ADDR_VAR 0 3
77123: PUSH
77124: LD_INT 0
77126: ST_TO_ADDR
// break ;
77127: GO 77131
// end ;
77129: GO 77092
77131: POP
77132: POP
// end else
77133: GO 77143
// result := false ;
77135: LD_ADDR_VAR 0 3
77139: PUSH
77140: LD_INT 0
77142: ST_TO_ADDR
// end ;
77143: LD_VAR 0 3
77147: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77148: LD_INT 0
77150: PPUSH
77151: PPUSH
// if not array1 or not array2 then
77152: LD_VAR 0 1
77156: NOT
77157: PUSH
77158: LD_VAR 0 2
77162: NOT
77163: OR
77164: IFFALSE 77168
// exit ;
77166: GO 77232
// result := true ;
77168: LD_ADDR_VAR 0 3
77172: PUSH
77173: LD_INT 1
77175: ST_TO_ADDR
// for i = 1 to array1 do
77176: LD_ADDR_VAR 0 4
77180: PUSH
77181: DOUBLE
77182: LD_INT 1
77184: DEC
77185: ST_TO_ADDR
77186: LD_VAR 0 1
77190: PUSH
77191: FOR_TO
77192: IFFALSE 77230
// if array1 [ i ] <> array2 [ i ] then
77194: LD_VAR 0 1
77198: PUSH
77199: LD_VAR 0 4
77203: ARRAY
77204: PUSH
77205: LD_VAR 0 2
77209: PUSH
77210: LD_VAR 0 4
77214: ARRAY
77215: NONEQUAL
77216: IFFALSE 77228
// begin result := false ;
77218: LD_ADDR_VAR 0 3
77222: PUSH
77223: LD_INT 0
77225: ST_TO_ADDR
// break ;
77226: GO 77230
// end ;
77228: GO 77191
77230: POP
77231: POP
// end ;
77232: LD_VAR 0 3
77236: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77237: LD_INT 0
77239: PPUSH
77240: PPUSH
77241: PPUSH
// pom := GetBase ( fac ) ;
77242: LD_ADDR_VAR 0 5
77246: PUSH
77247: LD_VAR 0 1
77251: PPUSH
77252: CALL_OW 274
77256: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77257: LD_ADDR_VAR 0 4
77261: PUSH
77262: LD_VAR 0 2
77266: PUSH
77267: LD_INT 1
77269: ARRAY
77270: PPUSH
77271: LD_VAR 0 2
77275: PUSH
77276: LD_INT 2
77278: ARRAY
77279: PPUSH
77280: LD_VAR 0 2
77284: PUSH
77285: LD_INT 3
77287: ARRAY
77288: PPUSH
77289: LD_VAR 0 2
77293: PUSH
77294: LD_INT 4
77296: ARRAY
77297: PPUSH
77298: CALL_OW 449
77302: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77303: LD_ADDR_VAR 0 3
77307: PUSH
77308: LD_VAR 0 5
77312: PPUSH
77313: LD_INT 1
77315: PPUSH
77316: CALL_OW 275
77320: PUSH
77321: LD_VAR 0 4
77325: PUSH
77326: LD_INT 1
77328: ARRAY
77329: GREATEREQUAL
77330: PUSH
77331: LD_VAR 0 5
77335: PPUSH
77336: LD_INT 2
77338: PPUSH
77339: CALL_OW 275
77343: PUSH
77344: LD_VAR 0 4
77348: PUSH
77349: LD_INT 2
77351: ARRAY
77352: GREATEREQUAL
77353: AND
77354: PUSH
77355: LD_VAR 0 5
77359: PPUSH
77360: LD_INT 3
77362: PPUSH
77363: CALL_OW 275
77367: PUSH
77368: LD_VAR 0 4
77372: PUSH
77373: LD_INT 3
77375: ARRAY
77376: GREATEREQUAL
77377: AND
77378: ST_TO_ADDR
// end ;
77379: LD_VAR 0 3
77383: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77384: LD_INT 0
77386: PPUSH
77387: PPUSH
77388: PPUSH
77389: PPUSH
// pom := GetBase ( building ) ;
77390: LD_ADDR_VAR 0 3
77394: PUSH
77395: LD_VAR 0 1
77399: PPUSH
77400: CALL_OW 274
77404: ST_TO_ADDR
// if not pom then
77405: LD_VAR 0 3
77409: NOT
77410: IFFALSE 77414
// exit ;
77412: GO 77584
// btype := GetBType ( building ) ;
77414: LD_ADDR_VAR 0 5
77418: PUSH
77419: LD_VAR 0 1
77423: PPUSH
77424: CALL_OW 266
77428: ST_TO_ADDR
// if btype = b_armoury then
77429: LD_VAR 0 5
77433: PUSH
77434: LD_INT 4
77436: EQUAL
77437: IFFALSE 77447
// btype := b_barracks ;
77439: LD_ADDR_VAR 0 5
77443: PUSH
77444: LD_INT 5
77446: ST_TO_ADDR
// if btype = b_depot then
77447: LD_VAR 0 5
77451: PUSH
77452: LD_INT 0
77454: EQUAL
77455: IFFALSE 77465
// btype := b_warehouse ;
77457: LD_ADDR_VAR 0 5
77461: PUSH
77462: LD_INT 1
77464: ST_TO_ADDR
// if btype = b_workshop then
77465: LD_VAR 0 5
77469: PUSH
77470: LD_INT 2
77472: EQUAL
77473: IFFALSE 77483
// btype := b_factory ;
77475: LD_ADDR_VAR 0 5
77479: PUSH
77480: LD_INT 3
77482: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77483: LD_ADDR_VAR 0 4
77487: PUSH
77488: LD_VAR 0 5
77492: PPUSH
77493: LD_VAR 0 1
77497: PPUSH
77498: CALL_OW 248
77502: PPUSH
77503: CALL_OW 450
77507: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77508: LD_ADDR_VAR 0 2
77512: PUSH
77513: LD_VAR 0 3
77517: PPUSH
77518: LD_INT 1
77520: PPUSH
77521: CALL_OW 275
77525: PUSH
77526: LD_VAR 0 4
77530: PUSH
77531: LD_INT 1
77533: ARRAY
77534: GREATEREQUAL
77535: PUSH
77536: LD_VAR 0 3
77540: PPUSH
77541: LD_INT 2
77543: PPUSH
77544: CALL_OW 275
77548: PUSH
77549: LD_VAR 0 4
77553: PUSH
77554: LD_INT 2
77556: ARRAY
77557: GREATEREQUAL
77558: AND
77559: PUSH
77560: LD_VAR 0 3
77564: PPUSH
77565: LD_INT 3
77567: PPUSH
77568: CALL_OW 275
77572: PUSH
77573: LD_VAR 0 4
77577: PUSH
77578: LD_INT 3
77580: ARRAY
77581: GREATEREQUAL
77582: AND
77583: ST_TO_ADDR
// end ;
77584: LD_VAR 0 2
77588: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77589: LD_INT 0
77591: PPUSH
77592: PPUSH
77593: PPUSH
// pom := GetBase ( building ) ;
77594: LD_ADDR_VAR 0 4
77598: PUSH
77599: LD_VAR 0 1
77603: PPUSH
77604: CALL_OW 274
77608: ST_TO_ADDR
// if not pom then
77609: LD_VAR 0 4
77613: NOT
77614: IFFALSE 77618
// exit ;
77616: GO 77719
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77618: LD_ADDR_VAR 0 5
77622: PUSH
77623: LD_VAR 0 2
77627: PPUSH
77628: LD_VAR 0 1
77632: PPUSH
77633: CALL_OW 248
77637: PPUSH
77638: CALL_OW 450
77642: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77643: LD_ADDR_VAR 0 3
77647: PUSH
77648: LD_VAR 0 4
77652: PPUSH
77653: LD_INT 1
77655: PPUSH
77656: CALL_OW 275
77660: PUSH
77661: LD_VAR 0 5
77665: PUSH
77666: LD_INT 1
77668: ARRAY
77669: GREATEREQUAL
77670: PUSH
77671: LD_VAR 0 4
77675: PPUSH
77676: LD_INT 2
77678: PPUSH
77679: CALL_OW 275
77683: PUSH
77684: LD_VAR 0 5
77688: PUSH
77689: LD_INT 2
77691: ARRAY
77692: GREATEREQUAL
77693: AND
77694: PUSH
77695: LD_VAR 0 4
77699: PPUSH
77700: LD_INT 3
77702: PPUSH
77703: CALL_OW 275
77707: PUSH
77708: LD_VAR 0 5
77712: PUSH
77713: LD_INT 3
77715: ARRAY
77716: GREATEREQUAL
77717: AND
77718: ST_TO_ADDR
// end ;
77719: LD_VAR 0 3
77723: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77724: LD_INT 0
77726: PPUSH
77727: PPUSH
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
77736: PPUSH
// result := false ;
77737: LD_ADDR_VAR 0 8
77741: PUSH
77742: LD_INT 0
77744: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77745: LD_VAR 0 5
77749: NOT
77750: PUSH
77751: LD_VAR 0 1
77755: NOT
77756: OR
77757: PUSH
77758: LD_VAR 0 2
77762: NOT
77763: OR
77764: PUSH
77765: LD_VAR 0 3
77769: NOT
77770: OR
77771: IFFALSE 77775
// exit ;
77773: GO 78589
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77775: LD_ADDR_VAR 0 14
77779: PUSH
77780: LD_VAR 0 1
77784: PPUSH
77785: LD_VAR 0 2
77789: PPUSH
77790: LD_VAR 0 3
77794: PPUSH
77795: LD_VAR 0 4
77799: PPUSH
77800: LD_VAR 0 5
77804: PUSH
77805: LD_INT 1
77807: ARRAY
77808: PPUSH
77809: CALL_OW 248
77813: PPUSH
77814: LD_INT 0
77816: PPUSH
77817: CALL 79826 0 6
77821: ST_TO_ADDR
// if not hexes then
77822: LD_VAR 0 14
77826: NOT
77827: IFFALSE 77831
// exit ;
77829: GO 78589
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77831: LD_ADDR_VAR 0 17
77835: PUSH
77836: LD_VAR 0 5
77840: PPUSH
77841: LD_INT 22
77843: PUSH
77844: LD_VAR 0 13
77848: PPUSH
77849: CALL_OW 255
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 2
77860: PUSH
77861: LD_INT 30
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 30
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: LIST
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PPUSH
77890: CALL_OW 72
77894: ST_TO_ADDR
// for i = 1 to hexes do
77895: LD_ADDR_VAR 0 9
77899: PUSH
77900: DOUBLE
77901: LD_INT 1
77903: DEC
77904: ST_TO_ADDR
77905: LD_VAR 0 14
77909: PUSH
77910: FOR_TO
77911: IFFALSE 78587
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77913: LD_ADDR_VAR 0 13
77917: PUSH
77918: LD_VAR 0 14
77922: PUSH
77923: LD_VAR 0 9
77927: ARRAY
77928: PUSH
77929: LD_INT 1
77931: ARRAY
77932: PPUSH
77933: LD_VAR 0 14
77937: PUSH
77938: LD_VAR 0 9
77942: ARRAY
77943: PUSH
77944: LD_INT 2
77946: ARRAY
77947: PPUSH
77948: CALL_OW 428
77952: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77953: LD_VAR 0 14
77957: PUSH
77958: LD_VAR 0 9
77962: ARRAY
77963: PUSH
77964: LD_INT 1
77966: ARRAY
77967: PPUSH
77968: LD_VAR 0 14
77972: PUSH
77973: LD_VAR 0 9
77977: ARRAY
77978: PUSH
77979: LD_INT 2
77981: ARRAY
77982: PPUSH
77983: CALL_OW 351
77987: PUSH
77988: LD_VAR 0 14
77992: PUSH
77993: LD_VAR 0 9
77997: ARRAY
77998: PUSH
77999: LD_INT 1
78001: ARRAY
78002: PPUSH
78003: LD_VAR 0 14
78007: PUSH
78008: LD_VAR 0 9
78012: ARRAY
78013: PUSH
78014: LD_INT 2
78016: ARRAY
78017: PPUSH
78018: CALL_OW 488
78022: NOT
78023: OR
78024: PUSH
78025: LD_VAR 0 13
78029: PPUSH
78030: CALL_OW 247
78034: PUSH
78035: LD_INT 3
78037: EQUAL
78038: OR
78039: IFFALSE 78045
// exit ;
78041: POP
78042: POP
78043: GO 78589
// if not tmp then
78045: LD_VAR 0 13
78049: NOT
78050: IFFALSE 78054
// continue ;
78052: GO 77910
// result := true ;
78054: LD_ADDR_VAR 0 8
78058: PUSH
78059: LD_INT 1
78061: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78062: LD_VAR 0 6
78066: PUSH
78067: LD_VAR 0 13
78071: PPUSH
78072: CALL_OW 247
78076: PUSH
78077: LD_INT 2
78079: EQUAL
78080: AND
78081: PUSH
78082: LD_VAR 0 13
78086: PPUSH
78087: CALL_OW 263
78091: PUSH
78092: LD_INT 1
78094: EQUAL
78095: AND
78096: IFFALSE 78260
// begin if IsDrivenBy ( tmp ) then
78098: LD_VAR 0 13
78102: PPUSH
78103: CALL_OW 311
78107: IFFALSE 78111
// continue ;
78109: GO 77910
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78111: LD_VAR 0 6
78115: PPUSH
78116: LD_INT 3
78118: PUSH
78119: LD_INT 60
78121: PUSH
78122: EMPTY
78123: LIST
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 3
78131: PUSH
78132: LD_INT 55
78134: PUSH
78135: EMPTY
78136: LIST
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PPUSH
78146: CALL_OW 72
78150: IFFALSE 78258
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78152: LD_ADDR_VAR 0 18
78156: PUSH
78157: LD_VAR 0 6
78161: PPUSH
78162: LD_INT 3
78164: PUSH
78165: LD_INT 60
78167: PUSH
78168: EMPTY
78169: LIST
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 3
78177: PUSH
78178: LD_INT 55
78180: PUSH
78181: EMPTY
78182: LIST
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PPUSH
78192: CALL_OW 72
78196: PUSH
78197: LD_INT 1
78199: ARRAY
78200: ST_TO_ADDR
// if IsInUnit ( driver ) then
78201: LD_VAR 0 18
78205: PPUSH
78206: CALL_OW 310
78210: IFFALSE 78221
// ComExit ( driver ) ;
78212: LD_VAR 0 18
78216: PPUSH
78217: CALL 103010 0 1
// AddComEnterUnit ( driver , tmp ) ;
78221: LD_VAR 0 18
78225: PPUSH
78226: LD_VAR 0 13
78230: PPUSH
78231: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78235: LD_VAR 0 18
78239: PPUSH
78240: LD_VAR 0 7
78244: PPUSH
78245: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78249: LD_VAR 0 18
78253: PPUSH
78254: CALL_OW 181
// end ; continue ;
78258: GO 77910
// end ; if not cleaners or not tmp in cleaners then
78260: LD_VAR 0 6
78264: NOT
78265: PUSH
78266: LD_VAR 0 13
78270: PUSH
78271: LD_VAR 0 6
78275: IN
78276: NOT
78277: OR
78278: IFFALSE 78585
// begin if dep then
78280: LD_VAR 0 17
78284: IFFALSE 78420
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78286: LD_ADDR_VAR 0 16
78290: PUSH
78291: LD_VAR 0 17
78295: PUSH
78296: LD_INT 1
78298: ARRAY
78299: PPUSH
78300: CALL_OW 250
78304: PPUSH
78305: LD_VAR 0 17
78309: PUSH
78310: LD_INT 1
78312: ARRAY
78313: PPUSH
78314: CALL_OW 254
78318: PPUSH
78319: LD_INT 5
78321: PPUSH
78322: CALL_OW 272
78326: PUSH
78327: LD_VAR 0 17
78331: PUSH
78332: LD_INT 1
78334: ARRAY
78335: PPUSH
78336: CALL_OW 251
78340: PPUSH
78341: LD_VAR 0 17
78345: PUSH
78346: LD_INT 1
78348: ARRAY
78349: PPUSH
78350: CALL_OW 254
78354: PPUSH
78355: LD_INT 5
78357: PPUSH
78358: CALL_OW 273
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78367: LD_VAR 0 16
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: LD_VAR 0 16
78380: PUSH
78381: LD_INT 2
78383: ARRAY
78384: PPUSH
78385: CALL_OW 488
78389: IFFALSE 78420
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78391: LD_VAR 0 13
78395: PPUSH
78396: LD_VAR 0 16
78400: PUSH
78401: LD_INT 1
78403: ARRAY
78404: PPUSH
78405: LD_VAR 0 16
78409: PUSH
78410: LD_INT 2
78412: ARRAY
78413: PPUSH
78414: CALL_OW 111
// continue ;
78418: GO 77910
// end ; end ; r := GetDir ( tmp ) ;
78420: LD_ADDR_VAR 0 15
78424: PUSH
78425: LD_VAR 0 13
78429: PPUSH
78430: CALL_OW 254
78434: ST_TO_ADDR
// if r = 5 then
78435: LD_VAR 0 15
78439: PUSH
78440: LD_INT 5
78442: EQUAL
78443: IFFALSE 78453
// r := 0 ;
78445: LD_ADDR_VAR 0 15
78449: PUSH
78450: LD_INT 0
78452: ST_TO_ADDR
// for j = r to 5 do
78453: LD_ADDR_VAR 0 10
78457: PUSH
78458: DOUBLE
78459: LD_VAR 0 15
78463: DEC
78464: ST_TO_ADDR
78465: LD_INT 5
78467: PUSH
78468: FOR_TO
78469: IFFALSE 78583
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78471: LD_ADDR_VAR 0 11
78475: PUSH
78476: LD_VAR 0 13
78480: PPUSH
78481: CALL_OW 250
78485: PPUSH
78486: LD_VAR 0 10
78490: PPUSH
78491: LD_INT 2
78493: PPUSH
78494: CALL_OW 272
78498: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78499: LD_ADDR_VAR 0 12
78503: PUSH
78504: LD_VAR 0 13
78508: PPUSH
78509: CALL_OW 251
78513: PPUSH
78514: LD_VAR 0 10
78518: PPUSH
78519: LD_INT 2
78521: PPUSH
78522: CALL_OW 273
78526: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78527: LD_VAR 0 11
78531: PPUSH
78532: LD_VAR 0 12
78536: PPUSH
78537: CALL_OW 488
78541: PUSH
78542: LD_VAR 0 11
78546: PPUSH
78547: LD_VAR 0 12
78551: PPUSH
78552: CALL_OW 428
78556: NOT
78557: AND
78558: IFFALSE 78581
// begin ComMoveXY ( tmp , _x , _y ) ;
78560: LD_VAR 0 13
78564: PPUSH
78565: LD_VAR 0 11
78569: PPUSH
78570: LD_VAR 0 12
78574: PPUSH
78575: CALL_OW 111
// break ;
78579: GO 78583
// end ; end ;
78581: GO 78468
78583: POP
78584: POP
// end ; end ;
78585: GO 77910
78587: POP
78588: POP
// end ;
78589: LD_VAR 0 8
78593: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78594: LD_INT 0
78596: PPUSH
// result := true ;
78597: LD_ADDR_VAR 0 3
78601: PUSH
78602: LD_INT 1
78604: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78605: LD_VAR 0 2
78609: PUSH
78610: LD_INT 24
78612: DOUBLE
78613: EQUAL
78614: IFTRUE 78624
78616: LD_INT 33
78618: DOUBLE
78619: EQUAL
78620: IFTRUE 78624
78622: GO 78649
78624: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78625: LD_ADDR_VAR 0 3
78629: PUSH
78630: LD_INT 32
78632: PPUSH
78633: LD_VAR 0 1
78637: PPUSH
78638: CALL_OW 321
78642: PUSH
78643: LD_INT 2
78645: EQUAL
78646: ST_TO_ADDR
78647: GO 78969
78649: LD_INT 20
78651: DOUBLE
78652: EQUAL
78653: IFTRUE 78657
78655: GO 78682
78657: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78658: LD_ADDR_VAR 0 3
78662: PUSH
78663: LD_INT 6
78665: PPUSH
78666: LD_VAR 0 1
78670: PPUSH
78671: CALL_OW 321
78675: PUSH
78676: LD_INT 2
78678: EQUAL
78679: ST_TO_ADDR
78680: GO 78969
78682: LD_INT 22
78684: DOUBLE
78685: EQUAL
78686: IFTRUE 78696
78688: LD_INT 36
78690: DOUBLE
78691: EQUAL
78692: IFTRUE 78696
78694: GO 78721
78696: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78697: LD_ADDR_VAR 0 3
78701: PUSH
78702: LD_INT 15
78704: PPUSH
78705: LD_VAR 0 1
78709: PPUSH
78710: CALL_OW 321
78714: PUSH
78715: LD_INT 2
78717: EQUAL
78718: ST_TO_ADDR
78719: GO 78969
78721: LD_INT 30
78723: DOUBLE
78724: EQUAL
78725: IFTRUE 78729
78727: GO 78754
78729: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78730: LD_ADDR_VAR 0 3
78734: PUSH
78735: LD_INT 20
78737: PPUSH
78738: LD_VAR 0 1
78742: PPUSH
78743: CALL_OW 321
78747: PUSH
78748: LD_INT 2
78750: EQUAL
78751: ST_TO_ADDR
78752: GO 78969
78754: LD_INT 28
78756: DOUBLE
78757: EQUAL
78758: IFTRUE 78768
78760: LD_INT 21
78762: DOUBLE
78763: EQUAL
78764: IFTRUE 78768
78766: GO 78793
78768: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78769: LD_ADDR_VAR 0 3
78773: PUSH
78774: LD_INT 21
78776: PPUSH
78777: LD_VAR 0 1
78781: PPUSH
78782: CALL_OW 321
78786: PUSH
78787: LD_INT 2
78789: EQUAL
78790: ST_TO_ADDR
78791: GO 78969
78793: LD_INT 16
78795: DOUBLE
78796: EQUAL
78797: IFTRUE 78801
78799: GO 78828
78801: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78802: LD_ADDR_VAR 0 3
78806: PUSH
78807: LD_EXP 107
78811: PPUSH
78812: LD_VAR 0 1
78816: PPUSH
78817: CALL_OW 321
78821: PUSH
78822: LD_INT 2
78824: EQUAL
78825: ST_TO_ADDR
78826: GO 78969
78828: LD_INT 19
78830: DOUBLE
78831: EQUAL
78832: IFTRUE 78842
78834: LD_INT 23
78836: DOUBLE
78837: EQUAL
78838: IFTRUE 78842
78840: GO 78869
78842: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78843: LD_ADDR_VAR 0 3
78847: PUSH
78848: LD_EXP 106
78852: PPUSH
78853: LD_VAR 0 1
78857: PPUSH
78858: CALL_OW 321
78862: PUSH
78863: LD_INT 2
78865: EQUAL
78866: ST_TO_ADDR
78867: GO 78969
78869: LD_INT 17
78871: DOUBLE
78872: EQUAL
78873: IFTRUE 78877
78875: GO 78902
78877: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78878: LD_ADDR_VAR 0 3
78882: PUSH
78883: LD_INT 39
78885: PPUSH
78886: LD_VAR 0 1
78890: PPUSH
78891: CALL_OW 321
78895: PUSH
78896: LD_INT 2
78898: EQUAL
78899: ST_TO_ADDR
78900: GO 78969
78902: LD_INT 18
78904: DOUBLE
78905: EQUAL
78906: IFTRUE 78910
78908: GO 78935
78910: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78911: LD_ADDR_VAR 0 3
78915: PUSH
78916: LD_INT 40
78918: PPUSH
78919: LD_VAR 0 1
78923: PPUSH
78924: CALL_OW 321
78928: PUSH
78929: LD_INT 2
78931: EQUAL
78932: ST_TO_ADDR
78933: GO 78969
78935: LD_INT 27
78937: DOUBLE
78938: EQUAL
78939: IFTRUE 78943
78941: GO 78968
78943: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78944: LD_ADDR_VAR 0 3
78948: PUSH
78949: LD_INT 35
78951: PPUSH
78952: LD_VAR 0 1
78956: PPUSH
78957: CALL_OW 321
78961: PUSH
78962: LD_INT 2
78964: EQUAL
78965: ST_TO_ADDR
78966: GO 78969
78968: POP
// end ;
78969: LD_VAR 0 3
78973: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78974: LD_INT 0
78976: PPUSH
78977: PPUSH
78978: PPUSH
78979: PPUSH
78980: PPUSH
78981: PPUSH
78982: PPUSH
78983: PPUSH
78984: PPUSH
78985: PPUSH
78986: PPUSH
// result := false ;
78987: LD_ADDR_VAR 0 6
78991: PUSH
78992: LD_INT 0
78994: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78995: LD_VAR 0 1
78999: NOT
79000: PUSH
79001: LD_VAR 0 1
79005: PPUSH
79006: CALL_OW 266
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: IN
79021: NOT
79022: OR
79023: PUSH
79024: LD_VAR 0 2
79028: NOT
79029: OR
79030: PUSH
79031: LD_VAR 0 5
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: LD_INT 1
79041: PUSH
79042: LD_INT 2
79044: PUSH
79045: LD_INT 3
79047: PUSH
79048: LD_INT 4
79050: PUSH
79051: LD_INT 5
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: IN
79062: NOT
79063: OR
79064: PUSH
79065: LD_VAR 0 3
79069: PPUSH
79070: LD_VAR 0 4
79074: PPUSH
79075: CALL_OW 488
79079: NOT
79080: OR
79081: IFFALSE 79085
// exit ;
79083: GO 79821
// side := GetSide ( depot ) ;
79085: LD_ADDR_VAR 0 9
79089: PUSH
79090: LD_VAR 0 1
79094: PPUSH
79095: CALL_OW 255
79099: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79100: LD_VAR 0 9
79104: PPUSH
79105: LD_VAR 0 2
79109: PPUSH
79110: CALL 78594 0 2
79114: NOT
79115: IFFALSE 79119
// exit ;
79117: GO 79821
// pom := GetBase ( depot ) ;
79119: LD_ADDR_VAR 0 10
79123: PUSH
79124: LD_VAR 0 1
79128: PPUSH
79129: CALL_OW 274
79133: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79134: LD_ADDR_VAR 0 11
79138: PUSH
79139: LD_VAR 0 2
79143: PPUSH
79144: LD_VAR 0 1
79148: PPUSH
79149: CALL_OW 248
79153: PPUSH
79154: CALL_OW 450
79158: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79159: LD_VAR 0 10
79163: PPUSH
79164: LD_INT 1
79166: PPUSH
79167: CALL_OW 275
79171: PUSH
79172: LD_VAR 0 11
79176: PUSH
79177: LD_INT 1
79179: ARRAY
79180: GREATEREQUAL
79181: PUSH
79182: LD_VAR 0 10
79186: PPUSH
79187: LD_INT 2
79189: PPUSH
79190: CALL_OW 275
79194: PUSH
79195: LD_VAR 0 11
79199: PUSH
79200: LD_INT 2
79202: ARRAY
79203: GREATEREQUAL
79204: AND
79205: PUSH
79206: LD_VAR 0 10
79210: PPUSH
79211: LD_INT 3
79213: PPUSH
79214: CALL_OW 275
79218: PUSH
79219: LD_VAR 0 11
79223: PUSH
79224: LD_INT 3
79226: ARRAY
79227: GREATEREQUAL
79228: AND
79229: NOT
79230: IFFALSE 79234
// exit ;
79232: GO 79821
// if GetBType ( depot ) = b_depot then
79234: LD_VAR 0 1
79238: PPUSH
79239: CALL_OW 266
79243: PUSH
79244: LD_INT 0
79246: EQUAL
79247: IFFALSE 79259
// dist := 28 else
79249: LD_ADDR_VAR 0 14
79253: PUSH
79254: LD_INT 28
79256: ST_TO_ADDR
79257: GO 79267
// dist := 36 ;
79259: LD_ADDR_VAR 0 14
79263: PUSH
79264: LD_INT 36
79266: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79267: LD_VAR 0 1
79271: PPUSH
79272: LD_VAR 0 3
79276: PPUSH
79277: LD_VAR 0 4
79281: PPUSH
79282: CALL_OW 297
79286: PUSH
79287: LD_VAR 0 14
79291: GREATER
79292: IFFALSE 79296
// exit ;
79294: GO 79821
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79296: LD_ADDR_VAR 0 12
79300: PUSH
79301: LD_VAR 0 2
79305: PPUSH
79306: LD_VAR 0 3
79310: PPUSH
79311: LD_VAR 0 4
79315: PPUSH
79316: LD_VAR 0 5
79320: PPUSH
79321: LD_VAR 0 1
79325: PPUSH
79326: CALL_OW 248
79330: PPUSH
79331: LD_INT 0
79333: PPUSH
79334: CALL 79826 0 6
79338: ST_TO_ADDR
// if not hexes then
79339: LD_VAR 0 12
79343: NOT
79344: IFFALSE 79348
// exit ;
79346: GO 79821
// hex := GetHexInfo ( x , y ) ;
79348: LD_ADDR_VAR 0 15
79352: PUSH
79353: LD_VAR 0 3
79357: PPUSH
79358: LD_VAR 0 4
79362: PPUSH
79363: CALL_OW 546
79367: ST_TO_ADDR
// if hex [ 1 ] then
79368: LD_VAR 0 15
79372: PUSH
79373: LD_INT 1
79375: ARRAY
79376: IFFALSE 79380
// exit ;
79378: GO 79821
// height := hex [ 2 ] ;
79380: LD_ADDR_VAR 0 13
79384: PUSH
79385: LD_VAR 0 15
79389: PUSH
79390: LD_INT 2
79392: ARRAY
79393: ST_TO_ADDR
// for i = 1 to hexes do
79394: LD_ADDR_VAR 0 7
79398: PUSH
79399: DOUBLE
79400: LD_INT 1
79402: DEC
79403: ST_TO_ADDR
79404: LD_VAR 0 12
79408: PUSH
79409: FOR_TO
79410: IFFALSE 79740
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79412: LD_VAR 0 12
79416: PUSH
79417: LD_VAR 0 7
79421: ARRAY
79422: PUSH
79423: LD_INT 1
79425: ARRAY
79426: PPUSH
79427: LD_VAR 0 12
79431: PUSH
79432: LD_VAR 0 7
79436: ARRAY
79437: PUSH
79438: LD_INT 2
79440: ARRAY
79441: PPUSH
79442: CALL_OW 488
79446: NOT
79447: PUSH
79448: LD_VAR 0 12
79452: PUSH
79453: LD_VAR 0 7
79457: ARRAY
79458: PUSH
79459: LD_INT 1
79461: ARRAY
79462: PPUSH
79463: LD_VAR 0 12
79467: PUSH
79468: LD_VAR 0 7
79472: ARRAY
79473: PUSH
79474: LD_INT 2
79476: ARRAY
79477: PPUSH
79478: CALL_OW 428
79482: PUSH
79483: LD_INT 0
79485: GREATER
79486: OR
79487: PUSH
79488: LD_VAR 0 12
79492: PUSH
79493: LD_VAR 0 7
79497: ARRAY
79498: PUSH
79499: LD_INT 1
79501: ARRAY
79502: PPUSH
79503: LD_VAR 0 12
79507: PUSH
79508: LD_VAR 0 7
79512: ARRAY
79513: PUSH
79514: LD_INT 2
79516: ARRAY
79517: PPUSH
79518: CALL_OW 351
79522: OR
79523: IFFALSE 79529
// exit ;
79525: POP
79526: POP
79527: GO 79821
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79529: LD_ADDR_VAR 0 8
79533: PUSH
79534: LD_VAR 0 12
79538: PUSH
79539: LD_VAR 0 7
79543: ARRAY
79544: PUSH
79545: LD_INT 1
79547: ARRAY
79548: PPUSH
79549: LD_VAR 0 12
79553: PUSH
79554: LD_VAR 0 7
79558: ARRAY
79559: PUSH
79560: LD_INT 2
79562: ARRAY
79563: PPUSH
79564: CALL_OW 546
79568: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79569: LD_VAR 0 8
79573: PUSH
79574: LD_INT 1
79576: ARRAY
79577: PUSH
79578: LD_VAR 0 8
79582: PUSH
79583: LD_INT 2
79585: ARRAY
79586: PUSH
79587: LD_VAR 0 13
79591: PUSH
79592: LD_INT 2
79594: PLUS
79595: GREATER
79596: OR
79597: PUSH
79598: LD_VAR 0 8
79602: PUSH
79603: LD_INT 2
79605: ARRAY
79606: PUSH
79607: LD_VAR 0 13
79611: PUSH
79612: LD_INT 2
79614: MINUS
79615: LESS
79616: OR
79617: PUSH
79618: LD_VAR 0 8
79622: PUSH
79623: LD_INT 3
79625: ARRAY
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: LD_INT 8
79632: PUSH
79633: LD_INT 9
79635: PUSH
79636: LD_INT 10
79638: PUSH
79639: LD_INT 11
79641: PUSH
79642: LD_INT 12
79644: PUSH
79645: LD_INT 13
79647: PUSH
79648: LD_INT 16
79650: PUSH
79651: LD_INT 17
79653: PUSH
79654: LD_INT 18
79656: PUSH
79657: LD_INT 19
79659: PUSH
79660: LD_INT 20
79662: PUSH
79663: LD_INT 21
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: IN
79681: NOT
79682: OR
79683: PUSH
79684: LD_VAR 0 8
79688: PUSH
79689: LD_INT 5
79691: ARRAY
79692: NOT
79693: OR
79694: PUSH
79695: LD_VAR 0 8
79699: PUSH
79700: LD_INT 6
79702: ARRAY
79703: PUSH
79704: LD_INT 1
79706: PUSH
79707: LD_INT 2
79709: PUSH
79710: LD_INT 7
79712: PUSH
79713: LD_INT 9
79715: PUSH
79716: LD_INT 10
79718: PUSH
79719: LD_INT 11
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: IN
79730: NOT
79731: OR
79732: IFFALSE 79738
// exit ;
79734: POP
79735: POP
79736: GO 79821
// end ;
79738: GO 79409
79740: POP
79741: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79742: LD_VAR 0 9
79746: PPUSH
79747: LD_VAR 0 3
79751: PPUSH
79752: LD_VAR 0 4
79756: PPUSH
79757: LD_INT 20
79759: PPUSH
79760: CALL 71767 0 4
79764: PUSH
79765: LD_INT 4
79767: ARRAY
79768: IFFALSE 79772
// exit ;
79770: GO 79821
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79772: LD_VAR 0 2
79776: PUSH
79777: LD_INT 29
79779: PUSH
79780: LD_INT 30
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: IN
79787: PUSH
79788: LD_VAR 0 3
79792: PPUSH
79793: LD_VAR 0 4
79797: PPUSH
79798: LD_VAR 0 9
79802: PPUSH
79803: CALL_OW 440
79807: NOT
79808: AND
79809: IFFALSE 79813
// exit ;
79811: GO 79821
// result := true ;
79813: LD_ADDR_VAR 0 6
79817: PUSH
79818: LD_INT 1
79820: ST_TO_ADDR
// end ;
79821: LD_VAR 0 6
79825: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79826: LD_INT 0
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
79833: PPUSH
79834: PPUSH
79835: PPUSH
79836: PPUSH
79837: PPUSH
79838: PPUSH
79839: PPUSH
79840: PPUSH
79841: PPUSH
79842: PPUSH
79843: PPUSH
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
79851: PPUSH
79852: PPUSH
79853: PPUSH
79854: PPUSH
79855: PPUSH
79856: PPUSH
79857: PPUSH
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
79878: PPUSH
79879: PPUSH
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
// result = [ ] ;
79886: LD_ADDR_VAR 0 7
79890: PUSH
79891: EMPTY
79892: ST_TO_ADDR
// temp_list = [ ] ;
79893: LD_ADDR_VAR 0 9
79897: PUSH
79898: EMPTY
79899: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79900: LD_VAR 0 4
79904: PUSH
79905: LD_INT 0
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: LD_INT 2
79913: PUSH
79914: LD_INT 3
79916: PUSH
79917: LD_INT 4
79919: PUSH
79920: LD_INT 5
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: IN
79931: NOT
79932: PUSH
79933: LD_VAR 0 1
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: IN
79948: PUSH
79949: LD_VAR 0 5
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 3
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: LIST
79967: IN
79968: NOT
79969: AND
79970: OR
79971: IFFALSE 79975
// exit ;
79973: GO 98366
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79975: LD_VAR 0 1
79979: PUSH
79980: LD_INT 6
79982: PUSH
79983: LD_INT 7
79985: PUSH
79986: LD_INT 8
79988: PUSH
79989: LD_INT 13
79991: PUSH
79992: LD_INT 12
79994: PUSH
79995: LD_INT 15
79997: PUSH
79998: LD_INT 11
80000: PUSH
80001: LD_INT 14
80003: PUSH
80004: LD_INT 10
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: IN
80018: IFFALSE 80028
// btype = b_lab ;
80020: LD_ADDR_VAR 0 1
80024: PUSH
80025: LD_INT 6
80027: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80028: LD_VAR 0 6
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: LD_INT 1
80038: PUSH
80039: LD_INT 2
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: LIST
80046: IN
80047: NOT
80048: PUSH
80049: LD_VAR 0 1
80053: PUSH
80054: LD_INT 0
80056: PUSH
80057: LD_INT 1
80059: PUSH
80060: LD_INT 2
80062: PUSH
80063: LD_INT 3
80065: PUSH
80066: LD_INT 6
80068: PUSH
80069: LD_INT 36
80071: PUSH
80072: LD_INT 4
80074: PUSH
80075: LD_INT 5
80077: PUSH
80078: LD_INT 31
80080: PUSH
80081: LD_INT 32
80083: PUSH
80084: LD_INT 33
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: IN
80100: NOT
80101: PUSH
80102: LD_VAR 0 6
80106: PUSH
80107: LD_INT 1
80109: EQUAL
80110: AND
80111: OR
80112: PUSH
80113: LD_VAR 0 1
80117: PUSH
80118: LD_INT 2
80120: PUSH
80121: LD_INT 3
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: IN
80128: NOT
80129: PUSH
80130: LD_VAR 0 6
80134: PUSH
80135: LD_INT 2
80137: EQUAL
80138: AND
80139: OR
80140: IFFALSE 80150
// mode = 0 ;
80142: LD_ADDR_VAR 0 6
80146: PUSH
80147: LD_INT 0
80149: ST_TO_ADDR
// case mode of 0 :
80150: LD_VAR 0 6
80154: PUSH
80155: LD_INT 0
80157: DOUBLE
80158: EQUAL
80159: IFTRUE 80163
80161: GO 91616
80163: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80164: LD_ADDR_VAR 0 11
80168: PUSH
80169: LD_INT 0
80171: PUSH
80172: LD_INT 0
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 1
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: LD_INT 1
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: NEG
80223: PUSH
80224: LD_INT 0
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: LD_INT 1
80237: NEG
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 0
80257: PUSH
80258: LD_INT 2
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 1
80268: PUSH
80269: LD_INT 1
80271: NEG
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 1
80279: PUSH
80280: LD_INT 2
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 0
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 1
80299: NEG
80300: PUSH
80301: LD_INT 1
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 1
80310: PUSH
80311: LD_INT 3
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 0
80320: PUSH
80321: LD_INT 3
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: LD_INT 2
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80357: LD_ADDR_VAR 0 12
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: LD_INT 0
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: LD_INT 1
80377: NEG
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 1
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 2
80459: PUSH
80460: LD_INT 1
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: NEG
80470: PUSH
80471: LD_INT 1
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 2
80480: NEG
80481: PUSH
80482: LD_INT 0
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 2
80491: NEG
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 2
80503: NEG
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 3
80514: NEG
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 3
80525: NEG
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80553: LD_ADDR_VAR 0 13
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 1
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 1
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 1
80591: PUSH
80592: LD_INT 1
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 0
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 0
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 1
80622: NEG
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: NEG
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 2
80646: PUSH
80647: LD_INT 1
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 2
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 1
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 2
80676: NEG
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 2
80688: NEG
80689: PUSH
80690: LD_INT 2
80692: NEG
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 2
80700: NEG
80701: PUSH
80702: LD_INT 3
80704: NEG
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 3
80712: NEG
80713: PUSH
80714: LD_INT 2
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 3
80724: NEG
80725: PUSH
80726: LD_INT 3
80728: NEG
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80752: LD_ADDR_VAR 0 14
80756: PUSH
80757: LD_INT 0
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: LD_INT 1
80772: NEG
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 1
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: LD_INT 1
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 1
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: NEG
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: LD_INT 2
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 1
80856: PUSH
80857: LD_INT 1
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: LD_INT 2
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: LD_INT 2
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 1
80887: NEG
80888: PUSH
80889: LD_INT 1
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: LD_INT 3
80902: NEG
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: LD_INT 3
80913: NEG
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 1
80921: PUSH
80922: LD_INT 2
80924: NEG
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80948: LD_ADDR_VAR 0 15
80952: PUSH
80953: LD_INT 0
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 0
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 0
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 1
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: NEG
81007: PUSH
81008: LD_INT 0
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: LD_INT 1
81032: NEG
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 2
81040: PUSH
81041: LD_INT 0
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: NEG
81072: PUSH
81073: LD_INT 0
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 2
81082: NEG
81083: PUSH
81084: LD_INT 1
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 2
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 3
81105: PUSH
81106: LD_INT 0
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 3
81115: PUSH
81116: LD_INT 1
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81141: LD_ADDR_VAR 0 16
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 1
81161: NEG
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: LD_INT 1
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 1
81210: NEG
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: LD_INT 2
81226: NEG
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 2
81234: PUSH
81235: LD_INT 1
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 2
81244: PUSH
81245: LD_INT 2
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 1
81254: PUSH
81255: LD_INT 2
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 2
81264: NEG
81265: PUSH
81266: LD_INT 1
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 2
81276: NEG
81277: PUSH
81278: LD_INT 2
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 3
81288: PUSH
81289: LD_INT 2
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 3
81298: PUSH
81299: LD_INT 3
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: PUSH
81309: LD_INT 3
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81334: LD_ADDR_VAR 0 17
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: LD_INT 0
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: LD_INT 1
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: LD_INT 0
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 1
81372: PUSH
81373: LD_INT 1
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 1
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: NEG
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 1
81403: NEG
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 1
81415: NEG
81416: PUSH
81417: LD_INT 2
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 0
81427: PUSH
81428: LD_INT 2
81430: NEG
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: PUSH
81439: LD_INT 1
81441: NEG
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: LD_INT 0
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 2
81459: PUSH
81460: LD_INT 1
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 2
81469: PUSH
81470: LD_INT 2
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 1
81479: PUSH
81480: LD_INT 2
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: LD_INT 2
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 1
81499: NEG
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 2
81510: NEG
81511: PUSH
81512: LD_INT 0
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 2
81521: NEG
81522: PUSH
81523: LD_INT 1
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 2
81533: NEG
81534: PUSH
81535: LD_INT 2
81537: NEG
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81564: LD_ADDR_VAR 0 18
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: LD_INT 0
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 0
81581: PUSH
81582: LD_INT 1
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 1
81592: PUSH
81593: LD_INT 0
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 1
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 1
81622: NEG
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 1
81633: NEG
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 0
81657: PUSH
81658: LD_INT 2
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 2
81679: PUSH
81680: LD_INT 0
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 2
81689: PUSH
81690: LD_INT 1
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 2
81699: PUSH
81700: LD_INT 2
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 1
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 0
81719: PUSH
81720: LD_INT 2
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 1
81729: NEG
81730: PUSH
81731: LD_INT 1
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 2
81740: NEG
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: LD_INT 1
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 2
81763: NEG
81764: PUSH
81765: LD_INT 2
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81794: LD_ADDR_VAR 0 19
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: LD_INT 0
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: PUSH
81823: LD_INT 0
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 1
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: LD_INT 1
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: NEG
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 1
81863: NEG
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: EMPTY
81870: LIST
81871: LIST
81872: PUSH
81873: LD_INT 1
81875: NEG
81876: PUSH
81877: LD_INT 2
81879: NEG
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 0
81887: PUSH
81888: LD_INT 2
81890: NEG
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: LD_INT 1
81901: NEG
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 2
81909: PUSH
81910: LD_INT 0
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 2
81919: PUSH
81920: LD_INT 1
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 2
81929: PUSH
81930: LD_INT 2
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 1
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 0
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: LD_INT 1
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 2
81970: NEG
81971: PUSH
81972: LD_INT 0
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: LD_INT 2
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82024: LD_ADDR_VAR 0 20
82028: PUSH
82029: LD_INT 0
82031: PUSH
82032: LD_INT 0
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 1
82052: PUSH
82053: LD_INT 0
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 1
82062: PUSH
82063: LD_INT 1
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 0
82117: PUSH
82118: LD_INT 2
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: PUSH
82129: LD_INT 1
82131: NEG
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: LD_INT 0
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 2
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 2
82159: PUSH
82160: LD_INT 2
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 1
82169: PUSH
82170: LD_INT 2
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 0
82179: PUSH
82180: LD_INT 2
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 1
82189: NEG
82190: PUSH
82191: LD_INT 1
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: LD_INT 0
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: LD_INT 1
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 2
82223: NEG
82224: PUSH
82225: LD_INT 2
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82254: LD_ADDR_VAR 0 21
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: LD_INT 0
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: LD_INT 1
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 1
82292: PUSH
82293: LD_INT 1
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 1
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: NEG
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: NEG
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: LD_INT 2
82339: NEG
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: LD_INT 2
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 1
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 2
82379: PUSH
82380: LD_INT 1
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 2
82389: PUSH
82390: LD_INT 2
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: PUSH
82400: LD_INT 2
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 0
82409: PUSH
82410: LD_INT 2
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 1
82419: NEG
82420: PUSH
82421: LD_INT 1
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 2
82430: NEG
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 2
82441: NEG
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 2
82453: NEG
82454: PUSH
82455: LD_INT 2
82457: NEG
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82484: LD_ADDR_VAR 0 22
82488: PUSH
82489: LD_INT 0
82491: PUSH
82492: LD_INT 0
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 1
82512: PUSH
82513: LD_INT 0
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 1
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: LD_INT 1
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: NEG
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 1
82553: NEG
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: NEG
82566: PUSH
82567: LD_INT 2
82569: NEG
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 0
82577: PUSH
82578: LD_INT 2
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: LD_INT 1
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 2
82619: PUSH
82620: LD_INT 2
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: PUSH
82630: LD_INT 2
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 0
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: LD_INT 1
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 2
82660: NEG
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 2
82671: NEG
82672: PUSH
82673: LD_INT 1
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 2
82683: NEG
82684: PUSH
82685: LD_INT 2
82687: NEG
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82714: LD_ADDR_VAR 0 23
82718: PUSH
82719: LD_INT 0
82721: PUSH
82722: LD_INT 0
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 0
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: PUSH
82743: LD_INT 0
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: PUSH
82753: LD_INT 1
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: LD_INT 1
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: NEG
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 1
82795: NEG
82796: PUSH
82797: LD_INT 2
82799: NEG
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 2
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: LD_INT 1
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: LD_INT 0
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 2
82839: PUSH
82840: LD_INT 1
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 2
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 1
82859: PUSH
82860: LD_INT 2
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 0
82869: PUSH
82870: LD_INT 2
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 1
82879: NEG
82880: PUSH
82881: LD_INT 1
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: NEG
82891: PUSH
82892: LD_INT 0
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 2
82901: NEG
82902: PUSH
82903: LD_INT 1
82905: NEG
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 2
82913: NEG
82914: PUSH
82915: LD_INT 2
82917: NEG
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 2
82925: NEG
82926: PUSH
82927: LD_INT 3
82929: NEG
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 1
82937: NEG
82938: PUSH
82939: LD_INT 3
82941: NEG
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: LD_INT 2
82952: NEG
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 2
82960: PUSH
82961: LD_INT 1
82963: NEG
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82994: LD_ADDR_VAR 0 24
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 0
83011: PUSH
83012: LD_INT 1
83014: NEG
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 0
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 1
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 1
83052: NEG
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: NEG
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 1
83075: NEG
83076: PUSH
83077: LD_INT 2
83079: NEG
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: LD_INT 2
83090: NEG
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 1
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 2
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 2
83129: PUSH
83130: LD_INT 2
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 1
83139: PUSH
83140: LD_INT 2
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 2
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: NEG
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 2
83181: NEG
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: NEG
83194: PUSH
83195: LD_INT 2
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: LD_INT 2
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 3
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 3
83237: PUSH
83238: LD_INT 2
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83270: LD_ADDR_VAR 0 25
83274: PUSH
83275: LD_INT 0
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 1
83298: PUSH
83299: LD_INT 0
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: PUSH
83309: LD_INT 1
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 1
83328: NEG
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: LD_INT 1
83343: NEG
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 1
83351: NEG
83352: PUSH
83353: LD_INT 2
83355: NEG
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: LD_INT 2
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 1
83374: PUSH
83375: LD_INT 1
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 2
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 2
83395: PUSH
83396: LD_INT 1
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 2
83405: PUSH
83406: LD_INT 2
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 1
83415: PUSH
83416: LD_INT 2
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: LD_INT 2
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 1
83435: NEG
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 2
83446: NEG
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 2
83457: NEG
83458: PUSH
83459: LD_INT 1
83461: NEG
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: LD_INT 2
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 3
83481: PUSH
83482: LD_INT 1
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 3
83491: PUSH
83492: LD_INT 2
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 2
83501: PUSH
83502: LD_INT 3
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83544: LD_ADDR_VAR 0 26
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: LD_INT 0
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 0
83561: PUSH
83562: LD_INT 1
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 1
83572: PUSH
83573: LD_INT 0
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 1
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 0
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 1
83602: NEG
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 1
83613: NEG
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: EMPTY
83620: LIST
83621: LIST
83622: PUSH
83623: LD_INT 1
83625: NEG
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: LD_INT 2
83640: NEG
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: PUSH
83649: LD_INT 1
83651: NEG
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: PUSH
83660: LD_INT 0
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: LD_INT 1
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 1
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: LD_INT 1
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: LD_INT 2
83720: NEG
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: LD_INT 1
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 2
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: PUSH
83756: LD_INT 3
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: LD_INT 3
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 1
83775: NEG
83776: PUSH
83777: LD_INT 2
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 2
83786: NEG
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83820: LD_ADDR_VAR 0 27
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 1
83878: NEG
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: NEG
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 2
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 2
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 2
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: NEG
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: NEG
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 1
84031: NEG
84032: PUSH
84033: LD_INT 2
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: NEG
84043: PUSH
84044: LD_INT 1
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 3
84053: NEG
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 3
84065: NEG
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84100: LD_ADDR_VAR 0 28
84104: PUSH
84105: LD_INT 0
84107: PUSH
84108: LD_INT 0
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 0
84117: PUSH
84118: LD_INT 1
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 1
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 1
84138: PUSH
84139: LD_INT 1
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 0
84148: PUSH
84149: LD_INT 1
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 1
84158: NEG
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: LD_INT 1
84173: NEG
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: LD_INT 2
84185: NEG
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 2
84196: NEG
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 1
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 2
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 2
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 2
84235: PUSH
84236: LD_INT 2
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 1
84245: PUSH
84246: LD_INT 2
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 1
84265: NEG
84266: PUSH
84267: LD_INT 1
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 2
84287: NEG
84288: PUSH
84289: LD_INT 1
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: LD_INT 2
84303: NEG
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 2
84311: NEG
84312: PUSH
84313: LD_INT 3
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: NEG
84324: PUSH
84325: LD_INT 3
84327: NEG
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 3
84335: NEG
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 3
84347: NEG
84348: PUSH
84349: LD_INT 2
84351: NEG
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84382: LD_ADDR_VAR 0 29
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 0
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 0
84399: PUSH
84400: LD_INT 1
84402: NEG
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 1
84410: PUSH
84411: LD_INT 0
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 1
84420: PUSH
84421: LD_INT 1
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: LD_INT 1
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 1
84440: NEG
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: LD_INT 1
84463: NEG
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 0
84475: PUSH
84476: LD_INT 2
84478: NEG
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: LD_INT 1
84489: NEG
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 2
84497: PUSH
84498: LD_INT 0
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 2
84507: PUSH
84508: LD_INT 1
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 2
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 2
84548: NEG
84549: PUSH
84550: LD_INT 1
84552: NEG
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 2
84560: NEG
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 2
84572: NEG
84573: PUSH
84574: LD_INT 3
84576: NEG
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: LD_INT 1
84587: NEG
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 3
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: LD_INT 3
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 1
84615: NEG
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 3
84626: NEG
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84661: LD_ADDR_VAR 0 30
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 0
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: PUSH
84690: LD_INT 0
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 1
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: NEG
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 1
84768: NEG
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 2
84776: PUSH
84777: LD_INT 0
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 2
84786: PUSH
84787: LD_INT 1
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 2
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: NEG
84828: PUSH
84829: LD_INT 0
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 2
84838: NEG
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: NEG
84851: PUSH
84852: LD_INT 3
84854: NEG
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: PUSH
84860: LD_INT 1
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 3
84873: PUSH
84874: LD_INT 2
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 2
84883: PUSH
84884: LD_INT 3
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 2
84893: NEG
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 3
84904: NEG
84905: PUSH
84906: LD_INT 1
84908: NEG
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84939: LD_ADDR_VAR 0 31
84943: PUSH
84944: LD_INT 0
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 2
85043: PUSH
85044: LD_INT 0
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 2
85053: PUSH
85054: LD_INT 1
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 2
85063: PUSH
85064: LD_INT 2
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: LD_INT 2
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: LD_INT 2
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: LD_INT 1
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 2
85104: NEG
85105: PUSH
85106: LD_INT 1
85108: NEG
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 2
85116: NEG
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 2
85128: NEG
85129: PUSH
85130: LD_INT 3
85132: NEG
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 2
85140: PUSH
85141: LD_INT 1
85143: NEG
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 3
85151: PUSH
85152: LD_INT 1
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: LD_INT 3
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: NEG
85172: PUSH
85173: LD_INT 2
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 3
85182: NEG
85183: PUSH
85184: LD_INT 2
85186: NEG
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85217: LD_ADDR_VAR 0 32
85221: PUSH
85222: LD_INT 0
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: LD_INT 1
85237: NEG
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: NEG
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 2
85302: NEG
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 0
85310: PUSH
85311: LD_INT 2
85313: NEG
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 2
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 2
85342: PUSH
85343: LD_INT 2
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 2
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 0
85362: PUSH
85363: LD_INT 2
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 1
85372: NEG
85373: PUSH
85374: LD_INT 1
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: NEG
85384: PUSH
85385: LD_INT 0
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: LD_INT 2
85394: NEG
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: LD_INT 3
85410: NEG
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 1
85418: PUSH
85419: LD_INT 2
85421: NEG
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 3
85429: PUSH
85430: LD_INT 2
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 2
85439: PUSH
85440: LD_INT 3
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 2
85449: NEG
85450: PUSH
85451: LD_INT 1
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 3
85460: NEG
85461: PUSH
85462: LD_INT 1
85464: NEG
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85495: LD_ADDR_VAR 0 33
85499: PUSH
85500: LD_INT 0
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 0
85512: PUSH
85513: LD_INT 1
85515: NEG
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 0
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: NEG
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 2
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 0
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 1
85639: NEG
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: NEG
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 2
85661: NEG
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: NEG
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 2
85685: NEG
85686: PUSH
85687: LD_INT 3
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 2
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 3
85708: PUSH
85709: LD_INT 1
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 1
85718: PUSH
85719: LD_INT 3
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 1
85728: NEG
85729: PUSH
85730: LD_INT 2
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 3
85739: NEG
85740: PUSH
85741: LD_INT 2
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85774: LD_ADDR_VAR 0 34
85778: PUSH
85779: LD_INT 0
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 0
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 1
85812: PUSH
85813: LD_INT 1
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 0
85822: PUSH
85823: LD_INT 1
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: NEG
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: LD_INT 1
85847: NEG
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: LD_INT 2
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 0
85867: PUSH
85868: LD_INT 2
85870: NEG
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: LD_INT 1
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 2
85889: PUSH
85890: LD_INT 1
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 2
85899: PUSH
85900: LD_INT 2
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 1
85919: NEG
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 2
85930: NEG
85931: PUSH
85932: LD_INT 0
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 2
85941: NEG
85942: PUSH
85943: LD_INT 1
85945: NEG
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 2
85953: NEG
85954: PUSH
85955: LD_INT 2
85957: NEG
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: LD_INT 3
85969: NEG
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: LD_INT 2
85980: NEG
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 3
85988: PUSH
85989: LD_INT 2
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: LD_INT 3
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 2
86008: NEG
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 3
86019: NEG
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86054: LD_ADDR_VAR 0 35
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 0
86071: PUSH
86072: LD_INT 1
86074: NEG
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 1
86082: PUSH
86083: LD_INT 0
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 1
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: NEG
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: LD_INT 1
86149: NEG
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86166: LD_ADDR_VAR 0 36
86170: PUSH
86171: LD_INT 0
86173: PUSH
86174: LD_INT 0
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: LD_INT 1
86186: NEG
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: LD_INT 1
86194: PUSH
86195: LD_INT 0
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 1
86204: PUSH
86205: LD_INT 1
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: LD_INT 1
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: NEG
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 1
86235: NEG
86236: PUSH
86237: LD_INT 1
86239: NEG
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 2
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: LD_INT 2
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86278: LD_ADDR_VAR 0 37
86282: PUSH
86283: LD_INT 0
86285: PUSH
86286: LD_INT 0
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 0
86295: PUSH
86296: LD_INT 1
86298: NEG
86299: PUSH
86300: EMPTY
86301: LIST
86302: LIST
86303: PUSH
86304: LD_INT 1
86306: PUSH
86307: LD_INT 0
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: LD_INT 1
86316: PUSH
86317: LD_INT 1
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: LD_INT 1
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PUSH
86334: LD_INT 1
86336: NEG
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 1
86347: NEG
86348: PUSH
86349: LD_INT 1
86351: NEG
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86390: LD_ADDR_VAR 0 38
86394: PUSH
86395: LD_INT 0
86397: PUSH
86398: LD_INT 0
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 0
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 1
86418: PUSH
86419: LD_INT 0
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 1
86428: PUSH
86429: LD_INT 1
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: LD_INT 1
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: NEG
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: LD_INT 1
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 2
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 2
86481: NEG
86482: PUSH
86483: LD_INT 1
86485: NEG
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86502: LD_ADDR_VAR 0 39
86506: PUSH
86507: LD_INT 0
86509: PUSH
86510: LD_INT 0
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: PUSH
86531: LD_INT 0
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 1
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 1
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: NEG
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: NEG
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: NEG
86584: PUSH
86585: LD_INT 2
86587: NEG
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: LD_INT 2
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86614: LD_ADDR_VAR 0 40
86618: PUSH
86619: LD_INT 0
86621: PUSH
86622: LD_INT 0
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 0
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 1
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 1
86652: PUSH
86653: LD_INT 1
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: LD_INT 1
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: NEG
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 1
86683: NEG
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: PUSH
86696: LD_INT 1
86698: NEG
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 1
86706: NEG
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86726: LD_ADDR_VAR 0 41
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 1
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: LD_INT 1
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 0
86774: PUSH
86775: LD_INT 1
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: NEG
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: LD_INT 2
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 2
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 2
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 2
86850: PUSH
86851: LD_INT 2
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 1
86860: PUSH
86861: LD_INT 2
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 2
86881: NEG
86882: PUSH
86883: LD_INT 0
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 2
86892: NEG
86893: PUSH
86894: LD_INT 1
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 2
86916: NEG
86917: PUSH
86918: LD_INT 3
86920: NEG
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: LD_INT 1
86931: NEG
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 3
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 3
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 3
86959: PUSH
86960: LD_INT 2
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 3
86969: PUSH
86970: LD_INT 3
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: PUSH
86980: LD_INT 3
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 2
86989: NEG
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 3
87000: NEG
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 3
87011: NEG
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 3
87023: NEG
87024: PUSH
87025: LD_INT 2
87027: NEG
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 3
87035: NEG
87036: PUSH
87037: LD_INT 3
87039: NEG
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87076: LD_ADDR_VAR 0 42
87080: PUSH
87081: LD_INT 0
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: LD_INT 1
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 1
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 1
87157: NEG
87158: PUSH
87159: LD_INT 2
87161: NEG
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 2
87172: NEG
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 2
87201: PUSH
87202: LD_INT 2
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: LD_INT 2
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 0
87221: PUSH
87222: LD_INT 2
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 1
87231: NEG
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 2
87242: NEG
87243: PUSH
87244: LD_INT 1
87246: NEG
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 2
87254: NEG
87255: PUSH
87256: LD_INT 2
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: NEG
87267: PUSH
87268: LD_INT 3
87270: NEG
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 1
87278: NEG
87279: PUSH
87280: LD_INT 3
87282: NEG
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 0
87290: PUSH
87291: LD_INT 3
87293: NEG
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 1
87301: PUSH
87302: LD_INT 2
87304: NEG
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: LD_INT 2
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 3
87322: PUSH
87323: LD_INT 3
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: LD_INT 3
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: LD_INT 3
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: LD_INT 3
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: PUSH
87364: LD_INT 2
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 3
87373: NEG
87374: PUSH
87375: LD_INT 2
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 3
87385: NEG
87386: PUSH
87387: LD_INT 3
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87426: LD_ADDR_VAR 0 43
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 0
87443: PUSH
87444: LD_INT 1
87446: NEG
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: LD_INT 0
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 1
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 0
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 1
87484: NEG
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: LD_INT 1
87499: NEG
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: LD_INT 2
87511: NEG
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: LD_INT 2
87522: NEG
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: LD_INT 1
87533: NEG
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: LD_INT 0
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 2
87551: PUSH
87552: LD_INT 1
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 1
87581: NEG
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 2
87592: NEG
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: NEG
87604: PUSH
87605: LD_INT 1
87607: NEG
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 1
87615: NEG
87616: PUSH
87617: LD_INT 3
87619: NEG
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 0
87627: PUSH
87628: LD_INT 3
87630: NEG
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 1
87638: PUSH
87639: LD_INT 2
87641: NEG
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 2
87649: PUSH
87650: LD_INT 1
87652: NEG
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 3
87660: PUSH
87661: LD_INT 0
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: LD_INT 3
87670: PUSH
87671: LD_INT 1
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 1
87680: PUSH
87681: LD_INT 3
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 0
87690: PUSH
87691: LD_INT 3
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 1
87700: NEG
87701: PUSH
87702: LD_INT 2
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 2
87711: NEG
87712: PUSH
87713: LD_INT 1
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 3
87722: NEG
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 3
87733: NEG
87734: PUSH
87735: LD_INT 1
87737: NEG
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87774: LD_ADDR_VAR 0 44
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 0
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 0
87791: PUSH
87792: LD_INT 1
87794: NEG
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: PUSH
87813: LD_INT 1
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 0
87822: PUSH
87823: LD_INT 1
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PUSH
87830: LD_INT 1
87832: NEG
87833: PUSH
87834: LD_INT 0
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 1
87843: NEG
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: LD_INT 2
87859: NEG
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 1
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 2
87898: PUSH
87899: LD_INT 2
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 1
87908: PUSH
87909: LD_INT 2
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 1
87918: NEG
87919: PUSH
87920: LD_INT 1
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 2
87929: NEG
87930: PUSH
87931: LD_INT 0
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: LD_INT 1
87944: NEG
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 2
87964: NEG
87965: PUSH
87966: LD_INT 3
87968: NEG
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: LD_INT 1
87979: NEG
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 3
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 3
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 3
88007: PUSH
88008: LD_INT 2
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 3
88017: PUSH
88018: LD_INT 3
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 2
88027: PUSH
88028: LD_INT 3
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 2
88037: NEG
88038: PUSH
88039: LD_INT 1
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 3
88048: NEG
88049: PUSH
88050: LD_INT 0
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 3
88059: NEG
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 3
88071: NEG
88072: PUSH
88073: LD_INT 2
88075: NEG
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 3
88083: NEG
88084: PUSH
88085: LD_INT 3
88087: NEG
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88124: LD_ADDR_VAR 0 45
88128: PUSH
88129: LD_INT 0
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 0
88141: PUSH
88142: LD_INT 1
88144: NEG
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 1
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: NEG
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 1
88205: NEG
88206: PUSH
88207: LD_INT 2
88209: NEG
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 2
88220: NEG
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 1
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 2
88239: PUSH
88240: LD_INT 1
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 2
88249: PUSH
88250: LD_INT 2
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: PUSH
88260: LD_INT 2
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 1
88279: NEG
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 2
88290: NEG
88291: PUSH
88292: LD_INT 1
88294: NEG
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 2
88302: NEG
88303: PUSH
88304: LD_INT 2
88306: NEG
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: NEG
88315: PUSH
88316: LD_INT 3
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: NEG
88327: PUSH
88328: LD_INT 3
88330: NEG
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 0
88338: PUSH
88339: LD_INT 3
88341: NEG
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: LD_INT 2
88352: NEG
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 3
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 3
88370: PUSH
88371: LD_INT 3
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 2
88380: PUSH
88381: LD_INT 3
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 1
88390: PUSH
88391: LD_INT 3
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 0
88400: PUSH
88401: LD_INT 3
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: LD_INT 2
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 3
88421: NEG
88422: PUSH
88423: LD_INT 2
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 3
88433: NEG
88434: PUSH
88435: LD_INT 3
88437: NEG
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88474: LD_ADDR_VAR 0 46
88478: PUSH
88479: LD_INT 0
88481: PUSH
88482: LD_INT 0
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 0
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 1
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: NEG
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: NEG
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 1
88555: NEG
88556: PUSH
88557: LD_INT 2
88559: NEG
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: LD_INT 2
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 1
88578: PUSH
88579: LD_INT 1
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 2
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 2
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 1
88629: NEG
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 2
88640: NEG
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 2
88651: NEG
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: NEG
88664: PUSH
88665: LD_INT 3
88667: NEG
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: LD_INT 3
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: PUSH
88687: LD_INT 2
88689: NEG
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: LD_INT 1
88700: NEG
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PUSH
88706: LD_INT 3
88708: PUSH
88709: LD_INT 0
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 3
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: LD_INT 1
88728: PUSH
88729: LD_INT 3
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: LD_INT 3
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 1
88748: NEG
88749: PUSH
88750: LD_INT 2
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 2
88759: NEG
88760: PUSH
88761: LD_INT 1
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 3
88770: NEG
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 3
88781: NEG
88782: PUSH
88783: LD_INT 1
88785: NEG
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88822: LD_ADDR_VAR 0 47
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: LD_INT 0
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: LD_INT 1
88842: NEG
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 1
88850: PUSH
88851: LD_INT 0
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 1
88860: PUSH
88861: LD_INT 1
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: LD_INT 1
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 1
88880: NEG
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 1
88891: NEG
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: LD_INT 2
88907: NEG
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 0
88915: PUSH
88916: LD_INT 2
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: LD_INT 1
88929: NEG
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 2
88937: NEG
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 2
88949: NEG
88950: PUSH
88951: LD_INT 2
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88973: LD_ADDR_VAR 0 48
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 0
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: LD_INT 0
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 1
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: LD_INT 2
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: LD_INT 1
89080: NEG
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 2
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 2
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89120: LD_ADDR_VAR 0 49
89124: PUSH
89125: LD_INT 0
89127: PUSH
89128: LD_INT 0
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: LD_INT 1
89140: NEG
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: NEG
89190: PUSH
89191: LD_INT 1
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 2
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 2
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 2
89232: PUSH
89233: LD_INT 2
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89264: LD_ADDR_VAR 0 50
89268: PUSH
89269: LD_INT 0
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 0
89281: PUSH
89282: LD_INT 1
89284: NEG
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: LD_INT 0
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: PUSH
89303: LD_INT 1
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 0
89312: PUSH
89313: LD_INT 1
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: NEG
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 1
89333: NEG
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 2
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 2
89355: PUSH
89356: LD_INT 2
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 2
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: LD_INT 2
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89408: LD_ADDR_VAR 0 51
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: PUSH
89490: LD_INT 2
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: LD_INT 0
89499: PUSH
89500: LD_INT 2
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 1
89509: NEG
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 2
89520: NEG
89521: PUSH
89522: LD_INT 0
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 2
89531: NEG
89532: PUSH
89533: LD_INT 1
89535: NEG
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89555: LD_ADDR_VAR 0 52
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: LD_INT 0
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 0
89572: PUSH
89573: LD_INT 1
89575: NEG
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 1
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: NEG
89614: PUSH
89615: LD_INT 0
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 2
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: NEG
89649: PUSH
89650: LD_INT 1
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 2
89659: NEG
89660: PUSH
89661: LD_INT 0
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 2
89670: NEG
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 2
89682: NEG
89683: PUSH
89684: LD_INT 2
89686: NEG
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89706: LD_ADDR_VAR 0 53
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: LD_INT 0
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 1
89734: PUSH
89735: LD_INT 0
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 1
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: NEG
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 1
89775: NEG
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: LD_INT 2
89791: NEG
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: LD_INT 2
89802: NEG
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: PUSH
89811: LD_INT 1
89813: NEG
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 2
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: PUSH
89829: LD_INT 2
89831: PUSH
89832: LD_INT 1
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: PUSH
89839: LD_INT 2
89841: PUSH
89842: LD_INT 2
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: PUSH
89852: LD_INT 2
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 0
89861: PUSH
89862: LD_INT 2
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: NEG
89872: PUSH
89873: LD_INT 1
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 2
89882: NEG
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 2
89893: NEG
89894: PUSH
89895: LD_INT 1
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 2
89905: NEG
89906: PUSH
89907: LD_INT 2
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89936: LD_ADDR_VAR 0 54
89940: PUSH
89941: LD_INT 0
89943: PUSH
89944: LD_INT 0
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 0
89953: PUSH
89954: LD_INT 1
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 1
89964: PUSH
89965: LD_INT 0
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 1
89974: PUSH
89975: LD_INT 1
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: LD_INT 1
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: LD_INT 1
90009: NEG
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: LD_INT 2
90021: NEG
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 2
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: PUSH
90041: LD_INT 1
90043: NEG
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 2
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 2
90071: PUSH
90072: LD_INT 2
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 1
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 0
90091: PUSH
90092: LD_INT 2
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 1
90101: NEG
90102: PUSH
90103: LD_INT 1
90105: PUSH
90106: EMPTY
90107: LIST
90108: LIST
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 2
90123: NEG
90124: PUSH
90125: LD_INT 1
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 2
90135: NEG
90136: PUSH
90137: LD_INT 2
90139: NEG
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90166: LD_ADDR_VAR 0 55
90170: PUSH
90171: LD_INT 0
90173: PUSH
90174: LD_INT 0
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: LD_INT 0
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: LD_INT 1
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 1
90224: NEG
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 1
90235: NEG
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: NEG
90248: PUSH
90249: LD_INT 2
90251: NEG
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 0
90259: PUSH
90260: LD_INT 2
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: LD_INT 1
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 2
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: LD_INT 1
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: LD_INT 2
90301: PUSH
90302: LD_INT 2
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: LD_INT 0
90321: PUSH
90322: LD_INT 2
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 1
90331: NEG
90332: PUSH
90333: LD_INT 1
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 2
90342: NEG
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: LD_INT 1
90357: NEG
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 2
90365: NEG
90366: PUSH
90367: LD_INT 2
90369: NEG
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90396: LD_ADDR_VAR 0 56
90400: PUSH
90401: LD_INT 0
90403: PUSH
90404: LD_INT 0
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: LD_INT 1
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 1
90424: PUSH
90425: LD_INT 0
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 1
90434: PUSH
90435: LD_INT 1
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: NEG
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 1
90465: NEG
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: LD_INT 1
90477: NEG
90478: PUSH
90479: LD_INT 2
90481: NEG
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 0
90489: PUSH
90490: LD_INT 2
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 2
90511: PUSH
90512: LD_INT 0
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 2
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 2
90531: PUSH
90532: LD_INT 2
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 1
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 0
90551: PUSH
90552: LD_INT 2
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 1
90561: NEG
90562: PUSH
90563: LD_INT 1
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 2
90572: NEG
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 2
90583: NEG
90584: PUSH
90585: LD_INT 1
90587: NEG
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 2
90595: NEG
90596: PUSH
90597: LD_INT 2
90599: NEG
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90626: LD_ADDR_VAR 0 57
90630: PUSH
90631: LD_INT 0
90633: PUSH
90634: LD_INT 0
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: LD_INT 1
90646: NEG
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 1
90654: PUSH
90655: LD_INT 0
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 1
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 1
90684: NEG
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 1
90695: NEG
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: NEG
90708: PUSH
90709: LD_INT 2
90711: NEG
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: LD_INT 2
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: LD_INT 0
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: LD_INT 1
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 2
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 0
90781: PUSH
90782: LD_INT 2
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 1
90791: NEG
90792: PUSH
90793: LD_INT 1
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 2
90802: NEG
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 2
90813: NEG
90814: PUSH
90815: LD_INT 1
90817: NEG
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 2
90825: NEG
90826: PUSH
90827: LD_INT 2
90829: NEG
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90856: LD_ADDR_VAR 0 58
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 0
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: LD_INT 0
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 0
90904: PUSH
90905: LD_INT 1
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 1
90914: NEG
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 1
90925: NEG
90926: PUSH
90927: LD_INT 1
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: NEG
90938: PUSH
90939: LD_INT 2
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 0
90949: PUSH
90950: LD_INT 2
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: PUSH
90961: LD_INT 1
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 2
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PUSH
90979: LD_INT 2
90981: PUSH
90982: LD_INT 1
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 2
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 1
91001: PUSH
91002: LD_INT 2
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: LD_INT 2
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 1
91021: NEG
91022: PUSH
91023: LD_INT 1
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 2
91032: NEG
91033: PUSH
91034: LD_INT 0
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 2
91043: NEG
91044: PUSH
91045: LD_INT 1
91047: NEG
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 2
91055: NEG
91056: PUSH
91057: LD_INT 2
91059: NEG
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91086: LD_ADDR_VAR 0 59
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: LD_INT 0
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: LD_INT 1
91106: NEG
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 1
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 1
91124: PUSH
91125: LD_INT 1
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 0
91134: PUSH
91135: LD_INT 1
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: NEG
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: NEG
91156: PUSH
91157: LD_INT 1
91159: NEG
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91174: LD_ADDR_VAR 0 60
91178: PUSH
91179: LD_INT 0
91181: PUSH
91182: LD_INT 0
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: LD_INT 1
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: PUSH
91203: LD_INT 0
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: LD_INT 1
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 0
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: NEG
91233: PUSH
91234: LD_INT 0
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: NEG
91244: PUSH
91245: LD_INT 1
91247: NEG
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91262: LD_ADDR_VAR 0 61
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: LD_INT 0
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: LD_INT 1
91282: NEG
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 1
91290: PUSH
91291: LD_INT 0
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 1
91300: PUSH
91301: LD_INT 1
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: LD_INT 1
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: NEG
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91350: LD_ADDR_VAR 0 62
91354: PUSH
91355: LD_INT 0
91357: PUSH
91358: LD_INT 0
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 0
91367: PUSH
91368: LD_INT 1
91370: NEG
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: LD_INT 1
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 0
91398: PUSH
91399: LD_INT 1
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 1
91408: NEG
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: NEG
91420: PUSH
91421: LD_INT 1
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91438: LD_ADDR_VAR 0 63
91442: PUSH
91443: LD_INT 0
91445: PUSH
91446: LD_INT 0
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 0
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: PUSH
91467: LD_INT 0
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: PUSH
91474: LD_INT 1
91476: PUSH
91477: LD_INT 1
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 1
91496: NEG
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 1
91507: NEG
91508: PUSH
91509: LD_INT 1
91511: NEG
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91526: LD_ADDR_VAR 0 64
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: LD_INT 0
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 0
91543: PUSH
91544: LD_INT 1
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 1
91554: PUSH
91555: LD_INT 0
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: LD_INT 1
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: LD_INT 1
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: NEG
91596: PUSH
91597: LD_INT 1
91599: NEG
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// end ; 1 :
91614: GO 97511
91616: LD_INT 1
91618: DOUBLE
91619: EQUAL
91620: IFTRUE 91624
91622: GO 94247
91624: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91625: LD_ADDR_VAR 0 11
91629: PUSH
91630: LD_INT 1
91632: NEG
91633: PUSH
91634: LD_INT 3
91636: NEG
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 0
91644: PUSH
91645: LD_INT 3
91647: NEG
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: LD_INT 2
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91669: LD_ADDR_VAR 0 12
91673: PUSH
91674: LD_INT 2
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 3
91687: PUSH
91688: LD_INT 0
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: LD_INT 3
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91710: LD_ADDR_VAR 0 13
91714: PUSH
91715: LD_INT 3
91717: PUSH
91718: LD_INT 2
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: LD_INT 3
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: LD_INT 2
91737: PUSH
91738: LD_INT 3
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: LIST
91749: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91750: LD_ADDR_VAR 0 14
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: LD_INT 3
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 0
91767: PUSH
91768: LD_INT 3
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 1
91777: NEG
91778: PUSH
91779: LD_INT 2
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: LIST
91790: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91791: LD_ADDR_VAR 0 15
91795: PUSH
91796: LD_INT 2
91798: NEG
91799: PUSH
91800: LD_INT 1
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 3
91809: NEG
91810: PUSH
91811: LD_INT 0
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 3
91820: NEG
91821: PUSH
91822: LD_INT 1
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91835: LD_ADDR_VAR 0 16
91839: PUSH
91840: LD_INT 2
91842: NEG
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 3
91854: NEG
91855: PUSH
91856: LD_INT 2
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 3
91866: NEG
91867: PUSH
91868: LD_INT 3
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: LIST
91880: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91881: LD_ADDR_VAR 0 17
91885: PUSH
91886: LD_INT 1
91888: NEG
91889: PUSH
91890: LD_INT 3
91892: NEG
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 0
91900: PUSH
91901: LD_INT 3
91903: NEG
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 1
91911: PUSH
91912: LD_INT 2
91914: NEG
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91925: LD_ADDR_VAR 0 18
91929: PUSH
91930: LD_INT 2
91932: PUSH
91933: LD_INT 1
91935: NEG
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: LD_INT 0
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 3
91953: PUSH
91954: LD_INT 1
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: LIST
91965: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91966: LD_ADDR_VAR 0 19
91970: PUSH
91971: LD_INT 3
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: PUSH
91984: LD_INT 3
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 2
91993: PUSH
91994: LD_INT 3
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: LIST
92005: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92006: LD_ADDR_VAR 0 20
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: LD_INT 3
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 0
92023: PUSH
92024: LD_INT 3
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 1
92033: NEG
92034: PUSH
92035: LD_INT 2
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92047: LD_ADDR_VAR 0 21
92051: PUSH
92052: LD_INT 2
92054: NEG
92055: PUSH
92056: LD_INT 1
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 3
92065: NEG
92066: PUSH
92067: LD_INT 0
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 3
92076: NEG
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92091: LD_ADDR_VAR 0 22
92095: PUSH
92096: LD_INT 2
92098: NEG
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 3
92110: NEG
92111: PUSH
92112: LD_INT 2
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 3
92122: NEG
92123: PUSH
92124: LD_INT 3
92126: NEG
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: LIST
92136: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92137: LD_ADDR_VAR 0 23
92141: PUSH
92142: LD_INT 0
92144: PUSH
92145: LD_INT 3
92147: NEG
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 1
92155: NEG
92156: PUSH
92157: LD_INT 4
92159: NEG
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 1
92167: PUSH
92168: LD_INT 3
92170: NEG
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: LIST
92180: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92181: LD_ADDR_VAR 0 24
92185: PUSH
92186: LD_INT 3
92188: PUSH
92189: LD_INT 0
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 3
92198: PUSH
92199: LD_INT 1
92201: NEG
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 4
92209: PUSH
92210: LD_INT 1
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92222: LD_ADDR_VAR 0 25
92226: PUSH
92227: LD_INT 3
92229: PUSH
92230: LD_INT 3
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 4
92239: PUSH
92240: LD_INT 3
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 3
92249: PUSH
92250: LD_INT 4
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: LIST
92261: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92262: LD_ADDR_VAR 0 26
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: LD_INT 3
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 1
92279: PUSH
92280: LD_INT 4
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 1
92289: NEG
92290: PUSH
92291: LD_INT 3
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92303: LD_ADDR_VAR 0 27
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: NEG
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 4
92332: NEG
92333: PUSH
92334: LD_INT 1
92336: NEG
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: LIST
92346: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92347: LD_ADDR_VAR 0 28
92351: PUSH
92352: LD_INT 3
92354: NEG
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 3
92366: NEG
92367: PUSH
92368: LD_INT 4
92370: NEG
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 4
92378: NEG
92379: PUSH
92380: LD_INT 3
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: LIST
92392: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92393: LD_ADDR_VAR 0 29
92397: PUSH
92398: LD_INT 1
92400: NEG
92401: PUSH
92402: LD_INT 3
92404: NEG
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: PUSH
92410: LD_INT 0
92412: PUSH
92413: LD_INT 3
92415: NEG
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 1
92423: PUSH
92424: LD_INT 2
92426: NEG
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 1
92434: NEG
92435: PUSH
92436: LD_INT 4
92438: NEG
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 4
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 1
92457: PUSH
92458: LD_INT 3
92460: NEG
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 1
92468: NEG
92469: PUSH
92470: LD_INT 5
92472: NEG
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 0
92480: PUSH
92481: LD_INT 5
92483: NEG
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 1
92491: PUSH
92492: LD_INT 4
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 1
92502: NEG
92503: PUSH
92504: LD_INT 6
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 0
92514: PUSH
92515: LD_INT 6
92517: NEG
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 1
92525: PUSH
92526: LD_INT 5
92528: NEG
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92548: LD_ADDR_VAR 0 30
92552: PUSH
92553: LD_INT 2
92555: PUSH
92556: LD_INT 1
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 3
92566: PUSH
92567: LD_INT 0
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 3
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 3
92586: PUSH
92587: LD_INT 1
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 4
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 4
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 4
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 5
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 5
92638: PUSH
92639: LD_INT 1
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 5
92648: PUSH
92649: LD_INT 1
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 6
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 6
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92691: LD_ADDR_VAR 0 31
92695: PUSH
92696: LD_INT 3
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: PUSH
92706: LD_INT 3
92708: PUSH
92709: LD_INT 3
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 2
92718: PUSH
92719: LD_INT 3
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 4
92728: PUSH
92729: LD_INT 3
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 4
92738: PUSH
92739: LD_INT 4
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 3
92748: PUSH
92749: LD_INT 4
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 5
92758: PUSH
92759: LD_INT 4
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 5
92768: PUSH
92769: LD_INT 5
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 4
92778: PUSH
92779: LD_INT 5
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 6
92788: PUSH
92789: LD_INT 5
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: LD_INT 6
92798: PUSH
92799: LD_INT 6
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 5
92808: PUSH
92809: LD_INT 6
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92830: LD_ADDR_VAR 0 32
92834: PUSH
92835: LD_INT 1
92837: PUSH
92838: LD_INT 3
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: LD_INT 3
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 1
92857: NEG
92858: PUSH
92859: LD_INT 2
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 1
92868: PUSH
92869: LD_INT 4
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: LD_INT 4
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 1
92888: NEG
92889: PUSH
92890: LD_INT 3
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 1
92899: PUSH
92900: LD_INT 5
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: LD_INT 5
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: LD_INT 4
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 1
92930: PUSH
92931: LD_INT 6
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 6
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: LD_INT 5
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92973: LD_ADDR_VAR 0 33
92977: PUSH
92978: LD_INT 2
92980: NEG
92981: PUSH
92982: LD_INT 1
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 3
92991: NEG
92992: PUSH
92993: LD_INT 0
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 3
93002: NEG
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 3
93014: NEG
93015: PUSH
93016: LD_INT 1
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 4
93025: NEG
93026: PUSH
93027: LD_INT 0
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 4
93036: NEG
93037: PUSH
93038: LD_INT 1
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 4
93048: NEG
93049: PUSH
93050: LD_INT 1
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 5
93059: NEG
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 5
93070: NEG
93071: PUSH
93072: LD_INT 1
93074: NEG
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 5
93082: NEG
93083: PUSH
93084: LD_INT 1
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 6
93093: NEG
93094: PUSH
93095: LD_INT 0
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 6
93104: NEG
93105: PUSH
93106: LD_INT 1
93108: NEG
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93128: LD_ADDR_VAR 0 34
93132: PUSH
93133: LD_INT 2
93135: NEG
93136: PUSH
93137: LD_INT 3
93139: NEG
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: LD_INT 3
93147: NEG
93148: PUSH
93149: LD_INT 2
93151: NEG
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 3
93159: NEG
93160: PUSH
93161: LD_INT 3
93163: NEG
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: PUSH
93169: LD_INT 3
93171: NEG
93172: PUSH
93173: LD_INT 4
93175: NEG
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 4
93183: NEG
93184: PUSH
93185: LD_INT 3
93187: NEG
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: LD_INT 4
93195: NEG
93196: PUSH
93197: LD_INT 4
93199: NEG
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 4
93207: NEG
93208: PUSH
93209: LD_INT 5
93211: NEG
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 5
93219: NEG
93220: PUSH
93221: LD_INT 4
93223: NEG
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 5
93231: NEG
93232: PUSH
93233: LD_INT 5
93235: NEG
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 5
93243: NEG
93244: PUSH
93245: LD_INT 6
93247: NEG
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 6
93255: NEG
93256: PUSH
93257: LD_INT 5
93259: NEG
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 6
93267: NEG
93268: PUSH
93269: LD_INT 6
93271: NEG
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93291: LD_ADDR_VAR 0 41
93295: PUSH
93296: LD_INT 0
93298: PUSH
93299: LD_INT 2
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 1
93309: NEG
93310: PUSH
93311: LD_INT 3
93313: NEG
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 1
93321: PUSH
93322: LD_INT 2
93324: NEG
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: LIST
93334: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93335: LD_ADDR_VAR 0 42
93339: PUSH
93340: LD_INT 2
93342: PUSH
93343: LD_INT 0
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 2
93352: PUSH
93353: LD_INT 1
93355: NEG
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 3
93363: PUSH
93364: LD_INT 1
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: LIST
93375: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93376: LD_ADDR_VAR 0 43
93380: PUSH
93381: LD_INT 2
93383: PUSH
93384: LD_INT 2
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 2
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 2
93403: PUSH
93404: LD_INT 3
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: LIST
93415: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93416: LD_ADDR_VAR 0 44
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 1
93433: PUSH
93434: LD_INT 3
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 1
93443: NEG
93444: PUSH
93445: LD_INT 2
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: LIST
93456: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93457: LD_ADDR_VAR 0 45
93461: PUSH
93462: LD_INT 2
93464: NEG
93465: PUSH
93466: LD_INT 0
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: LD_INT 2
93475: NEG
93476: PUSH
93477: LD_INT 1
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 3
93486: NEG
93487: PUSH
93488: LD_INT 1
93490: NEG
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: LIST
93500: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93501: LD_ADDR_VAR 0 46
93505: PUSH
93506: LD_INT 2
93508: NEG
93509: PUSH
93510: LD_INT 2
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 2
93520: NEG
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 3
93532: NEG
93533: PUSH
93534: LD_INT 2
93536: NEG
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: LIST
93546: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93547: LD_ADDR_VAR 0 47
93551: PUSH
93552: LD_INT 2
93554: NEG
93555: PUSH
93556: LD_INT 3
93558: NEG
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 1
93566: NEG
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93580: LD_ADDR_VAR 0 48
93584: PUSH
93585: LD_INT 1
93587: PUSH
93588: LD_INT 2
93590: NEG
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: LD_INT 2
93598: PUSH
93599: LD_INT 1
93601: NEG
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93611: LD_ADDR_VAR 0 49
93615: PUSH
93616: LD_INT 3
93618: PUSH
93619: LD_INT 1
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 3
93628: PUSH
93629: LD_INT 2
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93640: LD_ADDR_VAR 0 50
93644: PUSH
93645: LD_INT 2
93647: PUSH
93648: LD_INT 3
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 1
93657: PUSH
93658: LD_INT 3
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93669: LD_ADDR_VAR 0 51
93673: PUSH
93674: LD_INT 1
93676: NEG
93677: PUSH
93678: LD_INT 2
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 1
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93700: LD_ADDR_VAR 0 52
93704: PUSH
93705: LD_INT 3
93707: NEG
93708: PUSH
93709: LD_INT 1
93711: NEG
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 3
93719: NEG
93720: PUSH
93721: LD_INT 2
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93733: LD_ADDR_VAR 0 53
93737: PUSH
93738: LD_INT 1
93740: NEG
93741: PUSH
93742: LD_INT 3
93744: NEG
93745: PUSH
93746: EMPTY
93747: LIST
93748: LIST
93749: PUSH
93750: LD_INT 0
93752: PUSH
93753: LD_INT 3
93755: NEG
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PUSH
93761: LD_INT 1
93763: PUSH
93764: LD_INT 2
93766: NEG
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: LIST
93776: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93777: LD_ADDR_VAR 0 54
93781: PUSH
93782: LD_INT 2
93784: PUSH
93785: LD_INT 1
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 3
93795: PUSH
93796: LD_INT 0
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 3
93805: PUSH
93806: LD_INT 1
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: LIST
93817: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93818: LD_ADDR_VAR 0 55
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 2
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 3
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 2
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93858: LD_ADDR_VAR 0 56
93862: PUSH
93863: LD_INT 1
93865: PUSH
93866: LD_INT 3
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: LD_INT 3
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 1
93885: NEG
93886: PUSH
93887: LD_INT 2
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: LIST
93898: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93899: LD_ADDR_VAR 0 57
93903: PUSH
93904: LD_INT 2
93906: NEG
93907: PUSH
93908: LD_INT 1
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 3
93917: NEG
93918: PUSH
93919: LD_INT 0
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 3
93928: NEG
93929: PUSH
93930: LD_INT 1
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93943: LD_ADDR_VAR 0 58
93947: PUSH
93948: LD_INT 2
93950: NEG
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 3
93962: NEG
93963: PUSH
93964: LD_INT 2
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 3
93974: NEG
93975: PUSH
93976: LD_INT 3
93978: NEG
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: LIST
93988: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93989: LD_ADDR_VAR 0 59
93993: PUSH
93994: LD_INT 1
93996: NEG
93997: PUSH
93998: LD_INT 2
94000: NEG
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 0
94008: PUSH
94009: LD_INT 2
94011: NEG
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 1
94019: PUSH
94020: LD_INT 1
94022: NEG
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: LIST
94032: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94033: LD_ADDR_VAR 0 60
94037: PUSH
94038: LD_INT 1
94040: PUSH
94041: LD_INT 1
94043: NEG
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 2
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94074: LD_ADDR_VAR 0 61
94078: PUSH
94079: LD_INT 2
94081: PUSH
94082: LD_INT 1
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 2
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 1
94101: PUSH
94102: LD_INT 2
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: LIST
94113: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94114: LD_ADDR_VAR 0 62
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: LD_INT 2
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 0
94131: PUSH
94132: LD_INT 2
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 1
94141: NEG
94142: PUSH
94143: LD_INT 1
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: LIST
94154: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94155: LD_ADDR_VAR 0 63
94159: PUSH
94160: LD_INT 1
94162: NEG
94163: PUSH
94164: LD_INT 1
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: LD_INT 0
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 2
94184: NEG
94185: PUSH
94186: LD_INT 1
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: LIST
94198: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94199: LD_ADDR_VAR 0 64
94203: PUSH
94204: LD_INT 1
94206: NEG
94207: PUSH
94208: LD_INT 2
94210: NEG
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 2
94218: NEG
94219: PUSH
94220: LD_INT 1
94222: NEG
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 2
94230: NEG
94231: PUSH
94232: LD_INT 2
94234: NEG
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: EMPTY
94241: LIST
94242: LIST
94243: LIST
94244: ST_TO_ADDR
// end ; 2 :
94245: GO 97511
94247: LD_INT 2
94249: DOUBLE
94250: EQUAL
94251: IFTRUE 94255
94253: GO 97510
94255: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94256: LD_ADDR_VAR 0 29
94260: PUSH
94261: LD_INT 4
94263: PUSH
94264: LD_INT 0
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 4
94273: PUSH
94274: LD_INT 1
94276: NEG
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 5
94284: PUSH
94285: LD_INT 0
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: PUSH
94292: LD_INT 5
94294: PUSH
94295: LD_INT 1
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 4
94304: PUSH
94305: LD_INT 1
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 3
94314: PUSH
94315: LD_INT 0
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 3
94324: PUSH
94325: LD_INT 1
94327: NEG
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 3
94335: PUSH
94336: LD_INT 2
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 5
94346: PUSH
94347: LD_INT 2
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 3
94356: PUSH
94357: LD_INT 3
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 3
94366: PUSH
94367: LD_INT 2
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 4
94376: PUSH
94377: LD_INT 3
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 4
94386: PUSH
94387: LD_INT 4
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: LD_INT 4
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 2
94406: PUSH
94407: LD_INT 3
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 2
94416: PUSH
94417: LD_INT 2
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 4
94426: PUSH
94427: LD_INT 2
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: PUSH
94437: LD_INT 4
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 0
94446: PUSH
94447: LD_INT 4
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 0
94456: PUSH
94457: LD_INT 3
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: LD_INT 1
94466: PUSH
94467: LD_INT 4
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 1
94476: PUSH
94477: LD_INT 5
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 0
94486: PUSH
94487: LD_INT 5
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 1
94496: NEG
94497: PUSH
94498: LD_INT 4
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 1
94507: NEG
94508: PUSH
94509: LD_INT 3
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 2
94518: PUSH
94519: LD_INT 5
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 2
94528: NEG
94529: PUSH
94530: LD_INT 3
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 3
94539: NEG
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 3
94550: NEG
94551: PUSH
94552: LD_INT 1
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 2
94562: NEG
94563: PUSH
94564: LD_INT 0
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 2
94573: NEG
94574: PUSH
94575: LD_INT 1
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 3
94584: NEG
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 4
94595: NEG
94596: PUSH
94597: LD_INT 0
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 4
94606: NEG
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 4
94618: NEG
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 2
94630: NEG
94631: PUSH
94632: LD_INT 2
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 4
94641: NEG
94642: PUSH
94643: LD_INT 4
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 4
94653: NEG
94654: PUSH
94655: LD_INT 5
94657: NEG
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 3
94665: NEG
94666: PUSH
94667: LD_INT 4
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 3
94677: NEG
94678: PUSH
94679: LD_INT 3
94681: NEG
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 4
94689: NEG
94690: PUSH
94691: LD_INT 3
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 5
94701: NEG
94702: PUSH
94703: LD_INT 4
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 5
94713: NEG
94714: PUSH
94715: LD_INT 5
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 3
94725: NEG
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 5
94737: NEG
94738: PUSH
94739: LD_INT 3
94741: NEG
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94794: LD_ADDR_VAR 0 30
94798: PUSH
94799: LD_INT 4
94801: PUSH
94802: LD_INT 4
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 4
94811: PUSH
94812: LD_INT 3
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 5
94821: PUSH
94822: LD_INT 4
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PUSH
94829: LD_INT 5
94831: PUSH
94832: LD_INT 5
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PUSH
94839: LD_INT 4
94841: PUSH
94842: LD_INT 5
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 3
94851: PUSH
94852: LD_INT 4
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 3
94861: PUSH
94862: LD_INT 3
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 5
94871: PUSH
94872: LD_INT 3
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 3
94881: PUSH
94882: LD_INT 5
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 0
94901: PUSH
94902: LD_INT 2
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 1
94911: PUSH
94912: LD_INT 3
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 1
94921: PUSH
94922: LD_INT 4
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 0
94931: PUSH
94932: LD_INT 4
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: NEG
94942: PUSH
94943: LD_INT 3
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 1
94952: NEG
94953: PUSH
94954: LD_INT 2
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 2
94963: PUSH
94964: LD_INT 4
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 2
94973: NEG
94974: PUSH
94975: LD_INT 2
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 4
94984: NEG
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 4
94995: NEG
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 3
95007: NEG
95008: PUSH
95009: LD_INT 0
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 3
95018: NEG
95019: PUSH
95020: LD_INT 1
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 4
95029: NEG
95030: PUSH
95031: LD_INT 1
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 5
95040: NEG
95041: PUSH
95042: LD_INT 0
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 5
95051: NEG
95052: PUSH
95053: LD_INT 1
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 5
95063: NEG
95064: PUSH
95065: LD_INT 2
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 3
95075: NEG
95076: PUSH
95077: LD_INT 2
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 3
95086: NEG
95087: PUSH
95088: LD_INT 3
95090: NEG
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 3
95098: NEG
95099: PUSH
95100: LD_INT 4
95102: NEG
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 2
95110: NEG
95111: PUSH
95112: LD_INT 3
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 2
95122: NEG
95123: PUSH
95124: LD_INT 2
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 3
95134: NEG
95135: PUSH
95136: LD_INT 2
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 4
95146: NEG
95147: PUSH
95148: LD_INT 3
95150: NEG
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: LD_INT 4
95158: NEG
95159: PUSH
95160: LD_INT 4
95162: NEG
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PUSH
95168: LD_INT 2
95170: NEG
95171: PUSH
95172: LD_INT 4
95174: NEG
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 4
95182: NEG
95183: PUSH
95184: LD_INT 2
95186: NEG
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 0
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 0
95205: PUSH
95206: LD_INT 5
95208: NEG
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 1
95216: PUSH
95217: LD_INT 4
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 1
95227: PUSH
95228: LD_INT 3
95230: NEG
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 0
95238: PUSH
95239: LD_INT 3
95241: NEG
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 1
95249: NEG
95250: PUSH
95251: LD_INT 4
95253: NEG
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 1
95261: NEG
95262: PUSH
95263: LD_INT 5
95265: NEG
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: LD_INT 2
95273: PUSH
95274: LD_INT 3
95276: NEG
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 2
95284: NEG
95285: PUSH
95286: LD_INT 5
95288: NEG
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95341: LD_ADDR_VAR 0 31
95345: PUSH
95346: LD_INT 0
95348: PUSH
95349: LD_INT 4
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 0
95358: PUSH
95359: LD_INT 3
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 1
95368: PUSH
95369: LD_INT 4
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 1
95378: PUSH
95379: LD_INT 5
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: LD_INT 5
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 1
95398: NEG
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 1
95409: NEG
95410: PUSH
95411: LD_INT 3
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 2
95420: PUSH
95421: LD_INT 5
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 2
95430: NEG
95431: PUSH
95432: LD_INT 3
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 3
95441: NEG
95442: PUSH
95443: LD_INT 0
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 3
95452: NEG
95453: PUSH
95454: LD_INT 1
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 2
95464: NEG
95465: PUSH
95466: LD_INT 0
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 2
95475: NEG
95476: PUSH
95477: LD_INT 1
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 3
95486: NEG
95487: PUSH
95488: LD_INT 1
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 4
95497: NEG
95498: PUSH
95499: LD_INT 0
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: PUSH
95506: LD_INT 4
95508: NEG
95509: PUSH
95510: LD_INT 1
95512: NEG
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 4
95520: NEG
95521: PUSH
95522: LD_INT 2
95524: NEG
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: PUSH
95530: LD_INT 2
95532: NEG
95533: PUSH
95534: LD_INT 2
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 4
95543: NEG
95544: PUSH
95545: LD_INT 4
95547: NEG
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 4
95555: NEG
95556: PUSH
95557: LD_INT 5
95559: NEG
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 3
95567: NEG
95568: PUSH
95569: LD_INT 4
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 3
95579: NEG
95580: PUSH
95581: LD_INT 3
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 4
95591: NEG
95592: PUSH
95593: LD_INT 3
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 5
95603: NEG
95604: PUSH
95605: LD_INT 4
95607: NEG
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 5
95615: NEG
95616: PUSH
95617: LD_INT 5
95619: NEG
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 3
95627: NEG
95628: PUSH
95629: LD_INT 5
95631: NEG
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 5
95639: NEG
95640: PUSH
95641: LD_INT 3
95643: NEG
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 0
95651: PUSH
95652: LD_INT 3
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 0
95662: PUSH
95663: LD_INT 4
95665: NEG
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 1
95673: PUSH
95674: LD_INT 3
95676: NEG
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 1
95684: PUSH
95685: LD_INT 2
95687: NEG
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: LD_INT 0
95695: PUSH
95696: LD_INT 2
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 1
95706: NEG
95707: PUSH
95708: LD_INT 3
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 1
95718: NEG
95719: PUSH
95720: LD_INT 4
95722: NEG
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: PUSH
95728: LD_INT 2
95730: PUSH
95731: LD_INT 2
95733: NEG
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 2
95741: NEG
95742: PUSH
95743: LD_INT 4
95745: NEG
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 4
95753: PUSH
95754: LD_INT 0
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 4
95763: PUSH
95764: LD_INT 1
95766: NEG
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_INT 5
95774: PUSH
95775: LD_INT 0
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: PUSH
95782: LD_INT 5
95784: PUSH
95785: LD_INT 1
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 4
95794: PUSH
95795: LD_INT 1
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 3
95804: PUSH
95805: LD_INT 0
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 3
95814: PUSH
95815: LD_INT 1
95817: NEG
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 3
95825: PUSH
95826: LD_INT 2
95828: NEG
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: LD_INT 5
95836: PUSH
95837: LD_INT 2
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95891: LD_ADDR_VAR 0 32
95895: PUSH
95896: LD_INT 4
95898: NEG
95899: PUSH
95900: LD_INT 0
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 4
95909: NEG
95910: PUSH
95911: LD_INT 1
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 3
95921: NEG
95922: PUSH
95923: LD_INT 0
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 3
95932: NEG
95933: PUSH
95934: LD_INT 1
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 4
95943: NEG
95944: PUSH
95945: LD_INT 1
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: PUSH
95952: LD_INT 5
95954: NEG
95955: PUSH
95956: LD_INT 0
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 5
95965: NEG
95966: PUSH
95967: LD_INT 1
95969: NEG
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 5
95977: NEG
95978: PUSH
95979: LD_INT 2
95981: NEG
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 3
95989: NEG
95990: PUSH
95991: LD_INT 2
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 3
96000: NEG
96001: PUSH
96002: LD_INT 3
96004: NEG
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 3
96012: NEG
96013: PUSH
96014: LD_INT 4
96016: NEG
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 2
96024: NEG
96025: PUSH
96026: LD_INT 3
96028: NEG
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: LD_INT 2
96036: NEG
96037: PUSH
96038: LD_INT 2
96040: NEG
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 3
96048: NEG
96049: PUSH
96050: LD_INT 2
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 4
96060: NEG
96061: PUSH
96062: LD_INT 3
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 4
96072: NEG
96073: PUSH
96074: LD_INT 4
96076: NEG
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 2
96084: NEG
96085: PUSH
96086: LD_INT 4
96088: NEG
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 4
96096: NEG
96097: PUSH
96098: LD_INT 2
96100: NEG
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 0
96108: PUSH
96109: LD_INT 4
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 0
96119: PUSH
96120: LD_INT 5
96122: NEG
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 1
96130: PUSH
96131: LD_INT 4
96133: NEG
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 1
96141: PUSH
96142: LD_INT 3
96144: NEG
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 0
96152: PUSH
96153: LD_INT 3
96155: NEG
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 1
96163: NEG
96164: PUSH
96165: LD_INT 4
96167: NEG
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 1
96175: NEG
96176: PUSH
96177: LD_INT 5
96179: NEG
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: PUSH
96185: LD_INT 2
96187: PUSH
96188: LD_INT 3
96190: NEG
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 2
96198: NEG
96199: PUSH
96200: LD_INT 5
96202: NEG
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 3
96210: PUSH
96211: LD_INT 0
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 3
96220: PUSH
96221: LD_INT 1
96223: NEG
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_INT 4
96231: PUSH
96232: LD_INT 0
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 4
96241: PUSH
96242: LD_INT 1
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: LD_INT 3
96251: PUSH
96252: LD_INT 1
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 2
96261: PUSH
96262: LD_INT 0
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 2
96271: PUSH
96272: LD_INT 1
96274: NEG
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 2
96282: PUSH
96283: LD_INT 2
96285: NEG
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: LD_INT 4
96293: PUSH
96294: LD_INT 2
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PUSH
96301: LD_INT 4
96303: PUSH
96304: LD_INT 4
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 4
96313: PUSH
96314: LD_INT 3
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 5
96323: PUSH
96324: LD_INT 4
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 5
96333: PUSH
96334: LD_INT 5
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 4
96343: PUSH
96344: LD_INT 5
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 3
96353: PUSH
96354: LD_INT 4
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 3
96363: PUSH
96364: LD_INT 3
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 5
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 5
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96438: LD_ADDR_VAR 0 33
96442: PUSH
96443: LD_INT 4
96445: NEG
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 4
96457: NEG
96458: PUSH
96459: LD_INT 5
96461: NEG
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: PUSH
96467: LD_INT 3
96469: NEG
96470: PUSH
96471: LD_INT 4
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 3
96481: NEG
96482: PUSH
96483: LD_INT 3
96485: NEG
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 4
96493: NEG
96494: PUSH
96495: LD_INT 3
96497: NEG
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 5
96505: NEG
96506: PUSH
96507: LD_INT 4
96509: NEG
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 5
96517: NEG
96518: PUSH
96519: LD_INT 5
96521: NEG
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 3
96529: NEG
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 5
96541: NEG
96542: PUSH
96543: LD_INT 3
96545: NEG
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_INT 0
96553: PUSH
96554: LD_INT 3
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 0
96564: PUSH
96565: LD_INT 4
96567: NEG
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: LD_INT 1
96575: PUSH
96576: LD_INT 3
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 1
96586: PUSH
96587: LD_INT 2
96589: NEG
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 0
96597: PUSH
96598: LD_INT 2
96600: NEG
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PUSH
96606: LD_INT 1
96608: NEG
96609: PUSH
96610: LD_INT 3
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 1
96620: NEG
96621: PUSH
96622: LD_INT 4
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 2
96632: PUSH
96633: LD_INT 2
96635: NEG
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 2
96643: NEG
96644: PUSH
96645: LD_INT 4
96647: NEG
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 4
96655: PUSH
96656: LD_INT 0
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 4
96665: PUSH
96666: LD_INT 1
96668: NEG
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: LD_INT 5
96676: PUSH
96677: LD_INT 0
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 5
96686: PUSH
96687: LD_INT 1
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 4
96696: PUSH
96697: LD_INT 1
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: PUSH
96704: LD_INT 3
96706: PUSH
96707: LD_INT 0
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 3
96716: PUSH
96717: LD_INT 1
96719: NEG
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 3
96727: PUSH
96728: LD_INT 2
96730: NEG
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 5
96738: PUSH
96739: LD_INT 2
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: LD_INT 3
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: LD_INT 2
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 4
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 4
96778: PUSH
96779: LD_INT 4
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 3
96788: PUSH
96789: LD_INT 4
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 2
96798: PUSH
96799: LD_INT 3
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 2
96808: PUSH
96809: LD_INT 2
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 4
96818: PUSH
96819: LD_INT 2
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 2
96828: PUSH
96829: LD_INT 4
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 0
96838: PUSH
96839: LD_INT 4
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 0
96848: PUSH
96849: LD_INT 3
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 1
96858: PUSH
96859: LD_INT 4
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 1
96868: PUSH
96869: LD_INT 5
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 0
96878: PUSH
96879: LD_INT 5
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 1
96888: NEG
96889: PUSH
96890: LD_INT 4
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: NEG
96900: PUSH
96901: LD_INT 3
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 2
96910: PUSH
96911: LD_INT 5
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 2
96920: NEG
96921: PUSH
96922: LD_INT 3
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96976: LD_ADDR_VAR 0 34
96980: PUSH
96981: LD_INT 0
96983: PUSH
96984: LD_INT 4
96986: NEG
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 0
96994: PUSH
96995: LD_INT 5
96997: NEG
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 1
97005: PUSH
97006: LD_INT 4
97008: NEG
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 1
97016: PUSH
97017: LD_INT 3
97019: NEG
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: LD_INT 0
97027: PUSH
97028: LD_INT 3
97030: NEG
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: LD_INT 1
97038: NEG
97039: PUSH
97040: LD_INT 4
97042: NEG
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 1
97050: NEG
97051: PUSH
97052: LD_INT 5
97054: NEG
97055: PUSH
97056: EMPTY
97057: LIST
97058: LIST
97059: PUSH
97060: LD_INT 2
97062: PUSH
97063: LD_INT 3
97065: NEG
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 2
97073: NEG
97074: PUSH
97075: LD_INT 5
97077: NEG
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 3
97085: PUSH
97086: LD_INT 0
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PUSH
97093: LD_INT 3
97095: PUSH
97096: LD_INT 1
97098: NEG
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 4
97106: PUSH
97107: LD_INT 0
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 4
97116: PUSH
97117: LD_INT 1
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 3
97126: PUSH
97127: LD_INT 1
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: PUSH
97134: LD_INT 2
97136: PUSH
97137: LD_INT 0
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PUSH
97144: LD_INT 2
97146: PUSH
97147: LD_INT 1
97149: NEG
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 2
97157: PUSH
97158: LD_INT 2
97160: NEG
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: LD_INT 4
97168: PUSH
97169: LD_INT 2
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 4
97178: PUSH
97179: LD_INT 4
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 4
97188: PUSH
97189: LD_INT 3
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 5
97198: PUSH
97199: LD_INT 4
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 5
97208: PUSH
97209: LD_INT 5
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 4
97218: PUSH
97219: LD_INT 5
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 3
97228: PUSH
97229: LD_INT 4
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 3
97238: PUSH
97239: LD_INT 3
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 5
97248: PUSH
97249: LD_INT 3
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 3
97258: PUSH
97259: LD_INT 5
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 0
97268: PUSH
97269: LD_INT 3
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 0
97278: PUSH
97279: LD_INT 2
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 1
97288: PUSH
97289: LD_INT 3
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 1
97298: PUSH
97299: LD_INT 4
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 0
97308: PUSH
97309: LD_INT 4
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 1
97318: NEG
97319: PUSH
97320: LD_INT 3
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 1
97329: NEG
97330: PUSH
97331: LD_INT 2
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 2
97340: PUSH
97341: LD_INT 4
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 2
97350: NEG
97351: PUSH
97352: LD_INT 2
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 4
97361: NEG
97362: PUSH
97363: LD_INT 0
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 4
97372: NEG
97373: PUSH
97374: LD_INT 1
97376: NEG
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 3
97384: NEG
97385: PUSH
97386: LD_INT 0
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 3
97395: NEG
97396: PUSH
97397: LD_INT 1
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: LD_INT 4
97406: NEG
97407: PUSH
97408: LD_INT 1
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: PUSH
97415: LD_INT 5
97417: NEG
97418: PUSH
97419: LD_INT 0
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PUSH
97426: LD_INT 5
97428: NEG
97429: PUSH
97430: LD_INT 1
97432: NEG
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 5
97440: NEG
97441: PUSH
97442: LD_INT 2
97444: NEG
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 3
97452: NEG
97453: PUSH
97454: LD_INT 2
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: ST_TO_ADDR
// end ; end ;
97508: GO 97511
97510: POP
// case btype of b_depot , b_warehouse :
97511: LD_VAR 0 1
97515: PUSH
97516: LD_INT 0
97518: DOUBLE
97519: EQUAL
97520: IFTRUE 97530
97522: LD_INT 1
97524: DOUBLE
97525: EQUAL
97526: IFTRUE 97530
97528: GO 97731
97530: POP
// case nation of nation_american :
97531: LD_VAR 0 5
97535: PUSH
97536: LD_INT 1
97538: DOUBLE
97539: EQUAL
97540: IFTRUE 97544
97542: GO 97600
97544: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97545: LD_ADDR_VAR 0 9
97549: PUSH
97550: LD_VAR 0 11
97554: PUSH
97555: LD_VAR 0 12
97559: PUSH
97560: LD_VAR 0 13
97564: PUSH
97565: LD_VAR 0 14
97569: PUSH
97570: LD_VAR 0 15
97574: PUSH
97575: LD_VAR 0 16
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: PUSH
97588: LD_VAR 0 4
97592: PUSH
97593: LD_INT 1
97595: PLUS
97596: ARRAY
97597: ST_TO_ADDR
97598: GO 97729
97600: LD_INT 2
97602: DOUBLE
97603: EQUAL
97604: IFTRUE 97608
97606: GO 97664
97608: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97609: LD_ADDR_VAR 0 9
97613: PUSH
97614: LD_VAR 0 17
97618: PUSH
97619: LD_VAR 0 18
97623: PUSH
97624: LD_VAR 0 19
97628: PUSH
97629: LD_VAR 0 20
97633: PUSH
97634: LD_VAR 0 21
97638: PUSH
97639: LD_VAR 0 22
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: PUSH
97652: LD_VAR 0 4
97656: PUSH
97657: LD_INT 1
97659: PLUS
97660: ARRAY
97661: ST_TO_ADDR
97662: GO 97729
97664: LD_INT 3
97666: DOUBLE
97667: EQUAL
97668: IFTRUE 97672
97670: GO 97728
97672: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97673: LD_ADDR_VAR 0 9
97677: PUSH
97678: LD_VAR 0 23
97682: PUSH
97683: LD_VAR 0 24
97687: PUSH
97688: LD_VAR 0 25
97692: PUSH
97693: LD_VAR 0 26
97697: PUSH
97698: LD_VAR 0 27
97702: PUSH
97703: LD_VAR 0 28
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: PUSH
97716: LD_VAR 0 4
97720: PUSH
97721: LD_INT 1
97723: PLUS
97724: ARRAY
97725: ST_TO_ADDR
97726: GO 97729
97728: POP
97729: GO 98284
97731: LD_INT 2
97733: DOUBLE
97734: EQUAL
97735: IFTRUE 97745
97737: LD_INT 3
97739: DOUBLE
97740: EQUAL
97741: IFTRUE 97745
97743: GO 97801
97745: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97746: LD_ADDR_VAR 0 9
97750: PUSH
97751: LD_VAR 0 29
97755: PUSH
97756: LD_VAR 0 30
97760: PUSH
97761: LD_VAR 0 31
97765: PUSH
97766: LD_VAR 0 32
97770: PUSH
97771: LD_VAR 0 33
97775: PUSH
97776: LD_VAR 0 34
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: PUSH
97789: LD_VAR 0 4
97793: PUSH
97794: LD_INT 1
97796: PLUS
97797: ARRAY
97798: ST_TO_ADDR
97799: GO 98284
97801: LD_INT 16
97803: DOUBLE
97804: EQUAL
97805: IFTRUE 97863
97807: LD_INT 17
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97863
97813: LD_INT 18
97815: DOUBLE
97816: EQUAL
97817: IFTRUE 97863
97819: LD_INT 19
97821: DOUBLE
97822: EQUAL
97823: IFTRUE 97863
97825: LD_INT 22
97827: DOUBLE
97828: EQUAL
97829: IFTRUE 97863
97831: LD_INT 20
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97863
97837: LD_INT 21
97839: DOUBLE
97840: EQUAL
97841: IFTRUE 97863
97843: LD_INT 23
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97863
97849: LD_INT 24
97851: DOUBLE
97852: EQUAL
97853: IFTRUE 97863
97855: LD_INT 25
97857: DOUBLE
97858: EQUAL
97859: IFTRUE 97863
97861: GO 97919
97863: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97864: LD_ADDR_VAR 0 9
97868: PUSH
97869: LD_VAR 0 35
97873: PUSH
97874: LD_VAR 0 36
97878: PUSH
97879: LD_VAR 0 37
97883: PUSH
97884: LD_VAR 0 38
97888: PUSH
97889: LD_VAR 0 39
97893: PUSH
97894: LD_VAR 0 40
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: PUSH
97907: LD_VAR 0 4
97911: PUSH
97912: LD_INT 1
97914: PLUS
97915: ARRAY
97916: ST_TO_ADDR
97917: GO 98284
97919: LD_INT 6
97921: DOUBLE
97922: EQUAL
97923: IFTRUE 97975
97925: LD_INT 7
97927: DOUBLE
97928: EQUAL
97929: IFTRUE 97975
97931: LD_INT 8
97933: DOUBLE
97934: EQUAL
97935: IFTRUE 97975
97937: LD_INT 13
97939: DOUBLE
97940: EQUAL
97941: IFTRUE 97975
97943: LD_INT 12
97945: DOUBLE
97946: EQUAL
97947: IFTRUE 97975
97949: LD_INT 15
97951: DOUBLE
97952: EQUAL
97953: IFTRUE 97975
97955: LD_INT 11
97957: DOUBLE
97958: EQUAL
97959: IFTRUE 97975
97961: LD_INT 14
97963: DOUBLE
97964: EQUAL
97965: IFTRUE 97975
97967: LD_INT 10
97969: DOUBLE
97970: EQUAL
97971: IFTRUE 97975
97973: GO 98031
97975: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97976: LD_ADDR_VAR 0 9
97980: PUSH
97981: LD_VAR 0 41
97985: PUSH
97986: LD_VAR 0 42
97990: PUSH
97991: LD_VAR 0 43
97995: PUSH
97996: LD_VAR 0 44
98000: PUSH
98001: LD_VAR 0 45
98005: PUSH
98006: LD_VAR 0 46
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: PUSH
98019: LD_VAR 0 4
98023: PUSH
98024: LD_INT 1
98026: PLUS
98027: ARRAY
98028: ST_TO_ADDR
98029: GO 98284
98031: LD_INT 36
98033: DOUBLE
98034: EQUAL
98035: IFTRUE 98039
98037: GO 98095
98039: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98040: LD_ADDR_VAR 0 9
98044: PUSH
98045: LD_VAR 0 47
98049: PUSH
98050: LD_VAR 0 48
98054: PUSH
98055: LD_VAR 0 49
98059: PUSH
98060: LD_VAR 0 50
98064: PUSH
98065: LD_VAR 0 51
98069: PUSH
98070: LD_VAR 0 52
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: PUSH
98083: LD_VAR 0 4
98087: PUSH
98088: LD_INT 1
98090: PLUS
98091: ARRAY
98092: ST_TO_ADDR
98093: GO 98284
98095: LD_INT 4
98097: DOUBLE
98098: EQUAL
98099: IFTRUE 98121
98101: LD_INT 5
98103: DOUBLE
98104: EQUAL
98105: IFTRUE 98121
98107: LD_INT 34
98109: DOUBLE
98110: EQUAL
98111: IFTRUE 98121
98113: LD_INT 37
98115: DOUBLE
98116: EQUAL
98117: IFTRUE 98121
98119: GO 98177
98121: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98122: LD_ADDR_VAR 0 9
98126: PUSH
98127: LD_VAR 0 53
98131: PUSH
98132: LD_VAR 0 54
98136: PUSH
98137: LD_VAR 0 55
98141: PUSH
98142: LD_VAR 0 56
98146: PUSH
98147: LD_VAR 0 57
98151: PUSH
98152: LD_VAR 0 58
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: LIST
98163: LIST
98164: PUSH
98165: LD_VAR 0 4
98169: PUSH
98170: LD_INT 1
98172: PLUS
98173: ARRAY
98174: ST_TO_ADDR
98175: GO 98284
98177: LD_INT 31
98179: DOUBLE
98180: EQUAL
98181: IFTRUE 98227
98183: LD_INT 32
98185: DOUBLE
98186: EQUAL
98187: IFTRUE 98227
98189: LD_INT 33
98191: DOUBLE
98192: EQUAL
98193: IFTRUE 98227
98195: LD_INT 27
98197: DOUBLE
98198: EQUAL
98199: IFTRUE 98227
98201: LD_INT 26
98203: DOUBLE
98204: EQUAL
98205: IFTRUE 98227
98207: LD_INT 28
98209: DOUBLE
98210: EQUAL
98211: IFTRUE 98227
98213: LD_INT 29
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98227
98219: LD_INT 30
98221: DOUBLE
98222: EQUAL
98223: IFTRUE 98227
98225: GO 98283
98227: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98228: LD_ADDR_VAR 0 9
98232: PUSH
98233: LD_VAR 0 59
98237: PUSH
98238: LD_VAR 0 60
98242: PUSH
98243: LD_VAR 0 61
98247: PUSH
98248: LD_VAR 0 62
98252: PUSH
98253: LD_VAR 0 63
98257: PUSH
98258: LD_VAR 0 64
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: PUSH
98271: LD_VAR 0 4
98275: PUSH
98276: LD_INT 1
98278: PLUS
98279: ARRAY
98280: ST_TO_ADDR
98281: GO 98284
98283: POP
// temp_list2 = [ ] ;
98284: LD_ADDR_VAR 0 10
98288: PUSH
98289: EMPTY
98290: ST_TO_ADDR
// for i in temp_list do
98291: LD_ADDR_VAR 0 8
98295: PUSH
98296: LD_VAR 0 9
98300: PUSH
98301: FOR_IN
98302: IFFALSE 98354
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98304: LD_ADDR_VAR 0 10
98308: PUSH
98309: LD_VAR 0 10
98313: PUSH
98314: LD_VAR 0 8
98318: PUSH
98319: LD_INT 1
98321: ARRAY
98322: PUSH
98323: LD_VAR 0 2
98327: PLUS
98328: PUSH
98329: LD_VAR 0 8
98333: PUSH
98334: LD_INT 2
98336: ARRAY
98337: PUSH
98338: LD_VAR 0 3
98342: PLUS
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: EMPTY
98349: LIST
98350: ADD
98351: ST_TO_ADDR
98352: GO 98301
98354: POP
98355: POP
// result = temp_list2 ;
98356: LD_ADDR_VAR 0 7
98360: PUSH
98361: LD_VAR 0 10
98365: ST_TO_ADDR
// end ;
98366: LD_VAR 0 7
98370: RET
// export function EnemyInRange ( unit , dist ) ; begin
98371: LD_INT 0
98373: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98374: LD_ADDR_VAR 0 3
98378: PUSH
98379: LD_VAR 0 1
98383: PPUSH
98384: CALL_OW 255
98388: PPUSH
98389: LD_VAR 0 1
98393: PPUSH
98394: CALL_OW 250
98398: PPUSH
98399: LD_VAR 0 1
98403: PPUSH
98404: CALL_OW 251
98408: PPUSH
98409: LD_VAR 0 2
98413: PPUSH
98414: CALL 71767 0 4
98418: PUSH
98419: LD_INT 4
98421: ARRAY
98422: ST_TO_ADDR
// end ;
98423: LD_VAR 0 3
98427: RET
// export function PlayerSeeMe ( unit ) ; begin
98428: LD_INT 0
98430: PPUSH
// result := See ( your_side , unit ) ;
98431: LD_ADDR_VAR 0 2
98435: PUSH
98436: LD_OWVAR 2
98440: PPUSH
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 292
98450: ST_TO_ADDR
// end ;
98451: LD_VAR 0 2
98455: RET
// export function ReverseDir ( unit ) ; begin
98456: LD_INT 0
98458: PPUSH
// if not unit then
98459: LD_VAR 0 1
98463: NOT
98464: IFFALSE 98468
// exit ;
98466: GO 98491
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98468: LD_ADDR_VAR 0 2
98472: PUSH
98473: LD_VAR 0 1
98477: PPUSH
98478: CALL_OW 254
98482: PUSH
98483: LD_INT 3
98485: PLUS
98486: PUSH
98487: LD_INT 6
98489: MOD
98490: ST_TO_ADDR
// end ;
98491: LD_VAR 0 2
98495: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98496: LD_INT 0
98498: PPUSH
98499: PPUSH
98500: PPUSH
98501: PPUSH
98502: PPUSH
// if not hexes then
98503: LD_VAR 0 2
98507: NOT
98508: IFFALSE 98512
// exit ;
98510: GO 98660
// dist := 9999 ;
98512: LD_ADDR_VAR 0 5
98516: PUSH
98517: LD_INT 9999
98519: ST_TO_ADDR
// for i = 1 to hexes do
98520: LD_ADDR_VAR 0 4
98524: PUSH
98525: DOUBLE
98526: LD_INT 1
98528: DEC
98529: ST_TO_ADDR
98530: LD_VAR 0 2
98534: PUSH
98535: FOR_TO
98536: IFFALSE 98648
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98538: LD_VAR 0 1
98542: PPUSH
98543: LD_VAR 0 2
98547: PUSH
98548: LD_VAR 0 4
98552: ARRAY
98553: PUSH
98554: LD_INT 1
98556: ARRAY
98557: PPUSH
98558: LD_VAR 0 2
98562: PUSH
98563: LD_VAR 0 4
98567: ARRAY
98568: PUSH
98569: LD_INT 2
98571: ARRAY
98572: PPUSH
98573: CALL_OW 297
98577: PUSH
98578: LD_VAR 0 5
98582: LESS
98583: IFFALSE 98646
// begin hex := hexes [ i ] ;
98585: LD_ADDR_VAR 0 7
98589: PUSH
98590: LD_VAR 0 2
98594: PUSH
98595: LD_VAR 0 4
98599: ARRAY
98600: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98601: LD_ADDR_VAR 0 5
98605: PUSH
98606: LD_VAR 0 1
98610: PPUSH
98611: LD_VAR 0 2
98615: PUSH
98616: LD_VAR 0 4
98620: ARRAY
98621: PUSH
98622: LD_INT 1
98624: ARRAY
98625: PPUSH
98626: LD_VAR 0 2
98630: PUSH
98631: LD_VAR 0 4
98635: ARRAY
98636: PUSH
98637: LD_INT 2
98639: ARRAY
98640: PPUSH
98641: CALL_OW 297
98645: ST_TO_ADDR
// end ; end ;
98646: GO 98535
98648: POP
98649: POP
// result := hex ;
98650: LD_ADDR_VAR 0 3
98654: PUSH
98655: LD_VAR 0 7
98659: ST_TO_ADDR
// end ;
98660: LD_VAR 0 3
98664: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98665: LD_INT 0
98667: PPUSH
98668: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98669: LD_VAR 0 1
98673: NOT
98674: PUSH
98675: LD_VAR 0 1
98679: PUSH
98680: LD_INT 21
98682: PUSH
98683: LD_INT 2
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 23
98692: PUSH
98693: LD_INT 2
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PPUSH
98704: CALL_OW 69
98708: IN
98709: NOT
98710: OR
98711: IFFALSE 98715
// exit ;
98713: GO 98762
// for i = 1 to 3 do
98715: LD_ADDR_VAR 0 3
98719: PUSH
98720: DOUBLE
98721: LD_INT 1
98723: DEC
98724: ST_TO_ADDR
98725: LD_INT 3
98727: PUSH
98728: FOR_TO
98729: IFFALSE 98760
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98731: LD_VAR 0 1
98735: PPUSH
98736: CALL_OW 250
98740: PPUSH
98741: LD_VAR 0 1
98745: PPUSH
98746: CALL_OW 251
98750: PPUSH
98751: LD_INT 1
98753: PPUSH
98754: CALL_OW 453
98758: GO 98728
98760: POP
98761: POP
// end ;
98762: LD_VAR 0 2
98766: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98767: LD_INT 0
98769: PPUSH
98770: PPUSH
98771: PPUSH
98772: PPUSH
98773: PPUSH
98774: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98775: LD_VAR 0 1
98779: NOT
98780: PUSH
98781: LD_VAR 0 2
98785: NOT
98786: OR
98787: PUSH
98788: LD_VAR 0 1
98792: PPUSH
98793: CALL_OW 314
98797: OR
98798: IFFALSE 98802
// exit ;
98800: GO 99243
// x := GetX ( enemy_unit ) ;
98802: LD_ADDR_VAR 0 7
98806: PUSH
98807: LD_VAR 0 2
98811: PPUSH
98812: CALL_OW 250
98816: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98817: LD_ADDR_VAR 0 8
98821: PUSH
98822: LD_VAR 0 2
98826: PPUSH
98827: CALL_OW 251
98831: ST_TO_ADDR
// if not x or not y then
98832: LD_VAR 0 7
98836: NOT
98837: PUSH
98838: LD_VAR 0 8
98842: NOT
98843: OR
98844: IFFALSE 98848
// exit ;
98846: GO 99243
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98848: LD_ADDR_VAR 0 6
98852: PUSH
98853: LD_VAR 0 7
98857: PPUSH
98858: LD_INT 0
98860: PPUSH
98861: LD_INT 4
98863: PPUSH
98864: CALL_OW 272
98868: PUSH
98869: LD_VAR 0 8
98873: PPUSH
98874: LD_INT 0
98876: PPUSH
98877: LD_INT 4
98879: PPUSH
98880: CALL_OW 273
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: PUSH
98889: LD_VAR 0 7
98893: PPUSH
98894: LD_INT 1
98896: PPUSH
98897: LD_INT 4
98899: PPUSH
98900: CALL_OW 272
98904: PUSH
98905: LD_VAR 0 8
98909: PPUSH
98910: LD_INT 1
98912: PPUSH
98913: LD_INT 4
98915: PPUSH
98916: CALL_OW 273
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_VAR 0 7
98929: PPUSH
98930: LD_INT 2
98932: PPUSH
98933: LD_INT 4
98935: PPUSH
98936: CALL_OW 272
98940: PUSH
98941: LD_VAR 0 8
98945: PPUSH
98946: LD_INT 2
98948: PPUSH
98949: LD_INT 4
98951: PPUSH
98952: CALL_OW 273
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PUSH
98961: LD_VAR 0 7
98965: PPUSH
98966: LD_INT 3
98968: PPUSH
98969: LD_INT 4
98971: PPUSH
98972: CALL_OW 272
98976: PUSH
98977: LD_VAR 0 8
98981: PPUSH
98982: LD_INT 3
98984: PPUSH
98985: LD_INT 4
98987: PPUSH
98988: CALL_OW 273
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PUSH
98997: LD_VAR 0 7
99001: PPUSH
99002: LD_INT 4
99004: PPUSH
99005: LD_INT 4
99007: PPUSH
99008: CALL_OW 272
99012: PUSH
99013: LD_VAR 0 8
99017: PPUSH
99018: LD_INT 4
99020: PPUSH
99021: LD_INT 4
99023: PPUSH
99024: CALL_OW 273
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_VAR 0 7
99037: PPUSH
99038: LD_INT 5
99040: PPUSH
99041: LD_INT 4
99043: PPUSH
99044: CALL_OW 272
99048: PUSH
99049: LD_VAR 0 8
99053: PPUSH
99054: LD_INT 5
99056: PPUSH
99057: LD_INT 4
99059: PPUSH
99060: CALL_OW 273
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: PUSH
99069: EMPTY
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: ST_TO_ADDR
// for i = tmp downto 1 do
99077: LD_ADDR_VAR 0 4
99081: PUSH
99082: DOUBLE
99083: LD_VAR 0 6
99087: INC
99088: ST_TO_ADDR
99089: LD_INT 1
99091: PUSH
99092: FOR_DOWNTO
99093: IFFALSE 99194
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99095: LD_VAR 0 6
99099: PUSH
99100: LD_VAR 0 4
99104: ARRAY
99105: PUSH
99106: LD_INT 1
99108: ARRAY
99109: PPUSH
99110: LD_VAR 0 6
99114: PUSH
99115: LD_VAR 0 4
99119: ARRAY
99120: PUSH
99121: LD_INT 2
99123: ARRAY
99124: PPUSH
99125: CALL_OW 488
99129: NOT
99130: PUSH
99131: LD_VAR 0 6
99135: PUSH
99136: LD_VAR 0 4
99140: ARRAY
99141: PUSH
99142: LD_INT 1
99144: ARRAY
99145: PPUSH
99146: LD_VAR 0 6
99150: PUSH
99151: LD_VAR 0 4
99155: ARRAY
99156: PUSH
99157: LD_INT 2
99159: ARRAY
99160: PPUSH
99161: CALL_OW 428
99165: PUSH
99166: LD_INT 0
99168: NONEQUAL
99169: OR
99170: IFFALSE 99192
// tmp := Delete ( tmp , i ) ;
99172: LD_ADDR_VAR 0 6
99176: PUSH
99177: LD_VAR 0 6
99181: PPUSH
99182: LD_VAR 0 4
99186: PPUSH
99187: CALL_OW 3
99191: ST_TO_ADDR
99192: GO 99092
99194: POP
99195: POP
// j := GetClosestHex ( unit , tmp ) ;
99196: LD_ADDR_VAR 0 5
99200: PUSH
99201: LD_VAR 0 1
99205: PPUSH
99206: LD_VAR 0 6
99210: PPUSH
99211: CALL 98496 0 2
99215: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99216: LD_VAR 0 1
99220: PPUSH
99221: LD_VAR 0 5
99225: PUSH
99226: LD_INT 1
99228: ARRAY
99229: PPUSH
99230: LD_VAR 0 5
99234: PUSH
99235: LD_INT 2
99237: ARRAY
99238: PPUSH
99239: CALL_OW 111
// end ;
99243: LD_VAR 0 3
99247: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99248: LD_INT 0
99250: PPUSH
99251: PPUSH
99252: PPUSH
// uc_side = 0 ;
99253: LD_ADDR_OWVAR 20
99257: PUSH
99258: LD_INT 0
99260: ST_TO_ADDR
// uc_nation = 0 ;
99261: LD_ADDR_OWVAR 21
99265: PUSH
99266: LD_INT 0
99268: ST_TO_ADDR
// InitHc_All ( ) ;
99269: CALL_OW 584
// InitVc ;
99273: CALL_OW 20
// if mastodonts then
99277: LD_VAR 0 6
99281: IFFALSE 99348
// for i = 1 to mastodonts do
99283: LD_ADDR_VAR 0 11
99287: PUSH
99288: DOUBLE
99289: LD_INT 1
99291: DEC
99292: ST_TO_ADDR
99293: LD_VAR 0 6
99297: PUSH
99298: FOR_TO
99299: IFFALSE 99346
// begin vc_chassis := 31 ;
99301: LD_ADDR_OWVAR 37
99305: PUSH
99306: LD_INT 31
99308: ST_TO_ADDR
// vc_control := control_rider ;
99309: LD_ADDR_OWVAR 38
99313: PUSH
99314: LD_INT 4
99316: ST_TO_ADDR
// animal := CreateVehicle ;
99317: LD_ADDR_VAR 0 12
99321: PUSH
99322: CALL_OW 45
99326: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99327: LD_VAR 0 12
99331: PPUSH
99332: LD_VAR 0 8
99336: PPUSH
99337: LD_INT 0
99339: PPUSH
99340: CALL 101536 0 3
// end ;
99344: GO 99298
99346: POP
99347: POP
// if horses then
99348: LD_VAR 0 5
99352: IFFALSE 99419
// for i = 1 to horses do
99354: LD_ADDR_VAR 0 11
99358: PUSH
99359: DOUBLE
99360: LD_INT 1
99362: DEC
99363: ST_TO_ADDR
99364: LD_VAR 0 5
99368: PUSH
99369: FOR_TO
99370: IFFALSE 99417
// begin hc_class := 21 ;
99372: LD_ADDR_OWVAR 28
99376: PUSH
99377: LD_INT 21
99379: ST_TO_ADDR
// hc_gallery :=  ;
99380: LD_ADDR_OWVAR 33
99384: PUSH
99385: LD_STRING 
99387: ST_TO_ADDR
// animal := CreateHuman ;
99388: LD_ADDR_VAR 0 12
99392: PUSH
99393: CALL_OW 44
99397: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99398: LD_VAR 0 12
99402: PPUSH
99403: LD_VAR 0 8
99407: PPUSH
99408: LD_INT 0
99410: PPUSH
99411: CALL 101536 0 3
// end ;
99415: GO 99369
99417: POP
99418: POP
// if birds then
99419: LD_VAR 0 1
99423: IFFALSE 99490
// for i = 1 to birds do
99425: LD_ADDR_VAR 0 11
99429: PUSH
99430: DOUBLE
99431: LD_INT 1
99433: DEC
99434: ST_TO_ADDR
99435: LD_VAR 0 1
99439: PUSH
99440: FOR_TO
99441: IFFALSE 99488
// begin hc_class = 18 ;
99443: LD_ADDR_OWVAR 28
99447: PUSH
99448: LD_INT 18
99450: ST_TO_ADDR
// hc_gallery =  ;
99451: LD_ADDR_OWVAR 33
99455: PUSH
99456: LD_STRING 
99458: ST_TO_ADDR
// animal := CreateHuman ;
99459: LD_ADDR_VAR 0 12
99463: PUSH
99464: CALL_OW 44
99468: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99469: LD_VAR 0 12
99473: PPUSH
99474: LD_VAR 0 8
99478: PPUSH
99479: LD_INT 0
99481: PPUSH
99482: CALL 101536 0 3
// end ;
99486: GO 99440
99488: POP
99489: POP
// if tigers then
99490: LD_VAR 0 2
99494: IFFALSE 99578
// for i = 1 to tigers do
99496: LD_ADDR_VAR 0 11
99500: PUSH
99501: DOUBLE
99502: LD_INT 1
99504: DEC
99505: ST_TO_ADDR
99506: LD_VAR 0 2
99510: PUSH
99511: FOR_TO
99512: IFFALSE 99576
// begin hc_class = class_tiger ;
99514: LD_ADDR_OWVAR 28
99518: PUSH
99519: LD_INT 14
99521: ST_TO_ADDR
// hc_gallery =  ;
99522: LD_ADDR_OWVAR 33
99526: PUSH
99527: LD_STRING 
99529: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99530: LD_ADDR_OWVAR 35
99534: PUSH
99535: LD_INT 7
99537: NEG
99538: PPUSH
99539: LD_INT 7
99541: PPUSH
99542: CALL_OW 12
99546: ST_TO_ADDR
// animal := CreateHuman ;
99547: LD_ADDR_VAR 0 12
99551: PUSH
99552: CALL_OW 44
99556: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99557: LD_VAR 0 12
99561: PPUSH
99562: LD_VAR 0 8
99566: PPUSH
99567: LD_INT 0
99569: PPUSH
99570: CALL 101536 0 3
// end ;
99574: GO 99511
99576: POP
99577: POP
// if apemans then
99578: LD_VAR 0 3
99582: IFFALSE 99705
// for i = 1 to apemans do
99584: LD_ADDR_VAR 0 11
99588: PUSH
99589: DOUBLE
99590: LD_INT 1
99592: DEC
99593: ST_TO_ADDR
99594: LD_VAR 0 3
99598: PUSH
99599: FOR_TO
99600: IFFALSE 99703
// begin hc_class = class_apeman ;
99602: LD_ADDR_OWVAR 28
99606: PUSH
99607: LD_INT 12
99609: ST_TO_ADDR
// hc_gallery =  ;
99610: LD_ADDR_OWVAR 33
99614: PUSH
99615: LD_STRING 
99617: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99618: LD_ADDR_OWVAR 35
99622: PUSH
99623: LD_INT 2
99625: NEG
99626: PPUSH
99627: LD_INT 2
99629: PPUSH
99630: CALL_OW 12
99634: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99635: LD_ADDR_OWVAR 31
99639: PUSH
99640: LD_INT 1
99642: PPUSH
99643: LD_INT 3
99645: PPUSH
99646: CALL_OW 12
99650: PUSH
99651: LD_INT 1
99653: PPUSH
99654: LD_INT 3
99656: PPUSH
99657: CALL_OW 12
99661: PUSH
99662: LD_INT 0
99664: PUSH
99665: LD_INT 0
99667: PUSH
99668: EMPTY
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: ST_TO_ADDR
// animal := CreateHuman ;
99674: LD_ADDR_VAR 0 12
99678: PUSH
99679: CALL_OW 44
99683: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99684: LD_VAR 0 12
99688: PPUSH
99689: LD_VAR 0 8
99693: PPUSH
99694: LD_INT 0
99696: PPUSH
99697: CALL 101536 0 3
// end ;
99701: GO 99599
99703: POP
99704: POP
// if enchidnas then
99705: LD_VAR 0 4
99709: IFFALSE 99776
// for i = 1 to enchidnas do
99711: LD_ADDR_VAR 0 11
99715: PUSH
99716: DOUBLE
99717: LD_INT 1
99719: DEC
99720: ST_TO_ADDR
99721: LD_VAR 0 4
99725: PUSH
99726: FOR_TO
99727: IFFALSE 99774
// begin hc_class = 13 ;
99729: LD_ADDR_OWVAR 28
99733: PUSH
99734: LD_INT 13
99736: ST_TO_ADDR
// hc_gallery =  ;
99737: LD_ADDR_OWVAR 33
99741: PUSH
99742: LD_STRING 
99744: ST_TO_ADDR
// animal := CreateHuman ;
99745: LD_ADDR_VAR 0 12
99749: PUSH
99750: CALL_OW 44
99754: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99755: LD_VAR 0 12
99759: PPUSH
99760: LD_VAR 0 8
99764: PPUSH
99765: LD_INT 0
99767: PPUSH
99768: CALL 101536 0 3
// end ;
99772: GO 99726
99774: POP
99775: POP
// if fishes then
99776: LD_VAR 0 7
99780: IFFALSE 99847
// for i = 1 to fishes do
99782: LD_ADDR_VAR 0 11
99786: PUSH
99787: DOUBLE
99788: LD_INT 1
99790: DEC
99791: ST_TO_ADDR
99792: LD_VAR 0 7
99796: PUSH
99797: FOR_TO
99798: IFFALSE 99845
// begin hc_class = 20 ;
99800: LD_ADDR_OWVAR 28
99804: PUSH
99805: LD_INT 20
99807: ST_TO_ADDR
// hc_gallery =  ;
99808: LD_ADDR_OWVAR 33
99812: PUSH
99813: LD_STRING 
99815: ST_TO_ADDR
// animal := CreateHuman ;
99816: LD_ADDR_VAR 0 12
99820: PUSH
99821: CALL_OW 44
99825: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99826: LD_VAR 0 12
99830: PPUSH
99831: LD_VAR 0 9
99835: PPUSH
99836: LD_INT 0
99838: PPUSH
99839: CALL 101536 0 3
// end ;
99843: GO 99797
99845: POP
99846: POP
// end ;
99847: LD_VAR 0 10
99851: RET
// export function WantHeal ( sci , unit ) ; begin
99852: LD_INT 0
99854: PPUSH
// if GetTaskList ( sci ) > 0 then
99855: LD_VAR 0 1
99859: PPUSH
99860: CALL_OW 437
99864: PUSH
99865: LD_INT 0
99867: GREATER
99868: IFFALSE 99938
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99870: LD_VAR 0 1
99874: PPUSH
99875: CALL_OW 437
99879: PUSH
99880: LD_INT 1
99882: ARRAY
99883: PUSH
99884: LD_INT 1
99886: ARRAY
99887: PUSH
99888: LD_STRING l
99890: EQUAL
99891: PUSH
99892: LD_VAR 0 1
99896: PPUSH
99897: CALL_OW 437
99901: PUSH
99902: LD_INT 1
99904: ARRAY
99905: PUSH
99906: LD_INT 4
99908: ARRAY
99909: PUSH
99910: LD_VAR 0 2
99914: EQUAL
99915: AND
99916: IFFALSE 99928
// result := true else
99918: LD_ADDR_VAR 0 3
99922: PUSH
99923: LD_INT 1
99925: ST_TO_ADDR
99926: GO 99936
// result := false ;
99928: LD_ADDR_VAR 0 3
99932: PUSH
99933: LD_INT 0
99935: ST_TO_ADDR
// end else
99936: GO 99946
// result := false ;
99938: LD_ADDR_VAR 0 3
99942: PUSH
99943: LD_INT 0
99945: ST_TO_ADDR
// end ;
99946: LD_VAR 0 3
99950: RET
// export function HealTarget ( sci ) ; begin
99951: LD_INT 0
99953: PPUSH
// if not sci then
99954: LD_VAR 0 1
99958: NOT
99959: IFFALSE 99963
// exit ;
99961: GO 100028
// result := 0 ;
99963: LD_ADDR_VAR 0 2
99967: PUSH
99968: LD_INT 0
99970: ST_TO_ADDR
// if GetTaskList ( sci ) then
99971: LD_VAR 0 1
99975: PPUSH
99976: CALL_OW 437
99980: IFFALSE 100028
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99982: LD_VAR 0 1
99986: PPUSH
99987: CALL_OW 437
99991: PUSH
99992: LD_INT 1
99994: ARRAY
99995: PUSH
99996: LD_INT 1
99998: ARRAY
99999: PUSH
100000: LD_STRING l
100002: EQUAL
100003: IFFALSE 100028
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100005: LD_ADDR_VAR 0 2
100009: PUSH
100010: LD_VAR 0 1
100014: PPUSH
100015: CALL_OW 437
100019: PUSH
100020: LD_INT 1
100022: ARRAY
100023: PUSH
100024: LD_INT 4
100026: ARRAY
100027: ST_TO_ADDR
// end ;
100028: LD_VAR 0 2
100032: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100033: LD_INT 0
100035: PPUSH
100036: PPUSH
100037: PPUSH
100038: PPUSH
// if not base_units then
100039: LD_VAR 0 1
100043: NOT
100044: IFFALSE 100048
// exit ;
100046: GO 100135
// result := false ;
100048: LD_ADDR_VAR 0 2
100052: PUSH
100053: LD_INT 0
100055: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100056: LD_ADDR_VAR 0 5
100060: PUSH
100061: LD_VAR 0 1
100065: PPUSH
100066: LD_INT 21
100068: PUSH
100069: LD_INT 3
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PPUSH
100076: CALL_OW 72
100080: ST_TO_ADDR
// if not tmp then
100081: LD_VAR 0 5
100085: NOT
100086: IFFALSE 100090
// exit ;
100088: GO 100135
// for i in tmp do
100090: LD_ADDR_VAR 0 3
100094: PUSH
100095: LD_VAR 0 5
100099: PUSH
100100: FOR_IN
100101: IFFALSE 100133
// begin result := EnemyInRange ( i , 22 ) ;
100103: LD_ADDR_VAR 0 2
100107: PUSH
100108: LD_VAR 0 3
100112: PPUSH
100113: LD_INT 22
100115: PPUSH
100116: CALL 98371 0 2
100120: ST_TO_ADDR
// if result then
100121: LD_VAR 0 2
100125: IFFALSE 100131
// exit ;
100127: POP
100128: POP
100129: GO 100135
// end ;
100131: GO 100100
100133: POP
100134: POP
// end ;
100135: LD_VAR 0 2
100139: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
100140: LD_INT 0
100142: PPUSH
100143: PPUSH
// if not units then
100144: LD_VAR 0 1
100148: NOT
100149: IFFALSE 100153
// exit ;
100151: GO 100223
// result := [ ] ;
100153: LD_ADDR_VAR 0 3
100157: PUSH
100158: EMPTY
100159: ST_TO_ADDR
// for i in units do
100160: LD_ADDR_VAR 0 4
100164: PUSH
100165: LD_VAR 0 1
100169: PUSH
100170: FOR_IN
100171: IFFALSE 100221
// if GetTag ( i ) = tag then
100173: LD_VAR 0 4
100177: PPUSH
100178: CALL_OW 110
100182: PUSH
100183: LD_VAR 0 2
100187: EQUAL
100188: IFFALSE 100219
// result := Replace ( result , result + 1 , i ) ;
100190: LD_ADDR_VAR 0 3
100194: PUSH
100195: LD_VAR 0 3
100199: PPUSH
100200: LD_VAR 0 3
100204: PUSH
100205: LD_INT 1
100207: PLUS
100208: PPUSH
100209: LD_VAR 0 4
100213: PPUSH
100214: CALL_OW 1
100218: ST_TO_ADDR
100219: GO 100170
100221: POP
100222: POP
// end ;
100223: LD_VAR 0 3
100227: RET
// export function IsDriver ( un ) ; begin
100228: LD_INT 0
100230: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100231: LD_ADDR_VAR 0 2
100235: PUSH
100236: LD_VAR 0 1
100240: PUSH
100241: LD_INT 55
100243: PUSH
100244: EMPTY
100245: LIST
100246: PPUSH
100247: CALL_OW 69
100251: IN
100252: ST_TO_ADDR
// end ;
100253: LD_VAR 0 2
100257: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100258: LD_INT 0
100260: PPUSH
100261: PPUSH
// list := [ ] ;
100262: LD_ADDR_VAR 0 5
100266: PUSH
100267: EMPTY
100268: ST_TO_ADDR
// case d of 0 :
100269: LD_VAR 0 3
100273: PUSH
100274: LD_INT 0
100276: DOUBLE
100277: EQUAL
100278: IFTRUE 100282
100280: GO 100415
100282: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100283: LD_ADDR_VAR 0 5
100287: PUSH
100288: LD_VAR 0 1
100292: PUSH
100293: LD_INT 4
100295: MINUS
100296: PUSH
100297: LD_VAR 0 2
100301: PUSH
100302: LD_INT 4
100304: MINUS
100305: PUSH
100306: LD_INT 2
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: LIST
100313: PUSH
100314: LD_VAR 0 1
100318: PUSH
100319: LD_INT 3
100321: MINUS
100322: PUSH
100323: LD_VAR 0 2
100327: PUSH
100328: LD_INT 1
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: LIST
100335: PUSH
100336: LD_VAR 0 1
100340: PUSH
100341: LD_INT 4
100343: PLUS
100344: PUSH
100345: LD_VAR 0 2
100349: PUSH
100350: LD_INT 4
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: LIST
100357: PUSH
100358: LD_VAR 0 1
100362: PUSH
100363: LD_INT 3
100365: PLUS
100366: PUSH
100367: LD_VAR 0 2
100371: PUSH
100372: LD_INT 3
100374: PLUS
100375: PUSH
100376: LD_INT 5
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: LIST
100383: PUSH
100384: LD_VAR 0 1
100388: PUSH
100389: LD_VAR 0 2
100393: PUSH
100394: LD_INT 4
100396: PLUS
100397: PUSH
100398: LD_INT 0
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: LIST
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: ST_TO_ADDR
// end ; 1 :
100413: GO 101113
100415: LD_INT 1
100417: DOUBLE
100418: EQUAL
100419: IFTRUE 100423
100421: GO 100556
100423: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100424: LD_ADDR_VAR 0 5
100428: PUSH
100429: LD_VAR 0 1
100433: PUSH
100434: LD_VAR 0 2
100438: PUSH
100439: LD_INT 4
100441: MINUS
100442: PUSH
100443: LD_INT 3
100445: PUSH
100446: EMPTY
100447: LIST
100448: LIST
100449: LIST
100450: PUSH
100451: LD_VAR 0 1
100455: PUSH
100456: LD_INT 3
100458: MINUS
100459: PUSH
100460: LD_VAR 0 2
100464: PUSH
100465: LD_INT 3
100467: MINUS
100468: PUSH
100469: LD_INT 2
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: LIST
100476: PUSH
100477: LD_VAR 0 1
100481: PUSH
100482: LD_INT 4
100484: MINUS
100485: PUSH
100486: LD_VAR 0 2
100490: PUSH
100491: LD_INT 1
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: LIST
100498: PUSH
100499: LD_VAR 0 1
100503: PUSH
100504: LD_VAR 0 2
100508: PUSH
100509: LD_INT 3
100511: PLUS
100512: PUSH
100513: LD_INT 0
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: LIST
100520: PUSH
100521: LD_VAR 0 1
100525: PUSH
100526: LD_INT 4
100528: PLUS
100529: PUSH
100530: LD_VAR 0 2
100534: PUSH
100535: LD_INT 4
100537: PLUS
100538: PUSH
100539: LD_INT 5
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: LIST
100546: PUSH
100547: EMPTY
100548: LIST
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: ST_TO_ADDR
// end ; 2 :
100554: GO 101113
100556: LD_INT 2
100558: DOUBLE
100559: EQUAL
100560: IFTRUE 100564
100562: GO 100693
100564: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100565: LD_ADDR_VAR 0 5
100569: PUSH
100570: LD_VAR 0 1
100574: PUSH
100575: LD_VAR 0 2
100579: PUSH
100580: LD_INT 3
100582: MINUS
100583: PUSH
100584: LD_INT 3
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: LIST
100591: PUSH
100592: LD_VAR 0 1
100596: PUSH
100597: LD_INT 4
100599: PLUS
100600: PUSH
100601: LD_VAR 0 2
100605: PUSH
100606: LD_INT 4
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: LIST
100613: PUSH
100614: LD_VAR 0 1
100618: PUSH
100619: LD_VAR 0 2
100623: PUSH
100624: LD_INT 4
100626: PLUS
100627: PUSH
100628: LD_INT 0
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: LIST
100635: PUSH
100636: LD_VAR 0 1
100640: PUSH
100641: LD_INT 3
100643: MINUS
100644: PUSH
100645: LD_VAR 0 2
100649: PUSH
100650: LD_INT 1
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: LIST
100657: PUSH
100658: LD_VAR 0 1
100662: PUSH
100663: LD_INT 4
100665: MINUS
100666: PUSH
100667: LD_VAR 0 2
100671: PUSH
100672: LD_INT 4
100674: MINUS
100675: PUSH
100676: LD_INT 2
100678: PUSH
100679: EMPTY
100680: LIST
100681: LIST
100682: LIST
100683: PUSH
100684: EMPTY
100685: LIST
100686: LIST
100687: LIST
100688: LIST
100689: LIST
100690: ST_TO_ADDR
// end ; 3 :
100691: GO 101113
100693: LD_INT 3
100695: DOUBLE
100696: EQUAL
100697: IFTRUE 100701
100699: GO 100834
100701: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100702: LD_ADDR_VAR 0 5
100706: PUSH
100707: LD_VAR 0 1
100711: PUSH
100712: LD_INT 3
100714: PLUS
100715: PUSH
100716: LD_VAR 0 2
100720: PUSH
100721: LD_INT 4
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: LIST
100728: PUSH
100729: LD_VAR 0 1
100733: PUSH
100734: LD_INT 4
100736: PLUS
100737: PUSH
100738: LD_VAR 0 2
100742: PUSH
100743: LD_INT 4
100745: PLUS
100746: PUSH
100747: LD_INT 5
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: LIST
100754: PUSH
100755: LD_VAR 0 1
100759: PUSH
100760: LD_INT 4
100762: MINUS
100763: PUSH
100764: LD_VAR 0 2
100768: PUSH
100769: LD_INT 1
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: LIST
100776: PUSH
100777: LD_VAR 0 1
100781: PUSH
100782: LD_VAR 0 2
100786: PUSH
100787: LD_INT 4
100789: MINUS
100790: PUSH
100791: LD_INT 3
100793: PUSH
100794: EMPTY
100795: LIST
100796: LIST
100797: LIST
100798: PUSH
100799: LD_VAR 0 1
100803: PUSH
100804: LD_INT 3
100806: MINUS
100807: PUSH
100808: LD_VAR 0 2
100812: PUSH
100813: LD_INT 3
100815: MINUS
100816: PUSH
100817: LD_INT 2
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: LIST
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: LIST
100831: ST_TO_ADDR
// end ; 4 :
100832: GO 101113
100834: LD_INT 4
100836: DOUBLE
100837: EQUAL
100838: IFTRUE 100842
100840: GO 100975
100842: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100843: LD_ADDR_VAR 0 5
100847: PUSH
100848: LD_VAR 0 1
100852: PUSH
100853: LD_VAR 0 2
100857: PUSH
100858: LD_INT 4
100860: PLUS
100861: PUSH
100862: LD_INT 0
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: LIST
100869: PUSH
100870: LD_VAR 0 1
100874: PUSH
100875: LD_INT 3
100877: PLUS
100878: PUSH
100879: LD_VAR 0 2
100883: PUSH
100884: LD_INT 3
100886: PLUS
100887: PUSH
100888: LD_INT 5
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: LIST
100895: PUSH
100896: LD_VAR 0 1
100900: PUSH
100901: LD_INT 4
100903: PLUS
100904: PUSH
100905: LD_VAR 0 2
100909: PUSH
100910: LD_INT 4
100912: PUSH
100913: EMPTY
100914: LIST
100915: LIST
100916: LIST
100917: PUSH
100918: LD_VAR 0 1
100922: PUSH
100923: LD_VAR 0 2
100927: PUSH
100928: LD_INT 3
100930: MINUS
100931: PUSH
100932: LD_INT 3
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: LIST
100939: PUSH
100940: LD_VAR 0 1
100944: PUSH
100945: LD_INT 4
100947: MINUS
100948: PUSH
100949: LD_VAR 0 2
100953: PUSH
100954: LD_INT 4
100956: MINUS
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: PUSH
100966: EMPTY
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: ST_TO_ADDR
// end ; 5 :
100973: GO 101113
100975: LD_INT 5
100977: DOUBLE
100978: EQUAL
100979: IFTRUE 100983
100981: GO 101112
100983: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100984: LD_ADDR_VAR 0 5
100988: PUSH
100989: LD_VAR 0 1
100993: PUSH
100994: LD_INT 4
100996: MINUS
100997: PUSH
100998: LD_VAR 0 2
101002: PUSH
101003: LD_INT 1
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: LIST
101010: PUSH
101011: LD_VAR 0 1
101015: PUSH
101016: LD_VAR 0 2
101020: PUSH
101021: LD_INT 4
101023: MINUS
101024: PUSH
101025: LD_INT 3
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: LIST
101032: PUSH
101033: LD_VAR 0 1
101037: PUSH
101038: LD_INT 4
101040: PLUS
101041: PUSH
101042: LD_VAR 0 2
101046: PUSH
101047: LD_INT 4
101049: PLUS
101050: PUSH
101051: LD_INT 5
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: LIST
101058: PUSH
101059: LD_VAR 0 1
101063: PUSH
101064: LD_INT 3
101066: PLUS
101067: PUSH
101068: LD_VAR 0 2
101072: PUSH
101073: LD_INT 4
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: LIST
101080: PUSH
101081: LD_VAR 0 1
101085: PUSH
101086: LD_VAR 0 2
101090: PUSH
101091: LD_INT 3
101093: PLUS
101094: PUSH
101095: LD_INT 0
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: LIST
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: ST_TO_ADDR
// end ; end ;
101110: GO 101113
101112: POP
// result := list ;
101113: LD_ADDR_VAR 0 4
101117: PUSH
101118: LD_VAR 0 5
101122: ST_TO_ADDR
// end ;
101123: LD_VAR 0 4
101127: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101128: LD_INT 0
101130: PPUSH
101131: PPUSH
101132: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101133: LD_VAR 0 1
101137: NOT
101138: PUSH
101139: LD_VAR 0 2
101143: PUSH
101144: LD_INT 1
101146: PUSH
101147: LD_INT 2
101149: PUSH
101150: LD_INT 3
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: IN
101162: NOT
101163: OR
101164: IFFALSE 101168
// exit ;
101166: GO 101260
// tmp := [ ] ;
101168: LD_ADDR_VAR 0 5
101172: PUSH
101173: EMPTY
101174: ST_TO_ADDR
// for i in units do
101175: LD_ADDR_VAR 0 4
101179: PUSH
101180: LD_VAR 0 1
101184: PUSH
101185: FOR_IN
101186: IFFALSE 101229
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101188: LD_ADDR_VAR 0 5
101192: PUSH
101193: LD_VAR 0 5
101197: PPUSH
101198: LD_VAR 0 5
101202: PUSH
101203: LD_INT 1
101205: PLUS
101206: PPUSH
101207: LD_VAR 0 4
101211: PPUSH
101212: LD_VAR 0 2
101216: PPUSH
101217: CALL_OW 259
101221: PPUSH
101222: CALL_OW 2
101226: ST_TO_ADDR
101227: GO 101185
101229: POP
101230: POP
// if not tmp then
101231: LD_VAR 0 5
101235: NOT
101236: IFFALSE 101240
// exit ;
101238: GO 101260
// result := SortListByListDesc ( units , tmp ) ;
101240: LD_ADDR_VAR 0 3
101244: PUSH
101245: LD_VAR 0 1
101249: PPUSH
101250: LD_VAR 0 5
101254: PPUSH
101255: CALL_OW 77
101259: ST_TO_ADDR
// end ;
101260: LD_VAR 0 3
101264: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101265: LD_INT 0
101267: PPUSH
101268: PPUSH
101269: PPUSH
// result := false ;
101270: LD_ADDR_VAR 0 3
101274: PUSH
101275: LD_INT 0
101277: ST_TO_ADDR
// x := GetX ( building ) ;
101278: LD_ADDR_VAR 0 4
101282: PUSH
101283: LD_VAR 0 2
101287: PPUSH
101288: CALL_OW 250
101292: ST_TO_ADDR
// y := GetY ( building ) ;
101293: LD_ADDR_VAR 0 5
101297: PUSH
101298: LD_VAR 0 2
101302: PPUSH
101303: CALL_OW 251
101307: ST_TO_ADDR
// if not building or not x or not y then
101308: LD_VAR 0 2
101312: NOT
101313: PUSH
101314: LD_VAR 0 4
101318: NOT
101319: OR
101320: PUSH
101321: LD_VAR 0 5
101325: NOT
101326: OR
101327: IFFALSE 101331
// exit ;
101329: GO 101423
// if GetTaskList ( unit ) then
101331: LD_VAR 0 1
101335: PPUSH
101336: CALL_OW 437
101340: IFFALSE 101423
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101342: LD_STRING e
101344: PUSH
101345: LD_VAR 0 1
101349: PPUSH
101350: CALL_OW 437
101354: PUSH
101355: LD_INT 1
101357: ARRAY
101358: PUSH
101359: LD_INT 1
101361: ARRAY
101362: EQUAL
101363: PUSH
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 1
101373: PPUSH
101374: CALL_OW 437
101378: PUSH
101379: LD_INT 1
101381: ARRAY
101382: PUSH
101383: LD_INT 2
101385: ARRAY
101386: EQUAL
101387: AND
101388: PUSH
101389: LD_VAR 0 5
101393: PUSH
101394: LD_VAR 0 1
101398: PPUSH
101399: CALL_OW 437
101403: PUSH
101404: LD_INT 1
101406: ARRAY
101407: PUSH
101408: LD_INT 3
101410: ARRAY
101411: EQUAL
101412: AND
101413: IFFALSE 101423
// result := true end ;
101415: LD_ADDR_VAR 0 3
101419: PUSH
101420: LD_INT 1
101422: ST_TO_ADDR
// end ;
101423: LD_VAR 0 3
101427: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101428: LD_INT 0
101430: PPUSH
// result := false ;
101431: LD_ADDR_VAR 0 4
101435: PUSH
101436: LD_INT 0
101438: ST_TO_ADDR
// if GetTaskList ( unit ) then
101439: LD_VAR 0 1
101443: PPUSH
101444: CALL_OW 437
101448: IFFALSE 101531
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101450: LD_STRING M
101452: PUSH
101453: LD_VAR 0 1
101457: PPUSH
101458: CALL_OW 437
101462: PUSH
101463: LD_INT 1
101465: ARRAY
101466: PUSH
101467: LD_INT 1
101469: ARRAY
101470: EQUAL
101471: PUSH
101472: LD_VAR 0 2
101476: PUSH
101477: LD_VAR 0 1
101481: PPUSH
101482: CALL_OW 437
101486: PUSH
101487: LD_INT 1
101489: ARRAY
101490: PUSH
101491: LD_INT 2
101493: ARRAY
101494: EQUAL
101495: AND
101496: PUSH
101497: LD_VAR 0 3
101501: PUSH
101502: LD_VAR 0 1
101506: PPUSH
101507: CALL_OW 437
101511: PUSH
101512: LD_INT 1
101514: ARRAY
101515: PUSH
101516: LD_INT 3
101518: ARRAY
101519: EQUAL
101520: AND
101521: IFFALSE 101531
// result := true ;
101523: LD_ADDR_VAR 0 4
101527: PUSH
101528: LD_INT 1
101530: ST_TO_ADDR
// end ; end ;
101531: LD_VAR 0 4
101535: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101536: LD_INT 0
101538: PPUSH
101539: PPUSH
101540: PPUSH
101541: PPUSH
// if not unit or not area then
101542: LD_VAR 0 1
101546: NOT
101547: PUSH
101548: LD_VAR 0 2
101552: NOT
101553: OR
101554: IFFALSE 101558
// exit ;
101556: GO 101722
// tmp := AreaToList ( area , i ) ;
101558: LD_ADDR_VAR 0 6
101562: PUSH
101563: LD_VAR 0 2
101567: PPUSH
101568: LD_VAR 0 5
101572: PPUSH
101573: CALL_OW 517
101577: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101578: LD_ADDR_VAR 0 5
101582: PUSH
101583: DOUBLE
101584: LD_INT 1
101586: DEC
101587: ST_TO_ADDR
101588: LD_VAR 0 6
101592: PUSH
101593: LD_INT 1
101595: ARRAY
101596: PUSH
101597: FOR_TO
101598: IFFALSE 101720
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101600: LD_ADDR_VAR 0 7
101604: PUSH
101605: LD_VAR 0 6
101609: PUSH
101610: LD_INT 1
101612: ARRAY
101613: PUSH
101614: LD_VAR 0 5
101618: ARRAY
101619: PUSH
101620: LD_VAR 0 6
101624: PUSH
101625: LD_INT 2
101627: ARRAY
101628: PUSH
101629: LD_VAR 0 5
101633: ARRAY
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101639: LD_VAR 0 7
101643: PUSH
101644: LD_INT 1
101646: ARRAY
101647: PPUSH
101648: LD_VAR 0 7
101652: PUSH
101653: LD_INT 2
101655: ARRAY
101656: PPUSH
101657: CALL_OW 428
101661: PUSH
101662: LD_INT 0
101664: EQUAL
101665: IFFALSE 101718
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101667: LD_VAR 0 1
101671: PPUSH
101672: LD_VAR 0 7
101676: PUSH
101677: LD_INT 1
101679: ARRAY
101680: PPUSH
101681: LD_VAR 0 7
101685: PUSH
101686: LD_INT 2
101688: ARRAY
101689: PPUSH
101690: LD_VAR 0 3
101694: PPUSH
101695: CALL_OW 48
// result := IsPlaced ( unit ) ;
101699: LD_ADDR_VAR 0 4
101703: PUSH
101704: LD_VAR 0 1
101708: PPUSH
101709: CALL_OW 305
101713: ST_TO_ADDR
// exit ;
101714: POP
101715: POP
101716: GO 101722
// end ; end ;
101718: GO 101597
101720: POP
101721: POP
// end ;
101722: LD_VAR 0 4
101726: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101727: LD_INT 0
101729: PPUSH
101730: PPUSH
101731: PPUSH
// if not side or side > 8 then
101732: LD_VAR 0 1
101736: NOT
101737: PUSH
101738: LD_VAR 0 1
101742: PUSH
101743: LD_INT 8
101745: GREATER
101746: OR
101747: IFFALSE 101751
// exit ;
101749: GO 101938
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101751: LD_ADDR_VAR 0 4
101755: PUSH
101756: LD_INT 22
101758: PUSH
101759: LD_VAR 0 1
101763: PUSH
101764: EMPTY
101765: LIST
101766: LIST
101767: PUSH
101768: LD_INT 21
101770: PUSH
101771: LD_INT 3
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PPUSH
101782: CALL_OW 69
101786: ST_TO_ADDR
// if not tmp then
101787: LD_VAR 0 4
101791: NOT
101792: IFFALSE 101796
// exit ;
101794: GO 101938
// enable_addtolog := true ;
101796: LD_ADDR_OWVAR 81
101800: PUSH
101801: LD_INT 1
101803: ST_TO_ADDR
// AddToLog ( [ ) ;
101804: LD_STRING [
101806: PPUSH
101807: CALL_OW 561
// for i in tmp do
101811: LD_ADDR_VAR 0 3
101815: PUSH
101816: LD_VAR 0 4
101820: PUSH
101821: FOR_IN
101822: IFFALSE 101929
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101824: LD_STRING [
101826: PUSH
101827: LD_VAR 0 3
101831: PPUSH
101832: CALL_OW 266
101836: STR
101837: PUSH
101838: LD_STRING , 
101840: STR
101841: PUSH
101842: LD_VAR 0 3
101846: PPUSH
101847: CALL_OW 250
101851: STR
101852: PUSH
101853: LD_STRING , 
101855: STR
101856: PUSH
101857: LD_VAR 0 3
101861: PPUSH
101862: CALL_OW 251
101866: STR
101867: PUSH
101868: LD_STRING , 
101870: STR
101871: PUSH
101872: LD_VAR 0 3
101876: PPUSH
101877: CALL_OW 254
101881: STR
101882: PUSH
101883: LD_STRING , 
101885: STR
101886: PUSH
101887: LD_VAR 0 3
101891: PPUSH
101892: LD_INT 1
101894: PPUSH
101895: CALL_OW 268
101899: STR
101900: PUSH
101901: LD_STRING , 
101903: STR
101904: PUSH
101905: LD_VAR 0 3
101909: PPUSH
101910: LD_INT 2
101912: PPUSH
101913: CALL_OW 268
101917: STR
101918: PUSH
101919: LD_STRING ],
101921: STR
101922: PPUSH
101923: CALL_OW 561
// end ;
101927: GO 101821
101929: POP
101930: POP
// AddToLog ( ]; ) ;
101931: LD_STRING ];
101933: PPUSH
101934: CALL_OW 561
// end ;
101938: LD_VAR 0 2
101942: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101943: LD_INT 0
101945: PPUSH
101946: PPUSH
101947: PPUSH
101948: PPUSH
101949: PPUSH
// if not area or not rate or not max then
101950: LD_VAR 0 1
101954: NOT
101955: PUSH
101956: LD_VAR 0 2
101960: NOT
101961: OR
101962: PUSH
101963: LD_VAR 0 4
101967: NOT
101968: OR
101969: IFFALSE 101973
// exit ;
101971: GO 102165
// while 1 do
101973: LD_INT 1
101975: IFFALSE 102165
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101977: LD_ADDR_VAR 0 9
101981: PUSH
101982: LD_VAR 0 1
101986: PPUSH
101987: LD_INT 1
101989: PPUSH
101990: CALL_OW 287
101994: PUSH
101995: LD_INT 10
101997: MUL
101998: ST_TO_ADDR
// r := rate / 10 ;
101999: LD_ADDR_VAR 0 7
102003: PUSH
102004: LD_VAR 0 2
102008: PUSH
102009: LD_INT 10
102011: DIVREAL
102012: ST_TO_ADDR
// time := 1 1$00 ;
102013: LD_ADDR_VAR 0 8
102017: PUSH
102018: LD_INT 2100
102020: ST_TO_ADDR
// if amount < min then
102021: LD_VAR 0 9
102025: PUSH
102026: LD_VAR 0 3
102030: LESS
102031: IFFALSE 102049
// r := r * 2 else
102033: LD_ADDR_VAR 0 7
102037: PUSH
102038: LD_VAR 0 7
102042: PUSH
102043: LD_INT 2
102045: MUL
102046: ST_TO_ADDR
102047: GO 102075
// if amount > max then
102049: LD_VAR 0 9
102053: PUSH
102054: LD_VAR 0 4
102058: GREATER
102059: IFFALSE 102075
// r := r / 2 ;
102061: LD_ADDR_VAR 0 7
102065: PUSH
102066: LD_VAR 0 7
102070: PUSH
102071: LD_INT 2
102073: DIVREAL
102074: ST_TO_ADDR
// time := time / r ;
102075: LD_ADDR_VAR 0 8
102079: PUSH
102080: LD_VAR 0 8
102084: PUSH
102085: LD_VAR 0 7
102089: DIVREAL
102090: ST_TO_ADDR
// if time < 0 then
102091: LD_VAR 0 8
102095: PUSH
102096: LD_INT 0
102098: LESS
102099: IFFALSE 102116
// time := time * - 1 ;
102101: LD_ADDR_VAR 0 8
102105: PUSH
102106: LD_VAR 0 8
102110: PUSH
102111: LD_INT 1
102113: NEG
102114: MUL
102115: ST_TO_ADDR
// wait ( time ) ;
102116: LD_VAR 0 8
102120: PPUSH
102121: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
102125: LD_INT 35
102127: PPUSH
102128: LD_INT 875
102130: PPUSH
102131: CALL_OW 12
102135: PPUSH
102136: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102140: LD_INT 1
102142: PPUSH
102143: LD_INT 5
102145: PPUSH
102146: CALL_OW 12
102150: PPUSH
102151: LD_VAR 0 1
102155: PPUSH
102156: LD_INT 1
102158: PPUSH
102159: CALL_OW 55
// end ;
102163: GO 101973
// end ;
102165: LD_VAR 0 5
102169: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102170: LD_INT 0
102172: PPUSH
102173: PPUSH
102174: PPUSH
102175: PPUSH
102176: PPUSH
102177: PPUSH
102178: PPUSH
102179: PPUSH
// if not turrets or not factories then
102180: LD_VAR 0 1
102184: NOT
102185: PUSH
102186: LD_VAR 0 2
102190: NOT
102191: OR
102192: IFFALSE 102196
// exit ;
102194: GO 102503
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102196: LD_ADDR_VAR 0 10
102200: PUSH
102201: LD_INT 5
102203: PUSH
102204: LD_INT 6
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: PUSH
102211: LD_INT 2
102213: PUSH
102214: LD_INT 4
102216: PUSH
102217: EMPTY
102218: LIST
102219: LIST
102220: PUSH
102221: LD_INT 3
102223: PUSH
102224: LD_INT 5
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: EMPTY
102232: LIST
102233: LIST
102234: LIST
102235: PUSH
102236: LD_INT 24
102238: PUSH
102239: LD_INT 25
102241: PUSH
102242: EMPTY
102243: LIST
102244: LIST
102245: PUSH
102246: LD_INT 23
102248: PUSH
102249: LD_INT 27
102251: PUSH
102252: EMPTY
102253: LIST
102254: LIST
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: PUSH
102260: LD_INT 42
102262: PUSH
102263: LD_INT 43
102265: PUSH
102266: EMPTY
102267: LIST
102268: LIST
102269: PUSH
102270: LD_INT 44
102272: PUSH
102273: LD_INT 46
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: PUSH
102280: LD_INT 45
102282: PUSH
102283: LD_INT 47
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: LIST
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: LIST
102299: ST_TO_ADDR
// result := [ ] ;
102300: LD_ADDR_VAR 0 3
102304: PUSH
102305: EMPTY
102306: ST_TO_ADDR
// for i in turrets do
102307: LD_ADDR_VAR 0 4
102311: PUSH
102312: LD_VAR 0 1
102316: PUSH
102317: FOR_IN
102318: IFFALSE 102501
// begin nat := GetNation ( i ) ;
102320: LD_ADDR_VAR 0 7
102324: PUSH
102325: LD_VAR 0 4
102329: PPUSH
102330: CALL_OW 248
102334: ST_TO_ADDR
// weapon := 0 ;
102335: LD_ADDR_VAR 0 8
102339: PUSH
102340: LD_INT 0
102342: ST_TO_ADDR
// if not nat then
102343: LD_VAR 0 7
102347: NOT
102348: IFFALSE 102352
// continue ;
102350: GO 102317
// for j in list [ nat ] do
102352: LD_ADDR_VAR 0 5
102356: PUSH
102357: LD_VAR 0 10
102361: PUSH
102362: LD_VAR 0 7
102366: ARRAY
102367: PUSH
102368: FOR_IN
102369: IFFALSE 102410
// if GetBWeapon ( i ) = j [ 1 ] then
102371: LD_VAR 0 4
102375: PPUSH
102376: CALL_OW 269
102380: PUSH
102381: LD_VAR 0 5
102385: PUSH
102386: LD_INT 1
102388: ARRAY
102389: EQUAL
102390: IFFALSE 102408
// begin weapon := j [ 2 ] ;
102392: LD_ADDR_VAR 0 8
102396: PUSH
102397: LD_VAR 0 5
102401: PUSH
102402: LD_INT 2
102404: ARRAY
102405: ST_TO_ADDR
// break ;
102406: GO 102410
// end ;
102408: GO 102368
102410: POP
102411: POP
// if not weapon then
102412: LD_VAR 0 8
102416: NOT
102417: IFFALSE 102421
// continue ;
102419: GO 102317
// for k in factories do
102421: LD_ADDR_VAR 0 6
102425: PUSH
102426: LD_VAR 0 2
102430: PUSH
102431: FOR_IN
102432: IFFALSE 102497
// begin weapons := AvailableWeaponList ( k ) ;
102434: LD_ADDR_VAR 0 9
102438: PUSH
102439: LD_VAR 0 6
102443: PPUSH
102444: CALL_OW 478
102448: ST_TO_ADDR
// if not weapons then
102449: LD_VAR 0 9
102453: NOT
102454: IFFALSE 102458
// continue ;
102456: GO 102431
// if weapon in weapons then
102458: LD_VAR 0 8
102462: PUSH
102463: LD_VAR 0 9
102467: IN
102468: IFFALSE 102495
// begin result := [ i , weapon ] ;
102470: LD_ADDR_VAR 0 3
102474: PUSH
102475: LD_VAR 0 4
102479: PUSH
102480: LD_VAR 0 8
102484: PUSH
102485: EMPTY
102486: LIST
102487: LIST
102488: ST_TO_ADDR
// exit ;
102489: POP
102490: POP
102491: POP
102492: POP
102493: GO 102503
// end ; end ;
102495: GO 102431
102497: POP
102498: POP
// end ;
102499: GO 102317
102501: POP
102502: POP
// end ;
102503: LD_VAR 0 3
102507: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102508: LD_INT 0
102510: PPUSH
// if not side or side > 8 then
102511: LD_VAR 0 3
102515: NOT
102516: PUSH
102517: LD_VAR 0 3
102521: PUSH
102522: LD_INT 8
102524: GREATER
102525: OR
102526: IFFALSE 102530
// exit ;
102528: GO 102589
// if not range then
102530: LD_VAR 0 4
102534: NOT
102535: IFFALSE 102546
// range := - 12 ;
102537: LD_ADDR_VAR 0 4
102541: PUSH
102542: LD_INT 12
102544: NEG
102545: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102546: LD_VAR 0 1
102550: PPUSH
102551: LD_VAR 0 2
102555: PPUSH
102556: LD_VAR 0 3
102560: PPUSH
102561: LD_VAR 0 4
102565: PPUSH
102566: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102570: LD_VAR 0 1
102574: PPUSH
102575: LD_VAR 0 2
102579: PPUSH
102580: LD_VAR 0 3
102584: PPUSH
102585: CALL_OW 331
// end ;
102589: LD_VAR 0 5
102593: RET
// export function Video ( mode ) ; begin
102594: LD_INT 0
102596: PPUSH
// ingame_video = mode ;
102597: LD_ADDR_OWVAR 52
102601: PUSH
102602: LD_VAR 0 1
102606: ST_TO_ADDR
// interface_hidden = mode ;
102607: LD_ADDR_OWVAR 54
102611: PUSH
102612: LD_VAR 0 1
102616: ST_TO_ADDR
// end ;
102617: LD_VAR 0 2
102621: RET
// export function Join ( array , element ) ; begin
102622: LD_INT 0
102624: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102625: LD_ADDR_VAR 0 3
102629: PUSH
102630: LD_VAR 0 1
102634: PPUSH
102635: LD_VAR 0 1
102639: PUSH
102640: LD_INT 1
102642: PLUS
102643: PPUSH
102644: LD_VAR 0 2
102648: PPUSH
102649: CALL_OW 1
102653: ST_TO_ADDR
// end ;
102654: LD_VAR 0 3
102658: RET
// export function JoinUnion ( array , element ) ; begin
102659: LD_INT 0
102661: PPUSH
// result := array union element ;
102662: LD_ADDR_VAR 0 3
102666: PUSH
102667: LD_VAR 0 1
102671: PUSH
102672: LD_VAR 0 2
102676: UNION
102677: ST_TO_ADDR
// end ;
102678: LD_VAR 0 3
102682: RET
// export function GetBehemoths ( side ) ; begin
102683: LD_INT 0
102685: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102686: LD_ADDR_VAR 0 2
102690: PUSH
102691: LD_INT 22
102693: PUSH
102694: LD_VAR 0 1
102698: PUSH
102699: EMPTY
102700: LIST
102701: LIST
102702: PUSH
102703: LD_INT 31
102705: PUSH
102706: LD_INT 25
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PPUSH
102717: CALL_OW 69
102721: ST_TO_ADDR
// end ;
102722: LD_VAR 0 2
102726: RET
// export function Shuffle ( array ) ; var i , index ; begin
102727: LD_INT 0
102729: PPUSH
102730: PPUSH
102731: PPUSH
// result := [ ] ;
102732: LD_ADDR_VAR 0 2
102736: PUSH
102737: EMPTY
102738: ST_TO_ADDR
// if not array then
102739: LD_VAR 0 1
102743: NOT
102744: IFFALSE 102748
// exit ;
102746: GO 102847
// Randomize ;
102748: CALL_OW 10
// for i = array downto 1 do
102752: LD_ADDR_VAR 0 3
102756: PUSH
102757: DOUBLE
102758: LD_VAR 0 1
102762: INC
102763: ST_TO_ADDR
102764: LD_INT 1
102766: PUSH
102767: FOR_DOWNTO
102768: IFFALSE 102845
// begin index := rand ( 1 , array ) ;
102770: LD_ADDR_VAR 0 4
102774: PUSH
102775: LD_INT 1
102777: PPUSH
102778: LD_VAR 0 1
102782: PPUSH
102783: CALL_OW 12
102787: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102788: LD_ADDR_VAR 0 2
102792: PUSH
102793: LD_VAR 0 2
102797: PPUSH
102798: LD_VAR 0 2
102802: PUSH
102803: LD_INT 1
102805: PLUS
102806: PPUSH
102807: LD_VAR 0 1
102811: PUSH
102812: LD_VAR 0 4
102816: ARRAY
102817: PPUSH
102818: CALL_OW 2
102822: ST_TO_ADDR
// array := Delete ( array , index ) ;
102823: LD_ADDR_VAR 0 1
102827: PUSH
102828: LD_VAR 0 1
102832: PPUSH
102833: LD_VAR 0 4
102837: PPUSH
102838: CALL_OW 3
102842: ST_TO_ADDR
// end ;
102843: GO 102767
102845: POP
102846: POP
// end ;
102847: LD_VAR 0 2
102851: RET
// export function GetBaseMaterials ( base ) ; begin
102852: LD_INT 0
102854: PPUSH
// result := [ 0 , 0 , 0 ] ;
102855: LD_ADDR_VAR 0 2
102859: PUSH
102860: LD_INT 0
102862: PUSH
102863: LD_INT 0
102865: PUSH
102866: LD_INT 0
102868: PUSH
102869: EMPTY
102870: LIST
102871: LIST
102872: LIST
102873: ST_TO_ADDR
// if not base then
102874: LD_VAR 0 1
102878: NOT
102879: IFFALSE 102883
// exit ;
102881: GO 102932
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102883: LD_ADDR_VAR 0 2
102887: PUSH
102888: LD_VAR 0 1
102892: PPUSH
102893: LD_INT 1
102895: PPUSH
102896: CALL_OW 275
102900: PUSH
102901: LD_VAR 0 1
102905: PPUSH
102906: LD_INT 2
102908: PPUSH
102909: CALL_OW 275
102913: PUSH
102914: LD_VAR 0 1
102918: PPUSH
102919: LD_INT 3
102921: PPUSH
102922: CALL_OW 275
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: LIST
102931: ST_TO_ADDR
// end ;
102932: LD_VAR 0 2
102936: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102937: LD_INT 0
102939: PPUSH
102940: PPUSH
// result := array ;
102941: LD_ADDR_VAR 0 3
102945: PUSH
102946: LD_VAR 0 1
102950: ST_TO_ADDR
// if size > 0 then
102951: LD_VAR 0 2
102955: PUSH
102956: LD_INT 0
102958: GREATER
102959: IFFALSE 103005
// for i := array downto size do
102961: LD_ADDR_VAR 0 4
102965: PUSH
102966: DOUBLE
102967: LD_VAR 0 1
102971: INC
102972: ST_TO_ADDR
102973: LD_VAR 0 2
102977: PUSH
102978: FOR_DOWNTO
102979: IFFALSE 103003
// result := Delete ( result , result ) ;
102981: LD_ADDR_VAR 0 3
102985: PUSH
102986: LD_VAR 0 3
102990: PPUSH
102991: LD_VAR 0 3
102995: PPUSH
102996: CALL_OW 3
103000: ST_TO_ADDR
103001: GO 102978
103003: POP
103004: POP
// end ;
103005: LD_VAR 0 3
103009: RET
// export function ComExit ( unit ) ; var tmp ; begin
103010: LD_INT 0
103012: PPUSH
103013: PPUSH
// if not IsInUnit ( unit ) then
103014: LD_VAR 0 1
103018: PPUSH
103019: CALL_OW 310
103023: NOT
103024: IFFALSE 103028
// exit ;
103026: GO 103088
// tmp := IsInUnit ( unit ) ;
103028: LD_ADDR_VAR 0 3
103032: PUSH
103033: LD_VAR 0 1
103037: PPUSH
103038: CALL_OW 310
103042: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103043: LD_VAR 0 3
103047: PPUSH
103048: CALL_OW 247
103052: PUSH
103053: LD_INT 2
103055: EQUAL
103056: IFFALSE 103069
// ComExitVehicle ( unit ) else
103058: LD_VAR 0 1
103062: PPUSH
103063: CALL_OW 121
103067: GO 103078
// ComExitBuilding ( unit ) ;
103069: LD_VAR 0 1
103073: PPUSH
103074: CALL_OW 122
// result := tmp ;
103078: LD_ADDR_VAR 0 2
103082: PUSH
103083: LD_VAR 0 3
103087: ST_TO_ADDR
// end ;
103088: LD_VAR 0 2
103092: RET
// export function ComExitAll ( units ) ; var i ; begin
103093: LD_INT 0
103095: PPUSH
103096: PPUSH
// if not units then
103097: LD_VAR 0 1
103101: NOT
103102: IFFALSE 103106
// exit ;
103104: GO 103132
// for i in units do
103106: LD_ADDR_VAR 0 3
103110: PUSH
103111: LD_VAR 0 1
103115: PUSH
103116: FOR_IN
103117: IFFALSE 103130
// ComExit ( i ) ;
103119: LD_VAR 0 3
103123: PPUSH
103124: CALL 103010 0 1
103128: GO 103116
103130: POP
103131: POP
// end ;
103132: LD_VAR 0 2
103136: RET
// export function ResetHc ; begin
103137: LD_INT 0
103139: PPUSH
// InitHc ;
103140: CALL_OW 19
// hc_importance := 0 ;
103144: LD_ADDR_OWVAR 32
103148: PUSH
103149: LD_INT 0
103151: ST_TO_ADDR
// end ;
103152: LD_VAR 0 1
103156: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103157: LD_INT 0
103159: PPUSH
103160: PPUSH
103161: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103162: LD_ADDR_VAR 0 6
103166: PUSH
103167: LD_VAR 0 1
103171: PUSH
103172: LD_VAR 0 3
103176: PLUS
103177: PUSH
103178: LD_INT 2
103180: DIV
103181: ST_TO_ADDR
// if _x < 0 then
103182: LD_VAR 0 6
103186: PUSH
103187: LD_INT 0
103189: LESS
103190: IFFALSE 103207
// _x := _x * - 1 ;
103192: LD_ADDR_VAR 0 6
103196: PUSH
103197: LD_VAR 0 6
103201: PUSH
103202: LD_INT 1
103204: NEG
103205: MUL
103206: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103207: LD_ADDR_VAR 0 7
103211: PUSH
103212: LD_VAR 0 2
103216: PUSH
103217: LD_VAR 0 4
103221: PLUS
103222: PUSH
103223: LD_INT 2
103225: DIV
103226: ST_TO_ADDR
// if _y < 0 then
103227: LD_VAR 0 7
103231: PUSH
103232: LD_INT 0
103234: LESS
103235: IFFALSE 103252
// _y := _y * - 1 ;
103237: LD_ADDR_VAR 0 7
103241: PUSH
103242: LD_VAR 0 7
103246: PUSH
103247: LD_INT 1
103249: NEG
103250: MUL
103251: ST_TO_ADDR
// result := [ _x , _y ] ;
103252: LD_ADDR_VAR 0 5
103256: PUSH
103257: LD_VAR 0 6
103261: PUSH
103262: LD_VAR 0 7
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: ST_TO_ADDR
// end ;
103271: LD_VAR 0 5
103275: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103276: LD_INT 0
103278: PPUSH
103279: PPUSH
103280: PPUSH
103281: PPUSH
// task := GetTaskList ( unit ) ;
103282: LD_ADDR_VAR 0 7
103286: PUSH
103287: LD_VAR 0 1
103291: PPUSH
103292: CALL_OW 437
103296: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103297: LD_VAR 0 7
103301: NOT
103302: PUSH
103303: LD_VAR 0 1
103307: PPUSH
103308: LD_VAR 0 2
103312: PPUSH
103313: CALL_OW 308
103317: NOT
103318: AND
103319: IFFALSE 103323
// exit ;
103321: GO 103441
// if IsInArea ( unit , area ) then
103323: LD_VAR 0 1
103327: PPUSH
103328: LD_VAR 0 2
103332: PPUSH
103333: CALL_OW 308
103337: IFFALSE 103355
// begin ComMoveToArea ( unit , goAway ) ;
103339: LD_VAR 0 1
103343: PPUSH
103344: LD_VAR 0 3
103348: PPUSH
103349: CALL_OW 113
// exit ;
103353: GO 103441
// end ; if task [ 1 ] [ 1 ] <> M then
103355: LD_VAR 0 7
103359: PUSH
103360: LD_INT 1
103362: ARRAY
103363: PUSH
103364: LD_INT 1
103366: ARRAY
103367: PUSH
103368: LD_STRING M
103370: NONEQUAL
103371: IFFALSE 103375
// exit ;
103373: GO 103441
// x := task [ 1 ] [ 2 ] ;
103375: LD_ADDR_VAR 0 5
103379: PUSH
103380: LD_VAR 0 7
103384: PUSH
103385: LD_INT 1
103387: ARRAY
103388: PUSH
103389: LD_INT 2
103391: ARRAY
103392: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103393: LD_ADDR_VAR 0 6
103397: PUSH
103398: LD_VAR 0 7
103402: PUSH
103403: LD_INT 1
103405: ARRAY
103406: PUSH
103407: LD_INT 3
103409: ARRAY
103410: ST_TO_ADDR
// if InArea ( x , y , area ) then
103411: LD_VAR 0 5
103415: PPUSH
103416: LD_VAR 0 6
103420: PPUSH
103421: LD_VAR 0 2
103425: PPUSH
103426: CALL_OW 309
103430: IFFALSE 103441
// ComStop ( unit ) ;
103432: LD_VAR 0 1
103436: PPUSH
103437: CALL_OW 141
// end ;
103441: LD_VAR 0 4
103445: RET
// export function Abs ( value ) ; begin
103446: LD_INT 0
103448: PPUSH
// result := value ;
103449: LD_ADDR_VAR 0 2
103453: PUSH
103454: LD_VAR 0 1
103458: ST_TO_ADDR
// if value < 0 then
103459: LD_VAR 0 1
103463: PUSH
103464: LD_INT 0
103466: LESS
103467: IFFALSE 103484
// result := value * - 1 ;
103469: LD_ADDR_VAR 0 2
103473: PUSH
103474: LD_VAR 0 1
103478: PUSH
103479: LD_INT 1
103481: NEG
103482: MUL
103483: ST_TO_ADDR
// end ;
103484: LD_VAR 0 2
103488: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103489: LD_INT 0
103491: PPUSH
103492: PPUSH
103493: PPUSH
103494: PPUSH
103495: PPUSH
103496: PPUSH
103497: PPUSH
103498: PPUSH
// if not unit or not building then
103499: LD_VAR 0 1
103503: NOT
103504: PUSH
103505: LD_VAR 0 2
103509: NOT
103510: OR
103511: IFFALSE 103515
// exit ;
103513: GO 103741
// x := GetX ( building ) ;
103515: LD_ADDR_VAR 0 4
103519: PUSH
103520: LD_VAR 0 2
103524: PPUSH
103525: CALL_OW 250
103529: ST_TO_ADDR
// y := GetY ( building ) ;
103530: LD_ADDR_VAR 0 6
103534: PUSH
103535: LD_VAR 0 2
103539: PPUSH
103540: CALL_OW 251
103544: ST_TO_ADDR
// d := GetDir ( building ) ;
103545: LD_ADDR_VAR 0 8
103549: PUSH
103550: LD_VAR 0 2
103554: PPUSH
103555: CALL_OW 254
103559: ST_TO_ADDR
// r := 4 ;
103560: LD_ADDR_VAR 0 9
103564: PUSH
103565: LD_INT 4
103567: ST_TO_ADDR
// for i := 1 to 5 do
103568: LD_ADDR_VAR 0 10
103572: PUSH
103573: DOUBLE
103574: LD_INT 1
103576: DEC
103577: ST_TO_ADDR
103578: LD_INT 5
103580: PUSH
103581: FOR_TO
103582: IFFALSE 103739
// begin _x := ShiftX ( x , d , r + i ) ;
103584: LD_ADDR_VAR 0 5
103588: PUSH
103589: LD_VAR 0 4
103593: PPUSH
103594: LD_VAR 0 8
103598: PPUSH
103599: LD_VAR 0 9
103603: PUSH
103604: LD_VAR 0 10
103608: PLUS
103609: PPUSH
103610: CALL_OW 272
103614: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103615: LD_ADDR_VAR 0 7
103619: PUSH
103620: LD_VAR 0 6
103624: PPUSH
103625: LD_VAR 0 8
103629: PPUSH
103630: LD_VAR 0 9
103634: PUSH
103635: LD_VAR 0 10
103639: PLUS
103640: PPUSH
103641: CALL_OW 273
103645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103646: LD_VAR 0 5
103650: PPUSH
103651: LD_VAR 0 7
103655: PPUSH
103656: CALL_OW 488
103660: PUSH
103661: LD_VAR 0 5
103665: PPUSH
103666: LD_VAR 0 7
103670: PPUSH
103671: CALL_OW 428
103675: PPUSH
103676: CALL_OW 247
103680: PUSH
103681: LD_INT 3
103683: PUSH
103684: LD_INT 2
103686: PUSH
103687: EMPTY
103688: LIST
103689: LIST
103690: IN
103691: NOT
103692: AND
103693: IFFALSE 103737
// begin ComMoveXY ( unit , _x , _y ) ;
103695: LD_VAR 0 1
103699: PPUSH
103700: LD_VAR 0 5
103704: PPUSH
103705: LD_VAR 0 7
103709: PPUSH
103710: CALL_OW 111
// result := [ _x , _y ] ;
103714: LD_ADDR_VAR 0 3
103718: PUSH
103719: LD_VAR 0 5
103723: PUSH
103724: LD_VAR 0 7
103728: PUSH
103729: EMPTY
103730: LIST
103731: LIST
103732: ST_TO_ADDR
// exit ;
103733: POP
103734: POP
103735: GO 103741
// end ; end ;
103737: GO 103581
103739: POP
103740: POP
// end ;
103741: LD_VAR 0 3
103745: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103746: LD_INT 0
103748: PPUSH
103749: PPUSH
103750: PPUSH
// result := 0 ;
103751: LD_ADDR_VAR 0 3
103755: PUSH
103756: LD_INT 0
103758: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103759: LD_VAR 0 1
103763: PUSH
103764: LD_INT 0
103766: LESS
103767: PUSH
103768: LD_VAR 0 1
103772: PUSH
103773: LD_INT 8
103775: GREATER
103776: OR
103777: PUSH
103778: LD_VAR 0 2
103782: PUSH
103783: LD_INT 0
103785: LESS
103786: OR
103787: PUSH
103788: LD_VAR 0 2
103792: PUSH
103793: LD_INT 8
103795: GREATER
103796: OR
103797: IFFALSE 103801
// exit ;
103799: GO 103876
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103801: LD_ADDR_VAR 0 4
103805: PUSH
103806: LD_INT 22
103808: PUSH
103809: LD_VAR 0 2
103813: PUSH
103814: EMPTY
103815: LIST
103816: LIST
103817: PPUSH
103818: CALL_OW 69
103822: PUSH
103823: FOR_IN
103824: IFFALSE 103874
// begin un := UnitShoot ( i ) ;
103826: LD_ADDR_VAR 0 5
103830: PUSH
103831: LD_VAR 0 4
103835: PPUSH
103836: CALL_OW 504
103840: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103841: LD_VAR 0 5
103845: PPUSH
103846: CALL_OW 255
103850: PUSH
103851: LD_VAR 0 1
103855: EQUAL
103856: IFFALSE 103872
// begin result := un ;
103858: LD_ADDR_VAR 0 3
103862: PUSH
103863: LD_VAR 0 5
103867: ST_TO_ADDR
// exit ;
103868: POP
103869: POP
103870: GO 103876
// end ; end ;
103872: GO 103823
103874: POP
103875: POP
// end ;
103876: LD_VAR 0 3
103880: RET
// export function GetCargoBay ( units ) ; begin
103881: LD_INT 0
103883: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103884: LD_ADDR_VAR 0 2
103888: PUSH
103889: LD_VAR 0 1
103893: PPUSH
103894: LD_INT 2
103896: PUSH
103897: LD_INT 34
103899: PUSH
103900: LD_INT 12
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PUSH
103907: LD_INT 34
103909: PUSH
103910: LD_INT 51
103912: PUSH
103913: EMPTY
103914: LIST
103915: LIST
103916: PUSH
103917: LD_INT 34
103919: PUSH
103920: LD_INT 32
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 34
103929: PUSH
103930: LD_EXP 96
103934: PUSH
103935: EMPTY
103936: LIST
103937: LIST
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: LIST
103943: LIST
103944: LIST
103945: PPUSH
103946: CALL_OW 72
103950: ST_TO_ADDR
// end ;
103951: LD_VAR 0 2
103955: RET
// export function Negate ( value ) ; begin
103956: LD_INT 0
103958: PPUSH
// result := not value ;
103959: LD_ADDR_VAR 0 2
103963: PUSH
103964: LD_VAR 0 1
103968: NOT
103969: ST_TO_ADDR
// end ;
103970: LD_VAR 0 2
103974: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103975: LD_INT 0
103977: PPUSH
// if x1 = x2 then
103978: LD_VAR 0 1
103982: PUSH
103983: LD_VAR 0 3
103987: EQUAL
103988: IFFALSE 104022
// begin if y1 > y2 then
103990: LD_VAR 0 2
103994: PUSH
103995: LD_VAR 0 4
103999: GREATER
104000: IFFALSE 104012
// result := 0 else
104002: LD_ADDR_VAR 0 5
104006: PUSH
104007: LD_INT 0
104009: ST_TO_ADDR
104010: GO 104020
// result := 3 ;
104012: LD_ADDR_VAR 0 5
104016: PUSH
104017: LD_INT 3
104019: ST_TO_ADDR
// exit ;
104020: GO 104108
// end ; if y1 = y2 then
104022: LD_VAR 0 2
104026: PUSH
104027: LD_VAR 0 4
104031: EQUAL
104032: IFFALSE 104066
// begin if x1 > x2 then
104034: LD_VAR 0 1
104038: PUSH
104039: LD_VAR 0 3
104043: GREATER
104044: IFFALSE 104056
// result := 1 else
104046: LD_ADDR_VAR 0 5
104050: PUSH
104051: LD_INT 1
104053: ST_TO_ADDR
104054: GO 104064
// result := 4 ;
104056: LD_ADDR_VAR 0 5
104060: PUSH
104061: LD_INT 4
104063: ST_TO_ADDR
// exit ;
104064: GO 104108
// end ; if x1 > x2 and y1 > y2 then
104066: LD_VAR 0 1
104070: PUSH
104071: LD_VAR 0 3
104075: GREATER
104076: PUSH
104077: LD_VAR 0 2
104081: PUSH
104082: LD_VAR 0 4
104086: GREATER
104087: AND
104088: IFFALSE 104100
// result := 2 else
104090: LD_ADDR_VAR 0 5
104094: PUSH
104095: LD_INT 2
104097: ST_TO_ADDR
104098: GO 104108
// result := 5 ;
104100: LD_ADDR_VAR 0 5
104104: PUSH
104105: LD_INT 5
104107: ST_TO_ADDR
// end ;
104108: LD_VAR 0 5
104112: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104113: LD_INT 0
104115: PPUSH
104116: PPUSH
// if not driver or not IsInUnit ( driver ) then
104117: LD_VAR 0 1
104121: NOT
104122: PUSH
104123: LD_VAR 0 1
104127: PPUSH
104128: CALL_OW 310
104132: NOT
104133: OR
104134: IFFALSE 104138
// exit ;
104136: GO 104228
// vehicle := IsInUnit ( driver ) ;
104138: LD_ADDR_VAR 0 3
104142: PUSH
104143: LD_VAR 0 1
104147: PPUSH
104148: CALL_OW 310
104152: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104153: LD_VAR 0 1
104157: PPUSH
104158: LD_STRING \
104160: PUSH
104161: LD_INT 0
104163: PUSH
104164: LD_INT 0
104166: PUSH
104167: LD_INT 0
104169: PUSH
104170: LD_INT 0
104172: PUSH
104173: LD_INT 0
104175: PUSH
104176: LD_INT 0
104178: PUSH
104179: EMPTY
104180: LIST
104181: LIST
104182: LIST
104183: LIST
104184: LIST
104185: LIST
104186: LIST
104187: PUSH
104188: LD_STRING E
104190: PUSH
104191: LD_INT 0
104193: PUSH
104194: LD_INT 0
104196: PUSH
104197: LD_VAR 0 3
104201: PUSH
104202: LD_INT 0
104204: PUSH
104205: LD_INT 0
104207: PUSH
104208: LD_INT 0
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: LIST
104215: LIST
104216: LIST
104217: LIST
104218: LIST
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: PPUSH
104224: CALL_OW 446
// end ;
104228: LD_VAR 0 2
104232: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104233: LD_INT 0
104235: PPUSH
104236: PPUSH
// if not driver or not IsInUnit ( driver ) then
104237: LD_VAR 0 1
104241: NOT
104242: PUSH
104243: LD_VAR 0 1
104247: PPUSH
104248: CALL_OW 310
104252: NOT
104253: OR
104254: IFFALSE 104258
// exit ;
104256: GO 104348
// vehicle := IsInUnit ( driver ) ;
104258: LD_ADDR_VAR 0 3
104262: PUSH
104263: LD_VAR 0 1
104267: PPUSH
104268: CALL_OW 310
104272: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104273: LD_VAR 0 1
104277: PPUSH
104278: LD_STRING \
104280: PUSH
104281: LD_INT 0
104283: PUSH
104284: LD_INT 0
104286: PUSH
104287: LD_INT 0
104289: PUSH
104290: LD_INT 0
104292: PUSH
104293: LD_INT 0
104295: PUSH
104296: LD_INT 0
104298: PUSH
104299: EMPTY
104300: LIST
104301: LIST
104302: LIST
104303: LIST
104304: LIST
104305: LIST
104306: LIST
104307: PUSH
104308: LD_STRING E
104310: PUSH
104311: LD_INT 0
104313: PUSH
104314: LD_INT 0
104316: PUSH
104317: LD_VAR 0 3
104321: PUSH
104322: LD_INT 0
104324: PUSH
104325: LD_INT 0
104327: PUSH
104328: LD_INT 0
104330: PUSH
104331: EMPTY
104332: LIST
104333: LIST
104334: LIST
104335: LIST
104336: LIST
104337: LIST
104338: LIST
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PPUSH
104344: CALL_OW 447
// end ;
104348: LD_VAR 0 2
104352: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104353: LD_INT 0
104355: PPUSH
104356: PPUSH
104357: PPUSH
// tmp := [ ] ;
104358: LD_ADDR_VAR 0 5
104362: PUSH
104363: EMPTY
104364: ST_TO_ADDR
// for i in units do
104365: LD_ADDR_VAR 0 4
104369: PUSH
104370: LD_VAR 0 1
104374: PUSH
104375: FOR_IN
104376: IFFALSE 104414
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104378: LD_ADDR_VAR 0 5
104382: PUSH
104383: LD_VAR 0 5
104387: PPUSH
104388: LD_VAR 0 5
104392: PUSH
104393: LD_INT 1
104395: PLUS
104396: PPUSH
104397: LD_VAR 0 4
104401: PPUSH
104402: CALL_OW 256
104406: PPUSH
104407: CALL_OW 2
104411: ST_TO_ADDR
104412: GO 104375
104414: POP
104415: POP
// if not tmp then
104416: LD_VAR 0 5
104420: NOT
104421: IFFALSE 104425
// exit ;
104423: GO 104473
// if asc then
104425: LD_VAR 0 2
104429: IFFALSE 104453
// result := SortListByListAsc ( units , tmp ) else
104431: LD_ADDR_VAR 0 3
104435: PUSH
104436: LD_VAR 0 1
104440: PPUSH
104441: LD_VAR 0 5
104445: PPUSH
104446: CALL_OW 76
104450: ST_TO_ADDR
104451: GO 104473
// result := SortListByListDesc ( units , tmp ) ;
104453: LD_ADDR_VAR 0 3
104457: PUSH
104458: LD_VAR 0 1
104462: PPUSH
104463: LD_VAR 0 5
104467: PPUSH
104468: CALL_OW 77
104472: ST_TO_ADDR
// end ;
104473: LD_VAR 0 3
104477: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104478: LD_INT 0
104480: PPUSH
104481: PPUSH
// task := GetTaskList ( mech ) ;
104482: LD_ADDR_VAR 0 4
104486: PUSH
104487: LD_VAR 0 1
104491: PPUSH
104492: CALL_OW 437
104496: ST_TO_ADDR
// if not task then
104497: LD_VAR 0 4
104501: NOT
104502: IFFALSE 104506
// exit ;
104504: GO 104548
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104506: LD_ADDR_VAR 0 3
104510: PUSH
104511: LD_VAR 0 4
104515: PUSH
104516: LD_INT 1
104518: ARRAY
104519: PUSH
104520: LD_INT 1
104522: ARRAY
104523: PUSH
104524: LD_STRING r
104526: EQUAL
104527: PUSH
104528: LD_VAR 0 4
104532: PUSH
104533: LD_INT 1
104535: ARRAY
104536: PUSH
104537: LD_INT 4
104539: ARRAY
104540: PUSH
104541: LD_VAR 0 2
104545: EQUAL
104546: AND
104547: ST_TO_ADDR
// end ;
104548: LD_VAR 0 3
104552: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104553: LD_INT 0
104555: PPUSH
// SetDir ( unit , d ) ;
104556: LD_VAR 0 1
104560: PPUSH
104561: LD_VAR 0 4
104565: PPUSH
104566: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104570: LD_VAR 0 1
104574: PPUSH
104575: LD_VAR 0 2
104579: PPUSH
104580: LD_VAR 0 3
104584: PPUSH
104585: LD_VAR 0 5
104589: PPUSH
104590: CALL_OW 48
// end ;
104594: LD_VAR 0 6
104598: RET
// export function ToNaturalNumber ( number ) ; begin
104599: LD_INT 0
104601: PPUSH
// result := number div 1 ;
104602: LD_ADDR_VAR 0 2
104606: PUSH
104607: LD_VAR 0 1
104611: PUSH
104612: LD_INT 1
104614: DIV
104615: ST_TO_ADDR
// if number < 0 then
104616: LD_VAR 0 1
104620: PUSH
104621: LD_INT 0
104623: LESS
104624: IFFALSE 104634
// result := 0 ;
104626: LD_ADDR_VAR 0 2
104630: PUSH
104631: LD_INT 0
104633: ST_TO_ADDR
// end ;
104634: LD_VAR 0 2
104638: RET
// export function SortByClass ( units , class ) ; var un ; begin
104639: LD_INT 0
104641: PPUSH
104642: PPUSH
// if not units or not class then
104643: LD_VAR 0 1
104647: NOT
104648: PUSH
104649: LD_VAR 0 2
104653: NOT
104654: OR
104655: IFFALSE 104659
// exit ;
104657: GO 104754
// result := [ ] ;
104659: LD_ADDR_VAR 0 3
104663: PUSH
104664: EMPTY
104665: ST_TO_ADDR
// for un in units do
104666: LD_ADDR_VAR 0 4
104670: PUSH
104671: LD_VAR 0 1
104675: PUSH
104676: FOR_IN
104677: IFFALSE 104752
// if GetClass ( un ) = class then
104679: LD_VAR 0 4
104683: PPUSH
104684: CALL_OW 257
104688: PUSH
104689: LD_VAR 0 2
104693: EQUAL
104694: IFFALSE 104721
// result := Insert ( result , 1 , un ) else
104696: LD_ADDR_VAR 0 3
104700: PUSH
104701: LD_VAR 0 3
104705: PPUSH
104706: LD_INT 1
104708: PPUSH
104709: LD_VAR 0 4
104713: PPUSH
104714: CALL_OW 2
104718: ST_TO_ADDR
104719: GO 104750
// result := Replace ( result , result + 1 , un ) ;
104721: LD_ADDR_VAR 0 3
104725: PUSH
104726: LD_VAR 0 3
104730: PPUSH
104731: LD_VAR 0 3
104735: PUSH
104736: LD_INT 1
104738: PLUS
104739: PPUSH
104740: LD_VAR 0 4
104744: PPUSH
104745: CALL_OW 1
104749: ST_TO_ADDR
104750: GO 104676
104752: POP
104753: POP
// end ;
104754: LD_VAR 0 3
104758: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104759: LD_INT 0
104761: PPUSH
104762: PPUSH
104763: PPUSH
104764: PPUSH
104765: PPUSH
104766: PPUSH
104767: PPUSH
// result := [ ] ;
104768: LD_ADDR_VAR 0 4
104772: PUSH
104773: EMPTY
104774: ST_TO_ADDR
// if x - r < 0 then
104775: LD_VAR 0 1
104779: PUSH
104780: LD_VAR 0 3
104784: MINUS
104785: PUSH
104786: LD_INT 0
104788: LESS
104789: IFFALSE 104801
// min_x := 0 else
104791: LD_ADDR_VAR 0 8
104795: PUSH
104796: LD_INT 0
104798: ST_TO_ADDR
104799: GO 104817
// min_x := x - r ;
104801: LD_ADDR_VAR 0 8
104805: PUSH
104806: LD_VAR 0 1
104810: PUSH
104811: LD_VAR 0 3
104815: MINUS
104816: ST_TO_ADDR
// if y - r < 0 then
104817: LD_VAR 0 2
104821: PUSH
104822: LD_VAR 0 3
104826: MINUS
104827: PUSH
104828: LD_INT 0
104830: LESS
104831: IFFALSE 104843
// min_y := 0 else
104833: LD_ADDR_VAR 0 7
104837: PUSH
104838: LD_INT 0
104840: ST_TO_ADDR
104841: GO 104859
// min_y := y - r ;
104843: LD_ADDR_VAR 0 7
104847: PUSH
104848: LD_VAR 0 2
104852: PUSH
104853: LD_VAR 0 3
104857: MINUS
104858: ST_TO_ADDR
// max_x := x + r ;
104859: LD_ADDR_VAR 0 9
104863: PUSH
104864: LD_VAR 0 1
104868: PUSH
104869: LD_VAR 0 3
104873: PLUS
104874: ST_TO_ADDR
// max_y := y + r ;
104875: LD_ADDR_VAR 0 10
104879: PUSH
104880: LD_VAR 0 2
104884: PUSH
104885: LD_VAR 0 3
104889: PLUS
104890: ST_TO_ADDR
// for _x = min_x to max_x do
104891: LD_ADDR_VAR 0 5
104895: PUSH
104896: DOUBLE
104897: LD_VAR 0 8
104901: DEC
104902: ST_TO_ADDR
104903: LD_VAR 0 9
104907: PUSH
104908: FOR_TO
104909: IFFALSE 105010
// for _y = min_y to max_y do
104911: LD_ADDR_VAR 0 6
104915: PUSH
104916: DOUBLE
104917: LD_VAR 0 7
104921: DEC
104922: ST_TO_ADDR
104923: LD_VAR 0 10
104927: PUSH
104928: FOR_TO
104929: IFFALSE 105006
// begin if not ValidHex ( _x , _y ) then
104931: LD_VAR 0 5
104935: PPUSH
104936: LD_VAR 0 6
104940: PPUSH
104941: CALL_OW 488
104945: NOT
104946: IFFALSE 104950
// continue ;
104948: GO 104928
// if GetResourceTypeXY ( _x , _y ) then
104950: LD_VAR 0 5
104954: PPUSH
104955: LD_VAR 0 6
104959: PPUSH
104960: CALL_OW 283
104964: IFFALSE 105004
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
104966: LD_ADDR_VAR 0 4
104970: PUSH
104971: LD_VAR 0 4
104975: PPUSH
104976: LD_VAR 0 4
104980: PUSH
104981: LD_INT 1
104983: PLUS
104984: PPUSH
104985: LD_VAR 0 5
104989: PUSH
104990: LD_VAR 0 6
104994: PUSH
104995: EMPTY
104996: LIST
104997: LIST
104998: PPUSH
104999: CALL_OW 1
105003: ST_TO_ADDR
// end ;
105004: GO 104928
105006: POP
105007: POP
105008: GO 104908
105010: POP
105011: POP
// end ;
105012: LD_VAR 0 4
105016: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
105017: LD_INT 0
105019: PPUSH
105020: PPUSH
105021: PPUSH
105022: PPUSH
105023: PPUSH
105024: PPUSH
// if not units then
105025: LD_VAR 0 1
105029: NOT
105030: IFFALSE 105034
// exit ;
105032: GO 105435
// result := UnitFilter ( units , [ f_ok ] ) ;
105034: LD_ADDR_VAR 0 3
105038: PUSH
105039: LD_VAR 0 1
105043: PPUSH
105044: LD_INT 50
105046: PUSH
105047: EMPTY
105048: LIST
105049: PPUSH
105050: CALL_OW 72
105054: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105055: LD_ADDR_VAR 0 7
105059: PUSH
105060: LD_VAR 0 1
105064: PUSH
105065: LD_INT 1
105067: ARRAY
105068: PPUSH
105069: CALL_OW 255
105073: ST_TO_ADDR
// if not result then
105074: LD_VAR 0 3
105078: NOT
105079: IFFALSE 105083
// exit ;
105081: GO 105435
// for i in result do
105083: LD_ADDR_VAR 0 4
105087: PUSH
105088: LD_VAR 0 3
105092: PUSH
105093: FOR_IN
105094: IFFALSE 105433
// begin tag := GetTag ( i ) + 1 ;
105096: LD_ADDR_VAR 0 8
105100: PUSH
105101: LD_VAR 0 4
105105: PPUSH
105106: CALL_OW 110
105110: PUSH
105111: LD_INT 1
105113: PLUS
105114: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
105115: LD_ADDR_VAR 0 6
105119: PUSH
105120: LD_VAR 0 4
105124: PPUSH
105125: CALL_OW 250
105129: PPUSH
105130: LD_VAR 0 4
105134: PPUSH
105135: CALL_OW 251
105139: PPUSH
105140: LD_INT 6
105142: PPUSH
105143: CALL 104759 0 3
105147: ST_TO_ADDR
// if cr then
105148: LD_VAR 0 6
105152: IFFALSE 105191
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
105154: LD_VAR 0 4
105158: PPUSH
105159: LD_VAR 0 6
105163: PUSH
105164: LD_INT 1
105166: ARRAY
105167: PUSH
105168: LD_INT 1
105170: ARRAY
105171: PPUSH
105172: LD_VAR 0 6
105176: PUSH
105177: LD_INT 1
105179: ARRAY
105180: PUSH
105181: LD_INT 2
105183: ARRAY
105184: PPUSH
105185: CALL_OW 116
105189: GO 105431
// if path > tag then
105191: LD_VAR 0 2
105195: PUSH
105196: LD_VAR 0 8
105200: GREATER
105201: IFFALSE 105379
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
105203: LD_ADDR_VAR 0 5
105207: PUSH
105208: LD_INT 81
105210: PUSH
105211: LD_VAR 0 7
105215: PUSH
105216: EMPTY
105217: LIST
105218: LIST
105219: PUSH
105220: LD_INT 91
105222: PUSH
105223: LD_VAR 0 4
105227: PUSH
105228: LD_INT 12
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: LIST
105235: PUSH
105236: EMPTY
105237: LIST
105238: LIST
105239: PPUSH
105240: CALL_OW 69
105244: ST_TO_ADDR
// if enemy then
105245: LD_VAR 0 5
105249: IFFALSE 105277
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105251: LD_VAR 0 4
105255: PPUSH
105256: LD_VAR 0 5
105260: PPUSH
105261: LD_VAR 0 4
105265: PPUSH
105266: CALL_OW 74
105270: PPUSH
105271: CALL_OW 115
105275: GO 105377
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
105277: LD_VAR 0 4
105281: PPUSH
105282: LD_VAR 0 2
105286: PUSH
105287: LD_VAR 0 8
105291: ARRAY
105292: PUSH
105293: LD_INT 1
105295: ARRAY
105296: PPUSH
105297: LD_VAR 0 2
105301: PUSH
105302: LD_VAR 0 8
105306: ARRAY
105307: PUSH
105308: LD_INT 2
105310: ARRAY
105311: PPUSH
105312: CALL_OW 297
105316: PUSH
105317: LD_INT 6
105319: GREATER
105320: IFFALSE 105363
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
105322: LD_VAR 0 4
105326: PPUSH
105327: LD_VAR 0 2
105331: PUSH
105332: LD_VAR 0 8
105336: ARRAY
105337: PUSH
105338: LD_INT 1
105340: ARRAY
105341: PPUSH
105342: LD_VAR 0 2
105346: PUSH
105347: LD_VAR 0 8
105351: ARRAY
105352: PUSH
105353: LD_INT 2
105355: ARRAY
105356: PPUSH
105357: CALL_OW 114
105361: GO 105377
// SetTag ( i , tag ) ;
105363: LD_VAR 0 4
105367: PPUSH
105368: LD_VAR 0 8
105372: PPUSH
105373: CALL_OW 109
// end else
105377: GO 105431
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105379: LD_ADDR_VAR 0 5
105383: PUSH
105384: LD_INT 81
105386: PUSH
105387: LD_VAR 0 7
105391: PUSH
105392: EMPTY
105393: LIST
105394: LIST
105395: PPUSH
105396: CALL_OW 69
105400: ST_TO_ADDR
// if enemy then
105401: LD_VAR 0 5
105405: IFFALSE 105431
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
105407: LD_VAR 0 4
105411: PPUSH
105412: LD_VAR 0 5
105416: PPUSH
105417: LD_VAR 0 4
105421: PPUSH
105422: CALL_OW 74
105426: PPUSH
105427: CALL_OW 115
// end ; end ;
105431: GO 105093
105433: POP
105434: POP
// end ; end_of_file end_of_file
105435: LD_VAR 0 3
105439: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105440: LD_INT 0
105442: PPUSH
// if p2 = 100 then
105443: LD_VAR 0 2
105447: PUSH
105448: LD_INT 100
105450: EQUAL
105451: IFFALSE 106454
// begin if not StreamModeActive then
105453: LD_EXP 160
105457: NOT
105458: IFFALSE 105468
// StreamModeActive := true ;
105460: LD_ADDR_EXP 160
105464: PUSH
105465: LD_INT 1
105467: ST_TO_ADDR
// if p3 = 0 then
105468: LD_VAR 0 3
105472: PUSH
105473: LD_INT 0
105475: EQUAL
105476: IFFALSE 105482
// InitStreamMode ;
105478: CALL 106614 0 0
// if p3 = 1 then
105482: LD_VAR 0 3
105486: PUSH
105487: LD_INT 1
105489: EQUAL
105490: IFFALSE 105500
// sRocket := true ;
105492: LD_ADDR_EXP 165
105496: PUSH
105497: LD_INT 1
105499: ST_TO_ADDR
// if p3 = 2 then
105500: LD_VAR 0 3
105504: PUSH
105505: LD_INT 2
105507: EQUAL
105508: IFFALSE 105518
// sSpeed := true ;
105510: LD_ADDR_EXP 164
105514: PUSH
105515: LD_INT 1
105517: ST_TO_ADDR
// if p3 = 3 then
105518: LD_VAR 0 3
105522: PUSH
105523: LD_INT 3
105525: EQUAL
105526: IFFALSE 105536
// sEngine := true ;
105528: LD_ADDR_EXP 166
105532: PUSH
105533: LD_INT 1
105535: ST_TO_ADDR
// if p3 = 4 then
105536: LD_VAR 0 3
105540: PUSH
105541: LD_INT 4
105543: EQUAL
105544: IFFALSE 105554
// sSpec := true ;
105546: LD_ADDR_EXP 163
105550: PUSH
105551: LD_INT 1
105553: ST_TO_ADDR
// if p3 = 5 then
105554: LD_VAR 0 3
105558: PUSH
105559: LD_INT 5
105561: EQUAL
105562: IFFALSE 105572
// sLevel := true ;
105564: LD_ADDR_EXP 167
105568: PUSH
105569: LD_INT 1
105571: ST_TO_ADDR
// if p3 = 6 then
105572: LD_VAR 0 3
105576: PUSH
105577: LD_INT 6
105579: EQUAL
105580: IFFALSE 105590
// sArmoury := true ;
105582: LD_ADDR_EXP 168
105586: PUSH
105587: LD_INT 1
105589: ST_TO_ADDR
// if p3 = 7 then
105590: LD_VAR 0 3
105594: PUSH
105595: LD_INT 7
105597: EQUAL
105598: IFFALSE 105608
// sRadar := true ;
105600: LD_ADDR_EXP 169
105604: PUSH
105605: LD_INT 1
105607: ST_TO_ADDR
// if p3 = 8 then
105608: LD_VAR 0 3
105612: PUSH
105613: LD_INT 8
105615: EQUAL
105616: IFFALSE 105626
// sBunker := true ;
105618: LD_ADDR_EXP 170
105622: PUSH
105623: LD_INT 1
105625: ST_TO_ADDR
// if p3 = 9 then
105626: LD_VAR 0 3
105630: PUSH
105631: LD_INT 9
105633: EQUAL
105634: IFFALSE 105644
// sHack := true ;
105636: LD_ADDR_EXP 171
105640: PUSH
105641: LD_INT 1
105643: ST_TO_ADDR
// if p3 = 10 then
105644: LD_VAR 0 3
105648: PUSH
105649: LD_INT 10
105651: EQUAL
105652: IFFALSE 105662
// sFire := true ;
105654: LD_ADDR_EXP 172
105658: PUSH
105659: LD_INT 1
105661: ST_TO_ADDR
// if p3 = 11 then
105662: LD_VAR 0 3
105666: PUSH
105667: LD_INT 11
105669: EQUAL
105670: IFFALSE 105680
// sRefresh := true ;
105672: LD_ADDR_EXP 173
105676: PUSH
105677: LD_INT 1
105679: ST_TO_ADDR
// if p3 = 12 then
105680: LD_VAR 0 3
105684: PUSH
105685: LD_INT 12
105687: EQUAL
105688: IFFALSE 105698
// sExp := true ;
105690: LD_ADDR_EXP 174
105694: PUSH
105695: LD_INT 1
105697: ST_TO_ADDR
// if p3 = 13 then
105698: LD_VAR 0 3
105702: PUSH
105703: LD_INT 13
105705: EQUAL
105706: IFFALSE 105716
// sDepot := true ;
105708: LD_ADDR_EXP 175
105712: PUSH
105713: LD_INT 1
105715: ST_TO_ADDR
// if p3 = 14 then
105716: LD_VAR 0 3
105720: PUSH
105721: LD_INT 14
105723: EQUAL
105724: IFFALSE 105734
// sFlag := true ;
105726: LD_ADDR_EXP 176
105730: PUSH
105731: LD_INT 1
105733: ST_TO_ADDR
// if p3 = 15 then
105734: LD_VAR 0 3
105738: PUSH
105739: LD_INT 15
105741: EQUAL
105742: IFFALSE 105752
// sKamikadze := true ;
105744: LD_ADDR_EXP 184
105748: PUSH
105749: LD_INT 1
105751: ST_TO_ADDR
// if p3 = 16 then
105752: LD_VAR 0 3
105756: PUSH
105757: LD_INT 16
105759: EQUAL
105760: IFFALSE 105770
// sTroll := true ;
105762: LD_ADDR_EXP 185
105766: PUSH
105767: LD_INT 1
105769: ST_TO_ADDR
// if p3 = 17 then
105770: LD_VAR 0 3
105774: PUSH
105775: LD_INT 17
105777: EQUAL
105778: IFFALSE 105788
// sSlow := true ;
105780: LD_ADDR_EXP 186
105784: PUSH
105785: LD_INT 1
105787: ST_TO_ADDR
// if p3 = 18 then
105788: LD_VAR 0 3
105792: PUSH
105793: LD_INT 18
105795: EQUAL
105796: IFFALSE 105806
// sLack := true ;
105798: LD_ADDR_EXP 187
105802: PUSH
105803: LD_INT 1
105805: ST_TO_ADDR
// if p3 = 19 then
105806: LD_VAR 0 3
105810: PUSH
105811: LD_INT 19
105813: EQUAL
105814: IFFALSE 105824
// sTank := true ;
105816: LD_ADDR_EXP 189
105820: PUSH
105821: LD_INT 1
105823: ST_TO_ADDR
// if p3 = 20 then
105824: LD_VAR 0 3
105828: PUSH
105829: LD_INT 20
105831: EQUAL
105832: IFFALSE 105842
// sRemote := true ;
105834: LD_ADDR_EXP 190
105838: PUSH
105839: LD_INT 1
105841: ST_TO_ADDR
// if p3 = 21 then
105842: LD_VAR 0 3
105846: PUSH
105847: LD_INT 21
105849: EQUAL
105850: IFFALSE 105860
// sPowell := true ;
105852: LD_ADDR_EXP 191
105856: PUSH
105857: LD_INT 1
105859: ST_TO_ADDR
// if p3 = 22 then
105860: LD_VAR 0 3
105864: PUSH
105865: LD_INT 22
105867: EQUAL
105868: IFFALSE 105878
// sTeleport := true ;
105870: LD_ADDR_EXP 194
105874: PUSH
105875: LD_INT 1
105877: ST_TO_ADDR
// if p3 = 23 then
105878: LD_VAR 0 3
105882: PUSH
105883: LD_INT 23
105885: EQUAL
105886: IFFALSE 105896
// sOilTower := true ;
105888: LD_ADDR_EXP 196
105892: PUSH
105893: LD_INT 1
105895: ST_TO_ADDR
// if p3 = 24 then
105896: LD_VAR 0 3
105900: PUSH
105901: LD_INT 24
105903: EQUAL
105904: IFFALSE 105914
// sShovel := true ;
105906: LD_ADDR_EXP 197
105910: PUSH
105911: LD_INT 1
105913: ST_TO_ADDR
// if p3 = 25 then
105914: LD_VAR 0 3
105918: PUSH
105919: LD_INT 25
105921: EQUAL
105922: IFFALSE 105932
// sSheik := true ;
105924: LD_ADDR_EXP 198
105928: PUSH
105929: LD_INT 1
105931: ST_TO_ADDR
// if p3 = 26 then
105932: LD_VAR 0 3
105936: PUSH
105937: LD_INT 26
105939: EQUAL
105940: IFFALSE 105950
// sEarthquake := true ;
105942: LD_ADDR_EXP 200
105946: PUSH
105947: LD_INT 1
105949: ST_TO_ADDR
// if p3 = 27 then
105950: LD_VAR 0 3
105954: PUSH
105955: LD_INT 27
105957: EQUAL
105958: IFFALSE 105968
// sAI := true ;
105960: LD_ADDR_EXP 201
105964: PUSH
105965: LD_INT 1
105967: ST_TO_ADDR
// if p3 = 28 then
105968: LD_VAR 0 3
105972: PUSH
105973: LD_INT 28
105975: EQUAL
105976: IFFALSE 105986
// sCargo := true ;
105978: LD_ADDR_EXP 204
105982: PUSH
105983: LD_INT 1
105985: ST_TO_ADDR
// if p3 = 29 then
105986: LD_VAR 0 3
105990: PUSH
105991: LD_INT 29
105993: EQUAL
105994: IFFALSE 106004
// sDLaser := true ;
105996: LD_ADDR_EXP 205
106000: PUSH
106001: LD_INT 1
106003: ST_TO_ADDR
// if p3 = 30 then
106004: LD_VAR 0 3
106008: PUSH
106009: LD_INT 30
106011: EQUAL
106012: IFFALSE 106022
// sExchange := true ;
106014: LD_ADDR_EXP 206
106018: PUSH
106019: LD_INT 1
106021: ST_TO_ADDR
// if p3 = 31 then
106022: LD_VAR 0 3
106026: PUSH
106027: LD_INT 31
106029: EQUAL
106030: IFFALSE 106040
// sFac := true ;
106032: LD_ADDR_EXP 207
106036: PUSH
106037: LD_INT 1
106039: ST_TO_ADDR
// if p3 = 32 then
106040: LD_VAR 0 3
106044: PUSH
106045: LD_INT 32
106047: EQUAL
106048: IFFALSE 106058
// sPower := true ;
106050: LD_ADDR_EXP 208
106054: PUSH
106055: LD_INT 1
106057: ST_TO_ADDR
// if p3 = 33 then
106058: LD_VAR 0 3
106062: PUSH
106063: LD_INT 33
106065: EQUAL
106066: IFFALSE 106076
// sRandom := true ;
106068: LD_ADDR_EXP 209
106072: PUSH
106073: LD_INT 1
106075: ST_TO_ADDR
// if p3 = 34 then
106076: LD_VAR 0 3
106080: PUSH
106081: LD_INT 34
106083: EQUAL
106084: IFFALSE 106094
// sShield := true ;
106086: LD_ADDR_EXP 210
106090: PUSH
106091: LD_INT 1
106093: ST_TO_ADDR
// if p3 = 35 then
106094: LD_VAR 0 3
106098: PUSH
106099: LD_INT 35
106101: EQUAL
106102: IFFALSE 106112
// sTime := true ;
106104: LD_ADDR_EXP 211
106108: PUSH
106109: LD_INT 1
106111: ST_TO_ADDR
// if p3 = 36 then
106112: LD_VAR 0 3
106116: PUSH
106117: LD_INT 36
106119: EQUAL
106120: IFFALSE 106130
// sTools := true ;
106122: LD_ADDR_EXP 212
106126: PUSH
106127: LD_INT 1
106129: ST_TO_ADDR
// if p3 = 101 then
106130: LD_VAR 0 3
106134: PUSH
106135: LD_INT 101
106137: EQUAL
106138: IFFALSE 106148
// sSold := true ;
106140: LD_ADDR_EXP 177
106144: PUSH
106145: LD_INT 1
106147: ST_TO_ADDR
// if p3 = 102 then
106148: LD_VAR 0 3
106152: PUSH
106153: LD_INT 102
106155: EQUAL
106156: IFFALSE 106166
// sDiff := true ;
106158: LD_ADDR_EXP 178
106162: PUSH
106163: LD_INT 1
106165: ST_TO_ADDR
// if p3 = 103 then
106166: LD_VAR 0 3
106170: PUSH
106171: LD_INT 103
106173: EQUAL
106174: IFFALSE 106184
// sFog := true ;
106176: LD_ADDR_EXP 181
106180: PUSH
106181: LD_INT 1
106183: ST_TO_ADDR
// if p3 = 104 then
106184: LD_VAR 0 3
106188: PUSH
106189: LD_INT 104
106191: EQUAL
106192: IFFALSE 106202
// sReset := true ;
106194: LD_ADDR_EXP 182
106198: PUSH
106199: LD_INT 1
106201: ST_TO_ADDR
// if p3 = 105 then
106202: LD_VAR 0 3
106206: PUSH
106207: LD_INT 105
106209: EQUAL
106210: IFFALSE 106220
// sSun := true ;
106212: LD_ADDR_EXP 183
106216: PUSH
106217: LD_INT 1
106219: ST_TO_ADDR
// if p3 = 106 then
106220: LD_VAR 0 3
106224: PUSH
106225: LD_INT 106
106227: EQUAL
106228: IFFALSE 106238
// sTiger := true ;
106230: LD_ADDR_EXP 179
106234: PUSH
106235: LD_INT 1
106237: ST_TO_ADDR
// if p3 = 107 then
106238: LD_VAR 0 3
106242: PUSH
106243: LD_INT 107
106245: EQUAL
106246: IFFALSE 106256
// sBomb := true ;
106248: LD_ADDR_EXP 180
106252: PUSH
106253: LD_INT 1
106255: ST_TO_ADDR
// if p3 = 108 then
106256: LD_VAR 0 3
106260: PUSH
106261: LD_INT 108
106263: EQUAL
106264: IFFALSE 106274
// sWound := true ;
106266: LD_ADDR_EXP 188
106270: PUSH
106271: LD_INT 1
106273: ST_TO_ADDR
// if p3 = 109 then
106274: LD_VAR 0 3
106278: PUSH
106279: LD_INT 109
106281: EQUAL
106282: IFFALSE 106292
// sBetray := true ;
106284: LD_ADDR_EXP 192
106288: PUSH
106289: LD_INT 1
106291: ST_TO_ADDR
// if p3 = 110 then
106292: LD_VAR 0 3
106296: PUSH
106297: LD_INT 110
106299: EQUAL
106300: IFFALSE 106310
// sContamin := true ;
106302: LD_ADDR_EXP 193
106306: PUSH
106307: LD_INT 1
106309: ST_TO_ADDR
// if p3 = 111 then
106310: LD_VAR 0 3
106314: PUSH
106315: LD_INT 111
106317: EQUAL
106318: IFFALSE 106328
// sOil := true ;
106320: LD_ADDR_EXP 195
106324: PUSH
106325: LD_INT 1
106327: ST_TO_ADDR
// if p3 = 112 then
106328: LD_VAR 0 3
106332: PUSH
106333: LD_INT 112
106335: EQUAL
106336: IFFALSE 106346
// sStu := true ;
106338: LD_ADDR_EXP 199
106342: PUSH
106343: LD_INT 1
106345: ST_TO_ADDR
// if p3 = 113 then
106346: LD_VAR 0 3
106350: PUSH
106351: LD_INT 113
106353: EQUAL
106354: IFFALSE 106364
// sBazooka := true ;
106356: LD_ADDR_EXP 202
106360: PUSH
106361: LD_INT 1
106363: ST_TO_ADDR
// if p3 = 114 then
106364: LD_VAR 0 3
106368: PUSH
106369: LD_INT 114
106371: EQUAL
106372: IFFALSE 106382
// sMortar := true ;
106374: LD_ADDR_EXP 203
106378: PUSH
106379: LD_INT 1
106381: ST_TO_ADDR
// if p3 = 115 then
106382: LD_VAR 0 3
106386: PUSH
106387: LD_INT 115
106389: EQUAL
106390: IFFALSE 106400
// sRanger := true ;
106392: LD_ADDR_EXP 213
106396: PUSH
106397: LD_INT 1
106399: ST_TO_ADDR
// if p3 = 116 then
106400: LD_VAR 0 3
106404: PUSH
106405: LD_INT 116
106407: EQUAL
106408: IFFALSE 106418
// sComputer := true ;
106410: LD_ADDR_EXP 214
106414: PUSH
106415: LD_INT 1
106417: ST_TO_ADDR
// if p3 = 117 then
106418: LD_VAR 0 3
106422: PUSH
106423: LD_INT 117
106425: EQUAL
106426: IFFALSE 106436
// s30 := true ;
106428: LD_ADDR_EXP 215
106432: PUSH
106433: LD_INT 1
106435: ST_TO_ADDR
// if p3 = 118 then
106436: LD_VAR 0 3
106440: PUSH
106441: LD_INT 118
106443: EQUAL
106444: IFFALSE 106454
// s60 := true ;
106446: LD_ADDR_EXP 216
106450: PUSH
106451: LD_INT 1
106453: ST_TO_ADDR
// end ; if p2 = 101 then
106454: LD_VAR 0 2
106458: PUSH
106459: LD_INT 101
106461: EQUAL
106462: IFFALSE 106590
// begin case p3 of 1 :
106464: LD_VAR 0 3
106468: PUSH
106469: LD_INT 1
106471: DOUBLE
106472: EQUAL
106473: IFTRUE 106477
106475: GO 106484
106477: POP
// hHackUnlimitedResources ; 2 :
106478: CALL 118186 0 0
106482: GO 106590
106484: LD_INT 2
106486: DOUBLE
106487: EQUAL
106488: IFTRUE 106492
106490: GO 106499
106492: POP
// hHackSetLevel10 ; 3 :
106493: CALL 118319 0 0
106497: GO 106590
106499: LD_INT 3
106501: DOUBLE
106502: EQUAL
106503: IFTRUE 106507
106505: GO 106514
106507: POP
// hHackSetLevel10YourUnits ; 4 :
106508: CALL 118404 0 0
106512: GO 106590
106514: LD_INT 4
106516: DOUBLE
106517: EQUAL
106518: IFTRUE 106522
106520: GO 106529
106522: POP
// hHackInvincible ; 5 :
106523: CALL 118852 0 0
106527: GO 106590
106529: LD_INT 5
106531: DOUBLE
106532: EQUAL
106533: IFTRUE 106537
106535: GO 106544
106537: POP
// hHackInvisible ; 6 :
106538: CALL 118963 0 0
106542: GO 106590
106544: LD_INT 6
106546: DOUBLE
106547: EQUAL
106548: IFTRUE 106552
106550: GO 106559
106552: POP
// hHackChangeYourSide ; 7 :
106553: CALL 119020 0 0
106557: GO 106590
106559: LD_INT 7
106561: DOUBLE
106562: EQUAL
106563: IFTRUE 106567
106565: GO 106574
106567: POP
// hHackChangeUnitSide ; 8 :
106568: CALL 119062 0 0
106572: GO 106590
106574: LD_INT 8
106576: DOUBLE
106577: EQUAL
106578: IFTRUE 106582
106580: GO 106589
106582: POP
// hHackFog ; end ;
106583: CALL 119163 0 0
106587: GO 106590
106589: POP
// end ; end ;
106590: LD_VAR 0 7
106594: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
106595: GO 106597
106597: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
106598: LD_STRING initStreamRollete();
106600: PPUSH
106601: CALL_OW 559
// InitStreamMode ;
106605: CALL 106614 0 0
// DefineStreamItems ( ) ;
106609: CALL 107078 0 0
// end ;
106613: END
// function InitStreamMode ; begin
106614: LD_INT 0
106616: PPUSH
// streamModeActive := false ;
106617: LD_ADDR_EXP 160
106621: PUSH
106622: LD_INT 0
106624: ST_TO_ADDR
// normalCounter := 36 ;
106625: LD_ADDR_EXP 161
106629: PUSH
106630: LD_INT 36
106632: ST_TO_ADDR
// hardcoreCounter := 16 ;
106633: LD_ADDR_EXP 162
106637: PUSH
106638: LD_INT 16
106640: ST_TO_ADDR
// sRocket := false ;
106641: LD_ADDR_EXP 165
106645: PUSH
106646: LD_INT 0
106648: ST_TO_ADDR
// sSpeed := false ;
106649: LD_ADDR_EXP 164
106653: PUSH
106654: LD_INT 0
106656: ST_TO_ADDR
// sEngine := false ;
106657: LD_ADDR_EXP 166
106661: PUSH
106662: LD_INT 0
106664: ST_TO_ADDR
// sSpec := false ;
106665: LD_ADDR_EXP 163
106669: PUSH
106670: LD_INT 0
106672: ST_TO_ADDR
// sLevel := false ;
106673: LD_ADDR_EXP 167
106677: PUSH
106678: LD_INT 0
106680: ST_TO_ADDR
// sArmoury := false ;
106681: LD_ADDR_EXP 168
106685: PUSH
106686: LD_INT 0
106688: ST_TO_ADDR
// sRadar := false ;
106689: LD_ADDR_EXP 169
106693: PUSH
106694: LD_INT 0
106696: ST_TO_ADDR
// sBunker := false ;
106697: LD_ADDR_EXP 170
106701: PUSH
106702: LD_INT 0
106704: ST_TO_ADDR
// sHack := false ;
106705: LD_ADDR_EXP 171
106709: PUSH
106710: LD_INT 0
106712: ST_TO_ADDR
// sFire := false ;
106713: LD_ADDR_EXP 172
106717: PUSH
106718: LD_INT 0
106720: ST_TO_ADDR
// sRefresh := false ;
106721: LD_ADDR_EXP 173
106725: PUSH
106726: LD_INT 0
106728: ST_TO_ADDR
// sExp := false ;
106729: LD_ADDR_EXP 174
106733: PUSH
106734: LD_INT 0
106736: ST_TO_ADDR
// sDepot := false ;
106737: LD_ADDR_EXP 175
106741: PUSH
106742: LD_INT 0
106744: ST_TO_ADDR
// sFlag := false ;
106745: LD_ADDR_EXP 176
106749: PUSH
106750: LD_INT 0
106752: ST_TO_ADDR
// sKamikadze := false ;
106753: LD_ADDR_EXP 184
106757: PUSH
106758: LD_INT 0
106760: ST_TO_ADDR
// sTroll := false ;
106761: LD_ADDR_EXP 185
106765: PUSH
106766: LD_INT 0
106768: ST_TO_ADDR
// sSlow := false ;
106769: LD_ADDR_EXP 186
106773: PUSH
106774: LD_INT 0
106776: ST_TO_ADDR
// sLack := false ;
106777: LD_ADDR_EXP 187
106781: PUSH
106782: LD_INT 0
106784: ST_TO_ADDR
// sTank := false ;
106785: LD_ADDR_EXP 189
106789: PUSH
106790: LD_INT 0
106792: ST_TO_ADDR
// sRemote := false ;
106793: LD_ADDR_EXP 190
106797: PUSH
106798: LD_INT 0
106800: ST_TO_ADDR
// sPowell := false ;
106801: LD_ADDR_EXP 191
106805: PUSH
106806: LD_INT 0
106808: ST_TO_ADDR
// sTeleport := false ;
106809: LD_ADDR_EXP 194
106813: PUSH
106814: LD_INT 0
106816: ST_TO_ADDR
// sOilTower := false ;
106817: LD_ADDR_EXP 196
106821: PUSH
106822: LD_INT 0
106824: ST_TO_ADDR
// sShovel := false ;
106825: LD_ADDR_EXP 197
106829: PUSH
106830: LD_INT 0
106832: ST_TO_ADDR
// sSheik := false ;
106833: LD_ADDR_EXP 198
106837: PUSH
106838: LD_INT 0
106840: ST_TO_ADDR
// sEarthquake := false ;
106841: LD_ADDR_EXP 200
106845: PUSH
106846: LD_INT 0
106848: ST_TO_ADDR
// sAI := false ;
106849: LD_ADDR_EXP 201
106853: PUSH
106854: LD_INT 0
106856: ST_TO_ADDR
// sCargo := false ;
106857: LD_ADDR_EXP 204
106861: PUSH
106862: LD_INT 0
106864: ST_TO_ADDR
// sDLaser := false ;
106865: LD_ADDR_EXP 205
106869: PUSH
106870: LD_INT 0
106872: ST_TO_ADDR
// sExchange := false ;
106873: LD_ADDR_EXP 206
106877: PUSH
106878: LD_INT 0
106880: ST_TO_ADDR
// sFac := false ;
106881: LD_ADDR_EXP 207
106885: PUSH
106886: LD_INT 0
106888: ST_TO_ADDR
// sPower := false ;
106889: LD_ADDR_EXP 208
106893: PUSH
106894: LD_INT 0
106896: ST_TO_ADDR
// sRandom := false ;
106897: LD_ADDR_EXP 209
106901: PUSH
106902: LD_INT 0
106904: ST_TO_ADDR
// sShield := false ;
106905: LD_ADDR_EXP 210
106909: PUSH
106910: LD_INT 0
106912: ST_TO_ADDR
// sTime := false ;
106913: LD_ADDR_EXP 211
106917: PUSH
106918: LD_INT 0
106920: ST_TO_ADDR
// sTools := false ;
106921: LD_ADDR_EXP 212
106925: PUSH
106926: LD_INT 0
106928: ST_TO_ADDR
// sSold := false ;
106929: LD_ADDR_EXP 177
106933: PUSH
106934: LD_INT 0
106936: ST_TO_ADDR
// sDiff := false ;
106937: LD_ADDR_EXP 178
106941: PUSH
106942: LD_INT 0
106944: ST_TO_ADDR
// sFog := false ;
106945: LD_ADDR_EXP 181
106949: PUSH
106950: LD_INT 0
106952: ST_TO_ADDR
// sReset := false ;
106953: LD_ADDR_EXP 182
106957: PUSH
106958: LD_INT 0
106960: ST_TO_ADDR
// sSun := false ;
106961: LD_ADDR_EXP 183
106965: PUSH
106966: LD_INT 0
106968: ST_TO_ADDR
// sTiger := false ;
106969: LD_ADDR_EXP 179
106973: PUSH
106974: LD_INT 0
106976: ST_TO_ADDR
// sBomb := false ;
106977: LD_ADDR_EXP 180
106981: PUSH
106982: LD_INT 0
106984: ST_TO_ADDR
// sWound := false ;
106985: LD_ADDR_EXP 188
106989: PUSH
106990: LD_INT 0
106992: ST_TO_ADDR
// sBetray := false ;
106993: LD_ADDR_EXP 192
106997: PUSH
106998: LD_INT 0
107000: ST_TO_ADDR
// sContamin := false ;
107001: LD_ADDR_EXP 193
107005: PUSH
107006: LD_INT 0
107008: ST_TO_ADDR
// sOil := false ;
107009: LD_ADDR_EXP 195
107013: PUSH
107014: LD_INT 0
107016: ST_TO_ADDR
// sStu := false ;
107017: LD_ADDR_EXP 199
107021: PUSH
107022: LD_INT 0
107024: ST_TO_ADDR
// sBazooka := false ;
107025: LD_ADDR_EXP 202
107029: PUSH
107030: LD_INT 0
107032: ST_TO_ADDR
// sMortar := false ;
107033: LD_ADDR_EXP 203
107037: PUSH
107038: LD_INT 0
107040: ST_TO_ADDR
// sRanger := false ;
107041: LD_ADDR_EXP 213
107045: PUSH
107046: LD_INT 0
107048: ST_TO_ADDR
// sComputer := false ;
107049: LD_ADDR_EXP 214
107053: PUSH
107054: LD_INT 0
107056: ST_TO_ADDR
// s30 := false ;
107057: LD_ADDR_EXP 215
107061: PUSH
107062: LD_INT 0
107064: ST_TO_ADDR
// s60 := false ;
107065: LD_ADDR_EXP 216
107069: PUSH
107070: LD_INT 0
107072: ST_TO_ADDR
// end ;
107073: LD_VAR 0 1
107077: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
107078: LD_INT 0
107080: PPUSH
107081: PPUSH
107082: PPUSH
107083: PPUSH
107084: PPUSH
// result := [ ] ;
107085: LD_ADDR_VAR 0 1
107089: PUSH
107090: EMPTY
107091: ST_TO_ADDR
// if campaign_id = 1 then
107092: LD_OWVAR 69
107096: PUSH
107097: LD_INT 1
107099: EQUAL
107100: IFFALSE 110266
// begin case mission_number of 1 :
107102: LD_OWVAR 70
107106: PUSH
107107: LD_INT 1
107109: DOUBLE
107110: EQUAL
107111: IFTRUE 107115
107113: GO 107191
107115: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
107116: LD_ADDR_VAR 0 1
107120: PUSH
107121: LD_INT 2
107123: PUSH
107124: LD_INT 4
107126: PUSH
107127: LD_INT 11
107129: PUSH
107130: LD_INT 12
107132: PUSH
107133: LD_INT 15
107135: PUSH
107136: LD_INT 16
107138: PUSH
107139: LD_INT 22
107141: PUSH
107142: LD_INT 23
107144: PUSH
107145: LD_INT 26
107147: PUSH
107148: EMPTY
107149: LIST
107150: LIST
107151: LIST
107152: LIST
107153: LIST
107154: LIST
107155: LIST
107156: LIST
107157: LIST
107158: PUSH
107159: LD_INT 101
107161: PUSH
107162: LD_INT 102
107164: PUSH
107165: LD_INT 106
107167: PUSH
107168: LD_INT 116
107170: PUSH
107171: LD_INT 117
107173: PUSH
107174: LD_INT 118
107176: PUSH
107177: EMPTY
107178: LIST
107179: LIST
107180: LIST
107181: LIST
107182: LIST
107183: LIST
107184: PUSH
107185: EMPTY
107186: LIST
107187: LIST
107188: ST_TO_ADDR
107189: GO 110264
107191: LD_INT 2
107193: DOUBLE
107194: EQUAL
107195: IFTRUE 107199
107197: GO 107283
107199: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
107200: LD_ADDR_VAR 0 1
107204: PUSH
107205: LD_INT 2
107207: PUSH
107208: LD_INT 4
107210: PUSH
107211: LD_INT 11
107213: PUSH
107214: LD_INT 12
107216: PUSH
107217: LD_INT 15
107219: PUSH
107220: LD_INT 16
107222: PUSH
107223: LD_INT 22
107225: PUSH
107226: LD_INT 23
107228: PUSH
107229: LD_INT 26
107231: PUSH
107232: EMPTY
107233: LIST
107234: LIST
107235: LIST
107236: LIST
107237: LIST
107238: LIST
107239: LIST
107240: LIST
107241: LIST
107242: PUSH
107243: LD_INT 101
107245: PUSH
107246: LD_INT 102
107248: PUSH
107249: LD_INT 105
107251: PUSH
107252: LD_INT 106
107254: PUSH
107255: LD_INT 108
107257: PUSH
107258: LD_INT 116
107260: PUSH
107261: LD_INT 117
107263: PUSH
107264: LD_INT 118
107266: PUSH
107267: EMPTY
107268: LIST
107269: LIST
107270: LIST
107271: LIST
107272: LIST
107273: LIST
107274: LIST
107275: LIST
107276: PUSH
107277: EMPTY
107278: LIST
107279: LIST
107280: ST_TO_ADDR
107281: GO 110264
107283: LD_INT 3
107285: DOUBLE
107286: EQUAL
107287: IFTRUE 107291
107289: GO 107379
107291: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
107292: LD_ADDR_VAR 0 1
107296: PUSH
107297: LD_INT 2
107299: PUSH
107300: LD_INT 4
107302: PUSH
107303: LD_INT 5
107305: PUSH
107306: LD_INT 11
107308: PUSH
107309: LD_INT 12
107311: PUSH
107312: LD_INT 15
107314: PUSH
107315: LD_INT 16
107317: PUSH
107318: LD_INT 22
107320: PUSH
107321: LD_INT 26
107323: PUSH
107324: LD_INT 36
107326: PUSH
107327: EMPTY
107328: LIST
107329: LIST
107330: LIST
107331: LIST
107332: LIST
107333: LIST
107334: LIST
107335: LIST
107336: LIST
107337: LIST
107338: PUSH
107339: LD_INT 101
107341: PUSH
107342: LD_INT 102
107344: PUSH
107345: LD_INT 105
107347: PUSH
107348: LD_INT 106
107350: PUSH
107351: LD_INT 108
107353: PUSH
107354: LD_INT 116
107356: PUSH
107357: LD_INT 117
107359: PUSH
107360: LD_INT 118
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: LIST
107367: LIST
107368: LIST
107369: LIST
107370: LIST
107371: LIST
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: ST_TO_ADDR
107377: GO 110264
107379: LD_INT 4
107381: DOUBLE
107382: EQUAL
107383: IFTRUE 107387
107385: GO 107483
107387: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
107388: LD_ADDR_VAR 0 1
107392: PUSH
107393: LD_INT 2
107395: PUSH
107396: LD_INT 4
107398: PUSH
107399: LD_INT 5
107401: PUSH
107402: LD_INT 8
107404: PUSH
107405: LD_INT 11
107407: PUSH
107408: LD_INT 12
107410: PUSH
107411: LD_INT 15
107413: PUSH
107414: LD_INT 16
107416: PUSH
107417: LD_INT 22
107419: PUSH
107420: LD_INT 23
107422: PUSH
107423: LD_INT 26
107425: PUSH
107426: LD_INT 36
107428: PUSH
107429: EMPTY
107430: LIST
107431: LIST
107432: LIST
107433: LIST
107434: LIST
107435: LIST
107436: LIST
107437: LIST
107438: LIST
107439: LIST
107440: LIST
107441: LIST
107442: PUSH
107443: LD_INT 101
107445: PUSH
107446: LD_INT 102
107448: PUSH
107449: LD_INT 105
107451: PUSH
107452: LD_INT 106
107454: PUSH
107455: LD_INT 108
107457: PUSH
107458: LD_INT 116
107460: PUSH
107461: LD_INT 117
107463: PUSH
107464: LD_INT 118
107466: PUSH
107467: EMPTY
107468: LIST
107469: LIST
107470: LIST
107471: LIST
107472: LIST
107473: LIST
107474: LIST
107475: LIST
107476: PUSH
107477: EMPTY
107478: LIST
107479: LIST
107480: ST_TO_ADDR
107481: GO 110264
107483: LD_INT 5
107485: DOUBLE
107486: EQUAL
107487: IFTRUE 107491
107489: GO 107603
107491: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
107492: LD_ADDR_VAR 0 1
107496: PUSH
107497: LD_INT 2
107499: PUSH
107500: LD_INT 4
107502: PUSH
107503: LD_INT 5
107505: PUSH
107506: LD_INT 6
107508: PUSH
107509: LD_INT 8
107511: PUSH
107512: LD_INT 11
107514: PUSH
107515: LD_INT 12
107517: PUSH
107518: LD_INT 15
107520: PUSH
107521: LD_INT 16
107523: PUSH
107524: LD_INT 22
107526: PUSH
107527: LD_INT 23
107529: PUSH
107530: LD_INT 25
107532: PUSH
107533: LD_INT 26
107535: PUSH
107536: LD_INT 36
107538: PUSH
107539: EMPTY
107540: LIST
107541: LIST
107542: LIST
107543: LIST
107544: LIST
107545: LIST
107546: LIST
107547: LIST
107548: LIST
107549: LIST
107550: LIST
107551: LIST
107552: LIST
107553: LIST
107554: PUSH
107555: LD_INT 101
107557: PUSH
107558: LD_INT 102
107560: PUSH
107561: LD_INT 105
107563: PUSH
107564: LD_INT 106
107566: PUSH
107567: LD_INT 108
107569: PUSH
107570: LD_INT 109
107572: PUSH
107573: LD_INT 112
107575: PUSH
107576: LD_INT 116
107578: PUSH
107579: LD_INT 117
107581: PUSH
107582: LD_INT 118
107584: PUSH
107585: EMPTY
107586: LIST
107587: LIST
107588: LIST
107589: LIST
107590: LIST
107591: LIST
107592: LIST
107593: LIST
107594: LIST
107595: LIST
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: ST_TO_ADDR
107601: GO 110264
107603: LD_INT 6
107605: DOUBLE
107606: EQUAL
107607: IFTRUE 107611
107609: GO 107743
107611: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
107612: LD_ADDR_VAR 0 1
107616: PUSH
107617: LD_INT 2
107619: PUSH
107620: LD_INT 4
107622: PUSH
107623: LD_INT 5
107625: PUSH
107626: LD_INT 6
107628: PUSH
107629: LD_INT 8
107631: PUSH
107632: LD_INT 11
107634: PUSH
107635: LD_INT 12
107637: PUSH
107638: LD_INT 15
107640: PUSH
107641: LD_INT 16
107643: PUSH
107644: LD_INT 20
107646: PUSH
107647: LD_INT 21
107649: PUSH
107650: LD_INT 22
107652: PUSH
107653: LD_INT 23
107655: PUSH
107656: LD_INT 25
107658: PUSH
107659: LD_INT 26
107661: PUSH
107662: LD_INT 30
107664: PUSH
107665: LD_INT 31
107667: PUSH
107668: LD_INT 32
107670: PUSH
107671: LD_INT 36
107673: PUSH
107674: EMPTY
107675: LIST
107676: LIST
107677: LIST
107678: LIST
107679: LIST
107680: LIST
107681: LIST
107682: LIST
107683: LIST
107684: LIST
107685: LIST
107686: LIST
107687: LIST
107688: LIST
107689: LIST
107690: LIST
107691: LIST
107692: LIST
107693: LIST
107694: PUSH
107695: LD_INT 101
107697: PUSH
107698: LD_INT 102
107700: PUSH
107701: LD_INT 105
107703: PUSH
107704: LD_INT 106
107706: PUSH
107707: LD_INT 108
107709: PUSH
107710: LD_INT 109
107712: PUSH
107713: LD_INT 112
107715: PUSH
107716: LD_INT 116
107718: PUSH
107719: LD_INT 117
107721: PUSH
107722: LD_INT 118
107724: PUSH
107725: EMPTY
107726: LIST
107727: LIST
107728: LIST
107729: LIST
107730: LIST
107731: LIST
107732: LIST
107733: LIST
107734: LIST
107735: LIST
107736: PUSH
107737: EMPTY
107738: LIST
107739: LIST
107740: ST_TO_ADDR
107741: GO 110264
107743: LD_INT 7
107745: DOUBLE
107746: EQUAL
107747: IFTRUE 107751
107749: GO 107863
107751: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
107752: LD_ADDR_VAR 0 1
107756: PUSH
107757: LD_INT 2
107759: PUSH
107760: LD_INT 4
107762: PUSH
107763: LD_INT 5
107765: PUSH
107766: LD_INT 7
107768: PUSH
107769: LD_INT 11
107771: PUSH
107772: LD_INT 12
107774: PUSH
107775: LD_INT 15
107777: PUSH
107778: LD_INT 16
107780: PUSH
107781: LD_INT 20
107783: PUSH
107784: LD_INT 21
107786: PUSH
107787: LD_INT 22
107789: PUSH
107790: LD_INT 23
107792: PUSH
107793: LD_INT 25
107795: PUSH
107796: LD_INT 26
107798: PUSH
107799: EMPTY
107800: LIST
107801: LIST
107802: LIST
107803: LIST
107804: LIST
107805: LIST
107806: LIST
107807: LIST
107808: LIST
107809: LIST
107810: LIST
107811: LIST
107812: LIST
107813: LIST
107814: PUSH
107815: LD_INT 101
107817: PUSH
107818: LD_INT 102
107820: PUSH
107821: LD_INT 103
107823: PUSH
107824: LD_INT 105
107826: PUSH
107827: LD_INT 106
107829: PUSH
107830: LD_INT 108
107832: PUSH
107833: LD_INT 112
107835: PUSH
107836: LD_INT 116
107838: PUSH
107839: LD_INT 117
107841: PUSH
107842: LD_INT 118
107844: PUSH
107845: EMPTY
107846: LIST
107847: LIST
107848: LIST
107849: LIST
107850: LIST
107851: LIST
107852: LIST
107853: LIST
107854: LIST
107855: LIST
107856: PUSH
107857: EMPTY
107858: LIST
107859: LIST
107860: ST_TO_ADDR
107861: GO 110264
107863: LD_INT 8
107865: DOUBLE
107866: EQUAL
107867: IFTRUE 107871
107869: GO 108011
107871: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
107872: LD_ADDR_VAR 0 1
107876: PUSH
107877: LD_INT 2
107879: PUSH
107880: LD_INT 4
107882: PUSH
107883: LD_INT 5
107885: PUSH
107886: LD_INT 6
107888: PUSH
107889: LD_INT 7
107891: PUSH
107892: LD_INT 8
107894: PUSH
107895: LD_INT 11
107897: PUSH
107898: LD_INT 12
107900: PUSH
107901: LD_INT 15
107903: PUSH
107904: LD_INT 16
107906: PUSH
107907: LD_INT 20
107909: PUSH
107910: LD_INT 21
107912: PUSH
107913: LD_INT 22
107915: PUSH
107916: LD_INT 23
107918: PUSH
107919: LD_INT 25
107921: PUSH
107922: LD_INT 26
107924: PUSH
107925: LD_INT 30
107927: PUSH
107928: LD_INT 31
107930: PUSH
107931: LD_INT 32
107933: PUSH
107934: LD_INT 36
107936: PUSH
107937: EMPTY
107938: LIST
107939: LIST
107940: LIST
107941: LIST
107942: LIST
107943: LIST
107944: LIST
107945: LIST
107946: LIST
107947: LIST
107948: LIST
107949: LIST
107950: LIST
107951: LIST
107952: LIST
107953: LIST
107954: LIST
107955: LIST
107956: LIST
107957: LIST
107958: PUSH
107959: LD_INT 101
107961: PUSH
107962: LD_INT 102
107964: PUSH
107965: LD_INT 103
107967: PUSH
107968: LD_INT 105
107970: PUSH
107971: LD_INT 106
107973: PUSH
107974: LD_INT 108
107976: PUSH
107977: LD_INT 109
107979: PUSH
107980: LD_INT 112
107982: PUSH
107983: LD_INT 116
107985: PUSH
107986: LD_INT 117
107988: PUSH
107989: LD_INT 118
107991: PUSH
107992: EMPTY
107993: LIST
107994: LIST
107995: LIST
107996: LIST
107997: LIST
107998: LIST
107999: LIST
108000: LIST
108001: LIST
108002: LIST
108003: LIST
108004: PUSH
108005: EMPTY
108006: LIST
108007: LIST
108008: ST_TO_ADDR
108009: GO 110264
108011: LD_INT 9
108013: DOUBLE
108014: EQUAL
108015: IFTRUE 108019
108017: GO 108167
108019: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
108020: LD_ADDR_VAR 0 1
108024: PUSH
108025: LD_INT 2
108027: PUSH
108028: LD_INT 4
108030: PUSH
108031: LD_INT 5
108033: PUSH
108034: LD_INT 6
108036: PUSH
108037: LD_INT 7
108039: PUSH
108040: LD_INT 8
108042: PUSH
108043: LD_INT 11
108045: PUSH
108046: LD_INT 12
108048: PUSH
108049: LD_INT 15
108051: PUSH
108052: LD_INT 16
108054: PUSH
108055: LD_INT 20
108057: PUSH
108058: LD_INT 21
108060: PUSH
108061: LD_INT 22
108063: PUSH
108064: LD_INT 23
108066: PUSH
108067: LD_INT 25
108069: PUSH
108070: LD_INT 26
108072: PUSH
108073: LD_INT 28
108075: PUSH
108076: LD_INT 30
108078: PUSH
108079: LD_INT 31
108081: PUSH
108082: LD_INT 32
108084: PUSH
108085: LD_INT 36
108087: PUSH
108088: EMPTY
108089: LIST
108090: LIST
108091: LIST
108092: LIST
108093: LIST
108094: LIST
108095: LIST
108096: LIST
108097: LIST
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: LIST
108104: LIST
108105: LIST
108106: LIST
108107: LIST
108108: LIST
108109: LIST
108110: PUSH
108111: LD_INT 101
108113: PUSH
108114: LD_INT 102
108116: PUSH
108117: LD_INT 103
108119: PUSH
108120: LD_INT 105
108122: PUSH
108123: LD_INT 106
108125: PUSH
108126: LD_INT 108
108128: PUSH
108129: LD_INT 109
108131: PUSH
108132: LD_INT 112
108134: PUSH
108135: LD_INT 114
108137: PUSH
108138: LD_INT 116
108140: PUSH
108141: LD_INT 117
108143: PUSH
108144: LD_INT 118
108146: PUSH
108147: EMPTY
108148: LIST
108149: LIST
108150: LIST
108151: LIST
108152: LIST
108153: LIST
108154: LIST
108155: LIST
108156: LIST
108157: LIST
108158: LIST
108159: LIST
108160: PUSH
108161: EMPTY
108162: LIST
108163: LIST
108164: ST_TO_ADDR
108165: GO 110264
108167: LD_INT 10
108169: DOUBLE
108170: EQUAL
108171: IFTRUE 108175
108173: GO 108371
108175: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
108176: LD_ADDR_VAR 0 1
108180: PUSH
108181: LD_INT 2
108183: PUSH
108184: LD_INT 4
108186: PUSH
108187: LD_INT 5
108189: PUSH
108190: LD_INT 6
108192: PUSH
108193: LD_INT 7
108195: PUSH
108196: LD_INT 8
108198: PUSH
108199: LD_INT 9
108201: PUSH
108202: LD_INT 10
108204: PUSH
108205: LD_INT 11
108207: PUSH
108208: LD_INT 12
108210: PUSH
108211: LD_INT 13
108213: PUSH
108214: LD_INT 14
108216: PUSH
108217: LD_INT 15
108219: PUSH
108220: LD_INT 16
108222: PUSH
108223: LD_INT 17
108225: PUSH
108226: LD_INT 18
108228: PUSH
108229: LD_INT 19
108231: PUSH
108232: LD_INT 20
108234: PUSH
108235: LD_INT 21
108237: PUSH
108238: LD_INT 22
108240: PUSH
108241: LD_INT 23
108243: PUSH
108244: LD_INT 24
108246: PUSH
108247: LD_INT 25
108249: PUSH
108250: LD_INT 26
108252: PUSH
108253: LD_INT 28
108255: PUSH
108256: LD_INT 30
108258: PUSH
108259: LD_INT 31
108261: PUSH
108262: LD_INT 32
108264: PUSH
108265: LD_INT 36
108267: PUSH
108268: EMPTY
108269: LIST
108270: LIST
108271: LIST
108272: LIST
108273: LIST
108274: LIST
108275: LIST
108276: LIST
108277: LIST
108278: LIST
108279: LIST
108280: LIST
108281: LIST
108282: LIST
108283: LIST
108284: LIST
108285: LIST
108286: LIST
108287: LIST
108288: LIST
108289: LIST
108290: LIST
108291: LIST
108292: LIST
108293: LIST
108294: LIST
108295: LIST
108296: LIST
108297: LIST
108298: PUSH
108299: LD_INT 101
108301: PUSH
108302: LD_INT 102
108304: PUSH
108305: LD_INT 103
108307: PUSH
108308: LD_INT 104
108310: PUSH
108311: LD_INT 105
108313: PUSH
108314: LD_INT 106
108316: PUSH
108317: LD_INT 107
108319: PUSH
108320: LD_INT 108
108322: PUSH
108323: LD_INT 109
108325: PUSH
108326: LD_INT 110
108328: PUSH
108329: LD_INT 111
108331: PUSH
108332: LD_INT 112
108334: PUSH
108335: LD_INT 114
108337: PUSH
108338: LD_INT 116
108340: PUSH
108341: LD_INT 117
108343: PUSH
108344: LD_INT 118
108346: PUSH
108347: EMPTY
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: LIST
108353: LIST
108354: LIST
108355: LIST
108356: LIST
108357: LIST
108358: LIST
108359: LIST
108360: LIST
108361: LIST
108362: LIST
108363: LIST
108364: PUSH
108365: EMPTY
108366: LIST
108367: LIST
108368: ST_TO_ADDR
108369: GO 110264
108371: LD_INT 11
108373: DOUBLE
108374: EQUAL
108375: IFTRUE 108379
108377: GO 108583
108379: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
108380: LD_ADDR_VAR 0 1
108384: PUSH
108385: LD_INT 2
108387: PUSH
108388: LD_INT 3
108390: PUSH
108391: LD_INT 4
108393: PUSH
108394: LD_INT 5
108396: PUSH
108397: LD_INT 6
108399: PUSH
108400: LD_INT 7
108402: PUSH
108403: LD_INT 8
108405: PUSH
108406: LD_INT 9
108408: PUSH
108409: LD_INT 10
108411: PUSH
108412: LD_INT 11
108414: PUSH
108415: LD_INT 12
108417: PUSH
108418: LD_INT 13
108420: PUSH
108421: LD_INT 14
108423: PUSH
108424: LD_INT 15
108426: PUSH
108427: LD_INT 16
108429: PUSH
108430: LD_INT 17
108432: PUSH
108433: LD_INT 18
108435: PUSH
108436: LD_INT 19
108438: PUSH
108439: LD_INT 20
108441: PUSH
108442: LD_INT 21
108444: PUSH
108445: LD_INT 22
108447: PUSH
108448: LD_INT 23
108450: PUSH
108451: LD_INT 24
108453: PUSH
108454: LD_INT 25
108456: PUSH
108457: LD_INT 26
108459: PUSH
108460: LD_INT 28
108462: PUSH
108463: LD_INT 30
108465: PUSH
108466: LD_INT 31
108468: PUSH
108469: LD_INT 32
108471: PUSH
108472: LD_INT 34
108474: PUSH
108475: LD_INT 36
108477: PUSH
108478: EMPTY
108479: LIST
108480: LIST
108481: LIST
108482: LIST
108483: LIST
108484: LIST
108485: LIST
108486: LIST
108487: LIST
108488: LIST
108489: LIST
108490: LIST
108491: LIST
108492: LIST
108493: LIST
108494: LIST
108495: LIST
108496: LIST
108497: LIST
108498: LIST
108499: LIST
108500: LIST
108501: LIST
108502: LIST
108503: LIST
108504: LIST
108505: LIST
108506: LIST
108507: LIST
108508: LIST
108509: LIST
108510: PUSH
108511: LD_INT 101
108513: PUSH
108514: LD_INT 102
108516: PUSH
108517: LD_INT 103
108519: PUSH
108520: LD_INT 104
108522: PUSH
108523: LD_INT 105
108525: PUSH
108526: LD_INT 106
108528: PUSH
108529: LD_INT 107
108531: PUSH
108532: LD_INT 108
108534: PUSH
108535: LD_INT 109
108537: PUSH
108538: LD_INT 110
108540: PUSH
108541: LD_INT 111
108543: PUSH
108544: LD_INT 112
108546: PUSH
108547: LD_INT 114
108549: PUSH
108550: LD_INT 116
108552: PUSH
108553: LD_INT 117
108555: PUSH
108556: LD_INT 118
108558: PUSH
108559: EMPTY
108560: LIST
108561: LIST
108562: LIST
108563: LIST
108564: LIST
108565: LIST
108566: LIST
108567: LIST
108568: LIST
108569: LIST
108570: LIST
108571: LIST
108572: LIST
108573: LIST
108574: LIST
108575: LIST
108576: PUSH
108577: EMPTY
108578: LIST
108579: LIST
108580: ST_TO_ADDR
108581: GO 110264
108583: LD_INT 12
108585: DOUBLE
108586: EQUAL
108587: IFTRUE 108591
108589: GO 108811
108591: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
108592: LD_ADDR_VAR 0 1
108596: PUSH
108597: LD_INT 1
108599: PUSH
108600: LD_INT 2
108602: PUSH
108603: LD_INT 3
108605: PUSH
108606: LD_INT 4
108608: PUSH
108609: LD_INT 5
108611: PUSH
108612: LD_INT 6
108614: PUSH
108615: LD_INT 7
108617: PUSH
108618: LD_INT 8
108620: PUSH
108621: LD_INT 9
108623: PUSH
108624: LD_INT 10
108626: PUSH
108627: LD_INT 11
108629: PUSH
108630: LD_INT 12
108632: PUSH
108633: LD_INT 13
108635: PUSH
108636: LD_INT 14
108638: PUSH
108639: LD_INT 15
108641: PUSH
108642: LD_INT 16
108644: PUSH
108645: LD_INT 17
108647: PUSH
108648: LD_INT 18
108650: PUSH
108651: LD_INT 19
108653: PUSH
108654: LD_INT 20
108656: PUSH
108657: LD_INT 21
108659: PUSH
108660: LD_INT 22
108662: PUSH
108663: LD_INT 23
108665: PUSH
108666: LD_INT 24
108668: PUSH
108669: LD_INT 25
108671: PUSH
108672: LD_INT 26
108674: PUSH
108675: LD_INT 27
108677: PUSH
108678: LD_INT 28
108680: PUSH
108681: LD_INT 30
108683: PUSH
108684: LD_INT 31
108686: PUSH
108687: LD_INT 32
108689: PUSH
108690: LD_INT 33
108692: PUSH
108693: LD_INT 34
108695: PUSH
108696: LD_INT 36
108698: PUSH
108699: EMPTY
108700: LIST
108701: LIST
108702: LIST
108703: LIST
108704: LIST
108705: LIST
108706: LIST
108707: LIST
108708: LIST
108709: LIST
108710: LIST
108711: LIST
108712: LIST
108713: LIST
108714: LIST
108715: LIST
108716: LIST
108717: LIST
108718: LIST
108719: LIST
108720: LIST
108721: LIST
108722: LIST
108723: LIST
108724: LIST
108725: LIST
108726: LIST
108727: LIST
108728: LIST
108729: LIST
108730: LIST
108731: LIST
108732: LIST
108733: LIST
108734: PUSH
108735: LD_INT 101
108737: PUSH
108738: LD_INT 102
108740: PUSH
108741: LD_INT 103
108743: PUSH
108744: LD_INT 104
108746: PUSH
108747: LD_INT 105
108749: PUSH
108750: LD_INT 106
108752: PUSH
108753: LD_INT 107
108755: PUSH
108756: LD_INT 108
108758: PUSH
108759: LD_INT 109
108761: PUSH
108762: LD_INT 110
108764: PUSH
108765: LD_INT 111
108767: PUSH
108768: LD_INT 112
108770: PUSH
108771: LD_INT 113
108773: PUSH
108774: LD_INT 114
108776: PUSH
108777: LD_INT 116
108779: PUSH
108780: LD_INT 117
108782: PUSH
108783: LD_INT 118
108785: PUSH
108786: EMPTY
108787: LIST
108788: LIST
108789: LIST
108790: LIST
108791: LIST
108792: LIST
108793: LIST
108794: LIST
108795: LIST
108796: LIST
108797: LIST
108798: LIST
108799: LIST
108800: LIST
108801: LIST
108802: LIST
108803: LIST
108804: PUSH
108805: EMPTY
108806: LIST
108807: LIST
108808: ST_TO_ADDR
108809: GO 110264
108811: LD_INT 13
108813: DOUBLE
108814: EQUAL
108815: IFTRUE 108819
108817: GO 109027
108819: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
108820: LD_ADDR_VAR 0 1
108824: PUSH
108825: LD_INT 1
108827: PUSH
108828: LD_INT 2
108830: PUSH
108831: LD_INT 3
108833: PUSH
108834: LD_INT 4
108836: PUSH
108837: LD_INT 5
108839: PUSH
108840: LD_INT 8
108842: PUSH
108843: LD_INT 9
108845: PUSH
108846: LD_INT 10
108848: PUSH
108849: LD_INT 11
108851: PUSH
108852: LD_INT 12
108854: PUSH
108855: LD_INT 14
108857: PUSH
108858: LD_INT 15
108860: PUSH
108861: LD_INT 16
108863: PUSH
108864: LD_INT 17
108866: PUSH
108867: LD_INT 18
108869: PUSH
108870: LD_INT 19
108872: PUSH
108873: LD_INT 20
108875: PUSH
108876: LD_INT 21
108878: PUSH
108879: LD_INT 22
108881: PUSH
108882: LD_INT 23
108884: PUSH
108885: LD_INT 24
108887: PUSH
108888: LD_INT 25
108890: PUSH
108891: LD_INT 26
108893: PUSH
108894: LD_INT 27
108896: PUSH
108897: LD_INT 28
108899: PUSH
108900: LD_INT 30
108902: PUSH
108903: LD_INT 31
108905: PUSH
108906: LD_INT 32
108908: PUSH
108909: LD_INT 33
108911: PUSH
108912: LD_INT 34
108914: PUSH
108915: LD_INT 36
108917: PUSH
108918: EMPTY
108919: LIST
108920: LIST
108921: LIST
108922: LIST
108923: LIST
108924: LIST
108925: LIST
108926: LIST
108927: LIST
108928: LIST
108929: LIST
108930: LIST
108931: LIST
108932: LIST
108933: LIST
108934: LIST
108935: LIST
108936: LIST
108937: LIST
108938: LIST
108939: LIST
108940: LIST
108941: LIST
108942: LIST
108943: LIST
108944: LIST
108945: LIST
108946: LIST
108947: LIST
108948: LIST
108949: LIST
108950: PUSH
108951: LD_INT 101
108953: PUSH
108954: LD_INT 102
108956: PUSH
108957: LD_INT 103
108959: PUSH
108960: LD_INT 104
108962: PUSH
108963: LD_INT 105
108965: PUSH
108966: LD_INT 106
108968: PUSH
108969: LD_INT 107
108971: PUSH
108972: LD_INT 108
108974: PUSH
108975: LD_INT 109
108977: PUSH
108978: LD_INT 110
108980: PUSH
108981: LD_INT 111
108983: PUSH
108984: LD_INT 112
108986: PUSH
108987: LD_INT 113
108989: PUSH
108990: LD_INT 114
108992: PUSH
108993: LD_INT 116
108995: PUSH
108996: LD_INT 117
108998: PUSH
108999: LD_INT 118
109001: PUSH
109002: EMPTY
109003: LIST
109004: LIST
109005: LIST
109006: LIST
109007: LIST
109008: LIST
109009: LIST
109010: LIST
109011: LIST
109012: LIST
109013: LIST
109014: LIST
109015: LIST
109016: LIST
109017: LIST
109018: LIST
109019: LIST
109020: PUSH
109021: EMPTY
109022: LIST
109023: LIST
109024: ST_TO_ADDR
109025: GO 110264
109027: LD_INT 14
109029: DOUBLE
109030: EQUAL
109031: IFTRUE 109035
109033: GO 109259
109035: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
109036: LD_ADDR_VAR 0 1
109040: PUSH
109041: LD_INT 1
109043: PUSH
109044: LD_INT 2
109046: PUSH
109047: LD_INT 3
109049: PUSH
109050: LD_INT 4
109052: PUSH
109053: LD_INT 5
109055: PUSH
109056: LD_INT 6
109058: PUSH
109059: LD_INT 7
109061: PUSH
109062: LD_INT 8
109064: PUSH
109065: LD_INT 9
109067: PUSH
109068: LD_INT 10
109070: PUSH
109071: LD_INT 11
109073: PUSH
109074: LD_INT 12
109076: PUSH
109077: LD_INT 13
109079: PUSH
109080: LD_INT 14
109082: PUSH
109083: LD_INT 15
109085: PUSH
109086: LD_INT 16
109088: PUSH
109089: LD_INT 17
109091: PUSH
109092: LD_INT 18
109094: PUSH
109095: LD_INT 19
109097: PUSH
109098: LD_INT 20
109100: PUSH
109101: LD_INT 21
109103: PUSH
109104: LD_INT 22
109106: PUSH
109107: LD_INT 23
109109: PUSH
109110: LD_INT 24
109112: PUSH
109113: LD_INT 25
109115: PUSH
109116: LD_INT 26
109118: PUSH
109119: LD_INT 27
109121: PUSH
109122: LD_INT 28
109124: PUSH
109125: LD_INT 29
109127: PUSH
109128: LD_INT 30
109130: PUSH
109131: LD_INT 31
109133: PUSH
109134: LD_INT 32
109136: PUSH
109137: LD_INT 33
109139: PUSH
109140: LD_INT 34
109142: PUSH
109143: LD_INT 36
109145: PUSH
109146: EMPTY
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: LIST
109161: LIST
109162: LIST
109163: LIST
109164: LIST
109165: LIST
109166: LIST
109167: LIST
109168: LIST
109169: LIST
109170: LIST
109171: LIST
109172: LIST
109173: LIST
109174: LIST
109175: LIST
109176: LIST
109177: LIST
109178: LIST
109179: LIST
109180: LIST
109181: LIST
109182: PUSH
109183: LD_INT 101
109185: PUSH
109186: LD_INT 102
109188: PUSH
109189: LD_INT 103
109191: PUSH
109192: LD_INT 104
109194: PUSH
109195: LD_INT 105
109197: PUSH
109198: LD_INT 106
109200: PUSH
109201: LD_INT 107
109203: PUSH
109204: LD_INT 108
109206: PUSH
109207: LD_INT 109
109209: PUSH
109210: LD_INT 110
109212: PUSH
109213: LD_INT 111
109215: PUSH
109216: LD_INT 112
109218: PUSH
109219: LD_INT 113
109221: PUSH
109222: LD_INT 114
109224: PUSH
109225: LD_INT 116
109227: PUSH
109228: LD_INT 117
109230: PUSH
109231: LD_INT 118
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: LIST
109240: LIST
109241: LIST
109242: LIST
109243: LIST
109244: LIST
109245: LIST
109246: LIST
109247: LIST
109248: LIST
109249: LIST
109250: LIST
109251: LIST
109252: PUSH
109253: EMPTY
109254: LIST
109255: LIST
109256: ST_TO_ADDR
109257: GO 110264
109259: LD_INT 15
109261: DOUBLE
109262: EQUAL
109263: IFTRUE 109267
109265: GO 109491
109267: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
109268: LD_ADDR_VAR 0 1
109272: PUSH
109273: LD_INT 1
109275: PUSH
109276: LD_INT 2
109278: PUSH
109279: LD_INT 3
109281: PUSH
109282: LD_INT 4
109284: PUSH
109285: LD_INT 5
109287: PUSH
109288: LD_INT 6
109290: PUSH
109291: LD_INT 7
109293: PUSH
109294: LD_INT 8
109296: PUSH
109297: LD_INT 9
109299: PUSH
109300: LD_INT 10
109302: PUSH
109303: LD_INT 11
109305: PUSH
109306: LD_INT 12
109308: PUSH
109309: LD_INT 13
109311: PUSH
109312: LD_INT 14
109314: PUSH
109315: LD_INT 15
109317: PUSH
109318: LD_INT 16
109320: PUSH
109321: LD_INT 17
109323: PUSH
109324: LD_INT 18
109326: PUSH
109327: LD_INT 19
109329: PUSH
109330: LD_INT 20
109332: PUSH
109333: LD_INT 21
109335: PUSH
109336: LD_INT 22
109338: PUSH
109339: LD_INT 23
109341: PUSH
109342: LD_INT 24
109344: PUSH
109345: LD_INT 25
109347: PUSH
109348: LD_INT 26
109350: PUSH
109351: LD_INT 27
109353: PUSH
109354: LD_INT 28
109356: PUSH
109357: LD_INT 29
109359: PUSH
109360: LD_INT 30
109362: PUSH
109363: LD_INT 31
109365: PUSH
109366: LD_INT 32
109368: PUSH
109369: LD_INT 33
109371: PUSH
109372: LD_INT 34
109374: PUSH
109375: LD_INT 36
109377: PUSH
109378: EMPTY
109379: LIST
109380: LIST
109381: LIST
109382: LIST
109383: LIST
109384: LIST
109385: LIST
109386: LIST
109387: LIST
109388: LIST
109389: LIST
109390: LIST
109391: LIST
109392: LIST
109393: LIST
109394: LIST
109395: LIST
109396: LIST
109397: LIST
109398: LIST
109399: LIST
109400: LIST
109401: LIST
109402: LIST
109403: LIST
109404: LIST
109405: LIST
109406: LIST
109407: LIST
109408: LIST
109409: LIST
109410: LIST
109411: LIST
109412: LIST
109413: LIST
109414: PUSH
109415: LD_INT 101
109417: PUSH
109418: LD_INT 102
109420: PUSH
109421: LD_INT 103
109423: PUSH
109424: LD_INT 104
109426: PUSH
109427: LD_INT 105
109429: PUSH
109430: LD_INT 106
109432: PUSH
109433: LD_INT 107
109435: PUSH
109436: LD_INT 108
109438: PUSH
109439: LD_INT 109
109441: PUSH
109442: LD_INT 110
109444: PUSH
109445: LD_INT 111
109447: PUSH
109448: LD_INT 112
109450: PUSH
109451: LD_INT 113
109453: PUSH
109454: LD_INT 114
109456: PUSH
109457: LD_INT 116
109459: PUSH
109460: LD_INT 117
109462: PUSH
109463: LD_INT 118
109465: PUSH
109466: EMPTY
109467: LIST
109468: LIST
109469: LIST
109470: LIST
109471: LIST
109472: LIST
109473: LIST
109474: LIST
109475: LIST
109476: LIST
109477: LIST
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: PUSH
109485: EMPTY
109486: LIST
109487: LIST
109488: ST_TO_ADDR
109489: GO 110264
109491: LD_INT 16
109493: DOUBLE
109494: EQUAL
109495: IFTRUE 109499
109497: GO 109635
109499: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
109500: LD_ADDR_VAR 0 1
109504: PUSH
109505: LD_INT 2
109507: PUSH
109508: LD_INT 4
109510: PUSH
109511: LD_INT 5
109513: PUSH
109514: LD_INT 7
109516: PUSH
109517: LD_INT 11
109519: PUSH
109520: LD_INT 12
109522: PUSH
109523: LD_INT 15
109525: PUSH
109526: LD_INT 16
109528: PUSH
109529: LD_INT 20
109531: PUSH
109532: LD_INT 21
109534: PUSH
109535: LD_INT 22
109537: PUSH
109538: LD_INT 23
109540: PUSH
109541: LD_INT 25
109543: PUSH
109544: LD_INT 26
109546: PUSH
109547: LD_INT 30
109549: PUSH
109550: LD_INT 31
109552: PUSH
109553: LD_INT 32
109555: PUSH
109556: LD_INT 33
109558: PUSH
109559: LD_INT 34
109561: PUSH
109562: EMPTY
109563: LIST
109564: LIST
109565: LIST
109566: LIST
109567: LIST
109568: LIST
109569: LIST
109570: LIST
109571: LIST
109572: LIST
109573: LIST
109574: LIST
109575: LIST
109576: LIST
109577: LIST
109578: LIST
109579: LIST
109580: LIST
109581: LIST
109582: PUSH
109583: LD_INT 101
109585: PUSH
109586: LD_INT 102
109588: PUSH
109589: LD_INT 103
109591: PUSH
109592: LD_INT 106
109594: PUSH
109595: LD_INT 108
109597: PUSH
109598: LD_INT 112
109600: PUSH
109601: LD_INT 113
109603: PUSH
109604: LD_INT 114
109606: PUSH
109607: LD_INT 116
109609: PUSH
109610: LD_INT 117
109612: PUSH
109613: LD_INT 118
109615: PUSH
109616: EMPTY
109617: LIST
109618: LIST
109619: LIST
109620: LIST
109621: LIST
109622: LIST
109623: LIST
109624: LIST
109625: LIST
109626: LIST
109627: LIST
109628: PUSH
109629: EMPTY
109630: LIST
109631: LIST
109632: ST_TO_ADDR
109633: GO 110264
109635: LD_INT 17
109637: DOUBLE
109638: EQUAL
109639: IFTRUE 109643
109641: GO 109867
109643: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
109644: LD_ADDR_VAR 0 1
109648: PUSH
109649: LD_INT 1
109651: PUSH
109652: LD_INT 2
109654: PUSH
109655: LD_INT 3
109657: PUSH
109658: LD_INT 4
109660: PUSH
109661: LD_INT 5
109663: PUSH
109664: LD_INT 6
109666: PUSH
109667: LD_INT 7
109669: PUSH
109670: LD_INT 8
109672: PUSH
109673: LD_INT 9
109675: PUSH
109676: LD_INT 10
109678: PUSH
109679: LD_INT 11
109681: PUSH
109682: LD_INT 12
109684: PUSH
109685: LD_INT 13
109687: PUSH
109688: LD_INT 14
109690: PUSH
109691: LD_INT 15
109693: PUSH
109694: LD_INT 16
109696: PUSH
109697: LD_INT 17
109699: PUSH
109700: LD_INT 18
109702: PUSH
109703: LD_INT 19
109705: PUSH
109706: LD_INT 20
109708: PUSH
109709: LD_INT 21
109711: PUSH
109712: LD_INT 22
109714: PUSH
109715: LD_INT 23
109717: PUSH
109718: LD_INT 24
109720: PUSH
109721: LD_INT 25
109723: PUSH
109724: LD_INT 26
109726: PUSH
109727: LD_INT 27
109729: PUSH
109730: LD_INT 28
109732: PUSH
109733: LD_INT 29
109735: PUSH
109736: LD_INT 30
109738: PUSH
109739: LD_INT 31
109741: PUSH
109742: LD_INT 32
109744: PUSH
109745: LD_INT 33
109747: PUSH
109748: LD_INT 34
109750: PUSH
109751: LD_INT 36
109753: PUSH
109754: EMPTY
109755: LIST
109756: LIST
109757: LIST
109758: LIST
109759: LIST
109760: LIST
109761: LIST
109762: LIST
109763: LIST
109764: LIST
109765: LIST
109766: LIST
109767: LIST
109768: LIST
109769: LIST
109770: LIST
109771: LIST
109772: LIST
109773: LIST
109774: LIST
109775: LIST
109776: LIST
109777: LIST
109778: LIST
109779: LIST
109780: LIST
109781: LIST
109782: LIST
109783: LIST
109784: LIST
109785: LIST
109786: LIST
109787: LIST
109788: LIST
109789: LIST
109790: PUSH
109791: LD_INT 101
109793: PUSH
109794: LD_INT 102
109796: PUSH
109797: LD_INT 103
109799: PUSH
109800: LD_INT 104
109802: PUSH
109803: LD_INT 105
109805: PUSH
109806: LD_INT 106
109808: PUSH
109809: LD_INT 107
109811: PUSH
109812: LD_INT 108
109814: PUSH
109815: LD_INT 109
109817: PUSH
109818: LD_INT 110
109820: PUSH
109821: LD_INT 111
109823: PUSH
109824: LD_INT 112
109826: PUSH
109827: LD_INT 113
109829: PUSH
109830: LD_INT 114
109832: PUSH
109833: LD_INT 116
109835: PUSH
109836: LD_INT 117
109838: PUSH
109839: LD_INT 118
109841: PUSH
109842: EMPTY
109843: LIST
109844: LIST
109845: LIST
109846: LIST
109847: LIST
109848: LIST
109849: LIST
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: LIST
109856: LIST
109857: LIST
109858: LIST
109859: LIST
109860: PUSH
109861: EMPTY
109862: LIST
109863: LIST
109864: ST_TO_ADDR
109865: GO 110264
109867: LD_INT 18
109869: DOUBLE
109870: EQUAL
109871: IFTRUE 109875
109873: GO 110023
109875: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
109876: LD_ADDR_VAR 0 1
109880: PUSH
109881: LD_INT 2
109883: PUSH
109884: LD_INT 4
109886: PUSH
109887: LD_INT 5
109889: PUSH
109890: LD_INT 7
109892: PUSH
109893: LD_INT 11
109895: PUSH
109896: LD_INT 12
109898: PUSH
109899: LD_INT 15
109901: PUSH
109902: LD_INT 16
109904: PUSH
109905: LD_INT 20
109907: PUSH
109908: LD_INT 21
109910: PUSH
109911: LD_INT 22
109913: PUSH
109914: LD_INT 23
109916: PUSH
109917: LD_INT 25
109919: PUSH
109920: LD_INT 26
109922: PUSH
109923: LD_INT 30
109925: PUSH
109926: LD_INT 31
109928: PUSH
109929: LD_INT 32
109931: PUSH
109932: LD_INT 33
109934: PUSH
109935: LD_INT 34
109937: PUSH
109938: LD_INT 35
109940: PUSH
109941: LD_INT 36
109943: PUSH
109944: EMPTY
109945: LIST
109946: LIST
109947: LIST
109948: LIST
109949: LIST
109950: LIST
109951: LIST
109952: LIST
109953: LIST
109954: LIST
109955: LIST
109956: LIST
109957: LIST
109958: LIST
109959: LIST
109960: LIST
109961: LIST
109962: LIST
109963: LIST
109964: LIST
109965: LIST
109966: PUSH
109967: LD_INT 101
109969: PUSH
109970: LD_INT 102
109972: PUSH
109973: LD_INT 103
109975: PUSH
109976: LD_INT 106
109978: PUSH
109979: LD_INT 108
109981: PUSH
109982: LD_INT 112
109984: PUSH
109985: LD_INT 113
109987: PUSH
109988: LD_INT 114
109990: PUSH
109991: LD_INT 115
109993: PUSH
109994: LD_INT 116
109996: PUSH
109997: LD_INT 117
109999: PUSH
110000: LD_INT 118
110002: PUSH
110003: EMPTY
110004: LIST
110005: LIST
110006: LIST
110007: LIST
110008: LIST
110009: LIST
110010: LIST
110011: LIST
110012: LIST
110013: LIST
110014: LIST
110015: LIST
110016: PUSH
110017: EMPTY
110018: LIST
110019: LIST
110020: ST_TO_ADDR
110021: GO 110264
110023: LD_INT 19
110025: DOUBLE
110026: EQUAL
110027: IFTRUE 110031
110029: GO 110263
110031: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
110032: LD_ADDR_VAR 0 1
110036: PUSH
110037: LD_INT 1
110039: PUSH
110040: LD_INT 2
110042: PUSH
110043: LD_INT 3
110045: PUSH
110046: LD_INT 4
110048: PUSH
110049: LD_INT 5
110051: PUSH
110052: LD_INT 6
110054: PUSH
110055: LD_INT 7
110057: PUSH
110058: LD_INT 8
110060: PUSH
110061: LD_INT 9
110063: PUSH
110064: LD_INT 10
110066: PUSH
110067: LD_INT 11
110069: PUSH
110070: LD_INT 12
110072: PUSH
110073: LD_INT 13
110075: PUSH
110076: LD_INT 14
110078: PUSH
110079: LD_INT 15
110081: PUSH
110082: LD_INT 16
110084: PUSH
110085: LD_INT 17
110087: PUSH
110088: LD_INT 18
110090: PUSH
110091: LD_INT 19
110093: PUSH
110094: LD_INT 20
110096: PUSH
110097: LD_INT 21
110099: PUSH
110100: LD_INT 22
110102: PUSH
110103: LD_INT 23
110105: PUSH
110106: LD_INT 24
110108: PUSH
110109: LD_INT 25
110111: PUSH
110112: LD_INT 26
110114: PUSH
110115: LD_INT 27
110117: PUSH
110118: LD_INT 28
110120: PUSH
110121: LD_INT 29
110123: PUSH
110124: LD_INT 30
110126: PUSH
110127: LD_INT 31
110129: PUSH
110130: LD_INT 32
110132: PUSH
110133: LD_INT 33
110135: PUSH
110136: LD_INT 34
110138: PUSH
110139: LD_INT 35
110141: PUSH
110142: LD_INT 36
110144: PUSH
110145: EMPTY
110146: LIST
110147: LIST
110148: LIST
110149: LIST
110150: LIST
110151: LIST
110152: LIST
110153: LIST
110154: LIST
110155: LIST
110156: LIST
110157: LIST
110158: LIST
110159: LIST
110160: LIST
110161: LIST
110162: LIST
110163: LIST
110164: LIST
110165: LIST
110166: LIST
110167: LIST
110168: LIST
110169: LIST
110170: LIST
110171: LIST
110172: LIST
110173: LIST
110174: LIST
110175: LIST
110176: LIST
110177: LIST
110178: LIST
110179: LIST
110180: LIST
110181: LIST
110182: PUSH
110183: LD_INT 101
110185: PUSH
110186: LD_INT 102
110188: PUSH
110189: LD_INT 103
110191: PUSH
110192: LD_INT 104
110194: PUSH
110195: LD_INT 105
110197: PUSH
110198: LD_INT 106
110200: PUSH
110201: LD_INT 107
110203: PUSH
110204: LD_INT 108
110206: PUSH
110207: LD_INT 109
110209: PUSH
110210: LD_INT 110
110212: PUSH
110213: LD_INT 111
110215: PUSH
110216: LD_INT 112
110218: PUSH
110219: LD_INT 113
110221: PUSH
110222: LD_INT 114
110224: PUSH
110225: LD_INT 115
110227: PUSH
110228: LD_INT 116
110230: PUSH
110231: LD_INT 117
110233: PUSH
110234: LD_INT 118
110236: PUSH
110237: EMPTY
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: LIST
110254: LIST
110255: LIST
110256: PUSH
110257: EMPTY
110258: LIST
110259: LIST
110260: ST_TO_ADDR
110261: GO 110264
110263: POP
// end else
110264: GO 110495
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
110266: LD_ADDR_VAR 0 1
110270: PUSH
110271: LD_INT 1
110273: PUSH
110274: LD_INT 2
110276: PUSH
110277: LD_INT 3
110279: PUSH
110280: LD_INT 4
110282: PUSH
110283: LD_INT 5
110285: PUSH
110286: LD_INT 6
110288: PUSH
110289: LD_INT 7
110291: PUSH
110292: LD_INT 8
110294: PUSH
110295: LD_INT 9
110297: PUSH
110298: LD_INT 10
110300: PUSH
110301: LD_INT 11
110303: PUSH
110304: LD_INT 12
110306: PUSH
110307: LD_INT 13
110309: PUSH
110310: LD_INT 14
110312: PUSH
110313: LD_INT 15
110315: PUSH
110316: LD_INT 16
110318: PUSH
110319: LD_INT 17
110321: PUSH
110322: LD_INT 18
110324: PUSH
110325: LD_INT 19
110327: PUSH
110328: LD_INT 20
110330: PUSH
110331: LD_INT 21
110333: PUSH
110334: LD_INT 22
110336: PUSH
110337: LD_INT 23
110339: PUSH
110340: LD_INT 24
110342: PUSH
110343: LD_INT 25
110345: PUSH
110346: LD_INT 26
110348: PUSH
110349: LD_INT 27
110351: PUSH
110352: LD_INT 28
110354: PUSH
110355: LD_INT 29
110357: PUSH
110358: LD_INT 30
110360: PUSH
110361: LD_INT 31
110363: PUSH
110364: LD_INT 32
110366: PUSH
110367: LD_INT 33
110369: PUSH
110370: LD_INT 34
110372: PUSH
110373: LD_INT 35
110375: PUSH
110376: LD_INT 36
110378: PUSH
110379: EMPTY
110380: LIST
110381: LIST
110382: LIST
110383: LIST
110384: LIST
110385: LIST
110386: LIST
110387: LIST
110388: LIST
110389: LIST
110390: LIST
110391: LIST
110392: LIST
110393: LIST
110394: LIST
110395: LIST
110396: LIST
110397: LIST
110398: LIST
110399: LIST
110400: LIST
110401: LIST
110402: LIST
110403: LIST
110404: LIST
110405: LIST
110406: LIST
110407: LIST
110408: LIST
110409: LIST
110410: LIST
110411: LIST
110412: LIST
110413: LIST
110414: LIST
110415: LIST
110416: PUSH
110417: LD_INT 101
110419: PUSH
110420: LD_INT 102
110422: PUSH
110423: LD_INT 103
110425: PUSH
110426: LD_INT 104
110428: PUSH
110429: LD_INT 105
110431: PUSH
110432: LD_INT 106
110434: PUSH
110435: LD_INT 107
110437: PUSH
110438: LD_INT 108
110440: PUSH
110441: LD_INT 109
110443: PUSH
110444: LD_INT 110
110446: PUSH
110447: LD_INT 111
110449: PUSH
110450: LD_INT 112
110452: PUSH
110453: LD_INT 113
110455: PUSH
110456: LD_INT 114
110458: PUSH
110459: LD_INT 115
110461: PUSH
110462: LD_INT 116
110464: PUSH
110465: LD_INT 117
110467: PUSH
110468: LD_INT 118
110470: PUSH
110471: EMPTY
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: LIST
110477: LIST
110478: LIST
110479: LIST
110480: LIST
110481: LIST
110482: LIST
110483: LIST
110484: LIST
110485: LIST
110486: LIST
110487: LIST
110488: LIST
110489: LIST
110490: PUSH
110491: EMPTY
110492: LIST
110493: LIST
110494: ST_TO_ADDR
// if result then
110495: LD_VAR 0 1
110499: IFFALSE 110788
// begin normal :=  ;
110501: LD_ADDR_VAR 0 3
110505: PUSH
110506: LD_STRING 
110508: ST_TO_ADDR
// hardcore :=  ;
110509: LD_ADDR_VAR 0 4
110513: PUSH
110514: LD_STRING 
110516: ST_TO_ADDR
// for i = 1 to normalCounter do
110517: LD_ADDR_VAR 0 5
110521: PUSH
110522: DOUBLE
110523: LD_INT 1
110525: DEC
110526: ST_TO_ADDR
110527: LD_EXP 161
110531: PUSH
110532: FOR_TO
110533: IFFALSE 110634
// begin tmp := 0 ;
110535: LD_ADDR_VAR 0 2
110539: PUSH
110540: LD_STRING 0
110542: ST_TO_ADDR
// if result [ 1 ] then
110543: LD_VAR 0 1
110547: PUSH
110548: LD_INT 1
110550: ARRAY
110551: IFFALSE 110616
// if result [ 1 ] [ 1 ] = i then
110553: LD_VAR 0 1
110557: PUSH
110558: LD_INT 1
110560: ARRAY
110561: PUSH
110562: LD_INT 1
110564: ARRAY
110565: PUSH
110566: LD_VAR 0 5
110570: EQUAL
110571: IFFALSE 110616
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
110573: LD_ADDR_VAR 0 1
110577: PUSH
110578: LD_VAR 0 1
110582: PPUSH
110583: LD_INT 1
110585: PPUSH
110586: LD_VAR 0 1
110590: PUSH
110591: LD_INT 1
110593: ARRAY
110594: PPUSH
110595: LD_INT 1
110597: PPUSH
110598: CALL_OW 3
110602: PPUSH
110603: CALL_OW 1
110607: ST_TO_ADDR
// tmp := 1 ;
110608: LD_ADDR_VAR 0 2
110612: PUSH
110613: LD_STRING 1
110615: ST_TO_ADDR
// end ; normal := normal & tmp ;
110616: LD_ADDR_VAR 0 3
110620: PUSH
110621: LD_VAR 0 3
110625: PUSH
110626: LD_VAR 0 2
110630: STR
110631: ST_TO_ADDR
// end ;
110632: GO 110532
110634: POP
110635: POP
// for i = 1 to hardcoreCounter do
110636: LD_ADDR_VAR 0 5
110640: PUSH
110641: DOUBLE
110642: LD_INT 1
110644: DEC
110645: ST_TO_ADDR
110646: LD_EXP 162
110650: PUSH
110651: FOR_TO
110652: IFFALSE 110757
// begin tmp := 0 ;
110654: LD_ADDR_VAR 0 2
110658: PUSH
110659: LD_STRING 0
110661: ST_TO_ADDR
// if result [ 2 ] then
110662: LD_VAR 0 1
110666: PUSH
110667: LD_INT 2
110669: ARRAY
110670: IFFALSE 110739
// if result [ 2 ] [ 1 ] = 100 + i then
110672: LD_VAR 0 1
110676: PUSH
110677: LD_INT 2
110679: ARRAY
110680: PUSH
110681: LD_INT 1
110683: ARRAY
110684: PUSH
110685: LD_INT 100
110687: PUSH
110688: LD_VAR 0 5
110692: PLUS
110693: EQUAL
110694: IFFALSE 110739
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
110696: LD_ADDR_VAR 0 1
110700: PUSH
110701: LD_VAR 0 1
110705: PPUSH
110706: LD_INT 2
110708: PPUSH
110709: LD_VAR 0 1
110713: PUSH
110714: LD_INT 2
110716: ARRAY
110717: PPUSH
110718: LD_INT 1
110720: PPUSH
110721: CALL_OW 3
110725: PPUSH
110726: CALL_OW 1
110730: ST_TO_ADDR
// tmp := 1 ;
110731: LD_ADDR_VAR 0 2
110735: PUSH
110736: LD_STRING 1
110738: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
110739: LD_ADDR_VAR 0 4
110743: PUSH
110744: LD_VAR 0 4
110748: PUSH
110749: LD_VAR 0 2
110753: STR
110754: ST_TO_ADDR
// end ;
110755: GO 110651
110757: POP
110758: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
110759: LD_STRING getStreamItemsFromMission("
110761: PUSH
110762: LD_VAR 0 3
110766: STR
110767: PUSH
110768: LD_STRING ","
110770: STR
110771: PUSH
110772: LD_VAR 0 4
110776: STR
110777: PUSH
110778: LD_STRING ")
110780: STR
110781: PPUSH
110782: CALL_OW 559
// end else
110786: GO 110795
// ToLua ( getStreamItemsFromMission("","") ) ;
110788: LD_STRING getStreamItemsFromMission("","")
110790: PPUSH
110791: CALL_OW 559
// end ;
110795: LD_VAR 0 1
110799: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
110800: LD_EXP 160
110804: PUSH
110805: LD_EXP 165
110809: AND
110810: IFFALSE 110934
110812: GO 110814
110814: DISABLE
110815: LD_INT 0
110817: PPUSH
110818: PPUSH
// begin enable ;
110819: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
110820: LD_ADDR_VAR 0 2
110824: PUSH
110825: LD_INT 22
110827: PUSH
110828: LD_OWVAR 2
110832: PUSH
110833: EMPTY
110834: LIST
110835: LIST
110836: PUSH
110837: LD_INT 2
110839: PUSH
110840: LD_INT 34
110842: PUSH
110843: LD_INT 7
110845: PUSH
110846: EMPTY
110847: LIST
110848: LIST
110849: PUSH
110850: LD_INT 34
110852: PUSH
110853: LD_INT 45
110855: PUSH
110856: EMPTY
110857: LIST
110858: LIST
110859: PUSH
110860: LD_INT 34
110862: PUSH
110863: LD_INT 28
110865: PUSH
110866: EMPTY
110867: LIST
110868: LIST
110869: PUSH
110870: LD_INT 34
110872: PUSH
110873: LD_INT 47
110875: PUSH
110876: EMPTY
110877: LIST
110878: LIST
110879: PUSH
110880: EMPTY
110881: LIST
110882: LIST
110883: LIST
110884: LIST
110885: LIST
110886: PUSH
110887: EMPTY
110888: LIST
110889: LIST
110890: PPUSH
110891: CALL_OW 69
110895: ST_TO_ADDR
// if not tmp then
110896: LD_VAR 0 2
110900: NOT
110901: IFFALSE 110905
// exit ;
110903: GO 110934
// for i in tmp do
110905: LD_ADDR_VAR 0 1
110909: PUSH
110910: LD_VAR 0 2
110914: PUSH
110915: FOR_IN
110916: IFFALSE 110932
// begin SetLives ( i , 0 ) ;
110918: LD_VAR 0 1
110922: PPUSH
110923: LD_INT 0
110925: PPUSH
110926: CALL_OW 234
// end ;
110930: GO 110915
110932: POP
110933: POP
// end ;
110934: PPOPN 2
110936: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
110937: LD_EXP 160
110941: PUSH
110942: LD_EXP 166
110946: AND
110947: IFFALSE 111031
110949: GO 110951
110951: DISABLE
110952: LD_INT 0
110954: PPUSH
110955: PPUSH
// begin enable ;
110956: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
110957: LD_ADDR_VAR 0 2
110961: PUSH
110962: LD_INT 22
110964: PUSH
110965: LD_OWVAR 2
110969: PUSH
110970: EMPTY
110971: LIST
110972: LIST
110973: PUSH
110974: LD_INT 32
110976: PUSH
110977: LD_INT 3
110979: PUSH
110980: EMPTY
110981: LIST
110982: LIST
110983: PUSH
110984: EMPTY
110985: LIST
110986: LIST
110987: PPUSH
110988: CALL_OW 69
110992: ST_TO_ADDR
// if not tmp then
110993: LD_VAR 0 2
110997: NOT
110998: IFFALSE 111002
// exit ;
111000: GO 111031
// for i in tmp do
111002: LD_ADDR_VAR 0 1
111006: PUSH
111007: LD_VAR 0 2
111011: PUSH
111012: FOR_IN
111013: IFFALSE 111029
// begin SetLives ( i , 0 ) ;
111015: LD_VAR 0 1
111019: PPUSH
111020: LD_INT 0
111022: PPUSH
111023: CALL_OW 234
// end ;
111027: GO 111012
111029: POP
111030: POP
// end ;
111031: PPOPN 2
111033: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
111034: LD_EXP 160
111038: PUSH
111039: LD_EXP 163
111043: AND
111044: IFFALSE 111137
111046: GO 111048
111048: DISABLE
111049: LD_INT 0
111051: PPUSH
// begin enable ;
111052: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
111053: LD_ADDR_VAR 0 1
111057: PUSH
111058: LD_INT 22
111060: PUSH
111061: LD_OWVAR 2
111065: PUSH
111066: EMPTY
111067: LIST
111068: LIST
111069: PUSH
111070: LD_INT 2
111072: PUSH
111073: LD_INT 25
111075: PUSH
111076: LD_INT 5
111078: PUSH
111079: EMPTY
111080: LIST
111081: LIST
111082: PUSH
111083: LD_INT 25
111085: PUSH
111086: LD_INT 9
111088: PUSH
111089: EMPTY
111090: LIST
111091: LIST
111092: PUSH
111093: LD_INT 25
111095: PUSH
111096: LD_INT 8
111098: PUSH
111099: EMPTY
111100: LIST
111101: LIST
111102: PUSH
111103: EMPTY
111104: LIST
111105: LIST
111106: LIST
111107: LIST
111108: PUSH
111109: EMPTY
111110: LIST
111111: LIST
111112: PPUSH
111113: CALL_OW 69
111117: PUSH
111118: FOR_IN
111119: IFFALSE 111135
// begin SetClass ( i , 1 ) ;
111121: LD_VAR 0 1
111125: PPUSH
111126: LD_INT 1
111128: PPUSH
111129: CALL_OW 336
// end ;
111133: GO 111118
111135: POP
111136: POP
// end ;
111137: PPOPN 1
111139: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
111140: LD_EXP 160
111144: PUSH
111145: LD_EXP 164
111149: AND
111150: PUSH
111151: LD_OWVAR 65
111155: PUSH
111156: LD_INT 7
111158: LESS
111159: AND
111160: IFFALSE 111174
111162: GO 111164
111164: DISABLE
// begin enable ;
111165: ENABLE
// game_speed := 7 ;
111166: LD_ADDR_OWVAR 65
111170: PUSH
111171: LD_INT 7
111173: ST_TO_ADDR
// end ;
111174: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
111175: LD_EXP 160
111179: PUSH
111180: LD_EXP 167
111184: AND
111185: IFFALSE 111387
111187: GO 111189
111189: DISABLE
111190: LD_INT 0
111192: PPUSH
111193: PPUSH
111194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
111195: LD_ADDR_VAR 0 3
111199: PUSH
111200: LD_INT 81
111202: PUSH
111203: LD_OWVAR 2
111207: PUSH
111208: EMPTY
111209: LIST
111210: LIST
111211: PUSH
111212: LD_INT 21
111214: PUSH
111215: LD_INT 1
111217: PUSH
111218: EMPTY
111219: LIST
111220: LIST
111221: PUSH
111222: EMPTY
111223: LIST
111224: LIST
111225: PPUSH
111226: CALL_OW 69
111230: ST_TO_ADDR
// if not tmp then
111231: LD_VAR 0 3
111235: NOT
111236: IFFALSE 111240
// exit ;
111238: GO 111387
// if tmp > 5 then
111240: LD_VAR 0 3
111244: PUSH
111245: LD_INT 5
111247: GREATER
111248: IFFALSE 111260
// k := 5 else
111250: LD_ADDR_VAR 0 2
111254: PUSH
111255: LD_INT 5
111257: ST_TO_ADDR
111258: GO 111270
// k := tmp ;
111260: LD_ADDR_VAR 0 2
111264: PUSH
111265: LD_VAR 0 3
111269: ST_TO_ADDR
// for i := 1 to k do
111270: LD_ADDR_VAR 0 1
111274: PUSH
111275: DOUBLE
111276: LD_INT 1
111278: DEC
111279: ST_TO_ADDR
111280: LD_VAR 0 2
111284: PUSH
111285: FOR_TO
111286: IFFALSE 111385
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
111288: LD_VAR 0 3
111292: PUSH
111293: LD_VAR 0 1
111297: ARRAY
111298: PPUSH
111299: LD_VAR 0 1
111303: PUSH
111304: LD_INT 4
111306: MOD
111307: PUSH
111308: LD_INT 1
111310: PLUS
111311: PPUSH
111312: CALL_OW 259
111316: PUSH
111317: LD_INT 10
111319: LESS
111320: IFFALSE 111383
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
111322: LD_VAR 0 3
111326: PUSH
111327: LD_VAR 0 1
111331: ARRAY
111332: PPUSH
111333: LD_VAR 0 1
111337: PUSH
111338: LD_INT 4
111340: MOD
111341: PUSH
111342: LD_INT 1
111344: PLUS
111345: PPUSH
111346: LD_VAR 0 3
111350: PUSH
111351: LD_VAR 0 1
111355: ARRAY
111356: PPUSH
111357: LD_VAR 0 1
111361: PUSH
111362: LD_INT 4
111364: MOD
111365: PUSH
111366: LD_INT 1
111368: PLUS
111369: PPUSH
111370: CALL_OW 259
111374: PUSH
111375: LD_INT 1
111377: PLUS
111378: PPUSH
111379: CALL_OW 237
111383: GO 111285
111385: POP
111386: POP
// end ;
111387: PPOPN 3
111389: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
111390: LD_EXP 160
111394: PUSH
111395: LD_EXP 168
111399: AND
111400: IFFALSE 111420
111402: GO 111404
111404: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
111405: LD_INT 4
111407: PPUSH
111408: LD_OWVAR 2
111412: PPUSH
111413: LD_INT 0
111415: PPUSH
111416: CALL_OW 324
111420: END
// every 0 0$1 trigger StreamModeActive and sShovel do
111421: LD_EXP 160
111425: PUSH
111426: LD_EXP 197
111430: AND
111431: IFFALSE 111451
111433: GO 111435
111435: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
111436: LD_INT 19
111438: PPUSH
111439: LD_OWVAR 2
111443: PPUSH
111444: LD_INT 0
111446: PPUSH
111447: CALL_OW 324
111451: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
111452: LD_EXP 160
111456: PUSH
111457: LD_EXP 169
111461: AND
111462: IFFALSE 111564
111464: GO 111466
111466: DISABLE
111467: LD_INT 0
111469: PPUSH
111470: PPUSH
// begin enable ;
111471: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
111472: LD_ADDR_VAR 0 2
111476: PUSH
111477: LD_INT 22
111479: PUSH
111480: LD_OWVAR 2
111484: PUSH
111485: EMPTY
111486: LIST
111487: LIST
111488: PUSH
111489: LD_INT 2
111491: PUSH
111492: LD_INT 34
111494: PUSH
111495: LD_INT 11
111497: PUSH
111498: EMPTY
111499: LIST
111500: LIST
111501: PUSH
111502: LD_INT 34
111504: PUSH
111505: LD_INT 30
111507: PUSH
111508: EMPTY
111509: LIST
111510: LIST
111511: PUSH
111512: EMPTY
111513: LIST
111514: LIST
111515: LIST
111516: PUSH
111517: EMPTY
111518: LIST
111519: LIST
111520: PPUSH
111521: CALL_OW 69
111525: ST_TO_ADDR
// if not tmp then
111526: LD_VAR 0 2
111530: NOT
111531: IFFALSE 111535
// exit ;
111533: GO 111564
// for i in tmp do
111535: LD_ADDR_VAR 0 1
111539: PUSH
111540: LD_VAR 0 2
111544: PUSH
111545: FOR_IN
111546: IFFALSE 111562
// begin SetLives ( i , 0 ) ;
111548: LD_VAR 0 1
111552: PPUSH
111553: LD_INT 0
111555: PPUSH
111556: CALL_OW 234
// end ;
111560: GO 111545
111562: POP
111563: POP
// end ;
111564: PPOPN 2
111566: END
// every 0 0$1 trigger StreamModeActive and sBunker do
111567: LD_EXP 160
111571: PUSH
111572: LD_EXP 170
111576: AND
111577: IFFALSE 111597
111579: GO 111581
111581: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
111582: LD_INT 32
111584: PPUSH
111585: LD_OWVAR 2
111589: PPUSH
111590: LD_INT 0
111592: PPUSH
111593: CALL_OW 324
111597: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
111598: LD_EXP 160
111602: PUSH
111603: LD_EXP 171
111607: AND
111608: IFFALSE 111789
111610: GO 111612
111612: DISABLE
111613: LD_INT 0
111615: PPUSH
111616: PPUSH
111617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
111618: LD_ADDR_VAR 0 2
111622: PUSH
111623: LD_INT 22
111625: PUSH
111626: LD_OWVAR 2
111630: PUSH
111631: EMPTY
111632: LIST
111633: LIST
111634: PUSH
111635: LD_INT 33
111637: PUSH
111638: LD_INT 3
111640: PUSH
111641: EMPTY
111642: LIST
111643: LIST
111644: PUSH
111645: EMPTY
111646: LIST
111647: LIST
111648: PPUSH
111649: CALL_OW 69
111653: ST_TO_ADDR
// if not tmp then
111654: LD_VAR 0 2
111658: NOT
111659: IFFALSE 111663
// exit ;
111661: GO 111789
// side := 0 ;
111663: LD_ADDR_VAR 0 3
111667: PUSH
111668: LD_INT 0
111670: ST_TO_ADDR
// for i := 1 to 8 do
111671: LD_ADDR_VAR 0 1
111675: PUSH
111676: DOUBLE
111677: LD_INT 1
111679: DEC
111680: ST_TO_ADDR
111681: LD_INT 8
111683: PUSH
111684: FOR_TO
111685: IFFALSE 111733
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
111687: LD_OWVAR 2
111691: PUSH
111692: LD_VAR 0 1
111696: NONEQUAL
111697: PUSH
111698: LD_OWVAR 2
111702: PPUSH
111703: LD_VAR 0 1
111707: PPUSH
111708: CALL_OW 81
111712: PUSH
111713: LD_INT 2
111715: EQUAL
111716: AND
111717: IFFALSE 111731
// begin side := i ;
111719: LD_ADDR_VAR 0 3
111723: PUSH
111724: LD_VAR 0 1
111728: ST_TO_ADDR
// break ;
111729: GO 111733
// end ;
111731: GO 111684
111733: POP
111734: POP
// if not side then
111735: LD_VAR 0 3
111739: NOT
111740: IFFALSE 111744
// exit ;
111742: GO 111789
// for i := 1 to tmp do
111744: LD_ADDR_VAR 0 1
111748: PUSH
111749: DOUBLE
111750: LD_INT 1
111752: DEC
111753: ST_TO_ADDR
111754: LD_VAR 0 2
111758: PUSH
111759: FOR_TO
111760: IFFALSE 111787
// if Prob ( 60 ) then
111762: LD_INT 60
111764: PPUSH
111765: CALL_OW 13
111769: IFFALSE 111785
// SetSide ( i , side ) ;
111771: LD_VAR 0 1
111775: PPUSH
111776: LD_VAR 0 3
111780: PPUSH
111781: CALL_OW 235
111785: GO 111759
111787: POP
111788: POP
// end ;
111789: PPOPN 3
111791: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
111792: LD_EXP 160
111796: PUSH
111797: LD_EXP 173
111801: AND
111802: IFFALSE 111921
111804: GO 111806
111806: DISABLE
111807: LD_INT 0
111809: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
111810: LD_ADDR_VAR 0 1
111814: PUSH
111815: LD_INT 22
111817: PUSH
111818: LD_OWVAR 2
111822: PUSH
111823: EMPTY
111824: LIST
111825: LIST
111826: PUSH
111827: LD_INT 21
111829: PUSH
111830: LD_INT 1
111832: PUSH
111833: EMPTY
111834: LIST
111835: LIST
111836: PUSH
111837: LD_INT 3
111839: PUSH
111840: LD_INT 23
111842: PUSH
111843: LD_INT 0
111845: PUSH
111846: EMPTY
111847: LIST
111848: LIST
111849: PUSH
111850: EMPTY
111851: LIST
111852: LIST
111853: PUSH
111854: EMPTY
111855: LIST
111856: LIST
111857: LIST
111858: PPUSH
111859: CALL_OW 69
111863: PUSH
111864: FOR_IN
111865: IFFALSE 111919
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
111867: LD_VAR 0 1
111871: PPUSH
111872: CALL_OW 257
111876: PUSH
111877: LD_INT 1
111879: PUSH
111880: LD_INT 2
111882: PUSH
111883: LD_INT 3
111885: PUSH
111886: LD_INT 4
111888: PUSH
111889: EMPTY
111890: LIST
111891: LIST
111892: LIST
111893: LIST
111894: IN
111895: IFFALSE 111917
// SetClass ( un , rand ( 1 , 4 ) ) ;
111897: LD_VAR 0 1
111901: PPUSH
111902: LD_INT 1
111904: PPUSH
111905: LD_INT 4
111907: PPUSH
111908: CALL_OW 12
111912: PPUSH
111913: CALL_OW 336
111917: GO 111864
111919: POP
111920: POP
// end ;
111921: PPOPN 1
111923: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
111924: LD_EXP 160
111928: PUSH
111929: LD_EXP 172
111933: AND
111934: IFFALSE 112013
111936: GO 111938
111938: DISABLE
111939: LD_INT 0
111941: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111942: LD_ADDR_VAR 0 1
111946: PUSH
111947: LD_INT 22
111949: PUSH
111950: LD_OWVAR 2
111954: PUSH
111955: EMPTY
111956: LIST
111957: LIST
111958: PUSH
111959: LD_INT 21
111961: PUSH
111962: LD_INT 3
111964: PUSH
111965: EMPTY
111966: LIST
111967: LIST
111968: PUSH
111969: EMPTY
111970: LIST
111971: LIST
111972: PPUSH
111973: CALL_OW 69
111977: ST_TO_ADDR
// if not tmp then
111978: LD_VAR 0 1
111982: NOT
111983: IFFALSE 111987
// exit ;
111985: GO 112013
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
111987: LD_VAR 0 1
111991: PUSH
111992: LD_INT 1
111994: PPUSH
111995: LD_VAR 0 1
111999: PPUSH
112000: CALL_OW 12
112004: ARRAY
112005: PPUSH
112006: LD_INT 100
112008: PPUSH
112009: CALL_OW 234
// end ;
112013: PPOPN 1
112015: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
112016: LD_EXP 160
112020: PUSH
112021: LD_EXP 174
112025: AND
112026: IFFALSE 112124
112028: GO 112030
112030: DISABLE
112031: LD_INT 0
112033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112034: LD_ADDR_VAR 0 1
112038: PUSH
112039: LD_INT 22
112041: PUSH
112042: LD_OWVAR 2
112046: PUSH
112047: EMPTY
112048: LIST
112049: LIST
112050: PUSH
112051: LD_INT 21
112053: PUSH
112054: LD_INT 1
112056: PUSH
112057: EMPTY
112058: LIST
112059: LIST
112060: PUSH
112061: EMPTY
112062: LIST
112063: LIST
112064: PPUSH
112065: CALL_OW 69
112069: ST_TO_ADDR
// if not tmp then
112070: LD_VAR 0 1
112074: NOT
112075: IFFALSE 112079
// exit ;
112077: GO 112124
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
112079: LD_VAR 0 1
112083: PUSH
112084: LD_INT 1
112086: PPUSH
112087: LD_VAR 0 1
112091: PPUSH
112092: CALL_OW 12
112096: ARRAY
112097: PPUSH
112098: LD_INT 1
112100: PPUSH
112101: LD_INT 4
112103: PPUSH
112104: CALL_OW 12
112108: PPUSH
112109: LD_INT 3000
112111: PPUSH
112112: LD_INT 9000
112114: PPUSH
112115: CALL_OW 12
112119: PPUSH
112120: CALL_OW 492
// end ;
112124: PPOPN 1
112126: END
// every 0 0$1 trigger StreamModeActive and sDepot do
112127: LD_EXP 160
112131: PUSH
112132: LD_EXP 175
112136: AND
112137: IFFALSE 112157
112139: GO 112141
112141: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
112142: LD_INT 1
112144: PPUSH
112145: LD_OWVAR 2
112149: PPUSH
112150: LD_INT 0
112152: PPUSH
112153: CALL_OW 324
112157: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
112158: LD_EXP 160
112162: PUSH
112163: LD_EXP 176
112167: AND
112168: IFFALSE 112251
112170: GO 112172
112172: DISABLE
112173: LD_INT 0
112175: PPUSH
112176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
112177: LD_ADDR_VAR 0 2
112181: PUSH
112182: LD_INT 22
112184: PUSH
112185: LD_OWVAR 2
112189: PUSH
112190: EMPTY
112191: LIST
112192: LIST
112193: PUSH
112194: LD_INT 21
112196: PUSH
112197: LD_INT 3
112199: PUSH
112200: EMPTY
112201: LIST
112202: LIST
112203: PUSH
112204: EMPTY
112205: LIST
112206: LIST
112207: PPUSH
112208: CALL_OW 69
112212: ST_TO_ADDR
// if not tmp then
112213: LD_VAR 0 2
112217: NOT
112218: IFFALSE 112222
// exit ;
112220: GO 112251
// for i in tmp do
112222: LD_ADDR_VAR 0 1
112226: PUSH
112227: LD_VAR 0 2
112231: PUSH
112232: FOR_IN
112233: IFFALSE 112249
// SetBLevel ( i , 10 ) ;
112235: LD_VAR 0 1
112239: PPUSH
112240: LD_INT 10
112242: PPUSH
112243: CALL_OW 241
112247: GO 112232
112249: POP
112250: POP
// end ;
112251: PPOPN 2
112253: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
112254: LD_EXP 160
112258: PUSH
112259: LD_EXP 177
112263: AND
112264: IFFALSE 112375
112266: GO 112268
112268: DISABLE
112269: LD_INT 0
112271: PPUSH
112272: PPUSH
112273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112274: LD_ADDR_VAR 0 3
112278: PUSH
112279: LD_INT 22
112281: PUSH
112282: LD_OWVAR 2
112286: PUSH
112287: EMPTY
112288: LIST
112289: LIST
112290: PUSH
112291: LD_INT 25
112293: PUSH
112294: LD_INT 1
112296: PUSH
112297: EMPTY
112298: LIST
112299: LIST
112300: PUSH
112301: EMPTY
112302: LIST
112303: LIST
112304: PPUSH
112305: CALL_OW 69
112309: ST_TO_ADDR
// if not tmp then
112310: LD_VAR 0 3
112314: NOT
112315: IFFALSE 112319
// exit ;
112317: GO 112375
// un := tmp [ rand ( 1 , tmp ) ] ;
112319: LD_ADDR_VAR 0 2
112323: PUSH
112324: LD_VAR 0 3
112328: PUSH
112329: LD_INT 1
112331: PPUSH
112332: LD_VAR 0 3
112336: PPUSH
112337: CALL_OW 12
112341: ARRAY
112342: ST_TO_ADDR
// if Crawls ( un ) then
112343: LD_VAR 0 2
112347: PPUSH
112348: CALL_OW 318
112352: IFFALSE 112363
// ComWalk ( un ) ;
112354: LD_VAR 0 2
112358: PPUSH
112359: CALL_OW 138
// SetClass ( un , class_sniper ) ;
112363: LD_VAR 0 2
112367: PPUSH
112368: LD_INT 5
112370: PPUSH
112371: CALL_OW 336
// end ;
112375: PPOPN 3
112377: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
112378: LD_EXP 160
112382: PUSH
112383: LD_EXP 178
112387: AND
112388: PUSH
112389: LD_OWVAR 67
112393: PUSH
112394: LD_INT 4
112396: LESS
112397: AND
112398: IFFALSE 112417
112400: GO 112402
112402: DISABLE
// begin Difficulty := Difficulty + 1 ;
112403: LD_ADDR_OWVAR 67
112407: PUSH
112408: LD_OWVAR 67
112412: PUSH
112413: LD_INT 1
112415: PLUS
112416: ST_TO_ADDR
// end ;
112417: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
112418: LD_EXP 160
112422: PUSH
112423: LD_EXP 179
112427: AND
112428: IFFALSE 112531
112430: GO 112432
112432: DISABLE
112433: LD_INT 0
112435: PPUSH
// begin for i := 1 to 5 do
112436: LD_ADDR_VAR 0 1
112440: PUSH
112441: DOUBLE
112442: LD_INT 1
112444: DEC
112445: ST_TO_ADDR
112446: LD_INT 5
112448: PUSH
112449: FOR_TO
112450: IFFALSE 112529
// begin uc_nation := nation_nature ;
112452: LD_ADDR_OWVAR 21
112456: PUSH
112457: LD_INT 0
112459: ST_TO_ADDR
// uc_side := 0 ;
112460: LD_ADDR_OWVAR 20
112464: PUSH
112465: LD_INT 0
112467: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112468: LD_ADDR_OWVAR 29
112472: PUSH
112473: LD_INT 12
112475: PUSH
112476: LD_INT 12
112478: PUSH
112479: EMPTY
112480: LIST
112481: LIST
112482: ST_TO_ADDR
// hc_agressivity := 20 ;
112483: LD_ADDR_OWVAR 35
112487: PUSH
112488: LD_INT 20
112490: ST_TO_ADDR
// hc_class := class_tiger ;
112491: LD_ADDR_OWVAR 28
112495: PUSH
112496: LD_INT 14
112498: ST_TO_ADDR
// hc_gallery :=  ;
112499: LD_ADDR_OWVAR 33
112503: PUSH
112504: LD_STRING 
112506: ST_TO_ADDR
// hc_name :=  ;
112507: LD_ADDR_OWVAR 26
112511: PUSH
112512: LD_STRING 
112514: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
112515: CALL_OW 44
112519: PPUSH
112520: LD_INT 0
112522: PPUSH
112523: CALL_OW 51
// end ;
112527: GO 112449
112529: POP
112530: POP
// end ;
112531: PPOPN 1
112533: END
// every 0 0$1 trigger StreamModeActive and sBomb do
112534: LD_EXP 160
112538: PUSH
112539: LD_EXP 180
112543: AND
112544: IFFALSE 112553
112546: GO 112548
112548: DISABLE
// StreamSibBomb ;
112549: CALL 112554 0 0
112553: END
// export function StreamSibBomb ; var i , x , y ; begin
112554: LD_INT 0
112556: PPUSH
112557: PPUSH
112558: PPUSH
112559: PPUSH
// result := false ;
112560: LD_ADDR_VAR 0 1
112564: PUSH
112565: LD_INT 0
112567: ST_TO_ADDR
// for i := 1 to 16 do
112568: LD_ADDR_VAR 0 2
112572: PUSH
112573: DOUBLE
112574: LD_INT 1
112576: DEC
112577: ST_TO_ADDR
112578: LD_INT 16
112580: PUSH
112581: FOR_TO
112582: IFFALSE 112781
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112584: LD_ADDR_VAR 0 3
112588: PUSH
112589: LD_INT 10
112591: PUSH
112592: LD_INT 20
112594: PUSH
112595: LD_INT 30
112597: PUSH
112598: LD_INT 40
112600: PUSH
112601: LD_INT 50
112603: PUSH
112604: LD_INT 60
112606: PUSH
112607: LD_INT 70
112609: PUSH
112610: LD_INT 80
112612: PUSH
112613: LD_INT 90
112615: PUSH
112616: LD_INT 100
112618: PUSH
112619: LD_INT 110
112621: PUSH
112622: LD_INT 120
112624: PUSH
112625: LD_INT 130
112627: PUSH
112628: LD_INT 140
112630: PUSH
112631: LD_INT 150
112633: PUSH
112634: EMPTY
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: LIST
112641: LIST
112642: LIST
112643: LIST
112644: LIST
112645: LIST
112646: LIST
112647: LIST
112648: LIST
112649: LIST
112650: PUSH
112651: LD_INT 1
112653: PPUSH
112654: LD_INT 15
112656: PPUSH
112657: CALL_OW 12
112661: ARRAY
112662: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112663: LD_ADDR_VAR 0 4
112667: PUSH
112668: LD_INT 10
112670: PUSH
112671: LD_INT 20
112673: PUSH
112674: LD_INT 30
112676: PUSH
112677: LD_INT 40
112679: PUSH
112680: LD_INT 50
112682: PUSH
112683: LD_INT 60
112685: PUSH
112686: LD_INT 70
112688: PUSH
112689: LD_INT 80
112691: PUSH
112692: LD_INT 90
112694: PUSH
112695: LD_INT 100
112697: PUSH
112698: LD_INT 110
112700: PUSH
112701: LD_INT 120
112703: PUSH
112704: LD_INT 130
112706: PUSH
112707: LD_INT 140
112709: PUSH
112710: LD_INT 150
112712: PUSH
112713: EMPTY
112714: LIST
112715: LIST
112716: LIST
112717: LIST
112718: LIST
112719: LIST
112720: LIST
112721: LIST
112722: LIST
112723: LIST
112724: LIST
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: PUSH
112730: LD_INT 1
112732: PPUSH
112733: LD_INT 15
112735: PPUSH
112736: CALL_OW 12
112740: ARRAY
112741: ST_TO_ADDR
// if ValidHex ( x , y ) then
112742: LD_VAR 0 3
112746: PPUSH
112747: LD_VAR 0 4
112751: PPUSH
112752: CALL_OW 488
112756: IFFALSE 112779
// begin result := [ x , y ] ;
112758: LD_ADDR_VAR 0 1
112762: PUSH
112763: LD_VAR 0 3
112767: PUSH
112768: LD_VAR 0 4
112772: PUSH
112773: EMPTY
112774: LIST
112775: LIST
112776: ST_TO_ADDR
// break ;
112777: GO 112781
// end ; end ;
112779: GO 112581
112781: POP
112782: POP
// if result then
112783: LD_VAR 0 1
112787: IFFALSE 112847
// begin ToLua ( playSibBomb() ) ;
112789: LD_STRING playSibBomb()
112791: PPUSH
112792: CALL_OW 559
// wait ( 0 0$14 ) ;
112796: LD_INT 490
112798: PPUSH
112799: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
112803: LD_VAR 0 1
112807: PUSH
112808: LD_INT 1
112810: ARRAY
112811: PPUSH
112812: LD_VAR 0 1
112816: PUSH
112817: LD_INT 2
112819: ARRAY
112820: PPUSH
112821: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
112825: LD_VAR 0 1
112829: PUSH
112830: LD_INT 1
112832: ARRAY
112833: PPUSH
112834: LD_VAR 0 1
112838: PUSH
112839: LD_INT 2
112841: ARRAY
112842: PPUSH
112843: CALL_OW 429
// end ; end ;
112847: LD_VAR 0 1
112851: RET
// every 0 0$1 trigger StreamModeActive and sReset do
112852: LD_EXP 160
112856: PUSH
112857: LD_EXP 182
112861: AND
112862: IFFALSE 112874
112864: GO 112866
112866: DISABLE
// YouLost (  ) ;
112867: LD_STRING 
112869: PPUSH
112870: CALL_OW 104
112874: END
// every 0 0$1 trigger StreamModeActive and sFog do
112875: LD_EXP 160
112879: PUSH
112880: LD_EXP 181
112884: AND
112885: IFFALSE 112899
112887: GO 112889
112889: DISABLE
// FogOff ( your_side ) ;
112890: LD_OWVAR 2
112894: PPUSH
112895: CALL_OW 344
112899: END
// every 0 0$1 trigger StreamModeActive and sSun do
112900: LD_EXP 160
112904: PUSH
112905: LD_EXP 183
112909: AND
112910: IFFALSE 112938
112912: GO 112914
112914: DISABLE
// begin solar_recharge_percent := 0 ;
112915: LD_ADDR_OWVAR 79
112919: PUSH
112920: LD_INT 0
112922: ST_TO_ADDR
// wait ( 5 5$00 ) ;
112923: LD_INT 10500
112925: PPUSH
112926: CALL_OW 67
// solar_recharge_percent := 100 ;
112930: LD_ADDR_OWVAR 79
112934: PUSH
112935: LD_INT 100
112937: ST_TO_ADDR
// end ;
112938: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
112939: LD_EXP 160
112943: PUSH
112944: LD_EXP 184
112948: AND
112949: IFFALSE 113188
112951: GO 112953
112953: DISABLE
112954: LD_INT 0
112956: PPUSH
112957: PPUSH
112958: PPUSH
// begin tmp := [ ] ;
112959: LD_ADDR_VAR 0 3
112963: PUSH
112964: EMPTY
112965: ST_TO_ADDR
// for i := 1 to 6 do
112966: LD_ADDR_VAR 0 1
112970: PUSH
112971: DOUBLE
112972: LD_INT 1
112974: DEC
112975: ST_TO_ADDR
112976: LD_INT 6
112978: PUSH
112979: FOR_TO
112980: IFFALSE 113085
// begin uc_nation := nation_nature ;
112982: LD_ADDR_OWVAR 21
112986: PUSH
112987: LD_INT 0
112989: ST_TO_ADDR
// uc_side := 0 ;
112990: LD_ADDR_OWVAR 20
112994: PUSH
112995: LD_INT 0
112997: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112998: LD_ADDR_OWVAR 29
113002: PUSH
113003: LD_INT 12
113005: PUSH
113006: LD_INT 12
113008: PUSH
113009: EMPTY
113010: LIST
113011: LIST
113012: ST_TO_ADDR
// hc_agressivity := 20 ;
113013: LD_ADDR_OWVAR 35
113017: PUSH
113018: LD_INT 20
113020: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
113021: LD_ADDR_OWVAR 28
113025: PUSH
113026: LD_INT 17
113028: ST_TO_ADDR
// hc_gallery :=  ;
113029: LD_ADDR_OWVAR 33
113033: PUSH
113034: LD_STRING 
113036: ST_TO_ADDR
// hc_name :=  ;
113037: LD_ADDR_OWVAR 26
113041: PUSH
113042: LD_STRING 
113044: ST_TO_ADDR
// un := CreateHuman ;
113045: LD_ADDR_VAR 0 2
113049: PUSH
113050: CALL_OW 44
113054: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
113055: LD_VAR 0 2
113059: PPUSH
113060: LD_INT 1
113062: PPUSH
113063: CALL_OW 51
// tmp := tmp ^ un ;
113067: LD_ADDR_VAR 0 3
113071: PUSH
113072: LD_VAR 0 3
113076: PUSH
113077: LD_VAR 0 2
113081: ADD
113082: ST_TO_ADDR
// end ;
113083: GO 112979
113085: POP
113086: POP
// repeat wait ( 0 0$1 ) ;
113087: LD_INT 35
113089: PPUSH
113090: CALL_OW 67
// for un in tmp do
113094: LD_ADDR_VAR 0 2
113098: PUSH
113099: LD_VAR 0 3
113103: PUSH
113104: FOR_IN
113105: IFFALSE 113179
// begin if IsDead ( un ) then
113107: LD_VAR 0 2
113111: PPUSH
113112: CALL_OW 301
113116: IFFALSE 113136
// begin tmp := tmp diff un ;
113118: LD_ADDR_VAR 0 3
113122: PUSH
113123: LD_VAR 0 3
113127: PUSH
113128: LD_VAR 0 2
113132: DIFF
113133: ST_TO_ADDR
// continue ;
113134: GO 113104
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
113136: LD_VAR 0 2
113140: PPUSH
113141: LD_INT 3
113143: PUSH
113144: LD_INT 22
113146: PUSH
113147: LD_INT 0
113149: PUSH
113150: EMPTY
113151: LIST
113152: LIST
113153: PUSH
113154: EMPTY
113155: LIST
113156: LIST
113157: PPUSH
113158: CALL_OW 69
113162: PPUSH
113163: LD_VAR 0 2
113167: PPUSH
113168: CALL_OW 74
113172: PPUSH
113173: CALL_OW 115
// end ;
113177: GO 113104
113179: POP
113180: POP
// until not tmp ;
113181: LD_VAR 0 3
113185: NOT
113186: IFFALSE 113087
// end ;
113188: PPOPN 3
113190: END
// every 0 0$1 trigger StreamModeActive and sTroll do
113191: LD_EXP 160
113195: PUSH
113196: LD_EXP 185
113200: AND
113201: IFFALSE 113255
113203: GO 113205
113205: DISABLE
// begin ToLua ( displayTroll(); ) ;
113206: LD_STRING displayTroll();
113208: PPUSH
113209: CALL_OW 559
// wait ( 3 3$00 ) ;
113213: LD_INT 6300
113215: PPUSH
113216: CALL_OW 67
// ToLua ( hideTroll(); ) ;
113220: LD_STRING hideTroll();
113222: PPUSH
113223: CALL_OW 559
// wait ( 1 1$00 ) ;
113227: LD_INT 2100
113229: PPUSH
113230: CALL_OW 67
// ToLua ( displayTroll(); ) ;
113234: LD_STRING displayTroll();
113236: PPUSH
113237: CALL_OW 559
// wait ( 1 1$00 ) ;
113241: LD_INT 2100
113243: PPUSH
113244: CALL_OW 67
// ToLua ( hideTroll(); ) ;
113248: LD_STRING hideTroll();
113250: PPUSH
113251: CALL_OW 559
// end ;
113255: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
113256: LD_EXP 160
113260: PUSH
113261: LD_EXP 186
113265: AND
113266: IFFALSE 113329
113268: GO 113270
113270: DISABLE
113271: LD_INT 0
113273: PPUSH
// begin p := 0 ;
113274: LD_ADDR_VAR 0 1
113278: PUSH
113279: LD_INT 0
113281: ST_TO_ADDR
// repeat game_speed := 1 ;
113282: LD_ADDR_OWVAR 65
113286: PUSH
113287: LD_INT 1
113289: ST_TO_ADDR
// wait ( 0 0$1 ) ;
113290: LD_INT 35
113292: PPUSH
113293: CALL_OW 67
// p := p + 1 ;
113297: LD_ADDR_VAR 0 1
113301: PUSH
113302: LD_VAR 0 1
113306: PUSH
113307: LD_INT 1
113309: PLUS
113310: ST_TO_ADDR
// until p >= 60 ;
113311: LD_VAR 0 1
113315: PUSH
113316: LD_INT 60
113318: GREATEREQUAL
113319: IFFALSE 113282
// game_speed := 4 ;
113321: LD_ADDR_OWVAR 65
113325: PUSH
113326: LD_INT 4
113328: ST_TO_ADDR
// end ;
113329: PPOPN 1
113331: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
113332: LD_EXP 160
113336: PUSH
113337: LD_EXP 187
113341: AND
113342: IFFALSE 113488
113344: GO 113346
113346: DISABLE
113347: LD_INT 0
113349: PPUSH
113350: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113351: LD_ADDR_VAR 0 1
113355: PUSH
113356: LD_INT 22
113358: PUSH
113359: LD_OWVAR 2
113363: PUSH
113364: EMPTY
113365: LIST
113366: LIST
113367: PUSH
113368: LD_INT 2
113370: PUSH
113371: LD_INT 30
113373: PUSH
113374: LD_INT 0
113376: PUSH
113377: EMPTY
113378: LIST
113379: LIST
113380: PUSH
113381: LD_INT 30
113383: PUSH
113384: LD_INT 1
113386: PUSH
113387: EMPTY
113388: LIST
113389: LIST
113390: PUSH
113391: EMPTY
113392: LIST
113393: LIST
113394: LIST
113395: PUSH
113396: EMPTY
113397: LIST
113398: LIST
113399: PPUSH
113400: CALL_OW 69
113404: ST_TO_ADDR
// if not depot then
113405: LD_VAR 0 1
113409: NOT
113410: IFFALSE 113414
// exit ;
113412: GO 113488
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
113414: LD_ADDR_VAR 0 2
113418: PUSH
113419: LD_VAR 0 1
113423: PUSH
113424: LD_INT 1
113426: PPUSH
113427: LD_VAR 0 1
113431: PPUSH
113432: CALL_OW 12
113436: ARRAY
113437: PPUSH
113438: CALL_OW 274
113442: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
113443: LD_VAR 0 2
113447: PPUSH
113448: LD_INT 1
113450: PPUSH
113451: LD_INT 0
113453: PPUSH
113454: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
113458: LD_VAR 0 2
113462: PPUSH
113463: LD_INT 2
113465: PPUSH
113466: LD_INT 0
113468: PPUSH
113469: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
113473: LD_VAR 0 2
113477: PPUSH
113478: LD_INT 3
113480: PPUSH
113481: LD_INT 0
113483: PPUSH
113484: CALL_OW 277
// end ;
113488: PPOPN 2
113490: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
113491: LD_EXP 160
113495: PUSH
113496: LD_EXP 188
113500: AND
113501: IFFALSE 113598
113503: GO 113505
113505: DISABLE
113506: LD_INT 0
113508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113509: LD_ADDR_VAR 0 1
113513: PUSH
113514: LD_INT 22
113516: PUSH
113517: LD_OWVAR 2
113521: PUSH
113522: EMPTY
113523: LIST
113524: LIST
113525: PUSH
113526: LD_INT 21
113528: PUSH
113529: LD_INT 1
113531: PUSH
113532: EMPTY
113533: LIST
113534: LIST
113535: PUSH
113536: LD_INT 3
113538: PUSH
113539: LD_INT 23
113541: PUSH
113542: LD_INT 0
113544: PUSH
113545: EMPTY
113546: LIST
113547: LIST
113548: PUSH
113549: EMPTY
113550: LIST
113551: LIST
113552: PUSH
113553: EMPTY
113554: LIST
113555: LIST
113556: LIST
113557: PPUSH
113558: CALL_OW 69
113562: ST_TO_ADDR
// if not tmp then
113563: LD_VAR 0 1
113567: NOT
113568: IFFALSE 113572
// exit ;
113570: GO 113598
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
113572: LD_VAR 0 1
113576: PUSH
113577: LD_INT 1
113579: PPUSH
113580: LD_VAR 0 1
113584: PPUSH
113585: CALL_OW 12
113589: ARRAY
113590: PPUSH
113591: LD_INT 200
113593: PPUSH
113594: CALL_OW 234
// end ;
113598: PPOPN 1
113600: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
113601: LD_EXP 160
113605: PUSH
113606: LD_EXP 189
113610: AND
113611: IFFALSE 113690
113613: GO 113615
113615: DISABLE
113616: LD_INT 0
113618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
113619: LD_ADDR_VAR 0 1
113623: PUSH
113624: LD_INT 22
113626: PUSH
113627: LD_OWVAR 2
113631: PUSH
113632: EMPTY
113633: LIST
113634: LIST
113635: PUSH
113636: LD_INT 21
113638: PUSH
113639: LD_INT 2
113641: PUSH
113642: EMPTY
113643: LIST
113644: LIST
113645: PUSH
113646: EMPTY
113647: LIST
113648: LIST
113649: PPUSH
113650: CALL_OW 69
113654: ST_TO_ADDR
// if not tmp then
113655: LD_VAR 0 1
113659: NOT
113660: IFFALSE 113664
// exit ;
113662: GO 113690
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
113664: LD_VAR 0 1
113668: PUSH
113669: LD_INT 1
113671: PPUSH
113672: LD_VAR 0 1
113676: PPUSH
113677: CALL_OW 12
113681: ARRAY
113682: PPUSH
113683: LD_INT 60
113685: PPUSH
113686: CALL_OW 234
// end ;
113690: PPOPN 1
113692: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
113693: LD_EXP 160
113697: PUSH
113698: LD_EXP 190
113702: AND
113703: IFFALSE 113802
113705: GO 113707
113707: DISABLE
113708: LD_INT 0
113710: PPUSH
113711: PPUSH
// begin enable ;
113712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
113713: LD_ADDR_VAR 0 1
113717: PUSH
113718: LD_INT 22
113720: PUSH
113721: LD_OWVAR 2
113725: PUSH
113726: EMPTY
113727: LIST
113728: LIST
113729: PUSH
113730: LD_INT 61
113732: PUSH
113733: EMPTY
113734: LIST
113735: PUSH
113736: LD_INT 33
113738: PUSH
113739: LD_INT 2
113741: PUSH
113742: EMPTY
113743: LIST
113744: LIST
113745: PUSH
113746: EMPTY
113747: LIST
113748: LIST
113749: LIST
113750: PPUSH
113751: CALL_OW 69
113755: ST_TO_ADDR
// if not tmp then
113756: LD_VAR 0 1
113760: NOT
113761: IFFALSE 113765
// exit ;
113763: GO 113802
// for i in tmp do
113765: LD_ADDR_VAR 0 2
113769: PUSH
113770: LD_VAR 0 1
113774: PUSH
113775: FOR_IN
113776: IFFALSE 113800
// if IsControledBy ( i ) then
113778: LD_VAR 0 2
113782: PPUSH
113783: CALL_OW 312
113787: IFFALSE 113798
// ComUnlink ( i ) ;
113789: LD_VAR 0 2
113793: PPUSH
113794: CALL_OW 136
113798: GO 113775
113800: POP
113801: POP
// end ;
113802: PPOPN 2
113804: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
113805: LD_EXP 160
113809: PUSH
113810: LD_EXP 191
113814: AND
113815: IFFALSE 113955
113817: GO 113819
113819: DISABLE
113820: LD_INT 0
113822: PPUSH
113823: PPUSH
// begin ToLua ( displayPowell(); ) ;
113824: LD_STRING displayPowell();
113826: PPUSH
113827: CALL_OW 559
// uc_side := 0 ;
113831: LD_ADDR_OWVAR 20
113835: PUSH
113836: LD_INT 0
113838: ST_TO_ADDR
// uc_nation := 2 ;
113839: LD_ADDR_OWVAR 21
113843: PUSH
113844: LD_INT 2
113846: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
113847: LD_ADDR_OWVAR 37
113851: PUSH
113852: LD_INT 14
113854: ST_TO_ADDR
// vc_engine := engine_siberite ;
113855: LD_ADDR_OWVAR 39
113859: PUSH
113860: LD_INT 3
113862: ST_TO_ADDR
// vc_control := control_apeman ;
113863: LD_ADDR_OWVAR 38
113867: PUSH
113868: LD_INT 5
113870: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
113871: LD_ADDR_OWVAR 40
113875: PUSH
113876: LD_INT 29
113878: ST_TO_ADDR
// un := CreateVehicle ;
113879: LD_ADDR_VAR 0 2
113883: PUSH
113884: CALL_OW 45
113888: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113889: LD_VAR 0 2
113893: PPUSH
113894: LD_INT 1
113896: PPUSH
113897: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
113901: LD_INT 35
113903: PPUSH
113904: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
113908: LD_VAR 0 2
113912: PPUSH
113913: LD_INT 22
113915: PUSH
113916: LD_OWVAR 2
113920: PUSH
113921: EMPTY
113922: LIST
113923: LIST
113924: PPUSH
113925: CALL_OW 69
113929: PPUSH
113930: LD_VAR 0 2
113934: PPUSH
113935: CALL_OW 74
113939: PPUSH
113940: CALL_OW 115
// until IsDead ( un ) ;
113944: LD_VAR 0 2
113948: PPUSH
113949: CALL_OW 301
113953: IFFALSE 113901
// end ;
113955: PPOPN 2
113957: END
// every 0 0$1 trigger StreamModeActive and sStu do
113958: LD_EXP 160
113962: PUSH
113963: LD_EXP 199
113967: AND
113968: IFFALSE 113984
113970: GO 113972
113972: DISABLE
// begin ToLua ( displayStucuk(); ) ;
113973: LD_STRING displayStucuk();
113975: PPUSH
113976: CALL_OW 559
// ResetFog ;
113980: CALL_OW 335
// end ;
113984: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
113985: LD_EXP 160
113989: PUSH
113990: LD_EXP 192
113994: AND
113995: IFFALSE 114136
113997: GO 113999
113999: DISABLE
114000: LD_INT 0
114002: PPUSH
114003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114004: LD_ADDR_VAR 0 2
114008: PUSH
114009: LD_INT 22
114011: PUSH
114012: LD_OWVAR 2
114016: PUSH
114017: EMPTY
114018: LIST
114019: LIST
114020: PUSH
114021: LD_INT 21
114023: PUSH
114024: LD_INT 1
114026: PUSH
114027: EMPTY
114028: LIST
114029: LIST
114030: PUSH
114031: EMPTY
114032: LIST
114033: LIST
114034: PPUSH
114035: CALL_OW 69
114039: ST_TO_ADDR
// if not tmp then
114040: LD_VAR 0 2
114044: NOT
114045: IFFALSE 114049
// exit ;
114047: GO 114136
// un := tmp [ rand ( 1 , tmp ) ] ;
114049: LD_ADDR_VAR 0 1
114053: PUSH
114054: LD_VAR 0 2
114058: PUSH
114059: LD_INT 1
114061: PPUSH
114062: LD_VAR 0 2
114066: PPUSH
114067: CALL_OW 12
114071: ARRAY
114072: ST_TO_ADDR
// SetSide ( un , 0 ) ;
114073: LD_VAR 0 1
114077: PPUSH
114078: LD_INT 0
114080: PPUSH
114081: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
114085: LD_VAR 0 1
114089: PPUSH
114090: LD_OWVAR 3
114094: PUSH
114095: LD_VAR 0 1
114099: DIFF
114100: PPUSH
114101: LD_VAR 0 1
114105: PPUSH
114106: CALL_OW 74
114110: PPUSH
114111: CALL_OW 115
// wait ( 0 0$20 ) ;
114115: LD_INT 700
114117: PPUSH
114118: CALL_OW 67
// SetSide ( un , your_side ) ;
114122: LD_VAR 0 1
114126: PPUSH
114127: LD_OWVAR 2
114131: PPUSH
114132: CALL_OW 235
// end ;
114136: PPOPN 2
114138: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
114139: LD_EXP 160
114143: PUSH
114144: LD_EXP 193
114148: AND
114149: IFFALSE 114255
114151: GO 114153
114153: DISABLE
114154: LD_INT 0
114156: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114157: LD_ADDR_VAR 0 1
114161: PUSH
114162: LD_INT 22
114164: PUSH
114165: LD_OWVAR 2
114169: PUSH
114170: EMPTY
114171: LIST
114172: LIST
114173: PUSH
114174: LD_INT 2
114176: PUSH
114177: LD_INT 30
114179: PUSH
114180: LD_INT 0
114182: PUSH
114183: EMPTY
114184: LIST
114185: LIST
114186: PUSH
114187: LD_INT 30
114189: PUSH
114190: LD_INT 1
114192: PUSH
114193: EMPTY
114194: LIST
114195: LIST
114196: PUSH
114197: EMPTY
114198: LIST
114199: LIST
114200: LIST
114201: PUSH
114202: EMPTY
114203: LIST
114204: LIST
114205: PPUSH
114206: CALL_OW 69
114210: ST_TO_ADDR
// if not depot then
114211: LD_VAR 0 1
114215: NOT
114216: IFFALSE 114220
// exit ;
114218: GO 114255
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
114220: LD_VAR 0 1
114224: PUSH
114225: LD_INT 1
114227: ARRAY
114228: PPUSH
114229: CALL_OW 250
114233: PPUSH
114234: LD_VAR 0 1
114238: PUSH
114239: LD_INT 1
114241: ARRAY
114242: PPUSH
114243: CALL_OW 251
114247: PPUSH
114248: LD_INT 70
114250: PPUSH
114251: CALL_OW 495
// end ;
114255: PPOPN 1
114257: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
114258: LD_EXP 160
114262: PUSH
114263: LD_EXP 194
114267: AND
114268: IFFALSE 114479
114270: GO 114272
114272: DISABLE
114273: LD_INT 0
114275: PPUSH
114276: PPUSH
114277: PPUSH
114278: PPUSH
114279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114280: LD_ADDR_VAR 0 5
114284: PUSH
114285: LD_INT 22
114287: PUSH
114288: LD_OWVAR 2
114292: PUSH
114293: EMPTY
114294: LIST
114295: LIST
114296: PUSH
114297: LD_INT 21
114299: PUSH
114300: LD_INT 1
114302: PUSH
114303: EMPTY
114304: LIST
114305: LIST
114306: PUSH
114307: EMPTY
114308: LIST
114309: LIST
114310: PPUSH
114311: CALL_OW 69
114315: ST_TO_ADDR
// if not tmp then
114316: LD_VAR 0 5
114320: NOT
114321: IFFALSE 114325
// exit ;
114323: GO 114479
// for i in tmp do
114325: LD_ADDR_VAR 0 1
114329: PUSH
114330: LD_VAR 0 5
114334: PUSH
114335: FOR_IN
114336: IFFALSE 114477
// begin d := rand ( 0 , 5 ) ;
114338: LD_ADDR_VAR 0 4
114342: PUSH
114343: LD_INT 0
114345: PPUSH
114346: LD_INT 5
114348: PPUSH
114349: CALL_OW 12
114353: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
114354: LD_ADDR_VAR 0 2
114358: PUSH
114359: LD_VAR 0 1
114363: PPUSH
114364: CALL_OW 250
114368: PPUSH
114369: LD_VAR 0 4
114373: PPUSH
114374: LD_INT 3
114376: PPUSH
114377: LD_INT 12
114379: PPUSH
114380: CALL_OW 12
114384: PPUSH
114385: CALL_OW 272
114389: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
114390: LD_ADDR_VAR 0 3
114394: PUSH
114395: LD_VAR 0 1
114399: PPUSH
114400: CALL_OW 251
114404: PPUSH
114405: LD_VAR 0 4
114409: PPUSH
114410: LD_INT 3
114412: PPUSH
114413: LD_INT 12
114415: PPUSH
114416: CALL_OW 12
114420: PPUSH
114421: CALL_OW 273
114425: ST_TO_ADDR
// if ValidHex ( x , y ) then
114426: LD_VAR 0 2
114430: PPUSH
114431: LD_VAR 0 3
114435: PPUSH
114436: CALL_OW 488
114440: IFFALSE 114475
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
114442: LD_VAR 0 1
114446: PPUSH
114447: LD_VAR 0 2
114451: PPUSH
114452: LD_VAR 0 3
114456: PPUSH
114457: LD_INT 3
114459: PPUSH
114460: LD_INT 6
114462: PPUSH
114463: CALL_OW 12
114467: PPUSH
114468: LD_INT 1
114470: PPUSH
114471: CALL_OW 483
// end ;
114475: GO 114335
114477: POP
114478: POP
// end ;
114479: PPOPN 5
114481: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
114482: LD_EXP 160
114486: PUSH
114487: LD_EXP 195
114491: AND
114492: IFFALSE 114586
114494: GO 114496
114496: DISABLE
114497: LD_INT 0
114499: PPUSH
114500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
114501: LD_ADDR_VAR 0 2
114505: PUSH
114506: LD_INT 22
114508: PUSH
114509: LD_OWVAR 2
114513: PUSH
114514: EMPTY
114515: LIST
114516: LIST
114517: PUSH
114518: LD_INT 32
114520: PUSH
114521: LD_INT 1
114523: PUSH
114524: EMPTY
114525: LIST
114526: LIST
114527: PUSH
114528: LD_INT 21
114530: PUSH
114531: LD_INT 2
114533: PUSH
114534: EMPTY
114535: LIST
114536: LIST
114537: PUSH
114538: EMPTY
114539: LIST
114540: LIST
114541: LIST
114542: PPUSH
114543: CALL_OW 69
114547: ST_TO_ADDR
// if not tmp then
114548: LD_VAR 0 2
114552: NOT
114553: IFFALSE 114557
// exit ;
114555: GO 114586
// for i in tmp do
114557: LD_ADDR_VAR 0 1
114561: PUSH
114562: LD_VAR 0 2
114566: PUSH
114567: FOR_IN
114568: IFFALSE 114584
// SetFuel ( i , 0 ) ;
114570: LD_VAR 0 1
114574: PPUSH
114575: LD_INT 0
114577: PPUSH
114578: CALL_OW 240
114582: GO 114567
114584: POP
114585: POP
// end ;
114586: PPOPN 2
114588: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
114589: LD_EXP 160
114593: PUSH
114594: LD_EXP 196
114598: AND
114599: IFFALSE 114665
114601: GO 114603
114603: DISABLE
114604: LD_INT 0
114606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
114607: LD_ADDR_VAR 0 1
114611: PUSH
114612: LD_INT 22
114614: PUSH
114615: LD_OWVAR 2
114619: PUSH
114620: EMPTY
114621: LIST
114622: LIST
114623: PUSH
114624: LD_INT 30
114626: PUSH
114627: LD_INT 29
114629: PUSH
114630: EMPTY
114631: LIST
114632: LIST
114633: PUSH
114634: EMPTY
114635: LIST
114636: LIST
114637: PPUSH
114638: CALL_OW 69
114642: ST_TO_ADDR
// if not tmp then
114643: LD_VAR 0 1
114647: NOT
114648: IFFALSE 114652
// exit ;
114650: GO 114665
// DestroyUnit ( tmp [ 1 ] ) ;
114652: LD_VAR 0 1
114656: PUSH
114657: LD_INT 1
114659: ARRAY
114660: PPUSH
114661: CALL_OW 65
// end ;
114665: PPOPN 1
114667: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
114668: LD_EXP 160
114672: PUSH
114673: LD_EXP 198
114677: AND
114678: IFFALSE 114807
114680: GO 114682
114682: DISABLE
114683: LD_INT 0
114685: PPUSH
// begin uc_side := 0 ;
114686: LD_ADDR_OWVAR 20
114690: PUSH
114691: LD_INT 0
114693: ST_TO_ADDR
// uc_nation := nation_arabian ;
114694: LD_ADDR_OWVAR 21
114698: PUSH
114699: LD_INT 2
114701: ST_TO_ADDR
// hc_gallery :=  ;
114702: LD_ADDR_OWVAR 33
114706: PUSH
114707: LD_STRING 
114709: ST_TO_ADDR
// hc_name :=  ;
114710: LD_ADDR_OWVAR 26
114714: PUSH
114715: LD_STRING 
114717: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
114718: LD_INT 1
114720: PPUSH
114721: LD_INT 11
114723: PPUSH
114724: LD_INT 10
114726: PPUSH
114727: CALL_OW 380
// un := CreateHuman ;
114731: LD_ADDR_VAR 0 1
114735: PUSH
114736: CALL_OW 44
114740: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114741: LD_VAR 0 1
114745: PPUSH
114746: LD_INT 1
114748: PPUSH
114749: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
114753: LD_INT 35
114755: PPUSH
114756: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
114760: LD_VAR 0 1
114764: PPUSH
114765: LD_INT 22
114767: PUSH
114768: LD_OWVAR 2
114772: PUSH
114773: EMPTY
114774: LIST
114775: LIST
114776: PPUSH
114777: CALL_OW 69
114781: PPUSH
114782: LD_VAR 0 1
114786: PPUSH
114787: CALL_OW 74
114791: PPUSH
114792: CALL_OW 115
// until IsDead ( un ) ;
114796: LD_VAR 0 1
114800: PPUSH
114801: CALL_OW 301
114805: IFFALSE 114753
// end ;
114807: PPOPN 1
114809: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
114810: LD_EXP 160
114814: PUSH
114815: LD_EXP 200
114819: AND
114820: IFFALSE 114832
114822: GO 114824
114824: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
114825: LD_STRING earthquake(getX(game), 0, 32)
114827: PPUSH
114828: CALL_OW 559
114832: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
114833: LD_EXP 160
114837: PUSH
114838: LD_EXP 201
114842: AND
114843: IFFALSE 114934
114845: GO 114847
114847: DISABLE
114848: LD_INT 0
114850: PPUSH
// begin enable ;
114851: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
114852: LD_ADDR_VAR 0 1
114856: PUSH
114857: LD_INT 22
114859: PUSH
114860: LD_OWVAR 2
114864: PUSH
114865: EMPTY
114866: LIST
114867: LIST
114868: PUSH
114869: LD_INT 21
114871: PUSH
114872: LD_INT 2
114874: PUSH
114875: EMPTY
114876: LIST
114877: LIST
114878: PUSH
114879: LD_INT 33
114881: PUSH
114882: LD_INT 3
114884: PUSH
114885: EMPTY
114886: LIST
114887: LIST
114888: PUSH
114889: EMPTY
114890: LIST
114891: LIST
114892: LIST
114893: PPUSH
114894: CALL_OW 69
114898: ST_TO_ADDR
// if not tmp then
114899: LD_VAR 0 1
114903: NOT
114904: IFFALSE 114908
// exit ;
114906: GO 114934
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114908: LD_VAR 0 1
114912: PUSH
114913: LD_INT 1
114915: PPUSH
114916: LD_VAR 0 1
114920: PPUSH
114921: CALL_OW 12
114925: ARRAY
114926: PPUSH
114927: LD_INT 1
114929: PPUSH
114930: CALL_OW 234
// end ;
114934: PPOPN 1
114936: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
114937: LD_EXP 160
114941: PUSH
114942: LD_EXP 202
114946: AND
114947: IFFALSE 115088
114949: GO 114951
114951: DISABLE
114952: LD_INT 0
114954: PPUSH
114955: PPUSH
114956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114957: LD_ADDR_VAR 0 3
114961: PUSH
114962: LD_INT 22
114964: PUSH
114965: LD_OWVAR 2
114969: PUSH
114970: EMPTY
114971: LIST
114972: LIST
114973: PUSH
114974: LD_INT 25
114976: PUSH
114977: LD_INT 1
114979: PUSH
114980: EMPTY
114981: LIST
114982: LIST
114983: PUSH
114984: EMPTY
114985: LIST
114986: LIST
114987: PPUSH
114988: CALL_OW 69
114992: ST_TO_ADDR
// if not tmp then
114993: LD_VAR 0 3
114997: NOT
114998: IFFALSE 115002
// exit ;
115000: GO 115088
// un := tmp [ rand ( 1 , tmp ) ] ;
115002: LD_ADDR_VAR 0 2
115006: PUSH
115007: LD_VAR 0 3
115011: PUSH
115012: LD_INT 1
115014: PPUSH
115015: LD_VAR 0 3
115019: PPUSH
115020: CALL_OW 12
115024: ARRAY
115025: ST_TO_ADDR
// if Crawls ( un ) then
115026: LD_VAR 0 2
115030: PPUSH
115031: CALL_OW 318
115035: IFFALSE 115046
// ComWalk ( un ) ;
115037: LD_VAR 0 2
115041: PPUSH
115042: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
115046: LD_VAR 0 2
115050: PPUSH
115051: LD_INT 9
115053: PPUSH
115054: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
115058: LD_INT 28
115060: PPUSH
115061: LD_OWVAR 2
115065: PPUSH
115066: LD_INT 2
115068: PPUSH
115069: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
115073: LD_INT 29
115075: PPUSH
115076: LD_OWVAR 2
115080: PPUSH
115081: LD_INT 2
115083: PPUSH
115084: CALL_OW 322
// end ;
115088: PPOPN 3
115090: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
115091: LD_EXP 160
115095: PUSH
115096: LD_EXP 203
115100: AND
115101: IFFALSE 115212
115103: GO 115105
115105: DISABLE
115106: LD_INT 0
115108: PPUSH
115109: PPUSH
115110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115111: LD_ADDR_VAR 0 3
115115: PUSH
115116: LD_INT 22
115118: PUSH
115119: LD_OWVAR 2
115123: PUSH
115124: EMPTY
115125: LIST
115126: LIST
115127: PUSH
115128: LD_INT 25
115130: PUSH
115131: LD_INT 1
115133: PUSH
115134: EMPTY
115135: LIST
115136: LIST
115137: PUSH
115138: EMPTY
115139: LIST
115140: LIST
115141: PPUSH
115142: CALL_OW 69
115146: ST_TO_ADDR
// if not tmp then
115147: LD_VAR 0 3
115151: NOT
115152: IFFALSE 115156
// exit ;
115154: GO 115212
// un := tmp [ rand ( 1 , tmp ) ] ;
115156: LD_ADDR_VAR 0 2
115160: PUSH
115161: LD_VAR 0 3
115165: PUSH
115166: LD_INT 1
115168: PPUSH
115169: LD_VAR 0 3
115173: PPUSH
115174: CALL_OW 12
115178: ARRAY
115179: ST_TO_ADDR
// if Crawls ( un ) then
115180: LD_VAR 0 2
115184: PPUSH
115185: CALL_OW 318
115189: IFFALSE 115200
// ComWalk ( un ) ;
115191: LD_VAR 0 2
115195: PPUSH
115196: CALL_OW 138
// SetClass ( un , class_mortar ) ;
115200: LD_VAR 0 2
115204: PPUSH
115205: LD_INT 8
115207: PPUSH
115208: CALL_OW 336
// end ;
115212: PPOPN 3
115214: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
115215: LD_EXP 160
115219: PUSH
115220: LD_EXP 204
115224: AND
115225: IFFALSE 115369
115227: GO 115229
115229: DISABLE
115230: LD_INT 0
115232: PPUSH
115233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
115234: LD_ADDR_VAR 0 2
115238: PUSH
115239: LD_INT 22
115241: PUSH
115242: LD_OWVAR 2
115246: PUSH
115247: EMPTY
115248: LIST
115249: LIST
115250: PUSH
115251: LD_INT 21
115253: PUSH
115254: LD_INT 2
115256: PUSH
115257: EMPTY
115258: LIST
115259: LIST
115260: PUSH
115261: LD_INT 2
115263: PUSH
115264: LD_INT 34
115266: PUSH
115267: LD_INT 12
115269: PUSH
115270: EMPTY
115271: LIST
115272: LIST
115273: PUSH
115274: LD_INT 34
115276: PUSH
115277: LD_INT 51
115279: PUSH
115280: EMPTY
115281: LIST
115282: LIST
115283: PUSH
115284: LD_INT 34
115286: PUSH
115287: LD_INT 32
115289: PUSH
115290: EMPTY
115291: LIST
115292: LIST
115293: PUSH
115294: EMPTY
115295: LIST
115296: LIST
115297: LIST
115298: LIST
115299: PUSH
115300: EMPTY
115301: LIST
115302: LIST
115303: LIST
115304: PPUSH
115305: CALL_OW 69
115309: ST_TO_ADDR
// if not tmp then
115310: LD_VAR 0 2
115314: NOT
115315: IFFALSE 115319
// exit ;
115317: GO 115369
// for i in tmp do
115319: LD_ADDR_VAR 0 1
115323: PUSH
115324: LD_VAR 0 2
115328: PUSH
115329: FOR_IN
115330: IFFALSE 115367
// if GetCargo ( i , mat_artifact ) = 0 then
115332: LD_VAR 0 1
115336: PPUSH
115337: LD_INT 4
115339: PPUSH
115340: CALL_OW 289
115344: PUSH
115345: LD_INT 0
115347: EQUAL
115348: IFFALSE 115365
// SetCargo ( i , mat_siberit , 100 ) ;
115350: LD_VAR 0 1
115354: PPUSH
115355: LD_INT 3
115357: PPUSH
115358: LD_INT 100
115360: PPUSH
115361: CALL_OW 290
115365: GO 115329
115367: POP
115368: POP
// end ;
115369: PPOPN 2
115371: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
115372: LD_EXP 160
115376: PUSH
115377: LD_EXP 205
115381: AND
115382: IFFALSE 115565
115384: GO 115386
115386: DISABLE
115387: LD_INT 0
115389: PPUSH
115390: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
115391: LD_ADDR_VAR 0 2
115395: PUSH
115396: LD_INT 22
115398: PUSH
115399: LD_OWVAR 2
115403: PUSH
115404: EMPTY
115405: LIST
115406: LIST
115407: PPUSH
115408: CALL_OW 69
115412: ST_TO_ADDR
// if not tmp then
115413: LD_VAR 0 2
115417: NOT
115418: IFFALSE 115422
// exit ;
115420: GO 115565
// for i := 1 to 2 do
115422: LD_ADDR_VAR 0 1
115426: PUSH
115427: DOUBLE
115428: LD_INT 1
115430: DEC
115431: ST_TO_ADDR
115432: LD_INT 2
115434: PUSH
115435: FOR_TO
115436: IFFALSE 115563
// begin uc_side := your_side ;
115438: LD_ADDR_OWVAR 20
115442: PUSH
115443: LD_OWVAR 2
115447: ST_TO_ADDR
// uc_nation := nation_american ;
115448: LD_ADDR_OWVAR 21
115452: PUSH
115453: LD_INT 1
115455: ST_TO_ADDR
// vc_chassis := us_morphling ;
115456: LD_ADDR_OWVAR 37
115460: PUSH
115461: LD_INT 5
115463: ST_TO_ADDR
// vc_engine := engine_siberite ;
115464: LD_ADDR_OWVAR 39
115468: PUSH
115469: LD_INT 3
115471: ST_TO_ADDR
// vc_control := control_computer ;
115472: LD_ADDR_OWVAR 38
115476: PUSH
115477: LD_INT 3
115479: ST_TO_ADDR
// vc_weapon := us_double_laser ;
115480: LD_ADDR_OWVAR 40
115484: PUSH
115485: LD_INT 10
115487: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
115488: LD_VAR 0 2
115492: PUSH
115493: LD_INT 1
115495: ARRAY
115496: PPUSH
115497: CALL_OW 310
115501: NOT
115502: IFFALSE 115549
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
115504: CALL_OW 45
115508: PPUSH
115509: LD_VAR 0 2
115513: PUSH
115514: LD_INT 1
115516: ARRAY
115517: PPUSH
115518: CALL_OW 250
115522: PPUSH
115523: LD_VAR 0 2
115527: PUSH
115528: LD_INT 1
115530: ARRAY
115531: PPUSH
115532: CALL_OW 251
115536: PPUSH
115537: LD_INT 12
115539: PPUSH
115540: LD_INT 1
115542: PPUSH
115543: CALL_OW 50
115547: GO 115561
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
115549: CALL_OW 45
115553: PPUSH
115554: LD_INT 1
115556: PPUSH
115557: CALL_OW 51
// end ;
115561: GO 115435
115563: POP
115564: POP
// end ;
115565: PPOPN 2
115567: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
115568: LD_EXP 160
115572: PUSH
115573: LD_EXP 206
115577: AND
115578: IFFALSE 115800
115580: GO 115582
115582: DISABLE
115583: LD_INT 0
115585: PPUSH
115586: PPUSH
115587: PPUSH
115588: PPUSH
115589: PPUSH
115590: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115591: LD_ADDR_VAR 0 6
115595: PUSH
115596: LD_INT 22
115598: PUSH
115599: LD_OWVAR 2
115603: PUSH
115604: EMPTY
115605: LIST
115606: LIST
115607: PUSH
115608: LD_INT 21
115610: PUSH
115611: LD_INT 1
115613: PUSH
115614: EMPTY
115615: LIST
115616: LIST
115617: PUSH
115618: LD_INT 3
115620: PUSH
115621: LD_INT 23
115623: PUSH
115624: LD_INT 0
115626: PUSH
115627: EMPTY
115628: LIST
115629: LIST
115630: PUSH
115631: EMPTY
115632: LIST
115633: LIST
115634: PUSH
115635: EMPTY
115636: LIST
115637: LIST
115638: LIST
115639: PPUSH
115640: CALL_OW 69
115644: ST_TO_ADDR
// if not tmp then
115645: LD_VAR 0 6
115649: NOT
115650: IFFALSE 115654
// exit ;
115652: GO 115800
// s1 := rand ( 1 , 4 ) ;
115654: LD_ADDR_VAR 0 2
115658: PUSH
115659: LD_INT 1
115661: PPUSH
115662: LD_INT 4
115664: PPUSH
115665: CALL_OW 12
115669: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
115670: LD_ADDR_VAR 0 4
115674: PUSH
115675: LD_VAR 0 6
115679: PUSH
115680: LD_INT 1
115682: ARRAY
115683: PPUSH
115684: LD_VAR 0 2
115688: PPUSH
115689: CALL_OW 259
115693: ST_TO_ADDR
// if s1 = 1 then
115694: LD_VAR 0 2
115698: PUSH
115699: LD_INT 1
115701: EQUAL
115702: IFFALSE 115722
// s2 := rand ( 2 , 4 ) else
115704: LD_ADDR_VAR 0 3
115708: PUSH
115709: LD_INT 2
115711: PPUSH
115712: LD_INT 4
115714: PPUSH
115715: CALL_OW 12
115719: ST_TO_ADDR
115720: GO 115730
// s2 := 1 ;
115722: LD_ADDR_VAR 0 3
115726: PUSH
115727: LD_INT 1
115729: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
115730: LD_ADDR_VAR 0 5
115734: PUSH
115735: LD_VAR 0 6
115739: PUSH
115740: LD_INT 1
115742: ARRAY
115743: PPUSH
115744: LD_VAR 0 3
115748: PPUSH
115749: CALL_OW 259
115753: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
115754: LD_VAR 0 6
115758: PUSH
115759: LD_INT 1
115761: ARRAY
115762: PPUSH
115763: LD_VAR 0 2
115767: PPUSH
115768: LD_VAR 0 5
115772: PPUSH
115773: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
115777: LD_VAR 0 6
115781: PUSH
115782: LD_INT 1
115784: ARRAY
115785: PPUSH
115786: LD_VAR 0 3
115790: PPUSH
115791: LD_VAR 0 4
115795: PPUSH
115796: CALL_OW 237
// end ;
115800: PPOPN 6
115802: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
115803: LD_EXP 160
115807: PUSH
115808: LD_EXP 207
115812: AND
115813: IFFALSE 115892
115815: GO 115817
115817: DISABLE
115818: LD_INT 0
115820: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
115821: LD_ADDR_VAR 0 1
115825: PUSH
115826: LD_INT 22
115828: PUSH
115829: LD_OWVAR 2
115833: PUSH
115834: EMPTY
115835: LIST
115836: LIST
115837: PUSH
115838: LD_INT 30
115840: PUSH
115841: LD_INT 3
115843: PUSH
115844: EMPTY
115845: LIST
115846: LIST
115847: PUSH
115848: EMPTY
115849: LIST
115850: LIST
115851: PPUSH
115852: CALL_OW 69
115856: ST_TO_ADDR
// if not tmp then
115857: LD_VAR 0 1
115861: NOT
115862: IFFALSE 115866
// exit ;
115864: GO 115892
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
115866: LD_VAR 0 1
115870: PUSH
115871: LD_INT 1
115873: PPUSH
115874: LD_VAR 0 1
115878: PPUSH
115879: CALL_OW 12
115883: ARRAY
115884: PPUSH
115885: LD_INT 1
115887: PPUSH
115888: CALL_OW 234
// end ;
115892: PPOPN 1
115894: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
115895: LD_EXP 160
115899: PUSH
115900: LD_EXP 208
115904: AND
115905: IFFALSE 116017
115907: GO 115909
115909: DISABLE
115910: LD_INT 0
115912: PPUSH
115913: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
115914: LD_ADDR_VAR 0 2
115918: PUSH
115919: LD_INT 22
115921: PUSH
115922: LD_OWVAR 2
115926: PUSH
115927: EMPTY
115928: LIST
115929: LIST
115930: PUSH
115931: LD_INT 2
115933: PUSH
115934: LD_INT 30
115936: PUSH
115937: LD_INT 27
115939: PUSH
115940: EMPTY
115941: LIST
115942: LIST
115943: PUSH
115944: LD_INT 30
115946: PUSH
115947: LD_INT 26
115949: PUSH
115950: EMPTY
115951: LIST
115952: LIST
115953: PUSH
115954: LD_INT 30
115956: PUSH
115957: LD_INT 28
115959: PUSH
115960: EMPTY
115961: LIST
115962: LIST
115963: PUSH
115964: EMPTY
115965: LIST
115966: LIST
115967: LIST
115968: LIST
115969: PUSH
115970: EMPTY
115971: LIST
115972: LIST
115973: PPUSH
115974: CALL_OW 69
115978: ST_TO_ADDR
// if not tmp then
115979: LD_VAR 0 2
115983: NOT
115984: IFFALSE 115988
// exit ;
115986: GO 116017
// for i in tmp do
115988: LD_ADDR_VAR 0 1
115992: PUSH
115993: LD_VAR 0 2
115997: PUSH
115998: FOR_IN
115999: IFFALSE 116015
// SetLives ( i , 1 ) ;
116001: LD_VAR 0 1
116005: PPUSH
116006: LD_INT 1
116008: PPUSH
116009: CALL_OW 234
116013: GO 115998
116015: POP
116016: POP
// end ;
116017: PPOPN 2
116019: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
116020: LD_EXP 160
116024: PUSH
116025: LD_EXP 209
116029: AND
116030: IFFALSE 116317
116032: GO 116034
116034: DISABLE
116035: LD_INT 0
116037: PPUSH
116038: PPUSH
116039: PPUSH
// begin i := rand ( 1 , 7 ) ;
116040: LD_ADDR_VAR 0 1
116044: PUSH
116045: LD_INT 1
116047: PPUSH
116048: LD_INT 7
116050: PPUSH
116051: CALL_OW 12
116055: ST_TO_ADDR
// case i of 1 :
116056: LD_VAR 0 1
116060: PUSH
116061: LD_INT 1
116063: DOUBLE
116064: EQUAL
116065: IFTRUE 116069
116067: GO 116079
116069: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
116070: LD_STRING earthquake(getX(game), 0, 32)
116072: PPUSH
116073: CALL_OW 559
116077: GO 116317
116079: LD_INT 2
116081: DOUBLE
116082: EQUAL
116083: IFTRUE 116087
116085: GO 116101
116087: POP
// begin ToLua ( displayStucuk(); ) ;
116088: LD_STRING displayStucuk();
116090: PPUSH
116091: CALL_OW 559
// ResetFog ;
116095: CALL_OW 335
// end ; 3 :
116099: GO 116317
116101: LD_INT 3
116103: DOUBLE
116104: EQUAL
116105: IFTRUE 116109
116107: GO 116213
116109: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116110: LD_ADDR_VAR 0 2
116114: PUSH
116115: LD_INT 22
116117: PUSH
116118: LD_OWVAR 2
116122: PUSH
116123: EMPTY
116124: LIST
116125: LIST
116126: PUSH
116127: LD_INT 25
116129: PUSH
116130: LD_INT 1
116132: PUSH
116133: EMPTY
116134: LIST
116135: LIST
116136: PUSH
116137: EMPTY
116138: LIST
116139: LIST
116140: PPUSH
116141: CALL_OW 69
116145: ST_TO_ADDR
// if not tmp then
116146: LD_VAR 0 2
116150: NOT
116151: IFFALSE 116155
// exit ;
116153: GO 116317
// un := tmp [ rand ( 1 , tmp ) ] ;
116155: LD_ADDR_VAR 0 3
116159: PUSH
116160: LD_VAR 0 2
116164: PUSH
116165: LD_INT 1
116167: PPUSH
116168: LD_VAR 0 2
116172: PPUSH
116173: CALL_OW 12
116177: ARRAY
116178: ST_TO_ADDR
// if Crawls ( un ) then
116179: LD_VAR 0 3
116183: PPUSH
116184: CALL_OW 318
116188: IFFALSE 116199
// ComWalk ( un ) ;
116190: LD_VAR 0 3
116194: PPUSH
116195: CALL_OW 138
// SetClass ( un , class_mortar ) ;
116199: LD_VAR 0 3
116203: PPUSH
116204: LD_INT 8
116206: PPUSH
116207: CALL_OW 336
// end ; 4 :
116211: GO 116317
116213: LD_INT 4
116215: DOUBLE
116216: EQUAL
116217: IFTRUE 116221
116219: GO 116295
116221: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116222: LD_ADDR_VAR 0 2
116226: PUSH
116227: LD_INT 22
116229: PUSH
116230: LD_OWVAR 2
116234: PUSH
116235: EMPTY
116236: LIST
116237: LIST
116238: PUSH
116239: LD_INT 30
116241: PUSH
116242: LD_INT 29
116244: PUSH
116245: EMPTY
116246: LIST
116247: LIST
116248: PUSH
116249: EMPTY
116250: LIST
116251: LIST
116252: PPUSH
116253: CALL_OW 69
116257: ST_TO_ADDR
// if not tmp then
116258: LD_VAR 0 2
116262: NOT
116263: IFFALSE 116267
// exit ;
116265: GO 116317
// CenterNowOnUnits ( tmp [ 1 ] ) ;
116267: LD_VAR 0 2
116271: PUSH
116272: LD_INT 1
116274: ARRAY
116275: PPUSH
116276: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
116280: LD_VAR 0 2
116284: PUSH
116285: LD_INT 1
116287: ARRAY
116288: PPUSH
116289: CALL_OW 65
// end ; 5 .. 7 :
116293: GO 116317
116295: LD_INT 5
116297: DOUBLE
116298: GREATEREQUAL
116299: IFFALSE 116307
116301: LD_INT 7
116303: DOUBLE
116304: LESSEQUAL
116305: IFTRUE 116309
116307: GO 116316
116309: POP
// StreamSibBomb ; end ;
116310: CALL 112554 0 0
116314: GO 116317
116316: POP
// end ;
116317: PPOPN 3
116319: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
116320: LD_EXP 160
116324: PUSH
116325: LD_EXP 210
116329: AND
116330: IFFALSE 116486
116332: GO 116334
116334: DISABLE
116335: LD_INT 0
116337: PPUSH
116338: PPUSH
116339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
116340: LD_ADDR_VAR 0 2
116344: PUSH
116345: LD_INT 81
116347: PUSH
116348: LD_OWVAR 2
116352: PUSH
116353: EMPTY
116354: LIST
116355: LIST
116356: PUSH
116357: LD_INT 2
116359: PUSH
116360: LD_INT 21
116362: PUSH
116363: LD_INT 1
116365: PUSH
116366: EMPTY
116367: LIST
116368: LIST
116369: PUSH
116370: LD_INT 21
116372: PUSH
116373: LD_INT 2
116375: PUSH
116376: EMPTY
116377: LIST
116378: LIST
116379: PUSH
116380: EMPTY
116381: LIST
116382: LIST
116383: LIST
116384: PUSH
116385: EMPTY
116386: LIST
116387: LIST
116388: PPUSH
116389: CALL_OW 69
116393: ST_TO_ADDR
// if not tmp then
116394: LD_VAR 0 2
116398: NOT
116399: IFFALSE 116403
// exit ;
116401: GO 116486
// p := 0 ;
116403: LD_ADDR_VAR 0 3
116407: PUSH
116408: LD_INT 0
116410: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116411: LD_INT 35
116413: PPUSH
116414: CALL_OW 67
// p := p + 1 ;
116418: LD_ADDR_VAR 0 3
116422: PUSH
116423: LD_VAR 0 3
116427: PUSH
116428: LD_INT 1
116430: PLUS
116431: ST_TO_ADDR
// for i in tmp do
116432: LD_ADDR_VAR 0 1
116436: PUSH
116437: LD_VAR 0 2
116441: PUSH
116442: FOR_IN
116443: IFFALSE 116474
// if GetLives ( i ) < 1000 then
116445: LD_VAR 0 1
116449: PPUSH
116450: CALL_OW 256
116454: PUSH
116455: LD_INT 1000
116457: LESS
116458: IFFALSE 116472
// SetLives ( i , 1000 ) ;
116460: LD_VAR 0 1
116464: PPUSH
116465: LD_INT 1000
116467: PPUSH
116468: CALL_OW 234
116472: GO 116442
116474: POP
116475: POP
// until p > 20 ;
116476: LD_VAR 0 3
116480: PUSH
116481: LD_INT 20
116483: GREATER
116484: IFFALSE 116411
// end ;
116486: PPOPN 3
116488: END
// every 0 0$1 trigger StreamModeActive and sTime do
116489: LD_EXP 160
116493: PUSH
116494: LD_EXP 211
116498: AND
116499: IFFALSE 116534
116501: GO 116503
116503: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
116504: LD_INT 28
116506: PPUSH
116507: LD_OWVAR 2
116511: PPUSH
116512: LD_INT 2
116514: PPUSH
116515: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
116519: LD_INT 30
116521: PPUSH
116522: LD_OWVAR 2
116526: PPUSH
116527: LD_INT 2
116529: PPUSH
116530: CALL_OW 322
// end ;
116534: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
116535: LD_EXP 160
116539: PUSH
116540: LD_EXP 212
116544: AND
116545: IFFALSE 116666
116547: GO 116549
116549: DISABLE
116550: LD_INT 0
116552: PPUSH
116553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
116554: LD_ADDR_VAR 0 2
116558: PUSH
116559: LD_INT 22
116561: PUSH
116562: LD_OWVAR 2
116566: PUSH
116567: EMPTY
116568: LIST
116569: LIST
116570: PUSH
116571: LD_INT 21
116573: PUSH
116574: LD_INT 1
116576: PUSH
116577: EMPTY
116578: LIST
116579: LIST
116580: PUSH
116581: LD_INT 3
116583: PUSH
116584: LD_INT 23
116586: PUSH
116587: LD_INT 0
116589: PUSH
116590: EMPTY
116591: LIST
116592: LIST
116593: PUSH
116594: EMPTY
116595: LIST
116596: LIST
116597: PUSH
116598: EMPTY
116599: LIST
116600: LIST
116601: LIST
116602: PPUSH
116603: CALL_OW 69
116607: ST_TO_ADDR
// if not tmp then
116608: LD_VAR 0 2
116612: NOT
116613: IFFALSE 116617
// exit ;
116615: GO 116666
// for i in tmp do
116617: LD_ADDR_VAR 0 1
116621: PUSH
116622: LD_VAR 0 2
116626: PUSH
116627: FOR_IN
116628: IFFALSE 116664
// begin if Crawls ( i ) then
116630: LD_VAR 0 1
116634: PPUSH
116635: CALL_OW 318
116639: IFFALSE 116650
// ComWalk ( i ) ;
116641: LD_VAR 0 1
116645: PPUSH
116646: CALL_OW 138
// SetClass ( i , 2 ) ;
116650: LD_VAR 0 1
116654: PPUSH
116655: LD_INT 2
116657: PPUSH
116658: CALL_OW 336
// end ;
116662: GO 116627
116664: POP
116665: POP
// end ;
116666: PPOPN 2
116668: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
116669: LD_EXP 160
116673: PUSH
116674: LD_EXP 213
116678: AND
116679: IFFALSE 116967
116681: GO 116683
116683: DISABLE
116684: LD_INT 0
116686: PPUSH
116687: PPUSH
116688: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
116689: LD_OWVAR 2
116693: PPUSH
116694: LD_INT 9
116696: PPUSH
116697: LD_INT 1
116699: PPUSH
116700: LD_INT 1
116702: PPUSH
116703: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
116707: LD_INT 9
116709: PPUSH
116710: LD_OWVAR 2
116714: PPUSH
116715: CALL_OW 343
// uc_side := 9 ;
116719: LD_ADDR_OWVAR 20
116723: PUSH
116724: LD_INT 9
116726: ST_TO_ADDR
// uc_nation := 2 ;
116727: LD_ADDR_OWVAR 21
116731: PUSH
116732: LD_INT 2
116734: ST_TO_ADDR
// hc_name := Dark Warrior ;
116735: LD_ADDR_OWVAR 26
116739: PUSH
116740: LD_STRING Dark Warrior
116742: ST_TO_ADDR
// hc_gallery :=  ;
116743: LD_ADDR_OWVAR 33
116747: PUSH
116748: LD_STRING 
116750: ST_TO_ADDR
// hc_noskilllimit := true ;
116751: LD_ADDR_OWVAR 76
116755: PUSH
116756: LD_INT 1
116758: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
116759: LD_ADDR_OWVAR 31
116763: PUSH
116764: LD_INT 30
116766: PUSH
116767: LD_INT 30
116769: PUSH
116770: LD_INT 30
116772: PUSH
116773: LD_INT 30
116775: PUSH
116776: EMPTY
116777: LIST
116778: LIST
116779: LIST
116780: LIST
116781: ST_TO_ADDR
// un := CreateHuman ;
116782: LD_ADDR_VAR 0 3
116786: PUSH
116787: CALL_OW 44
116791: ST_TO_ADDR
// hc_noskilllimit := false ;
116792: LD_ADDR_OWVAR 76
116796: PUSH
116797: LD_INT 0
116799: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116800: LD_VAR 0 3
116804: PPUSH
116805: LD_INT 1
116807: PPUSH
116808: CALL_OW 51
// ToLua ( playRanger() ) ;
116812: LD_STRING playRanger()
116814: PPUSH
116815: CALL_OW 559
// p := 0 ;
116819: LD_ADDR_VAR 0 2
116823: PUSH
116824: LD_INT 0
116826: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116827: LD_INT 35
116829: PPUSH
116830: CALL_OW 67
// p := p + 1 ;
116834: LD_ADDR_VAR 0 2
116838: PUSH
116839: LD_VAR 0 2
116843: PUSH
116844: LD_INT 1
116846: PLUS
116847: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
116848: LD_VAR 0 3
116852: PPUSH
116853: CALL_OW 256
116857: PUSH
116858: LD_INT 1000
116860: LESS
116861: IFFALSE 116875
// SetLives ( un , 1000 ) ;
116863: LD_VAR 0 3
116867: PPUSH
116868: LD_INT 1000
116870: PPUSH
116871: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
116875: LD_VAR 0 3
116879: PPUSH
116880: LD_INT 81
116882: PUSH
116883: LD_OWVAR 2
116887: PUSH
116888: EMPTY
116889: LIST
116890: LIST
116891: PUSH
116892: LD_INT 91
116894: PUSH
116895: LD_VAR 0 3
116899: PUSH
116900: LD_INT 30
116902: PUSH
116903: EMPTY
116904: LIST
116905: LIST
116906: LIST
116907: PUSH
116908: EMPTY
116909: LIST
116910: LIST
116911: PPUSH
116912: CALL_OW 69
116916: PPUSH
116917: LD_VAR 0 3
116921: PPUSH
116922: CALL_OW 74
116926: PPUSH
116927: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
116931: LD_VAR 0 2
116935: PUSH
116936: LD_INT 80
116938: GREATER
116939: PUSH
116940: LD_VAR 0 3
116944: PPUSH
116945: CALL_OW 301
116949: OR
116950: IFFALSE 116827
// if un then
116952: LD_VAR 0 3
116956: IFFALSE 116967
// RemoveUnit ( un ) ;
116958: LD_VAR 0 3
116962: PPUSH
116963: CALL_OW 64
// end ;
116967: PPOPN 3
116969: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
116970: LD_EXP 214
116974: IFFALSE 117090
116976: GO 116978
116978: DISABLE
116979: LD_INT 0
116981: PPUSH
116982: PPUSH
116983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
116984: LD_ADDR_VAR 0 2
116988: PUSH
116989: LD_INT 81
116991: PUSH
116992: LD_OWVAR 2
116996: PUSH
116997: EMPTY
116998: LIST
116999: LIST
117000: PUSH
117001: LD_INT 21
117003: PUSH
117004: LD_INT 1
117006: PUSH
117007: EMPTY
117008: LIST
117009: LIST
117010: PUSH
117011: EMPTY
117012: LIST
117013: LIST
117014: PPUSH
117015: CALL_OW 69
117019: ST_TO_ADDR
// if not tmp then
117020: LD_VAR 0 2
117024: NOT
117025: IFFALSE 117029
// exit ;
117027: GO 117090
// ToLua ( playComputer() ) ;
117029: LD_STRING playComputer()
117031: PPUSH
117032: CALL_OW 559
// for i in tmp do
117036: LD_ADDR_VAR 0 1
117040: PUSH
117041: LD_VAR 0 2
117045: PUSH
117046: FOR_IN
117047: IFFALSE 117088
// for j := 1 to 4 do
117049: LD_ADDR_VAR 0 3
117053: PUSH
117054: DOUBLE
117055: LD_INT 1
117057: DEC
117058: ST_TO_ADDR
117059: LD_INT 4
117061: PUSH
117062: FOR_TO
117063: IFFALSE 117084
// SetSkill ( i , j , 10 ) ;
117065: LD_VAR 0 1
117069: PPUSH
117070: LD_VAR 0 3
117074: PPUSH
117075: LD_INT 10
117077: PPUSH
117078: CALL_OW 237
117082: GO 117062
117084: POP
117085: POP
117086: GO 117046
117088: POP
117089: POP
// end ;
117090: PPOPN 3
117092: END
// every 0 0$1 trigger s30 do var i , tmp ;
117093: LD_EXP 215
117097: IFFALSE 117166
117099: GO 117101
117101: DISABLE
117102: LD_INT 0
117104: PPUSH
117105: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117106: LD_ADDR_VAR 0 2
117110: PUSH
117111: LD_INT 22
117113: PUSH
117114: LD_OWVAR 2
117118: PUSH
117119: EMPTY
117120: LIST
117121: LIST
117122: PPUSH
117123: CALL_OW 69
117127: ST_TO_ADDR
// if not tmp then
117128: LD_VAR 0 2
117132: NOT
117133: IFFALSE 117137
// exit ;
117135: GO 117166
// for i in tmp do
117137: LD_ADDR_VAR 0 1
117141: PUSH
117142: LD_VAR 0 2
117146: PUSH
117147: FOR_IN
117148: IFFALSE 117164
// SetLives ( i , 300 ) ;
117150: LD_VAR 0 1
117154: PPUSH
117155: LD_INT 300
117157: PPUSH
117158: CALL_OW 234
117162: GO 117147
117164: POP
117165: POP
// end ;
117166: PPOPN 2
117168: END
// every 0 0$1 trigger s60 do var i , tmp ;
117169: LD_EXP 216
117173: IFFALSE 117242
117175: GO 117177
117177: DISABLE
117178: LD_INT 0
117180: PPUSH
117181: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117182: LD_ADDR_VAR 0 2
117186: PUSH
117187: LD_INT 22
117189: PUSH
117190: LD_OWVAR 2
117194: PUSH
117195: EMPTY
117196: LIST
117197: LIST
117198: PPUSH
117199: CALL_OW 69
117203: ST_TO_ADDR
// if not tmp then
117204: LD_VAR 0 2
117208: NOT
117209: IFFALSE 117213
// exit ;
117211: GO 117242
// for i in tmp do
117213: LD_ADDR_VAR 0 1
117217: PUSH
117218: LD_VAR 0 2
117222: PUSH
117223: FOR_IN
117224: IFFALSE 117240
// SetLives ( i , 600 ) ;
117226: LD_VAR 0 1
117230: PPUSH
117231: LD_INT 600
117233: PPUSH
117234: CALL_OW 234
117238: GO 117223
117240: POP
117241: POP
// end ;
117242: PPOPN 2
117244: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
117245: LD_INT 0
117247: PPUSH
// case cmd of 301 :
117248: LD_VAR 0 1
117252: PUSH
117253: LD_INT 301
117255: DOUBLE
117256: EQUAL
117257: IFTRUE 117261
117259: GO 117293
117261: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
117262: LD_VAR 0 6
117266: PPUSH
117267: LD_VAR 0 7
117271: PPUSH
117272: LD_VAR 0 8
117276: PPUSH
117277: LD_VAR 0 4
117281: PPUSH
117282: LD_VAR 0 5
117286: PPUSH
117287: CALL 118494 0 5
117291: GO 117414
117293: LD_INT 302
117295: DOUBLE
117296: EQUAL
117297: IFTRUE 117301
117299: GO 117338
117301: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
117302: LD_VAR 0 6
117306: PPUSH
117307: LD_VAR 0 7
117311: PPUSH
117312: LD_VAR 0 8
117316: PPUSH
117317: LD_VAR 0 9
117321: PPUSH
117322: LD_VAR 0 4
117326: PPUSH
117327: LD_VAR 0 5
117331: PPUSH
117332: CALL 118585 0 6
117336: GO 117414
117338: LD_INT 303
117340: DOUBLE
117341: EQUAL
117342: IFTRUE 117346
117344: GO 117383
117346: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
117347: LD_VAR 0 6
117351: PPUSH
117352: LD_VAR 0 7
117356: PPUSH
117357: LD_VAR 0 8
117361: PPUSH
117362: LD_VAR 0 9
117366: PPUSH
117367: LD_VAR 0 4
117371: PPUSH
117372: LD_VAR 0 5
117376: PPUSH
117377: CALL 117419 0 6
117381: GO 117414
117383: LD_INT 304
117385: DOUBLE
117386: EQUAL
117387: IFTRUE 117391
117389: GO 117413
117391: POP
// hHackTeleport ( unit , x , y ) ; end ;
117392: LD_VAR 0 2
117396: PPUSH
117397: LD_VAR 0 4
117401: PPUSH
117402: LD_VAR 0 5
117406: PPUSH
117407: CALL 119178 0 3
117411: GO 117414
117413: POP
// end ;
117414: LD_VAR 0 12
117418: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
117419: LD_INT 0
117421: PPUSH
117422: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
117423: LD_VAR 0 1
117427: PUSH
117428: LD_INT 1
117430: LESS
117431: PUSH
117432: LD_VAR 0 1
117436: PUSH
117437: LD_INT 3
117439: GREATER
117440: OR
117441: PUSH
117442: LD_VAR 0 5
117446: PPUSH
117447: LD_VAR 0 6
117451: PPUSH
117452: CALL_OW 428
117456: OR
117457: IFFALSE 117461
// exit ;
117459: GO 118181
// uc_side := your_side ;
117461: LD_ADDR_OWVAR 20
117465: PUSH
117466: LD_OWVAR 2
117470: ST_TO_ADDR
// uc_nation := nation ;
117471: LD_ADDR_OWVAR 21
117475: PUSH
117476: LD_VAR 0 1
117480: ST_TO_ADDR
// bc_level = 1 ;
117481: LD_ADDR_OWVAR 43
117485: PUSH
117486: LD_INT 1
117488: ST_TO_ADDR
// case btype of 1 :
117489: LD_VAR 0 2
117493: PUSH
117494: LD_INT 1
117496: DOUBLE
117497: EQUAL
117498: IFTRUE 117502
117500: GO 117513
117502: POP
// bc_type := b_depot ; 2 :
117503: LD_ADDR_OWVAR 42
117507: PUSH
117508: LD_INT 0
117510: ST_TO_ADDR
117511: GO 118125
117513: LD_INT 2
117515: DOUBLE
117516: EQUAL
117517: IFTRUE 117521
117519: GO 117532
117521: POP
// bc_type := b_warehouse ; 3 :
117522: LD_ADDR_OWVAR 42
117526: PUSH
117527: LD_INT 1
117529: ST_TO_ADDR
117530: GO 118125
117532: LD_INT 3
117534: DOUBLE
117535: EQUAL
117536: IFTRUE 117540
117538: GO 117551
117540: POP
// bc_type := b_lab ; 4 .. 9 :
117541: LD_ADDR_OWVAR 42
117545: PUSH
117546: LD_INT 6
117548: ST_TO_ADDR
117549: GO 118125
117551: LD_INT 4
117553: DOUBLE
117554: GREATEREQUAL
117555: IFFALSE 117563
117557: LD_INT 9
117559: DOUBLE
117560: LESSEQUAL
117561: IFTRUE 117565
117563: GO 117617
117565: POP
// begin bc_type := b_lab_half ;
117566: LD_ADDR_OWVAR 42
117570: PUSH
117571: LD_INT 7
117573: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
117574: LD_ADDR_OWVAR 44
117578: PUSH
117579: LD_INT 10
117581: PUSH
117582: LD_INT 11
117584: PUSH
117585: LD_INT 12
117587: PUSH
117588: LD_INT 15
117590: PUSH
117591: LD_INT 14
117593: PUSH
117594: LD_INT 13
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: PUSH
117605: LD_VAR 0 2
117609: PUSH
117610: LD_INT 3
117612: MINUS
117613: ARRAY
117614: ST_TO_ADDR
// end ; 10 .. 13 :
117615: GO 118125
117617: LD_INT 10
117619: DOUBLE
117620: GREATEREQUAL
117621: IFFALSE 117629
117623: LD_INT 13
117625: DOUBLE
117626: LESSEQUAL
117627: IFTRUE 117631
117629: GO 117708
117631: POP
// begin bc_type := b_lab_full ;
117632: LD_ADDR_OWVAR 42
117636: PUSH
117637: LD_INT 8
117639: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
117640: LD_ADDR_OWVAR 44
117644: PUSH
117645: LD_INT 10
117647: PUSH
117648: LD_INT 12
117650: PUSH
117651: LD_INT 14
117653: PUSH
117654: LD_INT 13
117656: PUSH
117657: EMPTY
117658: LIST
117659: LIST
117660: LIST
117661: LIST
117662: PUSH
117663: LD_VAR 0 2
117667: PUSH
117668: LD_INT 9
117670: MINUS
117671: ARRAY
117672: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
117673: LD_ADDR_OWVAR 45
117677: PUSH
117678: LD_INT 11
117680: PUSH
117681: LD_INT 15
117683: PUSH
117684: LD_INT 12
117686: PUSH
117687: LD_INT 15
117689: PUSH
117690: EMPTY
117691: LIST
117692: LIST
117693: LIST
117694: LIST
117695: PUSH
117696: LD_VAR 0 2
117700: PUSH
117701: LD_INT 9
117703: MINUS
117704: ARRAY
117705: ST_TO_ADDR
// end ; 14 :
117706: GO 118125
117708: LD_INT 14
117710: DOUBLE
117711: EQUAL
117712: IFTRUE 117716
117714: GO 117727
117716: POP
// bc_type := b_workshop ; 15 :
117717: LD_ADDR_OWVAR 42
117721: PUSH
117722: LD_INT 2
117724: ST_TO_ADDR
117725: GO 118125
117727: LD_INT 15
117729: DOUBLE
117730: EQUAL
117731: IFTRUE 117735
117733: GO 117746
117735: POP
// bc_type := b_factory ; 16 :
117736: LD_ADDR_OWVAR 42
117740: PUSH
117741: LD_INT 3
117743: ST_TO_ADDR
117744: GO 118125
117746: LD_INT 16
117748: DOUBLE
117749: EQUAL
117750: IFTRUE 117754
117752: GO 117765
117754: POP
// bc_type := b_ext_gun ; 17 :
117755: LD_ADDR_OWVAR 42
117759: PUSH
117760: LD_INT 17
117762: ST_TO_ADDR
117763: GO 118125
117765: LD_INT 17
117767: DOUBLE
117768: EQUAL
117769: IFTRUE 117773
117771: GO 117801
117773: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
117774: LD_ADDR_OWVAR 42
117778: PUSH
117779: LD_INT 19
117781: PUSH
117782: LD_INT 23
117784: PUSH
117785: LD_INT 19
117787: PUSH
117788: EMPTY
117789: LIST
117790: LIST
117791: LIST
117792: PUSH
117793: LD_VAR 0 1
117797: ARRAY
117798: ST_TO_ADDR
117799: GO 118125
117801: LD_INT 18
117803: DOUBLE
117804: EQUAL
117805: IFTRUE 117809
117807: GO 117820
117809: POP
// bc_type := b_ext_radar ; 19 :
117810: LD_ADDR_OWVAR 42
117814: PUSH
117815: LD_INT 20
117817: ST_TO_ADDR
117818: GO 118125
117820: LD_INT 19
117822: DOUBLE
117823: EQUAL
117824: IFTRUE 117828
117826: GO 117839
117828: POP
// bc_type := b_ext_radio ; 20 :
117829: LD_ADDR_OWVAR 42
117833: PUSH
117834: LD_INT 22
117836: ST_TO_ADDR
117837: GO 118125
117839: LD_INT 20
117841: DOUBLE
117842: EQUAL
117843: IFTRUE 117847
117845: GO 117858
117847: POP
// bc_type := b_ext_siberium ; 21 :
117848: LD_ADDR_OWVAR 42
117852: PUSH
117853: LD_INT 21
117855: ST_TO_ADDR
117856: GO 118125
117858: LD_INT 21
117860: DOUBLE
117861: EQUAL
117862: IFTRUE 117866
117864: GO 117877
117866: POP
// bc_type := b_ext_computer ; 22 :
117867: LD_ADDR_OWVAR 42
117871: PUSH
117872: LD_INT 24
117874: ST_TO_ADDR
117875: GO 118125
117877: LD_INT 22
117879: DOUBLE
117880: EQUAL
117881: IFTRUE 117885
117883: GO 117896
117885: POP
// bc_type := b_ext_track ; 23 :
117886: LD_ADDR_OWVAR 42
117890: PUSH
117891: LD_INT 16
117893: ST_TO_ADDR
117894: GO 118125
117896: LD_INT 23
117898: DOUBLE
117899: EQUAL
117900: IFTRUE 117904
117902: GO 117915
117904: POP
// bc_type := b_ext_laser ; 24 :
117905: LD_ADDR_OWVAR 42
117909: PUSH
117910: LD_INT 25
117912: ST_TO_ADDR
117913: GO 118125
117915: LD_INT 24
117917: DOUBLE
117918: EQUAL
117919: IFTRUE 117923
117921: GO 117934
117923: POP
// bc_type := b_control_tower ; 25 :
117924: LD_ADDR_OWVAR 42
117928: PUSH
117929: LD_INT 36
117931: ST_TO_ADDR
117932: GO 118125
117934: LD_INT 25
117936: DOUBLE
117937: EQUAL
117938: IFTRUE 117942
117940: GO 117953
117942: POP
// bc_type := b_breastwork ; 26 :
117943: LD_ADDR_OWVAR 42
117947: PUSH
117948: LD_INT 31
117950: ST_TO_ADDR
117951: GO 118125
117953: LD_INT 26
117955: DOUBLE
117956: EQUAL
117957: IFTRUE 117961
117959: GO 117972
117961: POP
// bc_type := b_bunker ; 27 :
117962: LD_ADDR_OWVAR 42
117966: PUSH
117967: LD_INT 32
117969: ST_TO_ADDR
117970: GO 118125
117972: LD_INT 27
117974: DOUBLE
117975: EQUAL
117976: IFTRUE 117980
117978: GO 117991
117980: POP
// bc_type := b_turret ; 28 :
117981: LD_ADDR_OWVAR 42
117985: PUSH
117986: LD_INT 33
117988: ST_TO_ADDR
117989: GO 118125
117991: LD_INT 28
117993: DOUBLE
117994: EQUAL
117995: IFTRUE 117999
117997: GO 118010
117999: POP
// bc_type := b_armoury ; 29 :
118000: LD_ADDR_OWVAR 42
118004: PUSH
118005: LD_INT 4
118007: ST_TO_ADDR
118008: GO 118125
118010: LD_INT 29
118012: DOUBLE
118013: EQUAL
118014: IFTRUE 118018
118016: GO 118029
118018: POP
// bc_type := b_barracks ; 30 :
118019: LD_ADDR_OWVAR 42
118023: PUSH
118024: LD_INT 5
118026: ST_TO_ADDR
118027: GO 118125
118029: LD_INT 30
118031: DOUBLE
118032: EQUAL
118033: IFTRUE 118037
118035: GO 118048
118037: POP
// bc_type := b_solar_power ; 31 :
118038: LD_ADDR_OWVAR 42
118042: PUSH
118043: LD_INT 27
118045: ST_TO_ADDR
118046: GO 118125
118048: LD_INT 31
118050: DOUBLE
118051: EQUAL
118052: IFTRUE 118056
118054: GO 118067
118056: POP
// bc_type := b_oil_power ; 32 :
118057: LD_ADDR_OWVAR 42
118061: PUSH
118062: LD_INT 26
118064: ST_TO_ADDR
118065: GO 118125
118067: LD_INT 32
118069: DOUBLE
118070: EQUAL
118071: IFTRUE 118075
118073: GO 118086
118075: POP
// bc_type := b_siberite_power ; 33 :
118076: LD_ADDR_OWVAR 42
118080: PUSH
118081: LD_INT 28
118083: ST_TO_ADDR
118084: GO 118125
118086: LD_INT 33
118088: DOUBLE
118089: EQUAL
118090: IFTRUE 118094
118092: GO 118105
118094: POP
// bc_type := b_oil_mine ; 34 :
118095: LD_ADDR_OWVAR 42
118099: PUSH
118100: LD_INT 29
118102: ST_TO_ADDR
118103: GO 118125
118105: LD_INT 34
118107: DOUBLE
118108: EQUAL
118109: IFTRUE 118113
118111: GO 118124
118113: POP
// bc_type := b_siberite_mine ; end ;
118114: LD_ADDR_OWVAR 42
118118: PUSH
118119: LD_INT 30
118121: ST_TO_ADDR
118122: GO 118125
118124: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
118125: LD_ADDR_VAR 0 8
118129: PUSH
118130: LD_VAR 0 5
118134: PPUSH
118135: LD_VAR 0 6
118139: PPUSH
118140: LD_VAR 0 3
118144: PPUSH
118145: CALL_OW 47
118149: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
118150: LD_OWVAR 42
118154: PUSH
118155: LD_INT 32
118157: PUSH
118158: LD_INT 33
118160: PUSH
118161: EMPTY
118162: LIST
118163: LIST
118164: IN
118165: IFFALSE 118181
// PlaceWeaponTurret ( b , weapon ) ;
118167: LD_VAR 0 8
118171: PPUSH
118172: LD_VAR 0 4
118176: PPUSH
118177: CALL_OW 431
// end ;
118181: LD_VAR 0 7
118185: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
118186: LD_INT 0
118188: PPUSH
118189: PPUSH
118190: PPUSH
118191: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118192: LD_ADDR_VAR 0 4
118196: PUSH
118197: LD_INT 22
118199: PUSH
118200: LD_OWVAR 2
118204: PUSH
118205: EMPTY
118206: LIST
118207: LIST
118208: PUSH
118209: LD_INT 2
118211: PUSH
118212: LD_INT 30
118214: PUSH
118215: LD_INT 0
118217: PUSH
118218: EMPTY
118219: LIST
118220: LIST
118221: PUSH
118222: LD_INT 30
118224: PUSH
118225: LD_INT 1
118227: PUSH
118228: EMPTY
118229: LIST
118230: LIST
118231: PUSH
118232: EMPTY
118233: LIST
118234: LIST
118235: LIST
118236: PUSH
118237: EMPTY
118238: LIST
118239: LIST
118240: PPUSH
118241: CALL_OW 69
118245: ST_TO_ADDR
// if not tmp then
118246: LD_VAR 0 4
118250: NOT
118251: IFFALSE 118255
// exit ;
118253: GO 118314
// for i in tmp do
118255: LD_ADDR_VAR 0 2
118259: PUSH
118260: LD_VAR 0 4
118264: PUSH
118265: FOR_IN
118266: IFFALSE 118312
// for j = 1 to 3 do
118268: LD_ADDR_VAR 0 3
118272: PUSH
118273: DOUBLE
118274: LD_INT 1
118276: DEC
118277: ST_TO_ADDR
118278: LD_INT 3
118280: PUSH
118281: FOR_TO
118282: IFFALSE 118308
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
118284: LD_VAR 0 2
118288: PPUSH
118289: CALL_OW 274
118293: PPUSH
118294: LD_VAR 0 3
118298: PPUSH
118299: LD_INT 99999
118301: PPUSH
118302: CALL_OW 277
118306: GO 118281
118308: POP
118309: POP
118310: GO 118265
118312: POP
118313: POP
// end ;
118314: LD_VAR 0 1
118318: RET
// export function hHackSetLevel10 ; var i , j ; begin
118319: LD_INT 0
118321: PPUSH
118322: PPUSH
118323: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
118324: LD_ADDR_VAR 0 2
118328: PUSH
118329: LD_INT 21
118331: PUSH
118332: LD_INT 1
118334: PUSH
118335: EMPTY
118336: LIST
118337: LIST
118338: PPUSH
118339: CALL_OW 69
118343: PUSH
118344: FOR_IN
118345: IFFALSE 118397
// if IsSelected ( i ) then
118347: LD_VAR 0 2
118351: PPUSH
118352: CALL_OW 306
118356: IFFALSE 118395
// begin for j := 1 to 4 do
118358: LD_ADDR_VAR 0 3
118362: PUSH
118363: DOUBLE
118364: LD_INT 1
118366: DEC
118367: ST_TO_ADDR
118368: LD_INT 4
118370: PUSH
118371: FOR_TO
118372: IFFALSE 118393
// SetSkill ( i , j , 10 ) ;
118374: LD_VAR 0 2
118378: PPUSH
118379: LD_VAR 0 3
118383: PPUSH
118384: LD_INT 10
118386: PPUSH
118387: CALL_OW 237
118391: GO 118371
118393: POP
118394: POP
// end ;
118395: GO 118344
118397: POP
118398: POP
// end ;
118399: LD_VAR 0 1
118403: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
118404: LD_INT 0
118406: PPUSH
118407: PPUSH
118408: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
118409: LD_ADDR_VAR 0 2
118413: PUSH
118414: LD_INT 22
118416: PUSH
118417: LD_OWVAR 2
118421: PUSH
118422: EMPTY
118423: LIST
118424: LIST
118425: PUSH
118426: LD_INT 21
118428: PUSH
118429: LD_INT 1
118431: PUSH
118432: EMPTY
118433: LIST
118434: LIST
118435: PUSH
118436: EMPTY
118437: LIST
118438: LIST
118439: PPUSH
118440: CALL_OW 69
118444: PUSH
118445: FOR_IN
118446: IFFALSE 118487
// begin for j := 1 to 4 do
118448: LD_ADDR_VAR 0 3
118452: PUSH
118453: DOUBLE
118454: LD_INT 1
118456: DEC
118457: ST_TO_ADDR
118458: LD_INT 4
118460: PUSH
118461: FOR_TO
118462: IFFALSE 118483
// SetSkill ( i , j , 10 ) ;
118464: LD_VAR 0 2
118468: PPUSH
118469: LD_VAR 0 3
118473: PPUSH
118474: LD_INT 10
118476: PPUSH
118477: CALL_OW 237
118481: GO 118461
118483: POP
118484: POP
// end ;
118485: GO 118445
118487: POP
118488: POP
// end ;
118489: LD_VAR 0 1
118493: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
118494: LD_INT 0
118496: PPUSH
// uc_side := your_side ;
118497: LD_ADDR_OWVAR 20
118501: PUSH
118502: LD_OWVAR 2
118506: ST_TO_ADDR
// uc_nation := nation ;
118507: LD_ADDR_OWVAR 21
118511: PUSH
118512: LD_VAR 0 1
118516: ST_TO_ADDR
// InitHc ;
118517: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
118521: LD_INT 0
118523: PPUSH
118524: LD_VAR 0 2
118528: PPUSH
118529: LD_VAR 0 3
118533: PPUSH
118534: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
118538: LD_VAR 0 4
118542: PPUSH
118543: LD_VAR 0 5
118547: PPUSH
118548: CALL_OW 428
118552: PUSH
118553: LD_INT 0
118555: EQUAL
118556: IFFALSE 118580
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
118558: CALL_OW 44
118562: PPUSH
118563: LD_VAR 0 4
118567: PPUSH
118568: LD_VAR 0 5
118572: PPUSH
118573: LD_INT 1
118575: PPUSH
118576: CALL_OW 48
// end ;
118580: LD_VAR 0 6
118584: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
118585: LD_INT 0
118587: PPUSH
118588: PPUSH
// uc_side := your_side ;
118589: LD_ADDR_OWVAR 20
118593: PUSH
118594: LD_OWVAR 2
118598: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
118599: LD_VAR 0 1
118603: PUSH
118604: LD_INT 1
118606: PUSH
118607: LD_INT 2
118609: PUSH
118610: LD_INT 3
118612: PUSH
118613: LD_INT 4
118615: PUSH
118616: LD_INT 5
118618: PUSH
118619: EMPTY
118620: LIST
118621: LIST
118622: LIST
118623: LIST
118624: LIST
118625: IN
118626: IFFALSE 118638
// uc_nation := nation_american else
118628: LD_ADDR_OWVAR 21
118632: PUSH
118633: LD_INT 1
118635: ST_TO_ADDR
118636: GO 118681
// if chassis in [ 11 , 12 , 13 , 14 ] then
118638: LD_VAR 0 1
118642: PUSH
118643: LD_INT 11
118645: PUSH
118646: LD_INT 12
118648: PUSH
118649: LD_INT 13
118651: PUSH
118652: LD_INT 14
118654: PUSH
118655: EMPTY
118656: LIST
118657: LIST
118658: LIST
118659: LIST
118660: IN
118661: IFFALSE 118673
// uc_nation := nation_arabian else
118663: LD_ADDR_OWVAR 21
118667: PUSH
118668: LD_INT 2
118670: ST_TO_ADDR
118671: GO 118681
// uc_nation := nation_russian ;
118673: LD_ADDR_OWVAR 21
118677: PUSH
118678: LD_INT 3
118680: ST_TO_ADDR
// vc_chassis := chassis ;
118681: LD_ADDR_OWVAR 37
118685: PUSH
118686: LD_VAR 0 1
118690: ST_TO_ADDR
// vc_engine := engine ;
118691: LD_ADDR_OWVAR 39
118695: PUSH
118696: LD_VAR 0 2
118700: ST_TO_ADDR
// vc_control := control ;
118701: LD_ADDR_OWVAR 38
118705: PUSH
118706: LD_VAR 0 3
118710: ST_TO_ADDR
// vc_weapon := weapon ;
118711: LD_ADDR_OWVAR 40
118715: PUSH
118716: LD_VAR 0 4
118720: ST_TO_ADDR
// un := CreateVehicle ;
118721: LD_ADDR_VAR 0 8
118725: PUSH
118726: CALL_OW 45
118730: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
118731: LD_VAR 0 8
118735: PPUSH
118736: LD_INT 0
118738: PPUSH
118739: LD_INT 5
118741: PPUSH
118742: CALL_OW 12
118746: PPUSH
118747: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
118751: LD_VAR 0 8
118755: PPUSH
118756: LD_VAR 0 5
118760: PPUSH
118761: LD_VAR 0 6
118765: PPUSH
118766: LD_INT 1
118768: PPUSH
118769: CALL_OW 48
// end ;
118773: LD_VAR 0 7
118777: RET
// export hInvincible ; every 1 do
118778: GO 118780
118780: DISABLE
// hInvincible := [ ] ;
118781: LD_ADDR_EXP 217
118785: PUSH
118786: EMPTY
118787: ST_TO_ADDR
118788: END
// every 10 do var i ;
118789: GO 118791
118791: DISABLE
118792: LD_INT 0
118794: PPUSH
// begin enable ;
118795: ENABLE
// if not hInvincible then
118796: LD_EXP 217
118800: NOT
118801: IFFALSE 118805
// exit ;
118803: GO 118849
// for i in hInvincible do
118805: LD_ADDR_VAR 0 1
118809: PUSH
118810: LD_EXP 217
118814: PUSH
118815: FOR_IN
118816: IFFALSE 118847
// if GetLives ( i ) < 1000 then
118818: LD_VAR 0 1
118822: PPUSH
118823: CALL_OW 256
118827: PUSH
118828: LD_INT 1000
118830: LESS
118831: IFFALSE 118845
// SetLives ( i , 1000 ) ;
118833: LD_VAR 0 1
118837: PPUSH
118838: LD_INT 1000
118840: PPUSH
118841: CALL_OW 234
118845: GO 118815
118847: POP
118848: POP
// end ;
118849: PPOPN 1
118851: END
// export function hHackInvincible ; var i ; begin
118852: LD_INT 0
118854: PPUSH
118855: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
118856: LD_ADDR_VAR 0 2
118860: PUSH
118861: LD_INT 2
118863: PUSH
118864: LD_INT 21
118866: PUSH
118867: LD_INT 1
118869: PUSH
118870: EMPTY
118871: LIST
118872: LIST
118873: PUSH
118874: LD_INT 21
118876: PUSH
118877: LD_INT 2
118879: PUSH
118880: EMPTY
118881: LIST
118882: LIST
118883: PUSH
118884: EMPTY
118885: LIST
118886: LIST
118887: LIST
118888: PPUSH
118889: CALL_OW 69
118893: PUSH
118894: FOR_IN
118895: IFFALSE 118956
// if IsSelected ( i ) then
118897: LD_VAR 0 2
118901: PPUSH
118902: CALL_OW 306
118906: IFFALSE 118954
// begin if i in hInvincible then
118908: LD_VAR 0 2
118912: PUSH
118913: LD_EXP 217
118917: IN
118918: IFFALSE 118938
// hInvincible := hInvincible diff i else
118920: LD_ADDR_EXP 217
118924: PUSH
118925: LD_EXP 217
118929: PUSH
118930: LD_VAR 0 2
118934: DIFF
118935: ST_TO_ADDR
118936: GO 118954
// hInvincible := hInvincible union i ;
118938: LD_ADDR_EXP 217
118942: PUSH
118943: LD_EXP 217
118947: PUSH
118948: LD_VAR 0 2
118952: UNION
118953: ST_TO_ADDR
// end ;
118954: GO 118894
118956: POP
118957: POP
// end ;
118958: LD_VAR 0 1
118962: RET
// export function hHackInvisible ; var i , j ; begin
118963: LD_INT 0
118965: PPUSH
118966: PPUSH
118967: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
118968: LD_ADDR_VAR 0 2
118972: PUSH
118973: LD_INT 21
118975: PUSH
118976: LD_INT 1
118978: PUSH
118979: EMPTY
118980: LIST
118981: LIST
118982: PPUSH
118983: CALL_OW 69
118987: PUSH
118988: FOR_IN
118989: IFFALSE 119013
// if IsSelected ( i ) then
118991: LD_VAR 0 2
118995: PPUSH
118996: CALL_OW 306
119000: IFFALSE 119011
// ComForceInvisible ( i ) ;
119002: LD_VAR 0 2
119006: PPUSH
119007: CALL_OW 496
119011: GO 118988
119013: POP
119014: POP
// end ;
119015: LD_VAR 0 1
119019: RET
// export function hHackChangeYourSide ; begin
119020: LD_INT 0
119022: PPUSH
// if your_side = 8 then
119023: LD_OWVAR 2
119027: PUSH
119028: LD_INT 8
119030: EQUAL
119031: IFFALSE 119043
// your_side := 0 else
119033: LD_ADDR_OWVAR 2
119037: PUSH
119038: LD_INT 0
119040: ST_TO_ADDR
119041: GO 119057
// your_side := your_side + 1 ;
119043: LD_ADDR_OWVAR 2
119047: PUSH
119048: LD_OWVAR 2
119052: PUSH
119053: LD_INT 1
119055: PLUS
119056: ST_TO_ADDR
// end ;
119057: LD_VAR 0 1
119061: RET
// export function hHackChangeUnitSide ; var i , j ; begin
119062: LD_INT 0
119064: PPUSH
119065: PPUSH
119066: PPUSH
// for i in all_units do
119067: LD_ADDR_VAR 0 2
119071: PUSH
119072: LD_OWVAR 3
119076: PUSH
119077: FOR_IN
119078: IFFALSE 119156
// if IsSelected ( i ) then
119080: LD_VAR 0 2
119084: PPUSH
119085: CALL_OW 306
119089: IFFALSE 119154
// begin j := GetSide ( i ) ;
119091: LD_ADDR_VAR 0 3
119095: PUSH
119096: LD_VAR 0 2
119100: PPUSH
119101: CALL_OW 255
119105: ST_TO_ADDR
// if j = 8 then
119106: LD_VAR 0 3
119110: PUSH
119111: LD_INT 8
119113: EQUAL
119114: IFFALSE 119126
// j := 0 else
119116: LD_ADDR_VAR 0 3
119120: PUSH
119121: LD_INT 0
119123: ST_TO_ADDR
119124: GO 119140
// j := j + 1 ;
119126: LD_ADDR_VAR 0 3
119130: PUSH
119131: LD_VAR 0 3
119135: PUSH
119136: LD_INT 1
119138: PLUS
119139: ST_TO_ADDR
// SetSide ( i , j ) ;
119140: LD_VAR 0 2
119144: PPUSH
119145: LD_VAR 0 3
119149: PPUSH
119150: CALL_OW 235
// end ;
119154: GO 119077
119156: POP
119157: POP
// end ;
119158: LD_VAR 0 1
119162: RET
// export function hHackFog ; begin
119163: LD_INT 0
119165: PPUSH
// FogOff ( true ) ;
119166: LD_INT 1
119168: PPUSH
119169: CALL_OW 344
// end ;
119173: LD_VAR 0 1
119177: RET
// export function hHackTeleport ( unit , x , y ) ; begin
119178: LD_INT 0
119180: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
119181: LD_VAR 0 1
119185: PPUSH
119186: LD_VAR 0 2
119190: PPUSH
119191: LD_VAR 0 3
119195: PPUSH
119196: LD_INT 1
119198: PPUSH
119199: LD_INT 1
119201: PPUSH
119202: CALL_OW 483
// CenterOnXY ( x , y ) ;
119206: LD_VAR 0 2
119210: PPUSH
119211: LD_VAR 0 3
119215: PPUSH
119216: CALL_OW 84
// end ; end_of_file
119220: LD_VAR 0 4
119224: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
119225: LD_INT 0
119227: PPUSH
119228: PPUSH
119229: PPUSH
119230: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
119231: LD_VAR 0 1
119235: PPUSH
119236: CALL_OW 264
119240: PUSH
119241: LD_EXP 99
119245: EQUAL
119246: IFFALSE 119318
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
119248: LD_INT 68
119250: PPUSH
119251: LD_VAR 0 1
119255: PPUSH
119256: CALL_OW 255
119260: PPUSH
119261: CALL_OW 321
119265: PUSH
119266: LD_INT 2
119268: EQUAL
119269: IFFALSE 119281
// eff := 70 else
119271: LD_ADDR_VAR 0 4
119275: PUSH
119276: LD_INT 70
119278: ST_TO_ADDR
119279: GO 119289
// eff := 30 ;
119281: LD_ADDR_VAR 0 4
119285: PUSH
119286: LD_INT 30
119288: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
119289: LD_VAR 0 1
119293: PPUSH
119294: CALL_OW 250
119298: PPUSH
119299: LD_VAR 0 1
119303: PPUSH
119304: CALL_OW 251
119308: PPUSH
119309: LD_VAR 0 4
119313: PPUSH
119314: CALL_OW 495
// end ; end ;
119318: LD_VAR 0 2
119322: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
119323: LD_INT 0
119325: PPUSH
// end ;
119326: LD_VAR 0 4
119330: RET
// export function SOS_Command ( cmd ) ; begin
119331: LD_INT 0
119333: PPUSH
// end ;
119334: LD_VAR 0 2
119338: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
119339: LD_INT 0
119341: PPUSH
// end ;
119342: LD_VAR 0 6
119346: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
119347: LD_INT 0
119349: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
119350: LD_VAR 0 1
119354: PUSH
119355: LD_INT 250
119357: EQUAL
119358: PUSH
119359: LD_VAR 0 2
119363: PPUSH
119364: CALL_OW 264
119368: PUSH
119369: LD_EXP 102
119373: EQUAL
119374: AND
119375: IFFALSE 119396
// MinerPlaceMine ( unit , x , y ) ;
119377: LD_VAR 0 2
119381: PPUSH
119382: LD_VAR 0 4
119386: PPUSH
119387: LD_VAR 0 5
119391: PPUSH
119392: CALL 121745 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
119396: LD_VAR 0 1
119400: PUSH
119401: LD_INT 251
119403: EQUAL
119404: PUSH
119405: LD_VAR 0 2
119409: PPUSH
119410: CALL_OW 264
119414: PUSH
119415: LD_EXP 102
119419: EQUAL
119420: AND
119421: IFFALSE 119442
// MinerDetonateMine ( unit , x , y ) ;
119423: LD_VAR 0 2
119427: PPUSH
119428: LD_VAR 0 4
119432: PPUSH
119433: LD_VAR 0 5
119437: PPUSH
119438: CALL 122022 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
119442: LD_VAR 0 1
119446: PUSH
119447: LD_INT 252
119449: EQUAL
119450: PUSH
119451: LD_VAR 0 2
119455: PPUSH
119456: CALL_OW 264
119460: PUSH
119461: LD_EXP 102
119465: EQUAL
119466: AND
119467: IFFALSE 119488
// MinerCreateMinefield ( unit , x , y ) ;
119469: LD_VAR 0 2
119473: PPUSH
119474: LD_VAR 0 4
119478: PPUSH
119479: LD_VAR 0 5
119483: PPUSH
119484: CALL 122439 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
119488: LD_VAR 0 1
119492: PUSH
119493: LD_INT 253
119495: EQUAL
119496: PUSH
119497: LD_VAR 0 2
119501: PPUSH
119502: CALL_OW 257
119506: PUSH
119507: LD_INT 5
119509: EQUAL
119510: AND
119511: IFFALSE 119532
// ComBinocular ( unit , x , y ) ;
119513: LD_VAR 0 2
119517: PPUSH
119518: LD_VAR 0 4
119522: PPUSH
119523: LD_VAR 0 5
119527: PPUSH
119528: CALL 122810 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
119532: LD_VAR 0 1
119536: PUSH
119537: LD_INT 254
119539: EQUAL
119540: PUSH
119541: LD_VAR 0 2
119545: PPUSH
119546: CALL_OW 264
119550: PUSH
119551: LD_EXP 97
119555: EQUAL
119556: AND
119557: PUSH
119558: LD_VAR 0 3
119562: PPUSH
119563: CALL_OW 263
119567: PUSH
119568: LD_INT 3
119570: EQUAL
119571: AND
119572: IFFALSE 119588
// HackDestroyVehicle ( unit , selectedUnit ) ;
119574: LD_VAR 0 2
119578: PPUSH
119579: LD_VAR 0 3
119583: PPUSH
119584: CALL 121105 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
119588: LD_VAR 0 1
119592: PUSH
119593: LD_INT 255
119595: EQUAL
119596: PUSH
119597: LD_VAR 0 2
119601: PPUSH
119602: CALL_OW 264
119606: PUSH
119607: LD_INT 14
119609: PUSH
119610: LD_INT 53
119612: PUSH
119613: EMPTY
119614: LIST
119615: LIST
119616: IN
119617: AND
119618: PUSH
119619: LD_VAR 0 4
119623: PPUSH
119624: LD_VAR 0 5
119628: PPUSH
119629: CALL_OW 488
119633: AND
119634: IFFALSE 119658
// CutTreeXYR ( unit , x , y , 12 ) ;
119636: LD_VAR 0 2
119640: PPUSH
119641: LD_VAR 0 4
119645: PPUSH
119646: LD_VAR 0 5
119650: PPUSH
119651: LD_INT 12
119653: PPUSH
119654: CALL 119671 0 4
// end ;
119658: LD_VAR 0 6
119662: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
119663: LD_INT 0
119665: PPUSH
// end ;
119666: LD_VAR 0 4
119670: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119671: LD_INT 0
119673: PPUSH
119674: PPUSH
119675: PPUSH
119676: PPUSH
119677: PPUSH
119678: PPUSH
119679: PPUSH
119680: PPUSH
119681: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119682: LD_VAR 0 1
119686: NOT
119687: PUSH
119688: LD_VAR 0 2
119692: PPUSH
119693: LD_VAR 0 3
119697: PPUSH
119698: CALL_OW 488
119702: NOT
119703: OR
119704: PUSH
119705: LD_VAR 0 4
119709: NOT
119710: OR
119711: IFFALSE 119715
// exit ;
119713: GO 120055
// list := [ ] ;
119715: LD_ADDR_VAR 0 13
119719: PUSH
119720: EMPTY
119721: ST_TO_ADDR
// if x - r < 0 then
119722: LD_VAR 0 2
119726: PUSH
119727: LD_VAR 0 4
119731: MINUS
119732: PUSH
119733: LD_INT 0
119735: LESS
119736: IFFALSE 119748
// min_x := 0 else
119738: LD_ADDR_VAR 0 7
119742: PUSH
119743: LD_INT 0
119745: ST_TO_ADDR
119746: GO 119764
// min_x := x - r ;
119748: LD_ADDR_VAR 0 7
119752: PUSH
119753: LD_VAR 0 2
119757: PUSH
119758: LD_VAR 0 4
119762: MINUS
119763: ST_TO_ADDR
// if y - r < 0 then
119764: LD_VAR 0 3
119768: PUSH
119769: LD_VAR 0 4
119773: MINUS
119774: PUSH
119775: LD_INT 0
119777: LESS
119778: IFFALSE 119790
// min_y := 0 else
119780: LD_ADDR_VAR 0 8
119784: PUSH
119785: LD_INT 0
119787: ST_TO_ADDR
119788: GO 119806
// min_y := y - r ;
119790: LD_ADDR_VAR 0 8
119794: PUSH
119795: LD_VAR 0 3
119799: PUSH
119800: LD_VAR 0 4
119804: MINUS
119805: ST_TO_ADDR
// max_x := x + r ;
119806: LD_ADDR_VAR 0 9
119810: PUSH
119811: LD_VAR 0 2
119815: PUSH
119816: LD_VAR 0 4
119820: PLUS
119821: ST_TO_ADDR
// max_y := y + r ;
119822: LD_ADDR_VAR 0 10
119826: PUSH
119827: LD_VAR 0 3
119831: PUSH
119832: LD_VAR 0 4
119836: PLUS
119837: ST_TO_ADDR
// for _x = min_x to max_x do
119838: LD_ADDR_VAR 0 11
119842: PUSH
119843: DOUBLE
119844: LD_VAR 0 7
119848: DEC
119849: ST_TO_ADDR
119850: LD_VAR 0 9
119854: PUSH
119855: FOR_TO
119856: IFFALSE 119973
// for _y = min_y to max_y do
119858: LD_ADDR_VAR 0 12
119862: PUSH
119863: DOUBLE
119864: LD_VAR 0 8
119868: DEC
119869: ST_TO_ADDR
119870: LD_VAR 0 10
119874: PUSH
119875: FOR_TO
119876: IFFALSE 119969
// begin if not ValidHex ( _x , _y ) then
119878: LD_VAR 0 11
119882: PPUSH
119883: LD_VAR 0 12
119887: PPUSH
119888: CALL_OW 488
119892: NOT
119893: IFFALSE 119897
// continue ;
119895: GO 119875
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119897: LD_VAR 0 11
119901: PPUSH
119902: LD_VAR 0 12
119906: PPUSH
119907: CALL_OW 351
119911: PUSH
119912: LD_VAR 0 11
119916: PPUSH
119917: LD_VAR 0 12
119921: PPUSH
119922: CALL_OW 554
119926: AND
119927: IFFALSE 119967
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119929: LD_ADDR_VAR 0 13
119933: PUSH
119934: LD_VAR 0 13
119938: PPUSH
119939: LD_VAR 0 13
119943: PUSH
119944: LD_INT 1
119946: PLUS
119947: PPUSH
119948: LD_VAR 0 11
119952: PUSH
119953: LD_VAR 0 12
119957: PUSH
119958: EMPTY
119959: LIST
119960: LIST
119961: PPUSH
119962: CALL_OW 2
119966: ST_TO_ADDR
// end ;
119967: GO 119875
119969: POP
119970: POP
119971: GO 119855
119973: POP
119974: POP
// if not list then
119975: LD_VAR 0 13
119979: NOT
119980: IFFALSE 119984
// exit ;
119982: GO 120055
// for i in list do
119984: LD_ADDR_VAR 0 6
119988: PUSH
119989: LD_VAR 0 13
119993: PUSH
119994: FOR_IN
119995: IFFALSE 120053
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119997: LD_VAR 0 1
120001: PPUSH
120002: LD_STRING M
120004: PUSH
120005: LD_VAR 0 6
120009: PUSH
120010: LD_INT 1
120012: ARRAY
120013: PUSH
120014: LD_VAR 0 6
120018: PUSH
120019: LD_INT 2
120021: ARRAY
120022: PUSH
120023: LD_INT 0
120025: PUSH
120026: LD_INT 0
120028: PUSH
120029: LD_INT 0
120031: PUSH
120032: LD_INT 0
120034: PUSH
120035: EMPTY
120036: LIST
120037: LIST
120038: LIST
120039: LIST
120040: LIST
120041: LIST
120042: LIST
120043: PUSH
120044: EMPTY
120045: LIST
120046: PPUSH
120047: CALL_OW 447
120051: GO 119994
120053: POP
120054: POP
// end ;
120055: LD_VAR 0 5
120059: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
120060: LD_EXP 220
120064: NOT
120065: IFFALSE 120115
120067: GO 120069
120069: DISABLE
// begin initHack := true ;
120070: LD_ADDR_EXP 220
120074: PUSH
120075: LD_INT 1
120077: ST_TO_ADDR
// hackTanks := [ ] ;
120078: LD_ADDR_EXP 221
120082: PUSH
120083: EMPTY
120084: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
120085: LD_ADDR_EXP 222
120089: PUSH
120090: EMPTY
120091: ST_TO_ADDR
// hackLimit := 3 ;
120092: LD_ADDR_EXP 223
120096: PUSH
120097: LD_INT 3
120099: ST_TO_ADDR
// hackDist := 12 ;
120100: LD_ADDR_EXP 224
120104: PUSH
120105: LD_INT 12
120107: ST_TO_ADDR
// hackCounter := [ ] ;
120108: LD_ADDR_EXP 225
120112: PUSH
120113: EMPTY
120114: ST_TO_ADDR
// end ;
120115: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
120116: LD_EXP 220
120120: PUSH
120121: LD_INT 34
120123: PUSH
120124: LD_EXP 97
120128: PUSH
120129: EMPTY
120130: LIST
120131: LIST
120132: PPUSH
120133: CALL_OW 69
120137: AND
120138: IFFALSE 120393
120140: GO 120142
120142: DISABLE
120143: LD_INT 0
120145: PPUSH
120146: PPUSH
// begin enable ;
120147: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
120148: LD_ADDR_VAR 0 1
120152: PUSH
120153: LD_INT 34
120155: PUSH
120156: LD_EXP 97
120160: PUSH
120161: EMPTY
120162: LIST
120163: LIST
120164: PPUSH
120165: CALL_OW 69
120169: PUSH
120170: FOR_IN
120171: IFFALSE 120391
// begin if not i in hackTanks then
120173: LD_VAR 0 1
120177: PUSH
120178: LD_EXP 221
120182: IN
120183: NOT
120184: IFFALSE 120267
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
120186: LD_ADDR_EXP 221
120190: PUSH
120191: LD_EXP 221
120195: PPUSH
120196: LD_EXP 221
120200: PUSH
120201: LD_INT 1
120203: PLUS
120204: PPUSH
120205: LD_VAR 0 1
120209: PPUSH
120210: CALL_OW 1
120214: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
120215: LD_ADDR_EXP 222
120219: PUSH
120220: LD_EXP 222
120224: PPUSH
120225: LD_EXP 222
120229: PUSH
120230: LD_INT 1
120232: PLUS
120233: PPUSH
120234: EMPTY
120235: PPUSH
120236: CALL_OW 1
120240: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
120241: LD_ADDR_EXP 225
120245: PUSH
120246: LD_EXP 225
120250: PPUSH
120251: LD_EXP 225
120255: PUSH
120256: LD_INT 1
120258: PLUS
120259: PPUSH
120260: EMPTY
120261: PPUSH
120262: CALL_OW 1
120266: ST_TO_ADDR
// end ; if not IsOk ( i ) then
120267: LD_VAR 0 1
120271: PPUSH
120272: CALL_OW 302
120276: NOT
120277: IFFALSE 120290
// begin HackUnlinkAll ( i ) ;
120279: LD_VAR 0 1
120283: PPUSH
120284: CALL 120396 0 1
// continue ;
120288: GO 120170
// end ; HackCheckCapturedStatus ( i ) ;
120290: LD_VAR 0 1
120294: PPUSH
120295: CALL 120839 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
120299: LD_ADDR_VAR 0 2
120303: PUSH
120304: LD_INT 81
120306: PUSH
120307: LD_VAR 0 1
120311: PPUSH
120312: CALL_OW 255
120316: PUSH
120317: EMPTY
120318: LIST
120319: LIST
120320: PUSH
120321: LD_INT 33
120323: PUSH
120324: LD_INT 3
120326: PUSH
120327: EMPTY
120328: LIST
120329: LIST
120330: PUSH
120331: LD_INT 91
120333: PUSH
120334: LD_VAR 0 1
120338: PUSH
120339: LD_EXP 224
120343: PUSH
120344: EMPTY
120345: LIST
120346: LIST
120347: LIST
120348: PUSH
120349: LD_INT 50
120351: PUSH
120352: EMPTY
120353: LIST
120354: PUSH
120355: EMPTY
120356: LIST
120357: LIST
120358: LIST
120359: LIST
120360: PPUSH
120361: CALL_OW 69
120365: ST_TO_ADDR
// if not tmp then
120366: LD_VAR 0 2
120370: NOT
120371: IFFALSE 120375
// continue ;
120373: GO 120170
// HackLink ( i , tmp ) ;
120375: LD_VAR 0 1
120379: PPUSH
120380: LD_VAR 0 2
120384: PPUSH
120385: CALL 120532 0 2
// end ;
120389: GO 120170
120391: POP
120392: POP
// end ;
120393: PPOPN 2
120395: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
120396: LD_INT 0
120398: PPUSH
120399: PPUSH
120400: PPUSH
// if not hack in hackTanks then
120401: LD_VAR 0 1
120405: PUSH
120406: LD_EXP 221
120410: IN
120411: NOT
120412: IFFALSE 120416
// exit ;
120414: GO 120527
// index := GetElementIndex ( hackTanks , hack ) ;
120416: LD_ADDR_VAR 0 4
120420: PUSH
120421: LD_EXP 221
120425: PPUSH
120426: LD_VAR 0 1
120430: PPUSH
120431: CALL 70656 0 2
120435: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
120436: LD_EXP 222
120440: PUSH
120441: LD_VAR 0 4
120445: ARRAY
120446: IFFALSE 120527
// begin for i in hackTanksCaptured [ index ] do
120448: LD_ADDR_VAR 0 3
120452: PUSH
120453: LD_EXP 222
120457: PUSH
120458: LD_VAR 0 4
120462: ARRAY
120463: PUSH
120464: FOR_IN
120465: IFFALSE 120491
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
120467: LD_VAR 0 3
120471: PUSH
120472: LD_INT 1
120474: ARRAY
120475: PPUSH
120476: LD_VAR 0 3
120480: PUSH
120481: LD_INT 2
120483: ARRAY
120484: PPUSH
120485: CALL_OW 235
120489: GO 120464
120491: POP
120492: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
120493: LD_ADDR_EXP 222
120497: PUSH
120498: LD_EXP 222
120502: PPUSH
120503: LD_VAR 0 4
120507: PPUSH
120508: EMPTY
120509: PPUSH
120510: CALL_OW 1
120514: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
120515: LD_VAR 0 1
120519: PPUSH
120520: LD_INT 0
120522: PPUSH
120523: CALL_OW 505
// end ; end ;
120527: LD_VAR 0 2
120531: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
120532: LD_INT 0
120534: PPUSH
120535: PPUSH
120536: PPUSH
// if not hack in hackTanks or not vehicles then
120537: LD_VAR 0 1
120541: PUSH
120542: LD_EXP 221
120546: IN
120547: NOT
120548: PUSH
120549: LD_VAR 0 2
120553: NOT
120554: OR
120555: IFFALSE 120559
// exit ;
120557: GO 120834
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
120559: LD_ADDR_VAR 0 2
120563: PUSH
120564: LD_VAR 0 1
120568: PPUSH
120569: LD_VAR 0 2
120573: PPUSH
120574: LD_INT 1
120576: PPUSH
120577: LD_INT 1
120579: PPUSH
120580: CALL 71306 0 4
120584: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
120585: LD_ADDR_VAR 0 5
120589: PUSH
120590: LD_EXP 221
120594: PPUSH
120595: LD_VAR 0 1
120599: PPUSH
120600: CALL 70656 0 2
120604: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
120605: LD_EXP 222
120609: PUSH
120610: LD_VAR 0 5
120614: ARRAY
120615: PUSH
120616: LD_EXP 223
120620: LESS
120621: IFFALSE 120810
// begin for i := 1 to vehicles do
120623: LD_ADDR_VAR 0 4
120627: PUSH
120628: DOUBLE
120629: LD_INT 1
120631: DEC
120632: ST_TO_ADDR
120633: LD_VAR 0 2
120637: PUSH
120638: FOR_TO
120639: IFFALSE 120808
// begin if hackTanksCaptured [ index ] = hackLimit then
120641: LD_EXP 222
120645: PUSH
120646: LD_VAR 0 5
120650: ARRAY
120651: PUSH
120652: LD_EXP 223
120656: EQUAL
120657: IFFALSE 120661
// break ;
120659: GO 120808
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
120661: LD_ADDR_EXP 225
120665: PUSH
120666: LD_EXP 225
120670: PPUSH
120671: LD_VAR 0 5
120675: PPUSH
120676: LD_EXP 225
120680: PUSH
120681: LD_VAR 0 5
120685: ARRAY
120686: PUSH
120687: LD_INT 1
120689: PLUS
120690: PPUSH
120691: CALL_OW 1
120695: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
120696: LD_ADDR_EXP 222
120700: PUSH
120701: LD_EXP 222
120705: PPUSH
120706: LD_VAR 0 5
120710: PUSH
120711: LD_EXP 222
120715: PUSH
120716: LD_VAR 0 5
120720: ARRAY
120721: PUSH
120722: LD_INT 1
120724: PLUS
120725: PUSH
120726: EMPTY
120727: LIST
120728: LIST
120729: PPUSH
120730: LD_VAR 0 2
120734: PUSH
120735: LD_VAR 0 4
120739: ARRAY
120740: PUSH
120741: LD_VAR 0 2
120745: PUSH
120746: LD_VAR 0 4
120750: ARRAY
120751: PPUSH
120752: CALL_OW 255
120756: PUSH
120757: EMPTY
120758: LIST
120759: LIST
120760: PPUSH
120761: CALL 70871 0 3
120765: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
120766: LD_VAR 0 2
120770: PUSH
120771: LD_VAR 0 4
120775: ARRAY
120776: PPUSH
120777: LD_VAR 0 1
120781: PPUSH
120782: CALL_OW 255
120786: PPUSH
120787: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
120791: LD_VAR 0 2
120795: PUSH
120796: LD_VAR 0 4
120800: ARRAY
120801: PPUSH
120802: CALL_OW 141
// end ;
120806: GO 120638
120808: POP
120809: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
120810: LD_VAR 0 1
120814: PPUSH
120815: LD_EXP 222
120819: PUSH
120820: LD_VAR 0 5
120824: ARRAY
120825: PUSH
120826: LD_INT 0
120828: PLUS
120829: PPUSH
120830: CALL_OW 505
// end ;
120834: LD_VAR 0 3
120838: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
120839: LD_INT 0
120841: PPUSH
120842: PPUSH
120843: PPUSH
120844: PPUSH
// if not hack in hackTanks then
120845: LD_VAR 0 1
120849: PUSH
120850: LD_EXP 221
120854: IN
120855: NOT
120856: IFFALSE 120860
// exit ;
120858: GO 121100
// index := GetElementIndex ( hackTanks , hack ) ;
120860: LD_ADDR_VAR 0 4
120864: PUSH
120865: LD_EXP 221
120869: PPUSH
120870: LD_VAR 0 1
120874: PPUSH
120875: CALL 70656 0 2
120879: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
120880: LD_ADDR_VAR 0 3
120884: PUSH
120885: DOUBLE
120886: LD_EXP 222
120890: PUSH
120891: LD_VAR 0 4
120895: ARRAY
120896: INC
120897: ST_TO_ADDR
120898: LD_INT 1
120900: PUSH
120901: FOR_DOWNTO
120902: IFFALSE 121074
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
120904: LD_ADDR_VAR 0 5
120908: PUSH
120909: LD_EXP 222
120913: PUSH
120914: LD_VAR 0 4
120918: ARRAY
120919: PUSH
120920: LD_VAR 0 3
120924: ARRAY
120925: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
120926: LD_VAR 0 5
120930: PUSH
120931: LD_INT 1
120933: ARRAY
120934: PPUSH
120935: CALL_OW 302
120939: NOT
120940: PUSH
120941: LD_VAR 0 5
120945: PUSH
120946: LD_INT 1
120948: ARRAY
120949: PPUSH
120950: CALL_OW 255
120954: PUSH
120955: LD_VAR 0 1
120959: PPUSH
120960: CALL_OW 255
120964: NONEQUAL
120965: OR
120966: IFFALSE 121072
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
120968: LD_VAR 0 5
120972: PUSH
120973: LD_INT 1
120975: ARRAY
120976: PPUSH
120977: CALL_OW 305
120981: PUSH
120982: LD_VAR 0 5
120986: PUSH
120987: LD_INT 1
120989: ARRAY
120990: PPUSH
120991: CALL_OW 255
120995: PUSH
120996: LD_VAR 0 1
121000: PPUSH
121001: CALL_OW 255
121005: EQUAL
121006: AND
121007: IFFALSE 121031
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
121009: LD_VAR 0 5
121013: PUSH
121014: LD_INT 1
121016: ARRAY
121017: PPUSH
121018: LD_VAR 0 5
121022: PUSH
121023: LD_INT 2
121025: ARRAY
121026: PPUSH
121027: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
121031: LD_ADDR_EXP 222
121035: PUSH
121036: LD_EXP 222
121040: PPUSH
121041: LD_VAR 0 4
121045: PPUSH
121046: LD_EXP 222
121050: PUSH
121051: LD_VAR 0 4
121055: ARRAY
121056: PPUSH
121057: LD_VAR 0 3
121061: PPUSH
121062: CALL_OW 3
121066: PPUSH
121067: CALL_OW 1
121071: ST_TO_ADDR
// end ; end ;
121072: GO 120901
121074: POP
121075: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
121076: LD_VAR 0 1
121080: PPUSH
121081: LD_EXP 222
121085: PUSH
121086: LD_VAR 0 4
121090: ARRAY
121091: PUSH
121092: LD_INT 0
121094: PLUS
121095: PPUSH
121096: CALL_OW 505
// end ;
121100: LD_VAR 0 2
121104: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
121105: LD_INT 0
121107: PPUSH
121108: PPUSH
121109: PPUSH
121110: PPUSH
// if not hack in hackTanks then
121111: LD_VAR 0 1
121115: PUSH
121116: LD_EXP 221
121120: IN
121121: NOT
121122: IFFALSE 121126
// exit ;
121124: GO 121211
// index := GetElementIndex ( hackTanks , hack ) ;
121126: LD_ADDR_VAR 0 5
121130: PUSH
121131: LD_EXP 221
121135: PPUSH
121136: LD_VAR 0 1
121140: PPUSH
121141: CALL 70656 0 2
121145: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
121146: LD_ADDR_VAR 0 4
121150: PUSH
121151: DOUBLE
121152: LD_INT 1
121154: DEC
121155: ST_TO_ADDR
121156: LD_EXP 222
121160: PUSH
121161: LD_VAR 0 5
121165: ARRAY
121166: PUSH
121167: FOR_TO
121168: IFFALSE 121209
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
121170: LD_EXP 222
121174: PUSH
121175: LD_VAR 0 5
121179: ARRAY
121180: PUSH
121181: LD_VAR 0 4
121185: ARRAY
121186: PUSH
121187: LD_INT 1
121189: ARRAY
121190: PUSH
121191: LD_VAR 0 2
121195: EQUAL
121196: IFFALSE 121207
// KillUnit ( vehicle ) ;
121198: LD_VAR 0 2
121202: PPUSH
121203: CALL_OW 66
121207: GO 121167
121209: POP
121210: POP
// end ;
121211: LD_VAR 0 3
121215: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
121216: LD_EXP 226
121220: NOT
121221: IFFALSE 121256
121223: GO 121225
121225: DISABLE
// begin initMiner := true ;
121226: LD_ADDR_EXP 226
121230: PUSH
121231: LD_INT 1
121233: ST_TO_ADDR
// minersList := [ ] ;
121234: LD_ADDR_EXP 227
121238: PUSH
121239: EMPTY
121240: ST_TO_ADDR
// minerMinesList := [ ] ;
121241: LD_ADDR_EXP 228
121245: PUSH
121246: EMPTY
121247: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
121248: LD_ADDR_EXP 229
121252: PUSH
121253: LD_INT 5
121255: ST_TO_ADDR
// end ;
121256: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
121257: LD_EXP 226
121261: PUSH
121262: LD_INT 34
121264: PUSH
121265: LD_EXP 102
121269: PUSH
121270: EMPTY
121271: LIST
121272: LIST
121273: PPUSH
121274: CALL_OW 69
121278: AND
121279: IFFALSE 121742
121281: GO 121283
121283: DISABLE
121284: LD_INT 0
121286: PPUSH
121287: PPUSH
121288: PPUSH
121289: PPUSH
// begin enable ;
121290: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
121291: LD_ADDR_VAR 0 1
121295: PUSH
121296: LD_INT 34
121298: PUSH
121299: LD_EXP 102
121303: PUSH
121304: EMPTY
121305: LIST
121306: LIST
121307: PPUSH
121308: CALL_OW 69
121312: PUSH
121313: FOR_IN
121314: IFFALSE 121386
// begin if not i in minersList then
121316: LD_VAR 0 1
121320: PUSH
121321: LD_EXP 227
121325: IN
121326: NOT
121327: IFFALSE 121384
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
121329: LD_ADDR_EXP 227
121333: PUSH
121334: LD_EXP 227
121338: PPUSH
121339: LD_EXP 227
121343: PUSH
121344: LD_INT 1
121346: PLUS
121347: PPUSH
121348: LD_VAR 0 1
121352: PPUSH
121353: CALL_OW 1
121357: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
121358: LD_ADDR_EXP 228
121362: PUSH
121363: LD_EXP 228
121367: PPUSH
121368: LD_EXP 228
121372: PUSH
121373: LD_INT 1
121375: PLUS
121376: PPUSH
121377: EMPTY
121378: PPUSH
121379: CALL_OW 1
121383: ST_TO_ADDR
// end end ;
121384: GO 121313
121386: POP
121387: POP
// for i := minerMinesList downto 1 do
121388: LD_ADDR_VAR 0 1
121392: PUSH
121393: DOUBLE
121394: LD_EXP 228
121398: INC
121399: ST_TO_ADDR
121400: LD_INT 1
121402: PUSH
121403: FOR_DOWNTO
121404: IFFALSE 121740
// begin if IsLive ( minersList [ i ] ) then
121406: LD_EXP 227
121410: PUSH
121411: LD_VAR 0 1
121415: ARRAY
121416: PPUSH
121417: CALL_OW 300
121421: IFFALSE 121449
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
121423: LD_EXP 227
121427: PUSH
121428: LD_VAR 0 1
121432: ARRAY
121433: PPUSH
121434: LD_EXP 228
121438: PUSH
121439: LD_VAR 0 1
121443: ARRAY
121444: PPUSH
121445: CALL_OW 505
// if not minerMinesList [ i ] then
121449: LD_EXP 228
121453: PUSH
121454: LD_VAR 0 1
121458: ARRAY
121459: NOT
121460: IFFALSE 121464
// continue ;
121462: GO 121403
// for j := minerMinesList [ i ] downto 1 do
121464: LD_ADDR_VAR 0 2
121468: PUSH
121469: DOUBLE
121470: LD_EXP 228
121474: PUSH
121475: LD_VAR 0 1
121479: ARRAY
121480: INC
121481: ST_TO_ADDR
121482: LD_INT 1
121484: PUSH
121485: FOR_DOWNTO
121486: IFFALSE 121736
// begin side := GetSide ( minersList [ i ] ) ;
121488: LD_ADDR_VAR 0 3
121492: PUSH
121493: LD_EXP 227
121497: PUSH
121498: LD_VAR 0 1
121502: ARRAY
121503: PPUSH
121504: CALL_OW 255
121508: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
121509: LD_ADDR_VAR 0 4
121513: PUSH
121514: LD_EXP 228
121518: PUSH
121519: LD_VAR 0 1
121523: ARRAY
121524: PUSH
121525: LD_VAR 0 2
121529: ARRAY
121530: PUSH
121531: LD_INT 1
121533: ARRAY
121534: PPUSH
121535: LD_EXP 228
121539: PUSH
121540: LD_VAR 0 1
121544: ARRAY
121545: PUSH
121546: LD_VAR 0 2
121550: ARRAY
121551: PUSH
121552: LD_INT 2
121554: ARRAY
121555: PPUSH
121556: CALL_OW 428
121560: ST_TO_ADDR
// if not tmp then
121561: LD_VAR 0 4
121565: NOT
121566: IFFALSE 121570
// continue ;
121568: GO 121485
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
121570: LD_VAR 0 4
121574: PUSH
121575: LD_INT 81
121577: PUSH
121578: LD_VAR 0 3
121582: PUSH
121583: EMPTY
121584: LIST
121585: LIST
121586: PPUSH
121587: CALL_OW 69
121591: IN
121592: PUSH
121593: LD_EXP 228
121597: PUSH
121598: LD_VAR 0 1
121602: ARRAY
121603: PUSH
121604: LD_VAR 0 2
121608: ARRAY
121609: PUSH
121610: LD_INT 1
121612: ARRAY
121613: PPUSH
121614: LD_EXP 228
121618: PUSH
121619: LD_VAR 0 1
121623: ARRAY
121624: PUSH
121625: LD_VAR 0 2
121629: ARRAY
121630: PUSH
121631: LD_INT 2
121633: ARRAY
121634: PPUSH
121635: CALL_OW 458
121639: AND
121640: IFFALSE 121734
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
121642: LD_EXP 228
121646: PUSH
121647: LD_VAR 0 1
121651: ARRAY
121652: PUSH
121653: LD_VAR 0 2
121657: ARRAY
121658: PUSH
121659: LD_INT 1
121661: ARRAY
121662: PPUSH
121663: LD_EXP 228
121667: PUSH
121668: LD_VAR 0 1
121672: ARRAY
121673: PUSH
121674: LD_VAR 0 2
121678: ARRAY
121679: PUSH
121680: LD_INT 2
121682: ARRAY
121683: PPUSH
121684: LD_VAR 0 3
121688: PPUSH
121689: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
121693: LD_ADDR_EXP 228
121697: PUSH
121698: LD_EXP 228
121702: PPUSH
121703: LD_VAR 0 1
121707: PPUSH
121708: LD_EXP 228
121712: PUSH
121713: LD_VAR 0 1
121717: ARRAY
121718: PPUSH
121719: LD_VAR 0 2
121723: PPUSH
121724: CALL_OW 3
121728: PPUSH
121729: CALL_OW 1
121733: ST_TO_ADDR
// end ; end ;
121734: GO 121485
121736: POP
121737: POP
// end ;
121738: GO 121403
121740: POP
121741: POP
// end ;
121742: PPOPN 4
121744: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
121745: LD_INT 0
121747: PPUSH
121748: PPUSH
// result := false ;
121749: LD_ADDR_VAR 0 4
121753: PUSH
121754: LD_INT 0
121756: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
121757: LD_VAR 0 1
121761: PPUSH
121762: CALL_OW 264
121766: PUSH
121767: LD_EXP 102
121771: EQUAL
121772: NOT
121773: IFFALSE 121777
// exit ;
121775: GO 122017
// index := GetElementIndex ( minersList , unit ) ;
121777: LD_ADDR_VAR 0 5
121781: PUSH
121782: LD_EXP 227
121786: PPUSH
121787: LD_VAR 0 1
121791: PPUSH
121792: CALL 70656 0 2
121796: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
121797: LD_EXP 228
121801: PUSH
121802: LD_VAR 0 5
121806: ARRAY
121807: PUSH
121808: LD_EXP 229
121812: GREATEREQUAL
121813: IFFALSE 121817
// exit ;
121815: GO 122017
// ComMoveXY ( unit , x , y ) ;
121817: LD_VAR 0 1
121821: PPUSH
121822: LD_VAR 0 2
121826: PPUSH
121827: LD_VAR 0 3
121831: PPUSH
121832: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
121836: LD_INT 35
121838: PPUSH
121839: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
121843: LD_VAR 0 1
121847: PPUSH
121848: LD_VAR 0 2
121852: PPUSH
121853: LD_VAR 0 3
121857: PPUSH
121858: CALL 101428 0 3
121862: NOT
121863: PUSH
121864: LD_VAR 0 1
121868: PPUSH
121869: CALL_OW 314
121873: AND
121874: IFFALSE 121878
// exit ;
121876: GO 122017
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
121878: LD_VAR 0 2
121882: PPUSH
121883: LD_VAR 0 3
121887: PPUSH
121888: CALL_OW 428
121892: PUSH
121893: LD_VAR 0 1
121897: EQUAL
121898: PUSH
121899: LD_VAR 0 1
121903: PPUSH
121904: CALL_OW 314
121908: NOT
121909: AND
121910: IFFALSE 121836
// PlaySoundXY ( x , y , PlantMine ) ;
121912: LD_VAR 0 2
121916: PPUSH
121917: LD_VAR 0 3
121921: PPUSH
121922: LD_STRING PlantMine
121924: PPUSH
121925: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
121929: LD_VAR 0 2
121933: PPUSH
121934: LD_VAR 0 3
121938: PPUSH
121939: LD_VAR 0 1
121943: PPUSH
121944: CALL_OW 255
121948: PPUSH
121949: LD_INT 0
121951: PPUSH
121952: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
121956: LD_ADDR_EXP 228
121960: PUSH
121961: LD_EXP 228
121965: PPUSH
121966: LD_VAR 0 5
121970: PUSH
121971: LD_EXP 228
121975: PUSH
121976: LD_VAR 0 5
121980: ARRAY
121981: PUSH
121982: LD_INT 1
121984: PLUS
121985: PUSH
121986: EMPTY
121987: LIST
121988: LIST
121989: PPUSH
121990: LD_VAR 0 2
121994: PUSH
121995: LD_VAR 0 3
121999: PUSH
122000: EMPTY
122001: LIST
122002: LIST
122003: PPUSH
122004: CALL 70871 0 3
122008: ST_TO_ADDR
// result := true ;
122009: LD_ADDR_VAR 0 4
122013: PUSH
122014: LD_INT 1
122016: ST_TO_ADDR
// end ;
122017: LD_VAR 0 4
122021: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
122022: LD_INT 0
122024: PPUSH
122025: PPUSH
122026: PPUSH
// if not unit in minersList then
122027: LD_VAR 0 1
122031: PUSH
122032: LD_EXP 227
122036: IN
122037: NOT
122038: IFFALSE 122042
// exit ;
122040: GO 122434
// index := GetElementIndex ( minersList , unit ) ;
122042: LD_ADDR_VAR 0 6
122046: PUSH
122047: LD_EXP 227
122051: PPUSH
122052: LD_VAR 0 1
122056: PPUSH
122057: CALL 70656 0 2
122061: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
122062: LD_ADDR_VAR 0 5
122066: PUSH
122067: DOUBLE
122068: LD_EXP 228
122072: PUSH
122073: LD_VAR 0 6
122077: ARRAY
122078: INC
122079: ST_TO_ADDR
122080: LD_INT 1
122082: PUSH
122083: FOR_DOWNTO
122084: IFFALSE 122245
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
122086: LD_EXP 228
122090: PUSH
122091: LD_VAR 0 6
122095: ARRAY
122096: PUSH
122097: LD_VAR 0 5
122101: ARRAY
122102: PUSH
122103: LD_INT 1
122105: ARRAY
122106: PUSH
122107: LD_VAR 0 2
122111: EQUAL
122112: PUSH
122113: LD_EXP 228
122117: PUSH
122118: LD_VAR 0 6
122122: ARRAY
122123: PUSH
122124: LD_VAR 0 5
122128: ARRAY
122129: PUSH
122130: LD_INT 2
122132: ARRAY
122133: PUSH
122134: LD_VAR 0 3
122138: EQUAL
122139: AND
122140: IFFALSE 122243
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
122142: LD_EXP 228
122146: PUSH
122147: LD_VAR 0 6
122151: ARRAY
122152: PUSH
122153: LD_VAR 0 5
122157: ARRAY
122158: PUSH
122159: LD_INT 1
122161: ARRAY
122162: PPUSH
122163: LD_EXP 228
122167: PUSH
122168: LD_VAR 0 6
122172: ARRAY
122173: PUSH
122174: LD_VAR 0 5
122178: ARRAY
122179: PUSH
122180: LD_INT 2
122182: ARRAY
122183: PPUSH
122184: LD_VAR 0 1
122188: PPUSH
122189: CALL_OW 255
122193: PPUSH
122194: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
122198: LD_ADDR_EXP 228
122202: PUSH
122203: LD_EXP 228
122207: PPUSH
122208: LD_VAR 0 6
122212: PPUSH
122213: LD_EXP 228
122217: PUSH
122218: LD_VAR 0 6
122222: ARRAY
122223: PPUSH
122224: LD_VAR 0 5
122228: PPUSH
122229: CALL_OW 3
122233: PPUSH
122234: CALL_OW 1
122238: ST_TO_ADDR
// exit ;
122239: POP
122240: POP
122241: GO 122434
// end ; end ;
122243: GO 122083
122245: POP
122246: POP
// for i := minerMinesList [ index ] downto 1 do
122247: LD_ADDR_VAR 0 5
122251: PUSH
122252: DOUBLE
122253: LD_EXP 228
122257: PUSH
122258: LD_VAR 0 6
122262: ARRAY
122263: INC
122264: ST_TO_ADDR
122265: LD_INT 1
122267: PUSH
122268: FOR_DOWNTO
122269: IFFALSE 122432
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
122271: LD_EXP 228
122275: PUSH
122276: LD_VAR 0 6
122280: ARRAY
122281: PUSH
122282: LD_VAR 0 5
122286: ARRAY
122287: PUSH
122288: LD_INT 1
122290: ARRAY
122291: PPUSH
122292: LD_EXP 228
122296: PUSH
122297: LD_VAR 0 6
122301: ARRAY
122302: PUSH
122303: LD_VAR 0 5
122307: ARRAY
122308: PUSH
122309: LD_INT 2
122311: ARRAY
122312: PPUSH
122313: LD_VAR 0 2
122317: PPUSH
122318: LD_VAR 0 3
122322: PPUSH
122323: CALL_OW 298
122327: PUSH
122328: LD_INT 6
122330: LESS
122331: IFFALSE 122430
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
122333: LD_EXP 228
122337: PUSH
122338: LD_VAR 0 6
122342: ARRAY
122343: PUSH
122344: LD_VAR 0 5
122348: ARRAY
122349: PUSH
122350: LD_INT 1
122352: ARRAY
122353: PPUSH
122354: LD_EXP 228
122358: PUSH
122359: LD_VAR 0 6
122363: ARRAY
122364: PUSH
122365: LD_VAR 0 5
122369: ARRAY
122370: PUSH
122371: LD_INT 2
122373: ARRAY
122374: PPUSH
122375: LD_VAR 0 1
122379: PPUSH
122380: CALL_OW 255
122384: PPUSH
122385: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
122389: LD_ADDR_EXP 228
122393: PUSH
122394: LD_EXP 228
122398: PPUSH
122399: LD_VAR 0 6
122403: PPUSH
122404: LD_EXP 228
122408: PUSH
122409: LD_VAR 0 6
122413: ARRAY
122414: PPUSH
122415: LD_VAR 0 5
122419: PPUSH
122420: CALL_OW 3
122424: PPUSH
122425: CALL_OW 1
122429: ST_TO_ADDR
// end ; end ;
122430: GO 122268
122432: POP
122433: POP
// end ;
122434: LD_VAR 0 4
122438: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
122439: LD_INT 0
122441: PPUSH
122442: PPUSH
122443: PPUSH
122444: PPUSH
122445: PPUSH
122446: PPUSH
122447: PPUSH
122448: PPUSH
122449: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
122450: LD_VAR 0 1
122454: PPUSH
122455: CALL_OW 264
122459: PUSH
122460: LD_EXP 102
122464: EQUAL
122465: NOT
122466: PUSH
122467: LD_VAR 0 1
122471: PUSH
122472: LD_EXP 227
122476: IN
122477: NOT
122478: OR
122479: IFFALSE 122483
// exit ;
122481: GO 122805
// index := GetElementIndex ( minersList , unit ) ;
122483: LD_ADDR_VAR 0 6
122487: PUSH
122488: LD_EXP 227
122492: PPUSH
122493: LD_VAR 0 1
122497: PPUSH
122498: CALL 70656 0 2
122502: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
122503: LD_ADDR_VAR 0 8
122507: PUSH
122508: LD_EXP 229
122512: PUSH
122513: LD_EXP 228
122517: PUSH
122518: LD_VAR 0 6
122522: ARRAY
122523: MINUS
122524: ST_TO_ADDR
// if not minesFreeAmount then
122525: LD_VAR 0 8
122529: NOT
122530: IFFALSE 122534
// exit ;
122532: GO 122805
// tmp := [ ] ;
122534: LD_ADDR_VAR 0 7
122538: PUSH
122539: EMPTY
122540: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
122541: LD_ADDR_VAR 0 5
122545: PUSH
122546: DOUBLE
122547: LD_INT 1
122549: DEC
122550: ST_TO_ADDR
122551: LD_VAR 0 8
122555: PUSH
122556: FOR_TO
122557: IFFALSE 122752
// begin _d := rand ( 0 , 5 ) ;
122559: LD_ADDR_VAR 0 11
122563: PUSH
122564: LD_INT 0
122566: PPUSH
122567: LD_INT 5
122569: PPUSH
122570: CALL_OW 12
122574: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
122575: LD_ADDR_VAR 0 12
122579: PUSH
122580: LD_INT 2
122582: PPUSH
122583: LD_INT 6
122585: PPUSH
122586: CALL_OW 12
122590: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
122591: LD_ADDR_VAR 0 9
122595: PUSH
122596: LD_VAR 0 2
122600: PPUSH
122601: LD_VAR 0 11
122605: PPUSH
122606: LD_VAR 0 12
122610: PPUSH
122611: CALL_OW 272
122615: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
122616: LD_ADDR_VAR 0 10
122620: PUSH
122621: LD_VAR 0 3
122625: PPUSH
122626: LD_VAR 0 11
122630: PPUSH
122631: LD_VAR 0 12
122635: PPUSH
122636: CALL_OW 273
122640: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
122641: LD_VAR 0 9
122645: PPUSH
122646: LD_VAR 0 10
122650: PPUSH
122651: CALL_OW 488
122655: PUSH
122656: LD_VAR 0 9
122660: PUSH
122661: LD_VAR 0 10
122665: PUSH
122666: EMPTY
122667: LIST
122668: LIST
122669: PUSH
122670: LD_VAR 0 7
122674: IN
122675: NOT
122676: AND
122677: PUSH
122678: LD_VAR 0 9
122682: PPUSH
122683: LD_VAR 0 10
122687: PPUSH
122688: CALL_OW 458
122692: NOT
122693: AND
122694: IFFALSE 122736
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
122696: LD_ADDR_VAR 0 7
122700: PUSH
122701: LD_VAR 0 7
122705: PPUSH
122706: LD_VAR 0 7
122710: PUSH
122711: LD_INT 1
122713: PLUS
122714: PPUSH
122715: LD_VAR 0 9
122719: PUSH
122720: LD_VAR 0 10
122724: PUSH
122725: EMPTY
122726: LIST
122727: LIST
122728: PPUSH
122729: CALL_OW 1
122733: ST_TO_ADDR
122734: GO 122750
// i := i - 1 ;
122736: LD_ADDR_VAR 0 5
122740: PUSH
122741: LD_VAR 0 5
122745: PUSH
122746: LD_INT 1
122748: MINUS
122749: ST_TO_ADDR
// end ;
122750: GO 122556
122752: POP
122753: POP
// for i in tmp do
122754: LD_ADDR_VAR 0 5
122758: PUSH
122759: LD_VAR 0 7
122763: PUSH
122764: FOR_IN
122765: IFFALSE 122803
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
122767: LD_VAR 0 1
122771: PPUSH
122772: LD_VAR 0 5
122776: PUSH
122777: LD_INT 1
122779: ARRAY
122780: PPUSH
122781: LD_VAR 0 5
122785: PUSH
122786: LD_INT 2
122788: ARRAY
122789: PPUSH
122790: CALL 121745 0 3
122794: NOT
122795: IFFALSE 122801
// exit ;
122797: POP
122798: POP
122799: GO 122805
122801: GO 122764
122803: POP
122804: POP
// end ;
122805: LD_VAR 0 4
122809: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
122810: LD_INT 0
122812: PPUSH
122813: PPUSH
122814: PPUSH
122815: PPUSH
122816: PPUSH
122817: PPUSH
122818: PPUSH
// if not GetClass ( unit ) = class_sniper then
122819: LD_VAR 0 1
122823: PPUSH
122824: CALL_OW 257
122828: PUSH
122829: LD_INT 5
122831: EQUAL
122832: NOT
122833: IFFALSE 122837
// exit ;
122835: GO 123225
// dist := 8 ;
122837: LD_ADDR_VAR 0 5
122841: PUSH
122842: LD_INT 8
122844: ST_TO_ADDR
// viewRange := 12 ;
122845: LD_ADDR_VAR 0 7
122849: PUSH
122850: LD_INT 12
122852: ST_TO_ADDR
// side := GetSide ( unit ) ;
122853: LD_ADDR_VAR 0 6
122857: PUSH
122858: LD_VAR 0 1
122862: PPUSH
122863: CALL_OW 255
122867: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
122868: LD_INT 61
122870: PPUSH
122871: LD_VAR 0 6
122875: PPUSH
122876: CALL_OW 321
122880: PUSH
122881: LD_INT 2
122883: EQUAL
122884: IFFALSE 122894
// viewRange := 16 ;
122886: LD_ADDR_VAR 0 7
122890: PUSH
122891: LD_INT 16
122893: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
122894: LD_VAR 0 1
122898: PPUSH
122899: LD_VAR 0 2
122903: PPUSH
122904: LD_VAR 0 3
122908: PPUSH
122909: CALL_OW 297
122913: PUSH
122914: LD_VAR 0 5
122918: GREATER
122919: IFFALSE 122998
// begin ComMoveXY ( unit , x , y ) ;
122921: LD_VAR 0 1
122925: PPUSH
122926: LD_VAR 0 2
122930: PPUSH
122931: LD_VAR 0 3
122935: PPUSH
122936: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
122940: LD_INT 35
122942: PPUSH
122943: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
122947: LD_VAR 0 1
122951: PPUSH
122952: LD_VAR 0 2
122956: PPUSH
122957: LD_VAR 0 3
122961: PPUSH
122962: CALL 101428 0 3
122966: NOT
122967: IFFALSE 122971
// exit ;
122969: GO 123225
// until GetDistUnitXY ( unit , x , y ) < dist ;
122971: LD_VAR 0 1
122975: PPUSH
122976: LD_VAR 0 2
122980: PPUSH
122981: LD_VAR 0 3
122985: PPUSH
122986: CALL_OW 297
122990: PUSH
122991: LD_VAR 0 5
122995: LESS
122996: IFFALSE 122940
// end ; ComTurnXY ( unit , x , y ) ;
122998: LD_VAR 0 1
123002: PPUSH
123003: LD_VAR 0 2
123007: PPUSH
123008: LD_VAR 0 3
123012: PPUSH
123013: CALL_OW 118
// wait ( 5 ) ;
123017: LD_INT 5
123019: PPUSH
123020: CALL_OW 67
// _d := GetDir ( unit ) ;
123024: LD_ADDR_VAR 0 10
123028: PUSH
123029: LD_VAR 0 1
123033: PPUSH
123034: CALL_OW 254
123038: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
123039: LD_ADDR_VAR 0 8
123043: PUSH
123044: LD_VAR 0 1
123048: PPUSH
123049: CALL_OW 250
123053: PPUSH
123054: LD_VAR 0 10
123058: PPUSH
123059: LD_VAR 0 5
123063: PPUSH
123064: CALL_OW 272
123068: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
123069: LD_ADDR_VAR 0 9
123073: PUSH
123074: LD_VAR 0 1
123078: PPUSH
123079: CALL_OW 251
123083: PPUSH
123084: LD_VAR 0 10
123088: PPUSH
123089: LD_VAR 0 5
123093: PPUSH
123094: CALL_OW 273
123098: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
123099: LD_VAR 0 8
123103: PPUSH
123104: LD_VAR 0 9
123108: PPUSH
123109: CALL_OW 488
123113: NOT
123114: IFFALSE 123118
// exit ;
123116: GO 123225
// ComAnimCustom ( unit , 1 ) ;
123118: LD_VAR 0 1
123122: PPUSH
123123: LD_INT 1
123125: PPUSH
123126: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
123130: LD_VAR 0 8
123134: PPUSH
123135: LD_VAR 0 9
123139: PPUSH
123140: LD_VAR 0 6
123144: PPUSH
123145: LD_VAR 0 7
123149: PPUSH
123150: CALL_OW 330
// repeat wait ( 1 ) ;
123154: LD_INT 1
123156: PPUSH
123157: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
123161: LD_VAR 0 1
123165: PPUSH
123166: CALL_OW 316
123170: PUSH
123171: LD_VAR 0 1
123175: PPUSH
123176: CALL_OW 314
123180: OR
123181: PUSH
123182: LD_VAR 0 1
123186: PPUSH
123187: CALL_OW 302
123191: NOT
123192: OR
123193: PUSH
123194: LD_VAR 0 1
123198: PPUSH
123199: CALL_OW 301
123203: OR
123204: IFFALSE 123154
// RemoveSeeing ( _x , _y , side ) ;
123206: LD_VAR 0 8
123210: PPUSH
123211: LD_VAR 0 9
123215: PPUSH
123216: LD_VAR 0 6
123220: PPUSH
123221: CALL_OW 331
// end ; end_of_file
123225: LD_VAR 0 4
123229: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
123230: LD_INT 0
123232: PPUSH
123233: PPUSH
123234: PPUSH
123235: PPUSH
123236: PPUSH
123237: PPUSH
123238: PPUSH
123239: PPUSH
123240: PPUSH
123241: PPUSH
123242: PPUSH
123243: PPUSH
123244: PPUSH
123245: PPUSH
123246: PPUSH
123247: PPUSH
123248: PPUSH
123249: PPUSH
123250: PPUSH
123251: PPUSH
123252: PPUSH
123253: PPUSH
123254: PPUSH
123255: PPUSH
123256: PPUSH
123257: PPUSH
123258: PPUSH
123259: PPUSH
123260: PPUSH
123261: PPUSH
123262: PPUSH
123263: PPUSH
123264: PPUSH
123265: PPUSH
// if not list then
123266: LD_VAR 0 1
123270: NOT
123271: IFFALSE 123275
// exit ;
123273: GO 127934
// base := list [ 1 ] ;
123275: LD_ADDR_VAR 0 3
123279: PUSH
123280: LD_VAR 0 1
123284: PUSH
123285: LD_INT 1
123287: ARRAY
123288: ST_TO_ADDR
// group := list [ 2 ] ;
123289: LD_ADDR_VAR 0 4
123293: PUSH
123294: LD_VAR 0 1
123298: PUSH
123299: LD_INT 2
123301: ARRAY
123302: ST_TO_ADDR
// path := list [ 3 ] ;
123303: LD_ADDR_VAR 0 5
123307: PUSH
123308: LD_VAR 0 1
123312: PUSH
123313: LD_INT 3
123315: ARRAY
123316: ST_TO_ADDR
// flags := list [ 4 ] ;
123317: LD_ADDR_VAR 0 6
123321: PUSH
123322: LD_VAR 0 1
123326: PUSH
123327: LD_INT 4
123329: ARRAY
123330: ST_TO_ADDR
// mined := [ ] ;
123331: LD_ADDR_VAR 0 27
123335: PUSH
123336: EMPTY
123337: ST_TO_ADDR
// bombed := [ ] ;
123338: LD_ADDR_VAR 0 28
123342: PUSH
123343: EMPTY
123344: ST_TO_ADDR
// healers := [ ] ;
123345: LD_ADDR_VAR 0 31
123349: PUSH
123350: EMPTY
123351: ST_TO_ADDR
// to_heal := [ ] ;
123352: LD_ADDR_VAR 0 30
123356: PUSH
123357: EMPTY
123358: ST_TO_ADDR
// repairs := [ ] ;
123359: LD_ADDR_VAR 0 33
123363: PUSH
123364: EMPTY
123365: ST_TO_ADDR
// to_repair := [ ] ;
123366: LD_ADDR_VAR 0 32
123370: PUSH
123371: EMPTY
123372: ST_TO_ADDR
// if not group or not path then
123373: LD_VAR 0 4
123377: NOT
123378: PUSH
123379: LD_VAR 0 5
123383: NOT
123384: OR
123385: IFFALSE 123389
// exit ;
123387: GO 127934
// side := GetSide ( group [ 1 ] ) ;
123389: LD_ADDR_VAR 0 35
123393: PUSH
123394: LD_VAR 0 4
123398: PUSH
123399: LD_INT 1
123401: ARRAY
123402: PPUSH
123403: CALL_OW 255
123407: ST_TO_ADDR
// if flags then
123408: LD_VAR 0 6
123412: IFFALSE 123556
// begin f_ignore_area := flags [ 1 ] ;
123414: LD_ADDR_VAR 0 17
123418: PUSH
123419: LD_VAR 0 6
123423: PUSH
123424: LD_INT 1
123426: ARRAY
123427: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
123428: LD_ADDR_VAR 0 18
123432: PUSH
123433: LD_VAR 0 6
123437: PUSH
123438: LD_INT 2
123440: ARRAY
123441: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
123442: LD_ADDR_VAR 0 19
123446: PUSH
123447: LD_VAR 0 6
123451: PUSH
123452: LD_INT 3
123454: ARRAY
123455: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
123456: LD_ADDR_VAR 0 20
123460: PUSH
123461: LD_VAR 0 6
123465: PUSH
123466: LD_INT 4
123468: ARRAY
123469: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
123470: LD_ADDR_VAR 0 21
123474: PUSH
123475: LD_VAR 0 6
123479: PUSH
123480: LD_INT 5
123482: ARRAY
123483: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
123484: LD_ADDR_VAR 0 22
123488: PUSH
123489: LD_VAR 0 6
123493: PUSH
123494: LD_INT 6
123496: ARRAY
123497: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
123498: LD_ADDR_VAR 0 23
123502: PUSH
123503: LD_VAR 0 6
123507: PUSH
123508: LD_INT 7
123510: ARRAY
123511: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
123512: LD_ADDR_VAR 0 24
123516: PUSH
123517: LD_VAR 0 6
123521: PUSH
123522: LD_INT 8
123524: ARRAY
123525: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
123526: LD_ADDR_VAR 0 25
123530: PUSH
123531: LD_VAR 0 6
123535: PUSH
123536: LD_INT 9
123538: ARRAY
123539: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
123540: LD_ADDR_VAR 0 26
123544: PUSH
123545: LD_VAR 0 6
123549: PUSH
123550: LD_INT 10
123552: ARRAY
123553: ST_TO_ADDR
// end else
123554: GO 123636
// begin f_ignore_area := false ;
123556: LD_ADDR_VAR 0 17
123560: PUSH
123561: LD_INT 0
123563: ST_TO_ADDR
// f_capture := false ;
123564: LD_ADDR_VAR 0 18
123568: PUSH
123569: LD_INT 0
123571: ST_TO_ADDR
// f_ignore_civ := false ;
123572: LD_ADDR_VAR 0 19
123576: PUSH
123577: LD_INT 0
123579: ST_TO_ADDR
// f_murder := false ;
123580: LD_ADDR_VAR 0 20
123584: PUSH
123585: LD_INT 0
123587: ST_TO_ADDR
// f_mines := false ;
123588: LD_ADDR_VAR 0 21
123592: PUSH
123593: LD_INT 0
123595: ST_TO_ADDR
// f_repair := false ;
123596: LD_ADDR_VAR 0 22
123600: PUSH
123601: LD_INT 0
123603: ST_TO_ADDR
// f_heal := false ;
123604: LD_ADDR_VAR 0 23
123608: PUSH
123609: LD_INT 0
123611: ST_TO_ADDR
// f_spacetime := false ;
123612: LD_ADDR_VAR 0 24
123616: PUSH
123617: LD_INT 0
123619: ST_TO_ADDR
// f_attack_depot := false ;
123620: LD_ADDR_VAR 0 25
123624: PUSH
123625: LD_INT 0
123627: ST_TO_ADDR
// f_crawl := false ;
123628: LD_ADDR_VAR 0 26
123632: PUSH
123633: LD_INT 0
123635: ST_TO_ADDR
// end ; if f_heal then
123636: LD_VAR 0 23
123640: IFFALSE 123667
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
123642: LD_ADDR_VAR 0 31
123646: PUSH
123647: LD_VAR 0 4
123651: PPUSH
123652: LD_INT 25
123654: PUSH
123655: LD_INT 4
123657: PUSH
123658: EMPTY
123659: LIST
123660: LIST
123661: PPUSH
123662: CALL_OW 72
123666: ST_TO_ADDR
// if f_repair then
123667: LD_VAR 0 22
123671: IFFALSE 123698
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
123673: LD_ADDR_VAR 0 33
123677: PUSH
123678: LD_VAR 0 4
123682: PPUSH
123683: LD_INT 25
123685: PUSH
123686: LD_INT 3
123688: PUSH
123689: EMPTY
123690: LIST
123691: LIST
123692: PPUSH
123693: CALL_OW 72
123697: ST_TO_ADDR
// units_path := [ ] ;
123698: LD_ADDR_VAR 0 16
123702: PUSH
123703: EMPTY
123704: ST_TO_ADDR
// for i = 1 to group do
123705: LD_ADDR_VAR 0 7
123709: PUSH
123710: DOUBLE
123711: LD_INT 1
123713: DEC
123714: ST_TO_ADDR
123715: LD_VAR 0 4
123719: PUSH
123720: FOR_TO
123721: IFFALSE 123750
// units_path := Replace ( units_path , i , path ) ;
123723: LD_ADDR_VAR 0 16
123727: PUSH
123728: LD_VAR 0 16
123732: PPUSH
123733: LD_VAR 0 7
123737: PPUSH
123738: LD_VAR 0 5
123742: PPUSH
123743: CALL_OW 1
123747: ST_TO_ADDR
123748: GO 123720
123750: POP
123751: POP
// repeat for i = group downto 1 do
123752: LD_ADDR_VAR 0 7
123756: PUSH
123757: DOUBLE
123758: LD_VAR 0 4
123762: INC
123763: ST_TO_ADDR
123764: LD_INT 1
123766: PUSH
123767: FOR_DOWNTO
123768: IFFALSE 127890
// begin wait ( 5 ) ;
123770: LD_INT 5
123772: PPUSH
123773: CALL_OW 67
// tmp := [ ] ;
123777: LD_ADDR_VAR 0 14
123781: PUSH
123782: EMPTY
123783: ST_TO_ADDR
// attacking := false ;
123784: LD_ADDR_VAR 0 29
123788: PUSH
123789: LD_INT 0
123791: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
123792: LD_VAR 0 4
123796: PUSH
123797: LD_VAR 0 7
123801: ARRAY
123802: PPUSH
123803: CALL_OW 301
123807: PUSH
123808: LD_VAR 0 4
123812: PUSH
123813: LD_VAR 0 7
123817: ARRAY
123818: NOT
123819: OR
123820: IFFALSE 123929
// begin if GetType ( group [ i ] ) = unit_human then
123822: LD_VAR 0 4
123826: PUSH
123827: LD_VAR 0 7
123831: ARRAY
123832: PPUSH
123833: CALL_OW 247
123837: PUSH
123838: LD_INT 1
123840: EQUAL
123841: IFFALSE 123887
// begin to_heal := to_heal diff group [ i ] ;
123843: LD_ADDR_VAR 0 30
123847: PUSH
123848: LD_VAR 0 30
123852: PUSH
123853: LD_VAR 0 4
123857: PUSH
123858: LD_VAR 0 7
123862: ARRAY
123863: DIFF
123864: ST_TO_ADDR
// healers := healers diff group [ i ] ;
123865: LD_ADDR_VAR 0 31
123869: PUSH
123870: LD_VAR 0 31
123874: PUSH
123875: LD_VAR 0 4
123879: PUSH
123880: LD_VAR 0 7
123884: ARRAY
123885: DIFF
123886: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
123887: LD_ADDR_VAR 0 4
123891: PUSH
123892: LD_VAR 0 4
123896: PPUSH
123897: LD_VAR 0 7
123901: PPUSH
123902: CALL_OW 3
123906: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
123907: LD_ADDR_VAR 0 16
123911: PUSH
123912: LD_VAR 0 16
123916: PPUSH
123917: LD_VAR 0 7
123921: PPUSH
123922: CALL_OW 3
123926: ST_TO_ADDR
// continue ;
123927: GO 123767
// end ; if f_repair then
123929: LD_VAR 0 22
123933: IFFALSE 124422
// begin if GetType ( group [ i ] ) = unit_vehicle then
123935: LD_VAR 0 4
123939: PUSH
123940: LD_VAR 0 7
123944: ARRAY
123945: PPUSH
123946: CALL_OW 247
123950: PUSH
123951: LD_INT 2
123953: EQUAL
123954: IFFALSE 124144
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
123956: LD_VAR 0 4
123960: PUSH
123961: LD_VAR 0 7
123965: ARRAY
123966: PPUSH
123967: CALL_OW 256
123971: PUSH
123972: LD_INT 700
123974: LESS
123975: PUSH
123976: LD_VAR 0 4
123980: PUSH
123981: LD_VAR 0 7
123985: ARRAY
123986: PUSH
123987: LD_VAR 0 32
123991: IN
123992: NOT
123993: AND
123994: IFFALSE 124018
// to_repair := to_repair union group [ i ] ;
123996: LD_ADDR_VAR 0 32
124000: PUSH
124001: LD_VAR 0 32
124005: PUSH
124006: LD_VAR 0 4
124010: PUSH
124011: LD_VAR 0 7
124015: ARRAY
124016: UNION
124017: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
124018: LD_VAR 0 4
124022: PUSH
124023: LD_VAR 0 7
124027: ARRAY
124028: PPUSH
124029: CALL_OW 256
124033: PUSH
124034: LD_INT 1000
124036: EQUAL
124037: PUSH
124038: LD_VAR 0 4
124042: PUSH
124043: LD_VAR 0 7
124047: ARRAY
124048: PUSH
124049: LD_VAR 0 32
124053: IN
124054: AND
124055: IFFALSE 124079
// to_repair := to_repair diff group [ i ] ;
124057: LD_ADDR_VAR 0 32
124061: PUSH
124062: LD_VAR 0 32
124066: PUSH
124067: LD_VAR 0 4
124071: PUSH
124072: LD_VAR 0 7
124076: ARRAY
124077: DIFF
124078: ST_TO_ADDR
// if group [ i ] in to_repair then
124079: LD_VAR 0 4
124083: PUSH
124084: LD_VAR 0 7
124088: ARRAY
124089: PUSH
124090: LD_VAR 0 32
124094: IN
124095: IFFALSE 124142
// begin if not IsInArea ( group [ i ] , f_repair ) then
124097: LD_VAR 0 4
124101: PUSH
124102: LD_VAR 0 7
124106: ARRAY
124107: PPUSH
124108: LD_VAR 0 22
124112: PPUSH
124113: CALL_OW 308
124117: NOT
124118: IFFALSE 124140
// ComMoveToArea ( group [ i ] , f_repair ) ;
124120: LD_VAR 0 4
124124: PUSH
124125: LD_VAR 0 7
124129: ARRAY
124130: PPUSH
124131: LD_VAR 0 22
124135: PPUSH
124136: CALL_OW 113
// continue ;
124140: GO 123767
// end ; end else
124142: GO 124422
// if group [ i ] in repairs then
124144: LD_VAR 0 4
124148: PUSH
124149: LD_VAR 0 7
124153: ARRAY
124154: PUSH
124155: LD_VAR 0 33
124159: IN
124160: IFFALSE 124422
// begin if IsInUnit ( group [ i ] ) then
124162: LD_VAR 0 4
124166: PUSH
124167: LD_VAR 0 7
124171: ARRAY
124172: PPUSH
124173: CALL_OW 310
124177: IFFALSE 124245
// begin z := IsInUnit ( group [ i ] ) ;
124179: LD_ADDR_VAR 0 13
124183: PUSH
124184: LD_VAR 0 4
124188: PUSH
124189: LD_VAR 0 7
124193: ARRAY
124194: PPUSH
124195: CALL_OW 310
124199: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
124200: LD_VAR 0 13
124204: PUSH
124205: LD_VAR 0 32
124209: IN
124210: PUSH
124211: LD_VAR 0 13
124215: PPUSH
124216: LD_VAR 0 22
124220: PPUSH
124221: CALL_OW 308
124225: AND
124226: IFFALSE 124243
// ComExitVehicle ( group [ i ] ) ;
124228: LD_VAR 0 4
124232: PUSH
124233: LD_VAR 0 7
124237: ARRAY
124238: PPUSH
124239: CALL_OW 121
// end else
124243: GO 124422
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
124245: LD_ADDR_VAR 0 13
124249: PUSH
124250: LD_VAR 0 4
124254: PPUSH
124255: LD_INT 95
124257: PUSH
124258: LD_VAR 0 22
124262: PUSH
124263: EMPTY
124264: LIST
124265: LIST
124266: PUSH
124267: LD_INT 58
124269: PUSH
124270: EMPTY
124271: LIST
124272: PUSH
124273: EMPTY
124274: LIST
124275: LIST
124276: PPUSH
124277: CALL_OW 72
124281: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
124282: LD_VAR 0 4
124286: PUSH
124287: LD_VAR 0 7
124291: ARRAY
124292: PPUSH
124293: CALL_OW 314
124297: NOT
124298: IFFALSE 124420
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
124300: LD_ADDR_VAR 0 10
124304: PUSH
124305: LD_VAR 0 13
124309: PPUSH
124310: LD_VAR 0 4
124314: PUSH
124315: LD_VAR 0 7
124319: ARRAY
124320: PPUSH
124321: CALL_OW 74
124325: ST_TO_ADDR
// if not x then
124326: LD_VAR 0 10
124330: NOT
124331: IFFALSE 124335
// continue ;
124333: GO 123767
// if GetLives ( x ) < 1000 then
124335: LD_VAR 0 10
124339: PPUSH
124340: CALL_OW 256
124344: PUSH
124345: LD_INT 1000
124347: LESS
124348: IFFALSE 124372
// ComRepairVehicle ( group [ i ] , x ) else
124350: LD_VAR 0 4
124354: PUSH
124355: LD_VAR 0 7
124359: ARRAY
124360: PPUSH
124361: LD_VAR 0 10
124365: PPUSH
124366: CALL_OW 129
124370: GO 124420
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
124372: LD_VAR 0 23
124376: PUSH
124377: LD_VAR 0 4
124381: PUSH
124382: LD_VAR 0 7
124386: ARRAY
124387: PPUSH
124388: CALL_OW 256
124392: PUSH
124393: LD_INT 1000
124395: LESS
124396: AND
124397: NOT
124398: IFFALSE 124420
// ComEnterUnit ( group [ i ] , x ) ;
124400: LD_VAR 0 4
124404: PUSH
124405: LD_VAR 0 7
124409: ARRAY
124410: PPUSH
124411: LD_VAR 0 10
124415: PPUSH
124416: CALL_OW 120
// end ; continue ;
124420: GO 123767
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
124422: LD_VAR 0 23
124426: PUSH
124427: LD_VAR 0 4
124431: PUSH
124432: LD_VAR 0 7
124436: ARRAY
124437: PPUSH
124438: CALL_OW 247
124442: PUSH
124443: LD_INT 1
124445: EQUAL
124446: AND
124447: IFFALSE 124925
// begin if group [ i ] in healers then
124449: LD_VAR 0 4
124453: PUSH
124454: LD_VAR 0 7
124458: ARRAY
124459: PUSH
124460: LD_VAR 0 31
124464: IN
124465: IFFALSE 124738
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
124467: LD_VAR 0 4
124471: PUSH
124472: LD_VAR 0 7
124476: ARRAY
124477: PPUSH
124478: LD_VAR 0 23
124482: PPUSH
124483: CALL_OW 308
124487: NOT
124488: PUSH
124489: LD_VAR 0 4
124493: PUSH
124494: LD_VAR 0 7
124498: ARRAY
124499: PPUSH
124500: CALL_OW 314
124504: NOT
124505: AND
124506: IFFALSE 124530
// ComMoveToArea ( group [ i ] , f_heal ) else
124508: LD_VAR 0 4
124512: PUSH
124513: LD_VAR 0 7
124517: ARRAY
124518: PPUSH
124519: LD_VAR 0 23
124523: PPUSH
124524: CALL_OW 113
124528: GO 124736
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
124530: LD_VAR 0 4
124534: PUSH
124535: LD_VAR 0 7
124539: ARRAY
124540: PPUSH
124541: CALL 99951 0 1
124545: PPUSH
124546: CALL_OW 256
124550: PUSH
124551: LD_INT 1000
124553: EQUAL
124554: IFFALSE 124573
// ComStop ( group [ i ] ) else
124556: LD_VAR 0 4
124560: PUSH
124561: LD_VAR 0 7
124565: ARRAY
124566: PPUSH
124567: CALL_OW 141
124571: GO 124736
// if not HasTask ( group [ i ] ) and to_heal then
124573: LD_VAR 0 4
124577: PUSH
124578: LD_VAR 0 7
124582: ARRAY
124583: PPUSH
124584: CALL_OW 314
124588: NOT
124589: PUSH
124590: LD_VAR 0 30
124594: AND
124595: IFFALSE 124736
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
124597: LD_ADDR_VAR 0 13
124601: PUSH
124602: LD_VAR 0 30
124606: PPUSH
124607: LD_INT 3
124609: PUSH
124610: LD_INT 54
124612: PUSH
124613: EMPTY
124614: LIST
124615: PUSH
124616: EMPTY
124617: LIST
124618: LIST
124619: PPUSH
124620: CALL_OW 72
124624: PPUSH
124625: LD_VAR 0 4
124629: PUSH
124630: LD_VAR 0 7
124634: ARRAY
124635: PPUSH
124636: CALL_OW 74
124640: ST_TO_ADDR
// if z then
124641: LD_VAR 0 13
124645: IFFALSE 124736
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
124647: LD_INT 91
124649: PUSH
124650: LD_VAR 0 13
124654: PUSH
124655: LD_INT 10
124657: PUSH
124658: EMPTY
124659: LIST
124660: LIST
124661: LIST
124662: PUSH
124663: LD_INT 81
124665: PUSH
124666: LD_VAR 0 13
124670: PPUSH
124671: CALL_OW 255
124675: PUSH
124676: EMPTY
124677: LIST
124678: LIST
124679: PUSH
124680: EMPTY
124681: LIST
124682: LIST
124683: PPUSH
124684: CALL_OW 69
124688: PUSH
124689: LD_INT 0
124691: EQUAL
124692: IFFALSE 124716
// ComHeal ( group [ i ] , z ) else
124694: LD_VAR 0 4
124698: PUSH
124699: LD_VAR 0 7
124703: ARRAY
124704: PPUSH
124705: LD_VAR 0 13
124709: PPUSH
124710: CALL_OW 128
124714: GO 124736
// ComMoveToArea ( group [ i ] , f_heal ) ;
124716: LD_VAR 0 4
124720: PUSH
124721: LD_VAR 0 7
124725: ARRAY
124726: PPUSH
124727: LD_VAR 0 23
124731: PPUSH
124732: CALL_OW 113
// end ; continue ;
124736: GO 123767
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
124738: LD_VAR 0 4
124742: PUSH
124743: LD_VAR 0 7
124747: ARRAY
124748: PPUSH
124749: CALL_OW 256
124753: PUSH
124754: LD_INT 700
124756: LESS
124757: PUSH
124758: LD_VAR 0 4
124762: PUSH
124763: LD_VAR 0 7
124767: ARRAY
124768: PUSH
124769: LD_VAR 0 30
124773: IN
124774: NOT
124775: AND
124776: IFFALSE 124800
// to_heal := to_heal union group [ i ] ;
124778: LD_ADDR_VAR 0 30
124782: PUSH
124783: LD_VAR 0 30
124787: PUSH
124788: LD_VAR 0 4
124792: PUSH
124793: LD_VAR 0 7
124797: ARRAY
124798: UNION
124799: ST_TO_ADDR
// if group [ i ] in to_heal then
124800: LD_VAR 0 4
124804: PUSH
124805: LD_VAR 0 7
124809: ARRAY
124810: PUSH
124811: LD_VAR 0 30
124815: IN
124816: IFFALSE 124925
// begin if GetLives ( group [ i ] ) = 1000 then
124818: LD_VAR 0 4
124822: PUSH
124823: LD_VAR 0 7
124827: ARRAY
124828: PPUSH
124829: CALL_OW 256
124833: PUSH
124834: LD_INT 1000
124836: EQUAL
124837: IFFALSE 124863
// to_heal := to_heal diff group [ i ] else
124839: LD_ADDR_VAR 0 30
124843: PUSH
124844: LD_VAR 0 30
124848: PUSH
124849: LD_VAR 0 4
124853: PUSH
124854: LD_VAR 0 7
124858: ARRAY
124859: DIFF
124860: ST_TO_ADDR
124861: GO 124925
// begin if not IsInArea ( group [ i ] , to_heal ) then
124863: LD_VAR 0 4
124867: PUSH
124868: LD_VAR 0 7
124872: ARRAY
124873: PPUSH
124874: LD_VAR 0 30
124878: PPUSH
124879: CALL_OW 308
124883: NOT
124884: IFFALSE 124908
// ComMoveToArea ( group [ i ] , f_heal ) else
124886: LD_VAR 0 4
124890: PUSH
124891: LD_VAR 0 7
124895: ARRAY
124896: PPUSH
124897: LD_VAR 0 23
124901: PPUSH
124902: CALL_OW 113
124906: GO 124923
// ComHold ( group [ i ] ) ;
124908: LD_VAR 0 4
124912: PUSH
124913: LD_VAR 0 7
124917: ARRAY
124918: PPUSH
124919: CALL_OW 140
// continue ;
124923: GO 123767
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
124925: LD_VAR 0 4
124929: PUSH
124930: LD_VAR 0 7
124934: ARRAY
124935: PPUSH
124936: LD_INT 10
124938: PPUSH
124939: CALL 98371 0 2
124943: NOT
124944: PUSH
124945: LD_VAR 0 16
124949: PUSH
124950: LD_VAR 0 7
124954: ARRAY
124955: PUSH
124956: EMPTY
124957: EQUAL
124958: NOT
124959: AND
124960: IFFALSE 125226
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
124962: LD_VAR 0 4
124966: PUSH
124967: LD_VAR 0 7
124971: ARRAY
124972: PPUSH
124973: CALL_OW 262
124977: PUSH
124978: LD_INT 1
124980: PUSH
124981: LD_INT 2
124983: PUSH
124984: EMPTY
124985: LIST
124986: LIST
124987: IN
124988: IFFALSE 125029
// if GetFuel ( group [ i ] ) < 10 then
124990: LD_VAR 0 4
124994: PUSH
124995: LD_VAR 0 7
124999: ARRAY
125000: PPUSH
125001: CALL_OW 261
125005: PUSH
125006: LD_INT 10
125008: LESS
125009: IFFALSE 125029
// SetFuel ( group [ i ] , 12 ) ;
125011: LD_VAR 0 4
125015: PUSH
125016: LD_VAR 0 7
125020: ARRAY
125021: PPUSH
125022: LD_INT 12
125024: PPUSH
125025: CALL_OW 240
// if units_path [ i ] then
125029: LD_VAR 0 16
125033: PUSH
125034: LD_VAR 0 7
125038: ARRAY
125039: IFFALSE 125224
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
125041: LD_VAR 0 4
125045: PUSH
125046: LD_VAR 0 7
125050: ARRAY
125051: PPUSH
125052: LD_VAR 0 16
125056: PUSH
125057: LD_VAR 0 7
125061: ARRAY
125062: PUSH
125063: LD_INT 1
125065: ARRAY
125066: PUSH
125067: LD_INT 1
125069: ARRAY
125070: PPUSH
125071: LD_VAR 0 16
125075: PUSH
125076: LD_VAR 0 7
125080: ARRAY
125081: PUSH
125082: LD_INT 1
125084: ARRAY
125085: PUSH
125086: LD_INT 2
125088: ARRAY
125089: PPUSH
125090: CALL_OW 297
125094: PUSH
125095: LD_INT 6
125097: GREATER
125098: IFFALSE 125173
// begin if not HasTask ( group [ i ] ) then
125100: LD_VAR 0 4
125104: PUSH
125105: LD_VAR 0 7
125109: ARRAY
125110: PPUSH
125111: CALL_OW 314
125115: NOT
125116: IFFALSE 125171
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
125118: LD_VAR 0 4
125122: PUSH
125123: LD_VAR 0 7
125127: ARRAY
125128: PPUSH
125129: LD_VAR 0 16
125133: PUSH
125134: LD_VAR 0 7
125138: ARRAY
125139: PUSH
125140: LD_INT 1
125142: ARRAY
125143: PUSH
125144: LD_INT 1
125146: ARRAY
125147: PPUSH
125148: LD_VAR 0 16
125152: PUSH
125153: LD_VAR 0 7
125157: ARRAY
125158: PUSH
125159: LD_INT 1
125161: ARRAY
125162: PUSH
125163: LD_INT 2
125165: ARRAY
125166: PPUSH
125167: CALL_OW 114
// end else
125171: GO 125224
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
125173: LD_ADDR_VAR 0 15
125177: PUSH
125178: LD_VAR 0 16
125182: PUSH
125183: LD_VAR 0 7
125187: ARRAY
125188: PPUSH
125189: LD_INT 1
125191: PPUSH
125192: CALL_OW 3
125196: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
125197: LD_ADDR_VAR 0 16
125201: PUSH
125202: LD_VAR 0 16
125206: PPUSH
125207: LD_VAR 0 7
125211: PPUSH
125212: LD_VAR 0 15
125216: PPUSH
125217: CALL_OW 1
125221: ST_TO_ADDR
// continue ;
125222: GO 123767
// end ; end ; end else
125224: GO 127888
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
125226: LD_ADDR_VAR 0 14
125230: PUSH
125231: LD_INT 81
125233: PUSH
125234: LD_VAR 0 4
125238: PUSH
125239: LD_VAR 0 7
125243: ARRAY
125244: PPUSH
125245: CALL_OW 255
125249: PUSH
125250: EMPTY
125251: LIST
125252: LIST
125253: PPUSH
125254: CALL_OW 69
125258: ST_TO_ADDR
// if not tmp then
125259: LD_VAR 0 14
125263: NOT
125264: IFFALSE 125268
// continue ;
125266: GO 123767
// if f_ignore_area then
125268: LD_VAR 0 17
125272: IFFALSE 125360
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
125274: LD_ADDR_VAR 0 15
125278: PUSH
125279: LD_VAR 0 14
125283: PPUSH
125284: LD_INT 3
125286: PUSH
125287: LD_INT 92
125289: PUSH
125290: LD_VAR 0 17
125294: PUSH
125295: LD_INT 1
125297: ARRAY
125298: PUSH
125299: LD_VAR 0 17
125303: PUSH
125304: LD_INT 2
125306: ARRAY
125307: PUSH
125308: LD_VAR 0 17
125312: PUSH
125313: LD_INT 3
125315: ARRAY
125316: PUSH
125317: EMPTY
125318: LIST
125319: LIST
125320: LIST
125321: LIST
125322: PUSH
125323: EMPTY
125324: LIST
125325: LIST
125326: PPUSH
125327: CALL_OW 72
125331: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
125332: LD_VAR 0 14
125336: PUSH
125337: LD_VAR 0 15
125341: DIFF
125342: IFFALSE 125360
// tmp := tmp diff tmp2 ;
125344: LD_ADDR_VAR 0 14
125348: PUSH
125349: LD_VAR 0 14
125353: PUSH
125354: LD_VAR 0 15
125358: DIFF
125359: ST_TO_ADDR
// end ; if not f_murder then
125360: LD_VAR 0 20
125364: NOT
125365: IFFALSE 125423
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
125367: LD_ADDR_VAR 0 15
125371: PUSH
125372: LD_VAR 0 14
125376: PPUSH
125377: LD_INT 3
125379: PUSH
125380: LD_INT 50
125382: PUSH
125383: EMPTY
125384: LIST
125385: PUSH
125386: EMPTY
125387: LIST
125388: LIST
125389: PPUSH
125390: CALL_OW 72
125394: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
125395: LD_VAR 0 14
125399: PUSH
125400: LD_VAR 0 15
125404: DIFF
125405: IFFALSE 125423
// tmp := tmp diff tmp2 ;
125407: LD_ADDR_VAR 0 14
125411: PUSH
125412: LD_VAR 0 14
125416: PUSH
125417: LD_VAR 0 15
125421: DIFF
125422: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
125423: LD_ADDR_VAR 0 14
125427: PUSH
125428: LD_VAR 0 4
125432: PUSH
125433: LD_VAR 0 7
125437: ARRAY
125438: PPUSH
125439: LD_VAR 0 14
125443: PPUSH
125444: LD_INT 1
125446: PPUSH
125447: LD_INT 1
125449: PPUSH
125450: CALL 71306 0 4
125454: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
125455: LD_VAR 0 4
125459: PUSH
125460: LD_VAR 0 7
125464: ARRAY
125465: PPUSH
125466: CALL_OW 257
125470: PUSH
125471: LD_INT 1
125473: EQUAL
125474: IFFALSE 125922
// begin if WantPlant ( group [ i ] ) then
125476: LD_VAR 0 4
125480: PUSH
125481: LD_VAR 0 7
125485: ARRAY
125486: PPUSH
125487: CALL 70807 0 1
125491: IFFALSE 125495
// continue ;
125493: GO 123767
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
125495: LD_VAR 0 18
125499: PUSH
125500: LD_VAR 0 4
125504: PUSH
125505: LD_VAR 0 7
125509: ARRAY
125510: PPUSH
125511: CALL_OW 310
125515: NOT
125516: AND
125517: PUSH
125518: LD_VAR 0 14
125522: PUSH
125523: LD_INT 1
125525: ARRAY
125526: PUSH
125527: LD_VAR 0 14
125531: PPUSH
125532: LD_INT 21
125534: PUSH
125535: LD_INT 2
125537: PUSH
125538: EMPTY
125539: LIST
125540: LIST
125541: PUSH
125542: LD_INT 58
125544: PUSH
125545: EMPTY
125546: LIST
125547: PUSH
125548: EMPTY
125549: LIST
125550: LIST
125551: PPUSH
125552: CALL_OW 72
125556: IN
125557: AND
125558: IFFALSE 125594
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
125560: LD_VAR 0 4
125564: PUSH
125565: LD_VAR 0 7
125569: ARRAY
125570: PPUSH
125571: LD_VAR 0 14
125575: PUSH
125576: LD_INT 1
125578: ARRAY
125579: PPUSH
125580: CALL_OW 120
// attacking := true ;
125584: LD_ADDR_VAR 0 29
125588: PUSH
125589: LD_INT 1
125591: ST_TO_ADDR
// continue ;
125592: GO 123767
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
125594: LD_VAR 0 26
125598: PUSH
125599: LD_VAR 0 4
125603: PUSH
125604: LD_VAR 0 7
125608: ARRAY
125609: PPUSH
125610: CALL_OW 257
125614: PUSH
125615: LD_INT 1
125617: EQUAL
125618: AND
125619: PUSH
125620: LD_VAR 0 4
125624: PUSH
125625: LD_VAR 0 7
125629: ARRAY
125630: PPUSH
125631: CALL_OW 256
125635: PUSH
125636: LD_INT 800
125638: LESS
125639: AND
125640: PUSH
125641: LD_VAR 0 4
125645: PUSH
125646: LD_VAR 0 7
125650: ARRAY
125651: PPUSH
125652: CALL_OW 318
125656: NOT
125657: AND
125658: IFFALSE 125675
// ComCrawl ( group [ i ] ) ;
125660: LD_VAR 0 4
125664: PUSH
125665: LD_VAR 0 7
125669: ARRAY
125670: PPUSH
125671: CALL_OW 137
// if f_mines then
125675: LD_VAR 0 21
125679: IFFALSE 125922
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
125681: LD_VAR 0 14
125685: PUSH
125686: LD_INT 1
125688: ARRAY
125689: PPUSH
125690: CALL_OW 247
125694: PUSH
125695: LD_INT 3
125697: EQUAL
125698: PUSH
125699: LD_VAR 0 14
125703: PUSH
125704: LD_INT 1
125706: ARRAY
125707: PUSH
125708: LD_VAR 0 27
125712: IN
125713: NOT
125714: AND
125715: IFFALSE 125922
// begin x := GetX ( tmp [ 1 ] ) ;
125717: LD_ADDR_VAR 0 10
125721: PUSH
125722: LD_VAR 0 14
125726: PUSH
125727: LD_INT 1
125729: ARRAY
125730: PPUSH
125731: CALL_OW 250
125735: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
125736: LD_ADDR_VAR 0 11
125740: PUSH
125741: LD_VAR 0 14
125745: PUSH
125746: LD_INT 1
125748: ARRAY
125749: PPUSH
125750: CALL_OW 251
125754: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
125755: LD_ADDR_VAR 0 12
125759: PUSH
125760: LD_VAR 0 4
125764: PUSH
125765: LD_VAR 0 7
125769: ARRAY
125770: PPUSH
125771: CALL 98456 0 1
125775: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
125776: LD_VAR 0 4
125780: PUSH
125781: LD_VAR 0 7
125785: ARRAY
125786: PPUSH
125787: LD_VAR 0 10
125791: PPUSH
125792: LD_VAR 0 11
125796: PPUSH
125797: LD_VAR 0 14
125801: PUSH
125802: LD_INT 1
125804: ARRAY
125805: PPUSH
125806: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
125810: LD_VAR 0 4
125814: PUSH
125815: LD_VAR 0 7
125819: ARRAY
125820: PPUSH
125821: LD_VAR 0 10
125825: PPUSH
125826: LD_VAR 0 12
125830: PPUSH
125831: LD_INT 7
125833: PPUSH
125834: CALL_OW 272
125838: PPUSH
125839: LD_VAR 0 11
125843: PPUSH
125844: LD_VAR 0 12
125848: PPUSH
125849: LD_INT 7
125851: PPUSH
125852: CALL_OW 273
125856: PPUSH
125857: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
125861: LD_VAR 0 4
125865: PUSH
125866: LD_VAR 0 7
125870: ARRAY
125871: PPUSH
125872: LD_INT 71
125874: PPUSH
125875: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
125879: LD_ADDR_VAR 0 27
125883: PUSH
125884: LD_VAR 0 27
125888: PPUSH
125889: LD_VAR 0 27
125893: PUSH
125894: LD_INT 1
125896: PLUS
125897: PPUSH
125898: LD_VAR 0 14
125902: PUSH
125903: LD_INT 1
125905: ARRAY
125906: PPUSH
125907: CALL_OW 1
125911: ST_TO_ADDR
// attacking := true ;
125912: LD_ADDR_VAR 0 29
125916: PUSH
125917: LD_INT 1
125919: ST_TO_ADDR
// continue ;
125920: GO 123767
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
125922: LD_VAR 0 4
125926: PUSH
125927: LD_VAR 0 7
125931: ARRAY
125932: PPUSH
125933: CALL_OW 257
125937: PUSH
125938: LD_INT 17
125940: EQUAL
125941: PUSH
125942: LD_VAR 0 4
125946: PUSH
125947: LD_VAR 0 7
125951: ARRAY
125952: PPUSH
125953: CALL_OW 110
125957: PUSH
125958: LD_INT 71
125960: EQUAL
125961: NOT
125962: AND
125963: IFFALSE 126109
// begin attacking := false ;
125965: LD_ADDR_VAR 0 29
125969: PUSH
125970: LD_INT 0
125972: ST_TO_ADDR
// k := 5 ;
125973: LD_ADDR_VAR 0 9
125977: PUSH
125978: LD_INT 5
125980: ST_TO_ADDR
// if tmp < k then
125981: LD_VAR 0 14
125985: PUSH
125986: LD_VAR 0 9
125990: LESS
125991: IFFALSE 126003
// k := tmp ;
125993: LD_ADDR_VAR 0 9
125997: PUSH
125998: LD_VAR 0 14
126002: ST_TO_ADDR
// for j = 1 to k do
126003: LD_ADDR_VAR 0 8
126007: PUSH
126008: DOUBLE
126009: LD_INT 1
126011: DEC
126012: ST_TO_ADDR
126013: LD_VAR 0 9
126017: PUSH
126018: FOR_TO
126019: IFFALSE 126107
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
126021: LD_VAR 0 14
126025: PUSH
126026: LD_VAR 0 8
126030: ARRAY
126031: PUSH
126032: LD_VAR 0 14
126036: PPUSH
126037: LD_INT 58
126039: PUSH
126040: EMPTY
126041: LIST
126042: PPUSH
126043: CALL_OW 72
126047: IN
126048: NOT
126049: IFFALSE 126105
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126051: LD_VAR 0 4
126055: PUSH
126056: LD_VAR 0 7
126060: ARRAY
126061: PPUSH
126062: LD_VAR 0 14
126066: PUSH
126067: LD_VAR 0 8
126071: ARRAY
126072: PPUSH
126073: CALL_OW 115
// attacking := true ;
126077: LD_ADDR_VAR 0 29
126081: PUSH
126082: LD_INT 1
126084: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
126085: LD_VAR 0 4
126089: PUSH
126090: LD_VAR 0 7
126094: ARRAY
126095: PPUSH
126096: LD_INT 71
126098: PPUSH
126099: CALL_OW 109
// continue ;
126103: GO 126018
// end ; end ;
126105: GO 126018
126107: POP
126108: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
126109: LD_VAR 0 4
126113: PUSH
126114: LD_VAR 0 7
126118: ARRAY
126119: PPUSH
126120: CALL_OW 257
126124: PUSH
126125: LD_INT 8
126127: EQUAL
126128: PUSH
126129: LD_VAR 0 4
126133: PUSH
126134: LD_VAR 0 7
126138: ARRAY
126139: PPUSH
126140: CALL_OW 264
126144: PUSH
126145: LD_INT 28
126147: PUSH
126148: LD_INT 45
126150: PUSH
126151: LD_INT 7
126153: PUSH
126154: LD_INT 47
126156: PUSH
126157: EMPTY
126158: LIST
126159: LIST
126160: LIST
126161: LIST
126162: IN
126163: OR
126164: IFFALSE 126420
// begin attacking := false ;
126166: LD_ADDR_VAR 0 29
126170: PUSH
126171: LD_INT 0
126173: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
126174: LD_VAR 0 14
126178: PUSH
126179: LD_INT 1
126181: ARRAY
126182: PPUSH
126183: CALL_OW 266
126187: PUSH
126188: LD_INT 32
126190: PUSH
126191: LD_INT 31
126193: PUSH
126194: LD_INT 33
126196: PUSH
126197: LD_INT 4
126199: PUSH
126200: LD_INT 5
126202: PUSH
126203: EMPTY
126204: LIST
126205: LIST
126206: LIST
126207: LIST
126208: LIST
126209: IN
126210: IFFALSE 126396
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
126212: LD_ADDR_VAR 0 9
126216: PUSH
126217: LD_VAR 0 14
126221: PUSH
126222: LD_INT 1
126224: ARRAY
126225: PPUSH
126226: CALL_OW 266
126230: PPUSH
126231: LD_VAR 0 14
126235: PUSH
126236: LD_INT 1
126238: ARRAY
126239: PPUSH
126240: CALL_OW 250
126244: PPUSH
126245: LD_VAR 0 14
126249: PUSH
126250: LD_INT 1
126252: ARRAY
126253: PPUSH
126254: CALL_OW 251
126258: PPUSH
126259: LD_VAR 0 14
126263: PUSH
126264: LD_INT 1
126266: ARRAY
126267: PPUSH
126268: CALL_OW 254
126272: PPUSH
126273: LD_VAR 0 14
126277: PUSH
126278: LD_INT 1
126280: ARRAY
126281: PPUSH
126282: CALL_OW 248
126286: PPUSH
126287: LD_INT 0
126289: PPUSH
126290: CALL 79826 0 6
126294: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
126295: LD_ADDR_VAR 0 8
126299: PUSH
126300: LD_VAR 0 4
126304: PUSH
126305: LD_VAR 0 7
126309: ARRAY
126310: PPUSH
126311: LD_VAR 0 9
126315: PPUSH
126316: CALL 98496 0 2
126320: ST_TO_ADDR
// if j then
126321: LD_VAR 0 8
126325: IFFALSE 126394
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
126327: LD_VAR 0 8
126331: PUSH
126332: LD_INT 1
126334: ARRAY
126335: PPUSH
126336: LD_VAR 0 8
126340: PUSH
126341: LD_INT 2
126343: ARRAY
126344: PPUSH
126345: CALL_OW 488
126349: IFFALSE 126394
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
126351: LD_VAR 0 4
126355: PUSH
126356: LD_VAR 0 7
126360: ARRAY
126361: PPUSH
126362: LD_VAR 0 8
126366: PUSH
126367: LD_INT 1
126369: ARRAY
126370: PPUSH
126371: LD_VAR 0 8
126375: PUSH
126376: LD_INT 2
126378: ARRAY
126379: PPUSH
126380: CALL_OW 116
// attacking := true ;
126384: LD_ADDR_VAR 0 29
126388: PUSH
126389: LD_INT 1
126391: ST_TO_ADDR
// continue ;
126392: GO 123767
// end ; end else
126394: GO 126420
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126396: LD_VAR 0 4
126400: PUSH
126401: LD_VAR 0 7
126405: ARRAY
126406: PPUSH
126407: LD_VAR 0 14
126411: PUSH
126412: LD_INT 1
126414: ARRAY
126415: PPUSH
126416: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
126420: LD_VAR 0 4
126424: PUSH
126425: LD_VAR 0 7
126429: ARRAY
126430: PPUSH
126431: CALL_OW 265
126435: PUSH
126436: LD_INT 11
126438: EQUAL
126439: IFFALSE 126717
// begin k := 10 ;
126441: LD_ADDR_VAR 0 9
126445: PUSH
126446: LD_INT 10
126448: ST_TO_ADDR
// x := 0 ;
126449: LD_ADDR_VAR 0 10
126453: PUSH
126454: LD_INT 0
126456: ST_TO_ADDR
// if tmp < k then
126457: LD_VAR 0 14
126461: PUSH
126462: LD_VAR 0 9
126466: LESS
126467: IFFALSE 126479
// k := tmp ;
126469: LD_ADDR_VAR 0 9
126473: PUSH
126474: LD_VAR 0 14
126478: ST_TO_ADDR
// for j = k downto 1 do
126479: LD_ADDR_VAR 0 8
126483: PUSH
126484: DOUBLE
126485: LD_VAR 0 9
126489: INC
126490: ST_TO_ADDR
126491: LD_INT 1
126493: PUSH
126494: FOR_DOWNTO
126495: IFFALSE 126570
// begin if GetType ( tmp [ j ] ) = unit_human then
126497: LD_VAR 0 14
126501: PUSH
126502: LD_VAR 0 8
126506: ARRAY
126507: PPUSH
126508: CALL_OW 247
126512: PUSH
126513: LD_INT 1
126515: EQUAL
126516: IFFALSE 126568
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
126518: LD_VAR 0 4
126522: PUSH
126523: LD_VAR 0 7
126527: ARRAY
126528: PPUSH
126529: LD_VAR 0 14
126533: PUSH
126534: LD_VAR 0 8
126538: ARRAY
126539: PPUSH
126540: CALL 98767 0 2
// x := tmp [ j ] ;
126544: LD_ADDR_VAR 0 10
126548: PUSH
126549: LD_VAR 0 14
126553: PUSH
126554: LD_VAR 0 8
126558: ARRAY
126559: ST_TO_ADDR
// attacking := true ;
126560: LD_ADDR_VAR 0 29
126564: PUSH
126565: LD_INT 1
126567: ST_TO_ADDR
// end ; end ;
126568: GO 126494
126570: POP
126571: POP
// if not x then
126572: LD_VAR 0 10
126576: NOT
126577: IFFALSE 126717
// begin attacking := true ;
126579: LD_ADDR_VAR 0 29
126583: PUSH
126584: LD_INT 1
126586: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
126587: LD_VAR 0 4
126591: PUSH
126592: LD_VAR 0 7
126596: ARRAY
126597: PPUSH
126598: CALL_OW 250
126602: PPUSH
126603: LD_VAR 0 4
126607: PUSH
126608: LD_VAR 0 7
126612: ARRAY
126613: PPUSH
126614: CALL_OW 251
126618: PPUSH
126619: CALL_OW 546
126623: PUSH
126624: LD_INT 2
126626: ARRAY
126627: PUSH
126628: LD_VAR 0 14
126632: PUSH
126633: LD_INT 1
126635: ARRAY
126636: PPUSH
126637: CALL_OW 250
126641: PPUSH
126642: LD_VAR 0 14
126646: PUSH
126647: LD_INT 1
126649: ARRAY
126650: PPUSH
126651: CALL_OW 251
126655: PPUSH
126656: CALL_OW 546
126660: PUSH
126661: LD_INT 2
126663: ARRAY
126664: EQUAL
126665: IFFALSE 126693
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
126667: LD_VAR 0 4
126671: PUSH
126672: LD_VAR 0 7
126676: ARRAY
126677: PPUSH
126678: LD_VAR 0 14
126682: PUSH
126683: LD_INT 1
126685: ARRAY
126686: PPUSH
126687: CALL 98767 0 2
126691: GO 126717
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126693: LD_VAR 0 4
126697: PUSH
126698: LD_VAR 0 7
126702: ARRAY
126703: PPUSH
126704: LD_VAR 0 14
126708: PUSH
126709: LD_INT 1
126711: ARRAY
126712: PPUSH
126713: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
126717: LD_VAR 0 4
126721: PUSH
126722: LD_VAR 0 7
126726: ARRAY
126727: PPUSH
126728: CALL_OW 264
126732: PUSH
126733: LD_INT 29
126735: EQUAL
126736: IFFALSE 127102
// begin if WantsToAttack ( group [ i ] ) in bombed then
126738: LD_VAR 0 4
126742: PUSH
126743: LD_VAR 0 7
126747: ARRAY
126748: PPUSH
126749: CALL_OW 319
126753: PUSH
126754: LD_VAR 0 28
126758: IN
126759: IFFALSE 126763
// continue ;
126761: GO 123767
// k := 8 ;
126763: LD_ADDR_VAR 0 9
126767: PUSH
126768: LD_INT 8
126770: ST_TO_ADDR
// x := 0 ;
126771: LD_ADDR_VAR 0 10
126775: PUSH
126776: LD_INT 0
126778: ST_TO_ADDR
// if tmp < k then
126779: LD_VAR 0 14
126783: PUSH
126784: LD_VAR 0 9
126788: LESS
126789: IFFALSE 126801
// k := tmp ;
126791: LD_ADDR_VAR 0 9
126795: PUSH
126796: LD_VAR 0 14
126800: ST_TO_ADDR
// for j = 1 to k do
126801: LD_ADDR_VAR 0 8
126805: PUSH
126806: DOUBLE
126807: LD_INT 1
126809: DEC
126810: ST_TO_ADDR
126811: LD_VAR 0 9
126815: PUSH
126816: FOR_TO
126817: IFFALSE 126949
// begin if GetType ( tmp [ j ] ) = unit_building then
126819: LD_VAR 0 14
126823: PUSH
126824: LD_VAR 0 8
126828: ARRAY
126829: PPUSH
126830: CALL_OW 247
126834: PUSH
126835: LD_INT 3
126837: EQUAL
126838: IFFALSE 126947
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
126840: LD_VAR 0 14
126844: PUSH
126845: LD_VAR 0 8
126849: ARRAY
126850: PUSH
126851: LD_VAR 0 28
126855: IN
126856: NOT
126857: PUSH
126858: LD_VAR 0 14
126862: PUSH
126863: LD_VAR 0 8
126867: ARRAY
126868: PPUSH
126869: CALL_OW 313
126873: AND
126874: IFFALSE 126947
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126876: LD_VAR 0 4
126880: PUSH
126881: LD_VAR 0 7
126885: ARRAY
126886: PPUSH
126887: LD_VAR 0 14
126891: PUSH
126892: LD_VAR 0 8
126896: ARRAY
126897: PPUSH
126898: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
126902: LD_ADDR_VAR 0 28
126906: PUSH
126907: LD_VAR 0 28
126911: PPUSH
126912: LD_VAR 0 28
126916: PUSH
126917: LD_INT 1
126919: PLUS
126920: PPUSH
126921: LD_VAR 0 14
126925: PUSH
126926: LD_VAR 0 8
126930: ARRAY
126931: PPUSH
126932: CALL_OW 1
126936: ST_TO_ADDR
// attacking := true ;
126937: LD_ADDR_VAR 0 29
126941: PUSH
126942: LD_INT 1
126944: ST_TO_ADDR
// break ;
126945: GO 126949
// end ; end ;
126947: GO 126816
126949: POP
126950: POP
// if not attacking and f_attack_depot then
126951: LD_VAR 0 29
126955: NOT
126956: PUSH
126957: LD_VAR 0 25
126961: AND
126962: IFFALSE 127057
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126964: LD_ADDR_VAR 0 13
126968: PUSH
126969: LD_VAR 0 14
126973: PPUSH
126974: LD_INT 2
126976: PUSH
126977: LD_INT 30
126979: PUSH
126980: LD_INT 0
126982: PUSH
126983: EMPTY
126984: LIST
126985: LIST
126986: PUSH
126987: LD_INT 30
126989: PUSH
126990: LD_INT 1
126992: PUSH
126993: EMPTY
126994: LIST
126995: LIST
126996: PUSH
126997: EMPTY
126998: LIST
126999: LIST
127000: LIST
127001: PPUSH
127002: CALL_OW 72
127006: ST_TO_ADDR
// if z then
127007: LD_VAR 0 13
127011: IFFALSE 127057
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
127013: LD_VAR 0 4
127017: PUSH
127018: LD_VAR 0 7
127022: ARRAY
127023: PPUSH
127024: LD_VAR 0 13
127028: PPUSH
127029: LD_VAR 0 4
127033: PUSH
127034: LD_VAR 0 7
127038: ARRAY
127039: PPUSH
127040: CALL_OW 74
127044: PPUSH
127045: CALL_OW 115
// attacking := true ;
127049: LD_ADDR_VAR 0 29
127053: PUSH
127054: LD_INT 1
127056: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
127057: LD_VAR 0 4
127061: PUSH
127062: LD_VAR 0 7
127066: ARRAY
127067: PPUSH
127068: CALL_OW 256
127072: PUSH
127073: LD_INT 500
127075: LESS
127076: IFFALSE 127102
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127078: LD_VAR 0 4
127082: PUSH
127083: LD_VAR 0 7
127087: ARRAY
127088: PPUSH
127089: LD_VAR 0 14
127093: PUSH
127094: LD_INT 1
127096: ARRAY
127097: PPUSH
127098: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
127102: LD_VAR 0 4
127106: PUSH
127107: LD_VAR 0 7
127111: ARRAY
127112: PPUSH
127113: CALL_OW 264
127117: PUSH
127118: LD_INT 49
127120: EQUAL
127121: IFFALSE 127242
// begin if not HasTask ( group [ i ] ) then
127123: LD_VAR 0 4
127127: PUSH
127128: LD_VAR 0 7
127132: ARRAY
127133: PPUSH
127134: CALL_OW 314
127138: NOT
127139: IFFALSE 127242
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
127141: LD_ADDR_VAR 0 9
127145: PUSH
127146: LD_INT 81
127148: PUSH
127149: LD_VAR 0 4
127153: PUSH
127154: LD_VAR 0 7
127158: ARRAY
127159: PPUSH
127160: CALL_OW 255
127164: PUSH
127165: EMPTY
127166: LIST
127167: LIST
127168: PPUSH
127169: CALL_OW 69
127173: PPUSH
127174: LD_VAR 0 4
127178: PUSH
127179: LD_VAR 0 7
127183: ARRAY
127184: PPUSH
127185: CALL_OW 74
127189: ST_TO_ADDR
// if k then
127190: LD_VAR 0 9
127194: IFFALSE 127242
// if GetDistUnits ( group [ i ] , k ) > 10 then
127196: LD_VAR 0 4
127200: PUSH
127201: LD_VAR 0 7
127205: ARRAY
127206: PPUSH
127207: LD_VAR 0 9
127211: PPUSH
127212: CALL_OW 296
127216: PUSH
127217: LD_INT 10
127219: GREATER
127220: IFFALSE 127242
// ComMoveUnit ( group [ i ] , k ) ;
127222: LD_VAR 0 4
127226: PUSH
127227: LD_VAR 0 7
127231: ARRAY
127232: PPUSH
127233: LD_VAR 0 9
127237: PPUSH
127238: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
127242: LD_VAR 0 4
127246: PUSH
127247: LD_VAR 0 7
127251: ARRAY
127252: PPUSH
127253: CALL_OW 256
127257: PUSH
127258: LD_INT 250
127260: LESS
127261: PUSH
127262: LD_VAR 0 4
127266: PUSH
127267: LD_VAR 0 7
127271: ARRAY
127272: PUSH
127273: LD_INT 21
127275: PUSH
127276: LD_INT 2
127278: PUSH
127279: EMPTY
127280: LIST
127281: LIST
127282: PUSH
127283: LD_INT 23
127285: PUSH
127286: LD_INT 2
127288: PUSH
127289: EMPTY
127290: LIST
127291: LIST
127292: PUSH
127293: EMPTY
127294: LIST
127295: LIST
127296: PPUSH
127297: CALL_OW 69
127301: IN
127302: AND
127303: IFFALSE 127428
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
127305: LD_ADDR_VAR 0 9
127309: PUSH
127310: LD_OWVAR 3
127314: PUSH
127315: LD_VAR 0 4
127319: PUSH
127320: LD_VAR 0 7
127324: ARRAY
127325: DIFF
127326: PPUSH
127327: LD_VAR 0 4
127331: PUSH
127332: LD_VAR 0 7
127336: ARRAY
127337: PPUSH
127338: CALL_OW 74
127342: ST_TO_ADDR
// if not k then
127343: LD_VAR 0 9
127347: NOT
127348: IFFALSE 127352
// continue ;
127350: GO 123767
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
127352: LD_VAR 0 9
127356: PUSH
127357: LD_INT 81
127359: PUSH
127360: LD_VAR 0 4
127364: PUSH
127365: LD_VAR 0 7
127369: ARRAY
127370: PPUSH
127371: CALL_OW 255
127375: PUSH
127376: EMPTY
127377: LIST
127378: LIST
127379: PPUSH
127380: CALL_OW 69
127384: IN
127385: PUSH
127386: LD_VAR 0 9
127390: PPUSH
127391: LD_VAR 0 4
127395: PUSH
127396: LD_VAR 0 7
127400: ARRAY
127401: PPUSH
127402: CALL_OW 296
127406: PUSH
127407: LD_INT 5
127409: LESS
127410: AND
127411: IFFALSE 127428
// ComAutodestruct ( group [ i ] ) ;
127413: LD_VAR 0 4
127417: PUSH
127418: LD_VAR 0 7
127422: ARRAY
127423: PPUSH
127424: CALL 98665 0 1
// end ; if f_attack_depot then
127428: LD_VAR 0 25
127432: IFFALSE 127544
// begin k := 6 ;
127434: LD_ADDR_VAR 0 9
127438: PUSH
127439: LD_INT 6
127441: ST_TO_ADDR
// if tmp < k then
127442: LD_VAR 0 14
127446: PUSH
127447: LD_VAR 0 9
127451: LESS
127452: IFFALSE 127464
// k := tmp ;
127454: LD_ADDR_VAR 0 9
127458: PUSH
127459: LD_VAR 0 14
127463: ST_TO_ADDR
// for j = 1 to k do
127464: LD_ADDR_VAR 0 8
127468: PUSH
127469: DOUBLE
127470: LD_INT 1
127472: DEC
127473: ST_TO_ADDR
127474: LD_VAR 0 9
127478: PUSH
127479: FOR_TO
127480: IFFALSE 127542
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
127482: LD_VAR 0 8
127486: PPUSH
127487: CALL_OW 266
127491: PUSH
127492: LD_INT 0
127494: PUSH
127495: LD_INT 1
127497: PUSH
127498: EMPTY
127499: LIST
127500: LIST
127501: IN
127502: IFFALSE 127540
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
127504: LD_VAR 0 4
127508: PUSH
127509: LD_VAR 0 7
127513: ARRAY
127514: PPUSH
127515: LD_VAR 0 14
127519: PUSH
127520: LD_VAR 0 8
127524: ARRAY
127525: PPUSH
127526: CALL_OW 115
// attacking := true ;
127530: LD_ADDR_VAR 0 29
127534: PUSH
127535: LD_INT 1
127537: ST_TO_ADDR
// break ;
127538: GO 127542
// end ;
127540: GO 127479
127542: POP
127543: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
127544: LD_VAR 0 4
127548: PUSH
127549: LD_VAR 0 7
127553: ARRAY
127554: PPUSH
127555: CALL_OW 302
127559: PUSH
127560: LD_VAR 0 29
127564: NOT
127565: AND
127566: IFFALSE 127888
// begin if GetTag ( group [ i ] ) = 71 then
127568: LD_VAR 0 4
127572: PUSH
127573: LD_VAR 0 7
127577: ARRAY
127578: PPUSH
127579: CALL_OW 110
127583: PUSH
127584: LD_INT 71
127586: EQUAL
127587: IFFALSE 127628
// begin if HasTask ( group [ i ] ) then
127589: LD_VAR 0 4
127593: PUSH
127594: LD_VAR 0 7
127598: ARRAY
127599: PPUSH
127600: CALL_OW 314
127604: IFFALSE 127610
// continue else
127606: GO 123767
127608: GO 127628
// SetTag ( group [ i ] , 0 ) ;
127610: LD_VAR 0 4
127614: PUSH
127615: LD_VAR 0 7
127619: ARRAY
127620: PPUSH
127621: LD_INT 0
127623: PPUSH
127624: CALL_OW 109
// end ; k := 8 ;
127628: LD_ADDR_VAR 0 9
127632: PUSH
127633: LD_INT 8
127635: ST_TO_ADDR
// x := 0 ;
127636: LD_ADDR_VAR 0 10
127640: PUSH
127641: LD_INT 0
127643: ST_TO_ADDR
// if tmp < k then
127644: LD_VAR 0 14
127648: PUSH
127649: LD_VAR 0 9
127653: LESS
127654: IFFALSE 127666
// k := tmp ;
127656: LD_ADDR_VAR 0 9
127660: PUSH
127661: LD_VAR 0 14
127665: ST_TO_ADDR
// for j = 1 to k do
127666: LD_ADDR_VAR 0 8
127670: PUSH
127671: DOUBLE
127672: LD_INT 1
127674: DEC
127675: ST_TO_ADDR
127676: LD_VAR 0 9
127680: PUSH
127681: FOR_TO
127682: IFFALSE 127780
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
127684: LD_VAR 0 14
127688: PUSH
127689: LD_VAR 0 8
127693: ARRAY
127694: PPUSH
127695: CALL_OW 247
127699: PUSH
127700: LD_INT 1
127702: EQUAL
127703: PUSH
127704: LD_VAR 0 14
127708: PUSH
127709: LD_VAR 0 8
127713: ARRAY
127714: PPUSH
127715: CALL_OW 256
127719: PUSH
127720: LD_INT 250
127722: LESS
127723: PUSH
127724: LD_VAR 0 20
127728: AND
127729: PUSH
127730: LD_VAR 0 20
127734: NOT
127735: PUSH
127736: LD_VAR 0 14
127740: PUSH
127741: LD_VAR 0 8
127745: ARRAY
127746: PPUSH
127747: CALL_OW 256
127751: PUSH
127752: LD_INT 250
127754: GREATEREQUAL
127755: AND
127756: OR
127757: AND
127758: IFFALSE 127778
// begin x := tmp [ j ] ;
127760: LD_ADDR_VAR 0 10
127764: PUSH
127765: LD_VAR 0 14
127769: PUSH
127770: LD_VAR 0 8
127774: ARRAY
127775: ST_TO_ADDR
// break ;
127776: GO 127780
// end ;
127778: GO 127681
127780: POP
127781: POP
// if x then
127782: LD_VAR 0 10
127786: IFFALSE 127810
// ComAttackUnit ( group [ i ] , x ) else
127788: LD_VAR 0 4
127792: PUSH
127793: LD_VAR 0 7
127797: ARRAY
127798: PPUSH
127799: LD_VAR 0 10
127803: PPUSH
127804: CALL_OW 115
127808: GO 127834
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127810: LD_VAR 0 4
127814: PUSH
127815: LD_VAR 0 7
127819: ARRAY
127820: PPUSH
127821: LD_VAR 0 14
127825: PUSH
127826: LD_INT 1
127828: ARRAY
127829: PPUSH
127830: CALL_OW 115
// if not HasTask ( group [ i ] ) then
127834: LD_VAR 0 4
127838: PUSH
127839: LD_VAR 0 7
127843: ARRAY
127844: PPUSH
127845: CALL_OW 314
127849: NOT
127850: IFFALSE 127888
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
127852: LD_VAR 0 4
127856: PUSH
127857: LD_VAR 0 7
127861: ARRAY
127862: PPUSH
127863: LD_VAR 0 14
127867: PPUSH
127868: LD_VAR 0 4
127872: PUSH
127873: LD_VAR 0 7
127877: ARRAY
127878: PPUSH
127879: CALL_OW 74
127883: PPUSH
127884: CALL_OW 115
// end ; end ; end ;
127888: GO 123767
127890: POP
127891: POP
// wait ( 0 0$2 ) ;
127892: LD_INT 70
127894: PPUSH
127895: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
127899: LD_VAR 0 4
127903: NOT
127904: PUSH
127905: LD_VAR 0 4
127909: PUSH
127910: EMPTY
127911: EQUAL
127912: OR
127913: PUSH
127914: LD_INT 81
127916: PUSH
127917: LD_VAR 0 35
127921: PUSH
127922: EMPTY
127923: LIST
127924: LIST
127925: PPUSH
127926: CALL_OW 69
127930: NOT
127931: OR
127932: IFFALSE 123752
// end ;
127934: LD_VAR 0 2
127938: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
127939: LD_INT 0
127941: PPUSH
127942: PPUSH
127943: PPUSH
127944: PPUSH
127945: PPUSH
127946: PPUSH
// if not base or not mc_bases [ base ] or not solds then
127947: LD_VAR 0 1
127951: NOT
127952: PUSH
127953: LD_EXP 116
127957: PUSH
127958: LD_VAR 0 1
127962: ARRAY
127963: NOT
127964: OR
127965: PUSH
127966: LD_VAR 0 2
127970: NOT
127971: OR
127972: IFFALSE 127976
// exit ;
127974: GO 128530
// side := mc_sides [ base ] ;
127976: LD_ADDR_VAR 0 6
127980: PUSH
127981: LD_EXP 142
127985: PUSH
127986: LD_VAR 0 1
127990: ARRAY
127991: ST_TO_ADDR
// if not side then
127992: LD_VAR 0 6
127996: NOT
127997: IFFALSE 128001
// exit ;
127999: GO 128530
// for i in solds do
128001: LD_ADDR_VAR 0 7
128005: PUSH
128006: LD_VAR 0 2
128010: PUSH
128011: FOR_IN
128012: IFFALSE 128073
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
128014: LD_VAR 0 7
128018: PPUSH
128019: CALL_OW 310
128023: PPUSH
128024: CALL_OW 266
128028: PUSH
128029: LD_INT 32
128031: PUSH
128032: LD_INT 31
128034: PUSH
128035: EMPTY
128036: LIST
128037: LIST
128038: IN
128039: IFFALSE 128059
// solds := solds diff i else
128041: LD_ADDR_VAR 0 2
128045: PUSH
128046: LD_VAR 0 2
128050: PUSH
128051: LD_VAR 0 7
128055: DIFF
128056: ST_TO_ADDR
128057: GO 128071
// SetTag ( i , 18 ) ;
128059: LD_VAR 0 7
128063: PPUSH
128064: LD_INT 18
128066: PPUSH
128067: CALL_OW 109
128071: GO 128011
128073: POP
128074: POP
// if not solds then
128075: LD_VAR 0 2
128079: NOT
128080: IFFALSE 128084
// exit ;
128082: GO 128530
// repeat wait ( 0 0$2 ) ;
128084: LD_INT 70
128086: PPUSH
128087: CALL_OW 67
// enemy := mc_scan [ base ] ;
128091: LD_ADDR_VAR 0 4
128095: PUSH
128096: LD_EXP 139
128100: PUSH
128101: LD_VAR 0 1
128105: ARRAY
128106: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128107: LD_EXP 116
128111: PUSH
128112: LD_VAR 0 1
128116: ARRAY
128117: NOT
128118: PUSH
128119: LD_EXP 116
128123: PUSH
128124: LD_VAR 0 1
128128: ARRAY
128129: PUSH
128130: EMPTY
128131: EQUAL
128132: OR
128133: IFFALSE 128170
// begin for i in solds do
128135: LD_ADDR_VAR 0 7
128139: PUSH
128140: LD_VAR 0 2
128144: PUSH
128145: FOR_IN
128146: IFFALSE 128159
// ComStop ( i ) ;
128148: LD_VAR 0 7
128152: PPUSH
128153: CALL_OW 141
128157: GO 128145
128159: POP
128160: POP
// solds := [ ] ;
128161: LD_ADDR_VAR 0 2
128165: PUSH
128166: EMPTY
128167: ST_TO_ADDR
// exit ;
128168: GO 128530
// end ; for i in solds do
128170: LD_ADDR_VAR 0 7
128174: PUSH
128175: LD_VAR 0 2
128179: PUSH
128180: FOR_IN
128181: IFFALSE 128502
// begin if IsInUnit ( i ) then
128183: LD_VAR 0 7
128187: PPUSH
128188: CALL_OW 310
128192: IFFALSE 128203
// ComExitBuilding ( i ) ;
128194: LD_VAR 0 7
128198: PPUSH
128199: CALL_OW 122
// if GetLives ( i ) > 500 then
128203: LD_VAR 0 7
128207: PPUSH
128208: CALL_OW 256
128212: PUSH
128213: LD_INT 500
128215: GREATER
128216: IFFALSE 128269
// begin e := NearestUnitToUnit ( enemy , i ) ;
128218: LD_ADDR_VAR 0 5
128222: PUSH
128223: LD_VAR 0 4
128227: PPUSH
128228: LD_VAR 0 7
128232: PPUSH
128233: CALL_OW 74
128237: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
128238: LD_VAR 0 7
128242: PPUSH
128243: LD_VAR 0 5
128247: PPUSH
128248: CALL_OW 250
128252: PPUSH
128253: LD_VAR 0 5
128257: PPUSH
128258: CALL_OW 251
128262: PPUSH
128263: CALL_OW 114
// end else
128267: GO 128500
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
128269: LD_VAR 0 7
128273: PPUSH
128274: LD_EXP 116
128278: PUSH
128279: LD_VAR 0 1
128283: ARRAY
128284: PPUSH
128285: LD_INT 2
128287: PUSH
128288: LD_INT 30
128290: PUSH
128291: LD_INT 0
128293: PUSH
128294: EMPTY
128295: LIST
128296: LIST
128297: PUSH
128298: LD_INT 30
128300: PUSH
128301: LD_INT 1
128303: PUSH
128304: EMPTY
128305: LIST
128306: LIST
128307: PUSH
128308: LD_INT 30
128310: PUSH
128311: LD_INT 6
128313: PUSH
128314: EMPTY
128315: LIST
128316: LIST
128317: PUSH
128318: EMPTY
128319: LIST
128320: LIST
128321: LIST
128322: LIST
128323: PPUSH
128324: CALL_OW 72
128328: PPUSH
128329: LD_VAR 0 7
128333: PPUSH
128334: CALL_OW 74
128338: PPUSH
128339: CALL_OW 296
128343: PUSH
128344: LD_INT 10
128346: GREATER
128347: IFFALSE 128500
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
128349: LD_ADDR_VAR 0 8
128353: PUSH
128354: LD_EXP 116
128358: PUSH
128359: LD_VAR 0 1
128363: ARRAY
128364: PPUSH
128365: LD_INT 2
128367: PUSH
128368: LD_INT 30
128370: PUSH
128371: LD_INT 0
128373: PUSH
128374: EMPTY
128375: LIST
128376: LIST
128377: PUSH
128378: LD_INT 30
128380: PUSH
128381: LD_INT 1
128383: PUSH
128384: EMPTY
128385: LIST
128386: LIST
128387: PUSH
128388: LD_INT 30
128390: PUSH
128391: LD_INT 6
128393: PUSH
128394: EMPTY
128395: LIST
128396: LIST
128397: PUSH
128398: EMPTY
128399: LIST
128400: LIST
128401: LIST
128402: LIST
128403: PPUSH
128404: CALL_OW 72
128408: PPUSH
128409: LD_VAR 0 7
128413: PPUSH
128414: CALL_OW 74
128418: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
128419: LD_VAR 0 7
128423: PPUSH
128424: LD_VAR 0 8
128428: PPUSH
128429: CALL_OW 250
128433: PPUSH
128434: LD_INT 3
128436: PPUSH
128437: LD_INT 5
128439: PPUSH
128440: CALL_OW 272
128444: PPUSH
128445: LD_VAR 0 8
128449: PPUSH
128450: CALL_OW 251
128454: PPUSH
128455: LD_INT 3
128457: PPUSH
128458: LD_INT 5
128460: PPUSH
128461: CALL_OW 273
128465: PPUSH
128466: CALL_OW 111
// SetTag ( i , 0 ) ;
128470: LD_VAR 0 7
128474: PPUSH
128475: LD_INT 0
128477: PPUSH
128478: CALL_OW 109
// solds := solds diff i ;
128482: LD_ADDR_VAR 0 2
128486: PUSH
128487: LD_VAR 0 2
128491: PUSH
128492: LD_VAR 0 7
128496: DIFF
128497: ST_TO_ADDR
// continue ;
128498: GO 128180
// end ; end ;
128500: GO 128180
128502: POP
128503: POP
// until not solds or not enemy ;
128504: LD_VAR 0 2
128508: NOT
128509: PUSH
128510: LD_VAR 0 4
128514: NOT
128515: OR
128516: IFFALSE 128084
// MC_Reset ( base , 18 ) ;
128518: LD_VAR 0 1
128522: PPUSH
128523: LD_INT 18
128525: PPUSH
128526: CALL 39413 0 2
// end ;
128530: LD_VAR 0 3
128534: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
128535: LD_INT 0
128537: PPUSH
128538: PPUSH
128539: PPUSH
128540: PPUSH
128541: PPUSH
128542: PPUSH
128543: PPUSH
128544: PPUSH
128545: PPUSH
128546: PPUSH
128547: PPUSH
128548: PPUSH
128549: PPUSH
128550: PPUSH
128551: PPUSH
128552: PPUSH
128553: PPUSH
128554: PPUSH
128555: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
128556: LD_ADDR_VAR 0 12
128560: PUSH
128561: LD_EXP 116
128565: PUSH
128566: LD_VAR 0 1
128570: ARRAY
128571: PPUSH
128572: LD_INT 25
128574: PUSH
128575: LD_INT 3
128577: PUSH
128578: EMPTY
128579: LIST
128580: LIST
128581: PPUSH
128582: CALL_OW 72
128586: ST_TO_ADDR
// if mc_remote_driver [ base ] then
128587: LD_EXP 156
128591: PUSH
128592: LD_VAR 0 1
128596: ARRAY
128597: IFFALSE 128621
// mechs := mechs diff mc_remote_driver [ base ] ;
128599: LD_ADDR_VAR 0 12
128603: PUSH
128604: LD_VAR 0 12
128608: PUSH
128609: LD_EXP 156
128613: PUSH
128614: LD_VAR 0 1
128618: ARRAY
128619: DIFF
128620: ST_TO_ADDR
// for i in mechs do
128621: LD_ADDR_VAR 0 4
128625: PUSH
128626: LD_VAR 0 12
128630: PUSH
128631: FOR_IN
128632: IFFALSE 128667
// if GetTag ( i ) > 0 then
128634: LD_VAR 0 4
128638: PPUSH
128639: CALL_OW 110
128643: PUSH
128644: LD_INT 0
128646: GREATER
128647: IFFALSE 128665
// mechs := mechs diff i ;
128649: LD_ADDR_VAR 0 12
128653: PUSH
128654: LD_VAR 0 12
128658: PUSH
128659: LD_VAR 0 4
128663: DIFF
128664: ST_TO_ADDR
128665: GO 128631
128667: POP
128668: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
128669: LD_ADDR_VAR 0 8
128673: PUSH
128674: LD_EXP 116
128678: PUSH
128679: LD_VAR 0 1
128683: ARRAY
128684: PPUSH
128685: LD_INT 2
128687: PUSH
128688: LD_INT 25
128690: PUSH
128691: LD_INT 1
128693: PUSH
128694: EMPTY
128695: LIST
128696: LIST
128697: PUSH
128698: LD_INT 25
128700: PUSH
128701: LD_INT 5
128703: PUSH
128704: EMPTY
128705: LIST
128706: LIST
128707: PUSH
128708: LD_INT 25
128710: PUSH
128711: LD_INT 8
128713: PUSH
128714: EMPTY
128715: LIST
128716: LIST
128717: PUSH
128718: LD_INT 25
128720: PUSH
128721: LD_INT 9
128723: PUSH
128724: EMPTY
128725: LIST
128726: LIST
128727: PUSH
128728: EMPTY
128729: LIST
128730: LIST
128731: LIST
128732: LIST
128733: LIST
128734: PPUSH
128735: CALL_OW 72
128739: ST_TO_ADDR
// if not defenders and not solds then
128740: LD_VAR 0 2
128744: NOT
128745: PUSH
128746: LD_VAR 0 8
128750: NOT
128751: AND
128752: IFFALSE 128756
// exit ;
128754: GO 130526
// depot_under_attack := false ;
128756: LD_ADDR_VAR 0 16
128760: PUSH
128761: LD_INT 0
128763: ST_TO_ADDR
// sold_defenders := [ ] ;
128764: LD_ADDR_VAR 0 17
128768: PUSH
128769: EMPTY
128770: ST_TO_ADDR
// if mechs then
128771: LD_VAR 0 12
128775: IFFALSE 128928
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
128777: LD_ADDR_VAR 0 4
128781: PUSH
128782: LD_VAR 0 2
128786: PPUSH
128787: LD_INT 21
128789: PUSH
128790: LD_INT 2
128792: PUSH
128793: EMPTY
128794: LIST
128795: LIST
128796: PPUSH
128797: CALL_OW 72
128801: PUSH
128802: FOR_IN
128803: IFFALSE 128926
// begin if GetTag ( i ) <> 20 then
128805: LD_VAR 0 4
128809: PPUSH
128810: CALL_OW 110
128814: PUSH
128815: LD_INT 20
128817: NONEQUAL
128818: IFFALSE 128832
// SetTag ( i , 20 ) ;
128820: LD_VAR 0 4
128824: PPUSH
128825: LD_INT 20
128827: PPUSH
128828: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
128832: LD_VAR 0 4
128836: PPUSH
128837: CALL_OW 263
128841: PUSH
128842: LD_INT 1
128844: EQUAL
128845: PUSH
128846: LD_VAR 0 4
128850: PPUSH
128851: CALL_OW 311
128855: NOT
128856: AND
128857: IFFALSE 128924
// begin un := mechs [ 1 ] ;
128859: LD_ADDR_VAR 0 10
128863: PUSH
128864: LD_VAR 0 12
128868: PUSH
128869: LD_INT 1
128871: ARRAY
128872: ST_TO_ADDR
// ComExit ( un ) ;
128873: LD_VAR 0 10
128877: PPUSH
128878: CALL 103010 0 1
// AddComEnterUnit ( un , i ) ;
128882: LD_VAR 0 10
128886: PPUSH
128887: LD_VAR 0 4
128891: PPUSH
128892: CALL_OW 180
// SetTag ( un , 19 ) ;
128896: LD_VAR 0 10
128900: PPUSH
128901: LD_INT 19
128903: PPUSH
128904: CALL_OW 109
// mechs := mechs diff un ;
128908: LD_ADDR_VAR 0 12
128912: PUSH
128913: LD_VAR 0 12
128917: PUSH
128918: LD_VAR 0 10
128922: DIFF
128923: ST_TO_ADDR
// end ; end ;
128924: GO 128802
128926: POP
128927: POP
// if solds then
128928: LD_VAR 0 8
128932: IFFALSE 128991
// for i in solds do
128934: LD_ADDR_VAR 0 4
128938: PUSH
128939: LD_VAR 0 8
128943: PUSH
128944: FOR_IN
128945: IFFALSE 128989
// if not GetTag ( i ) then
128947: LD_VAR 0 4
128951: PPUSH
128952: CALL_OW 110
128956: NOT
128957: IFFALSE 128987
// begin defenders := defenders union i ;
128959: LD_ADDR_VAR 0 2
128963: PUSH
128964: LD_VAR 0 2
128968: PUSH
128969: LD_VAR 0 4
128973: UNION
128974: ST_TO_ADDR
// SetTag ( i , 18 ) ;
128975: LD_VAR 0 4
128979: PPUSH
128980: LD_INT 18
128982: PPUSH
128983: CALL_OW 109
// end ;
128987: GO 128944
128989: POP
128990: POP
// repeat wait ( 0 0$2 ) ;
128991: LD_INT 70
128993: PPUSH
128994: CALL_OW 67
// enemy := mc_scan [ base ] ;
128998: LD_ADDR_VAR 0 21
129002: PUSH
129003: LD_EXP 139
129007: PUSH
129008: LD_VAR 0 1
129012: ARRAY
129013: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
129014: LD_EXP 116
129018: PUSH
129019: LD_VAR 0 1
129023: ARRAY
129024: NOT
129025: PUSH
129026: LD_EXP 116
129030: PUSH
129031: LD_VAR 0 1
129035: ARRAY
129036: PUSH
129037: EMPTY
129038: EQUAL
129039: OR
129040: IFFALSE 129077
// begin for i in defenders do
129042: LD_ADDR_VAR 0 4
129046: PUSH
129047: LD_VAR 0 2
129051: PUSH
129052: FOR_IN
129053: IFFALSE 129066
// ComStop ( i ) ;
129055: LD_VAR 0 4
129059: PPUSH
129060: CALL_OW 141
129064: GO 129052
129066: POP
129067: POP
// defenders := [ ] ;
129068: LD_ADDR_VAR 0 2
129072: PUSH
129073: EMPTY
129074: ST_TO_ADDR
// exit ;
129075: GO 130526
// end ; for i in defenders do
129077: LD_ADDR_VAR 0 4
129081: PUSH
129082: LD_VAR 0 2
129086: PUSH
129087: FOR_IN
129088: IFFALSE 129986
// begin e := NearestUnitToUnit ( enemy , i ) ;
129090: LD_ADDR_VAR 0 13
129094: PUSH
129095: LD_VAR 0 21
129099: PPUSH
129100: LD_VAR 0 4
129104: PPUSH
129105: CALL_OW 74
129109: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
129110: LD_ADDR_VAR 0 7
129114: PUSH
129115: LD_EXP 116
129119: PUSH
129120: LD_VAR 0 1
129124: ARRAY
129125: PPUSH
129126: LD_INT 2
129128: PUSH
129129: LD_INT 30
129131: PUSH
129132: LD_INT 0
129134: PUSH
129135: EMPTY
129136: LIST
129137: LIST
129138: PUSH
129139: LD_INT 30
129141: PUSH
129142: LD_INT 1
129144: PUSH
129145: EMPTY
129146: LIST
129147: LIST
129148: PUSH
129149: EMPTY
129150: LIST
129151: LIST
129152: LIST
129153: PPUSH
129154: CALL_OW 72
129158: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
129159: LD_ADDR_VAR 0 16
129163: PUSH
129164: LD_VAR 0 7
129168: NOT
129169: PUSH
129170: LD_VAR 0 7
129174: PPUSH
129175: LD_INT 3
129177: PUSH
129178: LD_INT 24
129180: PUSH
129181: LD_INT 600
129183: PUSH
129184: EMPTY
129185: LIST
129186: LIST
129187: PUSH
129188: EMPTY
129189: LIST
129190: LIST
129191: PPUSH
129192: CALL_OW 72
129196: OR
129197: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
129198: LD_VAR 0 4
129202: PPUSH
129203: CALL_OW 247
129207: PUSH
129208: LD_INT 2
129210: DOUBLE
129211: EQUAL
129212: IFTRUE 129216
129214: GO 129612
129216: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
129217: LD_VAR 0 4
129221: PPUSH
129222: CALL_OW 256
129226: PUSH
129227: LD_INT 1000
129229: EQUAL
129230: PUSH
129231: LD_VAR 0 4
129235: PPUSH
129236: LD_VAR 0 13
129240: PPUSH
129241: CALL_OW 296
129245: PUSH
129246: LD_INT 40
129248: LESS
129249: PUSH
129250: LD_VAR 0 13
129254: PPUSH
129255: LD_EXP 141
129259: PUSH
129260: LD_VAR 0 1
129264: ARRAY
129265: PPUSH
129266: CALL_OW 308
129270: OR
129271: AND
129272: IFFALSE 129394
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
129274: LD_VAR 0 4
129278: PPUSH
129279: CALL_OW 262
129283: PUSH
129284: LD_INT 1
129286: EQUAL
129287: PUSH
129288: LD_VAR 0 4
129292: PPUSH
129293: CALL_OW 261
129297: PUSH
129298: LD_INT 30
129300: LESS
129301: AND
129302: PUSH
129303: LD_VAR 0 7
129307: AND
129308: IFFALSE 129378
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
129310: LD_VAR 0 4
129314: PPUSH
129315: LD_VAR 0 7
129319: PPUSH
129320: LD_VAR 0 4
129324: PPUSH
129325: CALL_OW 74
129329: PPUSH
129330: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
129334: LD_VAR 0 4
129338: PPUSH
129339: LD_VAR 0 7
129343: PPUSH
129344: LD_VAR 0 4
129348: PPUSH
129349: CALL_OW 74
129353: PPUSH
129354: CALL_OW 296
129358: PUSH
129359: LD_INT 6
129361: LESS
129362: IFFALSE 129376
// SetFuel ( i , 100 ) ;
129364: LD_VAR 0 4
129368: PPUSH
129369: LD_INT 100
129371: PPUSH
129372: CALL_OW 240
// end else
129376: GO 129392
// ComAttackUnit ( i , e ) ;
129378: LD_VAR 0 4
129382: PPUSH
129383: LD_VAR 0 13
129387: PPUSH
129388: CALL_OW 115
// end else
129392: GO 129495
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
129394: LD_VAR 0 13
129398: PPUSH
129399: LD_EXP 141
129403: PUSH
129404: LD_VAR 0 1
129408: ARRAY
129409: PPUSH
129410: CALL_OW 308
129414: NOT
129415: PUSH
129416: LD_VAR 0 4
129420: PPUSH
129421: LD_VAR 0 13
129425: PPUSH
129426: CALL_OW 296
129430: PUSH
129431: LD_INT 40
129433: GREATEREQUAL
129434: AND
129435: PUSH
129436: LD_VAR 0 4
129440: PPUSH
129441: CALL_OW 256
129445: PUSH
129446: LD_INT 650
129448: LESSEQUAL
129449: OR
129450: PUSH
129451: LD_VAR 0 4
129455: PPUSH
129456: LD_EXP 140
129460: PUSH
129461: LD_VAR 0 1
129465: ARRAY
129466: PPUSH
129467: CALL_OW 308
129471: NOT
129472: AND
129473: IFFALSE 129495
// ComMoveToArea ( i , mc_parking [ base ] ) ;
129475: LD_VAR 0 4
129479: PPUSH
129480: LD_EXP 140
129484: PUSH
129485: LD_VAR 0 1
129489: ARRAY
129490: PPUSH
129491: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
129495: LD_VAR 0 4
129499: PPUSH
129500: CALL_OW 256
129504: PUSH
129505: LD_INT 1000
129507: LESS
129508: PUSH
129509: LD_VAR 0 4
129513: PPUSH
129514: CALL_OW 263
129518: PUSH
129519: LD_INT 1
129521: EQUAL
129522: AND
129523: PUSH
129524: LD_VAR 0 4
129528: PPUSH
129529: CALL_OW 311
129533: AND
129534: PUSH
129535: LD_VAR 0 4
129539: PPUSH
129540: LD_EXP 140
129544: PUSH
129545: LD_VAR 0 1
129549: ARRAY
129550: PPUSH
129551: CALL_OW 308
129555: AND
129556: IFFALSE 129610
// begin mech := IsDrivenBy ( i ) ;
129558: LD_ADDR_VAR 0 9
129562: PUSH
129563: LD_VAR 0 4
129567: PPUSH
129568: CALL_OW 311
129572: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
129573: LD_VAR 0 9
129577: PPUSH
129578: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
129582: LD_VAR 0 9
129586: PPUSH
129587: LD_VAR 0 4
129591: PPUSH
129592: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
129596: LD_VAR 0 9
129600: PPUSH
129601: LD_VAR 0 4
129605: PPUSH
129606: CALL_OW 180
// end ; end ; unit_human :
129610: GO 129957
129612: LD_INT 1
129614: DOUBLE
129615: EQUAL
129616: IFTRUE 129620
129618: GO 129956
129620: POP
// begin b := IsInUnit ( i ) ;
129621: LD_ADDR_VAR 0 18
129625: PUSH
129626: LD_VAR 0 4
129630: PPUSH
129631: CALL_OW 310
129635: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
129636: LD_ADDR_VAR 0 19
129640: PUSH
129641: LD_VAR 0 18
129645: NOT
129646: PUSH
129647: LD_VAR 0 18
129651: PPUSH
129652: CALL_OW 266
129656: PUSH
129657: LD_INT 32
129659: PUSH
129660: LD_INT 31
129662: PUSH
129663: EMPTY
129664: LIST
129665: LIST
129666: IN
129667: OR
129668: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
129669: LD_VAR 0 18
129673: PPUSH
129674: CALL_OW 266
129678: PUSH
129679: LD_INT 5
129681: EQUAL
129682: PUSH
129683: LD_VAR 0 4
129687: PPUSH
129688: CALL_OW 257
129692: PUSH
129693: LD_INT 1
129695: PUSH
129696: LD_INT 2
129698: PUSH
129699: LD_INT 3
129701: PUSH
129702: LD_INT 4
129704: PUSH
129705: EMPTY
129706: LIST
129707: LIST
129708: LIST
129709: LIST
129710: IN
129711: AND
129712: IFFALSE 129749
// begin class := AllowSpecClass ( i ) ;
129714: LD_ADDR_VAR 0 20
129718: PUSH
129719: LD_VAR 0 4
129723: PPUSH
129724: CALL 67671 0 1
129728: ST_TO_ADDR
// if class then
129729: LD_VAR 0 20
129733: IFFALSE 129749
// ComChangeProfession ( i , class ) ;
129735: LD_VAR 0 4
129739: PPUSH
129740: LD_VAR 0 20
129744: PPUSH
129745: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
129749: LD_VAR 0 16
129753: PUSH
129754: LD_VAR 0 2
129758: PPUSH
129759: LD_INT 21
129761: PUSH
129762: LD_INT 2
129764: PUSH
129765: EMPTY
129766: LIST
129767: LIST
129768: PPUSH
129769: CALL_OW 72
129773: PUSH
129774: LD_INT 1
129776: LESSEQUAL
129777: OR
129778: PUSH
129779: LD_VAR 0 19
129783: AND
129784: PUSH
129785: LD_VAR 0 4
129789: PUSH
129790: LD_VAR 0 17
129794: IN
129795: NOT
129796: AND
129797: IFFALSE 129890
// begin if b then
129799: LD_VAR 0 18
129803: IFFALSE 129852
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
129805: LD_VAR 0 18
129809: PPUSH
129810: LD_VAR 0 21
129814: PPUSH
129815: LD_VAR 0 18
129819: PPUSH
129820: CALL_OW 74
129824: PPUSH
129825: CALL_OW 296
129829: PUSH
129830: LD_INT 10
129832: LESS
129833: PUSH
129834: LD_VAR 0 18
129838: PPUSH
129839: CALL_OW 461
129843: PUSH
129844: LD_INT 7
129846: NONEQUAL
129847: AND
129848: IFFALSE 129852
// continue ;
129850: GO 129087
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
129852: LD_ADDR_VAR 0 17
129856: PUSH
129857: LD_VAR 0 17
129861: PPUSH
129862: LD_VAR 0 17
129866: PUSH
129867: LD_INT 1
129869: PLUS
129870: PPUSH
129871: LD_VAR 0 4
129875: PPUSH
129876: CALL_OW 1
129880: ST_TO_ADDR
// ComExitBuilding ( i ) ;
129881: LD_VAR 0 4
129885: PPUSH
129886: CALL_OW 122
// end ; if sold_defenders then
129890: LD_VAR 0 17
129894: IFFALSE 129954
// if i in sold_defenders then
129896: LD_VAR 0 4
129900: PUSH
129901: LD_VAR 0 17
129905: IN
129906: IFFALSE 129954
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
129908: LD_VAR 0 4
129912: PPUSH
129913: CALL_OW 314
129917: NOT
129918: PUSH
129919: LD_VAR 0 4
129923: PPUSH
129924: LD_VAR 0 13
129928: PPUSH
129929: CALL_OW 296
129933: PUSH
129934: LD_INT 30
129936: LESS
129937: AND
129938: IFFALSE 129954
// ComAttackUnit ( i , e ) ;
129940: LD_VAR 0 4
129944: PPUSH
129945: LD_VAR 0 13
129949: PPUSH
129950: CALL_OW 115
// end ; end ; end ;
129954: GO 129957
129956: POP
// if IsDead ( i ) then
129957: LD_VAR 0 4
129961: PPUSH
129962: CALL_OW 301
129966: IFFALSE 129984
// defenders := defenders diff i ;
129968: LD_ADDR_VAR 0 2
129972: PUSH
129973: LD_VAR 0 2
129977: PUSH
129978: LD_VAR 0 4
129982: DIFF
129983: ST_TO_ADDR
// end ;
129984: GO 129087
129986: POP
129987: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
129988: LD_VAR 0 21
129992: NOT
129993: PUSH
129994: LD_VAR 0 2
129998: NOT
129999: OR
130000: PUSH
130001: LD_EXP 116
130005: PUSH
130006: LD_VAR 0 1
130010: ARRAY
130011: NOT
130012: OR
130013: IFFALSE 128991
// MC_Reset ( base , 18 ) ;
130015: LD_VAR 0 1
130019: PPUSH
130020: LD_INT 18
130022: PPUSH
130023: CALL 39413 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
130027: LD_ADDR_VAR 0 2
130031: PUSH
130032: LD_VAR 0 2
130036: PUSH
130037: LD_VAR 0 2
130041: PPUSH
130042: LD_INT 2
130044: PUSH
130045: LD_INT 25
130047: PUSH
130048: LD_INT 1
130050: PUSH
130051: EMPTY
130052: LIST
130053: LIST
130054: PUSH
130055: LD_INT 25
130057: PUSH
130058: LD_INT 5
130060: PUSH
130061: EMPTY
130062: LIST
130063: LIST
130064: PUSH
130065: LD_INT 25
130067: PUSH
130068: LD_INT 8
130070: PUSH
130071: EMPTY
130072: LIST
130073: LIST
130074: PUSH
130075: LD_INT 25
130077: PUSH
130078: LD_INT 9
130080: PUSH
130081: EMPTY
130082: LIST
130083: LIST
130084: PUSH
130085: EMPTY
130086: LIST
130087: LIST
130088: LIST
130089: LIST
130090: LIST
130091: PPUSH
130092: CALL_OW 72
130096: DIFF
130097: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
130098: LD_VAR 0 21
130102: NOT
130103: PUSH
130104: LD_VAR 0 2
130108: PPUSH
130109: LD_INT 21
130111: PUSH
130112: LD_INT 2
130114: PUSH
130115: EMPTY
130116: LIST
130117: LIST
130118: PPUSH
130119: CALL_OW 72
130123: AND
130124: IFFALSE 130462
// begin tmp := FilterByTag ( defenders , 19 ) ;
130126: LD_ADDR_VAR 0 11
130130: PUSH
130131: LD_VAR 0 2
130135: PPUSH
130136: LD_INT 19
130138: PPUSH
130139: CALL 100140 0 2
130143: ST_TO_ADDR
// if tmp then
130144: LD_VAR 0 11
130148: IFFALSE 130218
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
130150: LD_ADDR_VAR 0 11
130154: PUSH
130155: LD_VAR 0 11
130159: PPUSH
130160: LD_INT 25
130162: PUSH
130163: LD_INT 3
130165: PUSH
130166: EMPTY
130167: LIST
130168: LIST
130169: PPUSH
130170: CALL_OW 72
130174: ST_TO_ADDR
// if tmp then
130175: LD_VAR 0 11
130179: IFFALSE 130218
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
130181: LD_ADDR_EXP 128
130185: PUSH
130186: LD_EXP 128
130190: PPUSH
130191: LD_VAR 0 1
130195: PPUSH
130196: LD_EXP 128
130200: PUSH
130201: LD_VAR 0 1
130205: ARRAY
130206: PUSH
130207: LD_VAR 0 11
130211: UNION
130212: PPUSH
130213: CALL_OW 1
130217: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
130218: LD_VAR 0 1
130222: PPUSH
130223: LD_INT 19
130225: PPUSH
130226: CALL 39413 0 2
// repeat wait ( 0 0$1 ) ;
130230: LD_INT 35
130232: PPUSH
130233: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
130237: LD_EXP 116
130241: PUSH
130242: LD_VAR 0 1
130246: ARRAY
130247: NOT
130248: PUSH
130249: LD_EXP 116
130253: PUSH
130254: LD_VAR 0 1
130258: ARRAY
130259: PUSH
130260: EMPTY
130261: EQUAL
130262: OR
130263: IFFALSE 130300
// begin for i in defenders do
130265: LD_ADDR_VAR 0 4
130269: PUSH
130270: LD_VAR 0 2
130274: PUSH
130275: FOR_IN
130276: IFFALSE 130289
// ComStop ( i ) ;
130278: LD_VAR 0 4
130282: PPUSH
130283: CALL_OW 141
130287: GO 130275
130289: POP
130290: POP
// defenders := [ ] ;
130291: LD_ADDR_VAR 0 2
130295: PUSH
130296: EMPTY
130297: ST_TO_ADDR
// exit ;
130298: GO 130526
// end ; for i in defenders do
130300: LD_ADDR_VAR 0 4
130304: PUSH
130305: LD_VAR 0 2
130309: PUSH
130310: FOR_IN
130311: IFFALSE 130400
// begin if not IsInArea ( i , mc_parking [ base ] ) then
130313: LD_VAR 0 4
130317: PPUSH
130318: LD_EXP 140
130322: PUSH
130323: LD_VAR 0 1
130327: ARRAY
130328: PPUSH
130329: CALL_OW 308
130333: NOT
130334: IFFALSE 130358
// ComMoveToArea ( i , mc_parking [ base ] ) else
130336: LD_VAR 0 4
130340: PPUSH
130341: LD_EXP 140
130345: PUSH
130346: LD_VAR 0 1
130350: ARRAY
130351: PPUSH
130352: CALL_OW 113
130356: GO 130398
// if GetControl ( i ) = control_manual then
130358: LD_VAR 0 4
130362: PPUSH
130363: CALL_OW 263
130367: PUSH
130368: LD_INT 1
130370: EQUAL
130371: IFFALSE 130398
// if IsDrivenBy ( i ) then
130373: LD_VAR 0 4
130377: PPUSH
130378: CALL_OW 311
130382: IFFALSE 130398
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
130384: LD_VAR 0 4
130388: PPUSH
130389: CALL_OW 311
130393: PPUSH
130394: CALL_OW 121
// end ;
130398: GO 130310
130400: POP
130401: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
130402: LD_VAR 0 2
130406: PPUSH
130407: LD_INT 95
130409: PUSH
130410: LD_EXP 140
130414: PUSH
130415: LD_VAR 0 1
130419: ARRAY
130420: PUSH
130421: EMPTY
130422: LIST
130423: LIST
130424: PPUSH
130425: CALL_OW 72
130429: PUSH
130430: LD_VAR 0 2
130434: EQUAL
130435: PUSH
130436: LD_EXP 139
130440: PUSH
130441: LD_VAR 0 1
130445: ARRAY
130446: OR
130447: PUSH
130448: LD_EXP 116
130452: PUSH
130453: LD_VAR 0 1
130457: ARRAY
130458: NOT
130459: OR
130460: IFFALSE 130230
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
130462: LD_ADDR_EXP 138
130466: PUSH
130467: LD_EXP 138
130471: PPUSH
130472: LD_VAR 0 1
130476: PPUSH
130477: LD_VAR 0 2
130481: PPUSH
130482: LD_INT 21
130484: PUSH
130485: LD_INT 2
130487: PUSH
130488: EMPTY
130489: LIST
130490: LIST
130491: PPUSH
130492: CALL_OW 72
130496: PPUSH
130497: CALL_OW 1
130501: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
130502: LD_VAR 0 1
130506: PPUSH
130507: LD_INT 19
130509: PPUSH
130510: CALL 39413 0 2
// MC_Reset ( base , 20 ) ;
130514: LD_VAR 0 1
130518: PPUSH
130519: LD_INT 20
130521: PPUSH
130522: CALL 39413 0 2
// end ; end_of_file
130526: LD_VAR 0 3
130530: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
130531: LD_VAR 0 1
130535: PUSH
130536: LD_INT 200
130538: DOUBLE
130539: GREATEREQUAL
130540: IFFALSE 130548
130542: LD_INT 299
130544: DOUBLE
130545: LESSEQUAL
130546: IFTRUE 130550
130548: GO 130582
130550: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
130551: LD_VAR 0 1
130555: PPUSH
130556: LD_VAR 0 2
130560: PPUSH
130561: LD_VAR 0 3
130565: PPUSH
130566: LD_VAR 0 4
130570: PPUSH
130571: LD_VAR 0 5
130575: PPUSH
130576: CALL 119347 0 5
130580: GO 130659
130582: LD_INT 300
130584: DOUBLE
130585: GREATEREQUAL
130586: IFFALSE 130594
130588: LD_INT 399
130590: DOUBLE
130591: LESSEQUAL
130592: IFTRUE 130596
130594: GO 130658
130596: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
130597: LD_VAR 0 1
130601: PPUSH
130602: LD_VAR 0 2
130606: PPUSH
130607: LD_VAR 0 3
130611: PPUSH
130612: LD_VAR 0 4
130616: PPUSH
130617: LD_VAR 0 5
130621: PPUSH
130622: LD_VAR 0 6
130626: PPUSH
130627: LD_VAR 0 7
130631: PPUSH
130632: LD_VAR 0 8
130636: PPUSH
130637: LD_VAR 0 9
130641: PPUSH
130642: LD_VAR 0 10
130646: PPUSH
130647: LD_VAR 0 11
130651: PPUSH
130652: CALL 117245 0 11
130656: GO 130659
130658: POP
// end ;
130659: PPOPN 11
130661: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
130662: LD_VAR 0 1
130666: PPUSH
130667: LD_VAR 0 2
130671: PPUSH
130672: LD_VAR 0 3
130676: PPUSH
130677: LD_VAR 0 4
130681: PPUSH
130682: LD_VAR 0 5
130686: PPUSH
130687: CALL 119339 0 5
// end ; end_of_file
130691: PPOPN 5
130693: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
130694: LD_VAR 0 1
130698: PPUSH
130699: LD_VAR 0 2
130703: PPUSH
130704: LD_VAR 0 3
130708: PPUSH
130709: LD_VAR 0 4
130713: PPUSH
130714: LD_VAR 0 5
130718: PPUSH
130719: LD_VAR 0 6
130723: PPUSH
130724: CALL 105440 0 6
// end ;
130728: PPOPN 6
130730: END
